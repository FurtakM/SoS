// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34970 0 0
// InitMacro ;
  19: CALL 35114 0 0
// InitNature ;
  23: CALL 34838 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37226 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 137
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 138
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59535 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59628 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 58978 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 58793 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59535 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59628 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 58793 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 58978 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59408 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58475 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59535 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59628 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 142
 959: PUSH
 960: LD_EXP 142
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 58793 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59535 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59628 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58685 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 59946 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59117 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59408 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59408 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59740 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 58793 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59359 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65204 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70028 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70028 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70028 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70028 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70028 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65204 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65204 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65204 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65204 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65204 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65204 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65204 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65204 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65204 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65204 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65204 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65204 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65204 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65204 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65204 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65204 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65204 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65204 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65204 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65204 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65204 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65204 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65204 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65204 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65204 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65204 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65204 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65204 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70028 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65204 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65204 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65204 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73437 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 113
4739: PUSH
4740: LD_EXP 113
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70028 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 58978 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 58841 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60259 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 58841 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 58841 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60259 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60259 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 132
6023: PUSH
6024: LD_EXP 132
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 132
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70028 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65204 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73437 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 113
7483: PUSH
7484: LD_EXP 113
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 101193 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 101193 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 101254 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 101254 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70028 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70028 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70028 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70028 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70028 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70028 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70028 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70028 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65204 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60259 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 58841 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 58841 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60259 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60259 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 132
10579: PUSH
10580: LD_EXP 132
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 132
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65204 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 113
11990: PUSH
11991: LD_EXP 113
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 101298 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 58841 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 58841 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60259 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60259 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 132
13374: PUSH
13375: LD_EXP 132
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 132
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70028 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70028 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70028 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70028 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 101165 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 101079 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 101079 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 101079 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 101079 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 101079 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 101079 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 101079 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 101079 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 101079 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 101165 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 113
17039: PUSH
17040: LD_EXP 113
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 101165 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 101165 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 132
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 99699 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 99699 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 113
19216: PUSH
19217: LD_EXP 113
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 113
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 132
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 132
19588: PUSH
19589: LD_EXP 132
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 132
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 113
20048: PUSH
20049: LD_EXP 113
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 113
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70028 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 58793 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 132
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 132
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 132
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35349 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 101165 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70028 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73083 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 101165 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65267 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35349 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65204 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65204 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65204 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70028 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 101254 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 98799 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 98799 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 1 ) ;
29795: LD_INT 1
29797: PPUSH
29798: CALL 35349 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35349 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 98799 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 113
32464: PUSH
32465: LD_EXP 113
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 113
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 21
32737: PUSH
32738: LD_INT 2
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 50
32747: PUSH
32748: EMPTY
32749: LIST
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: LIST
32755: PPUSH
32756: CALL_OW 69
32760: PUSH
32761: LD_INT 0
32763: EQUAL
32764: AND
32765: PUSH
32766: LD_EXP 21
32770: AND
32771: PUSH
32772: LD_EXP 22
32776: AND
32777: PUSH
32778: LD_EXP 23
32782: AND
32783: IFFALSE 33425
32785: GO 32787
32787: DISABLE
32788: LD_INT 0
32790: PPUSH
32791: PPUSH
32792: PPUSH
// begin m1 := false ;
32793: LD_ADDR_VAR 0 1
32797: PUSH
32798: LD_INT 0
32800: ST_TO_ADDR
// m2 := false ;
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: LD_INT 0
32808: ST_TO_ADDR
// m3 := false ;
32809: LD_ADDR_VAR 0 3
32813: PUSH
32814: LD_INT 0
32816: ST_TO_ADDR
// if not bombExploded then
32817: LD_EXP 37
32821: NOT
32822: IFFALSE 32831
// SetAchievement ( ACH_SIBROCKET ) ;
32824: LD_STRING ACH_SIBROCKET
32826: PPUSH
32827: CALL_OW 543
// if tick <= 120 120$00 then
32831: LD_OWVAR 1
32835: PUSH
32836: LD_INT 252000
32838: LESSEQUAL
32839: IFFALSE 32855
// begin wait ( 3 ) ;
32841: LD_INT 3
32843: PPUSH
32844: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32848: LD_STRING ACH_ASPEED_15
32850: PPUSH
32851: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32855: LD_EXP 39
32859: PPUSH
32860: CALL_OW 87
// music_class := 5 ;
32864: LD_ADDR_OWVAR 72
32868: PUSH
32869: LD_INT 5
32871: ST_TO_ADDR
// music_nat := 5 ;
32872: LD_ADDR_OWVAR 71
32876: PUSH
32877: LD_INT 5
32879: ST_TO_ADDR
// DialogueOn ;
32880: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32884: LD_EXP 39
32888: PPUSH
32889: LD_STRING D20-JMM-1
32891: PPUSH
32892: CALL_OW 88
// if IsOK ( Joan ) then
32896: LD_EXP 40
32900: PPUSH
32901: CALL_OW 302
32905: IFFALSE 32919
// Say ( Joan , D20-Joan-1 ) ;
32907: LD_EXP 40
32911: PPUSH
32912: LD_STRING D20-Joan-1
32914: PPUSH
32915: CALL_OW 88
// if IsOk ( Lisa ) then
32919: LD_EXP 42
32923: PPUSH
32924: CALL_OW 302
32928: IFFALSE 32942
// Say ( Lisa , D20-Lisa-1 ) ;
32930: LD_EXP 42
32934: PPUSH
32935: LD_STRING D20-Lisa-1
32937: PPUSH
32938: CALL_OW 88
// if IsOk ( Donaldson ) then
32942: LD_EXP 43
32946: PPUSH
32947: CALL_OW 302
32951: IFFALSE 32965
// Say ( Donaldson , D20-Don-1 ) ;
32953: LD_EXP 43
32957: PPUSH
32958: LD_STRING D20-Don-1
32960: PPUSH
32961: CALL_OW 88
// if IsOK ( Cornel ) then
32965: LD_EXP 50
32969: PPUSH
32970: CALL_OW 302
32974: IFFALSE 32988
// Say ( Cornel , D20-Corn-1 ) ;
32976: LD_EXP 50
32980: PPUSH
32981: LD_STRING D20-Corn-1
32983: PPUSH
32984: CALL_OW 88
// if IsOk ( Denis ) then
32988: LD_EXP 46
32992: PPUSH
32993: CALL_OW 302
32997: IFFALSE 33011
// Say ( Denis , D20-Den-1 ) ;
32999: LD_EXP 46
33003: PPUSH
33004: LD_STRING D20-Den-1
33006: PPUSH
33007: CALL_OW 88
// if IsOk ( Bobby ) then
33011: LD_EXP 44
33015: PPUSH
33016: CALL_OW 302
33020: IFFALSE 33034
// Say ( Bobby , D20-Bobby-1 ) ;
33022: LD_EXP 44
33026: PPUSH
33027: LD_STRING D20-Bobby-1
33029: PPUSH
33030: CALL_OW 88
// if IsOk ( Gladstone ) then
33034: LD_EXP 48
33038: PPUSH
33039: CALL_OW 302
33043: IFFALSE 33057
// Say ( Gladstone , D20-Glad-1 ) ;
33045: LD_EXP 48
33049: PPUSH
33050: LD_STRING D20-Glad-1
33052: PPUSH
33053: CALL_OW 88
// if IsOk ( Cyrus ) then
33057: LD_EXP 45
33061: PPUSH
33062: CALL_OW 302
33066: IFFALSE 33080
// Say ( Cyrus , D20-Cyrus-1 ) ;
33068: LD_EXP 45
33072: PPUSH
33073: LD_STRING D20-Cyrus-1
33075: PPUSH
33076: CALL_OW 88
// if IsOk ( Stevens ) then
33080: LD_EXP 41
33084: PPUSH
33085: CALL_OW 302
33089: IFFALSE 33103
// Say ( Stevens , D20-Huck-1 ) ;
33091: LD_EXP 41
33095: PPUSH
33096: LD_STRING D20-Huck-1
33098: PPUSH
33099: CALL_OW 88
// if IsOk ( Brown ) then
33103: LD_EXP 47
33107: PPUSH
33108: CALL_OW 302
33112: IFFALSE 33126
// Say ( Brown , D20-Brown-1 ) ;
33114: LD_EXP 47
33118: PPUSH
33119: LD_STRING D20-Brown-1
33121: PPUSH
33122: CALL_OW 88
// if IsOk ( Gary ) then
33126: LD_EXP 51
33130: PPUSH
33131: CALL_OW 302
33135: IFFALSE 33149
// Say ( Gary , D20-Gary-1 ) ;
33137: LD_EXP 51
33141: PPUSH
33142: LD_STRING D20-Gary-1
33144: PPUSH
33145: CALL_OW 88
// if IsOk ( Connie ) then
33149: LD_EXP 54
33153: PPUSH
33154: CALL_OW 302
33158: IFFALSE 33172
// Say ( Connie , D20-Con-1 ) ;
33160: LD_EXP 54
33164: PPUSH
33165: LD_STRING D20-Con-1
33167: PPUSH
33168: CALL_OW 88
// if IsOk ( Kurt ) then
33172: LD_EXP 60
33176: PPUSH
33177: CALL_OW 302
33181: IFFALSE 33195
// Say ( Kurt , D20-Kurt-1 ) ;
33183: LD_EXP 60
33187: PPUSH
33188: LD_STRING D20-Kurt-1
33190: PPUSH
33191: CALL_OW 88
// if IsOk ( Kikuchi ) then
33195: LD_EXP 53
33199: PPUSH
33200: CALL_OW 302
33204: IFFALSE 33218
// Say ( Kikuchi , D20-Yam-1 ) ;
33206: LD_EXP 53
33210: PPUSH
33211: LD_STRING D20-Yam-1
33213: PPUSH
33214: CALL_OW 88
// if IsOk ( Frank ) then
33218: LD_EXP 52
33222: PPUSH
33223: CALL_OW 302
33227: IFFALSE 33241
// Say ( Frank , D20-Frank-1 ) ;
33229: LD_EXP 52
33233: PPUSH
33234: LD_STRING D20-Frank-1
33236: PPUSH
33237: CALL_OW 88
// DialogueOff ;
33241: CALL_OW 7
// if RothCaptured then
33245: LD_EXP 33
33249: IFFALSE 33271
// begin m1 := true ;
33251: LD_ADDR_VAR 0 1
33255: PUSH
33256: LD_INT 1
33258: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33259: LD_STRING Roth
33261: PPUSH
33262: LD_INT 1
33264: PPUSH
33265: CALL_OW 101
// end else
33269: GO 33282
// AddMedal ( Roth , - 1 ) ;
33271: LD_STRING Roth
33273: PPUSH
33274: LD_INT 1
33276: NEG
33277: PPUSH
33278: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33282: LD_EXP 27
33286: IFFALSE 33308
// begin m2 := true ;
33288: LD_ADDR_VAR 0 2
33292: PUSH
33293: LD_INT 1
33295: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33296: LD_STRING Project
33298: PPUSH
33299: LD_INT 1
33301: PPUSH
33302: CALL_OW 101
// end else
33306: GO 33319
// AddMedal ( Project , - 1 ) ;
33308: LD_STRING Project
33310: PPUSH
33311: LD_INT 1
33313: NEG
33314: PPUSH
33315: CALL_OW 101
// if lostCounter = 0 then
33319: LD_EXP 32
33323: PUSH
33324: LD_INT 0
33326: EQUAL
33327: IFFALSE 33349
// begin m3 := true ;
33329: LD_ADDR_VAR 0 3
33333: PUSH
33334: LD_INT 1
33336: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33337: LD_STRING NoLosses
33339: PPUSH
33340: LD_INT 1
33342: PPUSH
33343: CALL_OW 101
// end else
33347: GO 33360
// AddMedal ( NoLosses , - 1 ) ;
33349: LD_STRING NoLosses
33351: PPUSH
33352: LD_INT 1
33354: NEG
33355: PPUSH
33356: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33360: LD_VAR 0 1
33364: PUSH
33365: LD_VAR 0 2
33369: AND
33370: PUSH
33371: LD_VAR 0 3
33375: AND
33376: PUSH
33377: LD_OWVAR 67
33381: PUSH
33382: LD_INT 3
33384: EQUAL
33385: AND
33386: IFFALSE 33398
// SetAchievementEX ( ACH_AMER , 15 ) ;
33388: LD_STRING ACH_AMER
33390: PPUSH
33391: LD_INT 15
33393: PPUSH
33394: CALL_OW 564
// GiveMedals ( MAIN ) ;
33398: LD_STRING MAIN
33400: PPUSH
33401: CALL_OW 102
// music_class := 4 ;
33405: LD_ADDR_OWVAR 72
33409: PUSH
33410: LD_INT 4
33412: ST_TO_ADDR
// music_nat := 1 ;
33413: LD_ADDR_OWVAR 71
33417: PUSH
33418: LD_INT 1
33420: ST_TO_ADDR
// YouWin ;
33421: CALL_OW 103
// end ; end_of_file
33425: PPOPN 3
33427: END
// export function CustomEvent ( event ) ; begin
33428: LD_INT 0
33430: PPUSH
// end ;
33431: LD_VAR 0 2
33435: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33436: LD_VAR 0 1
33440: PUSH
33441: LD_INT 1
33443: EQUAL
33444: PUSH
33445: LD_VAR 0 2
33449: PUSH
33450: LD_INT 4
33452: EQUAL
33453: AND
33454: PUSH
33455: LD_EXP 58
33459: PPUSH
33460: CALL_OW 300
33464: AND
33465: IFFALSE 33481
// begin wait ( 0 0$2 ) ;
33467: LD_INT 70
33469: PPUSH
33470: CALL_OW 67
// YouLost ( Dismissed ) ;
33474: LD_STRING Dismissed
33476: PPUSH
33477: CALL_OW 104
// end ; end ;
33481: PPOPN 2
33483: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33484: LD_VAR 0 2
33488: PPUSH
33489: LD_VAR 0 3
33493: PPUSH
33494: LD_INT 18
33496: PPUSH
33497: CALL_OW 309
33501: IFFALSE 33510
// YouLost ( Motherlode3 ) ;
33503: LD_STRING Motherlode3
33505: PPUSH
33506: CALL_OW 104
// end ;
33510: PPOPN 3
33512: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33513: LD_EXP 27
33517: NOT
33518: IFFALSE 33528
// behemothDone := true ;
33520: LD_ADDR_EXP 28
33524: PUSH
33525: LD_INT 1
33527: ST_TO_ADDR
// end ;
33528: PPOPN 1
33530: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33531: LD_VAR 0 1
33535: PPUSH
33536: CALL_OW 255
33540: PUSH
33541: LD_INT 1
33543: EQUAL
33544: IFFALSE 33554
// bombExploded := true ;
33546: LD_ADDR_EXP 37
33550: PUSH
33551: LD_INT 1
33553: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33554: LD_VAR 0 1
33558: PPUSH
33559: CALL_OW 255
33563: PUSH
33564: LD_INT 1
33566: EQUAL
33567: PUSH
33568: LD_EXP 30
33572: AND
33573: PUSH
33574: LD_INT 22
33576: PUSH
33577: LD_INT 3
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 34
33586: PUSH
33587: LD_INT 48
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PPUSH
33598: CALL_OW 69
33602: AND
33603: PUSH
33604: LD_INT 22
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 34
33616: PUSH
33617: LD_INT 8
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PPUSH
33628: CALL_OW 69
33632: NOT
33633: AND
33634: IFFALSE 33686
// begin wait ( 0 0$5 ) ;
33636: LD_INT 175
33638: PPUSH
33639: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33643: LD_INT 22
33645: PUSH
33646: LD_INT 3
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 34
33655: PUSH
33656: LD_INT 48
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PPUSH
33667: CALL_OW 69
33671: PUSH
33672: LD_INT 1
33674: ARRAY
33675: PPUSH
33676: LD_INT 60
33678: PPUSH
33679: LD_INT 95
33681: PPUSH
33682: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33686: LD_VAR 0 2
33690: PPUSH
33691: LD_VAR 0 3
33695: PPUSH
33696: LD_INT 18
33698: PPUSH
33699: CALL_OW 309
33703: IFFALSE 33763
// begin if GetSide ( unit ) = 1 then
33705: LD_VAR 0 1
33709: PPUSH
33710: CALL_OW 255
33714: PUSH
33715: LD_INT 1
33717: EQUAL
33718: IFFALSE 33734
// begin wait ( 0 0$6 ) ;
33720: LD_INT 210
33722: PPUSH
33723: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33727: LD_STRING Motherlode2
33729: PPUSH
33730: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33734: LD_VAR 0 1
33738: PPUSH
33739: CALL_OW 255
33743: PUSH
33744: LD_INT 8
33746: EQUAL
33747: IFFALSE 33763
// begin wait ( 0 0$6 ) ;
33749: LD_INT 210
33751: PPUSH
33752: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33756: LD_STRING Motherlode1
33758: PPUSH
33759: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33763: LD_VAR 0 1
33767: PPUSH
33768: CALL_OW 255
33772: PUSH
33773: LD_INT 3
33775: EQUAL
33776: IFFALSE 33797
// begin wait ( 0 0$5 ) ;
33778: LD_INT 175
33780: PPUSH
33781: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33785: LD_EXP 64
33789: PPUSH
33790: LD_STRING D18-Pla-1
33792: PPUSH
33793: CALL_OW 94
// end ; end ;
33797: PPOPN 3
33799: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33800: LD_VAR 0 1
33804: PUSH
33805: LD_INT 22
33807: PUSH
33808: LD_INT 1
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 21
33817: PUSH
33818: LD_INT 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 23
33827: PUSH
33828: LD_INT 1
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: LIST
33839: PPUSH
33840: CALL_OW 69
33844: IN
33845: IFFALSE 33861
// lostCounter := lostCounter + 1 ;
33847: LD_ADDR_EXP 32
33851: PUSH
33852: LD_EXP 32
33856: PUSH
33857: LD_INT 1
33859: PLUS
33860: ST_TO_ADDR
// if un in behemothBuilders then
33861: LD_VAR 0 1
33865: PUSH
33866: LD_EXP 73
33870: IN
33871: IFFALSE 33891
// begin behemothBuilders := behemothBuilders diff un ;
33873: LD_ADDR_EXP 73
33877: PUSH
33878: LD_EXP 73
33882: PUSH
33883: LD_VAR 0 1
33887: DIFF
33888: ST_TO_ADDR
// exit ;
33889: GO 33921
// end ; if un = JMM then
33891: LD_VAR 0 1
33895: PUSH
33896: LD_EXP 39
33900: EQUAL
33901: IFFALSE 33912
// begin YouLost ( JMM ) ;
33903: LD_STRING JMM
33905: PPUSH
33906: CALL_OW 104
// exit ;
33910: GO 33921
// end ; MCE_UnitDestroyed ( un ) ;
33912: LD_VAR 0 1
33916: PPUSH
33917: CALL 62252 0 1
// end ;
33921: PPOPN 1
33923: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33924: LD_VAR 0 1
33928: PPUSH
33929: LD_VAR 0 2
33933: PPUSH
33934: CALL 64586 0 2
// end ;
33938: PPOPN 2
33940: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33941: LD_VAR 0 1
33945: PPUSH
33946: CALL 63654 0 1
// end ;
33950: PPOPN 1
33952: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33953: LD_VAR 0 1
33957: PUSH
33958: LD_INT 22
33960: PUSH
33961: LD_INT 8
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 30
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 23
33980: PUSH
33981: LD_INT 3
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: LIST
33992: PPUSH
33993: CALL_OW 69
33997: IN
33998: IFFALSE 34025
// begin ComUpgrade ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34009: LD_EXP 61
34013: PPUSH
34014: LD_VAR 0 1
34018: PPUSH
34019: CALL 73001 0 2
// exit ;
34023: GO 34034
// end ; MCE_BuildingComplete ( building ) ;
34025: LD_VAR 0 1
34029: PPUSH
34030: CALL 63895 0 1
// end ;
34034: PPOPN 1
34036: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34037: LD_VAR 0 1
34041: PPUSH
34042: LD_VAR 0 2
34046: PPUSH
34047: CALL 61948 0 2
// end ;
34051: PPOPN 2
34053: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34054: LD_VAR 0 1
34058: PPUSH
34059: LD_VAR 0 2
34063: PPUSH
34064: LD_VAR 0 3
34068: PPUSH
34069: LD_VAR 0 4
34073: PPUSH
34074: LD_VAR 0 5
34078: PPUSH
34079: CALL 61568 0 5
// end ;
34083: PPOPN 5
34085: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34086: LD_VAR 0 1
34090: PPUSH
34091: LD_VAR 0 2
34095: PPUSH
34096: CALL 61158 0 2
// end ;
34100: PPOPN 2
34102: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL 60996 0 4
// end ;
34127: PPOPN 4
34129: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: LD_VAR 0 3
34144: PPUSH
34145: CALL 60771 0 3
// end ;
34149: PPOPN 3
34151: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34152: LD_VAR 0 1
34156: PPUSH
34157: LD_VAR 0 2
34161: PPUSH
34162: CALL 60656 0 2
// end ;
34166: PPOPN 2
34168: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34169: LD_VAR 0 1
34173: PPUSH
34174: LD_VAR 0 2
34178: PPUSH
34179: CALL 64847 0 2
// end ;
34183: PPOPN 2
34185: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34186: LD_VAR 0 1
34190: PPUSH
34191: CALL_OW 255
34195: PUSH
34196: LD_INT 4
34198: EQUAL
34199: PUSH
34200: LD_VAR 0 1
34204: PUSH
34205: LD_EXP 18
34209: PUSH
34210: LD_INT 1
34212: ARRAY
34213: IN
34214: AND
34215: PUSH
34216: LD_EXP 19
34220: AND
34221: IFFALSE 34240
// begin ComMoveXY ( driver , 61 , 93 ) ;
34223: LD_VAR 0 1
34227: PPUSH
34228: LD_INT 61
34230: PPUSH
34231: LD_INT 93
34233: PPUSH
34234: CALL_OW 111
// exit ;
34238: GO 34264
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34240: LD_VAR 0 1
34244: PPUSH
34245: LD_VAR 0 2
34249: PPUSH
34250: LD_VAR 0 3
34254: PPUSH
34255: LD_VAR 0 4
34259: PPUSH
34260: CALL 65063 0 4
// end ;
34264: PPOPN 4
34266: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34267: LD_VAR 0 1
34271: PPUSH
34272: LD_VAR 0 2
34276: PPUSH
34277: CALL 60465 0 2
// end ;
34281: PPOPN 2
34283: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34284: LD_VAR 0 1
34288: PPUSH
34289: CALL 115546 0 1
// end ; end_of_file
34293: PPOPN 1
34295: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34296: LD_EXP 15
34300: PUSH
34301: LD_INT 2
34303: EQUAL
34304: IFFALSE 34783
34306: GO 34308
34308: DISABLE
34309: LD_INT 0
34311: PPUSH
// begin time := 0 0$40 ;
34312: LD_ADDR_VAR 0 1
34316: PUSH
34317: LD_INT 1400
34319: ST_TO_ADDR
// repeat wait ( time ) ;
34320: LD_VAR 0 1
34324: PPUSH
34325: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34329: LD_INT 1
34331: PPUSH
34332: LD_INT 5
34334: PPUSH
34335: CALL_OW 12
34339: PPUSH
34340: LD_INT 106
34342: PPUSH
34343: LD_INT 150
34345: PPUSH
34346: LD_INT 19
34348: PPUSH
34349: LD_INT 1
34351: PPUSH
34352: CALL_OW 56
// time := time + 0 0$9 ;
34356: LD_ADDR_VAR 0 1
34360: PUSH
34361: LD_VAR 0 1
34365: PUSH
34366: LD_INT 315
34368: PLUS
34369: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34370: LD_INT 455
34372: PPUSH
34373: LD_INT 840
34375: PPUSH
34376: CALL_OW 12
34380: PPUSH
34381: CALL_OW 67
// if Prob ( 50 ) then
34385: LD_INT 50
34387: PPUSH
34388: CALL_OW 13
34392: IFFALSE 34421
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34394: LD_INT 1
34396: PPUSH
34397: LD_INT 5
34399: PPUSH
34400: CALL_OW 12
34404: PPUSH
34405: LD_INT 62
34407: PPUSH
34408: LD_INT 108
34410: PPUSH
34411: LD_INT 10
34413: PPUSH
34414: LD_INT 1
34416: PPUSH
34417: CALL_OW 56
// until missionStage > 4 ;
34421: LD_EXP 15
34425: PUSH
34426: LD_INT 4
34428: GREATER
34429: IFFALSE 34320
// repeat wait ( 0 0$1 ) ;
34431: LD_INT 35
34433: PPUSH
34434: CALL_OW 67
// until missionStage = 6 ;
34438: LD_EXP 15
34442: PUSH
34443: LD_INT 6
34445: EQUAL
34446: IFFALSE 34431
// time := 0 0$50 ;
34448: LD_ADDR_VAR 0 1
34452: PUSH
34453: LD_INT 1750
34455: ST_TO_ADDR
// repeat wait ( time ) ;
34456: LD_VAR 0 1
34460: PPUSH
34461: CALL_OW 67
// if Prob ( 50 ) then
34465: LD_INT 50
34467: PPUSH
34468: CALL_OW 13
34472: IFFALSE 34501
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34474: LD_INT 1
34476: PPUSH
34477: LD_INT 5
34479: PPUSH
34480: CALL_OW 12
34484: PPUSH
34485: LD_INT 106
34487: PPUSH
34488: LD_INT 89
34490: PPUSH
34491: LD_INT 45
34493: PPUSH
34494: LD_INT 1
34496: PPUSH
34497: CALL_OW 56
// time := time + 0 0$2 ;
34501: LD_ADDR_VAR 0 1
34505: PUSH
34506: LD_VAR 0 1
34510: PUSH
34511: LD_INT 70
34513: PLUS
34514: ST_TO_ADDR
// if Prob ( 30 ) then
34515: LD_INT 30
34517: PPUSH
34518: CALL_OW 13
34522: IFFALSE 34568
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34524: LD_INT 385
34526: PPUSH
34527: LD_INT 945
34529: PPUSH
34530: CALL_OW 12
34534: PPUSH
34535: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34539: LD_INT 1
34541: PPUSH
34542: LD_INT 5
34544: PPUSH
34545: CALL_OW 12
34549: PPUSH
34550: LD_INT 21
34552: PPUSH
34553: LD_INT 26
34555: PPUSH
34556: LD_INT 12
34558: PPUSH
34559: LD_INT 1
34561: PPUSH
34562: CALL_OW 56
// end else
34566: GO 34604
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34568: LD_INT 700
34570: PPUSH
34571: LD_INT 1225
34573: PPUSH
34574: CALL_OW 12
34578: PPUSH
34579: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34583: LD_INT 1
34585: PPUSH
34586: LD_INT 5
34588: PPUSH
34589: CALL_OW 12
34593: PPUSH
34594: LD_INT 16
34596: PPUSH
34597: LD_INT 1
34599: PPUSH
34600: CALL_OW 55
// end ; if Prob ( 50 ) then
34604: LD_INT 50
34606: PPUSH
34607: CALL_OW 13
34611: IFFALSE 34657
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34613: LD_INT 700
34615: PPUSH
34616: LD_INT 1050
34618: PPUSH
34619: CALL_OW 12
34623: PPUSH
34624: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34628: LD_INT 1
34630: PPUSH
34631: LD_INT 5
34633: PPUSH
34634: CALL_OW 12
34638: PPUSH
34639: LD_INT 181
34641: PPUSH
34642: LD_INT 218
34644: PPUSH
34645: LD_INT 16
34647: PPUSH
34648: LD_INT 1
34650: PPUSH
34651: CALL_OW 56
// end else
34655: GO 34693
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34657: LD_INT 350
34659: PPUSH
34660: LD_INT 525
34662: PPUSH
34663: CALL_OW 12
34667: PPUSH
34668: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34672: LD_INT 1
34674: PPUSH
34675: LD_INT 5
34677: PPUSH
34678: CALL_OW 12
34682: PPUSH
34683: LD_INT 15
34685: PPUSH
34686: LD_INT 1
34688: PPUSH
34689: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34693: LD_INT 45
34695: PUSH
34696: LD_INT 32
34698: PUSH
34699: LD_INT 25
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: PUSH
34707: LD_OWVAR 67
34711: ARRAY
34712: PPUSH
34713: CALL_OW 13
34717: IFFALSE 34761
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34719: LD_INT 175
34721: PPUSH
34722: LD_INT 315
34724: PPUSH
34725: CALL_OW 12
34729: PPUSH
34730: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34734: LD_INT 1
34736: PPUSH
34737: LD_INT 5
34739: PPUSH
34740: CALL_OW 12
34744: PPUSH
34745: LD_INT 103
34747: PPUSH
34748: LD_INT 140
34750: PPUSH
34751: LD_INT 20
34753: PPUSH
34754: LD_INT 1
34756: PPUSH
34757: CALL_OW 56
// end ; if time > 1 1$20 then
34761: LD_VAR 0 1
34765: PUSH
34766: LD_INT 2800
34768: GREATER
34769: IFFALSE 34779
// time := 0 0$30 ;
34771: LD_ADDR_VAR 0 1
34775: PUSH
34776: LD_INT 1050
34778: ST_TO_ADDR
// until false ;
34779: LD_INT 0
34781: IFFALSE 34456
// end ; end_of_file
34783: PPOPN 1
34785: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34786: LD_EXP 13
34790: PUSH
34791: LD_EXP 15
34795: PUSH
34796: LD_INT 6
34798: GREATEREQUAL
34799: AND
34800: IFFALSE 34837
34802: GO 34804
34804: DISABLE
// begin enable ;
34805: ENABLE
// missionTime := missionTime + 0 0$1 ;
34806: LD_ADDR_EXP 14
34810: PUSH
34811: LD_EXP 14
34815: PUSH
34816: LD_INT 35
34818: PLUS
34819: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34820: LD_ADDR_OWVAR 47
34824: PUSH
34825: LD_STRING #Am15-1
34827: PUSH
34828: LD_EXP 14
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: ST_TO_ADDR
// end ; end_of_file
34837: END
// export function InitNature ; begin
34838: LD_INT 0
34840: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34841: LD_INT 3
34843: PPUSH
34844: LD_INT 3
34846: PPUSH
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 0
34858: PPUSH
34859: LD_INT 0
34861: PPUSH
34862: LD_INT 20
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: CALL 97819 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34872: LD_INT 2
34874: PPUSH
34875: LD_INT 1
34877: PPUSH
34878: LD_INT 1
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 1
34886: PPUSH
34887: LD_INT 0
34889: PPUSH
34890: LD_INT 0
34892: PPUSH
34893: LD_INT 21
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: CALL 97819 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34903: LD_INT 4
34905: PPUSH
34906: LD_INT 1
34908: PPUSH
34909: LD_INT 2
34911: PPUSH
34912: LD_INT 4
34914: PPUSH
34915: LD_INT 2
34917: PPUSH
34918: LD_INT 1
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 22
34926: PPUSH
34927: LD_INT 0
34929: PPUSH
34930: CALL 97819 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34934: LD_INT 0
34936: PPUSH
34937: LD_INT 0
34939: PPUSH
34940: LD_INT 0
34942: PPUSH
34943: LD_INT 0
34945: PPUSH
34946: LD_INT 0
34948: PPUSH
34949: LD_INT 0
34951: PPUSH
34952: LD_INT 9
34954: PPUSH
34955: LD_INT 0
34957: PPUSH
34958: LD_INT 23
34960: PPUSH
34961: CALL 97819 0 9
// end ; end_of_file
34965: LD_VAR 0 1
34969: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34970: LD_INT 0
34972: PPUSH
// ar_miner := 81 ;
34973: LD_ADDR_EXP 102
34977: PUSH
34978: LD_INT 81
34980: ST_TO_ADDR
// ar_crane := 88 ;
34981: LD_ADDR_EXP 101
34985: PUSH
34986: LD_INT 88
34988: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34989: LD_ADDR_EXP 96
34993: PUSH
34994: LD_INT 89
34996: ST_TO_ADDR
// us_hack := 99 ;
34997: LD_ADDR_EXP 97
35001: PUSH
35002: LD_INT 99
35004: ST_TO_ADDR
// us_artillery := 97 ;
35005: LD_ADDR_EXP 98
35009: PUSH
35010: LD_INT 97
35012: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35013: LD_ADDR_EXP 99
35017: PUSH
35018: LD_INT 91
35020: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
35021: LD_ADDR_EXP 100
35025: PUSH
35026: LD_INT 92
35028: ST_TO_ADDR
// ru_radar := 98 ;
35029: LD_ADDR_EXP 95
35033: PUSH
35034: LD_INT 98
35036: ST_TO_ADDR
// tech_Artillery := 80 ;
35037: LD_ADDR_EXP 103
35041: PUSH
35042: LD_INT 80
35044: ST_TO_ADDR
// tech_RadMat := 81 ;
35045: LD_ADDR_EXP 104
35049: PUSH
35050: LD_INT 81
35052: ST_TO_ADDR
// tech_BasicTools := 82 ;
35053: LD_ADDR_EXP 105
35057: PUSH
35058: LD_INT 82
35060: ST_TO_ADDR
// tech_Cargo := 83 ;
35061: LD_ADDR_EXP 106
35065: PUSH
35066: LD_INT 83
35068: ST_TO_ADDR
// tech_Track := 84 ;
35069: LD_ADDR_EXP 107
35073: PUSH
35074: LD_INT 84
35076: ST_TO_ADDR
// tech_Crane := 85 ;
35077: LD_ADDR_EXP 108
35081: PUSH
35082: LD_INT 85
35084: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35085: LD_ADDR_EXP 109
35089: PUSH
35090: LD_INT 86
35092: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35093: LD_ADDR_EXP 110
35097: PUSH
35098: LD_INT 87
35100: ST_TO_ADDR
// end ;
35101: LD_VAR 0 1
35105: RET
// every 1 do
35106: GO 35108
35108: DISABLE
// InitGlobalVariables ; end_of_file
35109: CALL 34970 0 0
35113: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35114: LD_INT 0
35116: PPUSH
35117: PPUSH
// skirmish := false ;
35118: LD_ADDR_EXP 111
35122: PUSH
35123: LD_INT 0
35125: ST_TO_ADDR
// debug_mc := false ;
35126: LD_ADDR_EXP 112
35130: PUSH
35131: LD_INT 0
35133: ST_TO_ADDR
// mc_bases := [ ] ;
35134: LD_ADDR_EXP 113
35138: PUSH
35139: EMPTY
35140: ST_TO_ADDR
// mc_sides := [ ] ;
35141: LD_ADDR_EXP 139
35145: PUSH
35146: EMPTY
35147: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35148: LD_ADDR_EXP 114
35152: PUSH
35153: EMPTY
35154: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35155: LD_ADDR_EXP 115
35159: PUSH
35160: EMPTY
35161: ST_TO_ADDR
// mc_need_heal := [ ] ;
35162: LD_ADDR_EXP 116
35166: PUSH
35167: EMPTY
35168: ST_TO_ADDR
// mc_healers := [ ] ;
35169: LD_ADDR_EXP 117
35173: PUSH
35174: EMPTY
35175: ST_TO_ADDR
// mc_build_list := [ ] ;
35176: LD_ADDR_EXP 118
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35183: LD_ADDR_EXP 145
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_builders := [ ] ;
35190: LD_ADDR_EXP 119
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_construct_list := [ ] ;
35197: LD_ADDR_EXP 120
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_turret_list := [ ] ;
35204: LD_ADDR_EXP 121
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35211: LD_ADDR_EXP 122
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_miners := [ ] ;
35218: LD_ADDR_EXP 127
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_mines := [ ] ;
35225: LD_ADDR_EXP 126
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_minefields := [ ] ;
35232: LD_ADDR_EXP 128
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_crates := [ ] ;
35239: LD_ADDR_EXP 129
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35246: LD_ADDR_EXP 130
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_crates_area := [ ] ;
35253: LD_ADDR_EXP 131
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_vehicles := [ ] ;
35260: LD_ADDR_EXP 132
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_attack := [ ] ;
35267: LD_ADDR_EXP 133
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_produce := [ ] ;
35274: LD_ADDR_EXP 134
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_defender := [ ] ;
35281: LD_ADDR_EXP 135
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_parking := [ ] ;
35288: LD_ADDR_EXP 137
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35295: LD_ADDR_EXP 123
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35302: LD_ADDR_EXP 125
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_scan := [ ] ;
35309: LD_ADDR_EXP 136
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_scan_area := [ ] ;
35316: LD_ADDR_EXP 138
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_tech := [ ] ;
35323: LD_ADDR_EXP 140
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_class := [ ] ;
35330: LD_ADDR_EXP 154
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35337: LD_ADDR_EXP 155
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// end ;
35344: LD_VAR 0 1
35348: RET
// export function MC_Kill ( base ) ; begin
35349: LD_INT 0
35351: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35352: LD_ADDR_EXP 113
35356: PUSH
35357: LD_EXP 113
35361: PPUSH
35362: LD_VAR 0 1
35366: PPUSH
35367: EMPTY
35368: PPUSH
35369: CALL_OW 1
35373: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35374: LD_ADDR_EXP 114
35378: PUSH
35379: LD_EXP 114
35383: PPUSH
35384: LD_VAR 0 1
35388: PPUSH
35389: EMPTY
35390: PPUSH
35391: CALL_OW 1
35395: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35396: LD_ADDR_EXP 115
35400: PUSH
35401: LD_EXP 115
35405: PPUSH
35406: LD_VAR 0 1
35410: PPUSH
35411: EMPTY
35412: PPUSH
35413: CALL_OW 1
35417: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35418: LD_ADDR_EXP 116
35422: PUSH
35423: LD_EXP 116
35427: PPUSH
35428: LD_VAR 0 1
35432: PPUSH
35433: EMPTY
35434: PPUSH
35435: CALL_OW 1
35439: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35440: LD_ADDR_EXP 117
35444: PUSH
35445: LD_EXP 117
35449: PPUSH
35450: LD_VAR 0 1
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL_OW 1
35461: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35462: LD_ADDR_EXP 118
35466: PUSH
35467: LD_EXP 118
35471: PPUSH
35472: LD_VAR 0 1
35476: PPUSH
35477: EMPTY
35478: PPUSH
35479: CALL_OW 1
35483: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35484: LD_ADDR_EXP 119
35488: PUSH
35489: LD_EXP 119
35493: PPUSH
35494: LD_VAR 0 1
35498: PPUSH
35499: EMPTY
35500: PPUSH
35501: CALL_OW 1
35505: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35506: LD_ADDR_EXP 120
35510: PUSH
35511: LD_EXP 120
35515: PPUSH
35516: LD_VAR 0 1
35520: PPUSH
35521: EMPTY
35522: PPUSH
35523: CALL_OW 1
35527: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35528: LD_ADDR_EXP 121
35532: PUSH
35533: LD_EXP 121
35537: PPUSH
35538: LD_VAR 0 1
35542: PPUSH
35543: EMPTY
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35550: LD_ADDR_EXP 122
35554: PUSH
35555: LD_EXP 122
35559: PPUSH
35560: LD_VAR 0 1
35564: PPUSH
35565: EMPTY
35566: PPUSH
35567: CALL_OW 1
35571: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35572: LD_ADDR_EXP 123
35576: PUSH
35577: LD_EXP 123
35581: PPUSH
35582: LD_VAR 0 1
35586: PPUSH
35587: EMPTY
35588: PPUSH
35589: CALL_OW 1
35593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35594: LD_ADDR_EXP 124
35598: PUSH
35599: LD_EXP 124
35603: PPUSH
35604: LD_VAR 0 1
35608: PPUSH
35609: LD_INT 0
35611: PPUSH
35612: CALL_OW 1
35616: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35617: LD_ADDR_EXP 125
35621: PUSH
35622: LD_EXP 125
35626: PPUSH
35627: LD_VAR 0 1
35631: PPUSH
35632: EMPTY
35633: PPUSH
35634: CALL_OW 1
35638: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35639: LD_ADDR_EXP 126
35643: PUSH
35644: LD_EXP 126
35648: PPUSH
35649: LD_VAR 0 1
35653: PPUSH
35654: EMPTY
35655: PPUSH
35656: CALL_OW 1
35660: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35661: LD_ADDR_EXP 127
35665: PUSH
35666: LD_EXP 127
35670: PPUSH
35671: LD_VAR 0 1
35675: PPUSH
35676: EMPTY
35677: PPUSH
35678: CALL_OW 1
35682: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35683: LD_ADDR_EXP 128
35687: PUSH
35688: LD_EXP 128
35692: PPUSH
35693: LD_VAR 0 1
35697: PPUSH
35698: EMPTY
35699: PPUSH
35700: CALL_OW 1
35704: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35705: LD_ADDR_EXP 129
35709: PUSH
35710: LD_EXP 129
35714: PPUSH
35715: LD_VAR 0 1
35719: PPUSH
35720: EMPTY
35721: PPUSH
35722: CALL_OW 1
35726: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35727: LD_ADDR_EXP 130
35731: PUSH
35732: LD_EXP 130
35736: PPUSH
35737: LD_VAR 0 1
35741: PPUSH
35742: EMPTY
35743: PPUSH
35744: CALL_OW 1
35748: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35749: LD_ADDR_EXP 131
35753: PUSH
35754: LD_EXP 131
35758: PPUSH
35759: LD_VAR 0 1
35763: PPUSH
35764: EMPTY
35765: PPUSH
35766: CALL_OW 1
35770: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35771: LD_ADDR_EXP 132
35775: PUSH
35776: LD_EXP 132
35780: PPUSH
35781: LD_VAR 0 1
35785: PPUSH
35786: EMPTY
35787: PPUSH
35788: CALL_OW 1
35792: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35793: LD_ADDR_EXP 133
35797: PUSH
35798: LD_EXP 133
35802: PPUSH
35803: LD_VAR 0 1
35807: PPUSH
35808: EMPTY
35809: PPUSH
35810: CALL_OW 1
35814: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35815: LD_ADDR_EXP 134
35819: PUSH
35820: LD_EXP 134
35824: PPUSH
35825: LD_VAR 0 1
35829: PPUSH
35830: EMPTY
35831: PPUSH
35832: CALL_OW 1
35836: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35837: LD_ADDR_EXP 135
35841: PUSH
35842: LD_EXP 135
35846: PPUSH
35847: LD_VAR 0 1
35851: PPUSH
35852: EMPTY
35853: PPUSH
35854: CALL_OW 1
35858: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35859: LD_ADDR_EXP 136
35863: PUSH
35864: LD_EXP 136
35868: PPUSH
35869: LD_VAR 0 1
35873: PPUSH
35874: EMPTY
35875: PPUSH
35876: CALL_OW 1
35880: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35881: LD_ADDR_EXP 137
35885: PUSH
35886: LD_EXP 137
35890: PPUSH
35891: LD_VAR 0 1
35895: PPUSH
35896: EMPTY
35897: PPUSH
35898: CALL_OW 1
35902: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35903: LD_ADDR_EXP 138
35907: PUSH
35908: LD_EXP 138
35912: PPUSH
35913: LD_VAR 0 1
35917: PPUSH
35918: EMPTY
35919: PPUSH
35920: CALL_OW 1
35924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35925: LD_ADDR_EXP 140
35929: PUSH
35930: LD_EXP 140
35934: PPUSH
35935: LD_VAR 0 1
35939: PPUSH
35940: EMPTY
35941: PPUSH
35942: CALL_OW 1
35946: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35947: LD_ADDR_EXP 142
35951: PUSH
35952: LD_EXP 142
35956: PPUSH
35957: LD_VAR 0 1
35961: PPUSH
35962: EMPTY
35963: PPUSH
35964: CALL_OW 1
35968: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35969: LD_ADDR_EXP 143
35973: PUSH
35974: LD_EXP 143
35978: PPUSH
35979: LD_VAR 0 1
35983: PPUSH
35984: EMPTY
35985: PPUSH
35986: CALL_OW 1
35990: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35991: LD_ADDR_EXP 144
35995: PUSH
35996: LD_EXP 144
36000: PPUSH
36001: LD_VAR 0 1
36005: PPUSH
36006: EMPTY
36007: PPUSH
36008: CALL_OW 1
36012: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36013: LD_ADDR_EXP 145
36017: PUSH
36018: LD_EXP 145
36022: PPUSH
36023: LD_VAR 0 1
36027: PPUSH
36028: EMPTY
36029: PPUSH
36030: CALL_OW 1
36034: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36035: LD_ADDR_EXP 146
36039: PUSH
36040: LD_EXP 146
36044: PPUSH
36045: LD_VAR 0 1
36049: PPUSH
36050: EMPTY
36051: PPUSH
36052: CALL_OW 1
36056: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36057: LD_ADDR_EXP 147
36061: PUSH
36062: LD_EXP 147
36066: PPUSH
36067: LD_VAR 0 1
36071: PPUSH
36072: EMPTY
36073: PPUSH
36074: CALL_OW 1
36078: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36079: LD_ADDR_EXP 148
36083: PUSH
36084: LD_EXP 148
36088: PPUSH
36089: LD_VAR 0 1
36093: PPUSH
36094: EMPTY
36095: PPUSH
36096: CALL_OW 1
36100: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36101: LD_ADDR_EXP 149
36105: PUSH
36106: LD_EXP 149
36110: PPUSH
36111: LD_VAR 0 1
36115: PPUSH
36116: EMPTY
36117: PPUSH
36118: CALL_OW 1
36122: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36123: LD_ADDR_EXP 150
36127: PUSH
36128: LD_EXP 150
36132: PPUSH
36133: LD_VAR 0 1
36137: PPUSH
36138: EMPTY
36139: PPUSH
36140: CALL_OW 1
36144: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36145: LD_ADDR_EXP 151
36149: PUSH
36150: LD_EXP 151
36154: PPUSH
36155: LD_VAR 0 1
36159: PPUSH
36160: EMPTY
36161: PPUSH
36162: CALL_OW 1
36166: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36167: LD_ADDR_EXP 152
36171: PUSH
36172: LD_EXP 152
36176: PPUSH
36177: LD_VAR 0 1
36181: PPUSH
36182: EMPTY
36183: PPUSH
36184: CALL_OW 1
36188: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36189: LD_ADDR_EXP 153
36193: PUSH
36194: LD_EXP 153
36198: PPUSH
36199: LD_VAR 0 1
36203: PPUSH
36204: EMPTY
36205: PPUSH
36206: CALL_OW 1
36210: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36211: LD_ADDR_EXP 154
36215: PUSH
36216: LD_EXP 154
36220: PPUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL_OW 1
36232: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36233: LD_ADDR_EXP 155
36237: PUSH
36238: LD_EXP 155
36242: PPUSH
36243: LD_VAR 0 1
36247: PPUSH
36248: LD_INT 0
36250: PPUSH
36251: CALL_OW 1
36255: ST_TO_ADDR
// end ;
36256: LD_VAR 0 2
36260: RET
// export function MC_Add ( side , units ) ; var base ; begin
36261: LD_INT 0
36263: PPUSH
36264: PPUSH
// base := mc_bases + 1 ;
36265: LD_ADDR_VAR 0 4
36269: PUSH
36270: LD_EXP 113
36274: PUSH
36275: LD_INT 1
36277: PLUS
36278: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36279: LD_ADDR_EXP 139
36283: PUSH
36284: LD_EXP 139
36288: PPUSH
36289: LD_VAR 0 4
36293: PPUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: CALL_OW 1
36303: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36304: LD_ADDR_EXP 113
36308: PUSH
36309: LD_EXP 113
36313: PPUSH
36314: LD_VAR 0 4
36318: PPUSH
36319: LD_VAR 0 2
36323: PPUSH
36324: CALL_OW 1
36328: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36329: LD_ADDR_EXP 114
36333: PUSH
36334: LD_EXP 114
36338: PPUSH
36339: LD_VAR 0 4
36343: PPUSH
36344: EMPTY
36345: PPUSH
36346: CALL_OW 1
36350: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36351: LD_ADDR_EXP 115
36355: PUSH
36356: LD_EXP 115
36360: PPUSH
36361: LD_VAR 0 4
36365: PPUSH
36366: EMPTY
36367: PPUSH
36368: CALL_OW 1
36372: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36373: LD_ADDR_EXP 116
36377: PUSH
36378: LD_EXP 116
36382: PPUSH
36383: LD_VAR 0 4
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL_OW 1
36394: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36395: LD_ADDR_EXP 117
36399: PUSH
36400: LD_EXP 117
36404: PPUSH
36405: LD_VAR 0 4
36409: PPUSH
36410: EMPTY
36411: PPUSH
36412: CALL_OW 1
36416: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36417: LD_ADDR_EXP 118
36421: PUSH
36422: LD_EXP 118
36426: PPUSH
36427: LD_VAR 0 4
36431: PPUSH
36432: EMPTY
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36439: LD_ADDR_EXP 119
36443: PUSH
36444: LD_EXP 119
36448: PPUSH
36449: LD_VAR 0 4
36453: PPUSH
36454: EMPTY
36455: PPUSH
36456: CALL_OW 1
36460: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36461: LD_ADDR_EXP 120
36465: PUSH
36466: LD_EXP 120
36470: PPUSH
36471: LD_VAR 0 4
36475: PPUSH
36476: EMPTY
36477: PPUSH
36478: CALL_OW 1
36482: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36483: LD_ADDR_EXP 121
36487: PUSH
36488: LD_EXP 121
36492: PPUSH
36493: LD_VAR 0 4
36497: PPUSH
36498: EMPTY
36499: PPUSH
36500: CALL_OW 1
36504: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36505: LD_ADDR_EXP 122
36509: PUSH
36510: LD_EXP 122
36514: PPUSH
36515: LD_VAR 0 4
36519: PPUSH
36520: EMPTY
36521: PPUSH
36522: CALL_OW 1
36526: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36527: LD_ADDR_EXP 123
36531: PUSH
36532: LD_EXP 123
36536: PPUSH
36537: LD_VAR 0 4
36541: PPUSH
36542: EMPTY
36543: PPUSH
36544: CALL_OW 1
36548: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36549: LD_ADDR_EXP 124
36553: PUSH
36554: LD_EXP 124
36558: PPUSH
36559: LD_VAR 0 4
36563: PPUSH
36564: LD_INT 0
36566: PPUSH
36567: CALL_OW 1
36571: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36572: LD_ADDR_EXP 125
36576: PUSH
36577: LD_EXP 125
36581: PPUSH
36582: LD_VAR 0 4
36586: PPUSH
36587: EMPTY
36588: PPUSH
36589: CALL_OW 1
36593: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36594: LD_ADDR_EXP 126
36598: PUSH
36599: LD_EXP 126
36603: PPUSH
36604: LD_VAR 0 4
36608: PPUSH
36609: EMPTY
36610: PPUSH
36611: CALL_OW 1
36615: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36616: LD_ADDR_EXP 127
36620: PUSH
36621: LD_EXP 127
36625: PPUSH
36626: LD_VAR 0 4
36630: PPUSH
36631: EMPTY
36632: PPUSH
36633: CALL_OW 1
36637: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36638: LD_ADDR_EXP 128
36642: PUSH
36643: LD_EXP 128
36647: PPUSH
36648: LD_VAR 0 4
36652: PPUSH
36653: EMPTY
36654: PPUSH
36655: CALL_OW 1
36659: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36660: LD_ADDR_EXP 129
36664: PUSH
36665: LD_EXP 129
36669: PPUSH
36670: LD_VAR 0 4
36674: PPUSH
36675: EMPTY
36676: PPUSH
36677: CALL_OW 1
36681: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36682: LD_ADDR_EXP 130
36686: PUSH
36687: LD_EXP 130
36691: PPUSH
36692: LD_VAR 0 4
36696: PPUSH
36697: EMPTY
36698: PPUSH
36699: CALL_OW 1
36703: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36704: LD_ADDR_EXP 131
36708: PUSH
36709: LD_EXP 131
36713: PPUSH
36714: LD_VAR 0 4
36718: PPUSH
36719: EMPTY
36720: PPUSH
36721: CALL_OW 1
36725: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36726: LD_ADDR_EXP 132
36730: PUSH
36731: LD_EXP 132
36735: PPUSH
36736: LD_VAR 0 4
36740: PPUSH
36741: EMPTY
36742: PPUSH
36743: CALL_OW 1
36747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36748: LD_ADDR_EXP 133
36752: PUSH
36753: LD_EXP 133
36757: PPUSH
36758: LD_VAR 0 4
36762: PPUSH
36763: EMPTY
36764: PPUSH
36765: CALL_OW 1
36769: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36770: LD_ADDR_EXP 134
36774: PUSH
36775: LD_EXP 134
36779: PPUSH
36780: LD_VAR 0 4
36784: PPUSH
36785: EMPTY
36786: PPUSH
36787: CALL_OW 1
36791: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36792: LD_ADDR_EXP 135
36796: PUSH
36797: LD_EXP 135
36801: PPUSH
36802: LD_VAR 0 4
36806: PPUSH
36807: EMPTY
36808: PPUSH
36809: CALL_OW 1
36813: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36814: LD_ADDR_EXP 136
36818: PUSH
36819: LD_EXP 136
36823: PPUSH
36824: LD_VAR 0 4
36828: PPUSH
36829: EMPTY
36830: PPUSH
36831: CALL_OW 1
36835: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36836: LD_ADDR_EXP 137
36840: PUSH
36841: LD_EXP 137
36845: PPUSH
36846: LD_VAR 0 4
36850: PPUSH
36851: EMPTY
36852: PPUSH
36853: CALL_OW 1
36857: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36858: LD_ADDR_EXP 138
36862: PUSH
36863: LD_EXP 138
36867: PPUSH
36868: LD_VAR 0 4
36872: PPUSH
36873: EMPTY
36874: PPUSH
36875: CALL_OW 1
36879: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36880: LD_ADDR_EXP 140
36884: PUSH
36885: LD_EXP 140
36889: PPUSH
36890: LD_VAR 0 4
36894: PPUSH
36895: EMPTY
36896: PPUSH
36897: CALL_OW 1
36901: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36902: LD_ADDR_EXP 142
36906: PUSH
36907: LD_EXP 142
36911: PPUSH
36912: LD_VAR 0 4
36916: PPUSH
36917: EMPTY
36918: PPUSH
36919: CALL_OW 1
36923: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36924: LD_ADDR_EXP 143
36928: PUSH
36929: LD_EXP 143
36933: PPUSH
36934: LD_VAR 0 4
36938: PPUSH
36939: EMPTY
36940: PPUSH
36941: CALL_OW 1
36945: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36946: LD_ADDR_EXP 144
36950: PUSH
36951: LD_EXP 144
36955: PPUSH
36956: LD_VAR 0 4
36960: PPUSH
36961: EMPTY
36962: PPUSH
36963: CALL_OW 1
36967: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36968: LD_ADDR_EXP 145
36972: PUSH
36973: LD_EXP 145
36977: PPUSH
36978: LD_VAR 0 4
36982: PPUSH
36983: EMPTY
36984: PPUSH
36985: CALL_OW 1
36989: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36990: LD_ADDR_EXP 146
36994: PUSH
36995: LD_EXP 146
36999: PPUSH
37000: LD_VAR 0 4
37004: PPUSH
37005: EMPTY
37006: PPUSH
37007: CALL_OW 1
37011: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37012: LD_ADDR_EXP 147
37016: PUSH
37017: LD_EXP 147
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: EMPTY
37028: PPUSH
37029: CALL_OW 1
37033: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37034: LD_ADDR_EXP 148
37038: PUSH
37039: LD_EXP 148
37043: PPUSH
37044: LD_VAR 0 4
37048: PPUSH
37049: EMPTY
37050: PPUSH
37051: CALL_OW 1
37055: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37056: LD_ADDR_EXP 149
37060: PUSH
37061: LD_EXP 149
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: EMPTY
37072: PPUSH
37073: CALL_OW 1
37077: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37078: LD_ADDR_EXP 150
37082: PUSH
37083: LD_EXP 150
37087: PPUSH
37088: LD_VAR 0 4
37092: PPUSH
37093: EMPTY
37094: PPUSH
37095: CALL_OW 1
37099: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37100: LD_ADDR_EXP 151
37104: PUSH
37105: LD_EXP 151
37109: PPUSH
37110: LD_VAR 0 4
37114: PPUSH
37115: EMPTY
37116: PPUSH
37117: CALL_OW 1
37121: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37122: LD_ADDR_EXP 152
37126: PUSH
37127: LD_EXP 152
37131: PPUSH
37132: LD_VAR 0 4
37136: PPUSH
37137: EMPTY
37138: PPUSH
37139: CALL_OW 1
37143: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37144: LD_ADDR_EXP 153
37148: PUSH
37149: LD_EXP 153
37153: PPUSH
37154: LD_VAR 0 4
37158: PPUSH
37159: EMPTY
37160: PPUSH
37161: CALL_OW 1
37165: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37166: LD_ADDR_EXP 154
37170: PUSH
37171: LD_EXP 154
37175: PPUSH
37176: LD_VAR 0 4
37180: PPUSH
37181: EMPTY
37182: PPUSH
37183: CALL_OW 1
37187: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37188: LD_ADDR_EXP 155
37192: PUSH
37193: LD_EXP 155
37197: PPUSH
37198: LD_VAR 0 4
37202: PPUSH
37203: LD_INT 0
37205: PPUSH
37206: CALL_OW 1
37210: ST_TO_ADDR
// result := base ;
37211: LD_ADDR_VAR 0 3
37215: PUSH
37216: LD_VAR 0 4
37220: ST_TO_ADDR
// end ;
37221: LD_VAR 0 3
37225: RET
// export function MC_Start ( ) ; var i ; begin
37226: LD_INT 0
37228: PPUSH
37229: PPUSH
// for i = 1 to mc_bases do
37230: LD_ADDR_VAR 0 2
37234: PUSH
37235: DOUBLE
37236: LD_INT 1
37238: DEC
37239: ST_TO_ADDR
37240: LD_EXP 113
37244: PUSH
37245: FOR_TO
37246: IFFALSE 38323
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37248: LD_ADDR_EXP 113
37252: PUSH
37253: LD_EXP 113
37257: PPUSH
37258: LD_VAR 0 2
37262: PPUSH
37263: LD_EXP 113
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PUSH
37274: LD_INT 0
37276: DIFF
37277: PPUSH
37278: CALL_OW 1
37282: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37283: LD_ADDR_EXP 114
37287: PUSH
37288: LD_EXP 114
37292: PPUSH
37293: LD_VAR 0 2
37297: PPUSH
37298: EMPTY
37299: PPUSH
37300: CALL_OW 1
37304: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37305: LD_ADDR_EXP 115
37309: PUSH
37310: LD_EXP 115
37314: PPUSH
37315: LD_VAR 0 2
37319: PPUSH
37320: EMPTY
37321: PPUSH
37322: CALL_OW 1
37326: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37327: LD_ADDR_EXP 116
37331: PUSH
37332: LD_EXP 116
37336: PPUSH
37337: LD_VAR 0 2
37341: PPUSH
37342: EMPTY
37343: PPUSH
37344: CALL_OW 1
37348: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37349: LD_ADDR_EXP 117
37353: PUSH
37354: LD_EXP 117
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: EMPTY
37365: PUSH
37366: EMPTY
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PPUSH
37372: CALL_OW 1
37376: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37377: LD_ADDR_EXP 118
37381: PUSH
37382: LD_EXP 118
37386: PPUSH
37387: LD_VAR 0 2
37391: PPUSH
37392: EMPTY
37393: PPUSH
37394: CALL_OW 1
37398: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37399: LD_ADDR_EXP 145
37403: PUSH
37404: LD_EXP 145
37408: PPUSH
37409: LD_VAR 0 2
37413: PPUSH
37414: EMPTY
37415: PPUSH
37416: CALL_OW 1
37420: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37421: LD_ADDR_EXP 119
37425: PUSH
37426: LD_EXP 119
37430: PPUSH
37431: LD_VAR 0 2
37435: PPUSH
37436: EMPTY
37437: PPUSH
37438: CALL_OW 1
37442: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37443: LD_ADDR_EXP 120
37447: PUSH
37448: LD_EXP 120
37452: PPUSH
37453: LD_VAR 0 2
37457: PPUSH
37458: EMPTY
37459: PPUSH
37460: CALL_OW 1
37464: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37465: LD_ADDR_EXP 121
37469: PUSH
37470: LD_EXP 121
37474: PPUSH
37475: LD_VAR 0 2
37479: PPUSH
37480: LD_EXP 113
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: PPUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 30
37496: PUSH
37497: LD_INT 32
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 30
37506: PUSH
37507: LD_INT 33
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: LIST
37518: PPUSH
37519: CALL_OW 72
37523: PPUSH
37524: CALL_OW 1
37528: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37529: LD_ADDR_EXP 122
37533: PUSH
37534: LD_EXP 122
37538: PPUSH
37539: LD_VAR 0 2
37543: PPUSH
37544: LD_EXP 113
37548: PUSH
37549: LD_VAR 0 2
37553: ARRAY
37554: PPUSH
37555: LD_INT 2
37557: PUSH
37558: LD_INT 30
37560: PUSH
37561: LD_INT 32
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 30
37570: PUSH
37571: LD_INT 31
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: LIST
37582: PUSH
37583: LD_INT 58
37585: PUSH
37586: EMPTY
37587: LIST
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PPUSH
37593: CALL_OW 72
37597: PPUSH
37598: CALL_OW 1
37602: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37603: LD_ADDR_EXP 123
37607: PUSH
37608: LD_EXP 123
37612: PPUSH
37613: LD_VAR 0 2
37617: PPUSH
37618: EMPTY
37619: PPUSH
37620: CALL_OW 1
37624: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37625: LD_ADDR_EXP 127
37629: PUSH
37630: LD_EXP 127
37634: PPUSH
37635: LD_VAR 0 2
37639: PPUSH
37640: EMPTY
37641: PPUSH
37642: CALL_OW 1
37646: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37647: LD_ADDR_EXP 126
37651: PUSH
37652: LD_EXP 126
37656: PPUSH
37657: LD_VAR 0 2
37661: PPUSH
37662: EMPTY
37663: PPUSH
37664: CALL_OW 1
37668: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37669: LD_ADDR_EXP 128
37673: PUSH
37674: LD_EXP 128
37678: PPUSH
37679: LD_VAR 0 2
37683: PPUSH
37684: EMPTY
37685: PPUSH
37686: CALL_OW 1
37690: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37691: LD_ADDR_EXP 129
37695: PUSH
37696: LD_EXP 129
37700: PPUSH
37701: LD_VAR 0 2
37705: PPUSH
37706: EMPTY
37707: PPUSH
37708: CALL_OW 1
37712: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37713: LD_ADDR_EXP 130
37717: PUSH
37718: LD_EXP 130
37722: PPUSH
37723: LD_VAR 0 2
37727: PPUSH
37728: EMPTY
37729: PPUSH
37730: CALL_OW 1
37734: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37735: LD_ADDR_EXP 131
37739: PUSH
37740: LD_EXP 131
37744: PPUSH
37745: LD_VAR 0 2
37749: PPUSH
37750: EMPTY
37751: PPUSH
37752: CALL_OW 1
37756: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37757: LD_ADDR_EXP 132
37761: PUSH
37762: LD_EXP 132
37766: PPUSH
37767: LD_VAR 0 2
37771: PPUSH
37772: EMPTY
37773: PPUSH
37774: CALL_OW 1
37778: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37779: LD_ADDR_EXP 133
37783: PUSH
37784: LD_EXP 133
37788: PPUSH
37789: LD_VAR 0 2
37793: PPUSH
37794: EMPTY
37795: PPUSH
37796: CALL_OW 1
37800: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37801: LD_ADDR_EXP 134
37805: PUSH
37806: LD_EXP 134
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: EMPTY
37817: PPUSH
37818: CALL_OW 1
37822: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37823: LD_ADDR_EXP 135
37827: PUSH
37828: LD_EXP 135
37832: PPUSH
37833: LD_VAR 0 2
37837: PPUSH
37838: EMPTY
37839: PPUSH
37840: CALL_OW 1
37844: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37845: LD_ADDR_EXP 124
37849: PUSH
37850: LD_EXP 124
37854: PPUSH
37855: LD_VAR 0 2
37859: PPUSH
37860: LD_INT 0
37862: PPUSH
37863: CALL_OW 1
37867: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37868: LD_ADDR_EXP 137
37872: PUSH
37873: LD_EXP 137
37877: PPUSH
37878: LD_VAR 0 2
37882: PPUSH
37883: LD_INT 0
37885: PPUSH
37886: CALL_OW 1
37890: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37891: LD_ADDR_EXP 125
37895: PUSH
37896: LD_EXP 125
37900: PPUSH
37901: LD_VAR 0 2
37905: PPUSH
37906: EMPTY
37907: PPUSH
37908: CALL_OW 1
37912: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37913: LD_ADDR_EXP 136
37917: PUSH
37918: LD_EXP 136
37922: PPUSH
37923: LD_VAR 0 2
37927: PPUSH
37928: LD_INT 0
37930: PPUSH
37931: CALL_OW 1
37935: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37936: LD_ADDR_EXP 138
37940: PUSH
37941: LD_EXP 138
37945: PPUSH
37946: LD_VAR 0 2
37950: PPUSH
37951: EMPTY
37952: PPUSH
37953: CALL_OW 1
37957: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37958: LD_ADDR_EXP 141
37962: PUSH
37963: LD_EXP 141
37967: PPUSH
37968: LD_VAR 0 2
37972: PPUSH
37973: LD_INT 0
37975: PPUSH
37976: CALL_OW 1
37980: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37981: LD_ADDR_EXP 142
37985: PUSH
37986: LD_EXP 142
37990: PPUSH
37991: LD_VAR 0 2
37995: PPUSH
37996: EMPTY
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38003: LD_ADDR_EXP 143
38007: PUSH
38008: LD_EXP 143
38012: PPUSH
38013: LD_VAR 0 2
38017: PPUSH
38018: EMPTY
38019: PPUSH
38020: CALL_OW 1
38024: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38025: LD_ADDR_EXP 144
38029: PUSH
38030: LD_EXP 144
38034: PPUSH
38035: LD_VAR 0 2
38039: PPUSH
38040: EMPTY
38041: PPUSH
38042: CALL_OW 1
38046: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38047: LD_ADDR_EXP 146
38051: PUSH
38052: LD_EXP 146
38056: PPUSH
38057: LD_VAR 0 2
38061: PPUSH
38062: LD_EXP 113
38066: PUSH
38067: LD_VAR 0 2
38071: ARRAY
38072: PPUSH
38073: LD_INT 2
38075: PUSH
38076: LD_INT 30
38078: PUSH
38079: LD_INT 6
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 30
38088: PUSH
38089: LD_INT 7
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 30
38098: PUSH
38099: LD_INT 8
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: PPUSH
38112: CALL_OW 72
38116: PPUSH
38117: CALL_OW 1
38121: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38122: LD_ADDR_EXP 147
38126: PUSH
38127: LD_EXP 147
38131: PPUSH
38132: LD_VAR 0 2
38136: PPUSH
38137: EMPTY
38138: PPUSH
38139: CALL_OW 1
38143: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38144: LD_ADDR_EXP 148
38148: PUSH
38149: LD_EXP 148
38153: PPUSH
38154: LD_VAR 0 2
38158: PPUSH
38159: EMPTY
38160: PPUSH
38161: CALL_OW 1
38165: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38166: LD_ADDR_EXP 149
38170: PUSH
38171: LD_EXP 149
38175: PPUSH
38176: LD_VAR 0 2
38180: PPUSH
38181: EMPTY
38182: PPUSH
38183: CALL_OW 1
38187: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38188: LD_ADDR_EXP 150
38192: PUSH
38193: LD_EXP 150
38197: PPUSH
38198: LD_VAR 0 2
38202: PPUSH
38203: EMPTY
38204: PPUSH
38205: CALL_OW 1
38209: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38210: LD_ADDR_EXP 151
38214: PUSH
38215: LD_EXP 151
38219: PPUSH
38220: LD_VAR 0 2
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38232: LD_ADDR_EXP 152
38236: PUSH
38237: LD_EXP 152
38241: PPUSH
38242: LD_VAR 0 2
38246: PPUSH
38247: EMPTY
38248: PPUSH
38249: CALL_OW 1
38253: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38254: LD_ADDR_EXP 153
38258: PUSH
38259: LD_EXP 153
38263: PPUSH
38264: LD_VAR 0 2
38268: PPUSH
38269: EMPTY
38270: PPUSH
38271: CALL_OW 1
38275: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38276: LD_ADDR_EXP 154
38280: PUSH
38281: LD_EXP 154
38285: PPUSH
38286: LD_VAR 0 2
38290: PPUSH
38291: EMPTY
38292: PPUSH
38293: CALL_OW 1
38297: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38298: LD_ADDR_EXP 155
38302: PUSH
38303: LD_EXP 155
38307: PPUSH
38308: LD_VAR 0 2
38312: PPUSH
38313: LD_INT 0
38315: PPUSH
38316: CALL_OW 1
38320: ST_TO_ADDR
// end ;
38321: GO 37245
38323: POP
38324: POP
// MC_InitSides ( ) ;
38325: CALL 38611 0 0
// MC_InitResearch ( ) ;
38329: CALL 38350 0 0
// CustomInitMacro ( ) ;
38333: CALL 471 0 0
// skirmish := true ;
38337: LD_ADDR_EXP 111
38341: PUSH
38342: LD_INT 1
38344: ST_TO_ADDR
// end ;
38345: LD_VAR 0 1
38349: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38350: LD_INT 0
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
// if not mc_bases then
38358: LD_EXP 113
38362: NOT
38363: IFFALSE 38367
// exit ;
38365: GO 38606
// for i = 1 to 8 do
38367: LD_ADDR_VAR 0 2
38371: PUSH
38372: DOUBLE
38373: LD_INT 1
38375: DEC
38376: ST_TO_ADDR
38377: LD_INT 8
38379: PUSH
38380: FOR_TO
38381: IFFALSE 38407
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38383: LD_ADDR_EXP 140
38387: PUSH
38388: LD_EXP 140
38392: PPUSH
38393: LD_VAR 0 2
38397: PPUSH
38398: EMPTY
38399: PPUSH
38400: CALL_OW 1
38404: ST_TO_ADDR
38405: GO 38380
38407: POP
38408: POP
// tmp := [ ] ;
38409: LD_ADDR_VAR 0 5
38413: PUSH
38414: EMPTY
38415: ST_TO_ADDR
// for i = 1 to mc_sides do
38416: LD_ADDR_VAR 0 2
38420: PUSH
38421: DOUBLE
38422: LD_INT 1
38424: DEC
38425: ST_TO_ADDR
38426: LD_EXP 139
38430: PUSH
38431: FOR_TO
38432: IFFALSE 38490
// if not mc_sides [ i ] in tmp then
38434: LD_EXP 139
38438: PUSH
38439: LD_VAR 0 2
38443: ARRAY
38444: PUSH
38445: LD_VAR 0 5
38449: IN
38450: NOT
38451: IFFALSE 38488
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38453: LD_ADDR_VAR 0 5
38457: PUSH
38458: LD_VAR 0 5
38462: PPUSH
38463: LD_VAR 0 5
38467: PUSH
38468: LD_INT 1
38470: PLUS
38471: PPUSH
38472: LD_EXP 139
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PPUSH
38483: CALL_OW 2
38487: ST_TO_ADDR
38488: GO 38431
38490: POP
38491: POP
// if not tmp then
38492: LD_VAR 0 5
38496: NOT
38497: IFFALSE 38501
// exit ;
38499: GO 38606
// for j in tmp do
38501: LD_ADDR_VAR 0 3
38505: PUSH
38506: LD_VAR 0 5
38510: PUSH
38511: FOR_IN
38512: IFFALSE 38604
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38514: LD_ADDR_VAR 0 6
38518: PUSH
38519: LD_INT 22
38521: PUSH
38522: LD_VAR 0 3
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PPUSH
38531: CALL_OW 69
38535: ST_TO_ADDR
// if not un then
38536: LD_VAR 0 6
38540: NOT
38541: IFFALSE 38545
// continue ;
38543: GO 38511
// nation := GetNation ( un [ 1 ] ) ;
38545: LD_ADDR_VAR 0 4
38549: PUSH
38550: LD_VAR 0 6
38554: PUSH
38555: LD_INT 1
38557: ARRAY
38558: PPUSH
38559: CALL_OW 248
38563: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38564: LD_ADDR_EXP 140
38568: PUSH
38569: LD_EXP 140
38573: PPUSH
38574: LD_VAR 0 3
38578: PPUSH
38579: LD_VAR 0 3
38583: PPUSH
38584: LD_VAR 0 4
38588: PPUSH
38589: LD_INT 1
38591: PPUSH
38592: CALL 65267 0 3
38596: PPUSH
38597: CALL_OW 1
38601: ST_TO_ADDR
// end ;
38602: GO 38511
38604: POP
38605: POP
// end ;
38606: LD_VAR 0 1
38610: RET
// export function MC_InitSides ( ) ; var i ; begin
38611: LD_INT 0
38613: PPUSH
38614: PPUSH
// if not mc_bases then
38615: LD_EXP 113
38619: NOT
38620: IFFALSE 38624
// exit ;
38622: GO 38698
// for i = 1 to mc_bases do
38624: LD_ADDR_VAR 0 2
38628: PUSH
38629: DOUBLE
38630: LD_INT 1
38632: DEC
38633: ST_TO_ADDR
38634: LD_EXP 113
38638: PUSH
38639: FOR_TO
38640: IFFALSE 38696
// if mc_bases [ i ] then
38642: LD_EXP 113
38646: PUSH
38647: LD_VAR 0 2
38651: ARRAY
38652: IFFALSE 38694
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38654: LD_ADDR_EXP 139
38658: PUSH
38659: LD_EXP 139
38663: PPUSH
38664: LD_VAR 0 2
38668: PPUSH
38669: LD_EXP 113
38673: PUSH
38674: LD_VAR 0 2
38678: ARRAY
38679: PUSH
38680: LD_INT 1
38682: ARRAY
38683: PPUSH
38684: CALL_OW 255
38688: PPUSH
38689: CALL_OW 1
38693: ST_TO_ADDR
38694: GO 38639
38696: POP
38697: POP
// end ;
38698: LD_VAR 0 1
38702: RET
// every 0 0$01 trigger skirmish do
38703: LD_EXP 111
38707: IFFALSE 38861
38709: GO 38711
38711: DISABLE
// begin enable ;
38712: ENABLE
// MC_CheckBuildings ( ) ;
38713: CALL 43359 0 0
// MC_CheckPeopleLife ( ) ;
38717: CALL 43484 0 0
// RaiseSailEvent ( 100 ) ;
38721: LD_INT 100
38723: PPUSH
38724: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38728: LD_INT 103
38730: PPUSH
38731: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38735: LD_INT 104
38737: PPUSH
38738: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38742: LD_INT 105
38744: PPUSH
38745: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38749: LD_INT 106
38751: PPUSH
38752: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38756: LD_INT 107
38758: PPUSH
38759: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38763: LD_INT 108
38765: PPUSH
38766: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38770: LD_INT 109
38772: PPUSH
38773: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38777: LD_INT 110
38779: PPUSH
38780: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38784: LD_INT 111
38786: PPUSH
38787: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38791: LD_INT 112
38793: PPUSH
38794: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38798: LD_INT 113
38800: PPUSH
38801: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38805: LD_INT 120
38807: PPUSH
38808: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38812: LD_INT 121
38814: PPUSH
38815: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38819: LD_INT 122
38821: PPUSH
38822: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38826: LD_INT 123
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38833: LD_INT 124
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38840: LD_INT 125
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38847: LD_INT 126
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38854: LD_INT 200
38856: PPUSH
38857: CALL_OW 427
// end ;
38861: END
// on SailEvent ( event ) do begin if event < 100 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 100
38869: LESS
38870: IFFALSE 38881
// CustomEvent ( event ) ;
38872: LD_VAR 0 1
38876: PPUSH
38877: CALL 33428 0 1
// if event = 100 then
38881: LD_VAR 0 1
38885: PUSH
38886: LD_INT 100
38888: EQUAL
38889: IFFALSE 38895
// MC_ClassManager ( ) ;
38891: CALL 39287 0 0
// if event = 101 then
38895: LD_VAR 0 1
38899: PUSH
38900: LD_INT 101
38902: EQUAL
38903: IFFALSE 38909
// MC_RepairBuildings ( ) ;
38905: CALL 44069 0 0
// if event = 102 then
38909: LD_VAR 0 1
38913: PUSH
38914: LD_INT 102
38916: EQUAL
38917: IFFALSE 38923
// MC_Heal ( ) ;
38919: CALL 44954 0 0
// if event = 103 then
38923: LD_VAR 0 1
38927: PUSH
38928: LD_INT 103
38930: EQUAL
38931: IFFALSE 38937
// MC_Build ( ) ;
38933: CALL 45376 0 0
// if event = 104 then
38937: LD_VAR 0 1
38941: PUSH
38942: LD_INT 104
38944: EQUAL
38945: IFFALSE 38951
// MC_TurretWeapon ( ) ;
38947: CALL 46989 0 0
// if event = 105 then
38951: LD_VAR 0 1
38955: PUSH
38956: LD_INT 105
38958: EQUAL
38959: IFFALSE 38965
// MC_BuildUpgrade ( ) ;
38961: CALL 46540 0 0
// if event = 106 then
38965: LD_VAR 0 1
38969: PUSH
38970: LD_INT 106
38972: EQUAL
38973: IFFALSE 38979
// MC_PlantMines ( ) ;
38975: CALL 47419 0 0
// if event = 107 then
38979: LD_VAR 0 1
38983: PUSH
38984: LD_INT 107
38986: EQUAL
38987: IFFALSE 38993
// MC_CollectCrates ( ) ;
38989: CALL 48217 0 0
// if event = 108 then
38993: LD_VAR 0 1
38997: PUSH
38998: LD_INT 108
39000: EQUAL
39001: IFFALSE 39007
// MC_LinkRemoteControl ( ) ;
39003: CALL 49993 0 0
// if event = 109 then
39007: LD_VAR 0 1
39011: PUSH
39012: LD_INT 109
39014: EQUAL
39015: IFFALSE 39021
// MC_ProduceVehicle ( ) ;
39017: CALL 50174 0 0
// if event = 110 then
39021: LD_VAR 0 1
39025: PUSH
39026: LD_INT 110
39028: EQUAL
39029: IFFALSE 39035
// MC_SendAttack ( ) ;
39031: CALL 50640 0 0
// if event = 111 then
39035: LD_VAR 0 1
39039: PUSH
39040: LD_INT 111
39042: EQUAL
39043: IFFALSE 39049
// MC_Defend ( ) ;
39045: CALL 50748 0 0
// if event = 112 then
39049: LD_VAR 0 1
39053: PUSH
39054: LD_INT 112
39056: EQUAL
39057: IFFALSE 39063
// MC_Research ( ) ;
39059: CALL 51375 0 0
// if event = 113 then
39063: LD_VAR 0 1
39067: PUSH
39068: LD_INT 113
39070: EQUAL
39071: IFFALSE 39077
// MC_MinesTrigger ( ) ;
39073: CALL 52489 0 0
// if event = 120 then
39077: LD_VAR 0 1
39081: PUSH
39082: LD_INT 120
39084: EQUAL
39085: IFFALSE 39091
// MC_RepairVehicle ( ) ;
39087: CALL 52588 0 0
// if event = 121 then
39091: LD_VAR 0 1
39095: PUSH
39096: LD_INT 121
39098: EQUAL
39099: IFFALSE 39105
// MC_TameApe ( ) ;
39101: CALL 53318 0 0
// if event = 122 then
39105: LD_VAR 0 1
39109: PUSH
39110: LD_INT 122
39112: EQUAL
39113: IFFALSE 39119
// MC_ChangeApeClass ( ) ;
39115: CALL 54147 0 0
// if event = 123 then
39119: LD_VAR 0 1
39123: PUSH
39124: LD_INT 123
39126: EQUAL
39127: IFFALSE 39133
// MC_Bazooka ( ) ;
39129: CALL 54797 0 0
// if event = 124 then
39133: LD_VAR 0 1
39137: PUSH
39138: LD_INT 124
39140: EQUAL
39141: IFFALSE 39147
// MC_TeleportExit ( ) ;
39143: CALL 54995 0 0
// if event = 125 then
39147: LD_VAR 0 1
39151: PUSH
39152: LD_INT 125
39154: EQUAL
39155: IFFALSE 39161
// MC_Deposits ( ) ;
39157: CALL 55642 0 0
// if event = 126 then
39161: LD_VAR 0 1
39165: PUSH
39166: LD_INT 126
39168: EQUAL
39169: IFFALSE 39175
// MC_RemoteDriver ( ) ;
39171: CALL 56267 0 0
// if event = 200 then
39175: LD_VAR 0 1
39179: PUSH
39180: LD_INT 200
39182: EQUAL
39183: IFFALSE 39189
// MC_Idle ( ) ;
39185: CALL 58216 0 0
// end ;
39189: PPOPN 1
39191: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39192: LD_INT 0
39194: PPUSH
39195: PPUSH
// if not mc_bases [ base ] or not tag then
39196: LD_EXP 113
39200: PUSH
39201: LD_VAR 0 1
39205: ARRAY
39206: NOT
39207: PUSH
39208: LD_VAR 0 2
39212: NOT
39213: OR
39214: IFFALSE 39218
// exit ;
39216: GO 39282
// for i in mc_bases [ base ] union mc_ape [ base ] do
39218: LD_ADDR_VAR 0 4
39222: PUSH
39223: LD_EXP 113
39227: PUSH
39228: LD_VAR 0 1
39232: ARRAY
39233: PUSH
39234: LD_EXP 142
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: UNION
39245: PUSH
39246: FOR_IN
39247: IFFALSE 39280
// if GetTag ( i ) = tag then
39249: LD_VAR 0 4
39253: PPUSH
39254: CALL_OW 110
39258: PUSH
39259: LD_VAR 0 2
39263: EQUAL
39264: IFFALSE 39278
// SetTag ( i , 0 ) ;
39266: LD_VAR 0 4
39270: PPUSH
39271: LD_INT 0
39273: PPUSH
39274: CALL_OW 109
39278: GO 39246
39280: POP
39281: POP
// end ;
39282: LD_VAR 0 3
39286: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39287: LD_INT 0
39289: PPUSH
39290: PPUSH
39291: PPUSH
39292: PPUSH
39293: PPUSH
39294: PPUSH
39295: PPUSH
39296: PPUSH
// if not mc_bases then
39297: LD_EXP 113
39301: NOT
39302: IFFALSE 39306
// exit ;
39304: GO 39764
// for i = 1 to mc_bases do
39306: LD_ADDR_VAR 0 2
39310: PUSH
39311: DOUBLE
39312: LD_INT 1
39314: DEC
39315: ST_TO_ADDR
39316: LD_EXP 113
39320: PUSH
39321: FOR_TO
39322: IFFALSE 39762
// begin tmp := MC_ClassCheckReq ( i ) ;
39324: LD_ADDR_VAR 0 4
39328: PUSH
39329: LD_VAR 0 2
39333: PPUSH
39334: CALL 39769 0 1
39338: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39339: LD_ADDR_EXP 154
39343: PUSH
39344: LD_EXP 154
39348: PPUSH
39349: LD_VAR 0 2
39353: PPUSH
39354: LD_VAR 0 4
39358: PPUSH
39359: CALL_OW 1
39363: ST_TO_ADDR
// if not tmp then
39364: LD_VAR 0 4
39368: NOT
39369: IFFALSE 39373
// continue ;
39371: GO 39321
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39373: LD_ADDR_VAR 0 6
39377: PUSH
39378: LD_EXP 113
39382: PUSH
39383: LD_VAR 0 2
39387: ARRAY
39388: PPUSH
39389: LD_INT 2
39391: PUSH
39392: LD_INT 30
39394: PUSH
39395: LD_INT 4
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 30
39404: PUSH
39405: LD_INT 5
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: LIST
39416: PPUSH
39417: CALL_OW 72
39421: PUSH
39422: LD_EXP 113
39426: PUSH
39427: LD_VAR 0 2
39431: ARRAY
39432: PPUSH
39433: LD_INT 2
39435: PUSH
39436: LD_INT 30
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 30
39448: PUSH
39449: LD_INT 1
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: LIST
39460: PPUSH
39461: CALL_OW 72
39465: PUSH
39466: LD_EXP 113
39470: PUSH
39471: LD_VAR 0 2
39475: ARRAY
39476: PPUSH
39477: LD_INT 30
39479: PUSH
39480: LD_INT 3
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PPUSH
39487: CALL_OW 72
39491: PUSH
39492: LD_EXP 113
39496: PUSH
39497: LD_VAR 0 2
39501: ARRAY
39502: PPUSH
39503: LD_INT 2
39505: PUSH
39506: LD_INT 30
39508: PUSH
39509: LD_INT 6
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 30
39518: PUSH
39519: LD_INT 7
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 30
39528: PUSH
39529: LD_INT 8
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: PPUSH
39542: CALL_OW 72
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: ST_TO_ADDR
// for j = 1 to 4 do
39553: LD_ADDR_VAR 0 3
39557: PUSH
39558: DOUBLE
39559: LD_INT 1
39561: DEC
39562: ST_TO_ADDR
39563: LD_INT 4
39565: PUSH
39566: FOR_TO
39567: IFFALSE 39758
// begin if not tmp [ j ] then
39569: LD_VAR 0 4
39573: PUSH
39574: LD_VAR 0 3
39578: ARRAY
39579: NOT
39580: IFFALSE 39584
// continue ;
39582: GO 39566
// for p in tmp [ j ] do
39584: LD_ADDR_VAR 0 5
39588: PUSH
39589: LD_VAR 0 4
39593: PUSH
39594: LD_VAR 0 3
39598: ARRAY
39599: PUSH
39600: FOR_IN
39601: IFFALSE 39754
// begin if not b [ j ] then
39603: LD_VAR 0 6
39607: PUSH
39608: LD_VAR 0 3
39612: ARRAY
39613: NOT
39614: IFFALSE 39618
// break ;
39616: GO 39754
// e := 0 ;
39618: LD_ADDR_VAR 0 7
39622: PUSH
39623: LD_INT 0
39625: ST_TO_ADDR
// for k in b [ j ] do
39626: LD_ADDR_VAR 0 8
39630: PUSH
39631: LD_VAR 0 6
39635: PUSH
39636: LD_VAR 0 3
39640: ARRAY
39641: PUSH
39642: FOR_IN
39643: IFFALSE 39670
// if IsNotFull ( k ) then
39645: LD_VAR 0 8
39649: PPUSH
39650: CALL 67416 0 1
39654: IFFALSE 39668
// begin e := k ;
39656: LD_ADDR_VAR 0 7
39660: PUSH
39661: LD_VAR 0 8
39665: ST_TO_ADDR
// break ;
39666: GO 39670
// end ;
39668: GO 39642
39670: POP
39671: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39672: LD_VAR 0 7
39676: PUSH
39677: LD_VAR 0 5
39681: PPUSH
39682: LD_VAR 0 7
39686: PPUSH
39687: CALL 99836 0 2
39691: NOT
39692: AND
39693: IFFALSE 39752
// begin if IsInUnit ( p ) then
39695: LD_VAR 0 5
39699: PPUSH
39700: CALL_OW 310
39704: IFFALSE 39715
// ComExitBuilding ( p ) ;
39706: LD_VAR 0 5
39710: PPUSH
39711: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39715: LD_VAR 0 5
39719: PPUSH
39720: LD_VAR 0 7
39724: PPUSH
39725: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39729: LD_VAR 0 5
39733: PPUSH
39734: LD_VAR 0 3
39738: PPUSH
39739: CALL_OW 183
// AddComExitBuilding ( p ) ;
39743: LD_VAR 0 5
39747: PPUSH
39748: CALL_OW 182
// end ; end ;
39752: GO 39600
39754: POP
39755: POP
// end ;
39756: GO 39566
39758: POP
39759: POP
// end ;
39760: GO 39321
39762: POP
39763: POP
// end ;
39764: LD_VAR 0 1
39768: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39769: LD_INT 0
39771: PPUSH
39772: PPUSH
39773: PPUSH
39774: PPUSH
39775: PPUSH
39776: PPUSH
39777: PPUSH
39778: PPUSH
39779: PPUSH
39780: PPUSH
39781: PPUSH
39782: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39783: LD_VAR 0 1
39787: NOT
39788: PUSH
39789: LD_EXP 113
39793: PUSH
39794: LD_VAR 0 1
39798: ARRAY
39799: NOT
39800: OR
39801: PUSH
39802: LD_EXP 113
39806: PUSH
39807: LD_VAR 0 1
39811: ARRAY
39812: PPUSH
39813: LD_INT 2
39815: PUSH
39816: LD_INT 30
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 30
39828: PUSH
39829: LD_INT 1
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: LIST
39840: PPUSH
39841: CALL_OW 72
39845: NOT
39846: OR
39847: IFFALSE 39851
// exit ;
39849: GO 43354
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39851: LD_ADDR_VAR 0 4
39855: PUSH
39856: LD_EXP 113
39860: PUSH
39861: LD_VAR 0 1
39865: ARRAY
39866: PPUSH
39867: LD_INT 2
39869: PUSH
39870: LD_INT 25
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 25
39882: PUSH
39883: LD_INT 2
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PUSH
39890: LD_INT 25
39892: PUSH
39893: LD_INT 3
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 25
39902: PUSH
39903: LD_INT 4
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 25
39912: PUSH
39913: LD_INT 5
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 25
39922: PUSH
39923: LD_INT 8
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 25
39932: PUSH
39933: LD_INT 9
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: PPUSH
39950: CALL_OW 72
39954: ST_TO_ADDR
// if not tmp then
39955: LD_VAR 0 4
39959: NOT
39960: IFFALSE 39964
// exit ;
39962: GO 43354
// for i in tmp do
39964: LD_ADDR_VAR 0 3
39968: PUSH
39969: LD_VAR 0 4
39973: PUSH
39974: FOR_IN
39975: IFFALSE 40006
// if GetTag ( i ) then
39977: LD_VAR 0 3
39981: PPUSH
39982: CALL_OW 110
39986: IFFALSE 40004
// tmp := tmp diff i ;
39988: LD_ADDR_VAR 0 4
39992: PUSH
39993: LD_VAR 0 4
39997: PUSH
39998: LD_VAR 0 3
40002: DIFF
40003: ST_TO_ADDR
40004: GO 39974
40006: POP
40007: POP
// if not tmp then
40008: LD_VAR 0 4
40012: NOT
40013: IFFALSE 40017
// exit ;
40015: GO 43354
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40017: LD_ADDR_VAR 0 5
40021: PUSH
40022: LD_EXP 113
40026: PUSH
40027: LD_VAR 0 1
40031: ARRAY
40032: PPUSH
40033: LD_INT 2
40035: PUSH
40036: LD_INT 25
40038: PUSH
40039: LD_INT 1
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 25
40048: PUSH
40049: LD_INT 5
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 25
40058: PUSH
40059: LD_INT 8
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 25
40068: PUSH
40069: LD_INT 9
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: PPUSH
40083: CALL_OW 72
40087: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40088: LD_ADDR_VAR 0 6
40092: PUSH
40093: LD_EXP 113
40097: PUSH
40098: LD_VAR 0 1
40102: ARRAY
40103: PPUSH
40104: LD_INT 25
40106: PUSH
40107: LD_INT 2
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PPUSH
40114: CALL_OW 72
40118: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40119: LD_ADDR_VAR 0 7
40123: PUSH
40124: LD_EXP 113
40128: PUSH
40129: LD_VAR 0 1
40133: ARRAY
40134: PPUSH
40135: LD_INT 25
40137: PUSH
40138: LD_INT 3
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PPUSH
40145: CALL_OW 72
40149: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40150: LD_ADDR_VAR 0 8
40154: PUSH
40155: LD_EXP 113
40159: PUSH
40160: LD_VAR 0 1
40164: ARRAY
40165: PPUSH
40166: LD_INT 25
40168: PUSH
40169: LD_INT 4
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 24
40178: PUSH
40179: LD_INT 251
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PPUSH
40190: CALL_OW 72
40194: ST_TO_ADDR
// if mc_scan [ base ] then
40195: LD_EXP 136
40199: PUSH
40200: LD_VAR 0 1
40204: ARRAY
40205: IFFALSE 40666
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40207: LD_ADDR_EXP 155
40211: PUSH
40212: LD_EXP 155
40216: PPUSH
40217: LD_VAR 0 1
40221: PPUSH
40222: LD_INT 4
40224: PPUSH
40225: CALL_OW 1
40229: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40230: LD_ADDR_VAR 0 12
40234: PUSH
40235: LD_EXP 113
40239: PUSH
40240: LD_VAR 0 1
40244: ARRAY
40245: PPUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 30
40251: PUSH
40252: LD_INT 4
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 30
40261: PUSH
40262: LD_INT 5
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: LIST
40273: PPUSH
40274: CALL_OW 72
40278: ST_TO_ADDR
// if not b then
40279: LD_VAR 0 12
40283: NOT
40284: IFFALSE 40288
// exit ;
40286: GO 43354
// p := [ ] ;
40288: LD_ADDR_VAR 0 11
40292: PUSH
40293: EMPTY
40294: ST_TO_ADDR
// if sci >= 2 then
40295: LD_VAR 0 8
40299: PUSH
40300: LD_INT 2
40302: GREATEREQUAL
40303: IFFALSE 40334
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40305: LD_ADDR_VAR 0 8
40309: PUSH
40310: LD_VAR 0 8
40314: PUSH
40315: LD_INT 1
40317: ARRAY
40318: PUSH
40319: LD_VAR 0 8
40323: PUSH
40324: LD_INT 2
40326: ARRAY
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: ST_TO_ADDR
40332: GO 40395
// if sci = 1 then
40334: LD_VAR 0 8
40338: PUSH
40339: LD_INT 1
40341: EQUAL
40342: IFFALSE 40363
// sci := [ sci [ 1 ] ] else
40344: LD_ADDR_VAR 0 8
40348: PUSH
40349: LD_VAR 0 8
40353: PUSH
40354: LD_INT 1
40356: ARRAY
40357: PUSH
40358: EMPTY
40359: LIST
40360: ST_TO_ADDR
40361: GO 40395
// if sci = 0 then
40363: LD_VAR 0 8
40367: PUSH
40368: LD_INT 0
40370: EQUAL
40371: IFFALSE 40395
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40373: LD_ADDR_VAR 0 11
40377: PUSH
40378: LD_VAR 0 4
40382: PPUSH
40383: LD_INT 4
40385: PPUSH
40386: CALL 99699 0 2
40390: PUSH
40391: LD_INT 1
40393: ARRAY
40394: ST_TO_ADDR
// if eng > 4 then
40395: LD_VAR 0 6
40399: PUSH
40400: LD_INT 4
40402: GREATER
40403: IFFALSE 40449
// for i = eng downto 4 do
40405: LD_ADDR_VAR 0 3
40409: PUSH
40410: DOUBLE
40411: LD_VAR 0 6
40415: INC
40416: ST_TO_ADDR
40417: LD_INT 4
40419: PUSH
40420: FOR_DOWNTO
40421: IFFALSE 40447
// eng := eng diff eng [ i ] ;
40423: LD_ADDR_VAR 0 6
40427: PUSH
40428: LD_VAR 0 6
40432: PUSH
40433: LD_VAR 0 6
40437: PUSH
40438: LD_VAR 0 3
40442: ARRAY
40443: DIFF
40444: ST_TO_ADDR
40445: GO 40420
40447: POP
40448: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40449: LD_ADDR_VAR 0 4
40453: PUSH
40454: LD_VAR 0 4
40458: PUSH
40459: LD_VAR 0 5
40463: PUSH
40464: LD_VAR 0 6
40468: UNION
40469: PUSH
40470: LD_VAR 0 7
40474: UNION
40475: PUSH
40476: LD_VAR 0 8
40480: UNION
40481: DIFF
40482: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40483: LD_ADDR_VAR 0 13
40487: PUSH
40488: LD_EXP 113
40492: PUSH
40493: LD_VAR 0 1
40497: ARRAY
40498: PPUSH
40499: LD_INT 2
40501: PUSH
40502: LD_INT 30
40504: PUSH
40505: LD_INT 32
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 30
40514: PUSH
40515: LD_INT 31
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: LIST
40526: PPUSH
40527: CALL_OW 72
40531: PUSH
40532: LD_EXP 113
40536: PUSH
40537: LD_VAR 0 1
40541: ARRAY
40542: PPUSH
40543: LD_INT 2
40545: PUSH
40546: LD_INT 30
40548: PUSH
40549: LD_INT 4
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 30
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: LIST
40570: PPUSH
40571: CALL_OW 72
40575: PUSH
40576: LD_INT 6
40578: MUL
40579: PLUS
40580: ST_TO_ADDR
// if bcount < tmp then
40581: LD_VAR 0 13
40585: PUSH
40586: LD_VAR 0 4
40590: LESS
40591: IFFALSE 40637
// for i = tmp downto bcount do
40593: LD_ADDR_VAR 0 3
40597: PUSH
40598: DOUBLE
40599: LD_VAR 0 4
40603: INC
40604: ST_TO_ADDR
40605: LD_VAR 0 13
40609: PUSH
40610: FOR_DOWNTO
40611: IFFALSE 40635
// tmp := Delete ( tmp , tmp ) ;
40613: LD_ADDR_VAR 0 4
40617: PUSH
40618: LD_VAR 0 4
40622: PPUSH
40623: LD_VAR 0 4
40627: PPUSH
40628: CALL_OW 3
40632: ST_TO_ADDR
40633: GO 40610
40635: POP
40636: POP
// result := [ tmp , 0 , 0 , p ] ;
40637: LD_ADDR_VAR 0 2
40641: PUSH
40642: LD_VAR 0 4
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 0
40652: PUSH
40653: LD_VAR 0 11
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: ST_TO_ADDR
// exit ;
40664: GO 43354
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40666: LD_EXP 113
40670: PUSH
40671: LD_VAR 0 1
40675: ARRAY
40676: PPUSH
40677: LD_INT 2
40679: PUSH
40680: LD_INT 30
40682: PUSH
40683: LD_INT 6
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 30
40692: PUSH
40693: LD_INT 7
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 30
40702: PUSH
40703: LD_INT 8
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: PPUSH
40716: CALL_OW 72
40720: NOT
40721: PUSH
40722: LD_EXP 113
40726: PUSH
40727: LD_VAR 0 1
40731: ARRAY
40732: PPUSH
40733: LD_INT 30
40735: PUSH
40736: LD_INT 3
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PPUSH
40743: CALL_OW 72
40747: NOT
40748: AND
40749: IFFALSE 40821
// begin if eng = tmp then
40751: LD_VAR 0 6
40755: PUSH
40756: LD_VAR 0 4
40760: EQUAL
40761: IFFALSE 40765
// exit ;
40763: GO 43354
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40765: LD_ADDR_EXP 155
40769: PUSH
40770: LD_EXP 155
40774: PPUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 1
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40788: LD_ADDR_VAR 0 2
40792: PUSH
40793: LD_INT 0
40795: PUSH
40796: LD_VAR 0 4
40800: PUSH
40801: LD_VAR 0 6
40805: DIFF
40806: PUSH
40807: LD_INT 0
40809: PUSH
40810: LD_INT 0
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: LIST
40818: ST_TO_ADDR
// exit ;
40819: GO 43354
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40821: LD_EXP 140
40825: PUSH
40826: LD_EXP 139
40830: PUSH
40831: LD_VAR 0 1
40835: ARRAY
40836: ARRAY
40837: PUSH
40838: LD_EXP 113
40842: PUSH
40843: LD_VAR 0 1
40847: ARRAY
40848: PPUSH
40849: LD_INT 2
40851: PUSH
40852: LD_INT 30
40854: PUSH
40855: LD_INT 6
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 30
40864: PUSH
40865: LD_INT 7
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 30
40874: PUSH
40875: LD_INT 8
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: PPUSH
40888: CALL_OW 72
40892: AND
40893: PUSH
40894: LD_EXP 113
40898: PUSH
40899: LD_VAR 0 1
40903: ARRAY
40904: PPUSH
40905: LD_INT 30
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PPUSH
40915: CALL_OW 72
40919: NOT
40920: AND
40921: IFFALSE 41135
// begin if sci >= 6 then
40923: LD_VAR 0 8
40927: PUSH
40928: LD_INT 6
40930: GREATEREQUAL
40931: IFFALSE 40935
// exit ;
40933: GO 43354
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40935: LD_ADDR_EXP 155
40939: PUSH
40940: LD_EXP 155
40944: PPUSH
40945: LD_VAR 0 1
40949: PPUSH
40950: LD_INT 2
40952: PPUSH
40953: CALL_OW 1
40957: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40958: LD_ADDR_VAR 0 9
40962: PUSH
40963: LD_VAR 0 4
40967: PUSH
40968: LD_VAR 0 8
40972: DIFF
40973: PPUSH
40974: LD_INT 4
40976: PPUSH
40977: CALL 99699 0 2
40981: ST_TO_ADDR
// p := [ ] ;
40982: LD_ADDR_VAR 0 11
40986: PUSH
40987: EMPTY
40988: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40989: LD_VAR 0 8
40993: PUSH
40994: LD_INT 6
40996: LESS
40997: PUSH
40998: LD_VAR 0 9
41002: PUSH
41003: LD_INT 6
41005: GREATER
41006: AND
41007: IFFALSE 41088
// begin for i = 1 to 6 - sci do
41009: LD_ADDR_VAR 0 3
41013: PUSH
41014: DOUBLE
41015: LD_INT 1
41017: DEC
41018: ST_TO_ADDR
41019: LD_INT 6
41021: PUSH
41022: LD_VAR 0 8
41026: MINUS
41027: PUSH
41028: FOR_TO
41029: IFFALSE 41084
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41031: LD_ADDR_VAR 0 11
41035: PUSH
41036: LD_VAR 0 11
41040: PPUSH
41041: LD_VAR 0 11
41045: PUSH
41046: LD_INT 1
41048: PLUS
41049: PPUSH
41050: LD_VAR 0 9
41054: PUSH
41055: LD_INT 1
41057: ARRAY
41058: PPUSH
41059: CALL_OW 2
41063: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41064: LD_ADDR_VAR 0 9
41068: PUSH
41069: LD_VAR 0 9
41073: PPUSH
41074: LD_INT 1
41076: PPUSH
41077: CALL_OW 3
41081: ST_TO_ADDR
// end ;
41082: GO 41028
41084: POP
41085: POP
// end else
41086: GO 41108
// if sort then
41088: LD_VAR 0 9
41092: IFFALSE 41108
// p := sort [ 1 ] ;
41094: LD_ADDR_VAR 0 11
41098: PUSH
41099: LD_VAR 0 9
41103: PUSH
41104: LD_INT 1
41106: ARRAY
41107: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41108: LD_ADDR_VAR 0 2
41112: PUSH
41113: LD_INT 0
41115: PUSH
41116: LD_INT 0
41118: PUSH
41119: LD_INT 0
41121: PUSH
41122: LD_VAR 0 11
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: ST_TO_ADDR
// exit ;
41133: GO 43354
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41135: LD_EXP 140
41139: PUSH
41140: LD_EXP 139
41144: PUSH
41145: LD_VAR 0 1
41149: ARRAY
41150: ARRAY
41151: PUSH
41152: LD_EXP 113
41156: PUSH
41157: LD_VAR 0 1
41161: ARRAY
41162: PPUSH
41163: LD_INT 2
41165: PUSH
41166: LD_INT 30
41168: PUSH
41169: LD_INT 6
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 30
41178: PUSH
41179: LD_INT 7
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 30
41188: PUSH
41189: LD_INT 8
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: PPUSH
41202: CALL_OW 72
41206: AND
41207: PUSH
41208: LD_EXP 113
41212: PUSH
41213: LD_VAR 0 1
41217: ARRAY
41218: PPUSH
41219: LD_INT 30
41221: PUSH
41222: LD_INT 3
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PPUSH
41229: CALL_OW 72
41233: AND
41234: IFFALSE 41968
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41236: LD_ADDR_EXP 155
41240: PUSH
41241: LD_EXP 155
41245: PPUSH
41246: LD_VAR 0 1
41250: PPUSH
41251: LD_INT 3
41253: PPUSH
41254: CALL_OW 1
41258: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41259: LD_ADDR_VAR 0 2
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: LD_INT 0
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: LIST
41280: LIST
41281: ST_TO_ADDR
// if not eng then
41282: LD_VAR 0 6
41286: NOT
41287: IFFALSE 41350
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41289: LD_ADDR_VAR 0 11
41293: PUSH
41294: LD_VAR 0 4
41298: PPUSH
41299: LD_INT 2
41301: PPUSH
41302: CALL 99699 0 2
41306: PUSH
41307: LD_INT 1
41309: ARRAY
41310: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41311: LD_ADDR_VAR 0 2
41315: PUSH
41316: LD_VAR 0 2
41320: PPUSH
41321: LD_INT 2
41323: PPUSH
41324: LD_VAR 0 11
41328: PPUSH
41329: CALL_OW 1
41333: ST_TO_ADDR
// tmp := tmp diff p ;
41334: LD_ADDR_VAR 0 4
41338: PUSH
41339: LD_VAR 0 4
41343: PUSH
41344: LD_VAR 0 11
41348: DIFF
41349: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41350: LD_VAR 0 4
41354: PUSH
41355: LD_VAR 0 8
41359: PUSH
41360: LD_INT 6
41362: LESS
41363: AND
41364: IFFALSE 41552
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41366: LD_ADDR_VAR 0 9
41370: PUSH
41371: LD_VAR 0 4
41375: PUSH
41376: LD_VAR 0 8
41380: PUSH
41381: LD_VAR 0 7
41385: UNION
41386: DIFF
41387: PPUSH
41388: LD_INT 4
41390: PPUSH
41391: CALL 99699 0 2
41395: ST_TO_ADDR
// p := [ ] ;
41396: LD_ADDR_VAR 0 11
41400: PUSH
41401: EMPTY
41402: ST_TO_ADDR
// if sort then
41403: LD_VAR 0 9
41407: IFFALSE 41523
// for i = 1 to 6 - sci do
41409: LD_ADDR_VAR 0 3
41413: PUSH
41414: DOUBLE
41415: LD_INT 1
41417: DEC
41418: ST_TO_ADDR
41419: LD_INT 6
41421: PUSH
41422: LD_VAR 0 8
41426: MINUS
41427: PUSH
41428: FOR_TO
41429: IFFALSE 41521
// begin if i = sort then
41431: LD_VAR 0 3
41435: PUSH
41436: LD_VAR 0 9
41440: EQUAL
41441: IFFALSE 41445
// break ;
41443: GO 41521
// if GetClass ( i ) = 4 then
41445: LD_VAR 0 3
41449: PPUSH
41450: CALL_OW 257
41454: PUSH
41455: LD_INT 4
41457: EQUAL
41458: IFFALSE 41462
// continue ;
41460: GO 41428
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41462: LD_ADDR_VAR 0 11
41466: PUSH
41467: LD_VAR 0 11
41471: PPUSH
41472: LD_VAR 0 11
41476: PUSH
41477: LD_INT 1
41479: PLUS
41480: PPUSH
41481: LD_VAR 0 9
41485: PUSH
41486: LD_VAR 0 3
41490: ARRAY
41491: PPUSH
41492: CALL_OW 2
41496: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41497: LD_ADDR_VAR 0 4
41501: PUSH
41502: LD_VAR 0 4
41506: PUSH
41507: LD_VAR 0 9
41511: PUSH
41512: LD_VAR 0 3
41516: ARRAY
41517: DIFF
41518: ST_TO_ADDR
// end ;
41519: GO 41428
41521: POP
41522: POP
// if p then
41523: LD_VAR 0 11
41527: IFFALSE 41552
// result := Replace ( result , 4 , p ) ;
41529: LD_ADDR_VAR 0 2
41533: PUSH
41534: LD_VAR 0 2
41538: PPUSH
41539: LD_INT 4
41541: PPUSH
41542: LD_VAR 0 11
41546: PPUSH
41547: CALL_OW 1
41551: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41552: LD_VAR 0 4
41556: PUSH
41557: LD_VAR 0 7
41561: PUSH
41562: LD_INT 6
41564: LESS
41565: AND
41566: IFFALSE 41754
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41568: LD_ADDR_VAR 0 9
41572: PUSH
41573: LD_VAR 0 4
41577: PUSH
41578: LD_VAR 0 8
41582: PUSH
41583: LD_VAR 0 7
41587: UNION
41588: DIFF
41589: PPUSH
41590: LD_INT 3
41592: PPUSH
41593: CALL 99699 0 2
41597: ST_TO_ADDR
// p := [ ] ;
41598: LD_ADDR_VAR 0 11
41602: PUSH
41603: EMPTY
41604: ST_TO_ADDR
// if sort then
41605: LD_VAR 0 9
41609: IFFALSE 41725
// for i = 1 to 6 - mech do
41611: LD_ADDR_VAR 0 3
41615: PUSH
41616: DOUBLE
41617: LD_INT 1
41619: DEC
41620: ST_TO_ADDR
41621: LD_INT 6
41623: PUSH
41624: LD_VAR 0 7
41628: MINUS
41629: PUSH
41630: FOR_TO
41631: IFFALSE 41723
// begin if i = sort then
41633: LD_VAR 0 3
41637: PUSH
41638: LD_VAR 0 9
41642: EQUAL
41643: IFFALSE 41647
// break ;
41645: GO 41723
// if GetClass ( i ) = 3 then
41647: LD_VAR 0 3
41651: PPUSH
41652: CALL_OW 257
41656: PUSH
41657: LD_INT 3
41659: EQUAL
41660: IFFALSE 41664
// continue ;
41662: GO 41630
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41664: LD_ADDR_VAR 0 11
41668: PUSH
41669: LD_VAR 0 11
41673: PPUSH
41674: LD_VAR 0 11
41678: PUSH
41679: LD_INT 1
41681: PLUS
41682: PPUSH
41683: LD_VAR 0 9
41687: PUSH
41688: LD_VAR 0 3
41692: ARRAY
41693: PPUSH
41694: CALL_OW 2
41698: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41699: LD_ADDR_VAR 0 4
41703: PUSH
41704: LD_VAR 0 4
41708: PUSH
41709: LD_VAR 0 9
41713: PUSH
41714: LD_VAR 0 3
41718: ARRAY
41719: DIFF
41720: ST_TO_ADDR
// end ;
41721: GO 41630
41723: POP
41724: POP
// if p then
41725: LD_VAR 0 11
41729: IFFALSE 41754
// result := Replace ( result , 3 , p ) ;
41731: LD_ADDR_VAR 0 2
41735: PUSH
41736: LD_VAR 0 2
41740: PPUSH
41741: LD_INT 3
41743: PPUSH
41744: LD_VAR 0 11
41748: PPUSH
41749: CALL_OW 1
41753: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41754: LD_VAR 0 4
41758: PUSH
41759: LD_INT 6
41761: GREATER
41762: PUSH
41763: LD_VAR 0 6
41767: PUSH
41768: LD_INT 6
41770: LESS
41771: AND
41772: IFFALSE 41966
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41774: LD_ADDR_VAR 0 9
41778: PUSH
41779: LD_VAR 0 4
41783: PUSH
41784: LD_VAR 0 8
41788: PUSH
41789: LD_VAR 0 7
41793: UNION
41794: PUSH
41795: LD_VAR 0 6
41799: UNION
41800: DIFF
41801: PPUSH
41802: LD_INT 2
41804: PPUSH
41805: CALL 99699 0 2
41809: ST_TO_ADDR
// p := [ ] ;
41810: LD_ADDR_VAR 0 11
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// if sort then
41817: LD_VAR 0 9
41821: IFFALSE 41937
// for i = 1 to 6 - eng do
41823: LD_ADDR_VAR 0 3
41827: PUSH
41828: DOUBLE
41829: LD_INT 1
41831: DEC
41832: ST_TO_ADDR
41833: LD_INT 6
41835: PUSH
41836: LD_VAR 0 6
41840: MINUS
41841: PUSH
41842: FOR_TO
41843: IFFALSE 41935
// begin if i = sort then
41845: LD_VAR 0 3
41849: PUSH
41850: LD_VAR 0 9
41854: EQUAL
41855: IFFALSE 41859
// break ;
41857: GO 41935
// if GetClass ( i ) = 2 then
41859: LD_VAR 0 3
41863: PPUSH
41864: CALL_OW 257
41868: PUSH
41869: LD_INT 2
41871: EQUAL
41872: IFFALSE 41876
// continue ;
41874: GO 41842
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41876: LD_ADDR_VAR 0 11
41880: PUSH
41881: LD_VAR 0 11
41885: PPUSH
41886: LD_VAR 0 11
41890: PUSH
41891: LD_INT 1
41893: PLUS
41894: PPUSH
41895: LD_VAR 0 9
41899: PUSH
41900: LD_VAR 0 3
41904: ARRAY
41905: PPUSH
41906: CALL_OW 2
41910: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41911: LD_ADDR_VAR 0 4
41915: PUSH
41916: LD_VAR 0 4
41920: PUSH
41921: LD_VAR 0 9
41925: PUSH
41926: LD_VAR 0 3
41930: ARRAY
41931: DIFF
41932: ST_TO_ADDR
// end ;
41933: GO 41842
41935: POP
41936: POP
// if p then
41937: LD_VAR 0 11
41941: IFFALSE 41966
// result := Replace ( result , 2 , p ) ;
41943: LD_ADDR_VAR 0 2
41947: PUSH
41948: LD_VAR 0 2
41952: PPUSH
41953: LD_INT 2
41955: PPUSH
41956: LD_VAR 0 11
41960: PPUSH
41961: CALL_OW 1
41965: ST_TO_ADDR
// end ; exit ;
41966: GO 43354
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41968: LD_EXP 140
41972: PUSH
41973: LD_EXP 139
41977: PUSH
41978: LD_VAR 0 1
41982: ARRAY
41983: ARRAY
41984: NOT
41985: PUSH
41986: LD_EXP 113
41990: PUSH
41991: LD_VAR 0 1
41995: ARRAY
41996: PPUSH
41997: LD_INT 30
41999: PUSH
42000: LD_INT 3
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PPUSH
42007: CALL_OW 72
42011: AND
42012: PUSH
42013: LD_EXP 118
42017: PUSH
42018: LD_VAR 0 1
42022: ARRAY
42023: AND
42024: IFFALSE 42632
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42026: LD_ADDR_EXP 155
42030: PUSH
42031: LD_EXP 155
42035: PPUSH
42036: LD_VAR 0 1
42040: PPUSH
42041: LD_INT 5
42043: PPUSH
42044: CALL_OW 1
42048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42049: LD_ADDR_VAR 0 2
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: LD_INT 0
42059: PUSH
42060: LD_INT 0
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: ST_TO_ADDR
// if sci > 1 then
42072: LD_VAR 0 8
42076: PUSH
42077: LD_INT 1
42079: GREATER
42080: IFFALSE 42108
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42082: LD_ADDR_VAR 0 4
42086: PUSH
42087: LD_VAR 0 4
42091: PUSH
42092: LD_VAR 0 8
42096: PUSH
42097: LD_VAR 0 8
42101: PUSH
42102: LD_INT 1
42104: ARRAY
42105: DIFF
42106: DIFF
42107: ST_TO_ADDR
// if tmp and not sci then
42108: LD_VAR 0 4
42112: PUSH
42113: LD_VAR 0 8
42117: NOT
42118: AND
42119: IFFALSE 42188
// begin sort := SortBySkill ( tmp , 4 ) ;
42121: LD_ADDR_VAR 0 9
42125: PUSH
42126: LD_VAR 0 4
42130: PPUSH
42131: LD_INT 4
42133: PPUSH
42134: CALL 99699 0 2
42138: ST_TO_ADDR
// if sort then
42139: LD_VAR 0 9
42143: IFFALSE 42159
// p := sort [ 1 ] ;
42145: LD_ADDR_VAR 0 11
42149: PUSH
42150: LD_VAR 0 9
42154: PUSH
42155: LD_INT 1
42157: ARRAY
42158: ST_TO_ADDR
// if p then
42159: LD_VAR 0 11
42163: IFFALSE 42188
// result := Replace ( result , 4 , p ) ;
42165: LD_ADDR_VAR 0 2
42169: PUSH
42170: LD_VAR 0 2
42174: PPUSH
42175: LD_INT 4
42177: PPUSH
42178: LD_VAR 0 11
42182: PPUSH
42183: CALL_OW 1
42187: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42188: LD_ADDR_VAR 0 4
42192: PUSH
42193: LD_VAR 0 4
42197: PUSH
42198: LD_VAR 0 7
42202: DIFF
42203: ST_TO_ADDR
// if tmp and mech < 6 then
42204: LD_VAR 0 4
42208: PUSH
42209: LD_VAR 0 7
42213: PUSH
42214: LD_INT 6
42216: LESS
42217: AND
42218: IFFALSE 42406
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42220: LD_ADDR_VAR 0 9
42224: PUSH
42225: LD_VAR 0 4
42229: PUSH
42230: LD_VAR 0 8
42234: PUSH
42235: LD_VAR 0 7
42239: UNION
42240: DIFF
42241: PPUSH
42242: LD_INT 3
42244: PPUSH
42245: CALL 99699 0 2
42249: ST_TO_ADDR
// p := [ ] ;
42250: LD_ADDR_VAR 0 11
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// if sort then
42257: LD_VAR 0 9
42261: IFFALSE 42377
// for i = 1 to 6 - mech do
42263: LD_ADDR_VAR 0 3
42267: PUSH
42268: DOUBLE
42269: LD_INT 1
42271: DEC
42272: ST_TO_ADDR
42273: LD_INT 6
42275: PUSH
42276: LD_VAR 0 7
42280: MINUS
42281: PUSH
42282: FOR_TO
42283: IFFALSE 42375
// begin if i = sort then
42285: LD_VAR 0 3
42289: PUSH
42290: LD_VAR 0 9
42294: EQUAL
42295: IFFALSE 42299
// break ;
42297: GO 42375
// if GetClass ( i ) = 3 then
42299: LD_VAR 0 3
42303: PPUSH
42304: CALL_OW 257
42308: PUSH
42309: LD_INT 3
42311: EQUAL
42312: IFFALSE 42316
// continue ;
42314: GO 42282
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42316: LD_ADDR_VAR 0 11
42320: PUSH
42321: LD_VAR 0 11
42325: PPUSH
42326: LD_VAR 0 11
42330: PUSH
42331: LD_INT 1
42333: PLUS
42334: PPUSH
42335: LD_VAR 0 9
42339: PUSH
42340: LD_VAR 0 3
42344: ARRAY
42345: PPUSH
42346: CALL_OW 2
42350: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42351: LD_ADDR_VAR 0 4
42355: PUSH
42356: LD_VAR 0 4
42360: PUSH
42361: LD_VAR 0 9
42365: PUSH
42366: LD_VAR 0 3
42370: ARRAY
42371: DIFF
42372: ST_TO_ADDR
// end ;
42373: GO 42282
42375: POP
42376: POP
// if p then
42377: LD_VAR 0 11
42381: IFFALSE 42406
// result := Replace ( result , 3 , p ) ;
42383: LD_ADDR_VAR 0 2
42387: PUSH
42388: LD_VAR 0 2
42392: PPUSH
42393: LD_INT 3
42395: PPUSH
42396: LD_VAR 0 11
42400: PPUSH
42401: CALL_OW 1
42405: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42406: LD_ADDR_VAR 0 4
42410: PUSH
42411: LD_VAR 0 4
42415: PUSH
42416: LD_VAR 0 6
42420: DIFF
42421: ST_TO_ADDR
// if tmp and eng < 6 then
42422: LD_VAR 0 4
42426: PUSH
42427: LD_VAR 0 6
42431: PUSH
42432: LD_INT 6
42434: LESS
42435: AND
42436: IFFALSE 42630
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42438: LD_ADDR_VAR 0 9
42442: PUSH
42443: LD_VAR 0 4
42447: PUSH
42448: LD_VAR 0 8
42452: PUSH
42453: LD_VAR 0 7
42457: UNION
42458: PUSH
42459: LD_VAR 0 6
42463: UNION
42464: DIFF
42465: PPUSH
42466: LD_INT 2
42468: PPUSH
42469: CALL 99699 0 2
42473: ST_TO_ADDR
// p := [ ] ;
42474: LD_ADDR_VAR 0 11
42478: PUSH
42479: EMPTY
42480: ST_TO_ADDR
// if sort then
42481: LD_VAR 0 9
42485: IFFALSE 42601
// for i = 1 to 6 - eng do
42487: LD_ADDR_VAR 0 3
42491: PUSH
42492: DOUBLE
42493: LD_INT 1
42495: DEC
42496: ST_TO_ADDR
42497: LD_INT 6
42499: PUSH
42500: LD_VAR 0 6
42504: MINUS
42505: PUSH
42506: FOR_TO
42507: IFFALSE 42599
// begin if i = sort then
42509: LD_VAR 0 3
42513: PUSH
42514: LD_VAR 0 9
42518: EQUAL
42519: IFFALSE 42523
// break ;
42521: GO 42599
// if GetClass ( i ) = 2 then
42523: LD_VAR 0 3
42527: PPUSH
42528: CALL_OW 257
42532: PUSH
42533: LD_INT 2
42535: EQUAL
42536: IFFALSE 42540
// continue ;
42538: GO 42506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42540: LD_ADDR_VAR 0 11
42544: PUSH
42545: LD_VAR 0 11
42549: PPUSH
42550: LD_VAR 0 11
42554: PUSH
42555: LD_INT 1
42557: PLUS
42558: PPUSH
42559: LD_VAR 0 9
42563: PUSH
42564: LD_VAR 0 3
42568: ARRAY
42569: PPUSH
42570: CALL_OW 2
42574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42575: LD_ADDR_VAR 0 4
42579: PUSH
42580: LD_VAR 0 4
42584: PUSH
42585: LD_VAR 0 9
42589: PUSH
42590: LD_VAR 0 3
42594: ARRAY
42595: DIFF
42596: ST_TO_ADDR
// end ;
42597: GO 42506
42599: POP
42600: POP
// if p then
42601: LD_VAR 0 11
42605: IFFALSE 42630
// result := Replace ( result , 2 , p ) ;
42607: LD_ADDR_VAR 0 2
42611: PUSH
42612: LD_VAR 0 2
42616: PPUSH
42617: LD_INT 2
42619: PPUSH
42620: LD_VAR 0 11
42624: PPUSH
42625: CALL_OW 1
42629: ST_TO_ADDR
// end ; exit ;
42630: GO 43354
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42632: LD_EXP 140
42636: PUSH
42637: LD_EXP 139
42641: PUSH
42642: LD_VAR 0 1
42646: ARRAY
42647: ARRAY
42648: NOT
42649: PUSH
42650: LD_EXP 113
42654: PUSH
42655: LD_VAR 0 1
42659: ARRAY
42660: PPUSH
42661: LD_INT 30
42663: PUSH
42664: LD_INT 3
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PPUSH
42671: CALL_OW 72
42675: AND
42676: PUSH
42677: LD_EXP 118
42681: PUSH
42682: LD_VAR 0 1
42686: ARRAY
42687: NOT
42688: AND
42689: IFFALSE 43354
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42691: LD_ADDR_EXP 155
42695: PUSH
42696: LD_EXP 155
42700: PPUSH
42701: LD_VAR 0 1
42705: PPUSH
42706: LD_INT 6
42708: PPUSH
42709: CALL_OW 1
42713: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42714: LD_ADDR_VAR 0 2
42718: PUSH
42719: LD_INT 0
42721: PUSH
42722: LD_INT 0
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// if sci >= 1 then
42737: LD_VAR 0 8
42741: PUSH
42742: LD_INT 1
42744: GREATEREQUAL
42745: IFFALSE 42767
// tmp := tmp diff sci [ 1 ] ;
42747: LD_ADDR_VAR 0 4
42751: PUSH
42752: LD_VAR 0 4
42756: PUSH
42757: LD_VAR 0 8
42761: PUSH
42762: LD_INT 1
42764: ARRAY
42765: DIFF
42766: ST_TO_ADDR
// if tmp and not sci then
42767: LD_VAR 0 4
42771: PUSH
42772: LD_VAR 0 8
42776: NOT
42777: AND
42778: IFFALSE 42847
// begin sort := SortBySkill ( tmp , 4 ) ;
42780: LD_ADDR_VAR 0 9
42784: PUSH
42785: LD_VAR 0 4
42789: PPUSH
42790: LD_INT 4
42792: PPUSH
42793: CALL 99699 0 2
42797: ST_TO_ADDR
// if sort then
42798: LD_VAR 0 9
42802: IFFALSE 42818
// p := sort [ 1 ] ;
42804: LD_ADDR_VAR 0 11
42808: PUSH
42809: LD_VAR 0 9
42813: PUSH
42814: LD_INT 1
42816: ARRAY
42817: ST_TO_ADDR
// if p then
42818: LD_VAR 0 11
42822: IFFALSE 42847
// result := Replace ( result , 4 , p ) ;
42824: LD_ADDR_VAR 0 2
42828: PUSH
42829: LD_VAR 0 2
42833: PPUSH
42834: LD_INT 4
42836: PPUSH
42837: LD_VAR 0 11
42841: PPUSH
42842: CALL_OW 1
42846: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42847: LD_ADDR_VAR 0 4
42851: PUSH
42852: LD_VAR 0 4
42856: PUSH
42857: LD_VAR 0 7
42861: DIFF
42862: ST_TO_ADDR
// if tmp and mech < 6 then
42863: LD_VAR 0 4
42867: PUSH
42868: LD_VAR 0 7
42872: PUSH
42873: LD_INT 6
42875: LESS
42876: AND
42877: IFFALSE 43059
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42879: LD_ADDR_VAR 0 9
42883: PUSH
42884: LD_VAR 0 4
42888: PUSH
42889: LD_VAR 0 7
42893: DIFF
42894: PPUSH
42895: LD_INT 3
42897: PPUSH
42898: CALL 99699 0 2
42902: ST_TO_ADDR
// p := [ ] ;
42903: LD_ADDR_VAR 0 11
42907: PUSH
42908: EMPTY
42909: ST_TO_ADDR
// if sort then
42910: LD_VAR 0 9
42914: IFFALSE 43030
// for i = 1 to 6 - mech do
42916: LD_ADDR_VAR 0 3
42920: PUSH
42921: DOUBLE
42922: LD_INT 1
42924: DEC
42925: ST_TO_ADDR
42926: LD_INT 6
42928: PUSH
42929: LD_VAR 0 7
42933: MINUS
42934: PUSH
42935: FOR_TO
42936: IFFALSE 43028
// begin if i = sort then
42938: LD_VAR 0 3
42942: PUSH
42943: LD_VAR 0 9
42947: EQUAL
42948: IFFALSE 42952
// break ;
42950: GO 43028
// if GetClass ( i ) = 3 then
42952: LD_VAR 0 3
42956: PPUSH
42957: CALL_OW 257
42961: PUSH
42962: LD_INT 3
42964: EQUAL
42965: IFFALSE 42969
// continue ;
42967: GO 42935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42969: LD_ADDR_VAR 0 11
42973: PUSH
42974: LD_VAR 0 11
42978: PPUSH
42979: LD_VAR 0 11
42983: PUSH
42984: LD_INT 1
42986: PLUS
42987: PPUSH
42988: LD_VAR 0 9
42992: PUSH
42993: LD_VAR 0 3
42997: ARRAY
42998: PPUSH
42999: CALL_OW 2
43003: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43004: LD_ADDR_VAR 0 4
43008: PUSH
43009: LD_VAR 0 4
43013: PUSH
43014: LD_VAR 0 9
43018: PUSH
43019: LD_VAR 0 3
43023: ARRAY
43024: DIFF
43025: ST_TO_ADDR
// end ;
43026: GO 42935
43028: POP
43029: POP
// if p then
43030: LD_VAR 0 11
43034: IFFALSE 43059
// result := Replace ( result , 3 , p ) ;
43036: LD_ADDR_VAR 0 2
43040: PUSH
43041: LD_VAR 0 2
43045: PPUSH
43046: LD_INT 3
43048: PPUSH
43049: LD_VAR 0 11
43053: PPUSH
43054: CALL_OW 1
43058: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43059: LD_ADDR_VAR 0 4
43063: PUSH
43064: LD_VAR 0 4
43068: PUSH
43069: LD_VAR 0 6
43073: DIFF
43074: ST_TO_ADDR
// if tmp and eng < 4 then
43075: LD_VAR 0 4
43079: PUSH
43080: LD_VAR 0 6
43084: PUSH
43085: LD_INT 4
43087: LESS
43088: AND
43089: IFFALSE 43279
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43091: LD_ADDR_VAR 0 9
43095: PUSH
43096: LD_VAR 0 4
43100: PUSH
43101: LD_VAR 0 7
43105: PUSH
43106: LD_VAR 0 6
43110: UNION
43111: DIFF
43112: PPUSH
43113: LD_INT 2
43115: PPUSH
43116: CALL 99699 0 2
43120: ST_TO_ADDR
// p := [ ] ;
43121: LD_ADDR_VAR 0 11
43125: PUSH
43126: EMPTY
43127: ST_TO_ADDR
// if sort then
43128: LD_VAR 0 9
43132: IFFALSE 43248
// for i = 1 to 4 - eng do
43134: LD_ADDR_VAR 0 3
43138: PUSH
43139: DOUBLE
43140: LD_INT 1
43142: DEC
43143: ST_TO_ADDR
43144: LD_INT 4
43146: PUSH
43147: LD_VAR 0 6
43151: MINUS
43152: PUSH
43153: FOR_TO
43154: IFFALSE 43246
// begin if i = sort then
43156: LD_VAR 0 3
43160: PUSH
43161: LD_VAR 0 9
43165: EQUAL
43166: IFFALSE 43170
// break ;
43168: GO 43246
// if GetClass ( i ) = 2 then
43170: LD_VAR 0 3
43174: PPUSH
43175: CALL_OW 257
43179: PUSH
43180: LD_INT 2
43182: EQUAL
43183: IFFALSE 43187
// continue ;
43185: GO 43153
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43187: LD_ADDR_VAR 0 11
43191: PUSH
43192: LD_VAR 0 11
43196: PPUSH
43197: LD_VAR 0 11
43201: PUSH
43202: LD_INT 1
43204: PLUS
43205: PPUSH
43206: LD_VAR 0 9
43210: PUSH
43211: LD_VAR 0 3
43215: ARRAY
43216: PPUSH
43217: CALL_OW 2
43221: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43222: LD_ADDR_VAR 0 4
43226: PUSH
43227: LD_VAR 0 4
43231: PUSH
43232: LD_VAR 0 9
43236: PUSH
43237: LD_VAR 0 3
43241: ARRAY
43242: DIFF
43243: ST_TO_ADDR
// end ;
43244: GO 43153
43246: POP
43247: POP
// if p then
43248: LD_VAR 0 11
43252: IFFALSE 43277
// result := Replace ( result , 2 , p ) ;
43254: LD_ADDR_VAR 0 2
43258: PUSH
43259: LD_VAR 0 2
43263: PPUSH
43264: LD_INT 2
43266: PPUSH
43267: LD_VAR 0 11
43271: PPUSH
43272: CALL_OW 1
43276: ST_TO_ADDR
// end else
43277: GO 43323
// for i = eng downto 5 do
43279: LD_ADDR_VAR 0 3
43283: PUSH
43284: DOUBLE
43285: LD_VAR 0 6
43289: INC
43290: ST_TO_ADDR
43291: LD_INT 5
43293: PUSH
43294: FOR_DOWNTO
43295: IFFALSE 43321
// tmp := tmp union eng [ i ] ;
43297: LD_ADDR_VAR 0 4
43301: PUSH
43302: LD_VAR 0 4
43306: PUSH
43307: LD_VAR 0 6
43311: PUSH
43312: LD_VAR 0 3
43316: ARRAY
43317: UNION
43318: ST_TO_ADDR
43319: GO 43294
43321: POP
43322: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43323: LD_ADDR_VAR 0 2
43327: PUSH
43328: LD_VAR 0 2
43332: PPUSH
43333: LD_INT 1
43335: PPUSH
43336: LD_VAR 0 4
43340: PUSH
43341: LD_VAR 0 5
43345: DIFF
43346: PPUSH
43347: CALL_OW 1
43351: ST_TO_ADDR
// exit ;
43352: GO 43354
// end ; end ;
43354: LD_VAR 0 2
43358: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43359: LD_INT 0
43361: PPUSH
43362: PPUSH
43363: PPUSH
// if not mc_bases then
43364: LD_EXP 113
43368: NOT
43369: IFFALSE 43373
// exit ;
43371: GO 43479
// for i = 1 to mc_bases do
43373: LD_ADDR_VAR 0 2
43377: PUSH
43378: DOUBLE
43379: LD_INT 1
43381: DEC
43382: ST_TO_ADDR
43383: LD_EXP 113
43387: PUSH
43388: FOR_TO
43389: IFFALSE 43470
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43391: LD_ADDR_VAR 0 3
43395: PUSH
43396: LD_EXP 113
43400: PUSH
43401: LD_VAR 0 2
43405: ARRAY
43406: PPUSH
43407: LD_INT 21
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: LD_INT 24
43422: PUSH
43423: LD_INT 1000
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PPUSH
43438: CALL_OW 72
43442: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43443: LD_ADDR_EXP 114
43447: PUSH
43448: LD_EXP 114
43452: PPUSH
43453: LD_VAR 0 2
43457: PPUSH
43458: LD_VAR 0 3
43462: PPUSH
43463: CALL_OW 1
43467: ST_TO_ADDR
// end ;
43468: GO 43388
43470: POP
43471: POP
// RaiseSailEvent ( 101 ) ;
43472: LD_INT 101
43474: PPUSH
43475: CALL_OW 427
// end ;
43479: LD_VAR 0 1
43483: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43484: LD_INT 0
43486: PPUSH
43487: PPUSH
43488: PPUSH
43489: PPUSH
43490: PPUSH
43491: PPUSH
43492: PPUSH
// if not mc_bases then
43493: LD_EXP 113
43497: NOT
43498: IFFALSE 43502
// exit ;
43500: GO 44064
// for i = 1 to mc_bases do
43502: LD_ADDR_VAR 0 2
43506: PUSH
43507: DOUBLE
43508: LD_INT 1
43510: DEC
43511: ST_TO_ADDR
43512: LD_EXP 113
43516: PUSH
43517: FOR_TO
43518: IFFALSE 44055
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43520: LD_ADDR_VAR 0 5
43524: PUSH
43525: LD_EXP 113
43529: PUSH
43530: LD_VAR 0 2
43534: ARRAY
43535: PUSH
43536: LD_EXP 142
43540: PUSH
43541: LD_VAR 0 2
43545: ARRAY
43546: UNION
43547: PPUSH
43548: LD_INT 21
43550: PUSH
43551: LD_INT 1
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: LD_INT 3
43563: PUSH
43564: LD_INT 54
43566: PUSH
43567: EMPTY
43568: LIST
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 3
43576: PUSH
43577: LD_INT 24
43579: PUSH
43580: LD_INT 800
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: LIST
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PPUSH
43600: CALL_OW 72
43604: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43605: LD_ADDR_VAR 0 6
43609: PUSH
43610: LD_EXP 113
43614: PUSH
43615: LD_VAR 0 2
43619: ARRAY
43620: PPUSH
43621: LD_INT 21
43623: PUSH
43624: LD_INT 1
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 3
43636: PUSH
43637: LD_INT 54
43639: PUSH
43640: EMPTY
43641: LIST
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 3
43649: PUSH
43650: LD_INT 24
43652: PUSH
43653: LD_INT 250
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PPUSH
43673: CALL_OW 72
43677: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43678: LD_ADDR_VAR 0 7
43682: PUSH
43683: LD_VAR 0 5
43687: PUSH
43688: LD_VAR 0 6
43692: DIFF
43693: ST_TO_ADDR
// if not need_heal_1 then
43694: LD_VAR 0 6
43698: NOT
43699: IFFALSE 43732
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43701: LD_ADDR_EXP 116
43705: PUSH
43706: LD_EXP 116
43710: PPUSH
43711: LD_VAR 0 2
43715: PUSH
43716: LD_INT 1
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PPUSH
43723: EMPTY
43724: PPUSH
43725: CALL 70150 0 3
43729: ST_TO_ADDR
43730: GO 43802
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43732: LD_ADDR_EXP 116
43736: PUSH
43737: LD_EXP 116
43741: PPUSH
43742: LD_VAR 0 2
43746: PUSH
43747: LD_INT 1
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PPUSH
43754: LD_EXP 116
43758: PUSH
43759: LD_VAR 0 2
43763: ARRAY
43764: PUSH
43765: LD_INT 1
43767: ARRAY
43768: PPUSH
43769: LD_INT 3
43771: PUSH
43772: LD_INT 24
43774: PUSH
43775: LD_INT 1000
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PPUSH
43786: CALL_OW 72
43790: PUSH
43791: LD_VAR 0 6
43795: UNION
43796: PPUSH
43797: CALL 70150 0 3
43801: ST_TO_ADDR
// if not need_heal_2 then
43802: LD_VAR 0 7
43806: NOT
43807: IFFALSE 43840
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43809: LD_ADDR_EXP 116
43813: PUSH
43814: LD_EXP 116
43818: PPUSH
43819: LD_VAR 0 2
43823: PUSH
43824: LD_INT 2
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PPUSH
43831: EMPTY
43832: PPUSH
43833: CALL 70150 0 3
43837: ST_TO_ADDR
43838: GO 43872
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43840: LD_ADDR_EXP 116
43844: PUSH
43845: LD_EXP 116
43849: PPUSH
43850: LD_VAR 0 2
43854: PUSH
43855: LD_INT 2
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PPUSH
43862: LD_VAR 0 7
43866: PPUSH
43867: CALL 70150 0 3
43871: ST_TO_ADDR
// if need_heal_2 then
43872: LD_VAR 0 7
43876: IFFALSE 44037
// for j in need_heal_2 do
43878: LD_ADDR_VAR 0 3
43882: PUSH
43883: LD_VAR 0 7
43887: PUSH
43888: FOR_IN
43889: IFFALSE 44035
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43891: LD_ADDR_VAR 0 5
43895: PUSH
43896: LD_EXP 113
43900: PUSH
43901: LD_VAR 0 2
43905: ARRAY
43906: PPUSH
43907: LD_INT 2
43909: PUSH
43910: LD_INT 30
43912: PUSH
43913: LD_INT 6
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 30
43922: PUSH
43923: LD_INT 7
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 30
43932: PUSH
43933: LD_INT 8
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 30
43942: PUSH
43943: LD_INT 0
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 30
43952: PUSH
43953: LD_INT 1
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: PPUSH
43968: CALL_OW 72
43972: ST_TO_ADDR
// if tmp then
43973: LD_VAR 0 5
43977: IFFALSE 44033
// begin k := NearestUnitToUnit ( tmp , j ) ;
43979: LD_ADDR_VAR 0 4
43983: PUSH
43984: LD_VAR 0 5
43988: PPUSH
43989: LD_VAR 0 3
43993: PPUSH
43994: CALL_OW 74
43998: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43999: LD_VAR 0 3
44003: PPUSH
44004: LD_VAR 0 4
44008: PPUSH
44009: CALL_OW 296
44013: PUSH
44014: LD_INT 5
44016: GREATER
44017: IFFALSE 44033
// ComMoveToNearbyEntrance ( j , k ) ;
44019: LD_VAR 0 3
44023: PPUSH
44024: LD_VAR 0 4
44028: PPUSH
44029: CALL 102016 0 2
// end ; end ;
44033: GO 43888
44035: POP
44036: POP
// if not need_heal_1 and not need_heal_2 then
44037: LD_VAR 0 6
44041: NOT
44042: PUSH
44043: LD_VAR 0 7
44047: NOT
44048: AND
44049: IFFALSE 44053
// continue ;
44051: GO 43517
// end ;
44053: GO 43517
44055: POP
44056: POP
// RaiseSailEvent ( 102 ) ;
44057: LD_INT 102
44059: PPUSH
44060: CALL_OW 427
// end ;
44064: LD_VAR 0 1
44068: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44069: LD_INT 0
44071: PPUSH
44072: PPUSH
44073: PPUSH
44074: PPUSH
44075: PPUSH
44076: PPUSH
44077: PPUSH
44078: PPUSH
// if not mc_bases then
44079: LD_EXP 113
44083: NOT
44084: IFFALSE 44088
// exit ;
44086: GO 44949
// for i = 1 to mc_bases do
44088: LD_ADDR_VAR 0 2
44092: PUSH
44093: DOUBLE
44094: LD_INT 1
44096: DEC
44097: ST_TO_ADDR
44098: LD_EXP 113
44102: PUSH
44103: FOR_TO
44104: IFFALSE 44947
// begin if not mc_building_need_repair [ i ] then
44106: LD_EXP 114
44110: PUSH
44111: LD_VAR 0 2
44115: ARRAY
44116: NOT
44117: IFFALSE 44304
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44119: LD_ADDR_VAR 0 6
44123: PUSH
44124: LD_EXP 132
44128: PUSH
44129: LD_VAR 0 2
44133: ARRAY
44134: PPUSH
44135: LD_INT 3
44137: PUSH
44138: LD_INT 24
44140: PUSH
44141: LD_INT 1000
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 2
44154: PUSH
44155: LD_INT 34
44157: PUSH
44158: LD_INT 13
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 34
44167: PUSH
44168: LD_INT 52
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 34
44177: PUSH
44178: LD_EXP 101
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PPUSH
44197: CALL_OW 72
44201: ST_TO_ADDR
// if cranes then
44202: LD_VAR 0 6
44206: IFFALSE 44268
// for j in cranes do
44208: LD_ADDR_VAR 0 3
44212: PUSH
44213: LD_VAR 0 6
44217: PUSH
44218: FOR_IN
44219: IFFALSE 44266
// if not IsInArea ( j , mc_parking [ i ] ) then
44221: LD_VAR 0 3
44225: PPUSH
44226: LD_EXP 137
44230: PUSH
44231: LD_VAR 0 2
44235: ARRAY
44236: PPUSH
44237: CALL_OW 308
44241: NOT
44242: IFFALSE 44264
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44244: LD_VAR 0 3
44248: PPUSH
44249: LD_EXP 137
44253: PUSH
44254: LD_VAR 0 2
44258: ARRAY
44259: PPUSH
44260: CALL_OW 113
44264: GO 44218
44266: POP
44267: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44268: LD_ADDR_EXP 115
44272: PUSH
44273: LD_EXP 115
44277: PPUSH
44278: LD_VAR 0 2
44282: PPUSH
44283: EMPTY
44284: PPUSH
44285: CALL_OW 1
44289: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44290: LD_VAR 0 2
44294: PPUSH
44295: LD_INT 101
44297: PPUSH
44298: CALL 39192 0 2
// continue ;
44302: GO 44103
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44304: LD_ADDR_EXP 119
44308: PUSH
44309: LD_EXP 119
44313: PPUSH
44314: LD_VAR 0 2
44318: PPUSH
44319: EMPTY
44320: PPUSH
44321: CALL_OW 1
44325: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44326: LD_VAR 0 2
44330: PPUSH
44331: LD_INT 103
44333: PPUSH
44334: CALL 39192 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44338: LD_ADDR_VAR 0 5
44342: PUSH
44343: LD_EXP 113
44347: PUSH
44348: LD_VAR 0 2
44352: ARRAY
44353: PUSH
44354: LD_EXP 142
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: UNION
44365: PPUSH
44366: LD_INT 2
44368: PUSH
44369: LD_INT 25
44371: PUSH
44372: LD_INT 2
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 25
44381: PUSH
44382: LD_INT 16
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: LIST
44393: PUSH
44394: EMPTY
44395: LIST
44396: PPUSH
44397: CALL_OW 72
44401: PUSH
44402: LD_EXP 116
44406: PUSH
44407: LD_VAR 0 2
44411: ARRAY
44412: PUSH
44413: LD_INT 1
44415: ARRAY
44416: PUSH
44417: LD_EXP 116
44421: PUSH
44422: LD_VAR 0 2
44426: ARRAY
44427: PUSH
44428: LD_INT 2
44430: ARRAY
44431: UNION
44432: DIFF
44433: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44434: LD_ADDR_VAR 0 6
44438: PUSH
44439: LD_EXP 132
44443: PUSH
44444: LD_VAR 0 2
44448: ARRAY
44449: PPUSH
44450: LD_INT 2
44452: PUSH
44453: LD_INT 34
44455: PUSH
44456: LD_INT 13
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 34
44465: PUSH
44466: LD_INT 52
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 34
44475: PUSH
44476: LD_EXP 101
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: PPUSH
44491: CALL_OW 72
44495: ST_TO_ADDR
// if cranes then
44496: LD_VAR 0 6
44500: IFFALSE 44636
// begin for j in cranes do
44502: LD_ADDR_VAR 0 3
44506: PUSH
44507: LD_VAR 0 6
44511: PUSH
44512: FOR_IN
44513: IFFALSE 44634
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44515: LD_VAR 0 3
44519: PPUSH
44520: CALL_OW 256
44524: PUSH
44525: LD_INT 1000
44527: EQUAL
44528: PUSH
44529: LD_VAR 0 3
44533: PPUSH
44534: CALL_OW 314
44538: NOT
44539: AND
44540: IFFALSE 44574
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44542: LD_VAR 0 3
44546: PPUSH
44547: LD_EXP 114
44551: PUSH
44552: LD_VAR 0 2
44556: ARRAY
44557: PPUSH
44558: LD_VAR 0 3
44562: PPUSH
44563: CALL_OW 74
44567: PPUSH
44568: CALL_OW 130
44572: GO 44632
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44574: LD_VAR 0 3
44578: PPUSH
44579: CALL_OW 256
44583: PUSH
44584: LD_INT 500
44586: LESS
44587: PUSH
44588: LD_VAR 0 3
44592: PPUSH
44593: LD_EXP 137
44597: PUSH
44598: LD_VAR 0 2
44602: ARRAY
44603: PPUSH
44604: CALL_OW 308
44608: NOT
44609: AND
44610: IFFALSE 44632
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44612: LD_VAR 0 3
44616: PPUSH
44617: LD_EXP 137
44621: PUSH
44622: LD_VAR 0 2
44626: ARRAY
44627: PPUSH
44628: CALL_OW 113
// end ;
44632: GO 44512
44634: POP
44635: POP
// end ; if tmp > 3 then
44636: LD_VAR 0 5
44640: PUSH
44641: LD_INT 3
44643: GREATER
44644: IFFALSE 44664
// tmp := ShrinkArray ( tmp , 4 ) ;
44646: LD_ADDR_VAR 0 5
44650: PUSH
44651: LD_VAR 0 5
44655: PPUSH
44656: LD_INT 4
44658: PPUSH
44659: CALL 101508 0 2
44663: ST_TO_ADDR
// if not tmp then
44664: LD_VAR 0 5
44668: NOT
44669: IFFALSE 44673
// continue ;
44671: GO 44103
// for j in tmp do
44673: LD_ADDR_VAR 0 3
44677: PUSH
44678: LD_VAR 0 5
44682: PUSH
44683: FOR_IN
44684: IFFALSE 44943
// begin if IsInUnit ( j ) then
44686: LD_VAR 0 3
44690: PPUSH
44691: CALL_OW 310
44695: IFFALSE 44706
// ComExitBuilding ( j ) ;
44697: LD_VAR 0 3
44701: PPUSH
44702: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44706: LD_VAR 0 3
44710: PUSH
44711: LD_EXP 115
44715: PUSH
44716: LD_VAR 0 2
44720: ARRAY
44721: IN
44722: NOT
44723: IFFALSE 44781
// begin SetTag ( j , 101 ) ;
44725: LD_VAR 0 3
44729: PPUSH
44730: LD_INT 101
44732: PPUSH
44733: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44737: LD_ADDR_EXP 115
44741: PUSH
44742: LD_EXP 115
44746: PPUSH
44747: LD_VAR 0 2
44751: PUSH
44752: LD_EXP 115
44756: PUSH
44757: LD_VAR 0 2
44761: ARRAY
44762: PUSH
44763: LD_INT 1
44765: PLUS
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PPUSH
44771: LD_VAR 0 3
44775: PPUSH
44776: CALL 70150 0 3
44780: ST_TO_ADDR
// end ; wait ( 1 ) ;
44781: LD_INT 1
44783: PPUSH
44784: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44788: LD_ADDR_VAR 0 7
44792: PUSH
44793: LD_EXP 114
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: ST_TO_ADDR
// if mc_scan [ i ] then
44804: LD_EXP 136
44808: PUSH
44809: LD_VAR 0 2
44813: ARRAY
44814: IFFALSE 44876
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44816: LD_ADDR_VAR 0 7
44820: PUSH
44821: LD_EXP 114
44825: PUSH
44826: LD_VAR 0 2
44830: ARRAY
44831: PPUSH
44832: LD_INT 3
44834: PUSH
44835: LD_INT 30
44837: PUSH
44838: LD_INT 32
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 30
44847: PUSH
44848: LD_INT 33
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 30
44857: PUSH
44858: LD_INT 31
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: PPUSH
44871: CALL_OW 72
44875: ST_TO_ADDR
// if not to_repair_tmp then
44876: LD_VAR 0 7
44880: NOT
44881: IFFALSE 44885
// continue ;
44883: GO 44683
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44885: LD_ADDR_VAR 0 8
44889: PUSH
44890: LD_VAR 0 7
44894: PPUSH
44895: LD_VAR 0 3
44899: PPUSH
44900: CALL_OW 74
44904: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
44905: LD_VAR 0 8
44909: PPUSH
44910: LD_INT 16
44912: PPUSH
44913: CALL 72743 0 2
44917: PUSH
44918: LD_INT 4
44920: ARRAY
44921: PUSH
44922: LD_INT 10
44924: LESS
44925: IFFALSE 44941
// ComRepairBuilding ( j , to_repair ) ;
44927: LD_VAR 0 3
44931: PPUSH
44932: LD_VAR 0 8
44936: PPUSH
44937: CALL_OW 130
// end ;
44941: GO 44683
44943: POP
44944: POP
// end ;
44945: GO 44103
44947: POP
44948: POP
// end ;
44949: LD_VAR 0 1
44953: RET
// export function MC_Heal ; var i , j , tmp ; begin
44954: LD_INT 0
44956: PPUSH
44957: PPUSH
44958: PPUSH
44959: PPUSH
// if not mc_bases then
44960: LD_EXP 113
44964: NOT
44965: IFFALSE 44969
// exit ;
44967: GO 45371
// for i = 1 to mc_bases do
44969: LD_ADDR_VAR 0 2
44973: PUSH
44974: DOUBLE
44975: LD_INT 1
44977: DEC
44978: ST_TO_ADDR
44979: LD_EXP 113
44983: PUSH
44984: FOR_TO
44985: IFFALSE 45369
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44987: LD_EXP 116
44991: PUSH
44992: LD_VAR 0 2
44996: ARRAY
44997: PUSH
44998: LD_INT 1
45000: ARRAY
45001: NOT
45002: PUSH
45003: LD_EXP 116
45007: PUSH
45008: LD_VAR 0 2
45012: ARRAY
45013: PUSH
45014: LD_INT 2
45016: ARRAY
45017: NOT
45018: AND
45019: IFFALSE 45057
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45021: LD_ADDR_EXP 117
45025: PUSH
45026: LD_EXP 117
45030: PPUSH
45031: LD_VAR 0 2
45035: PPUSH
45036: EMPTY
45037: PPUSH
45038: CALL_OW 1
45042: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45043: LD_VAR 0 2
45047: PPUSH
45048: LD_INT 102
45050: PPUSH
45051: CALL 39192 0 2
// continue ;
45055: GO 44984
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45057: LD_ADDR_VAR 0 4
45061: PUSH
45062: LD_EXP 113
45066: PUSH
45067: LD_VAR 0 2
45071: ARRAY
45072: PPUSH
45073: LD_INT 25
45075: PUSH
45076: LD_INT 4
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PPUSH
45083: CALL_OW 72
45087: ST_TO_ADDR
// if not tmp then
45088: LD_VAR 0 4
45092: NOT
45093: IFFALSE 45097
// continue ;
45095: GO 44984
// if mc_taming [ i ] then
45097: LD_EXP 144
45101: PUSH
45102: LD_VAR 0 2
45106: ARRAY
45107: IFFALSE 45131
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45109: LD_ADDR_EXP 144
45113: PUSH
45114: LD_EXP 144
45118: PPUSH
45119: LD_VAR 0 2
45123: PPUSH
45124: EMPTY
45125: PPUSH
45126: CALL_OW 1
45130: ST_TO_ADDR
// for j in tmp do
45131: LD_ADDR_VAR 0 3
45135: PUSH
45136: LD_VAR 0 4
45140: PUSH
45141: FOR_IN
45142: IFFALSE 45365
// begin if IsInUnit ( j ) then
45144: LD_VAR 0 3
45148: PPUSH
45149: CALL_OW 310
45153: IFFALSE 45164
// ComExitBuilding ( j ) ;
45155: LD_VAR 0 3
45159: PPUSH
45160: CALL_OW 122
// if not j in mc_healers [ i ] then
45164: LD_VAR 0 3
45168: PUSH
45169: LD_EXP 117
45173: PUSH
45174: LD_VAR 0 2
45178: ARRAY
45179: IN
45180: NOT
45181: IFFALSE 45227
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45183: LD_ADDR_EXP 117
45187: PUSH
45188: LD_EXP 117
45192: PPUSH
45193: LD_VAR 0 2
45197: PUSH
45198: LD_EXP 117
45202: PUSH
45203: LD_VAR 0 2
45207: ARRAY
45208: PUSH
45209: LD_INT 1
45211: PLUS
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PPUSH
45217: LD_VAR 0 3
45221: PPUSH
45222: CALL 70150 0 3
45226: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45227: LD_VAR 0 3
45231: PPUSH
45232: CALL_OW 110
45236: PUSH
45237: LD_INT 102
45239: NONEQUAL
45240: IFFALSE 45254
// SetTag ( j , 102 ) ;
45242: LD_VAR 0 3
45246: PPUSH
45247: LD_INT 102
45249: PPUSH
45250: CALL_OW 109
// Wait ( 3 ) ;
45254: LD_INT 3
45256: PPUSH
45257: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45261: LD_EXP 116
45265: PUSH
45266: LD_VAR 0 2
45270: ARRAY
45271: PUSH
45272: LD_INT 1
45274: ARRAY
45275: IFFALSE 45307
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45277: LD_VAR 0 3
45281: PPUSH
45282: LD_EXP 116
45286: PUSH
45287: LD_VAR 0 2
45291: ARRAY
45292: PUSH
45293: LD_INT 1
45295: ARRAY
45296: PUSH
45297: LD_INT 1
45299: ARRAY
45300: PPUSH
45301: CALL_OW 128
45305: GO 45363
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45307: LD_VAR 0 3
45311: PPUSH
45312: CALL_OW 314
45316: NOT
45317: PUSH
45318: LD_EXP 116
45322: PUSH
45323: LD_VAR 0 2
45327: ARRAY
45328: PUSH
45329: LD_INT 2
45331: ARRAY
45332: AND
45333: IFFALSE 45363
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45335: LD_VAR 0 3
45339: PPUSH
45340: LD_EXP 116
45344: PUSH
45345: LD_VAR 0 2
45349: ARRAY
45350: PUSH
45351: LD_INT 2
45353: ARRAY
45354: PUSH
45355: LD_INT 1
45357: ARRAY
45358: PPUSH
45359: CALL_OW 128
// end ;
45363: GO 45141
45365: POP
45366: POP
// end ;
45367: GO 44984
45369: POP
45370: POP
// end ;
45371: LD_VAR 0 1
45375: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45376: LD_INT 0
45378: PPUSH
45379: PPUSH
45380: PPUSH
45381: PPUSH
45382: PPUSH
// if not mc_bases then
45383: LD_EXP 113
45387: NOT
45388: IFFALSE 45392
// exit ;
45390: GO 46535
// for i = 1 to mc_bases do
45392: LD_ADDR_VAR 0 2
45396: PUSH
45397: DOUBLE
45398: LD_INT 1
45400: DEC
45401: ST_TO_ADDR
45402: LD_EXP 113
45406: PUSH
45407: FOR_TO
45408: IFFALSE 46533
// begin if mc_scan [ i ] then
45410: LD_EXP 136
45414: PUSH
45415: LD_VAR 0 2
45419: ARRAY
45420: IFFALSE 45424
// continue ;
45422: GO 45407
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45424: LD_EXP 118
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: NOT
45435: PUSH
45436: LD_EXP 120
45440: PUSH
45441: LD_VAR 0 2
45445: ARRAY
45446: NOT
45447: AND
45448: PUSH
45449: LD_EXP 119
45453: PUSH
45454: LD_VAR 0 2
45458: ARRAY
45459: AND
45460: IFFALSE 45498
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45462: LD_ADDR_EXP 119
45466: PUSH
45467: LD_EXP 119
45471: PPUSH
45472: LD_VAR 0 2
45476: PPUSH
45477: EMPTY
45478: PPUSH
45479: CALL_OW 1
45483: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45484: LD_VAR 0 2
45488: PPUSH
45489: LD_INT 103
45491: PPUSH
45492: CALL 39192 0 2
// continue ;
45496: GO 45407
// end ; if mc_construct_list [ i ] then
45498: LD_EXP 120
45502: PUSH
45503: LD_VAR 0 2
45507: ARRAY
45508: IFFALSE 45728
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45510: LD_ADDR_VAR 0 4
45514: PUSH
45515: LD_EXP 113
45519: PUSH
45520: LD_VAR 0 2
45524: ARRAY
45525: PPUSH
45526: LD_INT 25
45528: PUSH
45529: LD_INT 2
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PPUSH
45536: CALL_OW 72
45540: PUSH
45541: LD_EXP 115
45545: PUSH
45546: LD_VAR 0 2
45550: ARRAY
45551: DIFF
45552: ST_TO_ADDR
// if not tmp then
45553: LD_VAR 0 4
45557: NOT
45558: IFFALSE 45562
// continue ;
45560: GO 45407
// for j in tmp do
45562: LD_ADDR_VAR 0 3
45566: PUSH
45567: LD_VAR 0 4
45571: PUSH
45572: FOR_IN
45573: IFFALSE 45724
// begin if not mc_builders [ i ] then
45575: LD_EXP 119
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: NOT
45586: IFFALSE 45644
// begin SetTag ( j , 103 ) ;
45588: LD_VAR 0 3
45592: PPUSH
45593: LD_INT 103
45595: PPUSH
45596: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45600: LD_ADDR_EXP 119
45604: PUSH
45605: LD_EXP 119
45609: PPUSH
45610: LD_VAR 0 2
45614: PUSH
45615: LD_EXP 119
45619: PUSH
45620: LD_VAR 0 2
45624: ARRAY
45625: PUSH
45626: LD_INT 1
45628: PLUS
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PPUSH
45634: LD_VAR 0 3
45638: PPUSH
45639: CALL 70150 0 3
45643: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45644: LD_VAR 0 3
45648: PPUSH
45649: CALL_OW 310
45653: IFFALSE 45664
// ComExitBuilding ( j ) ;
45655: LD_VAR 0 3
45659: PPUSH
45660: CALL_OW 122
// wait ( 3 ) ;
45664: LD_INT 3
45666: PPUSH
45667: CALL_OW 67
// if not mc_construct_list [ i ] then
45671: LD_EXP 120
45675: PUSH
45676: LD_VAR 0 2
45680: ARRAY
45681: NOT
45682: IFFALSE 45686
// break ;
45684: GO 45724
// if not HasTask ( j ) then
45686: LD_VAR 0 3
45690: PPUSH
45691: CALL_OW 314
45695: NOT
45696: IFFALSE 45722
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45698: LD_VAR 0 3
45702: PPUSH
45703: LD_EXP 120
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: PUSH
45714: LD_INT 1
45716: ARRAY
45717: PPUSH
45718: CALL 73001 0 2
// end ;
45722: GO 45572
45724: POP
45725: POP
// end else
45726: GO 46531
// if mc_build_list [ i ] then
45728: LD_EXP 118
45732: PUSH
45733: LD_VAR 0 2
45737: ARRAY
45738: IFFALSE 46531
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45740: LD_ADDR_VAR 0 5
45744: PUSH
45745: LD_EXP 113
45749: PUSH
45750: LD_VAR 0 2
45754: ARRAY
45755: PPUSH
45756: LD_INT 2
45758: PUSH
45759: LD_INT 30
45761: PUSH
45762: LD_INT 0
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 30
45771: PUSH
45772: LD_INT 1
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: LIST
45783: PPUSH
45784: CALL_OW 72
45788: ST_TO_ADDR
// if depot then
45789: LD_VAR 0 5
45793: IFFALSE 45811
// depot := depot [ 1 ] else
45795: LD_ADDR_VAR 0 5
45799: PUSH
45800: LD_VAR 0 5
45804: PUSH
45805: LD_INT 1
45807: ARRAY
45808: ST_TO_ADDR
45809: GO 45819
// depot := 0 ;
45811: LD_ADDR_VAR 0 5
45815: PUSH
45816: LD_INT 0
45818: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45819: LD_EXP 118
45823: PUSH
45824: LD_VAR 0 2
45828: ARRAY
45829: PUSH
45830: LD_INT 1
45832: ARRAY
45833: PUSH
45834: LD_INT 1
45836: ARRAY
45837: PPUSH
45838: CALL 72831 0 1
45842: PUSH
45843: LD_EXP 113
45847: PUSH
45848: LD_VAR 0 2
45852: ARRAY
45853: PPUSH
45854: LD_INT 2
45856: PUSH
45857: LD_INT 30
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 30
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: LIST
45881: PPUSH
45882: CALL_OW 72
45886: NOT
45887: AND
45888: IFFALSE 45993
// begin for j = 1 to mc_build_list [ i ] do
45890: LD_ADDR_VAR 0 3
45894: PUSH
45895: DOUBLE
45896: LD_INT 1
45898: DEC
45899: ST_TO_ADDR
45900: LD_EXP 118
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: FOR_TO
45912: IFFALSE 45991
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45914: LD_EXP 118
45918: PUSH
45919: LD_VAR 0 2
45923: ARRAY
45924: PUSH
45925: LD_VAR 0 3
45929: ARRAY
45930: PUSH
45931: LD_INT 1
45933: ARRAY
45934: PUSH
45935: LD_INT 2
45937: EQUAL
45938: IFFALSE 45989
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45940: LD_ADDR_EXP 118
45944: PUSH
45945: LD_EXP 118
45949: PPUSH
45950: LD_VAR 0 2
45954: PPUSH
45955: LD_EXP 118
45959: PUSH
45960: LD_VAR 0 2
45964: ARRAY
45965: PPUSH
45966: LD_VAR 0 3
45970: PPUSH
45971: LD_INT 1
45973: PPUSH
45974: LD_INT 0
45976: PPUSH
45977: CALL 69568 0 4
45981: PPUSH
45982: CALL_OW 1
45986: ST_TO_ADDR
// break ;
45987: GO 45991
// end ;
45989: GO 45911
45991: POP
45992: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45993: LD_EXP 118
45997: PUSH
45998: LD_VAR 0 2
46002: ARRAY
46003: PUSH
46004: LD_INT 1
46006: ARRAY
46007: PUSH
46008: LD_INT 1
46010: ARRAY
46011: PUSH
46012: LD_INT 0
46014: EQUAL
46015: PUSH
46016: LD_VAR 0 5
46020: PUSH
46021: LD_VAR 0 5
46025: PPUSH
46026: LD_EXP 118
46030: PUSH
46031: LD_VAR 0 2
46035: ARRAY
46036: PUSH
46037: LD_INT 1
46039: ARRAY
46040: PUSH
46041: LD_INT 1
46043: ARRAY
46044: PPUSH
46045: LD_EXP 118
46049: PUSH
46050: LD_VAR 0 2
46054: ARRAY
46055: PUSH
46056: LD_INT 1
46058: ARRAY
46059: PUSH
46060: LD_INT 2
46062: ARRAY
46063: PPUSH
46064: LD_EXP 118
46068: PUSH
46069: LD_VAR 0 2
46073: ARRAY
46074: PUSH
46075: LD_INT 1
46077: ARRAY
46078: PUSH
46079: LD_INT 3
46081: ARRAY
46082: PPUSH
46083: LD_EXP 118
46087: PUSH
46088: LD_VAR 0 2
46092: ARRAY
46093: PUSH
46094: LD_INT 1
46096: ARRAY
46097: PUSH
46098: LD_INT 4
46100: ARRAY
46101: PPUSH
46102: CALL 77565 0 5
46106: AND
46107: OR
46108: IFFALSE 46389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46110: LD_ADDR_VAR 0 4
46114: PUSH
46115: LD_EXP 113
46119: PUSH
46120: LD_VAR 0 2
46124: ARRAY
46125: PPUSH
46126: LD_INT 25
46128: PUSH
46129: LD_INT 2
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PPUSH
46136: CALL_OW 72
46140: PUSH
46141: LD_EXP 115
46145: PUSH
46146: LD_VAR 0 2
46150: ARRAY
46151: DIFF
46152: ST_TO_ADDR
// if not tmp then
46153: LD_VAR 0 4
46157: NOT
46158: IFFALSE 46162
// continue ;
46160: GO 45407
// for j in tmp do
46162: LD_ADDR_VAR 0 3
46166: PUSH
46167: LD_VAR 0 4
46171: PUSH
46172: FOR_IN
46173: IFFALSE 46385
// begin if not mc_builders [ i ] then
46175: LD_EXP 119
46179: PUSH
46180: LD_VAR 0 2
46184: ARRAY
46185: NOT
46186: IFFALSE 46244
// begin SetTag ( j , 103 ) ;
46188: LD_VAR 0 3
46192: PPUSH
46193: LD_INT 103
46195: PPUSH
46196: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46200: LD_ADDR_EXP 119
46204: PUSH
46205: LD_EXP 119
46209: PPUSH
46210: LD_VAR 0 2
46214: PUSH
46215: LD_EXP 119
46219: PUSH
46220: LD_VAR 0 2
46224: ARRAY
46225: PUSH
46226: LD_INT 1
46228: PLUS
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PPUSH
46234: LD_VAR 0 3
46238: PPUSH
46239: CALL 70150 0 3
46243: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46244: LD_VAR 0 3
46248: PPUSH
46249: CALL_OW 310
46253: IFFALSE 46264
// ComExitBuilding ( j ) ;
46255: LD_VAR 0 3
46259: PPUSH
46260: CALL_OW 122
// wait ( 3 ) ;
46264: LD_INT 3
46266: PPUSH
46267: CALL_OW 67
// if not mc_build_list [ i ] then
46271: LD_EXP 118
46275: PUSH
46276: LD_VAR 0 2
46280: ARRAY
46281: NOT
46282: IFFALSE 46286
// break ;
46284: GO 46385
// if not HasTask ( j ) then
46286: LD_VAR 0 3
46290: PPUSH
46291: CALL_OW 314
46295: NOT
46296: IFFALSE 46383
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46298: LD_VAR 0 3
46302: PPUSH
46303: LD_EXP 118
46307: PUSH
46308: LD_VAR 0 2
46312: ARRAY
46313: PUSH
46314: LD_INT 1
46316: ARRAY
46317: PUSH
46318: LD_INT 1
46320: ARRAY
46321: PPUSH
46322: LD_EXP 118
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_INT 1
46335: ARRAY
46336: PUSH
46337: LD_INT 2
46339: ARRAY
46340: PPUSH
46341: LD_EXP 118
46345: PUSH
46346: LD_VAR 0 2
46350: ARRAY
46351: PUSH
46352: LD_INT 1
46354: ARRAY
46355: PUSH
46356: LD_INT 3
46358: ARRAY
46359: PPUSH
46360: LD_EXP 118
46364: PUSH
46365: LD_VAR 0 2
46369: ARRAY
46370: PUSH
46371: LD_INT 1
46373: ARRAY
46374: PUSH
46375: LD_INT 4
46377: ARRAY
46378: PPUSH
46379: CALL_OW 145
// end ;
46383: GO 46172
46385: POP
46386: POP
// end else
46387: GO 46531
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46389: LD_EXP 113
46393: PUSH
46394: LD_VAR 0 2
46398: ARRAY
46399: PPUSH
46400: LD_EXP 118
46404: PUSH
46405: LD_VAR 0 2
46409: ARRAY
46410: PUSH
46411: LD_INT 1
46413: ARRAY
46414: PUSH
46415: LD_INT 1
46417: ARRAY
46418: PPUSH
46419: LD_EXP 118
46423: PUSH
46424: LD_VAR 0 2
46428: ARRAY
46429: PUSH
46430: LD_INT 1
46432: ARRAY
46433: PUSH
46434: LD_INT 2
46436: ARRAY
46437: PPUSH
46438: LD_EXP 118
46442: PUSH
46443: LD_VAR 0 2
46447: ARRAY
46448: PUSH
46449: LD_INT 1
46451: ARRAY
46452: PUSH
46453: LD_INT 3
46455: ARRAY
46456: PPUSH
46457: LD_EXP 118
46461: PUSH
46462: LD_VAR 0 2
46466: ARRAY
46467: PUSH
46468: LD_INT 1
46470: ARRAY
46471: PUSH
46472: LD_INT 4
46474: ARRAY
46475: PPUSH
46476: CALL 76901 0 5
46480: NOT
46481: IFFALSE 46531
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46483: LD_ADDR_EXP 118
46487: PUSH
46488: LD_EXP 118
46492: PPUSH
46493: LD_VAR 0 2
46497: PPUSH
46498: LD_EXP 118
46502: PUSH
46503: LD_VAR 0 2
46507: ARRAY
46508: PPUSH
46509: LD_INT 1
46511: PPUSH
46512: LD_INT 1
46514: NEG
46515: PPUSH
46516: LD_INT 0
46518: PPUSH
46519: CALL 69568 0 4
46523: PPUSH
46524: CALL_OW 1
46528: ST_TO_ADDR
// continue ;
46529: GO 45407
// end ; end ; end ;
46531: GO 45407
46533: POP
46534: POP
// end ;
46535: LD_VAR 0 1
46539: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46540: LD_INT 0
46542: PPUSH
46543: PPUSH
46544: PPUSH
46545: PPUSH
46546: PPUSH
46547: PPUSH
// if not mc_bases then
46548: LD_EXP 113
46552: NOT
46553: IFFALSE 46557
// exit ;
46555: GO 46984
// for i = 1 to mc_bases do
46557: LD_ADDR_VAR 0 2
46561: PUSH
46562: DOUBLE
46563: LD_INT 1
46565: DEC
46566: ST_TO_ADDR
46567: LD_EXP 113
46571: PUSH
46572: FOR_TO
46573: IFFALSE 46982
// begin tmp := mc_build_upgrade [ i ] ;
46575: LD_ADDR_VAR 0 4
46579: PUSH
46580: LD_EXP 145
46584: PUSH
46585: LD_VAR 0 2
46589: ARRAY
46590: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46591: LD_ADDR_VAR 0 6
46595: PUSH
46596: LD_EXP 146
46600: PUSH
46601: LD_VAR 0 2
46605: ARRAY
46606: PPUSH
46607: LD_INT 2
46609: PUSH
46610: LD_INT 30
46612: PUSH
46613: LD_INT 6
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 30
46622: PUSH
46623: LD_INT 7
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: EMPTY
46631: LIST
46632: LIST
46633: LIST
46634: PPUSH
46635: CALL_OW 72
46639: ST_TO_ADDR
// if not tmp and not lab then
46640: LD_VAR 0 4
46644: NOT
46645: PUSH
46646: LD_VAR 0 6
46650: NOT
46651: AND
46652: IFFALSE 46656
// continue ;
46654: GO 46572
// if tmp then
46656: LD_VAR 0 4
46660: IFFALSE 46780
// for j in tmp do
46662: LD_ADDR_VAR 0 3
46666: PUSH
46667: LD_VAR 0 4
46671: PUSH
46672: FOR_IN
46673: IFFALSE 46778
// begin if UpgradeCost ( j ) then
46675: LD_VAR 0 3
46679: PPUSH
46680: CALL 76561 0 1
46684: IFFALSE 46776
// begin ComUpgrade ( j ) ;
46686: LD_VAR 0 3
46690: PPUSH
46691: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46695: LD_ADDR_EXP 145
46699: PUSH
46700: LD_EXP 145
46704: PPUSH
46705: LD_VAR 0 2
46709: PPUSH
46710: LD_EXP 145
46714: PUSH
46715: LD_VAR 0 2
46719: ARRAY
46720: PUSH
46721: LD_VAR 0 3
46725: DIFF
46726: PPUSH
46727: CALL_OW 1
46731: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46732: LD_ADDR_EXP 120
46736: PUSH
46737: LD_EXP 120
46741: PPUSH
46742: LD_VAR 0 2
46746: PUSH
46747: LD_EXP 120
46751: PUSH
46752: LD_VAR 0 2
46756: ARRAY
46757: PUSH
46758: LD_INT 1
46760: PLUS
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PPUSH
46766: LD_VAR 0 3
46770: PPUSH
46771: CALL 70150 0 3
46775: ST_TO_ADDR
// end ; end ;
46776: GO 46672
46778: POP
46779: POP
// if not lab or not mc_lab_upgrade [ i ] then
46780: LD_VAR 0 6
46784: NOT
46785: PUSH
46786: LD_EXP 147
46790: PUSH
46791: LD_VAR 0 2
46795: ARRAY
46796: NOT
46797: OR
46798: IFFALSE 46802
// continue ;
46800: GO 46572
// for j in lab do
46802: LD_ADDR_VAR 0 3
46806: PUSH
46807: LD_VAR 0 6
46811: PUSH
46812: FOR_IN
46813: IFFALSE 46978
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46815: LD_VAR 0 3
46819: PPUSH
46820: CALL_OW 266
46824: PUSH
46825: LD_INT 6
46827: PUSH
46828: LD_INT 7
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: IN
46835: PUSH
46836: LD_VAR 0 3
46840: PPUSH
46841: CALL_OW 461
46845: PUSH
46846: LD_INT 1
46848: NONEQUAL
46849: AND
46850: IFFALSE 46976
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46852: LD_VAR 0 3
46856: PPUSH
46857: LD_EXP 147
46861: PUSH
46862: LD_VAR 0 2
46866: ARRAY
46867: PUSH
46868: LD_INT 1
46870: ARRAY
46871: PPUSH
46872: CALL 76766 0 2
46876: IFFALSE 46976
// begin ComCancel ( j ) ;
46878: LD_VAR 0 3
46882: PPUSH
46883: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46887: LD_VAR 0 3
46891: PPUSH
46892: LD_EXP 147
46896: PUSH
46897: LD_VAR 0 2
46901: ARRAY
46902: PUSH
46903: LD_INT 1
46905: ARRAY
46906: PPUSH
46907: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46911: LD_VAR 0 3
46915: PUSH
46916: LD_EXP 120
46920: PUSH
46921: LD_VAR 0 2
46925: ARRAY
46926: IN
46927: NOT
46928: IFFALSE 46974
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46930: LD_ADDR_EXP 120
46934: PUSH
46935: LD_EXP 120
46939: PPUSH
46940: LD_VAR 0 2
46944: PUSH
46945: LD_EXP 120
46949: PUSH
46950: LD_VAR 0 2
46954: ARRAY
46955: PUSH
46956: LD_INT 1
46958: PLUS
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PPUSH
46964: LD_VAR 0 3
46968: PPUSH
46969: CALL 70150 0 3
46973: ST_TO_ADDR
// break ;
46974: GO 46978
// end ; end ; end ;
46976: GO 46812
46978: POP
46979: POP
// end ;
46980: GO 46572
46982: POP
46983: POP
// end ;
46984: LD_VAR 0 1
46988: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46989: LD_INT 0
46991: PPUSH
46992: PPUSH
46993: PPUSH
46994: PPUSH
46995: PPUSH
46996: PPUSH
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases then
47000: LD_EXP 113
47004: NOT
47005: IFFALSE 47009
// exit ;
47007: GO 47414
// for i = 1 to mc_bases do
47009: LD_ADDR_VAR 0 2
47013: PUSH
47014: DOUBLE
47015: LD_INT 1
47017: DEC
47018: ST_TO_ADDR
47019: LD_EXP 113
47023: PUSH
47024: FOR_TO
47025: IFFALSE 47412
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47027: LD_EXP 121
47031: PUSH
47032: LD_VAR 0 2
47036: ARRAY
47037: NOT
47038: PUSH
47039: LD_EXP 113
47043: PUSH
47044: LD_VAR 0 2
47048: ARRAY
47049: PPUSH
47050: LD_INT 30
47052: PUSH
47053: LD_INT 3
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PPUSH
47060: CALL_OW 72
47064: NOT
47065: OR
47066: IFFALSE 47070
// continue ;
47068: GO 47024
// busy := false ;
47070: LD_ADDR_VAR 0 8
47074: PUSH
47075: LD_INT 0
47077: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47078: LD_ADDR_VAR 0 4
47082: PUSH
47083: LD_EXP 113
47087: PUSH
47088: LD_VAR 0 2
47092: ARRAY
47093: PPUSH
47094: LD_INT 30
47096: PUSH
47097: LD_INT 3
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: PPUSH
47104: CALL_OW 72
47108: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47109: LD_ADDR_VAR 0 6
47113: PUSH
47114: LD_EXP 121
47118: PUSH
47119: LD_VAR 0 2
47123: ARRAY
47124: PPUSH
47125: LD_INT 2
47127: PUSH
47128: LD_INT 30
47130: PUSH
47131: LD_INT 32
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 30
47140: PUSH
47141: LD_INT 33
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: LIST
47152: PPUSH
47153: CALL_OW 72
47157: ST_TO_ADDR
// if not t then
47158: LD_VAR 0 6
47162: NOT
47163: IFFALSE 47167
// continue ;
47165: GO 47024
// for j in tmp do
47167: LD_ADDR_VAR 0 3
47171: PUSH
47172: LD_VAR 0 4
47176: PUSH
47177: FOR_IN
47178: IFFALSE 47208
// if not BuildingStatus ( j ) = bs_idle then
47180: LD_VAR 0 3
47184: PPUSH
47185: CALL_OW 461
47189: PUSH
47190: LD_INT 2
47192: EQUAL
47193: NOT
47194: IFFALSE 47206
// begin busy := true ;
47196: LD_ADDR_VAR 0 8
47200: PUSH
47201: LD_INT 1
47203: ST_TO_ADDR
// break ;
47204: GO 47208
// end ;
47206: GO 47177
47208: POP
47209: POP
// if busy then
47210: LD_VAR 0 8
47214: IFFALSE 47218
// continue ;
47216: GO 47024
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47218: LD_ADDR_VAR 0 7
47222: PUSH
47223: LD_VAR 0 6
47227: PPUSH
47228: LD_INT 35
47230: PUSH
47231: LD_INT 0
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PPUSH
47238: CALL_OW 72
47242: ST_TO_ADDR
// if tw then
47243: LD_VAR 0 7
47247: IFFALSE 47324
// begin tw := tw [ 1 ] ;
47249: LD_ADDR_VAR 0 7
47253: PUSH
47254: LD_VAR 0 7
47258: PUSH
47259: LD_INT 1
47261: ARRAY
47262: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47263: LD_ADDR_VAR 0 9
47267: PUSH
47268: LD_VAR 0 7
47272: PPUSH
47273: LD_EXP 138
47277: PUSH
47278: LD_VAR 0 2
47282: ARRAY
47283: PPUSH
47284: CALL 75120 0 2
47288: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47289: LD_EXP 152
47293: PUSH
47294: LD_VAR 0 2
47298: ARRAY
47299: IFFALSE 47322
// if not weapon in mc_allowed_tower_weapons [ i ] then
47301: LD_VAR 0 9
47305: PUSH
47306: LD_EXP 152
47310: PUSH
47311: LD_VAR 0 2
47315: ARRAY
47316: IN
47317: NOT
47318: IFFALSE 47322
// continue ;
47320: GO 47024
// end else
47322: GO 47387
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47324: LD_ADDR_VAR 0 5
47328: PUSH
47329: LD_EXP 121
47333: PUSH
47334: LD_VAR 0 2
47338: ARRAY
47339: PPUSH
47340: LD_VAR 0 4
47344: PPUSH
47345: CALL 100741 0 2
47349: ST_TO_ADDR
// if not tmp2 then
47350: LD_VAR 0 5
47354: NOT
47355: IFFALSE 47359
// continue ;
47357: GO 47024
// tw := tmp2 [ 1 ] ;
47359: LD_ADDR_VAR 0 7
47363: PUSH
47364: LD_VAR 0 5
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47373: LD_ADDR_VAR 0 9
47377: PUSH
47378: LD_VAR 0 5
47382: PUSH
47383: LD_INT 2
47385: ARRAY
47386: ST_TO_ADDR
// end ; if not weapon then
47387: LD_VAR 0 9
47391: NOT
47392: IFFALSE 47396
// continue ;
47394: GO 47024
// ComPlaceWeapon ( tw , weapon ) ;
47396: LD_VAR 0 7
47400: PPUSH
47401: LD_VAR 0 9
47405: PPUSH
47406: CALL_OW 148
// end ;
47410: GO 47024
47412: POP
47413: POP
// end ;
47414: LD_VAR 0 1
47418: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47419: LD_INT 0
47421: PPUSH
47422: PPUSH
47423: PPUSH
47424: PPUSH
47425: PPUSH
47426: PPUSH
// if not mc_bases then
47427: LD_EXP 113
47431: NOT
47432: IFFALSE 47436
// exit ;
47434: GO 48212
// for i = 1 to mc_bases do
47436: LD_ADDR_VAR 0 2
47440: PUSH
47441: DOUBLE
47442: LD_INT 1
47444: DEC
47445: ST_TO_ADDR
47446: LD_EXP 113
47450: PUSH
47451: FOR_TO
47452: IFFALSE 48210
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47454: LD_EXP 126
47458: PUSH
47459: LD_VAR 0 2
47463: ARRAY
47464: NOT
47465: PUSH
47466: LD_EXP 126
47470: PUSH
47471: LD_VAR 0 2
47475: ARRAY
47476: PUSH
47477: LD_EXP 127
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: EQUAL
47488: OR
47489: PUSH
47490: LD_EXP 136
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: OR
47501: IFFALSE 47505
// continue ;
47503: GO 47451
// if mc_miners [ i ] then
47505: LD_EXP 127
47509: PUSH
47510: LD_VAR 0 2
47514: ARRAY
47515: IFFALSE 47897
// begin for j = mc_miners [ i ] downto 1 do
47517: LD_ADDR_VAR 0 3
47521: PUSH
47522: DOUBLE
47523: LD_EXP 127
47527: PUSH
47528: LD_VAR 0 2
47532: ARRAY
47533: INC
47534: ST_TO_ADDR
47535: LD_INT 1
47537: PUSH
47538: FOR_DOWNTO
47539: IFFALSE 47895
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47541: LD_EXP 127
47545: PUSH
47546: LD_VAR 0 2
47550: ARRAY
47551: PUSH
47552: LD_VAR 0 3
47556: ARRAY
47557: PPUSH
47558: CALL_OW 301
47562: PUSH
47563: LD_EXP 127
47567: PUSH
47568: LD_VAR 0 2
47572: ARRAY
47573: PUSH
47574: LD_VAR 0 3
47578: ARRAY
47579: PPUSH
47580: CALL_OW 257
47584: PUSH
47585: LD_INT 1
47587: NONEQUAL
47588: OR
47589: IFFALSE 47652
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47591: LD_ADDR_VAR 0 5
47595: PUSH
47596: LD_EXP 127
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: PUSH
47607: LD_EXP 127
47611: PUSH
47612: LD_VAR 0 2
47616: ARRAY
47617: PUSH
47618: LD_VAR 0 3
47622: ARRAY
47623: DIFF
47624: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47625: LD_ADDR_EXP 127
47629: PUSH
47630: LD_EXP 127
47634: PPUSH
47635: LD_VAR 0 2
47639: PPUSH
47640: LD_VAR 0 5
47644: PPUSH
47645: CALL_OW 1
47649: ST_TO_ADDR
// continue ;
47650: GO 47538
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47652: LD_EXP 127
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: PPUSH
47669: CALL_OW 257
47673: PUSH
47674: LD_INT 1
47676: EQUAL
47677: PUSH
47678: LD_EXP 127
47682: PUSH
47683: LD_VAR 0 2
47687: ARRAY
47688: PUSH
47689: LD_VAR 0 3
47693: ARRAY
47694: PPUSH
47695: CALL_OW 459
47699: NOT
47700: AND
47701: PUSH
47702: LD_EXP 127
47706: PUSH
47707: LD_VAR 0 2
47711: ARRAY
47712: PUSH
47713: LD_VAR 0 3
47717: ARRAY
47718: PPUSH
47719: CALL_OW 314
47723: NOT
47724: AND
47725: IFFALSE 47893
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47727: LD_EXP 127
47731: PUSH
47732: LD_VAR 0 2
47736: ARRAY
47737: PUSH
47738: LD_VAR 0 3
47742: ARRAY
47743: PPUSH
47744: CALL_OW 310
47748: IFFALSE 47771
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47750: LD_EXP 127
47754: PUSH
47755: LD_VAR 0 2
47759: ARRAY
47760: PUSH
47761: LD_VAR 0 3
47765: ARRAY
47766: PPUSH
47767: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47771: LD_EXP 127
47775: PUSH
47776: LD_VAR 0 2
47780: ARRAY
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: PPUSH
47788: CALL_OW 314
47792: NOT
47793: IFFALSE 47893
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47795: LD_EXP 127
47799: PUSH
47800: LD_VAR 0 2
47804: ARRAY
47805: PUSH
47806: LD_VAR 0 3
47810: ARRAY
47811: PPUSH
47812: LD_EXP 126
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PUSH
47823: LD_VAR 0 3
47827: PUSH
47828: LD_EXP 126
47832: PUSH
47833: LD_VAR 0 2
47837: ARRAY
47838: MOD
47839: PUSH
47840: LD_INT 1
47842: PLUS
47843: ARRAY
47844: PUSH
47845: LD_INT 1
47847: ARRAY
47848: PPUSH
47849: LD_EXP 126
47853: PUSH
47854: LD_VAR 0 2
47858: ARRAY
47859: PUSH
47860: LD_VAR 0 3
47864: PUSH
47865: LD_EXP 126
47869: PUSH
47870: LD_VAR 0 2
47874: ARRAY
47875: MOD
47876: PUSH
47877: LD_INT 1
47879: PLUS
47880: ARRAY
47881: PUSH
47882: LD_INT 2
47884: ARRAY
47885: PPUSH
47886: LD_INT 0
47888: PPUSH
47889: CALL_OW 193
// end ; end ;
47893: GO 47538
47895: POP
47896: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47897: LD_ADDR_VAR 0 5
47901: PUSH
47902: LD_EXP 113
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: PPUSH
47913: LD_INT 2
47915: PUSH
47916: LD_INT 30
47918: PUSH
47919: LD_INT 4
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 30
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 30
47938: PUSH
47939: LD_INT 32
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: PPUSH
47952: CALL_OW 72
47956: ST_TO_ADDR
// if not tmp then
47957: LD_VAR 0 5
47961: NOT
47962: IFFALSE 47966
// continue ;
47964: GO 47451
// list := [ ] ;
47966: LD_ADDR_VAR 0 6
47970: PUSH
47971: EMPTY
47972: ST_TO_ADDR
// for j in tmp do
47973: LD_ADDR_VAR 0 3
47977: PUSH
47978: LD_VAR 0 5
47982: PUSH
47983: FOR_IN
47984: IFFALSE 48053
// begin for k in UnitsInside ( j ) do
47986: LD_ADDR_VAR 0 4
47990: PUSH
47991: LD_VAR 0 3
47995: PPUSH
47996: CALL_OW 313
48000: PUSH
48001: FOR_IN
48002: IFFALSE 48049
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48004: LD_VAR 0 4
48008: PPUSH
48009: CALL_OW 257
48013: PUSH
48014: LD_INT 1
48016: EQUAL
48017: PUSH
48018: LD_VAR 0 4
48022: PPUSH
48023: CALL_OW 459
48027: NOT
48028: AND
48029: IFFALSE 48047
// list := list ^ k ;
48031: LD_ADDR_VAR 0 6
48035: PUSH
48036: LD_VAR 0 6
48040: PUSH
48041: LD_VAR 0 4
48045: ADD
48046: ST_TO_ADDR
48047: GO 48001
48049: POP
48050: POP
// end ;
48051: GO 47983
48053: POP
48054: POP
// list := list diff mc_miners [ i ] ;
48055: LD_ADDR_VAR 0 6
48059: PUSH
48060: LD_VAR 0 6
48064: PUSH
48065: LD_EXP 127
48069: PUSH
48070: LD_VAR 0 2
48074: ARRAY
48075: DIFF
48076: ST_TO_ADDR
// if not list then
48077: LD_VAR 0 6
48081: NOT
48082: IFFALSE 48086
// continue ;
48084: GO 47451
// k := mc_mines [ i ] - mc_miners [ i ] ;
48086: LD_ADDR_VAR 0 4
48090: PUSH
48091: LD_EXP 126
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: PUSH
48102: LD_EXP 127
48106: PUSH
48107: LD_VAR 0 2
48111: ARRAY
48112: MINUS
48113: ST_TO_ADDR
// if k > list then
48114: LD_VAR 0 4
48118: PUSH
48119: LD_VAR 0 6
48123: GREATER
48124: IFFALSE 48136
// k := list ;
48126: LD_ADDR_VAR 0 4
48130: PUSH
48131: LD_VAR 0 6
48135: ST_TO_ADDR
// for j = 1 to k do
48136: LD_ADDR_VAR 0 3
48140: PUSH
48141: DOUBLE
48142: LD_INT 1
48144: DEC
48145: ST_TO_ADDR
48146: LD_VAR 0 4
48150: PUSH
48151: FOR_TO
48152: IFFALSE 48206
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48154: LD_ADDR_EXP 127
48158: PUSH
48159: LD_EXP 127
48163: PPUSH
48164: LD_VAR 0 2
48168: PUSH
48169: LD_EXP 127
48173: PUSH
48174: LD_VAR 0 2
48178: ARRAY
48179: PUSH
48180: LD_INT 1
48182: PLUS
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PPUSH
48188: LD_VAR 0 6
48192: PUSH
48193: LD_VAR 0 3
48197: ARRAY
48198: PPUSH
48199: CALL 70150 0 3
48203: ST_TO_ADDR
48204: GO 48151
48206: POP
48207: POP
// end ;
48208: GO 47451
48210: POP
48211: POP
// end ;
48212: LD_VAR 0 1
48216: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48217: LD_INT 0
48219: PPUSH
48220: PPUSH
48221: PPUSH
48222: PPUSH
48223: PPUSH
48224: PPUSH
48225: PPUSH
48226: PPUSH
48227: PPUSH
48228: PPUSH
// if not mc_bases then
48229: LD_EXP 113
48233: NOT
48234: IFFALSE 48238
// exit ;
48236: GO 49988
// for i = 1 to mc_bases do
48238: LD_ADDR_VAR 0 2
48242: PUSH
48243: DOUBLE
48244: LD_INT 1
48246: DEC
48247: ST_TO_ADDR
48248: LD_EXP 113
48252: PUSH
48253: FOR_TO
48254: IFFALSE 49986
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48256: LD_EXP 113
48260: PUSH
48261: LD_VAR 0 2
48265: ARRAY
48266: NOT
48267: PUSH
48268: LD_EXP 120
48272: PUSH
48273: LD_VAR 0 2
48277: ARRAY
48278: OR
48279: IFFALSE 48283
// continue ;
48281: GO 48253
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48283: LD_EXP 129
48287: PUSH
48288: LD_VAR 0 2
48292: ARRAY
48293: NOT
48294: PUSH
48295: LD_EXP 130
48299: PUSH
48300: LD_VAR 0 2
48304: ARRAY
48305: AND
48306: IFFALSE 48344
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48308: LD_ADDR_EXP 130
48312: PUSH
48313: LD_EXP 130
48317: PPUSH
48318: LD_VAR 0 2
48322: PPUSH
48323: EMPTY
48324: PPUSH
48325: CALL_OW 1
48329: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48330: LD_VAR 0 2
48334: PPUSH
48335: LD_INT 107
48337: PPUSH
48338: CALL 39192 0 2
// continue ;
48342: GO 48253
// end ; target := [ ] ;
48344: LD_ADDR_VAR 0 6
48348: PUSH
48349: EMPTY
48350: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48351: LD_ADDR_VAR 0 3
48355: PUSH
48356: DOUBLE
48357: LD_EXP 129
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: INC
48368: ST_TO_ADDR
48369: LD_INT 1
48371: PUSH
48372: FOR_DOWNTO
48373: IFFALSE 48633
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48375: LD_EXP 129
48379: PUSH
48380: LD_VAR 0 2
48384: ARRAY
48385: PUSH
48386: LD_VAR 0 3
48390: ARRAY
48391: PUSH
48392: LD_INT 2
48394: ARRAY
48395: PPUSH
48396: LD_EXP 129
48400: PUSH
48401: LD_VAR 0 2
48405: ARRAY
48406: PUSH
48407: LD_VAR 0 3
48411: ARRAY
48412: PUSH
48413: LD_INT 3
48415: ARRAY
48416: PPUSH
48417: CALL_OW 488
48421: PUSH
48422: LD_EXP 129
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PUSH
48433: LD_VAR 0 3
48437: ARRAY
48438: PUSH
48439: LD_INT 2
48441: ARRAY
48442: PPUSH
48443: LD_EXP 129
48447: PUSH
48448: LD_VAR 0 2
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 3
48458: ARRAY
48459: PUSH
48460: LD_INT 3
48462: ARRAY
48463: PPUSH
48464: CALL_OW 284
48468: PUSH
48469: LD_INT 0
48471: EQUAL
48472: AND
48473: IFFALSE 48528
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48475: LD_ADDR_VAR 0 5
48479: PUSH
48480: LD_EXP 129
48484: PUSH
48485: LD_VAR 0 2
48489: ARRAY
48490: PPUSH
48491: LD_VAR 0 3
48495: PPUSH
48496: CALL_OW 3
48500: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48501: LD_ADDR_EXP 129
48505: PUSH
48506: LD_EXP 129
48510: PPUSH
48511: LD_VAR 0 2
48515: PPUSH
48516: LD_VAR 0 5
48520: PPUSH
48521: CALL_OW 1
48525: ST_TO_ADDR
// continue ;
48526: GO 48372
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48528: LD_EXP 113
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PUSH
48539: LD_INT 1
48541: ARRAY
48542: PPUSH
48543: CALL_OW 255
48547: PPUSH
48548: LD_EXP 129
48552: PUSH
48553: LD_VAR 0 2
48557: ARRAY
48558: PUSH
48559: LD_VAR 0 3
48563: ARRAY
48564: PUSH
48565: LD_INT 2
48567: ARRAY
48568: PPUSH
48569: LD_EXP 129
48573: PUSH
48574: LD_VAR 0 2
48578: ARRAY
48579: PUSH
48580: LD_VAR 0 3
48584: ARRAY
48585: PUSH
48586: LD_INT 3
48588: ARRAY
48589: PPUSH
48590: LD_INT 30
48592: PPUSH
48593: CALL 71046 0 4
48597: PUSH
48598: LD_INT 4
48600: ARRAY
48601: PUSH
48602: LD_INT 0
48604: EQUAL
48605: IFFALSE 48631
// begin target := mc_crates [ i ] [ j ] ;
48607: LD_ADDR_VAR 0 6
48611: PUSH
48612: LD_EXP 129
48616: PUSH
48617: LD_VAR 0 2
48621: ARRAY
48622: PUSH
48623: LD_VAR 0 3
48627: ARRAY
48628: ST_TO_ADDR
// break ;
48629: GO 48633
// end ; end ;
48631: GO 48372
48633: POP
48634: POP
// if not target then
48635: LD_VAR 0 6
48639: NOT
48640: IFFALSE 48644
// continue ;
48642: GO 48253
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48644: LD_ADDR_VAR 0 7
48648: PUSH
48649: LD_EXP 132
48653: PUSH
48654: LD_VAR 0 2
48658: ARRAY
48659: PPUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 3
48665: PUSH
48666: LD_INT 58
48668: PUSH
48669: EMPTY
48670: LIST
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 61
48678: PUSH
48679: EMPTY
48680: LIST
48681: PUSH
48682: LD_INT 33
48684: PUSH
48685: LD_INT 5
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 33
48694: PUSH
48695: LD_INT 3
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 2
48711: PUSH
48712: LD_INT 34
48714: PUSH
48715: LD_INT 32
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 34
48724: PUSH
48725: LD_INT 51
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 34
48734: PUSH
48735: LD_INT 12
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: ST_TO_ADDR
// if not cargo then
48757: LD_VAR 0 7
48761: NOT
48762: IFFALSE 49405
// begin if mc_crates_collector [ i ] < 5 then
48764: LD_EXP 130
48768: PUSH
48769: LD_VAR 0 2
48773: ARRAY
48774: PUSH
48775: LD_INT 5
48777: LESS
48778: IFFALSE 49144
// begin if mc_ape [ i ] then
48780: LD_EXP 142
48784: PUSH
48785: LD_VAR 0 2
48789: ARRAY
48790: IFFALSE 48837
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48792: LD_ADDR_VAR 0 5
48796: PUSH
48797: LD_EXP 142
48801: PUSH
48802: LD_VAR 0 2
48806: ARRAY
48807: PPUSH
48808: LD_INT 25
48810: PUSH
48811: LD_INT 16
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 24
48820: PUSH
48821: LD_INT 750
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PPUSH
48832: CALL_OW 72
48836: ST_TO_ADDR
// if not tmp then
48837: LD_VAR 0 5
48841: NOT
48842: IFFALSE 48889
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48844: LD_ADDR_VAR 0 5
48848: PUSH
48849: LD_EXP 113
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PPUSH
48860: LD_INT 25
48862: PUSH
48863: LD_INT 2
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 24
48872: PUSH
48873: LD_INT 750
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PPUSH
48884: CALL_OW 72
48888: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48889: LD_EXP 142
48893: PUSH
48894: LD_VAR 0 2
48898: ARRAY
48899: PUSH
48900: LD_EXP 113
48904: PUSH
48905: LD_VAR 0 2
48909: ARRAY
48910: PPUSH
48911: LD_INT 25
48913: PUSH
48914: LD_INT 2
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 24
48923: PUSH
48924: LD_INT 750
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PPUSH
48935: CALL_OW 72
48939: AND
48940: PUSH
48941: LD_VAR 0 5
48945: PUSH
48946: LD_INT 5
48948: LESS
48949: AND
48950: IFFALSE 49032
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48952: LD_ADDR_VAR 0 3
48956: PUSH
48957: LD_EXP 113
48961: PUSH
48962: LD_VAR 0 2
48966: ARRAY
48967: PPUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 2
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 24
48980: PUSH
48981: LD_INT 750
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PPUSH
48992: CALL_OW 72
48996: PUSH
48997: FOR_IN
48998: IFFALSE 49030
// begin tmp := tmp union j ;
49000: LD_ADDR_VAR 0 5
49004: PUSH
49005: LD_VAR 0 5
49009: PUSH
49010: LD_VAR 0 3
49014: UNION
49015: ST_TO_ADDR
// if tmp >= 5 then
49016: LD_VAR 0 5
49020: PUSH
49021: LD_INT 5
49023: GREATEREQUAL
49024: IFFALSE 49028
// break ;
49026: GO 49030
// end ;
49028: GO 48997
49030: POP
49031: POP
// end ; if not tmp then
49032: LD_VAR 0 5
49036: NOT
49037: IFFALSE 49041
// continue ;
49039: GO 48253
// for j in tmp do
49041: LD_ADDR_VAR 0 3
49045: PUSH
49046: LD_VAR 0 5
49050: PUSH
49051: FOR_IN
49052: IFFALSE 49142
// if not GetTag ( j ) then
49054: LD_VAR 0 3
49058: PPUSH
49059: CALL_OW 110
49063: NOT
49064: IFFALSE 49140
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49066: LD_ADDR_EXP 130
49070: PUSH
49071: LD_EXP 130
49075: PPUSH
49076: LD_VAR 0 2
49080: PUSH
49081: LD_EXP 130
49085: PUSH
49086: LD_VAR 0 2
49090: ARRAY
49091: PUSH
49092: LD_INT 1
49094: PLUS
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PPUSH
49100: LD_VAR 0 3
49104: PPUSH
49105: CALL 70150 0 3
49109: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49110: LD_VAR 0 3
49114: PPUSH
49115: LD_INT 107
49117: PPUSH
49118: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49122: LD_EXP 130
49126: PUSH
49127: LD_VAR 0 2
49131: ARRAY
49132: PUSH
49133: LD_INT 5
49135: GREATEREQUAL
49136: IFFALSE 49140
// break ;
49138: GO 49142
// end ;
49140: GO 49051
49142: POP
49143: POP
// end ; if mc_crates_collector [ i ] and target then
49144: LD_EXP 130
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PUSH
49155: LD_VAR 0 6
49159: AND
49160: IFFALSE 49403
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49162: LD_EXP 130
49166: PUSH
49167: LD_VAR 0 2
49171: ARRAY
49172: PUSH
49173: LD_VAR 0 6
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: LESS
49182: IFFALSE 49202
// tmp := mc_crates_collector [ i ] else
49184: LD_ADDR_VAR 0 5
49188: PUSH
49189: LD_EXP 130
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: ST_TO_ADDR
49200: GO 49216
// tmp := target [ 1 ] ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_VAR 0 6
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: ST_TO_ADDR
// k := 0 ;
49216: LD_ADDR_VAR 0 4
49220: PUSH
49221: LD_INT 0
49223: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49224: LD_ADDR_VAR 0 3
49228: PUSH
49229: LD_EXP 130
49233: PUSH
49234: LD_VAR 0 2
49238: ARRAY
49239: PUSH
49240: FOR_IN
49241: IFFALSE 49401
// begin k := k + 1 ;
49243: LD_ADDR_VAR 0 4
49247: PUSH
49248: LD_VAR 0 4
49252: PUSH
49253: LD_INT 1
49255: PLUS
49256: ST_TO_ADDR
// if k > tmp then
49257: LD_VAR 0 4
49261: PUSH
49262: LD_VAR 0 5
49266: GREATER
49267: IFFALSE 49271
// break ;
49269: GO 49401
// if not GetClass ( j ) in [ 2 , 16 ] then
49271: LD_VAR 0 3
49275: PPUSH
49276: CALL_OW 257
49280: PUSH
49281: LD_INT 2
49283: PUSH
49284: LD_INT 16
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: IN
49291: NOT
49292: IFFALSE 49345
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49294: LD_ADDR_EXP 130
49298: PUSH
49299: LD_EXP 130
49303: PPUSH
49304: LD_VAR 0 2
49308: PPUSH
49309: LD_EXP 130
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 3
49324: DIFF
49325: PPUSH
49326: CALL_OW 1
49330: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49331: LD_VAR 0 3
49335: PPUSH
49336: LD_INT 0
49338: PPUSH
49339: CALL_OW 109
// continue ;
49343: GO 49240
// end ; if IsInUnit ( j ) then
49345: LD_VAR 0 3
49349: PPUSH
49350: CALL_OW 310
49354: IFFALSE 49365
// ComExitBuilding ( j ) ;
49356: LD_VAR 0 3
49360: PPUSH
49361: CALL_OW 122
// wait ( 3 ) ;
49365: LD_INT 3
49367: PPUSH
49368: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49372: LD_VAR 0 3
49376: PPUSH
49377: LD_VAR 0 6
49381: PUSH
49382: LD_INT 2
49384: ARRAY
49385: PPUSH
49386: LD_VAR 0 6
49390: PUSH
49391: LD_INT 3
49393: ARRAY
49394: PPUSH
49395: CALL_OW 117
// end ;
49399: GO 49240
49401: POP
49402: POP
// end ; end else
49403: GO 49984
// begin for j in cargo do
49405: LD_ADDR_VAR 0 3
49409: PUSH
49410: LD_VAR 0 7
49414: PUSH
49415: FOR_IN
49416: IFFALSE 49982
// begin if GetTag ( j ) <> 0 then
49418: LD_VAR 0 3
49422: PPUSH
49423: CALL_OW 110
49427: PUSH
49428: LD_INT 0
49430: NONEQUAL
49431: IFFALSE 49435
// continue ;
49433: GO 49415
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49435: LD_VAR 0 3
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 1000
49447: LESS
49448: PUSH
49449: LD_VAR 0 3
49453: PPUSH
49454: LD_EXP 137
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: PPUSH
49465: CALL_OW 308
49469: NOT
49470: AND
49471: IFFALSE 49493
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49473: LD_VAR 0 3
49477: PPUSH
49478: LD_EXP 137
49482: PUSH
49483: LD_VAR 0 2
49487: ARRAY
49488: PPUSH
49489: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49493: LD_VAR 0 3
49497: PPUSH
49498: CALL_OW 256
49502: PUSH
49503: LD_INT 1000
49505: LESS
49506: PUSH
49507: LD_VAR 0 3
49511: PPUSH
49512: LD_EXP 137
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PPUSH
49523: CALL_OW 308
49527: AND
49528: IFFALSE 49532
// continue ;
49530: GO 49415
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49532: LD_VAR 0 3
49536: PPUSH
49537: CALL_OW 262
49541: PUSH
49542: LD_INT 2
49544: EQUAL
49545: PUSH
49546: LD_VAR 0 3
49550: PPUSH
49551: CALL_OW 261
49555: PUSH
49556: LD_INT 15
49558: LESS
49559: AND
49560: IFFALSE 49564
// continue ;
49562: GO 49415
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49564: LD_VAR 0 3
49568: PPUSH
49569: CALL_OW 262
49573: PUSH
49574: LD_INT 1
49576: EQUAL
49577: PUSH
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 261
49587: PUSH
49588: LD_INT 10
49590: LESS
49591: AND
49592: IFFALSE 49921
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49594: LD_ADDR_VAR 0 8
49598: PUSH
49599: LD_EXP 113
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: LD_INT 2
49612: PUSH
49613: LD_INT 30
49615: PUSH
49616: LD_INT 0
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 30
49625: PUSH
49626: LD_INT 1
49628: PUSH
49629: EMPTY
49630: LIST
49631: LIST
49632: PUSH
49633: EMPTY
49634: LIST
49635: LIST
49636: LIST
49637: PPUSH
49638: CALL_OW 72
49642: ST_TO_ADDR
// if not depot then
49643: LD_VAR 0 8
49647: NOT
49648: IFFALSE 49652
// continue ;
49650: GO 49415
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49652: LD_VAR 0 3
49656: PPUSH
49657: LD_VAR 0 8
49661: PPUSH
49662: LD_VAR 0 3
49666: PPUSH
49667: CALL_OW 74
49671: PPUSH
49672: CALL_OW 296
49676: PUSH
49677: LD_INT 6
49679: LESS
49680: IFFALSE 49696
// SetFuel ( j , 100 ) else
49682: LD_VAR 0 3
49686: PPUSH
49687: LD_INT 100
49689: PPUSH
49690: CALL_OW 240
49694: GO 49921
// if GetFuel ( j ) = 0 then
49696: LD_VAR 0 3
49700: PPUSH
49701: CALL_OW 261
49705: PUSH
49706: LD_INT 0
49708: EQUAL
49709: IFFALSE 49921
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49711: LD_ADDR_EXP 132
49715: PUSH
49716: LD_EXP 132
49720: PPUSH
49721: LD_VAR 0 2
49725: PPUSH
49726: LD_EXP 132
49730: PUSH
49731: LD_VAR 0 2
49735: ARRAY
49736: PUSH
49737: LD_VAR 0 3
49741: DIFF
49742: PPUSH
49743: CALL_OW 1
49747: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49748: LD_VAR 0 3
49752: PPUSH
49753: CALL_OW 263
49757: PUSH
49758: LD_INT 1
49760: EQUAL
49761: IFFALSE 49777
// ComExitVehicle ( IsInUnit ( j ) ) ;
49763: LD_VAR 0 3
49767: PPUSH
49768: CALL_OW 310
49772: PPUSH
49773: CALL_OW 121
// if GetControl ( j ) = control_remote then
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL_OW 263
49786: PUSH
49787: LD_INT 2
49789: EQUAL
49790: IFFALSE 49801
// ComUnlink ( j ) ;
49792: LD_VAR 0 3
49796: PPUSH
49797: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49801: LD_ADDR_VAR 0 9
49805: PUSH
49806: LD_VAR 0 2
49810: PPUSH
49811: LD_INT 3
49813: PPUSH
49814: CALL 59296 0 2
49818: ST_TO_ADDR
// if fac then
49819: LD_VAR 0 9
49823: IFFALSE 49919
// begin for k in fac do
49825: LD_ADDR_VAR 0 4
49829: PUSH
49830: LD_VAR 0 9
49834: PUSH
49835: FOR_IN
49836: IFFALSE 49917
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49838: LD_ADDR_VAR 0 10
49842: PUSH
49843: LD_VAR 0 9
49847: PPUSH
49848: LD_VAR 0 3
49852: PPUSH
49853: CALL_OW 265
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL_OW 262
49867: PPUSH
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL_OW 263
49877: PPUSH
49878: LD_VAR 0 3
49882: PPUSH
49883: CALL_OW 264
49887: PPUSH
49888: CALL 67682 0 5
49892: ST_TO_ADDR
// if components then
49893: LD_VAR 0 10
49897: IFFALSE 49915
// begin MC_InsertProduceList ( i , components ) ;
49899: LD_VAR 0 2
49903: PPUSH
49904: LD_VAR 0 10
49908: PPUSH
49909: CALL 58841 0 2
// break ;
49913: GO 49917
// end ; end ;
49915: GO 49835
49917: POP
49918: POP
// end ; continue ;
49919: GO 49415
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49921: LD_VAR 0 3
49925: PPUSH
49926: LD_INT 1
49928: PPUSH
49929: CALL_OW 289
49933: PUSH
49934: LD_INT 100
49936: LESS
49937: PUSH
49938: LD_VAR 0 3
49942: PPUSH
49943: CALL_OW 314
49947: NOT
49948: AND
49949: IFFALSE 49978
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49951: LD_VAR 0 3
49955: PPUSH
49956: LD_VAR 0 6
49960: PUSH
49961: LD_INT 2
49963: ARRAY
49964: PPUSH
49965: LD_VAR 0 6
49969: PUSH
49970: LD_INT 3
49972: ARRAY
49973: PPUSH
49974: CALL_OW 117
// break ;
49978: GO 49982
// end ;
49980: GO 49415
49982: POP
49983: POP
// end ; end ;
49984: GO 48253
49986: POP
49987: POP
// end ;
49988: LD_VAR 0 1
49992: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49993: LD_INT 0
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
// if not mc_bases then
49999: LD_EXP 113
50003: NOT
50004: IFFALSE 50008
// exit ;
50006: GO 50169
// for i = 1 to mc_bases do
50008: LD_ADDR_VAR 0 2
50012: PUSH
50013: DOUBLE
50014: LD_INT 1
50016: DEC
50017: ST_TO_ADDR
50018: LD_EXP 113
50022: PUSH
50023: FOR_TO
50024: IFFALSE 50167
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50026: LD_ADDR_VAR 0 4
50030: PUSH
50031: LD_EXP 132
50035: PUSH
50036: LD_VAR 0 2
50040: ARRAY
50041: PUSH
50042: LD_EXP 135
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: UNION
50053: PPUSH
50054: LD_INT 33
50056: PUSH
50057: LD_INT 2
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PPUSH
50064: CALL_OW 72
50068: ST_TO_ADDR
// if tmp then
50069: LD_VAR 0 4
50073: IFFALSE 50165
// for j in tmp do
50075: LD_ADDR_VAR 0 3
50079: PUSH
50080: LD_VAR 0 4
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50163
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50088: LD_VAR 0 3
50092: PPUSH
50093: CALL_OW 312
50097: NOT
50098: PUSH
50099: LD_VAR 0 3
50103: PPUSH
50104: CALL_OW 256
50108: PUSH
50109: LD_INT 250
50111: GREATEREQUAL
50112: AND
50113: IFFALSE 50126
// Connect ( j ) else
50115: LD_VAR 0 3
50119: PPUSH
50120: CALL 73083 0 1
50124: GO 50161
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50126: LD_VAR 0 3
50130: PPUSH
50131: CALL_OW 256
50135: PUSH
50136: LD_INT 250
50138: LESS
50139: PUSH
50140: LD_VAR 0 3
50144: PPUSH
50145: CALL_OW 312
50149: AND
50150: IFFALSE 50161
// ComUnlink ( j ) ;
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 136
50161: GO 50085
50163: POP
50164: POP
// end ;
50165: GO 50023
50167: POP
50168: POP
// end ;
50169: LD_VAR 0 1
50173: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50174: LD_INT 0
50176: PPUSH
50177: PPUSH
50178: PPUSH
50179: PPUSH
50180: PPUSH
// if not mc_bases then
50181: LD_EXP 113
50185: NOT
50186: IFFALSE 50190
// exit ;
50188: GO 50635
// for i = 1 to mc_bases do
50190: LD_ADDR_VAR 0 2
50194: PUSH
50195: DOUBLE
50196: LD_INT 1
50198: DEC
50199: ST_TO_ADDR
50200: LD_EXP 113
50204: PUSH
50205: FOR_TO
50206: IFFALSE 50633
// begin if not mc_produce [ i ] then
50208: LD_EXP 134
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: NOT
50219: IFFALSE 50223
// continue ;
50221: GO 50205
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50223: LD_ADDR_VAR 0 5
50227: PUSH
50228: LD_EXP 113
50232: PUSH
50233: LD_VAR 0 2
50237: ARRAY
50238: PPUSH
50239: LD_INT 30
50241: PUSH
50242: LD_INT 3
50244: PUSH
50245: EMPTY
50246: LIST
50247: LIST
50248: PPUSH
50249: CALL_OW 72
50253: ST_TO_ADDR
// if not fac then
50254: LD_VAR 0 5
50258: NOT
50259: IFFALSE 50263
// continue ;
50261: GO 50205
// for j in fac do
50263: LD_ADDR_VAR 0 3
50267: PUSH
50268: LD_VAR 0 5
50272: PUSH
50273: FOR_IN
50274: IFFALSE 50629
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50276: LD_VAR 0 3
50280: PPUSH
50281: CALL_OW 461
50285: PUSH
50286: LD_INT 2
50288: NONEQUAL
50289: PUSH
50290: LD_VAR 0 3
50294: PPUSH
50295: LD_INT 15
50297: PPUSH
50298: CALL 72743 0 2
50302: PUSH
50303: LD_INT 4
50305: ARRAY
50306: OR
50307: IFFALSE 50311
// continue ;
50309: GO 50273
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50311: LD_VAR 0 3
50315: PPUSH
50316: LD_EXP 134
50320: PUSH
50321: LD_VAR 0 2
50325: ARRAY
50326: PUSH
50327: LD_INT 1
50329: ARRAY
50330: PUSH
50331: LD_INT 1
50333: ARRAY
50334: PPUSH
50335: LD_EXP 134
50339: PUSH
50340: LD_VAR 0 2
50344: ARRAY
50345: PUSH
50346: LD_INT 1
50348: ARRAY
50349: PUSH
50350: LD_INT 2
50352: ARRAY
50353: PPUSH
50354: LD_EXP 134
50358: PUSH
50359: LD_VAR 0 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PUSH
50369: LD_INT 3
50371: ARRAY
50372: PPUSH
50373: LD_EXP 134
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: PUSH
50384: LD_INT 1
50386: ARRAY
50387: PUSH
50388: LD_INT 4
50390: ARRAY
50391: PPUSH
50392: CALL_OW 448
50396: PUSH
50397: LD_VAR 0 3
50401: PPUSH
50402: LD_EXP 134
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: PUSH
50413: LD_INT 1
50415: ARRAY
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_EXP 134
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: PUSH
50432: LD_INT 1
50434: ARRAY
50435: PUSH
50436: LD_INT 2
50438: ARRAY
50439: PUSH
50440: LD_EXP 134
50444: PUSH
50445: LD_VAR 0 2
50449: ARRAY
50450: PUSH
50451: LD_INT 1
50453: ARRAY
50454: PUSH
50455: LD_INT 3
50457: ARRAY
50458: PUSH
50459: LD_EXP 134
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_INT 1
50472: ARRAY
50473: PUSH
50474: LD_INT 4
50476: ARRAY
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: PPUSH
50484: CALL 76414 0 2
50488: AND
50489: IFFALSE 50627
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50491: LD_VAR 0 3
50495: PPUSH
50496: LD_EXP 134
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PUSH
50507: LD_INT 1
50509: ARRAY
50510: PUSH
50511: LD_INT 1
50513: ARRAY
50514: PPUSH
50515: LD_EXP 134
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: PUSH
50526: LD_INT 1
50528: ARRAY
50529: PUSH
50530: LD_INT 2
50532: ARRAY
50533: PPUSH
50534: LD_EXP 134
50538: PUSH
50539: LD_VAR 0 2
50543: ARRAY
50544: PUSH
50545: LD_INT 1
50547: ARRAY
50548: PUSH
50549: LD_INT 3
50551: ARRAY
50552: PPUSH
50553: LD_EXP 134
50557: PUSH
50558: LD_VAR 0 2
50562: ARRAY
50563: PUSH
50564: LD_INT 1
50566: ARRAY
50567: PUSH
50568: LD_INT 4
50570: ARRAY
50571: PPUSH
50572: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50576: LD_ADDR_VAR 0 4
50580: PUSH
50581: LD_EXP 134
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PPUSH
50592: LD_INT 1
50594: PPUSH
50595: CALL_OW 3
50599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50600: LD_ADDR_EXP 134
50604: PUSH
50605: LD_EXP 134
50609: PPUSH
50610: LD_VAR 0 2
50614: PPUSH
50615: LD_VAR 0 4
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// break ;
50625: GO 50629
// end ; end ;
50627: GO 50273
50629: POP
50630: POP
// end ;
50631: GO 50205
50633: POP
50634: POP
// end ;
50635: LD_VAR 0 1
50639: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50640: LD_INT 0
50642: PPUSH
50643: PPUSH
50644: PPUSH
// if not mc_bases then
50645: LD_EXP 113
50649: NOT
50650: IFFALSE 50654
// exit ;
50652: GO 50743
// for i = 1 to mc_bases do
50654: LD_ADDR_VAR 0 2
50658: PUSH
50659: DOUBLE
50660: LD_INT 1
50662: DEC
50663: ST_TO_ADDR
50664: LD_EXP 113
50668: PUSH
50669: FOR_TO
50670: IFFALSE 50741
// begin if mc_attack [ i ] then
50672: LD_EXP 133
50676: PUSH
50677: LD_VAR 0 2
50681: ARRAY
50682: IFFALSE 50739
// begin tmp := mc_attack [ i ] [ 1 ] ;
50684: LD_ADDR_VAR 0 3
50688: PUSH
50689: LD_EXP 133
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PUSH
50700: LD_INT 1
50702: ARRAY
50703: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50704: LD_ADDR_EXP 133
50708: PUSH
50709: LD_EXP 133
50713: PPUSH
50714: LD_VAR 0 2
50718: PPUSH
50719: EMPTY
50720: PPUSH
50721: CALL_OW 1
50725: ST_TO_ADDR
// Attack ( tmp ) ;
50726: LD_VAR 0 3
50730: PPUSH
50731: CALL 119429 0 1
// exit ;
50735: POP
50736: POP
50737: GO 50743
// end ; end ;
50739: GO 50669
50741: POP
50742: POP
// end ;
50743: LD_VAR 0 1
50747: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
50752: PPUSH
50753: PPUSH
50754: PPUSH
50755: PPUSH
50756: PPUSH
// if not mc_bases then
50757: LD_EXP 113
50761: NOT
50762: IFFALSE 50766
// exit ;
50764: GO 51370
// for i = 1 to mc_bases do
50766: LD_ADDR_VAR 0 2
50770: PUSH
50771: DOUBLE
50772: LD_INT 1
50774: DEC
50775: ST_TO_ADDR
50776: LD_EXP 113
50780: PUSH
50781: FOR_TO
50782: IFFALSE 51368
// begin if not mc_bases [ i ] then
50784: LD_EXP 113
50788: PUSH
50789: LD_VAR 0 2
50793: ARRAY
50794: NOT
50795: IFFALSE 50799
// continue ;
50797: GO 50781
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50799: LD_ADDR_VAR 0 7
50803: PUSH
50804: LD_EXP 113
50808: PUSH
50809: LD_VAR 0 2
50813: ARRAY
50814: PUSH
50815: LD_INT 1
50817: ARRAY
50818: PPUSH
50819: CALL 66986 0 1
50823: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50824: LD_ADDR_EXP 136
50828: PUSH
50829: LD_EXP 136
50833: PPUSH
50834: LD_VAR 0 2
50838: PPUSH
50839: LD_EXP 113
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PUSH
50850: LD_INT 1
50852: ARRAY
50853: PPUSH
50854: CALL_OW 255
50858: PPUSH
50859: LD_EXP 138
50863: PUSH
50864: LD_VAR 0 2
50868: ARRAY
50869: PPUSH
50870: CALL 66951 0 2
50874: PPUSH
50875: CALL_OW 1
50879: ST_TO_ADDR
// if not mc_scan [ i ] then
50880: LD_EXP 136
50884: PUSH
50885: LD_VAR 0 2
50889: ARRAY
50890: NOT
50891: IFFALSE 51046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50893: LD_ADDR_VAR 0 4
50897: PUSH
50898: LD_EXP 113
50902: PUSH
50903: LD_VAR 0 2
50907: ARRAY
50908: PPUSH
50909: LD_INT 2
50911: PUSH
50912: LD_INT 25
50914: PUSH
50915: LD_INT 5
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 25
50924: PUSH
50925: LD_INT 8
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: LD_INT 25
50934: PUSH
50935: LD_INT 9
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: PPUSH
50948: CALL_OW 72
50952: ST_TO_ADDR
// if not tmp then
50953: LD_VAR 0 4
50957: NOT
50958: IFFALSE 50962
// continue ;
50960: GO 50781
// for j in tmp do
50962: LD_ADDR_VAR 0 3
50966: PUSH
50967: LD_VAR 0 4
50971: PUSH
50972: FOR_IN
50973: IFFALSE 51044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50975: LD_VAR 0 3
50979: PPUSH
50980: CALL_OW 310
50984: PPUSH
50985: CALL_OW 266
50989: PUSH
50990: LD_INT 5
50992: EQUAL
50993: PUSH
50994: LD_VAR 0 3
50998: PPUSH
50999: CALL_OW 257
51003: PUSH
51004: LD_INT 1
51006: EQUAL
51007: AND
51008: PUSH
51009: LD_VAR 0 3
51013: PPUSH
51014: CALL_OW 459
51018: NOT
51019: AND
51020: PUSH
51021: LD_VAR 0 7
51025: AND
51026: IFFALSE 51042
// ComChangeProfession ( j , class ) ;
51028: LD_VAR 0 3
51032: PPUSH
51033: LD_VAR 0 7
51037: PPUSH
51038: CALL_OW 123
51042: GO 50972
51044: POP
51045: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51046: LD_EXP 136
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: PUSH
51057: LD_EXP 135
51061: PUSH
51062: LD_VAR 0 2
51066: ARRAY
51067: NOT
51068: AND
51069: PUSH
51070: LD_EXP 113
51074: PUSH
51075: LD_VAR 0 2
51079: ARRAY
51080: PPUSH
51081: LD_INT 30
51083: PUSH
51084: LD_INT 32
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PPUSH
51091: CALL_OW 72
51095: NOT
51096: AND
51097: PUSH
51098: LD_EXP 113
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PPUSH
51109: LD_INT 2
51111: PUSH
51112: LD_INT 30
51114: PUSH
51115: LD_INT 4
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 30
51124: PUSH
51125: LD_INT 5
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: LIST
51136: PPUSH
51137: CALL_OW 72
51141: NOT
51142: AND
51143: IFFALSE 51275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51145: LD_ADDR_VAR 0 4
51149: PUSH
51150: LD_EXP 113
51154: PUSH
51155: LD_VAR 0 2
51159: ARRAY
51160: PPUSH
51161: LD_INT 2
51163: PUSH
51164: LD_INT 25
51166: PUSH
51167: LD_INT 1
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PUSH
51174: LD_INT 25
51176: PUSH
51177: LD_INT 5
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 25
51186: PUSH
51187: LD_INT 8
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 25
51196: PUSH
51197: LD_INT 9
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: LIST
51208: LIST
51209: LIST
51210: PPUSH
51211: CALL_OW 72
51215: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51216: LD_ADDR_VAR 0 4
51220: PUSH
51221: LD_VAR 0 4
51225: PUSH
51226: LD_VAR 0 4
51230: PPUSH
51231: LD_INT 18
51233: PPUSH
51234: CALL 98711 0 2
51238: DIFF
51239: ST_TO_ADDR
// if tmp then
51240: LD_VAR 0 4
51244: IFFALSE 51275
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_VAR 0 4
51255: PPUSH
51256: LD_EXP 138
51260: PUSH
51261: LD_VAR 0 2
51265: ARRAY
51266: PPUSH
51267: CALL 124138 0 3
// exit ;
51271: POP
51272: POP
51273: GO 51370
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51275: LD_EXP 136
51279: PUSH
51280: LD_VAR 0 2
51284: ARRAY
51285: PUSH
51286: LD_EXP 135
51290: PUSH
51291: LD_VAR 0 2
51295: ARRAY
51296: AND
51297: IFFALSE 51366
// begin tmp := mc_defender [ i ] ;
51299: LD_ADDR_VAR 0 4
51303: PUSH
51304: LD_EXP 135
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51315: LD_ADDR_EXP 135
51319: PUSH
51320: LD_EXP 135
51324: PPUSH
51325: LD_VAR 0 2
51329: PPUSH
51330: EMPTY
51331: PPUSH
51332: CALL_OW 1
51336: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51337: LD_VAR 0 2
51341: PPUSH
51342: LD_VAR 0 4
51346: PPUSH
51347: LD_EXP 136
51351: PUSH
51352: LD_VAR 0 2
51356: ARRAY
51357: PPUSH
51358: CALL 124699 0 3
// exit ;
51362: POP
51363: POP
51364: GO 51370
// end ; end ;
51366: GO 50781
51368: POP
51369: POP
// end ;
51370: LD_VAR 0 1
51374: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51375: LD_INT 0
51377: PPUSH
51378: PPUSH
51379: PPUSH
51380: PPUSH
51381: PPUSH
51382: PPUSH
51383: PPUSH
51384: PPUSH
51385: PPUSH
51386: PPUSH
51387: PPUSH
// if not mc_bases then
51388: LD_EXP 113
51392: NOT
51393: IFFALSE 51397
// exit ;
51395: GO 52484
// for i = 1 to mc_bases do
51397: LD_ADDR_VAR 0 2
51401: PUSH
51402: DOUBLE
51403: LD_INT 1
51405: DEC
51406: ST_TO_ADDR
51407: LD_EXP 113
51411: PUSH
51412: FOR_TO
51413: IFFALSE 52482
// begin tmp := mc_lab [ i ] ;
51415: LD_ADDR_VAR 0 6
51419: PUSH
51420: LD_EXP 146
51424: PUSH
51425: LD_VAR 0 2
51429: ARRAY
51430: ST_TO_ADDR
// if not tmp then
51431: LD_VAR 0 6
51435: NOT
51436: IFFALSE 51440
// continue ;
51438: GO 51412
// idle_lab := 0 ;
51440: LD_ADDR_VAR 0 11
51444: PUSH
51445: LD_INT 0
51447: ST_TO_ADDR
// for j in tmp do
51448: LD_ADDR_VAR 0 3
51452: PUSH
51453: LD_VAR 0 6
51457: PUSH
51458: FOR_IN
51459: IFFALSE 52478
// begin researching := false ;
51461: LD_ADDR_VAR 0 10
51465: PUSH
51466: LD_INT 0
51468: ST_TO_ADDR
// side := GetSide ( j ) ;
51469: LD_ADDR_VAR 0 4
51473: PUSH
51474: LD_VAR 0 3
51478: PPUSH
51479: CALL_OW 255
51483: ST_TO_ADDR
// if not mc_tech [ side ] then
51484: LD_EXP 140
51488: PUSH
51489: LD_VAR 0 4
51493: ARRAY
51494: NOT
51495: IFFALSE 51499
// continue ;
51497: GO 51458
// if BuildingStatus ( j ) = bs_idle then
51499: LD_VAR 0 3
51503: PPUSH
51504: CALL_OW 461
51508: PUSH
51509: LD_INT 2
51511: EQUAL
51512: IFFALSE 51700
// begin if idle_lab and UnitsInside ( j ) < 6 then
51514: LD_VAR 0 11
51518: PUSH
51519: LD_VAR 0 3
51523: PPUSH
51524: CALL_OW 313
51528: PUSH
51529: LD_INT 6
51531: LESS
51532: AND
51533: IFFALSE 51604
// begin tmp2 := UnitsInside ( idle_lab ) ;
51535: LD_ADDR_VAR 0 9
51539: PUSH
51540: LD_VAR 0 11
51544: PPUSH
51545: CALL_OW 313
51549: ST_TO_ADDR
// if tmp2 then
51550: LD_VAR 0 9
51554: IFFALSE 51596
// for x in tmp2 do
51556: LD_ADDR_VAR 0 7
51560: PUSH
51561: LD_VAR 0 9
51565: PUSH
51566: FOR_IN
51567: IFFALSE 51594
// begin ComExitBuilding ( x ) ;
51569: LD_VAR 0 7
51573: PPUSH
51574: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51578: LD_VAR 0 7
51582: PPUSH
51583: LD_VAR 0 3
51587: PPUSH
51588: CALL_OW 180
// end ;
51592: GO 51566
51594: POP
51595: POP
// idle_lab := 0 ;
51596: LD_ADDR_VAR 0 11
51600: PUSH
51601: LD_INT 0
51603: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51604: LD_ADDR_VAR 0 5
51608: PUSH
51609: LD_EXP 140
51613: PUSH
51614: LD_VAR 0 4
51618: ARRAY
51619: PUSH
51620: FOR_IN
51621: IFFALSE 51681
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51623: LD_VAR 0 3
51627: PPUSH
51628: LD_VAR 0 5
51632: PPUSH
51633: CALL_OW 430
51637: PUSH
51638: LD_VAR 0 4
51642: PPUSH
51643: LD_VAR 0 5
51647: PPUSH
51648: CALL 66056 0 2
51652: AND
51653: IFFALSE 51679
// begin researching := true ;
51655: LD_ADDR_VAR 0 10
51659: PUSH
51660: LD_INT 1
51662: ST_TO_ADDR
// ComResearch ( j , t ) ;
51663: LD_VAR 0 3
51667: PPUSH
51668: LD_VAR 0 5
51672: PPUSH
51673: CALL_OW 124
// break ;
51677: GO 51681
// end ;
51679: GO 51620
51681: POP
51682: POP
// if not researching then
51683: LD_VAR 0 10
51687: NOT
51688: IFFALSE 51700
// idle_lab := j ;
51690: LD_ADDR_VAR 0 11
51694: PUSH
51695: LD_VAR 0 3
51699: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51700: LD_VAR 0 3
51704: PPUSH
51705: CALL_OW 461
51709: PUSH
51710: LD_INT 10
51712: EQUAL
51713: IFFALSE 52301
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51715: LD_EXP 142
51719: PUSH
51720: LD_VAR 0 2
51724: ARRAY
51725: NOT
51726: PUSH
51727: LD_EXP 143
51731: PUSH
51732: LD_VAR 0 2
51736: ARRAY
51737: NOT
51738: AND
51739: PUSH
51740: LD_EXP 140
51744: PUSH
51745: LD_VAR 0 4
51749: ARRAY
51750: PUSH
51751: LD_INT 1
51753: GREATER
51754: AND
51755: IFFALSE 51886
// begin ComCancel ( j ) ;
51757: LD_VAR 0 3
51761: PPUSH
51762: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51766: LD_ADDR_EXP 140
51770: PUSH
51771: LD_EXP 140
51775: PPUSH
51776: LD_VAR 0 4
51780: PPUSH
51781: LD_EXP 140
51785: PUSH
51786: LD_VAR 0 4
51790: ARRAY
51791: PPUSH
51792: LD_EXP 140
51796: PUSH
51797: LD_VAR 0 4
51801: ARRAY
51802: PUSH
51803: LD_INT 1
51805: MINUS
51806: PPUSH
51807: LD_EXP 140
51811: PUSH
51812: LD_VAR 0 4
51816: ARRAY
51817: PPUSH
51818: LD_INT 0
51820: PPUSH
51821: CALL 69568 0 4
51825: PPUSH
51826: CALL_OW 1
51830: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51831: LD_ADDR_EXP 140
51835: PUSH
51836: LD_EXP 140
51840: PPUSH
51841: LD_VAR 0 4
51845: PPUSH
51846: LD_EXP 140
51850: PUSH
51851: LD_VAR 0 4
51855: ARRAY
51856: PPUSH
51857: LD_EXP 140
51861: PUSH
51862: LD_VAR 0 4
51866: ARRAY
51867: PPUSH
51868: LD_INT 1
51870: PPUSH
51871: LD_INT 0
51873: PPUSH
51874: CALL 69568 0 4
51878: PPUSH
51879: CALL_OW 1
51883: ST_TO_ADDR
// continue ;
51884: GO 51458
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51886: LD_EXP 142
51890: PUSH
51891: LD_VAR 0 2
51895: ARRAY
51896: PUSH
51897: LD_EXP 143
51901: PUSH
51902: LD_VAR 0 2
51906: ARRAY
51907: NOT
51908: AND
51909: IFFALSE 52036
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51911: LD_ADDR_EXP 143
51915: PUSH
51916: LD_EXP 143
51920: PPUSH
51921: LD_VAR 0 2
51925: PUSH
51926: LD_EXP 143
51930: PUSH
51931: LD_VAR 0 2
51935: ARRAY
51936: PUSH
51937: LD_INT 1
51939: PLUS
51940: PUSH
51941: EMPTY
51942: LIST
51943: LIST
51944: PPUSH
51945: LD_EXP 142
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PUSH
51956: LD_INT 1
51958: ARRAY
51959: PPUSH
51960: CALL 70150 0 3
51964: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51965: LD_EXP 142
51969: PUSH
51970: LD_VAR 0 2
51974: ARRAY
51975: PUSH
51976: LD_INT 1
51978: ARRAY
51979: PPUSH
51980: LD_INT 112
51982: PPUSH
51983: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51987: LD_ADDR_VAR 0 9
51991: PUSH
51992: LD_EXP 142
51996: PUSH
51997: LD_VAR 0 2
52001: ARRAY
52002: PPUSH
52003: LD_INT 1
52005: PPUSH
52006: CALL_OW 3
52010: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52011: LD_ADDR_EXP 142
52015: PUSH
52016: LD_EXP 142
52020: PPUSH
52021: LD_VAR 0 2
52025: PPUSH
52026: LD_VAR 0 9
52030: PPUSH
52031: CALL_OW 1
52035: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52036: LD_EXP 142
52040: PUSH
52041: LD_VAR 0 2
52045: ARRAY
52046: PUSH
52047: LD_EXP 143
52051: PUSH
52052: LD_VAR 0 2
52056: ARRAY
52057: AND
52058: PUSH
52059: LD_EXP 143
52063: PUSH
52064: LD_VAR 0 2
52068: ARRAY
52069: PUSH
52070: LD_INT 1
52072: ARRAY
52073: PPUSH
52074: CALL_OW 310
52078: NOT
52079: AND
52080: PUSH
52081: LD_VAR 0 3
52085: PPUSH
52086: CALL_OW 313
52090: PUSH
52091: LD_INT 6
52093: EQUAL
52094: AND
52095: IFFALSE 52151
// begin tmp2 := UnitsInside ( j ) ;
52097: LD_ADDR_VAR 0 9
52101: PUSH
52102: LD_VAR 0 3
52106: PPUSH
52107: CALL_OW 313
52111: ST_TO_ADDR
// if tmp2 = 6 then
52112: LD_VAR 0 9
52116: PUSH
52117: LD_INT 6
52119: EQUAL
52120: IFFALSE 52151
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52122: LD_VAR 0 9
52126: PUSH
52127: LD_INT 1
52129: ARRAY
52130: PPUSH
52131: LD_INT 112
52133: PPUSH
52134: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52138: LD_VAR 0 9
52142: PUSH
52143: LD_INT 1
52145: ARRAY
52146: PPUSH
52147: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52151: LD_EXP 143
52155: PUSH
52156: LD_VAR 0 2
52160: ARRAY
52161: PUSH
52162: LD_EXP 143
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 314
52181: NOT
52182: AND
52183: PUSH
52184: LD_EXP 143
52188: PUSH
52189: LD_VAR 0 2
52193: ARRAY
52194: PUSH
52195: LD_INT 1
52197: ARRAY
52198: PPUSH
52199: CALL_OW 310
52203: NOT
52204: AND
52205: IFFALSE 52231
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52207: LD_EXP 143
52211: PUSH
52212: LD_VAR 0 2
52216: ARRAY
52217: PUSH
52218: LD_INT 1
52220: ARRAY
52221: PPUSH
52222: LD_VAR 0 3
52226: PPUSH
52227: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52231: LD_EXP 143
52235: PUSH
52236: LD_VAR 0 2
52240: ARRAY
52241: PUSH
52242: LD_INT 1
52244: ARRAY
52245: PPUSH
52246: CALL_OW 310
52250: PUSH
52251: LD_EXP 143
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PUSH
52262: LD_INT 1
52264: ARRAY
52265: PPUSH
52266: CALL_OW 310
52270: PPUSH
52271: CALL_OW 461
52275: PUSH
52276: LD_INT 3
52278: NONEQUAL
52279: AND
52280: IFFALSE 52301
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52282: LD_EXP 143
52286: PUSH
52287: LD_VAR 0 2
52291: ARRAY
52292: PUSH
52293: LD_INT 1
52295: ARRAY
52296: PPUSH
52297: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52301: LD_VAR 0 3
52305: PPUSH
52306: CALL_OW 461
52310: PUSH
52311: LD_INT 6
52313: EQUAL
52314: PUSH
52315: LD_VAR 0 6
52319: PUSH
52320: LD_INT 1
52322: GREATER
52323: AND
52324: IFFALSE 52476
// begin sci := [ ] ;
52326: LD_ADDR_VAR 0 8
52330: PUSH
52331: EMPTY
52332: ST_TO_ADDR
// for x in ( tmp diff j ) do
52333: LD_ADDR_VAR 0 7
52337: PUSH
52338: LD_VAR 0 6
52342: PUSH
52343: LD_VAR 0 3
52347: DIFF
52348: PUSH
52349: FOR_IN
52350: IFFALSE 52402
// begin if sci = 6 then
52352: LD_VAR 0 8
52356: PUSH
52357: LD_INT 6
52359: EQUAL
52360: IFFALSE 52364
// break ;
52362: GO 52402
// if BuildingStatus ( x ) = bs_idle then
52364: LD_VAR 0 7
52368: PPUSH
52369: CALL_OW 461
52373: PUSH
52374: LD_INT 2
52376: EQUAL
52377: IFFALSE 52400
// sci := sci ^ UnitsInside ( x ) ;
52379: LD_ADDR_VAR 0 8
52383: PUSH
52384: LD_VAR 0 8
52388: PUSH
52389: LD_VAR 0 7
52393: PPUSH
52394: CALL_OW 313
52398: ADD
52399: ST_TO_ADDR
// end ;
52400: GO 52349
52402: POP
52403: POP
// if not sci then
52404: LD_VAR 0 8
52408: NOT
52409: IFFALSE 52413
// continue ;
52411: GO 51458
// for x in sci do
52413: LD_ADDR_VAR 0 7
52417: PUSH
52418: LD_VAR 0 8
52422: PUSH
52423: FOR_IN
52424: IFFALSE 52474
// if IsInUnit ( x ) and not HasTask ( x ) then
52426: LD_VAR 0 7
52430: PPUSH
52431: CALL_OW 310
52435: PUSH
52436: LD_VAR 0 7
52440: PPUSH
52441: CALL_OW 314
52445: NOT
52446: AND
52447: IFFALSE 52472
// begin ComExitBuilding ( x ) ;
52449: LD_VAR 0 7
52453: PPUSH
52454: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52458: LD_VAR 0 7
52462: PPUSH
52463: LD_VAR 0 3
52467: PPUSH
52468: CALL_OW 180
// end ;
52472: GO 52423
52474: POP
52475: POP
// end ; end ;
52476: GO 51458
52478: POP
52479: POP
// end ;
52480: GO 51412
52482: POP
52483: POP
// end ;
52484: LD_VAR 0 1
52488: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52489: LD_INT 0
52491: PPUSH
52492: PPUSH
// if not mc_bases then
52493: LD_EXP 113
52497: NOT
52498: IFFALSE 52502
// exit ;
52500: GO 52583
// for i = 1 to mc_bases do
52502: LD_ADDR_VAR 0 2
52506: PUSH
52507: DOUBLE
52508: LD_INT 1
52510: DEC
52511: ST_TO_ADDR
52512: LD_EXP 113
52516: PUSH
52517: FOR_TO
52518: IFFALSE 52581
// if mc_mines [ i ] and mc_miners [ i ] then
52520: LD_EXP 126
52524: PUSH
52525: LD_VAR 0 2
52529: ARRAY
52530: PUSH
52531: LD_EXP 127
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: AND
52542: IFFALSE 52579
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52544: LD_EXP 127
52548: PUSH
52549: LD_VAR 0 2
52553: ARRAY
52554: PUSH
52555: LD_INT 1
52557: ARRAY
52558: PPUSH
52559: CALL_OW 255
52563: PPUSH
52564: LD_EXP 126
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PPUSH
52575: CALL 67139 0 2
52579: GO 52517
52581: POP
52582: POP
// end ;
52583: LD_VAR 0 1
52587: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52588: LD_INT 0
52590: PPUSH
52591: PPUSH
52592: PPUSH
52593: PPUSH
52594: PPUSH
52595: PPUSH
52596: PPUSH
52597: PPUSH
// if not mc_bases or not mc_parking then
52598: LD_EXP 113
52602: NOT
52603: PUSH
52604: LD_EXP 137
52608: NOT
52609: OR
52610: IFFALSE 52614
// exit ;
52612: GO 53313
// for i = 1 to mc_bases do
52614: LD_ADDR_VAR 0 2
52618: PUSH
52619: DOUBLE
52620: LD_INT 1
52622: DEC
52623: ST_TO_ADDR
52624: LD_EXP 113
52628: PUSH
52629: FOR_TO
52630: IFFALSE 53311
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52632: LD_EXP 113
52636: PUSH
52637: LD_VAR 0 2
52641: ARRAY
52642: NOT
52643: PUSH
52644: LD_EXP 137
52648: PUSH
52649: LD_VAR 0 2
52653: ARRAY
52654: NOT
52655: OR
52656: IFFALSE 52660
// continue ;
52658: GO 52629
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52660: LD_ADDR_VAR 0 5
52664: PUSH
52665: LD_EXP 113
52669: PUSH
52670: LD_VAR 0 2
52674: ARRAY
52675: PUSH
52676: LD_INT 1
52678: ARRAY
52679: PPUSH
52680: CALL_OW 255
52684: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52685: LD_ADDR_VAR 0 6
52689: PUSH
52690: LD_EXP 113
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PPUSH
52701: LD_INT 30
52703: PUSH
52704: LD_INT 3
52706: PUSH
52707: EMPTY
52708: LIST
52709: LIST
52710: PPUSH
52711: CALL_OW 72
52715: ST_TO_ADDR
// if not fac then
52716: LD_VAR 0 6
52720: NOT
52721: IFFALSE 52772
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52723: LD_ADDR_VAR 0 6
52727: PUSH
52728: LD_EXP 113
52732: PUSH
52733: LD_VAR 0 2
52737: ARRAY
52738: PPUSH
52739: LD_INT 2
52741: PUSH
52742: LD_INT 30
52744: PUSH
52745: LD_INT 0
52747: PUSH
52748: EMPTY
52749: LIST
52750: LIST
52751: PUSH
52752: LD_INT 30
52754: PUSH
52755: LD_INT 1
52757: PUSH
52758: EMPTY
52759: LIST
52760: LIST
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: LIST
52766: PPUSH
52767: CALL_OW 72
52771: ST_TO_ADDR
// if not fac then
52772: LD_VAR 0 6
52776: NOT
52777: IFFALSE 52781
// continue ;
52779: GO 52629
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52781: LD_ADDR_VAR 0 7
52785: PUSH
52786: LD_EXP 137
52790: PUSH
52791: LD_VAR 0 2
52795: ARRAY
52796: PPUSH
52797: LD_INT 22
52799: PUSH
52800: LD_VAR 0 5
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 21
52811: PUSH
52812: LD_INT 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 3
52821: PUSH
52822: LD_INT 24
52824: PUSH
52825: LD_INT 1000
52827: PUSH
52828: EMPTY
52829: LIST
52830: LIST
52831: PUSH
52832: EMPTY
52833: LIST
52834: LIST
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: LIST
52840: PPUSH
52841: CALL_OW 70
52845: ST_TO_ADDR
// for j in fac do
52846: LD_ADDR_VAR 0 3
52850: PUSH
52851: LD_VAR 0 6
52855: PUSH
52856: FOR_IN
52857: IFFALSE 52938
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52859: LD_ADDR_VAR 0 7
52863: PUSH
52864: LD_VAR 0 7
52868: PUSH
52869: LD_INT 22
52871: PUSH
52872: LD_VAR 0 5
52876: PUSH
52877: EMPTY
52878: LIST
52879: LIST
52880: PUSH
52881: LD_INT 91
52883: PUSH
52884: LD_VAR 0 3
52888: PUSH
52889: LD_INT 15
52891: PUSH
52892: EMPTY
52893: LIST
52894: LIST
52895: LIST
52896: PUSH
52897: LD_INT 21
52899: PUSH
52900: LD_INT 2
52902: PUSH
52903: EMPTY
52904: LIST
52905: LIST
52906: PUSH
52907: LD_INT 3
52909: PUSH
52910: LD_INT 24
52912: PUSH
52913: LD_INT 1000
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: PUSH
52924: EMPTY
52925: LIST
52926: LIST
52927: LIST
52928: LIST
52929: PPUSH
52930: CALL_OW 69
52934: UNION
52935: ST_TO_ADDR
52936: GO 52856
52938: POP
52939: POP
// if not vehs then
52940: LD_VAR 0 7
52944: NOT
52945: IFFALSE 52971
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52947: LD_ADDR_EXP 125
52951: PUSH
52952: LD_EXP 125
52956: PPUSH
52957: LD_VAR 0 2
52961: PPUSH
52962: EMPTY
52963: PPUSH
52964: CALL_OW 1
52968: ST_TO_ADDR
// continue ;
52969: GO 52629
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52971: LD_ADDR_VAR 0 8
52975: PUSH
52976: LD_EXP 113
52980: PUSH
52981: LD_VAR 0 2
52985: ARRAY
52986: PPUSH
52987: LD_INT 30
52989: PUSH
52990: LD_INT 3
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: PPUSH
52997: CALL_OW 72
53001: ST_TO_ADDR
// if tmp then
53002: LD_VAR 0 8
53006: IFFALSE 53109
// begin for j in tmp do
53008: LD_ADDR_VAR 0 3
53012: PUSH
53013: LD_VAR 0 8
53017: PUSH
53018: FOR_IN
53019: IFFALSE 53107
// for k in UnitsInside ( j ) do
53021: LD_ADDR_VAR 0 4
53025: PUSH
53026: LD_VAR 0 3
53030: PPUSH
53031: CALL_OW 313
53035: PUSH
53036: FOR_IN
53037: IFFALSE 53103
// if k then
53039: LD_VAR 0 4
53043: IFFALSE 53101
// if not k in mc_repair_vehicle [ i ] then
53045: LD_VAR 0 4
53049: PUSH
53050: LD_EXP 125
53054: PUSH
53055: LD_VAR 0 2
53059: ARRAY
53060: IN
53061: NOT
53062: IFFALSE 53101
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53064: LD_ADDR_EXP 125
53068: PUSH
53069: LD_EXP 125
53073: PPUSH
53074: LD_VAR 0 2
53078: PPUSH
53079: LD_EXP 125
53083: PUSH
53084: LD_VAR 0 2
53088: ARRAY
53089: PUSH
53090: LD_VAR 0 4
53094: UNION
53095: PPUSH
53096: CALL_OW 1
53100: ST_TO_ADDR
53101: GO 53036
53103: POP
53104: POP
53105: GO 53018
53107: POP
53108: POP
// end ; if not mc_repair_vehicle [ i ] then
53109: LD_EXP 125
53113: PUSH
53114: LD_VAR 0 2
53118: ARRAY
53119: NOT
53120: IFFALSE 53124
// continue ;
53122: GO 52629
// for j in mc_repair_vehicle [ i ] do
53124: LD_ADDR_VAR 0 3
53128: PUSH
53129: LD_EXP 125
53133: PUSH
53134: LD_VAR 0 2
53138: ARRAY
53139: PUSH
53140: FOR_IN
53141: IFFALSE 53307
// begin if GetClass ( j ) <> 3 then
53143: LD_VAR 0 3
53147: PPUSH
53148: CALL_OW 257
53152: PUSH
53153: LD_INT 3
53155: NONEQUAL
53156: IFFALSE 53197
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53158: LD_ADDR_EXP 125
53162: PUSH
53163: LD_EXP 125
53167: PPUSH
53168: LD_VAR 0 2
53172: PPUSH
53173: LD_EXP 125
53177: PUSH
53178: LD_VAR 0 2
53182: ARRAY
53183: PUSH
53184: LD_VAR 0 3
53188: DIFF
53189: PPUSH
53190: CALL_OW 1
53194: ST_TO_ADDR
// continue ;
53195: GO 53140
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53197: LD_VAR 0 3
53201: PPUSH
53202: CALL_OW 311
53206: NOT
53207: PUSH
53208: LD_VAR 0 3
53212: PUSH
53213: LD_EXP 116
53217: PUSH
53218: LD_VAR 0 2
53222: ARRAY
53223: PUSH
53224: LD_INT 1
53226: ARRAY
53227: IN
53228: NOT
53229: AND
53230: PUSH
53231: LD_VAR 0 3
53235: PUSH
53236: LD_EXP 116
53240: PUSH
53241: LD_VAR 0 2
53245: ARRAY
53246: PUSH
53247: LD_INT 2
53249: ARRAY
53250: IN
53251: NOT
53252: AND
53253: IFFALSE 53305
// begin if IsInUnit ( j ) then
53255: LD_VAR 0 3
53259: PPUSH
53260: CALL_OW 310
53264: IFFALSE 53275
// ComExitBuilding ( j ) ;
53266: LD_VAR 0 3
53270: PPUSH
53271: CALL_OW 122
// if not HasTask ( j ) then
53275: LD_VAR 0 3
53279: PPUSH
53280: CALL_OW 314
53284: NOT
53285: IFFALSE 53305
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53287: LD_VAR 0 3
53291: PPUSH
53292: LD_VAR 0 7
53296: PUSH
53297: LD_INT 1
53299: ARRAY
53300: PPUSH
53301: CALL_OW 189
// end ; end ;
53305: GO 53140
53307: POP
53308: POP
// end ;
53309: GO 52629
53311: POP
53312: POP
// end ;
53313: LD_VAR 0 1
53317: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53318: LD_INT 0
53320: PPUSH
53321: PPUSH
53322: PPUSH
53323: PPUSH
53324: PPUSH
53325: PPUSH
53326: PPUSH
53327: PPUSH
53328: PPUSH
53329: PPUSH
53330: PPUSH
// if not mc_bases then
53331: LD_EXP 113
53335: NOT
53336: IFFALSE 53340
// exit ;
53338: GO 54142
// for i = 1 to mc_bases do
53340: LD_ADDR_VAR 0 2
53344: PUSH
53345: DOUBLE
53346: LD_INT 1
53348: DEC
53349: ST_TO_ADDR
53350: LD_EXP 113
53354: PUSH
53355: FOR_TO
53356: IFFALSE 54140
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53358: LD_EXP 141
53362: PUSH
53363: LD_VAR 0 2
53367: ARRAY
53368: NOT
53369: PUSH
53370: LD_EXP 116
53374: PUSH
53375: LD_VAR 0 2
53379: ARRAY
53380: PUSH
53381: LD_INT 1
53383: ARRAY
53384: OR
53385: PUSH
53386: LD_EXP 116
53390: PUSH
53391: LD_VAR 0 2
53395: ARRAY
53396: PUSH
53397: LD_INT 2
53399: ARRAY
53400: OR
53401: PUSH
53402: LD_EXP 139
53406: PUSH
53407: LD_VAR 0 2
53411: ARRAY
53412: PPUSH
53413: LD_INT 1
53415: PPUSH
53416: CALL_OW 325
53420: NOT
53421: OR
53422: PUSH
53423: LD_EXP 136
53427: PUSH
53428: LD_VAR 0 2
53432: ARRAY
53433: OR
53434: IFFALSE 53438
// continue ;
53436: GO 53355
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53438: LD_ADDR_VAR 0 8
53442: PUSH
53443: LD_EXP 113
53447: PUSH
53448: LD_VAR 0 2
53452: ARRAY
53453: PPUSH
53454: LD_INT 25
53456: PUSH
53457: LD_INT 4
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: LD_INT 50
53466: PUSH
53467: EMPTY
53468: LIST
53469: PUSH
53470: LD_INT 3
53472: PUSH
53473: LD_INT 60
53475: PUSH
53476: EMPTY
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: PUSH
53483: EMPTY
53484: LIST
53485: LIST
53486: LIST
53487: PPUSH
53488: CALL_OW 72
53492: PUSH
53493: LD_EXP 117
53497: PUSH
53498: LD_VAR 0 2
53502: ARRAY
53503: DIFF
53504: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53505: LD_ADDR_VAR 0 9
53509: PUSH
53510: LD_EXP 113
53514: PUSH
53515: LD_VAR 0 2
53519: ARRAY
53520: PPUSH
53521: LD_INT 2
53523: PUSH
53524: LD_INT 30
53526: PUSH
53527: LD_INT 0
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PUSH
53534: LD_INT 30
53536: PUSH
53537: LD_INT 1
53539: PUSH
53540: EMPTY
53541: LIST
53542: LIST
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: LIST
53548: PPUSH
53549: CALL_OW 72
53553: ST_TO_ADDR
// if not tmp or not dep then
53554: LD_VAR 0 8
53558: NOT
53559: PUSH
53560: LD_VAR 0 9
53564: NOT
53565: OR
53566: IFFALSE 53570
// continue ;
53568: GO 53355
// side := GetSide ( tmp [ 1 ] ) ;
53570: LD_ADDR_VAR 0 11
53574: PUSH
53575: LD_VAR 0 8
53579: PUSH
53580: LD_INT 1
53582: ARRAY
53583: PPUSH
53584: CALL_OW 255
53588: ST_TO_ADDR
// dep := dep [ 1 ] ;
53589: LD_ADDR_VAR 0 9
53593: PUSH
53594: LD_VAR 0 9
53598: PUSH
53599: LD_INT 1
53601: ARRAY
53602: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53603: LD_ADDR_VAR 0 7
53607: PUSH
53608: LD_EXP 141
53612: PUSH
53613: LD_VAR 0 2
53617: ARRAY
53618: PPUSH
53619: LD_INT 22
53621: PUSH
53622: LD_INT 0
53624: PUSH
53625: EMPTY
53626: LIST
53627: LIST
53628: PUSH
53629: LD_INT 25
53631: PUSH
53632: LD_INT 12
53634: PUSH
53635: EMPTY
53636: LIST
53637: LIST
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: PPUSH
53643: CALL_OW 70
53647: PUSH
53648: LD_INT 22
53650: PUSH
53651: LD_INT 0
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: PUSH
53658: LD_INT 25
53660: PUSH
53661: LD_INT 12
53663: PUSH
53664: EMPTY
53665: LIST
53666: LIST
53667: PUSH
53668: LD_INT 91
53670: PUSH
53671: LD_VAR 0 9
53675: PUSH
53676: LD_INT 20
53678: PUSH
53679: EMPTY
53680: LIST
53681: LIST
53682: LIST
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: LIST
53688: PPUSH
53689: CALL_OW 69
53693: UNION
53694: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53695: LD_ADDR_VAR 0 10
53699: PUSH
53700: LD_EXP 141
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PPUSH
53711: LD_INT 81
53713: PUSH
53714: LD_VAR 0 11
53718: PUSH
53719: EMPTY
53720: LIST
53721: LIST
53722: PPUSH
53723: CALL_OW 70
53727: ST_TO_ADDR
// if not apes or danger_at_area then
53728: LD_VAR 0 7
53732: NOT
53733: PUSH
53734: LD_VAR 0 10
53738: OR
53739: IFFALSE 53789
// begin if mc_taming [ i ] then
53741: LD_EXP 144
53745: PUSH
53746: LD_VAR 0 2
53750: ARRAY
53751: IFFALSE 53787
// begin MC_Reset ( i , 121 ) ;
53753: LD_VAR 0 2
53757: PPUSH
53758: LD_INT 121
53760: PPUSH
53761: CALL 39192 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53765: LD_ADDR_EXP 144
53769: PUSH
53770: LD_EXP 144
53774: PPUSH
53775: LD_VAR 0 2
53779: PPUSH
53780: EMPTY
53781: PPUSH
53782: CALL_OW 1
53786: ST_TO_ADDR
// end ; continue ;
53787: GO 53355
// end ; for j in tmp do
53789: LD_ADDR_VAR 0 3
53793: PUSH
53794: LD_VAR 0 8
53798: PUSH
53799: FOR_IN
53800: IFFALSE 54136
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53802: LD_VAR 0 3
53806: PUSH
53807: LD_EXP 144
53811: PUSH
53812: LD_VAR 0 2
53816: ARRAY
53817: IN
53818: NOT
53819: PUSH
53820: LD_EXP 144
53824: PUSH
53825: LD_VAR 0 2
53829: ARRAY
53830: PUSH
53831: LD_INT 3
53833: LESS
53834: AND
53835: IFFALSE 53893
// begin SetTag ( j , 121 ) ;
53837: LD_VAR 0 3
53841: PPUSH
53842: LD_INT 121
53844: PPUSH
53845: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53849: LD_ADDR_EXP 144
53853: PUSH
53854: LD_EXP 144
53858: PPUSH
53859: LD_VAR 0 2
53863: PUSH
53864: LD_EXP 144
53868: PUSH
53869: LD_VAR 0 2
53873: ARRAY
53874: PUSH
53875: LD_INT 1
53877: PLUS
53878: PUSH
53879: EMPTY
53880: LIST
53881: LIST
53882: PPUSH
53883: LD_VAR 0 3
53887: PPUSH
53888: CALL 70150 0 3
53892: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53893: LD_VAR 0 3
53897: PUSH
53898: LD_EXP 144
53902: PUSH
53903: LD_VAR 0 2
53907: ARRAY
53908: IN
53909: IFFALSE 54134
// begin if GetClass ( j ) <> 4 then
53911: LD_VAR 0 3
53915: PPUSH
53916: CALL_OW 257
53920: PUSH
53921: LD_INT 4
53923: NONEQUAL
53924: IFFALSE 53977
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53926: LD_ADDR_EXP 144
53930: PUSH
53931: LD_EXP 144
53935: PPUSH
53936: LD_VAR 0 2
53940: PPUSH
53941: LD_EXP 144
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: PUSH
53952: LD_VAR 0 3
53956: DIFF
53957: PPUSH
53958: CALL_OW 1
53962: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53963: LD_VAR 0 3
53967: PPUSH
53968: LD_INT 0
53970: PPUSH
53971: CALL_OW 109
// continue ;
53975: GO 53799
// end ; if IsInUnit ( j ) then
53977: LD_VAR 0 3
53981: PPUSH
53982: CALL_OW 310
53986: IFFALSE 53997
// ComExitBuilding ( j ) ;
53988: LD_VAR 0 3
53992: PPUSH
53993: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53997: LD_ADDR_VAR 0 6
54001: PUSH
54002: LD_VAR 0 7
54006: PPUSH
54007: LD_VAR 0 3
54011: PPUSH
54012: CALL_OW 74
54016: ST_TO_ADDR
// if not ape then
54017: LD_VAR 0 6
54021: NOT
54022: IFFALSE 54026
// break ;
54024: GO 54136
// x := GetX ( ape ) ;
54026: LD_ADDR_VAR 0 4
54030: PUSH
54031: LD_VAR 0 6
54035: PPUSH
54036: CALL_OW 250
54040: ST_TO_ADDR
// y := GetY ( ape ) ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 6
54050: PPUSH
54051: CALL_OW 251
54055: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54056: LD_VAR 0 4
54060: PPUSH
54061: LD_VAR 0 5
54065: PPUSH
54066: CALL_OW 488
54070: NOT
54071: PUSH
54072: LD_VAR 0 11
54076: PPUSH
54077: LD_VAR 0 4
54081: PPUSH
54082: LD_VAR 0 5
54086: PPUSH
54087: LD_INT 20
54089: PPUSH
54090: CALL 71046 0 4
54094: PUSH
54095: LD_INT 4
54097: ARRAY
54098: OR
54099: IFFALSE 54103
// break ;
54101: GO 54136
// if not HasTask ( j ) then
54103: LD_VAR 0 3
54107: PPUSH
54108: CALL_OW 314
54112: NOT
54113: IFFALSE 54134
// ComTameXY ( j , x , y ) ;
54115: LD_VAR 0 3
54119: PPUSH
54120: LD_VAR 0 4
54124: PPUSH
54125: LD_VAR 0 5
54129: PPUSH
54130: CALL_OW 131
// end ; end ;
54134: GO 53799
54136: POP
54137: POP
// end ;
54138: GO 53355
54140: POP
54141: POP
// end ;
54142: LD_VAR 0 1
54146: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54147: LD_INT 0
54149: PPUSH
54150: PPUSH
54151: PPUSH
54152: PPUSH
54153: PPUSH
54154: PPUSH
54155: PPUSH
54156: PPUSH
// if not mc_bases then
54157: LD_EXP 113
54161: NOT
54162: IFFALSE 54166
// exit ;
54164: GO 54792
// for i = 1 to mc_bases do
54166: LD_ADDR_VAR 0 2
54170: PUSH
54171: DOUBLE
54172: LD_INT 1
54174: DEC
54175: ST_TO_ADDR
54176: LD_EXP 113
54180: PUSH
54181: FOR_TO
54182: IFFALSE 54790
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54184: LD_EXP 142
54188: PUSH
54189: LD_VAR 0 2
54193: ARRAY
54194: NOT
54195: PUSH
54196: LD_EXP 142
54200: PUSH
54201: LD_VAR 0 2
54205: ARRAY
54206: PPUSH
54207: LD_INT 25
54209: PUSH
54210: LD_INT 12
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PPUSH
54217: CALL_OW 72
54221: NOT
54222: OR
54223: IFFALSE 54227
// continue ;
54225: GO 54181
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54227: LD_ADDR_VAR 0 5
54231: PUSH
54232: LD_EXP 142
54236: PUSH
54237: LD_VAR 0 2
54241: ARRAY
54242: PUSH
54243: LD_INT 1
54245: ARRAY
54246: PPUSH
54247: CALL_OW 255
54251: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54252: LD_VAR 0 5
54256: PPUSH
54257: LD_INT 2
54259: PPUSH
54260: CALL_OW 325
54264: IFFALSE 54517
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54266: LD_ADDR_VAR 0 4
54270: PUSH
54271: LD_EXP 142
54275: PUSH
54276: LD_VAR 0 2
54280: ARRAY
54281: PPUSH
54282: LD_INT 25
54284: PUSH
54285: LD_INT 16
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: PPUSH
54292: CALL_OW 72
54296: ST_TO_ADDR
// if tmp < 6 then
54297: LD_VAR 0 4
54301: PUSH
54302: LD_INT 6
54304: LESS
54305: IFFALSE 54517
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: LD_EXP 113
54316: PUSH
54317: LD_VAR 0 2
54321: ARRAY
54322: PPUSH
54323: LD_INT 2
54325: PUSH
54326: LD_INT 30
54328: PUSH
54329: LD_INT 0
54331: PUSH
54332: EMPTY
54333: LIST
54334: LIST
54335: PUSH
54336: LD_INT 30
54338: PUSH
54339: LD_INT 1
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: LIST
54350: PPUSH
54351: CALL_OW 72
54355: ST_TO_ADDR
// if depot then
54356: LD_VAR 0 6
54360: IFFALSE 54517
// begin selected := 0 ;
54362: LD_ADDR_VAR 0 7
54366: PUSH
54367: LD_INT 0
54369: ST_TO_ADDR
// for j in depot do
54370: LD_ADDR_VAR 0 3
54374: PUSH
54375: LD_VAR 0 6
54379: PUSH
54380: FOR_IN
54381: IFFALSE 54412
// begin if UnitsInside ( j ) < 6 then
54383: LD_VAR 0 3
54387: PPUSH
54388: CALL_OW 313
54392: PUSH
54393: LD_INT 6
54395: LESS
54396: IFFALSE 54410
// begin selected := j ;
54398: LD_ADDR_VAR 0 7
54402: PUSH
54403: LD_VAR 0 3
54407: ST_TO_ADDR
// break ;
54408: GO 54412
// end ; end ;
54410: GO 54380
54412: POP
54413: POP
// if selected then
54414: LD_VAR 0 7
54418: IFFALSE 54517
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54420: LD_ADDR_VAR 0 3
54424: PUSH
54425: LD_EXP 142
54429: PUSH
54430: LD_VAR 0 2
54434: ARRAY
54435: PPUSH
54436: LD_INT 25
54438: PUSH
54439: LD_INT 12
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: PPUSH
54446: CALL_OW 72
54450: PUSH
54451: FOR_IN
54452: IFFALSE 54515
// if not HasTask ( j ) then
54454: LD_VAR 0 3
54458: PPUSH
54459: CALL_OW 314
54463: NOT
54464: IFFALSE 54513
// begin if not IsInUnit ( j ) then
54466: LD_VAR 0 3
54470: PPUSH
54471: CALL_OW 310
54475: NOT
54476: IFFALSE 54492
// ComEnterUnit ( j , selected ) ;
54478: LD_VAR 0 3
54482: PPUSH
54483: LD_VAR 0 7
54487: PPUSH
54488: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54492: LD_VAR 0 3
54496: PPUSH
54497: LD_INT 16
54499: PPUSH
54500: CALL_OW 183
// AddComExitBuilding ( j ) ;
54504: LD_VAR 0 3
54508: PPUSH
54509: CALL_OW 182
// end ;
54513: GO 54451
54515: POP
54516: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54517: LD_VAR 0 5
54521: PPUSH
54522: LD_INT 11
54524: PPUSH
54525: CALL_OW 325
54529: IFFALSE 54788
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54531: LD_ADDR_VAR 0 4
54535: PUSH
54536: LD_EXP 142
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: PPUSH
54547: LD_INT 25
54549: PUSH
54550: LD_INT 16
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: PPUSH
54557: CALL_OW 72
54561: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54562: LD_VAR 0 4
54566: PUSH
54567: LD_INT 6
54569: GREATEREQUAL
54570: PUSH
54571: LD_VAR 0 5
54575: PPUSH
54576: LD_INT 2
54578: PPUSH
54579: CALL_OW 325
54583: NOT
54584: OR
54585: IFFALSE 54788
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54587: LD_ADDR_VAR 0 8
54591: PUSH
54592: LD_EXP 113
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: PPUSH
54603: LD_INT 2
54605: PUSH
54606: LD_INT 30
54608: PUSH
54609: LD_INT 4
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: PUSH
54616: LD_INT 30
54618: PUSH
54619: LD_INT 5
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: LIST
54630: PPUSH
54631: CALL_OW 72
54635: ST_TO_ADDR
// if barracks then
54636: LD_VAR 0 8
54640: IFFALSE 54788
// begin selected := 0 ;
54642: LD_ADDR_VAR 0 7
54646: PUSH
54647: LD_INT 0
54649: ST_TO_ADDR
// for j in barracks do
54650: LD_ADDR_VAR 0 3
54654: PUSH
54655: LD_VAR 0 8
54659: PUSH
54660: FOR_IN
54661: IFFALSE 54692
// begin if UnitsInside ( j ) < 6 then
54663: LD_VAR 0 3
54667: PPUSH
54668: CALL_OW 313
54672: PUSH
54673: LD_INT 6
54675: LESS
54676: IFFALSE 54690
// begin selected := j ;
54678: LD_ADDR_VAR 0 7
54682: PUSH
54683: LD_VAR 0 3
54687: ST_TO_ADDR
// break ;
54688: GO 54692
// end ; end ;
54690: GO 54660
54692: POP
54693: POP
// if selected then
54694: LD_VAR 0 7
54698: IFFALSE 54788
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54700: LD_ADDR_VAR 0 3
54704: PUSH
54705: LD_EXP 142
54709: PUSH
54710: LD_VAR 0 2
54714: ARRAY
54715: PPUSH
54716: LD_INT 25
54718: PUSH
54719: LD_INT 12
54721: PUSH
54722: EMPTY
54723: LIST
54724: LIST
54725: PPUSH
54726: CALL_OW 72
54730: PUSH
54731: FOR_IN
54732: IFFALSE 54786
// if not IsInUnit ( j ) and not HasTask ( j ) then
54734: LD_VAR 0 3
54738: PPUSH
54739: CALL_OW 310
54743: NOT
54744: PUSH
54745: LD_VAR 0 3
54749: PPUSH
54750: CALL_OW 314
54754: NOT
54755: AND
54756: IFFALSE 54784
// begin ComEnterUnit ( j , selected ) ;
54758: LD_VAR 0 3
54762: PPUSH
54763: LD_VAR 0 7
54767: PPUSH
54768: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54772: LD_VAR 0 3
54776: PPUSH
54777: LD_INT 15
54779: PPUSH
54780: CALL_OW 183
// end ;
54784: GO 54731
54786: POP
54787: POP
// end ; end ; end ; end ; end ;
54788: GO 54181
54790: POP
54791: POP
// end ;
54792: LD_VAR 0 1
54796: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54797: LD_INT 0
54799: PPUSH
54800: PPUSH
54801: PPUSH
54802: PPUSH
// if not mc_bases then
54803: LD_EXP 113
54807: NOT
54808: IFFALSE 54812
// exit ;
54810: GO 54990
// for i = 1 to mc_bases do
54812: LD_ADDR_VAR 0 2
54816: PUSH
54817: DOUBLE
54818: LD_INT 1
54820: DEC
54821: ST_TO_ADDR
54822: LD_EXP 113
54826: PUSH
54827: FOR_TO
54828: IFFALSE 54988
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54830: LD_ADDR_VAR 0 4
54834: PUSH
54835: LD_EXP 113
54839: PUSH
54840: LD_VAR 0 2
54844: ARRAY
54845: PPUSH
54846: LD_INT 25
54848: PUSH
54849: LD_INT 9
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: PPUSH
54856: CALL_OW 72
54860: ST_TO_ADDR
// if not tmp then
54861: LD_VAR 0 4
54865: NOT
54866: IFFALSE 54870
// continue ;
54868: GO 54827
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54870: LD_EXP 139
54874: PUSH
54875: LD_VAR 0 2
54879: ARRAY
54880: PPUSH
54881: LD_INT 29
54883: PPUSH
54884: CALL_OW 325
54888: NOT
54889: PUSH
54890: LD_EXP 139
54894: PUSH
54895: LD_VAR 0 2
54899: ARRAY
54900: PPUSH
54901: LD_INT 28
54903: PPUSH
54904: CALL_OW 325
54908: NOT
54909: AND
54910: IFFALSE 54914
// continue ;
54912: GO 54827
// for j in tmp do
54914: LD_ADDR_VAR 0 3
54918: PUSH
54919: LD_VAR 0 4
54923: PUSH
54924: FOR_IN
54925: IFFALSE 54984
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54927: LD_VAR 0 3
54931: PUSH
54932: LD_EXP 116
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: PUSH
54943: LD_INT 1
54945: ARRAY
54946: IN
54947: NOT
54948: PUSH
54949: LD_VAR 0 3
54953: PUSH
54954: LD_EXP 116
54958: PUSH
54959: LD_VAR 0 2
54963: ARRAY
54964: PUSH
54965: LD_INT 2
54967: ARRAY
54968: IN
54969: NOT
54970: AND
54971: IFFALSE 54982
// ComSpaceTimeShoot ( j ) ;
54973: LD_VAR 0 3
54977: PPUSH
54978: CALL 66147 0 1
54982: GO 54924
54984: POP
54985: POP
// end ;
54986: GO 54827
54988: POP
54989: POP
// end ;
54990: LD_VAR 0 1
54994: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54995: LD_INT 0
54997: PPUSH
54998: PPUSH
54999: PPUSH
55000: PPUSH
55001: PPUSH
55002: PPUSH
55003: PPUSH
55004: PPUSH
55005: PPUSH
// if not mc_bases then
55006: LD_EXP 113
55010: NOT
55011: IFFALSE 55015
// exit ;
55013: GO 55637
// for i = 1 to mc_bases do
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: DOUBLE
55021: LD_INT 1
55023: DEC
55024: ST_TO_ADDR
55025: LD_EXP 113
55029: PUSH
55030: FOR_TO
55031: IFFALSE 55635
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55033: LD_EXP 148
55037: PUSH
55038: LD_VAR 0 2
55042: ARRAY
55043: NOT
55044: PUSH
55045: LD_INT 38
55047: PPUSH
55048: LD_EXP 139
55052: PUSH
55053: LD_VAR 0 2
55057: ARRAY
55058: PPUSH
55059: CALL_OW 321
55063: PUSH
55064: LD_INT 2
55066: NONEQUAL
55067: OR
55068: IFFALSE 55072
// continue ;
55070: GO 55030
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55072: LD_ADDR_VAR 0 8
55076: PUSH
55077: LD_EXP 113
55081: PUSH
55082: LD_VAR 0 2
55086: ARRAY
55087: PPUSH
55088: LD_INT 30
55090: PUSH
55091: LD_INT 34
55093: PUSH
55094: EMPTY
55095: LIST
55096: LIST
55097: PPUSH
55098: CALL_OW 72
55102: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55103: LD_ADDR_VAR 0 9
55107: PUSH
55108: LD_EXP 113
55112: PUSH
55113: LD_VAR 0 2
55117: ARRAY
55118: PPUSH
55119: LD_INT 25
55121: PUSH
55122: LD_INT 4
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: PPUSH
55129: CALL_OW 72
55133: PPUSH
55134: LD_INT 0
55136: PPUSH
55137: CALL 98711 0 2
55141: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55142: LD_VAR 0 9
55146: NOT
55147: PUSH
55148: LD_VAR 0 8
55152: NOT
55153: OR
55154: PUSH
55155: LD_EXP 113
55159: PUSH
55160: LD_VAR 0 2
55164: ARRAY
55165: PPUSH
55166: LD_INT 124
55168: PPUSH
55169: CALL 98711 0 2
55173: OR
55174: IFFALSE 55178
// continue ;
55176: GO 55030
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55178: LD_EXP 149
55182: PUSH
55183: LD_VAR 0 2
55187: ARRAY
55188: PUSH
55189: LD_EXP 148
55193: PUSH
55194: LD_VAR 0 2
55198: ARRAY
55199: LESS
55200: PUSH
55201: LD_EXP 149
55205: PUSH
55206: LD_VAR 0 2
55210: ARRAY
55211: PUSH
55212: LD_VAR 0 8
55216: LESS
55217: AND
55218: IFFALSE 55633
// begin tmp := sci [ 1 ] ;
55220: LD_ADDR_VAR 0 7
55224: PUSH
55225: LD_VAR 0 9
55229: PUSH
55230: LD_INT 1
55232: ARRAY
55233: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55234: LD_VAR 0 7
55238: PPUSH
55239: LD_INT 124
55241: PPUSH
55242: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55246: LD_ADDR_VAR 0 3
55250: PUSH
55251: DOUBLE
55252: LD_EXP 148
55256: PUSH
55257: LD_VAR 0 2
55261: ARRAY
55262: INC
55263: ST_TO_ADDR
55264: LD_EXP 148
55268: PUSH
55269: LD_VAR 0 2
55273: ARRAY
55274: PUSH
55275: FOR_DOWNTO
55276: IFFALSE 55619
// begin if IsInUnit ( tmp ) then
55278: LD_VAR 0 7
55282: PPUSH
55283: CALL_OW 310
55287: IFFALSE 55298
// ComExitBuilding ( tmp ) ;
55289: LD_VAR 0 7
55293: PPUSH
55294: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55298: LD_INT 35
55300: PPUSH
55301: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55305: LD_VAR 0 7
55309: PPUSH
55310: CALL_OW 310
55314: NOT
55315: PUSH
55316: LD_VAR 0 7
55320: PPUSH
55321: CALL_OW 314
55325: NOT
55326: AND
55327: IFFALSE 55298
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55329: LD_ADDR_VAR 0 6
55333: PUSH
55334: LD_VAR 0 7
55338: PPUSH
55339: CALL_OW 250
55343: PUSH
55344: LD_VAR 0 7
55348: PPUSH
55349: CALL_OW 251
55353: PUSH
55354: EMPTY
55355: LIST
55356: LIST
55357: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55358: LD_INT 35
55360: PPUSH
55361: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55365: LD_ADDR_VAR 0 4
55369: PUSH
55370: LD_EXP 148
55374: PUSH
55375: LD_VAR 0 2
55379: ARRAY
55380: PUSH
55381: LD_VAR 0 3
55385: ARRAY
55386: PUSH
55387: LD_INT 1
55389: ARRAY
55390: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55391: LD_ADDR_VAR 0 5
55395: PUSH
55396: LD_EXP 148
55400: PUSH
55401: LD_VAR 0 2
55405: ARRAY
55406: PUSH
55407: LD_VAR 0 3
55411: ARRAY
55412: PUSH
55413: LD_INT 2
55415: ARRAY
55416: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55417: LD_VAR 0 7
55421: PPUSH
55422: LD_INT 10
55424: PPUSH
55425: CALL 72743 0 2
55429: PUSH
55430: LD_INT 4
55432: ARRAY
55433: IFFALSE 55471
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55435: LD_VAR 0 7
55439: PPUSH
55440: LD_VAR 0 6
55444: PUSH
55445: LD_INT 1
55447: ARRAY
55448: PPUSH
55449: LD_VAR 0 6
55453: PUSH
55454: LD_INT 2
55456: ARRAY
55457: PPUSH
55458: CALL_OW 111
// wait ( 0 0$10 ) ;
55462: LD_INT 350
55464: PPUSH
55465: CALL_OW 67
// end else
55469: GO 55497
// begin ComMoveXY ( tmp , x , y ) ;
55471: LD_VAR 0 7
55475: PPUSH
55476: LD_VAR 0 4
55480: PPUSH
55481: LD_VAR 0 5
55485: PPUSH
55486: CALL_OW 111
// wait ( 0 0$3 ) ;
55490: LD_INT 105
55492: PPUSH
55493: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55497: LD_VAR 0 7
55501: PPUSH
55502: LD_VAR 0 4
55506: PPUSH
55507: LD_VAR 0 5
55511: PPUSH
55512: CALL_OW 307
55516: IFFALSE 55358
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55518: LD_VAR 0 7
55522: PPUSH
55523: LD_VAR 0 4
55527: PPUSH
55528: LD_VAR 0 5
55532: PPUSH
55533: LD_VAR 0 8
55537: PUSH
55538: LD_VAR 0 3
55542: ARRAY
55543: PPUSH
55544: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55548: LD_INT 35
55550: PPUSH
55551: CALL_OW 67
// until not HasTask ( tmp ) ;
55555: LD_VAR 0 7
55559: PPUSH
55560: CALL_OW 314
55564: NOT
55565: IFFALSE 55548
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55567: LD_ADDR_EXP 149
55571: PUSH
55572: LD_EXP 149
55576: PPUSH
55577: LD_VAR 0 2
55581: PUSH
55582: LD_EXP 149
55586: PUSH
55587: LD_VAR 0 2
55591: ARRAY
55592: PUSH
55593: LD_INT 1
55595: PLUS
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: PPUSH
55601: LD_VAR 0 8
55605: PUSH
55606: LD_VAR 0 3
55610: ARRAY
55611: PPUSH
55612: CALL 70150 0 3
55616: ST_TO_ADDR
// end ;
55617: GO 55275
55619: POP
55620: POP
// MC_Reset ( i , 124 ) ;
55621: LD_VAR 0 2
55625: PPUSH
55626: LD_INT 124
55628: PPUSH
55629: CALL 39192 0 2
// end ; end ;
55633: GO 55030
55635: POP
55636: POP
// end ;
55637: LD_VAR 0 1
55641: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55642: LD_INT 0
55644: PPUSH
55645: PPUSH
55646: PPUSH
// if not mc_bases then
55647: LD_EXP 113
55651: NOT
55652: IFFALSE 55656
// exit ;
55654: GO 56262
// for i = 1 to mc_bases do
55656: LD_ADDR_VAR 0 2
55660: PUSH
55661: DOUBLE
55662: LD_INT 1
55664: DEC
55665: ST_TO_ADDR
55666: LD_EXP 113
55670: PUSH
55671: FOR_TO
55672: IFFALSE 56260
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55674: LD_ADDR_VAR 0 3
55678: PUSH
55679: LD_EXP 113
55683: PUSH
55684: LD_VAR 0 2
55688: ARRAY
55689: PPUSH
55690: LD_INT 25
55692: PUSH
55693: LD_INT 4
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PPUSH
55700: CALL_OW 72
55704: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55705: LD_VAR 0 3
55709: NOT
55710: PUSH
55711: LD_EXP 150
55715: PUSH
55716: LD_VAR 0 2
55720: ARRAY
55721: NOT
55722: OR
55723: PUSH
55724: LD_EXP 113
55728: PUSH
55729: LD_VAR 0 2
55733: ARRAY
55734: PPUSH
55735: LD_INT 2
55737: PUSH
55738: LD_INT 30
55740: PUSH
55741: LD_INT 0
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: PUSH
55748: LD_INT 30
55750: PUSH
55751: LD_INT 1
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: LIST
55762: PPUSH
55763: CALL_OW 72
55767: NOT
55768: OR
55769: IFFALSE 55819
// begin if mc_deposits_finder [ i ] then
55771: LD_EXP 151
55775: PUSH
55776: LD_VAR 0 2
55780: ARRAY
55781: IFFALSE 55817
// begin MC_Reset ( i , 125 ) ;
55783: LD_VAR 0 2
55787: PPUSH
55788: LD_INT 125
55790: PPUSH
55791: CALL 39192 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55795: LD_ADDR_EXP 151
55799: PUSH
55800: LD_EXP 151
55804: PPUSH
55805: LD_VAR 0 2
55809: PPUSH
55810: EMPTY
55811: PPUSH
55812: CALL_OW 1
55816: ST_TO_ADDR
// end ; continue ;
55817: GO 55671
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55819: LD_EXP 150
55823: PUSH
55824: LD_VAR 0 2
55828: ARRAY
55829: PUSH
55830: LD_INT 1
55832: ARRAY
55833: PUSH
55834: LD_INT 3
55836: ARRAY
55837: PUSH
55838: LD_INT 1
55840: EQUAL
55841: PUSH
55842: LD_INT 20
55844: PPUSH
55845: LD_EXP 139
55849: PUSH
55850: LD_VAR 0 2
55854: ARRAY
55855: PPUSH
55856: CALL_OW 321
55860: PUSH
55861: LD_INT 2
55863: NONEQUAL
55864: AND
55865: IFFALSE 55915
// begin if mc_deposits_finder [ i ] then
55867: LD_EXP 151
55871: PUSH
55872: LD_VAR 0 2
55876: ARRAY
55877: IFFALSE 55913
// begin MC_Reset ( i , 125 ) ;
55879: LD_VAR 0 2
55883: PPUSH
55884: LD_INT 125
55886: PPUSH
55887: CALL 39192 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55891: LD_ADDR_EXP 151
55895: PUSH
55896: LD_EXP 151
55900: PPUSH
55901: LD_VAR 0 2
55905: PPUSH
55906: EMPTY
55907: PPUSH
55908: CALL_OW 1
55912: ST_TO_ADDR
// end ; continue ;
55913: GO 55671
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55915: LD_EXP 150
55919: PUSH
55920: LD_VAR 0 2
55924: ARRAY
55925: PUSH
55926: LD_INT 1
55928: ARRAY
55929: PUSH
55930: LD_INT 1
55932: ARRAY
55933: PPUSH
55934: LD_EXP 150
55938: PUSH
55939: LD_VAR 0 2
55943: ARRAY
55944: PUSH
55945: LD_INT 1
55947: ARRAY
55948: PUSH
55949: LD_INT 2
55951: ARRAY
55952: PPUSH
55953: LD_EXP 139
55957: PUSH
55958: LD_VAR 0 2
55962: ARRAY
55963: PPUSH
55964: CALL_OW 440
55968: IFFALSE 56011
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55970: LD_ADDR_EXP 150
55974: PUSH
55975: LD_EXP 150
55979: PPUSH
55980: LD_VAR 0 2
55984: PPUSH
55985: LD_EXP 150
55989: PUSH
55990: LD_VAR 0 2
55994: ARRAY
55995: PPUSH
55996: LD_INT 1
55998: PPUSH
55999: CALL_OW 3
56003: PPUSH
56004: CALL_OW 1
56008: ST_TO_ADDR
56009: GO 56258
// begin if not mc_deposits_finder [ i ] then
56011: LD_EXP 151
56015: PUSH
56016: LD_VAR 0 2
56020: ARRAY
56021: NOT
56022: IFFALSE 56074
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56024: LD_ADDR_EXP 151
56028: PUSH
56029: LD_EXP 151
56033: PPUSH
56034: LD_VAR 0 2
56038: PPUSH
56039: LD_VAR 0 3
56043: PUSH
56044: LD_INT 1
56046: ARRAY
56047: PUSH
56048: EMPTY
56049: LIST
56050: PPUSH
56051: CALL_OW 1
56055: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56056: LD_VAR 0 3
56060: PUSH
56061: LD_INT 1
56063: ARRAY
56064: PPUSH
56065: LD_INT 125
56067: PPUSH
56068: CALL_OW 109
// end else
56072: GO 56258
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56074: LD_EXP 151
56078: PUSH
56079: LD_VAR 0 2
56083: ARRAY
56084: PUSH
56085: LD_INT 1
56087: ARRAY
56088: PPUSH
56089: CALL_OW 310
56093: IFFALSE 56116
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56095: LD_EXP 151
56099: PUSH
56100: LD_VAR 0 2
56104: ARRAY
56105: PUSH
56106: LD_INT 1
56108: ARRAY
56109: PPUSH
56110: CALL_OW 122
56114: GO 56258
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56116: LD_EXP 151
56120: PUSH
56121: LD_VAR 0 2
56125: ARRAY
56126: PUSH
56127: LD_INT 1
56129: ARRAY
56130: PPUSH
56131: CALL_OW 314
56135: NOT
56136: PUSH
56137: LD_EXP 151
56141: PUSH
56142: LD_VAR 0 2
56146: ARRAY
56147: PUSH
56148: LD_INT 1
56150: ARRAY
56151: PPUSH
56152: LD_EXP 150
56156: PUSH
56157: LD_VAR 0 2
56161: ARRAY
56162: PUSH
56163: LD_INT 1
56165: ARRAY
56166: PUSH
56167: LD_INT 1
56169: ARRAY
56170: PPUSH
56171: LD_EXP 150
56175: PUSH
56176: LD_VAR 0 2
56180: ARRAY
56181: PUSH
56182: LD_INT 1
56184: ARRAY
56185: PUSH
56186: LD_INT 2
56188: ARRAY
56189: PPUSH
56190: CALL_OW 297
56194: PUSH
56195: LD_INT 6
56197: GREATER
56198: AND
56199: IFFALSE 56258
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56201: LD_EXP 151
56205: PUSH
56206: LD_VAR 0 2
56210: ARRAY
56211: PUSH
56212: LD_INT 1
56214: ARRAY
56215: PPUSH
56216: LD_EXP 150
56220: PUSH
56221: LD_VAR 0 2
56225: ARRAY
56226: PUSH
56227: LD_INT 1
56229: ARRAY
56230: PUSH
56231: LD_INT 1
56233: ARRAY
56234: PPUSH
56235: LD_EXP 150
56239: PUSH
56240: LD_VAR 0 2
56244: ARRAY
56245: PUSH
56246: LD_INT 1
56248: ARRAY
56249: PUSH
56250: LD_INT 2
56252: ARRAY
56253: PPUSH
56254: CALL_OW 111
// end ; end ; end ;
56258: GO 55671
56260: POP
56261: POP
// end ;
56262: LD_VAR 0 1
56266: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56267: LD_INT 0
56269: PPUSH
56270: PPUSH
56271: PPUSH
56272: PPUSH
56273: PPUSH
56274: PPUSH
56275: PPUSH
56276: PPUSH
56277: PPUSH
56278: PPUSH
56279: PPUSH
// if not mc_bases then
56280: LD_EXP 113
56284: NOT
56285: IFFALSE 56289
// exit ;
56287: GO 57229
// for i = 1 to mc_bases do
56289: LD_ADDR_VAR 0 2
56293: PUSH
56294: DOUBLE
56295: LD_INT 1
56297: DEC
56298: ST_TO_ADDR
56299: LD_EXP 113
56303: PUSH
56304: FOR_TO
56305: IFFALSE 57227
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56307: LD_EXP 113
56311: PUSH
56312: LD_VAR 0 2
56316: ARRAY
56317: NOT
56318: PUSH
56319: LD_EXP 136
56323: PUSH
56324: LD_VAR 0 2
56328: ARRAY
56329: OR
56330: IFFALSE 56334
// continue ;
56332: GO 56304
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56334: LD_ADDR_VAR 0 7
56338: PUSH
56339: LD_EXP 113
56343: PUSH
56344: LD_VAR 0 2
56348: ARRAY
56349: PUSH
56350: LD_INT 1
56352: ARRAY
56353: PPUSH
56354: CALL_OW 248
56358: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56359: LD_VAR 0 7
56363: PUSH
56364: LD_INT 3
56366: EQUAL
56367: PUSH
56368: LD_EXP 132
56372: PUSH
56373: LD_VAR 0 2
56377: ARRAY
56378: PUSH
56379: LD_EXP 135
56383: PUSH
56384: LD_VAR 0 2
56388: ARRAY
56389: UNION
56390: PPUSH
56391: LD_INT 33
56393: PUSH
56394: LD_INT 2
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: PPUSH
56401: CALL_OW 72
56405: NOT
56406: OR
56407: IFFALSE 56411
// continue ;
56409: GO 56304
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56411: LD_ADDR_VAR 0 9
56415: PUSH
56416: LD_EXP 113
56420: PUSH
56421: LD_VAR 0 2
56425: ARRAY
56426: PPUSH
56427: LD_INT 30
56429: PUSH
56430: LD_INT 36
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: PPUSH
56437: CALL_OW 72
56441: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56442: LD_ADDR_VAR 0 10
56446: PUSH
56447: LD_EXP 132
56451: PUSH
56452: LD_VAR 0 2
56456: ARRAY
56457: PPUSH
56458: LD_INT 34
56460: PUSH
56461: LD_INT 31
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: PPUSH
56468: CALL_OW 72
56472: ST_TO_ADDR
// if not cts and not mcts then
56473: LD_VAR 0 9
56477: NOT
56478: PUSH
56479: LD_VAR 0 10
56483: NOT
56484: AND
56485: IFFALSE 56489
// continue ;
56487: GO 56304
// x := cts ;
56489: LD_ADDR_VAR 0 11
56493: PUSH
56494: LD_VAR 0 9
56498: ST_TO_ADDR
// if not x then
56499: LD_VAR 0 11
56503: NOT
56504: IFFALSE 56516
// x := mcts ;
56506: LD_ADDR_VAR 0 11
56510: PUSH
56511: LD_VAR 0 10
56515: ST_TO_ADDR
// if not x then
56516: LD_VAR 0 11
56520: NOT
56521: IFFALSE 56525
// continue ;
56523: GO 56304
// if mc_remote_driver [ i ] then
56525: LD_EXP 153
56529: PUSH
56530: LD_VAR 0 2
56534: ARRAY
56535: IFFALSE 56922
// for j in mc_remote_driver [ i ] do
56537: LD_ADDR_VAR 0 3
56541: PUSH
56542: LD_EXP 153
56546: PUSH
56547: LD_VAR 0 2
56551: ARRAY
56552: PUSH
56553: FOR_IN
56554: IFFALSE 56920
// begin if GetClass ( j ) <> 3 then
56556: LD_VAR 0 3
56560: PPUSH
56561: CALL_OW 257
56565: PUSH
56566: LD_INT 3
56568: NONEQUAL
56569: IFFALSE 56622
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56571: LD_ADDR_EXP 153
56575: PUSH
56576: LD_EXP 153
56580: PPUSH
56581: LD_VAR 0 2
56585: PPUSH
56586: LD_EXP 153
56590: PUSH
56591: LD_VAR 0 2
56595: ARRAY
56596: PUSH
56597: LD_VAR 0 3
56601: DIFF
56602: PPUSH
56603: CALL_OW 1
56607: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56608: LD_VAR 0 3
56612: PPUSH
56613: LD_INT 0
56615: PPUSH
56616: CALL_OW 109
// continue ;
56620: GO 56553
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56622: LD_EXP 132
56626: PUSH
56627: LD_VAR 0 2
56631: ARRAY
56632: PPUSH
56633: LD_INT 34
56635: PUSH
56636: LD_INT 31
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: PUSH
56643: LD_INT 58
56645: PUSH
56646: EMPTY
56647: LIST
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PPUSH
56653: CALL_OW 72
56657: PUSH
56658: LD_VAR 0 3
56662: PPUSH
56663: CALL 98799 0 1
56667: NOT
56668: AND
56669: IFFALSE 56740
// begin if IsInUnit ( j ) then
56671: LD_VAR 0 3
56675: PPUSH
56676: CALL_OW 310
56680: IFFALSE 56691
// ComExitBuilding ( j ) ;
56682: LD_VAR 0 3
56686: PPUSH
56687: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56691: LD_VAR 0 3
56695: PPUSH
56696: LD_EXP 132
56700: PUSH
56701: LD_VAR 0 2
56705: ARRAY
56706: PPUSH
56707: LD_INT 34
56709: PUSH
56710: LD_INT 31
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: PUSH
56717: LD_INT 58
56719: PUSH
56720: EMPTY
56721: LIST
56722: PUSH
56723: EMPTY
56724: LIST
56725: LIST
56726: PPUSH
56727: CALL_OW 72
56731: PUSH
56732: LD_INT 1
56734: ARRAY
56735: PPUSH
56736: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56740: LD_VAR 0 3
56744: PPUSH
56745: CALL_OW 310
56749: NOT
56750: PUSH
56751: LD_VAR 0 3
56755: PPUSH
56756: CALL_OW 310
56760: PPUSH
56761: CALL_OW 266
56765: PUSH
56766: LD_INT 36
56768: NONEQUAL
56769: PUSH
56770: LD_VAR 0 3
56774: PPUSH
56775: CALL 98799 0 1
56779: NOT
56780: AND
56781: OR
56782: IFFALSE 56918
// begin if IsInUnit ( j ) then
56784: LD_VAR 0 3
56788: PPUSH
56789: CALL_OW 310
56793: IFFALSE 56804
// ComExitBuilding ( j ) ;
56795: LD_VAR 0 3
56799: PPUSH
56800: CALL_OW 122
// ct := 0 ;
56804: LD_ADDR_VAR 0 8
56808: PUSH
56809: LD_INT 0
56811: ST_TO_ADDR
// for k in x do
56812: LD_ADDR_VAR 0 4
56816: PUSH
56817: LD_VAR 0 11
56821: PUSH
56822: FOR_IN
56823: IFFALSE 56896
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56825: LD_VAR 0 4
56829: PPUSH
56830: CALL_OW 264
56834: PUSH
56835: LD_INT 31
56837: EQUAL
56838: PUSH
56839: LD_VAR 0 4
56843: PPUSH
56844: CALL_OW 311
56848: NOT
56849: AND
56850: PUSH
56851: LD_VAR 0 4
56855: PPUSH
56856: CALL_OW 266
56860: PUSH
56861: LD_INT 36
56863: EQUAL
56864: PUSH
56865: LD_VAR 0 4
56869: PPUSH
56870: CALL_OW 313
56874: PUSH
56875: LD_INT 3
56877: LESS
56878: AND
56879: OR
56880: IFFALSE 56894
// begin ct := k ;
56882: LD_ADDR_VAR 0 8
56886: PUSH
56887: LD_VAR 0 4
56891: ST_TO_ADDR
// break ;
56892: GO 56896
// end ;
56894: GO 56822
56896: POP
56897: POP
// if ct then
56898: LD_VAR 0 8
56902: IFFALSE 56918
// ComEnterUnit ( j , ct ) ;
56904: LD_VAR 0 3
56908: PPUSH
56909: LD_VAR 0 8
56913: PPUSH
56914: CALL_OW 120
// end ; end ;
56918: GO 56553
56920: POP
56921: POP
// places := 0 ;
56922: LD_ADDR_VAR 0 5
56926: PUSH
56927: LD_INT 0
56929: ST_TO_ADDR
// for j = 1 to x do
56930: LD_ADDR_VAR 0 3
56934: PUSH
56935: DOUBLE
56936: LD_INT 1
56938: DEC
56939: ST_TO_ADDR
56940: LD_VAR 0 11
56944: PUSH
56945: FOR_TO
56946: IFFALSE 57022
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56948: LD_VAR 0 11
56952: PUSH
56953: LD_VAR 0 3
56957: ARRAY
56958: PPUSH
56959: CALL_OW 264
56963: PUSH
56964: LD_INT 31
56966: EQUAL
56967: IFFALSE 56985
// places := places + 1 else
56969: LD_ADDR_VAR 0 5
56973: PUSH
56974: LD_VAR 0 5
56978: PUSH
56979: LD_INT 1
56981: PLUS
56982: ST_TO_ADDR
56983: GO 57020
// if GetBType ( x [ j ] ) = b_control_tower then
56985: LD_VAR 0 11
56989: PUSH
56990: LD_VAR 0 3
56994: ARRAY
56995: PPUSH
56996: CALL_OW 266
57000: PUSH
57001: LD_INT 36
57003: EQUAL
57004: IFFALSE 57020
// places := places + 3 ;
57006: LD_ADDR_VAR 0 5
57010: PUSH
57011: LD_VAR 0 5
57015: PUSH
57016: LD_INT 3
57018: PLUS
57019: ST_TO_ADDR
57020: GO 56945
57022: POP
57023: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57024: LD_VAR 0 5
57028: PUSH
57029: LD_INT 0
57031: EQUAL
57032: PUSH
57033: LD_VAR 0 5
57037: PUSH
57038: LD_EXP 153
57042: PUSH
57043: LD_VAR 0 2
57047: ARRAY
57048: LESSEQUAL
57049: OR
57050: IFFALSE 57054
// continue ;
57052: GO 56304
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57054: LD_ADDR_VAR 0 6
57058: PUSH
57059: LD_EXP 113
57063: PUSH
57064: LD_VAR 0 2
57068: ARRAY
57069: PPUSH
57070: LD_INT 25
57072: PUSH
57073: LD_INT 3
57075: PUSH
57076: EMPTY
57077: LIST
57078: LIST
57079: PPUSH
57080: CALL_OW 72
57084: PUSH
57085: LD_EXP 153
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: DIFF
57096: PPUSH
57097: LD_INT 3
57099: PPUSH
57100: CALL 99699 0 2
57104: ST_TO_ADDR
// for j in tmp do
57105: LD_ADDR_VAR 0 3
57109: PUSH
57110: LD_VAR 0 6
57114: PUSH
57115: FOR_IN
57116: IFFALSE 57151
// if GetTag ( j ) > 0 then
57118: LD_VAR 0 3
57122: PPUSH
57123: CALL_OW 110
57127: PUSH
57128: LD_INT 0
57130: GREATER
57131: IFFALSE 57149
// tmp := tmp diff j ;
57133: LD_ADDR_VAR 0 6
57137: PUSH
57138: LD_VAR 0 6
57142: PUSH
57143: LD_VAR 0 3
57147: DIFF
57148: ST_TO_ADDR
57149: GO 57115
57151: POP
57152: POP
// if not tmp then
57153: LD_VAR 0 6
57157: NOT
57158: IFFALSE 57162
// continue ;
57160: GO 56304
// if places then
57162: LD_VAR 0 5
57166: IFFALSE 57225
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57168: LD_ADDR_EXP 153
57172: PUSH
57173: LD_EXP 153
57177: PPUSH
57178: LD_VAR 0 2
57182: PPUSH
57183: LD_EXP 153
57187: PUSH
57188: LD_VAR 0 2
57192: ARRAY
57193: PUSH
57194: LD_VAR 0 6
57198: PUSH
57199: LD_INT 1
57201: ARRAY
57202: UNION
57203: PPUSH
57204: CALL_OW 1
57208: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57209: LD_VAR 0 6
57213: PUSH
57214: LD_INT 1
57216: ARRAY
57217: PPUSH
57218: LD_INT 126
57220: PPUSH
57221: CALL_OW 109
// end ; end ;
57225: GO 56304
57227: POP
57228: POP
// end ;
57229: LD_VAR 0 1
57233: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57234: LD_INT 0
57236: PPUSH
57237: PPUSH
57238: PPUSH
57239: PPUSH
57240: PPUSH
57241: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57242: LD_VAR 0 1
57246: NOT
57247: PUSH
57248: LD_VAR 0 2
57252: NOT
57253: OR
57254: PUSH
57255: LD_VAR 0 3
57259: NOT
57260: OR
57261: PUSH
57262: LD_VAR 0 4
57266: PUSH
57267: LD_INT 1
57269: PUSH
57270: LD_INT 2
57272: PUSH
57273: LD_INT 3
57275: PUSH
57276: LD_INT 4
57278: PUSH
57279: LD_INT 5
57281: PUSH
57282: LD_INT 8
57284: PUSH
57285: LD_INT 9
57287: PUSH
57288: LD_INT 15
57290: PUSH
57291: LD_INT 16
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: LIST
57298: LIST
57299: LIST
57300: LIST
57301: LIST
57302: LIST
57303: LIST
57304: IN
57305: NOT
57306: OR
57307: IFFALSE 57311
// exit ;
57309: GO 58211
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57311: LD_ADDR_VAR 0 2
57315: PUSH
57316: LD_VAR 0 2
57320: PPUSH
57321: LD_INT 21
57323: PUSH
57324: LD_INT 3
57326: PUSH
57327: EMPTY
57328: LIST
57329: LIST
57330: PUSH
57331: LD_INT 24
57333: PUSH
57334: LD_INT 250
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: PPUSH
57345: CALL_OW 72
57349: ST_TO_ADDR
// case class of 1 , 15 :
57350: LD_VAR 0 4
57354: PUSH
57355: LD_INT 1
57357: DOUBLE
57358: EQUAL
57359: IFTRUE 57369
57361: LD_INT 15
57363: DOUBLE
57364: EQUAL
57365: IFTRUE 57369
57367: GO 57454
57369: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57370: LD_ADDR_VAR 0 8
57374: PUSH
57375: LD_VAR 0 2
57379: PPUSH
57380: LD_INT 2
57382: PUSH
57383: LD_INT 30
57385: PUSH
57386: LD_INT 32
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PUSH
57393: LD_INT 30
57395: PUSH
57396: LD_INT 31
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: PUSH
57403: EMPTY
57404: LIST
57405: LIST
57406: LIST
57407: PPUSH
57408: CALL_OW 72
57412: PUSH
57413: LD_VAR 0 2
57417: PPUSH
57418: LD_INT 2
57420: PUSH
57421: LD_INT 30
57423: PUSH
57424: LD_INT 4
57426: PUSH
57427: EMPTY
57428: LIST
57429: LIST
57430: PUSH
57431: LD_INT 30
57433: PUSH
57434: LD_INT 5
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: LIST
57445: PPUSH
57446: CALL_OW 72
57450: ADD
57451: ST_TO_ADDR
57452: GO 57700
57454: LD_INT 2
57456: DOUBLE
57457: EQUAL
57458: IFTRUE 57468
57460: LD_INT 16
57462: DOUBLE
57463: EQUAL
57464: IFTRUE 57468
57466: GO 57514
57468: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57469: LD_ADDR_VAR 0 8
57473: PUSH
57474: LD_VAR 0 2
57478: PPUSH
57479: LD_INT 2
57481: PUSH
57482: LD_INT 30
57484: PUSH
57485: LD_INT 0
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: PUSH
57492: LD_INT 30
57494: PUSH
57495: LD_INT 1
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: LIST
57506: PPUSH
57507: CALL_OW 72
57511: ST_TO_ADDR
57512: GO 57700
57514: LD_INT 3
57516: DOUBLE
57517: EQUAL
57518: IFTRUE 57522
57520: GO 57568
57522: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57523: LD_ADDR_VAR 0 8
57527: PUSH
57528: LD_VAR 0 2
57532: PPUSH
57533: LD_INT 2
57535: PUSH
57536: LD_INT 30
57538: PUSH
57539: LD_INT 2
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: PUSH
57546: LD_INT 30
57548: PUSH
57549: LD_INT 3
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: LIST
57560: PPUSH
57561: CALL_OW 72
57565: ST_TO_ADDR
57566: GO 57700
57568: LD_INT 4
57570: DOUBLE
57571: EQUAL
57572: IFTRUE 57576
57574: GO 57633
57576: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57577: LD_ADDR_VAR 0 8
57581: PUSH
57582: LD_VAR 0 2
57586: PPUSH
57587: LD_INT 2
57589: PUSH
57590: LD_INT 30
57592: PUSH
57593: LD_INT 6
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: PUSH
57600: LD_INT 30
57602: PUSH
57603: LD_INT 7
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: PUSH
57610: LD_INT 30
57612: PUSH
57613: LD_INT 8
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: LIST
57624: LIST
57625: PPUSH
57626: CALL_OW 72
57630: ST_TO_ADDR
57631: GO 57700
57633: LD_INT 5
57635: DOUBLE
57636: EQUAL
57637: IFTRUE 57653
57639: LD_INT 8
57641: DOUBLE
57642: EQUAL
57643: IFTRUE 57653
57645: LD_INT 9
57647: DOUBLE
57648: EQUAL
57649: IFTRUE 57653
57651: GO 57699
57653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57654: LD_ADDR_VAR 0 8
57658: PUSH
57659: LD_VAR 0 2
57663: PPUSH
57664: LD_INT 2
57666: PUSH
57667: LD_INT 30
57669: PUSH
57670: LD_INT 4
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: PUSH
57677: LD_INT 30
57679: PUSH
57680: LD_INT 5
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: PUSH
57687: EMPTY
57688: LIST
57689: LIST
57690: LIST
57691: PPUSH
57692: CALL_OW 72
57696: ST_TO_ADDR
57697: GO 57700
57699: POP
// if not tmp then
57700: LD_VAR 0 8
57704: NOT
57705: IFFALSE 57709
// exit ;
57707: GO 58211
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57709: LD_VAR 0 4
57713: PUSH
57714: LD_INT 1
57716: PUSH
57717: LD_INT 15
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: IN
57724: PUSH
57725: LD_EXP 122
57729: PUSH
57730: LD_VAR 0 1
57734: ARRAY
57735: AND
57736: IFFALSE 57892
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57738: LD_ADDR_VAR 0 9
57742: PUSH
57743: LD_EXP 122
57747: PUSH
57748: LD_VAR 0 1
57752: ARRAY
57753: PUSH
57754: LD_INT 1
57756: ARRAY
57757: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57758: LD_VAR 0 9
57762: PUSH
57763: LD_EXP 123
57767: PUSH
57768: LD_VAR 0 1
57772: ARRAY
57773: IN
57774: NOT
57775: IFFALSE 57890
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57777: LD_ADDR_EXP 123
57781: PUSH
57782: LD_EXP 123
57786: PPUSH
57787: LD_VAR 0 1
57791: PUSH
57792: LD_EXP 123
57796: PUSH
57797: LD_VAR 0 1
57801: ARRAY
57802: PUSH
57803: LD_INT 1
57805: PLUS
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PPUSH
57811: LD_VAR 0 9
57815: PPUSH
57816: CALL 70150 0 3
57820: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57821: LD_ADDR_EXP 122
57825: PUSH
57826: LD_EXP 122
57830: PPUSH
57831: LD_VAR 0 1
57835: PPUSH
57836: LD_EXP 122
57840: PUSH
57841: LD_VAR 0 1
57845: ARRAY
57846: PUSH
57847: LD_VAR 0 9
57851: DIFF
57852: PPUSH
57853: CALL_OW 1
57857: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57858: LD_VAR 0 3
57862: PPUSH
57863: LD_EXP 123
57867: PUSH
57868: LD_VAR 0 1
57872: ARRAY
57873: PUSH
57874: LD_EXP 123
57878: PUSH
57879: LD_VAR 0 1
57883: ARRAY
57884: ARRAY
57885: PPUSH
57886: CALL_OW 120
// end ; exit ;
57890: GO 58211
// end ; if tmp > 1 then
57892: LD_VAR 0 8
57896: PUSH
57897: LD_INT 1
57899: GREATER
57900: IFFALSE 58004
// for i = 2 to tmp do
57902: LD_ADDR_VAR 0 6
57906: PUSH
57907: DOUBLE
57908: LD_INT 2
57910: DEC
57911: ST_TO_ADDR
57912: LD_VAR 0 8
57916: PUSH
57917: FOR_TO
57918: IFFALSE 58002
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57920: LD_VAR 0 8
57924: PUSH
57925: LD_VAR 0 6
57929: ARRAY
57930: PPUSH
57931: CALL_OW 461
57935: PUSH
57936: LD_INT 6
57938: EQUAL
57939: IFFALSE 58000
// begin x := tmp [ i ] ;
57941: LD_ADDR_VAR 0 9
57945: PUSH
57946: LD_VAR 0 8
57950: PUSH
57951: LD_VAR 0 6
57955: ARRAY
57956: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57957: LD_ADDR_VAR 0 8
57961: PUSH
57962: LD_VAR 0 8
57966: PPUSH
57967: LD_VAR 0 6
57971: PPUSH
57972: CALL_OW 3
57976: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57977: LD_ADDR_VAR 0 8
57981: PUSH
57982: LD_VAR 0 8
57986: PPUSH
57987: LD_INT 1
57989: PPUSH
57990: LD_VAR 0 9
57994: PPUSH
57995: CALL_OW 2
57999: ST_TO_ADDR
// end ;
58000: GO 57917
58002: POP
58003: POP
// for i in tmp do
58004: LD_ADDR_VAR 0 6
58008: PUSH
58009: LD_VAR 0 8
58013: PUSH
58014: FOR_IN
58015: IFFALSE 58084
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58017: LD_VAR 0 6
58021: PPUSH
58022: CALL_OW 313
58026: PUSH
58027: LD_INT 6
58029: LESS
58030: PUSH
58031: LD_VAR 0 6
58035: PPUSH
58036: CALL_OW 266
58040: PUSH
58041: LD_INT 31
58043: PUSH
58044: LD_INT 32
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: IN
58051: NOT
58052: AND
58053: PUSH
58054: LD_VAR 0 6
58058: PPUSH
58059: CALL_OW 313
58063: PUSH
58064: LD_INT 0
58066: EQUAL
58067: OR
58068: IFFALSE 58082
// begin j := i ;
58070: LD_ADDR_VAR 0 7
58074: PUSH
58075: LD_VAR 0 6
58079: ST_TO_ADDR
// break ;
58080: GO 58084
// end ; end ;
58082: GO 58014
58084: POP
58085: POP
// if j then
58086: LD_VAR 0 7
58090: IFFALSE 58108
// ComEnterUnit ( unit , j ) else
58092: LD_VAR 0 3
58096: PPUSH
58097: LD_VAR 0 7
58101: PPUSH
58102: CALL_OW 120
58106: GO 58211
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58108: LD_ADDR_VAR 0 10
58112: PUSH
58113: LD_VAR 0 2
58117: PPUSH
58118: LD_INT 2
58120: PUSH
58121: LD_INT 30
58123: PUSH
58124: LD_INT 0
58126: PUSH
58127: EMPTY
58128: LIST
58129: LIST
58130: PUSH
58131: LD_INT 30
58133: PUSH
58134: LD_INT 1
58136: PUSH
58137: EMPTY
58138: LIST
58139: LIST
58140: PUSH
58141: EMPTY
58142: LIST
58143: LIST
58144: LIST
58145: PPUSH
58146: CALL_OW 72
58150: ST_TO_ADDR
// if depot then
58151: LD_VAR 0 10
58155: IFFALSE 58211
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58157: LD_ADDR_VAR 0 10
58161: PUSH
58162: LD_VAR 0 10
58166: PPUSH
58167: LD_VAR 0 3
58171: PPUSH
58172: CALL_OW 74
58176: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58177: LD_VAR 0 3
58181: PPUSH
58182: LD_VAR 0 10
58186: PPUSH
58187: CALL_OW 296
58191: PUSH
58192: LD_INT 10
58194: GREATER
58195: IFFALSE 58211
// ComStandNearbyBuilding ( unit , depot ) ;
58197: LD_VAR 0 3
58201: PPUSH
58202: LD_VAR 0 10
58206: PPUSH
58207: CALL 66764 0 2
// end ; end ; end ;
58211: LD_VAR 0 5
58215: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58216: LD_INT 0
58218: PPUSH
58219: PPUSH
58220: PPUSH
58221: PPUSH
// if not mc_bases then
58222: LD_EXP 113
58226: NOT
58227: IFFALSE 58231
// exit ;
58229: GO 58470
// for i = 1 to mc_bases do
58231: LD_ADDR_VAR 0 2
58235: PUSH
58236: DOUBLE
58237: LD_INT 1
58239: DEC
58240: ST_TO_ADDR
58241: LD_EXP 113
58245: PUSH
58246: FOR_TO
58247: IFFALSE 58468
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58249: LD_ADDR_VAR 0 4
58253: PUSH
58254: LD_EXP 113
58258: PUSH
58259: LD_VAR 0 2
58263: ARRAY
58264: PPUSH
58265: LD_INT 21
58267: PUSH
58268: LD_INT 1
58270: PUSH
58271: EMPTY
58272: LIST
58273: LIST
58274: PPUSH
58275: CALL_OW 72
58279: PUSH
58280: LD_EXP 142
58284: PUSH
58285: LD_VAR 0 2
58289: ARRAY
58290: UNION
58291: ST_TO_ADDR
// if not tmp then
58292: LD_VAR 0 4
58296: NOT
58297: IFFALSE 58301
// continue ;
58299: GO 58246
// for j in tmp do
58301: LD_ADDR_VAR 0 3
58305: PUSH
58306: LD_VAR 0 4
58310: PUSH
58311: FOR_IN
58312: IFFALSE 58464
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58314: LD_VAR 0 3
58318: PPUSH
58319: CALL_OW 110
58323: NOT
58324: PUSH
58325: LD_VAR 0 3
58329: PPUSH
58330: CALL_OW 314
58334: NOT
58335: AND
58336: PUSH
58337: LD_VAR 0 3
58341: PPUSH
58342: CALL_OW 311
58346: NOT
58347: AND
58348: PUSH
58349: LD_VAR 0 3
58353: PPUSH
58354: CALL_OW 310
58358: NOT
58359: AND
58360: PUSH
58361: LD_VAR 0 3
58365: PUSH
58366: LD_EXP 116
58370: PUSH
58371: LD_VAR 0 2
58375: ARRAY
58376: PUSH
58377: LD_INT 1
58379: ARRAY
58380: IN
58381: NOT
58382: AND
58383: PUSH
58384: LD_VAR 0 3
58388: PUSH
58389: LD_EXP 116
58393: PUSH
58394: LD_VAR 0 2
58398: ARRAY
58399: PUSH
58400: LD_INT 2
58402: ARRAY
58403: IN
58404: NOT
58405: AND
58406: PUSH
58407: LD_VAR 0 3
58411: PUSH
58412: LD_EXP 125
58416: PUSH
58417: LD_VAR 0 2
58421: ARRAY
58422: IN
58423: NOT
58424: AND
58425: IFFALSE 58462
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58427: LD_VAR 0 2
58431: PPUSH
58432: LD_EXP 113
58436: PUSH
58437: LD_VAR 0 2
58441: ARRAY
58442: PPUSH
58443: LD_VAR 0 3
58447: PPUSH
58448: LD_VAR 0 3
58452: PPUSH
58453: CALL_OW 257
58457: PPUSH
58458: CALL 57234 0 4
// end ;
58462: GO 58311
58464: POP
58465: POP
// end ;
58466: GO 58246
58468: POP
58469: POP
// end ;
58470: LD_VAR 0 1
58474: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58475: LD_INT 0
58477: PPUSH
58478: PPUSH
58479: PPUSH
58480: PPUSH
58481: PPUSH
58482: PPUSH
// if not mc_bases [ base ] then
58483: LD_EXP 113
58487: PUSH
58488: LD_VAR 0 1
58492: ARRAY
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58680
// tmp := [ ] ;
58498: LD_ADDR_VAR 0 6
58502: PUSH
58503: EMPTY
58504: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58505: LD_ADDR_VAR 0 7
58509: PUSH
58510: LD_VAR 0 3
58514: PPUSH
58515: LD_INT 0
58517: PPUSH
58518: CALL_OW 517
58522: ST_TO_ADDR
// if not list then
58523: LD_VAR 0 7
58527: NOT
58528: IFFALSE 58532
// exit ;
58530: GO 58680
// for i = 1 to amount do
58532: LD_ADDR_VAR 0 5
58536: PUSH
58537: DOUBLE
58538: LD_INT 1
58540: DEC
58541: ST_TO_ADDR
58542: LD_VAR 0 2
58546: PUSH
58547: FOR_TO
58548: IFFALSE 58628
// begin x := rand ( 1 , list [ 1 ] ) ;
58550: LD_ADDR_VAR 0 8
58554: PUSH
58555: LD_INT 1
58557: PPUSH
58558: LD_VAR 0 7
58562: PUSH
58563: LD_INT 1
58565: ARRAY
58566: PPUSH
58567: CALL_OW 12
58571: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58572: LD_ADDR_VAR 0 6
58576: PUSH
58577: LD_VAR 0 6
58581: PPUSH
58582: LD_VAR 0 5
58586: PPUSH
58587: LD_VAR 0 7
58591: PUSH
58592: LD_INT 1
58594: ARRAY
58595: PUSH
58596: LD_VAR 0 8
58600: ARRAY
58601: PUSH
58602: LD_VAR 0 7
58606: PUSH
58607: LD_INT 2
58609: ARRAY
58610: PUSH
58611: LD_VAR 0 8
58615: ARRAY
58616: PUSH
58617: EMPTY
58618: LIST
58619: LIST
58620: PPUSH
58621: CALL_OW 1
58625: ST_TO_ADDR
// end ;
58626: GO 58547
58628: POP
58629: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58630: LD_ADDR_EXP 126
58634: PUSH
58635: LD_EXP 126
58639: PPUSH
58640: LD_VAR 0 1
58644: PPUSH
58645: LD_VAR 0 6
58649: PPUSH
58650: CALL_OW 1
58654: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58655: LD_ADDR_EXP 128
58659: PUSH
58660: LD_EXP 128
58664: PPUSH
58665: LD_VAR 0 1
58669: PPUSH
58670: LD_VAR 0 3
58674: PPUSH
58675: CALL_OW 1
58679: ST_TO_ADDR
// end ;
58680: LD_VAR 0 4
58684: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58685: LD_INT 0
58687: PPUSH
// if not mc_bases [ base ] then
58688: LD_EXP 113
58692: PUSH
58693: LD_VAR 0 1
58697: ARRAY
58698: NOT
58699: IFFALSE 58703
// exit ;
58701: GO 58728
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58703: LD_ADDR_EXP 118
58707: PUSH
58708: LD_EXP 118
58712: PPUSH
58713: LD_VAR 0 1
58717: PPUSH
58718: LD_VAR 0 2
58722: PPUSH
58723: CALL_OW 1
58727: ST_TO_ADDR
// end ;
58728: LD_VAR 0 3
58732: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58733: LD_INT 0
58735: PPUSH
// if not mc_bases [ base ] then
58736: LD_EXP 113
58740: PUSH
58741: LD_VAR 0 1
58745: ARRAY
58746: NOT
58747: IFFALSE 58751
// exit ;
58749: GO 58788
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58751: LD_ADDR_EXP 118
58755: PUSH
58756: LD_EXP 118
58760: PPUSH
58761: LD_VAR 0 1
58765: PPUSH
58766: LD_EXP 118
58770: PUSH
58771: LD_VAR 0 1
58775: ARRAY
58776: PUSH
58777: LD_VAR 0 2
58781: UNION
58782: PPUSH
58783: CALL_OW 1
58787: ST_TO_ADDR
// end ;
58788: LD_VAR 0 3
58792: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58793: LD_INT 0
58795: PPUSH
// if not mc_bases [ base ] then
58796: LD_EXP 113
58800: PUSH
58801: LD_VAR 0 1
58805: ARRAY
58806: NOT
58807: IFFALSE 58811
// exit ;
58809: GO 58836
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58811: LD_ADDR_EXP 134
58815: PUSH
58816: LD_EXP 134
58820: PPUSH
58821: LD_VAR 0 1
58825: PPUSH
58826: LD_VAR 0 2
58830: PPUSH
58831: CALL_OW 1
58835: ST_TO_ADDR
// end ;
58836: LD_VAR 0 3
58840: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58841: LD_INT 0
58843: PPUSH
// if not mc_bases [ base ] then
58844: LD_EXP 113
58848: PUSH
58849: LD_VAR 0 1
58853: ARRAY
58854: NOT
58855: IFFALSE 58859
// exit ;
58857: GO 58896
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58859: LD_ADDR_EXP 134
58863: PUSH
58864: LD_EXP 134
58868: PPUSH
58869: LD_VAR 0 1
58873: PPUSH
58874: LD_EXP 134
58878: PUSH
58879: LD_VAR 0 1
58883: ARRAY
58884: PUSH
58885: LD_VAR 0 2
58889: ADD
58890: PPUSH
58891: CALL_OW 1
58895: ST_TO_ADDR
// end ;
58896: LD_VAR 0 3
58900: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58901: LD_INT 0
58903: PPUSH
// if not mc_bases [ base ] then
58904: LD_EXP 113
58908: PUSH
58909: LD_VAR 0 1
58913: ARRAY
58914: NOT
58915: IFFALSE 58919
// exit ;
58917: GO 58973
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58919: LD_ADDR_EXP 135
58923: PUSH
58924: LD_EXP 135
58928: PPUSH
58929: LD_VAR 0 1
58933: PPUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: CALL_OW 1
58943: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58944: LD_ADDR_EXP 124
58948: PUSH
58949: LD_EXP 124
58953: PPUSH
58954: LD_VAR 0 1
58958: PPUSH
58959: LD_VAR 0 2
58963: PUSH
58964: LD_INT 0
58966: PLUS
58967: PPUSH
58968: CALL_OW 1
58972: ST_TO_ADDR
// end ;
58973: LD_VAR 0 3
58977: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58978: LD_INT 0
58980: PPUSH
// if not mc_bases [ base ] then
58981: LD_EXP 113
58985: PUSH
58986: LD_VAR 0 1
58990: ARRAY
58991: NOT
58992: IFFALSE 58996
// exit ;
58994: GO 59021
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58996: LD_ADDR_EXP 124
59000: PUSH
59001: LD_EXP 124
59005: PPUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: LD_VAR 0 2
59015: PPUSH
59016: CALL_OW 1
59020: ST_TO_ADDR
// end ;
59021: LD_VAR 0 3
59025: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59026: LD_INT 0
59028: PPUSH
59029: PPUSH
59030: PPUSH
59031: PPUSH
// if not mc_bases [ base ] then
59032: LD_EXP 113
59036: PUSH
59037: LD_VAR 0 1
59041: ARRAY
59042: NOT
59043: IFFALSE 59047
// exit ;
59045: GO 59112
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59047: LD_ADDR_EXP 133
59051: PUSH
59052: LD_EXP 133
59056: PPUSH
59057: LD_VAR 0 1
59061: PUSH
59062: LD_EXP 133
59066: PUSH
59067: LD_VAR 0 1
59071: ARRAY
59072: PUSH
59073: LD_INT 1
59075: PLUS
59076: PUSH
59077: EMPTY
59078: LIST
59079: LIST
59080: PPUSH
59081: LD_VAR 0 1
59085: PUSH
59086: LD_VAR 0 2
59090: PUSH
59091: LD_VAR 0 3
59095: PUSH
59096: LD_VAR 0 4
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: LIST
59105: LIST
59106: PPUSH
59107: CALL 70150 0 3
59111: ST_TO_ADDR
// end ;
59112: LD_VAR 0 5
59116: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59117: LD_INT 0
59119: PPUSH
// if not mc_bases [ base ] then
59120: LD_EXP 113
59124: PUSH
59125: LD_VAR 0 1
59129: ARRAY
59130: NOT
59131: IFFALSE 59135
// exit ;
59133: GO 59160
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59135: LD_ADDR_EXP 150
59139: PUSH
59140: LD_EXP 150
59144: PPUSH
59145: LD_VAR 0 1
59149: PPUSH
59150: LD_VAR 0 2
59154: PPUSH
59155: CALL_OW 1
59159: ST_TO_ADDR
// end ;
59160: LD_VAR 0 3
59164: RET
// export function MC_GetMinesField ( base ) ; begin
59165: LD_INT 0
59167: PPUSH
// result := mc_mines [ base ] ;
59168: LD_ADDR_VAR 0 2
59172: PUSH
59173: LD_EXP 126
59177: PUSH
59178: LD_VAR 0 1
59182: ARRAY
59183: ST_TO_ADDR
// end ;
59184: LD_VAR 0 2
59188: RET
// export function MC_GetProduceList ( base ) ; begin
59189: LD_INT 0
59191: PPUSH
// result := mc_produce [ base ] ;
59192: LD_ADDR_VAR 0 2
59196: PUSH
59197: LD_EXP 134
59201: PUSH
59202: LD_VAR 0 1
59206: ARRAY
59207: ST_TO_ADDR
// end ;
59208: LD_VAR 0 2
59212: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59213: LD_INT 0
59215: PPUSH
59216: PPUSH
// if not mc_bases then
59217: LD_EXP 113
59221: NOT
59222: IFFALSE 59226
// exit ;
59224: GO 59291
// if mc_bases [ base ] then
59226: LD_EXP 113
59230: PUSH
59231: LD_VAR 0 1
59235: ARRAY
59236: IFFALSE 59291
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59238: LD_ADDR_VAR 0 3
59242: PUSH
59243: LD_EXP 113
59247: PUSH
59248: LD_VAR 0 1
59252: ARRAY
59253: PPUSH
59254: LD_INT 30
59256: PUSH
59257: LD_VAR 0 2
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: PPUSH
59266: CALL_OW 72
59270: ST_TO_ADDR
// if result then
59271: LD_VAR 0 3
59275: IFFALSE 59291
// result := result [ 1 ] ;
59277: LD_ADDR_VAR 0 3
59281: PUSH
59282: LD_VAR 0 3
59286: PUSH
59287: LD_INT 1
59289: ARRAY
59290: ST_TO_ADDR
// end ; end ;
59291: LD_VAR 0 3
59295: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
// if not mc_bases then
59300: LD_EXP 113
59304: NOT
59305: IFFALSE 59309
// exit ;
59307: GO 59354
// if mc_bases [ base ] then
59309: LD_EXP 113
59313: PUSH
59314: LD_VAR 0 1
59318: ARRAY
59319: IFFALSE 59354
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59321: LD_ADDR_VAR 0 3
59325: PUSH
59326: LD_EXP 113
59330: PUSH
59331: LD_VAR 0 1
59335: ARRAY
59336: PPUSH
59337: LD_INT 30
59339: PUSH
59340: LD_VAR 0 2
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: PPUSH
59349: CALL_OW 72
59353: ST_TO_ADDR
// end ;
59354: LD_VAR 0 3
59358: RET
// export function MC_SetTame ( base , area ) ; begin
59359: LD_INT 0
59361: PPUSH
// if not mc_bases or not base then
59362: LD_EXP 113
59366: NOT
59367: PUSH
59368: LD_VAR 0 1
59372: NOT
59373: OR
59374: IFFALSE 59378
// exit ;
59376: GO 59403
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59378: LD_ADDR_EXP 141
59382: PUSH
59383: LD_EXP 141
59387: PPUSH
59388: LD_VAR 0 1
59392: PPUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: CALL_OW 1
59402: ST_TO_ADDR
// end ;
59403: LD_VAR 0 3
59407: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59408: LD_INT 0
59410: PPUSH
59411: PPUSH
// if not mc_bases or not base then
59412: LD_EXP 113
59416: NOT
59417: PUSH
59418: LD_VAR 0 1
59422: NOT
59423: OR
59424: IFFALSE 59428
// exit ;
59426: GO 59530
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59428: LD_ADDR_VAR 0 4
59432: PUSH
59433: LD_EXP 113
59437: PUSH
59438: LD_VAR 0 1
59442: ARRAY
59443: PPUSH
59444: LD_INT 30
59446: PUSH
59447: LD_VAR 0 2
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: PPUSH
59456: CALL_OW 72
59460: ST_TO_ADDR
// if not tmp then
59461: LD_VAR 0 4
59465: NOT
59466: IFFALSE 59470
// exit ;
59468: GO 59530
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59470: LD_ADDR_EXP 145
59474: PUSH
59475: LD_EXP 145
59479: PPUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: LD_EXP 145
59489: PUSH
59490: LD_VAR 0 1
59494: ARRAY
59495: PPUSH
59496: LD_EXP 145
59500: PUSH
59501: LD_VAR 0 1
59505: ARRAY
59506: PUSH
59507: LD_INT 1
59509: PLUS
59510: PPUSH
59511: LD_VAR 0 4
59515: PUSH
59516: LD_INT 1
59518: ARRAY
59519: PPUSH
59520: CALL_OW 2
59524: PPUSH
59525: CALL_OW 1
59529: ST_TO_ADDR
// end ;
59530: LD_VAR 0 3
59534: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59535: LD_INT 0
59537: PPUSH
59538: PPUSH
// if not mc_bases or not base or not kinds then
59539: LD_EXP 113
59543: NOT
59544: PUSH
59545: LD_VAR 0 1
59549: NOT
59550: OR
59551: PUSH
59552: LD_VAR 0 2
59556: NOT
59557: OR
59558: IFFALSE 59562
// exit ;
59560: GO 59623
// for i in kinds do
59562: LD_ADDR_VAR 0 4
59566: PUSH
59567: LD_VAR 0 2
59571: PUSH
59572: FOR_IN
59573: IFFALSE 59621
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59575: LD_ADDR_EXP 147
59579: PUSH
59580: LD_EXP 147
59584: PPUSH
59585: LD_VAR 0 1
59589: PUSH
59590: LD_EXP 147
59594: PUSH
59595: LD_VAR 0 1
59599: ARRAY
59600: PUSH
59601: LD_INT 1
59603: PLUS
59604: PUSH
59605: EMPTY
59606: LIST
59607: LIST
59608: PPUSH
59609: LD_VAR 0 4
59613: PPUSH
59614: CALL 70150 0 3
59618: ST_TO_ADDR
59619: GO 59572
59621: POP
59622: POP
// end ;
59623: LD_VAR 0 3
59627: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59628: LD_INT 0
59630: PPUSH
// if not mc_bases or not base or not areas then
59631: LD_EXP 113
59635: NOT
59636: PUSH
59637: LD_VAR 0 1
59641: NOT
59642: OR
59643: PUSH
59644: LD_VAR 0 2
59648: NOT
59649: OR
59650: IFFALSE 59654
// exit ;
59652: GO 59679
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59654: LD_ADDR_EXP 131
59658: PUSH
59659: LD_EXP 131
59663: PPUSH
59664: LD_VAR 0 1
59668: PPUSH
59669: LD_VAR 0 2
59673: PPUSH
59674: CALL_OW 1
59678: ST_TO_ADDR
// end ;
59679: LD_VAR 0 3
59683: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59684: LD_INT 0
59686: PPUSH
// if not mc_bases or not base or not teleports_exit then
59687: LD_EXP 113
59691: NOT
59692: PUSH
59693: LD_VAR 0 1
59697: NOT
59698: OR
59699: PUSH
59700: LD_VAR 0 2
59704: NOT
59705: OR
59706: IFFALSE 59710
// exit ;
59708: GO 59735
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59710: LD_ADDR_EXP 148
59714: PUSH
59715: LD_EXP 148
59719: PPUSH
59720: LD_VAR 0 1
59724: PPUSH
59725: LD_VAR 0 2
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// end ;
59735: LD_VAR 0 3
59739: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59740: LD_INT 0
59742: PPUSH
59743: PPUSH
59744: PPUSH
// if not mc_bases or not base or not ext_list then
59745: LD_EXP 113
59749: NOT
59750: PUSH
59751: LD_VAR 0 1
59755: NOT
59756: OR
59757: PUSH
59758: LD_VAR 0 5
59762: NOT
59763: OR
59764: IFFALSE 59768
// exit ;
59766: GO 59941
// tmp := GetFacExtXYD ( x , y , d ) ;
59768: LD_ADDR_VAR 0 8
59772: PUSH
59773: LD_VAR 0 2
59777: PPUSH
59778: LD_VAR 0 3
59782: PPUSH
59783: LD_VAR 0 4
59787: PPUSH
59788: CALL 98829 0 3
59792: ST_TO_ADDR
// if not tmp then
59793: LD_VAR 0 8
59797: NOT
59798: IFFALSE 59802
// exit ;
59800: GO 59941
// for i in tmp do
59802: LD_ADDR_VAR 0 7
59806: PUSH
59807: LD_VAR 0 8
59811: PUSH
59812: FOR_IN
59813: IFFALSE 59939
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59815: LD_ADDR_EXP 118
59819: PUSH
59820: LD_EXP 118
59824: PPUSH
59825: LD_VAR 0 1
59829: PPUSH
59830: LD_EXP 118
59834: PUSH
59835: LD_VAR 0 1
59839: ARRAY
59840: PPUSH
59841: LD_EXP 118
59845: PUSH
59846: LD_VAR 0 1
59850: ARRAY
59851: PUSH
59852: LD_INT 1
59854: PLUS
59855: PPUSH
59856: LD_VAR 0 5
59860: PUSH
59861: LD_INT 1
59863: ARRAY
59864: PUSH
59865: LD_VAR 0 7
59869: PUSH
59870: LD_INT 1
59872: ARRAY
59873: PUSH
59874: LD_VAR 0 7
59878: PUSH
59879: LD_INT 2
59881: ARRAY
59882: PUSH
59883: LD_VAR 0 7
59887: PUSH
59888: LD_INT 3
59890: ARRAY
59891: PUSH
59892: EMPTY
59893: LIST
59894: LIST
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 2
59902: PPUSH
59903: CALL_OW 1
59907: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59908: LD_ADDR_VAR 0 5
59912: PUSH
59913: LD_VAR 0 5
59917: PPUSH
59918: LD_INT 1
59920: PPUSH
59921: CALL_OW 3
59925: ST_TO_ADDR
// if not ext_list then
59926: LD_VAR 0 5
59930: NOT
59931: IFFALSE 59937
// exit ;
59933: POP
59934: POP
59935: GO 59941
// end ;
59937: GO 59812
59939: POP
59940: POP
// end ;
59941: LD_VAR 0 6
59945: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59946: LD_INT 0
59948: PPUSH
// if not mc_bases or not base or not weapon_list then
59949: LD_EXP 113
59953: NOT
59954: PUSH
59955: LD_VAR 0 1
59959: NOT
59960: OR
59961: PUSH
59962: LD_VAR 0 2
59966: NOT
59967: OR
59968: IFFALSE 59972
// exit ;
59970: GO 59997
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59972: LD_ADDR_EXP 152
59976: PUSH
59977: LD_EXP 152
59981: PPUSH
59982: LD_VAR 0 1
59986: PPUSH
59987: LD_VAR 0 2
59991: PPUSH
59992: CALL_OW 1
59996: ST_TO_ADDR
// end ;
59997: LD_VAR 0 3
60001: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60002: LD_INT 0
60004: PPUSH
// if not mc_bases or not base or not tech_list then
60005: LD_EXP 113
60009: NOT
60010: PUSH
60011: LD_VAR 0 1
60015: NOT
60016: OR
60017: PUSH
60018: LD_VAR 0 2
60022: NOT
60023: OR
60024: IFFALSE 60028
// exit ;
60026: GO 60053
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60028: LD_ADDR_EXP 140
60032: PUSH
60033: LD_EXP 140
60037: PPUSH
60038: LD_VAR 0 1
60042: PPUSH
60043: LD_VAR 0 2
60047: PPUSH
60048: CALL_OW 1
60052: ST_TO_ADDR
// end ;
60053: LD_VAR 0 3
60057: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60058: LD_INT 0
60060: PPUSH
// if not mc_bases or not parking_area or not base then
60061: LD_EXP 113
60065: NOT
60066: PUSH
60067: LD_VAR 0 2
60071: NOT
60072: OR
60073: PUSH
60074: LD_VAR 0 1
60078: NOT
60079: OR
60080: IFFALSE 60084
// exit ;
60082: GO 60109
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60084: LD_ADDR_EXP 137
60088: PUSH
60089: LD_EXP 137
60093: PPUSH
60094: LD_VAR 0 1
60098: PPUSH
60099: LD_VAR 0 2
60103: PPUSH
60104: CALL_OW 1
60108: ST_TO_ADDR
// end ;
60109: LD_VAR 0 3
60113: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60114: LD_INT 0
60116: PPUSH
// if not mc_bases or not base or not scan_area then
60117: LD_EXP 113
60121: NOT
60122: PUSH
60123: LD_VAR 0 1
60127: NOT
60128: OR
60129: PUSH
60130: LD_VAR 0 2
60134: NOT
60135: OR
60136: IFFALSE 60140
// exit ;
60138: GO 60165
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60140: LD_ADDR_EXP 138
60144: PUSH
60145: LD_EXP 138
60149: PPUSH
60150: LD_VAR 0 1
60154: PPUSH
60155: LD_VAR 0 2
60159: PPUSH
60160: CALL_OW 1
60164: ST_TO_ADDR
// end ;
60165: LD_VAR 0 3
60169: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60170: LD_INT 0
60172: PPUSH
60173: PPUSH
// if not mc_bases or not base then
60174: LD_EXP 113
60178: NOT
60179: PUSH
60180: LD_VAR 0 1
60184: NOT
60185: OR
60186: IFFALSE 60190
// exit ;
60188: GO 60254
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60190: LD_ADDR_VAR 0 3
60194: PUSH
60195: LD_INT 1
60197: PUSH
60198: LD_INT 2
60200: PUSH
60201: LD_INT 3
60203: PUSH
60204: LD_INT 4
60206: PUSH
60207: LD_INT 11
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60217: LD_ADDR_EXP 140
60221: PUSH
60222: LD_EXP 140
60226: PPUSH
60227: LD_VAR 0 1
60231: PPUSH
60232: LD_EXP 140
60236: PUSH
60237: LD_VAR 0 1
60241: ARRAY
60242: PUSH
60243: LD_VAR 0 3
60247: DIFF
60248: PPUSH
60249: CALL_OW 1
60253: ST_TO_ADDR
// end ;
60254: LD_VAR 0 2
60258: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60259: LD_INT 0
60261: PPUSH
// result := mc_vehicles [ base ] ;
60262: LD_ADDR_VAR 0 3
60266: PUSH
60267: LD_EXP 132
60271: PUSH
60272: LD_VAR 0 1
60276: ARRAY
60277: ST_TO_ADDR
// if onlyCombat then
60278: LD_VAR 0 2
60282: IFFALSE 60460
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60284: LD_ADDR_VAR 0 3
60288: PUSH
60289: LD_VAR 0 3
60293: PUSH
60294: LD_VAR 0 3
60298: PPUSH
60299: LD_INT 2
60301: PUSH
60302: LD_INT 34
60304: PUSH
60305: LD_INT 12
60307: PUSH
60308: EMPTY
60309: LIST
60310: LIST
60311: PUSH
60312: LD_INT 34
60314: PUSH
60315: LD_INT 51
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: PUSH
60322: LD_INT 34
60324: PUSH
60325: LD_EXP 96
60329: PUSH
60330: EMPTY
60331: LIST
60332: LIST
60333: PUSH
60334: LD_INT 34
60336: PUSH
60337: LD_INT 32
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: PUSH
60344: LD_INT 34
60346: PUSH
60347: LD_INT 13
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 34
60356: PUSH
60357: LD_INT 52
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 34
60366: PUSH
60367: LD_EXP 101
60371: PUSH
60372: EMPTY
60373: LIST
60374: LIST
60375: PUSH
60376: LD_INT 34
60378: PUSH
60379: LD_INT 14
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: LD_INT 34
60388: PUSH
60389: LD_INT 53
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 34
60398: PUSH
60399: LD_EXP 95
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: PUSH
60408: LD_INT 34
60410: PUSH
60411: LD_INT 31
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PUSH
60418: LD_INT 34
60420: PUSH
60421: LD_INT 48
60423: PUSH
60424: EMPTY
60425: LIST
60426: LIST
60427: PUSH
60428: LD_INT 34
60430: PUSH
60431: LD_INT 8
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: LIST
60442: LIST
60443: LIST
60444: LIST
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: PPUSH
60454: CALL_OW 72
60458: DIFF
60459: ST_TO_ADDR
// end ; end_of_file
60460: LD_VAR 0 3
60464: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60465: LD_INT 0
60467: PPUSH
60468: PPUSH
60469: PPUSH
// if not mc_bases or not skirmish then
60470: LD_EXP 113
60474: NOT
60475: PUSH
60476: LD_EXP 111
60480: NOT
60481: OR
60482: IFFALSE 60486
// exit ;
60484: GO 60651
// for i = 1 to mc_bases do
60486: LD_ADDR_VAR 0 4
60490: PUSH
60491: DOUBLE
60492: LD_INT 1
60494: DEC
60495: ST_TO_ADDR
60496: LD_EXP 113
60500: PUSH
60501: FOR_TO
60502: IFFALSE 60649
// begin if sci in mc_bases [ i ] then
60504: LD_VAR 0 2
60508: PUSH
60509: LD_EXP 113
60513: PUSH
60514: LD_VAR 0 4
60518: ARRAY
60519: IN
60520: IFFALSE 60647
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60522: LD_ADDR_EXP 142
60526: PUSH
60527: LD_EXP 142
60531: PPUSH
60532: LD_VAR 0 4
60536: PUSH
60537: LD_EXP 142
60541: PUSH
60542: LD_VAR 0 4
60546: ARRAY
60547: PUSH
60548: LD_INT 1
60550: PLUS
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PPUSH
60556: LD_VAR 0 1
60560: PPUSH
60561: CALL 70150 0 3
60565: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60566: LD_ADDR_VAR 0 5
60570: PUSH
60571: LD_EXP 113
60575: PUSH
60576: LD_VAR 0 4
60580: ARRAY
60581: PPUSH
60582: LD_INT 2
60584: PUSH
60585: LD_INT 30
60587: PUSH
60588: LD_INT 0
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: PUSH
60595: LD_INT 30
60597: PUSH
60598: LD_INT 1
60600: PUSH
60601: EMPTY
60602: LIST
60603: LIST
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: LIST
60609: PPUSH
60610: CALL_OW 72
60614: PPUSH
60615: LD_VAR 0 1
60619: PPUSH
60620: CALL_OW 74
60624: ST_TO_ADDR
// if tmp then
60625: LD_VAR 0 5
60629: IFFALSE 60645
// ComStandNearbyBuilding ( ape , tmp ) ;
60631: LD_VAR 0 1
60635: PPUSH
60636: LD_VAR 0 5
60640: PPUSH
60641: CALL 66764 0 2
// break ;
60645: GO 60649
// end ; end ;
60647: GO 60501
60649: POP
60650: POP
// end ;
60651: LD_VAR 0 3
60655: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60656: LD_INT 0
60658: PPUSH
60659: PPUSH
60660: PPUSH
// if not mc_bases or not skirmish then
60661: LD_EXP 113
60665: NOT
60666: PUSH
60667: LD_EXP 111
60671: NOT
60672: OR
60673: IFFALSE 60677
// exit ;
60675: GO 60766
// for i = 1 to mc_bases do
60677: LD_ADDR_VAR 0 4
60681: PUSH
60682: DOUBLE
60683: LD_INT 1
60685: DEC
60686: ST_TO_ADDR
60687: LD_EXP 113
60691: PUSH
60692: FOR_TO
60693: IFFALSE 60764
// begin if building in mc_busy_turret_list [ i ] then
60695: LD_VAR 0 1
60699: PUSH
60700: LD_EXP 123
60704: PUSH
60705: LD_VAR 0 4
60709: ARRAY
60710: IN
60711: IFFALSE 60762
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60713: LD_ADDR_VAR 0 5
60717: PUSH
60718: LD_EXP 123
60722: PUSH
60723: LD_VAR 0 4
60727: ARRAY
60728: PUSH
60729: LD_VAR 0 1
60733: DIFF
60734: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60735: LD_ADDR_EXP 123
60739: PUSH
60740: LD_EXP 123
60744: PPUSH
60745: LD_VAR 0 4
60749: PPUSH
60750: LD_VAR 0 5
60754: PPUSH
60755: CALL_OW 1
60759: ST_TO_ADDR
// break ;
60760: GO 60764
// end ; end ;
60762: GO 60692
60764: POP
60765: POP
// end ;
60766: LD_VAR 0 3
60770: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60771: LD_INT 0
60773: PPUSH
60774: PPUSH
60775: PPUSH
// if not mc_bases or not skirmish then
60776: LD_EXP 113
60780: NOT
60781: PUSH
60782: LD_EXP 111
60786: NOT
60787: OR
60788: IFFALSE 60792
// exit ;
60790: GO 60991
// for i = 1 to mc_bases do
60792: LD_ADDR_VAR 0 5
60796: PUSH
60797: DOUBLE
60798: LD_INT 1
60800: DEC
60801: ST_TO_ADDR
60802: LD_EXP 113
60806: PUSH
60807: FOR_TO
60808: IFFALSE 60989
// if building in mc_bases [ i ] then
60810: LD_VAR 0 1
60814: PUSH
60815: LD_EXP 113
60819: PUSH
60820: LD_VAR 0 5
60824: ARRAY
60825: IN
60826: IFFALSE 60987
// begin tmp := mc_bases [ i ] diff building ;
60828: LD_ADDR_VAR 0 6
60832: PUSH
60833: LD_EXP 113
60837: PUSH
60838: LD_VAR 0 5
60842: ARRAY
60843: PUSH
60844: LD_VAR 0 1
60848: DIFF
60849: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60850: LD_ADDR_EXP 113
60854: PUSH
60855: LD_EXP 113
60859: PPUSH
60860: LD_VAR 0 5
60864: PPUSH
60865: LD_VAR 0 6
60869: PPUSH
60870: CALL_OW 1
60874: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60875: LD_VAR 0 1
60879: PUSH
60880: LD_EXP 121
60884: PUSH
60885: LD_VAR 0 5
60889: ARRAY
60890: IN
60891: IFFALSE 60930
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60893: LD_ADDR_EXP 121
60897: PUSH
60898: LD_EXP 121
60902: PPUSH
60903: LD_VAR 0 5
60907: PPUSH
60908: LD_EXP 121
60912: PUSH
60913: LD_VAR 0 5
60917: ARRAY
60918: PUSH
60919: LD_VAR 0 1
60923: DIFF
60924: PPUSH
60925: CALL_OW 1
60929: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60930: LD_VAR 0 1
60934: PUSH
60935: LD_EXP 122
60939: PUSH
60940: LD_VAR 0 5
60944: ARRAY
60945: IN
60946: IFFALSE 60985
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60948: LD_ADDR_EXP 122
60952: PUSH
60953: LD_EXP 122
60957: PPUSH
60958: LD_VAR 0 5
60962: PPUSH
60963: LD_EXP 122
60967: PUSH
60968: LD_VAR 0 5
60972: ARRAY
60973: PUSH
60974: LD_VAR 0 1
60978: DIFF
60979: PPUSH
60980: CALL_OW 1
60984: ST_TO_ADDR
// break ;
60985: GO 60989
// end ;
60987: GO 60807
60989: POP
60990: POP
// end ;
60991: LD_VAR 0 4
60995: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60996: LD_INT 0
60998: PPUSH
60999: PPUSH
61000: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61001: LD_EXP 113
61005: NOT
61006: PUSH
61007: LD_EXP 111
61011: NOT
61012: OR
61013: PUSH
61014: LD_VAR 0 3
61018: PUSH
61019: LD_EXP 139
61023: IN
61024: NOT
61025: OR
61026: IFFALSE 61030
// exit ;
61028: GO 61153
// for i = 1 to mc_vehicles do
61030: LD_ADDR_VAR 0 6
61034: PUSH
61035: DOUBLE
61036: LD_INT 1
61038: DEC
61039: ST_TO_ADDR
61040: LD_EXP 132
61044: PUSH
61045: FOR_TO
61046: IFFALSE 61151
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61048: LD_VAR 0 2
61052: PUSH
61053: LD_EXP 132
61057: PUSH
61058: LD_VAR 0 6
61062: ARRAY
61063: IN
61064: PUSH
61065: LD_VAR 0 1
61069: PUSH
61070: LD_EXP 132
61074: PUSH
61075: LD_VAR 0 6
61079: ARRAY
61080: IN
61081: OR
61082: IFFALSE 61149
// begin tmp := mc_vehicles [ i ] diff old ;
61084: LD_ADDR_VAR 0 7
61088: PUSH
61089: LD_EXP 132
61093: PUSH
61094: LD_VAR 0 6
61098: ARRAY
61099: PUSH
61100: LD_VAR 0 2
61104: DIFF
61105: ST_TO_ADDR
// tmp := tmp diff new ;
61106: LD_ADDR_VAR 0 7
61110: PUSH
61111: LD_VAR 0 7
61115: PUSH
61116: LD_VAR 0 1
61120: DIFF
61121: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61122: LD_ADDR_EXP 132
61126: PUSH
61127: LD_EXP 132
61131: PPUSH
61132: LD_VAR 0 6
61136: PPUSH
61137: LD_VAR 0 7
61141: PPUSH
61142: CALL_OW 1
61146: ST_TO_ADDR
// break ;
61147: GO 61151
// end ;
61149: GO 61045
61151: POP
61152: POP
// end ;
61153: LD_VAR 0 5
61157: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61158: LD_INT 0
61160: PPUSH
61161: PPUSH
61162: PPUSH
61163: PPUSH
// if not mc_bases or not skirmish then
61164: LD_EXP 113
61168: NOT
61169: PUSH
61170: LD_EXP 111
61174: NOT
61175: OR
61176: IFFALSE 61180
// exit ;
61178: GO 61563
// side := GetSide ( vehicle ) ;
61180: LD_ADDR_VAR 0 5
61184: PUSH
61185: LD_VAR 0 1
61189: PPUSH
61190: CALL_OW 255
61194: ST_TO_ADDR
// for i = 1 to mc_bases do
61195: LD_ADDR_VAR 0 4
61199: PUSH
61200: DOUBLE
61201: LD_INT 1
61203: DEC
61204: ST_TO_ADDR
61205: LD_EXP 113
61209: PUSH
61210: FOR_TO
61211: IFFALSE 61561
// begin if factory in mc_bases [ i ] then
61213: LD_VAR 0 2
61217: PUSH
61218: LD_EXP 113
61222: PUSH
61223: LD_VAR 0 4
61227: ARRAY
61228: IN
61229: IFFALSE 61559
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61231: LD_EXP 135
61235: PUSH
61236: LD_VAR 0 4
61240: ARRAY
61241: PUSH
61242: LD_EXP 124
61246: PUSH
61247: LD_VAR 0 4
61251: ARRAY
61252: LESS
61253: PUSH
61254: LD_VAR 0 1
61258: PPUSH
61259: CALL_OW 264
61263: PUSH
61264: LD_INT 31
61266: PUSH
61267: LD_INT 32
61269: PUSH
61270: LD_INT 51
61272: PUSH
61273: LD_EXP 96
61277: PUSH
61278: LD_INT 12
61280: PUSH
61281: LD_INT 30
61283: PUSH
61284: LD_EXP 95
61288: PUSH
61289: LD_INT 11
61291: PUSH
61292: LD_INT 53
61294: PUSH
61295: LD_INT 14
61297: PUSH
61298: LD_EXP 99
61302: PUSH
61303: LD_INT 29
61305: PUSH
61306: LD_EXP 97
61310: PUSH
61311: LD_INT 13
61313: PUSH
61314: LD_INT 52
61316: PUSH
61317: LD_EXP 101
61321: PUSH
61322: LD_INT 48
61324: PUSH
61325: LD_INT 8
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: LIST
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: IN
61348: NOT
61349: AND
61350: IFFALSE 61398
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61352: LD_ADDR_EXP 135
61356: PUSH
61357: LD_EXP 135
61361: PPUSH
61362: LD_VAR 0 4
61366: PUSH
61367: LD_EXP 135
61371: PUSH
61372: LD_VAR 0 4
61376: ARRAY
61377: PUSH
61378: LD_INT 1
61380: PLUS
61381: PUSH
61382: EMPTY
61383: LIST
61384: LIST
61385: PPUSH
61386: LD_VAR 0 1
61390: PPUSH
61391: CALL 70150 0 3
61395: ST_TO_ADDR
61396: GO 61442
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61398: LD_ADDR_EXP 132
61402: PUSH
61403: LD_EXP 132
61407: PPUSH
61408: LD_VAR 0 4
61412: PUSH
61413: LD_EXP 132
61417: PUSH
61418: LD_VAR 0 4
61422: ARRAY
61423: PUSH
61424: LD_INT 1
61426: PLUS
61427: PUSH
61428: EMPTY
61429: LIST
61430: LIST
61431: PPUSH
61432: LD_VAR 0 1
61436: PPUSH
61437: CALL 70150 0 3
61441: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL_OW 263
61451: PUSH
61452: LD_INT 2
61454: EQUAL
61455: IFFALSE 61475
// begin repeat wait ( 0 0$1 ) ;
61457: LD_INT 35
61459: PPUSH
61460: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61464: LD_VAR 0 1
61468: PPUSH
61469: CALL_OW 312
61473: IFFALSE 61457
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61475: LD_VAR 0 1
61479: PPUSH
61480: LD_EXP 137
61484: PUSH
61485: LD_VAR 0 4
61489: ARRAY
61490: PPUSH
61491: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61495: LD_VAR 0 1
61499: PPUSH
61500: CALL_OW 263
61504: PUSH
61505: LD_INT 1
61507: NONEQUAL
61508: IFFALSE 61512
// break ;
61510: GO 61561
// repeat wait ( 0 0$1 ) ;
61512: LD_INT 35
61514: PPUSH
61515: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61519: LD_VAR 0 1
61523: PPUSH
61524: LD_EXP 137
61528: PUSH
61529: LD_VAR 0 4
61533: ARRAY
61534: PPUSH
61535: CALL_OW 308
61539: IFFALSE 61512
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61541: LD_VAR 0 1
61545: PPUSH
61546: CALL_OW 311
61550: PPUSH
61551: CALL_OW 121
// exit ;
61555: POP
61556: POP
61557: GO 61563
// end ; end ;
61559: GO 61210
61561: POP
61562: POP
// end ;
61563: LD_VAR 0 3
61567: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61568: LD_INT 0
61570: PPUSH
61571: PPUSH
61572: PPUSH
61573: PPUSH
// if not mc_bases or not skirmish then
61574: LD_EXP 113
61578: NOT
61579: PUSH
61580: LD_EXP 111
61584: NOT
61585: OR
61586: IFFALSE 61590
// exit ;
61588: GO 61943
// repeat wait ( 0 0$1 ) ;
61590: LD_INT 35
61592: PPUSH
61593: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61597: LD_VAR 0 2
61601: PPUSH
61602: LD_VAR 0 3
61606: PPUSH
61607: CALL_OW 284
61611: IFFALSE 61590
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61613: LD_VAR 0 2
61617: PPUSH
61618: LD_VAR 0 3
61622: PPUSH
61623: CALL_OW 283
61627: PUSH
61628: LD_INT 4
61630: EQUAL
61631: IFFALSE 61635
// exit ;
61633: GO 61943
// for i = 1 to mc_bases do
61635: LD_ADDR_VAR 0 7
61639: PUSH
61640: DOUBLE
61641: LD_INT 1
61643: DEC
61644: ST_TO_ADDR
61645: LD_EXP 113
61649: PUSH
61650: FOR_TO
61651: IFFALSE 61941
// begin if mc_crates_area [ i ] then
61653: LD_EXP 131
61657: PUSH
61658: LD_VAR 0 7
61662: ARRAY
61663: IFFALSE 61774
// for j in mc_crates_area [ i ] do
61665: LD_ADDR_VAR 0 8
61669: PUSH
61670: LD_EXP 131
61674: PUSH
61675: LD_VAR 0 7
61679: ARRAY
61680: PUSH
61681: FOR_IN
61682: IFFALSE 61772
// if InArea ( x , y , j ) then
61684: LD_VAR 0 2
61688: PPUSH
61689: LD_VAR 0 3
61693: PPUSH
61694: LD_VAR 0 8
61698: PPUSH
61699: CALL_OW 309
61703: IFFALSE 61770
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61705: LD_ADDR_EXP 129
61709: PUSH
61710: LD_EXP 129
61714: PPUSH
61715: LD_VAR 0 7
61719: PUSH
61720: LD_EXP 129
61724: PUSH
61725: LD_VAR 0 7
61729: ARRAY
61730: PUSH
61731: LD_INT 1
61733: PLUS
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PPUSH
61739: LD_VAR 0 4
61743: PUSH
61744: LD_VAR 0 2
61748: PUSH
61749: LD_VAR 0 3
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: LIST
61758: PPUSH
61759: CALL 70150 0 3
61763: ST_TO_ADDR
// exit ;
61764: POP
61765: POP
61766: POP
61767: POP
61768: GO 61943
// end ;
61770: GO 61681
61772: POP
61773: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61774: LD_ADDR_VAR 0 9
61778: PUSH
61779: LD_EXP 113
61783: PUSH
61784: LD_VAR 0 7
61788: ARRAY
61789: PPUSH
61790: LD_INT 2
61792: PUSH
61793: LD_INT 30
61795: PUSH
61796: LD_INT 0
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 30
61805: PUSH
61806: LD_INT 1
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PUSH
61813: EMPTY
61814: LIST
61815: LIST
61816: LIST
61817: PPUSH
61818: CALL_OW 72
61822: ST_TO_ADDR
// if not depot then
61823: LD_VAR 0 9
61827: NOT
61828: IFFALSE 61832
// continue ;
61830: GO 61650
// for j in depot do
61832: LD_ADDR_VAR 0 8
61836: PUSH
61837: LD_VAR 0 9
61841: PUSH
61842: FOR_IN
61843: IFFALSE 61937
// if GetDistUnitXY ( j , x , y ) < 30 then
61845: LD_VAR 0 8
61849: PPUSH
61850: LD_VAR 0 2
61854: PPUSH
61855: LD_VAR 0 3
61859: PPUSH
61860: CALL_OW 297
61864: PUSH
61865: LD_INT 30
61867: LESS
61868: IFFALSE 61935
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61870: LD_ADDR_EXP 129
61874: PUSH
61875: LD_EXP 129
61879: PPUSH
61880: LD_VAR 0 7
61884: PUSH
61885: LD_EXP 129
61889: PUSH
61890: LD_VAR 0 7
61894: ARRAY
61895: PUSH
61896: LD_INT 1
61898: PLUS
61899: PUSH
61900: EMPTY
61901: LIST
61902: LIST
61903: PPUSH
61904: LD_VAR 0 4
61908: PUSH
61909: LD_VAR 0 2
61913: PUSH
61914: LD_VAR 0 3
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: LIST
61923: PPUSH
61924: CALL 70150 0 3
61928: ST_TO_ADDR
// exit ;
61929: POP
61930: POP
61931: POP
61932: POP
61933: GO 61943
// end ;
61935: GO 61842
61937: POP
61938: POP
// end ;
61939: GO 61650
61941: POP
61942: POP
// end ;
61943: LD_VAR 0 6
61947: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61948: LD_INT 0
61950: PPUSH
61951: PPUSH
61952: PPUSH
61953: PPUSH
// if not mc_bases or not skirmish then
61954: LD_EXP 113
61958: NOT
61959: PUSH
61960: LD_EXP 111
61964: NOT
61965: OR
61966: IFFALSE 61970
// exit ;
61968: GO 62247
// side := GetSide ( lab ) ;
61970: LD_ADDR_VAR 0 4
61974: PUSH
61975: LD_VAR 0 2
61979: PPUSH
61980: CALL_OW 255
61984: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61985: LD_VAR 0 4
61989: PUSH
61990: LD_EXP 139
61994: IN
61995: NOT
61996: PUSH
61997: LD_EXP 140
62001: NOT
62002: OR
62003: PUSH
62004: LD_EXP 113
62008: NOT
62009: OR
62010: IFFALSE 62014
// exit ;
62012: GO 62247
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62014: LD_ADDR_EXP 140
62018: PUSH
62019: LD_EXP 140
62023: PPUSH
62024: LD_VAR 0 4
62028: PPUSH
62029: LD_EXP 140
62033: PUSH
62034: LD_VAR 0 4
62038: ARRAY
62039: PUSH
62040: LD_VAR 0 1
62044: DIFF
62045: PPUSH
62046: CALL_OW 1
62050: ST_TO_ADDR
// for i = 1 to mc_bases do
62051: LD_ADDR_VAR 0 5
62055: PUSH
62056: DOUBLE
62057: LD_INT 1
62059: DEC
62060: ST_TO_ADDR
62061: LD_EXP 113
62065: PUSH
62066: FOR_TO
62067: IFFALSE 62245
// begin if lab in mc_bases [ i ] then
62069: LD_VAR 0 2
62073: PUSH
62074: LD_EXP 113
62078: PUSH
62079: LD_VAR 0 5
62083: ARRAY
62084: IN
62085: IFFALSE 62243
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62087: LD_VAR 0 1
62091: PUSH
62092: LD_INT 11
62094: PUSH
62095: LD_INT 4
62097: PUSH
62098: LD_INT 3
62100: PUSH
62101: LD_INT 2
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: IN
62110: PUSH
62111: LD_EXP 143
62115: PUSH
62116: LD_VAR 0 5
62120: ARRAY
62121: AND
62122: IFFALSE 62243
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62124: LD_ADDR_VAR 0 6
62128: PUSH
62129: LD_EXP 143
62133: PUSH
62134: LD_VAR 0 5
62138: ARRAY
62139: PUSH
62140: LD_INT 1
62142: ARRAY
62143: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62144: LD_ADDR_EXP 143
62148: PUSH
62149: LD_EXP 143
62153: PPUSH
62154: LD_VAR 0 5
62158: PPUSH
62159: EMPTY
62160: PPUSH
62161: CALL_OW 1
62165: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62166: LD_VAR 0 6
62170: PPUSH
62171: LD_INT 0
62173: PPUSH
62174: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62178: LD_VAR 0 6
62182: PPUSH
62183: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62187: LD_ADDR_EXP 142
62191: PUSH
62192: LD_EXP 142
62196: PPUSH
62197: LD_VAR 0 5
62201: PPUSH
62202: LD_EXP 142
62206: PUSH
62207: LD_VAR 0 5
62211: ARRAY
62212: PPUSH
62213: LD_INT 1
62215: PPUSH
62216: LD_VAR 0 6
62220: PPUSH
62221: CALL_OW 2
62225: PPUSH
62226: CALL_OW 1
62230: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62231: LD_VAR 0 5
62235: PPUSH
62236: LD_INT 112
62238: PPUSH
62239: CALL 39192 0 2
// end ; end ; end ;
62243: GO 62066
62245: POP
62246: POP
// end ;
62247: LD_VAR 0 3
62251: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62252: LD_INT 0
62254: PPUSH
62255: PPUSH
62256: PPUSH
62257: PPUSH
62258: PPUSH
62259: PPUSH
62260: PPUSH
62261: PPUSH
// if not mc_bases or not skirmish then
62262: LD_EXP 113
62266: NOT
62267: PUSH
62268: LD_EXP 111
62272: NOT
62273: OR
62274: IFFALSE 62278
// exit ;
62276: GO 63649
// for i = 1 to mc_bases do
62278: LD_ADDR_VAR 0 3
62282: PUSH
62283: DOUBLE
62284: LD_INT 1
62286: DEC
62287: ST_TO_ADDR
62288: LD_EXP 113
62292: PUSH
62293: FOR_TO
62294: IFFALSE 63647
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62296: LD_VAR 0 1
62300: PUSH
62301: LD_EXP 113
62305: PUSH
62306: LD_VAR 0 3
62310: ARRAY
62311: IN
62312: PUSH
62313: LD_VAR 0 1
62317: PUSH
62318: LD_EXP 120
62322: PUSH
62323: LD_VAR 0 3
62327: ARRAY
62328: IN
62329: OR
62330: PUSH
62331: LD_VAR 0 1
62335: PUSH
62336: LD_EXP 135
62340: PUSH
62341: LD_VAR 0 3
62345: ARRAY
62346: IN
62347: OR
62348: PUSH
62349: LD_VAR 0 1
62353: PUSH
62354: LD_EXP 132
62358: PUSH
62359: LD_VAR 0 3
62363: ARRAY
62364: IN
62365: OR
62366: PUSH
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 142
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: OR
62384: PUSH
62385: LD_VAR 0 1
62389: PUSH
62390: LD_EXP 143
62394: PUSH
62395: LD_VAR 0 3
62399: ARRAY
62400: IN
62401: OR
62402: IFFALSE 63645
// begin if un in mc_ape [ i ] then
62404: LD_VAR 0 1
62408: PUSH
62409: LD_EXP 142
62413: PUSH
62414: LD_VAR 0 3
62418: ARRAY
62419: IN
62420: IFFALSE 62459
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62422: LD_ADDR_EXP 142
62426: PUSH
62427: LD_EXP 142
62431: PPUSH
62432: LD_VAR 0 3
62436: PPUSH
62437: LD_EXP 142
62441: PUSH
62442: LD_VAR 0 3
62446: ARRAY
62447: PUSH
62448: LD_VAR 0 1
62452: DIFF
62453: PPUSH
62454: CALL_OW 1
62458: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62459: LD_VAR 0 1
62463: PUSH
62464: LD_EXP 143
62468: PUSH
62469: LD_VAR 0 3
62473: ARRAY
62474: IN
62475: IFFALSE 62499
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62477: LD_ADDR_EXP 143
62481: PUSH
62482: LD_EXP 143
62486: PPUSH
62487: LD_VAR 0 3
62491: PPUSH
62492: EMPTY
62493: PPUSH
62494: CALL_OW 1
62498: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62499: LD_VAR 0 1
62503: PPUSH
62504: CALL_OW 247
62508: PUSH
62509: LD_INT 2
62511: EQUAL
62512: PUSH
62513: LD_VAR 0 1
62517: PPUSH
62518: CALL_OW 110
62522: PUSH
62523: LD_INT 20
62525: EQUAL
62526: PUSH
62527: LD_VAR 0 1
62531: PUSH
62532: LD_EXP 135
62536: PUSH
62537: LD_VAR 0 3
62541: ARRAY
62542: IN
62543: OR
62544: PUSH
62545: LD_VAR 0 1
62549: PPUSH
62550: CALL_OW 264
62554: PUSH
62555: LD_INT 12
62557: PUSH
62558: LD_INT 51
62560: PUSH
62561: LD_EXP 96
62565: PUSH
62566: LD_INT 32
62568: PUSH
62569: LD_INT 13
62571: PUSH
62572: LD_INT 52
62574: PUSH
62575: LD_INT 31
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: IN
62587: OR
62588: AND
62589: IFFALSE 62897
// begin if un in mc_defender [ i ] then
62591: LD_VAR 0 1
62595: PUSH
62596: LD_EXP 135
62600: PUSH
62601: LD_VAR 0 3
62605: ARRAY
62606: IN
62607: IFFALSE 62646
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62609: LD_ADDR_EXP 135
62613: PUSH
62614: LD_EXP 135
62618: PPUSH
62619: LD_VAR 0 3
62623: PPUSH
62624: LD_EXP 135
62628: PUSH
62629: LD_VAR 0 3
62633: ARRAY
62634: PUSH
62635: LD_VAR 0 1
62639: DIFF
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62646: LD_ADDR_VAR 0 8
62650: PUSH
62651: LD_VAR 0 3
62655: PPUSH
62656: LD_INT 3
62658: PPUSH
62659: CALL 59296 0 2
62663: ST_TO_ADDR
// if fac then
62664: LD_VAR 0 8
62668: IFFALSE 62897
// begin for j in fac do
62670: LD_ADDR_VAR 0 4
62674: PUSH
62675: LD_VAR 0 8
62679: PUSH
62680: FOR_IN
62681: IFFALSE 62895
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62683: LD_ADDR_VAR 0 9
62687: PUSH
62688: LD_VAR 0 8
62692: PPUSH
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 265
62702: PPUSH
62703: LD_VAR 0 1
62707: PPUSH
62708: CALL_OW 262
62712: PPUSH
62713: LD_VAR 0 1
62717: PPUSH
62718: CALL_OW 263
62722: PPUSH
62723: LD_VAR 0 1
62727: PPUSH
62728: CALL_OW 264
62732: PPUSH
62733: CALL 67682 0 5
62737: ST_TO_ADDR
// if components then
62738: LD_VAR 0 9
62742: IFFALSE 62893
// begin if GetWeapon ( un ) = ar_control_tower then
62744: LD_VAR 0 1
62748: PPUSH
62749: CALL_OW 264
62753: PUSH
62754: LD_INT 31
62756: EQUAL
62757: IFFALSE 62874
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62759: LD_VAR 0 1
62763: PPUSH
62764: CALL_OW 311
62768: PPUSH
62769: LD_INT 0
62771: PPUSH
62772: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62776: LD_ADDR_EXP 153
62780: PUSH
62781: LD_EXP 153
62785: PPUSH
62786: LD_VAR 0 3
62790: PPUSH
62791: LD_EXP 153
62795: PUSH
62796: LD_VAR 0 3
62800: ARRAY
62801: PUSH
62802: LD_VAR 0 1
62806: PPUSH
62807: CALL_OW 311
62811: DIFF
62812: PPUSH
62813: CALL_OW 1
62817: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62818: LD_ADDR_VAR 0 7
62822: PUSH
62823: LD_EXP 134
62827: PUSH
62828: LD_VAR 0 3
62832: ARRAY
62833: PPUSH
62834: LD_INT 1
62836: PPUSH
62837: LD_VAR 0 9
62841: PPUSH
62842: CALL_OW 2
62846: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62847: LD_ADDR_EXP 134
62851: PUSH
62852: LD_EXP 134
62856: PPUSH
62857: LD_VAR 0 3
62861: PPUSH
62862: LD_VAR 0 7
62866: PPUSH
62867: CALL_OW 1
62871: ST_TO_ADDR
// end else
62872: GO 62891
// MC_InsertProduceList ( i , [ components ] ) ;
62874: LD_VAR 0 3
62878: PPUSH
62879: LD_VAR 0 9
62883: PUSH
62884: EMPTY
62885: LIST
62886: PPUSH
62887: CALL 58841 0 2
// break ;
62891: GO 62895
// end ; end ;
62893: GO 62680
62895: POP
62896: POP
// end ; end ; if GetType ( un ) = unit_building then
62897: LD_VAR 0 1
62901: PPUSH
62902: CALL_OW 247
62906: PUSH
62907: LD_INT 3
62909: EQUAL
62910: IFFALSE 63313
// begin btype := GetBType ( un ) ;
62912: LD_ADDR_VAR 0 5
62916: PUSH
62917: LD_VAR 0 1
62921: PPUSH
62922: CALL_OW 266
62926: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62927: LD_VAR 0 5
62931: PUSH
62932: LD_INT 29
62934: PUSH
62935: LD_INT 30
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: IN
62942: IFFALSE 63015
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62944: LD_VAR 0 1
62948: PPUSH
62949: CALL_OW 250
62953: PPUSH
62954: LD_VAR 0 1
62958: PPUSH
62959: CALL_OW 251
62963: PPUSH
62964: LD_VAR 0 1
62968: PPUSH
62969: CALL_OW 255
62973: PPUSH
62974: CALL_OW 440
62978: NOT
62979: IFFALSE 63015
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62981: LD_VAR 0 1
62985: PPUSH
62986: CALL_OW 250
62990: PPUSH
62991: LD_VAR 0 1
62995: PPUSH
62996: CALL_OW 251
63000: PPUSH
63001: LD_VAR 0 1
63005: PPUSH
63006: CALL_OW 255
63010: PPUSH
63011: CALL_OW 441
// end ; if btype = b_warehouse then
63015: LD_VAR 0 5
63019: PUSH
63020: LD_INT 1
63022: EQUAL
63023: IFFALSE 63041
// begin btype := b_depot ;
63025: LD_ADDR_VAR 0 5
63029: PUSH
63030: LD_INT 0
63032: ST_TO_ADDR
// pos := 1 ;
63033: LD_ADDR_VAR 0 6
63037: PUSH
63038: LD_INT 1
63040: ST_TO_ADDR
// end ; if btype = b_factory then
63041: LD_VAR 0 5
63045: PUSH
63046: LD_INT 3
63048: EQUAL
63049: IFFALSE 63067
// begin btype := b_workshop ;
63051: LD_ADDR_VAR 0 5
63055: PUSH
63056: LD_INT 2
63058: ST_TO_ADDR
// pos := 1 ;
63059: LD_ADDR_VAR 0 6
63063: PUSH
63064: LD_INT 1
63066: ST_TO_ADDR
// end ; if btype = b_barracks then
63067: LD_VAR 0 5
63071: PUSH
63072: LD_INT 5
63074: EQUAL
63075: IFFALSE 63085
// btype := b_armoury ;
63077: LD_ADDR_VAR 0 5
63081: PUSH
63082: LD_INT 4
63084: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63085: LD_VAR 0 5
63089: PUSH
63090: LD_INT 7
63092: PUSH
63093: LD_INT 8
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: IN
63100: IFFALSE 63110
// btype := b_lab ;
63102: LD_ADDR_VAR 0 5
63106: PUSH
63107: LD_INT 6
63109: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63110: LD_ADDR_EXP 118
63114: PUSH
63115: LD_EXP 118
63119: PPUSH
63120: LD_VAR 0 3
63124: PUSH
63125: LD_EXP 118
63129: PUSH
63130: LD_VAR 0 3
63134: ARRAY
63135: PUSH
63136: LD_INT 1
63138: PLUS
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PPUSH
63144: LD_VAR 0 5
63148: PUSH
63149: LD_VAR 0 1
63153: PPUSH
63154: CALL_OW 250
63158: PUSH
63159: LD_VAR 0 1
63163: PPUSH
63164: CALL_OW 251
63168: PUSH
63169: LD_VAR 0 1
63173: PPUSH
63174: CALL_OW 254
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: LIST
63183: LIST
63184: PPUSH
63185: CALL 70150 0 3
63189: ST_TO_ADDR
// if pos = 1 then
63190: LD_VAR 0 6
63194: PUSH
63195: LD_INT 1
63197: EQUAL
63198: IFFALSE 63313
// begin tmp := mc_build_list [ i ] ;
63200: LD_ADDR_VAR 0 7
63204: PUSH
63205: LD_EXP 118
63209: PUSH
63210: LD_VAR 0 3
63214: ARRAY
63215: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63216: LD_VAR 0 7
63220: PPUSH
63221: LD_INT 2
63223: PUSH
63224: LD_INT 30
63226: PUSH
63227: LD_INT 0
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_INT 30
63236: PUSH
63237: LD_INT 1
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: LIST
63248: PPUSH
63249: CALL_OW 72
63253: IFFALSE 63263
// pos := 2 ;
63255: LD_ADDR_VAR 0 6
63259: PUSH
63260: LD_INT 2
63262: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63263: LD_ADDR_VAR 0 7
63267: PUSH
63268: LD_VAR 0 7
63272: PPUSH
63273: LD_VAR 0 6
63277: PPUSH
63278: LD_VAR 0 7
63282: PPUSH
63283: CALL 70476 0 3
63287: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63288: LD_ADDR_EXP 118
63292: PUSH
63293: LD_EXP 118
63297: PPUSH
63298: LD_VAR 0 3
63302: PPUSH
63303: LD_VAR 0 7
63307: PPUSH
63308: CALL_OW 1
63312: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63313: LD_VAR 0 1
63317: PUSH
63318: LD_EXP 113
63322: PUSH
63323: LD_VAR 0 3
63327: ARRAY
63328: IN
63329: IFFALSE 63368
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63331: LD_ADDR_EXP 113
63335: PUSH
63336: LD_EXP 113
63340: PPUSH
63341: LD_VAR 0 3
63345: PPUSH
63346: LD_EXP 113
63350: PUSH
63351: LD_VAR 0 3
63355: ARRAY
63356: PUSH
63357: LD_VAR 0 1
63361: DIFF
63362: PPUSH
63363: CALL_OW 1
63367: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63368: LD_VAR 0 1
63372: PUSH
63373: LD_EXP 120
63377: PUSH
63378: LD_VAR 0 3
63382: ARRAY
63383: IN
63384: IFFALSE 63423
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63386: LD_ADDR_EXP 120
63390: PUSH
63391: LD_EXP 120
63395: PPUSH
63396: LD_VAR 0 3
63400: PPUSH
63401: LD_EXP 120
63405: PUSH
63406: LD_VAR 0 3
63410: ARRAY
63411: PUSH
63412: LD_VAR 0 1
63416: DIFF
63417: PPUSH
63418: CALL_OW 1
63422: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63423: LD_VAR 0 1
63427: PUSH
63428: LD_EXP 132
63432: PUSH
63433: LD_VAR 0 3
63437: ARRAY
63438: IN
63439: IFFALSE 63478
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63441: LD_ADDR_EXP 132
63445: PUSH
63446: LD_EXP 132
63450: PPUSH
63451: LD_VAR 0 3
63455: PPUSH
63456: LD_EXP 132
63460: PUSH
63461: LD_VAR 0 3
63465: ARRAY
63466: PUSH
63467: LD_VAR 0 1
63471: DIFF
63472: PPUSH
63473: CALL_OW 1
63477: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63478: LD_VAR 0 1
63482: PUSH
63483: LD_EXP 135
63487: PUSH
63488: LD_VAR 0 3
63492: ARRAY
63493: IN
63494: IFFALSE 63533
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63496: LD_ADDR_EXP 135
63500: PUSH
63501: LD_EXP 135
63505: PPUSH
63506: LD_VAR 0 3
63510: PPUSH
63511: LD_EXP 135
63515: PUSH
63516: LD_VAR 0 3
63520: ARRAY
63521: PUSH
63522: LD_VAR 0 1
63526: DIFF
63527: PPUSH
63528: CALL_OW 1
63532: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63533: LD_VAR 0 1
63537: PUSH
63538: LD_EXP 122
63542: PUSH
63543: LD_VAR 0 3
63547: ARRAY
63548: IN
63549: IFFALSE 63588
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63551: LD_ADDR_EXP 122
63555: PUSH
63556: LD_EXP 122
63560: PPUSH
63561: LD_VAR 0 3
63565: PPUSH
63566: LD_EXP 122
63570: PUSH
63571: LD_VAR 0 3
63575: ARRAY
63576: PUSH
63577: LD_VAR 0 1
63581: DIFF
63582: PPUSH
63583: CALL_OW 1
63587: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63588: LD_VAR 0 1
63592: PUSH
63593: LD_EXP 121
63597: PUSH
63598: LD_VAR 0 3
63602: ARRAY
63603: IN
63604: IFFALSE 63643
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63606: LD_ADDR_EXP 121
63610: PUSH
63611: LD_EXP 121
63615: PPUSH
63616: LD_VAR 0 3
63620: PPUSH
63621: LD_EXP 121
63625: PUSH
63626: LD_VAR 0 3
63630: ARRAY
63631: PUSH
63632: LD_VAR 0 1
63636: DIFF
63637: PPUSH
63638: CALL_OW 1
63642: ST_TO_ADDR
// end ; break ;
63643: GO 63647
// end ;
63645: GO 62293
63647: POP
63648: POP
// end ;
63649: LD_VAR 0 2
63653: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63654: LD_INT 0
63656: PPUSH
63657: PPUSH
63658: PPUSH
// if not mc_bases or not skirmish then
63659: LD_EXP 113
63663: NOT
63664: PUSH
63665: LD_EXP 111
63669: NOT
63670: OR
63671: IFFALSE 63675
// exit ;
63673: GO 63890
// for i = 1 to mc_bases do
63675: LD_ADDR_VAR 0 3
63679: PUSH
63680: DOUBLE
63681: LD_INT 1
63683: DEC
63684: ST_TO_ADDR
63685: LD_EXP 113
63689: PUSH
63690: FOR_TO
63691: IFFALSE 63888
// begin if building in mc_construct_list [ i ] then
63693: LD_VAR 0 1
63697: PUSH
63698: LD_EXP 120
63702: PUSH
63703: LD_VAR 0 3
63707: ARRAY
63708: IN
63709: IFFALSE 63886
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63711: LD_ADDR_EXP 120
63715: PUSH
63716: LD_EXP 120
63720: PPUSH
63721: LD_VAR 0 3
63725: PPUSH
63726: LD_EXP 120
63730: PUSH
63731: LD_VAR 0 3
63735: ARRAY
63736: PUSH
63737: LD_VAR 0 1
63741: DIFF
63742: PPUSH
63743: CALL_OW 1
63747: ST_TO_ADDR
// if building in mc_lab [ i ] then
63748: LD_VAR 0 1
63752: PUSH
63753: LD_EXP 146
63757: PUSH
63758: LD_VAR 0 3
63762: ARRAY
63763: IN
63764: IFFALSE 63819
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63766: LD_ADDR_EXP 147
63770: PUSH
63771: LD_EXP 147
63775: PPUSH
63776: LD_VAR 0 3
63780: PPUSH
63781: LD_EXP 147
63785: PUSH
63786: LD_VAR 0 3
63790: ARRAY
63791: PPUSH
63792: LD_INT 1
63794: PPUSH
63795: LD_EXP 147
63799: PUSH
63800: LD_VAR 0 3
63804: ARRAY
63805: PPUSH
63806: LD_INT 0
63808: PPUSH
63809: CALL 69568 0 4
63813: PPUSH
63814: CALL_OW 1
63818: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63819: LD_VAR 0 1
63823: PUSH
63824: LD_EXP 113
63828: PUSH
63829: LD_VAR 0 3
63833: ARRAY
63834: IN
63835: NOT
63836: IFFALSE 63882
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63838: LD_ADDR_EXP 113
63842: PUSH
63843: LD_EXP 113
63847: PPUSH
63848: LD_VAR 0 3
63852: PUSH
63853: LD_EXP 113
63857: PUSH
63858: LD_VAR 0 3
63862: ARRAY
63863: PUSH
63864: LD_INT 1
63866: PLUS
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PPUSH
63872: LD_VAR 0 1
63876: PPUSH
63877: CALL 70150 0 3
63881: ST_TO_ADDR
// exit ;
63882: POP
63883: POP
63884: GO 63890
// end ; end ;
63886: GO 63690
63888: POP
63889: POP
// end ;
63890: LD_VAR 0 2
63894: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63895: LD_INT 0
63897: PPUSH
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
// if not mc_bases or not skirmish then
63904: LD_EXP 113
63908: NOT
63909: PUSH
63910: LD_EXP 111
63914: NOT
63915: OR
63916: IFFALSE 63920
// exit ;
63918: GO 64581
// for i = 1 to mc_bases do
63920: LD_ADDR_VAR 0 3
63924: PUSH
63925: DOUBLE
63926: LD_INT 1
63928: DEC
63929: ST_TO_ADDR
63930: LD_EXP 113
63934: PUSH
63935: FOR_TO
63936: IFFALSE 64579
// begin if building in mc_construct_list [ i ] then
63938: LD_VAR 0 1
63942: PUSH
63943: LD_EXP 120
63947: PUSH
63948: LD_VAR 0 3
63952: ARRAY
63953: IN
63954: IFFALSE 64577
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63956: LD_ADDR_EXP 120
63960: PUSH
63961: LD_EXP 120
63965: PPUSH
63966: LD_VAR 0 3
63970: PPUSH
63971: LD_EXP 120
63975: PUSH
63976: LD_VAR 0 3
63980: ARRAY
63981: PUSH
63982: LD_VAR 0 1
63986: DIFF
63987: PPUSH
63988: CALL_OW 1
63992: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63993: LD_ADDR_EXP 113
63997: PUSH
63998: LD_EXP 113
64002: PPUSH
64003: LD_VAR 0 3
64007: PUSH
64008: LD_EXP 113
64012: PUSH
64013: LD_VAR 0 3
64017: ARRAY
64018: PUSH
64019: LD_INT 1
64021: PLUS
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PPUSH
64027: LD_VAR 0 1
64031: PPUSH
64032: CALL 70150 0 3
64036: ST_TO_ADDR
// btype := GetBType ( building ) ;
64037: LD_ADDR_VAR 0 5
64041: PUSH
64042: LD_VAR 0 1
64046: PPUSH
64047: CALL_OW 266
64051: ST_TO_ADDR
// side := GetSide ( building ) ;
64052: LD_ADDR_VAR 0 8
64056: PUSH
64057: LD_VAR 0 1
64061: PPUSH
64062: CALL_OW 255
64066: ST_TO_ADDR
// if btype = b_lab then
64067: LD_VAR 0 5
64071: PUSH
64072: LD_INT 6
64074: EQUAL
64075: IFFALSE 64125
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64077: LD_ADDR_EXP 146
64081: PUSH
64082: LD_EXP 146
64086: PPUSH
64087: LD_VAR 0 3
64091: PUSH
64092: LD_EXP 146
64096: PUSH
64097: LD_VAR 0 3
64101: ARRAY
64102: PUSH
64103: LD_INT 1
64105: PLUS
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PPUSH
64111: LD_VAR 0 1
64115: PPUSH
64116: CALL 70150 0 3
64120: ST_TO_ADDR
// exit ;
64121: POP
64122: POP
64123: GO 64581
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64125: LD_VAR 0 5
64129: PUSH
64130: LD_INT 0
64132: PUSH
64133: LD_INT 2
64135: PUSH
64136: LD_INT 4
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: LIST
64143: IN
64144: IFFALSE 64268
// begin if btype = b_armoury then
64146: LD_VAR 0 5
64150: PUSH
64151: LD_INT 4
64153: EQUAL
64154: IFFALSE 64164
// btype := b_barracks ;
64156: LD_ADDR_VAR 0 5
64160: PUSH
64161: LD_INT 5
64163: ST_TO_ADDR
// if btype = b_depot then
64164: LD_VAR 0 5
64168: PUSH
64169: LD_INT 0
64171: EQUAL
64172: IFFALSE 64182
// btype := b_warehouse ;
64174: LD_ADDR_VAR 0 5
64178: PUSH
64179: LD_INT 1
64181: ST_TO_ADDR
// if btype = b_workshop then
64182: LD_VAR 0 5
64186: PUSH
64187: LD_INT 2
64189: EQUAL
64190: IFFALSE 64200
// btype := b_factory ;
64192: LD_ADDR_VAR 0 5
64196: PUSH
64197: LD_INT 3
64199: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64200: LD_VAR 0 5
64204: PPUSH
64205: LD_VAR 0 8
64209: PPUSH
64210: CALL_OW 323
64214: PUSH
64215: LD_INT 1
64217: EQUAL
64218: IFFALSE 64264
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64220: LD_ADDR_EXP 145
64224: PUSH
64225: LD_EXP 145
64229: PPUSH
64230: LD_VAR 0 3
64234: PUSH
64235: LD_EXP 145
64239: PUSH
64240: LD_VAR 0 3
64244: ARRAY
64245: PUSH
64246: LD_INT 1
64248: PLUS
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PPUSH
64254: LD_VAR 0 1
64258: PPUSH
64259: CALL 70150 0 3
64263: ST_TO_ADDR
// exit ;
64264: POP
64265: POP
64266: GO 64581
// end ; if btype in [ b_bunker , b_turret ] then
64268: LD_VAR 0 5
64272: PUSH
64273: LD_INT 32
64275: PUSH
64276: LD_INT 33
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: IN
64283: IFFALSE 64573
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64285: LD_ADDR_EXP 121
64289: PUSH
64290: LD_EXP 121
64294: PPUSH
64295: LD_VAR 0 3
64299: PUSH
64300: LD_EXP 121
64304: PUSH
64305: LD_VAR 0 3
64309: ARRAY
64310: PUSH
64311: LD_INT 1
64313: PLUS
64314: PUSH
64315: EMPTY
64316: LIST
64317: LIST
64318: PPUSH
64319: LD_VAR 0 1
64323: PPUSH
64324: CALL 70150 0 3
64328: ST_TO_ADDR
// if btype = b_bunker then
64329: LD_VAR 0 5
64333: PUSH
64334: LD_INT 32
64336: EQUAL
64337: IFFALSE 64573
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64339: LD_ADDR_EXP 122
64343: PUSH
64344: LD_EXP 122
64348: PPUSH
64349: LD_VAR 0 3
64353: PUSH
64354: LD_EXP 122
64358: PUSH
64359: LD_VAR 0 3
64363: ARRAY
64364: PUSH
64365: LD_INT 1
64367: PLUS
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PPUSH
64373: LD_VAR 0 1
64377: PPUSH
64378: CALL 70150 0 3
64382: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64383: LD_ADDR_VAR 0 6
64387: PUSH
64388: LD_EXP 113
64392: PUSH
64393: LD_VAR 0 3
64397: ARRAY
64398: PPUSH
64399: LD_INT 25
64401: PUSH
64402: LD_INT 1
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 3
64411: PUSH
64412: LD_INT 54
64414: PUSH
64415: EMPTY
64416: LIST
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: PPUSH
64426: CALL_OW 72
64430: ST_TO_ADDR
// if tmp then
64431: LD_VAR 0 6
64435: IFFALSE 64441
// exit ;
64437: POP
64438: POP
64439: GO 64581
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64441: LD_ADDR_VAR 0 6
64445: PUSH
64446: LD_EXP 113
64450: PUSH
64451: LD_VAR 0 3
64455: ARRAY
64456: PPUSH
64457: LD_INT 2
64459: PUSH
64460: LD_INT 30
64462: PUSH
64463: LD_INT 4
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: LD_INT 30
64472: PUSH
64473: LD_INT 5
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: LIST
64484: PPUSH
64485: CALL_OW 72
64489: ST_TO_ADDR
// if not tmp then
64490: LD_VAR 0 6
64494: NOT
64495: IFFALSE 64501
// exit ;
64497: POP
64498: POP
64499: GO 64581
// for j in tmp do
64501: LD_ADDR_VAR 0 4
64505: PUSH
64506: LD_VAR 0 6
64510: PUSH
64511: FOR_IN
64512: IFFALSE 64571
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64514: LD_ADDR_VAR 0 7
64518: PUSH
64519: LD_VAR 0 4
64523: PPUSH
64524: CALL_OW 313
64528: PPUSH
64529: LD_INT 25
64531: PUSH
64532: LD_INT 1
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PPUSH
64539: CALL_OW 72
64543: ST_TO_ADDR
// if units then
64544: LD_VAR 0 7
64548: IFFALSE 64569
// begin ComExitBuilding ( units [ 1 ] ) ;
64550: LD_VAR 0 7
64554: PUSH
64555: LD_INT 1
64557: ARRAY
64558: PPUSH
64559: CALL_OW 122
// exit ;
64563: POP
64564: POP
64565: POP
64566: POP
64567: GO 64581
// end ; end ;
64569: GO 64511
64571: POP
64572: POP
// end ; end ; exit ;
64573: POP
64574: POP
64575: GO 64581
// end ; end ;
64577: GO 63935
64579: POP
64580: POP
// end ;
64581: LD_VAR 0 2
64585: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64586: LD_INT 0
64588: PPUSH
64589: PPUSH
64590: PPUSH
64591: PPUSH
64592: PPUSH
64593: PPUSH
64594: PPUSH
// if not mc_bases or not skirmish then
64595: LD_EXP 113
64599: NOT
64600: PUSH
64601: LD_EXP 111
64605: NOT
64606: OR
64607: IFFALSE 64611
// exit ;
64609: GO 64842
// btype := GetBType ( building ) ;
64611: LD_ADDR_VAR 0 6
64615: PUSH
64616: LD_VAR 0 1
64620: PPUSH
64621: CALL_OW 266
64625: ST_TO_ADDR
// x := GetX ( building ) ;
64626: LD_ADDR_VAR 0 7
64630: PUSH
64631: LD_VAR 0 1
64635: PPUSH
64636: CALL_OW 250
64640: ST_TO_ADDR
// y := GetY ( building ) ;
64641: LD_ADDR_VAR 0 8
64645: PUSH
64646: LD_VAR 0 1
64650: PPUSH
64651: CALL_OW 251
64655: ST_TO_ADDR
// d := GetDir ( building ) ;
64656: LD_ADDR_VAR 0 9
64660: PUSH
64661: LD_VAR 0 1
64665: PPUSH
64666: CALL_OW 254
64670: ST_TO_ADDR
// for i = 1 to mc_bases do
64671: LD_ADDR_VAR 0 4
64675: PUSH
64676: DOUBLE
64677: LD_INT 1
64679: DEC
64680: ST_TO_ADDR
64681: LD_EXP 113
64685: PUSH
64686: FOR_TO
64687: IFFALSE 64840
// begin if not mc_build_list [ i ] then
64689: LD_EXP 118
64693: PUSH
64694: LD_VAR 0 4
64698: ARRAY
64699: NOT
64700: IFFALSE 64704
// continue ;
64702: GO 64686
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64704: LD_VAR 0 6
64708: PUSH
64709: LD_VAR 0 7
64713: PUSH
64714: LD_VAR 0 8
64718: PUSH
64719: LD_VAR 0 9
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: PPUSH
64730: LD_EXP 118
64734: PUSH
64735: LD_VAR 0 4
64739: ARRAY
64740: PUSH
64741: LD_INT 1
64743: ARRAY
64744: PPUSH
64745: CALL 76319 0 2
64749: IFFALSE 64838
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64751: LD_ADDR_EXP 118
64755: PUSH
64756: LD_EXP 118
64760: PPUSH
64761: LD_VAR 0 4
64765: PPUSH
64766: LD_EXP 118
64770: PUSH
64771: LD_VAR 0 4
64775: ARRAY
64776: PPUSH
64777: LD_INT 1
64779: PPUSH
64780: CALL_OW 3
64784: PPUSH
64785: CALL_OW 1
64789: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64790: LD_ADDR_EXP 120
64794: PUSH
64795: LD_EXP 120
64799: PPUSH
64800: LD_VAR 0 4
64804: PUSH
64805: LD_EXP 120
64809: PUSH
64810: LD_VAR 0 4
64814: ARRAY
64815: PUSH
64816: LD_INT 1
64818: PLUS
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PPUSH
64824: LD_VAR 0 1
64828: PPUSH
64829: CALL 70150 0 3
64833: ST_TO_ADDR
// exit ;
64834: POP
64835: POP
64836: GO 64842
// end ; end ;
64838: GO 64686
64840: POP
64841: POP
// end ;
64842: LD_VAR 0 3
64846: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64847: LD_INT 0
64849: PPUSH
64850: PPUSH
64851: PPUSH
// if not mc_bases or not skirmish then
64852: LD_EXP 113
64856: NOT
64857: PUSH
64858: LD_EXP 111
64862: NOT
64863: OR
64864: IFFALSE 64868
// exit ;
64866: GO 65058
// for i = 1 to mc_bases do
64868: LD_ADDR_VAR 0 4
64872: PUSH
64873: DOUBLE
64874: LD_INT 1
64876: DEC
64877: ST_TO_ADDR
64878: LD_EXP 113
64882: PUSH
64883: FOR_TO
64884: IFFALSE 64971
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64886: LD_VAR 0 1
64890: PUSH
64891: LD_EXP 121
64895: PUSH
64896: LD_VAR 0 4
64900: ARRAY
64901: IN
64902: PUSH
64903: LD_VAR 0 1
64907: PUSH
64908: LD_EXP 122
64912: PUSH
64913: LD_VAR 0 4
64917: ARRAY
64918: IN
64919: NOT
64920: AND
64921: IFFALSE 64969
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64923: LD_ADDR_EXP 122
64927: PUSH
64928: LD_EXP 122
64932: PPUSH
64933: LD_VAR 0 4
64937: PUSH
64938: LD_EXP 122
64942: PUSH
64943: LD_VAR 0 4
64947: ARRAY
64948: PUSH
64949: LD_INT 1
64951: PLUS
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PPUSH
64957: LD_VAR 0 1
64961: PPUSH
64962: CALL 70150 0 3
64966: ST_TO_ADDR
// break ;
64967: GO 64971
// end ; end ;
64969: GO 64883
64971: POP
64972: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64973: LD_VAR 0 1
64977: PPUSH
64978: CALL_OW 257
64982: PUSH
64983: LD_EXP 139
64987: IN
64988: PUSH
64989: LD_VAR 0 1
64993: PPUSH
64994: CALL_OW 266
64998: PUSH
64999: LD_INT 5
65001: EQUAL
65002: AND
65003: PUSH
65004: LD_VAR 0 2
65008: PPUSH
65009: CALL_OW 110
65013: PUSH
65014: LD_INT 18
65016: NONEQUAL
65017: AND
65018: IFFALSE 65058
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65020: LD_VAR 0 2
65024: PPUSH
65025: CALL_OW 257
65029: PUSH
65030: LD_INT 5
65032: PUSH
65033: LD_INT 8
65035: PUSH
65036: LD_INT 9
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: LIST
65043: IN
65044: IFFALSE 65058
// SetClass ( unit , 1 ) ;
65046: LD_VAR 0 2
65050: PPUSH
65051: LD_INT 1
65053: PPUSH
65054: CALL_OW 336
// end ;
65058: LD_VAR 0 3
65062: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65063: LD_INT 0
65065: PPUSH
65066: PPUSH
// if not mc_bases or not skirmish then
65067: LD_EXP 113
65071: NOT
65072: PUSH
65073: LD_EXP 111
65077: NOT
65078: OR
65079: IFFALSE 65083
// exit ;
65081: GO 65199
// if GetLives ( abandoned_vehicle ) > 250 then
65083: LD_VAR 0 2
65087: PPUSH
65088: CALL_OW 256
65092: PUSH
65093: LD_INT 250
65095: GREATER
65096: IFFALSE 65100
// exit ;
65098: GO 65199
// for i = 1 to mc_bases do
65100: LD_ADDR_VAR 0 6
65104: PUSH
65105: DOUBLE
65106: LD_INT 1
65108: DEC
65109: ST_TO_ADDR
65110: LD_EXP 113
65114: PUSH
65115: FOR_TO
65116: IFFALSE 65197
// begin if driver in mc_bases [ i ] then
65118: LD_VAR 0 1
65122: PUSH
65123: LD_EXP 113
65127: PUSH
65128: LD_VAR 0 6
65132: ARRAY
65133: IN
65134: IFFALSE 65195
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65136: LD_VAR 0 1
65140: PPUSH
65141: LD_EXP 113
65145: PUSH
65146: LD_VAR 0 6
65150: ARRAY
65151: PPUSH
65152: LD_INT 2
65154: PUSH
65155: LD_INT 30
65157: PUSH
65158: LD_INT 0
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PUSH
65165: LD_INT 30
65167: PUSH
65168: LD_INT 1
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: LIST
65179: PPUSH
65180: CALL_OW 72
65184: PUSH
65185: LD_INT 1
65187: ARRAY
65188: PPUSH
65189: CALL 102016 0 2
// break ;
65193: GO 65197
// end ; end ;
65195: GO 65115
65197: POP
65198: POP
// end ; end_of_file
65199: LD_VAR 0 5
65203: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65204: LD_INT 0
65206: PPUSH
65207: PPUSH
// if exist_mode then
65208: LD_VAR 0 2
65212: IFFALSE 65237
// unit := CreateCharacter ( prefix & ident ) else
65214: LD_ADDR_VAR 0 5
65218: PUSH
65219: LD_VAR 0 3
65223: PUSH
65224: LD_VAR 0 1
65228: STR
65229: PPUSH
65230: CALL_OW 34
65234: ST_TO_ADDR
65235: GO 65252
// unit := NewCharacter ( ident ) ;
65237: LD_ADDR_VAR 0 5
65241: PUSH
65242: LD_VAR 0 1
65246: PPUSH
65247: CALL_OW 25
65251: ST_TO_ADDR
// result := unit ;
65252: LD_ADDR_VAR 0 4
65256: PUSH
65257: LD_VAR 0 5
65261: ST_TO_ADDR
// end ;
65262: LD_VAR 0 4
65266: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65267: LD_INT 0
65269: PPUSH
65270: PPUSH
// if not side or not nation then
65271: LD_VAR 0 1
65275: NOT
65276: PUSH
65277: LD_VAR 0 2
65281: NOT
65282: OR
65283: IFFALSE 65287
// exit ;
65285: GO 66051
// case nation of nation_american :
65287: LD_VAR 0 2
65291: PUSH
65292: LD_INT 1
65294: DOUBLE
65295: EQUAL
65296: IFTRUE 65300
65298: GO 65514
65300: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65301: LD_ADDR_VAR 0 4
65305: PUSH
65306: LD_INT 35
65308: PUSH
65309: LD_INT 45
65311: PUSH
65312: LD_INT 46
65314: PUSH
65315: LD_INT 47
65317: PUSH
65318: LD_INT 82
65320: PUSH
65321: LD_INT 83
65323: PUSH
65324: LD_INT 84
65326: PUSH
65327: LD_INT 85
65329: PUSH
65330: LD_INT 86
65332: PUSH
65333: LD_INT 1
65335: PUSH
65336: LD_INT 2
65338: PUSH
65339: LD_INT 6
65341: PUSH
65342: LD_INT 15
65344: PUSH
65345: LD_INT 16
65347: PUSH
65348: LD_INT 7
65350: PUSH
65351: LD_INT 12
65353: PUSH
65354: LD_INT 13
65356: PUSH
65357: LD_INT 10
65359: PUSH
65360: LD_INT 14
65362: PUSH
65363: LD_INT 20
65365: PUSH
65366: LD_INT 21
65368: PUSH
65369: LD_INT 22
65371: PUSH
65372: LD_INT 25
65374: PUSH
65375: LD_INT 32
65377: PUSH
65378: LD_INT 27
65380: PUSH
65381: LD_INT 36
65383: PUSH
65384: LD_INT 69
65386: PUSH
65387: LD_INT 39
65389: PUSH
65390: LD_INT 34
65392: PUSH
65393: LD_INT 40
65395: PUSH
65396: LD_INT 48
65398: PUSH
65399: LD_INT 49
65401: PUSH
65402: LD_INT 50
65404: PUSH
65405: LD_INT 51
65407: PUSH
65408: LD_INT 52
65410: PUSH
65411: LD_INT 53
65413: PUSH
65414: LD_INT 54
65416: PUSH
65417: LD_INT 55
65419: PUSH
65420: LD_INT 56
65422: PUSH
65423: LD_INT 57
65425: PUSH
65426: LD_INT 58
65428: PUSH
65429: LD_INT 59
65431: PUSH
65432: LD_INT 60
65434: PUSH
65435: LD_INT 61
65437: PUSH
65438: LD_INT 62
65440: PUSH
65441: LD_INT 80
65443: PUSH
65444: LD_INT 82
65446: PUSH
65447: LD_INT 83
65449: PUSH
65450: LD_INT 84
65452: PUSH
65453: LD_INT 85
65455: PUSH
65456: LD_INT 86
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: ST_TO_ADDR
65512: GO 65975
65514: LD_INT 2
65516: DOUBLE
65517: EQUAL
65518: IFTRUE 65522
65520: GO 65744
65522: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65523: LD_ADDR_VAR 0 4
65527: PUSH
65528: LD_INT 35
65530: PUSH
65531: LD_INT 45
65533: PUSH
65534: LD_INT 46
65536: PUSH
65537: LD_INT 47
65539: PUSH
65540: LD_INT 82
65542: PUSH
65543: LD_INT 83
65545: PUSH
65546: LD_INT 84
65548: PUSH
65549: LD_INT 85
65551: PUSH
65552: LD_INT 87
65554: PUSH
65555: LD_INT 70
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 11
65563: PUSH
65564: LD_INT 3
65566: PUSH
65567: LD_INT 4
65569: PUSH
65570: LD_INT 5
65572: PUSH
65573: LD_INT 6
65575: PUSH
65576: LD_INT 15
65578: PUSH
65579: LD_INT 18
65581: PUSH
65582: LD_INT 7
65584: PUSH
65585: LD_INT 17
65587: PUSH
65588: LD_INT 8
65590: PUSH
65591: LD_INT 20
65593: PUSH
65594: LD_INT 21
65596: PUSH
65597: LD_INT 22
65599: PUSH
65600: LD_INT 72
65602: PUSH
65603: LD_INT 26
65605: PUSH
65606: LD_INT 69
65608: PUSH
65609: LD_INT 39
65611: PUSH
65612: LD_INT 40
65614: PUSH
65615: LD_INT 41
65617: PUSH
65618: LD_INT 42
65620: PUSH
65621: LD_INT 43
65623: PUSH
65624: LD_INT 48
65626: PUSH
65627: LD_INT 49
65629: PUSH
65630: LD_INT 50
65632: PUSH
65633: LD_INT 51
65635: PUSH
65636: LD_INT 52
65638: PUSH
65639: LD_INT 53
65641: PUSH
65642: LD_INT 54
65644: PUSH
65645: LD_INT 55
65647: PUSH
65648: LD_INT 56
65650: PUSH
65651: LD_INT 60
65653: PUSH
65654: LD_INT 61
65656: PUSH
65657: LD_INT 62
65659: PUSH
65660: LD_INT 66
65662: PUSH
65663: LD_INT 67
65665: PUSH
65666: LD_INT 68
65668: PUSH
65669: LD_INT 81
65671: PUSH
65672: LD_INT 82
65674: PUSH
65675: LD_INT 83
65677: PUSH
65678: LD_INT 84
65680: PUSH
65681: LD_INT 85
65683: PUSH
65684: LD_INT 87
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: ST_TO_ADDR
65742: GO 65975
65744: LD_INT 3
65746: DOUBLE
65747: EQUAL
65748: IFTRUE 65752
65750: GO 65974
65752: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65753: LD_ADDR_VAR 0 4
65757: PUSH
65758: LD_INT 46
65760: PUSH
65761: LD_INT 47
65763: PUSH
65764: LD_INT 1
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: LD_INT 82
65772: PUSH
65773: LD_INT 83
65775: PUSH
65776: LD_INT 84
65778: PUSH
65779: LD_INT 85
65781: PUSH
65782: LD_INT 86
65784: PUSH
65785: LD_INT 11
65787: PUSH
65788: LD_INT 9
65790: PUSH
65791: LD_INT 20
65793: PUSH
65794: LD_INT 19
65796: PUSH
65797: LD_INT 21
65799: PUSH
65800: LD_INT 24
65802: PUSH
65803: LD_INT 22
65805: PUSH
65806: LD_INT 25
65808: PUSH
65809: LD_INT 28
65811: PUSH
65812: LD_INT 29
65814: PUSH
65815: LD_INT 30
65817: PUSH
65818: LD_INT 31
65820: PUSH
65821: LD_INT 37
65823: PUSH
65824: LD_INT 38
65826: PUSH
65827: LD_INT 32
65829: PUSH
65830: LD_INT 27
65832: PUSH
65833: LD_INT 33
65835: PUSH
65836: LD_INT 69
65838: PUSH
65839: LD_INT 39
65841: PUSH
65842: LD_INT 34
65844: PUSH
65845: LD_INT 40
65847: PUSH
65848: LD_INT 71
65850: PUSH
65851: LD_INT 23
65853: PUSH
65854: LD_INT 44
65856: PUSH
65857: LD_INT 48
65859: PUSH
65860: LD_INT 49
65862: PUSH
65863: LD_INT 50
65865: PUSH
65866: LD_INT 51
65868: PUSH
65869: LD_INT 52
65871: PUSH
65872: LD_INT 53
65874: PUSH
65875: LD_INT 54
65877: PUSH
65878: LD_INT 55
65880: PUSH
65881: LD_INT 56
65883: PUSH
65884: LD_INT 57
65886: PUSH
65887: LD_INT 58
65889: PUSH
65890: LD_INT 59
65892: PUSH
65893: LD_INT 63
65895: PUSH
65896: LD_INT 64
65898: PUSH
65899: LD_INT 65
65901: PUSH
65902: LD_INT 82
65904: PUSH
65905: LD_INT 83
65907: PUSH
65908: LD_INT 84
65910: PUSH
65911: LD_INT 85
65913: PUSH
65914: LD_INT 86
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: ST_TO_ADDR
65972: GO 65975
65974: POP
// if state > - 1 and state < 3 then
65975: LD_VAR 0 3
65979: PUSH
65980: LD_INT 1
65982: NEG
65983: GREATER
65984: PUSH
65985: LD_VAR 0 3
65989: PUSH
65990: LD_INT 3
65992: LESS
65993: AND
65994: IFFALSE 66051
// for i in result do
65996: LD_ADDR_VAR 0 5
66000: PUSH
66001: LD_VAR 0 4
66005: PUSH
66006: FOR_IN
66007: IFFALSE 66049
// if GetTech ( i , side ) <> state then
66009: LD_VAR 0 5
66013: PPUSH
66014: LD_VAR 0 1
66018: PPUSH
66019: CALL_OW 321
66023: PUSH
66024: LD_VAR 0 3
66028: NONEQUAL
66029: IFFALSE 66047
// result := result diff i ;
66031: LD_ADDR_VAR 0 4
66035: PUSH
66036: LD_VAR 0 4
66040: PUSH
66041: LD_VAR 0 5
66045: DIFF
66046: ST_TO_ADDR
66047: GO 66006
66049: POP
66050: POP
// end ;
66051: LD_VAR 0 4
66055: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66056: LD_INT 0
66058: PPUSH
66059: PPUSH
66060: PPUSH
// result := true ;
66061: LD_ADDR_VAR 0 3
66065: PUSH
66066: LD_INT 1
66068: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66069: LD_ADDR_VAR 0 5
66073: PUSH
66074: LD_VAR 0 2
66078: PPUSH
66079: CALL_OW 480
66083: ST_TO_ADDR
// if not tmp then
66084: LD_VAR 0 5
66088: NOT
66089: IFFALSE 66093
// exit ;
66091: GO 66142
// for i in tmp do
66093: LD_ADDR_VAR 0 4
66097: PUSH
66098: LD_VAR 0 5
66102: PUSH
66103: FOR_IN
66104: IFFALSE 66140
// if GetTech ( i , side ) <> state_researched then
66106: LD_VAR 0 4
66110: PPUSH
66111: LD_VAR 0 1
66115: PPUSH
66116: CALL_OW 321
66120: PUSH
66121: LD_INT 2
66123: NONEQUAL
66124: IFFALSE 66138
// begin result := false ;
66126: LD_ADDR_VAR 0 3
66130: PUSH
66131: LD_INT 0
66133: ST_TO_ADDR
// exit ;
66134: POP
66135: POP
66136: GO 66142
// end ;
66138: GO 66103
66140: POP
66141: POP
// end ;
66142: LD_VAR 0 3
66146: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66147: LD_INT 0
66149: PPUSH
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66162: LD_VAR 0 1
66166: NOT
66167: PUSH
66168: LD_VAR 0 1
66172: PPUSH
66173: CALL_OW 257
66177: PUSH
66178: LD_INT 9
66180: NONEQUAL
66181: OR
66182: IFFALSE 66186
// exit ;
66184: GO 66759
// side := GetSide ( unit ) ;
66186: LD_ADDR_VAR 0 9
66190: PUSH
66191: LD_VAR 0 1
66195: PPUSH
66196: CALL_OW 255
66200: ST_TO_ADDR
// tech_space := tech_spacanom ;
66201: LD_ADDR_VAR 0 12
66205: PUSH
66206: LD_INT 29
66208: ST_TO_ADDR
// tech_time := tech_taurad ;
66209: LD_ADDR_VAR 0 13
66213: PUSH
66214: LD_INT 28
66216: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66217: LD_ADDR_VAR 0 11
66221: PUSH
66222: LD_VAR 0 1
66226: PPUSH
66227: CALL_OW 310
66231: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66232: LD_VAR 0 11
66236: PPUSH
66237: CALL_OW 247
66241: PUSH
66242: LD_INT 2
66244: EQUAL
66245: IFFALSE 66249
// exit ;
66247: GO 66759
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66249: LD_ADDR_VAR 0 8
66253: PUSH
66254: LD_INT 81
66256: PUSH
66257: LD_VAR 0 9
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: LD_INT 21
66271: PUSH
66272: LD_INT 3
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PPUSH
66287: CALL_OW 69
66291: ST_TO_ADDR
// if not tmp then
66292: LD_VAR 0 8
66296: NOT
66297: IFFALSE 66301
// exit ;
66299: GO 66759
// if in_unit then
66301: LD_VAR 0 11
66305: IFFALSE 66329
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66307: LD_ADDR_VAR 0 10
66311: PUSH
66312: LD_VAR 0 8
66316: PPUSH
66317: LD_VAR 0 11
66321: PPUSH
66322: CALL_OW 74
66326: ST_TO_ADDR
66327: GO 66349
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66329: LD_ADDR_VAR 0 10
66333: PUSH
66334: LD_VAR 0 8
66338: PPUSH
66339: LD_VAR 0 1
66343: PPUSH
66344: CALL_OW 74
66348: ST_TO_ADDR
// if not enemy then
66349: LD_VAR 0 10
66353: NOT
66354: IFFALSE 66358
// exit ;
66356: GO 66759
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66358: LD_VAR 0 11
66362: PUSH
66363: LD_VAR 0 11
66367: PPUSH
66368: LD_VAR 0 10
66372: PPUSH
66373: CALL_OW 296
66377: PUSH
66378: LD_INT 13
66380: GREATER
66381: AND
66382: PUSH
66383: LD_VAR 0 1
66387: PPUSH
66388: LD_VAR 0 10
66392: PPUSH
66393: CALL_OW 296
66397: PUSH
66398: LD_INT 12
66400: GREATER
66401: OR
66402: IFFALSE 66406
// exit ;
66404: GO 66759
// missile := [ 1 ] ;
66406: LD_ADDR_VAR 0 14
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: EMPTY
66415: LIST
66416: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66417: LD_VAR 0 9
66421: PPUSH
66422: LD_VAR 0 12
66426: PPUSH
66427: CALL_OW 325
66431: IFFALSE 66460
// missile := Insert ( missile , missile + 1 , 2 ) ;
66433: LD_ADDR_VAR 0 14
66437: PUSH
66438: LD_VAR 0 14
66442: PPUSH
66443: LD_VAR 0 14
66447: PUSH
66448: LD_INT 1
66450: PLUS
66451: PPUSH
66452: LD_INT 2
66454: PPUSH
66455: CALL_OW 2
66459: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66460: LD_VAR 0 9
66464: PPUSH
66465: LD_VAR 0 13
66469: PPUSH
66470: CALL_OW 325
66474: PUSH
66475: LD_VAR 0 10
66479: PPUSH
66480: CALL_OW 255
66484: PPUSH
66485: LD_VAR 0 13
66489: PPUSH
66490: CALL_OW 325
66494: NOT
66495: AND
66496: IFFALSE 66525
// missile := Insert ( missile , missile + 1 , 3 ) ;
66498: LD_ADDR_VAR 0 14
66502: PUSH
66503: LD_VAR 0 14
66507: PPUSH
66508: LD_VAR 0 14
66512: PUSH
66513: LD_INT 1
66515: PLUS
66516: PPUSH
66517: LD_INT 3
66519: PPUSH
66520: CALL_OW 2
66524: ST_TO_ADDR
// if missile < 2 then
66525: LD_VAR 0 14
66529: PUSH
66530: LD_INT 2
66532: LESS
66533: IFFALSE 66537
// exit ;
66535: GO 66759
// x := GetX ( enemy ) ;
66537: LD_ADDR_VAR 0 4
66541: PUSH
66542: LD_VAR 0 10
66546: PPUSH
66547: CALL_OW 250
66551: ST_TO_ADDR
// y := GetY ( enemy ) ;
66552: LD_ADDR_VAR 0 5
66556: PUSH
66557: LD_VAR 0 10
66561: PPUSH
66562: CALL_OW 251
66566: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66567: LD_ADDR_VAR 0 6
66571: PUSH
66572: LD_VAR 0 4
66576: PUSH
66577: LD_INT 1
66579: NEG
66580: PPUSH
66581: LD_INT 1
66583: PPUSH
66584: CALL_OW 12
66588: PLUS
66589: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66590: LD_ADDR_VAR 0 7
66594: PUSH
66595: LD_VAR 0 5
66599: PUSH
66600: LD_INT 1
66602: NEG
66603: PPUSH
66604: LD_INT 1
66606: PPUSH
66607: CALL_OW 12
66611: PLUS
66612: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66613: LD_VAR 0 6
66617: PPUSH
66618: LD_VAR 0 7
66622: PPUSH
66623: CALL_OW 488
66627: NOT
66628: IFFALSE 66650
// begin _x := x ;
66630: LD_ADDR_VAR 0 6
66634: PUSH
66635: LD_VAR 0 4
66639: ST_TO_ADDR
// _y := y ;
66640: LD_ADDR_VAR 0 7
66644: PUSH
66645: LD_VAR 0 5
66649: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66650: LD_ADDR_VAR 0 3
66654: PUSH
66655: LD_INT 1
66657: PPUSH
66658: LD_VAR 0 14
66662: PPUSH
66663: CALL_OW 12
66667: ST_TO_ADDR
// case i of 1 :
66668: LD_VAR 0 3
66672: PUSH
66673: LD_INT 1
66675: DOUBLE
66676: EQUAL
66677: IFTRUE 66681
66679: GO 66698
66681: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66682: LD_VAR 0 1
66686: PPUSH
66687: LD_VAR 0 10
66691: PPUSH
66692: CALL_OW 115
66696: GO 66759
66698: LD_INT 2
66700: DOUBLE
66701: EQUAL
66702: IFTRUE 66706
66704: GO 66728
66706: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66707: LD_VAR 0 1
66711: PPUSH
66712: LD_VAR 0 6
66716: PPUSH
66717: LD_VAR 0 7
66721: PPUSH
66722: CALL_OW 153
66726: GO 66759
66728: LD_INT 3
66730: DOUBLE
66731: EQUAL
66732: IFTRUE 66736
66734: GO 66758
66736: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66737: LD_VAR 0 1
66741: PPUSH
66742: LD_VAR 0 6
66746: PPUSH
66747: LD_VAR 0 7
66751: PPUSH
66752: CALL_OW 154
66756: GO 66759
66758: POP
// end ;
66759: LD_VAR 0 2
66763: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66764: LD_INT 0
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
// if not unit or not building then
66772: LD_VAR 0 1
66776: NOT
66777: PUSH
66778: LD_VAR 0 2
66782: NOT
66783: OR
66784: IFFALSE 66788
// exit ;
66786: GO 66946
// x := GetX ( building ) ;
66788: LD_ADDR_VAR 0 5
66792: PUSH
66793: LD_VAR 0 2
66797: PPUSH
66798: CALL_OW 250
66802: ST_TO_ADDR
// y := GetY ( building ) ;
66803: LD_ADDR_VAR 0 6
66807: PUSH
66808: LD_VAR 0 2
66812: PPUSH
66813: CALL_OW 251
66817: ST_TO_ADDR
// for i = 0 to 5 do
66818: LD_ADDR_VAR 0 4
66822: PUSH
66823: DOUBLE
66824: LD_INT 0
66826: DEC
66827: ST_TO_ADDR
66828: LD_INT 5
66830: PUSH
66831: FOR_TO
66832: IFFALSE 66944
// begin _x := ShiftX ( x , i , 3 ) ;
66834: LD_ADDR_VAR 0 7
66838: PUSH
66839: LD_VAR 0 5
66843: PPUSH
66844: LD_VAR 0 4
66848: PPUSH
66849: LD_INT 3
66851: PPUSH
66852: CALL_OW 272
66856: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66857: LD_ADDR_VAR 0 8
66861: PUSH
66862: LD_VAR 0 6
66866: PPUSH
66867: LD_VAR 0 4
66871: PPUSH
66872: LD_INT 3
66874: PPUSH
66875: CALL_OW 273
66879: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66880: LD_VAR 0 7
66884: PPUSH
66885: LD_VAR 0 8
66889: PPUSH
66890: CALL_OW 488
66894: NOT
66895: IFFALSE 66899
// continue ;
66897: GO 66831
// if HexInfo ( _x , _y ) = 0 then
66899: LD_VAR 0 7
66903: PPUSH
66904: LD_VAR 0 8
66908: PPUSH
66909: CALL_OW 428
66913: PUSH
66914: LD_INT 0
66916: EQUAL
66917: IFFALSE 66942
// begin ComMoveXY ( unit , _x , _y ) ;
66919: LD_VAR 0 1
66923: PPUSH
66924: LD_VAR 0 7
66928: PPUSH
66929: LD_VAR 0 8
66933: PPUSH
66934: CALL_OW 111
// exit ;
66938: POP
66939: POP
66940: GO 66946
// end ; end ;
66942: GO 66831
66944: POP
66945: POP
// end ;
66946: LD_VAR 0 3
66950: RET
// export function ScanBase ( side , base_area ) ; begin
66951: LD_INT 0
66953: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66954: LD_ADDR_VAR 0 3
66958: PUSH
66959: LD_VAR 0 2
66963: PPUSH
66964: LD_INT 81
66966: PUSH
66967: LD_VAR 0 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PPUSH
66976: CALL_OW 70
66980: ST_TO_ADDR
// end ;
66981: LD_VAR 0 3
66985: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66986: LD_INT 0
66988: PPUSH
66989: PPUSH
66990: PPUSH
66991: PPUSH
// result := false ;
66992: LD_ADDR_VAR 0 2
66996: PUSH
66997: LD_INT 0
66999: ST_TO_ADDR
// side := GetSide ( unit ) ;
67000: LD_ADDR_VAR 0 3
67004: PUSH
67005: LD_VAR 0 1
67009: PPUSH
67010: CALL_OW 255
67014: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67015: LD_ADDR_VAR 0 4
67019: PUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL_OW 248
67029: ST_TO_ADDR
// case nat of 1 :
67030: LD_VAR 0 4
67034: PUSH
67035: LD_INT 1
67037: DOUBLE
67038: EQUAL
67039: IFTRUE 67043
67041: GO 67054
67043: POP
// tech := tech_lassight ; 2 :
67044: LD_ADDR_VAR 0 5
67048: PUSH
67049: LD_INT 12
67051: ST_TO_ADDR
67052: GO 67093
67054: LD_INT 2
67056: DOUBLE
67057: EQUAL
67058: IFTRUE 67062
67060: GO 67073
67062: POP
// tech := tech_mortar ; 3 :
67063: LD_ADDR_VAR 0 5
67067: PUSH
67068: LD_INT 41
67070: ST_TO_ADDR
67071: GO 67093
67073: LD_INT 3
67075: DOUBLE
67076: EQUAL
67077: IFTRUE 67081
67079: GO 67092
67081: POP
// tech := tech_bazooka ; end ;
67082: LD_ADDR_VAR 0 5
67086: PUSH
67087: LD_INT 44
67089: ST_TO_ADDR
67090: GO 67093
67092: POP
// if Researched ( side , tech ) then
67093: LD_VAR 0 3
67097: PPUSH
67098: LD_VAR 0 5
67102: PPUSH
67103: CALL_OW 325
67107: IFFALSE 67134
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67109: LD_ADDR_VAR 0 2
67113: PUSH
67114: LD_INT 5
67116: PUSH
67117: LD_INT 8
67119: PUSH
67120: LD_INT 9
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: LIST
67127: PUSH
67128: LD_VAR 0 4
67132: ARRAY
67133: ST_TO_ADDR
// end ;
67134: LD_VAR 0 2
67138: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67139: LD_INT 0
67141: PPUSH
67142: PPUSH
67143: PPUSH
// if not mines then
67144: LD_VAR 0 2
67148: NOT
67149: IFFALSE 67153
// exit ;
67151: GO 67297
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67153: LD_ADDR_VAR 0 5
67157: PUSH
67158: LD_INT 81
67160: PUSH
67161: LD_VAR 0 1
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 3
67172: PUSH
67173: LD_INT 21
67175: PUSH
67176: LD_INT 3
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PPUSH
67191: CALL_OW 69
67195: ST_TO_ADDR
// for i in mines do
67196: LD_ADDR_VAR 0 4
67200: PUSH
67201: LD_VAR 0 2
67205: PUSH
67206: FOR_IN
67207: IFFALSE 67295
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67209: LD_VAR 0 4
67213: PUSH
67214: LD_INT 1
67216: ARRAY
67217: PPUSH
67218: LD_VAR 0 4
67222: PUSH
67223: LD_INT 2
67225: ARRAY
67226: PPUSH
67227: CALL_OW 458
67231: NOT
67232: IFFALSE 67236
// continue ;
67234: GO 67206
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67236: LD_VAR 0 4
67240: PUSH
67241: LD_INT 1
67243: ARRAY
67244: PPUSH
67245: LD_VAR 0 4
67249: PUSH
67250: LD_INT 2
67252: ARRAY
67253: PPUSH
67254: CALL_OW 428
67258: PUSH
67259: LD_VAR 0 5
67263: IN
67264: IFFALSE 67293
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67266: LD_VAR 0 4
67270: PUSH
67271: LD_INT 1
67273: ARRAY
67274: PPUSH
67275: LD_VAR 0 4
67279: PUSH
67280: LD_INT 2
67282: ARRAY
67283: PPUSH
67284: LD_VAR 0 1
67288: PPUSH
67289: CALL_OW 456
// end ;
67293: GO 67206
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 3
67301: RET
// export function Count ( array ) ; var i ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
// result := 0 ;
67306: LD_ADDR_VAR 0 2
67310: PUSH
67311: LD_INT 0
67313: ST_TO_ADDR
// for i in array do
67314: LD_ADDR_VAR 0 3
67318: PUSH
67319: LD_VAR 0 1
67323: PUSH
67324: FOR_IN
67325: IFFALSE 67349
// if i then
67327: LD_VAR 0 3
67331: IFFALSE 67347
// result := result + 1 ;
67333: LD_ADDR_VAR 0 2
67337: PUSH
67338: LD_VAR 0 2
67342: PUSH
67343: LD_INT 1
67345: PLUS
67346: ST_TO_ADDR
67347: GO 67324
67349: POP
67350: POP
// end ;
67351: LD_VAR 0 2
67355: RET
// export function IsEmpty ( building ) ; begin
67356: LD_INT 0
67358: PPUSH
// if not building then
67359: LD_VAR 0 1
67363: NOT
67364: IFFALSE 67368
// exit ;
67366: GO 67411
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67368: LD_ADDR_VAR 0 2
67372: PUSH
67373: LD_VAR 0 1
67377: PUSH
67378: LD_INT 22
67380: PUSH
67381: LD_VAR 0 1
67385: PPUSH
67386: CALL_OW 255
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 58
67397: PUSH
67398: EMPTY
67399: LIST
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PPUSH
67405: CALL_OW 69
67409: IN
67410: ST_TO_ADDR
// end ;
67411: LD_VAR 0 2
67415: RET
// export function IsNotFull ( building ) ; begin
67416: LD_INT 0
67418: PPUSH
// if not building then
67419: LD_VAR 0 1
67423: NOT
67424: IFFALSE 67428
// exit ;
67426: GO 67447
// result := UnitsInside ( building ) < 6 ;
67428: LD_ADDR_VAR 0 2
67432: PUSH
67433: LD_VAR 0 1
67437: PPUSH
67438: CALL_OW 313
67442: PUSH
67443: LD_INT 6
67445: LESS
67446: ST_TO_ADDR
// end ;
67447: LD_VAR 0 2
67451: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67452: LD_INT 0
67454: PPUSH
67455: PPUSH
67456: PPUSH
67457: PPUSH
// tmp := [ ] ;
67458: LD_ADDR_VAR 0 3
67462: PUSH
67463: EMPTY
67464: ST_TO_ADDR
// list := [ ] ;
67465: LD_ADDR_VAR 0 5
67469: PUSH
67470: EMPTY
67471: ST_TO_ADDR
// for i = 16 to 25 do
67472: LD_ADDR_VAR 0 4
67476: PUSH
67477: DOUBLE
67478: LD_INT 16
67480: DEC
67481: ST_TO_ADDR
67482: LD_INT 25
67484: PUSH
67485: FOR_TO
67486: IFFALSE 67559
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67488: LD_ADDR_VAR 0 3
67492: PUSH
67493: LD_VAR 0 3
67497: PUSH
67498: LD_INT 22
67500: PUSH
67501: LD_VAR 0 1
67505: PPUSH
67506: CALL_OW 255
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 91
67517: PUSH
67518: LD_VAR 0 1
67522: PUSH
67523: LD_INT 6
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 30
67533: PUSH
67534: LD_VAR 0 4
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: LIST
67547: PUSH
67548: EMPTY
67549: LIST
67550: PPUSH
67551: CALL_OW 69
67555: ADD
67556: ST_TO_ADDR
67557: GO 67485
67559: POP
67560: POP
// for i = 1 to tmp do
67561: LD_ADDR_VAR 0 4
67565: PUSH
67566: DOUBLE
67567: LD_INT 1
67569: DEC
67570: ST_TO_ADDR
67571: LD_VAR 0 3
67575: PUSH
67576: FOR_TO
67577: IFFALSE 67665
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67579: LD_ADDR_VAR 0 5
67583: PUSH
67584: LD_VAR 0 5
67588: PUSH
67589: LD_VAR 0 3
67593: PUSH
67594: LD_VAR 0 4
67598: ARRAY
67599: PPUSH
67600: CALL_OW 266
67604: PUSH
67605: LD_VAR 0 3
67609: PUSH
67610: LD_VAR 0 4
67614: ARRAY
67615: PPUSH
67616: CALL_OW 250
67620: PUSH
67621: LD_VAR 0 3
67625: PUSH
67626: LD_VAR 0 4
67630: ARRAY
67631: PPUSH
67632: CALL_OW 251
67636: PUSH
67637: LD_VAR 0 3
67641: PUSH
67642: LD_VAR 0 4
67646: ARRAY
67647: PPUSH
67648: CALL_OW 254
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: PUSH
67659: EMPTY
67660: LIST
67661: ADD
67662: ST_TO_ADDR
67663: GO 67576
67665: POP
67666: POP
// result := list ;
67667: LD_ADDR_VAR 0 2
67671: PUSH
67672: LD_VAR 0 5
67676: ST_TO_ADDR
// end ;
67677: LD_VAR 0 2
67681: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67682: LD_INT 0
67684: PPUSH
67685: PPUSH
67686: PPUSH
67687: PPUSH
67688: PPUSH
67689: PPUSH
67690: PPUSH
// if not factory then
67691: LD_VAR 0 1
67695: NOT
67696: IFFALSE 67700
// exit ;
67698: GO 68293
// if control = control_apeman then
67700: LD_VAR 0 4
67704: PUSH
67705: LD_INT 5
67707: EQUAL
67708: IFFALSE 67817
// begin tmp := UnitsInside ( factory ) ;
67710: LD_ADDR_VAR 0 8
67714: PUSH
67715: LD_VAR 0 1
67719: PPUSH
67720: CALL_OW 313
67724: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67725: LD_VAR 0 8
67729: PPUSH
67730: LD_INT 25
67732: PUSH
67733: LD_INT 12
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PPUSH
67740: CALL_OW 72
67744: NOT
67745: IFFALSE 67755
// control := control_manual ;
67747: LD_ADDR_VAR 0 4
67751: PUSH
67752: LD_INT 1
67754: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67755: LD_ADDR_VAR 0 8
67759: PUSH
67760: LD_VAR 0 1
67764: PPUSH
67765: CALL 67452 0 1
67769: ST_TO_ADDR
// if tmp then
67770: LD_VAR 0 8
67774: IFFALSE 67817
// begin for i in tmp do
67776: LD_ADDR_VAR 0 7
67780: PUSH
67781: LD_VAR 0 8
67785: PUSH
67786: FOR_IN
67787: IFFALSE 67815
// if i [ 1 ] = b_ext_radio then
67789: LD_VAR 0 7
67793: PUSH
67794: LD_INT 1
67796: ARRAY
67797: PUSH
67798: LD_INT 22
67800: EQUAL
67801: IFFALSE 67813
// begin control := control_remote ;
67803: LD_ADDR_VAR 0 4
67807: PUSH
67808: LD_INT 2
67810: ST_TO_ADDR
// break ;
67811: GO 67815
// end ;
67813: GO 67786
67815: POP
67816: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67817: LD_VAR 0 1
67821: PPUSH
67822: LD_VAR 0 2
67826: PPUSH
67827: LD_VAR 0 3
67831: PPUSH
67832: LD_VAR 0 4
67836: PPUSH
67837: LD_VAR 0 5
67841: PPUSH
67842: CALL_OW 448
67846: IFFALSE 67881
// begin result := [ chassis , engine , control , weapon ] ;
67848: LD_ADDR_VAR 0 6
67852: PUSH
67853: LD_VAR 0 2
67857: PUSH
67858: LD_VAR 0 3
67862: PUSH
67863: LD_VAR 0 4
67867: PUSH
67868: LD_VAR 0 5
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: ST_TO_ADDR
// exit ;
67879: GO 68293
// end ; _chassis := AvailableChassisList ( factory ) ;
67881: LD_ADDR_VAR 0 9
67885: PUSH
67886: LD_VAR 0 1
67890: PPUSH
67891: CALL_OW 475
67895: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67896: LD_ADDR_VAR 0 11
67900: PUSH
67901: LD_VAR 0 1
67905: PPUSH
67906: CALL_OW 476
67910: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67911: LD_ADDR_VAR 0 12
67915: PUSH
67916: LD_VAR 0 1
67920: PPUSH
67921: CALL_OW 477
67925: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67926: LD_ADDR_VAR 0 10
67930: PUSH
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL_OW 478
67940: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67941: LD_VAR 0 9
67945: NOT
67946: PUSH
67947: LD_VAR 0 11
67951: NOT
67952: OR
67953: PUSH
67954: LD_VAR 0 12
67958: NOT
67959: OR
67960: PUSH
67961: LD_VAR 0 10
67965: NOT
67966: OR
67967: IFFALSE 68002
// begin result := [ chassis , engine , control , weapon ] ;
67969: LD_ADDR_VAR 0 6
67973: PUSH
67974: LD_VAR 0 2
67978: PUSH
67979: LD_VAR 0 3
67983: PUSH
67984: LD_VAR 0 4
67988: PUSH
67989: LD_VAR 0 5
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: ST_TO_ADDR
// exit ;
68000: GO 68293
// end ; if not chassis in _chassis then
68002: LD_VAR 0 2
68006: PUSH
68007: LD_VAR 0 9
68011: IN
68012: NOT
68013: IFFALSE 68039
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68015: LD_ADDR_VAR 0 2
68019: PUSH
68020: LD_VAR 0 9
68024: PUSH
68025: LD_INT 1
68027: PPUSH
68028: LD_VAR 0 9
68032: PPUSH
68033: CALL_OW 12
68037: ARRAY
68038: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68039: LD_VAR 0 2
68043: PPUSH
68044: LD_VAR 0 3
68048: PPUSH
68049: CALL 68298 0 2
68053: NOT
68054: IFFALSE 68113
// repeat engine := _engine [ 1 ] ;
68056: LD_ADDR_VAR 0 3
68060: PUSH
68061: LD_VAR 0 11
68065: PUSH
68066: LD_INT 1
68068: ARRAY
68069: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68070: LD_ADDR_VAR 0 11
68074: PUSH
68075: LD_VAR 0 11
68079: PPUSH
68080: LD_INT 1
68082: PPUSH
68083: CALL_OW 3
68087: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68088: LD_VAR 0 2
68092: PPUSH
68093: LD_VAR 0 3
68097: PPUSH
68098: CALL 68298 0 2
68102: PUSH
68103: LD_VAR 0 11
68107: PUSH
68108: EMPTY
68109: EQUAL
68110: OR
68111: IFFALSE 68056
// if not control in _control then
68113: LD_VAR 0 4
68117: PUSH
68118: LD_VAR 0 12
68122: IN
68123: NOT
68124: IFFALSE 68150
// control := _control [ rand ( 1 , _control ) ] ;
68126: LD_ADDR_VAR 0 4
68130: PUSH
68131: LD_VAR 0 12
68135: PUSH
68136: LD_INT 1
68138: PPUSH
68139: LD_VAR 0 12
68143: PPUSH
68144: CALL_OW 12
68148: ARRAY
68149: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68150: LD_VAR 0 2
68154: PPUSH
68155: LD_VAR 0 5
68159: PPUSH
68160: CALL 68518 0 2
68164: NOT
68165: IFFALSE 68224
// repeat weapon := _weapon [ 1 ] ;
68167: LD_ADDR_VAR 0 5
68171: PUSH
68172: LD_VAR 0 10
68176: PUSH
68177: LD_INT 1
68179: ARRAY
68180: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68181: LD_ADDR_VAR 0 10
68185: PUSH
68186: LD_VAR 0 10
68190: PPUSH
68191: LD_INT 1
68193: PPUSH
68194: CALL_OW 3
68198: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68199: LD_VAR 0 2
68203: PPUSH
68204: LD_VAR 0 5
68208: PPUSH
68209: CALL 68518 0 2
68213: PUSH
68214: LD_VAR 0 10
68218: PUSH
68219: EMPTY
68220: EQUAL
68221: OR
68222: IFFALSE 68167
// result := [ ] ;
68224: LD_ADDR_VAR 0 6
68228: PUSH
68229: EMPTY
68230: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68231: LD_VAR 0 1
68235: PPUSH
68236: LD_VAR 0 2
68240: PPUSH
68241: LD_VAR 0 3
68245: PPUSH
68246: LD_VAR 0 4
68250: PPUSH
68251: LD_VAR 0 5
68255: PPUSH
68256: CALL_OW 448
68260: IFFALSE 68293
// result := [ chassis , engine , control , weapon ] ;
68262: LD_ADDR_VAR 0 6
68266: PUSH
68267: LD_VAR 0 2
68271: PUSH
68272: LD_VAR 0 3
68276: PUSH
68277: LD_VAR 0 4
68281: PUSH
68282: LD_VAR 0 5
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: ST_TO_ADDR
// end ;
68293: LD_VAR 0 6
68297: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68298: LD_INT 0
68300: PPUSH
// if not chassis or not engine then
68301: LD_VAR 0 1
68305: NOT
68306: PUSH
68307: LD_VAR 0 2
68311: NOT
68312: OR
68313: IFFALSE 68317
// exit ;
68315: GO 68513
// case engine of engine_solar :
68317: LD_VAR 0 2
68321: PUSH
68322: LD_INT 2
68324: DOUBLE
68325: EQUAL
68326: IFTRUE 68330
68328: GO 68368
68330: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68331: LD_ADDR_VAR 0 3
68335: PUSH
68336: LD_INT 11
68338: PUSH
68339: LD_INT 12
68341: PUSH
68342: LD_INT 13
68344: PUSH
68345: LD_INT 14
68347: PUSH
68348: LD_INT 1
68350: PUSH
68351: LD_INT 2
68353: PUSH
68354: LD_INT 3
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: ST_TO_ADDR
68366: GO 68497
68368: LD_INT 1
68370: DOUBLE
68371: EQUAL
68372: IFTRUE 68376
68374: GO 68438
68376: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68377: LD_ADDR_VAR 0 3
68381: PUSH
68382: LD_INT 11
68384: PUSH
68385: LD_INT 12
68387: PUSH
68388: LD_INT 13
68390: PUSH
68391: LD_INT 14
68393: PUSH
68394: LD_INT 1
68396: PUSH
68397: LD_INT 2
68399: PUSH
68400: LD_INT 3
68402: PUSH
68403: LD_INT 4
68405: PUSH
68406: LD_INT 5
68408: PUSH
68409: LD_INT 21
68411: PUSH
68412: LD_INT 23
68414: PUSH
68415: LD_INT 22
68417: PUSH
68418: LD_INT 24
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: ST_TO_ADDR
68436: GO 68497
68438: LD_INT 3
68440: DOUBLE
68441: EQUAL
68442: IFTRUE 68446
68444: GO 68496
68446: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68447: LD_ADDR_VAR 0 3
68451: PUSH
68452: LD_INT 13
68454: PUSH
68455: LD_INT 14
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 3
68463: PUSH
68464: LD_INT 4
68466: PUSH
68467: LD_INT 5
68469: PUSH
68470: LD_INT 21
68472: PUSH
68473: LD_INT 22
68475: PUSH
68476: LD_INT 23
68478: PUSH
68479: LD_INT 24
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: ST_TO_ADDR
68494: GO 68497
68496: POP
// result := ( chassis in result ) ;
68497: LD_ADDR_VAR 0 3
68501: PUSH
68502: LD_VAR 0 1
68506: PUSH
68507: LD_VAR 0 3
68511: IN
68512: ST_TO_ADDR
// end ;
68513: LD_VAR 0 3
68517: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68518: LD_INT 0
68520: PPUSH
// if not chassis or not weapon then
68521: LD_VAR 0 1
68525: NOT
68526: PUSH
68527: LD_VAR 0 2
68531: NOT
68532: OR
68533: IFFALSE 68537
// exit ;
68535: GO 69563
// case weapon of us_machine_gun :
68537: LD_VAR 0 2
68541: PUSH
68542: LD_INT 2
68544: DOUBLE
68545: EQUAL
68546: IFTRUE 68550
68548: GO 68580
68550: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68551: LD_ADDR_VAR 0 3
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: LD_INT 2
68561: PUSH
68562: LD_INT 3
68564: PUSH
68565: LD_INT 4
68567: PUSH
68568: LD_INT 5
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: ST_TO_ADDR
68578: GO 69547
68580: LD_INT 3
68582: DOUBLE
68583: EQUAL
68584: IFTRUE 68588
68586: GO 68618
68588: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68589: LD_ADDR_VAR 0 3
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: LD_INT 2
68599: PUSH
68600: LD_INT 3
68602: PUSH
68603: LD_INT 4
68605: PUSH
68606: LD_INT 5
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: ST_TO_ADDR
68616: GO 69547
68618: LD_INT 11
68620: DOUBLE
68621: EQUAL
68622: IFTRUE 68626
68624: GO 68656
68626: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68627: LD_ADDR_VAR 0 3
68631: PUSH
68632: LD_INT 1
68634: PUSH
68635: LD_INT 2
68637: PUSH
68638: LD_INT 3
68640: PUSH
68641: LD_INT 4
68643: PUSH
68644: LD_INT 5
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: ST_TO_ADDR
68654: GO 69547
68656: LD_INT 4
68658: DOUBLE
68659: EQUAL
68660: IFTRUE 68664
68662: GO 68690
68664: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68665: LD_ADDR_VAR 0 3
68669: PUSH
68670: LD_INT 2
68672: PUSH
68673: LD_INT 3
68675: PUSH
68676: LD_INT 4
68678: PUSH
68679: LD_INT 5
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: ST_TO_ADDR
68688: GO 69547
68690: LD_INT 5
68692: DOUBLE
68693: EQUAL
68694: IFTRUE 68698
68696: GO 68724
68698: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68699: LD_ADDR_VAR 0 3
68703: PUSH
68704: LD_INT 2
68706: PUSH
68707: LD_INT 3
68709: PUSH
68710: LD_INT 4
68712: PUSH
68713: LD_INT 5
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: ST_TO_ADDR
68722: GO 69547
68724: LD_INT 9
68726: DOUBLE
68727: EQUAL
68728: IFTRUE 68732
68730: GO 68758
68732: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68733: LD_ADDR_VAR 0 3
68737: PUSH
68738: LD_INT 2
68740: PUSH
68741: LD_INT 3
68743: PUSH
68744: LD_INT 4
68746: PUSH
68747: LD_INT 5
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: ST_TO_ADDR
68756: GO 69547
68758: LD_INT 7
68760: DOUBLE
68761: EQUAL
68762: IFTRUE 68766
68764: GO 68792
68766: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68767: LD_ADDR_VAR 0 3
68771: PUSH
68772: LD_INT 2
68774: PUSH
68775: LD_INT 3
68777: PUSH
68778: LD_INT 4
68780: PUSH
68781: LD_INT 5
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: ST_TO_ADDR
68790: GO 69547
68792: LD_INT 12
68794: DOUBLE
68795: EQUAL
68796: IFTRUE 68800
68798: GO 68826
68800: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68801: LD_ADDR_VAR 0 3
68805: PUSH
68806: LD_INT 2
68808: PUSH
68809: LD_INT 3
68811: PUSH
68812: LD_INT 4
68814: PUSH
68815: LD_INT 5
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: ST_TO_ADDR
68824: GO 69547
68826: LD_INT 13
68828: DOUBLE
68829: EQUAL
68830: IFTRUE 68834
68832: GO 68860
68834: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68835: LD_ADDR_VAR 0 3
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: LD_INT 3
68845: PUSH
68846: LD_INT 4
68848: PUSH
68849: LD_INT 5
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: ST_TO_ADDR
68858: GO 69547
68860: LD_INT 14
68862: DOUBLE
68863: EQUAL
68864: IFTRUE 68868
68866: GO 68886
68868: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: LD_INT 4
68876: PUSH
68877: LD_INT 5
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: ST_TO_ADDR
68884: GO 69547
68886: LD_INT 6
68888: DOUBLE
68889: EQUAL
68890: IFTRUE 68894
68892: GO 68912
68894: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68895: LD_ADDR_VAR 0 3
68899: PUSH
68900: LD_INT 4
68902: PUSH
68903: LD_INT 5
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: ST_TO_ADDR
68910: GO 69547
68912: LD_INT 10
68914: DOUBLE
68915: EQUAL
68916: IFTRUE 68920
68918: GO 68938
68920: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68921: LD_ADDR_VAR 0 3
68925: PUSH
68926: LD_INT 4
68928: PUSH
68929: LD_INT 5
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: ST_TO_ADDR
68936: GO 69547
68938: LD_INT 22
68940: DOUBLE
68941: EQUAL
68942: IFTRUE 68946
68944: GO 68972
68946: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68947: LD_ADDR_VAR 0 3
68951: PUSH
68952: LD_INT 11
68954: PUSH
68955: LD_INT 12
68957: PUSH
68958: LD_INT 13
68960: PUSH
68961: LD_INT 14
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: ST_TO_ADDR
68970: GO 69547
68972: LD_INT 23
68974: DOUBLE
68975: EQUAL
68976: IFTRUE 68980
68978: GO 69006
68980: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68981: LD_ADDR_VAR 0 3
68985: PUSH
68986: LD_INT 11
68988: PUSH
68989: LD_INT 12
68991: PUSH
68992: LD_INT 13
68994: PUSH
68995: LD_INT 14
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: ST_TO_ADDR
69004: GO 69547
69006: LD_INT 24
69008: DOUBLE
69009: EQUAL
69010: IFTRUE 69014
69012: GO 69040
69014: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69015: LD_ADDR_VAR 0 3
69019: PUSH
69020: LD_INT 11
69022: PUSH
69023: LD_INT 12
69025: PUSH
69026: LD_INT 13
69028: PUSH
69029: LD_INT 14
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: ST_TO_ADDR
69038: GO 69547
69040: LD_INT 30
69042: DOUBLE
69043: EQUAL
69044: IFTRUE 69048
69046: GO 69074
69048: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69049: LD_ADDR_VAR 0 3
69053: PUSH
69054: LD_INT 11
69056: PUSH
69057: LD_INT 12
69059: PUSH
69060: LD_INT 13
69062: PUSH
69063: LD_INT 14
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: ST_TO_ADDR
69072: GO 69547
69074: LD_INT 25
69076: DOUBLE
69077: EQUAL
69078: IFTRUE 69082
69080: GO 69100
69082: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69083: LD_ADDR_VAR 0 3
69087: PUSH
69088: LD_INT 13
69090: PUSH
69091: LD_INT 14
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: ST_TO_ADDR
69098: GO 69547
69100: LD_INT 27
69102: DOUBLE
69103: EQUAL
69104: IFTRUE 69108
69106: GO 69126
69108: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69109: LD_ADDR_VAR 0 3
69113: PUSH
69114: LD_INT 13
69116: PUSH
69117: LD_INT 14
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: ST_TO_ADDR
69124: GO 69547
69126: LD_INT 28
69128: DOUBLE
69129: EQUAL
69130: IFTRUE 69134
69132: GO 69152
69134: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69135: LD_ADDR_VAR 0 3
69139: PUSH
69140: LD_INT 13
69142: PUSH
69143: LD_INT 14
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: ST_TO_ADDR
69150: GO 69547
69152: LD_INT 29
69154: DOUBLE
69155: EQUAL
69156: IFTRUE 69160
69158: GO 69178
69160: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69161: LD_ADDR_VAR 0 3
69165: PUSH
69166: LD_INT 13
69168: PUSH
69169: LD_INT 14
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: ST_TO_ADDR
69176: GO 69547
69178: LD_INT 31
69180: DOUBLE
69181: EQUAL
69182: IFTRUE 69186
69184: GO 69204
69186: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69187: LD_ADDR_VAR 0 3
69191: PUSH
69192: LD_INT 13
69194: PUSH
69195: LD_INT 14
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: ST_TO_ADDR
69202: GO 69547
69204: LD_INT 26
69206: DOUBLE
69207: EQUAL
69208: IFTRUE 69212
69210: GO 69230
69212: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69213: LD_ADDR_VAR 0 3
69217: PUSH
69218: LD_INT 13
69220: PUSH
69221: LD_INT 14
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: ST_TO_ADDR
69228: GO 69547
69230: LD_INT 42
69232: DOUBLE
69233: EQUAL
69234: IFTRUE 69238
69236: GO 69264
69238: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69239: LD_ADDR_VAR 0 3
69243: PUSH
69244: LD_INT 21
69246: PUSH
69247: LD_INT 22
69249: PUSH
69250: LD_INT 23
69252: PUSH
69253: LD_INT 24
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: ST_TO_ADDR
69262: GO 69547
69264: LD_INT 43
69266: DOUBLE
69267: EQUAL
69268: IFTRUE 69272
69270: GO 69298
69272: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69273: LD_ADDR_VAR 0 3
69277: PUSH
69278: LD_INT 21
69280: PUSH
69281: LD_INT 22
69283: PUSH
69284: LD_INT 23
69286: PUSH
69287: LD_INT 24
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: ST_TO_ADDR
69296: GO 69547
69298: LD_INT 44
69300: DOUBLE
69301: EQUAL
69302: IFTRUE 69306
69304: GO 69332
69306: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69307: LD_ADDR_VAR 0 3
69311: PUSH
69312: LD_INT 21
69314: PUSH
69315: LD_INT 22
69317: PUSH
69318: LD_INT 23
69320: PUSH
69321: LD_INT 24
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: ST_TO_ADDR
69330: GO 69547
69332: LD_INT 45
69334: DOUBLE
69335: EQUAL
69336: IFTRUE 69340
69338: GO 69366
69340: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69341: LD_ADDR_VAR 0 3
69345: PUSH
69346: LD_INT 21
69348: PUSH
69349: LD_INT 22
69351: PUSH
69352: LD_INT 23
69354: PUSH
69355: LD_INT 24
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: ST_TO_ADDR
69364: GO 69547
69366: LD_INT 49
69368: DOUBLE
69369: EQUAL
69370: IFTRUE 69374
69372: GO 69400
69374: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69375: LD_ADDR_VAR 0 3
69379: PUSH
69380: LD_INT 21
69382: PUSH
69383: LD_INT 22
69385: PUSH
69386: LD_INT 23
69388: PUSH
69389: LD_INT 24
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: ST_TO_ADDR
69398: GO 69547
69400: LD_INT 51
69402: DOUBLE
69403: EQUAL
69404: IFTRUE 69408
69406: GO 69434
69408: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69409: LD_ADDR_VAR 0 3
69413: PUSH
69414: LD_INT 21
69416: PUSH
69417: LD_INT 22
69419: PUSH
69420: LD_INT 23
69422: PUSH
69423: LD_INT 24
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: ST_TO_ADDR
69432: GO 69547
69434: LD_INT 52
69436: DOUBLE
69437: EQUAL
69438: IFTRUE 69442
69440: GO 69468
69442: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69443: LD_ADDR_VAR 0 3
69447: PUSH
69448: LD_INT 21
69450: PUSH
69451: LD_INT 22
69453: PUSH
69454: LD_INT 23
69456: PUSH
69457: LD_INT 24
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: ST_TO_ADDR
69466: GO 69547
69468: LD_INT 53
69470: DOUBLE
69471: EQUAL
69472: IFTRUE 69476
69474: GO 69494
69476: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69477: LD_ADDR_VAR 0 3
69481: PUSH
69482: LD_INT 23
69484: PUSH
69485: LD_INT 24
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: ST_TO_ADDR
69492: GO 69547
69494: LD_INT 46
69496: DOUBLE
69497: EQUAL
69498: IFTRUE 69502
69500: GO 69520
69502: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69503: LD_ADDR_VAR 0 3
69507: PUSH
69508: LD_INT 23
69510: PUSH
69511: LD_INT 24
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: ST_TO_ADDR
69518: GO 69547
69520: LD_INT 47
69522: DOUBLE
69523: EQUAL
69524: IFTRUE 69528
69526: GO 69546
69528: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69529: LD_ADDR_VAR 0 3
69533: PUSH
69534: LD_INT 23
69536: PUSH
69537: LD_INT 24
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: ST_TO_ADDR
69544: GO 69547
69546: POP
// result := ( chassis in result ) ;
69547: LD_ADDR_VAR 0 3
69551: PUSH
69552: LD_VAR 0 1
69556: PUSH
69557: LD_VAR 0 3
69561: IN
69562: ST_TO_ADDR
// end ;
69563: LD_VAR 0 3
69567: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69568: LD_INT 0
69570: PPUSH
69571: PPUSH
69572: PPUSH
69573: PPUSH
69574: PPUSH
69575: PPUSH
69576: PPUSH
// result := array ;
69577: LD_ADDR_VAR 0 5
69581: PUSH
69582: LD_VAR 0 1
69586: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69587: LD_VAR 0 1
69591: NOT
69592: PUSH
69593: LD_VAR 0 2
69597: NOT
69598: OR
69599: PUSH
69600: LD_VAR 0 3
69604: NOT
69605: OR
69606: PUSH
69607: LD_VAR 0 2
69611: PUSH
69612: LD_VAR 0 1
69616: GREATER
69617: OR
69618: PUSH
69619: LD_VAR 0 3
69623: PUSH
69624: LD_VAR 0 1
69628: GREATER
69629: OR
69630: IFFALSE 69634
// exit ;
69632: GO 69930
// if direction then
69634: LD_VAR 0 4
69638: IFFALSE 69702
// begin d := 1 ;
69640: LD_ADDR_VAR 0 9
69644: PUSH
69645: LD_INT 1
69647: ST_TO_ADDR
// if i_from > i_to then
69648: LD_VAR 0 2
69652: PUSH
69653: LD_VAR 0 3
69657: GREATER
69658: IFFALSE 69684
// length := ( array - i_from ) + i_to else
69660: LD_ADDR_VAR 0 11
69664: PUSH
69665: LD_VAR 0 1
69669: PUSH
69670: LD_VAR 0 2
69674: MINUS
69675: PUSH
69676: LD_VAR 0 3
69680: PLUS
69681: ST_TO_ADDR
69682: GO 69700
// length := i_to - i_from ;
69684: LD_ADDR_VAR 0 11
69688: PUSH
69689: LD_VAR 0 3
69693: PUSH
69694: LD_VAR 0 2
69698: MINUS
69699: ST_TO_ADDR
// end else
69700: GO 69763
// begin d := - 1 ;
69702: LD_ADDR_VAR 0 9
69706: PUSH
69707: LD_INT 1
69709: NEG
69710: ST_TO_ADDR
// if i_from > i_to then
69711: LD_VAR 0 2
69715: PUSH
69716: LD_VAR 0 3
69720: GREATER
69721: IFFALSE 69741
// length := i_from - i_to else
69723: LD_ADDR_VAR 0 11
69727: PUSH
69728: LD_VAR 0 2
69732: PUSH
69733: LD_VAR 0 3
69737: MINUS
69738: ST_TO_ADDR
69739: GO 69763
// length := ( array - i_to ) + i_from ;
69741: LD_ADDR_VAR 0 11
69745: PUSH
69746: LD_VAR 0 1
69750: PUSH
69751: LD_VAR 0 3
69755: MINUS
69756: PUSH
69757: LD_VAR 0 2
69761: PLUS
69762: ST_TO_ADDR
// end ; if not length then
69763: LD_VAR 0 11
69767: NOT
69768: IFFALSE 69772
// exit ;
69770: GO 69930
// tmp := array ;
69772: LD_ADDR_VAR 0 10
69776: PUSH
69777: LD_VAR 0 1
69781: ST_TO_ADDR
// for i = 1 to length do
69782: LD_ADDR_VAR 0 6
69786: PUSH
69787: DOUBLE
69788: LD_INT 1
69790: DEC
69791: ST_TO_ADDR
69792: LD_VAR 0 11
69796: PUSH
69797: FOR_TO
69798: IFFALSE 69918
// begin for j = 1 to array do
69800: LD_ADDR_VAR 0 7
69804: PUSH
69805: DOUBLE
69806: LD_INT 1
69808: DEC
69809: ST_TO_ADDR
69810: LD_VAR 0 1
69814: PUSH
69815: FOR_TO
69816: IFFALSE 69904
// begin k := j + d ;
69818: LD_ADDR_VAR 0 8
69822: PUSH
69823: LD_VAR 0 7
69827: PUSH
69828: LD_VAR 0 9
69832: PLUS
69833: ST_TO_ADDR
// if k > array then
69834: LD_VAR 0 8
69838: PUSH
69839: LD_VAR 0 1
69843: GREATER
69844: IFFALSE 69854
// k := 1 ;
69846: LD_ADDR_VAR 0 8
69850: PUSH
69851: LD_INT 1
69853: ST_TO_ADDR
// if not k then
69854: LD_VAR 0 8
69858: NOT
69859: IFFALSE 69871
// k := array ;
69861: LD_ADDR_VAR 0 8
69865: PUSH
69866: LD_VAR 0 1
69870: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69871: LD_ADDR_VAR 0 10
69875: PUSH
69876: LD_VAR 0 10
69880: PPUSH
69881: LD_VAR 0 8
69885: PPUSH
69886: LD_VAR 0 1
69890: PUSH
69891: LD_VAR 0 7
69895: ARRAY
69896: PPUSH
69897: CALL_OW 1
69901: ST_TO_ADDR
// end ;
69902: GO 69815
69904: POP
69905: POP
// array := tmp ;
69906: LD_ADDR_VAR 0 1
69910: PUSH
69911: LD_VAR 0 10
69915: ST_TO_ADDR
// end ;
69916: GO 69797
69918: POP
69919: POP
// result := array ;
69920: LD_ADDR_VAR 0 5
69924: PUSH
69925: LD_VAR 0 1
69929: ST_TO_ADDR
// end ;
69930: LD_VAR 0 5
69934: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69935: LD_INT 0
69937: PPUSH
69938: PPUSH
// result := 0 ;
69939: LD_ADDR_VAR 0 3
69943: PUSH
69944: LD_INT 0
69946: ST_TO_ADDR
// if not array or not value in array then
69947: LD_VAR 0 1
69951: NOT
69952: PUSH
69953: LD_VAR 0 2
69957: PUSH
69958: LD_VAR 0 1
69962: IN
69963: NOT
69964: OR
69965: IFFALSE 69969
// exit ;
69967: GO 70023
// for i = 1 to array do
69969: LD_ADDR_VAR 0 4
69973: PUSH
69974: DOUBLE
69975: LD_INT 1
69977: DEC
69978: ST_TO_ADDR
69979: LD_VAR 0 1
69983: PUSH
69984: FOR_TO
69985: IFFALSE 70021
// if value = array [ i ] then
69987: LD_VAR 0 2
69991: PUSH
69992: LD_VAR 0 1
69996: PUSH
69997: LD_VAR 0 4
70001: ARRAY
70002: EQUAL
70003: IFFALSE 70019
// begin result := i ;
70005: LD_ADDR_VAR 0 3
70009: PUSH
70010: LD_VAR 0 4
70014: ST_TO_ADDR
// exit ;
70015: POP
70016: POP
70017: GO 70023
// end ;
70019: GO 69984
70021: POP
70022: POP
// end ;
70023: LD_VAR 0 3
70027: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70028: LD_INT 0
70030: PPUSH
// vc_chassis := chassis ;
70031: LD_ADDR_OWVAR 37
70035: PUSH
70036: LD_VAR 0 1
70040: ST_TO_ADDR
// vc_engine := engine ;
70041: LD_ADDR_OWVAR 39
70045: PUSH
70046: LD_VAR 0 2
70050: ST_TO_ADDR
// vc_control := control ;
70051: LD_ADDR_OWVAR 38
70055: PUSH
70056: LD_VAR 0 3
70060: ST_TO_ADDR
// vc_weapon := weapon ;
70061: LD_ADDR_OWVAR 40
70065: PUSH
70066: LD_VAR 0 4
70070: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70071: LD_ADDR_OWVAR 41
70075: PUSH
70076: LD_VAR 0 5
70080: ST_TO_ADDR
// end ;
70081: LD_VAR 0 6
70085: RET
// export function WantPlant ( unit ) ; var task ; begin
70086: LD_INT 0
70088: PPUSH
70089: PPUSH
// result := false ;
70090: LD_ADDR_VAR 0 2
70094: PUSH
70095: LD_INT 0
70097: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70098: LD_ADDR_VAR 0 3
70102: PUSH
70103: LD_VAR 0 1
70107: PPUSH
70108: CALL_OW 437
70112: ST_TO_ADDR
// if task then
70113: LD_VAR 0 3
70117: IFFALSE 70145
// if task [ 1 ] [ 1 ] = p then
70119: LD_VAR 0 3
70123: PUSH
70124: LD_INT 1
70126: ARRAY
70127: PUSH
70128: LD_INT 1
70130: ARRAY
70131: PUSH
70132: LD_STRING p
70134: EQUAL
70135: IFFALSE 70145
// result := true ;
70137: LD_ADDR_VAR 0 2
70141: PUSH
70142: LD_INT 1
70144: ST_TO_ADDR
// end ;
70145: LD_VAR 0 2
70149: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70150: LD_INT 0
70152: PPUSH
70153: PPUSH
70154: PPUSH
70155: PPUSH
// if pos < 1 then
70156: LD_VAR 0 2
70160: PUSH
70161: LD_INT 1
70163: LESS
70164: IFFALSE 70168
// exit ;
70166: GO 70471
// if pos = 1 then
70168: LD_VAR 0 2
70172: PUSH
70173: LD_INT 1
70175: EQUAL
70176: IFFALSE 70209
// result := Replace ( arr , pos [ 1 ] , value ) else
70178: LD_ADDR_VAR 0 4
70182: PUSH
70183: LD_VAR 0 1
70187: PPUSH
70188: LD_VAR 0 2
70192: PUSH
70193: LD_INT 1
70195: ARRAY
70196: PPUSH
70197: LD_VAR 0 3
70201: PPUSH
70202: CALL_OW 1
70206: ST_TO_ADDR
70207: GO 70471
// begin tmp := arr ;
70209: LD_ADDR_VAR 0 6
70213: PUSH
70214: LD_VAR 0 1
70218: ST_TO_ADDR
// s_arr := [ tmp ] ;
70219: LD_ADDR_VAR 0 7
70223: PUSH
70224: LD_VAR 0 6
70228: PUSH
70229: EMPTY
70230: LIST
70231: ST_TO_ADDR
// for i = 1 to pos - 1 do
70232: LD_ADDR_VAR 0 5
70236: PUSH
70237: DOUBLE
70238: LD_INT 1
70240: DEC
70241: ST_TO_ADDR
70242: LD_VAR 0 2
70246: PUSH
70247: LD_INT 1
70249: MINUS
70250: PUSH
70251: FOR_TO
70252: IFFALSE 70297
// begin tmp := tmp [ pos [ i ] ] ;
70254: LD_ADDR_VAR 0 6
70258: PUSH
70259: LD_VAR 0 6
70263: PUSH
70264: LD_VAR 0 2
70268: PUSH
70269: LD_VAR 0 5
70273: ARRAY
70274: ARRAY
70275: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70276: LD_ADDR_VAR 0 7
70280: PUSH
70281: LD_VAR 0 7
70285: PUSH
70286: LD_VAR 0 6
70290: PUSH
70291: EMPTY
70292: LIST
70293: ADD
70294: ST_TO_ADDR
// end ;
70295: GO 70251
70297: POP
70298: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70299: LD_ADDR_VAR 0 6
70303: PUSH
70304: LD_VAR 0 6
70308: PPUSH
70309: LD_VAR 0 2
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PPUSH
70320: LD_VAR 0 3
70324: PPUSH
70325: CALL_OW 1
70329: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70330: LD_ADDR_VAR 0 7
70334: PUSH
70335: LD_VAR 0 7
70339: PPUSH
70340: LD_VAR 0 7
70344: PPUSH
70345: LD_VAR 0 6
70349: PPUSH
70350: CALL_OW 1
70354: ST_TO_ADDR
// for i = s_arr downto 2 do
70355: LD_ADDR_VAR 0 5
70359: PUSH
70360: DOUBLE
70361: LD_VAR 0 7
70365: INC
70366: ST_TO_ADDR
70367: LD_INT 2
70369: PUSH
70370: FOR_DOWNTO
70371: IFFALSE 70455
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70373: LD_ADDR_VAR 0 6
70377: PUSH
70378: LD_VAR 0 7
70382: PUSH
70383: LD_VAR 0 5
70387: PUSH
70388: LD_INT 1
70390: MINUS
70391: ARRAY
70392: PPUSH
70393: LD_VAR 0 2
70397: PUSH
70398: LD_VAR 0 5
70402: PUSH
70403: LD_INT 1
70405: MINUS
70406: ARRAY
70407: PPUSH
70408: LD_VAR 0 7
70412: PUSH
70413: LD_VAR 0 5
70417: ARRAY
70418: PPUSH
70419: CALL_OW 1
70423: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70424: LD_ADDR_VAR 0 7
70428: PUSH
70429: LD_VAR 0 7
70433: PPUSH
70434: LD_VAR 0 5
70438: PUSH
70439: LD_INT 1
70441: MINUS
70442: PPUSH
70443: LD_VAR 0 6
70447: PPUSH
70448: CALL_OW 1
70452: ST_TO_ADDR
// end ;
70453: GO 70370
70455: POP
70456: POP
// result := s_arr [ 1 ] ;
70457: LD_ADDR_VAR 0 4
70461: PUSH
70462: LD_VAR 0 7
70466: PUSH
70467: LD_INT 1
70469: ARRAY
70470: ST_TO_ADDR
// end ; end ;
70471: LD_VAR 0 4
70475: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70476: LD_INT 0
70478: PPUSH
70479: PPUSH
// if not list then
70480: LD_VAR 0 1
70484: NOT
70485: IFFALSE 70489
// exit ;
70487: GO 70580
// i := list [ pos1 ] ;
70489: LD_ADDR_VAR 0 5
70493: PUSH
70494: LD_VAR 0 1
70498: PUSH
70499: LD_VAR 0 2
70503: ARRAY
70504: ST_TO_ADDR
// if not i then
70505: LD_VAR 0 5
70509: NOT
70510: IFFALSE 70514
// exit ;
70512: GO 70580
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70514: LD_ADDR_VAR 0 1
70518: PUSH
70519: LD_VAR 0 1
70523: PPUSH
70524: LD_VAR 0 2
70528: PPUSH
70529: LD_VAR 0 1
70533: PUSH
70534: LD_VAR 0 3
70538: ARRAY
70539: PPUSH
70540: CALL_OW 1
70544: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70545: LD_ADDR_VAR 0 1
70549: PUSH
70550: LD_VAR 0 1
70554: PPUSH
70555: LD_VAR 0 3
70559: PPUSH
70560: LD_VAR 0 5
70564: PPUSH
70565: CALL_OW 1
70569: ST_TO_ADDR
// result := list ;
70570: LD_ADDR_VAR 0 4
70574: PUSH
70575: LD_VAR 0 1
70579: ST_TO_ADDR
// end ;
70580: LD_VAR 0 4
70584: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70585: LD_INT 0
70587: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70588: LD_ADDR_VAR 0 5
70592: PUSH
70593: LD_VAR 0 1
70597: PPUSH
70598: CALL_OW 250
70602: PPUSH
70603: LD_VAR 0 1
70607: PPUSH
70608: CALL_OW 251
70612: PPUSH
70613: LD_VAR 0 2
70617: PPUSH
70618: LD_VAR 0 3
70622: PPUSH
70623: LD_VAR 0 4
70627: PPUSH
70628: CALL 70638 0 5
70632: ST_TO_ADDR
// end ;
70633: LD_VAR 0 5
70637: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70638: LD_INT 0
70640: PPUSH
70641: PPUSH
70642: PPUSH
70643: PPUSH
// if not list then
70644: LD_VAR 0 3
70648: NOT
70649: IFFALSE 70653
// exit ;
70651: GO 71041
// result := [ ] ;
70653: LD_ADDR_VAR 0 6
70657: PUSH
70658: EMPTY
70659: ST_TO_ADDR
// for i in list do
70660: LD_ADDR_VAR 0 7
70664: PUSH
70665: LD_VAR 0 3
70669: PUSH
70670: FOR_IN
70671: IFFALSE 70873
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70673: LD_ADDR_VAR 0 9
70677: PUSH
70678: LD_VAR 0 7
70682: PPUSH
70683: LD_VAR 0 1
70687: PPUSH
70688: LD_VAR 0 2
70692: PPUSH
70693: CALL_OW 297
70697: ST_TO_ADDR
// if not result then
70698: LD_VAR 0 6
70702: NOT
70703: IFFALSE 70729
// result := [ [ i , tmp ] ] else
70705: LD_ADDR_VAR 0 6
70709: PUSH
70710: LD_VAR 0 7
70714: PUSH
70715: LD_VAR 0 9
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: EMPTY
70725: LIST
70726: ST_TO_ADDR
70727: GO 70871
// begin if result [ result ] [ 2 ] < tmp then
70729: LD_VAR 0 6
70733: PUSH
70734: LD_VAR 0 6
70738: ARRAY
70739: PUSH
70740: LD_INT 2
70742: ARRAY
70743: PUSH
70744: LD_VAR 0 9
70748: LESS
70749: IFFALSE 70791
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70751: LD_ADDR_VAR 0 6
70755: PUSH
70756: LD_VAR 0 6
70760: PPUSH
70761: LD_VAR 0 6
70765: PUSH
70766: LD_INT 1
70768: PLUS
70769: PPUSH
70770: LD_VAR 0 7
70774: PUSH
70775: LD_VAR 0 9
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PPUSH
70784: CALL_OW 2
70788: ST_TO_ADDR
70789: GO 70871
// for j = 1 to result do
70791: LD_ADDR_VAR 0 8
70795: PUSH
70796: DOUBLE
70797: LD_INT 1
70799: DEC
70800: ST_TO_ADDR
70801: LD_VAR 0 6
70805: PUSH
70806: FOR_TO
70807: IFFALSE 70869
// begin if tmp < result [ j ] [ 2 ] then
70809: LD_VAR 0 9
70813: PUSH
70814: LD_VAR 0 6
70818: PUSH
70819: LD_VAR 0 8
70823: ARRAY
70824: PUSH
70825: LD_INT 2
70827: ARRAY
70828: LESS
70829: IFFALSE 70867
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70831: LD_ADDR_VAR 0 6
70835: PUSH
70836: LD_VAR 0 6
70840: PPUSH
70841: LD_VAR 0 8
70845: PPUSH
70846: LD_VAR 0 7
70850: PUSH
70851: LD_VAR 0 9
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PPUSH
70860: CALL_OW 2
70864: ST_TO_ADDR
// break ;
70865: GO 70869
// end ; end ;
70867: GO 70806
70869: POP
70870: POP
// end ; end ;
70871: GO 70670
70873: POP
70874: POP
// if result and not asc then
70875: LD_VAR 0 6
70879: PUSH
70880: LD_VAR 0 4
70884: NOT
70885: AND
70886: IFFALSE 70961
// begin tmp := result ;
70888: LD_ADDR_VAR 0 9
70892: PUSH
70893: LD_VAR 0 6
70897: ST_TO_ADDR
// for i = tmp downto 1 do
70898: LD_ADDR_VAR 0 7
70902: PUSH
70903: DOUBLE
70904: LD_VAR 0 9
70908: INC
70909: ST_TO_ADDR
70910: LD_INT 1
70912: PUSH
70913: FOR_DOWNTO
70914: IFFALSE 70959
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70916: LD_ADDR_VAR 0 6
70920: PUSH
70921: LD_VAR 0 6
70925: PPUSH
70926: LD_VAR 0 9
70930: PUSH
70931: LD_VAR 0 7
70935: MINUS
70936: PUSH
70937: LD_INT 1
70939: PLUS
70940: PPUSH
70941: LD_VAR 0 9
70945: PUSH
70946: LD_VAR 0 7
70950: ARRAY
70951: PPUSH
70952: CALL_OW 1
70956: ST_TO_ADDR
70957: GO 70913
70959: POP
70960: POP
// end ; tmp := [ ] ;
70961: LD_ADDR_VAR 0 9
70965: PUSH
70966: EMPTY
70967: ST_TO_ADDR
// if mode then
70968: LD_VAR 0 5
70972: IFFALSE 71041
// begin for i = 1 to result do
70974: LD_ADDR_VAR 0 7
70978: PUSH
70979: DOUBLE
70980: LD_INT 1
70982: DEC
70983: ST_TO_ADDR
70984: LD_VAR 0 6
70988: PUSH
70989: FOR_TO
70990: IFFALSE 71029
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70992: LD_ADDR_VAR 0 9
70996: PUSH
70997: LD_VAR 0 9
71001: PPUSH
71002: LD_VAR 0 7
71006: PPUSH
71007: LD_VAR 0 6
71011: PUSH
71012: LD_VAR 0 7
71016: ARRAY
71017: PUSH
71018: LD_INT 1
71020: ARRAY
71021: PPUSH
71022: CALL_OW 1
71026: ST_TO_ADDR
71027: GO 70989
71029: POP
71030: POP
// result := tmp ;
71031: LD_ADDR_VAR 0 6
71035: PUSH
71036: LD_VAR 0 9
71040: ST_TO_ADDR
// end ; end ;
71041: LD_VAR 0 6
71045: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71046: LD_INT 0
71048: PPUSH
71049: PPUSH
71050: PPUSH
71051: PPUSH
71052: PPUSH
71053: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71054: LD_ADDR_VAR 0 5
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: ST_TO_ADDR
// if not x or not y then
71076: LD_VAR 0 2
71080: NOT
71081: PUSH
71082: LD_VAR 0 3
71086: NOT
71087: OR
71088: IFFALSE 71092
// exit ;
71090: GO 72738
// if not range then
71092: LD_VAR 0 4
71096: NOT
71097: IFFALSE 71107
// range := 10 ;
71099: LD_ADDR_VAR 0 4
71103: PUSH
71104: LD_INT 10
71106: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71107: LD_ADDR_VAR 0 8
71111: PUSH
71112: LD_INT 81
71114: PUSH
71115: LD_VAR 0 1
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 92
71126: PUSH
71127: LD_VAR 0 2
71131: PUSH
71132: LD_VAR 0 3
71136: PUSH
71137: LD_VAR 0 4
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 3
71150: PUSH
71151: LD_INT 21
71153: PUSH
71154: LD_INT 3
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: LIST
71169: PPUSH
71170: CALL_OW 69
71174: ST_TO_ADDR
// if not tmp then
71175: LD_VAR 0 8
71179: NOT
71180: IFFALSE 71184
// exit ;
71182: GO 72738
// for i in tmp do
71184: LD_ADDR_VAR 0 6
71188: PUSH
71189: LD_VAR 0 8
71193: PUSH
71194: FOR_IN
71195: IFFALSE 72713
// begin points := [ 0 , 0 , 0 ] ;
71197: LD_ADDR_VAR 0 9
71201: PUSH
71202: LD_INT 0
71204: PUSH
71205: LD_INT 0
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: LIST
71215: ST_TO_ADDR
// bpoints := 1 ;
71216: LD_ADDR_VAR 0 10
71220: PUSH
71221: LD_INT 1
71223: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71224: LD_VAR 0 6
71228: PPUSH
71229: CALL_OW 247
71233: PUSH
71234: LD_INT 1
71236: DOUBLE
71237: EQUAL
71238: IFTRUE 71242
71240: GO 71820
71242: POP
// begin if GetClass ( i ) = 1 then
71243: LD_VAR 0 6
71247: PPUSH
71248: CALL_OW 257
71252: PUSH
71253: LD_INT 1
71255: EQUAL
71256: IFFALSE 71277
// points := [ 10 , 5 , 3 ] ;
71258: LD_ADDR_VAR 0 9
71262: PUSH
71263: LD_INT 10
71265: PUSH
71266: LD_INT 5
71268: PUSH
71269: LD_INT 3
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: LIST
71276: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71277: LD_VAR 0 6
71281: PPUSH
71282: CALL_OW 257
71286: PUSH
71287: LD_INT 2
71289: PUSH
71290: LD_INT 3
71292: PUSH
71293: LD_INT 4
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: LIST
71300: IN
71301: IFFALSE 71322
// points := [ 3 , 2 , 1 ] ;
71303: LD_ADDR_VAR 0 9
71307: PUSH
71308: LD_INT 3
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: LIST
71321: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71322: LD_VAR 0 6
71326: PPUSH
71327: CALL_OW 257
71331: PUSH
71332: LD_INT 5
71334: EQUAL
71335: IFFALSE 71356
// points := [ 130 , 5 , 2 ] ;
71337: LD_ADDR_VAR 0 9
71341: PUSH
71342: LD_INT 130
71344: PUSH
71345: LD_INT 5
71347: PUSH
71348: LD_INT 2
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: LIST
71355: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71356: LD_VAR 0 6
71360: PPUSH
71361: CALL_OW 257
71365: PUSH
71366: LD_INT 8
71368: EQUAL
71369: IFFALSE 71390
// points := [ 35 , 35 , 30 ] ;
71371: LD_ADDR_VAR 0 9
71375: PUSH
71376: LD_INT 35
71378: PUSH
71379: LD_INT 35
71381: PUSH
71382: LD_INT 30
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: LIST
71389: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71390: LD_VAR 0 6
71394: PPUSH
71395: CALL_OW 257
71399: PUSH
71400: LD_INT 9
71402: EQUAL
71403: IFFALSE 71424
// points := [ 20 , 55 , 40 ] ;
71405: LD_ADDR_VAR 0 9
71409: PUSH
71410: LD_INT 20
71412: PUSH
71413: LD_INT 55
71415: PUSH
71416: LD_INT 40
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71424: LD_VAR 0 6
71428: PPUSH
71429: CALL_OW 257
71433: PUSH
71434: LD_INT 12
71436: PUSH
71437: LD_INT 16
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: IN
71444: IFFALSE 71465
// points := [ 5 , 3 , 2 ] ;
71446: LD_ADDR_VAR 0 9
71450: PUSH
71451: LD_INT 5
71453: PUSH
71454: LD_INT 3
71456: PUSH
71457: LD_INT 2
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71465: LD_VAR 0 6
71469: PPUSH
71470: CALL_OW 257
71474: PUSH
71475: LD_INT 17
71477: EQUAL
71478: IFFALSE 71499
// points := [ 100 , 50 , 75 ] ;
71480: LD_ADDR_VAR 0 9
71484: PUSH
71485: LD_INT 100
71487: PUSH
71488: LD_INT 50
71490: PUSH
71491: LD_INT 75
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: LIST
71498: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71499: LD_VAR 0 6
71503: PPUSH
71504: CALL_OW 257
71508: PUSH
71509: LD_INT 15
71511: EQUAL
71512: IFFALSE 71533
// points := [ 10 , 5 , 3 ] ;
71514: LD_ADDR_VAR 0 9
71518: PUSH
71519: LD_INT 10
71521: PUSH
71522: LD_INT 5
71524: PUSH
71525: LD_INT 3
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71533: LD_VAR 0 6
71537: PPUSH
71538: CALL_OW 257
71542: PUSH
71543: LD_INT 14
71545: EQUAL
71546: IFFALSE 71567
// points := [ 10 , 0 , 0 ] ;
71548: LD_ADDR_VAR 0 9
71552: PUSH
71553: LD_INT 10
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: LD_INT 0
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: LIST
71566: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71567: LD_VAR 0 6
71571: PPUSH
71572: CALL_OW 257
71576: PUSH
71577: LD_INT 11
71579: EQUAL
71580: IFFALSE 71601
// points := [ 30 , 10 , 5 ] ;
71582: LD_ADDR_VAR 0 9
71586: PUSH
71587: LD_INT 30
71589: PUSH
71590: LD_INT 10
71592: PUSH
71593: LD_INT 5
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: LIST
71600: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71601: LD_VAR 0 1
71605: PPUSH
71606: LD_INT 5
71608: PPUSH
71609: CALL_OW 321
71613: PUSH
71614: LD_INT 2
71616: EQUAL
71617: IFFALSE 71634
// bpoints := bpoints * 1.8 ;
71619: LD_ADDR_VAR 0 10
71623: PUSH
71624: LD_VAR 0 10
71628: PUSH
71629: LD_REAL  1.80000000000000E+0000
71632: MUL
71633: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71634: LD_VAR 0 6
71638: PPUSH
71639: CALL_OW 257
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: LD_INT 3
71652: PUSH
71653: LD_INT 4
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: IN
71662: PUSH
71663: LD_VAR 0 1
71667: PPUSH
71668: LD_INT 51
71670: PPUSH
71671: CALL_OW 321
71675: PUSH
71676: LD_INT 2
71678: EQUAL
71679: AND
71680: IFFALSE 71697
// bpoints := bpoints * 1.2 ;
71682: LD_ADDR_VAR 0 10
71686: PUSH
71687: LD_VAR 0 10
71691: PUSH
71692: LD_REAL  1.20000000000000E+0000
71695: MUL
71696: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71697: LD_VAR 0 6
71701: PPUSH
71702: CALL_OW 257
71706: PUSH
71707: LD_INT 5
71709: PUSH
71710: LD_INT 7
71712: PUSH
71713: LD_INT 9
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: LIST
71720: IN
71721: PUSH
71722: LD_VAR 0 1
71726: PPUSH
71727: LD_INT 52
71729: PPUSH
71730: CALL_OW 321
71734: PUSH
71735: LD_INT 2
71737: EQUAL
71738: AND
71739: IFFALSE 71756
// bpoints := bpoints * 1.5 ;
71741: LD_ADDR_VAR 0 10
71745: PUSH
71746: LD_VAR 0 10
71750: PUSH
71751: LD_REAL  1.50000000000000E+0000
71754: MUL
71755: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71756: LD_VAR 0 1
71760: PPUSH
71761: LD_INT 66
71763: PPUSH
71764: CALL_OW 321
71768: PUSH
71769: LD_INT 2
71771: EQUAL
71772: IFFALSE 71789
// bpoints := bpoints * 1.1 ;
71774: LD_ADDR_VAR 0 10
71778: PUSH
71779: LD_VAR 0 10
71783: PUSH
71784: LD_REAL  1.10000000000000E+0000
71787: MUL
71788: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71789: LD_ADDR_VAR 0 10
71793: PUSH
71794: LD_VAR 0 10
71798: PUSH
71799: LD_VAR 0 6
71803: PPUSH
71804: LD_INT 1
71806: PPUSH
71807: CALL_OW 259
71811: PUSH
71812: LD_REAL  1.15000000000000E+0000
71815: MUL
71816: MUL
71817: ST_TO_ADDR
// end ; unit_vehicle :
71818: GO 72642
71820: LD_INT 2
71822: DOUBLE
71823: EQUAL
71824: IFTRUE 71828
71826: GO 72630
71828: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71829: LD_VAR 0 6
71833: PPUSH
71834: CALL_OW 264
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: LD_INT 42
71844: PUSH
71845: LD_INT 24
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: LIST
71852: IN
71853: IFFALSE 71874
// points := [ 25 , 5 , 3 ] ;
71855: LD_ADDR_VAR 0 9
71859: PUSH
71860: LD_INT 25
71862: PUSH
71863: LD_INT 5
71865: PUSH
71866: LD_INT 3
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: LIST
71873: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71874: LD_VAR 0 6
71878: PPUSH
71879: CALL_OW 264
71883: PUSH
71884: LD_INT 4
71886: PUSH
71887: LD_INT 43
71889: PUSH
71890: LD_INT 25
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: LIST
71897: IN
71898: IFFALSE 71919
// points := [ 40 , 15 , 5 ] ;
71900: LD_ADDR_VAR 0 9
71904: PUSH
71905: LD_INT 40
71907: PUSH
71908: LD_INT 15
71910: PUSH
71911: LD_INT 5
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: LIST
71918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71919: LD_VAR 0 6
71923: PPUSH
71924: CALL_OW 264
71928: PUSH
71929: LD_INT 3
71931: PUSH
71932: LD_INT 23
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: IN
71939: IFFALSE 71960
// points := [ 7 , 25 , 8 ] ;
71941: LD_ADDR_VAR 0 9
71945: PUSH
71946: LD_INT 7
71948: PUSH
71949: LD_INT 25
71951: PUSH
71952: LD_INT 8
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: LIST
71959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71960: LD_VAR 0 6
71964: PPUSH
71965: CALL_OW 264
71969: PUSH
71970: LD_INT 5
71972: PUSH
71973: LD_INT 27
71975: PUSH
71976: LD_INT 44
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: IN
71984: IFFALSE 72005
// points := [ 14 , 50 , 16 ] ;
71986: LD_ADDR_VAR 0 9
71990: PUSH
71991: LD_INT 14
71993: PUSH
71994: LD_INT 50
71996: PUSH
71997: LD_INT 16
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: LIST
72004: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72005: LD_VAR 0 6
72009: PPUSH
72010: CALL_OW 264
72014: PUSH
72015: LD_INT 6
72017: PUSH
72018: LD_INT 46
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: IN
72025: IFFALSE 72046
// points := [ 32 , 120 , 70 ] ;
72027: LD_ADDR_VAR 0 9
72031: PUSH
72032: LD_INT 32
72034: PUSH
72035: LD_INT 120
72037: PUSH
72038: LD_INT 70
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: LIST
72045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72046: LD_VAR 0 6
72050: PPUSH
72051: CALL_OW 264
72055: PUSH
72056: LD_INT 7
72058: PUSH
72059: LD_INT 28
72061: PUSH
72062: LD_INT 45
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: IN
72070: IFFALSE 72091
// points := [ 35 , 20 , 45 ] ;
72072: LD_ADDR_VAR 0 9
72076: PUSH
72077: LD_INT 35
72079: PUSH
72080: LD_INT 20
72082: PUSH
72083: LD_INT 45
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: LIST
72090: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72091: LD_VAR 0 6
72095: PPUSH
72096: CALL_OW 264
72100: PUSH
72101: LD_INT 47
72103: PUSH
72104: EMPTY
72105: LIST
72106: IN
72107: IFFALSE 72128
// points := [ 67 , 45 , 75 ] ;
72109: LD_ADDR_VAR 0 9
72113: PUSH
72114: LD_INT 67
72116: PUSH
72117: LD_INT 45
72119: PUSH
72120: LD_INT 75
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: LIST
72127: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72128: LD_VAR 0 6
72132: PPUSH
72133: CALL_OW 264
72137: PUSH
72138: LD_INT 26
72140: PUSH
72141: EMPTY
72142: LIST
72143: IN
72144: IFFALSE 72165
// points := [ 120 , 30 , 80 ] ;
72146: LD_ADDR_VAR 0 9
72150: PUSH
72151: LD_INT 120
72153: PUSH
72154: LD_INT 30
72156: PUSH
72157: LD_INT 80
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: LIST
72164: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72165: LD_VAR 0 6
72169: PPUSH
72170: CALL_OW 264
72174: PUSH
72175: LD_INT 22
72177: PUSH
72178: EMPTY
72179: LIST
72180: IN
72181: IFFALSE 72202
// points := [ 40 , 1 , 1 ] ;
72183: LD_ADDR_VAR 0 9
72187: PUSH
72188: LD_INT 40
72190: PUSH
72191: LD_INT 1
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: LIST
72201: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72202: LD_VAR 0 6
72206: PPUSH
72207: CALL_OW 264
72211: PUSH
72212: LD_INT 29
72214: PUSH
72215: EMPTY
72216: LIST
72217: IN
72218: IFFALSE 72239
// points := [ 70 , 200 , 400 ] ;
72220: LD_ADDR_VAR 0 9
72224: PUSH
72225: LD_INT 70
72227: PUSH
72228: LD_INT 200
72230: PUSH
72231: LD_INT 400
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: LIST
72238: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72239: LD_VAR 0 6
72243: PPUSH
72244: CALL_OW 264
72248: PUSH
72249: LD_INT 14
72251: PUSH
72252: LD_INT 53
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: IN
72259: IFFALSE 72280
// points := [ 40 , 10 , 20 ] ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_INT 40
72268: PUSH
72269: LD_INT 10
72271: PUSH
72272: LD_INT 20
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: LIST
72279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72280: LD_VAR 0 6
72284: PPUSH
72285: CALL_OW 264
72289: PUSH
72290: LD_INT 9
72292: PUSH
72293: EMPTY
72294: LIST
72295: IN
72296: IFFALSE 72317
// points := [ 5 , 70 , 20 ] ;
72298: LD_ADDR_VAR 0 9
72302: PUSH
72303: LD_INT 5
72305: PUSH
72306: LD_INT 70
72308: PUSH
72309: LD_INT 20
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: LIST
72316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72317: LD_VAR 0 6
72321: PPUSH
72322: CALL_OW 264
72326: PUSH
72327: LD_INT 10
72329: PUSH
72330: EMPTY
72331: LIST
72332: IN
72333: IFFALSE 72354
// points := [ 35 , 110 , 70 ] ;
72335: LD_ADDR_VAR 0 9
72339: PUSH
72340: LD_INT 35
72342: PUSH
72343: LD_INT 110
72345: PUSH
72346: LD_INT 70
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: LIST
72353: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72354: LD_VAR 0 6
72358: PPUSH
72359: CALL_OW 265
72363: PUSH
72364: LD_INT 25
72366: EQUAL
72367: IFFALSE 72388
// points := [ 80 , 65 , 100 ] ;
72369: LD_ADDR_VAR 0 9
72373: PUSH
72374: LD_INT 80
72376: PUSH
72377: LD_INT 65
72379: PUSH
72380: LD_INT 100
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: LIST
72387: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72388: LD_VAR 0 6
72392: PPUSH
72393: CALL_OW 263
72397: PUSH
72398: LD_INT 1
72400: EQUAL
72401: IFFALSE 72436
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72403: LD_ADDR_VAR 0 10
72407: PUSH
72408: LD_VAR 0 10
72412: PUSH
72413: LD_VAR 0 6
72417: PPUSH
72418: CALL_OW 311
72422: PPUSH
72423: LD_INT 3
72425: PPUSH
72426: CALL_OW 259
72430: PUSH
72431: LD_INT 4
72433: MUL
72434: MUL
72435: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72436: LD_VAR 0 6
72440: PPUSH
72441: CALL_OW 263
72445: PUSH
72446: LD_INT 2
72448: EQUAL
72449: IFFALSE 72500
// begin j := IsControledBy ( i ) ;
72451: LD_ADDR_VAR 0 7
72455: PUSH
72456: LD_VAR 0 6
72460: PPUSH
72461: CALL_OW 312
72465: ST_TO_ADDR
// if j then
72466: LD_VAR 0 7
72470: IFFALSE 72500
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72472: LD_ADDR_VAR 0 10
72476: PUSH
72477: LD_VAR 0 10
72481: PUSH
72482: LD_VAR 0 7
72486: PPUSH
72487: LD_INT 3
72489: PPUSH
72490: CALL_OW 259
72494: PUSH
72495: LD_INT 3
72497: MUL
72498: MUL
72499: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72500: LD_VAR 0 6
72504: PPUSH
72505: CALL_OW 264
72509: PUSH
72510: LD_INT 5
72512: PUSH
72513: LD_INT 6
72515: PUSH
72516: LD_INT 46
72518: PUSH
72519: LD_INT 44
72521: PUSH
72522: LD_INT 47
72524: PUSH
72525: LD_INT 45
72527: PUSH
72528: LD_INT 28
72530: PUSH
72531: LD_INT 7
72533: PUSH
72534: LD_INT 27
72536: PUSH
72537: LD_INT 29
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: IN
72552: PUSH
72553: LD_VAR 0 1
72557: PPUSH
72558: LD_INT 52
72560: PPUSH
72561: CALL_OW 321
72565: PUSH
72566: LD_INT 2
72568: EQUAL
72569: AND
72570: IFFALSE 72587
// bpoints := bpoints * 1.2 ;
72572: LD_ADDR_VAR 0 10
72576: PUSH
72577: LD_VAR 0 10
72581: PUSH
72582: LD_REAL  1.20000000000000E+0000
72585: MUL
72586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72587: LD_VAR 0 6
72591: PPUSH
72592: CALL_OW 264
72596: PUSH
72597: LD_INT 6
72599: PUSH
72600: LD_INT 46
72602: PUSH
72603: LD_INT 47
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: LIST
72610: IN
72611: IFFALSE 72628
// bpoints := bpoints * 1.2 ;
72613: LD_ADDR_VAR 0 10
72617: PUSH
72618: LD_VAR 0 10
72622: PUSH
72623: LD_REAL  1.20000000000000E+0000
72626: MUL
72627: ST_TO_ADDR
// end ; unit_building :
72628: GO 72642
72630: LD_INT 3
72632: DOUBLE
72633: EQUAL
72634: IFTRUE 72638
72636: GO 72641
72638: POP
// ; end ;
72639: GO 72642
72641: POP
// for j = 1 to 3 do
72642: LD_ADDR_VAR 0 7
72646: PUSH
72647: DOUBLE
72648: LD_INT 1
72650: DEC
72651: ST_TO_ADDR
72652: LD_INT 3
72654: PUSH
72655: FOR_TO
72656: IFFALSE 72709
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72658: LD_ADDR_VAR 0 5
72662: PUSH
72663: LD_VAR 0 5
72667: PPUSH
72668: LD_VAR 0 7
72672: PPUSH
72673: LD_VAR 0 5
72677: PUSH
72678: LD_VAR 0 7
72682: ARRAY
72683: PUSH
72684: LD_VAR 0 9
72688: PUSH
72689: LD_VAR 0 7
72693: ARRAY
72694: PUSH
72695: LD_VAR 0 10
72699: MUL
72700: PLUS
72701: PPUSH
72702: CALL_OW 1
72706: ST_TO_ADDR
72707: GO 72655
72709: POP
72710: POP
// end ;
72711: GO 71194
72713: POP
72714: POP
// result := Replace ( result , 4 , tmp ) ;
72715: LD_ADDR_VAR 0 5
72719: PUSH
72720: LD_VAR 0 5
72724: PPUSH
72725: LD_INT 4
72727: PPUSH
72728: LD_VAR 0 8
72732: PPUSH
72733: CALL_OW 1
72737: ST_TO_ADDR
// end ;
72738: LD_VAR 0 5
72742: RET
// export function DangerAtRange ( unit , range ) ; begin
72743: LD_INT 0
72745: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_VAR 0 1
72755: PPUSH
72756: CALL_OW 255
72760: PPUSH
72761: LD_VAR 0 1
72765: PPUSH
72766: CALL_OW 250
72770: PPUSH
72771: LD_VAR 0 1
72775: PPUSH
72776: CALL_OW 251
72780: PPUSH
72781: LD_VAR 0 2
72785: PPUSH
72786: CALL 71046 0 4
72790: ST_TO_ADDR
// end ;
72791: LD_VAR 0 3
72795: RET
// export function DangerInArea ( side , area ) ; begin
72796: LD_INT 0
72798: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72799: LD_ADDR_VAR 0 3
72803: PUSH
72804: LD_VAR 0 2
72808: PPUSH
72809: LD_INT 81
72811: PUSH
72812: LD_VAR 0 1
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PPUSH
72821: CALL_OW 70
72825: ST_TO_ADDR
// end ;
72826: LD_VAR 0 3
72830: RET
// export function IsExtension ( b ) ; begin
72831: LD_INT 0
72833: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72834: LD_ADDR_VAR 0 2
72838: PUSH
72839: LD_VAR 0 1
72843: PUSH
72844: LD_INT 23
72846: PUSH
72847: LD_INT 20
72849: PUSH
72850: LD_INT 22
72852: PUSH
72853: LD_INT 17
72855: PUSH
72856: LD_INT 24
72858: PUSH
72859: LD_INT 21
72861: PUSH
72862: LD_INT 19
72864: PUSH
72865: LD_INT 16
72867: PUSH
72868: LD_INT 25
72870: PUSH
72871: LD_INT 18
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: IN
72886: ST_TO_ADDR
// end ;
72887: LD_VAR 0 2
72891: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72892: LD_INT 0
72894: PPUSH
72895: PPUSH
72896: PPUSH
// result := [ ] ;
72897: LD_ADDR_VAR 0 3
72901: PUSH
72902: EMPTY
72903: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72904: LD_ADDR_VAR 0 4
72908: PUSH
72909: LD_VAR 0 2
72913: PPUSH
72914: LD_INT 21
72916: PUSH
72917: LD_INT 3
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PPUSH
72924: CALL_OW 70
72928: ST_TO_ADDR
// if not tmp then
72929: LD_VAR 0 4
72933: NOT
72934: IFFALSE 72938
// exit ;
72936: GO 72996
// for i in tmp do
72938: LD_ADDR_VAR 0 5
72942: PUSH
72943: LD_VAR 0 4
72947: PUSH
72948: FOR_IN
72949: IFFALSE 72984
// if GetBase ( i ) <> base then
72951: LD_VAR 0 5
72955: PPUSH
72956: CALL_OW 274
72960: PUSH
72961: LD_VAR 0 1
72965: NONEQUAL
72966: IFFALSE 72982
// ComLinkToBase ( base , i ) ;
72968: LD_VAR 0 1
72972: PPUSH
72973: LD_VAR 0 5
72977: PPUSH
72978: CALL_OW 169
72982: GO 72948
72984: POP
72985: POP
// result := tmp ;
72986: LD_ADDR_VAR 0 3
72990: PUSH
72991: LD_VAR 0 4
72995: ST_TO_ADDR
// end ;
72996: LD_VAR 0 3
73000: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73001: LD_INT 0
73003: PPUSH
73004: PPUSH
// if BuildingStatus ( b ) = bs_build then
73005: LD_VAR 0 2
73009: PPUSH
73010: CALL_OW 461
73014: PUSH
73015: LD_INT 1
73017: EQUAL
73018: IFFALSE 73078
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73020: LD_VAR 0 1
73024: PPUSH
73025: LD_STRING h
73027: PUSH
73028: LD_VAR 0 2
73032: PPUSH
73033: CALL_OW 250
73037: PUSH
73038: LD_VAR 0 2
73042: PPUSH
73043: CALL_OW 251
73047: PUSH
73048: LD_VAR 0 2
73052: PUSH
73053: LD_INT 0
73055: PUSH
73056: LD_INT 0
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: PUSH
73071: EMPTY
73072: LIST
73073: PPUSH
73074: CALL_OW 446
// end ;
73078: LD_VAR 0 3
73082: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73083: LD_INT 0
73085: PPUSH
73086: PPUSH
73087: PPUSH
73088: PPUSH
73089: PPUSH
73090: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73091: LD_VAR 0 1
73095: NOT
73096: PUSH
73097: LD_VAR 0 1
73101: PPUSH
73102: CALL_OW 263
73106: PUSH
73107: LD_INT 2
73109: EQUAL
73110: NOT
73111: OR
73112: IFFALSE 73116
// exit ;
73114: GO 73432
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73116: LD_ADDR_VAR 0 6
73120: PUSH
73121: LD_INT 22
73123: PUSH
73124: LD_VAR 0 1
73128: PPUSH
73129: CALL_OW 255
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 2
73140: PUSH
73141: LD_INT 30
73143: PUSH
73144: LD_INT 36
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 34
73153: PUSH
73154: LD_INT 31
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: LIST
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PPUSH
73170: CALL_OW 69
73174: ST_TO_ADDR
// if not tmp then
73175: LD_VAR 0 6
73179: NOT
73180: IFFALSE 73184
// exit ;
73182: GO 73432
// result := [ ] ;
73184: LD_ADDR_VAR 0 2
73188: PUSH
73189: EMPTY
73190: ST_TO_ADDR
// for i in tmp do
73191: LD_ADDR_VAR 0 3
73195: PUSH
73196: LD_VAR 0 6
73200: PUSH
73201: FOR_IN
73202: IFFALSE 73273
// begin t := UnitsInside ( i ) ;
73204: LD_ADDR_VAR 0 4
73208: PUSH
73209: LD_VAR 0 3
73213: PPUSH
73214: CALL_OW 313
73218: ST_TO_ADDR
// if t then
73219: LD_VAR 0 4
73223: IFFALSE 73271
// for j in t do
73225: LD_ADDR_VAR 0 7
73229: PUSH
73230: LD_VAR 0 4
73234: PUSH
73235: FOR_IN
73236: IFFALSE 73269
// result := Insert ( result , result + 1 , j ) ;
73238: LD_ADDR_VAR 0 2
73242: PUSH
73243: LD_VAR 0 2
73247: PPUSH
73248: LD_VAR 0 2
73252: PUSH
73253: LD_INT 1
73255: PLUS
73256: PPUSH
73257: LD_VAR 0 7
73261: PPUSH
73262: CALL_OW 2
73266: ST_TO_ADDR
73267: GO 73235
73269: POP
73270: POP
// end ;
73271: GO 73201
73273: POP
73274: POP
// if not result then
73275: LD_VAR 0 2
73279: NOT
73280: IFFALSE 73284
// exit ;
73282: GO 73432
// mech := result [ 1 ] ;
73284: LD_ADDR_VAR 0 5
73288: PUSH
73289: LD_VAR 0 2
73293: PUSH
73294: LD_INT 1
73296: ARRAY
73297: ST_TO_ADDR
// if result > 1 then
73298: LD_VAR 0 2
73302: PUSH
73303: LD_INT 1
73305: GREATER
73306: IFFALSE 73418
// for i = 2 to result do
73308: LD_ADDR_VAR 0 3
73312: PUSH
73313: DOUBLE
73314: LD_INT 2
73316: DEC
73317: ST_TO_ADDR
73318: LD_VAR 0 2
73322: PUSH
73323: FOR_TO
73324: IFFALSE 73416
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73326: LD_ADDR_VAR 0 4
73330: PUSH
73331: LD_VAR 0 2
73335: PUSH
73336: LD_VAR 0 3
73340: ARRAY
73341: PPUSH
73342: LD_INT 3
73344: PPUSH
73345: CALL_OW 259
73349: PUSH
73350: LD_VAR 0 2
73354: PUSH
73355: LD_VAR 0 3
73359: ARRAY
73360: PPUSH
73361: CALL_OW 432
73365: MINUS
73366: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73367: LD_VAR 0 4
73371: PUSH
73372: LD_VAR 0 5
73376: PPUSH
73377: LD_INT 3
73379: PPUSH
73380: CALL_OW 259
73384: PUSH
73385: LD_VAR 0 5
73389: PPUSH
73390: CALL_OW 432
73394: MINUS
73395: GREATEREQUAL
73396: IFFALSE 73414
// mech := result [ i ] ;
73398: LD_ADDR_VAR 0 5
73402: PUSH
73403: LD_VAR 0 2
73407: PUSH
73408: LD_VAR 0 3
73412: ARRAY
73413: ST_TO_ADDR
// end ;
73414: GO 73323
73416: POP
73417: POP
// ComLinkTo ( vehicle , mech ) ;
73418: LD_VAR 0 1
73422: PPUSH
73423: LD_VAR 0 5
73427: PPUSH
73428: CALL_OW 135
// end ;
73432: LD_VAR 0 2
73436: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73437: LD_INT 0
73439: PPUSH
73440: PPUSH
73441: PPUSH
73442: PPUSH
73443: PPUSH
73444: PPUSH
73445: PPUSH
73446: PPUSH
73447: PPUSH
73448: PPUSH
73449: PPUSH
73450: PPUSH
73451: PPUSH
// result := [ ] ;
73452: LD_ADDR_VAR 0 7
73456: PUSH
73457: EMPTY
73458: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73459: LD_VAR 0 1
73463: PPUSH
73464: CALL_OW 266
73468: PUSH
73469: LD_INT 0
73471: PUSH
73472: LD_INT 1
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: IN
73479: NOT
73480: IFFALSE 73484
// exit ;
73482: GO 75115
// if name then
73484: LD_VAR 0 3
73488: IFFALSE 73504
// SetBName ( base_dep , name ) ;
73490: LD_VAR 0 1
73494: PPUSH
73495: LD_VAR 0 3
73499: PPUSH
73500: CALL_OW 500
// base := GetBase ( base_dep ) ;
73504: LD_ADDR_VAR 0 15
73508: PUSH
73509: LD_VAR 0 1
73513: PPUSH
73514: CALL_OW 274
73518: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73519: LD_ADDR_VAR 0 16
73523: PUSH
73524: LD_VAR 0 1
73528: PPUSH
73529: CALL_OW 255
73533: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73534: LD_ADDR_VAR 0 17
73538: PUSH
73539: LD_VAR 0 1
73543: PPUSH
73544: CALL_OW 248
73548: ST_TO_ADDR
// if sources then
73549: LD_VAR 0 5
73553: IFFALSE 73600
// for i = 1 to 3 do
73555: LD_ADDR_VAR 0 8
73559: PUSH
73560: DOUBLE
73561: LD_INT 1
73563: DEC
73564: ST_TO_ADDR
73565: LD_INT 3
73567: PUSH
73568: FOR_TO
73569: IFFALSE 73598
// AddResourceType ( base , i , sources [ i ] ) ;
73571: LD_VAR 0 15
73575: PPUSH
73576: LD_VAR 0 8
73580: PPUSH
73581: LD_VAR 0 5
73585: PUSH
73586: LD_VAR 0 8
73590: ARRAY
73591: PPUSH
73592: CALL_OW 276
73596: GO 73568
73598: POP
73599: POP
// buildings := GetBaseBuildings ( base , area ) ;
73600: LD_ADDR_VAR 0 18
73604: PUSH
73605: LD_VAR 0 15
73609: PPUSH
73610: LD_VAR 0 2
73614: PPUSH
73615: CALL 72892 0 2
73619: ST_TO_ADDR
// InitHc ;
73620: CALL_OW 19
// InitUc ;
73624: CALL_OW 18
// uc_side := side ;
73628: LD_ADDR_OWVAR 20
73632: PUSH
73633: LD_VAR 0 16
73637: ST_TO_ADDR
// uc_nation := nation ;
73638: LD_ADDR_OWVAR 21
73642: PUSH
73643: LD_VAR 0 17
73647: ST_TO_ADDR
// if buildings then
73648: LD_VAR 0 18
73652: IFFALSE 74974
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73654: LD_ADDR_VAR 0 19
73658: PUSH
73659: LD_VAR 0 18
73663: PPUSH
73664: LD_INT 2
73666: PUSH
73667: LD_INT 30
73669: PUSH
73670: LD_INT 29
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 30
73679: PUSH
73680: LD_INT 30
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: LIST
73691: PPUSH
73692: CALL_OW 72
73696: ST_TO_ADDR
// if tmp then
73697: LD_VAR 0 19
73701: IFFALSE 73749
// for i in tmp do
73703: LD_ADDR_VAR 0 8
73707: PUSH
73708: LD_VAR 0 19
73712: PUSH
73713: FOR_IN
73714: IFFALSE 73747
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73716: LD_VAR 0 8
73720: PPUSH
73721: CALL_OW 250
73725: PPUSH
73726: LD_VAR 0 8
73730: PPUSH
73731: CALL_OW 251
73735: PPUSH
73736: LD_VAR 0 16
73740: PPUSH
73741: CALL_OW 441
73745: GO 73713
73747: POP
73748: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73749: LD_VAR 0 18
73753: PPUSH
73754: LD_INT 2
73756: PUSH
73757: LD_INT 30
73759: PUSH
73760: LD_INT 32
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: PUSH
73767: LD_INT 30
73769: PUSH
73770: LD_INT 33
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: LIST
73781: PPUSH
73782: CALL_OW 72
73786: IFFALSE 73874
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73788: LD_ADDR_VAR 0 8
73792: PUSH
73793: LD_VAR 0 18
73797: PPUSH
73798: LD_INT 2
73800: PUSH
73801: LD_INT 30
73803: PUSH
73804: LD_INT 32
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 30
73813: PUSH
73814: LD_INT 33
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: LIST
73825: PPUSH
73826: CALL_OW 72
73830: PUSH
73831: FOR_IN
73832: IFFALSE 73872
// begin if not GetBWeapon ( i ) then
73834: LD_VAR 0 8
73838: PPUSH
73839: CALL_OW 269
73843: NOT
73844: IFFALSE 73870
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73846: LD_VAR 0 8
73850: PPUSH
73851: LD_VAR 0 8
73855: PPUSH
73856: LD_VAR 0 2
73860: PPUSH
73861: CALL 75120 0 2
73865: PPUSH
73866: CALL_OW 431
// end ;
73870: GO 73831
73872: POP
73873: POP
// end ; for i = 1 to personel do
73874: LD_ADDR_VAR 0 8
73878: PUSH
73879: DOUBLE
73880: LD_INT 1
73882: DEC
73883: ST_TO_ADDR
73884: LD_VAR 0 6
73888: PUSH
73889: FOR_TO
73890: IFFALSE 74954
// begin if i > 4 then
73892: LD_VAR 0 8
73896: PUSH
73897: LD_INT 4
73899: GREATER
73900: IFFALSE 73904
// break ;
73902: GO 74954
// case i of 1 :
73904: LD_VAR 0 8
73908: PUSH
73909: LD_INT 1
73911: DOUBLE
73912: EQUAL
73913: IFTRUE 73917
73915: GO 73997
73917: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73918: LD_ADDR_VAR 0 12
73922: PUSH
73923: LD_VAR 0 18
73927: PPUSH
73928: LD_INT 22
73930: PUSH
73931: LD_VAR 0 16
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 58
73942: PUSH
73943: EMPTY
73944: LIST
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: LD_INT 30
73951: PUSH
73952: LD_INT 32
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 30
73961: PUSH
73962: LD_INT 4
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 30
73971: PUSH
73972: LD_INT 5
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: LIST
73989: PPUSH
73990: CALL_OW 72
73994: ST_TO_ADDR
73995: GO 74219
73997: LD_INT 2
73999: DOUBLE
74000: EQUAL
74001: IFTRUE 74005
74003: GO 74067
74005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74006: LD_ADDR_VAR 0 12
74010: PUSH
74011: LD_VAR 0 18
74015: PPUSH
74016: LD_INT 22
74018: PUSH
74019: LD_VAR 0 16
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: PUSH
74031: LD_INT 30
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 30
74043: PUSH
74044: LD_INT 1
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: LIST
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PPUSH
74060: CALL_OW 72
74064: ST_TO_ADDR
74065: GO 74219
74067: LD_INT 3
74069: DOUBLE
74070: EQUAL
74071: IFTRUE 74075
74073: GO 74137
74075: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74076: LD_ADDR_VAR 0 12
74080: PUSH
74081: LD_VAR 0 18
74085: PPUSH
74086: LD_INT 22
74088: PUSH
74089: LD_VAR 0 16
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 2
74100: PUSH
74101: LD_INT 30
74103: PUSH
74104: LD_INT 2
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 30
74113: PUSH
74114: LD_INT 3
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: LIST
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PPUSH
74130: CALL_OW 72
74134: ST_TO_ADDR
74135: GO 74219
74137: LD_INT 4
74139: DOUBLE
74140: EQUAL
74141: IFTRUE 74145
74143: GO 74218
74145: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74146: LD_ADDR_VAR 0 12
74150: PUSH
74151: LD_VAR 0 18
74155: PPUSH
74156: LD_INT 22
74158: PUSH
74159: LD_VAR 0 16
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 2
74170: PUSH
74171: LD_INT 30
74173: PUSH
74174: LD_INT 6
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 30
74183: PUSH
74184: LD_INT 7
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 30
74193: PUSH
74194: LD_INT 8
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PPUSH
74211: CALL_OW 72
74215: ST_TO_ADDR
74216: GO 74219
74218: POP
// if i = 1 then
74219: LD_VAR 0 8
74223: PUSH
74224: LD_INT 1
74226: EQUAL
74227: IFFALSE 74338
// begin tmp := [ ] ;
74229: LD_ADDR_VAR 0 19
74233: PUSH
74234: EMPTY
74235: ST_TO_ADDR
// for j in f do
74236: LD_ADDR_VAR 0 9
74240: PUSH
74241: LD_VAR 0 12
74245: PUSH
74246: FOR_IN
74247: IFFALSE 74320
// if GetBType ( j ) = b_bunker then
74249: LD_VAR 0 9
74253: PPUSH
74254: CALL_OW 266
74258: PUSH
74259: LD_INT 32
74261: EQUAL
74262: IFFALSE 74289
// tmp := Insert ( tmp , 1 , j ) else
74264: LD_ADDR_VAR 0 19
74268: PUSH
74269: LD_VAR 0 19
74273: PPUSH
74274: LD_INT 1
74276: PPUSH
74277: LD_VAR 0 9
74281: PPUSH
74282: CALL_OW 2
74286: ST_TO_ADDR
74287: GO 74318
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74289: LD_ADDR_VAR 0 19
74293: PUSH
74294: LD_VAR 0 19
74298: PPUSH
74299: LD_VAR 0 19
74303: PUSH
74304: LD_INT 1
74306: PLUS
74307: PPUSH
74308: LD_VAR 0 9
74312: PPUSH
74313: CALL_OW 2
74317: ST_TO_ADDR
74318: GO 74246
74320: POP
74321: POP
// if tmp then
74322: LD_VAR 0 19
74326: IFFALSE 74338
// f := tmp ;
74328: LD_ADDR_VAR 0 12
74332: PUSH
74333: LD_VAR 0 19
74337: ST_TO_ADDR
// end ; x := personel [ i ] ;
74338: LD_ADDR_VAR 0 13
74342: PUSH
74343: LD_VAR 0 6
74347: PUSH
74348: LD_VAR 0 8
74352: ARRAY
74353: ST_TO_ADDR
// if x = - 1 then
74354: LD_VAR 0 13
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: EQUAL
74363: IFFALSE 74572
// begin for j in f do
74365: LD_ADDR_VAR 0 9
74369: PUSH
74370: LD_VAR 0 12
74374: PUSH
74375: FOR_IN
74376: IFFALSE 74568
// repeat InitHc ;
74378: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74382: LD_VAR 0 9
74386: PPUSH
74387: CALL_OW 266
74391: PUSH
74392: LD_INT 5
74394: EQUAL
74395: IFFALSE 74465
// begin if UnitsInside ( j ) < 3 then
74397: LD_VAR 0 9
74401: PPUSH
74402: CALL_OW 313
74406: PUSH
74407: LD_INT 3
74409: LESS
74410: IFFALSE 74446
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74412: LD_INT 0
74414: PPUSH
74415: LD_INT 5
74417: PUSH
74418: LD_INT 8
74420: PUSH
74421: LD_INT 9
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: LIST
74428: PUSH
74429: LD_VAR 0 17
74433: ARRAY
74434: PPUSH
74435: LD_VAR 0 4
74439: PPUSH
74440: CALL_OW 380
74444: GO 74463
// PrepareHuman ( false , i , skill ) ;
74446: LD_INT 0
74448: PPUSH
74449: LD_VAR 0 8
74453: PPUSH
74454: LD_VAR 0 4
74458: PPUSH
74459: CALL_OW 380
// end else
74463: GO 74482
// PrepareHuman ( false , i , skill ) ;
74465: LD_INT 0
74467: PPUSH
74468: LD_VAR 0 8
74472: PPUSH
74473: LD_VAR 0 4
74477: PPUSH
74478: CALL_OW 380
// un := CreateHuman ;
74482: LD_ADDR_VAR 0 14
74486: PUSH
74487: CALL_OW 44
74491: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74492: LD_ADDR_VAR 0 7
74496: PUSH
74497: LD_VAR 0 7
74501: PPUSH
74502: LD_INT 1
74504: PPUSH
74505: LD_VAR 0 14
74509: PPUSH
74510: CALL_OW 2
74514: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74515: LD_VAR 0 14
74519: PPUSH
74520: LD_VAR 0 9
74524: PPUSH
74525: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74529: LD_VAR 0 9
74533: PPUSH
74534: CALL_OW 313
74538: PUSH
74539: LD_INT 6
74541: EQUAL
74542: PUSH
74543: LD_VAR 0 9
74547: PPUSH
74548: CALL_OW 266
74552: PUSH
74553: LD_INT 32
74555: PUSH
74556: LD_INT 31
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: IN
74563: OR
74564: IFFALSE 74378
74566: GO 74375
74568: POP
74569: POP
// end else
74570: GO 74952
// for j = 1 to x do
74572: LD_ADDR_VAR 0 9
74576: PUSH
74577: DOUBLE
74578: LD_INT 1
74580: DEC
74581: ST_TO_ADDR
74582: LD_VAR 0 13
74586: PUSH
74587: FOR_TO
74588: IFFALSE 74950
// begin InitHc ;
74590: CALL_OW 19
// if not f then
74594: LD_VAR 0 12
74598: NOT
74599: IFFALSE 74688
// begin PrepareHuman ( false , i , skill ) ;
74601: LD_INT 0
74603: PPUSH
74604: LD_VAR 0 8
74608: PPUSH
74609: LD_VAR 0 4
74613: PPUSH
74614: CALL_OW 380
// un := CreateHuman ;
74618: LD_ADDR_VAR 0 14
74622: PUSH
74623: CALL_OW 44
74627: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74628: LD_ADDR_VAR 0 7
74632: PUSH
74633: LD_VAR 0 7
74637: PPUSH
74638: LD_INT 1
74640: PPUSH
74641: LD_VAR 0 14
74645: PPUSH
74646: CALL_OW 2
74650: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74651: LD_VAR 0 14
74655: PPUSH
74656: LD_VAR 0 1
74660: PPUSH
74661: CALL_OW 250
74665: PPUSH
74666: LD_VAR 0 1
74670: PPUSH
74671: CALL_OW 251
74675: PPUSH
74676: LD_INT 10
74678: PPUSH
74679: LD_INT 0
74681: PPUSH
74682: CALL_OW 50
// continue ;
74686: GO 74587
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74688: LD_VAR 0 12
74692: PUSH
74693: LD_INT 1
74695: ARRAY
74696: PPUSH
74697: CALL_OW 313
74701: PUSH
74702: LD_VAR 0 12
74706: PUSH
74707: LD_INT 1
74709: ARRAY
74710: PPUSH
74711: CALL_OW 266
74715: PUSH
74716: LD_INT 32
74718: PUSH
74719: LD_INT 31
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: IN
74726: AND
74727: PUSH
74728: LD_VAR 0 12
74732: PUSH
74733: LD_INT 1
74735: ARRAY
74736: PPUSH
74737: CALL_OW 313
74741: PUSH
74742: LD_INT 6
74744: EQUAL
74745: OR
74746: IFFALSE 74766
// f := Delete ( f , 1 ) ;
74748: LD_ADDR_VAR 0 12
74752: PUSH
74753: LD_VAR 0 12
74757: PPUSH
74758: LD_INT 1
74760: PPUSH
74761: CALL_OW 3
74765: ST_TO_ADDR
// if not f then
74766: LD_VAR 0 12
74770: NOT
74771: IFFALSE 74789
// begin x := x + 2 ;
74773: LD_ADDR_VAR 0 13
74777: PUSH
74778: LD_VAR 0 13
74782: PUSH
74783: LD_INT 2
74785: PLUS
74786: ST_TO_ADDR
// continue ;
74787: GO 74587
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74789: LD_VAR 0 12
74793: PUSH
74794: LD_INT 1
74796: ARRAY
74797: PPUSH
74798: CALL_OW 266
74802: PUSH
74803: LD_INT 5
74805: EQUAL
74806: IFFALSE 74880
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74808: LD_VAR 0 12
74812: PUSH
74813: LD_INT 1
74815: ARRAY
74816: PPUSH
74817: CALL_OW 313
74821: PUSH
74822: LD_INT 3
74824: LESS
74825: IFFALSE 74861
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74827: LD_INT 0
74829: PPUSH
74830: LD_INT 5
74832: PUSH
74833: LD_INT 8
74835: PUSH
74836: LD_INT 9
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: LIST
74843: PUSH
74844: LD_VAR 0 17
74848: ARRAY
74849: PPUSH
74850: LD_VAR 0 4
74854: PPUSH
74855: CALL_OW 380
74859: GO 74878
// PrepareHuman ( false , i , skill ) ;
74861: LD_INT 0
74863: PPUSH
74864: LD_VAR 0 8
74868: PPUSH
74869: LD_VAR 0 4
74873: PPUSH
74874: CALL_OW 380
// end else
74878: GO 74897
// PrepareHuman ( false , i , skill ) ;
74880: LD_INT 0
74882: PPUSH
74883: LD_VAR 0 8
74887: PPUSH
74888: LD_VAR 0 4
74892: PPUSH
74893: CALL_OW 380
// un := CreateHuman ;
74897: LD_ADDR_VAR 0 14
74901: PUSH
74902: CALL_OW 44
74906: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74907: LD_ADDR_VAR 0 7
74911: PUSH
74912: LD_VAR 0 7
74916: PPUSH
74917: LD_INT 1
74919: PPUSH
74920: LD_VAR 0 14
74924: PPUSH
74925: CALL_OW 2
74929: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74930: LD_VAR 0 14
74934: PPUSH
74935: LD_VAR 0 12
74939: PUSH
74940: LD_INT 1
74942: ARRAY
74943: PPUSH
74944: CALL_OW 52
// end ;
74948: GO 74587
74950: POP
74951: POP
// end ;
74952: GO 73889
74954: POP
74955: POP
// result := result ^ buildings ;
74956: LD_ADDR_VAR 0 7
74960: PUSH
74961: LD_VAR 0 7
74965: PUSH
74966: LD_VAR 0 18
74970: ADD
74971: ST_TO_ADDR
// end else
74972: GO 75115
// begin for i = 1 to personel do
74974: LD_ADDR_VAR 0 8
74978: PUSH
74979: DOUBLE
74980: LD_INT 1
74982: DEC
74983: ST_TO_ADDR
74984: LD_VAR 0 6
74988: PUSH
74989: FOR_TO
74990: IFFALSE 75113
// begin if i > 4 then
74992: LD_VAR 0 8
74996: PUSH
74997: LD_INT 4
74999: GREATER
75000: IFFALSE 75004
// break ;
75002: GO 75113
// x := personel [ i ] ;
75004: LD_ADDR_VAR 0 13
75008: PUSH
75009: LD_VAR 0 6
75013: PUSH
75014: LD_VAR 0 8
75018: ARRAY
75019: ST_TO_ADDR
// if x = - 1 then
75020: LD_VAR 0 13
75024: PUSH
75025: LD_INT 1
75027: NEG
75028: EQUAL
75029: IFFALSE 75033
// continue ;
75031: GO 74989
// PrepareHuman ( false , i , skill ) ;
75033: LD_INT 0
75035: PPUSH
75036: LD_VAR 0 8
75040: PPUSH
75041: LD_VAR 0 4
75045: PPUSH
75046: CALL_OW 380
// un := CreateHuman ;
75050: LD_ADDR_VAR 0 14
75054: PUSH
75055: CALL_OW 44
75059: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75060: LD_VAR 0 14
75064: PPUSH
75065: LD_VAR 0 1
75069: PPUSH
75070: CALL_OW 250
75074: PPUSH
75075: LD_VAR 0 1
75079: PPUSH
75080: CALL_OW 251
75084: PPUSH
75085: LD_INT 10
75087: PPUSH
75088: LD_INT 0
75090: PPUSH
75091: CALL_OW 50
// result := result ^ un ;
75095: LD_ADDR_VAR 0 7
75099: PUSH
75100: LD_VAR 0 7
75104: PUSH
75105: LD_VAR 0 14
75109: ADD
75110: ST_TO_ADDR
// end ;
75111: GO 74989
75113: POP
75114: POP
// end ; end ;
75115: LD_VAR 0 7
75119: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75120: LD_INT 0
75122: PPUSH
75123: PPUSH
75124: PPUSH
75125: PPUSH
75126: PPUSH
75127: PPUSH
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
75136: PPUSH
75137: PPUSH
// result := false ;
75138: LD_ADDR_VAR 0 3
75142: PUSH
75143: LD_INT 0
75145: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75146: LD_VAR 0 1
75150: NOT
75151: PUSH
75152: LD_VAR 0 1
75156: PPUSH
75157: CALL_OW 266
75161: PUSH
75162: LD_INT 32
75164: PUSH
75165: LD_INT 33
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: IN
75172: NOT
75173: OR
75174: IFFALSE 75178
// exit ;
75176: GO 76314
// nat := GetNation ( tower ) ;
75178: LD_ADDR_VAR 0 12
75182: PUSH
75183: LD_VAR 0 1
75187: PPUSH
75188: CALL_OW 248
75192: ST_TO_ADDR
// side := GetSide ( tower ) ;
75193: LD_ADDR_VAR 0 16
75197: PUSH
75198: LD_VAR 0 1
75202: PPUSH
75203: CALL_OW 255
75207: ST_TO_ADDR
// x := GetX ( tower ) ;
75208: LD_ADDR_VAR 0 10
75212: PUSH
75213: LD_VAR 0 1
75217: PPUSH
75218: CALL_OW 250
75222: ST_TO_ADDR
// y := GetY ( tower ) ;
75223: LD_ADDR_VAR 0 11
75227: PUSH
75228: LD_VAR 0 1
75232: PPUSH
75233: CALL_OW 251
75237: ST_TO_ADDR
// if not x or not y then
75238: LD_VAR 0 10
75242: NOT
75243: PUSH
75244: LD_VAR 0 11
75248: NOT
75249: OR
75250: IFFALSE 75254
// exit ;
75252: GO 76314
// weapon := 0 ;
75254: LD_ADDR_VAR 0 18
75258: PUSH
75259: LD_INT 0
75261: ST_TO_ADDR
// fac_list := [ ] ;
75262: LD_ADDR_VAR 0 17
75266: PUSH
75267: EMPTY
75268: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75269: LD_ADDR_VAR 0 6
75273: PUSH
75274: LD_VAR 0 1
75278: PPUSH
75279: CALL_OW 274
75283: PPUSH
75284: LD_VAR 0 2
75288: PPUSH
75289: CALL 72892 0 2
75293: PPUSH
75294: LD_INT 30
75296: PUSH
75297: LD_INT 3
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PPUSH
75304: CALL_OW 72
75308: ST_TO_ADDR
// if not factories then
75309: LD_VAR 0 6
75313: NOT
75314: IFFALSE 75318
// exit ;
75316: GO 76314
// for i in factories do
75318: LD_ADDR_VAR 0 8
75322: PUSH
75323: LD_VAR 0 6
75327: PUSH
75328: FOR_IN
75329: IFFALSE 75354
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75331: LD_ADDR_VAR 0 17
75335: PUSH
75336: LD_VAR 0 17
75340: PUSH
75341: LD_VAR 0 8
75345: PPUSH
75346: CALL_OW 478
75350: UNION
75351: ST_TO_ADDR
75352: GO 75328
75354: POP
75355: POP
// if not fac_list then
75356: LD_VAR 0 17
75360: NOT
75361: IFFALSE 75365
// exit ;
75363: GO 76314
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75365: LD_ADDR_VAR 0 5
75369: PUSH
75370: LD_INT 4
75372: PUSH
75373: LD_INT 5
75375: PUSH
75376: LD_INT 9
75378: PUSH
75379: LD_INT 10
75381: PUSH
75382: LD_INT 6
75384: PUSH
75385: LD_INT 7
75387: PUSH
75388: LD_INT 11
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 27
75402: PUSH
75403: LD_INT 28
75405: PUSH
75406: LD_INT 26
75408: PUSH
75409: LD_INT 30
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 43
75420: PUSH
75421: LD_INT 44
75423: PUSH
75424: LD_INT 46
75426: PUSH
75427: LD_INT 45
75429: PUSH
75430: LD_INT 47
75432: PUSH
75433: LD_INT 49
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: LIST
75448: PUSH
75449: LD_VAR 0 12
75453: ARRAY
75454: ST_TO_ADDR
// for i in list do
75455: LD_ADDR_VAR 0 8
75459: PUSH
75460: LD_VAR 0 5
75464: PUSH
75465: FOR_IN
75466: IFFALSE 75499
// if not i in fac_list then
75468: LD_VAR 0 8
75472: PUSH
75473: LD_VAR 0 17
75477: IN
75478: NOT
75479: IFFALSE 75497
// list := list diff i ;
75481: LD_ADDR_VAR 0 5
75485: PUSH
75486: LD_VAR 0 5
75490: PUSH
75491: LD_VAR 0 8
75495: DIFF
75496: ST_TO_ADDR
75497: GO 75465
75499: POP
75500: POP
// if not list then
75501: LD_VAR 0 5
75505: NOT
75506: IFFALSE 75510
// exit ;
75508: GO 76314
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75510: LD_VAR 0 12
75514: PUSH
75515: LD_INT 3
75517: EQUAL
75518: PUSH
75519: LD_INT 49
75521: PUSH
75522: LD_VAR 0 5
75526: IN
75527: AND
75528: PUSH
75529: LD_INT 31
75531: PPUSH
75532: LD_VAR 0 16
75536: PPUSH
75537: CALL_OW 321
75541: PUSH
75542: LD_INT 2
75544: EQUAL
75545: AND
75546: IFFALSE 75606
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75548: LD_INT 22
75550: PUSH
75551: LD_VAR 0 16
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 35
75562: PUSH
75563: LD_INT 49
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 91
75572: PUSH
75573: LD_VAR 0 1
75577: PUSH
75578: LD_INT 10
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: LIST
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: LIST
75590: PPUSH
75591: CALL_OW 69
75595: NOT
75596: IFFALSE 75606
// weapon := ru_time_lapser ;
75598: LD_ADDR_VAR 0 18
75602: PUSH
75603: LD_INT 49
75605: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75606: LD_VAR 0 12
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: LD_INT 2
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: IN
75621: PUSH
75622: LD_INT 11
75624: PUSH
75625: LD_VAR 0 5
75629: IN
75630: PUSH
75631: LD_INT 30
75633: PUSH
75634: LD_VAR 0 5
75638: IN
75639: OR
75640: AND
75641: PUSH
75642: LD_INT 6
75644: PPUSH
75645: LD_VAR 0 16
75649: PPUSH
75650: CALL_OW 321
75654: PUSH
75655: LD_INT 2
75657: EQUAL
75658: AND
75659: IFFALSE 75824
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75661: LD_INT 22
75663: PUSH
75664: LD_VAR 0 16
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: LD_INT 35
75678: PUSH
75679: LD_INT 11
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 35
75688: PUSH
75689: LD_INT 30
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 91
75703: PUSH
75704: LD_VAR 0 1
75708: PUSH
75709: LD_INT 18
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: LIST
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: LIST
75721: PPUSH
75722: CALL_OW 69
75726: NOT
75727: PUSH
75728: LD_INT 22
75730: PUSH
75731: LD_VAR 0 16
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 2
75742: PUSH
75743: LD_INT 30
75745: PUSH
75746: LD_INT 32
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 30
75755: PUSH
75756: LD_INT 33
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 91
75770: PUSH
75771: LD_VAR 0 1
75775: PUSH
75776: LD_INT 12
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: LIST
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: LIST
75788: PUSH
75789: EMPTY
75790: LIST
75791: PPUSH
75792: CALL_OW 69
75796: PUSH
75797: LD_INT 2
75799: GREATER
75800: AND
75801: IFFALSE 75824
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75803: LD_ADDR_VAR 0 18
75807: PUSH
75808: LD_INT 11
75810: PUSH
75811: LD_INT 30
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_VAR 0 12
75822: ARRAY
75823: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75824: LD_VAR 0 18
75828: NOT
75829: PUSH
75830: LD_INT 40
75832: PPUSH
75833: LD_VAR 0 16
75837: PPUSH
75838: CALL_OW 321
75842: PUSH
75843: LD_INT 2
75845: EQUAL
75846: AND
75847: PUSH
75848: LD_INT 7
75850: PUSH
75851: LD_VAR 0 5
75855: IN
75856: PUSH
75857: LD_INT 28
75859: PUSH
75860: LD_VAR 0 5
75864: IN
75865: OR
75866: PUSH
75867: LD_INT 45
75869: PUSH
75870: LD_VAR 0 5
75874: IN
75875: OR
75876: AND
75877: IFFALSE 76131
// begin hex := GetHexInfo ( x , y ) ;
75879: LD_ADDR_VAR 0 4
75883: PUSH
75884: LD_VAR 0 10
75888: PPUSH
75889: LD_VAR 0 11
75893: PPUSH
75894: CALL_OW 546
75898: ST_TO_ADDR
// if hex [ 1 ] then
75899: LD_VAR 0 4
75903: PUSH
75904: LD_INT 1
75906: ARRAY
75907: IFFALSE 75911
// exit ;
75909: GO 76314
// height := hex [ 2 ] ;
75911: LD_ADDR_VAR 0 15
75915: PUSH
75916: LD_VAR 0 4
75920: PUSH
75921: LD_INT 2
75923: ARRAY
75924: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75925: LD_ADDR_VAR 0 14
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: LD_INT 2
75935: PUSH
75936: LD_INT 3
75938: PUSH
75939: LD_INT 5
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: ST_TO_ADDR
// for i in tmp do
75948: LD_ADDR_VAR 0 8
75952: PUSH
75953: LD_VAR 0 14
75957: PUSH
75958: FOR_IN
75959: IFFALSE 76129
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75961: LD_ADDR_VAR 0 9
75965: PUSH
75966: LD_VAR 0 10
75970: PPUSH
75971: LD_VAR 0 8
75975: PPUSH
75976: LD_INT 5
75978: PPUSH
75979: CALL_OW 272
75983: PUSH
75984: LD_VAR 0 11
75988: PPUSH
75989: LD_VAR 0 8
75993: PPUSH
75994: LD_INT 5
75996: PPUSH
75997: CALL_OW 273
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76006: LD_VAR 0 9
76010: PUSH
76011: LD_INT 1
76013: ARRAY
76014: PPUSH
76015: LD_VAR 0 9
76019: PUSH
76020: LD_INT 2
76022: ARRAY
76023: PPUSH
76024: CALL_OW 488
76028: IFFALSE 76127
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76030: LD_ADDR_VAR 0 4
76034: PUSH
76035: LD_VAR 0 9
76039: PUSH
76040: LD_INT 1
76042: ARRAY
76043: PPUSH
76044: LD_VAR 0 9
76048: PUSH
76049: LD_INT 2
76051: ARRAY
76052: PPUSH
76053: CALL_OW 546
76057: ST_TO_ADDR
// if hex [ 1 ] then
76058: LD_VAR 0 4
76062: PUSH
76063: LD_INT 1
76065: ARRAY
76066: IFFALSE 76070
// continue ;
76068: GO 75958
// h := hex [ 2 ] ;
76070: LD_ADDR_VAR 0 13
76074: PUSH
76075: LD_VAR 0 4
76079: PUSH
76080: LD_INT 2
76082: ARRAY
76083: ST_TO_ADDR
// if h + 7 < height then
76084: LD_VAR 0 13
76088: PUSH
76089: LD_INT 7
76091: PLUS
76092: PUSH
76093: LD_VAR 0 15
76097: LESS
76098: IFFALSE 76127
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76100: LD_ADDR_VAR 0 18
76104: PUSH
76105: LD_INT 7
76107: PUSH
76108: LD_INT 28
76110: PUSH
76111: LD_INT 45
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: LIST
76118: PUSH
76119: LD_VAR 0 12
76123: ARRAY
76124: ST_TO_ADDR
// break ;
76125: GO 76129
// end ; end ; end ;
76127: GO 75958
76129: POP
76130: POP
// end ; if not weapon then
76131: LD_VAR 0 18
76135: NOT
76136: IFFALSE 76196
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76138: LD_ADDR_VAR 0 5
76142: PUSH
76143: LD_VAR 0 5
76147: PUSH
76148: LD_INT 11
76150: PUSH
76151: LD_INT 30
76153: PUSH
76154: LD_INT 49
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: LIST
76161: DIFF
76162: ST_TO_ADDR
// if not list then
76163: LD_VAR 0 5
76167: NOT
76168: IFFALSE 76172
// exit ;
76170: GO 76314
// weapon := list [ rand ( 1 , list ) ] ;
76172: LD_ADDR_VAR 0 18
76176: PUSH
76177: LD_VAR 0 5
76181: PUSH
76182: LD_INT 1
76184: PPUSH
76185: LD_VAR 0 5
76189: PPUSH
76190: CALL_OW 12
76194: ARRAY
76195: ST_TO_ADDR
// end ; if weapon then
76196: LD_VAR 0 18
76200: IFFALSE 76314
// begin tmp := CostOfWeapon ( weapon ) ;
76202: LD_ADDR_VAR 0 14
76206: PUSH
76207: LD_VAR 0 18
76211: PPUSH
76212: CALL_OW 451
76216: ST_TO_ADDR
// j := GetBase ( tower ) ;
76217: LD_ADDR_VAR 0 9
76221: PUSH
76222: LD_VAR 0 1
76226: PPUSH
76227: CALL_OW 274
76231: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76232: LD_VAR 0 9
76236: PPUSH
76237: LD_INT 1
76239: PPUSH
76240: CALL_OW 275
76244: PUSH
76245: LD_VAR 0 14
76249: PUSH
76250: LD_INT 1
76252: ARRAY
76253: GREATEREQUAL
76254: PUSH
76255: LD_VAR 0 9
76259: PPUSH
76260: LD_INT 2
76262: PPUSH
76263: CALL_OW 275
76267: PUSH
76268: LD_VAR 0 14
76272: PUSH
76273: LD_INT 2
76275: ARRAY
76276: GREATEREQUAL
76277: AND
76278: PUSH
76279: LD_VAR 0 9
76283: PPUSH
76284: LD_INT 3
76286: PPUSH
76287: CALL_OW 275
76291: PUSH
76292: LD_VAR 0 14
76296: PUSH
76297: LD_INT 3
76299: ARRAY
76300: GREATEREQUAL
76301: AND
76302: IFFALSE 76314
// result := weapon ;
76304: LD_ADDR_VAR 0 3
76308: PUSH
76309: LD_VAR 0 18
76313: ST_TO_ADDR
// end ; end ;
76314: LD_VAR 0 3
76318: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76319: LD_INT 0
76321: PPUSH
76322: PPUSH
// result := true ;
76323: LD_ADDR_VAR 0 3
76327: PUSH
76328: LD_INT 1
76330: ST_TO_ADDR
// if array1 = array2 then
76331: LD_VAR 0 1
76335: PUSH
76336: LD_VAR 0 2
76340: EQUAL
76341: IFFALSE 76401
// begin for i = 1 to array1 do
76343: LD_ADDR_VAR 0 4
76347: PUSH
76348: DOUBLE
76349: LD_INT 1
76351: DEC
76352: ST_TO_ADDR
76353: LD_VAR 0 1
76357: PUSH
76358: FOR_TO
76359: IFFALSE 76397
// if array1 [ i ] <> array2 [ i ] then
76361: LD_VAR 0 1
76365: PUSH
76366: LD_VAR 0 4
76370: ARRAY
76371: PUSH
76372: LD_VAR 0 2
76376: PUSH
76377: LD_VAR 0 4
76381: ARRAY
76382: NONEQUAL
76383: IFFALSE 76395
// begin result := false ;
76385: LD_ADDR_VAR 0 3
76389: PUSH
76390: LD_INT 0
76392: ST_TO_ADDR
// break ;
76393: GO 76397
// end ;
76395: GO 76358
76397: POP
76398: POP
// end else
76399: GO 76409
// result := false ;
76401: LD_ADDR_VAR 0 3
76405: PUSH
76406: LD_INT 0
76408: ST_TO_ADDR
// end ;
76409: LD_VAR 0 3
76413: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76414: LD_INT 0
76416: PPUSH
76417: PPUSH
76418: PPUSH
// pom := GetBase ( fac ) ;
76419: LD_ADDR_VAR 0 5
76423: PUSH
76424: LD_VAR 0 1
76428: PPUSH
76429: CALL_OW 274
76433: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76434: LD_ADDR_VAR 0 4
76438: PUSH
76439: LD_VAR 0 2
76443: PUSH
76444: LD_INT 1
76446: ARRAY
76447: PPUSH
76448: LD_VAR 0 2
76452: PUSH
76453: LD_INT 2
76455: ARRAY
76456: PPUSH
76457: LD_VAR 0 2
76461: PUSH
76462: LD_INT 3
76464: ARRAY
76465: PPUSH
76466: LD_VAR 0 2
76470: PUSH
76471: LD_INT 4
76473: ARRAY
76474: PPUSH
76475: CALL_OW 449
76479: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76480: LD_ADDR_VAR 0 3
76484: PUSH
76485: LD_VAR 0 5
76489: PPUSH
76490: LD_INT 1
76492: PPUSH
76493: CALL_OW 275
76497: PUSH
76498: LD_VAR 0 4
76502: PUSH
76503: LD_INT 1
76505: ARRAY
76506: GREATEREQUAL
76507: PUSH
76508: LD_VAR 0 5
76512: PPUSH
76513: LD_INT 2
76515: PPUSH
76516: CALL_OW 275
76520: PUSH
76521: LD_VAR 0 4
76525: PUSH
76526: LD_INT 2
76528: ARRAY
76529: GREATEREQUAL
76530: AND
76531: PUSH
76532: LD_VAR 0 5
76536: PPUSH
76537: LD_INT 3
76539: PPUSH
76540: CALL_OW 275
76544: PUSH
76545: LD_VAR 0 4
76549: PUSH
76550: LD_INT 3
76552: ARRAY
76553: GREATEREQUAL
76554: AND
76555: ST_TO_ADDR
// end ;
76556: LD_VAR 0 3
76560: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76561: LD_INT 0
76563: PPUSH
76564: PPUSH
76565: PPUSH
76566: PPUSH
// pom := GetBase ( building ) ;
76567: LD_ADDR_VAR 0 3
76571: PUSH
76572: LD_VAR 0 1
76576: PPUSH
76577: CALL_OW 274
76581: ST_TO_ADDR
// if not pom then
76582: LD_VAR 0 3
76586: NOT
76587: IFFALSE 76591
// exit ;
76589: GO 76761
// btype := GetBType ( building ) ;
76591: LD_ADDR_VAR 0 5
76595: PUSH
76596: LD_VAR 0 1
76600: PPUSH
76601: CALL_OW 266
76605: ST_TO_ADDR
// if btype = b_armoury then
76606: LD_VAR 0 5
76610: PUSH
76611: LD_INT 4
76613: EQUAL
76614: IFFALSE 76624
// btype := b_barracks ;
76616: LD_ADDR_VAR 0 5
76620: PUSH
76621: LD_INT 5
76623: ST_TO_ADDR
// if btype = b_depot then
76624: LD_VAR 0 5
76628: PUSH
76629: LD_INT 0
76631: EQUAL
76632: IFFALSE 76642
// btype := b_warehouse ;
76634: LD_ADDR_VAR 0 5
76638: PUSH
76639: LD_INT 1
76641: ST_TO_ADDR
// if btype = b_workshop then
76642: LD_VAR 0 5
76646: PUSH
76647: LD_INT 2
76649: EQUAL
76650: IFFALSE 76660
// btype := b_factory ;
76652: LD_ADDR_VAR 0 5
76656: PUSH
76657: LD_INT 3
76659: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76660: LD_ADDR_VAR 0 4
76664: PUSH
76665: LD_VAR 0 5
76669: PPUSH
76670: LD_VAR 0 1
76674: PPUSH
76675: CALL_OW 248
76679: PPUSH
76680: CALL_OW 450
76684: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76685: LD_ADDR_VAR 0 2
76689: PUSH
76690: LD_VAR 0 3
76694: PPUSH
76695: LD_INT 1
76697: PPUSH
76698: CALL_OW 275
76702: PUSH
76703: LD_VAR 0 4
76707: PUSH
76708: LD_INT 1
76710: ARRAY
76711: GREATEREQUAL
76712: PUSH
76713: LD_VAR 0 3
76717: PPUSH
76718: LD_INT 2
76720: PPUSH
76721: CALL_OW 275
76725: PUSH
76726: LD_VAR 0 4
76730: PUSH
76731: LD_INT 2
76733: ARRAY
76734: GREATEREQUAL
76735: AND
76736: PUSH
76737: LD_VAR 0 3
76741: PPUSH
76742: LD_INT 3
76744: PPUSH
76745: CALL_OW 275
76749: PUSH
76750: LD_VAR 0 4
76754: PUSH
76755: LD_INT 3
76757: ARRAY
76758: GREATEREQUAL
76759: AND
76760: ST_TO_ADDR
// end ;
76761: LD_VAR 0 2
76765: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76766: LD_INT 0
76768: PPUSH
76769: PPUSH
76770: PPUSH
// pom := GetBase ( building ) ;
76771: LD_ADDR_VAR 0 4
76775: PUSH
76776: LD_VAR 0 1
76780: PPUSH
76781: CALL_OW 274
76785: ST_TO_ADDR
// if not pom then
76786: LD_VAR 0 4
76790: NOT
76791: IFFALSE 76795
// exit ;
76793: GO 76896
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76795: LD_ADDR_VAR 0 5
76799: PUSH
76800: LD_VAR 0 2
76804: PPUSH
76805: LD_VAR 0 1
76809: PPUSH
76810: CALL_OW 248
76814: PPUSH
76815: CALL_OW 450
76819: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76820: LD_ADDR_VAR 0 3
76824: PUSH
76825: LD_VAR 0 4
76829: PPUSH
76830: LD_INT 1
76832: PPUSH
76833: CALL_OW 275
76837: PUSH
76838: LD_VAR 0 5
76842: PUSH
76843: LD_INT 1
76845: ARRAY
76846: GREATEREQUAL
76847: PUSH
76848: LD_VAR 0 4
76852: PPUSH
76853: LD_INT 2
76855: PPUSH
76856: CALL_OW 275
76860: PUSH
76861: LD_VAR 0 5
76865: PUSH
76866: LD_INT 2
76868: ARRAY
76869: GREATEREQUAL
76870: AND
76871: PUSH
76872: LD_VAR 0 4
76876: PPUSH
76877: LD_INT 3
76879: PPUSH
76880: CALL_OW 275
76884: PUSH
76885: LD_VAR 0 5
76889: PUSH
76890: LD_INT 3
76892: ARRAY
76893: GREATEREQUAL
76894: AND
76895: ST_TO_ADDR
// end ;
76896: LD_VAR 0 3
76900: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76901: LD_INT 0
76903: PPUSH
76904: PPUSH
76905: PPUSH
76906: PPUSH
76907: PPUSH
76908: PPUSH
76909: PPUSH
76910: PPUSH
76911: PPUSH
76912: PPUSH
// result := false ;
76913: LD_ADDR_VAR 0 6
76917: PUSH
76918: LD_INT 0
76920: ST_TO_ADDR
// if not base or not btype or not x or not y then
76921: LD_VAR 0 1
76925: NOT
76926: PUSH
76927: LD_VAR 0 2
76931: NOT
76932: OR
76933: PUSH
76934: LD_VAR 0 3
76938: NOT
76939: OR
76940: PUSH
76941: LD_VAR 0 4
76945: NOT
76946: OR
76947: IFFALSE 76951
// exit ;
76949: GO 77560
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76951: LD_ADDR_VAR 0 12
76955: PUSH
76956: LD_VAR 0 2
76960: PPUSH
76961: LD_VAR 0 3
76965: PPUSH
76966: LD_VAR 0 4
76970: PPUSH
76971: LD_VAR 0 5
76975: PPUSH
76976: LD_VAR 0 1
76980: PUSH
76981: LD_INT 1
76983: ARRAY
76984: PPUSH
76985: CALL_OW 248
76989: PPUSH
76990: LD_INT 0
76992: PPUSH
76993: CALL 78397 0 6
76997: ST_TO_ADDR
// if not hexes then
76998: LD_VAR 0 12
77002: NOT
77003: IFFALSE 77007
// exit ;
77005: GO 77560
// for i = 1 to hexes do
77007: LD_ADDR_VAR 0 7
77011: PUSH
77012: DOUBLE
77013: LD_INT 1
77015: DEC
77016: ST_TO_ADDR
77017: LD_VAR 0 12
77021: PUSH
77022: FOR_TO
77023: IFFALSE 77558
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77025: LD_ADDR_VAR 0 11
77029: PUSH
77030: LD_VAR 0 12
77034: PUSH
77035: LD_VAR 0 7
77039: ARRAY
77040: PUSH
77041: LD_INT 1
77043: ARRAY
77044: PPUSH
77045: LD_VAR 0 12
77049: PUSH
77050: LD_VAR 0 7
77054: ARRAY
77055: PUSH
77056: LD_INT 2
77058: ARRAY
77059: PPUSH
77060: CALL_OW 428
77064: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77065: LD_VAR 0 12
77069: PUSH
77070: LD_VAR 0 7
77074: ARRAY
77075: PUSH
77076: LD_INT 1
77078: ARRAY
77079: PPUSH
77080: LD_VAR 0 12
77084: PUSH
77085: LD_VAR 0 7
77089: ARRAY
77090: PUSH
77091: LD_INT 2
77093: ARRAY
77094: PPUSH
77095: CALL_OW 351
77099: PUSH
77100: LD_VAR 0 12
77104: PUSH
77105: LD_VAR 0 7
77109: ARRAY
77110: PUSH
77111: LD_INT 1
77113: ARRAY
77114: PPUSH
77115: LD_VAR 0 12
77119: PUSH
77120: LD_VAR 0 7
77124: ARRAY
77125: PUSH
77126: LD_INT 2
77128: ARRAY
77129: PPUSH
77130: CALL_OW 488
77134: NOT
77135: OR
77136: PUSH
77137: LD_VAR 0 11
77141: PPUSH
77142: CALL_OW 247
77146: PUSH
77147: LD_INT 3
77149: EQUAL
77150: OR
77151: IFFALSE 77157
// exit ;
77153: POP
77154: POP
77155: GO 77560
// if not tmp or not tmp in base then
77157: LD_VAR 0 11
77161: NOT
77162: PUSH
77163: LD_VAR 0 11
77167: PUSH
77168: LD_VAR 0 1
77172: IN
77173: NOT
77174: OR
77175: IFFALSE 77179
// continue ;
77177: GO 77022
// result := true ;
77179: LD_ADDR_VAR 0 6
77183: PUSH
77184: LD_INT 1
77186: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77187: LD_ADDR_VAR 0 15
77191: PUSH
77192: LD_VAR 0 1
77196: PPUSH
77197: LD_INT 22
77199: PUSH
77200: LD_VAR 0 11
77204: PPUSH
77205: CALL_OW 255
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 2
77216: PUSH
77217: LD_INT 30
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 30
77229: PUSH
77230: LD_INT 1
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: LIST
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PPUSH
77246: CALL_OW 72
77250: ST_TO_ADDR
// if dep then
77251: LD_VAR 0 15
77255: IFFALSE 77391
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77257: LD_ADDR_VAR 0 14
77261: PUSH
77262: LD_VAR 0 15
77266: PUSH
77267: LD_INT 1
77269: ARRAY
77270: PPUSH
77271: CALL_OW 250
77275: PPUSH
77276: LD_VAR 0 15
77280: PUSH
77281: LD_INT 1
77283: ARRAY
77284: PPUSH
77285: CALL_OW 254
77289: PPUSH
77290: LD_INT 5
77292: PPUSH
77293: CALL_OW 272
77297: PUSH
77298: LD_VAR 0 15
77302: PUSH
77303: LD_INT 1
77305: ARRAY
77306: PPUSH
77307: CALL_OW 251
77311: PPUSH
77312: LD_VAR 0 15
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PPUSH
77321: CALL_OW 254
77325: PPUSH
77326: LD_INT 5
77328: PPUSH
77329: CALL_OW 273
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77338: LD_VAR 0 14
77342: PUSH
77343: LD_INT 1
77345: ARRAY
77346: PPUSH
77347: LD_VAR 0 14
77351: PUSH
77352: LD_INT 2
77354: ARRAY
77355: PPUSH
77356: CALL_OW 488
77360: IFFALSE 77391
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77362: LD_VAR 0 11
77366: PPUSH
77367: LD_VAR 0 14
77371: PUSH
77372: LD_INT 1
77374: ARRAY
77375: PPUSH
77376: LD_VAR 0 14
77380: PUSH
77381: LD_INT 2
77383: ARRAY
77384: PPUSH
77385: CALL_OW 111
// continue ;
77389: GO 77022
// end ; end ; r := GetDir ( tmp ) ;
77391: LD_ADDR_VAR 0 13
77395: PUSH
77396: LD_VAR 0 11
77400: PPUSH
77401: CALL_OW 254
77405: ST_TO_ADDR
// if r = 5 then
77406: LD_VAR 0 13
77410: PUSH
77411: LD_INT 5
77413: EQUAL
77414: IFFALSE 77424
// r := 0 ;
77416: LD_ADDR_VAR 0 13
77420: PUSH
77421: LD_INT 0
77423: ST_TO_ADDR
// for j = r to 5 do
77424: LD_ADDR_VAR 0 8
77428: PUSH
77429: DOUBLE
77430: LD_VAR 0 13
77434: DEC
77435: ST_TO_ADDR
77436: LD_INT 5
77438: PUSH
77439: FOR_TO
77440: IFFALSE 77554
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77442: LD_ADDR_VAR 0 9
77446: PUSH
77447: LD_VAR 0 11
77451: PPUSH
77452: CALL_OW 250
77456: PPUSH
77457: LD_VAR 0 8
77461: PPUSH
77462: LD_INT 2
77464: PPUSH
77465: CALL_OW 272
77469: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77470: LD_ADDR_VAR 0 10
77474: PUSH
77475: LD_VAR 0 11
77479: PPUSH
77480: CALL_OW 251
77484: PPUSH
77485: LD_VAR 0 8
77489: PPUSH
77490: LD_INT 2
77492: PPUSH
77493: CALL_OW 273
77497: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77498: LD_VAR 0 9
77502: PPUSH
77503: LD_VAR 0 10
77507: PPUSH
77508: CALL_OW 488
77512: PUSH
77513: LD_VAR 0 9
77517: PPUSH
77518: LD_VAR 0 10
77522: PPUSH
77523: CALL_OW 428
77527: NOT
77528: AND
77529: IFFALSE 77552
// begin ComMoveXY ( tmp , _x , _y ) ;
77531: LD_VAR 0 11
77535: PPUSH
77536: LD_VAR 0 9
77540: PPUSH
77541: LD_VAR 0 10
77545: PPUSH
77546: CALL_OW 111
// break ;
77550: GO 77554
// end ; end ;
77552: GO 77439
77554: POP
77555: POP
// end ;
77556: GO 77022
77558: POP
77559: POP
// end ;
77560: LD_VAR 0 6
77564: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77565: LD_INT 0
77567: PPUSH
77568: PPUSH
77569: PPUSH
77570: PPUSH
77571: PPUSH
77572: PPUSH
77573: PPUSH
77574: PPUSH
77575: PPUSH
77576: PPUSH
// result := false ;
77577: LD_ADDR_VAR 0 6
77581: PUSH
77582: LD_INT 0
77584: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77585: LD_VAR 0 1
77589: NOT
77590: PUSH
77591: LD_VAR 0 1
77595: PPUSH
77596: CALL_OW 266
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: IN
77611: NOT
77612: OR
77613: PUSH
77614: LD_VAR 0 2
77618: NOT
77619: OR
77620: PUSH
77621: LD_VAR 0 5
77625: PUSH
77626: LD_INT 0
77628: PUSH
77629: LD_INT 1
77631: PUSH
77632: LD_INT 2
77634: PUSH
77635: LD_INT 3
77637: PUSH
77638: LD_INT 4
77640: PUSH
77641: LD_INT 5
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: IN
77652: NOT
77653: OR
77654: PUSH
77655: LD_VAR 0 3
77659: PPUSH
77660: LD_VAR 0 4
77664: PPUSH
77665: CALL_OW 488
77669: NOT
77670: OR
77671: IFFALSE 77675
// exit ;
77673: GO 78392
// pom := GetBase ( depot ) ;
77675: LD_ADDR_VAR 0 10
77679: PUSH
77680: LD_VAR 0 1
77684: PPUSH
77685: CALL_OW 274
77689: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77690: LD_ADDR_VAR 0 11
77694: PUSH
77695: LD_VAR 0 2
77699: PPUSH
77700: LD_VAR 0 1
77704: PPUSH
77705: CALL_OW 248
77709: PPUSH
77710: CALL_OW 450
77714: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77715: LD_VAR 0 10
77719: PPUSH
77720: LD_INT 1
77722: PPUSH
77723: CALL_OW 275
77727: PUSH
77728: LD_VAR 0 11
77732: PUSH
77733: LD_INT 1
77735: ARRAY
77736: GREATEREQUAL
77737: PUSH
77738: LD_VAR 0 10
77742: PPUSH
77743: LD_INT 2
77745: PPUSH
77746: CALL_OW 275
77750: PUSH
77751: LD_VAR 0 11
77755: PUSH
77756: LD_INT 2
77758: ARRAY
77759: GREATEREQUAL
77760: AND
77761: PUSH
77762: LD_VAR 0 10
77766: PPUSH
77767: LD_INT 3
77769: PPUSH
77770: CALL_OW 275
77774: PUSH
77775: LD_VAR 0 11
77779: PUSH
77780: LD_INT 3
77782: ARRAY
77783: GREATEREQUAL
77784: AND
77785: NOT
77786: IFFALSE 77790
// exit ;
77788: GO 78392
// if GetBType ( depot ) = b_depot then
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 266
77799: PUSH
77800: LD_INT 0
77802: EQUAL
77803: IFFALSE 77815
// dist := 28 else
77805: LD_ADDR_VAR 0 14
77809: PUSH
77810: LD_INT 28
77812: ST_TO_ADDR
77813: GO 77823
// dist := 36 ;
77815: LD_ADDR_VAR 0 14
77819: PUSH
77820: LD_INT 36
77822: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77823: LD_VAR 0 1
77827: PPUSH
77828: LD_VAR 0 3
77832: PPUSH
77833: LD_VAR 0 4
77837: PPUSH
77838: CALL_OW 297
77842: PUSH
77843: LD_VAR 0 14
77847: GREATER
77848: IFFALSE 77852
// exit ;
77850: GO 78392
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77852: LD_ADDR_VAR 0 12
77856: PUSH
77857: LD_VAR 0 2
77861: PPUSH
77862: LD_VAR 0 3
77866: PPUSH
77867: LD_VAR 0 4
77871: PPUSH
77872: LD_VAR 0 5
77876: PPUSH
77877: LD_VAR 0 1
77881: PPUSH
77882: CALL_OW 248
77886: PPUSH
77887: LD_INT 0
77889: PPUSH
77890: CALL 78397 0 6
77894: ST_TO_ADDR
// if not hexes then
77895: LD_VAR 0 12
77899: NOT
77900: IFFALSE 77904
// exit ;
77902: GO 78392
// hex := GetHexInfo ( x , y ) ;
77904: LD_ADDR_VAR 0 15
77908: PUSH
77909: LD_VAR 0 3
77913: PPUSH
77914: LD_VAR 0 4
77918: PPUSH
77919: CALL_OW 546
77923: ST_TO_ADDR
// if hex [ 1 ] then
77924: LD_VAR 0 15
77928: PUSH
77929: LD_INT 1
77931: ARRAY
77932: IFFALSE 77936
// exit ;
77934: GO 78392
// height := hex [ 2 ] ;
77936: LD_ADDR_VAR 0 13
77940: PUSH
77941: LD_VAR 0 15
77945: PUSH
77946: LD_INT 2
77948: ARRAY
77949: ST_TO_ADDR
// for i = 1 to hexes do
77950: LD_ADDR_VAR 0 7
77954: PUSH
77955: DOUBLE
77956: LD_INT 1
77958: DEC
77959: ST_TO_ADDR
77960: LD_VAR 0 12
77964: PUSH
77965: FOR_TO
77966: IFFALSE 78296
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77968: LD_VAR 0 12
77972: PUSH
77973: LD_VAR 0 7
77977: ARRAY
77978: PUSH
77979: LD_INT 1
77981: ARRAY
77982: PPUSH
77983: LD_VAR 0 12
77987: PUSH
77988: LD_VAR 0 7
77992: ARRAY
77993: PUSH
77994: LD_INT 2
77996: ARRAY
77997: PPUSH
77998: CALL_OW 488
78002: NOT
78003: PUSH
78004: LD_VAR 0 12
78008: PUSH
78009: LD_VAR 0 7
78013: ARRAY
78014: PUSH
78015: LD_INT 1
78017: ARRAY
78018: PPUSH
78019: LD_VAR 0 12
78023: PUSH
78024: LD_VAR 0 7
78028: ARRAY
78029: PUSH
78030: LD_INT 2
78032: ARRAY
78033: PPUSH
78034: CALL_OW 428
78038: PUSH
78039: LD_INT 0
78041: GREATER
78042: OR
78043: PUSH
78044: LD_VAR 0 12
78048: PUSH
78049: LD_VAR 0 7
78053: ARRAY
78054: PUSH
78055: LD_INT 1
78057: ARRAY
78058: PPUSH
78059: LD_VAR 0 12
78063: PUSH
78064: LD_VAR 0 7
78068: ARRAY
78069: PUSH
78070: LD_INT 2
78072: ARRAY
78073: PPUSH
78074: CALL_OW 351
78078: OR
78079: IFFALSE 78085
// exit ;
78081: POP
78082: POP
78083: GO 78392
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78085: LD_ADDR_VAR 0 8
78089: PUSH
78090: LD_VAR 0 12
78094: PUSH
78095: LD_VAR 0 7
78099: ARRAY
78100: PUSH
78101: LD_INT 1
78103: ARRAY
78104: PPUSH
78105: LD_VAR 0 12
78109: PUSH
78110: LD_VAR 0 7
78114: ARRAY
78115: PUSH
78116: LD_INT 2
78118: ARRAY
78119: PPUSH
78120: CALL_OW 546
78124: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78125: LD_VAR 0 8
78129: PUSH
78130: LD_INT 1
78132: ARRAY
78133: PUSH
78134: LD_VAR 0 8
78138: PUSH
78139: LD_INT 2
78141: ARRAY
78142: PUSH
78143: LD_VAR 0 13
78147: PUSH
78148: LD_INT 2
78150: PLUS
78151: GREATER
78152: OR
78153: PUSH
78154: LD_VAR 0 8
78158: PUSH
78159: LD_INT 2
78161: ARRAY
78162: PUSH
78163: LD_VAR 0 13
78167: PUSH
78168: LD_INT 2
78170: MINUS
78171: LESS
78172: OR
78173: PUSH
78174: LD_VAR 0 8
78178: PUSH
78179: LD_INT 3
78181: ARRAY
78182: PUSH
78183: LD_INT 0
78185: PUSH
78186: LD_INT 8
78188: PUSH
78189: LD_INT 9
78191: PUSH
78192: LD_INT 10
78194: PUSH
78195: LD_INT 11
78197: PUSH
78198: LD_INT 12
78200: PUSH
78201: LD_INT 13
78203: PUSH
78204: LD_INT 16
78206: PUSH
78207: LD_INT 17
78209: PUSH
78210: LD_INT 18
78212: PUSH
78213: LD_INT 19
78215: PUSH
78216: LD_INT 20
78218: PUSH
78219: LD_INT 21
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: IN
78237: NOT
78238: OR
78239: PUSH
78240: LD_VAR 0 8
78244: PUSH
78245: LD_INT 5
78247: ARRAY
78248: NOT
78249: OR
78250: PUSH
78251: LD_VAR 0 8
78255: PUSH
78256: LD_INT 6
78258: ARRAY
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: LD_INT 2
78265: PUSH
78266: LD_INT 7
78268: PUSH
78269: LD_INT 9
78271: PUSH
78272: LD_INT 10
78274: PUSH
78275: LD_INT 11
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: IN
78286: NOT
78287: OR
78288: IFFALSE 78294
// exit ;
78290: POP
78291: POP
78292: GO 78392
// end ;
78294: GO 77965
78296: POP
78297: POP
// side := GetSide ( depot ) ;
78298: LD_ADDR_VAR 0 9
78302: PUSH
78303: LD_VAR 0 1
78307: PPUSH
78308: CALL_OW 255
78312: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78313: LD_VAR 0 9
78317: PPUSH
78318: LD_VAR 0 3
78322: PPUSH
78323: LD_VAR 0 4
78327: PPUSH
78328: LD_INT 20
78330: PPUSH
78331: CALL 71046 0 4
78335: PUSH
78336: LD_INT 4
78338: ARRAY
78339: IFFALSE 78343
// exit ;
78341: GO 78392
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78343: LD_VAR 0 2
78347: PUSH
78348: LD_INT 29
78350: PUSH
78351: LD_INT 30
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: IN
78358: PUSH
78359: LD_VAR 0 3
78363: PPUSH
78364: LD_VAR 0 4
78368: PPUSH
78369: LD_VAR 0 9
78373: PPUSH
78374: CALL_OW 440
78378: NOT
78379: AND
78380: IFFALSE 78384
// exit ;
78382: GO 78392
// result := true ;
78384: LD_ADDR_VAR 0 6
78388: PUSH
78389: LD_INT 1
78391: ST_TO_ADDR
// end ;
78392: LD_VAR 0 6
78396: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78397: LD_INT 0
78399: PPUSH
78400: PPUSH
78401: PPUSH
78402: PPUSH
78403: PPUSH
78404: PPUSH
78405: PPUSH
78406: PPUSH
78407: PPUSH
78408: PPUSH
78409: PPUSH
78410: PPUSH
78411: PPUSH
78412: PPUSH
78413: PPUSH
78414: PPUSH
78415: PPUSH
78416: PPUSH
78417: PPUSH
78418: PPUSH
78419: PPUSH
78420: PPUSH
78421: PPUSH
78422: PPUSH
78423: PPUSH
78424: PPUSH
78425: PPUSH
78426: PPUSH
78427: PPUSH
78428: PPUSH
78429: PPUSH
78430: PPUSH
78431: PPUSH
78432: PPUSH
78433: PPUSH
78434: PPUSH
78435: PPUSH
78436: PPUSH
78437: PPUSH
78438: PPUSH
78439: PPUSH
78440: PPUSH
78441: PPUSH
78442: PPUSH
78443: PPUSH
78444: PPUSH
78445: PPUSH
78446: PPUSH
78447: PPUSH
78448: PPUSH
78449: PPUSH
78450: PPUSH
78451: PPUSH
78452: PPUSH
78453: PPUSH
78454: PPUSH
78455: PPUSH
78456: PPUSH
// result = [ ] ;
78457: LD_ADDR_VAR 0 7
78461: PUSH
78462: EMPTY
78463: ST_TO_ADDR
// temp_list = [ ] ;
78464: LD_ADDR_VAR 0 9
78468: PUSH
78469: EMPTY
78470: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78471: LD_VAR 0 4
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: LD_INT 2
78484: PUSH
78485: LD_INT 3
78487: PUSH
78488: LD_INT 4
78490: PUSH
78491: LD_INT 5
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: IN
78502: NOT
78503: PUSH
78504: LD_VAR 0 1
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: IN
78519: PUSH
78520: LD_VAR 0 5
78524: PUSH
78525: LD_INT 1
78527: PUSH
78528: LD_INT 2
78530: PUSH
78531: LD_INT 3
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: LIST
78538: IN
78539: NOT
78540: AND
78541: OR
78542: IFFALSE 78546
// exit ;
78544: GO 96937
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78546: LD_VAR 0 1
78550: PUSH
78551: LD_INT 6
78553: PUSH
78554: LD_INT 7
78556: PUSH
78557: LD_INT 8
78559: PUSH
78560: LD_INT 13
78562: PUSH
78563: LD_INT 12
78565: PUSH
78566: LD_INT 15
78568: PUSH
78569: LD_INT 11
78571: PUSH
78572: LD_INT 14
78574: PUSH
78575: LD_INT 10
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: IN
78589: IFFALSE 78599
// btype = b_lab ;
78591: LD_ADDR_VAR 0 1
78595: PUSH
78596: LD_INT 6
78598: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78599: LD_VAR 0 6
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: LD_INT 1
78609: PUSH
78610: LD_INT 2
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: LIST
78617: IN
78618: NOT
78619: PUSH
78620: LD_VAR 0 1
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: LD_INT 1
78630: PUSH
78631: LD_INT 2
78633: PUSH
78634: LD_INT 3
78636: PUSH
78637: LD_INT 6
78639: PUSH
78640: LD_INT 36
78642: PUSH
78643: LD_INT 4
78645: PUSH
78646: LD_INT 5
78648: PUSH
78649: LD_INT 31
78651: PUSH
78652: LD_INT 32
78654: PUSH
78655: LD_INT 33
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: IN
78671: NOT
78672: PUSH
78673: LD_VAR 0 6
78677: PUSH
78678: LD_INT 1
78680: EQUAL
78681: AND
78682: OR
78683: PUSH
78684: LD_VAR 0 1
78688: PUSH
78689: LD_INT 2
78691: PUSH
78692: LD_INT 3
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: IN
78699: NOT
78700: PUSH
78701: LD_VAR 0 6
78705: PUSH
78706: LD_INT 2
78708: EQUAL
78709: AND
78710: OR
78711: IFFALSE 78721
// mode = 0 ;
78713: LD_ADDR_VAR 0 6
78717: PUSH
78718: LD_INT 0
78720: ST_TO_ADDR
// case mode of 0 :
78721: LD_VAR 0 6
78725: PUSH
78726: LD_INT 0
78728: DOUBLE
78729: EQUAL
78730: IFTRUE 78734
78732: GO 90187
78734: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78735: LD_ADDR_VAR 0 11
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: LD_INT 0
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 1
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: LD_INT 1
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 1
78804: NEG
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 1
78816: NEG
78817: PUSH
78818: LD_INT 2
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 0
78828: PUSH
78829: LD_INT 2
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 1
78839: PUSH
78840: LD_INT 1
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 2
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: LD_INT 2
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 1
78870: NEG
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: LD_INT 3
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: LD_INT 3
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: LD_INT 2
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78928: LD_ADDR_VAR 0 12
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 0
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: LD_INT 1
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: LD_INT 0
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 1
78986: NEG
78987: PUSH
78988: LD_INT 0
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 1
78997: NEG
78998: PUSH
78999: LD_INT 1
79001: NEG
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: PUSH
79010: LD_INT 1
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 2
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 2
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: NEG
79041: PUSH
79042: LD_INT 1
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 2
79051: NEG
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: NEG
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 2
79074: NEG
79075: PUSH
79076: LD_INT 1
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 3
79085: NEG
79086: PUSH
79087: LD_INT 0
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 3
79096: NEG
79097: PUSH
79098: LD_INT 1
79100: NEG
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79124: LD_ADDR_VAR 0 13
79128: PUSH
79129: LD_INT 0
79131: PUSH
79132: LD_INT 0
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 1
79152: PUSH
79153: LD_INT 0
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 1
79162: PUSH
79163: LD_INT 1
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: LD_INT 0
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 1
79193: NEG
79194: PUSH
79195: LD_INT 1
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: NEG
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 2
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 2
79227: PUSH
79228: LD_INT 2
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 1
79237: PUSH
79238: LD_INT 2
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 2
79247: NEG
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: LD_INT 2
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 2
79271: NEG
79272: PUSH
79273: LD_INT 3
79275: NEG
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 3
79283: NEG
79284: PUSH
79285: LD_INT 2
79287: NEG
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 3
79295: NEG
79296: PUSH
79297: LD_INT 3
79299: NEG
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79323: LD_ADDR_VAR 0 14
79327: PUSH
79328: LD_INT 0
79330: PUSH
79331: LD_INT 0
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 0
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: PUSH
79352: LD_INT 0
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 1
79361: PUSH
79362: LD_INT 1
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 1
79381: NEG
79382: PUSH
79383: LD_INT 0
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 1
79392: NEG
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: LD_INT 2
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 1
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 1
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 0
79448: PUSH
79449: LD_INT 2
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 1
79458: NEG
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 1
79469: NEG
79470: PUSH
79471: LD_INT 3
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: LD_INT 3
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: PUSH
79493: LD_INT 2
79495: NEG
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79519: LD_ADDR_VAR 0 15
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 0
79536: PUSH
79537: LD_INT 1
79539: NEG
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 1
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: LD_INT 1
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 0
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 1
79577: NEG
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 1
79600: PUSH
79601: LD_INT 1
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: PUSH
79612: LD_INT 0
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 2
79621: PUSH
79622: LD_INT 1
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 2
79653: NEG
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 2
79665: PUSH
79666: LD_INT 1
79668: NEG
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 3
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 3
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79712: LD_ADDR_VAR 0 16
79716: PUSH
79717: LD_INT 0
79719: PUSH
79720: LD_INT 0
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: LD_INT 1
79732: NEG
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 1
79740: PUSH
79741: LD_INT 0
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 1
79750: PUSH
79751: LD_INT 1
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 1
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: NEG
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 1
79781: NEG
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 1
79793: NEG
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 2
79805: PUSH
79806: LD_INT 1
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 2
79815: PUSH
79816: LD_INT 2
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: LD_INT 2
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 2
79835: NEG
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 2
79847: NEG
79848: PUSH
79849: LD_INT 2
79851: NEG
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 3
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 3
79869: PUSH
79870: LD_INT 3
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PUSH
79877: LD_INT 2
79879: PUSH
79880: LD_INT 3
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79905: LD_ADDR_VAR 0 17
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: LD_INT 0
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 0
79922: PUSH
79923: LD_INT 1
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: LD_INT 0
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: LD_INT 1
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 0
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 1
79963: NEG
79964: PUSH
79965: LD_INT 0
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: LD_INT 1
79978: NEG
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 1
79986: NEG
79987: PUSH
79988: LD_INT 2
79990: NEG
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 0
79998: PUSH
79999: LD_INT 2
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 2
80020: PUSH
80021: LD_INT 0
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 2
80040: PUSH
80041: LD_INT 2
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: LD_INT 2
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 0
80060: PUSH
80061: LD_INT 2
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 1
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 2
80081: NEG
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 2
80104: NEG
80105: PUSH
80106: LD_INT 2
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80135: LD_ADDR_VAR 0 18
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: LD_INT 0
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 0
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 1
80193: NEG
80194: PUSH
80195: LD_INT 0
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: LD_INT 1
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 1
80216: NEG
80217: PUSH
80218: LD_INT 2
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 0
80228: PUSH
80229: LD_INT 2
80231: NEG
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 2
80270: PUSH
80271: LD_INT 2
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 1
80280: PUSH
80281: LD_INT 2
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 0
80290: PUSH
80291: LD_INT 2
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 1
80300: NEG
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 2
80311: NEG
80312: PUSH
80313: LD_INT 0
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 2
80334: NEG
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80365: LD_ADDR_VAR 0 19
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 0
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: LD_INT 1
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: LD_INT 0
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 1
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 1
80423: NEG
80424: PUSH
80425: LD_INT 0
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 1
80446: NEG
80447: PUSH
80448: LD_INT 2
80450: NEG
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: LD_INT 2
80461: NEG
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 1
80472: NEG
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 2
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: LD_INT 1
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: LD_INT 2
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: LD_INT 2
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: LD_INT 2
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 1
80530: NEG
80531: PUSH
80532: LD_INT 1
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 2
80541: NEG
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 2
80564: NEG
80565: PUSH
80566: LD_INT 2
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80595: LD_ADDR_VAR 0 20
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 0
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: PUSH
80624: LD_INT 0
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PUSH
80631: LD_INT 1
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 0
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: LD_INT 0
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 1
80668: NEG
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 1
80676: NEG
80677: PUSH
80678: LD_INT 2
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 2
80710: PUSH
80711: LD_INT 0
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 2
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 2
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 1
80740: PUSH
80741: LD_INT 2
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: LD_INT 2
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 1
80760: NEG
80761: PUSH
80762: LD_INT 1
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 2
80771: NEG
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: LD_INT 1
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: NEG
80795: PUSH
80796: LD_INT 2
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80825: LD_ADDR_VAR 0 21
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: LD_INT 0
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 0
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 1
80853: PUSH
80854: LD_INT 0
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 1
80863: PUSH
80864: LD_INT 1
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 0
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 1
80883: NEG
80884: PUSH
80885: LD_INT 0
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 1
80906: NEG
80907: PUSH
80908: LD_INT 2
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 0
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: LD_INT 1
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 2
80940: PUSH
80941: LD_INT 0
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 1
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: LD_INT 2
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 1
80970: PUSH
80971: LD_INT 2
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 0
80980: PUSH
80981: LD_INT 2
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: NEG
80991: PUSH
80992: LD_INT 1
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: LD_INT 0
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: LD_INT 1
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: NEG
81025: PUSH
81026: LD_INT 2
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81055: LD_ADDR_VAR 0 22
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 1
81083: PUSH
81084: LD_INT 0
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 0
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 1
81113: NEG
81114: PUSH
81115: LD_INT 0
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PUSH
81122: LD_INT 1
81124: NEG
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 1
81136: NEG
81137: PUSH
81138: LD_INT 2
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 2
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 2
81180: PUSH
81181: LD_INT 1
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 2
81190: PUSH
81191: LD_INT 2
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 1
81200: PUSH
81201: LD_INT 2
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: LD_INT 2
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: LD_INT 1
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 2
81242: NEG
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 2
81254: NEG
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81285: LD_ADDR_VAR 0 23
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 0
81302: PUSH
81303: LD_INT 1
81305: NEG
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 1
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 1
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: LD_INT 1
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: LD_INT 0
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 1
81354: NEG
81355: PUSH
81356: LD_INT 1
81358: NEG
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 1
81366: NEG
81367: PUSH
81368: LD_INT 2
81370: NEG
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 1
81389: PUSH
81390: LD_INT 1
81392: NEG
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 2
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 2
81410: PUSH
81411: LD_INT 1
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: LD_INT 2
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 2
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 0
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: NEG
81451: PUSH
81452: LD_INT 1
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: NEG
81462: PUSH
81463: LD_INT 0
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 2
81472: NEG
81473: PUSH
81474: LD_INT 1
81476: NEG
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 2
81484: NEG
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 2
81496: NEG
81497: PUSH
81498: LD_INT 3
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 1
81508: NEG
81509: PUSH
81510: LD_INT 3
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 1
81520: PUSH
81521: LD_INT 2
81523: NEG
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 2
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81565: LD_ADDR_VAR 0 24
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: LD_INT 1
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: LD_INT 0
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: LD_INT 1
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: NEG
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 1
81634: NEG
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 1
81646: NEG
81647: PUSH
81648: LD_INT 2
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 0
81658: PUSH
81659: LD_INT 2
81661: NEG
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 1
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 2
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 2
81690: PUSH
81691: LD_INT 1
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: LD_INT 2
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 1
81710: PUSH
81711: LD_INT 2
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: LD_INT 2
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: NEG
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 2
81741: NEG
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: NEG
81753: PUSH
81754: LD_INT 1
81756: NEG
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 2
81764: NEG
81765: PUSH
81766: LD_INT 2
81768: NEG
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: LD_INT 2
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 2
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 3
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 3
81808: PUSH
81809: LD_INT 2
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81841: LD_ADDR_VAR 0 25
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: LD_INT 1
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: LD_INT 0
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 0
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 1
81899: NEG
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 1
81910: NEG
81911: PUSH
81912: LD_INT 1
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: LD_INT 2
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 1
81945: PUSH
81946: LD_INT 1
81948: NEG
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 2
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 2
81966: PUSH
81967: LD_INT 1
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 2
81976: PUSH
81977: LD_INT 2
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 1
81986: PUSH
81987: LD_INT 2
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: NEG
82007: PUSH
82008: LD_INT 1
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 2
82028: NEG
82029: PUSH
82030: LD_INT 1
82032: NEG
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 2
82040: NEG
82041: PUSH
82042: LD_INT 2
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 3
82052: PUSH
82053: LD_INT 1
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: PUSH
82063: LD_INT 2
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 2
82072: PUSH
82073: LD_INT 3
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: PUSH
82083: LD_INT 3
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82115: LD_ADDR_VAR 0 26
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: LD_INT 0
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: LD_INT 0
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 1
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: LD_INT 1
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: LD_INT 0
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 1
82184: NEG
82185: PUSH
82186: LD_INT 1
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 1
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: LD_INT 0
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 2
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: LD_INT 2
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 1
82260: PUSH
82261: LD_INT 2
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: LD_INT 2
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: NEG
82292: PUSH
82293: LD_INT 0
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: LD_INT 1
82306: NEG
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 2
82326: PUSH
82327: LD_INT 3
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 1
82336: PUSH
82337: LD_INT 3
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 1
82346: NEG
82347: PUSH
82348: LD_INT 2
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: NEG
82358: PUSH
82359: LD_INT 1
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82391: LD_ADDR_VAR 0 27
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: LD_INT 1
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 1
82419: PUSH
82420: LD_INT 0
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 1
82429: PUSH
82430: LD_INT 1
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: LD_INT 1
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 1
82449: NEG
82450: PUSH
82451: LD_INT 0
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 2
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 0
82484: PUSH
82485: LD_INT 2
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 2
82506: PUSH
82507: LD_INT 0
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 2
82516: PUSH
82517: LD_INT 1
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 2
82526: PUSH
82527: LD_INT 2
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 1
82536: PUSH
82537: LD_INT 2
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: LD_INT 2
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 1
82556: NEG
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: NEG
82568: PUSH
82569: LD_INT 0
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 2
82578: NEG
82579: PUSH
82580: LD_INT 1
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: LD_INT 2
82594: NEG
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 1
82602: NEG
82603: PUSH
82604: LD_INT 2
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 2
82613: NEG
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 3
82624: NEG
82625: PUSH
82626: LD_INT 1
82628: NEG
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 3
82636: NEG
82637: PUSH
82638: LD_INT 2
82640: NEG
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82671: LD_ADDR_VAR 0 28
82675: PUSH
82676: LD_INT 0
82678: PUSH
82679: LD_INT 0
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 0
82688: PUSH
82689: LD_INT 1
82691: NEG
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: LD_INT 0
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 0
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 1
82729: NEG
82730: PUSH
82731: LD_INT 0
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: NEG
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: LD_INT 2
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: LD_INT 2
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: PUSH
82776: LD_INT 1
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: PUSH
82787: LD_INT 0
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: LD_INT 1
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: LD_INT 1
82816: PUSH
82817: LD_INT 2
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 0
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 2
82847: NEG
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 2
82858: NEG
82859: PUSH
82860: LD_INT 1
82862: NEG
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 2
82870: NEG
82871: PUSH
82872: LD_INT 2
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: NEG
82883: PUSH
82884: LD_INT 3
82886: NEG
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 1
82894: NEG
82895: PUSH
82896: LD_INT 3
82898: NEG
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 3
82906: NEG
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 3
82918: NEG
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82953: LD_ADDR_VAR 0 29
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: LD_INT 0
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: PUSH
82992: LD_INT 1
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: LD_INT 1
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: NEG
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: NEG
83023: PUSH
83024: LD_INT 1
83026: NEG
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 1
83034: NEG
83035: PUSH
83036: LD_INT 2
83038: NEG
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: LD_INT 2
83049: NEG
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: LD_INT 1
83060: NEG
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 2
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: LD_INT 2
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 0
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: NEG
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: LD_INT 1
83123: NEG
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 2
83131: NEG
83132: PUSH
83133: LD_INT 2
83135: NEG
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 2
83143: NEG
83144: PUSH
83145: LD_INT 3
83147: NEG
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: LD_INT 1
83158: NEG
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 3
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: LD_INT 3
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: LD_INT 2
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 3
83197: NEG
83198: PUSH
83199: LD_INT 2
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83232: LD_ADDR_VAR 0 30
83236: PUSH
83237: LD_INT 0
83239: PUSH
83240: LD_INT 0
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: LD_INT 1
83252: NEG
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: LD_INT 0
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 1
83270: PUSH
83271: LD_INT 1
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: LD_INT 1
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: LD_INT 2
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 1
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 2
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 2
83357: PUSH
83358: LD_INT 1
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 2
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: LD_INT 2
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 1
83387: NEG
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 2
83398: NEG
83399: PUSH
83400: LD_INT 0
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 2
83409: NEG
83410: PUSH
83411: LD_INT 1
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: NEG
83422: PUSH
83423: LD_INT 3
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 1
83433: PUSH
83434: LD_INT 2
83436: NEG
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 3
83444: PUSH
83445: LD_INT 2
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 1
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 3
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83510: LD_ADDR_VAR 0 31
83514: PUSH
83515: LD_INT 0
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: LD_INT 1
83530: NEG
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 0
83558: PUSH
83559: LD_INT 1
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 1
83568: NEG
83569: PUSH
83570: LD_INT 0
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: LD_INT 1
83583: NEG
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: NEG
83592: PUSH
83593: LD_INT 2
83595: NEG
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 1
83606: NEG
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 2
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 2
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: LD_INT 2
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: LD_INT 2
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: LD_INT 1
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: LD_INT 1
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 2
83687: NEG
83688: PUSH
83689: LD_INT 2
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 2
83699: NEG
83700: PUSH
83701: LD_INT 3
83703: NEG
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 2
83711: PUSH
83712: LD_INT 1
83714: NEG
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 3
83722: PUSH
83723: LD_INT 1
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 3
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 1
83742: NEG
83743: PUSH
83744: LD_INT 2
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 3
83753: NEG
83754: PUSH
83755: LD_INT 2
83757: NEG
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83788: LD_ADDR_VAR 0 32
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: LD_INT 0
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: LD_INT 1
83808: NEG
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: PUSH
83827: LD_INT 1
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: LD_INT 1
83861: NEG
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 1
83869: NEG
83870: PUSH
83871: LD_INT 2
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 0
83881: PUSH
83882: LD_INT 2
83884: NEG
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: LD_INT 1
83895: NEG
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 2
83903: PUSH
83904: LD_INT 1
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 2
83913: PUSH
83914: LD_INT 2
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: PUSH
83924: LD_INT 2
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 0
83933: PUSH
83934: LD_INT 2
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 2
83954: NEG
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 2
83965: NEG
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 3
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: LD_INT 2
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 3
84000: PUSH
84001: LD_INT 2
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: PUSH
84008: LD_INT 2
84010: PUSH
84011: LD_INT 3
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: LD_INT 1
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 3
84031: NEG
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84066: LD_ADDR_VAR 0 33
84070: PUSH
84071: LD_INT 0
84073: PUSH
84074: LD_INT 0
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: LD_INT 1
84086: NEG
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 1
84094: PUSH
84095: LD_INT 0
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: PUSH
84105: LD_INT 1
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 1
84124: NEG
84125: PUSH
84126: LD_INT 0
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 1
84135: NEG
84136: PUSH
84137: LD_INT 1
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: NEG
84148: PUSH
84149: LD_INT 2
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: LD_INT 1
84162: NEG
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 2
84170: PUSH
84171: LD_INT 0
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PUSH
84178: LD_INT 2
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: LD_INT 2
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 1
84210: NEG
84211: PUSH
84212: LD_INT 1
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: NEG
84222: PUSH
84223: LD_INT 0
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 2
84232: NEG
84233: PUSH
84234: LD_INT 1
84236: NEG
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 2
84244: NEG
84245: PUSH
84246: LD_INT 2
84248: NEG
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 2
84256: NEG
84257: PUSH
84258: LD_INT 3
84260: NEG
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 2
84268: PUSH
84269: LD_INT 1
84271: NEG
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 3
84279: PUSH
84280: LD_INT 1
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: LD_INT 1
84289: PUSH
84290: LD_INT 3
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 1
84299: NEG
84300: PUSH
84301: LD_INT 2
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 3
84310: NEG
84311: PUSH
84312: LD_INT 2
84314: NEG
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84345: LD_ADDR_VAR 0 34
84349: PUSH
84350: LD_INT 0
84352: PUSH
84353: LD_INT 0
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 0
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: PUSH
84374: LD_INT 0
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 1
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 1
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: LD_INT 0
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: NEG
84415: PUSH
84416: LD_INT 1
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: NEG
84427: PUSH
84428: LD_INT 2
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 0
84438: PUSH
84439: LD_INT 2
84441: NEG
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 1
84449: PUSH
84450: LD_INT 1
84452: NEG
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: LD_INT 1
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: LD_INT 2
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 1
84480: PUSH
84481: LD_INT 2
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 1
84490: NEG
84491: PUSH
84492: LD_INT 1
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 2
84512: NEG
84513: PUSH
84514: LD_INT 1
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 2
84524: NEG
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 1
84536: NEG
84537: PUSH
84538: LD_INT 3
84540: NEG
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 2
84551: NEG
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 3
84559: PUSH
84560: LD_INT 2
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: LD_INT 3
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 2
84579: NEG
84580: PUSH
84581: LD_INT 1
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 3
84590: NEG
84591: PUSH
84592: LD_INT 1
84594: NEG
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84625: LD_ADDR_VAR 0 35
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 0
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: LD_INT 1
84720: NEG
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84737: LD_ADDR_VAR 0 36
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: LD_INT 0
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: NEG
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: LD_INT 2
84822: NEG
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 1
84830: PUSH
84831: LD_INT 2
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84849: LD_ADDR_VAR 0 37
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 0
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: PUSH
84931: LD_INT 1
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84961: LD_ADDR_VAR 0 38
84965: PUSH
84966: LD_INT 0
84968: PUSH
84969: LD_INT 0
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 2
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 2
85052: NEG
85053: PUSH
85054: LD_INT 1
85056: NEG
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85073: LD_ADDR_VAR 0 39
85077: PUSH
85078: LD_INT 0
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: NEG
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: LD_INT 2
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85185: LD_ADDR_VAR 0 40
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 0
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: LD_INT 1
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: NEG
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 1
85258: NEG
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85297: LD_ADDR_VAR 0 41
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: LD_INT 0
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: LD_INT 1
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: NEG
85379: PUSH
85380: LD_INT 2
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 1
85390: PUSH
85391: LD_INT 1
85393: NEG
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 2
85401: PUSH
85402: LD_INT 0
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 2
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 1
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 1
85441: NEG
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 2
85452: NEG
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 2
85463: NEG
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 2
85475: NEG
85476: PUSH
85477: LD_INT 2
85479: NEG
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 2
85487: NEG
85488: PUSH
85489: LD_INT 3
85491: NEG
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: LD_INT 1
85502: NEG
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 3
85510: PUSH
85511: LD_INT 0
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 3
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 3
85530: PUSH
85531: LD_INT 2
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 3
85540: PUSH
85541: LD_INT 3
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: PUSH
85551: LD_INT 3
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 2
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 3
85571: NEG
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 3
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: NEG
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 3
85594: NEG
85595: PUSH
85596: LD_INT 2
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 3
85606: NEG
85607: PUSH
85608: LD_INT 3
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85647: LD_ADDR_VAR 0 42
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 1
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 0
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 1
85705: NEG
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 1
85716: NEG
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 1
85728: NEG
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 0
85740: PUSH
85741: LD_INT 2
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: PUSH
85752: LD_INT 1
85754: NEG
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: LD_INT 1
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 2
85772: PUSH
85773: LD_INT 2
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 1
85782: PUSH
85783: LD_INT 2
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: LD_INT 2
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 2
85813: NEG
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 2
85825: NEG
85826: PUSH
85827: LD_INT 2
85829: NEG
85830: PUSH
85831: EMPTY
85832: LIST
85833: LIST
85834: PUSH
85835: LD_INT 2
85837: NEG
85838: PUSH
85839: LD_INT 3
85841: NEG
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: LD_INT 3
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 0
85861: PUSH
85862: LD_INT 3
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: LD_INT 2
85875: NEG
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 3
85883: PUSH
85884: LD_INT 2
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 3
85893: PUSH
85894: LD_INT 3
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 2
85903: PUSH
85904: LD_INT 3
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: PUSH
85914: LD_INT 3
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 0
85923: PUSH
85924: LD_INT 3
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: NEG
85934: PUSH
85935: LD_INT 2
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 3
85944: NEG
85945: PUSH
85946: LD_INT 2
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 3
85956: NEG
85957: PUSH
85958: LD_INT 3
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85997: LD_ADDR_VAR 0 43
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: LD_INT 0
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 1
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: LD_INT 1
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 0
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 1
86055: NEG
86056: PUSH
86057: LD_INT 0
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: LD_INT 1
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 1
86078: NEG
86079: PUSH
86080: LD_INT 2
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: LD_INT 2
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 1
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 2
86112: PUSH
86113: LD_INT 0
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 2
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: LD_INT 2
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 1
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 2
86163: NEG
86164: PUSH
86165: LD_INT 0
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 2
86174: NEG
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 1
86186: NEG
86187: PUSH
86188: LD_INT 3
86190: NEG
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 0
86198: PUSH
86199: LD_INT 3
86201: NEG
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: LD_INT 2
86212: NEG
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 2
86220: PUSH
86221: LD_INT 1
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 3
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 3
86241: PUSH
86242: LD_INT 1
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: LD_INT 3
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 0
86261: PUSH
86262: LD_INT 3
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: NEG
86272: PUSH
86273: LD_INT 2
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 2
86282: NEG
86283: PUSH
86284: LD_INT 1
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 3
86293: NEG
86294: PUSH
86295: LD_INT 0
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 3
86304: NEG
86305: PUSH
86306: LD_INT 1
86308: NEG
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86345: LD_ADDR_VAR 0 44
86349: PUSH
86350: LD_INT 0
86352: PUSH
86353: LD_INT 0
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: LD_INT 1
86365: NEG
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 1
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 1
86383: PUSH
86384: LD_INT 1
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 0
86393: PUSH
86394: LD_INT 1
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: LD_INT 0
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 1
86414: NEG
86415: PUSH
86416: LD_INT 1
86418: NEG
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 1
86426: NEG
86427: PUSH
86428: LD_INT 2
86430: NEG
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 1
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 2
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 2
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 2
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 2
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 1
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 2
86500: NEG
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 2
86511: NEG
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 2
86523: NEG
86524: PUSH
86525: LD_INT 2
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 2
86535: NEG
86536: PUSH
86537: LD_INT 3
86539: NEG
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 2
86547: PUSH
86548: LD_INT 1
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 3
86558: PUSH
86559: LD_INT 0
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PUSH
86566: LD_INT 3
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: LD_INT 3
86578: PUSH
86579: LD_INT 2
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: PUSH
86586: LD_INT 3
86588: PUSH
86589: LD_INT 3
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 2
86598: PUSH
86599: LD_INT 3
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 2
86608: NEG
86609: PUSH
86610: LD_INT 1
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 3
86619: NEG
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 3
86630: NEG
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 3
86642: NEG
86643: PUSH
86644: LD_INT 2
86646: NEG
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 3
86654: NEG
86655: PUSH
86656: LD_INT 3
86658: NEG
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86695: LD_ADDR_VAR 0 45
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: LD_INT 1
86715: NEG
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 1
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 1
86733: PUSH
86734: LD_INT 1
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: NEG
86765: PUSH
86766: LD_INT 1
86768: NEG
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 2
86780: NEG
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: LD_INT 2
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: PUSH
86800: LD_INT 1
86802: NEG
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: LD_INT 1
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 2
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 1
86830: PUSH
86831: LD_INT 2
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: LD_INT 2
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 2
86861: NEG
86862: PUSH
86863: LD_INT 1
86865: NEG
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 2
86873: NEG
86874: PUSH
86875: LD_INT 2
86877: NEG
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 2
86885: NEG
86886: PUSH
86887: LD_INT 3
86889: NEG
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 1
86897: NEG
86898: PUSH
86899: LD_INT 3
86901: NEG
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 0
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 1
86920: PUSH
86921: LD_INT 2
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 3
86931: PUSH
86932: LD_INT 2
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 3
86941: PUSH
86942: LD_INT 3
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: LD_INT 3
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 0
86971: PUSH
86972: LD_INT 3
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 1
86981: NEG
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 3
86992: NEG
86993: PUSH
86994: LD_INT 2
86996: NEG
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 3
87004: NEG
87005: PUSH
87006: LD_INT 3
87008: NEG
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87045: LD_ADDR_VAR 0 46
87049: PUSH
87050: LD_INT 0
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: LD_INT 1
87065: NEG
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 1
87073: PUSH
87074: LD_INT 0
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 1
87083: PUSH
87084: LD_INT 1
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 1
87103: NEG
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: LD_INT 1
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 2
87130: NEG
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: LD_INT 2
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 2
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: PUSH
87168: LD_INT 2
87170: PUSH
87171: LD_INT 1
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 0
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 1
87200: NEG
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 2
87211: NEG
87212: PUSH
87213: LD_INT 0
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 2
87222: NEG
87223: PUSH
87224: LD_INT 1
87226: NEG
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 1
87234: NEG
87235: PUSH
87236: LD_INT 3
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 2
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 2
87268: PUSH
87269: LD_INT 1
87271: NEG
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 3
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 3
87289: PUSH
87290: LD_INT 1
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: LD_INT 3
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 0
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: NEG
87320: PUSH
87321: LD_INT 2
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 2
87330: NEG
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 3
87341: NEG
87342: PUSH
87343: LD_INT 0
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 3
87352: NEG
87353: PUSH
87354: LD_INT 1
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87393: LD_ADDR_VAR 0 47
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: LD_INT 1
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: LD_INT 0
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 2
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 0
87486: PUSH
87487: LD_INT 2
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: NEG
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: NEG
87521: PUSH
87522: LD_INT 2
87524: NEG
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87544: LD_ADDR_VAR 0 48
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: LD_INT 1
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 1
87602: NEG
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: LD_INT 1
87617: NEG
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: LD_INT 2
87629: NEG
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: LD_INT 2
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 1
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 2
87659: PUSH
87660: LD_INT 0
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87691: LD_ADDR_VAR 0 49
87695: PUSH
87696: LD_INT 0
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: LD_INT 1
87711: NEG
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: PUSH
87717: LD_INT 1
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 1
87729: PUSH
87730: LD_INT 1
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 0
87739: PUSH
87740: LD_INT 1
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 1
87749: NEG
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 1
87760: NEG
87761: PUSH
87762: LD_INT 1
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: LD_INT 1
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 2
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 2
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 2
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87835: LD_ADDR_VAR 0 50
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: LD_INT 1
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: LD_INT 1
87908: NEG
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: LD_INT 1
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 2
87926: PUSH
87927: LD_INT 2
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 1
87936: PUSH
87937: LD_INT 2
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: LD_INT 2
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87979: LD_ADDR_VAR 0 51
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 0
87996: PUSH
87997: LD_INT 1
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 1
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 1
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: LD_INT 1
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 1
88037: NEG
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 1
88060: PUSH
88061: LD_INT 2
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: LD_INT 2
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88126: LD_ADDR_VAR 0 52
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 0
88143: PUSH
88144: LD_INT 1
88146: NEG
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 1
88164: PUSH
88165: LD_INT 1
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: LD_INT 1
88184: NEG
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 1
88195: NEG
88196: PUSH
88197: LD_INT 1
88199: NEG
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: NEG
88208: PUSH
88209: LD_INT 2
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 1
88219: NEG
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 2
88230: NEG
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: NEG
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 2
88253: NEG
88254: PUSH
88255: LD_INT 2
88257: NEG
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88277: LD_ADDR_VAR 0 53
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 0
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 1
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 1
88335: NEG
88336: PUSH
88337: LD_INT 0
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: NEG
88347: PUSH
88348: LD_INT 1
88350: NEG
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: NEG
88359: PUSH
88360: LD_INT 2
88362: NEG
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: LD_INT 2
88373: NEG
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 1
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 2
88392: PUSH
88393: LD_INT 0
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 2
88402: PUSH
88403: LD_INT 1
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 2
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: LD_INT 2
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 1
88442: NEG
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 2
88453: NEG
88454: PUSH
88455: LD_INT 0
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 2
88476: NEG
88477: PUSH
88478: LD_INT 2
88480: NEG
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88507: LD_ADDR_VAR 0 54
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 0
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 0
88524: PUSH
88525: LD_INT 1
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: PUSH
88536: LD_INT 0
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 1
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 0
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 1
88565: NEG
88566: PUSH
88567: LD_INT 0
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 1
88576: NEG
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 1
88588: NEG
88589: PUSH
88590: LD_INT 2
88592: NEG
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 0
88600: PUSH
88601: LD_INT 2
88603: NEG
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: LD_INT 1
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: LD_INT 0
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 2
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 2
88642: PUSH
88643: LD_INT 2
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 1
88652: PUSH
88653: LD_INT 2
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 0
88662: PUSH
88663: LD_INT 2
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: NEG
88673: PUSH
88674: LD_INT 1
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 2
88683: NEG
88684: PUSH
88685: LD_INT 0
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: LD_INT 1
88698: NEG
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 2
88706: NEG
88707: PUSH
88708: LD_INT 2
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88737: LD_ADDR_VAR 0 55
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 0
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: PUSH
88766: LD_INT 0
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 1
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 0
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: NEG
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 1
88806: NEG
88807: PUSH
88808: LD_INT 1
88810: NEG
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: LD_INT 1
88818: NEG
88819: PUSH
88820: LD_INT 2
88822: NEG
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 0
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: LD_INT 1
88844: NEG
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 2
88852: PUSH
88853: LD_INT 0
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 2
88862: PUSH
88863: LD_INT 1
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: LD_INT 2
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: PUSH
88883: LD_INT 2
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: LD_INT 2
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: NEG
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 2
88913: NEG
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 2
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88967: LD_ADDR_VAR 0 56
88971: PUSH
88972: LD_INT 0
88974: PUSH
88975: LD_INT 0
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 1
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 0
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 1
89025: NEG
89026: PUSH
89027: LD_INT 0
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 1
89036: NEG
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: LD_INT 2
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: LD_INT 2
89063: NEG
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 2
89082: PUSH
89083: LD_INT 0
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 2
89092: PUSH
89093: LD_INT 1
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 2
89102: PUSH
89103: LD_INT 2
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: PUSH
89113: LD_INT 2
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 2
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: NEG
89144: PUSH
89145: LD_INT 0
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 2
89154: NEG
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 2
89166: NEG
89167: PUSH
89168: LD_INT 2
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89197: LD_ADDR_VAR 0 57
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: LD_INT 0
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 1
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: LD_INT 1
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 1
89255: NEG
89256: PUSH
89257: LD_INT 0
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 1
89270: NEG
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: LD_INT 2
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 0
89290: PUSH
89291: LD_INT 2
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: PUSH
89302: LD_INT 1
89304: NEG
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 2
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 2
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 2
89332: PUSH
89333: LD_INT 2
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 2
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 0
89352: PUSH
89353: LD_INT 2
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 1
89362: NEG
89363: PUSH
89364: LD_INT 1
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: LD_INT 0
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 2
89396: NEG
89397: PUSH
89398: LD_INT 2
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89427: LD_ADDR_VAR 0 58
89431: PUSH
89432: LD_INT 0
89434: PUSH
89435: LD_INT 0
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: LD_INT 1
89447: NEG
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: LD_INT 0
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: LD_INT 1
89465: PUSH
89466: LD_INT 1
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 0
89475: PUSH
89476: LD_INT 1
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: LD_INT 1
89485: NEG
89486: PUSH
89487: LD_INT 0
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: LD_INT 1
89508: NEG
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 0
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 1
89531: PUSH
89532: LD_INT 1
89534: NEG
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 2
89542: PUSH
89543: LD_INT 0
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 2
89552: PUSH
89553: LD_INT 1
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 2
89562: PUSH
89563: LD_INT 2
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: PUSH
89573: LD_INT 2
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 0
89582: PUSH
89583: LD_INT 2
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 2
89603: NEG
89604: PUSH
89605: LD_INT 0
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 2
89614: NEG
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: NEG
89627: PUSH
89628: LD_INT 2
89630: NEG
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89657: LD_ADDR_VAR 0 59
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: LD_INT 0
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 0
89674: PUSH
89675: LD_INT 1
89677: NEG
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 1
89685: PUSH
89686: LD_INT 0
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 1
89695: PUSH
89696: LD_INT 1
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: LD_INT 1
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 1
89715: NEG
89716: PUSH
89717: LD_INT 0
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: LD_INT 1
89730: NEG
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89745: LD_ADDR_VAR 0 60
89749: PUSH
89750: LD_INT 0
89752: PUSH
89753: LD_INT 0
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: LD_INT 1
89765: NEG
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 1
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 1
89783: PUSH
89784: LD_INT 1
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 1
89803: NEG
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 1
89814: NEG
89815: PUSH
89816: LD_INT 1
89818: NEG
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89833: LD_ADDR_VAR 0 61
89837: PUSH
89838: LD_INT 0
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: LD_INT 1
89853: NEG
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 1
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: LD_INT 1
89906: NEG
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89921: LD_ADDR_VAR 0 62
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: LD_INT 0
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: LD_INT 1
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: LD_INT 0
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: LD_INT 1
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 0
89969: PUSH
89970: LD_INT 1
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 1
89979: NEG
89980: PUSH
89981: LD_INT 0
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 1
89990: NEG
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90009: LD_ADDR_VAR 0 63
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 1
90037: PUSH
90038: LD_INT 0
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: PUSH
90048: LD_INT 1
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 1
90067: NEG
90068: PUSH
90069: LD_INT 0
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: LD_INT 1
90082: NEG
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90097: LD_ADDR_VAR 0 64
90101: PUSH
90102: LD_INT 0
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: LD_INT 1
90125: PUSH
90126: LD_INT 0
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: NEG
90156: PUSH
90157: LD_INT 0
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: ST_TO_ADDR
// end ; 1 :
90185: GO 96082
90187: LD_INT 1
90189: DOUBLE
90190: EQUAL
90191: IFTRUE 90195
90193: GO 92818
90195: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90196: LD_ADDR_VAR 0 11
90200: PUSH
90201: LD_INT 1
90203: NEG
90204: PUSH
90205: LD_INT 3
90207: NEG
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 0
90215: PUSH
90216: LD_INT 3
90218: NEG
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 1
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: LIST
90239: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90240: LD_ADDR_VAR 0 12
90244: PUSH
90245: LD_INT 2
90247: PUSH
90248: LD_INT 1
90250: NEG
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 3
90258: PUSH
90259: LD_INT 0
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 3
90268: PUSH
90269: LD_INT 1
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: LIST
90280: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90281: LD_ADDR_VAR 0 13
90285: PUSH
90286: LD_INT 3
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 3
90298: PUSH
90299: LD_INT 3
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 2
90308: PUSH
90309: LD_INT 3
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: LIST
90320: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90321: LD_ADDR_VAR 0 14
90325: PUSH
90326: LD_INT 1
90328: PUSH
90329: LD_INT 3
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 0
90338: PUSH
90339: LD_INT 3
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: PUSH
90346: LD_INT 1
90348: NEG
90349: PUSH
90350: LD_INT 2
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90362: LD_ADDR_VAR 0 15
90366: PUSH
90367: LD_INT 2
90369: NEG
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 3
90380: NEG
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 3
90391: NEG
90392: PUSH
90393: LD_INT 1
90395: NEG
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90406: LD_ADDR_VAR 0 16
90410: PUSH
90411: LD_INT 2
90413: NEG
90414: PUSH
90415: LD_INT 3
90417: NEG
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 3
90425: NEG
90426: PUSH
90427: LD_INT 2
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 3
90437: NEG
90438: PUSH
90439: LD_INT 3
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: LIST
90451: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90452: LD_ADDR_VAR 0 17
90456: PUSH
90457: LD_INT 1
90459: NEG
90460: PUSH
90461: LD_INT 3
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 3
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 2
90485: NEG
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: LIST
90495: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90496: LD_ADDR_VAR 0 18
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: LD_INT 1
90506: NEG
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 3
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 3
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: LIST
90536: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90537: LD_ADDR_VAR 0 19
90541: PUSH
90542: LD_INT 3
90544: PUSH
90545: LD_INT 2
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 3
90554: PUSH
90555: LD_INT 3
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 2
90564: PUSH
90565: LD_INT 3
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: LIST
90576: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90577: LD_ADDR_VAR 0 20
90581: PUSH
90582: LD_INT 1
90584: PUSH
90585: LD_INT 3
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 0
90594: PUSH
90595: LD_INT 3
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PUSH
90602: LD_INT 1
90604: NEG
90605: PUSH
90606: LD_INT 2
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90618: LD_ADDR_VAR 0 21
90622: PUSH
90623: LD_INT 2
90625: NEG
90626: PUSH
90627: LD_INT 1
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 3
90636: NEG
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 3
90647: NEG
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: LIST
90661: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90662: LD_ADDR_VAR 0 22
90666: PUSH
90667: LD_INT 2
90669: NEG
90670: PUSH
90671: LD_INT 3
90673: NEG
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 3
90681: NEG
90682: PUSH
90683: LD_INT 2
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 3
90693: NEG
90694: PUSH
90695: LD_INT 3
90697: NEG
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: LIST
90707: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90708: LD_ADDR_VAR 0 23
90712: PUSH
90713: LD_INT 0
90715: PUSH
90716: LD_INT 3
90718: NEG
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 1
90726: NEG
90727: PUSH
90728: LD_INT 4
90730: NEG
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: LD_INT 3
90741: NEG
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: LIST
90751: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90752: LD_ADDR_VAR 0 24
90756: PUSH
90757: LD_INT 3
90759: PUSH
90760: LD_INT 0
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 3
90769: PUSH
90770: LD_INT 1
90772: NEG
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 4
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: LIST
90792: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90793: LD_ADDR_VAR 0 25
90797: PUSH
90798: LD_INT 3
90800: PUSH
90801: LD_INT 3
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 4
90810: PUSH
90811: LD_INT 3
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 3
90820: PUSH
90821: LD_INT 4
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: LIST
90832: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90833: LD_ADDR_VAR 0 26
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: LD_INT 3
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: PUSH
90851: LD_INT 4
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 1
90860: NEG
90861: PUSH
90862: LD_INT 3
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: LIST
90873: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90874: LD_ADDR_VAR 0 27
90878: PUSH
90879: LD_INT 3
90881: NEG
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 3
90892: NEG
90893: PUSH
90894: LD_INT 1
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 4
90903: NEG
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: LIST
90917: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90918: LD_ADDR_VAR 0 28
90922: PUSH
90923: LD_INT 3
90925: NEG
90926: PUSH
90927: LD_INT 3
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 3
90937: NEG
90938: PUSH
90939: LD_INT 4
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 4
90949: NEG
90950: PUSH
90951: LD_INT 3
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: LIST
90963: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90964: LD_ADDR_VAR 0 29
90968: PUSH
90969: LD_INT 1
90971: NEG
90972: PUSH
90973: LD_INT 3
90975: NEG
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 0
90983: PUSH
90984: LD_INT 3
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 1
90994: PUSH
90995: LD_INT 2
90997: NEG
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 1
91005: NEG
91006: PUSH
91007: LD_INT 4
91009: NEG
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 0
91017: PUSH
91018: LD_INT 4
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: LD_INT 3
91031: NEG
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: LD_INT 5
91043: NEG
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 5
91054: NEG
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 1
91062: PUSH
91063: LD_INT 4
91065: NEG
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: LD_INT 6
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 6
91088: NEG
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 1
91096: PUSH
91097: LD_INT 5
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91119: LD_ADDR_VAR 0 30
91123: PUSH
91124: LD_INT 2
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 3
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 3
91147: PUSH
91148: LD_INT 1
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 4
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 4
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 4
91188: PUSH
91189: LD_INT 1
91191: NEG
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 5
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 5
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 5
91219: PUSH
91220: LD_INT 1
91222: NEG
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 6
91230: PUSH
91231: LD_INT 0
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 6
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91262: LD_ADDR_VAR 0 31
91266: PUSH
91267: LD_INT 3
91269: PUSH
91270: LD_INT 2
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 3
91279: PUSH
91280: LD_INT 3
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 2
91289: PUSH
91290: LD_INT 3
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 4
91299: PUSH
91300: LD_INT 3
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 4
91309: PUSH
91310: LD_INT 4
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 3
91319: PUSH
91320: LD_INT 4
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 5
91329: PUSH
91330: LD_INT 4
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 5
91339: PUSH
91340: LD_INT 5
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 4
91349: PUSH
91350: LD_INT 5
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 6
91359: PUSH
91360: LD_INT 5
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 6
91369: PUSH
91370: LD_INT 6
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 5
91379: PUSH
91380: LD_INT 6
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91401: LD_ADDR_VAR 0 32
91405: PUSH
91406: LD_INT 1
91408: PUSH
91409: LD_INT 3
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 1
91428: NEG
91429: PUSH
91430: LD_INT 2
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 1
91439: PUSH
91440: LD_INT 4
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 0
91449: PUSH
91450: LD_INT 4
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 1
91459: NEG
91460: PUSH
91461: LD_INT 3
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: LD_INT 5
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: LD_INT 5
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 1
91490: NEG
91491: PUSH
91492: LD_INT 4
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: PUSH
91502: LD_INT 6
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: LD_INT 6
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 1
91521: NEG
91522: PUSH
91523: LD_INT 5
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91544: LD_ADDR_VAR 0 33
91548: PUSH
91549: LD_INT 2
91551: NEG
91552: PUSH
91553: LD_INT 1
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 3
91562: NEG
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: NEG
91574: PUSH
91575: LD_INT 1
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 3
91585: NEG
91586: PUSH
91587: LD_INT 1
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 4
91596: NEG
91597: PUSH
91598: LD_INT 0
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 4
91607: NEG
91608: PUSH
91609: LD_INT 1
91611: NEG
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 4
91619: NEG
91620: PUSH
91621: LD_INT 1
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 5
91630: NEG
91631: PUSH
91632: LD_INT 0
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 5
91641: NEG
91642: PUSH
91643: LD_INT 1
91645: NEG
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 5
91653: NEG
91654: PUSH
91655: LD_INT 1
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 6
91664: NEG
91665: PUSH
91666: LD_INT 0
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 6
91675: NEG
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91699: LD_ADDR_VAR 0 34
91703: PUSH
91704: LD_INT 2
91706: NEG
91707: PUSH
91708: LD_INT 3
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 3
91718: NEG
91719: PUSH
91720: LD_INT 2
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 3
91730: NEG
91731: PUSH
91732: LD_INT 3
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 3
91742: NEG
91743: PUSH
91744: LD_INT 4
91746: NEG
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 4
91754: NEG
91755: PUSH
91756: LD_INT 3
91758: NEG
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 4
91766: NEG
91767: PUSH
91768: LD_INT 4
91770: NEG
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 4
91778: NEG
91779: PUSH
91780: LD_INT 5
91782: NEG
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 5
91790: NEG
91791: PUSH
91792: LD_INT 4
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 5
91802: NEG
91803: PUSH
91804: LD_INT 5
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 5
91814: NEG
91815: PUSH
91816: LD_INT 6
91818: NEG
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 6
91826: NEG
91827: PUSH
91828: LD_INT 5
91830: NEG
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 6
91838: NEG
91839: PUSH
91840: LD_INT 6
91842: NEG
91843: PUSH
91844: EMPTY
91845: LIST
91846: LIST
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91862: LD_ADDR_VAR 0 41
91866: PUSH
91867: LD_INT 0
91869: PUSH
91870: LD_INT 2
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 1
91880: NEG
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: LD_INT 2
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91906: LD_ADDR_VAR 0 42
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 2
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 3
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91947: LD_ADDR_VAR 0 43
91951: PUSH
91952: LD_INT 2
91954: PUSH
91955: LD_INT 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 3
91964: PUSH
91965: LD_INT 2
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 2
91974: PUSH
91975: LD_INT 3
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: LIST
91986: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91987: LD_ADDR_VAR 0 44
91991: PUSH
91992: LD_INT 0
91994: PUSH
91995: LD_INT 2
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 1
92004: PUSH
92005: LD_INT 3
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 1
92014: NEG
92015: PUSH
92016: LD_INT 2
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: LIST
92027: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92028: LD_ADDR_VAR 0 45
92032: PUSH
92033: LD_INT 2
92035: NEG
92036: PUSH
92037: LD_INT 0
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: LD_INT 1
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92072: LD_ADDR_VAR 0 46
92076: PUSH
92077: LD_INT 2
92079: NEG
92080: PUSH
92081: LD_INT 2
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 2
92091: NEG
92092: PUSH
92093: LD_INT 3
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 3
92103: NEG
92104: PUSH
92105: LD_INT 2
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: LIST
92117: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92118: LD_ADDR_VAR 0 47
92122: PUSH
92123: LD_INT 2
92125: NEG
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 3
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92151: LD_ADDR_VAR 0 48
92155: PUSH
92156: LD_INT 1
92158: PUSH
92159: LD_INT 2
92161: NEG
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 2
92169: PUSH
92170: LD_INT 1
92172: NEG
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92182: LD_ADDR_VAR 0 49
92186: PUSH
92187: LD_INT 3
92189: PUSH
92190: LD_INT 1
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 3
92199: PUSH
92200: LD_INT 2
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92211: LD_ADDR_VAR 0 50
92215: PUSH
92216: LD_INT 2
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: LD_INT 3
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92240: LD_ADDR_VAR 0 51
92244: PUSH
92245: LD_INT 1
92247: NEG
92248: PUSH
92249: LD_INT 2
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 2
92258: NEG
92259: PUSH
92260: LD_INT 1
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92271: LD_ADDR_VAR 0 52
92275: PUSH
92276: LD_INT 3
92278: NEG
92279: PUSH
92280: LD_INT 1
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 3
92290: NEG
92291: PUSH
92292: LD_INT 2
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92304: LD_ADDR_VAR 0 53
92308: PUSH
92309: LD_INT 1
92311: NEG
92312: PUSH
92313: LD_INT 3
92315: NEG
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 0
92323: PUSH
92324: LD_INT 3
92326: NEG
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 1
92334: PUSH
92335: LD_INT 2
92337: NEG
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: LIST
92347: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92348: LD_ADDR_VAR 0 54
92352: PUSH
92353: LD_INT 2
92355: PUSH
92356: LD_INT 1
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 3
92366: PUSH
92367: LD_INT 0
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 3
92376: PUSH
92377: LD_INT 1
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: LIST
92388: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92389: LD_ADDR_VAR 0 55
92393: PUSH
92394: LD_INT 3
92396: PUSH
92397: LD_INT 2
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 3
92406: PUSH
92407: LD_INT 3
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: LD_INT 3
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: LIST
92428: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92429: LD_ADDR_VAR 0 56
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 3
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 3
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: NEG
92457: PUSH
92458: LD_INT 2
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: EMPTY
92466: LIST
92467: LIST
92468: LIST
92469: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92470: LD_ADDR_VAR 0 57
92474: PUSH
92475: LD_INT 2
92477: NEG
92478: PUSH
92479: LD_INT 1
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 3
92488: NEG
92489: PUSH
92490: LD_INT 0
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 3
92499: NEG
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: LIST
92513: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92514: LD_ADDR_VAR 0 58
92518: PUSH
92519: LD_INT 2
92521: NEG
92522: PUSH
92523: LD_INT 3
92525: NEG
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 3
92533: NEG
92534: PUSH
92535: LD_INT 2
92537: NEG
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 3
92545: NEG
92546: PUSH
92547: LD_INT 3
92549: NEG
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: LIST
92559: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92560: LD_ADDR_VAR 0 59
92564: PUSH
92565: LD_INT 1
92567: NEG
92568: PUSH
92569: LD_INT 2
92571: NEG
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 0
92579: PUSH
92580: LD_INT 2
92582: NEG
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: LD_INT 1
92593: NEG
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: LIST
92603: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92604: LD_ADDR_VAR 0 60
92608: PUSH
92609: LD_INT 1
92611: PUSH
92612: LD_INT 1
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 2
92622: PUSH
92623: LD_INT 0
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: PUSH
92633: LD_INT 1
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: LIST
92644: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92645: LD_ADDR_VAR 0 61
92649: PUSH
92650: LD_INT 2
92652: PUSH
92653: LD_INT 1
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: LD_INT 2
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: LD_INT 2
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: LIST
92684: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92685: LD_ADDR_VAR 0 62
92689: PUSH
92690: LD_INT 1
92692: PUSH
92693: LD_INT 2
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 0
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 1
92712: NEG
92713: PUSH
92714: LD_INT 1
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: LIST
92725: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92726: LD_ADDR_VAR 0 63
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: LD_INT 1
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 2
92744: NEG
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 2
92755: NEG
92756: PUSH
92757: LD_INT 1
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: LIST
92769: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92770: LD_ADDR_VAR 0 64
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 2
92789: NEG
92790: PUSH
92791: LD_INT 1
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 2
92801: NEG
92802: PUSH
92803: LD_INT 2
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: LIST
92815: ST_TO_ADDR
// end ; 2 :
92816: GO 96082
92818: LD_INT 2
92820: DOUBLE
92821: EQUAL
92822: IFTRUE 92826
92824: GO 96081
92826: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92827: LD_ADDR_VAR 0 29
92831: PUSH
92832: LD_INT 4
92834: PUSH
92835: LD_INT 0
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: LD_INT 4
92844: PUSH
92845: LD_INT 1
92847: NEG
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 5
92855: PUSH
92856: LD_INT 0
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 5
92865: PUSH
92866: LD_INT 1
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 4
92875: PUSH
92876: LD_INT 1
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 3
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 3
92895: PUSH
92896: LD_INT 1
92898: NEG
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 3
92906: PUSH
92907: LD_INT 2
92909: NEG
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 5
92917: PUSH
92918: LD_INT 2
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 3
92927: PUSH
92928: LD_INT 3
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 3
92937: PUSH
92938: LD_INT 2
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 4
92947: PUSH
92948: LD_INT 3
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 4
92957: PUSH
92958: LD_INT 4
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 3
92967: PUSH
92968: LD_INT 4
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 2
92977: PUSH
92978: LD_INT 3
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 2
92987: PUSH
92988: LD_INT 2
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 4
92997: PUSH
92998: LD_INT 2
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 2
93007: PUSH
93008: LD_INT 4
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: LD_INT 4
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 0
93027: PUSH
93028: LD_INT 3
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: LD_INT 4
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: LD_INT 5
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 0
93057: PUSH
93058: LD_INT 5
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 1
93067: NEG
93068: PUSH
93069: LD_INT 4
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: LD_INT 3
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: LD_INT 5
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 2
93099: NEG
93100: PUSH
93101: LD_INT 3
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: LD_INT 3
93110: NEG
93111: PUSH
93112: LD_INT 0
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 3
93121: NEG
93122: PUSH
93123: LD_INT 1
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 2
93133: NEG
93134: PUSH
93135: LD_INT 0
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 2
93144: NEG
93145: PUSH
93146: LD_INT 1
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 3
93155: NEG
93156: PUSH
93157: LD_INT 1
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 4
93166: NEG
93167: PUSH
93168: LD_INT 0
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 4
93177: NEG
93178: PUSH
93179: LD_INT 1
93181: NEG
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 4
93189: NEG
93190: PUSH
93191: LD_INT 2
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 2
93201: NEG
93202: PUSH
93203: LD_INT 2
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 4
93212: NEG
93213: PUSH
93214: LD_INT 4
93216: NEG
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 4
93224: NEG
93225: PUSH
93226: LD_INT 5
93228: NEG
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 3
93236: NEG
93237: PUSH
93238: LD_INT 4
93240: NEG
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 3
93248: NEG
93249: PUSH
93250: LD_INT 3
93252: NEG
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 4
93260: NEG
93261: PUSH
93262: LD_INT 3
93264: NEG
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 5
93272: NEG
93273: PUSH
93274: LD_INT 4
93276: NEG
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 5
93284: NEG
93285: PUSH
93286: LD_INT 5
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 3
93296: NEG
93297: PUSH
93298: LD_INT 5
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 5
93308: NEG
93309: PUSH
93310: LD_INT 3
93312: NEG
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93365: LD_ADDR_VAR 0 30
93369: PUSH
93370: LD_INT 4
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 4
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 5
93392: PUSH
93393: LD_INT 4
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 5
93402: PUSH
93403: LD_INT 5
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 4
93412: PUSH
93413: LD_INT 5
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 3
93422: PUSH
93423: LD_INT 4
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 3
93432: PUSH
93433: LD_INT 3
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 5
93442: PUSH
93443: LD_INT 3
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 3
93452: PUSH
93453: LD_INT 5
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: LD_INT 0
93462: PUSH
93463: LD_INT 3
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 0
93472: PUSH
93473: LD_INT 2
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: LD_INT 3
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: LD_INT 4
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 0
93502: PUSH
93503: LD_INT 4
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: LD_INT 3
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 1
93523: NEG
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 2
93534: PUSH
93535: LD_INT 4
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 2
93544: NEG
93545: PUSH
93546: LD_INT 2
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 4
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 3
93578: NEG
93579: PUSH
93580: LD_INT 0
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 3
93589: NEG
93590: PUSH
93591: LD_INT 1
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 4
93600: NEG
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 5
93611: NEG
93612: PUSH
93613: LD_INT 0
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 5
93622: NEG
93623: PUSH
93624: LD_INT 1
93626: NEG
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 5
93634: NEG
93635: PUSH
93636: LD_INT 2
93638: NEG
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 3
93646: NEG
93647: PUSH
93648: LD_INT 2
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 3
93657: NEG
93658: PUSH
93659: LD_INT 3
93661: NEG
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 3
93669: NEG
93670: PUSH
93671: LD_INT 4
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 2
93681: NEG
93682: PUSH
93683: LD_INT 3
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 2
93693: NEG
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 3
93705: NEG
93706: PUSH
93707: LD_INT 2
93709: NEG
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 4
93717: NEG
93718: PUSH
93719: LD_INT 3
93721: NEG
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 4
93729: NEG
93730: PUSH
93731: LD_INT 4
93733: NEG
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: PUSH
93739: LD_INT 2
93741: NEG
93742: PUSH
93743: LD_INT 4
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 4
93753: NEG
93754: PUSH
93755: LD_INT 2
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: LD_INT 4
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 0
93776: PUSH
93777: LD_INT 5
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: LD_INT 4
93790: NEG
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: PUSH
93796: LD_INT 1
93798: PUSH
93799: LD_INT 3
93801: NEG
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 0
93809: PUSH
93810: LD_INT 3
93812: NEG
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: LD_INT 1
93820: NEG
93821: PUSH
93822: LD_INT 4
93824: NEG
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 1
93832: NEG
93833: PUSH
93834: LD_INT 5
93836: NEG
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 2
93844: PUSH
93845: LD_INT 3
93847: NEG
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 2
93855: NEG
93856: PUSH
93857: LD_INT 5
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93912: LD_ADDR_VAR 0 31
93916: PUSH
93917: LD_INT 0
93919: PUSH
93920: LD_INT 4
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 0
93929: PUSH
93930: LD_INT 3
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 1
93939: PUSH
93940: LD_INT 4
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: LD_INT 5
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 0
93959: PUSH
93960: LD_INT 5
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 1
93969: NEG
93970: PUSH
93971: LD_INT 4
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 1
93980: NEG
93981: PUSH
93982: LD_INT 3
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 2
93991: PUSH
93992: LD_INT 5
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 2
94001: NEG
94002: PUSH
94003: LD_INT 3
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 3
94012: NEG
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 3
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 2
94035: NEG
94036: PUSH
94037: LD_INT 0
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 2
94046: NEG
94047: PUSH
94048: LD_INT 1
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 3
94057: NEG
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 4
94068: NEG
94069: PUSH
94070: LD_INT 0
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 4
94079: NEG
94080: PUSH
94081: LD_INT 1
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 4
94091: NEG
94092: PUSH
94093: LD_INT 2
94095: NEG
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 2
94103: NEG
94104: PUSH
94105: LD_INT 2
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 4
94114: NEG
94115: PUSH
94116: LD_INT 4
94118: NEG
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: PUSH
94124: LD_INT 4
94126: NEG
94127: PUSH
94128: LD_INT 5
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 3
94138: NEG
94139: PUSH
94140: LD_INT 4
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: LD_INT 3
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 4
94162: NEG
94163: PUSH
94164: LD_INT 3
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 5
94174: NEG
94175: PUSH
94176: LD_INT 4
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: LD_INT 5
94186: NEG
94187: PUSH
94188: LD_INT 5
94190: NEG
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PUSH
94196: LD_INT 3
94198: NEG
94199: PUSH
94200: LD_INT 5
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 5
94210: NEG
94211: PUSH
94212: LD_INT 3
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 0
94222: PUSH
94223: LD_INT 3
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 0
94233: PUSH
94234: LD_INT 4
94236: NEG
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 1
94244: PUSH
94245: LD_INT 3
94247: NEG
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 1
94255: PUSH
94256: LD_INT 2
94258: NEG
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 0
94266: PUSH
94267: LD_INT 2
94269: NEG
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 1
94277: NEG
94278: PUSH
94279: LD_INT 3
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 1
94289: NEG
94290: PUSH
94291: LD_INT 4
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 2
94301: PUSH
94302: LD_INT 2
94304: NEG
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 2
94312: NEG
94313: PUSH
94314: LD_INT 4
94316: NEG
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 4
94324: PUSH
94325: LD_INT 0
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 4
94334: PUSH
94335: LD_INT 1
94337: NEG
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 5
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 5
94355: PUSH
94356: LD_INT 1
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 4
94365: PUSH
94366: LD_INT 1
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 3
94375: PUSH
94376: LD_INT 0
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 3
94385: PUSH
94386: LD_INT 1
94388: NEG
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: LD_INT 2
94399: NEG
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 5
94407: PUSH
94408: LD_INT 2
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94462: LD_ADDR_VAR 0 32
94466: PUSH
94467: LD_INT 4
94469: NEG
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 4
94480: NEG
94481: PUSH
94482: LD_INT 1
94484: NEG
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 3
94492: NEG
94493: PUSH
94494: LD_INT 0
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 3
94503: NEG
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 4
94514: NEG
94515: PUSH
94516: LD_INT 1
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 5
94525: NEG
94526: PUSH
94527: LD_INT 0
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: PUSH
94534: LD_INT 5
94536: NEG
94537: PUSH
94538: LD_INT 1
94540: NEG
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 5
94548: NEG
94549: PUSH
94550: LD_INT 2
94552: NEG
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 3
94560: NEG
94561: PUSH
94562: LD_INT 2
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 3
94571: NEG
94572: PUSH
94573: LD_INT 3
94575: NEG
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 3
94583: NEG
94584: PUSH
94585: LD_INT 4
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 2
94595: NEG
94596: PUSH
94597: LD_INT 3
94599: NEG
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 2
94607: NEG
94608: PUSH
94609: LD_INT 2
94611: NEG
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 3
94619: NEG
94620: PUSH
94621: LD_INT 2
94623: NEG
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 4
94631: NEG
94632: PUSH
94633: LD_INT 3
94635: NEG
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 4
94643: NEG
94644: PUSH
94645: LD_INT 4
94647: NEG
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: PUSH
94653: LD_INT 2
94655: NEG
94656: PUSH
94657: LD_INT 4
94659: NEG
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 4
94667: NEG
94668: PUSH
94669: LD_INT 2
94671: NEG
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 0
94679: PUSH
94680: LD_INT 4
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 0
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 1
94701: PUSH
94702: LD_INT 4
94704: NEG
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 1
94712: PUSH
94713: LD_INT 3
94715: NEG
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 0
94723: PUSH
94724: LD_INT 3
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 1
94734: NEG
94735: PUSH
94736: LD_INT 4
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 1
94746: NEG
94747: PUSH
94748: LD_INT 5
94750: NEG
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 2
94758: PUSH
94759: LD_INT 3
94761: NEG
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 2
94769: NEG
94770: PUSH
94771: LD_INT 5
94773: NEG
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 3
94781: PUSH
94782: LD_INT 0
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 3
94791: PUSH
94792: LD_INT 1
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 4
94802: PUSH
94803: LD_INT 0
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 3
94822: PUSH
94823: LD_INT 1
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 2
94832: PUSH
94833: LD_INT 0
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 2
94842: PUSH
94843: LD_INT 1
94845: NEG
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 2
94853: PUSH
94854: LD_INT 2
94856: NEG
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 4
94864: PUSH
94865: LD_INT 2
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 4
94874: PUSH
94875: LD_INT 4
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 4
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 5
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 5
94904: PUSH
94905: LD_INT 5
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 4
94914: PUSH
94915: LD_INT 5
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 3
94924: PUSH
94925: LD_INT 4
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: PUSH
94932: LD_INT 3
94934: PUSH
94935: LD_INT 3
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 5
94944: PUSH
94945: LD_INT 3
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 3
94954: PUSH
94955: LD_INT 5
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95009: LD_ADDR_VAR 0 33
95013: PUSH
95014: LD_INT 4
95016: NEG
95017: PUSH
95018: LD_INT 4
95020: NEG
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 4
95028: NEG
95029: PUSH
95030: LD_INT 5
95032: NEG
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 3
95040: NEG
95041: PUSH
95042: LD_INT 4
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 3
95052: NEG
95053: PUSH
95054: LD_INT 3
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 4
95064: NEG
95065: PUSH
95066: LD_INT 3
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 5
95076: NEG
95077: PUSH
95078: LD_INT 4
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 5
95088: NEG
95089: PUSH
95090: LD_INT 5
95092: NEG
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: LD_INT 3
95100: NEG
95101: PUSH
95102: LD_INT 5
95104: NEG
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: PUSH
95110: LD_INT 5
95112: NEG
95113: PUSH
95114: LD_INT 3
95116: NEG
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 0
95124: PUSH
95125: LD_INT 3
95127: NEG
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 0
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: LD_INT 3
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 1
95157: PUSH
95158: LD_INT 2
95160: NEG
95161: PUSH
95162: EMPTY
95163: LIST
95164: LIST
95165: PUSH
95166: LD_INT 0
95168: PUSH
95169: LD_INT 2
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 1
95179: NEG
95180: PUSH
95181: LD_INT 3
95183: NEG
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 1
95191: NEG
95192: PUSH
95193: LD_INT 4
95195: NEG
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 2
95203: PUSH
95204: LD_INT 2
95206: NEG
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 2
95214: NEG
95215: PUSH
95216: LD_INT 4
95218: NEG
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 4
95226: PUSH
95227: LD_INT 0
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 4
95236: PUSH
95237: LD_INT 1
95239: NEG
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 5
95247: PUSH
95248: LD_INT 0
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 5
95257: PUSH
95258: LD_INT 1
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 4
95267: PUSH
95268: LD_INT 1
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 3
95277: PUSH
95278: LD_INT 0
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 3
95287: PUSH
95288: LD_INT 1
95290: NEG
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: LD_INT 3
95298: PUSH
95299: LD_INT 2
95301: NEG
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 5
95309: PUSH
95310: LD_INT 2
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 3
95319: PUSH
95320: LD_INT 3
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: LD_INT 2
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 4
95339: PUSH
95340: LD_INT 3
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 4
95349: PUSH
95350: LD_INT 4
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 3
95359: PUSH
95360: LD_INT 4
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 2
95369: PUSH
95370: LD_INT 3
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 2
95379: PUSH
95380: LD_INT 2
95382: PUSH
95383: EMPTY
95384: LIST
95385: LIST
95386: PUSH
95387: LD_INT 4
95389: PUSH
95390: LD_INT 2
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 0
95409: PUSH
95410: LD_INT 4
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 0
95419: PUSH
95420: LD_INT 3
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 1
95429: PUSH
95430: LD_INT 4
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 1
95439: PUSH
95440: LD_INT 5
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: PUSH
95447: LD_INT 0
95449: PUSH
95450: LD_INT 5
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 1
95470: NEG
95471: PUSH
95472: LD_INT 3
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 2
95481: PUSH
95482: LD_INT 5
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: PUSH
95489: LD_INT 2
95491: NEG
95492: PUSH
95493: LD_INT 3
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95547: LD_ADDR_VAR 0 34
95551: PUSH
95552: LD_INT 0
95554: PUSH
95555: LD_INT 4
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 0
95565: PUSH
95566: LD_INT 5
95568: NEG
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PUSH
95574: LD_INT 1
95576: PUSH
95577: LD_INT 4
95579: NEG
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 1
95587: PUSH
95588: LD_INT 3
95590: NEG
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 0
95598: PUSH
95599: LD_INT 3
95601: NEG
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 1
95609: NEG
95610: PUSH
95611: LD_INT 4
95613: NEG
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 1
95621: NEG
95622: PUSH
95623: LD_INT 5
95625: NEG
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 2
95633: PUSH
95634: LD_INT 3
95636: NEG
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 2
95644: NEG
95645: PUSH
95646: LD_INT 5
95648: NEG
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 3
95656: PUSH
95657: LD_INT 0
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 3
95666: PUSH
95667: LD_INT 1
95669: NEG
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 4
95677: PUSH
95678: LD_INT 0
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 4
95687: PUSH
95688: LD_INT 1
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 3
95697: PUSH
95698: LD_INT 1
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 2
95707: PUSH
95708: LD_INT 0
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 2
95717: PUSH
95718: LD_INT 1
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 2
95728: PUSH
95729: LD_INT 2
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 4
95739: PUSH
95740: LD_INT 2
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 4
95749: PUSH
95750: LD_INT 4
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: LD_INT 3
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 5
95769: PUSH
95770: LD_INT 4
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 5
95779: PUSH
95780: LD_INT 5
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 4
95789: PUSH
95790: LD_INT 5
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 3
95799: PUSH
95800: LD_INT 4
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 3
95809: PUSH
95810: LD_INT 3
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 5
95819: PUSH
95820: LD_INT 3
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 3
95829: PUSH
95830: LD_INT 5
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: LD_INT 3
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 0
95849: PUSH
95850: LD_INT 2
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 1
95859: PUSH
95860: LD_INT 3
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 1
95869: PUSH
95870: LD_INT 4
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 0
95879: PUSH
95880: LD_INT 4
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 1
95889: NEG
95890: PUSH
95891: LD_INT 3
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: LD_INT 2
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 2
95911: PUSH
95912: LD_INT 4
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 2
95921: NEG
95922: PUSH
95923: LD_INT 2
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 4
95932: NEG
95933: PUSH
95934: LD_INT 0
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 4
95943: NEG
95944: PUSH
95945: LD_INT 1
95947: NEG
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 3
95955: NEG
95956: PUSH
95957: LD_INT 0
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 3
95966: NEG
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 4
95977: NEG
95978: PUSH
95979: LD_INT 1
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 5
95988: NEG
95989: PUSH
95990: LD_INT 0
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: PUSH
95997: LD_INT 5
95999: NEG
96000: PUSH
96001: LD_INT 1
96003: NEG
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: LD_INT 5
96011: NEG
96012: PUSH
96013: LD_INT 2
96015: NEG
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: PUSH
96021: LD_INT 3
96023: NEG
96024: PUSH
96025: LD_INT 2
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: ST_TO_ADDR
// end ; end ;
96079: GO 96082
96081: POP
// case btype of b_depot , b_warehouse :
96082: LD_VAR 0 1
96086: PUSH
96087: LD_INT 0
96089: DOUBLE
96090: EQUAL
96091: IFTRUE 96101
96093: LD_INT 1
96095: DOUBLE
96096: EQUAL
96097: IFTRUE 96101
96099: GO 96302
96101: POP
// case nation of nation_american :
96102: LD_VAR 0 5
96106: PUSH
96107: LD_INT 1
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96171
96115: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96116: LD_ADDR_VAR 0 9
96120: PUSH
96121: LD_VAR 0 11
96125: PUSH
96126: LD_VAR 0 12
96130: PUSH
96131: LD_VAR 0 13
96135: PUSH
96136: LD_VAR 0 14
96140: PUSH
96141: LD_VAR 0 15
96145: PUSH
96146: LD_VAR 0 16
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: PUSH
96159: LD_VAR 0 4
96163: PUSH
96164: LD_INT 1
96166: PLUS
96167: ARRAY
96168: ST_TO_ADDR
96169: GO 96300
96171: LD_INT 2
96173: DOUBLE
96174: EQUAL
96175: IFTRUE 96179
96177: GO 96235
96179: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96180: LD_ADDR_VAR 0 9
96184: PUSH
96185: LD_VAR 0 17
96189: PUSH
96190: LD_VAR 0 18
96194: PUSH
96195: LD_VAR 0 19
96199: PUSH
96200: LD_VAR 0 20
96204: PUSH
96205: LD_VAR 0 21
96209: PUSH
96210: LD_VAR 0 22
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: PUSH
96223: LD_VAR 0 4
96227: PUSH
96228: LD_INT 1
96230: PLUS
96231: ARRAY
96232: ST_TO_ADDR
96233: GO 96300
96235: LD_INT 3
96237: DOUBLE
96238: EQUAL
96239: IFTRUE 96243
96241: GO 96299
96243: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96244: LD_ADDR_VAR 0 9
96248: PUSH
96249: LD_VAR 0 23
96253: PUSH
96254: LD_VAR 0 24
96258: PUSH
96259: LD_VAR 0 25
96263: PUSH
96264: LD_VAR 0 26
96268: PUSH
96269: LD_VAR 0 27
96273: PUSH
96274: LD_VAR 0 28
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: PUSH
96287: LD_VAR 0 4
96291: PUSH
96292: LD_INT 1
96294: PLUS
96295: ARRAY
96296: ST_TO_ADDR
96297: GO 96300
96299: POP
96300: GO 96855
96302: LD_INT 2
96304: DOUBLE
96305: EQUAL
96306: IFTRUE 96316
96308: LD_INT 3
96310: DOUBLE
96311: EQUAL
96312: IFTRUE 96316
96314: GO 96372
96316: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96317: LD_ADDR_VAR 0 9
96321: PUSH
96322: LD_VAR 0 29
96326: PUSH
96327: LD_VAR 0 30
96331: PUSH
96332: LD_VAR 0 31
96336: PUSH
96337: LD_VAR 0 32
96341: PUSH
96342: LD_VAR 0 33
96346: PUSH
96347: LD_VAR 0 34
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: PUSH
96360: LD_VAR 0 4
96364: PUSH
96365: LD_INT 1
96367: PLUS
96368: ARRAY
96369: ST_TO_ADDR
96370: GO 96855
96372: LD_INT 16
96374: DOUBLE
96375: EQUAL
96376: IFTRUE 96434
96378: LD_INT 17
96380: DOUBLE
96381: EQUAL
96382: IFTRUE 96434
96384: LD_INT 18
96386: DOUBLE
96387: EQUAL
96388: IFTRUE 96434
96390: LD_INT 19
96392: DOUBLE
96393: EQUAL
96394: IFTRUE 96434
96396: LD_INT 22
96398: DOUBLE
96399: EQUAL
96400: IFTRUE 96434
96402: LD_INT 20
96404: DOUBLE
96405: EQUAL
96406: IFTRUE 96434
96408: LD_INT 21
96410: DOUBLE
96411: EQUAL
96412: IFTRUE 96434
96414: LD_INT 23
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96434
96420: LD_INT 24
96422: DOUBLE
96423: EQUAL
96424: IFTRUE 96434
96426: LD_INT 25
96428: DOUBLE
96429: EQUAL
96430: IFTRUE 96434
96432: GO 96490
96434: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96435: LD_ADDR_VAR 0 9
96439: PUSH
96440: LD_VAR 0 35
96444: PUSH
96445: LD_VAR 0 36
96449: PUSH
96450: LD_VAR 0 37
96454: PUSH
96455: LD_VAR 0 38
96459: PUSH
96460: LD_VAR 0 39
96464: PUSH
96465: LD_VAR 0 40
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: PUSH
96478: LD_VAR 0 4
96482: PUSH
96483: LD_INT 1
96485: PLUS
96486: ARRAY
96487: ST_TO_ADDR
96488: GO 96855
96490: LD_INT 6
96492: DOUBLE
96493: EQUAL
96494: IFTRUE 96546
96496: LD_INT 7
96498: DOUBLE
96499: EQUAL
96500: IFTRUE 96546
96502: LD_INT 8
96504: DOUBLE
96505: EQUAL
96506: IFTRUE 96546
96508: LD_INT 13
96510: DOUBLE
96511: EQUAL
96512: IFTRUE 96546
96514: LD_INT 12
96516: DOUBLE
96517: EQUAL
96518: IFTRUE 96546
96520: LD_INT 15
96522: DOUBLE
96523: EQUAL
96524: IFTRUE 96546
96526: LD_INT 11
96528: DOUBLE
96529: EQUAL
96530: IFTRUE 96546
96532: LD_INT 14
96534: DOUBLE
96535: EQUAL
96536: IFTRUE 96546
96538: LD_INT 10
96540: DOUBLE
96541: EQUAL
96542: IFTRUE 96546
96544: GO 96602
96546: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96547: LD_ADDR_VAR 0 9
96551: PUSH
96552: LD_VAR 0 41
96556: PUSH
96557: LD_VAR 0 42
96561: PUSH
96562: LD_VAR 0 43
96566: PUSH
96567: LD_VAR 0 44
96571: PUSH
96572: LD_VAR 0 45
96576: PUSH
96577: LD_VAR 0 46
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: PUSH
96590: LD_VAR 0 4
96594: PUSH
96595: LD_INT 1
96597: PLUS
96598: ARRAY
96599: ST_TO_ADDR
96600: GO 96855
96602: LD_INT 36
96604: DOUBLE
96605: EQUAL
96606: IFTRUE 96610
96608: GO 96666
96610: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96611: LD_ADDR_VAR 0 9
96615: PUSH
96616: LD_VAR 0 47
96620: PUSH
96621: LD_VAR 0 48
96625: PUSH
96626: LD_VAR 0 49
96630: PUSH
96631: LD_VAR 0 50
96635: PUSH
96636: LD_VAR 0 51
96640: PUSH
96641: LD_VAR 0 52
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: PUSH
96654: LD_VAR 0 4
96658: PUSH
96659: LD_INT 1
96661: PLUS
96662: ARRAY
96663: ST_TO_ADDR
96664: GO 96855
96666: LD_INT 4
96668: DOUBLE
96669: EQUAL
96670: IFTRUE 96692
96672: LD_INT 5
96674: DOUBLE
96675: EQUAL
96676: IFTRUE 96692
96678: LD_INT 34
96680: DOUBLE
96681: EQUAL
96682: IFTRUE 96692
96684: LD_INT 37
96686: DOUBLE
96687: EQUAL
96688: IFTRUE 96692
96690: GO 96748
96692: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96693: LD_ADDR_VAR 0 9
96697: PUSH
96698: LD_VAR 0 53
96702: PUSH
96703: LD_VAR 0 54
96707: PUSH
96708: LD_VAR 0 55
96712: PUSH
96713: LD_VAR 0 56
96717: PUSH
96718: LD_VAR 0 57
96722: PUSH
96723: LD_VAR 0 58
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: PUSH
96736: LD_VAR 0 4
96740: PUSH
96741: LD_INT 1
96743: PLUS
96744: ARRAY
96745: ST_TO_ADDR
96746: GO 96855
96748: LD_INT 31
96750: DOUBLE
96751: EQUAL
96752: IFTRUE 96798
96754: LD_INT 32
96756: DOUBLE
96757: EQUAL
96758: IFTRUE 96798
96760: LD_INT 33
96762: DOUBLE
96763: EQUAL
96764: IFTRUE 96798
96766: LD_INT 27
96768: DOUBLE
96769: EQUAL
96770: IFTRUE 96798
96772: LD_INT 26
96774: DOUBLE
96775: EQUAL
96776: IFTRUE 96798
96778: LD_INT 28
96780: DOUBLE
96781: EQUAL
96782: IFTRUE 96798
96784: LD_INT 29
96786: DOUBLE
96787: EQUAL
96788: IFTRUE 96798
96790: LD_INT 30
96792: DOUBLE
96793: EQUAL
96794: IFTRUE 96798
96796: GO 96854
96798: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96799: LD_ADDR_VAR 0 9
96803: PUSH
96804: LD_VAR 0 59
96808: PUSH
96809: LD_VAR 0 60
96813: PUSH
96814: LD_VAR 0 61
96818: PUSH
96819: LD_VAR 0 62
96823: PUSH
96824: LD_VAR 0 63
96828: PUSH
96829: LD_VAR 0 64
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: PUSH
96842: LD_VAR 0 4
96846: PUSH
96847: LD_INT 1
96849: PLUS
96850: ARRAY
96851: ST_TO_ADDR
96852: GO 96855
96854: POP
// temp_list2 = [ ] ;
96855: LD_ADDR_VAR 0 10
96859: PUSH
96860: EMPTY
96861: ST_TO_ADDR
// for i in temp_list do
96862: LD_ADDR_VAR 0 8
96866: PUSH
96867: LD_VAR 0 9
96871: PUSH
96872: FOR_IN
96873: IFFALSE 96925
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96875: LD_ADDR_VAR 0 10
96879: PUSH
96880: LD_VAR 0 10
96884: PUSH
96885: LD_VAR 0 8
96889: PUSH
96890: LD_INT 1
96892: ARRAY
96893: PUSH
96894: LD_VAR 0 2
96898: PLUS
96899: PUSH
96900: LD_VAR 0 8
96904: PUSH
96905: LD_INT 2
96907: ARRAY
96908: PUSH
96909: LD_VAR 0 3
96913: PLUS
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: EMPTY
96920: LIST
96921: ADD
96922: ST_TO_ADDR
96923: GO 96872
96925: POP
96926: POP
// result = temp_list2 ;
96927: LD_ADDR_VAR 0 7
96931: PUSH
96932: LD_VAR 0 10
96936: ST_TO_ADDR
// end ;
96937: LD_VAR 0 7
96941: RET
// export function EnemyInRange ( unit , dist ) ; begin
96942: LD_INT 0
96944: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96945: LD_ADDR_VAR 0 3
96949: PUSH
96950: LD_VAR 0 1
96954: PPUSH
96955: CALL_OW 255
96959: PPUSH
96960: LD_VAR 0 1
96964: PPUSH
96965: CALL_OW 250
96969: PPUSH
96970: LD_VAR 0 1
96974: PPUSH
96975: CALL_OW 251
96979: PPUSH
96980: LD_VAR 0 2
96984: PPUSH
96985: CALL 71046 0 4
96989: PUSH
96990: LD_INT 4
96992: ARRAY
96993: ST_TO_ADDR
// end ;
96994: LD_VAR 0 3
96998: RET
// export function PlayerSeeMe ( unit ) ; begin
96999: LD_INT 0
97001: PPUSH
// result := See ( your_side , unit ) ;
97002: LD_ADDR_VAR 0 2
97006: PUSH
97007: LD_OWVAR 2
97011: PPUSH
97012: LD_VAR 0 1
97016: PPUSH
97017: CALL_OW 292
97021: ST_TO_ADDR
// end ;
97022: LD_VAR 0 2
97026: RET
// export function ReverseDir ( unit ) ; begin
97027: LD_INT 0
97029: PPUSH
// if not unit then
97030: LD_VAR 0 1
97034: NOT
97035: IFFALSE 97039
// exit ;
97037: GO 97062
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
97039: LD_ADDR_VAR 0 2
97043: PUSH
97044: LD_VAR 0 1
97048: PPUSH
97049: CALL_OW 254
97053: PUSH
97054: LD_INT 3
97056: PLUS
97057: PUSH
97058: LD_INT 6
97060: MOD
97061: ST_TO_ADDR
// end ;
97062: LD_VAR 0 2
97066: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97067: LD_INT 0
97069: PPUSH
97070: PPUSH
97071: PPUSH
97072: PPUSH
97073: PPUSH
// if not hexes then
97074: LD_VAR 0 2
97078: NOT
97079: IFFALSE 97083
// exit ;
97081: GO 97231
// dist := 9999 ;
97083: LD_ADDR_VAR 0 5
97087: PUSH
97088: LD_INT 9999
97090: ST_TO_ADDR
// for i = 1 to hexes do
97091: LD_ADDR_VAR 0 4
97095: PUSH
97096: DOUBLE
97097: LD_INT 1
97099: DEC
97100: ST_TO_ADDR
97101: LD_VAR 0 2
97105: PUSH
97106: FOR_TO
97107: IFFALSE 97219
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97109: LD_VAR 0 1
97113: PPUSH
97114: LD_VAR 0 2
97118: PUSH
97119: LD_VAR 0 4
97123: ARRAY
97124: PUSH
97125: LD_INT 1
97127: ARRAY
97128: PPUSH
97129: LD_VAR 0 2
97133: PUSH
97134: LD_VAR 0 4
97138: ARRAY
97139: PUSH
97140: LD_INT 2
97142: ARRAY
97143: PPUSH
97144: CALL_OW 297
97148: PUSH
97149: LD_VAR 0 5
97153: LESS
97154: IFFALSE 97217
// begin hex := hexes [ i ] ;
97156: LD_ADDR_VAR 0 7
97160: PUSH
97161: LD_VAR 0 2
97165: PUSH
97166: LD_VAR 0 4
97170: ARRAY
97171: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97172: LD_ADDR_VAR 0 5
97176: PUSH
97177: LD_VAR 0 1
97181: PPUSH
97182: LD_VAR 0 2
97186: PUSH
97187: LD_VAR 0 4
97191: ARRAY
97192: PUSH
97193: LD_INT 1
97195: ARRAY
97196: PPUSH
97197: LD_VAR 0 2
97201: PUSH
97202: LD_VAR 0 4
97206: ARRAY
97207: PUSH
97208: LD_INT 2
97210: ARRAY
97211: PPUSH
97212: CALL_OW 297
97216: ST_TO_ADDR
// end ; end ;
97217: GO 97106
97219: POP
97220: POP
// result := hex ;
97221: LD_ADDR_VAR 0 3
97225: PUSH
97226: LD_VAR 0 7
97230: ST_TO_ADDR
// end ;
97231: LD_VAR 0 3
97235: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97236: LD_INT 0
97238: PPUSH
97239: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97240: LD_VAR 0 1
97244: NOT
97245: PUSH
97246: LD_VAR 0 1
97250: PUSH
97251: LD_INT 21
97253: PUSH
97254: LD_INT 2
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 23
97263: PUSH
97264: LD_INT 2
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PPUSH
97275: CALL_OW 69
97279: IN
97280: NOT
97281: OR
97282: IFFALSE 97286
// exit ;
97284: GO 97333
// for i = 1 to 3 do
97286: LD_ADDR_VAR 0 3
97290: PUSH
97291: DOUBLE
97292: LD_INT 1
97294: DEC
97295: ST_TO_ADDR
97296: LD_INT 3
97298: PUSH
97299: FOR_TO
97300: IFFALSE 97331
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97302: LD_VAR 0 1
97306: PPUSH
97307: CALL_OW 250
97311: PPUSH
97312: LD_VAR 0 1
97316: PPUSH
97317: CALL_OW 251
97321: PPUSH
97322: LD_INT 1
97324: PPUSH
97325: CALL_OW 453
97329: GO 97299
97331: POP
97332: POP
// end ;
97333: LD_VAR 0 2
97337: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97338: LD_INT 0
97340: PPUSH
97341: PPUSH
97342: PPUSH
97343: PPUSH
97344: PPUSH
97345: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97346: LD_VAR 0 1
97350: NOT
97351: PUSH
97352: LD_VAR 0 2
97356: NOT
97357: OR
97358: PUSH
97359: LD_VAR 0 1
97363: PPUSH
97364: CALL_OW 314
97368: OR
97369: IFFALSE 97373
// exit ;
97371: GO 97814
// x := GetX ( enemy_unit ) ;
97373: LD_ADDR_VAR 0 7
97377: PUSH
97378: LD_VAR 0 2
97382: PPUSH
97383: CALL_OW 250
97387: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97388: LD_ADDR_VAR 0 8
97392: PUSH
97393: LD_VAR 0 2
97397: PPUSH
97398: CALL_OW 251
97402: ST_TO_ADDR
// if not x or not y then
97403: LD_VAR 0 7
97407: NOT
97408: PUSH
97409: LD_VAR 0 8
97413: NOT
97414: OR
97415: IFFALSE 97419
// exit ;
97417: GO 97814
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97419: LD_ADDR_VAR 0 6
97423: PUSH
97424: LD_VAR 0 7
97428: PPUSH
97429: LD_INT 0
97431: PPUSH
97432: LD_INT 4
97434: PPUSH
97435: CALL_OW 272
97439: PUSH
97440: LD_VAR 0 8
97444: PPUSH
97445: LD_INT 0
97447: PPUSH
97448: LD_INT 4
97450: PPUSH
97451: CALL_OW 273
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_VAR 0 7
97464: PPUSH
97465: LD_INT 1
97467: PPUSH
97468: LD_INT 4
97470: PPUSH
97471: CALL_OW 272
97475: PUSH
97476: LD_VAR 0 8
97480: PPUSH
97481: LD_INT 1
97483: PPUSH
97484: LD_INT 4
97486: PPUSH
97487: CALL_OW 273
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_VAR 0 7
97500: PPUSH
97501: LD_INT 2
97503: PPUSH
97504: LD_INT 4
97506: PPUSH
97507: CALL_OW 272
97511: PUSH
97512: LD_VAR 0 8
97516: PPUSH
97517: LD_INT 2
97519: PPUSH
97520: LD_INT 4
97522: PPUSH
97523: CALL_OW 273
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_VAR 0 7
97536: PPUSH
97537: LD_INT 3
97539: PPUSH
97540: LD_INT 4
97542: PPUSH
97543: CALL_OW 272
97547: PUSH
97548: LD_VAR 0 8
97552: PPUSH
97553: LD_INT 3
97555: PPUSH
97556: LD_INT 4
97558: PPUSH
97559: CALL_OW 273
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_VAR 0 7
97572: PPUSH
97573: LD_INT 4
97575: PPUSH
97576: LD_INT 4
97578: PPUSH
97579: CALL_OW 272
97583: PUSH
97584: LD_VAR 0 8
97588: PPUSH
97589: LD_INT 4
97591: PPUSH
97592: LD_INT 4
97594: PPUSH
97595: CALL_OW 273
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_VAR 0 7
97608: PPUSH
97609: LD_INT 5
97611: PPUSH
97612: LD_INT 4
97614: PPUSH
97615: CALL_OW 272
97619: PUSH
97620: LD_VAR 0 8
97624: PPUSH
97625: LD_INT 5
97627: PPUSH
97628: LD_INT 4
97630: PPUSH
97631: CALL_OW 273
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: ST_TO_ADDR
// for i = tmp downto 1 do
97648: LD_ADDR_VAR 0 4
97652: PUSH
97653: DOUBLE
97654: LD_VAR 0 6
97658: INC
97659: ST_TO_ADDR
97660: LD_INT 1
97662: PUSH
97663: FOR_DOWNTO
97664: IFFALSE 97765
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97666: LD_VAR 0 6
97670: PUSH
97671: LD_VAR 0 4
97675: ARRAY
97676: PUSH
97677: LD_INT 1
97679: ARRAY
97680: PPUSH
97681: LD_VAR 0 6
97685: PUSH
97686: LD_VAR 0 4
97690: ARRAY
97691: PUSH
97692: LD_INT 2
97694: ARRAY
97695: PPUSH
97696: CALL_OW 488
97700: NOT
97701: PUSH
97702: LD_VAR 0 6
97706: PUSH
97707: LD_VAR 0 4
97711: ARRAY
97712: PUSH
97713: LD_INT 1
97715: ARRAY
97716: PPUSH
97717: LD_VAR 0 6
97721: PUSH
97722: LD_VAR 0 4
97726: ARRAY
97727: PUSH
97728: LD_INT 2
97730: ARRAY
97731: PPUSH
97732: CALL_OW 428
97736: PUSH
97737: LD_INT 0
97739: NONEQUAL
97740: OR
97741: IFFALSE 97763
// tmp := Delete ( tmp , i ) ;
97743: LD_ADDR_VAR 0 6
97747: PUSH
97748: LD_VAR 0 6
97752: PPUSH
97753: LD_VAR 0 4
97757: PPUSH
97758: CALL_OW 3
97762: ST_TO_ADDR
97763: GO 97663
97765: POP
97766: POP
// j := GetClosestHex ( unit , tmp ) ;
97767: LD_ADDR_VAR 0 5
97771: PUSH
97772: LD_VAR 0 1
97776: PPUSH
97777: LD_VAR 0 6
97781: PPUSH
97782: CALL 97067 0 2
97786: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97787: LD_VAR 0 1
97791: PPUSH
97792: LD_VAR 0 5
97796: PUSH
97797: LD_INT 1
97799: ARRAY
97800: PPUSH
97801: LD_VAR 0 5
97805: PUSH
97806: LD_INT 2
97808: ARRAY
97809: PPUSH
97810: CALL_OW 111
// end ;
97814: LD_VAR 0 3
97818: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97819: LD_INT 0
97821: PPUSH
97822: PPUSH
97823: PPUSH
// uc_side = 0 ;
97824: LD_ADDR_OWVAR 20
97828: PUSH
97829: LD_INT 0
97831: ST_TO_ADDR
// uc_nation = 0 ;
97832: LD_ADDR_OWVAR 21
97836: PUSH
97837: LD_INT 0
97839: ST_TO_ADDR
// InitHc_All ( ) ;
97840: CALL_OW 584
// InitVc ;
97844: CALL_OW 20
// if mastodonts then
97848: LD_VAR 0 6
97852: IFFALSE 97919
// for i = 1 to mastodonts do
97854: LD_ADDR_VAR 0 11
97858: PUSH
97859: DOUBLE
97860: LD_INT 1
97862: DEC
97863: ST_TO_ADDR
97864: LD_VAR 0 6
97868: PUSH
97869: FOR_TO
97870: IFFALSE 97917
// begin vc_chassis := 31 ;
97872: LD_ADDR_OWVAR 37
97876: PUSH
97877: LD_INT 31
97879: ST_TO_ADDR
// vc_control := control_rider ;
97880: LD_ADDR_OWVAR 38
97884: PUSH
97885: LD_INT 4
97887: ST_TO_ADDR
// animal := CreateVehicle ;
97888: LD_ADDR_VAR 0 12
97892: PUSH
97893: CALL_OW 45
97897: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97898: LD_VAR 0 12
97902: PPUSH
97903: LD_VAR 0 8
97907: PPUSH
97908: LD_INT 0
97910: PPUSH
97911: CALL 100107 0 3
// end ;
97915: GO 97869
97917: POP
97918: POP
// if horses then
97919: LD_VAR 0 5
97923: IFFALSE 97990
// for i = 1 to horses do
97925: LD_ADDR_VAR 0 11
97929: PUSH
97930: DOUBLE
97931: LD_INT 1
97933: DEC
97934: ST_TO_ADDR
97935: LD_VAR 0 5
97939: PUSH
97940: FOR_TO
97941: IFFALSE 97988
// begin hc_class := 21 ;
97943: LD_ADDR_OWVAR 28
97947: PUSH
97948: LD_INT 21
97950: ST_TO_ADDR
// hc_gallery :=  ;
97951: LD_ADDR_OWVAR 33
97955: PUSH
97956: LD_STRING 
97958: ST_TO_ADDR
// animal := CreateHuman ;
97959: LD_ADDR_VAR 0 12
97963: PUSH
97964: CALL_OW 44
97968: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97969: LD_VAR 0 12
97973: PPUSH
97974: LD_VAR 0 8
97978: PPUSH
97979: LD_INT 0
97981: PPUSH
97982: CALL 100107 0 3
// end ;
97986: GO 97940
97988: POP
97989: POP
// if birds then
97990: LD_VAR 0 1
97994: IFFALSE 98061
// for i = 1 to birds do
97996: LD_ADDR_VAR 0 11
98000: PUSH
98001: DOUBLE
98002: LD_INT 1
98004: DEC
98005: ST_TO_ADDR
98006: LD_VAR 0 1
98010: PUSH
98011: FOR_TO
98012: IFFALSE 98059
// begin hc_class = 18 ;
98014: LD_ADDR_OWVAR 28
98018: PUSH
98019: LD_INT 18
98021: ST_TO_ADDR
// hc_gallery =  ;
98022: LD_ADDR_OWVAR 33
98026: PUSH
98027: LD_STRING 
98029: ST_TO_ADDR
// animal := CreateHuman ;
98030: LD_ADDR_VAR 0 12
98034: PUSH
98035: CALL_OW 44
98039: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98040: LD_VAR 0 12
98044: PPUSH
98045: LD_VAR 0 8
98049: PPUSH
98050: LD_INT 0
98052: PPUSH
98053: CALL 100107 0 3
// end ;
98057: GO 98011
98059: POP
98060: POP
// if tigers then
98061: LD_VAR 0 2
98065: IFFALSE 98149
// for i = 1 to tigers do
98067: LD_ADDR_VAR 0 11
98071: PUSH
98072: DOUBLE
98073: LD_INT 1
98075: DEC
98076: ST_TO_ADDR
98077: LD_VAR 0 2
98081: PUSH
98082: FOR_TO
98083: IFFALSE 98147
// begin hc_class = class_tiger ;
98085: LD_ADDR_OWVAR 28
98089: PUSH
98090: LD_INT 14
98092: ST_TO_ADDR
// hc_gallery =  ;
98093: LD_ADDR_OWVAR 33
98097: PUSH
98098: LD_STRING 
98100: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98101: LD_ADDR_OWVAR 35
98105: PUSH
98106: LD_INT 7
98108: NEG
98109: PPUSH
98110: LD_INT 7
98112: PPUSH
98113: CALL_OW 12
98117: ST_TO_ADDR
// animal := CreateHuman ;
98118: LD_ADDR_VAR 0 12
98122: PUSH
98123: CALL_OW 44
98127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98128: LD_VAR 0 12
98132: PPUSH
98133: LD_VAR 0 8
98137: PPUSH
98138: LD_INT 0
98140: PPUSH
98141: CALL 100107 0 3
// end ;
98145: GO 98082
98147: POP
98148: POP
// if apemans then
98149: LD_VAR 0 3
98153: IFFALSE 98276
// for i = 1 to apemans do
98155: LD_ADDR_VAR 0 11
98159: PUSH
98160: DOUBLE
98161: LD_INT 1
98163: DEC
98164: ST_TO_ADDR
98165: LD_VAR 0 3
98169: PUSH
98170: FOR_TO
98171: IFFALSE 98274
// begin hc_class = class_apeman ;
98173: LD_ADDR_OWVAR 28
98177: PUSH
98178: LD_INT 12
98180: ST_TO_ADDR
// hc_gallery =  ;
98181: LD_ADDR_OWVAR 33
98185: PUSH
98186: LD_STRING 
98188: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98189: LD_ADDR_OWVAR 35
98193: PUSH
98194: LD_INT 5
98196: NEG
98197: PPUSH
98198: LD_INT 5
98200: PPUSH
98201: CALL_OW 12
98205: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98206: LD_ADDR_OWVAR 31
98210: PUSH
98211: LD_INT 1
98213: PPUSH
98214: LD_INT 3
98216: PPUSH
98217: CALL_OW 12
98221: PUSH
98222: LD_INT 1
98224: PPUSH
98225: LD_INT 3
98227: PPUSH
98228: CALL_OW 12
98232: PUSH
98233: LD_INT 0
98235: PUSH
98236: LD_INT 0
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: ST_TO_ADDR
// animal := CreateHuman ;
98245: LD_ADDR_VAR 0 12
98249: PUSH
98250: CALL_OW 44
98254: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98255: LD_VAR 0 12
98259: PPUSH
98260: LD_VAR 0 8
98264: PPUSH
98265: LD_INT 0
98267: PPUSH
98268: CALL 100107 0 3
// end ;
98272: GO 98170
98274: POP
98275: POP
// if enchidnas then
98276: LD_VAR 0 4
98280: IFFALSE 98347
// for i = 1 to enchidnas do
98282: LD_ADDR_VAR 0 11
98286: PUSH
98287: DOUBLE
98288: LD_INT 1
98290: DEC
98291: ST_TO_ADDR
98292: LD_VAR 0 4
98296: PUSH
98297: FOR_TO
98298: IFFALSE 98345
// begin hc_class = 13 ;
98300: LD_ADDR_OWVAR 28
98304: PUSH
98305: LD_INT 13
98307: ST_TO_ADDR
// hc_gallery =  ;
98308: LD_ADDR_OWVAR 33
98312: PUSH
98313: LD_STRING 
98315: ST_TO_ADDR
// animal := CreateHuman ;
98316: LD_ADDR_VAR 0 12
98320: PUSH
98321: CALL_OW 44
98325: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98326: LD_VAR 0 12
98330: PPUSH
98331: LD_VAR 0 8
98335: PPUSH
98336: LD_INT 0
98338: PPUSH
98339: CALL 100107 0 3
// end ;
98343: GO 98297
98345: POP
98346: POP
// if fishes then
98347: LD_VAR 0 7
98351: IFFALSE 98418
// for i = 1 to fishes do
98353: LD_ADDR_VAR 0 11
98357: PUSH
98358: DOUBLE
98359: LD_INT 1
98361: DEC
98362: ST_TO_ADDR
98363: LD_VAR 0 7
98367: PUSH
98368: FOR_TO
98369: IFFALSE 98416
// begin hc_class = 20 ;
98371: LD_ADDR_OWVAR 28
98375: PUSH
98376: LD_INT 20
98378: ST_TO_ADDR
// hc_gallery =  ;
98379: LD_ADDR_OWVAR 33
98383: PUSH
98384: LD_STRING 
98386: ST_TO_ADDR
// animal := CreateHuman ;
98387: LD_ADDR_VAR 0 12
98391: PUSH
98392: CALL_OW 44
98396: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98397: LD_VAR 0 12
98401: PPUSH
98402: LD_VAR 0 9
98406: PPUSH
98407: LD_INT 0
98409: PPUSH
98410: CALL 100107 0 3
// end ;
98414: GO 98368
98416: POP
98417: POP
// end ;
98418: LD_VAR 0 10
98422: RET
// export function WantHeal ( sci , unit ) ; begin
98423: LD_INT 0
98425: PPUSH
// if GetTaskList ( sci ) > 0 then
98426: LD_VAR 0 1
98430: PPUSH
98431: CALL_OW 437
98435: PUSH
98436: LD_INT 0
98438: GREATER
98439: IFFALSE 98509
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 437
98450: PUSH
98451: LD_INT 1
98453: ARRAY
98454: PUSH
98455: LD_INT 1
98457: ARRAY
98458: PUSH
98459: LD_STRING l
98461: EQUAL
98462: PUSH
98463: LD_VAR 0 1
98467: PPUSH
98468: CALL_OW 437
98472: PUSH
98473: LD_INT 1
98475: ARRAY
98476: PUSH
98477: LD_INT 4
98479: ARRAY
98480: PUSH
98481: LD_VAR 0 2
98485: EQUAL
98486: AND
98487: IFFALSE 98499
// result := true else
98489: LD_ADDR_VAR 0 3
98493: PUSH
98494: LD_INT 1
98496: ST_TO_ADDR
98497: GO 98507
// result := false ;
98499: LD_ADDR_VAR 0 3
98503: PUSH
98504: LD_INT 0
98506: ST_TO_ADDR
// end else
98507: GO 98517
// result := false ;
98509: LD_ADDR_VAR 0 3
98513: PUSH
98514: LD_INT 0
98516: ST_TO_ADDR
// end ;
98517: LD_VAR 0 3
98521: RET
// export function HealTarget ( sci ) ; begin
98522: LD_INT 0
98524: PPUSH
// if not sci then
98525: LD_VAR 0 1
98529: NOT
98530: IFFALSE 98534
// exit ;
98532: GO 98599
// result := 0 ;
98534: LD_ADDR_VAR 0 2
98538: PUSH
98539: LD_INT 0
98541: ST_TO_ADDR
// if GetTaskList ( sci ) then
98542: LD_VAR 0 1
98546: PPUSH
98547: CALL_OW 437
98551: IFFALSE 98599
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98553: LD_VAR 0 1
98557: PPUSH
98558: CALL_OW 437
98562: PUSH
98563: LD_INT 1
98565: ARRAY
98566: PUSH
98567: LD_INT 1
98569: ARRAY
98570: PUSH
98571: LD_STRING l
98573: EQUAL
98574: IFFALSE 98599
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98576: LD_ADDR_VAR 0 2
98580: PUSH
98581: LD_VAR 0 1
98585: PPUSH
98586: CALL_OW 437
98590: PUSH
98591: LD_INT 1
98593: ARRAY
98594: PUSH
98595: LD_INT 4
98597: ARRAY
98598: ST_TO_ADDR
// end ;
98599: LD_VAR 0 2
98603: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98604: LD_INT 0
98606: PPUSH
98607: PPUSH
98608: PPUSH
98609: PPUSH
// if not base_units then
98610: LD_VAR 0 1
98614: NOT
98615: IFFALSE 98619
// exit ;
98617: GO 98706
// result := false ;
98619: LD_ADDR_VAR 0 2
98623: PUSH
98624: LD_INT 0
98626: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98627: LD_ADDR_VAR 0 5
98631: PUSH
98632: LD_VAR 0 1
98636: PPUSH
98637: LD_INT 21
98639: PUSH
98640: LD_INT 3
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PPUSH
98647: CALL_OW 72
98651: ST_TO_ADDR
// if not tmp then
98652: LD_VAR 0 5
98656: NOT
98657: IFFALSE 98661
// exit ;
98659: GO 98706
// for i in tmp do
98661: LD_ADDR_VAR 0 3
98665: PUSH
98666: LD_VAR 0 5
98670: PUSH
98671: FOR_IN
98672: IFFALSE 98704
// begin result := EnemyInRange ( i , 22 ) ;
98674: LD_ADDR_VAR 0 2
98678: PUSH
98679: LD_VAR 0 3
98683: PPUSH
98684: LD_INT 22
98686: PPUSH
98687: CALL 96942 0 2
98691: ST_TO_ADDR
// if result then
98692: LD_VAR 0 2
98696: IFFALSE 98702
// exit ;
98698: POP
98699: POP
98700: GO 98706
// end ;
98702: GO 98671
98704: POP
98705: POP
// end ;
98706: LD_VAR 0 2
98710: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98711: LD_INT 0
98713: PPUSH
98714: PPUSH
// if not units then
98715: LD_VAR 0 1
98719: NOT
98720: IFFALSE 98724
// exit ;
98722: GO 98794
// result := [ ] ;
98724: LD_ADDR_VAR 0 3
98728: PUSH
98729: EMPTY
98730: ST_TO_ADDR
// for i in units do
98731: LD_ADDR_VAR 0 4
98735: PUSH
98736: LD_VAR 0 1
98740: PUSH
98741: FOR_IN
98742: IFFALSE 98792
// if GetTag ( i ) = tag then
98744: LD_VAR 0 4
98748: PPUSH
98749: CALL_OW 110
98753: PUSH
98754: LD_VAR 0 2
98758: EQUAL
98759: IFFALSE 98790
// result := Insert ( result , result + 1 , i ) ;
98761: LD_ADDR_VAR 0 3
98765: PUSH
98766: LD_VAR 0 3
98770: PPUSH
98771: LD_VAR 0 3
98775: PUSH
98776: LD_INT 1
98778: PLUS
98779: PPUSH
98780: LD_VAR 0 4
98784: PPUSH
98785: CALL_OW 2
98789: ST_TO_ADDR
98790: GO 98741
98792: POP
98793: POP
// end ;
98794: LD_VAR 0 3
98798: RET
// export function IsDriver ( un ) ; begin
98799: LD_INT 0
98801: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98802: LD_ADDR_VAR 0 2
98806: PUSH
98807: LD_VAR 0 1
98811: PUSH
98812: LD_INT 55
98814: PUSH
98815: EMPTY
98816: LIST
98817: PPUSH
98818: CALL_OW 69
98822: IN
98823: ST_TO_ADDR
// end ;
98824: LD_VAR 0 2
98828: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98829: LD_INT 0
98831: PPUSH
98832: PPUSH
// list := [ ] ;
98833: LD_ADDR_VAR 0 5
98837: PUSH
98838: EMPTY
98839: ST_TO_ADDR
// case d of 0 :
98840: LD_VAR 0 3
98844: PUSH
98845: LD_INT 0
98847: DOUBLE
98848: EQUAL
98849: IFTRUE 98853
98851: GO 98986
98853: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98854: LD_ADDR_VAR 0 5
98858: PUSH
98859: LD_VAR 0 1
98863: PUSH
98864: LD_INT 4
98866: MINUS
98867: PUSH
98868: LD_VAR 0 2
98872: PUSH
98873: LD_INT 4
98875: MINUS
98876: PUSH
98877: LD_INT 2
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: LIST
98884: PUSH
98885: LD_VAR 0 1
98889: PUSH
98890: LD_INT 3
98892: MINUS
98893: PUSH
98894: LD_VAR 0 2
98898: PUSH
98899: LD_INT 1
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: LIST
98906: PUSH
98907: LD_VAR 0 1
98911: PUSH
98912: LD_INT 4
98914: PLUS
98915: PUSH
98916: LD_VAR 0 2
98920: PUSH
98921: LD_INT 4
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: LIST
98928: PUSH
98929: LD_VAR 0 1
98933: PUSH
98934: LD_INT 3
98936: PLUS
98937: PUSH
98938: LD_VAR 0 2
98942: PUSH
98943: LD_INT 3
98945: PLUS
98946: PUSH
98947: LD_INT 5
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: LIST
98954: PUSH
98955: LD_VAR 0 1
98959: PUSH
98960: LD_VAR 0 2
98964: PUSH
98965: LD_INT 4
98967: PLUS
98968: PUSH
98969: LD_INT 0
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: LIST
98976: PUSH
98977: EMPTY
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: ST_TO_ADDR
// end ; 1 :
98984: GO 99684
98986: LD_INT 1
98988: DOUBLE
98989: EQUAL
98990: IFTRUE 98994
98992: GO 99127
98994: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98995: LD_ADDR_VAR 0 5
98999: PUSH
99000: LD_VAR 0 1
99004: PUSH
99005: LD_VAR 0 2
99009: PUSH
99010: LD_INT 4
99012: MINUS
99013: PUSH
99014: LD_INT 3
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: LIST
99021: PUSH
99022: LD_VAR 0 1
99026: PUSH
99027: LD_INT 3
99029: MINUS
99030: PUSH
99031: LD_VAR 0 2
99035: PUSH
99036: LD_INT 3
99038: MINUS
99039: PUSH
99040: LD_INT 2
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: PUSH
99048: LD_VAR 0 1
99052: PUSH
99053: LD_INT 4
99055: MINUS
99056: PUSH
99057: LD_VAR 0 2
99061: PUSH
99062: LD_INT 1
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: LIST
99069: PUSH
99070: LD_VAR 0 1
99074: PUSH
99075: LD_VAR 0 2
99079: PUSH
99080: LD_INT 3
99082: PLUS
99083: PUSH
99084: LD_INT 0
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: LIST
99091: PUSH
99092: LD_VAR 0 1
99096: PUSH
99097: LD_INT 4
99099: PLUS
99100: PUSH
99101: LD_VAR 0 2
99105: PUSH
99106: LD_INT 4
99108: PLUS
99109: PUSH
99110: LD_INT 5
99112: PUSH
99113: EMPTY
99114: LIST
99115: LIST
99116: LIST
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: ST_TO_ADDR
// end ; 2 :
99125: GO 99684
99127: LD_INT 2
99129: DOUBLE
99130: EQUAL
99131: IFTRUE 99135
99133: GO 99264
99135: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99136: LD_ADDR_VAR 0 5
99140: PUSH
99141: LD_VAR 0 1
99145: PUSH
99146: LD_VAR 0 2
99150: PUSH
99151: LD_INT 3
99153: MINUS
99154: PUSH
99155: LD_INT 3
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: LIST
99162: PUSH
99163: LD_VAR 0 1
99167: PUSH
99168: LD_INT 4
99170: PLUS
99171: PUSH
99172: LD_VAR 0 2
99176: PUSH
99177: LD_INT 4
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: LIST
99184: PUSH
99185: LD_VAR 0 1
99189: PUSH
99190: LD_VAR 0 2
99194: PUSH
99195: LD_INT 4
99197: PLUS
99198: PUSH
99199: LD_INT 0
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: LD_VAR 0 1
99211: PUSH
99212: LD_INT 3
99214: MINUS
99215: PUSH
99216: LD_VAR 0 2
99220: PUSH
99221: LD_INT 1
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: LIST
99228: PUSH
99229: LD_VAR 0 1
99233: PUSH
99234: LD_INT 4
99236: MINUS
99237: PUSH
99238: LD_VAR 0 2
99242: PUSH
99243: LD_INT 4
99245: MINUS
99246: PUSH
99247: LD_INT 2
99249: PUSH
99250: EMPTY
99251: LIST
99252: LIST
99253: LIST
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: ST_TO_ADDR
// end ; 3 :
99262: GO 99684
99264: LD_INT 3
99266: DOUBLE
99267: EQUAL
99268: IFTRUE 99272
99270: GO 99405
99272: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99273: LD_ADDR_VAR 0 5
99277: PUSH
99278: LD_VAR 0 1
99282: PUSH
99283: LD_INT 3
99285: PLUS
99286: PUSH
99287: LD_VAR 0 2
99291: PUSH
99292: LD_INT 4
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: LIST
99299: PUSH
99300: LD_VAR 0 1
99304: PUSH
99305: LD_INT 4
99307: PLUS
99308: PUSH
99309: LD_VAR 0 2
99313: PUSH
99314: LD_INT 4
99316: PLUS
99317: PUSH
99318: LD_INT 5
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: LIST
99325: PUSH
99326: LD_VAR 0 1
99330: PUSH
99331: LD_INT 4
99333: MINUS
99334: PUSH
99335: LD_VAR 0 2
99339: PUSH
99340: LD_INT 1
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: LIST
99347: PUSH
99348: LD_VAR 0 1
99352: PUSH
99353: LD_VAR 0 2
99357: PUSH
99358: LD_INT 4
99360: MINUS
99361: PUSH
99362: LD_INT 3
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: LIST
99369: PUSH
99370: LD_VAR 0 1
99374: PUSH
99375: LD_INT 3
99377: MINUS
99378: PUSH
99379: LD_VAR 0 2
99383: PUSH
99384: LD_INT 3
99386: MINUS
99387: PUSH
99388: LD_INT 2
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: LIST
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: ST_TO_ADDR
// end ; 4 :
99403: GO 99684
99405: LD_INT 4
99407: DOUBLE
99408: EQUAL
99409: IFTRUE 99413
99411: GO 99546
99413: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99414: LD_ADDR_VAR 0 5
99418: PUSH
99419: LD_VAR 0 1
99423: PUSH
99424: LD_VAR 0 2
99428: PUSH
99429: LD_INT 4
99431: PLUS
99432: PUSH
99433: LD_INT 0
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: LIST
99440: PUSH
99441: LD_VAR 0 1
99445: PUSH
99446: LD_INT 3
99448: PLUS
99449: PUSH
99450: LD_VAR 0 2
99454: PUSH
99455: LD_INT 3
99457: PLUS
99458: PUSH
99459: LD_INT 5
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: LIST
99466: PUSH
99467: LD_VAR 0 1
99471: PUSH
99472: LD_INT 4
99474: PLUS
99475: PUSH
99476: LD_VAR 0 2
99480: PUSH
99481: LD_INT 4
99483: PUSH
99484: EMPTY
99485: LIST
99486: LIST
99487: LIST
99488: PUSH
99489: LD_VAR 0 1
99493: PUSH
99494: LD_VAR 0 2
99498: PUSH
99499: LD_INT 3
99501: MINUS
99502: PUSH
99503: LD_INT 3
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: LIST
99510: PUSH
99511: LD_VAR 0 1
99515: PUSH
99516: LD_INT 4
99518: MINUS
99519: PUSH
99520: LD_VAR 0 2
99524: PUSH
99525: LD_INT 4
99527: MINUS
99528: PUSH
99529: LD_INT 2
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: LIST
99536: PUSH
99537: EMPTY
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: ST_TO_ADDR
// end ; 5 :
99544: GO 99684
99546: LD_INT 5
99548: DOUBLE
99549: EQUAL
99550: IFTRUE 99554
99552: GO 99683
99554: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99555: LD_ADDR_VAR 0 5
99559: PUSH
99560: LD_VAR 0 1
99564: PUSH
99565: LD_INT 4
99567: MINUS
99568: PUSH
99569: LD_VAR 0 2
99573: PUSH
99574: LD_INT 1
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: PUSH
99582: LD_VAR 0 1
99586: PUSH
99587: LD_VAR 0 2
99591: PUSH
99592: LD_INT 4
99594: MINUS
99595: PUSH
99596: LD_INT 3
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: LIST
99603: PUSH
99604: LD_VAR 0 1
99608: PUSH
99609: LD_INT 4
99611: PLUS
99612: PUSH
99613: LD_VAR 0 2
99617: PUSH
99618: LD_INT 4
99620: PLUS
99621: PUSH
99622: LD_INT 5
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: LIST
99629: PUSH
99630: LD_VAR 0 1
99634: PUSH
99635: LD_INT 3
99637: PLUS
99638: PUSH
99639: LD_VAR 0 2
99643: PUSH
99644: LD_INT 4
99646: PUSH
99647: EMPTY
99648: LIST
99649: LIST
99650: LIST
99651: PUSH
99652: LD_VAR 0 1
99656: PUSH
99657: LD_VAR 0 2
99661: PUSH
99662: LD_INT 3
99664: PLUS
99665: PUSH
99666: LD_INT 0
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: LIST
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: ST_TO_ADDR
// end ; end ;
99681: GO 99684
99683: POP
// result := list ;
99684: LD_ADDR_VAR 0 4
99688: PUSH
99689: LD_VAR 0 5
99693: ST_TO_ADDR
// end ;
99694: LD_VAR 0 4
99698: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99699: LD_INT 0
99701: PPUSH
99702: PPUSH
99703: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99704: LD_VAR 0 1
99708: NOT
99709: PUSH
99710: LD_VAR 0 2
99714: PUSH
99715: LD_INT 1
99717: PUSH
99718: LD_INT 2
99720: PUSH
99721: LD_INT 3
99723: PUSH
99724: LD_INT 4
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: IN
99733: NOT
99734: OR
99735: IFFALSE 99739
// exit ;
99737: GO 99831
// tmp := [ ] ;
99739: LD_ADDR_VAR 0 5
99743: PUSH
99744: EMPTY
99745: ST_TO_ADDR
// for i in units do
99746: LD_ADDR_VAR 0 4
99750: PUSH
99751: LD_VAR 0 1
99755: PUSH
99756: FOR_IN
99757: IFFALSE 99800
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99759: LD_ADDR_VAR 0 5
99763: PUSH
99764: LD_VAR 0 5
99768: PPUSH
99769: LD_VAR 0 5
99773: PUSH
99774: LD_INT 1
99776: PLUS
99777: PPUSH
99778: LD_VAR 0 4
99782: PPUSH
99783: LD_VAR 0 2
99787: PPUSH
99788: CALL_OW 259
99792: PPUSH
99793: CALL_OW 2
99797: ST_TO_ADDR
99798: GO 99756
99800: POP
99801: POP
// if not tmp then
99802: LD_VAR 0 5
99806: NOT
99807: IFFALSE 99811
// exit ;
99809: GO 99831
// result := SortListByListDesc ( units , tmp ) ;
99811: LD_ADDR_VAR 0 3
99815: PUSH
99816: LD_VAR 0 1
99820: PPUSH
99821: LD_VAR 0 5
99825: PPUSH
99826: CALL_OW 77
99830: ST_TO_ADDR
// end ;
99831: LD_VAR 0 3
99835: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99836: LD_INT 0
99838: PPUSH
99839: PPUSH
99840: PPUSH
// result := false ;
99841: LD_ADDR_VAR 0 3
99845: PUSH
99846: LD_INT 0
99848: ST_TO_ADDR
// x := GetX ( building ) ;
99849: LD_ADDR_VAR 0 4
99853: PUSH
99854: LD_VAR 0 2
99858: PPUSH
99859: CALL_OW 250
99863: ST_TO_ADDR
// y := GetY ( building ) ;
99864: LD_ADDR_VAR 0 5
99868: PUSH
99869: LD_VAR 0 2
99873: PPUSH
99874: CALL_OW 251
99878: ST_TO_ADDR
// if not building or not x or not y then
99879: LD_VAR 0 2
99883: NOT
99884: PUSH
99885: LD_VAR 0 4
99889: NOT
99890: OR
99891: PUSH
99892: LD_VAR 0 5
99896: NOT
99897: OR
99898: IFFALSE 99902
// exit ;
99900: GO 99994
// if GetTaskList ( unit ) then
99902: LD_VAR 0 1
99906: PPUSH
99907: CALL_OW 437
99911: IFFALSE 99994
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99913: LD_STRING e
99915: PUSH
99916: LD_VAR 0 1
99920: PPUSH
99921: CALL_OW 437
99925: PUSH
99926: LD_INT 1
99928: ARRAY
99929: PUSH
99930: LD_INT 1
99932: ARRAY
99933: EQUAL
99934: PUSH
99935: LD_VAR 0 4
99939: PUSH
99940: LD_VAR 0 1
99944: PPUSH
99945: CALL_OW 437
99949: PUSH
99950: LD_INT 1
99952: ARRAY
99953: PUSH
99954: LD_INT 2
99956: ARRAY
99957: EQUAL
99958: AND
99959: PUSH
99960: LD_VAR 0 5
99964: PUSH
99965: LD_VAR 0 1
99969: PPUSH
99970: CALL_OW 437
99974: PUSH
99975: LD_INT 1
99977: ARRAY
99978: PUSH
99979: LD_INT 3
99981: ARRAY
99982: EQUAL
99983: AND
99984: IFFALSE 99994
// result := true end ;
99986: LD_ADDR_VAR 0 3
99990: PUSH
99991: LD_INT 1
99993: ST_TO_ADDR
// end ;
99994: LD_VAR 0 3
99998: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99999: LD_INT 0
100001: PPUSH
// result := false ;
100002: LD_ADDR_VAR 0 4
100006: PUSH
100007: LD_INT 0
100009: ST_TO_ADDR
// if GetTaskList ( unit ) then
100010: LD_VAR 0 1
100014: PPUSH
100015: CALL_OW 437
100019: IFFALSE 100102
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100021: LD_STRING M
100023: PUSH
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 437
100033: PUSH
100034: LD_INT 1
100036: ARRAY
100037: PUSH
100038: LD_INT 1
100040: ARRAY
100041: EQUAL
100042: PUSH
100043: LD_VAR 0 2
100047: PUSH
100048: LD_VAR 0 1
100052: PPUSH
100053: CALL_OW 437
100057: PUSH
100058: LD_INT 1
100060: ARRAY
100061: PUSH
100062: LD_INT 2
100064: ARRAY
100065: EQUAL
100066: AND
100067: PUSH
100068: LD_VAR 0 3
100072: PUSH
100073: LD_VAR 0 1
100077: PPUSH
100078: CALL_OW 437
100082: PUSH
100083: LD_INT 1
100085: ARRAY
100086: PUSH
100087: LD_INT 3
100089: ARRAY
100090: EQUAL
100091: AND
100092: IFFALSE 100102
// result := true ;
100094: LD_ADDR_VAR 0 4
100098: PUSH
100099: LD_INT 1
100101: ST_TO_ADDR
// end ; end ;
100102: LD_VAR 0 4
100106: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100107: LD_INT 0
100109: PPUSH
100110: PPUSH
100111: PPUSH
100112: PPUSH
// if not unit or not area then
100113: LD_VAR 0 1
100117: NOT
100118: PUSH
100119: LD_VAR 0 2
100123: NOT
100124: OR
100125: IFFALSE 100129
// exit ;
100127: GO 100293
// tmp := AreaToList ( area , i ) ;
100129: LD_ADDR_VAR 0 6
100133: PUSH
100134: LD_VAR 0 2
100138: PPUSH
100139: LD_VAR 0 5
100143: PPUSH
100144: CALL_OW 517
100148: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100149: LD_ADDR_VAR 0 5
100153: PUSH
100154: DOUBLE
100155: LD_INT 1
100157: DEC
100158: ST_TO_ADDR
100159: LD_VAR 0 6
100163: PUSH
100164: LD_INT 1
100166: ARRAY
100167: PUSH
100168: FOR_TO
100169: IFFALSE 100291
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100171: LD_ADDR_VAR 0 7
100175: PUSH
100176: LD_VAR 0 6
100180: PUSH
100181: LD_INT 1
100183: ARRAY
100184: PUSH
100185: LD_VAR 0 5
100189: ARRAY
100190: PUSH
100191: LD_VAR 0 6
100195: PUSH
100196: LD_INT 2
100198: ARRAY
100199: PUSH
100200: LD_VAR 0 5
100204: ARRAY
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100210: LD_VAR 0 7
100214: PUSH
100215: LD_INT 1
100217: ARRAY
100218: PPUSH
100219: LD_VAR 0 7
100223: PUSH
100224: LD_INT 2
100226: ARRAY
100227: PPUSH
100228: CALL_OW 428
100232: PUSH
100233: LD_INT 0
100235: EQUAL
100236: IFFALSE 100289
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100238: LD_VAR 0 1
100242: PPUSH
100243: LD_VAR 0 7
100247: PUSH
100248: LD_INT 1
100250: ARRAY
100251: PPUSH
100252: LD_VAR 0 7
100256: PUSH
100257: LD_INT 2
100259: ARRAY
100260: PPUSH
100261: LD_VAR 0 3
100265: PPUSH
100266: CALL_OW 48
// result := IsPlaced ( unit ) ;
100270: LD_ADDR_VAR 0 4
100274: PUSH
100275: LD_VAR 0 1
100279: PPUSH
100280: CALL_OW 305
100284: ST_TO_ADDR
// exit ;
100285: POP
100286: POP
100287: GO 100293
// end ; end ;
100289: GO 100168
100291: POP
100292: POP
// end ;
100293: LD_VAR 0 4
100297: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100298: LD_INT 0
100300: PPUSH
100301: PPUSH
100302: PPUSH
// if not side or side > 8 then
100303: LD_VAR 0 1
100307: NOT
100308: PUSH
100309: LD_VAR 0 1
100313: PUSH
100314: LD_INT 8
100316: GREATER
100317: OR
100318: IFFALSE 100322
// exit ;
100320: GO 100509
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100322: LD_ADDR_VAR 0 4
100326: PUSH
100327: LD_INT 22
100329: PUSH
100330: LD_VAR 0 1
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: LD_INT 21
100341: PUSH
100342: LD_INT 3
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PPUSH
100353: CALL_OW 69
100357: ST_TO_ADDR
// if not tmp then
100358: LD_VAR 0 4
100362: NOT
100363: IFFALSE 100367
// exit ;
100365: GO 100509
// enable_addtolog := true ;
100367: LD_ADDR_OWVAR 81
100371: PUSH
100372: LD_INT 1
100374: ST_TO_ADDR
// AddToLog ( [ ) ;
100375: LD_STRING [
100377: PPUSH
100378: CALL_OW 561
// for i in tmp do
100382: LD_ADDR_VAR 0 3
100386: PUSH
100387: LD_VAR 0 4
100391: PUSH
100392: FOR_IN
100393: IFFALSE 100500
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100395: LD_STRING [
100397: PUSH
100398: LD_VAR 0 3
100402: PPUSH
100403: CALL_OW 266
100407: STR
100408: PUSH
100409: LD_STRING , 
100411: STR
100412: PUSH
100413: LD_VAR 0 3
100417: PPUSH
100418: CALL_OW 250
100422: STR
100423: PUSH
100424: LD_STRING , 
100426: STR
100427: PUSH
100428: LD_VAR 0 3
100432: PPUSH
100433: CALL_OW 251
100437: STR
100438: PUSH
100439: LD_STRING , 
100441: STR
100442: PUSH
100443: LD_VAR 0 3
100447: PPUSH
100448: CALL_OW 254
100452: STR
100453: PUSH
100454: LD_STRING , 
100456: STR
100457: PUSH
100458: LD_VAR 0 3
100462: PPUSH
100463: LD_INT 1
100465: PPUSH
100466: CALL_OW 268
100470: STR
100471: PUSH
100472: LD_STRING , 
100474: STR
100475: PUSH
100476: LD_VAR 0 3
100480: PPUSH
100481: LD_INT 2
100483: PPUSH
100484: CALL_OW 268
100488: STR
100489: PUSH
100490: LD_STRING ],
100492: STR
100493: PPUSH
100494: CALL_OW 561
// end ;
100498: GO 100392
100500: POP
100501: POP
// AddToLog ( ]; ) ;
100502: LD_STRING ];
100504: PPUSH
100505: CALL_OW 561
// end ;
100509: LD_VAR 0 2
100513: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100514: LD_INT 0
100516: PPUSH
100517: PPUSH
100518: PPUSH
100519: PPUSH
100520: PPUSH
// if not area or not rate or not max then
100521: LD_VAR 0 1
100525: NOT
100526: PUSH
100527: LD_VAR 0 2
100531: NOT
100532: OR
100533: PUSH
100534: LD_VAR 0 4
100538: NOT
100539: OR
100540: IFFALSE 100544
// exit ;
100542: GO 100736
// while 1 do
100544: LD_INT 1
100546: IFFALSE 100736
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100548: LD_ADDR_VAR 0 9
100552: PUSH
100553: LD_VAR 0 1
100557: PPUSH
100558: LD_INT 1
100560: PPUSH
100561: CALL_OW 287
100565: PUSH
100566: LD_INT 10
100568: MUL
100569: ST_TO_ADDR
// r := rate / 10 ;
100570: LD_ADDR_VAR 0 7
100574: PUSH
100575: LD_VAR 0 2
100579: PUSH
100580: LD_INT 10
100582: DIVREAL
100583: ST_TO_ADDR
// time := 1 1$00 ;
100584: LD_ADDR_VAR 0 8
100588: PUSH
100589: LD_INT 2100
100591: ST_TO_ADDR
// if amount < min then
100592: LD_VAR 0 9
100596: PUSH
100597: LD_VAR 0 3
100601: LESS
100602: IFFALSE 100620
// r := r * 2 else
100604: LD_ADDR_VAR 0 7
100608: PUSH
100609: LD_VAR 0 7
100613: PUSH
100614: LD_INT 2
100616: MUL
100617: ST_TO_ADDR
100618: GO 100646
// if amount > max then
100620: LD_VAR 0 9
100624: PUSH
100625: LD_VAR 0 4
100629: GREATER
100630: IFFALSE 100646
// r := r / 2 ;
100632: LD_ADDR_VAR 0 7
100636: PUSH
100637: LD_VAR 0 7
100641: PUSH
100642: LD_INT 2
100644: DIVREAL
100645: ST_TO_ADDR
// time := time / r ;
100646: LD_ADDR_VAR 0 8
100650: PUSH
100651: LD_VAR 0 8
100655: PUSH
100656: LD_VAR 0 7
100660: DIVREAL
100661: ST_TO_ADDR
// if time < 0 then
100662: LD_VAR 0 8
100666: PUSH
100667: LD_INT 0
100669: LESS
100670: IFFALSE 100687
// time := time * - 1 ;
100672: LD_ADDR_VAR 0 8
100676: PUSH
100677: LD_VAR 0 8
100681: PUSH
100682: LD_INT 1
100684: NEG
100685: MUL
100686: ST_TO_ADDR
// wait ( time ) ;
100687: LD_VAR 0 8
100691: PPUSH
100692: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100696: LD_INT 35
100698: PPUSH
100699: LD_INT 875
100701: PPUSH
100702: CALL_OW 12
100706: PPUSH
100707: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100711: LD_INT 1
100713: PPUSH
100714: LD_INT 5
100716: PPUSH
100717: CALL_OW 12
100721: PPUSH
100722: LD_VAR 0 1
100726: PPUSH
100727: LD_INT 1
100729: PPUSH
100730: CALL_OW 55
// end ;
100734: GO 100544
// end ;
100736: LD_VAR 0 5
100740: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100741: LD_INT 0
100743: PPUSH
100744: PPUSH
100745: PPUSH
100746: PPUSH
100747: PPUSH
100748: PPUSH
100749: PPUSH
100750: PPUSH
// if not turrets or not factories then
100751: LD_VAR 0 1
100755: NOT
100756: PUSH
100757: LD_VAR 0 2
100761: NOT
100762: OR
100763: IFFALSE 100767
// exit ;
100765: GO 101074
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100767: LD_ADDR_VAR 0 10
100771: PUSH
100772: LD_INT 5
100774: PUSH
100775: LD_INT 6
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 2
100784: PUSH
100785: LD_INT 4
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: LD_INT 3
100794: PUSH
100795: LD_INT 5
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 24
100809: PUSH
100810: LD_INT 25
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: PUSH
100817: LD_INT 23
100819: PUSH
100820: LD_INT 27
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: PUSH
100831: LD_INT 42
100833: PUSH
100834: LD_INT 43
100836: PUSH
100837: EMPTY
100838: LIST
100839: LIST
100840: PUSH
100841: LD_INT 44
100843: PUSH
100844: LD_INT 46
100846: PUSH
100847: EMPTY
100848: LIST
100849: LIST
100850: PUSH
100851: LD_INT 45
100853: PUSH
100854: LD_INT 47
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: LIST
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: LIST
100870: ST_TO_ADDR
// result := [ ] ;
100871: LD_ADDR_VAR 0 3
100875: PUSH
100876: EMPTY
100877: ST_TO_ADDR
// for i in turrets do
100878: LD_ADDR_VAR 0 4
100882: PUSH
100883: LD_VAR 0 1
100887: PUSH
100888: FOR_IN
100889: IFFALSE 101072
// begin nat := GetNation ( i ) ;
100891: LD_ADDR_VAR 0 7
100895: PUSH
100896: LD_VAR 0 4
100900: PPUSH
100901: CALL_OW 248
100905: ST_TO_ADDR
// weapon := 0 ;
100906: LD_ADDR_VAR 0 8
100910: PUSH
100911: LD_INT 0
100913: ST_TO_ADDR
// if not nat then
100914: LD_VAR 0 7
100918: NOT
100919: IFFALSE 100923
// continue ;
100921: GO 100888
// for j in list [ nat ] do
100923: LD_ADDR_VAR 0 5
100927: PUSH
100928: LD_VAR 0 10
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PUSH
100939: FOR_IN
100940: IFFALSE 100981
// if GetBWeapon ( i ) = j [ 1 ] then
100942: LD_VAR 0 4
100946: PPUSH
100947: CALL_OW 269
100951: PUSH
100952: LD_VAR 0 5
100956: PUSH
100957: LD_INT 1
100959: ARRAY
100960: EQUAL
100961: IFFALSE 100979
// begin weapon := j [ 2 ] ;
100963: LD_ADDR_VAR 0 8
100967: PUSH
100968: LD_VAR 0 5
100972: PUSH
100973: LD_INT 2
100975: ARRAY
100976: ST_TO_ADDR
// break ;
100977: GO 100981
// end ;
100979: GO 100939
100981: POP
100982: POP
// if not weapon then
100983: LD_VAR 0 8
100987: NOT
100988: IFFALSE 100992
// continue ;
100990: GO 100888
// for k in factories do
100992: LD_ADDR_VAR 0 6
100996: PUSH
100997: LD_VAR 0 2
101001: PUSH
101002: FOR_IN
101003: IFFALSE 101068
// begin weapons := AvailableWeaponList ( k ) ;
101005: LD_ADDR_VAR 0 9
101009: PUSH
101010: LD_VAR 0 6
101014: PPUSH
101015: CALL_OW 478
101019: ST_TO_ADDR
// if not weapons then
101020: LD_VAR 0 9
101024: NOT
101025: IFFALSE 101029
// continue ;
101027: GO 101002
// if weapon in weapons then
101029: LD_VAR 0 8
101033: PUSH
101034: LD_VAR 0 9
101038: IN
101039: IFFALSE 101066
// begin result := [ i , weapon ] ;
101041: LD_ADDR_VAR 0 3
101045: PUSH
101046: LD_VAR 0 4
101050: PUSH
101051: LD_VAR 0 8
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: ST_TO_ADDR
// exit ;
101060: POP
101061: POP
101062: POP
101063: POP
101064: GO 101074
// end ; end ;
101066: GO 101002
101068: POP
101069: POP
// end ;
101070: GO 100888
101072: POP
101073: POP
// end ;
101074: LD_VAR 0 3
101078: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101079: LD_INT 0
101081: PPUSH
// if not side or side > 8 then
101082: LD_VAR 0 3
101086: NOT
101087: PUSH
101088: LD_VAR 0 3
101092: PUSH
101093: LD_INT 8
101095: GREATER
101096: OR
101097: IFFALSE 101101
// exit ;
101099: GO 101160
// if not range then
101101: LD_VAR 0 4
101105: NOT
101106: IFFALSE 101117
// range := - 12 ;
101108: LD_ADDR_VAR 0 4
101112: PUSH
101113: LD_INT 12
101115: NEG
101116: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101117: LD_VAR 0 1
101121: PPUSH
101122: LD_VAR 0 2
101126: PPUSH
101127: LD_VAR 0 3
101131: PPUSH
101132: LD_VAR 0 4
101136: PPUSH
101137: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101141: LD_VAR 0 1
101145: PPUSH
101146: LD_VAR 0 2
101150: PPUSH
101151: LD_VAR 0 3
101155: PPUSH
101156: CALL_OW 331
// end ;
101160: LD_VAR 0 5
101164: RET
// export function Video ( mode ) ; begin
101165: LD_INT 0
101167: PPUSH
// ingame_video = mode ;
101168: LD_ADDR_OWVAR 52
101172: PUSH
101173: LD_VAR 0 1
101177: ST_TO_ADDR
// interface_hidden = mode ;
101178: LD_ADDR_OWVAR 54
101182: PUSH
101183: LD_VAR 0 1
101187: ST_TO_ADDR
// end ;
101188: LD_VAR 0 2
101192: RET
// export function Join ( array , element ) ; begin
101193: LD_INT 0
101195: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101196: LD_ADDR_VAR 0 3
101200: PUSH
101201: LD_VAR 0 1
101205: PPUSH
101206: LD_VAR 0 1
101210: PUSH
101211: LD_INT 1
101213: PLUS
101214: PPUSH
101215: LD_VAR 0 2
101219: PPUSH
101220: CALL_OW 1
101224: ST_TO_ADDR
// end ;
101225: LD_VAR 0 3
101229: RET
// export function JoinUnion ( array , element ) ; begin
101230: LD_INT 0
101232: PPUSH
// result := array union element ;
101233: LD_ADDR_VAR 0 3
101237: PUSH
101238: LD_VAR 0 1
101242: PUSH
101243: LD_VAR 0 2
101247: UNION
101248: ST_TO_ADDR
// end ;
101249: LD_VAR 0 3
101253: RET
// export function GetBehemoths ( side ) ; begin
101254: LD_INT 0
101256: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101257: LD_ADDR_VAR 0 2
101261: PUSH
101262: LD_INT 22
101264: PUSH
101265: LD_VAR 0 1
101269: PUSH
101270: EMPTY
101271: LIST
101272: LIST
101273: PUSH
101274: LD_INT 31
101276: PUSH
101277: LD_INT 25
101279: PUSH
101280: EMPTY
101281: LIST
101282: LIST
101283: PUSH
101284: EMPTY
101285: LIST
101286: LIST
101287: PPUSH
101288: CALL_OW 69
101292: ST_TO_ADDR
// end ;
101293: LD_VAR 0 2
101297: RET
// export function Shuffle ( array ) ; var i , index ; begin
101298: LD_INT 0
101300: PPUSH
101301: PPUSH
101302: PPUSH
// result := [ ] ;
101303: LD_ADDR_VAR 0 2
101307: PUSH
101308: EMPTY
101309: ST_TO_ADDR
// if not array then
101310: LD_VAR 0 1
101314: NOT
101315: IFFALSE 101319
// exit ;
101317: GO 101418
// Randomize ;
101319: CALL_OW 10
// for i = array downto 1 do
101323: LD_ADDR_VAR 0 3
101327: PUSH
101328: DOUBLE
101329: LD_VAR 0 1
101333: INC
101334: ST_TO_ADDR
101335: LD_INT 1
101337: PUSH
101338: FOR_DOWNTO
101339: IFFALSE 101416
// begin index := rand ( 1 , array ) ;
101341: LD_ADDR_VAR 0 4
101345: PUSH
101346: LD_INT 1
101348: PPUSH
101349: LD_VAR 0 1
101353: PPUSH
101354: CALL_OW 12
101358: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101359: LD_ADDR_VAR 0 2
101363: PUSH
101364: LD_VAR 0 2
101368: PPUSH
101369: LD_VAR 0 2
101373: PUSH
101374: LD_INT 1
101376: PLUS
101377: PPUSH
101378: LD_VAR 0 1
101382: PUSH
101383: LD_VAR 0 4
101387: ARRAY
101388: PPUSH
101389: CALL_OW 2
101393: ST_TO_ADDR
// array := Delete ( array , index ) ;
101394: LD_ADDR_VAR 0 1
101398: PUSH
101399: LD_VAR 0 1
101403: PPUSH
101404: LD_VAR 0 4
101408: PPUSH
101409: CALL_OW 3
101413: ST_TO_ADDR
// end ;
101414: GO 101338
101416: POP
101417: POP
// end ;
101418: LD_VAR 0 2
101422: RET
// export function GetBaseMaterials ( base ) ; begin
101423: LD_INT 0
101425: PPUSH
// result := [ 0 , 0 , 0 ] ;
101426: LD_ADDR_VAR 0 2
101430: PUSH
101431: LD_INT 0
101433: PUSH
101434: LD_INT 0
101436: PUSH
101437: LD_INT 0
101439: PUSH
101440: EMPTY
101441: LIST
101442: LIST
101443: LIST
101444: ST_TO_ADDR
// if not base then
101445: LD_VAR 0 1
101449: NOT
101450: IFFALSE 101454
// exit ;
101452: GO 101503
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101454: LD_ADDR_VAR 0 2
101458: PUSH
101459: LD_VAR 0 1
101463: PPUSH
101464: LD_INT 1
101466: PPUSH
101467: CALL_OW 275
101471: PUSH
101472: LD_VAR 0 1
101476: PPUSH
101477: LD_INT 2
101479: PPUSH
101480: CALL_OW 275
101484: PUSH
101485: LD_VAR 0 1
101489: PPUSH
101490: LD_INT 3
101492: PPUSH
101493: CALL_OW 275
101497: PUSH
101498: EMPTY
101499: LIST
101500: LIST
101501: LIST
101502: ST_TO_ADDR
// end ;
101503: LD_VAR 0 2
101507: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101508: LD_INT 0
101510: PPUSH
101511: PPUSH
// result := array ;
101512: LD_ADDR_VAR 0 3
101516: PUSH
101517: LD_VAR 0 1
101521: ST_TO_ADDR
// if size > 0 then
101522: LD_VAR 0 2
101526: PUSH
101527: LD_INT 0
101529: GREATER
101530: IFFALSE 101576
// for i := array downto size do
101532: LD_ADDR_VAR 0 4
101536: PUSH
101537: DOUBLE
101538: LD_VAR 0 1
101542: INC
101543: ST_TO_ADDR
101544: LD_VAR 0 2
101548: PUSH
101549: FOR_DOWNTO
101550: IFFALSE 101574
// result := Delete ( result , result ) ;
101552: LD_ADDR_VAR 0 3
101556: PUSH
101557: LD_VAR 0 3
101561: PPUSH
101562: LD_VAR 0 3
101566: PPUSH
101567: CALL_OW 3
101571: ST_TO_ADDR
101572: GO 101549
101574: POP
101575: POP
// end ;
101576: LD_VAR 0 3
101580: RET
// export function ComExit ( unit ) ; var tmp ; begin
101581: LD_INT 0
101583: PPUSH
101584: PPUSH
// if not IsInUnit ( unit ) then
101585: LD_VAR 0 1
101589: PPUSH
101590: CALL_OW 310
101594: NOT
101595: IFFALSE 101599
// exit ;
101597: GO 101659
// tmp := IsInUnit ( unit ) ;
101599: LD_ADDR_VAR 0 3
101603: PUSH
101604: LD_VAR 0 1
101608: PPUSH
101609: CALL_OW 310
101613: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101614: LD_VAR 0 3
101618: PPUSH
101619: CALL_OW 247
101623: PUSH
101624: LD_INT 2
101626: EQUAL
101627: IFFALSE 101640
// ComExitVehicle ( unit ) else
101629: LD_VAR 0 1
101633: PPUSH
101634: CALL_OW 121
101638: GO 101649
// ComExitBuilding ( unit ) ;
101640: LD_VAR 0 1
101644: PPUSH
101645: CALL_OW 122
// result := tmp ;
101649: LD_ADDR_VAR 0 2
101653: PUSH
101654: LD_VAR 0 3
101658: ST_TO_ADDR
// end ;
101659: LD_VAR 0 2
101663: RET
// export function ResetHc ; begin
101664: LD_INT 0
101666: PPUSH
// InitHc ;
101667: CALL_OW 19
// hc_importance := 0 ;
101671: LD_ADDR_OWVAR 32
101675: PUSH
101676: LD_INT 0
101678: ST_TO_ADDR
// end ;
101679: LD_VAR 0 1
101683: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101684: LD_INT 0
101686: PPUSH
101687: PPUSH
101688: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101689: LD_ADDR_VAR 0 6
101693: PUSH
101694: LD_VAR 0 1
101698: PUSH
101699: LD_VAR 0 3
101703: PLUS
101704: PUSH
101705: LD_INT 2
101707: DIV
101708: ST_TO_ADDR
// if _x < 0 then
101709: LD_VAR 0 6
101713: PUSH
101714: LD_INT 0
101716: LESS
101717: IFFALSE 101734
// _x := _x * - 1 ;
101719: LD_ADDR_VAR 0 6
101723: PUSH
101724: LD_VAR 0 6
101728: PUSH
101729: LD_INT 1
101731: NEG
101732: MUL
101733: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101734: LD_ADDR_VAR 0 7
101738: PUSH
101739: LD_VAR 0 2
101743: PUSH
101744: LD_VAR 0 4
101748: PLUS
101749: PUSH
101750: LD_INT 2
101752: DIV
101753: ST_TO_ADDR
// if _y < 0 then
101754: LD_VAR 0 7
101758: PUSH
101759: LD_INT 0
101761: LESS
101762: IFFALSE 101779
// _y := _y * - 1 ;
101764: LD_ADDR_VAR 0 7
101768: PUSH
101769: LD_VAR 0 7
101773: PUSH
101774: LD_INT 1
101776: NEG
101777: MUL
101778: ST_TO_ADDR
// result := [ _x , _y ] ;
101779: LD_ADDR_VAR 0 5
101783: PUSH
101784: LD_VAR 0 6
101788: PUSH
101789: LD_VAR 0 7
101793: PUSH
101794: EMPTY
101795: LIST
101796: LIST
101797: ST_TO_ADDR
// end ;
101798: LD_VAR 0 5
101802: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101803: LD_INT 0
101805: PPUSH
101806: PPUSH
101807: PPUSH
101808: PPUSH
// task := GetTaskList ( unit ) ;
101809: LD_ADDR_VAR 0 7
101813: PUSH
101814: LD_VAR 0 1
101818: PPUSH
101819: CALL_OW 437
101823: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101824: LD_VAR 0 7
101828: NOT
101829: PUSH
101830: LD_VAR 0 1
101834: PPUSH
101835: LD_VAR 0 2
101839: PPUSH
101840: CALL_OW 308
101844: NOT
101845: AND
101846: IFFALSE 101850
// exit ;
101848: GO 101968
// if IsInArea ( unit , area ) then
101850: LD_VAR 0 1
101854: PPUSH
101855: LD_VAR 0 2
101859: PPUSH
101860: CALL_OW 308
101864: IFFALSE 101882
// begin ComMoveToArea ( unit , goAway ) ;
101866: LD_VAR 0 1
101870: PPUSH
101871: LD_VAR 0 3
101875: PPUSH
101876: CALL_OW 113
// exit ;
101880: GO 101968
// end ; if task [ 1 ] [ 1 ] <> M then
101882: LD_VAR 0 7
101886: PUSH
101887: LD_INT 1
101889: ARRAY
101890: PUSH
101891: LD_INT 1
101893: ARRAY
101894: PUSH
101895: LD_STRING M
101897: NONEQUAL
101898: IFFALSE 101902
// exit ;
101900: GO 101968
// x := task [ 1 ] [ 2 ] ;
101902: LD_ADDR_VAR 0 5
101906: PUSH
101907: LD_VAR 0 7
101911: PUSH
101912: LD_INT 1
101914: ARRAY
101915: PUSH
101916: LD_INT 2
101918: ARRAY
101919: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101920: LD_ADDR_VAR 0 6
101924: PUSH
101925: LD_VAR 0 7
101929: PUSH
101930: LD_INT 1
101932: ARRAY
101933: PUSH
101934: LD_INT 3
101936: ARRAY
101937: ST_TO_ADDR
// if InArea ( x , y , area ) then
101938: LD_VAR 0 5
101942: PPUSH
101943: LD_VAR 0 6
101947: PPUSH
101948: LD_VAR 0 2
101952: PPUSH
101953: CALL_OW 309
101957: IFFALSE 101968
// ComStop ( unit ) ;
101959: LD_VAR 0 1
101963: PPUSH
101964: CALL_OW 141
// end ;
101968: LD_VAR 0 4
101972: RET
// export function Abs ( value ) ; begin
101973: LD_INT 0
101975: PPUSH
// result := value ;
101976: LD_ADDR_VAR 0 2
101980: PUSH
101981: LD_VAR 0 1
101985: ST_TO_ADDR
// if value < 0 then
101986: LD_VAR 0 1
101990: PUSH
101991: LD_INT 0
101993: LESS
101994: IFFALSE 102011
// result := value * - 1 ;
101996: LD_ADDR_VAR 0 2
102000: PUSH
102001: LD_VAR 0 1
102005: PUSH
102006: LD_INT 1
102008: NEG
102009: MUL
102010: ST_TO_ADDR
// end ;
102011: LD_VAR 0 2
102015: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102016: LD_INT 0
102018: PPUSH
102019: PPUSH
102020: PPUSH
102021: PPUSH
102022: PPUSH
102023: PPUSH
102024: PPUSH
102025: PPUSH
// if not unit or not building then
102026: LD_VAR 0 1
102030: NOT
102031: PUSH
102032: LD_VAR 0 2
102036: NOT
102037: OR
102038: IFFALSE 102042
// exit ;
102040: GO 102268
// x := GetX ( building ) ;
102042: LD_ADDR_VAR 0 4
102046: PUSH
102047: LD_VAR 0 2
102051: PPUSH
102052: CALL_OW 250
102056: ST_TO_ADDR
// y := GetY ( building ) ;
102057: LD_ADDR_VAR 0 6
102061: PUSH
102062: LD_VAR 0 2
102066: PPUSH
102067: CALL_OW 251
102071: ST_TO_ADDR
// d := GetDir ( building ) ;
102072: LD_ADDR_VAR 0 8
102076: PUSH
102077: LD_VAR 0 2
102081: PPUSH
102082: CALL_OW 254
102086: ST_TO_ADDR
// r := 4 ;
102087: LD_ADDR_VAR 0 9
102091: PUSH
102092: LD_INT 4
102094: ST_TO_ADDR
// for i := 1 to 5 do
102095: LD_ADDR_VAR 0 10
102099: PUSH
102100: DOUBLE
102101: LD_INT 1
102103: DEC
102104: ST_TO_ADDR
102105: LD_INT 5
102107: PUSH
102108: FOR_TO
102109: IFFALSE 102266
// begin _x := ShiftX ( x , d , r + i ) ;
102111: LD_ADDR_VAR 0 5
102115: PUSH
102116: LD_VAR 0 4
102120: PPUSH
102121: LD_VAR 0 8
102125: PPUSH
102126: LD_VAR 0 9
102130: PUSH
102131: LD_VAR 0 10
102135: PLUS
102136: PPUSH
102137: CALL_OW 272
102141: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102142: LD_ADDR_VAR 0 7
102146: PUSH
102147: LD_VAR 0 6
102151: PPUSH
102152: LD_VAR 0 8
102156: PPUSH
102157: LD_VAR 0 9
102161: PUSH
102162: LD_VAR 0 10
102166: PLUS
102167: PPUSH
102168: CALL_OW 273
102172: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102173: LD_VAR 0 5
102177: PPUSH
102178: LD_VAR 0 7
102182: PPUSH
102183: CALL_OW 488
102187: PUSH
102188: LD_VAR 0 5
102192: PPUSH
102193: LD_VAR 0 7
102197: PPUSH
102198: CALL_OW 428
102202: PPUSH
102203: CALL_OW 247
102207: PUSH
102208: LD_INT 3
102210: PUSH
102211: LD_INT 2
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: IN
102218: NOT
102219: AND
102220: IFFALSE 102264
// begin ComMoveXY ( unit , _x , _y ) ;
102222: LD_VAR 0 1
102226: PPUSH
102227: LD_VAR 0 5
102231: PPUSH
102232: LD_VAR 0 7
102236: PPUSH
102237: CALL_OW 111
// result := [ _x , _y ] ;
102241: LD_ADDR_VAR 0 3
102245: PUSH
102246: LD_VAR 0 5
102250: PUSH
102251: LD_VAR 0 7
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: ST_TO_ADDR
// exit ;
102260: POP
102261: POP
102262: GO 102268
// end ; end ;
102264: GO 102108
102266: POP
102267: POP
// end ; end_of_file end_of_file
102268: LD_VAR 0 3
102272: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
102273: LD_VAR 0 2
102277: PUSH
102278: LD_INT 100
102280: EQUAL
102281: IFFALSE 103230
// begin if not StreamModeActive then
102283: LD_EXP 156
102287: NOT
102288: IFFALSE 102298
// StreamModeActive := true ;
102290: LD_ADDR_EXP 156
102294: PUSH
102295: LD_INT 1
102297: ST_TO_ADDR
// if p3 = 0 then
102298: LD_VAR 0 3
102302: PUSH
102303: LD_INT 0
102305: EQUAL
102306: IFFALSE 102312
// InitStreamMode ;
102308: CALL 103388 0 0
// if p3 = 1 then
102312: LD_VAR 0 3
102316: PUSH
102317: LD_INT 1
102319: EQUAL
102320: IFFALSE 102330
// sRocket := true ;
102322: LD_ADDR_EXP 161
102326: PUSH
102327: LD_INT 1
102329: ST_TO_ADDR
// if p3 = 2 then
102330: LD_VAR 0 3
102334: PUSH
102335: LD_INT 2
102337: EQUAL
102338: IFFALSE 102348
// sSpeed := true ;
102340: LD_ADDR_EXP 160
102344: PUSH
102345: LD_INT 1
102347: ST_TO_ADDR
// if p3 = 3 then
102348: LD_VAR 0 3
102352: PUSH
102353: LD_INT 3
102355: EQUAL
102356: IFFALSE 102366
// sEngine := true ;
102358: LD_ADDR_EXP 162
102362: PUSH
102363: LD_INT 1
102365: ST_TO_ADDR
// if p3 = 4 then
102366: LD_VAR 0 3
102370: PUSH
102371: LD_INT 4
102373: EQUAL
102374: IFFALSE 102384
// sSpec := true ;
102376: LD_ADDR_EXP 159
102380: PUSH
102381: LD_INT 1
102383: ST_TO_ADDR
// if p3 = 5 then
102384: LD_VAR 0 3
102388: PUSH
102389: LD_INT 5
102391: EQUAL
102392: IFFALSE 102402
// sLevel := true ;
102394: LD_ADDR_EXP 163
102398: PUSH
102399: LD_INT 1
102401: ST_TO_ADDR
// if p3 = 6 then
102402: LD_VAR 0 3
102406: PUSH
102407: LD_INT 6
102409: EQUAL
102410: IFFALSE 102420
// sArmoury := true ;
102412: LD_ADDR_EXP 164
102416: PUSH
102417: LD_INT 1
102419: ST_TO_ADDR
// if p3 = 7 then
102420: LD_VAR 0 3
102424: PUSH
102425: LD_INT 7
102427: EQUAL
102428: IFFALSE 102438
// sRadar := true ;
102430: LD_ADDR_EXP 165
102434: PUSH
102435: LD_INT 1
102437: ST_TO_ADDR
// if p3 = 8 then
102438: LD_VAR 0 3
102442: PUSH
102443: LD_INT 8
102445: EQUAL
102446: IFFALSE 102456
// sBunker := true ;
102448: LD_ADDR_EXP 166
102452: PUSH
102453: LD_INT 1
102455: ST_TO_ADDR
// if p3 = 9 then
102456: LD_VAR 0 3
102460: PUSH
102461: LD_INT 9
102463: EQUAL
102464: IFFALSE 102474
// sHack := true ;
102466: LD_ADDR_EXP 167
102470: PUSH
102471: LD_INT 1
102473: ST_TO_ADDR
// if p3 = 10 then
102474: LD_VAR 0 3
102478: PUSH
102479: LD_INT 10
102481: EQUAL
102482: IFFALSE 102492
// sFire := true ;
102484: LD_ADDR_EXP 168
102488: PUSH
102489: LD_INT 1
102491: ST_TO_ADDR
// if p3 = 11 then
102492: LD_VAR 0 3
102496: PUSH
102497: LD_INT 11
102499: EQUAL
102500: IFFALSE 102510
// sRefresh := true ;
102502: LD_ADDR_EXP 169
102506: PUSH
102507: LD_INT 1
102509: ST_TO_ADDR
// if p3 = 12 then
102510: LD_VAR 0 3
102514: PUSH
102515: LD_INT 12
102517: EQUAL
102518: IFFALSE 102528
// sExp := true ;
102520: LD_ADDR_EXP 170
102524: PUSH
102525: LD_INT 1
102527: ST_TO_ADDR
// if p3 = 13 then
102528: LD_VAR 0 3
102532: PUSH
102533: LD_INT 13
102535: EQUAL
102536: IFFALSE 102546
// sDepot := true ;
102538: LD_ADDR_EXP 171
102542: PUSH
102543: LD_INT 1
102545: ST_TO_ADDR
// if p3 = 14 then
102546: LD_VAR 0 3
102550: PUSH
102551: LD_INT 14
102553: EQUAL
102554: IFFALSE 102564
// sFlag := true ;
102556: LD_ADDR_EXP 172
102560: PUSH
102561: LD_INT 1
102563: ST_TO_ADDR
// if p3 = 15 then
102564: LD_VAR 0 3
102568: PUSH
102569: LD_INT 15
102571: EQUAL
102572: IFFALSE 102582
// sKamikadze := true ;
102574: LD_ADDR_EXP 180
102578: PUSH
102579: LD_INT 1
102581: ST_TO_ADDR
// if p3 = 16 then
102582: LD_VAR 0 3
102586: PUSH
102587: LD_INT 16
102589: EQUAL
102590: IFFALSE 102600
// sTroll := true ;
102592: LD_ADDR_EXP 181
102596: PUSH
102597: LD_INT 1
102599: ST_TO_ADDR
// if p3 = 17 then
102600: LD_VAR 0 3
102604: PUSH
102605: LD_INT 17
102607: EQUAL
102608: IFFALSE 102618
// sSlow := true ;
102610: LD_ADDR_EXP 182
102614: PUSH
102615: LD_INT 1
102617: ST_TO_ADDR
// if p3 = 18 then
102618: LD_VAR 0 3
102622: PUSH
102623: LD_INT 18
102625: EQUAL
102626: IFFALSE 102636
// sLack := true ;
102628: LD_ADDR_EXP 183
102632: PUSH
102633: LD_INT 1
102635: ST_TO_ADDR
// if p3 = 19 then
102636: LD_VAR 0 3
102640: PUSH
102641: LD_INT 19
102643: EQUAL
102644: IFFALSE 102654
// sTank := true ;
102646: LD_ADDR_EXP 185
102650: PUSH
102651: LD_INT 1
102653: ST_TO_ADDR
// if p3 = 20 then
102654: LD_VAR 0 3
102658: PUSH
102659: LD_INT 20
102661: EQUAL
102662: IFFALSE 102672
// sRemote := true ;
102664: LD_ADDR_EXP 186
102668: PUSH
102669: LD_INT 1
102671: ST_TO_ADDR
// if p3 = 21 then
102672: LD_VAR 0 3
102676: PUSH
102677: LD_INT 21
102679: EQUAL
102680: IFFALSE 102690
// sPowell := true ;
102682: LD_ADDR_EXP 187
102686: PUSH
102687: LD_INT 1
102689: ST_TO_ADDR
// if p3 = 22 then
102690: LD_VAR 0 3
102694: PUSH
102695: LD_INT 22
102697: EQUAL
102698: IFFALSE 102708
// sTeleport := true ;
102700: LD_ADDR_EXP 190
102704: PUSH
102705: LD_INT 1
102707: ST_TO_ADDR
// if p3 = 23 then
102708: LD_VAR 0 3
102712: PUSH
102713: LD_INT 23
102715: EQUAL
102716: IFFALSE 102726
// sOilTower := true ;
102718: LD_ADDR_EXP 192
102722: PUSH
102723: LD_INT 1
102725: ST_TO_ADDR
// if p3 = 24 then
102726: LD_VAR 0 3
102730: PUSH
102731: LD_INT 24
102733: EQUAL
102734: IFFALSE 102744
// sShovel := true ;
102736: LD_ADDR_EXP 193
102740: PUSH
102741: LD_INT 1
102743: ST_TO_ADDR
// if p3 = 25 then
102744: LD_VAR 0 3
102748: PUSH
102749: LD_INT 25
102751: EQUAL
102752: IFFALSE 102762
// sSheik := true ;
102754: LD_ADDR_EXP 194
102758: PUSH
102759: LD_INT 1
102761: ST_TO_ADDR
// if p3 = 26 then
102762: LD_VAR 0 3
102766: PUSH
102767: LD_INT 26
102769: EQUAL
102770: IFFALSE 102780
// sEarthquake := true ;
102772: LD_ADDR_EXP 196
102776: PUSH
102777: LD_INT 1
102779: ST_TO_ADDR
// if p3 = 27 then
102780: LD_VAR 0 3
102784: PUSH
102785: LD_INT 27
102787: EQUAL
102788: IFFALSE 102798
// sAI := true ;
102790: LD_ADDR_EXP 197
102794: PUSH
102795: LD_INT 1
102797: ST_TO_ADDR
// if p3 = 28 then
102798: LD_VAR 0 3
102802: PUSH
102803: LD_INT 28
102805: EQUAL
102806: IFFALSE 102816
// sCargo := true ;
102808: LD_ADDR_EXP 200
102812: PUSH
102813: LD_INT 1
102815: ST_TO_ADDR
// if p3 = 29 then
102816: LD_VAR 0 3
102820: PUSH
102821: LD_INT 29
102823: EQUAL
102824: IFFALSE 102834
// sDLaser := true ;
102826: LD_ADDR_EXP 201
102830: PUSH
102831: LD_INT 1
102833: ST_TO_ADDR
// if p3 = 30 then
102834: LD_VAR 0 3
102838: PUSH
102839: LD_INT 30
102841: EQUAL
102842: IFFALSE 102852
// sExchange := true ;
102844: LD_ADDR_EXP 202
102848: PUSH
102849: LD_INT 1
102851: ST_TO_ADDR
// if p3 = 31 then
102852: LD_VAR 0 3
102856: PUSH
102857: LD_INT 31
102859: EQUAL
102860: IFFALSE 102870
// sFac := true ;
102862: LD_ADDR_EXP 203
102866: PUSH
102867: LD_INT 1
102869: ST_TO_ADDR
// if p3 = 32 then
102870: LD_VAR 0 3
102874: PUSH
102875: LD_INT 32
102877: EQUAL
102878: IFFALSE 102888
// sPower := true ;
102880: LD_ADDR_EXP 204
102884: PUSH
102885: LD_INT 1
102887: ST_TO_ADDR
// if p3 = 33 then
102888: LD_VAR 0 3
102892: PUSH
102893: LD_INT 33
102895: EQUAL
102896: IFFALSE 102906
// sRandom := true ;
102898: LD_ADDR_EXP 205
102902: PUSH
102903: LD_INT 1
102905: ST_TO_ADDR
// if p3 = 34 then
102906: LD_VAR 0 3
102910: PUSH
102911: LD_INT 34
102913: EQUAL
102914: IFFALSE 102924
// sShield := true ;
102916: LD_ADDR_EXP 206
102920: PUSH
102921: LD_INT 1
102923: ST_TO_ADDR
// if p3 = 35 then
102924: LD_VAR 0 3
102928: PUSH
102929: LD_INT 35
102931: EQUAL
102932: IFFALSE 102942
// sTime := true ;
102934: LD_ADDR_EXP 207
102938: PUSH
102939: LD_INT 1
102941: ST_TO_ADDR
// if p3 = 36 then
102942: LD_VAR 0 3
102946: PUSH
102947: LD_INT 36
102949: EQUAL
102950: IFFALSE 102960
// sTools := true ;
102952: LD_ADDR_EXP 208
102956: PUSH
102957: LD_INT 1
102959: ST_TO_ADDR
// if p3 = 101 then
102960: LD_VAR 0 3
102964: PUSH
102965: LD_INT 101
102967: EQUAL
102968: IFFALSE 102978
// sSold := true ;
102970: LD_ADDR_EXP 173
102974: PUSH
102975: LD_INT 1
102977: ST_TO_ADDR
// if p3 = 102 then
102978: LD_VAR 0 3
102982: PUSH
102983: LD_INT 102
102985: EQUAL
102986: IFFALSE 102996
// sDiff := true ;
102988: LD_ADDR_EXP 174
102992: PUSH
102993: LD_INT 1
102995: ST_TO_ADDR
// if p3 = 103 then
102996: LD_VAR 0 3
103000: PUSH
103001: LD_INT 103
103003: EQUAL
103004: IFFALSE 103014
// sFog := true ;
103006: LD_ADDR_EXP 177
103010: PUSH
103011: LD_INT 1
103013: ST_TO_ADDR
// if p3 = 104 then
103014: LD_VAR 0 3
103018: PUSH
103019: LD_INT 104
103021: EQUAL
103022: IFFALSE 103032
// sReset := true ;
103024: LD_ADDR_EXP 178
103028: PUSH
103029: LD_INT 1
103031: ST_TO_ADDR
// if p3 = 105 then
103032: LD_VAR 0 3
103036: PUSH
103037: LD_INT 105
103039: EQUAL
103040: IFFALSE 103050
// sSun := true ;
103042: LD_ADDR_EXP 179
103046: PUSH
103047: LD_INT 1
103049: ST_TO_ADDR
// if p3 = 106 then
103050: LD_VAR 0 3
103054: PUSH
103055: LD_INT 106
103057: EQUAL
103058: IFFALSE 103068
// sTiger := true ;
103060: LD_ADDR_EXP 175
103064: PUSH
103065: LD_INT 1
103067: ST_TO_ADDR
// if p3 = 107 then
103068: LD_VAR 0 3
103072: PUSH
103073: LD_INT 107
103075: EQUAL
103076: IFFALSE 103086
// sBomb := true ;
103078: LD_ADDR_EXP 176
103082: PUSH
103083: LD_INT 1
103085: ST_TO_ADDR
// if p3 = 108 then
103086: LD_VAR 0 3
103090: PUSH
103091: LD_INT 108
103093: EQUAL
103094: IFFALSE 103104
// sWound := true ;
103096: LD_ADDR_EXP 184
103100: PUSH
103101: LD_INT 1
103103: ST_TO_ADDR
// if p3 = 109 then
103104: LD_VAR 0 3
103108: PUSH
103109: LD_INT 109
103111: EQUAL
103112: IFFALSE 103122
// sBetray := true ;
103114: LD_ADDR_EXP 188
103118: PUSH
103119: LD_INT 1
103121: ST_TO_ADDR
// if p3 = 110 then
103122: LD_VAR 0 3
103126: PUSH
103127: LD_INT 110
103129: EQUAL
103130: IFFALSE 103140
// sContamin := true ;
103132: LD_ADDR_EXP 189
103136: PUSH
103137: LD_INT 1
103139: ST_TO_ADDR
// if p3 = 111 then
103140: LD_VAR 0 3
103144: PUSH
103145: LD_INT 111
103147: EQUAL
103148: IFFALSE 103158
// sOil := true ;
103150: LD_ADDR_EXP 191
103154: PUSH
103155: LD_INT 1
103157: ST_TO_ADDR
// if p3 = 112 then
103158: LD_VAR 0 3
103162: PUSH
103163: LD_INT 112
103165: EQUAL
103166: IFFALSE 103176
// sStu := true ;
103168: LD_ADDR_EXP 195
103172: PUSH
103173: LD_INT 1
103175: ST_TO_ADDR
// if p3 = 113 then
103176: LD_VAR 0 3
103180: PUSH
103181: LD_INT 113
103183: EQUAL
103184: IFFALSE 103194
// sBazooka := true ;
103186: LD_ADDR_EXP 198
103190: PUSH
103191: LD_INT 1
103193: ST_TO_ADDR
// if p3 = 114 then
103194: LD_VAR 0 3
103198: PUSH
103199: LD_INT 114
103201: EQUAL
103202: IFFALSE 103212
// sMortar := true ;
103204: LD_ADDR_EXP 199
103208: PUSH
103209: LD_INT 1
103211: ST_TO_ADDR
// if p3 = 115 then
103212: LD_VAR 0 3
103216: PUSH
103217: LD_INT 115
103219: EQUAL
103220: IFFALSE 103230
// sRanger := true ;
103222: LD_ADDR_EXP 209
103226: PUSH
103227: LD_INT 1
103229: ST_TO_ADDR
// end ; if p2 = 101 then
103230: LD_VAR 0 2
103234: PUSH
103235: LD_INT 101
103237: EQUAL
103238: IFFALSE 103366
// begin case p3 of 1 :
103240: LD_VAR 0 3
103244: PUSH
103245: LD_INT 1
103247: DOUBLE
103248: EQUAL
103249: IFTRUE 103253
103251: GO 103260
103253: POP
// hHackUnlimitedResources ; 2 :
103254: CALL 114401 0 0
103258: GO 103366
103260: LD_INT 2
103262: DOUBLE
103263: EQUAL
103264: IFTRUE 103268
103266: GO 103275
103268: POP
// hHackSetLevel10 ; 3 :
103269: CALL 114534 0 0
103273: GO 103366
103275: LD_INT 3
103277: DOUBLE
103278: EQUAL
103279: IFTRUE 103283
103281: GO 103290
103283: POP
// hHackSetLevel10YourUnits ; 4 :
103284: CALL 114619 0 0
103288: GO 103366
103290: LD_INT 4
103292: DOUBLE
103293: EQUAL
103294: IFTRUE 103298
103296: GO 103305
103298: POP
// hHackInvincible ; 5 :
103299: CALL 115067 0 0
103303: GO 103366
103305: LD_INT 5
103307: DOUBLE
103308: EQUAL
103309: IFTRUE 103313
103311: GO 103320
103313: POP
// hHackInvisible ; 6 :
103314: CALL 115178 0 0
103318: GO 103366
103320: LD_INT 6
103322: DOUBLE
103323: EQUAL
103324: IFTRUE 103328
103326: GO 103335
103328: POP
// hHackChangeYourSide ; 7 :
103329: CALL 115235 0 0
103333: GO 103366
103335: LD_INT 7
103337: DOUBLE
103338: EQUAL
103339: IFTRUE 103343
103341: GO 103350
103343: POP
// hHackChangeUnitSide ; 8 :
103344: CALL 115277 0 0
103348: GO 103366
103350: LD_INT 8
103352: DOUBLE
103353: EQUAL
103354: IFTRUE 103358
103356: GO 103365
103358: POP
// hHackFog ; end ;
103359: CALL 115378 0 0
103363: GO 103366
103365: POP
// end ; end ;
103366: PPOPN 6
103368: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
103369: GO 103371
103371: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
103372: LD_STRING initStreamRollete();
103374: PPUSH
103375: CALL_OW 559
// InitStreamMode ;
103379: CALL 103388 0 0
// DefineStreamItems ( ) ;
103383: CALL 103828 0 0
// end ;
103387: END
// function InitStreamMode ; begin
103388: LD_INT 0
103390: PPUSH
// streamModeActive := false ;
103391: LD_ADDR_EXP 156
103395: PUSH
103396: LD_INT 0
103398: ST_TO_ADDR
// normalCounter := 36 ;
103399: LD_ADDR_EXP 157
103403: PUSH
103404: LD_INT 36
103406: ST_TO_ADDR
// hardcoreCounter := 16 ;
103407: LD_ADDR_EXP 158
103411: PUSH
103412: LD_INT 16
103414: ST_TO_ADDR
// sRocket := false ;
103415: LD_ADDR_EXP 161
103419: PUSH
103420: LD_INT 0
103422: ST_TO_ADDR
// sSpeed := false ;
103423: LD_ADDR_EXP 160
103427: PUSH
103428: LD_INT 0
103430: ST_TO_ADDR
// sEngine := false ;
103431: LD_ADDR_EXP 162
103435: PUSH
103436: LD_INT 0
103438: ST_TO_ADDR
// sSpec := false ;
103439: LD_ADDR_EXP 159
103443: PUSH
103444: LD_INT 0
103446: ST_TO_ADDR
// sLevel := false ;
103447: LD_ADDR_EXP 163
103451: PUSH
103452: LD_INT 0
103454: ST_TO_ADDR
// sArmoury := false ;
103455: LD_ADDR_EXP 164
103459: PUSH
103460: LD_INT 0
103462: ST_TO_ADDR
// sRadar := false ;
103463: LD_ADDR_EXP 165
103467: PUSH
103468: LD_INT 0
103470: ST_TO_ADDR
// sBunker := false ;
103471: LD_ADDR_EXP 166
103475: PUSH
103476: LD_INT 0
103478: ST_TO_ADDR
// sHack := false ;
103479: LD_ADDR_EXP 167
103483: PUSH
103484: LD_INT 0
103486: ST_TO_ADDR
// sFire := false ;
103487: LD_ADDR_EXP 168
103491: PUSH
103492: LD_INT 0
103494: ST_TO_ADDR
// sRefresh := false ;
103495: LD_ADDR_EXP 169
103499: PUSH
103500: LD_INT 0
103502: ST_TO_ADDR
// sExp := false ;
103503: LD_ADDR_EXP 170
103507: PUSH
103508: LD_INT 0
103510: ST_TO_ADDR
// sDepot := false ;
103511: LD_ADDR_EXP 171
103515: PUSH
103516: LD_INT 0
103518: ST_TO_ADDR
// sFlag := false ;
103519: LD_ADDR_EXP 172
103523: PUSH
103524: LD_INT 0
103526: ST_TO_ADDR
// sKamikadze := false ;
103527: LD_ADDR_EXP 180
103531: PUSH
103532: LD_INT 0
103534: ST_TO_ADDR
// sTroll := false ;
103535: LD_ADDR_EXP 181
103539: PUSH
103540: LD_INT 0
103542: ST_TO_ADDR
// sSlow := false ;
103543: LD_ADDR_EXP 182
103547: PUSH
103548: LD_INT 0
103550: ST_TO_ADDR
// sLack := false ;
103551: LD_ADDR_EXP 183
103555: PUSH
103556: LD_INT 0
103558: ST_TO_ADDR
// sTank := false ;
103559: LD_ADDR_EXP 185
103563: PUSH
103564: LD_INT 0
103566: ST_TO_ADDR
// sRemote := false ;
103567: LD_ADDR_EXP 186
103571: PUSH
103572: LD_INT 0
103574: ST_TO_ADDR
// sPowell := false ;
103575: LD_ADDR_EXP 187
103579: PUSH
103580: LD_INT 0
103582: ST_TO_ADDR
// sTeleport := false ;
103583: LD_ADDR_EXP 190
103587: PUSH
103588: LD_INT 0
103590: ST_TO_ADDR
// sOilTower := false ;
103591: LD_ADDR_EXP 192
103595: PUSH
103596: LD_INT 0
103598: ST_TO_ADDR
// sShovel := false ;
103599: LD_ADDR_EXP 193
103603: PUSH
103604: LD_INT 0
103606: ST_TO_ADDR
// sSheik := false ;
103607: LD_ADDR_EXP 194
103611: PUSH
103612: LD_INT 0
103614: ST_TO_ADDR
// sEarthquake := false ;
103615: LD_ADDR_EXP 196
103619: PUSH
103620: LD_INT 0
103622: ST_TO_ADDR
// sAI := false ;
103623: LD_ADDR_EXP 197
103627: PUSH
103628: LD_INT 0
103630: ST_TO_ADDR
// sCargo := false ;
103631: LD_ADDR_EXP 200
103635: PUSH
103636: LD_INT 0
103638: ST_TO_ADDR
// sDLaser := false ;
103639: LD_ADDR_EXP 201
103643: PUSH
103644: LD_INT 0
103646: ST_TO_ADDR
// sExchange := false ;
103647: LD_ADDR_EXP 202
103651: PUSH
103652: LD_INT 0
103654: ST_TO_ADDR
// sFac := false ;
103655: LD_ADDR_EXP 203
103659: PUSH
103660: LD_INT 0
103662: ST_TO_ADDR
// sPower := false ;
103663: LD_ADDR_EXP 204
103667: PUSH
103668: LD_INT 0
103670: ST_TO_ADDR
// sRandom := false ;
103671: LD_ADDR_EXP 205
103675: PUSH
103676: LD_INT 0
103678: ST_TO_ADDR
// sShield := false ;
103679: LD_ADDR_EXP 206
103683: PUSH
103684: LD_INT 0
103686: ST_TO_ADDR
// sTime := false ;
103687: LD_ADDR_EXP 207
103691: PUSH
103692: LD_INT 0
103694: ST_TO_ADDR
// sTools := false ;
103695: LD_ADDR_EXP 208
103699: PUSH
103700: LD_INT 0
103702: ST_TO_ADDR
// sSold := false ;
103703: LD_ADDR_EXP 173
103707: PUSH
103708: LD_INT 0
103710: ST_TO_ADDR
// sDiff := false ;
103711: LD_ADDR_EXP 174
103715: PUSH
103716: LD_INT 0
103718: ST_TO_ADDR
// sFog := false ;
103719: LD_ADDR_EXP 177
103723: PUSH
103724: LD_INT 0
103726: ST_TO_ADDR
// sReset := false ;
103727: LD_ADDR_EXP 178
103731: PUSH
103732: LD_INT 0
103734: ST_TO_ADDR
// sSun := false ;
103735: LD_ADDR_EXP 179
103739: PUSH
103740: LD_INT 0
103742: ST_TO_ADDR
// sTiger := false ;
103743: LD_ADDR_EXP 175
103747: PUSH
103748: LD_INT 0
103750: ST_TO_ADDR
// sBomb := false ;
103751: LD_ADDR_EXP 176
103755: PUSH
103756: LD_INT 0
103758: ST_TO_ADDR
// sWound := false ;
103759: LD_ADDR_EXP 184
103763: PUSH
103764: LD_INT 0
103766: ST_TO_ADDR
// sBetray := false ;
103767: LD_ADDR_EXP 188
103771: PUSH
103772: LD_INT 0
103774: ST_TO_ADDR
// sContamin := false ;
103775: LD_ADDR_EXP 189
103779: PUSH
103780: LD_INT 0
103782: ST_TO_ADDR
// sOil := false ;
103783: LD_ADDR_EXP 191
103787: PUSH
103788: LD_INT 0
103790: ST_TO_ADDR
// sStu := false ;
103791: LD_ADDR_EXP 195
103795: PUSH
103796: LD_INT 0
103798: ST_TO_ADDR
// sBazooka := false ;
103799: LD_ADDR_EXP 198
103803: PUSH
103804: LD_INT 0
103806: ST_TO_ADDR
// sMortar := false ;
103807: LD_ADDR_EXP 199
103811: PUSH
103812: LD_INT 0
103814: ST_TO_ADDR
// sRanger := false ;
103815: LD_ADDR_EXP 209
103819: PUSH
103820: LD_INT 0
103822: ST_TO_ADDR
// end ;
103823: LD_VAR 0 1
103827: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103828: LD_INT 0
103830: PPUSH
103831: PPUSH
103832: PPUSH
103833: PPUSH
103834: PPUSH
// result := [ ] ;
103835: LD_ADDR_VAR 0 1
103839: PUSH
103840: EMPTY
103841: ST_TO_ADDR
// if campaign_id = 1 then
103842: LD_OWVAR 69
103846: PUSH
103847: LD_INT 1
103849: EQUAL
103850: IFFALSE 106788
// begin case mission_number of 1 :
103852: LD_OWVAR 70
103856: PUSH
103857: LD_INT 1
103859: DOUBLE
103860: EQUAL
103861: IFTRUE 103865
103863: GO 103929
103865: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
103866: LD_ADDR_VAR 0 1
103870: PUSH
103871: LD_INT 2
103873: PUSH
103874: LD_INT 4
103876: PUSH
103877: LD_INT 11
103879: PUSH
103880: LD_INT 12
103882: PUSH
103883: LD_INT 15
103885: PUSH
103886: LD_INT 16
103888: PUSH
103889: LD_INT 22
103891: PUSH
103892: LD_INT 23
103894: PUSH
103895: LD_INT 26
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: LIST
103902: LIST
103903: LIST
103904: LIST
103905: LIST
103906: LIST
103907: LIST
103908: PUSH
103909: LD_INT 101
103911: PUSH
103912: LD_INT 102
103914: PUSH
103915: LD_INT 106
103917: PUSH
103918: EMPTY
103919: LIST
103920: LIST
103921: LIST
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: ST_TO_ADDR
103927: GO 106786
103929: LD_INT 2
103931: DOUBLE
103932: EQUAL
103933: IFTRUE 103937
103935: GO 104009
103937: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
103938: LD_ADDR_VAR 0 1
103942: PUSH
103943: LD_INT 2
103945: PUSH
103946: LD_INT 4
103948: PUSH
103949: LD_INT 11
103951: PUSH
103952: LD_INT 12
103954: PUSH
103955: LD_INT 15
103957: PUSH
103958: LD_INT 16
103960: PUSH
103961: LD_INT 22
103963: PUSH
103964: LD_INT 23
103966: PUSH
103967: LD_INT 26
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: LIST
103974: LIST
103975: LIST
103976: LIST
103977: LIST
103978: LIST
103979: LIST
103980: PUSH
103981: LD_INT 101
103983: PUSH
103984: LD_INT 102
103986: PUSH
103987: LD_INT 105
103989: PUSH
103990: LD_INT 106
103992: PUSH
103993: LD_INT 108
103995: PUSH
103996: EMPTY
103997: LIST
103998: LIST
103999: LIST
104000: LIST
104001: LIST
104002: PUSH
104003: EMPTY
104004: LIST
104005: LIST
104006: ST_TO_ADDR
104007: GO 106786
104009: LD_INT 3
104011: DOUBLE
104012: EQUAL
104013: IFTRUE 104017
104015: GO 104093
104017: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
104018: LD_ADDR_VAR 0 1
104022: PUSH
104023: LD_INT 2
104025: PUSH
104026: LD_INT 4
104028: PUSH
104029: LD_INT 5
104031: PUSH
104032: LD_INT 11
104034: PUSH
104035: LD_INT 12
104037: PUSH
104038: LD_INT 15
104040: PUSH
104041: LD_INT 16
104043: PUSH
104044: LD_INT 22
104046: PUSH
104047: LD_INT 26
104049: PUSH
104050: LD_INT 36
104052: PUSH
104053: EMPTY
104054: LIST
104055: LIST
104056: LIST
104057: LIST
104058: LIST
104059: LIST
104060: LIST
104061: LIST
104062: LIST
104063: LIST
104064: PUSH
104065: LD_INT 101
104067: PUSH
104068: LD_INT 102
104070: PUSH
104071: LD_INT 105
104073: PUSH
104074: LD_INT 106
104076: PUSH
104077: LD_INT 108
104079: PUSH
104080: EMPTY
104081: LIST
104082: LIST
104083: LIST
104084: LIST
104085: LIST
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: ST_TO_ADDR
104091: GO 106786
104093: LD_INT 4
104095: DOUBLE
104096: EQUAL
104097: IFTRUE 104101
104099: GO 104185
104101: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
104102: LD_ADDR_VAR 0 1
104106: PUSH
104107: LD_INT 2
104109: PUSH
104110: LD_INT 4
104112: PUSH
104113: LD_INT 5
104115: PUSH
104116: LD_INT 8
104118: PUSH
104119: LD_INT 11
104121: PUSH
104122: LD_INT 12
104124: PUSH
104125: LD_INT 15
104127: PUSH
104128: LD_INT 16
104130: PUSH
104131: LD_INT 22
104133: PUSH
104134: LD_INT 23
104136: PUSH
104137: LD_INT 26
104139: PUSH
104140: LD_INT 36
104142: PUSH
104143: EMPTY
104144: LIST
104145: LIST
104146: LIST
104147: LIST
104148: LIST
104149: LIST
104150: LIST
104151: LIST
104152: LIST
104153: LIST
104154: LIST
104155: LIST
104156: PUSH
104157: LD_INT 101
104159: PUSH
104160: LD_INT 102
104162: PUSH
104163: LD_INT 105
104165: PUSH
104166: LD_INT 106
104168: PUSH
104169: LD_INT 108
104171: PUSH
104172: EMPTY
104173: LIST
104174: LIST
104175: LIST
104176: LIST
104177: LIST
104178: PUSH
104179: EMPTY
104180: LIST
104181: LIST
104182: ST_TO_ADDR
104183: GO 106786
104185: LD_INT 5
104187: DOUBLE
104188: EQUAL
104189: IFTRUE 104193
104191: GO 104293
104193: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
104194: LD_ADDR_VAR 0 1
104198: PUSH
104199: LD_INT 2
104201: PUSH
104202: LD_INT 4
104204: PUSH
104205: LD_INT 5
104207: PUSH
104208: LD_INT 6
104210: PUSH
104211: LD_INT 8
104213: PUSH
104214: LD_INT 11
104216: PUSH
104217: LD_INT 12
104219: PUSH
104220: LD_INT 15
104222: PUSH
104223: LD_INT 16
104225: PUSH
104226: LD_INT 22
104228: PUSH
104229: LD_INT 23
104231: PUSH
104232: LD_INT 25
104234: PUSH
104235: LD_INT 26
104237: PUSH
104238: LD_INT 36
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: LIST
104247: LIST
104248: LIST
104249: LIST
104250: LIST
104251: LIST
104252: LIST
104253: LIST
104254: LIST
104255: LIST
104256: PUSH
104257: LD_INT 101
104259: PUSH
104260: LD_INT 102
104262: PUSH
104263: LD_INT 105
104265: PUSH
104266: LD_INT 106
104268: PUSH
104269: LD_INT 108
104271: PUSH
104272: LD_INT 109
104274: PUSH
104275: LD_INT 112
104277: PUSH
104278: EMPTY
104279: LIST
104280: LIST
104281: LIST
104282: LIST
104283: LIST
104284: LIST
104285: LIST
104286: PUSH
104287: EMPTY
104288: LIST
104289: LIST
104290: ST_TO_ADDR
104291: GO 106786
104293: LD_INT 6
104295: DOUBLE
104296: EQUAL
104297: IFTRUE 104301
104299: GO 104421
104301: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
104302: LD_ADDR_VAR 0 1
104306: PUSH
104307: LD_INT 2
104309: PUSH
104310: LD_INT 4
104312: PUSH
104313: LD_INT 5
104315: PUSH
104316: LD_INT 6
104318: PUSH
104319: LD_INT 8
104321: PUSH
104322: LD_INT 11
104324: PUSH
104325: LD_INT 12
104327: PUSH
104328: LD_INT 15
104330: PUSH
104331: LD_INT 16
104333: PUSH
104334: LD_INT 20
104336: PUSH
104337: LD_INT 21
104339: PUSH
104340: LD_INT 22
104342: PUSH
104343: LD_INT 23
104345: PUSH
104346: LD_INT 25
104348: PUSH
104349: LD_INT 26
104351: PUSH
104352: LD_INT 30
104354: PUSH
104355: LD_INT 31
104357: PUSH
104358: LD_INT 32
104360: PUSH
104361: LD_INT 36
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: LIST
104368: LIST
104369: LIST
104370: LIST
104371: LIST
104372: LIST
104373: LIST
104374: LIST
104375: LIST
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: PUSH
104385: LD_INT 101
104387: PUSH
104388: LD_INT 102
104390: PUSH
104391: LD_INT 105
104393: PUSH
104394: LD_INT 106
104396: PUSH
104397: LD_INT 108
104399: PUSH
104400: LD_INT 109
104402: PUSH
104403: LD_INT 112
104405: PUSH
104406: EMPTY
104407: LIST
104408: LIST
104409: LIST
104410: LIST
104411: LIST
104412: LIST
104413: LIST
104414: PUSH
104415: EMPTY
104416: LIST
104417: LIST
104418: ST_TO_ADDR
104419: GO 106786
104421: LD_INT 7
104423: DOUBLE
104424: EQUAL
104425: IFTRUE 104429
104427: GO 104529
104429: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
104430: LD_ADDR_VAR 0 1
104434: PUSH
104435: LD_INT 2
104437: PUSH
104438: LD_INT 4
104440: PUSH
104441: LD_INT 5
104443: PUSH
104444: LD_INT 7
104446: PUSH
104447: LD_INT 11
104449: PUSH
104450: LD_INT 12
104452: PUSH
104453: LD_INT 15
104455: PUSH
104456: LD_INT 16
104458: PUSH
104459: LD_INT 20
104461: PUSH
104462: LD_INT 21
104464: PUSH
104465: LD_INT 22
104467: PUSH
104468: LD_INT 23
104470: PUSH
104471: LD_INT 25
104473: PUSH
104474: LD_INT 26
104476: PUSH
104477: EMPTY
104478: LIST
104479: LIST
104480: LIST
104481: LIST
104482: LIST
104483: LIST
104484: LIST
104485: LIST
104486: LIST
104487: LIST
104488: LIST
104489: LIST
104490: LIST
104491: LIST
104492: PUSH
104493: LD_INT 101
104495: PUSH
104496: LD_INT 102
104498: PUSH
104499: LD_INT 103
104501: PUSH
104502: LD_INT 105
104504: PUSH
104505: LD_INT 106
104507: PUSH
104508: LD_INT 108
104510: PUSH
104511: LD_INT 112
104513: PUSH
104514: EMPTY
104515: LIST
104516: LIST
104517: LIST
104518: LIST
104519: LIST
104520: LIST
104521: LIST
104522: PUSH
104523: EMPTY
104524: LIST
104525: LIST
104526: ST_TO_ADDR
104527: GO 106786
104529: LD_INT 8
104531: DOUBLE
104532: EQUAL
104533: IFTRUE 104537
104535: GO 104665
104537: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
104538: LD_ADDR_VAR 0 1
104542: PUSH
104543: LD_INT 2
104545: PUSH
104546: LD_INT 4
104548: PUSH
104549: LD_INT 5
104551: PUSH
104552: LD_INT 6
104554: PUSH
104555: LD_INT 7
104557: PUSH
104558: LD_INT 8
104560: PUSH
104561: LD_INT 11
104563: PUSH
104564: LD_INT 12
104566: PUSH
104567: LD_INT 15
104569: PUSH
104570: LD_INT 16
104572: PUSH
104573: LD_INT 20
104575: PUSH
104576: LD_INT 21
104578: PUSH
104579: LD_INT 22
104581: PUSH
104582: LD_INT 23
104584: PUSH
104585: LD_INT 25
104587: PUSH
104588: LD_INT 26
104590: PUSH
104591: LD_INT 30
104593: PUSH
104594: LD_INT 31
104596: PUSH
104597: LD_INT 32
104599: PUSH
104600: LD_INT 36
104602: PUSH
104603: EMPTY
104604: LIST
104605: LIST
104606: LIST
104607: LIST
104608: LIST
104609: LIST
104610: LIST
104611: LIST
104612: LIST
104613: LIST
104614: LIST
104615: LIST
104616: LIST
104617: LIST
104618: LIST
104619: LIST
104620: LIST
104621: LIST
104622: LIST
104623: LIST
104624: PUSH
104625: LD_INT 101
104627: PUSH
104628: LD_INT 102
104630: PUSH
104631: LD_INT 103
104633: PUSH
104634: LD_INT 105
104636: PUSH
104637: LD_INT 106
104639: PUSH
104640: LD_INT 108
104642: PUSH
104643: LD_INT 109
104645: PUSH
104646: LD_INT 112
104648: PUSH
104649: EMPTY
104650: LIST
104651: LIST
104652: LIST
104653: LIST
104654: LIST
104655: LIST
104656: LIST
104657: LIST
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: ST_TO_ADDR
104663: GO 106786
104665: LD_INT 9
104667: DOUBLE
104668: EQUAL
104669: IFTRUE 104673
104671: GO 104809
104673: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
104674: LD_ADDR_VAR 0 1
104678: PUSH
104679: LD_INT 2
104681: PUSH
104682: LD_INT 4
104684: PUSH
104685: LD_INT 5
104687: PUSH
104688: LD_INT 6
104690: PUSH
104691: LD_INT 7
104693: PUSH
104694: LD_INT 8
104696: PUSH
104697: LD_INT 11
104699: PUSH
104700: LD_INT 12
104702: PUSH
104703: LD_INT 15
104705: PUSH
104706: LD_INT 16
104708: PUSH
104709: LD_INT 20
104711: PUSH
104712: LD_INT 21
104714: PUSH
104715: LD_INT 22
104717: PUSH
104718: LD_INT 23
104720: PUSH
104721: LD_INT 25
104723: PUSH
104724: LD_INT 26
104726: PUSH
104727: LD_INT 28
104729: PUSH
104730: LD_INT 30
104732: PUSH
104733: LD_INT 31
104735: PUSH
104736: LD_INT 32
104738: PUSH
104739: LD_INT 36
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: LIST
104746: LIST
104747: LIST
104748: LIST
104749: LIST
104750: LIST
104751: LIST
104752: LIST
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: LIST
104758: LIST
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: PUSH
104765: LD_INT 101
104767: PUSH
104768: LD_INT 102
104770: PUSH
104771: LD_INT 103
104773: PUSH
104774: LD_INT 105
104776: PUSH
104777: LD_INT 106
104779: PUSH
104780: LD_INT 108
104782: PUSH
104783: LD_INT 109
104785: PUSH
104786: LD_INT 112
104788: PUSH
104789: LD_INT 114
104791: PUSH
104792: EMPTY
104793: LIST
104794: LIST
104795: LIST
104796: LIST
104797: LIST
104798: LIST
104799: LIST
104800: LIST
104801: LIST
104802: PUSH
104803: EMPTY
104804: LIST
104805: LIST
104806: ST_TO_ADDR
104807: GO 106786
104809: LD_INT 10
104811: DOUBLE
104812: EQUAL
104813: IFTRUE 104817
104815: GO 105001
104817: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104818: LD_ADDR_VAR 0 1
104822: PUSH
104823: LD_INT 2
104825: PUSH
104826: LD_INT 4
104828: PUSH
104829: LD_INT 5
104831: PUSH
104832: LD_INT 6
104834: PUSH
104835: LD_INT 7
104837: PUSH
104838: LD_INT 8
104840: PUSH
104841: LD_INT 9
104843: PUSH
104844: LD_INT 10
104846: PUSH
104847: LD_INT 11
104849: PUSH
104850: LD_INT 12
104852: PUSH
104853: LD_INT 13
104855: PUSH
104856: LD_INT 14
104858: PUSH
104859: LD_INT 15
104861: PUSH
104862: LD_INT 16
104864: PUSH
104865: LD_INT 17
104867: PUSH
104868: LD_INT 18
104870: PUSH
104871: LD_INT 19
104873: PUSH
104874: LD_INT 20
104876: PUSH
104877: LD_INT 21
104879: PUSH
104880: LD_INT 22
104882: PUSH
104883: LD_INT 23
104885: PUSH
104886: LD_INT 24
104888: PUSH
104889: LD_INT 25
104891: PUSH
104892: LD_INT 26
104894: PUSH
104895: LD_INT 28
104897: PUSH
104898: LD_INT 30
104900: PUSH
104901: LD_INT 31
104903: PUSH
104904: LD_INT 32
104906: PUSH
104907: LD_INT 36
104909: PUSH
104910: EMPTY
104911: LIST
104912: LIST
104913: LIST
104914: LIST
104915: LIST
104916: LIST
104917: LIST
104918: LIST
104919: LIST
104920: LIST
104921: LIST
104922: LIST
104923: LIST
104924: LIST
104925: LIST
104926: LIST
104927: LIST
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: LIST
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: PUSH
104941: LD_INT 101
104943: PUSH
104944: LD_INT 102
104946: PUSH
104947: LD_INT 103
104949: PUSH
104950: LD_INT 104
104952: PUSH
104953: LD_INT 105
104955: PUSH
104956: LD_INT 106
104958: PUSH
104959: LD_INT 107
104961: PUSH
104962: LD_INT 108
104964: PUSH
104965: LD_INT 109
104967: PUSH
104968: LD_INT 110
104970: PUSH
104971: LD_INT 111
104973: PUSH
104974: LD_INT 112
104976: PUSH
104977: LD_INT 114
104979: PUSH
104980: EMPTY
104981: LIST
104982: LIST
104983: LIST
104984: LIST
104985: LIST
104986: LIST
104987: LIST
104988: LIST
104989: LIST
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: PUSH
104995: EMPTY
104996: LIST
104997: LIST
104998: ST_TO_ADDR
104999: GO 106786
105001: LD_INT 11
105003: DOUBLE
105004: EQUAL
105005: IFTRUE 105009
105007: GO 105201
105009: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
105010: LD_ADDR_VAR 0 1
105014: PUSH
105015: LD_INT 2
105017: PUSH
105018: LD_INT 3
105020: PUSH
105021: LD_INT 4
105023: PUSH
105024: LD_INT 5
105026: PUSH
105027: LD_INT 6
105029: PUSH
105030: LD_INT 7
105032: PUSH
105033: LD_INT 8
105035: PUSH
105036: LD_INT 9
105038: PUSH
105039: LD_INT 10
105041: PUSH
105042: LD_INT 11
105044: PUSH
105045: LD_INT 12
105047: PUSH
105048: LD_INT 13
105050: PUSH
105051: LD_INT 14
105053: PUSH
105054: LD_INT 15
105056: PUSH
105057: LD_INT 16
105059: PUSH
105060: LD_INT 17
105062: PUSH
105063: LD_INT 18
105065: PUSH
105066: LD_INT 19
105068: PUSH
105069: LD_INT 20
105071: PUSH
105072: LD_INT 21
105074: PUSH
105075: LD_INT 22
105077: PUSH
105078: LD_INT 23
105080: PUSH
105081: LD_INT 24
105083: PUSH
105084: LD_INT 25
105086: PUSH
105087: LD_INT 26
105089: PUSH
105090: LD_INT 28
105092: PUSH
105093: LD_INT 30
105095: PUSH
105096: LD_INT 31
105098: PUSH
105099: LD_INT 32
105101: PUSH
105102: LD_INT 34
105104: PUSH
105105: LD_INT 36
105107: PUSH
105108: EMPTY
105109: LIST
105110: LIST
105111: LIST
105112: LIST
105113: LIST
105114: LIST
105115: LIST
105116: LIST
105117: LIST
105118: LIST
105119: LIST
105120: LIST
105121: LIST
105122: LIST
105123: LIST
105124: LIST
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: LIST
105130: LIST
105131: LIST
105132: LIST
105133: LIST
105134: LIST
105135: LIST
105136: LIST
105137: LIST
105138: LIST
105139: LIST
105140: PUSH
105141: LD_INT 101
105143: PUSH
105144: LD_INT 102
105146: PUSH
105147: LD_INT 103
105149: PUSH
105150: LD_INT 104
105152: PUSH
105153: LD_INT 105
105155: PUSH
105156: LD_INT 106
105158: PUSH
105159: LD_INT 107
105161: PUSH
105162: LD_INT 108
105164: PUSH
105165: LD_INT 109
105167: PUSH
105168: LD_INT 110
105170: PUSH
105171: LD_INT 111
105173: PUSH
105174: LD_INT 112
105176: PUSH
105177: LD_INT 114
105179: PUSH
105180: EMPTY
105181: LIST
105182: LIST
105183: LIST
105184: LIST
105185: LIST
105186: LIST
105187: LIST
105188: LIST
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: LIST
105194: PUSH
105195: EMPTY
105196: LIST
105197: LIST
105198: ST_TO_ADDR
105199: GO 106786
105201: LD_INT 12
105203: DOUBLE
105204: EQUAL
105205: IFTRUE 105209
105207: GO 105417
105209: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
105210: LD_ADDR_VAR 0 1
105214: PUSH
105215: LD_INT 1
105217: PUSH
105218: LD_INT 2
105220: PUSH
105221: LD_INT 3
105223: PUSH
105224: LD_INT 4
105226: PUSH
105227: LD_INT 5
105229: PUSH
105230: LD_INT 6
105232: PUSH
105233: LD_INT 7
105235: PUSH
105236: LD_INT 8
105238: PUSH
105239: LD_INT 9
105241: PUSH
105242: LD_INT 10
105244: PUSH
105245: LD_INT 11
105247: PUSH
105248: LD_INT 12
105250: PUSH
105251: LD_INT 13
105253: PUSH
105254: LD_INT 14
105256: PUSH
105257: LD_INT 15
105259: PUSH
105260: LD_INT 16
105262: PUSH
105263: LD_INT 17
105265: PUSH
105266: LD_INT 18
105268: PUSH
105269: LD_INT 19
105271: PUSH
105272: LD_INT 20
105274: PUSH
105275: LD_INT 21
105277: PUSH
105278: LD_INT 22
105280: PUSH
105281: LD_INT 23
105283: PUSH
105284: LD_INT 24
105286: PUSH
105287: LD_INT 25
105289: PUSH
105290: LD_INT 26
105292: PUSH
105293: LD_INT 27
105295: PUSH
105296: LD_INT 28
105298: PUSH
105299: LD_INT 30
105301: PUSH
105302: LD_INT 31
105304: PUSH
105305: LD_INT 32
105307: PUSH
105308: LD_INT 33
105310: PUSH
105311: LD_INT 34
105313: PUSH
105314: LD_INT 36
105316: PUSH
105317: EMPTY
105318: LIST
105319: LIST
105320: LIST
105321: LIST
105322: LIST
105323: LIST
105324: LIST
105325: LIST
105326: LIST
105327: LIST
105328: LIST
105329: LIST
105330: LIST
105331: LIST
105332: LIST
105333: LIST
105334: LIST
105335: LIST
105336: LIST
105337: LIST
105338: LIST
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: LIST
105344: LIST
105345: LIST
105346: LIST
105347: LIST
105348: LIST
105349: LIST
105350: LIST
105351: LIST
105352: PUSH
105353: LD_INT 101
105355: PUSH
105356: LD_INT 102
105358: PUSH
105359: LD_INT 103
105361: PUSH
105362: LD_INT 104
105364: PUSH
105365: LD_INT 105
105367: PUSH
105368: LD_INT 106
105370: PUSH
105371: LD_INT 107
105373: PUSH
105374: LD_INT 108
105376: PUSH
105377: LD_INT 109
105379: PUSH
105380: LD_INT 110
105382: PUSH
105383: LD_INT 111
105385: PUSH
105386: LD_INT 112
105388: PUSH
105389: LD_INT 113
105391: PUSH
105392: LD_INT 114
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: LIST
105399: LIST
105400: LIST
105401: LIST
105402: LIST
105403: LIST
105404: LIST
105405: LIST
105406: LIST
105407: LIST
105408: LIST
105409: LIST
105410: PUSH
105411: EMPTY
105412: LIST
105413: LIST
105414: ST_TO_ADDR
105415: GO 106786
105417: LD_INT 13
105419: DOUBLE
105420: EQUAL
105421: IFTRUE 105425
105423: GO 105621
105425: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
105426: LD_ADDR_VAR 0 1
105430: PUSH
105431: LD_INT 1
105433: PUSH
105434: LD_INT 2
105436: PUSH
105437: LD_INT 3
105439: PUSH
105440: LD_INT 4
105442: PUSH
105443: LD_INT 5
105445: PUSH
105446: LD_INT 8
105448: PUSH
105449: LD_INT 9
105451: PUSH
105452: LD_INT 10
105454: PUSH
105455: LD_INT 11
105457: PUSH
105458: LD_INT 12
105460: PUSH
105461: LD_INT 14
105463: PUSH
105464: LD_INT 15
105466: PUSH
105467: LD_INT 16
105469: PUSH
105470: LD_INT 17
105472: PUSH
105473: LD_INT 18
105475: PUSH
105476: LD_INT 19
105478: PUSH
105479: LD_INT 20
105481: PUSH
105482: LD_INT 21
105484: PUSH
105485: LD_INT 22
105487: PUSH
105488: LD_INT 23
105490: PUSH
105491: LD_INT 24
105493: PUSH
105494: LD_INT 25
105496: PUSH
105497: LD_INT 26
105499: PUSH
105500: LD_INT 27
105502: PUSH
105503: LD_INT 28
105505: PUSH
105506: LD_INT 30
105508: PUSH
105509: LD_INT 31
105511: PUSH
105512: LD_INT 32
105514: PUSH
105515: LD_INT 33
105517: PUSH
105518: LD_INT 34
105520: PUSH
105521: LD_INT 36
105523: PUSH
105524: EMPTY
105525: LIST
105526: LIST
105527: LIST
105528: LIST
105529: LIST
105530: LIST
105531: LIST
105532: LIST
105533: LIST
105534: LIST
105535: LIST
105536: LIST
105537: LIST
105538: LIST
105539: LIST
105540: LIST
105541: LIST
105542: LIST
105543: LIST
105544: LIST
105545: LIST
105546: LIST
105547: LIST
105548: LIST
105549: LIST
105550: LIST
105551: LIST
105552: LIST
105553: LIST
105554: LIST
105555: LIST
105556: PUSH
105557: LD_INT 101
105559: PUSH
105560: LD_INT 102
105562: PUSH
105563: LD_INT 103
105565: PUSH
105566: LD_INT 104
105568: PUSH
105569: LD_INT 105
105571: PUSH
105572: LD_INT 106
105574: PUSH
105575: LD_INT 107
105577: PUSH
105578: LD_INT 108
105580: PUSH
105581: LD_INT 109
105583: PUSH
105584: LD_INT 110
105586: PUSH
105587: LD_INT 111
105589: PUSH
105590: LD_INT 112
105592: PUSH
105593: LD_INT 113
105595: PUSH
105596: LD_INT 114
105598: PUSH
105599: EMPTY
105600: LIST
105601: LIST
105602: LIST
105603: LIST
105604: LIST
105605: LIST
105606: LIST
105607: LIST
105608: LIST
105609: LIST
105610: LIST
105611: LIST
105612: LIST
105613: LIST
105614: PUSH
105615: EMPTY
105616: LIST
105617: LIST
105618: ST_TO_ADDR
105619: GO 106786
105621: LD_INT 14
105623: DOUBLE
105624: EQUAL
105625: IFTRUE 105629
105627: GO 105841
105629: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
105630: LD_ADDR_VAR 0 1
105634: PUSH
105635: LD_INT 1
105637: PUSH
105638: LD_INT 2
105640: PUSH
105641: LD_INT 3
105643: PUSH
105644: LD_INT 4
105646: PUSH
105647: LD_INT 5
105649: PUSH
105650: LD_INT 6
105652: PUSH
105653: LD_INT 7
105655: PUSH
105656: LD_INT 8
105658: PUSH
105659: LD_INT 9
105661: PUSH
105662: LD_INT 10
105664: PUSH
105665: LD_INT 11
105667: PUSH
105668: LD_INT 12
105670: PUSH
105671: LD_INT 13
105673: PUSH
105674: LD_INT 14
105676: PUSH
105677: LD_INT 15
105679: PUSH
105680: LD_INT 16
105682: PUSH
105683: LD_INT 17
105685: PUSH
105686: LD_INT 18
105688: PUSH
105689: LD_INT 19
105691: PUSH
105692: LD_INT 20
105694: PUSH
105695: LD_INT 21
105697: PUSH
105698: LD_INT 22
105700: PUSH
105701: LD_INT 23
105703: PUSH
105704: LD_INT 24
105706: PUSH
105707: LD_INT 25
105709: PUSH
105710: LD_INT 26
105712: PUSH
105713: LD_INT 27
105715: PUSH
105716: LD_INT 28
105718: PUSH
105719: LD_INT 29
105721: PUSH
105722: LD_INT 30
105724: PUSH
105725: LD_INT 31
105727: PUSH
105728: LD_INT 32
105730: PUSH
105731: LD_INT 33
105733: PUSH
105734: LD_INT 34
105736: PUSH
105737: LD_INT 36
105739: PUSH
105740: EMPTY
105741: LIST
105742: LIST
105743: LIST
105744: LIST
105745: LIST
105746: LIST
105747: LIST
105748: LIST
105749: LIST
105750: LIST
105751: LIST
105752: LIST
105753: LIST
105754: LIST
105755: LIST
105756: LIST
105757: LIST
105758: LIST
105759: LIST
105760: LIST
105761: LIST
105762: LIST
105763: LIST
105764: LIST
105765: LIST
105766: LIST
105767: LIST
105768: LIST
105769: LIST
105770: LIST
105771: LIST
105772: LIST
105773: LIST
105774: LIST
105775: LIST
105776: PUSH
105777: LD_INT 101
105779: PUSH
105780: LD_INT 102
105782: PUSH
105783: LD_INT 103
105785: PUSH
105786: LD_INT 104
105788: PUSH
105789: LD_INT 105
105791: PUSH
105792: LD_INT 106
105794: PUSH
105795: LD_INT 107
105797: PUSH
105798: LD_INT 108
105800: PUSH
105801: LD_INT 109
105803: PUSH
105804: LD_INT 110
105806: PUSH
105807: LD_INT 111
105809: PUSH
105810: LD_INT 112
105812: PUSH
105813: LD_INT 113
105815: PUSH
105816: LD_INT 114
105818: PUSH
105819: EMPTY
105820: LIST
105821: LIST
105822: LIST
105823: LIST
105824: LIST
105825: LIST
105826: LIST
105827: LIST
105828: LIST
105829: LIST
105830: LIST
105831: LIST
105832: LIST
105833: LIST
105834: PUSH
105835: EMPTY
105836: LIST
105837: LIST
105838: ST_TO_ADDR
105839: GO 106786
105841: LD_INT 15
105843: DOUBLE
105844: EQUAL
105845: IFTRUE 105849
105847: GO 106061
105849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105850: LD_ADDR_VAR 0 1
105854: PUSH
105855: LD_INT 1
105857: PUSH
105858: LD_INT 2
105860: PUSH
105861: LD_INT 3
105863: PUSH
105864: LD_INT 4
105866: PUSH
105867: LD_INT 5
105869: PUSH
105870: LD_INT 6
105872: PUSH
105873: LD_INT 7
105875: PUSH
105876: LD_INT 8
105878: PUSH
105879: LD_INT 9
105881: PUSH
105882: LD_INT 10
105884: PUSH
105885: LD_INT 11
105887: PUSH
105888: LD_INT 12
105890: PUSH
105891: LD_INT 13
105893: PUSH
105894: LD_INT 14
105896: PUSH
105897: LD_INT 15
105899: PUSH
105900: LD_INT 16
105902: PUSH
105903: LD_INT 17
105905: PUSH
105906: LD_INT 18
105908: PUSH
105909: LD_INT 19
105911: PUSH
105912: LD_INT 20
105914: PUSH
105915: LD_INT 21
105917: PUSH
105918: LD_INT 22
105920: PUSH
105921: LD_INT 23
105923: PUSH
105924: LD_INT 24
105926: PUSH
105927: LD_INT 25
105929: PUSH
105930: LD_INT 26
105932: PUSH
105933: LD_INT 27
105935: PUSH
105936: LD_INT 28
105938: PUSH
105939: LD_INT 29
105941: PUSH
105942: LD_INT 30
105944: PUSH
105945: LD_INT 31
105947: PUSH
105948: LD_INT 32
105950: PUSH
105951: LD_INT 33
105953: PUSH
105954: LD_INT 34
105956: PUSH
105957: LD_INT 36
105959: PUSH
105960: EMPTY
105961: LIST
105962: LIST
105963: LIST
105964: LIST
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: LIST
105975: LIST
105976: LIST
105977: LIST
105978: LIST
105979: LIST
105980: LIST
105981: LIST
105982: LIST
105983: LIST
105984: LIST
105985: LIST
105986: LIST
105987: LIST
105988: LIST
105989: LIST
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: LIST
105996: PUSH
105997: LD_INT 101
105999: PUSH
106000: LD_INT 102
106002: PUSH
106003: LD_INT 103
106005: PUSH
106006: LD_INT 104
106008: PUSH
106009: LD_INT 105
106011: PUSH
106012: LD_INT 106
106014: PUSH
106015: LD_INT 107
106017: PUSH
106018: LD_INT 108
106020: PUSH
106021: LD_INT 109
106023: PUSH
106024: LD_INT 110
106026: PUSH
106027: LD_INT 111
106029: PUSH
106030: LD_INT 112
106032: PUSH
106033: LD_INT 113
106035: PUSH
106036: LD_INT 114
106038: PUSH
106039: EMPTY
106040: LIST
106041: LIST
106042: LIST
106043: LIST
106044: LIST
106045: LIST
106046: LIST
106047: LIST
106048: LIST
106049: LIST
106050: LIST
106051: LIST
106052: LIST
106053: LIST
106054: PUSH
106055: EMPTY
106056: LIST
106057: LIST
106058: ST_TO_ADDR
106059: GO 106786
106061: LD_INT 16
106063: DOUBLE
106064: EQUAL
106065: IFTRUE 106069
106067: GO 106193
106069: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
106070: LD_ADDR_VAR 0 1
106074: PUSH
106075: LD_INT 2
106077: PUSH
106078: LD_INT 4
106080: PUSH
106081: LD_INT 5
106083: PUSH
106084: LD_INT 7
106086: PUSH
106087: LD_INT 11
106089: PUSH
106090: LD_INT 12
106092: PUSH
106093: LD_INT 15
106095: PUSH
106096: LD_INT 16
106098: PUSH
106099: LD_INT 20
106101: PUSH
106102: LD_INT 21
106104: PUSH
106105: LD_INT 22
106107: PUSH
106108: LD_INT 23
106110: PUSH
106111: LD_INT 25
106113: PUSH
106114: LD_INT 26
106116: PUSH
106117: LD_INT 30
106119: PUSH
106120: LD_INT 31
106122: PUSH
106123: LD_INT 32
106125: PUSH
106126: LD_INT 33
106128: PUSH
106129: LD_INT 34
106131: PUSH
106132: EMPTY
106133: LIST
106134: LIST
106135: LIST
106136: LIST
106137: LIST
106138: LIST
106139: LIST
106140: LIST
106141: LIST
106142: LIST
106143: LIST
106144: LIST
106145: LIST
106146: LIST
106147: LIST
106148: LIST
106149: LIST
106150: LIST
106151: LIST
106152: PUSH
106153: LD_INT 101
106155: PUSH
106156: LD_INT 102
106158: PUSH
106159: LD_INT 103
106161: PUSH
106162: LD_INT 106
106164: PUSH
106165: LD_INT 108
106167: PUSH
106168: LD_INT 112
106170: PUSH
106171: LD_INT 113
106173: PUSH
106174: LD_INT 114
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: LIST
106181: LIST
106182: LIST
106183: LIST
106184: LIST
106185: LIST
106186: PUSH
106187: EMPTY
106188: LIST
106189: LIST
106190: ST_TO_ADDR
106191: GO 106786
106193: LD_INT 17
106195: DOUBLE
106196: EQUAL
106197: IFTRUE 106201
106199: GO 106413
106201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
106202: LD_ADDR_VAR 0 1
106206: PUSH
106207: LD_INT 1
106209: PUSH
106210: LD_INT 2
106212: PUSH
106213: LD_INT 3
106215: PUSH
106216: LD_INT 4
106218: PUSH
106219: LD_INT 5
106221: PUSH
106222: LD_INT 6
106224: PUSH
106225: LD_INT 7
106227: PUSH
106228: LD_INT 8
106230: PUSH
106231: LD_INT 9
106233: PUSH
106234: LD_INT 10
106236: PUSH
106237: LD_INT 11
106239: PUSH
106240: LD_INT 12
106242: PUSH
106243: LD_INT 13
106245: PUSH
106246: LD_INT 14
106248: PUSH
106249: LD_INT 15
106251: PUSH
106252: LD_INT 16
106254: PUSH
106255: LD_INT 17
106257: PUSH
106258: LD_INT 18
106260: PUSH
106261: LD_INT 19
106263: PUSH
106264: LD_INT 20
106266: PUSH
106267: LD_INT 21
106269: PUSH
106270: LD_INT 22
106272: PUSH
106273: LD_INT 23
106275: PUSH
106276: LD_INT 24
106278: PUSH
106279: LD_INT 25
106281: PUSH
106282: LD_INT 26
106284: PUSH
106285: LD_INT 27
106287: PUSH
106288: LD_INT 28
106290: PUSH
106291: LD_INT 29
106293: PUSH
106294: LD_INT 30
106296: PUSH
106297: LD_INT 31
106299: PUSH
106300: LD_INT 32
106302: PUSH
106303: LD_INT 33
106305: PUSH
106306: LD_INT 34
106308: PUSH
106309: LD_INT 36
106311: PUSH
106312: EMPTY
106313: LIST
106314: LIST
106315: LIST
106316: LIST
106317: LIST
106318: LIST
106319: LIST
106320: LIST
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: LIST
106327: LIST
106328: LIST
106329: LIST
106330: LIST
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: LIST
106336: LIST
106337: LIST
106338: LIST
106339: LIST
106340: LIST
106341: LIST
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: LIST
106347: LIST
106348: PUSH
106349: LD_INT 101
106351: PUSH
106352: LD_INT 102
106354: PUSH
106355: LD_INT 103
106357: PUSH
106358: LD_INT 104
106360: PUSH
106361: LD_INT 105
106363: PUSH
106364: LD_INT 106
106366: PUSH
106367: LD_INT 107
106369: PUSH
106370: LD_INT 108
106372: PUSH
106373: LD_INT 109
106375: PUSH
106376: LD_INT 110
106378: PUSH
106379: LD_INT 111
106381: PUSH
106382: LD_INT 112
106384: PUSH
106385: LD_INT 113
106387: PUSH
106388: LD_INT 114
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: LIST
106395: LIST
106396: LIST
106397: LIST
106398: LIST
106399: LIST
106400: LIST
106401: LIST
106402: LIST
106403: LIST
106404: LIST
106405: LIST
106406: PUSH
106407: EMPTY
106408: LIST
106409: LIST
106410: ST_TO_ADDR
106411: GO 106786
106413: LD_INT 18
106415: DOUBLE
106416: EQUAL
106417: IFTRUE 106421
106419: GO 106557
106421: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
106422: LD_ADDR_VAR 0 1
106426: PUSH
106427: LD_INT 2
106429: PUSH
106430: LD_INT 4
106432: PUSH
106433: LD_INT 5
106435: PUSH
106436: LD_INT 7
106438: PUSH
106439: LD_INT 11
106441: PUSH
106442: LD_INT 12
106444: PUSH
106445: LD_INT 15
106447: PUSH
106448: LD_INT 16
106450: PUSH
106451: LD_INT 20
106453: PUSH
106454: LD_INT 21
106456: PUSH
106457: LD_INT 22
106459: PUSH
106460: LD_INT 23
106462: PUSH
106463: LD_INT 25
106465: PUSH
106466: LD_INT 26
106468: PUSH
106469: LD_INT 30
106471: PUSH
106472: LD_INT 31
106474: PUSH
106475: LD_INT 32
106477: PUSH
106478: LD_INT 33
106480: PUSH
106481: LD_INT 34
106483: PUSH
106484: LD_INT 35
106486: PUSH
106487: LD_INT 36
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: LIST
106494: LIST
106495: LIST
106496: LIST
106497: LIST
106498: LIST
106499: LIST
106500: LIST
106501: LIST
106502: LIST
106503: LIST
106504: LIST
106505: LIST
106506: LIST
106507: LIST
106508: LIST
106509: LIST
106510: LIST
106511: LIST
106512: PUSH
106513: LD_INT 101
106515: PUSH
106516: LD_INT 102
106518: PUSH
106519: LD_INT 103
106521: PUSH
106522: LD_INT 106
106524: PUSH
106525: LD_INT 108
106527: PUSH
106528: LD_INT 112
106530: PUSH
106531: LD_INT 113
106533: PUSH
106534: LD_INT 114
106536: PUSH
106537: LD_INT 115
106539: PUSH
106540: EMPTY
106541: LIST
106542: LIST
106543: LIST
106544: LIST
106545: LIST
106546: LIST
106547: LIST
106548: LIST
106549: LIST
106550: PUSH
106551: EMPTY
106552: LIST
106553: LIST
106554: ST_TO_ADDR
106555: GO 106786
106557: LD_INT 19
106559: DOUBLE
106560: EQUAL
106561: IFTRUE 106565
106563: GO 106785
106565: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
106566: LD_ADDR_VAR 0 1
106570: PUSH
106571: LD_INT 1
106573: PUSH
106574: LD_INT 2
106576: PUSH
106577: LD_INT 3
106579: PUSH
106580: LD_INT 4
106582: PUSH
106583: LD_INT 5
106585: PUSH
106586: LD_INT 6
106588: PUSH
106589: LD_INT 7
106591: PUSH
106592: LD_INT 8
106594: PUSH
106595: LD_INT 9
106597: PUSH
106598: LD_INT 10
106600: PUSH
106601: LD_INT 11
106603: PUSH
106604: LD_INT 12
106606: PUSH
106607: LD_INT 13
106609: PUSH
106610: LD_INT 14
106612: PUSH
106613: LD_INT 15
106615: PUSH
106616: LD_INT 16
106618: PUSH
106619: LD_INT 17
106621: PUSH
106622: LD_INT 18
106624: PUSH
106625: LD_INT 19
106627: PUSH
106628: LD_INT 20
106630: PUSH
106631: LD_INT 21
106633: PUSH
106634: LD_INT 22
106636: PUSH
106637: LD_INT 23
106639: PUSH
106640: LD_INT 24
106642: PUSH
106643: LD_INT 25
106645: PUSH
106646: LD_INT 26
106648: PUSH
106649: LD_INT 27
106651: PUSH
106652: LD_INT 28
106654: PUSH
106655: LD_INT 29
106657: PUSH
106658: LD_INT 30
106660: PUSH
106661: LD_INT 31
106663: PUSH
106664: LD_INT 32
106666: PUSH
106667: LD_INT 33
106669: PUSH
106670: LD_INT 34
106672: PUSH
106673: LD_INT 35
106675: PUSH
106676: LD_INT 36
106678: PUSH
106679: EMPTY
106680: LIST
106681: LIST
106682: LIST
106683: LIST
106684: LIST
106685: LIST
106686: LIST
106687: LIST
106688: LIST
106689: LIST
106690: LIST
106691: LIST
106692: LIST
106693: LIST
106694: LIST
106695: LIST
106696: LIST
106697: LIST
106698: LIST
106699: LIST
106700: LIST
106701: LIST
106702: LIST
106703: LIST
106704: LIST
106705: LIST
106706: LIST
106707: LIST
106708: LIST
106709: LIST
106710: LIST
106711: LIST
106712: LIST
106713: LIST
106714: LIST
106715: LIST
106716: PUSH
106717: LD_INT 101
106719: PUSH
106720: LD_INT 102
106722: PUSH
106723: LD_INT 103
106725: PUSH
106726: LD_INT 104
106728: PUSH
106729: LD_INT 105
106731: PUSH
106732: LD_INT 106
106734: PUSH
106735: LD_INT 107
106737: PUSH
106738: LD_INT 108
106740: PUSH
106741: LD_INT 109
106743: PUSH
106744: LD_INT 110
106746: PUSH
106747: LD_INT 111
106749: PUSH
106750: LD_INT 112
106752: PUSH
106753: LD_INT 113
106755: PUSH
106756: LD_INT 114
106758: PUSH
106759: LD_INT 115
106761: PUSH
106762: EMPTY
106763: LIST
106764: LIST
106765: LIST
106766: LIST
106767: LIST
106768: LIST
106769: LIST
106770: LIST
106771: LIST
106772: LIST
106773: LIST
106774: LIST
106775: LIST
106776: LIST
106777: LIST
106778: PUSH
106779: EMPTY
106780: LIST
106781: LIST
106782: ST_TO_ADDR
106783: GO 106786
106785: POP
// end else
106786: GO 107005
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
106788: LD_ADDR_VAR 0 1
106792: PUSH
106793: LD_INT 1
106795: PUSH
106796: LD_INT 2
106798: PUSH
106799: LD_INT 3
106801: PUSH
106802: LD_INT 4
106804: PUSH
106805: LD_INT 5
106807: PUSH
106808: LD_INT 6
106810: PUSH
106811: LD_INT 7
106813: PUSH
106814: LD_INT 8
106816: PUSH
106817: LD_INT 9
106819: PUSH
106820: LD_INT 10
106822: PUSH
106823: LD_INT 11
106825: PUSH
106826: LD_INT 12
106828: PUSH
106829: LD_INT 13
106831: PUSH
106832: LD_INT 14
106834: PUSH
106835: LD_INT 15
106837: PUSH
106838: LD_INT 16
106840: PUSH
106841: LD_INT 17
106843: PUSH
106844: LD_INT 18
106846: PUSH
106847: LD_INT 19
106849: PUSH
106850: LD_INT 20
106852: PUSH
106853: LD_INT 21
106855: PUSH
106856: LD_INT 22
106858: PUSH
106859: LD_INT 23
106861: PUSH
106862: LD_INT 24
106864: PUSH
106865: LD_INT 25
106867: PUSH
106868: LD_INT 26
106870: PUSH
106871: LD_INT 27
106873: PUSH
106874: LD_INT 28
106876: PUSH
106877: LD_INT 29
106879: PUSH
106880: LD_INT 30
106882: PUSH
106883: LD_INT 31
106885: PUSH
106886: LD_INT 32
106888: PUSH
106889: LD_INT 33
106891: PUSH
106892: LD_INT 34
106894: PUSH
106895: LD_INT 35
106897: PUSH
106898: LD_INT 36
106900: PUSH
106901: EMPTY
106902: LIST
106903: LIST
106904: LIST
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: LIST
106910: LIST
106911: LIST
106912: LIST
106913: LIST
106914: LIST
106915: LIST
106916: LIST
106917: LIST
106918: LIST
106919: LIST
106920: LIST
106921: LIST
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: LIST
106927: LIST
106928: LIST
106929: LIST
106930: LIST
106931: LIST
106932: LIST
106933: LIST
106934: LIST
106935: LIST
106936: LIST
106937: LIST
106938: PUSH
106939: LD_INT 101
106941: PUSH
106942: LD_INT 102
106944: PUSH
106945: LD_INT 103
106947: PUSH
106948: LD_INT 104
106950: PUSH
106951: LD_INT 105
106953: PUSH
106954: LD_INT 106
106956: PUSH
106957: LD_INT 107
106959: PUSH
106960: LD_INT 108
106962: PUSH
106963: LD_INT 109
106965: PUSH
106966: LD_INT 110
106968: PUSH
106969: LD_INT 111
106971: PUSH
106972: LD_INT 112
106974: PUSH
106975: LD_INT 113
106977: PUSH
106978: LD_INT 114
106980: PUSH
106981: LD_INT 115
106983: PUSH
106984: EMPTY
106985: LIST
106986: LIST
106987: LIST
106988: LIST
106989: LIST
106990: LIST
106991: LIST
106992: LIST
106993: LIST
106994: LIST
106995: LIST
106996: LIST
106997: LIST
106998: LIST
106999: LIST
107000: PUSH
107001: EMPTY
107002: LIST
107003: LIST
107004: ST_TO_ADDR
// if result then
107005: LD_VAR 0 1
107009: IFFALSE 107298
// begin normal :=  ;
107011: LD_ADDR_VAR 0 3
107015: PUSH
107016: LD_STRING 
107018: ST_TO_ADDR
// hardcore :=  ;
107019: LD_ADDR_VAR 0 4
107023: PUSH
107024: LD_STRING 
107026: ST_TO_ADDR
// for i = 1 to normalCounter do
107027: LD_ADDR_VAR 0 5
107031: PUSH
107032: DOUBLE
107033: LD_INT 1
107035: DEC
107036: ST_TO_ADDR
107037: LD_EXP 157
107041: PUSH
107042: FOR_TO
107043: IFFALSE 107144
// begin tmp := 0 ;
107045: LD_ADDR_VAR 0 2
107049: PUSH
107050: LD_STRING 0
107052: ST_TO_ADDR
// if result [ 1 ] then
107053: LD_VAR 0 1
107057: PUSH
107058: LD_INT 1
107060: ARRAY
107061: IFFALSE 107126
// if result [ 1 ] [ 1 ] = i then
107063: LD_VAR 0 1
107067: PUSH
107068: LD_INT 1
107070: ARRAY
107071: PUSH
107072: LD_INT 1
107074: ARRAY
107075: PUSH
107076: LD_VAR 0 5
107080: EQUAL
107081: IFFALSE 107126
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
107083: LD_ADDR_VAR 0 1
107087: PUSH
107088: LD_VAR 0 1
107092: PPUSH
107093: LD_INT 1
107095: PPUSH
107096: LD_VAR 0 1
107100: PUSH
107101: LD_INT 1
107103: ARRAY
107104: PPUSH
107105: LD_INT 1
107107: PPUSH
107108: CALL_OW 3
107112: PPUSH
107113: CALL_OW 1
107117: ST_TO_ADDR
// tmp := 1 ;
107118: LD_ADDR_VAR 0 2
107122: PUSH
107123: LD_STRING 1
107125: ST_TO_ADDR
// end ; normal := normal & tmp ;
107126: LD_ADDR_VAR 0 3
107130: PUSH
107131: LD_VAR 0 3
107135: PUSH
107136: LD_VAR 0 2
107140: STR
107141: ST_TO_ADDR
// end ;
107142: GO 107042
107144: POP
107145: POP
// for i = 1 to hardcoreCounter do
107146: LD_ADDR_VAR 0 5
107150: PUSH
107151: DOUBLE
107152: LD_INT 1
107154: DEC
107155: ST_TO_ADDR
107156: LD_EXP 158
107160: PUSH
107161: FOR_TO
107162: IFFALSE 107267
// begin tmp := 0 ;
107164: LD_ADDR_VAR 0 2
107168: PUSH
107169: LD_STRING 0
107171: ST_TO_ADDR
// if result [ 2 ] then
107172: LD_VAR 0 1
107176: PUSH
107177: LD_INT 2
107179: ARRAY
107180: IFFALSE 107249
// if result [ 2 ] [ 1 ] = 100 + i then
107182: LD_VAR 0 1
107186: PUSH
107187: LD_INT 2
107189: ARRAY
107190: PUSH
107191: LD_INT 1
107193: ARRAY
107194: PUSH
107195: LD_INT 100
107197: PUSH
107198: LD_VAR 0 5
107202: PLUS
107203: EQUAL
107204: IFFALSE 107249
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
107206: LD_ADDR_VAR 0 1
107210: PUSH
107211: LD_VAR 0 1
107215: PPUSH
107216: LD_INT 2
107218: PPUSH
107219: LD_VAR 0 1
107223: PUSH
107224: LD_INT 2
107226: ARRAY
107227: PPUSH
107228: LD_INT 1
107230: PPUSH
107231: CALL_OW 3
107235: PPUSH
107236: CALL_OW 1
107240: ST_TO_ADDR
// tmp := 1 ;
107241: LD_ADDR_VAR 0 2
107245: PUSH
107246: LD_STRING 1
107248: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
107249: LD_ADDR_VAR 0 4
107253: PUSH
107254: LD_VAR 0 4
107258: PUSH
107259: LD_VAR 0 2
107263: STR
107264: ST_TO_ADDR
// end ;
107265: GO 107161
107267: POP
107268: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
107269: LD_STRING getStreamItemsFromMission("
107271: PUSH
107272: LD_VAR 0 3
107276: STR
107277: PUSH
107278: LD_STRING ","
107280: STR
107281: PUSH
107282: LD_VAR 0 4
107286: STR
107287: PUSH
107288: LD_STRING ")
107290: STR
107291: PPUSH
107292: CALL_OW 559
// end else
107296: GO 107305
// ToLua ( getStreamItemsFromMission("","") ) ;
107298: LD_STRING getStreamItemsFromMission("","")
107300: PPUSH
107301: CALL_OW 559
// end ;
107305: LD_VAR 0 1
107309: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
107310: LD_EXP 156
107314: PUSH
107315: LD_EXP 161
107319: AND
107320: IFFALSE 107444
107322: GO 107324
107324: DISABLE
107325: LD_INT 0
107327: PPUSH
107328: PPUSH
// begin enable ;
107329: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
107330: LD_ADDR_VAR 0 2
107334: PUSH
107335: LD_INT 22
107337: PUSH
107338: LD_OWVAR 2
107342: PUSH
107343: EMPTY
107344: LIST
107345: LIST
107346: PUSH
107347: LD_INT 2
107349: PUSH
107350: LD_INT 34
107352: PUSH
107353: LD_INT 7
107355: PUSH
107356: EMPTY
107357: LIST
107358: LIST
107359: PUSH
107360: LD_INT 34
107362: PUSH
107363: LD_INT 45
107365: PUSH
107366: EMPTY
107367: LIST
107368: LIST
107369: PUSH
107370: LD_INT 34
107372: PUSH
107373: LD_INT 28
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: PUSH
107380: LD_INT 34
107382: PUSH
107383: LD_INT 47
107385: PUSH
107386: EMPTY
107387: LIST
107388: LIST
107389: PUSH
107390: EMPTY
107391: LIST
107392: LIST
107393: LIST
107394: LIST
107395: LIST
107396: PUSH
107397: EMPTY
107398: LIST
107399: LIST
107400: PPUSH
107401: CALL_OW 69
107405: ST_TO_ADDR
// if not tmp then
107406: LD_VAR 0 2
107410: NOT
107411: IFFALSE 107415
// exit ;
107413: GO 107444
// for i in tmp do
107415: LD_ADDR_VAR 0 1
107419: PUSH
107420: LD_VAR 0 2
107424: PUSH
107425: FOR_IN
107426: IFFALSE 107442
// begin SetLives ( i , 0 ) ;
107428: LD_VAR 0 1
107432: PPUSH
107433: LD_INT 0
107435: PPUSH
107436: CALL_OW 234
// end ;
107440: GO 107425
107442: POP
107443: POP
// end ;
107444: PPOPN 2
107446: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
107447: LD_EXP 156
107451: PUSH
107452: LD_EXP 162
107456: AND
107457: IFFALSE 107541
107459: GO 107461
107461: DISABLE
107462: LD_INT 0
107464: PPUSH
107465: PPUSH
// begin enable ;
107466: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
107467: LD_ADDR_VAR 0 2
107471: PUSH
107472: LD_INT 22
107474: PUSH
107475: LD_OWVAR 2
107479: PUSH
107480: EMPTY
107481: LIST
107482: LIST
107483: PUSH
107484: LD_INT 32
107486: PUSH
107487: LD_INT 3
107489: PUSH
107490: EMPTY
107491: LIST
107492: LIST
107493: PUSH
107494: EMPTY
107495: LIST
107496: LIST
107497: PPUSH
107498: CALL_OW 69
107502: ST_TO_ADDR
// if not tmp then
107503: LD_VAR 0 2
107507: NOT
107508: IFFALSE 107512
// exit ;
107510: GO 107541
// for i in tmp do
107512: LD_ADDR_VAR 0 1
107516: PUSH
107517: LD_VAR 0 2
107521: PUSH
107522: FOR_IN
107523: IFFALSE 107539
// begin SetLives ( i , 0 ) ;
107525: LD_VAR 0 1
107529: PPUSH
107530: LD_INT 0
107532: PPUSH
107533: CALL_OW 234
// end ;
107537: GO 107522
107539: POP
107540: POP
// end ;
107541: PPOPN 2
107543: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
107544: LD_EXP 156
107548: PUSH
107549: LD_EXP 159
107553: AND
107554: IFFALSE 107647
107556: GO 107558
107558: DISABLE
107559: LD_INT 0
107561: PPUSH
// begin enable ;
107562: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
107563: LD_ADDR_VAR 0 1
107567: PUSH
107568: LD_INT 22
107570: PUSH
107571: LD_OWVAR 2
107575: PUSH
107576: EMPTY
107577: LIST
107578: LIST
107579: PUSH
107580: LD_INT 2
107582: PUSH
107583: LD_INT 25
107585: PUSH
107586: LD_INT 5
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PUSH
107593: LD_INT 25
107595: PUSH
107596: LD_INT 9
107598: PUSH
107599: EMPTY
107600: LIST
107601: LIST
107602: PUSH
107603: LD_INT 25
107605: PUSH
107606: LD_INT 8
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: PUSH
107613: EMPTY
107614: LIST
107615: LIST
107616: LIST
107617: LIST
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: PPUSH
107623: CALL_OW 69
107627: PUSH
107628: FOR_IN
107629: IFFALSE 107645
// begin SetClass ( i , 1 ) ;
107631: LD_VAR 0 1
107635: PPUSH
107636: LD_INT 1
107638: PPUSH
107639: CALL_OW 336
// end ;
107643: GO 107628
107645: POP
107646: POP
// end ;
107647: PPOPN 1
107649: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
107650: LD_EXP 156
107654: PUSH
107655: LD_EXP 160
107659: AND
107660: PUSH
107661: LD_OWVAR 65
107665: PUSH
107666: LD_INT 7
107668: LESS
107669: AND
107670: IFFALSE 107684
107672: GO 107674
107674: DISABLE
// begin enable ;
107675: ENABLE
// game_speed := 7 ;
107676: LD_ADDR_OWVAR 65
107680: PUSH
107681: LD_INT 7
107683: ST_TO_ADDR
// end ;
107684: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
107685: LD_EXP 156
107689: PUSH
107690: LD_EXP 163
107694: AND
107695: IFFALSE 107897
107697: GO 107699
107699: DISABLE
107700: LD_INT 0
107702: PPUSH
107703: PPUSH
107704: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107705: LD_ADDR_VAR 0 3
107709: PUSH
107710: LD_INT 81
107712: PUSH
107713: LD_OWVAR 2
107717: PUSH
107718: EMPTY
107719: LIST
107720: LIST
107721: PUSH
107722: LD_INT 21
107724: PUSH
107725: LD_INT 1
107727: PUSH
107728: EMPTY
107729: LIST
107730: LIST
107731: PUSH
107732: EMPTY
107733: LIST
107734: LIST
107735: PPUSH
107736: CALL_OW 69
107740: ST_TO_ADDR
// if not tmp then
107741: LD_VAR 0 3
107745: NOT
107746: IFFALSE 107750
// exit ;
107748: GO 107897
// if tmp > 5 then
107750: LD_VAR 0 3
107754: PUSH
107755: LD_INT 5
107757: GREATER
107758: IFFALSE 107770
// k := 5 else
107760: LD_ADDR_VAR 0 2
107764: PUSH
107765: LD_INT 5
107767: ST_TO_ADDR
107768: GO 107780
// k := tmp ;
107770: LD_ADDR_VAR 0 2
107774: PUSH
107775: LD_VAR 0 3
107779: ST_TO_ADDR
// for i := 1 to k do
107780: LD_ADDR_VAR 0 1
107784: PUSH
107785: DOUBLE
107786: LD_INT 1
107788: DEC
107789: ST_TO_ADDR
107790: LD_VAR 0 2
107794: PUSH
107795: FOR_TO
107796: IFFALSE 107895
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
107798: LD_VAR 0 3
107802: PUSH
107803: LD_VAR 0 1
107807: ARRAY
107808: PPUSH
107809: LD_VAR 0 1
107813: PUSH
107814: LD_INT 4
107816: MOD
107817: PUSH
107818: LD_INT 1
107820: PLUS
107821: PPUSH
107822: CALL_OW 259
107826: PUSH
107827: LD_INT 10
107829: LESS
107830: IFFALSE 107893
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107832: LD_VAR 0 3
107836: PUSH
107837: LD_VAR 0 1
107841: ARRAY
107842: PPUSH
107843: LD_VAR 0 1
107847: PUSH
107848: LD_INT 4
107850: MOD
107851: PUSH
107852: LD_INT 1
107854: PLUS
107855: PPUSH
107856: LD_VAR 0 3
107860: PUSH
107861: LD_VAR 0 1
107865: ARRAY
107866: PPUSH
107867: LD_VAR 0 1
107871: PUSH
107872: LD_INT 4
107874: MOD
107875: PUSH
107876: LD_INT 1
107878: PLUS
107879: PPUSH
107880: CALL_OW 259
107884: PUSH
107885: LD_INT 1
107887: PLUS
107888: PPUSH
107889: CALL_OW 237
107893: GO 107795
107895: POP
107896: POP
// end ;
107897: PPOPN 3
107899: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
107900: LD_EXP 156
107904: PUSH
107905: LD_EXP 164
107909: AND
107910: IFFALSE 107930
107912: GO 107914
107914: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
107915: LD_INT 4
107917: PPUSH
107918: LD_OWVAR 2
107922: PPUSH
107923: LD_INT 0
107925: PPUSH
107926: CALL_OW 324
107930: END
// every 0 0$1 trigger StreamModeActive and sShovel do
107931: LD_EXP 156
107935: PUSH
107936: LD_EXP 193
107940: AND
107941: IFFALSE 107961
107943: GO 107945
107945: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
107946: LD_INT 19
107948: PPUSH
107949: LD_OWVAR 2
107953: PPUSH
107954: LD_INT 0
107956: PPUSH
107957: CALL_OW 324
107961: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
107962: LD_EXP 156
107966: PUSH
107967: LD_EXP 165
107971: AND
107972: IFFALSE 108074
107974: GO 107976
107976: DISABLE
107977: LD_INT 0
107979: PPUSH
107980: PPUSH
// begin enable ;
107981: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107982: LD_ADDR_VAR 0 2
107986: PUSH
107987: LD_INT 22
107989: PUSH
107990: LD_OWVAR 2
107994: PUSH
107995: EMPTY
107996: LIST
107997: LIST
107998: PUSH
107999: LD_INT 2
108001: PUSH
108002: LD_INT 34
108004: PUSH
108005: LD_INT 11
108007: PUSH
108008: EMPTY
108009: LIST
108010: LIST
108011: PUSH
108012: LD_INT 34
108014: PUSH
108015: LD_INT 30
108017: PUSH
108018: EMPTY
108019: LIST
108020: LIST
108021: PUSH
108022: EMPTY
108023: LIST
108024: LIST
108025: LIST
108026: PUSH
108027: EMPTY
108028: LIST
108029: LIST
108030: PPUSH
108031: CALL_OW 69
108035: ST_TO_ADDR
// if not tmp then
108036: LD_VAR 0 2
108040: NOT
108041: IFFALSE 108045
// exit ;
108043: GO 108074
// for i in tmp do
108045: LD_ADDR_VAR 0 1
108049: PUSH
108050: LD_VAR 0 2
108054: PUSH
108055: FOR_IN
108056: IFFALSE 108072
// begin SetLives ( i , 0 ) ;
108058: LD_VAR 0 1
108062: PPUSH
108063: LD_INT 0
108065: PPUSH
108066: CALL_OW 234
// end ;
108070: GO 108055
108072: POP
108073: POP
// end ;
108074: PPOPN 2
108076: END
// every 0 0$1 trigger StreamModeActive and sBunker do
108077: LD_EXP 156
108081: PUSH
108082: LD_EXP 166
108086: AND
108087: IFFALSE 108107
108089: GO 108091
108091: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
108092: LD_INT 32
108094: PPUSH
108095: LD_OWVAR 2
108099: PPUSH
108100: LD_INT 0
108102: PPUSH
108103: CALL_OW 324
108107: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
108108: LD_EXP 156
108112: PUSH
108113: LD_EXP 167
108117: AND
108118: IFFALSE 108299
108120: GO 108122
108122: DISABLE
108123: LD_INT 0
108125: PPUSH
108126: PPUSH
108127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
108128: LD_ADDR_VAR 0 2
108132: PUSH
108133: LD_INT 22
108135: PUSH
108136: LD_OWVAR 2
108140: PUSH
108141: EMPTY
108142: LIST
108143: LIST
108144: PUSH
108145: LD_INT 33
108147: PUSH
108148: LD_INT 3
108150: PUSH
108151: EMPTY
108152: LIST
108153: LIST
108154: PUSH
108155: EMPTY
108156: LIST
108157: LIST
108158: PPUSH
108159: CALL_OW 69
108163: ST_TO_ADDR
// if not tmp then
108164: LD_VAR 0 2
108168: NOT
108169: IFFALSE 108173
// exit ;
108171: GO 108299
// side := 0 ;
108173: LD_ADDR_VAR 0 3
108177: PUSH
108178: LD_INT 0
108180: ST_TO_ADDR
// for i := 1 to 8 do
108181: LD_ADDR_VAR 0 1
108185: PUSH
108186: DOUBLE
108187: LD_INT 1
108189: DEC
108190: ST_TO_ADDR
108191: LD_INT 8
108193: PUSH
108194: FOR_TO
108195: IFFALSE 108243
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
108197: LD_OWVAR 2
108201: PUSH
108202: LD_VAR 0 1
108206: NONEQUAL
108207: PUSH
108208: LD_OWVAR 2
108212: PPUSH
108213: LD_VAR 0 1
108217: PPUSH
108218: CALL_OW 81
108222: PUSH
108223: LD_INT 2
108225: EQUAL
108226: AND
108227: IFFALSE 108241
// begin side := i ;
108229: LD_ADDR_VAR 0 3
108233: PUSH
108234: LD_VAR 0 1
108238: ST_TO_ADDR
// break ;
108239: GO 108243
// end ;
108241: GO 108194
108243: POP
108244: POP
// if not side then
108245: LD_VAR 0 3
108249: NOT
108250: IFFALSE 108254
// exit ;
108252: GO 108299
// for i := 1 to tmp do
108254: LD_ADDR_VAR 0 1
108258: PUSH
108259: DOUBLE
108260: LD_INT 1
108262: DEC
108263: ST_TO_ADDR
108264: LD_VAR 0 2
108268: PUSH
108269: FOR_TO
108270: IFFALSE 108297
// if Prob ( 60 ) then
108272: LD_INT 60
108274: PPUSH
108275: CALL_OW 13
108279: IFFALSE 108295
// SetSide ( i , side ) ;
108281: LD_VAR 0 1
108285: PPUSH
108286: LD_VAR 0 3
108290: PPUSH
108291: CALL_OW 235
108295: GO 108269
108297: POP
108298: POP
// end ;
108299: PPOPN 3
108301: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
108302: LD_EXP 156
108306: PUSH
108307: LD_EXP 169
108311: AND
108312: IFFALSE 108431
108314: GO 108316
108316: DISABLE
108317: LD_INT 0
108319: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
108320: LD_ADDR_VAR 0 1
108324: PUSH
108325: LD_INT 22
108327: PUSH
108328: LD_OWVAR 2
108332: PUSH
108333: EMPTY
108334: LIST
108335: LIST
108336: PUSH
108337: LD_INT 21
108339: PUSH
108340: LD_INT 1
108342: PUSH
108343: EMPTY
108344: LIST
108345: LIST
108346: PUSH
108347: LD_INT 3
108349: PUSH
108350: LD_INT 23
108352: PUSH
108353: LD_INT 0
108355: PUSH
108356: EMPTY
108357: LIST
108358: LIST
108359: PUSH
108360: EMPTY
108361: LIST
108362: LIST
108363: PUSH
108364: EMPTY
108365: LIST
108366: LIST
108367: LIST
108368: PPUSH
108369: CALL_OW 69
108373: PUSH
108374: FOR_IN
108375: IFFALSE 108429
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
108377: LD_VAR 0 1
108381: PPUSH
108382: CALL_OW 257
108386: PUSH
108387: LD_INT 1
108389: PUSH
108390: LD_INT 2
108392: PUSH
108393: LD_INT 3
108395: PUSH
108396: LD_INT 4
108398: PUSH
108399: EMPTY
108400: LIST
108401: LIST
108402: LIST
108403: LIST
108404: IN
108405: IFFALSE 108427
// SetClass ( un , rand ( 1 , 4 ) ) ;
108407: LD_VAR 0 1
108411: PPUSH
108412: LD_INT 1
108414: PPUSH
108415: LD_INT 4
108417: PPUSH
108418: CALL_OW 12
108422: PPUSH
108423: CALL_OW 336
108427: GO 108374
108429: POP
108430: POP
// end ;
108431: PPOPN 1
108433: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
108434: LD_EXP 156
108438: PUSH
108439: LD_EXP 168
108443: AND
108444: IFFALSE 108523
108446: GO 108448
108448: DISABLE
108449: LD_INT 0
108451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108452: LD_ADDR_VAR 0 1
108456: PUSH
108457: LD_INT 22
108459: PUSH
108460: LD_OWVAR 2
108464: PUSH
108465: EMPTY
108466: LIST
108467: LIST
108468: PUSH
108469: LD_INT 21
108471: PUSH
108472: LD_INT 3
108474: PUSH
108475: EMPTY
108476: LIST
108477: LIST
108478: PUSH
108479: EMPTY
108480: LIST
108481: LIST
108482: PPUSH
108483: CALL_OW 69
108487: ST_TO_ADDR
// if not tmp then
108488: LD_VAR 0 1
108492: NOT
108493: IFFALSE 108497
// exit ;
108495: GO 108523
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
108497: LD_VAR 0 1
108501: PUSH
108502: LD_INT 1
108504: PPUSH
108505: LD_VAR 0 1
108509: PPUSH
108510: CALL_OW 12
108514: ARRAY
108515: PPUSH
108516: LD_INT 100
108518: PPUSH
108519: CALL_OW 234
// end ;
108523: PPOPN 1
108525: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
108526: LD_EXP 156
108530: PUSH
108531: LD_EXP 170
108535: AND
108536: IFFALSE 108634
108538: GO 108540
108540: DISABLE
108541: LD_INT 0
108543: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108544: LD_ADDR_VAR 0 1
108548: PUSH
108549: LD_INT 22
108551: PUSH
108552: LD_OWVAR 2
108556: PUSH
108557: EMPTY
108558: LIST
108559: LIST
108560: PUSH
108561: LD_INT 21
108563: PUSH
108564: LD_INT 1
108566: PUSH
108567: EMPTY
108568: LIST
108569: LIST
108570: PUSH
108571: EMPTY
108572: LIST
108573: LIST
108574: PPUSH
108575: CALL_OW 69
108579: ST_TO_ADDR
// if not tmp then
108580: LD_VAR 0 1
108584: NOT
108585: IFFALSE 108589
// exit ;
108587: GO 108634
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
108589: LD_VAR 0 1
108593: PUSH
108594: LD_INT 1
108596: PPUSH
108597: LD_VAR 0 1
108601: PPUSH
108602: CALL_OW 12
108606: ARRAY
108607: PPUSH
108608: LD_INT 1
108610: PPUSH
108611: LD_INT 4
108613: PPUSH
108614: CALL_OW 12
108618: PPUSH
108619: LD_INT 3000
108621: PPUSH
108622: LD_INT 9000
108624: PPUSH
108625: CALL_OW 12
108629: PPUSH
108630: CALL_OW 492
// end ;
108634: PPOPN 1
108636: END
// every 0 0$1 trigger StreamModeActive and sDepot do
108637: LD_EXP 156
108641: PUSH
108642: LD_EXP 171
108646: AND
108647: IFFALSE 108667
108649: GO 108651
108651: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
108652: LD_INT 1
108654: PPUSH
108655: LD_OWVAR 2
108659: PPUSH
108660: LD_INT 0
108662: PPUSH
108663: CALL_OW 324
108667: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
108668: LD_EXP 156
108672: PUSH
108673: LD_EXP 172
108677: AND
108678: IFFALSE 108761
108680: GO 108682
108682: DISABLE
108683: LD_INT 0
108685: PPUSH
108686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108687: LD_ADDR_VAR 0 2
108691: PUSH
108692: LD_INT 22
108694: PUSH
108695: LD_OWVAR 2
108699: PUSH
108700: EMPTY
108701: LIST
108702: LIST
108703: PUSH
108704: LD_INT 21
108706: PUSH
108707: LD_INT 3
108709: PUSH
108710: EMPTY
108711: LIST
108712: LIST
108713: PUSH
108714: EMPTY
108715: LIST
108716: LIST
108717: PPUSH
108718: CALL_OW 69
108722: ST_TO_ADDR
// if not tmp then
108723: LD_VAR 0 2
108727: NOT
108728: IFFALSE 108732
// exit ;
108730: GO 108761
// for i in tmp do
108732: LD_ADDR_VAR 0 1
108736: PUSH
108737: LD_VAR 0 2
108741: PUSH
108742: FOR_IN
108743: IFFALSE 108759
// SetBLevel ( i , 10 ) ;
108745: LD_VAR 0 1
108749: PPUSH
108750: LD_INT 10
108752: PPUSH
108753: CALL_OW 241
108757: GO 108742
108759: POP
108760: POP
// end ;
108761: PPOPN 2
108763: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
108764: LD_EXP 156
108768: PUSH
108769: LD_EXP 173
108773: AND
108774: IFFALSE 108885
108776: GO 108778
108778: DISABLE
108779: LD_INT 0
108781: PPUSH
108782: PPUSH
108783: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108784: LD_ADDR_VAR 0 3
108788: PUSH
108789: LD_INT 22
108791: PUSH
108792: LD_OWVAR 2
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: PUSH
108801: LD_INT 25
108803: PUSH
108804: LD_INT 1
108806: PUSH
108807: EMPTY
108808: LIST
108809: LIST
108810: PUSH
108811: EMPTY
108812: LIST
108813: LIST
108814: PPUSH
108815: CALL_OW 69
108819: ST_TO_ADDR
// if not tmp then
108820: LD_VAR 0 3
108824: NOT
108825: IFFALSE 108829
// exit ;
108827: GO 108885
// un := tmp [ rand ( 1 , tmp ) ] ;
108829: LD_ADDR_VAR 0 2
108833: PUSH
108834: LD_VAR 0 3
108838: PUSH
108839: LD_INT 1
108841: PPUSH
108842: LD_VAR 0 3
108846: PPUSH
108847: CALL_OW 12
108851: ARRAY
108852: ST_TO_ADDR
// if Crawls ( un ) then
108853: LD_VAR 0 2
108857: PPUSH
108858: CALL_OW 318
108862: IFFALSE 108873
// ComWalk ( un ) ;
108864: LD_VAR 0 2
108868: PPUSH
108869: CALL_OW 138
// SetClass ( un , class_sniper ) ;
108873: LD_VAR 0 2
108877: PPUSH
108878: LD_INT 5
108880: PPUSH
108881: CALL_OW 336
// end ;
108885: PPOPN 3
108887: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
108888: LD_EXP 156
108892: PUSH
108893: LD_EXP 174
108897: AND
108898: PUSH
108899: LD_OWVAR 67
108903: PUSH
108904: LD_INT 3
108906: LESS
108907: AND
108908: IFFALSE 108927
108910: GO 108912
108912: DISABLE
// Difficulty := Difficulty + 1 ;
108913: LD_ADDR_OWVAR 67
108917: PUSH
108918: LD_OWVAR 67
108922: PUSH
108923: LD_INT 1
108925: PLUS
108926: ST_TO_ADDR
108927: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
108928: LD_EXP 156
108932: PUSH
108933: LD_EXP 175
108937: AND
108938: IFFALSE 109041
108940: GO 108942
108942: DISABLE
108943: LD_INT 0
108945: PPUSH
// begin for i := 1 to 5 do
108946: LD_ADDR_VAR 0 1
108950: PUSH
108951: DOUBLE
108952: LD_INT 1
108954: DEC
108955: ST_TO_ADDR
108956: LD_INT 5
108958: PUSH
108959: FOR_TO
108960: IFFALSE 109039
// begin uc_nation := nation_nature ;
108962: LD_ADDR_OWVAR 21
108966: PUSH
108967: LD_INT 0
108969: ST_TO_ADDR
// uc_side := 0 ;
108970: LD_ADDR_OWVAR 20
108974: PUSH
108975: LD_INT 0
108977: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108978: LD_ADDR_OWVAR 29
108982: PUSH
108983: LD_INT 12
108985: PUSH
108986: LD_INT 12
108988: PUSH
108989: EMPTY
108990: LIST
108991: LIST
108992: ST_TO_ADDR
// hc_agressivity := 20 ;
108993: LD_ADDR_OWVAR 35
108997: PUSH
108998: LD_INT 20
109000: ST_TO_ADDR
// hc_class := class_tiger ;
109001: LD_ADDR_OWVAR 28
109005: PUSH
109006: LD_INT 14
109008: ST_TO_ADDR
// hc_gallery :=  ;
109009: LD_ADDR_OWVAR 33
109013: PUSH
109014: LD_STRING 
109016: ST_TO_ADDR
// hc_name :=  ;
109017: LD_ADDR_OWVAR 26
109021: PUSH
109022: LD_STRING 
109024: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
109025: CALL_OW 44
109029: PPUSH
109030: LD_INT 0
109032: PPUSH
109033: CALL_OW 51
// end ;
109037: GO 108959
109039: POP
109040: POP
// end ;
109041: PPOPN 1
109043: END
// every 0 0$1 trigger StreamModeActive and sBomb do
109044: LD_EXP 156
109048: PUSH
109049: LD_EXP 176
109053: AND
109054: IFFALSE 109063
109056: GO 109058
109058: DISABLE
// StreamSibBomb ;
109059: CALL 109064 0 0
109063: END
// export function StreamSibBomb ; var i , x , y ; begin
109064: LD_INT 0
109066: PPUSH
109067: PPUSH
109068: PPUSH
109069: PPUSH
// result := false ;
109070: LD_ADDR_VAR 0 1
109074: PUSH
109075: LD_INT 0
109077: ST_TO_ADDR
// for i := 1 to 16 do
109078: LD_ADDR_VAR 0 2
109082: PUSH
109083: DOUBLE
109084: LD_INT 1
109086: DEC
109087: ST_TO_ADDR
109088: LD_INT 16
109090: PUSH
109091: FOR_TO
109092: IFFALSE 109291
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109094: LD_ADDR_VAR 0 3
109098: PUSH
109099: LD_INT 10
109101: PUSH
109102: LD_INT 20
109104: PUSH
109105: LD_INT 30
109107: PUSH
109108: LD_INT 40
109110: PUSH
109111: LD_INT 50
109113: PUSH
109114: LD_INT 60
109116: PUSH
109117: LD_INT 70
109119: PUSH
109120: LD_INT 80
109122: PUSH
109123: LD_INT 90
109125: PUSH
109126: LD_INT 100
109128: PUSH
109129: LD_INT 110
109131: PUSH
109132: LD_INT 120
109134: PUSH
109135: LD_INT 130
109137: PUSH
109138: LD_INT 140
109140: PUSH
109141: LD_INT 150
109143: PUSH
109144: EMPTY
109145: LIST
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: PUSH
109161: LD_INT 1
109163: PPUSH
109164: LD_INT 15
109166: PPUSH
109167: CALL_OW 12
109171: ARRAY
109172: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109173: LD_ADDR_VAR 0 4
109177: PUSH
109178: LD_INT 10
109180: PUSH
109181: LD_INT 20
109183: PUSH
109184: LD_INT 30
109186: PUSH
109187: LD_INT 40
109189: PUSH
109190: LD_INT 50
109192: PUSH
109193: LD_INT 60
109195: PUSH
109196: LD_INT 70
109198: PUSH
109199: LD_INT 80
109201: PUSH
109202: LD_INT 90
109204: PUSH
109205: LD_INT 100
109207: PUSH
109208: LD_INT 110
109210: PUSH
109211: LD_INT 120
109213: PUSH
109214: LD_INT 130
109216: PUSH
109217: LD_INT 140
109219: PUSH
109220: LD_INT 150
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: LIST
109227: LIST
109228: LIST
109229: LIST
109230: LIST
109231: LIST
109232: LIST
109233: LIST
109234: LIST
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: PUSH
109240: LD_INT 1
109242: PPUSH
109243: LD_INT 15
109245: PPUSH
109246: CALL_OW 12
109250: ARRAY
109251: ST_TO_ADDR
// if ValidHex ( x , y ) then
109252: LD_VAR 0 3
109256: PPUSH
109257: LD_VAR 0 4
109261: PPUSH
109262: CALL_OW 488
109266: IFFALSE 109289
// begin result := [ x , y ] ;
109268: LD_ADDR_VAR 0 1
109272: PUSH
109273: LD_VAR 0 3
109277: PUSH
109278: LD_VAR 0 4
109282: PUSH
109283: EMPTY
109284: LIST
109285: LIST
109286: ST_TO_ADDR
// break ;
109287: GO 109291
// end ; end ;
109289: GO 109091
109291: POP
109292: POP
// if result then
109293: LD_VAR 0 1
109297: IFFALSE 109357
// begin ToLua ( playSibBomb() ) ;
109299: LD_STRING playSibBomb()
109301: PPUSH
109302: CALL_OW 559
// wait ( 0 0$14 ) ;
109306: LD_INT 490
109308: PPUSH
109309: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
109313: LD_VAR 0 1
109317: PUSH
109318: LD_INT 1
109320: ARRAY
109321: PPUSH
109322: LD_VAR 0 1
109326: PUSH
109327: LD_INT 2
109329: ARRAY
109330: PPUSH
109331: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
109335: LD_VAR 0 1
109339: PUSH
109340: LD_INT 1
109342: ARRAY
109343: PPUSH
109344: LD_VAR 0 1
109348: PUSH
109349: LD_INT 2
109351: ARRAY
109352: PPUSH
109353: CALL_OW 429
// end ; end ;
109357: LD_VAR 0 1
109361: RET
// every 0 0$1 trigger StreamModeActive and sReset do
109362: LD_EXP 156
109366: PUSH
109367: LD_EXP 178
109371: AND
109372: IFFALSE 109384
109374: GO 109376
109376: DISABLE
// YouLost (  ) ;
109377: LD_STRING 
109379: PPUSH
109380: CALL_OW 104
109384: END
// every 0 0$1 trigger StreamModeActive and sFog do
109385: LD_EXP 156
109389: PUSH
109390: LD_EXP 177
109394: AND
109395: IFFALSE 109409
109397: GO 109399
109399: DISABLE
// FogOff ( your_side ) ;
109400: LD_OWVAR 2
109404: PPUSH
109405: CALL_OW 344
109409: END
// every 0 0$1 trigger StreamModeActive and sSun do
109410: LD_EXP 156
109414: PUSH
109415: LD_EXP 179
109419: AND
109420: IFFALSE 109448
109422: GO 109424
109424: DISABLE
// begin solar_recharge_percent := 0 ;
109425: LD_ADDR_OWVAR 79
109429: PUSH
109430: LD_INT 0
109432: ST_TO_ADDR
// wait ( 5 5$00 ) ;
109433: LD_INT 10500
109435: PPUSH
109436: CALL_OW 67
// solar_recharge_percent := 100 ;
109440: LD_ADDR_OWVAR 79
109444: PUSH
109445: LD_INT 100
109447: ST_TO_ADDR
// end ;
109448: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
109449: LD_EXP 156
109453: PUSH
109454: LD_EXP 180
109458: AND
109459: IFFALSE 109698
109461: GO 109463
109463: DISABLE
109464: LD_INT 0
109466: PPUSH
109467: PPUSH
109468: PPUSH
// begin tmp := [ ] ;
109469: LD_ADDR_VAR 0 3
109473: PUSH
109474: EMPTY
109475: ST_TO_ADDR
// for i := 1 to 6 do
109476: LD_ADDR_VAR 0 1
109480: PUSH
109481: DOUBLE
109482: LD_INT 1
109484: DEC
109485: ST_TO_ADDR
109486: LD_INT 6
109488: PUSH
109489: FOR_TO
109490: IFFALSE 109595
// begin uc_nation := nation_nature ;
109492: LD_ADDR_OWVAR 21
109496: PUSH
109497: LD_INT 0
109499: ST_TO_ADDR
// uc_side := 0 ;
109500: LD_ADDR_OWVAR 20
109504: PUSH
109505: LD_INT 0
109507: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109508: LD_ADDR_OWVAR 29
109512: PUSH
109513: LD_INT 12
109515: PUSH
109516: LD_INT 12
109518: PUSH
109519: EMPTY
109520: LIST
109521: LIST
109522: ST_TO_ADDR
// hc_agressivity := 20 ;
109523: LD_ADDR_OWVAR 35
109527: PUSH
109528: LD_INT 20
109530: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
109531: LD_ADDR_OWVAR 28
109535: PUSH
109536: LD_INT 17
109538: ST_TO_ADDR
// hc_gallery :=  ;
109539: LD_ADDR_OWVAR 33
109543: PUSH
109544: LD_STRING 
109546: ST_TO_ADDR
// hc_name :=  ;
109547: LD_ADDR_OWVAR 26
109551: PUSH
109552: LD_STRING 
109554: ST_TO_ADDR
// un := CreateHuman ;
109555: LD_ADDR_VAR 0 2
109559: PUSH
109560: CALL_OW 44
109564: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
109565: LD_VAR 0 2
109569: PPUSH
109570: LD_INT 1
109572: PPUSH
109573: CALL_OW 51
// tmp := tmp ^ un ;
109577: LD_ADDR_VAR 0 3
109581: PUSH
109582: LD_VAR 0 3
109586: PUSH
109587: LD_VAR 0 2
109591: ADD
109592: ST_TO_ADDR
// end ;
109593: GO 109489
109595: POP
109596: POP
// repeat wait ( 0 0$1 ) ;
109597: LD_INT 35
109599: PPUSH
109600: CALL_OW 67
// for un in tmp do
109604: LD_ADDR_VAR 0 2
109608: PUSH
109609: LD_VAR 0 3
109613: PUSH
109614: FOR_IN
109615: IFFALSE 109689
// begin if IsDead ( un ) then
109617: LD_VAR 0 2
109621: PPUSH
109622: CALL_OW 301
109626: IFFALSE 109646
// begin tmp := tmp diff un ;
109628: LD_ADDR_VAR 0 3
109632: PUSH
109633: LD_VAR 0 3
109637: PUSH
109638: LD_VAR 0 2
109642: DIFF
109643: ST_TO_ADDR
// continue ;
109644: GO 109614
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
109646: LD_VAR 0 2
109650: PPUSH
109651: LD_INT 3
109653: PUSH
109654: LD_INT 22
109656: PUSH
109657: LD_INT 0
109659: PUSH
109660: EMPTY
109661: LIST
109662: LIST
109663: PUSH
109664: EMPTY
109665: LIST
109666: LIST
109667: PPUSH
109668: CALL_OW 69
109672: PPUSH
109673: LD_VAR 0 2
109677: PPUSH
109678: CALL_OW 74
109682: PPUSH
109683: CALL_OW 115
// end ;
109687: GO 109614
109689: POP
109690: POP
// until not tmp ;
109691: LD_VAR 0 3
109695: NOT
109696: IFFALSE 109597
// end ;
109698: PPOPN 3
109700: END
// every 0 0$1 trigger StreamModeActive and sTroll do
109701: LD_EXP 156
109705: PUSH
109706: LD_EXP 181
109710: AND
109711: IFFALSE 109765
109713: GO 109715
109715: DISABLE
// begin ToLua ( displayTroll(); ) ;
109716: LD_STRING displayTroll();
109718: PPUSH
109719: CALL_OW 559
// wait ( 3 3$00 ) ;
109723: LD_INT 6300
109725: PPUSH
109726: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109730: LD_STRING hideTroll();
109732: PPUSH
109733: CALL_OW 559
// wait ( 1 1$00 ) ;
109737: LD_INT 2100
109739: PPUSH
109740: CALL_OW 67
// ToLua ( displayTroll(); ) ;
109744: LD_STRING displayTroll();
109746: PPUSH
109747: CALL_OW 559
// wait ( 1 1$00 ) ;
109751: LD_INT 2100
109753: PPUSH
109754: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109758: LD_STRING hideTroll();
109760: PPUSH
109761: CALL_OW 559
// end ;
109765: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
109766: LD_EXP 156
109770: PUSH
109771: LD_EXP 182
109775: AND
109776: IFFALSE 109839
109778: GO 109780
109780: DISABLE
109781: LD_INT 0
109783: PPUSH
// begin p := 0 ;
109784: LD_ADDR_VAR 0 1
109788: PUSH
109789: LD_INT 0
109791: ST_TO_ADDR
// repeat game_speed := 1 ;
109792: LD_ADDR_OWVAR 65
109796: PUSH
109797: LD_INT 1
109799: ST_TO_ADDR
// wait ( 0 0$1 ) ;
109800: LD_INT 35
109802: PPUSH
109803: CALL_OW 67
// p := p + 1 ;
109807: LD_ADDR_VAR 0 1
109811: PUSH
109812: LD_VAR 0 1
109816: PUSH
109817: LD_INT 1
109819: PLUS
109820: ST_TO_ADDR
// until p >= 60 ;
109821: LD_VAR 0 1
109825: PUSH
109826: LD_INT 60
109828: GREATEREQUAL
109829: IFFALSE 109792
// game_speed := 4 ;
109831: LD_ADDR_OWVAR 65
109835: PUSH
109836: LD_INT 4
109838: ST_TO_ADDR
// end ;
109839: PPOPN 1
109841: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109842: LD_EXP 156
109846: PUSH
109847: LD_EXP 183
109851: AND
109852: IFFALSE 109998
109854: GO 109856
109856: DISABLE
109857: LD_INT 0
109859: PPUSH
109860: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109861: LD_ADDR_VAR 0 1
109865: PUSH
109866: LD_INT 22
109868: PUSH
109869: LD_OWVAR 2
109873: PUSH
109874: EMPTY
109875: LIST
109876: LIST
109877: PUSH
109878: LD_INT 2
109880: PUSH
109881: LD_INT 30
109883: PUSH
109884: LD_INT 0
109886: PUSH
109887: EMPTY
109888: LIST
109889: LIST
109890: PUSH
109891: LD_INT 30
109893: PUSH
109894: LD_INT 1
109896: PUSH
109897: EMPTY
109898: LIST
109899: LIST
109900: PUSH
109901: EMPTY
109902: LIST
109903: LIST
109904: LIST
109905: PUSH
109906: EMPTY
109907: LIST
109908: LIST
109909: PPUSH
109910: CALL_OW 69
109914: ST_TO_ADDR
// if not depot then
109915: LD_VAR 0 1
109919: NOT
109920: IFFALSE 109924
// exit ;
109922: GO 109998
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
109924: LD_ADDR_VAR 0 2
109928: PUSH
109929: LD_VAR 0 1
109933: PUSH
109934: LD_INT 1
109936: PPUSH
109937: LD_VAR 0 1
109941: PPUSH
109942: CALL_OW 12
109946: ARRAY
109947: PPUSH
109948: CALL_OW 274
109952: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
109953: LD_VAR 0 2
109957: PPUSH
109958: LD_INT 1
109960: PPUSH
109961: LD_INT 0
109963: PPUSH
109964: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
109968: LD_VAR 0 2
109972: PPUSH
109973: LD_INT 2
109975: PPUSH
109976: LD_INT 0
109978: PPUSH
109979: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109983: LD_VAR 0 2
109987: PPUSH
109988: LD_INT 3
109990: PPUSH
109991: LD_INT 0
109993: PPUSH
109994: CALL_OW 277
// end ;
109998: PPOPN 2
110000: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
110001: LD_EXP 156
110005: PUSH
110006: LD_EXP 184
110010: AND
110011: IFFALSE 110108
110013: GO 110015
110015: DISABLE
110016: LD_INT 0
110018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110019: LD_ADDR_VAR 0 1
110023: PUSH
110024: LD_INT 22
110026: PUSH
110027: LD_OWVAR 2
110031: PUSH
110032: EMPTY
110033: LIST
110034: LIST
110035: PUSH
110036: LD_INT 21
110038: PUSH
110039: LD_INT 1
110041: PUSH
110042: EMPTY
110043: LIST
110044: LIST
110045: PUSH
110046: LD_INT 3
110048: PUSH
110049: LD_INT 23
110051: PUSH
110052: LD_INT 0
110054: PUSH
110055: EMPTY
110056: LIST
110057: LIST
110058: PUSH
110059: EMPTY
110060: LIST
110061: LIST
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: LIST
110067: PPUSH
110068: CALL_OW 69
110072: ST_TO_ADDR
// if not tmp then
110073: LD_VAR 0 1
110077: NOT
110078: IFFALSE 110082
// exit ;
110080: GO 110108
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
110082: LD_VAR 0 1
110086: PUSH
110087: LD_INT 1
110089: PPUSH
110090: LD_VAR 0 1
110094: PPUSH
110095: CALL_OW 12
110099: ARRAY
110100: PPUSH
110101: LD_INT 200
110103: PPUSH
110104: CALL_OW 234
// end ;
110108: PPOPN 1
110110: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
110111: LD_EXP 156
110115: PUSH
110116: LD_EXP 185
110120: AND
110121: IFFALSE 110200
110123: GO 110125
110125: DISABLE
110126: LD_INT 0
110128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
110129: LD_ADDR_VAR 0 1
110133: PUSH
110134: LD_INT 22
110136: PUSH
110137: LD_OWVAR 2
110141: PUSH
110142: EMPTY
110143: LIST
110144: LIST
110145: PUSH
110146: LD_INT 21
110148: PUSH
110149: LD_INT 2
110151: PUSH
110152: EMPTY
110153: LIST
110154: LIST
110155: PUSH
110156: EMPTY
110157: LIST
110158: LIST
110159: PPUSH
110160: CALL_OW 69
110164: ST_TO_ADDR
// if not tmp then
110165: LD_VAR 0 1
110169: NOT
110170: IFFALSE 110174
// exit ;
110172: GO 110200
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
110174: LD_VAR 0 1
110178: PUSH
110179: LD_INT 1
110181: PPUSH
110182: LD_VAR 0 1
110186: PPUSH
110187: CALL_OW 12
110191: ARRAY
110192: PPUSH
110193: LD_INT 60
110195: PPUSH
110196: CALL_OW 234
// end ;
110200: PPOPN 1
110202: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
110203: LD_EXP 156
110207: PUSH
110208: LD_EXP 186
110212: AND
110213: IFFALSE 110312
110215: GO 110217
110217: DISABLE
110218: LD_INT 0
110220: PPUSH
110221: PPUSH
// begin enable ;
110222: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
110223: LD_ADDR_VAR 0 1
110227: PUSH
110228: LD_INT 22
110230: PUSH
110231: LD_OWVAR 2
110235: PUSH
110236: EMPTY
110237: LIST
110238: LIST
110239: PUSH
110240: LD_INT 61
110242: PUSH
110243: EMPTY
110244: LIST
110245: PUSH
110246: LD_INT 33
110248: PUSH
110249: LD_INT 2
110251: PUSH
110252: EMPTY
110253: LIST
110254: LIST
110255: PUSH
110256: EMPTY
110257: LIST
110258: LIST
110259: LIST
110260: PPUSH
110261: CALL_OW 69
110265: ST_TO_ADDR
// if not tmp then
110266: LD_VAR 0 1
110270: NOT
110271: IFFALSE 110275
// exit ;
110273: GO 110312
// for i in tmp do
110275: LD_ADDR_VAR 0 2
110279: PUSH
110280: LD_VAR 0 1
110284: PUSH
110285: FOR_IN
110286: IFFALSE 110310
// if IsControledBy ( i ) then
110288: LD_VAR 0 2
110292: PPUSH
110293: CALL_OW 312
110297: IFFALSE 110308
// ComUnlink ( i ) ;
110299: LD_VAR 0 2
110303: PPUSH
110304: CALL_OW 136
110308: GO 110285
110310: POP
110311: POP
// end ;
110312: PPOPN 2
110314: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
110315: LD_EXP 156
110319: PUSH
110320: LD_EXP 187
110324: AND
110325: IFFALSE 110465
110327: GO 110329
110329: DISABLE
110330: LD_INT 0
110332: PPUSH
110333: PPUSH
// begin ToLua ( displayPowell(); ) ;
110334: LD_STRING displayPowell();
110336: PPUSH
110337: CALL_OW 559
// uc_side := 0 ;
110341: LD_ADDR_OWVAR 20
110345: PUSH
110346: LD_INT 0
110348: ST_TO_ADDR
// uc_nation := 2 ;
110349: LD_ADDR_OWVAR 21
110353: PUSH
110354: LD_INT 2
110356: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
110357: LD_ADDR_OWVAR 37
110361: PUSH
110362: LD_INT 14
110364: ST_TO_ADDR
// vc_engine := engine_siberite ;
110365: LD_ADDR_OWVAR 39
110369: PUSH
110370: LD_INT 3
110372: ST_TO_ADDR
// vc_control := control_apeman ;
110373: LD_ADDR_OWVAR 38
110377: PUSH
110378: LD_INT 5
110380: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
110381: LD_ADDR_OWVAR 40
110385: PUSH
110386: LD_INT 29
110388: ST_TO_ADDR
// un := CreateVehicle ;
110389: LD_ADDR_VAR 0 2
110393: PUSH
110394: CALL_OW 45
110398: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110399: LD_VAR 0 2
110403: PPUSH
110404: LD_INT 1
110406: PPUSH
110407: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110411: LD_INT 35
110413: PPUSH
110414: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110418: LD_VAR 0 2
110422: PPUSH
110423: LD_INT 22
110425: PUSH
110426: LD_OWVAR 2
110430: PUSH
110431: EMPTY
110432: LIST
110433: LIST
110434: PPUSH
110435: CALL_OW 69
110439: PPUSH
110440: LD_VAR 0 2
110444: PPUSH
110445: CALL_OW 74
110449: PPUSH
110450: CALL_OW 115
// until IsDead ( un ) ;
110454: LD_VAR 0 2
110458: PPUSH
110459: CALL_OW 301
110463: IFFALSE 110411
// end ;
110465: PPOPN 2
110467: END
// every 0 0$1 trigger StreamModeActive and sStu do
110468: LD_EXP 156
110472: PUSH
110473: LD_EXP 195
110477: AND
110478: IFFALSE 110494
110480: GO 110482
110482: DISABLE
// begin ToLua ( displayStucuk(); ) ;
110483: LD_STRING displayStucuk();
110485: PPUSH
110486: CALL_OW 559
// ResetFog ;
110490: CALL_OW 335
// end ;
110494: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
110495: LD_EXP 156
110499: PUSH
110500: LD_EXP 188
110504: AND
110505: IFFALSE 110646
110507: GO 110509
110509: DISABLE
110510: LD_INT 0
110512: PPUSH
110513: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110514: LD_ADDR_VAR 0 2
110518: PUSH
110519: LD_INT 22
110521: PUSH
110522: LD_OWVAR 2
110526: PUSH
110527: EMPTY
110528: LIST
110529: LIST
110530: PUSH
110531: LD_INT 21
110533: PUSH
110534: LD_INT 1
110536: PUSH
110537: EMPTY
110538: LIST
110539: LIST
110540: PUSH
110541: EMPTY
110542: LIST
110543: LIST
110544: PPUSH
110545: CALL_OW 69
110549: ST_TO_ADDR
// if not tmp then
110550: LD_VAR 0 2
110554: NOT
110555: IFFALSE 110559
// exit ;
110557: GO 110646
// un := tmp [ rand ( 1 , tmp ) ] ;
110559: LD_ADDR_VAR 0 1
110563: PUSH
110564: LD_VAR 0 2
110568: PUSH
110569: LD_INT 1
110571: PPUSH
110572: LD_VAR 0 2
110576: PPUSH
110577: CALL_OW 12
110581: ARRAY
110582: ST_TO_ADDR
// SetSide ( un , 0 ) ;
110583: LD_VAR 0 1
110587: PPUSH
110588: LD_INT 0
110590: PPUSH
110591: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
110595: LD_VAR 0 1
110599: PPUSH
110600: LD_OWVAR 3
110604: PUSH
110605: LD_VAR 0 1
110609: DIFF
110610: PPUSH
110611: LD_VAR 0 1
110615: PPUSH
110616: CALL_OW 74
110620: PPUSH
110621: CALL_OW 115
// wait ( 0 0$20 ) ;
110625: LD_INT 700
110627: PPUSH
110628: CALL_OW 67
// SetSide ( un , your_side ) ;
110632: LD_VAR 0 1
110636: PPUSH
110637: LD_OWVAR 2
110641: PPUSH
110642: CALL_OW 235
// end ;
110646: PPOPN 2
110648: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
110649: LD_EXP 156
110653: PUSH
110654: LD_EXP 189
110658: AND
110659: IFFALSE 110765
110661: GO 110663
110663: DISABLE
110664: LD_INT 0
110666: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110667: LD_ADDR_VAR 0 1
110671: PUSH
110672: LD_INT 22
110674: PUSH
110675: LD_OWVAR 2
110679: PUSH
110680: EMPTY
110681: LIST
110682: LIST
110683: PUSH
110684: LD_INT 2
110686: PUSH
110687: LD_INT 30
110689: PUSH
110690: LD_INT 0
110692: PUSH
110693: EMPTY
110694: LIST
110695: LIST
110696: PUSH
110697: LD_INT 30
110699: PUSH
110700: LD_INT 1
110702: PUSH
110703: EMPTY
110704: LIST
110705: LIST
110706: PUSH
110707: EMPTY
110708: LIST
110709: LIST
110710: LIST
110711: PUSH
110712: EMPTY
110713: LIST
110714: LIST
110715: PPUSH
110716: CALL_OW 69
110720: ST_TO_ADDR
// if not depot then
110721: LD_VAR 0 1
110725: NOT
110726: IFFALSE 110730
// exit ;
110728: GO 110765
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
110730: LD_VAR 0 1
110734: PUSH
110735: LD_INT 1
110737: ARRAY
110738: PPUSH
110739: CALL_OW 250
110743: PPUSH
110744: LD_VAR 0 1
110748: PUSH
110749: LD_INT 1
110751: ARRAY
110752: PPUSH
110753: CALL_OW 251
110757: PPUSH
110758: LD_INT 70
110760: PPUSH
110761: CALL_OW 495
// end ;
110765: PPOPN 1
110767: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
110768: LD_EXP 156
110772: PUSH
110773: LD_EXP 190
110777: AND
110778: IFFALSE 110989
110780: GO 110782
110782: DISABLE
110783: LD_INT 0
110785: PPUSH
110786: PPUSH
110787: PPUSH
110788: PPUSH
110789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110790: LD_ADDR_VAR 0 5
110794: PUSH
110795: LD_INT 22
110797: PUSH
110798: LD_OWVAR 2
110802: PUSH
110803: EMPTY
110804: LIST
110805: LIST
110806: PUSH
110807: LD_INT 21
110809: PUSH
110810: LD_INT 1
110812: PUSH
110813: EMPTY
110814: LIST
110815: LIST
110816: PUSH
110817: EMPTY
110818: LIST
110819: LIST
110820: PPUSH
110821: CALL_OW 69
110825: ST_TO_ADDR
// if not tmp then
110826: LD_VAR 0 5
110830: NOT
110831: IFFALSE 110835
// exit ;
110833: GO 110989
// for i in tmp do
110835: LD_ADDR_VAR 0 1
110839: PUSH
110840: LD_VAR 0 5
110844: PUSH
110845: FOR_IN
110846: IFFALSE 110987
// begin d := rand ( 0 , 5 ) ;
110848: LD_ADDR_VAR 0 4
110852: PUSH
110853: LD_INT 0
110855: PPUSH
110856: LD_INT 5
110858: PPUSH
110859: CALL_OW 12
110863: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110864: LD_ADDR_VAR 0 2
110868: PUSH
110869: LD_VAR 0 1
110873: PPUSH
110874: CALL_OW 250
110878: PPUSH
110879: LD_VAR 0 4
110883: PPUSH
110884: LD_INT 3
110886: PPUSH
110887: LD_INT 12
110889: PPUSH
110890: CALL_OW 12
110894: PPUSH
110895: CALL_OW 272
110899: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
110900: LD_ADDR_VAR 0 3
110904: PUSH
110905: LD_VAR 0 1
110909: PPUSH
110910: CALL_OW 251
110914: PPUSH
110915: LD_VAR 0 4
110919: PPUSH
110920: LD_INT 3
110922: PPUSH
110923: LD_INT 12
110925: PPUSH
110926: CALL_OW 12
110930: PPUSH
110931: CALL_OW 273
110935: ST_TO_ADDR
// if ValidHex ( x , y ) then
110936: LD_VAR 0 2
110940: PPUSH
110941: LD_VAR 0 3
110945: PPUSH
110946: CALL_OW 488
110950: IFFALSE 110985
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
110952: LD_VAR 0 1
110956: PPUSH
110957: LD_VAR 0 2
110961: PPUSH
110962: LD_VAR 0 3
110966: PPUSH
110967: LD_INT 3
110969: PPUSH
110970: LD_INT 6
110972: PPUSH
110973: CALL_OW 12
110977: PPUSH
110978: LD_INT 1
110980: PPUSH
110981: CALL_OW 483
// end ;
110985: GO 110845
110987: POP
110988: POP
// end ;
110989: PPOPN 5
110991: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110992: LD_EXP 156
110996: PUSH
110997: LD_EXP 191
111001: AND
111002: IFFALSE 111096
111004: GO 111006
111006: DISABLE
111007: LD_INT 0
111009: PPUSH
111010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
111011: LD_ADDR_VAR 0 2
111015: PUSH
111016: LD_INT 22
111018: PUSH
111019: LD_OWVAR 2
111023: PUSH
111024: EMPTY
111025: LIST
111026: LIST
111027: PUSH
111028: LD_INT 32
111030: PUSH
111031: LD_INT 1
111033: PUSH
111034: EMPTY
111035: LIST
111036: LIST
111037: PUSH
111038: LD_INT 21
111040: PUSH
111041: LD_INT 2
111043: PUSH
111044: EMPTY
111045: LIST
111046: LIST
111047: PUSH
111048: EMPTY
111049: LIST
111050: LIST
111051: LIST
111052: PPUSH
111053: CALL_OW 69
111057: ST_TO_ADDR
// if not tmp then
111058: LD_VAR 0 2
111062: NOT
111063: IFFALSE 111067
// exit ;
111065: GO 111096
// for i in tmp do
111067: LD_ADDR_VAR 0 1
111071: PUSH
111072: LD_VAR 0 2
111076: PUSH
111077: FOR_IN
111078: IFFALSE 111094
// SetFuel ( i , 0 ) ;
111080: LD_VAR 0 1
111084: PPUSH
111085: LD_INT 0
111087: PPUSH
111088: CALL_OW 240
111092: GO 111077
111094: POP
111095: POP
// end ;
111096: PPOPN 2
111098: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
111099: LD_EXP 156
111103: PUSH
111104: LD_EXP 192
111108: AND
111109: IFFALSE 111175
111111: GO 111113
111113: DISABLE
111114: LD_INT 0
111116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111117: LD_ADDR_VAR 0 1
111121: PUSH
111122: LD_INT 22
111124: PUSH
111125: LD_OWVAR 2
111129: PUSH
111130: EMPTY
111131: LIST
111132: LIST
111133: PUSH
111134: LD_INT 30
111136: PUSH
111137: LD_INT 29
111139: PUSH
111140: EMPTY
111141: LIST
111142: LIST
111143: PUSH
111144: EMPTY
111145: LIST
111146: LIST
111147: PPUSH
111148: CALL_OW 69
111152: ST_TO_ADDR
// if not tmp then
111153: LD_VAR 0 1
111157: NOT
111158: IFFALSE 111162
// exit ;
111160: GO 111175
// DestroyUnit ( tmp [ 1 ] ) ;
111162: LD_VAR 0 1
111166: PUSH
111167: LD_INT 1
111169: ARRAY
111170: PPUSH
111171: CALL_OW 65
// end ;
111175: PPOPN 1
111177: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
111178: LD_EXP 156
111182: PUSH
111183: LD_EXP 194
111187: AND
111188: IFFALSE 111317
111190: GO 111192
111192: DISABLE
111193: LD_INT 0
111195: PPUSH
// begin uc_side := 0 ;
111196: LD_ADDR_OWVAR 20
111200: PUSH
111201: LD_INT 0
111203: ST_TO_ADDR
// uc_nation := nation_arabian ;
111204: LD_ADDR_OWVAR 21
111208: PUSH
111209: LD_INT 2
111211: ST_TO_ADDR
// hc_gallery :=  ;
111212: LD_ADDR_OWVAR 33
111216: PUSH
111217: LD_STRING 
111219: ST_TO_ADDR
// hc_name :=  ;
111220: LD_ADDR_OWVAR 26
111224: PUSH
111225: LD_STRING 
111227: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
111228: LD_INT 1
111230: PPUSH
111231: LD_INT 11
111233: PPUSH
111234: LD_INT 10
111236: PPUSH
111237: CALL_OW 380
// un := CreateHuman ;
111241: LD_ADDR_VAR 0 1
111245: PUSH
111246: CALL_OW 44
111250: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111251: LD_VAR 0 1
111255: PPUSH
111256: LD_INT 1
111258: PPUSH
111259: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
111263: LD_INT 35
111265: PPUSH
111266: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
111270: LD_VAR 0 1
111274: PPUSH
111275: LD_INT 22
111277: PUSH
111278: LD_OWVAR 2
111282: PUSH
111283: EMPTY
111284: LIST
111285: LIST
111286: PPUSH
111287: CALL_OW 69
111291: PPUSH
111292: LD_VAR 0 1
111296: PPUSH
111297: CALL_OW 74
111301: PPUSH
111302: CALL_OW 115
// until IsDead ( un ) ;
111306: LD_VAR 0 1
111310: PPUSH
111311: CALL_OW 301
111315: IFFALSE 111263
// end ;
111317: PPOPN 1
111319: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
111320: LD_EXP 156
111324: PUSH
111325: LD_EXP 196
111329: AND
111330: IFFALSE 111342
111332: GO 111334
111334: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
111335: LD_STRING earthquake(getX(game), 0, 32)
111337: PPUSH
111338: CALL_OW 559
111342: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
111343: LD_EXP 156
111347: PUSH
111348: LD_EXP 197
111352: AND
111353: IFFALSE 111444
111355: GO 111357
111357: DISABLE
111358: LD_INT 0
111360: PPUSH
// begin enable ;
111361: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
111362: LD_ADDR_VAR 0 1
111366: PUSH
111367: LD_INT 22
111369: PUSH
111370: LD_OWVAR 2
111374: PUSH
111375: EMPTY
111376: LIST
111377: LIST
111378: PUSH
111379: LD_INT 21
111381: PUSH
111382: LD_INT 2
111384: PUSH
111385: EMPTY
111386: LIST
111387: LIST
111388: PUSH
111389: LD_INT 33
111391: PUSH
111392: LD_INT 3
111394: PUSH
111395: EMPTY
111396: LIST
111397: LIST
111398: PUSH
111399: EMPTY
111400: LIST
111401: LIST
111402: LIST
111403: PPUSH
111404: CALL_OW 69
111408: ST_TO_ADDR
// if not tmp then
111409: LD_VAR 0 1
111413: NOT
111414: IFFALSE 111418
// exit ;
111416: GO 111444
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111418: LD_VAR 0 1
111422: PUSH
111423: LD_INT 1
111425: PPUSH
111426: LD_VAR 0 1
111430: PPUSH
111431: CALL_OW 12
111435: ARRAY
111436: PPUSH
111437: LD_INT 1
111439: PPUSH
111440: CALL_OW 234
// end ;
111444: PPOPN 1
111446: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
111447: LD_EXP 156
111451: PUSH
111452: LD_EXP 198
111456: AND
111457: IFFALSE 111598
111459: GO 111461
111461: DISABLE
111462: LD_INT 0
111464: PPUSH
111465: PPUSH
111466: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111467: LD_ADDR_VAR 0 3
111471: PUSH
111472: LD_INT 22
111474: PUSH
111475: LD_OWVAR 2
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: PUSH
111484: LD_INT 25
111486: PUSH
111487: LD_INT 1
111489: PUSH
111490: EMPTY
111491: LIST
111492: LIST
111493: PUSH
111494: EMPTY
111495: LIST
111496: LIST
111497: PPUSH
111498: CALL_OW 69
111502: ST_TO_ADDR
// if not tmp then
111503: LD_VAR 0 3
111507: NOT
111508: IFFALSE 111512
// exit ;
111510: GO 111598
// un := tmp [ rand ( 1 , tmp ) ] ;
111512: LD_ADDR_VAR 0 2
111516: PUSH
111517: LD_VAR 0 3
111521: PUSH
111522: LD_INT 1
111524: PPUSH
111525: LD_VAR 0 3
111529: PPUSH
111530: CALL_OW 12
111534: ARRAY
111535: ST_TO_ADDR
// if Crawls ( un ) then
111536: LD_VAR 0 2
111540: PPUSH
111541: CALL_OW 318
111545: IFFALSE 111556
// ComWalk ( un ) ;
111547: LD_VAR 0 2
111551: PPUSH
111552: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
111556: LD_VAR 0 2
111560: PPUSH
111561: LD_INT 9
111563: PPUSH
111564: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
111568: LD_INT 28
111570: PPUSH
111571: LD_OWVAR 2
111575: PPUSH
111576: LD_INT 2
111578: PPUSH
111579: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
111583: LD_INT 29
111585: PPUSH
111586: LD_OWVAR 2
111590: PPUSH
111591: LD_INT 2
111593: PPUSH
111594: CALL_OW 322
// end ;
111598: PPOPN 3
111600: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
111601: LD_EXP 156
111605: PUSH
111606: LD_EXP 199
111610: AND
111611: IFFALSE 111722
111613: GO 111615
111615: DISABLE
111616: LD_INT 0
111618: PPUSH
111619: PPUSH
111620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111621: LD_ADDR_VAR 0 3
111625: PUSH
111626: LD_INT 22
111628: PUSH
111629: LD_OWVAR 2
111633: PUSH
111634: EMPTY
111635: LIST
111636: LIST
111637: PUSH
111638: LD_INT 25
111640: PUSH
111641: LD_INT 1
111643: PUSH
111644: EMPTY
111645: LIST
111646: LIST
111647: PUSH
111648: EMPTY
111649: LIST
111650: LIST
111651: PPUSH
111652: CALL_OW 69
111656: ST_TO_ADDR
// if not tmp then
111657: LD_VAR 0 3
111661: NOT
111662: IFFALSE 111666
// exit ;
111664: GO 111722
// un := tmp [ rand ( 1 , tmp ) ] ;
111666: LD_ADDR_VAR 0 2
111670: PUSH
111671: LD_VAR 0 3
111675: PUSH
111676: LD_INT 1
111678: PPUSH
111679: LD_VAR 0 3
111683: PPUSH
111684: CALL_OW 12
111688: ARRAY
111689: ST_TO_ADDR
// if Crawls ( un ) then
111690: LD_VAR 0 2
111694: PPUSH
111695: CALL_OW 318
111699: IFFALSE 111710
// ComWalk ( un ) ;
111701: LD_VAR 0 2
111705: PPUSH
111706: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111710: LD_VAR 0 2
111714: PPUSH
111715: LD_INT 8
111717: PPUSH
111718: CALL_OW 336
// end ;
111722: PPOPN 3
111724: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
111725: LD_EXP 156
111729: PUSH
111730: LD_EXP 200
111734: AND
111735: IFFALSE 111879
111737: GO 111739
111739: DISABLE
111740: LD_INT 0
111742: PPUSH
111743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
111744: LD_ADDR_VAR 0 2
111748: PUSH
111749: LD_INT 22
111751: PUSH
111752: LD_OWVAR 2
111756: PUSH
111757: EMPTY
111758: LIST
111759: LIST
111760: PUSH
111761: LD_INT 21
111763: PUSH
111764: LD_INT 2
111766: PUSH
111767: EMPTY
111768: LIST
111769: LIST
111770: PUSH
111771: LD_INT 2
111773: PUSH
111774: LD_INT 34
111776: PUSH
111777: LD_INT 12
111779: PUSH
111780: EMPTY
111781: LIST
111782: LIST
111783: PUSH
111784: LD_INT 34
111786: PUSH
111787: LD_INT 51
111789: PUSH
111790: EMPTY
111791: LIST
111792: LIST
111793: PUSH
111794: LD_INT 34
111796: PUSH
111797: LD_INT 32
111799: PUSH
111800: EMPTY
111801: LIST
111802: LIST
111803: PUSH
111804: EMPTY
111805: LIST
111806: LIST
111807: LIST
111808: LIST
111809: PUSH
111810: EMPTY
111811: LIST
111812: LIST
111813: LIST
111814: PPUSH
111815: CALL_OW 69
111819: ST_TO_ADDR
// if not tmp then
111820: LD_VAR 0 2
111824: NOT
111825: IFFALSE 111829
// exit ;
111827: GO 111879
// for i in tmp do
111829: LD_ADDR_VAR 0 1
111833: PUSH
111834: LD_VAR 0 2
111838: PUSH
111839: FOR_IN
111840: IFFALSE 111877
// if GetCargo ( i , mat_artifact ) = 0 then
111842: LD_VAR 0 1
111846: PPUSH
111847: LD_INT 4
111849: PPUSH
111850: CALL_OW 289
111854: PUSH
111855: LD_INT 0
111857: EQUAL
111858: IFFALSE 111875
// SetCargo ( i , mat_siberit , 100 ) ;
111860: LD_VAR 0 1
111864: PPUSH
111865: LD_INT 3
111867: PPUSH
111868: LD_INT 100
111870: PPUSH
111871: CALL_OW 290
111875: GO 111839
111877: POP
111878: POP
// end ;
111879: PPOPN 2
111881: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
111882: LD_EXP 156
111886: PUSH
111887: LD_EXP 201
111891: AND
111892: IFFALSE 112075
111894: GO 111896
111896: DISABLE
111897: LD_INT 0
111899: PPUSH
111900: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
111901: LD_ADDR_VAR 0 2
111905: PUSH
111906: LD_INT 22
111908: PUSH
111909: LD_OWVAR 2
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: PPUSH
111918: CALL_OW 69
111922: ST_TO_ADDR
// if not tmp then
111923: LD_VAR 0 2
111927: NOT
111928: IFFALSE 111932
// exit ;
111930: GO 112075
// for i := 1 to 2 do
111932: LD_ADDR_VAR 0 1
111936: PUSH
111937: DOUBLE
111938: LD_INT 1
111940: DEC
111941: ST_TO_ADDR
111942: LD_INT 2
111944: PUSH
111945: FOR_TO
111946: IFFALSE 112073
// begin uc_side := your_side ;
111948: LD_ADDR_OWVAR 20
111952: PUSH
111953: LD_OWVAR 2
111957: ST_TO_ADDR
// uc_nation := nation_american ;
111958: LD_ADDR_OWVAR 21
111962: PUSH
111963: LD_INT 1
111965: ST_TO_ADDR
// vc_chassis := us_morphling ;
111966: LD_ADDR_OWVAR 37
111970: PUSH
111971: LD_INT 5
111973: ST_TO_ADDR
// vc_engine := engine_siberite ;
111974: LD_ADDR_OWVAR 39
111978: PUSH
111979: LD_INT 3
111981: ST_TO_ADDR
// vc_control := control_computer ;
111982: LD_ADDR_OWVAR 38
111986: PUSH
111987: LD_INT 3
111989: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111990: LD_ADDR_OWVAR 40
111994: PUSH
111995: LD_INT 10
111997: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111998: LD_VAR 0 2
112002: PUSH
112003: LD_INT 1
112005: ARRAY
112006: PPUSH
112007: CALL_OW 310
112011: NOT
112012: IFFALSE 112059
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
112014: CALL_OW 45
112018: PPUSH
112019: LD_VAR 0 2
112023: PUSH
112024: LD_INT 1
112026: ARRAY
112027: PPUSH
112028: CALL_OW 250
112032: PPUSH
112033: LD_VAR 0 2
112037: PUSH
112038: LD_INT 1
112040: ARRAY
112041: PPUSH
112042: CALL_OW 251
112046: PPUSH
112047: LD_INT 12
112049: PPUSH
112050: LD_INT 1
112052: PPUSH
112053: CALL_OW 50
112057: GO 112071
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
112059: CALL_OW 45
112063: PPUSH
112064: LD_INT 1
112066: PPUSH
112067: CALL_OW 51
// end ;
112071: GO 111945
112073: POP
112074: POP
// end ;
112075: PPOPN 2
112077: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
112078: LD_EXP 156
112082: PUSH
112083: LD_EXP 202
112087: AND
112088: IFFALSE 112310
112090: GO 112092
112092: DISABLE
112093: LD_INT 0
112095: PPUSH
112096: PPUSH
112097: PPUSH
112098: PPUSH
112099: PPUSH
112100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112101: LD_ADDR_VAR 0 6
112105: PUSH
112106: LD_INT 22
112108: PUSH
112109: LD_OWVAR 2
112113: PUSH
112114: EMPTY
112115: LIST
112116: LIST
112117: PUSH
112118: LD_INT 21
112120: PUSH
112121: LD_INT 1
112123: PUSH
112124: EMPTY
112125: LIST
112126: LIST
112127: PUSH
112128: LD_INT 3
112130: PUSH
112131: LD_INT 23
112133: PUSH
112134: LD_INT 0
112136: PUSH
112137: EMPTY
112138: LIST
112139: LIST
112140: PUSH
112141: EMPTY
112142: LIST
112143: LIST
112144: PUSH
112145: EMPTY
112146: LIST
112147: LIST
112148: LIST
112149: PPUSH
112150: CALL_OW 69
112154: ST_TO_ADDR
// if not tmp then
112155: LD_VAR 0 6
112159: NOT
112160: IFFALSE 112164
// exit ;
112162: GO 112310
// s1 := rand ( 1 , 4 ) ;
112164: LD_ADDR_VAR 0 2
112168: PUSH
112169: LD_INT 1
112171: PPUSH
112172: LD_INT 4
112174: PPUSH
112175: CALL_OW 12
112179: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
112180: LD_ADDR_VAR 0 4
112184: PUSH
112185: LD_VAR 0 6
112189: PUSH
112190: LD_INT 1
112192: ARRAY
112193: PPUSH
112194: LD_VAR 0 2
112198: PPUSH
112199: CALL_OW 259
112203: ST_TO_ADDR
// if s1 = 1 then
112204: LD_VAR 0 2
112208: PUSH
112209: LD_INT 1
112211: EQUAL
112212: IFFALSE 112232
// s2 := rand ( 2 , 4 ) else
112214: LD_ADDR_VAR 0 3
112218: PUSH
112219: LD_INT 2
112221: PPUSH
112222: LD_INT 4
112224: PPUSH
112225: CALL_OW 12
112229: ST_TO_ADDR
112230: GO 112240
// s2 := 1 ;
112232: LD_ADDR_VAR 0 3
112236: PUSH
112237: LD_INT 1
112239: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
112240: LD_ADDR_VAR 0 5
112244: PUSH
112245: LD_VAR 0 6
112249: PUSH
112250: LD_INT 1
112252: ARRAY
112253: PPUSH
112254: LD_VAR 0 3
112258: PPUSH
112259: CALL_OW 259
112263: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
112264: LD_VAR 0 6
112268: PUSH
112269: LD_INT 1
112271: ARRAY
112272: PPUSH
112273: LD_VAR 0 2
112277: PPUSH
112278: LD_VAR 0 5
112282: PPUSH
112283: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
112287: LD_VAR 0 6
112291: PUSH
112292: LD_INT 1
112294: ARRAY
112295: PPUSH
112296: LD_VAR 0 3
112300: PPUSH
112301: LD_VAR 0 4
112305: PPUSH
112306: CALL_OW 237
// end ;
112310: PPOPN 6
112312: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
112313: LD_EXP 156
112317: PUSH
112318: LD_EXP 203
112322: AND
112323: IFFALSE 112402
112325: GO 112327
112327: DISABLE
112328: LD_INT 0
112330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
112331: LD_ADDR_VAR 0 1
112335: PUSH
112336: LD_INT 22
112338: PUSH
112339: LD_OWVAR 2
112343: PUSH
112344: EMPTY
112345: LIST
112346: LIST
112347: PUSH
112348: LD_INT 30
112350: PUSH
112351: LD_INT 3
112353: PUSH
112354: EMPTY
112355: LIST
112356: LIST
112357: PUSH
112358: EMPTY
112359: LIST
112360: LIST
112361: PPUSH
112362: CALL_OW 69
112366: ST_TO_ADDR
// if not tmp then
112367: LD_VAR 0 1
112371: NOT
112372: IFFALSE 112376
// exit ;
112374: GO 112402
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112376: LD_VAR 0 1
112380: PUSH
112381: LD_INT 1
112383: PPUSH
112384: LD_VAR 0 1
112388: PPUSH
112389: CALL_OW 12
112393: ARRAY
112394: PPUSH
112395: LD_INT 1
112397: PPUSH
112398: CALL_OW 234
// end ;
112402: PPOPN 1
112404: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
112405: LD_EXP 156
112409: PUSH
112410: LD_EXP 204
112414: AND
112415: IFFALSE 112527
112417: GO 112419
112419: DISABLE
112420: LD_INT 0
112422: PPUSH
112423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
112424: LD_ADDR_VAR 0 2
112428: PUSH
112429: LD_INT 22
112431: PUSH
112432: LD_OWVAR 2
112436: PUSH
112437: EMPTY
112438: LIST
112439: LIST
112440: PUSH
112441: LD_INT 2
112443: PUSH
112444: LD_INT 30
112446: PUSH
112447: LD_INT 27
112449: PUSH
112450: EMPTY
112451: LIST
112452: LIST
112453: PUSH
112454: LD_INT 30
112456: PUSH
112457: LD_INT 26
112459: PUSH
112460: EMPTY
112461: LIST
112462: LIST
112463: PUSH
112464: LD_INT 30
112466: PUSH
112467: LD_INT 28
112469: PUSH
112470: EMPTY
112471: LIST
112472: LIST
112473: PUSH
112474: EMPTY
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: PUSH
112480: EMPTY
112481: LIST
112482: LIST
112483: PPUSH
112484: CALL_OW 69
112488: ST_TO_ADDR
// if not tmp then
112489: LD_VAR 0 2
112493: NOT
112494: IFFALSE 112498
// exit ;
112496: GO 112527
// for i in tmp do
112498: LD_ADDR_VAR 0 1
112502: PUSH
112503: LD_VAR 0 2
112507: PUSH
112508: FOR_IN
112509: IFFALSE 112525
// SetLives ( i , 1 ) ;
112511: LD_VAR 0 1
112515: PPUSH
112516: LD_INT 1
112518: PPUSH
112519: CALL_OW 234
112523: GO 112508
112525: POP
112526: POP
// end ;
112527: PPOPN 2
112529: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
112530: LD_EXP 156
112534: PUSH
112535: LD_EXP 205
112539: AND
112540: IFFALSE 112814
112542: GO 112544
112544: DISABLE
112545: LD_INT 0
112547: PPUSH
112548: PPUSH
112549: PPUSH
// begin i := rand ( 1 , 7 ) ;
112550: LD_ADDR_VAR 0 1
112554: PUSH
112555: LD_INT 1
112557: PPUSH
112558: LD_INT 7
112560: PPUSH
112561: CALL_OW 12
112565: ST_TO_ADDR
// case i of 1 :
112566: LD_VAR 0 1
112570: PUSH
112571: LD_INT 1
112573: DOUBLE
112574: EQUAL
112575: IFTRUE 112579
112577: GO 112589
112579: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
112580: LD_STRING earthquake(getX(game), 0, 32)
112582: PPUSH
112583: CALL_OW 559
112587: GO 112814
112589: LD_INT 2
112591: DOUBLE
112592: EQUAL
112593: IFTRUE 112597
112595: GO 112611
112597: POP
// begin ToLua ( displayStucuk(); ) ;
112598: LD_STRING displayStucuk();
112600: PPUSH
112601: CALL_OW 559
// ResetFog ;
112605: CALL_OW 335
// end ; 3 :
112609: GO 112814
112611: LD_INT 3
112613: DOUBLE
112614: EQUAL
112615: IFTRUE 112619
112617: GO 112723
112619: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112620: LD_ADDR_VAR 0 2
112624: PUSH
112625: LD_INT 22
112627: PUSH
112628: LD_OWVAR 2
112632: PUSH
112633: EMPTY
112634: LIST
112635: LIST
112636: PUSH
112637: LD_INT 25
112639: PUSH
112640: LD_INT 1
112642: PUSH
112643: EMPTY
112644: LIST
112645: LIST
112646: PUSH
112647: EMPTY
112648: LIST
112649: LIST
112650: PPUSH
112651: CALL_OW 69
112655: ST_TO_ADDR
// if not tmp then
112656: LD_VAR 0 2
112660: NOT
112661: IFFALSE 112665
// exit ;
112663: GO 112814
// un := tmp [ rand ( 1 , tmp ) ] ;
112665: LD_ADDR_VAR 0 3
112669: PUSH
112670: LD_VAR 0 2
112674: PUSH
112675: LD_INT 1
112677: PPUSH
112678: LD_VAR 0 2
112682: PPUSH
112683: CALL_OW 12
112687: ARRAY
112688: ST_TO_ADDR
// if Crawls ( un ) then
112689: LD_VAR 0 3
112693: PPUSH
112694: CALL_OW 318
112698: IFFALSE 112709
// ComWalk ( un ) ;
112700: LD_VAR 0 3
112704: PPUSH
112705: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112709: LD_VAR 0 3
112713: PPUSH
112714: LD_INT 8
112716: PPUSH
112717: CALL_OW 336
// end ; 4 :
112721: GO 112814
112723: LD_INT 4
112725: DOUBLE
112726: EQUAL
112727: IFTRUE 112731
112729: GO 112792
112731: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112732: LD_ADDR_VAR 0 2
112736: PUSH
112737: LD_INT 22
112739: PUSH
112740: LD_OWVAR 2
112744: PUSH
112745: EMPTY
112746: LIST
112747: LIST
112748: PUSH
112749: LD_INT 30
112751: PUSH
112752: LD_INT 29
112754: PUSH
112755: EMPTY
112756: LIST
112757: LIST
112758: PUSH
112759: EMPTY
112760: LIST
112761: LIST
112762: PPUSH
112763: CALL_OW 69
112767: ST_TO_ADDR
// if not tmp then
112768: LD_VAR 0 2
112772: NOT
112773: IFFALSE 112777
// exit ;
112775: GO 112814
// DestroyUnit ( tmp [ 1 ] ) ;
112777: LD_VAR 0 2
112781: PUSH
112782: LD_INT 1
112784: ARRAY
112785: PPUSH
112786: CALL_OW 65
// end ; 5 .. 7 :
112790: GO 112814
112792: LD_INT 5
112794: DOUBLE
112795: GREATEREQUAL
112796: IFFALSE 112804
112798: LD_INT 7
112800: DOUBLE
112801: LESSEQUAL
112802: IFTRUE 112806
112804: GO 112813
112806: POP
// StreamSibBomb ; end ;
112807: CALL 109064 0 0
112811: GO 112814
112813: POP
// end ;
112814: PPOPN 3
112816: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112817: LD_EXP 156
112821: PUSH
112822: LD_EXP 206
112826: AND
112827: IFFALSE 112983
112829: GO 112831
112831: DISABLE
112832: LD_INT 0
112834: PPUSH
112835: PPUSH
112836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112837: LD_ADDR_VAR 0 2
112841: PUSH
112842: LD_INT 81
112844: PUSH
112845: LD_OWVAR 2
112849: PUSH
112850: EMPTY
112851: LIST
112852: LIST
112853: PUSH
112854: LD_INT 2
112856: PUSH
112857: LD_INT 21
112859: PUSH
112860: LD_INT 1
112862: PUSH
112863: EMPTY
112864: LIST
112865: LIST
112866: PUSH
112867: LD_INT 21
112869: PUSH
112870: LD_INT 2
112872: PUSH
112873: EMPTY
112874: LIST
112875: LIST
112876: PUSH
112877: EMPTY
112878: LIST
112879: LIST
112880: LIST
112881: PUSH
112882: EMPTY
112883: LIST
112884: LIST
112885: PPUSH
112886: CALL_OW 69
112890: ST_TO_ADDR
// if not tmp then
112891: LD_VAR 0 2
112895: NOT
112896: IFFALSE 112900
// exit ;
112898: GO 112983
// p := 0 ;
112900: LD_ADDR_VAR 0 3
112904: PUSH
112905: LD_INT 0
112907: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112908: LD_INT 35
112910: PPUSH
112911: CALL_OW 67
// p := p + 1 ;
112915: LD_ADDR_VAR 0 3
112919: PUSH
112920: LD_VAR 0 3
112924: PUSH
112925: LD_INT 1
112927: PLUS
112928: ST_TO_ADDR
// for i in tmp do
112929: LD_ADDR_VAR 0 1
112933: PUSH
112934: LD_VAR 0 2
112938: PUSH
112939: FOR_IN
112940: IFFALSE 112971
// if GetLives ( i ) < 1000 then
112942: LD_VAR 0 1
112946: PPUSH
112947: CALL_OW 256
112951: PUSH
112952: LD_INT 1000
112954: LESS
112955: IFFALSE 112969
// SetLives ( i , 1000 ) ;
112957: LD_VAR 0 1
112961: PPUSH
112962: LD_INT 1000
112964: PPUSH
112965: CALL_OW 234
112969: GO 112939
112971: POP
112972: POP
// until p > 20 ;
112973: LD_VAR 0 3
112977: PUSH
112978: LD_INT 20
112980: GREATER
112981: IFFALSE 112908
// end ;
112983: PPOPN 3
112985: END
// every 0 0$1 trigger StreamModeActive and sTime do
112986: LD_EXP 156
112990: PUSH
112991: LD_EXP 207
112995: AND
112996: IFFALSE 113031
112998: GO 113000
113000: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
113001: LD_INT 28
113003: PPUSH
113004: LD_OWVAR 2
113008: PPUSH
113009: LD_INT 2
113011: PPUSH
113012: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
113016: LD_INT 30
113018: PPUSH
113019: LD_OWVAR 2
113023: PPUSH
113024: LD_INT 2
113026: PPUSH
113027: CALL_OW 322
// end ;
113031: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
113032: LD_EXP 156
113036: PUSH
113037: LD_EXP 208
113041: AND
113042: IFFALSE 113163
113044: GO 113046
113046: DISABLE
113047: LD_INT 0
113049: PPUSH
113050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113051: LD_ADDR_VAR 0 2
113055: PUSH
113056: LD_INT 22
113058: PUSH
113059: LD_OWVAR 2
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: PUSH
113068: LD_INT 21
113070: PUSH
113071: LD_INT 1
113073: PUSH
113074: EMPTY
113075: LIST
113076: LIST
113077: PUSH
113078: LD_INT 3
113080: PUSH
113081: LD_INT 23
113083: PUSH
113084: LD_INT 0
113086: PUSH
113087: EMPTY
113088: LIST
113089: LIST
113090: PUSH
113091: EMPTY
113092: LIST
113093: LIST
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: LIST
113099: PPUSH
113100: CALL_OW 69
113104: ST_TO_ADDR
// if not tmp then
113105: LD_VAR 0 2
113109: NOT
113110: IFFALSE 113114
// exit ;
113112: GO 113163
// for i in tmp do
113114: LD_ADDR_VAR 0 1
113118: PUSH
113119: LD_VAR 0 2
113123: PUSH
113124: FOR_IN
113125: IFFALSE 113161
// begin if Crawls ( i ) then
113127: LD_VAR 0 1
113131: PPUSH
113132: CALL_OW 318
113136: IFFALSE 113147
// ComWalk ( i ) ;
113138: LD_VAR 0 1
113142: PPUSH
113143: CALL_OW 138
// SetClass ( i , 2 ) ;
113147: LD_VAR 0 1
113151: PPUSH
113152: LD_INT 2
113154: PPUSH
113155: CALL_OW 336
// end ;
113159: GO 113124
113161: POP
113162: POP
// end ;
113163: PPOPN 2
113165: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
113166: LD_EXP 156
113170: PUSH
113171: LD_EXP 209
113175: AND
113176: IFFALSE 113457
113178: GO 113180
113180: DISABLE
113181: LD_INT 0
113183: PPUSH
113184: PPUSH
113185: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
113186: LD_OWVAR 2
113190: PPUSH
113191: LD_INT 9
113193: PPUSH
113194: LD_INT 1
113196: PPUSH
113197: LD_INT 1
113199: PPUSH
113200: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
113204: LD_INT 9
113206: PPUSH
113207: LD_OWVAR 2
113211: PPUSH
113212: CALL_OW 343
// uc_side := 9 ;
113216: LD_ADDR_OWVAR 20
113220: PUSH
113221: LD_INT 9
113223: ST_TO_ADDR
// uc_nation := 2 ;
113224: LD_ADDR_OWVAR 21
113228: PUSH
113229: LD_INT 2
113231: ST_TO_ADDR
// hc_name := Dark Warrior ;
113232: LD_ADDR_OWVAR 26
113236: PUSH
113237: LD_STRING Dark Warrior
113239: ST_TO_ADDR
// hc_gallery :=  ;
113240: LD_ADDR_OWVAR 33
113244: PUSH
113245: LD_STRING 
113247: ST_TO_ADDR
// hc_noskilllimit := true ;
113248: LD_ADDR_OWVAR 76
113252: PUSH
113253: LD_INT 1
113255: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
113256: LD_ADDR_OWVAR 31
113260: PUSH
113261: LD_INT 30
113263: PUSH
113264: LD_INT 30
113266: PUSH
113267: LD_INT 30
113269: PUSH
113270: LD_INT 30
113272: PUSH
113273: EMPTY
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: ST_TO_ADDR
// un := CreateHuman ;
113279: LD_ADDR_VAR 0 3
113283: PUSH
113284: CALL_OW 44
113288: ST_TO_ADDR
// hc_noskilllimit := false ;
113289: LD_ADDR_OWVAR 76
113293: PUSH
113294: LD_INT 0
113296: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113297: LD_VAR 0 3
113301: PPUSH
113302: LD_INT 1
113304: PPUSH
113305: CALL_OW 51
// p := 0 ;
113309: LD_ADDR_VAR 0 2
113313: PUSH
113314: LD_INT 0
113316: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113317: LD_INT 35
113319: PPUSH
113320: CALL_OW 67
// p := p + 1 ;
113324: LD_ADDR_VAR 0 2
113328: PUSH
113329: LD_VAR 0 2
113333: PUSH
113334: LD_INT 1
113336: PLUS
113337: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
113338: LD_VAR 0 3
113342: PPUSH
113343: CALL_OW 256
113347: PUSH
113348: LD_INT 1000
113350: LESS
113351: IFFALSE 113365
// SetLives ( un , 1000 ) ;
113353: LD_VAR 0 3
113357: PPUSH
113358: LD_INT 1000
113360: PPUSH
113361: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
113365: LD_VAR 0 3
113369: PPUSH
113370: LD_INT 81
113372: PUSH
113373: LD_OWVAR 2
113377: PUSH
113378: EMPTY
113379: LIST
113380: LIST
113381: PUSH
113382: LD_INT 91
113384: PUSH
113385: LD_VAR 0 3
113389: PUSH
113390: LD_INT 30
113392: PUSH
113393: EMPTY
113394: LIST
113395: LIST
113396: LIST
113397: PUSH
113398: EMPTY
113399: LIST
113400: LIST
113401: PPUSH
113402: CALL_OW 69
113406: PPUSH
113407: LD_VAR 0 3
113411: PPUSH
113412: CALL_OW 74
113416: PPUSH
113417: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
113421: LD_VAR 0 2
113425: PUSH
113426: LD_INT 60
113428: GREATER
113429: PUSH
113430: LD_VAR 0 3
113434: PPUSH
113435: CALL_OW 301
113439: OR
113440: IFFALSE 113317
// if un then
113442: LD_VAR 0 3
113446: IFFALSE 113457
// RemoveUnit ( un ) ;
113448: LD_VAR 0 3
113452: PPUSH
113453: CALL_OW 64
// end ;
113457: PPOPN 3
113459: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113460: LD_INT 0
113462: PPUSH
// case cmd of 301 :
113463: LD_VAR 0 1
113467: PUSH
113468: LD_INT 301
113470: DOUBLE
113471: EQUAL
113472: IFTRUE 113476
113474: GO 113508
113476: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
113477: LD_VAR 0 6
113481: PPUSH
113482: LD_VAR 0 7
113486: PPUSH
113487: LD_VAR 0 8
113491: PPUSH
113492: LD_VAR 0 4
113496: PPUSH
113497: LD_VAR 0 5
113501: PPUSH
113502: CALL 114709 0 5
113506: GO 113629
113508: LD_INT 302
113510: DOUBLE
113511: EQUAL
113512: IFTRUE 113516
113514: GO 113553
113516: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
113517: LD_VAR 0 6
113521: PPUSH
113522: LD_VAR 0 7
113526: PPUSH
113527: LD_VAR 0 8
113531: PPUSH
113532: LD_VAR 0 9
113536: PPUSH
113537: LD_VAR 0 4
113541: PPUSH
113542: LD_VAR 0 5
113546: PPUSH
113547: CALL 114800 0 6
113551: GO 113629
113553: LD_INT 303
113555: DOUBLE
113556: EQUAL
113557: IFTRUE 113561
113559: GO 113598
113561: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
113562: LD_VAR 0 6
113566: PPUSH
113567: LD_VAR 0 7
113571: PPUSH
113572: LD_VAR 0 8
113576: PPUSH
113577: LD_VAR 0 9
113581: PPUSH
113582: LD_VAR 0 4
113586: PPUSH
113587: LD_VAR 0 5
113591: PPUSH
113592: CALL 113634 0 6
113596: GO 113629
113598: LD_INT 304
113600: DOUBLE
113601: EQUAL
113602: IFTRUE 113606
113604: GO 113628
113606: POP
// hHackTeleport ( unit , x , y ) ; end ;
113607: LD_VAR 0 2
113611: PPUSH
113612: LD_VAR 0 4
113616: PPUSH
113617: LD_VAR 0 5
113621: PPUSH
113622: CALL 115393 0 3
113626: GO 113629
113628: POP
// end ;
113629: LD_VAR 0 12
113633: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
113634: LD_INT 0
113636: PPUSH
113637: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
113638: LD_VAR 0 1
113642: PUSH
113643: LD_INT 1
113645: LESS
113646: PUSH
113647: LD_VAR 0 1
113651: PUSH
113652: LD_INT 3
113654: GREATER
113655: OR
113656: PUSH
113657: LD_VAR 0 5
113661: PPUSH
113662: LD_VAR 0 6
113666: PPUSH
113667: CALL_OW 428
113671: OR
113672: IFFALSE 113676
// exit ;
113674: GO 114396
// uc_side := your_side ;
113676: LD_ADDR_OWVAR 20
113680: PUSH
113681: LD_OWVAR 2
113685: ST_TO_ADDR
// uc_nation := nation ;
113686: LD_ADDR_OWVAR 21
113690: PUSH
113691: LD_VAR 0 1
113695: ST_TO_ADDR
// bc_level = 1 ;
113696: LD_ADDR_OWVAR 43
113700: PUSH
113701: LD_INT 1
113703: ST_TO_ADDR
// case btype of 1 :
113704: LD_VAR 0 2
113708: PUSH
113709: LD_INT 1
113711: DOUBLE
113712: EQUAL
113713: IFTRUE 113717
113715: GO 113728
113717: POP
// bc_type := b_depot ; 2 :
113718: LD_ADDR_OWVAR 42
113722: PUSH
113723: LD_INT 0
113725: ST_TO_ADDR
113726: GO 114340
113728: LD_INT 2
113730: DOUBLE
113731: EQUAL
113732: IFTRUE 113736
113734: GO 113747
113736: POP
// bc_type := b_warehouse ; 3 :
113737: LD_ADDR_OWVAR 42
113741: PUSH
113742: LD_INT 1
113744: ST_TO_ADDR
113745: GO 114340
113747: LD_INT 3
113749: DOUBLE
113750: EQUAL
113751: IFTRUE 113755
113753: GO 113766
113755: POP
// bc_type := b_lab ; 4 .. 9 :
113756: LD_ADDR_OWVAR 42
113760: PUSH
113761: LD_INT 6
113763: ST_TO_ADDR
113764: GO 114340
113766: LD_INT 4
113768: DOUBLE
113769: GREATEREQUAL
113770: IFFALSE 113778
113772: LD_INT 9
113774: DOUBLE
113775: LESSEQUAL
113776: IFTRUE 113780
113778: GO 113832
113780: POP
// begin bc_type := b_lab_half ;
113781: LD_ADDR_OWVAR 42
113785: PUSH
113786: LD_INT 7
113788: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
113789: LD_ADDR_OWVAR 44
113793: PUSH
113794: LD_INT 10
113796: PUSH
113797: LD_INT 11
113799: PUSH
113800: LD_INT 12
113802: PUSH
113803: LD_INT 15
113805: PUSH
113806: LD_INT 14
113808: PUSH
113809: LD_INT 13
113811: PUSH
113812: EMPTY
113813: LIST
113814: LIST
113815: LIST
113816: LIST
113817: LIST
113818: LIST
113819: PUSH
113820: LD_VAR 0 2
113824: PUSH
113825: LD_INT 3
113827: MINUS
113828: ARRAY
113829: ST_TO_ADDR
// end ; 10 .. 13 :
113830: GO 114340
113832: LD_INT 10
113834: DOUBLE
113835: GREATEREQUAL
113836: IFFALSE 113844
113838: LD_INT 13
113840: DOUBLE
113841: LESSEQUAL
113842: IFTRUE 113846
113844: GO 113923
113846: POP
// begin bc_type := b_lab_full ;
113847: LD_ADDR_OWVAR 42
113851: PUSH
113852: LD_INT 8
113854: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113855: LD_ADDR_OWVAR 44
113859: PUSH
113860: LD_INT 10
113862: PUSH
113863: LD_INT 12
113865: PUSH
113866: LD_INT 14
113868: PUSH
113869: LD_INT 13
113871: PUSH
113872: EMPTY
113873: LIST
113874: LIST
113875: LIST
113876: LIST
113877: PUSH
113878: LD_VAR 0 2
113882: PUSH
113883: LD_INT 9
113885: MINUS
113886: ARRAY
113887: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
113888: LD_ADDR_OWVAR 45
113892: PUSH
113893: LD_INT 11
113895: PUSH
113896: LD_INT 15
113898: PUSH
113899: LD_INT 12
113901: PUSH
113902: LD_INT 15
113904: PUSH
113905: EMPTY
113906: LIST
113907: LIST
113908: LIST
113909: LIST
113910: PUSH
113911: LD_VAR 0 2
113915: PUSH
113916: LD_INT 9
113918: MINUS
113919: ARRAY
113920: ST_TO_ADDR
// end ; 14 :
113921: GO 114340
113923: LD_INT 14
113925: DOUBLE
113926: EQUAL
113927: IFTRUE 113931
113929: GO 113942
113931: POP
// bc_type := b_workshop ; 15 :
113932: LD_ADDR_OWVAR 42
113936: PUSH
113937: LD_INT 2
113939: ST_TO_ADDR
113940: GO 114340
113942: LD_INT 15
113944: DOUBLE
113945: EQUAL
113946: IFTRUE 113950
113948: GO 113961
113950: POP
// bc_type := b_factory ; 16 :
113951: LD_ADDR_OWVAR 42
113955: PUSH
113956: LD_INT 3
113958: ST_TO_ADDR
113959: GO 114340
113961: LD_INT 16
113963: DOUBLE
113964: EQUAL
113965: IFTRUE 113969
113967: GO 113980
113969: POP
// bc_type := b_ext_gun ; 17 :
113970: LD_ADDR_OWVAR 42
113974: PUSH
113975: LD_INT 17
113977: ST_TO_ADDR
113978: GO 114340
113980: LD_INT 17
113982: DOUBLE
113983: EQUAL
113984: IFTRUE 113988
113986: GO 114016
113988: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113989: LD_ADDR_OWVAR 42
113993: PUSH
113994: LD_INT 19
113996: PUSH
113997: LD_INT 23
113999: PUSH
114000: LD_INT 19
114002: PUSH
114003: EMPTY
114004: LIST
114005: LIST
114006: LIST
114007: PUSH
114008: LD_VAR 0 1
114012: ARRAY
114013: ST_TO_ADDR
114014: GO 114340
114016: LD_INT 18
114018: DOUBLE
114019: EQUAL
114020: IFTRUE 114024
114022: GO 114035
114024: POP
// bc_type := b_ext_radar ; 19 :
114025: LD_ADDR_OWVAR 42
114029: PUSH
114030: LD_INT 20
114032: ST_TO_ADDR
114033: GO 114340
114035: LD_INT 19
114037: DOUBLE
114038: EQUAL
114039: IFTRUE 114043
114041: GO 114054
114043: POP
// bc_type := b_ext_radio ; 20 :
114044: LD_ADDR_OWVAR 42
114048: PUSH
114049: LD_INT 22
114051: ST_TO_ADDR
114052: GO 114340
114054: LD_INT 20
114056: DOUBLE
114057: EQUAL
114058: IFTRUE 114062
114060: GO 114073
114062: POP
// bc_type := b_ext_siberium ; 21 :
114063: LD_ADDR_OWVAR 42
114067: PUSH
114068: LD_INT 21
114070: ST_TO_ADDR
114071: GO 114340
114073: LD_INT 21
114075: DOUBLE
114076: EQUAL
114077: IFTRUE 114081
114079: GO 114092
114081: POP
// bc_type := b_ext_computer ; 22 :
114082: LD_ADDR_OWVAR 42
114086: PUSH
114087: LD_INT 24
114089: ST_TO_ADDR
114090: GO 114340
114092: LD_INT 22
114094: DOUBLE
114095: EQUAL
114096: IFTRUE 114100
114098: GO 114111
114100: POP
// bc_type := b_ext_track ; 23 :
114101: LD_ADDR_OWVAR 42
114105: PUSH
114106: LD_INT 16
114108: ST_TO_ADDR
114109: GO 114340
114111: LD_INT 23
114113: DOUBLE
114114: EQUAL
114115: IFTRUE 114119
114117: GO 114130
114119: POP
// bc_type := b_ext_laser ; 24 :
114120: LD_ADDR_OWVAR 42
114124: PUSH
114125: LD_INT 25
114127: ST_TO_ADDR
114128: GO 114340
114130: LD_INT 24
114132: DOUBLE
114133: EQUAL
114134: IFTRUE 114138
114136: GO 114149
114138: POP
// bc_type := b_control_tower ; 25 :
114139: LD_ADDR_OWVAR 42
114143: PUSH
114144: LD_INT 36
114146: ST_TO_ADDR
114147: GO 114340
114149: LD_INT 25
114151: DOUBLE
114152: EQUAL
114153: IFTRUE 114157
114155: GO 114168
114157: POP
// bc_type := b_breastwork ; 26 :
114158: LD_ADDR_OWVAR 42
114162: PUSH
114163: LD_INT 31
114165: ST_TO_ADDR
114166: GO 114340
114168: LD_INT 26
114170: DOUBLE
114171: EQUAL
114172: IFTRUE 114176
114174: GO 114187
114176: POP
// bc_type := b_bunker ; 27 :
114177: LD_ADDR_OWVAR 42
114181: PUSH
114182: LD_INT 32
114184: ST_TO_ADDR
114185: GO 114340
114187: LD_INT 27
114189: DOUBLE
114190: EQUAL
114191: IFTRUE 114195
114193: GO 114206
114195: POP
// bc_type := b_turret ; 28 :
114196: LD_ADDR_OWVAR 42
114200: PUSH
114201: LD_INT 33
114203: ST_TO_ADDR
114204: GO 114340
114206: LD_INT 28
114208: DOUBLE
114209: EQUAL
114210: IFTRUE 114214
114212: GO 114225
114214: POP
// bc_type := b_armoury ; 29 :
114215: LD_ADDR_OWVAR 42
114219: PUSH
114220: LD_INT 4
114222: ST_TO_ADDR
114223: GO 114340
114225: LD_INT 29
114227: DOUBLE
114228: EQUAL
114229: IFTRUE 114233
114231: GO 114244
114233: POP
// bc_type := b_barracks ; 30 :
114234: LD_ADDR_OWVAR 42
114238: PUSH
114239: LD_INT 5
114241: ST_TO_ADDR
114242: GO 114340
114244: LD_INT 30
114246: DOUBLE
114247: EQUAL
114248: IFTRUE 114252
114250: GO 114263
114252: POP
// bc_type := b_solar_power ; 31 :
114253: LD_ADDR_OWVAR 42
114257: PUSH
114258: LD_INT 27
114260: ST_TO_ADDR
114261: GO 114340
114263: LD_INT 31
114265: DOUBLE
114266: EQUAL
114267: IFTRUE 114271
114269: GO 114282
114271: POP
// bc_type := b_oil_power ; 32 :
114272: LD_ADDR_OWVAR 42
114276: PUSH
114277: LD_INT 26
114279: ST_TO_ADDR
114280: GO 114340
114282: LD_INT 32
114284: DOUBLE
114285: EQUAL
114286: IFTRUE 114290
114288: GO 114301
114290: POP
// bc_type := b_siberite_power ; 33 :
114291: LD_ADDR_OWVAR 42
114295: PUSH
114296: LD_INT 28
114298: ST_TO_ADDR
114299: GO 114340
114301: LD_INT 33
114303: DOUBLE
114304: EQUAL
114305: IFTRUE 114309
114307: GO 114320
114309: POP
// bc_type := b_oil_mine ; 34 :
114310: LD_ADDR_OWVAR 42
114314: PUSH
114315: LD_INT 29
114317: ST_TO_ADDR
114318: GO 114340
114320: LD_INT 34
114322: DOUBLE
114323: EQUAL
114324: IFTRUE 114328
114326: GO 114339
114328: POP
// bc_type := b_siberite_mine ; end ;
114329: LD_ADDR_OWVAR 42
114333: PUSH
114334: LD_INT 30
114336: ST_TO_ADDR
114337: GO 114340
114339: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
114340: LD_ADDR_VAR 0 8
114344: PUSH
114345: LD_VAR 0 5
114349: PPUSH
114350: LD_VAR 0 6
114354: PPUSH
114355: LD_VAR 0 3
114359: PPUSH
114360: CALL_OW 47
114364: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
114365: LD_OWVAR 42
114369: PUSH
114370: LD_INT 32
114372: PUSH
114373: LD_INT 33
114375: PUSH
114376: EMPTY
114377: LIST
114378: LIST
114379: IN
114380: IFFALSE 114396
// PlaceWeaponTurret ( b , weapon ) ;
114382: LD_VAR 0 8
114386: PPUSH
114387: LD_VAR 0 4
114391: PPUSH
114392: CALL_OW 431
// end ;
114396: LD_VAR 0 7
114400: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
114401: LD_INT 0
114403: PPUSH
114404: PPUSH
114405: PPUSH
114406: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114407: LD_ADDR_VAR 0 4
114411: PUSH
114412: LD_INT 22
114414: PUSH
114415: LD_OWVAR 2
114419: PUSH
114420: EMPTY
114421: LIST
114422: LIST
114423: PUSH
114424: LD_INT 2
114426: PUSH
114427: LD_INT 30
114429: PUSH
114430: LD_INT 0
114432: PUSH
114433: EMPTY
114434: LIST
114435: LIST
114436: PUSH
114437: LD_INT 30
114439: PUSH
114440: LD_INT 1
114442: PUSH
114443: EMPTY
114444: LIST
114445: LIST
114446: PUSH
114447: EMPTY
114448: LIST
114449: LIST
114450: LIST
114451: PUSH
114452: EMPTY
114453: LIST
114454: LIST
114455: PPUSH
114456: CALL_OW 69
114460: ST_TO_ADDR
// if not tmp then
114461: LD_VAR 0 4
114465: NOT
114466: IFFALSE 114470
// exit ;
114468: GO 114529
// for i in tmp do
114470: LD_ADDR_VAR 0 2
114474: PUSH
114475: LD_VAR 0 4
114479: PUSH
114480: FOR_IN
114481: IFFALSE 114527
// for j = 1 to 3 do
114483: LD_ADDR_VAR 0 3
114487: PUSH
114488: DOUBLE
114489: LD_INT 1
114491: DEC
114492: ST_TO_ADDR
114493: LD_INT 3
114495: PUSH
114496: FOR_TO
114497: IFFALSE 114523
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
114499: LD_VAR 0 2
114503: PPUSH
114504: CALL_OW 274
114508: PPUSH
114509: LD_VAR 0 3
114513: PPUSH
114514: LD_INT 99999
114516: PPUSH
114517: CALL_OW 277
114521: GO 114496
114523: POP
114524: POP
114525: GO 114480
114527: POP
114528: POP
// end ;
114529: LD_VAR 0 1
114533: RET
// export function hHackSetLevel10 ; var i , j ; begin
114534: LD_INT 0
114536: PPUSH
114537: PPUSH
114538: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114539: LD_ADDR_VAR 0 2
114543: PUSH
114544: LD_INT 21
114546: PUSH
114547: LD_INT 1
114549: PUSH
114550: EMPTY
114551: LIST
114552: LIST
114553: PPUSH
114554: CALL_OW 69
114558: PUSH
114559: FOR_IN
114560: IFFALSE 114612
// if IsSelected ( i ) then
114562: LD_VAR 0 2
114566: PPUSH
114567: CALL_OW 306
114571: IFFALSE 114610
// begin for j := 1 to 4 do
114573: LD_ADDR_VAR 0 3
114577: PUSH
114578: DOUBLE
114579: LD_INT 1
114581: DEC
114582: ST_TO_ADDR
114583: LD_INT 4
114585: PUSH
114586: FOR_TO
114587: IFFALSE 114608
// SetSkill ( i , j , 10 ) ;
114589: LD_VAR 0 2
114593: PPUSH
114594: LD_VAR 0 3
114598: PPUSH
114599: LD_INT 10
114601: PPUSH
114602: CALL_OW 237
114606: GO 114586
114608: POP
114609: POP
// end ;
114610: GO 114559
114612: POP
114613: POP
// end ;
114614: LD_VAR 0 1
114618: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
114619: LD_INT 0
114621: PPUSH
114622: PPUSH
114623: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
114624: LD_ADDR_VAR 0 2
114628: PUSH
114629: LD_INT 22
114631: PUSH
114632: LD_OWVAR 2
114636: PUSH
114637: EMPTY
114638: LIST
114639: LIST
114640: PUSH
114641: LD_INT 21
114643: PUSH
114644: LD_INT 1
114646: PUSH
114647: EMPTY
114648: LIST
114649: LIST
114650: PUSH
114651: EMPTY
114652: LIST
114653: LIST
114654: PPUSH
114655: CALL_OW 69
114659: PUSH
114660: FOR_IN
114661: IFFALSE 114702
// begin for j := 1 to 4 do
114663: LD_ADDR_VAR 0 3
114667: PUSH
114668: DOUBLE
114669: LD_INT 1
114671: DEC
114672: ST_TO_ADDR
114673: LD_INT 4
114675: PUSH
114676: FOR_TO
114677: IFFALSE 114698
// SetSkill ( i , j , 10 ) ;
114679: LD_VAR 0 2
114683: PPUSH
114684: LD_VAR 0 3
114688: PPUSH
114689: LD_INT 10
114691: PPUSH
114692: CALL_OW 237
114696: GO 114676
114698: POP
114699: POP
// end ;
114700: GO 114660
114702: POP
114703: POP
// end ;
114704: LD_VAR 0 1
114708: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
114709: LD_INT 0
114711: PPUSH
// uc_side := your_side ;
114712: LD_ADDR_OWVAR 20
114716: PUSH
114717: LD_OWVAR 2
114721: ST_TO_ADDR
// uc_nation := nation ;
114722: LD_ADDR_OWVAR 21
114726: PUSH
114727: LD_VAR 0 1
114731: ST_TO_ADDR
// InitHc ;
114732: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
114736: LD_INT 0
114738: PPUSH
114739: LD_VAR 0 2
114743: PPUSH
114744: LD_VAR 0 3
114748: PPUSH
114749: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
114753: LD_VAR 0 4
114757: PPUSH
114758: LD_VAR 0 5
114762: PPUSH
114763: CALL_OW 428
114767: PUSH
114768: LD_INT 0
114770: EQUAL
114771: IFFALSE 114795
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
114773: CALL_OW 44
114777: PPUSH
114778: LD_VAR 0 4
114782: PPUSH
114783: LD_VAR 0 5
114787: PPUSH
114788: LD_INT 1
114790: PPUSH
114791: CALL_OW 48
// end ;
114795: LD_VAR 0 6
114799: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
114800: LD_INT 0
114802: PPUSH
114803: PPUSH
// uc_side := your_side ;
114804: LD_ADDR_OWVAR 20
114808: PUSH
114809: LD_OWVAR 2
114813: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114814: LD_VAR 0 1
114818: PUSH
114819: LD_INT 1
114821: PUSH
114822: LD_INT 2
114824: PUSH
114825: LD_INT 3
114827: PUSH
114828: LD_INT 4
114830: PUSH
114831: LD_INT 5
114833: PUSH
114834: EMPTY
114835: LIST
114836: LIST
114837: LIST
114838: LIST
114839: LIST
114840: IN
114841: IFFALSE 114853
// uc_nation := nation_american else
114843: LD_ADDR_OWVAR 21
114847: PUSH
114848: LD_INT 1
114850: ST_TO_ADDR
114851: GO 114896
// if chassis in [ 11 , 12 , 13 , 14 ] then
114853: LD_VAR 0 1
114857: PUSH
114858: LD_INT 11
114860: PUSH
114861: LD_INT 12
114863: PUSH
114864: LD_INT 13
114866: PUSH
114867: LD_INT 14
114869: PUSH
114870: EMPTY
114871: LIST
114872: LIST
114873: LIST
114874: LIST
114875: IN
114876: IFFALSE 114888
// uc_nation := nation_arabian else
114878: LD_ADDR_OWVAR 21
114882: PUSH
114883: LD_INT 2
114885: ST_TO_ADDR
114886: GO 114896
// uc_nation := nation_russian ;
114888: LD_ADDR_OWVAR 21
114892: PUSH
114893: LD_INT 3
114895: ST_TO_ADDR
// vc_chassis := chassis ;
114896: LD_ADDR_OWVAR 37
114900: PUSH
114901: LD_VAR 0 1
114905: ST_TO_ADDR
// vc_engine := engine ;
114906: LD_ADDR_OWVAR 39
114910: PUSH
114911: LD_VAR 0 2
114915: ST_TO_ADDR
// vc_control := control ;
114916: LD_ADDR_OWVAR 38
114920: PUSH
114921: LD_VAR 0 3
114925: ST_TO_ADDR
// vc_weapon := weapon ;
114926: LD_ADDR_OWVAR 40
114930: PUSH
114931: LD_VAR 0 4
114935: ST_TO_ADDR
// un := CreateVehicle ;
114936: LD_ADDR_VAR 0 8
114940: PUSH
114941: CALL_OW 45
114945: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
114946: LD_VAR 0 8
114950: PPUSH
114951: LD_INT 0
114953: PPUSH
114954: LD_INT 5
114956: PPUSH
114957: CALL_OW 12
114961: PPUSH
114962: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
114966: LD_VAR 0 8
114970: PPUSH
114971: LD_VAR 0 5
114975: PPUSH
114976: LD_VAR 0 6
114980: PPUSH
114981: LD_INT 1
114983: PPUSH
114984: CALL_OW 48
// end ;
114988: LD_VAR 0 7
114992: RET
// export hInvincible ; every 1 do
114993: GO 114995
114995: DISABLE
// hInvincible := [ ] ;
114996: LD_ADDR_EXP 210
115000: PUSH
115001: EMPTY
115002: ST_TO_ADDR
115003: END
// every 10 do var i ;
115004: GO 115006
115006: DISABLE
115007: LD_INT 0
115009: PPUSH
// begin enable ;
115010: ENABLE
// if not hInvincible then
115011: LD_EXP 210
115015: NOT
115016: IFFALSE 115020
// exit ;
115018: GO 115064
// for i in hInvincible do
115020: LD_ADDR_VAR 0 1
115024: PUSH
115025: LD_EXP 210
115029: PUSH
115030: FOR_IN
115031: IFFALSE 115062
// if GetLives ( i ) < 1000 then
115033: LD_VAR 0 1
115037: PPUSH
115038: CALL_OW 256
115042: PUSH
115043: LD_INT 1000
115045: LESS
115046: IFFALSE 115060
// SetLives ( i , 1000 ) ;
115048: LD_VAR 0 1
115052: PPUSH
115053: LD_INT 1000
115055: PPUSH
115056: CALL_OW 234
115060: GO 115030
115062: POP
115063: POP
// end ;
115064: PPOPN 1
115066: END
// export function hHackInvincible ; var i ; begin
115067: LD_INT 0
115069: PPUSH
115070: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
115071: LD_ADDR_VAR 0 2
115075: PUSH
115076: LD_INT 2
115078: PUSH
115079: LD_INT 21
115081: PUSH
115082: LD_INT 1
115084: PUSH
115085: EMPTY
115086: LIST
115087: LIST
115088: PUSH
115089: LD_INT 21
115091: PUSH
115092: LD_INT 2
115094: PUSH
115095: EMPTY
115096: LIST
115097: LIST
115098: PUSH
115099: EMPTY
115100: LIST
115101: LIST
115102: LIST
115103: PPUSH
115104: CALL_OW 69
115108: PUSH
115109: FOR_IN
115110: IFFALSE 115171
// if IsSelected ( i ) then
115112: LD_VAR 0 2
115116: PPUSH
115117: CALL_OW 306
115121: IFFALSE 115169
// begin if i in hInvincible then
115123: LD_VAR 0 2
115127: PUSH
115128: LD_EXP 210
115132: IN
115133: IFFALSE 115153
// hInvincible := hInvincible diff i else
115135: LD_ADDR_EXP 210
115139: PUSH
115140: LD_EXP 210
115144: PUSH
115145: LD_VAR 0 2
115149: DIFF
115150: ST_TO_ADDR
115151: GO 115169
// hInvincible := hInvincible union i ;
115153: LD_ADDR_EXP 210
115157: PUSH
115158: LD_EXP 210
115162: PUSH
115163: LD_VAR 0 2
115167: UNION
115168: ST_TO_ADDR
// end ;
115169: GO 115109
115171: POP
115172: POP
// end ;
115173: LD_VAR 0 1
115177: RET
// export function hHackInvisible ; var i , j ; begin
115178: LD_INT 0
115180: PPUSH
115181: PPUSH
115182: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115183: LD_ADDR_VAR 0 2
115187: PUSH
115188: LD_INT 21
115190: PUSH
115191: LD_INT 1
115193: PUSH
115194: EMPTY
115195: LIST
115196: LIST
115197: PPUSH
115198: CALL_OW 69
115202: PUSH
115203: FOR_IN
115204: IFFALSE 115228
// if IsSelected ( i ) then
115206: LD_VAR 0 2
115210: PPUSH
115211: CALL_OW 306
115215: IFFALSE 115226
// ComForceInvisible ( i ) ;
115217: LD_VAR 0 2
115221: PPUSH
115222: CALL_OW 496
115226: GO 115203
115228: POP
115229: POP
// end ;
115230: LD_VAR 0 1
115234: RET
// export function hHackChangeYourSide ; begin
115235: LD_INT 0
115237: PPUSH
// if your_side = 8 then
115238: LD_OWVAR 2
115242: PUSH
115243: LD_INT 8
115245: EQUAL
115246: IFFALSE 115258
// your_side := 0 else
115248: LD_ADDR_OWVAR 2
115252: PUSH
115253: LD_INT 0
115255: ST_TO_ADDR
115256: GO 115272
// your_side := your_side + 1 ;
115258: LD_ADDR_OWVAR 2
115262: PUSH
115263: LD_OWVAR 2
115267: PUSH
115268: LD_INT 1
115270: PLUS
115271: ST_TO_ADDR
// end ;
115272: LD_VAR 0 1
115276: RET
// export function hHackChangeUnitSide ; var i , j ; begin
115277: LD_INT 0
115279: PPUSH
115280: PPUSH
115281: PPUSH
// for i in all_units do
115282: LD_ADDR_VAR 0 2
115286: PUSH
115287: LD_OWVAR 3
115291: PUSH
115292: FOR_IN
115293: IFFALSE 115371
// if IsSelected ( i ) then
115295: LD_VAR 0 2
115299: PPUSH
115300: CALL_OW 306
115304: IFFALSE 115369
// begin j := GetSide ( i ) ;
115306: LD_ADDR_VAR 0 3
115310: PUSH
115311: LD_VAR 0 2
115315: PPUSH
115316: CALL_OW 255
115320: ST_TO_ADDR
// if j = 8 then
115321: LD_VAR 0 3
115325: PUSH
115326: LD_INT 8
115328: EQUAL
115329: IFFALSE 115341
// j := 0 else
115331: LD_ADDR_VAR 0 3
115335: PUSH
115336: LD_INT 0
115338: ST_TO_ADDR
115339: GO 115355
// j := j + 1 ;
115341: LD_ADDR_VAR 0 3
115345: PUSH
115346: LD_VAR 0 3
115350: PUSH
115351: LD_INT 1
115353: PLUS
115354: ST_TO_ADDR
// SetSide ( i , j ) ;
115355: LD_VAR 0 2
115359: PPUSH
115360: LD_VAR 0 3
115364: PPUSH
115365: CALL_OW 235
// end ;
115369: GO 115292
115371: POP
115372: POP
// end ;
115373: LD_VAR 0 1
115377: RET
// export function hHackFog ; begin
115378: LD_INT 0
115380: PPUSH
// FogOff ( true ) ;
115381: LD_INT 1
115383: PPUSH
115384: CALL_OW 344
// end ;
115388: LD_VAR 0 1
115392: RET
// export function hHackTeleport ( unit , x , y ) ; begin
115393: LD_INT 0
115395: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
115396: LD_VAR 0 1
115400: PPUSH
115401: LD_VAR 0 2
115405: PPUSH
115406: LD_VAR 0 3
115410: PPUSH
115411: LD_INT 1
115413: PPUSH
115414: LD_INT 1
115416: PPUSH
115417: CALL_OW 483
// CenterOnXY ( x , y ) ;
115421: LD_VAR 0 2
115425: PPUSH
115426: LD_VAR 0 3
115430: PPUSH
115431: CALL_OW 84
// end ; end_of_file
115435: LD_VAR 0 4
115439: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
115440: LD_INT 0
115442: PPUSH
115443: PPUSH
115444: PPUSH
115445: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
115446: LD_VAR 0 1
115450: PPUSH
115451: CALL_OW 264
115455: PUSH
115456: LD_EXP 99
115460: EQUAL
115461: IFFALSE 115533
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115463: LD_INT 68
115465: PPUSH
115466: LD_VAR 0 1
115470: PPUSH
115471: CALL_OW 255
115475: PPUSH
115476: CALL_OW 321
115480: PUSH
115481: LD_INT 2
115483: EQUAL
115484: IFFALSE 115496
// eff := 70 else
115486: LD_ADDR_VAR 0 4
115490: PUSH
115491: LD_INT 70
115493: ST_TO_ADDR
115494: GO 115504
// eff := 30 ;
115496: LD_ADDR_VAR 0 4
115500: PUSH
115501: LD_INT 30
115503: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115504: LD_VAR 0 1
115508: PPUSH
115509: CALL_OW 250
115513: PPUSH
115514: LD_VAR 0 1
115518: PPUSH
115519: CALL_OW 251
115523: PPUSH
115524: LD_VAR 0 4
115528: PPUSH
115529: CALL_OW 495
// end ; end ;
115533: LD_VAR 0 2
115537: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
115538: LD_INT 0
115540: PPUSH
// end ;
115541: LD_VAR 0 4
115545: RET
// export function SOS_Command ( cmd ) ; begin
115546: LD_INT 0
115548: PPUSH
// end ;
115549: LD_VAR 0 2
115553: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
115554: LD_INT 0
115556: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
115557: LD_VAR 0 1
115561: PUSH
115562: LD_INT 250
115564: EQUAL
115565: PUSH
115566: LD_VAR 0 2
115570: PPUSH
115571: CALL_OW 264
115575: PUSH
115576: LD_EXP 102
115580: EQUAL
115581: AND
115582: IFFALSE 115603
// MinerPlaceMine ( unit , x , y ) ;
115584: LD_VAR 0 2
115588: PPUSH
115589: LD_VAR 0 4
115593: PPUSH
115594: LD_VAR 0 5
115598: PPUSH
115599: CALL 117944 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
115603: LD_VAR 0 1
115607: PUSH
115608: LD_INT 251
115610: EQUAL
115611: PUSH
115612: LD_VAR 0 2
115616: PPUSH
115617: CALL_OW 264
115621: PUSH
115622: LD_EXP 102
115626: EQUAL
115627: AND
115628: IFFALSE 115649
// MinerDetonateMine ( unit , x , y ) ;
115630: LD_VAR 0 2
115634: PPUSH
115635: LD_VAR 0 4
115639: PPUSH
115640: LD_VAR 0 5
115644: PPUSH
115645: CALL 118221 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
115649: LD_VAR 0 1
115653: PUSH
115654: LD_INT 252
115656: EQUAL
115657: PUSH
115658: LD_VAR 0 2
115662: PPUSH
115663: CALL_OW 264
115667: PUSH
115668: LD_EXP 102
115672: EQUAL
115673: AND
115674: IFFALSE 115695
// MinerCreateMinefield ( unit , x , y ) ;
115676: LD_VAR 0 2
115680: PPUSH
115681: LD_VAR 0 4
115685: PPUSH
115686: LD_VAR 0 5
115690: PPUSH
115691: CALL 118638 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115695: LD_VAR 0 1
115699: PUSH
115700: LD_INT 253
115702: EQUAL
115703: PUSH
115704: LD_VAR 0 2
115708: PPUSH
115709: CALL_OW 257
115713: PUSH
115714: LD_INT 5
115716: EQUAL
115717: AND
115718: IFFALSE 115739
// ComBinocular ( unit , x , y ) ;
115720: LD_VAR 0 2
115724: PPUSH
115725: LD_VAR 0 4
115729: PPUSH
115730: LD_VAR 0 5
115734: PPUSH
115735: CALL 119009 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115739: LD_VAR 0 1
115743: PUSH
115744: LD_INT 254
115746: EQUAL
115747: PUSH
115748: LD_VAR 0 2
115752: PPUSH
115753: CALL_OW 264
115757: PUSH
115758: LD_EXP 97
115762: EQUAL
115763: AND
115764: PUSH
115765: LD_VAR 0 3
115769: PPUSH
115770: CALL_OW 263
115774: PUSH
115775: LD_INT 3
115777: EQUAL
115778: AND
115779: IFFALSE 115795
// HackDestroyVehicle ( unit , selectedUnit ) ;
115781: LD_VAR 0 2
115785: PPUSH
115786: LD_VAR 0 3
115790: PPUSH
115791: CALL 117304 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115795: LD_VAR 0 1
115799: PUSH
115800: LD_INT 255
115802: EQUAL
115803: PUSH
115804: LD_VAR 0 2
115808: PPUSH
115809: CALL_OW 264
115813: PUSH
115814: LD_INT 14
115816: PUSH
115817: LD_INT 53
115819: PUSH
115820: EMPTY
115821: LIST
115822: LIST
115823: IN
115824: AND
115825: PUSH
115826: LD_VAR 0 4
115830: PPUSH
115831: LD_VAR 0 5
115835: PPUSH
115836: CALL_OW 488
115840: AND
115841: IFFALSE 115865
// CutTreeXYR ( unit , x , y , 12 ) ;
115843: LD_VAR 0 2
115847: PPUSH
115848: LD_VAR 0 4
115852: PPUSH
115853: LD_VAR 0 5
115857: PPUSH
115858: LD_INT 12
115860: PPUSH
115861: CALL 115870 0 4
// end ;
115865: LD_VAR 0 6
115869: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115870: LD_INT 0
115872: PPUSH
115873: PPUSH
115874: PPUSH
115875: PPUSH
115876: PPUSH
115877: PPUSH
115878: PPUSH
115879: PPUSH
115880: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
115881: LD_VAR 0 1
115885: NOT
115886: PUSH
115887: LD_VAR 0 2
115891: PPUSH
115892: LD_VAR 0 3
115896: PPUSH
115897: CALL_OW 488
115901: NOT
115902: OR
115903: PUSH
115904: LD_VAR 0 4
115908: NOT
115909: OR
115910: IFFALSE 115914
// exit ;
115912: GO 116254
// list := [ ] ;
115914: LD_ADDR_VAR 0 13
115918: PUSH
115919: EMPTY
115920: ST_TO_ADDR
// if x - r < 0 then
115921: LD_VAR 0 2
115925: PUSH
115926: LD_VAR 0 4
115930: MINUS
115931: PUSH
115932: LD_INT 0
115934: LESS
115935: IFFALSE 115947
// min_x := 0 else
115937: LD_ADDR_VAR 0 7
115941: PUSH
115942: LD_INT 0
115944: ST_TO_ADDR
115945: GO 115963
// min_x := x - r ;
115947: LD_ADDR_VAR 0 7
115951: PUSH
115952: LD_VAR 0 2
115956: PUSH
115957: LD_VAR 0 4
115961: MINUS
115962: ST_TO_ADDR
// if y - r < 0 then
115963: LD_VAR 0 3
115967: PUSH
115968: LD_VAR 0 4
115972: MINUS
115973: PUSH
115974: LD_INT 0
115976: LESS
115977: IFFALSE 115989
// min_y := 0 else
115979: LD_ADDR_VAR 0 8
115983: PUSH
115984: LD_INT 0
115986: ST_TO_ADDR
115987: GO 116005
// min_y := y - r ;
115989: LD_ADDR_VAR 0 8
115993: PUSH
115994: LD_VAR 0 3
115998: PUSH
115999: LD_VAR 0 4
116003: MINUS
116004: ST_TO_ADDR
// max_x := x + r ;
116005: LD_ADDR_VAR 0 9
116009: PUSH
116010: LD_VAR 0 2
116014: PUSH
116015: LD_VAR 0 4
116019: PLUS
116020: ST_TO_ADDR
// max_y := y + r ;
116021: LD_ADDR_VAR 0 10
116025: PUSH
116026: LD_VAR 0 3
116030: PUSH
116031: LD_VAR 0 4
116035: PLUS
116036: ST_TO_ADDR
// for _x = min_x to max_x do
116037: LD_ADDR_VAR 0 11
116041: PUSH
116042: DOUBLE
116043: LD_VAR 0 7
116047: DEC
116048: ST_TO_ADDR
116049: LD_VAR 0 9
116053: PUSH
116054: FOR_TO
116055: IFFALSE 116172
// for _y = min_y to max_y do
116057: LD_ADDR_VAR 0 12
116061: PUSH
116062: DOUBLE
116063: LD_VAR 0 8
116067: DEC
116068: ST_TO_ADDR
116069: LD_VAR 0 10
116073: PUSH
116074: FOR_TO
116075: IFFALSE 116168
// begin if not ValidHex ( _x , _y ) then
116077: LD_VAR 0 11
116081: PPUSH
116082: LD_VAR 0 12
116086: PPUSH
116087: CALL_OW 488
116091: NOT
116092: IFFALSE 116096
// continue ;
116094: GO 116074
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116096: LD_VAR 0 11
116100: PPUSH
116101: LD_VAR 0 12
116105: PPUSH
116106: CALL_OW 351
116110: PUSH
116111: LD_VAR 0 11
116115: PPUSH
116116: LD_VAR 0 12
116120: PPUSH
116121: CALL_OW 554
116125: AND
116126: IFFALSE 116166
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116128: LD_ADDR_VAR 0 13
116132: PUSH
116133: LD_VAR 0 13
116137: PPUSH
116138: LD_VAR 0 13
116142: PUSH
116143: LD_INT 1
116145: PLUS
116146: PPUSH
116147: LD_VAR 0 11
116151: PUSH
116152: LD_VAR 0 12
116156: PUSH
116157: EMPTY
116158: LIST
116159: LIST
116160: PPUSH
116161: CALL_OW 2
116165: ST_TO_ADDR
// end ;
116166: GO 116074
116168: POP
116169: POP
116170: GO 116054
116172: POP
116173: POP
// if not list then
116174: LD_VAR 0 13
116178: NOT
116179: IFFALSE 116183
// exit ;
116181: GO 116254
// for i in list do
116183: LD_ADDR_VAR 0 6
116187: PUSH
116188: LD_VAR 0 13
116192: PUSH
116193: FOR_IN
116194: IFFALSE 116252
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
116196: LD_VAR 0 1
116200: PPUSH
116201: LD_STRING M
116203: PUSH
116204: LD_VAR 0 6
116208: PUSH
116209: LD_INT 1
116211: ARRAY
116212: PUSH
116213: LD_VAR 0 6
116217: PUSH
116218: LD_INT 2
116220: ARRAY
116221: PUSH
116222: LD_INT 0
116224: PUSH
116225: LD_INT 0
116227: PUSH
116228: LD_INT 0
116230: PUSH
116231: LD_INT 0
116233: PUSH
116234: EMPTY
116235: LIST
116236: LIST
116237: LIST
116238: LIST
116239: LIST
116240: LIST
116241: LIST
116242: PUSH
116243: EMPTY
116244: LIST
116245: PPUSH
116246: CALL_OW 447
116250: GO 116193
116252: POP
116253: POP
// end ;
116254: LD_VAR 0 5
116258: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116259: LD_EXP 211
116263: NOT
116264: IFFALSE 116314
116266: GO 116268
116268: DISABLE
// begin initHack := true ;
116269: LD_ADDR_EXP 211
116273: PUSH
116274: LD_INT 1
116276: ST_TO_ADDR
// hackTanks := [ ] ;
116277: LD_ADDR_EXP 212
116281: PUSH
116282: EMPTY
116283: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116284: LD_ADDR_EXP 213
116288: PUSH
116289: EMPTY
116290: ST_TO_ADDR
// hackLimit := 3 ;
116291: LD_ADDR_EXP 214
116295: PUSH
116296: LD_INT 3
116298: ST_TO_ADDR
// hackDist := 12 ;
116299: LD_ADDR_EXP 215
116303: PUSH
116304: LD_INT 12
116306: ST_TO_ADDR
// hackCounter := [ ] ;
116307: LD_ADDR_EXP 216
116311: PUSH
116312: EMPTY
116313: ST_TO_ADDR
// end ;
116314: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116315: LD_EXP 211
116319: PUSH
116320: LD_INT 34
116322: PUSH
116323: LD_EXP 97
116327: PUSH
116328: EMPTY
116329: LIST
116330: LIST
116331: PPUSH
116332: CALL_OW 69
116336: AND
116337: IFFALSE 116592
116339: GO 116341
116341: DISABLE
116342: LD_INT 0
116344: PPUSH
116345: PPUSH
// begin enable ;
116346: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116347: LD_ADDR_VAR 0 1
116351: PUSH
116352: LD_INT 34
116354: PUSH
116355: LD_EXP 97
116359: PUSH
116360: EMPTY
116361: LIST
116362: LIST
116363: PPUSH
116364: CALL_OW 69
116368: PUSH
116369: FOR_IN
116370: IFFALSE 116590
// begin if not i in hackTanks then
116372: LD_VAR 0 1
116376: PUSH
116377: LD_EXP 212
116381: IN
116382: NOT
116383: IFFALSE 116466
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116385: LD_ADDR_EXP 212
116389: PUSH
116390: LD_EXP 212
116394: PPUSH
116395: LD_EXP 212
116399: PUSH
116400: LD_INT 1
116402: PLUS
116403: PPUSH
116404: LD_VAR 0 1
116408: PPUSH
116409: CALL_OW 1
116413: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116414: LD_ADDR_EXP 213
116418: PUSH
116419: LD_EXP 213
116423: PPUSH
116424: LD_EXP 213
116428: PUSH
116429: LD_INT 1
116431: PLUS
116432: PPUSH
116433: EMPTY
116434: PPUSH
116435: CALL_OW 1
116439: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116440: LD_ADDR_EXP 216
116444: PUSH
116445: LD_EXP 216
116449: PPUSH
116450: LD_EXP 216
116454: PUSH
116455: LD_INT 1
116457: PLUS
116458: PPUSH
116459: EMPTY
116460: PPUSH
116461: CALL_OW 1
116465: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116466: LD_VAR 0 1
116470: PPUSH
116471: CALL_OW 302
116475: NOT
116476: IFFALSE 116489
// begin HackUnlinkAll ( i ) ;
116478: LD_VAR 0 1
116482: PPUSH
116483: CALL 116595 0 1
// continue ;
116487: GO 116369
// end ; HackCheckCapturedStatus ( i ) ;
116489: LD_VAR 0 1
116493: PPUSH
116494: CALL 117038 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116498: LD_ADDR_VAR 0 2
116502: PUSH
116503: LD_INT 81
116505: PUSH
116506: LD_VAR 0 1
116510: PPUSH
116511: CALL_OW 255
116515: PUSH
116516: EMPTY
116517: LIST
116518: LIST
116519: PUSH
116520: LD_INT 33
116522: PUSH
116523: LD_INT 3
116525: PUSH
116526: EMPTY
116527: LIST
116528: LIST
116529: PUSH
116530: LD_INT 91
116532: PUSH
116533: LD_VAR 0 1
116537: PUSH
116538: LD_EXP 215
116542: PUSH
116543: EMPTY
116544: LIST
116545: LIST
116546: LIST
116547: PUSH
116548: LD_INT 50
116550: PUSH
116551: EMPTY
116552: LIST
116553: PUSH
116554: EMPTY
116555: LIST
116556: LIST
116557: LIST
116558: LIST
116559: PPUSH
116560: CALL_OW 69
116564: ST_TO_ADDR
// if not tmp then
116565: LD_VAR 0 2
116569: NOT
116570: IFFALSE 116574
// continue ;
116572: GO 116369
// HackLink ( i , tmp ) ;
116574: LD_VAR 0 1
116578: PPUSH
116579: LD_VAR 0 2
116583: PPUSH
116584: CALL 116731 0 2
// end ;
116588: GO 116369
116590: POP
116591: POP
// end ;
116592: PPOPN 2
116594: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116595: LD_INT 0
116597: PPUSH
116598: PPUSH
116599: PPUSH
// if not hack in hackTanks then
116600: LD_VAR 0 1
116604: PUSH
116605: LD_EXP 212
116609: IN
116610: NOT
116611: IFFALSE 116615
// exit ;
116613: GO 116726
// index := GetElementIndex ( hackTanks , hack ) ;
116615: LD_ADDR_VAR 0 4
116619: PUSH
116620: LD_EXP 212
116624: PPUSH
116625: LD_VAR 0 1
116629: PPUSH
116630: CALL 69935 0 2
116634: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116635: LD_EXP 213
116639: PUSH
116640: LD_VAR 0 4
116644: ARRAY
116645: IFFALSE 116726
// begin for i in hackTanksCaptured [ index ] do
116647: LD_ADDR_VAR 0 3
116651: PUSH
116652: LD_EXP 213
116656: PUSH
116657: LD_VAR 0 4
116661: ARRAY
116662: PUSH
116663: FOR_IN
116664: IFFALSE 116690
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116666: LD_VAR 0 3
116670: PUSH
116671: LD_INT 1
116673: ARRAY
116674: PPUSH
116675: LD_VAR 0 3
116679: PUSH
116680: LD_INT 2
116682: ARRAY
116683: PPUSH
116684: CALL_OW 235
116688: GO 116663
116690: POP
116691: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116692: LD_ADDR_EXP 213
116696: PUSH
116697: LD_EXP 213
116701: PPUSH
116702: LD_VAR 0 4
116706: PPUSH
116707: EMPTY
116708: PPUSH
116709: CALL_OW 1
116713: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116714: LD_VAR 0 1
116718: PPUSH
116719: LD_INT 0
116721: PPUSH
116722: CALL_OW 505
// end ; end ;
116726: LD_VAR 0 2
116730: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116731: LD_INT 0
116733: PPUSH
116734: PPUSH
116735: PPUSH
// if not hack in hackTanks or not vehicles then
116736: LD_VAR 0 1
116740: PUSH
116741: LD_EXP 212
116745: IN
116746: NOT
116747: PUSH
116748: LD_VAR 0 2
116752: NOT
116753: OR
116754: IFFALSE 116758
// exit ;
116756: GO 117033
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116758: LD_ADDR_VAR 0 2
116762: PUSH
116763: LD_VAR 0 1
116767: PPUSH
116768: LD_VAR 0 2
116772: PPUSH
116773: LD_INT 1
116775: PPUSH
116776: LD_INT 1
116778: PPUSH
116779: CALL 70585 0 4
116783: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116784: LD_ADDR_VAR 0 5
116788: PUSH
116789: LD_EXP 212
116793: PPUSH
116794: LD_VAR 0 1
116798: PPUSH
116799: CALL 69935 0 2
116803: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116804: LD_EXP 213
116808: PUSH
116809: LD_VAR 0 5
116813: ARRAY
116814: PUSH
116815: LD_EXP 214
116819: LESS
116820: IFFALSE 117009
// begin for i := 1 to vehicles do
116822: LD_ADDR_VAR 0 4
116826: PUSH
116827: DOUBLE
116828: LD_INT 1
116830: DEC
116831: ST_TO_ADDR
116832: LD_VAR 0 2
116836: PUSH
116837: FOR_TO
116838: IFFALSE 117007
// begin if hackTanksCaptured [ index ] = hackLimit then
116840: LD_EXP 213
116844: PUSH
116845: LD_VAR 0 5
116849: ARRAY
116850: PUSH
116851: LD_EXP 214
116855: EQUAL
116856: IFFALSE 116860
// break ;
116858: GO 117007
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
116860: LD_ADDR_EXP 216
116864: PUSH
116865: LD_EXP 216
116869: PPUSH
116870: LD_VAR 0 5
116874: PPUSH
116875: LD_EXP 216
116879: PUSH
116880: LD_VAR 0 5
116884: ARRAY
116885: PUSH
116886: LD_INT 1
116888: PLUS
116889: PPUSH
116890: CALL_OW 1
116894: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
116895: LD_ADDR_EXP 213
116899: PUSH
116900: LD_EXP 213
116904: PPUSH
116905: LD_VAR 0 5
116909: PUSH
116910: LD_EXP 213
116914: PUSH
116915: LD_VAR 0 5
116919: ARRAY
116920: PUSH
116921: LD_INT 1
116923: PLUS
116924: PUSH
116925: EMPTY
116926: LIST
116927: LIST
116928: PPUSH
116929: LD_VAR 0 2
116933: PUSH
116934: LD_VAR 0 4
116938: ARRAY
116939: PUSH
116940: LD_VAR 0 2
116944: PUSH
116945: LD_VAR 0 4
116949: ARRAY
116950: PPUSH
116951: CALL_OW 255
116955: PUSH
116956: EMPTY
116957: LIST
116958: LIST
116959: PPUSH
116960: CALL 70150 0 3
116964: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
116965: LD_VAR 0 2
116969: PUSH
116970: LD_VAR 0 4
116974: ARRAY
116975: PPUSH
116976: LD_VAR 0 1
116980: PPUSH
116981: CALL_OW 255
116985: PPUSH
116986: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
116990: LD_VAR 0 2
116994: PUSH
116995: LD_VAR 0 4
116999: ARRAY
117000: PPUSH
117001: CALL_OW 141
// end ;
117005: GO 116837
117007: POP
117008: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117009: LD_VAR 0 1
117013: PPUSH
117014: LD_EXP 213
117018: PUSH
117019: LD_VAR 0 5
117023: ARRAY
117024: PUSH
117025: LD_INT 0
117027: PLUS
117028: PPUSH
117029: CALL_OW 505
// end ;
117033: LD_VAR 0 3
117037: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117038: LD_INT 0
117040: PPUSH
117041: PPUSH
117042: PPUSH
117043: PPUSH
// if not hack in hackTanks then
117044: LD_VAR 0 1
117048: PUSH
117049: LD_EXP 212
117053: IN
117054: NOT
117055: IFFALSE 117059
// exit ;
117057: GO 117299
// index := GetElementIndex ( hackTanks , hack ) ;
117059: LD_ADDR_VAR 0 4
117063: PUSH
117064: LD_EXP 212
117068: PPUSH
117069: LD_VAR 0 1
117073: PPUSH
117074: CALL 69935 0 2
117078: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117079: LD_ADDR_VAR 0 3
117083: PUSH
117084: DOUBLE
117085: LD_EXP 213
117089: PUSH
117090: LD_VAR 0 4
117094: ARRAY
117095: INC
117096: ST_TO_ADDR
117097: LD_INT 1
117099: PUSH
117100: FOR_DOWNTO
117101: IFFALSE 117273
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117103: LD_ADDR_VAR 0 5
117107: PUSH
117108: LD_EXP 213
117112: PUSH
117113: LD_VAR 0 4
117117: ARRAY
117118: PUSH
117119: LD_VAR 0 3
117123: ARRAY
117124: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117125: LD_VAR 0 5
117129: PUSH
117130: LD_INT 1
117132: ARRAY
117133: PPUSH
117134: CALL_OW 302
117138: NOT
117139: PUSH
117140: LD_VAR 0 5
117144: PUSH
117145: LD_INT 1
117147: ARRAY
117148: PPUSH
117149: CALL_OW 255
117153: PUSH
117154: LD_VAR 0 1
117158: PPUSH
117159: CALL_OW 255
117163: NONEQUAL
117164: OR
117165: IFFALSE 117271
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117167: LD_VAR 0 5
117171: PUSH
117172: LD_INT 1
117174: ARRAY
117175: PPUSH
117176: CALL_OW 305
117180: PUSH
117181: LD_VAR 0 5
117185: PUSH
117186: LD_INT 1
117188: ARRAY
117189: PPUSH
117190: CALL_OW 255
117194: PUSH
117195: LD_VAR 0 1
117199: PPUSH
117200: CALL_OW 255
117204: EQUAL
117205: AND
117206: IFFALSE 117230
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117208: LD_VAR 0 5
117212: PUSH
117213: LD_INT 1
117215: ARRAY
117216: PPUSH
117217: LD_VAR 0 5
117221: PUSH
117222: LD_INT 2
117224: ARRAY
117225: PPUSH
117226: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117230: LD_ADDR_EXP 213
117234: PUSH
117235: LD_EXP 213
117239: PPUSH
117240: LD_VAR 0 4
117244: PPUSH
117245: LD_EXP 213
117249: PUSH
117250: LD_VAR 0 4
117254: ARRAY
117255: PPUSH
117256: LD_VAR 0 3
117260: PPUSH
117261: CALL_OW 3
117265: PPUSH
117266: CALL_OW 1
117270: ST_TO_ADDR
// end ; end ;
117271: GO 117100
117273: POP
117274: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117275: LD_VAR 0 1
117279: PPUSH
117280: LD_EXP 213
117284: PUSH
117285: LD_VAR 0 4
117289: ARRAY
117290: PUSH
117291: LD_INT 0
117293: PLUS
117294: PPUSH
117295: CALL_OW 505
// end ;
117299: LD_VAR 0 2
117303: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117304: LD_INT 0
117306: PPUSH
117307: PPUSH
117308: PPUSH
117309: PPUSH
// if not hack in hackTanks then
117310: LD_VAR 0 1
117314: PUSH
117315: LD_EXP 212
117319: IN
117320: NOT
117321: IFFALSE 117325
// exit ;
117323: GO 117410
// index := GetElementIndex ( hackTanks , hack ) ;
117325: LD_ADDR_VAR 0 5
117329: PUSH
117330: LD_EXP 212
117334: PPUSH
117335: LD_VAR 0 1
117339: PPUSH
117340: CALL 69935 0 2
117344: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117345: LD_ADDR_VAR 0 4
117349: PUSH
117350: DOUBLE
117351: LD_INT 1
117353: DEC
117354: ST_TO_ADDR
117355: LD_EXP 213
117359: PUSH
117360: LD_VAR 0 5
117364: ARRAY
117365: PUSH
117366: FOR_TO
117367: IFFALSE 117408
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117369: LD_EXP 213
117373: PUSH
117374: LD_VAR 0 5
117378: ARRAY
117379: PUSH
117380: LD_VAR 0 4
117384: ARRAY
117385: PUSH
117386: LD_INT 1
117388: ARRAY
117389: PUSH
117390: LD_VAR 0 2
117394: EQUAL
117395: IFFALSE 117406
// KillUnit ( vehicle ) ;
117397: LD_VAR 0 2
117401: PPUSH
117402: CALL_OW 66
117406: GO 117366
117408: POP
117409: POP
// end ;
117410: LD_VAR 0 3
117414: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
117415: LD_EXP 217
117419: NOT
117420: IFFALSE 117455
117422: GO 117424
117424: DISABLE
// begin initMiner := true ;
117425: LD_ADDR_EXP 217
117429: PUSH
117430: LD_INT 1
117432: ST_TO_ADDR
// minersList := [ ] ;
117433: LD_ADDR_EXP 218
117437: PUSH
117438: EMPTY
117439: ST_TO_ADDR
// minerMinesList := [ ] ;
117440: LD_ADDR_EXP 219
117444: PUSH
117445: EMPTY
117446: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
117447: LD_ADDR_EXP 220
117451: PUSH
117452: LD_INT 5
117454: ST_TO_ADDR
// end ;
117455: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
117456: LD_EXP 217
117460: PUSH
117461: LD_INT 34
117463: PUSH
117464: LD_EXP 102
117468: PUSH
117469: EMPTY
117470: LIST
117471: LIST
117472: PPUSH
117473: CALL_OW 69
117477: AND
117478: IFFALSE 117941
117480: GO 117482
117482: DISABLE
117483: LD_INT 0
117485: PPUSH
117486: PPUSH
117487: PPUSH
117488: PPUSH
// begin enable ;
117489: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117490: LD_ADDR_VAR 0 1
117494: PUSH
117495: LD_INT 34
117497: PUSH
117498: LD_EXP 102
117502: PUSH
117503: EMPTY
117504: LIST
117505: LIST
117506: PPUSH
117507: CALL_OW 69
117511: PUSH
117512: FOR_IN
117513: IFFALSE 117585
// begin if not i in minersList then
117515: LD_VAR 0 1
117519: PUSH
117520: LD_EXP 218
117524: IN
117525: NOT
117526: IFFALSE 117583
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117528: LD_ADDR_EXP 218
117532: PUSH
117533: LD_EXP 218
117537: PPUSH
117538: LD_EXP 218
117542: PUSH
117543: LD_INT 1
117545: PLUS
117546: PPUSH
117547: LD_VAR 0 1
117551: PPUSH
117552: CALL_OW 1
117556: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117557: LD_ADDR_EXP 219
117561: PUSH
117562: LD_EXP 219
117566: PPUSH
117567: LD_EXP 219
117571: PUSH
117572: LD_INT 1
117574: PLUS
117575: PPUSH
117576: EMPTY
117577: PPUSH
117578: CALL_OW 1
117582: ST_TO_ADDR
// end end ;
117583: GO 117512
117585: POP
117586: POP
// for i := minerMinesList downto 1 do
117587: LD_ADDR_VAR 0 1
117591: PUSH
117592: DOUBLE
117593: LD_EXP 219
117597: INC
117598: ST_TO_ADDR
117599: LD_INT 1
117601: PUSH
117602: FOR_DOWNTO
117603: IFFALSE 117939
// begin if IsLive ( minersList [ i ] ) then
117605: LD_EXP 218
117609: PUSH
117610: LD_VAR 0 1
117614: ARRAY
117615: PPUSH
117616: CALL_OW 300
117620: IFFALSE 117648
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
117622: LD_EXP 218
117626: PUSH
117627: LD_VAR 0 1
117631: ARRAY
117632: PPUSH
117633: LD_EXP 219
117637: PUSH
117638: LD_VAR 0 1
117642: ARRAY
117643: PPUSH
117644: CALL_OW 505
// if not minerMinesList [ i ] then
117648: LD_EXP 219
117652: PUSH
117653: LD_VAR 0 1
117657: ARRAY
117658: NOT
117659: IFFALSE 117663
// continue ;
117661: GO 117602
// for j := minerMinesList [ i ] downto 1 do
117663: LD_ADDR_VAR 0 2
117667: PUSH
117668: DOUBLE
117669: LD_EXP 219
117673: PUSH
117674: LD_VAR 0 1
117678: ARRAY
117679: INC
117680: ST_TO_ADDR
117681: LD_INT 1
117683: PUSH
117684: FOR_DOWNTO
117685: IFFALSE 117935
// begin side := GetSide ( minersList [ i ] ) ;
117687: LD_ADDR_VAR 0 3
117691: PUSH
117692: LD_EXP 218
117696: PUSH
117697: LD_VAR 0 1
117701: ARRAY
117702: PPUSH
117703: CALL_OW 255
117707: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117708: LD_ADDR_VAR 0 4
117712: PUSH
117713: LD_EXP 219
117717: PUSH
117718: LD_VAR 0 1
117722: ARRAY
117723: PUSH
117724: LD_VAR 0 2
117728: ARRAY
117729: PUSH
117730: LD_INT 1
117732: ARRAY
117733: PPUSH
117734: LD_EXP 219
117738: PUSH
117739: LD_VAR 0 1
117743: ARRAY
117744: PUSH
117745: LD_VAR 0 2
117749: ARRAY
117750: PUSH
117751: LD_INT 2
117753: ARRAY
117754: PPUSH
117755: CALL_OW 428
117759: ST_TO_ADDR
// if not tmp then
117760: LD_VAR 0 4
117764: NOT
117765: IFFALSE 117769
// continue ;
117767: GO 117684
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117769: LD_VAR 0 4
117773: PUSH
117774: LD_INT 81
117776: PUSH
117777: LD_VAR 0 3
117781: PUSH
117782: EMPTY
117783: LIST
117784: LIST
117785: PPUSH
117786: CALL_OW 69
117790: IN
117791: PUSH
117792: LD_EXP 219
117796: PUSH
117797: LD_VAR 0 1
117801: ARRAY
117802: PUSH
117803: LD_VAR 0 2
117807: ARRAY
117808: PUSH
117809: LD_INT 1
117811: ARRAY
117812: PPUSH
117813: LD_EXP 219
117817: PUSH
117818: LD_VAR 0 1
117822: ARRAY
117823: PUSH
117824: LD_VAR 0 2
117828: ARRAY
117829: PUSH
117830: LD_INT 2
117832: ARRAY
117833: PPUSH
117834: CALL_OW 458
117838: AND
117839: IFFALSE 117933
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
117841: LD_EXP 219
117845: PUSH
117846: LD_VAR 0 1
117850: ARRAY
117851: PUSH
117852: LD_VAR 0 2
117856: ARRAY
117857: PUSH
117858: LD_INT 1
117860: ARRAY
117861: PPUSH
117862: LD_EXP 219
117866: PUSH
117867: LD_VAR 0 1
117871: ARRAY
117872: PUSH
117873: LD_VAR 0 2
117877: ARRAY
117878: PUSH
117879: LD_INT 2
117881: ARRAY
117882: PPUSH
117883: LD_VAR 0 3
117887: PPUSH
117888: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117892: LD_ADDR_EXP 219
117896: PUSH
117897: LD_EXP 219
117901: PPUSH
117902: LD_VAR 0 1
117906: PPUSH
117907: LD_EXP 219
117911: PUSH
117912: LD_VAR 0 1
117916: ARRAY
117917: PPUSH
117918: LD_VAR 0 2
117922: PPUSH
117923: CALL_OW 3
117927: PPUSH
117928: CALL_OW 1
117932: ST_TO_ADDR
// end ; end ;
117933: GO 117684
117935: POP
117936: POP
// end ;
117937: GO 117602
117939: POP
117940: POP
// end ;
117941: PPOPN 4
117943: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
117944: LD_INT 0
117946: PPUSH
117947: PPUSH
// result := false ;
117948: LD_ADDR_VAR 0 4
117952: PUSH
117953: LD_INT 0
117955: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
117956: LD_VAR 0 1
117960: PPUSH
117961: CALL_OW 264
117965: PUSH
117966: LD_EXP 102
117970: EQUAL
117971: NOT
117972: IFFALSE 117976
// exit ;
117974: GO 118216
// index := GetElementIndex ( minersList , unit ) ;
117976: LD_ADDR_VAR 0 5
117980: PUSH
117981: LD_EXP 218
117985: PPUSH
117986: LD_VAR 0 1
117990: PPUSH
117991: CALL 69935 0 2
117995: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
117996: LD_EXP 219
118000: PUSH
118001: LD_VAR 0 5
118005: ARRAY
118006: PUSH
118007: LD_EXP 220
118011: GREATEREQUAL
118012: IFFALSE 118016
// exit ;
118014: GO 118216
// ComMoveXY ( unit , x , y ) ;
118016: LD_VAR 0 1
118020: PPUSH
118021: LD_VAR 0 2
118025: PPUSH
118026: LD_VAR 0 3
118030: PPUSH
118031: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118035: LD_INT 35
118037: PPUSH
118038: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118042: LD_VAR 0 1
118046: PPUSH
118047: LD_VAR 0 2
118051: PPUSH
118052: LD_VAR 0 3
118056: PPUSH
118057: CALL 99999 0 3
118061: NOT
118062: PUSH
118063: LD_VAR 0 1
118067: PPUSH
118068: CALL_OW 314
118072: AND
118073: IFFALSE 118077
// exit ;
118075: GO 118216
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118077: LD_VAR 0 2
118081: PPUSH
118082: LD_VAR 0 3
118086: PPUSH
118087: CALL_OW 428
118091: PUSH
118092: LD_VAR 0 1
118096: EQUAL
118097: PUSH
118098: LD_VAR 0 1
118102: PPUSH
118103: CALL_OW 314
118107: NOT
118108: AND
118109: IFFALSE 118035
// PlaySoundXY ( x , y , PlantMine ) ;
118111: LD_VAR 0 2
118115: PPUSH
118116: LD_VAR 0 3
118120: PPUSH
118121: LD_STRING PlantMine
118123: PPUSH
118124: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
118128: LD_VAR 0 2
118132: PPUSH
118133: LD_VAR 0 3
118137: PPUSH
118138: LD_VAR 0 1
118142: PPUSH
118143: CALL_OW 255
118147: PPUSH
118148: LD_INT 0
118150: PPUSH
118151: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118155: LD_ADDR_EXP 219
118159: PUSH
118160: LD_EXP 219
118164: PPUSH
118165: LD_VAR 0 5
118169: PUSH
118170: LD_EXP 219
118174: PUSH
118175: LD_VAR 0 5
118179: ARRAY
118180: PUSH
118181: LD_INT 1
118183: PLUS
118184: PUSH
118185: EMPTY
118186: LIST
118187: LIST
118188: PPUSH
118189: LD_VAR 0 2
118193: PUSH
118194: LD_VAR 0 3
118198: PUSH
118199: EMPTY
118200: LIST
118201: LIST
118202: PPUSH
118203: CALL 70150 0 3
118207: ST_TO_ADDR
// result := true ;
118208: LD_ADDR_VAR 0 4
118212: PUSH
118213: LD_INT 1
118215: ST_TO_ADDR
// end ;
118216: LD_VAR 0 4
118220: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118221: LD_INT 0
118223: PPUSH
118224: PPUSH
118225: PPUSH
// if not unit in minersList then
118226: LD_VAR 0 1
118230: PUSH
118231: LD_EXP 218
118235: IN
118236: NOT
118237: IFFALSE 118241
// exit ;
118239: GO 118633
// index := GetElementIndex ( minersList , unit ) ;
118241: LD_ADDR_VAR 0 6
118245: PUSH
118246: LD_EXP 218
118250: PPUSH
118251: LD_VAR 0 1
118255: PPUSH
118256: CALL 69935 0 2
118260: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118261: LD_ADDR_VAR 0 5
118265: PUSH
118266: DOUBLE
118267: LD_EXP 219
118271: PUSH
118272: LD_VAR 0 6
118276: ARRAY
118277: INC
118278: ST_TO_ADDR
118279: LD_INT 1
118281: PUSH
118282: FOR_DOWNTO
118283: IFFALSE 118444
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
118285: LD_EXP 219
118289: PUSH
118290: LD_VAR 0 6
118294: ARRAY
118295: PUSH
118296: LD_VAR 0 5
118300: ARRAY
118301: PUSH
118302: LD_INT 1
118304: ARRAY
118305: PUSH
118306: LD_VAR 0 2
118310: EQUAL
118311: PUSH
118312: LD_EXP 219
118316: PUSH
118317: LD_VAR 0 6
118321: ARRAY
118322: PUSH
118323: LD_VAR 0 5
118327: ARRAY
118328: PUSH
118329: LD_INT 2
118331: ARRAY
118332: PUSH
118333: LD_VAR 0 3
118337: EQUAL
118338: AND
118339: IFFALSE 118442
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118341: LD_EXP 219
118345: PUSH
118346: LD_VAR 0 6
118350: ARRAY
118351: PUSH
118352: LD_VAR 0 5
118356: ARRAY
118357: PUSH
118358: LD_INT 1
118360: ARRAY
118361: PPUSH
118362: LD_EXP 219
118366: PUSH
118367: LD_VAR 0 6
118371: ARRAY
118372: PUSH
118373: LD_VAR 0 5
118377: ARRAY
118378: PUSH
118379: LD_INT 2
118381: ARRAY
118382: PPUSH
118383: LD_VAR 0 1
118387: PPUSH
118388: CALL_OW 255
118392: PPUSH
118393: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118397: LD_ADDR_EXP 219
118401: PUSH
118402: LD_EXP 219
118406: PPUSH
118407: LD_VAR 0 6
118411: PPUSH
118412: LD_EXP 219
118416: PUSH
118417: LD_VAR 0 6
118421: ARRAY
118422: PPUSH
118423: LD_VAR 0 5
118427: PPUSH
118428: CALL_OW 3
118432: PPUSH
118433: CALL_OW 1
118437: ST_TO_ADDR
// exit ;
118438: POP
118439: POP
118440: GO 118633
// end ; end ;
118442: GO 118282
118444: POP
118445: POP
// for i := minerMinesList [ index ] downto 1 do
118446: LD_ADDR_VAR 0 5
118450: PUSH
118451: DOUBLE
118452: LD_EXP 219
118456: PUSH
118457: LD_VAR 0 6
118461: ARRAY
118462: INC
118463: ST_TO_ADDR
118464: LD_INT 1
118466: PUSH
118467: FOR_DOWNTO
118468: IFFALSE 118631
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118470: LD_EXP 219
118474: PUSH
118475: LD_VAR 0 6
118479: ARRAY
118480: PUSH
118481: LD_VAR 0 5
118485: ARRAY
118486: PUSH
118487: LD_INT 1
118489: ARRAY
118490: PPUSH
118491: LD_EXP 219
118495: PUSH
118496: LD_VAR 0 6
118500: ARRAY
118501: PUSH
118502: LD_VAR 0 5
118506: ARRAY
118507: PUSH
118508: LD_INT 2
118510: ARRAY
118511: PPUSH
118512: LD_VAR 0 2
118516: PPUSH
118517: LD_VAR 0 3
118521: PPUSH
118522: CALL_OW 298
118526: PUSH
118527: LD_INT 6
118529: LESS
118530: IFFALSE 118629
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118532: LD_EXP 219
118536: PUSH
118537: LD_VAR 0 6
118541: ARRAY
118542: PUSH
118543: LD_VAR 0 5
118547: ARRAY
118548: PUSH
118549: LD_INT 1
118551: ARRAY
118552: PPUSH
118553: LD_EXP 219
118557: PUSH
118558: LD_VAR 0 6
118562: ARRAY
118563: PUSH
118564: LD_VAR 0 5
118568: ARRAY
118569: PUSH
118570: LD_INT 2
118572: ARRAY
118573: PPUSH
118574: LD_VAR 0 1
118578: PPUSH
118579: CALL_OW 255
118583: PPUSH
118584: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118588: LD_ADDR_EXP 219
118592: PUSH
118593: LD_EXP 219
118597: PPUSH
118598: LD_VAR 0 6
118602: PPUSH
118603: LD_EXP 219
118607: PUSH
118608: LD_VAR 0 6
118612: ARRAY
118613: PPUSH
118614: LD_VAR 0 5
118618: PPUSH
118619: CALL_OW 3
118623: PPUSH
118624: CALL_OW 1
118628: ST_TO_ADDR
// end ; end ;
118629: GO 118467
118631: POP
118632: POP
// end ;
118633: LD_VAR 0 4
118637: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118638: LD_INT 0
118640: PPUSH
118641: PPUSH
118642: PPUSH
118643: PPUSH
118644: PPUSH
118645: PPUSH
118646: PPUSH
118647: PPUSH
118648: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118649: LD_VAR 0 1
118653: PPUSH
118654: CALL_OW 264
118658: PUSH
118659: LD_EXP 102
118663: EQUAL
118664: NOT
118665: PUSH
118666: LD_VAR 0 1
118670: PUSH
118671: LD_EXP 218
118675: IN
118676: NOT
118677: OR
118678: IFFALSE 118682
// exit ;
118680: GO 119004
// index := GetElementIndex ( minersList , unit ) ;
118682: LD_ADDR_VAR 0 6
118686: PUSH
118687: LD_EXP 218
118691: PPUSH
118692: LD_VAR 0 1
118696: PPUSH
118697: CALL 69935 0 2
118701: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118702: LD_ADDR_VAR 0 8
118706: PUSH
118707: LD_EXP 220
118711: PUSH
118712: LD_EXP 219
118716: PUSH
118717: LD_VAR 0 6
118721: ARRAY
118722: MINUS
118723: ST_TO_ADDR
// if not minesFreeAmount then
118724: LD_VAR 0 8
118728: NOT
118729: IFFALSE 118733
// exit ;
118731: GO 119004
// tmp := [ ] ;
118733: LD_ADDR_VAR 0 7
118737: PUSH
118738: EMPTY
118739: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118740: LD_ADDR_VAR 0 5
118744: PUSH
118745: DOUBLE
118746: LD_INT 1
118748: DEC
118749: ST_TO_ADDR
118750: LD_VAR 0 8
118754: PUSH
118755: FOR_TO
118756: IFFALSE 118951
// begin _d := rand ( 0 , 5 ) ;
118758: LD_ADDR_VAR 0 11
118762: PUSH
118763: LD_INT 0
118765: PPUSH
118766: LD_INT 5
118768: PPUSH
118769: CALL_OW 12
118773: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118774: LD_ADDR_VAR 0 12
118778: PUSH
118779: LD_INT 2
118781: PPUSH
118782: LD_INT 6
118784: PPUSH
118785: CALL_OW 12
118789: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118790: LD_ADDR_VAR 0 9
118794: PUSH
118795: LD_VAR 0 2
118799: PPUSH
118800: LD_VAR 0 11
118804: PPUSH
118805: LD_VAR 0 12
118809: PPUSH
118810: CALL_OW 272
118814: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118815: LD_ADDR_VAR 0 10
118819: PUSH
118820: LD_VAR 0 3
118824: PPUSH
118825: LD_VAR 0 11
118829: PPUSH
118830: LD_VAR 0 12
118834: PPUSH
118835: CALL_OW 273
118839: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
118840: LD_VAR 0 9
118844: PPUSH
118845: LD_VAR 0 10
118849: PPUSH
118850: CALL_OW 488
118854: PUSH
118855: LD_VAR 0 9
118859: PUSH
118860: LD_VAR 0 10
118864: PUSH
118865: EMPTY
118866: LIST
118867: LIST
118868: PUSH
118869: LD_VAR 0 7
118873: IN
118874: NOT
118875: AND
118876: PUSH
118877: LD_VAR 0 9
118881: PPUSH
118882: LD_VAR 0 10
118886: PPUSH
118887: CALL_OW 458
118891: NOT
118892: AND
118893: IFFALSE 118935
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
118895: LD_ADDR_VAR 0 7
118899: PUSH
118900: LD_VAR 0 7
118904: PPUSH
118905: LD_VAR 0 7
118909: PUSH
118910: LD_INT 1
118912: PLUS
118913: PPUSH
118914: LD_VAR 0 9
118918: PUSH
118919: LD_VAR 0 10
118923: PUSH
118924: EMPTY
118925: LIST
118926: LIST
118927: PPUSH
118928: CALL_OW 1
118932: ST_TO_ADDR
118933: GO 118949
// i := i - 1 ;
118935: LD_ADDR_VAR 0 5
118939: PUSH
118940: LD_VAR 0 5
118944: PUSH
118945: LD_INT 1
118947: MINUS
118948: ST_TO_ADDR
// end ;
118949: GO 118755
118951: POP
118952: POP
// for i in tmp do
118953: LD_ADDR_VAR 0 5
118957: PUSH
118958: LD_VAR 0 7
118962: PUSH
118963: FOR_IN
118964: IFFALSE 119002
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
118966: LD_VAR 0 1
118970: PPUSH
118971: LD_VAR 0 5
118975: PUSH
118976: LD_INT 1
118978: ARRAY
118979: PPUSH
118980: LD_VAR 0 5
118984: PUSH
118985: LD_INT 2
118987: ARRAY
118988: PPUSH
118989: CALL 117944 0 3
118993: NOT
118994: IFFALSE 119000
// exit ;
118996: POP
118997: POP
118998: GO 119004
119000: GO 118963
119002: POP
119003: POP
// end ;
119004: LD_VAR 0 4
119008: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
119009: LD_INT 0
119011: PPUSH
119012: PPUSH
119013: PPUSH
119014: PPUSH
119015: PPUSH
119016: PPUSH
119017: PPUSH
// if not GetClass ( unit ) = class_sniper then
119018: LD_VAR 0 1
119022: PPUSH
119023: CALL_OW 257
119027: PUSH
119028: LD_INT 5
119030: EQUAL
119031: NOT
119032: IFFALSE 119036
// exit ;
119034: GO 119424
// dist := 8 ;
119036: LD_ADDR_VAR 0 5
119040: PUSH
119041: LD_INT 8
119043: ST_TO_ADDR
// viewRange := 12 ;
119044: LD_ADDR_VAR 0 7
119048: PUSH
119049: LD_INT 12
119051: ST_TO_ADDR
// side := GetSide ( unit ) ;
119052: LD_ADDR_VAR 0 6
119056: PUSH
119057: LD_VAR 0 1
119061: PPUSH
119062: CALL_OW 255
119066: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119067: LD_INT 61
119069: PPUSH
119070: LD_VAR 0 6
119074: PPUSH
119075: CALL_OW 321
119079: PUSH
119080: LD_INT 2
119082: EQUAL
119083: IFFALSE 119093
// viewRange := 16 ;
119085: LD_ADDR_VAR 0 7
119089: PUSH
119090: LD_INT 16
119092: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119093: LD_VAR 0 1
119097: PPUSH
119098: LD_VAR 0 2
119102: PPUSH
119103: LD_VAR 0 3
119107: PPUSH
119108: CALL_OW 297
119112: PUSH
119113: LD_VAR 0 5
119117: GREATER
119118: IFFALSE 119197
// begin ComMoveXY ( unit , x , y ) ;
119120: LD_VAR 0 1
119124: PPUSH
119125: LD_VAR 0 2
119129: PPUSH
119130: LD_VAR 0 3
119134: PPUSH
119135: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119139: LD_INT 35
119141: PPUSH
119142: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119146: LD_VAR 0 1
119150: PPUSH
119151: LD_VAR 0 2
119155: PPUSH
119156: LD_VAR 0 3
119160: PPUSH
119161: CALL 99999 0 3
119165: NOT
119166: IFFALSE 119170
// exit ;
119168: GO 119424
// until GetDistUnitXY ( unit , x , y ) < dist ;
119170: LD_VAR 0 1
119174: PPUSH
119175: LD_VAR 0 2
119179: PPUSH
119180: LD_VAR 0 3
119184: PPUSH
119185: CALL_OW 297
119189: PUSH
119190: LD_VAR 0 5
119194: LESS
119195: IFFALSE 119139
// end ; ComTurnXY ( unit , x , y ) ;
119197: LD_VAR 0 1
119201: PPUSH
119202: LD_VAR 0 2
119206: PPUSH
119207: LD_VAR 0 3
119211: PPUSH
119212: CALL_OW 118
// wait ( 5 ) ;
119216: LD_INT 5
119218: PPUSH
119219: CALL_OW 67
// _d := GetDir ( unit ) ;
119223: LD_ADDR_VAR 0 10
119227: PUSH
119228: LD_VAR 0 1
119232: PPUSH
119233: CALL_OW 254
119237: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
119238: LD_ADDR_VAR 0 8
119242: PUSH
119243: LD_VAR 0 1
119247: PPUSH
119248: CALL_OW 250
119252: PPUSH
119253: LD_VAR 0 10
119257: PPUSH
119258: LD_VAR 0 5
119262: PPUSH
119263: CALL_OW 272
119267: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
119268: LD_ADDR_VAR 0 9
119272: PUSH
119273: LD_VAR 0 1
119277: PPUSH
119278: CALL_OW 251
119282: PPUSH
119283: LD_VAR 0 10
119287: PPUSH
119288: LD_VAR 0 5
119292: PPUSH
119293: CALL_OW 273
119297: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119298: LD_VAR 0 8
119302: PPUSH
119303: LD_VAR 0 9
119307: PPUSH
119308: CALL_OW 488
119312: NOT
119313: IFFALSE 119317
// exit ;
119315: GO 119424
// ComAnimCustom ( unit , 1 ) ;
119317: LD_VAR 0 1
119321: PPUSH
119322: LD_INT 1
119324: PPUSH
119325: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119329: LD_VAR 0 8
119333: PPUSH
119334: LD_VAR 0 9
119338: PPUSH
119339: LD_VAR 0 6
119343: PPUSH
119344: LD_VAR 0 7
119348: PPUSH
119349: CALL_OW 330
// repeat wait ( 1 ) ;
119353: LD_INT 1
119355: PPUSH
119356: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
119360: LD_VAR 0 1
119364: PPUSH
119365: CALL_OW 316
119369: PUSH
119370: LD_VAR 0 1
119374: PPUSH
119375: CALL_OW 314
119379: OR
119380: PUSH
119381: LD_VAR 0 1
119385: PPUSH
119386: CALL_OW 302
119390: NOT
119391: OR
119392: PUSH
119393: LD_VAR 0 1
119397: PPUSH
119398: CALL_OW 301
119402: OR
119403: IFFALSE 119353
// RemoveSeeing ( _x , _y , side ) ;
119405: LD_VAR 0 8
119409: PPUSH
119410: LD_VAR 0 9
119414: PPUSH
119415: LD_VAR 0 6
119419: PPUSH
119420: CALL_OW 331
// end ; end_of_file
119424: LD_VAR 0 4
119428: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
119429: LD_INT 0
119431: PPUSH
119432: PPUSH
119433: PPUSH
119434: PPUSH
119435: PPUSH
119436: PPUSH
119437: PPUSH
119438: PPUSH
119439: PPUSH
119440: PPUSH
119441: PPUSH
119442: PPUSH
119443: PPUSH
119444: PPUSH
119445: PPUSH
119446: PPUSH
119447: PPUSH
119448: PPUSH
119449: PPUSH
119450: PPUSH
119451: PPUSH
119452: PPUSH
119453: PPUSH
119454: PPUSH
119455: PPUSH
119456: PPUSH
119457: PPUSH
119458: PPUSH
119459: PPUSH
119460: PPUSH
119461: PPUSH
119462: PPUSH
119463: PPUSH
119464: PPUSH
// if not list then
119465: LD_VAR 0 1
119469: NOT
119470: IFFALSE 119474
// exit ;
119472: GO 124133
// base := list [ 1 ] ;
119474: LD_ADDR_VAR 0 3
119478: PUSH
119479: LD_VAR 0 1
119483: PUSH
119484: LD_INT 1
119486: ARRAY
119487: ST_TO_ADDR
// group := list [ 2 ] ;
119488: LD_ADDR_VAR 0 4
119492: PUSH
119493: LD_VAR 0 1
119497: PUSH
119498: LD_INT 2
119500: ARRAY
119501: ST_TO_ADDR
// path := list [ 3 ] ;
119502: LD_ADDR_VAR 0 5
119506: PUSH
119507: LD_VAR 0 1
119511: PUSH
119512: LD_INT 3
119514: ARRAY
119515: ST_TO_ADDR
// flags := list [ 4 ] ;
119516: LD_ADDR_VAR 0 6
119520: PUSH
119521: LD_VAR 0 1
119525: PUSH
119526: LD_INT 4
119528: ARRAY
119529: ST_TO_ADDR
// mined := [ ] ;
119530: LD_ADDR_VAR 0 27
119534: PUSH
119535: EMPTY
119536: ST_TO_ADDR
// bombed := [ ] ;
119537: LD_ADDR_VAR 0 28
119541: PUSH
119542: EMPTY
119543: ST_TO_ADDR
// healers := [ ] ;
119544: LD_ADDR_VAR 0 31
119548: PUSH
119549: EMPTY
119550: ST_TO_ADDR
// to_heal := [ ] ;
119551: LD_ADDR_VAR 0 30
119555: PUSH
119556: EMPTY
119557: ST_TO_ADDR
// repairs := [ ] ;
119558: LD_ADDR_VAR 0 33
119562: PUSH
119563: EMPTY
119564: ST_TO_ADDR
// to_repair := [ ] ;
119565: LD_ADDR_VAR 0 32
119569: PUSH
119570: EMPTY
119571: ST_TO_ADDR
// if not group or not path then
119572: LD_VAR 0 4
119576: NOT
119577: PUSH
119578: LD_VAR 0 5
119582: NOT
119583: OR
119584: IFFALSE 119588
// exit ;
119586: GO 124133
// side := GetSide ( group [ 1 ] ) ;
119588: LD_ADDR_VAR 0 35
119592: PUSH
119593: LD_VAR 0 4
119597: PUSH
119598: LD_INT 1
119600: ARRAY
119601: PPUSH
119602: CALL_OW 255
119606: ST_TO_ADDR
// if flags then
119607: LD_VAR 0 6
119611: IFFALSE 119755
// begin f_ignore_area := flags [ 1 ] ;
119613: LD_ADDR_VAR 0 17
119617: PUSH
119618: LD_VAR 0 6
119622: PUSH
119623: LD_INT 1
119625: ARRAY
119626: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
119627: LD_ADDR_VAR 0 18
119631: PUSH
119632: LD_VAR 0 6
119636: PUSH
119637: LD_INT 2
119639: ARRAY
119640: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
119641: LD_ADDR_VAR 0 19
119645: PUSH
119646: LD_VAR 0 6
119650: PUSH
119651: LD_INT 3
119653: ARRAY
119654: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
119655: LD_ADDR_VAR 0 20
119659: PUSH
119660: LD_VAR 0 6
119664: PUSH
119665: LD_INT 4
119667: ARRAY
119668: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
119669: LD_ADDR_VAR 0 21
119673: PUSH
119674: LD_VAR 0 6
119678: PUSH
119679: LD_INT 5
119681: ARRAY
119682: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
119683: LD_ADDR_VAR 0 22
119687: PUSH
119688: LD_VAR 0 6
119692: PUSH
119693: LD_INT 6
119695: ARRAY
119696: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
119697: LD_ADDR_VAR 0 23
119701: PUSH
119702: LD_VAR 0 6
119706: PUSH
119707: LD_INT 7
119709: ARRAY
119710: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
119711: LD_ADDR_VAR 0 24
119715: PUSH
119716: LD_VAR 0 6
119720: PUSH
119721: LD_INT 8
119723: ARRAY
119724: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
119725: LD_ADDR_VAR 0 25
119729: PUSH
119730: LD_VAR 0 6
119734: PUSH
119735: LD_INT 9
119737: ARRAY
119738: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
119739: LD_ADDR_VAR 0 26
119743: PUSH
119744: LD_VAR 0 6
119748: PUSH
119749: LD_INT 10
119751: ARRAY
119752: ST_TO_ADDR
// end else
119753: GO 119835
// begin f_ignore_area := false ;
119755: LD_ADDR_VAR 0 17
119759: PUSH
119760: LD_INT 0
119762: ST_TO_ADDR
// f_capture := false ;
119763: LD_ADDR_VAR 0 18
119767: PUSH
119768: LD_INT 0
119770: ST_TO_ADDR
// f_ignore_civ := false ;
119771: LD_ADDR_VAR 0 19
119775: PUSH
119776: LD_INT 0
119778: ST_TO_ADDR
// f_murder := false ;
119779: LD_ADDR_VAR 0 20
119783: PUSH
119784: LD_INT 0
119786: ST_TO_ADDR
// f_mines := false ;
119787: LD_ADDR_VAR 0 21
119791: PUSH
119792: LD_INT 0
119794: ST_TO_ADDR
// f_repair := false ;
119795: LD_ADDR_VAR 0 22
119799: PUSH
119800: LD_INT 0
119802: ST_TO_ADDR
// f_heal := false ;
119803: LD_ADDR_VAR 0 23
119807: PUSH
119808: LD_INT 0
119810: ST_TO_ADDR
// f_spacetime := false ;
119811: LD_ADDR_VAR 0 24
119815: PUSH
119816: LD_INT 0
119818: ST_TO_ADDR
// f_attack_depot := false ;
119819: LD_ADDR_VAR 0 25
119823: PUSH
119824: LD_INT 0
119826: ST_TO_ADDR
// f_crawl := false ;
119827: LD_ADDR_VAR 0 26
119831: PUSH
119832: LD_INT 0
119834: ST_TO_ADDR
// end ; if f_heal then
119835: LD_VAR 0 23
119839: IFFALSE 119866
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
119841: LD_ADDR_VAR 0 31
119845: PUSH
119846: LD_VAR 0 4
119850: PPUSH
119851: LD_INT 25
119853: PUSH
119854: LD_INT 4
119856: PUSH
119857: EMPTY
119858: LIST
119859: LIST
119860: PPUSH
119861: CALL_OW 72
119865: ST_TO_ADDR
// if f_repair then
119866: LD_VAR 0 22
119870: IFFALSE 119897
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
119872: LD_ADDR_VAR 0 33
119876: PUSH
119877: LD_VAR 0 4
119881: PPUSH
119882: LD_INT 25
119884: PUSH
119885: LD_INT 3
119887: PUSH
119888: EMPTY
119889: LIST
119890: LIST
119891: PPUSH
119892: CALL_OW 72
119896: ST_TO_ADDR
// units_path := [ ] ;
119897: LD_ADDR_VAR 0 16
119901: PUSH
119902: EMPTY
119903: ST_TO_ADDR
// for i = 1 to group do
119904: LD_ADDR_VAR 0 7
119908: PUSH
119909: DOUBLE
119910: LD_INT 1
119912: DEC
119913: ST_TO_ADDR
119914: LD_VAR 0 4
119918: PUSH
119919: FOR_TO
119920: IFFALSE 119949
// units_path := Replace ( units_path , i , path ) ;
119922: LD_ADDR_VAR 0 16
119926: PUSH
119927: LD_VAR 0 16
119931: PPUSH
119932: LD_VAR 0 7
119936: PPUSH
119937: LD_VAR 0 5
119941: PPUSH
119942: CALL_OW 1
119946: ST_TO_ADDR
119947: GO 119919
119949: POP
119950: POP
// repeat for i = group downto 1 do
119951: LD_ADDR_VAR 0 7
119955: PUSH
119956: DOUBLE
119957: LD_VAR 0 4
119961: INC
119962: ST_TO_ADDR
119963: LD_INT 1
119965: PUSH
119966: FOR_DOWNTO
119967: IFFALSE 124089
// begin wait ( 5 ) ;
119969: LD_INT 5
119971: PPUSH
119972: CALL_OW 67
// tmp := [ ] ;
119976: LD_ADDR_VAR 0 14
119980: PUSH
119981: EMPTY
119982: ST_TO_ADDR
// attacking := false ;
119983: LD_ADDR_VAR 0 29
119987: PUSH
119988: LD_INT 0
119990: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
119991: LD_VAR 0 4
119995: PUSH
119996: LD_VAR 0 7
120000: ARRAY
120001: PPUSH
120002: CALL_OW 301
120006: PUSH
120007: LD_VAR 0 4
120011: PUSH
120012: LD_VAR 0 7
120016: ARRAY
120017: NOT
120018: OR
120019: IFFALSE 120128
// begin if GetType ( group [ i ] ) = unit_human then
120021: LD_VAR 0 4
120025: PUSH
120026: LD_VAR 0 7
120030: ARRAY
120031: PPUSH
120032: CALL_OW 247
120036: PUSH
120037: LD_INT 1
120039: EQUAL
120040: IFFALSE 120086
// begin to_heal := to_heal diff group [ i ] ;
120042: LD_ADDR_VAR 0 30
120046: PUSH
120047: LD_VAR 0 30
120051: PUSH
120052: LD_VAR 0 4
120056: PUSH
120057: LD_VAR 0 7
120061: ARRAY
120062: DIFF
120063: ST_TO_ADDR
// healers := healers diff group [ i ] ;
120064: LD_ADDR_VAR 0 31
120068: PUSH
120069: LD_VAR 0 31
120073: PUSH
120074: LD_VAR 0 4
120078: PUSH
120079: LD_VAR 0 7
120083: ARRAY
120084: DIFF
120085: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
120086: LD_ADDR_VAR 0 4
120090: PUSH
120091: LD_VAR 0 4
120095: PPUSH
120096: LD_VAR 0 7
120100: PPUSH
120101: CALL_OW 3
120105: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
120106: LD_ADDR_VAR 0 16
120110: PUSH
120111: LD_VAR 0 16
120115: PPUSH
120116: LD_VAR 0 7
120120: PPUSH
120121: CALL_OW 3
120125: ST_TO_ADDR
// continue ;
120126: GO 119966
// end ; if f_repair then
120128: LD_VAR 0 22
120132: IFFALSE 120621
// begin if GetType ( group [ i ] ) = unit_vehicle then
120134: LD_VAR 0 4
120138: PUSH
120139: LD_VAR 0 7
120143: ARRAY
120144: PPUSH
120145: CALL_OW 247
120149: PUSH
120150: LD_INT 2
120152: EQUAL
120153: IFFALSE 120343
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
120155: LD_VAR 0 4
120159: PUSH
120160: LD_VAR 0 7
120164: ARRAY
120165: PPUSH
120166: CALL_OW 256
120170: PUSH
120171: LD_INT 700
120173: LESS
120174: PUSH
120175: LD_VAR 0 4
120179: PUSH
120180: LD_VAR 0 7
120184: ARRAY
120185: PUSH
120186: LD_VAR 0 32
120190: IN
120191: NOT
120192: AND
120193: IFFALSE 120217
// to_repair := to_repair union group [ i ] ;
120195: LD_ADDR_VAR 0 32
120199: PUSH
120200: LD_VAR 0 32
120204: PUSH
120205: LD_VAR 0 4
120209: PUSH
120210: LD_VAR 0 7
120214: ARRAY
120215: UNION
120216: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
120217: LD_VAR 0 4
120221: PUSH
120222: LD_VAR 0 7
120226: ARRAY
120227: PPUSH
120228: CALL_OW 256
120232: PUSH
120233: LD_INT 1000
120235: EQUAL
120236: PUSH
120237: LD_VAR 0 4
120241: PUSH
120242: LD_VAR 0 7
120246: ARRAY
120247: PUSH
120248: LD_VAR 0 32
120252: IN
120253: AND
120254: IFFALSE 120278
// to_repair := to_repair diff group [ i ] ;
120256: LD_ADDR_VAR 0 32
120260: PUSH
120261: LD_VAR 0 32
120265: PUSH
120266: LD_VAR 0 4
120270: PUSH
120271: LD_VAR 0 7
120275: ARRAY
120276: DIFF
120277: ST_TO_ADDR
// if group [ i ] in to_repair then
120278: LD_VAR 0 4
120282: PUSH
120283: LD_VAR 0 7
120287: ARRAY
120288: PUSH
120289: LD_VAR 0 32
120293: IN
120294: IFFALSE 120341
// begin if not IsInArea ( group [ i ] , f_repair ) then
120296: LD_VAR 0 4
120300: PUSH
120301: LD_VAR 0 7
120305: ARRAY
120306: PPUSH
120307: LD_VAR 0 22
120311: PPUSH
120312: CALL_OW 308
120316: NOT
120317: IFFALSE 120339
// ComMoveToArea ( group [ i ] , f_repair ) ;
120319: LD_VAR 0 4
120323: PUSH
120324: LD_VAR 0 7
120328: ARRAY
120329: PPUSH
120330: LD_VAR 0 22
120334: PPUSH
120335: CALL_OW 113
// continue ;
120339: GO 119966
// end ; end else
120341: GO 120621
// if group [ i ] in repairs then
120343: LD_VAR 0 4
120347: PUSH
120348: LD_VAR 0 7
120352: ARRAY
120353: PUSH
120354: LD_VAR 0 33
120358: IN
120359: IFFALSE 120621
// begin if IsInUnit ( group [ i ] ) then
120361: LD_VAR 0 4
120365: PUSH
120366: LD_VAR 0 7
120370: ARRAY
120371: PPUSH
120372: CALL_OW 310
120376: IFFALSE 120444
// begin z := IsInUnit ( group [ i ] ) ;
120378: LD_ADDR_VAR 0 13
120382: PUSH
120383: LD_VAR 0 4
120387: PUSH
120388: LD_VAR 0 7
120392: ARRAY
120393: PPUSH
120394: CALL_OW 310
120398: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
120399: LD_VAR 0 13
120403: PUSH
120404: LD_VAR 0 32
120408: IN
120409: PUSH
120410: LD_VAR 0 13
120414: PPUSH
120415: LD_VAR 0 22
120419: PPUSH
120420: CALL_OW 308
120424: AND
120425: IFFALSE 120442
// ComExitVehicle ( group [ i ] ) ;
120427: LD_VAR 0 4
120431: PUSH
120432: LD_VAR 0 7
120436: ARRAY
120437: PPUSH
120438: CALL_OW 121
// end else
120442: GO 120621
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
120444: LD_ADDR_VAR 0 13
120448: PUSH
120449: LD_VAR 0 4
120453: PPUSH
120454: LD_INT 95
120456: PUSH
120457: LD_VAR 0 22
120461: PUSH
120462: EMPTY
120463: LIST
120464: LIST
120465: PUSH
120466: LD_INT 58
120468: PUSH
120469: EMPTY
120470: LIST
120471: PUSH
120472: EMPTY
120473: LIST
120474: LIST
120475: PPUSH
120476: CALL_OW 72
120480: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
120481: LD_VAR 0 4
120485: PUSH
120486: LD_VAR 0 7
120490: ARRAY
120491: PPUSH
120492: CALL_OW 314
120496: NOT
120497: IFFALSE 120619
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
120499: LD_ADDR_VAR 0 10
120503: PUSH
120504: LD_VAR 0 13
120508: PPUSH
120509: LD_VAR 0 4
120513: PUSH
120514: LD_VAR 0 7
120518: ARRAY
120519: PPUSH
120520: CALL_OW 74
120524: ST_TO_ADDR
// if not x then
120525: LD_VAR 0 10
120529: NOT
120530: IFFALSE 120534
// continue ;
120532: GO 119966
// if GetLives ( x ) < 1000 then
120534: LD_VAR 0 10
120538: PPUSH
120539: CALL_OW 256
120543: PUSH
120544: LD_INT 1000
120546: LESS
120547: IFFALSE 120571
// ComRepairVehicle ( group [ i ] , x ) else
120549: LD_VAR 0 4
120553: PUSH
120554: LD_VAR 0 7
120558: ARRAY
120559: PPUSH
120560: LD_VAR 0 10
120564: PPUSH
120565: CALL_OW 129
120569: GO 120619
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
120571: LD_VAR 0 23
120575: PUSH
120576: LD_VAR 0 4
120580: PUSH
120581: LD_VAR 0 7
120585: ARRAY
120586: PPUSH
120587: CALL_OW 256
120591: PUSH
120592: LD_INT 1000
120594: LESS
120595: AND
120596: NOT
120597: IFFALSE 120619
// ComEnterUnit ( group [ i ] , x ) ;
120599: LD_VAR 0 4
120603: PUSH
120604: LD_VAR 0 7
120608: ARRAY
120609: PPUSH
120610: LD_VAR 0 10
120614: PPUSH
120615: CALL_OW 120
// end ; continue ;
120619: GO 119966
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
120621: LD_VAR 0 23
120625: PUSH
120626: LD_VAR 0 4
120630: PUSH
120631: LD_VAR 0 7
120635: ARRAY
120636: PPUSH
120637: CALL_OW 247
120641: PUSH
120642: LD_INT 1
120644: EQUAL
120645: AND
120646: IFFALSE 121124
// begin if group [ i ] in healers then
120648: LD_VAR 0 4
120652: PUSH
120653: LD_VAR 0 7
120657: ARRAY
120658: PUSH
120659: LD_VAR 0 31
120663: IN
120664: IFFALSE 120937
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
120666: LD_VAR 0 4
120670: PUSH
120671: LD_VAR 0 7
120675: ARRAY
120676: PPUSH
120677: LD_VAR 0 23
120681: PPUSH
120682: CALL_OW 308
120686: NOT
120687: PUSH
120688: LD_VAR 0 4
120692: PUSH
120693: LD_VAR 0 7
120697: ARRAY
120698: PPUSH
120699: CALL_OW 314
120703: NOT
120704: AND
120705: IFFALSE 120729
// ComMoveToArea ( group [ i ] , f_heal ) else
120707: LD_VAR 0 4
120711: PUSH
120712: LD_VAR 0 7
120716: ARRAY
120717: PPUSH
120718: LD_VAR 0 23
120722: PPUSH
120723: CALL_OW 113
120727: GO 120935
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
120729: LD_VAR 0 4
120733: PUSH
120734: LD_VAR 0 7
120738: ARRAY
120739: PPUSH
120740: CALL 98522 0 1
120744: PPUSH
120745: CALL_OW 256
120749: PUSH
120750: LD_INT 1000
120752: EQUAL
120753: IFFALSE 120772
// ComStop ( group [ i ] ) else
120755: LD_VAR 0 4
120759: PUSH
120760: LD_VAR 0 7
120764: ARRAY
120765: PPUSH
120766: CALL_OW 141
120770: GO 120935
// if not HasTask ( group [ i ] ) and to_heal then
120772: LD_VAR 0 4
120776: PUSH
120777: LD_VAR 0 7
120781: ARRAY
120782: PPUSH
120783: CALL_OW 314
120787: NOT
120788: PUSH
120789: LD_VAR 0 30
120793: AND
120794: IFFALSE 120935
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
120796: LD_ADDR_VAR 0 13
120800: PUSH
120801: LD_VAR 0 30
120805: PPUSH
120806: LD_INT 3
120808: PUSH
120809: LD_INT 54
120811: PUSH
120812: EMPTY
120813: LIST
120814: PUSH
120815: EMPTY
120816: LIST
120817: LIST
120818: PPUSH
120819: CALL_OW 72
120823: PPUSH
120824: LD_VAR 0 4
120828: PUSH
120829: LD_VAR 0 7
120833: ARRAY
120834: PPUSH
120835: CALL_OW 74
120839: ST_TO_ADDR
// if z then
120840: LD_VAR 0 13
120844: IFFALSE 120935
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
120846: LD_INT 91
120848: PUSH
120849: LD_VAR 0 13
120853: PUSH
120854: LD_INT 10
120856: PUSH
120857: EMPTY
120858: LIST
120859: LIST
120860: LIST
120861: PUSH
120862: LD_INT 81
120864: PUSH
120865: LD_VAR 0 13
120869: PPUSH
120870: CALL_OW 255
120874: PUSH
120875: EMPTY
120876: LIST
120877: LIST
120878: PUSH
120879: EMPTY
120880: LIST
120881: LIST
120882: PPUSH
120883: CALL_OW 69
120887: PUSH
120888: LD_INT 0
120890: EQUAL
120891: IFFALSE 120915
// ComHeal ( group [ i ] , z ) else
120893: LD_VAR 0 4
120897: PUSH
120898: LD_VAR 0 7
120902: ARRAY
120903: PPUSH
120904: LD_VAR 0 13
120908: PPUSH
120909: CALL_OW 128
120913: GO 120935
// ComMoveToArea ( group [ i ] , f_heal ) ;
120915: LD_VAR 0 4
120919: PUSH
120920: LD_VAR 0 7
120924: ARRAY
120925: PPUSH
120926: LD_VAR 0 23
120930: PPUSH
120931: CALL_OW 113
// end ; continue ;
120935: GO 119966
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
120937: LD_VAR 0 4
120941: PUSH
120942: LD_VAR 0 7
120946: ARRAY
120947: PPUSH
120948: CALL_OW 256
120952: PUSH
120953: LD_INT 700
120955: LESS
120956: PUSH
120957: LD_VAR 0 4
120961: PUSH
120962: LD_VAR 0 7
120966: ARRAY
120967: PUSH
120968: LD_VAR 0 30
120972: IN
120973: NOT
120974: AND
120975: IFFALSE 120999
// to_heal := to_heal union group [ i ] ;
120977: LD_ADDR_VAR 0 30
120981: PUSH
120982: LD_VAR 0 30
120986: PUSH
120987: LD_VAR 0 4
120991: PUSH
120992: LD_VAR 0 7
120996: ARRAY
120997: UNION
120998: ST_TO_ADDR
// if group [ i ] in to_heal then
120999: LD_VAR 0 4
121003: PUSH
121004: LD_VAR 0 7
121008: ARRAY
121009: PUSH
121010: LD_VAR 0 30
121014: IN
121015: IFFALSE 121124
// begin if GetLives ( group [ i ] ) = 1000 then
121017: LD_VAR 0 4
121021: PUSH
121022: LD_VAR 0 7
121026: ARRAY
121027: PPUSH
121028: CALL_OW 256
121032: PUSH
121033: LD_INT 1000
121035: EQUAL
121036: IFFALSE 121062
// to_heal := to_heal diff group [ i ] else
121038: LD_ADDR_VAR 0 30
121042: PUSH
121043: LD_VAR 0 30
121047: PUSH
121048: LD_VAR 0 4
121052: PUSH
121053: LD_VAR 0 7
121057: ARRAY
121058: DIFF
121059: ST_TO_ADDR
121060: GO 121124
// begin if not IsInArea ( group [ i ] , to_heal ) then
121062: LD_VAR 0 4
121066: PUSH
121067: LD_VAR 0 7
121071: ARRAY
121072: PPUSH
121073: LD_VAR 0 30
121077: PPUSH
121078: CALL_OW 308
121082: NOT
121083: IFFALSE 121107
// ComMoveToArea ( group [ i ] , f_heal ) else
121085: LD_VAR 0 4
121089: PUSH
121090: LD_VAR 0 7
121094: ARRAY
121095: PPUSH
121096: LD_VAR 0 23
121100: PPUSH
121101: CALL_OW 113
121105: GO 121122
// ComHold ( group [ i ] ) ;
121107: LD_VAR 0 4
121111: PUSH
121112: LD_VAR 0 7
121116: ARRAY
121117: PPUSH
121118: CALL_OW 140
// continue ;
121122: GO 119966
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
121124: LD_VAR 0 4
121128: PUSH
121129: LD_VAR 0 7
121133: ARRAY
121134: PPUSH
121135: LD_INT 10
121137: PPUSH
121138: CALL 96942 0 2
121142: NOT
121143: PUSH
121144: LD_VAR 0 16
121148: PUSH
121149: LD_VAR 0 7
121153: ARRAY
121154: PUSH
121155: EMPTY
121156: EQUAL
121157: NOT
121158: AND
121159: IFFALSE 121425
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
121161: LD_VAR 0 4
121165: PUSH
121166: LD_VAR 0 7
121170: ARRAY
121171: PPUSH
121172: CALL_OW 262
121176: PUSH
121177: LD_INT 1
121179: PUSH
121180: LD_INT 2
121182: PUSH
121183: EMPTY
121184: LIST
121185: LIST
121186: IN
121187: IFFALSE 121228
// if GetFuel ( group [ i ] ) < 10 then
121189: LD_VAR 0 4
121193: PUSH
121194: LD_VAR 0 7
121198: ARRAY
121199: PPUSH
121200: CALL_OW 261
121204: PUSH
121205: LD_INT 10
121207: LESS
121208: IFFALSE 121228
// SetFuel ( group [ i ] , 12 ) ;
121210: LD_VAR 0 4
121214: PUSH
121215: LD_VAR 0 7
121219: ARRAY
121220: PPUSH
121221: LD_INT 12
121223: PPUSH
121224: CALL_OW 240
// if units_path [ i ] then
121228: LD_VAR 0 16
121232: PUSH
121233: LD_VAR 0 7
121237: ARRAY
121238: IFFALSE 121423
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
121240: LD_VAR 0 4
121244: PUSH
121245: LD_VAR 0 7
121249: ARRAY
121250: PPUSH
121251: LD_VAR 0 16
121255: PUSH
121256: LD_VAR 0 7
121260: ARRAY
121261: PUSH
121262: LD_INT 1
121264: ARRAY
121265: PUSH
121266: LD_INT 1
121268: ARRAY
121269: PPUSH
121270: LD_VAR 0 16
121274: PUSH
121275: LD_VAR 0 7
121279: ARRAY
121280: PUSH
121281: LD_INT 1
121283: ARRAY
121284: PUSH
121285: LD_INT 2
121287: ARRAY
121288: PPUSH
121289: CALL_OW 297
121293: PUSH
121294: LD_INT 6
121296: GREATER
121297: IFFALSE 121372
// begin if not HasTask ( group [ i ] ) then
121299: LD_VAR 0 4
121303: PUSH
121304: LD_VAR 0 7
121308: ARRAY
121309: PPUSH
121310: CALL_OW 314
121314: NOT
121315: IFFALSE 121370
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
121317: LD_VAR 0 4
121321: PUSH
121322: LD_VAR 0 7
121326: ARRAY
121327: PPUSH
121328: LD_VAR 0 16
121332: PUSH
121333: LD_VAR 0 7
121337: ARRAY
121338: PUSH
121339: LD_INT 1
121341: ARRAY
121342: PUSH
121343: LD_INT 1
121345: ARRAY
121346: PPUSH
121347: LD_VAR 0 16
121351: PUSH
121352: LD_VAR 0 7
121356: ARRAY
121357: PUSH
121358: LD_INT 1
121360: ARRAY
121361: PUSH
121362: LD_INT 2
121364: ARRAY
121365: PPUSH
121366: CALL_OW 114
// end else
121370: GO 121423
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
121372: LD_ADDR_VAR 0 15
121376: PUSH
121377: LD_VAR 0 16
121381: PUSH
121382: LD_VAR 0 7
121386: ARRAY
121387: PPUSH
121388: LD_INT 1
121390: PPUSH
121391: CALL_OW 3
121395: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
121396: LD_ADDR_VAR 0 16
121400: PUSH
121401: LD_VAR 0 16
121405: PPUSH
121406: LD_VAR 0 7
121410: PPUSH
121411: LD_VAR 0 15
121415: PPUSH
121416: CALL_OW 1
121420: ST_TO_ADDR
// continue ;
121421: GO 119966
// end ; end ; end else
121423: GO 124087
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
121425: LD_ADDR_VAR 0 14
121429: PUSH
121430: LD_INT 81
121432: PUSH
121433: LD_VAR 0 4
121437: PUSH
121438: LD_VAR 0 7
121442: ARRAY
121443: PPUSH
121444: CALL_OW 255
121448: PUSH
121449: EMPTY
121450: LIST
121451: LIST
121452: PPUSH
121453: CALL_OW 69
121457: ST_TO_ADDR
// if not tmp then
121458: LD_VAR 0 14
121462: NOT
121463: IFFALSE 121467
// continue ;
121465: GO 119966
// if f_ignore_area then
121467: LD_VAR 0 17
121471: IFFALSE 121559
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
121473: LD_ADDR_VAR 0 15
121477: PUSH
121478: LD_VAR 0 14
121482: PPUSH
121483: LD_INT 3
121485: PUSH
121486: LD_INT 92
121488: PUSH
121489: LD_VAR 0 17
121493: PUSH
121494: LD_INT 1
121496: ARRAY
121497: PUSH
121498: LD_VAR 0 17
121502: PUSH
121503: LD_INT 2
121505: ARRAY
121506: PUSH
121507: LD_VAR 0 17
121511: PUSH
121512: LD_INT 3
121514: ARRAY
121515: PUSH
121516: EMPTY
121517: LIST
121518: LIST
121519: LIST
121520: LIST
121521: PUSH
121522: EMPTY
121523: LIST
121524: LIST
121525: PPUSH
121526: CALL_OW 72
121530: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121531: LD_VAR 0 14
121535: PUSH
121536: LD_VAR 0 15
121540: DIFF
121541: IFFALSE 121559
// tmp := tmp diff tmp2 ;
121543: LD_ADDR_VAR 0 14
121547: PUSH
121548: LD_VAR 0 14
121552: PUSH
121553: LD_VAR 0 15
121557: DIFF
121558: ST_TO_ADDR
// end ; if not f_murder then
121559: LD_VAR 0 20
121563: NOT
121564: IFFALSE 121622
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
121566: LD_ADDR_VAR 0 15
121570: PUSH
121571: LD_VAR 0 14
121575: PPUSH
121576: LD_INT 3
121578: PUSH
121579: LD_INT 50
121581: PUSH
121582: EMPTY
121583: LIST
121584: PUSH
121585: EMPTY
121586: LIST
121587: LIST
121588: PPUSH
121589: CALL_OW 72
121593: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121594: LD_VAR 0 14
121598: PUSH
121599: LD_VAR 0 15
121603: DIFF
121604: IFFALSE 121622
// tmp := tmp diff tmp2 ;
121606: LD_ADDR_VAR 0 14
121610: PUSH
121611: LD_VAR 0 14
121615: PUSH
121616: LD_VAR 0 15
121620: DIFF
121621: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
121622: LD_ADDR_VAR 0 14
121626: PUSH
121627: LD_VAR 0 4
121631: PUSH
121632: LD_VAR 0 7
121636: ARRAY
121637: PPUSH
121638: LD_VAR 0 14
121642: PPUSH
121643: LD_INT 1
121645: PPUSH
121646: LD_INT 1
121648: PPUSH
121649: CALL 70585 0 4
121653: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
121654: LD_VAR 0 4
121658: PUSH
121659: LD_VAR 0 7
121663: ARRAY
121664: PPUSH
121665: CALL_OW 257
121669: PUSH
121670: LD_INT 1
121672: EQUAL
121673: IFFALSE 122121
// begin if WantPlant ( group [ i ] ) then
121675: LD_VAR 0 4
121679: PUSH
121680: LD_VAR 0 7
121684: ARRAY
121685: PPUSH
121686: CALL 70086 0 1
121690: IFFALSE 121694
// continue ;
121692: GO 119966
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
121694: LD_VAR 0 18
121698: PUSH
121699: LD_VAR 0 4
121703: PUSH
121704: LD_VAR 0 7
121708: ARRAY
121709: PPUSH
121710: CALL_OW 310
121714: NOT
121715: AND
121716: PUSH
121717: LD_VAR 0 14
121721: PUSH
121722: LD_INT 1
121724: ARRAY
121725: PUSH
121726: LD_VAR 0 14
121730: PPUSH
121731: LD_INT 21
121733: PUSH
121734: LD_INT 2
121736: PUSH
121737: EMPTY
121738: LIST
121739: LIST
121740: PUSH
121741: LD_INT 58
121743: PUSH
121744: EMPTY
121745: LIST
121746: PUSH
121747: EMPTY
121748: LIST
121749: LIST
121750: PPUSH
121751: CALL_OW 72
121755: IN
121756: AND
121757: IFFALSE 121793
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
121759: LD_VAR 0 4
121763: PUSH
121764: LD_VAR 0 7
121768: ARRAY
121769: PPUSH
121770: LD_VAR 0 14
121774: PUSH
121775: LD_INT 1
121777: ARRAY
121778: PPUSH
121779: CALL_OW 120
// attacking := true ;
121783: LD_ADDR_VAR 0 29
121787: PUSH
121788: LD_INT 1
121790: ST_TO_ADDR
// continue ;
121791: GO 119966
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
121793: LD_VAR 0 26
121797: PUSH
121798: LD_VAR 0 4
121802: PUSH
121803: LD_VAR 0 7
121807: ARRAY
121808: PPUSH
121809: CALL_OW 257
121813: PUSH
121814: LD_INT 1
121816: EQUAL
121817: AND
121818: PUSH
121819: LD_VAR 0 4
121823: PUSH
121824: LD_VAR 0 7
121828: ARRAY
121829: PPUSH
121830: CALL_OW 256
121834: PUSH
121835: LD_INT 800
121837: LESS
121838: AND
121839: PUSH
121840: LD_VAR 0 4
121844: PUSH
121845: LD_VAR 0 7
121849: ARRAY
121850: PPUSH
121851: CALL_OW 318
121855: NOT
121856: AND
121857: IFFALSE 121874
// ComCrawl ( group [ i ] ) ;
121859: LD_VAR 0 4
121863: PUSH
121864: LD_VAR 0 7
121868: ARRAY
121869: PPUSH
121870: CALL_OW 137
// if f_mines then
121874: LD_VAR 0 21
121878: IFFALSE 122121
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
121880: LD_VAR 0 14
121884: PUSH
121885: LD_INT 1
121887: ARRAY
121888: PPUSH
121889: CALL_OW 247
121893: PUSH
121894: LD_INT 3
121896: EQUAL
121897: PUSH
121898: LD_VAR 0 14
121902: PUSH
121903: LD_INT 1
121905: ARRAY
121906: PUSH
121907: LD_VAR 0 27
121911: IN
121912: NOT
121913: AND
121914: IFFALSE 122121
// begin x := GetX ( tmp [ 1 ] ) ;
121916: LD_ADDR_VAR 0 10
121920: PUSH
121921: LD_VAR 0 14
121925: PUSH
121926: LD_INT 1
121928: ARRAY
121929: PPUSH
121930: CALL_OW 250
121934: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
121935: LD_ADDR_VAR 0 11
121939: PUSH
121940: LD_VAR 0 14
121944: PUSH
121945: LD_INT 1
121947: ARRAY
121948: PPUSH
121949: CALL_OW 251
121953: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
121954: LD_ADDR_VAR 0 12
121958: PUSH
121959: LD_VAR 0 4
121963: PUSH
121964: LD_VAR 0 7
121968: ARRAY
121969: PPUSH
121970: CALL 97027 0 1
121974: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
121975: LD_VAR 0 4
121979: PUSH
121980: LD_VAR 0 7
121984: ARRAY
121985: PPUSH
121986: LD_VAR 0 10
121990: PPUSH
121991: LD_VAR 0 11
121995: PPUSH
121996: LD_VAR 0 14
122000: PUSH
122001: LD_INT 1
122003: ARRAY
122004: PPUSH
122005: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
122009: LD_VAR 0 4
122013: PUSH
122014: LD_VAR 0 7
122018: ARRAY
122019: PPUSH
122020: LD_VAR 0 10
122024: PPUSH
122025: LD_VAR 0 12
122029: PPUSH
122030: LD_INT 7
122032: PPUSH
122033: CALL_OW 272
122037: PPUSH
122038: LD_VAR 0 11
122042: PPUSH
122043: LD_VAR 0 12
122047: PPUSH
122048: LD_INT 7
122050: PPUSH
122051: CALL_OW 273
122055: PPUSH
122056: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
122060: LD_VAR 0 4
122064: PUSH
122065: LD_VAR 0 7
122069: ARRAY
122070: PPUSH
122071: LD_INT 71
122073: PPUSH
122074: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
122078: LD_ADDR_VAR 0 27
122082: PUSH
122083: LD_VAR 0 27
122087: PPUSH
122088: LD_VAR 0 27
122092: PUSH
122093: LD_INT 1
122095: PLUS
122096: PPUSH
122097: LD_VAR 0 14
122101: PUSH
122102: LD_INT 1
122104: ARRAY
122105: PPUSH
122106: CALL_OW 1
122110: ST_TO_ADDR
// attacking := true ;
122111: LD_ADDR_VAR 0 29
122115: PUSH
122116: LD_INT 1
122118: ST_TO_ADDR
// continue ;
122119: GO 119966
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
122121: LD_VAR 0 4
122125: PUSH
122126: LD_VAR 0 7
122130: ARRAY
122131: PPUSH
122132: CALL_OW 257
122136: PUSH
122137: LD_INT 17
122139: EQUAL
122140: PUSH
122141: LD_VAR 0 4
122145: PUSH
122146: LD_VAR 0 7
122150: ARRAY
122151: PPUSH
122152: CALL_OW 110
122156: PUSH
122157: LD_INT 71
122159: EQUAL
122160: NOT
122161: AND
122162: IFFALSE 122308
// begin attacking := false ;
122164: LD_ADDR_VAR 0 29
122168: PUSH
122169: LD_INT 0
122171: ST_TO_ADDR
// k := 5 ;
122172: LD_ADDR_VAR 0 9
122176: PUSH
122177: LD_INT 5
122179: ST_TO_ADDR
// if tmp < k then
122180: LD_VAR 0 14
122184: PUSH
122185: LD_VAR 0 9
122189: LESS
122190: IFFALSE 122202
// k := tmp ;
122192: LD_ADDR_VAR 0 9
122196: PUSH
122197: LD_VAR 0 14
122201: ST_TO_ADDR
// for j = 1 to k do
122202: LD_ADDR_VAR 0 8
122206: PUSH
122207: DOUBLE
122208: LD_INT 1
122210: DEC
122211: ST_TO_ADDR
122212: LD_VAR 0 9
122216: PUSH
122217: FOR_TO
122218: IFFALSE 122306
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
122220: LD_VAR 0 14
122224: PUSH
122225: LD_VAR 0 8
122229: ARRAY
122230: PUSH
122231: LD_VAR 0 14
122235: PPUSH
122236: LD_INT 58
122238: PUSH
122239: EMPTY
122240: LIST
122241: PPUSH
122242: CALL_OW 72
122246: IN
122247: NOT
122248: IFFALSE 122304
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122250: LD_VAR 0 4
122254: PUSH
122255: LD_VAR 0 7
122259: ARRAY
122260: PPUSH
122261: LD_VAR 0 14
122265: PUSH
122266: LD_VAR 0 8
122270: ARRAY
122271: PPUSH
122272: CALL_OW 115
// attacking := true ;
122276: LD_ADDR_VAR 0 29
122280: PUSH
122281: LD_INT 1
122283: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
122284: LD_VAR 0 4
122288: PUSH
122289: LD_VAR 0 7
122293: ARRAY
122294: PPUSH
122295: LD_INT 71
122297: PPUSH
122298: CALL_OW 109
// continue ;
122302: GO 122217
// end ; end ;
122304: GO 122217
122306: POP
122307: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
122308: LD_VAR 0 4
122312: PUSH
122313: LD_VAR 0 7
122317: ARRAY
122318: PPUSH
122319: CALL_OW 257
122323: PUSH
122324: LD_INT 8
122326: EQUAL
122327: PUSH
122328: LD_VAR 0 4
122332: PUSH
122333: LD_VAR 0 7
122337: ARRAY
122338: PPUSH
122339: CALL_OW 264
122343: PUSH
122344: LD_INT 28
122346: PUSH
122347: LD_INT 45
122349: PUSH
122350: LD_INT 7
122352: PUSH
122353: LD_INT 47
122355: PUSH
122356: EMPTY
122357: LIST
122358: LIST
122359: LIST
122360: LIST
122361: IN
122362: OR
122363: IFFALSE 122619
// begin attacking := false ;
122365: LD_ADDR_VAR 0 29
122369: PUSH
122370: LD_INT 0
122372: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
122373: LD_VAR 0 14
122377: PUSH
122378: LD_INT 1
122380: ARRAY
122381: PPUSH
122382: CALL_OW 266
122386: PUSH
122387: LD_INT 32
122389: PUSH
122390: LD_INT 31
122392: PUSH
122393: LD_INT 33
122395: PUSH
122396: LD_INT 4
122398: PUSH
122399: LD_INT 5
122401: PUSH
122402: EMPTY
122403: LIST
122404: LIST
122405: LIST
122406: LIST
122407: LIST
122408: IN
122409: IFFALSE 122595
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
122411: LD_ADDR_VAR 0 9
122415: PUSH
122416: LD_VAR 0 14
122420: PUSH
122421: LD_INT 1
122423: ARRAY
122424: PPUSH
122425: CALL_OW 266
122429: PPUSH
122430: LD_VAR 0 14
122434: PUSH
122435: LD_INT 1
122437: ARRAY
122438: PPUSH
122439: CALL_OW 250
122443: PPUSH
122444: LD_VAR 0 14
122448: PUSH
122449: LD_INT 1
122451: ARRAY
122452: PPUSH
122453: CALL_OW 251
122457: PPUSH
122458: LD_VAR 0 14
122462: PUSH
122463: LD_INT 1
122465: ARRAY
122466: PPUSH
122467: CALL_OW 254
122471: PPUSH
122472: LD_VAR 0 14
122476: PUSH
122477: LD_INT 1
122479: ARRAY
122480: PPUSH
122481: CALL_OW 248
122485: PPUSH
122486: LD_INT 0
122488: PPUSH
122489: CALL 78397 0 6
122493: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
122494: LD_ADDR_VAR 0 8
122498: PUSH
122499: LD_VAR 0 4
122503: PUSH
122504: LD_VAR 0 7
122508: ARRAY
122509: PPUSH
122510: LD_VAR 0 9
122514: PPUSH
122515: CALL 97067 0 2
122519: ST_TO_ADDR
// if j then
122520: LD_VAR 0 8
122524: IFFALSE 122593
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
122526: LD_VAR 0 8
122530: PUSH
122531: LD_INT 1
122533: ARRAY
122534: PPUSH
122535: LD_VAR 0 8
122539: PUSH
122540: LD_INT 2
122542: ARRAY
122543: PPUSH
122544: CALL_OW 488
122548: IFFALSE 122593
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
122550: LD_VAR 0 4
122554: PUSH
122555: LD_VAR 0 7
122559: ARRAY
122560: PPUSH
122561: LD_VAR 0 8
122565: PUSH
122566: LD_INT 1
122568: ARRAY
122569: PPUSH
122570: LD_VAR 0 8
122574: PUSH
122575: LD_INT 2
122577: ARRAY
122578: PPUSH
122579: CALL_OW 116
// attacking := true ;
122583: LD_ADDR_VAR 0 29
122587: PUSH
122588: LD_INT 1
122590: ST_TO_ADDR
// continue ;
122591: GO 119966
// end ; end else
122593: GO 122619
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122595: LD_VAR 0 4
122599: PUSH
122600: LD_VAR 0 7
122604: ARRAY
122605: PPUSH
122606: LD_VAR 0 14
122610: PUSH
122611: LD_INT 1
122613: ARRAY
122614: PPUSH
122615: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
122619: LD_VAR 0 4
122623: PUSH
122624: LD_VAR 0 7
122628: ARRAY
122629: PPUSH
122630: CALL_OW 265
122634: PUSH
122635: LD_INT 11
122637: EQUAL
122638: IFFALSE 122916
// begin k := 10 ;
122640: LD_ADDR_VAR 0 9
122644: PUSH
122645: LD_INT 10
122647: ST_TO_ADDR
// x := 0 ;
122648: LD_ADDR_VAR 0 10
122652: PUSH
122653: LD_INT 0
122655: ST_TO_ADDR
// if tmp < k then
122656: LD_VAR 0 14
122660: PUSH
122661: LD_VAR 0 9
122665: LESS
122666: IFFALSE 122678
// k := tmp ;
122668: LD_ADDR_VAR 0 9
122672: PUSH
122673: LD_VAR 0 14
122677: ST_TO_ADDR
// for j = k downto 1 do
122678: LD_ADDR_VAR 0 8
122682: PUSH
122683: DOUBLE
122684: LD_VAR 0 9
122688: INC
122689: ST_TO_ADDR
122690: LD_INT 1
122692: PUSH
122693: FOR_DOWNTO
122694: IFFALSE 122769
// begin if GetType ( tmp [ j ] ) = unit_human then
122696: LD_VAR 0 14
122700: PUSH
122701: LD_VAR 0 8
122705: ARRAY
122706: PPUSH
122707: CALL_OW 247
122711: PUSH
122712: LD_INT 1
122714: EQUAL
122715: IFFALSE 122767
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
122717: LD_VAR 0 4
122721: PUSH
122722: LD_VAR 0 7
122726: ARRAY
122727: PPUSH
122728: LD_VAR 0 14
122732: PUSH
122733: LD_VAR 0 8
122737: ARRAY
122738: PPUSH
122739: CALL 97338 0 2
// x := tmp [ j ] ;
122743: LD_ADDR_VAR 0 10
122747: PUSH
122748: LD_VAR 0 14
122752: PUSH
122753: LD_VAR 0 8
122757: ARRAY
122758: ST_TO_ADDR
// attacking := true ;
122759: LD_ADDR_VAR 0 29
122763: PUSH
122764: LD_INT 1
122766: ST_TO_ADDR
// end ; end ;
122767: GO 122693
122769: POP
122770: POP
// if not x then
122771: LD_VAR 0 10
122775: NOT
122776: IFFALSE 122916
// begin attacking := true ;
122778: LD_ADDR_VAR 0 29
122782: PUSH
122783: LD_INT 1
122785: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
122786: LD_VAR 0 4
122790: PUSH
122791: LD_VAR 0 7
122795: ARRAY
122796: PPUSH
122797: CALL_OW 250
122801: PPUSH
122802: LD_VAR 0 4
122806: PUSH
122807: LD_VAR 0 7
122811: ARRAY
122812: PPUSH
122813: CALL_OW 251
122817: PPUSH
122818: CALL_OW 546
122822: PUSH
122823: LD_INT 2
122825: ARRAY
122826: PUSH
122827: LD_VAR 0 14
122831: PUSH
122832: LD_INT 1
122834: ARRAY
122835: PPUSH
122836: CALL_OW 250
122840: PPUSH
122841: LD_VAR 0 14
122845: PUSH
122846: LD_INT 1
122848: ARRAY
122849: PPUSH
122850: CALL_OW 251
122854: PPUSH
122855: CALL_OW 546
122859: PUSH
122860: LD_INT 2
122862: ARRAY
122863: EQUAL
122864: IFFALSE 122892
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
122866: LD_VAR 0 4
122870: PUSH
122871: LD_VAR 0 7
122875: ARRAY
122876: PPUSH
122877: LD_VAR 0 14
122881: PUSH
122882: LD_INT 1
122884: ARRAY
122885: PPUSH
122886: CALL 97338 0 2
122890: GO 122916
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122892: LD_VAR 0 4
122896: PUSH
122897: LD_VAR 0 7
122901: ARRAY
122902: PPUSH
122903: LD_VAR 0 14
122907: PUSH
122908: LD_INT 1
122910: ARRAY
122911: PPUSH
122912: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
122916: LD_VAR 0 4
122920: PUSH
122921: LD_VAR 0 7
122925: ARRAY
122926: PPUSH
122927: CALL_OW 264
122931: PUSH
122932: LD_INT 29
122934: EQUAL
122935: IFFALSE 123301
// begin if WantsToAttack ( group [ i ] ) in bombed then
122937: LD_VAR 0 4
122941: PUSH
122942: LD_VAR 0 7
122946: ARRAY
122947: PPUSH
122948: CALL_OW 319
122952: PUSH
122953: LD_VAR 0 28
122957: IN
122958: IFFALSE 122962
// continue ;
122960: GO 119966
// k := 8 ;
122962: LD_ADDR_VAR 0 9
122966: PUSH
122967: LD_INT 8
122969: ST_TO_ADDR
// x := 0 ;
122970: LD_ADDR_VAR 0 10
122974: PUSH
122975: LD_INT 0
122977: ST_TO_ADDR
// if tmp < k then
122978: LD_VAR 0 14
122982: PUSH
122983: LD_VAR 0 9
122987: LESS
122988: IFFALSE 123000
// k := tmp ;
122990: LD_ADDR_VAR 0 9
122994: PUSH
122995: LD_VAR 0 14
122999: ST_TO_ADDR
// for j = 1 to k do
123000: LD_ADDR_VAR 0 8
123004: PUSH
123005: DOUBLE
123006: LD_INT 1
123008: DEC
123009: ST_TO_ADDR
123010: LD_VAR 0 9
123014: PUSH
123015: FOR_TO
123016: IFFALSE 123148
// begin if GetType ( tmp [ j ] ) = unit_building then
123018: LD_VAR 0 14
123022: PUSH
123023: LD_VAR 0 8
123027: ARRAY
123028: PPUSH
123029: CALL_OW 247
123033: PUSH
123034: LD_INT 3
123036: EQUAL
123037: IFFALSE 123146
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
123039: LD_VAR 0 14
123043: PUSH
123044: LD_VAR 0 8
123048: ARRAY
123049: PUSH
123050: LD_VAR 0 28
123054: IN
123055: NOT
123056: PUSH
123057: LD_VAR 0 14
123061: PUSH
123062: LD_VAR 0 8
123066: ARRAY
123067: PPUSH
123068: CALL_OW 313
123072: AND
123073: IFFALSE 123146
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123075: LD_VAR 0 4
123079: PUSH
123080: LD_VAR 0 7
123084: ARRAY
123085: PPUSH
123086: LD_VAR 0 14
123090: PUSH
123091: LD_VAR 0 8
123095: ARRAY
123096: PPUSH
123097: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
123101: LD_ADDR_VAR 0 28
123105: PUSH
123106: LD_VAR 0 28
123110: PPUSH
123111: LD_VAR 0 28
123115: PUSH
123116: LD_INT 1
123118: PLUS
123119: PPUSH
123120: LD_VAR 0 14
123124: PUSH
123125: LD_VAR 0 8
123129: ARRAY
123130: PPUSH
123131: CALL_OW 1
123135: ST_TO_ADDR
// attacking := true ;
123136: LD_ADDR_VAR 0 29
123140: PUSH
123141: LD_INT 1
123143: ST_TO_ADDR
// break ;
123144: GO 123148
// end ; end ;
123146: GO 123015
123148: POP
123149: POP
// if not attacking and f_attack_depot then
123150: LD_VAR 0 29
123154: NOT
123155: PUSH
123156: LD_VAR 0 25
123160: AND
123161: IFFALSE 123256
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123163: LD_ADDR_VAR 0 13
123167: PUSH
123168: LD_VAR 0 14
123172: PPUSH
123173: LD_INT 2
123175: PUSH
123176: LD_INT 30
123178: PUSH
123179: LD_INT 0
123181: PUSH
123182: EMPTY
123183: LIST
123184: LIST
123185: PUSH
123186: LD_INT 30
123188: PUSH
123189: LD_INT 1
123191: PUSH
123192: EMPTY
123193: LIST
123194: LIST
123195: PUSH
123196: EMPTY
123197: LIST
123198: LIST
123199: LIST
123200: PPUSH
123201: CALL_OW 72
123205: ST_TO_ADDR
// if z then
123206: LD_VAR 0 13
123210: IFFALSE 123256
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
123212: LD_VAR 0 4
123216: PUSH
123217: LD_VAR 0 7
123221: ARRAY
123222: PPUSH
123223: LD_VAR 0 13
123227: PPUSH
123228: LD_VAR 0 4
123232: PUSH
123233: LD_VAR 0 7
123237: ARRAY
123238: PPUSH
123239: CALL_OW 74
123243: PPUSH
123244: CALL_OW 115
// attacking := true ;
123248: LD_ADDR_VAR 0 29
123252: PUSH
123253: LD_INT 1
123255: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
123256: LD_VAR 0 4
123260: PUSH
123261: LD_VAR 0 7
123265: ARRAY
123266: PPUSH
123267: CALL_OW 256
123271: PUSH
123272: LD_INT 500
123274: LESS
123275: IFFALSE 123301
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123277: LD_VAR 0 4
123281: PUSH
123282: LD_VAR 0 7
123286: ARRAY
123287: PPUSH
123288: LD_VAR 0 14
123292: PUSH
123293: LD_INT 1
123295: ARRAY
123296: PPUSH
123297: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
123301: LD_VAR 0 4
123305: PUSH
123306: LD_VAR 0 7
123310: ARRAY
123311: PPUSH
123312: CALL_OW 264
123316: PUSH
123317: LD_INT 49
123319: EQUAL
123320: IFFALSE 123441
// begin if not HasTask ( group [ i ] ) then
123322: LD_VAR 0 4
123326: PUSH
123327: LD_VAR 0 7
123331: ARRAY
123332: PPUSH
123333: CALL_OW 314
123337: NOT
123338: IFFALSE 123441
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
123340: LD_ADDR_VAR 0 9
123344: PUSH
123345: LD_INT 81
123347: PUSH
123348: LD_VAR 0 4
123352: PUSH
123353: LD_VAR 0 7
123357: ARRAY
123358: PPUSH
123359: CALL_OW 255
123363: PUSH
123364: EMPTY
123365: LIST
123366: LIST
123367: PPUSH
123368: CALL_OW 69
123372: PPUSH
123373: LD_VAR 0 4
123377: PUSH
123378: LD_VAR 0 7
123382: ARRAY
123383: PPUSH
123384: CALL_OW 74
123388: ST_TO_ADDR
// if k then
123389: LD_VAR 0 9
123393: IFFALSE 123441
// if GetDistUnits ( group [ i ] , k ) > 10 then
123395: LD_VAR 0 4
123399: PUSH
123400: LD_VAR 0 7
123404: ARRAY
123405: PPUSH
123406: LD_VAR 0 9
123410: PPUSH
123411: CALL_OW 296
123415: PUSH
123416: LD_INT 10
123418: GREATER
123419: IFFALSE 123441
// ComMoveUnit ( group [ i ] , k ) ;
123421: LD_VAR 0 4
123425: PUSH
123426: LD_VAR 0 7
123430: ARRAY
123431: PPUSH
123432: LD_VAR 0 9
123436: PPUSH
123437: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
123441: LD_VAR 0 4
123445: PUSH
123446: LD_VAR 0 7
123450: ARRAY
123451: PPUSH
123452: CALL_OW 256
123456: PUSH
123457: LD_INT 250
123459: LESS
123460: PUSH
123461: LD_VAR 0 4
123465: PUSH
123466: LD_VAR 0 7
123470: ARRAY
123471: PUSH
123472: LD_INT 21
123474: PUSH
123475: LD_INT 2
123477: PUSH
123478: EMPTY
123479: LIST
123480: LIST
123481: PUSH
123482: LD_INT 23
123484: PUSH
123485: LD_INT 2
123487: PUSH
123488: EMPTY
123489: LIST
123490: LIST
123491: PUSH
123492: EMPTY
123493: LIST
123494: LIST
123495: PPUSH
123496: CALL_OW 69
123500: IN
123501: AND
123502: IFFALSE 123627
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
123504: LD_ADDR_VAR 0 9
123508: PUSH
123509: LD_OWVAR 3
123513: PUSH
123514: LD_VAR 0 4
123518: PUSH
123519: LD_VAR 0 7
123523: ARRAY
123524: DIFF
123525: PPUSH
123526: LD_VAR 0 4
123530: PUSH
123531: LD_VAR 0 7
123535: ARRAY
123536: PPUSH
123537: CALL_OW 74
123541: ST_TO_ADDR
// if not k then
123542: LD_VAR 0 9
123546: NOT
123547: IFFALSE 123551
// continue ;
123549: GO 119966
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
123551: LD_VAR 0 9
123555: PUSH
123556: LD_INT 81
123558: PUSH
123559: LD_VAR 0 4
123563: PUSH
123564: LD_VAR 0 7
123568: ARRAY
123569: PPUSH
123570: CALL_OW 255
123574: PUSH
123575: EMPTY
123576: LIST
123577: LIST
123578: PPUSH
123579: CALL_OW 69
123583: IN
123584: PUSH
123585: LD_VAR 0 9
123589: PPUSH
123590: LD_VAR 0 4
123594: PUSH
123595: LD_VAR 0 7
123599: ARRAY
123600: PPUSH
123601: CALL_OW 296
123605: PUSH
123606: LD_INT 5
123608: LESS
123609: AND
123610: IFFALSE 123627
// ComAutodestruct ( group [ i ] ) ;
123612: LD_VAR 0 4
123616: PUSH
123617: LD_VAR 0 7
123621: ARRAY
123622: PPUSH
123623: CALL 97236 0 1
// end ; if f_attack_depot then
123627: LD_VAR 0 25
123631: IFFALSE 123743
// begin k := 6 ;
123633: LD_ADDR_VAR 0 9
123637: PUSH
123638: LD_INT 6
123640: ST_TO_ADDR
// if tmp < k then
123641: LD_VAR 0 14
123645: PUSH
123646: LD_VAR 0 9
123650: LESS
123651: IFFALSE 123663
// k := tmp ;
123653: LD_ADDR_VAR 0 9
123657: PUSH
123658: LD_VAR 0 14
123662: ST_TO_ADDR
// for j = 1 to k do
123663: LD_ADDR_VAR 0 8
123667: PUSH
123668: DOUBLE
123669: LD_INT 1
123671: DEC
123672: ST_TO_ADDR
123673: LD_VAR 0 9
123677: PUSH
123678: FOR_TO
123679: IFFALSE 123741
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
123681: LD_VAR 0 8
123685: PPUSH
123686: CALL_OW 266
123690: PUSH
123691: LD_INT 0
123693: PUSH
123694: LD_INT 1
123696: PUSH
123697: EMPTY
123698: LIST
123699: LIST
123700: IN
123701: IFFALSE 123739
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123703: LD_VAR 0 4
123707: PUSH
123708: LD_VAR 0 7
123712: ARRAY
123713: PPUSH
123714: LD_VAR 0 14
123718: PUSH
123719: LD_VAR 0 8
123723: ARRAY
123724: PPUSH
123725: CALL_OW 115
// attacking := true ;
123729: LD_ADDR_VAR 0 29
123733: PUSH
123734: LD_INT 1
123736: ST_TO_ADDR
// break ;
123737: GO 123741
// end ;
123739: GO 123678
123741: POP
123742: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
123743: LD_VAR 0 4
123747: PUSH
123748: LD_VAR 0 7
123752: ARRAY
123753: PPUSH
123754: CALL_OW 302
123758: PUSH
123759: LD_VAR 0 29
123763: NOT
123764: AND
123765: IFFALSE 124087
// begin if GetTag ( group [ i ] ) = 71 then
123767: LD_VAR 0 4
123771: PUSH
123772: LD_VAR 0 7
123776: ARRAY
123777: PPUSH
123778: CALL_OW 110
123782: PUSH
123783: LD_INT 71
123785: EQUAL
123786: IFFALSE 123827
// begin if HasTask ( group [ i ] ) then
123788: LD_VAR 0 4
123792: PUSH
123793: LD_VAR 0 7
123797: ARRAY
123798: PPUSH
123799: CALL_OW 314
123803: IFFALSE 123809
// continue else
123805: GO 119966
123807: GO 123827
// SetTag ( group [ i ] , 0 ) ;
123809: LD_VAR 0 4
123813: PUSH
123814: LD_VAR 0 7
123818: ARRAY
123819: PPUSH
123820: LD_INT 0
123822: PPUSH
123823: CALL_OW 109
// end ; k := 8 ;
123827: LD_ADDR_VAR 0 9
123831: PUSH
123832: LD_INT 8
123834: ST_TO_ADDR
// x := 0 ;
123835: LD_ADDR_VAR 0 10
123839: PUSH
123840: LD_INT 0
123842: ST_TO_ADDR
// if tmp < k then
123843: LD_VAR 0 14
123847: PUSH
123848: LD_VAR 0 9
123852: LESS
123853: IFFALSE 123865
// k := tmp ;
123855: LD_ADDR_VAR 0 9
123859: PUSH
123860: LD_VAR 0 14
123864: ST_TO_ADDR
// for j = 1 to k do
123865: LD_ADDR_VAR 0 8
123869: PUSH
123870: DOUBLE
123871: LD_INT 1
123873: DEC
123874: ST_TO_ADDR
123875: LD_VAR 0 9
123879: PUSH
123880: FOR_TO
123881: IFFALSE 123979
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
123883: LD_VAR 0 14
123887: PUSH
123888: LD_VAR 0 8
123892: ARRAY
123893: PPUSH
123894: CALL_OW 247
123898: PUSH
123899: LD_INT 1
123901: EQUAL
123902: PUSH
123903: LD_VAR 0 14
123907: PUSH
123908: LD_VAR 0 8
123912: ARRAY
123913: PPUSH
123914: CALL_OW 256
123918: PUSH
123919: LD_INT 250
123921: LESS
123922: PUSH
123923: LD_VAR 0 20
123927: AND
123928: PUSH
123929: LD_VAR 0 20
123933: NOT
123934: PUSH
123935: LD_VAR 0 14
123939: PUSH
123940: LD_VAR 0 8
123944: ARRAY
123945: PPUSH
123946: CALL_OW 256
123950: PUSH
123951: LD_INT 250
123953: GREATEREQUAL
123954: AND
123955: OR
123956: AND
123957: IFFALSE 123977
// begin x := tmp [ j ] ;
123959: LD_ADDR_VAR 0 10
123963: PUSH
123964: LD_VAR 0 14
123968: PUSH
123969: LD_VAR 0 8
123973: ARRAY
123974: ST_TO_ADDR
// break ;
123975: GO 123979
// end ;
123977: GO 123880
123979: POP
123980: POP
// if x then
123981: LD_VAR 0 10
123985: IFFALSE 124009
// ComAttackUnit ( group [ i ] , x ) else
123987: LD_VAR 0 4
123991: PUSH
123992: LD_VAR 0 7
123996: ARRAY
123997: PPUSH
123998: LD_VAR 0 10
124002: PPUSH
124003: CALL_OW 115
124007: GO 124033
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124009: LD_VAR 0 4
124013: PUSH
124014: LD_VAR 0 7
124018: ARRAY
124019: PPUSH
124020: LD_VAR 0 14
124024: PUSH
124025: LD_INT 1
124027: ARRAY
124028: PPUSH
124029: CALL_OW 115
// if not HasTask ( group [ i ] ) then
124033: LD_VAR 0 4
124037: PUSH
124038: LD_VAR 0 7
124042: ARRAY
124043: PPUSH
124044: CALL_OW 314
124048: NOT
124049: IFFALSE 124087
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
124051: LD_VAR 0 4
124055: PUSH
124056: LD_VAR 0 7
124060: ARRAY
124061: PPUSH
124062: LD_VAR 0 14
124066: PPUSH
124067: LD_VAR 0 4
124071: PUSH
124072: LD_VAR 0 7
124076: ARRAY
124077: PPUSH
124078: CALL_OW 74
124082: PPUSH
124083: CALL_OW 115
// end ; end ; end ;
124087: GO 119966
124089: POP
124090: POP
// wait ( 0 0$2 ) ;
124091: LD_INT 70
124093: PPUSH
124094: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
124098: LD_VAR 0 4
124102: NOT
124103: PUSH
124104: LD_VAR 0 4
124108: PUSH
124109: EMPTY
124110: EQUAL
124111: OR
124112: PUSH
124113: LD_INT 81
124115: PUSH
124116: LD_VAR 0 35
124120: PUSH
124121: EMPTY
124122: LIST
124123: LIST
124124: PPUSH
124125: CALL_OW 69
124129: NOT
124130: OR
124131: IFFALSE 119951
// end ;
124133: LD_VAR 0 2
124137: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
124138: LD_INT 0
124140: PPUSH
124141: PPUSH
124142: PPUSH
124143: PPUSH
124144: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
124145: LD_VAR 0 1
124149: NOT
124150: PUSH
124151: LD_EXP 113
124155: PUSH
124156: LD_VAR 0 1
124160: ARRAY
124161: NOT
124162: OR
124163: PUSH
124164: LD_VAR 0 2
124168: NOT
124169: OR
124170: PUSH
124171: LD_VAR 0 3
124175: NOT
124176: OR
124177: IFFALSE 124181
// exit ;
124179: GO 124694
// side := mc_sides [ base ] ;
124181: LD_ADDR_VAR 0 6
124185: PUSH
124186: LD_EXP 139
124190: PUSH
124191: LD_VAR 0 1
124195: ARRAY
124196: ST_TO_ADDR
// if not side then
124197: LD_VAR 0 6
124201: NOT
124202: IFFALSE 124206
// exit ;
124204: GO 124694
// for i in solds do
124206: LD_ADDR_VAR 0 7
124210: PUSH
124211: LD_VAR 0 2
124215: PUSH
124216: FOR_IN
124217: IFFALSE 124278
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
124219: LD_VAR 0 7
124223: PPUSH
124224: CALL_OW 310
124228: PPUSH
124229: CALL_OW 266
124233: PUSH
124234: LD_INT 32
124236: PUSH
124237: LD_INT 31
124239: PUSH
124240: EMPTY
124241: LIST
124242: LIST
124243: IN
124244: IFFALSE 124264
// solds := solds diff i else
124246: LD_ADDR_VAR 0 2
124250: PUSH
124251: LD_VAR 0 2
124255: PUSH
124256: LD_VAR 0 7
124260: DIFF
124261: ST_TO_ADDR
124262: GO 124276
// SetTag ( i , 18 ) ;
124264: LD_VAR 0 7
124268: PPUSH
124269: LD_INT 18
124271: PPUSH
124272: CALL_OW 109
124276: GO 124216
124278: POP
124279: POP
// if not solds then
124280: LD_VAR 0 2
124284: NOT
124285: IFFALSE 124289
// exit ;
124287: GO 124694
// repeat wait ( 0 0$2 ) ;
124289: LD_INT 70
124291: PPUSH
124292: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
124296: LD_ADDR_VAR 0 5
124300: PUSH
124301: LD_VAR 0 6
124305: PPUSH
124306: LD_VAR 0 3
124310: PPUSH
124311: CALL 66951 0 2
124315: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124316: LD_EXP 113
124320: PUSH
124321: LD_VAR 0 1
124325: ARRAY
124326: NOT
124327: PUSH
124328: LD_EXP 113
124332: PUSH
124333: LD_VAR 0 1
124337: ARRAY
124338: PUSH
124339: EMPTY
124340: EQUAL
124341: OR
124342: IFFALSE 124379
// begin for i in solds do
124344: LD_ADDR_VAR 0 7
124348: PUSH
124349: LD_VAR 0 2
124353: PUSH
124354: FOR_IN
124355: IFFALSE 124368
// ComStop ( i ) ;
124357: LD_VAR 0 7
124361: PPUSH
124362: CALL_OW 141
124366: GO 124354
124368: POP
124369: POP
// solds := [ ] ;
124370: LD_ADDR_VAR 0 2
124374: PUSH
124375: EMPTY
124376: ST_TO_ADDR
// exit ;
124377: GO 124694
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
124379: LD_VAR 0 5
124383: NOT
124384: PUSH
124385: LD_VAR 0 5
124389: PUSH
124390: LD_INT 3
124392: GREATER
124393: OR
124394: PUSH
124395: LD_EXP 135
124399: PUSH
124400: LD_VAR 0 1
124404: ARRAY
124405: OR
124406: IFFALSE 124447
// begin for i in solds do
124408: LD_ADDR_VAR 0 7
124412: PUSH
124413: LD_VAR 0 2
124417: PUSH
124418: FOR_IN
124419: IFFALSE 124443
// if HasTask ( i ) then
124421: LD_VAR 0 7
124425: PPUSH
124426: CALL_OW 314
124430: IFFALSE 124441
// ComStop ( i ) ;
124432: LD_VAR 0 7
124436: PPUSH
124437: CALL_OW 141
124441: GO 124418
124443: POP
124444: POP
// break ;
124445: GO 124682
// end ; for i in solds do
124447: LD_ADDR_VAR 0 7
124451: PUSH
124452: LD_VAR 0 2
124456: PUSH
124457: FOR_IN
124458: IFFALSE 124674
// begin if IsInUnit ( i ) then
124460: LD_VAR 0 7
124464: PPUSH
124465: CALL_OW 310
124469: IFFALSE 124480
// ComExitBuilding ( i ) ;
124471: LD_VAR 0 7
124475: PPUSH
124476: CALL_OW 122
// if GetLives ( i ) > 333 then
124480: LD_VAR 0 7
124484: PPUSH
124485: CALL_OW 256
124489: PUSH
124490: LD_INT 333
124492: GREATER
124493: IFFALSE 124521
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
124495: LD_VAR 0 7
124499: PPUSH
124500: LD_VAR 0 5
124504: PPUSH
124505: LD_VAR 0 7
124509: PPUSH
124510: CALL_OW 74
124514: PPUSH
124515: CALL_OW 115
124519: GO 124672
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
124521: LD_ADDR_VAR 0 8
124525: PUSH
124526: LD_EXP 113
124530: PUSH
124531: LD_VAR 0 1
124535: ARRAY
124536: PPUSH
124537: LD_INT 2
124539: PUSH
124540: LD_INT 30
124542: PUSH
124543: LD_INT 0
124545: PUSH
124546: EMPTY
124547: LIST
124548: LIST
124549: PUSH
124550: LD_INT 30
124552: PUSH
124553: LD_INT 1
124555: PUSH
124556: EMPTY
124557: LIST
124558: LIST
124559: PUSH
124560: LD_INT 30
124562: PUSH
124563: LD_INT 6
124565: PUSH
124566: EMPTY
124567: LIST
124568: LIST
124569: PUSH
124570: EMPTY
124571: LIST
124572: LIST
124573: LIST
124574: LIST
124575: PPUSH
124576: CALL_OW 72
124580: PPUSH
124581: LD_VAR 0 7
124585: PPUSH
124586: CALL_OW 74
124590: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
124591: LD_VAR 0 7
124595: PPUSH
124596: LD_VAR 0 8
124600: PPUSH
124601: CALL_OW 250
124605: PPUSH
124606: LD_INT 3
124608: PPUSH
124609: LD_INT 5
124611: PPUSH
124612: CALL_OW 272
124616: PPUSH
124617: LD_VAR 0 8
124621: PPUSH
124622: CALL_OW 251
124626: PPUSH
124627: LD_INT 3
124629: PPUSH
124630: LD_INT 5
124632: PPUSH
124633: CALL_OW 273
124637: PPUSH
124638: CALL_OW 111
// SetTag ( i , 0 ) ;
124642: LD_VAR 0 7
124646: PPUSH
124647: LD_INT 0
124649: PPUSH
124650: CALL_OW 109
// solds := solds diff i ;
124654: LD_ADDR_VAR 0 2
124658: PUSH
124659: LD_VAR 0 2
124663: PUSH
124664: LD_VAR 0 7
124668: DIFF
124669: ST_TO_ADDR
// continue ;
124670: GO 124457
// end ; end ;
124672: GO 124457
124674: POP
124675: POP
// until solds ;
124676: LD_VAR 0 2
124680: IFFALSE 124289
// MC_Reset ( base , 18 ) ;
124682: LD_VAR 0 1
124686: PPUSH
124687: LD_INT 18
124689: PPUSH
124690: CALL 39192 0 2
// end ;
124694: LD_VAR 0 4
124698: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
124699: LD_INT 0
124701: PPUSH
124702: PPUSH
124703: PPUSH
124704: PPUSH
124705: PPUSH
124706: PPUSH
124707: PPUSH
124708: PPUSH
124709: PPUSH
124710: PPUSH
124711: PPUSH
124712: PPUSH
124713: PPUSH
124714: PPUSH
124715: PPUSH
124716: PPUSH
124717: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
124718: LD_ADDR_VAR 0 13
124722: PUSH
124723: LD_EXP 113
124727: PUSH
124728: LD_VAR 0 1
124732: ARRAY
124733: PPUSH
124734: LD_INT 25
124736: PUSH
124737: LD_INT 3
124739: PUSH
124740: EMPTY
124741: LIST
124742: LIST
124743: PPUSH
124744: CALL_OW 72
124748: ST_TO_ADDR
// if mc_remote_driver [ base ] then
124749: LD_EXP 153
124753: PUSH
124754: LD_VAR 0 1
124758: ARRAY
124759: IFFALSE 124783
// mechs := mechs diff mc_remote_driver [ base ] ;
124761: LD_ADDR_VAR 0 13
124765: PUSH
124766: LD_VAR 0 13
124770: PUSH
124771: LD_EXP 153
124775: PUSH
124776: LD_VAR 0 1
124780: ARRAY
124781: DIFF
124782: ST_TO_ADDR
// for i in mechs do
124783: LD_ADDR_VAR 0 5
124787: PUSH
124788: LD_VAR 0 13
124792: PUSH
124793: FOR_IN
124794: IFFALSE 124829
// if GetTag ( i ) > 0 then
124796: LD_VAR 0 5
124800: PPUSH
124801: CALL_OW 110
124805: PUSH
124806: LD_INT 0
124808: GREATER
124809: IFFALSE 124827
// mechs := mechs diff i ;
124811: LD_ADDR_VAR 0 13
124815: PUSH
124816: LD_VAR 0 13
124820: PUSH
124821: LD_VAR 0 5
124825: DIFF
124826: ST_TO_ADDR
124827: GO 124793
124829: POP
124830: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124831: LD_ADDR_VAR 0 9
124835: PUSH
124836: LD_EXP 113
124840: PUSH
124841: LD_VAR 0 1
124845: ARRAY
124846: PPUSH
124847: LD_INT 2
124849: PUSH
124850: LD_INT 25
124852: PUSH
124853: LD_INT 1
124855: PUSH
124856: EMPTY
124857: LIST
124858: LIST
124859: PUSH
124860: LD_INT 25
124862: PUSH
124863: LD_INT 5
124865: PUSH
124866: EMPTY
124867: LIST
124868: LIST
124869: PUSH
124870: LD_INT 25
124872: PUSH
124873: LD_INT 8
124875: PUSH
124876: EMPTY
124877: LIST
124878: LIST
124879: PUSH
124880: LD_INT 25
124882: PUSH
124883: LD_INT 9
124885: PUSH
124886: EMPTY
124887: LIST
124888: LIST
124889: PUSH
124890: EMPTY
124891: LIST
124892: LIST
124893: LIST
124894: LIST
124895: LIST
124896: PPUSH
124897: CALL_OW 72
124901: ST_TO_ADDR
// if not defenders and not solds then
124902: LD_VAR 0 2
124906: NOT
124907: PUSH
124908: LD_VAR 0 9
124912: NOT
124913: AND
124914: IFFALSE 124918
// exit ;
124916: GO 126608
// depot_under_attack := false ;
124918: LD_ADDR_VAR 0 17
124922: PUSH
124923: LD_INT 0
124925: ST_TO_ADDR
// sold_defenders := [ ] ;
124926: LD_ADDR_VAR 0 18
124930: PUSH
124931: EMPTY
124932: ST_TO_ADDR
// if mechs then
124933: LD_VAR 0 13
124937: IFFALSE 125090
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
124939: LD_ADDR_VAR 0 5
124943: PUSH
124944: LD_VAR 0 2
124948: PPUSH
124949: LD_INT 21
124951: PUSH
124952: LD_INT 2
124954: PUSH
124955: EMPTY
124956: LIST
124957: LIST
124958: PPUSH
124959: CALL_OW 72
124963: PUSH
124964: FOR_IN
124965: IFFALSE 125088
// begin if GetTag ( i ) <> 20 then
124967: LD_VAR 0 5
124971: PPUSH
124972: CALL_OW 110
124976: PUSH
124977: LD_INT 20
124979: NONEQUAL
124980: IFFALSE 124994
// SetTag ( i , 20 ) ;
124982: LD_VAR 0 5
124986: PPUSH
124987: LD_INT 20
124989: PPUSH
124990: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
124994: LD_VAR 0 5
124998: PPUSH
124999: CALL_OW 263
125003: PUSH
125004: LD_INT 1
125006: EQUAL
125007: PUSH
125008: LD_VAR 0 5
125012: PPUSH
125013: CALL_OW 311
125017: NOT
125018: AND
125019: IFFALSE 125086
// begin un := mechs [ 1 ] ;
125021: LD_ADDR_VAR 0 11
125025: PUSH
125026: LD_VAR 0 13
125030: PUSH
125031: LD_INT 1
125033: ARRAY
125034: ST_TO_ADDR
// ComExit ( un ) ;
125035: LD_VAR 0 11
125039: PPUSH
125040: CALL 101581 0 1
// AddComEnterUnit ( un , i ) ;
125044: LD_VAR 0 11
125048: PPUSH
125049: LD_VAR 0 5
125053: PPUSH
125054: CALL_OW 180
// SetTag ( un , 19 ) ;
125058: LD_VAR 0 11
125062: PPUSH
125063: LD_INT 19
125065: PPUSH
125066: CALL_OW 109
// mechs := mechs diff un ;
125070: LD_ADDR_VAR 0 13
125074: PUSH
125075: LD_VAR 0 13
125079: PUSH
125080: LD_VAR 0 11
125084: DIFF
125085: ST_TO_ADDR
// end ; end ;
125086: GO 124964
125088: POP
125089: POP
// if solds then
125090: LD_VAR 0 9
125094: IFFALSE 125153
// for i in solds do
125096: LD_ADDR_VAR 0 5
125100: PUSH
125101: LD_VAR 0 9
125105: PUSH
125106: FOR_IN
125107: IFFALSE 125151
// if not GetTag ( i ) then
125109: LD_VAR 0 5
125113: PPUSH
125114: CALL_OW 110
125118: NOT
125119: IFFALSE 125149
// begin defenders := defenders union i ;
125121: LD_ADDR_VAR 0 2
125125: PUSH
125126: LD_VAR 0 2
125130: PUSH
125131: LD_VAR 0 5
125135: UNION
125136: ST_TO_ADDR
// SetTag ( i , 18 ) ;
125137: LD_VAR 0 5
125141: PPUSH
125142: LD_INT 18
125144: PPUSH
125145: CALL_OW 109
// end ;
125149: GO 125106
125151: POP
125152: POP
// repeat wait ( 0 0$2 ) ;
125153: LD_INT 70
125155: PPUSH
125156: CALL_OW 67
// enemy := mc_scan [ base ] ;
125160: LD_ADDR_VAR 0 3
125164: PUSH
125165: LD_EXP 136
125169: PUSH
125170: LD_VAR 0 1
125174: ARRAY
125175: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125176: LD_EXP 113
125180: PUSH
125181: LD_VAR 0 1
125185: ARRAY
125186: NOT
125187: PUSH
125188: LD_EXP 113
125192: PUSH
125193: LD_VAR 0 1
125197: ARRAY
125198: PUSH
125199: EMPTY
125200: EQUAL
125201: OR
125202: IFFALSE 125239
// begin for i in defenders do
125204: LD_ADDR_VAR 0 5
125208: PUSH
125209: LD_VAR 0 2
125213: PUSH
125214: FOR_IN
125215: IFFALSE 125228
// ComStop ( i ) ;
125217: LD_VAR 0 5
125221: PPUSH
125222: CALL_OW 141
125226: GO 125214
125228: POP
125229: POP
// defenders := [ ] ;
125230: LD_ADDR_VAR 0 2
125234: PUSH
125235: EMPTY
125236: ST_TO_ADDR
// exit ;
125237: GO 126608
// end ; for i in defenders do
125239: LD_ADDR_VAR 0 5
125243: PUSH
125244: LD_VAR 0 2
125248: PUSH
125249: FOR_IN
125250: IFFALSE 126068
// begin e := NearestUnitToUnit ( enemy , i ) ;
125252: LD_ADDR_VAR 0 14
125256: PUSH
125257: LD_VAR 0 3
125261: PPUSH
125262: LD_VAR 0 5
125266: PPUSH
125267: CALL_OW 74
125271: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125272: LD_ADDR_VAR 0 8
125276: PUSH
125277: LD_EXP 113
125281: PUSH
125282: LD_VAR 0 1
125286: ARRAY
125287: PPUSH
125288: LD_INT 2
125290: PUSH
125291: LD_INT 30
125293: PUSH
125294: LD_INT 0
125296: PUSH
125297: EMPTY
125298: LIST
125299: LIST
125300: PUSH
125301: LD_INT 30
125303: PUSH
125304: LD_INT 1
125306: PUSH
125307: EMPTY
125308: LIST
125309: LIST
125310: PUSH
125311: EMPTY
125312: LIST
125313: LIST
125314: LIST
125315: PPUSH
125316: CALL_OW 72
125320: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
125321: LD_ADDR_VAR 0 17
125325: PUSH
125326: LD_VAR 0 8
125330: NOT
125331: PUSH
125332: LD_VAR 0 8
125336: PPUSH
125337: LD_INT 3
125339: PUSH
125340: LD_INT 24
125342: PUSH
125343: LD_INT 600
125345: PUSH
125346: EMPTY
125347: LIST
125348: LIST
125349: PUSH
125350: EMPTY
125351: LIST
125352: LIST
125353: PPUSH
125354: CALL_OW 72
125358: OR
125359: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
125360: LD_VAR 0 5
125364: PPUSH
125365: CALL_OW 247
125369: PUSH
125370: LD_INT 2
125372: DOUBLE
125373: EQUAL
125374: IFTRUE 125378
125376: GO 125774
125378: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
125379: LD_VAR 0 5
125383: PPUSH
125384: CALL_OW 256
125388: PUSH
125389: LD_INT 650
125391: GREATER
125392: PUSH
125393: LD_VAR 0 5
125397: PPUSH
125398: LD_VAR 0 14
125402: PPUSH
125403: CALL_OW 296
125407: PUSH
125408: LD_INT 40
125410: LESS
125411: PUSH
125412: LD_VAR 0 14
125416: PPUSH
125417: LD_EXP 138
125421: PUSH
125422: LD_VAR 0 1
125426: ARRAY
125427: PPUSH
125428: CALL_OW 308
125432: OR
125433: AND
125434: IFFALSE 125556
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
125436: LD_VAR 0 5
125440: PPUSH
125441: CALL_OW 262
125445: PUSH
125446: LD_INT 1
125448: EQUAL
125449: PUSH
125450: LD_VAR 0 5
125454: PPUSH
125455: CALL_OW 261
125459: PUSH
125460: LD_INT 30
125462: LESS
125463: AND
125464: PUSH
125465: LD_VAR 0 8
125469: AND
125470: IFFALSE 125540
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
125472: LD_VAR 0 5
125476: PPUSH
125477: LD_VAR 0 8
125481: PPUSH
125482: LD_VAR 0 5
125486: PPUSH
125487: CALL_OW 74
125491: PPUSH
125492: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
125496: LD_VAR 0 5
125500: PPUSH
125501: LD_VAR 0 8
125505: PPUSH
125506: LD_VAR 0 5
125510: PPUSH
125511: CALL_OW 74
125515: PPUSH
125516: CALL_OW 296
125520: PUSH
125521: LD_INT 6
125523: LESS
125524: IFFALSE 125538
// SetFuel ( i , 100 ) ;
125526: LD_VAR 0 5
125530: PPUSH
125531: LD_INT 100
125533: PPUSH
125534: CALL_OW 240
// end else
125538: GO 125554
// ComAttackUnit ( i , e ) ;
125540: LD_VAR 0 5
125544: PPUSH
125545: LD_VAR 0 14
125549: PPUSH
125550: CALL_OW 115
// end else
125554: GO 125657
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
125556: LD_VAR 0 14
125560: PPUSH
125561: LD_EXP 138
125565: PUSH
125566: LD_VAR 0 1
125570: ARRAY
125571: PPUSH
125572: CALL_OW 308
125576: NOT
125577: PUSH
125578: LD_VAR 0 5
125582: PPUSH
125583: LD_VAR 0 14
125587: PPUSH
125588: CALL_OW 296
125592: PUSH
125593: LD_INT 40
125595: GREATEREQUAL
125596: AND
125597: PUSH
125598: LD_VAR 0 5
125602: PPUSH
125603: CALL_OW 256
125607: PUSH
125608: LD_INT 650
125610: LESSEQUAL
125611: OR
125612: PUSH
125613: LD_VAR 0 5
125617: PPUSH
125618: LD_EXP 137
125622: PUSH
125623: LD_VAR 0 1
125627: ARRAY
125628: PPUSH
125629: CALL_OW 308
125633: NOT
125634: AND
125635: IFFALSE 125657
// ComMoveToArea ( i , mc_parking [ base ] ) ;
125637: LD_VAR 0 5
125641: PPUSH
125642: LD_EXP 137
125646: PUSH
125647: LD_VAR 0 1
125651: ARRAY
125652: PPUSH
125653: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
125657: LD_VAR 0 5
125661: PPUSH
125662: CALL_OW 256
125666: PUSH
125667: LD_INT 998
125669: LESS
125670: PUSH
125671: LD_VAR 0 5
125675: PPUSH
125676: CALL_OW 263
125680: PUSH
125681: LD_INT 1
125683: EQUAL
125684: AND
125685: PUSH
125686: LD_VAR 0 5
125690: PPUSH
125691: CALL_OW 311
125695: AND
125696: PUSH
125697: LD_VAR 0 5
125701: PPUSH
125702: LD_EXP 137
125706: PUSH
125707: LD_VAR 0 1
125711: ARRAY
125712: PPUSH
125713: CALL_OW 308
125717: AND
125718: IFFALSE 125772
// begin mech := IsDrivenBy ( i ) ;
125720: LD_ADDR_VAR 0 10
125724: PUSH
125725: LD_VAR 0 5
125729: PPUSH
125730: CALL_OW 311
125734: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
125735: LD_VAR 0 10
125739: PPUSH
125740: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
125744: LD_VAR 0 10
125748: PPUSH
125749: LD_VAR 0 5
125753: PPUSH
125754: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
125758: LD_VAR 0 10
125762: PPUSH
125763: LD_VAR 0 5
125767: PPUSH
125768: CALL_OW 180
// end ; end ; unit_human :
125772: GO 126039
125774: LD_INT 1
125776: DOUBLE
125777: EQUAL
125778: IFTRUE 125782
125780: GO 126038
125782: POP
// begin b := IsInUnit ( i ) ;
125783: LD_ADDR_VAR 0 19
125787: PUSH
125788: LD_VAR 0 5
125792: PPUSH
125793: CALL_OW 310
125797: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
125798: LD_ADDR_VAR 0 20
125802: PUSH
125803: LD_VAR 0 19
125807: NOT
125808: PUSH
125809: LD_VAR 0 19
125813: PPUSH
125814: CALL_OW 266
125818: PUSH
125819: LD_INT 32
125821: PUSH
125822: LD_INT 31
125824: PUSH
125825: EMPTY
125826: LIST
125827: LIST
125828: IN
125829: OR
125830: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
125831: LD_VAR 0 17
125835: PUSH
125836: LD_VAR 0 2
125840: PPUSH
125841: LD_INT 21
125843: PUSH
125844: LD_INT 2
125846: PUSH
125847: EMPTY
125848: LIST
125849: LIST
125850: PPUSH
125851: CALL_OW 72
125855: PUSH
125856: LD_INT 1
125858: LESSEQUAL
125859: OR
125860: PUSH
125861: LD_VAR 0 20
125865: AND
125866: PUSH
125867: LD_VAR 0 5
125871: PUSH
125872: LD_VAR 0 18
125876: IN
125877: NOT
125878: AND
125879: IFFALSE 125972
// begin if b then
125881: LD_VAR 0 19
125885: IFFALSE 125934
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
125887: LD_VAR 0 19
125891: PPUSH
125892: LD_VAR 0 3
125896: PPUSH
125897: LD_VAR 0 19
125901: PPUSH
125902: CALL_OW 74
125906: PPUSH
125907: CALL_OW 296
125911: PUSH
125912: LD_INT 10
125914: LESS
125915: PUSH
125916: LD_VAR 0 19
125920: PPUSH
125921: CALL_OW 461
125925: PUSH
125926: LD_INT 7
125928: NONEQUAL
125929: AND
125930: IFFALSE 125934
// continue ;
125932: GO 125249
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
125934: LD_ADDR_VAR 0 18
125938: PUSH
125939: LD_VAR 0 18
125943: PPUSH
125944: LD_VAR 0 18
125948: PUSH
125949: LD_INT 1
125951: PLUS
125952: PPUSH
125953: LD_VAR 0 5
125957: PPUSH
125958: CALL_OW 1
125962: ST_TO_ADDR
// ComExitBuilding ( i ) ;
125963: LD_VAR 0 5
125967: PPUSH
125968: CALL_OW 122
// end ; if sold_defenders then
125972: LD_VAR 0 18
125976: IFFALSE 126036
// if i in sold_defenders then
125978: LD_VAR 0 5
125982: PUSH
125983: LD_VAR 0 18
125987: IN
125988: IFFALSE 126036
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
125990: LD_VAR 0 5
125994: PPUSH
125995: CALL_OW 314
125999: NOT
126000: PUSH
126001: LD_VAR 0 5
126005: PPUSH
126006: LD_VAR 0 14
126010: PPUSH
126011: CALL_OW 296
126015: PUSH
126016: LD_INT 30
126018: LESS
126019: AND
126020: IFFALSE 126036
// ComAttackUnit ( i , e ) ;
126022: LD_VAR 0 5
126026: PPUSH
126027: LD_VAR 0 14
126031: PPUSH
126032: CALL_OW 115
// end ; end ; end ;
126036: GO 126039
126038: POP
// if IsDead ( i ) then
126039: LD_VAR 0 5
126043: PPUSH
126044: CALL_OW 301
126048: IFFALSE 126066
// defenders := defenders diff i ;
126050: LD_ADDR_VAR 0 2
126054: PUSH
126055: LD_VAR 0 2
126059: PUSH
126060: LD_VAR 0 5
126064: DIFF
126065: ST_TO_ADDR
// end ;
126066: GO 125249
126068: POP
126069: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
126070: LD_VAR 0 3
126074: NOT
126075: PUSH
126076: LD_VAR 0 2
126080: NOT
126081: OR
126082: PUSH
126083: LD_EXP 113
126087: PUSH
126088: LD_VAR 0 1
126092: ARRAY
126093: NOT
126094: OR
126095: IFFALSE 125153
// MC_Reset ( base , 18 ) ;
126097: LD_VAR 0 1
126101: PPUSH
126102: LD_INT 18
126104: PPUSH
126105: CALL 39192 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126109: LD_ADDR_VAR 0 2
126113: PUSH
126114: LD_VAR 0 2
126118: PUSH
126119: LD_VAR 0 2
126123: PPUSH
126124: LD_INT 2
126126: PUSH
126127: LD_INT 25
126129: PUSH
126130: LD_INT 1
126132: PUSH
126133: EMPTY
126134: LIST
126135: LIST
126136: PUSH
126137: LD_INT 25
126139: PUSH
126140: LD_INT 5
126142: PUSH
126143: EMPTY
126144: LIST
126145: LIST
126146: PUSH
126147: LD_INT 25
126149: PUSH
126150: LD_INT 8
126152: PUSH
126153: EMPTY
126154: LIST
126155: LIST
126156: PUSH
126157: LD_INT 25
126159: PUSH
126160: LD_INT 9
126162: PUSH
126163: EMPTY
126164: LIST
126165: LIST
126166: PUSH
126167: EMPTY
126168: LIST
126169: LIST
126170: LIST
126171: LIST
126172: LIST
126173: PPUSH
126174: CALL_OW 72
126178: DIFF
126179: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
126180: LD_VAR 0 3
126184: NOT
126185: PUSH
126186: LD_VAR 0 2
126190: PPUSH
126191: LD_INT 21
126193: PUSH
126194: LD_INT 2
126196: PUSH
126197: EMPTY
126198: LIST
126199: LIST
126200: PPUSH
126201: CALL_OW 72
126205: AND
126206: IFFALSE 126544
// begin tmp := FilterByTag ( defenders , 19 ) ;
126208: LD_ADDR_VAR 0 12
126212: PUSH
126213: LD_VAR 0 2
126217: PPUSH
126218: LD_INT 19
126220: PPUSH
126221: CALL 98711 0 2
126225: ST_TO_ADDR
// if tmp then
126226: LD_VAR 0 12
126230: IFFALSE 126300
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
126232: LD_ADDR_VAR 0 12
126236: PUSH
126237: LD_VAR 0 12
126241: PPUSH
126242: LD_INT 25
126244: PUSH
126245: LD_INT 3
126247: PUSH
126248: EMPTY
126249: LIST
126250: LIST
126251: PPUSH
126252: CALL_OW 72
126256: ST_TO_ADDR
// if tmp then
126257: LD_VAR 0 12
126261: IFFALSE 126300
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
126263: LD_ADDR_EXP 125
126267: PUSH
126268: LD_EXP 125
126272: PPUSH
126273: LD_VAR 0 1
126277: PPUSH
126278: LD_EXP 125
126282: PUSH
126283: LD_VAR 0 1
126287: ARRAY
126288: PUSH
126289: LD_VAR 0 12
126293: UNION
126294: PPUSH
126295: CALL_OW 1
126299: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
126300: LD_VAR 0 1
126304: PPUSH
126305: LD_INT 19
126307: PPUSH
126308: CALL 39192 0 2
// repeat wait ( 0 0$1 ) ;
126312: LD_INT 35
126314: PPUSH
126315: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126319: LD_EXP 113
126323: PUSH
126324: LD_VAR 0 1
126328: ARRAY
126329: NOT
126330: PUSH
126331: LD_EXP 113
126335: PUSH
126336: LD_VAR 0 1
126340: ARRAY
126341: PUSH
126342: EMPTY
126343: EQUAL
126344: OR
126345: IFFALSE 126382
// begin for i in defenders do
126347: LD_ADDR_VAR 0 5
126351: PUSH
126352: LD_VAR 0 2
126356: PUSH
126357: FOR_IN
126358: IFFALSE 126371
// ComStop ( i ) ;
126360: LD_VAR 0 5
126364: PPUSH
126365: CALL_OW 141
126369: GO 126357
126371: POP
126372: POP
// defenders := [ ] ;
126373: LD_ADDR_VAR 0 2
126377: PUSH
126378: EMPTY
126379: ST_TO_ADDR
// exit ;
126380: GO 126608
// end ; for i in defenders do
126382: LD_ADDR_VAR 0 5
126386: PUSH
126387: LD_VAR 0 2
126391: PUSH
126392: FOR_IN
126393: IFFALSE 126482
// begin if not IsInArea ( i , mc_parking [ base ] ) then
126395: LD_VAR 0 5
126399: PPUSH
126400: LD_EXP 137
126404: PUSH
126405: LD_VAR 0 1
126409: ARRAY
126410: PPUSH
126411: CALL_OW 308
126415: NOT
126416: IFFALSE 126440
// ComMoveToArea ( i , mc_parking [ base ] ) else
126418: LD_VAR 0 5
126422: PPUSH
126423: LD_EXP 137
126427: PUSH
126428: LD_VAR 0 1
126432: ARRAY
126433: PPUSH
126434: CALL_OW 113
126438: GO 126480
// if GetControl ( i ) = control_manual then
126440: LD_VAR 0 5
126444: PPUSH
126445: CALL_OW 263
126449: PUSH
126450: LD_INT 1
126452: EQUAL
126453: IFFALSE 126480
// if IsDrivenBy ( i ) then
126455: LD_VAR 0 5
126459: PPUSH
126460: CALL_OW 311
126464: IFFALSE 126480
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
126466: LD_VAR 0 5
126470: PPUSH
126471: CALL_OW 311
126475: PPUSH
126476: CALL_OW 121
// end ;
126480: GO 126392
126482: POP
126483: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
126484: LD_VAR 0 2
126488: PPUSH
126489: LD_INT 95
126491: PUSH
126492: LD_EXP 137
126496: PUSH
126497: LD_VAR 0 1
126501: ARRAY
126502: PUSH
126503: EMPTY
126504: LIST
126505: LIST
126506: PPUSH
126507: CALL_OW 72
126511: PUSH
126512: LD_VAR 0 2
126516: EQUAL
126517: PUSH
126518: LD_EXP 136
126522: PUSH
126523: LD_VAR 0 1
126527: ARRAY
126528: OR
126529: PUSH
126530: LD_EXP 113
126534: PUSH
126535: LD_VAR 0 1
126539: ARRAY
126540: NOT
126541: OR
126542: IFFALSE 126312
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
126544: LD_ADDR_EXP 135
126548: PUSH
126549: LD_EXP 135
126553: PPUSH
126554: LD_VAR 0 1
126558: PPUSH
126559: LD_VAR 0 2
126563: PPUSH
126564: LD_INT 21
126566: PUSH
126567: LD_INT 2
126569: PUSH
126570: EMPTY
126571: LIST
126572: LIST
126573: PPUSH
126574: CALL_OW 72
126578: PPUSH
126579: CALL_OW 1
126583: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
126584: LD_VAR 0 1
126588: PPUSH
126589: LD_INT 19
126591: PPUSH
126592: CALL 39192 0 2
// MC_Reset ( base , 20 ) ;
126596: LD_VAR 0 1
126600: PPUSH
126601: LD_INT 20
126603: PPUSH
126604: CALL 39192 0 2
// end ; end_of_file
126608: LD_VAR 0 4
126612: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
126613: LD_VAR 0 1
126617: PUSH
126618: LD_INT 200
126620: DOUBLE
126621: GREATEREQUAL
126622: IFFALSE 126630
126624: LD_INT 299
126626: DOUBLE
126627: LESSEQUAL
126628: IFTRUE 126632
126630: GO 126664
126632: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
126633: LD_VAR 0 1
126637: PPUSH
126638: LD_VAR 0 2
126642: PPUSH
126643: LD_VAR 0 3
126647: PPUSH
126648: LD_VAR 0 4
126652: PPUSH
126653: LD_VAR 0 5
126657: PPUSH
126658: CALL 115554 0 5
126662: GO 126741
126664: LD_INT 300
126666: DOUBLE
126667: GREATEREQUAL
126668: IFFALSE 126676
126670: LD_INT 399
126672: DOUBLE
126673: LESSEQUAL
126674: IFTRUE 126678
126676: GO 126740
126678: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
126679: LD_VAR 0 1
126683: PPUSH
126684: LD_VAR 0 2
126688: PPUSH
126689: LD_VAR 0 3
126693: PPUSH
126694: LD_VAR 0 4
126698: PPUSH
126699: LD_VAR 0 5
126703: PPUSH
126704: LD_VAR 0 6
126708: PPUSH
126709: LD_VAR 0 7
126713: PPUSH
126714: LD_VAR 0 8
126718: PPUSH
126719: LD_VAR 0 9
126723: PPUSH
126724: LD_VAR 0 10
126728: PPUSH
126729: LD_VAR 0 11
126733: PPUSH
126734: CALL 113460 0 11
126738: GO 126741
126740: POP
// end ;
126741: PPOPN 11
126743: END
