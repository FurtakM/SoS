// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34977 0 0
// InitMacro ;
  19: CALL 35121 0 0
// InitNature ;
  23: CALL 34845 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37233 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 137
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 138
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59535 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59628 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 58978 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 58793 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59535 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59628 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 58793 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 58978 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59408 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58475 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59535 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59628 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 142
 959: PUSH
 960: LD_EXP 142
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 58793 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59535 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59628 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58685 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 59946 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59117 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59408 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59408 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59740 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 58793 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59359 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65204 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70028 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70028 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70028 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70028 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70028 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65204 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65204 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65204 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65204 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65204 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65204 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65204 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65204 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65204 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65204 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65204 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65204 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65204 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65204 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65204 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65204 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65204 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65204 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65204 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65204 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65204 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65204 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65204 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65204 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65204 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65204 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65204 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65204 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70028 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65204 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65204 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65204 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73437 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 113
4739: PUSH
4740: LD_EXP 113
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70028 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 58978 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 58841 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60259 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 58841 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 58841 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60259 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60259 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 132
6023: PUSH
6024: LD_EXP 132
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 132
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70028 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65204 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73437 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 113
7483: PUSH
7484: LD_EXP 113
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 101193 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 101193 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 101254 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 101254 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70028 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70028 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70028 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70028 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70028 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70028 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70028 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70028 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65204 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60259 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 58841 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 58841 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60259 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60259 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 132
10579: PUSH
10580: LD_EXP 132
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 132
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65204 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 113
11990: PUSH
11991: LD_EXP 113
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 101298 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 58841 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 58841 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60259 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60259 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 132
13374: PUSH
13375: LD_EXP 132
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 132
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70028 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70028 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70028 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70028 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 101165 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 101079 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 101079 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 101079 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 101079 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 101079 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 101079 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 101079 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 101079 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 101079 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 101165 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 113
17039: PUSH
17040: LD_EXP 113
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 101165 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 101165 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 132
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 99699 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 99699 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 113
19216: PUSH
19217: LD_EXP 113
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 113
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 132
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 132
19588: PUSH
19589: LD_EXP 132
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 132
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 113
20048: PUSH
20049: LD_EXP 113
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 113
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70028 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 58793 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 132
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 132
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 132
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35356 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 101165 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70028 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73083 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 101165 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65267 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35356 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65204 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65204 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65204 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70028 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 101254 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 58841 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 98799 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 98799 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 2 ) ;
29795: LD_INT 2
29797: PPUSH
29798: CALL 35356 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35356 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 98799 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 113
32464: PUSH
32465: LD_EXP 113
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 113
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 21
32737: PUSH
32738: LD_INT 2
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 50
32747: PUSH
32748: EMPTY
32749: LIST
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: LIST
32755: PPUSH
32756: CALL_OW 69
32760: PUSH
32761: LD_INT 0
32763: EQUAL
32764: AND
32765: PUSH
32766: LD_EXP 21
32770: AND
32771: PUSH
32772: LD_EXP 22
32776: AND
32777: PUSH
32778: LD_EXP 23
32782: AND
32783: IFFALSE 33432
32785: GO 32787
32787: DISABLE
32788: LD_INT 0
32790: PPUSH
32791: PPUSH
32792: PPUSH
// begin m1 := false ;
32793: LD_ADDR_VAR 0 1
32797: PUSH
32798: LD_INT 0
32800: ST_TO_ADDR
// m2 := false ;
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: LD_INT 0
32808: ST_TO_ADDR
// m3 := false ;
32809: LD_ADDR_VAR 0 3
32813: PUSH
32814: LD_INT 0
32816: ST_TO_ADDR
// if not bombExploded then
32817: LD_EXP 37
32821: NOT
32822: IFFALSE 32831
// SetAchievement ( ACH_SIBROCKET ) ;
32824: LD_STRING ACH_SIBROCKET
32826: PPUSH
32827: CALL_OW 543
// if tick <= 120 120$00 then
32831: LD_OWVAR 1
32835: PUSH
32836: LD_INT 252000
32838: LESSEQUAL
32839: IFFALSE 32855
// begin wait ( 3 ) ;
32841: LD_INT 3
32843: PPUSH
32844: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32848: LD_STRING ACH_ASPEED_15
32850: PPUSH
32851: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32855: LD_EXP 39
32859: PPUSH
32860: CALL_OW 87
// music_class := 5 ;
32864: LD_ADDR_OWVAR 72
32868: PUSH
32869: LD_INT 5
32871: ST_TO_ADDR
// music_nat := 5 ;
32872: LD_ADDR_OWVAR 71
32876: PUSH
32877: LD_INT 5
32879: ST_TO_ADDR
// DialogueOn ;
32880: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32884: LD_EXP 39
32888: PPUSH
32889: LD_STRING D20-JMM-1
32891: PPUSH
32892: CALL_OW 88
// if IsOK ( Joan ) then
32896: LD_EXP 40
32900: PPUSH
32901: CALL_OW 302
32905: IFFALSE 32919
// Say ( Joan , D20-Joan-1 ) ;
32907: LD_EXP 40
32911: PPUSH
32912: LD_STRING D20-Joan-1
32914: PPUSH
32915: CALL_OW 88
// if IsOk ( Lisa ) then
32919: LD_EXP 42
32923: PPUSH
32924: CALL_OW 302
32928: IFFALSE 32942
// Say ( Lisa , D20-Lisa-1 ) ;
32930: LD_EXP 42
32934: PPUSH
32935: LD_STRING D20-Lisa-1
32937: PPUSH
32938: CALL_OW 88
// if IsOk ( Donaldson ) then
32942: LD_EXP 43
32946: PPUSH
32947: CALL_OW 302
32951: IFFALSE 32965
// Say ( Donaldson , D20-Don-1 ) ;
32953: LD_EXP 43
32957: PPUSH
32958: LD_STRING D20-Don-1
32960: PPUSH
32961: CALL_OW 88
// if IsOK ( Cornel ) then
32965: LD_EXP 50
32969: PPUSH
32970: CALL_OW 302
32974: IFFALSE 32988
// Say ( Cornel , D20-Corn-1 ) ;
32976: LD_EXP 50
32980: PPUSH
32981: LD_STRING D20-Corn-1
32983: PPUSH
32984: CALL_OW 88
// if IsOk ( Denis ) then
32988: LD_EXP 46
32992: PPUSH
32993: CALL_OW 302
32997: IFFALSE 33011
// Say ( Denis , D20-Den-1 ) ;
32999: LD_EXP 46
33003: PPUSH
33004: LD_STRING D20-Den-1
33006: PPUSH
33007: CALL_OW 88
// if IsOk ( Bobby ) then
33011: LD_EXP 44
33015: PPUSH
33016: CALL_OW 302
33020: IFFALSE 33034
// Say ( Bobby , D20-Bobby-1 ) ;
33022: LD_EXP 44
33026: PPUSH
33027: LD_STRING D20-Bobby-1
33029: PPUSH
33030: CALL_OW 88
// if IsOk ( Gladstone ) then
33034: LD_EXP 48
33038: PPUSH
33039: CALL_OW 302
33043: IFFALSE 33057
// Say ( Gladstone , D20-Glad-1 ) ;
33045: LD_EXP 48
33049: PPUSH
33050: LD_STRING D20-Glad-1
33052: PPUSH
33053: CALL_OW 88
// if IsOk ( Cyrus ) then
33057: LD_EXP 45
33061: PPUSH
33062: CALL_OW 302
33066: IFFALSE 33080
// Say ( Cyrus , D20-Cyrus-1 ) ;
33068: LD_EXP 45
33072: PPUSH
33073: LD_STRING D20-Cyrus-1
33075: PPUSH
33076: CALL_OW 88
// if IsOk ( Stevens ) then
33080: LD_EXP 41
33084: PPUSH
33085: CALL_OW 302
33089: IFFALSE 33103
// Say ( Stevens , D20-Huck-1 ) ;
33091: LD_EXP 41
33095: PPUSH
33096: LD_STRING D20-Huck-1
33098: PPUSH
33099: CALL_OW 88
// if IsOk ( Brown ) then
33103: LD_EXP 47
33107: PPUSH
33108: CALL_OW 302
33112: IFFALSE 33126
// Say ( Brown , D20-Brown-1 ) ;
33114: LD_EXP 47
33118: PPUSH
33119: LD_STRING D20-Brown-1
33121: PPUSH
33122: CALL_OW 88
// if IsOk ( Gary ) then
33126: LD_EXP 51
33130: PPUSH
33131: CALL_OW 302
33135: IFFALSE 33149
// Say ( Gary , D20-Gary-1 ) ;
33137: LD_EXP 51
33141: PPUSH
33142: LD_STRING D20-Gary-1
33144: PPUSH
33145: CALL_OW 88
// if IsOk ( Connie ) then
33149: LD_EXP 54
33153: PPUSH
33154: CALL_OW 302
33158: IFFALSE 33172
// Say ( Connie , D20-Con-1 ) ;
33160: LD_EXP 54
33164: PPUSH
33165: LD_STRING D20-Con-1
33167: PPUSH
33168: CALL_OW 88
// if IsOk ( Kurt ) then
33172: LD_EXP 60
33176: PPUSH
33177: CALL_OW 302
33181: IFFALSE 33195
// Say ( Kurt , D20-Kurt-1 ) ;
33183: LD_EXP 60
33187: PPUSH
33188: LD_STRING D20-Kurt-1
33190: PPUSH
33191: CALL_OW 88
// if IsOk ( Kikuchi ) then
33195: LD_EXP 53
33199: PPUSH
33200: CALL_OW 302
33204: IFFALSE 33218
// Say ( Kikuchi , D20-Yam-1 ) ;
33206: LD_EXP 53
33210: PPUSH
33211: LD_STRING D20-Yam-1
33213: PPUSH
33214: CALL_OW 88
// if IsOk ( Frank ) then
33218: LD_EXP 52
33222: PPUSH
33223: CALL_OW 302
33227: IFFALSE 33241
// Say ( Frank , D20-Frank-1 ) ;
33229: LD_EXP 52
33233: PPUSH
33234: LD_STRING D20-Frank-1
33236: PPUSH
33237: CALL_OW 88
// DialogueOff ;
33241: CALL_OW 7
// if RothCaptured then
33245: LD_EXP 33
33249: IFFALSE 33271
// begin m1 := true ;
33251: LD_ADDR_VAR 0 1
33255: PUSH
33256: LD_INT 1
33258: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33259: LD_STRING Roth
33261: PPUSH
33262: LD_INT 1
33264: PPUSH
33265: CALL_OW 101
// end else
33269: GO 33282
// AddMedal ( Roth , - 1 ) ;
33271: LD_STRING Roth
33273: PPUSH
33274: LD_INT 1
33276: NEG
33277: PPUSH
33278: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33282: LD_EXP 25
33286: NOT
33287: PUSH
33288: LD_EXP 27
33292: OR
33293: IFFALSE 33315
// begin m2 := true ;
33295: LD_ADDR_VAR 0 2
33299: PUSH
33300: LD_INT 1
33302: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33303: LD_STRING Project
33305: PPUSH
33306: LD_INT 1
33308: PPUSH
33309: CALL_OW 101
// end else
33313: GO 33326
// AddMedal ( Project , - 1 ) ;
33315: LD_STRING Project
33317: PPUSH
33318: LD_INT 1
33320: NEG
33321: PPUSH
33322: CALL_OW 101
// if lostCounter = 0 then
33326: LD_EXP 32
33330: PUSH
33331: LD_INT 0
33333: EQUAL
33334: IFFALSE 33356
// begin m3 := true ;
33336: LD_ADDR_VAR 0 3
33340: PUSH
33341: LD_INT 1
33343: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33344: LD_STRING NoLosses
33346: PPUSH
33347: LD_INT 1
33349: PPUSH
33350: CALL_OW 101
// end else
33354: GO 33367
// AddMedal ( NoLosses , - 1 ) ;
33356: LD_STRING NoLosses
33358: PPUSH
33359: LD_INT 1
33361: NEG
33362: PPUSH
33363: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33367: LD_VAR 0 1
33371: PUSH
33372: LD_VAR 0 2
33376: AND
33377: PUSH
33378: LD_VAR 0 3
33382: AND
33383: PUSH
33384: LD_OWVAR 67
33388: PUSH
33389: LD_INT 3
33391: EQUAL
33392: AND
33393: IFFALSE 33405
// SetAchievementEX ( ACH_AMER , 15 ) ;
33395: LD_STRING ACH_AMER
33397: PPUSH
33398: LD_INT 15
33400: PPUSH
33401: CALL_OW 564
// GiveMedals ( MAIN ) ;
33405: LD_STRING MAIN
33407: PPUSH
33408: CALL_OW 102
// music_class := 4 ;
33412: LD_ADDR_OWVAR 72
33416: PUSH
33417: LD_INT 4
33419: ST_TO_ADDR
// music_nat := 1 ;
33420: LD_ADDR_OWVAR 71
33424: PUSH
33425: LD_INT 1
33427: ST_TO_ADDR
// YouWin ;
33428: CALL_OW 103
// end ; end_of_file
33432: PPOPN 3
33434: END
// export function CustomEvent ( event ) ; begin
33435: LD_INT 0
33437: PPUSH
// end ;
33438: LD_VAR 0 2
33442: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33443: LD_VAR 0 1
33447: PUSH
33448: LD_INT 1
33450: EQUAL
33451: PUSH
33452: LD_VAR 0 2
33456: PUSH
33457: LD_INT 4
33459: EQUAL
33460: AND
33461: PUSH
33462: LD_EXP 58
33466: PPUSH
33467: CALL_OW 300
33471: AND
33472: IFFALSE 33488
// begin wait ( 0 0$2 ) ;
33474: LD_INT 70
33476: PPUSH
33477: CALL_OW 67
// YouLost ( Dismissed ) ;
33481: LD_STRING Dismissed
33483: PPUSH
33484: CALL_OW 104
// end ; end ;
33488: PPOPN 2
33490: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33491: LD_VAR 0 2
33495: PPUSH
33496: LD_VAR 0 3
33500: PPUSH
33501: LD_INT 18
33503: PPUSH
33504: CALL_OW 309
33508: IFFALSE 33517
// YouLost ( Motherlode3 ) ;
33510: LD_STRING Motherlode3
33512: PPUSH
33513: CALL_OW 104
// end ;
33517: PPOPN 3
33519: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33520: LD_EXP 27
33524: NOT
33525: IFFALSE 33535
// behemothDone := true ;
33527: LD_ADDR_EXP 28
33531: PUSH
33532: LD_INT 1
33534: ST_TO_ADDR
// end ;
33535: PPOPN 1
33537: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33538: LD_VAR 0 1
33542: PPUSH
33543: CALL_OW 255
33547: PUSH
33548: LD_INT 1
33550: EQUAL
33551: IFFALSE 33561
// bombExploded := true ;
33553: LD_ADDR_EXP 37
33557: PUSH
33558: LD_INT 1
33560: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33561: LD_VAR 0 1
33565: PPUSH
33566: CALL_OW 255
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: PUSH
33575: LD_EXP 30
33579: AND
33580: PUSH
33581: LD_INT 22
33583: PUSH
33584: LD_INT 3
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 34
33593: PUSH
33594: LD_INT 48
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PPUSH
33605: CALL_OW 69
33609: AND
33610: PUSH
33611: LD_INT 22
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 34
33623: PUSH
33624: LD_INT 8
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PPUSH
33635: CALL_OW 69
33639: NOT
33640: AND
33641: IFFALSE 33693
// begin wait ( 0 0$5 ) ;
33643: LD_INT 175
33645: PPUSH
33646: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33650: LD_INT 22
33652: PUSH
33653: LD_INT 3
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 34
33662: PUSH
33663: LD_INT 48
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PPUSH
33674: CALL_OW 69
33678: PUSH
33679: LD_INT 1
33681: ARRAY
33682: PPUSH
33683: LD_INT 60
33685: PPUSH
33686: LD_INT 95
33688: PPUSH
33689: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33693: LD_VAR 0 2
33697: PPUSH
33698: LD_VAR 0 3
33702: PPUSH
33703: LD_INT 18
33705: PPUSH
33706: CALL_OW 309
33710: IFFALSE 33770
// begin if GetSide ( unit ) = 1 then
33712: LD_VAR 0 1
33716: PPUSH
33717: CALL_OW 255
33721: PUSH
33722: LD_INT 1
33724: EQUAL
33725: IFFALSE 33741
// begin wait ( 0 0$6 ) ;
33727: LD_INT 210
33729: PPUSH
33730: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33734: LD_STRING Motherlode2
33736: PPUSH
33737: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33741: LD_VAR 0 1
33745: PPUSH
33746: CALL_OW 255
33750: PUSH
33751: LD_INT 8
33753: EQUAL
33754: IFFALSE 33770
// begin wait ( 0 0$6 ) ;
33756: LD_INT 210
33758: PPUSH
33759: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33763: LD_STRING Motherlode1
33765: PPUSH
33766: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33770: LD_VAR 0 1
33774: PPUSH
33775: CALL_OW 255
33779: PUSH
33780: LD_INT 3
33782: EQUAL
33783: IFFALSE 33804
// begin wait ( 0 0$5 ) ;
33785: LD_INT 175
33787: PPUSH
33788: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33792: LD_EXP 64
33796: PPUSH
33797: LD_STRING D18-Pla-1
33799: PPUSH
33800: CALL_OW 94
// end ; end ;
33804: PPOPN 3
33806: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33807: LD_VAR 0 1
33811: PUSH
33812: LD_INT 22
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 21
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 23
33834: PUSH
33835: LD_INT 1
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: LIST
33846: PPUSH
33847: CALL_OW 69
33851: IN
33852: IFFALSE 33868
// lostCounter := lostCounter + 1 ;
33854: LD_ADDR_EXP 32
33858: PUSH
33859: LD_EXP 32
33863: PUSH
33864: LD_INT 1
33866: PLUS
33867: ST_TO_ADDR
// if un in behemothBuilders then
33868: LD_VAR 0 1
33872: PUSH
33873: LD_EXP 73
33877: IN
33878: IFFALSE 33898
// begin behemothBuilders := behemothBuilders diff un ;
33880: LD_ADDR_EXP 73
33884: PUSH
33885: LD_EXP 73
33889: PUSH
33890: LD_VAR 0 1
33894: DIFF
33895: ST_TO_ADDR
// exit ;
33896: GO 33928
// end ; if un = JMM then
33898: LD_VAR 0 1
33902: PUSH
33903: LD_EXP 39
33907: EQUAL
33908: IFFALSE 33919
// begin YouLost ( JMM ) ;
33910: LD_STRING JMM
33912: PPUSH
33913: CALL_OW 104
// exit ;
33917: GO 33928
// end ; MCE_UnitDestroyed ( un ) ;
33919: LD_VAR 0 1
33923: PPUSH
33924: CALL 62252 0 1
// end ;
33928: PPOPN 1
33930: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33931: LD_VAR 0 1
33935: PPUSH
33936: LD_VAR 0 2
33940: PPUSH
33941: CALL 64586 0 2
// end ;
33945: PPOPN 2
33947: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33948: LD_VAR 0 1
33952: PPUSH
33953: CALL 63654 0 1
// end ;
33957: PPOPN 1
33959: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33960: LD_VAR 0 1
33964: PUSH
33965: LD_INT 22
33967: PUSH
33968: LD_INT 8
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 30
33977: PUSH
33978: LD_INT 2
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 23
33987: PUSH
33988: LD_INT 3
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: LIST
33999: PPUSH
34000: CALL_OW 69
34004: IN
34005: IFFALSE 34032
// begin ComUpgrade ( building ) ;
34007: LD_VAR 0 1
34011: PPUSH
34012: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34016: LD_EXP 61
34020: PPUSH
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL 73001 0 2
// exit ;
34030: GO 34041
// end ; MCE_BuildingComplete ( building ) ;
34032: LD_VAR 0 1
34036: PPUSH
34037: CALL 63895 0 1
// end ;
34041: PPOPN 1
34043: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34044: LD_VAR 0 1
34048: PPUSH
34049: LD_VAR 0 2
34053: PPUSH
34054: CALL 61948 0 2
// end ;
34058: PPOPN 2
34060: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: LD_VAR 0 3
34075: PPUSH
34076: LD_VAR 0 4
34080: PPUSH
34081: LD_VAR 0 5
34085: PPUSH
34086: CALL 61568 0 5
// end ;
34090: PPOPN 5
34092: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34093: LD_VAR 0 1
34097: PPUSH
34098: LD_VAR 0 2
34102: PPUSH
34103: CALL 61158 0 2
// end ;
34107: PPOPN 2
34109: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34110: LD_VAR 0 1
34114: PPUSH
34115: LD_VAR 0 2
34119: PPUSH
34120: LD_VAR 0 3
34124: PPUSH
34125: LD_VAR 0 4
34129: PPUSH
34130: CALL 60996 0 4
// end ;
34134: PPOPN 4
34136: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34137: LD_VAR 0 1
34141: PPUSH
34142: LD_VAR 0 2
34146: PPUSH
34147: LD_VAR 0 3
34151: PPUSH
34152: CALL 60771 0 3
// end ;
34156: PPOPN 3
34158: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34159: LD_VAR 0 1
34163: PPUSH
34164: LD_VAR 0 2
34168: PPUSH
34169: CALL 60656 0 2
// end ;
34173: PPOPN 2
34175: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34176: LD_VAR 0 1
34180: PPUSH
34181: LD_VAR 0 2
34185: PPUSH
34186: CALL 64847 0 2
// end ;
34190: PPOPN 2
34192: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34193: LD_VAR 0 1
34197: PPUSH
34198: CALL_OW 255
34202: PUSH
34203: LD_INT 4
34205: EQUAL
34206: PUSH
34207: LD_VAR 0 1
34211: PUSH
34212: LD_EXP 18
34216: PUSH
34217: LD_INT 1
34219: ARRAY
34220: IN
34221: AND
34222: PUSH
34223: LD_EXP 19
34227: AND
34228: IFFALSE 34247
// begin ComMoveXY ( driver , 61 , 93 ) ;
34230: LD_VAR 0 1
34234: PPUSH
34235: LD_INT 61
34237: PPUSH
34238: LD_INT 93
34240: PPUSH
34241: CALL_OW 111
// exit ;
34245: GO 34271
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34247: LD_VAR 0 1
34251: PPUSH
34252: LD_VAR 0 2
34256: PPUSH
34257: LD_VAR 0 3
34261: PPUSH
34262: LD_VAR 0 4
34266: PPUSH
34267: CALL 65063 0 4
// end ;
34271: PPOPN 4
34273: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34274: LD_VAR 0 1
34278: PPUSH
34279: LD_VAR 0 2
34283: PPUSH
34284: CALL 60465 0 2
// end ;
34288: PPOPN 2
34290: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34291: LD_VAR 0 1
34295: PPUSH
34296: CALL 115681 0 1
// end ; end_of_file
34300: PPOPN 1
34302: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34303: LD_EXP 15
34307: PUSH
34308: LD_INT 2
34310: EQUAL
34311: IFFALSE 34790
34313: GO 34315
34315: DISABLE
34316: LD_INT 0
34318: PPUSH
// begin time := 0 0$40 ;
34319: LD_ADDR_VAR 0 1
34323: PUSH
34324: LD_INT 1400
34326: ST_TO_ADDR
// repeat wait ( time ) ;
34327: LD_VAR 0 1
34331: PPUSH
34332: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34336: LD_INT 1
34338: PPUSH
34339: LD_INT 5
34341: PPUSH
34342: CALL_OW 12
34346: PPUSH
34347: LD_INT 106
34349: PPUSH
34350: LD_INT 150
34352: PPUSH
34353: LD_INT 19
34355: PPUSH
34356: LD_INT 1
34358: PPUSH
34359: CALL_OW 56
// time := time + 0 0$9 ;
34363: LD_ADDR_VAR 0 1
34367: PUSH
34368: LD_VAR 0 1
34372: PUSH
34373: LD_INT 315
34375: PLUS
34376: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34377: LD_INT 455
34379: PPUSH
34380: LD_INT 840
34382: PPUSH
34383: CALL_OW 12
34387: PPUSH
34388: CALL_OW 67
// if Prob ( 50 ) then
34392: LD_INT 50
34394: PPUSH
34395: CALL_OW 13
34399: IFFALSE 34428
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34401: LD_INT 1
34403: PPUSH
34404: LD_INT 5
34406: PPUSH
34407: CALL_OW 12
34411: PPUSH
34412: LD_INT 62
34414: PPUSH
34415: LD_INT 108
34417: PPUSH
34418: LD_INT 10
34420: PPUSH
34421: LD_INT 1
34423: PPUSH
34424: CALL_OW 56
// until missionStage > 4 ;
34428: LD_EXP 15
34432: PUSH
34433: LD_INT 4
34435: GREATER
34436: IFFALSE 34327
// repeat wait ( 0 0$1 ) ;
34438: LD_INT 35
34440: PPUSH
34441: CALL_OW 67
// until missionStage = 6 ;
34445: LD_EXP 15
34449: PUSH
34450: LD_INT 6
34452: EQUAL
34453: IFFALSE 34438
// time := 0 0$50 ;
34455: LD_ADDR_VAR 0 1
34459: PUSH
34460: LD_INT 1750
34462: ST_TO_ADDR
// repeat wait ( time ) ;
34463: LD_VAR 0 1
34467: PPUSH
34468: CALL_OW 67
// if Prob ( 50 ) then
34472: LD_INT 50
34474: PPUSH
34475: CALL_OW 13
34479: IFFALSE 34508
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34481: LD_INT 1
34483: PPUSH
34484: LD_INT 5
34486: PPUSH
34487: CALL_OW 12
34491: PPUSH
34492: LD_INT 106
34494: PPUSH
34495: LD_INT 89
34497: PPUSH
34498: LD_INT 45
34500: PPUSH
34501: LD_INT 1
34503: PPUSH
34504: CALL_OW 56
// time := time + 0 0$2 ;
34508: LD_ADDR_VAR 0 1
34512: PUSH
34513: LD_VAR 0 1
34517: PUSH
34518: LD_INT 70
34520: PLUS
34521: ST_TO_ADDR
// if Prob ( 30 ) then
34522: LD_INT 30
34524: PPUSH
34525: CALL_OW 13
34529: IFFALSE 34575
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34531: LD_INT 385
34533: PPUSH
34534: LD_INT 945
34536: PPUSH
34537: CALL_OW 12
34541: PPUSH
34542: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34546: LD_INT 1
34548: PPUSH
34549: LD_INT 5
34551: PPUSH
34552: CALL_OW 12
34556: PPUSH
34557: LD_INT 21
34559: PPUSH
34560: LD_INT 26
34562: PPUSH
34563: LD_INT 12
34565: PPUSH
34566: LD_INT 1
34568: PPUSH
34569: CALL_OW 56
// end else
34573: GO 34611
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34575: LD_INT 700
34577: PPUSH
34578: LD_INT 1225
34580: PPUSH
34581: CALL_OW 12
34585: PPUSH
34586: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34590: LD_INT 1
34592: PPUSH
34593: LD_INT 5
34595: PPUSH
34596: CALL_OW 12
34600: PPUSH
34601: LD_INT 16
34603: PPUSH
34604: LD_INT 1
34606: PPUSH
34607: CALL_OW 55
// end ; if Prob ( 50 ) then
34611: LD_INT 50
34613: PPUSH
34614: CALL_OW 13
34618: IFFALSE 34664
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34620: LD_INT 700
34622: PPUSH
34623: LD_INT 1050
34625: PPUSH
34626: CALL_OW 12
34630: PPUSH
34631: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34635: LD_INT 1
34637: PPUSH
34638: LD_INT 5
34640: PPUSH
34641: CALL_OW 12
34645: PPUSH
34646: LD_INT 181
34648: PPUSH
34649: LD_INT 218
34651: PPUSH
34652: LD_INT 16
34654: PPUSH
34655: LD_INT 1
34657: PPUSH
34658: CALL_OW 56
// end else
34662: GO 34700
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34664: LD_INT 350
34666: PPUSH
34667: LD_INT 525
34669: PPUSH
34670: CALL_OW 12
34674: PPUSH
34675: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34679: LD_INT 1
34681: PPUSH
34682: LD_INT 5
34684: PPUSH
34685: CALL_OW 12
34689: PPUSH
34690: LD_INT 15
34692: PPUSH
34693: LD_INT 1
34695: PPUSH
34696: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34700: LD_INT 45
34702: PUSH
34703: LD_INT 32
34705: PUSH
34706: LD_INT 25
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: LIST
34713: PUSH
34714: LD_OWVAR 67
34718: ARRAY
34719: PPUSH
34720: CALL_OW 13
34724: IFFALSE 34768
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34726: LD_INT 175
34728: PPUSH
34729: LD_INT 315
34731: PPUSH
34732: CALL_OW 12
34736: PPUSH
34737: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34741: LD_INT 1
34743: PPUSH
34744: LD_INT 5
34746: PPUSH
34747: CALL_OW 12
34751: PPUSH
34752: LD_INT 103
34754: PPUSH
34755: LD_INT 140
34757: PPUSH
34758: LD_INT 20
34760: PPUSH
34761: LD_INT 1
34763: PPUSH
34764: CALL_OW 56
// end ; if time > 1 1$20 then
34768: LD_VAR 0 1
34772: PUSH
34773: LD_INT 2800
34775: GREATER
34776: IFFALSE 34786
// time := 0 0$30 ;
34778: LD_ADDR_VAR 0 1
34782: PUSH
34783: LD_INT 1050
34785: ST_TO_ADDR
// until false ;
34786: LD_INT 0
34788: IFFALSE 34463
// end ; end_of_file
34790: PPOPN 1
34792: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34793: LD_EXP 13
34797: PUSH
34798: LD_EXP 15
34802: PUSH
34803: LD_INT 6
34805: GREATEREQUAL
34806: AND
34807: IFFALSE 34844
34809: GO 34811
34811: DISABLE
// begin enable ;
34812: ENABLE
// missionTime := missionTime + 0 0$1 ;
34813: LD_ADDR_EXP 14
34817: PUSH
34818: LD_EXP 14
34822: PUSH
34823: LD_INT 35
34825: PLUS
34826: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34827: LD_ADDR_OWVAR 47
34831: PUSH
34832: LD_STRING #Am15-1
34834: PUSH
34835: LD_EXP 14
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: ST_TO_ADDR
// end ; end_of_file
34844: END
// export function InitNature ; begin
34845: LD_INT 0
34847: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34848: LD_INT 3
34850: PPUSH
34851: LD_INT 3
34853: PPUSH
34854: LD_INT 2
34856: PPUSH
34857: LD_INT 1
34859: PPUSH
34860: LD_INT 1
34862: PPUSH
34863: LD_INT 0
34865: PPUSH
34866: LD_INT 0
34868: PPUSH
34869: LD_INT 20
34871: PPUSH
34872: LD_INT 0
34874: PPUSH
34875: CALL 97819 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34879: LD_INT 2
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: LD_INT 1
34887: PPUSH
34888: LD_INT 1
34890: PPUSH
34891: LD_INT 1
34893: PPUSH
34894: LD_INT 0
34896: PPUSH
34897: LD_INT 0
34899: PPUSH
34900: LD_INT 21
34902: PPUSH
34903: LD_INT 0
34905: PPUSH
34906: CALL 97819 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34910: LD_INT 4
34912: PPUSH
34913: LD_INT 1
34915: PPUSH
34916: LD_INT 2
34918: PPUSH
34919: LD_INT 4
34921: PPUSH
34922: LD_INT 2
34924: PPUSH
34925: LD_INT 1
34927: PPUSH
34928: LD_INT 0
34930: PPUSH
34931: LD_INT 22
34933: PPUSH
34934: LD_INT 0
34936: PPUSH
34937: CALL 97819 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34941: LD_INT 0
34943: PPUSH
34944: LD_INT 0
34946: PPUSH
34947: LD_INT 0
34949: PPUSH
34950: LD_INT 0
34952: PPUSH
34953: LD_INT 0
34955: PPUSH
34956: LD_INT 0
34958: PPUSH
34959: LD_INT 9
34961: PPUSH
34962: LD_INT 0
34964: PPUSH
34965: LD_INT 23
34967: PPUSH
34968: CALL 97819 0 9
// end ; end_of_file
34972: LD_VAR 0 1
34976: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34977: LD_INT 0
34979: PPUSH
// ar_miner := 81 ;
34980: LD_ADDR_EXP 102
34984: PUSH
34985: LD_INT 81
34987: ST_TO_ADDR
// ar_crane := 88 ;
34988: LD_ADDR_EXP 101
34992: PUSH
34993: LD_INT 88
34995: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34996: LD_ADDR_EXP 96
35000: PUSH
35001: LD_INT 89
35003: ST_TO_ADDR
// us_hack := 99 ;
35004: LD_ADDR_EXP 97
35008: PUSH
35009: LD_INT 99
35011: ST_TO_ADDR
// us_artillery := 97 ;
35012: LD_ADDR_EXP 98
35016: PUSH
35017: LD_INT 97
35019: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35020: LD_ADDR_EXP 99
35024: PUSH
35025: LD_INT 91
35027: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
35028: LD_ADDR_EXP 100
35032: PUSH
35033: LD_INT 92
35035: ST_TO_ADDR
// ru_radar := 98 ;
35036: LD_ADDR_EXP 95
35040: PUSH
35041: LD_INT 98
35043: ST_TO_ADDR
// tech_Artillery := 80 ;
35044: LD_ADDR_EXP 103
35048: PUSH
35049: LD_INT 80
35051: ST_TO_ADDR
// tech_RadMat := 81 ;
35052: LD_ADDR_EXP 104
35056: PUSH
35057: LD_INT 81
35059: ST_TO_ADDR
// tech_BasicTools := 82 ;
35060: LD_ADDR_EXP 105
35064: PUSH
35065: LD_INT 82
35067: ST_TO_ADDR
// tech_Cargo := 83 ;
35068: LD_ADDR_EXP 106
35072: PUSH
35073: LD_INT 83
35075: ST_TO_ADDR
// tech_Track := 84 ;
35076: LD_ADDR_EXP 107
35080: PUSH
35081: LD_INT 84
35083: ST_TO_ADDR
// tech_Crane := 85 ;
35084: LD_ADDR_EXP 108
35088: PUSH
35089: LD_INT 85
35091: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35092: LD_ADDR_EXP 109
35096: PUSH
35097: LD_INT 86
35099: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35100: LD_ADDR_EXP 110
35104: PUSH
35105: LD_INT 87
35107: ST_TO_ADDR
// end ;
35108: LD_VAR 0 1
35112: RET
// every 1 do
35113: GO 35115
35115: DISABLE
// InitGlobalVariables ; end_of_file
35116: CALL 34977 0 0
35120: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35121: LD_INT 0
35123: PPUSH
35124: PPUSH
// skirmish := false ;
35125: LD_ADDR_EXP 111
35129: PUSH
35130: LD_INT 0
35132: ST_TO_ADDR
// debug_mc := false ;
35133: LD_ADDR_EXP 112
35137: PUSH
35138: LD_INT 0
35140: ST_TO_ADDR
// mc_bases := [ ] ;
35141: LD_ADDR_EXP 113
35145: PUSH
35146: EMPTY
35147: ST_TO_ADDR
// mc_sides := [ ] ;
35148: LD_ADDR_EXP 139
35152: PUSH
35153: EMPTY
35154: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35155: LD_ADDR_EXP 114
35159: PUSH
35160: EMPTY
35161: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35162: LD_ADDR_EXP 115
35166: PUSH
35167: EMPTY
35168: ST_TO_ADDR
// mc_need_heal := [ ] ;
35169: LD_ADDR_EXP 116
35173: PUSH
35174: EMPTY
35175: ST_TO_ADDR
// mc_healers := [ ] ;
35176: LD_ADDR_EXP 117
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_build_list := [ ] ;
35183: LD_ADDR_EXP 118
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35190: LD_ADDR_EXP 145
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_builders := [ ] ;
35197: LD_ADDR_EXP 119
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_construct_list := [ ] ;
35204: LD_ADDR_EXP 120
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_turret_list := [ ] ;
35211: LD_ADDR_EXP 121
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35218: LD_ADDR_EXP 122
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_miners := [ ] ;
35225: LD_ADDR_EXP 127
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_mines := [ ] ;
35232: LD_ADDR_EXP 126
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_minefields := [ ] ;
35239: LD_ADDR_EXP 128
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_crates := [ ] ;
35246: LD_ADDR_EXP 129
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35253: LD_ADDR_EXP 130
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_crates_area := [ ] ;
35260: LD_ADDR_EXP 131
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_vehicles := [ ] ;
35267: LD_ADDR_EXP 132
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_attack := [ ] ;
35274: LD_ADDR_EXP 133
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_produce := [ ] ;
35281: LD_ADDR_EXP 134
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_defender := [ ] ;
35288: LD_ADDR_EXP 135
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_parking := [ ] ;
35295: LD_ADDR_EXP 137
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35302: LD_ADDR_EXP 123
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35309: LD_ADDR_EXP 125
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_scan := [ ] ;
35316: LD_ADDR_EXP 136
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_scan_area := [ ] ;
35323: LD_ADDR_EXP 138
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_tech := [ ] ;
35330: LD_ADDR_EXP 140
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_class := [ ] ;
35337: LD_ADDR_EXP 154
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35344: LD_ADDR_EXP 155
35348: PUSH
35349: EMPTY
35350: ST_TO_ADDR
// end ;
35351: LD_VAR 0 1
35355: RET
// export function MC_Kill ( base ) ; begin
35356: LD_INT 0
35358: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35359: LD_ADDR_EXP 113
35363: PUSH
35364: LD_EXP 113
35368: PPUSH
35369: LD_VAR 0 1
35373: PPUSH
35374: EMPTY
35375: PPUSH
35376: CALL_OW 1
35380: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35381: LD_ADDR_EXP 114
35385: PUSH
35386: LD_EXP 114
35390: PPUSH
35391: LD_VAR 0 1
35395: PPUSH
35396: EMPTY
35397: PPUSH
35398: CALL_OW 1
35402: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35403: LD_ADDR_EXP 115
35407: PUSH
35408: LD_EXP 115
35412: PPUSH
35413: LD_VAR 0 1
35417: PPUSH
35418: EMPTY
35419: PPUSH
35420: CALL_OW 1
35424: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35425: LD_ADDR_EXP 116
35429: PUSH
35430: LD_EXP 116
35434: PPUSH
35435: LD_VAR 0 1
35439: PPUSH
35440: EMPTY
35441: PPUSH
35442: CALL_OW 1
35446: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35447: LD_ADDR_EXP 117
35451: PUSH
35452: LD_EXP 117
35456: PPUSH
35457: LD_VAR 0 1
35461: PPUSH
35462: EMPTY
35463: PPUSH
35464: CALL_OW 1
35468: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35469: LD_ADDR_EXP 118
35473: PUSH
35474: LD_EXP 118
35478: PPUSH
35479: LD_VAR 0 1
35483: PPUSH
35484: EMPTY
35485: PPUSH
35486: CALL_OW 1
35490: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35491: LD_ADDR_EXP 119
35495: PUSH
35496: LD_EXP 119
35500: PPUSH
35501: LD_VAR 0 1
35505: PPUSH
35506: EMPTY
35507: PPUSH
35508: CALL_OW 1
35512: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35513: LD_ADDR_EXP 120
35517: PUSH
35518: LD_EXP 120
35522: PPUSH
35523: LD_VAR 0 1
35527: PPUSH
35528: EMPTY
35529: PPUSH
35530: CALL_OW 1
35534: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35535: LD_ADDR_EXP 121
35539: PUSH
35540: LD_EXP 121
35544: PPUSH
35545: LD_VAR 0 1
35549: PPUSH
35550: EMPTY
35551: PPUSH
35552: CALL_OW 1
35556: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35557: LD_ADDR_EXP 122
35561: PUSH
35562: LD_EXP 122
35566: PPUSH
35567: LD_VAR 0 1
35571: PPUSH
35572: EMPTY
35573: PPUSH
35574: CALL_OW 1
35578: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35579: LD_ADDR_EXP 123
35583: PUSH
35584: LD_EXP 123
35588: PPUSH
35589: LD_VAR 0 1
35593: PPUSH
35594: EMPTY
35595: PPUSH
35596: CALL_OW 1
35600: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35601: LD_ADDR_EXP 124
35605: PUSH
35606: LD_EXP 124
35610: PPUSH
35611: LD_VAR 0 1
35615: PPUSH
35616: LD_INT 0
35618: PPUSH
35619: CALL_OW 1
35623: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35624: LD_ADDR_EXP 125
35628: PUSH
35629: LD_EXP 125
35633: PPUSH
35634: LD_VAR 0 1
35638: PPUSH
35639: EMPTY
35640: PPUSH
35641: CALL_OW 1
35645: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35646: LD_ADDR_EXP 126
35650: PUSH
35651: LD_EXP 126
35655: PPUSH
35656: LD_VAR 0 1
35660: PPUSH
35661: EMPTY
35662: PPUSH
35663: CALL_OW 1
35667: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35668: LD_ADDR_EXP 127
35672: PUSH
35673: LD_EXP 127
35677: PPUSH
35678: LD_VAR 0 1
35682: PPUSH
35683: EMPTY
35684: PPUSH
35685: CALL_OW 1
35689: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35690: LD_ADDR_EXP 128
35694: PUSH
35695: LD_EXP 128
35699: PPUSH
35700: LD_VAR 0 1
35704: PPUSH
35705: EMPTY
35706: PPUSH
35707: CALL_OW 1
35711: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35712: LD_ADDR_EXP 129
35716: PUSH
35717: LD_EXP 129
35721: PPUSH
35722: LD_VAR 0 1
35726: PPUSH
35727: EMPTY
35728: PPUSH
35729: CALL_OW 1
35733: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35734: LD_ADDR_EXP 130
35738: PUSH
35739: LD_EXP 130
35743: PPUSH
35744: LD_VAR 0 1
35748: PPUSH
35749: EMPTY
35750: PPUSH
35751: CALL_OW 1
35755: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35756: LD_ADDR_EXP 131
35760: PUSH
35761: LD_EXP 131
35765: PPUSH
35766: LD_VAR 0 1
35770: PPUSH
35771: EMPTY
35772: PPUSH
35773: CALL_OW 1
35777: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35778: LD_ADDR_EXP 132
35782: PUSH
35783: LD_EXP 132
35787: PPUSH
35788: LD_VAR 0 1
35792: PPUSH
35793: EMPTY
35794: PPUSH
35795: CALL_OW 1
35799: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35800: LD_ADDR_EXP 133
35804: PUSH
35805: LD_EXP 133
35809: PPUSH
35810: LD_VAR 0 1
35814: PPUSH
35815: EMPTY
35816: PPUSH
35817: CALL_OW 1
35821: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35822: LD_ADDR_EXP 134
35826: PUSH
35827: LD_EXP 134
35831: PPUSH
35832: LD_VAR 0 1
35836: PPUSH
35837: EMPTY
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35844: LD_ADDR_EXP 135
35848: PUSH
35849: LD_EXP 135
35853: PPUSH
35854: LD_VAR 0 1
35858: PPUSH
35859: EMPTY
35860: PPUSH
35861: CALL_OW 1
35865: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35866: LD_ADDR_EXP 136
35870: PUSH
35871: LD_EXP 136
35875: PPUSH
35876: LD_VAR 0 1
35880: PPUSH
35881: EMPTY
35882: PPUSH
35883: CALL_OW 1
35887: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35888: LD_ADDR_EXP 137
35892: PUSH
35893: LD_EXP 137
35897: PPUSH
35898: LD_VAR 0 1
35902: PPUSH
35903: EMPTY
35904: PPUSH
35905: CALL_OW 1
35909: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35910: LD_ADDR_EXP 138
35914: PUSH
35915: LD_EXP 138
35919: PPUSH
35920: LD_VAR 0 1
35924: PPUSH
35925: EMPTY
35926: PPUSH
35927: CALL_OW 1
35931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35932: LD_ADDR_EXP 140
35936: PUSH
35937: LD_EXP 140
35941: PPUSH
35942: LD_VAR 0 1
35946: PPUSH
35947: EMPTY
35948: PPUSH
35949: CALL_OW 1
35953: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35954: LD_ADDR_EXP 142
35958: PUSH
35959: LD_EXP 142
35963: PPUSH
35964: LD_VAR 0 1
35968: PPUSH
35969: EMPTY
35970: PPUSH
35971: CALL_OW 1
35975: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35976: LD_ADDR_EXP 143
35980: PUSH
35981: LD_EXP 143
35985: PPUSH
35986: LD_VAR 0 1
35990: PPUSH
35991: EMPTY
35992: PPUSH
35993: CALL_OW 1
35997: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35998: LD_ADDR_EXP 144
36002: PUSH
36003: LD_EXP 144
36007: PPUSH
36008: LD_VAR 0 1
36012: PPUSH
36013: EMPTY
36014: PPUSH
36015: CALL_OW 1
36019: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36020: LD_ADDR_EXP 145
36024: PUSH
36025: LD_EXP 145
36029: PPUSH
36030: LD_VAR 0 1
36034: PPUSH
36035: EMPTY
36036: PPUSH
36037: CALL_OW 1
36041: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36042: LD_ADDR_EXP 146
36046: PUSH
36047: LD_EXP 146
36051: PPUSH
36052: LD_VAR 0 1
36056: PPUSH
36057: EMPTY
36058: PPUSH
36059: CALL_OW 1
36063: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36064: LD_ADDR_EXP 147
36068: PUSH
36069: LD_EXP 147
36073: PPUSH
36074: LD_VAR 0 1
36078: PPUSH
36079: EMPTY
36080: PPUSH
36081: CALL_OW 1
36085: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36086: LD_ADDR_EXP 148
36090: PUSH
36091: LD_EXP 148
36095: PPUSH
36096: LD_VAR 0 1
36100: PPUSH
36101: EMPTY
36102: PPUSH
36103: CALL_OW 1
36107: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36108: LD_ADDR_EXP 149
36112: PUSH
36113: LD_EXP 149
36117: PPUSH
36118: LD_VAR 0 1
36122: PPUSH
36123: EMPTY
36124: PPUSH
36125: CALL_OW 1
36129: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36130: LD_ADDR_EXP 150
36134: PUSH
36135: LD_EXP 150
36139: PPUSH
36140: LD_VAR 0 1
36144: PPUSH
36145: EMPTY
36146: PPUSH
36147: CALL_OW 1
36151: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36152: LD_ADDR_EXP 151
36156: PUSH
36157: LD_EXP 151
36161: PPUSH
36162: LD_VAR 0 1
36166: PPUSH
36167: EMPTY
36168: PPUSH
36169: CALL_OW 1
36173: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36174: LD_ADDR_EXP 152
36178: PUSH
36179: LD_EXP 152
36183: PPUSH
36184: LD_VAR 0 1
36188: PPUSH
36189: EMPTY
36190: PPUSH
36191: CALL_OW 1
36195: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36196: LD_ADDR_EXP 153
36200: PUSH
36201: LD_EXP 153
36205: PPUSH
36206: LD_VAR 0 1
36210: PPUSH
36211: EMPTY
36212: PPUSH
36213: CALL_OW 1
36217: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36218: LD_ADDR_EXP 154
36222: PUSH
36223: LD_EXP 154
36227: PPUSH
36228: LD_VAR 0 1
36232: PPUSH
36233: EMPTY
36234: PPUSH
36235: CALL_OW 1
36239: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36240: LD_ADDR_EXP 155
36244: PUSH
36245: LD_EXP 155
36249: PPUSH
36250: LD_VAR 0 1
36254: PPUSH
36255: LD_INT 0
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// end ;
36263: LD_VAR 0 2
36267: RET
// export function MC_Add ( side , units ) ; var base ; begin
36268: LD_INT 0
36270: PPUSH
36271: PPUSH
// base := mc_bases + 1 ;
36272: LD_ADDR_VAR 0 4
36276: PUSH
36277: LD_EXP 113
36281: PUSH
36282: LD_INT 1
36284: PLUS
36285: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36286: LD_ADDR_EXP 139
36290: PUSH
36291: LD_EXP 139
36295: PPUSH
36296: LD_VAR 0 4
36300: PPUSH
36301: LD_VAR 0 1
36305: PPUSH
36306: CALL_OW 1
36310: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36311: LD_ADDR_EXP 113
36315: PUSH
36316: LD_EXP 113
36320: PPUSH
36321: LD_VAR 0 4
36325: PPUSH
36326: LD_VAR 0 2
36330: PPUSH
36331: CALL_OW 1
36335: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36336: LD_ADDR_EXP 114
36340: PUSH
36341: LD_EXP 114
36345: PPUSH
36346: LD_VAR 0 4
36350: PPUSH
36351: EMPTY
36352: PPUSH
36353: CALL_OW 1
36357: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36358: LD_ADDR_EXP 115
36362: PUSH
36363: LD_EXP 115
36367: PPUSH
36368: LD_VAR 0 4
36372: PPUSH
36373: EMPTY
36374: PPUSH
36375: CALL_OW 1
36379: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36380: LD_ADDR_EXP 116
36384: PUSH
36385: LD_EXP 116
36389: PPUSH
36390: LD_VAR 0 4
36394: PPUSH
36395: EMPTY
36396: PPUSH
36397: CALL_OW 1
36401: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36402: LD_ADDR_EXP 117
36406: PUSH
36407: LD_EXP 117
36411: PPUSH
36412: LD_VAR 0 4
36416: PPUSH
36417: EMPTY
36418: PPUSH
36419: CALL_OW 1
36423: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36424: LD_ADDR_EXP 118
36428: PUSH
36429: LD_EXP 118
36433: PPUSH
36434: LD_VAR 0 4
36438: PPUSH
36439: EMPTY
36440: PPUSH
36441: CALL_OW 1
36445: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36446: LD_ADDR_EXP 119
36450: PUSH
36451: LD_EXP 119
36455: PPUSH
36456: LD_VAR 0 4
36460: PPUSH
36461: EMPTY
36462: PPUSH
36463: CALL_OW 1
36467: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36468: LD_ADDR_EXP 120
36472: PUSH
36473: LD_EXP 120
36477: PPUSH
36478: LD_VAR 0 4
36482: PPUSH
36483: EMPTY
36484: PPUSH
36485: CALL_OW 1
36489: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36490: LD_ADDR_EXP 121
36494: PUSH
36495: LD_EXP 121
36499: PPUSH
36500: LD_VAR 0 4
36504: PPUSH
36505: EMPTY
36506: PPUSH
36507: CALL_OW 1
36511: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36512: LD_ADDR_EXP 122
36516: PUSH
36517: LD_EXP 122
36521: PPUSH
36522: LD_VAR 0 4
36526: PPUSH
36527: EMPTY
36528: PPUSH
36529: CALL_OW 1
36533: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36534: LD_ADDR_EXP 123
36538: PUSH
36539: LD_EXP 123
36543: PPUSH
36544: LD_VAR 0 4
36548: PPUSH
36549: EMPTY
36550: PPUSH
36551: CALL_OW 1
36555: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36556: LD_ADDR_EXP 124
36560: PUSH
36561: LD_EXP 124
36565: PPUSH
36566: LD_VAR 0 4
36570: PPUSH
36571: LD_INT 0
36573: PPUSH
36574: CALL_OW 1
36578: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36579: LD_ADDR_EXP 125
36583: PUSH
36584: LD_EXP 125
36588: PPUSH
36589: LD_VAR 0 4
36593: PPUSH
36594: EMPTY
36595: PPUSH
36596: CALL_OW 1
36600: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36601: LD_ADDR_EXP 126
36605: PUSH
36606: LD_EXP 126
36610: PPUSH
36611: LD_VAR 0 4
36615: PPUSH
36616: EMPTY
36617: PPUSH
36618: CALL_OW 1
36622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36623: LD_ADDR_EXP 127
36627: PUSH
36628: LD_EXP 127
36632: PPUSH
36633: LD_VAR 0 4
36637: PPUSH
36638: EMPTY
36639: PPUSH
36640: CALL_OW 1
36644: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36645: LD_ADDR_EXP 128
36649: PUSH
36650: LD_EXP 128
36654: PPUSH
36655: LD_VAR 0 4
36659: PPUSH
36660: EMPTY
36661: PPUSH
36662: CALL_OW 1
36666: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36667: LD_ADDR_EXP 129
36671: PUSH
36672: LD_EXP 129
36676: PPUSH
36677: LD_VAR 0 4
36681: PPUSH
36682: EMPTY
36683: PPUSH
36684: CALL_OW 1
36688: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36689: LD_ADDR_EXP 130
36693: PUSH
36694: LD_EXP 130
36698: PPUSH
36699: LD_VAR 0 4
36703: PPUSH
36704: EMPTY
36705: PPUSH
36706: CALL_OW 1
36710: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36711: LD_ADDR_EXP 131
36715: PUSH
36716: LD_EXP 131
36720: PPUSH
36721: LD_VAR 0 4
36725: PPUSH
36726: EMPTY
36727: PPUSH
36728: CALL_OW 1
36732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36733: LD_ADDR_EXP 132
36737: PUSH
36738: LD_EXP 132
36742: PPUSH
36743: LD_VAR 0 4
36747: PPUSH
36748: EMPTY
36749: PPUSH
36750: CALL_OW 1
36754: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36755: LD_ADDR_EXP 133
36759: PUSH
36760: LD_EXP 133
36764: PPUSH
36765: LD_VAR 0 4
36769: PPUSH
36770: EMPTY
36771: PPUSH
36772: CALL_OW 1
36776: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36777: LD_ADDR_EXP 134
36781: PUSH
36782: LD_EXP 134
36786: PPUSH
36787: LD_VAR 0 4
36791: PPUSH
36792: EMPTY
36793: PPUSH
36794: CALL_OW 1
36798: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36799: LD_ADDR_EXP 135
36803: PUSH
36804: LD_EXP 135
36808: PPUSH
36809: LD_VAR 0 4
36813: PPUSH
36814: EMPTY
36815: PPUSH
36816: CALL_OW 1
36820: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36821: LD_ADDR_EXP 136
36825: PUSH
36826: LD_EXP 136
36830: PPUSH
36831: LD_VAR 0 4
36835: PPUSH
36836: EMPTY
36837: PPUSH
36838: CALL_OW 1
36842: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36843: LD_ADDR_EXP 137
36847: PUSH
36848: LD_EXP 137
36852: PPUSH
36853: LD_VAR 0 4
36857: PPUSH
36858: EMPTY
36859: PPUSH
36860: CALL_OW 1
36864: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36865: LD_ADDR_EXP 138
36869: PUSH
36870: LD_EXP 138
36874: PPUSH
36875: LD_VAR 0 4
36879: PPUSH
36880: EMPTY
36881: PPUSH
36882: CALL_OW 1
36886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36887: LD_ADDR_EXP 140
36891: PUSH
36892: LD_EXP 140
36896: PPUSH
36897: LD_VAR 0 4
36901: PPUSH
36902: EMPTY
36903: PPUSH
36904: CALL_OW 1
36908: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36909: LD_ADDR_EXP 142
36913: PUSH
36914: LD_EXP 142
36918: PPUSH
36919: LD_VAR 0 4
36923: PPUSH
36924: EMPTY
36925: PPUSH
36926: CALL_OW 1
36930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36931: LD_ADDR_EXP 143
36935: PUSH
36936: LD_EXP 143
36940: PPUSH
36941: LD_VAR 0 4
36945: PPUSH
36946: EMPTY
36947: PPUSH
36948: CALL_OW 1
36952: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36953: LD_ADDR_EXP 144
36957: PUSH
36958: LD_EXP 144
36962: PPUSH
36963: LD_VAR 0 4
36967: PPUSH
36968: EMPTY
36969: PPUSH
36970: CALL_OW 1
36974: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36975: LD_ADDR_EXP 145
36979: PUSH
36980: LD_EXP 145
36984: PPUSH
36985: LD_VAR 0 4
36989: PPUSH
36990: EMPTY
36991: PPUSH
36992: CALL_OW 1
36996: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36997: LD_ADDR_EXP 146
37001: PUSH
37002: LD_EXP 146
37006: PPUSH
37007: LD_VAR 0 4
37011: PPUSH
37012: EMPTY
37013: PPUSH
37014: CALL_OW 1
37018: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37019: LD_ADDR_EXP 147
37023: PUSH
37024: LD_EXP 147
37028: PPUSH
37029: LD_VAR 0 4
37033: PPUSH
37034: EMPTY
37035: PPUSH
37036: CALL_OW 1
37040: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37041: LD_ADDR_EXP 148
37045: PUSH
37046: LD_EXP 148
37050: PPUSH
37051: LD_VAR 0 4
37055: PPUSH
37056: EMPTY
37057: PPUSH
37058: CALL_OW 1
37062: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37063: LD_ADDR_EXP 149
37067: PUSH
37068: LD_EXP 149
37072: PPUSH
37073: LD_VAR 0 4
37077: PPUSH
37078: EMPTY
37079: PPUSH
37080: CALL_OW 1
37084: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37085: LD_ADDR_EXP 150
37089: PUSH
37090: LD_EXP 150
37094: PPUSH
37095: LD_VAR 0 4
37099: PPUSH
37100: EMPTY
37101: PPUSH
37102: CALL_OW 1
37106: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37107: LD_ADDR_EXP 151
37111: PUSH
37112: LD_EXP 151
37116: PPUSH
37117: LD_VAR 0 4
37121: PPUSH
37122: EMPTY
37123: PPUSH
37124: CALL_OW 1
37128: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37129: LD_ADDR_EXP 152
37133: PUSH
37134: LD_EXP 152
37138: PPUSH
37139: LD_VAR 0 4
37143: PPUSH
37144: EMPTY
37145: PPUSH
37146: CALL_OW 1
37150: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37151: LD_ADDR_EXP 153
37155: PUSH
37156: LD_EXP 153
37160: PPUSH
37161: LD_VAR 0 4
37165: PPUSH
37166: EMPTY
37167: PPUSH
37168: CALL_OW 1
37172: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37173: LD_ADDR_EXP 154
37177: PUSH
37178: LD_EXP 154
37182: PPUSH
37183: LD_VAR 0 4
37187: PPUSH
37188: EMPTY
37189: PPUSH
37190: CALL_OW 1
37194: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37195: LD_ADDR_EXP 155
37199: PUSH
37200: LD_EXP 155
37204: PPUSH
37205: LD_VAR 0 4
37209: PPUSH
37210: LD_INT 0
37212: PPUSH
37213: CALL_OW 1
37217: ST_TO_ADDR
// result := base ;
37218: LD_ADDR_VAR 0 3
37222: PUSH
37223: LD_VAR 0 4
37227: ST_TO_ADDR
// end ;
37228: LD_VAR 0 3
37232: RET
// export function MC_Start ( ) ; var i ; begin
37233: LD_INT 0
37235: PPUSH
37236: PPUSH
// for i = 1 to mc_bases do
37237: LD_ADDR_VAR 0 2
37241: PUSH
37242: DOUBLE
37243: LD_INT 1
37245: DEC
37246: ST_TO_ADDR
37247: LD_EXP 113
37251: PUSH
37252: FOR_TO
37253: IFFALSE 38330
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37255: LD_ADDR_EXP 113
37259: PUSH
37260: LD_EXP 113
37264: PPUSH
37265: LD_VAR 0 2
37269: PPUSH
37270: LD_EXP 113
37274: PUSH
37275: LD_VAR 0 2
37279: ARRAY
37280: PUSH
37281: LD_INT 0
37283: DIFF
37284: PPUSH
37285: CALL_OW 1
37289: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37290: LD_ADDR_EXP 114
37294: PUSH
37295: LD_EXP 114
37299: PPUSH
37300: LD_VAR 0 2
37304: PPUSH
37305: EMPTY
37306: PPUSH
37307: CALL_OW 1
37311: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37312: LD_ADDR_EXP 115
37316: PUSH
37317: LD_EXP 115
37321: PPUSH
37322: LD_VAR 0 2
37326: PPUSH
37327: EMPTY
37328: PPUSH
37329: CALL_OW 1
37333: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37334: LD_ADDR_EXP 116
37338: PUSH
37339: LD_EXP 116
37343: PPUSH
37344: LD_VAR 0 2
37348: PPUSH
37349: EMPTY
37350: PPUSH
37351: CALL_OW 1
37355: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37356: LD_ADDR_EXP 117
37360: PUSH
37361: LD_EXP 117
37365: PPUSH
37366: LD_VAR 0 2
37370: PPUSH
37371: EMPTY
37372: PUSH
37373: EMPTY
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PPUSH
37379: CALL_OW 1
37383: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37384: LD_ADDR_EXP 118
37388: PUSH
37389: LD_EXP 118
37393: PPUSH
37394: LD_VAR 0 2
37398: PPUSH
37399: EMPTY
37400: PPUSH
37401: CALL_OW 1
37405: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37406: LD_ADDR_EXP 145
37410: PUSH
37411: LD_EXP 145
37415: PPUSH
37416: LD_VAR 0 2
37420: PPUSH
37421: EMPTY
37422: PPUSH
37423: CALL_OW 1
37427: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37428: LD_ADDR_EXP 119
37432: PUSH
37433: LD_EXP 119
37437: PPUSH
37438: LD_VAR 0 2
37442: PPUSH
37443: EMPTY
37444: PPUSH
37445: CALL_OW 1
37449: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37450: LD_ADDR_EXP 120
37454: PUSH
37455: LD_EXP 120
37459: PPUSH
37460: LD_VAR 0 2
37464: PPUSH
37465: EMPTY
37466: PPUSH
37467: CALL_OW 1
37471: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37472: LD_ADDR_EXP 121
37476: PUSH
37477: LD_EXP 121
37481: PPUSH
37482: LD_VAR 0 2
37486: PPUSH
37487: LD_EXP 113
37491: PUSH
37492: LD_VAR 0 2
37496: ARRAY
37497: PPUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 30
37503: PUSH
37504: LD_INT 32
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 30
37513: PUSH
37514: LD_INT 33
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: LIST
37525: PPUSH
37526: CALL_OW 72
37530: PPUSH
37531: CALL_OW 1
37535: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37536: LD_ADDR_EXP 122
37540: PUSH
37541: LD_EXP 122
37545: PPUSH
37546: LD_VAR 0 2
37550: PPUSH
37551: LD_EXP 113
37555: PUSH
37556: LD_VAR 0 2
37560: ARRAY
37561: PPUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 30
37567: PUSH
37568: LD_INT 32
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 30
37577: PUSH
37578: LD_INT 31
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 58
37592: PUSH
37593: EMPTY
37594: LIST
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PPUSH
37600: CALL_OW 72
37604: PPUSH
37605: CALL_OW 1
37609: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37610: LD_ADDR_EXP 123
37614: PUSH
37615: LD_EXP 123
37619: PPUSH
37620: LD_VAR 0 2
37624: PPUSH
37625: EMPTY
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37632: LD_ADDR_EXP 127
37636: PUSH
37637: LD_EXP 127
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37654: LD_ADDR_EXP 126
37658: PUSH
37659: LD_EXP 126
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL_OW 1
37675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37676: LD_ADDR_EXP 128
37680: PUSH
37681: LD_EXP 128
37685: PPUSH
37686: LD_VAR 0 2
37690: PPUSH
37691: EMPTY
37692: PPUSH
37693: CALL_OW 1
37697: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37698: LD_ADDR_EXP 129
37702: PUSH
37703: LD_EXP 129
37707: PPUSH
37708: LD_VAR 0 2
37712: PPUSH
37713: EMPTY
37714: PPUSH
37715: CALL_OW 1
37719: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37720: LD_ADDR_EXP 130
37724: PUSH
37725: LD_EXP 130
37729: PPUSH
37730: LD_VAR 0 2
37734: PPUSH
37735: EMPTY
37736: PPUSH
37737: CALL_OW 1
37741: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37742: LD_ADDR_EXP 131
37746: PUSH
37747: LD_EXP 131
37751: PPUSH
37752: LD_VAR 0 2
37756: PPUSH
37757: EMPTY
37758: PPUSH
37759: CALL_OW 1
37763: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37764: LD_ADDR_EXP 132
37768: PUSH
37769: LD_EXP 132
37773: PPUSH
37774: LD_VAR 0 2
37778: PPUSH
37779: EMPTY
37780: PPUSH
37781: CALL_OW 1
37785: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37786: LD_ADDR_EXP 133
37790: PUSH
37791: LD_EXP 133
37795: PPUSH
37796: LD_VAR 0 2
37800: PPUSH
37801: EMPTY
37802: PPUSH
37803: CALL_OW 1
37807: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37808: LD_ADDR_EXP 134
37812: PUSH
37813: LD_EXP 134
37817: PPUSH
37818: LD_VAR 0 2
37822: PPUSH
37823: EMPTY
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37830: LD_ADDR_EXP 135
37834: PUSH
37835: LD_EXP 135
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37852: LD_ADDR_EXP 124
37856: PUSH
37857: LD_EXP 124
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: LD_INT 0
37869: PPUSH
37870: CALL_OW 1
37874: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37875: LD_ADDR_EXP 137
37879: PUSH
37880: LD_EXP 137
37884: PPUSH
37885: LD_VAR 0 2
37889: PPUSH
37890: LD_INT 0
37892: PPUSH
37893: CALL_OW 1
37897: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37898: LD_ADDR_EXP 125
37902: PUSH
37903: LD_EXP 125
37907: PPUSH
37908: LD_VAR 0 2
37912: PPUSH
37913: EMPTY
37914: PPUSH
37915: CALL_OW 1
37919: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37920: LD_ADDR_EXP 136
37924: PUSH
37925: LD_EXP 136
37929: PPUSH
37930: LD_VAR 0 2
37934: PPUSH
37935: LD_INT 0
37937: PPUSH
37938: CALL_OW 1
37942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37943: LD_ADDR_EXP 138
37947: PUSH
37948: LD_EXP 138
37952: PPUSH
37953: LD_VAR 0 2
37957: PPUSH
37958: EMPTY
37959: PPUSH
37960: CALL_OW 1
37964: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37965: LD_ADDR_EXP 141
37969: PUSH
37970: LD_EXP 141
37974: PPUSH
37975: LD_VAR 0 2
37979: PPUSH
37980: LD_INT 0
37982: PPUSH
37983: CALL_OW 1
37987: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37988: LD_ADDR_EXP 142
37992: PUSH
37993: LD_EXP 142
37997: PPUSH
37998: LD_VAR 0 2
38002: PPUSH
38003: EMPTY
38004: PPUSH
38005: CALL_OW 1
38009: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38010: LD_ADDR_EXP 143
38014: PUSH
38015: LD_EXP 143
38019: PPUSH
38020: LD_VAR 0 2
38024: PPUSH
38025: EMPTY
38026: PPUSH
38027: CALL_OW 1
38031: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38032: LD_ADDR_EXP 144
38036: PUSH
38037: LD_EXP 144
38041: PPUSH
38042: LD_VAR 0 2
38046: PPUSH
38047: EMPTY
38048: PPUSH
38049: CALL_OW 1
38053: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38054: LD_ADDR_EXP 146
38058: PUSH
38059: LD_EXP 146
38063: PPUSH
38064: LD_VAR 0 2
38068: PPUSH
38069: LD_EXP 113
38073: PUSH
38074: LD_VAR 0 2
38078: ARRAY
38079: PPUSH
38080: LD_INT 2
38082: PUSH
38083: LD_INT 30
38085: PUSH
38086: LD_INT 6
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 30
38095: PUSH
38096: LD_INT 7
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 30
38105: PUSH
38106: LD_INT 8
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: PPUSH
38119: CALL_OW 72
38123: PPUSH
38124: CALL_OW 1
38128: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38129: LD_ADDR_EXP 147
38133: PUSH
38134: LD_EXP 147
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: EMPTY
38145: PPUSH
38146: CALL_OW 1
38150: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38151: LD_ADDR_EXP 148
38155: PUSH
38156: LD_EXP 148
38160: PPUSH
38161: LD_VAR 0 2
38165: PPUSH
38166: EMPTY
38167: PPUSH
38168: CALL_OW 1
38172: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38173: LD_ADDR_EXP 149
38177: PUSH
38178: LD_EXP 149
38182: PPUSH
38183: LD_VAR 0 2
38187: PPUSH
38188: EMPTY
38189: PPUSH
38190: CALL_OW 1
38194: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38195: LD_ADDR_EXP 150
38199: PUSH
38200: LD_EXP 150
38204: PPUSH
38205: LD_VAR 0 2
38209: PPUSH
38210: EMPTY
38211: PPUSH
38212: CALL_OW 1
38216: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38217: LD_ADDR_EXP 151
38221: PUSH
38222: LD_EXP 151
38226: PPUSH
38227: LD_VAR 0 2
38231: PPUSH
38232: EMPTY
38233: PPUSH
38234: CALL_OW 1
38238: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38239: LD_ADDR_EXP 152
38243: PUSH
38244: LD_EXP 152
38248: PPUSH
38249: LD_VAR 0 2
38253: PPUSH
38254: EMPTY
38255: PPUSH
38256: CALL_OW 1
38260: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38261: LD_ADDR_EXP 153
38265: PUSH
38266: LD_EXP 153
38270: PPUSH
38271: LD_VAR 0 2
38275: PPUSH
38276: EMPTY
38277: PPUSH
38278: CALL_OW 1
38282: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38283: LD_ADDR_EXP 154
38287: PUSH
38288: LD_EXP 154
38292: PPUSH
38293: LD_VAR 0 2
38297: PPUSH
38298: EMPTY
38299: PPUSH
38300: CALL_OW 1
38304: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38305: LD_ADDR_EXP 155
38309: PUSH
38310: LD_EXP 155
38314: PPUSH
38315: LD_VAR 0 2
38319: PPUSH
38320: LD_INT 0
38322: PPUSH
38323: CALL_OW 1
38327: ST_TO_ADDR
// end ;
38328: GO 37252
38330: POP
38331: POP
// MC_InitSides ( ) ;
38332: CALL 38618 0 0
// MC_InitResearch ( ) ;
38336: CALL 38357 0 0
// CustomInitMacro ( ) ;
38340: CALL 471 0 0
// skirmish := true ;
38344: LD_ADDR_EXP 111
38348: PUSH
38349: LD_INT 1
38351: ST_TO_ADDR
// end ;
38352: LD_VAR 0 1
38356: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38357: LD_INT 0
38359: PPUSH
38360: PPUSH
38361: PPUSH
38362: PPUSH
38363: PPUSH
38364: PPUSH
// if not mc_bases then
38365: LD_EXP 113
38369: NOT
38370: IFFALSE 38374
// exit ;
38372: GO 38613
// for i = 1 to 8 do
38374: LD_ADDR_VAR 0 2
38378: PUSH
38379: DOUBLE
38380: LD_INT 1
38382: DEC
38383: ST_TO_ADDR
38384: LD_INT 8
38386: PUSH
38387: FOR_TO
38388: IFFALSE 38414
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38390: LD_ADDR_EXP 140
38394: PUSH
38395: LD_EXP 140
38399: PPUSH
38400: LD_VAR 0 2
38404: PPUSH
38405: EMPTY
38406: PPUSH
38407: CALL_OW 1
38411: ST_TO_ADDR
38412: GO 38387
38414: POP
38415: POP
// tmp := [ ] ;
38416: LD_ADDR_VAR 0 5
38420: PUSH
38421: EMPTY
38422: ST_TO_ADDR
// for i = 1 to mc_sides do
38423: LD_ADDR_VAR 0 2
38427: PUSH
38428: DOUBLE
38429: LD_INT 1
38431: DEC
38432: ST_TO_ADDR
38433: LD_EXP 139
38437: PUSH
38438: FOR_TO
38439: IFFALSE 38497
// if not mc_sides [ i ] in tmp then
38441: LD_EXP 139
38445: PUSH
38446: LD_VAR 0 2
38450: ARRAY
38451: PUSH
38452: LD_VAR 0 5
38456: IN
38457: NOT
38458: IFFALSE 38495
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38460: LD_ADDR_VAR 0 5
38464: PUSH
38465: LD_VAR 0 5
38469: PPUSH
38470: LD_VAR 0 5
38474: PUSH
38475: LD_INT 1
38477: PLUS
38478: PPUSH
38479: LD_EXP 139
38483: PUSH
38484: LD_VAR 0 2
38488: ARRAY
38489: PPUSH
38490: CALL_OW 2
38494: ST_TO_ADDR
38495: GO 38438
38497: POP
38498: POP
// if not tmp then
38499: LD_VAR 0 5
38503: NOT
38504: IFFALSE 38508
// exit ;
38506: GO 38613
// for j in tmp do
38508: LD_ADDR_VAR 0 3
38512: PUSH
38513: LD_VAR 0 5
38517: PUSH
38518: FOR_IN
38519: IFFALSE 38611
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38521: LD_ADDR_VAR 0 6
38525: PUSH
38526: LD_INT 22
38528: PUSH
38529: LD_VAR 0 3
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PPUSH
38538: CALL_OW 69
38542: ST_TO_ADDR
// if not un then
38543: LD_VAR 0 6
38547: NOT
38548: IFFALSE 38552
// continue ;
38550: GO 38518
// nation := GetNation ( un [ 1 ] ) ;
38552: LD_ADDR_VAR 0 4
38556: PUSH
38557: LD_VAR 0 6
38561: PUSH
38562: LD_INT 1
38564: ARRAY
38565: PPUSH
38566: CALL_OW 248
38570: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38571: LD_ADDR_EXP 140
38575: PUSH
38576: LD_EXP 140
38580: PPUSH
38581: LD_VAR 0 3
38585: PPUSH
38586: LD_VAR 0 3
38590: PPUSH
38591: LD_VAR 0 4
38595: PPUSH
38596: LD_INT 1
38598: PPUSH
38599: CALL 65267 0 3
38603: PPUSH
38604: CALL_OW 1
38608: ST_TO_ADDR
// end ;
38609: GO 38518
38611: POP
38612: POP
// end ;
38613: LD_VAR 0 1
38617: RET
// export function MC_InitSides ( ) ; var i ; begin
38618: LD_INT 0
38620: PPUSH
38621: PPUSH
// if not mc_bases then
38622: LD_EXP 113
38626: NOT
38627: IFFALSE 38631
// exit ;
38629: GO 38705
// for i = 1 to mc_bases do
38631: LD_ADDR_VAR 0 2
38635: PUSH
38636: DOUBLE
38637: LD_INT 1
38639: DEC
38640: ST_TO_ADDR
38641: LD_EXP 113
38645: PUSH
38646: FOR_TO
38647: IFFALSE 38703
// if mc_bases [ i ] then
38649: LD_EXP 113
38653: PUSH
38654: LD_VAR 0 2
38658: ARRAY
38659: IFFALSE 38701
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38661: LD_ADDR_EXP 139
38665: PUSH
38666: LD_EXP 139
38670: PPUSH
38671: LD_VAR 0 2
38675: PPUSH
38676: LD_EXP 113
38680: PUSH
38681: LD_VAR 0 2
38685: ARRAY
38686: PUSH
38687: LD_INT 1
38689: ARRAY
38690: PPUSH
38691: CALL_OW 255
38695: PPUSH
38696: CALL_OW 1
38700: ST_TO_ADDR
38701: GO 38646
38703: POP
38704: POP
// end ;
38705: LD_VAR 0 1
38709: RET
// every 0 0$01 trigger skirmish do
38710: LD_EXP 111
38714: IFFALSE 38868
38716: GO 38718
38718: DISABLE
// begin enable ;
38719: ENABLE
// MC_CheckBuildings ( ) ;
38720: CALL 43366 0 0
// MC_CheckPeopleLife ( ) ;
38724: CALL 43491 0 0
// RaiseSailEvent ( 100 ) ;
38728: LD_INT 100
38730: PPUSH
38731: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38735: LD_INT 103
38737: PPUSH
38738: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38742: LD_INT 104
38744: PPUSH
38745: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38749: LD_INT 105
38751: PPUSH
38752: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38756: LD_INT 106
38758: PPUSH
38759: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38763: LD_INT 107
38765: PPUSH
38766: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38770: LD_INT 108
38772: PPUSH
38773: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38777: LD_INT 109
38779: PPUSH
38780: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38784: LD_INT 110
38786: PPUSH
38787: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38791: LD_INT 111
38793: PPUSH
38794: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38798: LD_INT 112
38800: PPUSH
38801: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38805: LD_INT 113
38807: PPUSH
38808: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38812: LD_INT 120
38814: PPUSH
38815: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38819: LD_INT 121
38821: PPUSH
38822: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38826: LD_INT 122
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38833: LD_INT 123
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38840: LD_INT 124
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38847: LD_INT 125
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38854: LD_INT 126
38856: PPUSH
38857: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38861: LD_INT 200
38863: PPUSH
38864: CALL_OW 427
// end ;
38868: END
// on SailEvent ( event ) do begin if event < 100 then
38869: LD_VAR 0 1
38873: PUSH
38874: LD_INT 100
38876: LESS
38877: IFFALSE 38888
// CustomEvent ( event ) ;
38879: LD_VAR 0 1
38883: PPUSH
38884: CALL 33435 0 1
// if event = 100 then
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 100
38895: EQUAL
38896: IFFALSE 38902
// MC_ClassManager ( ) ;
38898: CALL 39294 0 0
// if event = 101 then
38902: LD_VAR 0 1
38906: PUSH
38907: LD_INT 101
38909: EQUAL
38910: IFFALSE 38916
// MC_RepairBuildings ( ) ;
38912: CALL 44076 0 0
// if event = 102 then
38916: LD_VAR 0 1
38920: PUSH
38921: LD_INT 102
38923: EQUAL
38924: IFFALSE 38930
// MC_Heal ( ) ;
38926: CALL 44961 0 0
// if event = 103 then
38930: LD_VAR 0 1
38934: PUSH
38935: LD_INT 103
38937: EQUAL
38938: IFFALSE 38944
// MC_Build ( ) ;
38940: CALL 45383 0 0
// if event = 104 then
38944: LD_VAR 0 1
38948: PUSH
38949: LD_INT 104
38951: EQUAL
38952: IFFALSE 38958
// MC_TurretWeapon ( ) ;
38954: CALL 46996 0 0
// if event = 105 then
38958: LD_VAR 0 1
38962: PUSH
38963: LD_INT 105
38965: EQUAL
38966: IFFALSE 38972
// MC_BuildUpgrade ( ) ;
38968: CALL 46547 0 0
// if event = 106 then
38972: LD_VAR 0 1
38976: PUSH
38977: LD_INT 106
38979: EQUAL
38980: IFFALSE 38986
// MC_PlantMines ( ) ;
38982: CALL 47426 0 0
// if event = 107 then
38986: LD_VAR 0 1
38990: PUSH
38991: LD_INT 107
38993: EQUAL
38994: IFFALSE 39000
// MC_CollectCrates ( ) ;
38996: CALL 48217 0 0
// if event = 108 then
39000: LD_VAR 0 1
39004: PUSH
39005: LD_INT 108
39007: EQUAL
39008: IFFALSE 39014
// MC_LinkRemoteControl ( ) ;
39010: CALL 49993 0 0
// if event = 109 then
39014: LD_VAR 0 1
39018: PUSH
39019: LD_INT 109
39021: EQUAL
39022: IFFALSE 39028
// MC_ProduceVehicle ( ) ;
39024: CALL 50174 0 0
// if event = 110 then
39028: LD_VAR 0 1
39032: PUSH
39033: LD_INT 110
39035: EQUAL
39036: IFFALSE 39042
// MC_SendAttack ( ) ;
39038: CALL 50640 0 0
// if event = 111 then
39042: LD_VAR 0 1
39046: PUSH
39047: LD_INT 111
39049: EQUAL
39050: IFFALSE 39056
// MC_Defend ( ) ;
39052: CALL 50748 0 0
// if event = 112 then
39056: LD_VAR 0 1
39060: PUSH
39061: LD_INT 112
39063: EQUAL
39064: IFFALSE 39070
// MC_Research ( ) ;
39066: CALL 51375 0 0
// if event = 113 then
39070: LD_VAR 0 1
39074: PUSH
39075: LD_INT 113
39077: EQUAL
39078: IFFALSE 39084
// MC_MinesTrigger ( ) ;
39080: CALL 52489 0 0
// if event = 120 then
39084: LD_VAR 0 1
39088: PUSH
39089: LD_INT 120
39091: EQUAL
39092: IFFALSE 39098
// MC_RepairVehicle ( ) ;
39094: CALL 52588 0 0
// if event = 121 then
39098: LD_VAR 0 1
39102: PUSH
39103: LD_INT 121
39105: EQUAL
39106: IFFALSE 39112
// MC_TameApe ( ) ;
39108: CALL 53318 0 0
// if event = 122 then
39112: LD_VAR 0 1
39116: PUSH
39117: LD_INT 122
39119: EQUAL
39120: IFFALSE 39126
// MC_ChangeApeClass ( ) ;
39122: CALL 54147 0 0
// if event = 123 then
39126: LD_VAR 0 1
39130: PUSH
39131: LD_INT 123
39133: EQUAL
39134: IFFALSE 39140
// MC_Bazooka ( ) ;
39136: CALL 54797 0 0
// if event = 124 then
39140: LD_VAR 0 1
39144: PUSH
39145: LD_INT 124
39147: EQUAL
39148: IFFALSE 39154
// MC_TeleportExit ( ) ;
39150: CALL 54995 0 0
// if event = 125 then
39154: LD_VAR 0 1
39158: PUSH
39159: LD_INT 125
39161: EQUAL
39162: IFFALSE 39168
// MC_Deposits ( ) ;
39164: CALL 55642 0 0
// if event = 126 then
39168: LD_VAR 0 1
39172: PUSH
39173: LD_INT 126
39175: EQUAL
39176: IFFALSE 39182
// MC_RemoteDriver ( ) ;
39178: CALL 56267 0 0
// if event = 200 then
39182: LD_VAR 0 1
39186: PUSH
39187: LD_INT 200
39189: EQUAL
39190: IFFALSE 39196
// MC_Idle ( ) ;
39192: CALL 58216 0 0
// end ;
39196: PPOPN 1
39198: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39199: LD_INT 0
39201: PPUSH
39202: PPUSH
// if not mc_bases [ base ] or not tag then
39203: LD_EXP 113
39207: PUSH
39208: LD_VAR 0 1
39212: ARRAY
39213: NOT
39214: PUSH
39215: LD_VAR 0 2
39219: NOT
39220: OR
39221: IFFALSE 39225
// exit ;
39223: GO 39289
// for i in mc_bases [ base ] union mc_ape [ base ] do
39225: LD_ADDR_VAR 0 4
39229: PUSH
39230: LD_EXP 113
39234: PUSH
39235: LD_VAR 0 1
39239: ARRAY
39240: PUSH
39241: LD_EXP 142
39245: PUSH
39246: LD_VAR 0 1
39250: ARRAY
39251: UNION
39252: PUSH
39253: FOR_IN
39254: IFFALSE 39287
// if GetTag ( i ) = tag then
39256: LD_VAR 0 4
39260: PPUSH
39261: CALL_OW 110
39265: PUSH
39266: LD_VAR 0 2
39270: EQUAL
39271: IFFALSE 39285
// SetTag ( i , 0 ) ;
39273: LD_VAR 0 4
39277: PPUSH
39278: LD_INT 0
39280: PPUSH
39281: CALL_OW 109
39285: GO 39253
39287: POP
39288: POP
// end ;
39289: LD_VAR 0 3
39293: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39294: LD_INT 0
39296: PPUSH
39297: PPUSH
39298: PPUSH
39299: PPUSH
39300: PPUSH
39301: PPUSH
39302: PPUSH
39303: PPUSH
// if not mc_bases then
39304: LD_EXP 113
39308: NOT
39309: IFFALSE 39313
// exit ;
39311: GO 39771
// for i = 1 to mc_bases do
39313: LD_ADDR_VAR 0 2
39317: PUSH
39318: DOUBLE
39319: LD_INT 1
39321: DEC
39322: ST_TO_ADDR
39323: LD_EXP 113
39327: PUSH
39328: FOR_TO
39329: IFFALSE 39769
// begin tmp := MC_ClassCheckReq ( i ) ;
39331: LD_ADDR_VAR 0 4
39335: PUSH
39336: LD_VAR 0 2
39340: PPUSH
39341: CALL 39776 0 1
39345: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39346: LD_ADDR_EXP 154
39350: PUSH
39351: LD_EXP 154
39355: PPUSH
39356: LD_VAR 0 2
39360: PPUSH
39361: LD_VAR 0 4
39365: PPUSH
39366: CALL_OW 1
39370: ST_TO_ADDR
// if not tmp then
39371: LD_VAR 0 4
39375: NOT
39376: IFFALSE 39380
// continue ;
39378: GO 39328
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39380: LD_ADDR_VAR 0 6
39384: PUSH
39385: LD_EXP 113
39389: PUSH
39390: LD_VAR 0 2
39394: ARRAY
39395: PPUSH
39396: LD_INT 2
39398: PUSH
39399: LD_INT 30
39401: PUSH
39402: LD_INT 4
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 30
39411: PUSH
39412: LD_INT 5
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: LIST
39423: PPUSH
39424: CALL_OW 72
39428: PUSH
39429: LD_EXP 113
39433: PUSH
39434: LD_VAR 0 2
39438: ARRAY
39439: PPUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 30
39445: PUSH
39446: LD_INT 0
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 30
39455: PUSH
39456: LD_INT 1
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: LIST
39467: PPUSH
39468: CALL_OW 72
39472: PUSH
39473: LD_EXP 113
39477: PUSH
39478: LD_VAR 0 2
39482: ARRAY
39483: PPUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 3
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PPUSH
39494: CALL_OW 72
39498: PUSH
39499: LD_EXP 113
39503: PUSH
39504: LD_VAR 0 2
39508: ARRAY
39509: PPUSH
39510: LD_INT 2
39512: PUSH
39513: LD_INT 30
39515: PUSH
39516: LD_INT 6
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 30
39525: PUSH
39526: LD_INT 7
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 30
39535: PUSH
39536: LD_INT 8
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: PPUSH
39549: CALL_OW 72
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: ST_TO_ADDR
// for j = 1 to 4 do
39560: LD_ADDR_VAR 0 3
39564: PUSH
39565: DOUBLE
39566: LD_INT 1
39568: DEC
39569: ST_TO_ADDR
39570: LD_INT 4
39572: PUSH
39573: FOR_TO
39574: IFFALSE 39765
// begin if not tmp [ j ] then
39576: LD_VAR 0 4
39580: PUSH
39581: LD_VAR 0 3
39585: ARRAY
39586: NOT
39587: IFFALSE 39591
// continue ;
39589: GO 39573
// for p in tmp [ j ] do
39591: LD_ADDR_VAR 0 5
39595: PUSH
39596: LD_VAR 0 4
39600: PUSH
39601: LD_VAR 0 3
39605: ARRAY
39606: PUSH
39607: FOR_IN
39608: IFFALSE 39761
// begin if not b [ j ] then
39610: LD_VAR 0 6
39614: PUSH
39615: LD_VAR 0 3
39619: ARRAY
39620: NOT
39621: IFFALSE 39625
// break ;
39623: GO 39761
// e := 0 ;
39625: LD_ADDR_VAR 0 7
39629: PUSH
39630: LD_INT 0
39632: ST_TO_ADDR
// for k in b [ j ] do
39633: LD_ADDR_VAR 0 8
39637: PUSH
39638: LD_VAR 0 6
39642: PUSH
39643: LD_VAR 0 3
39647: ARRAY
39648: PUSH
39649: FOR_IN
39650: IFFALSE 39677
// if IsNotFull ( k ) then
39652: LD_VAR 0 8
39656: PPUSH
39657: CALL 67416 0 1
39661: IFFALSE 39675
// begin e := k ;
39663: LD_ADDR_VAR 0 7
39667: PUSH
39668: LD_VAR 0 8
39672: ST_TO_ADDR
// break ;
39673: GO 39677
// end ;
39675: GO 39649
39677: POP
39678: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39679: LD_VAR 0 7
39683: PUSH
39684: LD_VAR 0 5
39688: PPUSH
39689: LD_VAR 0 7
39693: PPUSH
39694: CALL 99836 0 2
39698: NOT
39699: AND
39700: IFFALSE 39759
// begin if IsInUnit ( p ) then
39702: LD_VAR 0 5
39706: PPUSH
39707: CALL_OW 310
39711: IFFALSE 39722
// ComExitBuilding ( p ) ;
39713: LD_VAR 0 5
39717: PPUSH
39718: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39722: LD_VAR 0 5
39726: PPUSH
39727: LD_VAR 0 7
39731: PPUSH
39732: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39736: LD_VAR 0 5
39740: PPUSH
39741: LD_VAR 0 3
39745: PPUSH
39746: CALL_OW 183
// AddComExitBuilding ( p ) ;
39750: LD_VAR 0 5
39754: PPUSH
39755: CALL_OW 182
// end ; end ;
39759: GO 39607
39761: POP
39762: POP
// end ;
39763: GO 39573
39765: POP
39766: POP
// end ;
39767: GO 39328
39769: POP
39770: POP
// end ;
39771: LD_VAR 0 1
39775: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39776: LD_INT 0
39778: PPUSH
39779: PPUSH
39780: PPUSH
39781: PPUSH
39782: PPUSH
39783: PPUSH
39784: PPUSH
39785: PPUSH
39786: PPUSH
39787: PPUSH
39788: PPUSH
39789: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39790: LD_VAR 0 1
39794: NOT
39795: PUSH
39796: LD_EXP 113
39800: PUSH
39801: LD_VAR 0 1
39805: ARRAY
39806: NOT
39807: OR
39808: PUSH
39809: LD_EXP 113
39813: PUSH
39814: LD_VAR 0 1
39818: ARRAY
39819: PPUSH
39820: LD_INT 2
39822: PUSH
39823: LD_INT 30
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 30
39835: PUSH
39836: LD_INT 1
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: LIST
39847: PPUSH
39848: CALL_OW 72
39852: NOT
39853: OR
39854: IFFALSE 39858
// exit ;
39856: GO 43361
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39858: LD_ADDR_VAR 0 4
39862: PUSH
39863: LD_EXP 113
39867: PUSH
39868: LD_VAR 0 1
39872: ARRAY
39873: PPUSH
39874: LD_INT 2
39876: PUSH
39877: LD_INT 25
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 25
39889: PUSH
39890: LD_INT 2
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 25
39899: PUSH
39900: LD_INT 3
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 25
39909: PUSH
39910: LD_INT 4
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 25
39919: PUSH
39920: LD_INT 5
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 25
39929: PUSH
39930: LD_INT 8
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 25
39939: PUSH
39940: LD_INT 9
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: PPUSH
39957: CALL_OW 72
39961: ST_TO_ADDR
// if not tmp then
39962: LD_VAR 0 4
39966: NOT
39967: IFFALSE 39971
// exit ;
39969: GO 43361
// for i in tmp do
39971: LD_ADDR_VAR 0 3
39975: PUSH
39976: LD_VAR 0 4
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40013
// if GetTag ( i ) then
39984: LD_VAR 0 3
39988: PPUSH
39989: CALL_OW 110
39993: IFFALSE 40011
// tmp := tmp diff i ;
39995: LD_ADDR_VAR 0 4
39999: PUSH
40000: LD_VAR 0 4
40004: PUSH
40005: LD_VAR 0 3
40009: DIFF
40010: ST_TO_ADDR
40011: GO 39981
40013: POP
40014: POP
// if not tmp then
40015: LD_VAR 0 4
40019: NOT
40020: IFFALSE 40024
// exit ;
40022: GO 43361
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40024: LD_ADDR_VAR 0 5
40028: PUSH
40029: LD_EXP 113
40033: PUSH
40034: LD_VAR 0 1
40038: ARRAY
40039: PPUSH
40040: LD_INT 2
40042: PUSH
40043: LD_INT 25
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 25
40055: PUSH
40056: LD_INT 5
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 25
40065: PUSH
40066: LD_INT 8
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 25
40075: PUSH
40076: LD_INT 9
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: PPUSH
40090: CALL_OW 72
40094: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40095: LD_ADDR_VAR 0 6
40099: PUSH
40100: LD_EXP 113
40104: PUSH
40105: LD_VAR 0 1
40109: ARRAY
40110: PPUSH
40111: LD_INT 25
40113: PUSH
40114: LD_INT 2
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PPUSH
40121: CALL_OW 72
40125: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40126: LD_ADDR_VAR 0 7
40130: PUSH
40131: LD_EXP 113
40135: PUSH
40136: LD_VAR 0 1
40140: ARRAY
40141: PPUSH
40142: LD_INT 25
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PPUSH
40152: CALL_OW 72
40156: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40157: LD_ADDR_VAR 0 8
40161: PUSH
40162: LD_EXP 113
40166: PUSH
40167: LD_VAR 0 1
40171: ARRAY
40172: PPUSH
40173: LD_INT 25
40175: PUSH
40176: LD_INT 4
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 24
40185: PUSH
40186: LD_INT 251
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PPUSH
40197: CALL_OW 72
40201: ST_TO_ADDR
// if mc_scan [ base ] then
40202: LD_EXP 136
40206: PUSH
40207: LD_VAR 0 1
40211: ARRAY
40212: IFFALSE 40673
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40214: LD_ADDR_EXP 155
40218: PUSH
40219: LD_EXP 155
40223: PPUSH
40224: LD_VAR 0 1
40228: PPUSH
40229: LD_INT 4
40231: PPUSH
40232: CALL_OW 1
40236: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40237: LD_ADDR_VAR 0 12
40241: PUSH
40242: LD_EXP 113
40246: PUSH
40247: LD_VAR 0 1
40251: ARRAY
40252: PPUSH
40253: LD_INT 2
40255: PUSH
40256: LD_INT 30
40258: PUSH
40259: LD_INT 4
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 30
40268: PUSH
40269: LD_INT 5
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: LIST
40280: PPUSH
40281: CALL_OW 72
40285: ST_TO_ADDR
// if not b then
40286: LD_VAR 0 12
40290: NOT
40291: IFFALSE 40295
// exit ;
40293: GO 43361
// p := [ ] ;
40295: LD_ADDR_VAR 0 11
40299: PUSH
40300: EMPTY
40301: ST_TO_ADDR
// if sci >= 2 then
40302: LD_VAR 0 8
40306: PUSH
40307: LD_INT 2
40309: GREATEREQUAL
40310: IFFALSE 40341
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40312: LD_ADDR_VAR 0 8
40316: PUSH
40317: LD_VAR 0 8
40321: PUSH
40322: LD_INT 1
40324: ARRAY
40325: PUSH
40326: LD_VAR 0 8
40330: PUSH
40331: LD_INT 2
40333: ARRAY
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: ST_TO_ADDR
40339: GO 40402
// if sci = 1 then
40341: LD_VAR 0 8
40345: PUSH
40346: LD_INT 1
40348: EQUAL
40349: IFFALSE 40370
// sci := [ sci [ 1 ] ] else
40351: LD_ADDR_VAR 0 8
40355: PUSH
40356: LD_VAR 0 8
40360: PUSH
40361: LD_INT 1
40363: ARRAY
40364: PUSH
40365: EMPTY
40366: LIST
40367: ST_TO_ADDR
40368: GO 40402
// if sci = 0 then
40370: LD_VAR 0 8
40374: PUSH
40375: LD_INT 0
40377: EQUAL
40378: IFFALSE 40402
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40380: LD_ADDR_VAR 0 11
40384: PUSH
40385: LD_VAR 0 4
40389: PPUSH
40390: LD_INT 4
40392: PPUSH
40393: CALL 99699 0 2
40397: PUSH
40398: LD_INT 1
40400: ARRAY
40401: ST_TO_ADDR
// if eng > 4 then
40402: LD_VAR 0 6
40406: PUSH
40407: LD_INT 4
40409: GREATER
40410: IFFALSE 40456
// for i = eng downto 4 do
40412: LD_ADDR_VAR 0 3
40416: PUSH
40417: DOUBLE
40418: LD_VAR 0 6
40422: INC
40423: ST_TO_ADDR
40424: LD_INT 4
40426: PUSH
40427: FOR_DOWNTO
40428: IFFALSE 40454
// eng := eng diff eng [ i ] ;
40430: LD_ADDR_VAR 0 6
40434: PUSH
40435: LD_VAR 0 6
40439: PUSH
40440: LD_VAR 0 6
40444: PUSH
40445: LD_VAR 0 3
40449: ARRAY
40450: DIFF
40451: ST_TO_ADDR
40452: GO 40427
40454: POP
40455: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40456: LD_ADDR_VAR 0 4
40460: PUSH
40461: LD_VAR 0 4
40465: PUSH
40466: LD_VAR 0 5
40470: PUSH
40471: LD_VAR 0 6
40475: UNION
40476: PUSH
40477: LD_VAR 0 7
40481: UNION
40482: PUSH
40483: LD_VAR 0 8
40487: UNION
40488: DIFF
40489: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40490: LD_ADDR_VAR 0 13
40494: PUSH
40495: LD_EXP 113
40499: PUSH
40500: LD_VAR 0 1
40504: ARRAY
40505: PPUSH
40506: LD_INT 2
40508: PUSH
40509: LD_INT 30
40511: PUSH
40512: LD_INT 32
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 30
40521: PUSH
40522: LD_INT 31
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: LIST
40533: PPUSH
40534: CALL_OW 72
40538: PUSH
40539: LD_EXP 113
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: PPUSH
40550: LD_INT 2
40552: PUSH
40553: LD_INT 30
40555: PUSH
40556: LD_INT 4
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 30
40565: PUSH
40566: LD_INT 5
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: LIST
40577: PPUSH
40578: CALL_OW 72
40582: PUSH
40583: LD_INT 6
40585: MUL
40586: PLUS
40587: ST_TO_ADDR
// if bcount < tmp then
40588: LD_VAR 0 13
40592: PUSH
40593: LD_VAR 0 4
40597: LESS
40598: IFFALSE 40644
// for i = tmp downto bcount do
40600: LD_ADDR_VAR 0 3
40604: PUSH
40605: DOUBLE
40606: LD_VAR 0 4
40610: INC
40611: ST_TO_ADDR
40612: LD_VAR 0 13
40616: PUSH
40617: FOR_DOWNTO
40618: IFFALSE 40642
// tmp := Delete ( tmp , tmp ) ;
40620: LD_ADDR_VAR 0 4
40624: PUSH
40625: LD_VAR 0 4
40629: PPUSH
40630: LD_VAR 0 4
40634: PPUSH
40635: CALL_OW 3
40639: ST_TO_ADDR
40640: GO 40617
40642: POP
40643: POP
// result := [ tmp , 0 , 0 , p ] ;
40644: LD_ADDR_VAR 0 2
40648: PUSH
40649: LD_VAR 0 4
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: LD_INT 0
40659: PUSH
40660: LD_VAR 0 11
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: ST_TO_ADDR
// exit ;
40671: GO 43361
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40673: LD_EXP 113
40677: PUSH
40678: LD_VAR 0 1
40682: ARRAY
40683: PPUSH
40684: LD_INT 2
40686: PUSH
40687: LD_INT 30
40689: PUSH
40690: LD_INT 6
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 30
40699: PUSH
40700: LD_INT 7
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 30
40709: PUSH
40710: LD_INT 8
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: PPUSH
40723: CALL_OW 72
40727: NOT
40728: PUSH
40729: LD_EXP 113
40733: PUSH
40734: LD_VAR 0 1
40738: ARRAY
40739: PPUSH
40740: LD_INT 30
40742: PUSH
40743: LD_INT 3
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PPUSH
40750: CALL_OW 72
40754: NOT
40755: AND
40756: IFFALSE 40828
// begin if eng = tmp then
40758: LD_VAR 0 6
40762: PUSH
40763: LD_VAR 0 4
40767: EQUAL
40768: IFFALSE 40772
// exit ;
40770: GO 43361
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40772: LD_ADDR_EXP 155
40776: PUSH
40777: LD_EXP 155
40781: PPUSH
40782: LD_VAR 0 1
40786: PPUSH
40787: LD_INT 1
40789: PPUSH
40790: CALL_OW 1
40794: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40795: LD_ADDR_VAR 0 2
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: LD_VAR 0 4
40807: PUSH
40808: LD_VAR 0 6
40812: DIFF
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: LIST
40824: LIST
40825: ST_TO_ADDR
// exit ;
40826: GO 43361
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40828: LD_EXP 140
40832: PUSH
40833: LD_EXP 139
40837: PUSH
40838: LD_VAR 0 1
40842: ARRAY
40843: ARRAY
40844: PUSH
40845: LD_EXP 113
40849: PUSH
40850: LD_VAR 0 1
40854: ARRAY
40855: PPUSH
40856: LD_INT 2
40858: PUSH
40859: LD_INT 30
40861: PUSH
40862: LD_INT 6
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 30
40871: PUSH
40872: LD_INT 7
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 30
40881: PUSH
40882: LD_INT 8
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: PPUSH
40895: CALL_OW 72
40899: AND
40900: PUSH
40901: LD_EXP 113
40905: PUSH
40906: LD_VAR 0 1
40910: ARRAY
40911: PPUSH
40912: LD_INT 30
40914: PUSH
40915: LD_INT 3
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PPUSH
40922: CALL_OW 72
40926: NOT
40927: AND
40928: IFFALSE 41142
// begin if sci >= 6 then
40930: LD_VAR 0 8
40934: PUSH
40935: LD_INT 6
40937: GREATEREQUAL
40938: IFFALSE 40942
// exit ;
40940: GO 43361
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40942: LD_ADDR_EXP 155
40946: PUSH
40947: LD_EXP 155
40951: PPUSH
40952: LD_VAR 0 1
40956: PPUSH
40957: LD_INT 2
40959: PPUSH
40960: CALL_OW 1
40964: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40965: LD_ADDR_VAR 0 9
40969: PUSH
40970: LD_VAR 0 4
40974: PUSH
40975: LD_VAR 0 8
40979: DIFF
40980: PPUSH
40981: LD_INT 4
40983: PPUSH
40984: CALL 99699 0 2
40988: ST_TO_ADDR
// p := [ ] ;
40989: LD_ADDR_VAR 0 11
40993: PUSH
40994: EMPTY
40995: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40996: LD_VAR 0 8
41000: PUSH
41001: LD_INT 6
41003: LESS
41004: PUSH
41005: LD_VAR 0 9
41009: PUSH
41010: LD_INT 6
41012: GREATER
41013: AND
41014: IFFALSE 41095
// begin for i = 1 to 6 - sci do
41016: LD_ADDR_VAR 0 3
41020: PUSH
41021: DOUBLE
41022: LD_INT 1
41024: DEC
41025: ST_TO_ADDR
41026: LD_INT 6
41028: PUSH
41029: LD_VAR 0 8
41033: MINUS
41034: PUSH
41035: FOR_TO
41036: IFFALSE 41091
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41038: LD_ADDR_VAR 0 11
41042: PUSH
41043: LD_VAR 0 11
41047: PPUSH
41048: LD_VAR 0 11
41052: PUSH
41053: LD_INT 1
41055: PLUS
41056: PPUSH
41057: LD_VAR 0 9
41061: PUSH
41062: LD_INT 1
41064: ARRAY
41065: PPUSH
41066: CALL_OW 2
41070: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41071: LD_ADDR_VAR 0 9
41075: PUSH
41076: LD_VAR 0 9
41080: PPUSH
41081: LD_INT 1
41083: PPUSH
41084: CALL_OW 3
41088: ST_TO_ADDR
// end ;
41089: GO 41035
41091: POP
41092: POP
// end else
41093: GO 41115
// if sort then
41095: LD_VAR 0 9
41099: IFFALSE 41115
// p := sort [ 1 ] ;
41101: LD_ADDR_VAR 0 11
41105: PUSH
41106: LD_VAR 0 9
41110: PUSH
41111: LD_INT 1
41113: ARRAY
41114: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41115: LD_ADDR_VAR 0 2
41119: PUSH
41120: LD_INT 0
41122: PUSH
41123: LD_INT 0
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: LD_VAR 0 11
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: ST_TO_ADDR
// exit ;
41140: GO 43361
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41142: LD_EXP 140
41146: PUSH
41147: LD_EXP 139
41151: PUSH
41152: LD_VAR 0 1
41156: ARRAY
41157: ARRAY
41158: PUSH
41159: LD_EXP 113
41163: PUSH
41164: LD_VAR 0 1
41168: ARRAY
41169: PPUSH
41170: LD_INT 2
41172: PUSH
41173: LD_INT 30
41175: PUSH
41176: LD_INT 6
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 30
41185: PUSH
41186: LD_INT 7
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 30
41195: PUSH
41196: LD_INT 8
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL_OW 72
41213: AND
41214: PUSH
41215: LD_EXP 113
41219: PUSH
41220: LD_VAR 0 1
41224: ARRAY
41225: PPUSH
41226: LD_INT 30
41228: PUSH
41229: LD_INT 3
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PPUSH
41236: CALL_OW 72
41240: AND
41241: IFFALSE 41975
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41243: LD_ADDR_EXP 155
41247: PUSH
41248: LD_EXP 155
41252: PPUSH
41253: LD_VAR 0 1
41257: PPUSH
41258: LD_INT 3
41260: PPUSH
41261: CALL_OW 1
41265: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41266: LD_ADDR_VAR 0 2
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: LD_INT 0
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: ST_TO_ADDR
// if not eng then
41289: LD_VAR 0 6
41293: NOT
41294: IFFALSE 41357
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41296: LD_ADDR_VAR 0 11
41300: PUSH
41301: LD_VAR 0 4
41305: PPUSH
41306: LD_INT 2
41308: PPUSH
41309: CALL 99699 0 2
41313: PUSH
41314: LD_INT 1
41316: ARRAY
41317: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41318: LD_ADDR_VAR 0 2
41322: PUSH
41323: LD_VAR 0 2
41327: PPUSH
41328: LD_INT 2
41330: PPUSH
41331: LD_VAR 0 11
41335: PPUSH
41336: CALL_OW 1
41340: ST_TO_ADDR
// tmp := tmp diff p ;
41341: LD_ADDR_VAR 0 4
41345: PUSH
41346: LD_VAR 0 4
41350: PUSH
41351: LD_VAR 0 11
41355: DIFF
41356: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41357: LD_VAR 0 4
41361: PUSH
41362: LD_VAR 0 8
41366: PUSH
41367: LD_INT 6
41369: LESS
41370: AND
41371: IFFALSE 41559
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41373: LD_ADDR_VAR 0 9
41377: PUSH
41378: LD_VAR 0 4
41382: PUSH
41383: LD_VAR 0 8
41387: PUSH
41388: LD_VAR 0 7
41392: UNION
41393: DIFF
41394: PPUSH
41395: LD_INT 4
41397: PPUSH
41398: CALL 99699 0 2
41402: ST_TO_ADDR
// p := [ ] ;
41403: LD_ADDR_VAR 0 11
41407: PUSH
41408: EMPTY
41409: ST_TO_ADDR
// if sort then
41410: LD_VAR 0 9
41414: IFFALSE 41530
// for i = 1 to 6 - sci do
41416: LD_ADDR_VAR 0 3
41420: PUSH
41421: DOUBLE
41422: LD_INT 1
41424: DEC
41425: ST_TO_ADDR
41426: LD_INT 6
41428: PUSH
41429: LD_VAR 0 8
41433: MINUS
41434: PUSH
41435: FOR_TO
41436: IFFALSE 41528
// begin if i = sort then
41438: LD_VAR 0 3
41442: PUSH
41443: LD_VAR 0 9
41447: EQUAL
41448: IFFALSE 41452
// break ;
41450: GO 41528
// if GetClass ( i ) = 4 then
41452: LD_VAR 0 3
41456: PPUSH
41457: CALL_OW 257
41461: PUSH
41462: LD_INT 4
41464: EQUAL
41465: IFFALSE 41469
// continue ;
41467: GO 41435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41469: LD_ADDR_VAR 0 11
41473: PUSH
41474: LD_VAR 0 11
41478: PPUSH
41479: LD_VAR 0 11
41483: PUSH
41484: LD_INT 1
41486: PLUS
41487: PPUSH
41488: LD_VAR 0 9
41492: PUSH
41493: LD_VAR 0 3
41497: ARRAY
41498: PPUSH
41499: CALL_OW 2
41503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41504: LD_ADDR_VAR 0 4
41508: PUSH
41509: LD_VAR 0 4
41513: PUSH
41514: LD_VAR 0 9
41518: PUSH
41519: LD_VAR 0 3
41523: ARRAY
41524: DIFF
41525: ST_TO_ADDR
// end ;
41526: GO 41435
41528: POP
41529: POP
// if p then
41530: LD_VAR 0 11
41534: IFFALSE 41559
// result := Replace ( result , 4 , p ) ;
41536: LD_ADDR_VAR 0 2
41540: PUSH
41541: LD_VAR 0 2
41545: PPUSH
41546: LD_INT 4
41548: PPUSH
41549: LD_VAR 0 11
41553: PPUSH
41554: CALL_OW 1
41558: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41559: LD_VAR 0 4
41563: PUSH
41564: LD_VAR 0 7
41568: PUSH
41569: LD_INT 6
41571: LESS
41572: AND
41573: IFFALSE 41761
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41575: LD_ADDR_VAR 0 9
41579: PUSH
41580: LD_VAR 0 4
41584: PUSH
41585: LD_VAR 0 8
41589: PUSH
41590: LD_VAR 0 7
41594: UNION
41595: DIFF
41596: PPUSH
41597: LD_INT 3
41599: PPUSH
41600: CALL 99699 0 2
41604: ST_TO_ADDR
// p := [ ] ;
41605: LD_ADDR_VAR 0 11
41609: PUSH
41610: EMPTY
41611: ST_TO_ADDR
// if sort then
41612: LD_VAR 0 9
41616: IFFALSE 41732
// for i = 1 to 6 - mech do
41618: LD_ADDR_VAR 0 3
41622: PUSH
41623: DOUBLE
41624: LD_INT 1
41626: DEC
41627: ST_TO_ADDR
41628: LD_INT 6
41630: PUSH
41631: LD_VAR 0 7
41635: MINUS
41636: PUSH
41637: FOR_TO
41638: IFFALSE 41730
// begin if i = sort then
41640: LD_VAR 0 3
41644: PUSH
41645: LD_VAR 0 9
41649: EQUAL
41650: IFFALSE 41654
// break ;
41652: GO 41730
// if GetClass ( i ) = 3 then
41654: LD_VAR 0 3
41658: PPUSH
41659: CALL_OW 257
41663: PUSH
41664: LD_INT 3
41666: EQUAL
41667: IFFALSE 41671
// continue ;
41669: GO 41637
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41671: LD_ADDR_VAR 0 11
41675: PUSH
41676: LD_VAR 0 11
41680: PPUSH
41681: LD_VAR 0 11
41685: PUSH
41686: LD_INT 1
41688: PLUS
41689: PPUSH
41690: LD_VAR 0 9
41694: PUSH
41695: LD_VAR 0 3
41699: ARRAY
41700: PPUSH
41701: CALL_OW 2
41705: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41706: LD_ADDR_VAR 0 4
41710: PUSH
41711: LD_VAR 0 4
41715: PUSH
41716: LD_VAR 0 9
41720: PUSH
41721: LD_VAR 0 3
41725: ARRAY
41726: DIFF
41727: ST_TO_ADDR
// end ;
41728: GO 41637
41730: POP
41731: POP
// if p then
41732: LD_VAR 0 11
41736: IFFALSE 41761
// result := Replace ( result , 3 , p ) ;
41738: LD_ADDR_VAR 0 2
41742: PUSH
41743: LD_VAR 0 2
41747: PPUSH
41748: LD_INT 3
41750: PPUSH
41751: LD_VAR 0 11
41755: PPUSH
41756: CALL_OW 1
41760: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41761: LD_VAR 0 4
41765: PUSH
41766: LD_INT 6
41768: GREATER
41769: PUSH
41770: LD_VAR 0 6
41774: PUSH
41775: LD_INT 6
41777: LESS
41778: AND
41779: IFFALSE 41973
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41781: LD_ADDR_VAR 0 9
41785: PUSH
41786: LD_VAR 0 4
41790: PUSH
41791: LD_VAR 0 8
41795: PUSH
41796: LD_VAR 0 7
41800: UNION
41801: PUSH
41802: LD_VAR 0 6
41806: UNION
41807: DIFF
41808: PPUSH
41809: LD_INT 2
41811: PPUSH
41812: CALL 99699 0 2
41816: ST_TO_ADDR
// p := [ ] ;
41817: LD_ADDR_VAR 0 11
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// if sort then
41824: LD_VAR 0 9
41828: IFFALSE 41944
// for i = 1 to 6 - eng do
41830: LD_ADDR_VAR 0 3
41834: PUSH
41835: DOUBLE
41836: LD_INT 1
41838: DEC
41839: ST_TO_ADDR
41840: LD_INT 6
41842: PUSH
41843: LD_VAR 0 6
41847: MINUS
41848: PUSH
41849: FOR_TO
41850: IFFALSE 41942
// begin if i = sort then
41852: LD_VAR 0 3
41856: PUSH
41857: LD_VAR 0 9
41861: EQUAL
41862: IFFALSE 41866
// break ;
41864: GO 41942
// if GetClass ( i ) = 2 then
41866: LD_VAR 0 3
41870: PPUSH
41871: CALL_OW 257
41875: PUSH
41876: LD_INT 2
41878: EQUAL
41879: IFFALSE 41883
// continue ;
41881: GO 41849
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41883: LD_ADDR_VAR 0 11
41887: PUSH
41888: LD_VAR 0 11
41892: PPUSH
41893: LD_VAR 0 11
41897: PUSH
41898: LD_INT 1
41900: PLUS
41901: PPUSH
41902: LD_VAR 0 9
41906: PUSH
41907: LD_VAR 0 3
41911: ARRAY
41912: PPUSH
41913: CALL_OW 2
41917: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41918: LD_ADDR_VAR 0 4
41922: PUSH
41923: LD_VAR 0 4
41927: PUSH
41928: LD_VAR 0 9
41932: PUSH
41933: LD_VAR 0 3
41937: ARRAY
41938: DIFF
41939: ST_TO_ADDR
// end ;
41940: GO 41849
41942: POP
41943: POP
// if p then
41944: LD_VAR 0 11
41948: IFFALSE 41973
// result := Replace ( result , 2 , p ) ;
41950: LD_ADDR_VAR 0 2
41954: PUSH
41955: LD_VAR 0 2
41959: PPUSH
41960: LD_INT 2
41962: PPUSH
41963: LD_VAR 0 11
41967: PPUSH
41968: CALL_OW 1
41972: ST_TO_ADDR
// end ; exit ;
41973: GO 43361
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41975: LD_EXP 140
41979: PUSH
41980: LD_EXP 139
41984: PUSH
41985: LD_VAR 0 1
41989: ARRAY
41990: ARRAY
41991: NOT
41992: PUSH
41993: LD_EXP 113
41997: PUSH
41998: LD_VAR 0 1
42002: ARRAY
42003: PPUSH
42004: LD_INT 30
42006: PUSH
42007: LD_INT 3
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PPUSH
42014: CALL_OW 72
42018: AND
42019: PUSH
42020: LD_EXP 118
42024: PUSH
42025: LD_VAR 0 1
42029: ARRAY
42030: AND
42031: IFFALSE 42639
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42033: LD_ADDR_EXP 155
42037: PUSH
42038: LD_EXP 155
42042: PPUSH
42043: LD_VAR 0 1
42047: PPUSH
42048: LD_INT 5
42050: PPUSH
42051: CALL_OW 1
42055: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42056: LD_ADDR_VAR 0 2
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: LD_INT 0
42066: PUSH
42067: LD_INT 0
42069: PUSH
42070: LD_INT 0
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: ST_TO_ADDR
// if sci > 1 then
42079: LD_VAR 0 8
42083: PUSH
42084: LD_INT 1
42086: GREATER
42087: IFFALSE 42115
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42089: LD_ADDR_VAR 0 4
42093: PUSH
42094: LD_VAR 0 4
42098: PUSH
42099: LD_VAR 0 8
42103: PUSH
42104: LD_VAR 0 8
42108: PUSH
42109: LD_INT 1
42111: ARRAY
42112: DIFF
42113: DIFF
42114: ST_TO_ADDR
// if tmp and not sci then
42115: LD_VAR 0 4
42119: PUSH
42120: LD_VAR 0 8
42124: NOT
42125: AND
42126: IFFALSE 42195
// begin sort := SortBySkill ( tmp , 4 ) ;
42128: LD_ADDR_VAR 0 9
42132: PUSH
42133: LD_VAR 0 4
42137: PPUSH
42138: LD_INT 4
42140: PPUSH
42141: CALL 99699 0 2
42145: ST_TO_ADDR
// if sort then
42146: LD_VAR 0 9
42150: IFFALSE 42166
// p := sort [ 1 ] ;
42152: LD_ADDR_VAR 0 11
42156: PUSH
42157: LD_VAR 0 9
42161: PUSH
42162: LD_INT 1
42164: ARRAY
42165: ST_TO_ADDR
// if p then
42166: LD_VAR 0 11
42170: IFFALSE 42195
// result := Replace ( result , 4 , p ) ;
42172: LD_ADDR_VAR 0 2
42176: PUSH
42177: LD_VAR 0 2
42181: PPUSH
42182: LD_INT 4
42184: PPUSH
42185: LD_VAR 0 11
42189: PPUSH
42190: CALL_OW 1
42194: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42195: LD_ADDR_VAR 0 4
42199: PUSH
42200: LD_VAR 0 4
42204: PUSH
42205: LD_VAR 0 7
42209: DIFF
42210: ST_TO_ADDR
// if tmp and mech < 6 then
42211: LD_VAR 0 4
42215: PUSH
42216: LD_VAR 0 7
42220: PUSH
42221: LD_INT 6
42223: LESS
42224: AND
42225: IFFALSE 42413
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42227: LD_ADDR_VAR 0 9
42231: PUSH
42232: LD_VAR 0 4
42236: PUSH
42237: LD_VAR 0 8
42241: PUSH
42242: LD_VAR 0 7
42246: UNION
42247: DIFF
42248: PPUSH
42249: LD_INT 3
42251: PPUSH
42252: CALL 99699 0 2
42256: ST_TO_ADDR
// p := [ ] ;
42257: LD_ADDR_VAR 0 11
42261: PUSH
42262: EMPTY
42263: ST_TO_ADDR
// if sort then
42264: LD_VAR 0 9
42268: IFFALSE 42384
// for i = 1 to 6 - mech do
42270: LD_ADDR_VAR 0 3
42274: PUSH
42275: DOUBLE
42276: LD_INT 1
42278: DEC
42279: ST_TO_ADDR
42280: LD_INT 6
42282: PUSH
42283: LD_VAR 0 7
42287: MINUS
42288: PUSH
42289: FOR_TO
42290: IFFALSE 42382
// begin if i = sort then
42292: LD_VAR 0 3
42296: PUSH
42297: LD_VAR 0 9
42301: EQUAL
42302: IFFALSE 42306
// break ;
42304: GO 42382
// if GetClass ( i ) = 3 then
42306: LD_VAR 0 3
42310: PPUSH
42311: CALL_OW 257
42315: PUSH
42316: LD_INT 3
42318: EQUAL
42319: IFFALSE 42323
// continue ;
42321: GO 42289
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42323: LD_ADDR_VAR 0 11
42327: PUSH
42328: LD_VAR 0 11
42332: PPUSH
42333: LD_VAR 0 11
42337: PUSH
42338: LD_INT 1
42340: PLUS
42341: PPUSH
42342: LD_VAR 0 9
42346: PUSH
42347: LD_VAR 0 3
42351: ARRAY
42352: PPUSH
42353: CALL_OW 2
42357: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42358: LD_ADDR_VAR 0 4
42362: PUSH
42363: LD_VAR 0 4
42367: PUSH
42368: LD_VAR 0 9
42372: PUSH
42373: LD_VAR 0 3
42377: ARRAY
42378: DIFF
42379: ST_TO_ADDR
// end ;
42380: GO 42289
42382: POP
42383: POP
// if p then
42384: LD_VAR 0 11
42388: IFFALSE 42413
// result := Replace ( result , 3 , p ) ;
42390: LD_ADDR_VAR 0 2
42394: PUSH
42395: LD_VAR 0 2
42399: PPUSH
42400: LD_INT 3
42402: PPUSH
42403: LD_VAR 0 11
42407: PPUSH
42408: CALL_OW 1
42412: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42413: LD_ADDR_VAR 0 4
42417: PUSH
42418: LD_VAR 0 4
42422: PUSH
42423: LD_VAR 0 6
42427: DIFF
42428: ST_TO_ADDR
// if tmp and eng < 6 then
42429: LD_VAR 0 4
42433: PUSH
42434: LD_VAR 0 6
42438: PUSH
42439: LD_INT 6
42441: LESS
42442: AND
42443: IFFALSE 42637
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42445: LD_ADDR_VAR 0 9
42449: PUSH
42450: LD_VAR 0 4
42454: PUSH
42455: LD_VAR 0 8
42459: PUSH
42460: LD_VAR 0 7
42464: UNION
42465: PUSH
42466: LD_VAR 0 6
42470: UNION
42471: DIFF
42472: PPUSH
42473: LD_INT 2
42475: PPUSH
42476: CALL 99699 0 2
42480: ST_TO_ADDR
// p := [ ] ;
42481: LD_ADDR_VAR 0 11
42485: PUSH
42486: EMPTY
42487: ST_TO_ADDR
// if sort then
42488: LD_VAR 0 9
42492: IFFALSE 42608
// for i = 1 to 6 - eng do
42494: LD_ADDR_VAR 0 3
42498: PUSH
42499: DOUBLE
42500: LD_INT 1
42502: DEC
42503: ST_TO_ADDR
42504: LD_INT 6
42506: PUSH
42507: LD_VAR 0 6
42511: MINUS
42512: PUSH
42513: FOR_TO
42514: IFFALSE 42606
// begin if i = sort then
42516: LD_VAR 0 3
42520: PUSH
42521: LD_VAR 0 9
42525: EQUAL
42526: IFFALSE 42530
// break ;
42528: GO 42606
// if GetClass ( i ) = 2 then
42530: LD_VAR 0 3
42534: PPUSH
42535: CALL_OW 257
42539: PUSH
42540: LD_INT 2
42542: EQUAL
42543: IFFALSE 42547
// continue ;
42545: GO 42513
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42547: LD_ADDR_VAR 0 11
42551: PUSH
42552: LD_VAR 0 11
42556: PPUSH
42557: LD_VAR 0 11
42561: PUSH
42562: LD_INT 1
42564: PLUS
42565: PPUSH
42566: LD_VAR 0 9
42570: PUSH
42571: LD_VAR 0 3
42575: ARRAY
42576: PPUSH
42577: CALL_OW 2
42581: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42582: LD_ADDR_VAR 0 4
42586: PUSH
42587: LD_VAR 0 4
42591: PUSH
42592: LD_VAR 0 9
42596: PUSH
42597: LD_VAR 0 3
42601: ARRAY
42602: DIFF
42603: ST_TO_ADDR
// end ;
42604: GO 42513
42606: POP
42607: POP
// if p then
42608: LD_VAR 0 11
42612: IFFALSE 42637
// result := Replace ( result , 2 , p ) ;
42614: LD_ADDR_VAR 0 2
42618: PUSH
42619: LD_VAR 0 2
42623: PPUSH
42624: LD_INT 2
42626: PPUSH
42627: LD_VAR 0 11
42631: PPUSH
42632: CALL_OW 1
42636: ST_TO_ADDR
// end ; exit ;
42637: GO 43361
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42639: LD_EXP 140
42643: PUSH
42644: LD_EXP 139
42648: PUSH
42649: LD_VAR 0 1
42653: ARRAY
42654: ARRAY
42655: NOT
42656: PUSH
42657: LD_EXP 113
42661: PUSH
42662: LD_VAR 0 1
42666: ARRAY
42667: PPUSH
42668: LD_INT 30
42670: PUSH
42671: LD_INT 3
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PPUSH
42678: CALL_OW 72
42682: AND
42683: PUSH
42684: LD_EXP 118
42688: PUSH
42689: LD_VAR 0 1
42693: ARRAY
42694: NOT
42695: AND
42696: IFFALSE 43361
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42698: LD_ADDR_EXP 155
42702: PUSH
42703: LD_EXP 155
42707: PPUSH
42708: LD_VAR 0 1
42712: PPUSH
42713: LD_INT 6
42715: PPUSH
42716: CALL_OW 1
42720: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42721: LD_ADDR_VAR 0 2
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: LD_INT 0
42731: PUSH
42732: LD_INT 0
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: ST_TO_ADDR
// if sci >= 1 then
42744: LD_VAR 0 8
42748: PUSH
42749: LD_INT 1
42751: GREATEREQUAL
42752: IFFALSE 42774
// tmp := tmp diff sci [ 1 ] ;
42754: LD_ADDR_VAR 0 4
42758: PUSH
42759: LD_VAR 0 4
42763: PUSH
42764: LD_VAR 0 8
42768: PUSH
42769: LD_INT 1
42771: ARRAY
42772: DIFF
42773: ST_TO_ADDR
// if tmp and not sci then
42774: LD_VAR 0 4
42778: PUSH
42779: LD_VAR 0 8
42783: NOT
42784: AND
42785: IFFALSE 42854
// begin sort := SortBySkill ( tmp , 4 ) ;
42787: LD_ADDR_VAR 0 9
42791: PUSH
42792: LD_VAR 0 4
42796: PPUSH
42797: LD_INT 4
42799: PPUSH
42800: CALL 99699 0 2
42804: ST_TO_ADDR
// if sort then
42805: LD_VAR 0 9
42809: IFFALSE 42825
// p := sort [ 1 ] ;
42811: LD_ADDR_VAR 0 11
42815: PUSH
42816: LD_VAR 0 9
42820: PUSH
42821: LD_INT 1
42823: ARRAY
42824: ST_TO_ADDR
// if p then
42825: LD_VAR 0 11
42829: IFFALSE 42854
// result := Replace ( result , 4 , p ) ;
42831: LD_ADDR_VAR 0 2
42835: PUSH
42836: LD_VAR 0 2
42840: PPUSH
42841: LD_INT 4
42843: PPUSH
42844: LD_VAR 0 11
42848: PPUSH
42849: CALL_OW 1
42853: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42854: LD_ADDR_VAR 0 4
42858: PUSH
42859: LD_VAR 0 4
42863: PUSH
42864: LD_VAR 0 7
42868: DIFF
42869: ST_TO_ADDR
// if tmp and mech < 6 then
42870: LD_VAR 0 4
42874: PUSH
42875: LD_VAR 0 7
42879: PUSH
42880: LD_INT 6
42882: LESS
42883: AND
42884: IFFALSE 43066
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42886: LD_ADDR_VAR 0 9
42890: PUSH
42891: LD_VAR 0 4
42895: PUSH
42896: LD_VAR 0 7
42900: DIFF
42901: PPUSH
42902: LD_INT 3
42904: PPUSH
42905: CALL 99699 0 2
42909: ST_TO_ADDR
// p := [ ] ;
42910: LD_ADDR_VAR 0 11
42914: PUSH
42915: EMPTY
42916: ST_TO_ADDR
// if sort then
42917: LD_VAR 0 9
42921: IFFALSE 43037
// for i = 1 to 6 - mech do
42923: LD_ADDR_VAR 0 3
42927: PUSH
42928: DOUBLE
42929: LD_INT 1
42931: DEC
42932: ST_TO_ADDR
42933: LD_INT 6
42935: PUSH
42936: LD_VAR 0 7
42940: MINUS
42941: PUSH
42942: FOR_TO
42943: IFFALSE 43035
// begin if i = sort then
42945: LD_VAR 0 3
42949: PUSH
42950: LD_VAR 0 9
42954: EQUAL
42955: IFFALSE 42959
// break ;
42957: GO 43035
// if GetClass ( i ) = 3 then
42959: LD_VAR 0 3
42963: PPUSH
42964: CALL_OW 257
42968: PUSH
42969: LD_INT 3
42971: EQUAL
42972: IFFALSE 42976
// continue ;
42974: GO 42942
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42976: LD_ADDR_VAR 0 11
42980: PUSH
42981: LD_VAR 0 11
42985: PPUSH
42986: LD_VAR 0 11
42990: PUSH
42991: LD_INT 1
42993: PLUS
42994: PPUSH
42995: LD_VAR 0 9
42999: PUSH
43000: LD_VAR 0 3
43004: ARRAY
43005: PPUSH
43006: CALL_OW 2
43010: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43011: LD_ADDR_VAR 0 4
43015: PUSH
43016: LD_VAR 0 4
43020: PUSH
43021: LD_VAR 0 9
43025: PUSH
43026: LD_VAR 0 3
43030: ARRAY
43031: DIFF
43032: ST_TO_ADDR
// end ;
43033: GO 42942
43035: POP
43036: POP
// if p then
43037: LD_VAR 0 11
43041: IFFALSE 43066
// result := Replace ( result , 3 , p ) ;
43043: LD_ADDR_VAR 0 2
43047: PUSH
43048: LD_VAR 0 2
43052: PPUSH
43053: LD_INT 3
43055: PPUSH
43056: LD_VAR 0 11
43060: PPUSH
43061: CALL_OW 1
43065: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43066: LD_ADDR_VAR 0 4
43070: PUSH
43071: LD_VAR 0 4
43075: PUSH
43076: LD_VAR 0 6
43080: DIFF
43081: ST_TO_ADDR
// if tmp and eng < 4 then
43082: LD_VAR 0 4
43086: PUSH
43087: LD_VAR 0 6
43091: PUSH
43092: LD_INT 4
43094: LESS
43095: AND
43096: IFFALSE 43286
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43098: LD_ADDR_VAR 0 9
43102: PUSH
43103: LD_VAR 0 4
43107: PUSH
43108: LD_VAR 0 7
43112: PUSH
43113: LD_VAR 0 6
43117: UNION
43118: DIFF
43119: PPUSH
43120: LD_INT 2
43122: PPUSH
43123: CALL 99699 0 2
43127: ST_TO_ADDR
// p := [ ] ;
43128: LD_ADDR_VAR 0 11
43132: PUSH
43133: EMPTY
43134: ST_TO_ADDR
// if sort then
43135: LD_VAR 0 9
43139: IFFALSE 43255
// for i = 1 to 4 - eng do
43141: LD_ADDR_VAR 0 3
43145: PUSH
43146: DOUBLE
43147: LD_INT 1
43149: DEC
43150: ST_TO_ADDR
43151: LD_INT 4
43153: PUSH
43154: LD_VAR 0 6
43158: MINUS
43159: PUSH
43160: FOR_TO
43161: IFFALSE 43253
// begin if i = sort then
43163: LD_VAR 0 3
43167: PUSH
43168: LD_VAR 0 9
43172: EQUAL
43173: IFFALSE 43177
// break ;
43175: GO 43253
// if GetClass ( i ) = 2 then
43177: LD_VAR 0 3
43181: PPUSH
43182: CALL_OW 257
43186: PUSH
43187: LD_INT 2
43189: EQUAL
43190: IFFALSE 43194
// continue ;
43192: GO 43160
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43194: LD_ADDR_VAR 0 11
43198: PUSH
43199: LD_VAR 0 11
43203: PPUSH
43204: LD_VAR 0 11
43208: PUSH
43209: LD_INT 1
43211: PLUS
43212: PPUSH
43213: LD_VAR 0 9
43217: PUSH
43218: LD_VAR 0 3
43222: ARRAY
43223: PPUSH
43224: CALL_OW 2
43228: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43229: LD_ADDR_VAR 0 4
43233: PUSH
43234: LD_VAR 0 4
43238: PUSH
43239: LD_VAR 0 9
43243: PUSH
43244: LD_VAR 0 3
43248: ARRAY
43249: DIFF
43250: ST_TO_ADDR
// end ;
43251: GO 43160
43253: POP
43254: POP
// if p then
43255: LD_VAR 0 11
43259: IFFALSE 43284
// result := Replace ( result , 2 , p ) ;
43261: LD_ADDR_VAR 0 2
43265: PUSH
43266: LD_VAR 0 2
43270: PPUSH
43271: LD_INT 2
43273: PPUSH
43274: LD_VAR 0 11
43278: PPUSH
43279: CALL_OW 1
43283: ST_TO_ADDR
// end else
43284: GO 43330
// for i = eng downto 5 do
43286: LD_ADDR_VAR 0 3
43290: PUSH
43291: DOUBLE
43292: LD_VAR 0 6
43296: INC
43297: ST_TO_ADDR
43298: LD_INT 5
43300: PUSH
43301: FOR_DOWNTO
43302: IFFALSE 43328
// tmp := tmp union eng [ i ] ;
43304: LD_ADDR_VAR 0 4
43308: PUSH
43309: LD_VAR 0 4
43313: PUSH
43314: LD_VAR 0 6
43318: PUSH
43319: LD_VAR 0 3
43323: ARRAY
43324: UNION
43325: ST_TO_ADDR
43326: GO 43301
43328: POP
43329: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43330: LD_ADDR_VAR 0 2
43334: PUSH
43335: LD_VAR 0 2
43339: PPUSH
43340: LD_INT 1
43342: PPUSH
43343: LD_VAR 0 4
43347: PUSH
43348: LD_VAR 0 5
43352: DIFF
43353: PPUSH
43354: CALL_OW 1
43358: ST_TO_ADDR
// exit ;
43359: GO 43361
// end ; end ;
43361: LD_VAR 0 2
43365: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43366: LD_INT 0
43368: PPUSH
43369: PPUSH
43370: PPUSH
// if not mc_bases then
43371: LD_EXP 113
43375: NOT
43376: IFFALSE 43380
// exit ;
43378: GO 43486
// for i = 1 to mc_bases do
43380: LD_ADDR_VAR 0 2
43384: PUSH
43385: DOUBLE
43386: LD_INT 1
43388: DEC
43389: ST_TO_ADDR
43390: LD_EXP 113
43394: PUSH
43395: FOR_TO
43396: IFFALSE 43477
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43398: LD_ADDR_VAR 0 3
43402: PUSH
43403: LD_EXP 113
43407: PUSH
43408: LD_VAR 0 2
43412: ARRAY
43413: PPUSH
43414: LD_INT 21
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 3
43426: PUSH
43427: LD_INT 24
43429: PUSH
43430: LD_INT 1000
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PPUSH
43445: CALL_OW 72
43449: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43450: LD_ADDR_EXP 114
43454: PUSH
43455: LD_EXP 114
43459: PPUSH
43460: LD_VAR 0 2
43464: PPUSH
43465: LD_VAR 0 3
43469: PPUSH
43470: CALL_OW 1
43474: ST_TO_ADDR
// end ;
43475: GO 43395
43477: POP
43478: POP
// RaiseSailEvent ( 101 ) ;
43479: LD_INT 101
43481: PPUSH
43482: CALL_OW 427
// end ;
43486: LD_VAR 0 1
43490: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43491: LD_INT 0
43493: PPUSH
43494: PPUSH
43495: PPUSH
43496: PPUSH
43497: PPUSH
43498: PPUSH
43499: PPUSH
// if not mc_bases then
43500: LD_EXP 113
43504: NOT
43505: IFFALSE 43509
// exit ;
43507: GO 44071
// for i = 1 to mc_bases do
43509: LD_ADDR_VAR 0 2
43513: PUSH
43514: DOUBLE
43515: LD_INT 1
43517: DEC
43518: ST_TO_ADDR
43519: LD_EXP 113
43523: PUSH
43524: FOR_TO
43525: IFFALSE 44062
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43527: LD_ADDR_VAR 0 5
43531: PUSH
43532: LD_EXP 113
43536: PUSH
43537: LD_VAR 0 2
43541: ARRAY
43542: PUSH
43543: LD_EXP 142
43547: PUSH
43548: LD_VAR 0 2
43552: ARRAY
43553: UNION
43554: PPUSH
43555: LD_INT 21
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 1
43567: PUSH
43568: LD_INT 3
43570: PUSH
43571: LD_INT 54
43573: PUSH
43574: EMPTY
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 3
43583: PUSH
43584: LD_INT 24
43586: PUSH
43587: LD_INT 800
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: LIST
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PPUSH
43607: CALL_OW 72
43611: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43612: LD_ADDR_VAR 0 6
43616: PUSH
43617: LD_EXP 113
43621: PUSH
43622: LD_VAR 0 2
43626: ARRAY
43627: PPUSH
43628: LD_INT 21
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: LD_INT 3
43643: PUSH
43644: LD_INT 54
43646: PUSH
43647: EMPTY
43648: LIST
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 3
43656: PUSH
43657: LD_INT 24
43659: PUSH
43660: LD_INT 250
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: LIST
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PPUSH
43680: CALL_OW 72
43684: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43685: LD_ADDR_VAR 0 7
43689: PUSH
43690: LD_VAR 0 5
43694: PUSH
43695: LD_VAR 0 6
43699: DIFF
43700: ST_TO_ADDR
// if not need_heal_1 then
43701: LD_VAR 0 6
43705: NOT
43706: IFFALSE 43739
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43708: LD_ADDR_EXP 116
43712: PUSH
43713: LD_EXP 116
43717: PPUSH
43718: LD_VAR 0 2
43722: PUSH
43723: LD_INT 1
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PPUSH
43730: EMPTY
43731: PPUSH
43732: CALL 70150 0 3
43736: ST_TO_ADDR
43737: GO 43809
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43739: LD_ADDR_EXP 116
43743: PUSH
43744: LD_EXP 116
43748: PPUSH
43749: LD_VAR 0 2
43753: PUSH
43754: LD_INT 1
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: LD_EXP 116
43765: PUSH
43766: LD_VAR 0 2
43770: ARRAY
43771: PUSH
43772: LD_INT 1
43774: ARRAY
43775: PPUSH
43776: LD_INT 3
43778: PUSH
43779: LD_INT 24
43781: PUSH
43782: LD_INT 1000
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PPUSH
43793: CALL_OW 72
43797: PUSH
43798: LD_VAR 0 6
43802: UNION
43803: PPUSH
43804: CALL 70150 0 3
43808: ST_TO_ADDR
// if not need_heal_2 then
43809: LD_VAR 0 7
43813: NOT
43814: IFFALSE 43847
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43816: LD_ADDR_EXP 116
43820: PUSH
43821: LD_EXP 116
43825: PPUSH
43826: LD_VAR 0 2
43830: PUSH
43831: LD_INT 2
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PPUSH
43838: EMPTY
43839: PPUSH
43840: CALL 70150 0 3
43844: ST_TO_ADDR
43845: GO 43879
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43847: LD_ADDR_EXP 116
43851: PUSH
43852: LD_EXP 116
43856: PPUSH
43857: LD_VAR 0 2
43861: PUSH
43862: LD_INT 2
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PPUSH
43869: LD_VAR 0 7
43873: PPUSH
43874: CALL 70150 0 3
43878: ST_TO_ADDR
// if need_heal_2 then
43879: LD_VAR 0 7
43883: IFFALSE 44044
// for j in need_heal_2 do
43885: LD_ADDR_VAR 0 3
43889: PUSH
43890: LD_VAR 0 7
43894: PUSH
43895: FOR_IN
43896: IFFALSE 44042
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43898: LD_ADDR_VAR 0 5
43902: PUSH
43903: LD_EXP 113
43907: PUSH
43908: LD_VAR 0 2
43912: ARRAY
43913: PPUSH
43914: LD_INT 2
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 6
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 30
43929: PUSH
43930: LD_INT 7
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 30
43939: PUSH
43940: LD_INT 8
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 30
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 30
43959: PUSH
43960: LD_INT 1
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: PPUSH
43975: CALL_OW 72
43979: ST_TO_ADDR
// if tmp then
43980: LD_VAR 0 5
43984: IFFALSE 44040
// begin k := NearestUnitToUnit ( tmp , j ) ;
43986: LD_ADDR_VAR 0 4
43990: PUSH
43991: LD_VAR 0 5
43995: PPUSH
43996: LD_VAR 0 3
44000: PPUSH
44001: CALL_OW 74
44005: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44006: LD_VAR 0 3
44010: PPUSH
44011: LD_VAR 0 4
44015: PPUSH
44016: CALL_OW 296
44020: PUSH
44021: LD_INT 5
44023: GREATER
44024: IFFALSE 44040
// ComMoveToNearbyEntrance ( j , k ) ;
44026: LD_VAR 0 3
44030: PPUSH
44031: LD_VAR 0 4
44035: PPUSH
44036: CALL 102016 0 2
// end ; end ;
44040: GO 43895
44042: POP
44043: POP
// if not need_heal_1 and not need_heal_2 then
44044: LD_VAR 0 6
44048: NOT
44049: PUSH
44050: LD_VAR 0 7
44054: NOT
44055: AND
44056: IFFALSE 44060
// continue ;
44058: GO 43524
// end ;
44060: GO 43524
44062: POP
44063: POP
// RaiseSailEvent ( 102 ) ;
44064: LD_INT 102
44066: PPUSH
44067: CALL_OW 427
// end ;
44071: LD_VAR 0 1
44075: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44076: LD_INT 0
44078: PPUSH
44079: PPUSH
44080: PPUSH
44081: PPUSH
44082: PPUSH
44083: PPUSH
44084: PPUSH
44085: PPUSH
// if not mc_bases then
44086: LD_EXP 113
44090: NOT
44091: IFFALSE 44095
// exit ;
44093: GO 44956
// for i = 1 to mc_bases do
44095: LD_ADDR_VAR 0 2
44099: PUSH
44100: DOUBLE
44101: LD_INT 1
44103: DEC
44104: ST_TO_ADDR
44105: LD_EXP 113
44109: PUSH
44110: FOR_TO
44111: IFFALSE 44954
// begin if not mc_building_need_repair [ i ] then
44113: LD_EXP 114
44117: PUSH
44118: LD_VAR 0 2
44122: ARRAY
44123: NOT
44124: IFFALSE 44311
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44126: LD_ADDR_VAR 0 6
44130: PUSH
44131: LD_EXP 132
44135: PUSH
44136: LD_VAR 0 2
44140: ARRAY
44141: PPUSH
44142: LD_INT 3
44144: PUSH
44145: LD_INT 24
44147: PUSH
44148: LD_INT 1000
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 34
44164: PUSH
44165: LD_INT 13
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 34
44174: PUSH
44175: LD_INT 52
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 34
44184: PUSH
44185: LD_EXP 101
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PPUSH
44204: CALL_OW 72
44208: ST_TO_ADDR
// if cranes then
44209: LD_VAR 0 6
44213: IFFALSE 44275
// for j in cranes do
44215: LD_ADDR_VAR 0 3
44219: PUSH
44220: LD_VAR 0 6
44224: PUSH
44225: FOR_IN
44226: IFFALSE 44273
// if not IsInArea ( j , mc_parking [ i ] ) then
44228: LD_VAR 0 3
44232: PPUSH
44233: LD_EXP 137
44237: PUSH
44238: LD_VAR 0 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 308
44248: NOT
44249: IFFALSE 44271
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44251: LD_VAR 0 3
44255: PPUSH
44256: LD_EXP 137
44260: PUSH
44261: LD_VAR 0 2
44265: ARRAY
44266: PPUSH
44267: CALL_OW 113
44271: GO 44225
44273: POP
44274: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44275: LD_ADDR_EXP 115
44279: PUSH
44280: LD_EXP 115
44284: PPUSH
44285: LD_VAR 0 2
44289: PPUSH
44290: EMPTY
44291: PPUSH
44292: CALL_OW 1
44296: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44297: LD_VAR 0 2
44301: PPUSH
44302: LD_INT 101
44304: PPUSH
44305: CALL 39199 0 2
// continue ;
44309: GO 44110
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44311: LD_ADDR_EXP 119
44315: PUSH
44316: LD_EXP 119
44320: PPUSH
44321: LD_VAR 0 2
44325: PPUSH
44326: EMPTY
44327: PPUSH
44328: CALL_OW 1
44332: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44333: LD_VAR 0 2
44337: PPUSH
44338: LD_INT 103
44340: PPUSH
44341: CALL 39199 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44345: LD_ADDR_VAR 0 5
44349: PUSH
44350: LD_EXP 113
44354: PUSH
44355: LD_VAR 0 2
44359: ARRAY
44360: PUSH
44361: LD_EXP 142
44365: PUSH
44366: LD_VAR 0 2
44370: ARRAY
44371: UNION
44372: PPUSH
44373: LD_INT 2
44375: PUSH
44376: LD_INT 25
44378: PUSH
44379: LD_INT 2
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 25
44388: PUSH
44389: LD_INT 16
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: LIST
44400: PUSH
44401: EMPTY
44402: LIST
44403: PPUSH
44404: CALL_OW 72
44408: PUSH
44409: LD_EXP 116
44413: PUSH
44414: LD_VAR 0 2
44418: ARRAY
44419: PUSH
44420: LD_INT 1
44422: ARRAY
44423: PUSH
44424: LD_EXP 116
44428: PUSH
44429: LD_VAR 0 2
44433: ARRAY
44434: PUSH
44435: LD_INT 2
44437: ARRAY
44438: UNION
44439: DIFF
44440: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44441: LD_ADDR_VAR 0 6
44445: PUSH
44446: LD_EXP 132
44450: PUSH
44451: LD_VAR 0 2
44455: ARRAY
44456: PPUSH
44457: LD_INT 2
44459: PUSH
44460: LD_INT 34
44462: PUSH
44463: LD_INT 13
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 34
44472: PUSH
44473: LD_INT 52
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 34
44482: PUSH
44483: LD_EXP 101
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: PPUSH
44498: CALL_OW 72
44502: ST_TO_ADDR
// if cranes then
44503: LD_VAR 0 6
44507: IFFALSE 44643
// begin for j in cranes do
44509: LD_ADDR_VAR 0 3
44513: PUSH
44514: LD_VAR 0 6
44518: PUSH
44519: FOR_IN
44520: IFFALSE 44641
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44522: LD_VAR 0 3
44526: PPUSH
44527: CALL_OW 256
44531: PUSH
44532: LD_INT 1000
44534: EQUAL
44535: PUSH
44536: LD_VAR 0 3
44540: PPUSH
44541: CALL_OW 314
44545: NOT
44546: AND
44547: IFFALSE 44581
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44549: LD_VAR 0 3
44553: PPUSH
44554: LD_EXP 114
44558: PUSH
44559: LD_VAR 0 2
44563: ARRAY
44564: PPUSH
44565: LD_VAR 0 3
44569: PPUSH
44570: CALL_OW 74
44574: PPUSH
44575: CALL_OW 130
44579: GO 44639
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44581: LD_VAR 0 3
44585: PPUSH
44586: CALL_OW 256
44590: PUSH
44591: LD_INT 500
44593: LESS
44594: PUSH
44595: LD_VAR 0 3
44599: PPUSH
44600: LD_EXP 137
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PPUSH
44611: CALL_OW 308
44615: NOT
44616: AND
44617: IFFALSE 44639
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44619: LD_VAR 0 3
44623: PPUSH
44624: LD_EXP 137
44628: PUSH
44629: LD_VAR 0 2
44633: ARRAY
44634: PPUSH
44635: CALL_OW 113
// end ;
44639: GO 44519
44641: POP
44642: POP
// end ; if tmp > 3 then
44643: LD_VAR 0 5
44647: PUSH
44648: LD_INT 3
44650: GREATER
44651: IFFALSE 44671
// tmp := ShrinkArray ( tmp , 4 ) ;
44653: LD_ADDR_VAR 0 5
44657: PUSH
44658: LD_VAR 0 5
44662: PPUSH
44663: LD_INT 4
44665: PPUSH
44666: CALL 101508 0 2
44670: ST_TO_ADDR
// if not tmp then
44671: LD_VAR 0 5
44675: NOT
44676: IFFALSE 44680
// continue ;
44678: GO 44110
// for j in tmp do
44680: LD_ADDR_VAR 0 3
44684: PUSH
44685: LD_VAR 0 5
44689: PUSH
44690: FOR_IN
44691: IFFALSE 44950
// begin if IsInUnit ( j ) then
44693: LD_VAR 0 3
44697: PPUSH
44698: CALL_OW 310
44702: IFFALSE 44713
// ComExitBuilding ( j ) ;
44704: LD_VAR 0 3
44708: PPUSH
44709: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44713: LD_VAR 0 3
44717: PUSH
44718: LD_EXP 115
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: IN
44729: NOT
44730: IFFALSE 44788
// begin SetTag ( j , 101 ) ;
44732: LD_VAR 0 3
44736: PPUSH
44737: LD_INT 101
44739: PPUSH
44740: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44744: LD_ADDR_EXP 115
44748: PUSH
44749: LD_EXP 115
44753: PPUSH
44754: LD_VAR 0 2
44758: PUSH
44759: LD_EXP 115
44763: PUSH
44764: LD_VAR 0 2
44768: ARRAY
44769: PUSH
44770: LD_INT 1
44772: PLUS
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PPUSH
44778: LD_VAR 0 3
44782: PPUSH
44783: CALL 70150 0 3
44787: ST_TO_ADDR
// end ; wait ( 1 ) ;
44788: LD_INT 1
44790: PPUSH
44791: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44795: LD_ADDR_VAR 0 7
44799: PUSH
44800: LD_EXP 114
44804: PUSH
44805: LD_VAR 0 2
44809: ARRAY
44810: ST_TO_ADDR
// if mc_scan [ i ] then
44811: LD_EXP 136
44815: PUSH
44816: LD_VAR 0 2
44820: ARRAY
44821: IFFALSE 44883
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44823: LD_ADDR_VAR 0 7
44827: PUSH
44828: LD_EXP 114
44832: PUSH
44833: LD_VAR 0 2
44837: ARRAY
44838: PPUSH
44839: LD_INT 3
44841: PUSH
44842: LD_INT 30
44844: PUSH
44845: LD_INT 32
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 30
44854: PUSH
44855: LD_INT 33
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 30
44864: PUSH
44865: LD_INT 31
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: PPUSH
44878: CALL_OW 72
44882: ST_TO_ADDR
// if not to_repair_tmp then
44883: LD_VAR 0 7
44887: NOT
44888: IFFALSE 44892
// continue ;
44890: GO 44690
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44892: LD_ADDR_VAR 0 8
44896: PUSH
44897: LD_VAR 0 7
44901: PPUSH
44902: LD_VAR 0 3
44906: PPUSH
44907: CALL_OW 74
44911: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
44912: LD_VAR 0 8
44916: PPUSH
44917: LD_INT 16
44919: PPUSH
44920: CALL 72743 0 2
44924: PUSH
44925: LD_INT 4
44927: ARRAY
44928: PUSH
44929: LD_INT 10
44931: LESS
44932: IFFALSE 44948
// ComRepairBuilding ( j , to_repair ) ;
44934: LD_VAR 0 3
44938: PPUSH
44939: LD_VAR 0 8
44943: PPUSH
44944: CALL_OW 130
// end ;
44948: GO 44690
44950: POP
44951: POP
// end ;
44952: GO 44110
44954: POP
44955: POP
// end ;
44956: LD_VAR 0 1
44960: RET
// export function MC_Heal ; var i , j , tmp ; begin
44961: LD_INT 0
44963: PPUSH
44964: PPUSH
44965: PPUSH
44966: PPUSH
// if not mc_bases then
44967: LD_EXP 113
44971: NOT
44972: IFFALSE 44976
// exit ;
44974: GO 45378
// for i = 1 to mc_bases do
44976: LD_ADDR_VAR 0 2
44980: PUSH
44981: DOUBLE
44982: LD_INT 1
44984: DEC
44985: ST_TO_ADDR
44986: LD_EXP 113
44990: PUSH
44991: FOR_TO
44992: IFFALSE 45376
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44994: LD_EXP 116
44998: PUSH
44999: LD_VAR 0 2
45003: ARRAY
45004: PUSH
45005: LD_INT 1
45007: ARRAY
45008: NOT
45009: PUSH
45010: LD_EXP 116
45014: PUSH
45015: LD_VAR 0 2
45019: ARRAY
45020: PUSH
45021: LD_INT 2
45023: ARRAY
45024: NOT
45025: AND
45026: IFFALSE 45064
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45028: LD_ADDR_EXP 117
45032: PUSH
45033: LD_EXP 117
45037: PPUSH
45038: LD_VAR 0 2
45042: PPUSH
45043: EMPTY
45044: PPUSH
45045: CALL_OW 1
45049: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45050: LD_VAR 0 2
45054: PPUSH
45055: LD_INT 102
45057: PPUSH
45058: CALL 39199 0 2
// continue ;
45062: GO 44991
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45064: LD_ADDR_VAR 0 4
45068: PUSH
45069: LD_EXP 113
45073: PUSH
45074: LD_VAR 0 2
45078: ARRAY
45079: PPUSH
45080: LD_INT 25
45082: PUSH
45083: LD_INT 4
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PPUSH
45090: CALL_OW 72
45094: ST_TO_ADDR
// if not tmp then
45095: LD_VAR 0 4
45099: NOT
45100: IFFALSE 45104
// continue ;
45102: GO 44991
// if mc_taming [ i ] then
45104: LD_EXP 144
45108: PUSH
45109: LD_VAR 0 2
45113: ARRAY
45114: IFFALSE 45138
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45116: LD_ADDR_EXP 144
45120: PUSH
45121: LD_EXP 144
45125: PPUSH
45126: LD_VAR 0 2
45130: PPUSH
45131: EMPTY
45132: PPUSH
45133: CALL_OW 1
45137: ST_TO_ADDR
// for j in tmp do
45138: LD_ADDR_VAR 0 3
45142: PUSH
45143: LD_VAR 0 4
45147: PUSH
45148: FOR_IN
45149: IFFALSE 45372
// begin if IsInUnit ( j ) then
45151: LD_VAR 0 3
45155: PPUSH
45156: CALL_OW 310
45160: IFFALSE 45171
// ComExitBuilding ( j ) ;
45162: LD_VAR 0 3
45166: PPUSH
45167: CALL_OW 122
// if not j in mc_healers [ i ] then
45171: LD_VAR 0 3
45175: PUSH
45176: LD_EXP 117
45180: PUSH
45181: LD_VAR 0 2
45185: ARRAY
45186: IN
45187: NOT
45188: IFFALSE 45234
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45190: LD_ADDR_EXP 117
45194: PUSH
45195: LD_EXP 117
45199: PPUSH
45200: LD_VAR 0 2
45204: PUSH
45205: LD_EXP 117
45209: PUSH
45210: LD_VAR 0 2
45214: ARRAY
45215: PUSH
45216: LD_INT 1
45218: PLUS
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PPUSH
45224: LD_VAR 0 3
45228: PPUSH
45229: CALL 70150 0 3
45233: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45234: LD_VAR 0 3
45238: PPUSH
45239: CALL_OW 110
45243: PUSH
45244: LD_INT 102
45246: NONEQUAL
45247: IFFALSE 45261
// SetTag ( j , 102 ) ;
45249: LD_VAR 0 3
45253: PPUSH
45254: LD_INT 102
45256: PPUSH
45257: CALL_OW 109
// Wait ( 3 ) ;
45261: LD_INT 3
45263: PPUSH
45264: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45268: LD_EXP 116
45272: PUSH
45273: LD_VAR 0 2
45277: ARRAY
45278: PUSH
45279: LD_INT 1
45281: ARRAY
45282: IFFALSE 45314
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45284: LD_VAR 0 3
45288: PPUSH
45289: LD_EXP 116
45293: PUSH
45294: LD_VAR 0 2
45298: ARRAY
45299: PUSH
45300: LD_INT 1
45302: ARRAY
45303: PUSH
45304: LD_INT 1
45306: ARRAY
45307: PPUSH
45308: CALL_OW 128
45312: GO 45370
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45314: LD_VAR 0 3
45318: PPUSH
45319: CALL_OW 314
45323: NOT
45324: PUSH
45325: LD_EXP 116
45329: PUSH
45330: LD_VAR 0 2
45334: ARRAY
45335: PUSH
45336: LD_INT 2
45338: ARRAY
45339: AND
45340: IFFALSE 45370
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45342: LD_VAR 0 3
45346: PPUSH
45347: LD_EXP 116
45351: PUSH
45352: LD_VAR 0 2
45356: ARRAY
45357: PUSH
45358: LD_INT 2
45360: ARRAY
45361: PUSH
45362: LD_INT 1
45364: ARRAY
45365: PPUSH
45366: CALL_OW 128
// end ;
45370: GO 45148
45372: POP
45373: POP
// end ;
45374: GO 44991
45376: POP
45377: POP
// end ;
45378: LD_VAR 0 1
45382: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45383: LD_INT 0
45385: PPUSH
45386: PPUSH
45387: PPUSH
45388: PPUSH
45389: PPUSH
// if not mc_bases then
45390: LD_EXP 113
45394: NOT
45395: IFFALSE 45399
// exit ;
45397: GO 46542
// for i = 1 to mc_bases do
45399: LD_ADDR_VAR 0 2
45403: PUSH
45404: DOUBLE
45405: LD_INT 1
45407: DEC
45408: ST_TO_ADDR
45409: LD_EXP 113
45413: PUSH
45414: FOR_TO
45415: IFFALSE 46540
// begin if mc_scan [ i ] then
45417: LD_EXP 136
45421: PUSH
45422: LD_VAR 0 2
45426: ARRAY
45427: IFFALSE 45431
// continue ;
45429: GO 45414
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45431: LD_EXP 118
45435: PUSH
45436: LD_VAR 0 2
45440: ARRAY
45441: NOT
45442: PUSH
45443: LD_EXP 120
45447: PUSH
45448: LD_VAR 0 2
45452: ARRAY
45453: NOT
45454: AND
45455: PUSH
45456: LD_EXP 119
45460: PUSH
45461: LD_VAR 0 2
45465: ARRAY
45466: AND
45467: IFFALSE 45505
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45469: LD_ADDR_EXP 119
45473: PUSH
45474: LD_EXP 119
45478: PPUSH
45479: LD_VAR 0 2
45483: PPUSH
45484: EMPTY
45485: PPUSH
45486: CALL_OW 1
45490: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45491: LD_VAR 0 2
45495: PPUSH
45496: LD_INT 103
45498: PPUSH
45499: CALL 39199 0 2
// continue ;
45503: GO 45414
// end ; if mc_construct_list [ i ] then
45505: LD_EXP 120
45509: PUSH
45510: LD_VAR 0 2
45514: ARRAY
45515: IFFALSE 45735
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45517: LD_ADDR_VAR 0 4
45521: PUSH
45522: LD_EXP 113
45526: PUSH
45527: LD_VAR 0 2
45531: ARRAY
45532: PPUSH
45533: LD_INT 25
45535: PUSH
45536: LD_INT 2
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PPUSH
45543: CALL_OW 72
45547: PUSH
45548: LD_EXP 115
45552: PUSH
45553: LD_VAR 0 2
45557: ARRAY
45558: DIFF
45559: ST_TO_ADDR
// if not tmp then
45560: LD_VAR 0 4
45564: NOT
45565: IFFALSE 45569
// continue ;
45567: GO 45414
// for j in tmp do
45569: LD_ADDR_VAR 0 3
45573: PUSH
45574: LD_VAR 0 4
45578: PUSH
45579: FOR_IN
45580: IFFALSE 45731
// begin if not mc_builders [ i ] then
45582: LD_EXP 119
45586: PUSH
45587: LD_VAR 0 2
45591: ARRAY
45592: NOT
45593: IFFALSE 45651
// begin SetTag ( j , 103 ) ;
45595: LD_VAR 0 3
45599: PPUSH
45600: LD_INT 103
45602: PPUSH
45603: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45607: LD_ADDR_EXP 119
45611: PUSH
45612: LD_EXP 119
45616: PPUSH
45617: LD_VAR 0 2
45621: PUSH
45622: LD_EXP 119
45626: PUSH
45627: LD_VAR 0 2
45631: ARRAY
45632: PUSH
45633: LD_INT 1
45635: PLUS
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PPUSH
45641: LD_VAR 0 3
45645: PPUSH
45646: CALL 70150 0 3
45650: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45651: LD_VAR 0 3
45655: PPUSH
45656: CALL_OW 310
45660: IFFALSE 45671
// ComExitBuilding ( j ) ;
45662: LD_VAR 0 3
45666: PPUSH
45667: CALL_OW 122
// wait ( 3 ) ;
45671: LD_INT 3
45673: PPUSH
45674: CALL_OW 67
// if not mc_construct_list [ i ] then
45678: LD_EXP 120
45682: PUSH
45683: LD_VAR 0 2
45687: ARRAY
45688: NOT
45689: IFFALSE 45693
// break ;
45691: GO 45731
// if not HasTask ( j ) then
45693: LD_VAR 0 3
45697: PPUSH
45698: CALL_OW 314
45702: NOT
45703: IFFALSE 45729
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45705: LD_VAR 0 3
45709: PPUSH
45710: LD_EXP 120
45714: PUSH
45715: LD_VAR 0 2
45719: ARRAY
45720: PUSH
45721: LD_INT 1
45723: ARRAY
45724: PPUSH
45725: CALL 73001 0 2
// end ;
45729: GO 45579
45731: POP
45732: POP
// end else
45733: GO 46538
// if mc_build_list [ i ] then
45735: LD_EXP 118
45739: PUSH
45740: LD_VAR 0 2
45744: ARRAY
45745: IFFALSE 46538
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45747: LD_ADDR_VAR 0 5
45751: PUSH
45752: LD_EXP 113
45756: PUSH
45757: LD_VAR 0 2
45761: ARRAY
45762: PPUSH
45763: LD_INT 2
45765: PUSH
45766: LD_INT 30
45768: PUSH
45769: LD_INT 0
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 30
45778: PUSH
45779: LD_INT 1
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: LIST
45790: PPUSH
45791: CALL_OW 72
45795: ST_TO_ADDR
// if depot then
45796: LD_VAR 0 5
45800: IFFALSE 45818
// depot := depot [ 1 ] else
45802: LD_ADDR_VAR 0 5
45806: PUSH
45807: LD_VAR 0 5
45811: PUSH
45812: LD_INT 1
45814: ARRAY
45815: ST_TO_ADDR
45816: GO 45826
// depot := 0 ;
45818: LD_ADDR_VAR 0 5
45822: PUSH
45823: LD_INT 0
45825: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45826: LD_EXP 118
45830: PUSH
45831: LD_VAR 0 2
45835: ARRAY
45836: PUSH
45837: LD_INT 1
45839: ARRAY
45840: PUSH
45841: LD_INT 1
45843: ARRAY
45844: PPUSH
45845: CALL 72831 0 1
45849: PUSH
45850: LD_EXP 113
45854: PUSH
45855: LD_VAR 0 2
45859: ARRAY
45860: PPUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 30
45866: PUSH
45867: LD_INT 2
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 30
45876: PUSH
45877: LD_INT 3
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: LIST
45888: PPUSH
45889: CALL_OW 72
45893: NOT
45894: AND
45895: IFFALSE 46000
// begin for j = 1 to mc_build_list [ i ] do
45897: LD_ADDR_VAR 0 3
45901: PUSH
45902: DOUBLE
45903: LD_INT 1
45905: DEC
45906: ST_TO_ADDR
45907: LD_EXP 118
45911: PUSH
45912: LD_VAR 0 2
45916: ARRAY
45917: PUSH
45918: FOR_TO
45919: IFFALSE 45998
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45921: LD_EXP 118
45925: PUSH
45926: LD_VAR 0 2
45930: ARRAY
45931: PUSH
45932: LD_VAR 0 3
45936: ARRAY
45937: PUSH
45938: LD_INT 1
45940: ARRAY
45941: PUSH
45942: LD_INT 2
45944: EQUAL
45945: IFFALSE 45996
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45947: LD_ADDR_EXP 118
45951: PUSH
45952: LD_EXP 118
45956: PPUSH
45957: LD_VAR 0 2
45961: PPUSH
45962: LD_EXP 118
45966: PUSH
45967: LD_VAR 0 2
45971: ARRAY
45972: PPUSH
45973: LD_VAR 0 3
45977: PPUSH
45978: LD_INT 1
45980: PPUSH
45981: LD_INT 0
45983: PPUSH
45984: CALL 69568 0 4
45988: PPUSH
45989: CALL_OW 1
45993: ST_TO_ADDR
// break ;
45994: GO 45998
// end ;
45996: GO 45918
45998: POP
45999: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46000: LD_EXP 118
46004: PUSH
46005: LD_VAR 0 2
46009: ARRAY
46010: PUSH
46011: LD_INT 1
46013: ARRAY
46014: PUSH
46015: LD_INT 1
46017: ARRAY
46018: PUSH
46019: LD_INT 0
46021: EQUAL
46022: PUSH
46023: LD_VAR 0 5
46027: PUSH
46028: LD_VAR 0 5
46032: PPUSH
46033: LD_EXP 118
46037: PUSH
46038: LD_VAR 0 2
46042: ARRAY
46043: PUSH
46044: LD_INT 1
46046: ARRAY
46047: PUSH
46048: LD_INT 1
46050: ARRAY
46051: PPUSH
46052: LD_EXP 118
46056: PUSH
46057: LD_VAR 0 2
46061: ARRAY
46062: PUSH
46063: LD_INT 1
46065: ARRAY
46066: PUSH
46067: LD_INT 2
46069: ARRAY
46070: PPUSH
46071: LD_EXP 118
46075: PUSH
46076: LD_VAR 0 2
46080: ARRAY
46081: PUSH
46082: LD_INT 1
46084: ARRAY
46085: PUSH
46086: LD_INT 3
46088: ARRAY
46089: PPUSH
46090: LD_EXP 118
46094: PUSH
46095: LD_VAR 0 2
46099: ARRAY
46100: PUSH
46101: LD_INT 1
46103: ARRAY
46104: PUSH
46105: LD_INT 4
46107: ARRAY
46108: PPUSH
46109: CALL 77565 0 5
46113: AND
46114: OR
46115: IFFALSE 46396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46117: LD_ADDR_VAR 0 4
46121: PUSH
46122: LD_EXP 113
46126: PUSH
46127: LD_VAR 0 2
46131: ARRAY
46132: PPUSH
46133: LD_INT 25
46135: PUSH
46136: LD_INT 2
46138: PUSH
46139: EMPTY
46140: LIST
46141: LIST
46142: PPUSH
46143: CALL_OW 72
46147: PUSH
46148: LD_EXP 115
46152: PUSH
46153: LD_VAR 0 2
46157: ARRAY
46158: DIFF
46159: ST_TO_ADDR
// if not tmp then
46160: LD_VAR 0 4
46164: NOT
46165: IFFALSE 46169
// continue ;
46167: GO 45414
// for j in tmp do
46169: LD_ADDR_VAR 0 3
46173: PUSH
46174: LD_VAR 0 4
46178: PUSH
46179: FOR_IN
46180: IFFALSE 46392
// begin if not mc_builders [ i ] then
46182: LD_EXP 119
46186: PUSH
46187: LD_VAR 0 2
46191: ARRAY
46192: NOT
46193: IFFALSE 46251
// begin SetTag ( j , 103 ) ;
46195: LD_VAR 0 3
46199: PPUSH
46200: LD_INT 103
46202: PPUSH
46203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46207: LD_ADDR_EXP 119
46211: PUSH
46212: LD_EXP 119
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_EXP 119
46226: PUSH
46227: LD_VAR 0 2
46231: ARRAY
46232: PUSH
46233: LD_INT 1
46235: PLUS
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PPUSH
46241: LD_VAR 0 3
46245: PPUSH
46246: CALL 70150 0 3
46250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46251: LD_VAR 0 3
46255: PPUSH
46256: CALL_OW 310
46260: IFFALSE 46271
// ComExitBuilding ( j ) ;
46262: LD_VAR 0 3
46266: PPUSH
46267: CALL_OW 122
// wait ( 3 ) ;
46271: LD_INT 3
46273: PPUSH
46274: CALL_OW 67
// if not mc_build_list [ i ] then
46278: LD_EXP 118
46282: PUSH
46283: LD_VAR 0 2
46287: ARRAY
46288: NOT
46289: IFFALSE 46293
// break ;
46291: GO 46392
// if not HasTask ( j ) then
46293: LD_VAR 0 3
46297: PPUSH
46298: CALL_OW 314
46302: NOT
46303: IFFALSE 46390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46305: LD_VAR 0 3
46309: PPUSH
46310: LD_EXP 118
46314: PUSH
46315: LD_VAR 0 2
46319: ARRAY
46320: PUSH
46321: LD_INT 1
46323: ARRAY
46324: PUSH
46325: LD_INT 1
46327: ARRAY
46328: PPUSH
46329: LD_EXP 118
46333: PUSH
46334: LD_VAR 0 2
46338: ARRAY
46339: PUSH
46340: LD_INT 1
46342: ARRAY
46343: PUSH
46344: LD_INT 2
46346: ARRAY
46347: PPUSH
46348: LD_EXP 118
46352: PUSH
46353: LD_VAR 0 2
46357: ARRAY
46358: PUSH
46359: LD_INT 1
46361: ARRAY
46362: PUSH
46363: LD_INT 3
46365: ARRAY
46366: PPUSH
46367: LD_EXP 118
46371: PUSH
46372: LD_VAR 0 2
46376: ARRAY
46377: PUSH
46378: LD_INT 1
46380: ARRAY
46381: PUSH
46382: LD_INT 4
46384: ARRAY
46385: PPUSH
46386: CALL_OW 145
// end ;
46390: GO 46179
46392: POP
46393: POP
// end else
46394: GO 46538
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46396: LD_EXP 113
46400: PUSH
46401: LD_VAR 0 2
46405: ARRAY
46406: PPUSH
46407: LD_EXP 118
46411: PUSH
46412: LD_VAR 0 2
46416: ARRAY
46417: PUSH
46418: LD_INT 1
46420: ARRAY
46421: PUSH
46422: LD_INT 1
46424: ARRAY
46425: PPUSH
46426: LD_EXP 118
46430: PUSH
46431: LD_VAR 0 2
46435: ARRAY
46436: PUSH
46437: LD_INT 1
46439: ARRAY
46440: PUSH
46441: LD_INT 2
46443: ARRAY
46444: PPUSH
46445: LD_EXP 118
46449: PUSH
46450: LD_VAR 0 2
46454: ARRAY
46455: PUSH
46456: LD_INT 1
46458: ARRAY
46459: PUSH
46460: LD_INT 3
46462: ARRAY
46463: PPUSH
46464: LD_EXP 118
46468: PUSH
46469: LD_VAR 0 2
46473: ARRAY
46474: PUSH
46475: LD_INT 1
46477: ARRAY
46478: PUSH
46479: LD_INT 4
46481: ARRAY
46482: PPUSH
46483: CALL 76901 0 5
46487: NOT
46488: IFFALSE 46538
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46490: LD_ADDR_EXP 118
46494: PUSH
46495: LD_EXP 118
46499: PPUSH
46500: LD_VAR 0 2
46504: PPUSH
46505: LD_EXP 118
46509: PUSH
46510: LD_VAR 0 2
46514: ARRAY
46515: PPUSH
46516: LD_INT 1
46518: PPUSH
46519: LD_INT 1
46521: NEG
46522: PPUSH
46523: LD_INT 0
46525: PPUSH
46526: CALL 69568 0 4
46530: PPUSH
46531: CALL_OW 1
46535: ST_TO_ADDR
// continue ;
46536: GO 45414
// end ; end ; end ;
46538: GO 45414
46540: POP
46541: POP
// end ;
46542: LD_VAR 0 1
46546: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46547: LD_INT 0
46549: PPUSH
46550: PPUSH
46551: PPUSH
46552: PPUSH
46553: PPUSH
46554: PPUSH
// if not mc_bases then
46555: LD_EXP 113
46559: NOT
46560: IFFALSE 46564
// exit ;
46562: GO 46991
// for i = 1 to mc_bases do
46564: LD_ADDR_VAR 0 2
46568: PUSH
46569: DOUBLE
46570: LD_INT 1
46572: DEC
46573: ST_TO_ADDR
46574: LD_EXP 113
46578: PUSH
46579: FOR_TO
46580: IFFALSE 46989
// begin tmp := mc_build_upgrade [ i ] ;
46582: LD_ADDR_VAR 0 4
46586: PUSH
46587: LD_EXP 145
46591: PUSH
46592: LD_VAR 0 2
46596: ARRAY
46597: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46598: LD_ADDR_VAR 0 6
46602: PUSH
46603: LD_EXP 146
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: PPUSH
46614: LD_INT 2
46616: PUSH
46617: LD_INT 30
46619: PUSH
46620: LD_INT 6
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 30
46629: PUSH
46630: LD_INT 7
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: PPUSH
46642: CALL_OW 72
46646: ST_TO_ADDR
// if not tmp and not lab then
46647: LD_VAR 0 4
46651: NOT
46652: PUSH
46653: LD_VAR 0 6
46657: NOT
46658: AND
46659: IFFALSE 46663
// continue ;
46661: GO 46579
// if tmp then
46663: LD_VAR 0 4
46667: IFFALSE 46787
// for j in tmp do
46669: LD_ADDR_VAR 0 3
46673: PUSH
46674: LD_VAR 0 4
46678: PUSH
46679: FOR_IN
46680: IFFALSE 46785
// begin if UpgradeCost ( j ) then
46682: LD_VAR 0 3
46686: PPUSH
46687: CALL 76561 0 1
46691: IFFALSE 46783
// begin ComUpgrade ( j ) ;
46693: LD_VAR 0 3
46697: PPUSH
46698: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46702: LD_ADDR_EXP 145
46706: PUSH
46707: LD_EXP 145
46711: PPUSH
46712: LD_VAR 0 2
46716: PPUSH
46717: LD_EXP 145
46721: PUSH
46722: LD_VAR 0 2
46726: ARRAY
46727: PUSH
46728: LD_VAR 0 3
46732: DIFF
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46739: LD_ADDR_EXP 120
46743: PUSH
46744: LD_EXP 120
46748: PPUSH
46749: LD_VAR 0 2
46753: PUSH
46754: LD_EXP 120
46758: PUSH
46759: LD_VAR 0 2
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: PLUS
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: PPUSH
46773: LD_VAR 0 3
46777: PPUSH
46778: CALL 70150 0 3
46782: ST_TO_ADDR
// end ; end ;
46783: GO 46679
46785: POP
46786: POP
// if not lab or not mc_lab_upgrade [ i ] then
46787: LD_VAR 0 6
46791: NOT
46792: PUSH
46793: LD_EXP 147
46797: PUSH
46798: LD_VAR 0 2
46802: ARRAY
46803: NOT
46804: OR
46805: IFFALSE 46809
// continue ;
46807: GO 46579
// for j in lab do
46809: LD_ADDR_VAR 0 3
46813: PUSH
46814: LD_VAR 0 6
46818: PUSH
46819: FOR_IN
46820: IFFALSE 46985
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46822: LD_VAR 0 3
46826: PPUSH
46827: CALL_OW 266
46831: PUSH
46832: LD_INT 6
46834: PUSH
46835: LD_INT 7
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: IN
46842: PUSH
46843: LD_VAR 0 3
46847: PPUSH
46848: CALL_OW 461
46852: PUSH
46853: LD_INT 1
46855: NONEQUAL
46856: AND
46857: IFFALSE 46983
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46859: LD_VAR 0 3
46863: PPUSH
46864: LD_EXP 147
46868: PUSH
46869: LD_VAR 0 2
46873: ARRAY
46874: PUSH
46875: LD_INT 1
46877: ARRAY
46878: PPUSH
46879: CALL 76766 0 2
46883: IFFALSE 46983
// begin ComCancel ( j ) ;
46885: LD_VAR 0 3
46889: PPUSH
46890: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46894: LD_VAR 0 3
46898: PPUSH
46899: LD_EXP 147
46903: PUSH
46904: LD_VAR 0 2
46908: ARRAY
46909: PUSH
46910: LD_INT 1
46912: ARRAY
46913: PPUSH
46914: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46918: LD_VAR 0 3
46922: PUSH
46923: LD_EXP 120
46927: PUSH
46928: LD_VAR 0 2
46932: ARRAY
46933: IN
46934: NOT
46935: IFFALSE 46981
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46937: LD_ADDR_EXP 120
46941: PUSH
46942: LD_EXP 120
46946: PPUSH
46947: LD_VAR 0 2
46951: PUSH
46952: LD_EXP 120
46956: PUSH
46957: LD_VAR 0 2
46961: ARRAY
46962: PUSH
46963: LD_INT 1
46965: PLUS
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PPUSH
46971: LD_VAR 0 3
46975: PPUSH
46976: CALL 70150 0 3
46980: ST_TO_ADDR
// break ;
46981: GO 46985
// end ; end ; end ;
46983: GO 46819
46985: POP
46986: POP
// end ;
46987: GO 46579
46989: POP
46990: POP
// end ;
46991: LD_VAR 0 1
46995: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46996: LD_INT 0
46998: PPUSH
46999: PPUSH
47000: PPUSH
47001: PPUSH
47002: PPUSH
47003: PPUSH
47004: PPUSH
47005: PPUSH
47006: PPUSH
// if not mc_bases then
47007: LD_EXP 113
47011: NOT
47012: IFFALSE 47016
// exit ;
47014: GO 47421
// for i = 1 to mc_bases do
47016: LD_ADDR_VAR 0 2
47020: PUSH
47021: DOUBLE
47022: LD_INT 1
47024: DEC
47025: ST_TO_ADDR
47026: LD_EXP 113
47030: PUSH
47031: FOR_TO
47032: IFFALSE 47419
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47034: LD_EXP 121
47038: PUSH
47039: LD_VAR 0 2
47043: ARRAY
47044: NOT
47045: PUSH
47046: LD_EXP 113
47050: PUSH
47051: LD_VAR 0 2
47055: ARRAY
47056: PPUSH
47057: LD_INT 30
47059: PUSH
47060: LD_INT 3
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PPUSH
47067: CALL_OW 72
47071: NOT
47072: OR
47073: IFFALSE 47077
// continue ;
47075: GO 47031
// busy := false ;
47077: LD_ADDR_VAR 0 8
47081: PUSH
47082: LD_INT 0
47084: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47085: LD_ADDR_VAR 0 4
47089: PUSH
47090: LD_EXP 113
47094: PUSH
47095: LD_VAR 0 2
47099: ARRAY
47100: PPUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 3
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PPUSH
47111: CALL_OW 72
47115: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47116: LD_ADDR_VAR 0 6
47120: PUSH
47121: LD_EXP 121
47125: PUSH
47126: LD_VAR 0 2
47130: ARRAY
47131: PPUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 30
47137: PUSH
47138: LD_INT 32
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 33
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: PPUSH
47160: CALL_OW 72
47164: ST_TO_ADDR
// if not t then
47165: LD_VAR 0 6
47169: NOT
47170: IFFALSE 47174
// continue ;
47172: GO 47031
// for j in tmp do
47174: LD_ADDR_VAR 0 3
47178: PUSH
47179: LD_VAR 0 4
47183: PUSH
47184: FOR_IN
47185: IFFALSE 47215
// if not BuildingStatus ( j ) = bs_idle then
47187: LD_VAR 0 3
47191: PPUSH
47192: CALL_OW 461
47196: PUSH
47197: LD_INT 2
47199: EQUAL
47200: NOT
47201: IFFALSE 47213
// begin busy := true ;
47203: LD_ADDR_VAR 0 8
47207: PUSH
47208: LD_INT 1
47210: ST_TO_ADDR
// break ;
47211: GO 47215
// end ;
47213: GO 47184
47215: POP
47216: POP
// if busy then
47217: LD_VAR 0 8
47221: IFFALSE 47225
// continue ;
47223: GO 47031
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47225: LD_ADDR_VAR 0 7
47229: PUSH
47230: LD_VAR 0 6
47234: PPUSH
47235: LD_INT 35
47237: PUSH
47238: LD_INT 0
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PPUSH
47245: CALL_OW 72
47249: ST_TO_ADDR
// if tw then
47250: LD_VAR 0 7
47254: IFFALSE 47331
// begin tw := tw [ 1 ] ;
47256: LD_ADDR_VAR 0 7
47260: PUSH
47261: LD_VAR 0 7
47265: PUSH
47266: LD_INT 1
47268: ARRAY
47269: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47270: LD_ADDR_VAR 0 9
47274: PUSH
47275: LD_VAR 0 7
47279: PPUSH
47280: LD_EXP 138
47284: PUSH
47285: LD_VAR 0 2
47289: ARRAY
47290: PPUSH
47291: CALL 75120 0 2
47295: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47296: LD_EXP 152
47300: PUSH
47301: LD_VAR 0 2
47305: ARRAY
47306: IFFALSE 47329
// if not weapon in mc_allowed_tower_weapons [ i ] then
47308: LD_VAR 0 9
47312: PUSH
47313: LD_EXP 152
47317: PUSH
47318: LD_VAR 0 2
47322: ARRAY
47323: IN
47324: NOT
47325: IFFALSE 47329
// continue ;
47327: GO 47031
// end else
47329: GO 47394
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47331: LD_ADDR_VAR 0 5
47335: PUSH
47336: LD_EXP 121
47340: PUSH
47341: LD_VAR 0 2
47345: ARRAY
47346: PPUSH
47347: LD_VAR 0 4
47351: PPUSH
47352: CALL 100741 0 2
47356: ST_TO_ADDR
// if not tmp2 then
47357: LD_VAR 0 5
47361: NOT
47362: IFFALSE 47366
// continue ;
47364: GO 47031
// tw := tmp2 [ 1 ] ;
47366: LD_ADDR_VAR 0 7
47370: PUSH
47371: LD_VAR 0 5
47375: PUSH
47376: LD_INT 1
47378: ARRAY
47379: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47380: LD_ADDR_VAR 0 9
47384: PUSH
47385: LD_VAR 0 5
47389: PUSH
47390: LD_INT 2
47392: ARRAY
47393: ST_TO_ADDR
// end ; if not weapon then
47394: LD_VAR 0 9
47398: NOT
47399: IFFALSE 47403
// continue ;
47401: GO 47031
// ComPlaceWeapon ( tw , weapon ) ;
47403: LD_VAR 0 7
47407: PPUSH
47408: LD_VAR 0 9
47412: PPUSH
47413: CALL_OW 148
// end ;
47417: GO 47031
47419: POP
47420: POP
// end ;
47421: LD_VAR 0 1
47425: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47426: LD_INT 0
47428: PPUSH
47429: PPUSH
47430: PPUSH
47431: PPUSH
47432: PPUSH
47433: PPUSH
47434: PPUSH
// if not mc_bases then
47435: LD_EXP 113
47439: NOT
47440: IFFALSE 47444
// exit ;
47442: GO 48212
// for i = 1 to mc_bases do
47444: LD_ADDR_VAR 0 2
47448: PUSH
47449: DOUBLE
47450: LD_INT 1
47452: DEC
47453: ST_TO_ADDR
47454: LD_EXP 113
47458: PUSH
47459: FOR_TO
47460: IFFALSE 48210
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47462: LD_EXP 126
47466: PUSH
47467: LD_VAR 0 2
47471: ARRAY
47472: NOT
47473: PUSH
47474: LD_EXP 126
47478: PUSH
47479: LD_VAR 0 2
47483: ARRAY
47484: PUSH
47485: LD_EXP 127
47489: PUSH
47490: LD_VAR 0 2
47494: ARRAY
47495: EQUAL
47496: OR
47497: PUSH
47498: LD_EXP 136
47502: PUSH
47503: LD_VAR 0 2
47507: ARRAY
47508: OR
47509: IFFALSE 47513
// continue ;
47511: GO 47459
// if mc_miners [ i ] then
47513: LD_EXP 127
47517: PUSH
47518: LD_VAR 0 2
47522: ARRAY
47523: IFFALSE 47897
// begin for j = mc_miners [ i ] downto 1 do
47525: LD_ADDR_VAR 0 3
47529: PUSH
47530: DOUBLE
47531: LD_EXP 127
47535: PUSH
47536: LD_VAR 0 2
47540: ARRAY
47541: INC
47542: ST_TO_ADDR
47543: LD_INT 1
47545: PUSH
47546: FOR_DOWNTO
47547: IFFALSE 47895
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47549: LD_EXP 127
47553: PUSH
47554: LD_VAR 0 2
47558: ARRAY
47559: PUSH
47560: LD_VAR 0 3
47564: ARRAY
47565: PPUSH
47566: CALL_OW 301
47570: PUSH
47571: LD_EXP 127
47575: PUSH
47576: LD_VAR 0 2
47580: ARRAY
47581: PUSH
47582: LD_VAR 0 3
47586: ARRAY
47587: PPUSH
47588: CALL_OW 257
47592: PUSH
47593: LD_INT 1
47595: NONEQUAL
47596: OR
47597: IFFALSE 47660
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47599: LD_ADDR_VAR 0 5
47603: PUSH
47604: LD_EXP 127
47608: PUSH
47609: LD_VAR 0 2
47613: ARRAY
47614: PUSH
47615: LD_EXP 127
47619: PUSH
47620: LD_VAR 0 2
47624: ARRAY
47625: PUSH
47626: LD_VAR 0 3
47630: ARRAY
47631: DIFF
47632: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47633: LD_ADDR_EXP 127
47637: PUSH
47638: LD_EXP 127
47642: PPUSH
47643: LD_VAR 0 2
47647: PPUSH
47648: LD_VAR 0 5
47652: PPUSH
47653: CALL_OW 1
47657: ST_TO_ADDR
// continue ;
47658: GO 47546
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47660: LD_EXP 127
47664: PUSH
47665: LD_VAR 0 2
47669: ARRAY
47670: PUSH
47671: LD_VAR 0 3
47675: ARRAY
47676: PPUSH
47677: CALL_OW 257
47681: PUSH
47682: LD_INT 1
47684: EQUAL
47685: PUSH
47686: LD_EXP 127
47690: PUSH
47691: LD_VAR 0 2
47695: ARRAY
47696: PUSH
47697: LD_VAR 0 3
47701: ARRAY
47702: PPUSH
47703: CALL_OW 459
47707: NOT
47708: AND
47709: PUSH
47710: LD_EXP 127
47714: PUSH
47715: LD_VAR 0 2
47719: ARRAY
47720: PUSH
47721: LD_VAR 0 3
47725: ARRAY
47726: PPUSH
47727: CALL_OW 314
47731: NOT
47732: AND
47733: IFFALSE 47893
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47735: LD_EXP 127
47739: PUSH
47740: LD_VAR 0 2
47744: ARRAY
47745: PUSH
47746: LD_VAR 0 3
47750: ARRAY
47751: PPUSH
47752: CALL_OW 310
47756: IFFALSE 47779
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47758: LD_EXP 127
47762: PUSH
47763: LD_VAR 0 2
47767: ARRAY
47768: PUSH
47769: LD_VAR 0 3
47773: ARRAY
47774: PPUSH
47775: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47779: LD_EXP 127
47783: PUSH
47784: LD_VAR 0 2
47788: ARRAY
47789: PUSH
47790: LD_VAR 0 3
47794: ARRAY
47795: PPUSH
47796: CALL_OW 314
47800: NOT
47801: IFFALSE 47893
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47803: LD_ADDR_VAR 0 7
47807: PUSH
47808: LD_INT 1
47810: PPUSH
47811: LD_EXP 126
47815: PUSH
47816: LD_VAR 0 2
47820: ARRAY
47821: PPUSH
47822: CALL_OW 12
47826: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
47827: LD_EXP 127
47831: PUSH
47832: LD_VAR 0 2
47836: ARRAY
47837: PUSH
47838: LD_VAR 0 3
47842: ARRAY
47843: PPUSH
47844: LD_EXP 126
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: PUSH
47855: LD_VAR 0 7
47859: ARRAY
47860: PUSH
47861: LD_INT 1
47863: ARRAY
47864: PPUSH
47865: LD_EXP 126
47869: PUSH
47870: LD_VAR 0 2
47874: ARRAY
47875: PUSH
47876: LD_VAR 0 7
47880: ARRAY
47881: PUSH
47882: LD_INT 2
47884: ARRAY
47885: PPUSH
47886: LD_INT 0
47888: PPUSH
47889: CALL_OW 193
// end ; end ; end ;
47893: GO 47546
47895: POP
47896: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47897: LD_ADDR_VAR 0 5
47901: PUSH
47902: LD_EXP 113
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: PPUSH
47913: LD_INT 2
47915: PUSH
47916: LD_INT 30
47918: PUSH
47919: LD_INT 4
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 30
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 30
47938: PUSH
47939: LD_INT 32
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: PPUSH
47952: CALL_OW 72
47956: ST_TO_ADDR
// if not tmp then
47957: LD_VAR 0 5
47961: NOT
47962: IFFALSE 47966
// continue ;
47964: GO 47459
// list := [ ] ;
47966: LD_ADDR_VAR 0 6
47970: PUSH
47971: EMPTY
47972: ST_TO_ADDR
// for j in tmp do
47973: LD_ADDR_VAR 0 3
47977: PUSH
47978: LD_VAR 0 5
47982: PUSH
47983: FOR_IN
47984: IFFALSE 48053
// begin for k in UnitsInside ( j ) do
47986: LD_ADDR_VAR 0 4
47990: PUSH
47991: LD_VAR 0 3
47995: PPUSH
47996: CALL_OW 313
48000: PUSH
48001: FOR_IN
48002: IFFALSE 48049
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48004: LD_VAR 0 4
48008: PPUSH
48009: CALL_OW 257
48013: PUSH
48014: LD_INT 1
48016: EQUAL
48017: PUSH
48018: LD_VAR 0 4
48022: PPUSH
48023: CALL_OW 459
48027: NOT
48028: AND
48029: IFFALSE 48047
// list := list ^ k ;
48031: LD_ADDR_VAR 0 6
48035: PUSH
48036: LD_VAR 0 6
48040: PUSH
48041: LD_VAR 0 4
48045: ADD
48046: ST_TO_ADDR
48047: GO 48001
48049: POP
48050: POP
// end ;
48051: GO 47983
48053: POP
48054: POP
// list := list diff mc_miners [ i ] ;
48055: LD_ADDR_VAR 0 6
48059: PUSH
48060: LD_VAR 0 6
48064: PUSH
48065: LD_EXP 127
48069: PUSH
48070: LD_VAR 0 2
48074: ARRAY
48075: DIFF
48076: ST_TO_ADDR
// if not list then
48077: LD_VAR 0 6
48081: NOT
48082: IFFALSE 48086
// continue ;
48084: GO 47459
// k := mc_mines [ i ] - mc_miners [ i ] ;
48086: LD_ADDR_VAR 0 4
48090: PUSH
48091: LD_EXP 126
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: PUSH
48102: LD_EXP 127
48106: PUSH
48107: LD_VAR 0 2
48111: ARRAY
48112: MINUS
48113: ST_TO_ADDR
// if k > list then
48114: LD_VAR 0 4
48118: PUSH
48119: LD_VAR 0 6
48123: GREATER
48124: IFFALSE 48136
// k := list ;
48126: LD_ADDR_VAR 0 4
48130: PUSH
48131: LD_VAR 0 6
48135: ST_TO_ADDR
// for j = 1 to k do
48136: LD_ADDR_VAR 0 3
48140: PUSH
48141: DOUBLE
48142: LD_INT 1
48144: DEC
48145: ST_TO_ADDR
48146: LD_VAR 0 4
48150: PUSH
48151: FOR_TO
48152: IFFALSE 48206
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48154: LD_ADDR_EXP 127
48158: PUSH
48159: LD_EXP 127
48163: PPUSH
48164: LD_VAR 0 2
48168: PUSH
48169: LD_EXP 127
48173: PUSH
48174: LD_VAR 0 2
48178: ARRAY
48179: PUSH
48180: LD_INT 1
48182: PLUS
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PPUSH
48188: LD_VAR 0 6
48192: PUSH
48193: LD_VAR 0 3
48197: ARRAY
48198: PPUSH
48199: CALL 70150 0 3
48203: ST_TO_ADDR
48204: GO 48151
48206: POP
48207: POP
// end ;
48208: GO 47459
48210: POP
48211: POP
// end ;
48212: LD_VAR 0 1
48216: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48217: LD_INT 0
48219: PPUSH
48220: PPUSH
48221: PPUSH
48222: PPUSH
48223: PPUSH
48224: PPUSH
48225: PPUSH
48226: PPUSH
48227: PPUSH
48228: PPUSH
// if not mc_bases then
48229: LD_EXP 113
48233: NOT
48234: IFFALSE 48238
// exit ;
48236: GO 49988
// for i = 1 to mc_bases do
48238: LD_ADDR_VAR 0 2
48242: PUSH
48243: DOUBLE
48244: LD_INT 1
48246: DEC
48247: ST_TO_ADDR
48248: LD_EXP 113
48252: PUSH
48253: FOR_TO
48254: IFFALSE 49986
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48256: LD_EXP 113
48260: PUSH
48261: LD_VAR 0 2
48265: ARRAY
48266: NOT
48267: PUSH
48268: LD_EXP 120
48272: PUSH
48273: LD_VAR 0 2
48277: ARRAY
48278: OR
48279: IFFALSE 48283
// continue ;
48281: GO 48253
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48283: LD_EXP 129
48287: PUSH
48288: LD_VAR 0 2
48292: ARRAY
48293: NOT
48294: PUSH
48295: LD_EXP 130
48299: PUSH
48300: LD_VAR 0 2
48304: ARRAY
48305: AND
48306: IFFALSE 48344
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48308: LD_ADDR_EXP 130
48312: PUSH
48313: LD_EXP 130
48317: PPUSH
48318: LD_VAR 0 2
48322: PPUSH
48323: EMPTY
48324: PPUSH
48325: CALL_OW 1
48329: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48330: LD_VAR 0 2
48334: PPUSH
48335: LD_INT 107
48337: PPUSH
48338: CALL 39199 0 2
// continue ;
48342: GO 48253
// end ; target := [ ] ;
48344: LD_ADDR_VAR 0 6
48348: PUSH
48349: EMPTY
48350: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48351: LD_ADDR_VAR 0 3
48355: PUSH
48356: DOUBLE
48357: LD_EXP 129
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: INC
48368: ST_TO_ADDR
48369: LD_INT 1
48371: PUSH
48372: FOR_DOWNTO
48373: IFFALSE 48633
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48375: LD_EXP 129
48379: PUSH
48380: LD_VAR 0 2
48384: ARRAY
48385: PUSH
48386: LD_VAR 0 3
48390: ARRAY
48391: PUSH
48392: LD_INT 2
48394: ARRAY
48395: PPUSH
48396: LD_EXP 129
48400: PUSH
48401: LD_VAR 0 2
48405: ARRAY
48406: PUSH
48407: LD_VAR 0 3
48411: ARRAY
48412: PUSH
48413: LD_INT 3
48415: ARRAY
48416: PPUSH
48417: CALL_OW 488
48421: PUSH
48422: LD_EXP 129
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PUSH
48433: LD_VAR 0 3
48437: ARRAY
48438: PUSH
48439: LD_INT 2
48441: ARRAY
48442: PPUSH
48443: LD_EXP 129
48447: PUSH
48448: LD_VAR 0 2
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 3
48458: ARRAY
48459: PUSH
48460: LD_INT 3
48462: ARRAY
48463: PPUSH
48464: CALL_OW 284
48468: PUSH
48469: LD_INT 0
48471: EQUAL
48472: AND
48473: IFFALSE 48528
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48475: LD_ADDR_VAR 0 5
48479: PUSH
48480: LD_EXP 129
48484: PUSH
48485: LD_VAR 0 2
48489: ARRAY
48490: PPUSH
48491: LD_VAR 0 3
48495: PPUSH
48496: CALL_OW 3
48500: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48501: LD_ADDR_EXP 129
48505: PUSH
48506: LD_EXP 129
48510: PPUSH
48511: LD_VAR 0 2
48515: PPUSH
48516: LD_VAR 0 5
48520: PPUSH
48521: CALL_OW 1
48525: ST_TO_ADDR
// continue ;
48526: GO 48372
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48528: LD_EXP 113
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PUSH
48539: LD_INT 1
48541: ARRAY
48542: PPUSH
48543: CALL_OW 255
48547: PPUSH
48548: LD_EXP 129
48552: PUSH
48553: LD_VAR 0 2
48557: ARRAY
48558: PUSH
48559: LD_VAR 0 3
48563: ARRAY
48564: PUSH
48565: LD_INT 2
48567: ARRAY
48568: PPUSH
48569: LD_EXP 129
48573: PUSH
48574: LD_VAR 0 2
48578: ARRAY
48579: PUSH
48580: LD_VAR 0 3
48584: ARRAY
48585: PUSH
48586: LD_INT 3
48588: ARRAY
48589: PPUSH
48590: LD_INT 30
48592: PPUSH
48593: CALL 71046 0 4
48597: PUSH
48598: LD_INT 4
48600: ARRAY
48601: PUSH
48602: LD_INT 0
48604: EQUAL
48605: IFFALSE 48631
// begin target := mc_crates [ i ] [ j ] ;
48607: LD_ADDR_VAR 0 6
48611: PUSH
48612: LD_EXP 129
48616: PUSH
48617: LD_VAR 0 2
48621: ARRAY
48622: PUSH
48623: LD_VAR 0 3
48627: ARRAY
48628: ST_TO_ADDR
// break ;
48629: GO 48633
// end ; end ;
48631: GO 48372
48633: POP
48634: POP
// if not target then
48635: LD_VAR 0 6
48639: NOT
48640: IFFALSE 48644
// continue ;
48642: GO 48253
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48644: LD_ADDR_VAR 0 7
48648: PUSH
48649: LD_EXP 132
48653: PUSH
48654: LD_VAR 0 2
48658: ARRAY
48659: PPUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 3
48665: PUSH
48666: LD_INT 58
48668: PUSH
48669: EMPTY
48670: LIST
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 61
48678: PUSH
48679: EMPTY
48680: LIST
48681: PUSH
48682: LD_INT 33
48684: PUSH
48685: LD_INT 5
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 33
48694: PUSH
48695: LD_INT 3
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 2
48711: PUSH
48712: LD_INT 34
48714: PUSH
48715: LD_INT 32
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 34
48724: PUSH
48725: LD_INT 51
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 34
48734: PUSH
48735: LD_INT 12
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: ST_TO_ADDR
// if not cargo then
48757: LD_VAR 0 7
48761: NOT
48762: IFFALSE 49405
// begin if mc_crates_collector [ i ] < 5 then
48764: LD_EXP 130
48768: PUSH
48769: LD_VAR 0 2
48773: ARRAY
48774: PUSH
48775: LD_INT 5
48777: LESS
48778: IFFALSE 49144
// begin if mc_ape [ i ] then
48780: LD_EXP 142
48784: PUSH
48785: LD_VAR 0 2
48789: ARRAY
48790: IFFALSE 48837
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48792: LD_ADDR_VAR 0 5
48796: PUSH
48797: LD_EXP 142
48801: PUSH
48802: LD_VAR 0 2
48806: ARRAY
48807: PPUSH
48808: LD_INT 25
48810: PUSH
48811: LD_INT 16
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 24
48820: PUSH
48821: LD_INT 750
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PPUSH
48832: CALL_OW 72
48836: ST_TO_ADDR
// if not tmp then
48837: LD_VAR 0 5
48841: NOT
48842: IFFALSE 48889
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48844: LD_ADDR_VAR 0 5
48848: PUSH
48849: LD_EXP 113
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PPUSH
48860: LD_INT 25
48862: PUSH
48863: LD_INT 2
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 24
48872: PUSH
48873: LD_INT 750
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PPUSH
48884: CALL_OW 72
48888: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48889: LD_EXP 142
48893: PUSH
48894: LD_VAR 0 2
48898: ARRAY
48899: PUSH
48900: LD_EXP 113
48904: PUSH
48905: LD_VAR 0 2
48909: ARRAY
48910: PPUSH
48911: LD_INT 25
48913: PUSH
48914: LD_INT 2
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 24
48923: PUSH
48924: LD_INT 750
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PPUSH
48935: CALL_OW 72
48939: AND
48940: PUSH
48941: LD_VAR 0 5
48945: PUSH
48946: LD_INT 5
48948: LESS
48949: AND
48950: IFFALSE 49032
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48952: LD_ADDR_VAR 0 3
48956: PUSH
48957: LD_EXP 113
48961: PUSH
48962: LD_VAR 0 2
48966: ARRAY
48967: PPUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 2
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 24
48980: PUSH
48981: LD_INT 750
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PPUSH
48992: CALL_OW 72
48996: PUSH
48997: FOR_IN
48998: IFFALSE 49030
// begin tmp := tmp union j ;
49000: LD_ADDR_VAR 0 5
49004: PUSH
49005: LD_VAR 0 5
49009: PUSH
49010: LD_VAR 0 3
49014: UNION
49015: ST_TO_ADDR
// if tmp >= 5 then
49016: LD_VAR 0 5
49020: PUSH
49021: LD_INT 5
49023: GREATEREQUAL
49024: IFFALSE 49028
// break ;
49026: GO 49030
// end ;
49028: GO 48997
49030: POP
49031: POP
// end ; if not tmp then
49032: LD_VAR 0 5
49036: NOT
49037: IFFALSE 49041
// continue ;
49039: GO 48253
// for j in tmp do
49041: LD_ADDR_VAR 0 3
49045: PUSH
49046: LD_VAR 0 5
49050: PUSH
49051: FOR_IN
49052: IFFALSE 49142
// if not GetTag ( j ) then
49054: LD_VAR 0 3
49058: PPUSH
49059: CALL_OW 110
49063: NOT
49064: IFFALSE 49140
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49066: LD_ADDR_EXP 130
49070: PUSH
49071: LD_EXP 130
49075: PPUSH
49076: LD_VAR 0 2
49080: PUSH
49081: LD_EXP 130
49085: PUSH
49086: LD_VAR 0 2
49090: ARRAY
49091: PUSH
49092: LD_INT 1
49094: PLUS
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PPUSH
49100: LD_VAR 0 3
49104: PPUSH
49105: CALL 70150 0 3
49109: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49110: LD_VAR 0 3
49114: PPUSH
49115: LD_INT 107
49117: PPUSH
49118: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49122: LD_EXP 130
49126: PUSH
49127: LD_VAR 0 2
49131: ARRAY
49132: PUSH
49133: LD_INT 5
49135: GREATEREQUAL
49136: IFFALSE 49140
// break ;
49138: GO 49142
// end ;
49140: GO 49051
49142: POP
49143: POP
// end ; if mc_crates_collector [ i ] and target then
49144: LD_EXP 130
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PUSH
49155: LD_VAR 0 6
49159: AND
49160: IFFALSE 49403
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49162: LD_EXP 130
49166: PUSH
49167: LD_VAR 0 2
49171: ARRAY
49172: PUSH
49173: LD_VAR 0 6
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: LESS
49182: IFFALSE 49202
// tmp := mc_crates_collector [ i ] else
49184: LD_ADDR_VAR 0 5
49188: PUSH
49189: LD_EXP 130
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: ST_TO_ADDR
49200: GO 49216
// tmp := target [ 1 ] ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_VAR 0 6
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: ST_TO_ADDR
// k := 0 ;
49216: LD_ADDR_VAR 0 4
49220: PUSH
49221: LD_INT 0
49223: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49224: LD_ADDR_VAR 0 3
49228: PUSH
49229: LD_EXP 130
49233: PUSH
49234: LD_VAR 0 2
49238: ARRAY
49239: PUSH
49240: FOR_IN
49241: IFFALSE 49401
// begin k := k + 1 ;
49243: LD_ADDR_VAR 0 4
49247: PUSH
49248: LD_VAR 0 4
49252: PUSH
49253: LD_INT 1
49255: PLUS
49256: ST_TO_ADDR
// if k > tmp then
49257: LD_VAR 0 4
49261: PUSH
49262: LD_VAR 0 5
49266: GREATER
49267: IFFALSE 49271
// break ;
49269: GO 49401
// if not GetClass ( j ) in [ 2 , 16 ] then
49271: LD_VAR 0 3
49275: PPUSH
49276: CALL_OW 257
49280: PUSH
49281: LD_INT 2
49283: PUSH
49284: LD_INT 16
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: IN
49291: NOT
49292: IFFALSE 49345
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49294: LD_ADDR_EXP 130
49298: PUSH
49299: LD_EXP 130
49303: PPUSH
49304: LD_VAR 0 2
49308: PPUSH
49309: LD_EXP 130
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 3
49324: DIFF
49325: PPUSH
49326: CALL_OW 1
49330: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49331: LD_VAR 0 3
49335: PPUSH
49336: LD_INT 0
49338: PPUSH
49339: CALL_OW 109
// continue ;
49343: GO 49240
// end ; if IsInUnit ( j ) then
49345: LD_VAR 0 3
49349: PPUSH
49350: CALL_OW 310
49354: IFFALSE 49365
// ComExitBuilding ( j ) ;
49356: LD_VAR 0 3
49360: PPUSH
49361: CALL_OW 122
// wait ( 3 ) ;
49365: LD_INT 3
49367: PPUSH
49368: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49372: LD_VAR 0 3
49376: PPUSH
49377: LD_VAR 0 6
49381: PUSH
49382: LD_INT 2
49384: ARRAY
49385: PPUSH
49386: LD_VAR 0 6
49390: PUSH
49391: LD_INT 3
49393: ARRAY
49394: PPUSH
49395: CALL_OW 117
// end ;
49399: GO 49240
49401: POP
49402: POP
// end ; end else
49403: GO 49984
// begin for j in cargo do
49405: LD_ADDR_VAR 0 3
49409: PUSH
49410: LD_VAR 0 7
49414: PUSH
49415: FOR_IN
49416: IFFALSE 49982
// begin if GetTag ( j ) <> 0 then
49418: LD_VAR 0 3
49422: PPUSH
49423: CALL_OW 110
49427: PUSH
49428: LD_INT 0
49430: NONEQUAL
49431: IFFALSE 49435
// continue ;
49433: GO 49415
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49435: LD_VAR 0 3
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 1000
49447: LESS
49448: PUSH
49449: LD_VAR 0 3
49453: PPUSH
49454: LD_EXP 137
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: PPUSH
49465: CALL_OW 308
49469: NOT
49470: AND
49471: IFFALSE 49493
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49473: LD_VAR 0 3
49477: PPUSH
49478: LD_EXP 137
49482: PUSH
49483: LD_VAR 0 2
49487: ARRAY
49488: PPUSH
49489: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49493: LD_VAR 0 3
49497: PPUSH
49498: CALL_OW 256
49502: PUSH
49503: LD_INT 1000
49505: LESS
49506: PUSH
49507: LD_VAR 0 3
49511: PPUSH
49512: LD_EXP 137
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PPUSH
49523: CALL_OW 308
49527: AND
49528: IFFALSE 49532
// continue ;
49530: GO 49415
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49532: LD_VAR 0 3
49536: PPUSH
49537: CALL_OW 262
49541: PUSH
49542: LD_INT 2
49544: EQUAL
49545: PUSH
49546: LD_VAR 0 3
49550: PPUSH
49551: CALL_OW 261
49555: PUSH
49556: LD_INT 15
49558: LESS
49559: AND
49560: IFFALSE 49564
// continue ;
49562: GO 49415
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49564: LD_VAR 0 3
49568: PPUSH
49569: CALL_OW 262
49573: PUSH
49574: LD_INT 1
49576: EQUAL
49577: PUSH
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 261
49587: PUSH
49588: LD_INT 10
49590: LESS
49591: AND
49592: IFFALSE 49921
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49594: LD_ADDR_VAR 0 8
49598: PUSH
49599: LD_EXP 113
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: LD_INT 2
49612: PUSH
49613: LD_INT 30
49615: PUSH
49616: LD_INT 0
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 30
49625: PUSH
49626: LD_INT 1
49628: PUSH
49629: EMPTY
49630: LIST
49631: LIST
49632: PUSH
49633: EMPTY
49634: LIST
49635: LIST
49636: LIST
49637: PPUSH
49638: CALL_OW 72
49642: ST_TO_ADDR
// if not depot then
49643: LD_VAR 0 8
49647: NOT
49648: IFFALSE 49652
// continue ;
49650: GO 49415
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49652: LD_VAR 0 3
49656: PPUSH
49657: LD_VAR 0 8
49661: PPUSH
49662: LD_VAR 0 3
49666: PPUSH
49667: CALL_OW 74
49671: PPUSH
49672: CALL_OW 296
49676: PUSH
49677: LD_INT 6
49679: LESS
49680: IFFALSE 49696
// SetFuel ( j , 100 ) else
49682: LD_VAR 0 3
49686: PPUSH
49687: LD_INT 100
49689: PPUSH
49690: CALL_OW 240
49694: GO 49921
// if GetFuel ( j ) = 0 then
49696: LD_VAR 0 3
49700: PPUSH
49701: CALL_OW 261
49705: PUSH
49706: LD_INT 0
49708: EQUAL
49709: IFFALSE 49921
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49711: LD_ADDR_EXP 132
49715: PUSH
49716: LD_EXP 132
49720: PPUSH
49721: LD_VAR 0 2
49725: PPUSH
49726: LD_EXP 132
49730: PUSH
49731: LD_VAR 0 2
49735: ARRAY
49736: PUSH
49737: LD_VAR 0 3
49741: DIFF
49742: PPUSH
49743: CALL_OW 1
49747: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49748: LD_VAR 0 3
49752: PPUSH
49753: CALL_OW 263
49757: PUSH
49758: LD_INT 1
49760: EQUAL
49761: IFFALSE 49777
// ComExitVehicle ( IsInUnit ( j ) ) ;
49763: LD_VAR 0 3
49767: PPUSH
49768: CALL_OW 310
49772: PPUSH
49773: CALL_OW 121
// if GetControl ( j ) = control_remote then
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL_OW 263
49786: PUSH
49787: LD_INT 2
49789: EQUAL
49790: IFFALSE 49801
// ComUnlink ( j ) ;
49792: LD_VAR 0 3
49796: PPUSH
49797: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49801: LD_ADDR_VAR 0 9
49805: PUSH
49806: LD_VAR 0 2
49810: PPUSH
49811: LD_INT 3
49813: PPUSH
49814: CALL 59296 0 2
49818: ST_TO_ADDR
// if fac then
49819: LD_VAR 0 9
49823: IFFALSE 49919
// begin for k in fac do
49825: LD_ADDR_VAR 0 4
49829: PUSH
49830: LD_VAR 0 9
49834: PUSH
49835: FOR_IN
49836: IFFALSE 49917
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49838: LD_ADDR_VAR 0 10
49842: PUSH
49843: LD_VAR 0 9
49847: PPUSH
49848: LD_VAR 0 3
49852: PPUSH
49853: CALL_OW 265
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL_OW 262
49867: PPUSH
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL_OW 263
49877: PPUSH
49878: LD_VAR 0 3
49882: PPUSH
49883: CALL_OW 264
49887: PPUSH
49888: CALL 67682 0 5
49892: ST_TO_ADDR
// if components then
49893: LD_VAR 0 10
49897: IFFALSE 49915
// begin MC_InsertProduceList ( i , components ) ;
49899: LD_VAR 0 2
49903: PPUSH
49904: LD_VAR 0 10
49908: PPUSH
49909: CALL 58841 0 2
// break ;
49913: GO 49917
// end ; end ;
49915: GO 49835
49917: POP
49918: POP
// end ; continue ;
49919: GO 49415
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49921: LD_VAR 0 3
49925: PPUSH
49926: LD_INT 1
49928: PPUSH
49929: CALL_OW 289
49933: PUSH
49934: LD_INT 100
49936: LESS
49937: PUSH
49938: LD_VAR 0 3
49942: PPUSH
49943: CALL_OW 314
49947: NOT
49948: AND
49949: IFFALSE 49978
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49951: LD_VAR 0 3
49955: PPUSH
49956: LD_VAR 0 6
49960: PUSH
49961: LD_INT 2
49963: ARRAY
49964: PPUSH
49965: LD_VAR 0 6
49969: PUSH
49970: LD_INT 3
49972: ARRAY
49973: PPUSH
49974: CALL_OW 117
// break ;
49978: GO 49982
// end ;
49980: GO 49415
49982: POP
49983: POP
// end ; end ;
49984: GO 48253
49986: POP
49987: POP
// end ;
49988: LD_VAR 0 1
49992: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49993: LD_INT 0
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
// if not mc_bases then
49999: LD_EXP 113
50003: NOT
50004: IFFALSE 50008
// exit ;
50006: GO 50169
// for i = 1 to mc_bases do
50008: LD_ADDR_VAR 0 2
50012: PUSH
50013: DOUBLE
50014: LD_INT 1
50016: DEC
50017: ST_TO_ADDR
50018: LD_EXP 113
50022: PUSH
50023: FOR_TO
50024: IFFALSE 50167
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50026: LD_ADDR_VAR 0 4
50030: PUSH
50031: LD_EXP 132
50035: PUSH
50036: LD_VAR 0 2
50040: ARRAY
50041: PUSH
50042: LD_EXP 135
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: UNION
50053: PPUSH
50054: LD_INT 33
50056: PUSH
50057: LD_INT 2
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PPUSH
50064: CALL_OW 72
50068: ST_TO_ADDR
// if tmp then
50069: LD_VAR 0 4
50073: IFFALSE 50165
// for j in tmp do
50075: LD_ADDR_VAR 0 3
50079: PUSH
50080: LD_VAR 0 4
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50163
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50088: LD_VAR 0 3
50092: PPUSH
50093: CALL_OW 312
50097: NOT
50098: PUSH
50099: LD_VAR 0 3
50103: PPUSH
50104: CALL_OW 256
50108: PUSH
50109: LD_INT 250
50111: GREATEREQUAL
50112: AND
50113: IFFALSE 50126
// Connect ( j ) else
50115: LD_VAR 0 3
50119: PPUSH
50120: CALL 73083 0 1
50124: GO 50161
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50126: LD_VAR 0 3
50130: PPUSH
50131: CALL_OW 256
50135: PUSH
50136: LD_INT 250
50138: LESS
50139: PUSH
50140: LD_VAR 0 3
50144: PPUSH
50145: CALL_OW 312
50149: AND
50150: IFFALSE 50161
// ComUnlink ( j ) ;
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 136
50161: GO 50085
50163: POP
50164: POP
// end ;
50165: GO 50023
50167: POP
50168: POP
// end ;
50169: LD_VAR 0 1
50173: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50174: LD_INT 0
50176: PPUSH
50177: PPUSH
50178: PPUSH
50179: PPUSH
50180: PPUSH
// if not mc_bases then
50181: LD_EXP 113
50185: NOT
50186: IFFALSE 50190
// exit ;
50188: GO 50635
// for i = 1 to mc_bases do
50190: LD_ADDR_VAR 0 2
50194: PUSH
50195: DOUBLE
50196: LD_INT 1
50198: DEC
50199: ST_TO_ADDR
50200: LD_EXP 113
50204: PUSH
50205: FOR_TO
50206: IFFALSE 50633
// begin if not mc_produce [ i ] then
50208: LD_EXP 134
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: NOT
50219: IFFALSE 50223
// continue ;
50221: GO 50205
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50223: LD_ADDR_VAR 0 5
50227: PUSH
50228: LD_EXP 113
50232: PUSH
50233: LD_VAR 0 2
50237: ARRAY
50238: PPUSH
50239: LD_INT 30
50241: PUSH
50242: LD_INT 3
50244: PUSH
50245: EMPTY
50246: LIST
50247: LIST
50248: PPUSH
50249: CALL_OW 72
50253: ST_TO_ADDR
// if not fac then
50254: LD_VAR 0 5
50258: NOT
50259: IFFALSE 50263
// continue ;
50261: GO 50205
// for j in fac do
50263: LD_ADDR_VAR 0 3
50267: PUSH
50268: LD_VAR 0 5
50272: PUSH
50273: FOR_IN
50274: IFFALSE 50629
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50276: LD_VAR 0 3
50280: PPUSH
50281: CALL_OW 461
50285: PUSH
50286: LD_INT 2
50288: NONEQUAL
50289: PUSH
50290: LD_VAR 0 3
50294: PPUSH
50295: LD_INT 15
50297: PPUSH
50298: CALL 72743 0 2
50302: PUSH
50303: LD_INT 4
50305: ARRAY
50306: OR
50307: IFFALSE 50311
// continue ;
50309: GO 50273
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50311: LD_VAR 0 3
50315: PPUSH
50316: LD_EXP 134
50320: PUSH
50321: LD_VAR 0 2
50325: ARRAY
50326: PUSH
50327: LD_INT 1
50329: ARRAY
50330: PUSH
50331: LD_INT 1
50333: ARRAY
50334: PPUSH
50335: LD_EXP 134
50339: PUSH
50340: LD_VAR 0 2
50344: ARRAY
50345: PUSH
50346: LD_INT 1
50348: ARRAY
50349: PUSH
50350: LD_INT 2
50352: ARRAY
50353: PPUSH
50354: LD_EXP 134
50358: PUSH
50359: LD_VAR 0 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PUSH
50369: LD_INT 3
50371: ARRAY
50372: PPUSH
50373: LD_EXP 134
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: PUSH
50384: LD_INT 1
50386: ARRAY
50387: PUSH
50388: LD_INT 4
50390: ARRAY
50391: PPUSH
50392: CALL_OW 448
50396: PUSH
50397: LD_VAR 0 3
50401: PPUSH
50402: LD_EXP 134
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: PUSH
50413: LD_INT 1
50415: ARRAY
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_EXP 134
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: PUSH
50432: LD_INT 1
50434: ARRAY
50435: PUSH
50436: LD_INT 2
50438: ARRAY
50439: PUSH
50440: LD_EXP 134
50444: PUSH
50445: LD_VAR 0 2
50449: ARRAY
50450: PUSH
50451: LD_INT 1
50453: ARRAY
50454: PUSH
50455: LD_INT 3
50457: ARRAY
50458: PUSH
50459: LD_EXP 134
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_INT 1
50472: ARRAY
50473: PUSH
50474: LD_INT 4
50476: ARRAY
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: PPUSH
50484: CALL 76414 0 2
50488: AND
50489: IFFALSE 50627
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50491: LD_VAR 0 3
50495: PPUSH
50496: LD_EXP 134
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PUSH
50507: LD_INT 1
50509: ARRAY
50510: PUSH
50511: LD_INT 1
50513: ARRAY
50514: PPUSH
50515: LD_EXP 134
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: PUSH
50526: LD_INT 1
50528: ARRAY
50529: PUSH
50530: LD_INT 2
50532: ARRAY
50533: PPUSH
50534: LD_EXP 134
50538: PUSH
50539: LD_VAR 0 2
50543: ARRAY
50544: PUSH
50545: LD_INT 1
50547: ARRAY
50548: PUSH
50549: LD_INT 3
50551: ARRAY
50552: PPUSH
50553: LD_EXP 134
50557: PUSH
50558: LD_VAR 0 2
50562: ARRAY
50563: PUSH
50564: LD_INT 1
50566: ARRAY
50567: PUSH
50568: LD_INT 4
50570: ARRAY
50571: PPUSH
50572: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50576: LD_ADDR_VAR 0 4
50580: PUSH
50581: LD_EXP 134
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PPUSH
50592: LD_INT 1
50594: PPUSH
50595: CALL_OW 3
50599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50600: LD_ADDR_EXP 134
50604: PUSH
50605: LD_EXP 134
50609: PPUSH
50610: LD_VAR 0 2
50614: PPUSH
50615: LD_VAR 0 4
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// break ;
50625: GO 50629
// end ; end ;
50627: GO 50273
50629: POP
50630: POP
// end ;
50631: GO 50205
50633: POP
50634: POP
// end ;
50635: LD_VAR 0 1
50639: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50640: LD_INT 0
50642: PPUSH
50643: PPUSH
50644: PPUSH
// if not mc_bases then
50645: LD_EXP 113
50649: NOT
50650: IFFALSE 50654
// exit ;
50652: GO 50743
// for i = 1 to mc_bases do
50654: LD_ADDR_VAR 0 2
50658: PUSH
50659: DOUBLE
50660: LD_INT 1
50662: DEC
50663: ST_TO_ADDR
50664: LD_EXP 113
50668: PUSH
50669: FOR_TO
50670: IFFALSE 50741
// begin if mc_attack [ i ] then
50672: LD_EXP 133
50676: PUSH
50677: LD_VAR 0 2
50681: ARRAY
50682: IFFALSE 50739
// begin tmp := mc_attack [ i ] [ 1 ] ;
50684: LD_ADDR_VAR 0 3
50688: PUSH
50689: LD_EXP 133
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PUSH
50700: LD_INT 1
50702: ARRAY
50703: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50704: LD_ADDR_EXP 133
50708: PUSH
50709: LD_EXP 133
50713: PPUSH
50714: LD_VAR 0 2
50718: PPUSH
50719: EMPTY
50720: PPUSH
50721: CALL_OW 1
50725: ST_TO_ADDR
// Attack ( tmp ) ;
50726: LD_VAR 0 3
50730: PPUSH
50731: CALL 119590 0 1
// exit ;
50735: POP
50736: POP
50737: GO 50743
// end ; end ;
50739: GO 50669
50741: POP
50742: POP
// end ;
50743: LD_VAR 0 1
50747: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
50752: PPUSH
50753: PPUSH
50754: PPUSH
50755: PPUSH
50756: PPUSH
// if not mc_bases then
50757: LD_EXP 113
50761: NOT
50762: IFFALSE 50766
// exit ;
50764: GO 51370
// for i = 1 to mc_bases do
50766: LD_ADDR_VAR 0 2
50770: PUSH
50771: DOUBLE
50772: LD_INT 1
50774: DEC
50775: ST_TO_ADDR
50776: LD_EXP 113
50780: PUSH
50781: FOR_TO
50782: IFFALSE 51368
// begin if not mc_bases [ i ] then
50784: LD_EXP 113
50788: PUSH
50789: LD_VAR 0 2
50793: ARRAY
50794: NOT
50795: IFFALSE 50799
// continue ;
50797: GO 50781
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50799: LD_ADDR_VAR 0 7
50803: PUSH
50804: LD_EXP 113
50808: PUSH
50809: LD_VAR 0 2
50813: ARRAY
50814: PUSH
50815: LD_INT 1
50817: ARRAY
50818: PPUSH
50819: CALL 66986 0 1
50823: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50824: LD_ADDR_EXP 136
50828: PUSH
50829: LD_EXP 136
50833: PPUSH
50834: LD_VAR 0 2
50838: PPUSH
50839: LD_EXP 113
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PUSH
50850: LD_INT 1
50852: ARRAY
50853: PPUSH
50854: CALL_OW 255
50858: PPUSH
50859: LD_EXP 138
50863: PUSH
50864: LD_VAR 0 2
50868: ARRAY
50869: PPUSH
50870: CALL 66951 0 2
50874: PPUSH
50875: CALL_OW 1
50879: ST_TO_ADDR
// if not mc_scan [ i ] then
50880: LD_EXP 136
50884: PUSH
50885: LD_VAR 0 2
50889: ARRAY
50890: NOT
50891: IFFALSE 51046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50893: LD_ADDR_VAR 0 4
50897: PUSH
50898: LD_EXP 113
50902: PUSH
50903: LD_VAR 0 2
50907: ARRAY
50908: PPUSH
50909: LD_INT 2
50911: PUSH
50912: LD_INT 25
50914: PUSH
50915: LD_INT 5
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 25
50924: PUSH
50925: LD_INT 8
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: LD_INT 25
50934: PUSH
50935: LD_INT 9
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: PPUSH
50948: CALL_OW 72
50952: ST_TO_ADDR
// if not tmp then
50953: LD_VAR 0 4
50957: NOT
50958: IFFALSE 50962
// continue ;
50960: GO 50781
// for j in tmp do
50962: LD_ADDR_VAR 0 3
50966: PUSH
50967: LD_VAR 0 4
50971: PUSH
50972: FOR_IN
50973: IFFALSE 51044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50975: LD_VAR 0 3
50979: PPUSH
50980: CALL_OW 310
50984: PPUSH
50985: CALL_OW 266
50989: PUSH
50990: LD_INT 5
50992: EQUAL
50993: PUSH
50994: LD_VAR 0 3
50998: PPUSH
50999: CALL_OW 257
51003: PUSH
51004: LD_INT 1
51006: EQUAL
51007: AND
51008: PUSH
51009: LD_VAR 0 3
51013: PPUSH
51014: CALL_OW 459
51018: NOT
51019: AND
51020: PUSH
51021: LD_VAR 0 7
51025: AND
51026: IFFALSE 51042
// ComChangeProfession ( j , class ) ;
51028: LD_VAR 0 3
51032: PPUSH
51033: LD_VAR 0 7
51037: PPUSH
51038: CALL_OW 123
51042: GO 50972
51044: POP
51045: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51046: LD_EXP 136
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: PUSH
51057: LD_EXP 135
51061: PUSH
51062: LD_VAR 0 2
51066: ARRAY
51067: NOT
51068: AND
51069: PUSH
51070: LD_EXP 113
51074: PUSH
51075: LD_VAR 0 2
51079: ARRAY
51080: PPUSH
51081: LD_INT 30
51083: PUSH
51084: LD_INT 32
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PPUSH
51091: CALL_OW 72
51095: NOT
51096: AND
51097: PUSH
51098: LD_EXP 113
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PPUSH
51109: LD_INT 2
51111: PUSH
51112: LD_INT 30
51114: PUSH
51115: LD_INT 4
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 30
51124: PUSH
51125: LD_INT 5
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: LIST
51136: PPUSH
51137: CALL_OW 72
51141: NOT
51142: AND
51143: IFFALSE 51275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51145: LD_ADDR_VAR 0 4
51149: PUSH
51150: LD_EXP 113
51154: PUSH
51155: LD_VAR 0 2
51159: ARRAY
51160: PPUSH
51161: LD_INT 2
51163: PUSH
51164: LD_INT 25
51166: PUSH
51167: LD_INT 1
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PUSH
51174: LD_INT 25
51176: PUSH
51177: LD_INT 5
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 25
51186: PUSH
51187: LD_INT 8
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 25
51196: PUSH
51197: LD_INT 9
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: LIST
51208: LIST
51209: LIST
51210: PPUSH
51211: CALL_OW 72
51215: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51216: LD_ADDR_VAR 0 4
51220: PUSH
51221: LD_VAR 0 4
51225: PUSH
51226: LD_VAR 0 4
51230: PPUSH
51231: LD_INT 18
51233: PPUSH
51234: CALL 98711 0 2
51238: DIFF
51239: ST_TO_ADDR
// if tmp then
51240: LD_VAR 0 4
51244: IFFALSE 51275
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_VAR 0 4
51255: PPUSH
51256: LD_EXP 138
51260: PUSH
51261: LD_VAR 0 2
51265: ARRAY
51266: PPUSH
51267: CALL 124299 0 3
// exit ;
51271: POP
51272: POP
51273: GO 51370
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51275: LD_EXP 136
51279: PUSH
51280: LD_VAR 0 2
51284: ARRAY
51285: PUSH
51286: LD_EXP 135
51290: PUSH
51291: LD_VAR 0 2
51295: ARRAY
51296: AND
51297: IFFALSE 51366
// begin tmp := mc_defender [ i ] ;
51299: LD_ADDR_VAR 0 4
51303: PUSH
51304: LD_EXP 135
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51315: LD_ADDR_EXP 135
51319: PUSH
51320: LD_EXP 135
51324: PPUSH
51325: LD_VAR 0 2
51329: PPUSH
51330: EMPTY
51331: PPUSH
51332: CALL_OW 1
51336: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51337: LD_VAR 0 2
51341: PPUSH
51342: LD_VAR 0 4
51346: PPUSH
51347: LD_EXP 136
51351: PUSH
51352: LD_VAR 0 2
51356: ARRAY
51357: PPUSH
51358: CALL 124860 0 3
// exit ;
51362: POP
51363: POP
51364: GO 51370
// end ; end ;
51366: GO 50781
51368: POP
51369: POP
// end ;
51370: LD_VAR 0 1
51374: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51375: LD_INT 0
51377: PPUSH
51378: PPUSH
51379: PPUSH
51380: PPUSH
51381: PPUSH
51382: PPUSH
51383: PPUSH
51384: PPUSH
51385: PPUSH
51386: PPUSH
51387: PPUSH
// if not mc_bases then
51388: LD_EXP 113
51392: NOT
51393: IFFALSE 51397
// exit ;
51395: GO 52484
// for i = 1 to mc_bases do
51397: LD_ADDR_VAR 0 2
51401: PUSH
51402: DOUBLE
51403: LD_INT 1
51405: DEC
51406: ST_TO_ADDR
51407: LD_EXP 113
51411: PUSH
51412: FOR_TO
51413: IFFALSE 52482
// begin tmp := mc_lab [ i ] ;
51415: LD_ADDR_VAR 0 6
51419: PUSH
51420: LD_EXP 146
51424: PUSH
51425: LD_VAR 0 2
51429: ARRAY
51430: ST_TO_ADDR
// if not tmp then
51431: LD_VAR 0 6
51435: NOT
51436: IFFALSE 51440
// continue ;
51438: GO 51412
// idle_lab := 0 ;
51440: LD_ADDR_VAR 0 11
51444: PUSH
51445: LD_INT 0
51447: ST_TO_ADDR
// for j in tmp do
51448: LD_ADDR_VAR 0 3
51452: PUSH
51453: LD_VAR 0 6
51457: PUSH
51458: FOR_IN
51459: IFFALSE 52478
// begin researching := false ;
51461: LD_ADDR_VAR 0 10
51465: PUSH
51466: LD_INT 0
51468: ST_TO_ADDR
// side := GetSide ( j ) ;
51469: LD_ADDR_VAR 0 4
51473: PUSH
51474: LD_VAR 0 3
51478: PPUSH
51479: CALL_OW 255
51483: ST_TO_ADDR
// if not mc_tech [ side ] then
51484: LD_EXP 140
51488: PUSH
51489: LD_VAR 0 4
51493: ARRAY
51494: NOT
51495: IFFALSE 51499
// continue ;
51497: GO 51458
// if BuildingStatus ( j ) = bs_idle then
51499: LD_VAR 0 3
51503: PPUSH
51504: CALL_OW 461
51508: PUSH
51509: LD_INT 2
51511: EQUAL
51512: IFFALSE 51700
// begin if idle_lab and UnitsInside ( j ) < 6 then
51514: LD_VAR 0 11
51518: PUSH
51519: LD_VAR 0 3
51523: PPUSH
51524: CALL_OW 313
51528: PUSH
51529: LD_INT 6
51531: LESS
51532: AND
51533: IFFALSE 51604
// begin tmp2 := UnitsInside ( idle_lab ) ;
51535: LD_ADDR_VAR 0 9
51539: PUSH
51540: LD_VAR 0 11
51544: PPUSH
51545: CALL_OW 313
51549: ST_TO_ADDR
// if tmp2 then
51550: LD_VAR 0 9
51554: IFFALSE 51596
// for x in tmp2 do
51556: LD_ADDR_VAR 0 7
51560: PUSH
51561: LD_VAR 0 9
51565: PUSH
51566: FOR_IN
51567: IFFALSE 51594
// begin ComExitBuilding ( x ) ;
51569: LD_VAR 0 7
51573: PPUSH
51574: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51578: LD_VAR 0 7
51582: PPUSH
51583: LD_VAR 0 3
51587: PPUSH
51588: CALL_OW 180
// end ;
51592: GO 51566
51594: POP
51595: POP
// idle_lab := 0 ;
51596: LD_ADDR_VAR 0 11
51600: PUSH
51601: LD_INT 0
51603: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51604: LD_ADDR_VAR 0 5
51608: PUSH
51609: LD_EXP 140
51613: PUSH
51614: LD_VAR 0 4
51618: ARRAY
51619: PUSH
51620: FOR_IN
51621: IFFALSE 51681
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51623: LD_VAR 0 3
51627: PPUSH
51628: LD_VAR 0 5
51632: PPUSH
51633: CALL_OW 430
51637: PUSH
51638: LD_VAR 0 4
51642: PPUSH
51643: LD_VAR 0 5
51647: PPUSH
51648: CALL 66056 0 2
51652: AND
51653: IFFALSE 51679
// begin researching := true ;
51655: LD_ADDR_VAR 0 10
51659: PUSH
51660: LD_INT 1
51662: ST_TO_ADDR
// ComResearch ( j , t ) ;
51663: LD_VAR 0 3
51667: PPUSH
51668: LD_VAR 0 5
51672: PPUSH
51673: CALL_OW 124
// break ;
51677: GO 51681
// end ;
51679: GO 51620
51681: POP
51682: POP
// if not researching then
51683: LD_VAR 0 10
51687: NOT
51688: IFFALSE 51700
// idle_lab := j ;
51690: LD_ADDR_VAR 0 11
51694: PUSH
51695: LD_VAR 0 3
51699: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51700: LD_VAR 0 3
51704: PPUSH
51705: CALL_OW 461
51709: PUSH
51710: LD_INT 10
51712: EQUAL
51713: IFFALSE 52301
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51715: LD_EXP 142
51719: PUSH
51720: LD_VAR 0 2
51724: ARRAY
51725: NOT
51726: PUSH
51727: LD_EXP 143
51731: PUSH
51732: LD_VAR 0 2
51736: ARRAY
51737: NOT
51738: AND
51739: PUSH
51740: LD_EXP 140
51744: PUSH
51745: LD_VAR 0 4
51749: ARRAY
51750: PUSH
51751: LD_INT 1
51753: GREATER
51754: AND
51755: IFFALSE 51886
// begin ComCancel ( j ) ;
51757: LD_VAR 0 3
51761: PPUSH
51762: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51766: LD_ADDR_EXP 140
51770: PUSH
51771: LD_EXP 140
51775: PPUSH
51776: LD_VAR 0 4
51780: PPUSH
51781: LD_EXP 140
51785: PUSH
51786: LD_VAR 0 4
51790: ARRAY
51791: PPUSH
51792: LD_EXP 140
51796: PUSH
51797: LD_VAR 0 4
51801: ARRAY
51802: PUSH
51803: LD_INT 1
51805: MINUS
51806: PPUSH
51807: LD_EXP 140
51811: PUSH
51812: LD_VAR 0 4
51816: ARRAY
51817: PPUSH
51818: LD_INT 0
51820: PPUSH
51821: CALL 69568 0 4
51825: PPUSH
51826: CALL_OW 1
51830: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51831: LD_ADDR_EXP 140
51835: PUSH
51836: LD_EXP 140
51840: PPUSH
51841: LD_VAR 0 4
51845: PPUSH
51846: LD_EXP 140
51850: PUSH
51851: LD_VAR 0 4
51855: ARRAY
51856: PPUSH
51857: LD_EXP 140
51861: PUSH
51862: LD_VAR 0 4
51866: ARRAY
51867: PPUSH
51868: LD_INT 1
51870: PPUSH
51871: LD_INT 0
51873: PPUSH
51874: CALL 69568 0 4
51878: PPUSH
51879: CALL_OW 1
51883: ST_TO_ADDR
// continue ;
51884: GO 51458
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51886: LD_EXP 142
51890: PUSH
51891: LD_VAR 0 2
51895: ARRAY
51896: PUSH
51897: LD_EXP 143
51901: PUSH
51902: LD_VAR 0 2
51906: ARRAY
51907: NOT
51908: AND
51909: IFFALSE 52036
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51911: LD_ADDR_EXP 143
51915: PUSH
51916: LD_EXP 143
51920: PPUSH
51921: LD_VAR 0 2
51925: PUSH
51926: LD_EXP 143
51930: PUSH
51931: LD_VAR 0 2
51935: ARRAY
51936: PUSH
51937: LD_INT 1
51939: PLUS
51940: PUSH
51941: EMPTY
51942: LIST
51943: LIST
51944: PPUSH
51945: LD_EXP 142
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PUSH
51956: LD_INT 1
51958: ARRAY
51959: PPUSH
51960: CALL 70150 0 3
51964: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51965: LD_EXP 142
51969: PUSH
51970: LD_VAR 0 2
51974: ARRAY
51975: PUSH
51976: LD_INT 1
51978: ARRAY
51979: PPUSH
51980: LD_INT 112
51982: PPUSH
51983: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51987: LD_ADDR_VAR 0 9
51991: PUSH
51992: LD_EXP 142
51996: PUSH
51997: LD_VAR 0 2
52001: ARRAY
52002: PPUSH
52003: LD_INT 1
52005: PPUSH
52006: CALL_OW 3
52010: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52011: LD_ADDR_EXP 142
52015: PUSH
52016: LD_EXP 142
52020: PPUSH
52021: LD_VAR 0 2
52025: PPUSH
52026: LD_VAR 0 9
52030: PPUSH
52031: CALL_OW 1
52035: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52036: LD_EXP 142
52040: PUSH
52041: LD_VAR 0 2
52045: ARRAY
52046: PUSH
52047: LD_EXP 143
52051: PUSH
52052: LD_VAR 0 2
52056: ARRAY
52057: AND
52058: PUSH
52059: LD_EXP 143
52063: PUSH
52064: LD_VAR 0 2
52068: ARRAY
52069: PUSH
52070: LD_INT 1
52072: ARRAY
52073: PPUSH
52074: CALL_OW 310
52078: NOT
52079: AND
52080: PUSH
52081: LD_VAR 0 3
52085: PPUSH
52086: CALL_OW 313
52090: PUSH
52091: LD_INT 6
52093: EQUAL
52094: AND
52095: IFFALSE 52151
// begin tmp2 := UnitsInside ( j ) ;
52097: LD_ADDR_VAR 0 9
52101: PUSH
52102: LD_VAR 0 3
52106: PPUSH
52107: CALL_OW 313
52111: ST_TO_ADDR
// if tmp2 = 6 then
52112: LD_VAR 0 9
52116: PUSH
52117: LD_INT 6
52119: EQUAL
52120: IFFALSE 52151
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52122: LD_VAR 0 9
52126: PUSH
52127: LD_INT 1
52129: ARRAY
52130: PPUSH
52131: LD_INT 112
52133: PPUSH
52134: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52138: LD_VAR 0 9
52142: PUSH
52143: LD_INT 1
52145: ARRAY
52146: PPUSH
52147: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52151: LD_EXP 143
52155: PUSH
52156: LD_VAR 0 2
52160: ARRAY
52161: PUSH
52162: LD_EXP 143
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 314
52181: NOT
52182: AND
52183: PUSH
52184: LD_EXP 143
52188: PUSH
52189: LD_VAR 0 2
52193: ARRAY
52194: PUSH
52195: LD_INT 1
52197: ARRAY
52198: PPUSH
52199: CALL_OW 310
52203: NOT
52204: AND
52205: IFFALSE 52231
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52207: LD_EXP 143
52211: PUSH
52212: LD_VAR 0 2
52216: ARRAY
52217: PUSH
52218: LD_INT 1
52220: ARRAY
52221: PPUSH
52222: LD_VAR 0 3
52226: PPUSH
52227: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52231: LD_EXP 143
52235: PUSH
52236: LD_VAR 0 2
52240: ARRAY
52241: PUSH
52242: LD_INT 1
52244: ARRAY
52245: PPUSH
52246: CALL_OW 310
52250: PUSH
52251: LD_EXP 143
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PUSH
52262: LD_INT 1
52264: ARRAY
52265: PPUSH
52266: CALL_OW 310
52270: PPUSH
52271: CALL_OW 461
52275: PUSH
52276: LD_INT 3
52278: NONEQUAL
52279: AND
52280: IFFALSE 52301
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52282: LD_EXP 143
52286: PUSH
52287: LD_VAR 0 2
52291: ARRAY
52292: PUSH
52293: LD_INT 1
52295: ARRAY
52296: PPUSH
52297: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52301: LD_VAR 0 3
52305: PPUSH
52306: CALL_OW 461
52310: PUSH
52311: LD_INT 6
52313: EQUAL
52314: PUSH
52315: LD_VAR 0 6
52319: PUSH
52320: LD_INT 1
52322: GREATER
52323: AND
52324: IFFALSE 52476
// begin sci := [ ] ;
52326: LD_ADDR_VAR 0 8
52330: PUSH
52331: EMPTY
52332: ST_TO_ADDR
// for x in ( tmp diff j ) do
52333: LD_ADDR_VAR 0 7
52337: PUSH
52338: LD_VAR 0 6
52342: PUSH
52343: LD_VAR 0 3
52347: DIFF
52348: PUSH
52349: FOR_IN
52350: IFFALSE 52402
// begin if sci = 6 then
52352: LD_VAR 0 8
52356: PUSH
52357: LD_INT 6
52359: EQUAL
52360: IFFALSE 52364
// break ;
52362: GO 52402
// if BuildingStatus ( x ) = bs_idle then
52364: LD_VAR 0 7
52368: PPUSH
52369: CALL_OW 461
52373: PUSH
52374: LD_INT 2
52376: EQUAL
52377: IFFALSE 52400
// sci := sci ^ UnitsInside ( x ) ;
52379: LD_ADDR_VAR 0 8
52383: PUSH
52384: LD_VAR 0 8
52388: PUSH
52389: LD_VAR 0 7
52393: PPUSH
52394: CALL_OW 313
52398: ADD
52399: ST_TO_ADDR
// end ;
52400: GO 52349
52402: POP
52403: POP
// if not sci then
52404: LD_VAR 0 8
52408: NOT
52409: IFFALSE 52413
// continue ;
52411: GO 51458
// for x in sci do
52413: LD_ADDR_VAR 0 7
52417: PUSH
52418: LD_VAR 0 8
52422: PUSH
52423: FOR_IN
52424: IFFALSE 52474
// if IsInUnit ( x ) and not HasTask ( x ) then
52426: LD_VAR 0 7
52430: PPUSH
52431: CALL_OW 310
52435: PUSH
52436: LD_VAR 0 7
52440: PPUSH
52441: CALL_OW 314
52445: NOT
52446: AND
52447: IFFALSE 52472
// begin ComExitBuilding ( x ) ;
52449: LD_VAR 0 7
52453: PPUSH
52454: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52458: LD_VAR 0 7
52462: PPUSH
52463: LD_VAR 0 3
52467: PPUSH
52468: CALL_OW 180
// end ;
52472: GO 52423
52474: POP
52475: POP
// end ; end ;
52476: GO 51458
52478: POP
52479: POP
// end ;
52480: GO 51412
52482: POP
52483: POP
// end ;
52484: LD_VAR 0 1
52488: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52489: LD_INT 0
52491: PPUSH
52492: PPUSH
// if not mc_bases then
52493: LD_EXP 113
52497: NOT
52498: IFFALSE 52502
// exit ;
52500: GO 52583
// for i = 1 to mc_bases do
52502: LD_ADDR_VAR 0 2
52506: PUSH
52507: DOUBLE
52508: LD_INT 1
52510: DEC
52511: ST_TO_ADDR
52512: LD_EXP 113
52516: PUSH
52517: FOR_TO
52518: IFFALSE 52581
// if mc_mines [ i ] and mc_miners [ i ] then
52520: LD_EXP 126
52524: PUSH
52525: LD_VAR 0 2
52529: ARRAY
52530: PUSH
52531: LD_EXP 127
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: AND
52542: IFFALSE 52579
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52544: LD_EXP 127
52548: PUSH
52549: LD_VAR 0 2
52553: ARRAY
52554: PUSH
52555: LD_INT 1
52557: ARRAY
52558: PPUSH
52559: CALL_OW 255
52563: PPUSH
52564: LD_EXP 126
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PPUSH
52575: CALL 67139 0 2
52579: GO 52517
52581: POP
52582: POP
// end ;
52583: LD_VAR 0 1
52587: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52588: LD_INT 0
52590: PPUSH
52591: PPUSH
52592: PPUSH
52593: PPUSH
52594: PPUSH
52595: PPUSH
52596: PPUSH
52597: PPUSH
// if not mc_bases or not mc_parking then
52598: LD_EXP 113
52602: NOT
52603: PUSH
52604: LD_EXP 137
52608: NOT
52609: OR
52610: IFFALSE 52614
// exit ;
52612: GO 53313
// for i = 1 to mc_bases do
52614: LD_ADDR_VAR 0 2
52618: PUSH
52619: DOUBLE
52620: LD_INT 1
52622: DEC
52623: ST_TO_ADDR
52624: LD_EXP 113
52628: PUSH
52629: FOR_TO
52630: IFFALSE 53311
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52632: LD_EXP 113
52636: PUSH
52637: LD_VAR 0 2
52641: ARRAY
52642: NOT
52643: PUSH
52644: LD_EXP 137
52648: PUSH
52649: LD_VAR 0 2
52653: ARRAY
52654: NOT
52655: OR
52656: IFFALSE 52660
// continue ;
52658: GO 52629
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52660: LD_ADDR_VAR 0 5
52664: PUSH
52665: LD_EXP 113
52669: PUSH
52670: LD_VAR 0 2
52674: ARRAY
52675: PUSH
52676: LD_INT 1
52678: ARRAY
52679: PPUSH
52680: CALL_OW 255
52684: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52685: LD_ADDR_VAR 0 6
52689: PUSH
52690: LD_EXP 113
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PPUSH
52701: LD_INT 30
52703: PUSH
52704: LD_INT 3
52706: PUSH
52707: EMPTY
52708: LIST
52709: LIST
52710: PPUSH
52711: CALL_OW 72
52715: ST_TO_ADDR
// if not fac then
52716: LD_VAR 0 6
52720: NOT
52721: IFFALSE 52772
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52723: LD_ADDR_VAR 0 6
52727: PUSH
52728: LD_EXP 113
52732: PUSH
52733: LD_VAR 0 2
52737: ARRAY
52738: PPUSH
52739: LD_INT 2
52741: PUSH
52742: LD_INT 30
52744: PUSH
52745: LD_INT 0
52747: PUSH
52748: EMPTY
52749: LIST
52750: LIST
52751: PUSH
52752: LD_INT 30
52754: PUSH
52755: LD_INT 1
52757: PUSH
52758: EMPTY
52759: LIST
52760: LIST
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: LIST
52766: PPUSH
52767: CALL_OW 72
52771: ST_TO_ADDR
// if not fac then
52772: LD_VAR 0 6
52776: NOT
52777: IFFALSE 52781
// continue ;
52779: GO 52629
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52781: LD_ADDR_VAR 0 7
52785: PUSH
52786: LD_EXP 137
52790: PUSH
52791: LD_VAR 0 2
52795: ARRAY
52796: PPUSH
52797: LD_INT 22
52799: PUSH
52800: LD_VAR 0 5
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 21
52811: PUSH
52812: LD_INT 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 3
52821: PUSH
52822: LD_INT 24
52824: PUSH
52825: LD_INT 1000
52827: PUSH
52828: EMPTY
52829: LIST
52830: LIST
52831: PUSH
52832: EMPTY
52833: LIST
52834: LIST
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: LIST
52840: PPUSH
52841: CALL_OW 70
52845: ST_TO_ADDR
// for j in fac do
52846: LD_ADDR_VAR 0 3
52850: PUSH
52851: LD_VAR 0 6
52855: PUSH
52856: FOR_IN
52857: IFFALSE 52938
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52859: LD_ADDR_VAR 0 7
52863: PUSH
52864: LD_VAR 0 7
52868: PUSH
52869: LD_INT 22
52871: PUSH
52872: LD_VAR 0 5
52876: PUSH
52877: EMPTY
52878: LIST
52879: LIST
52880: PUSH
52881: LD_INT 91
52883: PUSH
52884: LD_VAR 0 3
52888: PUSH
52889: LD_INT 15
52891: PUSH
52892: EMPTY
52893: LIST
52894: LIST
52895: LIST
52896: PUSH
52897: LD_INT 21
52899: PUSH
52900: LD_INT 2
52902: PUSH
52903: EMPTY
52904: LIST
52905: LIST
52906: PUSH
52907: LD_INT 3
52909: PUSH
52910: LD_INT 24
52912: PUSH
52913: LD_INT 1000
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: PUSH
52924: EMPTY
52925: LIST
52926: LIST
52927: LIST
52928: LIST
52929: PPUSH
52930: CALL_OW 69
52934: UNION
52935: ST_TO_ADDR
52936: GO 52856
52938: POP
52939: POP
// if not vehs then
52940: LD_VAR 0 7
52944: NOT
52945: IFFALSE 52971
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52947: LD_ADDR_EXP 125
52951: PUSH
52952: LD_EXP 125
52956: PPUSH
52957: LD_VAR 0 2
52961: PPUSH
52962: EMPTY
52963: PPUSH
52964: CALL_OW 1
52968: ST_TO_ADDR
// continue ;
52969: GO 52629
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52971: LD_ADDR_VAR 0 8
52975: PUSH
52976: LD_EXP 113
52980: PUSH
52981: LD_VAR 0 2
52985: ARRAY
52986: PPUSH
52987: LD_INT 30
52989: PUSH
52990: LD_INT 3
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: PPUSH
52997: CALL_OW 72
53001: ST_TO_ADDR
// if tmp then
53002: LD_VAR 0 8
53006: IFFALSE 53109
// begin for j in tmp do
53008: LD_ADDR_VAR 0 3
53012: PUSH
53013: LD_VAR 0 8
53017: PUSH
53018: FOR_IN
53019: IFFALSE 53107
// for k in UnitsInside ( j ) do
53021: LD_ADDR_VAR 0 4
53025: PUSH
53026: LD_VAR 0 3
53030: PPUSH
53031: CALL_OW 313
53035: PUSH
53036: FOR_IN
53037: IFFALSE 53103
// if k then
53039: LD_VAR 0 4
53043: IFFALSE 53101
// if not k in mc_repair_vehicle [ i ] then
53045: LD_VAR 0 4
53049: PUSH
53050: LD_EXP 125
53054: PUSH
53055: LD_VAR 0 2
53059: ARRAY
53060: IN
53061: NOT
53062: IFFALSE 53101
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53064: LD_ADDR_EXP 125
53068: PUSH
53069: LD_EXP 125
53073: PPUSH
53074: LD_VAR 0 2
53078: PPUSH
53079: LD_EXP 125
53083: PUSH
53084: LD_VAR 0 2
53088: ARRAY
53089: PUSH
53090: LD_VAR 0 4
53094: UNION
53095: PPUSH
53096: CALL_OW 1
53100: ST_TO_ADDR
53101: GO 53036
53103: POP
53104: POP
53105: GO 53018
53107: POP
53108: POP
// end ; if not mc_repair_vehicle [ i ] then
53109: LD_EXP 125
53113: PUSH
53114: LD_VAR 0 2
53118: ARRAY
53119: NOT
53120: IFFALSE 53124
// continue ;
53122: GO 52629
// for j in mc_repair_vehicle [ i ] do
53124: LD_ADDR_VAR 0 3
53128: PUSH
53129: LD_EXP 125
53133: PUSH
53134: LD_VAR 0 2
53138: ARRAY
53139: PUSH
53140: FOR_IN
53141: IFFALSE 53307
// begin if GetClass ( j ) <> 3 then
53143: LD_VAR 0 3
53147: PPUSH
53148: CALL_OW 257
53152: PUSH
53153: LD_INT 3
53155: NONEQUAL
53156: IFFALSE 53197
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53158: LD_ADDR_EXP 125
53162: PUSH
53163: LD_EXP 125
53167: PPUSH
53168: LD_VAR 0 2
53172: PPUSH
53173: LD_EXP 125
53177: PUSH
53178: LD_VAR 0 2
53182: ARRAY
53183: PUSH
53184: LD_VAR 0 3
53188: DIFF
53189: PPUSH
53190: CALL_OW 1
53194: ST_TO_ADDR
// continue ;
53195: GO 53140
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53197: LD_VAR 0 3
53201: PPUSH
53202: CALL_OW 311
53206: NOT
53207: PUSH
53208: LD_VAR 0 3
53212: PUSH
53213: LD_EXP 116
53217: PUSH
53218: LD_VAR 0 2
53222: ARRAY
53223: PUSH
53224: LD_INT 1
53226: ARRAY
53227: IN
53228: NOT
53229: AND
53230: PUSH
53231: LD_VAR 0 3
53235: PUSH
53236: LD_EXP 116
53240: PUSH
53241: LD_VAR 0 2
53245: ARRAY
53246: PUSH
53247: LD_INT 2
53249: ARRAY
53250: IN
53251: NOT
53252: AND
53253: IFFALSE 53305
// begin if IsInUnit ( j ) then
53255: LD_VAR 0 3
53259: PPUSH
53260: CALL_OW 310
53264: IFFALSE 53275
// ComExitBuilding ( j ) ;
53266: LD_VAR 0 3
53270: PPUSH
53271: CALL_OW 122
// if not HasTask ( j ) then
53275: LD_VAR 0 3
53279: PPUSH
53280: CALL_OW 314
53284: NOT
53285: IFFALSE 53305
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53287: LD_VAR 0 3
53291: PPUSH
53292: LD_VAR 0 7
53296: PUSH
53297: LD_INT 1
53299: ARRAY
53300: PPUSH
53301: CALL_OW 189
// end ; end ;
53305: GO 53140
53307: POP
53308: POP
// end ;
53309: GO 52629
53311: POP
53312: POP
// end ;
53313: LD_VAR 0 1
53317: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53318: LD_INT 0
53320: PPUSH
53321: PPUSH
53322: PPUSH
53323: PPUSH
53324: PPUSH
53325: PPUSH
53326: PPUSH
53327: PPUSH
53328: PPUSH
53329: PPUSH
53330: PPUSH
// if not mc_bases then
53331: LD_EXP 113
53335: NOT
53336: IFFALSE 53340
// exit ;
53338: GO 54142
// for i = 1 to mc_bases do
53340: LD_ADDR_VAR 0 2
53344: PUSH
53345: DOUBLE
53346: LD_INT 1
53348: DEC
53349: ST_TO_ADDR
53350: LD_EXP 113
53354: PUSH
53355: FOR_TO
53356: IFFALSE 54140
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53358: LD_EXP 141
53362: PUSH
53363: LD_VAR 0 2
53367: ARRAY
53368: NOT
53369: PUSH
53370: LD_EXP 116
53374: PUSH
53375: LD_VAR 0 2
53379: ARRAY
53380: PUSH
53381: LD_INT 1
53383: ARRAY
53384: OR
53385: PUSH
53386: LD_EXP 116
53390: PUSH
53391: LD_VAR 0 2
53395: ARRAY
53396: PUSH
53397: LD_INT 2
53399: ARRAY
53400: OR
53401: PUSH
53402: LD_EXP 139
53406: PUSH
53407: LD_VAR 0 2
53411: ARRAY
53412: PPUSH
53413: LD_INT 1
53415: PPUSH
53416: CALL_OW 325
53420: NOT
53421: OR
53422: PUSH
53423: LD_EXP 136
53427: PUSH
53428: LD_VAR 0 2
53432: ARRAY
53433: OR
53434: IFFALSE 53438
// continue ;
53436: GO 53355
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53438: LD_ADDR_VAR 0 8
53442: PUSH
53443: LD_EXP 113
53447: PUSH
53448: LD_VAR 0 2
53452: ARRAY
53453: PPUSH
53454: LD_INT 25
53456: PUSH
53457: LD_INT 4
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: LD_INT 50
53466: PUSH
53467: EMPTY
53468: LIST
53469: PUSH
53470: LD_INT 3
53472: PUSH
53473: LD_INT 60
53475: PUSH
53476: EMPTY
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: PUSH
53483: EMPTY
53484: LIST
53485: LIST
53486: LIST
53487: PPUSH
53488: CALL_OW 72
53492: PUSH
53493: LD_EXP 117
53497: PUSH
53498: LD_VAR 0 2
53502: ARRAY
53503: DIFF
53504: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53505: LD_ADDR_VAR 0 9
53509: PUSH
53510: LD_EXP 113
53514: PUSH
53515: LD_VAR 0 2
53519: ARRAY
53520: PPUSH
53521: LD_INT 2
53523: PUSH
53524: LD_INT 30
53526: PUSH
53527: LD_INT 0
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PUSH
53534: LD_INT 30
53536: PUSH
53537: LD_INT 1
53539: PUSH
53540: EMPTY
53541: LIST
53542: LIST
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: LIST
53548: PPUSH
53549: CALL_OW 72
53553: ST_TO_ADDR
// if not tmp or not dep then
53554: LD_VAR 0 8
53558: NOT
53559: PUSH
53560: LD_VAR 0 9
53564: NOT
53565: OR
53566: IFFALSE 53570
// continue ;
53568: GO 53355
// side := GetSide ( tmp [ 1 ] ) ;
53570: LD_ADDR_VAR 0 11
53574: PUSH
53575: LD_VAR 0 8
53579: PUSH
53580: LD_INT 1
53582: ARRAY
53583: PPUSH
53584: CALL_OW 255
53588: ST_TO_ADDR
// dep := dep [ 1 ] ;
53589: LD_ADDR_VAR 0 9
53593: PUSH
53594: LD_VAR 0 9
53598: PUSH
53599: LD_INT 1
53601: ARRAY
53602: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53603: LD_ADDR_VAR 0 7
53607: PUSH
53608: LD_EXP 141
53612: PUSH
53613: LD_VAR 0 2
53617: ARRAY
53618: PPUSH
53619: LD_INT 22
53621: PUSH
53622: LD_INT 0
53624: PUSH
53625: EMPTY
53626: LIST
53627: LIST
53628: PUSH
53629: LD_INT 25
53631: PUSH
53632: LD_INT 12
53634: PUSH
53635: EMPTY
53636: LIST
53637: LIST
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: PPUSH
53643: CALL_OW 70
53647: PUSH
53648: LD_INT 22
53650: PUSH
53651: LD_INT 0
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: PUSH
53658: LD_INT 25
53660: PUSH
53661: LD_INT 12
53663: PUSH
53664: EMPTY
53665: LIST
53666: LIST
53667: PUSH
53668: LD_INT 91
53670: PUSH
53671: LD_VAR 0 9
53675: PUSH
53676: LD_INT 20
53678: PUSH
53679: EMPTY
53680: LIST
53681: LIST
53682: LIST
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: LIST
53688: PPUSH
53689: CALL_OW 69
53693: UNION
53694: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53695: LD_ADDR_VAR 0 10
53699: PUSH
53700: LD_EXP 141
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PPUSH
53711: LD_INT 81
53713: PUSH
53714: LD_VAR 0 11
53718: PUSH
53719: EMPTY
53720: LIST
53721: LIST
53722: PPUSH
53723: CALL_OW 70
53727: ST_TO_ADDR
// if not apes or danger_at_area then
53728: LD_VAR 0 7
53732: NOT
53733: PUSH
53734: LD_VAR 0 10
53738: OR
53739: IFFALSE 53789
// begin if mc_taming [ i ] then
53741: LD_EXP 144
53745: PUSH
53746: LD_VAR 0 2
53750: ARRAY
53751: IFFALSE 53787
// begin MC_Reset ( i , 121 ) ;
53753: LD_VAR 0 2
53757: PPUSH
53758: LD_INT 121
53760: PPUSH
53761: CALL 39199 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53765: LD_ADDR_EXP 144
53769: PUSH
53770: LD_EXP 144
53774: PPUSH
53775: LD_VAR 0 2
53779: PPUSH
53780: EMPTY
53781: PPUSH
53782: CALL_OW 1
53786: ST_TO_ADDR
// end ; continue ;
53787: GO 53355
// end ; for j in tmp do
53789: LD_ADDR_VAR 0 3
53793: PUSH
53794: LD_VAR 0 8
53798: PUSH
53799: FOR_IN
53800: IFFALSE 54136
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53802: LD_VAR 0 3
53806: PUSH
53807: LD_EXP 144
53811: PUSH
53812: LD_VAR 0 2
53816: ARRAY
53817: IN
53818: NOT
53819: PUSH
53820: LD_EXP 144
53824: PUSH
53825: LD_VAR 0 2
53829: ARRAY
53830: PUSH
53831: LD_INT 3
53833: LESS
53834: AND
53835: IFFALSE 53893
// begin SetTag ( j , 121 ) ;
53837: LD_VAR 0 3
53841: PPUSH
53842: LD_INT 121
53844: PPUSH
53845: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53849: LD_ADDR_EXP 144
53853: PUSH
53854: LD_EXP 144
53858: PPUSH
53859: LD_VAR 0 2
53863: PUSH
53864: LD_EXP 144
53868: PUSH
53869: LD_VAR 0 2
53873: ARRAY
53874: PUSH
53875: LD_INT 1
53877: PLUS
53878: PUSH
53879: EMPTY
53880: LIST
53881: LIST
53882: PPUSH
53883: LD_VAR 0 3
53887: PPUSH
53888: CALL 70150 0 3
53892: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53893: LD_VAR 0 3
53897: PUSH
53898: LD_EXP 144
53902: PUSH
53903: LD_VAR 0 2
53907: ARRAY
53908: IN
53909: IFFALSE 54134
// begin if GetClass ( j ) <> 4 then
53911: LD_VAR 0 3
53915: PPUSH
53916: CALL_OW 257
53920: PUSH
53921: LD_INT 4
53923: NONEQUAL
53924: IFFALSE 53977
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53926: LD_ADDR_EXP 144
53930: PUSH
53931: LD_EXP 144
53935: PPUSH
53936: LD_VAR 0 2
53940: PPUSH
53941: LD_EXP 144
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: PUSH
53952: LD_VAR 0 3
53956: DIFF
53957: PPUSH
53958: CALL_OW 1
53962: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53963: LD_VAR 0 3
53967: PPUSH
53968: LD_INT 0
53970: PPUSH
53971: CALL_OW 109
// continue ;
53975: GO 53799
// end ; if IsInUnit ( j ) then
53977: LD_VAR 0 3
53981: PPUSH
53982: CALL_OW 310
53986: IFFALSE 53997
// ComExitBuilding ( j ) ;
53988: LD_VAR 0 3
53992: PPUSH
53993: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53997: LD_ADDR_VAR 0 6
54001: PUSH
54002: LD_VAR 0 7
54006: PPUSH
54007: LD_VAR 0 3
54011: PPUSH
54012: CALL_OW 74
54016: ST_TO_ADDR
// if not ape then
54017: LD_VAR 0 6
54021: NOT
54022: IFFALSE 54026
// break ;
54024: GO 54136
// x := GetX ( ape ) ;
54026: LD_ADDR_VAR 0 4
54030: PUSH
54031: LD_VAR 0 6
54035: PPUSH
54036: CALL_OW 250
54040: ST_TO_ADDR
// y := GetY ( ape ) ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 6
54050: PPUSH
54051: CALL_OW 251
54055: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54056: LD_VAR 0 4
54060: PPUSH
54061: LD_VAR 0 5
54065: PPUSH
54066: CALL_OW 488
54070: NOT
54071: PUSH
54072: LD_VAR 0 11
54076: PPUSH
54077: LD_VAR 0 4
54081: PPUSH
54082: LD_VAR 0 5
54086: PPUSH
54087: LD_INT 20
54089: PPUSH
54090: CALL 71046 0 4
54094: PUSH
54095: LD_INT 4
54097: ARRAY
54098: OR
54099: IFFALSE 54103
// break ;
54101: GO 54136
// if not HasTask ( j ) then
54103: LD_VAR 0 3
54107: PPUSH
54108: CALL_OW 314
54112: NOT
54113: IFFALSE 54134
// ComTameXY ( j , x , y ) ;
54115: LD_VAR 0 3
54119: PPUSH
54120: LD_VAR 0 4
54124: PPUSH
54125: LD_VAR 0 5
54129: PPUSH
54130: CALL_OW 131
// end ; end ;
54134: GO 53799
54136: POP
54137: POP
// end ;
54138: GO 53355
54140: POP
54141: POP
// end ;
54142: LD_VAR 0 1
54146: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54147: LD_INT 0
54149: PPUSH
54150: PPUSH
54151: PPUSH
54152: PPUSH
54153: PPUSH
54154: PPUSH
54155: PPUSH
54156: PPUSH
// if not mc_bases then
54157: LD_EXP 113
54161: NOT
54162: IFFALSE 54166
// exit ;
54164: GO 54792
// for i = 1 to mc_bases do
54166: LD_ADDR_VAR 0 2
54170: PUSH
54171: DOUBLE
54172: LD_INT 1
54174: DEC
54175: ST_TO_ADDR
54176: LD_EXP 113
54180: PUSH
54181: FOR_TO
54182: IFFALSE 54790
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54184: LD_EXP 142
54188: PUSH
54189: LD_VAR 0 2
54193: ARRAY
54194: NOT
54195: PUSH
54196: LD_EXP 142
54200: PUSH
54201: LD_VAR 0 2
54205: ARRAY
54206: PPUSH
54207: LD_INT 25
54209: PUSH
54210: LD_INT 12
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PPUSH
54217: CALL_OW 72
54221: NOT
54222: OR
54223: IFFALSE 54227
// continue ;
54225: GO 54181
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54227: LD_ADDR_VAR 0 5
54231: PUSH
54232: LD_EXP 142
54236: PUSH
54237: LD_VAR 0 2
54241: ARRAY
54242: PUSH
54243: LD_INT 1
54245: ARRAY
54246: PPUSH
54247: CALL_OW 255
54251: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54252: LD_VAR 0 5
54256: PPUSH
54257: LD_INT 2
54259: PPUSH
54260: CALL_OW 325
54264: IFFALSE 54517
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54266: LD_ADDR_VAR 0 4
54270: PUSH
54271: LD_EXP 142
54275: PUSH
54276: LD_VAR 0 2
54280: ARRAY
54281: PPUSH
54282: LD_INT 25
54284: PUSH
54285: LD_INT 16
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: PPUSH
54292: CALL_OW 72
54296: ST_TO_ADDR
// if tmp < 6 then
54297: LD_VAR 0 4
54301: PUSH
54302: LD_INT 6
54304: LESS
54305: IFFALSE 54517
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: LD_EXP 113
54316: PUSH
54317: LD_VAR 0 2
54321: ARRAY
54322: PPUSH
54323: LD_INT 2
54325: PUSH
54326: LD_INT 30
54328: PUSH
54329: LD_INT 0
54331: PUSH
54332: EMPTY
54333: LIST
54334: LIST
54335: PUSH
54336: LD_INT 30
54338: PUSH
54339: LD_INT 1
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: LIST
54350: PPUSH
54351: CALL_OW 72
54355: ST_TO_ADDR
// if depot then
54356: LD_VAR 0 6
54360: IFFALSE 54517
// begin selected := 0 ;
54362: LD_ADDR_VAR 0 7
54366: PUSH
54367: LD_INT 0
54369: ST_TO_ADDR
// for j in depot do
54370: LD_ADDR_VAR 0 3
54374: PUSH
54375: LD_VAR 0 6
54379: PUSH
54380: FOR_IN
54381: IFFALSE 54412
// begin if UnitsInside ( j ) < 6 then
54383: LD_VAR 0 3
54387: PPUSH
54388: CALL_OW 313
54392: PUSH
54393: LD_INT 6
54395: LESS
54396: IFFALSE 54410
// begin selected := j ;
54398: LD_ADDR_VAR 0 7
54402: PUSH
54403: LD_VAR 0 3
54407: ST_TO_ADDR
// break ;
54408: GO 54412
// end ; end ;
54410: GO 54380
54412: POP
54413: POP
// if selected then
54414: LD_VAR 0 7
54418: IFFALSE 54517
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54420: LD_ADDR_VAR 0 3
54424: PUSH
54425: LD_EXP 142
54429: PUSH
54430: LD_VAR 0 2
54434: ARRAY
54435: PPUSH
54436: LD_INT 25
54438: PUSH
54439: LD_INT 12
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: PPUSH
54446: CALL_OW 72
54450: PUSH
54451: FOR_IN
54452: IFFALSE 54515
// if not HasTask ( j ) then
54454: LD_VAR 0 3
54458: PPUSH
54459: CALL_OW 314
54463: NOT
54464: IFFALSE 54513
// begin if not IsInUnit ( j ) then
54466: LD_VAR 0 3
54470: PPUSH
54471: CALL_OW 310
54475: NOT
54476: IFFALSE 54492
// ComEnterUnit ( j , selected ) ;
54478: LD_VAR 0 3
54482: PPUSH
54483: LD_VAR 0 7
54487: PPUSH
54488: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54492: LD_VAR 0 3
54496: PPUSH
54497: LD_INT 16
54499: PPUSH
54500: CALL_OW 183
// AddComExitBuilding ( j ) ;
54504: LD_VAR 0 3
54508: PPUSH
54509: CALL_OW 182
// end ;
54513: GO 54451
54515: POP
54516: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54517: LD_VAR 0 5
54521: PPUSH
54522: LD_INT 11
54524: PPUSH
54525: CALL_OW 325
54529: IFFALSE 54788
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54531: LD_ADDR_VAR 0 4
54535: PUSH
54536: LD_EXP 142
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: PPUSH
54547: LD_INT 25
54549: PUSH
54550: LD_INT 16
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: PPUSH
54557: CALL_OW 72
54561: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54562: LD_VAR 0 4
54566: PUSH
54567: LD_INT 6
54569: GREATEREQUAL
54570: PUSH
54571: LD_VAR 0 5
54575: PPUSH
54576: LD_INT 2
54578: PPUSH
54579: CALL_OW 325
54583: NOT
54584: OR
54585: IFFALSE 54788
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54587: LD_ADDR_VAR 0 8
54591: PUSH
54592: LD_EXP 113
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: PPUSH
54603: LD_INT 2
54605: PUSH
54606: LD_INT 30
54608: PUSH
54609: LD_INT 4
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: PUSH
54616: LD_INT 30
54618: PUSH
54619: LD_INT 5
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: LIST
54630: PPUSH
54631: CALL_OW 72
54635: ST_TO_ADDR
// if barracks then
54636: LD_VAR 0 8
54640: IFFALSE 54788
// begin selected := 0 ;
54642: LD_ADDR_VAR 0 7
54646: PUSH
54647: LD_INT 0
54649: ST_TO_ADDR
// for j in barracks do
54650: LD_ADDR_VAR 0 3
54654: PUSH
54655: LD_VAR 0 8
54659: PUSH
54660: FOR_IN
54661: IFFALSE 54692
// begin if UnitsInside ( j ) < 6 then
54663: LD_VAR 0 3
54667: PPUSH
54668: CALL_OW 313
54672: PUSH
54673: LD_INT 6
54675: LESS
54676: IFFALSE 54690
// begin selected := j ;
54678: LD_ADDR_VAR 0 7
54682: PUSH
54683: LD_VAR 0 3
54687: ST_TO_ADDR
// break ;
54688: GO 54692
// end ; end ;
54690: GO 54660
54692: POP
54693: POP
// if selected then
54694: LD_VAR 0 7
54698: IFFALSE 54788
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54700: LD_ADDR_VAR 0 3
54704: PUSH
54705: LD_EXP 142
54709: PUSH
54710: LD_VAR 0 2
54714: ARRAY
54715: PPUSH
54716: LD_INT 25
54718: PUSH
54719: LD_INT 12
54721: PUSH
54722: EMPTY
54723: LIST
54724: LIST
54725: PPUSH
54726: CALL_OW 72
54730: PUSH
54731: FOR_IN
54732: IFFALSE 54786
// if not IsInUnit ( j ) and not HasTask ( j ) then
54734: LD_VAR 0 3
54738: PPUSH
54739: CALL_OW 310
54743: NOT
54744: PUSH
54745: LD_VAR 0 3
54749: PPUSH
54750: CALL_OW 314
54754: NOT
54755: AND
54756: IFFALSE 54784
// begin ComEnterUnit ( j , selected ) ;
54758: LD_VAR 0 3
54762: PPUSH
54763: LD_VAR 0 7
54767: PPUSH
54768: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54772: LD_VAR 0 3
54776: PPUSH
54777: LD_INT 15
54779: PPUSH
54780: CALL_OW 183
// end ;
54784: GO 54731
54786: POP
54787: POP
// end ; end ; end ; end ; end ;
54788: GO 54181
54790: POP
54791: POP
// end ;
54792: LD_VAR 0 1
54796: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54797: LD_INT 0
54799: PPUSH
54800: PPUSH
54801: PPUSH
54802: PPUSH
// if not mc_bases then
54803: LD_EXP 113
54807: NOT
54808: IFFALSE 54812
// exit ;
54810: GO 54990
// for i = 1 to mc_bases do
54812: LD_ADDR_VAR 0 2
54816: PUSH
54817: DOUBLE
54818: LD_INT 1
54820: DEC
54821: ST_TO_ADDR
54822: LD_EXP 113
54826: PUSH
54827: FOR_TO
54828: IFFALSE 54988
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54830: LD_ADDR_VAR 0 4
54834: PUSH
54835: LD_EXP 113
54839: PUSH
54840: LD_VAR 0 2
54844: ARRAY
54845: PPUSH
54846: LD_INT 25
54848: PUSH
54849: LD_INT 9
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: PPUSH
54856: CALL_OW 72
54860: ST_TO_ADDR
// if not tmp then
54861: LD_VAR 0 4
54865: NOT
54866: IFFALSE 54870
// continue ;
54868: GO 54827
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54870: LD_EXP 139
54874: PUSH
54875: LD_VAR 0 2
54879: ARRAY
54880: PPUSH
54881: LD_INT 29
54883: PPUSH
54884: CALL_OW 325
54888: NOT
54889: PUSH
54890: LD_EXP 139
54894: PUSH
54895: LD_VAR 0 2
54899: ARRAY
54900: PPUSH
54901: LD_INT 28
54903: PPUSH
54904: CALL_OW 325
54908: NOT
54909: AND
54910: IFFALSE 54914
// continue ;
54912: GO 54827
// for j in tmp do
54914: LD_ADDR_VAR 0 3
54918: PUSH
54919: LD_VAR 0 4
54923: PUSH
54924: FOR_IN
54925: IFFALSE 54984
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54927: LD_VAR 0 3
54931: PUSH
54932: LD_EXP 116
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: PUSH
54943: LD_INT 1
54945: ARRAY
54946: IN
54947: NOT
54948: PUSH
54949: LD_VAR 0 3
54953: PUSH
54954: LD_EXP 116
54958: PUSH
54959: LD_VAR 0 2
54963: ARRAY
54964: PUSH
54965: LD_INT 2
54967: ARRAY
54968: IN
54969: NOT
54970: AND
54971: IFFALSE 54982
// ComSpaceTimeShoot ( j ) ;
54973: LD_VAR 0 3
54977: PPUSH
54978: CALL 66147 0 1
54982: GO 54924
54984: POP
54985: POP
// end ;
54986: GO 54827
54988: POP
54989: POP
// end ;
54990: LD_VAR 0 1
54994: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54995: LD_INT 0
54997: PPUSH
54998: PPUSH
54999: PPUSH
55000: PPUSH
55001: PPUSH
55002: PPUSH
55003: PPUSH
55004: PPUSH
55005: PPUSH
// if not mc_bases then
55006: LD_EXP 113
55010: NOT
55011: IFFALSE 55015
// exit ;
55013: GO 55637
// for i = 1 to mc_bases do
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: DOUBLE
55021: LD_INT 1
55023: DEC
55024: ST_TO_ADDR
55025: LD_EXP 113
55029: PUSH
55030: FOR_TO
55031: IFFALSE 55635
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55033: LD_EXP 148
55037: PUSH
55038: LD_VAR 0 2
55042: ARRAY
55043: NOT
55044: PUSH
55045: LD_INT 38
55047: PPUSH
55048: LD_EXP 139
55052: PUSH
55053: LD_VAR 0 2
55057: ARRAY
55058: PPUSH
55059: CALL_OW 321
55063: PUSH
55064: LD_INT 2
55066: NONEQUAL
55067: OR
55068: IFFALSE 55072
// continue ;
55070: GO 55030
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55072: LD_ADDR_VAR 0 8
55076: PUSH
55077: LD_EXP 113
55081: PUSH
55082: LD_VAR 0 2
55086: ARRAY
55087: PPUSH
55088: LD_INT 30
55090: PUSH
55091: LD_INT 34
55093: PUSH
55094: EMPTY
55095: LIST
55096: LIST
55097: PPUSH
55098: CALL_OW 72
55102: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55103: LD_ADDR_VAR 0 9
55107: PUSH
55108: LD_EXP 113
55112: PUSH
55113: LD_VAR 0 2
55117: ARRAY
55118: PPUSH
55119: LD_INT 25
55121: PUSH
55122: LD_INT 4
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: PPUSH
55129: CALL_OW 72
55133: PPUSH
55134: LD_INT 0
55136: PPUSH
55137: CALL 98711 0 2
55141: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55142: LD_VAR 0 9
55146: NOT
55147: PUSH
55148: LD_VAR 0 8
55152: NOT
55153: OR
55154: PUSH
55155: LD_EXP 113
55159: PUSH
55160: LD_VAR 0 2
55164: ARRAY
55165: PPUSH
55166: LD_INT 124
55168: PPUSH
55169: CALL 98711 0 2
55173: OR
55174: IFFALSE 55178
// continue ;
55176: GO 55030
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55178: LD_EXP 149
55182: PUSH
55183: LD_VAR 0 2
55187: ARRAY
55188: PUSH
55189: LD_EXP 148
55193: PUSH
55194: LD_VAR 0 2
55198: ARRAY
55199: LESS
55200: PUSH
55201: LD_EXP 149
55205: PUSH
55206: LD_VAR 0 2
55210: ARRAY
55211: PUSH
55212: LD_VAR 0 8
55216: LESS
55217: AND
55218: IFFALSE 55633
// begin tmp := sci [ 1 ] ;
55220: LD_ADDR_VAR 0 7
55224: PUSH
55225: LD_VAR 0 9
55229: PUSH
55230: LD_INT 1
55232: ARRAY
55233: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55234: LD_VAR 0 7
55238: PPUSH
55239: LD_INT 124
55241: PPUSH
55242: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55246: LD_ADDR_VAR 0 3
55250: PUSH
55251: DOUBLE
55252: LD_EXP 148
55256: PUSH
55257: LD_VAR 0 2
55261: ARRAY
55262: INC
55263: ST_TO_ADDR
55264: LD_EXP 148
55268: PUSH
55269: LD_VAR 0 2
55273: ARRAY
55274: PUSH
55275: FOR_DOWNTO
55276: IFFALSE 55619
// begin if IsInUnit ( tmp ) then
55278: LD_VAR 0 7
55282: PPUSH
55283: CALL_OW 310
55287: IFFALSE 55298
// ComExitBuilding ( tmp ) ;
55289: LD_VAR 0 7
55293: PPUSH
55294: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55298: LD_INT 35
55300: PPUSH
55301: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55305: LD_VAR 0 7
55309: PPUSH
55310: CALL_OW 310
55314: NOT
55315: PUSH
55316: LD_VAR 0 7
55320: PPUSH
55321: CALL_OW 314
55325: NOT
55326: AND
55327: IFFALSE 55298
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55329: LD_ADDR_VAR 0 6
55333: PUSH
55334: LD_VAR 0 7
55338: PPUSH
55339: CALL_OW 250
55343: PUSH
55344: LD_VAR 0 7
55348: PPUSH
55349: CALL_OW 251
55353: PUSH
55354: EMPTY
55355: LIST
55356: LIST
55357: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55358: LD_INT 35
55360: PPUSH
55361: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55365: LD_ADDR_VAR 0 4
55369: PUSH
55370: LD_EXP 148
55374: PUSH
55375: LD_VAR 0 2
55379: ARRAY
55380: PUSH
55381: LD_VAR 0 3
55385: ARRAY
55386: PUSH
55387: LD_INT 1
55389: ARRAY
55390: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55391: LD_ADDR_VAR 0 5
55395: PUSH
55396: LD_EXP 148
55400: PUSH
55401: LD_VAR 0 2
55405: ARRAY
55406: PUSH
55407: LD_VAR 0 3
55411: ARRAY
55412: PUSH
55413: LD_INT 2
55415: ARRAY
55416: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55417: LD_VAR 0 7
55421: PPUSH
55422: LD_INT 10
55424: PPUSH
55425: CALL 72743 0 2
55429: PUSH
55430: LD_INT 4
55432: ARRAY
55433: IFFALSE 55471
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55435: LD_VAR 0 7
55439: PPUSH
55440: LD_VAR 0 6
55444: PUSH
55445: LD_INT 1
55447: ARRAY
55448: PPUSH
55449: LD_VAR 0 6
55453: PUSH
55454: LD_INT 2
55456: ARRAY
55457: PPUSH
55458: CALL_OW 111
// wait ( 0 0$10 ) ;
55462: LD_INT 350
55464: PPUSH
55465: CALL_OW 67
// end else
55469: GO 55497
// begin ComMoveXY ( tmp , x , y ) ;
55471: LD_VAR 0 7
55475: PPUSH
55476: LD_VAR 0 4
55480: PPUSH
55481: LD_VAR 0 5
55485: PPUSH
55486: CALL_OW 111
// wait ( 0 0$3 ) ;
55490: LD_INT 105
55492: PPUSH
55493: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55497: LD_VAR 0 7
55501: PPUSH
55502: LD_VAR 0 4
55506: PPUSH
55507: LD_VAR 0 5
55511: PPUSH
55512: CALL_OW 307
55516: IFFALSE 55358
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55518: LD_VAR 0 7
55522: PPUSH
55523: LD_VAR 0 4
55527: PPUSH
55528: LD_VAR 0 5
55532: PPUSH
55533: LD_VAR 0 8
55537: PUSH
55538: LD_VAR 0 3
55542: ARRAY
55543: PPUSH
55544: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55548: LD_INT 35
55550: PPUSH
55551: CALL_OW 67
// until not HasTask ( tmp ) ;
55555: LD_VAR 0 7
55559: PPUSH
55560: CALL_OW 314
55564: NOT
55565: IFFALSE 55548
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55567: LD_ADDR_EXP 149
55571: PUSH
55572: LD_EXP 149
55576: PPUSH
55577: LD_VAR 0 2
55581: PUSH
55582: LD_EXP 149
55586: PUSH
55587: LD_VAR 0 2
55591: ARRAY
55592: PUSH
55593: LD_INT 1
55595: PLUS
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: PPUSH
55601: LD_VAR 0 8
55605: PUSH
55606: LD_VAR 0 3
55610: ARRAY
55611: PPUSH
55612: CALL 70150 0 3
55616: ST_TO_ADDR
// end ;
55617: GO 55275
55619: POP
55620: POP
// MC_Reset ( i , 124 ) ;
55621: LD_VAR 0 2
55625: PPUSH
55626: LD_INT 124
55628: PPUSH
55629: CALL 39199 0 2
// end ; end ;
55633: GO 55030
55635: POP
55636: POP
// end ;
55637: LD_VAR 0 1
55641: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55642: LD_INT 0
55644: PPUSH
55645: PPUSH
55646: PPUSH
// if not mc_bases then
55647: LD_EXP 113
55651: NOT
55652: IFFALSE 55656
// exit ;
55654: GO 56262
// for i = 1 to mc_bases do
55656: LD_ADDR_VAR 0 2
55660: PUSH
55661: DOUBLE
55662: LD_INT 1
55664: DEC
55665: ST_TO_ADDR
55666: LD_EXP 113
55670: PUSH
55671: FOR_TO
55672: IFFALSE 56260
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55674: LD_ADDR_VAR 0 3
55678: PUSH
55679: LD_EXP 113
55683: PUSH
55684: LD_VAR 0 2
55688: ARRAY
55689: PPUSH
55690: LD_INT 25
55692: PUSH
55693: LD_INT 4
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PPUSH
55700: CALL_OW 72
55704: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55705: LD_VAR 0 3
55709: NOT
55710: PUSH
55711: LD_EXP 150
55715: PUSH
55716: LD_VAR 0 2
55720: ARRAY
55721: NOT
55722: OR
55723: PUSH
55724: LD_EXP 113
55728: PUSH
55729: LD_VAR 0 2
55733: ARRAY
55734: PPUSH
55735: LD_INT 2
55737: PUSH
55738: LD_INT 30
55740: PUSH
55741: LD_INT 0
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: PUSH
55748: LD_INT 30
55750: PUSH
55751: LD_INT 1
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: LIST
55762: PPUSH
55763: CALL_OW 72
55767: NOT
55768: OR
55769: IFFALSE 55819
// begin if mc_deposits_finder [ i ] then
55771: LD_EXP 151
55775: PUSH
55776: LD_VAR 0 2
55780: ARRAY
55781: IFFALSE 55817
// begin MC_Reset ( i , 125 ) ;
55783: LD_VAR 0 2
55787: PPUSH
55788: LD_INT 125
55790: PPUSH
55791: CALL 39199 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55795: LD_ADDR_EXP 151
55799: PUSH
55800: LD_EXP 151
55804: PPUSH
55805: LD_VAR 0 2
55809: PPUSH
55810: EMPTY
55811: PPUSH
55812: CALL_OW 1
55816: ST_TO_ADDR
// end ; continue ;
55817: GO 55671
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55819: LD_EXP 150
55823: PUSH
55824: LD_VAR 0 2
55828: ARRAY
55829: PUSH
55830: LD_INT 1
55832: ARRAY
55833: PUSH
55834: LD_INT 3
55836: ARRAY
55837: PUSH
55838: LD_INT 1
55840: EQUAL
55841: PUSH
55842: LD_INT 20
55844: PPUSH
55845: LD_EXP 139
55849: PUSH
55850: LD_VAR 0 2
55854: ARRAY
55855: PPUSH
55856: CALL_OW 321
55860: PUSH
55861: LD_INT 2
55863: NONEQUAL
55864: AND
55865: IFFALSE 55915
// begin if mc_deposits_finder [ i ] then
55867: LD_EXP 151
55871: PUSH
55872: LD_VAR 0 2
55876: ARRAY
55877: IFFALSE 55913
// begin MC_Reset ( i , 125 ) ;
55879: LD_VAR 0 2
55883: PPUSH
55884: LD_INT 125
55886: PPUSH
55887: CALL 39199 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55891: LD_ADDR_EXP 151
55895: PUSH
55896: LD_EXP 151
55900: PPUSH
55901: LD_VAR 0 2
55905: PPUSH
55906: EMPTY
55907: PPUSH
55908: CALL_OW 1
55912: ST_TO_ADDR
// end ; continue ;
55913: GO 55671
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55915: LD_EXP 150
55919: PUSH
55920: LD_VAR 0 2
55924: ARRAY
55925: PUSH
55926: LD_INT 1
55928: ARRAY
55929: PUSH
55930: LD_INT 1
55932: ARRAY
55933: PPUSH
55934: LD_EXP 150
55938: PUSH
55939: LD_VAR 0 2
55943: ARRAY
55944: PUSH
55945: LD_INT 1
55947: ARRAY
55948: PUSH
55949: LD_INT 2
55951: ARRAY
55952: PPUSH
55953: LD_EXP 139
55957: PUSH
55958: LD_VAR 0 2
55962: ARRAY
55963: PPUSH
55964: CALL_OW 440
55968: IFFALSE 56011
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55970: LD_ADDR_EXP 150
55974: PUSH
55975: LD_EXP 150
55979: PPUSH
55980: LD_VAR 0 2
55984: PPUSH
55985: LD_EXP 150
55989: PUSH
55990: LD_VAR 0 2
55994: ARRAY
55995: PPUSH
55996: LD_INT 1
55998: PPUSH
55999: CALL_OW 3
56003: PPUSH
56004: CALL_OW 1
56008: ST_TO_ADDR
56009: GO 56258
// begin if not mc_deposits_finder [ i ] then
56011: LD_EXP 151
56015: PUSH
56016: LD_VAR 0 2
56020: ARRAY
56021: NOT
56022: IFFALSE 56074
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56024: LD_ADDR_EXP 151
56028: PUSH
56029: LD_EXP 151
56033: PPUSH
56034: LD_VAR 0 2
56038: PPUSH
56039: LD_VAR 0 3
56043: PUSH
56044: LD_INT 1
56046: ARRAY
56047: PUSH
56048: EMPTY
56049: LIST
56050: PPUSH
56051: CALL_OW 1
56055: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56056: LD_VAR 0 3
56060: PUSH
56061: LD_INT 1
56063: ARRAY
56064: PPUSH
56065: LD_INT 125
56067: PPUSH
56068: CALL_OW 109
// end else
56072: GO 56258
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56074: LD_EXP 151
56078: PUSH
56079: LD_VAR 0 2
56083: ARRAY
56084: PUSH
56085: LD_INT 1
56087: ARRAY
56088: PPUSH
56089: CALL_OW 310
56093: IFFALSE 56116
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56095: LD_EXP 151
56099: PUSH
56100: LD_VAR 0 2
56104: ARRAY
56105: PUSH
56106: LD_INT 1
56108: ARRAY
56109: PPUSH
56110: CALL_OW 122
56114: GO 56258
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56116: LD_EXP 151
56120: PUSH
56121: LD_VAR 0 2
56125: ARRAY
56126: PUSH
56127: LD_INT 1
56129: ARRAY
56130: PPUSH
56131: CALL_OW 314
56135: NOT
56136: PUSH
56137: LD_EXP 151
56141: PUSH
56142: LD_VAR 0 2
56146: ARRAY
56147: PUSH
56148: LD_INT 1
56150: ARRAY
56151: PPUSH
56152: LD_EXP 150
56156: PUSH
56157: LD_VAR 0 2
56161: ARRAY
56162: PUSH
56163: LD_INT 1
56165: ARRAY
56166: PUSH
56167: LD_INT 1
56169: ARRAY
56170: PPUSH
56171: LD_EXP 150
56175: PUSH
56176: LD_VAR 0 2
56180: ARRAY
56181: PUSH
56182: LD_INT 1
56184: ARRAY
56185: PUSH
56186: LD_INT 2
56188: ARRAY
56189: PPUSH
56190: CALL_OW 297
56194: PUSH
56195: LD_INT 6
56197: GREATER
56198: AND
56199: IFFALSE 56258
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56201: LD_EXP 151
56205: PUSH
56206: LD_VAR 0 2
56210: ARRAY
56211: PUSH
56212: LD_INT 1
56214: ARRAY
56215: PPUSH
56216: LD_EXP 150
56220: PUSH
56221: LD_VAR 0 2
56225: ARRAY
56226: PUSH
56227: LD_INT 1
56229: ARRAY
56230: PUSH
56231: LD_INT 1
56233: ARRAY
56234: PPUSH
56235: LD_EXP 150
56239: PUSH
56240: LD_VAR 0 2
56244: ARRAY
56245: PUSH
56246: LD_INT 1
56248: ARRAY
56249: PUSH
56250: LD_INT 2
56252: ARRAY
56253: PPUSH
56254: CALL_OW 111
// end ; end ; end ;
56258: GO 55671
56260: POP
56261: POP
// end ;
56262: LD_VAR 0 1
56266: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56267: LD_INT 0
56269: PPUSH
56270: PPUSH
56271: PPUSH
56272: PPUSH
56273: PPUSH
56274: PPUSH
56275: PPUSH
56276: PPUSH
56277: PPUSH
56278: PPUSH
56279: PPUSH
// if not mc_bases then
56280: LD_EXP 113
56284: NOT
56285: IFFALSE 56289
// exit ;
56287: GO 57229
// for i = 1 to mc_bases do
56289: LD_ADDR_VAR 0 2
56293: PUSH
56294: DOUBLE
56295: LD_INT 1
56297: DEC
56298: ST_TO_ADDR
56299: LD_EXP 113
56303: PUSH
56304: FOR_TO
56305: IFFALSE 57227
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56307: LD_EXP 113
56311: PUSH
56312: LD_VAR 0 2
56316: ARRAY
56317: NOT
56318: PUSH
56319: LD_EXP 136
56323: PUSH
56324: LD_VAR 0 2
56328: ARRAY
56329: OR
56330: IFFALSE 56334
// continue ;
56332: GO 56304
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56334: LD_ADDR_VAR 0 7
56338: PUSH
56339: LD_EXP 113
56343: PUSH
56344: LD_VAR 0 2
56348: ARRAY
56349: PUSH
56350: LD_INT 1
56352: ARRAY
56353: PPUSH
56354: CALL_OW 248
56358: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56359: LD_VAR 0 7
56363: PUSH
56364: LD_INT 3
56366: EQUAL
56367: PUSH
56368: LD_EXP 132
56372: PUSH
56373: LD_VAR 0 2
56377: ARRAY
56378: PUSH
56379: LD_EXP 135
56383: PUSH
56384: LD_VAR 0 2
56388: ARRAY
56389: UNION
56390: PPUSH
56391: LD_INT 33
56393: PUSH
56394: LD_INT 2
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: PPUSH
56401: CALL_OW 72
56405: NOT
56406: OR
56407: IFFALSE 56411
// continue ;
56409: GO 56304
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56411: LD_ADDR_VAR 0 9
56415: PUSH
56416: LD_EXP 113
56420: PUSH
56421: LD_VAR 0 2
56425: ARRAY
56426: PPUSH
56427: LD_INT 30
56429: PUSH
56430: LD_INT 36
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: PPUSH
56437: CALL_OW 72
56441: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56442: LD_ADDR_VAR 0 10
56446: PUSH
56447: LD_EXP 132
56451: PUSH
56452: LD_VAR 0 2
56456: ARRAY
56457: PPUSH
56458: LD_INT 34
56460: PUSH
56461: LD_INT 31
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: PPUSH
56468: CALL_OW 72
56472: ST_TO_ADDR
// if not cts and not mcts then
56473: LD_VAR 0 9
56477: NOT
56478: PUSH
56479: LD_VAR 0 10
56483: NOT
56484: AND
56485: IFFALSE 56489
// continue ;
56487: GO 56304
// x := cts ;
56489: LD_ADDR_VAR 0 11
56493: PUSH
56494: LD_VAR 0 9
56498: ST_TO_ADDR
// if not x then
56499: LD_VAR 0 11
56503: NOT
56504: IFFALSE 56516
// x := mcts ;
56506: LD_ADDR_VAR 0 11
56510: PUSH
56511: LD_VAR 0 10
56515: ST_TO_ADDR
// if not x then
56516: LD_VAR 0 11
56520: NOT
56521: IFFALSE 56525
// continue ;
56523: GO 56304
// if mc_remote_driver [ i ] then
56525: LD_EXP 153
56529: PUSH
56530: LD_VAR 0 2
56534: ARRAY
56535: IFFALSE 56922
// for j in mc_remote_driver [ i ] do
56537: LD_ADDR_VAR 0 3
56541: PUSH
56542: LD_EXP 153
56546: PUSH
56547: LD_VAR 0 2
56551: ARRAY
56552: PUSH
56553: FOR_IN
56554: IFFALSE 56920
// begin if GetClass ( j ) <> 3 then
56556: LD_VAR 0 3
56560: PPUSH
56561: CALL_OW 257
56565: PUSH
56566: LD_INT 3
56568: NONEQUAL
56569: IFFALSE 56622
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56571: LD_ADDR_EXP 153
56575: PUSH
56576: LD_EXP 153
56580: PPUSH
56581: LD_VAR 0 2
56585: PPUSH
56586: LD_EXP 153
56590: PUSH
56591: LD_VAR 0 2
56595: ARRAY
56596: PUSH
56597: LD_VAR 0 3
56601: DIFF
56602: PPUSH
56603: CALL_OW 1
56607: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56608: LD_VAR 0 3
56612: PPUSH
56613: LD_INT 0
56615: PPUSH
56616: CALL_OW 109
// continue ;
56620: GO 56553
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56622: LD_EXP 132
56626: PUSH
56627: LD_VAR 0 2
56631: ARRAY
56632: PPUSH
56633: LD_INT 34
56635: PUSH
56636: LD_INT 31
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: PUSH
56643: LD_INT 58
56645: PUSH
56646: EMPTY
56647: LIST
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PPUSH
56653: CALL_OW 72
56657: PUSH
56658: LD_VAR 0 3
56662: PPUSH
56663: CALL 98799 0 1
56667: NOT
56668: AND
56669: IFFALSE 56740
// begin if IsInUnit ( j ) then
56671: LD_VAR 0 3
56675: PPUSH
56676: CALL_OW 310
56680: IFFALSE 56691
// ComExitBuilding ( j ) ;
56682: LD_VAR 0 3
56686: PPUSH
56687: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56691: LD_VAR 0 3
56695: PPUSH
56696: LD_EXP 132
56700: PUSH
56701: LD_VAR 0 2
56705: ARRAY
56706: PPUSH
56707: LD_INT 34
56709: PUSH
56710: LD_INT 31
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: PUSH
56717: LD_INT 58
56719: PUSH
56720: EMPTY
56721: LIST
56722: PUSH
56723: EMPTY
56724: LIST
56725: LIST
56726: PPUSH
56727: CALL_OW 72
56731: PUSH
56732: LD_INT 1
56734: ARRAY
56735: PPUSH
56736: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56740: LD_VAR 0 3
56744: PPUSH
56745: CALL_OW 310
56749: NOT
56750: PUSH
56751: LD_VAR 0 3
56755: PPUSH
56756: CALL_OW 310
56760: PPUSH
56761: CALL_OW 266
56765: PUSH
56766: LD_INT 36
56768: NONEQUAL
56769: PUSH
56770: LD_VAR 0 3
56774: PPUSH
56775: CALL 98799 0 1
56779: NOT
56780: AND
56781: OR
56782: IFFALSE 56918
// begin if IsInUnit ( j ) then
56784: LD_VAR 0 3
56788: PPUSH
56789: CALL_OW 310
56793: IFFALSE 56804
// ComExitBuilding ( j ) ;
56795: LD_VAR 0 3
56799: PPUSH
56800: CALL_OW 122
// ct := 0 ;
56804: LD_ADDR_VAR 0 8
56808: PUSH
56809: LD_INT 0
56811: ST_TO_ADDR
// for k in x do
56812: LD_ADDR_VAR 0 4
56816: PUSH
56817: LD_VAR 0 11
56821: PUSH
56822: FOR_IN
56823: IFFALSE 56896
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56825: LD_VAR 0 4
56829: PPUSH
56830: CALL_OW 264
56834: PUSH
56835: LD_INT 31
56837: EQUAL
56838: PUSH
56839: LD_VAR 0 4
56843: PPUSH
56844: CALL_OW 311
56848: NOT
56849: AND
56850: PUSH
56851: LD_VAR 0 4
56855: PPUSH
56856: CALL_OW 266
56860: PUSH
56861: LD_INT 36
56863: EQUAL
56864: PUSH
56865: LD_VAR 0 4
56869: PPUSH
56870: CALL_OW 313
56874: PUSH
56875: LD_INT 3
56877: LESS
56878: AND
56879: OR
56880: IFFALSE 56894
// begin ct := k ;
56882: LD_ADDR_VAR 0 8
56886: PUSH
56887: LD_VAR 0 4
56891: ST_TO_ADDR
// break ;
56892: GO 56896
// end ;
56894: GO 56822
56896: POP
56897: POP
// if ct then
56898: LD_VAR 0 8
56902: IFFALSE 56918
// ComEnterUnit ( j , ct ) ;
56904: LD_VAR 0 3
56908: PPUSH
56909: LD_VAR 0 8
56913: PPUSH
56914: CALL_OW 120
// end ; end ;
56918: GO 56553
56920: POP
56921: POP
// places := 0 ;
56922: LD_ADDR_VAR 0 5
56926: PUSH
56927: LD_INT 0
56929: ST_TO_ADDR
// for j = 1 to x do
56930: LD_ADDR_VAR 0 3
56934: PUSH
56935: DOUBLE
56936: LD_INT 1
56938: DEC
56939: ST_TO_ADDR
56940: LD_VAR 0 11
56944: PUSH
56945: FOR_TO
56946: IFFALSE 57022
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56948: LD_VAR 0 11
56952: PUSH
56953: LD_VAR 0 3
56957: ARRAY
56958: PPUSH
56959: CALL_OW 264
56963: PUSH
56964: LD_INT 31
56966: EQUAL
56967: IFFALSE 56985
// places := places + 1 else
56969: LD_ADDR_VAR 0 5
56973: PUSH
56974: LD_VAR 0 5
56978: PUSH
56979: LD_INT 1
56981: PLUS
56982: ST_TO_ADDR
56983: GO 57020
// if GetBType ( x [ j ] ) = b_control_tower then
56985: LD_VAR 0 11
56989: PUSH
56990: LD_VAR 0 3
56994: ARRAY
56995: PPUSH
56996: CALL_OW 266
57000: PUSH
57001: LD_INT 36
57003: EQUAL
57004: IFFALSE 57020
// places := places + 3 ;
57006: LD_ADDR_VAR 0 5
57010: PUSH
57011: LD_VAR 0 5
57015: PUSH
57016: LD_INT 3
57018: PLUS
57019: ST_TO_ADDR
57020: GO 56945
57022: POP
57023: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57024: LD_VAR 0 5
57028: PUSH
57029: LD_INT 0
57031: EQUAL
57032: PUSH
57033: LD_VAR 0 5
57037: PUSH
57038: LD_EXP 153
57042: PUSH
57043: LD_VAR 0 2
57047: ARRAY
57048: LESSEQUAL
57049: OR
57050: IFFALSE 57054
// continue ;
57052: GO 56304
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57054: LD_ADDR_VAR 0 6
57058: PUSH
57059: LD_EXP 113
57063: PUSH
57064: LD_VAR 0 2
57068: ARRAY
57069: PPUSH
57070: LD_INT 25
57072: PUSH
57073: LD_INT 3
57075: PUSH
57076: EMPTY
57077: LIST
57078: LIST
57079: PPUSH
57080: CALL_OW 72
57084: PUSH
57085: LD_EXP 153
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: DIFF
57096: PPUSH
57097: LD_INT 3
57099: PPUSH
57100: CALL 99699 0 2
57104: ST_TO_ADDR
// for j in tmp do
57105: LD_ADDR_VAR 0 3
57109: PUSH
57110: LD_VAR 0 6
57114: PUSH
57115: FOR_IN
57116: IFFALSE 57151
// if GetTag ( j ) > 0 then
57118: LD_VAR 0 3
57122: PPUSH
57123: CALL_OW 110
57127: PUSH
57128: LD_INT 0
57130: GREATER
57131: IFFALSE 57149
// tmp := tmp diff j ;
57133: LD_ADDR_VAR 0 6
57137: PUSH
57138: LD_VAR 0 6
57142: PUSH
57143: LD_VAR 0 3
57147: DIFF
57148: ST_TO_ADDR
57149: GO 57115
57151: POP
57152: POP
// if not tmp then
57153: LD_VAR 0 6
57157: NOT
57158: IFFALSE 57162
// continue ;
57160: GO 56304
// if places then
57162: LD_VAR 0 5
57166: IFFALSE 57225
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57168: LD_ADDR_EXP 153
57172: PUSH
57173: LD_EXP 153
57177: PPUSH
57178: LD_VAR 0 2
57182: PPUSH
57183: LD_EXP 153
57187: PUSH
57188: LD_VAR 0 2
57192: ARRAY
57193: PUSH
57194: LD_VAR 0 6
57198: PUSH
57199: LD_INT 1
57201: ARRAY
57202: UNION
57203: PPUSH
57204: CALL_OW 1
57208: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57209: LD_VAR 0 6
57213: PUSH
57214: LD_INT 1
57216: ARRAY
57217: PPUSH
57218: LD_INT 126
57220: PPUSH
57221: CALL_OW 109
// end ; end ;
57225: GO 56304
57227: POP
57228: POP
// end ;
57229: LD_VAR 0 1
57233: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57234: LD_INT 0
57236: PPUSH
57237: PPUSH
57238: PPUSH
57239: PPUSH
57240: PPUSH
57241: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57242: LD_VAR 0 1
57246: NOT
57247: PUSH
57248: LD_VAR 0 2
57252: NOT
57253: OR
57254: PUSH
57255: LD_VAR 0 3
57259: NOT
57260: OR
57261: PUSH
57262: LD_VAR 0 4
57266: PUSH
57267: LD_INT 1
57269: PUSH
57270: LD_INT 2
57272: PUSH
57273: LD_INT 3
57275: PUSH
57276: LD_INT 4
57278: PUSH
57279: LD_INT 5
57281: PUSH
57282: LD_INT 8
57284: PUSH
57285: LD_INT 9
57287: PUSH
57288: LD_INT 15
57290: PUSH
57291: LD_INT 16
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: LIST
57298: LIST
57299: LIST
57300: LIST
57301: LIST
57302: LIST
57303: LIST
57304: IN
57305: NOT
57306: OR
57307: IFFALSE 57311
// exit ;
57309: GO 58211
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57311: LD_ADDR_VAR 0 2
57315: PUSH
57316: LD_VAR 0 2
57320: PPUSH
57321: LD_INT 21
57323: PUSH
57324: LD_INT 3
57326: PUSH
57327: EMPTY
57328: LIST
57329: LIST
57330: PUSH
57331: LD_INT 24
57333: PUSH
57334: LD_INT 250
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: PPUSH
57345: CALL_OW 72
57349: ST_TO_ADDR
// case class of 1 , 15 :
57350: LD_VAR 0 4
57354: PUSH
57355: LD_INT 1
57357: DOUBLE
57358: EQUAL
57359: IFTRUE 57369
57361: LD_INT 15
57363: DOUBLE
57364: EQUAL
57365: IFTRUE 57369
57367: GO 57454
57369: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57370: LD_ADDR_VAR 0 8
57374: PUSH
57375: LD_VAR 0 2
57379: PPUSH
57380: LD_INT 2
57382: PUSH
57383: LD_INT 30
57385: PUSH
57386: LD_INT 32
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PUSH
57393: LD_INT 30
57395: PUSH
57396: LD_INT 31
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: PUSH
57403: EMPTY
57404: LIST
57405: LIST
57406: LIST
57407: PPUSH
57408: CALL_OW 72
57412: PUSH
57413: LD_VAR 0 2
57417: PPUSH
57418: LD_INT 2
57420: PUSH
57421: LD_INT 30
57423: PUSH
57424: LD_INT 4
57426: PUSH
57427: EMPTY
57428: LIST
57429: LIST
57430: PUSH
57431: LD_INT 30
57433: PUSH
57434: LD_INT 5
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: LIST
57445: PPUSH
57446: CALL_OW 72
57450: ADD
57451: ST_TO_ADDR
57452: GO 57700
57454: LD_INT 2
57456: DOUBLE
57457: EQUAL
57458: IFTRUE 57468
57460: LD_INT 16
57462: DOUBLE
57463: EQUAL
57464: IFTRUE 57468
57466: GO 57514
57468: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57469: LD_ADDR_VAR 0 8
57473: PUSH
57474: LD_VAR 0 2
57478: PPUSH
57479: LD_INT 2
57481: PUSH
57482: LD_INT 30
57484: PUSH
57485: LD_INT 0
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: PUSH
57492: LD_INT 30
57494: PUSH
57495: LD_INT 1
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: LIST
57506: PPUSH
57507: CALL_OW 72
57511: ST_TO_ADDR
57512: GO 57700
57514: LD_INT 3
57516: DOUBLE
57517: EQUAL
57518: IFTRUE 57522
57520: GO 57568
57522: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57523: LD_ADDR_VAR 0 8
57527: PUSH
57528: LD_VAR 0 2
57532: PPUSH
57533: LD_INT 2
57535: PUSH
57536: LD_INT 30
57538: PUSH
57539: LD_INT 2
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: PUSH
57546: LD_INT 30
57548: PUSH
57549: LD_INT 3
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: LIST
57560: PPUSH
57561: CALL_OW 72
57565: ST_TO_ADDR
57566: GO 57700
57568: LD_INT 4
57570: DOUBLE
57571: EQUAL
57572: IFTRUE 57576
57574: GO 57633
57576: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57577: LD_ADDR_VAR 0 8
57581: PUSH
57582: LD_VAR 0 2
57586: PPUSH
57587: LD_INT 2
57589: PUSH
57590: LD_INT 30
57592: PUSH
57593: LD_INT 6
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: PUSH
57600: LD_INT 30
57602: PUSH
57603: LD_INT 7
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: PUSH
57610: LD_INT 30
57612: PUSH
57613: LD_INT 8
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: LIST
57624: LIST
57625: PPUSH
57626: CALL_OW 72
57630: ST_TO_ADDR
57631: GO 57700
57633: LD_INT 5
57635: DOUBLE
57636: EQUAL
57637: IFTRUE 57653
57639: LD_INT 8
57641: DOUBLE
57642: EQUAL
57643: IFTRUE 57653
57645: LD_INT 9
57647: DOUBLE
57648: EQUAL
57649: IFTRUE 57653
57651: GO 57699
57653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57654: LD_ADDR_VAR 0 8
57658: PUSH
57659: LD_VAR 0 2
57663: PPUSH
57664: LD_INT 2
57666: PUSH
57667: LD_INT 30
57669: PUSH
57670: LD_INT 4
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: PUSH
57677: LD_INT 30
57679: PUSH
57680: LD_INT 5
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: PUSH
57687: EMPTY
57688: LIST
57689: LIST
57690: LIST
57691: PPUSH
57692: CALL_OW 72
57696: ST_TO_ADDR
57697: GO 57700
57699: POP
// if not tmp then
57700: LD_VAR 0 8
57704: NOT
57705: IFFALSE 57709
// exit ;
57707: GO 58211
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57709: LD_VAR 0 4
57713: PUSH
57714: LD_INT 1
57716: PUSH
57717: LD_INT 15
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: IN
57724: PUSH
57725: LD_EXP 122
57729: PUSH
57730: LD_VAR 0 1
57734: ARRAY
57735: AND
57736: IFFALSE 57892
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57738: LD_ADDR_VAR 0 9
57742: PUSH
57743: LD_EXP 122
57747: PUSH
57748: LD_VAR 0 1
57752: ARRAY
57753: PUSH
57754: LD_INT 1
57756: ARRAY
57757: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57758: LD_VAR 0 9
57762: PUSH
57763: LD_EXP 123
57767: PUSH
57768: LD_VAR 0 1
57772: ARRAY
57773: IN
57774: NOT
57775: IFFALSE 57890
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57777: LD_ADDR_EXP 123
57781: PUSH
57782: LD_EXP 123
57786: PPUSH
57787: LD_VAR 0 1
57791: PUSH
57792: LD_EXP 123
57796: PUSH
57797: LD_VAR 0 1
57801: ARRAY
57802: PUSH
57803: LD_INT 1
57805: PLUS
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PPUSH
57811: LD_VAR 0 9
57815: PPUSH
57816: CALL 70150 0 3
57820: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57821: LD_ADDR_EXP 122
57825: PUSH
57826: LD_EXP 122
57830: PPUSH
57831: LD_VAR 0 1
57835: PPUSH
57836: LD_EXP 122
57840: PUSH
57841: LD_VAR 0 1
57845: ARRAY
57846: PUSH
57847: LD_VAR 0 9
57851: DIFF
57852: PPUSH
57853: CALL_OW 1
57857: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57858: LD_VAR 0 3
57862: PPUSH
57863: LD_EXP 123
57867: PUSH
57868: LD_VAR 0 1
57872: ARRAY
57873: PUSH
57874: LD_EXP 123
57878: PUSH
57879: LD_VAR 0 1
57883: ARRAY
57884: ARRAY
57885: PPUSH
57886: CALL_OW 120
// end ; exit ;
57890: GO 58211
// end ; if tmp > 1 then
57892: LD_VAR 0 8
57896: PUSH
57897: LD_INT 1
57899: GREATER
57900: IFFALSE 58004
// for i = 2 to tmp do
57902: LD_ADDR_VAR 0 6
57906: PUSH
57907: DOUBLE
57908: LD_INT 2
57910: DEC
57911: ST_TO_ADDR
57912: LD_VAR 0 8
57916: PUSH
57917: FOR_TO
57918: IFFALSE 58002
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57920: LD_VAR 0 8
57924: PUSH
57925: LD_VAR 0 6
57929: ARRAY
57930: PPUSH
57931: CALL_OW 461
57935: PUSH
57936: LD_INT 6
57938: EQUAL
57939: IFFALSE 58000
// begin x := tmp [ i ] ;
57941: LD_ADDR_VAR 0 9
57945: PUSH
57946: LD_VAR 0 8
57950: PUSH
57951: LD_VAR 0 6
57955: ARRAY
57956: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57957: LD_ADDR_VAR 0 8
57961: PUSH
57962: LD_VAR 0 8
57966: PPUSH
57967: LD_VAR 0 6
57971: PPUSH
57972: CALL_OW 3
57976: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57977: LD_ADDR_VAR 0 8
57981: PUSH
57982: LD_VAR 0 8
57986: PPUSH
57987: LD_INT 1
57989: PPUSH
57990: LD_VAR 0 9
57994: PPUSH
57995: CALL_OW 2
57999: ST_TO_ADDR
// end ;
58000: GO 57917
58002: POP
58003: POP
// for i in tmp do
58004: LD_ADDR_VAR 0 6
58008: PUSH
58009: LD_VAR 0 8
58013: PUSH
58014: FOR_IN
58015: IFFALSE 58084
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58017: LD_VAR 0 6
58021: PPUSH
58022: CALL_OW 313
58026: PUSH
58027: LD_INT 6
58029: LESS
58030: PUSH
58031: LD_VAR 0 6
58035: PPUSH
58036: CALL_OW 266
58040: PUSH
58041: LD_INT 31
58043: PUSH
58044: LD_INT 32
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: IN
58051: NOT
58052: AND
58053: PUSH
58054: LD_VAR 0 6
58058: PPUSH
58059: CALL_OW 313
58063: PUSH
58064: LD_INT 0
58066: EQUAL
58067: OR
58068: IFFALSE 58082
// begin j := i ;
58070: LD_ADDR_VAR 0 7
58074: PUSH
58075: LD_VAR 0 6
58079: ST_TO_ADDR
// break ;
58080: GO 58084
// end ; end ;
58082: GO 58014
58084: POP
58085: POP
// if j then
58086: LD_VAR 0 7
58090: IFFALSE 58108
// ComEnterUnit ( unit , j ) else
58092: LD_VAR 0 3
58096: PPUSH
58097: LD_VAR 0 7
58101: PPUSH
58102: CALL_OW 120
58106: GO 58211
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58108: LD_ADDR_VAR 0 10
58112: PUSH
58113: LD_VAR 0 2
58117: PPUSH
58118: LD_INT 2
58120: PUSH
58121: LD_INT 30
58123: PUSH
58124: LD_INT 0
58126: PUSH
58127: EMPTY
58128: LIST
58129: LIST
58130: PUSH
58131: LD_INT 30
58133: PUSH
58134: LD_INT 1
58136: PUSH
58137: EMPTY
58138: LIST
58139: LIST
58140: PUSH
58141: EMPTY
58142: LIST
58143: LIST
58144: LIST
58145: PPUSH
58146: CALL_OW 72
58150: ST_TO_ADDR
// if depot then
58151: LD_VAR 0 10
58155: IFFALSE 58211
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58157: LD_ADDR_VAR 0 10
58161: PUSH
58162: LD_VAR 0 10
58166: PPUSH
58167: LD_VAR 0 3
58171: PPUSH
58172: CALL_OW 74
58176: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58177: LD_VAR 0 3
58181: PPUSH
58182: LD_VAR 0 10
58186: PPUSH
58187: CALL_OW 296
58191: PUSH
58192: LD_INT 10
58194: GREATER
58195: IFFALSE 58211
// ComStandNearbyBuilding ( unit , depot ) ;
58197: LD_VAR 0 3
58201: PPUSH
58202: LD_VAR 0 10
58206: PPUSH
58207: CALL 66764 0 2
// end ; end ; end ;
58211: LD_VAR 0 5
58215: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58216: LD_INT 0
58218: PPUSH
58219: PPUSH
58220: PPUSH
58221: PPUSH
// if not mc_bases then
58222: LD_EXP 113
58226: NOT
58227: IFFALSE 58231
// exit ;
58229: GO 58470
// for i = 1 to mc_bases do
58231: LD_ADDR_VAR 0 2
58235: PUSH
58236: DOUBLE
58237: LD_INT 1
58239: DEC
58240: ST_TO_ADDR
58241: LD_EXP 113
58245: PUSH
58246: FOR_TO
58247: IFFALSE 58468
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58249: LD_ADDR_VAR 0 4
58253: PUSH
58254: LD_EXP 113
58258: PUSH
58259: LD_VAR 0 2
58263: ARRAY
58264: PPUSH
58265: LD_INT 21
58267: PUSH
58268: LD_INT 1
58270: PUSH
58271: EMPTY
58272: LIST
58273: LIST
58274: PPUSH
58275: CALL_OW 72
58279: PUSH
58280: LD_EXP 142
58284: PUSH
58285: LD_VAR 0 2
58289: ARRAY
58290: UNION
58291: ST_TO_ADDR
// if not tmp then
58292: LD_VAR 0 4
58296: NOT
58297: IFFALSE 58301
// continue ;
58299: GO 58246
// for j in tmp do
58301: LD_ADDR_VAR 0 3
58305: PUSH
58306: LD_VAR 0 4
58310: PUSH
58311: FOR_IN
58312: IFFALSE 58464
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58314: LD_VAR 0 3
58318: PPUSH
58319: CALL_OW 110
58323: NOT
58324: PUSH
58325: LD_VAR 0 3
58329: PPUSH
58330: CALL_OW 314
58334: NOT
58335: AND
58336: PUSH
58337: LD_VAR 0 3
58341: PPUSH
58342: CALL_OW 311
58346: NOT
58347: AND
58348: PUSH
58349: LD_VAR 0 3
58353: PPUSH
58354: CALL_OW 310
58358: NOT
58359: AND
58360: PUSH
58361: LD_VAR 0 3
58365: PUSH
58366: LD_EXP 116
58370: PUSH
58371: LD_VAR 0 2
58375: ARRAY
58376: PUSH
58377: LD_INT 1
58379: ARRAY
58380: IN
58381: NOT
58382: AND
58383: PUSH
58384: LD_VAR 0 3
58388: PUSH
58389: LD_EXP 116
58393: PUSH
58394: LD_VAR 0 2
58398: ARRAY
58399: PUSH
58400: LD_INT 2
58402: ARRAY
58403: IN
58404: NOT
58405: AND
58406: PUSH
58407: LD_VAR 0 3
58411: PUSH
58412: LD_EXP 125
58416: PUSH
58417: LD_VAR 0 2
58421: ARRAY
58422: IN
58423: NOT
58424: AND
58425: IFFALSE 58462
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58427: LD_VAR 0 2
58431: PPUSH
58432: LD_EXP 113
58436: PUSH
58437: LD_VAR 0 2
58441: ARRAY
58442: PPUSH
58443: LD_VAR 0 3
58447: PPUSH
58448: LD_VAR 0 3
58452: PPUSH
58453: CALL_OW 257
58457: PPUSH
58458: CALL 57234 0 4
// end ;
58462: GO 58311
58464: POP
58465: POP
// end ;
58466: GO 58246
58468: POP
58469: POP
// end ;
58470: LD_VAR 0 1
58474: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58475: LD_INT 0
58477: PPUSH
58478: PPUSH
58479: PPUSH
58480: PPUSH
58481: PPUSH
58482: PPUSH
// if not mc_bases [ base ] then
58483: LD_EXP 113
58487: PUSH
58488: LD_VAR 0 1
58492: ARRAY
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58680
// tmp := [ ] ;
58498: LD_ADDR_VAR 0 6
58502: PUSH
58503: EMPTY
58504: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58505: LD_ADDR_VAR 0 7
58509: PUSH
58510: LD_VAR 0 3
58514: PPUSH
58515: LD_INT 0
58517: PPUSH
58518: CALL_OW 517
58522: ST_TO_ADDR
// if not list then
58523: LD_VAR 0 7
58527: NOT
58528: IFFALSE 58532
// exit ;
58530: GO 58680
// for i = 1 to amount do
58532: LD_ADDR_VAR 0 5
58536: PUSH
58537: DOUBLE
58538: LD_INT 1
58540: DEC
58541: ST_TO_ADDR
58542: LD_VAR 0 2
58546: PUSH
58547: FOR_TO
58548: IFFALSE 58628
// begin x := rand ( 1 , list [ 1 ] ) ;
58550: LD_ADDR_VAR 0 8
58554: PUSH
58555: LD_INT 1
58557: PPUSH
58558: LD_VAR 0 7
58562: PUSH
58563: LD_INT 1
58565: ARRAY
58566: PPUSH
58567: CALL_OW 12
58571: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58572: LD_ADDR_VAR 0 6
58576: PUSH
58577: LD_VAR 0 6
58581: PPUSH
58582: LD_VAR 0 5
58586: PPUSH
58587: LD_VAR 0 7
58591: PUSH
58592: LD_INT 1
58594: ARRAY
58595: PUSH
58596: LD_VAR 0 8
58600: ARRAY
58601: PUSH
58602: LD_VAR 0 7
58606: PUSH
58607: LD_INT 2
58609: ARRAY
58610: PUSH
58611: LD_VAR 0 8
58615: ARRAY
58616: PUSH
58617: EMPTY
58618: LIST
58619: LIST
58620: PPUSH
58621: CALL_OW 1
58625: ST_TO_ADDR
// end ;
58626: GO 58547
58628: POP
58629: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58630: LD_ADDR_EXP 126
58634: PUSH
58635: LD_EXP 126
58639: PPUSH
58640: LD_VAR 0 1
58644: PPUSH
58645: LD_VAR 0 6
58649: PPUSH
58650: CALL_OW 1
58654: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58655: LD_ADDR_EXP 128
58659: PUSH
58660: LD_EXP 128
58664: PPUSH
58665: LD_VAR 0 1
58669: PPUSH
58670: LD_VAR 0 3
58674: PPUSH
58675: CALL_OW 1
58679: ST_TO_ADDR
// end ;
58680: LD_VAR 0 4
58684: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58685: LD_INT 0
58687: PPUSH
// if not mc_bases [ base ] then
58688: LD_EXP 113
58692: PUSH
58693: LD_VAR 0 1
58697: ARRAY
58698: NOT
58699: IFFALSE 58703
// exit ;
58701: GO 58728
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58703: LD_ADDR_EXP 118
58707: PUSH
58708: LD_EXP 118
58712: PPUSH
58713: LD_VAR 0 1
58717: PPUSH
58718: LD_VAR 0 2
58722: PPUSH
58723: CALL_OW 1
58727: ST_TO_ADDR
// end ;
58728: LD_VAR 0 3
58732: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58733: LD_INT 0
58735: PPUSH
// if not mc_bases [ base ] then
58736: LD_EXP 113
58740: PUSH
58741: LD_VAR 0 1
58745: ARRAY
58746: NOT
58747: IFFALSE 58751
// exit ;
58749: GO 58788
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58751: LD_ADDR_EXP 118
58755: PUSH
58756: LD_EXP 118
58760: PPUSH
58761: LD_VAR 0 1
58765: PPUSH
58766: LD_EXP 118
58770: PUSH
58771: LD_VAR 0 1
58775: ARRAY
58776: PUSH
58777: LD_VAR 0 2
58781: UNION
58782: PPUSH
58783: CALL_OW 1
58787: ST_TO_ADDR
// end ;
58788: LD_VAR 0 3
58792: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58793: LD_INT 0
58795: PPUSH
// if not mc_bases [ base ] then
58796: LD_EXP 113
58800: PUSH
58801: LD_VAR 0 1
58805: ARRAY
58806: NOT
58807: IFFALSE 58811
// exit ;
58809: GO 58836
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58811: LD_ADDR_EXP 134
58815: PUSH
58816: LD_EXP 134
58820: PPUSH
58821: LD_VAR 0 1
58825: PPUSH
58826: LD_VAR 0 2
58830: PPUSH
58831: CALL_OW 1
58835: ST_TO_ADDR
// end ;
58836: LD_VAR 0 3
58840: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58841: LD_INT 0
58843: PPUSH
// if not mc_bases [ base ] then
58844: LD_EXP 113
58848: PUSH
58849: LD_VAR 0 1
58853: ARRAY
58854: NOT
58855: IFFALSE 58859
// exit ;
58857: GO 58896
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58859: LD_ADDR_EXP 134
58863: PUSH
58864: LD_EXP 134
58868: PPUSH
58869: LD_VAR 0 1
58873: PPUSH
58874: LD_EXP 134
58878: PUSH
58879: LD_VAR 0 1
58883: ARRAY
58884: PUSH
58885: LD_VAR 0 2
58889: ADD
58890: PPUSH
58891: CALL_OW 1
58895: ST_TO_ADDR
// end ;
58896: LD_VAR 0 3
58900: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58901: LD_INT 0
58903: PPUSH
// if not mc_bases [ base ] then
58904: LD_EXP 113
58908: PUSH
58909: LD_VAR 0 1
58913: ARRAY
58914: NOT
58915: IFFALSE 58919
// exit ;
58917: GO 58973
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58919: LD_ADDR_EXP 135
58923: PUSH
58924: LD_EXP 135
58928: PPUSH
58929: LD_VAR 0 1
58933: PPUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: CALL_OW 1
58943: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58944: LD_ADDR_EXP 124
58948: PUSH
58949: LD_EXP 124
58953: PPUSH
58954: LD_VAR 0 1
58958: PPUSH
58959: LD_VAR 0 2
58963: PUSH
58964: LD_INT 0
58966: PLUS
58967: PPUSH
58968: CALL_OW 1
58972: ST_TO_ADDR
// end ;
58973: LD_VAR 0 3
58977: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58978: LD_INT 0
58980: PPUSH
// if not mc_bases [ base ] then
58981: LD_EXP 113
58985: PUSH
58986: LD_VAR 0 1
58990: ARRAY
58991: NOT
58992: IFFALSE 58996
// exit ;
58994: GO 59021
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58996: LD_ADDR_EXP 124
59000: PUSH
59001: LD_EXP 124
59005: PPUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: LD_VAR 0 2
59015: PPUSH
59016: CALL_OW 1
59020: ST_TO_ADDR
// end ;
59021: LD_VAR 0 3
59025: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59026: LD_INT 0
59028: PPUSH
59029: PPUSH
59030: PPUSH
59031: PPUSH
// if not mc_bases [ base ] then
59032: LD_EXP 113
59036: PUSH
59037: LD_VAR 0 1
59041: ARRAY
59042: NOT
59043: IFFALSE 59047
// exit ;
59045: GO 59112
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59047: LD_ADDR_EXP 133
59051: PUSH
59052: LD_EXP 133
59056: PPUSH
59057: LD_VAR 0 1
59061: PUSH
59062: LD_EXP 133
59066: PUSH
59067: LD_VAR 0 1
59071: ARRAY
59072: PUSH
59073: LD_INT 1
59075: PLUS
59076: PUSH
59077: EMPTY
59078: LIST
59079: LIST
59080: PPUSH
59081: LD_VAR 0 1
59085: PUSH
59086: LD_VAR 0 2
59090: PUSH
59091: LD_VAR 0 3
59095: PUSH
59096: LD_VAR 0 4
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: LIST
59105: LIST
59106: PPUSH
59107: CALL 70150 0 3
59111: ST_TO_ADDR
// end ;
59112: LD_VAR 0 5
59116: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59117: LD_INT 0
59119: PPUSH
// if not mc_bases [ base ] then
59120: LD_EXP 113
59124: PUSH
59125: LD_VAR 0 1
59129: ARRAY
59130: NOT
59131: IFFALSE 59135
// exit ;
59133: GO 59160
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59135: LD_ADDR_EXP 150
59139: PUSH
59140: LD_EXP 150
59144: PPUSH
59145: LD_VAR 0 1
59149: PPUSH
59150: LD_VAR 0 2
59154: PPUSH
59155: CALL_OW 1
59159: ST_TO_ADDR
// end ;
59160: LD_VAR 0 3
59164: RET
// export function MC_GetMinesField ( base ) ; begin
59165: LD_INT 0
59167: PPUSH
// result := mc_mines [ base ] ;
59168: LD_ADDR_VAR 0 2
59172: PUSH
59173: LD_EXP 126
59177: PUSH
59178: LD_VAR 0 1
59182: ARRAY
59183: ST_TO_ADDR
// end ;
59184: LD_VAR 0 2
59188: RET
// export function MC_GetProduceList ( base ) ; begin
59189: LD_INT 0
59191: PPUSH
// result := mc_produce [ base ] ;
59192: LD_ADDR_VAR 0 2
59196: PUSH
59197: LD_EXP 134
59201: PUSH
59202: LD_VAR 0 1
59206: ARRAY
59207: ST_TO_ADDR
// end ;
59208: LD_VAR 0 2
59212: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59213: LD_INT 0
59215: PPUSH
59216: PPUSH
// if not mc_bases then
59217: LD_EXP 113
59221: NOT
59222: IFFALSE 59226
// exit ;
59224: GO 59291
// if mc_bases [ base ] then
59226: LD_EXP 113
59230: PUSH
59231: LD_VAR 0 1
59235: ARRAY
59236: IFFALSE 59291
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59238: LD_ADDR_VAR 0 3
59242: PUSH
59243: LD_EXP 113
59247: PUSH
59248: LD_VAR 0 1
59252: ARRAY
59253: PPUSH
59254: LD_INT 30
59256: PUSH
59257: LD_VAR 0 2
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: PPUSH
59266: CALL_OW 72
59270: ST_TO_ADDR
// if result then
59271: LD_VAR 0 3
59275: IFFALSE 59291
// result := result [ 1 ] ;
59277: LD_ADDR_VAR 0 3
59281: PUSH
59282: LD_VAR 0 3
59286: PUSH
59287: LD_INT 1
59289: ARRAY
59290: ST_TO_ADDR
// end ; end ;
59291: LD_VAR 0 3
59295: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
// if not mc_bases then
59300: LD_EXP 113
59304: NOT
59305: IFFALSE 59309
// exit ;
59307: GO 59354
// if mc_bases [ base ] then
59309: LD_EXP 113
59313: PUSH
59314: LD_VAR 0 1
59318: ARRAY
59319: IFFALSE 59354
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59321: LD_ADDR_VAR 0 3
59325: PUSH
59326: LD_EXP 113
59330: PUSH
59331: LD_VAR 0 1
59335: ARRAY
59336: PPUSH
59337: LD_INT 30
59339: PUSH
59340: LD_VAR 0 2
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: PPUSH
59349: CALL_OW 72
59353: ST_TO_ADDR
// end ;
59354: LD_VAR 0 3
59358: RET
// export function MC_SetTame ( base , area ) ; begin
59359: LD_INT 0
59361: PPUSH
// if not mc_bases or not base then
59362: LD_EXP 113
59366: NOT
59367: PUSH
59368: LD_VAR 0 1
59372: NOT
59373: OR
59374: IFFALSE 59378
// exit ;
59376: GO 59403
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59378: LD_ADDR_EXP 141
59382: PUSH
59383: LD_EXP 141
59387: PPUSH
59388: LD_VAR 0 1
59392: PPUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: CALL_OW 1
59402: ST_TO_ADDR
// end ;
59403: LD_VAR 0 3
59407: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59408: LD_INT 0
59410: PPUSH
59411: PPUSH
// if not mc_bases or not base then
59412: LD_EXP 113
59416: NOT
59417: PUSH
59418: LD_VAR 0 1
59422: NOT
59423: OR
59424: IFFALSE 59428
// exit ;
59426: GO 59530
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59428: LD_ADDR_VAR 0 4
59432: PUSH
59433: LD_EXP 113
59437: PUSH
59438: LD_VAR 0 1
59442: ARRAY
59443: PPUSH
59444: LD_INT 30
59446: PUSH
59447: LD_VAR 0 2
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: PPUSH
59456: CALL_OW 72
59460: ST_TO_ADDR
// if not tmp then
59461: LD_VAR 0 4
59465: NOT
59466: IFFALSE 59470
// exit ;
59468: GO 59530
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59470: LD_ADDR_EXP 145
59474: PUSH
59475: LD_EXP 145
59479: PPUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: LD_EXP 145
59489: PUSH
59490: LD_VAR 0 1
59494: ARRAY
59495: PPUSH
59496: LD_EXP 145
59500: PUSH
59501: LD_VAR 0 1
59505: ARRAY
59506: PUSH
59507: LD_INT 1
59509: PLUS
59510: PPUSH
59511: LD_VAR 0 4
59515: PUSH
59516: LD_INT 1
59518: ARRAY
59519: PPUSH
59520: CALL_OW 2
59524: PPUSH
59525: CALL_OW 1
59529: ST_TO_ADDR
// end ;
59530: LD_VAR 0 3
59534: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59535: LD_INT 0
59537: PPUSH
59538: PPUSH
// if not mc_bases or not base or not kinds then
59539: LD_EXP 113
59543: NOT
59544: PUSH
59545: LD_VAR 0 1
59549: NOT
59550: OR
59551: PUSH
59552: LD_VAR 0 2
59556: NOT
59557: OR
59558: IFFALSE 59562
// exit ;
59560: GO 59623
// for i in kinds do
59562: LD_ADDR_VAR 0 4
59566: PUSH
59567: LD_VAR 0 2
59571: PUSH
59572: FOR_IN
59573: IFFALSE 59621
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59575: LD_ADDR_EXP 147
59579: PUSH
59580: LD_EXP 147
59584: PPUSH
59585: LD_VAR 0 1
59589: PUSH
59590: LD_EXP 147
59594: PUSH
59595: LD_VAR 0 1
59599: ARRAY
59600: PUSH
59601: LD_INT 1
59603: PLUS
59604: PUSH
59605: EMPTY
59606: LIST
59607: LIST
59608: PPUSH
59609: LD_VAR 0 4
59613: PPUSH
59614: CALL 70150 0 3
59618: ST_TO_ADDR
59619: GO 59572
59621: POP
59622: POP
// end ;
59623: LD_VAR 0 3
59627: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59628: LD_INT 0
59630: PPUSH
// if not mc_bases or not base or not areas then
59631: LD_EXP 113
59635: NOT
59636: PUSH
59637: LD_VAR 0 1
59641: NOT
59642: OR
59643: PUSH
59644: LD_VAR 0 2
59648: NOT
59649: OR
59650: IFFALSE 59654
// exit ;
59652: GO 59679
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59654: LD_ADDR_EXP 131
59658: PUSH
59659: LD_EXP 131
59663: PPUSH
59664: LD_VAR 0 1
59668: PPUSH
59669: LD_VAR 0 2
59673: PPUSH
59674: CALL_OW 1
59678: ST_TO_ADDR
// end ;
59679: LD_VAR 0 3
59683: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59684: LD_INT 0
59686: PPUSH
// if not mc_bases or not base or not teleports_exit then
59687: LD_EXP 113
59691: NOT
59692: PUSH
59693: LD_VAR 0 1
59697: NOT
59698: OR
59699: PUSH
59700: LD_VAR 0 2
59704: NOT
59705: OR
59706: IFFALSE 59710
// exit ;
59708: GO 59735
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59710: LD_ADDR_EXP 148
59714: PUSH
59715: LD_EXP 148
59719: PPUSH
59720: LD_VAR 0 1
59724: PPUSH
59725: LD_VAR 0 2
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// end ;
59735: LD_VAR 0 3
59739: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59740: LD_INT 0
59742: PPUSH
59743: PPUSH
59744: PPUSH
// if not mc_bases or not base or not ext_list then
59745: LD_EXP 113
59749: NOT
59750: PUSH
59751: LD_VAR 0 1
59755: NOT
59756: OR
59757: PUSH
59758: LD_VAR 0 5
59762: NOT
59763: OR
59764: IFFALSE 59768
// exit ;
59766: GO 59941
// tmp := GetFacExtXYD ( x , y , d ) ;
59768: LD_ADDR_VAR 0 8
59772: PUSH
59773: LD_VAR 0 2
59777: PPUSH
59778: LD_VAR 0 3
59782: PPUSH
59783: LD_VAR 0 4
59787: PPUSH
59788: CALL 98829 0 3
59792: ST_TO_ADDR
// if not tmp then
59793: LD_VAR 0 8
59797: NOT
59798: IFFALSE 59802
// exit ;
59800: GO 59941
// for i in tmp do
59802: LD_ADDR_VAR 0 7
59806: PUSH
59807: LD_VAR 0 8
59811: PUSH
59812: FOR_IN
59813: IFFALSE 59939
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59815: LD_ADDR_EXP 118
59819: PUSH
59820: LD_EXP 118
59824: PPUSH
59825: LD_VAR 0 1
59829: PPUSH
59830: LD_EXP 118
59834: PUSH
59835: LD_VAR 0 1
59839: ARRAY
59840: PPUSH
59841: LD_EXP 118
59845: PUSH
59846: LD_VAR 0 1
59850: ARRAY
59851: PUSH
59852: LD_INT 1
59854: PLUS
59855: PPUSH
59856: LD_VAR 0 5
59860: PUSH
59861: LD_INT 1
59863: ARRAY
59864: PUSH
59865: LD_VAR 0 7
59869: PUSH
59870: LD_INT 1
59872: ARRAY
59873: PUSH
59874: LD_VAR 0 7
59878: PUSH
59879: LD_INT 2
59881: ARRAY
59882: PUSH
59883: LD_VAR 0 7
59887: PUSH
59888: LD_INT 3
59890: ARRAY
59891: PUSH
59892: EMPTY
59893: LIST
59894: LIST
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 2
59902: PPUSH
59903: CALL_OW 1
59907: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59908: LD_ADDR_VAR 0 5
59912: PUSH
59913: LD_VAR 0 5
59917: PPUSH
59918: LD_INT 1
59920: PPUSH
59921: CALL_OW 3
59925: ST_TO_ADDR
// if not ext_list then
59926: LD_VAR 0 5
59930: NOT
59931: IFFALSE 59937
// exit ;
59933: POP
59934: POP
59935: GO 59941
// end ;
59937: GO 59812
59939: POP
59940: POP
// end ;
59941: LD_VAR 0 6
59945: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59946: LD_INT 0
59948: PPUSH
// if not mc_bases or not base or not weapon_list then
59949: LD_EXP 113
59953: NOT
59954: PUSH
59955: LD_VAR 0 1
59959: NOT
59960: OR
59961: PUSH
59962: LD_VAR 0 2
59966: NOT
59967: OR
59968: IFFALSE 59972
// exit ;
59970: GO 59997
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59972: LD_ADDR_EXP 152
59976: PUSH
59977: LD_EXP 152
59981: PPUSH
59982: LD_VAR 0 1
59986: PPUSH
59987: LD_VAR 0 2
59991: PPUSH
59992: CALL_OW 1
59996: ST_TO_ADDR
// end ;
59997: LD_VAR 0 3
60001: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60002: LD_INT 0
60004: PPUSH
// if not mc_bases or not base or not tech_list then
60005: LD_EXP 113
60009: NOT
60010: PUSH
60011: LD_VAR 0 1
60015: NOT
60016: OR
60017: PUSH
60018: LD_VAR 0 2
60022: NOT
60023: OR
60024: IFFALSE 60028
// exit ;
60026: GO 60053
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60028: LD_ADDR_EXP 140
60032: PUSH
60033: LD_EXP 140
60037: PPUSH
60038: LD_VAR 0 1
60042: PPUSH
60043: LD_VAR 0 2
60047: PPUSH
60048: CALL_OW 1
60052: ST_TO_ADDR
// end ;
60053: LD_VAR 0 3
60057: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60058: LD_INT 0
60060: PPUSH
// if not mc_bases or not parking_area or not base then
60061: LD_EXP 113
60065: NOT
60066: PUSH
60067: LD_VAR 0 2
60071: NOT
60072: OR
60073: PUSH
60074: LD_VAR 0 1
60078: NOT
60079: OR
60080: IFFALSE 60084
// exit ;
60082: GO 60109
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60084: LD_ADDR_EXP 137
60088: PUSH
60089: LD_EXP 137
60093: PPUSH
60094: LD_VAR 0 1
60098: PPUSH
60099: LD_VAR 0 2
60103: PPUSH
60104: CALL_OW 1
60108: ST_TO_ADDR
// end ;
60109: LD_VAR 0 3
60113: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60114: LD_INT 0
60116: PPUSH
// if not mc_bases or not base or not scan_area then
60117: LD_EXP 113
60121: NOT
60122: PUSH
60123: LD_VAR 0 1
60127: NOT
60128: OR
60129: PUSH
60130: LD_VAR 0 2
60134: NOT
60135: OR
60136: IFFALSE 60140
// exit ;
60138: GO 60165
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60140: LD_ADDR_EXP 138
60144: PUSH
60145: LD_EXP 138
60149: PPUSH
60150: LD_VAR 0 1
60154: PPUSH
60155: LD_VAR 0 2
60159: PPUSH
60160: CALL_OW 1
60164: ST_TO_ADDR
// end ;
60165: LD_VAR 0 3
60169: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60170: LD_INT 0
60172: PPUSH
60173: PPUSH
// if not mc_bases or not base then
60174: LD_EXP 113
60178: NOT
60179: PUSH
60180: LD_VAR 0 1
60184: NOT
60185: OR
60186: IFFALSE 60190
// exit ;
60188: GO 60254
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60190: LD_ADDR_VAR 0 3
60194: PUSH
60195: LD_INT 1
60197: PUSH
60198: LD_INT 2
60200: PUSH
60201: LD_INT 3
60203: PUSH
60204: LD_INT 4
60206: PUSH
60207: LD_INT 11
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60217: LD_ADDR_EXP 140
60221: PUSH
60222: LD_EXP 140
60226: PPUSH
60227: LD_VAR 0 1
60231: PPUSH
60232: LD_EXP 140
60236: PUSH
60237: LD_VAR 0 1
60241: ARRAY
60242: PUSH
60243: LD_VAR 0 3
60247: DIFF
60248: PPUSH
60249: CALL_OW 1
60253: ST_TO_ADDR
// end ;
60254: LD_VAR 0 2
60258: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60259: LD_INT 0
60261: PPUSH
// result := mc_vehicles [ base ] ;
60262: LD_ADDR_VAR 0 3
60266: PUSH
60267: LD_EXP 132
60271: PUSH
60272: LD_VAR 0 1
60276: ARRAY
60277: ST_TO_ADDR
// if onlyCombat then
60278: LD_VAR 0 2
60282: IFFALSE 60460
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60284: LD_ADDR_VAR 0 3
60288: PUSH
60289: LD_VAR 0 3
60293: PUSH
60294: LD_VAR 0 3
60298: PPUSH
60299: LD_INT 2
60301: PUSH
60302: LD_INT 34
60304: PUSH
60305: LD_INT 12
60307: PUSH
60308: EMPTY
60309: LIST
60310: LIST
60311: PUSH
60312: LD_INT 34
60314: PUSH
60315: LD_INT 51
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: PUSH
60322: LD_INT 34
60324: PUSH
60325: LD_EXP 96
60329: PUSH
60330: EMPTY
60331: LIST
60332: LIST
60333: PUSH
60334: LD_INT 34
60336: PUSH
60337: LD_INT 32
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: PUSH
60344: LD_INT 34
60346: PUSH
60347: LD_INT 13
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 34
60356: PUSH
60357: LD_INT 52
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 34
60366: PUSH
60367: LD_EXP 101
60371: PUSH
60372: EMPTY
60373: LIST
60374: LIST
60375: PUSH
60376: LD_INT 34
60378: PUSH
60379: LD_INT 14
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: LD_INT 34
60388: PUSH
60389: LD_INT 53
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 34
60398: PUSH
60399: LD_EXP 95
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: PUSH
60408: LD_INT 34
60410: PUSH
60411: LD_INT 31
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PUSH
60418: LD_INT 34
60420: PUSH
60421: LD_INT 48
60423: PUSH
60424: EMPTY
60425: LIST
60426: LIST
60427: PUSH
60428: LD_INT 34
60430: PUSH
60431: LD_INT 8
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: LIST
60442: LIST
60443: LIST
60444: LIST
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: PPUSH
60454: CALL_OW 72
60458: DIFF
60459: ST_TO_ADDR
// end ; end_of_file
60460: LD_VAR 0 3
60464: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60465: LD_INT 0
60467: PPUSH
60468: PPUSH
60469: PPUSH
// if not mc_bases or not skirmish then
60470: LD_EXP 113
60474: NOT
60475: PUSH
60476: LD_EXP 111
60480: NOT
60481: OR
60482: IFFALSE 60486
// exit ;
60484: GO 60651
// for i = 1 to mc_bases do
60486: LD_ADDR_VAR 0 4
60490: PUSH
60491: DOUBLE
60492: LD_INT 1
60494: DEC
60495: ST_TO_ADDR
60496: LD_EXP 113
60500: PUSH
60501: FOR_TO
60502: IFFALSE 60649
// begin if sci in mc_bases [ i ] then
60504: LD_VAR 0 2
60508: PUSH
60509: LD_EXP 113
60513: PUSH
60514: LD_VAR 0 4
60518: ARRAY
60519: IN
60520: IFFALSE 60647
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60522: LD_ADDR_EXP 142
60526: PUSH
60527: LD_EXP 142
60531: PPUSH
60532: LD_VAR 0 4
60536: PUSH
60537: LD_EXP 142
60541: PUSH
60542: LD_VAR 0 4
60546: ARRAY
60547: PUSH
60548: LD_INT 1
60550: PLUS
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PPUSH
60556: LD_VAR 0 1
60560: PPUSH
60561: CALL 70150 0 3
60565: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60566: LD_ADDR_VAR 0 5
60570: PUSH
60571: LD_EXP 113
60575: PUSH
60576: LD_VAR 0 4
60580: ARRAY
60581: PPUSH
60582: LD_INT 2
60584: PUSH
60585: LD_INT 30
60587: PUSH
60588: LD_INT 0
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: PUSH
60595: LD_INT 30
60597: PUSH
60598: LD_INT 1
60600: PUSH
60601: EMPTY
60602: LIST
60603: LIST
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: LIST
60609: PPUSH
60610: CALL_OW 72
60614: PPUSH
60615: LD_VAR 0 1
60619: PPUSH
60620: CALL_OW 74
60624: ST_TO_ADDR
// if tmp then
60625: LD_VAR 0 5
60629: IFFALSE 60645
// ComStandNearbyBuilding ( ape , tmp ) ;
60631: LD_VAR 0 1
60635: PPUSH
60636: LD_VAR 0 5
60640: PPUSH
60641: CALL 66764 0 2
// break ;
60645: GO 60649
// end ; end ;
60647: GO 60501
60649: POP
60650: POP
// end ;
60651: LD_VAR 0 3
60655: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60656: LD_INT 0
60658: PPUSH
60659: PPUSH
60660: PPUSH
// if not mc_bases or not skirmish then
60661: LD_EXP 113
60665: NOT
60666: PUSH
60667: LD_EXP 111
60671: NOT
60672: OR
60673: IFFALSE 60677
// exit ;
60675: GO 60766
// for i = 1 to mc_bases do
60677: LD_ADDR_VAR 0 4
60681: PUSH
60682: DOUBLE
60683: LD_INT 1
60685: DEC
60686: ST_TO_ADDR
60687: LD_EXP 113
60691: PUSH
60692: FOR_TO
60693: IFFALSE 60764
// begin if building in mc_busy_turret_list [ i ] then
60695: LD_VAR 0 1
60699: PUSH
60700: LD_EXP 123
60704: PUSH
60705: LD_VAR 0 4
60709: ARRAY
60710: IN
60711: IFFALSE 60762
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60713: LD_ADDR_VAR 0 5
60717: PUSH
60718: LD_EXP 123
60722: PUSH
60723: LD_VAR 0 4
60727: ARRAY
60728: PUSH
60729: LD_VAR 0 1
60733: DIFF
60734: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60735: LD_ADDR_EXP 123
60739: PUSH
60740: LD_EXP 123
60744: PPUSH
60745: LD_VAR 0 4
60749: PPUSH
60750: LD_VAR 0 5
60754: PPUSH
60755: CALL_OW 1
60759: ST_TO_ADDR
// break ;
60760: GO 60764
// end ; end ;
60762: GO 60692
60764: POP
60765: POP
// end ;
60766: LD_VAR 0 3
60770: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60771: LD_INT 0
60773: PPUSH
60774: PPUSH
60775: PPUSH
// if not mc_bases or not skirmish then
60776: LD_EXP 113
60780: NOT
60781: PUSH
60782: LD_EXP 111
60786: NOT
60787: OR
60788: IFFALSE 60792
// exit ;
60790: GO 60991
// for i = 1 to mc_bases do
60792: LD_ADDR_VAR 0 5
60796: PUSH
60797: DOUBLE
60798: LD_INT 1
60800: DEC
60801: ST_TO_ADDR
60802: LD_EXP 113
60806: PUSH
60807: FOR_TO
60808: IFFALSE 60989
// if building in mc_bases [ i ] then
60810: LD_VAR 0 1
60814: PUSH
60815: LD_EXP 113
60819: PUSH
60820: LD_VAR 0 5
60824: ARRAY
60825: IN
60826: IFFALSE 60987
// begin tmp := mc_bases [ i ] diff building ;
60828: LD_ADDR_VAR 0 6
60832: PUSH
60833: LD_EXP 113
60837: PUSH
60838: LD_VAR 0 5
60842: ARRAY
60843: PUSH
60844: LD_VAR 0 1
60848: DIFF
60849: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60850: LD_ADDR_EXP 113
60854: PUSH
60855: LD_EXP 113
60859: PPUSH
60860: LD_VAR 0 5
60864: PPUSH
60865: LD_VAR 0 6
60869: PPUSH
60870: CALL_OW 1
60874: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60875: LD_VAR 0 1
60879: PUSH
60880: LD_EXP 121
60884: PUSH
60885: LD_VAR 0 5
60889: ARRAY
60890: IN
60891: IFFALSE 60930
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60893: LD_ADDR_EXP 121
60897: PUSH
60898: LD_EXP 121
60902: PPUSH
60903: LD_VAR 0 5
60907: PPUSH
60908: LD_EXP 121
60912: PUSH
60913: LD_VAR 0 5
60917: ARRAY
60918: PUSH
60919: LD_VAR 0 1
60923: DIFF
60924: PPUSH
60925: CALL_OW 1
60929: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60930: LD_VAR 0 1
60934: PUSH
60935: LD_EXP 122
60939: PUSH
60940: LD_VAR 0 5
60944: ARRAY
60945: IN
60946: IFFALSE 60985
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60948: LD_ADDR_EXP 122
60952: PUSH
60953: LD_EXP 122
60957: PPUSH
60958: LD_VAR 0 5
60962: PPUSH
60963: LD_EXP 122
60967: PUSH
60968: LD_VAR 0 5
60972: ARRAY
60973: PUSH
60974: LD_VAR 0 1
60978: DIFF
60979: PPUSH
60980: CALL_OW 1
60984: ST_TO_ADDR
// break ;
60985: GO 60989
// end ;
60987: GO 60807
60989: POP
60990: POP
// end ;
60991: LD_VAR 0 4
60995: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60996: LD_INT 0
60998: PPUSH
60999: PPUSH
61000: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61001: LD_EXP 113
61005: NOT
61006: PUSH
61007: LD_EXP 111
61011: NOT
61012: OR
61013: PUSH
61014: LD_VAR 0 3
61018: PUSH
61019: LD_EXP 139
61023: IN
61024: NOT
61025: OR
61026: IFFALSE 61030
// exit ;
61028: GO 61153
// for i = 1 to mc_vehicles do
61030: LD_ADDR_VAR 0 6
61034: PUSH
61035: DOUBLE
61036: LD_INT 1
61038: DEC
61039: ST_TO_ADDR
61040: LD_EXP 132
61044: PUSH
61045: FOR_TO
61046: IFFALSE 61151
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61048: LD_VAR 0 2
61052: PUSH
61053: LD_EXP 132
61057: PUSH
61058: LD_VAR 0 6
61062: ARRAY
61063: IN
61064: PUSH
61065: LD_VAR 0 1
61069: PUSH
61070: LD_EXP 132
61074: PUSH
61075: LD_VAR 0 6
61079: ARRAY
61080: IN
61081: OR
61082: IFFALSE 61149
// begin tmp := mc_vehicles [ i ] diff old ;
61084: LD_ADDR_VAR 0 7
61088: PUSH
61089: LD_EXP 132
61093: PUSH
61094: LD_VAR 0 6
61098: ARRAY
61099: PUSH
61100: LD_VAR 0 2
61104: DIFF
61105: ST_TO_ADDR
// tmp := tmp diff new ;
61106: LD_ADDR_VAR 0 7
61110: PUSH
61111: LD_VAR 0 7
61115: PUSH
61116: LD_VAR 0 1
61120: DIFF
61121: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61122: LD_ADDR_EXP 132
61126: PUSH
61127: LD_EXP 132
61131: PPUSH
61132: LD_VAR 0 6
61136: PPUSH
61137: LD_VAR 0 7
61141: PPUSH
61142: CALL_OW 1
61146: ST_TO_ADDR
// break ;
61147: GO 61151
// end ;
61149: GO 61045
61151: POP
61152: POP
// end ;
61153: LD_VAR 0 5
61157: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61158: LD_INT 0
61160: PPUSH
61161: PPUSH
61162: PPUSH
61163: PPUSH
// if not mc_bases or not skirmish then
61164: LD_EXP 113
61168: NOT
61169: PUSH
61170: LD_EXP 111
61174: NOT
61175: OR
61176: IFFALSE 61180
// exit ;
61178: GO 61563
// side := GetSide ( vehicle ) ;
61180: LD_ADDR_VAR 0 5
61184: PUSH
61185: LD_VAR 0 1
61189: PPUSH
61190: CALL_OW 255
61194: ST_TO_ADDR
// for i = 1 to mc_bases do
61195: LD_ADDR_VAR 0 4
61199: PUSH
61200: DOUBLE
61201: LD_INT 1
61203: DEC
61204: ST_TO_ADDR
61205: LD_EXP 113
61209: PUSH
61210: FOR_TO
61211: IFFALSE 61561
// begin if factory in mc_bases [ i ] then
61213: LD_VAR 0 2
61217: PUSH
61218: LD_EXP 113
61222: PUSH
61223: LD_VAR 0 4
61227: ARRAY
61228: IN
61229: IFFALSE 61559
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61231: LD_EXP 135
61235: PUSH
61236: LD_VAR 0 4
61240: ARRAY
61241: PUSH
61242: LD_EXP 124
61246: PUSH
61247: LD_VAR 0 4
61251: ARRAY
61252: LESS
61253: PUSH
61254: LD_VAR 0 1
61258: PPUSH
61259: CALL_OW 264
61263: PUSH
61264: LD_INT 31
61266: PUSH
61267: LD_INT 32
61269: PUSH
61270: LD_INT 51
61272: PUSH
61273: LD_EXP 96
61277: PUSH
61278: LD_INT 12
61280: PUSH
61281: LD_INT 30
61283: PUSH
61284: LD_EXP 95
61288: PUSH
61289: LD_INT 11
61291: PUSH
61292: LD_INT 53
61294: PUSH
61295: LD_INT 14
61297: PUSH
61298: LD_EXP 99
61302: PUSH
61303: LD_INT 29
61305: PUSH
61306: LD_EXP 97
61310: PUSH
61311: LD_INT 13
61313: PUSH
61314: LD_INT 52
61316: PUSH
61317: LD_EXP 101
61321: PUSH
61322: LD_INT 48
61324: PUSH
61325: LD_INT 8
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: LIST
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: IN
61348: NOT
61349: AND
61350: IFFALSE 61398
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61352: LD_ADDR_EXP 135
61356: PUSH
61357: LD_EXP 135
61361: PPUSH
61362: LD_VAR 0 4
61366: PUSH
61367: LD_EXP 135
61371: PUSH
61372: LD_VAR 0 4
61376: ARRAY
61377: PUSH
61378: LD_INT 1
61380: PLUS
61381: PUSH
61382: EMPTY
61383: LIST
61384: LIST
61385: PPUSH
61386: LD_VAR 0 1
61390: PPUSH
61391: CALL 70150 0 3
61395: ST_TO_ADDR
61396: GO 61442
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61398: LD_ADDR_EXP 132
61402: PUSH
61403: LD_EXP 132
61407: PPUSH
61408: LD_VAR 0 4
61412: PUSH
61413: LD_EXP 132
61417: PUSH
61418: LD_VAR 0 4
61422: ARRAY
61423: PUSH
61424: LD_INT 1
61426: PLUS
61427: PUSH
61428: EMPTY
61429: LIST
61430: LIST
61431: PPUSH
61432: LD_VAR 0 1
61436: PPUSH
61437: CALL 70150 0 3
61441: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL_OW 263
61451: PUSH
61452: LD_INT 2
61454: EQUAL
61455: IFFALSE 61475
// begin repeat wait ( 0 0$1 ) ;
61457: LD_INT 35
61459: PPUSH
61460: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61464: LD_VAR 0 1
61468: PPUSH
61469: CALL_OW 312
61473: IFFALSE 61457
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61475: LD_VAR 0 1
61479: PPUSH
61480: LD_EXP 137
61484: PUSH
61485: LD_VAR 0 4
61489: ARRAY
61490: PPUSH
61491: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61495: LD_VAR 0 1
61499: PPUSH
61500: CALL_OW 263
61504: PUSH
61505: LD_INT 1
61507: NONEQUAL
61508: IFFALSE 61512
// break ;
61510: GO 61561
// repeat wait ( 0 0$1 ) ;
61512: LD_INT 35
61514: PPUSH
61515: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61519: LD_VAR 0 1
61523: PPUSH
61524: LD_EXP 137
61528: PUSH
61529: LD_VAR 0 4
61533: ARRAY
61534: PPUSH
61535: CALL_OW 308
61539: IFFALSE 61512
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61541: LD_VAR 0 1
61545: PPUSH
61546: CALL_OW 311
61550: PPUSH
61551: CALL_OW 121
// exit ;
61555: POP
61556: POP
61557: GO 61563
// end ; end ;
61559: GO 61210
61561: POP
61562: POP
// end ;
61563: LD_VAR 0 3
61567: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61568: LD_INT 0
61570: PPUSH
61571: PPUSH
61572: PPUSH
61573: PPUSH
// if not mc_bases or not skirmish then
61574: LD_EXP 113
61578: NOT
61579: PUSH
61580: LD_EXP 111
61584: NOT
61585: OR
61586: IFFALSE 61590
// exit ;
61588: GO 61943
// repeat wait ( 0 0$1 ) ;
61590: LD_INT 35
61592: PPUSH
61593: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61597: LD_VAR 0 2
61601: PPUSH
61602: LD_VAR 0 3
61606: PPUSH
61607: CALL_OW 284
61611: IFFALSE 61590
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61613: LD_VAR 0 2
61617: PPUSH
61618: LD_VAR 0 3
61622: PPUSH
61623: CALL_OW 283
61627: PUSH
61628: LD_INT 4
61630: EQUAL
61631: IFFALSE 61635
// exit ;
61633: GO 61943
// for i = 1 to mc_bases do
61635: LD_ADDR_VAR 0 7
61639: PUSH
61640: DOUBLE
61641: LD_INT 1
61643: DEC
61644: ST_TO_ADDR
61645: LD_EXP 113
61649: PUSH
61650: FOR_TO
61651: IFFALSE 61941
// begin if mc_crates_area [ i ] then
61653: LD_EXP 131
61657: PUSH
61658: LD_VAR 0 7
61662: ARRAY
61663: IFFALSE 61774
// for j in mc_crates_area [ i ] do
61665: LD_ADDR_VAR 0 8
61669: PUSH
61670: LD_EXP 131
61674: PUSH
61675: LD_VAR 0 7
61679: ARRAY
61680: PUSH
61681: FOR_IN
61682: IFFALSE 61772
// if InArea ( x , y , j ) then
61684: LD_VAR 0 2
61688: PPUSH
61689: LD_VAR 0 3
61693: PPUSH
61694: LD_VAR 0 8
61698: PPUSH
61699: CALL_OW 309
61703: IFFALSE 61770
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61705: LD_ADDR_EXP 129
61709: PUSH
61710: LD_EXP 129
61714: PPUSH
61715: LD_VAR 0 7
61719: PUSH
61720: LD_EXP 129
61724: PUSH
61725: LD_VAR 0 7
61729: ARRAY
61730: PUSH
61731: LD_INT 1
61733: PLUS
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PPUSH
61739: LD_VAR 0 4
61743: PUSH
61744: LD_VAR 0 2
61748: PUSH
61749: LD_VAR 0 3
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: LIST
61758: PPUSH
61759: CALL 70150 0 3
61763: ST_TO_ADDR
// exit ;
61764: POP
61765: POP
61766: POP
61767: POP
61768: GO 61943
// end ;
61770: GO 61681
61772: POP
61773: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61774: LD_ADDR_VAR 0 9
61778: PUSH
61779: LD_EXP 113
61783: PUSH
61784: LD_VAR 0 7
61788: ARRAY
61789: PPUSH
61790: LD_INT 2
61792: PUSH
61793: LD_INT 30
61795: PUSH
61796: LD_INT 0
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 30
61805: PUSH
61806: LD_INT 1
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PUSH
61813: EMPTY
61814: LIST
61815: LIST
61816: LIST
61817: PPUSH
61818: CALL_OW 72
61822: ST_TO_ADDR
// if not depot then
61823: LD_VAR 0 9
61827: NOT
61828: IFFALSE 61832
// continue ;
61830: GO 61650
// for j in depot do
61832: LD_ADDR_VAR 0 8
61836: PUSH
61837: LD_VAR 0 9
61841: PUSH
61842: FOR_IN
61843: IFFALSE 61937
// if GetDistUnitXY ( j , x , y ) < 30 then
61845: LD_VAR 0 8
61849: PPUSH
61850: LD_VAR 0 2
61854: PPUSH
61855: LD_VAR 0 3
61859: PPUSH
61860: CALL_OW 297
61864: PUSH
61865: LD_INT 30
61867: LESS
61868: IFFALSE 61935
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61870: LD_ADDR_EXP 129
61874: PUSH
61875: LD_EXP 129
61879: PPUSH
61880: LD_VAR 0 7
61884: PUSH
61885: LD_EXP 129
61889: PUSH
61890: LD_VAR 0 7
61894: ARRAY
61895: PUSH
61896: LD_INT 1
61898: PLUS
61899: PUSH
61900: EMPTY
61901: LIST
61902: LIST
61903: PPUSH
61904: LD_VAR 0 4
61908: PUSH
61909: LD_VAR 0 2
61913: PUSH
61914: LD_VAR 0 3
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: LIST
61923: PPUSH
61924: CALL 70150 0 3
61928: ST_TO_ADDR
// exit ;
61929: POP
61930: POP
61931: POP
61932: POP
61933: GO 61943
// end ;
61935: GO 61842
61937: POP
61938: POP
// end ;
61939: GO 61650
61941: POP
61942: POP
// end ;
61943: LD_VAR 0 6
61947: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61948: LD_INT 0
61950: PPUSH
61951: PPUSH
61952: PPUSH
61953: PPUSH
// if not mc_bases or not skirmish then
61954: LD_EXP 113
61958: NOT
61959: PUSH
61960: LD_EXP 111
61964: NOT
61965: OR
61966: IFFALSE 61970
// exit ;
61968: GO 62247
// side := GetSide ( lab ) ;
61970: LD_ADDR_VAR 0 4
61974: PUSH
61975: LD_VAR 0 2
61979: PPUSH
61980: CALL_OW 255
61984: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61985: LD_VAR 0 4
61989: PUSH
61990: LD_EXP 139
61994: IN
61995: NOT
61996: PUSH
61997: LD_EXP 140
62001: NOT
62002: OR
62003: PUSH
62004: LD_EXP 113
62008: NOT
62009: OR
62010: IFFALSE 62014
// exit ;
62012: GO 62247
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62014: LD_ADDR_EXP 140
62018: PUSH
62019: LD_EXP 140
62023: PPUSH
62024: LD_VAR 0 4
62028: PPUSH
62029: LD_EXP 140
62033: PUSH
62034: LD_VAR 0 4
62038: ARRAY
62039: PUSH
62040: LD_VAR 0 1
62044: DIFF
62045: PPUSH
62046: CALL_OW 1
62050: ST_TO_ADDR
// for i = 1 to mc_bases do
62051: LD_ADDR_VAR 0 5
62055: PUSH
62056: DOUBLE
62057: LD_INT 1
62059: DEC
62060: ST_TO_ADDR
62061: LD_EXP 113
62065: PUSH
62066: FOR_TO
62067: IFFALSE 62245
// begin if lab in mc_bases [ i ] then
62069: LD_VAR 0 2
62073: PUSH
62074: LD_EXP 113
62078: PUSH
62079: LD_VAR 0 5
62083: ARRAY
62084: IN
62085: IFFALSE 62243
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62087: LD_VAR 0 1
62091: PUSH
62092: LD_INT 11
62094: PUSH
62095: LD_INT 4
62097: PUSH
62098: LD_INT 3
62100: PUSH
62101: LD_INT 2
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: IN
62110: PUSH
62111: LD_EXP 143
62115: PUSH
62116: LD_VAR 0 5
62120: ARRAY
62121: AND
62122: IFFALSE 62243
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62124: LD_ADDR_VAR 0 6
62128: PUSH
62129: LD_EXP 143
62133: PUSH
62134: LD_VAR 0 5
62138: ARRAY
62139: PUSH
62140: LD_INT 1
62142: ARRAY
62143: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62144: LD_ADDR_EXP 143
62148: PUSH
62149: LD_EXP 143
62153: PPUSH
62154: LD_VAR 0 5
62158: PPUSH
62159: EMPTY
62160: PPUSH
62161: CALL_OW 1
62165: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62166: LD_VAR 0 6
62170: PPUSH
62171: LD_INT 0
62173: PPUSH
62174: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62178: LD_VAR 0 6
62182: PPUSH
62183: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62187: LD_ADDR_EXP 142
62191: PUSH
62192: LD_EXP 142
62196: PPUSH
62197: LD_VAR 0 5
62201: PPUSH
62202: LD_EXP 142
62206: PUSH
62207: LD_VAR 0 5
62211: ARRAY
62212: PPUSH
62213: LD_INT 1
62215: PPUSH
62216: LD_VAR 0 6
62220: PPUSH
62221: CALL_OW 2
62225: PPUSH
62226: CALL_OW 1
62230: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62231: LD_VAR 0 5
62235: PPUSH
62236: LD_INT 112
62238: PPUSH
62239: CALL 39199 0 2
// end ; end ; end ;
62243: GO 62066
62245: POP
62246: POP
// end ;
62247: LD_VAR 0 3
62251: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62252: LD_INT 0
62254: PPUSH
62255: PPUSH
62256: PPUSH
62257: PPUSH
62258: PPUSH
62259: PPUSH
62260: PPUSH
62261: PPUSH
// if not mc_bases or not skirmish then
62262: LD_EXP 113
62266: NOT
62267: PUSH
62268: LD_EXP 111
62272: NOT
62273: OR
62274: IFFALSE 62278
// exit ;
62276: GO 63649
// for i = 1 to mc_bases do
62278: LD_ADDR_VAR 0 3
62282: PUSH
62283: DOUBLE
62284: LD_INT 1
62286: DEC
62287: ST_TO_ADDR
62288: LD_EXP 113
62292: PUSH
62293: FOR_TO
62294: IFFALSE 63647
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62296: LD_VAR 0 1
62300: PUSH
62301: LD_EXP 113
62305: PUSH
62306: LD_VAR 0 3
62310: ARRAY
62311: IN
62312: PUSH
62313: LD_VAR 0 1
62317: PUSH
62318: LD_EXP 120
62322: PUSH
62323: LD_VAR 0 3
62327: ARRAY
62328: IN
62329: OR
62330: PUSH
62331: LD_VAR 0 1
62335: PUSH
62336: LD_EXP 135
62340: PUSH
62341: LD_VAR 0 3
62345: ARRAY
62346: IN
62347: OR
62348: PUSH
62349: LD_VAR 0 1
62353: PUSH
62354: LD_EXP 132
62358: PUSH
62359: LD_VAR 0 3
62363: ARRAY
62364: IN
62365: OR
62366: PUSH
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 142
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: OR
62384: PUSH
62385: LD_VAR 0 1
62389: PUSH
62390: LD_EXP 143
62394: PUSH
62395: LD_VAR 0 3
62399: ARRAY
62400: IN
62401: OR
62402: IFFALSE 63645
// begin if un in mc_ape [ i ] then
62404: LD_VAR 0 1
62408: PUSH
62409: LD_EXP 142
62413: PUSH
62414: LD_VAR 0 3
62418: ARRAY
62419: IN
62420: IFFALSE 62459
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62422: LD_ADDR_EXP 142
62426: PUSH
62427: LD_EXP 142
62431: PPUSH
62432: LD_VAR 0 3
62436: PPUSH
62437: LD_EXP 142
62441: PUSH
62442: LD_VAR 0 3
62446: ARRAY
62447: PUSH
62448: LD_VAR 0 1
62452: DIFF
62453: PPUSH
62454: CALL_OW 1
62458: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62459: LD_VAR 0 1
62463: PUSH
62464: LD_EXP 143
62468: PUSH
62469: LD_VAR 0 3
62473: ARRAY
62474: IN
62475: IFFALSE 62499
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62477: LD_ADDR_EXP 143
62481: PUSH
62482: LD_EXP 143
62486: PPUSH
62487: LD_VAR 0 3
62491: PPUSH
62492: EMPTY
62493: PPUSH
62494: CALL_OW 1
62498: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62499: LD_VAR 0 1
62503: PPUSH
62504: CALL_OW 247
62508: PUSH
62509: LD_INT 2
62511: EQUAL
62512: PUSH
62513: LD_VAR 0 1
62517: PPUSH
62518: CALL_OW 110
62522: PUSH
62523: LD_INT 20
62525: EQUAL
62526: PUSH
62527: LD_VAR 0 1
62531: PUSH
62532: LD_EXP 135
62536: PUSH
62537: LD_VAR 0 3
62541: ARRAY
62542: IN
62543: OR
62544: PUSH
62545: LD_VAR 0 1
62549: PPUSH
62550: CALL_OW 264
62554: PUSH
62555: LD_INT 12
62557: PUSH
62558: LD_INT 51
62560: PUSH
62561: LD_EXP 96
62565: PUSH
62566: LD_INT 32
62568: PUSH
62569: LD_INT 13
62571: PUSH
62572: LD_INT 52
62574: PUSH
62575: LD_INT 31
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: IN
62587: OR
62588: AND
62589: IFFALSE 62897
// begin if un in mc_defender [ i ] then
62591: LD_VAR 0 1
62595: PUSH
62596: LD_EXP 135
62600: PUSH
62601: LD_VAR 0 3
62605: ARRAY
62606: IN
62607: IFFALSE 62646
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62609: LD_ADDR_EXP 135
62613: PUSH
62614: LD_EXP 135
62618: PPUSH
62619: LD_VAR 0 3
62623: PPUSH
62624: LD_EXP 135
62628: PUSH
62629: LD_VAR 0 3
62633: ARRAY
62634: PUSH
62635: LD_VAR 0 1
62639: DIFF
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62646: LD_ADDR_VAR 0 8
62650: PUSH
62651: LD_VAR 0 3
62655: PPUSH
62656: LD_INT 3
62658: PPUSH
62659: CALL 59296 0 2
62663: ST_TO_ADDR
// if fac then
62664: LD_VAR 0 8
62668: IFFALSE 62897
// begin for j in fac do
62670: LD_ADDR_VAR 0 4
62674: PUSH
62675: LD_VAR 0 8
62679: PUSH
62680: FOR_IN
62681: IFFALSE 62895
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62683: LD_ADDR_VAR 0 9
62687: PUSH
62688: LD_VAR 0 8
62692: PPUSH
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 265
62702: PPUSH
62703: LD_VAR 0 1
62707: PPUSH
62708: CALL_OW 262
62712: PPUSH
62713: LD_VAR 0 1
62717: PPUSH
62718: CALL_OW 263
62722: PPUSH
62723: LD_VAR 0 1
62727: PPUSH
62728: CALL_OW 264
62732: PPUSH
62733: CALL 67682 0 5
62737: ST_TO_ADDR
// if components then
62738: LD_VAR 0 9
62742: IFFALSE 62893
// begin if GetWeapon ( un ) = ar_control_tower then
62744: LD_VAR 0 1
62748: PPUSH
62749: CALL_OW 264
62753: PUSH
62754: LD_INT 31
62756: EQUAL
62757: IFFALSE 62874
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62759: LD_VAR 0 1
62763: PPUSH
62764: CALL_OW 311
62768: PPUSH
62769: LD_INT 0
62771: PPUSH
62772: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62776: LD_ADDR_EXP 153
62780: PUSH
62781: LD_EXP 153
62785: PPUSH
62786: LD_VAR 0 3
62790: PPUSH
62791: LD_EXP 153
62795: PUSH
62796: LD_VAR 0 3
62800: ARRAY
62801: PUSH
62802: LD_VAR 0 1
62806: PPUSH
62807: CALL_OW 311
62811: DIFF
62812: PPUSH
62813: CALL_OW 1
62817: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62818: LD_ADDR_VAR 0 7
62822: PUSH
62823: LD_EXP 134
62827: PUSH
62828: LD_VAR 0 3
62832: ARRAY
62833: PPUSH
62834: LD_INT 1
62836: PPUSH
62837: LD_VAR 0 9
62841: PPUSH
62842: CALL_OW 2
62846: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62847: LD_ADDR_EXP 134
62851: PUSH
62852: LD_EXP 134
62856: PPUSH
62857: LD_VAR 0 3
62861: PPUSH
62862: LD_VAR 0 7
62866: PPUSH
62867: CALL_OW 1
62871: ST_TO_ADDR
// end else
62872: GO 62891
// MC_InsertProduceList ( i , [ components ] ) ;
62874: LD_VAR 0 3
62878: PPUSH
62879: LD_VAR 0 9
62883: PUSH
62884: EMPTY
62885: LIST
62886: PPUSH
62887: CALL 58841 0 2
// break ;
62891: GO 62895
// end ; end ;
62893: GO 62680
62895: POP
62896: POP
// end ; end ; if GetType ( un ) = unit_building then
62897: LD_VAR 0 1
62901: PPUSH
62902: CALL_OW 247
62906: PUSH
62907: LD_INT 3
62909: EQUAL
62910: IFFALSE 63313
// begin btype := GetBType ( un ) ;
62912: LD_ADDR_VAR 0 5
62916: PUSH
62917: LD_VAR 0 1
62921: PPUSH
62922: CALL_OW 266
62926: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62927: LD_VAR 0 5
62931: PUSH
62932: LD_INT 29
62934: PUSH
62935: LD_INT 30
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: IN
62942: IFFALSE 63015
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62944: LD_VAR 0 1
62948: PPUSH
62949: CALL_OW 250
62953: PPUSH
62954: LD_VAR 0 1
62958: PPUSH
62959: CALL_OW 251
62963: PPUSH
62964: LD_VAR 0 1
62968: PPUSH
62969: CALL_OW 255
62973: PPUSH
62974: CALL_OW 440
62978: NOT
62979: IFFALSE 63015
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62981: LD_VAR 0 1
62985: PPUSH
62986: CALL_OW 250
62990: PPUSH
62991: LD_VAR 0 1
62995: PPUSH
62996: CALL_OW 251
63000: PPUSH
63001: LD_VAR 0 1
63005: PPUSH
63006: CALL_OW 255
63010: PPUSH
63011: CALL_OW 441
// end ; if btype = b_warehouse then
63015: LD_VAR 0 5
63019: PUSH
63020: LD_INT 1
63022: EQUAL
63023: IFFALSE 63041
// begin btype := b_depot ;
63025: LD_ADDR_VAR 0 5
63029: PUSH
63030: LD_INT 0
63032: ST_TO_ADDR
// pos := 1 ;
63033: LD_ADDR_VAR 0 6
63037: PUSH
63038: LD_INT 1
63040: ST_TO_ADDR
// end ; if btype = b_factory then
63041: LD_VAR 0 5
63045: PUSH
63046: LD_INT 3
63048: EQUAL
63049: IFFALSE 63067
// begin btype := b_workshop ;
63051: LD_ADDR_VAR 0 5
63055: PUSH
63056: LD_INT 2
63058: ST_TO_ADDR
// pos := 1 ;
63059: LD_ADDR_VAR 0 6
63063: PUSH
63064: LD_INT 1
63066: ST_TO_ADDR
// end ; if btype = b_barracks then
63067: LD_VAR 0 5
63071: PUSH
63072: LD_INT 5
63074: EQUAL
63075: IFFALSE 63085
// btype := b_armoury ;
63077: LD_ADDR_VAR 0 5
63081: PUSH
63082: LD_INT 4
63084: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63085: LD_VAR 0 5
63089: PUSH
63090: LD_INT 7
63092: PUSH
63093: LD_INT 8
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: IN
63100: IFFALSE 63110
// btype := b_lab ;
63102: LD_ADDR_VAR 0 5
63106: PUSH
63107: LD_INT 6
63109: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63110: LD_ADDR_EXP 118
63114: PUSH
63115: LD_EXP 118
63119: PPUSH
63120: LD_VAR 0 3
63124: PUSH
63125: LD_EXP 118
63129: PUSH
63130: LD_VAR 0 3
63134: ARRAY
63135: PUSH
63136: LD_INT 1
63138: PLUS
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PPUSH
63144: LD_VAR 0 5
63148: PUSH
63149: LD_VAR 0 1
63153: PPUSH
63154: CALL_OW 250
63158: PUSH
63159: LD_VAR 0 1
63163: PPUSH
63164: CALL_OW 251
63168: PUSH
63169: LD_VAR 0 1
63173: PPUSH
63174: CALL_OW 254
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: LIST
63183: LIST
63184: PPUSH
63185: CALL 70150 0 3
63189: ST_TO_ADDR
// if pos = 1 then
63190: LD_VAR 0 6
63194: PUSH
63195: LD_INT 1
63197: EQUAL
63198: IFFALSE 63313
// begin tmp := mc_build_list [ i ] ;
63200: LD_ADDR_VAR 0 7
63204: PUSH
63205: LD_EXP 118
63209: PUSH
63210: LD_VAR 0 3
63214: ARRAY
63215: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63216: LD_VAR 0 7
63220: PPUSH
63221: LD_INT 2
63223: PUSH
63224: LD_INT 30
63226: PUSH
63227: LD_INT 0
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_INT 30
63236: PUSH
63237: LD_INT 1
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: LIST
63248: PPUSH
63249: CALL_OW 72
63253: IFFALSE 63263
// pos := 2 ;
63255: LD_ADDR_VAR 0 6
63259: PUSH
63260: LD_INT 2
63262: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63263: LD_ADDR_VAR 0 7
63267: PUSH
63268: LD_VAR 0 7
63272: PPUSH
63273: LD_VAR 0 6
63277: PPUSH
63278: LD_VAR 0 7
63282: PPUSH
63283: CALL 70476 0 3
63287: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63288: LD_ADDR_EXP 118
63292: PUSH
63293: LD_EXP 118
63297: PPUSH
63298: LD_VAR 0 3
63302: PPUSH
63303: LD_VAR 0 7
63307: PPUSH
63308: CALL_OW 1
63312: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63313: LD_VAR 0 1
63317: PUSH
63318: LD_EXP 113
63322: PUSH
63323: LD_VAR 0 3
63327: ARRAY
63328: IN
63329: IFFALSE 63368
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63331: LD_ADDR_EXP 113
63335: PUSH
63336: LD_EXP 113
63340: PPUSH
63341: LD_VAR 0 3
63345: PPUSH
63346: LD_EXP 113
63350: PUSH
63351: LD_VAR 0 3
63355: ARRAY
63356: PUSH
63357: LD_VAR 0 1
63361: DIFF
63362: PPUSH
63363: CALL_OW 1
63367: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63368: LD_VAR 0 1
63372: PUSH
63373: LD_EXP 120
63377: PUSH
63378: LD_VAR 0 3
63382: ARRAY
63383: IN
63384: IFFALSE 63423
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63386: LD_ADDR_EXP 120
63390: PUSH
63391: LD_EXP 120
63395: PPUSH
63396: LD_VAR 0 3
63400: PPUSH
63401: LD_EXP 120
63405: PUSH
63406: LD_VAR 0 3
63410: ARRAY
63411: PUSH
63412: LD_VAR 0 1
63416: DIFF
63417: PPUSH
63418: CALL_OW 1
63422: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63423: LD_VAR 0 1
63427: PUSH
63428: LD_EXP 132
63432: PUSH
63433: LD_VAR 0 3
63437: ARRAY
63438: IN
63439: IFFALSE 63478
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63441: LD_ADDR_EXP 132
63445: PUSH
63446: LD_EXP 132
63450: PPUSH
63451: LD_VAR 0 3
63455: PPUSH
63456: LD_EXP 132
63460: PUSH
63461: LD_VAR 0 3
63465: ARRAY
63466: PUSH
63467: LD_VAR 0 1
63471: DIFF
63472: PPUSH
63473: CALL_OW 1
63477: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63478: LD_VAR 0 1
63482: PUSH
63483: LD_EXP 135
63487: PUSH
63488: LD_VAR 0 3
63492: ARRAY
63493: IN
63494: IFFALSE 63533
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63496: LD_ADDR_EXP 135
63500: PUSH
63501: LD_EXP 135
63505: PPUSH
63506: LD_VAR 0 3
63510: PPUSH
63511: LD_EXP 135
63515: PUSH
63516: LD_VAR 0 3
63520: ARRAY
63521: PUSH
63522: LD_VAR 0 1
63526: DIFF
63527: PPUSH
63528: CALL_OW 1
63532: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63533: LD_VAR 0 1
63537: PUSH
63538: LD_EXP 122
63542: PUSH
63543: LD_VAR 0 3
63547: ARRAY
63548: IN
63549: IFFALSE 63588
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63551: LD_ADDR_EXP 122
63555: PUSH
63556: LD_EXP 122
63560: PPUSH
63561: LD_VAR 0 3
63565: PPUSH
63566: LD_EXP 122
63570: PUSH
63571: LD_VAR 0 3
63575: ARRAY
63576: PUSH
63577: LD_VAR 0 1
63581: DIFF
63582: PPUSH
63583: CALL_OW 1
63587: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63588: LD_VAR 0 1
63592: PUSH
63593: LD_EXP 121
63597: PUSH
63598: LD_VAR 0 3
63602: ARRAY
63603: IN
63604: IFFALSE 63643
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63606: LD_ADDR_EXP 121
63610: PUSH
63611: LD_EXP 121
63615: PPUSH
63616: LD_VAR 0 3
63620: PPUSH
63621: LD_EXP 121
63625: PUSH
63626: LD_VAR 0 3
63630: ARRAY
63631: PUSH
63632: LD_VAR 0 1
63636: DIFF
63637: PPUSH
63638: CALL_OW 1
63642: ST_TO_ADDR
// end ; break ;
63643: GO 63647
// end ;
63645: GO 62293
63647: POP
63648: POP
// end ;
63649: LD_VAR 0 2
63653: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63654: LD_INT 0
63656: PPUSH
63657: PPUSH
63658: PPUSH
// if not mc_bases or not skirmish then
63659: LD_EXP 113
63663: NOT
63664: PUSH
63665: LD_EXP 111
63669: NOT
63670: OR
63671: IFFALSE 63675
// exit ;
63673: GO 63890
// for i = 1 to mc_bases do
63675: LD_ADDR_VAR 0 3
63679: PUSH
63680: DOUBLE
63681: LD_INT 1
63683: DEC
63684: ST_TO_ADDR
63685: LD_EXP 113
63689: PUSH
63690: FOR_TO
63691: IFFALSE 63888
// begin if building in mc_construct_list [ i ] then
63693: LD_VAR 0 1
63697: PUSH
63698: LD_EXP 120
63702: PUSH
63703: LD_VAR 0 3
63707: ARRAY
63708: IN
63709: IFFALSE 63886
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63711: LD_ADDR_EXP 120
63715: PUSH
63716: LD_EXP 120
63720: PPUSH
63721: LD_VAR 0 3
63725: PPUSH
63726: LD_EXP 120
63730: PUSH
63731: LD_VAR 0 3
63735: ARRAY
63736: PUSH
63737: LD_VAR 0 1
63741: DIFF
63742: PPUSH
63743: CALL_OW 1
63747: ST_TO_ADDR
// if building in mc_lab [ i ] then
63748: LD_VAR 0 1
63752: PUSH
63753: LD_EXP 146
63757: PUSH
63758: LD_VAR 0 3
63762: ARRAY
63763: IN
63764: IFFALSE 63819
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63766: LD_ADDR_EXP 147
63770: PUSH
63771: LD_EXP 147
63775: PPUSH
63776: LD_VAR 0 3
63780: PPUSH
63781: LD_EXP 147
63785: PUSH
63786: LD_VAR 0 3
63790: ARRAY
63791: PPUSH
63792: LD_INT 1
63794: PPUSH
63795: LD_EXP 147
63799: PUSH
63800: LD_VAR 0 3
63804: ARRAY
63805: PPUSH
63806: LD_INT 0
63808: PPUSH
63809: CALL 69568 0 4
63813: PPUSH
63814: CALL_OW 1
63818: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63819: LD_VAR 0 1
63823: PUSH
63824: LD_EXP 113
63828: PUSH
63829: LD_VAR 0 3
63833: ARRAY
63834: IN
63835: NOT
63836: IFFALSE 63882
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63838: LD_ADDR_EXP 113
63842: PUSH
63843: LD_EXP 113
63847: PPUSH
63848: LD_VAR 0 3
63852: PUSH
63853: LD_EXP 113
63857: PUSH
63858: LD_VAR 0 3
63862: ARRAY
63863: PUSH
63864: LD_INT 1
63866: PLUS
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PPUSH
63872: LD_VAR 0 1
63876: PPUSH
63877: CALL 70150 0 3
63881: ST_TO_ADDR
// exit ;
63882: POP
63883: POP
63884: GO 63890
// end ; end ;
63886: GO 63690
63888: POP
63889: POP
// end ;
63890: LD_VAR 0 2
63894: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63895: LD_INT 0
63897: PPUSH
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
// if not mc_bases or not skirmish then
63904: LD_EXP 113
63908: NOT
63909: PUSH
63910: LD_EXP 111
63914: NOT
63915: OR
63916: IFFALSE 63920
// exit ;
63918: GO 64581
// for i = 1 to mc_bases do
63920: LD_ADDR_VAR 0 3
63924: PUSH
63925: DOUBLE
63926: LD_INT 1
63928: DEC
63929: ST_TO_ADDR
63930: LD_EXP 113
63934: PUSH
63935: FOR_TO
63936: IFFALSE 64579
// begin if building in mc_construct_list [ i ] then
63938: LD_VAR 0 1
63942: PUSH
63943: LD_EXP 120
63947: PUSH
63948: LD_VAR 0 3
63952: ARRAY
63953: IN
63954: IFFALSE 64577
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63956: LD_ADDR_EXP 120
63960: PUSH
63961: LD_EXP 120
63965: PPUSH
63966: LD_VAR 0 3
63970: PPUSH
63971: LD_EXP 120
63975: PUSH
63976: LD_VAR 0 3
63980: ARRAY
63981: PUSH
63982: LD_VAR 0 1
63986: DIFF
63987: PPUSH
63988: CALL_OW 1
63992: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63993: LD_ADDR_EXP 113
63997: PUSH
63998: LD_EXP 113
64002: PPUSH
64003: LD_VAR 0 3
64007: PUSH
64008: LD_EXP 113
64012: PUSH
64013: LD_VAR 0 3
64017: ARRAY
64018: PUSH
64019: LD_INT 1
64021: PLUS
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PPUSH
64027: LD_VAR 0 1
64031: PPUSH
64032: CALL 70150 0 3
64036: ST_TO_ADDR
// btype := GetBType ( building ) ;
64037: LD_ADDR_VAR 0 5
64041: PUSH
64042: LD_VAR 0 1
64046: PPUSH
64047: CALL_OW 266
64051: ST_TO_ADDR
// side := GetSide ( building ) ;
64052: LD_ADDR_VAR 0 8
64056: PUSH
64057: LD_VAR 0 1
64061: PPUSH
64062: CALL_OW 255
64066: ST_TO_ADDR
// if btype = b_lab then
64067: LD_VAR 0 5
64071: PUSH
64072: LD_INT 6
64074: EQUAL
64075: IFFALSE 64125
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64077: LD_ADDR_EXP 146
64081: PUSH
64082: LD_EXP 146
64086: PPUSH
64087: LD_VAR 0 3
64091: PUSH
64092: LD_EXP 146
64096: PUSH
64097: LD_VAR 0 3
64101: ARRAY
64102: PUSH
64103: LD_INT 1
64105: PLUS
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PPUSH
64111: LD_VAR 0 1
64115: PPUSH
64116: CALL 70150 0 3
64120: ST_TO_ADDR
// exit ;
64121: POP
64122: POP
64123: GO 64581
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64125: LD_VAR 0 5
64129: PUSH
64130: LD_INT 0
64132: PUSH
64133: LD_INT 2
64135: PUSH
64136: LD_INT 4
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: LIST
64143: IN
64144: IFFALSE 64268
// begin if btype = b_armoury then
64146: LD_VAR 0 5
64150: PUSH
64151: LD_INT 4
64153: EQUAL
64154: IFFALSE 64164
// btype := b_barracks ;
64156: LD_ADDR_VAR 0 5
64160: PUSH
64161: LD_INT 5
64163: ST_TO_ADDR
// if btype = b_depot then
64164: LD_VAR 0 5
64168: PUSH
64169: LD_INT 0
64171: EQUAL
64172: IFFALSE 64182
// btype := b_warehouse ;
64174: LD_ADDR_VAR 0 5
64178: PUSH
64179: LD_INT 1
64181: ST_TO_ADDR
// if btype = b_workshop then
64182: LD_VAR 0 5
64186: PUSH
64187: LD_INT 2
64189: EQUAL
64190: IFFALSE 64200
// btype := b_factory ;
64192: LD_ADDR_VAR 0 5
64196: PUSH
64197: LD_INT 3
64199: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64200: LD_VAR 0 5
64204: PPUSH
64205: LD_VAR 0 8
64209: PPUSH
64210: CALL_OW 323
64214: PUSH
64215: LD_INT 1
64217: EQUAL
64218: IFFALSE 64264
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64220: LD_ADDR_EXP 145
64224: PUSH
64225: LD_EXP 145
64229: PPUSH
64230: LD_VAR 0 3
64234: PUSH
64235: LD_EXP 145
64239: PUSH
64240: LD_VAR 0 3
64244: ARRAY
64245: PUSH
64246: LD_INT 1
64248: PLUS
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PPUSH
64254: LD_VAR 0 1
64258: PPUSH
64259: CALL 70150 0 3
64263: ST_TO_ADDR
// exit ;
64264: POP
64265: POP
64266: GO 64581
// end ; if btype in [ b_bunker , b_turret ] then
64268: LD_VAR 0 5
64272: PUSH
64273: LD_INT 32
64275: PUSH
64276: LD_INT 33
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: IN
64283: IFFALSE 64573
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64285: LD_ADDR_EXP 121
64289: PUSH
64290: LD_EXP 121
64294: PPUSH
64295: LD_VAR 0 3
64299: PUSH
64300: LD_EXP 121
64304: PUSH
64305: LD_VAR 0 3
64309: ARRAY
64310: PUSH
64311: LD_INT 1
64313: PLUS
64314: PUSH
64315: EMPTY
64316: LIST
64317: LIST
64318: PPUSH
64319: LD_VAR 0 1
64323: PPUSH
64324: CALL 70150 0 3
64328: ST_TO_ADDR
// if btype = b_bunker then
64329: LD_VAR 0 5
64333: PUSH
64334: LD_INT 32
64336: EQUAL
64337: IFFALSE 64573
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64339: LD_ADDR_EXP 122
64343: PUSH
64344: LD_EXP 122
64348: PPUSH
64349: LD_VAR 0 3
64353: PUSH
64354: LD_EXP 122
64358: PUSH
64359: LD_VAR 0 3
64363: ARRAY
64364: PUSH
64365: LD_INT 1
64367: PLUS
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PPUSH
64373: LD_VAR 0 1
64377: PPUSH
64378: CALL 70150 0 3
64382: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64383: LD_ADDR_VAR 0 6
64387: PUSH
64388: LD_EXP 113
64392: PUSH
64393: LD_VAR 0 3
64397: ARRAY
64398: PPUSH
64399: LD_INT 25
64401: PUSH
64402: LD_INT 1
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 3
64411: PUSH
64412: LD_INT 54
64414: PUSH
64415: EMPTY
64416: LIST
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: PPUSH
64426: CALL_OW 72
64430: ST_TO_ADDR
// if tmp then
64431: LD_VAR 0 6
64435: IFFALSE 64441
// exit ;
64437: POP
64438: POP
64439: GO 64581
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64441: LD_ADDR_VAR 0 6
64445: PUSH
64446: LD_EXP 113
64450: PUSH
64451: LD_VAR 0 3
64455: ARRAY
64456: PPUSH
64457: LD_INT 2
64459: PUSH
64460: LD_INT 30
64462: PUSH
64463: LD_INT 4
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: LD_INT 30
64472: PUSH
64473: LD_INT 5
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: LIST
64484: PPUSH
64485: CALL_OW 72
64489: ST_TO_ADDR
// if not tmp then
64490: LD_VAR 0 6
64494: NOT
64495: IFFALSE 64501
// exit ;
64497: POP
64498: POP
64499: GO 64581
// for j in tmp do
64501: LD_ADDR_VAR 0 4
64505: PUSH
64506: LD_VAR 0 6
64510: PUSH
64511: FOR_IN
64512: IFFALSE 64571
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64514: LD_ADDR_VAR 0 7
64518: PUSH
64519: LD_VAR 0 4
64523: PPUSH
64524: CALL_OW 313
64528: PPUSH
64529: LD_INT 25
64531: PUSH
64532: LD_INT 1
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PPUSH
64539: CALL_OW 72
64543: ST_TO_ADDR
// if units then
64544: LD_VAR 0 7
64548: IFFALSE 64569
// begin ComExitBuilding ( units [ 1 ] ) ;
64550: LD_VAR 0 7
64554: PUSH
64555: LD_INT 1
64557: ARRAY
64558: PPUSH
64559: CALL_OW 122
// exit ;
64563: POP
64564: POP
64565: POP
64566: POP
64567: GO 64581
// end ; end ;
64569: GO 64511
64571: POP
64572: POP
// end ; end ; exit ;
64573: POP
64574: POP
64575: GO 64581
// end ; end ;
64577: GO 63935
64579: POP
64580: POP
// end ;
64581: LD_VAR 0 2
64585: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64586: LD_INT 0
64588: PPUSH
64589: PPUSH
64590: PPUSH
64591: PPUSH
64592: PPUSH
64593: PPUSH
64594: PPUSH
// if not mc_bases or not skirmish then
64595: LD_EXP 113
64599: NOT
64600: PUSH
64601: LD_EXP 111
64605: NOT
64606: OR
64607: IFFALSE 64611
// exit ;
64609: GO 64842
// btype := GetBType ( building ) ;
64611: LD_ADDR_VAR 0 6
64615: PUSH
64616: LD_VAR 0 1
64620: PPUSH
64621: CALL_OW 266
64625: ST_TO_ADDR
// x := GetX ( building ) ;
64626: LD_ADDR_VAR 0 7
64630: PUSH
64631: LD_VAR 0 1
64635: PPUSH
64636: CALL_OW 250
64640: ST_TO_ADDR
// y := GetY ( building ) ;
64641: LD_ADDR_VAR 0 8
64645: PUSH
64646: LD_VAR 0 1
64650: PPUSH
64651: CALL_OW 251
64655: ST_TO_ADDR
// d := GetDir ( building ) ;
64656: LD_ADDR_VAR 0 9
64660: PUSH
64661: LD_VAR 0 1
64665: PPUSH
64666: CALL_OW 254
64670: ST_TO_ADDR
// for i = 1 to mc_bases do
64671: LD_ADDR_VAR 0 4
64675: PUSH
64676: DOUBLE
64677: LD_INT 1
64679: DEC
64680: ST_TO_ADDR
64681: LD_EXP 113
64685: PUSH
64686: FOR_TO
64687: IFFALSE 64840
// begin if not mc_build_list [ i ] then
64689: LD_EXP 118
64693: PUSH
64694: LD_VAR 0 4
64698: ARRAY
64699: NOT
64700: IFFALSE 64704
// continue ;
64702: GO 64686
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64704: LD_VAR 0 6
64708: PUSH
64709: LD_VAR 0 7
64713: PUSH
64714: LD_VAR 0 8
64718: PUSH
64719: LD_VAR 0 9
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: PPUSH
64730: LD_EXP 118
64734: PUSH
64735: LD_VAR 0 4
64739: ARRAY
64740: PUSH
64741: LD_INT 1
64743: ARRAY
64744: PPUSH
64745: CALL 76319 0 2
64749: IFFALSE 64838
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64751: LD_ADDR_EXP 118
64755: PUSH
64756: LD_EXP 118
64760: PPUSH
64761: LD_VAR 0 4
64765: PPUSH
64766: LD_EXP 118
64770: PUSH
64771: LD_VAR 0 4
64775: ARRAY
64776: PPUSH
64777: LD_INT 1
64779: PPUSH
64780: CALL_OW 3
64784: PPUSH
64785: CALL_OW 1
64789: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64790: LD_ADDR_EXP 120
64794: PUSH
64795: LD_EXP 120
64799: PPUSH
64800: LD_VAR 0 4
64804: PUSH
64805: LD_EXP 120
64809: PUSH
64810: LD_VAR 0 4
64814: ARRAY
64815: PUSH
64816: LD_INT 1
64818: PLUS
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PPUSH
64824: LD_VAR 0 1
64828: PPUSH
64829: CALL 70150 0 3
64833: ST_TO_ADDR
// exit ;
64834: POP
64835: POP
64836: GO 64842
// end ; end ;
64838: GO 64686
64840: POP
64841: POP
// end ;
64842: LD_VAR 0 3
64846: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64847: LD_INT 0
64849: PPUSH
64850: PPUSH
64851: PPUSH
// if not mc_bases or not skirmish then
64852: LD_EXP 113
64856: NOT
64857: PUSH
64858: LD_EXP 111
64862: NOT
64863: OR
64864: IFFALSE 64868
// exit ;
64866: GO 65058
// for i = 1 to mc_bases do
64868: LD_ADDR_VAR 0 4
64872: PUSH
64873: DOUBLE
64874: LD_INT 1
64876: DEC
64877: ST_TO_ADDR
64878: LD_EXP 113
64882: PUSH
64883: FOR_TO
64884: IFFALSE 64971
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64886: LD_VAR 0 1
64890: PUSH
64891: LD_EXP 121
64895: PUSH
64896: LD_VAR 0 4
64900: ARRAY
64901: IN
64902: PUSH
64903: LD_VAR 0 1
64907: PUSH
64908: LD_EXP 122
64912: PUSH
64913: LD_VAR 0 4
64917: ARRAY
64918: IN
64919: NOT
64920: AND
64921: IFFALSE 64969
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64923: LD_ADDR_EXP 122
64927: PUSH
64928: LD_EXP 122
64932: PPUSH
64933: LD_VAR 0 4
64937: PUSH
64938: LD_EXP 122
64942: PUSH
64943: LD_VAR 0 4
64947: ARRAY
64948: PUSH
64949: LD_INT 1
64951: PLUS
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PPUSH
64957: LD_VAR 0 1
64961: PPUSH
64962: CALL 70150 0 3
64966: ST_TO_ADDR
// break ;
64967: GO 64971
// end ; end ;
64969: GO 64883
64971: POP
64972: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64973: LD_VAR 0 1
64977: PPUSH
64978: CALL_OW 257
64982: PUSH
64983: LD_EXP 139
64987: IN
64988: PUSH
64989: LD_VAR 0 1
64993: PPUSH
64994: CALL_OW 266
64998: PUSH
64999: LD_INT 5
65001: EQUAL
65002: AND
65003: PUSH
65004: LD_VAR 0 2
65008: PPUSH
65009: CALL_OW 110
65013: PUSH
65014: LD_INT 18
65016: NONEQUAL
65017: AND
65018: IFFALSE 65058
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65020: LD_VAR 0 2
65024: PPUSH
65025: CALL_OW 257
65029: PUSH
65030: LD_INT 5
65032: PUSH
65033: LD_INT 8
65035: PUSH
65036: LD_INT 9
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: LIST
65043: IN
65044: IFFALSE 65058
// SetClass ( unit , 1 ) ;
65046: LD_VAR 0 2
65050: PPUSH
65051: LD_INT 1
65053: PPUSH
65054: CALL_OW 336
// end ;
65058: LD_VAR 0 3
65062: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65063: LD_INT 0
65065: PPUSH
65066: PPUSH
// if not mc_bases or not skirmish then
65067: LD_EXP 113
65071: NOT
65072: PUSH
65073: LD_EXP 111
65077: NOT
65078: OR
65079: IFFALSE 65083
// exit ;
65081: GO 65199
// if GetLives ( abandoned_vehicle ) > 250 then
65083: LD_VAR 0 2
65087: PPUSH
65088: CALL_OW 256
65092: PUSH
65093: LD_INT 250
65095: GREATER
65096: IFFALSE 65100
// exit ;
65098: GO 65199
// for i = 1 to mc_bases do
65100: LD_ADDR_VAR 0 6
65104: PUSH
65105: DOUBLE
65106: LD_INT 1
65108: DEC
65109: ST_TO_ADDR
65110: LD_EXP 113
65114: PUSH
65115: FOR_TO
65116: IFFALSE 65197
// begin if driver in mc_bases [ i ] then
65118: LD_VAR 0 1
65122: PUSH
65123: LD_EXP 113
65127: PUSH
65128: LD_VAR 0 6
65132: ARRAY
65133: IN
65134: IFFALSE 65195
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65136: LD_VAR 0 1
65140: PPUSH
65141: LD_EXP 113
65145: PUSH
65146: LD_VAR 0 6
65150: ARRAY
65151: PPUSH
65152: LD_INT 2
65154: PUSH
65155: LD_INT 30
65157: PUSH
65158: LD_INT 0
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PUSH
65165: LD_INT 30
65167: PUSH
65168: LD_INT 1
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: LIST
65179: PPUSH
65180: CALL_OW 72
65184: PUSH
65185: LD_INT 1
65187: ARRAY
65188: PPUSH
65189: CALL 102016 0 2
// break ;
65193: GO 65197
// end ; end ;
65195: GO 65115
65197: POP
65198: POP
// end ; end_of_file
65199: LD_VAR 0 5
65203: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65204: LD_INT 0
65206: PPUSH
65207: PPUSH
// if exist_mode then
65208: LD_VAR 0 2
65212: IFFALSE 65237
// unit := CreateCharacter ( prefix & ident ) else
65214: LD_ADDR_VAR 0 5
65218: PUSH
65219: LD_VAR 0 3
65223: PUSH
65224: LD_VAR 0 1
65228: STR
65229: PPUSH
65230: CALL_OW 34
65234: ST_TO_ADDR
65235: GO 65252
// unit := NewCharacter ( ident ) ;
65237: LD_ADDR_VAR 0 5
65241: PUSH
65242: LD_VAR 0 1
65246: PPUSH
65247: CALL_OW 25
65251: ST_TO_ADDR
// result := unit ;
65252: LD_ADDR_VAR 0 4
65256: PUSH
65257: LD_VAR 0 5
65261: ST_TO_ADDR
// end ;
65262: LD_VAR 0 4
65266: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65267: LD_INT 0
65269: PPUSH
65270: PPUSH
// if not side or not nation then
65271: LD_VAR 0 1
65275: NOT
65276: PUSH
65277: LD_VAR 0 2
65281: NOT
65282: OR
65283: IFFALSE 65287
// exit ;
65285: GO 66051
// case nation of nation_american :
65287: LD_VAR 0 2
65291: PUSH
65292: LD_INT 1
65294: DOUBLE
65295: EQUAL
65296: IFTRUE 65300
65298: GO 65514
65300: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65301: LD_ADDR_VAR 0 4
65305: PUSH
65306: LD_INT 35
65308: PUSH
65309: LD_INT 45
65311: PUSH
65312: LD_INT 46
65314: PUSH
65315: LD_INT 47
65317: PUSH
65318: LD_INT 82
65320: PUSH
65321: LD_INT 83
65323: PUSH
65324: LD_INT 84
65326: PUSH
65327: LD_INT 85
65329: PUSH
65330: LD_INT 86
65332: PUSH
65333: LD_INT 1
65335: PUSH
65336: LD_INT 2
65338: PUSH
65339: LD_INT 6
65341: PUSH
65342: LD_INT 15
65344: PUSH
65345: LD_INT 16
65347: PUSH
65348: LD_INT 7
65350: PUSH
65351: LD_INT 12
65353: PUSH
65354: LD_INT 13
65356: PUSH
65357: LD_INT 10
65359: PUSH
65360: LD_INT 14
65362: PUSH
65363: LD_INT 20
65365: PUSH
65366: LD_INT 21
65368: PUSH
65369: LD_INT 22
65371: PUSH
65372: LD_INT 25
65374: PUSH
65375: LD_INT 32
65377: PUSH
65378: LD_INT 27
65380: PUSH
65381: LD_INT 36
65383: PUSH
65384: LD_INT 69
65386: PUSH
65387: LD_INT 39
65389: PUSH
65390: LD_INT 34
65392: PUSH
65393: LD_INT 40
65395: PUSH
65396: LD_INT 48
65398: PUSH
65399: LD_INT 49
65401: PUSH
65402: LD_INT 50
65404: PUSH
65405: LD_INT 51
65407: PUSH
65408: LD_INT 52
65410: PUSH
65411: LD_INT 53
65413: PUSH
65414: LD_INT 54
65416: PUSH
65417: LD_INT 55
65419: PUSH
65420: LD_INT 56
65422: PUSH
65423: LD_INT 57
65425: PUSH
65426: LD_INT 58
65428: PUSH
65429: LD_INT 59
65431: PUSH
65432: LD_INT 60
65434: PUSH
65435: LD_INT 61
65437: PUSH
65438: LD_INT 62
65440: PUSH
65441: LD_INT 80
65443: PUSH
65444: LD_INT 82
65446: PUSH
65447: LD_INT 83
65449: PUSH
65450: LD_INT 84
65452: PUSH
65453: LD_INT 85
65455: PUSH
65456: LD_INT 86
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: ST_TO_ADDR
65512: GO 65975
65514: LD_INT 2
65516: DOUBLE
65517: EQUAL
65518: IFTRUE 65522
65520: GO 65744
65522: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65523: LD_ADDR_VAR 0 4
65527: PUSH
65528: LD_INT 35
65530: PUSH
65531: LD_INT 45
65533: PUSH
65534: LD_INT 46
65536: PUSH
65537: LD_INT 47
65539: PUSH
65540: LD_INT 82
65542: PUSH
65543: LD_INT 83
65545: PUSH
65546: LD_INT 84
65548: PUSH
65549: LD_INT 85
65551: PUSH
65552: LD_INT 87
65554: PUSH
65555: LD_INT 70
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 11
65563: PUSH
65564: LD_INT 3
65566: PUSH
65567: LD_INT 4
65569: PUSH
65570: LD_INT 5
65572: PUSH
65573: LD_INT 6
65575: PUSH
65576: LD_INT 15
65578: PUSH
65579: LD_INT 18
65581: PUSH
65582: LD_INT 7
65584: PUSH
65585: LD_INT 17
65587: PUSH
65588: LD_INT 8
65590: PUSH
65591: LD_INT 20
65593: PUSH
65594: LD_INT 21
65596: PUSH
65597: LD_INT 22
65599: PUSH
65600: LD_INT 72
65602: PUSH
65603: LD_INT 26
65605: PUSH
65606: LD_INT 69
65608: PUSH
65609: LD_INT 39
65611: PUSH
65612: LD_INT 40
65614: PUSH
65615: LD_INT 41
65617: PUSH
65618: LD_INT 42
65620: PUSH
65621: LD_INT 43
65623: PUSH
65624: LD_INT 48
65626: PUSH
65627: LD_INT 49
65629: PUSH
65630: LD_INT 50
65632: PUSH
65633: LD_INT 51
65635: PUSH
65636: LD_INT 52
65638: PUSH
65639: LD_INT 53
65641: PUSH
65642: LD_INT 54
65644: PUSH
65645: LD_INT 55
65647: PUSH
65648: LD_INT 56
65650: PUSH
65651: LD_INT 60
65653: PUSH
65654: LD_INT 61
65656: PUSH
65657: LD_INT 62
65659: PUSH
65660: LD_INT 66
65662: PUSH
65663: LD_INT 67
65665: PUSH
65666: LD_INT 68
65668: PUSH
65669: LD_INT 81
65671: PUSH
65672: LD_INT 82
65674: PUSH
65675: LD_INT 83
65677: PUSH
65678: LD_INT 84
65680: PUSH
65681: LD_INT 85
65683: PUSH
65684: LD_INT 87
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: ST_TO_ADDR
65742: GO 65975
65744: LD_INT 3
65746: DOUBLE
65747: EQUAL
65748: IFTRUE 65752
65750: GO 65974
65752: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65753: LD_ADDR_VAR 0 4
65757: PUSH
65758: LD_INT 46
65760: PUSH
65761: LD_INT 47
65763: PUSH
65764: LD_INT 1
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: LD_INT 82
65772: PUSH
65773: LD_INT 83
65775: PUSH
65776: LD_INT 84
65778: PUSH
65779: LD_INT 85
65781: PUSH
65782: LD_INT 86
65784: PUSH
65785: LD_INT 11
65787: PUSH
65788: LD_INT 9
65790: PUSH
65791: LD_INT 20
65793: PUSH
65794: LD_INT 19
65796: PUSH
65797: LD_INT 21
65799: PUSH
65800: LD_INT 24
65802: PUSH
65803: LD_INT 22
65805: PUSH
65806: LD_INT 25
65808: PUSH
65809: LD_INT 28
65811: PUSH
65812: LD_INT 29
65814: PUSH
65815: LD_INT 30
65817: PUSH
65818: LD_INT 31
65820: PUSH
65821: LD_INT 37
65823: PUSH
65824: LD_INT 38
65826: PUSH
65827: LD_INT 32
65829: PUSH
65830: LD_INT 27
65832: PUSH
65833: LD_INT 33
65835: PUSH
65836: LD_INT 69
65838: PUSH
65839: LD_INT 39
65841: PUSH
65842: LD_INT 34
65844: PUSH
65845: LD_INT 40
65847: PUSH
65848: LD_INT 71
65850: PUSH
65851: LD_INT 23
65853: PUSH
65854: LD_INT 44
65856: PUSH
65857: LD_INT 48
65859: PUSH
65860: LD_INT 49
65862: PUSH
65863: LD_INT 50
65865: PUSH
65866: LD_INT 51
65868: PUSH
65869: LD_INT 52
65871: PUSH
65872: LD_INT 53
65874: PUSH
65875: LD_INT 54
65877: PUSH
65878: LD_INT 55
65880: PUSH
65881: LD_INT 56
65883: PUSH
65884: LD_INT 57
65886: PUSH
65887: LD_INT 58
65889: PUSH
65890: LD_INT 59
65892: PUSH
65893: LD_INT 63
65895: PUSH
65896: LD_INT 64
65898: PUSH
65899: LD_INT 65
65901: PUSH
65902: LD_INT 82
65904: PUSH
65905: LD_INT 83
65907: PUSH
65908: LD_INT 84
65910: PUSH
65911: LD_INT 85
65913: PUSH
65914: LD_INT 86
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: ST_TO_ADDR
65972: GO 65975
65974: POP
// if state > - 1 and state < 3 then
65975: LD_VAR 0 3
65979: PUSH
65980: LD_INT 1
65982: NEG
65983: GREATER
65984: PUSH
65985: LD_VAR 0 3
65989: PUSH
65990: LD_INT 3
65992: LESS
65993: AND
65994: IFFALSE 66051
// for i in result do
65996: LD_ADDR_VAR 0 5
66000: PUSH
66001: LD_VAR 0 4
66005: PUSH
66006: FOR_IN
66007: IFFALSE 66049
// if GetTech ( i , side ) <> state then
66009: LD_VAR 0 5
66013: PPUSH
66014: LD_VAR 0 1
66018: PPUSH
66019: CALL_OW 321
66023: PUSH
66024: LD_VAR 0 3
66028: NONEQUAL
66029: IFFALSE 66047
// result := result diff i ;
66031: LD_ADDR_VAR 0 4
66035: PUSH
66036: LD_VAR 0 4
66040: PUSH
66041: LD_VAR 0 5
66045: DIFF
66046: ST_TO_ADDR
66047: GO 66006
66049: POP
66050: POP
// end ;
66051: LD_VAR 0 4
66055: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66056: LD_INT 0
66058: PPUSH
66059: PPUSH
66060: PPUSH
// result := true ;
66061: LD_ADDR_VAR 0 3
66065: PUSH
66066: LD_INT 1
66068: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66069: LD_ADDR_VAR 0 5
66073: PUSH
66074: LD_VAR 0 2
66078: PPUSH
66079: CALL_OW 480
66083: ST_TO_ADDR
// if not tmp then
66084: LD_VAR 0 5
66088: NOT
66089: IFFALSE 66093
// exit ;
66091: GO 66142
// for i in tmp do
66093: LD_ADDR_VAR 0 4
66097: PUSH
66098: LD_VAR 0 5
66102: PUSH
66103: FOR_IN
66104: IFFALSE 66140
// if GetTech ( i , side ) <> state_researched then
66106: LD_VAR 0 4
66110: PPUSH
66111: LD_VAR 0 1
66115: PPUSH
66116: CALL_OW 321
66120: PUSH
66121: LD_INT 2
66123: NONEQUAL
66124: IFFALSE 66138
// begin result := false ;
66126: LD_ADDR_VAR 0 3
66130: PUSH
66131: LD_INT 0
66133: ST_TO_ADDR
// exit ;
66134: POP
66135: POP
66136: GO 66142
// end ;
66138: GO 66103
66140: POP
66141: POP
// end ;
66142: LD_VAR 0 3
66146: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66147: LD_INT 0
66149: PPUSH
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66162: LD_VAR 0 1
66166: NOT
66167: PUSH
66168: LD_VAR 0 1
66172: PPUSH
66173: CALL_OW 257
66177: PUSH
66178: LD_INT 9
66180: NONEQUAL
66181: OR
66182: IFFALSE 66186
// exit ;
66184: GO 66759
// side := GetSide ( unit ) ;
66186: LD_ADDR_VAR 0 9
66190: PUSH
66191: LD_VAR 0 1
66195: PPUSH
66196: CALL_OW 255
66200: ST_TO_ADDR
// tech_space := tech_spacanom ;
66201: LD_ADDR_VAR 0 12
66205: PUSH
66206: LD_INT 29
66208: ST_TO_ADDR
// tech_time := tech_taurad ;
66209: LD_ADDR_VAR 0 13
66213: PUSH
66214: LD_INT 28
66216: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66217: LD_ADDR_VAR 0 11
66221: PUSH
66222: LD_VAR 0 1
66226: PPUSH
66227: CALL_OW 310
66231: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66232: LD_VAR 0 11
66236: PPUSH
66237: CALL_OW 247
66241: PUSH
66242: LD_INT 2
66244: EQUAL
66245: IFFALSE 66249
// exit ;
66247: GO 66759
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66249: LD_ADDR_VAR 0 8
66253: PUSH
66254: LD_INT 81
66256: PUSH
66257: LD_VAR 0 9
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: LD_INT 21
66271: PUSH
66272: LD_INT 3
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PPUSH
66287: CALL_OW 69
66291: ST_TO_ADDR
// if not tmp then
66292: LD_VAR 0 8
66296: NOT
66297: IFFALSE 66301
// exit ;
66299: GO 66759
// if in_unit then
66301: LD_VAR 0 11
66305: IFFALSE 66329
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66307: LD_ADDR_VAR 0 10
66311: PUSH
66312: LD_VAR 0 8
66316: PPUSH
66317: LD_VAR 0 11
66321: PPUSH
66322: CALL_OW 74
66326: ST_TO_ADDR
66327: GO 66349
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66329: LD_ADDR_VAR 0 10
66333: PUSH
66334: LD_VAR 0 8
66338: PPUSH
66339: LD_VAR 0 1
66343: PPUSH
66344: CALL_OW 74
66348: ST_TO_ADDR
// if not enemy then
66349: LD_VAR 0 10
66353: NOT
66354: IFFALSE 66358
// exit ;
66356: GO 66759
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66358: LD_VAR 0 11
66362: PUSH
66363: LD_VAR 0 11
66367: PPUSH
66368: LD_VAR 0 10
66372: PPUSH
66373: CALL_OW 296
66377: PUSH
66378: LD_INT 13
66380: GREATER
66381: AND
66382: PUSH
66383: LD_VAR 0 1
66387: PPUSH
66388: LD_VAR 0 10
66392: PPUSH
66393: CALL_OW 296
66397: PUSH
66398: LD_INT 12
66400: GREATER
66401: OR
66402: IFFALSE 66406
// exit ;
66404: GO 66759
// missile := [ 1 ] ;
66406: LD_ADDR_VAR 0 14
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: EMPTY
66415: LIST
66416: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66417: LD_VAR 0 9
66421: PPUSH
66422: LD_VAR 0 12
66426: PPUSH
66427: CALL_OW 325
66431: IFFALSE 66460
// missile := Insert ( missile , missile + 1 , 2 ) ;
66433: LD_ADDR_VAR 0 14
66437: PUSH
66438: LD_VAR 0 14
66442: PPUSH
66443: LD_VAR 0 14
66447: PUSH
66448: LD_INT 1
66450: PLUS
66451: PPUSH
66452: LD_INT 2
66454: PPUSH
66455: CALL_OW 2
66459: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66460: LD_VAR 0 9
66464: PPUSH
66465: LD_VAR 0 13
66469: PPUSH
66470: CALL_OW 325
66474: PUSH
66475: LD_VAR 0 10
66479: PPUSH
66480: CALL_OW 255
66484: PPUSH
66485: LD_VAR 0 13
66489: PPUSH
66490: CALL_OW 325
66494: NOT
66495: AND
66496: IFFALSE 66525
// missile := Insert ( missile , missile + 1 , 3 ) ;
66498: LD_ADDR_VAR 0 14
66502: PUSH
66503: LD_VAR 0 14
66507: PPUSH
66508: LD_VAR 0 14
66512: PUSH
66513: LD_INT 1
66515: PLUS
66516: PPUSH
66517: LD_INT 3
66519: PPUSH
66520: CALL_OW 2
66524: ST_TO_ADDR
// if missile < 2 then
66525: LD_VAR 0 14
66529: PUSH
66530: LD_INT 2
66532: LESS
66533: IFFALSE 66537
// exit ;
66535: GO 66759
// x := GetX ( enemy ) ;
66537: LD_ADDR_VAR 0 4
66541: PUSH
66542: LD_VAR 0 10
66546: PPUSH
66547: CALL_OW 250
66551: ST_TO_ADDR
// y := GetY ( enemy ) ;
66552: LD_ADDR_VAR 0 5
66556: PUSH
66557: LD_VAR 0 10
66561: PPUSH
66562: CALL_OW 251
66566: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66567: LD_ADDR_VAR 0 6
66571: PUSH
66572: LD_VAR 0 4
66576: PUSH
66577: LD_INT 1
66579: NEG
66580: PPUSH
66581: LD_INT 1
66583: PPUSH
66584: CALL_OW 12
66588: PLUS
66589: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66590: LD_ADDR_VAR 0 7
66594: PUSH
66595: LD_VAR 0 5
66599: PUSH
66600: LD_INT 1
66602: NEG
66603: PPUSH
66604: LD_INT 1
66606: PPUSH
66607: CALL_OW 12
66611: PLUS
66612: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66613: LD_VAR 0 6
66617: PPUSH
66618: LD_VAR 0 7
66622: PPUSH
66623: CALL_OW 488
66627: NOT
66628: IFFALSE 66650
// begin _x := x ;
66630: LD_ADDR_VAR 0 6
66634: PUSH
66635: LD_VAR 0 4
66639: ST_TO_ADDR
// _y := y ;
66640: LD_ADDR_VAR 0 7
66644: PUSH
66645: LD_VAR 0 5
66649: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66650: LD_ADDR_VAR 0 3
66654: PUSH
66655: LD_INT 1
66657: PPUSH
66658: LD_VAR 0 14
66662: PPUSH
66663: CALL_OW 12
66667: ST_TO_ADDR
// case i of 1 :
66668: LD_VAR 0 3
66672: PUSH
66673: LD_INT 1
66675: DOUBLE
66676: EQUAL
66677: IFTRUE 66681
66679: GO 66698
66681: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66682: LD_VAR 0 1
66686: PPUSH
66687: LD_VAR 0 10
66691: PPUSH
66692: CALL_OW 115
66696: GO 66759
66698: LD_INT 2
66700: DOUBLE
66701: EQUAL
66702: IFTRUE 66706
66704: GO 66728
66706: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66707: LD_VAR 0 1
66711: PPUSH
66712: LD_VAR 0 6
66716: PPUSH
66717: LD_VAR 0 7
66721: PPUSH
66722: CALL_OW 153
66726: GO 66759
66728: LD_INT 3
66730: DOUBLE
66731: EQUAL
66732: IFTRUE 66736
66734: GO 66758
66736: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66737: LD_VAR 0 1
66741: PPUSH
66742: LD_VAR 0 6
66746: PPUSH
66747: LD_VAR 0 7
66751: PPUSH
66752: CALL_OW 154
66756: GO 66759
66758: POP
// end ;
66759: LD_VAR 0 2
66763: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66764: LD_INT 0
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
// if not unit or not building then
66772: LD_VAR 0 1
66776: NOT
66777: PUSH
66778: LD_VAR 0 2
66782: NOT
66783: OR
66784: IFFALSE 66788
// exit ;
66786: GO 66946
// x := GetX ( building ) ;
66788: LD_ADDR_VAR 0 5
66792: PUSH
66793: LD_VAR 0 2
66797: PPUSH
66798: CALL_OW 250
66802: ST_TO_ADDR
// y := GetY ( building ) ;
66803: LD_ADDR_VAR 0 6
66807: PUSH
66808: LD_VAR 0 2
66812: PPUSH
66813: CALL_OW 251
66817: ST_TO_ADDR
// for i = 0 to 5 do
66818: LD_ADDR_VAR 0 4
66822: PUSH
66823: DOUBLE
66824: LD_INT 0
66826: DEC
66827: ST_TO_ADDR
66828: LD_INT 5
66830: PUSH
66831: FOR_TO
66832: IFFALSE 66944
// begin _x := ShiftX ( x , i , 3 ) ;
66834: LD_ADDR_VAR 0 7
66838: PUSH
66839: LD_VAR 0 5
66843: PPUSH
66844: LD_VAR 0 4
66848: PPUSH
66849: LD_INT 3
66851: PPUSH
66852: CALL_OW 272
66856: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66857: LD_ADDR_VAR 0 8
66861: PUSH
66862: LD_VAR 0 6
66866: PPUSH
66867: LD_VAR 0 4
66871: PPUSH
66872: LD_INT 3
66874: PPUSH
66875: CALL_OW 273
66879: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66880: LD_VAR 0 7
66884: PPUSH
66885: LD_VAR 0 8
66889: PPUSH
66890: CALL_OW 488
66894: NOT
66895: IFFALSE 66899
// continue ;
66897: GO 66831
// if HexInfo ( _x , _y ) = 0 then
66899: LD_VAR 0 7
66903: PPUSH
66904: LD_VAR 0 8
66908: PPUSH
66909: CALL_OW 428
66913: PUSH
66914: LD_INT 0
66916: EQUAL
66917: IFFALSE 66942
// begin ComMoveXY ( unit , _x , _y ) ;
66919: LD_VAR 0 1
66923: PPUSH
66924: LD_VAR 0 7
66928: PPUSH
66929: LD_VAR 0 8
66933: PPUSH
66934: CALL_OW 111
// exit ;
66938: POP
66939: POP
66940: GO 66946
// end ; end ;
66942: GO 66831
66944: POP
66945: POP
// end ;
66946: LD_VAR 0 3
66950: RET
// export function ScanBase ( side , base_area ) ; begin
66951: LD_INT 0
66953: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66954: LD_ADDR_VAR 0 3
66958: PUSH
66959: LD_VAR 0 2
66963: PPUSH
66964: LD_INT 81
66966: PUSH
66967: LD_VAR 0 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PPUSH
66976: CALL_OW 70
66980: ST_TO_ADDR
// end ;
66981: LD_VAR 0 3
66985: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66986: LD_INT 0
66988: PPUSH
66989: PPUSH
66990: PPUSH
66991: PPUSH
// result := false ;
66992: LD_ADDR_VAR 0 2
66996: PUSH
66997: LD_INT 0
66999: ST_TO_ADDR
// side := GetSide ( unit ) ;
67000: LD_ADDR_VAR 0 3
67004: PUSH
67005: LD_VAR 0 1
67009: PPUSH
67010: CALL_OW 255
67014: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67015: LD_ADDR_VAR 0 4
67019: PUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL_OW 248
67029: ST_TO_ADDR
// case nat of 1 :
67030: LD_VAR 0 4
67034: PUSH
67035: LD_INT 1
67037: DOUBLE
67038: EQUAL
67039: IFTRUE 67043
67041: GO 67054
67043: POP
// tech := tech_lassight ; 2 :
67044: LD_ADDR_VAR 0 5
67048: PUSH
67049: LD_INT 12
67051: ST_TO_ADDR
67052: GO 67093
67054: LD_INT 2
67056: DOUBLE
67057: EQUAL
67058: IFTRUE 67062
67060: GO 67073
67062: POP
// tech := tech_mortar ; 3 :
67063: LD_ADDR_VAR 0 5
67067: PUSH
67068: LD_INT 41
67070: ST_TO_ADDR
67071: GO 67093
67073: LD_INT 3
67075: DOUBLE
67076: EQUAL
67077: IFTRUE 67081
67079: GO 67092
67081: POP
// tech := tech_bazooka ; end ;
67082: LD_ADDR_VAR 0 5
67086: PUSH
67087: LD_INT 44
67089: ST_TO_ADDR
67090: GO 67093
67092: POP
// if Researched ( side , tech ) then
67093: LD_VAR 0 3
67097: PPUSH
67098: LD_VAR 0 5
67102: PPUSH
67103: CALL_OW 325
67107: IFFALSE 67134
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67109: LD_ADDR_VAR 0 2
67113: PUSH
67114: LD_INT 5
67116: PUSH
67117: LD_INT 8
67119: PUSH
67120: LD_INT 9
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: LIST
67127: PUSH
67128: LD_VAR 0 4
67132: ARRAY
67133: ST_TO_ADDR
// end ;
67134: LD_VAR 0 2
67138: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67139: LD_INT 0
67141: PPUSH
67142: PPUSH
67143: PPUSH
// if not mines then
67144: LD_VAR 0 2
67148: NOT
67149: IFFALSE 67153
// exit ;
67151: GO 67297
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67153: LD_ADDR_VAR 0 5
67157: PUSH
67158: LD_INT 81
67160: PUSH
67161: LD_VAR 0 1
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 3
67172: PUSH
67173: LD_INT 21
67175: PUSH
67176: LD_INT 3
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PPUSH
67191: CALL_OW 69
67195: ST_TO_ADDR
// for i in mines do
67196: LD_ADDR_VAR 0 4
67200: PUSH
67201: LD_VAR 0 2
67205: PUSH
67206: FOR_IN
67207: IFFALSE 67295
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67209: LD_VAR 0 4
67213: PUSH
67214: LD_INT 1
67216: ARRAY
67217: PPUSH
67218: LD_VAR 0 4
67222: PUSH
67223: LD_INT 2
67225: ARRAY
67226: PPUSH
67227: CALL_OW 458
67231: NOT
67232: IFFALSE 67236
// continue ;
67234: GO 67206
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67236: LD_VAR 0 4
67240: PUSH
67241: LD_INT 1
67243: ARRAY
67244: PPUSH
67245: LD_VAR 0 4
67249: PUSH
67250: LD_INT 2
67252: ARRAY
67253: PPUSH
67254: CALL_OW 428
67258: PUSH
67259: LD_VAR 0 5
67263: IN
67264: IFFALSE 67293
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67266: LD_VAR 0 4
67270: PUSH
67271: LD_INT 1
67273: ARRAY
67274: PPUSH
67275: LD_VAR 0 4
67279: PUSH
67280: LD_INT 2
67282: ARRAY
67283: PPUSH
67284: LD_VAR 0 1
67288: PPUSH
67289: CALL_OW 456
// end ;
67293: GO 67206
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 3
67301: RET
// export function Count ( array ) ; var i ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
// result := 0 ;
67306: LD_ADDR_VAR 0 2
67310: PUSH
67311: LD_INT 0
67313: ST_TO_ADDR
// for i in array do
67314: LD_ADDR_VAR 0 3
67318: PUSH
67319: LD_VAR 0 1
67323: PUSH
67324: FOR_IN
67325: IFFALSE 67349
// if i then
67327: LD_VAR 0 3
67331: IFFALSE 67347
// result := result + 1 ;
67333: LD_ADDR_VAR 0 2
67337: PUSH
67338: LD_VAR 0 2
67342: PUSH
67343: LD_INT 1
67345: PLUS
67346: ST_TO_ADDR
67347: GO 67324
67349: POP
67350: POP
// end ;
67351: LD_VAR 0 2
67355: RET
// export function IsEmpty ( building ) ; begin
67356: LD_INT 0
67358: PPUSH
// if not building then
67359: LD_VAR 0 1
67363: NOT
67364: IFFALSE 67368
// exit ;
67366: GO 67411
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67368: LD_ADDR_VAR 0 2
67372: PUSH
67373: LD_VAR 0 1
67377: PUSH
67378: LD_INT 22
67380: PUSH
67381: LD_VAR 0 1
67385: PPUSH
67386: CALL_OW 255
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 58
67397: PUSH
67398: EMPTY
67399: LIST
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PPUSH
67405: CALL_OW 69
67409: IN
67410: ST_TO_ADDR
// end ;
67411: LD_VAR 0 2
67415: RET
// export function IsNotFull ( building ) ; begin
67416: LD_INT 0
67418: PPUSH
// if not building then
67419: LD_VAR 0 1
67423: NOT
67424: IFFALSE 67428
// exit ;
67426: GO 67447
// result := UnitsInside ( building ) < 6 ;
67428: LD_ADDR_VAR 0 2
67432: PUSH
67433: LD_VAR 0 1
67437: PPUSH
67438: CALL_OW 313
67442: PUSH
67443: LD_INT 6
67445: LESS
67446: ST_TO_ADDR
// end ;
67447: LD_VAR 0 2
67451: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67452: LD_INT 0
67454: PPUSH
67455: PPUSH
67456: PPUSH
67457: PPUSH
// tmp := [ ] ;
67458: LD_ADDR_VAR 0 3
67462: PUSH
67463: EMPTY
67464: ST_TO_ADDR
// list := [ ] ;
67465: LD_ADDR_VAR 0 5
67469: PUSH
67470: EMPTY
67471: ST_TO_ADDR
// for i = 16 to 25 do
67472: LD_ADDR_VAR 0 4
67476: PUSH
67477: DOUBLE
67478: LD_INT 16
67480: DEC
67481: ST_TO_ADDR
67482: LD_INT 25
67484: PUSH
67485: FOR_TO
67486: IFFALSE 67559
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67488: LD_ADDR_VAR 0 3
67492: PUSH
67493: LD_VAR 0 3
67497: PUSH
67498: LD_INT 22
67500: PUSH
67501: LD_VAR 0 1
67505: PPUSH
67506: CALL_OW 255
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 91
67517: PUSH
67518: LD_VAR 0 1
67522: PUSH
67523: LD_INT 6
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 30
67533: PUSH
67534: LD_VAR 0 4
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: LIST
67547: PUSH
67548: EMPTY
67549: LIST
67550: PPUSH
67551: CALL_OW 69
67555: ADD
67556: ST_TO_ADDR
67557: GO 67485
67559: POP
67560: POP
// for i = 1 to tmp do
67561: LD_ADDR_VAR 0 4
67565: PUSH
67566: DOUBLE
67567: LD_INT 1
67569: DEC
67570: ST_TO_ADDR
67571: LD_VAR 0 3
67575: PUSH
67576: FOR_TO
67577: IFFALSE 67665
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67579: LD_ADDR_VAR 0 5
67583: PUSH
67584: LD_VAR 0 5
67588: PUSH
67589: LD_VAR 0 3
67593: PUSH
67594: LD_VAR 0 4
67598: ARRAY
67599: PPUSH
67600: CALL_OW 266
67604: PUSH
67605: LD_VAR 0 3
67609: PUSH
67610: LD_VAR 0 4
67614: ARRAY
67615: PPUSH
67616: CALL_OW 250
67620: PUSH
67621: LD_VAR 0 3
67625: PUSH
67626: LD_VAR 0 4
67630: ARRAY
67631: PPUSH
67632: CALL_OW 251
67636: PUSH
67637: LD_VAR 0 3
67641: PUSH
67642: LD_VAR 0 4
67646: ARRAY
67647: PPUSH
67648: CALL_OW 254
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: PUSH
67659: EMPTY
67660: LIST
67661: ADD
67662: ST_TO_ADDR
67663: GO 67576
67665: POP
67666: POP
// result := list ;
67667: LD_ADDR_VAR 0 2
67671: PUSH
67672: LD_VAR 0 5
67676: ST_TO_ADDR
// end ;
67677: LD_VAR 0 2
67681: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67682: LD_INT 0
67684: PPUSH
67685: PPUSH
67686: PPUSH
67687: PPUSH
67688: PPUSH
67689: PPUSH
67690: PPUSH
// if not factory then
67691: LD_VAR 0 1
67695: NOT
67696: IFFALSE 67700
// exit ;
67698: GO 68293
// if control = control_apeman then
67700: LD_VAR 0 4
67704: PUSH
67705: LD_INT 5
67707: EQUAL
67708: IFFALSE 67817
// begin tmp := UnitsInside ( factory ) ;
67710: LD_ADDR_VAR 0 8
67714: PUSH
67715: LD_VAR 0 1
67719: PPUSH
67720: CALL_OW 313
67724: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67725: LD_VAR 0 8
67729: PPUSH
67730: LD_INT 25
67732: PUSH
67733: LD_INT 12
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PPUSH
67740: CALL_OW 72
67744: NOT
67745: IFFALSE 67755
// control := control_manual ;
67747: LD_ADDR_VAR 0 4
67751: PUSH
67752: LD_INT 1
67754: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67755: LD_ADDR_VAR 0 8
67759: PUSH
67760: LD_VAR 0 1
67764: PPUSH
67765: CALL 67452 0 1
67769: ST_TO_ADDR
// if tmp then
67770: LD_VAR 0 8
67774: IFFALSE 67817
// begin for i in tmp do
67776: LD_ADDR_VAR 0 7
67780: PUSH
67781: LD_VAR 0 8
67785: PUSH
67786: FOR_IN
67787: IFFALSE 67815
// if i [ 1 ] = b_ext_radio then
67789: LD_VAR 0 7
67793: PUSH
67794: LD_INT 1
67796: ARRAY
67797: PUSH
67798: LD_INT 22
67800: EQUAL
67801: IFFALSE 67813
// begin control := control_remote ;
67803: LD_ADDR_VAR 0 4
67807: PUSH
67808: LD_INT 2
67810: ST_TO_ADDR
// break ;
67811: GO 67815
// end ;
67813: GO 67786
67815: POP
67816: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67817: LD_VAR 0 1
67821: PPUSH
67822: LD_VAR 0 2
67826: PPUSH
67827: LD_VAR 0 3
67831: PPUSH
67832: LD_VAR 0 4
67836: PPUSH
67837: LD_VAR 0 5
67841: PPUSH
67842: CALL_OW 448
67846: IFFALSE 67881
// begin result := [ chassis , engine , control , weapon ] ;
67848: LD_ADDR_VAR 0 6
67852: PUSH
67853: LD_VAR 0 2
67857: PUSH
67858: LD_VAR 0 3
67862: PUSH
67863: LD_VAR 0 4
67867: PUSH
67868: LD_VAR 0 5
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: ST_TO_ADDR
// exit ;
67879: GO 68293
// end ; _chassis := AvailableChassisList ( factory ) ;
67881: LD_ADDR_VAR 0 9
67885: PUSH
67886: LD_VAR 0 1
67890: PPUSH
67891: CALL_OW 475
67895: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67896: LD_ADDR_VAR 0 11
67900: PUSH
67901: LD_VAR 0 1
67905: PPUSH
67906: CALL_OW 476
67910: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67911: LD_ADDR_VAR 0 12
67915: PUSH
67916: LD_VAR 0 1
67920: PPUSH
67921: CALL_OW 477
67925: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67926: LD_ADDR_VAR 0 10
67930: PUSH
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL_OW 478
67940: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67941: LD_VAR 0 9
67945: NOT
67946: PUSH
67947: LD_VAR 0 11
67951: NOT
67952: OR
67953: PUSH
67954: LD_VAR 0 12
67958: NOT
67959: OR
67960: PUSH
67961: LD_VAR 0 10
67965: NOT
67966: OR
67967: IFFALSE 68002
// begin result := [ chassis , engine , control , weapon ] ;
67969: LD_ADDR_VAR 0 6
67973: PUSH
67974: LD_VAR 0 2
67978: PUSH
67979: LD_VAR 0 3
67983: PUSH
67984: LD_VAR 0 4
67988: PUSH
67989: LD_VAR 0 5
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: ST_TO_ADDR
// exit ;
68000: GO 68293
// end ; if not chassis in _chassis then
68002: LD_VAR 0 2
68006: PUSH
68007: LD_VAR 0 9
68011: IN
68012: NOT
68013: IFFALSE 68039
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68015: LD_ADDR_VAR 0 2
68019: PUSH
68020: LD_VAR 0 9
68024: PUSH
68025: LD_INT 1
68027: PPUSH
68028: LD_VAR 0 9
68032: PPUSH
68033: CALL_OW 12
68037: ARRAY
68038: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68039: LD_VAR 0 2
68043: PPUSH
68044: LD_VAR 0 3
68048: PPUSH
68049: CALL 68298 0 2
68053: NOT
68054: IFFALSE 68113
// repeat engine := _engine [ 1 ] ;
68056: LD_ADDR_VAR 0 3
68060: PUSH
68061: LD_VAR 0 11
68065: PUSH
68066: LD_INT 1
68068: ARRAY
68069: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68070: LD_ADDR_VAR 0 11
68074: PUSH
68075: LD_VAR 0 11
68079: PPUSH
68080: LD_INT 1
68082: PPUSH
68083: CALL_OW 3
68087: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68088: LD_VAR 0 2
68092: PPUSH
68093: LD_VAR 0 3
68097: PPUSH
68098: CALL 68298 0 2
68102: PUSH
68103: LD_VAR 0 11
68107: PUSH
68108: EMPTY
68109: EQUAL
68110: OR
68111: IFFALSE 68056
// if not control in _control then
68113: LD_VAR 0 4
68117: PUSH
68118: LD_VAR 0 12
68122: IN
68123: NOT
68124: IFFALSE 68150
// control := _control [ rand ( 1 , _control ) ] ;
68126: LD_ADDR_VAR 0 4
68130: PUSH
68131: LD_VAR 0 12
68135: PUSH
68136: LD_INT 1
68138: PPUSH
68139: LD_VAR 0 12
68143: PPUSH
68144: CALL_OW 12
68148: ARRAY
68149: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68150: LD_VAR 0 2
68154: PPUSH
68155: LD_VAR 0 5
68159: PPUSH
68160: CALL 68518 0 2
68164: NOT
68165: IFFALSE 68224
// repeat weapon := _weapon [ 1 ] ;
68167: LD_ADDR_VAR 0 5
68171: PUSH
68172: LD_VAR 0 10
68176: PUSH
68177: LD_INT 1
68179: ARRAY
68180: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68181: LD_ADDR_VAR 0 10
68185: PUSH
68186: LD_VAR 0 10
68190: PPUSH
68191: LD_INT 1
68193: PPUSH
68194: CALL_OW 3
68198: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68199: LD_VAR 0 2
68203: PPUSH
68204: LD_VAR 0 5
68208: PPUSH
68209: CALL 68518 0 2
68213: PUSH
68214: LD_VAR 0 10
68218: PUSH
68219: EMPTY
68220: EQUAL
68221: OR
68222: IFFALSE 68167
// result := [ ] ;
68224: LD_ADDR_VAR 0 6
68228: PUSH
68229: EMPTY
68230: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68231: LD_VAR 0 1
68235: PPUSH
68236: LD_VAR 0 2
68240: PPUSH
68241: LD_VAR 0 3
68245: PPUSH
68246: LD_VAR 0 4
68250: PPUSH
68251: LD_VAR 0 5
68255: PPUSH
68256: CALL_OW 448
68260: IFFALSE 68293
// result := [ chassis , engine , control , weapon ] ;
68262: LD_ADDR_VAR 0 6
68266: PUSH
68267: LD_VAR 0 2
68271: PUSH
68272: LD_VAR 0 3
68276: PUSH
68277: LD_VAR 0 4
68281: PUSH
68282: LD_VAR 0 5
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: ST_TO_ADDR
// end ;
68293: LD_VAR 0 6
68297: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68298: LD_INT 0
68300: PPUSH
// if not chassis or not engine then
68301: LD_VAR 0 1
68305: NOT
68306: PUSH
68307: LD_VAR 0 2
68311: NOT
68312: OR
68313: IFFALSE 68317
// exit ;
68315: GO 68513
// case engine of engine_solar :
68317: LD_VAR 0 2
68321: PUSH
68322: LD_INT 2
68324: DOUBLE
68325: EQUAL
68326: IFTRUE 68330
68328: GO 68368
68330: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68331: LD_ADDR_VAR 0 3
68335: PUSH
68336: LD_INT 11
68338: PUSH
68339: LD_INT 12
68341: PUSH
68342: LD_INT 13
68344: PUSH
68345: LD_INT 14
68347: PUSH
68348: LD_INT 1
68350: PUSH
68351: LD_INT 2
68353: PUSH
68354: LD_INT 3
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: ST_TO_ADDR
68366: GO 68497
68368: LD_INT 1
68370: DOUBLE
68371: EQUAL
68372: IFTRUE 68376
68374: GO 68438
68376: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68377: LD_ADDR_VAR 0 3
68381: PUSH
68382: LD_INT 11
68384: PUSH
68385: LD_INT 12
68387: PUSH
68388: LD_INT 13
68390: PUSH
68391: LD_INT 14
68393: PUSH
68394: LD_INT 1
68396: PUSH
68397: LD_INT 2
68399: PUSH
68400: LD_INT 3
68402: PUSH
68403: LD_INT 4
68405: PUSH
68406: LD_INT 5
68408: PUSH
68409: LD_INT 21
68411: PUSH
68412: LD_INT 23
68414: PUSH
68415: LD_INT 22
68417: PUSH
68418: LD_INT 24
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: ST_TO_ADDR
68436: GO 68497
68438: LD_INT 3
68440: DOUBLE
68441: EQUAL
68442: IFTRUE 68446
68444: GO 68496
68446: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68447: LD_ADDR_VAR 0 3
68451: PUSH
68452: LD_INT 13
68454: PUSH
68455: LD_INT 14
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 3
68463: PUSH
68464: LD_INT 4
68466: PUSH
68467: LD_INT 5
68469: PUSH
68470: LD_INT 21
68472: PUSH
68473: LD_INT 22
68475: PUSH
68476: LD_INT 23
68478: PUSH
68479: LD_INT 24
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: ST_TO_ADDR
68494: GO 68497
68496: POP
// result := ( chassis in result ) ;
68497: LD_ADDR_VAR 0 3
68501: PUSH
68502: LD_VAR 0 1
68506: PUSH
68507: LD_VAR 0 3
68511: IN
68512: ST_TO_ADDR
// end ;
68513: LD_VAR 0 3
68517: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68518: LD_INT 0
68520: PPUSH
// if not chassis or not weapon then
68521: LD_VAR 0 1
68525: NOT
68526: PUSH
68527: LD_VAR 0 2
68531: NOT
68532: OR
68533: IFFALSE 68537
// exit ;
68535: GO 69563
// case weapon of us_machine_gun :
68537: LD_VAR 0 2
68541: PUSH
68542: LD_INT 2
68544: DOUBLE
68545: EQUAL
68546: IFTRUE 68550
68548: GO 68580
68550: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68551: LD_ADDR_VAR 0 3
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: LD_INT 2
68561: PUSH
68562: LD_INT 3
68564: PUSH
68565: LD_INT 4
68567: PUSH
68568: LD_INT 5
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: ST_TO_ADDR
68578: GO 69547
68580: LD_INT 3
68582: DOUBLE
68583: EQUAL
68584: IFTRUE 68588
68586: GO 68618
68588: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68589: LD_ADDR_VAR 0 3
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: LD_INT 2
68599: PUSH
68600: LD_INT 3
68602: PUSH
68603: LD_INT 4
68605: PUSH
68606: LD_INT 5
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: ST_TO_ADDR
68616: GO 69547
68618: LD_INT 11
68620: DOUBLE
68621: EQUAL
68622: IFTRUE 68626
68624: GO 68656
68626: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68627: LD_ADDR_VAR 0 3
68631: PUSH
68632: LD_INT 1
68634: PUSH
68635: LD_INT 2
68637: PUSH
68638: LD_INT 3
68640: PUSH
68641: LD_INT 4
68643: PUSH
68644: LD_INT 5
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: ST_TO_ADDR
68654: GO 69547
68656: LD_INT 4
68658: DOUBLE
68659: EQUAL
68660: IFTRUE 68664
68662: GO 68690
68664: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68665: LD_ADDR_VAR 0 3
68669: PUSH
68670: LD_INT 2
68672: PUSH
68673: LD_INT 3
68675: PUSH
68676: LD_INT 4
68678: PUSH
68679: LD_INT 5
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: ST_TO_ADDR
68688: GO 69547
68690: LD_INT 5
68692: DOUBLE
68693: EQUAL
68694: IFTRUE 68698
68696: GO 68724
68698: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68699: LD_ADDR_VAR 0 3
68703: PUSH
68704: LD_INT 2
68706: PUSH
68707: LD_INT 3
68709: PUSH
68710: LD_INT 4
68712: PUSH
68713: LD_INT 5
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: ST_TO_ADDR
68722: GO 69547
68724: LD_INT 9
68726: DOUBLE
68727: EQUAL
68728: IFTRUE 68732
68730: GO 68758
68732: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68733: LD_ADDR_VAR 0 3
68737: PUSH
68738: LD_INT 2
68740: PUSH
68741: LD_INT 3
68743: PUSH
68744: LD_INT 4
68746: PUSH
68747: LD_INT 5
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: ST_TO_ADDR
68756: GO 69547
68758: LD_INT 7
68760: DOUBLE
68761: EQUAL
68762: IFTRUE 68766
68764: GO 68792
68766: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68767: LD_ADDR_VAR 0 3
68771: PUSH
68772: LD_INT 2
68774: PUSH
68775: LD_INT 3
68777: PUSH
68778: LD_INT 4
68780: PUSH
68781: LD_INT 5
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: ST_TO_ADDR
68790: GO 69547
68792: LD_INT 12
68794: DOUBLE
68795: EQUAL
68796: IFTRUE 68800
68798: GO 68826
68800: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68801: LD_ADDR_VAR 0 3
68805: PUSH
68806: LD_INT 2
68808: PUSH
68809: LD_INT 3
68811: PUSH
68812: LD_INT 4
68814: PUSH
68815: LD_INT 5
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: ST_TO_ADDR
68824: GO 69547
68826: LD_INT 13
68828: DOUBLE
68829: EQUAL
68830: IFTRUE 68834
68832: GO 68860
68834: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68835: LD_ADDR_VAR 0 3
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: LD_INT 3
68845: PUSH
68846: LD_INT 4
68848: PUSH
68849: LD_INT 5
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: ST_TO_ADDR
68858: GO 69547
68860: LD_INT 14
68862: DOUBLE
68863: EQUAL
68864: IFTRUE 68868
68866: GO 68886
68868: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: LD_INT 4
68876: PUSH
68877: LD_INT 5
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: ST_TO_ADDR
68884: GO 69547
68886: LD_INT 6
68888: DOUBLE
68889: EQUAL
68890: IFTRUE 68894
68892: GO 68912
68894: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68895: LD_ADDR_VAR 0 3
68899: PUSH
68900: LD_INT 4
68902: PUSH
68903: LD_INT 5
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: ST_TO_ADDR
68910: GO 69547
68912: LD_INT 10
68914: DOUBLE
68915: EQUAL
68916: IFTRUE 68920
68918: GO 68938
68920: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68921: LD_ADDR_VAR 0 3
68925: PUSH
68926: LD_INT 4
68928: PUSH
68929: LD_INT 5
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: ST_TO_ADDR
68936: GO 69547
68938: LD_INT 22
68940: DOUBLE
68941: EQUAL
68942: IFTRUE 68946
68944: GO 68972
68946: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68947: LD_ADDR_VAR 0 3
68951: PUSH
68952: LD_INT 11
68954: PUSH
68955: LD_INT 12
68957: PUSH
68958: LD_INT 13
68960: PUSH
68961: LD_INT 14
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: ST_TO_ADDR
68970: GO 69547
68972: LD_INT 23
68974: DOUBLE
68975: EQUAL
68976: IFTRUE 68980
68978: GO 69006
68980: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68981: LD_ADDR_VAR 0 3
68985: PUSH
68986: LD_INT 11
68988: PUSH
68989: LD_INT 12
68991: PUSH
68992: LD_INT 13
68994: PUSH
68995: LD_INT 14
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: ST_TO_ADDR
69004: GO 69547
69006: LD_INT 24
69008: DOUBLE
69009: EQUAL
69010: IFTRUE 69014
69012: GO 69040
69014: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69015: LD_ADDR_VAR 0 3
69019: PUSH
69020: LD_INT 11
69022: PUSH
69023: LD_INT 12
69025: PUSH
69026: LD_INT 13
69028: PUSH
69029: LD_INT 14
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: ST_TO_ADDR
69038: GO 69547
69040: LD_INT 30
69042: DOUBLE
69043: EQUAL
69044: IFTRUE 69048
69046: GO 69074
69048: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69049: LD_ADDR_VAR 0 3
69053: PUSH
69054: LD_INT 11
69056: PUSH
69057: LD_INT 12
69059: PUSH
69060: LD_INT 13
69062: PUSH
69063: LD_INT 14
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: ST_TO_ADDR
69072: GO 69547
69074: LD_INT 25
69076: DOUBLE
69077: EQUAL
69078: IFTRUE 69082
69080: GO 69100
69082: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69083: LD_ADDR_VAR 0 3
69087: PUSH
69088: LD_INT 13
69090: PUSH
69091: LD_INT 14
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: ST_TO_ADDR
69098: GO 69547
69100: LD_INT 27
69102: DOUBLE
69103: EQUAL
69104: IFTRUE 69108
69106: GO 69126
69108: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69109: LD_ADDR_VAR 0 3
69113: PUSH
69114: LD_INT 13
69116: PUSH
69117: LD_INT 14
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: ST_TO_ADDR
69124: GO 69547
69126: LD_INT 28
69128: DOUBLE
69129: EQUAL
69130: IFTRUE 69134
69132: GO 69152
69134: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69135: LD_ADDR_VAR 0 3
69139: PUSH
69140: LD_INT 13
69142: PUSH
69143: LD_INT 14
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: ST_TO_ADDR
69150: GO 69547
69152: LD_INT 29
69154: DOUBLE
69155: EQUAL
69156: IFTRUE 69160
69158: GO 69178
69160: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69161: LD_ADDR_VAR 0 3
69165: PUSH
69166: LD_INT 13
69168: PUSH
69169: LD_INT 14
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: ST_TO_ADDR
69176: GO 69547
69178: LD_INT 31
69180: DOUBLE
69181: EQUAL
69182: IFTRUE 69186
69184: GO 69204
69186: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69187: LD_ADDR_VAR 0 3
69191: PUSH
69192: LD_INT 13
69194: PUSH
69195: LD_INT 14
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: ST_TO_ADDR
69202: GO 69547
69204: LD_INT 26
69206: DOUBLE
69207: EQUAL
69208: IFTRUE 69212
69210: GO 69230
69212: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69213: LD_ADDR_VAR 0 3
69217: PUSH
69218: LD_INT 13
69220: PUSH
69221: LD_INT 14
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: ST_TO_ADDR
69228: GO 69547
69230: LD_INT 42
69232: DOUBLE
69233: EQUAL
69234: IFTRUE 69238
69236: GO 69264
69238: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69239: LD_ADDR_VAR 0 3
69243: PUSH
69244: LD_INT 21
69246: PUSH
69247: LD_INT 22
69249: PUSH
69250: LD_INT 23
69252: PUSH
69253: LD_INT 24
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: ST_TO_ADDR
69262: GO 69547
69264: LD_INT 43
69266: DOUBLE
69267: EQUAL
69268: IFTRUE 69272
69270: GO 69298
69272: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69273: LD_ADDR_VAR 0 3
69277: PUSH
69278: LD_INT 21
69280: PUSH
69281: LD_INT 22
69283: PUSH
69284: LD_INT 23
69286: PUSH
69287: LD_INT 24
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: ST_TO_ADDR
69296: GO 69547
69298: LD_INT 44
69300: DOUBLE
69301: EQUAL
69302: IFTRUE 69306
69304: GO 69332
69306: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69307: LD_ADDR_VAR 0 3
69311: PUSH
69312: LD_INT 21
69314: PUSH
69315: LD_INT 22
69317: PUSH
69318: LD_INT 23
69320: PUSH
69321: LD_INT 24
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: ST_TO_ADDR
69330: GO 69547
69332: LD_INT 45
69334: DOUBLE
69335: EQUAL
69336: IFTRUE 69340
69338: GO 69366
69340: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69341: LD_ADDR_VAR 0 3
69345: PUSH
69346: LD_INT 21
69348: PUSH
69349: LD_INT 22
69351: PUSH
69352: LD_INT 23
69354: PUSH
69355: LD_INT 24
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: ST_TO_ADDR
69364: GO 69547
69366: LD_INT 49
69368: DOUBLE
69369: EQUAL
69370: IFTRUE 69374
69372: GO 69400
69374: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69375: LD_ADDR_VAR 0 3
69379: PUSH
69380: LD_INT 21
69382: PUSH
69383: LD_INT 22
69385: PUSH
69386: LD_INT 23
69388: PUSH
69389: LD_INT 24
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: ST_TO_ADDR
69398: GO 69547
69400: LD_INT 51
69402: DOUBLE
69403: EQUAL
69404: IFTRUE 69408
69406: GO 69434
69408: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69409: LD_ADDR_VAR 0 3
69413: PUSH
69414: LD_INT 21
69416: PUSH
69417: LD_INT 22
69419: PUSH
69420: LD_INT 23
69422: PUSH
69423: LD_INT 24
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: ST_TO_ADDR
69432: GO 69547
69434: LD_INT 52
69436: DOUBLE
69437: EQUAL
69438: IFTRUE 69442
69440: GO 69468
69442: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69443: LD_ADDR_VAR 0 3
69447: PUSH
69448: LD_INT 21
69450: PUSH
69451: LD_INT 22
69453: PUSH
69454: LD_INT 23
69456: PUSH
69457: LD_INT 24
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: ST_TO_ADDR
69466: GO 69547
69468: LD_INT 53
69470: DOUBLE
69471: EQUAL
69472: IFTRUE 69476
69474: GO 69494
69476: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69477: LD_ADDR_VAR 0 3
69481: PUSH
69482: LD_INT 23
69484: PUSH
69485: LD_INT 24
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: ST_TO_ADDR
69492: GO 69547
69494: LD_INT 46
69496: DOUBLE
69497: EQUAL
69498: IFTRUE 69502
69500: GO 69520
69502: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69503: LD_ADDR_VAR 0 3
69507: PUSH
69508: LD_INT 23
69510: PUSH
69511: LD_INT 24
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: ST_TO_ADDR
69518: GO 69547
69520: LD_INT 47
69522: DOUBLE
69523: EQUAL
69524: IFTRUE 69528
69526: GO 69546
69528: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69529: LD_ADDR_VAR 0 3
69533: PUSH
69534: LD_INT 23
69536: PUSH
69537: LD_INT 24
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: ST_TO_ADDR
69544: GO 69547
69546: POP
// result := ( chassis in result ) ;
69547: LD_ADDR_VAR 0 3
69551: PUSH
69552: LD_VAR 0 1
69556: PUSH
69557: LD_VAR 0 3
69561: IN
69562: ST_TO_ADDR
// end ;
69563: LD_VAR 0 3
69567: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69568: LD_INT 0
69570: PPUSH
69571: PPUSH
69572: PPUSH
69573: PPUSH
69574: PPUSH
69575: PPUSH
69576: PPUSH
// result := array ;
69577: LD_ADDR_VAR 0 5
69581: PUSH
69582: LD_VAR 0 1
69586: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69587: LD_VAR 0 1
69591: NOT
69592: PUSH
69593: LD_VAR 0 2
69597: NOT
69598: OR
69599: PUSH
69600: LD_VAR 0 3
69604: NOT
69605: OR
69606: PUSH
69607: LD_VAR 0 2
69611: PUSH
69612: LD_VAR 0 1
69616: GREATER
69617: OR
69618: PUSH
69619: LD_VAR 0 3
69623: PUSH
69624: LD_VAR 0 1
69628: GREATER
69629: OR
69630: IFFALSE 69634
// exit ;
69632: GO 69930
// if direction then
69634: LD_VAR 0 4
69638: IFFALSE 69702
// begin d := 1 ;
69640: LD_ADDR_VAR 0 9
69644: PUSH
69645: LD_INT 1
69647: ST_TO_ADDR
// if i_from > i_to then
69648: LD_VAR 0 2
69652: PUSH
69653: LD_VAR 0 3
69657: GREATER
69658: IFFALSE 69684
// length := ( array - i_from ) + i_to else
69660: LD_ADDR_VAR 0 11
69664: PUSH
69665: LD_VAR 0 1
69669: PUSH
69670: LD_VAR 0 2
69674: MINUS
69675: PUSH
69676: LD_VAR 0 3
69680: PLUS
69681: ST_TO_ADDR
69682: GO 69700
// length := i_to - i_from ;
69684: LD_ADDR_VAR 0 11
69688: PUSH
69689: LD_VAR 0 3
69693: PUSH
69694: LD_VAR 0 2
69698: MINUS
69699: ST_TO_ADDR
// end else
69700: GO 69763
// begin d := - 1 ;
69702: LD_ADDR_VAR 0 9
69706: PUSH
69707: LD_INT 1
69709: NEG
69710: ST_TO_ADDR
// if i_from > i_to then
69711: LD_VAR 0 2
69715: PUSH
69716: LD_VAR 0 3
69720: GREATER
69721: IFFALSE 69741
// length := i_from - i_to else
69723: LD_ADDR_VAR 0 11
69727: PUSH
69728: LD_VAR 0 2
69732: PUSH
69733: LD_VAR 0 3
69737: MINUS
69738: ST_TO_ADDR
69739: GO 69763
// length := ( array - i_to ) + i_from ;
69741: LD_ADDR_VAR 0 11
69745: PUSH
69746: LD_VAR 0 1
69750: PUSH
69751: LD_VAR 0 3
69755: MINUS
69756: PUSH
69757: LD_VAR 0 2
69761: PLUS
69762: ST_TO_ADDR
// end ; if not length then
69763: LD_VAR 0 11
69767: NOT
69768: IFFALSE 69772
// exit ;
69770: GO 69930
// tmp := array ;
69772: LD_ADDR_VAR 0 10
69776: PUSH
69777: LD_VAR 0 1
69781: ST_TO_ADDR
// for i = 1 to length do
69782: LD_ADDR_VAR 0 6
69786: PUSH
69787: DOUBLE
69788: LD_INT 1
69790: DEC
69791: ST_TO_ADDR
69792: LD_VAR 0 11
69796: PUSH
69797: FOR_TO
69798: IFFALSE 69918
// begin for j = 1 to array do
69800: LD_ADDR_VAR 0 7
69804: PUSH
69805: DOUBLE
69806: LD_INT 1
69808: DEC
69809: ST_TO_ADDR
69810: LD_VAR 0 1
69814: PUSH
69815: FOR_TO
69816: IFFALSE 69904
// begin k := j + d ;
69818: LD_ADDR_VAR 0 8
69822: PUSH
69823: LD_VAR 0 7
69827: PUSH
69828: LD_VAR 0 9
69832: PLUS
69833: ST_TO_ADDR
// if k > array then
69834: LD_VAR 0 8
69838: PUSH
69839: LD_VAR 0 1
69843: GREATER
69844: IFFALSE 69854
// k := 1 ;
69846: LD_ADDR_VAR 0 8
69850: PUSH
69851: LD_INT 1
69853: ST_TO_ADDR
// if not k then
69854: LD_VAR 0 8
69858: NOT
69859: IFFALSE 69871
// k := array ;
69861: LD_ADDR_VAR 0 8
69865: PUSH
69866: LD_VAR 0 1
69870: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69871: LD_ADDR_VAR 0 10
69875: PUSH
69876: LD_VAR 0 10
69880: PPUSH
69881: LD_VAR 0 8
69885: PPUSH
69886: LD_VAR 0 1
69890: PUSH
69891: LD_VAR 0 7
69895: ARRAY
69896: PPUSH
69897: CALL_OW 1
69901: ST_TO_ADDR
// end ;
69902: GO 69815
69904: POP
69905: POP
// array := tmp ;
69906: LD_ADDR_VAR 0 1
69910: PUSH
69911: LD_VAR 0 10
69915: ST_TO_ADDR
// end ;
69916: GO 69797
69918: POP
69919: POP
// result := array ;
69920: LD_ADDR_VAR 0 5
69924: PUSH
69925: LD_VAR 0 1
69929: ST_TO_ADDR
// end ;
69930: LD_VAR 0 5
69934: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69935: LD_INT 0
69937: PPUSH
69938: PPUSH
// result := 0 ;
69939: LD_ADDR_VAR 0 3
69943: PUSH
69944: LD_INT 0
69946: ST_TO_ADDR
// if not array or not value in array then
69947: LD_VAR 0 1
69951: NOT
69952: PUSH
69953: LD_VAR 0 2
69957: PUSH
69958: LD_VAR 0 1
69962: IN
69963: NOT
69964: OR
69965: IFFALSE 69969
// exit ;
69967: GO 70023
// for i = 1 to array do
69969: LD_ADDR_VAR 0 4
69973: PUSH
69974: DOUBLE
69975: LD_INT 1
69977: DEC
69978: ST_TO_ADDR
69979: LD_VAR 0 1
69983: PUSH
69984: FOR_TO
69985: IFFALSE 70021
// if value = array [ i ] then
69987: LD_VAR 0 2
69991: PUSH
69992: LD_VAR 0 1
69996: PUSH
69997: LD_VAR 0 4
70001: ARRAY
70002: EQUAL
70003: IFFALSE 70019
// begin result := i ;
70005: LD_ADDR_VAR 0 3
70009: PUSH
70010: LD_VAR 0 4
70014: ST_TO_ADDR
// exit ;
70015: POP
70016: POP
70017: GO 70023
// end ;
70019: GO 69984
70021: POP
70022: POP
// end ;
70023: LD_VAR 0 3
70027: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70028: LD_INT 0
70030: PPUSH
// vc_chassis := chassis ;
70031: LD_ADDR_OWVAR 37
70035: PUSH
70036: LD_VAR 0 1
70040: ST_TO_ADDR
// vc_engine := engine ;
70041: LD_ADDR_OWVAR 39
70045: PUSH
70046: LD_VAR 0 2
70050: ST_TO_ADDR
// vc_control := control ;
70051: LD_ADDR_OWVAR 38
70055: PUSH
70056: LD_VAR 0 3
70060: ST_TO_ADDR
// vc_weapon := weapon ;
70061: LD_ADDR_OWVAR 40
70065: PUSH
70066: LD_VAR 0 4
70070: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70071: LD_ADDR_OWVAR 41
70075: PUSH
70076: LD_VAR 0 5
70080: ST_TO_ADDR
// end ;
70081: LD_VAR 0 6
70085: RET
// export function WantPlant ( unit ) ; var task ; begin
70086: LD_INT 0
70088: PPUSH
70089: PPUSH
// result := false ;
70090: LD_ADDR_VAR 0 2
70094: PUSH
70095: LD_INT 0
70097: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70098: LD_ADDR_VAR 0 3
70102: PUSH
70103: LD_VAR 0 1
70107: PPUSH
70108: CALL_OW 437
70112: ST_TO_ADDR
// if task then
70113: LD_VAR 0 3
70117: IFFALSE 70145
// if task [ 1 ] [ 1 ] = p then
70119: LD_VAR 0 3
70123: PUSH
70124: LD_INT 1
70126: ARRAY
70127: PUSH
70128: LD_INT 1
70130: ARRAY
70131: PUSH
70132: LD_STRING p
70134: EQUAL
70135: IFFALSE 70145
// result := true ;
70137: LD_ADDR_VAR 0 2
70141: PUSH
70142: LD_INT 1
70144: ST_TO_ADDR
// end ;
70145: LD_VAR 0 2
70149: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70150: LD_INT 0
70152: PPUSH
70153: PPUSH
70154: PPUSH
70155: PPUSH
// if pos < 1 then
70156: LD_VAR 0 2
70160: PUSH
70161: LD_INT 1
70163: LESS
70164: IFFALSE 70168
// exit ;
70166: GO 70471
// if pos = 1 then
70168: LD_VAR 0 2
70172: PUSH
70173: LD_INT 1
70175: EQUAL
70176: IFFALSE 70209
// result := Replace ( arr , pos [ 1 ] , value ) else
70178: LD_ADDR_VAR 0 4
70182: PUSH
70183: LD_VAR 0 1
70187: PPUSH
70188: LD_VAR 0 2
70192: PUSH
70193: LD_INT 1
70195: ARRAY
70196: PPUSH
70197: LD_VAR 0 3
70201: PPUSH
70202: CALL_OW 1
70206: ST_TO_ADDR
70207: GO 70471
// begin tmp := arr ;
70209: LD_ADDR_VAR 0 6
70213: PUSH
70214: LD_VAR 0 1
70218: ST_TO_ADDR
// s_arr := [ tmp ] ;
70219: LD_ADDR_VAR 0 7
70223: PUSH
70224: LD_VAR 0 6
70228: PUSH
70229: EMPTY
70230: LIST
70231: ST_TO_ADDR
// for i = 1 to pos - 1 do
70232: LD_ADDR_VAR 0 5
70236: PUSH
70237: DOUBLE
70238: LD_INT 1
70240: DEC
70241: ST_TO_ADDR
70242: LD_VAR 0 2
70246: PUSH
70247: LD_INT 1
70249: MINUS
70250: PUSH
70251: FOR_TO
70252: IFFALSE 70297
// begin tmp := tmp [ pos [ i ] ] ;
70254: LD_ADDR_VAR 0 6
70258: PUSH
70259: LD_VAR 0 6
70263: PUSH
70264: LD_VAR 0 2
70268: PUSH
70269: LD_VAR 0 5
70273: ARRAY
70274: ARRAY
70275: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70276: LD_ADDR_VAR 0 7
70280: PUSH
70281: LD_VAR 0 7
70285: PUSH
70286: LD_VAR 0 6
70290: PUSH
70291: EMPTY
70292: LIST
70293: ADD
70294: ST_TO_ADDR
// end ;
70295: GO 70251
70297: POP
70298: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70299: LD_ADDR_VAR 0 6
70303: PUSH
70304: LD_VAR 0 6
70308: PPUSH
70309: LD_VAR 0 2
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PPUSH
70320: LD_VAR 0 3
70324: PPUSH
70325: CALL_OW 1
70329: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70330: LD_ADDR_VAR 0 7
70334: PUSH
70335: LD_VAR 0 7
70339: PPUSH
70340: LD_VAR 0 7
70344: PPUSH
70345: LD_VAR 0 6
70349: PPUSH
70350: CALL_OW 1
70354: ST_TO_ADDR
// for i = s_arr downto 2 do
70355: LD_ADDR_VAR 0 5
70359: PUSH
70360: DOUBLE
70361: LD_VAR 0 7
70365: INC
70366: ST_TO_ADDR
70367: LD_INT 2
70369: PUSH
70370: FOR_DOWNTO
70371: IFFALSE 70455
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70373: LD_ADDR_VAR 0 6
70377: PUSH
70378: LD_VAR 0 7
70382: PUSH
70383: LD_VAR 0 5
70387: PUSH
70388: LD_INT 1
70390: MINUS
70391: ARRAY
70392: PPUSH
70393: LD_VAR 0 2
70397: PUSH
70398: LD_VAR 0 5
70402: PUSH
70403: LD_INT 1
70405: MINUS
70406: ARRAY
70407: PPUSH
70408: LD_VAR 0 7
70412: PUSH
70413: LD_VAR 0 5
70417: ARRAY
70418: PPUSH
70419: CALL_OW 1
70423: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70424: LD_ADDR_VAR 0 7
70428: PUSH
70429: LD_VAR 0 7
70433: PPUSH
70434: LD_VAR 0 5
70438: PUSH
70439: LD_INT 1
70441: MINUS
70442: PPUSH
70443: LD_VAR 0 6
70447: PPUSH
70448: CALL_OW 1
70452: ST_TO_ADDR
// end ;
70453: GO 70370
70455: POP
70456: POP
// result := s_arr [ 1 ] ;
70457: LD_ADDR_VAR 0 4
70461: PUSH
70462: LD_VAR 0 7
70466: PUSH
70467: LD_INT 1
70469: ARRAY
70470: ST_TO_ADDR
// end ; end ;
70471: LD_VAR 0 4
70475: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70476: LD_INT 0
70478: PPUSH
70479: PPUSH
// if not list then
70480: LD_VAR 0 1
70484: NOT
70485: IFFALSE 70489
// exit ;
70487: GO 70580
// i := list [ pos1 ] ;
70489: LD_ADDR_VAR 0 5
70493: PUSH
70494: LD_VAR 0 1
70498: PUSH
70499: LD_VAR 0 2
70503: ARRAY
70504: ST_TO_ADDR
// if not i then
70505: LD_VAR 0 5
70509: NOT
70510: IFFALSE 70514
// exit ;
70512: GO 70580
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70514: LD_ADDR_VAR 0 1
70518: PUSH
70519: LD_VAR 0 1
70523: PPUSH
70524: LD_VAR 0 2
70528: PPUSH
70529: LD_VAR 0 1
70533: PUSH
70534: LD_VAR 0 3
70538: ARRAY
70539: PPUSH
70540: CALL_OW 1
70544: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70545: LD_ADDR_VAR 0 1
70549: PUSH
70550: LD_VAR 0 1
70554: PPUSH
70555: LD_VAR 0 3
70559: PPUSH
70560: LD_VAR 0 5
70564: PPUSH
70565: CALL_OW 1
70569: ST_TO_ADDR
// result := list ;
70570: LD_ADDR_VAR 0 4
70574: PUSH
70575: LD_VAR 0 1
70579: ST_TO_ADDR
// end ;
70580: LD_VAR 0 4
70584: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70585: LD_INT 0
70587: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70588: LD_ADDR_VAR 0 5
70592: PUSH
70593: LD_VAR 0 1
70597: PPUSH
70598: CALL_OW 250
70602: PPUSH
70603: LD_VAR 0 1
70607: PPUSH
70608: CALL_OW 251
70612: PPUSH
70613: LD_VAR 0 2
70617: PPUSH
70618: LD_VAR 0 3
70622: PPUSH
70623: LD_VAR 0 4
70627: PPUSH
70628: CALL 70638 0 5
70632: ST_TO_ADDR
// end ;
70633: LD_VAR 0 5
70637: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70638: LD_INT 0
70640: PPUSH
70641: PPUSH
70642: PPUSH
70643: PPUSH
// if not list then
70644: LD_VAR 0 3
70648: NOT
70649: IFFALSE 70653
// exit ;
70651: GO 71041
// result := [ ] ;
70653: LD_ADDR_VAR 0 6
70657: PUSH
70658: EMPTY
70659: ST_TO_ADDR
// for i in list do
70660: LD_ADDR_VAR 0 7
70664: PUSH
70665: LD_VAR 0 3
70669: PUSH
70670: FOR_IN
70671: IFFALSE 70873
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70673: LD_ADDR_VAR 0 9
70677: PUSH
70678: LD_VAR 0 7
70682: PPUSH
70683: LD_VAR 0 1
70687: PPUSH
70688: LD_VAR 0 2
70692: PPUSH
70693: CALL_OW 297
70697: ST_TO_ADDR
// if not result then
70698: LD_VAR 0 6
70702: NOT
70703: IFFALSE 70729
// result := [ [ i , tmp ] ] else
70705: LD_ADDR_VAR 0 6
70709: PUSH
70710: LD_VAR 0 7
70714: PUSH
70715: LD_VAR 0 9
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: EMPTY
70725: LIST
70726: ST_TO_ADDR
70727: GO 70871
// begin if result [ result ] [ 2 ] < tmp then
70729: LD_VAR 0 6
70733: PUSH
70734: LD_VAR 0 6
70738: ARRAY
70739: PUSH
70740: LD_INT 2
70742: ARRAY
70743: PUSH
70744: LD_VAR 0 9
70748: LESS
70749: IFFALSE 70791
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70751: LD_ADDR_VAR 0 6
70755: PUSH
70756: LD_VAR 0 6
70760: PPUSH
70761: LD_VAR 0 6
70765: PUSH
70766: LD_INT 1
70768: PLUS
70769: PPUSH
70770: LD_VAR 0 7
70774: PUSH
70775: LD_VAR 0 9
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PPUSH
70784: CALL_OW 2
70788: ST_TO_ADDR
70789: GO 70871
// for j = 1 to result do
70791: LD_ADDR_VAR 0 8
70795: PUSH
70796: DOUBLE
70797: LD_INT 1
70799: DEC
70800: ST_TO_ADDR
70801: LD_VAR 0 6
70805: PUSH
70806: FOR_TO
70807: IFFALSE 70869
// begin if tmp < result [ j ] [ 2 ] then
70809: LD_VAR 0 9
70813: PUSH
70814: LD_VAR 0 6
70818: PUSH
70819: LD_VAR 0 8
70823: ARRAY
70824: PUSH
70825: LD_INT 2
70827: ARRAY
70828: LESS
70829: IFFALSE 70867
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70831: LD_ADDR_VAR 0 6
70835: PUSH
70836: LD_VAR 0 6
70840: PPUSH
70841: LD_VAR 0 8
70845: PPUSH
70846: LD_VAR 0 7
70850: PUSH
70851: LD_VAR 0 9
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PPUSH
70860: CALL_OW 2
70864: ST_TO_ADDR
// break ;
70865: GO 70869
// end ; end ;
70867: GO 70806
70869: POP
70870: POP
// end ; end ;
70871: GO 70670
70873: POP
70874: POP
// if result and not asc then
70875: LD_VAR 0 6
70879: PUSH
70880: LD_VAR 0 4
70884: NOT
70885: AND
70886: IFFALSE 70961
// begin tmp := result ;
70888: LD_ADDR_VAR 0 9
70892: PUSH
70893: LD_VAR 0 6
70897: ST_TO_ADDR
// for i = tmp downto 1 do
70898: LD_ADDR_VAR 0 7
70902: PUSH
70903: DOUBLE
70904: LD_VAR 0 9
70908: INC
70909: ST_TO_ADDR
70910: LD_INT 1
70912: PUSH
70913: FOR_DOWNTO
70914: IFFALSE 70959
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70916: LD_ADDR_VAR 0 6
70920: PUSH
70921: LD_VAR 0 6
70925: PPUSH
70926: LD_VAR 0 9
70930: PUSH
70931: LD_VAR 0 7
70935: MINUS
70936: PUSH
70937: LD_INT 1
70939: PLUS
70940: PPUSH
70941: LD_VAR 0 9
70945: PUSH
70946: LD_VAR 0 7
70950: ARRAY
70951: PPUSH
70952: CALL_OW 1
70956: ST_TO_ADDR
70957: GO 70913
70959: POP
70960: POP
// end ; tmp := [ ] ;
70961: LD_ADDR_VAR 0 9
70965: PUSH
70966: EMPTY
70967: ST_TO_ADDR
// if mode then
70968: LD_VAR 0 5
70972: IFFALSE 71041
// begin for i = 1 to result do
70974: LD_ADDR_VAR 0 7
70978: PUSH
70979: DOUBLE
70980: LD_INT 1
70982: DEC
70983: ST_TO_ADDR
70984: LD_VAR 0 6
70988: PUSH
70989: FOR_TO
70990: IFFALSE 71029
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70992: LD_ADDR_VAR 0 9
70996: PUSH
70997: LD_VAR 0 9
71001: PPUSH
71002: LD_VAR 0 7
71006: PPUSH
71007: LD_VAR 0 6
71011: PUSH
71012: LD_VAR 0 7
71016: ARRAY
71017: PUSH
71018: LD_INT 1
71020: ARRAY
71021: PPUSH
71022: CALL_OW 1
71026: ST_TO_ADDR
71027: GO 70989
71029: POP
71030: POP
// result := tmp ;
71031: LD_ADDR_VAR 0 6
71035: PUSH
71036: LD_VAR 0 9
71040: ST_TO_ADDR
// end ; end ;
71041: LD_VAR 0 6
71045: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71046: LD_INT 0
71048: PPUSH
71049: PPUSH
71050: PPUSH
71051: PPUSH
71052: PPUSH
71053: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71054: LD_ADDR_VAR 0 5
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: ST_TO_ADDR
// if not x or not y then
71076: LD_VAR 0 2
71080: NOT
71081: PUSH
71082: LD_VAR 0 3
71086: NOT
71087: OR
71088: IFFALSE 71092
// exit ;
71090: GO 72738
// if not range then
71092: LD_VAR 0 4
71096: NOT
71097: IFFALSE 71107
// range := 10 ;
71099: LD_ADDR_VAR 0 4
71103: PUSH
71104: LD_INT 10
71106: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71107: LD_ADDR_VAR 0 8
71111: PUSH
71112: LD_INT 81
71114: PUSH
71115: LD_VAR 0 1
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 92
71126: PUSH
71127: LD_VAR 0 2
71131: PUSH
71132: LD_VAR 0 3
71136: PUSH
71137: LD_VAR 0 4
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 3
71150: PUSH
71151: LD_INT 21
71153: PUSH
71154: LD_INT 3
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: LIST
71169: PPUSH
71170: CALL_OW 69
71174: ST_TO_ADDR
// if not tmp then
71175: LD_VAR 0 8
71179: NOT
71180: IFFALSE 71184
// exit ;
71182: GO 72738
// for i in tmp do
71184: LD_ADDR_VAR 0 6
71188: PUSH
71189: LD_VAR 0 8
71193: PUSH
71194: FOR_IN
71195: IFFALSE 72713
// begin points := [ 0 , 0 , 0 ] ;
71197: LD_ADDR_VAR 0 9
71201: PUSH
71202: LD_INT 0
71204: PUSH
71205: LD_INT 0
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: LIST
71215: ST_TO_ADDR
// bpoints := 1 ;
71216: LD_ADDR_VAR 0 10
71220: PUSH
71221: LD_INT 1
71223: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71224: LD_VAR 0 6
71228: PPUSH
71229: CALL_OW 247
71233: PUSH
71234: LD_INT 1
71236: DOUBLE
71237: EQUAL
71238: IFTRUE 71242
71240: GO 71820
71242: POP
// begin if GetClass ( i ) = 1 then
71243: LD_VAR 0 6
71247: PPUSH
71248: CALL_OW 257
71252: PUSH
71253: LD_INT 1
71255: EQUAL
71256: IFFALSE 71277
// points := [ 10 , 5 , 3 ] ;
71258: LD_ADDR_VAR 0 9
71262: PUSH
71263: LD_INT 10
71265: PUSH
71266: LD_INT 5
71268: PUSH
71269: LD_INT 3
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: LIST
71276: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71277: LD_VAR 0 6
71281: PPUSH
71282: CALL_OW 257
71286: PUSH
71287: LD_INT 2
71289: PUSH
71290: LD_INT 3
71292: PUSH
71293: LD_INT 4
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: LIST
71300: IN
71301: IFFALSE 71322
// points := [ 3 , 2 , 1 ] ;
71303: LD_ADDR_VAR 0 9
71307: PUSH
71308: LD_INT 3
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: LIST
71321: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71322: LD_VAR 0 6
71326: PPUSH
71327: CALL_OW 257
71331: PUSH
71332: LD_INT 5
71334: EQUAL
71335: IFFALSE 71356
// points := [ 130 , 5 , 2 ] ;
71337: LD_ADDR_VAR 0 9
71341: PUSH
71342: LD_INT 130
71344: PUSH
71345: LD_INT 5
71347: PUSH
71348: LD_INT 2
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: LIST
71355: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71356: LD_VAR 0 6
71360: PPUSH
71361: CALL_OW 257
71365: PUSH
71366: LD_INT 8
71368: EQUAL
71369: IFFALSE 71390
// points := [ 35 , 35 , 30 ] ;
71371: LD_ADDR_VAR 0 9
71375: PUSH
71376: LD_INT 35
71378: PUSH
71379: LD_INT 35
71381: PUSH
71382: LD_INT 30
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: LIST
71389: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71390: LD_VAR 0 6
71394: PPUSH
71395: CALL_OW 257
71399: PUSH
71400: LD_INT 9
71402: EQUAL
71403: IFFALSE 71424
// points := [ 20 , 55 , 40 ] ;
71405: LD_ADDR_VAR 0 9
71409: PUSH
71410: LD_INT 20
71412: PUSH
71413: LD_INT 55
71415: PUSH
71416: LD_INT 40
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71424: LD_VAR 0 6
71428: PPUSH
71429: CALL_OW 257
71433: PUSH
71434: LD_INT 12
71436: PUSH
71437: LD_INT 16
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: IN
71444: IFFALSE 71465
// points := [ 5 , 3 , 2 ] ;
71446: LD_ADDR_VAR 0 9
71450: PUSH
71451: LD_INT 5
71453: PUSH
71454: LD_INT 3
71456: PUSH
71457: LD_INT 2
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71465: LD_VAR 0 6
71469: PPUSH
71470: CALL_OW 257
71474: PUSH
71475: LD_INT 17
71477: EQUAL
71478: IFFALSE 71499
// points := [ 100 , 50 , 75 ] ;
71480: LD_ADDR_VAR 0 9
71484: PUSH
71485: LD_INT 100
71487: PUSH
71488: LD_INT 50
71490: PUSH
71491: LD_INT 75
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: LIST
71498: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71499: LD_VAR 0 6
71503: PPUSH
71504: CALL_OW 257
71508: PUSH
71509: LD_INT 15
71511: EQUAL
71512: IFFALSE 71533
// points := [ 10 , 5 , 3 ] ;
71514: LD_ADDR_VAR 0 9
71518: PUSH
71519: LD_INT 10
71521: PUSH
71522: LD_INT 5
71524: PUSH
71525: LD_INT 3
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71533: LD_VAR 0 6
71537: PPUSH
71538: CALL_OW 257
71542: PUSH
71543: LD_INT 14
71545: EQUAL
71546: IFFALSE 71567
// points := [ 10 , 0 , 0 ] ;
71548: LD_ADDR_VAR 0 9
71552: PUSH
71553: LD_INT 10
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: LD_INT 0
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: LIST
71566: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71567: LD_VAR 0 6
71571: PPUSH
71572: CALL_OW 257
71576: PUSH
71577: LD_INT 11
71579: EQUAL
71580: IFFALSE 71601
// points := [ 30 , 10 , 5 ] ;
71582: LD_ADDR_VAR 0 9
71586: PUSH
71587: LD_INT 30
71589: PUSH
71590: LD_INT 10
71592: PUSH
71593: LD_INT 5
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: LIST
71600: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71601: LD_VAR 0 1
71605: PPUSH
71606: LD_INT 5
71608: PPUSH
71609: CALL_OW 321
71613: PUSH
71614: LD_INT 2
71616: EQUAL
71617: IFFALSE 71634
// bpoints := bpoints * 1.8 ;
71619: LD_ADDR_VAR 0 10
71623: PUSH
71624: LD_VAR 0 10
71628: PUSH
71629: LD_REAL  1.80000000000000E+0000
71632: MUL
71633: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71634: LD_VAR 0 6
71638: PPUSH
71639: CALL_OW 257
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: LD_INT 3
71652: PUSH
71653: LD_INT 4
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: IN
71662: PUSH
71663: LD_VAR 0 1
71667: PPUSH
71668: LD_INT 51
71670: PPUSH
71671: CALL_OW 321
71675: PUSH
71676: LD_INT 2
71678: EQUAL
71679: AND
71680: IFFALSE 71697
// bpoints := bpoints * 1.2 ;
71682: LD_ADDR_VAR 0 10
71686: PUSH
71687: LD_VAR 0 10
71691: PUSH
71692: LD_REAL  1.20000000000000E+0000
71695: MUL
71696: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71697: LD_VAR 0 6
71701: PPUSH
71702: CALL_OW 257
71706: PUSH
71707: LD_INT 5
71709: PUSH
71710: LD_INT 7
71712: PUSH
71713: LD_INT 9
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: LIST
71720: IN
71721: PUSH
71722: LD_VAR 0 1
71726: PPUSH
71727: LD_INT 52
71729: PPUSH
71730: CALL_OW 321
71734: PUSH
71735: LD_INT 2
71737: EQUAL
71738: AND
71739: IFFALSE 71756
// bpoints := bpoints * 1.5 ;
71741: LD_ADDR_VAR 0 10
71745: PUSH
71746: LD_VAR 0 10
71750: PUSH
71751: LD_REAL  1.50000000000000E+0000
71754: MUL
71755: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71756: LD_VAR 0 1
71760: PPUSH
71761: LD_INT 66
71763: PPUSH
71764: CALL_OW 321
71768: PUSH
71769: LD_INT 2
71771: EQUAL
71772: IFFALSE 71789
// bpoints := bpoints * 1.1 ;
71774: LD_ADDR_VAR 0 10
71778: PUSH
71779: LD_VAR 0 10
71783: PUSH
71784: LD_REAL  1.10000000000000E+0000
71787: MUL
71788: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71789: LD_ADDR_VAR 0 10
71793: PUSH
71794: LD_VAR 0 10
71798: PUSH
71799: LD_VAR 0 6
71803: PPUSH
71804: LD_INT 1
71806: PPUSH
71807: CALL_OW 259
71811: PUSH
71812: LD_REAL  1.15000000000000E+0000
71815: MUL
71816: MUL
71817: ST_TO_ADDR
// end ; unit_vehicle :
71818: GO 72642
71820: LD_INT 2
71822: DOUBLE
71823: EQUAL
71824: IFTRUE 71828
71826: GO 72630
71828: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71829: LD_VAR 0 6
71833: PPUSH
71834: CALL_OW 264
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: LD_INT 42
71844: PUSH
71845: LD_INT 24
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: LIST
71852: IN
71853: IFFALSE 71874
// points := [ 25 , 5 , 3 ] ;
71855: LD_ADDR_VAR 0 9
71859: PUSH
71860: LD_INT 25
71862: PUSH
71863: LD_INT 5
71865: PUSH
71866: LD_INT 3
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: LIST
71873: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71874: LD_VAR 0 6
71878: PPUSH
71879: CALL_OW 264
71883: PUSH
71884: LD_INT 4
71886: PUSH
71887: LD_INT 43
71889: PUSH
71890: LD_INT 25
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: LIST
71897: IN
71898: IFFALSE 71919
// points := [ 40 , 15 , 5 ] ;
71900: LD_ADDR_VAR 0 9
71904: PUSH
71905: LD_INT 40
71907: PUSH
71908: LD_INT 15
71910: PUSH
71911: LD_INT 5
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: LIST
71918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71919: LD_VAR 0 6
71923: PPUSH
71924: CALL_OW 264
71928: PUSH
71929: LD_INT 3
71931: PUSH
71932: LD_INT 23
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: IN
71939: IFFALSE 71960
// points := [ 7 , 25 , 8 ] ;
71941: LD_ADDR_VAR 0 9
71945: PUSH
71946: LD_INT 7
71948: PUSH
71949: LD_INT 25
71951: PUSH
71952: LD_INT 8
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: LIST
71959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71960: LD_VAR 0 6
71964: PPUSH
71965: CALL_OW 264
71969: PUSH
71970: LD_INT 5
71972: PUSH
71973: LD_INT 27
71975: PUSH
71976: LD_INT 44
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: IN
71984: IFFALSE 72005
// points := [ 14 , 50 , 16 ] ;
71986: LD_ADDR_VAR 0 9
71990: PUSH
71991: LD_INT 14
71993: PUSH
71994: LD_INT 50
71996: PUSH
71997: LD_INT 16
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: LIST
72004: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72005: LD_VAR 0 6
72009: PPUSH
72010: CALL_OW 264
72014: PUSH
72015: LD_INT 6
72017: PUSH
72018: LD_INT 46
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: IN
72025: IFFALSE 72046
// points := [ 32 , 120 , 70 ] ;
72027: LD_ADDR_VAR 0 9
72031: PUSH
72032: LD_INT 32
72034: PUSH
72035: LD_INT 120
72037: PUSH
72038: LD_INT 70
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: LIST
72045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72046: LD_VAR 0 6
72050: PPUSH
72051: CALL_OW 264
72055: PUSH
72056: LD_INT 7
72058: PUSH
72059: LD_INT 28
72061: PUSH
72062: LD_INT 45
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: IN
72070: IFFALSE 72091
// points := [ 35 , 20 , 45 ] ;
72072: LD_ADDR_VAR 0 9
72076: PUSH
72077: LD_INT 35
72079: PUSH
72080: LD_INT 20
72082: PUSH
72083: LD_INT 45
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: LIST
72090: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72091: LD_VAR 0 6
72095: PPUSH
72096: CALL_OW 264
72100: PUSH
72101: LD_INT 47
72103: PUSH
72104: EMPTY
72105: LIST
72106: IN
72107: IFFALSE 72128
// points := [ 67 , 45 , 75 ] ;
72109: LD_ADDR_VAR 0 9
72113: PUSH
72114: LD_INT 67
72116: PUSH
72117: LD_INT 45
72119: PUSH
72120: LD_INT 75
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: LIST
72127: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72128: LD_VAR 0 6
72132: PPUSH
72133: CALL_OW 264
72137: PUSH
72138: LD_INT 26
72140: PUSH
72141: EMPTY
72142: LIST
72143: IN
72144: IFFALSE 72165
// points := [ 120 , 30 , 80 ] ;
72146: LD_ADDR_VAR 0 9
72150: PUSH
72151: LD_INT 120
72153: PUSH
72154: LD_INT 30
72156: PUSH
72157: LD_INT 80
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: LIST
72164: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72165: LD_VAR 0 6
72169: PPUSH
72170: CALL_OW 264
72174: PUSH
72175: LD_INT 22
72177: PUSH
72178: EMPTY
72179: LIST
72180: IN
72181: IFFALSE 72202
// points := [ 40 , 1 , 1 ] ;
72183: LD_ADDR_VAR 0 9
72187: PUSH
72188: LD_INT 40
72190: PUSH
72191: LD_INT 1
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: LIST
72201: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72202: LD_VAR 0 6
72206: PPUSH
72207: CALL_OW 264
72211: PUSH
72212: LD_INT 29
72214: PUSH
72215: EMPTY
72216: LIST
72217: IN
72218: IFFALSE 72239
// points := [ 70 , 200 , 400 ] ;
72220: LD_ADDR_VAR 0 9
72224: PUSH
72225: LD_INT 70
72227: PUSH
72228: LD_INT 200
72230: PUSH
72231: LD_INT 400
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: LIST
72238: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72239: LD_VAR 0 6
72243: PPUSH
72244: CALL_OW 264
72248: PUSH
72249: LD_INT 14
72251: PUSH
72252: LD_INT 53
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: IN
72259: IFFALSE 72280
// points := [ 40 , 10 , 20 ] ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_INT 40
72268: PUSH
72269: LD_INT 10
72271: PUSH
72272: LD_INT 20
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: LIST
72279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72280: LD_VAR 0 6
72284: PPUSH
72285: CALL_OW 264
72289: PUSH
72290: LD_INT 9
72292: PUSH
72293: EMPTY
72294: LIST
72295: IN
72296: IFFALSE 72317
// points := [ 5 , 70 , 20 ] ;
72298: LD_ADDR_VAR 0 9
72302: PUSH
72303: LD_INT 5
72305: PUSH
72306: LD_INT 70
72308: PUSH
72309: LD_INT 20
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: LIST
72316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72317: LD_VAR 0 6
72321: PPUSH
72322: CALL_OW 264
72326: PUSH
72327: LD_INT 10
72329: PUSH
72330: EMPTY
72331: LIST
72332: IN
72333: IFFALSE 72354
// points := [ 35 , 110 , 70 ] ;
72335: LD_ADDR_VAR 0 9
72339: PUSH
72340: LD_INT 35
72342: PUSH
72343: LD_INT 110
72345: PUSH
72346: LD_INT 70
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: LIST
72353: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72354: LD_VAR 0 6
72358: PPUSH
72359: CALL_OW 265
72363: PUSH
72364: LD_INT 25
72366: EQUAL
72367: IFFALSE 72388
// points := [ 80 , 65 , 100 ] ;
72369: LD_ADDR_VAR 0 9
72373: PUSH
72374: LD_INT 80
72376: PUSH
72377: LD_INT 65
72379: PUSH
72380: LD_INT 100
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: LIST
72387: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72388: LD_VAR 0 6
72392: PPUSH
72393: CALL_OW 263
72397: PUSH
72398: LD_INT 1
72400: EQUAL
72401: IFFALSE 72436
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72403: LD_ADDR_VAR 0 10
72407: PUSH
72408: LD_VAR 0 10
72412: PUSH
72413: LD_VAR 0 6
72417: PPUSH
72418: CALL_OW 311
72422: PPUSH
72423: LD_INT 3
72425: PPUSH
72426: CALL_OW 259
72430: PUSH
72431: LD_INT 4
72433: MUL
72434: MUL
72435: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72436: LD_VAR 0 6
72440: PPUSH
72441: CALL_OW 263
72445: PUSH
72446: LD_INT 2
72448: EQUAL
72449: IFFALSE 72500
// begin j := IsControledBy ( i ) ;
72451: LD_ADDR_VAR 0 7
72455: PUSH
72456: LD_VAR 0 6
72460: PPUSH
72461: CALL_OW 312
72465: ST_TO_ADDR
// if j then
72466: LD_VAR 0 7
72470: IFFALSE 72500
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72472: LD_ADDR_VAR 0 10
72476: PUSH
72477: LD_VAR 0 10
72481: PUSH
72482: LD_VAR 0 7
72486: PPUSH
72487: LD_INT 3
72489: PPUSH
72490: CALL_OW 259
72494: PUSH
72495: LD_INT 3
72497: MUL
72498: MUL
72499: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72500: LD_VAR 0 6
72504: PPUSH
72505: CALL_OW 264
72509: PUSH
72510: LD_INT 5
72512: PUSH
72513: LD_INT 6
72515: PUSH
72516: LD_INT 46
72518: PUSH
72519: LD_INT 44
72521: PUSH
72522: LD_INT 47
72524: PUSH
72525: LD_INT 45
72527: PUSH
72528: LD_INT 28
72530: PUSH
72531: LD_INT 7
72533: PUSH
72534: LD_INT 27
72536: PUSH
72537: LD_INT 29
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: IN
72552: PUSH
72553: LD_VAR 0 1
72557: PPUSH
72558: LD_INT 52
72560: PPUSH
72561: CALL_OW 321
72565: PUSH
72566: LD_INT 2
72568: EQUAL
72569: AND
72570: IFFALSE 72587
// bpoints := bpoints * 1.2 ;
72572: LD_ADDR_VAR 0 10
72576: PUSH
72577: LD_VAR 0 10
72581: PUSH
72582: LD_REAL  1.20000000000000E+0000
72585: MUL
72586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72587: LD_VAR 0 6
72591: PPUSH
72592: CALL_OW 264
72596: PUSH
72597: LD_INT 6
72599: PUSH
72600: LD_INT 46
72602: PUSH
72603: LD_INT 47
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: LIST
72610: IN
72611: IFFALSE 72628
// bpoints := bpoints * 1.2 ;
72613: LD_ADDR_VAR 0 10
72617: PUSH
72618: LD_VAR 0 10
72622: PUSH
72623: LD_REAL  1.20000000000000E+0000
72626: MUL
72627: ST_TO_ADDR
// end ; unit_building :
72628: GO 72642
72630: LD_INT 3
72632: DOUBLE
72633: EQUAL
72634: IFTRUE 72638
72636: GO 72641
72638: POP
// ; end ;
72639: GO 72642
72641: POP
// for j = 1 to 3 do
72642: LD_ADDR_VAR 0 7
72646: PUSH
72647: DOUBLE
72648: LD_INT 1
72650: DEC
72651: ST_TO_ADDR
72652: LD_INT 3
72654: PUSH
72655: FOR_TO
72656: IFFALSE 72709
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72658: LD_ADDR_VAR 0 5
72662: PUSH
72663: LD_VAR 0 5
72667: PPUSH
72668: LD_VAR 0 7
72672: PPUSH
72673: LD_VAR 0 5
72677: PUSH
72678: LD_VAR 0 7
72682: ARRAY
72683: PUSH
72684: LD_VAR 0 9
72688: PUSH
72689: LD_VAR 0 7
72693: ARRAY
72694: PUSH
72695: LD_VAR 0 10
72699: MUL
72700: PLUS
72701: PPUSH
72702: CALL_OW 1
72706: ST_TO_ADDR
72707: GO 72655
72709: POP
72710: POP
// end ;
72711: GO 71194
72713: POP
72714: POP
// result := Replace ( result , 4 , tmp ) ;
72715: LD_ADDR_VAR 0 5
72719: PUSH
72720: LD_VAR 0 5
72724: PPUSH
72725: LD_INT 4
72727: PPUSH
72728: LD_VAR 0 8
72732: PPUSH
72733: CALL_OW 1
72737: ST_TO_ADDR
// end ;
72738: LD_VAR 0 5
72742: RET
// export function DangerAtRange ( unit , range ) ; begin
72743: LD_INT 0
72745: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_VAR 0 1
72755: PPUSH
72756: CALL_OW 255
72760: PPUSH
72761: LD_VAR 0 1
72765: PPUSH
72766: CALL_OW 250
72770: PPUSH
72771: LD_VAR 0 1
72775: PPUSH
72776: CALL_OW 251
72780: PPUSH
72781: LD_VAR 0 2
72785: PPUSH
72786: CALL 71046 0 4
72790: ST_TO_ADDR
// end ;
72791: LD_VAR 0 3
72795: RET
// export function DangerInArea ( side , area ) ; begin
72796: LD_INT 0
72798: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72799: LD_ADDR_VAR 0 3
72803: PUSH
72804: LD_VAR 0 2
72808: PPUSH
72809: LD_INT 81
72811: PUSH
72812: LD_VAR 0 1
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PPUSH
72821: CALL_OW 70
72825: ST_TO_ADDR
// end ;
72826: LD_VAR 0 3
72830: RET
// export function IsExtension ( b ) ; begin
72831: LD_INT 0
72833: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72834: LD_ADDR_VAR 0 2
72838: PUSH
72839: LD_VAR 0 1
72843: PUSH
72844: LD_INT 23
72846: PUSH
72847: LD_INT 20
72849: PUSH
72850: LD_INT 22
72852: PUSH
72853: LD_INT 17
72855: PUSH
72856: LD_INT 24
72858: PUSH
72859: LD_INT 21
72861: PUSH
72862: LD_INT 19
72864: PUSH
72865: LD_INT 16
72867: PUSH
72868: LD_INT 25
72870: PUSH
72871: LD_INT 18
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: IN
72886: ST_TO_ADDR
// end ;
72887: LD_VAR 0 2
72891: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72892: LD_INT 0
72894: PPUSH
72895: PPUSH
72896: PPUSH
// result := [ ] ;
72897: LD_ADDR_VAR 0 3
72901: PUSH
72902: EMPTY
72903: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72904: LD_ADDR_VAR 0 4
72908: PUSH
72909: LD_VAR 0 2
72913: PPUSH
72914: LD_INT 21
72916: PUSH
72917: LD_INT 3
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PPUSH
72924: CALL_OW 70
72928: ST_TO_ADDR
// if not tmp then
72929: LD_VAR 0 4
72933: NOT
72934: IFFALSE 72938
// exit ;
72936: GO 72996
// for i in tmp do
72938: LD_ADDR_VAR 0 5
72942: PUSH
72943: LD_VAR 0 4
72947: PUSH
72948: FOR_IN
72949: IFFALSE 72984
// if GetBase ( i ) <> base then
72951: LD_VAR 0 5
72955: PPUSH
72956: CALL_OW 274
72960: PUSH
72961: LD_VAR 0 1
72965: NONEQUAL
72966: IFFALSE 72982
// ComLinkToBase ( base , i ) ;
72968: LD_VAR 0 1
72972: PPUSH
72973: LD_VAR 0 5
72977: PPUSH
72978: CALL_OW 169
72982: GO 72948
72984: POP
72985: POP
// result := tmp ;
72986: LD_ADDR_VAR 0 3
72990: PUSH
72991: LD_VAR 0 4
72995: ST_TO_ADDR
// end ;
72996: LD_VAR 0 3
73000: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73001: LD_INT 0
73003: PPUSH
73004: PPUSH
// if BuildingStatus ( b ) = bs_build then
73005: LD_VAR 0 2
73009: PPUSH
73010: CALL_OW 461
73014: PUSH
73015: LD_INT 1
73017: EQUAL
73018: IFFALSE 73078
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73020: LD_VAR 0 1
73024: PPUSH
73025: LD_STRING h
73027: PUSH
73028: LD_VAR 0 2
73032: PPUSH
73033: CALL_OW 250
73037: PUSH
73038: LD_VAR 0 2
73042: PPUSH
73043: CALL_OW 251
73047: PUSH
73048: LD_VAR 0 2
73052: PUSH
73053: LD_INT 0
73055: PUSH
73056: LD_INT 0
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: PUSH
73071: EMPTY
73072: LIST
73073: PPUSH
73074: CALL_OW 446
// end ;
73078: LD_VAR 0 3
73082: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73083: LD_INT 0
73085: PPUSH
73086: PPUSH
73087: PPUSH
73088: PPUSH
73089: PPUSH
73090: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73091: LD_VAR 0 1
73095: NOT
73096: PUSH
73097: LD_VAR 0 1
73101: PPUSH
73102: CALL_OW 263
73106: PUSH
73107: LD_INT 2
73109: EQUAL
73110: NOT
73111: OR
73112: IFFALSE 73116
// exit ;
73114: GO 73432
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73116: LD_ADDR_VAR 0 6
73120: PUSH
73121: LD_INT 22
73123: PUSH
73124: LD_VAR 0 1
73128: PPUSH
73129: CALL_OW 255
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 2
73140: PUSH
73141: LD_INT 30
73143: PUSH
73144: LD_INT 36
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 34
73153: PUSH
73154: LD_INT 31
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: LIST
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PPUSH
73170: CALL_OW 69
73174: ST_TO_ADDR
// if not tmp then
73175: LD_VAR 0 6
73179: NOT
73180: IFFALSE 73184
// exit ;
73182: GO 73432
// result := [ ] ;
73184: LD_ADDR_VAR 0 2
73188: PUSH
73189: EMPTY
73190: ST_TO_ADDR
// for i in tmp do
73191: LD_ADDR_VAR 0 3
73195: PUSH
73196: LD_VAR 0 6
73200: PUSH
73201: FOR_IN
73202: IFFALSE 73273
// begin t := UnitsInside ( i ) ;
73204: LD_ADDR_VAR 0 4
73208: PUSH
73209: LD_VAR 0 3
73213: PPUSH
73214: CALL_OW 313
73218: ST_TO_ADDR
// if t then
73219: LD_VAR 0 4
73223: IFFALSE 73271
// for j in t do
73225: LD_ADDR_VAR 0 7
73229: PUSH
73230: LD_VAR 0 4
73234: PUSH
73235: FOR_IN
73236: IFFALSE 73269
// result := Insert ( result , result + 1 , j ) ;
73238: LD_ADDR_VAR 0 2
73242: PUSH
73243: LD_VAR 0 2
73247: PPUSH
73248: LD_VAR 0 2
73252: PUSH
73253: LD_INT 1
73255: PLUS
73256: PPUSH
73257: LD_VAR 0 7
73261: PPUSH
73262: CALL_OW 2
73266: ST_TO_ADDR
73267: GO 73235
73269: POP
73270: POP
// end ;
73271: GO 73201
73273: POP
73274: POP
// if not result then
73275: LD_VAR 0 2
73279: NOT
73280: IFFALSE 73284
// exit ;
73282: GO 73432
// mech := result [ 1 ] ;
73284: LD_ADDR_VAR 0 5
73288: PUSH
73289: LD_VAR 0 2
73293: PUSH
73294: LD_INT 1
73296: ARRAY
73297: ST_TO_ADDR
// if result > 1 then
73298: LD_VAR 0 2
73302: PUSH
73303: LD_INT 1
73305: GREATER
73306: IFFALSE 73418
// for i = 2 to result do
73308: LD_ADDR_VAR 0 3
73312: PUSH
73313: DOUBLE
73314: LD_INT 2
73316: DEC
73317: ST_TO_ADDR
73318: LD_VAR 0 2
73322: PUSH
73323: FOR_TO
73324: IFFALSE 73416
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73326: LD_ADDR_VAR 0 4
73330: PUSH
73331: LD_VAR 0 2
73335: PUSH
73336: LD_VAR 0 3
73340: ARRAY
73341: PPUSH
73342: LD_INT 3
73344: PPUSH
73345: CALL_OW 259
73349: PUSH
73350: LD_VAR 0 2
73354: PUSH
73355: LD_VAR 0 3
73359: ARRAY
73360: PPUSH
73361: CALL_OW 432
73365: MINUS
73366: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73367: LD_VAR 0 4
73371: PUSH
73372: LD_VAR 0 5
73376: PPUSH
73377: LD_INT 3
73379: PPUSH
73380: CALL_OW 259
73384: PUSH
73385: LD_VAR 0 5
73389: PPUSH
73390: CALL_OW 432
73394: MINUS
73395: GREATEREQUAL
73396: IFFALSE 73414
// mech := result [ i ] ;
73398: LD_ADDR_VAR 0 5
73402: PUSH
73403: LD_VAR 0 2
73407: PUSH
73408: LD_VAR 0 3
73412: ARRAY
73413: ST_TO_ADDR
// end ;
73414: GO 73323
73416: POP
73417: POP
// ComLinkTo ( vehicle , mech ) ;
73418: LD_VAR 0 1
73422: PPUSH
73423: LD_VAR 0 5
73427: PPUSH
73428: CALL_OW 135
// end ;
73432: LD_VAR 0 2
73436: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73437: LD_INT 0
73439: PPUSH
73440: PPUSH
73441: PPUSH
73442: PPUSH
73443: PPUSH
73444: PPUSH
73445: PPUSH
73446: PPUSH
73447: PPUSH
73448: PPUSH
73449: PPUSH
73450: PPUSH
73451: PPUSH
// result := [ ] ;
73452: LD_ADDR_VAR 0 7
73456: PUSH
73457: EMPTY
73458: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73459: LD_VAR 0 1
73463: PPUSH
73464: CALL_OW 266
73468: PUSH
73469: LD_INT 0
73471: PUSH
73472: LD_INT 1
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: IN
73479: NOT
73480: IFFALSE 73484
// exit ;
73482: GO 75115
// if name then
73484: LD_VAR 0 3
73488: IFFALSE 73504
// SetBName ( base_dep , name ) ;
73490: LD_VAR 0 1
73494: PPUSH
73495: LD_VAR 0 3
73499: PPUSH
73500: CALL_OW 500
// base := GetBase ( base_dep ) ;
73504: LD_ADDR_VAR 0 15
73508: PUSH
73509: LD_VAR 0 1
73513: PPUSH
73514: CALL_OW 274
73518: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73519: LD_ADDR_VAR 0 16
73523: PUSH
73524: LD_VAR 0 1
73528: PPUSH
73529: CALL_OW 255
73533: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73534: LD_ADDR_VAR 0 17
73538: PUSH
73539: LD_VAR 0 1
73543: PPUSH
73544: CALL_OW 248
73548: ST_TO_ADDR
// if sources then
73549: LD_VAR 0 5
73553: IFFALSE 73600
// for i = 1 to 3 do
73555: LD_ADDR_VAR 0 8
73559: PUSH
73560: DOUBLE
73561: LD_INT 1
73563: DEC
73564: ST_TO_ADDR
73565: LD_INT 3
73567: PUSH
73568: FOR_TO
73569: IFFALSE 73598
// AddResourceType ( base , i , sources [ i ] ) ;
73571: LD_VAR 0 15
73575: PPUSH
73576: LD_VAR 0 8
73580: PPUSH
73581: LD_VAR 0 5
73585: PUSH
73586: LD_VAR 0 8
73590: ARRAY
73591: PPUSH
73592: CALL_OW 276
73596: GO 73568
73598: POP
73599: POP
// buildings := GetBaseBuildings ( base , area ) ;
73600: LD_ADDR_VAR 0 18
73604: PUSH
73605: LD_VAR 0 15
73609: PPUSH
73610: LD_VAR 0 2
73614: PPUSH
73615: CALL 72892 0 2
73619: ST_TO_ADDR
// InitHc ;
73620: CALL_OW 19
// InitUc ;
73624: CALL_OW 18
// uc_side := side ;
73628: LD_ADDR_OWVAR 20
73632: PUSH
73633: LD_VAR 0 16
73637: ST_TO_ADDR
// uc_nation := nation ;
73638: LD_ADDR_OWVAR 21
73642: PUSH
73643: LD_VAR 0 17
73647: ST_TO_ADDR
// if buildings then
73648: LD_VAR 0 18
73652: IFFALSE 74974
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73654: LD_ADDR_VAR 0 19
73658: PUSH
73659: LD_VAR 0 18
73663: PPUSH
73664: LD_INT 2
73666: PUSH
73667: LD_INT 30
73669: PUSH
73670: LD_INT 29
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 30
73679: PUSH
73680: LD_INT 30
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: LIST
73691: PPUSH
73692: CALL_OW 72
73696: ST_TO_ADDR
// if tmp then
73697: LD_VAR 0 19
73701: IFFALSE 73749
// for i in tmp do
73703: LD_ADDR_VAR 0 8
73707: PUSH
73708: LD_VAR 0 19
73712: PUSH
73713: FOR_IN
73714: IFFALSE 73747
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73716: LD_VAR 0 8
73720: PPUSH
73721: CALL_OW 250
73725: PPUSH
73726: LD_VAR 0 8
73730: PPUSH
73731: CALL_OW 251
73735: PPUSH
73736: LD_VAR 0 16
73740: PPUSH
73741: CALL_OW 441
73745: GO 73713
73747: POP
73748: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73749: LD_VAR 0 18
73753: PPUSH
73754: LD_INT 2
73756: PUSH
73757: LD_INT 30
73759: PUSH
73760: LD_INT 32
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: PUSH
73767: LD_INT 30
73769: PUSH
73770: LD_INT 33
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: LIST
73781: PPUSH
73782: CALL_OW 72
73786: IFFALSE 73874
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73788: LD_ADDR_VAR 0 8
73792: PUSH
73793: LD_VAR 0 18
73797: PPUSH
73798: LD_INT 2
73800: PUSH
73801: LD_INT 30
73803: PUSH
73804: LD_INT 32
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 30
73813: PUSH
73814: LD_INT 33
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: LIST
73825: PPUSH
73826: CALL_OW 72
73830: PUSH
73831: FOR_IN
73832: IFFALSE 73872
// begin if not GetBWeapon ( i ) then
73834: LD_VAR 0 8
73838: PPUSH
73839: CALL_OW 269
73843: NOT
73844: IFFALSE 73870
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73846: LD_VAR 0 8
73850: PPUSH
73851: LD_VAR 0 8
73855: PPUSH
73856: LD_VAR 0 2
73860: PPUSH
73861: CALL 75120 0 2
73865: PPUSH
73866: CALL_OW 431
// end ;
73870: GO 73831
73872: POP
73873: POP
// end ; for i = 1 to personel do
73874: LD_ADDR_VAR 0 8
73878: PUSH
73879: DOUBLE
73880: LD_INT 1
73882: DEC
73883: ST_TO_ADDR
73884: LD_VAR 0 6
73888: PUSH
73889: FOR_TO
73890: IFFALSE 74954
// begin if i > 4 then
73892: LD_VAR 0 8
73896: PUSH
73897: LD_INT 4
73899: GREATER
73900: IFFALSE 73904
// break ;
73902: GO 74954
// case i of 1 :
73904: LD_VAR 0 8
73908: PUSH
73909: LD_INT 1
73911: DOUBLE
73912: EQUAL
73913: IFTRUE 73917
73915: GO 73997
73917: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73918: LD_ADDR_VAR 0 12
73922: PUSH
73923: LD_VAR 0 18
73927: PPUSH
73928: LD_INT 22
73930: PUSH
73931: LD_VAR 0 16
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 58
73942: PUSH
73943: EMPTY
73944: LIST
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: LD_INT 30
73951: PUSH
73952: LD_INT 32
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 30
73961: PUSH
73962: LD_INT 4
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 30
73971: PUSH
73972: LD_INT 5
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: LIST
73989: PPUSH
73990: CALL_OW 72
73994: ST_TO_ADDR
73995: GO 74219
73997: LD_INT 2
73999: DOUBLE
74000: EQUAL
74001: IFTRUE 74005
74003: GO 74067
74005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74006: LD_ADDR_VAR 0 12
74010: PUSH
74011: LD_VAR 0 18
74015: PPUSH
74016: LD_INT 22
74018: PUSH
74019: LD_VAR 0 16
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: PUSH
74031: LD_INT 30
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 30
74043: PUSH
74044: LD_INT 1
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: LIST
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PPUSH
74060: CALL_OW 72
74064: ST_TO_ADDR
74065: GO 74219
74067: LD_INT 3
74069: DOUBLE
74070: EQUAL
74071: IFTRUE 74075
74073: GO 74137
74075: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74076: LD_ADDR_VAR 0 12
74080: PUSH
74081: LD_VAR 0 18
74085: PPUSH
74086: LD_INT 22
74088: PUSH
74089: LD_VAR 0 16
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 2
74100: PUSH
74101: LD_INT 30
74103: PUSH
74104: LD_INT 2
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 30
74113: PUSH
74114: LD_INT 3
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: LIST
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PPUSH
74130: CALL_OW 72
74134: ST_TO_ADDR
74135: GO 74219
74137: LD_INT 4
74139: DOUBLE
74140: EQUAL
74141: IFTRUE 74145
74143: GO 74218
74145: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74146: LD_ADDR_VAR 0 12
74150: PUSH
74151: LD_VAR 0 18
74155: PPUSH
74156: LD_INT 22
74158: PUSH
74159: LD_VAR 0 16
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 2
74170: PUSH
74171: LD_INT 30
74173: PUSH
74174: LD_INT 6
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 30
74183: PUSH
74184: LD_INT 7
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 30
74193: PUSH
74194: LD_INT 8
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PPUSH
74211: CALL_OW 72
74215: ST_TO_ADDR
74216: GO 74219
74218: POP
// if i = 1 then
74219: LD_VAR 0 8
74223: PUSH
74224: LD_INT 1
74226: EQUAL
74227: IFFALSE 74338
// begin tmp := [ ] ;
74229: LD_ADDR_VAR 0 19
74233: PUSH
74234: EMPTY
74235: ST_TO_ADDR
// for j in f do
74236: LD_ADDR_VAR 0 9
74240: PUSH
74241: LD_VAR 0 12
74245: PUSH
74246: FOR_IN
74247: IFFALSE 74320
// if GetBType ( j ) = b_bunker then
74249: LD_VAR 0 9
74253: PPUSH
74254: CALL_OW 266
74258: PUSH
74259: LD_INT 32
74261: EQUAL
74262: IFFALSE 74289
// tmp := Insert ( tmp , 1 , j ) else
74264: LD_ADDR_VAR 0 19
74268: PUSH
74269: LD_VAR 0 19
74273: PPUSH
74274: LD_INT 1
74276: PPUSH
74277: LD_VAR 0 9
74281: PPUSH
74282: CALL_OW 2
74286: ST_TO_ADDR
74287: GO 74318
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74289: LD_ADDR_VAR 0 19
74293: PUSH
74294: LD_VAR 0 19
74298: PPUSH
74299: LD_VAR 0 19
74303: PUSH
74304: LD_INT 1
74306: PLUS
74307: PPUSH
74308: LD_VAR 0 9
74312: PPUSH
74313: CALL_OW 2
74317: ST_TO_ADDR
74318: GO 74246
74320: POP
74321: POP
// if tmp then
74322: LD_VAR 0 19
74326: IFFALSE 74338
// f := tmp ;
74328: LD_ADDR_VAR 0 12
74332: PUSH
74333: LD_VAR 0 19
74337: ST_TO_ADDR
// end ; x := personel [ i ] ;
74338: LD_ADDR_VAR 0 13
74342: PUSH
74343: LD_VAR 0 6
74347: PUSH
74348: LD_VAR 0 8
74352: ARRAY
74353: ST_TO_ADDR
// if x = - 1 then
74354: LD_VAR 0 13
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: EQUAL
74363: IFFALSE 74572
// begin for j in f do
74365: LD_ADDR_VAR 0 9
74369: PUSH
74370: LD_VAR 0 12
74374: PUSH
74375: FOR_IN
74376: IFFALSE 74568
// repeat InitHc ;
74378: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74382: LD_VAR 0 9
74386: PPUSH
74387: CALL_OW 266
74391: PUSH
74392: LD_INT 5
74394: EQUAL
74395: IFFALSE 74465
// begin if UnitsInside ( j ) < 3 then
74397: LD_VAR 0 9
74401: PPUSH
74402: CALL_OW 313
74406: PUSH
74407: LD_INT 3
74409: LESS
74410: IFFALSE 74446
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74412: LD_INT 0
74414: PPUSH
74415: LD_INT 5
74417: PUSH
74418: LD_INT 8
74420: PUSH
74421: LD_INT 9
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: LIST
74428: PUSH
74429: LD_VAR 0 17
74433: ARRAY
74434: PPUSH
74435: LD_VAR 0 4
74439: PPUSH
74440: CALL_OW 380
74444: GO 74463
// PrepareHuman ( false , i , skill ) ;
74446: LD_INT 0
74448: PPUSH
74449: LD_VAR 0 8
74453: PPUSH
74454: LD_VAR 0 4
74458: PPUSH
74459: CALL_OW 380
// end else
74463: GO 74482
// PrepareHuman ( false , i , skill ) ;
74465: LD_INT 0
74467: PPUSH
74468: LD_VAR 0 8
74472: PPUSH
74473: LD_VAR 0 4
74477: PPUSH
74478: CALL_OW 380
// un := CreateHuman ;
74482: LD_ADDR_VAR 0 14
74486: PUSH
74487: CALL_OW 44
74491: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74492: LD_ADDR_VAR 0 7
74496: PUSH
74497: LD_VAR 0 7
74501: PPUSH
74502: LD_INT 1
74504: PPUSH
74505: LD_VAR 0 14
74509: PPUSH
74510: CALL_OW 2
74514: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74515: LD_VAR 0 14
74519: PPUSH
74520: LD_VAR 0 9
74524: PPUSH
74525: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74529: LD_VAR 0 9
74533: PPUSH
74534: CALL_OW 313
74538: PUSH
74539: LD_INT 6
74541: EQUAL
74542: PUSH
74543: LD_VAR 0 9
74547: PPUSH
74548: CALL_OW 266
74552: PUSH
74553: LD_INT 32
74555: PUSH
74556: LD_INT 31
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: IN
74563: OR
74564: IFFALSE 74378
74566: GO 74375
74568: POP
74569: POP
// end else
74570: GO 74952
// for j = 1 to x do
74572: LD_ADDR_VAR 0 9
74576: PUSH
74577: DOUBLE
74578: LD_INT 1
74580: DEC
74581: ST_TO_ADDR
74582: LD_VAR 0 13
74586: PUSH
74587: FOR_TO
74588: IFFALSE 74950
// begin InitHc ;
74590: CALL_OW 19
// if not f then
74594: LD_VAR 0 12
74598: NOT
74599: IFFALSE 74688
// begin PrepareHuman ( false , i , skill ) ;
74601: LD_INT 0
74603: PPUSH
74604: LD_VAR 0 8
74608: PPUSH
74609: LD_VAR 0 4
74613: PPUSH
74614: CALL_OW 380
// un := CreateHuman ;
74618: LD_ADDR_VAR 0 14
74622: PUSH
74623: CALL_OW 44
74627: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74628: LD_ADDR_VAR 0 7
74632: PUSH
74633: LD_VAR 0 7
74637: PPUSH
74638: LD_INT 1
74640: PPUSH
74641: LD_VAR 0 14
74645: PPUSH
74646: CALL_OW 2
74650: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74651: LD_VAR 0 14
74655: PPUSH
74656: LD_VAR 0 1
74660: PPUSH
74661: CALL_OW 250
74665: PPUSH
74666: LD_VAR 0 1
74670: PPUSH
74671: CALL_OW 251
74675: PPUSH
74676: LD_INT 10
74678: PPUSH
74679: LD_INT 0
74681: PPUSH
74682: CALL_OW 50
// continue ;
74686: GO 74587
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74688: LD_VAR 0 12
74692: PUSH
74693: LD_INT 1
74695: ARRAY
74696: PPUSH
74697: CALL_OW 313
74701: PUSH
74702: LD_VAR 0 12
74706: PUSH
74707: LD_INT 1
74709: ARRAY
74710: PPUSH
74711: CALL_OW 266
74715: PUSH
74716: LD_INT 32
74718: PUSH
74719: LD_INT 31
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: IN
74726: AND
74727: PUSH
74728: LD_VAR 0 12
74732: PUSH
74733: LD_INT 1
74735: ARRAY
74736: PPUSH
74737: CALL_OW 313
74741: PUSH
74742: LD_INT 6
74744: EQUAL
74745: OR
74746: IFFALSE 74766
// f := Delete ( f , 1 ) ;
74748: LD_ADDR_VAR 0 12
74752: PUSH
74753: LD_VAR 0 12
74757: PPUSH
74758: LD_INT 1
74760: PPUSH
74761: CALL_OW 3
74765: ST_TO_ADDR
// if not f then
74766: LD_VAR 0 12
74770: NOT
74771: IFFALSE 74789
// begin x := x + 2 ;
74773: LD_ADDR_VAR 0 13
74777: PUSH
74778: LD_VAR 0 13
74782: PUSH
74783: LD_INT 2
74785: PLUS
74786: ST_TO_ADDR
// continue ;
74787: GO 74587
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74789: LD_VAR 0 12
74793: PUSH
74794: LD_INT 1
74796: ARRAY
74797: PPUSH
74798: CALL_OW 266
74802: PUSH
74803: LD_INT 5
74805: EQUAL
74806: IFFALSE 74880
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74808: LD_VAR 0 12
74812: PUSH
74813: LD_INT 1
74815: ARRAY
74816: PPUSH
74817: CALL_OW 313
74821: PUSH
74822: LD_INT 3
74824: LESS
74825: IFFALSE 74861
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74827: LD_INT 0
74829: PPUSH
74830: LD_INT 5
74832: PUSH
74833: LD_INT 8
74835: PUSH
74836: LD_INT 9
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: LIST
74843: PUSH
74844: LD_VAR 0 17
74848: ARRAY
74849: PPUSH
74850: LD_VAR 0 4
74854: PPUSH
74855: CALL_OW 380
74859: GO 74878
// PrepareHuman ( false , i , skill ) ;
74861: LD_INT 0
74863: PPUSH
74864: LD_VAR 0 8
74868: PPUSH
74869: LD_VAR 0 4
74873: PPUSH
74874: CALL_OW 380
// end else
74878: GO 74897
// PrepareHuman ( false , i , skill ) ;
74880: LD_INT 0
74882: PPUSH
74883: LD_VAR 0 8
74887: PPUSH
74888: LD_VAR 0 4
74892: PPUSH
74893: CALL_OW 380
// un := CreateHuman ;
74897: LD_ADDR_VAR 0 14
74901: PUSH
74902: CALL_OW 44
74906: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74907: LD_ADDR_VAR 0 7
74911: PUSH
74912: LD_VAR 0 7
74916: PPUSH
74917: LD_INT 1
74919: PPUSH
74920: LD_VAR 0 14
74924: PPUSH
74925: CALL_OW 2
74929: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74930: LD_VAR 0 14
74934: PPUSH
74935: LD_VAR 0 12
74939: PUSH
74940: LD_INT 1
74942: ARRAY
74943: PPUSH
74944: CALL_OW 52
// end ;
74948: GO 74587
74950: POP
74951: POP
// end ;
74952: GO 73889
74954: POP
74955: POP
// result := result ^ buildings ;
74956: LD_ADDR_VAR 0 7
74960: PUSH
74961: LD_VAR 0 7
74965: PUSH
74966: LD_VAR 0 18
74970: ADD
74971: ST_TO_ADDR
// end else
74972: GO 75115
// begin for i = 1 to personel do
74974: LD_ADDR_VAR 0 8
74978: PUSH
74979: DOUBLE
74980: LD_INT 1
74982: DEC
74983: ST_TO_ADDR
74984: LD_VAR 0 6
74988: PUSH
74989: FOR_TO
74990: IFFALSE 75113
// begin if i > 4 then
74992: LD_VAR 0 8
74996: PUSH
74997: LD_INT 4
74999: GREATER
75000: IFFALSE 75004
// break ;
75002: GO 75113
// x := personel [ i ] ;
75004: LD_ADDR_VAR 0 13
75008: PUSH
75009: LD_VAR 0 6
75013: PUSH
75014: LD_VAR 0 8
75018: ARRAY
75019: ST_TO_ADDR
// if x = - 1 then
75020: LD_VAR 0 13
75024: PUSH
75025: LD_INT 1
75027: NEG
75028: EQUAL
75029: IFFALSE 75033
// continue ;
75031: GO 74989
// PrepareHuman ( false , i , skill ) ;
75033: LD_INT 0
75035: PPUSH
75036: LD_VAR 0 8
75040: PPUSH
75041: LD_VAR 0 4
75045: PPUSH
75046: CALL_OW 380
// un := CreateHuman ;
75050: LD_ADDR_VAR 0 14
75054: PUSH
75055: CALL_OW 44
75059: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75060: LD_VAR 0 14
75064: PPUSH
75065: LD_VAR 0 1
75069: PPUSH
75070: CALL_OW 250
75074: PPUSH
75075: LD_VAR 0 1
75079: PPUSH
75080: CALL_OW 251
75084: PPUSH
75085: LD_INT 10
75087: PPUSH
75088: LD_INT 0
75090: PPUSH
75091: CALL_OW 50
// result := result ^ un ;
75095: LD_ADDR_VAR 0 7
75099: PUSH
75100: LD_VAR 0 7
75104: PUSH
75105: LD_VAR 0 14
75109: ADD
75110: ST_TO_ADDR
// end ;
75111: GO 74989
75113: POP
75114: POP
// end ; end ;
75115: LD_VAR 0 7
75119: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75120: LD_INT 0
75122: PPUSH
75123: PPUSH
75124: PPUSH
75125: PPUSH
75126: PPUSH
75127: PPUSH
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
75136: PPUSH
75137: PPUSH
// result := false ;
75138: LD_ADDR_VAR 0 3
75142: PUSH
75143: LD_INT 0
75145: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75146: LD_VAR 0 1
75150: NOT
75151: PUSH
75152: LD_VAR 0 1
75156: PPUSH
75157: CALL_OW 266
75161: PUSH
75162: LD_INT 32
75164: PUSH
75165: LD_INT 33
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: IN
75172: NOT
75173: OR
75174: IFFALSE 75178
// exit ;
75176: GO 76314
// nat := GetNation ( tower ) ;
75178: LD_ADDR_VAR 0 12
75182: PUSH
75183: LD_VAR 0 1
75187: PPUSH
75188: CALL_OW 248
75192: ST_TO_ADDR
// side := GetSide ( tower ) ;
75193: LD_ADDR_VAR 0 16
75197: PUSH
75198: LD_VAR 0 1
75202: PPUSH
75203: CALL_OW 255
75207: ST_TO_ADDR
// x := GetX ( tower ) ;
75208: LD_ADDR_VAR 0 10
75212: PUSH
75213: LD_VAR 0 1
75217: PPUSH
75218: CALL_OW 250
75222: ST_TO_ADDR
// y := GetY ( tower ) ;
75223: LD_ADDR_VAR 0 11
75227: PUSH
75228: LD_VAR 0 1
75232: PPUSH
75233: CALL_OW 251
75237: ST_TO_ADDR
// if not x or not y then
75238: LD_VAR 0 10
75242: NOT
75243: PUSH
75244: LD_VAR 0 11
75248: NOT
75249: OR
75250: IFFALSE 75254
// exit ;
75252: GO 76314
// weapon := 0 ;
75254: LD_ADDR_VAR 0 18
75258: PUSH
75259: LD_INT 0
75261: ST_TO_ADDR
// fac_list := [ ] ;
75262: LD_ADDR_VAR 0 17
75266: PUSH
75267: EMPTY
75268: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75269: LD_ADDR_VAR 0 6
75273: PUSH
75274: LD_VAR 0 1
75278: PPUSH
75279: CALL_OW 274
75283: PPUSH
75284: LD_VAR 0 2
75288: PPUSH
75289: CALL 72892 0 2
75293: PPUSH
75294: LD_INT 30
75296: PUSH
75297: LD_INT 3
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PPUSH
75304: CALL_OW 72
75308: ST_TO_ADDR
// if not factories then
75309: LD_VAR 0 6
75313: NOT
75314: IFFALSE 75318
// exit ;
75316: GO 76314
// for i in factories do
75318: LD_ADDR_VAR 0 8
75322: PUSH
75323: LD_VAR 0 6
75327: PUSH
75328: FOR_IN
75329: IFFALSE 75354
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75331: LD_ADDR_VAR 0 17
75335: PUSH
75336: LD_VAR 0 17
75340: PUSH
75341: LD_VAR 0 8
75345: PPUSH
75346: CALL_OW 478
75350: UNION
75351: ST_TO_ADDR
75352: GO 75328
75354: POP
75355: POP
// if not fac_list then
75356: LD_VAR 0 17
75360: NOT
75361: IFFALSE 75365
// exit ;
75363: GO 76314
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75365: LD_ADDR_VAR 0 5
75369: PUSH
75370: LD_INT 4
75372: PUSH
75373: LD_INT 5
75375: PUSH
75376: LD_INT 9
75378: PUSH
75379: LD_INT 10
75381: PUSH
75382: LD_INT 6
75384: PUSH
75385: LD_INT 7
75387: PUSH
75388: LD_INT 11
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 27
75402: PUSH
75403: LD_INT 28
75405: PUSH
75406: LD_INT 26
75408: PUSH
75409: LD_INT 30
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 43
75420: PUSH
75421: LD_INT 44
75423: PUSH
75424: LD_INT 46
75426: PUSH
75427: LD_INT 45
75429: PUSH
75430: LD_INT 47
75432: PUSH
75433: LD_INT 49
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: LIST
75448: PUSH
75449: LD_VAR 0 12
75453: ARRAY
75454: ST_TO_ADDR
// for i in list do
75455: LD_ADDR_VAR 0 8
75459: PUSH
75460: LD_VAR 0 5
75464: PUSH
75465: FOR_IN
75466: IFFALSE 75499
// if not i in fac_list then
75468: LD_VAR 0 8
75472: PUSH
75473: LD_VAR 0 17
75477: IN
75478: NOT
75479: IFFALSE 75497
// list := list diff i ;
75481: LD_ADDR_VAR 0 5
75485: PUSH
75486: LD_VAR 0 5
75490: PUSH
75491: LD_VAR 0 8
75495: DIFF
75496: ST_TO_ADDR
75497: GO 75465
75499: POP
75500: POP
// if not list then
75501: LD_VAR 0 5
75505: NOT
75506: IFFALSE 75510
// exit ;
75508: GO 76314
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75510: LD_VAR 0 12
75514: PUSH
75515: LD_INT 3
75517: EQUAL
75518: PUSH
75519: LD_INT 49
75521: PUSH
75522: LD_VAR 0 5
75526: IN
75527: AND
75528: PUSH
75529: LD_INT 31
75531: PPUSH
75532: LD_VAR 0 16
75536: PPUSH
75537: CALL_OW 321
75541: PUSH
75542: LD_INT 2
75544: EQUAL
75545: AND
75546: IFFALSE 75606
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75548: LD_INT 22
75550: PUSH
75551: LD_VAR 0 16
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 35
75562: PUSH
75563: LD_INT 49
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 91
75572: PUSH
75573: LD_VAR 0 1
75577: PUSH
75578: LD_INT 10
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: LIST
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: LIST
75590: PPUSH
75591: CALL_OW 69
75595: NOT
75596: IFFALSE 75606
// weapon := ru_time_lapser ;
75598: LD_ADDR_VAR 0 18
75602: PUSH
75603: LD_INT 49
75605: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75606: LD_VAR 0 12
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: LD_INT 2
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: IN
75621: PUSH
75622: LD_INT 11
75624: PUSH
75625: LD_VAR 0 5
75629: IN
75630: PUSH
75631: LD_INT 30
75633: PUSH
75634: LD_VAR 0 5
75638: IN
75639: OR
75640: AND
75641: PUSH
75642: LD_INT 6
75644: PPUSH
75645: LD_VAR 0 16
75649: PPUSH
75650: CALL_OW 321
75654: PUSH
75655: LD_INT 2
75657: EQUAL
75658: AND
75659: IFFALSE 75824
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75661: LD_INT 22
75663: PUSH
75664: LD_VAR 0 16
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: LD_INT 35
75678: PUSH
75679: LD_INT 11
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 35
75688: PUSH
75689: LD_INT 30
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 91
75703: PUSH
75704: LD_VAR 0 1
75708: PUSH
75709: LD_INT 18
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: LIST
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: LIST
75721: PPUSH
75722: CALL_OW 69
75726: NOT
75727: PUSH
75728: LD_INT 22
75730: PUSH
75731: LD_VAR 0 16
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 2
75742: PUSH
75743: LD_INT 30
75745: PUSH
75746: LD_INT 32
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 30
75755: PUSH
75756: LD_INT 33
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 91
75770: PUSH
75771: LD_VAR 0 1
75775: PUSH
75776: LD_INT 12
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: LIST
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: LIST
75788: PUSH
75789: EMPTY
75790: LIST
75791: PPUSH
75792: CALL_OW 69
75796: PUSH
75797: LD_INT 2
75799: GREATER
75800: AND
75801: IFFALSE 75824
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75803: LD_ADDR_VAR 0 18
75807: PUSH
75808: LD_INT 11
75810: PUSH
75811: LD_INT 30
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_VAR 0 12
75822: ARRAY
75823: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75824: LD_VAR 0 18
75828: NOT
75829: PUSH
75830: LD_INT 40
75832: PPUSH
75833: LD_VAR 0 16
75837: PPUSH
75838: CALL_OW 321
75842: PUSH
75843: LD_INT 2
75845: EQUAL
75846: AND
75847: PUSH
75848: LD_INT 7
75850: PUSH
75851: LD_VAR 0 5
75855: IN
75856: PUSH
75857: LD_INT 28
75859: PUSH
75860: LD_VAR 0 5
75864: IN
75865: OR
75866: PUSH
75867: LD_INT 45
75869: PUSH
75870: LD_VAR 0 5
75874: IN
75875: OR
75876: AND
75877: IFFALSE 76131
// begin hex := GetHexInfo ( x , y ) ;
75879: LD_ADDR_VAR 0 4
75883: PUSH
75884: LD_VAR 0 10
75888: PPUSH
75889: LD_VAR 0 11
75893: PPUSH
75894: CALL_OW 546
75898: ST_TO_ADDR
// if hex [ 1 ] then
75899: LD_VAR 0 4
75903: PUSH
75904: LD_INT 1
75906: ARRAY
75907: IFFALSE 75911
// exit ;
75909: GO 76314
// height := hex [ 2 ] ;
75911: LD_ADDR_VAR 0 15
75915: PUSH
75916: LD_VAR 0 4
75920: PUSH
75921: LD_INT 2
75923: ARRAY
75924: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75925: LD_ADDR_VAR 0 14
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: LD_INT 2
75935: PUSH
75936: LD_INT 3
75938: PUSH
75939: LD_INT 5
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: ST_TO_ADDR
// for i in tmp do
75948: LD_ADDR_VAR 0 8
75952: PUSH
75953: LD_VAR 0 14
75957: PUSH
75958: FOR_IN
75959: IFFALSE 76129
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75961: LD_ADDR_VAR 0 9
75965: PUSH
75966: LD_VAR 0 10
75970: PPUSH
75971: LD_VAR 0 8
75975: PPUSH
75976: LD_INT 5
75978: PPUSH
75979: CALL_OW 272
75983: PUSH
75984: LD_VAR 0 11
75988: PPUSH
75989: LD_VAR 0 8
75993: PPUSH
75994: LD_INT 5
75996: PPUSH
75997: CALL_OW 273
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76006: LD_VAR 0 9
76010: PUSH
76011: LD_INT 1
76013: ARRAY
76014: PPUSH
76015: LD_VAR 0 9
76019: PUSH
76020: LD_INT 2
76022: ARRAY
76023: PPUSH
76024: CALL_OW 488
76028: IFFALSE 76127
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76030: LD_ADDR_VAR 0 4
76034: PUSH
76035: LD_VAR 0 9
76039: PUSH
76040: LD_INT 1
76042: ARRAY
76043: PPUSH
76044: LD_VAR 0 9
76048: PUSH
76049: LD_INT 2
76051: ARRAY
76052: PPUSH
76053: CALL_OW 546
76057: ST_TO_ADDR
// if hex [ 1 ] then
76058: LD_VAR 0 4
76062: PUSH
76063: LD_INT 1
76065: ARRAY
76066: IFFALSE 76070
// continue ;
76068: GO 75958
// h := hex [ 2 ] ;
76070: LD_ADDR_VAR 0 13
76074: PUSH
76075: LD_VAR 0 4
76079: PUSH
76080: LD_INT 2
76082: ARRAY
76083: ST_TO_ADDR
// if h + 7 < height then
76084: LD_VAR 0 13
76088: PUSH
76089: LD_INT 7
76091: PLUS
76092: PUSH
76093: LD_VAR 0 15
76097: LESS
76098: IFFALSE 76127
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76100: LD_ADDR_VAR 0 18
76104: PUSH
76105: LD_INT 7
76107: PUSH
76108: LD_INT 28
76110: PUSH
76111: LD_INT 45
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: LIST
76118: PUSH
76119: LD_VAR 0 12
76123: ARRAY
76124: ST_TO_ADDR
// break ;
76125: GO 76129
// end ; end ; end ;
76127: GO 75958
76129: POP
76130: POP
// end ; if not weapon then
76131: LD_VAR 0 18
76135: NOT
76136: IFFALSE 76196
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76138: LD_ADDR_VAR 0 5
76142: PUSH
76143: LD_VAR 0 5
76147: PUSH
76148: LD_INT 11
76150: PUSH
76151: LD_INT 30
76153: PUSH
76154: LD_INT 49
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: LIST
76161: DIFF
76162: ST_TO_ADDR
// if not list then
76163: LD_VAR 0 5
76167: NOT
76168: IFFALSE 76172
// exit ;
76170: GO 76314
// weapon := list [ rand ( 1 , list ) ] ;
76172: LD_ADDR_VAR 0 18
76176: PUSH
76177: LD_VAR 0 5
76181: PUSH
76182: LD_INT 1
76184: PPUSH
76185: LD_VAR 0 5
76189: PPUSH
76190: CALL_OW 12
76194: ARRAY
76195: ST_TO_ADDR
// end ; if weapon then
76196: LD_VAR 0 18
76200: IFFALSE 76314
// begin tmp := CostOfWeapon ( weapon ) ;
76202: LD_ADDR_VAR 0 14
76206: PUSH
76207: LD_VAR 0 18
76211: PPUSH
76212: CALL_OW 451
76216: ST_TO_ADDR
// j := GetBase ( tower ) ;
76217: LD_ADDR_VAR 0 9
76221: PUSH
76222: LD_VAR 0 1
76226: PPUSH
76227: CALL_OW 274
76231: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76232: LD_VAR 0 9
76236: PPUSH
76237: LD_INT 1
76239: PPUSH
76240: CALL_OW 275
76244: PUSH
76245: LD_VAR 0 14
76249: PUSH
76250: LD_INT 1
76252: ARRAY
76253: GREATEREQUAL
76254: PUSH
76255: LD_VAR 0 9
76259: PPUSH
76260: LD_INT 2
76262: PPUSH
76263: CALL_OW 275
76267: PUSH
76268: LD_VAR 0 14
76272: PUSH
76273: LD_INT 2
76275: ARRAY
76276: GREATEREQUAL
76277: AND
76278: PUSH
76279: LD_VAR 0 9
76283: PPUSH
76284: LD_INT 3
76286: PPUSH
76287: CALL_OW 275
76291: PUSH
76292: LD_VAR 0 14
76296: PUSH
76297: LD_INT 3
76299: ARRAY
76300: GREATEREQUAL
76301: AND
76302: IFFALSE 76314
// result := weapon ;
76304: LD_ADDR_VAR 0 3
76308: PUSH
76309: LD_VAR 0 18
76313: ST_TO_ADDR
// end ; end ;
76314: LD_VAR 0 3
76318: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76319: LD_INT 0
76321: PPUSH
76322: PPUSH
// result := true ;
76323: LD_ADDR_VAR 0 3
76327: PUSH
76328: LD_INT 1
76330: ST_TO_ADDR
// if array1 = array2 then
76331: LD_VAR 0 1
76335: PUSH
76336: LD_VAR 0 2
76340: EQUAL
76341: IFFALSE 76401
// begin for i = 1 to array1 do
76343: LD_ADDR_VAR 0 4
76347: PUSH
76348: DOUBLE
76349: LD_INT 1
76351: DEC
76352: ST_TO_ADDR
76353: LD_VAR 0 1
76357: PUSH
76358: FOR_TO
76359: IFFALSE 76397
// if array1 [ i ] <> array2 [ i ] then
76361: LD_VAR 0 1
76365: PUSH
76366: LD_VAR 0 4
76370: ARRAY
76371: PUSH
76372: LD_VAR 0 2
76376: PUSH
76377: LD_VAR 0 4
76381: ARRAY
76382: NONEQUAL
76383: IFFALSE 76395
// begin result := false ;
76385: LD_ADDR_VAR 0 3
76389: PUSH
76390: LD_INT 0
76392: ST_TO_ADDR
// break ;
76393: GO 76397
// end ;
76395: GO 76358
76397: POP
76398: POP
// end else
76399: GO 76409
// result := false ;
76401: LD_ADDR_VAR 0 3
76405: PUSH
76406: LD_INT 0
76408: ST_TO_ADDR
// end ;
76409: LD_VAR 0 3
76413: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76414: LD_INT 0
76416: PPUSH
76417: PPUSH
76418: PPUSH
// pom := GetBase ( fac ) ;
76419: LD_ADDR_VAR 0 5
76423: PUSH
76424: LD_VAR 0 1
76428: PPUSH
76429: CALL_OW 274
76433: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76434: LD_ADDR_VAR 0 4
76438: PUSH
76439: LD_VAR 0 2
76443: PUSH
76444: LD_INT 1
76446: ARRAY
76447: PPUSH
76448: LD_VAR 0 2
76452: PUSH
76453: LD_INT 2
76455: ARRAY
76456: PPUSH
76457: LD_VAR 0 2
76461: PUSH
76462: LD_INT 3
76464: ARRAY
76465: PPUSH
76466: LD_VAR 0 2
76470: PUSH
76471: LD_INT 4
76473: ARRAY
76474: PPUSH
76475: CALL_OW 449
76479: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76480: LD_ADDR_VAR 0 3
76484: PUSH
76485: LD_VAR 0 5
76489: PPUSH
76490: LD_INT 1
76492: PPUSH
76493: CALL_OW 275
76497: PUSH
76498: LD_VAR 0 4
76502: PUSH
76503: LD_INT 1
76505: ARRAY
76506: GREATEREQUAL
76507: PUSH
76508: LD_VAR 0 5
76512: PPUSH
76513: LD_INT 2
76515: PPUSH
76516: CALL_OW 275
76520: PUSH
76521: LD_VAR 0 4
76525: PUSH
76526: LD_INT 2
76528: ARRAY
76529: GREATEREQUAL
76530: AND
76531: PUSH
76532: LD_VAR 0 5
76536: PPUSH
76537: LD_INT 3
76539: PPUSH
76540: CALL_OW 275
76544: PUSH
76545: LD_VAR 0 4
76549: PUSH
76550: LD_INT 3
76552: ARRAY
76553: GREATEREQUAL
76554: AND
76555: ST_TO_ADDR
// end ;
76556: LD_VAR 0 3
76560: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76561: LD_INT 0
76563: PPUSH
76564: PPUSH
76565: PPUSH
76566: PPUSH
// pom := GetBase ( building ) ;
76567: LD_ADDR_VAR 0 3
76571: PUSH
76572: LD_VAR 0 1
76576: PPUSH
76577: CALL_OW 274
76581: ST_TO_ADDR
// if not pom then
76582: LD_VAR 0 3
76586: NOT
76587: IFFALSE 76591
// exit ;
76589: GO 76761
// btype := GetBType ( building ) ;
76591: LD_ADDR_VAR 0 5
76595: PUSH
76596: LD_VAR 0 1
76600: PPUSH
76601: CALL_OW 266
76605: ST_TO_ADDR
// if btype = b_armoury then
76606: LD_VAR 0 5
76610: PUSH
76611: LD_INT 4
76613: EQUAL
76614: IFFALSE 76624
// btype := b_barracks ;
76616: LD_ADDR_VAR 0 5
76620: PUSH
76621: LD_INT 5
76623: ST_TO_ADDR
// if btype = b_depot then
76624: LD_VAR 0 5
76628: PUSH
76629: LD_INT 0
76631: EQUAL
76632: IFFALSE 76642
// btype := b_warehouse ;
76634: LD_ADDR_VAR 0 5
76638: PUSH
76639: LD_INT 1
76641: ST_TO_ADDR
// if btype = b_workshop then
76642: LD_VAR 0 5
76646: PUSH
76647: LD_INT 2
76649: EQUAL
76650: IFFALSE 76660
// btype := b_factory ;
76652: LD_ADDR_VAR 0 5
76656: PUSH
76657: LD_INT 3
76659: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76660: LD_ADDR_VAR 0 4
76664: PUSH
76665: LD_VAR 0 5
76669: PPUSH
76670: LD_VAR 0 1
76674: PPUSH
76675: CALL_OW 248
76679: PPUSH
76680: CALL_OW 450
76684: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76685: LD_ADDR_VAR 0 2
76689: PUSH
76690: LD_VAR 0 3
76694: PPUSH
76695: LD_INT 1
76697: PPUSH
76698: CALL_OW 275
76702: PUSH
76703: LD_VAR 0 4
76707: PUSH
76708: LD_INT 1
76710: ARRAY
76711: GREATEREQUAL
76712: PUSH
76713: LD_VAR 0 3
76717: PPUSH
76718: LD_INT 2
76720: PPUSH
76721: CALL_OW 275
76725: PUSH
76726: LD_VAR 0 4
76730: PUSH
76731: LD_INT 2
76733: ARRAY
76734: GREATEREQUAL
76735: AND
76736: PUSH
76737: LD_VAR 0 3
76741: PPUSH
76742: LD_INT 3
76744: PPUSH
76745: CALL_OW 275
76749: PUSH
76750: LD_VAR 0 4
76754: PUSH
76755: LD_INT 3
76757: ARRAY
76758: GREATEREQUAL
76759: AND
76760: ST_TO_ADDR
// end ;
76761: LD_VAR 0 2
76765: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76766: LD_INT 0
76768: PPUSH
76769: PPUSH
76770: PPUSH
// pom := GetBase ( building ) ;
76771: LD_ADDR_VAR 0 4
76775: PUSH
76776: LD_VAR 0 1
76780: PPUSH
76781: CALL_OW 274
76785: ST_TO_ADDR
// if not pom then
76786: LD_VAR 0 4
76790: NOT
76791: IFFALSE 76795
// exit ;
76793: GO 76896
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76795: LD_ADDR_VAR 0 5
76799: PUSH
76800: LD_VAR 0 2
76804: PPUSH
76805: LD_VAR 0 1
76809: PPUSH
76810: CALL_OW 248
76814: PPUSH
76815: CALL_OW 450
76819: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76820: LD_ADDR_VAR 0 3
76824: PUSH
76825: LD_VAR 0 4
76829: PPUSH
76830: LD_INT 1
76832: PPUSH
76833: CALL_OW 275
76837: PUSH
76838: LD_VAR 0 5
76842: PUSH
76843: LD_INT 1
76845: ARRAY
76846: GREATEREQUAL
76847: PUSH
76848: LD_VAR 0 4
76852: PPUSH
76853: LD_INT 2
76855: PPUSH
76856: CALL_OW 275
76860: PUSH
76861: LD_VAR 0 5
76865: PUSH
76866: LD_INT 2
76868: ARRAY
76869: GREATEREQUAL
76870: AND
76871: PUSH
76872: LD_VAR 0 4
76876: PPUSH
76877: LD_INT 3
76879: PPUSH
76880: CALL_OW 275
76884: PUSH
76885: LD_VAR 0 5
76889: PUSH
76890: LD_INT 3
76892: ARRAY
76893: GREATEREQUAL
76894: AND
76895: ST_TO_ADDR
// end ;
76896: LD_VAR 0 3
76900: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76901: LD_INT 0
76903: PPUSH
76904: PPUSH
76905: PPUSH
76906: PPUSH
76907: PPUSH
76908: PPUSH
76909: PPUSH
76910: PPUSH
76911: PPUSH
76912: PPUSH
// result := false ;
76913: LD_ADDR_VAR 0 6
76917: PUSH
76918: LD_INT 0
76920: ST_TO_ADDR
// if not base or not btype or not x or not y then
76921: LD_VAR 0 1
76925: NOT
76926: PUSH
76927: LD_VAR 0 2
76931: NOT
76932: OR
76933: PUSH
76934: LD_VAR 0 3
76938: NOT
76939: OR
76940: PUSH
76941: LD_VAR 0 4
76945: NOT
76946: OR
76947: IFFALSE 76951
// exit ;
76949: GO 77560
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76951: LD_ADDR_VAR 0 12
76955: PUSH
76956: LD_VAR 0 2
76960: PPUSH
76961: LD_VAR 0 3
76965: PPUSH
76966: LD_VAR 0 4
76970: PPUSH
76971: LD_VAR 0 5
76975: PPUSH
76976: LD_VAR 0 1
76980: PUSH
76981: LD_INT 1
76983: ARRAY
76984: PPUSH
76985: CALL_OW 248
76989: PPUSH
76990: LD_INT 0
76992: PPUSH
76993: CALL 78397 0 6
76997: ST_TO_ADDR
// if not hexes then
76998: LD_VAR 0 12
77002: NOT
77003: IFFALSE 77007
// exit ;
77005: GO 77560
// for i = 1 to hexes do
77007: LD_ADDR_VAR 0 7
77011: PUSH
77012: DOUBLE
77013: LD_INT 1
77015: DEC
77016: ST_TO_ADDR
77017: LD_VAR 0 12
77021: PUSH
77022: FOR_TO
77023: IFFALSE 77558
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77025: LD_ADDR_VAR 0 11
77029: PUSH
77030: LD_VAR 0 12
77034: PUSH
77035: LD_VAR 0 7
77039: ARRAY
77040: PUSH
77041: LD_INT 1
77043: ARRAY
77044: PPUSH
77045: LD_VAR 0 12
77049: PUSH
77050: LD_VAR 0 7
77054: ARRAY
77055: PUSH
77056: LD_INT 2
77058: ARRAY
77059: PPUSH
77060: CALL_OW 428
77064: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77065: LD_VAR 0 12
77069: PUSH
77070: LD_VAR 0 7
77074: ARRAY
77075: PUSH
77076: LD_INT 1
77078: ARRAY
77079: PPUSH
77080: LD_VAR 0 12
77084: PUSH
77085: LD_VAR 0 7
77089: ARRAY
77090: PUSH
77091: LD_INT 2
77093: ARRAY
77094: PPUSH
77095: CALL_OW 351
77099: PUSH
77100: LD_VAR 0 12
77104: PUSH
77105: LD_VAR 0 7
77109: ARRAY
77110: PUSH
77111: LD_INT 1
77113: ARRAY
77114: PPUSH
77115: LD_VAR 0 12
77119: PUSH
77120: LD_VAR 0 7
77124: ARRAY
77125: PUSH
77126: LD_INT 2
77128: ARRAY
77129: PPUSH
77130: CALL_OW 488
77134: NOT
77135: OR
77136: PUSH
77137: LD_VAR 0 11
77141: PPUSH
77142: CALL_OW 247
77146: PUSH
77147: LD_INT 3
77149: EQUAL
77150: OR
77151: IFFALSE 77157
// exit ;
77153: POP
77154: POP
77155: GO 77560
// if not tmp or not tmp in base then
77157: LD_VAR 0 11
77161: NOT
77162: PUSH
77163: LD_VAR 0 11
77167: PUSH
77168: LD_VAR 0 1
77172: IN
77173: NOT
77174: OR
77175: IFFALSE 77179
// continue ;
77177: GO 77022
// result := true ;
77179: LD_ADDR_VAR 0 6
77183: PUSH
77184: LD_INT 1
77186: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77187: LD_ADDR_VAR 0 15
77191: PUSH
77192: LD_VAR 0 1
77196: PPUSH
77197: LD_INT 22
77199: PUSH
77200: LD_VAR 0 11
77204: PPUSH
77205: CALL_OW 255
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 2
77216: PUSH
77217: LD_INT 30
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 30
77229: PUSH
77230: LD_INT 1
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: LIST
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PPUSH
77246: CALL_OW 72
77250: ST_TO_ADDR
// if dep then
77251: LD_VAR 0 15
77255: IFFALSE 77391
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77257: LD_ADDR_VAR 0 14
77261: PUSH
77262: LD_VAR 0 15
77266: PUSH
77267: LD_INT 1
77269: ARRAY
77270: PPUSH
77271: CALL_OW 250
77275: PPUSH
77276: LD_VAR 0 15
77280: PUSH
77281: LD_INT 1
77283: ARRAY
77284: PPUSH
77285: CALL_OW 254
77289: PPUSH
77290: LD_INT 5
77292: PPUSH
77293: CALL_OW 272
77297: PUSH
77298: LD_VAR 0 15
77302: PUSH
77303: LD_INT 1
77305: ARRAY
77306: PPUSH
77307: CALL_OW 251
77311: PPUSH
77312: LD_VAR 0 15
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PPUSH
77321: CALL_OW 254
77325: PPUSH
77326: LD_INT 5
77328: PPUSH
77329: CALL_OW 273
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77338: LD_VAR 0 14
77342: PUSH
77343: LD_INT 1
77345: ARRAY
77346: PPUSH
77347: LD_VAR 0 14
77351: PUSH
77352: LD_INT 2
77354: ARRAY
77355: PPUSH
77356: CALL_OW 488
77360: IFFALSE 77391
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77362: LD_VAR 0 11
77366: PPUSH
77367: LD_VAR 0 14
77371: PUSH
77372: LD_INT 1
77374: ARRAY
77375: PPUSH
77376: LD_VAR 0 14
77380: PUSH
77381: LD_INT 2
77383: ARRAY
77384: PPUSH
77385: CALL_OW 111
// continue ;
77389: GO 77022
// end ; end ; r := GetDir ( tmp ) ;
77391: LD_ADDR_VAR 0 13
77395: PUSH
77396: LD_VAR 0 11
77400: PPUSH
77401: CALL_OW 254
77405: ST_TO_ADDR
// if r = 5 then
77406: LD_VAR 0 13
77410: PUSH
77411: LD_INT 5
77413: EQUAL
77414: IFFALSE 77424
// r := 0 ;
77416: LD_ADDR_VAR 0 13
77420: PUSH
77421: LD_INT 0
77423: ST_TO_ADDR
// for j = r to 5 do
77424: LD_ADDR_VAR 0 8
77428: PUSH
77429: DOUBLE
77430: LD_VAR 0 13
77434: DEC
77435: ST_TO_ADDR
77436: LD_INT 5
77438: PUSH
77439: FOR_TO
77440: IFFALSE 77554
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77442: LD_ADDR_VAR 0 9
77446: PUSH
77447: LD_VAR 0 11
77451: PPUSH
77452: CALL_OW 250
77456: PPUSH
77457: LD_VAR 0 8
77461: PPUSH
77462: LD_INT 2
77464: PPUSH
77465: CALL_OW 272
77469: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77470: LD_ADDR_VAR 0 10
77474: PUSH
77475: LD_VAR 0 11
77479: PPUSH
77480: CALL_OW 251
77484: PPUSH
77485: LD_VAR 0 8
77489: PPUSH
77490: LD_INT 2
77492: PPUSH
77493: CALL_OW 273
77497: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77498: LD_VAR 0 9
77502: PPUSH
77503: LD_VAR 0 10
77507: PPUSH
77508: CALL_OW 488
77512: PUSH
77513: LD_VAR 0 9
77517: PPUSH
77518: LD_VAR 0 10
77522: PPUSH
77523: CALL_OW 428
77527: NOT
77528: AND
77529: IFFALSE 77552
// begin ComMoveXY ( tmp , _x , _y ) ;
77531: LD_VAR 0 11
77535: PPUSH
77536: LD_VAR 0 9
77540: PPUSH
77541: LD_VAR 0 10
77545: PPUSH
77546: CALL_OW 111
// break ;
77550: GO 77554
// end ; end ;
77552: GO 77439
77554: POP
77555: POP
// end ;
77556: GO 77022
77558: POP
77559: POP
// end ;
77560: LD_VAR 0 6
77564: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77565: LD_INT 0
77567: PPUSH
77568: PPUSH
77569: PPUSH
77570: PPUSH
77571: PPUSH
77572: PPUSH
77573: PPUSH
77574: PPUSH
77575: PPUSH
77576: PPUSH
// result := false ;
77577: LD_ADDR_VAR 0 6
77581: PUSH
77582: LD_INT 0
77584: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77585: LD_VAR 0 1
77589: NOT
77590: PUSH
77591: LD_VAR 0 1
77595: PPUSH
77596: CALL_OW 266
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: IN
77611: NOT
77612: OR
77613: PUSH
77614: LD_VAR 0 2
77618: NOT
77619: OR
77620: PUSH
77621: LD_VAR 0 5
77625: PUSH
77626: LD_INT 0
77628: PUSH
77629: LD_INT 1
77631: PUSH
77632: LD_INT 2
77634: PUSH
77635: LD_INT 3
77637: PUSH
77638: LD_INT 4
77640: PUSH
77641: LD_INT 5
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: IN
77652: NOT
77653: OR
77654: PUSH
77655: LD_VAR 0 3
77659: PPUSH
77660: LD_VAR 0 4
77664: PPUSH
77665: CALL_OW 488
77669: NOT
77670: OR
77671: IFFALSE 77675
// exit ;
77673: GO 78392
// pom := GetBase ( depot ) ;
77675: LD_ADDR_VAR 0 10
77679: PUSH
77680: LD_VAR 0 1
77684: PPUSH
77685: CALL_OW 274
77689: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77690: LD_ADDR_VAR 0 11
77694: PUSH
77695: LD_VAR 0 2
77699: PPUSH
77700: LD_VAR 0 1
77704: PPUSH
77705: CALL_OW 248
77709: PPUSH
77710: CALL_OW 450
77714: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77715: LD_VAR 0 10
77719: PPUSH
77720: LD_INT 1
77722: PPUSH
77723: CALL_OW 275
77727: PUSH
77728: LD_VAR 0 11
77732: PUSH
77733: LD_INT 1
77735: ARRAY
77736: GREATEREQUAL
77737: PUSH
77738: LD_VAR 0 10
77742: PPUSH
77743: LD_INT 2
77745: PPUSH
77746: CALL_OW 275
77750: PUSH
77751: LD_VAR 0 11
77755: PUSH
77756: LD_INT 2
77758: ARRAY
77759: GREATEREQUAL
77760: AND
77761: PUSH
77762: LD_VAR 0 10
77766: PPUSH
77767: LD_INT 3
77769: PPUSH
77770: CALL_OW 275
77774: PUSH
77775: LD_VAR 0 11
77779: PUSH
77780: LD_INT 3
77782: ARRAY
77783: GREATEREQUAL
77784: AND
77785: NOT
77786: IFFALSE 77790
// exit ;
77788: GO 78392
// if GetBType ( depot ) = b_depot then
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 266
77799: PUSH
77800: LD_INT 0
77802: EQUAL
77803: IFFALSE 77815
// dist := 28 else
77805: LD_ADDR_VAR 0 14
77809: PUSH
77810: LD_INT 28
77812: ST_TO_ADDR
77813: GO 77823
// dist := 36 ;
77815: LD_ADDR_VAR 0 14
77819: PUSH
77820: LD_INT 36
77822: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77823: LD_VAR 0 1
77827: PPUSH
77828: LD_VAR 0 3
77832: PPUSH
77833: LD_VAR 0 4
77837: PPUSH
77838: CALL_OW 297
77842: PUSH
77843: LD_VAR 0 14
77847: GREATER
77848: IFFALSE 77852
// exit ;
77850: GO 78392
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77852: LD_ADDR_VAR 0 12
77856: PUSH
77857: LD_VAR 0 2
77861: PPUSH
77862: LD_VAR 0 3
77866: PPUSH
77867: LD_VAR 0 4
77871: PPUSH
77872: LD_VAR 0 5
77876: PPUSH
77877: LD_VAR 0 1
77881: PPUSH
77882: CALL_OW 248
77886: PPUSH
77887: LD_INT 0
77889: PPUSH
77890: CALL 78397 0 6
77894: ST_TO_ADDR
// if not hexes then
77895: LD_VAR 0 12
77899: NOT
77900: IFFALSE 77904
// exit ;
77902: GO 78392
// hex := GetHexInfo ( x , y ) ;
77904: LD_ADDR_VAR 0 15
77908: PUSH
77909: LD_VAR 0 3
77913: PPUSH
77914: LD_VAR 0 4
77918: PPUSH
77919: CALL_OW 546
77923: ST_TO_ADDR
// if hex [ 1 ] then
77924: LD_VAR 0 15
77928: PUSH
77929: LD_INT 1
77931: ARRAY
77932: IFFALSE 77936
// exit ;
77934: GO 78392
// height := hex [ 2 ] ;
77936: LD_ADDR_VAR 0 13
77940: PUSH
77941: LD_VAR 0 15
77945: PUSH
77946: LD_INT 2
77948: ARRAY
77949: ST_TO_ADDR
// for i = 1 to hexes do
77950: LD_ADDR_VAR 0 7
77954: PUSH
77955: DOUBLE
77956: LD_INT 1
77958: DEC
77959: ST_TO_ADDR
77960: LD_VAR 0 12
77964: PUSH
77965: FOR_TO
77966: IFFALSE 78296
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77968: LD_VAR 0 12
77972: PUSH
77973: LD_VAR 0 7
77977: ARRAY
77978: PUSH
77979: LD_INT 1
77981: ARRAY
77982: PPUSH
77983: LD_VAR 0 12
77987: PUSH
77988: LD_VAR 0 7
77992: ARRAY
77993: PUSH
77994: LD_INT 2
77996: ARRAY
77997: PPUSH
77998: CALL_OW 488
78002: NOT
78003: PUSH
78004: LD_VAR 0 12
78008: PUSH
78009: LD_VAR 0 7
78013: ARRAY
78014: PUSH
78015: LD_INT 1
78017: ARRAY
78018: PPUSH
78019: LD_VAR 0 12
78023: PUSH
78024: LD_VAR 0 7
78028: ARRAY
78029: PUSH
78030: LD_INT 2
78032: ARRAY
78033: PPUSH
78034: CALL_OW 428
78038: PUSH
78039: LD_INT 0
78041: GREATER
78042: OR
78043: PUSH
78044: LD_VAR 0 12
78048: PUSH
78049: LD_VAR 0 7
78053: ARRAY
78054: PUSH
78055: LD_INT 1
78057: ARRAY
78058: PPUSH
78059: LD_VAR 0 12
78063: PUSH
78064: LD_VAR 0 7
78068: ARRAY
78069: PUSH
78070: LD_INT 2
78072: ARRAY
78073: PPUSH
78074: CALL_OW 351
78078: OR
78079: IFFALSE 78085
// exit ;
78081: POP
78082: POP
78083: GO 78392
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78085: LD_ADDR_VAR 0 8
78089: PUSH
78090: LD_VAR 0 12
78094: PUSH
78095: LD_VAR 0 7
78099: ARRAY
78100: PUSH
78101: LD_INT 1
78103: ARRAY
78104: PPUSH
78105: LD_VAR 0 12
78109: PUSH
78110: LD_VAR 0 7
78114: ARRAY
78115: PUSH
78116: LD_INT 2
78118: ARRAY
78119: PPUSH
78120: CALL_OW 546
78124: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78125: LD_VAR 0 8
78129: PUSH
78130: LD_INT 1
78132: ARRAY
78133: PUSH
78134: LD_VAR 0 8
78138: PUSH
78139: LD_INT 2
78141: ARRAY
78142: PUSH
78143: LD_VAR 0 13
78147: PUSH
78148: LD_INT 2
78150: PLUS
78151: GREATER
78152: OR
78153: PUSH
78154: LD_VAR 0 8
78158: PUSH
78159: LD_INT 2
78161: ARRAY
78162: PUSH
78163: LD_VAR 0 13
78167: PUSH
78168: LD_INT 2
78170: MINUS
78171: LESS
78172: OR
78173: PUSH
78174: LD_VAR 0 8
78178: PUSH
78179: LD_INT 3
78181: ARRAY
78182: PUSH
78183: LD_INT 0
78185: PUSH
78186: LD_INT 8
78188: PUSH
78189: LD_INT 9
78191: PUSH
78192: LD_INT 10
78194: PUSH
78195: LD_INT 11
78197: PUSH
78198: LD_INT 12
78200: PUSH
78201: LD_INT 13
78203: PUSH
78204: LD_INT 16
78206: PUSH
78207: LD_INT 17
78209: PUSH
78210: LD_INT 18
78212: PUSH
78213: LD_INT 19
78215: PUSH
78216: LD_INT 20
78218: PUSH
78219: LD_INT 21
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: IN
78237: NOT
78238: OR
78239: PUSH
78240: LD_VAR 0 8
78244: PUSH
78245: LD_INT 5
78247: ARRAY
78248: NOT
78249: OR
78250: PUSH
78251: LD_VAR 0 8
78255: PUSH
78256: LD_INT 6
78258: ARRAY
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: LD_INT 2
78265: PUSH
78266: LD_INT 7
78268: PUSH
78269: LD_INT 9
78271: PUSH
78272: LD_INT 10
78274: PUSH
78275: LD_INT 11
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: IN
78286: NOT
78287: OR
78288: IFFALSE 78294
// exit ;
78290: POP
78291: POP
78292: GO 78392
// end ;
78294: GO 77965
78296: POP
78297: POP
// side := GetSide ( depot ) ;
78298: LD_ADDR_VAR 0 9
78302: PUSH
78303: LD_VAR 0 1
78307: PPUSH
78308: CALL_OW 255
78312: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78313: LD_VAR 0 9
78317: PPUSH
78318: LD_VAR 0 3
78322: PPUSH
78323: LD_VAR 0 4
78327: PPUSH
78328: LD_INT 20
78330: PPUSH
78331: CALL 71046 0 4
78335: PUSH
78336: LD_INT 4
78338: ARRAY
78339: IFFALSE 78343
// exit ;
78341: GO 78392
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78343: LD_VAR 0 2
78347: PUSH
78348: LD_INT 29
78350: PUSH
78351: LD_INT 30
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: IN
78358: PUSH
78359: LD_VAR 0 3
78363: PPUSH
78364: LD_VAR 0 4
78368: PPUSH
78369: LD_VAR 0 9
78373: PPUSH
78374: CALL_OW 440
78378: NOT
78379: AND
78380: IFFALSE 78384
// exit ;
78382: GO 78392
// result := true ;
78384: LD_ADDR_VAR 0 6
78388: PUSH
78389: LD_INT 1
78391: ST_TO_ADDR
// end ;
78392: LD_VAR 0 6
78396: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78397: LD_INT 0
78399: PPUSH
78400: PPUSH
78401: PPUSH
78402: PPUSH
78403: PPUSH
78404: PPUSH
78405: PPUSH
78406: PPUSH
78407: PPUSH
78408: PPUSH
78409: PPUSH
78410: PPUSH
78411: PPUSH
78412: PPUSH
78413: PPUSH
78414: PPUSH
78415: PPUSH
78416: PPUSH
78417: PPUSH
78418: PPUSH
78419: PPUSH
78420: PPUSH
78421: PPUSH
78422: PPUSH
78423: PPUSH
78424: PPUSH
78425: PPUSH
78426: PPUSH
78427: PPUSH
78428: PPUSH
78429: PPUSH
78430: PPUSH
78431: PPUSH
78432: PPUSH
78433: PPUSH
78434: PPUSH
78435: PPUSH
78436: PPUSH
78437: PPUSH
78438: PPUSH
78439: PPUSH
78440: PPUSH
78441: PPUSH
78442: PPUSH
78443: PPUSH
78444: PPUSH
78445: PPUSH
78446: PPUSH
78447: PPUSH
78448: PPUSH
78449: PPUSH
78450: PPUSH
78451: PPUSH
78452: PPUSH
78453: PPUSH
78454: PPUSH
78455: PPUSH
78456: PPUSH
// result = [ ] ;
78457: LD_ADDR_VAR 0 7
78461: PUSH
78462: EMPTY
78463: ST_TO_ADDR
// temp_list = [ ] ;
78464: LD_ADDR_VAR 0 9
78468: PUSH
78469: EMPTY
78470: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78471: LD_VAR 0 4
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: LD_INT 2
78484: PUSH
78485: LD_INT 3
78487: PUSH
78488: LD_INT 4
78490: PUSH
78491: LD_INT 5
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: IN
78502: NOT
78503: PUSH
78504: LD_VAR 0 1
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: IN
78519: PUSH
78520: LD_VAR 0 5
78524: PUSH
78525: LD_INT 1
78527: PUSH
78528: LD_INT 2
78530: PUSH
78531: LD_INT 3
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: LIST
78538: IN
78539: NOT
78540: AND
78541: OR
78542: IFFALSE 78546
// exit ;
78544: GO 96937
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78546: LD_VAR 0 1
78550: PUSH
78551: LD_INT 6
78553: PUSH
78554: LD_INT 7
78556: PUSH
78557: LD_INT 8
78559: PUSH
78560: LD_INT 13
78562: PUSH
78563: LD_INT 12
78565: PUSH
78566: LD_INT 15
78568: PUSH
78569: LD_INT 11
78571: PUSH
78572: LD_INT 14
78574: PUSH
78575: LD_INT 10
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: IN
78589: IFFALSE 78599
// btype = b_lab ;
78591: LD_ADDR_VAR 0 1
78595: PUSH
78596: LD_INT 6
78598: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78599: LD_VAR 0 6
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: LD_INT 1
78609: PUSH
78610: LD_INT 2
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: LIST
78617: IN
78618: NOT
78619: PUSH
78620: LD_VAR 0 1
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: LD_INT 1
78630: PUSH
78631: LD_INT 2
78633: PUSH
78634: LD_INT 3
78636: PUSH
78637: LD_INT 6
78639: PUSH
78640: LD_INT 36
78642: PUSH
78643: LD_INT 4
78645: PUSH
78646: LD_INT 5
78648: PUSH
78649: LD_INT 31
78651: PUSH
78652: LD_INT 32
78654: PUSH
78655: LD_INT 33
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: IN
78671: NOT
78672: PUSH
78673: LD_VAR 0 6
78677: PUSH
78678: LD_INT 1
78680: EQUAL
78681: AND
78682: OR
78683: PUSH
78684: LD_VAR 0 1
78688: PUSH
78689: LD_INT 2
78691: PUSH
78692: LD_INT 3
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: IN
78699: NOT
78700: PUSH
78701: LD_VAR 0 6
78705: PUSH
78706: LD_INT 2
78708: EQUAL
78709: AND
78710: OR
78711: IFFALSE 78721
// mode = 0 ;
78713: LD_ADDR_VAR 0 6
78717: PUSH
78718: LD_INT 0
78720: ST_TO_ADDR
// case mode of 0 :
78721: LD_VAR 0 6
78725: PUSH
78726: LD_INT 0
78728: DOUBLE
78729: EQUAL
78730: IFTRUE 78734
78732: GO 90187
78734: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78735: LD_ADDR_VAR 0 11
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: LD_INT 0
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 1
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: LD_INT 1
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 1
78804: NEG
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 1
78816: NEG
78817: PUSH
78818: LD_INT 2
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 0
78828: PUSH
78829: LD_INT 2
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 1
78839: PUSH
78840: LD_INT 1
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 2
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: LD_INT 2
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 1
78870: NEG
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: LD_INT 3
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: LD_INT 3
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: LD_INT 2
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78928: LD_ADDR_VAR 0 12
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 0
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: LD_INT 1
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: LD_INT 0
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 1
78986: NEG
78987: PUSH
78988: LD_INT 0
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 1
78997: NEG
78998: PUSH
78999: LD_INT 1
79001: NEG
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: PUSH
79010: LD_INT 1
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 2
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 2
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: NEG
79041: PUSH
79042: LD_INT 1
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 2
79051: NEG
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: NEG
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 2
79074: NEG
79075: PUSH
79076: LD_INT 1
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 3
79085: NEG
79086: PUSH
79087: LD_INT 0
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 3
79096: NEG
79097: PUSH
79098: LD_INT 1
79100: NEG
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79124: LD_ADDR_VAR 0 13
79128: PUSH
79129: LD_INT 0
79131: PUSH
79132: LD_INT 0
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 1
79152: PUSH
79153: LD_INT 0
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 1
79162: PUSH
79163: LD_INT 1
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: LD_INT 0
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 1
79193: NEG
79194: PUSH
79195: LD_INT 1
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: NEG
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 2
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 2
79227: PUSH
79228: LD_INT 2
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 1
79237: PUSH
79238: LD_INT 2
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 2
79247: NEG
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: LD_INT 2
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 2
79271: NEG
79272: PUSH
79273: LD_INT 3
79275: NEG
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 3
79283: NEG
79284: PUSH
79285: LD_INT 2
79287: NEG
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 3
79295: NEG
79296: PUSH
79297: LD_INT 3
79299: NEG
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79323: LD_ADDR_VAR 0 14
79327: PUSH
79328: LD_INT 0
79330: PUSH
79331: LD_INT 0
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 0
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: PUSH
79352: LD_INT 0
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 1
79361: PUSH
79362: LD_INT 1
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 1
79381: NEG
79382: PUSH
79383: LD_INT 0
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 1
79392: NEG
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: LD_INT 2
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 1
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 1
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 0
79448: PUSH
79449: LD_INT 2
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 1
79458: NEG
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 1
79469: NEG
79470: PUSH
79471: LD_INT 3
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: LD_INT 3
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: PUSH
79493: LD_INT 2
79495: NEG
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79519: LD_ADDR_VAR 0 15
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 0
79536: PUSH
79537: LD_INT 1
79539: NEG
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 1
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: LD_INT 1
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 0
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 1
79577: NEG
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 1
79600: PUSH
79601: LD_INT 1
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: PUSH
79612: LD_INT 0
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 2
79621: PUSH
79622: LD_INT 1
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 2
79653: NEG
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 2
79665: PUSH
79666: LD_INT 1
79668: NEG
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 3
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 3
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79712: LD_ADDR_VAR 0 16
79716: PUSH
79717: LD_INT 0
79719: PUSH
79720: LD_INT 0
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: LD_INT 1
79732: NEG
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 1
79740: PUSH
79741: LD_INT 0
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 1
79750: PUSH
79751: LD_INT 1
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 1
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: NEG
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 1
79781: NEG
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 1
79793: NEG
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 2
79805: PUSH
79806: LD_INT 1
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 2
79815: PUSH
79816: LD_INT 2
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: LD_INT 2
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 2
79835: NEG
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 2
79847: NEG
79848: PUSH
79849: LD_INT 2
79851: NEG
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 3
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 3
79869: PUSH
79870: LD_INT 3
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PUSH
79877: LD_INT 2
79879: PUSH
79880: LD_INT 3
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79905: LD_ADDR_VAR 0 17
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: LD_INT 0
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 0
79922: PUSH
79923: LD_INT 1
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: LD_INT 0
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: LD_INT 1
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 0
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 1
79963: NEG
79964: PUSH
79965: LD_INT 0
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: LD_INT 1
79978: NEG
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 1
79986: NEG
79987: PUSH
79988: LD_INT 2
79990: NEG
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 0
79998: PUSH
79999: LD_INT 2
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 2
80020: PUSH
80021: LD_INT 0
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 2
80040: PUSH
80041: LD_INT 2
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: LD_INT 2
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 0
80060: PUSH
80061: LD_INT 2
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 1
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 2
80081: NEG
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 2
80104: NEG
80105: PUSH
80106: LD_INT 2
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80135: LD_ADDR_VAR 0 18
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: LD_INT 0
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 0
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 1
80193: NEG
80194: PUSH
80195: LD_INT 0
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: LD_INT 1
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 1
80216: NEG
80217: PUSH
80218: LD_INT 2
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 0
80228: PUSH
80229: LD_INT 2
80231: NEG
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 2
80270: PUSH
80271: LD_INT 2
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 1
80280: PUSH
80281: LD_INT 2
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 0
80290: PUSH
80291: LD_INT 2
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 1
80300: NEG
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 2
80311: NEG
80312: PUSH
80313: LD_INT 0
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 2
80334: NEG
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80365: LD_ADDR_VAR 0 19
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 0
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: LD_INT 1
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: LD_INT 0
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 1
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 1
80423: NEG
80424: PUSH
80425: LD_INT 0
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 1
80446: NEG
80447: PUSH
80448: LD_INT 2
80450: NEG
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: LD_INT 2
80461: NEG
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 1
80472: NEG
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 2
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: LD_INT 1
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: LD_INT 2
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: LD_INT 2
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: LD_INT 2
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 1
80530: NEG
80531: PUSH
80532: LD_INT 1
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 2
80541: NEG
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 2
80564: NEG
80565: PUSH
80566: LD_INT 2
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80595: LD_ADDR_VAR 0 20
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 0
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: PUSH
80624: LD_INT 0
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PUSH
80631: LD_INT 1
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 0
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: LD_INT 0
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 1
80668: NEG
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 1
80676: NEG
80677: PUSH
80678: LD_INT 2
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 2
80710: PUSH
80711: LD_INT 0
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 2
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 2
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 1
80740: PUSH
80741: LD_INT 2
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: LD_INT 2
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 1
80760: NEG
80761: PUSH
80762: LD_INT 1
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 2
80771: NEG
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: LD_INT 1
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: NEG
80795: PUSH
80796: LD_INT 2
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80825: LD_ADDR_VAR 0 21
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: LD_INT 0
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 0
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 1
80853: PUSH
80854: LD_INT 0
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 1
80863: PUSH
80864: LD_INT 1
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 0
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 1
80883: NEG
80884: PUSH
80885: LD_INT 0
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 1
80906: NEG
80907: PUSH
80908: LD_INT 2
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 0
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: LD_INT 1
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 2
80940: PUSH
80941: LD_INT 0
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 1
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: LD_INT 2
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 1
80970: PUSH
80971: LD_INT 2
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 0
80980: PUSH
80981: LD_INT 2
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: NEG
80991: PUSH
80992: LD_INT 1
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: LD_INT 0
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: LD_INT 1
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: NEG
81025: PUSH
81026: LD_INT 2
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81055: LD_ADDR_VAR 0 22
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 1
81083: PUSH
81084: LD_INT 0
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 0
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 1
81113: NEG
81114: PUSH
81115: LD_INT 0
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PUSH
81122: LD_INT 1
81124: NEG
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 1
81136: NEG
81137: PUSH
81138: LD_INT 2
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 2
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 2
81180: PUSH
81181: LD_INT 1
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 2
81190: PUSH
81191: LD_INT 2
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 1
81200: PUSH
81201: LD_INT 2
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: LD_INT 2
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: LD_INT 1
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 2
81242: NEG
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 2
81254: NEG
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81285: LD_ADDR_VAR 0 23
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 0
81302: PUSH
81303: LD_INT 1
81305: NEG
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 1
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 1
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: LD_INT 1
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: LD_INT 0
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 1
81354: NEG
81355: PUSH
81356: LD_INT 1
81358: NEG
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 1
81366: NEG
81367: PUSH
81368: LD_INT 2
81370: NEG
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 1
81389: PUSH
81390: LD_INT 1
81392: NEG
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 2
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 2
81410: PUSH
81411: LD_INT 1
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: LD_INT 2
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 2
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 0
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: NEG
81451: PUSH
81452: LD_INT 1
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: NEG
81462: PUSH
81463: LD_INT 0
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 2
81472: NEG
81473: PUSH
81474: LD_INT 1
81476: NEG
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 2
81484: NEG
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 2
81496: NEG
81497: PUSH
81498: LD_INT 3
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 1
81508: NEG
81509: PUSH
81510: LD_INT 3
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 1
81520: PUSH
81521: LD_INT 2
81523: NEG
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 2
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81565: LD_ADDR_VAR 0 24
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: LD_INT 1
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: LD_INT 0
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: LD_INT 1
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: NEG
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 1
81634: NEG
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 1
81646: NEG
81647: PUSH
81648: LD_INT 2
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 0
81658: PUSH
81659: LD_INT 2
81661: NEG
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 1
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 2
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 2
81690: PUSH
81691: LD_INT 1
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: LD_INT 2
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 1
81710: PUSH
81711: LD_INT 2
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: LD_INT 2
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: NEG
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 2
81741: NEG
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: NEG
81753: PUSH
81754: LD_INT 1
81756: NEG
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 2
81764: NEG
81765: PUSH
81766: LD_INT 2
81768: NEG
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: LD_INT 2
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 2
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 3
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 3
81808: PUSH
81809: LD_INT 2
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81841: LD_ADDR_VAR 0 25
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: LD_INT 1
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: LD_INT 0
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 0
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 1
81899: NEG
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 1
81910: NEG
81911: PUSH
81912: LD_INT 1
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: LD_INT 2
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 1
81945: PUSH
81946: LD_INT 1
81948: NEG
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 2
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 2
81966: PUSH
81967: LD_INT 1
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 2
81976: PUSH
81977: LD_INT 2
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 1
81986: PUSH
81987: LD_INT 2
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: NEG
82007: PUSH
82008: LD_INT 1
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 2
82028: NEG
82029: PUSH
82030: LD_INT 1
82032: NEG
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 2
82040: NEG
82041: PUSH
82042: LD_INT 2
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 3
82052: PUSH
82053: LD_INT 1
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: PUSH
82063: LD_INT 2
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 2
82072: PUSH
82073: LD_INT 3
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: PUSH
82083: LD_INT 3
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82115: LD_ADDR_VAR 0 26
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: LD_INT 0
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: LD_INT 0
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 1
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: LD_INT 1
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: LD_INT 0
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 1
82184: NEG
82185: PUSH
82186: LD_INT 1
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 1
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: LD_INT 0
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 2
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: LD_INT 2
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 1
82260: PUSH
82261: LD_INT 2
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: LD_INT 2
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: NEG
82292: PUSH
82293: LD_INT 0
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: LD_INT 1
82306: NEG
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 2
82326: PUSH
82327: LD_INT 3
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 1
82336: PUSH
82337: LD_INT 3
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 1
82346: NEG
82347: PUSH
82348: LD_INT 2
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: NEG
82358: PUSH
82359: LD_INT 1
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82391: LD_ADDR_VAR 0 27
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: LD_INT 1
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 1
82419: PUSH
82420: LD_INT 0
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 1
82429: PUSH
82430: LD_INT 1
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: LD_INT 1
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 1
82449: NEG
82450: PUSH
82451: LD_INT 0
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 2
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 0
82484: PUSH
82485: LD_INT 2
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 2
82506: PUSH
82507: LD_INT 0
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 2
82516: PUSH
82517: LD_INT 1
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 2
82526: PUSH
82527: LD_INT 2
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 1
82536: PUSH
82537: LD_INT 2
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: LD_INT 2
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 1
82556: NEG
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: NEG
82568: PUSH
82569: LD_INT 0
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 2
82578: NEG
82579: PUSH
82580: LD_INT 1
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: LD_INT 2
82594: NEG
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 1
82602: NEG
82603: PUSH
82604: LD_INT 2
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 2
82613: NEG
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 3
82624: NEG
82625: PUSH
82626: LD_INT 1
82628: NEG
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 3
82636: NEG
82637: PUSH
82638: LD_INT 2
82640: NEG
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82671: LD_ADDR_VAR 0 28
82675: PUSH
82676: LD_INT 0
82678: PUSH
82679: LD_INT 0
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 0
82688: PUSH
82689: LD_INT 1
82691: NEG
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: LD_INT 0
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 0
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 1
82729: NEG
82730: PUSH
82731: LD_INT 0
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: NEG
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: LD_INT 2
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: LD_INT 2
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: PUSH
82776: LD_INT 1
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: PUSH
82787: LD_INT 0
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: LD_INT 1
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: LD_INT 1
82816: PUSH
82817: LD_INT 2
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 0
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 2
82847: NEG
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 2
82858: NEG
82859: PUSH
82860: LD_INT 1
82862: NEG
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 2
82870: NEG
82871: PUSH
82872: LD_INT 2
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: NEG
82883: PUSH
82884: LD_INT 3
82886: NEG
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 1
82894: NEG
82895: PUSH
82896: LD_INT 3
82898: NEG
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 3
82906: NEG
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 3
82918: NEG
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82953: LD_ADDR_VAR 0 29
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: LD_INT 0
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: PUSH
82992: LD_INT 1
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: LD_INT 1
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: NEG
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: NEG
83023: PUSH
83024: LD_INT 1
83026: NEG
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 1
83034: NEG
83035: PUSH
83036: LD_INT 2
83038: NEG
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: LD_INT 2
83049: NEG
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: LD_INT 1
83060: NEG
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 2
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: LD_INT 2
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 0
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: NEG
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: LD_INT 1
83123: NEG
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 2
83131: NEG
83132: PUSH
83133: LD_INT 2
83135: NEG
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 2
83143: NEG
83144: PUSH
83145: LD_INT 3
83147: NEG
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: LD_INT 1
83158: NEG
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 3
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: LD_INT 3
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: LD_INT 2
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 3
83197: NEG
83198: PUSH
83199: LD_INT 2
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83232: LD_ADDR_VAR 0 30
83236: PUSH
83237: LD_INT 0
83239: PUSH
83240: LD_INT 0
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: LD_INT 1
83252: NEG
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: LD_INT 0
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 1
83270: PUSH
83271: LD_INT 1
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: LD_INT 1
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: LD_INT 2
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 1
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 2
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 2
83357: PUSH
83358: LD_INT 1
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 2
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: LD_INT 2
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 1
83387: NEG
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 2
83398: NEG
83399: PUSH
83400: LD_INT 0
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 2
83409: NEG
83410: PUSH
83411: LD_INT 1
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: NEG
83422: PUSH
83423: LD_INT 3
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 1
83433: PUSH
83434: LD_INT 2
83436: NEG
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 3
83444: PUSH
83445: LD_INT 2
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 1
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 3
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83510: LD_ADDR_VAR 0 31
83514: PUSH
83515: LD_INT 0
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: LD_INT 1
83530: NEG
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 0
83558: PUSH
83559: LD_INT 1
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 1
83568: NEG
83569: PUSH
83570: LD_INT 0
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: LD_INT 1
83583: NEG
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: NEG
83592: PUSH
83593: LD_INT 2
83595: NEG
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 1
83606: NEG
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 2
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 2
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: LD_INT 2
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: LD_INT 2
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: LD_INT 1
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: LD_INT 1
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 2
83687: NEG
83688: PUSH
83689: LD_INT 2
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 2
83699: NEG
83700: PUSH
83701: LD_INT 3
83703: NEG
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 2
83711: PUSH
83712: LD_INT 1
83714: NEG
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 3
83722: PUSH
83723: LD_INT 1
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 3
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 1
83742: NEG
83743: PUSH
83744: LD_INT 2
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 3
83753: NEG
83754: PUSH
83755: LD_INT 2
83757: NEG
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83788: LD_ADDR_VAR 0 32
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: LD_INT 0
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: LD_INT 1
83808: NEG
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: PUSH
83827: LD_INT 1
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: LD_INT 1
83861: NEG
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 1
83869: NEG
83870: PUSH
83871: LD_INT 2
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 0
83881: PUSH
83882: LD_INT 2
83884: NEG
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: LD_INT 1
83895: NEG
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 2
83903: PUSH
83904: LD_INT 1
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 2
83913: PUSH
83914: LD_INT 2
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: PUSH
83924: LD_INT 2
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 0
83933: PUSH
83934: LD_INT 2
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 2
83954: NEG
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 2
83965: NEG
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 3
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: LD_INT 2
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 3
84000: PUSH
84001: LD_INT 2
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: PUSH
84008: LD_INT 2
84010: PUSH
84011: LD_INT 3
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: LD_INT 1
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 3
84031: NEG
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84066: LD_ADDR_VAR 0 33
84070: PUSH
84071: LD_INT 0
84073: PUSH
84074: LD_INT 0
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: LD_INT 1
84086: NEG
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 1
84094: PUSH
84095: LD_INT 0
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: PUSH
84105: LD_INT 1
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 1
84124: NEG
84125: PUSH
84126: LD_INT 0
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 1
84135: NEG
84136: PUSH
84137: LD_INT 1
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: NEG
84148: PUSH
84149: LD_INT 2
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: LD_INT 1
84162: NEG
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 2
84170: PUSH
84171: LD_INT 0
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PUSH
84178: LD_INT 2
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: LD_INT 2
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 1
84210: NEG
84211: PUSH
84212: LD_INT 1
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: NEG
84222: PUSH
84223: LD_INT 0
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 2
84232: NEG
84233: PUSH
84234: LD_INT 1
84236: NEG
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 2
84244: NEG
84245: PUSH
84246: LD_INT 2
84248: NEG
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 2
84256: NEG
84257: PUSH
84258: LD_INT 3
84260: NEG
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 2
84268: PUSH
84269: LD_INT 1
84271: NEG
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 3
84279: PUSH
84280: LD_INT 1
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: LD_INT 1
84289: PUSH
84290: LD_INT 3
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 1
84299: NEG
84300: PUSH
84301: LD_INT 2
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 3
84310: NEG
84311: PUSH
84312: LD_INT 2
84314: NEG
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84345: LD_ADDR_VAR 0 34
84349: PUSH
84350: LD_INT 0
84352: PUSH
84353: LD_INT 0
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 0
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: PUSH
84374: LD_INT 0
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 1
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 1
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: LD_INT 0
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: NEG
84415: PUSH
84416: LD_INT 1
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: NEG
84427: PUSH
84428: LD_INT 2
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 0
84438: PUSH
84439: LD_INT 2
84441: NEG
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 1
84449: PUSH
84450: LD_INT 1
84452: NEG
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: LD_INT 1
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: LD_INT 2
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 1
84480: PUSH
84481: LD_INT 2
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 1
84490: NEG
84491: PUSH
84492: LD_INT 1
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 2
84512: NEG
84513: PUSH
84514: LD_INT 1
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 2
84524: NEG
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 1
84536: NEG
84537: PUSH
84538: LD_INT 3
84540: NEG
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 2
84551: NEG
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 3
84559: PUSH
84560: LD_INT 2
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: LD_INT 3
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 2
84579: NEG
84580: PUSH
84581: LD_INT 1
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 3
84590: NEG
84591: PUSH
84592: LD_INT 1
84594: NEG
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84625: LD_ADDR_VAR 0 35
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 0
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: LD_INT 1
84720: NEG
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84737: LD_ADDR_VAR 0 36
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: LD_INT 0
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: NEG
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: LD_INT 2
84822: NEG
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 1
84830: PUSH
84831: LD_INT 2
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84849: LD_ADDR_VAR 0 37
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 0
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: PUSH
84931: LD_INT 1
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84961: LD_ADDR_VAR 0 38
84965: PUSH
84966: LD_INT 0
84968: PUSH
84969: LD_INT 0
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 2
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 2
85052: NEG
85053: PUSH
85054: LD_INT 1
85056: NEG
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85073: LD_ADDR_VAR 0 39
85077: PUSH
85078: LD_INT 0
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: NEG
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: LD_INT 2
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85185: LD_ADDR_VAR 0 40
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 0
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: LD_INT 1
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: NEG
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 1
85258: NEG
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85297: LD_ADDR_VAR 0 41
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: LD_INT 0
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: LD_INT 1
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: NEG
85379: PUSH
85380: LD_INT 2
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 1
85390: PUSH
85391: LD_INT 1
85393: NEG
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 2
85401: PUSH
85402: LD_INT 0
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 2
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 1
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 1
85441: NEG
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 2
85452: NEG
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 2
85463: NEG
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 2
85475: NEG
85476: PUSH
85477: LD_INT 2
85479: NEG
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 2
85487: NEG
85488: PUSH
85489: LD_INT 3
85491: NEG
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: LD_INT 1
85502: NEG
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 3
85510: PUSH
85511: LD_INT 0
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 3
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 3
85530: PUSH
85531: LD_INT 2
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 3
85540: PUSH
85541: LD_INT 3
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: PUSH
85551: LD_INT 3
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 2
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 3
85571: NEG
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 3
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: NEG
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 3
85594: NEG
85595: PUSH
85596: LD_INT 2
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 3
85606: NEG
85607: PUSH
85608: LD_INT 3
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85647: LD_ADDR_VAR 0 42
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 1
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 0
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 1
85705: NEG
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 1
85716: NEG
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 1
85728: NEG
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 0
85740: PUSH
85741: LD_INT 2
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: PUSH
85752: LD_INT 1
85754: NEG
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: LD_INT 1
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 2
85772: PUSH
85773: LD_INT 2
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 1
85782: PUSH
85783: LD_INT 2
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: LD_INT 2
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 2
85813: NEG
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 2
85825: NEG
85826: PUSH
85827: LD_INT 2
85829: NEG
85830: PUSH
85831: EMPTY
85832: LIST
85833: LIST
85834: PUSH
85835: LD_INT 2
85837: NEG
85838: PUSH
85839: LD_INT 3
85841: NEG
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: LD_INT 3
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 0
85861: PUSH
85862: LD_INT 3
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: LD_INT 2
85875: NEG
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 3
85883: PUSH
85884: LD_INT 2
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 3
85893: PUSH
85894: LD_INT 3
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 2
85903: PUSH
85904: LD_INT 3
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: PUSH
85914: LD_INT 3
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 0
85923: PUSH
85924: LD_INT 3
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: NEG
85934: PUSH
85935: LD_INT 2
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 3
85944: NEG
85945: PUSH
85946: LD_INT 2
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 3
85956: NEG
85957: PUSH
85958: LD_INT 3
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85997: LD_ADDR_VAR 0 43
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: LD_INT 0
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 1
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: LD_INT 1
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 0
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 1
86055: NEG
86056: PUSH
86057: LD_INT 0
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: LD_INT 1
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 1
86078: NEG
86079: PUSH
86080: LD_INT 2
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: LD_INT 2
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 1
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 2
86112: PUSH
86113: LD_INT 0
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 2
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: LD_INT 2
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 1
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 2
86163: NEG
86164: PUSH
86165: LD_INT 0
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 2
86174: NEG
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 1
86186: NEG
86187: PUSH
86188: LD_INT 3
86190: NEG
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 0
86198: PUSH
86199: LD_INT 3
86201: NEG
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: LD_INT 2
86212: NEG
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 2
86220: PUSH
86221: LD_INT 1
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 3
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 3
86241: PUSH
86242: LD_INT 1
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: LD_INT 3
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 0
86261: PUSH
86262: LD_INT 3
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: NEG
86272: PUSH
86273: LD_INT 2
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 2
86282: NEG
86283: PUSH
86284: LD_INT 1
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 3
86293: NEG
86294: PUSH
86295: LD_INT 0
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 3
86304: NEG
86305: PUSH
86306: LD_INT 1
86308: NEG
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86345: LD_ADDR_VAR 0 44
86349: PUSH
86350: LD_INT 0
86352: PUSH
86353: LD_INT 0
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: LD_INT 1
86365: NEG
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 1
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 1
86383: PUSH
86384: LD_INT 1
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 0
86393: PUSH
86394: LD_INT 1
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: LD_INT 0
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 1
86414: NEG
86415: PUSH
86416: LD_INT 1
86418: NEG
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 1
86426: NEG
86427: PUSH
86428: LD_INT 2
86430: NEG
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 1
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 2
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 2
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 2
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 2
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 1
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 2
86500: NEG
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 2
86511: NEG
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 2
86523: NEG
86524: PUSH
86525: LD_INT 2
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 2
86535: NEG
86536: PUSH
86537: LD_INT 3
86539: NEG
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 2
86547: PUSH
86548: LD_INT 1
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 3
86558: PUSH
86559: LD_INT 0
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PUSH
86566: LD_INT 3
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: LD_INT 3
86578: PUSH
86579: LD_INT 2
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: PUSH
86586: LD_INT 3
86588: PUSH
86589: LD_INT 3
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 2
86598: PUSH
86599: LD_INT 3
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 2
86608: NEG
86609: PUSH
86610: LD_INT 1
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 3
86619: NEG
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 3
86630: NEG
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 3
86642: NEG
86643: PUSH
86644: LD_INT 2
86646: NEG
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 3
86654: NEG
86655: PUSH
86656: LD_INT 3
86658: NEG
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86695: LD_ADDR_VAR 0 45
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: LD_INT 1
86715: NEG
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 1
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 1
86733: PUSH
86734: LD_INT 1
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: NEG
86765: PUSH
86766: LD_INT 1
86768: NEG
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 2
86780: NEG
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: LD_INT 2
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: PUSH
86800: LD_INT 1
86802: NEG
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: LD_INT 1
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 2
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 1
86830: PUSH
86831: LD_INT 2
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: LD_INT 2
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 2
86861: NEG
86862: PUSH
86863: LD_INT 1
86865: NEG
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 2
86873: NEG
86874: PUSH
86875: LD_INT 2
86877: NEG
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 2
86885: NEG
86886: PUSH
86887: LD_INT 3
86889: NEG
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 1
86897: NEG
86898: PUSH
86899: LD_INT 3
86901: NEG
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 0
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 1
86920: PUSH
86921: LD_INT 2
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 3
86931: PUSH
86932: LD_INT 2
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 3
86941: PUSH
86942: LD_INT 3
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: LD_INT 3
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 0
86971: PUSH
86972: LD_INT 3
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 1
86981: NEG
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 3
86992: NEG
86993: PUSH
86994: LD_INT 2
86996: NEG
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 3
87004: NEG
87005: PUSH
87006: LD_INT 3
87008: NEG
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87045: LD_ADDR_VAR 0 46
87049: PUSH
87050: LD_INT 0
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: LD_INT 1
87065: NEG
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 1
87073: PUSH
87074: LD_INT 0
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 1
87083: PUSH
87084: LD_INT 1
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 1
87103: NEG
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: LD_INT 1
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 2
87130: NEG
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: LD_INT 2
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 2
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: PUSH
87168: LD_INT 2
87170: PUSH
87171: LD_INT 1
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 0
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 1
87200: NEG
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 2
87211: NEG
87212: PUSH
87213: LD_INT 0
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 2
87222: NEG
87223: PUSH
87224: LD_INT 1
87226: NEG
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 1
87234: NEG
87235: PUSH
87236: LD_INT 3
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 2
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 2
87268: PUSH
87269: LD_INT 1
87271: NEG
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 3
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 3
87289: PUSH
87290: LD_INT 1
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: LD_INT 3
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 0
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: NEG
87320: PUSH
87321: LD_INT 2
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 2
87330: NEG
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 3
87341: NEG
87342: PUSH
87343: LD_INT 0
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 3
87352: NEG
87353: PUSH
87354: LD_INT 1
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87393: LD_ADDR_VAR 0 47
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: LD_INT 1
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: LD_INT 0
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 2
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 0
87486: PUSH
87487: LD_INT 2
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: NEG
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: NEG
87521: PUSH
87522: LD_INT 2
87524: NEG
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87544: LD_ADDR_VAR 0 48
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: LD_INT 1
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 1
87602: NEG
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: LD_INT 1
87617: NEG
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: LD_INT 2
87629: NEG
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: LD_INT 2
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 1
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 2
87659: PUSH
87660: LD_INT 0
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87691: LD_ADDR_VAR 0 49
87695: PUSH
87696: LD_INT 0
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: LD_INT 1
87711: NEG
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: PUSH
87717: LD_INT 1
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 1
87729: PUSH
87730: LD_INT 1
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 0
87739: PUSH
87740: LD_INT 1
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 1
87749: NEG
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 1
87760: NEG
87761: PUSH
87762: LD_INT 1
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: LD_INT 1
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 2
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 2
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 2
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87835: LD_ADDR_VAR 0 50
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: LD_INT 1
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: LD_INT 1
87908: NEG
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: LD_INT 1
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 2
87926: PUSH
87927: LD_INT 2
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 1
87936: PUSH
87937: LD_INT 2
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: LD_INT 2
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87979: LD_ADDR_VAR 0 51
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 0
87996: PUSH
87997: LD_INT 1
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 1
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 1
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: LD_INT 1
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 1
88037: NEG
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 1
88060: PUSH
88061: LD_INT 2
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: LD_INT 2
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88126: LD_ADDR_VAR 0 52
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 0
88143: PUSH
88144: LD_INT 1
88146: NEG
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 1
88164: PUSH
88165: LD_INT 1
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: LD_INT 1
88184: NEG
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 1
88195: NEG
88196: PUSH
88197: LD_INT 1
88199: NEG
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: NEG
88208: PUSH
88209: LD_INT 2
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 1
88219: NEG
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 2
88230: NEG
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: NEG
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 2
88253: NEG
88254: PUSH
88255: LD_INT 2
88257: NEG
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88277: LD_ADDR_VAR 0 53
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 0
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 1
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 1
88335: NEG
88336: PUSH
88337: LD_INT 0
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: NEG
88347: PUSH
88348: LD_INT 1
88350: NEG
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: NEG
88359: PUSH
88360: LD_INT 2
88362: NEG
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: LD_INT 2
88373: NEG
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 1
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 2
88392: PUSH
88393: LD_INT 0
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 2
88402: PUSH
88403: LD_INT 1
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 2
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: LD_INT 2
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 1
88442: NEG
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 2
88453: NEG
88454: PUSH
88455: LD_INT 0
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 2
88476: NEG
88477: PUSH
88478: LD_INT 2
88480: NEG
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88507: LD_ADDR_VAR 0 54
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 0
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 0
88524: PUSH
88525: LD_INT 1
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: PUSH
88536: LD_INT 0
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 1
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 0
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 1
88565: NEG
88566: PUSH
88567: LD_INT 0
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 1
88576: NEG
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 1
88588: NEG
88589: PUSH
88590: LD_INT 2
88592: NEG
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 0
88600: PUSH
88601: LD_INT 2
88603: NEG
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: LD_INT 1
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: LD_INT 0
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 2
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 2
88642: PUSH
88643: LD_INT 2
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 1
88652: PUSH
88653: LD_INT 2
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 0
88662: PUSH
88663: LD_INT 2
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: NEG
88673: PUSH
88674: LD_INT 1
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 2
88683: NEG
88684: PUSH
88685: LD_INT 0
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: LD_INT 1
88698: NEG
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 2
88706: NEG
88707: PUSH
88708: LD_INT 2
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88737: LD_ADDR_VAR 0 55
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 0
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: PUSH
88766: LD_INT 0
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 1
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 0
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: NEG
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 1
88806: NEG
88807: PUSH
88808: LD_INT 1
88810: NEG
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: LD_INT 1
88818: NEG
88819: PUSH
88820: LD_INT 2
88822: NEG
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 0
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: LD_INT 1
88844: NEG
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 2
88852: PUSH
88853: LD_INT 0
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 2
88862: PUSH
88863: LD_INT 1
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: LD_INT 2
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: PUSH
88883: LD_INT 2
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: LD_INT 2
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: NEG
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 2
88913: NEG
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 2
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88967: LD_ADDR_VAR 0 56
88971: PUSH
88972: LD_INT 0
88974: PUSH
88975: LD_INT 0
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 1
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 0
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 1
89025: NEG
89026: PUSH
89027: LD_INT 0
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 1
89036: NEG
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: LD_INT 2
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: LD_INT 2
89063: NEG
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 2
89082: PUSH
89083: LD_INT 0
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 2
89092: PUSH
89093: LD_INT 1
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 2
89102: PUSH
89103: LD_INT 2
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: PUSH
89113: LD_INT 2
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 2
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: NEG
89144: PUSH
89145: LD_INT 0
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 2
89154: NEG
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 2
89166: NEG
89167: PUSH
89168: LD_INT 2
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89197: LD_ADDR_VAR 0 57
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: LD_INT 0
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 1
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: LD_INT 1
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 1
89255: NEG
89256: PUSH
89257: LD_INT 0
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 1
89270: NEG
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: LD_INT 2
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 0
89290: PUSH
89291: LD_INT 2
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: PUSH
89302: LD_INT 1
89304: NEG
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 2
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 2
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 2
89332: PUSH
89333: LD_INT 2
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 2
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 0
89352: PUSH
89353: LD_INT 2
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 1
89362: NEG
89363: PUSH
89364: LD_INT 1
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: LD_INT 0
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 2
89396: NEG
89397: PUSH
89398: LD_INT 2
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89427: LD_ADDR_VAR 0 58
89431: PUSH
89432: LD_INT 0
89434: PUSH
89435: LD_INT 0
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: LD_INT 1
89447: NEG
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: LD_INT 0
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: LD_INT 1
89465: PUSH
89466: LD_INT 1
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 0
89475: PUSH
89476: LD_INT 1
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: LD_INT 1
89485: NEG
89486: PUSH
89487: LD_INT 0
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: LD_INT 1
89508: NEG
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 0
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 1
89531: PUSH
89532: LD_INT 1
89534: NEG
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 2
89542: PUSH
89543: LD_INT 0
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 2
89552: PUSH
89553: LD_INT 1
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 2
89562: PUSH
89563: LD_INT 2
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: PUSH
89573: LD_INT 2
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 0
89582: PUSH
89583: LD_INT 2
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 2
89603: NEG
89604: PUSH
89605: LD_INT 0
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 2
89614: NEG
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: NEG
89627: PUSH
89628: LD_INT 2
89630: NEG
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89657: LD_ADDR_VAR 0 59
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: LD_INT 0
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 0
89674: PUSH
89675: LD_INT 1
89677: NEG
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 1
89685: PUSH
89686: LD_INT 0
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 1
89695: PUSH
89696: LD_INT 1
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: LD_INT 1
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 1
89715: NEG
89716: PUSH
89717: LD_INT 0
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: LD_INT 1
89730: NEG
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89745: LD_ADDR_VAR 0 60
89749: PUSH
89750: LD_INT 0
89752: PUSH
89753: LD_INT 0
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: LD_INT 1
89765: NEG
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 1
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 1
89783: PUSH
89784: LD_INT 1
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 1
89803: NEG
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 1
89814: NEG
89815: PUSH
89816: LD_INT 1
89818: NEG
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89833: LD_ADDR_VAR 0 61
89837: PUSH
89838: LD_INT 0
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: LD_INT 1
89853: NEG
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 1
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: LD_INT 1
89906: NEG
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89921: LD_ADDR_VAR 0 62
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: LD_INT 0
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: LD_INT 1
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: LD_INT 0
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: LD_INT 1
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 0
89969: PUSH
89970: LD_INT 1
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 1
89979: NEG
89980: PUSH
89981: LD_INT 0
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 1
89990: NEG
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90009: LD_ADDR_VAR 0 63
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 1
90037: PUSH
90038: LD_INT 0
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: PUSH
90048: LD_INT 1
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 1
90067: NEG
90068: PUSH
90069: LD_INT 0
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: LD_INT 1
90082: NEG
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90097: LD_ADDR_VAR 0 64
90101: PUSH
90102: LD_INT 0
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: LD_INT 1
90125: PUSH
90126: LD_INT 0
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: NEG
90156: PUSH
90157: LD_INT 0
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: ST_TO_ADDR
// end ; 1 :
90185: GO 96082
90187: LD_INT 1
90189: DOUBLE
90190: EQUAL
90191: IFTRUE 90195
90193: GO 92818
90195: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90196: LD_ADDR_VAR 0 11
90200: PUSH
90201: LD_INT 1
90203: NEG
90204: PUSH
90205: LD_INT 3
90207: NEG
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 0
90215: PUSH
90216: LD_INT 3
90218: NEG
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 1
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: LIST
90239: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90240: LD_ADDR_VAR 0 12
90244: PUSH
90245: LD_INT 2
90247: PUSH
90248: LD_INT 1
90250: NEG
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 3
90258: PUSH
90259: LD_INT 0
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 3
90268: PUSH
90269: LD_INT 1
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: LIST
90280: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90281: LD_ADDR_VAR 0 13
90285: PUSH
90286: LD_INT 3
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 3
90298: PUSH
90299: LD_INT 3
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 2
90308: PUSH
90309: LD_INT 3
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: LIST
90320: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90321: LD_ADDR_VAR 0 14
90325: PUSH
90326: LD_INT 1
90328: PUSH
90329: LD_INT 3
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 0
90338: PUSH
90339: LD_INT 3
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: PUSH
90346: LD_INT 1
90348: NEG
90349: PUSH
90350: LD_INT 2
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90362: LD_ADDR_VAR 0 15
90366: PUSH
90367: LD_INT 2
90369: NEG
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 3
90380: NEG
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 3
90391: NEG
90392: PUSH
90393: LD_INT 1
90395: NEG
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90406: LD_ADDR_VAR 0 16
90410: PUSH
90411: LD_INT 2
90413: NEG
90414: PUSH
90415: LD_INT 3
90417: NEG
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 3
90425: NEG
90426: PUSH
90427: LD_INT 2
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 3
90437: NEG
90438: PUSH
90439: LD_INT 3
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: LIST
90451: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90452: LD_ADDR_VAR 0 17
90456: PUSH
90457: LD_INT 1
90459: NEG
90460: PUSH
90461: LD_INT 3
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 3
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 2
90485: NEG
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: LIST
90495: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90496: LD_ADDR_VAR 0 18
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: LD_INT 1
90506: NEG
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 3
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 3
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: LIST
90536: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90537: LD_ADDR_VAR 0 19
90541: PUSH
90542: LD_INT 3
90544: PUSH
90545: LD_INT 2
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 3
90554: PUSH
90555: LD_INT 3
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 2
90564: PUSH
90565: LD_INT 3
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: LIST
90576: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90577: LD_ADDR_VAR 0 20
90581: PUSH
90582: LD_INT 1
90584: PUSH
90585: LD_INT 3
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 0
90594: PUSH
90595: LD_INT 3
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PUSH
90602: LD_INT 1
90604: NEG
90605: PUSH
90606: LD_INT 2
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90618: LD_ADDR_VAR 0 21
90622: PUSH
90623: LD_INT 2
90625: NEG
90626: PUSH
90627: LD_INT 1
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 3
90636: NEG
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 3
90647: NEG
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: LIST
90661: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90662: LD_ADDR_VAR 0 22
90666: PUSH
90667: LD_INT 2
90669: NEG
90670: PUSH
90671: LD_INT 3
90673: NEG
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 3
90681: NEG
90682: PUSH
90683: LD_INT 2
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 3
90693: NEG
90694: PUSH
90695: LD_INT 3
90697: NEG
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: LIST
90707: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90708: LD_ADDR_VAR 0 23
90712: PUSH
90713: LD_INT 0
90715: PUSH
90716: LD_INT 3
90718: NEG
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 1
90726: NEG
90727: PUSH
90728: LD_INT 4
90730: NEG
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: LD_INT 3
90741: NEG
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: LIST
90751: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90752: LD_ADDR_VAR 0 24
90756: PUSH
90757: LD_INT 3
90759: PUSH
90760: LD_INT 0
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 3
90769: PUSH
90770: LD_INT 1
90772: NEG
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 4
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: LIST
90792: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90793: LD_ADDR_VAR 0 25
90797: PUSH
90798: LD_INT 3
90800: PUSH
90801: LD_INT 3
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 4
90810: PUSH
90811: LD_INT 3
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 3
90820: PUSH
90821: LD_INT 4
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: LIST
90832: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90833: LD_ADDR_VAR 0 26
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: LD_INT 3
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: PUSH
90851: LD_INT 4
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 1
90860: NEG
90861: PUSH
90862: LD_INT 3
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: LIST
90873: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90874: LD_ADDR_VAR 0 27
90878: PUSH
90879: LD_INT 3
90881: NEG
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 3
90892: NEG
90893: PUSH
90894: LD_INT 1
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 4
90903: NEG
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: LIST
90917: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90918: LD_ADDR_VAR 0 28
90922: PUSH
90923: LD_INT 3
90925: NEG
90926: PUSH
90927: LD_INT 3
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 3
90937: NEG
90938: PUSH
90939: LD_INT 4
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 4
90949: NEG
90950: PUSH
90951: LD_INT 3
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: LIST
90963: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90964: LD_ADDR_VAR 0 29
90968: PUSH
90969: LD_INT 1
90971: NEG
90972: PUSH
90973: LD_INT 3
90975: NEG
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 0
90983: PUSH
90984: LD_INT 3
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 1
90994: PUSH
90995: LD_INT 2
90997: NEG
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 1
91005: NEG
91006: PUSH
91007: LD_INT 4
91009: NEG
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 0
91017: PUSH
91018: LD_INT 4
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: LD_INT 3
91031: NEG
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: LD_INT 5
91043: NEG
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 5
91054: NEG
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 1
91062: PUSH
91063: LD_INT 4
91065: NEG
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: LD_INT 6
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 6
91088: NEG
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 1
91096: PUSH
91097: LD_INT 5
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91119: LD_ADDR_VAR 0 30
91123: PUSH
91124: LD_INT 2
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 3
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 3
91147: PUSH
91148: LD_INT 1
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 4
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 4
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 4
91188: PUSH
91189: LD_INT 1
91191: NEG
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 5
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 5
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 5
91219: PUSH
91220: LD_INT 1
91222: NEG
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 6
91230: PUSH
91231: LD_INT 0
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 6
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91262: LD_ADDR_VAR 0 31
91266: PUSH
91267: LD_INT 3
91269: PUSH
91270: LD_INT 2
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 3
91279: PUSH
91280: LD_INT 3
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 2
91289: PUSH
91290: LD_INT 3
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 4
91299: PUSH
91300: LD_INT 3
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 4
91309: PUSH
91310: LD_INT 4
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 3
91319: PUSH
91320: LD_INT 4
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 5
91329: PUSH
91330: LD_INT 4
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 5
91339: PUSH
91340: LD_INT 5
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 4
91349: PUSH
91350: LD_INT 5
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 6
91359: PUSH
91360: LD_INT 5
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 6
91369: PUSH
91370: LD_INT 6
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 5
91379: PUSH
91380: LD_INT 6
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91401: LD_ADDR_VAR 0 32
91405: PUSH
91406: LD_INT 1
91408: PUSH
91409: LD_INT 3
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 1
91428: NEG
91429: PUSH
91430: LD_INT 2
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 1
91439: PUSH
91440: LD_INT 4
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 0
91449: PUSH
91450: LD_INT 4
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 1
91459: NEG
91460: PUSH
91461: LD_INT 3
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: LD_INT 5
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: LD_INT 5
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 1
91490: NEG
91491: PUSH
91492: LD_INT 4
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: PUSH
91502: LD_INT 6
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: LD_INT 6
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 1
91521: NEG
91522: PUSH
91523: LD_INT 5
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91544: LD_ADDR_VAR 0 33
91548: PUSH
91549: LD_INT 2
91551: NEG
91552: PUSH
91553: LD_INT 1
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 3
91562: NEG
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: NEG
91574: PUSH
91575: LD_INT 1
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 3
91585: NEG
91586: PUSH
91587: LD_INT 1
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 4
91596: NEG
91597: PUSH
91598: LD_INT 0
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 4
91607: NEG
91608: PUSH
91609: LD_INT 1
91611: NEG
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 4
91619: NEG
91620: PUSH
91621: LD_INT 1
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 5
91630: NEG
91631: PUSH
91632: LD_INT 0
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 5
91641: NEG
91642: PUSH
91643: LD_INT 1
91645: NEG
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 5
91653: NEG
91654: PUSH
91655: LD_INT 1
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 6
91664: NEG
91665: PUSH
91666: LD_INT 0
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 6
91675: NEG
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91699: LD_ADDR_VAR 0 34
91703: PUSH
91704: LD_INT 2
91706: NEG
91707: PUSH
91708: LD_INT 3
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 3
91718: NEG
91719: PUSH
91720: LD_INT 2
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 3
91730: NEG
91731: PUSH
91732: LD_INT 3
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 3
91742: NEG
91743: PUSH
91744: LD_INT 4
91746: NEG
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 4
91754: NEG
91755: PUSH
91756: LD_INT 3
91758: NEG
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 4
91766: NEG
91767: PUSH
91768: LD_INT 4
91770: NEG
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 4
91778: NEG
91779: PUSH
91780: LD_INT 5
91782: NEG
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 5
91790: NEG
91791: PUSH
91792: LD_INT 4
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 5
91802: NEG
91803: PUSH
91804: LD_INT 5
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 5
91814: NEG
91815: PUSH
91816: LD_INT 6
91818: NEG
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 6
91826: NEG
91827: PUSH
91828: LD_INT 5
91830: NEG
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 6
91838: NEG
91839: PUSH
91840: LD_INT 6
91842: NEG
91843: PUSH
91844: EMPTY
91845: LIST
91846: LIST
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91862: LD_ADDR_VAR 0 41
91866: PUSH
91867: LD_INT 0
91869: PUSH
91870: LD_INT 2
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 1
91880: NEG
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: LD_INT 2
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91906: LD_ADDR_VAR 0 42
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 2
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 3
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91947: LD_ADDR_VAR 0 43
91951: PUSH
91952: LD_INT 2
91954: PUSH
91955: LD_INT 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 3
91964: PUSH
91965: LD_INT 2
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 2
91974: PUSH
91975: LD_INT 3
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: LIST
91986: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91987: LD_ADDR_VAR 0 44
91991: PUSH
91992: LD_INT 0
91994: PUSH
91995: LD_INT 2
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 1
92004: PUSH
92005: LD_INT 3
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 1
92014: NEG
92015: PUSH
92016: LD_INT 2
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: LIST
92027: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92028: LD_ADDR_VAR 0 45
92032: PUSH
92033: LD_INT 2
92035: NEG
92036: PUSH
92037: LD_INT 0
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: LD_INT 1
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92072: LD_ADDR_VAR 0 46
92076: PUSH
92077: LD_INT 2
92079: NEG
92080: PUSH
92081: LD_INT 2
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 2
92091: NEG
92092: PUSH
92093: LD_INT 3
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 3
92103: NEG
92104: PUSH
92105: LD_INT 2
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: LIST
92117: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92118: LD_ADDR_VAR 0 47
92122: PUSH
92123: LD_INT 2
92125: NEG
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 3
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92151: LD_ADDR_VAR 0 48
92155: PUSH
92156: LD_INT 1
92158: PUSH
92159: LD_INT 2
92161: NEG
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 2
92169: PUSH
92170: LD_INT 1
92172: NEG
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92182: LD_ADDR_VAR 0 49
92186: PUSH
92187: LD_INT 3
92189: PUSH
92190: LD_INT 1
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 3
92199: PUSH
92200: LD_INT 2
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92211: LD_ADDR_VAR 0 50
92215: PUSH
92216: LD_INT 2
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: LD_INT 3
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92240: LD_ADDR_VAR 0 51
92244: PUSH
92245: LD_INT 1
92247: NEG
92248: PUSH
92249: LD_INT 2
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 2
92258: NEG
92259: PUSH
92260: LD_INT 1
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92271: LD_ADDR_VAR 0 52
92275: PUSH
92276: LD_INT 3
92278: NEG
92279: PUSH
92280: LD_INT 1
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 3
92290: NEG
92291: PUSH
92292: LD_INT 2
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92304: LD_ADDR_VAR 0 53
92308: PUSH
92309: LD_INT 1
92311: NEG
92312: PUSH
92313: LD_INT 3
92315: NEG
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 0
92323: PUSH
92324: LD_INT 3
92326: NEG
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 1
92334: PUSH
92335: LD_INT 2
92337: NEG
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: LIST
92347: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92348: LD_ADDR_VAR 0 54
92352: PUSH
92353: LD_INT 2
92355: PUSH
92356: LD_INT 1
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 3
92366: PUSH
92367: LD_INT 0
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 3
92376: PUSH
92377: LD_INT 1
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: LIST
92388: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92389: LD_ADDR_VAR 0 55
92393: PUSH
92394: LD_INT 3
92396: PUSH
92397: LD_INT 2
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 3
92406: PUSH
92407: LD_INT 3
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: LD_INT 3
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: LIST
92428: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92429: LD_ADDR_VAR 0 56
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 3
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 3
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: NEG
92457: PUSH
92458: LD_INT 2
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: EMPTY
92466: LIST
92467: LIST
92468: LIST
92469: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92470: LD_ADDR_VAR 0 57
92474: PUSH
92475: LD_INT 2
92477: NEG
92478: PUSH
92479: LD_INT 1
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 3
92488: NEG
92489: PUSH
92490: LD_INT 0
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 3
92499: NEG
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: LIST
92513: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92514: LD_ADDR_VAR 0 58
92518: PUSH
92519: LD_INT 2
92521: NEG
92522: PUSH
92523: LD_INT 3
92525: NEG
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 3
92533: NEG
92534: PUSH
92535: LD_INT 2
92537: NEG
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 3
92545: NEG
92546: PUSH
92547: LD_INT 3
92549: NEG
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: LIST
92559: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92560: LD_ADDR_VAR 0 59
92564: PUSH
92565: LD_INT 1
92567: NEG
92568: PUSH
92569: LD_INT 2
92571: NEG
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 0
92579: PUSH
92580: LD_INT 2
92582: NEG
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: LD_INT 1
92593: NEG
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: LIST
92603: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92604: LD_ADDR_VAR 0 60
92608: PUSH
92609: LD_INT 1
92611: PUSH
92612: LD_INT 1
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 2
92622: PUSH
92623: LD_INT 0
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: PUSH
92633: LD_INT 1
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: LIST
92644: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92645: LD_ADDR_VAR 0 61
92649: PUSH
92650: LD_INT 2
92652: PUSH
92653: LD_INT 1
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: LD_INT 2
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: LD_INT 2
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: LIST
92684: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92685: LD_ADDR_VAR 0 62
92689: PUSH
92690: LD_INT 1
92692: PUSH
92693: LD_INT 2
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 0
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 1
92712: NEG
92713: PUSH
92714: LD_INT 1
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: LIST
92725: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92726: LD_ADDR_VAR 0 63
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: LD_INT 1
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 2
92744: NEG
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 2
92755: NEG
92756: PUSH
92757: LD_INT 1
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: LIST
92769: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92770: LD_ADDR_VAR 0 64
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 2
92789: NEG
92790: PUSH
92791: LD_INT 1
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 2
92801: NEG
92802: PUSH
92803: LD_INT 2
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: LIST
92815: ST_TO_ADDR
// end ; 2 :
92816: GO 96082
92818: LD_INT 2
92820: DOUBLE
92821: EQUAL
92822: IFTRUE 92826
92824: GO 96081
92826: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92827: LD_ADDR_VAR 0 29
92831: PUSH
92832: LD_INT 4
92834: PUSH
92835: LD_INT 0
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: LD_INT 4
92844: PUSH
92845: LD_INT 1
92847: NEG
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 5
92855: PUSH
92856: LD_INT 0
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 5
92865: PUSH
92866: LD_INT 1
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 4
92875: PUSH
92876: LD_INT 1
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 3
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 3
92895: PUSH
92896: LD_INT 1
92898: NEG
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 3
92906: PUSH
92907: LD_INT 2
92909: NEG
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 5
92917: PUSH
92918: LD_INT 2
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 3
92927: PUSH
92928: LD_INT 3
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 3
92937: PUSH
92938: LD_INT 2
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 4
92947: PUSH
92948: LD_INT 3
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 4
92957: PUSH
92958: LD_INT 4
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 3
92967: PUSH
92968: LD_INT 4
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 2
92977: PUSH
92978: LD_INT 3
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 2
92987: PUSH
92988: LD_INT 2
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 4
92997: PUSH
92998: LD_INT 2
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 2
93007: PUSH
93008: LD_INT 4
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: LD_INT 4
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 0
93027: PUSH
93028: LD_INT 3
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: LD_INT 4
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: LD_INT 5
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 0
93057: PUSH
93058: LD_INT 5
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 1
93067: NEG
93068: PUSH
93069: LD_INT 4
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: LD_INT 3
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: LD_INT 5
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 2
93099: NEG
93100: PUSH
93101: LD_INT 3
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: LD_INT 3
93110: NEG
93111: PUSH
93112: LD_INT 0
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 3
93121: NEG
93122: PUSH
93123: LD_INT 1
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 2
93133: NEG
93134: PUSH
93135: LD_INT 0
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 2
93144: NEG
93145: PUSH
93146: LD_INT 1
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 3
93155: NEG
93156: PUSH
93157: LD_INT 1
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 4
93166: NEG
93167: PUSH
93168: LD_INT 0
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 4
93177: NEG
93178: PUSH
93179: LD_INT 1
93181: NEG
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 4
93189: NEG
93190: PUSH
93191: LD_INT 2
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 2
93201: NEG
93202: PUSH
93203: LD_INT 2
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 4
93212: NEG
93213: PUSH
93214: LD_INT 4
93216: NEG
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 4
93224: NEG
93225: PUSH
93226: LD_INT 5
93228: NEG
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 3
93236: NEG
93237: PUSH
93238: LD_INT 4
93240: NEG
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 3
93248: NEG
93249: PUSH
93250: LD_INT 3
93252: NEG
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 4
93260: NEG
93261: PUSH
93262: LD_INT 3
93264: NEG
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 5
93272: NEG
93273: PUSH
93274: LD_INT 4
93276: NEG
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 5
93284: NEG
93285: PUSH
93286: LD_INT 5
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 3
93296: NEG
93297: PUSH
93298: LD_INT 5
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 5
93308: NEG
93309: PUSH
93310: LD_INT 3
93312: NEG
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93365: LD_ADDR_VAR 0 30
93369: PUSH
93370: LD_INT 4
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 4
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 5
93392: PUSH
93393: LD_INT 4
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 5
93402: PUSH
93403: LD_INT 5
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 4
93412: PUSH
93413: LD_INT 5
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 3
93422: PUSH
93423: LD_INT 4
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 3
93432: PUSH
93433: LD_INT 3
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 5
93442: PUSH
93443: LD_INT 3
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 3
93452: PUSH
93453: LD_INT 5
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: LD_INT 0
93462: PUSH
93463: LD_INT 3
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 0
93472: PUSH
93473: LD_INT 2
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: LD_INT 3
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: LD_INT 4
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 0
93502: PUSH
93503: LD_INT 4
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: LD_INT 3
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 1
93523: NEG
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 2
93534: PUSH
93535: LD_INT 4
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 2
93544: NEG
93545: PUSH
93546: LD_INT 2
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 4
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 3
93578: NEG
93579: PUSH
93580: LD_INT 0
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 3
93589: NEG
93590: PUSH
93591: LD_INT 1
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 4
93600: NEG
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 5
93611: NEG
93612: PUSH
93613: LD_INT 0
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 5
93622: NEG
93623: PUSH
93624: LD_INT 1
93626: NEG
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 5
93634: NEG
93635: PUSH
93636: LD_INT 2
93638: NEG
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 3
93646: NEG
93647: PUSH
93648: LD_INT 2
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 3
93657: NEG
93658: PUSH
93659: LD_INT 3
93661: NEG
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 3
93669: NEG
93670: PUSH
93671: LD_INT 4
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 2
93681: NEG
93682: PUSH
93683: LD_INT 3
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 2
93693: NEG
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 3
93705: NEG
93706: PUSH
93707: LD_INT 2
93709: NEG
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 4
93717: NEG
93718: PUSH
93719: LD_INT 3
93721: NEG
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 4
93729: NEG
93730: PUSH
93731: LD_INT 4
93733: NEG
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: PUSH
93739: LD_INT 2
93741: NEG
93742: PUSH
93743: LD_INT 4
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 4
93753: NEG
93754: PUSH
93755: LD_INT 2
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: LD_INT 4
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 0
93776: PUSH
93777: LD_INT 5
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: LD_INT 4
93790: NEG
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: PUSH
93796: LD_INT 1
93798: PUSH
93799: LD_INT 3
93801: NEG
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 0
93809: PUSH
93810: LD_INT 3
93812: NEG
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: LD_INT 1
93820: NEG
93821: PUSH
93822: LD_INT 4
93824: NEG
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 1
93832: NEG
93833: PUSH
93834: LD_INT 5
93836: NEG
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 2
93844: PUSH
93845: LD_INT 3
93847: NEG
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 2
93855: NEG
93856: PUSH
93857: LD_INT 5
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93912: LD_ADDR_VAR 0 31
93916: PUSH
93917: LD_INT 0
93919: PUSH
93920: LD_INT 4
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 0
93929: PUSH
93930: LD_INT 3
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 1
93939: PUSH
93940: LD_INT 4
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: LD_INT 5
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 0
93959: PUSH
93960: LD_INT 5
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 1
93969: NEG
93970: PUSH
93971: LD_INT 4
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 1
93980: NEG
93981: PUSH
93982: LD_INT 3
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 2
93991: PUSH
93992: LD_INT 5
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 2
94001: NEG
94002: PUSH
94003: LD_INT 3
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 3
94012: NEG
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 3
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 2
94035: NEG
94036: PUSH
94037: LD_INT 0
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 2
94046: NEG
94047: PUSH
94048: LD_INT 1
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 3
94057: NEG
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 4
94068: NEG
94069: PUSH
94070: LD_INT 0
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 4
94079: NEG
94080: PUSH
94081: LD_INT 1
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 4
94091: NEG
94092: PUSH
94093: LD_INT 2
94095: NEG
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 2
94103: NEG
94104: PUSH
94105: LD_INT 2
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 4
94114: NEG
94115: PUSH
94116: LD_INT 4
94118: NEG
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: PUSH
94124: LD_INT 4
94126: NEG
94127: PUSH
94128: LD_INT 5
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 3
94138: NEG
94139: PUSH
94140: LD_INT 4
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: LD_INT 3
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 4
94162: NEG
94163: PUSH
94164: LD_INT 3
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 5
94174: NEG
94175: PUSH
94176: LD_INT 4
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: LD_INT 5
94186: NEG
94187: PUSH
94188: LD_INT 5
94190: NEG
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PUSH
94196: LD_INT 3
94198: NEG
94199: PUSH
94200: LD_INT 5
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 5
94210: NEG
94211: PUSH
94212: LD_INT 3
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 0
94222: PUSH
94223: LD_INT 3
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 0
94233: PUSH
94234: LD_INT 4
94236: NEG
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 1
94244: PUSH
94245: LD_INT 3
94247: NEG
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 1
94255: PUSH
94256: LD_INT 2
94258: NEG
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 0
94266: PUSH
94267: LD_INT 2
94269: NEG
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 1
94277: NEG
94278: PUSH
94279: LD_INT 3
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 1
94289: NEG
94290: PUSH
94291: LD_INT 4
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 2
94301: PUSH
94302: LD_INT 2
94304: NEG
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 2
94312: NEG
94313: PUSH
94314: LD_INT 4
94316: NEG
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 4
94324: PUSH
94325: LD_INT 0
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 4
94334: PUSH
94335: LD_INT 1
94337: NEG
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 5
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 5
94355: PUSH
94356: LD_INT 1
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 4
94365: PUSH
94366: LD_INT 1
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 3
94375: PUSH
94376: LD_INT 0
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 3
94385: PUSH
94386: LD_INT 1
94388: NEG
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: LD_INT 2
94399: NEG
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 5
94407: PUSH
94408: LD_INT 2
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94462: LD_ADDR_VAR 0 32
94466: PUSH
94467: LD_INT 4
94469: NEG
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 4
94480: NEG
94481: PUSH
94482: LD_INT 1
94484: NEG
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 3
94492: NEG
94493: PUSH
94494: LD_INT 0
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 3
94503: NEG
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 4
94514: NEG
94515: PUSH
94516: LD_INT 1
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 5
94525: NEG
94526: PUSH
94527: LD_INT 0
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: PUSH
94534: LD_INT 5
94536: NEG
94537: PUSH
94538: LD_INT 1
94540: NEG
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 5
94548: NEG
94549: PUSH
94550: LD_INT 2
94552: NEG
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 3
94560: NEG
94561: PUSH
94562: LD_INT 2
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 3
94571: NEG
94572: PUSH
94573: LD_INT 3
94575: NEG
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 3
94583: NEG
94584: PUSH
94585: LD_INT 4
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 2
94595: NEG
94596: PUSH
94597: LD_INT 3
94599: NEG
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 2
94607: NEG
94608: PUSH
94609: LD_INT 2
94611: NEG
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 3
94619: NEG
94620: PUSH
94621: LD_INT 2
94623: NEG
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 4
94631: NEG
94632: PUSH
94633: LD_INT 3
94635: NEG
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 4
94643: NEG
94644: PUSH
94645: LD_INT 4
94647: NEG
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: PUSH
94653: LD_INT 2
94655: NEG
94656: PUSH
94657: LD_INT 4
94659: NEG
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 4
94667: NEG
94668: PUSH
94669: LD_INT 2
94671: NEG
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 0
94679: PUSH
94680: LD_INT 4
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 0
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 1
94701: PUSH
94702: LD_INT 4
94704: NEG
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 1
94712: PUSH
94713: LD_INT 3
94715: NEG
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 0
94723: PUSH
94724: LD_INT 3
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 1
94734: NEG
94735: PUSH
94736: LD_INT 4
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 1
94746: NEG
94747: PUSH
94748: LD_INT 5
94750: NEG
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 2
94758: PUSH
94759: LD_INT 3
94761: NEG
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 2
94769: NEG
94770: PUSH
94771: LD_INT 5
94773: NEG
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 3
94781: PUSH
94782: LD_INT 0
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 3
94791: PUSH
94792: LD_INT 1
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 4
94802: PUSH
94803: LD_INT 0
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 3
94822: PUSH
94823: LD_INT 1
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 2
94832: PUSH
94833: LD_INT 0
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 2
94842: PUSH
94843: LD_INT 1
94845: NEG
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 2
94853: PUSH
94854: LD_INT 2
94856: NEG
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 4
94864: PUSH
94865: LD_INT 2
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 4
94874: PUSH
94875: LD_INT 4
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 4
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 5
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 5
94904: PUSH
94905: LD_INT 5
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 4
94914: PUSH
94915: LD_INT 5
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 3
94924: PUSH
94925: LD_INT 4
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: PUSH
94932: LD_INT 3
94934: PUSH
94935: LD_INT 3
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 5
94944: PUSH
94945: LD_INT 3
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 3
94954: PUSH
94955: LD_INT 5
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95009: LD_ADDR_VAR 0 33
95013: PUSH
95014: LD_INT 4
95016: NEG
95017: PUSH
95018: LD_INT 4
95020: NEG
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 4
95028: NEG
95029: PUSH
95030: LD_INT 5
95032: NEG
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 3
95040: NEG
95041: PUSH
95042: LD_INT 4
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 3
95052: NEG
95053: PUSH
95054: LD_INT 3
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 4
95064: NEG
95065: PUSH
95066: LD_INT 3
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 5
95076: NEG
95077: PUSH
95078: LD_INT 4
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 5
95088: NEG
95089: PUSH
95090: LD_INT 5
95092: NEG
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: LD_INT 3
95100: NEG
95101: PUSH
95102: LD_INT 5
95104: NEG
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: PUSH
95110: LD_INT 5
95112: NEG
95113: PUSH
95114: LD_INT 3
95116: NEG
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 0
95124: PUSH
95125: LD_INT 3
95127: NEG
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 0
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: LD_INT 3
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 1
95157: PUSH
95158: LD_INT 2
95160: NEG
95161: PUSH
95162: EMPTY
95163: LIST
95164: LIST
95165: PUSH
95166: LD_INT 0
95168: PUSH
95169: LD_INT 2
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 1
95179: NEG
95180: PUSH
95181: LD_INT 3
95183: NEG
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 1
95191: NEG
95192: PUSH
95193: LD_INT 4
95195: NEG
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 2
95203: PUSH
95204: LD_INT 2
95206: NEG
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 2
95214: NEG
95215: PUSH
95216: LD_INT 4
95218: NEG
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 4
95226: PUSH
95227: LD_INT 0
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 4
95236: PUSH
95237: LD_INT 1
95239: NEG
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 5
95247: PUSH
95248: LD_INT 0
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 5
95257: PUSH
95258: LD_INT 1
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 4
95267: PUSH
95268: LD_INT 1
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 3
95277: PUSH
95278: LD_INT 0
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 3
95287: PUSH
95288: LD_INT 1
95290: NEG
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: LD_INT 3
95298: PUSH
95299: LD_INT 2
95301: NEG
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 5
95309: PUSH
95310: LD_INT 2
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 3
95319: PUSH
95320: LD_INT 3
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: LD_INT 2
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 4
95339: PUSH
95340: LD_INT 3
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 4
95349: PUSH
95350: LD_INT 4
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 3
95359: PUSH
95360: LD_INT 4
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 2
95369: PUSH
95370: LD_INT 3
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 2
95379: PUSH
95380: LD_INT 2
95382: PUSH
95383: EMPTY
95384: LIST
95385: LIST
95386: PUSH
95387: LD_INT 4
95389: PUSH
95390: LD_INT 2
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 0
95409: PUSH
95410: LD_INT 4
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 0
95419: PUSH
95420: LD_INT 3
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 1
95429: PUSH
95430: LD_INT 4
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 1
95439: PUSH
95440: LD_INT 5
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: PUSH
95447: LD_INT 0
95449: PUSH
95450: LD_INT 5
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 1
95470: NEG
95471: PUSH
95472: LD_INT 3
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 2
95481: PUSH
95482: LD_INT 5
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: PUSH
95489: LD_INT 2
95491: NEG
95492: PUSH
95493: LD_INT 3
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95547: LD_ADDR_VAR 0 34
95551: PUSH
95552: LD_INT 0
95554: PUSH
95555: LD_INT 4
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 0
95565: PUSH
95566: LD_INT 5
95568: NEG
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PUSH
95574: LD_INT 1
95576: PUSH
95577: LD_INT 4
95579: NEG
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 1
95587: PUSH
95588: LD_INT 3
95590: NEG
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 0
95598: PUSH
95599: LD_INT 3
95601: NEG
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 1
95609: NEG
95610: PUSH
95611: LD_INT 4
95613: NEG
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 1
95621: NEG
95622: PUSH
95623: LD_INT 5
95625: NEG
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 2
95633: PUSH
95634: LD_INT 3
95636: NEG
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 2
95644: NEG
95645: PUSH
95646: LD_INT 5
95648: NEG
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 3
95656: PUSH
95657: LD_INT 0
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 3
95666: PUSH
95667: LD_INT 1
95669: NEG
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 4
95677: PUSH
95678: LD_INT 0
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 4
95687: PUSH
95688: LD_INT 1
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 3
95697: PUSH
95698: LD_INT 1
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 2
95707: PUSH
95708: LD_INT 0
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 2
95717: PUSH
95718: LD_INT 1
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 2
95728: PUSH
95729: LD_INT 2
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 4
95739: PUSH
95740: LD_INT 2
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 4
95749: PUSH
95750: LD_INT 4
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: LD_INT 3
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 5
95769: PUSH
95770: LD_INT 4
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 5
95779: PUSH
95780: LD_INT 5
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 4
95789: PUSH
95790: LD_INT 5
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 3
95799: PUSH
95800: LD_INT 4
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 3
95809: PUSH
95810: LD_INT 3
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 5
95819: PUSH
95820: LD_INT 3
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 3
95829: PUSH
95830: LD_INT 5
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: LD_INT 3
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 0
95849: PUSH
95850: LD_INT 2
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 1
95859: PUSH
95860: LD_INT 3
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 1
95869: PUSH
95870: LD_INT 4
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 0
95879: PUSH
95880: LD_INT 4
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 1
95889: NEG
95890: PUSH
95891: LD_INT 3
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: LD_INT 2
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 2
95911: PUSH
95912: LD_INT 4
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 2
95921: NEG
95922: PUSH
95923: LD_INT 2
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 4
95932: NEG
95933: PUSH
95934: LD_INT 0
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 4
95943: NEG
95944: PUSH
95945: LD_INT 1
95947: NEG
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 3
95955: NEG
95956: PUSH
95957: LD_INT 0
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 3
95966: NEG
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 4
95977: NEG
95978: PUSH
95979: LD_INT 1
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 5
95988: NEG
95989: PUSH
95990: LD_INT 0
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: PUSH
95997: LD_INT 5
95999: NEG
96000: PUSH
96001: LD_INT 1
96003: NEG
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: LD_INT 5
96011: NEG
96012: PUSH
96013: LD_INT 2
96015: NEG
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: PUSH
96021: LD_INT 3
96023: NEG
96024: PUSH
96025: LD_INT 2
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: ST_TO_ADDR
// end ; end ;
96079: GO 96082
96081: POP
// case btype of b_depot , b_warehouse :
96082: LD_VAR 0 1
96086: PUSH
96087: LD_INT 0
96089: DOUBLE
96090: EQUAL
96091: IFTRUE 96101
96093: LD_INT 1
96095: DOUBLE
96096: EQUAL
96097: IFTRUE 96101
96099: GO 96302
96101: POP
// case nation of nation_american :
96102: LD_VAR 0 5
96106: PUSH
96107: LD_INT 1
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96171
96115: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96116: LD_ADDR_VAR 0 9
96120: PUSH
96121: LD_VAR 0 11
96125: PUSH
96126: LD_VAR 0 12
96130: PUSH
96131: LD_VAR 0 13
96135: PUSH
96136: LD_VAR 0 14
96140: PUSH
96141: LD_VAR 0 15
96145: PUSH
96146: LD_VAR 0 16
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: PUSH
96159: LD_VAR 0 4
96163: PUSH
96164: LD_INT 1
96166: PLUS
96167: ARRAY
96168: ST_TO_ADDR
96169: GO 96300
96171: LD_INT 2
96173: DOUBLE
96174: EQUAL
96175: IFTRUE 96179
96177: GO 96235
96179: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96180: LD_ADDR_VAR 0 9
96184: PUSH
96185: LD_VAR 0 17
96189: PUSH
96190: LD_VAR 0 18
96194: PUSH
96195: LD_VAR 0 19
96199: PUSH
96200: LD_VAR 0 20
96204: PUSH
96205: LD_VAR 0 21
96209: PUSH
96210: LD_VAR 0 22
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: PUSH
96223: LD_VAR 0 4
96227: PUSH
96228: LD_INT 1
96230: PLUS
96231: ARRAY
96232: ST_TO_ADDR
96233: GO 96300
96235: LD_INT 3
96237: DOUBLE
96238: EQUAL
96239: IFTRUE 96243
96241: GO 96299
96243: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96244: LD_ADDR_VAR 0 9
96248: PUSH
96249: LD_VAR 0 23
96253: PUSH
96254: LD_VAR 0 24
96258: PUSH
96259: LD_VAR 0 25
96263: PUSH
96264: LD_VAR 0 26
96268: PUSH
96269: LD_VAR 0 27
96273: PUSH
96274: LD_VAR 0 28
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: PUSH
96287: LD_VAR 0 4
96291: PUSH
96292: LD_INT 1
96294: PLUS
96295: ARRAY
96296: ST_TO_ADDR
96297: GO 96300
96299: POP
96300: GO 96855
96302: LD_INT 2
96304: DOUBLE
96305: EQUAL
96306: IFTRUE 96316
96308: LD_INT 3
96310: DOUBLE
96311: EQUAL
96312: IFTRUE 96316
96314: GO 96372
96316: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96317: LD_ADDR_VAR 0 9
96321: PUSH
96322: LD_VAR 0 29
96326: PUSH
96327: LD_VAR 0 30
96331: PUSH
96332: LD_VAR 0 31
96336: PUSH
96337: LD_VAR 0 32
96341: PUSH
96342: LD_VAR 0 33
96346: PUSH
96347: LD_VAR 0 34
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: PUSH
96360: LD_VAR 0 4
96364: PUSH
96365: LD_INT 1
96367: PLUS
96368: ARRAY
96369: ST_TO_ADDR
96370: GO 96855
96372: LD_INT 16
96374: DOUBLE
96375: EQUAL
96376: IFTRUE 96434
96378: LD_INT 17
96380: DOUBLE
96381: EQUAL
96382: IFTRUE 96434
96384: LD_INT 18
96386: DOUBLE
96387: EQUAL
96388: IFTRUE 96434
96390: LD_INT 19
96392: DOUBLE
96393: EQUAL
96394: IFTRUE 96434
96396: LD_INT 22
96398: DOUBLE
96399: EQUAL
96400: IFTRUE 96434
96402: LD_INT 20
96404: DOUBLE
96405: EQUAL
96406: IFTRUE 96434
96408: LD_INT 21
96410: DOUBLE
96411: EQUAL
96412: IFTRUE 96434
96414: LD_INT 23
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96434
96420: LD_INT 24
96422: DOUBLE
96423: EQUAL
96424: IFTRUE 96434
96426: LD_INT 25
96428: DOUBLE
96429: EQUAL
96430: IFTRUE 96434
96432: GO 96490
96434: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96435: LD_ADDR_VAR 0 9
96439: PUSH
96440: LD_VAR 0 35
96444: PUSH
96445: LD_VAR 0 36
96449: PUSH
96450: LD_VAR 0 37
96454: PUSH
96455: LD_VAR 0 38
96459: PUSH
96460: LD_VAR 0 39
96464: PUSH
96465: LD_VAR 0 40
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: PUSH
96478: LD_VAR 0 4
96482: PUSH
96483: LD_INT 1
96485: PLUS
96486: ARRAY
96487: ST_TO_ADDR
96488: GO 96855
96490: LD_INT 6
96492: DOUBLE
96493: EQUAL
96494: IFTRUE 96546
96496: LD_INT 7
96498: DOUBLE
96499: EQUAL
96500: IFTRUE 96546
96502: LD_INT 8
96504: DOUBLE
96505: EQUAL
96506: IFTRUE 96546
96508: LD_INT 13
96510: DOUBLE
96511: EQUAL
96512: IFTRUE 96546
96514: LD_INT 12
96516: DOUBLE
96517: EQUAL
96518: IFTRUE 96546
96520: LD_INT 15
96522: DOUBLE
96523: EQUAL
96524: IFTRUE 96546
96526: LD_INT 11
96528: DOUBLE
96529: EQUAL
96530: IFTRUE 96546
96532: LD_INT 14
96534: DOUBLE
96535: EQUAL
96536: IFTRUE 96546
96538: LD_INT 10
96540: DOUBLE
96541: EQUAL
96542: IFTRUE 96546
96544: GO 96602
96546: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96547: LD_ADDR_VAR 0 9
96551: PUSH
96552: LD_VAR 0 41
96556: PUSH
96557: LD_VAR 0 42
96561: PUSH
96562: LD_VAR 0 43
96566: PUSH
96567: LD_VAR 0 44
96571: PUSH
96572: LD_VAR 0 45
96576: PUSH
96577: LD_VAR 0 46
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: PUSH
96590: LD_VAR 0 4
96594: PUSH
96595: LD_INT 1
96597: PLUS
96598: ARRAY
96599: ST_TO_ADDR
96600: GO 96855
96602: LD_INT 36
96604: DOUBLE
96605: EQUAL
96606: IFTRUE 96610
96608: GO 96666
96610: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96611: LD_ADDR_VAR 0 9
96615: PUSH
96616: LD_VAR 0 47
96620: PUSH
96621: LD_VAR 0 48
96625: PUSH
96626: LD_VAR 0 49
96630: PUSH
96631: LD_VAR 0 50
96635: PUSH
96636: LD_VAR 0 51
96640: PUSH
96641: LD_VAR 0 52
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: PUSH
96654: LD_VAR 0 4
96658: PUSH
96659: LD_INT 1
96661: PLUS
96662: ARRAY
96663: ST_TO_ADDR
96664: GO 96855
96666: LD_INT 4
96668: DOUBLE
96669: EQUAL
96670: IFTRUE 96692
96672: LD_INT 5
96674: DOUBLE
96675: EQUAL
96676: IFTRUE 96692
96678: LD_INT 34
96680: DOUBLE
96681: EQUAL
96682: IFTRUE 96692
96684: LD_INT 37
96686: DOUBLE
96687: EQUAL
96688: IFTRUE 96692
96690: GO 96748
96692: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96693: LD_ADDR_VAR 0 9
96697: PUSH
96698: LD_VAR 0 53
96702: PUSH
96703: LD_VAR 0 54
96707: PUSH
96708: LD_VAR 0 55
96712: PUSH
96713: LD_VAR 0 56
96717: PUSH
96718: LD_VAR 0 57
96722: PUSH
96723: LD_VAR 0 58
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: PUSH
96736: LD_VAR 0 4
96740: PUSH
96741: LD_INT 1
96743: PLUS
96744: ARRAY
96745: ST_TO_ADDR
96746: GO 96855
96748: LD_INT 31
96750: DOUBLE
96751: EQUAL
96752: IFTRUE 96798
96754: LD_INT 32
96756: DOUBLE
96757: EQUAL
96758: IFTRUE 96798
96760: LD_INT 33
96762: DOUBLE
96763: EQUAL
96764: IFTRUE 96798
96766: LD_INT 27
96768: DOUBLE
96769: EQUAL
96770: IFTRUE 96798
96772: LD_INT 26
96774: DOUBLE
96775: EQUAL
96776: IFTRUE 96798
96778: LD_INT 28
96780: DOUBLE
96781: EQUAL
96782: IFTRUE 96798
96784: LD_INT 29
96786: DOUBLE
96787: EQUAL
96788: IFTRUE 96798
96790: LD_INT 30
96792: DOUBLE
96793: EQUAL
96794: IFTRUE 96798
96796: GO 96854
96798: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96799: LD_ADDR_VAR 0 9
96803: PUSH
96804: LD_VAR 0 59
96808: PUSH
96809: LD_VAR 0 60
96813: PUSH
96814: LD_VAR 0 61
96818: PUSH
96819: LD_VAR 0 62
96823: PUSH
96824: LD_VAR 0 63
96828: PUSH
96829: LD_VAR 0 64
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: PUSH
96842: LD_VAR 0 4
96846: PUSH
96847: LD_INT 1
96849: PLUS
96850: ARRAY
96851: ST_TO_ADDR
96852: GO 96855
96854: POP
// temp_list2 = [ ] ;
96855: LD_ADDR_VAR 0 10
96859: PUSH
96860: EMPTY
96861: ST_TO_ADDR
// for i in temp_list do
96862: LD_ADDR_VAR 0 8
96866: PUSH
96867: LD_VAR 0 9
96871: PUSH
96872: FOR_IN
96873: IFFALSE 96925
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96875: LD_ADDR_VAR 0 10
96879: PUSH
96880: LD_VAR 0 10
96884: PUSH
96885: LD_VAR 0 8
96889: PUSH
96890: LD_INT 1
96892: ARRAY
96893: PUSH
96894: LD_VAR 0 2
96898: PLUS
96899: PUSH
96900: LD_VAR 0 8
96904: PUSH
96905: LD_INT 2
96907: ARRAY
96908: PUSH
96909: LD_VAR 0 3
96913: PLUS
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: EMPTY
96920: LIST
96921: ADD
96922: ST_TO_ADDR
96923: GO 96872
96925: POP
96926: POP
// result = temp_list2 ;
96927: LD_ADDR_VAR 0 7
96931: PUSH
96932: LD_VAR 0 10
96936: ST_TO_ADDR
// end ;
96937: LD_VAR 0 7
96941: RET
// export function EnemyInRange ( unit , dist ) ; begin
96942: LD_INT 0
96944: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96945: LD_ADDR_VAR 0 3
96949: PUSH
96950: LD_VAR 0 1
96954: PPUSH
96955: CALL_OW 255
96959: PPUSH
96960: LD_VAR 0 1
96964: PPUSH
96965: CALL_OW 250
96969: PPUSH
96970: LD_VAR 0 1
96974: PPUSH
96975: CALL_OW 251
96979: PPUSH
96980: LD_VAR 0 2
96984: PPUSH
96985: CALL 71046 0 4
96989: PUSH
96990: LD_INT 4
96992: ARRAY
96993: ST_TO_ADDR
// end ;
96994: LD_VAR 0 3
96998: RET
// export function PlayerSeeMe ( unit ) ; begin
96999: LD_INT 0
97001: PPUSH
// result := See ( your_side , unit ) ;
97002: LD_ADDR_VAR 0 2
97006: PUSH
97007: LD_OWVAR 2
97011: PPUSH
97012: LD_VAR 0 1
97016: PPUSH
97017: CALL_OW 292
97021: ST_TO_ADDR
// end ;
97022: LD_VAR 0 2
97026: RET
// export function ReverseDir ( unit ) ; begin
97027: LD_INT 0
97029: PPUSH
// if not unit then
97030: LD_VAR 0 1
97034: NOT
97035: IFFALSE 97039
// exit ;
97037: GO 97062
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
97039: LD_ADDR_VAR 0 2
97043: PUSH
97044: LD_VAR 0 1
97048: PPUSH
97049: CALL_OW 254
97053: PUSH
97054: LD_INT 3
97056: PLUS
97057: PUSH
97058: LD_INT 6
97060: MOD
97061: ST_TO_ADDR
// end ;
97062: LD_VAR 0 2
97066: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97067: LD_INT 0
97069: PPUSH
97070: PPUSH
97071: PPUSH
97072: PPUSH
97073: PPUSH
// if not hexes then
97074: LD_VAR 0 2
97078: NOT
97079: IFFALSE 97083
// exit ;
97081: GO 97231
// dist := 9999 ;
97083: LD_ADDR_VAR 0 5
97087: PUSH
97088: LD_INT 9999
97090: ST_TO_ADDR
// for i = 1 to hexes do
97091: LD_ADDR_VAR 0 4
97095: PUSH
97096: DOUBLE
97097: LD_INT 1
97099: DEC
97100: ST_TO_ADDR
97101: LD_VAR 0 2
97105: PUSH
97106: FOR_TO
97107: IFFALSE 97219
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97109: LD_VAR 0 1
97113: PPUSH
97114: LD_VAR 0 2
97118: PUSH
97119: LD_VAR 0 4
97123: ARRAY
97124: PUSH
97125: LD_INT 1
97127: ARRAY
97128: PPUSH
97129: LD_VAR 0 2
97133: PUSH
97134: LD_VAR 0 4
97138: ARRAY
97139: PUSH
97140: LD_INT 2
97142: ARRAY
97143: PPUSH
97144: CALL_OW 297
97148: PUSH
97149: LD_VAR 0 5
97153: LESS
97154: IFFALSE 97217
// begin hex := hexes [ i ] ;
97156: LD_ADDR_VAR 0 7
97160: PUSH
97161: LD_VAR 0 2
97165: PUSH
97166: LD_VAR 0 4
97170: ARRAY
97171: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97172: LD_ADDR_VAR 0 5
97176: PUSH
97177: LD_VAR 0 1
97181: PPUSH
97182: LD_VAR 0 2
97186: PUSH
97187: LD_VAR 0 4
97191: ARRAY
97192: PUSH
97193: LD_INT 1
97195: ARRAY
97196: PPUSH
97197: LD_VAR 0 2
97201: PUSH
97202: LD_VAR 0 4
97206: ARRAY
97207: PUSH
97208: LD_INT 2
97210: ARRAY
97211: PPUSH
97212: CALL_OW 297
97216: ST_TO_ADDR
// end ; end ;
97217: GO 97106
97219: POP
97220: POP
// result := hex ;
97221: LD_ADDR_VAR 0 3
97225: PUSH
97226: LD_VAR 0 7
97230: ST_TO_ADDR
// end ;
97231: LD_VAR 0 3
97235: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97236: LD_INT 0
97238: PPUSH
97239: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97240: LD_VAR 0 1
97244: NOT
97245: PUSH
97246: LD_VAR 0 1
97250: PUSH
97251: LD_INT 21
97253: PUSH
97254: LD_INT 2
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 23
97263: PUSH
97264: LD_INT 2
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PPUSH
97275: CALL_OW 69
97279: IN
97280: NOT
97281: OR
97282: IFFALSE 97286
// exit ;
97284: GO 97333
// for i = 1 to 3 do
97286: LD_ADDR_VAR 0 3
97290: PUSH
97291: DOUBLE
97292: LD_INT 1
97294: DEC
97295: ST_TO_ADDR
97296: LD_INT 3
97298: PUSH
97299: FOR_TO
97300: IFFALSE 97331
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97302: LD_VAR 0 1
97306: PPUSH
97307: CALL_OW 250
97311: PPUSH
97312: LD_VAR 0 1
97316: PPUSH
97317: CALL_OW 251
97321: PPUSH
97322: LD_INT 1
97324: PPUSH
97325: CALL_OW 453
97329: GO 97299
97331: POP
97332: POP
// end ;
97333: LD_VAR 0 2
97337: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97338: LD_INT 0
97340: PPUSH
97341: PPUSH
97342: PPUSH
97343: PPUSH
97344: PPUSH
97345: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97346: LD_VAR 0 1
97350: NOT
97351: PUSH
97352: LD_VAR 0 2
97356: NOT
97357: OR
97358: PUSH
97359: LD_VAR 0 1
97363: PPUSH
97364: CALL_OW 314
97368: OR
97369: IFFALSE 97373
// exit ;
97371: GO 97814
// x := GetX ( enemy_unit ) ;
97373: LD_ADDR_VAR 0 7
97377: PUSH
97378: LD_VAR 0 2
97382: PPUSH
97383: CALL_OW 250
97387: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97388: LD_ADDR_VAR 0 8
97392: PUSH
97393: LD_VAR 0 2
97397: PPUSH
97398: CALL_OW 251
97402: ST_TO_ADDR
// if not x or not y then
97403: LD_VAR 0 7
97407: NOT
97408: PUSH
97409: LD_VAR 0 8
97413: NOT
97414: OR
97415: IFFALSE 97419
// exit ;
97417: GO 97814
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97419: LD_ADDR_VAR 0 6
97423: PUSH
97424: LD_VAR 0 7
97428: PPUSH
97429: LD_INT 0
97431: PPUSH
97432: LD_INT 4
97434: PPUSH
97435: CALL_OW 272
97439: PUSH
97440: LD_VAR 0 8
97444: PPUSH
97445: LD_INT 0
97447: PPUSH
97448: LD_INT 4
97450: PPUSH
97451: CALL_OW 273
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_VAR 0 7
97464: PPUSH
97465: LD_INT 1
97467: PPUSH
97468: LD_INT 4
97470: PPUSH
97471: CALL_OW 272
97475: PUSH
97476: LD_VAR 0 8
97480: PPUSH
97481: LD_INT 1
97483: PPUSH
97484: LD_INT 4
97486: PPUSH
97487: CALL_OW 273
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_VAR 0 7
97500: PPUSH
97501: LD_INT 2
97503: PPUSH
97504: LD_INT 4
97506: PPUSH
97507: CALL_OW 272
97511: PUSH
97512: LD_VAR 0 8
97516: PPUSH
97517: LD_INT 2
97519: PPUSH
97520: LD_INT 4
97522: PPUSH
97523: CALL_OW 273
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_VAR 0 7
97536: PPUSH
97537: LD_INT 3
97539: PPUSH
97540: LD_INT 4
97542: PPUSH
97543: CALL_OW 272
97547: PUSH
97548: LD_VAR 0 8
97552: PPUSH
97553: LD_INT 3
97555: PPUSH
97556: LD_INT 4
97558: PPUSH
97559: CALL_OW 273
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_VAR 0 7
97572: PPUSH
97573: LD_INT 4
97575: PPUSH
97576: LD_INT 4
97578: PPUSH
97579: CALL_OW 272
97583: PUSH
97584: LD_VAR 0 8
97588: PPUSH
97589: LD_INT 4
97591: PPUSH
97592: LD_INT 4
97594: PPUSH
97595: CALL_OW 273
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_VAR 0 7
97608: PPUSH
97609: LD_INT 5
97611: PPUSH
97612: LD_INT 4
97614: PPUSH
97615: CALL_OW 272
97619: PUSH
97620: LD_VAR 0 8
97624: PPUSH
97625: LD_INT 5
97627: PPUSH
97628: LD_INT 4
97630: PPUSH
97631: CALL_OW 273
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: ST_TO_ADDR
// for i = tmp downto 1 do
97648: LD_ADDR_VAR 0 4
97652: PUSH
97653: DOUBLE
97654: LD_VAR 0 6
97658: INC
97659: ST_TO_ADDR
97660: LD_INT 1
97662: PUSH
97663: FOR_DOWNTO
97664: IFFALSE 97765
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97666: LD_VAR 0 6
97670: PUSH
97671: LD_VAR 0 4
97675: ARRAY
97676: PUSH
97677: LD_INT 1
97679: ARRAY
97680: PPUSH
97681: LD_VAR 0 6
97685: PUSH
97686: LD_VAR 0 4
97690: ARRAY
97691: PUSH
97692: LD_INT 2
97694: ARRAY
97695: PPUSH
97696: CALL_OW 488
97700: NOT
97701: PUSH
97702: LD_VAR 0 6
97706: PUSH
97707: LD_VAR 0 4
97711: ARRAY
97712: PUSH
97713: LD_INT 1
97715: ARRAY
97716: PPUSH
97717: LD_VAR 0 6
97721: PUSH
97722: LD_VAR 0 4
97726: ARRAY
97727: PUSH
97728: LD_INT 2
97730: ARRAY
97731: PPUSH
97732: CALL_OW 428
97736: PUSH
97737: LD_INT 0
97739: NONEQUAL
97740: OR
97741: IFFALSE 97763
// tmp := Delete ( tmp , i ) ;
97743: LD_ADDR_VAR 0 6
97747: PUSH
97748: LD_VAR 0 6
97752: PPUSH
97753: LD_VAR 0 4
97757: PPUSH
97758: CALL_OW 3
97762: ST_TO_ADDR
97763: GO 97663
97765: POP
97766: POP
// j := GetClosestHex ( unit , tmp ) ;
97767: LD_ADDR_VAR 0 5
97771: PUSH
97772: LD_VAR 0 1
97776: PPUSH
97777: LD_VAR 0 6
97781: PPUSH
97782: CALL 97067 0 2
97786: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97787: LD_VAR 0 1
97791: PPUSH
97792: LD_VAR 0 5
97796: PUSH
97797: LD_INT 1
97799: ARRAY
97800: PPUSH
97801: LD_VAR 0 5
97805: PUSH
97806: LD_INT 2
97808: ARRAY
97809: PPUSH
97810: CALL_OW 111
// end ;
97814: LD_VAR 0 3
97818: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97819: LD_INT 0
97821: PPUSH
97822: PPUSH
97823: PPUSH
// uc_side = 0 ;
97824: LD_ADDR_OWVAR 20
97828: PUSH
97829: LD_INT 0
97831: ST_TO_ADDR
// uc_nation = 0 ;
97832: LD_ADDR_OWVAR 21
97836: PUSH
97837: LD_INT 0
97839: ST_TO_ADDR
// InitHc_All ( ) ;
97840: CALL_OW 584
// InitVc ;
97844: CALL_OW 20
// if mastodonts then
97848: LD_VAR 0 6
97852: IFFALSE 97919
// for i = 1 to mastodonts do
97854: LD_ADDR_VAR 0 11
97858: PUSH
97859: DOUBLE
97860: LD_INT 1
97862: DEC
97863: ST_TO_ADDR
97864: LD_VAR 0 6
97868: PUSH
97869: FOR_TO
97870: IFFALSE 97917
// begin vc_chassis := 31 ;
97872: LD_ADDR_OWVAR 37
97876: PUSH
97877: LD_INT 31
97879: ST_TO_ADDR
// vc_control := control_rider ;
97880: LD_ADDR_OWVAR 38
97884: PUSH
97885: LD_INT 4
97887: ST_TO_ADDR
// animal := CreateVehicle ;
97888: LD_ADDR_VAR 0 12
97892: PUSH
97893: CALL_OW 45
97897: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97898: LD_VAR 0 12
97902: PPUSH
97903: LD_VAR 0 8
97907: PPUSH
97908: LD_INT 0
97910: PPUSH
97911: CALL 100107 0 3
// end ;
97915: GO 97869
97917: POP
97918: POP
// if horses then
97919: LD_VAR 0 5
97923: IFFALSE 97990
// for i = 1 to horses do
97925: LD_ADDR_VAR 0 11
97929: PUSH
97930: DOUBLE
97931: LD_INT 1
97933: DEC
97934: ST_TO_ADDR
97935: LD_VAR 0 5
97939: PUSH
97940: FOR_TO
97941: IFFALSE 97988
// begin hc_class := 21 ;
97943: LD_ADDR_OWVAR 28
97947: PUSH
97948: LD_INT 21
97950: ST_TO_ADDR
// hc_gallery :=  ;
97951: LD_ADDR_OWVAR 33
97955: PUSH
97956: LD_STRING 
97958: ST_TO_ADDR
// animal := CreateHuman ;
97959: LD_ADDR_VAR 0 12
97963: PUSH
97964: CALL_OW 44
97968: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97969: LD_VAR 0 12
97973: PPUSH
97974: LD_VAR 0 8
97978: PPUSH
97979: LD_INT 0
97981: PPUSH
97982: CALL 100107 0 3
// end ;
97986: GO 97940
97988: POP
97989: POP
// if birds then
97990: LD_VAR 0 1
97994: IFFALSE 98061
// for i = 1 to birds do
97996: LD_ADDR_VAR 0 11
98000: PUSH
98001: DOUBLE
98002: LD_INT 1
98004: DEC
98005: ST_TO_ADDR
98006: LD_VAR 0 1
98010: PUSH
98011: FOR_TO
98012: IFFALSE 98059
// begin hc_class = 18 ;
98014: LD_ADDR_OWVAR 28
98018: PUSH
98019: LD_INT 18
98021: ST_TO_ADDR
// hc_gallery =  ;
98022: LD_ADDR_OWVAR 33
98026: PUSH
98027: LD_STRING 
98029: ST_TO_ADDR
// animal := CreateHuman ;
98030: LD_ADDR_VAR 0 12
98034: PUSH
98035: CALL_OW 44
98039: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98040: LD_VAR 0 12
98044: PPUSH
98045: LD_VAR 0 8
98049: PPUSH
98050: LD_INT 0
98052: PPUSH
98053: CALL 100107 0 3
// end ;
98057: GO 98011
98059: POP
98060: POP
// if tigers then
98061: LD_VAR 0 2
98065: IFFALSE 98149
// for i = 1 to tigers do
98067: LD_ADDR_VAR 0 11
98071: PUSH
98072: DOUBLE
98073: LD_INT 1
98075: DEC
98076: ST_TO_ADDR
98077: LD_VAR 0 2
98081: PUSH
98082: FOR_TO
98083: IFFALSE 98147
// begin hc_class = class_tiger ;
98085: LD_ADDR_OWVAR 28
98089: PUSH
98090: LD_INT 14
98092: ST_TO_ADDR
// hc_gallery =  ;
98093: LD_ADDR_OWVAR 33
98097: PUSH
98098: LD_STRING 
98100: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98101: LD_ADDR_OWVAR 35
98105: PUSH
98106: LD_INT 7
98108: NEG
98109: PPUSH
98110: LD_INT 7
98112: PPUSH
98113: CALL_OW 12
98117: ST_TO_ADDR
// animal := CreateHuman ;
98118: LD_ADDR_VAR 0 12
98122: PUSH
98123: CALL_OW 44
98127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98128: LD_VAR 0 12
98132: PPUSH
98133: LD_VAR 0 8
98137: PPUSH
98138: LD_INT 0
98140: PPUSH
98141: CALL 100107 0 3
// end ;
98145: GO 98082
98147: POP
98148: POP
// if apemans then
98149: LD_VAR 0 3
98153: IFFALSE 98276
// for i = 1 to apemans do
98155: LD_ADDR_VAR 0 11
98159: PUSH
98160: DOUBLE
98161: LD_INT 1
98163: DEC
98164: ST_TO_ADDR
98165: LD_VAR 0 3
98169: PUSH
98170: FOR_TO
98171: IFFALSE 98274
// begin hc_class = class_apeman ;
98173: LD_ADDR_OWVAR 28
98177: PUSH
98178: LD_INT 12
98180: ST_TO_ADDR
// hc_gallery =  ;
98181: LD_ADDR_OWVAR 33
98185: PUSH
98186: LD_STRING 
98188: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98189: LD_ADDR_OWVAR 35
98193: PUSH
98194: LD_INT 5
98196: NEG
98197: PPUSH
98198: LD_INT 5
98200: PPUSH
98201: CALL_OW 12
98205: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98206: LD_ADDR_OWVAR 31
98210: PUSH
98211: LD_INT 1
98213: PPUSH
98214: LD_INT 3
98216: PPUSH
98217: CALL_OW 12
98221: PUSH
98222: LD_INT 1
98224: PPUSH
98225: LD_INT 3
98227: PPUSH
98228: CALL_OW 12
98232: PUSH
98233: LD_INT 0
98235: PUSH
98236: LD_INT 0
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: ST_TO_ADDR
// animal := CreateHuman ;
98245: LD_ADDR_VAR 0 12
98249: PUSH
98250: CALL_OW 44
98254: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98255: LD_VAR 0 12
98259: PPUSH
98260: LD_VAR 0 8
98264: PPUSH
98265: LD_INT 0
98267: PPUSH
98268: CALL 100107 0 3
// end ;
98272: GO 98170
98274: POP
98275: POP
// if enchidnas then
98276: LD_VAR 0 4
98280: IFFALSE 98347
// for i = 1 to enchidnas do
98282: LD_ADDR_VAR 0 11
98286: PUSH
98287: DOUBLE
98288: LD_INT 1
98290: DEC
98291: ST_TO_ADDR
98292: LD_VAR 0 4
98296: PUSH
98297: FOR_TO
98298: IFFALSE 98345
// begin hc_class = 13 ;
98300: LD_ADDR_OWVAR 28
98304: PUSH
98305: LD_INT 13
98307: ST_TO_ADDR
// hc_gallery =  ;
98308: LD_ADDR_OWVAR 33
98312: PUSH
98313: LD_STRING 
98315: ST_TO_ADDR
// animal := CreateHuman ;
98316: LD_ADDR_VAR 0 12
98320: PUSH
98321: CALL_OW 44
98325: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98326: LD_VAR 0 12
98330: PPUSH
98331: LD_VAR 0 8
98335: PPUSH
98336: LD_INT 0
98338: PPUSH
98339: CALL 100107 0 3
// end ;
98343: GO 98297
98345: POP
98346: POP
// if fishes then
98347: LD_VAR 0 7
98351: IFFALSE 98418
// for i = 1 to fishes do
98353: LD_ADDR_VAR 0 11
98357: PUSH
98358: DOUBLE
98359: LD_INT 1
98361: DEC
98362: ST_TO_ADDR
98363: LD_VAR 0 7
98367: PUSH
98368: FOR_TO
98369: IFFALSE 98416
// begin hc_class = 20 ;
98371: LD_ADDR_OWVAR 28
98375: PUSH
98376: LD_INT 20
98378: ST_TO_ADDR
// hc_gallery =  ;
98379: LD_ADDR_OWVAR 33
98383: PUSH
98384: LD_STRING 
98386: ST_TO_ADDR
// animal := CreateHuman ;
98387: LD_ADDR_VAR 0 12
98391: PUSH
98392: CALL_OW 44
98396: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98397: LD_VAR 0 12
98401: PPUSH
98402: LD_VAR 0 9
98406: PPUSH
98407: LD_INT 0
98409: PPUSH
98410: CALL 100107 0 3
// end ;
98414: GO 98368
98416: POP
98417: POP
// end ;
98418: LD_VAR 0 10
98422: RET
// export function WantHeal ( sci , unit ) ; begin
98423: LD_INT 0
98425: PPUSH
// if GetTaskList ( sci ) > 0 then
98426: LD_VAR 0 1
98430: PPUSH
98431: CALL_OW 437
98435: PUSH
98436: LD_INT 0
98438: GREATER
98439: IFFALSE 98509
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 437
98450: PUSH
98451: LD_INT 1
98453: ARRAY
98454: PUSH
98455: LD_INT 1
98457: ARRAY
98458: PUSH
98459: LD_STRING l
98461: EQUAL
98462: PUSH
98463: LD_VAR 0 1
98467: PPUSH
98468: CALL_OW 437
98472: PUSH
98473: LD_INT 1
98475: ARRAY
98476: PUSH
98477: LD_INT 4
98479: ARRAY
98480: PUSH
98481: LD_VAR 0 2
98485: EQUAL
98486: AND
98487: IFFALSE 98499
// result := true else
98489: LD_ADDR_VAR 0 3
98493: PUSH
98494: LD_INT 1
98496: ST_TO_ADDR
98497: GO 98507
// result := false ;
98499: LD_ADDR_VAR 0 3
98503: PUSH
98504: LD_INT 0
98506: ST_TO_ADDR
// end else
98507: GO 98517
// result := false ;
98509: LD_ADDR_VAR 0 3
98513: PUSH
98514: LD_INT 0
98516: ST_TO_ADDR
// end ;
98517: LD_VAR 0 3
98521: RET
// export function HealTarget ( sci ) ; begin
98522: LD_INT 0
98524: PPUSH
// if not sci then
98525: LD_VAR 0 1
98529: NOT
98530: IFFALSE 98534
// exit ;
98532: GO 98599
// result := 0 ;
98534: LD_ADDR_VAR 0 2
98538: PUSH
98539: LD_INT 0
98541: ST_TO_ADDR
// if GetTaskList ( sci ) then
98542: LD_VAR 0 1
98546: PPUSH
98547: CALL_OW 437
98551: IFFALSE 98599
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98553: LD_VAR 0 1
98557: PPUSH
98558: CALL_OW 437
98562: PUSH
98563: LD_INT 1
98565: ARRAY
98566: PUSH
98567: LD_INT 1
98569: ARRAY
98570: PUSH
98571: LD_STRING l
98573: EQUAL
98574: IFFALSE 98599
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98576: LD_ADDR_VAR 0 2
98580: PUSH
98581: LD_VAR 0 1
98585: PPUSH
98586: CALL_OW 437
98590: PUSH
98591: LD_INT 1
98593: ARRAY
98594: PUSH
98595: LD_INT 4
98597: ARRAY
98598: ST_TO_ADDR
// end ;
98599: LD_VAR 0 2
98603: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98604: LD_INT 0
98606: PPUSH
98607: PPUSH
98608: PPUSH
98609: PPUSH
// if not base_units then
98610: LD_VAR 0 1
98614: NOT
98615: IFFALSE 98619
// exit ;
98617: GO 98706
// result := false ;
98619: LD_ADDR_VAR 0 2
98623: PUSH
98624: LD_INT 0
98626: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98627: LD_ADDR_VAR 0 5
98631: PUSH
98632: LD_VAR 0 1
98636: PPUSH
98637: LD_INT 21
98639: PUSH
98640: LD_INT 3
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PPUSH
98647: CALL_OW 72
98651: ST_TO_ADDR
// if not tmp then
98652: LD_VAR 0 5
98656: NOT
98657: IFFALSE 98661
// exit ;
98659: GO 98706
// for i in tmp do
98661: LD_ADDR_VAR 0 3
98665: PUSH
98666: LD_VAR 0 5
98670: PUSH
98671: FOR_IN
98672: IFFALSE 98704
// begin result := EnemyInRange ( i , 22 ) ;
98674: LD_ADDR_VAR 0 2
98678: PUSH
98679: LD_VAR 0 3
98683: PPUSH
98684: LD_INT 22
98686: PPUSH
98687: CALL 96942 0 2
98691: ST_TO_ADDR
// if result then
98692: LD_VAR 0 2
98696: IFFALSE 98702
// exit ;
98698: POP
98699: POP
98700: GO 98706
// end ;
98702: GO 98671
98704: POP
98705: POP
// end ;
98706: LD_VAR 0 2
98710: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98711: LD_INT 0
98713: PPUSH
98714: PPUSH
// if not units then
98715: LD_VAR 0 1
98719: NOT
98720: IFFALSE 98724
// exit ;
98722: GO 98794
// result := [ ] ;
98724: LD_ADDR_VAR 0 3
98728: PUSH
98729: EMPTY
98730: ST_TO_ADDR
// for i in units do
98731: LD_ADDR_VAR 0 4
98735: PUSH
98736: LD_VAR 0 1
98740: PUSH
98741: FOR_IN
98742: IFFALSE 98792
// if GetTag ( i ) = tag then
98744: LD_VAR 0 4
98748: PPUSH
98749: CALL_OW 110
98753: PUSH
98754: LD_VAR 0 2
98758: EQUAL
98759: IFFALSE 98790
// result := Insert ( result , result + 1 , i ) ;
98761: LD_ADDR_VAR 0 3
98765: PUSH
98766: LD_VAR 0 3
98770: PPUSH
98771: LD_VAR 0 3
98775: PUSH
98776: LD_INT 1
98778: PLUS
98779: PPUSH
98780: LD_VAR 0 4
98784: PPUSH
98785: CALL_OW 2
98789: ST_TO_ADDR
98790: GO 98741
98792: POP
98793: POP
// end ;
98794: LD_VAR 0 3
98798: RET
// export function IsDriver ( un ) ; begin
98799: LD_INT 0
98801: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98802: LD_ADDR_VAR 0 2
98806: PUSH
98807: LD_VAR 0 1
98811: PUSH
98812: LD_INT 55
98814: PUSH
98815: EMPTY
98816: LIST
98817: PPUSH
98818: CALL_OW 69
98822: IN
98823: ST_TO_ADDR
// end ;
98824: LD_VAR 0 2
98828: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98829: LD_INT 0
98831: PPUSH
98832: PPUSH
// list := [ ] ;
98833: LD_ADDR_VAR 0 5
98837: PUSH
98838: EMPTY
98839: ST_TO_ADDR
// case d of 0 :
98840: LD_VAR 0 3
98844: PUSH
98845: LD_INT 0
98847: DOUBLE
98848: EQUAL
98849: IFTRUE 98853
98851: GO 98986
98853: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98854: LD_ADDR_VAR 0 5
98858: PUSH
98859: LD_VAR 0 1
98863: PUSH
98864: LD_INT 4
98866: MINUS
98867: PUSH
98868: LD_VAR 0 2
98872: PUSH
98873: LD_INT 4
98875: MINUS
98876: PUSH
98877: LD_INT 2
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: LIST
98884: PUSH
98885: LD_VAR 0 1
98889: PUSH
98890: LD_INT 3
98892: MINUS
98893: PUSH
98894: LD_VAR 0 2
98898: PUSH
98899: LD_INT 1
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: LIST
98906: PUSH
98907: LD_VAR 0 1
98911: PUSH
98912: LD_INT 4
98914: PLUS
98915: PUSH
98916: LD_VAR 0 2
98920: PUSH
98921: LD_INT 4
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: LIST
98928: PUSH
98929: LD_VAR 0 1
98933: PUSH
98934: LD_INT 3
98936: PLUS
98937: PUSH
98938: LD_VAR 0 2
98942: PUSH
98943: LD_INT 3
98945: PLUS
98946: PUSH
98947: LD_INT 5
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: LIST
98954: PUSH
98955: LD_VAR 0 1
98959: PUSH
98960: LD_VAR 0 2
98964: PUSH
98965: LD_INT 4
98967: PLUS
98968: PUSH
98969: LD_INT 0
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: LIST
98976: PUSH
98977: EMPTY
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: ST_TO_ADDR
// end ; 1 :
98984: GO 99684
98986: LD_INT 1
98988: DOUBLE
98989: EQUAL
98990: IFTRUE 98994
98992: GO 99127
98994: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98995: LD_ADDR_VAR 0 5
98999: PUSH
99000: LD_VAR 0 1
99004: PUSH
99005: LD_VAR 0 2
99009: PUSH
99010: LD_INT 4
99012: MINUS
99013: PUSH
99014: LD_INT 3
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: LIST
99021: PUSH
99022: LD_VAR 0 1
99026: PUSH
99027: LD_INT 3
99029: MINUS
99030: PUSH
99031: LD_VAR 0 2
99035: PUSH
99036: LD_INT 3
99038: MINUS
99039: PUSH
99040: LD_INT 2
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: PUSH
99048: LD_VAR 0 1
99052: PUSH
99053: LD_INT 4
99055: MINUS
99056: PUSH
99057: LD_VAR 0 2
99061: PUSH
99062: LD_INT 1
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: LIST
99069: PUSH
99070: LD_VAR 0 1
99074: PUSH
99075: LD_VAR 0 2
99079: PUSH
99080: LD_INT 3
99082: PLUS
99083: PUSH
99084: LD_INT 0
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: LIST
99091: PUSH
99092: LD_VAR 0 1
99096: PUSH
99097: LD_INT 4
99099: PLUS
99100: PUSH
99101: LD_VAR 0 2
99105: PUSH
99106: LD_INT 4
99108: PLUS
99109: PUSH
99110: LD_INT 5
99112: PUSH
99113: EMPTY
99114: LIST
99115: LIST
99116: LIST
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: ST_TO_ADDR
// end ; 2 :
99125: GO 99684
99127: LD_INT 2
99129: DOUBLE
99130: EQUAL
99131: IFTRUE 99135
99133: GO 99264
99135: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99136: LD_ADDR_VAR 0 5
99140: PUSH
99141: LD_VAR 0 1
99145: PUSH
99146: LD_VAR 0 2
99150: PUSH
99151: LD_INT 3
99153: MINUS
99154: PUSH
99155: LD_INT 3
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: LIST
99162: PUSH
99163: LD_VAR 0 1
99167: PUSH
99168: LD_INT 4
99170: PLUS
99171: PUSH
99172: LD_VAR 0 2
99176: PUSH
99177: LD_INT 4
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: LIST
99184: PUSH
99185: LD_VAR 0 1
99189: PUSH
99190: LD_VAR 0 2
99194: PUSH
99195: LD_INT 4
99197: PLUS
99198: PUSH
99199: LD_INT 0
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: LD_VAR 0 1
99211: PUSH
99212: LD_INT 3
99214: MINUS
99215: PUSH
99216: LD_VAR 0 2
99220: PUSH
99221: LD_INT 1
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: LIST
99228: PUSH
99229: LD_VAR 0 1
99233: PUSH
99234: LD_INT 4
99236: MINUS
99237: PUSH
99238: LD_VAR 0 2
99242: PUSH
99243: LD_INT 4
99245: MINUS
99246: PUSH
99247: LD_INT 2
99249: PUSH
99250: EMPTY
99251: LIST
99252: LIST
99253: LIST
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: ST_TO_ADDR
// end ; 3 :
99262: GO 99684
99264: LD_INT 3
99266: DOUBLE
99267: EQUAL
99268: IFTRUE 99272
99270: GO 99405
99272: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99273: LD_ADDR_VAR 0 5
99277: PUSH
99278: LD_VAR 0 1
99282: PUSH
99283: LD_INT 3
99285: PLUS
99286: PUSH
99287: LD_VAR 0 2
99291: PUSH
99292: LD_INT 4
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: LIST
99299: PUSH
99300: LD_VAR 0 1
99304: PUSH
99305: LD_INT 4
99307: PLUS
99308: PUSH
99309: LD_VAR 0 2
99313: PUSH
99314: LD_INT 4
99316: PLUS
99317: PUSH
99318: LD_INT 5
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: LIST
99325: PUSH
99326: LD_VAR 0 1
99330: PUSH
99331: LD_INT 4
99333: MINUS
99334: PUSH
99335: LD_VAR 0 2
99339: PUSH
99340: LD_INT 1
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: LIST
99347: PUSH
99348: LD_VAR 0 1
99352: PUSH
99353: LD_VAR 0 2
99357: PUSH
99358: LD_INT 4
99360: MINUS
99361: PUSH
99362: LD_INT 3
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: LIST
99369: PUSH
99370: LD_VAR 0 1
99374: PUSH
99375: LD_INT 3
99377: MINUS
99378: PUSH
99379: LD_VAR 0 2
99383: PUSH
99384: LD_INT 3
99386: MINUS
99387: PUSH
99388: LD_INT 2
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: LIST
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: ST_TO_ADDR
// end ; 4 :
99403: GO 99684
99405: LD_INT 4
99407: DOUBLE
99408: EQUAL
99409: IFTRUE 99413
99411: GO 99546
99413: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99414: LD_ADDR_VAR 0 5
99418: PUSH
99419: LD_VAR 0 1
99423: PUSH
99424: LD_VAR 0 2
99428: PUSH
99429: LD_INT 4
99431: PLUS
99432: PUSH
99433: LD_INT 0
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: LIST
99440: PUSH
99441: LD_VAR 0 1
99445: PUSH
99446: LD_INT 3
99448: PLUS
99449: PUSH
99450: LD_VAR 0 2
99454: PUSH
99455: LD_INT 3
99457: PLUS
99458: PUSH
99459: LD_INT 5
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: LIST
99466: PUSH
99467: LD_VAR 0 1
99471: PUSH
99472: LD_INT 4
99474: PLUS
99475: PUSH
99476: LD_VAR 0 2
99480: PUSH
99481: LD_INT 4
99483: PUSH
99484: EMPTY
99485: LIST
99486: LIST
99487: LIST
99488: PUSH
99489: LD_VAR 0 1
99493: PUSH
99494: LD_VAR 0 2
99498: PUSH
99499: LD_INT 3
99501: MINUS
99502: PUSH
99503: LD_INT 3
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: LIST
99510: PUSH
99511: LD_VAR 0 1
99515: PUSH
99516: LD_INT 4
99518: MINUS
99519: PUSH
99520: LD_VAR 0 2
99524: PUSH
99525: LD_INT 4
99527: MINUS
99528: PUSH
99529: LD_INT 2
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: LIST
99536: PUSH
99537: EMPTY
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: ST_TO_ADDR
// end ; 5 :
99544: GO 99684
99546: LD_INT 5
99548: DOUBLE
99549: EQUAL
99550: IFTRUE 99554
99552: GO 99683
99554: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99555: LD_ADDR_VAR 0 5
99559: PUSH
99560: LD_VAR 0 1
99564: PUSH
99565: LD_INT 4
99567: MINUS
99568: PUSH
99569: LD_VAR 0 2
99573: PUSH
99574: LD_INT 1
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: PUSH
99582: LD_VAR 0 1
99586: PUSH
99587: LD_VAR 0 2
99591: PUSH
99592: LD_INT 4
99594: MINUS
99595: PUSH
99596: LD_INT 3
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: LIST
99603: PUSH
99604: LD_VAR 0 1
99608: PUSH
99609: LD_INT 4
99611: PLUS
99612: PUSH
99613: LD_VAR 0 2
99617: PUSH
99618: LD_INT 4
99620: PLUS
99621: PUSH
99622: LD_INT 5
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: LIST
99629: PUSH
99630: LD_VAR 0 1
99634: PUSH
99635: LD_INT 3
99637: PLUS
99638: PUSH
99639: LD_VAR 0 2
99643: PUSH
99644: LD_INT 4
99646: PUSH
99647: EMPTY
99648: LIST
99649: LIST
99650: LIST
99651: PUSH
99652: LD_VAR 0 1
99656: PUSH
99657: LD_VAR 0 2
99661: PUSH
99662: LD_INT 3
99664: PLUS
99665: PUSH
99666: LD_INT 0
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: LIST
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: ST_TO_ADDR
// end ; end ;
99681: GO 99684
99683: POP
// result := list ;
99684: LD_ADDR_VAR 0 4
99688: PUSH
99689: LD_VAR 0 5
99693: ST_TO_ADDR
// end ;
99694: LD_VAR 0 4
99698: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99699: LD_INT 0
99701: PPUSH
99702: PPUSH
99703: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99704: LD_VAR 0 1
99708: NOT
99709: PUSH
99710: LD_VAR 0 2
99714: PUSH
99715: LD_INT 1
99717: PUSH
99718: LD_INT 2
99720: PUSH
99721: LD_INT 3
99723: PUSH
99724: LD_INT 4
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: IN
99733: NOT
99734: OR
99735: IFFALSE 99739
// exit ;
99737: GO 99831
// tmp := [ ] ;
99739: LD_ADDR_VAR 0 5
99743: PUSH
99744: EMPTY
99745: ST_TO_ADDR
// for i in units do
99746: LD_ADDR_VAR 0 4
99750: PUSH
99751: LD_VAR 0 1
99755: PUSH
99756: FOR_IN
99757: IFFALSE 99800
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99759: LD_ADDR_VAR 0 5
99763: PUSH
99764: LD_VAR 0 5
99768: PPUSH
99769: LD_VAR 0 5
99773: PUSH
99774: LD_INT 1
99776: PLUS
99777: PPUSH
99778: LD_VAR 0 4
99782: PPUSH
99783: LD_VAR 0 2
99787: PPUSH
99788: CALL_OW 259
99792: PPUSH
99793: CALL_OW 2
99797: ST_TO_ADDR
99798: GO 99756
99800: POP
99801: POP
// if not tmp then
99802: LD_VAR 0 5
99806: NOT
99807: IFFALSE 99811
// exit ;
99809: GO 99831
// result := SortListByListDesc ( units , tmp ) ;
99811: LD_ADDR_VAR 0 3
99815: PUSH
99816: LD_VAR 0 1
99820: PPUSH
99821: LD_VAR 0 5
99825: PPUSH
99826: CALL_OW 77
99830: ST_TO_ADDR
// end ;
99831: LD_VAR 0 3
99835: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99836: LD_INT 0
99838: PPUSH
99839: PPUSH
99840: PPUSH
// result := false ;
99841: LD_ADDR_VAR 0 3
99845: PUSH
99846: LD_INT 0
99848: ST_TO_ADDR
// x := GetX ( building ) ;
99849: LD_ADDR_VAR 0 4
99853: PUSH
99854: LD_VAR 0 2
99858: PPUSH
99859: CALL_OW 250
99863: ST_TO_ADDR
// y := GetY ( building ) ;
99864: LD_ADDR_VAR 0 5
99868: PUSH
99869: LD_VAR 0 2
99873: PPUSH
99874: CALL_OW 251
99878: ST_TO_ADDR
// if not building or not x or not y then
99879: LD_VAR 0 2
99883: NOT
99884: PUSH
99885: LD_VAR 0 4
99889: NOT
99890: OR
99891: PUSH
99892: LD_VAR 0 5
99896: NOT
99897: OR
99898: IFFALSE 99902
// exit ;
99900: GO 99994
// if GetTaskList ( unit ) then
99902: LD_VAR 0 1
99906: PPUSH
99907: CALL_OW 437
99911: IFFALSE 99994
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99913: LD_STRING e
99915: PUSH
99916: LD_VAR 0 1
99920: PPUSH
99921: CALL_OW 437
99925: PUSH
99926: LD_INT 1
99928: ARRAY
99929: PUSH
99930: LD_INT 1
99932: ARRAY
99933: EQUAL
99934: PUSH
99935: LD_VAR 0 4
99939: PUSH
99940: LD_VAR 0 1
99944: PPUSH
99945: CALL_OW 437
99949: PUSH
99950: LD_INT 1
99952: ARRAY
99953: PUSH
99954: LD_INT 2
99956: ARRAY
99957: EQUAL
99958: AND
99959: PUSH
99960: LD_VAR 0 5
99964: PUSH
99965: LD_VAR 0 1
99969: PPUSH
99970: CALL_OW 437
99974: PUSH
99975: LD_INT 1
99977: ARRAY
99978: PUSH
99979: LD_INT 3
99981: ARRAY
99982: EQUAL
99983: AND
99984: IFFALSE 99994
// result := true end ;
99986: LD_ADDR_VAR 0 3
99990: PUSH
99991: LD_INT 1
99993: ST_TO_ADDR
// end ;
99994: LD_VAR 0 3
99998: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99999: LD_INT 0
100001: PPUSH
// result := false ;
100002: LD_ADDR_VAR 0 4
100006: PUSH
100007: LD_INT 0
100009: ST_TO_ADDR
// if GetTaskList ( unit ) then
100010: LD_VAR 0 1
100014: PPUSH
100015: CALL_OW 437
100019: IFFALSE 100102
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100021: LD_STRING M
100023: PUSH
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 437
100033: PUSH
100034: LD_INT 1
100036: ARRAY
100037: PUSH
100038: LD_INT 1
100040: ARRAY
100041: EQUAL
100042: PUSH
100043: LD_VAR 0 2
100047: PUSH
100048: LD_VAR 0 1
100052: PPUSH
100053: CALL_OW 437
100057: PUSH
100058: LD_INT 1
100060: ARRAY
100061: PUSH
100062: LD_INT 2
100064: ARRAY
100065: EQUAL
100066: AND
100067: PUSH
100068: LD_VAR 0 3
100072: PUSH
100073: LD_VAR 0 1
100077: PPUSH
100078: CALL_OW 437
100082: PUSH
100083: LD_INT 1
100085: ARRAY
100086: PUSH
100087: LD_INT 3
100089: ARRAY
100090: EQUAL
100091: AND
100092: IFFALSE 100102
// result := true ;
100094: LD_ADDR_VAR 0 4
100098: PUSH
100099: LD_INT 1
100101: ST_TO_ADDR
// end ; end ;
100102: LD_VAR 0 4
100106: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100107: LD_INT 0
100109: PPUSH
100110: PPUSH
100111: PPUSH
100112: PPUSH
// if not unit or not area then
100113: LD_VAR 0 1
100117: NOT
100118: PUSH
100119: LD_VAR 0 2
100123: NOT
100124: OR
100125: IFFALSE 100129
// exit ;
100127: GO 100293
// tmp := AreaToList ( area , i ) ;
100129: LD_ADDR_VAR 0 6
100133: PUSH
100134: LD_VAR 0 2
100138: PPUSH
100139: LD_VAR 0 5
100143: PPUSH
100144: CALL_OW 517
100148: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100149: LD_ADDR_VAR 0 5
100153: PUSH
100154: DOUBLE
100155: LD_INT 1
100157: DEC
100158: ST_TO_ADDR
100159: LD_VAR 0 6
100163: PUSH
100164: LD_INT 1
100166: ARRAY
100167: PUSH
100168: FOR_TO
100169: IFFALSE 100291
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100171: LD_ADDR_VAR 0 7
100175: PUSH
100176: LD_VAR 0 6
100180: PUSH
100181: LD_INT 1
100183: ARRAY
100184: PUSH
100185: LD_VAR 0 5
100189: ARRAY
100190: PUSH
100191: LD_VAR 0 6
100195: PUSH
100196: LD_INT 2
100198: ARRAY
100199: PUSH
100200: LD_VAR 0 5
100204: ARRAY
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100210: LD_VAR 0 7
100214: PUSH
100215: LD_INT 1
100217: ARRAY
100218: PPUSH
100219: LD_VAR 0 7
100223: PUSH
100224: LD_INT 2
100226: ARRAY
100227: PPUSH
100228: CALL_OW 428
100232: PUSH
100233: LD_INT 0
100235: EQUAL
100236: IFFALSE 100289
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100238: LD_VAR 0 1
100242: PPUSH
100243: LD_VAR 0 7
100247: PUSH
100248: LD_INT 1
100250: ARRAY
100251: PPUSH
100252: LD_VAR 0 7
100256: PUSH
100257: LD_INT 2
100259: ARRAY
100260: PPUSH
100261: LD_VAR 0 3
100265: PPUSH
100266: CALL_OW 48
// result := IsPlaced ( unit ) ;
100270: LD_ADDR_VAR 0 4
100274: PUSH
100275: LD_VAR 0 1
100279: PPUSH
100280: CALL_OW 305
100284: ST_TO_ADDR
// exit ;
100285: POP
100286: POP
100287: GO 100293
// end ; end ;
100289: GO 100168
100291: POP
100292: POP
// end ;
100293: LD_VAR 0 4
100297: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100298: LD_INT 0
100300: PPUSH
100301: PPUSH
100302: PPUSH
// if not side or side > 8 then
100303: LD_VAR 0 1
100307: NOT
100308: PUSH
100309: LD_VAR 0 1
100313: PUSH
100314: LD_INT 8
100316: GREATER
100317: OR
100318: IFFALSE 100322
// exit ;
100320: GO 100509
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100322: LD_ADDR_VAR 0 4
100326: PUSH
100327: LD_INT 22
100329: PUSH
100330: LD_VAR 0 1
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: LD_INT 21
100341: PUSH
100342: LD_INT 3
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PPUSH
100353: CALL_OW 69
100357: ST_TO_ADDR
// if not tmp then
100358: LD_VAR 0 4
100362: NOT
100363: IFFALSE 100367
// exit ;
100365: GO 100509
// enable_addtolog := true ;
100367: LD_ADDR_OWVAR 81
100371: PUSH
100372: LD_INT 1
100374: ST_TO_ADDR
// AddToLog ( [ ) ;
100375: LD_STRING [
100377: PPUSH
100378: CALL_OW 561
// for i in tmp do
100382: LD_ADDR_VAR 0 3
100386: PUSH
100387: LD_VAR 0 4
100391: PUSH
100392: FOR_IN
100393: IFFALSE 100500
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100395: LD_STRING [
100397: PUSH
100398: LD_VAR 0 3
100402: PPUSH
100403: CALL_OW 266
100407: STR
100408: PUSH
100409: LD_STRING , 
100411: STR
100412: PUSH
100413: LD_VAR 0 3
100417: PPUSH
100418: CALL_OW 250
100422: STR
100423: PUSH
100424: LD_STRING , 
100426: STR
100427: PUSH
100428: LD_VAR 0 3
100432: PPUSH
100433: CALL_OW 251
100437: STR
100438: PUSH
100439: LD_STRING , 
100441: STR
100442: PUSH
100443: LD_VAR 0 3
100447: PPUSH
100448: CALL_OW 254
100452: STR
100453: PUSH
100454: LD_STRING , 
100456: STR
100457: PUSH
100458: LD_VAR 0 3
100462: PPUSH
100463: LD_INT 1
100465: PPUSH
100466: CALL_OW 268
100470: STR
100471: PUSH
100472: LD_STRING , 
100474: STR
100475: PUSH
100476: LD_VAR 0 3
100480: PPUSH
100481: LD_INT 2
100483: PPUSH
100484: CALL_OW 268
100488: STR
100489: PUSH
100490: LD_STRING ],
100492: STR
100493: PPUSH
100494: CALL_OW 561
// end ;
100498: GO 100392
100500: POP
100501: POP
// AddToLog ( ]; ) ;
100502: LD_STRING ];
100504: PPUSH
100505: CALL_OW 561
// end ;
100509: LD_VAR 0 2
100513: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100514: LD_INT 0
100516: PPUSH
100517: PPUSH
100518: PPUSH
100519: PPUSH
100520: PPUSH
// if not area or not rate or not max then
100521: LD_VAR 0 1
100525: NOT
100526: PUSH
100527: LD_VAR 0 2
100531: NOT
100532: OR
100533: PUSH
100534: LD_VAR 0 4
100538: NOT
100539: OR
100540: IFFALSE 100544
// exit ;
100542: GO 100736
// while 1 do
100544: LD_INT 1
100546: IFFALSE 100736
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100548: LD_ADDR_VAR 0 9
100552: PUSH
100553: LD_VAR 0 1
100557: PPUSH
100558: LD_INT 1
100560: PPUSH
100561: CALL_OW 287
100565: PUSH
100566: LD_INT 10
100568: MUL
100569: ST_TO_ADDR
// r := rate / 10 ;
100570: LD_ADDR_VAR 0 7
100574: PUSH
100575: LD_VAR 0 2
100579: PUSH
100580: LD_INT 10
100582: DIVREAL
100583: ST_TO_ADDR
// time := 1 1$00 ;
100584: LD_ADDR_VAR 0 8
100588: PUSH
100589: LD_INT 2100
100591: ST_TO_ADDR
// if amount < min then
100592: LD_VAR 0 9
100596: PUSH
100597: LD_VAR 0 3
100601: LESS
100602: IFFALSE 100620
// r := r * 2 else
100604: LD_ADDR_VAR 0 7
100608: PUSH
100609: LD_VAR 0 7
100613: PUSH
100614: LD_INT 2
100616: MUL
100617: ST_TO_ADDR
100618: GO 100646
// if amount > max then
100620: LD_VAR 0 9
100624: PUSH
100625: LD_VAR 0 4
100629: GREATER
100630: IFFALSE 100646
// r := r / 2 ;
100632: LD_ADDR_VAR 0 7
100636: PUSH
100637: LD_VAR 0 7
100641: PUSH
100642: LD_INT 2
100644: DIVREAL
100645: ST_TO_ADDR
// time := time / r ;
100646: LD_ADDR_VAR 0 8
100650: PUSH
100651: LD_VAR 0 8
100655: PUSH
100656: LD_VAR 0 7
100660: DIVREAL
100661: ST_TO_ADDR
// if time < 0 then
100662: LD_VAR 0 8
100666: PUSH
100667: LD_INT 0
100669: LESS
100670: IFFALSE 100687
// time := time * - 1 ;
100672: LD_ADDR_VAR 0 8
100676: PUSH
100677: LD_VAR 0 8
100681: PUSH
100682: LD_INT 1
100684: NEG
100685: MUL
100686: ST_TO_ADDR
// wait ( time ) ;
100687: LD_VAR 0 8
100691: PPUSH
100692: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100696: LD_INT 35
100698: PPUSH
100699: LD_INT 875
100701: PPUSH
100702: CALL_OW 12
100706: PPUSH
100707: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100711: LD_INT 1
100713: PPUSH
100714: LD_INT 5
100716: PPUSH
100717: CALL_OW 12
100721: PPUSH
100722: LD_VAR 0 1
100726: PPUSH
100727: LD_INT 1
100729: PPUSH
100730: CALL_OW 55
// end ;
100734: GO 100544
// end ;
100736: LD_VAR 0 5
100740: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100741: LD_INT 0
100743: PPUSH
100744: PPUSH
100745: PPUSH
100746: PPUSH
100747: PPUSH
100748: PPUSH
100749: PPUSH
100750: PPUSH
// if not turrets or not factories then
100751: LD_VAR 0 1
100755: NOT
100756: PUSH
100757: LD_VAR 0 2
100761: NOT
100762: OR
100763: IFFALSE 100767
// exit ;
100765: GO 101074
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100767: LD_ADDR_VAR 0 10
100771: PUSH
100772: LD_INT 5
100774: PUSH
100775: LD_INT 6
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 2
100784: PUSH
100785: LD_INT 4
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: LD_INT 3
100794: PUSH
100795: LD_INT 5
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 24
100809: PUSH
100810: LD_INT 25
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: PUSH
100817: LD_INT 23
100819: PUSH
100820: LD_INT 27
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: PUSH
100831: LD_INT 42
100833: PUSH
100834: LD_INT 43
100836: PUSH
100837: EMPTY
100838: LIST
100839: LIST
100840: PUSH
100841: LD_INT 44
100843: PUSH
100844: LD_INT 46
100846: PUSH
100847: EMPTY
100848: LIST
100849: LIST
100850: PUSH
100851: LD_INT 45
100853: PUSH
100854: LD_INT 47
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: LIST
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: LIST
100870: ST_TO_ADDR
// result := [ ] ;
100871: LD_ADDR_VAR 0 3
100875: PUSH
100876: EMPTY
100877: ST_TO_ADDR
// for i in turrets do
100878: LD_ADDR_VAR 0 4
100882: PUSH
100883: LD_VAR 0 1
100887: PUSH
100888: FOR_IN
100889: IFFALSE 101072
// begin nat := GetNation ( i ) ;
100891: LD_ADDR_VAR 0 7
100895: PUSH
100896: LD_VAR 0 4
100900: PPUSH
100901: CALL_OW 248
100905: ST_TO_ADDR
// weapon := 0 ;
100906: LD_ADDR_VAR 0 8
100910: PUSH
100911: LD_INT 0
100913: ST_TO_ADDR
// if not nat then
100914: LD_VAR 0 7
100918: NOT
100919: IFFALSE 100923
// continue ;
100921: GO 100888
// for j in list [ nat ] do
100923: LD_ADDR_VAR 0 5
100927: PUSH
100928: LD_VAR 0 10
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PUSH
100939: FOR_IN
100940: IFFALSE 100981
// if GetBWeapon ( i ) = j [ 1 ] then
100942: LD_VAR 0 4
100946: PPUSH
100947: CALL_OW 269
100951: PUSH
100952: LD_VAR 0 5
100956: PUSH
100957: LD_INT 1
100959: ARRAY
100960: EQUAL
100961: IFFALSE 100979
// begin weapon := j [ 2 ] ;
100963: LD_ADDR_VAR 0 8
100967: PUSH
100968: LD_VAR 0 5
100972: PUSH
100973: LD_INT 2
100975: ARRAY
100976: ST_TO_ADDR
// break ;
100977: GO 100981
// end ;
100979: GO 100939
100981: POP
100982: POP
// if not weapon then
100983: LD_VAR 0 8
100987: NOT
100988: IFFALSE 100992
// continue ;
100990: GO 100888
// for k in factories do
100992: LD_ADDR_VAR 0 6
100996: PUSH
100997: LD_VAR 0 2
101001: PUSH
101002: FOR_IN
101003: IFFALSE 101068
// begin weapons := AvailableWeaponList ( k ) ;
101005: LD_ADDR_VAR 0 9
101009: PUSH
101010: LD_VAR 0 6
101014: PPUSH
101015: CALL_OW 478
101019: ST_TO_ADDR
// if not weapons then
101020: LD_VAR 0 9
101024: NOT
101025: IFFALSE 101029
// continue ;
101027: GO 101002
// if weapon in weapons then
101029: LD_VAR 0 8
101033: PUSH
101034: LD_VAR 0 9
101038: IN
101039: IFFALSE 101066
// begin result := [ i , weapon ] ;
101041: LD_ADDR_VAR 0 3
101045: PUSH
101046: LD_VAR 0 4
101050: PUSH
101051: LD_VAR 0 8
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: ST_TO_ADDR
// exit ;
101060: POP
101061: POP
101062: POP
101063: POP
101064: GO 101074
// end ; end ;
101066: GO 101002
101068: POP
101069: POP
// end ;
101070: GO 100888
101072: POP
101073: POP
// end ;
101074: LD_VAR 0 3
101078: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101079: LD_INT 0
101081: PPUSH
// if not side or side > 8 then
101082: LD_VAR 0 3
101086: NOT
101087: PUSH
101088: LD_VAR 0 3
101092: PUSH
101093: LD_INT 8
101095: GREATER
101096: OR
101097: IFFALSE 101101
// exit ;
101099: GO 101160
// if not range then
101101: LD_VAR 0 4
101105: NOT
101106: IFFALSE 101117
// range := - 12 ;
101108: LD_ADDR_VAR 0 4
101112: PUSH
101113: LD_INT 12
101115: NEG
101116: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101117: LD_VAR 0 1
101121: PPUSH
101122: LD_VAR 0 2
101126: PPUSH
101127: LD_VAR 0 3
101131: PPUSH
101132: LD_VAR 0 4
101136: PPUSH
101137: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101141: LD_VAR 0 1
101145: PPUSH
101146: LD_VAR 0 2
101150: PPUSH
101151: LD_VAR 0 3
101155: PPUSH
101156: CALL_OW 331
// end ;
101160: LD_VAR 0 5
101164: RET
// export function Video ( mode ) ; begin
101165: LD_INT 0
101167: PPUSH
// ingame_video = mode ;
101168: LD_ADDR_OWVAR 52
101172: PUSH
101173: LD_VAR 0 1
101177: ST_TO_ADDR
// interface_hidden = mode ;
101178: LD_ADDR_OWVAR 54
101182: PUSH
101183: LD_VAR 0 1
101187: ST_TO_ADDR
// end ;
101188: LD_VAR 0 2
101192: RET
// export function Join ( array , element ) ; begin
101193: LD_INT 0
101195: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101196: LD_ADDR_VAR 0 3
101200: PUSH
101201: LD_VAR 0 1
101205: PPUSH
101206: LD_VAR 0 1
101210: PUSH
101211: LD_INT 1
101213: PLUS
101214: PPUSH
101215: LD_VAR 0 2
101219: PPUSH
101220: CALL_OW 1
101224: ST_TO_ADDR
// end ;
101225: LD_VAR 0 3
101229: RET
// export function JoinUnion ( array , element ) ; begin
101230: LD_INT 0
101232: PPUSH
// result := array union element ;
101233: LD_ADDR_VAR 0 3
101237: PUSH
101238: LD_VAR 0 1
101242: PUSH
101243: LD_VAR 0 2
101247: UNION
101248: ST_TO_ADDR
// end ;
101249: LD_VAR 0 3
101253: RET
// export function GetBehemoths ( side ) ; begin
101254: LD_INT 0
101256: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101257: LD_ADDR_VAR 0 2
101261: PUSH
101262: LD_INT 22
101264: PUSH
101265: LD_VAR 0 1
101269: PUSH
101270: EMPTY
101271: LIST
101272: LIST
101273: PUSH
101274: LD_INT 31
101276: PUSH
101277: LD_INT 25
101279: PUSH
101280: EMPTY
101281: LIST
101282: LIST
101283: PUSH
101284: EMPTY
101285: LIST
101286: LIST
101287: PPUSH
101288: CALL_OW 69
101292: ST_TO_ADDR
// end ;
101293: LD_VAR 0 2
101297: RET
// export function Shuffle ( array ) ; var i , index ; begin
101298: LD_INT 0
101300: PPUSH
101301: PPUSH
101302: PPUSH
// result := [ ] ;
101303: LD_ADDR_VAR 0 2
101307: PUSH
101308: EMPTY
101309: ST_TO_ADDR
// if not array then
101310: LD_VAR 0 1
101314: NOT
101315: IFFALSE 101319
// exit ;
101317: GO 101418
// Randomize ;
101319: CALL_OW 10
// for i = array downto 1 do
101323: LD_ADDR_VAR 0 3
101327: PUSH
101328: DOUBLE
101329: LD_VAR 0 1
101333: INC
101334: ST_TO_ADDR
101335: LD_INT 1
101337: PUSH
101338: FOR_DOWNTO
101339: IFFALSE 101416
// begin index := rand ( 1 , array ) ;
101341: LD_ADDR_VAR 0 4
101345: PUSH
101346: LD_INT 1
101348: PPUSH
101349: LD_VAR 0 1
101353: PPUSH
101354: CALL_OW 12
101358: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101359: LD_ADDR_VAR 0 2
101363: PUSH
101364: LD_VAR 0 2
101368: PPUSH
101369: LD_VAR 0 2
101373: PUSH
101374: LD_INT 1
101376: PLUS
101377: PPUSH
101378: LD_VAR 0 1
101382: PUSH
101383: LD_VAR 0 4
101387: ARRAY
101388: PPUSH
101389: CALL_OW 2
101393: ST_TO_ADDR
// array := Delete ( array , index ) ;
101394: LD_ADDR_VAR 0 1
101398: PUSH
101399: LD_VAR 0 1
101403: PPUSH
101404: LD_VAR 0 4
101408: PPUSH
101409: CALL_OW 3
101413: ST_TO_ADDR
// end ;
101414: GO 101338
101416: POP
101417: POP
// end ;
101418: LD_VAR 0 2
101422: RET
// export function GetBaseMaterials ( base ) ; begin
101423: LD_INT 0
101425: PPUSH
// result := [ 0 , 0 , 0 ] ;
101426: LD_ADDR_VAR 0 2
101430: PUSH
101431: LD_INT 0
101433: PUSH
101434: LD_INT 0
101436: PUSH
101437: LD_INT 0
101439: PUSH
101440: EMPTY
101441: LIST
101442: LIST
101443: LIST
101444: ST_TO_ADDR
// if not base then
101445: LD_VAR 0 1
101449: NOT
101450: IFFALSE 101454
// exit ;
101452: GO 101503
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101454: LD_ADDR_VAR 0 2
101458: PUSH
101459: LD_VAR 0 1
101463: PPUSH
101464: LD_INT 1
101466: PPUSH
101467: CALL_OW 275
101471: PUSH
101472: LD_VAR 0 1
101476: PPUSH
101477: LD_INT 2
101479: PPUSH
101480: CALL_OW 275
101484: PUSH
101485: LD_VAR 0 1
101489: PPUSH
101490: LD_INT 3
101492: PPUSH
101493: CALL_OW 275
101497: PUSH
101498: EMPTY
101499: LIST
101500: LIST
101501: LIST
101502: ST_TO_ADDR
// end ;
101503: LD_VAR 0 2
101507: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101508: LD_INT 0
101510: PPUSH
101511: PPUSH
// result := array ;
101512: LD_ADDR_VAR 0 3
101516: PUSH
101517: LD_VAR 0 1
101521: ST_TO_ADDR
// if size > 0 then
101522: LD_VAR 0 2
101526: PUSH
101527: LD_INT 0
101529: GREATER
101530: IFFALSE 101576
// for i := array downto size do
101532: LD_ADDR_VAR 0 4
101536: PUSH
101537: DOUBLE
101538: LD_VAR 0 1
101542: INC
101543: ST_TO_ADDR
101544: LD_VAR 0 2
101548: PUSH
101549: FOR_DOWNTO
101550: IFFALSE 101574
// result := Delete ( result , result ) ;
101552: LD_ADDR_VAR 0 3
101556: PUSH
101557: LD_VAR 0 3
101561: PPUSH
101562: LD_VAR 0 3
101566: PPUSH
101567: CALL_OW 3
101571: ST_TO_ADDR
101572: GO 101549
101574: POP
101575: POP
// end ;
101576: LD_VAR 0 3
101580: RET
// export function ComExit ( unit ) ; var tmp ; begin
101581: LD_INT 0
101583: PPUSH
101584: PPUSH
// if not IsInUnit ( unit ) then
101585: LD_VAR 0 1
101589: PPUSH
101590: CALL_OW 310
101594: NOT
101595: IFFALSE 101599
// exit ;
101597: GO 101659
// tmp := IsInUnit ( unit ) ;
101599: LD_ADDR_VAR 0 3
101603: PUSH
101604: LD_VAR 0 1
101608: PPUSH
101609: CALL_OW 310
101613: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101614: LD_VAR 0 3
101618: PPUSH
101619: CALL_OW 247
101623: PUSH
101624: LD_INT 2
101626: EQUAL
101627: IFFALSE 101640
// ComExitVehicle ( unit ) else
101629: LD_VAR 0 1
101633: PPUSH
101634: CALL_OW 121
101638: GO 101649
// ComExitBuilding ( unit ) ;
101640: LD_VAR 0 1
101644: PPUSH
101645: CALL_OW 122
// result := tmp ;
101649: LD_ADDR_VAR 0 2
101653: PUSH
101654: LD_VAR 0 3
101658: ST_TO_ADDR
// end ;
101659: LD_VAR 0 2
101663: RET
// export function ResetHc ; begin
101664: LD_INT 0
101666: PPUSH
// InitHc ;
101667: CALL_OW 19
// hc_importance := 0 ;
101671: LD_ADDR_OWVAR 32
101675: PUSH
101676: LD_INT 0
101678: ST_TO_ADDR
// end ;
101679: LD_VAR 0 1
101683: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101684: LD_INT 0
101686: PPUSH
101687: PPUSH
101688: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101689: LD_ADDR_VAR 0 6
101693: PUSH
101694: LD_VAR 0 1
101698: PUSH
101699: LD_VAR 0 3
101703: PLUS
101704: PUSH
101705: LD_INT 2
101707: DIV
101708: ST_TO_ADDR
// if _x < 0 then
101709: LD_VAR 0 6
101713: PUSH
101714: LD_INT 0
101716: LESS
101717: IFFALSE 101734
// _x := _x * - 1 ;
101719: LD_ADDR_VAR 0 6
101723: PUSH
101724: LD_VAR 0 6
101728: PUSH
101729: LD_INT 1
101731: NEG
101732: MUL
101733: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101734: LD_ADDR_VAR 0 7
101738: PUSH
101739: LD_VAR 0 2
101743: PUSH
101744: LD_VAR 0 4
101748: PLUS
101749: PUSH
101750: LD_INT 2
101752: DIV
101753: ST_TO_ADDR
// if _y < 0 then
101754: LD_VAR 0 7
101758: PUSH
101759: LD_INT 0
101761: LESS
101762: IFFALSE 101779
// _y := _y * - 1 ;
101764: LD_ADDR_VAR 0 7
101768: PUSH
101769: LD_VAR 0 7
101773: PUSH
101774: LD_INT 1
101776: NEG
101777: MUL
101778: ST_TO_ADDR
// result := [ _x , _y ] ;
101779: LD_ADDR_VAR 0 5
101783: PUSH
101784: LD_VAR 0 6
101788: PUSH
101789: LD_VAR 0 7
101793: PUSH
101794: EMPTY
101795: LIST
101796: LIST
101797: ST_TO_ADDR
// end ;
101798: LD_VAR 0 5
101802: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101803: LD_INT 0
101805: PPUSH
101806: PPUSH
101807: PPUSH
101808: PPUSH
// task := GetTaskList ( unit ) ;
101809: LD_ADDR_VAR 0 7
101813: PUSH
101814: LD_VAR 0 1
101818: PPUSH
101819: CALL_OW 437
101823: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101824: LD_VAR 0 7
101828: NOT
101829: PUSH
101830: LD_VAR 0 1
101834: PPUSH
101835: LD_VAR 0 2
101839: PPUSH
101840: CALL_OW 308
101844: NOT
101845: AND
101846: IFFALSE 101850
// exit ;
101848: GO 101968
// if IsInArea ( unit , area ) then
101850: LD_VAR 0 1
101854: PPUSH
101855: LD_VAR 0 2
101859: PPUSH
101860: CALL_OW 308
101864: IFFALSE 101882
// begin ComMoveToArea ( unit , goAway ) ;
101866: LD_VAR 0 1
101870: PPUSH
101871: LD_VAR 0 3
101875: PPUSH
101876: CALL_OW 113
// exit ;
101880: GO 101968
// end ; if task [ 1 ] [ 1 ] <> M then
101882: LD_VAR 0 7
101886: PUSH
101887: LD_INT 1
101889: ARRAY
101890: PUSH
101891: LD_INT 1
101893: ARRAY
101894: PUSH
101895: LD_STRING M
101897: NONEQUAL
101898: IFFALSE 101902
// exit ;
101900: GO 101968
// x := task [ 1 ] [ 2 ] ;
101902: LD_ADDR_VAR 0 5
101906: PUSH
101907: LD_VAR 0 7
101911: PUSH
101912: LD_INT 1
101914: ARRAY
101915: PUSH
101916: LD_INT 2
101918: ARRAY
101919: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101920: LD_ADDR_VAR 0 6
101924: PUSH
101925: LD_VAR 0 7
101929: PUSH
101930: LD_INT 1
101932: ARRAY
101933: PUSH
101934: LD_INT 3
101936: ARRAY
101937: ST_TO_ADDR
// if InArea ( x , y , area ) then
101938: LD_VAR 0 5
101942: PPUSH
101943: LD_VAR 0 6
101947: PPUSH
101948: LD_VAR 0 2
101952: PPUSH
101953: CALL_OW 309
101957: IFFALSE 101968
// ComStop ( unit ) ;
101959: LD_VAR 0 1
101963: PPUSH
101964: CALL_OW 141
// end ;
101968: LD_VAR 0 4
101972: RET
// export function Abs ( value ) ; begin
101973: LD_INT 0
101975: PPUSH
// result := value ;
101976: LD_ADDR_VAR 0 2
101980: PUSH
101981: LD_VAR 0 1
101985: ST_TO_ADDR
// if value < 0 then
101986: LD_VAR 0 1
101990: PUSH
101991: LD_INT 0
101993: LESS
101994: IFFALSE 102011
// result := value * - 1 ;
101996: LD_ADDR_VAR 0 2
102000: PUSH
102001: LD_VAR 0 1
102005: PUSH
102006: LD_INT 1
102008: NEG
102009: MUL
102010: ST_TO_ADDR
// end ;
102011: LD_VAR 0 2
102015: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102016: LD_INT 0
102018: PPUSH
102019: PPUSH
102020: PPUSH
102021: PPUSH
102022: PPUSH
102023: PPUSH
102024: PPUSH
102025: PPUSH
// if not unit or not building then
102026: LD_VAR 0 1
102030: NOT
102031: PUSH
102032: LD_VAR 0 2
102036: NOT
102037: OR
102038: IFFALSE 102042
// exit ;
102040: GO 102268
// x := GetX ( building ) ;
102042: LD_ADDR_VAR 0 4
102046: PUSH
102047: LD_VAR 0 2
102051: PPUSH
102052: CALL_OW 250
102056: ST_TO_ADDR
// y := GetY ( building ) ;
102057: LD_ADDR_VAR 0 6
102061: PUSH
102062: LD_VAR 0 2
102066: PPUSH
102067: CALL_OW 251
102071: ST_TO_ADDR
// d := GetDir ( building ) ;
102072: LD_ADDR_VAR 0 8
102076: PUSH
102077: LD_VAR 0 2
102081: PPUSH
102082: CALL_OW 254
102086: ST_TO_ADDR
// r := 4 ;
102087: LD_ADDR_VAR 0 9
102091: PUSH
102092: LD_INT 4
102094: ST_TO_ADDR
// for i := 1 to 5 do
102095: LD_ADDR_VAR 0 10
102099: PUSH
102100: DOUBLE
102101: LD_INT 1
102103: DEC
102104: ST_TO_ADDR
102105: LD_INT 5
102107: PUSH
102108: FOR_TO
102109: IFFALSE 102266
// begin _x := ShiftX ( x , d , r + i ) ;
102111: LD_ADDR_VAR 0 5
102115: PUSH
102116: LD_VAR 0 4
102120: PPUSH
102121: LD_VAR 0 8
102125: PPUSH
102126: LD_VAR 0 9
102130: PUSH
102131: LD_VAR 0 10
102135: PLUS
102136: PPUSH
102137: CALL_OW 272
102141: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102142: LD_ADDR_VAR 0 7
102146: PUSH
102147: LD_VAR 0 6
102151: PPUSH
102152: LD_VAR 0 8
102156: PPUSH
102157: LD_VAR 0 9
102161: PUSH
102162: LD_VAR 0 10
102166: PLUS
102167: PPUSH
102168: CALL_OW 273
102172: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102173: LD_VAR 0 5
102177: PPUSH
102178: LD_VAR 0 7
102182: PPUSH
102183: CALL_OW 488
102187: PUSH
102188: LD_VAR 0 5
102192: PPUSH
102193: LD_VAR 0 7
102197: PPUSH
102198: CALL_OW 428
102202: PPUSH
102203: CALL_OW 247
102207: PUSH
102208: LD_INT 3
102210: PUSH
102211: LD_INT 2
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: IN
102218: NOT
102219: AND
102220: IFFALSE 102264
// begin ComMoveXY ( unit , _x , _y ) ;
102222: LD_VAR 0 1
102226: PPUSH
102227: LD_VAR 0 5
102231: PPUSH
102232: LD_VAR 0 7
102236: PPUSH
102237: CALL_OW 111
// result := [ _x , _y ] ;
102241: LD_ADDR_VAR 0 3
102245: PUSH
102246: LD_VAR 0 5
102250: PUSH
102251: LD_VAR 0 7
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: ST_TO_ADDR
// exit ;
102260: POP
102261: POP
102262: GO 102268
// end ; end ;
102264: GO 102108
102266: POP
102267: POP
// end ;
102268: LD_VAR 0 3
102272: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
102273: LD_INT 0
102275: PPUSH
102276: PPUSH
102277: PPUSH
// result := 0 ;
102278: LD_ADDR_VAR 0 3
102282: PUSH
102283: LD_INT 0
102285: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
102286: LD_VAR 0 1
102290: PUSH
102291: LD_INT 0
102293: LESS
102294: PUSH
102295: LD_VAR 0 1
102299: PUSH
102300: LD_INT 8
102302: GREATER
102303: OR
102304: PUSH
102305: LD_VAR 0 2
102309: PUSH
102310: LD_INT 0
102312: LESS
102313: OR
102314: PUSH
102315: LD_VAR 0 2
102319: PUSH
102320: LD_INT 8
102322: GREATER
102323: OR
102324: IFFALSE 102328
// exit ;
102326: GO 102403
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102328: LD_ADDR_VAR 0 4
102332: PUSH
102333: LD_INT 22
102335: PUSH
102336: LD_VAR 0 2
102340: PUSH
102341: EMPTY
102342: LIST
102343: LIST
102344: PPUSH
102345: CALL_OW 69
102349: PUSH
102350: FOR_IN
102351: IFFALSE 102401
// begin un := UnitShoot ( i ) ;
102353: LD_ADDR_VAR 0 5
102357: PUSH
102358: LD_VAR 0 4
102362: PPUSH
102363: CALL_OW 504
102367: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102368: LD_VAR 0 5
102372: PPUSH
102373: CALL_OW 255
102377: PUSH
102378: LD_VAR 0 1
102382: EQUAL
102383: IFFALSE 102399
// begin result := un ;
102385: LD_ADDR_VAR 0 3
102389: PUSH
102390: LD_VAR 0 5
102394: ST_TO_ADDR
// exit ;
102395: POP
102396: POP
102397: GO 102403
// end ; end ;
102399: GO 102350
102401: POP
102402: POP
// end ; end_of_file end_of_file
102403: LD_VAR 0 3
102407: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
102408: LD_VAR 0 2
102412: PUSH
102413: LD_INT 100
102415: EQUAL
102416: IFFALSE 103365
// begin if not StreamModeActive then
102418: LD_EXP 156
102422: NOT
102423: IFFALSE 102433
// StreamModeActive := true ;
102425: LD_ADDR_EXP 156
102429: PUSH
102430: LD_INT 1
102432: ST_TO_ADDR
// if p3 = 0 then
102433: LD_VAR 0 3
102437: PUSH
102438: LD_INT 0
102440: EQUAL
102441: IFFALSE 102447
// InitStreamMode ;
102443: CALL 103523 0 0
// if p3 = 1 then
102447: LD_VAR 0 3
102451: PUSH
102452: LD_INT 1
102454: EQUAL
102455: IFFALSE 102465
// sRocket := true ;
102457: LD_ADDR_EXP 161
102461: PUSH
102462: LD_INT 1
102464: ST_TO_ADDR
// if p3 = 2 then
102465: LD_VAR 0 3
102469: PUSH
102470: LD_INT 2
102472: EQUAL
102473: IFFALSE 102483
// sSpeed := true ;
102475: LD_ADDR_EXP 160
102479: PUSH
102480: LD_INT 1
102482: ST_TO_ADDR
// if p3 = 3 then
102483: LD_VAR 0 3
102487: PUSH
102488: LD_INT 3
102490: EQUAL
102491: IFFALSE 102501
// sEngine := true ;
102493: LD_ADDR_EXP 162
102497: PUSH
102498: LD_INT 1
102500: ST_TO_ADDR
// if p3 = 4 then
102501: LD_VAR 0 3
102505: PUSH
102506: LD_INT 4
102508: EQUAL
102509: IFFALSE 102519
// sSpec := true ;
102511: LD_ADDR_EXP 159
102515: PUSH
102516: LD_INT 1
102518: ST_TO_ADDR
// if p3 = 5 then
102519: LD_VAR 0 3
102523: PUSH
102524: LD_INT 5
102526: EQUAL
102527: IFFALSE 102537
// sLevel := true ;
102529: LD_ADDR_EXP 163
102533: PUSH
102534: LD_INT 1
102536: ST_TO_ADDR
// if p3 = 6 then
102537: LD_VAR 0 3
102541: PUSH
102542: LD_INT 6
102544: EQUAL
102545: IFFALSE 102555
// sArmoury := true ;
102547: LD_ADDR_EXP 164
102551: PUSH
102552: LD_INT 1
102554: ST_TO_ADDR
// if p3 = 7 then
102555: LD_VAR 0 3
102559: PUSH
102560: LD_INT 7
102562: EQUAL
102563: IFFALSE 102573
// sRadar := true ;
102565: LD_ADDR_EXP 165
102569: PUSH
102570: LD_INT 1
102572: ST_TO_ADDR
// if p3 = 8 then
102573: LD_VAR 0 3
102577: PUSH
102578: LD_INT 8
102580: EQUAL
102581: IFFALSE 102591
// sBunker := true ;
102583: LD_ADDR_EXP 166
102587: PUSH
102588: LD_INT 1
102590: ST_TO_ADDR
// if p3 = 9 then
102591: LD_VAR 0 3
102595: PUSH
102596: LD_INT 9
102598: EQUAL
102599: IFFALSE 102609
// sHack := true ;
102601: LD_ADDR_EXP 167
102605: PUSH
102606: LD_INT 1
102608: ST_TO_ADDR
// if p3 = 10 then
102609: LD_VAR 0 3
102613: PUSH
102614: LD_INT 10
102616: EQUAL
102617: IFFALSE 102627
// sFire := true ;
102619: LD_ADDR_EXP 168
102623: PUSH
102624: LD_INT 1
102626: ST_TO_ADDR
// if p3 = 11 then
102627: LD_VAR 0 3
102631: PUSH
102632: LD_INT 11
102634: EQUAL
102635: IFFALSE 102645
// sRefresh := true ;
102637: LD_ADDR_EXP 169
102641: PUSH
102642: LD_INT 1
102644: ST_TO_ADDR
// if p3 = 12 then
102645: LD_VAR 0 3
102649: PUSH
102650: LD_INT 12
102652: EQUAL
102653: IFFALSE 102663
// sExp := true ;
102655: LD_ADDR_EXP 170
102659: PUSH
102660: LD_INT 1
102662: ST_TO_ADDR
// if p3 = 13 then
102663: LD_VAR 0 3
102667: PUSH
102668: LD_INT 13
102670: EQUAL
102671: IFFALSE 102681
// sDepot := true ;
102673: LD_ADDR_EXP 171
102677: PUSH
102678: LD_INT 1
102680: ST_TO_ADDR
// if p3 = 14 then
102681: LD_VAR 0 3
102685: PUSH
102686: LD_INT 14
102688: EQUAL
102689: IFFALSE 102699
// sFlag := true ;
102691: LD_ADDR_EXP 172
102695: PUSH
102696: LD_INT 1
102698: ST_TO_ADDR
// if p3 = 15 then
102699: LD_VAR 0 3
102703: PUSH
102704: LD_INT 15
102706: EQUAL
102707: IFFALSE 102717
// sKamikadze := true ;
102709: LD_ADDR_EXP 180
102713: PUSH
102714: LD_INT 1
102716: ST_TO_ADDR
// if p3 = 16 then
102717: LD_VAR 0 3
102721: PUSH
102722: LD_INT 16
102724: EQUAL
102725: IFFALSE 102735
// sTroll := true ;
102727: LD_ADDR_EXP 181
102731: PUSH
102732: LD_INT 1
102734: ST_TO_ADDR
// if p3 = 17 then
102735: LD_VAR 0 3
102739: PUSH
102740: LD_INT 17
102742: EQUAL
102743: IFFALSE 102753
// sSlow := true ;
102745: LD_ADDR_EXP 182
102749: PUSH
102750: LD_INT 1
102752: ST_TO_ADDR
// if p3 = 18 then
102753: LD_VAR 0 3
102757: PUSH
102758: LD_INT 18
102760: EQUAL
102761: IFFALSE 102771
// sLack := true ;
102763: LD_ADDR_EXP 183
102767: PUSH
102768: LD_INT 1
102770: ST_TO_ADDR
// if p3 = 19 then
102771: LD_VAR 0 3
102775: PUSH
102776: LD_INT 19
102778: EQUAL
102779: IFFALSE 102789
// sTank := true ;
102781: LD_ADDR_EXP 185
102785: PUSH
102786: LD_INT 1
102788: ST_TO_ADDR
// if p3 = 20 then
102789: LD_VAR 0 3
102793: PUSH
102794: LD_INT 20
102796: EQUAL
102797: IFFALSE 102807
// sRemote := true ;
102799: LD_ADDR_EXP 186
102803: PUSH
102804: LD_INT 1
102806: ST_TO_ADDR
// if p3 = 21 then
102807: LD_VAR 0 3
102811: PUSH
102812: LD_INT 21
102814: EQUAL
102815: IFFALSE 102825
// sPowell := true ;
102817: LD_ADDR_EXP 187
102821: PUSH
102822: LD_INT 1
102824: ST_TO_ADDR
// if p3 = 22 then
102825: LD_VAR 0 3
102829: PUSH
102830: LD_INT 22
102832: EQUAL
102833: IFFALSE 102843
// sTeleport := true ;
102835: LD_ADDR_EXP 190
102839: PUSH
102840: LD_INT 1
102842: ST_TO_ADDR
// if p3 = 23 then
102843: LD_VAR 0 3
102847: PUSH
102848: LD_INT 23
102850: EQUAL
102851: IFFALSE 102861
// sOilTower := true ;
102853: LD_ADDR_EXP 192
102857: PUSH
102858: LD_INT 1
102860: ST_TO_ADDR
// if p3 = 24 then
102861: LD_VAR 0 3
102865: PUSH
102866: LD_INT 24
102868: EQUAL
102869: IFFALSE 102879
// sShovel := true ;
102871: LD_ADDR_EXP 193
102875: PUSH
102876: LD_INT 1
102878: ST_TO_ADDR
// if p3 = 25 then
102879: LD_VAR 0 3
102883: PUSH
102884: LD_INT 25
102886: EQUAL
102887: IFFALSE 102897
// sSheik := true ;
102889: LD_ADDR_EXP 194
102893: PUSH
102894: LD_INT 1
102896: ST_TO_ADDR
// if p3 = 26 then
102897: LD_VAR 0 3
102901: PUSH
102902: LD_INT 26
102904: EQUAL
102905: IFFALSE 102915
// sEarthquake := true ;
102907: LD_ADDR_EXP 196
102911: PUSH
102912: LD_INT 1
102914: ST_TO_ADDR
// if p3 = 27 then
102915: LD_VAR 0 3
102919: PUSH
102920: LD_INT 27
102922: EQUAL
102923: IFFALSE 102933
// sAI := true ;
102925: LD_ADDR_EXP 197
102929: PUSH
102930: LD_INT 1
102932: ST_TO_ADDR
// if p3 = 28 then
102933: LD_VAR 0 3
102937: PUSH
102938: LD_INT 28
102940: EQUAL
102941: IFFALSE 102951
// sCargo := true ;
102943: LD_ADDR_EXP 200
102947: PUSH
102948: LD_INT 1
102950: ST_TO_ADDR
// if p3 = 29 then
102951: LD_VAR 0 3
102955: PUSH
102956: LD_INT 29
102958: EQUAL
102959: IFFALSE 102969
// sDLaser := true ;
102961: LD_ADDR_EXP 201
102965: PUSH
102966: LD_INT 1
102968: ST_TO_ADDR
// if p3 = 30 then
102969: LD_VAR 0 3
102973: PUSH
102974: LD_INT 30
102976: EQUAL
102977: IFFALSE 102987
// sExchange := true ;
102979: LD_ADDR_EXP 202
102983: PUSH
102984: LD_INT 1
102986: ST_TO_ADDR
// if p3 = 31 then
102987: LD_VAR 0 3
102991: PUSH
102992: LD_INT 31
102994: EQUAL
102995: IFFALSE 103005
// sFac := true ;
102997: LD_ADDR_EXP 203
103001: PUSH
103002: LD_INT 1
103004: ST_TO_ADDR
// if p3 = 32 then
103005: LD_VAR 0 3
103009: PUSH
103010: LD_INT 32
103012: EQUAL
103013: IFFALSE 103023
// sPower := true ;
103015: LD_ADDR_EXP 204
103019: PUSH
103020: LD_INT 1
103022: ST_TO_ADDR
// if p3 = 33 then
103023: LD_VAR 0 3
103027: PUSH
103028: LD_INT 33
103030: EQUAL
103031: IFFALSE 103041
// sRandom := true ;
103033: LD_ADDR_EXP 205
103037: PUSH
103038: LD_INT 1
103040: ST_TO_ADDR
// if p3 = 34 then
103041: LD_VAR 0 3
103045: PUSH
103046: LD_INT 34
103048: EQUAL
103049: IFFALSE 103059
// sShield := true ;
103051: LD_ADDR_EXP 206
103055: PUSH
103056: LD_INT 1
103058: ST_TO_ADDR
// if p3 = 35 then
103059: LD_VAR 0 3
103063: PUSH
103064: LD_INT 35
103066: EQUAL
103067: IFFALSE 103077
// sTime := true ;
103069: LD_ADDR_EXP 207
103073: PUSH
103074: LD_INT 1
103076: ST_TO_ADDR
// if p3 = 36 then
103077: LD_VAR 0 3
103081: PUSH
103082: LD_INT 36
103084: EQUAL
103085: IFFALSE 103095
// sTools := true ;
103087: LD_ADDR_EXP 208
103091: PUSH
103092: LD_INT 1
103094: ST_TO_ADDR
// if p3 = 101 then
103095: LD_VAR 0 3
103099: PUSH
103100: LD_INT 101
103102: EQUAL
103103: IFFALSE 103113
// sSold := true ;
103105: LD_ADDR_EXP 173
103109: PUSH
103110: LD_INT 1
103112: ST_TO_ADDR
// if p3 = 102 then
103113: LD_VAR 0 3
103117: PUSH
103118: LD_INT 102
103120: EQUAL
103121: IFFALSE 103131
// sDiff := true ;
103123: LD_ADDR_EXP 174
103127: PUSH
103128: LD_INT 1
103130: ST_TO_ADDR
// if p3 = 103 then
103131: LD_VAR 0 3
103135: PUSH
103136: LD_INT 103
103138: EQUAL
103139: IFFALSE 103149
// sFog := true ;
103141: LD_ADDR_EXP 177
103145: PUSH
103146: LD_INT 1
103148: ST_TO_ADDR
// if p3 = 104 then
103149: LD_VAR 0 3
103153: PUSH
103154: LD_INT 104
103156: EQUAL
103157: IFFALSE 103167
// sReset := true ;
103159: LD_ADDR_EXP 178
103163: PUSH
103164: LD_INT 1
103166: ST_TO_ADDR
// if p3 = 105 then
103167: LD_VAR 0 3
103171: PUSH
103172: LD_INT 105
103174: EQUAL
103175: IFFALSE 103185
// sSun := true ;
103177: LD_ADDR_EXP 179
103181: PUSH
103182: LD_INT 1
103184: ST_TO_ADDR
// if p3 = 106 then
103185: LD_VAR 0 3
103189: PUSH
103190: LD_INT 106
103192: EQUAL
103193: IFFALSE 103203
// sTiger := true ;
103195: LD_ADDR_EXP 175
103199: PUSH
103200: LD_INT 1
103202: ST_TO_ADDR
// if p3 = 107 then
103203: LD_VAR 0 3
103207: PUSH
103208: LD_INT 107
103210: EQUAL
103211: IFFALSE 103221
// sBomb := true ;
103213: LD_ADDR_EXP 176
103217: PUSH
103218: LD_INT 1
103220: ST_TO_ADDR
// if p3 = 108 then
103221: LD_VAR 0 3
103225: PUSH
103226: LD_INT 108
103228: EQUAL
103229: IFFALSE 103239
// sWound := true ;
103231: LD_ADDR_EXP 184
103235: PUSH
103236: LD_INT 1
103238: ST_TO_ADDR
// if p3 = 109 then
103239: LD_VAR 0 3
103243: PUSH
103244: LD_INT 109
103246: EQUAL
103247: IFFALSE 103257
// sBetray := true ;
103249: LD_ADDR_EXP 188
103253: PUSH
103254: LD_INT 1
103256: ST_TO_ADDR
// if p3 = 110 then
103257: LD_VAR 0 3
103261: PUSH
103262: LD_INT 110
103264: EQUAL
103265: IFFALSE 103275
// sContamin := true ;
103267: LD_ADDR_EXP 189
103271: PUSH
103272: LD_INT 1
103274: ST_TO_ADDR
// if p3 = 111 then
103275: LD_VAR 0 3
103279: PUSH
103280: LD_INT 111
103282: EQUAL
103283: IFFALSE 103293
// sOil := true ;
103285: LD_ADDR_EXP 191
103289: PUSH
103290: LD_INT 1
103292: ST_TO_ADDR
// if p3 = 112 then
103293: LD_VAR 0 3
103297: PUSH
103298: LD_INT 112
103300: EQUAL
103301: IFFALSE 103311
// sStu := true ;
103303: LD_ADDR_EXP 195
103307: PUSH
103308: LD_INT 1
103310: ST_TO_ADDR
// if p3 = 113 then
103311: LD_VAR 0 3
103315: PUSH
103316: LD_INT 113
103318: EQUAL
103319: IFFALSE 103329
// sBazooka := true ;
103321: LD_ADDR_EXP 198
103325: PUSH
103326: LD_INT 1
103328: ST_TO_ADDR
// if p3 = 114 then
103329: LD_VAR 0 3
103333: PUSH
103334: LD_INT 114
103336: EQUAL
103337: IFFALSE 103347
// sMortar := true ;
103339: LD_ADDR_EXP 199
103343: PUSH
103344: LD_INT 1
103346: ST_TO_ADDR
// if p3 = 115 then
103347: LD_VAR 0 3
103351: PUSH
103352: LD_INT 115
103354: EQUAL
103355: IFFALSE 103365
// sRanger := true ;
103357: LD_ADDR_EXP 209
103361: PUSH
103362: LD_INT 1
103364: ST_TO_ADDR
// end ; if p2 = 101 then
103365: LD_VAR 0 2
103369: PUSH
103370: LD_INT 101
103372: EQUAL
103373: IFFALSE 103501
// begin case p3 of 1 :
103375: LD_VAR 0 3
103379: PUSH
103380: LD_INT 1
103382: DOUBLE
103383: EQUAL
103384: IFTRUE 103388
103386: GO 103395
103388: POP
// hHackUnlimitedResources ; 2 :
103389: CALL 114536 0 0
103393: GO 103501
103395: LD_INT 2
103397: DOUBLE
103398: EQUAL
103399: IFTRUE 103403
103401: GO 103410
103403: POP
// hHackSetLevel10 ; 3 :
103404: CALL 114669 0 0
103408: GO 103501
103410: LD_INT 3
103412: DOUBLE
103413: EQUAL
103414: IFTRUE 103418
103416: GO 103425
103418: POP
// hHackSetLevel10YourUnits ; 4 :
103419: CALL 114754 0 0
103423: GO 103501
103425: LD_INT 4
103427: DOUBLE
103428: EQUAL
103429: IFTRUE 103433
103431: GO 103440
103433: POP
// hHackInvincible ; 5 :
103434: CALL 115202 0 0
103438: GO 103501
103440: LD_INT 5
103442: DOUBLE
103443: EQUAL
103444: IFTRUE 103448
103446: GO 103455
103448: POP
// hHackInvisible ; 6 :
103449: CALL 115313 0 0
103453: GO 103501
103455: LD_INT 6
103457: DOUBLE
103458: EQUAL
103459: IFTRUE 103463
103461: GO 103470
103463: POP
// hHackChangeYourSide ; 7 :
103464: CALL 115370 0 0
103468: GO 103501
103470: LD_INT 7
103472: DOUBLE
103473: EQUAL
103474: IFTRUE 103478
103476: GO 103485
103478: POP
// hHackChangeUnitSide ; 8 :
103479: CALL 115412 0 0
103483: GO 103501
103485: LD_INT 8
103487: DOUBLE
103488: EQUAL
103489: IFTRUE 103493
103491: GO 103500
103493: POP
// hHackFog ; end ;
103494: CALL 115513 0 0
103498: GO 103501
103500: POP
// end ; end ;
103501: PPOPN 6
103503: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
103504: GO 103506
103506: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
103507: LD_STRING initStreamRollete();
103509: PPUSH
103510: CALL_OW 559
// InitStreamMode ;
103514: CALL 103523 0 0
// DefineStreamItems ( ) ;
103518: CALL 103963 0 0
// end ;
103522: END
// function InitStreamMode ; begin
103523: LD_INT 0
103525: PPUSH
// streamModeActive := false ;
103526: LD_ADDR_EXP 156
103530: PUSH
103531: LD_INT 0
103533: ST_TO_ADDR
// normalCounter := 36 ;
103534: LD_ADDR_EXP 157
103538: PUSH
103539: LD_INT 36
103541: ST_TO_ADDR
// hardcoreCounter := 16 ;
103542: LD_ADDR_EXP 158
103546: PUSH
103547: LD_INT 16
103549: ST_TO_ADDR
// sRocket := false ;
103550: LD_ADDR_EXP 161
103554: PUSH
103555: LD_INT 0
103557: ST_TO_ADDR
// sSpeed := false ;
103558: LD_ADDR_EXP 160
103562: PUSH
103563: LD_INT 0
103565: ST_TO_ADDR
// sEngine := false ;
103566: LD_ADDR_EXP 162
103570: PUSH
103571: LD_INT 0
103573: ST_TO_ADDR
// sSpec := false ;
103574: LD_ADDR_EXP 159
103578: PUSH
103579: LD_INT 0
103581: ST_TO_ADDR
// sLevel := false ;
103582: LD_ADDR_EXP 163
103586: PUSH
103587: LD_INT 0
103589: ST_TO_ADDR
// sArmoury := false ;
103590: LD_ADDR_EXP 164
103594: PUSH
103595: LD_INT 0
103597: ST_TO_ADDR
// sRadar := false ;
103598: LD_ADDR_EXP 165
103602: PUSH
103603: LD_INT 0
103605: ST_TO_ADDR
// sBunker := false ;
103606: LD_ADDR_EXP 166
103610: PUSH
103611: LD_INT 0
103613: ST_TO_ADDR
// sHack := false ;
103614: LD_ADDR_EXP 167
103618: PUSH
103619: LD_INT 0
103621: ST_TO_ADDR
// sFire := false ;
103622: LD_ADDR_EXP 168
103626: PUSH
103627: LD_INT 0
103629: ST_TO_ADDR
// sRefresh := false ;
103630: LD_ADDR_EXP 169
103634: PUSH
103635: LD_INT 0
103637: ST_TO_ADDR
// sExp := false ;
103638: LD_ADDR_EXP 170
103642: PUSH
103643: LD_INT 0
103645: ST_TO_ADDR
// sDepot := false ;
103646: LD_ADDR_EXP 171
103650: PUSH
103651: LD_INT 0
103653: ST_TO_ADDR
// sFlag := false ;
103654: LD_ADDR_EXP 172
103658: PUSH
103659: LD_INT 0
103661: ST_TO_ADDR
// sKamikadze := false ;
103662: LD_ADDR_EXP 180
103666: PUSH
103667: LD_INT 0
103669: ST_TO_ADDR
// sTroll := false ;
103670: LD_ADDR_EXP 181
103674: PUSH
103675: LD_INT 0
103677: ST_TO_ADDR
// sSlow := false ;
103678: LD_ADDR_EXP 182
103682: PUSH
103683: LD_INT 0
103685: ST_TO_ADDR
// sLack := false ;
103686: LD_ADDR_EXP 183
103690: PUSH
103691: LD_INT 0
103693: ST_TO_ADDR
// sTank := false ;
103694: LD_ADDR_EXP 185
103698: PUSH
103699: LD_INT 0
103701: ST_TO_ADDR
// sRemote := false ;
103702: LD_ADDR_EXP 186
103706: PUSH
103707: LD_INT 0
103709: ST_TO_ADDR
// sPowell := false ;
103710: LD_ADDR_EXP 187
103714: PUSH
103715: LD_INT 0
103717: ST_TO_ADDR
// sTeleport := false ;
103718: LD_ADDR_EXP 190
103722: PUSH
103723: LD_INT 0
103725: ST_TO_ADDR
// sOilTower := false ;
103726: LD_ADDR_EXP 192
103730: PUSH
103731: LD_INT 0
103733: ST_TO_ADDR
// sShovel := false ;
103734: LD_ADDR_EXP 193
103738: PUSH
103739: LD_INT 0
103741: ST_TO_ADDR
// sSheik := false ;
103742: LD_ADDR_EXP 194
103746: PUSH
103747: LD_INT 0
103749: ST_TO_ADDR
// sEarthquake := false ;
103750: LD_ADDR_EXP 196
103754: PUSH
103755: LD_INT 0
103757: ST_TO_ADDR
// sAI := false ;
103758: LD_ADDR_EXP 197
103762: PUSH
103763: LD_INT 0
103765: ST_TO_ADDR
// sCargo := false ;
103766: LD_ADDR_EXP 200
103770: PUSH
103771: LD_INT 0
103773: ST_TO_ADDR
// sDLaser := false ;
103774: LD_ADDR_EXP 201
103778: PUSH
103779: LD_INT 0
103781: ST_TO_ADDR
// sExchange := false ;
103782: LD_ADDR_EXP 202
103786: PUSH
103787: LD_INT 0
103789: ST_TO_ADDR
// sFac := false ;
103790: LD_ADDR_EXP 203
103794: PUSH
103795: LD_INT 0
103797: ST_TO_ADDR
// sPower := false ;
103798: LD_ADDR_EXP 204
103802: PUSH
103803: LD_INT 0
103805: ST_TO_ADDR
// sRandom := false ;
103806: LD_ADDR_EXP 205
103810: PUSH
103811: LD_INT 0
103813: ST_TO_ADDR
// sShield := false ;
103814: LD_ADDR_EXP 206
103818: PUSH
103819: LD_INT 0
103821: ST_TO_ADDR
// sTime := false ;
103822: LD_ADDR_EXP 207
103826: PUSH
103827: LD_INT 0
103829: ST_TO_ADDR
// sTools := false ;
103830: LD_ADDR_EXP 208
103834: PUSH
103835: LD_INT 0
103837: ST_TO_ADDR
// sSold := false ;
103838: LD_ADDR_EXP 173
103842: PUSH
103843: LD_INT 0
103845: ST_TO_ADDR
// sDiff := false ;
103846: LD_ADDR_EXP 174
103850: PUSH
103851: LD_INT 0
103853: ST_TO_ADDR
// sFog := false ;
103854: LD_ADDR_EXP 177
103858: PUSH
103859: LD_INT 0
103861: ST_TO_ADDR
// sReset := false ;
103862: LD_ADDR_EXP 178
103866: PUSH
103867: LD_INT 0
103869: ST_TO_ADDR
// sSun := false ;
103870: LD_ADDR_EXP 179
103874: PUSH
103875: LD_INT 0
103877: ST_TO_ADDR
// sTiger := false ;
103878: LD_ADDR_EXP 175
103882: PUSH
103883: LD_INT 0
103885: ST_TO_ADDR
// sBomb := false ;
103886: LD_ADDR_EXP 176
103890: PUSH
103891: LD_INT 0
103893: ST_TO_ADDR
// sWound := false ;
103894: LD_ADDR_EXP 184
103898: PUSH
103899: LD_INT 0
103901: ST_TO_ADDR
// sBetray := false ;
103902: LD_ADDR_EXP 188
103906: PUSH
103907: LD_INT 0
103909: ST_TO_ADDR
// sContamin := false ;
103910: LD_ADDR_EXP 189
103914: PUSH
103915: LD_INT 0
103917: ST_TO_ADDR
// sOil := false ;
103918: LD_ADDR_EXP 191
103922: PUSH
103923: LD_INT 0
103925: ST_TO_ADDR
// sStu := false ;
103926: LD_ADDR_EXP 195
103930: PUSH
103931: LD_INT 0
103933: ST_TO_ADDR
// sBazooka := false ;
103934: LD_ADDR_EXP 198
103938: PUSH
103939: LD_INT 0
103941: ST_TO_ADDR
// sMortar := false ;
103942: LD_ADDR_EXP 199
103946: PUSH
103947: LD_INT 0
103949: ST_TO_ADDR
// sRanger := false ;
103950: LD_ADDR_EXP 209
103954: PUSH
103955: LD_INT 0
103957: ST_TO_ADDR
// end ;
103958: LD_VAR 0 1
103962: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103963: LD_INT 0
103965: PPUSH
103966: PPUSH
103967: PPUSH
103968: PPUSH
103969: PPUSH
// result := [ ] ;
103970: LD_ADDR_VAR 0 1
103974: PUSH
103975: EMPTY
103976: ST_TO_ADDR
// if campaign_id = 1 then
103977: LD_OWVAR 69
103981: PUSH
103982: LD_INT 1
103984: EQUAL
103985: IFFALSE 106923
// begin case mission_number of 1 :
103987: LD_OWVAR 70
103991: PUSH
103992: LD_INT 1
103994: DOUBLE
103995: EQUAL
103996: IFTRUE 104000
103998: GO 104064
104000: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
104001: LD_ADDR_VAR 0 1
104005: PUSH
104006: LD_INT 2
104008: PUSH
104009: LD_INT 4
104011: PUSH
104012: LD_INT 11
104014: PUSH
104015: LD_INT 12
104017: PUSH
104018: LD_INT 15
104020: PUSH
104021: LD_INT 16
104023: PUSH
104024: LD_INT 22
104026: PUSH
104027: LD_INT 23
104029: PUSH
104030: LD_INT 26
104032: PUSH
104033: EMPTY
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: LIST
104039: LIST
104040: LIST
104041: LIST
104042: LIST
104043: PUSH
104044: LD_INT 101
104046: PUSH
104047: LD_INT 102
104049: PUSH
104050: LD_INT 106
104052: PUSH
104053: EMPTY
104054: LIST
104055: LIST
104056: LIST
104057: PUSH
104058: EMPTY
104059: LIST
104060: LIST
104061: ST_TO_ADDR
104062: GO 106921
104064: LD_INT 2
104066: DOUBLE
104067: EQUAL
104068: IFTRUE 104072
104070: GO 104144
104072: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
104073: LD_ADDR_VAR 0 1
104077: PUSH
104078: LD_INT 2
104080: PUSH
104081: LD_INT 4
104083: PUSH
104084: LD_INT 11
104086: PUSH
104087: LD_INT 12
104089: PUSH
104090: LD_INT 15
104092: PUSH
104093: LD_INT 16
104095: PUSH
104096: LD_INT 22
104098: PUSH
104099: LD_INT 23
104101: PUSH
104102: LD_INT 26
104104: PUSH
104105: EMPTY
104106: LIST
104107: LIST
104108: LIST
104109: LIST
104110: LIST
104111: LIST
104112: LIST
104113: LIST
104114: LIST
104115: PUSH
104116: LD_INT 101
104118: PUSH
104119: LD_INT 102
104121: PUSH
104122: LD_INT 105
104124: PUSH
104125: LD_INT 106
104127: PUSH
104128: LD_INT 108
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: LIST
104135: LIST
104136: LIST
104137: PUSH
104138: EMPTY
104139: LIST
104140: LIST
104141: ST_TO_ADDR
104142: GO 106921
104144: LD_INT 3
104146: DOUBLE
104147: EQUAL
104148: IFTRUE 104152
104150: GO 104228
104152: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
104153: LD_ADDR_VAR 0 1
104157: PUSH
104158: LD_INT 2
104160: PUSH
104161: LD_INT 4
104163: PUSH
104164: LD_INT 5
104166: PUSH
104167: LD_INT 11
104169: PUSH
104170: LD_INT 12
104172: PUSH
104173: LD_INT 15
104175: PUSH
104176: LD_INT 16
104178: PUSH
104179: LD_INT 22
104181: PUSH
104182: LD_INT 26
104184: PUSH
104185: LD_INT 36
104187: PUSH
104188: EMPTY
104189: LIST
104190: LIST
104191: LIST
104192: LIST
104193: LIST
104194: LIST
104195: LIST
104196: LIST
104197: LIST
104198: LIST
104199: PUSH
104200: LD_INT 101
104202: PUSH
104203: LD_INT 102
104205: PUSH
104206: LD_INT 105
104208: PUSH
104209: LD_INT 106
104211: PUSH
104212: LD_INT 108
104214: PUSH
104215: EMPTY
104216: LIST
104217: LIST
104218: LIST
104219: LIST
104220: LIST
104221: PUSH
104222: EMPTY
104223: LIST
104224: LIST
104225: ST_TO_ADDR
104226: GO 106921
104228: LD_INT 4
104230: DOUBLE
104231: EQUAL
104232: IFTRUE 104236
104234: GO 104320
104236: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
104237: LD_ADDR_VAR 0 1
104241: PUSH
104242: LD_INT 2
104244: PUSH
104245: LD_INT 4
104247: PUSH
104248: LD_INT 5
104250: PUSH
104251: LD_INT 8
104253: PUSH
104254: LD_INT 11
104256: PUSH
104257: LD_INT 12
104259: PUSH
104260: LD_INT 15
104262: PUSH
104263: LD_INT 16
104265: PUSH
104266: LD_INT 22
104268: PUSH
104269: LD_INT 23
104271: PUSH
104272: LD_INT 26
104274: PUSH
104275: LD_INT 36
104277: PUSH
104278: EMPTY
104279: LIST
104280: LIST
104281: LIST
104282: LIST
104283: LIST
104284: LIST
104285: LIST
104286: LIST
104287: LIST
104288: LIST
104289: LIST
104290: LIST
104291: PUSH
104292: LD_INT 101
104294: PUSH
104295: LD_INT 102
104297: PUSH
104298: LD_INT 105
104300: PUSH
104301: LD_INT 106
104303: PUSH
104304: LD_INT 108
104306: PUSH
104307: EMPTY
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: LIST
104313: PUSH
104314: EMPTY
104315: LIST
104316: LIST
104317: ST_TO_ADDR
104318: GO 106921
104320: LD_INT 5
104322: DOUBLE
104323: EQUAL
104324: IFTRUE 104328
104326: GO 104428
104328: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
104329: LD_ADDR_VAR 0 1
104333: PUSH
104334: LD_INT 2
104336: PUSH
104337: LD_INT 4
104339: PUSH
104340: LD_INT 5
104342: PUSH
104343: LD_INT 6
104345: PUSH
104346: LD_INT 8
104348: PUSH
104349: LD_INT 11
104351: PUSH
104352: LD_INT 12
104354: PUSH
104355: LD_INT 15
104357: PUSH
104358: LD_INT 16
104360: PUSH
104361: LD_INT 22
104363: PUSH
104364: LD_INT 23
104366: PUSH
104367: LD_INT 25
104369: PUSH
104370: LD_INT 26
104372: PUSH
104373: LD_INT 36
104375: PUSH
104376: EMPTY
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: PUSH
104392: LD_INT 101
104394: PUSH
104395: LD_INT 102
104397: PUSH
104398: LD_INT 105
104400: PUSH
104401: LD_INT 106
104403: PUSH
104404: LD_INT 108
104406: PUSH
104407: LD_INT 109
104409: PUSH
104410: LD_INT 112
104412: PUSH
104413: EMPTY
104414: LIST
104415: LIST
104416: LIST
104417: LIST
104418: LIST
104419: LIST
104420: LIST
104421: PUSH
104422: EMPTY
104423: LIST
104424: LIST
104425: ST_TO_ADDR
104426: GO 106921
104428: LD_INT 6
104430: DOUBLE
104431: EQUAL
104432: IFTRUE 104436
104434: GO 104556
104436: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
104437: LD_ADDR_VAR 0 1
104441: PUSH
104442: LD_INT 2
104444: PUSH
104445: LD_INT 4
104447: PUSH
104448: LD_INT 5
104450: PUSH
104451: LD_INT 6
104453: PUSH
104454: LD_INT 8
104456: PUSH
104457: LD_INT 11
104459: PUSH
104460: LD_INT 12
104462: PUSH
104463: LD_INT 15
104465: PUSH
104466: LD_INT 16
104468: PUSH
104469: LD_INT 20
104471: PUSH
104472: LD_INT 21
104474: PUSH
104475: LD_INT 22
104477: PUSH
104478: LD_INT 23
104480: PUSH
104481: LD_INT 25
104483: PUSH
104484: LD_INT 26
104486: PUSH
104487: LD_INT 30
104489: PUSH
104490: LD_INT 31
104492: PUSH
104493: LD_INT 32
104495: PUSH
104496: LD_INT 36
104498: PUSH
104499: EMPTY
104500: LIST
104501: LIST
104502: LIST
104503: LIST
104504: LIST
104505: LIST
104506: LIST
104507: LIST
104508: LIST
104509: LIST
104510: LIST
104511: LIST
104512: LIST
104513: LIST
104514: LIST
104515: LIST
104516: LIST
104517: LIST
104518: LIST
104519: PUSH
104520: LD_INT 101
104522: PUSH
104523: LD_INT 102
104525: PUSH
104526: LD_INT 105
104528: PUSH
104529: LD_INT 106
104531: PUSH
104532: LD_INT 108
104534: PUSH
104535: LD_INT 109
104537: PUSH
104538: LD_INT 112
104540: PUSH
104541: EMPTY
104542: LIST
104543: LIST
104544: LIST
104545: LIST
104546: LIST
104547: LIST
104548: LIST
104549: PUSH
104550: EMPTY
104551: LIST
104552: LIST
104553: ST_TO_ADDR
104554: GO 106921
104556: LD_INT 7
104558: DOUBLE
104559: EQUAL
104560: IFTRUE 104564
104562: GO 104664
104564: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
104565: LD_ADDR_VAR 0 1
104569: PUSH
104570: LD_INT 2
104572: PUSH
104573: LD_INT 4
104575: PUSH
104576: LD_INT 5
104578: PUSH
104579: LD_INT 7
104581: PUSH
104582: LD_INT 11
104584: PUSH
104585: LD_INT 12
104587: PUSH
104588: LD_INT 15
104590: PUSH
104591: LD_INT 16
104593: PUSH
104594: LD_INT 20
104596: PUSH
104597: LD_INT 21
104599: PUSH
104600: LD_INT 22
104602: PUSH
104603: LD_INT 23
104605: PUSH
104606: LD_INT 25
104608: PUSH
104609: LD_INT 26
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: LIST
104616: LIST
104617: LIST
104618: LIST
104619: LIST
104620: LIST
104621: LIST
104622: LIST
104623: LIST
104624: LIST
104625: LIST
104626: LIST
104627: PUSH
104628: LD_INT 101
104630: PUSH
104631: LD_INT 102
104633: PUSH
104634: LD_INT 103
104636: PUSH
104637: LD_INT 105
104639: PUSH
104640: LD_INT 106
104642: PUSH
104643: LD_INT 108
104645: PUSH
104646: LD_INT 112
104648: PUSH
104649: EMPTY
104650: LIST
104651: LIST
104652: LIST
104653: LIST
104654: LIST
104655: LIST
104656: LIST
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: ST_TO_ADDR
104662: GO 106921
104664: LD_INT 8
104666: DOUBLE
104667: EQUAL
104668: IFTRUE 104672
104670: GO 104800
104672: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
104673: LD_ADDR_VAR 0 1
104677: PUSH
104678: LD_INT 2
104680: PUSH
104681: LD_INT 4
104683: PUSH
104684: LD_INT 5
104686: PUSH
104687: LD_INT 6
104689: PUSH
104690: LD_INT 7
104692: PUSH
104693: LD_INT 8
104695: PUSH
104696: LD_INT 11
104698: PUSH
104699: LD_INT 12
104701: PUSH
104702: LD_INT 15
104704: PUSH
104705: LD_INT 16
104707: PUSH
104708: LD_INT 20
104710: PUSH
104711: LD_INT 21
104713: PUSH
104714: LD_INT 22
104716: PUSH
104717: LD_INT 23
104719: PUSH
104720: LD_INT 25
104722: PUSH
104723: LD_INT 26
104725: PUSH
104726: LD_INT 30
104728: PUSH
104729: LD_INT 31
104731: PUSH
104732: LD_INT 32
104734: PUSH
104735: LD_INT 36
104737: PUSH
104738: EMPTY
104739: LIST
104740: LIST
104741: LIST
104742: LIST
104743: LIST
104744: LIST
104745: LIST
104746: LIST
104747: LIST
104748: LIST
104749: LIST
104750: LIST
104751: LIST
104752: LIST
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: LIST
104758: LIST
104759: PUSH
104760: LD_INT 101
104762: PUSH
104763: LD_INT 102
104765: PUSH
104766: LD_INT 103
104768: PUSH
104769: LD_INT 105
104771: PUSH
104772: LD_INT 106
104774: PUSH
104775: LD_INT 108
104777: PUSH
104778: LD_INT 109
104780: PUSH
104781: LD_INT 112
104783: PUSH
104784: EMPTY
104785: LIST
104786: LIST
104787: LIST
104788: LIST
104789: LIST
104790: LIST
104791: LIST
104792: LIST
104793: PUSH
104794: EMPTY
104795: LIST
104796: LIST
104797: ST_TO_ADDR
104798: GO 106921
104800: LD_INT 9
104802: DOUBLE
104803: EQUAL
104804: IFTRUE 104808
104806: GO 104944
104808: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
104809: LD_ADDR_VAR 0 1
104813: PUSH
104814: LD_INT 2
104816: PUSH
104817: LD_INT 4
104819: PUSH
104820: LD_INT 5
104822: PUSH
104823: LD_INT 6
104825: PUSH
104826: LD_INT 7
104828: PUSH
104829: LD_INT 8
104831: PUSH
104832: LD_INT 11
104834: PUSH
104835: LD_INT 12
104837: PUSH
104838: LD_INT 15
104840: PUSH
104841: LD_INT 16
104843: PUSH
104844: LD_INT 20
104846: PUSH
104847: LD_INT 21
104849: PUSH
104850: LD_INT 22
104852: PUSH
104853: LD_INT 23
104855: PUSH
104856: LD_INT 25
104858: PUSH
104859: LD_INT 26
104861: PUSH
104862: LD_INT 28
104864: PUSH
104865: LD_INT 30
104867: PUSH
104868: LD_INT 31
104870: PUSH
104871: LD_INT 32
104873: PUSH
104874: LD_INT 36
104876: PUSH
104877: EMPTY
104878: LIST
104879: LIST
104880: LIST
104881: LIST
104882: LIST
104883: LIST
104884: LIST
104885: LIST
104886: LIST
104887: LIST
104888: LIST
104889: LIST
104890: LIST
104891: LIST
104892: LIST
104893: LIST
104894: LIST
104895: LIST
104896: LIST
104897: LIST
104898: LIST
104899: PUSH
104900: LD_INT 101
104902: PUSH
104903: LD_INT 102
104905: PUSH
104906: LD_INT 103
104908: PUSH
104909: LD_INT 105
104911: PUSH
104912: LD_INT 106
104914: PUSH
104915: LD_INT 108
104917: PUSH
104918: LD_INT 109
104920: PUSH
104921: LD_INT 112
104923: PUSH
104924: LD_INT 114
104926: PUSH
104927: EMPTY
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: LIST
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: ST_TO_ADDR
104942: GO 106921
104944: LD_INT 10
104946: DOUBLE
104947: EQUAL
104948: IFTRUE 104952
104950: GO 105136
104952: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104953: LD_ADDR_VAR 0 1
104957: PUSH
104958: LD_INT 2
104960: PUSH
104961: LD_INT 4
104963: PUSH
104964: LD_INT 5
104966: PUSH
104967: LD_INT 6
104969: PUSH
104970: LD_INT 7
104972: PUSH
104973: LD_INT 8
104975: PUSH
104976: LD_INT 9
104978: PUSH
104979: LD_INT 10
104981: PUSH
104982: LD_INT 11
104984: PUSH
104985: LD_INT 12
104987: PUSH
104988: LD_INT 13
104990: PUSH
104991: LD_INT 14
104993: PUSH
104994: LD_INT 15
104996: PUSH
104997: LD_INT 16
104999: PUSH
105000: LD_INT 17
105002: PUSH
105003: LD_INT 18
105005: PUSH
105006: LD_INT 19
105008: PUSH
105009: LD_INT 20
105011: PUSH
105012: LD_INT 21
105014: PUSH
105015: LD_INT 22
105017: PUSH
105018: LD_INT 23
105020: PUSH
105021: LD_INT 24
105023: PUSH
105024: LD_INT 25
105026: PUSH
105027: LD_INT 26
105029: PUSH
105030: LD_INT 28
105032: PUSH
105033: LD_INT 30
105035: PUSH
105036: LD_INT 31
105038: PUSH
105039: LD_INT 32
105041: PUSH
105042: LD_INT 36
105044: PUSH
105045: EMPTY
105046: LIST
105047: LIST
105048: LIST
105049: LIST
105050: LIST
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: LIST
105056: LIST
105057: LIST
105058: LIST
105059: LIST
105060: LIST
105061: LIST
105062: LIST
105063: LIST
105064: LIST
105065: LIST
105066: LIST
105067: LIST
105068: LIST
105069: LIST
105070: LIST
105071: LIST
105072: LIST
105073: LIST
105074: LIST
105075: PUSH
105076: LD_INT 101
105078: PUSH
105079: LD_INT 102
105081: PUSH
105082: LD_INT 103
105084: PUSH
105085: LD_INT 104
105087: PUSH
105088: LD_INT 105
105090: PUSH
105091: LD_INT 106
105093: PUSH
105094: LD_INT 107
105096: PUSH
105097: LD_INT 108
105099: PUSH
105100: LD_INT 109
105102: PUSH
105103: LD_INT 110
105105: PUSH
105106: LD_INT 111
105108: PUSH
105109: LD_INT 112
105111: PUSH
105112: LD_INT 114
105114: PUSH
105115: EMPTY
105116: LIST
105117: LIST
105118: LIST
105119: LIST
105120: LIST
105121: LIST
105122: LIST
105123: LIST
105124: LIST
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: PUSH
105130: EMPTY
105131: LIST
105132: LIST
105133: ST_TO_ADDR
105134: GO 106921
105136: LD_INT 11
105138: DOUBLE
105139: EQUAL
105140: IFTRUE 105144
105142: GO 105336
105144: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
105145: LD_ADDR_VAR 0 1
105149: PUSH
105150: LD_INT 2
105152: PUSH
105153: LD_INT 3
105155: PUSH
105156: LD_INT 4
105158: PUSH
105159: LD_INT 5
105161: PUSH
105162: LD_INT 6
105164: PUSH
105165: LD_INT 7
105167: PUSH
105168: LD_INT 8
105170: PUSH
105171: LD_INT 9
105173: PUSH
105174: LD_INT 10
105176: PUSH
105177: LD_INT 11
105179: PUSH
105180: LD_INT 12
105182: PUSH
105183: LD_INT 13
105185: PUSH
105186: LD_INT 14
105188: PUSH
105189: LD_INT 15
105191: PUSH
105192: LD_INT 16
105194: PUSH
105195: LD_INT 17
105197: PUSH
105198: LD_INT 18
105200: PUSH
105201: LD_INT 19
105203: PUSH
105204: LD_INT 20
105206: PUSH
105207: LD_INT 21
105209: PUSH
105210: LD_INT 22
105212: PUSH
105213: LD_INT 23
105215: PUSH
105216: LD_INT 24
105218: PUSH
105219: LD_INT 25
105221: PUSH
105222: LD_INT 26
105224: PUSH
105225: LD_INT 28
105227: PUSH
105228: LD_INT 30
105230: PUSH
105231: LD_INT 31
105233: PUSH
105234: LD_INT 32
105236: PUSH
105237: LD_INT 34
105239: PUSH
105240: LD_INT 36
105242: PUSH
105243: EMPTY
105244: LIST
105245: LIST
105246: LIST
105247: LIST
105248: LIST
105249: LIST
105250: LIST
105251: LIST
105252: LIST
105253: LIST
105254: LIST
105255: LIST
105256: LIST
105257: LIST
105258: LIST
105259: LIST
105260: LIST
105261: LIST
105262: LIST
105263: LIST
105264: LIST
105265: LIST
105266: LIST
105267: LIST
105268: LIST
105269: LIST
105270: LIST
105271: LIST
105272: LIST
105273: LIST
105274: LIST
105275: PUSH
105276: LD_INT 101
105278: PUSH
105279: LD_INT 102
105281: PUSH
105282: LD_INT 103
105284: PUSH
105285: LD_INT 104
105287: PUSH
105288: LD_INT 105
105290: PUSH
105291: LD_INT 106
105293: PUSH
105294: LD_INT 107
105296: PUSH
105297: LD_INT 108
105299: PUSH
105300: LD_INT 109
105302: PUSH
105303: LD_INT 110
105305: PUSH
105306: LD_INT 111
105308: PUSH
105309: LD_INT 112
105311: PUSH
105312: LD_INT 114
105314: PUSH
105315: EMPTY
105316: LIST
105317: LIST
105318: LIST
105319: LIST
105320: LIST
105321: LIST
105322: LIST
105323: LIST
105324: LIST
105325: LIST
105326: LIST
105327: LIST
105328: LIST
105329: PUSH
105330: EMPTY
105331: LIST
105332: LIST
105333: ST_TO_ADDR
105334: GO 106921
105336: LD_INT 12
105338: DOUBLE
105339: EQUAL
105340: IFTRUE 105344
105342: GO 105552
105344: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
105345: LD_ADDR_VAR 0 1
105349: PUSH
105350: LD_INT 1
105352: PUSH
105353: LD_INT 2
105355: PUSH
105356: LD_INT 3
105358: PUSH
105359: LD_INT 4
105361: PUSH
105362: LD_INT 5
105364: PUSH
105365: LD_INT 6
105367: PUSH
105368: LD_INT 7
105370: PUSH
105371: LD_INT 8
105373: PUSH
105374: LD_INT 9
105376: PUSH
105377: LD_INT 10
105379: PUSH
105380: LD_INT 11
105382: PUSH
105383: LD_INT 12
105385: PUSH
105386: LD_INT 13
105388: PUSH
105389: LD_INT 14
105391: PUSH
105392: LD_INT 15
105394: PUSH
105395: LD_INT 16
105397: PUSH
105398: LD_INT 17
105400: PUSH
105401: LD_INT 18
105403: PUSH
105404: LD_INT 19
105406: PUSH
105407: LD_INT 20
105409: PUSH
105410: LD_INT 21
105412: PUSH
105413: LD_INT 22
105415: PUSH
105416: LD_INT 23
105418: PUSH
105419: LD_INT 24
105421: PUSH
105422: LD_INT 25
105424: PUSH
105425: LD_INT 26
105427: PUSH
105428: LD_INT 27
105430: PUSH
105431: LD_INT 28
105433: PUSH
105434: LD_INT 30
105436: PUSH
105437: LD_INT 31
105439: PUSH
105440: LD_INT 32
105442: PUSH
105443: LD_INT 33
105445: PUSH
105446: LD_INT 34
105448: PUSH
105449: LD_INT 36
105451: PUSH
105452: EMPTY
105453: LIST
105454: LIST
105455: LIST
105456: LIST
105457: LIST
105458: LIST
105459: LIST
105460: LIST
105461: LIST
105462: LIST
105463: LIST
105464: LIST
105465: LIST
105466: LIST
105467: LIST
105468: LIST
105469: LIST
105470: LIST
105471: LIST
105472: LIST
105473: LIST
105474: LIST
105475: LIST
105476: LIST
105477: LIST
105478: LIST
105479: LIST
105480: LIST
105481: LIST
105482: LIST
105483: LIST
105484: LIST
105485: LIST
105486: LIST
105487: PUSH
105488: LD_INT 101
105490: PUSH
105491: LD_INT 102
105493: PUSH
105494: LD_INT 103
105496: PUSH
105497: LD_INT 104
105499: PUSH
105500: LD_INT 105
105502: PUSH
105503: LD_INT 106
105505: PUSH
105506: LD_INT 107
105508: PUSH
105509: LD_INT 108
105511: PUSH
105512: LD_INT 109
105514: PUSH
105515: LD_INT 110
105517: PUSH
105518: LD_INT 111
105520: PUSH
105521: LD_INT 112
105523: PUSH
105524: LD_INT 113
105526: PUSH
105527: LD_INT 114
105529: PUSH
105530: EMPTY
105531: LIST
105532: LIST
105533: LIST
105534: LIST
105535: LIST
105536: LIST
105537: LIST
105538: LIST
105539: LIST
105540: LIST
105541: LIST
105542: LIST
105543: LIST
105544: LIST
105545: PUSH
105546: EMPTY
105547: LIST
105548: LIST
105549: ST_TO_ADDR
105550: GO 106921
105552: LD_INT 13
105554: DOUBLE
105555: EQUAL
105556: IFTRUE 105560
105558: GO 105756
105560: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
105561: LD_ADDR_VAR 0 1
105565: PUSH
105566: LD_INT 1
105568: PUSH
105569: LD_INT 2
105571: PUSH
105572: LD_INT 3
105574: PUSH
105575: LD_INT 4
105577: PUSH
105578: LD_INT 5
105580: PUSH
105581: LD_INT 8
105583: PUSH
105584: LD_INT 9
105586: PUSH
105587: LD_INT 10
105589: PUSH
105590: LD_INT 11
105592: PUSH
105593: LD_INT 12
105595: PUSH
105596: LD_INT 14
105598: PUSH
105599: LD_INT 15
105601: PUSH
105602: LD_INT 16
105604: PUSH
105605: LD_INT 17
105607: PUSH
105608: LD_INT 18
105610: PUSH
105611: LD_INT 19
105613: PUSH
105614: LD_INT 20
105616: PUSH
105617: LD_INT 21
105619: PUSH
105620: LD_INT 22
105622: PUSH
105623: LD_INT 23
105625: PUSH
105626: LD_INT 24
105628: PUSH
105629: LD_INT 25
105631: PUSH
105632: LD_INT 26
105634: PUSH
105635: LD_INT 27
105637: PUSH
105638: LD_INT 28
105640: PUSH
105641: LD_INT 30
105643: PUSH
105644: LD_INT 31
105646: PUSH
105647: LD_INT 32
105649: PUSH
105650: LD_INT 33
105652: PUSH
105653: LD_INT 34
105655: PUSH
105656: LD_INT 36
105658: PUSH
105659: EMPTY
105660: LIST
105661: LIST
105662: LIST
105663: LIST
105664: LIST
105665: LIST
105666: LIST
105667: LIST
105668: LIST
105669: LIST
105670: LIST
105671: LIST
105672: LIST
105673: LIST
105674: LIST
105675: LIST
105676: LIST
105677: LIST
105678: LIST
105679: LIST
105680: LIST
105681: LIST
105682: LIST
105683: LIST
105684: LIST
105685: LIST
105686: LIST
105687: LIST
105688: LIST
105689: LIST
105690: LIST
105691: PUSH
105692: LD_INT 101
105694: PUSH
105695: LD_INT 102
105697: PUSH
105698: LD_INT 103
105700: PUSH
105701: LD_INT 104
105703: PUSH
105704: LD_INT 105
105706: PUSH
105707: LD_INT 106
105709: PUSH
105710: LD_INT 107
105712: PUSH
105713: LD_INT 108
105715: PUSH
105716: LD_INT 109
105718: PUSH
105719: LD_INT 110
105721: PUSH
105722: LD_INT 111
105724: PUSH
105725: LD_INT 112
105727: PUSH
105728: LD_INT 113
105730: PUSH
105731: LD_INT 114
105733: PUSH
105734: EMPTY
105735: LIST
105736: LIST
105737: LIST
105738: LIST
105739: LIST
105740: LIST
105741: LIST
105742: LIST
105743: LIST
105744: LIST
105745: LIST
105746: LIST
105747: LIST
105748: LIST
105749: PUSH
105750: EMPTY
105751: LIST
105752: LIST
105753: ST_TO_ADDR
105754: GO 106921
105756: LD_INT 14
105758: DOUBLE
105759: EQUAL
105760: IFTRUE 105764
105762: GO 105976
105764: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
105765: LD_ADDR_VAR 0 1
105769: PUSH
105770: LD_INT 1
105772: PUSH
105773: LD_INT 2
105775: PUSH
105776: LD_INT 3
105778: PUSH
105779: LD_INT 4
105781: PUSH
105782: LD_INT 5
105784: PUSH
105785: LD_INT 6
105787: PUSH
105788: LD_INT 7
105790: PUSH
105791: LD_INT 8
105793: PUSH
105794: LD_INT 9
105796: PUSH
105797: LD_INT 10
105799: PUSH
105800: LD_INT 11
105802: PUSH
105803: LD_INT 12
105805: PUSH
105806: LD_INT 13
105808: PUSH
105809: LD_INT 14
105811: PUSH
105812: LD_INT 15
105814: PUSH
105815: LD_INT 16
105817: PUSH
105818: LD_INT 17
105820: PUSH
105821: LD_INT 18
105823: PUSH
105824: LD_INT 19
105826: PUSH
105827: LD_INT 20
105829: PUSH
105830: LD_INT 21
105832: PUSH
105833: LD_INT 22
105835: PUSH
105836: LD_INT 23
105838: PUSH
105839: LD_INT 24
105841: PUSH
105842: LD_INT 25
105844: PUSH
105845: LD_INT 26
105847: PUSH
105848: LD_INT 27
105850: PUSH
105851: LD_INT 28
105853: PUSH
105854: LD_INT 29
105856: PUSH
105857: LD_INT 30
105859: PUSH
105860: LD_INT 31
105862: PUSH
105863: LD_INT 32
105865: PUSH
105866: LD_INT 33
105868: PUSH
105869: LD_INT 34
105871: PUSH
105872: LD_INT 36
105874: PUSH
105875: EMPTY
105876: LIST
105877: LIST
105878: LIST
105879: LIST
105880: LIST
105881: LIST
105882: LIST
105883: LIST
105884: LIST
105885: LIST
105886: LIST
105887: LIST
105888: LIST
105889: LIST
105890: LIST
105891: LIST
105892: LIST
105893: LIST
105894: LIST
105895: LIST
105896: LIST
105897: LIST
105898: LIST
105899: LIST
105900: LIST
105901: LIST
105902: LIST
105903: LIST
105904: LIST
105905: LIST
105906: LIST
105907: LIST
105908: LIST
105909: LIST
105910: LIST
105911: PUSH
105912: LD_INT 101
105914: PUSH
105915: LD_INT 102
105917: PUSH
105918: LD_INT 103
105920: PUSH
105921: LD_INT 104
105923: PUSH
105924: LD_INT 105
105926: PUSH
105927: LD_INT 106
105929: PUSH
105930: LD_INT 107
105932: PUSH
105933: LD_INT 108
105935: PUSH
105936: LD_INT 109
105938: PUSH
105939: LD_INT 110
105941: PUSH
105942: LD_INT 111
105944: PUSH
105945: LD_INT 112
105947: PUSH
105948: LD_INT 113
105950: PUSH
105951: LD_INT 114
105953: PUSH
105954: EMPTY
105955: LIST
105956: LIST
105957: LIST
105958: LIST
105959: LIST
105960: LIST
105961: LIST
105962: LIST
105963: LIST
105964: LIST
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: PUSH
105970: EMPTY
105971: LIST
105972: LIST
105973: ST_TO_ADDR
105974: GO 106921
105976: LD_INT 15
105978: DOUBLE
105979: EQUAL
105980: IFTRUE 105984
105982: GO 106196
105984: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105985: LD_ADDR_VAR 0 1
105989: PUSH
105990: LD_INT 1
105992: PUSH
105993: LD_INT 2
105995: PUSH
105996: LD_INT 3
105998: PUSH
105999: LD_INT 4
106001: PUSH
106002: LD_INT 5
106004: PUSH
106005: LD_INT 6
106007: PUSH
106008: LD_INT 7
106010: PUSH
106011: LD_INT 8
106013: PUSH
106014: LD_INT 9
106016: PUSH
106017: LD_INT 10
106019: PUSH
106020: LD_INT 11
106022: PUSH
106023: LD_INT 12
106025: PUSH
106026: LD_INT 13
106028: PUSH
106029: LD_INT 14
106031: PUSH
106032: LD_INT 15
106034: PUSH
106035: LD_INT 16
106037: PUSH
106038: LD_INT 17
106040: PUSH
106041: LD_INT 18
106043: PUSH
106044: LD_INT 19
106046: PUSH
106047: LD_INT 20
106049: PUSH
106050: LD_INT 21
106052: PUSH
106053: LD_INT 22
106055: PUSH
106056: LD_INT 23
106058: PUSH
106059: LD_INT 24
106061: PUSH
106062: LD_INT 25
106064: PUSH
106065: LD_INT 26
106067: PUSH
106068: LD_INT 27
106070: PUSH
106071: LD_INT 28
106073: PUSH
106074: LD_INT 29
106076: PUSH
106077: LD_INT 30
106079: PUSH
106080: LD_INT 31
106082: PUSH
106083: LD_INT 32
106085: PUSH
106086: LD_INT 33
106088: PUSH
106089: LD_INT 34
106091: PUSH
106092: LD_INT 36
106094: PUSH
106095: EMPTY
106096: LIST
106097: LIST
106098: LIST
106099: LIST
106100: LIST
106101: LIST
106102: LIST
106103: LIST
106104: LIST
106105: LIST
106106: LIST
106107: LIST
106108: LIST
106109: LIST
106110: LIST
106111: LIST
106112: LIST
106113: LIST
106114: LIST
106115: LIST
106116: LIST
106117: LIST
106118: LIST
106119: LIST
106120: LIST
106121: LIST
106122: LIST
106123: LIST
106124: LIST
106125: LIST
106126: LIST
106127: LIST
106128: LIST
106129: LIST
106130: LIST
106131: PUSH
106132: LD_INT 101
106134: PUSH
106135: LD_INT 102
106137: PUSH
106138: LD_INT 103
106140: PUSH
106141: LD_INT 104
106143: PUSH
106144: LD_INT 105
106146: PUSH
106147: LD_INT 106
106149: PUSH
106150: LD_INT 107
106152: PUSH
106153: LD_INT 108
106155: PUSH
106156: LD_INT 109
106158: PUSH
106159: LD_INT 110
106161: PUSH
106162: LD_INT 111
106164: PUSH
106165: LD_INT 112
106167: PUSH
106168: LD_INT 113
106170: PUSH
106171: LD_INT 114
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: LIST
106178: LIST
106179: LIST
106180: LIST
106181: LIST
106182: LIST
106183: LIST
106184: LIST
106185: LIST
106186: LIST
106187: LIST
106188: LIST
106189: PUSH
106190: EMPTY
106191: LIST
106192: LIST
106193: ST_TO_ADDR
106194: GO 106921
106196: LD_INT 16
106198: DOUBLE
106199: EQUAL
106200: IFTRUE 106204
106202: GO 106328
106204: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
106205: LD_ADDR_VAR 0 1
106209: PUSH
106210: LD_INT 2
106212: PUSH
106213: LD_INT 4
106215: PUSH
106216: LD_INT 5
106218: PUSH
106219: LD_INT 7
106221: PUSH
106222: LD_INT 11
106224: PUSH
106225: LD_INT 12
106227: PUSH
106228: LD_INT 15
106230: PUSH
106231: LD_INT 16
106233: PUSH
106234: LD_INT 20
106236: PUSH
106237: LD_INT 21
106239: PUSH
106240: LD_INT 22
106242: PUSH
106243: LD_INT 23
106245: PUSH
106246: LD_INT 25
106248: PUSH
106249: LD_INT 26
106251: PUSH
106252: LD_INT 30
106254: PUSH
106255: LD_INT 31
106257: PUSH
106258: LD_INT 32
106260: PUSH
106261: LD_INT 33
106263: PUSH
106264: LD_INT 34
106266: PUSH
106267: EMPTY
106268: LIST
106269: LIST
106270: LIST
106271: LIST
106272: LIST
106273: LIST
106274: LIST
106275: LIST
106276: LIST
106277: LIST
106278: LIST
106279: LIST
106280: LIST
106281: LIST
106282: LIST
106283: LIST
106284: LIST
106285: LIST
106286: LIST
106287: PUSH
106288: LD_INT 101
106290: PUSH
106291: LD_INT 102
106293: PUSH
106294: LD_INT 103
106296: PUSH
106297: LD_INT 106
106299: PUSH
106300: LD_INT 108
106302: PUSH
106303: LD_INT 112
106305: PUSH
106306: LD_INT 113
106308: PUSH
106309: LD_INT 114
106311: PUSH
106312: EMPTY
106313: LIST
106314: LIST
106315: LIST
106316: LIST
106317: LIST
106318: LIST
106319: LIST
106320: LIST
106321: PUSH
106322: EMPTY
106323: LIST
106324: LIST
106325: ST_TO_ADDR
106326: GO 106921
106328: LD_INT 17
106330: DOUBLE
106331: EQUAL
106332: IFTRUE 106336
106334: GO 106548
106336: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
106337: LD_ADDR_VAR 0 1
106341: PUSH
106342: LD_INT 1
106344: PUSH
106345: LD_INT 2
106347: PUSH
106348: LD_INT 3
106350: PUSH
106351: LD_INT 4
106353: PUSH
106354: LD_INT 5
106356: PUSH
106357: LD_INT 6
106359: PUSH
106360: LD_INT 7
106362: PUSH
106363: LD_INT 8
106365: PUSH
106366: LD_INT 9
106368: PUSH
106369: LD_INT 10
106371: PUSH
106372: LD_INT 11
106374: PUSH
106375: LD_INT 12
106377: PUSH
106378: LD_INT 13
106380: PUSH
106381: LD_INT 14
106383: PUSH
106384: LD_INT 15
106386: PUSH
106387: LD_INT 16
106389: PUSH
106390: LD_INT 17
106392: PUSH
106393: LD_INT 18
106395: PUSH
106396: LD_INT 19
106398: PUSH
106399: LD_INT 20
106401: PUSH
106402: LD_INT 21
106404: PUSH
106405: LD_INT 22
106407: PUSH
106408: LD_INT 23
106410: PUSH
106411: LD_INT 24
106413: PUSH
106414: LD_INT 25
106416: PUSH
106417: LD_INT 26
106419: PUSH
106420: LD_INT 27
106422: PUSH
106423: LD_INT 28
106425: PUSH
106426: LD_INT 29
106428: PUSH
106429: LD_INT 30
106431: PUSH
106432: LD_INT 31
106434: PUSH
106435: LD_INT 32
106437: PUSH
106438: LD_INT 33
106440: PUSH
106441: LD_INT 34
106443: PUSH
106444: LD_INT 36
106446: PUSH
106447: EMPTY
106448: LIST
106449: LIST
106450: LIST
106451: LIST
106452: LIST
106453: LIST
106454: LIST
106455: LIST
106456: LIST
106457: LIST
106458: LIST
106459: LIST
106460: LIST
106461: LIST
106462: LIST
106463: LIST
106464: LIST
106465: LIST
106466: LIST
106467: LIST
106468: LIST
106469: LIST
106470: LIST
106471: LIST
106472: LIST
106473: LIST
106474: LIST
106475: LIST
106476: LIST
106477: LIST
106478: LIST
106479: LIST
106480: LIST
106481: LIST
106482: LIST
106483: PUSH
106484: LD_INT 101
106486: PUSH
106487: LD_INT 102
106489: PUSH
106490: LD_INT 103
106492: PUSH
106493: LD_INT 104
106495: PUSH
106496: LD_INT 105
106498: PUSH
106499: LD_INT 106
106501: PUSH
106502: LD_INT 107
106504: PUSH
106505: LD_INT 108
106507: PUSH
106508: LD_INT 109
106510: PUSH
106511: LD_INT 110
106513: PUSH
106514: LD_INT 111
106516: PUSH
106517: LD_INT 112
106519: PUSH
106520: LD_INT 113
106522: PUSH
106523: LD_INT 114
106525: PUSH
106526: EMPTY
106527: LIST
106528: LIST
106529: LIST
106530: LIST
106531: LIST
106532: LIST
106533: LIST
106534: LIST
106535: LIST
106536: LIST
106537: LIST
106538: LIST
106539: LIST
106540: LIST
106541: PUSH
106542: EMPTY
106543: LIST
106544: LIST
106545: ST_TO_ADDR
106546: GO 106921
106548: LD_INT 18
106550: DOUBLE
106551: EQUAL
106552: IFTRUE 106556
106554: GO 106692
106556: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
106557: LD_ADDR_VAR 0 1
106561: PUSH
106562: LD_INT 2
106564: PUSH
106565: LD_INT 4
106567: PUSH
106568: LD_INT 5
106570: PUSH
106571: LD_INT 7
106573: PUSH
106574: LD_INT 11
106576: PUSH
106577: LD_INT 12
106579: PUSH
106580: LD_INT 15
106582: PUSH
106583: LD_INT 16
106585: PUSH
106586: LD_INT 20
106588: PUSH
106589: LD_INT 21
106591: PUSH
106592: LD_INT 22
106594: PUSH
106595: LD_INT 23
106597: PUSH
106598: LD_INT 25
106600: PUSH
106601: LD_INT 26
106603: PUSH
106604: LD_INT 30
106606: PUSH
106607: LD_INT 31
106609: PUSH
106610: LD_INT 32
106612: PUSH
106613: LD_INT 33
106615: PUSH
106616: LD_INT 34
106618: PUSH
106619: LD_INT 35
106621: PUSH
106622: LD_INT 36
106624: PUSH
106625: EMPTY
106626: LIST
106627: LIST
106628: LIST
106629: LIST
106630: LIST
106631: LIST
106632: LIST
106633: LIST
106634: LIST
106635: LIST
106636: LIST
106637: LIST
106638: LIST
106639: LIST
106640: LIST
106641: LIST
106642: LIST
106643: LIST
106644: LIST
106645: LIST
106646: LIST
106647: PUSH
106648: LD_INT 101
106650: PUSH
106651: LD_INT 102
106653: PUSH
106654: LD_INT 103
106656: PUSH
106657: LD_INT 106
106659: PUSH
106660: LD_INT 108
106662: PUSH
106663: LD_INT 112
106665: PUSH
106666: LD_INT 113
106668: PUSH
106669: LD_INT 114
106671: PUSH
106672: LD_INT 115
106674: PUSH
106675: EMPTY
106676: LIST
106677: LIST
106678: LIST
106679: LIST
106680: LIST
106681: LIST
106682: LIST
106683: LIST
106684: LIST
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: ST_TO_ADDR
106690: GO 106921
106692: LD_INT 19
106694: DOUBLE
106695: EQUAL
106696: IFTRUE 106700
106698: GO 106920
106700: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
106701: LD_ADDR_VAR 0 1
106705: PUSH
106706: LD_INT 1
106708: PUSH
106709: LD_INT 2
106711: PUSH
106712: LD_INT 3
106714: PUSH
106715: LD_INT 4
106717: PUSH
106718: LD_INT 5
106720: PUSH
106721: LD_INT 6
106723: PUSH
106724: LD_INT 7
106726: PUSH
106727: LD_INT 8
106729: PUSH
106730: LD_INT 9
106732: PUSH
106733: LD_INT 10
106735: PUSH
106736: LD_INT 11
106738: PUSH
106739: LD_INT 12
106741: PUSH
106742: LD_INT 13
106744: PUSH
106745: LD_INT 14
106747: PUSH
106748: LD_INT 15
106750: PUSH
106751: LD_INT 16
106753: PUSH
106754: LD_INT 17
106756: PUSH
106757: LD_INT 18
106759: PUSH
106760: LD_INT 19
106762: PUSH
106763: LD_INT 20
106765: PUSH
106766: LD_INT 21
106768: PUSH
106769: LD_INT 22
106771: PUSH
106772: LD_INT 23
106774: PUSH
106775: LD_INT 24
106777: PUSH
106778: LD_INT 25
106780: PUSH
106781: LD_INT 26
106783: PUSH
106784: LD_INT 27
106786: PUSH
106787: LD_INT 28
106789: PUSH
106790: LD_INT 29
106792: PUSH
106793: LD_INT 30
106795: PUSH
106796: LD_INT 31
106798: PUSH
106799: LD_INT 32
106801: PUSH
106802: LD_INT 33
106804: PUSH
106805: LD_INT 34
106807: PUSH
106808: LD_INT 35
106810: PUSH
106811: LD_INT 36
106813: PUSH
106814: EMPTY
106815: LIST
106816: LIST
106817: LIST
106818: LIST
106819: LIST
106820: LIST
106821: LIST
106822: LIST
106823: LIST
106824: LIST
106825: LIST
106826: LIST
106827: LIST
106828: LIST
106829: LIST
106830: LIST
106831: LIST
106832: LIST
106833: LIST
106834: LIST
106835: LIST
106836: LIST
106837: LIST
106838: LIST
106839: LIST
106840: LIST
106841: LIST
106842: LIST
106843: LIST
106844: LIST
106845: LIST
106846: LIST
106847: LIST
106848: LIST
106849: LIST
106850: LIST
106851: PUSH
106852: LD_INT 101
106854: PUSH
106855: LD_INT 102
106857: PUSH
106858: LD_INT 103
106860: PUSH
106861: LD_INT 104
106863: PUSH
106864: LD_INT 105
106866: PUSH
106867: LD_INT 106
106869: PUSH
106870: LD_INT 107
106872: PUSH
106873: LD_INT 108
106875: PUSH
106876: LD_INT 109
106878: PUSH
106879: LD_INT 110
106881: PUSH
106882: LD_INT 111
106884: PUSH
106885: LD_INT 112
106887: PUSH
106888: LD_INT 113
106890: PUSH
106891: LD_INT 114
106893: PUSH
106894: LD_INT 115
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: LIST
106901: LIST
106902: LIST
106903: LIST
106904: LIST
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: LIST
106910: LIST
106911: LIST
106912: LIST
106913: PUSH
106914: EMPTY
106915: LIST
106916: LIST
106917: ST_TO_ADDR
106918: GO 106921
106920: POP
// end else
106921: GO 107140
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
106923: LD_ADDR_VAR 0 1
106927: PUSH
106928: LD_INT 1
106930: PUSH
106931: LD_INT 2
106933: PUSH
106934: LD_INT 3
106936: PUSH
106937: LD_INT 4
106939: PUSH
106940: LD_INT 5
106942: PUSH
106943: LD_INT 6
106945: PUSH
106946: LD_INT 7
106948: PUSH
106949: LD_INT 8
106951: PUSH
106952: LD_INT 9
106954: PUSH
106955: LD_INT 10
106957: PUSH
106958: LD_INT 11
106960: PUSH
106961: LD_INT 12
106963: PUSH
106964: LD_INT 13
106966: PUSH
106967: LD_INT 14
106969: PUSH
106970: LD_INT 15
106972: PUSH
106973: LD_INT 16
106975: PUSH
106976: LD_INT 17
106978: PUSH
106979: LD_INT 18
106981: PUSH
106982: LD_INT 19
106984: PUSH
106985: LD_INT 20
106987: PUSH
106988: LD_INT 21
106990: PUSH
106991: LD_INT 22
106993: PUSH
106994: LD_INT 23
106996: PUSH
106997: LD_INT 24
106999: PUSH
107000: LD_INT 25
107002: PUSH
107003: LD_INT 26
107005: PUSH
107006: LD_INT 27
107008: PUSH
107009: LD_INT 28
107011: PUSH
107012: LD_INT 29
107014: PUSH
107015: LD_INT 30
107017: PUSH
107018: LD_INT 31
107020: PUSH
107021: LD_INT 32
107023: PUSH
107024: LD_INT 33
107026: PUSH
107027: LD_INT 34
107029: PUSH
107030: LD_INT 35
107032: PUSH
107033: LD_INT 36
107035: PUSH
107036: EMPTY
107037: LIST
107038: LIST
107039: LIST
107040: LIST
107041: LIST
107042: LIST
107043: LIST
107044: LIST
107045: LIST
107046: LIST
107047: LIST
107048: LIST
107049: LIST
107050: LIST
107051: LIST
107052: LIST
107053: LIST
107054: LIST
107055: LIST
107056: LIST
107057: LIST
107058: LIST
107059: LIST
107060: LIST
107061: LIST
107062: LIST
107063: LIST
107064: LIST
107065: LIST
107066: LIST
107067: LIST
107068: LIST
107069: LIST
107070: LIST
107071: LIST
107072: LIST
107073: PUSH
107074: LD_INT 101
107076: PUSH
107077: LD_INT 102
107079: PUSH
107080: LD_INT 103
107082: PUSH
107083: LD_INT 104
107085: PUSH
107086: LD_INT 105
107088: PUSH
107089: LD_INT 106
107091: PUSH
107092: LD_INT 107
107094: PUSH
107095: LD_INT 108
107097: PUSH
107098: LD_INT 109
107100: PUSH
107101: LD_INT 110
107103: PUSH
107104: LD_INT 111
107106: PUSH
107107: LD_INT 112
107109: PUSH
107110: LD_INT 113
107112: PUSH
107113: LD_INT 114
107115: PUSH
107116: LD_INT 115
107118: PUSH
107119: EMPTY
107120: LIST
107121: LIST
107122: LIST
107123: LIST
107124: LIST
107125: LIST
107126: LIST
107127: LIST
107128: LIST
107129: LIST
107130: LIST
107131: LIST
107132: LIST
107133: LIST
107134: LIST
107135: PUSH
107136: EMPTY
107137: LIST
107138: LIST
107139: ST_TO_ADDR
// if result then
107140: LD_VAR 0 1
107144: IFFALSE 107433
// begin normal :=  ;
107146: LD_ADDR_VAR 0 3
107150: PUSH
107151: LD_STRING 
107153: ST_TO_ADDR
// hardcore :=  ;
107154: LD_ADDR_VAR 0 4
107158: PUSH
107159: LD_STRING 
107161: ST_TO_ADDR
// for i = 1 to normalCounter do
107162: LD_ADDR_VAR 0 5
107166: PUSH
107167: DOUBLE
107168: LD_INT 1
107170: DEC
107171: ST_TO_ADDR
107172: LD_EXP 157
107176: PUSH
107177: FOR_TO
107178: IFFALSE 107279
// begin tmp := 0 ;
107180: LD_ADDR_VAR 0 2
107184: PUSH
107185: LD_STRING 0
107187: ST_TO_ADDR
// if result [ 1 ] then
107188: LD_VAR 0 1
107192: PUSH
107193: LD_INT 1
107195: ARRAY
107196: IFFALSE 107261
// if result [ 1 ] [ 1 ] = i then
107198: LD_VAR 0 1
107202: PUSH
107203: LD_INT 1
107205: ARRAY
107206: PUSH
107207: LD_INT 1
107209: ARRAY
107210: PUSH
107211: LD_VAR 0 5
107215: EQUAL
107216: IFFALSE 107261
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
107218: LD_ADDR_VAR 0 1
107222: PUSH
107223: LD_VAR 0 1
107227: PPUSH
107228: LD_INT 1
107230: PPUSH
107231: LD_VAR 0 1
107235: PUSH
107236: LD_INT 1
107238: ARRAY
107239: PPUSH
107240: LD_INT 1
107242: PPUSH
107243: CALL_OW 3
107247: PPUSH
107248: CALL_OW 1
107252: ST_TO_ADDR
// tmp := 1 ;
107253: LD_ADDR_VAR 0 2
107257: PUSH
107258: LD_STRING 1
107260: ST_TO_ADDR
// end ; normal := normal & tmp ;
107261: LD_ADDR_VAR 0 3
107265: PUSH
107266: LD_VAR 0 3
107270: PUSH
107271: LD_VAR 0 2
107275: STR
107276: ST_TO_ADDR
// end ;
107277: GO 107177
107279: POP
107280: POP
// for i = 1 to hardcoreCounter do
107281: LD_ADDR_VAR 0 5
107285: PUSH
107286: DOUBLE
107287: LD_INT 1
107289: DEC
107290: ST_TO_ADDR
107291: LD_EXP 158
107295: PUSH
107296: FOR_TO
107297: IFFALSE 107402
// begin tmp := 0 ;
107299: LD_ADDR_VAR 0 2
107303: PUSH
107304: LD_STRING 0
107306: ST_TO_ADDR
// if result [ 2 ] then
107307: LD_VAR 0 1
107311: PUSH
107312: LD_INT 2
107314: ARRAY
107315: IFFALSE 107384
// if result [ 2 ] [ 1 ] = 100 + i then
107317: LD_VAR 0 1
107321: PUSH
107322: LD_INT 2
107324: ARRAY
107325: PUSH
107326: LD_INT 1
107328: ARRAY
107329: PUSH
107330: LD_INT 100
107332: PUSH
107333: LD_VAR 0 5
107337: PLUS
107338: EQUAL
107339: IFFALSE 107384
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
107341: LD_ADDR_VAR 0 1
107345: PUSH
107346: LD_VAR 0 1
107350: PPUSH
107351: LD_INT 2
107353: PPUSH
107354: LD_VAR 0 1
107358: PUSH
107359: LD_INT 2
107361: ARRAY
107362: PPUSH
107363: LD_INT 1
107365: PPUSH
107366: CALL_OW 3
107370: PPUSH
107371: CALL_OW 1
107375: ST_TO_ADDR
// tmp := 1 ;
107376: LD_ADDR_VAR 0 2
107380: PUSH
107381: LD_STRING 1
107383: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
107384: LD_ADDR_VAR 0 4
107388: PUSH
107389: LD_VAR 0 4
107393: PUSH
107394: LD_VAR 0 2
107398: STR
107399: ST_TO_ADDR
// end ;
107400: GO 107296
107402: POP
107403: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
107404: LD_STRING getStreamItemsFromMission("
107406: PUSH
107407: LD_VAR 0 3
107411: STR
107412: PUSH
107413: LD_STRING ","
107415: STR
107416: PUSH
107417: LD_VAR 0 4
107421: STR
107422: PUSH
107423: LD_STRING ")
107425: STR
107426: PPUSH
107427: CALL_OW 559
// end else
107431: GO 107440
// ToLua ( getStreamItemsFromMission("","") ) ;
107433: LD_STRING getStreamItemsFromMission("","")
107435: PPUSH
107436: CALL_OW 559
// end ;
107440: LD_VAR 0 1
107444: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
107445: LD_EXP 156
107449: PUSH
107450: LD_EXP 161
107454: AND
107455: IFFALSE 107579
107457: GO 107459
107459: DISABLE
107460: LD_INT 0
107462: PPUSH
107463: PPUSH
// begin enable ;
107464: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
107465: LD_ADDR_VAR 0 2
107469: PUSH
107470: LD_INT 22
107472: PUSH
107473: LD_OWVAR 2
107477: PUSH
107478: EMPTY
107479: LIST
107480: LIST
107481: PUSH
107482: LD_INT 2
107484: PUSH
107485: LD_INT 34
107487: PUSH
107488: LD_INT 7
107490: PUSH
107491: EMPTY
107492: LIST
107493: LIST
107494: PUSH
107495: LD_INT 34
107497: PUSH
107498: LD_INT 45
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: PUSH
107505: LD_INT 34
107507: PUSH
107508: LD_INT 28
107510: PUSH
107511: EMPTY
107512: LIST
107513: LIST
107514: PUSH
107515: LD_INT 34
107517: PUSH
107518: LD_INT 47
107520: PUSH
107521: EMPTY
107522: LIST
107523: LIST
107524: PUSH
107525: EMPTY
107526: LIST
107527: LIST
107528: LIST
107529: LIST
107530: LIST
107531: PUSH
107532: EMPTY
107533: LIST
107534: LIST
107535: PPUSH
107536: CALL_OW 69
107540: ST_TO_ADDR
// if not tmp then
107541: LD_VAR 0 2
107545: NOT
107546: IFFALSE 107550
// exit ;
107548: GO 107579
// for i in tmp do
107550: LD_ADDR_VAR 0 1
107554: PUSH
107555: LD_VAR 0 2
107559: PUSH
107560: FOR_IN
107561: IFFALSE 107577
// begin SetLives ( i , 0 ) ;
107563: LD_VAR 0 1
107567: PPUSH
107568: LD_INT 0
107570: PPUSH
107571: CALL_OW 234
// end ;
107575: GO 107560
107577: POP
107578: POP
// end ;
107579: PPOPN 2
107581: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
107582: LD_EXP 156
107586: PUSH
107587: LD_EXP 162
107591: AND
107592: IFFALSE 107676
107594: GO 107596
107596: DISABLE
107597: LD_INT 0
107599: PPUSH
107600: PPUSH
// begin enable ;
107601: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
107602: LD_ADDR_VAR 0 2
107606: PUSH
107607: LD_INT 22
107609: PUSH
107610: LD_OWVAR 2
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: PUSH
107619: LD_INT 32
107621: PUSH
107622: LD_INT 3
107624: PUSH
107625: EMPTY
107626: LIST
107627: LIST
107628: PUSH
107629: EMPTY
107630: LIST
107631: LIST
107632: PPUSH
107633: CALL_OW 69
107637: ST_TO_ADDR
// if not tmp then
107638: LD_VAR 0 2
107642: NOT
107643: IFFALSE 107647
// exit ;
107645: GO 107676
// for i in tmp do
107647: LD_ADDR_VAR 0 1
107651: PUSH
107652: LD_VAR 0 2
107656: PUSH
107657: FOR_IN
107658: IFFALSE 107674
// begin SetLives ( i , 0 ) ;
107660: LD_VAR 0 1
107664: PPUSH
107665: LD_INT 0
107667: PPUSH
107668: CALL_OW 234
// end ;
107672: GO 107657
107674: POP
107675: POP
// end ;
107676: PPOPN 2
107678: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
107679: LD_EXP 156
107683: PUSH
107684: LD_EXP 159
107688: AND
107689: IFFALSE 107782
107691: GO 107693
107693: DISABLE
107694: LD_INT 0
107696: PPUSH
// begin enable ;
107697: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
107698: LD_ADDR_VAR 0 1
107702: PUSH
107703: LD_INT 22
107705: PUSH
107706: LD_OWVAR 2
107710: PUSH
107711: EMPTY
107712: LIST
107713: LIST
107714: PUSH
107715: LD_INT 2
107717: PUSH
107718: LD_INT 25
107720: PUSH
107721: LD_INT 5
107723: PUSH
107724: EMPTY
107725: LIST
107726: LIST
107727: PUSH
107728: LD_INT 25
107730: PUSH
107731: LD_INT 9
107733: PUSH
107734: EMPTY
107735: LIST
107736: LIST
107737: PUSH
107738: LD_INT 25
107740: PUSH
107741: LD_INT 8
107743: PUSH
107744: EMPTY
107745: LIST
107746: LIST
107747: PUSH
107748: EMPTY
107749: LIST
107750: LIST
107751: LIST
107752: LIST
107753: PUSH
107754: EMPTY
107755: LIST
107756: LIST
107757: PPUSH
107758: CALL_OW 69
107762: PUSH
107763: FOR_IN
107764: IFFALSE 107780
// begin SetClass ( i , 1 ) ;
107766: LD_VAR 0 1
107770: PPUSH
107771: LD_INT 1
107773: PPUSH
107774: CALL_OW 336
// end ;
107778: GO 107763
107780: POP
107781: POP
// end ;
107782: PPOPN 1
107784: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
107785: LD_EXP 156
107789: PUSH
107790: LD_EXP 160
107794: AND
107795: PUSH
107796: LD_OWVAR 65
107800: PUSH
107801: LD_INT 7
107803: LESS
107804: AND
107805: IFFALSE 107819
107807: GO 107809
107809: DISABLE
// begin enable ;
107810: ENABLE
// game_speed := 7 ;
107811: LD_ADDR_OWVAR 65
107815: PUSH
107816: LD_INT 7
107818: ST_TO_ADDR
// end ;
107819: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
107820: LD_EXP 156
107824: PUSH
107825: LD_EXP 163
107829: AND
107830: IFFALSE 108032
107832: GO 107834
107834: DISABLE
107835: LD_INT 0
107837: PPUSH
107838: PPUSH
107839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107840: LD_ADDR_VAR 0 3
107844: PUSH
107845: LD_INT 81
107847: PUSH
107848: LD_OWVAR 2
107852: PUSH
107853: EMPTY
107854: LIST
107855: LIST
107856: PUSH
107857: LD_INT 21
107859: PUSH
107860: LD_INT 1
107862: PUSH
107863: EMPTY
107864: LIST
107865: LIST
107866: PUSH
107867: EMPTY
107868: LIST
107869: LIST
107870: PPUSH
107871: CALL_OW 69
107875: ST_TO_ADDR
// if not tmp then
107876: LD_VAR 0 3
107880: NOT
107881: IFFALSE 107885
// exit ;
107883: GO 108032
// if tmp > 5 then
107885: LD_VAR 0 3
107889: PUSH
107890: LD_INT 5
107892: GREATER
107893: IFFALSE 107905
// k := 5 else
107895: LD_ADDR_VAR 0 2
107899: PUSH
107900: LD_INT 5
107902: ST_TO_ADDR
107903: GO 107915
// k := tmp ;
107905: LD_ADDR_VAR 0 2
107909: PUSH
107910: LD_VAR 0 3
107914: ST_TO_ADDR
// for i := 1 to k do
107915: LD_ADDR_VAR 0 1
107919: PUSH
107920: DOUBLE
107921: LD_INT 1
107923: DEC
107924: ST_TO_ADDR
107925: LD_VAR 0 2
107929: PUSH
107930: FOR_TO
107931: IFFALSE 108030
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
107933: LD_VAR 0 3
107937: PUSH
107938: LD_VAR 0 1
107942: ARRAY
107943: PPUSH
107944: LD_VAR 0 1
107948: PUSH
107949: LD_INT 4
107951: MOD
107952: PUSH
107953: LD_INT 1
107955: PLUS
107956: PPUSH
107957: CALL_OW 259
107961: PUSH
107962: LD_INT 10
107964: LESS
107965: IFFALSE 108028
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107967: LD_VAR 0 3
107971: PUSH
107972: LD_VAR 0 1
107976: ARRAY
107977: PPUSH
107978: LD_VAR 0 1
107982: PUSH
107983: LD_INT 4
107985: MOD
107986: PUSH
107987: LD_INT 1
107989: PLUS
107990: PPUSH
107991: LD_VAR 0 3
107995: PUSH
107996: LD_VAR 0 1
108000: ARRAY
108001: PPUSH
108002: LD_VAR 0 1
108006: PUSH
108007: LD_INT 4
108009: MOD
108010: PUSH
108011: LD_INT 1
108013: PLUS
108014: PPUSH
108015: CALL_OW 259
108019: PUSH
108020: LD_INT 1
108022: PLUS
108023: PPUSH
108024: CALL_OW 237
108028: GO 107930
108030: POP
108031: POP
// end ;
108032: PPOPN 3
108034: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
108035: LD_EXP 156
108039: PUSH
108040: LD_EXP 164
108044: AND
108045: IFFALSE 108065
108047: GO 108049
108049: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
108050: LD_INT 4
108052: PPUSH
108053: LD_OWVAR 2
108057: PPUSH
108058: LD_INT 0
108060: PPUSH
108061: CALL_OW 324
108065: END
// every 0 0$1 trigger StreamModeActive and sShovel do
108066: LD_EXP 156
108070: PUSH
108071: LD_EXP 193
108075: AND
108076: IFFALSE 108096
108078: GO 108080
108080: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
108081: LD_INT 19
108083: PPUSH
108084: LD_OWVAR 2
108088: PPUSH
108089: LD_INT 0
108091: PPUSH
108092: CALL_OW 324
108096: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
108097: LD_EXP 156
108101: PUSH
108102: LD_EXP 165
108106: AND
108107: IFFALSE 108209
108109: GO 108111
108111: DISABLE
108112: LD_INT 0
108114: PPUSH
108115: PPUSH
// begin enable ;
108116: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
108117: LD_ADDR_VAR 0 2
108121: PUSH
108122: LD_INT 22
108124: PUSH
108125: LD_OWVAR 2
108129: PUSH
108130: EMPTY
108131: LIST
108132: LIST
108133: PUSH
108134: LD_INT 2
108136: PUSH
108137: LD_INT 34
108139: PUSH
108140: LD_INT 11
108142: PUSH
108143: EMPTY
108144: LIST
108145: LIST
108146: PUSH
108147: LD_INT 34
108149: PUSH
108150: LD_INT 30
108152: PUSH
108153: EMPTY
108154: LIST
108155: LIST
108156: PUSH
108157: EMPTY
108158: LIST
108159: LIST
108160: LIST
108161: PUSH
108162: EMPTY
108163: LIST
108164: LIST
108165: PPUSH
108166: CALL_OW 69
108170: ST_TO_ADDR
// if not tmp then
108171: LD_VAR 0 2
108175: NOT
108176: IFFALSE 108180
// exit ;
108178: GO 108209
// for i in tmp do
108180: LD_ADDR_VAR 0 1
108184: PUSH
108185: LD_VAR 0 2
108189: PUSH
108190: FOR_IN
108191: IFFALSE 108207
// begin SetLives ( i , 0 ) ;
108193: LD_VAR 0 1
108197: PPUSH
108198: LD_INT 0
108200: PPUSH
108201: CALL_OW 234
// end ;
108205: GO 108190
108207: POP
108208: POP
// end ;
108209: PPOPN 2
108211: END
// every 0 0$1 trigger StreamModeActive and sBunker do
108212: LD_EXP 156
108216: PUSH
108217: LD_EXP 166
108221: AND
108222: IFFALSE 108242
108224: GO 108226
108226: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
108227: LD_INT 32
108229: PPUSH
108230: LD_OWVAR 2
108234: PPUSH
108235: LD_INT 0
108237: PPUSH
108238: CALL_OW 324
108242: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
108243: LD_EXP 156
108247: PUSH
108248: LD_EXP 167
108252: AND
108253: IFFALSE 108434
108255: GO 108257
108257: DISABLE
108258: LD_INT 0
108260: PPUSH
108261: PPUSH
108262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
108263: LD_ADDR_VAR 0 2
108267: PUSH
108268: LD_INT 22
108270: PUSH
108271: LD_OWVAR 2
108275: PUSH
108276: EMPTY
108277: LIST
108278: LIST
108279: PUSH
108280: LD_INT 33
108282: PUSH
108283: LD_INT 3
108285: PUSH
108286: EMPTY
108287: LIST
108288: LIST
108289: PUSH
108290: EMPTY
108291: LIST
108292: LIST
108293: PPUSH
108294: CALL_OW 69
108298: ST_TO_ADDR
// if not tmp then
108299: LD_VAR 0 2
108303: NOT
108304: IFFALSE 108308
// exit ;
108306: GO 108434
// side := 0 ;
108308: LD_ADDR_VAR 0 3
108312: PUSH
108313: LD_INT 0
108315: ST_TO_ADDR
// for i := 1 to 8 do
108316: LD_ADDR_VAR 0 1
108320: PUSH
108321: DOUBLE
108322: LD_INT 1
108324: DEC
108325: ST_TO_ADDR
108326: LD_INT 8
108328: PUSH
108329: FOR_TO
108330: IFFALSE 108378
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
108332: LD_OWVAR 2
108336: PUSH
108337: LD_VAR 0 1
108341: NONEQUAL
108342: PUSH
108343: LD_OWVAR 2
108347: PPUSH
108348: LD_VAR 0 1
108352: PPUSH
108353: CALL_OW 81
108357: PUSH
108358: LD_INT 2
108360: EQUAL
108361: AND
108362: IFFALSE 108376
// begin side := i ;
108364: LD_ADDR_VAR 0 3
108368: PUSH
108369: LD_VAR 0 1
108373: ST_TO_ADDR
// break ;
108374: GO 108378
// end ;
108376: GO 108329
108378: POP
108379: POP
// if not side then
108380: LD_VAR 0 3
108384: NOT
108385: IFFALSE 108389
// exit ;
108387: GO 108434
// for i := 1 to tmp do
108389: LD_ADDR_VAR 0 1
108393: PUSH
108394: DOUBLE
108395: LD_INT 1
108397: DEC
108398: ST_TO_ADDR
108399: LD_VAR 0 2
108403: PUSH
108404: FOR_TO
108405: IFFALSE 108432
// if Prob ( 60 ) then
108407: LD_INT 60
108409: PPUSH
108410: CALL_OW 13
108414: IFFALSE 108430
// SetSide ( i , side ) ;
108416: LD_VAR 0 1
108420: PPUSH
108421: LD_VAR 0 3
108425: PPUSH
108426: CALL_OW 235
108430: GO 108404
108432: POP
108433: POP
// end ;
108434: PPOPN 3
108436: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
108437: LD_EXP 156
108441: PUSH
108442: LD_EXP 169
108446: AND
108447: IFFALSE 108566
108449: GO 108451
108451: DISABLE
108452: LD_INT 0
108454: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
108455: LD_ADDR_VAR 0 1
108459: PUSH
108460: LD_INT 22
108462: PUSH
108463: LD_OWVAR 2
108467: PUSH
108468: EMPTY
108469: LIST
108470: LIST
108471: PUSH
108472: LD_INT 21
108474: PUSH
108475: LD_INT 1
108477: PUSH
108478: EMPTY
108479: LIST
108480: LIST
108481: PUSH
108482: LD_INT 3
108484: PUSH
108485: LD_INT 23
108487: PUSH
108488: LD_INT 0
108490: PUSH
108491: EMPTY
108492: LIST
108493: LIST
108494: PUSH
108495: EMPTY
108496: LIST
108497: LIST
108498: PUSH
108499: EMPTY
108500: LIST
108501: LIST
108502: LIST
108503: PPUSH
108504: CALL_OW 69
108508: PUSH
108509: FOR_IN
108510: IFFALSE 108564
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
108512: LD_VAR 0 1
108516: PPUSH
108517: CALL_OW 257
108521: PUSH
108522: LD_INT 1
108524: PUSH
108525: LD_INT 2
108527: PUSH
108528: LD_INT 3
108530: PUSH
108531: LD_INT 4
108533: PUSH
108534: EMPTY
108535: LIST
108536: LIST
108537: LIST
108538: LIST
108539: IN
108540: IFFALSE 108562
// SetClass ( un , rand ( 1 , 4 ) ) ;
108542: LD_VAR 0 1
108546: PPUSH
108547: LD_INT 1
108549: PPUSH
108550: LD_INT 4
108552: PPUSH
108553: CALL_OW 12
108557: PPUSH
108558: CALL_OW 336
108562: GO 108509
108564: POP
108565: POP
// end ;
108566: PPOPN 1
108568: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
108569: LD_EXP 156
108573: PUSH
108574: LD_EXP 168
108578: AND
108579: IFFALSE 108658
108581: GO 108583
108583: DISABLE
108584: LD_INT 0
108586: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108587: LD_ADDR_VAR 0 1
108591: PUSH
108592: LD_INT 22
108594: PUSH
108595: LD_OWVAR 2
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: PUSH
108604: LD_INT 21
108606: PUSH
108607: LD_INT 3
108609: PUSH
108610: EMPTY
108611: LIST
108612: LIST
108613: PUSH
108614: EMPTY
108615: LIST
108616: LIST
108617: PPUSH
108618: CALL_OW 69
108622: ST_TO_ADDR
// if not tmp then
108623: LD_VAR 0 1
108627: NOT
108628: IFFALSE 108632
// exit ;
108630: GO 108658
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
108632: LD_VAR 0 1
108636: PUSH
108637: LD_INT 1
108639: PPUSH
108640: LD_VAR 0 1
108644: PPUSH
108645: CALL_OW 12
108649: ARRAY
108650: PPUSH
108651: LD_INT 100
108653: PPUSH
108654: CALL_OW 234
// end ;
108658: PPOPN 1
108660: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
108661: LD_EXP 156
108665: PUSH
108666: LD_EXP 170
108670: AND
108671: IFFALSE 108769
108673: GO 108675
108675: DISABLE
108676: LD_INT 0
108678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108679: LD_ADDR_VAR 0 1
108683: PUSH
108684: LD_INT 22
108686: PUSH
108687: LD_OWVAR 2
108691: PUSH
108692: EMPTY
108693: LIST
108694: LIST
108695: PUSH
108696: LD_INT 21
108698: PUSH
108699: LD_INT 1
108701: PUSH
108702: EMPTY
108703: LIST
108704: LIST
108705: PUSH
108706: EMPTY
108707: LIST
108708: LIST
108709: PPUSH
108710: CALL_OW 69
108714: ST_TO_ADDR
// if not tmp then
108715: LD_VAR 0 1
108719: NOT
108720: IFFALSE 108724
// exit ;
108722: GO 108769
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
108724: LD_VAR 0 1
108728: PUSH
108729: LD_INT 1
108731: PPUSH
108732: LD_VAR 0 1
108736: PPUSH
108737: CALL_OW 12
108741: ARRAY
108742: PPUSH
108743: LD_INT 1
108745: PPUSH
108746: LD_INT 4
108748: PPUSH
108749: CALL_OW 12
108753: PPUSH
108754: LD_INT 3000
108756: PPUSH
108757: LD_INT 9000
108759: PPUSH
108760: CALL_OW 12
108764: PPUSH
108765: CALL_OW 492
// end ;
108769: PPOPN 1
108771: END
// every 0 0$1 trigger StreamModeActive and sDepot do
108772: LD_EXP 156
108776: PUSH
108777: LD_EXP 171
108781: AND
108782: IFFALSE 108802
108784: GO 108786
108786: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
108787: LD_INT 1
108789: PPUSH
108790: LD_OWVAR 2
108794: PPUSH
108795: LD_INT 0
108797: PPUSH
108798: CALL_OW 324
108802: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
108803: LD_EXP 156
108807: PUSH
108808: LD_EXP 172
108812: AND
108813: IFFALSE 108896
108815: GO 108817
108817: DISABLE
108818: LD_INT 0
108820: PPUSH
108821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108822: LD_ADDR_VAR 0 2
108826: PUSH
108827: LD_INT 22
108829: PUSH
108830: LD_OWVAR 2
108834: PUSH
108835: EMPTY
108836: LIST
108837: LIST
108838: PUSH
108839: LD_INT 21
108841: PUSH
108842: LD_INT 3
108844: PUSH
108845: EMPTY
108846: LIST
108847: LIST
108848: PUSH
108849: EMPTY
108850: LIST
108851: LIST
108852: PPUSH
108853: CALL_OW 69
108857: ST_TO_ADDR
// if not tmp then
108858: LD_VAR 0 2
108862: NOT
108863: IFFALSE 108867
// exit ;
108865: GO 108896
// for i in tmp do
108867: LD_ADDR_VAR 0 1
108871: PUSH
108872: LD_VAR 0 2
108876: PUSH
108877: FOR_IN
108878: IFFALSE 108894
// SetBLevel ( i , 10 ) ;
108880: LD_VAR 0 1
108884: PPUSH
108885: LD_INT 10
108887: PPUSH
108888: CALL_OW 241
108892: GO 108877
108894: POP
108895: POP
// end ;
108896: PPOPN 2
108898: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
108899: LD_EXP 156
108903: PUSH
108904: LD_EXP 173
108908: AND
108909: IFFALSE 109020
108911: GO 108913
108913: DISABLE
108914: LD_INT 0
108916: PPUSH
108917: PPUSH
108918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108919: LD_ADDR_VAR 0 3
108923: PUSH
108924: LD_INT 22
108926: PUSH
108927: LD_OWVAR 2
108931: PUSH
108932: EMPTY
108933: LIST
108934: LIST
108935: PUSH
108936: LD_INT 25
108938: PUSH
108939: LD_INT 1
108941: PUSH
108942: EMPTY
108943: LIST
108944: LIST
108945: PUSH
108946: EMPTY
108947: LIST
108948: LIST
108949: PPUSH
108950: CALL_OW 69
108954: ST_TO_ADDR
// if not tmp then
108955: LD_VAR 0 3
108959: NOT
108960: IFFALSE 108964
// exit ;
108962: GO 109020
// un := tmp [ rand ( 1 , tmp ) ] ;
108964: LD_ADDR_VAR 0 2
108968: PUSH
108969: LD_VAR 0 3
108973: PUSH
108974: LD_INT 1
108976: PPUSH
108977: LD_VAR 0 3
108981: PPUSH
108982: CALL_OW 12
108986: ARRAY
108987: ST_TO_ADDR
// if Crawls ( un ) then
108988: LD_VAR 0 2
108992: PPUSH
108993: CALL_OW 318
108997: IFFALSE 109008
// ComWalk ( un ) ;
108999: LD_VAR 0 2
109003: PPUSH
109004: CALL_OW 138
// SetClass ( un , class_sniper ) ;
109008: LD_VAR 0 2
109012: PPUSH
109013: LD_INT 5
109015: PPUSH
109016: CALL_OW 336
// end ;
109020: PPOPN 3
109022: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
109023: LD_EXP 156
109027: PUSH
109028: LD_EXP 174
109032: AND
109033: PUSH
109034: LD_OWVAR 67
109038: PUSH
109039: LD_INT 3
109041: LESS
109042: AND
109043: IFFALSE 109062
109045: GO 109047
109047: DISABLE
// Difficulty := Difficulty + 1 ;
109048: LD_ADDR_OWVAR 67
109052: PUSH
109053: LD_OWVAR 67
109057: PUSH
109058: LD_INT 1
109060: PLUS
109061: ST_TO_ADDR
109062: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
109063: LD_EXP 156
109067: PUSH
109068: LD_EXP 175
109072: AND
109073: IFFALSE 109176
109075: GO 109077
109077: DISABLE
109078: LD_INT 0
109080: PPUSH
// begin for i := 1 to 5 do
109081: LD_ADDR_VAR 0 1
109085: PUSH
109086: DOUBLE
109087: LD_INT 1
109089: DEC
109090: ST_TO_ADDR
109091: LD_INT 5
109093: PUSH
109094: FOR_TO
109095: IFFALSE 109174
// begin uc_nation := nation_nature ;
109097: LD_ADDR_OWVAR 21
109101: PUSH
109102: LD_INT 0
109104: ST_TO_ADDR
// uc_side := 0 ;
109105: LD_ADDR_OWVAR 20
109109: PUSH
109110: LD_INT 0
109112: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109113: LD_ADDR_OWVAR 29
109117: PUSH
109118: LD_INT 12
109120: PUSH
109121: LD_INT 12
109123: PUSH
109124: EMPTY
109125: LIST
109126: LIST
109127: ST_TO_ADDR
// hc_agressivity := 20 ;
109128: LD_ADDR_OWVAR 35
109132: PUSH
109133: LD_INT 20
109135: ST_TO_ADDR
// hc_class := class_tiger ;
109136: LD_ADDR_OWVAR 28
109140: PUSH
109141: LD_INT 14
109143: ST_TO_ADDR
// hc_gallery :=  ;
109144: LD_ADDR_OWVAR 33
109148: PUSH
109149: LD_STRING 
109151: ST_TO_ADDR
// hc_name :=  ;
109152: LD_ADDR_OWVAR 26
109156: PUSH
109157: LD_STRING 
109159: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
109160: CALL_OW 44
109164: PPUSH
109165: LD_INT 0
109167: PPUSH
109168: CALL_OW 51
// end ;
109172: GO 109094
109174: POP
109175: POP
// end ;
109176: PPOPN 1
109178: END
// every 0 0$1 trigger StreamModeActive and sBomb do
109179: LD_EXP 156
109183: PUSH
109184: LD_EXP 176
109188: AND
109189: IFFALSE 109198
109191: GO 109193
109193: DISABLE
// StreamSibBomb ;
109194: CALL 109199 0 0
109198: END
// export function StreamSibBomb ; var i , x , y ; begin
109199: LD_INT 0
109201: PPUSH
109202: PPUSH
109203: PPUSH
109204: PPUSH
// result := false ;
109205: LD_ADDR_VAR 0 1
109209: PUSH
109210: LD_INT 0
109212: ST_TO_ADDR
// for i := 1 to 16 do
109213: LD_ADDR_VAR 0 2
109217: PUSH
109218: DOUBLE
109219: LD_INT 1
109221: DEC
109222: ST_TO_ADDR
109223: LD_INT 16
109225: PUSH
109226: FOR_TO
109227: IFFALSE 109426
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109229: LD_ADDR_VAR 0 3
109233: PUSH
109234: LD_INT 10
109236: PUSH
109237: LD_INT 20
109239: PUSH
109240: LD_INT 30
109242: PUSH
109243: LD_INT 40
109245: PUSH
109246: LD_INT 50
109248: PUSH
109249: LD_INT 60
109251: PUSH
109252: LD_INT 70
109254: PUSH
109255: LD_INT 80
109257: PUSH
109258: LD_INT 90
109260: PUSH
109261: LD_INT 100
109263: PUSH
109264: LD_INT 110
109266: PUSH
109267: LD_INT 120
109269: PUSH
109270: LD_INT 130
109272: PUSH
109273: LD_INT 140
109275: PUSH
109276: LD_INT 150
109278: PUSH
109279: EMPTY
109280: LIST
109281: LIST
109282: LIST
109283: LIST
109284: LIST
109285: LIST
109286: LIST
109287: LIST
109288: LIST
109289: LIST
109290: LIST
109291: LIST
109292: LIST
109293: LIST
109294: LIST
109295: PUSH
109296: LD_INT 1
109298: PPUSH
109299: LD_INT 15
109301: PPUSH
109302: CALL_OW 12
109306: ARRAY
109307: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109308: LD_ADDR_VAR 0 4
109312: PUSH
109313: LD_INT 10
109315: PUSH
109316: LD_INT 20
109318: PUSH
109319: LD_INT 30
109321: PUSH
109322: LD_INT 40
109324: PUSH
109325: LD_INT 50
109327: PUSH
109328: LD_INT 60
109330: PUSH
109331: LD_INT 70
109333: PUSH
109334: LD_INT 80
109336: PUSH
109337: LD_INT 90
109339: PUSH
109340: LD_INT 100
109342: PUSH
109343: LD_INT 110
109345: PUSH
109346: LD_INT 120
109348: PUSH
109349: LD_INT 130
109351: PUSH
109352: LD_INT 140
109354: PUSH
109355: LD_INT 150
109357: PUSH
109358: EMPTY
109359: LIST
109360: LIST
109361: LIST
109362: LIST
109363: LIST
109364: LIST
109365: LIST
109366: LIST
109367: LIST
109368: LIST
109369: LIST
109370: LIST
109371: LIST
109372: LIST
109373: LIST
109374: PUSH
109375: LD_INT 1
109377: PPUSH
109378: LD_INT 15
109380: PPUSH
109381: CALL_OW 12
109385: ARRAY
109386: ST_TO_ADDR
// if ValidHex ( x , y ) then
109387: LD_VAR 0 3
109391: PPUSH
109392: LD_VAR 0 4
109396: PPUSH
109397: CALL_OW 488
109401: IFFALSE 109424
// begin result := [ x , y ] ;
109403: LD_ADDR_VAR 0 1
109407: PUSH
109408: LD_VAR 0 3
109412: PUSH
109413: LD_VAR 0 4
109417: PUSH
109418: EMPTY
109419: LIST
109420: LIST
109421: ST_TO_ADDR
// break ;
109422: GO 109426
// end ; end ;
109424: GO 109226
109426: POP
109427: POP
// if result then
109428: LD_VAR 0 1
109432: IFFALSE 109492
// begin ToLua ( playSibBomb() ) ;
109434: LD_STRING playSibBomb()
109436: PPUSH
109437: CALL_OW 559
// wait ( 0 0$14 ) ;
109441: LD_INT 490
109443: PPUSH
109444: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
109448: LD_VAR 0 1
109452: PUSH
109453: LD_INT 1
109455: ARRAY
109456: PPUSH
109457: LD_VAR 0 1
109461: PUSH
109462: LD_INT 2
109464: ARRAY
109465: PPUSH
109466: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
109470: LD_VAR 0 1
109474: PUSH
109475: LD_INT 1
109477: ARRAY
109478: PPUSH
109479: LD_VAR 0 1
109483: PUSH
109484: LD_INT 2
109486: ARRAY
109487: PPUSH
109488: CALL_OW 429
// end ; end ;
109492: LD_VAR 0 1
109496: RET
// every 0 0$1 trigger StreamModeActive and sReset do
109497: LD_EXP 156
109501: PUSH
109502: LD_EXP 178
109506: AND
109507: IFFALSE 109519
109509: GO 109511
109511: DISABLE
// YouLost (  ) ;
109512: LD_STRING 
109514: PPUSH
109515: CALL_OW 104
109519: END
// every 0 0$1 trigger StreamModeActive and sFog do
109520: LD_EXP 156
109524: PUSH
109525: LD_EXP 177
109529: AND
109530: IFFALSE 109544
109532: GO 109534
109534: DISABLE
// FogOff ( your_side ) ;
109535: LD_OWVAR 2
109539: PPUSH
109540: CALL_OW 344
109544: END
// every 0 0$1 trigger StreamModeActive and sSun do
109545: LD_EXP 156
109549: PUSH
109550: LD_EXP 179
109554: AND
109555: IFFALSE 109583
109557: GO 109559
109559: DISABLE
// begin solar_recharge_percent := 0 ;
109560: LD_ADDR_OWVAR 79
109564: PUSH
109565: LD_INT 0
109567: ST_TO_ADDR
// wait ( 5 5$00 ) ;
109568: LD_INT 10500
109570: PPUSH
109571: CALL_OW 67
// solar_recharge_percent := 100 ;
109575: LD_ADDR_OWVAR 79
109579: PUSH
109580: LD_INT 100
109582: ST_TO_ADDR
// end ;
109583: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
109584: LD_EXP 156
109588: PUSH
109589: LD_EXP 180
109593: AND
109594: IFFALSE 109833
109596: GO 109598
109598: DISABLE
109599: LD_INT 0
109601: PPUSH
109602: PPUSH
109603: PPUSH
// begin tmp := [ ] ;
109604: LD_ADDR_VAR 0 3
109608: PUSH
109609: EMPTY
109610: ST_TO_ADDR
// for i := 1 to 6 do
109611: LD_ADDR_VAR 0 1
109615: PUSH
109616: DOUBLE
109617: LD_INT 1
109619: DEC
109620: ST_TO_ADDR
109621: LD_INT 6
109623: PUSH
109624: FOR_TO
109625: IFFALSE 109730
// begin uc_nation := nation_nature ;
109627: LD_ADDR_OWVAR 21
109631: PUSH
109632: LD_INT 0
109634: ST_TO_ADDR
// uc_side := 0 ;
109635: LD_ADDR_OWVAR 20
109639: PUSH
109640: LD_INT 0
109642: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109643: LD_ADDR_OWVAR 29
109647: PUSH
109648: LD_INT 12
109650: PUSH
109651: LD_INT 12
109653: PUSH
109654: EMPTY
109655: LIST
109656: LIST
109657: ST_TO_ADDR
// hc_agressivity := 20 ;
109658: LD_ADDR_OWVAR 35
109662: PUSH
109663: LD_INT 20
109665: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
109666: LD_ADDR_OWVAR 28
109670: PUSH
109671: LD_INT 17
109673: ST_TO_ADDR
// hc_gallery :=  ;
109674: LD_ADDR_OWVAR 33
109678: PUSH
109679: LD_STRING 
109681: ST_TO_ADDR
// hc_name :=  ;
109682: LD_ADDR_OWVAR 26
109686: PUSH
109687: LD_STRING 
109689: ST_TO_ADDR
// un := CreateHuman ;
109690: LD_ADDR_VAR 0 2
109694: PUSH
109695: CALL_OW 44
109699: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
109700: LD_VAR 0 2
109704: PPUSH
109705: LD_INT 1
109707: PPUSH
109708: CALL_OW 51
// tmp := tmp ^ un ;
109712: LD_ADDR_VAR 0 3
109716: PUSH
109717: LD_VAR 0 3
109721: PUSH
109722: LD_VAR 0 2
109726: ADD
109727: ST_TO_ADDR
// end ;
109728: GO 109624
109730: POP
109731: POP
// repeat wait ( 0 0$1 ) ;
109732: LD_INT 35
109734: PPUSH
109735: CALL_OW 67
// for un in tmp do
109739: LD_ADDR_VAR 0 2
109743: PUSH
109744: LD_VAR 0 3
109748: PUSH
109749: FOR_IN
109750: IFFALSE 109824
// begin if IsDead ( un ) then
109752: LD_VAR 0 2
109756: PPUSH
109757: CALL_OW 301
109761: IFFALSE 109781
// begin tmp := tmp diff un ;
109763: LD_ADDR_VAR 0 3
109767: PUSH
109768: LD_VAR 0 3
109772: PUSH
109773: LD_VAR 0 2
109777: DIFF
109778: ST_TO_ADDR
// continue ;
109779: GO 109749
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
109781: LD_VAR 0 2
109785: PPUSH
109786: LD_INT 3
109788: PUSH
109789: LD_INT 22
109791: PUSH
109792: LD_INT 0
109794: PUSH
109795: EMPTY
109796: LIST
109797: LIST
109798: PUSH
109799: EMPTY
109800: LIST
109801: LIST
109802: PPUSH
109803: CALL_OW 69
109807: PPUSH
109808: LD_VAR 0 2
109812: PPUSH
109813: CALL_OW 74
109817: PPUSH
109818: CALL_OW 115
// end ;
109822: GO 109749
109824: POP
109825: POP
// until not tmp ;
109826: LD_VAR 0 3
109830: NOT
109831: IFFALSE 109732
// end ;
109833: PPOPN 3
109835: END
// every 0 0$1 trigger StreamModeActive and sTroll do
109836: LD_EXP 156
109840: PUSH
109841: LD_EXP 181
109845: AND
109846: IFFALSE 109900
109848: GO 109850
109850: DISABLE
// begin ToLua ( displayTroll(); ) ;
109851: LD_STRING displayTroll();
109853: PPUSH
109854: CALL_OW 559
// wait ( 3 3$00 ) ;
109858: LD_INT 6300
109860: PPUSH
109861: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109865: LD_STRING hideTroll();
109867: PPUSH
109868: CALL_OW 559
// wait ( 1 1$00 ) ;
109872: LD_INT 2100
109874: PPUSH
109875: CALL_OW 67
// ToLua ( displayTroll(); ) ;
109879: LD_STRING displayTroll();
109881: PPUSH
109882: CALL_OW 559
// wait ( 1 1$00 ) ;
109886: LD_INT 2100
109888: PPUSH
109889: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109893: LD_STRING hideTroll();
109895: PPUSH
109896: CALL_OW 559
// end ;
109900: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
109901: LD_EXP 156
109905: PUSH
109906: LD_EXP 182
109910: AND
109911: IFFALSE 109974
109913: GO 109915
109915: DISABLE
109916: LD_INT 0
109918: PPUSH
// begin p := 0 ;
109919: LD_ADDR_VAR 0 1
109923: PUSH
109924: LD_INT 0
109926: ST_TO_ADDR
// repeat game_speed := 1 ;
109927: LD_ADDR_OWVAR 65
109931: PUSH
109932: LD_INT 1
109934: ST_TO_ADDR
// wait ( 0 0$1 ) ;
109935: LD_INT 35
109937: PPUSH
109938: CALL_OW 67
// p := p + 1 ;
109942: LD_ADDR_VAR 0 1
109946: PUSH
109947: LD_VAR 0 1
109951: PUSH
109952: LD_INT 1
109954: PLUS
109955: ST_TO_ADDR
// until p >= 60 ;
109956: LD_VAR 0 1
109960: PUSH
109961: LD_INT 60
109963: GREATEREQUAL
109964: IFFALSE 109927
// game_speed := 4 ;
109966: LD_ADDR_OWVAR 65
109970: PUSH
109971: LD_INT 4
109973: ST_TO_ADDR
// end ;
109974: PPOPN 1
109976: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109977: LD_EXP 156
109981: PUSH
109982: LD_EXP 183
109986: AND
109987: IFFALSE 110133
109989: GO 109991
109991: DISABLE
109992: LD_INT 0
109994: PPUSH
109995: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109996: LD_ADDR_VAR 0 1
110000: PUSH
110001: LD_INT 22
110003: PUSH
110004: LD_OWVAR 2
110008: PUSH
110009: EMPTY
110010: LIST
110011: LIST
110012: PUSH
110013: LD_INT 2
110015: PUSH
110016: LD_INT 30
110018: PUSH
110019: LD_INT 0
110021: PUSH
110022: EMPTY
110023: LIST
110024: LIST
110025: PUSH
110026: LD_INT 30
110028: PUSH
110029: LD_INT 1
110031: PUSH
110032: EMPTY
110033: LIST
110034: LIST
110035: PUSH
110036: EMPTY
110037: LIST
110038: LIST
110039: LIST
110040: PUSH
110041: EMPTY
110042: LIST
110043: LIST
110044: PPUSH
110045: CALL_OW 69
110049: ST_TO_ADDR
// if not depot then
110050: LD_VAR 0 1
110054: NOT
110055: IFFALSE 110059
// exit ;
110057: GO 110133
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
110059: LD_ADDR_VAR 0 2
110063: PUSH
110064: LD_VAR 0 1
110068: PUSH
110069: LD_INT 1
110071: PPUSH
110072: LD_VAR 0 1
110076: PPUSH
110077: CALL_OW 12
110081: ARRAY
110082: PPUSH
110083: CALL_OW 274
110087: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
110088: LD_VAR 0 2
110092: PPUSH
110093: LD_INT 1
110095: PPUSH
110096: LD_INT 0
110098: PPUSH
110099: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
110103: LD_VAR 0 2
110107: PPUSH
110108: LD_INT 2
110110: PPUSH
110111: LD_INT 0
110113: PPUSH
110114: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
110118: LD_VAR 0 2
110122: PPUSH
110123: LD_INT 3
110125: PPUSH
110126: LD_INT 0
110128: PPUSH
110129: CALL_OW 277
// end ;
110133: PPOPN 2
110135: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
110136: LD_EXP 156
110140: PUSH
110141: LD_EXP 184
110145: AND
110146: IFFALSE 110243
110148: GO 110150
110150: DISABLE
110151: LD_INT 0
110153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110154: LD_ADDR_VAR 0 1
110158: PUSH
110159: LD_INT 22
110161: PUSH
110162: LD_OWVAR 2
110166: PUSH
110167: EMPTY
110168: LIST
110169: LIST
110170: PUSH
110171: LD_INT 21
110173: PUSH
110174: LD_INT 1
110176: PUSH
110177: EMPTY
110178: LIST
110179: LIST
110180: PUSH
110181: LD_INT 3
110183: PUSH
110184: LD_INT 23
110186: PUSH
110187: LD_INT 0
110189: PUSH
110190: EMPTY
110191: LIST
110192: LIST
110193: PUSH
110194: EMPTY
110195: LIST
110196: LIST
110197: PUSH
110198: EMPTY
110199: LIST
110200: LIST
110201: LIST
110202: PPUSH
110203: CALL_OW 69
110207: ST_TO_ADDR
// if not tmp then
110208: LD_VAR 0 1
110212: NOT
110213: IFFALSE 110217
// exit ;
110215: GO 110243
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
110217: LD_VAR 0 1
110221: PUSH
110222: LD_INT 1
110224: PPUSH
110225: LD_VAR 0 1
110229: PPUSH
110230: CALL_OW 12
110234: ARRAY
110235: PPUSH
110236: LD_INT 200
110238: PPUSH
110239: CALL_OW 234
// end ;
110243: PPOPN 1
110245: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
110246: LD_EXP 156
110250: PUSH
110251: LD_EXP 185
110255: AND
110256: IFFALSE 110335
110258: GO 110260
110260: DISABLE
110261: LD_INT 0
110263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
110264: LD_ADDR_VAR 0 1
110268: PUSH
110269: LD_INT 22
110271: PUSH
110272: LD_OWVAR 2
110276: PUSH
110277: EMPTY
110278: LIST
110279: LIST
110280: PUSH
110281: LD_INT 21
110283: PUSH
110284: LD_INT 2
110286: PUSH
110287: EMPTY
110288: LIST
110289: LIST
110290: PUSH
110291: EMPTY
110292: LIST
110293: LIST
110294: PPUSH
110295: CALL_OW 69
110299: ST_TO_ADDR
// if not tmp then
110300: LD_VAR 0 1
110304: NOT
110305: IFFALSE 110309
// exit ;
110307: GO 110335
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
110309: LD_VAR 0 1
110313: PUSH
110314: LD_INT 1
110316: PPUSH
110317: LD_VAR 0 1
110321: PPUSH
110322: CALL_OW 12
110326: ARRAY
110327: PPUSH
110328: LD_INT 60
110330: PPUSH
110331: CALL_OW 234
// end ;
110335: PPOPN 1
110337: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
110338: LD_EXP 156
110342: PUSH
110343: LD_EXP 186
110347: AND
110348: IFFALSE 110447
110350: GO 110352
110352: DISABLE
110353: LD_INT 0
110355: PPUSH
110356: PPUSH
// begin enable ;
110357: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
110358: LD_ADDR_VAR 0 1
110362: PUSH
110363: LD_INT 22
110365: PUSH
110366: LD_OWVAR 2
110370: PUSH
110371: EMPTY
110372: LIST
110373: LIST
110374: PUSH
110375: LD_INT 61
110377: PUSH
110378: EMPTY
110379: LIST
110380: PUSH
110381: LD_INT 33
110383: PUSH
110384: LD_INT 2
110386: PUSH
110387: EMPTY
110388: LIST
110389: LIST
110390: PUSH
110391: EMPTY
110392: LIST
110393: LIST
110394: LIST
110395: PPUSH
110396: CALL_OW 69
110400: ST_TO_ADDR
// if not tmp then
110401: LD_VAR 0 1
110405: NOT
110406: IFFALSE 110410
// exit ;
110408: GO 110447
// for i in tmp do
110410: LD_ADDR_VAR 0 2
110414: PUSH
110415: LD_VAR 0 1
110419: PUSH
110420: FOR_IN
110421: IFFALSE 110445
// if IsControledBy ( i ) then
110423: LD_VAR 0 2
110427: PPUSH
110428: CALL_OW 312
110432: IFFALSE 110443
// ComUnlink ( i ) ;
110434: LD_VAR 0 2
110438: PPUSH
110439: CALL_OW 136
110443: GO 110420
110445: POP
110446: POP
// end ;
110447: PPOPN 2
110449: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
110450: LD_EXP 156
110454: PUSH
110455: LD_EXP 187
110459: AND
110460: IFFALSE 110600
110462: GO 110464
110464: DISABLE
110465: LD_INT 0
110467: PPUSH
110468: PPUSH
// begin ToLua ( displayPowell(); ) ;
110469: LD_STRING displayPowell();
110471: PPUSH
110472: CALL_OW 559
// uc_side := 0 ;
110476: LD_ADDR_OWVAR 20
110480: PUSH
110481: LD_INT 0
110483: ST_TO_ADDR
// uc_nation := 2 ;
110484: LD_ADDR_OWVAR 21
110488: PUSH
110489: LD_INT 2
110491: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
110492: LD_ADDR_OWVAR 37
110496: PUSH
110497: LD_INT 14
110499: ST_TO_ADDR
// vc_engine := engine_siberite ;
110500: LD_ADDR_OWVAR 39
110504: PUSH
110505: LD_INT 3
110507: ST_TO_ADDR
// vc_control := control_apeman ;
110508: LD_ADDR_OWVAR 38
110512: PUSH
110513: LD_INT 5
110515: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
110516: LD_ADDR_OWVAR 40
110520: PUSH
110521: LD_INT 29
110523: ST_TO_ADDR
// un := CreateVehicle ;
110524: LD_ADDR_VAR 0 2
110528: PUSH
110529: CALL_OW 45
110533: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110534: LD_VAR 0 2
110538: PPUSH
110539: LD_INT 1
110541: PPUSH
110542: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110546: LD_INT 35
110548: PPUSH
110549: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110553: LD_VAR 0 2
110557: PPUSH
110558: LD_INT 22
110560: PUSH
110561: LD_OWVAR 2
110565: PUSH
110566: EMPTY
110567: LIST
110568: LIST
110569: PPUSH
110570: CALL_OW 69
110574: PPUSH
110575: LD_VAR 0 2
110579: PPUSH
110580: CALL_OW 74
110584: PPUSH
110585: CALL_OW 115
// until IsDead ( un ) ;
110589: LD_VAR 0 2
110593: PPUSH
110594: CALL_OW 301
110598: IFFALSE 110546
// end ;
110600: PPOPN 2
110602: END
// every 0 0$1 trigger StreamModeActive and sStu do
110603: LD_EXP 156
110607: PUSH
110608: LD_EXP 195
110612: AND
110613: IFFALSE 110629
110615: GO 110617
110617: DISABLE
// begin ToLua ( displayStucuk(); ) ;
110618: LD_STRING displayStucuk();
110620: PPUSH
110621: CALL_OW 559
// ResetFog ;
110625: CALL_OW 335
// end ;
110629: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
110630: LD_EXP 156
110634: PUSH
110635: LD_EXP 188
110639: AND
110640: IFFALSE 110781
110642: GO 110644
110644: DISABLE
110645: LD_INT 0
110647: PPUSH
110648: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110649: LD_ADDR_VAR 0 2
110653: PUSH
110654: LD_INT 22
110656: PUSH
110657: LD_OWVAR 2
110661: PUSH
110662: EMPTY
110663: LIST
110664: LIST
110665: PUSH
110666: LD_INT 21
110668: PUSH
110669: LD_INT 1
110671: PUSH
110672: EMPTY
110673: LIST
110674: LIST
110675: PUSH
110676: EMPTY
110677: LIST
110678: LIST
110679: PPUSH
110680: CALL_OW 69
110684: ST_TO_ADDR
// if not tmp then
110685: LD_VAR 0 2
110689: NOT
110690: IFFALSE 110694
// exit ;
110692: GO 110781
// un := tmp [ rand ( 1 , tmp ) ] ;
110694: LD_ADDR_VAR 0 1
110698: PUSH
110699: LD_VAR 0 2
110703: PUSH
110704: LD_INT 1
110706: PPUSH
110707: LD_VAR 0 2
110711: PPUSH
110712: CALL_OW 12
110716: ARRAY
110717: ST_TO_ADDR
// SetSide ( un , 0 ) ;
110718: LD_VAR 0 1
110722: PPUSH
110723: LD_INT 0
110725: PPUSH
110726: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
110730: LD_VAR 0 1
110734: PPUSH
110735: LD_OWVAR 3
110739: PUSH
110740: LD_VAR 0 1
110744: DIFF
110745: PPUSH
110746: LD_VAR 0 1
110750: PPUSH
110751: CALL_OW 74
110755: PPUSH
110756: CALL_OW 115
// wait ( 0 0$20 ) ;
110760: LD_INT 700
110762: PPUSH
110763: CALL_OW 67
// SetSide ( un , your_side ) ;
110767: LD_VAR 0 1
110771: PPUSH
110772: LD_OWVAR 2
110776: PPUSH
110777: CALL_OW 235
// end ;
110781: PPOPN 2
110783: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
110784: LD_EXP 156
110788: PUSH
110789: LD_EXP 189
110793: AND
110794: IFFALSE 110900
110796: GO 110798
110798: DISABLE
110799: LD_INT 0
110801: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110802: LD_ADDR_VAR 0 1
110806: PUSH
110807: LD_INT 22
110809: PUSH
110810: LD_OWVAR 2
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PUSH
110819: LD_INT 2
110821: PUSH
110822: LD_INT 30
110824: PUSH
110825: LD_INT 0
110827: PUSH
110828: EMPTY
110829: LIST
110830: LIST
110831: PUSH
110832: LD_INT 30
110834: PUSH
110835: LD_INT 1
110837: PUSH
110838: EMPTY
110839: LIST
110840: LIST
110841: PUSH
110842: EMPTY
110843: LIST
110844: LIST
110845: LIST
110846: PUSH
110847: EMPTY
110848: LIST
110849: LIST
110850: PPUSH
110851: CALL_OW 69
110855: ST_TO_ADDR
// if not depot then
110856: LD_VAR 0 1
110860: NOT
110861: IFFALSE 110865
// exit ;
110863: GO 110900
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
110865: LD_VAR 0 1
110869: PUSH
110870: LD_INT 1
110872: ARRAY
110873: PPUSH
110874: CALL_OW 250
110878: PPUSH
110879: LD_VAR 0 1
110883: PUSH
110884: LD_INT 1
110886: ARRAY
110887: PPUSH
110888: CALL_OW 251
110892: PPUSH
110893: LD_INT 70
110895: PPUSH
110896: CALL_OW 495
// end ;
110900: PPOPN 1
110902: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
110903: LD_EXP 156
110907: PUSH
110908: LD_EXP 190
110912: AND
110913: IFFALSE 111124
110915: GO 110917
110917: DISABLE
110918: LD_INT 0
110920: PPUSH
110921: PPUSH
110922: PPUSH
110923: PPUSH
110924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110925: LD_ADDR_VAR 0 5
110929: PUSH
110930: LD_INT 22
110932: PUSH
110933: LD_OWVAR 2
110937: PUSH
110938: EMPTY
110939: LIST
110940: LIST
110941: PUSH
110942: LD_INT 21
110944: PUSH
110945: LD_INT 1
110947: PUSH
110948: EMPTY
110949: LIST
110950: LIST
110951: PUSH
110952: EMPTY
110953: LIST
110954: LIST
110955: PPUSH
110956: CALL_OW 69
110960: ST_TO_ADDR
// if not tmp then
110961: LD_VAR 0 5
110965: NOT
110966: IFFALSE 110970
// exit ;
110968: GO 111124
// for i in tmp do
110970: LD_ADDR_VAR 0 1
110974: PUSH
110975: LD_VAR 0 5
110979: PUSH
110980: FOR_IN
110981: IFFALSE 111122
// begin d := rand ( 0 , 5 ) ;
110983: LD_ADDR_VAR 0 4
110987: PUSH
110988: LD_INT 0
110990: PPUSH
110991: LD_INT 5
110993: PPUSH
110994: CALL_OW 12
110998: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110999: LD_ADDR_VAR 0 2
111003: PUSH
111004: LD_VAR 0 1
111008: PPUSH
111009: CALL_OW 250
111013: PPUSH
111014: LD_VAR 0 4
111018: PPUSH
111019: LD_INT 3
111021: PPUSH
111022: LD_INT 12
111024: PPUSH
111025: CALL_OW 12
111029: PPUSH
111030: CALL_OW 272
111034: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
111035: LD_ADDR_VAR 0 3
111039: PUSH
111040: LD_VAR 0 1
111044: PPUSH
111045: CALL_OW 251
111049: PPUSH
111050: LD_VAR 0 4
111054: PPUSH
111055: LD_INT 3
111057: PPUSH
111058: LD_INT 12
111060: PPUSH
111061: CALL_OW 12
111065: PPUSH
111066: CALL_OW 273
111070: ST_TO_ADDR
// if ValidHex ( x , y ) then
111071: LD_VAR 0 2
111075: PPUSH
111076: LD_VAR 0 3
111080: PPUSH
111081: CALL_OW 488
111085: IFFALSE 111120
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
111087: LD_VAR 0 1
111091: PPUSH
111092: LD_VAR 0 2
111096: PPUSH
111097: LD_VAR 0 3
111101: PPUSH
111102: LD_INT 3
111104: PPUSH
111105: LD_INT 6
111107: PPUSH
111108: CALL_OW 12
111112: PPUSH
111113: LD_INT 1
111115: PPUSH
111116: CALL_OW 483
// end ;
111120: GO 110980
111122: POP
111123: POP
// end ;
111124: PPOPN 5
111126: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
111127: LD_EXP 156
111131: PUSH
111132: LD_EXP 191
111136: AND
111137: IFFALSE 111231
111139: GO 111141
111141: DISABLE
111142: LD_INT 0
111144: PPUSH
111145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
111146: LD_ADDR_VAR 0 2
111150: PUSH
111151: LD_INT 22
111153: PUSH
111154: LD_OWVAR 2
111158: PUSH
111159: EMPTY
111160: LIST
111161: LIST
111162: PUSH
111163: LD_INT 32
111165: PUSH
111166: LD_INT 1
111168: PUSH
111169: EMPTY
111170: LIST
111171: LIST
111172: PUSH
111173: LD_INT 21
111175: PUSH
111176: LD_INT 2
111178: PUSH
111179: EMPTY
111180: LIST
111181: LIST
111182: PUSH
111183: EMPTY
111184: LIST
111185: LIST
111186: LIST
111187: PPUSH
111188: CALL_OW 69
111192: ST_TO_ADDR
// if not tmp then
111193: LD_VAR 0 2
111197: NOT
111198: IFFALSE 111202
// exit ;
111200: GO 111231
// for i in tmp do
111202: LD_ADDR_VAR 0 1
111206: PUSH
111207: LD_VAR 0 2
111211: PUSH
111212: FOR_IN
111213: IFFALSE 111229
// SetFuel ( i , 0 ) ;
111215: LD_VAR 0 1
111219: PPUSH
111220: LD_INT 0
111222: PPUSH
111223: CALL_OW 240
111227: GO 111212
111229: POP
111230: POP
// end ;
111231: PPOPN 2
111233: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
111234: LD_EXP 156
111238: PUSH
111239: LD_EXP 192
111243: AND
111244: IFFALSE 111310
111246: GO 111248
111248: DISABLE
111249: LD_INT 0
111251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111252: LD_ADDR_VAR 0 1
111256: PUSH
111257: LD_INT 22
111259: PUSH
111260: LD_OWVAR 2
111264: PUSH
111265: EMPTY
111266: LIST
111267: LIST
111268: PUSH
111269: LD_INT 30
111271: PUSH
111272: LD_INT 29
111274: PUSH
111275: EMPTY
111276: LIST
111277: LIST
111278: PUSH
111279: EMPTY
111280: LIST
111281: LIST
111282: PPUSH
111283: CALL_OW 69
111287: ST_TO_ADDR
// if not tmp then
111288: LD_VAR 0 1
111292: NOT
111293: IFFALSE 111297
// exit ;
111295: GO 111310
// DestroyUnit ( tmp [ 1 ] ) ;
111297: LD_VAR 0 1
111301: PUSH
111302: LD_INT 1
111304: ARRAY
111305: PPUSH
111306: CALL_OW 65
// end ;
111310: PPOPN 1
111312: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
111313: LD_EXP 156
111317: PUSH
111318: LD_EXP 194
111322: AND
111323: IFFALSE 111452
111325: GO 111327
111327: DISABLE
111328: LD_INT 0
111330: PPUSH
// begin uc_side := 0 ;
111331: LD_ADDR_OWVAR 20
111335: PUSH
111336: LD_INT 0
111338: ST_TO_ADDR
// uc_nation := nation_arabian ;
111339: LD_ADDR_OWVAR 21
111343: PUSH
111344: LD_INT 2
111346: ST_TO_ADDR
// hc_gallery :=  ;
111347: LD_ADDR_OWVAR 33
111351: PUSH
111352: LD_STRING 
111354: ST_TO_ADDR
// hc_name :=  ;
111355: LD_ADDR_OWVAR 26
111359: PUSH
111360: LD_STRING 
111362: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
111363: LD_INT 1
111365: PPUSH
111366: LD_INT 11
111368: PPUSH
111369: LD_INT 10
111371: PPUSH
111372: CALL_OW 380
// un := CreateHuman ;
111376: LD_ADDR_VAR 0 1
111380: PUSH
111381: CALL_OW 44
111385: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111386: LD_VAR 0 1
111390: PPUSH
111391: LD_INT 1
111393: PPUSH
111394: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
111398: LD_INT 35
111400: PPUSH
111401: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
111405: LD_VAR 0 1
111409: PPUSH
111410: LD_INT 22
111412: PUSH
111413: LD_OWVAR 2
111417: PUSH
111418: EMPTY
111419: LIST
111420: LIST
111421: PPUSH
111422: CALL_OW 69
111426: PPUSH
111427: LD_VAR 0 1
111431: PPUSH
111432: CALL_OW 74
111436: PPUSH
111437: CALL_OW 115
// until IsDead ( un ) ;
111441: LD_VAR 0 1
111445: PPUSH
111446: CALL_OW 301
111450: IFFALSE 111398
// end ;
111452: PPOPN 1
111454: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
111455: LD_EXP 156
111459: PUSH
111460: LD_EXP 196
111464: AND
111465: IFFALSE 111477
111467: GO 111469
111469: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
111470: LD_STRING earthquake(getX(game), 0, 32)
111472: PPUSH
111473: CALL_OW 559
111477: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
111478: LD_EXP 156
111482: PUSH
111483: LD_EXP 197
111487: AND
111488: IFFALSE 111579
111490: GO 111492
111492: DISABLE
111493: LD_INT 0
111495: PPUSH
// begin enable ;
111496: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
111497: LD_ADDR_VAR 0 1
111501: PUSH
111502: LD_INT 22
111504: PUSH
111505: LD_OWVAR 2
111509: PUSH
111510: EMPTY
111511: LIST
111512: LIST
111513: PUSH
111514: LD_INT 21
111516: PUSH
111517: LD_INT 2
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PUSH
111524: LD_INT 33
111526: PUSH
111527: LD_INT 3
111529: PUSH
111530: EMPTY
111531: LIST
111532: LIST
111533: PUSH
111534: EMPTY
111535: LIST
111536: LIST
111537: LIST
111538: PPUSH
111539: CALL_OW 69
111543: ST_TO_ADDR
// if not tmp then
111544: LD_VAR 0 1
111548: NOT
111549: IFFALSE 111553
// exit ;
111551: GO 111579
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111553: LD_VAR 0 1
111557: PUSH
111558: LD_INT 1
111560: PPUSH
111561: LD_VAR 0 1
111565: PPUSH
111566: CALL_OW 12
111570: ARRAY
111571: PPUSH
111572: LD_INT 1
111574: PPUSH
111575: CALL_OW 234
// end ;
111579: PPOPN 1
111581: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
111582: LD_EXP 156
111586: PUSH
111587: LD_EXP 198
111591: AND
111592: IFFALSE 111733
111594: GO 111596
111596: DISABLE
111597: LD_INT 0
111599: PPUSH
111600: PPUSH
111601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111602: LD_ADDR_VAR 0 3
111606: PUSH
111607: LD_INT 22
111609: PUSH
111610: LD_OWVAR 2
111614: PUSH
111615: EMPTY
111616: LIST
111617: LIST
111618: PUSH
111619: LD_INT 25
111621: PUSH
111622: LD_INT 1
111624: PUSH
111625: EMPTY
111626: LIST
111627: LIST
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: PPUSH
111633: CALL_OW 69
111637: ST_TO_ADDR
// if not tmp then
111638: LD_VAR 0 3
111642: NOT
111643: IFFALSE 111647
// exit ;
111645: GO 111733
// un := tmp [ rand ( 1 , tmp ) ] ;
111647: LD_ADDR_VAR 0 2
111651: PUSH
111652: LD_VAR 0 3
111656: PUSH
111657: LD_INT 1
111659: PPUSH
111660: LD_VAR 0 3
111664: PPUSH
111665: CALL_OW 12
111669: ARRAY
111670: ST_TO_ADDR
// if Crawls ( un ) then
111671: LD_VAR 0 2
111675: PPUSH
111676: CALL_OW 318
111680: IFFALSE 111691
// ComWalk ( un ) ;
111682: LD_VAR 0 2
111686: PPUSH
111687: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
111691: LD_VAR 0 2
111695: PPUSH
111696: LD_INT 9
111698: PPUSH
111699: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
111703: LD_INT 28
111705: PPUSH
111706: LD_OWVAR 2
111710: PPUSH
111711: LD_INT 2
111713: PPUSH
111714: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
111718: LD_INT 29
111720: PPUSH
111721: LD_OWVAR 2
111725: PPUSH
111726: LD_INT 2
111728: PPUSH
111729: CALL_OW 322
// end ;
111733: PPOPN 3
111735: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
111736: LD_EXP 156
111740: PUSH
111741: LD_EXP 199
111745: AND
111746: IFFALSE 111857
111748: GO 111750
111750: DISABLE
111751: LD_INT 0
111753: PPUSH
111754: PPUSH
111755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111756: LD_ADDR_VAR 0 3
111760: PUSH
111761: LD_INT 22
111763: PUSH
111764: LD_OWVAR 2
111768: PUSH
111769: EMPTY
111770: LIST
111771: LIST
111772: PUSH
111773: LD_INT 25
111775: PUSH
111776: LD_INT 1
111778: PUSH
111779: EMPTY
111780: LIST
111781: LIST
111782: PUSH
111783: EMPTY
111784: LIST
111785: LIST
111786: PPUSH
111787: CALL_OW 69
111791: ST_TO_ADDR
// if not tmp then
111792: LD_VAR 0 3
111796: NOT
111797: IFFALSE 111801
// exit ;
111799: GO 111857
// un := tmp [ rand ( 1 , tmp ) ] ;
111801: LD_ADDR_VAR 0 2
111805: PUSH
111806: LD_VAR 0 3
111810: PUSH
111811: LD_INT 1
111813: PPUSH
111814: LD_VAR 0 3
111818: PPUSH
111819: CALL_OW 12
111823: ARRAY
111824: ST_TO_ADDR
// if Crawls ( un ) then
111825: LD_VAR 0 2
111829: PPUSH
111830: CALL_OW 318
111834: IFFALSE 111845
// ComWalk ( un ) ;
111836: LD_VAR 0 2
111840: PPUSH
111841: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111845: LD_VAR 0 2
111849: PPUSH
111850: LD_INT 8
111852: PPUSH
111853: CALL_OW 336
// end ;
111857: PPOPN 3
111859: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
111860: LD_EXP 156
111864: PUSH
111865: LD_EXP 200
111869: AND
111870: IFFALSE 112014
111872: GO 111874
111874: DISABLE
111875: LD_INT 0
111877: PPUSH
111878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
111879: LD_ADDR_VAR 0 2
111883: PUSH
111884: LD_INT 22
111886: PUSH
111887: LD_OWVAR 2
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: PUSH
111896: LD_INT 21
111898: PUSH
111899: LD_INT 2
111901: PUSH
111902: EMPTY
111903: LIST
111904: LIST
111905: PUSH
111906: LD_INT 2
111908: PUSH
111909: LD_INT 34
111911: PUSH
111912: LD_INT 12
111914: PUSH
111915: EMPTY
111916: LIST
111917: LIST
111918: PUSH
111919: LD_INT 34
111921: PUSH
111922: LD_INT 51
111924: PUSH
111925: EMPTY
111926: LIST
111927: LIST
111928: PUSH
111929: LD_INT 34
111931: PUSH
111932: LD_INT 32
111934: PUSH
111935: EMPTY
111936: LIST
111937: LIST
111938: PUSH
111939: EMPTY
111940: LIST
111941: LIST
111942: LIST
111943: LIST
111944: PUSH
111945: EMPTY
111946: LIST
111947: LIST
111948: LIST
111949: PPUSH
111950: CALL_OW 69
111954: ST_TO_ADDR
// if not tmp then
111955: LD_VAR 0 2
111959: NOT
111960: IFFALSE 111964
// exit ;
111962: GO 112014
// for i in tmp do
111964: LD_ADDR_VAR 0 1
111968: PUSH
111969: LD_VAR 0 2
111973: PUSH
111974: FOR_IN
111975: IFFALSE 112012
// if GetCargo ( i , mat_artifact ) = 0 then
111977: LD_VAR 0 1
111981: PPUSH
111982: LD_INT 4
111984: PPUSH
111985: CALL_OW 289
111989: PUSH
111990: LD_INT 0
111992: EQUAL
111993: IFFALSE 112010
// SetCargo ( i , mat_siberit , 100 ) ;
111995: LD_VAR 0 1
111999: PPUSH
112000: LD_INT 3
112002: PPUSH
112003: LD_INT 100
112005: PPUSH
112006: CALL_OW 290
112010: GO 111974
112012: POP
112013: POP
// end ;
112014: PPOPN 2
112016: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
112017: LD_EXP 156
112021: PUSH
112022: LD_EXP 201
112026: AND
112027: IFFALSE 112210
112029: GO 112031
112031: DISABLE
112032: LD_INT 0
112034: PPUSH
112035: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112036: LD_ADDR_VAR 0 2
112040: PUSH
112041: LD_INT 22
112043: PUSH
112044: LD_OWVAR 2
112048: PUSH
112049: EMPTY
112050: LIST
112051: LIST
112052: PPUSH
112053: CALL_OW 69
112057: ST_TO_ADDR
// if not tmp then
112058: LD_VAR 0 2
112062: NOT
112063: IFFALSE 112067
// exit ;
112065: GO 112210
// for i := 1 to 2 do
112067: LD_ADDR_VAR 0 1
112071: PUSH
112072: DOUBLE
112073: LD_INT 1
112075: DEC
112076: ST_TO_ADDR
112077: LD_INT 2
112079: PUSH
112080: FOR_TO
112081: IFFALSE 112208
// begin uc_side := your_side ;
112083: LD_ADDR_OWVAR 20
112087: PUSH
112088: LD_OWVAR 2
112092: ST_TO_ADDR
// uc_nation := nation_american ;
112093: LD_ADDR_OWVAR 21
112097: PUSH
112098: LD_INT 1
112100: ST_TO_ADDR
// vc_chassis := us_morphling ;
112101: LD_ADDR_OWVAR 37
112105: PUSH
112106: LD_INT 5
112108: ST_TO_ADDR
// vc_engine := engine_siberite ;
112109: LD_ADDR_OWVAR 39
112113: PUSH
112114: LD_INT 3
112116: ST_TO_ADDR
// vc_control := control_computer ;
112117: LD_ADDR_OWVAR 38
112121: PUSH
112122: LD_INT 3
112124: ST_TO_ADDR
// vc_weapon := us_double_laser ;
112125: LD_ADDR_OWVAR 40
112129: PUSH
112130: LD_INT 10
112132: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
112133: LD_VAR 0 2
112137: PUSH
112138: LD_INT 1
112140: ARRAY
112141: PPUSH
112142: CALL_OW 310
112146: NOT
112147: IFFALSE 112194
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
112149: CALL_OW 45
112153: PPUSH
112154: LD_VAR 0 2
112158: PUSH
112159: LD_INT 1
112161: ARRAY
112162: PPUSH
112163: CALL_OW 250
112167: PPUSH
112168: LD_VAR 0 2
112172: PUSH
112173: LD_INT 1
112175: ARRAY
112176: PPUSH
112177: CALL_OW 251
112181: PPUSH
112182: LD_INT 12
112184: PPUSH
112185: LD_INT 1
112187: PPUSH
112188: CALL_OW 50
112192: GO 112206
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
112194: CALL_OW 45
112198: PPUSH
112199: LD_INT 1
112201: PPUSH
112202: CALL_OW 51
// end ;
112206: GO 112080
112208: POP
112209: POP
// end ;
112210: PPOPN 2
112212: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
112213: LD_EXP 156
112217: PUSH
112218: LD_EXP 202
112222: AND
112223: IFFALSE 112445
112225: GO 112227
112227: DISABLE
112228: LD_INT 0
112230: PPUSH
112231: PPUSH
112232: PPUSH
112233: PPUSH
112234: PPUSH
112235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112236: LD_ADDR_VAR 0 6
112240: PUSH
112241: LD_INT 22
112243: PUSH
112244: LD_OWVAR 2
112248: PUSH
112249: EMPTY
112250: LIST
112251: LIST
112252: PUSH
112253: LD_INT 21
112255: PUSH
112256: LD_INT 1
112258: PUSH
112259: EMPTY
112260: LIST
112261: LIST
112262: PUSH
112263: LD_INT 3
112265: PUSH
112266: LD_INT 23
112268: PUSH
112269: LD_INT 0
112271: PUSH
112272: EMPTY
112273: LIST
112274: LIST
112275: PUSH
112276: EMPTY
112277: LIST
112278: LIST
112279: PUSH
112280: EMPTY
112281: LIST
112282: LIST
112283: LIST
112284: PPUSH
112285: CALL_OW 69
112289: ST_TO_ADDR
// if not tmp then
112290: LD_VAR 0 6
112294: NOT
112295: IFFALSE 112299
// exit ;
112297: GO 112445
// s1 := rand ( 1 , 4 ) ;
112299: LD_ADDR_VAR 0 2
112303: PUSH
112304: LD_INT 1
112306: PPUSH
112307: LD_INT 4
112309: PPUSH
112310: CALL_OW 12
112314: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
112315: LD_ADDR_VAR 0 4
112319: PUSH
112320: LD_VAR 0 6
112324: PUSH
112325: LD_INT 1
112327: ARRAY
112328: PPUSH
112329: LD_VAR 0 2
112333: PPUSH
112334: CALL_OW 259
112338: ST_TO_ADDR
// if s1 = 1 then
112339: LD_VAR 0 2
112343: PUSH
112344: LD_INT 1
112346: EQUAL
112347: IFFALSE 112367
// s2 := rand ( 2 , 4 ) else
112349: LD_ADDR_VAR 0 3
112353: PUSH
112354: LD_INT 2
112356: PPUSH
112357: LD_INT 4
112359: PPUSH
112360: CALL_OW 12
112364: ST_TO_ADDR
112365: GO 112375
// s2 := 1 ;
112367: LD_ADDR_VAR 0 3
112371: PUSH
112372: LD_INT 1
112374: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
112375: LD_ADDR_VAR 0 5
112379: PUSH
112380: LD_VAR 0 6
112384: PUSH
112385: LD_INT 1
112387: ARRAY
112388: PPUSH
112389: LD_VAR 0 3
112393: PPUSH
112394: CALL_OW 259
112398: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
112399: LD_VAR 0 6
112403: PUSH
112404: LD_INT 1
112406: ARRAY
112407: PPUSH
112408: LD_VAR 0 2
112412: PPUSH
112413: LD_VAR 0 5
112417: PPUSH
112418: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
112422: LD_VAR 0 6
112426: PUSH
112427: LD_INT 1
112429: ARRAY
112430: PPUSH
112431: LD_VAR 0 3
112435: PPUSH
112436: LD_VAR 0 4
112440: PPUSH
112441: CALL_OW 237
// end ;
112445: PPOPN 6
112447: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
112448: LD_EXP 156
112452: PUSH
112453: LD_EXP 203
112457: AND
112458: IFFALSE 112537
112460: GO 112462
112462: DISABLE
112463: LD_INT 0
112465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
112466: LD_ADDR_VAR 0 1
112470: PUSH
112471: LD_INT 22
112473: PUSH
112474: LD_OWVAR 2
112478: PUSH
112479: EMPTY
112480: LIST
112481: LIST
112482: PUSH
112483: LD_INT 30
112485: PUSH
112486: LD_INT 3
112488: PUSH
112489: EMPTY
112490: LIST
112491: LIST
112492: PUSH
112493: EMPTY
112494: LIST
112495: LIST
112496: PPUSH
112497: CALL_OW 69
112501: ST_TO_ADDR
// if not tmp then
112502: LD_VAR 0 1
112506: NOT
112507: IFFALSE 112511
// exit ;
112509: GO 112537
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112511: LD_VAR 0 1
112515: PUSH
112516: LD_INT 1
112518: PPUSH
112519: LD_VAR 0 1
112523: PPUSH
112524: CALL_OW 12
112528: ARRAY
112529: PPUSH
112530: LD_INT 1
112532: PPUSH
112533: CALL_OW 234
// end ;
112537: PPOPN 1
112539: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
112540: LD_EXP 156
112544: PUSH
112545: LD_EXP 204
112549: AND
112550: IFFALSE 112662
112552: GO 112554
112554: DISABLE
112555: LD_INT 0
112557: PPUSH
112558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
112559: LD_ADDR_VAR 0 2
112563: PUSH
112564: LD_INT 22
112566: PUSH
112567: LD_OWVAR 2
112571: PUSH
112572: EMPTY
112573: LIST
112574: LIST
112575: PUSH
112576: LD_INT 2
112578: PUSH
112579: LD_INT 30
112581: PUSH
112582: LD_INT 27
112584: PUSH
112585: EMPTY
112586: LIST
112587: LIST
112588: PUSH
112589: LD_INT 30
112591: PUSH
112592: LD_INT 26
112594: PUSH
112595: EMPTY
112596: LIST
112597: LIST
112598: PUSH
112599: LD_INT 30
112601: PUSH
112602: LD_INT 28
112604: PUSH
112605: EMPTY
112606: LIST
112607: LIST
112608: PUSH
112609: EMPTY
112610: LIST
112611: LIST
112612: LIST
112613: LIST
112614: PUSH
112615: EMPTY
112616: LIST
112617: LIST
112618: PPUSH
112619: CALL_OW 69
112623: ST_TO_ADDR
// if not tmp then
112624: LD_VAR 0 2
112628: NOT
112629: IFFALSE 112633
// exit ;
112631: GO 112662
// for i in tmp do
112633: LD_ADDR_VAR 0 1
112637: PUSH
112638: LD_VAR 0 2
112642: PUSH
112643: FOR_IN
112644: IFFALSE 112660
// SetLives ( i , 1 ) ;
112646: LD_VAR 0 1
112650: PPUSH
112651: LD_INT 1
112653: PPUSH
112654: CALL_OW 234
112658: GO 112643
112660: POP
112661: POP
// end ;
112662: PPOPN 2
112664: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
112665: LD_EXP 156
112669: PUSH
112670: LD_EXP 205
112674: AND
112675: IFFALSE 112949
112677: GO 112679
112679: DISABLE
112680: LD_INT 0
112682: PPUSH
112683: PPUSH
112684: PPUSH
// begin i := rand ( 1 , 7 ) ;
112685: LD_ADDR_VAR 0 1
112689: PUSH
112690: LD_INT 1
112692: PPUSH
112693: LD_INT 7
112695: PPUSH
112696: CALL_OW 12
112700: ST_TO_ADDR
// case i of 1 :
112701: LD_VAR 0 1
112705: PUSH
112706: LD_INT 1
112708: DOUBLE
112709: EQUAL
112710: IFTRUE 112714
112712: GO 112724
112714: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
112715: LD_STRING earthquake(getX(game), 0, 32)
112717: PPUSH
112718: CALL_OW 559
112722: GO 112949
112724: LD_INT 2
112726: DOUBLE
112727: EQUAL
112728: IFTRUE 112732
112730: GO 112746
112732: POP
// begin ToLua ( displayStucuk(); ) ;
112733: LD_STRING displayStucuk();
112735: PPUSH
112736: CALL_OW 559
// ResetFog ;
112740: CALL_OW 335
// end ; 3 :
112744: GO 112949
112746: LD_INT 3
112748: DOUBLE
112749: EQUAL
112750: IFTRUE 112754
112752: GO 112858
112754: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112755: LD_ADDR_VAR 0 2
112759: PUSH
112760: LD_INT 22
112762: PUSH
112763: LD_OWVAR 2
112767: PUSH
112768: EMPTY
112769: LIST
112770: LIST
112771: PUSH
112772: LD_INT 25
112774: PUSH
112775: LD_INT 1
112777: PUSH
112778: EMPTY
112779: LIST
112780: LIST
112781: PUSH
112782: EMPTY
112783: LIST
112784: LIST
112785: PPUSH
112786: CALL_OW 69
112790: ST_TO_ADDR
// if not tmp then
112791: LD_VAR 0 2
112795: NOT
112796: IFFALSE 112800
// exit ;
112798: GO 112949
// un := tmp [ rand ( 1 , tmp ) ] ;
112800: LD_ADDR_VAR 0 3
112804: PUSH
112805: LD_VAR 0 2
112809: PUSH
112810: LD_INT 1
112812: PPUSH
112813: LD_VAR 0 2
112817: PPUSH
112818: CALL_OW 12
112822: ARRAY
112823: ST_TO_ADDR
// if Crawls ( un ) then
112824: LD_VAR 0 3
112828: PPUSH
112829: CALL_OW 318
112833: IFFALSE 112844
// ComWalk ( un ) ;
112835: LD_VAR 0 3
112839: PPUSH
112840: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112844: LD_VAR 0 3
112848: PPUSH
112849: LD_INT 8
112851: PPUSH
112852: CALL_OW 336
// end ; 4 :
112856: GO 112949
112858: LD_INT 4
112860: DOUBLE
112861: EQUAL
112862: IFTRUE 112866
112864: GO 112927
112866: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112867: LD_ADDR_VAR 0 2
112871: PUSH
112872: LD_INT 22
112874: PUSH
112875: LD_OWVAR 2
112879: PUSH
112880: EMPTY
112881: LIST
112882: LIST
112883: PUSH
112884: LD_INT 30
112886: PUSH
112887: LD_INT 29
112889: PUSH
112890: EMPTY
112891: LIST
112892: LIST
112893: PUSH
112894: EMPTY
112895: LIST
112896: LIST
112897: PPUSH
112898: CALL_OW 69
112902: ST_TO_ADDR
// if not tmp then
112903: LD_VAR 0 2
112907: NOT
112908: IFFALSE 112912
// exit ;
112910: GO 112949
// DestroyUnit ( tmp [ 1 ] ) ;
112912: LD_VAR 0 2
112916: PUSH
112917: LD_INT 1
112919: ARRAY
112920: PPUSH
112921: CALL_OW 65
// end ; 5 .. 7 :
112925: GO 112949
112927: LD_INT 5
112929: DOUBLE
112930: GREATEREQUAL
112931: IFFALSE 112939
112933: LD_INT 7
112935: DOUBLE
112936: LESSEQUAL
112937: IFTRUE 112941
112939: GO 112948
112941: POP
// StreamSibBomb ; end ;
112942: CALL 109199 0 0
112946: GO 112949
112948: POP
// end ;
112949: PPOPN 3
112951: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112952: LD_EXP 156
112956: PUSH
112957: LD_EXP 206
112961: AND
112962: IFFALSE 113118
112964: GO 112966
112966: DISABLE
112967: LD_INT 0
112969: PPUSH
112970: PPUSH
112971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112972: LD_ADDR_VAR 0 2
112976: PUSH
112977: LD_INT 81
112979: PUSH
112980: LD_OWVAR 2
112984: PUSH
112985: EMPTY
112986: LIST
112987: LIST
112988: PUSH
112989: LD_INT 2
112991: PUSH
112992: LD_INT 21
112994: PUSH
112995: LD_INT 1
112997: PUSH
112998: EMPTY
112999: LIST
113000: LIST
113001: PUSH
113002: LD_INT 21
113004: PUSH
113005: LD_INT 2
113007: PUSH
113008: EMPTY
113009: LIST
113010: LIST
113011: PUSH
113012: EMPTY
113013: LIST
113014: LIST
113015: LIST
113016: PUSH
113017: EMPTY
113018: LIST
113019: LIST
113020: PPUSH
113021: CALL_OW 69
113025: ST_TO_ADDR
// if not tmp then
113026: LD_VAR 0 2
113030: NOT
113031: IFFALSE 113035
// exit ;
113033: GO 113118
// p := 0 ;
113035: LD_ADDR_VAR 0 3
113039: PUSH
113040: LD_INT 0
113042: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113043: LD_INT 35
113045: PPUSH
113046: CALL_OW 67
// p := p + 1 ;
113050: LD_ADDR_VAR 0 3
113054: PUSH
113055: LD_VAR 0 3
113059: PUSH
113060: LD_INT 1
113062: PLUS
113063: ST_TO_ADDR
// for i in tmp do
113064: LD_ADDR_VAR 0 1
113068: PUSH
113069: LD_VAR 0 2
113073: PUSH
113074: FOR_IN
113075: IFFALSE 113106
// if GetLives ( i ) < 1000 then
113077: LD_VAR 0 1
113081: PPUSH
113082: CALL_OW 256
113086: PUSH
113087: LD_INT 1000
113089: LESS
113090: IFFALSE 113104
// SetLives ( i , 1000 ) ;
113092: LD_VAR 0 1
113096: PPUSH
113097: LD_INT 1000
113099: PPUSH
113100: CALL_OW 234
113104: GO 113074
113106: POP
113107: POP
// until p > 20 ;
113108: LD_VAR 0 3
113112: PUSH
113113: LD_INT 20
113115: GREATER
113116: IFFALSE 113043
// end ;
113118: PPOPN 3
113120: END
// every 0 0$1 trigger StreamModeActive and sTime do
113121: LD_EXP 156
113125: PUSH
113126: LD_EXP 207
113130: AND
113131: IFFALSE 113166
113133: GO 113135
113135: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
113136: LD_INT 28
113138: PPUSH
113139: LD_OWVAR 2
113143: PPUSH
113144: LD_INT 2
113146: PPUSH
113147: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
113151: LD_INT 30
113153: PPUSH
113154: LD_OWVAR 2
113158: PPUSH
113159: LD_INT 2
113161: PPUSH
113162: CALL_OW 322
// end ;
113166: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
113167: LD_EXP 156
113171: PUSH
113172: LD_EXP 208
113176: AND
113177: IFFALSE 113298
113179: GO 113181
113181: DISABLE
113182: LD_INT 0
113184: PPUSH
113185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113186: LD_ADDR_VAR 0 2
113190: PUSH
113191: LD_INT 22
113193: PUSH
113194: LD_OWVAR 2
113198: PUSH
113199: EMPTY
113200: LIST
113201: LIST
113202: PUSH
113203: LD_INT 21
113205: PUSH
113206: LD_INT 1
113208: PUSH
113209: EMPTY
113210: LIST
113211: LIST
113212: PUSH
113213: LD_INT 3
113215: PUSH
113216: LD_INT 23
113218: PUSH
113219: LD_INT 0
113221: PUSH
113222: EMPTY
113223: LIST
113224: LIST
113225: PUSH
113226: EMPTY
113227: LIST
113228: LIST
113229: PUSH
113230: EMPTY
113231: LIST
113232: LIST
113233: LIST
113234: PPUSH
113235: CALL_OW 69
113239: ST_TO_ADDR
// if not tmp then
113240: LD_VAR 0 2
113244: NOT
113245: IFFALSE 113249
// exit ;
113247: GO 113298
// for i in tmp do
113249: LD_ADDR_VAR 0 1
113253: PUSH
113254: LD_VAR 0 2
113258: PUSH
113259: FOR_IN
113260: IFFALSE 113296
// begin if Crawls ( i ) then
113262: LD_VAR 0 1
113266: PPUSH
113267: CALL_OW 318
113271: IFFALSE 113282
// ComWalk ( i ) ;
113273: LD_VAR 0 1
113277: PPUSH
113278: CALL_OW 138
// SetClass ( i , 2 ) ;
113282: LD_VAR 0 1
113286: PPUSH
113287: LD_INT 2
113289: PPUSH
113290: CALL_OW 336
// end ;
113294: GO 113259
113296: POP
113297: POP
// end ;
113298: PPOPN 2
113300: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
113301: LD_EXP 156
113305: PUSH
113306: LD_EXP 209
113310: AND
113311: IFFALSE 113592
113313: GO 113315
113315: DISABLE
113316: LD_INT 0
113318: PPUSH
113319: PPUSH
113320: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
113321: LD_OWVAR 2
113325: PPUSH
113326: LD_INT 9
113328: PPUSH
113329: LD_INT 1
113331: PPUSH
113332: LD_INT 1
113334: PPUSH
113335: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
113339: LD_INT 9
113341: PPUSH
113342: LD_OWVAR 2
113346: PPUSH
113347: CALL_OW 343
// uc_side := 9 ;
113351: LD_ADDR_OWVAR 20
113355: PUSH
113356: LD_INT 9
113358: ST_TO_ADDR
// uc_nation := 2 ;
113359: LD_ADDR_OWVAR 21
113363: PUSH
113364: LD_INT 2
113366: ST_TO_ADDR
// hc_name := Dark Warrior ;
113367: LD_ADDR_OWVAR 26
113371: PUSH
113372: LD_STRING Dark Warrior
113374: ST_TO_ADDR
// hc_gallery :=  ;
113375: LD_ADDR_OWVAR 33
113379: PUSH
113380: LD_STRING 
113382: ST_TO_ADDR
// hc_noskilllimit := true ;
113383: LD_ADDR_OWVAR 76
113387: PUSH
113388: LD_INT 1
113390: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
113391: LD_ADDR_OWVAR 31
113395: PUSH
113396: LD_INT 30
113398: PUSH
113399: LD_INT 30
113401: PUSH
113402: LD_INT 30
113404: PUSH
113405: LD_INT 30
113407: PUSH
113408: EMPTY
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: ST_TO_ADDR
// un := CreateHuman ;
113414: LD_ADDR_VAR 0 3
113418: PUSH
113419: CALL_OW 44
113423: ST_TO_ADDR
// hc_noskilllimit := false ;
113424: LD_ADDR_OWVAR 76
113428: PUSH
113429: LD_INT 0
113431: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113432: LD_VAR 0 3
113436: PPUSH
113437: LD_INT 1
113439: PPUSH
113440: CALL_OW 51
// p := 0 ;
113444: LD_ADDR_VAR 0 2
113448: PUSH
113449: LD_INT 0
113451: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113452: LD_INT 35
113454: PPUSH
113455: CALL_OW 67
// p := p + 1 ;
113459: LD_ADDR_VAR 0 2
113463: PUSH
113464: LD_VAR 0 2
113468: PUSH
113469: LD_INT 1
113471: PLUS
113472: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
113473: LD_VAR 0 3
113477: PPUSH
113478: CALL_OW 256
113482: PUSH
113483: LD_INT 1000
113485: LESS
113486: IFFALSE 113500
// SetLives ( un , 1000 ) ;
113488: LD_VAR 0 3
113492: PPUSH
113493: LD_INT 1000
113495: PPUSH
113496: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
113500: LD_VAR 0 3
113504: PPUSH
113505: LD_INT 81
113507: PUSH
113508: LD_OWVAR 2
113512: PUSH
113513: EMPTY
113514: LIST
113515: LIST
113516: PUSH
113517: LD_INT 91
113519: PUSH
113520: LD_VAR 0 3
113524: PUSH
113525: LD_INT 30
113527: PUSH
113528: EMPTY
113529: LIST
113530: LIST
113531: LIST
113532: PUSH
113533: EMPTY
113534: LIST
113535: LIST
113536: PPUSH
113537: CALL_OW 69
113541: PPUSH
113542: LD_VAR 0 3
113546: PPUSH
113547: CALL_OW 74
113551: PPUSH
113552: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
113556: LD_VAR 0 2
113560: PUSH
113561: LD_INT 60
113563: GREATER
113564: PUSH
113565: LD_VAR 0 3
113569: PPUSH
113570: CALL_OW 301
113574: OR
113575: IFFALSE 113452
// if un then
113577: LD_VAR 0 3
113581: IFFALSE 113592
// RemoveUnit ( un ) ;
113583: LD_VAR 0 3
113587: PPUSH
113588: CALL_OW 64
// end ;
113592: PPOPN 3
113594: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113595: LD_INT 0
113597: PPUSH
// case cmd of 301 :
113598: LD_VAR 0 1
113602: PUSH
113603: LD_INT 301
113605: DOUBLE
113606: EQUAL
113607: IFTRUE 113611
113609: GO 113643
113611: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
113612: LD_VAR 0 6
113616: PPUSH
113617: LD_VAR 0 7
113621: PPUSH
113622: LD_VAR 0 8
113626: PPUSH
113627: LD_VAR 0 4
113631: PPUSH
113632: LD_VAR 0 5
113636: PPUSH
113637: CALL 114844 0 5
113641: GO 113764
113643: LD_INT 302
113645: DOUBLE
113646: EQUAL
113647: IFTRUE 113651
113649: GO 113688
113651: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
113652: LD_VAR 0 6
113656: PPUSH
113657: LD_VAR 0 7
113661: PPUSH
113662: LD_VAR 0 8
113666: PPUSH
113667: LD_VAR 0 9
113671: PPUSH
113672: LD_VAR 0 4
113676: PPUSH
113677: LD_VAR 0 5
113681: PPUSH
113682: CALL 114935 0 6
113686: GO 113764
113688: LD_INT 303
113690: DOUBLE
113691: EQUAL
113692: IFTRUE 113696
113694: GO 113733
113696: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
113697: LD_VAR 0 6
113701: PPUSH
113702: LD_VAR 0 7
113706: PPUSH
113707: LD_VAR 0 8
113711: PPUSH
113712: LD_VAR 0 9
113716: PPUSH
113717: LD_VAR 0 4
113721: PPUSH
113722: LD_VAR 0 5
113726: PPUSH
113727: CALL 113769 0 6
113731: GO 113764
113733: LD_INT 304
113735: DOUBLE
113736: EQUAL
113737: IFTRUE 113741
113739: GO 113763
113741: POP
// hHackTeleport ( unit , x , y ) ; end ;
113742: LD_VAR 0 2
113746: PPUSH
113747: LD_VAR 0 4
113751: PPUSH
113752: LD_VAR 0 5
113756: PPUSH
113757: CALL 115528 0 3
113761: GO 113764
113763: POP
// end ;
113764: LD_VAR 0 12
113768: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
113769: LD_INT 0
113771: PPUSH
113772: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
113773: LD_VAR 0 1
113777: PUSH
113778: LD_INT 1
113780: LESS
113781: PUSH
113782: LD_VAR 0 1
113786: PUSH
113787: LD_INT 3
113789: GREATER
113790: OR
113791: PUSH
113792: LD_VAR 0 5
113796: PPUSH
113797: LD_VAR 0 6
113801: PPUSH
113802: CALL_OW 428
113806: OR
113807: IFFALSE 113811
// exit ;
113809: GO 114531
// uc_side := your_side ;
113811: LD_ADDR_OWVAR 20
113815: PUSH
113816: LD_OWVAR 2
113820: ST_TO_ADDR
// uc_nation := nation ;
113821: LD_ADDR_OWVAR 21
113825: PUSH
113826: LD_VAR 0 1
113830: ST_TO_ADDR
// bc_level = 1 ;
113831: LD_ADDR_OWVAR 43
113835: PUSH
113836: LD_INT 1
113838: ST_TO_ADDR
// case btype of 1 :
113839: LD_VAR 0 2
113843: PUSH
113844: LD_INT 1
113846: DOUBLE
113847: EQUAL
113848: IFTRUE 113852
113850: GO 113863
113852: POP
// bc_type := b_depot ; 2 :
113853: LD_ADDR_OWVAR 42
113857: PUSH
113858: LD_INT 0
113860: ST_TO_ADDR
113861: GO 114475
113863: LD_INT 2
113865: DOUBLE
113866: EQUAL
113867: IFTRUE 113871
113869: GO 113882
113871: POP
// bc_type := b_warehouse ; 3 :
113872: LD_ADDR_OWVAR 42
113876: PUSH
113877: LD_INT 1
113879: ST_TO_ADDR
113880: GO 114475
113882: LD_INT 3
113884: DOUBLE
113885: EQUAL
113886: IFTRUE 113890
113888: GO 113901
113890: POP
// bc_type := b_lab ; 4 .. 9 :
113891: LD_ADDR_OWVAR 42
113895: PUSH
113896: LD_INT 6
113898: ST_TO_ADDR
113899: GO 114475
113901: LD_INT 4
113903: DOUBLE
113904: GREATEREQUAL
113905: IFFALSE 113913
113907: LD_INT 9
113909: DOUBLE
113910: LESSEQUAL
113911: IFTRUE 113915
113913: GO 113967
113915: POP
// begin bc_type := b_lab_half ;
113916: LD_ADDR_OWVAR 42
113920: PUSH
113921: LD_INT 7
113923: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
113924: LD_ADDR_OWVAR 44
113928: PUSH
113929: LD_INT 10
113931: PUSH
113932: LD_INT 11
113934: PUSH
113935: LD_INT 12
113937: PUSH
113938: LD_INT 15
113940: PUSH
113941: LD_INT 14
113943: PUSH
113944: LD_INT 13
113946: PUSH
113947: EMPTY
113948: LIST
113949: LIST
113950: LIST
113951: LIST
113952: LIST
113953: LIST
113954: PUSH
113955: LD_VAR 0 2
113959: PUSH
113960: LD_INT 3
113962: MINUS
113963: ARRAY
113964: ST_TO_ADDR
// end ; 10 .. 13 :
113965: GO 114475
113967: LD_INT 10
113969: DOUBLE
113970: GREATEREQUAL
113971: IFFALSE 113979
113973: LD_INT 13
113975: DOUBLE
113976: LESSEQUAL
113977: IFTRUE 113981
113979: GO 114058
113981: POP
// begin bc_type := b_lab_full ;
113982: LD_ADDR_OWVAR 42
113986: PUSH
113987: LD_INT 8
113989: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113990: LD_ADDR_OWVAR 44
113994: PUSH
113995: LD_INT 10
113997: PUSH
113998: LD_INT 12
114000: PUSH
114001: LD_INT 14
114003: PUSH
114004: LD_INT 13
114006: PUSH
114007: EMPTY
114008: LIST
114009: LIST
114010: LIST
114011: LIST
114012: PUSH
114013: LD_VAR 0 2
114017: PUSH
114018: LD_INT 9
114020: MINUS
114021: ARRAY
114022: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
114023: LD_ADDR_OWVAR 45
114027: PUSH
114028: LD_INT 11
114030: PUSH
114031: LD_INT 15
114033: PUSH
114034: LD_INT 12
114036: PUSH
114037: LD_INT 15
114039: PUSH
114040: EMPTY
114041: LIST
114042: LIST
114043: LIST
114044: LIST
114045: PUSH
114046: LD_VAR 0 2
114050: PUSH
114051: LD_INT 9
114053: MINUS
114054: ARRAY
114055: ST_TO_ADDR
// end ; 14 :
114056: GO 114475
114058: LD_INT 14
114060: DOUBLE
114061: EQUAL
114062: IFTRUE 114066
114064: GO 114077
114066: POP
// bc_type := b_workshop ; 15 :
114067: LD_ADDR_OWVAR 42
114071: PUSH
114072: LD_INT 2
114074: ST_TO_ADDR
114075: GO 114475
114077: LD_INT 15
114079: DOUBLE
114080: EQUAL
114081: IFTRUE 114085
114083: GO 114096
114085: POP
// bc_type := b_factory ; 16 :
114086: LD_ADDR_OWVAR 42
114090: PUSH
114091: LD_INT 3
114093: ST_TO_ADDR
114094: GO 114475
114096: LD_INT 16
114098: DOUBLE
114099: EQUAL
114100: IFTRUE 114104
114102: GO 114115
114104: POP
// bc_type := b_ext_gun ; 17 :
114105: LD_ADDR_OWVAR 42
114109: PUSH
114110: LD_INT 17
114112: ST_TO_ADDR
114113: GO 114475
114115: LD_INT 17
114117: DOUBLE
114118: EQUAL
114119: IFTRUE 114123
114121: GO 114151
114123: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
114124: LD_ADDR_OWVAR 42
114128: PUSH
114129: LD_INT 19
114131: PUSH
114132: LD_INT 23
114134: PUSH
114135: LD_INT 19
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: LIST
114142: PUSH
114143: LD_VAR 0 1
114147: ARRAY
114148: ST_TO_ADDR
114149: GO 114475
114151: LD_INT 18
114153: DOUBLE
114154: EQUAL
114155: IFTRUE 114159
114157: GO 114170
114159: POP
// bc_type := b_ext_radar ; 19 :
114160: LD_ADDR_OWVAR 42
114164: PUSH
114165: LD_INT 20
114167: ST_TO_ADDR
114168: GO 114475
114170: LD_INT 19
114172: DOUBLE
114173: EQUAL
114174: IFTRUE 114178
114176: GO 114189
114178: POP
// bc_type := b_ext_radio ; 20 :
114179: LD_ADDR_OWVAR 42
114183: PUSH
114184: LD_INT 22
114186: ST_TO_ADDR
114187: GO 114475
114189: LD_INT 20
114191: DOUBLE
114192: EQUAL
114193: IFTRUE 114197
114195: GO 114208
114197: POP
// bc_type := b_ext_siberium ; 21 :
114198: LD_ADDR_OWVAR 42
114202: PUSH
114203: LD_INT 21
114205: ST_TO_ADDR
114206: GO 114475
114208: LD_INT 21
114210: DOUBLE
114211: EQUAL
114212: IFTRUE 114216
114214: GO 114227
114216: POP
// bc_type := b_ext_computer ; 22 :
114217: LD_ADDR_OWVAR 42
114221: PUSH
114222: LD_INT 24
114224: ST_TO_ADDR
114225: GO 114475
114227: LD_INT 22
114229: DOUBLE
114230: EQUAL
114231: IFTRUE 114235
114233: GO 114246
114235: POP
// bc_type := b_ext_track ; 23 :
114236: LD_ADDR_OWVAR 42
114240: PUSH
114241: LD_INT 16
114243: ST_TO_ADDR
114244: GO 114475
114246: LD_INT 23
114248: DOUBLE
114249: EQUAL
114250: IFTRUE 114254
114252: GO 114265
114254: POP
// bc_type := b_ext_laser ; 24 :
114255: LD_ADDR_OWVAR 42
114259: PUSH
114260: LD_INT 25
114262: ST_TO_ADDR
114263: GO 114475
114265: LD_INT 24
114267: DOUBLE
114268: EQUAL
114269: IFTRUE 114273
114271: GO 114284
114273: POP
// bc_type := b_control_tower ; 25 :
114274: LD_ADDR_OWVAR 42
114278: PUSH
114279: LD_INT 36
114281: ST_TO_ADDR
114282: GO 114475
114284: LD_INT 25
114286: DOUBLE
114287: EQUAL
114288: IFTRUE 114292
114290: GO 114303
114292: POP
// bc_type := b_breastwork ; 26 :
114293: LD_ADDR_OWVAR 42
114297: PUSH
114298: LD_INT 31
114300: ST_TO_ADDR
114301: GO 114475
114303: LD_INT 26
114305: DOUBLE
114306: EQUAL
114307: IFTRUE 114311
114309: GO 114322
114311: POP
// bc_type := b_bunker ; 27 :
114312: LD_ADDR_OWVAR 42
114316: PUSH
114317: LD_INT 32
114319: ST_TO_ADDR
114320: GO 114475
114322: LD_INT 27
114324: DOUBLE
114325: EQUAL
114326: IFTRUE 114330
114328: GO 114341
114330: POP
// bc_type := b_turret ; 28 :
114331: LD_ADDR_OWVAR 42
114335: PUSH
114336: LD_INT 33
114338: ST_TO_ADDR
114339: GO 114475
114341: LD_INT 28
114343: DOUBLE
114344: EQUAL
114345: IFTRUE 114349
114347: GO 114360
114349: POP
// bc_type := b_armoury ; 29 :
114350: LD_ADDR_OWVAR 42
114354: PUSH
114355: LD_INT 4
114357: ST_TO_ADDR
114358: GO 114475
114360: LD_INT 29
114362: DOUBLE
114363: EQUAL
114364: IFTRUE 114368
114366: GO 114379
114368: POP
// bc_type := b_barracks ; 30 :
114369: LD_ADDR_OWVAR 42
114373: PUSH
114374: LD_INT 5
114376: ST_TO_ADDR
114377: GO 114475
114379: LD_INT 30
114381: DOUBLE
114382: EQUAL
114383: IFTRUE 114387
114385: GO 114398
114387: POP
// bc_type := b_solar_power ; 31 :
114388: LD_ADDR_OWVAR 42
114392: PUSH
114393: LD_INT 27
114395: ST_TO_ADDR
114396: GO 114475
114398: LD_INT 31
114400: DOUBLE
114401: EQUAL
114402: IFTRUE 114406
114404: GO 114417
114406: POP
// bc_type := b_oil_power ; 32 :
114407: LD_ADDR_OWVAR 42
114411: PUSH
114412: LD_INT 26
114414: ST_TO_ADDR
114415: GO 114475
114417: LD_INT 32
114419: DOUBLE
114420: EQUAL
114421: IFTRUE 114425
114423: GO 114436
114425: POP
// bc_type := b_siberite_power ; 33 :
114426: LD_ADDR_OWVAR 42
114430: PUSH
114431: LD_INT 28
114433: ST_TO_ADDR
114434: GO 114475
114436: LD_INT 33
114438: DOUBLE
114439: EQUAL
114440: IFTRUE 114444
114442: GO 114455
114444: POP
// bc_type := b_oil_mine ; 34 :
114445: LD_ADDR_OWVAR 42
114449: PUSH
114450: LD_INT 29
114452: ST_TO_ADDR
114453: GO 114475
114455: LD_INT 34
114457: DOUBLE
114458: EQUAL
114459: IFTRUE 114463
114461: GO 114474
114463: POP
// bc_type := b_siberite_mine ; end ;
114464: LD_ADDR_OWVAR 42
114468: PUSH
114469: LD_INT 30
114471: ST_TO_ADDR
114472: GO 114475
114474: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
114475: LD_ADDR_VAR 0 8
114479: PUSH
114480: LD_VAR 0 5
114484: PPUSH
114485: LD_VAR 0 6
114489: PPUSH
114490: LD_VAR 0 3
114494: PPUSH
114495: CALL_OW 47
114499: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
114500: LD_OWVAR 42
114504: PUSH
114505: LD_INT 32
114507: PUSH
114508: LD_INT 33
114510: PUSH
114511: EMPTY
114512: LIST
114513: LIST
114514: IN
114515: IFFALSE 114531
// PlaceWeaponTurret ( b , weapon ) ;
114517: LD_VAR 0 8
114521: PPUSH
114522: LD_VAR 0 4
114526: PPUSH
114527: CALL_OW 431
// end ;
114531: LD_VAR 0 7
114535: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
114536: LD_INT 0
114538: PPUSH
114539: PPUSH
114540: PPUSH
114541: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114542: LD_ADDR_VAR 0 4
114546: PUSH
114547: LD_INT 22
114549: PUSH
114550: LD_OWVAR 2
114554: PUSH
114555: EMPTY
114556: LIST
114557: LIST
114558: PUSH
114559: LD_INT 2
114561: PUSH
114562: LD_INT 30
114564: PUSH
114565: LD_INT 0
114567: PUSH
114568: EMPTY
114569: LIST
114570: LIST
114571: PUSH
114572: LD_INT 30
114574: PUSH
114575: LD_INT 1
114577: PUSH
114578: EMPTY
114579: LIST
114580: LIST
114581: PUSH
114582: EMPTY
114583: LIST
114584: LIST
114585: LIST
114586: PUSH
114587: EMPTY
114588: LIST
114589: LIST
114590: PPUSH
114591: CALL_OW 69
114595: ST_TO_ADDR
// if not tmp then
114596: LD_VAR 0 4
114600: NOT
114601: IFFALSE 114605
// exit ;
114603: GO 114664
// for i in tmp do
114605: LD_ADDR_VAR 0 2
114609: PUSH
114610: LD_VAR 0 4
114614: PUSH
114615: FOR_IN
114616: IFFALSE 114662
// for j = 1 to 3 do
114618: LD_ADDR_VAR 0 3
114622: PUSH
114623: DOUBLE
114624: LD_INT 1
114626: DEC
114627: ST_TO_ADDR
114628: LD_INT 3
114630: PUSH
114631: FOR_TO
114632: IFFALSE 114658
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
114634: LD_VAR 0 2
114638: PPUSH
114639: CALL_OW 274
114643: PPUSH
114644: LD_VAR 0 3
114648: PPUSH
114649: LD_INT 99999
114651: PPUSH
114652: CALL_OW 277
114656: GO 114631
114658: POP
114659: POP
114660: GO 114615
114662: POP
114663: POP
// end ;
114664: LD_VAR 0 1
114668: RET
// export function hHackSetLevel10 ; var i , j ; begin
114669: LD_INT 0
114671: PPUSH
114672: PPUSH
114673: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114674: LD_ADDR_VAR 0 2
114678: PUSH
114679: LD_INT 21
114681: PUSH
114682: LD_INT 1
114684: PUSH
114685: EMPTY
114686: LIST
114687: LIST
114688: PPUSH
114689: CALL_OW 69
114693: PUSH
114694: FOR_IN
114695: IFFALSE 114747
// if IsSelected ( i ) then
114697: LD_VAR 0 2
114701: PPUSH
114702: CALL_OW 306
114706: IFFALSE 114745
// begin for j := 1 to 4 do
114708: LD_ADDR_VAR 0 3
114712: PUSH
114713: DOUBLE
114714: LD_INT 1
114716: DEC
114717: ST_TO_ADDR
114718: LD_INT 4
114720: PUSH
114721: FOR_TO
114722: IFFALSE 114743
// SetSkill ( i , j , 10 ) ;
114724: LD_VAR 0 2
114728: PPUSH
114729: LD_VAR 0 3
114733: PPUSH
114734: LD_INT 10
114736: PPUSH
114737: CALL_OW 237
114741: GO 114721
114743: POP
114744: POP
// end ;
114745: GO 114694
114747: POP
114748: POP
// end ;
114749: LD_VAR 0 1
114753: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
114754: LD_INT 0
114756: PPUSH
114757: PPUSH
114758: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
114759: LD_ADDR_VAR 0 2
114763: PUSH
114764: LD_INT 22
114766: PUSH
114767: LD_OWVAR 2
114771: PUSH
114772: EMPTY
114773: LIST
114774: LIST
114775: PUSH
114776: LD_INT 21
114778: PUSH
114779: LD_INT 1
114781: PUSH
114782: EMPTY
114783: LIST
114784: LIST
114785: PUSH
114786: EMPTY
114787: LIST
114788: LIST
114789: PPUSH
114790: CALL_OW 69
114794: PUSH
114795: FOR_IN
114796: IFFALSE 114837
// begin for j := 1 to 4 do
114798: LD_ADDR_VAR 0 3
114802: PUSH
114803: DOUBLE
114804: LD_INT 1
114806: DEC
114807: ST_TO_ADDR
114808: LD_INT 4
114810: PUSH
114811: FOR_TO
114812: IFFALSE 114833
// SetSkill ( i , j , 10 ) ;
114814: LD_VAR 0 2
114818: PPUSH
114819: LD_VAR 0 3
114823: PPUSH
114824: LD_INT 10
114826: PPUSH
114827: CALL_OW 237
114831: GO 114811
114833: POP
114834: POP
// end ;
114835: GO 114795
114837: POP
114838: POP
// end ;
114839: LD_VAR 0 1
114843: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
114844: LD_INT 0
114846: PPUSH
// uc_side := your_side ;
114847: LD_ADDR_OWVAR 20
114851: PUSH
114852: LD_OWVAR 2
114856: ST_TO_ADDR
// uc_nation := nation ;
114857: LD_ADDR_OWVAR 21
114861: PUSH
114862: LD_VAR 0 1
114866: ST_TO_ADDR
// InitHc ;
114867: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
114871: LD_INT 0
114873: PPUSH
114874: LD_VAR 0 2
114878: PPUSH
114879: LD_VAR 0 3
114883: PPUSH
114884: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
114888: LD_VAR 0 4
114892: PPUSH
114893: LD_VAR 0 5
114897: PPUSH
114898: CALL_OW 428
114902: PUSH
114903: LD_INT 0
114905: EQUAL
114906: IFFALSE 114930
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
114908: CALL_OW 44
114912: PPUSH
114913: LD_VAR 0 4
114917: PPUSH
114918: LD_VAR 0 5
114922: PPUSH
114923: LD_INT 1
114925: PPUSH
114926: CALL_OW 48
// end ;
114930: LD_VAR 0 6
114934: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
114935: LD_INT 0
114937: PPUSH
114938: PPUSH
// uc_side := your_side ;
114939: LD_ADDR_OWVAR 20
114943: PUSH
114944: LD_OWVAR 2
114948: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114949: LD_VAR 0 1
114953: PUSH
114954: LD_INT 1
114956: PUSH
114957: LD_INT 2
114959: PUSH
114960: LD_INT 3
114962: PUSH
114963: LD_INT 4
114965: PUSH
114966: LD_INT 5
114968: PUSH
114969: EMPTY
114970: LIST
114971: LIST
114972: LIST
114973: LIST
114974: LIST
114975: IN
114976: IFFALSE 114988
// uc_nation := nation_american else
114978: LD_ADDR_OWVAR 21
114982: PUSH
114983: LD_INT 1
114985: ST_TO_ADDR
114986: GO 115031
// if chassis in [ 11 , 12 , 13 , 14 ] then
114988: LD_VAR 0 1
114992: PUSH
114993: LD_INT 11
114995: PUSH
114996: LD_INT 12
114998: PUSH
114999: LD_INT 13
115001: PUSH
115002: LD_INT 14
115004: PUSH
115005: EMPTY
115006: LIST
115007: LIST
115008: LIST
115009: LIST
115010: IN
115011: IFFALSE 115023
// uc_nation := nation_arabian else
115013: LD_ADDR_OWVAR 21
115017: PUSH
115018: LD_INT 2
115020: ST_TO_ADDR
115021: GO 115031
// uc_nation := nation_russian ;
115023: LD_ADDR_OWVAR 21
115027: PUSH
115028: LD_INT 3
115030: ST_TO_ADDR
// vc_chassis := chassis ;
115031: LD_ADDR_OWVAR 37
115035: PUSH
115036: LD_VAR 0 1
115040: ST_TO_ADDR
// vc_engine := engine ;
115041: LD_ADDR_OWVAR 39
115045: PUSH
115046: LD_VAR 0 2
115050: ST_TO_ADDR
// vc_control := control ;
115051: LD_ADDR_OWVAR 38
115055: PUSH
115056: LD_VAR 0 3
115060: ST_TO_ADDR
// vc_weapon := weapon ;
115061: LD_ADDR_OWVAR 40
115065: PUSH
115066: LD_VAR 0 4
115070: ST_TO_ADDR
// un := CreateVehicle ;
115071: LD_ADDR_VAR 0 8
115075: PUSH
115076: CALL_OW 45
115080: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
115081: LD_VAR 0 8
115085: PPUSH
115086: LD_INT 0
115088: PPUSH
115089: LD_INT 5
115091: PPUSH
115092: CALL_OW 12
115096: PPUSH
115097: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
115101: LD_VAR 0 8
115105: PPUSH
115106: LD_VAR 0 5
115110: PPUSH
115111: LD_VAR 0 6
115115: PPUSH
115116: LD_INT 1
115118: PPUSH
115119: CALL_OW 48
// end ;
115123: LD_VAR 0 7
115127: RET
// export hInvincible ; every 1 do
115128: GO 115130
115130: DISABLE
// hInvincible := [ ] ;
115131: LD_ADDR_EXP 210
115135: PUSH
115136: EMPTY
115137: ST_TO_ADDR
115138: END
// every 10 do var i ;
115139: GO 115141
115141: DISABLE
115142: LD_INT 0
115144: PPUSH
// begin enable ;
115145: ENABLE
// if not hInvincible then
115146: LD_EXP 210
115150: NOT
115151: IFFALSE 115155
// exit ;
115153: GO 115199
// for i in hInvincible do
115155: LD_ADDR_VAR 0 1
115159: PUSH
115160: LD_EXP 210
115164: PUSH
115165: FOR_IN
115166: IFFALSE 115197
// if GetLives ( i ) < 1000 then
115168: LD_VAR 0 1
115172: PPUSH
115173: CALL_OW 256
115177: PUSH
115178: LD_INT 1000
115180: LESS
115181: IFFALSE 115195
// SetLives ( i , 1000 ) ;
115183: LD_VAR 0 1
115187: PPUSH
115188: LD_INT 1000
115190: PPUSH
115191: CALL_OW 234
115195: GO 115165
115197: POP
115198: POP
// end ;
115199: PPOPN 1
115201: END
// export function hHackInvincible ; var i ; begin
115202: LD_INT 0
115204: PPUSH
115205: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
115206: LD_ADDR_VAR 0 2
115210: PUSH
115211: LD_INT 2
115213: PUSH
115214: LD_INT 21
115216: PUSH
115217: LD_INT 1
115219: PUSH
115220: EMPTY
115221: LIST
115222: LIST
115223: PUSH
115224: LD_INT 21
115226: PUSH
115227: LD_INT 2
115229: PUSH
115230: EMPTY
115231: LIST
115232: LIST
115233: PUSH
115234: EMPTY
115235: LIST
115236: LIST
115237: LIST
115238: PPUSH
115239: CALL_OW 69
115243: PUSH
115244: FOR_IN
115245: IFFALSE 115306
// if IsSelected ( i ) then
115247: LD_VAR 0 2
115251: PPUSH
115252: CALL_OW 306
115256: IFFALSE 115304
// begin if i in hInvincible then
115258: LD_VAR 0 2
115262: PUSH
115263: LD_EXP 210
115267: IN
115268: IFFALSE 115288
// hInvincible := hInvincible diff i else
115270: LD_ADDR_EXP 210
115274: PUSH
115275: LD_EXP 210
115279: PUSH
115280: LD_VAR 0 2
115284: DIFF
115285: ST_TO_ADDR
115286: GO 115304
// hInvincible := hInvincible union i ;
115288: LD_ADDR_EXP 210
115292: PUSH
115293: LD_EXP 210
115297: PUSH
115298: LD_VAR 0 2
115302: UNION
115303: ST_TO_ADDR
// end ;
115304: GO 115244
115306: POP
115307: POP
// end ;
115308: LD_VAR 0 1
115312: RET
// export function hHackInvisible ; var i , j ; begin
115313: LD_INT 0
115315: PPUSH
115316: PPUSH
115317: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115318: LD_ADDR_VAR 0 2
115322: PUSH
115323: LD_INT 21
115325: PUSH
115326: LD_INT 1
115328: PUSH
115329: EMPTY
115330: LIST
115331: LIST
115332: PPUSH
115333: CALL_OW 69
115337: PUSH
115338: FOR_IN
115339: IFFALSE 115363
// if IsSelected ( i ) then
115341: LD_VAR 0 2
115345: PPUSH
115346: CALL_OW 306
115350: IFFALSE 115361
// ComForceInvisible ( i ) ;
115352: LD_VAR 0 2
115356: PPUSH
115357: CALL_OW 496
115361: GO 115338
115363: POP
115364: POP
// end ;
115365: LD_VAR 0 1
115369: RET
// export function hHackChangeYourSide ; begin
115370: LD_INT 0
115372: PPUSH
// if your_side = 8 then
115373: LD_OWVAR 2
115377: PUSH
115378: LD_INT 8
115380: EQUAL
115381: IFFALSE 115393
// your_side := 0 else
115383: LD_ADDR_OWVAR 2
115387: PUSH
115388: LD_INT 0
115390: ST_TO_ADDR
115391: GO 115407
// your_side := your_side + 1 ;
115393: LD_ADDR_OWVAR 2
115397: PUSH
115398: LD_OWVAR 2
115402: PUSH
115403: LD_INT 1
115405: PLUS
115406: ST_TO_ADDR
// end ;
115407: LD_VAR 0 1
115411: RET
// export function hHackChangeUnitSide ; var i , j ; begin
115412: LD_INT 0
115414: PPUSH
115415: PPUSH
115416: PPUSH
// for i in all_units do
115417: LD_ADDR_VAR 0 2
115421: PUSH
115422: LD_OWVAR 3
115426: PUSH
115427: FOR_IN
115428: IFFALSE 115506
// if IsSelected ( i ) then
115430: LD_VAR 0 2
115434: PPUSH
115435: CALL_OW 306
115439: IFFALSE 115504
// begin j := GetSide ( i ) ;
115441: LD_ADDR_VAR 0 3
115445: PUSH
115446: LD_VAR 0 2
115450: PPUSH
115451: CALL_OW 255
115455: ST_TO_ADDR
// if j = 8 then
115456: LD_VAR 0 3
115460: PUSH
115461: LD_INT 8
115463: EQUAL
115464: IFFALSE 115476
// j := 0 else
115466: LD_ADDR_VAR 0 3
115470: PUSH
115471: LD_INT 0
115473: ST_TO_ADDR
115474: GO 115490
// j := j + 1 ;
115476: LD_ADDR_VAR 0 3
115480: PUSH
115481: LD_VAR 0 3
115485: PUSH
115486: LD_INT 1
115488: PLUS
115489: ST_TO_ADDR
// SetSide ( i , j ) ;
115490: LD_VAR 0 2
115494: PPUSH
115495: LD_VAR 0 3
115499: PPUSH
115500: CALL_OW 235
// end ;
115504: GO 115427
115506: POP
115507: POP
// end ;
115508: LD_VAR 0 1
115512: RET
// export function hHackFog ; begin
115513: LD_INT 0
115515: PPUSH
// FogOff ( true ) ;
115516: LD_INT 1
115518: PPUSH
115519: CALL_OW 344
// end ;
115523: LD_VAR 0 1
115527: RET
// export function hHackTeleport ( unit , x , y ) ; begin
115528: LD_INT 0
115530: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
115531: LD_VAR 0 1
115535: PPUSH
115536: LD_VAR 0 2
115540: PPUSH
115541: LD_VAR 0 3
115545: PPUSH
115546: LD_INT 1
115548: PPUSH
115549: LD_INT 1
115551: PPUSH
115552: CALL_OW 483
// CenterOnXY ( x , y ) ;
115556: LD_VAR 0 2
115560: PPUSH
115561: LD_VAR 0 3
115565: PPUSH
115566: CALL_OW 84
// end ; end_of_file
115570: LD_VAR 0 4
115574: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
115575: LD_INT 0
115577: PPUSH
115578: PPUSH
115579: PPUSH
115580: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
115581: LD_VAR 0 1
115585: PPUSH
115586: CALL_OW 264
115590: PUSH
115591: LD_EXP 99
115595: EQUAL
115596: IFFALSE 115668
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115598: LD_INT 68
115600: PPUSH
115601: LD_VAR 0 1
115605: PPUSH
115606: CALL_OW 255
115610: PPUSH
115611: CALL_OW 321
115615: PUSH
115616: LD_INT 2
115618: EQUAL
115619: IFFALSE 115631
// eff := 70 else
115621: LD_ADDR_VAR 0 4
115625: PUSH
115626: LD_INT 70
115628: ST_TO_ADDR
115629: GO 115639
// eff := 30 ;
115631: LD_ADDR_VAR 0 4
115635: PUSH
115636: LD_INT 30
115638: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115639: LD_VAR 0 1
115643: PPUSH
115644: CALL_OW 250
115648: PPUSH
115649: LD_VAR 0 1
115653: PPUSH
115654: CALL_OW 251
115658: PPUSH
115659: LD_VAR 0 4
115663: PPUSH
115664: CALL_OW 495
// end ; end ;
115668: LD_VAR 0 2
115672: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
115673: LD_INT 0
115675: PPUSH
// end ;
115676: LD_VAR 0 4
115680: RET
// export function SOS_Command ( cmd ) ; begin
115681: LD_INT 0
115683: PPUSH
// end ;
115684: LD_VAR 0 2
115688: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
115689: LD_INT 0
115691: PPUSH
// if cmd = 121 then
115692: LD_VAR 0 1
115696: PUSH
115697: LD_INT 121
115699: EQUAL
115700: IFFALSE 115702
// end ;
115702: LD_VAR 0 6
115706: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
115707: LD_INT 0
115709: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
115710: LD_VAR 0 1
115714: PUSH
115715: LD_INT 250
115717: EQUAL
115718: PUSH
115719: LD_VAR 0 2
115723: PPUSH
115724: CALL_OW 264
115728: PUSH
115729: LD_EXP 102
115733: EQUAL
115734: AND
115735: IFFALSE 115756
// MinerPlaceMine ( unit , x , y ) ;
115737: LD_VAR 0 2
115741: PPUSH
115742: LD_VAR 0 4
115746: PPUSH
115747: LD_VAR 0 5
115751: PPUSH
115752: CALL 118105 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
115756: LD_VAR 0 1
115760: PUSH
115761: LD_INT 251
115763: EQUAL
115764: PUSH
115765: LD_VAR 0 2
115769: PPUSH
115770: CALL_OW 264
115774: PUSH
115775: LD_EXP 102
115779: EQUAL
115780: AND
115781: IFFALSE 115802
// MinerDetonateMine ( unit , x , y ) ;
115783: LD_VAR 0 2
115787: PPUSH
115788: LD_VAR 0 4
115792: PPUSH
115793: LD_VAR 0 5
115797: PPUSH
115798: CALL 118382 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
115802: LD_VAR 0 1
115806: PUSH
115807: LD_INT 252
115809: EQUAL
115810: PUSH
115811: LD_VAR 0 2
115815: PPUSH
115816: CALL_OW 264
115820: PUSH
115821: LD_EXP 102
115825: EQUAL
115826: AND
115827: IFFALSE 115848
// MinerCreateMinefield ( unit , x , y ) ;
115829: LD_VAR 0 2
115833: PPUSH
115834: LD_VAR 0 4
115838: PPUSH
115839: LD_VAR 0 5
115843: PPUSH
115844: CALL 118799 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115848: LD_VAR 0 1
115852: PUSH
115853: LD_INT 253
115855: EQUAL
115856: PUSH
115857: LD_VAR 0 2
115861: PPUSH
115862: CALL_OW 257
115866: PUSH
115867: LD_INT 5
115869: EQUAL
115870: AND
115871: IFFALSE 115892
// ComBinocular ( unit , x , y ) ;
115873: LD_VAR 0 2
115877: PPUSH
115878: LD_VAR 0 4
115882: PPUSH
115883: LD_VAR 0 5
115887: PPUSH
115888: CALL 119170 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115892: LD_VAR 0 1
115896: PUSH
115897: LD_INT 254
115899: EQUAL
115900: PUSH
115901: LD_VAR 0 2
115905: PPUSH
115906: CALL_OW 264
115910: PUSH
115911: LD_EXP 97
115915: EQUAL
115916: AND
115917: PUSH
115918: LD_VAR 0 3
115922: PPUSH
115923: CALL_OW 263
115927: PUSH
115928: LD_INT 3
115930: EQUAL
115931: AND
115932: IFFALSE 115948
// HackDestroyVehicle ( unit , selectedUnit ) ;
115934: LD_VAR 0 2
115938: PPUSH
115939: LD_VAR 0 3
115943: PPUSH
115944: CALL 117465 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115948: LD_VAR 0 1
115952: PUSH
115953: LD_INT 255
115955: EQUAL
115956: PUSH
115957: LD_VAR 0 2
115961: PPUSH
115962: CALL_OW 264
115966: PUSH
115967: LD_INT 14
115969: PUSH
115970: LD_INT 53
115972: PUSH
115973: EMPTY
115974: LIST
115975: LIST
115976: IN
115977: AND
115978: PUSH
115979: LD_VAR 0 4
115983: PPUSH
115984: LD_VAR 0 5
115988: PPUSH
115989: CALL_OW 488
115993: AND
115994: IFFALSE 116018
// CutTreeXYR ( unit , x , y , 12 ) ;
115996: LD_VAR 0 2
116000: PPUSH
116001: LD_VAR 0 4
116005: PPUSH
116006: LD_VAR 0 5
116010: PPUSH
116011: LD_INT 12
116013: PPUSH
116014: CALL 116031 0 4
// end ;
116018: LD_VAR 0 6
116022: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
116023: LD_INT 0
116025: PPUSH
// end ;
116026: LD_VAR 0 4
116030: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
116031: LD_INT 0
116033: PPUSH
116034: PPUSH
116035: PPUSH
116036: PPUSH
116037: PPUSH
116038: PPUSH
116039: PPUSH
116040: PPUSH
116041: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
116042: LD_VAR 0 1
116046: NOT
116047: PUSH
116048: LD_VAR 0 2
116052: PPUSH
116053: LD_VAR 0 3
116057: PPUSH
116058: CALL_OW 488
116062: NOT
116063: OR
116064: PUSH
116065: LD_VAR 0 4
116069: NOT
116070: OR
116071: IFFALSE 116075
// exit ;
116073: GO 116415
// list := [ ] ;
116075: LD_ADDR_VAR 0 13
116079: PUSH
116080: EMPTY
116081: ST_TO_ADDR
// if x - r < 0 then
116082: LD_VAR 0 2
116086: PUSH
116087: LD_VAR 0 4
116091: MINUS
116092: PUSH
116093: LD_INT 0
116095: LESS
116096: IFFALSE 116108
// min_x := 0 else
116098: LD_ADDR_VAR 0 7
116102: PUSH
116103: LD_INT 0
116105: ST_TO_ADDR
116106: GO 116124
// min_x := x - r ;
116108: LD_ADDR_VAR 0 7
116112: PUSH
116113: LD_VAR 0 2
116117: PUSH
116118: LD_VAR 0 4
116122: MINUS
116123: ST_TO_ADDR
// if y - r < 0 then
116124: LD_VAR 0 3
116128: PUSH
116129: LD_VAR 0 4
116133: MINUS
116134: PUSH
116135: LD_INT 0
116137: LESS
116138: IFFALSE 116150
// min_y := 0 else
116140: LD_ADDR_VAR 0 8
116144: PUSH
116145: LD_INT 0
116147: ST_TO_ADDR
116148: GO 116166
// min_y := y - r ;
116150: LD_ADDR_VAR 0 8
116154: PUSH
116155: LD_VAR 0 3
116159: PUSH
116160: LD_VAR 0 4
116164: MINUS
116165: ST_TO_ADDR
// max_x := x + r ;
116166: LD_ADDR_VAR 0 9
116170: PUSH
116171: LD_VAR 0 2
116175: PUSH
116176: LD_VAR 0 4
116180: PLUS
116181: ST_TO_ADDR
// max_y := y + r ;
116182: LD_ADDR_VAR 0 10
116186: PUSH
116187: LD_VAR 0 3
116191: PUSH
116192: LD_VAR 0 4
116196: PLUS
116197: ST_TO_ADDR
// for _x = min_x to max_x do
116198: LD_ADDR_VAR 0 11
116202: PUSH
116203: DOUBLE
116204: LD_VAR 0 7
116208: DEC
116209: ST_TO_ADDR
116210: LD_VAR 0 9
116214: PUSH
116215: FOR_TO
116216: IFFALSE 116333
// for _y = min_y to max_y do
116218: LD_ADDR_VAR 0 12
116222: PUSH
116223: DOUBLE
116224: LD_VAR 0 8
116228: DEC
116229: ST_TO_ADDR
116230: LD_VAR 0 10
116234: PUSH
116235: FOR_TO
116236: IFFALSE 116329
// begin if not ValidHex ( _x , _y ) then
116238: LD_VAR 0 11
116242: PPUSH
116243: LD_VAR 0 12
116247: PPUSH
116248: CALL_OW 488
116252: NOT
116253: IFFALSE 116257
// continue ;
116255: GO 116235
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116257: LD_VAR 0 11
116261: PPUSH
116262: LD_VAR 0 12
116266: PPUSH
116267: CALL_OW 351
116271: PUSH
116272: LD_VAR 0 11
116276: PPUSH
116277: LD_VAR 0 12
116281: PPUSH
116282: CALL_OW 554
116286: AND
116287: IFFALSE 116327
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116289: LD_ADDR_VAR 0 13
116293: PUSH
116294: LD_VAR 0 13
116298: PPUSH
116299: LD_VAR 0 13
116303: PUSH
116304: LD_INT 1
116306: PLUS
116307: PPUSH
116308: LD_VAR 0 11
116312: PUSH
116313: LD_VAR 0 12
116317: PUSH
116318: EMPTY
116319: LIST
116320: LIST
116321: PPUSH
116322: CALL_OW 2
116326: ST_TO_ADDR
// end ;
116327: GO 116235
116329: POP
116330: POP
116331: GO 116215
116333: POP
116334: POP
// if not list then
116335: LD_VAR 0 13
116339: NOT
116340: IFFALSE 116344
// exit ;
116342: GO 116415
// for i in list do
116344: LD_ADDR_VAR 0 6
116348: PUSH
116349: LD_VAR 0 13
116353: PUSH
116354: FOR_IN
116355: IFFALSE 116413
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
116357: LD_VAR 0 1
116361: PPUSH
116362: LD_STRING M
116364: PUSH
116365: LD_VAR 0 6
116369: PUSH
116370: LD_INT 1
116372: ARRAY
116373: PUSH
116374: LD_VAR 0 6
116378: PUSH
116379: LD_INT 2
116381: ARRAY
116382: PUSH
116383: LD_INT 0
116385: PUSH
116386: LD_INT 0
116388: PUSH
116389: LD_INT 0
116391: PUSH
116392: LD_INT 0
116394: PUSH
116395: EMPTY
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: LIST
116402: LIST
116403: PUSH
116404: EMPTY
116405: LIST
116406: PPUSH
116407: CALL_OW 447
116411: GO 116354
116413: POP
116414: POP
// end ;
116415: LD_VAR 0 5
116419: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116420: LD_EXP 213
116424: NOT
116425: IFFALSE 116475
116427: GO 116429
116429: DISABLE
// begin initHack := true ;
116430: LD_ADDR_EXP 213
116434: PUSH
116435: LD_INT 1
116437: ST_TO_ADDR
// hackTanks := [ ] ;
116438: LD_ADDR_EXP 214
116442: PUSH
116443: EMPTY
116444: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116445: LD_ADDR_EXP 215
116449: PUSH
116450: EMPTY
116451: ST_TO_ADDR
// hackLimit := 3 ;
116452: LD_ADDR_EXP 216
116456: PUSH
116457: LD_INT 3
116459: ST_TO_ADDR
// hackDist := 12 ;
116460: LD_ADDR_EXP 217
116464: PUSH
116465: LD_INT 12
116467: ST_TO_ADDR
// hackCounter := [ ] ;
116468: LD_ADDR_EXP 218
116472: PUSH
116473: EMPTY
116474: ST_TO_ADDR
// end ;
116475: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116476: LD_EXP 213
116480: PUSH
116481: LD_INT 34
116483: PUSH
116484: LD_EXP 97
116488: PUSH
116489: EMPTY
116490: LIST
116491: LIST
116492: PPUSH
116493: CALL_OW 69
116497: AND
116498: IFFALSE 116753
116500: GO 116502
116502: DISABLE
116503: LD_INT 0
116505: PPUSH
116506: PPUSH
// begin enable ;
116507: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116508: LD_ADDR_VAR 0 1
116512: PUSH
116513: LD_INT 34
116515: PUSH
116516: LD_EXP 97
116520: PUSH
116521: EMPTY
116522: LIST
116523: LIST
116524: PPUSH
116525: CALL_OW 69
116529: PUSH
116530: FOR_IN
116531: IFFALSE 116751
// begin if not i in hackTanks then
116533: LD_VAR 0 1
116537: PUSH
116538: LD_EXP 214
116542: IN
116543: NOT
116544: IFFALSE 116627
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116546: LD_ADDR_EXP 214
116550: PUSH
116551: LD_EXP 214
116555: PPUSH
116556: LD_EXP 214
116560: PUSH
116561: LD_INT 1
116563: PLUS
116564: PPUSH
116565: LD_VAR 0 1
116569: PPUSH
116570: CALL_OW 1
116574: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116575: LD_ADDR_EXP 215
116579: PUSH
116580: LD_EXP 215
116584: PPUSH
116585: LD_EXP 215
116589: PUSH
116590: LD_INT 1
116592: PLUS
116593: PPUSH
116594: EMPTY
116595: PPUSH
116596: CALL_OW 1
116600: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116601: LD_ADDR_EXP 218
116605: PUSH
116606: LD_EXP 218
116610: PPUSH
116611: LD_EXP 218
116615: PUSH
116616: LD_INT 1
116618: PLUS
116619: PPUSH
116620: EMPTY
116621: PPUSH
116622: CALL_OW 1
116626: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116627: LD_VAR 0 1
116631: PPUSH
116632: CALL_OW 302
116636: NOT
116637: IFFALSE 116650
// begin HackUnlinkAll ( i ) ;
116639: LD_VAR 0 1
116643: PPUSH
116644: CALL 116756 0 1
// continue ;
116648: GO 116530
// end ; HackCheckCapturedStatus ( i ) ;
116650: LD_VAR 0 1
116654: PPUSH
116655: CALL 117199 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116659: LD_ADDR_VAR 0 2
116663: PUSH
116664: LD_INT 81
116666: PUSH
116667: LD_VAR 0 1
116671: PPUSH
116672: CALL_OW 255
116676: PUSH
116677: EMPTY
116678: LIST
116679: LIST
116680: PUSH
116681: LD_INT 33
116683: PUSH
116684: LD_INT 3
116686: PUSH
116687: EMPTY
116688: LIST
116689: LIST
116690: PUSH
116691: LD_INT 91
116693: PUSH
116694: LD_VAR 0 1
116698: PUSH
116699: LD_EXP 217
116703: PUSH
116704: EMPTY
116705: LIST
116706: LIST
116707: LIST
116708: PUSH
116709: LD_INT 50
116711: PUSH
116712: EMPTY
116713: LIST
116714: PUSH
116715: EMPTY
116716: LIST
116717: LIST
116718: LIST
116719: LIST
116720: PPUSH
116721: CALL_OW 69
116725: ST_TO_ADDR
// if not tmp then
116726: LD_VAR 0 2
116730: NOT
116731: IFFALSE 116735
// continue ;
116733: GO 116530
// HackLink ( i , tmp ) ;
116735: LD_VAR 0 1
116739: PPUSH
116740: LD_VAR 0 2
116744: PPUSH
116745: CALL 116892 0 2
// end ;
116749: GO 116530
116751: POP
116752: POP
// end ;
116753: PPOPN 2
116755: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116756: LD_INT 0
116758: PPUSH
116759: PPUSH
116760: PPUSH
// if not hack in hackTanks then
116761: LD_VAR 0 1
116765: PUSH
116766: LD_EXP 214
116770: IN
116771: NOT
116772: IFFALSE 116776
// exit ;
116774: GO 116887
// index := GetElementIndex ( hackTanks , hack ) ;
116776: LD_ADDR_VAR 0 4
116780: PUSH
116781: LD_EXP 214
116785: PPUSH
116786: LD_VAR 0 1
116790: PPUSH
116791: CALL 69935 0 2
116795: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116796: LD_EXP 215
116800: PUSH
116801: LD_VAR 0 4
116805: ARRAY
116806: IFFALSE 116887
// begin for i in hackTanksCaptured [ index ] do
116808: LD_ADDR_VAR 0 3
116812: PUSH
116813: LD_EXP 215
116817: PUSH
116818: LD_VAR 0 4
116822: ARRAY
116823: PUSH
116824: FOR_IN
116825: IFFALSE 116851
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116827: LD_VAR 0 3
116831: PUSH
116832: LD_INT 1
116834: ARRAY
116835: PPUSH
116836: LD_VAR 0 3
116840: PUSH
116841: LD_INT 2
116843: ARRAY
116844: PPUSH
116845: CALL_OW 235
116849: GO 116824
116851: POP
116852: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116853: LD_ADDR_EXP 215
116857: PUSH
116858: LD_EXP 215
116862: PPUSH
116863: LD_VAR 0 4
116867: PPUSH
116868: EMPTY
116869: PPUSH
116870: CALL_OW 1
116874: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116875: LD_VAR 0 1
116879: PPUSH
116880: LD_INT 0
116882: PPUSH
116883: CALL_OW 505
// end ; end ;
116887: LD_VAR 0 2
116891: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116892: LD_INT 0
116894: PPUSH
116895: PPUSH
116896: PPUSH
// if not hack in hackTanks or not vehicles then
116897: LD_VAR 0 1
116901: PUSH
116902: LD_EXP 214
116906: IN
116907: NOT
116908: PUSH
116909: LD_VAR 0 2
116913: NOT
116914: OR
116915: IFFALSE 116919
// exit ;
116917: GO 117194
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116919: LD_ADDR_VAR 0 2
116923: PUSH
116924: LD_VAR 0 1
116928: PPUSH
116929: LD_VAR 0 2
116933: PPUSH
116934: LD_INT 1
116936: PPUSH
116937: LD_INT 1
116939: PPUSH
116940: CALL 70585 0 4
116944: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116945: LD_ADDR_VAR 0 5
116949: PUSH
116950: LD_EXP 214
116954: PPUSH
116955: LD_VAR 0 1
116959: PPUSH
116960: CALL 69935 0 2
116964: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116965: LD_EXP 215
116969: PUSH
116970: LD_VAR 0 5
116974: ARRAY
116975: PUSH
116976: LD_EXP 216
116980: LESS
116981: IFFALSE 117170
// begin for i := 1 to vehicles do
116983: LD_ADDR_VAR 0 4
116987: PUSH
116988: DOUBLE
116989: LD_INT 1
116991: DEC
116992: ST_TO_ADDR
116993: LD_VAR 0 2
116997: PUSH
116998: FOR_TO
116999: IFFALSE 117168
// begin if hackTanksCaptured [ index ] = hackLimit then
117001: LD_EXP 215
117005: PUSH
117006: LD_VAR 0 5
117010: ARRAY
117011: PUSH
117012: LD_EXP 216
117016: EQUAL
117017: IFFALSE 117021
// break ;
117019: GO 117168
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
117021: LD_ADDR_EXP 218
117025: PUSH
117026: LD_EXP 218
117030: PPUSH
117031: LD_VAR 0 5
117035: PPUSH
117036: LD_EXP 218
117040: PUSH
117041: LD_VAR 0 5
117045: ARRAY
117046: PUSH
117047: LD_INT 1
117049: PLUS
117050: PPUSH
117051: CALL_OW 1
117055: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
117056: LD_ADDR_EXP 215
117060: PUSH
117061: LD_EXP 215
117065: PPUSH
117066: LD_VAR 0 5
117070: PUSH
117071: LD_EXP 215
117075: PUSH
117076: LD_VAR 0 5
117080: ARRAY
117081: PUSH
117082: LD_INT 1
117084: PLUS
117085: PUSH
117086: EMPTY
117087: LIST
117088: LIST
117089: PPUSH
117090: LD_VAR 0 2
117094: PUSH
117095: LD_VAR 0 4
117099: ARRAY
117100: PUSH
117101: LD_VAR 0 2
117105: PUSH
117106: LD_VAR 0 4
117110: ARRAY
117111: PPUSH
117112: CALL_OW 255
117116: PUSH
117117: EMPTY
117118: LIST
117119: LIST
117120: PPUSH
117121: CALL 70150 0 3
117125: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
117126: LD_VAR 0 2
117130: PUSH
117131: LD_VAR 0 4
117135: ARRAY
117136: PPUSH
117137: LD_VAR 0 1
117141: PPUSH
117142: CALL_OW 255
117146: PPUSH
117147: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
117151: LD_VAR 0 2
117155: PUSH
117156: LD_VAR 0 4
117160: ARRAY
117161: PPUSH
117162: CALL_OW 141
// end ;
117166: GO 116998
117168: POP
117169: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117170: LD_VAR 0 1
117174: PPUSH
117175: LD_EXP 215
117179: PUSH
117180: LD_VAR 0 5
117184: ARRAY
117185: PUSH
117186: LD_INT 0
117188: PLUS
117189: PPUSH
117190: CALL_OW 505
// end ;
117194: LD_VAR 0 3
117198: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117199: LD_INT 0
117201: PPUSH
117202: PPUSH
117203: PPUSH
117204: PPUSH
// if not hack in hackTanks then
117205: LD_VAR 0 1
117209: PUSH
117210: LD_EXP 214
117214: IN
117215: NOT
117216: IFFALSE 117220
// exit ;
117218: GO 117460
// index := GetElementIndex ( hackTanks , hack ) ;
117220: LD_ADDR_VAR 0 4
117224: PUSH
117225: LD_EXP 214
117229: PPUSH
117230: LD_VAR 0 1
117234: PPUSH
117235: CALL 69935 0 2
117239: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117240: LD_ADDR_VAR 0 3
117244: PUSH
117245: DOUBLE
117246: LD_EXP 215
117250: PUSH
117251: LD_VAR 0 4
117255: ARRAY
117256: INC
117257: ST_TO_ADDR
117258: LD_INT 1
117260: PUSH
117261: FOR_DOWNTO
117262: IFFALSE 117434
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117264: LD_ADDR_VAR 0 5
117268: PUSH
117269: LD_EXP 215
117273: PUSH
117274: LD_VAR 0 4
117278: ARRAY
117279: PUSH
117280: LD_VAR 0 3
117284: ARRAY
117285: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117286: LD_VAR 0 5
117290: PUSH
117291: LD_INT 1
117293: ARRAY
117294: PPUSH
117295: CALL_OW 302
117299: NOT
117300: PUSH
117301: LD_VAR 0 5
117305: PUSH
117306: LD_INT 1
117308: ARRAY
117309: PPUSH
117310: CALL_OW 255
117314: PUSH
117315: LD_VAR 0 1
117319: PPUSH
117320: CALL_OW 255
117324: NONEQUAL
117325: OR
117326: IFFALSE 117432
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117328: LD_VAR 0 5
117332: PUSH
117333: LD_INT 1
117335: ARRAY
117336: PPUSH
117337: CALL_OW 305
117341: PUSH
117342: LD_VAR 0 5
117346: PUSH
117347: LD_INT 1
117349: ARRAY
117350: PPUSH
117351: CALL_OW 255
117355: PUSH
117356: LD_VAR 0 1
117360: PPUSH
117361: CALL_OW 255
117365: EQUAL
117366: AND
117367: IFFALSE 117391
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117369: LD_VAR 0 5
117373: PUSH
117374: LD_INT 1
117376: ARRAY
117377: PPUSH
117378: LD_VAR 0 5
117382: PUSH
117383: LD_INT 2
117385: ARRAY
117386: PPUSH
117387: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117391: LD_ADDR_EXP 215
117395: PUSH
117396: LD_EXP 215
117400: PPUSH
117401: LD_VAR 0 4
117405: PPUSH
117406: LD_EXP 215
117410: PUSH
117411: LD_VAR 0 4
117415: ARRAY
117416: PPUSH
117417: LD_VAR 0 3
117421: PPUSH
117422: CALL_OW 3
117426: PPUSH
117427: CALL_OW 1
117431: ST_TO_ADDR
// end ; end ;
117432: GO 117261
117434: POP
117435: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117436: LD_VAR 0 1
117440: PPUSH
117441: LD_EXP 215
117445: PUSH
117446: LD_VAR 0 4
117450: ARRAY
117451: PUSH
117452: LD_INT 0
117454: PLUS
117455: PPUSH
117456: CALL_OW 505
// end ;
117460: LD_VAR 0 2
117464: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117465: LD_INT 0
117467: PPUSH
117468: PPUSH
117469: PPUSH
117470: PPUSH
// if not hack in hackTanks then
117471: LD_VAR 0 1
117475: PUSH
117476: LD_EXP 214
117480: IN
117481: NOT
117482: IFFALSE 117486
// exit ;
117484: GO 117571
// index := GetElementIndex ( hackTanks , hack ) ;
117486: LD_ADDR_VAR 0 5
117490: PUSH
117491: LD_EXP 214
117495: PPUSH
117496: LD_VAR 0 1
117500: PPUSH
117501: CALL 69935 0 2
117505: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117506: LD_ADDR_VAR 0 4
117510: PUSH
117511: DOUBLE
117512: LD_INT 1
117514: DEC
117515: ST_TO_ADDR
117516: LD_EXP 215
117520: PUSH
117521: LD_VAR 0 5
117525: ARRAY
117526: PUSH
117527: FOR_TO
117528: IFFALSE 117569
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117530: LD_EXP 215
117534: PUSH
117535: LD_VAR 0 5
117539: ARRAY
117540: PUSH
117541: LD_VAR 0 4
117545: ARRAY
117546: PUSH
117547: LD_INT 1
117549: ARRAY
117550: PUSH
117551: LD_VAR 0 2
117555: EQUAL
117556: IFFALSE 117567
// KillUnit ( vehicle ) ;
117558: LD_VAR 0 2
117562: PPUSH
117563: CALL_OW 66
117567: GO 117527
117569: POP
117570: POP
// end ;
117571: LD_VAR 0 3
117575: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
117576: LD_EXP 219
117580: NOT
117581: IFFALSE 117616
117583: GO 117585
117585: DISABLE
// begin initMiner := true ;
117586: LD_ADDR_EXP 219
117590: PUSH
117591: LD_INT 1
117593: ST_TO_ADDR
// minersList := [ ] ;
117594: LD_ADDR_EXP 220
117598: PUSH
117599: EMPTY
117600: ST_TO_ADDR
// minerMinesList := [ ] ;
117601: LD_ADDR_EXP 221
117605: PUSH
117606: EMPTY
117607: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
117608: LD_ADDR_EXP 222
117612: PUSH
117613: LD_INT 5
117615: ST_TO_ADDR
// end ;
117616: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
117617: LD_EXP 219
117621: PUSH
117622: LD_INT 34
117624: PUSH
117625: LD_EXP 102
117629: PUSH
117630: EMPTY
117631: LIST
117632: LIST
117633: PPUSH
117634: CALL_OW 69
117638: AND
117639: IFFALSE 118102
117641: GO 117643
117643: DISABLE
117644: LD_INT 0
117646: PPUSH
117647: PPUSH
117648: PPUSH
117649: PPUSH
// begin enable ;
117650: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117651: LD_ADDR_VAR 0 1
117655: PUSH
117656: LD_INT 34
117658: PUSH
117659: LD_EXP 102
117663: PUSH
117664: EMPTY
117665: LIST
117666: LIST
117667: PPUSH
117668: CALL_OW 69
117672: PUSH
117673: FOR_IN
117674: IFFALSE 117746
// begin if not i in minersList then
117676: LD_VAR 0 1
117680: PUSH
117681: LD_EXP 220
117685: IN
117686: NOT
117687: IFFALSE 117744
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117689: LD_ADDR_EXP 220
117693: PUSH
117694: LD_EXP 220
117698: PPUSH
117699: LD_EXP 220
117703: PUSH
117704: LD_INT 1
117706: PLUS
117707: PPUSH
117708: LD_VAR 0 1
117712: PPUSH
117713: CALL_OW 1
117717: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117718: LD_ADDR_EXP 221
117722: PUSH
117723: LD_EXP 221
117727: PPUSH
117728: LD_EXP 221
117732: PUSH
117733: LD_INT 1
117735: PLUS
117736: PPUSH
117737: EMPTY
117738: PPUSH
117739: CALL_OW 1
117743: ST_TO_ADDR
// end end ;
117744: GO 117673
117746: POP
117747: POP
// for i := minerMinesList downto 1 do
117748: LD_ADDR_VAR 0 1
117752: PUSH
117753: DOUBLE
117754: LD_EXP 221
117758: INC
117759: ST_TO_ADDR
117760: LD_INT 1
117762: PUSH
117763: FOR_DOWNTO
117764: IFFALSE 118100
// begin if IsLive ( minersList [ i ] ) then
117766: LD_EXP 220
117770: PUSH
117771: LD_VAR 0 1
117775: ARRAY
117776: PPUSH
117777: CALL_OW 300
117781: IFFALSE 117809
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
117783: LD_EXP 220
117787: PUSH
117788: LD_VAR 0 1
117792: ARRAY
117793: PPUSH
117794: LD_EXP 221
117798: PUSH
117799: LD_VAR 0 1
117803: ARRAY
117804: PPUSH
117805: CALL_OW 505
// if not minerMinesList [ i ] then
117809: LD_EXP 221
117813: PUSH
117814: LD_VAR 0 1
117818: ARRAY
117819: NOT
117820: IFFALSE 117824
// continue ;
117822: GO 117763
// for j := minerMinesList [ i ] downto 1 do
117824: LD_ADDR_VAR 0 2
117828: PUSH
117829: DOUBLE
117830: LD_EXP 221
117834: PUSH
117835: LD_VAR 0 1
117839: ARRAY
117840: INC
117841: ST_TO_ADDR
117842: LD_INT 1
117844: PUSH
117845: FOR_DOWNTO
117846: IFFALSE 118096
// begin side := GetSide ( minersList [ i ] ) ;
117848: LD_ADDR_VAR 0 3
117852: PUSH
117853: LD_EXP 220
117857: PUSH
117858: LD_VAR 0 1
117862: ARRAY
117863: PPUSH
117864: CALL_OW 255
117868: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117869: LD_ADDR_VAR 0 4
117873: PUSH
117874: LD_EXP 221
117878: PUSH
117879: LD_VAR 0 1
117883: ARRAY
117884: PUSH
117885: LD_VAR 0 2
117889: ARRAY
117890: PUSH
117891: LD_INT 1
117893: ARRAY
117894: PPUSH
117895: LD_EXP 221
117899: PUSH
117900: LD_VAR 0 1
117904: ARRAY
117905: PUSH
117906: LD_VAR 0 2
117910: ARRAY
117911: PUSH
117912: LD_INT 2
117914: ARRAY
117915: PPUSH
117916: CALL_OW 428
117920: ST_TO_ADDR
// if not tmp then
117921: LD_VAR 0 4
117925: NOT
117926: IFFALSE 117930
// continue ;
117928: GO 117845
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117930: LD_VAR 0 4
117934: PUSH
117935: LD_INT 81
117937: PUSH
117938: LD_VAR 0 3
117942: PUSH
117943: EMPTY
117944: LIST
117945: LIST
117946: PPUSH
117947: CALL_OW 69
117951: IN
117952: PUSH
117953: LD_EXP 221
117957: PUSH
117958: LD_VAR 0 1
117962: ARRAY
117963: PUSH
117964: LD_VAR 0 2
117968: ARRAY
117969: PUSH
117970: LD_INT 1
117972: ARRAY
117973: PPUSH
117974: LD_EXP 221
117978: PUSH
117979: LD_VAR 0 1
117983: ARRAY
117984: PUSH
117985: LD_VAR 0 2
117989: ARRAY
117990: PUSH
117991: LD_INT 2
117993: ARRAY
117994: PPUSH
117995: CALL_OW 458
117999: AND
118000: IFFALSE 118094
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
118002: LD_EXP 221
118006: PUSH
118007: LD_VAR 0 1
118011: ARRAY
118012: PUSH
118013: LD_VAR 0 2
118017: ARRAY
118018: PUSH
118019: LD_INT 1
118021: ARRAY
118022: PPUSH
118023: LD_EXP 221
118027: PUSH
118028: LD_VAR 0 1
118032: ARRAY
118033: PUSH
118034: LD_VAR 0 2
118038: ARRAY
118039: PUSH
118040: LD_INT 2
118042: ARRAY
118043: PPUSH
118044: LD_VAR 0 3
118048: PPUSH
118049: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
118053: LD_ADDR_EXP 221
118057: PUSH
118058: LD_EXP 221
118062: PPUSH
118063: LD_VAR 0 1
118067: PPUSH
118068: LD_EXP 221
118072: PUSH
118073: LD_VAR 0 1
118077: ARRAY
118078: PPUSH
118079: LD_VAR 0 2
118083: PPUSH
118084: CALL_OW 3
118088: PPUSH
118089: CALL_OW 1
118093: ST_TO_ADDR
// end ; end ;
118094: GO 117845
118096: POP
118097: POP
// end ;
118098: GO 117763
118100: POP
118101: POP
// end ;
118102: PPOPN 4
118104: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
118105: LD_INT 0
118107: PPUSH
118108: PPUSH
// result := false ;
118109: LD_ADDR_VAR 0 4
118113: PUSH
118114: LD_INT 0
118116: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
118117: LD_VAR 0 1
118121: PPUSH
118122: CALL_OW 264
118126: PUSH
118127: LD_EXP 102
118131: EQUAL
118132: NOT
118133: IFFALSE 118137
// exit ;
118135: GO 118377
// index := GetElementIndex ( minersList , unit ) ;
118137: LD_ADDR_VAR 0 5
118141: PUSH
118142: LD_EXP 220
118146: PPUSH
118147: LD_VAR 0 1
118151: PPUSH
118152: CALL 69935 0 2
118156: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
118157: LD_EXP 221
118161: PUSH
118162: LD_VAR 0 5
118166: ARRAY
118167: PUSH
118168: LD_EXP 222
118172: GREATEREQUAL
118173: IFFALSE 118177
// exit ;
118175: GO 118377
// ComMoveXY ( unit , x , y ) ;
118177: LD_VAR 0 1
118181: PPUSH
118182: LD_VAR 0 2
118186: PPUSH
118187: LD_VAR 0 3
118191: PPUSH
118192: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118196: LD_INT 35
118198: PPUSH
118199: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118203: LD_VAR 0 1
118207: PPUSH
118208: LD_VAR 0 2
118212: PPUSH
118213: LD_VAR 0 3
118217: PPUSH
118218: CALL 99999 0 3
118222: NOT
118223: PUSH
118224: LD_VAR 0 1
118228: PPUSH
118229: CALL_OW 314
118233: AND
118234: IFFALSE 118238
// exit ;
118236: GO 118377
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118238: LD_VAR 0 2
118242: PPUSH
118243: LD_VAR 0 3
118247: PPUSH
118248: CALL_OW 428
118252: PUSH
118253: LD_VAR 0 1
118257: EQUAL
118258: PUSH
118259: LD_VAR 0 1
118263: PPUSH
118264: CALL_OW 314
118268: NOT
118269: AND
118270: IFFALSE 118196
// PlaySoundXY ( x , y , PlantMine ) ;
118272: LD_VAR 0 2
118276: PPUSH
118277: LD_VAR 0 3
118281: PPUSH
118282: LD_STRING PlantMine
118284: PPUSH
118285: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
118289: LD_VAR 0 2
118293: PPUSH
118294: LD_VAR 0 3
118298: PPUSH
118299: LD_VAR 0 1
118303: PPUSH
118304: CALL_OW 255
118308: PPUSH
118309: LD_INT 0
118311: PPUSH
118312: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118316: LD_ADDR_EXP 221
118320: PUSH
118321: LD_EXP 221
118325: PPUSH
118326: LD_VAR 0 5
118330: PUSH
118331: LD_EXP 221
118335: PUSH
118336: LD_VAR 0 5
118340: ARRAY
118341: PUSH
118342: LD_INT 1
118344: PLUS
118345: PUSH
118346: EMPTY
118347: LIST
118348: LIST
118349: PPUSH
118350: LD_VAR 0 2
118354: PUSH
118355: LD_VAR 0 3
118359: PUSH
118360: EMPTY
118361: LIST
118362: LIST
118363: PPUSH
118364: CALL 70150 0 3
118368: ST_TO_ADDR
// result := true ;
118369: LD_ADDR_VAR 0 4
118373: PUSH
118374: LD_INT 1
118376: ST_TO_ADDR
// end ;
118377: LD_VAR 0 4
118381: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118382: LD_INT 0
118384: PPUSH
118385: PPUSH
118386: PPUSH
// if not unit in minersList then
118387: LD_VAR 0 1
118391: PUSH
118392: LD_EXP 220
118396: IN
118397: NOT
118398: IFFALSE 118402
// exit ;
118400: GO 118794
// index := GetElementIndex ( minersList , unit ) ;
118402: LD_ADDR_VAR 0 6
118406: PUSH
118407: LD_EXP 220
118411: PPUSH
118412: LD_VAR 0 1
118416: PPUSH
118417: CALL 69935 0 2
118421: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118422: LD_ADDR_VAR 0 5
118426: PUSH
118427: DOUBLE
118428: LD_EXP 221
118432: PUSH
118433: LD_VAR 0 6
118437: ARRAY
118438: INC
118439: ST_TO_ADDR
118440: LD_INT 1
118442: PUSH
118443: FOR_DOWNTO
118444: IFFALSE 118605
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
118446: LD_EXP 221
118450: PUSH
118451: LD_VAR 0 6
118455: ARRAY
118456: PUSH
118457: LD_VAR 0 5
118461: ARRAY
118462: PUSH
118463: LD_INT 1
118465: ARRAY
118466: PUSH
118467: LD_VAR 0 2
118471: EQUAL
118472: PUSH
118473: LD_EXP 221
118477: PUSH
118478: LD_VAR 0 6
118482: ARRAY
118483: PUSH
118484: LD_VAR 0 5
118488: ARRAY
118489: PUSH
118490: LD_INT 2
118492: ARRAY
118493: PUSH
118494: LD_VAR 0 3
118498: EQUAL
118499: AND
118500: IFFALSE 118603
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118502: LD_EXP 221
118506: PUSH
118507: LD_VAR 0 6
118511: ARRAY
118512: PUSH
118513: LD_VAR 0 5
118517: ARRAY
118518: PUSH
118519: LD_INT 1
118521: ARRAY
118522: PPUSH
118523: LD_EXP 221
118527: PUSH
118528: LD_VAR 0 6
118532: ARRAY
118533: PUSH
118534: LD_VAR 0 5
118538: ARRAY
118539: PUSH
118540: LD_INT 2
118542: ARRAY
118543: PPUSH
118544: LD_VAR 0 1
118548: PPUSH
118549: CALL_OW 255
118553: PPUSH
118554: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118558: LD_ADDR_EXP 221
118562: PUSH
118563: LD_EXP 221
118567: PPUSH
118568: LD_VAR 0 6
118572: PPUSH
118573: LD_EXP 221
118577: PUSH
118578: LD_VAR 0 6
118582: ARRAY
118583: PPUSH
118584: LD_VAR 0 5
118588: PPUSH
118589: CALL_OW 3
118593: PPUSH
118594: CALL_OW 1
118598: ST_TO_ADDR
// exit ;
118599: POP
118600: POP
118601: GO 118794
// end ; end ;
118603: GO 118443
118605: POP
118606: POP
// for i := minerMinesList [ index ] downto 1 do
118607: LD_ADDR_VAR 0 5
118611: PUSH
118612: DOUBLE
118613: LD_EXP 221
118617: PUSH
118618: LD_VAR 0 6
118622: ARRAY
118623: INC
118624: ST_TO_ADDR
118625: LD_INT 1
118627: PUSH
118628: FOR_DOWNTO
118629: IFFALSE 118792
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118631: LD_EXP 221
118635: PUSH
118636: LD_VAR 0 6
118640: ARRAY
118641: PUSH
118642: LD_VAR 0 5
118646: ARRAY
118647: PUSH
118648: LD_INT 1
118650: ARRAY
118651: PPUSH
118652: LD_EXP 221
118656: PUSH
118657: LD_VAR 0 6
118661: ARRAY
118662: PUSH
118663: LD_VAR 0 5
118667: ARRAY
118668: PUSH
118669: LD_INT 2
118671: ARRAY
118672: PPUSH
118673: LD_VAR 0 2
118677: PPUSH
118678: LD_VAR 0 3
118682: PPUSH
118683: CALL_OW 298
118687: PUSH
118688: LD_INT 6
118690: LESS
118691: IFFALSE 118790
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118693: LD_EXP 221
118697: PUSH
118698: LD_VAR 0 6
118702: ARRAY
118703: PUSH
118704: LD_VAR 0 5
118708: ARRAY
118709: PUSH
118710: LD_INT 1
118712: ARRAY
118713: PPUSH
118714: LD_EXP 221
118718: PUSH
118719: LD_VAR 0 6
118723: ARRAY
118724: PUSH
118725: LD_VAR 0 5
118729: ARRAY
118730: PUSH
118731: LD_INT 2
118733: ARRAY
118734: PPUSH
118735: LD_VAR 0 1
118739: PPUSH
118740: CALL_OW 255
118744: PPUSH
118745: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118749: LD_ADDR_EXP 221
118753: PUSH
118754: LD_EXP 221
118758: PPUSH
118759: LD_VAR 0 6
118763: PPUSH
118764: LD_EXP 221
118768: PUSH
118769: LD_VAR 0 6
118773: ARRAY
118774: PPUSH
118775: LD_VAR 0 5
118779: PPUSH
118780: CALL_OW 3
118784: PPUSH
118785: CALL_OW 1
118789: ST_TO_ADDR
// end ; end ;
118790: GO 118628
118792: POP
118793: POP
// end ;
118794: LD_VAR 0 4
118798: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118799: LD_INT 0
118801: PPUSH
118802: PPUSH
118803: PPUSH
118804: PPUSH
118805: PPUSH
118806: PPUSH
118807: PPUSH
118808: PPUSH
118809: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118810: LD_VAR 0 1
118814: PPUSH
118815: CALL_OW 264
118819: PUSH
118820: LD_EXP 102
118824: EQUAL
118825: NOT
118826: PUSH
118827: LD_VAR 0 1
118831: PUSH
118832: LD_EXP 220
118836: IN
118837: NOT
118838: OR
118839: IFFALSE 118843
// exit ;
118841: GO 119165
// index := GetElementIndex ( minersList , unit ) ;
118843: LD_ADDR_VAR 0 6
118847: PUSH
118848: LD_EXP 220
118852: PPUSH
118853: LD_VAR 0 1
118857: PPUSH
118858: CALL 69935 0 2
118862: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118863: LD_ADDR_VAR 0 8
118867: PUSH
118868: LD_EXP 222
118872: PUSH
118873: LD_EXP 221
118877: PUSH
118878: LD_VAR 0 6
118882: ARRAY
118883: MINUS
118884: ST_TO_ADDR
// if not minesFreeAmount then
118885: LD_VAR 0 8
118889: NOT
118890: IFFALSE 118894
// exit ;
118892: GO 119165
// tmp := [ ] ;
118894: LD_ADDR_VAR 0 7
118898: PUSH
118899: EMPTY
118900: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118901: LD_ADDR_VAR 0 5
118905: PUSH
118906: DOUBLE
118907: LD_INT 1
118909: DEC
118910: ST_TO_ADDR
118911: LD_VAR 0 8
118915: PUSH
118916: FOR_TO
118917: IFFALSE 119112
// begin _d := rand ( 0 , 5 ) ;
118919: LD_ADDR_VAR 0 11
118923: PUSH
118924: LD_INT 0
118926: PPUSH
118927: LD_INT 5
118929: PPUSH
118930: CALL_OW 12
118934: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118935: LD_ADDR_VAR 0 12
118939: PUSH
118940: LD_INT 2
118942: PPUSH
118943: LD_INT 6
118945: PPUSH
118946: CALL_OW 12
118950: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118951: LD_ADDR_VAR 0 9
118955: PUSH
118956: LD_VAR 0 2
118960: PPUSH
118961: LD_VAR 0 11
118965: PPUSH
118966: LD_VAR 0 12
118970: PPUSH
118971: CALL_OW 272
118975: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118976: LD_ADDR_VAR 0 10
118980: PUSH
118981: LD_VAR 0 3
118985: PPUSH
118986: LD_VAR 0 11
118990: PPUSH
118991: LD_VAR 0 12
118995: PPUSH
118996: CALL_OW 273
119000: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
119001: LD_VAR 0 9
119005: PPUSH
119006: LD_VAR 0 10
119010: PPUSH
119011: CALL_OW 488
119015: PUSH
119016: LD_VAR 0 9
119020: PUSH
119021: LD_VAR 0 10
119025: PUSH
119026: EMPTY
119027: LIST
119028: LIST
119029: PUSH
119030: LD_VAR 0 7
119034: IN
119035: NOT
119036: AND
119037: PUSH
119038: LD_VAR 0 9
119042: PPUSH
119043: LD_VAR 0 10
119047: PPUSH
119048: CALL_OW 458
119052: NOT
119053: AND
119054: IFFALSE 119096
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
119056: LD_ADDR_VAR 0 7
119060: PUSH
119061: LD_VAR 0 7
119065: PPUSH
119066: LD_VAR 0 7
119070: PUSH
119071: LD_INT 1
119073: PLUS
119074: PPUSH
119075: LD_VAR 0 9
119079: PUSH
119080: LD_VAR 0 10
119084: PUSH
119085: EMPTY
119086: LIST
119087: LIST
119088: PPUSH
119089: CALL_OW 1
119093: ST_TO_ADDR
119094: GO 119110
// i := i - 1 ;
119096: LD_ADDR_VAR 0 5
119100: PUSH
119101: LD_VAR 0 5
119105: PUSH
119106: LD_INT 1
119108: MINUS
119109: ST_TO_ADDR
// end ;
119110: GO 118916
119112: POP
119113: POP
// for i in tmp do
119114: LD_ADDR_VAR 0 5
119118: PUSH
119119: LD_VAR 0 7
119123: PUSH
119124: FOR_IN
119125: IFFALSE 119163
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
119127: LD_VAR 0 1
119131: PPUSH
119132: LD_VAR 0 5
119136: PUSH
119137: LD_INT 1
119139: ARRAY
119140: PPUSH
119141: LD_VAR 0 5
119145: PUSH
119146: LD_INT 2
119148: ARRAY
119149: PPUSH
119150: CALL 118105 0 3
119154: NOT
119155: IFFALSE 119161
// exit ;
119157: POP
119158: POP
119159: GO 119165
119161: GO 119124
119163: POP
119164: POP
// end ;
119165: LD_VAR 0 4
119169: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
119170: LD_INT 0
119172: PPUSH
119173: PPUSH
119174: PPUSH
119175: PPUSH
119176: PPUSH
119177: PPUSH
119178: PPUSH
// if not GetClass ( unit ) = class_sniper then
119179: LD_VAR 0 1
119183: PPUSH
119184: CALL_OW 257
119188: PUSH
119189: LD_INT 5
119191: EQUAL
119192: NOT
119193: IFFALSE 119197
// exit ;
119195: GO 119585
// dist := 8 ;
119197: LD_ADDR_VAR 0 5
119201: PUSH
119202: LD_INT 8
119204: ST_TO_ADDR
// viewRange := 12 ;
119205: LD_ADDR_VAR 0 7
119209: PUSH
119210: LD_INT 12
119212: ST_TO_ADDR
// side := GetSide ( unit ) ;
119213: LD_ADDR_VAR 0 6
119217: PUSH
119218: LD_VAR 0 1
119222: PPUSH
119223: CALL_OW 255
119227: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119228: LD_INT 61
119230: PPUSH
119231: LD_VAR 0 6
119235: PPUSH
119236: CALL_OW 321
119240: PUSH
119241: LD_INT 2
119243: EQUAL
119244: IFFALSE 119254
// viewRange := 16 ;
119246: LD_ADDR_VAR 0 7
119250: PUSH
119251: LD_INT 16
119253: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119254: LD_VAR 0 1
119258: PPUSH
119259: LD_VAR 0 2
119263: PPUSH
119264: LD_VAR 0 3
119268: PPUSH
119269: CALL_OW 297
119273: PUSH
119274: LD_VAR 0 5
119278: GREATER
119279: IFFALSE 119358
// begin ComMoveXY ( unit , x , y ) ;
119281: LD_VAR 0 1
119285: PPUSH
119286: LD_VAR 0 2
119290: PPUSH
119291: LD_VAR 0 3
119295: PPUSH
119296: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119300: LD_INT 35
119302: PPUSH
119303: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119307: LD_VAR 0 1
119311: PPUSH
119312: LD_VAR 0 2
119316: PPUSH
119317: LD_VAR 0 3
119321: PPUSH
119322: CALL 99999 0 3
119326: NOT
119327: IFFALSE 119331
// exit ;
119329: GO 119585
// until GetDistUnitXY ( unit , x , y ) < dist ;
119331: LD_VAR 0 1
119335: PPUSH
119336: LD_VAR 0 2
119340: PPUSH
119341: LD_VAR 0 3
119345: PPUSH
119346: CALL_OW 297
119350: PUSH
119351: LD_VAR 0 5
119355: LESS
119356: IFFALSE 119300
// end ; ComTurnXY ( unit , x , y ) ;
119358: LD_VAR 0 1
119362: PPUSH
119363: LD_VAR 0 2
119367: PPUSH
119368: LD_VAR 0 3
119372: PPUSH
119373: CALL_OW 118
// wait ( 5 ) ;
119377: LD_INT 5
119379: PPUSH
119380: CALL_OW 67
// _d := GetDir ( unit ) ;
119384: LD_ADDR_VAR 0 10
119388: PUSH
119389: LD_VAR 0 1
119393: PPUSH
119394: CALL_OW 254
119398: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
119399: LD_ADDR_VAR 0 8
119403: PUSH
119404: LD_VAR 0 1
119408: PPUSH
119409: CALL_OW 250
119413: PPUSH
119414: LD_VAR 0 10
119418: PPUSH
119419: LD_VAR 0 5
119423: PPUSH
119424: CALL_OW 272
119428: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
119429: LD_ADDR_VAR 0 9
119433: PUSH
119434: LD_VAR 0 1
119438: PPUSH
119439: CALL_OW 251
119443: PPUSH
119444: LD_VAR 0 10
119448: PPUSH
119449: LD_VAR 0 5
119453: PPUSH
119454: CALL_OW 273
119458: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119459: LD_VAR 0 8
119463: PPUSH
119464: LD_VAR 0 9
119468: PPUSH
119469: CALL_OW 488
119473: NOT
119474: IFFALSE 119478
// exit ;
119476: GO 119585
// ComAnimCustom ( unit , 1 ) ;
119478: LD_VAR 0 1
119482: PPUSH
119483: LD_INT 1
119485: PPUSH
119486: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119490: LD_VAR 0 8
119494: PPUSH
119495: LD_VAR 0 9
119499: PPUSH
119500: LD_VAR 0 6
119504: PPUSH
119505: LD_VAR 0 7
119509: PPUSH
119510: CALL_OW 330
// repeat wait ( 1 ) ;
119514: LD_INT 1
119516: PPUSH
119517: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
119521: LD_VAR 0 1
119525: PPUSH
119526: CALL_OW 316
119530: PUSH
119531: LD_VAR 0 1
119535: PPUSH
119536: CALL_OW 314
119540: OR
119541: PUSH
119542: LD_VAR 0 1
119546: PPUSH
119547: CALL_OW 302
119551: NOT
119552: OR
119553: PUSH
119554: LD_VAR 0 1
119558: PPUSH
119559: CALL_OW 301
119563: OR
119564: IFFALSE 119514
// RemoveSeeing ( _x , _y , side ) ;
119566: LD_VAR 0 8
119570: PPUSH
119571: LD_VAR 0 9
119575: PPUSH
119576: LD_VAR 0 6
119580: PPUSH
119581: CALL_OW 331
// end ; end_of_file
119585: LD_VAR 0 4
119589: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
119590: LD_INT 0
119592: PPUSH
119593: PPUSH
119594: PPUSH
119595: PPUSH
119596: PPUSH
119597: PPUSH
119598: PPUSH
119599: PPUSH
119600: PPUSH
119601: PPUSH
119602: PPUSH
119603: PPUSH
119604: PPUSH
119605: PPUSH
119606: PPUSH
119607: PPUSH
119608: PPUSH
119609: PPUSH
119610: PPUSH
119611: PPUSH
119612: PPUSH
119613: PPUSH
119614: PPUSH
119615: PPUSH
119616: PPUSH
119617: PPUSH
119618: PPUSH
119619: PPUSH
119620: PPUSH
119621: PPUSH
119622: PPUSH
119623: PPUSH
119624: PPUSH
119625: PPUSH
// if not list then
119626: LD_VAR 0 1
119630: NOT
119631: IFFALSE 119635
// exit ;
119633: GO 124294
// base := list [ 1 ] ;
119635: LD_ADDR_VAR 0 3
119639: PUSH
119640: LD_VAR 0 1
119644: PUSH
119645: LD_INT 1
119647: ARRAY
119648: ST_TO_ADDR
// group := list [ 2 ] ;
119649: LD_ADDR_VAR 0 4
119653: PUSH
119654: LD_VAR 0 1
119658: PUSH
119659: LD_INT 2
119661: ARRAY
119662: ST_TO_ADDR
// path := list [ 3 ] ;
119663: LD_ADDR_VAR 0 5
119667: PUSH
119668: LD_VAR 0 1
119672: PUSH
119673: LD_INT 3
119675: ARRAY
119676: ST_TO_ADDR
// flags := list [ 4 ] ;
119677: LD_ADDR_VAR 0 6
119681: PUSH
119682: LD_VAR 0 1
119686: PUSH
119687: LD_INT 4
119689: ARRAY
119690: ST_TO_ADDR
// mined := [ ] ;
119691: LD_ADDR_VAR 0 27
119695: PUSH
119696: EMPTY
119697: ST_TO_ADDR
// bombed := [ ] ;
119698: LD_ADDR_VAR 0 28
119702: PUSH
119703: EMPTY
119704: ST_TO_ADDR
// healers := [ ] ;
119705: LD_ADDR_VAR 0 31
119709: PUSH
119710: EMPTY
119711: ST_TO_ADDR
// to_heal := [ ] ;
119712: LD_ADDR_VAR 0 30
119716: PUSH
119717: EMPTY
119718: ST_TO_ADDR
// repairs := [ ] ;
119719: LD_ADDR_VAR 0 33
119723: PUSH
119724: EMPTY
119725: ST_TO_ADDR
// to_repair := [ ] ;
119726: LD_ADDR_VAR 0 32
119730: PUSH
119731: EMPTY
119732: ST_TO_ADDR
// if not group or not path then
119733: LD_VAR 0 4
119737: NOT
119738: PUSH
119739: LD_VAR 0 5
119743: NOT
119744: OR
119745: IFFALSE 119749
// exit ;
119747: GO 124294
// side := GetSide ( group [ 1 ] ) ;
119749: LD_ADDR_VAR 0 35
119753: PUSH
119754: LD_VAR 0 4
119758: PUSH
119759: LD_INT 1
119761: ARRAY
119762: PPUSH
119763: CALL_OW 255
119767: ST_TO_ADDR
// if flags then
119768: LD_VAR 0 6
119772: IFFALSE 119916
// begin f_ignore_area := flags [ 1 ] ;
119774: LD_ADDR_VAR 0 17
119778: PUSH
119779: LD_VAR 0 6
119783: PUSH
119784: LD_INT 1
119786: ARRAY
119787: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
119788: LD_ADDR_VAR 0 18
119792: PUSH
119793: LD_VAR 0 6
119797: PUSH
119798: LD_INT 2
119800: ARRAY
119801: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
119802: LD_ADDR_VAR 0 19
119806: PUSH
119807: LD_VAR 0 6
119811: PUSH
119812: LD_INT 3
119814: ARRAY
119815: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
119816: LD_ADDR_VAR 0 20
119820: PUSH
119821: LD_VAR 0 6
119825: PUSH
119826: LD_INT 4
119828: ARRAY
119829: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
119830: LD_ADDR_VAR 0 21
119834: PUSH
119835: LD_VAR 0 6
119839: PUSH
119840: LD_INT 5
119842: ARRAY
119843: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
119844: LD_ADDR_VAR 0 22
119848: PUSH
119849: LD_VAR 0 6
119853: PUSH
119854: LD_INT 6
119856: ARRAY
119857: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
119858: LD_ADDR_VAR 0 23
119862: PUSH
119863: LD_VAR 0 6
119867: PUSH
119868: LD_INT 7
119870: ARRAY
119871: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
119872: LD_ADDR_VAR 0 24
119876: PUSH
119877: LD_VAR 0 6
119881: PUSH
119882: LD_INT 8
119884: ARRAY
119885: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
119886: LD_ADDR_VAR 0 25
119890: PUSH
119891: LD_VAR 0 6
119895: PUSH
119896: LD_INT 9
119898: ARRAY
119899: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
119900: LD_ADDR_VAR 0 26
119904: PUSH
119905: LD_VAR 0 6
119909: PUSH
119910: LD_INT 10
119912: ARRAY
119913: ST_TO_ADDR
// end else
119914: GO 119996
// begin f_ignore_area := false ;
119916: LD_ADDR_VAR 0 17
119920: PUSH
119921: LD_INT 0
119923: ST_TO_ADDR
// f_capture := false ;
119924: LD_ADDR_VAR 0 18
119928: PUSH
119929: LD_INT 0
119931: ST_TO_ADDR
// f_ignore_civ := false ;
119932: LD_ADDR_VAR 0 19
119936: PUSH
119937: LD_INT 0
119939: ST_TO_ADDR
// f_murder := false ;
119940: LD_ADDR_VAR 0 20
119944: PUSH
119945: LD_INT 0
119947: ST_TO_ADDR
// f_mines := false ;
119948: LD_ADDR_VAR 0 21
119952: PUSH
119953: LD_INT 0
119955: ST_TO_ADDR
// f_repair := false ;
119956: LD_ADDR_VAR 0 22
119960: PUSH
119961: LD_INT 0
119963: ST_TO_ADDR
// f_heal := false ;
119964: LD_ADDR_VAR 0 23
119968: PUSH
119969: LD_INT 0
119971: ST_TO_ADDR
// f_spacetime := false ;
119972: LD_ADDR_VAR 0 24
119976: PUSH
119977: LD_INT 0
119979: ST_TO_ADDR
// f_attack_depot := false ;
119980: LD_ADDR_VAR 0 25
119984: PUSH
119985: LD_INT 0
119987: ST_TO_ADDR
// f_crawl := false ;
119988: LD_ADDR_VAR 0 26
119992: PUSH
119993: LD_INT 0
119995: ST_TO_ADDR
// end ; if f_heal then
119996: LD_VAR 0 23
120000: IFFALSE 120027
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
120002: LD_ADDR_VAR 0 31
120006: PUSH
120007: LD_VAR 0 4
120011: PPUSH
120012: LD_INT 25
120014: PUSH
120015: LD_INT 4
120017: PUSH
120018: EMPTY
120019: LIST
120020: LIST
120021: PPUSH
120022: CALL_OW 72
120026: ST_TO_ADDR
// if f_repair then
120027: LD_VAR 0 22
120031: IFFALSE 120058
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
120033: LD_ADDR_VAR 0 33
120037: PUSH
120038: LD_VAR 0 4
120042: PPUSH
120043: LD_INT 25
120045: PUSH
120046: LD_INT 3
120048: PUSH
120049: EMPTY
120050: LIST
120051: LIST
120052: PPUSH
120053: CALL_OW 72
120057: ST_TO_ADDR
// units_path := [ ] ;
120058: LD_ADDR_VAR 0 16
120062: PUSH
120063: EMPTY
120064: ST_TO_ADDR
// for i = 1 to group do
120065: LD_ADDR_VAR 0 7
120069: PUSH
120070: DOUBLE
120071: LD_INT 1
120073: DEC
120074: ST_TO_ADDR
120075: LD_VAR 0 4
120079: PUSH
120080: FOR_TO
120081: IFFALSE 120110
// units_path := Replace ( units_path , i , path ) ;
120083: LD_ADDR_VAR 0 16
120087: PUSH
120088: LD_VAR 0 16
120092: PPUSH
120093: LD_VAR 0 7
120097: PPUSH
120098: LD_VAR 0 5
120102: PPUSH
120103: CALL_OW 1
120107: ST_TO_ADDR
120108: GO 120080
120110: POP
120111: POP
// repeat for i = group downto 1 do
120112: LD_ADDR_VAR 0 7
120116: PUSH
120117: DOUBLE
120118: LD_VAR 0 4
120122: INC
120123: ST_TO_ADDR
120124: LD_INT 1
120126: PUSH
120127: FOR_DOWNTO
120128: IFFALSE 124250
// begin wait ( 5 ) ;
120130: LD_INT 5
120132: PPUSH
120133: CALL_OW 67
// tmp := [ ] ;
120137: LD_ADDR_VAR 0 14
120141: PUSH
120142: EMPTY
120143: ST_TO_ADDR
// attacking := false ;
120144: LD_ADDR_VAR 0 29
120148: PUSH
120149: LD_INT 0
120151: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
120152: LD_VAR 0 4
120156: PUSH
120157: LD_VAR 0 7
120161: ARRAY
120162: PPUSH
120163: CALL_OW 301
120167: PUSH
120168: LD_VAR 0 4
120172: PUSH
120173: LD_VAR 0 7
120177: ARRAY
120178: NOT
120179: OR
120180: IFFALSE 120289
// begin if GetType ( group [ i ] ) = unit_human then
120182: LD_VAR 0 4
120186: PUSH
120187: LD_VAR 0 7
120191: ARRAY
120192: PPUSH
120193: CALL_OW 247
120197: PUSH
120198: LD_INT 1
120200: EQUAL
120201: IFFALSE 120247
// begin to_heal := to_heal diff group [ i ] ;
120203: LD_ADDR_VAR 0 30
120207: PUSH
120208: LD_VAR 0 30
120212: PUSH
120213: LD_VAR 0 4
120217: PUSH
120218: LD_VAR 0 7
120222: ARRAY
120223: DIFF
120224: ST_TO_ADDR
// healers := healers diff group [ i ] ;
120225: LD_ADDR_VAR 0 31
120229: PUSH
120230: LD_VAR 0 31
120234: PUSH
120235: LD_VAR 0 4
120239: PUSH
120240: LD_VAR 0 7
120244: ARRAY
120245: DIFF
120246: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
120247: LD_ADDR_VAR 0 4
120251: PUSH
120252: LD_VAR 0 4
120256: PPUSH
120257: LD_VAR 0 7
120261: PPUSH
120262: CALL_OW 3
120266: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
120267: LD_ADDR_VAR 0 16
120271: PUSH
120272: LD_VAR 0 16
120276: PPUSH
120277: LD_VAR 0 7
120281: PPUSH
120282: CALL_OW 3
120286: ST_TO_ADDR
// continue ;
120287: GO 120127
// end ; if f_repair then
120289: LD_VAR 0 22
120293: IFFALSE 120782
// begin if GetType ( group [ i ] ) = unit_vehicle then
120295: LD_VAR 0 4
120299: PUSH
120300: LD_VAR 0 7
120304: ARRAY
120305: PPUSH
120306: CALL_OW 247
120310: PUSH
120311: LD_INT 2
120313: EQUAL
120314: IFFALSE 120504
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
120316: LD_VAR 0 4
120320: PUSH
120321: LD_VAR 0 7
120325: ARRAY
120326: PPUSH
120327: CALL_OW 256
120331: PUSH
120332: LD_INT 700
120334: LESS
120335: PUSH
120336: LD_VAR 0 4
120340: PUSH
120341: LD_VAR 0 7
120345: ARRAY
120346: PUSH
120347: LD_VAR 0 32
120351: IN
120352: NOT
120353: AND
120354: IFFALSE 120378
// to_repair := to_repair union group [ i ] ;
120356: LD_ADDR_VAR 0 32
120360: PUSH
120361: LD_VAR 0 32
120365: PUSH
120366: LD_VAR 0 4
120370: PUSH
120371: LD_VAR 0 7
120375: ARRAY
120376: UNION
120377: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
120378: LD_VAR 0 4
120382: PUSH
120383: LD_VAR 0 7
120387: ARRAY
120388: PPUSH
120389: CALL_OW 256
120393: PUSH
120394: LD_INT 1000
120396: EQUAL
120397: PUSH
120398: LD_VAR 0 4
120402: PUSH
120403: LD_VAR 0 7
120407: ARRAY
120408: PUSH
120409: LD_VAR 0 32
120413: IN
120414: AND
120415: IFFALSE 120439
// to_repair := to_repair diff group [ i ] ;
120417: LD_ADDR_VAR 0 32
120421: PUSH
120422: LD_VAR 0 32
120426: PUSH
120427: LD_VAR 0 4
120431: PUSH
120432: LD_VAR 0 7
120436: ARRAY
120437: DIFF
120438: ST_TO_ADDR
// if group [ i ] in to_repair then
120439: LD_VAR 0 4
120443: PUSH
120444: LD_VAR 0 7
120448: ARRAY
120449: PUSH
120450: LD_VAR 0 32
120454: IN
120455: IFFALSE 120502
// begin if not IsInArea ( group [ i ] , f_repair ) then
120457: LD_VAR 0 4
120461: PUSH
120462: LD_VAR 0 7
120466: ARRAY
120467: PPUSH
120468: LD_VAR 0 22
120472: PPUSH
120473: CALL_OW 308
120477: NOT
120478: IFFALSE 120500
// ComMoveToArea ( group [ i ] , f_repair ) ;
120480: LD_VAR 0 4
120484: PUSH
120485: LD_VAR 0 7
120489: ARRAY
120490: PPUSH
120491: LD_VAR 0 22
120495: PPUSH
120496: CALL_OW 113
// continue ;
120500: GO 120127
// end ; end else
120502: GO 120782
// if group [ i ] in repairs then
120504: LD_VAR 0 4
120508: PUSH
120509: LD_VAR 0 7
120513: ARRAY
120514: PUSH
120515: LD_VAR 0 33
120519: IN
120520: IFFALSE 120782
// begin if IsInUnit ( group [ i ] ) then
120522: LD_VAR 0 4
120526: PUSH
120527: LD_VAR 0 7
120531: ARRAY
120532: PPUSH
120533: CALL_OW 310
120537: IFFALSE 120605
// begin z := IsInUnit ( group [ i ] ) ;
120539: LD_ADDR_VAR 0 13
120543: PUSH
120544: LD_VAR 0 4
120548: PUSH
120549: LD_VAR 0 7
120553: ARRAY
120554: PPUSH
120555: CALL_OW 310
120559: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
120560: LD_VAR 0 13
120564: PUSH
120565: LD_VAR 0 32
120569: IN
120570: PUSH
120571: LD_VAR 0 13
120575: PPUSH
120576: LD_VAR 0 22
120580: PPUSH
120581: CALL_OW 308
120585: AND
120586: IFFALSE 120603
// ComExitVehicle ( group [ i ] ) ;
120588: LD_VAR 0 4
120592: PUSH
120593: LD_VAR 0 7
120597: ARRAY
120598: PPUSH
120599: CALL_OW 121
// end else
120603: GO 120782
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
120605: LD_ADDR_VAR 0 13
120609: PUSH
120610: LD_VAR 0 4
120614: PPUSH
120615: LD_INT 95
120617: PUSH
120618: LD_VAR 0 22
120622: PUSH
120623: EMPTY
120624: LIST
120625: LIST
120626: PUSH
120627: LD_INT 58
120629: PUSH
120630: EMPTY
120631: LIST
120632: PUSH
120633: EMPTY
120634: LIST
120635: LIST
120636: PPUSH
120637: CALL_OW 72
120641: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
120642: LD_VAR 0 4
120646: PUSH
120647: LD_VAR 0 7
120651: ARRAY
120652: PPUSH
120653: CALL_OW 314
120657: NOT
120658: IFFALSE 120780
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
120660: LD_ADDR_VAR 0 10
120664: PUSH
120665: LD_VAR 0 13
120669: PPUSH
120670: LD_VAR 0 4
120674: PUSH
120675: LD_VAR 0 7
120679: ARRAY
120680: PPUSH
120681: CALL_OW 74
120685: ST_TO_ADDR
// if not x then
120686: LD_VAR 0 10
120690: NOT
120691: IFFALSE 120695
// continue ;
120693: GO 120127
// if GetLives ( x ) < 1000 then
120695: LD_VAR 0 10
120699: PPUSH
120700: CALL_OW 256
120704: PUSH
120705: LD_INT 1000
120707: LESS
120708: IFFALSE 120732
// ComRepairVehicle ( group [ i ] , x ) else
120710: LD_VAR 0 4
120714: PUSH
120715: LD_VAR 0 7
120719: ARRAY
120720: PPUSH
120721: LD_VAR 0 10
120725: PPUSH
120726: CALL_OW 129
120730: GO 120780
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
120732: LD_VAR 0 23
120736: PUSH
120737: LD_VAR 0 4
120741: PUSH
120742: LD_VAR 0 7
120746: ARRAY
120747: PPUSH
120748: CALL_OW 256
120752: PUSH
120753: LD_INT 1000
120755: LESS
120756: AND
120757: NOT
120758: IFFALSE 120780
// ComEnterUnit ( group [ i ] , x ) ;
120760: LD_VAR 0 4
120764: PUSH
120765: LD_VAR 0 7
120769: ARRAY
120770: PPUSH
120771: LD_VAR 0 10
120775: PPUSH
120776: CALL_OW 120
// end ; continue ;
120780: GO 120127
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
120782: LD_VAR 0 23
120786: PUSH
120787: LD_VAR 0 4
120791: PUSH
120792: LD_VAR 0 7
120796: ARRAY
120797: PPUSH
120798: CALL_OW 247
120802: PUSH
120803: LD_INT 1
120805: EQUAL
120806: AND
120807: IFFALSE 121285
// begin if group [ i ] in healers then
120809: LD_VAR 0 4
120813: PUSH
120814: LD_VAR 0 7
120818: ARRAY
120819: PUSH
120820: LD_VAR 0 31
120824: IN
120825: IFFALSE 121098
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
120827: LD_VAR 0 4
120831: PUSH
120832: LD_VAR 0 7
120836: ARRAY
120837: PPUSH
120838: LD_VAR 0 23
120842: PPUSH
120843: CALL_OW 308
120847: NOT
120848: PUSH
120849: LD_VAR 0 4
120853: PUSH
120854: LD_VAR 0 7
120858: ARRAY
120859: PPUSH
120860: CALL_OW 314
120864: NOT
120865: AND
120866: IFFALSE 120890
// ComMoveToArea ( group [ i ] , f_heal ) else
120868: LD_VAR 0 4
120872: PUSH
120873: LD_VAR 0 7
120877: ARRAY
120878: PPUSH
120879: LD_VAR 0 23
120883: PPUSH
120884: CALL_OW 113
120888: GO 121096
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
120890: LD_VAR 0 4
120894: PUSH
120895: LD_VAR 0 7
120899: ARRAY
120900: PPUSH
120901: CALL 98522 0 1
120905: PPUSH
120906: CALL_OW 256
120910: PUSH
120911: LD_INT 1000
120913: EQUAL
120914: IFFALSE 120933
// ComStop ( group [ i ] ) else
120916: LD_VAR 0 4
120920: PUSH
120921: LD_VAR 0 7
120925: ARRAY
120926: PPUSH
120927: CALL_OW 141
120931: GO 121096
// if not HasTask ( group [ i ] ) and to_heal then
120933: LD_VAR 0 4
120937: PUSH
120938: LD_VAR 0 7
120942: ARRAY
120943: PPUSH
120944: CALL_OW 314
120948: NOT
120949: PUSH
120950: LD_VAR 0 30
120954: AND
120955: IFFALSE 121096
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
120957: LD_ADDR_VAR 0 13
120961: PUSH
120962: LD_VAR 0 30
120966: PPUSH
120967: LD_INT 3
120969: PUSH
120970: LD_INT 54
120972: PUSH
120973: EMPTY
120974: LIST
120975: PUSH
120976: EMPTY
120977: LIST
120978: LIST
120979: PPUSH
120980: CALL_OW 72
120984: PPUSH
120985: LD_VAR 0 4
120989: PUSH
120990: LD_VAR 0 7
120994: ARRAY
120995: PPUSH
120996: CALL_OW 74
121000: ST_TO_ADDR
// if z then
121001: LD_VAR 0 13
121005: IFFALSE 121096
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
121007: LD_INT 91
121009: PUSH
121010: LD_VAR 0 13
121014: PUSH
121015: LD_INT 10
121017: PUSH
121018: EMPTY
121019: LIST
121020: LIST
121021: LIST
121022: PUSH
121023: LD_INT 81
121025: PUSH
121026: LD_VAR 0 13
121030: PPUSH
121031: CALL_OW 255
121035: PUSH
121036: EMPTY
121037: LIST
121038: LIST
121039: PUSH
121040: EMPTY
121041: LIST
121042: LIST
121043: PPUSH
121044: CALL_OW 69
121048: PUSH
121049: LD_INT 0
121051: EQUAL
121052: IFFALSE 121076
// ComHeal ( group [ i ] , z ) else
121054: LD_VAR 0 4
121058: PUSH
121059: LD_VAR 0 7
121063: ARRAY
121064: PPUSH
121065: LD_VAR 0 13
121069: PPUSH
121070: CALL_OW 128
121074: GO 121096
// ComMoveToArea ( group [ i ] , f_heal ) ;
121076: LD_VAR 0 4
121080: PUSH
121081: LD_VAR 0 7
121085: ARRAY
121086: PPUSH
121087: LD_VAR 0 23
121091: PPUSH
121092: CALL_OW 113
// end ; continue ;
121096: GO 120127
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
121098: LD_VAR 0 4
121102: PUSH
121103: LD_VAR 0 7
121107: ARRAY
121108: PPUSH
121109: CALL_OW 256
121113: PUSH
121114: LD_INT 700
121116: LESS
121117: PUSH
121118: LD_VAR 0 4
121122: PUSH
121123: LD_VAR 0 7
121127: ARRAY
121128: PUSH
121129: LD_VAR 0 30
121133: IN
121134: NOT
121135: AND
121136: IFFALSE 121160
// to_heal := to_heal union group [ i ] ;
121138: LD_ADDR_VAR 0 30
121142: PUSH
121143: LD_VAR 0 30
121147: PUSH
121148: LD_VAR 0 4
121152: PUSH
121153: LD_VAR 0 7
121157: ARRAY
121158: UNION
121159: ST_TO_ADDR
// if group [ i ] in to_heal then
121160: LD_VAR 0 4
121164: PUSH
121165: LD_VAR 0 7
121169: ARRAY
121170: PUSH
121171: LD_VAR 0 30
121175: IN
121176: IFFALSE 121285
// begin if GetLives ( group [ i ] ) = 1000 then
121178: LD_VAR 0 4
121182: PUSH
121183: LD_VAR 0 7
121187: ARRAY
121188: PPUSH
121189: CALL_OW 256
121193: PUSH
121194: LD_INT 1000
121196: EQUAL
121197: IFFALSE 121223
// to_heal := to_heal diff group [ i ] else
121199: LD_ADDR_VAR 0 30
121203: PUSH
121204: LD_VAR 0 30
121208: PUSH
121209: LD_VAR 0 4
121213: PUSH
121214: LD_VAR 0 7
121218: ARRAY
121219: DIFF
121220: ST_TO_ADDR
121221: GO 121285
// begin if not IsInArea ( group [ i ] , to_heal ) then
121223: LD_VAR 0 4
121227: PUSH
121228: LD_VAR 0 7
121232: ARRAY
121233: PPUSH
121234: LD_VAR 0 30
121238: PPUSH
121239: CALL_OW 308
121243: NOT
121244: IFFALSE 121268
// ComMoveToArea ( group [ i ] , f_heal ) else
121246: LD_VAR 0 4
121250: PUSH
121251: LD_VAR 0 7
121255: ARRAY
121256: PPUSH
121257: LD_VAR 0 23
121261: PPUSH
121262: CALL_OW 113
121266: GO 121283
// ComHold ( group [ i ] ) ;
121268: LD_VAR 0 4
121272: PUSH
121273: LD_VAR 0 7
121277: ARRAY
121278: PPUSH
121279: CALL_OW 140
// continue ;
121283: GO 120127
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
121285: LD_VAR 0 4
121289: PUSH
121290: LD_VAR 0 7
121294: ARRAY
121295: PPUSH
121296: LD_INT 10
121298: PPUSH
121299: CALL 96942 0 2
121303: NOT
121304: PUSH
121305: LD_VAR 0 16
121309: PUSH
121310: LD_VAR 0 7
121314: ARRAY
121315: PUSH
121316: EMPTY
121317: EQUAL
121318: NOT
121319: AND
121320: IFFALSE 121586
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
121322: LD_VAR 0 4
121326: PUSH
121327: LD_VAR 0 7
121331: ARRAY
121332: PPUSH
121333: CALL_OW 262
121337: PUSH
121338: LD_INT 1
121340: PUSH
121341: LD_INT 2
121343: PUSH
121344: EMPTY
121345: LIST
121346: LIST
121347: IN
121348: IFFALSE 121389
// if GetFuel ( group [ i ] ) < 10 then
121350: LD_VAR 0 4
121354: PUSH
121355: LD_VAR 0 7
121359: ARRAY
121360: PPUSH
121361: CALL_OW 261
121365: PUSH
121366: LD_INT 10
121368: LESS
121369: IFFALSE 121389
// SetFuel ( group [ i ] , 12 ) ;
121371: LD_VAR 0 4
121375: PUSH
121376: LD_VAR 0 7
121380: ARRAY
121381: PPUSH
121382: LD_INT 12
121384: PPUSH
121385: CALL_OW 240
// if units_path [ i ] then
121389: LD_VAR 0 16
121393: PUSH
121394: LD_VAR 0 7
121398: ARRAY
121399: IFFALSE 121584
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
121401: LD_VAR 0 4
121405: PUSH
121406: LD_VAR 0 7
121410: ARRAY
121411: PPUSH
121412: LD_VAR 0 16
121416: PUSH
121417: LD_VAR 0 7
121421: ARRAY
121422: PUSH
121423: LD_INT 1
121425: ARRAY
121426: PUSH
121427: LD_INT 1
121429: ARRAY
121430: PPUSH
121431: LD_VAR 0 16
121435: PUSH
121436: LD_VAR 0 7
121440: ARRAY
121441: PUSH
121442: LD_INT 1
121444: ARRAY
121445: PUSH
121446: LD_INT 2
121448: ARRAY
121449: PPUSH
121450: CALL_OW 297
121454: PUSH
121455: LD_INT 6
121457: GREATER
121458: IFFALSE 121533
// begin if not HasTask ( group [ i ] ) then
121460: LD_VAR 0 4
121464: PUSH
121465: LD_VAR 0 7
121469: ARRAY
121470: PPUSH
121471: CALL_OW 314
121475: NOT
121476: IFFALSE 121531
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
121478: LD_VAR 0 4
121482: PUSH
121483: LD_VAR 0 7
121487: ARRAY
121488: PPUSH
121489: LD_VAR 0 16
121493: PUSH
121494: LD_VAR 0 7
121498: ARRAY
121499: PUSH
121500: LD_INT 1
121502: ARRAY
121503: PUSH
121504: LD_INT 1
121506: ARRAY
121507: PPUSH
121508: LD_VAR 0 16
121512: PUSH
121513: LD_VAR 0 7
121517: ARRAY
121518: PUSH
121519: LD_INT 1
121521: ARRAY
121522: PUSH
121523: LD_INT 2
121525: ARRAY
121526: PPUSH
121527: CALL_OW 114
// end else
121531: GO 121584
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
121533: LD_ADDR_VAR 0 15
121537: PUSH
121538: LD_VAR 0 16
121542: PUSH
121543: LD_VAR 0 7
121547: ARRAY
121548: PPUSH
121549: LD_INT 1
121551: PPUSH
121552: CALL_OW 3
121556: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
121557: LD_ADDR_VAR 0 16
121561: PUSH
121562: LD_VAR 0 16
121566: PPUSH
121567: LD_VAR 0 7
121571: PPUSH
121572: LD_VAR 0 15
121576: PPUSH
121577: CALL_OW 1
121581: ST_TO_ADDR
// continue ;
121582: GO 120127
// end ; end ; end else
121584: GO 124248
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
121586: LD_ADDR_VAR 0 14
121590: PUSH
121591: LD_INT 81
121593: PUSH
121594: LD_VAR 0 4
121598: PUSH
121599: LD_VAR 0 7
121603: ARRAY
121604: PPUSH
121605: CALL_OW 255
121609: PUSH
121610: EMPTY
121611: LIST
121612: LIST
121613: PPUSH
121614: CALL_OW 69
121618: ST_TO_ADDR
// if not tmp then
121619: LD_VAR 0 14
121623: NOT
121624: IFFALSE 121628
// continue ;
121626: GO 120127
// if f_ignore_area then
121628: LD_VAR 0 17
121632: IFFALSE 121720
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
121634: LD_ADDR_VAR 0 15
121638: PUSH
121639: LD_VAR 0 14
121643: PPUSH
121644: LD_INT 3
121646: PUSH
121647: LD_INT 92
121649: PUSH
121650: LD_VAR 0 17
121654: PUSH
121655: LD_INT 1
121657: ARRAY
121658: PUSH
121659: LD_VAR 0 17
121663: PUSH
121664: LD_INT 2
121666: ARRAY
121667: PUSH
121668: LD_VAR 0 17
121672: PUSH
121673: LD_INT 3
121675: ARRAY
121676: PUSH
121677: EMPTY
121678: LIST
121679: LIST
121680: LIST
121681: LIST
121682: PUSH
121683: EMPTY
121684: LIST
121685: LIST
121686: PPUSH
121687: CALL_OW 72
121691: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121692: LD_VAR 0 14
121696: PUSH
121697: LD_VAR 0 15
121701: DIFF
121702: IFFALSE 121720
// tmp := tmp diff tmp2 ;
121704: LD_ADDR_VAR 0 14
121708: PUSH
121709: LD_VAR 0 14
121713: PUSH
121714: LD_VAR 0 15
121718: DIFF
121719: ST_TO_ADDR
// end ; if not f_murder then
121720: LD_VAR 0 20
121724: NOT
121725: IFFALSE 121783
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
121727: LD_ADDR_VAR 0 15
121731: PUSH
121732: LD_VAR 0 14
121736: PPUSH
121737: LD_INT 3
121739: PUSH
121740: LD_INT 50
121742: PUSH
121743: EMPTY
121744: LIST
121745: PUSH
121746: EMPTY
121747: LIST
121748: LIST
121749: PPUSH
121750: CALL_OW 72
121754: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121755: LD_VAR 0 14
121759: PUSH
121760: LD_VAR 0 15
121764: DIFF
121765: IFFALSE 121783
// tmp := tmp diff tmp2 ;
121767: LD_ADDR_VAR 0 14
121771: PUSH
121772: LD_VAR 0 14
121776: PUSH
121777: LD_VAR 0 15
121781: DIFF
121782: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
121783: LD_ADDR_VAR 0 14
121787: PUSH
121788: LD_VAR 0 4
121792: PUSH
121793: LD_VAR 0 7
121797: ARRAY
121798: PPUSH
121799: LD_VAR 0 14
121803: PPUSH
121804: LD_INT 1
121806: PPUSH
121807: LD_INT 1
121809: PPUSH
121810: CALL 70585 0 4
121814: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
121815: LD_VAR 0 4
121819: PUSH
121820: LD_VAR 0 7
121824: ARRAY
121825: PPUSH
121826: CALL_OW 257
121830: PUSH
121831: LD_INT 1
121833: EQUAL
121834: IFFALSE 122282
// begin if WantPlant ( group [ i ] ) then
121836: LD_VAR 0 4
121840: PUSH
121841: LD_VAR 0 7
121845: ARRAY
121846: PPUSH
121847: CALL 70086 0 1
121851: IFFALSE 121855
// continue ;
121853: GO 120127
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
121855: LD_VAR 0 18
121859: PUSH
121860: LD_VAR 0 4
121864: PUSH
121865: LD_VAR 0 7
121869: ARRAY
121870: PPUSH
121871: CALL_OW 310
121875: NOT
121876: AND
121877: PUSH
121878: LD_VAR 0 14
121882: PUSH
121883: LD_INT 1
121885: ARRAY
121886: PUSH
121887: LD_VAR 0 14
121891: PPUSH
121892: LD_INT 21
121894: PUSH
121895: LD_INT 2
121897: PUSH
121898: EMPTY
121899: LIST
121900: LIST
121901: PUSH
121902: LD_INT 58
121904: PUSH
121905: EMPTY
121906: LIST
121907: PUSH
121908: EMPTY
121909: LIST
121910: LIST
121911: PPUSH
121912: CALL_OW 72
121916: IN
121917: AND
121918: IFFALSE 121954
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
121920: LD_VAR 0 4
121924: PUSH
121925: LD_VAR 0 7
121929: ARRAY
121930: PPUSH
121931: LD_VAR 0 14
121935: PUSH
121936: LD_INT 1
121938: ARRAY
121939: PPUSH
121940: CALL_OW 120
// attacking := true ;
121944: LD_ADDR_VAR 0 29
121948: PUSH
121949: LD_INT 1
121951: ST_TO_ADDR
// continue ;
121952: GO 120127
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
121954: LD_VAR 0 26
121958: PUSH
121959: LD_VAR 0 4
121963: PUSH
121964: LD_VAR 0 7
121968: ARRAY
121969: PPUSH
121970: CALL_OW 257
121974: PUSH
121975: LD_INT 1
121977: EQUAL
121978: AND
121979: PUSH
121980: LD_VAR 0 4
121984: PUSH
121985: LD_VAR 0 7
121989: ARRAY
121990: PPUSH
121991: CALL_OW 256
121995: PUSH
121996: LD_INT 800
121998: LESS
121999: AND
122000: PUSH
122001: LD_VAR 0 4
122005: PUSH
122006: LD_VAR 0 7
122010: ARRAY
122011: PPUSH
122012: CALL_OW 318
122016: NOT
122017: AND
122018: IFFALSE 122035
// ComCrawl ( group [ i ] ) ;
122020: LD_VAR 0 4
122024: PUSH
122025: LD_VAR 0 7
122029: ARRAY
122030: PPUSH
122031: CALL_OW 137
// if f_mines then
122035: LD_VAR 0 21
122039: IFFALSE 122282
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
122041: LD_VAR 0 14
122045: PUSH
122046: LD_INT 1
122048: ARRAY
122049: PPUSH
122050: CALL_OW 247
122054: PUSH
122055: LD_INT 3
122057: EQUAL
122058: PUSH
122059: LD_VAR 0 14
122063: PUSH
122064: LD_INT 1
122066: ARRAY
122067: PUSH
122068: LD_VAR 0 27
122072: IN
122073: NOT
122074: AND
122075: IFFALSE 122282
// begin x := GetX ( tmp [ 1 ] ) ;
122077: LD_ADDR_VAR 0 10
122081: PUSH
122082: LD_VAR 0 14
122086: PUSH
122087: LD_INT 1
122089: ARRAY
122090: PPUSH
122091: CALL_OW 250
122095: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
122096: LD_ADDR_VAR 0 11
122100: PUSH
122101: LD_VAR 0 14
122105: PUSH
122106: LD_INT 1
122108: ARRAY
122109: PPUSH
122110: CALL_OW 251
122114: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
122115: LD_ADDR_VAR 0 12
122119: PUSH
122120: LD_VAR 0 4
122124: PUSH
122125: LD_VAR 0 7
122129: ARRAY
122130: PPUSH
122131: CALL 97027 0 1
122135: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
122136: LD_VAR 0 4
122140: PUSH
122141: LD_VAR 0 7
122145: ARRAY
122146: PPUSH
122147: LD_VAR 0 10
122151: PPUSH
122152: LD_VAR 0 11
122156: PPUSH
122157: LD_VAR 0 14
122161: PUSH
122162: LD_INT 1
122164: ARRAY
122165: PPUSH
122166: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
122170: LD_VAR 0 4
122174: PUSH
122175: LD_VAR 0 7
122179: ARRAY
122180: PPUSH
122181: LD_VAR 0 10
122185: PPUSH
122186: LD_VAR 0 12
122190: PPUSH
122191: LD_INT 7
122193: PPUSH
122194: CALL_OW 272
122198: PPUSH
122199: LD_VAR 0 11
122203: PPUSH
122204: LD_VAR 0 12
122208: PPUSH
122209: LD_INT 7
122211: PPUSH
122212: CALL_OW 273
122216: PPUSH
122217: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
122221: LD_VAR 0 4
122225: PUSH
122226: LD_VAR 0 7
122230: ARRAY
122231: PPUSH
122232: LD_INT 71
122234: PPUSH
122235: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
122239: LD_ADDR_VAR 0 27
122243: PUSH
122244: LD_VAR 0 27
122248: PPUSH
122249: LD_VAR 0 27
122253: PUSH
122254: LD_INT 1
122256: PLUS
122257: PPUSH
122258: LD_VAR 0 14
122262: PUSH
122263: LD_INT 1
122265: ARRAY
122266: PPUSH
122267: CALL_OW 1
122271: ST_TO_ADDR
// attacking := true ;
122272: LD_ADDR_VAR 0 29
122276: PUSH
122277: LD_INT 1
122279: ST_TO_ADDR
// continue ;
122280: GO 120127
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
122282: LD_VAR 0 4
122286: PUSH
122287: LD_VAR 0 7
122291: ARRAY
122292: PPUSH
122293: CALL_OW 257
122297: PUSH
122298: LD_INT 17
122300: EQUAL
122301: PUSH
122302: LD_VAR 0 4
122306: PUSH
122307: LD_VAR 0 7
122311: ARRAY
122312: PPUSH
122313: CALL_OW 110
122317: PUSH
122318: LD_INT 71
122320: EQUAL
122321: NOT
122322: AND
122323: IFFALSE 122469
// begin attacking := false ;
122325: LD_ADDR_VAR 0 29
122329: PUSH
122330: LD_INT 0
122332: ST_TO_ADDR
// k := 5 ;
122333: LD_ADDR_VAR 0 9
122337: PUSH
122338: LD_INT 5
122340: ST_TO_ADDR
// if tmp < k then
122341: LD_VAR 0 14
122345: PUSH
122346: LD_VAR 0 9
122350: LESS
122351: IFFALSE 122363
// k := tmp ;
122353: LD_ADDR_VAR 0 9
122357: PUSH
122358: LD_VAR 0 14
122362: ST_TO_ADDR
// for j = 1 to k do
122363: LD_ADDR_VAR 0 8
122367: PUSH
122368: DOUBLE
122369: LD_INT 1
122371: DEC
122372: ST_TO_ADDR
122373: LD_VAR 0 9
122377: PUSH
122378: FOR_TO
122379: IFFALSE 122467
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
122381: LD_VAR 0 14
122385: PUSH
122386: LD_VAR 0 8
122390: ARRAY
122391: PUSH
122392: LD_VAR 0 14
122396: PPUSH
122397: LD_INT 58
122399: PUSH
122400: EMPTY
122401: LIST
122402: PPUSH
122403: CALL_OW 72
122407: IN
122408: NOT
122409: IFFALSE 122465
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122411: LD_VAR 0 4
122415: PUSH
122416: LD_VAR 0 7
122420: ARRAY
122421: PPUSH
122422: LD_VAR 0 14
122426: PUSH
122427: LD_VAR 0 8
122431: ARRAY
122432: PPUSH
122433: CALL_OW 115
// attacking := true ;
122437: LD_ADDR_VAR 0 29
122441: PUSH
122442: LD_INT 1
122444: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
122445: LD_VAR 0 4
122449: PUSH
122450: LD_VAR 0 7
122454: ARRAY
122455: PPUSH
122456: LD_INT 71
122458: PPUSH
122459: CALL_OW 109
// continue ;
122463: GO 122378
// end ; end ;
122465: GO 122378
122467: POP
122468: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
122469: LD_VAR 0 4
122473: PUSH
122474: LD_VAR 0 7
122478: ARRAY
122479: PPUSH
122480: CALL_OW 257
122484: PUSH
122485: LD_INT 8
122487: EQUAL
122488: PUSH
122489: LD_VAR 0 4
122493: PUSH
122494: LD_VAR 0 7
122498: ARRAY
122499: PPUSH
122500: CALL_OW 264
122504: PUSH
122505: LD_INT 28
122507: PUSH
122508: LD_INT 45
122510: PUSH
122511: LD_INT 7
122513: PUSH
122514: LD_INT 47
122516: PUSH
122517: EMPTY
122518: LIST
122519: LIST
122520: LIST
122521: LIST
122522: IN
122523: OR
122524: IFFALSE 122780
// begin attacking := false ;
122526: LD_ADDR_VAR 0 29
122530: PUSH
122531: LD_INT 0
122533: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
122534: LD_VAR 0 14
122538: PUSH
122539: LD_INT 1
122541: ARRAY
122542: PPUSH
122543: CALL_OW 266
122547: PUSH
122548: LD_INT 32
122550: PUSH
122551: LD_INT 31
122553: PUSH
122554: LD_INT 33
122556: PUSH
122557: LD_INT 4
122559: PUSH
122560: LD_INT 5
122562: PUSH
122563: EMPTY
122564: LIST
122565: LIST
122566: LIST
122567: LIST
122568: LIST
122569: IN
122570: IFFALSE 122756
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
122572: LD_ADDR_VAR 0 9
122576: PUSH
122577: LD_VAR 0 14
122581: PUSH
122582: LD_INT 1
122584: ARRAY
122585: PPUSH
122586: CALL_OW 266
122590: PPUSH
122591: LD_VAR 0 14
122595: PUSH
122596: LD_INT 1
122598: ARRAY
122599: PPUSH
122600: CALL_OW 250
122604: PPUSH
122605: LD_VAR 0 14
122609: PUSH
122610: LD_INT 1
122612: ARRAY
122613: PPUSH
122614: CALL_OW 251
122618: PPUSH
122619: LD_VAR 0 14
122623: PUSH
122624: LD_INT 1
122626: ARRAY
122627: PPUSH
122628: CALL_OW 254
122632: PPUSH
122633: LD_VAR 0 14
122637: PUSH
122638: LD_INT 1
122640: ARRAY
122641: PPUSH
122642: CALL_OW 248
122646: PPUSH
122647: LD_INT 0
122649: PPUSH
122650: CALL 78397 0 6
122654: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
122655: LD_ADDR_VAR 0 8
122659: PUSH
122660: LD_VAR 0 4
122664: PUSH
122665: LD_VAR 0 7
122669: ARRAY
122670: PPUSH
122671: LD_VAR 0 9
122675: PPUSH
122676: CALL 97067 0 2
122680: ST_TO_ADDR
// if j then
122681: LD_VAR 0 8
122685: IFFALSE 122754
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
122687: LD_VAR 0 8
122691: PUSH
122692: LD_INT 1
122694: ARRAY
122695: PPUSH
122696: LD_VAR 0 8
122700: PUSH
122701: LD_INT 2
122703: ARRAY
122704: PPUSH
122705: CALL_OW 488
122709: IFFALSE 122754
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
122711: LD_VAR 0 4
122715: PUSH
122716: LD_VAR 0 7
122720: ARRAY
122721: PPUSH
122722: LD_VAR 0 8
122726: PUSH
122727: LD_INT 1
122729: ARRAY
122730: PPUSH
122731: LD_VAR 0 8
122735: PUSH
122736: LD_INT 2
122738: ARRAY
122739: PPUSH
122740: CALL_OW 116
// attacking := true ;
122744: LD_ADDR_VAR 0 29
122748: PUSH
122749: LD_INT 1
122751: ST_TO_ADDR
// continue ;
122752: GO 120127
// end ; end else
122754: GO 122780
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122756: LD_VAR 0 4
122760: PUSH
122761: LD_VAR 0 7
122765: ARRAY
122766: PPUSH
122767: LD_VAR 0 14
122771: PUSH
122772: LD_INT 1
122774: ARRAY
122775: PPUSH
122776: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
122780: LD_VAR 0 4
122784: PUSH
122785: LD_VAR 0 7
122789: ARRAY
122790: PPUSH
122791: CALL_OW 265
122795: PUSH
122796: LD_INT 11
122798: EQUAL
122799: IFFALSE 123077
// begin k := 10 ;
122801: LD_ADDR_VAR 0 9
122805: PUSH
122806: LD_INT 10
122808: ST_TO_ADDR
// x := 0 ;
122809: LD_ADDR_VAR 0 10
122813: PUSH
122814: LD_INT 0
122816: ST_TO_ADDR
// if tmp < k then
122817: LD_VAR 0 14
122821: PUSH
122822: LD_VAR 0 9
122826: LESS
122827: IFFALSE 122839
// k := tmp ;
122829: LD_ADDR_VAR 0 9
122833: PUSH
122834: LD_VAR 0 14
122838: ST_TO_ADDR
// for j = k downto 1 do
122839: LD_ADDR_VAR 0 8
122843: PUSH
122844: DOUBLE
122845: LD_VAR 0 9
122849: INC
122850: ST_TO_ADDR
122851: LD_INT 1
122853: PUSH
122854: FOR_DOWNTO
122855: IFFALSE 122930
// begin if GetType ( tmp [ j ] ) = unit_human then
122857: LD_VAR 0 14
122861: PUSH
122862: LD_VAR 0 8
122866: ARRAY
122867: PPUSH
122868: CALL_OW 247
122872: PUSH
122873: LD_INT 1
122875: EQUAL
122876: IFFALSE 122928
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
122878: LD_VAR 0 4
122882: PUSH
122883: LD_VAR 0 7
122887: ARRAY
122888: PPUSH
122889: LD_VAR 0 14
122893: PUSH
122894: LD_VAR 0 8
122898: ARRAY
122899: PPUSH
122900: CALL 97338 0 2
// x := tmp [ j ] ;
122904: LD_ADDR_VAR 0 10
122908: PUSH
122909: LD_VAR 0 14
122913: PUSH
122914: LD_VAR 0 8
122918: ARRAY
122919: ST_TO_ADDR
// attacking := true ;
122920: LD_ADDR_VAR 0 29
122924: PUSH
122925: LD_INT 1
122927: ST_TO_ADDR
// end ; end ;
122928: GO 122854
122930: POP
122931: POP
// if not x then
122932: LD_VAR 0 10
122936: NOT
122937: IFFALSE 123077
// begin attacking := true ;
122939: LD_ADDR_VAR 0 29
122943: PUSH
122944: LD_INT 1
122946: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
122947: LD_VAR 0 4
122951: PUSH
122952: LD_VAR 0 7
122956: ARRAY
122957: PPUSH
122958: CALL_OW 250
122962: PPUSH
122963: LD_VAR 0 4
122967: PUSH
122968: LD_VAR 0 7
122972: ARRAY
122973: PPUSH
122974: CALL_OW 251
122978: PPUSH
122979: CALL_OW 546
122983: PUSH
122984: LD_INT 2
122986: ARRAY
122987: PUSH
122988: LD_VAR 0 14
122992: PUSH
122993: LD_INT 1
122995: ARRAY
122996: PPUSH
122997: CALL_OW 250
123001: PPUSH
123002: LD_VAR 0 14
123006: PUSH
123007: LD_INT 1
123009: ARRAY
123010: PPUSH
123011: CALL_OW 251
123015: PPUSH
123016: CALL_OW 546
123020: PUSH
123021: LD_INT 2
123023: ARRAY
123024: EQUAL
123025: IFFALSE 123053
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
123027: LD_VAR 0 4
123031: PUSH
123032: LD_VAR 0 7
123036: ARRAY
123037: PPUSH
123038: LD_VAR 0 14
123042: PUSH
123043: LD_INT 1
123045: ARRAY
123046: PPUSH
123047: CALL 97338 0 2
123051: GO 123077
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123053: LD_VAR 0 4
123057: PUSH
123058: LD_VAR 0 7
123062: ARRAY
123063: PPUSH
123064: LD_VAR 0 14
123068: PUSH
123069: LD_INT 1
123071: ARRAY
123072: PPUSH
123073: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
123077: LD_VAR 0 4
123081: PUSH
123082: LD_VAR 0 7
123086: ARRAY
123087: PPUSH
123088: CALL_OW 264
123092: PUSH
123093: LD_INT 29
123095: EQUAL
123096: IFFALSE 123462
// begin if WantsToAttack ( group [ i ] ) in bombed then
123098: LD_VAR 0 4
123102: PUSH
123103: LD_VAR 0 7
123107: ARRAY
123108: PPUSH
123109: CALL_OW 319
123113: PUSH
123114: LD_VAR 0 28
123118: IN
123119: IFFALSE 123123
// continue ;
123121: GO 120127
// k := 8 ;
123123: LD_ADDR_VAR 0 9
123127: PUSH
123128: LD_INT 8
123130: ST_TO_ADDR
// x := 0 ;
123131: LD_ADDR_VAR 0 10
123135: PUSH
123136: LD_INT 0
123138: ST_TO_ADDR
// if tmp < k then
123139: LD_VAR 0 14
123143: PUSH
123144: LD_VAR 0 9
123148: LESS
123149: IFFALSE 123161
// k := tmp ;
123151: LD_ADDR_VAR 0 9
123155: PUSH
123156: LD_VAR 0 14
123160: ST_TO_ADDR
// for j = 1 to k do
123161: LD_ADDR_VAR 0 8
123165: PUSH
123166: DOUBLE
123167: LD_INT 1
123169: DEC
123170: ST_TO_ADDR
123171: LD_VAR 0 9
123175: PUSH
123176: FOR_TO
123177: IFFALSE 123309
// begin if GetType ( tmp [ j ] ) = unit_building then
123179: LD_VAR 0 14
123183: PUSH
123184: LD_VAR 0 8
123188: ARRAY
123189: PPUSH
123190: CALL_OW 247
123194: PUSH
123195: LD_INT 3
123197: EQUAL
123198: IFFALSE 123307
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
123200: LD_VAR 0 14
123204: PUSH
123205: LD_VAR 0 8
123209: ARRAY
123210: PUSH
123211: LD_VAR 0 28
123215: IN
123216: NOT
123217: PUSH
123218: LD_VAR 0 14
123222: PUSH
123223: LD_VAR 0 8
123227: ARRAY
123228: PPUSH
123229: CALL_OW 313
123233: AND
123234: IFFALSE 123307
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123236: LD_VAR 0 4
123240: PUSH
123241: LD_VAR 0 7
123245: ARRAY
123246: PPUSH
123247: LD_VAR 0 14
123251: PUSH
123252: LD_VAR 0 8
123256: ARRAY
123257: PPUSH
123258: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
123262: LD_ADDR_VAR 0 28
123266: PUSH
123267: LD_VAR 0 28
123271: PPUSH
123272: LD_VAR 0 28
123276: PUSH
123277: LD_INT 1
123279: PLUS
123280: PPUSH
123281: LD_VAR 0 14
123285: PUSH
123286: LD_VAR 0 8
123290: ARRAY
123291: PPUSH
123292: CALL_OW 1
123296: ST_TO_ADDR
// attacking := true ;
123297: LD_ADDR_VAR 0 29
123301: PUSH
123302: LD_INT 1
123304: ST_TO_ADDR
// break ;
123305: GO 123309
// end ; end ;
123307: GO 123176
123309: POP
123310: POP
// if not attacking and f_attack_depot then
123311: LD_VAR 0 29
123315: NOT
123316: PUSH
123317: LD_VAR 0 25
123321: AND
123322: IFFALSE 123417
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123324: LD_ADDR_VAR 0 13
123328: PUSH
123329: LD_VAR 0 14
123333: PPUSH
123334: LD_INT 2
123336: PUSH
123337: LD_INT 30
123339: PUSH
123340: LD_INT 0
123342: PUSH
123343: EMPTY
123344: LIST
123345: LIST
123346: PUSH
123347: LD_INT 30
123349: PUSH
123350: LD_INT 1
123352: PUSH
123353: EMPTY
123354: LIST
123355: LIST
123356: PUSH
123357: EMPTY
123358: LIST
123359: LIST
123360: LIST
123361: PPUSH
123362: CALL_OW 72
123366: ST_TO_ADDR
// if z then
123367: LD_VAR 0 13
123371: IFFALSE 123417
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
123373: LD_VAR 0 4
123377: PUSH
123378: LD_VAR 0 7
123382: ARRAY
123383: PPUSH
123384: LD_VAR 0 13
123388: PPUSH
123389: LD_VAR 0 4
123393: PUSH
123394: LD_VAR 0 7
123398: ARRAY
123399: PPUSH
123400: CALL_OW 74
123404: PPUSH
123405: CALL_OW 115
// attacking := true ;
123409: LD_ADDR_VAR 0 29
123413: PUSH
123414: LD_INT 1
123416: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
123417: LD_VAR 0 4
123421: PUSH
123422: LD_VAR 0 7
123426: ARRAY
123427: PPUSH
123428: CALL_OW 256
123432: PUSH
123433: LD_INT 500
123435: LESS
123436: IFFALSE 123462
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123438: LD_VAR 0 4
123442: PUSH
123443: LD_VAR 0 7
123447: ARRAY
123448: PPUSH
123449: LD_VAR 0 14
123453: PUSH
123454: LD_INT 1
123456: ARRAY
123457: PPUSH
123458: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
123462: LD_VAR 0 4
123466: PUSH
123467: LD_VAR 0 7
123471: ARRAY
123472: PPUSH
123473: CALL_OW 264
123477: PUSH
123478: LD_INT 49
123480: EQUAL
123481: IFFALSE 123602
// begin if not HasTask ( group [ i ] ) then
123483: LD_VAR 0 4
123487: PUSH
123488: LD_VAR 0 7
123492: ARRAY
123493: PPUSH
123494: CALL_OW 314
123498: NOT
123499: IFFALSE 123602
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
123501: LD_ADDR_VAR 0 9
123505: PUSH
123506: LD_INT 81
123508: PUSH
123509: LD_VAR 0 4
123513: PUSH
123514: LD_VAR 0 7
123518: ARRAY
123519: PPUSH
123520: CALL_OW 255
123524: PUSH
123525: EMPTY
123526: LIST
123527: LIST
123528: PPUSH
123529: CALL_OW 69
123533: PPUSH
123534: LD_VAR 0 4
123538: PUSH
123539: LD_VAR 0 7
123543: ARRAY
123544: PPUSH
123545: CALL_OW 74
123549: ST_TO_ADDR
// if k then
123550: LD_VAR 0 9
123554: IFFALSE 123602
// if GetDistUnits ( group [ i ] , k ) > 10 then
123556: LD_VAR 0 4
123560: PUSH
123561: LD_VAR 0 7
123565: ARRAY
123566: PPUSH
123567: LD_VAR 0 9
123571: PPUSH
123572: CALL_OW 296
123576: PUSH
123577: LD_INT 10
123579: GREATER
123580: IFFALSE 123602
// ComMoveUnit ( group [ i ] , k ) ;
123582: LD_VAR 0 4
123586: PUSH
123587: LD_VAR 0 7
123591: ARRAY
123592: PPUSH
123593: LD_VAR 0 9
123597: PPUSH
123598: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
123602: LD_VAR 0 4
123606: PUSH
123607: LD_VAR 0 7
123611: ARRAY
123612: PPUSH
123613: CALL_OW 256
123617: PUSH
123618: LD_INT 250
123620: LESS
123621: PUSH
123622: LD_VAR 0 4
123626: PUSH
123627: LD_VAR 0 7
123631: ARRAY
123632: PUSH
123633: LD_INT 21
123635: PUSH
123636: LD_INT 2
123638: PUSH
123639: EMPTY
123640: LIST
123641: LIST
123642: PUSH
123643: LD_INT 23
123645: PUSH
123646: LD_INT 2
123648: PUSH
123649: EMPTY
123650: LIST
123651: LIST
123652: PUSH
123653: EMPTY
123654: LIST
123655: LIST
123656: PPUSH
123657: CALL_OW 69
123661: IN
123662: AND
123663: IFFALSE 123788
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
123665: LD_ADDR_VAR 0 9
123669: PUSH
123670: LD_OWVAR 3
123674: PUSH
123675: LD_VAR 0 4
123679: PUSH
123680: LD_VAR 0 7
123684: ARRAY
123685: DIFF
123686: PPUSH
123687: LD_VAR 0 4
123691: PUSH
123692: LD_VAR 0 7
123696: ARRAY
123697: PPUSH
123698: CALL_OW 74
123702: ST_TO_ADDR
// if not k then
123703: LD_VAR 0 9
123707: NOT
123708: IFFALSE 123712
// continue ;
123710: GO 120127
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
123712: LD_VAR 0 9
123716: PUSH
123717: LD_INT 81
123719: PUSH
123720: LD_VAR 0 4
123724: PUSH
123725: LD_VAR 0 7
123729: ARRAY
123730: PPUSH
123731: CALL_OW 255
123735: PUSH
123736: EMPTY
123737: LIST
123738: LIST
123739: PPUSH
123740: CALL_OW 69
123744: IN
123745: PUSH
123746: LD_VAR 0 9
123750: PPUSH
123751: LD_VAR 0 4
123755: PUSH
123756: LD_VAR 0 7
123760: ARRAY
123761: PPUSH
123762: CALL_OW 296
123766: PUSH
123767: LD_INT 5
123769: LESS
123770: AND
123771: IFFALSE 123788
// ComAutodestruct ( group [ i ] ) ;
123773: LD_VAR 0 4
123777: PUSH
123778: LD_VAR 0 7
123782: ARRAY
123783: PPUSH
123784: CALL 97236 0 1
// end ; if f_attack_depot then
123788: LD_VAR 0 25
123792: IFFALSE 123904
// begin k := 6 ;
123794: LD_ADDR_VAR 0 9
123798: PUSH
123799: LD_INT 6
123801: ST_TO_ADDR
// if tmp < k then
123802: LD_VAR 0 14
123806: PUSH
123807: LD_VAR 0 9
123811: LESS
123812: IFFALSE 123824
// k := tmp ;
123814: LD_ADDR_VAR 0 9
123818: PUSH
123819: LD_VAR 0 14
123823: ST_TO_ADDR
// for j = 1 to k do
123824: LD_ADDR_VAR 0 8
123828: PUSH
123829: DOUBLE
123830: LD_INT 1
123832: DEC
123833: ST_TO_ADDR
123834: LD_VAR 0 9
123838: PUSH
123839: FOR_TO
123840: IFFALSE 123902
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
123842: LD_VAR 0 8
123846: PPUSH
123847: CALL_OW 266
123851: PUSH
123852: LD_INT 0
123854: PUSH
123855: LD_INT 1
123857: PUSH
123858: EMPTY
123859: LIST
123860: LIST
123861: IN
123862: IFFALSE 123900
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123864: LD_VAR 0 4
123868: PUSH
123869: LD_VAR 0 7
123873: ARRAY
123874: PPUSH
123875: LD_VAR 0 14
123879: PUSH
123880: LD_VAR 0 8
123884: ARRAY
123885: PPUSH
123886: CALL_OW 115
// attacking := true ;
123890: LD_ADDR_VAR 0 29
123894: PUSH
123895: LD_INT 1
123897: ST_TO_ADDR
// break ;
123898: GO 123902
// end ;
123900: GO 123839
123902: POP
123903: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
123904: LD_VAR 0 4
123908: PUSH
123909: LD_VAR 0 7
123913: ARRAY
123914: PPUSH
123915: CALL_OW 302
123919: PUSH
123920: LD_VAR 0 29
123924: NOT
123925: AND
123926: IFFALSE 124248
// begin if GetTag ( group [ i ] ) = 71 then
123928: LD_VAR 0 4
123932: PUSH
123933: LD_VAR 0 7
123937: ARRAY
123938: PPUSH
123939: CALL_OW 110
123943: PUSH
123944: LD_INT 71
123946: EQUAL
123947: IFFALSE 123988
// begin if HasTask ( group [ i ] ) then
123949: LD_VAR 0 4
123953: PUSH
123954: LD_VAR 0 7
123958: ARRAY
123959: PPUSH
123960: CALL_OW 314
123964: IFFALSE 123970
// continue else
123966: GO 120127
123968: GO 123988
// SetTag ( group [ i ] , 0 ) ;
123970: LD_VAR 0 4
123974: PUSH
123975: LD_VAR 0 7
123979: ARRAY
123980: PPUSH
123981: LD_INT 0
123983: PPUSH
123984: CALL_OW 109
// end ; k := 8 ;
123988: LD_ADDR_VAR 0 9
123992: PUSH
123993: LD_INT 8
123995: ST_TO_ADDR
// x := 0 ;
123996: LD_ADDR_VAR 0 10
124000: PUSH
124001: LD_INT 0
124003: ST_TO_ADDR
// if tmp < k then
124004: LD_VAR 0 14
124008: PUSH
124009: LD_VAR 0 9
124013: LESS
124014: IFFALSE 124026
// k := tmp ;
124016: LD_ADDR_VAR 0 9
124020: PUSH
124021: LD_VAR 0 14
124025: ST_TO_ADDR
// for j = 1 to k do
124026: LD_ADDR_VAR 0 8
124030: PUSH
124031: DOUBLE
124032: LD_INT 1
124034: DEC
124035: ST_TO_ADDR
124036: LD_VAR 0 9
124040: PUSH
124041: FOR_TO
124042: IFFALSE 124140
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
124044: LD_VAR 0 14
124048: PUSH
124049: LD_VAR 0 8
124053: ARRAY
124054: PPUSH
124055: CALL_OW 247
124059: PUSH
124060: LD_INT 1
124062: EQUAL
124063: PUSH
124064: LD_VAR 0 14
124068: PUSH
124069: LD_VAR 0 8
124073: ARRAY
124074: PPUSH
124075: CALL_OW 256
124079: PUSH
124080: LD_INT 250
124082: LESS
124083: PUSH
124084: LD_VAR 0 20
124088: AND
124089: PUSH
124090: LD_VAR 0 20
124094: NOT
124095: PUSH
124096: LD_VAR 0 14
124100: PUSH
124101: LD_VAR 0 8
124105: ARRAY
124106: PPUSH
124107: CALL_OW 256
124111: PUSH
124112: LD_INT 250
124114: GREATEREQUAL
124115: AND
124116: OR
124117: AND
124118: IFFALSE 124138
// begin x := tmp [ j ] ;
124120: LD_ADDR_VAR 0 10
124124: PUSH
124125: LD_VAR 0 14
124129: PUSH
124130: LD_VAR 0 8
124134: ARRAY
124135: ST_TO_ADDR
// break ;
124136: GO 124140
// end ;
124138: GO 124041
124140: POP
124141: POP
// if x then
124142: LD_VAR 0 10
124146: IFFALSE 124170
// ComAttackUnit ( group [ i ] , x ) else
124148: LD_VAR 0 4
124152: PUSH
124153: LD_VAR 0 7
124157: ARRAY
124158: PPUSH
124159: LD_VAR 0 10
124163: PPUSH
124164: CALL_OW 115
124168: GO 124194
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124170: LD_VAR 0 4
124174: PUSH
124175: LD_VAR 0 7
124179: ARRAY
124180: PPUSH
124181: LD_VAR 0 14
124185: PUSH
124186: LD_INT 1
124188: ARRAY
124189: PPUSH
124190: CALL_OW 115
// if not HasTask ( group [ i ] ) then
124194: LD_VAR 0 4
124198: PUSH
124199: LD_VAR 0 7
124203: ARRAY
124204: PPUSH
124205: CALL_OW 314
124209: NOT
124210: IFFALSE 124248
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
124212: LD_VAR 0 4
124216: PUSH
124217: LD_VAR 0 7
124221: ARRAY
124222: PPUSH
124223: LD_VAR 0 14
124227: PPUSH
124228: LD_VAR 0 4
124232: PUSH
124233: LD_VAR 0 7
124237: ARRAY
124238: PPUSH
124239: CALL_OW 74
124243: PPUSH
124244: CALL_OW 115
// end ; end ; end ;
124248: GO 120127
124250: POP
124251: POP
// wait ( 0 0$2 ) ;
124252: LD_INT 70
124254: PPUSH
124255: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
124259: LD_VAR 0 4
124263: NOT
124264: PUSH
124265: LD_VAR 0 4
124269: PUSH
124270: EMPTY
124271: EQUAL
124272: OR
124273: PUSH
124274: LD_INT 81
124276: PUSH
124277: LD_VAR 0 35
124281: PUSH
124282: EMPTY
124283: LIST
124284: LIST
124285: PPUSH
124286: CALL_OW 69
124290: NOT
124291: OR
124292: IFFALSE 120112
// end ;
124294: LD_VAR 0 2
124298: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
124299: LD_INT 0
124301: PPUSH
124302: PPUSH
124303: PPUSH
124304: PPUSH
124305: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
124306: LD_VAR 0 1
124310: NOT
124311: PUSH
124312: LD_EXP 113
124316: PUSH
124317: LD_VAR 0 1
124321: ARRAY
124322: NOT
124323: OR
124324: PUSH
124325: LD_VAR 0 2
124329: NOT
124330: OR
124331: PUSH
124332: LD_VAR 0 3
124336: NOT
124337: OR
124338: IFFALSE 124342
// exit ;
124340: GO 124855
// side := mc_sides [ base ] ;
124342: LD_ADDR_VAR 0 6
124346: PUSH
124347: LD_EXP 139
124351: PUSH
124352: LD_VAR 0 1
124356: ARRAY
124357: ST_TO_ADDR
// if not side then
124358: LD_VAR 0 6
124362: NOT
124363: IFFALSE 124367
// exit ;
124365: GO 124855
// for i in solds do
124367: LD_ADDR_VAR 0 7
124371: PUSH
124372: LD_VAR 0 2
124376: PUSH
124377: FOR_IN
124378: IFFALSE 124439
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
124380: LD_VAR 0 7
124384: PPUSH
124385: CALL_OW 310
124389: PPUSH
124390: CALL_OW 266
124394: PUSH
124395: LD_INT 32
124397: PUSH
124398: LD_INT 31
124400: PUSH
124401: EMPTY
124402: LIST
124403: LIST
124404: IN
124405: IFFALSE 124425
// solds := solds diff i else
124407: LD_ADDR_VAR 0 2
124411: PUSH
124412: LD_VAR 0 2
124416: PUSH
124417: LD_VAR 0 7
124421: DIFF
124422: ST_TO_ADDR
124423: GO 124437
// SetTag ( i , 18 ) ;
124425: LD_VAR 0 7
124429: PPUSH
124430: LD_INT 18
124432: PPUSH
124433: CALL_OW 109
124437: GO 124377
124439: POP
124440: POP
// if not solds then
124441: LD_VAR 0 2
124445: NOT
124446: IFFALSE 124450
// exit ;
124448: GO 124855
// repeat wait ( 0 0$2 ) ;
124450: LD_INT 70
124452: PPUSH
124453: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
124457: LD_ADDR_VAR 0 5
124461: PUSH
124462: LD_VAR 0 6
124466: PPUSH
124467: LD_VAR 0 3
124471: PPUSH
124472: CALL 66951 0 2
124476: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124477: LD_EXP 113
124481: PUSH
124482: LD_VAR 0 1
124486: ARRAY
124487: NOT
124488: PUSH
124489: LD_EXP 113
124493: PUSH
124494: LD_VAR 0 1
124498: ARRAY
124499: PUSH
124500: EMPTY
124501: EQUAL
124502: OR
124503: IFFALSE 124540
// begin for i in solds do
124505: LD_ADDR_VAR 0 7
124509: PUSH
124510: LD_VAR 0 2
124514: PUSH
124515: FOR_IN
124516: IFFALSE 124529
// ComStop ( i ) ;
124518: LD_VAR 0 7
124522: PPUSH
124523: CALL_OW 141
124527: GO 124515
124529: POP
124530: POP
// solds := [ ] ;
124531: LD_ADDR_VAR 0 2
124535: PUSH
124536: EMPTY
124537: ST_TO_ADDR
// exit ;
124538: GO 124855
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
124540: LD_VAR 0 5
124544: NOT
124545: PUSH
124546: LD_VAR 0 5
124550: PUSH
124551: LD_INT 3
124553: GREATER
124554: OR
124555: PUSH
124556: LD_EXP 135
124560: PUSH
124561: LD_VAR 0 1
124565: ARRAY
124566: OR
124567: IFFALSE 124608
// begin for i in solds do
124569: LD_ADDR_VAR 0 7
124573: PUSH
124574: LD_VAR 0 2
124578: PUSH
124579: FOR_IN
124580: IFFALSE 124604
// if HasTask ( i ) then
124582: LD_VAR 0 7
124586: PPUSH
124587: CALL_OW 314
124591: IFFALSE 124602
// ComStop ( i ) ;
124593: LD_VAR 0 7
124597: PPUSH
124598: CALL_OW 141
124602: GO 124579
124604: POP
124605: POP
// break ;
124606: GO 124843
// end ; for i in solds do
124608: LD_ADDR_VAR 0 7
124612: PUSH
124613: LD_VAR 0 2
124617: PUSH
124618: FOR_IN
124619: IFFALSE 124835
// begin if IsInUnit ( i ) then
124621: LD_VAR 0 7
124625: PPUSH
124626: CALL_OW 310
124630: IFFALSE 124641
// ComExitBuilding ( i ) ;
124632: LD_VAR 0 7
124636: PPUSH
124637: CALL_OW 122
// if GetLives ( i ) > 333 then
124641: LD_VAR 0 7
124645: PPUSH
124646: CALL_OW 256
124650: PUSH
124651: LD_INT 333
124653: GREATER
124654: IFFALSE 124682
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
124656: LD_VAR 0 7
124660: PPUSH
124661: LD_VAR 0 5
124665: PPUSH
124666: LD_VAR 0 7
124670: PPUSH
124671: CALL_OW 74
124675: PPUSH
124676: CALL_OW 115
124680: GO 124833
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
124682: LD_ADDR_VAR 0 8
124686: PUSH
124687: LD_EXP 113
124691: PUSH
124692: LD_VAR 0 1
124696: ARRAY
124697: PPUSH
124698: LD_INT 2
124700: PUSH
124701: LD_INT 30
124703: PUSH
124704: LD_INT 0
124706: PUSH
124707: EMPTY
124708: LIST
124709: LIST
124710: PUSH
124711: LD_INT 30
124713: PUSH
124714: LD_INT 1
124716: PUSH
124717: EMPTY
124718: LIST
124719: LIST
124720: PUSH
124721: LD_INT 30
124723: PUSH
124724: LD_INT 6
124726: PUSH
124727: EMPTY
124728: LIST
124729: LIST
124730: PUSH
124731: EMPTY
124732: LIST
124733: LIST
124734: LIST
124735: LIST
124736: PPUSH
124737: CALL_OW 72
124741: PPUSH
124742: LD_VAR 0 7
124746: PPUSH
124747: CALL_OW 74
124751: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
124752: LD_VAR 0 7
124756: PPUSH
124757: LD_VAR 0 8
124761: PPUSH
124762: CALL_OW 250
124766: PPUSH
124767: LD_INT 3
124769: PPUSH
124770: LD_INT 5
124772: PPUSH
124773: CALL_OW 272
124777: PPUSH
124778: LD_VAR 0 8
124782: PPUSH
124783: CALL_OW 251
124787: PPUSH
124788: LD_INT 3
124790: PPUSH
124791: LD_INT 5
124793: PPUSH
124794: CALL_OW 273
124798: PPUSH
124799: CALL_OW 111
// SetTag ( i , 0 ) ;
124803: LD_VAR 0 7
124807: PPUSH
124808: LD_INT 0
124810: PPUSH
124811: CALL_OW 109
// solds := solds diff i ;
124815: LD_ADDR_VAR 0 2
124819: PUSH
124820: LD_VAR 0 2
124824: PUSH
124825: LD_VAR 0 7
124829: DIFF
124830: ST_TO_ADDR
// continue ;
124831: GO 124618
// end ; end ;
124833: GO 124618
124835: POP
124836: POP
// until solds ;
124837: LD_VAR 0 2
124841: IFFALSE 124450
// MC_Reset ( base , 18 ) ;
124843: LD_VAR 0 1
124847: PPUSH
124848: LD_INT 18
124850: PPUSH
124851: CALL 39199 0 2
// end ;
124855: LD_VAR 0 4
124859: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
124860: LD_INT 0
124862: PPUSH
124863: PPUSH
124864: PPUSH
124865: PPUSH
124866: PPUSH
124867: PPUSH
124868: PPUSH
124869: PPUSH
124870: PPUSH
124871: PPUSH
124872: PPUSH
124873: PPUSH
124874: PPUSH
124875: PPUSH
124876: PPUSH
124877: PPUSH
124878: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
124879: LD_ADDR_VAR 0 13
124883: PUSH
124884: LD_EXP 113
124888: PUSH
124889: LD_VAR 0 1
124893: ARRAY
124894: PPUSH
124895: LD_INT 25
124897: PUSH
124898: LD_INT 3
124900: PUSH
124901: EMPTY
124902: LIST
124903: LIST
124904: PPUSH
124905: CALL_OW 72
124909: ST_TO_ADDR
// if mc_remote_driver [ base ] then
124910: LD_EXP 153
124914: PUSH
124915: LD_VAR 0 1
124919: ARRAY
124920: IFFALSE 124944
// mechs := mechs diff mc_remote_driver [ base ] ;
124922: LD_ADDR_VAR 0 13
124926: PUSH
124927: LD_VAR 0 13
124931: PUSH
124932: LD_EXP 153
124936: PUSH
124937: LD_VAR 0 1
124941: ARRAY
124942: DIFF
124943: ST_TO_ADDR
// for i in mechs do
124944: LD_ADDR_VAR 0 5
124948: PUSH
124949: LD_VAR 0 13
124953: PUSH
124954: FOR_IN
124955: IFFALSE 124990
// if GetTag ( i ) > 0 then
124957: LD_VAR 0 5
124961: PPUSH
124962: CALL_OW 110
124966: PUSH
124967: LD_INT 0
124969: GREATER
124970: IFFALSE 124988
// mechs := mechs diff i ;
124972: LD_ADDR_VAR 0 13
124976: PUSH
124977: LD_VAR 0 13
124981: PUSH
124982: LD_VAR 0 5
124986: DIFF
124987: ST_TO_ADDR
124988: GO 124954
124990: POP
124991: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124992: LD_ADDR_VAR 0 9
124996: PUSH
124997: LD_EXP 113
125001: PUSH
125002: LD_VAR 0 1
125006: ARRAY
125007: PPUSH
125008: LD_INT 2
125010: PUSH
125011: LD_INT 25
125013: PUSH
125014: LD_INT 1
125016: PUSH
125017: EMPTY
125018: LIST
125019: LIST
125020: PUSH
125021: LD_INT 25
125023: PUSH
125024: LD_INT 5
125026: PUSH
125027: EMPTY
125028: LIST
125029: LIST
125030: PUSH
125031: LD_INT 25
125033: PUSH
125034: LD_INT 8
125036: PUSH
125037: EMPTY
125038: LIST
125039: LIST
125040: PUSH
125041: LD_INT 25
125043: PUSH
125044: LD_INT 9
125046: PUSH
125047: EMPTY
125048: LIST
125049: LIST
125050: PUSH
125051: EMPTY
125052: LIST
125053: LIST
125054: LIST
125055: LIST
125056: LIST
125057: PPUSH
125058: CALL_OW 72
125062: ST_TO_ADDR
// if not defenders and not solds then
125063: LD_VAR 0 2
125067: NOT
125068: PUSH
125069: LD_VAR 0 9
125073: NOT
125074: AND
125075: IFFALSE 125079
// exit ;
125077: GO 126769
// depot_under_attack := false ;
125079: LD_ADDR_VAR 0 17
125083: PUSH
125084: LD_INT 0
125086: ST_TO_ADDR
// sold_defenders := [ ] ;
125087: LD_ADDR_VAR 0 18
125091: PUSH
125092: EMPTY
125093: ST_TO_ADDR
// if mechs then
125094: LD_VAR 0 13
125098: IFFALSE 125251
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
125100: LD_ADDR_VAR 0 5
125104: PUSH
125105: LD_VAR 0 2
125109: PPUSH
125110: LD_INT 21
125112: PUSH
125113: LD_INT 2
125115: PUSH
125116: EMPTY
125117: LIST
125118: LIST
125119: PPUSH
125120: CALL_OW 72
125124: PUSH
125125: FOR_IN
125126: IFFALSE 125249
// begin if GetTag ( i ) <> 20 then
125128: LD_VAR 0 5
125132: PPUSH
125133: CALL_OW 110
125137: PUSH
125138: LD_INT 20
125140: NONEQUAL
125141: IFFALSE 125155
// SetTag ( i , 20 ) ;
125143: LD_VAR 0 5
125147: PPUSH
125148: LD_INT 20
125150: PPUSH
125151: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
125155: LD_VAR 0 5
125159: PPUSH
125160: CALL_OW 263
125164: PUSH
125165: LD_INT 1
125167: EQUAL
125168: PUSH
125169: LD_VAR 0 5
125173: PPUSH
125174: CALL_OW 311
125178: NOT
125179: AND
125180: IFFALSE 125247
// begin un := mechs [ 1 ] ;
125182: LD_ADDR_VAR 0 11
125186: PUSH
125187: LD_VAR 0 13
125191: PUSH
125192: LD_INT 1
125194: ARRAY
125195: ST_TO_ADDR
// ComExit ( un ) ;
125196: LD_VAR 0 11
125200: PPUSH
125201: CALL 101581 0 1
// AddComEnterUnit ( un , i ) ;
125205: LD_VAR 0 11
125209: PPUSH
125210: LD_VAR 0 5
125214: PPUSH
125215: CALL_OW 180
// SetTag ( un , 19 ) ;
125219: LD_VAR 0 11
125223: PPUSH
125224: LD_INT 19
125226: PPUSH
125227: CALL_OW 109
// mechs := mechs diff un ;
125231: LD_ADDR_VAR 0 13
125235: PUSH
125236: LD_VAR 0 13
125240: PUSH
125241: LD_VAR 0 11
125245: DIFF
125246: ST_TO_ADDR
// end ; end ;
125247: GO 125125
125249: POP
125250: POP
// if solds then
125251: LD_VAR 0 9
125255: IFFALSE 125314
// for i in solds do
125257: LD_ADDR_VAR 0 5
125261: PUSH
125262: LD_VAR 0 9
125266: PUSH
125267: FOR_IN
125268: IFFALSE 125312
// if not GetTag ( i ) then
125270: LD_VAR 0 5
125274: PPUSH
125275: CALL_OW 110
125279: NOT
125280: IFFALSE 125310
// begin defenders := defenders union i ;
125282: LD_ADDR_VAR 0 2
125286: PUSH
125287: LD_VAR 0 2
125291: PUSH
125292: LD_VAR 0 5
125296: UNION
125297: ST_TO_ADDR
// SetTag ( i , 18 ) ;
125298: LD_VAR 0 5
125302: PPUSH
125303: LD_INT 18
125305: PPUSH
125306: CALL_OW 109
// end ;
125310: GO 125267
125312: POP
125313: POP
// repeat wait ( 0 0$2 ) ;
125314: LD_INT 70
125316: PPUSH
125317: CALL_OW 67
// enemy := mc_scan [ base ] ;
125321: LD_ADDR_VAR 0 3
125325: PUSH
125326: LD_EXP 136
125330: PUSH
125331: LD_VAR 0 1
125335: ARRAY
125336: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125337: LD_EXP 113
125341: PUSH
125342: LD_VAR 0 1
125346: ARRAY
125347: NOT
125348: PUSH
125349: LD_EXP 113
125353: PUSH
125354: LD_VAR 0 1
125358: ARRAY
125359: PUSH
125360: EMPTY
125361: EQUAL
125362: OR
125363: IFFALSE 125400
// begin for i in defenders do
125365: LD_ADDR_VAR 0 5
125369: PUSH
125370: LD_VAR 0 2
125374: PUSH
125375: FOR_IN
125376: IFFALSE 125389
// ComStop ( i ) ;
125378: LD_VAR 0 5
125382: PPUSH
125383: CALL_OW 141
125387: GO 125375
125389: POP
125390: POP
// defenders := [ ] ;
125391: LD_ADDR_VAR 0 2
125395: PUSH
125396: EMPTY
125397: ST_TO_ADDR
// exit ;
125398: GO 126769
// end ; for i in defenders do
125400: LD_ADDR_VAR 0 5
125404: PUSH
125405: LD_VAR 0 2
125409: PUSH
125410: FOR_IN
125411: IFFALSE 126229
// begin e := NearestUnitToUnit ( enemy , i ) ;
125413: LD_ADDR_VAR 0 14
125417: PUSH
125418: LD_VAR 0 3
125422: PPUSH
125423: LD_VAR 0 5
125427: PPUSH
125428: CALL_OW 74
125432: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125433: LD_ADDR_VAR 0 8
125437: PUSH
125438: LD_EXP 113
125442: PUSH
125443: LD_VAR 0 1
125447: ARRAY
125448: PPUSH
125449: LD_INT 2
125451: PUSH
125452: LD_INT 30
125454: PUSH
125455: LD_INT 0
125457: PUSH
125458: EMPTY
125459: LIST
125460: LIST
125461: PUSH
125462: LD_INT 30
125464: PUSH
125465: LD_INT 1
125467: PUSH
125468: EMPTY
125469: LIST
125470: LIST
125471: PUSH
125472: EMPTY
125473: LIST
125474: LIST
125475: LIST
125476: PPUSH
125477: CALL_OW 72
125481: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
125482: LD_ADDR_VAR 0 17
125486: PUSH
125487: LD_VAR 0 8
125491: NOT
125492: PUSH
125493: LD_VAR 0 8
125497: PPUSH
125498: LD_INT 3
125500: PUSH
125501: LD_INT 24
125503: PUSH
125504: LD_INT 600
125506: PUSH
125507: EMPTY
125508: LIST
125509: LIST
125510: PUSH
125511: EMPTY
125512: LIST
125513: LIST
125514: PPUSH
125515: CALL_OW 72
125519: OR
125520: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
125521: LD_VAR 0 5
125525: PPUSH
125526: CALL_OW 247
125530: PUSH
125531: LD_INT 2
125533: DOUBLE
125534: EQUAL
125535: IFTRUE 125539
125537: GO 125935
125539: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
125540: LD_VAR 0 5
125544: PPUSH
125545: CALL_OW 256
125549: PUSH
125550: LD_INT 650
125552: GREATER
125553: PUSH
125554: LD_VAR 0 5
125558: PPUSH
125559: LD_VAR 0 14
125563: PPUSH
125564: CALL_OW 296
125568: PUSH
125569: LD_INT 40
125571: LESS
125572: PUSH
125573: LD_VAR 0 14
125577: PPUSH
125578: LD_EXP 138
125582: PUSH
125583: LD_VAR 0 1
125587: ARRAY
125588: PPUSH
125589: CALL_OW 308
125593: OR
125594: AND
125595: IFFALSE 125717
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
125597: LD_VAR 0 5
125601: PPUSH
125602: CALL_OW 262
125606: PUSH
125607: LD_INT 1
125609: EQUAL
125610: PUSH
125611: LD_VAR 0 5
125615: PPUSH
125616: CALL_OW 261
125620: PUSH
125621: LD_INT 30
125623: LESS
125624: AND
125625: PUSH
125626: LD_VAR 0 8
125630: AND
125631: IFFALSE 125701
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
125633: LD_VAR 0 5
125637: PPUSH
125638: LD_VAR 0 8
125642: PPUSH
125643: LD_VAR 0 5
125647: PPUSH
125648: CALL_OW 74
125652: PPUSH
125653: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
125657: LD_VAR 0 5
125661: PPUSH
125662: LD_VAR 0 8
125666: PPUSH
125667: LD_VAR 0 5
125671: PPUSH
125672: CALL_OW 74
125676: PPUSH
125677: CALL_OW 296
125681: PUSH
125682: LD_INT 6
125684: LESS
125685: IFFALSE 125699
// SetFuel ( i , 100 ) ;
125687: LD_VAR 0 5
125691: PPUSH
125692: LD_INT 100
125694: PPUSH
125695: CALL_OW 240
// end else
125699: GO 125715
// ComAttackUnit ( i , e ) ;
125701: LD_VAR 0 5
125705: PPUSH
125706: LD_VAR 0 14
125710: PPUSH
125711: CALL_OW 115
// end else
125715: GO 125818
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
125717: LD_VAR 0 14
125721: PPUSH
125722: LD_EXP 138
125726: PUSH
125727: LD_VAR 0 1
125731: ARRAY
125732: PPUSH
125733: CALL_OW 308
125737: NOT
125738: PUSH
125739: LD_VAR 0 5
125743: PPUSH
125744: LD_VAR 0 14
125748: PPUSH
125749: CALL_OW 296
125753: PUSH
125754: LD_INT 40
125756: GREATEREQUAL
125757: AND
125758: PUSH
125759: LD_VAR 0 5
125763: PPUSH
125764: CALL_OW 256
125768: PUSH
125769: LD_INT 650
125771: LESSEQUAL
125772: OR
125773: PUSH
125774: LD_VAR 0 5
125778: PPUSH
125779: LD_EXP 137
125783: PUSH
125784: LD_VAR 0 1
125788: ARRAY
125789: PPUSH
125790: CALL_OW 308
125794: NOT
125795: AND
125796: IFFALSE 125818
// ComMoveToArea ( i , mc_parking [ base ] ) ;
125798: LD_VAR 0 5
125802: PPUSH
125803: LD_EXP 137
125807: PUSH
125808: LD_VAR 0 1
125812: ARRAY
125813: PPUSH
125814: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
125818: LD_VAR 0 5
125822: PPUSH
125823: CALL_OW 256
125827: PUSH
125828: LD_INT 998
125830: LESS
125831: PUSH
125832: LD_VAR 0 5
125836: PPUSH
125837: CALL_OW 263
125841: PUSH
125842: LD_INT 1
125844: EQUAL
125845: AND
125846: PUSH
125847: LD_VAR 0 5
125851: PPUSH
125852: CALL_OW 311
125856: AND
125857: PUSH
125858: LD_VAR 0 5
125862: PPUSH
125863: LD_EXP 137
125867: PUSH
125868: LD_VAR 0 1
125872: ARRAY
125873: PPUSH
125874: CALL_OW 308
125878: AND
125879: IFFALSE 125933
// begin mech := IsDrivenBy ( i ) ;
125881: LD_ADDR_VAR 0 10
125885: PUSH
125886: LD_VAR 0 5
125890: PPUSH
125891: CALL_OW 311
125895: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
125896: LD_VAR 0 10
125900: PPUSH
125901: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
125905: LD_VAR 0 10
125909: PPUSH
125910: LD_VAR 0 5
125914: PPUSH
125915: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
125919: LD_VAR 0 10
125923: PPUSH
125924: LD_VAR 0 5
125928: PPUSH
125929: CALL_OW 180
// end ; end ; unit_human :
125933: GO 126200
125935: LD_INT 1
125937: DOUBLE
125938: EQUAL
125939: IFTRUE 125943
125941: GO 126199
125943: POP
// begin b := IsInUnit ( i ) ;
125944: LD_ADDR_VAR 0 19
125948: PUSH
125949: LD_VAR 0 5
125953: PPUSH
125954: CALL_OW 310
125958: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
125959: LD_ADDR_VAR 0 20
125963: PUSH
125964: LD_VAR 0 19
125968: NOT
125969: PUSH
125970: LD_VAR 0 19
125974: PPUSH
125975: CALL_OW 266
125979: PUSH
125980: LD_INT 32
125982: PUSH
125983: LD_INT 31
125985: PUSH
125986: EMPTY
125987: LIST
125988: LIST
125989: IN
125990: OR
125991: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
125992: LD_VAR 0 17
125996: PUSH
125997: LD_VAR 0 2
126001: PPUSH
126002: LD_INT 21
126004: PUSH
126005: LD_INT 2
126007: PUSH
126008: EMPTY
126009: LIST
126010: LIST
126011: PPUSH
126012: CALL_OW 72
126016: PUSH
126017: LD_INT 1
126019: LESSEQUAL
126020: OR
126021: PUSH
126022: LD_VAR 0 20
126026: AND
126027: PUSH
126028: LD_VAR 0 5
126032: PUSH
126033: LD_VAR 0 18
126037: IN
126038: NOT
126039: AND
126040: IFFALSE 126133
// begin if b then
126042: LD_VAR 0 19
126046: IFFALSE 126095
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
126048: LD_VAR 0 19
126052: PPUSH
126053: LD_VAR 0 3
126057: PPUSH
126058: LD_VAR 0 19
126062: PPUSH
126063: CALL_OW 74
126067: PPUSH
126068: CALL_OW 296
126072: PUSH
126073: LD_INT 10
126075: LESS
126076: PUSH
126077: LD_VAR 0 19
126081: PPUSH
126082: CALL_OW 461
126086: PUSH
126087: LD_INT 7
126089: NONEQUAL
126090: AND
126091: IFFALSE 126095
// continue ;
126093: GO 125410
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
126095: LD_ADDR_VAR 0 18
126099: PUSH
126100: LD_VAR 0 18
126104: PPUSH
126105: LD_VAR 0 18
126109: PUSH
126110: LD_INT 1
126112: PLUS
126113: PPUSH
126114: LD_VAR 0 5
126118: PPUSH
126119: CALL_OW 1
126123: ST_TO_ADDR
// ComExitBuilding ( i ) ;
126124: LD_VAR 0 5
126128: PPUSH
126129: CALL_OW 122
// end ; if sold_defenders then
126133: LD_VAR 0 18
126137: IFFALSE 126197
// if i in sold_defenders then
126139: LD_VAR 0 5
126143: PUSH
126144: LD_VAR 0 18
126148: IN
126149: IFFALSE 126197
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
126151: LD_VAR 0 5
126155: PPUSH
126156: CALL_OW 314
126160: NOT
126161: PUSH
126162: LD_VAR 0 5
126166: PPUSH
126167: LD_VAR 0 14
126171: PPUSH
126172: CALL_OW 296
126176: PUSH
126177: LD_INT 30
126179: LESS
126180: AND
126181: IFFALSE 126197
// ComAttackUnit ( i , e ) ;
126183: LD_VAR 0 5
126187: PPUSH
126188: LD_VAR 0 14
126192: PPUSH
126193: CALL_OW 115
// end ; end ; end ;
126197: GO 126200
126199: POP
// if IsDead ( i ) then
126200: LD_VAR 0 5
126204: PPUSH
126205: CALL_OW 301
126209: IFFALSE 126227
// defenders := defenders diff i ;
126211: LD_ADDR_VAR 0 2
126215: PUSH
126216: LD_VAR 0 2
126220: PUSH
126221: LD_VAR 0 5
126225: DIFF
126226: ST_TO_ADDR
// end ;
126227: GO 125410
126229: POP
126230: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
126231: LD_VAR 0 3
126235: NOT
126236: PUSH
126237: LD_VAR 0 2
126241: NOT
126242: OR
126243: PUSH
126244: LD_EXP 113
126248: PUSH
126249: LD_VAR 0 1
126253: ARRAY
126254: NOT
126255: OR
126256: IFFALSE 125314
// MC_Reset ( base , 18 ) ;
126258: LD_VAR 0 1
126262: PPUSH
126263: LD_INT 18
126265: PPUSH
126266: CALL 39199 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126270: LD_ADDR_VAR 0 2
126274: PUSH
126275: LD_VAR 0 2
126279: PUSH
126280: LD_VAR 0 2
126284: PPUSH
126285: LD_INT 2
126287: PUSH
126288: LD_INT 25
126290: PUSH
126291: LD_INT 1
126293: PUSH
126294: EMPTY
126295: LIST
126296: LIST
126297: PUSH
126298: LD_INT 25
126300: PUSH
126301: LD_INT 5
126303: PUSH
126304: EMPTY
126305: LIST
126306: LIST
126307: PUSH
126308: LD_INT 25
126310: PUSH
126311: LD_INT 8
126313: PUSH
126314: EMPTY
126315: LIST
126316: LIST
126317: PUSH
126318: LD_INT 25
126320: PUSH
126321: LD_INT 9
126323: PUSH
126324: EMPTY
126325: LIST
126326: LIST
126327: PUSH
126328: EMPTY
126329: LIST
126330: LIST
126331: LIST
126332: LIST
126333: LIST
126334: PPUSH
126335: CALL_OW 72
126339: DIFF
126340: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
126341: LD_VAR 0 3
126345: NOT
126346: PUSH
126347: LD_VAR 0 2
126351: PPUSH
126352: LD_INT 21
126354: PUSH
126355: LD_INT 2
126357: PUSH
126358: EMPTY
126359: LIST
126360: LIST
126361: PPUSH
126362: CALL_OW 72
126366: AND
126367: IFFALSE 126705
// begin tmp := FilterByTag ( defenders , 19 ) ;
126369: LD_ADDR_VAR 0 12
126373: PUSH
126374: LD_VAR 0 2
126378: PPUSH
126379: LD_INT 19
126381: PPUSH
126382: CALL 98711 0 2
126386: ST_TO_ADDR
// if tmp then
126387: LD_VAR 0 12
126391: IFFALSE 126461
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
126393: LD_ADDR_VAR 0 12
126397: PUSH
126398: LD_VAR 0 12
126402: PPUSH
126403: LD_INT 25
126405: PUSH
126406: LD_INT 3
126408: PUSH
126409: EMPTY
126410: LIST
126411: LIST
126412: PPUSH
126413: CALL_OW 72
126417: ST_TO_ADDR
// if tmp then
126418: LD_VAR 0 12
126422: IFFALSE 126461
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
126424: LD_ADDR_EXP 125
126428: PUSH
126429: LD_EXP 125
126433: PPUSH
126434: LD_VAR 0 1
126438: PPUSH
126439: LD_EXP 125
126443: PUSH
126444: LD_VAR 0 1
126448: ARRAY
126449: PUSH
126450: LD_VAR 0 12
126454: UNION
126455: PPUSH
126456: CALL_OW 1
126460: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
126461: LD_VAR 0 1
126465: PPUSH
126466: LD_INT 19
126468: PPUSH
126469: CALL 39199 0 2
// repeat wait ( 0 0$1 ) ;
126473: LD_INT 35
126475: PPUSH
126476: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126480: LD_EXP 113
126484: PUSH
126485: LD_VAR 0 1
126489: ARRAY
126490: NOT
126491: PUSH
126492: LD_EXP 113
126496: PUSH
126497: LD_VAR 0 1
126501: ARRAY
126502: PUSH
126503: EMPTY
126504: EQUAL
126505: OR
126506: IFFALSE 126543
// begin for i in defenders do
126508: LD_ADDR_VAR 0 5
126512: PUSH
126513: LD_VAR 0 2
126517: PUSH
126518: FOR_IN
126519: IFFALSE 126532
// ComStop ( i ) ;
126521: LD_VAR 0 5
126525: PPUSH
126526: CALL_OW 141
126530: GO 126518
126532: POP
126533: POP
// defenders := [ ] ;
126534: LD_ADDR_VAR 0 2
126538: PUSH
126539: EMPTY
126540: ST_TO_ADDR
// exit ;
126541: GO 126769
// end ; for i in defenders do
126543: LD_ADDR_VAR 0 5
126547: PUSH
126548: LD_VAR 0 2
126552: PUSH
126553: FOR_IN
126554: IFFALSE 126643
// begin if not IsInArea ( i , mc_parking [ base ] ) then
126556: LD_VAR 0 5
126560: PPUSH
126561: LD_EXP 137
126565: PUSH
126566: LD_VAR 0 1
126570: ARRAY
126571: PPUSH
126572: CALL_OW 308
126576: NOT
126577: IFFALSE 126601
// ComMoveToArea ( i , mc_parking [ base ] ) else
126579: LD_VAR 0 5
126583: PPUSH
126584: LD_EXP 137
126588: PUSH
126589: LD_VAR 0 1
126593: ARRAY
126594: PPUSH
126595: CALL_OW 113
126599: GO 126641
// if GetControl ( i ) = control_manual then
126601: LD_VAR 0 5
126605: PPUSH
126606: CALL_OW 263
126610: PUSH
126611: LD_INT 1
126613: EQUAL
126614: IFFALSE 126641
// if IsDrivenBy ( i ) then
126616: LD_VAR 0 5
126620: PPUSH
126621: CALL_OW 311
126625: IFFALSE 126641
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
126627: LD_VAR 0 5
126631: PPUSH
126632: CALL_OW 311
126636: PPUSH
126637: CALL_OW 121
// end ;
126641: GO 126553
126643: POP
126644: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
126645: LD_VAR 0 2
126649: PPUSH
126650: LD_INT 95
126652: PUSH
126653: LD_EXP 137
126657: PUSH
126658: LD_VAR 0 1
126662: ARRAY
126663: PUSH
126664: EMPTY
126665: LIST
126666: LIST
126667: PPUSH
126668: CALL_OW 72
126672: PUSH
126673: LD_VAR 0 2
126677: EQUAL
126678: PUSH
126679: LD_EXP 136
126683: PUSH
126684: LD_VAR 0 1
126688: ARRAY
126689: OR
126690: PUSH
126691: LD_EXP 113
126695: PUSH
126696: LD_VAR 0 1
126700: ARRAY
126701: NOT
126702: OR
126703: IFFALSE 126473
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
126705: LD_ADDR_EXP 135
126709: PUSH
126710: LD_EXP 135
126714: PPUSH
126715: LD_VAR 0 1
126719: PPUSH
126720: LD_VAR 0 2
126724: PPUSH
126725: LD_INT 21
126727: PUSH
126728: LD_INT 2
126730: PUSH
126731: EMPTY
126732: LIST
126733: LIST
126734: PPUSH
126735: CALL_OW 72
126739: PPUSH
126740: CALL_OW 1
126744: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
126745: LD_VAR 0 1
126749: PPUSH
126750: LD_INT 19
126752: PPUSH
126753: CALL 39199 0 2
// MC_Reset ( base , 20 ) ;
126757: LD_VAR 0 1
126761: PPUSH
126762: LD_INT 20
126764: PPUSH
126765: CALL 39199 0 2
// end ; end_of_file
126769: LD_VAR 0 4
126773: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
126774: LD_VAR 0 1
126778: PUSH
126779: LD_INT 200
126781: DOUBLE
126782: GREATEREQUAL
126783: IFFALSE 126791
126785: LD_INT 299
126787: DOUBLE
126788: LESSEQUAL
126789: IFTRUE 126793
126791: GO 126825
126793: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
126794: LD_VAR 0 1
126798: PPUSH
126799: LD_VAR 0 2
126803: PPUSH
126804: LD_VAR 0 3
126808: PPUSH
126809: LD_VAR 0 4
126813: PPUSH
126814: LD_VAR 0 5
126818: PPUSH
126819: CALL 115707 0 5
126823: GO 126826
126825: POP
// end ;
126826: PPOPN 11
126828: END
