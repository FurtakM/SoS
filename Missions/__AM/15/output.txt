// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39574 0 0
// InitNature ;
  19: CALL 39442 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12660 0 0
// PrepareRussian ;
  40: CALL 7610 0 0
// PrepareLegion ;
  44: CALL 4678 0 0
// PreparePowell ;
  48: CALL 3212 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17590 0 0
// MC_Start ( ) ;
  60: CALL 41754 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 64550 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64643 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63993 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63808 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 64550 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64643 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63808 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63993 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64423 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 63471 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 64550 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64643 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63808 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 64550 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64643 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63700 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64961 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64132 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64423 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64423 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64755 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63808 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64374 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 70282 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1942
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1879: LD_INT 5
1881: PUSH
1882: LD_INT 5
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 3
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: PUSH
1897: LD_OWVAR 67
1901: ARRAY
1902: PPUSH
1903: LD_INT 3
1905: PPUSH
1906: LD_INT 1
1908: PPUSH
1909: LD_INT 9
1911: PUSH
1912: LD_INT 9
1914: PUSH
1915: LD_INT 5
1917: PUSH
1918: LD_INT 5
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: PUSH
1927: LD_OWVAR 67
1931: ARRAY
1932: PPUSH
1933: LD_INT 100
1935: PPUSH
1936: CALL 75122 0 5
1940: GO 2001
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1942: LD_EXP 4
1946: PUSH
1947: LD_INT 1
1949: ARRAY
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PPUSH
1955: LD_EXP 4
1959: PUSH
1960: LD_INT 2
1962: ARRAY
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: LD_EXP 4
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PUSH
1977: LD_INT 1
1979: ARRAY
1980: PPUSH
1981: LD_EXP 4
1985: PUSH
1986: LD_INT 4
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_INT 30
1996: PPUSH
1997: CALL 75122 0 5
// JMMNewVeh := CreateVehicle ;
2001: LD_ADDR_EXP 59
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// if not JMMNewVeh then
2011: LD_EXP 59
2015: NOT
2016: IFFALSE 2047
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2018: LD_INT 5
2020: PPUSH
2021: LD_INT 3
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_INT 9
2029: PPUSH
2030: LD_INT 100
2032: PPUSH
2033: CALL 75122 0 5
// JMMNewVeh := CreateVehicle ;
2037: LD_ADDR_EXP 59
2041: PUSH
2042: CALL_OW 45
2046: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2047: LD_EXP 59
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2059: LD_EXP 59
2063: PPUSH
2064: LD_INT 1
2066: NEG
2067: PPUSH
2068: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2072: LD_EXP 59
2076: PPUSH
2077: LD_INT 79
2079: PPUSH
2080: LD_INT 91
2082: PPUSH
2083: LD_INT 0
2085: PPUSH
2086: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2090: LD_EXP 40
2094: PPUSH
2095: LD_EXP 59
2099: PPUSH
2100: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2104: LD_EXP 6
2108: PUSH
2109: LD_EXP 2
2113: NOT
2114: AND
2115: IFFALSE 2373
// begin if not JMMGirlVeh then
2117: LD_EXP 5
2121: NOT
2122: IFFALSE 2145
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2124: LD_INT 3
2126: PPUSH
2127: LD_INT 3
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 9
2135: PPUSH
2136: LD_INT 100
2138: PPUSH
2139: CALL 75122 0 5
2143: GO 2204
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2145: LD_EXP 5
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 1
2156: ARRAY
2157: PPUSH
2158: LD_EXP 5
2162: PUSH
2163: LD_INT 2
2165: ARRAY
2166: PUSH
2167: LD_INT 1
2169: ARRAY
2170: PPUSH
2171: LD_EXP 5
2175: PUSH
2176: LD_INT 3
2178: ARRAY
2179: PUSH
2180: LD_INT 1
2182: ARRAY
2183: PPUSH
2184: LD_EXP 5
2188: PUSH
2189: LD_INT 4
2191: ARRAY
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_INT 30
2199: PPUSH
2200: CALL 75122 0 5
// GirlNewVeh := CreateVehicle ;
2204: LD_ADDR_EXP 60
2208: PUSH
2209: CALL_OW 45
2213: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2214: LD_EXP 60
2218: PPUSH
2219: LD_INT 4
2221: PPUSH
2222: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2226: LD_EXP 60
2230: PPUSH
2231: LD_INT 82
2233: PPUSH
2234: LD_INT 96
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 48
// if JMMGirl = 1 then
2244: LD_EXP 7
2248: PUSH
2249: LD_INT 1
2251: EQUAL
2252: IFFALSE 2287
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2254: LD_ADDR_EXP 41
2258: PUSH
2259: LD_STRING Joan
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_STRING 14_
2267: PPUSH
2268: CALL 70282 0 3
2272: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2273: LD_EXP 41
2277: PPUSH
2278: LD_EXP 60
2282: PPUSH
2283: CALL_OW 52
// end ; if JMMGirl = 2 then
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: EQUAL
2295: IFFALSE 2330
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2297: LD_ADDR_EXP 43
2301: PUSH
2302: LD_STRING Lisa
2304: PPUSH
2305: LD_INT 1
2307: PPUSH
2308: LD_STRING 14_
2310: PPUSH
2311: CALL 70282 0 3
2315: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2316: LD_EXP 43
2320: PPUSH
2321: LD_EXP 60
2325: PPUSH
2326: CALL_OW 52
// end ; if JMMGirl = 3 then
2330: LD_EXP 7
2334: PUSH
2335: LD_INT 3
2337: EQUAL
2338: IFFALSE 2373
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2340: LD_ADDR_EXP 55
2344: PUSH
2345: LD_STRING Connie
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_STRING 14_
2353: PPUSH
2354: CALL 70282 0 3
2358: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2359: LD_EXP 55
2363: PPUSH
2364: LD_EXP 60
2368: PPUSH
2369: CALL_OW 52
// end ; end ; end ;
2373: LD_VAR 0 1
2377: RET
// export function PrepareStevensSquad ; var tmp ; begin
2378: LD_INT 0
2380: PPUSH
2381: PPUSH
// uc_side := 1 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 1
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// tmp := [ ] ;
2398: LD_ADDR_VAR 0 2
2402: PUSH
2403: EMPTY
2404: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2405: LD_ADDR_EXP 42
2409: PUSH
2410: LD_STRING Stevens
2412: PPUSH
2413: LD_EXP 1
2417: NOT
2418: PPUSH
2419: LD_STRING 13f_
2421: PPUSH
2422: CALL 70282 0 3
2426: ST_TO_ADDR
// if not Stevens then
2427: LD_EXP 42
2431: NOT
2432: IFFALSE 2546
// begin hc_name = Baker Smith ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Baker Smith
2441: ST_TO_ADDR
// hc_gallery = us ;
2442: LD_ADDR_OWVAR 33
2446: PUSH
2447: LD_STRING us
2449: ST_TO_ADDR
// hc_face_number := 29 ;
2450: LD_ADDR_OWVAR 34
2454: PUSH
2455: LD_INT 29
2457: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2458: LD_INT 1
2460: PPUSH
2461: LD_INT 10
2463: PPUSH
2464: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2468: LD_ADDR_OWVAR 30
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: LD_INT 2
2478: PUSH
2479: LD_INT 0
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2491: LD_ADDR_OWVAR 31
2495: PUSH
2496: LD_INT 4
2498: PUSH
2499: LD_INT 5
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 10
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: ST_TO_ADDR
// Baker := CreateHuman ;
2514: LD_ADDR_EXP 56
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: LD_EXP 56
2538: ADD
2539: ST_TO_ADDR
// InitHc ;
2540: CALL_OW 19
// end else
2544: GO 2562
// tmp := tmp ^ Stevens ;
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_VAR 0 2
2555: PUSH
2556: LD_EXP 42
2560: ADD
2561: ST_TO_ADDR
// if not Lisa then
2562: LD_EXP 43
2566: NOT
2567: IFFALSE 2613
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2569: LD_ADDR_EXP 43
2573: PUSH
2574: LD_STRING Lisa
2576: PPUSH
2577: LD_EXP 1
2581: NOT
2582: PPUSH
2583: LD_STRING 13f_
2585: PPUSH
2586: CALL 70282 0 3
2590: ST_TO_ADDR
// if Lisa then
2591: LD_EXP 43
2595: IFFALSE 2613
// tmp := tmp ^ Lisa ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_VAR 0 2
2606: PUSH
2607: LD_EXP 43
2611: ADD
2612: ST_TO_ADDR
// end ; if not Donaldson then
2613: LD_EXP 44
2617: NOT
2618: IFFALSE 2664
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2620: LD_ADDR_EXP 44
2624: PUSH
2625: LD_STRING Donaldson
2627: PPUSH
2628: LD_EXP 1
2632: NOT
2633: PPUSH
2634: LD_STRING 13f_
2636: PPUSH
2637: CALL 70282 0 3
2641: ST_TO_ADDR
// if Donaldson then
2642: LD_EXP 44
2646: IFFALSE 2664
// tmp := tmp ^ Donaldson ;
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: LD_VAR 0 2
2657: PUSH
2658: LD_EXP 44
2662: ADD
2663: ST_TO_ADDR
// end ; if not Bobby then
2664: LD_EXP 45
2668: NOT
2669: IFFALSE 2715
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2671: LD_ADDR_EXP 45
2675: PUSH
2676: LD_STRING Bobby
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_STRING 13f_
2687: PPUSH
2688: CALL 70282 0 3
2692: ST_TO_ADDR
// if Bobby then
2693: LD_EXP 45
2697: IFFALSE 2715
// tmp := tmp ^ Bobby ;
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: LD_EXP 45
2713: ADD
2714: ST_TO_ADDR
// end ; if not Cyrus then
2715: LD_EXP 46
2719: NOT
2720: IFFALSE 2766
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2722: LD_ADDR_EXP 46
2726: PUSH
2727: LD_STRING Cyrus
2729: PPUSH
2730: LD_EXP 1
2734: NOT
2735: PPUSH
2736: LD_STRING 13f_
2738: PPUSH
2739: CALL 70282 0 3
2743: ST_TO_ADDR
// if Cyrus then
2744: LD_EXP 46
2748: IFFALSE 2766
// tmp := tmp ^ Cyrus ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_VAR 0 2
2759: PUSH
2760: LD_EXP 46
2764: ADD
2765: ST_TO_ADDR
// end ; if not Brown then
2766: LD_EXP 48
2770: NOT
2771: IFFALSE 2817
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2773: LD_ADDR_EXP 48
2777: PUSH
2778: LD_STRING Brown
2780: PPUSH
2781: LD_EXP 1
2785: NOT
2786: PPUSH
2787: LD_STRING 13f_
2789: PPUSH
2790: CALL 70282 0 3
2794: ST_TO_ADDR
// if Brown then
2795: LD_EXP 48
2799: IFFALSE 2817
// tmp := tmp ^ Brown ;
2801: LD_ADDR_VAR 0 2
2805: PUSH
2806: LD_VAR 0 2
2810: PUSH
2811: LD_EXP 48
2815: ADD
2816: ST_TO_ADDR
// end ; if not Gladstone then
2817: LD_EXP 49
2821: NOT
2822: IFFALSE 2868
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2824: LD_ADDR_EXP 49
2828: PUSH
2829: LD_STRING Gladstone
2831: PPUSH
2832: LD_EXP 1
2836: NOT
2837: PPUSH
2838: LD_STRING 13f_
2840: PPUSH
2841: CALL 70282 0 3
2845: ST_TO_ADDR
// if Gladstone then
2846: LD_EXP 49
2850: IFFALSE 2868
// tmp := tmp ^ Gladstone ;
2852: LD_ADDR_VAR 0 2
2856: PUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_EXP 49
2866: ADD
2867: ST_TO_ADDR
// end ; if not Houten then
2868: LD_EXP 50
2872: NOT
2873: IFFALSE 2919
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2875: LD_ADDR_EXP 50
2879: PUSH
2880: LD_STRING Houten
2882: PPUSH
2883: LD_EXP 1
2887: NOT
2888: PPUSH
2889: LD_STRING 13f_
2891: PPUSH
2892: CALL 70282 0 3
2896: ST_TO_ADDR
// if Houten then
2897: LD_EXP 50
2901: IFFALSE 2919
// tmp := tmp ^ Houten ;
2903: LD_ADDR_VAR 0 2
2907: PUSH
2908: LD_VAR 0 2
2912: PUSH
2913: LD_EXP 50
2917: ADD
2918: ST_TO_ADDR
// end ; if not Cornel then
2919: LD_EXP 51
2923: NOT
2924: IFFALSE 2970
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2926: LD_ADDR_EXP 51
2930: PUSH
2931: LD_STRING Cornell
2933: PPUSH
2934: LD_EXP 1
2938: NOT
2939: PPUSH
2940: LD_STRING 13f_
2942: PPUSH
2943: CALL 70282 0 3
2947: ST_TO_ADDR
// if Cornel then
2948: LD_EXP 51
2952: IFFALSE 2970
// tmp := tmp ^ Cornel ;
2954: LD_ADDR_VAR 0 2
2958: PUSH
2959: LD_VAR 0 2
2963: PUSH
2964: LD_EXP 51
2968: ADD
2969: ST_TO_ADDR
// end ; if not Gary then
2970: LD_EXP 52
2974: NOT
2975: IFFALSE 3021
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2977: LD_ADDR_EXP 52
2981: PUSH
2982: LD_STRING Gary
2984: PPUSH
2985: LD_EXP 1
2989: NOT
2990: PPUSH
2991: LD_STRING 13f_
2993: PPUSH
2994: CALL 70282 0 3
2998: ST_TO_ADDR
// if Gary then
2999: LD_EXP 52
3003: IFFALSE 3021
// tmp := tmp ^ Gary ;
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_VAR 0 2
3014: PUSH
3015: LD_EXP 52
3019: ADD
3020: ST_TO_ADDR
// end ; if not Frank then
3021: LD_EXP 53
3025: NOT
3026: IFFALSE 3072
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3028: LD_ADDR_EXP 53
3032: PUSH
3033: LD_STRING Frank
3035: PPUSH
3036: LD_EXP 1
3040: NOT
3041: PPUSH
3042: LD_STRING 13f_
3044: PPUSH
3045: CALL 70282 0 3
3049: ST_TO_ADDR
// if Frank then
3050: LD_EXP 53
3054: IFFALSE 3072
// tmp := tmp ^ Frank ;
3056: LD_ADDR_VAR 0 2
3060: PUSH
3061: LD_VAR 0 2
3065: PUSH
3066: LD_EXP 53
3070: ADD
3071: ST_TO_ADDR
// end ; if not Kikuchi then
3072: LD_EXP 54
3076: NOT
3077: IFFALSE 3123
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3079: LD_ADDR_EXP 54
3083: PUSH
3084: LD_STRING Kikuchi
3086: PPUSH
3087: LD_EXP 1
3091: NOT
3092: PPUSH
3093: LD_STRING 13f_
3095: PPUSH
3096: CALL 70282 0 3
3100: ST_TO_ADDR
// if Kikuchi then
3101: LD_EXP 54
3105: IFFALSE 3123
// tmp := tmp ^ Kikuchi ;
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_VAR 0 2
3116: PUSH
3117: LD_EXP 54
3121: ADD
3122: ST_TO_ADDR
// end ; if not DeltaDoctor then
3123: LD_EXP 58
3127: NOT
3128: IFFALSE 3174
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3130: LD_ADDR_EXP 58
3134: PUSH
3135: LD_STRING DeltaDoctor
3137: PPUSH
3138: LD_EXP 1
3142: NOT
3143: PPUSH
3144: LD_STRING 13f_
3146: PPUSH
3147: CALL 70282 0 3
3151: ST_TO_ADDR
// if Bobby then
3152: LD_EXP 45
3156: IFFALSE 3174
// tmp := tmp ^ DeltaDoctor ;
3158: LD_ADDR_VAR 0 2
3162: PUSH
3163: LD_VAR 0 2
3167: PUSH
3168: LD_EXP 58
3172: ADD
3173: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 2
3183: PUSH
3184: LD_STRING 13_other_survivors
3186: PPUSH
3187: CALL_OW 31
3191: UNION
3192: ST_TO_ADDR
// result := tmp diff 0 ;
3193: LD_ADDR_VAR 0 1
3197: PUSH
3198: LD_VAR 0 2
3202: PUSH
3203: LD_INT 0
3205: DIFF
3206: ST_TO_ADDR
// end ; end_of_file
3207: LD_VAR 0 1
3211: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
// uc_side := 4 ;
3224: LD_ADDR_OWVAR 20
3228: PUSH
3229: LD_INT 4
3231: ST_TO_ADDR
// uc_nation := 1 ;
3232: LD_ADDR_OWVAR 21
3236: PUSH
3237: LD_INT 1
3239: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3240: LD_INT 387
3242: PPUSH
3243: CALL_OW 274
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: LD_INT 3500
3253: PUSH
3254: LD_INT 3000
3256: PUSH
3257: LD_INT 2500
3259: PUSH
3260: LD_INT 2000
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: PUSH
3269: LD_OWVAR 67
3273: ARRAY
3274: PPUSH
3275: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3279: LD_INT 387
3281: PPUSH
3282: CALL_OW 274
3286: PPUSH
3287: LD_INT 2
3289: PPUSH
3290: LD_INT 400
3292: PPUSH
3293: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3297: LD_INT 387
3299: PPUSH
3300: CALL_OW 274
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 10
3310: PPUSH
3311: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3315: LD_INT 387
3317: PPUSH
3318: LD_STRING sigma
3320: PPUSH
3321: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3325: LD_ADDR_EXP 61
3329: PUSH
3330: LD_STRING Powell
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3338: LD_EXP 61
3342: PPUSH
3343: LD_INT 57
3345: PPUSH
3346: LD_INT 94
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3356: LD_EXP 61
3360: PPUSH
3361: LD_INT 58
3363: PPUSH
3364: LD_INT 94
3366: PPUSH
3367: CALL_OW 118
// vip := [ ] ;
3371: LD_ADDR_EXP 62
3375: PUSH
3376: EMPTY
3377: ST_TO_ADDR
// extraSquad := [ ] ;
3378: LD_ADDR_EXP 63
3382: PUSH
3383: EMPTY
3384: ST_TO_ADDR
// tmp := [ ] ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: EMPTY
3391: ST_TO_ADDR
// if JMMGirl <> 2 then
3392: LD_EXP 7
3396: PUSH
3397: LD_INT 2
3399: NONEQUAL
3400: IFFALSE 3424
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3402: LD_ADDR_EXP 43
3406: PUSH
3407: LD_STRING Lisa
3409: PPUSH
3410: LD_EXP 1
3414: NOT
3415: PPUSH
3416: LD_STRING 13s_
3418: PPUSH
3419: CALL 70282 0 3
3423: ST_TO_ADDR
// if Lisa then
3424: LD_EXP 43
3428: IFFALSE 3446
// tmp := tmp ^ Lisa ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_EXP 43
3444: ADD
3445: ST_TO_ADDR
// if JMMGirl < 3 then
3446: LD_EXP 7
3450: PUSH
3451: LD_INT 3
3453: LESS
3454: IFFALSE 3485
// begin Connie := NewCharacter ( Coonie ) ;
3456: LD_ADDR_EXP 55
3460: PUSH
3461: LD_STRING Coonie
3463: PPUSH
3464: CALL_OW 25
3468: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: LD_EXP 55
3483: ADD
3484: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3485: LD_ADDR_EXP 44
3489: PUSH
3490: LD_STRING Donaldson
3492: PPUSH
3493: LD_EXP 1
3497: NOT
3498: PPUSH
3499: LD_STRING 13s_
3501: PPUSH
3502: CALL 70282 0 3
3506: ST_TO_ADDR
// if Donaldson then
3507: LD_EXP 44
3511: IFFALSE 3529
// tmp := tmp ^ Donaldson ;
3513: LD_ADDR_VAR 0 5
3517: PUSH
3518: LD_VAR 0 5
3522: PUSH
3523: LD_EXP 44
3527: ADD
3528: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3529: LD_ADDR_EXP 45
3533: PUSH
3534: LD_STRING Bobby
3536: PPUSH
3537: LD_EXP 1
3541: NOT
3542: PPUSH
3543: LD_STRING 13s_
3545: PPUSH
3546: CALL 70282 0 3
3550: ST_TO_ADDR
// if Bobby then
3551: LD_EXP 45
3555: IFFALSE 3573
// tmp := tmp ^ Bobby ;
3557: LD_ADDR_VAR 0 5
3561: PUSH
3562: LD_VAR 0 5
3566: PUSH
3567: LD_EXP 45
3571: ADD
3572: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3573: LD_ADDR_EXP 46
3577: PUSH
3578: LD_STRING Cyrus
3580: PPUSH
3581: LD_EXP 1
3585: NOT
3586: PPUSH
3587: LD_STRING 13s_
3589: PPUSH
3590: CALL 70282 0 3
3594: ST_TO_ADDR
// if Cyrus then
3595: LD_EXP 46
3599: IFFALSE 3617
// tmp := tmp ^ Cyrus ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: LD_EXP 46
3615: ADD
3616: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3617: LD_ADDR_EXP 47
3621: PUSH
3622: LD_STRING Denis
3624: PPUSH
3625: LD_EXP 1
3629: NOT
3630: PPUSH
3631: LD_STRING 13s_
3633: PPUSH
3634: CALL 70282 0 3
3638: ST_TO_ADDR
// if not Denis then
3639: LD_EXP 47
3643: NOT
3644: IFFALSE 3668
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3646: LD_ADDR_EXP 47
3650: PUSH
3651: LD_STRING Denis
3653: PPUSH
3654: LD_EXP 1
3658: NOT
3659: PPUSH
3660: LD_STRING 13f_
3662: PPUSH
3663: CALL 70282 0 3
3667: ST_TO_ADDR
// if Denis then
3668: LD_EXP 47
3672: IFFALSE 3690
// tmp := tmp ^ Denis ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_VAR 0 5
3683: PUSH
3684: LD_EXP 47
3688: ADD
3689: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3690: LD_ADDR_EXP 48
3694: PUSH
3695: LD_STRING Brown
3697: PPUSH
3698: LD_EXP 1
3702: NOT
3703: PPUSH
3704: LD_STRING 13s_
3706: PPUSH
3707: CALL 70282 0 3
3711: ST_TO_ADDR
// if Brown then
3712: LD_EXP 48
3716: IFFALSE 3734
// tmp := tmp ^ Brown ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_VAR 0 5
3727: PUSH
3728: LD_EXP 48
3732: ADD
3733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3734: LD_ADDR_EXP 49
3738: PUSH
3739: LD_STRING Gladstone
3741: PPUSH
3742: LD_EXP 1
3746: NOT
3747: PPUSH
3748: LD_STRING 13s_
3750: PPUSH
3751: CALL 70282 0 3
3755: ST_TO_ADDR
// if Gladstone then
3756: LD_EXP 49
3760: IFFALSE 3778
// tmp := tmp ^ Gladstone ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_VAR 0 5
3771: PUSH
3772: LD_EXP 49
3776: ADD
3777: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3778: LD_ADDR_EXP 50
3782: PUSH
3783: LD_STRING Houten
3785: PPUSH
3786: LD_EXP 1
3790: NOT
3791: PPUSH
3792: LD_STRING 13s_
3794: PPUSH
3795: CALL 70282 0 3
3799: ST_TO_ADDR
// if Houten then
3800: LD_EXP 50
3804: IFFALSE 3822
// tmp := tmp ^ Houten ;
3806: LD_ADDR_VAR 0 5
3810: PUSH
3811: LD_VAR 0 5
3815: PUSH
3816: LD_EXP 50
3820: ADD
3821: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3822: LD_ADDR_EXP 51
3826: PUSH
3827: LD_STRING Cornel
3829: PPUSH
3830: LD_EXP 1
3834: NOT
3835: PPUSH
3836: LD_STRING 13s_
3838: PPUSH
3839: CALL 70282 0 3
3843: ST_TO_ADDR
// if Cornel then
3844: LD_EXP 51
3848: IFFALSE 3866
// tmp := tmp ^ Cornel ;
3850: LD_ADDR_VAR 0 5
3854: PUSH
3855: LD_VAR 0 5
3859: PUSH
3860: LD_EXP 51
3864: ADD
3865: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3866: LD_ADDR_EXP 52
3870: PUSH
3871: LD_STRING Gary
3873: PPUSH
3874: LD_EXP 1
3878: NOT
3879: PPUSH
3880: LD_STRING 13s_
3882: PPUSH
3883: CALL 70282 0 3
3887: ST_TO_ADDR
// if Gary then
3888: LD_EXP 52
3892: IFFALSE 3910
// tmp := tmp ^ Gary ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_EXP 52
3908: ADD
3909: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3910: LD_ADDR_EXP 53
3914: PUSH
3915: LD_STRING Frank
3917: PPUSH
3918: LD_EXP 1
3922: NOT
3923: PPUSH
3924: LD_STRING 13s_
3926: PPUSH
3927: CALL 70282 0 3
3931: ST_TO_ADDR
// if Frank then
3932: LD_EXP 53
3936: IFFALSE 3954
// tmp := tmp ^ Frank ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 5
3947: PUSH
3948: LD_EXP 53
3952: ADD
3953: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3954: LD_ADDR_EXP 54
3958: PUSH
3959: LD_STRING Kikuchi
3961: PPUSH
3962: LD_EXP 1
3966: NOT
3967: PPUSH
3968: LD_STRING 13s_
3970: PPUSH
3971: CALL 70282 0 3
3975: ST_TO_ADDR
// if Kikuchi then
3976: LD_EXP 54
3980: IFFALSE 3998
// tmp := tmp ^ Kikuchi ;
3982: LD_ADDR_VAR 0 5
3986: PUSH
3987: LD_VAR 0 5
3991: PUSH
3992: LD_EXP 54
3996: ADD
3997: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3998: LD_ADDR_EXP 58
4002: PUSH
4003: LD_STRING DeltaDoctor
4005: PPUSH
4006: LD_EXP 1
4010: NOT
4011: PPUSH
4012: LD_STRING 13s_
4014: PPUSH
4015: CALL 70282 0 3
4019: ST_TO_ADDR
// if DeltaDoctor then
4020: LD_EXP 58
4024: IFFALSE 4042
// tmp := tmp ^ DeltaDoctor ;
4026: LD_ADDR_VAR 0 5
4030: PUSH
4031: LD_VAR 0 5
4035: PUSH
4036: LD_EXP 58
4040: ADD
4041: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: LD_STRING Mike
4049: PPUSH
4050: LD_EXP 1
4054: NOT
4055: PPUSH
4056: LD_STRING 10c_
4058: PPUSH
4059: CALL 70282 0 3
4063: ST_TO_ADDR
// if Mike then
4064: LD_EXP 57
4068: IFFALSE 4091
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4070: LD_EXP 57
4074: PPUSH
4075: LD_INT 61
4077: PPUSH
4078: LD_INT 89
4080: PPUSH
4081: LD_INT 8
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 50
// vip := tmp ;
4091: LD_ADDR_EXP 62
4095: PUSH
4096: LD_VAR 0 5
4100: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_VAR 0 5
4110: PUSH
4111: LD_STRING 13s_others
4113: PPUSH
4114: CALL_OW 31
4118: UNION
4119: ST_TO_ADDR
// if tmp < 18 then
4120: LD_VAR 0 5
4124: PUSH
4125: LD_INT 18
4127: LESS
4128: IFFALSE 4233
// begin InitHC_All ( ) ;
4130: CALL_OW 584
// for i = 1 to 18 - tmp do
4134: LD_ADDR_VAR 0 2
4138: PUSH
4139: DOUBLE
4140: LD_INT 1
4142: DEC
4143: ST_TO_ADDR
4144: LD_INT 18
4146: PUSH
4147: LD_VAR 0 5
4151: MINUS
4152: PUSH
4153: FOR_TO
4154: IFFALSE 4231
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4156: LD_INT 1
4158: PPUSH
4159: LD_VAR 0 2
4163: PUSH
4164: LD_INT 4
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: PPUSH
4172: LD_INT 4
4174: PPUSH
4175: CALL_OW 380
// un := CreateHuman ;
4179: LD_ADDR_VAR 0 10
4183: PUSH
4184: CALL_OW 44
4188: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4189: LD_ADDR_VAR 0 5
4193: PUSH
4194: LD_VAR 0 5
4198: PPUSH
4199: LD_VAR 0 10
4203: PPUSH
4204: CALL 107973 0 2
4208: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4209: LD_ADDR_EXP 63
4213: PUSH
4214: LD_EXP 63
4218: PPUSH
4219: LD_VAR 0 10
4223: PPUSH
4224: CALL 107973 0 2
4228: ST_TO_ADDR
// end ;
4229: GO 4153
4231: POP
4232: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: LD_INT 53
4240: PPUSH
4241: LD_INT 94
4243: PPUSH
4244: CALL_OW 428
4248: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4249: LD_ADDR_VAR 0 7
4253: PUSH
4254: LD_INT 56
4256: PPUSH
4257: LD_INT 101
4259: PPUSH
4260: CALL_OW 428
4264: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4265: LD_ADDR_VAR 0 8
4269: PUSH
4270: LD_INT 67
4272: PPUSH
4273: LD_INT 101
4275: PPUSH
4276: CALL_OW 428
4280: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4281: LD_ADDR_VAR 0 9
4285: PUSH
4286: LD_INT 54
4288: PPUSH
4289: LD_INT 85
4291: PPUSH
4292: CALL_OW 428
4296: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4297: LD_ADDR_VAR 0 3
4301: PUSH
4302: LD_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PUSH
4312: LD_VAR 0 9
4316: PUSH
4317: LD_VAR 0 7
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: ST_TO_ADDR
// for i in tmp do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: LD_VAR 0 5
4337: PUSH
4338: FOR_IN
4339: IFFALSE 4534
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4341: LD_VAR 0 3
4345: PUSH
4346: LD_INT 1
4348: ARRAY
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 4
4357: DOUBLE
4358: EQUAL
4359: IFTRUE 4363
4361: GO 4378
4363: POP
// SetClass ( i , class_soldier ) ; b_depot :
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 336
4376: GO 4448
4378: LD_INT 0
4380: DOUBLE
4381: EQUAL
4382: IFTRUE 4386
4384: GO 4401
4386: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 336
4399: GO 4448
4401: LD_INT 2
4403: DOUBLE
4404: EQUAL
4405: IFTRUE 4409
4407: GO 4424
4409: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 3
4417: PPUSH
4418: CALL_OW 336
4422: GO 4448
4424: LD_INT 6
4426: DOUBLE
4427: EQUAL
4428: IFTRUE 4432
4430: GO 4447
4432: POP
// SetClass ( i , class_scientistic ) ; end ;
4433: LD_VAR 0 2
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: CALL_OW 336
4445: GO 4448
4447: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 1
4455: ARRAY
4456: PPUSH
4457: CALL_OW 313
4461: PUSH
4462: LD_INT 6
4464: EQUAL
4465: IFFALSE 4485
// b := Delete ( b , 1 ) ;
4467: LD_ADDR_VAR 0 3
4471: PUSH
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 1
4479: PPUSH
4480: CALL_OW 3
4484: ST_TO_ADDR
// if b then
4485: LD_VAR 0 3
4489: IFFALSE 4511
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4491: LD_VAR 0 2
4495: PPUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: CALL_OW 52
4509: GO 4532
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4511: LD_VAR 0 2
4515: PPUSH
4516: LD_INT 61
4518: PPUSH
4519: LD_INT 89
4521: PPUSH
4522: LD_INT 8
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 50
// end ;
4532: GO 4338
4534: POP
4535: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4536: LD_INT 2
4538: PPUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_INT 12
4547: PPUSH
4548: LD_INT 100
4550: PPUSH
4551: CALL 75122 0 5
// veh := CreateVehicle ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: CALL_OW 45
4564: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_INT 4
4572: PPUSH
4573: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 49
4584: PPUSH
4585: LD_INT 88
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4595: LD_VAR 0 4
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 100
4605: PPUSH
4606: CALL_OW 290
// uc_side := 0 ;
4610: LD_ADDR_OWVAR 20
4614: PUSH
4615: LD_INT 0
4617: ST_TO_ADDR
// uc_nation := 0 ;
4618: LD_ADDR_OWVAR 21
4622: PUSH
4623: LD_INT 0
4625: ST_TO_ADDR
// for i := 1 to 3 do
4626: LD_ADDR_VAR 0 2
4630: PUSH
4631: DOUBLE
4632: LD_INT 1
4634: DEC
4635: ST_TO_ADDR
4636: LD_INT 3
4638: PUSH
4639: FOR_TO
4640: IFFALSE 4671
// begin InitHc ;
4642: CALL_OW 19
// hc_class := class_apeman ;
4646: LD_ADDR_OWVAR 28
4650: PUSH
4651: LD_INT 12
4653: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4654: CALL_OW 44
4658: PPUSH
4659: LD_INT 13
4661: PPUSH
4662: LD_INT 0
4664: PPUSH
4665: CALL_OW 49
// end ;
4669: GO 4639
4671: POP
4672: POP
// end ; end_of_file
4673: LD_VAR 0 1
4677: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// side := 8 ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: LD_INT 8
4692: ST_TO_ADDR
// uc_side := side ;
4693: LD_ADDR_OWVAR 20
4697: PUSH
4698: LD_VAR 0 3
4702: ST_TO_ADDR
// uc_nation := 2 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 2
4710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: LD_INT 22
4718: PUSH
4719: LD_VAR 0 3
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 21
4730: PUSH
4731: LD_INT 3
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PPUSH
4742: CALL_OW 69
4746: PUSH
4747: FOR_IN
4748: IFFALSE 4764
// SetBLevel ( i , 10 ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: LD_INT 10
4757: PPUSH
4758: CALL_OW 241
4762: GO 4747
4764: POP
4765: POP
// if KurtStatus then
4766: LD_EXP 3
4770: IFFALSE 4793
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4772: LD_ADDR_EXP 64
4776: PUSH
4777: LD_STRING Kurt
4779: PPUSH
4780: LD_INT 0
4782: PPUSH
4783: LD_STRING 
4785: PPUSH
4786: CALL 70282 0 3
4790: ST_TO_ADDR
4791: GO 4815
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4793: LD_ADDR_EXP 64
4797: PUSH
4798: LD_STRING AltKurt
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 
4809: PPUSH
4810: CALL 70282 0 3
4814: ST_TO_ADDR
// if not Kurt then
4815: LD_EXP 64
4819: NOT
4820: IFFALSE 4846
// begin InitHc ;
4822: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4826: LD_INT 1
4828: PPUSH
4829: LD_INT 10
4831: PPUSH
4832: CALL_OW 381
// Kurt := CreateHuman ;
4836: LD_ADDR_EXP 64
4840: PUSH
4841: CALL_OW 44
4845: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4846: LD_EXP 64
4850: PPUSH
4851: LD_INT 324
4853: PPUSH
4854: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4858: LD_ADDR_EXP 65
4862: PUSH
4863: LD_STRING Kozlov
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: LD_STRING 
4871: PPUSH
4872: CALL 70282 0 3
4876: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4877: LD_EXP 65
4881: PPUSH
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 8
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: PUSH
4922: LD_INT 1
4924: ARRAY
4925: PPUSH
4926: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4930: LD_EXP 65
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 10
4940: PPUSH
4941: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4945: LD_EXP 65
4949: PPUSH
4950: LD_INT 4
4952: PPUSH
4953: LD_INT 10
4955: PPUSH
4956: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4960: LD_ADDR_VAR 0 5
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_VAR 0 3
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 32
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 58
4989: PUSH
4990: EMPTY
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: ST_TO_ADDR
// for i = 1 to 10 do
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: DOUBLE
5009: LD_INT 1
5011: DEC
5012: ST_TO_ADDR
5013: LD_INT 10
5015: PUSH
5016: FOR_TO
5017: IFFALSE 5089
// begin uc_nation := nation_nature ;
5019: LD_ADDR_OWVAR 21
5023: PUSH
5024: LD_INT 0
5026: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5027: LD_ADDR_OWVAR 28
5031: PUSH
5032: LD_INT 15
5034: ST_TO_ADDR
// hc_gallery :=  ;
5035: LD_ADDR_OWVAR 33
5039: PUSH
5040: LD_STRING 
5042: ST_TO_ADDR
// hc_name :=  ;
5043: LD_ADDR_OWVAR 26
5047: PUSH
5048: LD_STRING 
5050: ST_TO_ADDR
// un := CreateHuman ;
5051: LD_ADDR_VAR 0 4
5055: PUSH
5056: CALL_OW 44
5060: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5061: LD_VAR 0 4
5065: PPUSH
5066: LD_VAR 0 5
5070: PUSH
5071: LD_VAR 0 5
5075: PUSH
5076: LD_VAR 0 2
5080: MINUS
5081: ARRAY
5082: PPUSH
5083: CALL_OW 52
// end ;
5087: GO 5016
5089: POP
5090: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5091: LD_ADDR_VAR 0 5
5095: PUSH
5096: LD_STRING 12_kurt_squad
5098: PPUSH
5099: CALL_OW 31
5103: ST_TO_ADDR
// if tmp then
5104: LD_VAR 0 5
5108: IFFALSE 5142
// for i in tmp do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 5
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5140
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5123: LD_VAR 0 2
5127: PPUSH
5128: LD_INT 5
5130: PPUSH
5131: LD_INT 0
5133: PPUSH
5134: CALL_OW 49
5138: GO 5120
5140: POP
5141: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5142: LD_INT 324
5144: PPUSH
5145: LD_INT 5
5147: PPUSH
5148: LD_STRING 
5150: PPUSH
5151: LD_INT 8
5153: PUSH
5154: LD_INT 9
5156: PUSH
5157: LD_INT 10
5159: PUSH
5160: LD_INT 10
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: PUSH
5169: LD_OWVAR 67
5173: ARRAY
5174: PPUSH
5175: LD_INT 3000
5177: PUSH
5178: LD_INT 500
5180: PUSH
5181: LD_INT 150
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_INT 16
5191: PUSH
5192: LD_INT 6
5194: PUSH
5195: LD_INT 6
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL 78943 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5211: LD_ADDR_EXP 102
5215: PUSH
5216: LD_EXP 102
5220: PPUSH
5221: LD_INT 3
5223: PPUSH
5224: LD_INT 22
5226: PUSH
5227: LD_VAR 0 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 23
5238: PUSH
5239: LD_INT 2
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: LD_INT 21
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 69
5272: PUSH
5273: LD_EXP 64
5277: DIFF
5278: PPUSH
5279: CALL_OW 1
5283: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 7
5289: PPUSH
5290: CALL_OW 383
// hc_name := Ali Hadrach ;
5294: LD_ADDR_OWVAR 26
5298: PUSH
5299: LD_STRING Ali Hadrach
5301: ST_TO_ADDR
// hc_gallery := us ;
5302: LD_ADDR_OWVAR 33
5306: PUSH
5307: LD_STRING us
5309: ST_TO_ADDR
// hc_face_number := 31 ;
5310: LD_ADDR_OWVAR 34
5314: PUSH
5315: LD_INT 31
5317: ST_TO_ADDR
// Friend := CreateHuman ;
5318: LD_ADDR_EXP 66
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5328: LD_INT 14
5330: PPUSH
5331: LD_INT 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_INT 29
5339: PPUSH
5340: LD_INT 100
5342: PPUSH
5343: CALL 75122 0 5
// powellBomb := CreateVehicle ;
5347: LD_ADDR_EXP 67
5351: PUSH
5352: CALL_OW 45
5356: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5357: LD_EXP 67
5361: PPUSH
5362: LD_INT 90
5364: PPUSH
5365: LD_INT 51
5367: PPUSH
5368: LD_INT 0
5370: PPUSH
5371: CALL_OW 48
// end ;
5375: LD_VAR 0 1
5379: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
5384: PPUSH
// if IsLive ( kozlov_fac ) then
5385: LD_INT 332
5387: PPUSH
5388: CALL_OW 300
5392: IFFALSE 5396
// exit ;
5394: GO 5963
// ComExitBuilding ( Kozlov ) ;
5396: LD_EXP 65
5400: PPUSH
5401: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5405: LD_EXP 65
5409: PPUSH
5410: CALL_OW 257
5414: PUSH
5415: LD_INT 2
5417: NONEQUAL
5418: IFFALSE 5453
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5420: LD_EXP 65
5424: PPUSH
5425: LD_INT 324
5427: PPUSH
5428: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5432: LD_EXP 65
5436: PPUSH
5437: LD_INT 2
5439: PPUSH
5440: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5444: LD_EXP 65
5448: PPUSH
5449: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5453: LD_EXP 65
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: LD_INT 93
5463: PPUSH
5464: LD_INT 32
5466: PPUSH
5467: LD_INT 3
5469: PPUSH
5470: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5481: LD_INT 22
5483: PUSH
5484: LD_INT 8
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 23
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 57
5513: PUSH
5514: EMPTY
5515: LIST
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: IFFALSE 5474
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5529: LD_ADDR_VAR 0 2
5533: PUSH
5534: LD_INT 22
5536: PUSH
5537: LD_INT 8
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 30
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 23
5556: PUSH
5557: LD_INT 3
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 57
5566: PUSH
5567: EMPTY
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PPUSH
5576: CALL_OW 69
5580: PUSH
5581: LD_INT 1
5583: ARRAY
5584: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5585: LD_INT 22
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: NOT
5625: IFFALSE 5703
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5627: LD_EXP 65
5631: PPUSH
5632: LD_INT 21
5634: PPUSH
5635: LD_INT 97
5637: PPUSH
5638: LD_INT 36
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5648: LD_INT 35
5650: PPUSH
5651: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5655: LD_INT 22
5657: PUSH
5658: LD_INT 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 23
5667: PUSH
5668: LD_INT 3
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 57
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: IFFALSE 5648
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5703: LD_INT 22
5705: PUSH
5706: LD_INT 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 23
5715: PUSH
5716: LD_INT 3
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 18
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 69
5742: NOT
5743: IFFALSE 5821
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5745: LD_EXP 65
5749: PPUSH
5750: LD_INT 18
5752: PPUSH
5753: LD_INT 89
5755: PPUSH
5756: LD_INT 32
5758: PPUSH
5759: LD_INT 1
5761: PPUSH
5762: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5766: LD_INT 35
5768: PPUSH
5769: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5773: LD_INT 22
5775: PUSH
5776: LD_INT 8
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 23
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 30
5795: PUSH
5796: LD_INT 18
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 57
5805: PUSH
5806: EMPTY
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: IFFALSE 5766
// end ; lab := kozlov_lab ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_INT 336
5828: ST_TO_ADDR
// if not lab then
5829: LD_VAR 0 3
5833: NOT
5834: IFFALSE 5838
// exit ;
5836: GO 5963
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5838: LD_EXP 65
5842: PPUSH
5843: LD_VAR 0 3
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5856: LD_EXP 65
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5868: LD_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: LD_INT 25
5879: PPUSH
5880: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5891: LD_INT 25
5893: PPUSH
5894: LD_INT 8
5896: PPUSH
5897: CALL_OW 321
5901: PUSH
5902: LD_INT 2
5904: EQUAL
5905: IFFALSE 5884
// ComExitBuilding ( Kozlov ) ;
5907: LD_EXP 65
5911: PPUSH
5912: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5916: LD_EXP 65
5920: PPUSH
5921: LD_VAR 0 2
5925: PPUSH
5926: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5930: LD_EXP 65
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5942: LD_VAR 0 2
5946: PPUSH
5947: LD_INT 23
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 1
5955: PPUSH
5956: LD_INT 48
5958: PPUSH
5959: CALL_OW 125
// end ;
5963: LD_VAR 0 1
5967: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5968: LD_EXP 22
5972: NOT
5973: PUSH
5974: LD_EXP 15
5978: PUSH
5979: LD_INT 6
5981: GREATEREQUAL
5982: AND
5983: IFFALSE 6064
5985: GO 5987
5987: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 63993 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 14
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 28
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 1
6027: PUSH
6028: LD_INT 28
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 14
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: LD_INT 1
6045: PUSH
6046: LD_INT 28
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL 63856 0 2
// end ;
6064: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6065: LD_EXP 22
6069: NOT
6070: PUSH
6071: LD_EXP 15
6075: PUSH
6076: LD_INT 6
6078: GREATEREQUAL
6079: AND
6080: PUSH
6081: LD_INT 3
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: CALL 65274 0 2
6091: NOT
6092: AND
6093: IFFALSE 7046
6095: GO 6097
6097: DISABLE
6098: LD_INT 0
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin enable ;
6104: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6105: LD_INT 22
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 23
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 30
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL_OW 69
6144: NOT
6145: IFFALSE 6149
// exit ;
6147: GO 7046
// if Prob ( 40 ) then
6149: LD_INT 40
6151: PPUSH
6152: CALL_OW 13
6156: IFFALSE 6283
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 14
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 14
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 14
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 14
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 28
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 14
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 28
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 63856 0 2
// end else
6281: GO 6490
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 14
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 27
6297: PUSH
6298: LD_INT 26
6300: PUSH
6301: LD_INT 26
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_OWVAR 67
6317: ARRAY
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 14
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 27
6336: PUSH
6337: LD_INT 26
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 26
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 14
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: LD_INT 2
6372: PUSH
6373: LD_INT 26
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 29
6381: PUSH
6382: LD_INT 29
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_OWVAR 67
6395: ARRAY
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 13
6405: PUSH
6406: LD_INT 1
6408: PUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 26
6414: PUSH
6415: LD_INT 29
6417: PUSH
6418: LD_INT 29
6420: PUSH
6421: LD_INT 29
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 13
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 29
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 14
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 26
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL 63856 0 2
// end ; wait ( 2 2$00 ) ;
6490: LD_INT 4200
6492: PPUSH
6493: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 8
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 34
6527: PUSH
6528: LD_INT 31
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 34
6544: PUSH
6545: LD_INT 32
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 3
6558: PUSH
6559: LD_INT 34
6561: PUSH
6562: LD_INT 88
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 69
6584: PUSH
6585: LD_EXP 124
6589: PUSH
6590: LD_INT 3
6592: ARRAY
6593: DIFF
6594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6595: LD_ADDR_EXP 121
6599: PUSH
6600: LD_EXP 121
6604: PPUSH
6605: LD_INT 3
6607: PPUSH
6608: LD_EXP 121
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PUSH
6617: LD_VAR 0 2
6621: DIFF
6622: PPUSH
6623: CALL_OW 1
6627: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6628: LD_ADDR_VAR 0 3
6632: PUSH
6633: LD_INT 0
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ST_TO_ADDR
// if target then
6644: LD_VAR 0 3
6648: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 50
6662: PUSH
6663: EMPTY
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: ST_TO_ADDR
// if not tmp then
6671: LD_VAR 0 2
6675: NOT
6676: IFFALSE 6680
// break ;
6678: GO 6804
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 89
6700: PPUSH
6701: LD_INT 71
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 89 , 71 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 89
6721: PPUSH
6722: LD_INT 71
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 109334 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 89
6765: PUSH
6766: LD_INT 71
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6650
// end else
6804: GO 6960
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 50
6818: PUSH
6819: EMPTY
6820: LIST
6821: PPUSH
6822: CALL_OW 72
6826: ST_TO_ADDR
// if not tmp then
6827: LD_VAR 0 2
6831: NOT
6832: IFFALSE 6836
// break ;
6834: GO 6960
// for i in tmp do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: FOR_IN
6847: IFFALSE 6887
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_INT 125
6856: PPUSH
6857: LD_INT 129
6859: PPUSH
6860: CALL_OW 297
6864: PUSH
6865: LD_INT 9
6867: GREATER
6868: IFFALSE 6885
// ComMoveXY ( i , 125 , 129 ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_INT 125
6877: PPUSH
6878: LD_INT 129
6880: PPUSH
6881: CALL_OW 111
6885: GO 6846
6887: POP
6888: POP
// wait ( 0 0$1 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// p := Inc ( p ) ;
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL 109334 0 1
6910: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6911: LD_VAR 0 2
6915: PPUSH
6916: LD_INT 92
6918: PUSH
6919: LD_INT 125
6921: PUSH
6922: LD_INT 129
6924: PUSH
6925: LD_INT 9
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 72
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 1
6946: MINUS
6947: GREATEREQUAL
6948: PUSH
6949: LD_VAR 0 4
6953: PUSH
6954: LD_INT 30
6956: GREATER
6957: OR
6958: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 50
6979: PUSH
6980: EMPTY
6981: LIST
6982: PPUSH
6983: CALL_OW 72
6987: ST_TO_ADDR
// for i in tmp do
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: FOR_IN
6999: IFFALSE 7037
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7001: LD_VAR 0 1
7005: PPUSH
7006: LD_INT 81
7008: PUSH
7009: LD_INT 8
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 1
7025: PPUSH
7026: CALL_OW 74
7030: PPUSH
7031: CALL_OW 115
7035: GO 6998
7037: POP
7038: POP
// until not tmp ;
7039: LD_VAR 0 2
7043: NOT
7044: IFFALSE 6960
// end ;
7046: PPOPN 4
7048: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7049: LD_EXP 22
7053: NOT
7054: PUSH
7055: LD_EXP 15
7059: PUSH
7060: LD_INT 6
7062: GREATEREQUAL
7063: AND
7064: PUSH
7065: LD_OWVAR 67
7069: PUSH
7070: LD_INT 1
7072: GREATER
7073: AND
7074: IFFALSE 7607
7076: GO 7078
7078: DISABLE
7079: LD_INT 0
7081: PPUSH
7082: PPUSH
7083: PPUSH
// begin enable ;
7084: ENABLE
// tmp := [ ] ;
7085: LD_ADDR_VAR 0 3
7089: PUSH
7090: EMPTY
7091: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7092: LD_ADDR_VAR 0 1
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_INT 4
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 7
7110: PUSH
7111: LD_INT 8
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_OWVAR 67
7124: ARRAY
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7287
// begin uc_side := 8 ;
7129: LD_ADDR_OWVAR 20
7133: PUSH
7134: LD_INT 8
7136: ST_TO_ADDR
// uc_nation := 2 ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7145: LD_INT 13
7147: PUSH
7148: LD_INT 14
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_INT 2
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: LD_INT 27
7175: PUSH
7176: LD_INT 28
7178: PUSH
7179: LD_INT 26
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 4
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: PPUSH
7203: LD_INT 88
7205: PPUSH
7206: CALL 75122 0 5
// un := CreateVehicle ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: CALL_OW 45
7219: ST_TO_ADDR
// tmp := tmp ^ un ;
7220: LD_ADDR_VAR 0 3
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: LD_VAR 0 2
7234: ADD
7235: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 30
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 16
7270: PPUSH
7271: LD_INT 11
7273: PPUSH
7274: CALL_OW 111
// wait ( 0 0$2 ) ;
7278: LD_INT 70
7280: PPUSH
7281: CALL_OW 67
// end ;
7285: GO 7126
7287: POP
7288: POP
// for i = 1 to Difficulty do
7289: LD_ADDR_VAR 0 1
7293: PUSH
7294: DOUBLE
7295: LD_INT 1
7297: DEC
7298: ST_TO_ADDR
7299: LD_OWVAR 67
7303: PUSH
7304: FOR_TO
7305: IFFALSE 7434
// begin uc_side := 8 ;
7307: LD_ADDR_OWVAR 20
7311: PUSH
7312: LD_INT 8
7314: ST_TO_ADDR
// uc_nation := 2 ;
7315: LD_ADDR_OWVAR 21
7319: PUSH
7320: LD_INT 2
7322: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7323: LD_INT 0
7325: PPUSH
7326: LD_INT 8
7328: PPUSH
7329: LD_INT 8
7331: PUSH
7332: LD_INT 8
7334: PUSH
7335: LD_INT 9
7337: PUSH
7338: LD_INT 10
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PUSH
7347: LD_OWVAR 67
7351: ARRAY
7352: PPUSH
7353: CALL_OW 380
// un := CreateHuman ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: CALL_OW 44
7366: ST_TO_ADDR
// tmp := tmp ^ un ;
7367: LD_ADDR_VAR 0 3
7371: PUSH
7372: LD_VAR 0 3
7376: PUSH
7377: LD_VAR 0 2
7381: ADD
7382: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_INT 3
7390: PPUSH
7391: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_INT 30
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7410: LD_VAR 0 2
7414: PPUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 11
7420: PPUSH
7421: CALL_OW 111
// wait ( 0 0$2 ) ;
7425: LD_INT 70
7427: PPUSH
7428: CALL_OW 67
// end ;
7432: GO 7304
7434: POP
7435: POP
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// if legionDestroyed then
7443: LD_EXP 22
7447: IFFALSE 7451
// exit ;
7449: GO 7607
// for i in tmp do
7451: LD_ADDR_VAR 0 1
7455: PUSH
7456: LD_VAR 0 3
7460: PUSH
7461: FOR_IN
7462: IFFALSE 7598
// begin if GetLives ( i ) > 250 then
7464: LD_VAR 0 1
7468: PPUSH
7469: CALL_OW 256
7473: PUSH
7474: LD_INT 250
7476: GREATER
7477: IFFALSE 7569
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7479: LD_INT 81
7481: PUSH
7482: LD_INT 8
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 91
7491: PUSH
7492: LD_VAR 0 1
7496: PUSH
7497: LD_INT 10
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PPUSH
7509: CALL_OW 69
7513: NOT
7514: IFFALSE 7533
// ComAgressiveMove ( i , 67 , 110 ) else
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 67
7523: PPUSH
7524: LD_INT 110
7526: PPUSH
7527: CALL_OW 114
7531: GO 7567
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7533: LD_VAR 0 1
7537: PPUSH
7538: LD_INT 81
7540: PUSH
7541: LD_INT 8
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: PPUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 74
7562: PPUSH
7563: CALL_OW 115
// end else
7567: GO 7596
// if IsDead ( i ) then
7569: LD_VAR 0 1
7573: PPUSH
7574: CALL_OW 301
7578: IFFALSE 7596
// tmp := tmp diff i ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: LD_VAR 0 3
7589: PUSH
7590: LD_VAR 0 1
7594: DIFF
7595: ST_TO_ADDR
// end ;
7596: GO 7461
7598: POP
7599: POP
// until not tmp ;
7600: LD_VAR 0 3
7604: NOT
7605: IFFALSE 7436
// end ; end_of_file
7607: PPOPN 3
7609: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
7621: PPUSH
// side := 3 ;
7622: LD_ADDR_VAR 0 6
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// uc_side := side ;
7630: LD_ADDR_OWVAR 20
7634: PUSH
7635: LD_VAR 0 6
7639: ST_TO_ADDR
// uc_nation := 3 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 3
7647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 21
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: PUSH
7684: FOR_IN
7685: IFFALSE 7701
// SetBLevel ( i , 10 ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_INT 10
7694: PPUSH
7695: CALL_OW 241
7699: GO 7684
7701: POP
7702: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7703: LD_ADDR_VAR 0 10
7707: PUSH
7708: LD_INT 22
7710: PUSH
7711: LD_VAR 0 6
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 34
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// if teleport then
7739: LD_VAR 0 10
7743: IFFALSE 7764
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7745: LD_VAR 0 10
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 123
7756: PPUSH
7757: LD_INT 122
7759: PPUSH
7760: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7764: LD_ADDR_EXP 68
7768: PUSH
7769: LD_STRING Platonov
7771: PPUSH
7772: CALL_OW 25
7776: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7777: LD_ADDR_EXP 69
7781: PUSH
7782: LD_STRING Kovalyuk
7784: PPUSH
7785: CALL_OW 25
7789: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7790: LD_ADDR_EXP 71
7794: PUSH
7795: LD_STRING Yakotich
7797: PPUSH
7798: LD_EXP 1
7802: NOT
7803: PPUSH
7804: LD_STRING 09_
7806: PPUSH
7807: CALL 70282 0 3
7811: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7812: LD_ADDR_EXP 70
7816: PUSH
7817: LD_STRING Bystrov
7819: PPUSH
7820: CALL_OW 25
7824: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7825: LD_ADDR_EXP 72
7829: PUSH
7830: LD_STRING Gleb
7832: PPUSH
7833: CALL_OW 25
7837: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7838: LD_STRING 03_Cornel
7840: PPUSH
7841: CALL_OW 28
7845: IFFALSE 7893
// begin Bierezov := NewCharacter ( Mikhail ) ;
7847: LD_ADDR_EXP 73
7851: PUSH
7852: LD_STRING Mikhail
7854: PPUSH
7855: CALL_OW 25
7859: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7860: LD_EXP 73
7864: PPUSH
7865: LD_INT 197
7867: PPUSH
7868: LD_INT 111
7870: PPUSH
7871: LD_INT 9
7873: PPUSH
7874: LD_INT 0
7876: PPUSH
7877: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7881: LD_EXP 73
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7893: LD_EXP 68
7897: PPUSH
7898: LD_INT 126
7900: PPUSH
7901: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7905: LD_EXP 69
7909: PPUSH
7910: LD_INT 134
7912: PPUSH
7913: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7917: LD_EXP 71
7921: PPUSH
7922: LD_INT 197
7924: PPUSH
7925: LD_INT 111
7927: PPUSH
7928: LD_INT 9
7930: PPUSH
7931: LD_INT 0
7933: PPUSH
7934: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7938: LD_EXP 70
7942: PPUSH
7943: LD_INT 197
7945: PPUSH
7946: LD_INT 111
7948: PPUSH
7949: LD_INT 9
7951: PPUSH
7952: LD_INT 0
7954: PPUSH
7955: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7959: LD_EXP 72
7963: PPUSH
7964: LD_INT 197
7966: PPUSH
7967: LD_INT 111
7969: PPUSH
7970: LD_INT 9
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7980: LD_ADDR_VAR 0 5
7984: PUSH
7985: LD_INT 126
7987: PPUSH
7988: LD_INT 4
7990: PPUSH
7991: LD_STRING zhukov
7993: PPUSH
7994: LD_INT 9
7996: PUSH
7997: LD_INT 10
7999: PUSH
8000: LD_INT 10
8002: PUSH
8003: LD_INT 10
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: PUSH
8012: LD_OWVAR 67
8016: ARRAY
8017: PPUSH
8018: LD_INT 90000
8020: PUSH
8021: LD_INT 1000
8023: PUSH
8024: LD_INT 300
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: LD_INT 18
8034: PUSH
8035: LD_INT 8
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 6
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL 78943 0 6
8054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8055: LD_ADDR_EXP 102
8059: PUSH
8060: LD_EXP 102
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_EXP 71
8077: PUSH
8078: LD_EXP 70
8082: PUSH
8083: LD_EXP 72
8087: PUSH
8088: LD_EXP 73
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: UNION
8099: PPUSH
8100: CALL_OW 1
8104: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8105: LD_ADDR_VAR 0 4
8109: PUSH
8110: LD_INT 267
8112: PPUSH
8113: CALL_OW 274
8117: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: LD_INT 5000
8128: PPUSH
8129: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8133: LD_VAR 0 4
8137: PPUSH
8138: LD_INT 2
8140: PPUSH
8141: LD_INT 200
8143: PPUSH
8144: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8148: LD_VAR 0 4
8152: PPUSH
8153: LD_INT 3
8155: PPUSH
8156: LD_INT 200
8158: PPUSH
8159: CALL_OW 277
// for i := 1 to 6 do
8163: LD_ADDR_VAR 0 2
8167: PUSH
8168: DOUBLE
8169: LD_INT 1
8171: DEC
8172: ST_TO_ADDR
8173: LD_INT 6
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8260
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 8
8184: PUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_OWVAR 67
8204: ARRAY
8205: PPUSH
8206: CALL_OW 381
// un := CreateHuman ;
8210: LD_ADDR_VAR 0 8
8214: PUSH
8215: CALL_OW 44
8219: ST_TO_ADDR
// if i mod 2 = 0 then
8220: LD_VAR 0 2
8224: PUSH
8225: LD_INT 2
8227: MOD
8228: PUSH
8229: LD_INT 0
8231: EQUAL
8232: IFFALSE 8246
// SetClass ( un , class_bazooker ) ;
8234: LD_VAR 0 8
8238: PPUSH
8239: LD_INT 9
8241: PPUSH
8242: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8246: LD_VAR 0 8
8250: PPUSH
8251: LD_INT 460
8253: PPUSH
8254: CALL_OW 52
// end ;
8258: GO 8176
8260: POP
8261: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8262: LD_INT 21
8264: PPUSH
8265: LD_INT 3
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: LD_INT 52
8273: PPUSH
8274: LD_INT 100
8276: PPUSH
8277: CALL 75122 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8281: CALL_OW 45
8285: PPUSH
8286: LD_INT 259
8288: PPUSH
8289: LD_INT 145
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 0
8297: PPUSH
8298: CALL 110113 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8302: CALL_OW 45
8306: PPUSH
8307: LD_INT 245
8309: PPUSH
8310: LD_INT 139
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 0
8318: PPUSH
8319: CALL 110113 0 5
// behemoths := [ ] ;
8323: LD_ADDR_EXP 76
8327: PUSH
8328: EMPTY
8329: ST_TO_ADDR
// behemothBuilders := [ ] ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// if Kovalyuk then
8337: LD_EXP 69
8341: IFFALSE 8363
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8343: LD_ADDR_EXP 77
8347: PUSH
8348: LD_EXP 77
8352: PPUSH
8353: LD_EXP 69
8357: PPUSH
8358: CALL 107973 0 2
8362: ST_TO_ADDR
// end ;
8363: LD_VAR 0 1
8367: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8368: LD_INT 0
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 221
8382: PUSH
8383: LD_INT 154
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 223
8392: PUSH
8393: LD_INT 149
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 228
8402: PUSH
8403: LD_INT 147
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 232
8412: PUSH
8413: LD_INT 155
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: ST_TO_ADDR
// if not behemothBuilders then
8426: LD_EXP 77
8430: NOT
8431: IFFALSE 8435
// exit ;
8433: GO 8566
// j := 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// for i in behemothBuilders do
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_EXP 77
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8564
// begin if GetClass ( i ) <> class_mechanic then
8456: LD_VAR 0 2
8460: PPUSH
8461: CALL_OW 257
8465: PUSH
8466: LD_INT 3
8468: NONEQUAL
8469: IFFALSE 8483
// SetClass ( i , class_mechanic ) ;
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: CALL_OW 336
// if IsInUnit ( i ) then
8483: LD_VAR 0 2
8487: PPUSH
8488: CALL_OW 310
8492: IFFALSE 8503
// ComExitBuilding ( i ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 37
8510: PPUSH
8511: LD_VAR 0 4
8515: PUSH
8516: LD_VAR 0 3
8520: ARRAY
8521: PUSH
8522: LD_INT 1
8524: ARRAY
8525: PPUSH
8526: LD_VAR 0 4
8530: PUSH
8531: LD_VAR 0 3
8535: ARRAY
8536: PUSH
8537: LD_INT 2
8539: ARRAY
8540: PPUSH
8541: LD_INT 0
8543: PPUSH
8544: CALL_OW 230
// j := j + 1 ;
8548: LD_ADDR_VAR 0 3
8552: PUSH
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 1
8560: PLUS
8561: ST_TO_ADDR
// end ;
8562: GO 8453
8564: POP
8565: POP
// end ;
8566: LD_VAR 0 1
8570: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8571: LD_INT 24
8573: PPUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 37
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 70
8588: IFFALSE 8601
8590: GO 8592
8592: DISABLE
// behemothUnderConstruct := true ;
8593: LD_ADDR_EXP 26
8597: PUSH
8598: LD_INT 1
8600: ST_TO_ADDR
8601: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8602: LD_INT 3
8604: PPUSH
8605: CALL 108034 0 1
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 30
8622: PUSH
8623: LD_INT 37
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 69
8638: NOT
8639: AND
8640: IFFALSE 8826
8642: GO 8644
8644: DISABLE
8645: LD_INT 0
8647: PPUSH
8648: PPUSH
// begin enable ;
8649: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 3
8657: PPUSH
8658: CALL 108034 0 1
8662: ST_TO_ADDR
// for i in tmp do
8663: LD_ADDR_VAR 0 1
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: FOR_IN
8674: IFFALSE 8824
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8676: LD_VAR 0 1
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: CALL_OW 308
8688: PUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 110
8698: PUSH
8699: LD_INT 2
8701: EQUAL
8702: NOT
8703: AND
8704: IFFALSE 8718
// SetTag ( i , 2 ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: LD_INT 2
8713: PPUSH
8714: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8718: LD_INT 81
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 91
8730: PUSH
8731: LD_VAR 0 1
8735: PUSH
8736: LD_INT 12
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: NOT
8753: PUSH
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 110
8763: PUSH
8764: LD_INT 2
8766: EQUAL
8767: NOT
8768: AND
8769: IFFALSE 8788
// ComAgressiveMove ( i , 64 , 93 ) else
8771: LD_VAR 0 1
8775: PPUSH
8776: LD_INT 64
8778: PPUSH
8779: LD_INT 93
8781: PPUSH
8782: CALL_OW 114
8786: GO 8822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 81
8795: PUSH
8796: LD_INT 3
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PPUSH
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 74
8817: PPUSH
8818: CALL_OW 115
// end ;
8822: GO 8673
8824: POP
8825: POP
// end ;
8826: PPOPN 2
8828: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// result := [ ] ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: EMPTY
8840: ST_TO_ADDR
// uc_side := 6 ;
8841: LD_ADDR_OWVAR 20
8845: PUSH
8846: LD_INT 6
8848: ST_TO_ADDR
// uc_nation := 3 ;
8849: LD_ADDR_OWVAR 21
8853: PUSH
8854: LD_INT 3
8856: ST_TO_ADDR
// case strength of 1 :
8857: LD_VAR 0 1
8861: PUSH
8862: LD_INT 1
8864: DOUBLE
8865: EQUAL
8866: IFTRUE 8870
8868: GO 9012
8870: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: DOUBLE
8877: LD_INT 1
8879: DEC
8880: ST_TO_ADDR
8881: LD_INT 4
8883: PUSH
8884: LD_INT 5
8886: PUSH
8887: LD_INT 6
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_OWVAR 67
8903: ARRAY
8904: PUSH
8905: FOR_TO
8906: IFFALSE 9008
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8908: LD_INT 22
8910: PUSH
8911: LD_INT 24
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 2
8925: MOD
8926: PUSH
8927: LD_INT 1
8929: PLUS
8930: ARRAY
8931: PPUSH
8932: LD_INT 1
8934: PUSH
8935: LD_INT 3
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 2
8947: PPUSH
8948: CALL_OW 12
8952: ARRAY
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: LD_INT 43
8959: PUSH
8960: LD_INT 44
8962: PUSH
8963: LD_INT 45
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 3
8976: PPUSH
8977: CALL_OW 12
8981: ARRAY
8982: PPUSH
8983: LD_INT 80
8985: PPUSH
8986: CALL 75122 0 5
// result := result union CreateVehicle ;
8990: LD_ADDR_VAR 0 2
8994: PUSH
8995: LD_VAR 0 2
8999: PUSH
9000: CALL_OW 45
9004: UNION
9005: ST_TO_ADDR
// end ;
9006: GO 8905
9008: POP
9009: POP
// end ; 2 :
9010: GO 10007
9012: LD_INT 2
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9188
9020: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: DOUBLE
9027: LD_INT 1
9029: DEC
9030: ST_TO_ADDR
9031: LD_INT 5
9033: PUSH
9034: LD_INT 6
9036: PUSH
9037: LD_INT 7
9039: PUSH
9040: LD_INT 8
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: PUSH
9049: LD_OWVAR 67
9053: ARRAY
9054: PUSH
9055: FOR_TO
9056: IFFALSE 9184
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 24
9063: PUSH
9064: LD_INT 24
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: LIST
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: LD_INT 3
9079: MOD
9080: PUSH
9081: LD_INT 1
9083: PLUS
9084: ARRAY
9085: PPUSH
9086: LD_INT 1
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 2
9101: PPUSH
9102: CALL_OW 12
9106: ARRAY
9107: PPUSH
9108: LD_INT 3
9110: PPUSH
9111: LD_INT 43
9113: PUSH
9114: LD_INT 44
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: LD_INT 44
9122: PUSH
9123: LD_INT 46
9125: PUSH
9126: LD_INT 46
9128: PUSH
9129: LD_INT 49
9131: PUSH
9132: LD_INT 49
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_VAR 0 3
9149: PUSH
9150: LD_INT 8
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: LD_INT 80
9161: PPUSH
9162: CALL 75122 0 5
// result := result union CreateVehicle ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: CALL_OW 45
9180: UNION
9181: ST_TO_ADDR
// end ;
9182: GO 9055
9184: POP
9185: POP
// end ; 3 :
9186: GO 10007
9188: LD_INT 3
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9368
9196: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: DOUBLE
9203: LD_INT 1
9205: DEC
9206: ST_TO_ADDR
9207: LD_INT 6
9209: PUSH
9210: LD_INT 7
9212: PUSH
9213: LD_INT 8
9215: PUSH
9216: LD_INT 9
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_OWVAR 67
9229: ARRAY
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9364
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9234: LD_INT 22
9236: PUSH
9237: LD_INT 24
9239: PUSH
9240: LD_INT 24
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 3
9255: MOD
9256: PUSH
9257: LD_INT 1
9259: PLUS
9260: ARRAY
9261: PPUSH
9262: LD_INT 1
9264: PUSH
9265: LD_INT 3
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 2
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 43
9289: PUSH
9290: LD_INT 47
9292: PUSH
9293: LD_INT 45
9295: PUSH
9296: LD_INT 45
9298: PUSH
9299: LD_INT 46
9301: PUSH
9302: LD_INT 46
9304: PUSH
9305: LD_INT 49
9307: PUSH
9308: LD_INT 49
9310: PUSH
9311: LD_INT 49
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: PUSH
9325: LD_VAR 0 3
9329: PUSH
9330: LD_INT 9
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: ARRAY
9338: PPUSH
9339: LD_INT 80
9341: PPUSH
9342: CALL 75122 0 5
// result := result union CreateVehicle ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: CALL_OW 45
9360: UNION
9361: ST_TO_ADDR
// end ;
9362: GO 9231
9364: POP
9365: POP
// end ; 4 :
9366: GO 10007
9368: LD_INT 4
9370: DOUBLE
9371: EQUAL
9372: IFTRUE 9376
9374: GO 10006
9376: POP
// begin uc_nation := 3 ;
9377: LD_ADDR_OWVAR 21
9381: PUSH
9382: LD_INT 3
9384: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9385: LD_ADDR_VAR 0 3
9389: PUSH
9390: DOUBLE
9391: LD_INT 1
9393: DEC
9394: ST_TO_ADDR
9395: LD_INT 6
9397: PUSH
9398: LD_INT 8
9400: PUSH
9401: LD_INT 9
9403: PUSH
9404: LD_INT 10
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PUSH
9419: FOR_TO
9420: IFFALSE 9552
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9422: LD_INT 22
9424: PUSH
9425: LD_INT 24
9427: PUSH
9428: LD_INT 24
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: LD_VAR 0 3
9440: PUSH
9441: LD_INT 3
9443: MOD
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: ARRAY
9449: PPUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 12
9470: ARRAY
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: LD_INT 45
9477: PUSH
9478: LD_INT 47
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: LD_INT 45
9486: PUSH
9487: LD_INT 46
9489: PUSH
9490: LD_INT 46
9492: PUSH
9493: LD_INT 49
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: LD_INT 49
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_VAR 0 3
9517: PUSH
9518: LD_INT 9
9520: MOD
9521: PUSH
9522: LD_INT 1
9524: PLUS
9525: ARRAY
9526: PPUSH
9527: LD_INT 80
9529: PPUSH
9530: CALL 75122 0 5
// result := result union CreateVehicle ;
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: CALL_OW 45
9548: UNION
9549: ST_TO_ADDR
// end ;
9550: GO 9419
9552: POP
9553: POP
// if not KappaStatus then
9554: LD_EXP 2
9558: NOT
9559: IFFALSE 9794
// begin uc_nation := 1 ;
9561: LD_ADDR_OWVAR 21
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// for i = 1 to 3 do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: DOUBLE
9575: LD_INT 1
9577: DEC
9578: ST_TO_ADDR
9579: LD_INT 3
9581: PUSH
9582: FOR_TO
9583: IFFALSE 9719
// begin j := rand ( 0 , 1 ) ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_INT 0
9592: PPUSH
9593: LD_INT 1
9595: PPUSH
9596: CALL_OW 12
9600: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9601: LD_INT 3
9603: PUSH
9604: LD_INT 5
9606: PUSH
9607: LD_INT 5
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: PUSH
9619: LD_VAR 0 4
9623: PUSH
9624: LD_INT 1
9626: PPUSH
9627: LD_INT 3
9629: PPUSH
9630: CALL_OW 12
9634: PLUS
9635: ARRAY
9636: PPUSH
9637: LD_INT 1
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 2
9652: PPUSH
9653: CALL_OW 12
9657: ARRAY
9658: PPUSH
9659: LD_INT 3
9661: PPUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 7
9667: PUSH
9668: LD_INT 6
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: PUSH
9676: LD_VAR 0 4
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: PLUS
9692: ARRAY
9693: PPUSH
9694: LD_INT 85
9696: PPUSH
9697: CALL 75122 0 5
// result := result union CreateVehicle ;
9701: LD_ADDR_VAR 0 2
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: CALL_OW 45
9715: UNION
9716: ST_TO_ADDR
// end ;
9717: GO 9582
9719: POP
9720: POP
// if vsevolodFirstAttack then
9721: LD_EXP 24
9725: IFFALSE 9792
// begin vsevolodFirstAttack := false ;
9727: LD_ADDR_EXP 24
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9735: LD_INT 5
9737: PPUSH
9738: LD_INT 3
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: LD_INT 6
9746: PPUSH
9747: LD_INT 100
9749: PPUSH
9750: CALL 75122 0 5
// sewiVeh := CreateVehicle ;
9754: LD_ADDR_EXP 75
9758: PUSH
9759: CALL_OW 45
9763: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9764: LD_EXP 75
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: CALL_OW 242
// result := result union sewiVeh ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_VAR 0 2
9785: PUSH
9786: LD_EXP 75
9790: UNION
9791: ST_TO_ADDR
// end ; end else
9792: GO 10004
// if vsevolodFirstAttack then
9794: LD_EXP 24
9798: IFFALSE 10004
// begin vsevolodFirstAttack := false ;
9800: LD_ADDR_EXP 24
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// uc_nation := 3 ;
9808: LD_ADDR_OWVAR 21
9812: PUSH
9813: LD_INT 3
9815: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9816: LD_ADDR_VAR 0 3
9820: PUSH
9821: DOUBLE
9822: LD_INT 1
9824: DEC
9825: ST_TO_ADDR
9826: LD_INT 2
9828: PUSH
9829: LD_OWVAR 67
9833: PLUS
9834: PUSH
9835: FOR_TO
9836: IFFALSE 9944
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9838: LD_INT 22
9840: PUSH
9841: LD_INT 24
9843: PUSH
9844: LD_INT 24
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 3
9859: MOD
9860: PUSH
9861: LD_INT 1
9863: PLUS
9864: ARRAY
9865: PPUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 3
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 1
9878: PPUSH
9879: LD_INT 2
9881: PPUSH
9882: CALL_OW 12
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: LD_INT 45
9893: PUSH
9894: LD_INT 47
9896: PUSH
9897: LD_INT 47
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 3
9909: PUSH
9910: LD_INT 3
9912: MOD
9913: PUSH
9914: LD_INT 1
9916: PLUS
9917: ARRAY
9918: PPUSH
9919: LD_INT 80
9921: PPUSH
9922: CALL 75122 0 5
// result := result union CreateVehicle ;
9926: LD_ADDR_VAR 0 2
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: CALL_OW 45
9940: UNION
9941: ST_TO_ADDR
// end ;
9942: GO 9835
9944: POP
9945: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9946: LD_INT 24
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 47
9957: PPUSH
9958: LD_INT 100
9960: PPUSH
9961: CALL 75122 0 5
// sewiVeh := CreateVehicle ;
9965: LD_ADDR_EXP 75
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9975: LD_EXP 75
9979: PPUSH
9980: LD_INT 6
9982: NEG
9983: PPUSH
9984: CALL_OW 242
// result := result union sewiVeh ;
9988: LD_ADDR_VAR 0 2
9992: PUSH
9993: LD_VAR 0 2
9997: PUSH
9998: LD_EXP 75
10002: UNION
10003: ST_TO_ADDR
// end ; end ; end ;
10004: GO 10007
10006: POP
// end ;
10007: LD_VAR 0 2
10011: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10012: LD_EXP 16
10016: IFFALSE 10773
10018: GO 10020
10020: DISABLE
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10029: LD_ADDR_VAR 0 4
10033: PUSH
10034: LD_INT 11
10036: PUSH
10037: LD_INT 12
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_INT 11550
10051: PUSH
10052: LD_INT 10150
10054: PUSH
10055: LD_INT 9800
10057: PUSH
10058: LD_INT 9450
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_OWVAR 67
10071: ARRAY
10072: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10073: LD_ADDR_VAR 0 6
10077: PUSH
10078: LD_INT 70
10080: PUSH
10081: LD_INT 118
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 78
10090: PUSH
10091: LD_INT 31
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: ST_TO_ADDR
// repeat if missionStage = 2 then
10102: LD_EXP 15
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10121
// wait ( 1 1$30 ) else
10112: LD_INT 3150
10114: PPUSH
10115: CALL_OW 67
10119: GO 10130
// wait ( time ) ;
10121: LD_VAR 0 3
10125: PPUSH
10126: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 6
10137: EQUAL
10138: PUSH
10139: LD_OWVAR 67
10143: PUSH
10144: LD_INT 2
10146: GREATER
10147: OR
10148: IFFALSE 10176
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_INT 6
10155: PPUSH
10156: LD_INT 2
10158: PPUSH
10159: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10163: LD_INT 57
10165: PPUSH
10166: LD_INT 6
10168: PPUSH
10169: LD_INT 2
10171: PPUSH
10172: CALL_OW 322
// end ; if missionStage = 8 then
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 8
10183: EQUAL
10184: IFFALSE 10212
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10186: LD_INT 52
10188: PPUSH
10189: LD_INT 6
10191: PPUSH
10192: LD_INT 2
10194: PPUSH
10195: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10199: LD_INT 58
10201: PPUSH
10202: LD_INT 6
10204: PPUSH
10205: LD_INT 2
10207: PPUSH
10208: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10212: LD_OWVAR 67
10216: PUSH
10217: LD_INT 4
10219: EQUAL
10220: PUSH
10221: LD_EXP 15
10225: PUSH
10226: LD_INT 10
10228: EQUAL
10229: OR
10230: IFFALSE 10258
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10232: LD_INT 53
10234: PPUSH
10235: LD_INT 6
10237: PPUSH
10238: LD_INT 2
10240: PPUSH
10241: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10245: LD_INT 59
10247: PPUSH
10248: LD_INT 6
10250: PPUSH
10251: LD_INT 2
10253: PPUSH
10254: CALL_OW 322
// end ; if activeAttacks then
10258: LD_EXP 16
10262: IFFALSE 10767
// begin if missionStage = 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: EQUAL
10272: IFFALSE 10282
// strength := 1 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 1
10281: ST_TO_ADDR
// if missionStage > 2 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 2
10289: GREATER
10290: IFFALSE 10300
// strength := 2 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 2
10299: ST_TO_ADDR
// if missionStage > 6 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 6
10307: GREATER
10308: IFFALSE 10318
// strength := 3 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
// if missionStage > 10 then
10318: LD_EXP 15
10322: PUSH
10323: LD_INT 10
10325: GREATER
10326: IFFALSE 10336
// strength := 4 ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: LD_INT 4
10335: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: PPUSH
10346: CALL 8829 0 1
10350: ST_TO_ADDR
// for i in tmp do
10351: LD_ADDR_VAR 0 1
10355: PUSH
10356: LD_VAR 0 2
10360: PUSH
10361: FOR_IN
10362: IFFALSE 10636
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 4
10373: PUSH
10374: LD_INT 1
10376: PPUSH
10377: LD_INT 2
10379: PPUSH
10380: CALL_OW 12
10384: ARRAY
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// if i = sewiVeh then
10393: LD_VAR 0 1
10397: PUSH
10398: LD_EXP 75
10402: EQUAL
10403: IFFALSE 10456
// begin uc_side := 6 ;
10405: LD_ADDR_OWVAR 20
10409: PUSH
10410: LD_INT 6
10412: ST_TO_ADDR
// uc_nation := nation_russian ;
10413: LD_ADDR_OWVAR 21
10417: PUSH
10418: LD_INT 3
10420: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10421: LD_ADDR_EXP 74
10425: PUSH
10426: LD_STRING Vsevolod
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_STRING 
10434: PPUSH
10435: CALL 70282 0 3
10439: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10440: LD_EXP 74
10444: PPUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 52
// end else
10454: GO 10537
// if GetControl ( i ) = control_manual then
10456: LD_VAR 0 1
10460: PPUSH
10461: CALL_OW 263
10465: PUSH
10466: LD_INT 1
10468: EQUAL
10469: IFFALSE 10537
// begin uc_side := 6 ;
10471: LD_ADDR_OWVAR 20
10475: PUSH
10476: LD_INT 6
10478: ST_TO_ADDR
// uc_nation := 3 ;
10479: LD_ADDR_OWVAR 21
10483: PUSH
10484: LD_INT 3
10486: ST_TO_ADDR
// hc_gallery :=  ;
10487: LD_ADDR_OWVAR 33
10491: PUSH
10492: LD_STRING 
10494: ST_TO_ADDR
// hc_name :=  ;
10495: LD_ADDR_OWVAR 26
10499: PUSH
10500: LD_STRING 
10502: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10503: LD_INT 0
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: LD_INT 10
10511: PPUSH
10512: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10516: CALL_OW 44
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 3
10542: PPUSH
10543: CALL_OW 12
10547: PUSH
10548: LD_INT 1
10550: DOUBLE
10551: EQUAL
10552: IFTRUE 10556
10554: GO 10574
10556: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 111
10564: PPUSH
10565: LD_INT 197
10567: PPUSH
10568: CALL_OW 111
10572: GO 10627
10574: LD_INT 2
10576: DOUBLE
10577: EQUAL
10578: IFTRUE 10582
10580: GO 10600
10582: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 91
10590: PPUSH
10591: LD_INT 165
10593: PPUSH
10594: CALL_OW 111
10598: GO 10627
10600: LD_INT 3
10602: DOUBLE
10603: EQUAL
10604: IFTRUE 10608
10606: GO 10626
10608: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10609: LD_VAR 0 1
10613: PPUSH
10614: LD_INT 137
10616: PPUSH
10617: LD_INT 157
10619: PPUSH
10620: CALL_OW 111
10624: GO 10627
10626: POP
// wait ( 0 0$2 ) ;
10627: LD_INT 70
10629: PPUSH
10630: CALL_OW 67
// end ;
10634: GO 10361
10636: POP
10637: POP
// repeat wait ( 0 0$1 ) ;
10638: LD_INT 35
10640: PPUSH
10641: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10645: LD_ADDR_VAR 0 1
10649: PUSH
10650: LD_VAR 0 2
10654: PPUSH
10655: LD_INT 50
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: PUSH
10666: FOR_IN
10667: IFFALSE 10726
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_INT 108
10676: PUSH
10677: LD_INT 153
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 105
10686: PUSH
10687: LD_INT 149
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 85
10696: PUSH
10697: LD_INT 131
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 64
10706: PUSH
10707: LD_INT 105
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL 110577 0 2
10724: GO 10666
10726: POP
10727: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10728: LD_VAR 0 2
10732: PPUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 34
10738: PUSH
10739: LD_INT 49
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 50
10752: PUSH
10753: EMPTY
10754: LIST
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: NOT
10765: IFFALSE 10638
// end ; until russianDestroyed ;
10767: LD_EXP 21
10771: IFFALSE 10102
// end ;
10773: PPOPN 6
10775: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10776: LD_EXP 21
10780: NOT
10781: PUSH
10782: LD_EXP 15
10786: PUSH
10787: LD_INT 6
10789: GREATEREQUAL
10790: AND
10791: IFFALSE 11828
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
// begin enable ;
10803: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10804: LD_INT 22
10806: PUSH
10807: LD_INT 3
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 3
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PPUSH
10828: CALL_OW 69
10832: NOT
10833: IFFALSE 10837
// exit ;
10835: GO 11828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10837: LD_ADDR_VAR 0 4
10841: PUSH
10842: LD_INT 22
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PUSH
10852: LD_INT 30
10854: PUSH
10855: LD_INT 34
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 69
10870: ST_TO_ADDR
// if Prob ( 40 ) then
10871: LD_INT 40
10873: PPUSH
10874: CALL_OW 13
10878: IFFALSE 11024
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10880: LD_INT 2
10882: PPUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 3
10888: PUSH
10889: LD_INT 3
10891: PUSH
10892: LD_INT 49
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 3
10909: PUSH
10910: LD_INT 49
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 22
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 3
10927: PUSH
10928: LD_INT 49
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 24
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 3
10945: PUSH
10946: LD_INT 46
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 24
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: LD_INT 46
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 24
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 3
10981: PUSH
10982: LD_INT 46
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 24
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 3
10999: PUSH
11000: LD_INT 46
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PPUSH
11018: CALL 63856 0 2
// end else
11022: GO 11166
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11024: LD_INT 2
11026: PPUSH
11027: LD_INT 24
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 47
11038: PUSH
11039: EMPTY
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 24
11047: PUSH
11048: LD_INT 3
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 47
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 3
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 47
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 24
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: LD_INT 46
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 24
11101: PUSH
11102: LD_INT 3
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: LD_INT 46
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 3
11122: PUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 46
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 24
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 46
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL 63856 0 2
// end ; wait ( 2 2$00 ) ;
11166: LD_INT 4200
11168: PPUSH
11169: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 3
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 21
11200: PUSH
11201: LD_INT 2
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: LD_INT 3
11210: PUSH
11211: LD_INT 34
11213: PUSH
11214: LD_INT 48
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: LD_INT 3
11227: PUSH
11228: LD_INT 34
11230: PUSH
11231: LD_INT 51
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 3
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 52
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_EXP 124
11276: PUSH
11277: LD_INT 2
11279: ARRAY
11280: DIFF
11281: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11282: LD_ADDR_EXP 121
11286: PUSH
11287: LD_EXP 121
11291: PPUSH
11292: LD_INT 2
11294: PPUSH
11295: LD_EXP 121
11299: PUSH
11300: LD_INT 2
11302: ARRAY
11303: PUSH
11304: LD_VAR 0 2
11308: DIFF
11309: PPUSH
11310: CALL_OW 1
11314: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 12
11330: ST_TO_ADDR
// p := 0 ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// if target then
11339: LD_VAR 0 3
11343: IFFALSE 11492
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11345: LD_ADDR_VAR 0 2
11349: PUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: LD_INT 50
11357: PUSH
11358: EMPTY
11359: LIST
11360: PPUSH
11361: CALL_OW 72
11365: ST_TO_ADDR
// for i in tmp do
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_VAR 0 2
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11417
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_INT 139
11386: PPUSH
11387: LD_INT 89
11389: PPUSH
11390: CALL_OW 297
11394: PUSH
11395: LD_INT 9
11397: GREATER
11398: IFFALSE 11415
// ComMoveXY ( i , 139 , 89 ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_INT 139
11407: PPUSH
11408: LD_INT 89
11410: PPUSH
11411: CALL_OW 111
11415: GO 11376
11417: POP
11418: POP
// wait ( 0 0$1 ) ;
11419: LD_INT 35
11421: PPUSH
11422: CALL_OW 67
// p := Inc ( p ) ;
11426: LD_ADDR_VAR 0 5
11430: PUSH
11431: LD_VAR 0 5
11435: PPUSH
11436: CALL 109334 0 1
11440: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11441: LD_VAR 0 2
11445: PPUSH
11446: LD_INT 92
11448: PUSH
11449: LD_INT 139
11451: PUSH
11452: LD_INT 89
11454: PUSH
11455: LD_INT 9
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PPUSH
11464: CALL_OW 72
11468: PUSH
11469: LD_VAR 0 2
11473: PUSH
11474: LD_INT 1
11476: MINUS
11477: GREATEREQUAL
11478: PUSH
11479: LD_VAR 0 5
11483: PUSH
11484: LD_INT 60
11486: GREATER
11487: OR
11488: IFFALSE 11345
// end else
11490: GO 11655
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11492: LD_VAR 0 2
11496: PPUSH
11497: LD_VAR 0 4
11501: PUSH
11502: LD_INT 1
11504: ARRAY
11505: PPUSH
11506: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_VAR 0 2
11519: PPUSH
11520: LD_INT 50
11522: PUSH
11523: EMPTY
11524: LIST
11525: PPUSH
11526: CALL_OW 72
11530: ST_TO_ADDR
// for i in tmp do
11531: LD_ADDR_VAR 0 1
11535: PUSH
11536: LD_VAR 0 2
11540: PUSH
11541: FOR_IN
11542: IFFALSE 11582
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_INT 124
11551: PPUSH
11552: LD_INT 139
11554: PPUSH
11555: CALL_OW 297
11559: PUSH
11560: LD_INT 9
11562: GREATER
11563: IFFALSE 11580
// ComMoveXY ( i , 124 , 139 ) ;
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 124
11572: PPUSH
11573: LD_INT 139
11575: PPUSH
11576: CALL_OW 111
11580: GO 11541
11582: POP
11583: POP
// wait ( 0 0$1 ) ;
11584: LD_INT 35
11586: PPUSH
11587: CALL_OW 67
// p := Inc ( p ) ;
11591: LD_ADDR_VAR 0 5
11595: PUSH
11596: LD_VAR 0 5
11600: PPUSH
11601: CALL 109334 0 1
11605: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 92
11613: PUSH
11614: LD_INT 124
11616: PUSH
11617: LD_INT 139
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PPUSH
11629: CALL_OW 72
11633: PUSH
11634: LD_VAR 0 2
11638: PUSH
11639: LD_INT 1
11641: MINUS
11642: GREATEREQUAL
11643: PUSH
11644: LD_VAR 0 5
11648: PUSH
11649: LD_INT 60
11651: GREATER
11652: OR
11653: IFFALSE 11510
// end ; repeat wait ( 0 0$1 ) ;
11655: LD_INT 35
11657: PPUSH
11658: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11662: LD_ADDR_VAR 0 2
11666: PUSH
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_INT 50
11674: PUSH
11675: EMPTY
11676: LIST
11677: PPUSH
11678: CALL_OW 72
11682: ST_TO_ADDR
// for i in tmp do
11683: LD_ADDR_VAR 0 1
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: FOR_IN
11694: IFFALSE 11819
// begin if GetWeapon ( i ) = ru_time_lapser then
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL_OW 264
11705: PUSH
11706: LD_INT 49
11708: EQUAL
11709: IFFALSE 11765
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11711: LD_VAR 0 1
11715: PPUSH
11716: LD_INT 2
11718: PUSH
11719: LD_INT 22
11721: PUSH
11722: LD_INT 1
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: PUSH
11729: LD_INT 22
11731: PUSH
11732: LD_INT 8
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: PPUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 74
11758: PPUSH
11759: CALL_OW 112
11763: GO 11817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11765: LD_VAR 0 1
11769: PPUSH
11770: LD_INT 2
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 22
11785: PUSH
11786: LD_INT 8
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 69
11802: PPUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 74
11812: PPUSH
11813: CALL_OW 115
// end ;
11817: GO 11693
11819: POP
11820: POP
// until not tmp ;
11821: LD_VAR 0 2
11825: NOT
11826: IFFALSE 11655
// end ;
11828: PPOPN 5
11830: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11831: LD_EXP 15
11835: PUSH
11836: LD_INT 7
11838: GREATEREQUAL
11839: PUSH
11840: LD_OWVAR 67
11844: PUSH
11845: LD_INT 1
11847: GREATER
11848: AND
11849: IFFALSE 12141
11851: GO 11853
11853: DISABLE
11854: LD_INT 0
11856: PPUSH
11857: PPUSH
11858: PPUSH
// begin ruMobile := [ ] ;
11859: LD_ADDR_EXP 78
11863: PUSH
11864: EMPTY
11865: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 4
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 6
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_OWVAR 67
11894: PUSH
11895: LD_INT 1
11897: MINUS
11898: ARRAY
11899: PUSH
11900: FOR_TO
11901: IFFALSE 12139
// begin uc_side := 3 ;
11903: LD_ADDR_OWVAR 20
11907: PUSH
11908: LD_INT 3
11910: ST_TO_ADDR
// uc_nation := 1 ;
11911: LD_ADDR_OWVAR 21
11915: PUSH
11916: LD_INT 1
11918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11919: LD_INT 5
11921: PPUSH
11922: LD_INT 3
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 9
11930: PUSH
11931: LD_INT 7
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 2
11945: MOD
11946: PUSH
11947: LD_INT 1
11949: PLUS
11950: ARRAY
11951: PPUSH
11952: LD_INT 100
11954: PPUSH
11955: CALL 75122 0 5
// veh := CreateVehicle ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: CALL_OW 45
11968: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 3
11976: PPUSH
11977: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11981: LD_VAR 0 2
11985: PPUSH
11986: LD_INT 29
11988: PPUSH
11989: LD_INT 0
11991: PPUSH
11992: CALL_OW 49
// uc_nation := 3 ;
11996: LD_ADDR_OWVAR 21
12000: PUSH
12001: LD_INT 3
12003: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12004: LD_INT 0
12006: PPUSH
12007: LD_INT 10
12009: PPUSH
12010: CALL_OW 383
// un := CreateHuman ;
12014: LD_ADDR_VAR 0 3
12018: PUSH
12019: CALL_OW 44
12023: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_INT 105
12031: PPUSH
12032: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12036: LD_VAR 0 3
12040: PPUSH
12041: LD_INT 3
12043: PPUSH
12044: CALL_OW 259
12048: PUSH
12049: LD_INT 8
12051: PUSH
12052: LD_INT 9
12054: PUSH
12055: LD_INT 10
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: LESS
12069: IFFALSE 12103
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_INT 3
12078: PPUSH
12079: LD_INT 8
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: LD_INT 10
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PUSH
12093: LD_OWVAR 67
12097: ARRAY
12098: PPUSH
12099: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12103: LD_VAR 0 3
12107: PPUSH
12108: LD_VAR 0 2
12112: PPUSH
12113: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12117: LD_ADDR_EXP 78
12121: PUSH
12122: LD_EXP 78
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 107973 0 2
12136: ST_TO_ADDR
// end ;
12137: GO 11900
12139: POP
12140: POP
// end ;
12141: PPOPN 3
12143: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12144: LD_EXP 78
12148: IFFALSE 12657
12150: GO 12152
12152: DISABLE
12153: LD_INT 0
12155: PPUSH
12156: PPUSH
12157: PPUSH
// begin enable ;
12158: ENABLE
// if not ruMobile then
12159: LD_EXP 78
12163: NOT
12164: IFFALSE 12169
// begin disable ;
12166: DISABLE
// exit ;
12167: GO 12657
// end ; for i in ruMobile do
12169: LD_ADDR_VAR 0 1
12173: PUSH
12174: LD_EXP 78
12178: PUSH
12179: FOR_IN
12180: IFFALSE 12655
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL_OW 302
12191: NOT
12192: PUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 255
12202: PUSH
12203: LD_INT 3
12205: NONEQUAL
12206: OR
12207: IFFALSE 12227
// begin ruMobile := ruMobile diff i ;
12209: LD_ADDR_EXP 78
12213: PUSH
12214: LD_EXP 78
12218: PUSH
12219: LD_VAR 0 1
12223: DIFF
12224: ST_TO_ADDR
// continue ;
12225: GO 12179
// end ; if GetTag ( i ) = 300 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 110
12236: PUSH
12237: LD_INT 300
12239: EQUAL
12240: IFFALSE 12290
// begin ComMoveXY ( i , 160 , 81 ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: LD_INT 160
12249: PPUSH
12250: LD_INT 81
12252: PPUSH
12253: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 160
12264: PPUSH
12265: LD_INT 81
12267: PPUSH
12268: CALL_OW 297
12272: PUSH
12273: LD_INT 8
12275: LESS
12276: IFFALSE 12290
// SetTag ( i , 301 ) ;
12278: LD_VAR 0 1
12282: PPUSH
12283: LD_INT 301
12285: PPUSH
12286: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12290: LD_VAR 0 1
12294: PPUSH
12295: CALL_OW 110
12299: PUSH
12300: LD_INT 301
12302: EQUAL
12303: IFFALSE 12346
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_INT 33
12312: PPUSH
12313: CALL_OW 308
12317: NOT
12318: IFFALSE 12334
// ComMoveToArea ( i , ruMobileParkingArea ) else
12320: LD_VAR 0 1
12324: PPUSH
12325: LD_INT 33
12327: PPUSH
12328: CALL_OW 113
12332: GO 12346
// SetTag ( i , 302 ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: LD_INT 302
12341: PPUSH
12342: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 110
12355: PUSH
12356: LD_INT 302
12358: EQUAL
12359: IFFALSE 12489
// begin if GetLives ( i ) < 1000 then
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 256
12370: PUSH
12371: LD_INT 1000
12373: LESS
12374: IFFALSE 12466
// begin if not IsDrivenBy ( i ) then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 311
12385: NOT
12386: IFFALSE 12390
// continue ;
12388: GO 12179
// mech := IsDrivenBy ( i ) ;
12390: LD_ADDR_VAR 0 2
12394: PUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 311
12404: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12428: LD_INT 35
12430: PPUSH
12431: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 256
12444: PUSH
12445: LD_INT 1000
12447: EQUAL
12448: IFFALSE 12428
// ComEnterUnit ( mech , i ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 120
// end else
12464: GO 12489
// if IsDrivenBy ( i ) then
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 311
12475: IFFALSE 12489
// SetTag ( i , 0 ) ;
12477: LD_VAR 0 1
12481: PPUSH
12482: LD_INT 0
12484: PPUSH
12485: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 110
12498: PUSH
12499: LD_INT 300
12501: LESS
12502: IFFALSE 12653
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_INT 81
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 256
12536: PUSH
12537: LD_INT 650
12539: LESS
12540: IFFALSE 12565
// begin ComStop ( i ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 141
// SetTag ( i , 300 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 300
12558: PPUSH
12559: CALL_OW 109
// continue ;
12563: GO 12179
// end ; if enemy then
12565: LD_VAR 0 3
12569: IFFALSE 12609
// begin if not HasTask ( i ) then
12571: LD_VAR 0 1
12575: PPUSH
12576: CALL_OW 314
12580: NOT
12581: IFFALSE 12607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12583: LD_VAR 0 1
12587: PPUSH
12588: LD_VAR 0 3
12592: PPUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 74
12602: PPUSH
12603: CALL_OW 115
// end else
12607: GO 12653
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12609: LD_VAR 0 1
12613: PPUSH
12614: LD_INT 158
12616: PUSH
12617: LD_INT 61
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 98
12626: PUSH
12627: LD_INT 100
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 78
12636: PUSH
12637: LD_INT 93
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL 110577 0 2
// end ; end ;
12653: GO 12179
12655: POP
12656: POP
// end ; end_of_file
12657: PPOPN 3
12659: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12660: LD_INT 0
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
12667: PPUSH
12668: PPUSH
// if Difficulty = 1 then
12669: LD_OWVAR 67
12673: PUSH
12674: LD_INT 1
12676: EQUAL
12677: IFFALSE 12715
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_INT 95
12686: PUSH
12687: LD_INT 34
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: PUSH
12699: FOR_IN
12700: IFFALSE 12713
// RemoveUnit ( i ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 64
12711: GO 12699
12713: POP
12714: POP
// SetInvulnrability ( alien , true ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 607
// side := 7 ;
12725: LD_ADDR_VAR 0 5
12729: PUSH
12730: LD_INT 7
12732: ST_TO_ADDR
// uc_side := side ;
12733: LD_ADDR_OWVAR 20
12737: PUSH
12738: LD_VAR 0 5
12742: ST_TO_ADDR
// uc_nation := 1 ;
12743: LD_ADDR_OWVAR 21
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12751: LD_ADDR_VAR 0 2
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 21
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: FOR_IN
12788: IFFALSE 12804
// SetBLevel ( i , 10 ) ;
12790: LD_VAR 0 2
12794: PPUSH
12795: LD_INT 10
12797: PPUSH
12798: CALL_OW 241
12802: GO 12787
12804: POP
12805: POP
// base := GetBase ( al_depot ) ;
12806: LD_ADDR_VAR 0 4
12810: PUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 274
12818: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 6
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_VAR 0 5
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 30
12838: PUSH
12839: LD_INT 34
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: ST_TO_ADDR
// if teleport then
12855: LD_VAR 0 6
12859: IFFALSE 12880
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12861: LD_VAR 0 6
12865: PUSH
12866: LD_INT 1
12868: ARRAY
12869: PPUSH
12870: LD_INT 262
12872: PPUSH
12873: LD_INT 119
12875: PPUSH
12876: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12880: LD_VAR 0 4
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 19500
12890: PPUSH
12891: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12895: LD_VAR 0 4
12899: PPUSH
12900: LD_INT 2
12902: PPUSH
12903: LD_INT 200
12905: PPUSH
12906: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12910: LD_VAR 0 4
12914: PPUSH
12915: LD_INT 3
12917: PPUSH
12918: LD_INT 650
12920: PPUSH
12921: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12925: LD_ADDR_EXP 79
12929: PUSH
12930: LD_STRING Roth
12932: PPUSH
12933: CALL_OW 25
12937: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12938: LD_ADDR_EXP 80
12942: PUSH
12943: LD_STRING Simms
12945: PPUSH
12946: LD_EXP 1
12950: NOT
12951: PPUSH
12952: LD_STRING 10c_
12954: PPUSH
12955: CALL 70282 0 3
12959: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12960: LD_EXP 80
12964: PPUSH
12965: LD_INT 4
12967: PPUSH
12968: CALL_OW 336
// if not Simms then
12972: LD_EXP 80
12976: NOT
12977: IFFALSE 13007
// begin uc_nation := 1 ;
12979: LD_ADDR_OWVAR 21
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12987: LD_INT 2
12989: PPUSH
12990: LD_INT 10
12992: PPUSH
12993: CALL_OW 384
// Simms := CreateHuman ;
12997: LD_ADDR_EXP 80
13001: PUSH
13002: CALL_OW 44
13006: ST_TO_ADDR
// end ; uc_nation := 3 ;
13007: LD_ADDR_OWVAR 21
13011: PUSH
13012: LD_INT 3
13014: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13015: LD_ADDR_EXP 81
13019: PUSH
13020: LD_STRING Kirilenkova
13022: PPUSH
13023: CALL_OW 25
13027: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13028: LD_ADDR_EXP 95
13032: PUSH
13033: LD_STRING Oblukov
13035: PPUSH
13036: CALL_OW 25
13040: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13041: LD_ADDR_EXP 82
13045: PUSH
13046: LD_STRING Dolgov
13048: PPUSH
13049: CALL_OW 25
13053: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13054: LD_ADDR_EXP 83
13058: PUSH
13059: LD_STRING Petrosyan
13061: PPUSH
13062: CALL_OW 25
13066: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_STRING Scholtze
13074: PPUSH
13075: CALL_OW 25
13079: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13080: LD_ADDR_EXP 93
13084: PUSH
13085: LD_STRING Kapitsova
13087: PPUSH
13088: CALL_OW 25
13092: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13093: LD_ADDR_EXP 84
13097: PUSH
13098: LD_STRING Petrovova
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13106: LD_ADDR_EXP 85
13110: PUSH
13111: LD_STRING Kuzmov
13113: PPUSH
13114: CALL_OW 25
13118: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13119: LD_ADDR_EXP 92
13123: PUSH
13124: LD_STRING Karamazov
13126: PPUSH
13127: CALL_OW 25
13131: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13132: LD_STRING 13_Lipshchin_1
13134: PPUSH
13135: LD_INT 0
13137: PPUSH
13138: CALL_OW 30
13142: IFFALSE 13157
// Lipshchin := NewCharacter ( Lipshchin ) ;
13144: LD_ADDR_EXP 86
13148: PUSH
13149: LD_STRING Lipshchin
13151: PPUSH
13152: CALL_OW 25
13156: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13157: LD_STRING 13_Titov_1
13159: PPUSH
13160: LD_INT 0
13162: PPUSH
13163: CALL_OW 30
13167: IFFALSE 13182
// Titov := NewCharacter ( Titov ) ;
13169: LD_ADDR_EXP 88
13173: PUSH
13174: LD_STRING Titov
13176: PPUSH
13177: CALL_OW 25
13181: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13182: LD_STRING 13_Gnyevko_1
13184: PPUSH
13185: LD_INT 0
13187: PPUSH
13188: CALL_OW 30
13192: IFFALSE 13207
// Gnyevko := NewCharacter ( Gnyevko ) ;
13194: LD_ADDR_EXP 87
13198: PUSH
13199: LD_STRING Gnyevko
13201: PPUSH
13202: CALL_OW 25
13206: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13207: LD_STRING 13_Xavier_1
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 30
13217: IFFALSE 13232
// Xavier := NewCharacter ( Xavier2 ) ;
13219: LD_ADDR_EXP 89
13223: PUSH
13224: LD_STRING Xavier2
13226: PPUSH
13227: CALL_OW 25
13231: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13232: LD_STRING 13_Belkov_1
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 30
13242: IFFALSE 13257
// Belkov := NewCharacter ( Belkov ) ;
13244: LD_ADDR_EXP 90
13248: PUSH
13249: LD_STRING Belkov
13251: PPUSH
13252: CALL_OW 25
13256: ST_TO_ADDR
// if not BurlakStatus then
13257: LD_EXP 9
13261: NOT
13262: IFFALSE 13277
// Burlak = NewCharacter ( Burlak ) ;
13264: LD_ADDR_EXP 91
13268: PUSH
13269: LD_STRING Burlak
13271: PPUSH
13272: CALL_OW 25
13276: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_EXP 79
13286: PUSH
13287: LD_EXP 81
13291: PUSH
13292: LD_EXP 95
13296: PUSH
13297: LD_EXP 82
13301: PUSH
13302: LD_EXP 83
13306: PUSH
13307: LD_EXP 94
13311: PUSH
13312: LD_EXP 93
13316: PUSH
13317: LD_EXP 84
13321: PUSH
13322: LD_EXP 85
13326: PUSH
13327: LD_EXP 92
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: ST_TO_ADDR
// if Simms then
13344: LD_EXP 80
13348: IFFALSE 13366
// tmp := tmp ^ Simms ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: LD_VAR 0 3
13359: PUSH
13360: LD_EXP 80
13364: ADD
13365: ST_TO_ADDR
// if Titov then
13366: LD_EXP 88
13370: IFFALSE 13388
// tmp := tmp ^ Titov ;
13372: LD_ADDR_VAR 0 3
13376: PUSH
13377: LD_VAR 0 3
13381: PUSH
13382: LD_EXP 88
13386: ADD
13387: ST_TO_ADDR
// if Lipshchin then
13388: LD_EXP 86
13392: IFFALSE 13410
// tmp := tmp ^ Lipshchin ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_VAR 0 3
13403: PUSH
13404: LD_EXP 86
13408: ADD
13409: ST_TO_ADDR
// if Gnyevko then
13410: LD_EXP 87
13414: IFFALSE 13432
// tmp := tmp ^ Gnyevko ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_VAR 0 3
13425: PUSH
13426: LD_EXP 87
13430: ADD
13431: ST_TO_ADDR
// if Xavier then
13432: LD_EXP 89
13436: IFFALSE 13454
// tmp := tmp ^ Xavier ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: LD_VAR 0 3
13447: PUSH
13448: LD_EXP 89
13452: ADD
13453: ST_TO_ADDR
// if Belkov then
13454: LD_EXP 90
13458: IFFALSE 13476
// tmp := tmp ^ Belkov ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_EXP 90
13474: ADD
13475: ST_TO_ADDR
// if Burlak then
13476: LD_EXP 91
13480: IFFALSE 13498
// tmp := tmp ^ Burlak ;
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_EXP 91
13496: ADD
13497: ST_TO_ADDR
// for i = 1 to 11 do
13498: LD_ADDR_VAR 0 2
13502: PUSH
13503: DOUBLE
13504: LD_INT 1
13506: DEC
13507: ST_TO_ADDR
13508: LD_INT 11
13510: PUSH
13511: FOR_TO
13512: IFFALSE 13580
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13514: LD_ADDR_OWVAR 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 1
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: CALL_OW 12
13539: ARRAY
13540: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13541: LD_INT 0
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: LD_INT 4
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: LD_INT 10
13557: PPUSH
13558: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13562: LD_ADDR_VAR 0 3
13566: PUSH
13567: LD_VAR 0 3
13571: PUSH
13572: CALL_OW 44
13576: ADD
13577: ST_TO_ADDR
// end ;
13578: GO 13511
13580: POP
13581: POP
// for i in tmp do
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 3
13591: PUSH
13592: FOR_IN
13593: IFFALSE 13618
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13595: LD_VAR 0 2
13599: PPUSH
13600: LD_INT 260
13602: PPUSH
13603: LD_INT 235
13605: PPUSH
13606: LD_INT 8
13608: PPUSH
13609: LD_INT 0
13611: PPUSH
13612: CALL_OW 50
13616: GO 13592
13618: POP
13619: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13620: LD_ADDR_EXP 102
13624: PUSH
13625: LD_EXP 102
13629: PPUSH
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 22
13635: PUSH
13636: LD_VAR 0 5
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: LD_INT 21
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PUSH
13671: LD_EXP 79
13675: PUSH
13676: LD_EXP 80
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: DIFF
13685: PPUSH
13686: CALL_OW 1
13690: ST_TO_ADDR
// uc_side := 0 ;
13691: LD_ADDR_OWVAR 20
13695: PUSH
13696: LD_INT 0
13698: ST_TO_ADDR
// uc_nation := 0 ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_INT 0
13706: ST_TO_ADDR
// for i = 1 to 5 do
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_INT 5
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13758
// begin InitHc ;
13723: CALL_OW 19
// hc_class := class_apeman ;
13727: LD_ADDR_OWVAR 28
13731: PUSH
13732: LD_INT 12
13734: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13735: CALL_OW 44
13739: PPUSH
13740: LD_INT 299
13742: PPUSH
13743: LD_INT 229
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: LD_INT 0
13751: PPUSH
13752: CALL_OW 50
// end ;
13756: GO 13720
13758: POP
13759: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13760: LD_EXP 79
13764: PPUSH
13765: LD_INT 259
13767: PPUSH
13768: LD_INT 235
13770: PPUSH
13771: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13775: LD_EXP 79
13779: PPUSH
13780: LD_INT 262
13782: PPUSH
13783: LD_INT 235
13785: PPUSH
13786: CALL_OW 178
// if Simms then
13790: LD_EXP 80
13794: IFFALSE 13825
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13796: LD_EXP 80
13800: PPUSH
13801: LD_INT 262
13803: PPUSH
13804: LD_INT 235
13806: PPUSH
13807: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13811: LD_EXP 80
13815: PPUSH
13816: LD_EXP 79
13820: PPUSH
13821: CALL_OW 179
// end ; uc_side := 7 ;
13825: LD_ADDR_OWVAR 20
13829: PUSH
13830: LD_INT 7
13832: ST_TO_ADDR
// uc_nation := 1 ;
13833: LD_ADDR_OWVAR 21
13837: PUSH
13838: LD_INT 1
13840: ST_TO_ADDR
// bc_type := b_control_tower ;
13841: LD_ADDR_OWVAR 42
13845: PUSH
13846: LD_INT 36
13848: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13849: LD_ADDR_VAR 0 7
13853: PUSH
13854: LD_INT 268
13856: PPUSH
13857: LD_INT 251
13859: PPUSH
13860: LD_INT 4
13862: PPUSH
13863: CALL_OW 47
13867: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13868: LD_INT 0
13870: PPUSH
13871: LD_INT 10
13873: PPUSH
13874: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13878: CALL_OW 44
13882: PPUSH
13883: LD_VAR 0 7
13887: PPUSH
13888: CALL_OW 52
// end ;
13892: LD_VAR 0 1
13896: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13897: LD_EXP 31
13901: PUSH
13902: LD_EXP 23
13906: NOT
13907: AND
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 7
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 8
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: AND
13938: IFFALSE 14166
13940: GO 13942
13942: DISABLE
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
// begin enable ;
13948: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_INT 81
13956: PUSH
13957: LD_INT 7
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 2
13966: PUSH
13967: LD_INT 32
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 30
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: LD_INT 34
13999: PUSH
14000: LD_INT 49
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 34
14009: PUSH
14010: LD_INT 10
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 34
14019: PUSH
14020: LD_INT 8
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: ST_TO_ADDR
// if not tmp then
14045: LD_VAR 0 2
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14166
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_INT 34
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PPUSH
14069: CALL_OW 72
14073: IFFALSE 14106
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 8
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PPUSH
14095: CALL_OW 72
14099: PUSH
14100: LD_INT 1
14102: ARRAY
14103: ST_TO_ADDR
14104: GO 14130
// target := tmp [ rand ( 1 , tmp ) ] ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_VAR 0 2
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 2
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14130: LD_VAR 0 3
14134: PPUSH
14135: CALL_OW 255
14139: PUSH
14140: LD_INT 1
14142: EQUAL
14143: IFFALSE 14154
// CenterNowOnUnits ( target ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 87
// SetLives ( target , 0 ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 0
14161: PPUSH
14162: CALL_OW 234
// end ;
14166: PPOPN 3
14168: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14169: LD_EXP 23
14173: NOT
14174: PUSH
14175: LD_EXP 31
14179: AND
14180: IFFALSE 14696
14182: GO 14184
14184: DISABLE
14185: LD_INT 0
14187: PPUSH
14188: PPUSH
14189: PPUSH
// begin uc_side := 7 ;
14190: LD_ADDR_OWVAR 20
14194: PUSH
14195: LD_INT 7
14197: ST_TO_ADDR
// uc_nation := 1 ;
14198: LD_ADDR_OWVAR 21
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14206: LD_ADDR_VAR 0 3
14210: PUSH
14211: LD_INT 125
14213: PUSH
14214: LD_INT 163
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: LD_INT 185
14223: PUSH
14224: LD_INT 168
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 111
14233: PUSH
14234: LD_INT 97
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 94
14243: PUSH
14244: LD_INT 114
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL 108078 0 1
14261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14262: LD_ADDR_EXP 96
14266: PUSH
14267: EMPTY
14268: ST_TO_ADDR
// for i = 1 to Difficulty do
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_OWVAR 67
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14443
// begin InitHc ;
14287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14291: LD_INT 0
14293: PPUSH
14294: LD_INT 8
14296: PPUSH
14297: CALL_OW 381
// un := CreateHuman ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: CALL_OW 44
14310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 258
14318: PPUSH
14319: LD_INT 267
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: LD_INT 0
14327: PPUSH
14328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14332: LD_ADDR_EXP 96
14336: PUSH
14337: LD_EXP 96
14341: PUSH
14342: LD_VAR 0 2
14346: UNION
14347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14348: LD_VAR 0 2
14352: PPUSH
14353: LD_VAR 0 3
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PUSH
14364: LD_INT 1
14366: ARRAY
14367: PPUSH
14368: LD_VAR 0 3
14372: PUSH
14373: LD_VAR 0 1
14377: ARRAY
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: LD_INT 4
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 3
14402: PUSH
14403: LD_VAR 0 1
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_VAR 0 3
14417: PUSH
14418: LD_VAR 0 1
14422: ARRAY
14423: PUSH
14424: LD_INT 2
14426: ARRAY
14427: PPUSH
14428: CALL_OW 171
// AddComInvisible ( un ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: CALL_OW 212
// end ;
14441: GO 14284
14443: POP
14444: POP
// repeat wait ( 0 0$45 ) ;
14445: LD_INT 1575
14447: PPUSH
14448: CALL_OW 67
// for i in allianceSpecialForce do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_EXP 96
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14681
// begin if IsInvisible ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 571
14474: IFFALSE 14650
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: EMPTY
14495: LIST
14496: PUSH
14497: LD_INT 56
14499: PUSH
14500: EMPTY
14501: LIST
14502: PUSH
14503: LD_INT 91
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: LD_INT 25
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: LD_INT 25
14534: PUSH
14535: LD_INT 2
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 25
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: LD_INT 25
14554: PUSH
14555: LD_INT 4
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 5
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: LD_INT 8
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 69
14602: ST_TO_ADDR
// if not tmp then
14603: LD_VAR 0 3
14607: NOT
14608: IFFALSE 14612
// continue ;
14610: GO 14462
// if Prob ( 30 * Difficulty ) then
14612: LD_INT 30
14614: PUSH
14615: LD_OWVAR 67
14619: MUL
14620: PPUSH
14621: CALL_OW 13
14625: IFFALSE 14650
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 1
14634: PPUSH
14635: LD_VAR 0 3
14639: PPUSH
14640: CALL_OW 12
14644: ARRAY
14645: PPUSH
14646: CALL 35372 0 1
// end ; if IsDead ( i ) then
14650: LD_VAR 0 1
14654: PPUSH
14655: CALL_OW 301
14659: IFFALSE 14679
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14661: LD_ADDR_EXP 96
14665: PUSH
14666: LD_EXP 96
14670: PUSH
14671: LD_VAR 0 1
14675: DIFF
14676: ST_TO_ADDR
// continue ;
14677: GO 14462
// end ; end ;
14679: GO 14462
14681: POP
14682: POP
// until allianceDestroyed or not allianceSpecialForce ;
14683: LD_EXP 23
14687: PUSH
14688: LD_EXP 96
14692: NOT
14693: OR
14694: IFFALSE 14445
// end ;
14696: PPOPN 3
14698: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14699: LD_EXP 31
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_INT 1
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 2
14716: PUSH
14717: LD_INT 35
14719: PUSH
14720: LD_INT 8
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: LD_INT 34
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 69
14750: AND
14751: IFFALSE 15151
14753: GO 14755
14755: DISABLE
14756: LD_INT 0
14758: PPUSH
14759: PPUSH
14760: PPUSH
14761: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14762: LD_ADDR_VAR 0 1
14766: PUSH
14767: DOUBLE
14768: LD_INT 1
14770: DEC
14771: ST_TO_ADDR
14772: LD_INT 6
14774: PUSH
14775: LD_INT 8
14777: PUSH
14778: LD_INT 10
14780: PUSH
14781: LD_INT 12
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: PUSH
14790: LD_OWVAR 67
14794: ARRAY
14795: PUSH
14796: FOR_TO
14797: IFFALSE 14989
// begin uc_side := 7 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 7
14806: ST_TO_ADDR
// uc_nation := 1 ;
14807: LD_ADDR_OWVAR 21
14811: PUSH
14812: LD_INT 1
14814: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14815: LD_INT 5
14817: PPUSH
14818: LD_INT 3
14820: PPUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 1
14833: PPUSH
14834: LD_INT 2
14836: PPUSH
14837: CALL_OW 12
14841: ARRAY
14842: PPUSH
14843: LD_INT 6
14845: PUSH
14846: LD_INT 9
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 2
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: PPUSH
14865: LD_INT 100
14867: PPUSH
14868: CALL 75122 0 5
// un := CreateVehicle ;
14872: LD_ADDR_VAR 0 2
14876: PUSH
14877: CALL_OW 45
14881: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_INT 4
14889: PPUSH
14890: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14894: LD_VAR 0 2
14898: PPUSH
14899: LD_INT 307
14901: PPUSH
14902: LD_INT 219
14904: PPUSH
14905: LD_INT 6
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 50
// if GetControl ( un ) = control_remote then
14915: LD_VAR 0 2
14919: PPUSH
14920: CALL_OW 263
14924: PUSH
14925: LD_INT 2
14927: EQUAL
14928: IFFALSE 14939
// Connect ( un ) ;
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 78590 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14939: LD_VAR 0 2
14943: PPUSH
14944: LD_INT 124
14946: PPUSH
14947: LD_INT 92
14949: PPUSH
14950: LD_INT 12
14952: PPUSH
14953: LD_INT 1
14955: PPUSH
14956: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14960: LD_ADDR_VAR 0 3
14964: PUSH
14965: LD_VAR 0 3
14969: PPUSH
14970: LD_VAR 0 2
14974: PPUSH
14975: CALL 107973 0 2
14979: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14980: LD_INT 10
14982: PPUSH
14983: CALL_OW 67
// end ;
14987: GO 14796
14989: POP
14990: POP
// repeat wait ( 0 0$2 ) ;
14991: LD_INT 70
14993: PPUSH
14994: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 1
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: LD_INT 34
15015: PUSH
15016: LD_INT 8
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PPUSH
15027: CALL_OW 69
15031: ST_TO_ADDR
// if not e then
15032: LD_VAR 0 4
15036: NOT
15037: IFFALSE 15073
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15039: LD_ADDR_VAR 0 4
15043: PUSH
15044: LD_INT 22
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 21
15056: PUSH
15057: LD_INT 2
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: ST_TO_ADDR
// for i in tmp do
15073: LD_ADDR_VAR 0 1
15077: PUSH
15078: LD_VAR 0 3
15082: PUSH
15083: FOR_IN
15084: IFFALSE 15142
// if not IsOK ( i ) then
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 302
15095: NOT
15096: IFFALSE 15116
// tmp := tmp diff i else
15098: LD_ADDR_VAR 0 3
15102: PUSH
15103: LD_VAR 0 3
15107: PUSH
15108: LD_VAR 0 1
15112: DIFF
15113: ST_TO_ADDR
15114: GO 15140
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_VAR 0 4
15125: PPUSH
15126: LD_VAR 0 1
15130: PPUSH
15131: CALL_OW 74
15135: PPUSH
15136: CALL_OW 115
15140: GO 15083
15142: POP
15143: POP
// until not tmp ;
15144: LD_VAR 0 3
15148: NOT
15149: IFFALSE 14991
// end ;
15151: PPOPN 4
15153: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15154: LD_EXP 23
15158: NOT
15159: PUSH
15160: LD_EXP 31
15164: AND
15165: IFFALSE 16239
15167: GO 15169
15169: DISABLE
15170: LD_INT 0
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
// begin enable ;
15177: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15178: LD_INT 22
15180: PUSH
15181: LD_INT 7
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 30
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: NOT
15207: IFFALSE 15211
// exit ;
15209: GO 16239
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_INT 7
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 30
15228: PUSH
15229: LD_INT 34
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 69
15244: ST_TO_ADDR
// if Prob ( 40 ) then
15245: LD_INT 40
15247: PPUSH
15248: CALL_OW 13
15252: IFFALSE 15398
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15254: LD_INT 1
15256: PPUSH
15257: LD_INT 5
15259: PUSH
15260: LD_INT 3
15262: PUSH
15263: LD_INT 2
15265: PUSH
15266: LD_INT 6
15268: PUSH
15269: EMPTY
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 5
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 6
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 5
15295: PUSH
15296: LD_INT 3
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 5
15313: PUSH
15314: LD_INT 3
15316: PUSH
15317: LD_INT 2
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PUSH
15329: LD_INT 24
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 45
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 24
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 47
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 24
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 45
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: PPUSH
15392: CALL 63856 0 2
// end else
15396: GO 15540
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15398: LD_INT 1
15400: PPUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 47
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 24
15421: PUSH
15422: LD_INT 3
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 47
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 5
15439: PUSH
15440: LD_INT 3
15442: PUSH
15443: LD_INT 2
15445: PUSH
15446: LD_INT 9
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 5
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 9
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: PUSH
15473: LD_INT 5
15475: PUSH
15476: LD_INT 3
15478: PUSH
15479: LD_INT 2
15481: PUSH
15482: LD_INT 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 45
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_INT 24
15511: PUSH
15512: LD_INT 1
15514: PUSH
15515: LD_INT 3
15517: PUSH
15518: LD_INT 45
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL 63856 0 2
// end ; wait ( 2 2$00 ) ;
15540: LD_INT 4200
15542: PPUSH
15543: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 7
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 2
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 13
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 3
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 12
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 3
15608: PUSH
15609: LD_INT 34
15611: PUSH
15612: LD_INT 51
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 3
15625: PUSH
15626: LD_INT 34
15628: PUSH
15629: LD_INT 52
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: PUSH
15653: LD_EXP 124
15657: PUSH
15658: LD_INT 1
15660: ARRAY
15661: DIFF
15662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15663: LD_ADDR_EXP 121
15667: PUSH
15668: LD_EXP 121
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_EXP 121
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: LD_VAR 0 2
15689: DIFF
15690: PPUSH
15691: CALL_OW 1
15695: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: PPUSH
15704: LD_INT 1
15706: PPUSH
15707: CALL_OW 12
15711: ST_TO_ADDR
// p := 0 ;
15712: LD_ADDR_VAR 0 5
15716: PUSH
15717: LD_INT 0
15719: ST_TO_ADDR
// if target then
15720: LD_VAR 0 3
15724: IFFALSE 15915
// begin for i in tmp do
15726: LD_ADDR_VAR 0 1
15730: PUSH
15731: LD_VAR 0 2
15735: PUSH
15736: FOR_IN
15737: IFFALSE 15762
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_INT 179
15746: PPUSH
15747: LD_INT 209
15749: PPUSH
15750: LD_INT 8
15752: PPUSH
15753: LD_INT 1
15755: PPUSH
15756: CALL_OW 483
15760: GO 15736
15762: POP
15763: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: LD_VAR 0 2
15773: PPUSH
15774: LD_INT 24
15776: PUSH
15777: LD_INT 250
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 72
15788: ST_TO_ADDR
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15840
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 179
15809: PPUSH
15810: LD_INT 209
15812: PPUSH
15813: CALL_OW 297
15817: PUSH
15818: LD_INT 9
15820: GREATER
15821: IFFALSE 15838
// ComMoveXY ( i , 179 , 209 ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: LD_INT 179
15830: PPUSH
15831: LD_INT 209
15833: PPUSH
15834: CALL_OW 111
15838: GO 15799
15840: POP
15841: POP
// wait ( 0 0$1 ) ;
15842: LD_INT 35
15844: PPUSH
15845: CALL_OW 67
// p := Inc ( p ) ;
15849: LD_ADDR_VAR 0 5
15853: PUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL 109334 0 1
15863: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 92
15871: PUSH
15872: LD_INT 179
15874: PUSH
15875: LD_INT 209
15877: PUSH
15878: LD_INT 9
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: PPUSH
15887: CALL_OW 72
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_INT 1
15899: MINUS
15900: GREATEREQUAL
15901: PUSH
15902: LD_VAR 0 5
15906: PUSH
15907: LD_INT 30
15909: GREATER
15910: OR
15911: IFFALSE 15764
// end else
15913: GO 16102
// begin for i in tmp do
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: FOR_IN
15926: IFFALSE 15951
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 285
15935: PPUSH
15936: LD_INT 163
15938: PPUSH
15939: LD_INT 8
15941: PPUSH
15942: LD_INT 1
15944: PPUSH
15945: CALL_OW 483
15949: GO 15925
15951: POP
15952: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_VAR 0 2
15962: PPUSH
15963: LD_INT 24
15965: PUSH
15966: LD_INT 250
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 72
15977: ST_TO_ADDR
// for i in tmp do
15978: LD_ADDR_VAR 0 1
15982: PUSH
15983: LD_VAR 0 2
15987: PUSH
15988: FOR_IN
15989: IFFALSE 16029
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 285
15998: PPUSH
15999: LD_INT 163
16001: PPUSH
16002: CALL_OW 297
16006: PUSH
16007: LD_INT 9
16009: GREATER
16010: IFFALSE 16027
// ComMoveXY ( i , 285 , 163 ) ;
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_INT 285
16019: PPUSH
16020: LD_INT 163
16022: PPUSH
16023: CALL_OW 111
16027: GO 15988
16029: POP
16030: POP
// wait ( 0 0$1 ) ;
16031: LD_INT 35
16033: PPUSH
16034: CALL_OW 67
// p := Inc ( p ) ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_VAR 0 5
16047: PPUSH
16048: CALL 109334 0 1
16052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16053: LD_VAR 0 2
16057: PPUSH
16058: LD_INT 92
16060: PUSH
16061: LD_INT 285
16063: PUSH
16064: LD_INT 163
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 72
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_INT 1
16088: MINUS
16089: GREATEREQUAL
16090: PUSH
16091: LD_VAR 0 5
16095: PUSH
16096: LD_INT 30
16098: GREATER
16099: OR
16100: IFFALSE 15953
// end ; repeat wait ( 0 0$1 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16109: LD_ADDR_VAR 0 2
16113: PUSH
16114: LD_VAR 0 2
16118: PPUSH
16119: LD_INT 50
16121: PUSH
16122: EMPTY
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// for i in tmp do
16130: LD_ADDR_VAR 0 1
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16230
// if GetWeapon ( i ) = ru_time_lapser then
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 264
16152: PUSH
16153: LD_INT 49
16155: EQUAL
16156: IFFALSE 16194
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16158: LD_VAR 0 1
16162: PPUSH
16163: LD_INT 81
16165: PUSH
16166: LD_INT 7
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PPUSH
16178: LD_VAR 0 1
16182: PPUSH
16183: CALL_OW 74
16187: PPUSH
16188: CALL_OW 112
16192: GO 16228
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16194: LD_VAR 0 1
16198: PPUSH
16199: LD_INT 81
16201: PUSH
16202: LD_INT 7
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 74
16223: PPUSH
16224: CALL_OW 115
16228: GO 16140
16230: POP
16231: POP
// until not tmp ;
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16102
// end ;
16239: PPOPN 5
16241: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16242: LD_EXP 31
16246: PUSH
16247: LD_EXP 79
16251: PPUSH
16252: CALL_OW 302
16256: AND
16257: PUSH
16258: LD_OWVAR 67
16262: PUSH
16263: LD_INT 2
16265: GREATER
16266: AND
16267: IFFALSE 16367
16269: GO 16271
16271: DISABLE
// begin enable ;
16272: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16273: LD_EXP 79
16277: PPUSH
16278: LD_INT 245
16280: PPUSH
16281: LD_INT 234
16283: PPUSH
16284: CALL_OW 297
16288: PUSH
16289: LD_INT 6
16291: GREATER
16292: IFFALSE 16311
// ComMoveXY ( Roth , 245 , 234 ) else
16294: LD_EXP 79
16298: PPUSH
16299: LD_INT 245
16301: PPUSH
16302: LD_INT 234
16304: PPUSH
16305: CALL_OW 111
16309: GO 16367
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16311: LD_EXP 79
16315: PPUSH
16316: LD_INT 259
16318: PUSH
16319: LD_INT 235
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 252
16328: PUSH
16329: LD_INT 209
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: LD_INT 275
16338: PUSH
16339: LD_INT 235
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 3
16356: PPUSH
16357: CALL_OW 12
16361: ARRAY
16362: PPUSH
16363: CALL 112125 0 2
// end ; end_of_file
16367: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
// missionStage := 13 ;
16374: LD_ADDR_EXP 15
16378: PUSH
16379: LD_INT 13
16381: ST_TO_ADDR
// uc_side := 2 ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_INT 2
16389: ST_TO_ADDR
// uc_nation := 2 ;
16390: LD_ADDR_OWVAR 21
16394: PUSH
16395: LD_INT 2
16397: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16398: LD_ADDR_EXP 97
16402: PUSH
16403: LD_STRING Omar
16405: PPUSH
16406: CALL_OW 25
16410: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16411: LD_EXP 97
16415: PPUSH
16416: LD_INT 4
16418: PPUSH
16419: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16423: LD_EXP 97
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: LD_INT 75
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16441: LD_ADDR_EXP 98
16445: PUSH
16446: LD_STRING Heike
16448: PPUSH
16449: CALL_OW 25
16453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16454: LD_INT 14
16456: PPUSH
16457: LD_INT 3
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: LD_INT 27
16465: PPUSH
16466: LD_INT 100
16468: PPUSH
16469: CALL 75122 0 5
// veh := CreateVehicle ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: CALL_OW 45
16482: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_INT 2
16490: NEG
16491: PPUSH
16492: CALL_OW 242
// SetDir ( veh , 4 ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: LD_INT 4
16503: PPUSH
16504: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16508: LD_VAR 0 3
16512: PPUSH
16513: LD_INT 241
16515: PPUSH
16516: LD_INT 72
16518: PPUSH
16519: LD_INT 0
16521: PPUSH
16522: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16526: LD_EXP 98
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 52
// if KhatamStatus then
16540: LD_EXP 8
16544: IFFALSE 16607
// begin Khatam := NewCharacter ( Khatam ) ;
16546: LD_ADDR_EXP 99
16550: PUSH
16551: LD_STRING Khatam
16553: PPUSH
16554: CALL_OW 25
16558: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16559: LD_EXP 99
16563: PPUSH
16564: LD_INT 245
16566: PPUSH
16567: LD_INT 78
16569: PPUSH
16570: LD_INT 3
16572: PPUSH
16573: LD_INT 0
16575: PPUSH
16576: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16580: LD_EXP 99
16584: PPUSH
16585: LD_INT 4
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16595: LD_EXP 99
16599: PPUSH
16600: LD_INT 4
16602: PPUSH
16603: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: DOUBLE
16613: LD_INT 1
16615: DEC
16616: ST_TO_ADDR
16617: LD_INT 2
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 3
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PUSH
16641: FOR_TO
16642: IFFALSE 16708
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16644: LD_INT 0
16646: PPUSH
16647: LD_INT 6
16649: PUSH
16650: LD_OWVAR 67
16654: PLUS
16655: PPUSH
16656: CALL_OW 384
// un := CreateHuman ;
16660: LD_ADDR_VAR 0 4
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16670: LD_VAR 0 4
16674: PPUSH
16675: LD_INT 28
16677: PUSH
16678: LD_INT 29
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: LD_INT 2
16692: MOD
16693: PUSH
16694: LD_INT 1
16696: PLUS
16697: ARRAY
16698: PPUSH
16699: LD_INT 0
16701: PPUSH
16702: CALL_OW 49
// end ;
16706: GO 16641
16708: POP
16709: POP
// for i = 1 to 6 do
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_INT 6
16722: PUSH
16723: FOR_TO
16724: IFFALSE 16769
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16726: LD_INT 0
16728: PPUSH
16729: LD_INT 6
16731: PUSH
16732: LD_OWVAR 67
16736: PLUS
16737: PPUSH
16738: CALL_OW 381
// un := CreateHuman ;
16742: LD_ADDR_VAR 0 4
16746: PUSH
16747: CALL_OW 44
16751: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16752: LD_VAR 0 4
16756: PPUSH
16757: LD_INT 32
16759: PPUSH
16760: LD_INT 0
16762: PPUSH
16763: CALL_OW 49
// end ;
16767: GO 16723
16769: POP
16770: POP
// for i = 1 to 3 do
16771: LD_ADDR_VAR 0 2
16775: PUSH
16776: DOUBLE
16777: LD_INT 1
16779: DEC
16780: ST_TO_ADDR
16781: LD_INT 3
16783: PUSH
16784: FOR_TO
16785: IFFALSE 16833
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16787: LD_INT 0
16789: PPUSH
16790: LD_INT 8
16792: PPUSH
16793: LD_INT 6
16795: PUSH
16796: LD_OWVAR 67
16800: PLUS
16801: PPUSH
16802: CALL_OW 380
// un := CreateHuman ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: CALL_OW 44
16815: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16816: LD_VAR 0 4
16820: PPUSH
16821: LD_INT 32
16823: PPUSH
16824: LD_INT 0
16826: PPUSH
16827: CALL_OW 49
// end ;
16831: GO 16784
16833: POP
16834: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16835: LD_ADDR_VAR 0 2
16839: PUSH
16840: DOUBLE
16841: LD_INT 1
16843: DEC
16844: ST_TO_ADDR
16845: LD_INT 2
16847: PUSH
16848: LD_INT 3
16850: PUSH
16851: LD_INT 4
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: LD_OWVAR 67
16867: ARRAY
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16960
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16872: LD_INT 14
16874: PPUSH
16875: LD_INT 2
16877: PPUSH
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 28
16883: PPUSH
16884: LD_INT 80
16886: PPUSH
16887: CALL 75122 0 5
// veh := CreateVehicle ;
16891: LD_ADDR_VAR 0 3
16895: PUSH
16896: CALL_OW 45
16900: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16901: LD_VAR 0 3
16905: PPUSH
16906: LD_INT 3
16908: PPUSH
16909: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16913: LD_VAR 0 3
16917: PPUSH
16918: LD_INT 29
16920: PPUSH
16921: LD_INT 0
16923: PPUSH
16924: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16928: LD_INT 0
16930: PPUSH
16931: LD_INT 6
16933: PUSH
16934: LD_OWVAR 67
16938: PLUS
16939: PPUSH
16940: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16944: CALL_OW 44
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 52
// end ;
16958: GO 16869
16960: POP
16961: POP
// for i = 1 to 5 + Difficulty do
16962: LD_ADDR_VAR 0 2
16966: PUSH
16967: DOUBLE
16968: LD_INT 1
16970: DEC
16971: ST_TO_ADDR
16972: LD_INT 5
16974: PUSH
16975: LD_OWVAR 67
16979: PLUS
16980: PUSH
16981: FOR_TO
16982: IFFALSE 17109
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16984: LD_INT 14
16986: PPUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 3
16992: PPUSH
16993: CALL_OW 12
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 28
17003: PUSH
17004: LD_INT 26
17006: PUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_VAR 0 2
17023: PUSH
17024: LD_INT 4
17026: MOD
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: ARRAY
17032: PPUSH
17033: LD_INT 80
17035: PPUSH
17036: CALL 75122 0 5
// veh := CreateVehicle ;
17040: LD_ADDR_VAR 0 3
17044: PUSH
17045: CALL_OW 45
17049: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17050: LD_VAR 0 3
17054: PPUSH
17055: LD_INT 4
17057: PPUSH
17058: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_INT 28
17069: PPUSH
17070: LD_INT 0
17072: PPUSH
17073: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17077: LD_INT 0
17079: PPUSH
17080: LD_INT 6
17082: PUSH
17083: LD_OWVAR 67
17087: PLUS
17088: PPUSH
17089: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17093: CALL_OW 44
17097: PPUSH
17098: LD_VAR 0 3
17102: PPUSH
17103: CALL_OW 52
// end ;
17107: GO 16981
17109: POP
17110: POP
// for i = 1 to Difficulty do
17111: LD_ADDR_VAR 0 2
17115: PUSH
17116: DOUBLE
17117: LD_INT 1
17119: DEC
17120: ST_TO_ADDR
17121: LD_OWVAR 67
17125: PUSH
17126: FOR_TO
17127: IFFALSE 17187
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17129: LD_INT 14
17131: PPUSH
17132: LD_INT 3
17134: PPUSH
17135: LD_INT 5
17137: PPUSH
17138: LD_INT 29
17140: PPUSH
17141: LD_INT 80
17143: PPUSH
17144: CALL 75122 0 5
// veh := CreateVehicle ;
17148: LD_ADDR_VAR 0 3
17152: PUSH
17153: CALL_OW 45
17157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17158: LD_VAR 0 3
17162: PPUSH
17163: LD_INT 4
17165: PPUSH
17166: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_INT 28
17177: PPUSH
17178: LD_INT 0
17180: PPUSH
17181: CALL_OW 49
// end ;
17185: GO 17126
17187: POP
17188: POP
// end ;
17189: LD_VAR 0 1
17193: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17194: LD_INT 22
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PPUSH
17204: CALL_OW 69
17208: IFFALSE 17587
17210: GO 17212
17212: DISABLE
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
17218: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17219: LD_ADDR_VAR 0 3
17223: PUSH
17224: LD_INT 22
17226: PUSH
17227: LD_INT 2
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 25
17236: PUSH
17237: LD_INT 4
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 69
17252: PUSH
17253: LD_EXP 99
17257: DIFF
17258: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 22
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: PUSH
17279: LD_EXP 99
17283: PUSH
17284: LD_VAR 0 3
17288: UNION
17289: DIFF
17290: ST_TO_ADDR
// if Khatam then
17291: LD_EXP 99
17295: IFFALSE 17312
// ComMoveXY ( Khatam , 211 , 92 ) ;
17297: LD_EXP 99
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 92
17307: PPUSH
17308: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17312: LD_INT 197
17314: PPUSH
17315: LD_INT 80
17317: PPUSH
17318: LD_INT 2
17320: PPUSH
17321: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17325: LD_INT 213
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: LD_INT 2
17333: PPUSH
17334: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17338: LD_INT 215
17340: PPUSH
17341: LD_INT 129
17343: PPUSH
17344: LD_INT 2
17346: PPUSH
17347: CALL_OW 441
// if sci then
17351: LD_VAR 0 3
17355: IFFALSE 17376
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17357: LD_VAR 0 3
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: LD_INT 197
17368: PPUSH
17369: LD_INT 80
17371: PPUSH
17372: CALL_OW 158
// if sci > 1 then
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 1
17383: GREATER
17384: IFFALSE 17405
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17386: LD_VAR 0 3
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: LD_INT 213
17397: PPUSH
17398: LD_INT 90
17400: PPUSH
17401: CALL_OW 158
// if sci > 2 then
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 2
17412: GREATER
17413: IFFALSE 17434
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17415: LD_VAR 0 3
17419: PUSH
17420: LD_INT 3
17422: ARRAY
17423: PPUSH
17424: LD_INT 215
17426: PPUSH
17427: LD_INT 129
17429: PPUSH
17430: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17434: LD_VAR 0 2
17438: PPUSH
17439: LD_INT 195
17441: PPUSH
17442: LD_INT 102
17444: PPUSH
17445: CALL_OW 114
// wait ( 0 0$5 ) ;
17449: LD_INT 175
17451: PPUSH
17452: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17456: LD_INT 70
17458: PPUSH
17459: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: LD_INT 92
17470: PUSH
17471: LD_INT 195
17473: PUSH
17474: LD_INT 102
17476: PUSH
17477: LD_INT 36
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: ST_TO_ADDR
// for i in tmp do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17567
// if enemy then
17518: LD_VAR 0 4
17522: IFFALSE 17550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 4
17533: PPUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 74
17543: PPUSH
17544: CALL_OW 115
17548: GO 17565
// ComAgressiveMove ( i , 195 , 102 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 195
17557: PPUSH
17558: LD_INT 102
17560: PPUSH
17561: CALL_OW 114
17565: GO 17515
17567: POP
17568: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_INT 50
17576: PUSH
17577: EMPTY
17578: LIST
17579: PPUSH
17580: CALL_OW 72
17584: NOT
17585: IFFALSE 17456
// end ; end_of_file
17587: PPOPN 4
17589: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17590: LD_INT 0
17592: PPUSH
17593: PPUSH
17594: PPUSH
17595: PPUSH
17596: PPUSH
17597: PPUSH
17598: PPUSH
17599: PPUSH
17600: PPUSH
// Video ( true ) ;
17601: LD_INT 1
17603: PPUSH
17604: CALL 107945 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 7
17615: PPUSH
17616: LD_INT 0
17618: PPUSH
17619: CALL_OW 517
17623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: DOUBLE
17630: LD_INT 1
17632: DEC
17633: ST_TO_ADDR
17634: LD_VAR 0 5
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PUSH
17643: FOR_TO
17644: IFFALSE 17689
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17646: LD_VAR 0 5
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PUSH
17655: LD_VAR 0 2
17659: ARRAY
17660: PPUSH
17661: LD_VAR 0 5
17665: PUSH
17666: LD_INT 2
17668: ARRAY
17669: PUSH
17670: LD_VAR 0 2
17674: ARRAY
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_INT 15
17681: NEG
17682: PPUSH
17683: CALL 107859 0 4
17687: GO 17643
17689: POP
17690: POP
// CenterNowOnUnits ( Powell ) ;
17691: LD_EXP 61
17695: PPUSH
17696: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17700: LD_ADDR_VAR 0 5
17704: PUSH
17705: LD_EXP 59
17709: PUSH
17710: EMPTY
17711: LIST
17712: ST_TO_ADDR
// if GirlNewVeh then
17713: LD_EXP 60
17717: IFFALSE 17735
// tmp := tmp ^ GirlNewVeh ;
17719: LD_ADDR_VAR 0 5
17723: PUSH
17724: LD_VAR 0 5
17728: PUSH
17729: LD_EXP 60
17733: ADD
17734: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17735: LD_VAR 0 5
17739: PPUSH
17740: LD_INT 60
17742: PPUSH
17743: LD_INT 109
17745: PPUSH
17746: CALL_OW 111
// if KappaStatus then
17750: LD_EXP 2
17754: IFFALSE 17806
// begin Say ( JMM , D1nT-JMM-1 ) ;
17756: LD_EXP 40
17760: PPUSH
17761: LD_STRING D1nT-JMM-1
17763: PPUSH
17764: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17768: LD_EXP 61
17772: PPUSH
17773: LD_STRING D1T-Pow-1
17775: PPUSH
17776: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17780: LD_EXP 40
17784: PPUSH
17785: LD_STRING D1T-JMM-2
17787: PPUSH
17788: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17792: LD_EXP 61
17796: PPUSH
17797: LD_STRING D1T-Pow-2
17799: PPUSH
17800: CALL_OW 88
// end else
17804: GO 18012
// if JMMGirlStatus then
17806: LD_EXP 6
17810: IFFALSE 17955
// begin Say ( JMM , D1T-JMM-1 ) ;
17812: LD_EXP 40
17816: PPUSH
17817: LD_STRING D1T-JMM-1
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17824: LD_EXP 61
17828: PPUSH
17829: LD_STRING D1T-Pow-1
17831: PPUSH
17832: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17836: LD_EXP 40
17840: PPUSH
17841: LD_STRING D1T-JMM-3
17843: PPUSH
17844: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17848: LD_EXP 61
17852: PPUSH
17853: LD_STRING D1T-Pow-3
17855: PPUSH
17856: CALL_OW 88
// if JMMGirl then
17860: LD_EXP 7
17864: IFFALSE 17953
// begin case JMMGirl of 1 :
17866: LD_EXP 7
17870: PUSH
17871: LD_INT 1
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17880: LD_EXP 41
17884: PPUSH
17885: LD_STRING D1T-Joan-3
17887: PPUSH
17888: CALL_OW 88
17892: GO 17941
17894: LD_INT 2
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17903: LD_EXP 43
17907: PPUSH
17908: LD_STRING D1T-Lisa-3
17910: PPUSH
17911: CALL_OW 88
17915: GO 17941
17917: LD_INT 3
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17940
17925: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17926: LD_EXP 55
17930: PPUSH
17931: LD_STRING D1T-Con-3
17933: PPUSH
17934: CALL_OW 88
17938: GO 17941
17940: POP
// Say ( Powell , D1T-Pow-4 ) ;
17941: LD_EXP 61
17945: PPUSH
17946: LD_STRING D1T-Pow-4
17948: PPUSH
17949: CALL_OW 88
// end ; end else
17953: GO 18012
// if not FastEnd then
17955: LD_EXP 11
17959: NOT
17960: IFFALSE 17988
// begin Say ( JMM , D1T-JMM-4 ) ;
17962: LD_EXP 40
17966: PPUSH
17967: LD_STRING D1T-JMM-4
17969: PPUSH
17970: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17974: LD_EXP 61
17978: PPUSH
17979: LD_STRING D1T-Pow-5
17981: PPUSH
17982: CALL_OW 88
// end else
17986: GO 18012
// begin Say ( JMM , D1nT-JMM-1 ) ;
17988: LD_EXP 40
17992: PPUSH
17993: LD_STRING D1nT-JMM-1
17995: PPUSH
17996: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18000: LD_EXP 61
18004: PPUSH
18005: LD_STRING D1nT-Pow-1
18007: PPUSH
18008: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18012: LD_INT 3
18014: PPUSH
18015: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18019: LD_EXP 59
18023: PPUSH
18024: CALL_OW 314
18028: NOT
18029: IFFALSE 18012
// ComExitVehicle ( JMM ) ;
18031: LD_EXP 40
18035: PPUSH
18036: CALL_OW 121
// repeat wait ( 3 ) ;
18040: LD_INT 3
18042: PPUSH
18043: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18047: LD_EXP 40
18051: PPUSH
18052: CALL_OW 310
18056: NOT
18057: IFFALSE 18040
// ComMoveXY ( JMM , 60 , 94 ) ;
18059: LD_EXP 40
18063: PPUSH
18064: LD_INT 60
18066: PPUSH
18067: LD_INT 94
18069: PPUSH
18070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 61
18083: PPUSH
18084: CALL_OW 179
// if Joan then
18088: LD_EXP 41
18092: IFFALSE 18146
// begin ComExitVehicle ( Joan ) ;
18094: LD_EXP 41
18098: PPUSH
18099: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18103: LD_EXP 41
18107: PPUSH
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18115: LD_EXP 41
18119: PPUSH
18120: LD_INT 65
18122: PPUSH
18123: LD_INT 104
18125: PPUSH
18126: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18130: LD_EXP 41
18134: PPUSH
18135: LD_EXP 40
18139: PPUSH
18140: CALL_OW 179
// end else
18144: GO 18280
// if Lisa and JMMGirl = 2 then
18146: LD_EXP 43
18150: PUSH
18151: LD_EXP 7
18155: PUSH
18156: LD_INT 2
18158: EQUAL
18159: AND
18160: IFFALSE 18214
// begin ComExitVehicle ( Lisa ) ;
18162: LD_EXP 43
18166: PPUSH
18167: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18171: LD_EXP 43
18175: PPUSH
18176: LD_INT 35
18178: PPUSH
18179: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18183: LD_EXP 43
18187: PPUSH
18188: LD_INT 65
18190: PPUSH
18191: LD_INT 104
18193: PPUSH
18194: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18198: LD_EXP 43
18202: PPUSH
18203: LD_EXP 40
18207: PPUSH
18208: CALL_OW 179
// end else
18212: GO 18280
// if Connie and JMMGirl = 3 then
18214: LD_EXP 55
18218: PUSH
18219: LD_EXP 7
18223: PUSH
18224: LD_INT 3
18226: EQUAL
18227: AND
18228: IFFALSE 18280
// begin ComExitVehicle ( Connie ) ;
18230: LD_EXP 55
18234: PPUSH
18235: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18239: LD_EXP 55
18243: PPUSH
18244: LD_INT 35
18246: PPUSH
18247: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18251: LD_EXP 55
18255: PPUSH
18256: LD_INT 65
18258: PPUSH
18259: LD_INT 104
18261: PPUSH
18262: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18266: LD_EXP 55
18270: PPUSH
18271: LD_EXP 40
18275: PPUSH
18276: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18280: LD_INT 35
18282: PPUSH
18283: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18287: LD_EXP 40
18291: PPUSH
18292: LD_EXP 61
18296: PPUSH
18297: CALL_OW 296
18301: PUSH
18302: LD_INT 8
18304: LESS
18305: IFFALSE 18280
// wait ( 0 0$0.5 ) ;
18307: LD_INT 18
18309: PPUSH
18310: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-1
18321: PPUSH
18322: CALL_OW 88
// async ;
18326: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18327: LD_EXP 61
18331: PPUSH
18332: LD_STRING D1-Pow-1
18334: PPUSH
18335: CALL_OW 88
// if not dialogue_skipped then
18339: LD_OWVAR 59
18343: NOT
18344: IFFALSE 18353
// wait ( 0 0$2 ) ;
18346: LD_INT 70
18348: PPUSH
18349: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18353: LD_INT 170
18355: PPUSH
18356: LD_INT 99
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: LD_INT 6
18364: NEG
18365: PPUSH
18366: CALL 107859 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18370: LD_INT 174
18372: PPUSH
18373: LD_INT 115
18375: PPUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 6
18381: NEG
18382: PPUSH
18383: CALL 107859 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18387: LD_INT 169
18389: PPUSH
18390: LD_INT 71
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_INT 6
18398: NEG
18399: PPUSH
18400: CALL 107859 0 4
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18428
// begin CenterOnXY ( 170 , 99 ) ;
18411: LD_INT 170
18413: PPUSH
18414: LD_INT 99
18416: PPUSH
18417: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18421: LD_INT 80
18423: PPUSH
18424: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18428: LD_INT 75
18430: PPUSH
18431: LD_INT 53
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 9
18439: NEG
18440: PPUSH
18441: CALL 107859 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18445: LD_INT 54
18447: PPUSH
18448: LD_INT 42
18450: PPUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 9
18456: NEG
18457: PPUSH
18458: CALL 107859 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18462: LD_INT 62
18464: PPUSH
18465: LD_INT 51
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 9
18473: NEG
18474: PPUSH
18475: CALL 107859 0 4
// if not dialogue_skipped then
18479: LD_OWVAR 59
18483: NOT
18484: IFFALSE 18503
// begin CenterOnXY ( 75 , 53 ) ;
18486: LD_INT 75
18488: PPUSH
18489: LD_INT 53
18491: PPUSH
18492: CALL_OW 84
// wait ( 0 0$4 ) ;
18496: LD_INT 140
18498: PPUSH
18499: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18503: LD_EXP 61
18507: PPUSH
18508: CALL_OW 87
// if not dialogue_skipped then
18512: LD_OWVAR 59
18516: NOT
18517: IFFALSE 18526
// wait ( 0 0$2 ) ;
18519: LD_INT 70
18521: PPUSH
18522: CALL_OW 67
// sync ;
18526: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-2
18534: PPUSH
18535: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18539: LD_EXP 61
18543: PPUSH
18544: LD_STRING D1-Pow-2
18546: PPUSH
18547: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18551: LD_EXP 40
18555: PPUSH
18556: LD_STRING D1-JMM-3
18558: PPUSH
18559: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18563: LD_EXP 61
18567: PPUSH
18568: LD_STRING D1-Pow-3
18570: PPUSH
18571: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_STRING D1-JMM-4
18582: PPUSH
18583: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18587: LD_EXP 61
18591: PPUSH
18592: LD_STRING D1-Pow-4
18594: PPUSH
18595: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18599: LD_EXP 40
18603: PPUSH
18604: LD_STRING D1-JMM-5
18606: PPUSH
18607: CALL_OW 88
// async ;
18611: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18612: LD_EXP 61
18616: PPUSH
18617: LD_STRING D1-Pow-5
18619: PPUSH
18620: CALL_OW 88
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18638
// wait ( 0 0$3.6 ) ;
18631: LD_INT 126
18633: PPUSH
18634: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18638: LD_INT 134
18640: PPUSH
18641: LD_INT 210
18643: PPUSH
18644: LD_INT 1
18646: PPUSH
18647: LD_INT 11
18649: NEG
18650: PPUSH
18651: CALL 107859 0 4
// if not dialogue_skipped then
18655: LD_OWVAR 59
18659: NOT
18660: IFFALSE 18679
// begin CenterOnXY ( 134 , 210 ) ;
18662: LD_INT 134
18664: PPUSH
18665: LD_INT 210
18667: PPUSH
18668: CALL_OW 84
// wait ( 0 0$2 ) ;
18672: LD_INT 70
18674: PPUSH
18675: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18679: LD_INT 101
18681: PPUSH
18682: LD_INT 159
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: LD_INT 10
18690: NEG
18691: PPUSH
18692: CALL 107859 0 4
// if not dialogue_skipped then
18696: LD_OWVAR 59
18700: NOT
18701: IFFALSE 18720
// begin CenterOnXY ( 101 , 159 ) ;
18703: LD_INT 101
18705: PPUSH
18706: LD_INT 159
18708: PPUSH
18709: CALL_OW 84
// wait ( 0 0$2 ) ;
18713: LD_INT 70
18715: PPUSH
18716: CALL_OW 67
// end ; sync ;
18720: SYNC
// CenterNowOnUnits ( Powell ) ;
18721: LD_EXP 61
18725: PPUSH
18726: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18730: LD_ADDR_VAR 0 6
18734: PUSH
18735: LD_INT 1
18737: PUSH
18738: LD_INT 2
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: LD_INT 4
18746: PUSH
18747: LD_INT 5
18749: PUSH
18750: LD_INT 6
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18935
// begin game_speed := 4 ;
18768: LD_ADDR_OWVAR 65
18772: PUSH
18773: LD_INT 4
18775: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18776: LD_INT 210
18778: PPUSH
18779: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18783: LD_ADDR_VAR 0 7
18787: PUSH
18788: LD_STRING Q1
18790: PPUSH
18791: LD_VAR 0 6
18795: PPUSH
18796: CALL_OW 98
18800: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18801: LD_ADDR_VAR 0 7
18805: PUSH
18806: LD_STRING Q1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: CALL_OW 98
18818: ST_TO_ADDR
// options := options diff dec ;
18819: LD_ADDR_VAR 0 6
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: LD_VAR 0 7
18833: DIFF
18834: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18835: LD_VAR 0 7
18839: PPUSH
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL 20499 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18849: LD_VAR 0 7
18853: PUSH
18854: LD_INT 5
18856: PUSH
18857: LD_INT 6
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: IN
18864: PUSH
18865: LD_VAR 0 6
18869: PUSH
18870: LD_INT 2
18872: EQUAL
18873: OR
18874: IFFALSE 18801
// if not ( dec in [ 5 , 6 ] ) then
18876: LD_VAR 0 7
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: LD_INT 6
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: IN
18891: NOT
18892: IFFALSE 18935
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18894: LD_ADDR_VAR 0 7
18898: PUSH
18899: LD_STRING Q1a
18901: PPUSH
18902: LD_INT 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 98
18916: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18917: LD_VAR 0 7
18921: PUSH
18922: LD_INT 4
18924: PLUS
18925: PPUSH
18926: LD_VAR 0 6
18930: PPUSH
18931: CALL 20499 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18935: LD_INT 81
18937: PPUSH
18938: LD_INT 127
18940: PPUSH
18941: CALL_OW 84
// amount := 8 ;
18945: LD_ADDR_VAR 0 8
18949: PUSH
18950: LD_INT 8
18952: ST_TO_ADDR
// macmilan_squad := [ ] ;
18953: LD_ADDR_VAR 0 9
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// if vip < amount then
18960: LD_EXP 62
18964: PUSH
18965: LD_VAR 0 8
18969: LESS
18970: IFFALSE 19014
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18972: LD_ADDR_VAR 0 5
18976: PUSH
18977: LD_EXP 62
18981: PUSH
18982: LD_INT 22
18984: PUSH
18985: LD_INT 4
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 1
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 69
19010: UNION
19011: ST_TO_ADDR
19012: GO 19024
// tmp := vip ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_EXP 62
19023: ST_TO_ADDR
// tmp := tmp diff Powell ;
19024: LD_ADDR_VAR 0 5
19028: PUSH
19029: LD_VAR 0 5
19033: PUSH
19034: LD_EXP 61
19038: DIFF
19039: ST_TO_ADDR
// if tmp < amount then
19040: LD_VAR 0 5
19044: PUSH
19045: LD_VAR 0 8
19049: LESS
19050: IFFALSE 19062
// amount := tmp ;
19052: LD_ADDR_VAR 0 8
19056: PUSH
19057: LD_VAR 0 5
19061: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 2
19078: NONEQUAL
19079: IFFALSE 19177
// begin if IsInUnit ( tmp [ 1 ] ) then
19081: LD_VAR 0 5
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: CALL_OW 310
19094: IFFALSE 19109
// ComExitBuilding ( tmp [ 1 ] ) ;
19096: LD_VAR 0 5
19100: PUSH
19101: LD_INT 1
19103: ARRAY
19104: PPUSH
19105: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19109: LD_INT 387
19111: PPUSH
19112: CALL_OW 313
19116: PUSH
19117: LD_INT 6
19119: EQUAL
19120: IFFALSE 19145
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19122: LD_INT 387
19124: PPUSH
19125: CALL_OW 313
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: CALL_OW 122
// wait ( 3 ) ;
19138: LD_INT 3
19140: PPUSH
19141: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19145: LD_VAR 0 5
19149: PUSH
19150: LD_INT 1
19152: ARRAY
19153: PPUSH
19154: LD_INT 387
19156: PPUSH
19157: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19161: LD_VAR 0 5
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_INT 2
19172: PPUSH
19173: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19177: LD_EXP 40
19181: PPUSH
19182: LD_INT 82
19184: PPUSH
19185: LD_INT 129
19187: PPUSH
19188: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19192: LD_EXP 40
19196: PPUSH
19197: LD_EXP 61
19201: PPUSH
19202: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19206: LD_INT 22
19208: PUSH
19209: LD_INT 1
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: PPUSH
19216: CALL_OW 69
19220: PUSH
19221: LD_EXP 40
19225: DIFF
19226: PPUSH
19227: LD_INT 84
19229: PPUSH
19230: LD_INT 128
19232: PPUSH
19233: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19237: LD_INT 22
19239: PUSH
19240: LD_INT 1
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PPUSH
19247: CALL_OW 69
19251: PUSH
19252: LD_EXP 40
19256: DIFF
19257: PPUSH
19258: LD_EXP 40
19262: PPUSH
19263: CALL_OW 179
// for i = 1 to amount do
19267: LD_ADDR_VAR 0 2
19271: PUSH
19272: DOUBLE
19273: LD_INT 1
19275: DEC
19276: ST_TO_ADDR
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_TO
19283: IFFALSE 19451
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19285: LD_ADDR_VAR 0 9
19289: PUSH
19290: LD_VAR 0 9
19294: PUSH
19295: LD_VAR 0 5
19299: PUSH
19300: LD_VAR 0 2
19304: ARRAY
19305: ADD
19306: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19307: LD_VAR 0 5
19311: PUSH
19312: LD_VAR 0 2
19316: ARRAY
19317: PPUSH
19318: CALL_OW 310
19322: IFFALSE 19339
// AddComExitBuilding ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 182
// if i = 2 and JMMNewVeh then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 2
19346: EQUAL
19347: PUSH
19348: LD_EXP 59
19352: AND
19353: IFFALSE 19411
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19355: LD_VAR 0 5
19359: PUSH
19360: LD_VAR 0 2
19364: ARRAY
19365: PPUSH
19366: LD_EXP 59
19370: PPUSH
19371: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 2
19384: ARRAY
19385: PPUSH
19386: LD_INT 86
19388: PPUSH
19389: LD_INT 133
19391: PPUSH
19392: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19396: LD_VAR 0 5
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19411: LD_VAR 0 5
19415: PUSH
19416: LD_VAR 0 2
19420: ARRAY
19421: PPUSH
19422: LD_INT 8
19424: PPUSH
19425: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19429: LD_VAR 0 5
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: LD_EXP 40
19444: PPUSH
19445: CALL_OW 179
// end ;
19449: GO 19282
19451: POP
19452: POP
// if GirlNewVeh then
19453: LD_EXP 60
19457: IFFALSE 19471
// SetSide ( GirlNewVeh , 4 ) ;
19459: LD_EXP 60
19463: PPUSH
19464: LD_INT 4
19466: PPUSH
19467: CALL_OW 235
// if Mike then
19471: LD_EXP 57
19475: IFFALSE 19512
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19477: LD_ADDR_VAR 0 9
19481: PUSH
19482: LD_VAR 0 9
19486: PPUSH
19487: LD_EXP 57
19491: PPUSH
19492: CALL 107973 0 2
19496: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19497: LD_EXP 57
19501: PPUSH
19502: LD_INT 86
19504: PPUSH
19505: LD_INT 133
19507: PPUSH
19508: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19512: LD_INT 35
19514: PPUSH
19515: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19519: LD_VAR 0 9
19523: PPUSH
19524: LD_INT 95
19526: PUSH
19527: LD_INT 9
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: PUSH
19539: LD_INT 0
19541: EQUAL
19542: PUSH
19543: LD_EXP 40
19547: PPUSH
19548: LD_INT 9
19550: PPUSH
19551: CALL_OW 308
19555: NOT
19556: AND
19557: IFFALSE 19512
// wait ( 0 0$2 ) ;
19559: LD_INT 70
19561: PPUSH
19562: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19566: LD_VAR 0 9
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19578: LD_INT 21
19580: PUSH
19581: LD_INT 2
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 92
19590: PUSH
19591: LD_INT 83
19593: PUSH
19594: LD_INT 130
19596: PUSH
19597: LD_INT 10
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PPUSH
19610: CALL_OW 69
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: CALL_OW 235
// tick := 0 ;
19622: LD_ADDR_OWVAR 1
19626: PUSH
19627: LD_INT 0
19629: ST_TO_ADDR
// Video ( false ) ;
19630: LD_INT 0
19632: PPUSH
19633: CALL 107945 0 1
// ChangeMissionObjectives ( M1 ) ;
19637: LD_STRING M1
19639: PPUSH
19640: CALL_OW 337
// SaveForQuickRestart ;
19644: CALL_OW 22
// missionStart := true ;
19648: LD_ADDR_EXP 13
19652: PUSH
19653: LD_INT 1
19655: ST_TO_ADDR
// missionStage := 2 ;
19656: LD_ADDR_EXP 15
19660: PUSH
19661: LD_INT 2
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19671: LD_ADDR_VAR 0 5
19675: PUSH
19676: LD_INT 22
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 1
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 69
19704: PUSH
19705: LD_EXP 61
19709: DIFF
19710: ST_TO_ADDR
// if not tmp then
19711: LD_VAR 0 5
19715: NOT
19716: IFFALSE 19731
// tmp := [ Powell ] ;
19718: LD_ADDR_VAR 0 5
19722: PUSH
19723: LD_EXP 61
19727: PUSH
19728: EMPTY
19729: LIST
19730: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 34
19748: PUSH
19749: LD_INT 12
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: PUSH
19765: LD_INT 1
19767: ARRAY
19768: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19769: LD_VAR 0 5
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: CALL_OW 310
19782: IFFALSE 19797
// ComExitBuilding ( tmp [ 1 ] ) ;
19784: LD_VAR 0 5
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19797: LD_VAR 0 5
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PPUSH
19806: LD_VAR 0 4
19810: PPUSH
19811: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19815: LD_VAR 0 5
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: LD_INT 80
19826: PPUSH
19827: LD_INT 136
19829: PPUSH
19830: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19834: LD_VAR 0 5
19838: PUSH
19839: LD_INT 1
19841: ARRAY
19842: PPUSH
19843: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19847: LD_VAR 0 5
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: LD_INT 59
19858: PPUSH
19859: LD_INT 112
19861: PPUSH
19862: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19879: LD_EXP 41
19883: PUSH
19884: LD_EXP 41
19888: PPUSH
19889: CALL_OW 255
19893: PUSH
19894: LD_INT 1
19896: EQUAL
19897: AND
19898: IFFALSE 19924
// begin Say ( Joan , D3W-Joan-1 ) ;
19900: LD_EXP 41
19904: PPUSH
19905: LD_STRING D3W-Joan-1
19907: PPUSH
19908: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19912: LD_EXP 40
19916: PPUSH
19917: LD_STRING D3W-JMM-1
19919: PPUSH
19920: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19924: LD_EXP 43
19928: PUSH
19929: LD_EXP 43
19933: PPUSH
19934: CALL_OW 255
19938: PUSH
19939: LD_INT 1
19941: EQUAL
19942: AND
19943: PUSH
19944: LD_EXP 43
19948: PUSH
19949: LD_EXP 62
19953: IN
19954: NOT
19955: AND
19956: IFFALSE 19982
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19958: LD_EXP 43
19962: PPUSH
19963: LD_STRING D3W-Lisa-1
19965: PPUSH
19966: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19970: LD_EXP 40
19974: PPUSH
19975: LD_STRING D3W-JMM-1
19977: PPUSH
19978: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19982: LD_EXP 55
19986: PUSH
19987: LD_EXP 55
19991: PPUSH
19992: CALL_OW 255
19996: PUSH
19997: LD_INT 1
19999: EQUAL
20000: AND
20001: IFFALSE 20027
// begin Say ( Connie , D3W-Con-1 ) ;
20003: LD_EXP 55
20007: PPUSH
20008: LD_STRING D3W-Con-1
20010: PPUSH
20011: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20015: LD_EXP 40
20019: PPUSH
20020: LD_STRING D3W-JMM-1
20022: PPUSH
20023: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20027: LD_INT 18
20029: PPUSH
20030: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20034: LD_EXP 43
20038: PUSH
20039: LD_EXP 62
20043: IN
20044: PUSH
20045: LD_EXP 43
20049: PPUSH
20050: CALL_OW 255
20054: PUSH
20055: LD_INT 1
20057: EQUAL
20058: AND
20059: IFFALSE 20075
// Say ( Lisa , D3nW-Lisa-1 ) else
20061: LD_EXP 43
20065: PPUSH
20066: LD_STRING D3nW-Lisa-1
20068: PPUSH
20069: CALL_OW 88
20073: GO 20319
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20075: LD_EXP 46
20079: PUSH
20080: LD_EXP 62
20084: IN
20085: PUSH
20086: LD_EXP 46
20090: PPUSH
20091: CALL_OW 255
20095: PUSH
20096: LD_INT 1
20098: EQUAL
20099: AND
20100: IFFALSE 20116
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20102: LD_EXP 46
20106: PPUSH
20107: LD_STRING D3nW-Cyrus-1
20109: PPUSH
20110: CALL_OW 88
20114: GO 20319
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20116: LD_EXP 45
20120: PUSH
20121: LD_EXP 62
20125: IN
20126: PUSH
20127: LD_EXP 45
20131: PPUSH
20132: CALL_OW 255
20136: PUSH
20137: LD_INT 1
20139: EQUAL
20140: AND
20141: IFFALSE 20157
// Say ( Bobby , D3nW-Bobby-1 ) else
20143: LD_EXP 45
20147: PPUSH
20148: LD_STRING D3nW-Bobby-1
20150: PPUSH
20151: CALL_OW 88
20155: GO 20319
// if Gary in vip and GetSide ( Gary ) = 1 then
20157: LD_EXP 52
20161: PUSH
20162: LD_EXP 62
20166: IN
20167: PUSH
20168: LD_EXP 52
20172: PPUSH
20173: CALL_OW 255
20177: PUSH
20178: LD_INT 1
20180: EQUAL
20181: AND
20182: IFFALSE 20198
// Say ( Gary , D3nW-Gary-1 ) else
20184: LD_EXP 52
20188: PPUSH
20189: LD_STRING D3nW-Gary-1
20191: PPUSH
20192: CALL_OW 88
20196: GO 20319
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20198: LD_EXP 44
20202: PUSH
20203: LD_EXP 62
20207: IN
20208: PUSH
20209: LD_EXP 44
20213: PPUSH
20214: CALL_OW 255
20218: PUSH
20219: LD_INT 1
20221: EQUAL
20222: AND
20223: IFFALSE 20239
// Say ( Donaldson , D3nW-Don-1 ) else
20225: LD_EXP 44
20229: PPUSH
20230: LD_STRING D3nW-Don-1
20232: PPUSH
20233: CALL_OW 88
20237: GO 20319
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20239: LD_EXP 51
20243: PUSH
20244: LD_EXP 62
20248: IN
20249: PUSH
20250: LD_EXP 51
20254: PPUSH
20255: CALL_OW 255
20259: PUSH
20260: LD_INT 1
20262: EQUAL
20263: AND
20264: IFFALSE 20280
// Say ( Cornel , D3nW-Corn-1 ) else
20266: LD_EXP 51
20270: PPUSH
20271: LD_STRING D3nW-Corn-1
20273: PPUSH
20274: CALL_OW 88
20278: GO 20319
// if Frank in vip and GetSide ( Frank ) = 1 then
20280: LD_EXP 53
20284: PUSH
20285: LD_EXP 62
20289: IN
20290: PUSH
20291: LD_EXP 53
20295: PPUSH
20296: CALL_OW 255
20300: PUSH
20301: LD_INT 1
20303: EQUAL
20304: AND
20305: IFFALSE 20319
// Say ( Frank , D3nW-Frank-1 ) ;
20307: LD_EXP 53
20311: PPUSH
20312: LD_STRING D3nW-Frank-1
20314: PPUSH
20315: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20319: LD_EXP 62
20323: PPUSH
20324: LD_INT 22
20326: PUSH
20327: LD_INT 1
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PPUSH
20334: CALL_OW 72
20338: IFFALSE 20364
// begin Say ( JMM , D3nW-JMM-1 ) ;
20340: LD_EXP 40
20344: PPUSH
20345: LD_STRING D3nW-JMM-1
20347: PPUSH
20348: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20352: LD_EXP 40
20356: PPUSH
20357: LD_STRING D3nW-JMM-1a
20359: PPUSH
20360: CALL_OW 88
// end ; t := 0 0$00 ;
20364: LD_ADDR_VAR 0 3
20368: PUSH
20369: LD_INT 0
20371: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20372: LD_INT 35
20374: PPUSH
20375: CALL_OW 67
// t := t + 0 0$1 ;
20379: LD_ADDR_VAR 0 3
20383: PUSH
20384: LD_VAR 0 3
20388: PUSH
20389: LD_INT 35
20391: PLUS
20392: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20393: LD_INT 59
20395: PPUSH
20396: LD_INT 112
20398: PPUSH
20399: CALL_OW 428
20403: PUSH
20404: LD_VAR 0 3
20408: PUSH
20409: LD_INT 2100
20411: GREATER
20412: OR
20413: IFFALSE 20372
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20415: LD_ADDR_EXP 102
20419: PUSH
20420: LD_EXP 102
20424: PPUSH
20425: LD_INT 4
20427: PPUSH
20428: LD_INT 22
20430: PUSH
20431: LD_INT 4
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 23
20440: PUSH
20441: LD_INT 1
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: LD_INT 3
20450: PUSH
20451: LD_INT 21
20453: PUSH
20454: LD_INT 2
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: LIST
20469: PPUSH
20470: CALL_OW 69
20474: PUSH
20475: LD_EXP 61
20479: DIFF
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// activeAttacks := true ;
20486: LD_ADDR_EXP 16
20490: PUSH
20491: LD_INT 1
20493: ST_TO_ADDR
// end ;
20494: LD_VAR 0 1
20498: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20499: LD_INT 0
20501: PPUSH
// case question of 1 :
20502: LD_VAR 0 1
20506: PUSH
20507: LD_INT 1
20509: DOUBLE
20510: EQUAL
20511: IFTRUE 20515
20513: GO 20566
20515: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20516: LD_EXP 40
20520: PPUSH
20521: LD_STRING D2Mot-JMM-1
20523: PPUSH
20524: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20528: LD_EXP 61
20532: PPUSH
20533: LD_STRING D2Mot-Pow-1
20535: PPUSH
20536: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20540: LD_EXP 40
20544: PPUSH
20545: LD_STRING D2Mot-JMM-2
20547: PPUSH
20548: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20552: LD_EXP 61
20556: PPUSH
20557: LD_STRING D2Mot-Pow-2
20559: PPUSH
20560: CALL_OW 88
// end ; 2 :
20564: GO 20917
20566: LD_INT 2
20568: DOUBLE
20569: EQUAL
20570: IFTRUE 20574
20572: GO 20650
20574: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20575: LD_EXP 40
20579: PPUSH
20580: LD_STRING D2Rus-JMM-1
20582: PPUSH
20583: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20587: LD_EXP 61
20591: PPUSH
20592: LD_STRING D2Rus-Pow-1
20594: PPUSH
20595: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20599: LD_EXP 40
20603: PPUSH
20604: LD_STRING D2Rus-JMM-2
20606: PPUSH
20607: CALL_OW 88
// if not ( 3 in list_of_q ) then
20611: LD_INT 3
20613: PUSH
20614: LD_VAR 0 2
20618: IN
20619: NOT
20620: IFFALSE 20636
// Say ( Powell , D2Rus-Pow-2 ) else
20622: LD_EXP 61
20626: PPUSH
20627: LD_STRING D2Rus-Pow-2
20629: PPUSH
20630: CALL_OW 88
20634: GO 20648
// Say ( Powell , D2Rus-Pow-2a ) ;
20636: LD_EXP 61
20640: PPUSH
20641: LD_STRING D2Rus-Pow-2a
20643: PPUSH
20644: CALL_OW 88
// end ; 3 :
20648: GO 20917
20650: LD_INT 3
20652: DOUBLE
20653: EQUAL
20654: IFTRUE 20658
20656: GO 20743
20658: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20659: LD_EXP 40
20663: PPUSH
20664: LD_STRING D2Leg-JMM-1
20666: PPUSH
20667: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20671: LD_EXP 61
20675: PPUSH
20676: LD_STRING D2Leg-Pow-1
20678: PPUSH
20679: CALL_OW 88
// if 2 in list_of_q then
20683: LD_INT 2
20685: PUSH
20686: LD_VAR 0 2
20690: IN
20691: IFFALSE 20717
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20693: LD_EXP 40
20697: PPUSH
20698: LD_STRING D2Leg-JMM-2
20700: PPUSH
20701: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20705: LD_EXP 61
20709: PPUSH
20710: LD_STRING D2Leg-Pow-2
20712: PPUSH
20713: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20717: LD_EXP 40
20721: PPUSH
20722: LD_STRING D2Leg-JMM-3
20724: PPUSH
20725: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20729: LD_EXP 61
20733: PPUSH
20734: LD_STRING D2Leg-Pow-3
20736: PPUSH
20737: CALL_OW 88
// end ; 4 :
20741: GO 20917
20743: LD_INT 4
20745: DOUBLE
20746: EQUAL
20747: IFTRUE 20751
20749: GO 20826
20751: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20752: LD_EXP 40
20756: PPUSH
20757: LD_STRING D2Ar-JMM-1
20759: PPUSH
20760: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20764: LD_EXP 61
20768: PPUSH
20769: LD_STRING D2Ar-Pow-1
20771: PPUSH
20772: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20776: LD_EXP 40
20780: PPUSH
20781: LD_STRING D2Ar-JMM-2
20783: PPUSH
20784: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20788: LD_EXP 61
20792: PPUSH
20793: LD_STRING D2Ar-Pow-2
20795: PPUSH
20796: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20800: LD_EXP 40
20804: PPUSH
20805: LD_STRING D2Ar-JMM-3
20807: PPUSH
20808: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20812: LD_EXP 61
20816: PPUSH
20817: LD_STRING D2Ar-Pow-3
20819: PPUSH
20820: CALL_OW 88
// end ; 5 :
20824: GO 20917
20826: LD_INT 5
20828: DOUBLE
20829: EQUAL
20830: IFTRUE 20834
20832: GO 20849
20834: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20835: LD_EXP 40
20839: PPUSH
20840: LD_STRING D2Conf-JMM-1
20842: PPUSH
20843: CALL_OW 88
20847: GO 20917
20849: LD_INT 6
20851: DOUBLE
20852: EQUAL
20853: IFTRUE 20857
20855: GO 20916
20857: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20858: LD_EXP 40
20862: PPUSH
20863: LD_STRING D2Com-JMM-1
20865: PPUSH
20866: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20870: LD_EXP 61
20874: PPUSH
20875: LD_STRING D2Com-Pow-1
20877: PPUSH
20878: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20882: LD_EXP 40
20886: PPUSH
20887: LD_STRING D2Com-JMM-2
20889: PPUSH
20890: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20894: LD_EXP 61
20898: PPUSH
20899: LD_STRING D2Com-Pow-2
20901: PPUSH
20902: CALL_OW 88
// powellAngerQuery := true ;
20906: LD_ADDR_EXP 36
20910: PUSH
20911: LD_INT 1
20913: ST_TO_ADDR
// end ; end ;
20914: GO 20917
20916: POP
// end ;
20917: LD_VAR 0 3
20921: RET
// every 0 0$5 trigger missionStart do var tmp ;
20922: LD_EXP 13
20926: IFFALSE 21251
20928: GO 20930
20930: DISABLE
20931: LD_INT 0
20933: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20934: LD_INT 35
20936: PPUSH
20937: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20941: LD_INT 14
20943: PPUSH
20944: LD_INT 22
20946: PUSH
20947: LD_INT 1
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: LD_INT 21
20959: PUSH
20960: LD_INT 3
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PPUSH
20975: CALL_OW 70
20979: PUSH
20980: LD_EXP 15
20984: PUSH
20985: LD_INT 2
20987: PUSH
20988: LD_INT 3
20990: PUSH
20991: LD_INT 4
20993: PUSH
20994: LD_INT 5
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: IN
21003: AND
21004: IFFALSE 21241
// begin powellAnger := powellAnger + 1 ;
21006: LD_ADDR_EXP 17
21010: PUSH
21011: LD_EXP 17
21015: PUSH
21016: LD_INT 1
21018: PLUS
21019: ST_TO_ADDR
// Video ( true ) ;
21020: LD_INT 1
21022: PPUSH
21023: CALL 107945 0 1
// CenterNowOnUnits ( tmp ) ;
21027: LD_VAR 0 1
21031: PPUSH
21032: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21036: LD_INT 14
21038: PPUSH
21039: LD_INT 22
21041: PUSH
21042: LD_INT 1
21044: PUSH
21045: EMPTY
21046: LIST
21047: LIST
21048: PPUSH
21049: CALL_OW 70
21053: PPUSH
21054: LD_INT 86
21056: PPUSH
21057: LD_INT 133
21059: PPUSH
21060: CALL_OW 111
// async ;
21064: ASYNC
// case powellAnger of 1 :
21065: LD_EXP 17
21069: PUSH
21070: LD_INT 1
21072: DOUBLE
21073: EQUAL
21074: IFTRUE 21078
21076: GO 21093
21078: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21079: LD_EXP 61
21083: PPUSH
21084: LD_STRING DBack1-Pow-1
21086: PPUSH
21087: CALL_OW 88
21091: GO 21140
21093: LD_INT 2
21095: DOUBLE
21096: EQUAL
21097: IFTRUE 21101
21099: GO 21116
21101: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21102: LD_EXP 61
21106: PPUSH
21107: LD_STRING DBack2-Pow-1
21109: PPUSH
21110: CALL_OW 88
21114: GO 21140
21116: LD_INT 3
21118: DOUBLE
21119: EQUAL
21120: IFTRUE 21124
21122: GO 21139
21124: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21125: LD_EXP 61
21129: PPUSH
21130: LD_STRING DBack3-Pow-1
21132: PPUSH
21133: CALL_OW 88
21137: GO 21140
21139: POP
// sync ;
21140: SYNC
// repeat wait ( 0 0$1 ) ;
21141: LD_INT 35
21143: PPUSH
21144: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21148: LD_INT 14
21150: PPUSH
21151: LD_INT 22
21153: PUSH
21154: LD_INT 1
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PPUSH
21161: CALL_OW 70
21165: PPUSH
21166: LD_INT 86
21168: PPUSH
21169: LD_INT 133
21171: PPUSH
21172: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21176: LD_INT 14
21178: PPUSH
21179: LD_INT 22
21181: PUSH
21182: LD_INT 1
21184: PUSH
21185: EMPTY
21186: LIST
21187: LIST
21188: PUSH
21189: LD_INT 3
21191: PUSH
21192: LD_INT 21
21194: PUSH
21195: LD_INT 3
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PPUSH
21210: CALL_OW 70
21214: NOT
21215: IFFALSE 21141
// if powellAnger >= 3 then
21217: LD_EXP 17
21221: PUSH
21222: LD_INT 3
21224: GREATEREQUAL
21225: IFFALSE 21234
// YouLost ( Dismissed ) ;
21227: LD_STRING Dismissed
21229: PPUSH
21230: CALL_OW 104
// Video ( false ) ;
21234: LD_INT 0
21236: PPUSH
21237: CALL 107945 0 1
// end ; until missionStage > 5 ;
21241: LD_EXP 15
21245: PUSH
21246: LD_INT 5
21248: GREATER
21249: IFFALSE 20934
// end ;
21251: PPOPN 1
21253: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21254: LD_EXP 13
21258: PUSH
21259: LD_INT 22
21261: PUSH
21262: LD_INT 4
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 21
21271: PUSH
21272: LD_INT 2
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PPUSH
21283: CALL_OW 69
21287: PUSH
21288: LD_INT 4
21290: GREATEREQUAL
21291: AND
21292: PUSH
21293: LD_EXP 15
21297: PUSH
21298: LD_INT 2
21300: EQUAL
21301: AND
21302: IFFALSE 23936
21304: GO 21306
21306: DISABLE
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
21315: PPUSH
21316: PPUSH
21317: PPUSH
21318: PPUSH
21319: PPUSH
// begin missionStage := 3 ;
21320: LD_ADDR_EXP 15
21324: PUSH
21325: LD_INT 3
21327: ST_TO_ADDR
// retreat := false ;
21328: LD_ADDR_VAR 0 4
21332: PUSH
21333: LD_INT 0
21335: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21336: LD_ADDR_VAR 0 5
21340: PUSH
21341: LD_INT 22
21343: PUSH
21344: LD_INT 4
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PUSH
21351: LD_INT 30
21353: PUSH
21354: LD_INT 4
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PPUSH
21365: CALL_OW 69
21369: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21370: LD_ADDR_VAR 0 6
21374: PUSH
21375: LD_INT 22
21377: PUSH
21378: LD_INT 4
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: PUSH
21385: LD_INT 30
21387: PUSH
21388: LD_INT 5
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PPUSH
21399: CALL_OW 69
21403: ST_TO_ADDR
// if not bar then
21404: LD_VAR 0 6
21408: NOT
21409: IFFALSE 21462
// begin repeat wait ( 0 0$1 ) ;
21411: LD_INT 35
21413: PPUSH
21414: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21418: LD_INT 22
21420: PUSH
21421: LD_INT 4
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 57
21433: PUSH
21434: EMPTY
21435: LIST
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 30
21443: PUSH
21444: LD_INT 5
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: LIST
21455: PPUSH
21456: CALL_OW 69
21460: IFFALSE 21411
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21462: LD_ADDR_VAR 0 6
21466: PUSH
21467: LD_INT 22
21469: PUSH
21470: LD_INT 4
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_INT 5
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: PPUSH
21491: CALL_OW 69
21495: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21496: LD_INT 35
21498: PPUSH
21499: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21503: LD_EXP 121
21507: PUSH
21508: LD_INT 4
21510: ARRAY
21511: PUSH
21512: LD_INT 4
21514: GREATEREQUAL
21515: IFFALSE 21496
// tmp := [ ] ;
21517: LD_ADDR_VAR 0 2
21521: PUSH
21522: EMPTY
21523: ST_TO_ADDR
// tmp2 := [ ] ;
21524: LD_ADDR_VAR 0 3
21528: PUSH
21529: EMPTY
21530: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21531: LD_ADDR_VAR 0 1
21535: PUSH
21536: LD_INT 22
21538: PUSH
21539: LD_INT 4
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: LD_INT 2
21548: PUSH
21549: LD_INT 25
21551: PUSH
21552: LD_INT 1
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: LD_INT 25
21561: PUSH
21562: LD_INT 2
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: LD_INT 25
21571: PUSH
21572: LD_INT 3
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: LD_INT 25
21581: PUSH
21582: LD_INT 4
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 5
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PPUSH
21611: CALL_OW 69
21615: PUSH
21616: LD_EXP 61
21620: PUSH
21621: LD_EXP 62
21625: UNION
21626: DIFF
21627: PUSH
21628: FOR_IN
21629: IFFALSE 21691
// if not i in extraSquad then
21631: LD_VAR 0 1
21635: PUSH
21636: LD_EXP 63
21640: IN
21641: NOT
21642: IFFALSE 21666
// tmp := Join ( tmp , i ) else
21644: LD_ADDR_VAR 0 2
21648: PUSH
21649: LD_VAR 0 2
21653: PPUSH
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL 107973 0 2
21663: ST_TO_ADDR
21664: GO 21689
// tmp := Insert ( tmp , 1 , i ) ;
21666: LD_ADDR_VAR 0 2
21670: PUSH
21671: LD_VAR 0 2
21675: PPUSH
21676: LD_INT 1
21678: PPUSH
21679: LD_VAR 0 1
21683: PPUSH
21684: CALL_OW 2
21688: ST_TO_ADDR
21689: GO 21628
21691: POP
21692: POP
// tmp := tmp diff 0 ;
21693: LD_ADDR_VAR 0 2
21697: PUSH
21698: LD_VAR 0 2
21702: PUSH
21703: LD_INT 0
21705: DIFF
21706: ST_TO_ADDR
// p := 0 ;
21707: LD_ADDR_VAR 0 11
21711: PUSH
21712: LD_INT 0
21714: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21715: LD_ADDR_VAR 0 1
21719: PUSH
21720: LD_VAR 0 2
21724: PPUSH
21725: LD_INT 26
21727: PUSH
21728: LD_INT 1
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 72
21739: PUSH
21740: FOR_IN
21741: IFFALSE 21792
// begin p := Inc ( p ) ;
21743: LD_ADDR_VAR 0 11
21747: PUSH
21748: LD_VAR 0 11
21752: PPUSH
21753: CALL 109334 0 1
21757: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_VAR 0 3
21767: PPUSH
21768: LD_VAR 0 1
21772: PPUSH
21773: CALL 107973 0 2
21777: ST_TO_ADDR
// if p = 4 then
21778: LD_VAR 0 11
21782: PUSH
21783: LD_INT 4
21785: EQUAL
21786: IFFALSE 21790
// break ;
21788: GO 21792
// end ;
21790: GO 21740
21792: POP
21793: POP
// tmp := tmp diff tmp2 ;
21794: LD_ADDR_VAR 0 2
21798: PUSH
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: DIFF
21809: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21810: LD_ADDR_VAR 0 2
21814: PUSH
21815: LD_VAR 0 2
21819: PPUSH
21820: LD_INT 3
21822: PPUSH
21823: CALL 106477 0 2
21827: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21828: LD_ADDR_VAR 0 3
21832: PUSH
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 3
21840: PPUSH
21841: CALL 106477 0 2
21845: ST_TO_ADDR
// for i := 1 to 4 do
21846: LD_ADDR_VAR 0 1
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: LD_INT 4
21858: PUSH
21859: FOR_TO
21860: IFFALSE 22026
// begin if tmp2 then
21862: LD_VAR 0 3
21866: IFFALSE 21947
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21868: LD_ADDR_EXP 18
21872: PUSH
21873: LD_EXP 18
21877: PPUSH
21878: LD_INT 1
21880: PPUSH
21881: LD_EXP 18
21885: PUSH
21886: LD_INT 1
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 3
21894: PUSH
21895: LD_VAR 0 3
21899: ARRAY
21900: ADD
21901: PPUSH
21902: CALL_OW 1
21906: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21907: LD_VAR 0 3
21911: PUSH
21912: LD_VAR 0 3
21916: ARRAY
21917: PPUSH
21918: LD_INT 1
21920: PPUSH
21921: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
21925: LD_ADDR_VAR 0 3
21929: PUSH
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_VAR 0 3
21939: PPUSH
21940: CALL_OW 3
21944: ST_TO_ADDR
// end else
21945: GO 22024
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21947: LD_ADDR_EXP 18
21951: PUSH
21952: LD_EXP 18
21956: PPUSH
21957: LD_INT 1
21959: PPUSH
21960: LD_EXP 18
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PUSH
21969: LD_VAR 0 2
21973: PUSH
21974: LD_VAR 0 2
21978: ARRAY
21979: ADD
21980: PPUSH
21981: CALL_OW 1
21985: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21986: LD_VAR 0 2
21990: PUSH
21991: LD_VAR 0 2
21995: ARRAY
21996: PPUSH
21997: LD_INT 1
21999: PPUSH
22000: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22004: LD_ADDR_VAR 0 2
22008: PUSH
22009: LD_VAR 0 2
22013: PPUSH
22014: LD_VAR 0 2
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
// end ; end ;
22024: GO 21859
22026: POP
22027: POP
// if tmp2 then
22028: LD_VAR 0 3
22032: IFFALSE 22050
// tmp := tmp union tmp2 ;
22034: LD_ADDR_VAR 0 2
22038: PUSH
22039: LD_VAR 0 2
22043: PUSH
22044: LD_VAR 0 3
22048: UNION
22049: ST_TO_ADDR
// for i := 0 to 3 do
22050: LD_ADDR_VAR 0 1
22054: PUSH
22055: DOUBLE
22056: LD_INT 0
22058: DEC
22059: ST_TO_ADDR
22060: LD_INT 3
22062: PUSH
22063: FOR_TO
22064: IFFALSE 22227
// begin if not tmp [ tmp - i ] then
22066: LD_VAR 0 2
22070: PUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 1
22080: MINUS
22081: ARRAY
22082: NOT
22083: IFFALSE 22180
// begin uc_side := 4 ;
22085: LD_ADDR_OWVAR 20
22089: PUSH
22090: LD_INT 4
22092: ST_TO_ADDR
// uc_nation := 1 ;
22093: LD_ADDR_OWVAR 21
22097: PUSH
22098: LD_INT 1
22100: ST_TO_ADDR
// InitHc ;
22101: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22105: LD_INT 1
22107: PPUSH
22108: LD_INT 3
22110: PPUSH
22111: CALL_OW 381
// un := CreateHuman ;
22115: LD_ADDR_VAR 0 8
22119: PUSH
22120: CALL_OW 44
22124: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22125: LD_VAR 0 8
22129: PPUSH
22130: LD_INT 39
22132: PPUSH
22133: LD_INT 61
22135: PPUSH
22136: CALL_OW 428
22140: PPUSH
22141: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22145: LD_ADDR_EXP 18
22149: PUSH
22150: LD_EXP 18
22154: PPUSH
22155: LD_INT 2
22157: PPUSH
22158: LD_EXP 18
22162: PUSH
22163: LD_INT 2
22165: ARRAY
22166: PUSH
22167: LD_VAR 0 8
22171: ADD
22172: PPUSH
22173: CALL_OW 1
22177: ST_TO_ADDR
// end else
22178: GO 22225
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22180: LD_ADDR_EXP 18
22184: PUSH
22185: LD_EXP 18
22189: PPUSH
22190: LD_INT 2
22192: PPUSH
22193: LD_EXP 18
22197: PUSH
22198: LD_INT 2
22200: ARRAY
22201: PUSH
22202: LD_VAR 0 2
22206: PUSH
22207: LD_VAR 0 2
22211: PUSH
22212: LD_VAR 0 1
22216: MINUS
22217: ARRAY
22218: ADD
22219: PPUSH
22220: CALL_OW 1
22224: ST_TO_ADDR
// end ;
22225: GO 22063
22227: POP
22228: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22229: LD_ADDR_EXP 102
22233: PUSH
22234: LD_EXP 102
22238: PPUSH
22239: LD_INT 4
22241: PPUSH
22242: LD_EXP 102
22246: PUSH
22247: LD_INT 4
22249: ARRAY
22250: PUSH
22251: LD_EXP 18
22255: PUSH
22256: LD_INT 1
22258: ARRAY
22259: DIFF
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22266: LD_VAR 0 5
22270: PUSH
22271: LD_INT 1
22273: ARRAY
22274: PPUSH
22275: CALL_OW 313
22279: IFFALSE 22334
// begin for i in UnitsInside ( arm [ 1 ] ) do
22281: LD_ADDR_VAR 0 1
22285: PUSH
22286: LD_VAR 0 5
22290: PUSH
22291: LD_INT 1
22293: ARRAY
22294: PPUSH
22295: CALL_OW 313
22299: PUSH
22300: FOR_IN
22301: IFFALSE 22332
// begin ComExitBuilding ( i ) ;
22303: LD_VAR 0 1
22307: PPUSH
22308: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22312: LD_VAR 0 1
22316: PPUSH
22317: LD_VAR 0 6
22321: PUSH
22322: LD_INT 1
22324: ARRAY
22325: PPUSH
22326: CALL_OW 180
// end ;
22330: GO 22300
22332: POP
22333: POP
// end ; wait ( 0 0$5 ) ;
22334: LD_INT 175
22336: PPUSH
22337: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22341: LD_INT 35
22343: PPUSH
22344: CALL_OW 67
22348: LD_EXP 18
22352: PUSH
22353: LD_INT 1
22355: ARRAY
22356: PPUSH
22357: LD_INT 55
22359: PUSH
22360: EMPTY
22361: LIST
22362: PPUSH
22363: CALL_OW 72
22367: NOT
22368: IFFALSE 22341
// for i in powellSquadAttack [ 1 ] do
22370: LD_ADDR_VAR 0 1
22374: PUSH
22375: LD_EXP 18
22379: PUSH
22380: LD_INT 1
22382: ARRAY
22383: PUSH
22384: FOR_IN
22385: IFFALSE 22492
// begin if IsInUnit ( i ) then
22387: LD_VAR 0 1
22391: PPUSH
22392: CALL_OW 310
22396: IFFALSE 22407
// ComExitBuilding ( i ) ;
22398: LD_VAR 0 1
22402: PPUSH
22403: CALL_OW 122
// if GetClass ( i ) <> 1 then
22407: LD_VAR 0 1
22411: PPUSH
22412: CALL_OW 257
22416: PUSH
22417: LD_INT 1
22419: NONEQUAL
22420: IFFALSE 22461
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 5
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PPUSH
22436: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22440: LD_VAR 0 1
22444: PPUSH
22445: LD_INT 1
22447: PPUSH
22448: CALL_OW 183
// AddComExitBuilding ( i ) ;
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22461: LD_VAR 0 1
22465: PPUSH
22466: LD_INT 60
22468: PPUSH
22469: LD_INT 94
22471: PPUSH
22472: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22476: LD_VAR 0 1
22480: PPUSH
22481: LD_EXP 61
22485: PPUSH
22486: CALL_OW 179
// end ;
22490: GO 22384
22492: POP
22493: POP
// wait ( 0 0$45 ) ;
22494: LD_INT 1575
22496: PPUSH
22497: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22501: LD_EXP 61
22505: PPUSH
22506: LD_STRING D4-Pow-1
22508: PPUSH
22509: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22513: LD_ADDR_VAR 0 2
22517: PUSH
22518: LD_EXP 18
22522: PUSH
22523: LD_INT 1
22525: ARRAY
22526: PPUSH
22527: LD_INT 26
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 72
22541: ST_TO_ADDR
// if tmp then
22542: LD_VAR 0 2
22546: IFFALSE 22564
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22548: LD_VAR 0 2
22552: PUSH
22553: LD_INT 1
22555: ARRAY
22556: PPUSH
22557: LD_STRING D4-Sol1-1
22559: PPUSH
22560: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22564: LD_EXP 61
22568: PPUSH
22569: LD_STRING D4-Pow-2
22571: PPUSH
22572: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22576: LD_ADDR_VAR 0 1
22580: PUSH
22581: DOUBLE
22582: LD_INT 1
22584: DEC
22585: ST_TO_ADDR
22586: LD_EXP 18
22590: PUSH
22591: LD_INT 1
22593: ARRAY
22594: PUSH
22595: FOR_TO
22596: IFFALSE 22689
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22598: LD_EXP 18
22602: PUSH
22603: LD_INT 1
22605: ARRAY
22606: PUSH
22607: LD_VAR 0 1
22611: ARRAY
22612: PPUSH
22613: LD_EXP 121
22617: PUSH
22618: LD_INT 4
22620: ARRAY
22621: PUSH
22622: LD_INT 1
22624: ARRAY
22625: PPUSH
22626: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22630: LD_ADDR_EXP 121
22634: PUSH
22635: LD_EXP 121
22639: PPUSH
22640: LD_INT 4
22642: PPUSH
22643: LD_EXP 121
22647: PUSH
22648: LD_INT 4
22650: ARRAY
22651: PPUSH
22652: LD_INT 1
22654: PPUSH
22655: CALL_OW 3
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22665: LD_INT 8
22667: PPUSH
22668: LD_EXP 18
22672: PUSH
22673: LD_INT 1
22675: ARRAY
22676: PUSH
22677: LD_VAR 0 1
22681: ARRAY
22682: PPUSH
22683: CALL_OW 471
// end ;
22687: GO 22595
22689: POP
22690: POP
// repeat wait ( 0 0$1 ) ;
22691: LD_INT 35
22693: PPUSH
22694: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22698: LD_EXP 18
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PPUSH
22707: LD_INT 55
22709: PUSH
22710: EMPTY
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_INT 4
22720: GREATEREQUAL
22721: IFFALSE 22691
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22723: LD_EXP 18
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: PPUSH
22732: LD_INT 69
22734: PPUSH
22735: LD_INT 94
22737: PPUSH
22738: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22742: LD_EXP 18
22746: PUSH
22747: LD_INT 1
22749: ARRAY
22750: PPUSH
22751: LD_INT 82
22753: PPUSH
22754: LD_INT 83
22756: PPUSH
22757: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22761: LD_EXP 18
22765: PUSH
22766: LD_INT 1
22768: ARRAY
22769: PPUSH
22770: LD_INT 77
22772: PPUSH
22773: LD_INT 69
22775: PPUSH
22776: CALL_OW 174
// repeat wait ( 3 ) ;
22780: LD_INT 3
22782: PPUSH
22783: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22787: LD_ADDR_VAR 0 1
22791: PUSH
22792: LD_EXP 18
22796: PUSH
22797: LD_INT 1
22799: ARRAY
22800: PUSH
22801: FOR_IN
22802: IFFALSE 22938
// begin if GetLives ( i ) < 990 then
22804: LD_VAR 0 1
22808: PPUSH
22809: CALL_OW 256
22813: PUSH
22814: LD_INT 990
22816: LESS
22817: IFFALSE 22831
// SetLives ( i , 1000 ) ;
22819: LD_VAR 0 1
22823: PPUSH
22824: LD_INT 1000
22826: PPUSH
22827: CALL_OW 234
// if not IsInUnit ( i ) then
22831: LD_VAR 0 1
22835: PPUSH
22836: CALL_OW 310
22840: NOT
22841: IFFALSE 22936
// begin if not HasTask ( i ) then
22843: LD_VAR 0 1
22847: PPUSH
22848: CALL_OW 314
22852: NOT
22853: IFFALSE 22870
// ComMoveXY ( i , 64 , 93 ) ;
22855: LD_VAR 0 1
22859: PPUSH
22860: LD_INT 64
22862: PPUSH
22863: LD_INT 93
22865: PPUSH
22866: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22870: LD_VAR 0 4
22874: NOT
22875: PUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 258
22885: PUSH
22886: LD_INT 1
22888: EQUAL
22889: AND
22890: IFFALSE 22936
// begin retreat := true ;
22892: LD_ADDR_VAR 0 4
22896: PUSH
22897: LD_INT 1
22899: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22900: LD_VAR 0 1
22904: PPUSH
22905: LD_INT 2
22907: PPUSH
22908: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22912: LD_VAR 0 1
22916: PPUSH
22917: LD_STRING D4a-Sol1-1
22919: PPUSH
22920: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22924: LD_EXP 61
22928: PPUSH
22929: LD_STRING D4a-Pow-1
22931: PPUSH
22932: CALL_OW 88
// end ; end ; end ;
22936: GO 22801
22938: POP
22939: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22940: LD_EXP 18
22944: PUSH
22945: LD_INT 1
22947: ARRAY
22948: PPUSH
22949: LD_INT 95
22951: PUSH
22952: LD_INT 9
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: PUSH
22959: LD_INT 3
22961: PUSH
22962: LD_INT 55
22964: PUSH
22965: EMPTY
22966: LIST
22967: PUSH
22968: EMPTY
22969: LIST
22970: LIST
22971: PUSH
22972: EMPTY
22973: LIST
22974: LIST
22975: PPUSH
22976: CALL_OW 72
22980: PUSH
22981: LD_INT 4
22983: GREATEREQUAL
22984: IFFALSE 22780
// for i in powellSquadAttack [ 1 ] do
22986: LD_ADDR_VAR 0 1
22990: PUSH
22991: LD_EXP 18
22995: PUSH
22996: LD_INT 1
22998: ARRAY
22999: PUSH
23000: FOR_IN
23001: IFFALSE 23137
// begin if GetTag ( i ) = 2 then
23003: LD_VAR 0 1
23007: PPUSH
23008: CALL_OW 110
23012: PUSH
23013: LD_INT 2
23015: EQUAL
23016: IFFALSE 23078
// begin ComMoveXY ( i , 60 , 94 ) ;
23018: LD_VAR 0 1
23022: PPUSH
23023: LD_INT 60
23025: PPUSH
23026: LD_INT 94
23028: PPUSH
23029: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23033: LD_VAR 0 1
23037: PPUSH
23038: LD_EXP 61
23042: PPUSH
23043: CALL_OW 179
// wait ( 0 0$3 ) ;
23047: LD_INT 105
23049: PPUSH
23050: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23054: LD_VAR 0 1
23058: PPUSH
23059: LD_STRING D4a-Sol1-2
23061: PPUSH
23062: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23066: LD_EXP 61
23070: PPUSH
23071: LD_STRING D4a-Pow-2
23073: PPUSH
23074: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23078: LD_VAR 0 1
23082: PPUSH
23083: LD_INT 0
23085: PPUSH
23086: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23090: LD_ADDR_EXP 102
23094: PUSH
23095: LD_EXP 102
23099: PPUSH
23100: LD_INT 4
23102: PPUSH
23103: LD_EXP 102
23107: PUSH
23108: LD_INT 4
23110: ARRAY
23111: PUSH
23112: LD_VAR 0 1
23116: UNION
23117: PPUSH
23118: CALL_OW 1
23122: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23123: LD_INT 8
23125: PPUSH
23126: LD_VAR 0 1
23130: PPUSH
23131: CALL_OW 472
// end ;
23135: GO 23000
23137: POP
23138: POP
// wait ( 2 2$00 ) ;
23139: LD_INT 4200
23141: PPUSH
23142: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23146: LD_ADDR_VAR 0 9
23150: PUSH
23151: LD_INT 22
23153: PUSH
23154: LD_INT 4
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PUSH
23161: LD_INT 30
23163: PUSH
23164: LD_INT 32
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: PUSH
23171: LD_INT 58
23173: PUSH
23174: EMPTY
23175: LIST
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: LIST
23181: PPUSH
23182: CALL_OW 69
23186: ST_TO_ADDR
// if tmp then
23187: LD_VAR 0 2
23191: IFFALSE 23431
// begin for i := 1 to tmp do
23193: LD_ADDR_VAR 0 1
23197: PUSH
23198: DOUBLE
23199: LD_INT 1
23201: DEC
23202: ST_TO_ADDR
23203: LD_VAR 0 2
23207: PUSH
23208: FOR_TO
23209: IFFALSE 23422
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23211: LD_ADDR_EXP 102
23215: PUSH
23216: LD_EXP 102
23220: PPUSH
23221: LD_INT 4
23223: PPUSH
23224: LD_EXP 102
23228: PUSH
23229: LD_INT 4
23231: ARRAY
23232: PUSH
23233: LD_VAR 0 2
23237: PUSH
23238: LD_VAR 0 1
23242: ARRAY
23243: DIFF
23244: PPUSH
23245: CALL_OW 1
23249: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23250: LD_ADDR_VAR 0 10
23254: PUSH
23255: LD_VAR 0 2
23259: PUSH
23260: LD_VAR 0 1
23264: ARRAY
23265: PPUSH
23266: CALL_OW 310
23270: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23271: LD_VAR 0 10
23275: PUSH
23276: LD_VAR 0 10
23280: PPUSH
23281: CALL_OW 266
23285: PUSH
23286: LD_INT 32
23288: EQUAL
23289: AND
23290: IFFALSE 23294
// continue ;
23292: GO 23208
// if t then
23294: LD_VAR 0 10
23298: IFFALSE 23315
// ComExitBuilding ( tmp [ i ] ) ;
23300: LD_VAR 0 2
23304: PUSH
23305: LD_VAR 0 1
23309: ARRAY
23310: PPUSH
23311: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23315: LD_VAR 0 2
23319: PUSH
23320: LD_VAR 0 1
23324: ARRAY
23325: PPUSH
23326: LD_VAR 0 5
23330: PUSH
23331: LD_INT 1
23333: ARRAY
23334: PPUSH
23335: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23339: LD_VAR 0 2
23343: PUSH
23344: LD_VAR 0 1
23348: ARRAY
23349: PPUSH
23350: LD_INT 1
23352: PPUSH
23353: CALL_OW 183
// if emptyTowers then
23357: LD_VAR 0 9
23361: IFFALSE 23420
// begin AddComExitBuilding ( tmp [ i ] ) ;
23363: LD_VAR 0 2
23367: PUSH
23368: LD_VAR 0 1
23372: ARRAY
23373: PPUSH
23374: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23378: LD_VAR 0 2
23382: PUSH
23383: LD_VAR 0 1
23387: ARRAY
23388: PPUSH
23389: LD_VAR 0 9
23393: PUSH
23394: LD_INT 1
23396: ARRAY
23397: PPUSH
23398: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23402: LD_ADDR_VAR 0 9
23406: PUSH
23407: LD_VAR 0 9
23411: PPUSH
23412: LD_INT 1
23414: PPUSH
23415: CALL_OW 3
23419: ST_TO_ADDR
// end ; end ;
23420: GO 23208
23422: POP
23423: POP
// wait ( 0 0$30 ) ;
23424: LD_INT 1050
23426: PPUSH
23427: CALL_OW 67
// end ; uc_side := 6 ;
23431: LD_ADDR_OWVAR 20
23435: PUSH
23436: LD_INT 6
23438: ST_TO_ADDR
// uc_nation := 3 ;
23439: LD_ADDR_OWVAR 21
23443: PUSH
23444: LD_INT 3
23446: ST_TO_ADDR
// ru := [ ] ;
23447: LD_ADDR_VAR 0 7
23451: PUSH
23452: EMPTY
23453: ST_TO_ADDR
// for i = 1 to 5 do
23454: LD_ADDR_VAR 0 1
23458: PUSH
23459: DOUBLE
23460: LD_INT 1
23462: DEC
23463: ST_TO_ADDR
23464: LD_INT 5
23466: PUSH
23467: FOR_TO
23468: IFFALSE 23588
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23470: LD_INT 22
23472: PUSH
23473: LD_INT 23
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: PUSH
23480: LD_INT 1
23482: PPUSH
23483: LD_INT 2
23485: PPUSH
23486: CALL_OW 12
23490: ARRAY
23491: PPUSH
23492: LD_INT 1
23494: PPUSH
23495: LD_INT 3
23497: PPUSH
23498: LD_INT 43
23500: PUSH
23501: LD_INT 44
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 1
23510: PPUSH
23511: LD_INT 2
23513: PPUSH
23514: CALL_OW 12
23518: ARRAY
23519: PPUSH
23520: LD_INT 89
23522: PPUSH
23523: CALL 75122 0 5
// un := CreateVehicle ;
23527: LD_ADDR_VAR 0 8
23531: PUSH
23532: CALL_OW 45
23536: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_INT 4
23544: PPUSH
23545: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23549: LD_VAR 0 8
23553: PPUSH
23554: LD_INT 136
23556: PPUSH
23557: LD_INT 90
23559: PPUSH
23560: LD_INT 8
23562: PPUSH
23563: LD_INT 0
23565: PPUSH
23566: CALL_OW 50
// ru := ru ^ un ;
23570: LD_ADDR_VAR 0 7
23574: PUSH
23575: LD_VAR 0 7
23579: PUSH
23580: LD_VAR 0 8
23584: ADD
23585: ST_TO_ADDR
// end ;
23586: GO 23467
23588: POP
23589: POP
// if ru then
23590: LD_VAR 0 7
23594: IFFALSE 23611
// ComAgressiveMove ( ru , 57 , 94 ) ;
23596: LD_VAR 0 7
23600: PPUSH
23601: LD_INT 57
23603: PPUSH
23604: LD_INT 94
23606: PPUSH
23607: CALL_OW 114
// wait ( 3 3$00 ) ;
23611: LD_INT 6300
23613: PPUSH
23614: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23618: LD_ADDR_VAR 0 11
23622: PUSH
23623: LD_INT 54
23625: PPUSH
23626: LD_INT 85
23628: PPUSH
23629: CALL_OW 428
23633: PPUSH
23634: CALL_OW 313
23638: ST_TO_ADDR
// t := 0 ;
23639: LD_ADDR_VAR 0 10
23643: PUSH
23644: LD_INT 0
23646: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23647: LD_ADDR_VAR 0 1
23651: PUSH
23652: LD_INT 22
23654: PUSH
23655: LD_INT 4
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: PUSH
23662: LD_INT 3
23664: PUSH
23665: LD_INT 58
23667: PUSH
23668: EMPTY
23669: LIST
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: LD_INT 30
23677: PUSH
23678: LD_INT 32
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: LIST
23689: PPUSH
23690: CALL_OW 69
23694: PUSH
23695: FOR_IN
23696: IFFALSE 23822
// begin if p + t > 5 then
23698: LD_VAR 0 11
23702: PUSH
23703: LD_VAR 0 10
23707: PLUS
23708: PUSH
23709: LD_INT 5
23711: GREATER
23712: IFFALSE 23716
// break ;
23714: GO 23822
// un := UnitsInside ( i ) ;
23716: LD_ADDR_VAR 0 8
23720: PUSH
23721: LD_VAR 0 1
23725: PPUSH
23726: CALL_OW 313
23730: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23731: LD_VAR 0 8
23735: PPUSH
23736: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23740: LD_VAR 0 8
23744: PPUSH
23745: LD_INT 54
23747: PPUSH
23748: LD_INT 85
23750: PPUSH
23751: CALL_OW 428
23755: PPUSH
23756: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23760: LD_VAR 0 8
23764: PPUSH
23765: LD_INT 3
23767: PPUSH
23768: CALL_OW 183
// t := Inc ( t ) ;
23772: LD_ADDR_VAR 0 10
23776: PUSH
23777: LD_VAR 0 10
23781: PPUSH
23782: CALL 109334 0 1
23786: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23787: LD_ADDR_EXP 102
23791: PUSH
23792: LD_EXP 102
23796: PPUSH
23797: LD_INT 4
23799: PPUSH
23800: LD_EXP 102
23804: PUSH
23805: LD_INT 4
23807: ARRAY
23808: PUSH
23809: LD_VAR 0 8
23813: ADD
23814: PPUSH
23815: CALL_OW 1
23819: ST_TO_ADDR
// end ;
23820: GO 23695
23822: POP
23823: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23824: LD_INT 4
23826: PPUSH
23827: LD_INT 3
23829: PUSH
23830: LD_INT 1
23832: PUSH
23833: LD_INT 1
23835: PUSH
23836: LD_INT 5
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: LIST
23843: LIST
23844: PUSH
23845: LD_INT 4
23847: PUSH
23848: LD_INT 1
23850: PUSH
23851: LD_INT 1
23853: PUSH
23854: LD_INT 6
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: LIST
23861: LIST
23862: PUSH
23863: LD_INT 4
23865: PUSH
23866: LD_INT 1
23868: PUSH
23869: LD_INT 1
23871: PUSH
23872: LD_INT 7
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 3
23883: PUSH
23884: LD_INT 1
23886: PUSH
23887: LD_INT 1
23889: PUSH
23890: LD_INT 7
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: PUSH
23899: LD_INT 3
23901: PUSH
23902: LD_INT 1
23904: PUSH
23905: LD_INT 1
23907: PUSH
23908: LD_INT 5
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: PPUSH
23924: CALL 63808 0 2
// missionStage := 4 ;
23928: LD_ADDR_EXP 15
23932: PUSH
23933: LD_INT 4
23935: ST_TO_ADDR
// end ;
23936: PPOPN 11
23938: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23939: LD_EXP 15
23943: PUSH
23944: LD_INT 4
23946: EQUAL
23947: PUSH
23948: LD_INT 22
23950: PUSH
23951: LD_INT 4
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 21
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: PPUSH
23972: CALL_OW 69
23976: PUSH
23977: LD_INT 5
23979: GREATEREQUAL
23980: AND
23981: IFFALSE 28345
23983: GO 23985
23985: DISABLE
23986: LD_INT 0
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
23997: PPUSH
23998: PPUSH
23999: PPUSH
24000: PPUSH
24001: PPUSH
// begin wait ( 0 0$10 ) ;
24002: LD_INT 350
24004: PPUSH
24005: CALL_OW 67
// missionStage := 5 ;
24009: LD_ADDR_EXP 15
24013: PUSH
24014: LD_INT 5
24016: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24017: LD_ADDR_VAR 0 11
24021: PUSH
24022: LD_INT 22
24024: PUSH
24025: LD_INT 4
24027: PUSH
24028: EMPTY
24029: LIST
24030: LIST
24031: PUSH
24032: LD_INT 2
24034: PUSH
24035: LD_INT 30
24037: PUSH
24038: LD_INT 4
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: PUSH
24045: LD_INT 30
24047: PUSH
24048: LD_INT 5
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: LIST
24059: PUSH
24060: EMPTY
24061: LIST
24062: LIST
24063: PPUSH
24064: CALL_OW 69
24068: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24069: LD_ADDR_VAR 0 6
24073: PUSH
24074: LD_INT 22
24076: PUSH
24077: LD_INT 4
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 21
24086: PUSH
24087: LD_INT 1
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: LD_INT 3
24096: PUSH
24097: LD_INT 25
24099: PUSH
24100: LD_INT 16
24102: PUSH
24103: EMPTY
24104: LIST
24105: LIST
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: LD_INT 3
24113: PUSH
24114: LD_INT 25
24116: PUSH
24117: LD_INT 12
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: PPUSH
24134: CALL_OW 69
24138: PUSH
24139: LD_EXP 61
24143: DIFF
24144: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24145: LD_ADDR_VAR 0 10
24149: PUSH
24150: LD_INT 22
24152: PUSH
24153: LD_INT 4
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: LD_INT 30
24162: PUSH
24163: LD_INT 3
24165: PUSH
24166: EMPTY
24167: LIST
24168: LIST
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PPUSH
24174: CALL_OW 69
24178: PUSH
24179: LD_INT 1
24181: ARRAY
24182: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24183: LD_INT 350
24185: PPUSH
24186: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24190: LD_EXP 121
24194: PUSH
24195: LD_INT 4
24197: ARRAY
24198: PUSH
24199: LD_INT 5
24201: LESS
24202: PUSH
24203: LD_VAR 0 10
24207: PPUSH
24208: CALL_OW 461
24212: PUSH
24213: LD_INT 2
24215: EQUAL
24216: AND
24217: IFFALSE 24247
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24219: LD_INT 4
24221: PPUSH
24222: LD_INT 3
24224: PUSH
24225: LD_INT 1
24227: PUSH
24228: LD_INT 1
24230: PUSH
24231: LD_INT 5
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: LIST
24238: LIST
24239: PUSH
24240: EMPTY
24241: LIST
24242: PPUSH
24243: CALL 63856 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24247: LD_EXP 121
24251: PUSH
24252: LD_INT 4
24254: ARRAY
24255: PUSH
24256: LD_INT 5
24258: GREATEREQUAL
24259: PUSH
24260: LD_EXP 121
24264: PUSH
24265: LD_INT 4
24267: ARRAY
24268: PPUSH
24269: LD_INT 58
24271: PUSH
24272: EMPTY
24273: LIST
24274: PPUSH
24275: CALL_OW 72
24279: PUSH
24280: LD_INT 5
24282: GREATEREQUAL
24283: AND
24284: IFFALSE 24183
// powellAllowRetreat := false ;
24286: LD_ADDR_EXP 19
24290: PUSH
24291: LD_INT 0
24293: ST_TO_ADDR
// activeAttacks := false ;
24294: LD_ADDR_EXP 16
24298: PUSH
24299: LD_INT 0
24301: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24302: LD_INT 35
24304: PPUSH
24305: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24309: LD_INT 22
24311: PUSH
24312: LD_INT 6
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PPUSH
24319: CALL_OW 69
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: IFFALSE 24302
// tmp := mc_vehicles [ 4 ] ;
24329: LD_ADDR_VAR 0 3
24333: PUSH
24334: LD_EXP 121
24338: PUSH
24339: LD_INT 4
24341: ARRAY
24342: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24343: LD_ADDR_VAR 0 1
24347: PUSH
24348: DOUBLE
24349: LD_INT 1
24351: DEC
24352: ST_TO_ADDR
24353: LD_EXP 18
24357: PUSH
24358: FOR_TO
24359: IFFALSE 24681
// begin for j in powellSquadAttack [ i ] do
24361: LD_ADDR_VAR 0 2
24365: PUSH
24366: LD_EXP 18
24370: PUSH
24371: LD_VAR 0 1
24375: ARRAY
24376: PUSH
24377: FOR_IN
24378: IFFALSE 24677
// begin if j in mc_bases [ 4 ] then
24380: LD_VAR 0 2
24384: PUSH
24385: LD_EXP 102
24389: PUSH
24390: LD_INT 4
24392: ARRAY
24393: IN
24394: IFFALSE 24429
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24396: LD_ADDR_EXP 102
24400: PUSH
24401: LD_EXP 102
24405: PPUSH
24406: LD_INT 4
24408: PPUSH
24409: LD_EXP 102
24413: PUSH
24414: LD_INT 4
24416: ARRAY
24417: PUSH
24418: LD_VAR 0 2
24422: DIFF
24423: PPUSH
24424: CALL_OW 1
24428: ST_TO_ADDR
// forces := forces diff j ;
24429: LD_ADDR_VAR 0 6
24433: PUSH
24434: LD_VAR 0 6
24438: PUSH
24439: LD_VAR 0 2
24443: DIFF
24444: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24445: LD_VAR 0 2
24449: PPUSH
24450: LD_INT 1
24452: PPUSH
24453: CALL_OW 109
// wait ( 0 0$2 ) ;
24457: LD_INT 70
24459: PPUSH
24460: CALL_OW 67
// if IsInUnit ( j ) then
24464: LD_VAR 0 2
24468: PPUSH
24469: CALL_OW 310
24473: IFFALSE 24484
// ComExitBuilding ( j ) ;
24475: LD_VAR 0 2
24479: PPUSH
24480: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24484: LD_VAR 0 2
24488: PPUSH
24489: CALL_OW 257
24493: PUSH
24494: LD_INT 1
24496: NONEQUAL
24497: PUSH
24498: LD_VAR 0 2
24502: PPUSH
24503: CALL_OW 314
24507: NOT
24508: AND
24509: IFFALSE 24589
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24511: LD_VAR 0 11
24515: PUSH
24516: LD_INT 1
24518: ARRAY
24519: PPUSH
24520: CALL_OW 313
24524: PUSH
24525: LD_INT 5
24527: GREATEREQUAL
24528: IFFALSE 24550
// ComEnterUnit ( j , arm [ 2 ] ) else
24530: LD_VAR 0 2
24534: PPUSH
24535: LD_VAR 0 11
24539: PUSH
24540: LD_INT 2
24542: ARRAY
24543: PPUSH
24544: CALL_OW 120
24548: GO 24568
// ComEnterUnit ( j , arm [ 1 ] ) ;
24550: LD_VAR 0 2
24554: PPUSH
24555: LD_VAR 0 11
24559: PUSH
24560: LD_INT 1
24562: ARRAY
24563: PPUSH
24564: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24568: LD_VAR 0 2
24572: PPUSH
24573: LD_INT 1
24575: PPUSH
24576: CALL_OW 183
// AddComExitBuilding ( j ) ;
24580: LD_VAR 0 2
24584: PPUSH
24585: CALL_OW 182
// end ; if i = 2 then
24589: LD_VAR 0 1
24593: PUSH
24594: LD_INT 2
24596: EQUAL
24597: IFFALSE 24614
// AddComMoveXY ( j , 61 , 93 ) ;
24599: LD_VAR 0 2
24603: PPUSH
24604: LD_INT 61
24606: PPUSH
24607: LD_INT 93
24609: PPUSH
24610: CALL_OW 171
// if i = 1 then
24614: LD_VAR 0 1
24618: PUSH
24619: LD_INT 1
24621: EQUAL
24622: IFFALSE 24675
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24624: LD_VAR 0 2
24628: PPUSH
24629: LD_VAR 0 3
24633: PUSH
24634: LD_INT 1
24636: ARRAY
24637: PPUSH
24638: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24642: LD_ADDR_VAR 0 3
24646: PUSH
24647: LD_VAR 0 3
24651: PPUSH
24652: LD_INT 1
24654: PPUSH
24655: CALL_OW 3
24659: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24660: LD_VAR 0 2
24664: PPUSH
24665: LD_INT 69
24667: PPUSH
24668: LD_INT 94
24670: PPUSH
24671: CALL_OW 171
// end ; end ;
24675: GO 24377
24677: POP
24678: POP
// end ;
24679: GO 24358
24681: POP
24682: POP
// wait ( 0 0$30 ) ;
24683: LD_INT 1050
24685: PPUSH
24686: CALL_OW 67
// MC_Kill ( 4 ) ;
24690: LD_INT 4
24692: PPUSH
24693: CALL 39831 0 1
// tmp := UnitsInside ( fac ) ;
24697: LD_ADDR_VAR 0 3
24701: PUSH
24702: LD_VAR 0 10
24706: PPUSH
24707: CALL_OW 313
24711: ST_TO_ADDR
// if tmp then
24712: LD_VAR 0 3
24716: IFFALSE 24837
// for i in tmp do
24718: LD_ADDR_VAR 0 1
24722: PUSH
24723: LD_VAR 0 3
24727: PUSH
24728: FOR_IN
24729: IFFALSE 24835
// begin ComExitBuilding ( i ) ;
24731: LD_VAR 0 1
24735: PPUSH
24736: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24740: LD_VAR 0 11
24744: PUSH
24745: LD_INT 2
24747: ARRAY
24748: PPUSH
24749: CALL_OW 313
24753: PUSH
24754: LD_INT 6
24756: LESS
24757: IFFALSE 24779
// AddComEnterUnit ( i , arm [ 2 ] ) else
24759: LD_VAR 0 1
24763: PPUSH
24764: LD_VAR 0 11
24768: PUSH
24769: LD_INT 2
24771: ARRAY
24772: PPUSH
24773: CALL_OW 180
24777: GO 24833
// if UnitsInside ( arm [ 1 ] ) < 6 then
24779: LD_VAR 0 11
24783: PUSH
24784: LD_INT 1
24786: ARRAY
24787: PPUSH
24788: CALL_OW 313
24792: PUSH
24793: LD_INT 6
24795: LESS
24796: IFFALSE 24818
// AddComEnterUnit ( i , arm [ 1 ] ) else
24798: LD_VAR 0 1
24802: PPUSH
24803: LD_VAR 0 11
24807: PUSH
24808: LD_INT 1
24810: ARRAY
24811: PPUSH
24812: CALL_OW 180
24816: GO 24833
// AddComMoveXY ( i , 37 , 68 ) ;
24818: LD_VAR 0 1
24822: PPUSH
24823: LD_INT 37
24825: PPUSH
24826: LD_INT 68
24828: PPUSH
24829: CALL_OW 171
// end ;
24833: GO 24728
24835: POP
24836: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24837: LD_ADDR_VAR 0 12
24841: PUSH
24842: LD_VAR 0 6
24846: PPUSH
24847: LD_INT 26
24849: PUSH
24850: LD_INT 1
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PPUSH
24857: CALL_OW 72
24861: PUSH
24862: LD_EXP 62
24866: DIFF
24867: ST_TO_ADDR
// if not speaker then
24868: LD_VAR 0 12
24872: NOT
24873: IFFALSE 24900
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24875: LD_ADDR_VAR 0 12
24879: PUSH
24880: LD_VAR 0 6
24884: PPUSH
24885: LD_INT 26
24887: PUSH
24888: LD_INT 1
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PPUSH
24895: CALL_OW 72
24899: ST_TO_ADDR
// if speaker then
24900: LD_VAR 0 12
24904: IFFALSE 24920
// speaker := speaker [ 1 ] ;
24906: LD_ADDR_VAR 0 12
24910: PUSH
24911: LD_VAR 0 12
24915: PUSH
24916: LD_INT 1
24918: ARRAY
24919: ST_TO_ADDR
// Video ( true ) ;
24920: LD_INT 1
24922: PPUSH
24923: CALL 107945 0 1
// CenterNowOnUnits ( Powell ) ;
24927: LD_EXP 61
24931: PPUSH
24932: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24936: LD_ADDR_VAR 0 3
24940: PUSH
24941: LD_VAR 0 6
24945: PPUSH
24946: LD_INT 3
24948: PUSH
24949: LD_INT 25
24951: PUSH
24952: LD_INT 1
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PPUSH
24963: CALL_OW 72
24967: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24968: LD_ADDR_VAR 0 13
24972: PUSH
24973: LD_INT 22
24975: PUSH
24976: LD_INT 4
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PUSH
24983: LD_INT 30
24985: PUSH
24986: LD_INT 32
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 58
24995: PUSH
24996: EMPTY
24997: LIST
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: LIST
25003: PPUSH
25004: CALL_OW 69
25008: ST_TO_ADDR
// t := Count ( tmp ) ;
25009: LD_ADDR_VAR 0 7
25013: PUSH
25014: LD_VAR 0 3
25018: PPUSH
25019: CALL 72384 0 1
25023: ST_TO_ADDR
// if t > 4 then
25024: LD_VAR 0 7
25028: PUSH
25029: LD_INT 4
25031: GREATER
25032: IFFALSE 25042
// t := 4 ;
25034: LD_ADDR_VAR 0 7
25038: PUSH
25039: LD_INT 4
25041: ST_TO_ADDR
// for i := 1 to t do
25042: LD_ADDR_VAR 0 1
25046: PUSH
25047: DOUBLE
25048: LD_INT 1
25050: DEC
25051: ST_TO_ADDR
25052: LD_VAR 0 7
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25204
// begin if IsInUnit ( tmp [ i ] ) then
25060: LD_VAR 0 3
25064: PUSH
25065: LD_VAR 0 1
25069: ARRAY
25070: PPUSH
25071: CALL_OW 310
25075: IFFALSE 25092
// ComExitBuilding ( tmp [ i ] ) ;
25077: LD_VAR 0 3
25081: PUSH
25082: LD_VAR 0 1
25086: ARRAY
25087: PPUSH
25088: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25092: LD_VAR 0 3
25096: PUSH
25097: LD_VAR 0 1
25101: ARRAY
25102: PPUSH
25103: LD_VAR 0 11
25107: PUSH
25108: LD_INT 1
25110: ARRAY
25111: PPUSH
25112: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25116: LD_VAR 0 3
25120: PUSH
25121: LD_VAR 0 1
25125: ARRAY
25126: PPUSH
25127: LD_INT 1
25129: PPUSH
25130: CALL_OW 183
// if Count ( emp_towers ) then
25134: LD_VAR 0 13
25138: PPUSH
25139: CALL 72384 0 1
25143: IFFALSE 25202
// begin AddComExitBuilding ( tmp [ i ] ) ;
25145: LD_VAR 0 3
25149: PUSH
25150: LD_VAR 0 1
25154: ARRAY
25155: PPUSH
25156: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25160: LD_VAR 0 3
25164: PUSH
25165: LD_VAR 0 1
25169: ARRAY
25170: PPUSH
25171: LD_VAR 0 13
25175: PUSH
25176: LD_INT 1
25178: ARRAY
25179: PPUSH
25180: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25184: LD_ADDR_VAR 0 13
25188: PUSH
25189: LD_VAR 0 13
25193: PPUSH
25194: LD_INT 1
25196: PPUSH
25197: CALL_OW 3
25201: ST_TO_ADDR
// end ; end ;
25202: GO 25057
25204: POP
25205: POP
// wait ( 0 0$5 ) ;
25206: LD_INT 175
25208: PPUSH
25209: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25213: LD_VAR 0 3
25217: PPUSH
25218: LD_INT 3
25220: PUSH
25221: LD_INT 54
25223: PUSH
25224: EMPTY
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PPUSH
25231: CALL_OW 72
25235: IFFALSE 25255
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25237: LD_VAR 0 3
25241: PPUSH
25242: LD_VAR 0 11
25246: PUSH
25247: LD_INT 1
25249: ARRAY
25250: PPUSH
25251: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25255: LD_ADDR_VAR 0 3
25259: PUSH
25260: LD_EXP 18
25264: PUSH
25265: LD_INT 1
25267: ARRAY
25268: PUSH
25269: LD_EXP 18
25273: PUSH
25274: LD_INT 2
25276: ARRAY
25277: ADD
25278: PPUSH
25279: LD_INT 26
25281: PUSH
25282: LD_INT 1
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PPUSH
25289: CALL_OW 72
25293: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25294: LD_ADDR_VAR 0 1
25298: PUSH
25299: LD_EXP 18
25303: PUSH
25304: LD_INT 2
25306: ARRAY
25307: PUSH
25308: FOR_IN
25309: IFFALSE 25327
// ComTurnUnit ( i , Powell ) ;
25311: LD_VAR 0 1
25315: PPUSH
25316: LD_EXP 61
25320: PPUSH
25321: CALL_OW 119
25325: GO 25308
25327: POP
25328: POP
// Say ( Powell , D5-Pow-1 ) ;
25329: LD_EXP 61
25333: PPUSH
25334: LD_STRING D5-Pow-1
25336: PPUSH
25337: CALL_OW 88
// if tmp then
25341: LD_VAR 0 3
25345: IFFALSE 25363
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25347: LD_VAR 0 3
25351: PUSH
25352: LD_INT 1
25354: ARRAY
25355: PPUSH
25356: LD_STRING D5-Sol2-1
25358: PPUSH
25359: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25363: LD_EXP 61
25367: PPUSH
25368: LD_STRING D5-Pow-2
25370: PPUSH
25371: CALL_OW 88
// if tmp > 1 then
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: GREATER
25383: IFFALSE 25401
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25385: LD_VAR 0 3
25389: PUSH
25390: LD_INT 2
25392: ARRAY
25393: PPUSH
25394: LD_STRING D5-Sol2-2
25396: PPUSH
25397: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25401: LD_EXP 61
25405: PPUSH
25406: LD_STRING D5-Pow-3
25408: PPUSH
25409: CALL_OW 88
// wait ( 0 0$1 ) ;
25413: LD_INT 35
25415: PPUSH
25416: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25420: LD_ADDR_VAR 0 3
25424: PUSH
25425: LD_EXP 18
25429: PUSH
25430: LD_INT 1
25432: ARRAY
25433: PUSH
25434: LD_EXP 18
25438: PUSH
25439: LD_INT 2
25441: ARRAY
25442: UNION
25443: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25444: LD_VAR 0 3
25448: PPUSH
25449: LD_INT 80
25451: PPUSH
25452: LD_INT 67
25454: PPUSH
25455: CALL_OW 114
// wait ( 0 0$2 ) ;
25459: LD_INT 70
25461: PPUSH
25462: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25466: LD_INT 79
25468: PPUSH
25469: LD_INT 72
25471: PPUSH
25472: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25476: LD_INT 70
25478: PPUSH
25479: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25483: LD_VAR 0 3
25487: PPUSH
25488: LD_INT 3
25490: PUSH
25491: LD_INT 24
25493: PUSH
25494: LD_INT 1000
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PPUSH
25505: CALL_OW 72
25509: IFFALSE 25476
// Say ( Powell , D5a-Pow-1 ) ;
25511: LD_EXP 61
25515: PPUSH
25516: LD_STRING D5a-Pow-1
25518: PPUSH
25519: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25523: LD_EXP 61
25527: PPUSH
25528: LD_STRING D5a-Pow-1a
25530: PPUSH
25531: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25535: LD_INT 24
25537: PPUSH
25538: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25542: LD_EXP 61
25546: PPUSH
25547: LD_STRING D5a-Pow-1b
25549: PPUSH
25550: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25554: LD_INT 10
25556: PPUSH
25557: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25561: LD_EXP 61
25565: PPUSH
25566: LD_STRING D5a-Pow-1c
25568: PPUSH
25569: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25573: LD_VAR 0 3
25577: PPUSH
25578: LD_INT 68
25580: PPUSH
25581: LD_INT 63
25583: PPUSH
25584: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25588: LD_INT 18
25590: PPUSH
25591: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25595: LD_EXP 61
25599: PPUSH
25600: LD_STRING D5a-Pow-1d
25602: PPUSH
25603: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25607: LD_INT 35
25609: PPUSH
25610: CALL_OW 67
// if not HasTask ( tmp ) then
25614: LD_VAR 0 3
25618: PPUSH
25619: CALL_OW 314
25623: NOT
25624: IFFALSE 25641
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25626: LD_VAR 0 3
25630: PPUSH
25631: LD_INT 68
25633: PPUSH
25634: LD_INT 63
25636: PPUSH
25637: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25641: LD_VAR 0 3
25645: PPUSH
25646: LD_INT 24
25648: PUSH
25649: LD_INT 1
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PPUSH
25656: CALL_OW 72
25660: NOT
25661: IFFALSE 25607
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25663: LD_ADDR_VAR 0 3
25667: PUSH
25668: LD_INT 22
25670: PUSH
25671: LD_INT 4
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 92
25680: PUSH
25681: LD_INT 60
25683: PUSH
25684: LD_INT 93
25686: PUSH
25687: LD_INT 10
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 3
25698: PUSH
25699: LD_INT 54
25701: PUSH
25702: EMPTY
25703: LIST
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 69
25718: PUSH
25719: LD_EXP 61
25723: DIFF
25724: ST_TO_ADDR
// if tmp then
25725: LD_VAR 0 3
25729: IFFALSE 25763
// for i in tmp do
25731: LD_ADDR_VAR 0 1
25735: PUSH
25736: LD_VAR 0 3
25740: PUSH
25741: FOR_IN
25742: IFFALSE 25761
// ComMoveXY ( i , 36 , 67 ) ;
25744: LD_VAR 0 1
25748: PPUSH
25749: LD_INT 36
25751: PPUSH
25752: LD_INT 67
25754: PPUSH
25755: CALL_OW 111
25759: GO 25741
25761: POP
25762: POP
// wait ( 0 0$3 ) ;
25763: LD_INT 105
25765: PPUSH
25766: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25770: LD_VAR 0 12
25774: PPUSH
25775: LD_STRING D6-Sol3-1
25777: PPUSH
25778: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25782: LD_EXP 61
25786: PPUSH
25787: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25791: LD_EXP 61
25795: PPUSH
25796: LD_STRING D6-Pow-1
25798: PPUSH
25799: CALL_OW 88
// tmp := [ ] ;
25803: LD_ADDR_VAR 0 3
25807: PUSH
25808: EMPTY
25809: ST_TO_ADDR
// for i = 1 to 2 do
25810: LD_ADDR_VAR 0 1
25814: PUSH
25815: DOUBLE
25816: LD_INT 1
25818: DEC
25819: ST_TO_ADDR
25820: LD_INT 2
25822: PUSH
25823: FOR_TO
25824: IFFALSE 25938
// begin uc_side := 8 ;
25826: LD_ADDR_OWVAR 20
25830: PUSH
25831: LD_INT 8
25833: ST_TO_ADDR
// uc_nation := 2 ;
25834: LD_ADDR_OWVAR 21
25838: PUSH
25839: LD_INT 2
25841: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25842: LD_INT 14
25844: PPUSH
25845: LD_INT 3
25847: PPUSH
25848: LD_INT 2
25850: PPUSH
25851: LD_INT 29
25853: PPUSH
25854: LD_INT 100
25856: PPUSH
25857: CALL 75122 0 5
// veh := CreateVehicle ;
25861: LD_ADDR_VAR 0 14
25865: PUSH
25866: CALL_OW 45
25870: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25871: LD_VAR 0 14
25875: PPUSH
25876: LD_INT 4
25878: PPUSH
25879: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25883: LD_VAR 0 14
25887: PPUSH
25888: LD_INT 99
25890: PPUSH
25891: LD_INT 83
25893: PPUSH
25894: LD_INT 3
25896: PPUSH
25897: LD_INT 0
25899: PPUSH
25900: CALL_OW 50
// wait ( 3 ) ;
25904: LD_INT 3
25906: PPUSH
25907: CALL_OW 67
// Connect ( veh ) ;
25911: LD_VAR 0 14
25915: PPUSH
25916: CALL 78590 0 1
// tmp := tmp ^ veh ;
25920: LD_ADDR_VAR 0 3
25924: PUSH
25925: LD_VAR 0 3
25929: PUSH
25930: LD_VAR 0 14
25934: ADD
25935: ST_TO_ADDR
// end ;
25936: GO 25823
25938: POP
25939: POP
// wait ( 0 0$1 ) ;
25940: LD_INT 35
25942: PPUSH
25943: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25947: LD_INT 99
25949: PPUSH
25950: LD_INT 83
25952: PPUSH
25953: LD_INT 1
25955: PPUSH
25956: LD_INT 10
25958: PPUSH
25959: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25963: LD_INT 99
25965: PPUSH
25966: LD_INT 83
25968: PPUSH
25969: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25973: LD_VAR 0 12
25977: PPUSH
25978: LD_STRING D6-Sol3-2
25980: PPUSH
25981: CALL_OW 88
// async ;
25985: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25986: LD_EXP 61
25990: PPUSH
25991: LD_STRING D6-Pow-2
25993: PPUSH
25994: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25998: LD_VAR 0 3
26002: PUSH
26003: LD_INT 1
26005: ARRAY
26006: PPUSH
26007: LD_VAR 0 10
26011: PPUSH
26012: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26016: LD_VAR 0 3
26020: PUSH
26021: LD_INT 2
26023: ARRAY
26024: PPUSH
26025: LD_INT 22
26027: PUSH
26028: LD_INT 4
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: PUSH
26035: LD_INT 21
26037: PUSH
26038: LD_INT 3
26040: PUSH
26041: EMPTY
26042: LIST
26043: LIST
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PPUSH
26049: CALL_OW 69
26053: PPUSH
26054: LD_VAR 0 3
26058: PUSH
26059: LD_INT 2
26061: ARRAY
26062: PPUSH
26063: CALL_OW 74
26067: PPUSH
26068: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26072: LD_EXP 61
26076: PPUSH
26077: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26081: LD_INT 99
26083: PPUSH
26084: LD_INT 83
26086: PPUSH
26087: LD_INT 1
26089: PPUSH
26090: CALL_OW 331
// repeat wait ( 4 ) ;
26094: LD_INT 4
26096: PPUSH
26097: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26101: LD_VAR 0 3
26105: PUSH
26106: LD_INT 1
26108: ARRAY
26109: PPUSH
26110: CALL_OW 256
26114: PUSH
26115: LD_INT 1000
26117: LESS
26118: IFFALSE 26136
// SetLives ( tmp [ 1 ] , 1000 ) ;
26120: LD_VAR 0 3
26124: PUSH
26125: LD_INT 1
26127: ARRAY
26128: PPUSH
26129: LD_INT 1000
26131: PPUSH
26132: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26136: LD_INT 22
26138: PUSH
26139: LD_INT 4
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 30
26148: PUSH
26149: LD_INT 3
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PPUSH
26160: CALL_OW 69
26164: PUSH
26165: LD_INT 0
26167: EQUAL
26168: IFFALSE 26094
// skirmish := false ;
26170: LD_ADDR_EXP 100
26174: PUSH
26175: LD_INT 0
26177: ST_TO_ADDR
// sync ;
26178: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26179: LD_EXP 61
26183: PPUSH
26184: LD_STRING D6a-Pow-1
26186: PPUSH
26187: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26191: LD_VAR 0 12
26195: PPUSH
26196: LD_STRING D6a-Sol3-1
26198: PPUSH
26199: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26203: LD_EXP 61
26207: PPUSH
26208: LD_STRING D6a-Pow-2
26210: PPUSH
26211: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26215: LD_VAR 0 12
26219: PPUSH
26220: LD_STRING D6a-Sol3-2
26222: PPUSH
26223: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26227: LD_EXP 61
26231: PPUSH
26232: LD_STRING D6a-Pow-3
26234: PPUSH
26235: CALL_OW 88
// powellCenterCameraMode := true ;
26239: LD_ADDR_EXP 20
26243: PUSH
26244: LD_INT 1
26246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26247: LD_ADDR_VAR 0 1
26251: PUSH
26252: LD_INT 22
26254: PUSH
26255: LD_INT 8
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 25
26264: PUSH
26265: LD_INT 2
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PPUSH
26276: CALL_OW 69
26280: PUSH
26281: FOR_IN
26282: IFFALSE 26337
// begin SetTag ( i , 1 ) ;
26284: LD_VAR 0 1
26288: PPUSH
26289: LD_INT 1
26291: PPUSH
26292: CALL_OW 109
// ComExitBuilding ( i ) ;
26296: LD_VAR 0 1
26300: PPUSH
26301: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26305: LD_VAR 0 1
26309: PPUSH
26310: LD_INT 35
26312: PPUSH
26313: LD_INT 6
26315: PPUSH
26316: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26320: LD_VAR 0 1
26324: PPUSH
26325: LD_INT 53
26327: PPUSH
26328: LD_INT 4
26330: PPUSH
26331: CALL_OW 171
// end ;
26335: GO 26281
26337: POP
26338: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26339: LD_ADDR_VAR 0 3
26343: PUSH
26344: LD_INT 22
26346: PUSH
26347: LD_INT 4
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 21
26356: PUSH
26357: LD_INT 2
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 3
26366: PUSH
26367: LD_INT 34
26369: PUSH
26370: LD_INT 12
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: LIST
26385: PPUSH
26386: CALL_OW 69
26390: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26391: LD_EXP 61
26395: PPUSH
26396: LD_VAR 0 3
26400: PPUSH
26401: LD_EXP 61
26405: PPUSH
26406: CALL_OW 74
26410: PPUSH
26411: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26415: LD_EXP 61
26419: PPUSH
26420: LD_INT 100
26422: PPUSH
26423: LD_INT 88
26425: PPUSH
26426: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26430: LD_EXP 61
26434: PPUSH
26435: LD_INT 100
26437: PPUSH
26438: LD_INT 75
26440: PPUSH
26441: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26445: LD_EXP 61
26449: PPUSH
26450: LD_INT 88
26452: PPUSH
26453: LD_INT 53
26455: PPUSH
26456: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26460: LD_INT 8
26462: PPUSH
26463: LD_EXP 61
26467: PPUSH
26468: CALL_OW 471
// repeat wait ( 3 ) ;
26472: LD_INT 3
26474: PPUSH
26475: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26479: LD_INT 22
26481: PUSH
26482: LD_INT 4
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 92
26491: PUSH
26492: LD_INT 100
26494: PUSH
26495: LD_INT 75
26497: PUSH
26498: LD_INT 6
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: LIST
26505: LIST
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PPUSH
26511: CALL_OW 69
26515: IFFALSE 26472
// async ;
26517: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26518: LD_EXP 61
26522: PPUSH
26523: LD_STRING D6b-Pow-1
26525: PPUSH
26526: CALL_OW 88
// repeat wait ( 3 ) ;
26530: LD_INT 3
26532: PPUSH
26533: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26537: LD_EXP 61
26541: PPUSH
26542: CALL_OW 310
26546: PPUSH
26547: CALL_OW 256
26551: PUSH
26552: LD_INT 1000
26554: LESS
26555: IFFALSE 26574
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26557: LD_EXP 61
26561: PPUSH
26562: CALL_OW 310
26566: PPUSH
26567: LD_INT 1000
26569: PPUSH
26570: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26574: LD_EXP 61
26578: PPUSH
26579: CALL_OW 256
26583: PUSH
26584: LD_INT 1000
26586: LESS
26587: IFFALSE 26601
// SetLives ( Powell , 1000 ) ;
26589: LD_EXP 61
26593: PPUSH
26594: LD_INT 1000
26596: PPUSH
26597: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26601: LD_EXP 61
26605: PPUSH
26606: LD_EXP 67
26610: PPUSH
26611: CALL_OW 296
26615: PUSH
26616: LD_INT 5
26618: LESS
26619: PUSH
26620: LD_EXP 61
26624: PPUSH
26625: CALL_OW 310
26629: PPUSH
26630: LD_EXP 67
26634: PPUSH
26635: CALL_OW 296
26639: PUSH
26640: LD_INT 5
26642: LESS
26643: OR
26644: IFFALSE 26663
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26646: LD_EXP 61
26650: PPUSH
26651: CALL_OW 310
26655: PPUSH
26656: LD_INT 100
26658: PPUSH
26659: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26663: LD_EXP 61
26667: PPUSH
26668: CALL_OW 310
26672: NOT
26673: IFFALSE 26530
// DoNotAttack ( 8 , powellBomb ) ;
26675: LD_INT 8
26677: PPUSH
26678: LD_EXP 67
26682: PPUSH
26683: CALL_OW 471
// game_speed := 4 ;
26687: LD_ADDR_OWVAR 65
26691: PUSH
26692: LD_INT 4
26694: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26695: LD_EXP 61
26699: PPUSH
26700: LD_STRING D6b-Pow-1a
26702: PPUSH
26703: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26707: LD_EXP 61
26711: PPUSH
26712: LD_EXP 67
26716: PPUSH
26717: CALL_OW 180
// sync ;
26721: SYNC
// repeat wait ( 0 0$1 ) ;
26722: LD_INT 35
26724: PPUSH
26725: CALL_OW 67
// until IsInUnit ( Powell ) ;
26729: LD_EXP 61
26733: PPUSH
26734: CALL_OW 310
26738: IFFALSE 26722
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26740: LD_INT 8
26742: PPUSH
26743: LD_EXP 61
26747: PPUSH
26748: CALL_OW 310
26752: PPUSH
26753: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26757: LD_EXP 61
26761: PPUSH
26762: LD_INT 91
26764: PPUSH
26765: LD_INT 44
26767: PPUSH
26768: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26772: LD_EXP 61
26776: PPUSH
26777: LD_INT 96
26779: PPUSH
26780: LD_INT 44
26782: PPUSH
26783: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26787: LD_EXP 61
26791: PPUSH
26792: LD_INT 96
26794: PPUSH
26795: LD_INT 41
26797: PPUSH
26798: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26802: LD_EXP 61
26806: PPUSH
26807: LD_INT 92
26809: PPUSH
26810: LD_INT 39
26812: PPUSH
26813: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26817: LD_EXP 61
26821: PPUSH
26822: LD_INT 88
26824: PPUSH
26825: LD_INT 41
26827: PPUSH
26828: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26832: LD_EXP 61
26836: PPUSH
26837: LD_INT 91
26839: PPUSH
26840: LD_INT 44
26842: PPUSH
26843: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26847: LD_EXP 61
26851: PPUSH
26852: LD_INT 96
26854: PPUSH
26855: LD_INT 44
26857: PPUSH
26858: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26862: LD_EXP 61
26866: PPUSH
26867: LD_INT 96
26869: PPUSH
26870: LD_INT 41
26872: PPUSH
26873: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26877: LD_EXP 61
26881: PPUSH
26882: LD_INT 92
26884: PPUSH
26885: LD_INT 39
26887: PPUSH
26888: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26892: LD_EXP 61
26896: PPUSH
26897: LD_INT 88
26899: PPUSH
26900: LD_INT 41
26902: PPUSH
26903: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26907: LD_EXP 61
26911: PPUSH
26912: LD_INT 91
26914: PPUSH
26915: LD_INT 44
26917: PPUSH
26918: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26922: LD_EXP 61
26926: PPUSH
26927: LD_INT 93
26929: PPUSH
26930: LD_INT 39
26932: PPUSH
26933: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26937: LD_EXP 61
26941: PPUSH
26942: LD_INT 93
26944: PPUSH
26945: LD_INT 36
26947: PPUSH
26948: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26952: LD_INT 122
26954: PPUSH
26955: CALL_OW 67
// game_speed := 4 ;
26959: LD_ADDR_OWVAR 65
26963: PUSH
26964: LD_INT 4
26966: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26967: LD_EXP 61
26971: PPUSH
26972: LD_STRING D6b-Pow-1b
26974: PPUSH
26975: CALL_OW 88
// tmp := [ ] ;
26979: LD_ADDR_VAR 0 3
26983: PUSH
26984: EMPTY
26985: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26986: LD_ADDR_VAR 0 5
26990: PUSH
26991: LD_INT 78
26993: PUSH
26994: LD_INT 47
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PUSH
27001: LD_INT 106
27003: PUSH
27004: LD_INT 53
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27015: LD_ADDR_VAR 0 1
27019: PUSH
27020: LD_INT 22
27022: PUSH
27023: LD_INT 8
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 21
27032: PUSH
27033: LD_INT 3
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 92
27042: PUSH
27043: LD_INT 90
27045: PUSH
27046: LD_INT 52
27048: PUSH
27049: LD_INT 12
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: LIST
27056: LIST
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: LIST
27062: PPUSH
27063: CALL_OW 69
27067: PUSH
27068: FOR_IN
27069: IFFALSE 27094
// tmp := tmp ^ UnitsInside ( i ) ;
27071: LD_ADDR_VAR 0 3
27075: PUSH
27076: LD_VAR 0 3
27080: PUSH
27081: LD_VAR 0 1
27085: PPUSH
27086: CALL_OW 313
27090: ADD
27091: ST_TO_ADDR
27092: GO 27068
27094: POP
27095: POP
// for i in tmp do
27096: LD_ADDR_VAR 0 1
27100: PUSH
27101: LD_VAR 0 3
27105: PUSH
27106: FOR_IN
27107: IFFALSE 27269
// begin dist := 9999 ;
27109: LD_ADDR_VAR 0 9
27113: PUSH
27114: LD_INT 9999
27116: ST_TO_ADDR
// _xy := [ ] ;
27117: LD_ADDR_VAR 0 8
27121: PUSH
27122: EMPTY
27123: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27124: LD_VAR 0 1
27128: PPUSH
27129: LD_INT 1
27131: PPUSH
27132: CALL_OW 109
// ComExitBuilding ( i ) ;
27136: LD_VAR 0 1
27140: PPUSH
27141: CALL_OW 122
// for j in xy do
27145: LD_ADDR_VAR 0 2
27149: PUSH
27150: LD_VAR 0 5
27154: PUSH
27155: FOR_IN
27156: IFFALSE 27238
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27158: LD_VAR 0 1
27162: PPUSH
27163: LD_VAR 0 2
27167: PUSH
27168: LD_INT 1
27170: ARRAY
27171: PPUSH
27172: LD_VAR 0 2
27176: PUSH
27177: LD_INT 2
27179: ARRAY
27180: PPUSH
27181: CALL_OW 297
27185: PUSH
27186: LD_VAR 0 9
27190: LESS
27191: IFFALSE 27236
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27193: LD_ADDR_VAR 0 9
27197: PUSH
27198: LD_VAR 0 1
27202: PPUSH
27203: LD_VAR 0 2
27207: PUSH
27208: LD_INT 1
27210: ARRAY
27211: PPUSH
27212: LD_VAR 0 2
27216: PUSH
27217: LD_INT 2
27219: ARRAY
27220: PPUSH
27221: CALL_OW 297
27225: ST_TO_ADDR
// _xy := j ;
27226: LD_ADDR_VAR 0 8
27230: PUSH
27231: LD_VAR 0 2
27235: ST_TO_ADDR
// end ;
27236: GO 27155
27238: POP
27239: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27240: LD_VAR 0 1
27244: PPUSH
27245: LD_VAR 0 8
27249: PUSH
27250: LD_INT 1
27252: ARRAY
27253: PPUSH
27254: LD_VAR 0 8
27258: PUSH
27259: LD_INT 2
27261: ARRAY
27262: PPUSH
27263: CALL_OW 171
// end ;
27267: GO 27106
27269: POP
27270: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27271: LD_ADDR_VAR 0 4
27275: PUSH
27276: LD_VAR 0 3
27280: PPUSH
27281: LD_INT 26
27283: PUSH
27284: LD_INT 1
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: PUSH
27291: LD_INT 25
27293: PUSH
27294: LD_INT 1
27296: PUSH
27297: EMPTY
27298: LIST
27299: LIST
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PPUSH
27305: CALL_OW 72
27309: ST_TO_ADDR
// if tmp2 < 2 then
27310: LD_VAR 0 4
27314: PUSH
27315: LD_INT 2
27317: LESS
27318: IFFALSE 27387
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27320: LD_ADDR_VAR 0 4
27324: PUSH
27325: LD_INT 22
27327: PUSH
27328: LD_INT 8
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 26
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 3
27347: PUSH
27348: LD_INT 25
27350: PUSH
27351: LD_INT 15
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: LIST
27366: PPUSH
27367: CALL_OW 69
27371: PUSH
27372: LD_EXP 64
27376: PUSH
27377: LD_EXP 65
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: DIFF
27386: ST_TO_ADDR
// if tmp2 then
27387: LD_VAR 0 4
27391: IFFALSE 27409
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27393: LD_VAR 0 4
27397: PUSH
27398: LD_INT 1
27400: ARRAY
27401: PPUSH
27402: LD_STRING D6b-ArSol1-1
27404: PPUSH
27405: CALL_OW 88
// async ;
27409: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27410: LD_EXP 61
27414: PPUSH
27415: LD_STRING D6b-Pow-2
27417: PPUSH
27418: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27422: LD_INT 18
27424: PPUSH
27425: CALL_OW 67
// if tmp2 > 1 then
27429: LD_VAR 0 4
27433: PUSH
27434: LD_INT 1
27436: GREATER
27437: IFFALSE 27455
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27439: LD_VAR 0 4
27443: PUSH
27444: LD_INT 2
27446: ARRAY
27447: PPUSH
27448: LD_STRING D6b-ArSol2-1
27450: PPUSH
27451: CALL_OW 88
// sync ;
27455: SYNC
// repeat wait ( 5 ) ;
27456: LD_INT 5
27458: PPUSH
27459: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27463: LD_INT 93
27465: PPUSH
27466: LD_INT 36
27468: PPUSH
27469: CALL_OW 428
27473: PPUSH
27474: CALL_OW 255
27478: PUSH
27479: LD_INT 4
27481: EQUAL
27482: IFFALSE 27456
// DialogueOn ;
27484: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27488: LD_INT 10
27490: PPUSH
27491: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27495: LD_EXP 61
27499: PPUSH
27500: LD_STRING D6b-Pow-2a
27502: PPUSH
27503: CALL_OW 88
// DialogueOff ;
27507: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27511: LD_EXP 61
27515: PPUSH
27516: CALL_OW 310
27520: PPUSH
27521: LD_INT 332
27523: PPUSH
27524: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27528: LD_INT 93
27530: PPUSH
27531: LD_INT 35
27533: PPUSH
27534: LD_INT 1
27536: PPUSH
27537: LD_INT 6
27539: NEG
27540: PPUSH
27541: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27545: LD_INT 35
27547: PPUSH
27548: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27552: LD_INT 332
27554: PPUSH
27555: CALL_OW 256
27559: PUSH
27560: LD_INT 1000
27562: LESS
27563: PUSH
27564: LD_INT 332
27566: PPUSH
27567: CALL_OW 300
27571: AND
27572: IFFALSE 27584
// SetLives ( kozlov_fac , 0 ) ;
27574: LD_INT 332
27576: PPUSH
27577: LD_INT 0
27579: PPUSH
27580: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27584: LD_INT 332
27586: PPUSH
27587: CALL_OW 301
27591: PUSH
27592: LD_EXP 61
27596: PPUSH
27597: CALL_OW 301
27601: OR
27602: IFFALSE 27545
// game_speed := 4 ;
27604: LD_ADDR_OWVAR 65
27608: PUSH
27609: LD_INT 4
27611: ST_TO_ADDR
// powellCenterCameraMode := false ;
27612: LD_ADDR_EXP 20
27616: PUSH
27617: LD_INT 0
27619: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27620: LD_ADDR_VAR 0 1
27624: PUSH
27625: LD_VAR 0 3
27629: PUSH
27630: LD_INT 22
27632: PUSH
27633: LD_INT 8
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 25
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: PPUSH
27654: CALL_OW 69
27658: UNION
27659: PUSH
27660: FOR_IN
27661: IFFALSE 27677
// SetTag ( i , 0 ) ;
27663: LD_VAR 0 1
27667: PPUSH
27668: LD_INT 0
27670: PPUSH
27671: CALL_OW 109
27675: GO 27660
27677: POP
27678: POP
// wait ( 0 0$3 ) ;
27679: LD_INT 105
27681: PPUSH
27682: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27686: LD_INT 93
27688: PPUSH
27689: LD_INT 35
27691: PPUSH
27692: LD_INT 1
27694: PPUSH
27695: CALL_OW 331
// DialogueOn ;
27699: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27703: LD_VAR 0 12
27707: PPUSH
27708: LD_STRING D6c-Sol3-1
27710: PPUSH
27711: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27715: LD_INT 10
27717: PPUSH
27718: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27722: LD_EXP 40
27726: PPUSH
27727: LD_STRING D6c-JMM-1
27729: PPUSH
27730: CALL_OW 88
// if Cyrus then
27734: LD_EXP 46
27738: IFFALSE 27752
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27740: LD_EXP 46
27744: PPUSH
27745: LD_STRING D6c-Cyrus-1
27747: PPUSH
27748: CALL_OW 88
// if Bobby then
27752: LD_EXP 45
27756: IFFALSE 27770
// Say ( Bobby , D6c-Bobby-1 ) ;
27758: LD_EXP 45
27762: PPUSH
27763: LD_STRING D6c-Bobby-1
27765: PPUSH
27766: CALL_OW 88
// if Cornel then
27770: LD_EXP 51
27774: IFFALSE 27788
// Say ( Cornel , D6c-Corn-1 ) ;
27776: LD_EXP 51
27780: PPUSH
27781: LD_STRING D6c-Corn-1
27783: PPUSH
27784: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27788: LD_ADDR_VAR 0 4
27792: PUSH
27793: LD_INT 2
27795: PUSH
27796: LD_INT 22
27798: PUSH
27799: LD_INT 1
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 22
27808: PUSH
27809: LD_INT 4
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 26
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: LD_INT 23
27833: PUSH
27834: LD_INT 1
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: LIST
27845: PPUSH
27846: CALL_OW 69
27850: PUSH
27851: LD_VAR 0 12
27855: PUSH
27856: LD_EXP 40
27860: UNION
27861: PUSH
27862: LD_EXP 62
27866: UNION
27867: DIFF
27868: ST_TO_ADDR
// if tmp2 then
27869: LD_VAR 0 4
27873: IFFALSE 27891
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27875: LD_VAR 0 4
27879: PUSH
27880: LD_INT 1
27882: ARRAY
27883: PPUSH
27884: LD_STRING D6c-Sol1-1
27886: PPUSH
27887: CALL_OW 88
// if Lisa then
27891: LD_EXP 43
27895: IFFALSE 27909
// Say ( Lisa , D6c-Lisa-1 ) ;
27897: LD_EXP 43
27901: PPUSH
27902: LD_STRING D6c-Lisa-1
27904: PPUSH
27905: CALL_OW 88
// if Gary then
27909: LD_EXP 52
27913: IFFALSE 27927
// Say ( Gary , D6c-Gary-1 ) ;
27915: LD_EXP 52
27919: PPUSH
27920: LD_STRING D6c-Gary-1
27922: PPUSH
27923: CALL_OW 88
// if Donaldson then
27927: LD_EXP 44
27931: IFFALSE 27945
// Say ( Donaldson , D6c-Don-1 ) ;
27933: LD_EXP 44
27937: PPUSH
27938: LD_STRING D6c-Don-1
27940: PPUSH
27941: CALL_OW 88
// if tmp2 > 1 then
27945: LD_VAR 0 4
27949: PUSH
27950: LD_INT 1
27952: GREATER
27953: IFFALSE 27971
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27955: LD_VAR 0 4
27959: PUSH
27960: LD_INT 2
27962: ARRAY
27963: PPUSH
27964: LD_STRING D6c-Sol2-1
27966: PPUSH
27967: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27971: LD_VAR 0 12
27975: PPUSH
27976: LD_STRING D6c-Sol3-2
27978: PPUSH
27979: CALL_OW 88
// if IsInUnit ( JMM ) then
27983: LD_EXP 40
27987: PPUSH
27988: CALL_OW 310
27992: IFFALSE 28010
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27994: LD_EXP 40
27998: PPUSH
27999: CALL_OW 310
28003: PPUSH
28004: CALL_OW 87
28008: GO 28019
// CenterNowOnUnits ( JMM ) ;
28010: LD_EXP 40
28014: PPUSH
28015: CALL_OW 87
// dwait ( 0 0$2 ) ;
28019: LD_INT 70
28021: PPUSH
28022: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28026: LD_EXP 40
28030: PPUSH
28031: LD_STRING D6c-JMM-2
28033: PPUSH
28034: CALL_OW 88
// DialogueOff ;
28038: CALL_OW 7
// Video ( false ) ;
28042: LD_INT 0
28044: PPUSH
28045: CALL 107945 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28049: LD_INT 22
28051: PUSH
28052: LD_INT 4
28054: PUSH
28055: EMPTY
28056: LIST
28057: LIST
28058: PPUSH
28059: CALL_OW 69
28063: PPUSH
28064: LD_INT 1
28066: PPUSH
28067: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28071: LD_INT 4
28073: PPUSH
28074: LD_INT 4
28076: PPUSH
28077: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28081: LD_ADDR_VAR 0 1
28085: PUSH
28086: LD_INT 4
28088: PPUSH
28089: LD_INT 1
28091: PPUSH
28092: LD_INT 2
28094: PPUSH
28095: CALL 70345 0 3
28099: PUSH
28100: FOR_IN
28101: IFFALSE 28138
// if GetTech ( i , 1 ) <> state_researched then
28103: LD_VAR 0 1
28107: PPUSH
28108: LD_INT 1
28110: PPUSH
28111: CALL_OW 321
28115: PUSH
28116: LD_INT 2
28118: NONEQUAL
28119: IFFALSE 28136
// SetTech ( i , 1 , state_researched ) ;
28121: LD_VAR 0 1
28125: PPUSH
28126: LD_INT 1
28128: PPUSH
28129: LD_INT 2
28131: PPUSH
28132: CALL_OW 322
28136: GO 28100
28138: POP
28139: POP
// missionStage := 6 ;
28140: LD_ADDR_EXP 15
28144: PUSH
28145: LD_INT 6
28147: ST_TO_ADDR
// activeAttacks := true ;
28148: LD_ADDR_EXP 16
28152: PUSH
28153: LD_INT 1
28155: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28156: LD_STRING M2
28158: PPUSH
28159: CALL_OW 337
// SaveForQuickRestart ;
28163: CALL_OW 22
// wait ( 0 0$40 ) ;
28167: LD_INT 1400
28169: PPUSH
28170: CALL_OW 67
// DialogueOn ;
28174: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28178: LD_EXP 66
28182: PPUSH
28183: LD_STRING D7-Friend-1
28185: PPUSH
28186: CALL 112042 0 2
// Say ( JMM , D7-JMM-1 ) ;
28190: LD_EXP 40
28194: PPUSH
28195: LD_STRING D7-JMM-1
28197: PPUSH
28198: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28202: LD_EXP 66
28206: PPUSH
28207: LD_STRING D7-Friend-2
28209: PPUSH
28210: CALL 112042 0 2
// Say ( JMM , D7-JMM-2 ) ;
28214: LD_EXP 40
28218: PPUSH
28219: LD_STRING D7-JMM-2
28221: PPUSH
28222: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28226: LD_EXP 66
28230: PPUSH
28231: LD_STRING D7-Friend-3
28233: PPUSH
28234: CALL 112042 0 2
// Say ( JMM , D7-JMM-3 ) ;
28238: LD_EXP 40
28242: PPUSH
28243: LD_STRING D7-JMM-3
28245: PPUSH
28246: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28250: LD_EXP 66
28254: PPUSH
28255: LD_STRING D7-Friend-4
28257: PPUSH
28258: CALL 112042 0 2
// Say ( JMM , D7-JMM-4 ) ;
28262: LD_EXP 40
28266: PPUSH
28267: LD_STRING D7-JMM-4
28269: PPUSH
28270: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28274: LD_EXP 66
28278: PPUSH
28279: LD_STRING D7-Friend-5
28281: PPUSH
28282: CALL 112042 0 2
// Say ( JMM , D7-JMM-5 ) ;
28286: LD_EXP 40
28290: PPUSH
28291: LD_STRING D7-JMM-5
28293: PPUSH
28294: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28298: LD_EXP 66
28302: PPUSH
28303: LD_STRING D7-Friend-6
28305: PPUSH
28306: CALL 112042 0 2
// Say ( JMM , D7-JMM-6 ) ;
28310: LD_EXP 40
28314: PPUSH
28315: LD_STRING D7-JMM-6
28317: PPUSH
28318: CALL_OW 88
// DialogueOff ;
28322: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28326: LD_STRING Mlegion
28328: PPUSH
28329: CALL_OW 337
// skirmish := true ;
28333: LD_ADDR_EXP 100
28337: PUSH
28338: LD_INT 1
28340: ST_TO_ADDR
// RebuildKozlovFactory ;
28341: CALL 5380 0 0
// end ;
28345: PPOPN 14
28347: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28348: LD_EXP 20
28352: PUSH
28353: LD_EXP 61
28357: PPUSH
28358: CALL_OW 300
28362: AND
28363: IFFALSE 28405
28365: GO 28367
28367: DISABLE
// begin enable ;
28368: ENABLE
// if IsInUnit ( Powell ) then
28369: LD_EXP 61
28373: PPUSH
28374: CALL_OW 310
28378: IFFALSE 28396
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28380: LD_EXP 61
28384: PPUSH
28385: CALL_OW 310
28389: PPUSH
28390: CALL_OW 85
28394: GO 28405
// CenterOnUnits ( Powell ) ;
28396: LD_EXP 61
28400: PPUSH
28401: CALL_OW 85
// end ;
28405: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28406: LD_INT 22
28408: PUSH
28409: LD_INT 8
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 34
28418: PUSH
28419: LD_INT 48
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PPUSH
28430: CALL_OW 69
28434: IFFALSE 28708
28436: GO 28438
28438: DISABLE
28439: LD_INT 0
28441: PPUSH
28442: PPUSH
// begin if missionStage < 9 then
28443: LD_EXP 15
28447: PUSH
28448: LD_INT 9
28450: LESS
28451: IFFALSE 28461
// missionStage := 9 ;
28453: LD_ADDR_EXP 15
28457: PUSH
28458: LD_INT 9
28460: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28461: LD_ADDR_VAR 0 1
28465: PUSH
28466: LD_INT 22
28468: PUSH
28469: LD_INT 8
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: LD_INT 34
28478: PUSH
28479: LD_INT 48
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PPUSH
28490: CALL_OW 69
28494: PUSH
28495: LD_INT 1
28497: ARRAY
28498: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28499: LD_INT 175
28501: PPUSH
28502: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28506: LD_EXP 12
28510: PUSH
28511: LD_EXP 3
28515: PUSH
28516: LD_INT 0
28518: PUSH
28519: LD_INT 2
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: IN
28526: OR
28527: IFFALSE 28550
// target := [ 68 , 108 , 1 ] else
28529: LD_ADDR_VAR 0 2
28533: PUSH
28534: LD_INT 68
28536: PUSH
28537: LD_INT 108
28539: PUSH
28540: LD_INT 1
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: LIST
28547: ST_TO_ADDR
28548: GO 28569
// target := [ 181 , 88 , 2 ] ;
28550: LD_ADDR_VAR 0 2
28554: PUSH
28555: LD_INT 181
28557: PUSH
28558: LD_INT 88
28560: PUSH
28561: LD_INT 2
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: LIST
28568: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28569: LD_VAR 0 1
28573: PPUSH
28574: LD_VAR 0 2
28578: PUSH
28579: LD_INT 1
28581: ARRAY
28582: PPUSH
28583: LD_VAR 0 2
28587: PUSH
28588: LD_INT 2
28590: ARRAY
28591: PPUSH
28592: CALL_OW 176
// if target [ 3 ] = 1 then
28596: LD_VAR 0 2
28600: PUSH
28601: LD_INT 3
28603: ARRAY
28604: PUSH
28605: LD_INT 1
28607: EQUAL
28608: IFFALSE 28624
// SayRadio ( Kurt , D12-Kurt-1 ) else
28610: LD_EXP 64
28614: PPUSH
28615: LD_STRING D12-Kurt-1
28617: PPUSH
28618: CALL_OW 94
28622: GO 28648
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28624: LD_EXP 64
28628: PPUSH
28629: LD_STRING D12a-Kurt-1
28631: PPUSH
28632: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28636: LD_EXP 79
28640: PPUSH
28641: LD_STRING D12a-Roth-1
28643: PPUSH
28644: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28648: LD_INT 350
28650: PPUSH
28651: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28655: LD_VAR 0 1
28659: PPUSH
28660: LD_INT 22
28662: PUSH
28663: LD_INT 8
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 23
28672: PUSH
28673: LD_INT 2
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 30
28682: PUSH
28683: LD_INT 3
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: EMPTY
28691: LIST
28692: LIST
28693: LIST
28694: PPUSH
28695: CALL_OW 69
28699: PUSH
28700: LD_INT 1
28702: ARRAY
28703: PPUSH
28704: CALL_OW 228
// end ;
28708: PPOPN 2
28710: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28711: LD_EXP 64
28715: PPUSH
28716: CALL_OW 256
28720: PUSH
28721: LD_INT 999
28723: LESS
28724: PUSH
28725: LD_INT 22
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 21
28737: PUSH
28738: LD_INT 1
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: LD_INT 23
28747: PUSH
28748: LD_INT 2
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: LIST
28759: PPUSH
28760: CALL_OW 69
28764: PUSH
28765: LD_INT 9
28767: PUSH
28768: LD_INT 8
28770: PUSH
28771: LD_INT 7
28773: PUSH
28774: LD_INT 6
28776: PUSH
28777: EMPTY
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: PUSH
28783: LD_OWVAR 67
28787: ARRAY
28788: LESSEQUAL
28789: OR
28790: PUSH
28791: LD_INT 22
28793: PUSH
28794: LD_INT 8
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: LD_INT 34
28803: PUSH
28804: LD_INT 48
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PPUSH
28815: CALL_OW 69
28819: NOT
28820: AND
28821: PUSH
28822: LD_EXP 64
28826: PPUSH
28827: CALL_OW 302
28831: AND
28832: PUSH
28833: LD_INT 5
28835: PPUSH
28836: LD_INT 22
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PPUSH
28846: CALL_OW 70
28850: AND
28851: IFFALSE 29613
28853: GO 28855
28855: DISABLE
28856: LD_INT 0
28858: PPUSH
28859: PPUSH
28860: PPUSH
// begin legionDestroyed := true ;
28861: LD_ADDR_EXP 22
28865: PUSH
28866: LD_INT 1
28868: ST_TO_ADDR
// DialogueOn ;
28869: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28873: LD_EXP 40
28877: PPUSH
28878: LD_STRING D13-JMM-1
28880: PPUSH
28881: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28885: LD_EXP 64
28889: PPUSH
28890: LD_STRING D13-Kurt-1
28892: PPUSH
28893: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28897: LD_EXP 40
28901: PPUSH
28902: LD_STRING D13-JMM-2
28904: PPUSH
28905: CALL_OW 88
// if FakeInfo then
28909: LD_EXP 12
28913: IFFALSE 28933
// begin Say ( Kurt , D13-Kurt-2 ) ;
28915: LD_EXP 64
28919: PPUSH
28920: LD_STRING D13-Kurt-2
28922: PPUSH
28923: CALL_OW 88
// DialogueOff ;
28927: CALL_OW 7
// exit ;
28931: GO 29613
// end ; if not KurtStatus then
28933: LD_EXP 3
28937: NOT
28938: IFFALSE 28954
// Say ( Kurt , D13-Kurt-2b ) else
28940: LD_EXP 64
28944: PPUSH
28945: LD_STRING D13-Kurt-2b
28947: PPUSH
28948: CALL_OW 88
28952: GO 28966
// Say ( Kurt , D13-Kurt-2a ) ;
28954: LD_EXP 64
28958: PPUSH
28959: LD_STRING D13-Kurt-2a
28961: PPUSH
28962: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28966: LD_EXP 40
28970: PPUSH
28971: LD_STRING D13-JMM-3
28973: PPUSH
28974: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28978: LD_EXP 64
28982: PPUSH
28983: LD_STRING D13-Kurt-3
28985: PPUSH
28986: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28990: LD_EXP 40
28994: PPUSH
28995: LD_STRING D13-JMM-4
28997: PPUSH
28998: CALL_OW 88
// DialogueOff ;
29002: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29006: LD_STRING MlegionOut
29008: PPUSH
29009: CALL_OW 337
// MC_Kill ( 3 ) ;
29013: LD_INT 3
29015: PPUSH
29016: CALL 39831 0 1
// KillUnit ( Kozlov ) ;
29020: LD_EXP 65
29024: PPUSH
29025: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29029: LD_ADDR_VAR 0 1
29033: PUSH
29034: LD_INT 22
29036: PUSH
29037: LD_INT 8
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 23
29046: PUSH
29047: LD_INT 3
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: LD_INT 3
29056: PUSH
29057: LD_INT 21
29059: PUSH
29060: LD_INT 33
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: LIST
29075: PPUSH
29076: CALL_OW 69
29080: PUSH
29081: FOR_IN
29082: IFFALSE 29095
// KillUnit ( i ) ;
29084: LD_VAR 0 1
29088: PPUSH
29089: CALL_OW 66
29093: GO 29081
29095: POP
29096: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29097: LD_ADDR_VAR 0 1
29101: PUSH
29102: LD_INT 22
29104: PUSH
29105: LD_INT 8
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: LD_INT 21
29114: PUSH
29115: LD_INT 2
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 69
29130: PUSH
29131: FOR_IN
29132: IFFALSE 29145
// KillUnit ( i ) ;
29134: LD_VAR 0 1
29138: PPUSH
29139: CALL_OW 66
29143: GO 29131
29145: POP
29146: POP
// wait ( 0 0$0.6 ) ;
29147: LD_INT 21
29149: PPUSH
29150: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29154: LD_INT 8
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29164: LD_ADDR_VAR 0 2
29168: PUSH
29169: LD_INT 22
29171: PUSH
29172: LD_INT 8
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: LD_INT 21
29181: PUSH
29182: LD_INT 1
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PPUSH
29193: CALL_OW 69
29197: PUSH
29198: LD_EXP 65
29202: PUSH
29203: LD_EXP 64
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: DIFF
29212: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29213: LD_VAR 0 2
29217: PUSH
29218: LD_INT 6
29220: PUSH
29221: LD_INT 5
29223: PUSH
29224: LD_INT 4
29226: PUSH
29227: LD_INT 3
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: PUSH
29236: LD_OWVAR 67
29240: ARRAY
29241: GREATEREQUAL
29242: IFFALSE 29394
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29244: LD_ADDR_VAR 0 3
29248: PUSH
29249: LD_INT 6
29251: PUSH
29252: LD_INT 5
29254: PUSH
29255: LD_INT 4
29257: PUSH
29258: LD_INT 3
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: PUSH
29267: LD_OWVAR 67
29271: ARRAY
29272: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29273: LD_ADDR_VAR 0 1
29277: PUSH
29278: DOUBLE
29279: LD_VAR 0 2
29283: PUSH
29284: LD_VAR 0 3
29288: PUSH
29289: LD_INT 1
29291: PLUS
29292: MINUS
29293: INC
29294: ST_TO_ADDR
29295: LD_INT 1
29297: PUSH
29298: FOR_DOWNTO
29299: IFFALSE 29390
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29301: LD_ADDR_EXP 38
29305: PUSH
29306: LD_EXP 38
29310: PUSH
29311: LD_VAR 0 2
29315: PUSH
29316: LD_VAR 0 1
29320: ARRAY
29321: ADD
29322: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29323: LD_VAR 0 2
29327: PUSH
29328: LD_VAR 0 1
29332: ARRAY
29333: PPUSH
29334: CALL_OW 310
29338: IFFALSE 29355
// ComExit ( tmp [ i ] ) ;
29340: LD_VAR 0 2
29344: PUSH
29345: LD_VAR 0 1
29349: ARRAY
29350: PPUSH
29351: CALL 108371 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29355: LD_VAR 0 2
29359: PUSH
29360: LD_VAR 0 1
29364: ARRAY
29365: PPUSH
29366: LD_INT 34
29368: PUSH
29369: LD_INT 0
29371: PPUSH
29372: LD_INT 6
29374: PPUSH
29375: CALL_OW 12
29379: PLUS
29380: PPUSH
29381: LD_INT 1
29383: PPUSH
29384: CALL_OW 171
// end ;
29388: GO 29298
29390: POP
29391: POP
// end else
29392: GO 29404
// x := tmp ;
29394: LD_ADDR_VAR 0 3
29398: PUSH
29399: LD_VAR 0 2
29403: ST_TO_ADDR
// for i := tmp downto tmp - x do
29404: LD_ADDR_VAR 0 1
29408: PUSH
29409: DOUBLE
29410: LD_VAR 0 2
29414: INC
29415: ST_TO_ADDR
29416: LD_VAR 0 2
29420: PUSH
29421: LD_VAR 0 3
29425: MINUS
29426: PUSH
29427: FOR_DOWNTO
29428: IFFALSE 29500
// begin if IsInUnit ( tmp [ i ] ) then
29430: LD_VAR 0 2
29434: PUSH
29435: LD_VAR 0 1
29439: ARRAY
29440: PPUSH
29441: CALL_OW 310
29445: IFFALSE 29462
// ComExit ( tmp [ i ] ) ;
29447: LD_VAR 0 2
29451: PUSH
29452: LD_VAR 0 1
29456: ARRAY
29457: PPUSH
29458: CALL 108371 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29462: LD_VAR 0 2
29466: PUSH
29467: LD_VAR 0 1
29471: ARRAY
29472: PPUSH
29473: LD_INT 1
29475: PPUSH
29476: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29480: LD_VAR 0 2
29484: PUSH
29485: LD_VAR 0 1
29489: ARRAY
29490: PPUSH
29491: LD_INT 1000
29493: PPUSH
29494: CALL_OW 234
// end ;
29498: GO 29427
29500: POP
29501: POP
// SetSide ( Kurt , 1 ) ;
29502: LD_EXP 64
29506: PPUSH
29507: LD_INT 1
29509: PPUSH
29510: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29514: LD_INT 22
29516: PUSH
29517: LD_INT 8
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 21
29526: PUSH
29527: LD_INT 3
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PPUSH
29538: CALL_OW 69
29542: PPUSH
29543: LD_INT 1
29545: PPUSH
29546: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29550: LD_INT 8
29552: PPUSH
29553: LD_INT 1
29555: PPUSH
29556: LD_INT 1
29558: PPUSH
29559: LD_INT 1
29561: PPUSH
29562: CALL_OW 80
// wait ( 1 1$20 ) ;
29566: LD_INT 2800
29568: PPUSH
29569: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29573: LD_EXP 66
29577: PPUSH
29578: LD_INT 37
29580: PPUSH
29581: LD_INT 1
29583: PPUSH
29584: LD_INT 0
29586: PPUSH
29587: CALL_OW 48
// wait ( 0 0$1 ) ;
29591: LD_INT 35
29593: PPUSH
29594: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29598: LD_EXP 66
29602: PPUSH
29603: LD_INT 60
29605: PPUSH
29606: LD_INT 95
29608: PPUSH
29609: CALL_OW 111
// end ;
29613: PPOPN 3
29615: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29616: LD_EXP 22
29620: NOT
29621: PUSH
29622: LD_INT 22
29624: PUSH
29625: LD_INT 8
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 21
29634: PUSH
29635: LD_INT 1
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PPUSH
29646: CALL_OW 69
29650: PUSH
29651: LD_INT 0
29653: EQUAL
29654: AND
29655: IFFALSE 29675
29657: GO 29659
29659: DISABLE
// begin legionDestroyed := true ;
29660: LD_ADDR_EXP 22
29664: PUSH
29665: LD_INT 1
29667: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29668: LD_STRING MlegionOut
29670: PPUSH
29671: CALL_OW 337
// end ;
29675: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29676: LD_EXP 38
29680: IFFALSE 29755
29682: GO 29684
29684: DISABLE
29685: LD_INT 0
29687: PPUSH
// begin enable ;
29688: ENABLE
// for i in legionEscapeUnits do
29689: LD_ADDR_VAR 0 1
29693: PUSH
29694: LD_EXP 38
29698: PUSH
29699: FOR_IN
29700: IFFALSE 29753
// begin if IsInArea ( i , legionEscapeArea ) then
29702: LD_VAR 0 1
29706: PPUSH
29707: LD_INT 31
29709: PPUSH
29710: CALL_OW 308
29714: IFFALSE 29727
// RemoveUnit ( i ) else
29716: LD_VAR 0 1
29720: PPUSH
29721: CALL_OW 64
29725: GO 29751
// if not HasTask ( i ) then
29727: LD_VAR 0 1
29731: PPUSH
29732: CALL_OW 314
29736: NOT
29737: IFFALSE 29751
// ComMoveToArea ( i , legionEscapeArea ) ;
29739: LD_VAR 0 1
29743: PPUSH
29744: LD_INT 31
29746: PPUSH
29747: CALL_OW 113
// end ;
29751: GO 29699
29753: POP
29754: POP
// end ;
29755: PPOPN 1
29757: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29758: LD_INT 1
29760: PPUSH
29761: LD_EXP 66
29765: PPUSH
29766: CALL_OW 292
29770: IFFALSE 30068
29772: GO 29774
29774: DISABLE
29775: LD_INT 0
29777: PPUSH
// begin wait ( 0 0$2 ) ;
29778: LD_INT 70
29780: PPUSH
29781: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29785: LD_EXP 66
29789: PPUSH
29790: CALL_OW 87
// DialogueOn ;
29794: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29798: LD_EXP 40
29802: PPUSH
29803: LD_STRING D14-JMM-1
29805: PPUSH
29806: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29810: LD_EXP 66
29814: PPUSH
29815: LD_STRING D14-Friend-1
29817: PPUSH
29818: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29822: LD_EXP 40
29826: PPUSH
29827: LD_STRING D14-JMM-2
29829: PPUSH
29830: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29834: LD_EXP 66
29838: PPUSH
29839: LD_STRING D14-Friend-2
29841: PPUSH
29842: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29846: LD_EXP 40
29850: PPUSH
29851: LD_STRING D14-JMM-3
29853: PPUSH
29854: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29858: LD_EXP 66
29862: PPUSH
29863: LD_STRING D14-Friend-3
29865: PPUSH
29866: CALL_OW 88
// DialogueOff ;
29870: CALL_OW 7
// dec := Query ( Q14 ) ;
29874: LD_ADDR_VAR 0 1
29878: PUSH
29879: LD_STRING Q14
29881: PPUSH
29882: CALL_OW 97
29886: ST_TO_ADDR
// if dec = 1 then
29887: LD_VAR 0 1
29891: PUSH
29892: LD_INT 1
29894: EQUAL
29895: IFFALSE 29929
// begin DialogueOn ;
29897: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29901: LD_EXP 40
29905: PPUSH
29906: LD_STRING D14a-JMM-1
29908: PPUSH
29909: CALL_OW 88
// DialogueOff ;
29913: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29917: LD_EXP 66
29921: PPUSH
29922: LD_INT 1
29924: PPUSH
29925: CALL_OW 235
// end ; if dec = 2 then
29929: LD_VAR 0 1
29933: PUSH
29934: LD_INT 2
29936: EQUAL
29937: IFFALSE 29990
// begin DialogueOn ;
29939: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29943: LD_EXP 40
29947: PPUSH
29948: LD_STRING D14b-JMM-1
29950: PPUSH
29951: CALL_OW 88
// DialogueOff ;
29955: CALL_OW 7
// wait ( 0 0$1 ) ;
29959: LD_INT 35
29961: PPUSH
29962: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29966: LD_EXP 66
29970: PPUSH
29971: LD_INT 9
29973: PPUSH
29974: LD_INT 2
29976: PPUSH
29977: CALL_OW 111
// AddComHold ( Friend ) ;
29981: LD_EXP 66
29985: PPUSH
29986: CALL_OW 200
// end ; if dec = 3 then
29990: LD_VAR 0 1
29994: PUSH
29995: LD_INT 3
29997: EQUAL
29998: IFFALSE 30068
// begin DialogueOn ;
30000: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30004: LD_EXP 40
30008: PPUSH
30009: LD_STRING D14c-JMM-1
30011: PPUSH
30012: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30016: LD_EXP 66
30020: PPUSH
30021: LD_STRING D14c-Friend-1
30023: PPUSH
30024: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30028: LD_EXP 40
30032: PPUSH
30033: LD_STRING D14c-JMM-2
30035: PPUSH
30036: CALL_OW 88
// DialogueOff ;
30040: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30044: LD_EXP 66
30048: PPUSH
30049: LD_INT 9
30051: PPUSH
30052: LD_INT 2
30054: PPUSH
30055: CALL_OW 111
// AddComHold ( Friend ) ;
30059: LD_EXP 66
30063: PPUSH
30064: CALL_OW 200
// end ; end ;
30068: PPOPN 1
30070: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30071: LD_INT 9
30073: PPUSH
30074: LD_INT 2
30076: PPUSH
30077: CALL_OW 428
30081: PUSH
30082: LD_EXP 66
30086: EQUAL
30087: PUSH
30088: LD_EXP 66
30092: PPUSH
30093: CALL_OW 255
30097: PUSH
30098: LD_INT 8
30100: EQUAL
30101: AND
30102: IFFALSE 30116
30104: GO 30106
30106: DISABLE
// RemoveUnit ( Friend ) ;
30107: LD_EXP 66
30111: PPUSH
30112: CALL_OW 64
30116: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30117: LD_EXP 14
30121: PUSH
30122: LD_INT 31500
30124: GREATEREQUAL
30125: PUSH
30126: LD_EXP 7
30130: AND
30131: PUSH
30132: LD_EXP 2
30136: AND
30137: IFFALSE 30583
30139: GO 30141
30141: DISABLE
30142: LD_INT 0
30144: PPUSH
30145: PPUSH
30146: PPUSH
// begin missionStage := 7 ;
30147: LD_ADDR_EXP 15
30151: PUSH
30152: LD_INT 7
30154: ST_TO_ADDR
// for i := 1 to 5 do
30155: LD_ADDR_VAR 0 1
30159: PUSH
30160: DOUBLE
30161: LD_INT 1
30163: DEC
30164: ST_TO_ADDR
30165: LD_INT 5
30167: PUSH
30168: FOR_TO
30169: IFFALSE 30281
// begin uc_side = 1 ;
30171: LD_ADDR_OWVAR 20
30175: PUSH
30176: LD_INT 1
30178: ST_TO_ADDR
// uc_nation = 1 ;
30179: LD_ADDR_OWVAR 21
30183: PUSH
30184: LD_INT 1
30186: ST_TO_ADDR
// vc_engine = engine_siberite ;
30187: LD_ADDR_OWVAR 39
30191: PUSH
30192: LD_INT 3
30194: ST_TO_ADDR
// vc_control = control_computer ;
30195: LD_ADDR_OWVAR 38
30199: PUSH
30200: LD_INT 3
30202: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30203: LD_ADDR_OWVAR 37
30207: PUSH
30208: LD_INT 3
30210: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30211: LD_ADDR_OWVAR 40
30215: PUSH
30216: LD_INT 5
30218: PUSH
30219: LD_INT 9
30221: PUSH
30222: LD_INT 7
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 1
30232: PPUSH
30233: LD_INT 3
30235: PPUSH
30236: CALL_OW 12
30240: ARRAY
30241: ST_TO_ADDR
// veh = CreateVehicle ;
30242: LD_ADDR_VAR 0 2
30246: PUSH
30247: CALL_OW 45
30251: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30252: LD_VAR 0 2
30256: PPUSH
30257: LD_INT 1
30259: PPUSH
30260: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30264: LD_VAR 0 2
30268: PPUSH
30269: LD_INT 19
30271: PPUSH
30272: LD_INT 0
30274: PPUSH
30275: CALL_OW 49
// end ;
30279: GO 30168
30281: POP
30282: POP
// uc_side = 1 ;
30283: LD_ADDR_OWVAR 20
30287: PUSH
30288: LD_INT 1
30290: ST_TO_ADDR
// uc_nation = 1 ;
30291: LD_ADDR_OWVAR 21
30295: PUSH
30296: LD_INT 1
30298: ST_TO_ADDR
// vc_engine = 3 ;
30299: LD_ADDR_OWVAR 39
30303: PUSH
30304: LD_INT 3
30306: ST_TO_ADDR
// vc_control = 1 ;
30307: LD_ADDR_OWVAR 38
30311: PUSH
30312: LD_INT 1
30314: ST_TO_ADDR
// vc_chassis = 3 ;
30315: LD_ADDR_OWVAR 37
30319: PUSH
30320: LD_INT 3
30322: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30323: LD_ADDR_OWVAR 40
30327: PUSH
30328: LD_INT 5
30330: PUSH
30331: LD_INT 9
30333: PUSH
30334: LD_INT 7
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 1
30344: PPUSH
30345: LD_INT 3
30347: PPUSH
30348: CALL_OW 12
30352: ARRAY
30353: ST_TO_ADDR
// vehG = CreateVehicle ;
30354: LD_ADDR_VAR 0 3
30358: PUSH
30359: CALL_OW 45
30363: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30364: LD_VAR 0 3
30368: PPUSH
30369: LD_INT 1
30371: PPUSH
30372: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30376: LD_VAR 0 3
30380: PPUSH
30381: LD_INT 19
30383: PPUSH
30384: LD_INT 0
30386: PPUSH
30387: CALL_OW 49
// if JMMGirl = 1 then
30391: LD_EXP 7
30395: PUSH
30396: LD_INT 1
30398: EQUAL
30399: IFFALSE 30455
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30401: LD_ADDR_EXP 41
30405: PUSH
30406: LD_STRING Joan
30408: PPUSH
30409: LD_INT 1
30411: PPUSH
30412: LD_STRING 14_
30414: PPUSH
30415: CALL 70282 0 3
30419: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30420: LD_EXP 41
30424: PPUSH
30425: LD_VAR 0 3
30429: PPUSH
30430: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30434: LD_VAR 0 3
30438: PPUSH
30439: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30443: LD_EXP 41
30447: PPUSH
30448: LD_STRING D10BW-Joan-1
30450: PPUSH
30451: CALL_OW 94
// end ; if JMMGirl = 2 then
30455: LD_EXP 7
30459: PUSH
30460: LD_INT 2
30462: EQUAL
30463: IFFALSE 30519
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30465: LD_ADDR_EXP 43
30469: PUSH
30470: LD_STRING Lisa
30472: PPUSH
30473: LD_INT 1
30475: PPUSH
30476: LD_STRING 14_
30478: PPUSH
30479: CALL 70282 0 3
30483: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30484: LD_EXP 43
30488: PPUSH
30489: LD_VAR 0 3
30493: PPUSH
30494: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30498: LD_VAR 0 3
30502: PPUSH
30503: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30507: LD_EXP 43
30511: PPUSH
30512: LD_STRING D10BW-Lisa-1
30514: PPUSH
30515: CALL_OW 94
// end ; if JMMGirl = 3 then
30519: LD_EXP 7
30523: PUSH
30524: LD_INT 3
30526: EQUAL
30527: IFFALSE 30583
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30529: LD_ADDR_EXP 55
30533: PUSH
30534: LD_STRING Connie
30536: PPUSH
30537: LD_INT 1
30539: PPUSH
30540: LD_STRING 14_
30542: PPUSH
30543: CALL 70282 0 3
30547: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30548: LD_EXP 55
30552: PPUSH
30553: LD_VAR 0 3
30557: PPUSH
30558: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30562: LD_VAR 0 3
30566: PPUSH
30567: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30571: LD_EXP 55
30575: PPUSH
30576: LD_STRING D10BW-Con-1
30578: PPUSH
30579: CALL_OW 94
// end ; end ;
30583: PPOPN 3
30585: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30586: LD_EXP 14
30590: PUSH
30591: LD_INT 94500
30593: GREATEREQUAL
30594: IFFALSE 31006
30596: GO 30598
30598: DISABLE
30599: LD_INT 0
30601: PPUSH
30602: PPUSH
30603: PPUSH
// begin tmp := PrepareStevensSquad ;
30604: LD_ADDR_VAR 0 3
30608: PUSH
30609: CALL 2378 0 0
30613: ST_TO_ADDR
// if not tmp then
30614: LD_VAR 0 3
30618: NOT
30619: IFFALSE 30623
// exit ;
30621: GO 31006
// uc_side := 1 ;
30623: LD_ADDR_OWVAR 20
30627: PUSH
30628: LD_INT 1
30630: ST_TO_ADDR
// uc_nation := 1 ;
30631: LD_ADDR_OWVAR 21
30635: PUSH
30636: LD_INT 1
30638: ST_TO_ADDR
// for i in tmp do
30639: LD_ADDR_VAR 0 1
30643: PUSH
30644: LD_VAR 0 3
30648: PUSH
30649: FOR_IN
30650: IFFALSE 30747
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30652: LD_INT 3
30654: PPUSH
30655: LD_INT 3
30657: PPUSH
30658: LD_INT 1
30660: PPUSH
30661: LD_INT 5
30663: PUSH
30664: LD_INT 9
30666: PUSH
30667: LD_INT 7
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 1
30677: PPUSH
30678: LD_INT 3
30680: PPUSH
30681: CALL_OW 12
30685: ARRAY
30686: PPUSH
30687: LD_INT 40
30689: PPUSH
30690: CALL 75122 0 5
// veh := CreateVehicle ;
30694: LD_ADDR_VAR 0 2
30698: PUSH
30699: CALL_OW 45
30703: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30704: LD_VAR 0 2
30708: PPUSH
30709: LD_INT 1
30711: PPUSH
30712: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30716: LD_VAR 0 2
30720: PPUSH
30721: LD_INT 19
30723: PPUSH
30724: LD_INT 0
30726: PPUSH
30727: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30731: LD_VAR 0 1
30735: PPUSH
30736: LD_VAR 0 2
30740: PPUSH
30741: CALL_OW 52
// end ;
30745: GO 30649
30747: POP
30748: POP
// missionStage := 8 ;
30749: LD_ADDR_EXP 15
30753: PUSH
30754: LD_INT 8
30756: ST_TO_ADDR
// DialogueOn ;
30757: CALL_OW 6
// if Stevens then
30761: LD_EXP 42
30765: IFFALSE 30879
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30767: LD_EXP 42
30771: PPUSH
30772: CALL_OW 310
30776: PPUSH
30777: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30781: LD_EXP 42
30785: PPUSH
30786: LD_STRING D8-Huck-1
30788: PPUSH
30789: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30793: LD_EXP 40
30797: PPUSH
30798: LD_STRING D8-JMM-1
30800: PPUSH
30801: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30805: LD_EXP 42
30809: PPUSH
30810: LD_STRING D8-Huck-2
30812: PPUSH
30813: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30817: LD_EXP 40
30821: PPUSH
30822: LD_STRING D8-JMM-2
30824: PPUSH
30825: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30829: LD_EXP 42
30833: PPUSH
30834: LD_STRING D8-Huck-3
30836: PPUSH
30837: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30841: LD_EXP 40
30845: PPUSH
30846: LD_STRING D8-JMM-3
30848: PPUSH
30849: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30853: LD_EXP 42
30857: PPUSH
30858: LD_STRING D8-Huck-4
30860: PPUSH
30861: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30865: LD_EXP 40
30869: PPUSH
30870: LD_STRING D8-JMM-4
30872: PPUSH
30873: CALL_OW 88
// end else
30877: GO 30989
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30879: LD_EXP 56
30883: PPUSH
30884: CALL_OW 310
30888: PPUSH
30889: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30893: LD_EXP 56
30897: PPUSH
30898: LD_STRING D8-Huck-1
30900: PPUSH
30901: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30905: LD_EXP 40
30909: PPUSH
30910: LD_STRING D8-JMM-1a
30912: PPUSH
30913: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30917: LD_EXP 56
30921: PPUSH
30922: LD_STRING D8-Huck-2
30924: PPUSH
30925: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30929: LD_EXP 40
30933: PPUSH
30934: LD_STRING D8-JMM-2
30936: PPUSH
30937: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30941: LD_EXP 56
30945: PPUSH
30946: LD_STRING D8-Huck-3
30948: PPUSH
30949: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30953: LD_EXP 40
30957: PPUSH
30958: LD_STRING D8-JMM-3
30960: PPUSH
30961: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30965: LD_EXP 56
30969: PPUSH
30970: LD_STRING D8-Huck-4
30972: PPUSH
30973: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30977: LD_EXP 40
30981: PPUSH
30982: LD_STRING D8-JMM-4
30984: PPUSH
30985: CALL_OW 88
// end ; DialogueOff ;
30989: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30993: LD_INT 25
30995: PPUSH
30996: LD_INT 1
30998: PPUSH
30999: LD_INT 1
31001: PPUSH
31002: CALL_OW 322
// end ;
31006: PPOPN 3
31008: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31009: LD_EXP 75
31013: PPUSH
31014: CALL_OW 302
31018: PUSH
31019: LD_INT 1
31021: PPUSH
31022: LD_EXP 75
31026: PPUSH
31027: CALL_OW 292
31031: AND
31032: IFFALSE 31283
31034: GO 31036
31036: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31037: LD_EXP 75
31041: PPUSH
31042: CALL_OW 87
// DialogueOn ;
31046: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31050: LD_EXP 40
31054: PPUSH
31055: LD_STRING D10nB-JMM-1
31057: PPUSH
31058: CALL_OW 88
// if BurlakStatus = 1 then
31062: LD_EXP 9
31066: PUSH
31067: LD_INT 1
31069: EQUAL
31070: IFFALSE 31084
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
31072: LD_EXP 74
31076: PPUSH
31077: LD_STRING D10nB-Vse-1a
31079: PPUSH
31080: CALL_OW 94
// end ; if BurlakStatus = 0 then
31084: LD_EXP 9
31088: PUSH
31089: LD_INT 0
31091: EQUAL
31092: IFFALSE 31106
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31094: LD_EXP 74
31098: PPUSH
31099: LD_STRING D10nB-Vse-1
31101: PPUSH
31102: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31106: LD_EXP 40
31110: PPUSH
31111: LD_STRING D10nB-JMM-2
31113: PPUSH
31114: CALL_OW 88
// if KappaStatus then
31118: LD_EXP 2
31122: IFFALSE 31136
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
31124: LD_EXP 74
31128: PPUSH
31129: LD_STRING D10nB-Vse-5a
31131: PPUSH
31132: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
31136: LD_EXP 2
31140: NOT
31141: PUSH
31142: LD_EXP 6
31146: PUSH
31147: LD_INT 0
31149: EQUAL
31150: AND
31151: IFFALSE 31279
// begin if JMMGirl = 1 then
31153: LD_EXP 7
31157: PUSH
31158: LD_INT 1
31160: EQUAL
31161: IFFALSE 31211
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31163: LD_EXP 74
31167: PPUSH
31168: LD_STRING D10nB-Vse-2
31170: PPUSH
31171: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31175: LD_EXP 40
31179: PPUSH
31180: LD_STRING D10nB-JMM-3
31182: PPUSH
31183: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31187: LD_EXP 74
31191: PPUSH
31192: LD_STRING D10nB-Vse-3
31194: PPUSH
31195: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31199: LD_EXP 40
31203: PPUSH
31204: LD_STRING D10nB-JMM-4
31206: PPUSH
31207: CALL_OW 88
// end ; if JMMGirl = 2 then
31211: LD_EXP 7
31215: PUSH
31216: LD_INT 2
31218: EQUAL
31219: IFFALSE 31245
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31221: LD_EXP 74
31225: PPUSH
31226: LD_STRING D10nB-Vse-4
31228: PPUSH
31229: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31233: LD_EXP 40
31237: PPUSH
31238: LD_STRING D10nB-JMM-5
31240: PPUSH
31241: CALL_OW 88
// end ; if JMMGirl = 3 then
31245: LD_EXP 7
31249: PUSH
31250: LD_INT 3
31252: EQUAL
31253: IFFALSE 31279
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31255: LD_EXP 74
31259: PPUSH
31260: LD_STRING D10nB-Vse-5
31262: PPUSH
31263: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31267: LD_EXP 40
31271: PPUSH
31272: LD_STRING D10nB-JMM-6
31274: PPUSH
31275: CALL_OW 88
// end ; end ; DialogueOff ;
31279: CALL_OW 7
// end ;
31283: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31284: LD_EXP 14
31288: PUSH
31289: LD_INT 115500
31291: GREATEREQUAL
31292: PUSH
31293: LD_EXP 69
31297: PPUSH
31298: CALL_OW 302
31302: AND
31303: PUSH
31304: LD_INT 267
31306: PPUSH
31307: CALL_OW 302
31311: AND
31312: IFFALSE 31826
31314: GO 31316
31316: DISABLE
31317: LD_INT 0
31319: PPUSH
31320: PPUSH
31321: PPUSH
// begin missionStage := 10 ;
31322: LD_ADDR_EXP 15
31326: PUSH
31327: LD_INT 10
31329: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31330: LD_ADDR_VAR 0 3
31334: PUSH
31335: LD_INT 22
31337: PUSH
31338: LD_INT 1
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 23
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 26
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 3
31367: PUSH
31368: LD_INT 25
31370: PUSH
31371: LD_INT 12
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 3
31384: PUSH
31385: LD_INT 25
31387: PUSH
31388: LD_INT 16
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: EMPTY
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: PPUSH
31406: CALL_OW 69
31410: PUSH
31411: LD_EXP 40
31415: PUSH
31416: LD_EXP 64
31420: PUSH
31421: LD_EXP 42
31425: PUSH
31426: LD_EXP 56
31430: PUSH
31431: LD_EXP 43
31435: PUSH
31436: LD_EXP 44
31440: PUSH
31441: LD_EXP 45
31445: PUSH
31446: LD_EXP 46
31450: PUSH
31451: LD_EXP 47
31455: PUSH
31456: LD_EXP 48
31460: PUSH
31461: LD_EXP 49
31465: PUSH
31466: LD_EXP 50
31470: PUSH
31471: LD_EXP 51
31475: PUSH
31476: LD_EXP 52
31480: PUSH
31481: LD_EXP 53
31485: PUSH
31486: LD_EXP 54
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: DIFF
31509: ST_TO_ADDR
// if not tmp and Brown then
31510: LD_VAR 0 3
31514: NOT
31515: PUSH
31516: LD_EXP 48
31520: AND
31521: IFFALSE 31536
// tmp := [ Brown ] ;
31523: LD_ADDR_VAR 0 3
31527: PUSH
31528: LD_EXP 48
31532: PUSH
31533: EMPTY
31534: LIST
31535: ST_TO_ADDR
// DialogueOn ;
31536: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31540: LD_VAR 0 3
31544: PUSH
31545: LD_INT 1
31547: ARRAY
31548: PPUSH
31549: LD_STRING D11-Sol1-1
31551: PPUSH
31552: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31556: LD_EXP 68
31560: PPUSH
31561: LD_STRING D11-Pla-1
31563: PPUSH
31564: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31568: LD_EXP 69
31572: PPUSH
31573: LD_STRING D11-Kov-1
31575: PPUSH
31576: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31580: LD_EXP 68
31584: PPUSH
31585: LD_STRING D11-Pla-2
31587: PPUSH
31588: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31592: LD_VAR 0 3
31596: PUSH
31597: LD_INT 1
31599: ARRAY
31600: PPUSH
31601: LD_STRING D11-Sol1-2
31603: PPUSH
31604: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31608: LD_EXP 40
31612: PPUSH
31613: LD_STRING D11-JMM-2
31615: PPUSH
31616: CALL_OW 88
// DialogueOff ;
31620: CALL_OW 7
// allowBehemothConstruct := true ;
31624: LD_ADDR_EXP 25
31628: PUSH
31629: LD_INT 1
31631: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31632: LD_STRING M4
31634: PPUSH
31635: CALL_OW 337
// j := 3 ;
31639: LD_ADDR_VAR 0 2
31643: PUSH
31644: LD_INT 3
31646: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31647: LD_ADDR_VAR 0 3
31651: PUSH
31652: LD_INT 22
31654: PUSH
31655: LD_INT 3
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 50
31664: PUSH
31665: EMPTY
31666: LIST
31667: PUSH
31668: LD_INT 3
31670: PUSH
31671: LD_INT 120
31673: PUSH
31674: LD_INT 105
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 25
31687: PUSH
31688: LD_INT 3
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: LIST
31699: LIST
31700: PPUSH
31701: CALL_OW 69
31705: PUSH
31706: LD_EXP 69
31710: DIFF
31711: ST_TO_ADDR
// for i in tmp do
31712: LD_ADDR_VAR 0 1
31716: PUSH
31717: LD_VAR 0 3
31721: PUSH
31722: FOR_IN
31723: IFFALSE 31773
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31725: LD_ADDR_EXP 77
31729: PUSH
31730: LD_EXP 77
31734: PPUSH
31735: LD_VAR 0 1
31739: PPUSH
31740: CALL 107973 0 2
31744: ST_TO_ADDR
// j := j - 1 ;
31745: LD_ADDR_VAR 0 2
31749: PUSH
31750: LD_VAR 0 2
31754: PUSH
31755: LD_INT 1
31757: MINUS
31758: ST_TO_ADDR
// if j = 0 then
31759: LD_VAR 0 2
31763: PUSH
31764: LD_INT 0
31766: EQUAL
31767: IFFALSE 31771
// break ;
31769: GO 31773
// end ;
31771: GO 31722
31773: POP
31774: POP
// BuildBehemoths ;
31775: CALL 8368 0 0
// repeat wait ( 15 15$00 ) ;
31779: LD_INT 31500
31781: PPUSH
31782: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31786: LD_EXP 27
31790: IFFALSE 31794
// break ;
31792: GO 31826
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31794: LD_INT 267
31796: PPUSH
31797: CALL_OW 274
31801: PPUSH
31802: LD_INT 1
31804: PPUSH
31805: CALL_OW 275
31809: PUSH
31810: LD_INT 1000
31812: GREATEREQUAL
31813: IFFALSE 31819
// BuildBehemoths ;
31815: CALL 8368 0 0
// until not behemothBuilders ;
31819: LD_EXP 77
31823: NOT
31824: IFFALSE 31779
// end ;
31826: PPOPN 3
31828: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31829: LD_EXP 77
31833: NOT
31834: PUSH
31835: LD_EXP 28
31839: NOT
31840: AND
31841: PUSH
31842: LD_EXP 25
31846: AND
31847: IFFALSE 31867
31849: GO 31851
31851: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31852: LD_STRING M4a
31854: PPUSH
31855: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31859: LD_ADDR_EXP 27
31863: PUSH
31864: LD_INT 1
31866: ST_TO_ADDR
// end ;
31867: END
// every 0 0$1 trigger behemothDone do
31868: LD_EXP 28
31872: IFFALSE 31884
31874: GO 31876
31876: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31877: LD_STRING M4b
31879: PPUSH
31880: CALL_OW 337
31884: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31885: LD_EXP 29
31889: NOT
31890: IFFALSE 32086
31892: GO 31894
31894: DISABLE
31895: LD_INT 0
31897: PPUSH
31898: PPUSH
// begin enable ;
31899: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31900: LD_ADDR_VAR 0 1
31904: PUSH
31905: LD_INT 3
31907: PPUSH
31908: CALL 108034 0 1
31912: ST_TO_ADDR
// if not tmp and not behemothDone then
31913: LD_VAR 0 1
31917: NOT
31918: PUSH
31919: LD_EXP 28
31923: NOT
31924: AND
31925: IFFALSE 31961
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31927: LD_ADDR_VAR 0 1
31931: PUSH
31932: LD_INT 22
31934: PUSH
31935: LD_INT 3
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 30
31944: PUSH
31945: LD_INT 37
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PPUSH
31956: CALL_OW 69
31960: ST_TO_ADDR
// if not tmp then
31961: LD_VAR 0 1
31965: NOT
31966: IFFALSE 31970
// exit ;
31968: GO 32086
// for i in tmp do
31970: LD_ADDR_VAR 0 2
31974: PUSH
31975: LD_VAR 0 1
31979: PUSH
31980: FOR_IN
31981: IFFALSE 32084
// if See ( 1 , i ) then
31983: LD_INT 1
31985: PPUSH
31986: LD_VAR 0 2
31990: PPUSH
31991: CALL_OW 292
31995: IFFALSE 32082
// begin if GetType ( i ) = unit_building then
31997: LD_VAR 0 2
32001: PPUSH
32002: CALL_OW 247
32006: PUSH
32007: LD_INT 3
32009: EQUAL
32010: IFFALSE 32048
// begin disable ;
32012: DISABLE
// CenterNowOnUnits ( i ) ;
32013: LD_VAR 0 2
32017: PPUSH
32018: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32022: LD_EXP 40
32026: PPUSH
32027: LD_STRING D17a-JMM-1
32029: PPUSH
32030: CALL_OW 88
// seeBehemoth := true ;
32034: LD_ADDR_EXP 29
32038: PUSH
32039: LD_INT 1
32041: ST_TO_ADDR
// exit ;
32042: POP
32043: POP
32044: GO 32086
// end else
32046: GO 32082
// begin disable ;
32048: DISABLE
// CenterNowOnUnits ( i ) ;
32049: LD_VAR 0 2
32053: PPUSH
32054: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32058: LD_EXP 40
32062: PPUSH
32063: LD_STRING D17b-JMM-1
32065: PPUSH
32066: CALL_OW 88
// seeBehemoth := true ;
32070: LD_ADDR_EXP 29
32074: PUSH
32075: LD_INT 1
32077: ST_TO_ADDR
// exit ;
32078: POP
32079: POP
32080: GO 32086
// end ; end ;
32082: GO 31980
32084: POP
32085: POP
// end ;
32086: PPOPN 2
32088: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32089: LD_EXP 14
32093: PUSH
32094: LD_INT 123200
32096: GREATEREQUAL
32097: IFFALSE 33297
32099: GO 32101
32101: DISABLE
32102: LD_INT 0
32104: PPUSH
32105: PPUSH
32106: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32107: LD_INT 2
32109: PPUSH
32110: LD_INT 23
32112: PUSH
32113: LD_INT 3
32115: PUSH
32116: LD_INT 3
32118: PUSH
32119: LD_INT 48
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: LIST
32126: LIST
32127: PUSH
32128: EMPTY
32129: LIST
32130: PPUSH
32131: CALL 63856 0 2
// repeat wait ( 0 0$1 ) ;
32135: LD_INT 35
32137: PPUSH
32138: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32142: LD_INT 22
32144: PUSH
32145: LD_INT 3
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 34
32154: PUSH
32155: LD_INT 48
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PPUSH
32166: CALL_OW 69
32170: IFFALSE 32135
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32172: LD_ADDR_VAR 0 1
32176: PUSH
32177: LD_INT 22
32179: PUSH
32180: LD_INT 3
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 34
32189: PUSH
32190: LD_INT 48
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PPUSH
32201: CALL_OW 69
32205: PUSH
32206: LD_INT 1
32208: ARRAY
32209: ST_TO_ADDR
// missionStage := 12 ;
32210: LD_ADDR_EXP 15
32214: PUSH
32215: LD_INT 12
32217: ST_TO_ADDR
// platonovHasBomb := true ;
32218: LD_ADDR_EXP 30
32222: PUSH
32223: LD_INT 1
32225: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32226: LD_VAR 0 1
32230: PPUSH
32231: LD_INT 181
32233: PPUSH
32234: LD_INT 86
32236: PPUSH
32237: CALL_OW 171
// AddComHold ( bomb ) ;
32241: LD_VAR 0 1
32245: PPUSH
32246: CALL_OW 200
// wait ( 0 0$10 ) ;
32250: LD_INT 350
32252: PPUSH
32253: CALL_OW 67
// DialogueOn ;
32257: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32261: LD_EXP 68
32265: PPUSH
32266: LD_STRING D15-Pla-1
32268: PPUSH
32269: CALL_OW 94
// dec := Query ( Q15a ) ;
32273: LD_ADDR_VAR 0 2
32277: PUSH
32278: LD_STRING Q15a
32280: PPUSH
32281: CALL_OW 97
32285: ST_TO_ADDR
// if dec = 1 then
32286: LD_VAR 0 2
32290: PUSH
32291: LD_INT 1
32293: EQUAL
32294: IFFALSE 32317
// begin Say ( JMM , D15a-JMM-1 ) ;
32296: LD_EXP 40
32300: PPUSH
32301: LD_STRING D15a-JMM-1
32303: PPUSH
32304: CALL_OW 88
// YouLost ( Surrender ) ;
32308: LD_STRING Surrender
32310: PPUSH
32311: CALL_OW 104
// exit ;
32315: GO 33297
// end ; if dec = 2 then
32317: LD_VAR 0 2
32321: PUSH
32322: LD_INT 2
32324: EQUAL
32325: IFFALSE 32394
// begin Say ( JMM , D15b-JMM-1 ) ;
32327: LD_EXP 40
32331: PPUSH
32332: LD_STRING D15b-JMM-1
32334: PPUSH
32335: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32339: LD_EXP 68
32343: PPUSH
32344: LD_STRING D15b-Pla-1
32346: PPUSH
32347: CALL_OW 94
// DialogueOff ;
32351: CALL_OW 7
// wait ( 3 3$00 ) ;
32355: LD_INT 6300
32357: PPUSH
32358: CALL_OW 67
// DialogueOn ;
32362: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32366: LD_EXP 40
32370: PPUSH
32371: LD_STRING D15d-JMM-1a
32373: PPUSH
32374: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32378: LD_EXP 68
32382: PPUSH
32383: LD_STRING D15d-Pla-1
32385: PPUSH
32386: CALL_OW 94
// DialogueOff ;
32390: CALL_OW 7
// end ; if dec = 3 then
32394: LD_VAR 0 2
32398: PUSH
32399: LD_INT 3
32401: EQUAL
32402: IFFALSE 32456
// begin Say ( JMM , D15c-JMM-1 ) ;
32404: LD_EXP 40
32408: PPUSH
32409: LD_STRING D15c-JMM-1
32411: PPUSH
32412: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32416: LD_EXP 68
32420: PPUSH
32421: LD_STRING D15c-Pla-1
32423: PPUSH
32424: CALL_OW 94
// DialogueOff ;
32428: CALL_OW 7
// wait ( 0 0$15 ) ;
32432: LD_INT 525
32434: PPUSH
32435: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32439: LD_VAR 0 1
32443: PPUSH
32444: LD_INT 60
32446: PPUSH
32447: LD_INT 95
32449: PPUSH
32450: CALL_OW 116
// exit ;
32454: GO 33297
// end ; if dec = 4 then
32456: LD_VAR 0 2
32460: PUSH
32461: LD_INT 4
32463: EQUAL
32464: IFFALSE 32494
// begin Say ( JMM , D15d-JMM-1 ) ;
32466: LD_EXP 40
32470: PPUSH
32471: LD_STRING D15d-JMM-1
32473: PPUSH
32474: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32478: LD_EXP 68
32482: PPUSH
32483: LD_STRING D15d-Pla-1
32485: PPUSH
32486: CALL_OW 94
// DialogueOff ;
32490: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32494: LD_EXP 66
32498: PPUSH
32499: CALL_OW 302
32503: PUSH
32504: LD_EXP 66
32508: PPUSH
32509: CALL_OW 255
32513: PUSH
32514: LD_INT 1
32516: EQUAL
32517: AND
32518: PUSH
32519: LD_INT 22
32521: PUSH
32522: LD_INT 1
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 34
32531: PUSH
32532: LD_INT 8
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PPUSH
32543: CALL_OW 69
32547: NOT
32548: AND
32549: IFFALSE 33198
// begin SetSide ( Friend , 8 ) ;
32551: LD_EXP 66
32555: PPUSH
32556: LD_INT 8
32558: PPUSH
32559: CALL_OW 235
// if IsInUnit ( Friend ) then
32563: LD_EXP 66
32567: PPUSH
32568: CALL_OW 310
32572: IFFALSE 32583
// ComExitBuilding ( Friend ) ;
32574: LD_EXP 66
32578: PPUSH
32579: CALL_OW 122
// if IsDriver ( Friend ) then
32583: LD_EXP 66
32587: PPUSH
32588: CALL 105577 0 1
32592: IFFALSE 32603
// ComExitVehicle ( Friend ) ;
32594: LD_EXP 66
32598: PPUSH
32599: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32603: LD_EXP 66
32607: PPUSH
32608: LD_INT 9
32610: PPUSH
32611: LD_INT 2
32613: PPUSH
32614: CALL_OW 171
// wait ( 0 0$05 ) ;
32618: LD_INT 175
32620: PPUSH
32621: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32625: LD_EXP 66
32629: PPUSH
32630: CALL_OW 87
// DialogueOn ;
32634: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32638: LD_EXP 40
32642: PPUSH
32643: LD_STRING D16-JMM-1
32645: PPUSH
32646: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32650: LD_EXP 66
32654: PPUSH
32655: LD_STRING D16-Friend-1
32657: PPUSH
32658: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32662: LD_EXP 40
32666: PPUSH
32667: LD_STRING D16-JMM-2
32669: PPUSH
32670: CALL_OW 88
// DialogueOff ;
32674: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32678: LD_EXP 66
32682: PPUSH
32683: LD_INT 1
32685: PPUSH
32686: CALL_OW 235
// ComHold ( Friend ) ;
32690: LD_EXP 66
32694: PPUSH
32695: CALL_OW 140
// wait ( 0 0$20 ) ;
32699: LD_INT 700
32701: PPUSH
32702: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32706: LD_EXP 66
32710: PPUSH
32711: LD_INT 9
32713: PPUSH
32714: LD_INT 2
32716: PPUSH
32717: CALL_OW 297
32721: PUSH
32722: LD_INT 30
32724: LESS
32725: IFFALSE 32794
// begin SetSide ( Friend , 8 ) ;
32727: LD_EXP 66
32731: PPUSH
32732: LD_INT 8
32734: PPUSH
32735: CALL_OW 235
// if IsInUnit ( Friend ) then
32739: LD_EXP 66
32743: PPUSH
32744: CALL_OW 310
32748: IFFALSE 32759
// ComExitBuilding ( Friend ) ;
32750: LD_EXP 66
32754: PPUSH
32755: CALL_OW 122
// if IsDriver ( Friend ) then
32759: LD_EXP 66
32763: PPUSH
32764: CALL 105577 0 1
32768: IFFALSE 32779
// ComExitVehicle ( Friend ) ;
32770: LD_EXP 66
32774: PPUSH
32775: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32779: LD_EXP 66
32783: PPUSH
32784: LD_INT 9
32786: PPUSH
32787: LD_INT 2
32789: PPUSH
32790: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32794: LD_INT 1050
32796: PPUSH
32797: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32801: LD_INT 22
32803: PUSH
32804: LD_INT 1
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 34
32813: PUSH
32814: LD_INT 8
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PPUSH
32825: CALL_OW 69
32829: NOT
32830: IFFALSE 33176
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32832: LD_ADDR_VAR 0 3
32836: PUSH
32837: LD_INT 22
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 26
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 3
32859: PUSH
32860: LD_INT 25
32862: PUSH
32863: LD_INT 12
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 25
32872: PUSH
32873: LD_INT 16
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: LIST
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: LIST
32889: PPUSH
32890: CALL_OW 69
32894: PUSH
32895: LD_EXP 40
32899: PUSH
32900: LD_EXP 42
32904: PUSH
32905: LD_EXP 56
32909: PUSH
32910: LD_EXP 43
32914: PUSH
32915: LD_EXP 44
32919: PUSH
32920: LD_EXP 45
32924: PUSH
32925: LD_EXP 46
32929: PUSH
32930: LD_EXP 47
32934: PUSH
32935: LD_EXP 48
32939: PUSH
32940: LD_EXP 49
32944: PUSH
32945: LD_EXP 50
32949: PUSH
32950: LD_EXP 51
32954: PUSH
32955: LD_EXP 52
32959: PUSH
32960: LD_EXP 53
32964: PUSH
32965: LD_EXP 54
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: DIFF
32987: ST_TO_ADDR
// DialogueOn ;
32988: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32992: LD_EXP 68
32996: PPUSH
32997: LD_STRING D16a-Pla-1
32999: PPUSH
33000: CALL_OW 94
// if Stevens then
33004: LD_EXP 42
33008: IFFALSE 33024
// Say ( Stevens , D16a-Huck-1 ) else
33010: LD_EXP 42
33014: PPUSH
33015: LD_STRING D16a-Huck-1
33017: PPUSH
33018: CALL_OW 88
33022: GO 33066
// if Baker then
33024: LD_EXP 56
33028: IFFALSE 33044
// Say ( Baker , D16a-Huck-1 ) else
33030: LD_EXP 56
33034: PPUSH
33035: LD_STRING D16a-Huck-1
33037: PPUSH
33038: CALL_OW 88
33042: GO 33066
// if tmp then
33044: LD_VAR 0 3
33048: IFFALSE 33066
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33050: LD_VAR 0 3
33054: PUSH
33055: LD_INT 1
33057: ARRAY
33058: PPUSH
33059: LD_STRING D16a-Sol1-1
33061: PPUSH
33062: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33066: LD_EXP 66
33070: PPUSH
33071: CALL_OW 255
33075: PUSH
33076: LD_INT 8
33078: EQUAL
33079: IFFALSE 33095
// Say ( JMM , D16a-JMM-1 ) else
33081: LD_EXP 40
33085: PPUSH
33086: LD_STRING D16a-JMM-1
33088: PPUSH
33089: CALL_OW 88
33093: GO 33155
// begin Say ( JMM , D16a-JMM-1a ) ;
33095: LD_EXP 40
33099: PPUSH
33100: LD_STRING D16a-JMM-1a
33102: PPUSH
33103: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33107: LD_EXP 66
33111: PPUSH
33112: LD_STRING D16a-Friend-1
33114: PPUSH
33115: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33119: LD_EXP 66
33123: PPUSH
33124: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33128: LD_EXP 66
33132: PPUSH
33133: LD_INT 191
33135: PPUSH
33136: LD_INT 103
33138: PPUSH
33139: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33143: LD_EXP 66
33147: PPUSH
33148: LD_INT 3
33150: PPUSH
33151: CALL_OW 235
// end ; DialogueOff ;
33155: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33159: LD_VAR 0 1
33163: PPUSH
33164: LD_INT 60
33166: PPUSH
33167: LD_INT 95
33169: PPUSH
33170: CALL_OW 116
// end else
33174: GO 33196
// begin DialogueOn ;
33176: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33180: LD_EXP 68
33184: PPUSH
33185: LD_STRING D16c-Pla-1
33187: PPUSH
33188: CALL_OW 94
// DialogueOff ;
33192: CALL_OW 7
// end ; end else
33196: GO 33297
// begin wait ( 3 3$00 ) ;
33198: LD_INT 6300
33200: PPUSH
33201: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33205: LD_INT 22
33207: PUSH
33208: LD_INT 1
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 34
33217: PUSH
33218: LD_INT 8
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PPUSH
33229: CALL_OW 69
33233: NOT
33234: IFFALSE 33277
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33236: LD_EXP 68
33240: PPUSH
33241: LD_STRING D16b-Pla-1
33243: PPUSH
33244: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33248: LD_EXP 40
33252: PPUSH
33253: LD_STRING D16b-JMM-1
33255: PPUSH
33256: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33260: LD_VAR 0 1
33264: PPUSH
33265: LD_INT 60
33267: PPUSH
33268: LD_INT 95
33270: PPUSH
33271: CALL_OW 116
// end else
33275: GO 33297
// begin DialogueOn ;
33277: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33281: LD_EXP 68
33285: PPUSH
33286: LD_STRING D16c-Pla-1
33288: PPUSH
33289: CALL_OW 94
// DialogueOff ;
33293: CALL_OW 7
// end ; end ; end ;
33297: PPOPN 3
33299: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33300: LD_INT 25
33302: PPUSH
33303: LD_INT 1
33305: PPUSH
33306: CALL_OW 321
33310: PUSH
33311: LD_INT 2
33313: EQUAL
33314: PUSH
33315: LD_EXP 14
33319: PUSH
33320: LD_INT 126000
33322: GREATEREQUAL
33323: OR
33324: PUSH
33325: LD_EXP 23
33329: NOT
33330: AND
33331: PUSH
33332: LD_EXP 79
33336: PPUSH
33337: CALL_OW 302
33341: AND
33342: IFFALSE 33700
33344: GO 33346
33346: DISABLE
33347: LD_INT 0
33349: PPUSH
// begin missionStage := 11 ;
33350: LD_ADDR_EXP 15
33354: PUSH
33355: LD_INT 11
33357: ST_TO_ADDR
// DialogueOn ;
33358: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33362: LD_EXP 79
33366: PPUSH
33367: LD_STRING D9-Roth-1
33369: PPUSH
33370: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33374: LD_EXP 40
33378: PPUSH
33379: LD_STRING D9-JMM-1
33381: PPUSH
33382: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33386: LD_EXP 79
33390: PPUSH
33391: LD_STRING D9-Roth-2
33393: PPUSH
33394: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33398: LD_EXP 79
33402: PPUSH
33403: LD_STRING D9-Roth-2a
33405: PPUSH
33406: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33410: LD_EXP 68
33414: PPUSH
33415: LD_STRING D9-Pla-2
33417: PPUSH
33418: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33422: LD_EXP 79
33426: PPUSH
33427: LD_STRING D9-Roth-3
33429: PPUSH
33430: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33434: LD_EXP 68
33438: PPUSH
33439: LD_STRING D9-Pla-3
33441: PPUSH
33442: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33446: LD_EXP 79
33450: PPUSH
33451: LD_STRING D9-Roth-4
33453: PPUSH
33454: CALL_OW 94
// dec := Query ( Q9 ) ;
33458: LD_ADDR_VAR 0 1
33462: PUSH
33463: LD_STRING Q9
33465: PPUSH
33466: CALL_OW 97
33470: ST_TO_ADDR
// if dec = 1 then
33471: LD_VAR 0 1
33475: PUSH
33476: LD_INT 1
33478: EQUAL
33479: IFFALSE 33493
// SayRadio ( Roth , D9a-Roth-1 ) ;
33481: LD_EXP 79
33485: PPUSH
33486: LD_STRING D9a-Roth-1
33488: PPUSH
33489: CALL_OW 94
// if dec = 2 then
33493: LD_VAR 0 1
33497: PUSH
33498: LD_INT 2
33500: EQUAL
33501: IFFALSE 33527
// begin Say ( JMM , D9b-JMM-1 ) ;
33503: LD_EXP 40
33507: PPUSH
33508: LD_STRING D9b-JMM-1
33510: PPUSH
33511: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33515: LD_EXP 79
33519: PPUSH
33520: LD_STRING D9b-Roth-1
33522: PPUSH
33523: CALL_OW 94
// end ; if dec = 3 then
33527: LD_VAR 0 1
33531: PUSH
33532: LD_INT 3
33534: EQUAL
33535: IFFALSE 33597
// begin Say ( JMM , D9c-JMM-1 ) ;
33537: LD_EXP 40
33541: PPUSH
33542: LD_STRING D9c-JMM-1
33544: PPUSH
33545: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33549: LD_EXP 79
33553: PPUSH
33554: LD_STRING D9c-Roth-1
33556: PPUSH
33557: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33561: LD_EXP 40
33565: PPUSH
33566: LD_STRING D9c-JMM-2
33568: PPUSH
33569: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33573: LD_EXP 79
33577: PPUSH
33578: LD_STRING D9c-Roth-2
33580: PPUSH
33581: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33585: LD_EXP 40
33589: PPUSH
33590: LD_STRING D9c-JMM-3
33592: PPUSH
33593: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33597: LD_EXP 79
33601: PPUSH
33602: LD_STRING D9c-Roth-3
33604: PPUSH
33605: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33609: LD_EXP 79
33613: PPUSH
33614: LD_STRING D9cont-Roth-1
33616: PPUSH
33617: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33621: LD_EXP 40
33625: PPUSH
33626: LD_STRING D9cont-JMM-1
33628: PPUSH
33629: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33633: LD_EXP 79
33637: PPUSH
33638: LD_STRING D9cont-Roth-2
33640: PPUSH
33641: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33645: LD_EXP 40
33649: PPUSH
33650: LD_STRING D9cont-JMM-2
33652: PPUSH
33653: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33657: LD_EXP 79
33661: PPUSH
33662: LD_STRING D9cont-Roth-3
33664: PPUSH
33665: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33669: LD_EXP 40
33673: PPUSH
33674: LD_STRING D9cont-JMM-3
33676: PPUSH
33677: CALL_OW 88
// DialogueOff ;
33681: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33685: LD_STRING M3
33687: PPUSH
33688: CALL_OW 337
// allianceActive := true ;
33692: LD_ADDR_EXP 31
33696: PUSH
33697: LD_INT 1
33699: ST_TO_ADDR
// end ;
33700: PPOPN 1
33702: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33703: LD_INT 1
33705: PPUSH
33706: LD_INT 126
33708: PPUSH
33709: CALL_OW 292
33713: PUSH
33714: LD_EXP 68
33718: PPUSH
33719: CALL_OW 310
33723: AND
33724: IFFALSE 33877
33726: GO 33728
33728: DISABLE
33729: LD_INT 0
33731: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33732: LD_EXP 68
33736: PPUSH
33737: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33741: LD_ADDR_VAR 0 1
33745: PUSH
33746: LD_INT 4
33748: PPUSH
33749: LD_INT 22
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PPUSH
33759: CALL_OW 70
33763: PPUSH
33764: LD_EXP 68
33768: PPUSH
33769: CALL_OW 74
33773: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33774: LD_EXP 68
33778: PPUSH
33779: LD_VAR 0 1
33783: PUSH
33784: LD_INT 1
33786: ARRAY
33787: PPUSH
33788: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33792: LD_EXP 68
33796: PPUSH
33797: LD_STRING D18-Pla-1
33799: PPUSH
33800: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33804: LD_INT 22
33806: PUSH
33807: LD_INT 3
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 34
33816: PUSH
33817: LD_INT 48
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PPUSH
33828: CALL_OW 69
33832: IFFALSE 33877
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33834: LD_INT 22
33836: PUSH
33837: LD_INT 3
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 34
33846: PUSH
33847: LD_INT 48
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PPUSH
33858: CALL_OW 69
33862: PUSH
33863: LD_INT 1
33865: ARRAY
33866: PPUSH
33867: LD_INT 111
33869: PPUSH
33870: LD_INT 97
33872: PPUSH
33873: CALL_OW 116
// end ;
33877: PPOPN 1
33879: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33880: LD_EXP 68
33884: PPUSH
33885: CALL_OW 301
33889: PUSH
33890: LD_EXP 71
33894: PPUSH
33895: CALL_OW 301
33899: AND
33900: PUSH
33901: LD_INT 22
33903: PUSH
33904: LD_INT 3
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 21
33913: PUSH
33914: LD_INT 1
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 50
33923: PUSH
33924: EMPTY
33925: LIST
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: LIST
33931: PPUSH
33932: CALL_OW 69
33936: PUSH
33937: LD_INT 14
33939: PUSH
33940: LD_INT 13
33942: PUSH
33943: LD_INT 12
33945: PUSH
33946: LD_INT 10
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: LIST
33953: LIST
33954: PUSH
33955: LD_OWVAR 67
33959: ARRAY
33960: LESS
33961: AND
33962: IFFALSE 34761
33964: GO 33966
33966: DISABLE
33967: LD_INT 0
33969: PPUSH
33970: PPUSH
33971: PPUSH
33972: PPUSH
// begin MC_Kill ( 2 ) ;
33973: LD_INT 2
33975: PPUSH
33976: CALL 39831 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33980: LD_INT 1
33982: PPUSH
33983: LD_INT 3
33985: PPUSH
33986: LD_INT 1
33988: PPUSH
33989: LD_INT 1
33991: PPUSH
33992: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33996: LD_ADDR_VAR 0 2
34000: PUSH
34001: LD_INT 22
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 21
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 50
34023: PUSH
34024: EMPTY
34025: LIST
34026: PUSH
34027: LD_INT 26
34029: PUSH
34030: LD_INT 1
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: PPUSH
34043: CALL_OW 69
34047: ST_TO_ADDR
// if not tmp then
34048: LD_VAR 0 2
34052: NOT
34053: IFFALSE 34109
// begin uc_side = 3 ;
34055: LD_ADDR_OWVAR 20
34059: PUSH
34060: LD_INT 3
34062: ST_TO_ADDR
// uc_nation = 3 ;
34063: LD_ADDR_OWVAR 21
34067: PUSH
34068: LD_INT 3
34070: ST_TO_ADDR
// hc_name =  ;
34071: LD_ADDR_OWVAR 26
34075: PUSH
34076: LD_STRING 
34078: ST_TO_ADDR
// hc_gallery =  ;
34079: LD_ADDR_OWVAR 33
34083: PUSH
34084: LD_STRING 
34086: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34087: LD_INT 1
34089: PPUSH
34090: LD_INT 10
34092: PPUSH
34093: CALL_OW 381
// tmp = CreateHuman ;
34097: LD_ADDR_VAR 0 2
34101: PUSH
34102: CALL_OW 44
34106: ST_TO_ADDR
// end else
34107: GO 34123
// tmp := tmp [ 1 ] ;
34109: LD_ADDR_VAR 0 2
34113: PUSH
34114: LD_VAR 0 2
34118: PUSH
34119: LD_INT 1
34121: ARRAY
34122: ST_TO_ADDR
// DialogueOn ;
34123: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34127: LD_VAR 0 2
34131: PPUSH
34132: LD_STRING DSurrenderRussians-RSol1-1a
34134: PPUSH
34135: CALL_OW 94
// DialogueOff ;
34139: CALL_OW 7
// russianDestroyed := true ;
34143: LD_ADDR_EXP 21
34147: PUSH
34148: LD_INT 1
34150: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34151: LD_ADDR_VAR 0 1
34155: PUSH
34156: LD_INT 22
34158: PUSH
34159: LD_INT 6
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PPUSH
34166: CALL_OW 69
34170: PUSH
34171: FOR_IN
34172: IFFALSE 34185
// KillUnit ( i ) ;
34174: LD_VAR 0 1
34178: PPUSH
34179: CALL_OW 66
34183: GO 34171
34185: POP
34186: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34187: LD_INT 22
34189: PUSH
34190: LD_INT 3
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 21
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PPUSH
34211: CALL_OW 69
34215: PPUSH
34216: CALL_OW 122
// wait ( 0 0$1 ) ;
34220: LD_INT 35
34222: PPUSH
34223: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34227: LD_INT 22
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 21
34239: PUSH
34240: LD_INT 1
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PPUSH
34251: CALL_OW 69
34255: PPUSH
34256: LD_INT 25
34258: PPUSH
34259: CALL_OW 173
// wait ( 0 0$35 ) ;
34263: LD_INT 1225
34265: PPUSH
34266: CALL_OW 67
// PrepareOmarInvasion ;
34270: CALL 16368 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34274: LD_ADDR_VAR 0 2
34278: PUSH
34279: LD_EXP 97
34283: PPUSH
34284: CALL_OW 250
34288: PUSH
34289: LD_EXP 97
34293: PPUSH
34294: CALL_OW 251
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34303: LD_VAR 0 2
34307: PUSH
34308: LD_INT 1
34310: ARRAY
34311: PPUSH
34312: LD_VAR 0 2
34316: PUSH
34317: LD_INT 2
34319: ARRAY
34320: PPUSH
34321: LD_INT 1
34323: PPUSH
34324: LD_INT 8
34326: NEG
34327: PPUSH
34328: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34332: LD_EXP 97
34336: PPUSH
34337: CALL_OW 87
// DialogueOn ;
34341: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34345: LD_EXP 40
34349: PPUSH
34350: LD_STRING D19-JMM-1
34352: PPUSH
34353: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34357: LD_ADDR_VAR 0 3
34361: PUSH
34362: LD_INT 22
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 26
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 2
34384: PUSH
34385: LD_INT 25
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 25
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 25
34407: PUSH
34408: LD_INT 3
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 25
34417: PUSH
34418: LD_INT 4
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 25
34427: PUSH
34428: LD_INT 5
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 25
34437: PUSH
34438: LD_INT 8
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: LIST
34458: PPUSH
34459: CALL_OW 69
34463: PUSH
34464: LD_EXP 40
34468: PUSH
34469: LD_EXP 41
34473: PUSH
34474: LD_EXP 64
34478: PUSH
34479: LD_EXP 42
34483: PUSH
34484: LD_EXP 43
34488: PUSH
34489: LD_EXP 44
34493: PUSH
34494: LD_EXP 45
34498: PUSH
34499: LD_EXP 46
34503: PUSH
34504: LD_EXP 47
34508: PUSH
34509: LD_EXP 48
34513: PUSH
34514: LD_EXP 49
34518: PUSH
34519: LD_EXP 50
34523: PUSH
34524: LD_EXP 51
34528: PUSH
34529: LD_EXP 52
34533: PUSH
34534: LD_EXP 53
34538: PUSH
34539: LD_EXP 54
34543: PUSH
34544: LD_EXP 55
34548: PUSH
34549: LD_EXP 56
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: LIST
34570: LIST
34571: LIST
34572: LIST
34573: DIFF
34574: ST_TO_ADDR
// if tmp2 then
34575: LD_VAR 0 3
34579: IFFALSE 34597
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34581: LD_VAR 0 3
34585: PUSH
34586: LD_INT 1
34588: ARRAY
34589: PPUSH
34590: LD_STRING D19-Sol1-1
34592: PPUSH
34593: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34597: LD_EXP 40
34601: PPUSH
34602: LD_STRING D19-JMM-2
34604: PPUSH
34605: CALL_OW 88
// DialogueOff ;
34609: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34613: LD_VAR 0 2
34617: PUSH
34618: LD_INT 1
34620: ARRAY
34621: PPUSH
34622: LD_VAR 0 2
34626: PUSH
34627: LD_INT 2
34629: ARRAY
34630: PPUSH
34631: LD_INT 1
34633: PPUSH
34634: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34638: LD_STRING M5
34640: PPUSH
34641: CALL_OW 337
// omarOnMotherLode := false ;
34645: LD_ADDR_VAR 0 4
34649: PUSH
34650: LD_INT 0
34652: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34653: LD_INT 35
34655: PPUSH
34656: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34660: LD_EXP 97
34664: PPUSH
34665: LD_INT 215
34667: PPUSH
34668: LD_INT 100
34670: PPUSH
34671: CALL_OW 297
34675: PUSH
34676: LD_INT 10
34678: LESS
34679: PUSH
34680: LD_VAR 0 4
34684: NOT
34685: AND
34686: IFFALSE 34720
// begin omarOnMotherLode := true ;
34688: LD_ADDR_VAR 0 4
34692: PUSH
34693: LD_INT 1
34695: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34696: LD_EXP 40
34700: PPUSH
34701: LD_STRING D19b-JMM-1
34703: PPUSH
34704: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34708: LD_EXP 97
34712: PPUSH
34713: LD_STRING DOmarContam-Omar-1
34715: PPUSH
34716: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34720: LD_EXP 97
34724: PPUSH
34725: CALL_OW 301
34729: IFFALSE 34653
// Say ( JMM , D19a-JMM-1 ) ;
34731: LD_EXP 40
34735: PPUSH
34736: LD_STRING D19a-JMM-1
34738: PPUSH
34739: CALL_OW 88
// if Heike then
34743: LD_EXP 98
34747: IFFALSE 34761
// Say ( Heike , D19a-Hke-1 ) ;
34749: LD_EXP 98
34753: PPUSH
34754: LD_STRING D19a-Hke-1
34756: PPUSH
34757: CALL_OW 88
// end ;
34761: PPOPN 4
34763: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34764: LD_INT 22
34766: PUSH
34767: LD_INT 3
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 21
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PPUSH
34788: CALL_OW 69
34792: PUSH
34793: LD_EXP 21
34797: AND
34798: IFFALSE 34866
34800: GO 34802
34802: DISABLE
34803: LD_INT 0
34805: PPUSH
34806: PPUSH
// begin enable ;
34807: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34808: LD_ADDR_VAR 0 2
34812: PUSH
34813: LD_INT 25
34815: PPUSH
34816: LD_INT 22
34818: PUSH
34819: LD_INT 3
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PPUSH
34826: CALL_OW 70
34830: ST_TO_ADDR
// if not tmp then
34831: LD_VAR 0 2
34835: NOT
34836: IFFALSE 34840
// exit ;
34838: GO 34866
// for i in tmp do
34840: LD_ADDR_VAR 0 1
34844: PUSH
34845: LD_VAR 0 2
34849: PUSH
34850: FOR_IN
34851: IFFALSE 34864
// RemoveUnit ( i ) ;
34853: LD_VAR 0 1
34857: PPUSH
34858: CALL_OW 64
34862: GO 34850
34864: POP
34865: POP
// end ;
34866: PPOPN 2
34868: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34869: LD_INT 22
34871: PUSH
34872: LD_INT 7
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 21
34881: PUSH
34882: LD_INT 1
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PPUSH
34893: CALL_OW 69
34897: PUSH
34898: LD_INT 6
34900: LESS
34901: IFFALSE 35369
34903: GO 34905
34905: DISABLE
34906: LD_INT 0
34908: PPUSH
34909: PPUSH
// begin MC_Kill ( 1 ) ;
34910: LD_INT 1
34912: PPUSH
34913: CALL 39831 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34917: LD_INT 7
34919: PPUSH
34920: LD_INT 1
34922: PPUSH
34923: LD_INT 1
34925: PPUSH
34926: LD_INT 1
34928: PPUSH
34929: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34933: LD_ADDR_VAR 0 1
34937: PUSH
34938: LD_INT 22
34940: PUSH
34941: LD_INT 7
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 26
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PPUSH
34962: CALL_OW 69
34966: PUSH
34967: LD_EXP 79
34971: DIFF
34972: ST_TO_ADDR
// if tmp then
34973: LD_VAR 0 1
34977: IFFALSE 34995
// tmp := tmp [ 1 ] else
34979: LD_ADDR_VAR 0 1
34983: PUSH
34984: LD_VAR 0 1
34988: PUSH
34989: LD_INT 1
34991: ARRAY
34992: ST_TO_ADDR
34993: GO 35031
// begin uc_side := 7 ;
34995: LD_ADDR_OWVAR 20
34999: PUSH
35000: LD_INT 7
35002: ST_TO_ADDR
// uc_nation := 1 ;
35003: LD_ADDR_OWVAR 21
35007: PUSH
35008: LD_INT 1
35010: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35011: LD_INT 1
35013: PPUSH
35014: LD_INT 8
35016: PPUSH
35017: CALL_OW 384
// tmp := CreateHuman ;
35021: LD_ADDR_VAR 0 1
35025: PUSH
35026: CALL_OW 44
35030: ST_TO_ADDR
// end ; DialogueOn ;
35031: CALL_OW 6
// if IsOK ( Roth ) then
35035: LD_EXP 79
35039: PPUSH
35040: CALL_OW 302
35044: IFFALSE 35058
// Say ( JMM , DAb-JMM-1 ) ;
35046: LD_EXP 40
35050: PPUSH
35051: LD_STRING DAb-JMM-1
35053: PPUSH
35054: CALL_OW 88
// if IsOK ( Roth ) then
35058: LD_EXP 79
35062: PPUSH
35063: CALL_OW 302
35067: IFFALSE 35091
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35069: LD_EXP 79
35073: PPUSH
35074: LD_STRING DSurrenderAlliance-Roth-1
35076: PPUSH
35077: CALL_OW 88
// RothCaptured := true ;
35081: LD_ADDR_EXP 33
35085: PUSH
35086: LD_INT 1
35088: ST_TO_ADDR
// end else
35089: GO 35103
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35091: LD_VAR 0 1
35095: PPUSH
35096: LD_STRING DSurrenderAlliance-Sci1-1
35098: PPUSH
35099: CALL_OW 88
// DialogueOff ;
35103: CALL_OW 7
// allianceDestroyed := true ;
35107: LD_ADDR_EXP 23
35111: PUSH
35112: LD_INT 1
35114: ST_TO_ADDR
// if capturedUnit = 0 then
35115: LD_EXP 34
35119: PUSH
35120: LD_INT 0
35122: EQUAL
35123: IFFALSE 35132
// SetAchievement ( ACH_ALLIANCE ) ;
35125: LD_STRING ACH_ALLIANCE
35127: PPUSH
35128: CALL_OW 543
// if trueAmericans then
35132: LD_EXP 35
35136: IFFALSE 35212
// begin if trueAmericans = 1 then
35138: LD_EXP 35
35142: PUSH
35143: LD_INT 1
35145: EQUAL
35146: IFFALSE 35162
// Say ( JMM , DAb-JMM-1a ) else
35148: LD_EXP 40
35152: PPUSH
35153: LD_STRING DAb-JMM-1a
35155: PPUSH
35156: CALL_OW 88
35160: GO 35174
// Say ( JMM , DAb-JMM-1b ) ;
35162: LD_EXP 40
35166: PPUSH
35167: LD_STRING DAb-JMM-1b
35169: PPUSH
35170: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35174: LD_EXP 35
35178: PPUSH
35179: CALL_OW 87
// for i in trueAmericans do
35183: LD_ADDR_VAR 0 2
35187: PUSH
35188: LD_EXP 35
35192: PUSH
35193: FOR_IN
35194: IFFALSE 35210
// SetSide ( i , 1 ) ;
35196: LD_VAR 0 2
35200: PPUSH
35201: LD_INT 1
35203: PPUSH
35204: CALL_OW 235
35208: GO 35193
35210: POP
35211: POP
// end ; repeat wait ( 0 0$1 ) ;
35212: LD_INT 35
35214: PPUSH
35215: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35219: LD_ADDR_VAR 0 2
35223: PUSH
35224: LD_INT 22
35226: PUSH
35227: LD_INT 7
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 21
35236: PUSH
35237: LD_INT 1
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PPUSH
35248: CALL_OW 69
35252: PUSH
35253: FOR_IN
35254: IFFALSE 35336
// begin if IsInUnit ( i ) then
35256: LD_VAR 0 2
35260: PPUSH
35261: CALL_OW 310
35265: IFFALSE 35276
// ComExitBuilding ( i ) ;
35267: LD_VAR 0 2
35271: PPUSH
35272: CALL_OW 122
// if IsDriver ( i ) then
35276: LD_VAR 0 2
35280: PPUSH
35281: CALL 105577 0 1
35285: IFFALSE 35296
// ComExitVehicle ( i ) ;
35287: LD_VAR 0 2
35291: PPUSH
35292: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35296: LD_VAR 0 2
35300: PPUSH
35301: LD_INT 26
35303: PPUSH
35304: CALL_OW 308
35308: NOT
35309: IFFALSE 35325
// AddComMoveToArea ( i , allianceEscapeArea ) else
35311: LD_VAR 0 2
35315: PPUSH
35316: LD_INT 26
35318: PPUSH
35319: CALL_OW 173
35323: GO 35334
// RemoveUnit ( i ) ;
35325: LD_VAR 0 2
35329: PPUSH
35330: CALL_OW 64
// end ;
35334: GO 35253
35336: POP
35337: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35338: LD_INT 22
35340: PUSH
35341: LD_INT 7
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 21
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PPUSH
35362: CALL_OW 69
35366: NOT
35367: IFFALSE 35212
// end ;
35369: PPOPN 2
35371: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35372: LD_INT 0
35374: PPUSH
35375: PPUSH
// if not unit then
35376: LD_VAR 0 1
35380: NOT
35381: IFFALSE 35385
// exit ;
35383: GO 36899
// DoNotAttack ( 7 , unit ) ;
35385: LD_INT 7
35387: PPUSH
35388: LD_VAR 0 1
35392: PPUSH
35393: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35397: LD_VAR 0 1
35401: PPUSH
35402: LD_INT 260
35404: PPUSH
35405: LD_INT 235
35407: PPUSH
35408: LD_INT 3
35410: PPUSH
35411: LD_INT 1
35413: PPUSH
35414: CALL_OW 483
// SetSide ( unit , 4 ) ;
35418: LD_VAR 0 1
35422: PPUSH
35423: LD_INT 4
35425: PPUSH
35426: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35430: LD_ADDR_EXP 34
35434: PUSH
35435: LD_EXP 34
35439: PUSH
35440: LD_INT 1
35442: PLUS
35443: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35444: LD_INT 70
35446: PPUSH
35447: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35451: LD_INT 260
35453: PPUSH
35454: LD_INT 235
35456: PPUSH
35457: LD_INT 1
35459: PPUSH
35460: LD_INT 8
35462: NEG
35463: PPUSH
35464: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35468: LD_VAR 0 1
35472: PPUSH
35473: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35477: LD_VAR 0 1
35481: PPUSH
35482: LD_EXP 79
35486: PPUSH
35487: CALL_OW 119
// DialogueOn ;
35491: CALL_OW 6
// case unit of JMM :
35495: LD_VAR 0 1
35499: PUSH
35500: LD_EXP 40
35504: DOUBLE
35505: EQUAL
35506: IFTRUE 35510
35508: GO 35525
35510: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35511: LD_EXP 40
35515: PPUSH
35516: LD_STRING DA1-JMM-1
35518: PPUSH
35519: CALL_OW 91
35523: GO 35967
35525: LD_EXP 41
35529: DOUBLE
35530: EQUAL
35531: IFTRUE 35535
35533: GO 35550
35535: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35536: LD_EXP 41
35540: PPUSH
35541: LD_STRING DA1-Joan-1
35543: PPUSH
35544: CALL_OW 91
35548: GO 35967
35550: LD_EXP 43
35554: DOUBLE
35555: EQUAL
35556: IFTRUE 35560
35558: GO 35575
35560: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35561: LD_EXP 43
35565: PPUSH
35566: LD_STRING DA1-Lisa-1
35568: PPUSH
35569: CALL_OW 91
35573: GO 35967
35575: LD_EXP 44
35579: DOUBLE
35580: EQUAL
35581: IFTRUE 35585
35583: GO 35600
35585: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35586: LD_EXP 44
35590: PPUSH
35591: LD_STRING DA1-Don-1
35593: PPUSH
35594: CALL_OW 91
35598: GO 35967
35600: LD_EXP 51
35604: DOUBLE
35605: EQUAL
35606: IFTRUE 35610
35608: GO 35625
35610: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35611: LD_EXP 51
35615: PPUSH
35616: LD_STRING DA1-Corn-1
35618: PPUSH
35619: CALL_OW 91
35623: GO 35967
35625: LD_EXP 47
35629: DOUBLE
35630: EQUAL
35631: IFTRUE 35635
35633: GO 35650
35635: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35636: LD_EXP 47
35640: PPUSH
35641: LD_STRING DA1-Den-1
35643: PPUSH
35644: CALL_OW 91
35648: GO 35967
35650: LD_EXP 45
35654: DOUBLE
35655: EQUAL
35656: IFTRUE 35660
35658: GO 35675
35660: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35661: LD_EXP 45
35665: PPUSH
35666: LD_STRING DA1-Bobby-1
35668: PPUSH
35669: CALL_OW 91
35673: GO 35967
35675: LD_EXP 49
35679: DOUBLE
35680: EQUAL
35681: IFTRUE 35685
35683: GO 35700
35685: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35686: LD_EXP 49
35690: PPUSH
35691: LD_STRING DA1-Glad-1
35693: PPUSH
35694: CALL_OW 91
35698: GO 35967
35700: LD_EXP 46
35704: DOUBLE
35705: EQUAL
35706: IFTRUE 35710
35708: GO 35725
35710: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35711: LD_EXP 46
35715: PPUSH
35716: LD_STRING DA1-Cyrus-1
35718: PPUSH
35719: CALL_OW 91
35723: GO 35967
35725: LD_EXP 42
35729: DOUBLE
35730: EQUAL
35731: IFTRUE 35735
35733: GO 35750
35735: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35736: LD_EXP 42
35740: PPUSH
35741: LD_STRING DA1-Huck-1
35743: PPUSH
35744: CALL_OW 91
35748: GO 35967
35750: LD_EXP 56
35754: DOUBLE
35755: EQUAL
35756: IFTRUE 35760
35758: GO 35775
35760: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35761: LD_EXP 56
35765: PPUSH
35766: LD_STRING DA1-Huck-1
35768: PPUSH
35769: CALL_OW 91
35773: GO 35967
35775: LD_EXP 48
35779: DOUBLE
35780: EQUAL
35781: IFTRUE 35785
35783: GO 35800
35785: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35786: LD_EXP 48
35790: PPUSH
35791: LD_STRING DA1-Brown-1
35793: PPUSH
35794: CALL_OW 91
35798: GO 35967
35800: LD_EXP 52
35804: DOUBLE
35805: EQUAL
35806: IFTRUE 35810
35808: GO 35825
35810: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35811: LD_EXP 52
35815: PPUSH
35816: LD_STRING DA1-Gary-1
35818: PPUSH
35819: CALL_OW 91
35823: GO 35967
35825: LD_EXP 55
35829: DOUBLE
35830: EQUAL
35831: IFTRUE 35835
35833: GO 35850
35835: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35836: LD_EXP 55
35840: PPUSH
35841: LD_STRING DA1-Con-1
35843: PPUSH
35844: CALL_OW 91
35848: GO 35967
35850: LD_EXP 64
35854: DOUBLE
35855: EQUAL
35856: IFTRUE 35860
35858: GO 35875
35860: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35861: LD_EXP 64
35865: PPUSH
35866: LD_STRING DA1-Kurt-1
35868: PPUSH
35869: CALL_OW 91
35873: GO 35967
35875: LD_EXP 54
35879: DOUBLE
35880: EQUAL
35881: IFTRUE 35885
35883: GO 35900
35885: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35886: LD_EXP 54
35890: PPUSH
35891: LD_STRING DA1-Yam-1
35893: PPUSH
35894: CALL_OW 91
35898: GO 35967
35900: LD_EXP 53
35904: DOUBLE
35905: EQUAL
35906: IFTRUE 35910
35908: GO 35925
35910: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35911: LD_EXP 53
35915: PPUSH
35916: LD_STRING DA1-Frank-1
35918: PPUSH
35919: CALL_OW 91
35923: GO 35967
35925: POP
// begin if GetSex ( unit ) = sex_male then
35926: LD_VAR 0 1
35930: PPUSH
35931: CALL_OW 258
35935: PUSH
35936: LD_INT 1
35938: EQUAL
35939: IFFALSE 35955
// ForceSay ( unit , DA1-Sol1-1 ) else
35941: LD_VAR 0 1
35945: PPUSH
35946: LD_STRING DA1-Sol1-1
35948: PPUSH
35949: CALL_OW 91
35953: GO 35967
// ForceSay ( unit , DA1-FSol1-1 ) ;
35955: LD_VAR 0 1
35959: PPUSH
35960: LD_STRING DA1-FSol1-1
35962: PPUSH
35963: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35967: LD_EXP 79
35971: PPUSH
35972: LD_STRING DA-Roth-1
35974: PPUSH
35975: CALL_OW 88
// if capturedUnit = 1 then
35979: LD_EXP 34
35983: PUSH
35984: LD_INT 1
35986: EQUAL
35987: IFFALSE 36015
// begin Say ( Simms , DA-Sim-1 ) ;
35989: LD_EXP 80
35993: PPUSH
35994: LD_STRING DA-Sim-1
35996: PPUSH
35997: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36001: LD_EXP 79
36005: PPUSH
36006: LD_STRING DA-Roth-2
36008: PPUSH
36009: CALL_OW 88
// end else
36013: GO 36027
// Say ( Simms , DA-Sim-2 ) ;
36015: LD_EXP 80
36019: PPUSH
36020: LD_STRING DA-Sim-2
36022: PPUSH
36023: CALL_OW 88
// case unit of JMM :
36027: LD_VAR 0 1
36031: PUSH
36032: LD_EXP 40
36036: DOUBLE
36037: EQUAL
36038: IFTRUE 36042
36040: GO 36057
36042: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36043: LD_EXP 40
36047: PPUSH
36048: LD_STRING DA1-JMM-1a
36050: PPUSH
36051: CALL_OW 91
36055: GO 36574
36057: LD_EXP 41
36061: DOUBLE
36062: EQUAL
36063: IFTRUE 36067
36065: GO 36082
36067: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36068: LD_EXP 41
36072: PPUSH
36073: LD_STRING DA1-Joan-1a
36075: PPUSH
36076: CALL_OW 91
36080: GO 36574
36082: LD_EXP 43
36086: DOUBLE
36087: EQUAL
36088: IFTRUE 36092
36090: GO 36107
36092: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36093: LD_EXP 43
36097: PPUSH
36098: LD_STRING DA1-Lisa-1a
36100: PPUSH
36101: CALL_OW 91
36105: GO 36574
36107: LD_EXP 44
36111: DOUBLE
36112: EQUAL
36113: IFTRUE 36117
36115: GO 36132
36117: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36118: LD_EXP 44
36122: PPUSH
36123: LD_STRING DA1-Don-1a
36125: PPUSH
36126: CALL_OW 91
36130: GO 36574
36132: LD_EXP 51
36136: DOUBLE
36137: EQUAL
36138: IFTRUE 36142
36140: GO 36157
36142: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36143: LD_EXP 51
36147: PPUSH
36148: LD_STRING DA1-Corn-1a
36150: PPUSH
36151: CALL_OW 91
36155: GO 36574
36157: LD_EXP 47
36161: DOUBLE
36162: EQUAL
36163: IFTRUE 36167
36165: GO 36182
36167: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36168: LD_EXP 47
36172: PPUSH
36173: LD_STRING DA1-Den-1a
36175: PPUSH
36176: CALL_OW 91
36180: GO 36574
36182: LD_EXP 45
36186: DOUBLE
36187: EQUAL
36188: IFTRUE 36192
36190: GO 36207
36192: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36193: LD_EXP 45
36197: PPUSH
36198: LD_STRING DA1-Bobby-1a
36200: PPUSH
36201: CALL_OW 91
36205: GO 36574
36207: LD_EXP 49
36211: DOUBLE
36212: EQUAL
36213: IFTRUE 36217
36215: GO 36232
36217: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36218: LD_EXP 49
36222: PPUSH
36223: LD_STRING DA1-Glad-1a
36225: PPUSH
36226: CALL_OW 91
36230: GO 36574
36232: LD_EXP 46
36236: DOUBLE
36237: EQUAL
36238: IFTRUE 36242
36240: GO 36257
36242: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36243: LD_EXP 46
36247: PPUSH
36248: LD_STRING DA1-Cyrus-1a
36250: PPUSH
36251: CALL_OW 91
36255: GO 36574
36257: LD_EXP 42
36261: DOUBLE
36262: EQUAL
36263: IFTRUE 36267
36265: GO 36282
36267: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36268: LD_EXP 42
36272: PPUSH
36273: LD_STRING DA1-Huck-1a
36275: PPUSH
36276: CALL_OW 91
36280: GO 36574
36282: LD_EXP 56
36286: DOUBLE
36287: EQUAL
36288: IFTRUE 36292
36290: GO 36307
36292: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36293: LD_EXP 56
36297: PPUSH
36298: LD_STRING DA1-Huck-1a
36300: PPUSH
36301: CALL_OW 91
36305: GO 36574
36307: LD_EXP 48
36311: DOUBLE
36312: EQUAL
36313: IFTRUE 36317
36315: GO 36332
36317: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36318: LD_EXP 48
36322: PPUSH
36323: LD_STRING DA1-Brown-1a
36325: PPUSH
36326: CALL_OW 91
36330: GO 36574
36332: LD_EXP 52
36336: DOUBLE
36337: EQUAL
36338: IFTRUE 36342
36340: GO 36357
36342: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36343: LD_EXP 52
36347: PPUSH
36348: LD_STRING DA1-Gary-1a
36350: PPUSH
36351: CALL_OW 91
36355: GO 36574
36357: LD_EXP 55
36361: DOUBLE
36362: EQUAL
36363: IFTRUE 36367
36365: GO 36392
36367: POP
// if JMMGirl = 3 then
36368: LD_EXP 7
36372: PUSH
36373: LD_INT 3
36375: EQUAL
36376: IFFALSE 36390
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36378: LD_EXP 55
36382: PPUSH
36383: LD_STRING DA1-Con-1a
36385: PPUSH
36386: CALL_OW 91
36390: GO 36574
36392: LD_EXP 64
36396: DOUBLE
36397: EQUAL
36398: IFTRUE 36402
36400: GO 36417
36402: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36403: LD_EXP 64
36407: PPUSH
36408: LD_STRING DA1-Kurt-1a
36410: PPUSH
36411: CALL_OW 91
36415: GO 36574
36417: LD_EXP 54
36421: DOUBLE
36422: EQUAL
36423: IFTRUE 36427
36425: GO 36442
36427: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36428: LD_EXP 54
36432: PPUSH
36433: LD_STRING DA1-Yam-1a
36435: PPUSH
36436: CALL_OW 91
36440: GO 36574
36442: LD_EXP 53
36446: DOUBLE
36447: EQUAL
36448: IFTRUE 36452
36450: GO 36467
36452: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36453: LD_EXP 53
36457: PPUSH
36458: LD_STRING DA1-Frank-1a
36460: PPUSH
36461: CALL_OW 91
36465: GO 36574
36467: POP
// begin join := rand ( 0 , 1 ) ;
36468: LD_ADDR_VAR 0 3
36472: PUSH
36473: LD_INT 0
36475: PPUSH
36476: LD_INT 1
36478: PPUSH
36479: CALL_OW 12
36483: ST_TO_ADDR
// if join then
36484: LD_VAR 0 3
36488: IFFALSE 36533
// begin if GetSex ( unit ) = sex_male then
36490: LD_VAR 0 1
36494: PPUSH
36495: CALL_OW 258
36499: PUSH
36500: LD_INT 1
36502: EQUAL
36503: IFFALSE 36519
// ForceSay ( unit , DA1-Sol1-1b ) else
36505: LD_VAR 0 1
36509: PPUSH
36510: LD_STRING DA1-Sol1-1b
36512: PPUSH
36513: CALL_OW 91
36517: GO 36531
// ForceSay ( unit , DA1-FSol1-1b ) ;
36519: LD_VAR 0 1
36523: PPUSH
36524: LD_STRING DA1-FSol1-1b
36526: PPUSH
36527: CALL_OW 91
// end else
36531: GO 36574
// begin if GetSex ( unit ) = sex_male then
36533: LD_VAR 0 1
36537: PPUSH
36538: CALL_OW 258
36542: PUSH
36543: LD_INT 1
36545: EQUAL
36546: IFFALSE 36562
// ForceSay ( unit , DA1-Sol1-1a ) else
36548: LD_VAR 0 1
36552: PPUSH
36553: LD_STRING DA1-Sol1-1a
36555: PPUSH
36556: CALL_OW 91
36560: GO 36574
// ForceSay ( unit , DA1-FSol1-1a ) ;
36562: LD_VAR 0 1
36566: PPUSH
36567: LD_STRING DA1-FSol1-1a
36569: PPUSH
36570: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36574: LD_VAR 0 1
36578: PUSH
36579: LD_EXP 40
36583: EQUAL
36584: IFFALSE 36595
// begin YouLost ( JMMCaptured ) ;
36586: LD_STRING JMMCaptured
36588: PPUSH
36589: CALL_OW 104
// exit ;
36593: GO 36899
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36595: LD_VAR 0 1
36599: PUSH
36600: LD_EXP 44
36604: PUSH
36605: LD_EXP 47
36609: PUSH
36610: LD_EXP 45
36614: PUSH
36615: LD_EXP 42
36619: PUSH
36620: LD_EXP 56
36624: PUSH
36625: LD_EXP 48
36629: PUSH
36630: LD_EXP 54
36634: PUSH
36635: LD_EXP 58
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: IN
36650: PUSH
36651: LD_VAR 0 3
36655: OR
36656: IFFALSE 36755
// begin Say ( Roth , DA-Roth-3 ) ;
36658: LD_EXP 79
36662: PPUSH
36663: LD_STRING DA-Roth-3
36665: PPUSH
36666: CALL_OW 88
// SetSide ( unit , 7 ) ;
36670: LD_VAR 0 1
36674: PPUSH
36675: LD_INT 7
36677: PPUSH
36678: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36682: LD_ADDR_EXP 102
36686: PUSH
36687: LD_EXP 102
36691: PPUSH
36692: LD_INT 1
36694: PPUSH
36695: LD_EXP 102
36699: PUSH
36700: LD_INT 1
36702: ARRAY
36703: PUSH
36704: LD_VAR 0 1
36708: ADD
36709: PPUSH
36710: CALL_OW 1
36714: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36715: LD_INT 260
36717: PPUSH
36718: LD_INT 235
36720: PPUSH
36721: LD_INT 1
36723: PPUSH
36724: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36728: LD_VAR 0 1
36732: PPUSH
36733: LD_INT 1000
36735: PPUSH
36736: CALL_OW 234
// DialogueOff ;
36740: CALL_OW 7
// ComFree ( unit ) ;
36744: LD_VAR 0 1
36748: PPUSH
36749: CALL_OW 139
// end else
36753: GO 36836
// begin Say ( Roth , DA-Roth-3a ) ;
36755: LD_EXP 79
36759: PPUSH
36760: LD_STRING DA-Roth-3a
36762: PPUSH
36763: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36767: LD_ADDR_EXP 35
36771: PUSH
36772: LD_EXP 35
36776: PUSH
36777: LD_VAR 0 1
36781: ADD
36782: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36783: LD_INT 260
36785: PPUSH
36786: LD_INT 235
36788: PPUSH
36789: LD_INT 1
36791: PPUSH
36792: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36796: LD_VAR 0 1
36800: PPUSH
36801: LD_INT 1000
36803: PPUSH
36804: CALL_OW 234
// DialogueOff ;
36808: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36812: LD_VAR 0 1
36816: PPUSH
36817: LD_INT 272
36819: PPUSH
36820: LD_INT 254
36822: PPUSH
36823: CALL_OW 111
// AddComHold ( unit ) ;
36827: LD_VAR 0 1
36831: PPUSH
36832: CALL_OW 200
// end ; if capturedUnit = 1 then
36836: LD_EXP 34
36840: PUSH
36841: LD_INT 1
36843: EQUAL
36844: IFFALSE 36899
// begin DialogueOn ;
36846: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36850: LD_EXP 40
36854: PPUSH
36855: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36859: LD_EXP 40
36863: PPUSH
36864: LD_STRING DAa-JMM-1
36866: PPUSH
36867: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36871: LD_EXP 40
36875: PPUSH
36876: LD_STRING DAa-JMM-1a
36878: PPUSH
36879: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36883: LD_EXP 40
36887: PPUSH
36888: LD_STRING DAa-JMM-1b
36890: PPUSH
36891: CALL_OW 88
// DialogueOff ;
36895: CALL_OW 7
// end ; end ;
36899: LD_VAR 0 2
36903: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36904: LD_EXP 15
36908: PUSH
36909: LD_INT 13
36911: GREATEREQUAL
36912: PUSH
36913: LD_INT 22
36915: PUSH
36916: LD_INT 2
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 21
36925: PUSH
36926: LD_INT 1
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PPUSH
36937: CALL_OW 69
36941: PUSH
36942: LD_INT 0
36944: EQUAL
36945: AND
36946: PUSH
36947: LD_INT 22
36949: PUSH
36950: LD_INT 2
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 33
36959: PUSH
36960: LD_INT 5
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 21
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: LD_INT 50
36979: PUSH
36980: EMPTY
36981: LIST
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: PPUSH
36989: CALL_OW 69
36993: PUSH
36994: LD_INT 0
36996: EQUAL
36997: AND
36998: PUSH
36999: LD_EXP 21
37003: AND
37004: PUSH
37005: LD_EXP 22
37009: AND
37010: PUSH
37011: LD_EXP 23
37015: AND
37016: IFFALSE 37785
37018: GO 37020
37020: DISABLE
37021: LD_INT 0
37023: PPUSH
37024: PPUSH
37025: PPUSH
// begin wait ( 0 0$05 ) ;
37026: LD_INT 175
37028: PPUSH
37029: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37033: LD_INT 22
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 21
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 23
37055: PUSH
37056: LD_INT 1
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 50
37065: PUSH
37066: EMPTY
37067: LIST
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: PPUSH
37075: CALL_OW 69
37079: PPUSH
37080: CALL 72384 0 1
37084: PUSH
37085: LD_INT 2
37087: LESS
37088: IFFALSE 37099
// begin YouLost ( LostVictory ) ;
37090: LD_STRING LostVictory
37092: PPUSH
37093: CALL_OW 104
// exit ;
37097: GO 37785
// end ; m1 := false ;
37099: LD_ADDR_VAR 0 1
37103: PUSH
37104: LD_INT 0
37106: ST_TO_ADDR
// m2 := false ;
37107: LD_ADDR_VAR 0 2
37111: PUSH
37112: LD_INT 0
37114: ST_TO_ADDR
// m3 := false ;
37115: LD_ADDR_VAR 0 3
37119: PUSH
37120: LD_INT 0
37122: ST_TO_ADDR
// if not bombExploded then
37123: LD_EXP 37
37127: NOT
37128: IFFALSE 37137
// SetAchievement ( ACH_SIBROCKET ) ;
37130: LD_STRING ACH_SIBROCKET
37132: PPUSH
37133: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37137: LD_EXP 66
37141: PPUSH
37142: CALL_OW 255
37146: PUSH
37147: LD_INT 1
37149: EQUAL
37150: PUSH
37151: LD_EXP 66
37155: PPUSH
37156: CALL_OW 302
37160: AND
37161: IFFALSE 37177
// begin wait ( 3 ) ;
37163: LD_INT 3
37165: PPUSH
37166: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37170: LD_STRING ACH_OPO
37172: PPUSH
37173: CALL_OW 543
// end ; if tick <= 120 120$00 then
37177: LD_OWVAR 1
37181: PUSH
37182: LD_INT 252000
37184: LESSEQUAL
37185: IFFALSE 37201
// begin wait ( 3 ) ;
37187: LD_INT 3
37189: PPUSH
37190: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37194: LD_STRING ACH_ASPEED_15
37196: PPUSH
37197: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37201: LD_EXP 40
37205: PPUSH
37206: CALL_OW 87
// music_class := 5 ;
37210: LD_ADDR_OWVAR 72
37214: PUSH
37215: LD_INT 5
37217: ST_TO_ADDR
// music_nat := 5 ;
37218: LD_ADDR_OWVAR 71
37222: PUSH
37223: LD_INT 5
37225: ST_TO_ADDR
// DialogueOn ;
37226: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37230: LD_EXP 40
37234: PPUSH
37235: LD_STRING D20-JMM-1
37237: PPUSH
37238: CALL_OW 88
// if IsOK ( Joan ) then
37242: LD_EXP 41
37246: PPUSH
37247: CALL_OW 302
37251: IFFALSE 37265
// Say ( Joan , D20-Joan-1 ) ;
37253: LD_EXP 41
37257: PPUSH
37258: LD_STRING D20-Joan-1
37260: PPUSH
37261: CALL_OW 88
// if IsOk ( Lisa ) then
37265: LD_EXP 43
37269: PPUSH
37270: CALL_OW 302
37274: IFFALSE 37288
// Say ( Lisa , D20-Lisa-1 ) ;
37276: LD_EXP 43
37280: PPUSH
37281: LD_STRING D20-Lisa-1
37283: PPUSH
37284: CALL_OW 88
// if IsOk ( Donaldson ) then
37288: LD_EXP 44
37292: PPUSH
37293: CALL_OW 302
37297: IFFALSE 37311
// Say ( Donaldson , D20-Don-1 ) ;
37299: LD_EXP 44
37303: PPUSH
37304: LD_STRING D20-Don-1
37306: PPUSH
37307: CALL_OW 88
// if IsOK ( Cornel ) then
37311: LD_EXP 51
37315: PPUSH
37316: CALL_OW 302
37320: IFFALSE 37334
// Say ( Cornel , D20-Corn-1 ) ;
37322: LD_EXP 51
37326: PPUSH
37327: LD_STRING D20-Corn-1
37329: PPUSH
37330: CALL_OW 88
// if IsOk ( Denis ) then
37334: LD_EXP 47
37338: PPUSH
37339: CALL_OW 302
37343: IFFALSE 37357
// Say ( Denis , D20-Den-1 ) ;
37345: LD_EXP 47
37349: PPUSH
37350: LD_STRING D20-Den-1
37352: PPUSH
37353: CALL_OW 88
// if IsOk ( Bobby ) then
37357: LD_EXP 45
37361: PPUSH
37362: CALL_OW 302
37366: IFFALSE 37380
// Say ( Bobby , D20-Bobby-1 ) ;
37368: LD_EXP 45
37372: PPUSH
37373: LD_STRING D20-Bobby-1
37375: PPUSH
37376: CALL_OW 88
// if IsOk ( Gladstone ) then
37380: LD_EXP 49
37384: PPUSH
37385: CALL_OW 302
37389: IFFALSE 37403
// Say ( Gladstone , D20-Glad-1 ) ;
37391: LD_EXP 49
37395: PPUSH
37396: LD_STRING D20-Glad-1
37398: PPUSH
37399: CALL_OW 88
// if IsOk ( Cyrus ) then
37403: LD_EXP 46
37407: PPUSH
37408: CALL_OW 302
37412: IFFALSE 37426
// Say ( Cyrus , D20-Cyrus-1 ) ;
37414: LD_EXP 46
37418: PPUSH
37419: LD_STRING D20-Cyrus-1
37421: PPUSH
37422: CALL_OW 88
// if IsOk ( Stevens ) then
37426: LD_EXP 42
37430: PPUSH
37431: CALL_OW 302
37435: IFFALSE 37449
// Say ( Stevens , D20-Huck-1 ) ;
37437: LD_EXP 42
37441: PPUSH
37442: LD_STRING D20-Huck-1
37444: PPUSH
37445: CALL_OW 88
// if IsOk ( Brown ) then
37449: LD_EXP 48
37453: PPUSH
37454: CALL_OW 302
37458: IFFALSE 37472
// Say ( Brown , D20-Brown-1 ) ;
37460: LD_EXP 48
37464: PPUSH
37465: LD_STRING D20-Brown-1
37467: PPUSH
37468: CALL_OW 88
// if IsOk ( Gary ) then
37472: LD_EXP 52
37476: PPUSH
37477: CALL_OW 302
37481: IFFALSE 37495
// Say ( Gary , D20-Gary-1 ) ;
37483: LD_EXP 52
37487: PPUSH
37488: LD_STRING D20-Gary-1
37490: PPUSH
37491: CALL_OW 88
// if IsOk ( Connie ) then
37495: LD_EXP 55
37499: PPUSH
37500: CALL_OW 302
37504: IFFALSE 37518
// Say ( Connie , D20-Con-1 ) ;
37506: LD_EXP 55
37510: PPUSH
37511: LD_STRING D20-Con-1
37513: PPUSH
37514: CALL_OW 88
// if IsOk ( Kurt ) then
37518: LD_EXP 64
37522: PPUSH
37523: CALL_OW 302
37527: IFFALSE 37541
// Say ( Kurt , D20-Kurt-1 ) ;
37529: LD_EXP 64
37533: PPUSH
37534: LD_STRING D20-Kurt-1
37536: PPUSH
37537: CALL_OW 88
// if IsOk ( Kikuchi ) then
37541: LD_EXP 54
37545: PPUSH
37546: CALL_OW 302
37550: IFFALSE 37564
// Say ( Kikuchi , D20-Yam-1 ) ;
37552: LD_EXP 54
37556: PPUSH
37557: LD_STRING D20-Yam-1
37559: PPUSH
37560: CALL_OW 88
// if IsOk ( Frank ) then
37564: LD_EXP 53
37568: PPUSH
37569: CALL_OW 302
37573: IFFALSE 37587
// Say ( Frank , D20-Frank-1 ) ;
37575: LD_EXP 53
37579: PPUSH
37580: LD_STRING D20-Frank-1
37582: PPUSH
37583: CALL_OW 88
// DialogueOff ;
37587: CALL_OW 7
// if RothCaptured then
37591: LD_EXP 33
37595: IFFALSE 37617
// begin m1 := true ;
37597: LD_ADDR_VAR 0 1
37601: PUSH
37602: LD_INT 1
37604: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37605: LD_STRING Roth
37607: PPUSH
37608: LD_INT 1
37610: PPUSH
37611: CALL_OW 101
// end else
37615: GO 37628
// AddMedal ( Roth , - 1 ) ;
37617: LD_STRING Roth
37619: PPUSH
37620: LD_INT 1
37622: NEG
37623: PPUSH
37624: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37628: LD_EXP 25
37632: NOT
37633: PUSH
37634: LD_EXP 27
37638: OR
37639: PUSH
37640: LD_EXP 28
37644: NOT
37645: OR
37646: IFFALSE 37668
// begin m2 := true ;
37648: LD_ADDR_VAR 0 2
37652: PUSH
37653: LD_INT 1
37655: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37656: LD_STRING Project
37658: PPUSH
37659: LD_INT 1
37661: PPUSH
37662: CALL_OW 101
// end else
37666: GO 37679
// AddMedal ( Project , - 1 ) ;
37668: LD_STRING Project
37670: PPUSH
37671: LD_INT 1
37673: NEG
37674: PPUSH
37675: CALL_OW 101
// if lostCounter = 0 then
37679: LD_EXP 32
37683: PUSH
37684: LD_INT 0
37686: EQUAL
37687: IFFALSE 37709
// begin m3 := true ;
37689: LD_ADDR_VAR 0 3
37693: PUSH
37694: LD_INT 1
37696: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37697: LD_STRING NoLosses
37699: PPUSH
37700: LD_INT 1
37702: PPUSH
37703: CALL_OW 101
// end else
37707: GO 37720
// AddMedal ( NoLosses , - 1 ) ;
37709: LD_STRING NoLosses
37711: PPUSH
37712: LD_INT 1
37714: NEG
37715: PPUSH
37716: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37720: LD_VAR 0 1
37724: PUSH
37725: LD_VAR 0 2
37729: AND
37730: PUSH
37731: LD_VAR 0 3
37735: AND
37736: PUSH
37737: LD_OWVAR 67
37741: PUSH
37742: LD_INT 3
37744: GREATEREQUAL
37745: AND
37746: IFFALSE 37758
// SetAchievementEX ( ACH_AMER , 15 ) ;
37748: LD_STRING ACH_AMER
37750: PPUSH
37751: LD_INT 15
37753: PPUSH
37754: CALL_OW 564
// GiveMedals ( MAIN ) ;
37758: LD_STRING MAIN
37760: PPUSH
37761: CALL_OW 102
// music_class := 4 ;
37765: LD_ADDR_OWVAR 72
37769: PUSH
37770: LD_INT 4
37772: ST_TO_ADDR
// music_nat := 1 ;
37773: LD_ADDR_OWVAR 71
37777: PUSH
37778: LD_INT 1
37780: ST_TO_ADDR
// YouWin ;
37781: CALL_OW 103
// end ; end_of_file
37785: PPOPN 3
37787: END
// export function CustomEvent ( event ) ; begin
37788: LD_INT 0
37790: PPUSH
// end ;
37791: LD_VAR 0 2
37795: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37796: LD_VAR 0 1
37800: PUSH
37801: LD_INT 1
37803: EQUAL
37804: PUSH
37805: LD_VAR 0 2
37809: PUSH
37810: LD_INT 4
37812: EQUAL
37813: AND
37814: PUSH
37815: LD_EXP 61
37819: PPUSH
37820: CALL_OW 300
37824: AND
37825: IFFALSE 37841
// begin wait ( 0 0$2 ) ;
37827: LD_INT 70
37829: PPUSH
37830: CALL_OW 67
// YouLost ( Dismissed ) ;
37834: LD_STRING Dismissed
37836: PPUSH
37837: CALL_OW 104
// end ; end ;
37841: PPOPN 2
37843: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37844: LD_VAR 0 2
37848: PPUSH
37849: LD_VAR 0 3
37853: PPUSH
37854: LD_INT 18
37856: PPUSH
37857: CALL_OW 309
37861: IFFALSE 37870
// YouLost ( Motherlode3 ) ;
37863: LD_STRING Motherlode3
37865: PPUSH
37866: CALL_OW 104
// end ;
37870: PPOPN 3
37872: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37873: LD_EXP 27
37877: NOT
37878: IFFALSE 37888
// behemothDone := true ;
37880: LD_ADDR_EXP 28
37884: PUSH
37885: LD_INT 1
37887: ST_TO_ADDR
// end ;
37888: PPOPN 1
37890: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37891: LD_VAR 0 1
37895: PPUSH
37896: CALL_OW 255
37900: PUSH
37901: LD_INT 1
37903: EQUAL
37904: IFFALSE 37914
// bombExploded := true ;
37906: LD_ADDR_EXP 37
37910: PUSH
37911: LD_INT 1
37913: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37914: LD_VAR 0 1
37918: PPUSH
37919: CALL_OW 255
37923: PUSH
37924: LD_INT 3
37926: EQUAL
37927: IFFALSE 37957
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37929: LD_INT 2
37931: PPUSH
37932: LD_INT 23
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: LD_INT 3
37940: PUSH
37941: LD_INT 48
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: PPUSH
37953: CALL 63856 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37957: LD_VAR 0 1
37961: PPUSH
37962: CALL_OW 255
37966: PUSH
37967: LD_INT 1
37969: EQUAL
37970: PUSH
37971: LD_EXP 66
37975: PPUSH
37976: CALL_OW 255
37980: PUSH
37981: LD_INT 1
37983: EQUAL
37984: AND
37985: PUSH
37986: LD_EXP 66
37990: PPUSH
37991: CALL_OW 302
37995: AND
37996: PUSH
37997: LD_EXP 30
38001: AND
38002: PUSH
38003: LD_INT 22
38005: PUSH
38006: LD_INT 3
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 34
38015: PUSH
38016: LD_INT 48
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PPUSH
38027: CALL_OW 69
38031: AND
38032: PUSH
38033: LD_INT 22
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 34
38045: PUSH
38046: LD_INT 8
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PPUSH
38057: CALL_OW 69
38061: NOT
38062: AND
38063: IFFALSE 38115
// begin wait ( 0 0$5 ) ;
38065: LD_INT 175
38067: PPUSH
38068: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38072: LD_INT 22
38074: PUSH
38075: LD_INT 3
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 34
38084: PUSH
38085: LD_INT 48
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PPUSH
38096: CALL_OW 69
38100: PUSH
38101: LD_INT 1
38103: ARRAY
38104: PPUSH
38105: LD_INT 60
38107: PPUSH
38108: LD_INT 95
38110: PPUSH
38111: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38115: LD_VAR 0 2
38119: PPUSH
38120: LD_VAR 0 3
38124: PPUSH
38125: LD_INT 18
38127: PPUSH
38128: CALL_OW 309
38132: PUSH
38133: LD_VAR 0 2
38137: PPUSH
38138: LD_VAR 0 3
38142: PPUSH
38143: LD_INT 18
38145: PPUSH
38146: CALL 111786 0 3
38150: OR
38151: IFFALSE 38198
// begin if GetSide ( unit ) = 1 then
38153: LD_VAR 0 1
38157: PPUSH
38158: CALL_OW 255
38162: PUSH
38163: LD_INT 1
38165: EQUAL
38166: IFFALSE 38184
// begin wait ( 0 0$6 ) ;
38168: LD_INT 210
38170: PPUSH
38171: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38175: LD_STRING Motherlode2
38177: PPUSH
38178: CALL_OW 104
// end else
38182: GO 38198
// begin wait ( 0 0$6 ) ;
38184: LD_INT 210
38186: PPUSH
38187: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38191: LD_STRING Motherlode1
38193: PPUSH
38194: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38198: LD_VAR 0 1
38202: PPUSH
38203: CALL_OW 255
38207: PUSH
38208: LD_INT 3
38210: EQUAL
38211: IFFALSE 38232
// begin wait ( 0 0$5 ) ;
38213: LD_INT 175
38215: PPUSH
38216: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38220: LD_EXP 68
38224: PPUSH
38225: LD_STRING D18-Pla-1
38227: PPUSH
38228: CALL_OW 94
// end ; end ;
38232: PPOPN 3
38234: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38235: LD_VAR 0 1
38239: PPUSH
38240: CALL 128876 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38244: LD_VAR 0 1
38248: PUSH
38249: LD_INT 22
38251: PUSH
38252: LD_INT 1
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 21
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 23
38271: PUSH
38272: LD_INT 1
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: LIST
38283: PPUSH
38284: CALL_OW 69
38288: IN
38289: IFFALSE 38305
// lostCounter := lostCounter + 1 ;
38291: LD_ADDR_EXP 32
38295: PUSH
38296: LD_EXP 32
38300: PUSH
38301: LD_INT 1
38303: PLUS
38304: ST_TO_ADDR
// if un in behemothBuilders then
38305: LD_VAR 0 1
38309: PUSH
38310: LD_EXP 77
38314: IN
38315: IFFALSE 38335
// begin behemothBuilders := behemothBuilders diff un ;
38317: LD_ADDR_EXP 77
38321: PUSH
38322: LD_EXP 77
38326: PUSH
38327: LD_VAR 0 1
38331: DIFF
38332: ST_TO_ADDR
// exit ;
38333: GO 38365
// end ; if un = JMM then
38335: LD_VAR 0 1
38339: PUSH
38340: LD_EXP 40
38344: EQUAL
38345: IFFALSE 38356
// begin YouLost ( JMM ) ;
38347: LD_STRING JMM
38349: PPUSH
38350: CALL_OW 104
// exit ;
38354: GO 38365
// end ; MCE_UnitDestroyed ( un ) ;
38356: LD_VAR 0 1
38360: PPUSH
38361: CALL 67298 0 1
// end ;
38365: PPOPN 1
38367: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38368: LD_VAR 0 1
38372: PPUSH
38373: LD_VAR 0 2
38377: PPUSH
38378: CALL 69630 0 2
// end ;
38382: PPOPN 2
38384: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38385: LD_VAR 0 1
38389: PPUSH
38390: CALL 68698 0 1
// end ;
38394: PPOPN 1
38396: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38397: LD_VAR 0 1
38401: PUSH
38402: LD_INT 22
38404: PUSH
38405: LD_INT 8
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 30
38414: PUSH
38415: LD_INT 2
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 23
38424: PUSH
38425: LD_INT 3
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: LIST
38436: PPUSH
38437: CALL_OW 69
38441: IN
38442: IFFALSE 38469
// begin ComUpgrade ( building ) ;
38444: LD_VAR 0 1
38448: PPUSH
38449: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38453: LD_EXP 65
38457: PPUSH
38458: LD_VAR 0 1
38462: PPUSH
38463: CALL 78482 0 2
// exit ;
38467: GO 38478
// end ; MCE_BuildingComplete ( building ) ;
38469: LD_VAR 0 1
38473: PPUSH
38474: CALL 68939 0 1
// end ;
38478: PPOPN 1
38480: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38481: LD_VAR 0 1
38485: PPUSH
38486: LD_VAR 0 2
38490: PPUSH
38491: CALL 66994 0 2
// end ;
38495: PPOPN 2
38497: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38498: LD_VAR 0 1
38502: PPUSH
38503: LD_VAR 0 2
38507: PPUSH
38508: LD_VAR 0 3
38512: PPUSH
38513: LD_VAR 0 4
38517: PPUSH
38518: LD_VAR 0 5
38522: PPUSH
38523: CALL 66614 0 5
// end ;
38527: PPOPN 5
38529: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38530: LD_VAR 0 1
38534: PPUSH
38535: CALL_OW 255
38539: PUSH
38540: LD_INT 1
38542: EQUAL
38543: IFFALSE 38560
// amConstructCounter := Inc ( amConstructCounter ) ;
38545: LD_ADDR_EXP 39
38549: PUSH
38550: LD_EXP 39
38554: PPUSH
38555: CALL 109334 0 1
38559: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38560: LD_VAR 0 1
38564: PPUSH
38565: LD_VAR 0 2
38569: PPUSH
38570: CALL 128996 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38574: LD_VAR 0 1
38578: PPUSH
38579: LD_VAR 0 2
38583: PPUSH
38584: CALL 66167 0 2
// end ;
38588: PPOPN 2
38590: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38591: LD_VAR 0 1
38595: PPUSH
38596: LD_VAR 0 2
38600: PPUSH
38601: LD_VAR 0 3
38605: PPUSH
38606: LD_VAR 0 4
38610: PPUSH
38611: CALL 66005 0 4
// end ;
38615: PPOPN 4
38617: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38618: LD_VAR 0 1
38622: PPUSH
38623: LD_VAR 0 2
38627: PPUSH
38628: LD_VAR 0 3
38632: PPUSH
38633: CALL 65780 0 3
// end ;
38637: PPOPN 3
38639: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38640: LD_VAR 0 1
38644: PPUSH
38645: LD_VAR 0 2
38649: PPUSH
38650: CALL 65665 0 2
// end ;
38654: PPOPN 2
38656: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38657: LD_VAR 0 1
38661: PPUSH
38662: LD_VAR 0 2
38666: PPUSH
38667: CALL 69925 0 2
// end ;
38671: PPOPN 2
38673: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38674: LD_VAR 0 1
38678: PUSH
38679: LD_INT 460
38681: EQUAL
38682: IFFALSE 38704
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38684: LD_VAR 0 2
38688: PPUSH
38689: LD_INT 227
38691: PPUSH
38692: LD_INT 136
38694: PPUSH
38695: CALL_OW 428
38699: PPUSH
38700: CALL_OW 120
// end ;
38704: PPOPN 2
38706: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38707: LD_VAR 0 1
38711: PPUSH
38712: CALL_OW 255
38716: PUSH
38717: LD_INT 4
38719: EQUAL
38720: PUSH
38721: LD_VAR 0 1
38725: PUSH
38726: LD_EXP 18
38730: PUSH
38731: LD_INT 1
38733: ARRAY
38734: IN
38735: AND
38736: PUSH
38737: LD_EXP 19
38741: AND
38742: IFFALSE 38761
// begin ComMoveXY ( driver , 61 , 93 ) ;
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 61
38751: PPUSH
38752: LD_INT 93
38754: PPUSH
38755: CALL_OW 111
// exit ;
38759: GO 38830
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38761: LD_VAR 0 1
38765: PPUSH
38766: CALL_OW 255
38770: PUSH
38771: LD_INT 3
38773: EQUAL
38774: PUSH
38775: LD_VAR 0 1
38779: PPUSH
38780: CALL_OW 110
38784: PUSH
38785: LD_INT 105
38787: EQUAL
38788: AND
38789: IFFALSE 38806
// begin ComMoveXY ( driver , 187 , 92 ) ;
38791: LD_VAR 0 1
38795: PPUSH
38796: LD_INT 187
38798: PPUSH
38799: LD_INT 92
38801: PPUSH
38802: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38806: LD_VAR 0 1
38810: PPUSH
38811: LD_VAR 0 2
38815: PPUSH
38816: LD_VAR 0 3
38820: PPUSH
38821: LD_VAR 0 4
38825: PPUSH
38826: CALL 70141 0 4
// end ;
38830: PPOPN 4
38832: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38833: LD_VAR 0 1
38837: PPUSH
38838: LD_VAR 0 2
38842: PPUSH
38843: CALL 65474 0 2
// end ;
38847: PPOPN 2
38849: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38850: LD_VAR 0 1
38854: PPUSH
38855: CALL 128980 0 1
// end ; end_of_file
38859: PPOPN 1
38861: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38862: LD_EXP 15
38866: PUSH
38867: LD_INT 2
38869: EQUAL
38870: IFFALSE 39387
38872: GO 38874
38874: DISABLE
38875: LD_INT 0
38877: PPUSH
38878: PPUSH
// begin time := 0 0$35 ;
38879: LD_ADDR_VAR 0 2
38883: PUSH
38884: LD_INT 1225
38886: ST_TO_ADDR
// repeat wait ( time ) ;
38887: LD_VAR 0 2
38891: PPUSH
38892: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38896: LD_INT 1
38898: PPUSH
38899: LD_INT 5
38901: PPUSH
38902: CALL_OW 12
38906: PPUSH
38907: LD_INT 106
38909: PPUSH
38910: LD_INT 150
38912: PPUSH
38913: LD_INT 19
38915: PPUSH
38916: LD_INT 1
38918: PPUSH
38919: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38923: LD_INT 455
38925: PPUSH
38926: LD_INT 770
38928: PPUSH
38929: CALL_OW 12
38933: PPUSH
38934: CALL_OW 67
// if Prob ( 50 ) then
38938: LD_INT 50
38940: PPUSH
38941: CALL_OW 13
38945: IFFALSE 38974
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38947: LD_INT 1
38949: PPUSH
38950: LD_INT 5
38952: PPUSH
38953: CALL_OW 12
38957: PPUSH
38958: LD_INT 62
38960: PPUSH
38961: LD_INT 108
38963: PPUSH
38964: LD_INT 10
38966: PPUSH
38967: LD_INT 1
38969: PPUSH
38970: CALL_OW 56
// until missionStage > 4 ;
38974: LD_EXP 15
38978: PUSH
38979: LD_INT 4
38981: GREATER
38982: IFFALSE 38887
// repeat wait ( 0 0$1 ) ;
38984: LD_INT 35
38986: PPUSH
38987: CALL_OW 67
// until missionStage = 6 ;
38991: LD_EXP 15
38995: PUSH
38996: LD_INT 6
38998: EQUAL
38999: IFFALSE 38984
// time := 0 0$20 ;
39001: LD_ADDR_VAR 0 2
39005: PUSH
39006: LD_INT 700
39008: ST_TO_ADDR
// repeat wait ( time ) ;
39009: LD_VAR 0 2
39013: PPUSH
39014: CALL_OW 67
// if Prob ( 90 ) then
39018: LD_INT 90
39020: PPUSH
39021: CALL_OW 13
39025: IFFALSE 39068
// begin time := time + 0 0$2 ;
39027: LD_ADDR_VAR 0 2
39031: PUSH
39032: LD_VAR 0 2
39036: PUSH
39037: LD_INT 70
39039: PLUS
39040: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39041: LD_INT 1
39043: PPUSH
39044: LD_INT 5
39046: PPUSH
39047: CALL_OW 12
39051: PPUSH
39052: LD_INT 106
39054: PPUSH
39055: LD_INT 89
39057: PPUSH
39058: LD_INT 45
39060: PPUSH
39061: LD_INT 1
39063: PPUSH
39064: CALL_OW 56
// end ; if Prob ( 45 ) then
39068: LD_INT 45
39070: PPUSH
39071: CALL_OW 13
39075: IFFALSE 39131
// begin for i := 1 to 4 do
39077: LD_ADDR_VAR 0 1
39081: PUSH
39082: DOUBLE
39083: LD_INT 1
39085: DEC
39086: ST_TO_ADDR
39087: LD_INT 4
39089: PUSH
39090: FOR_TO
39091: IFFALSE 39129
// begin wait ( 0 0$5 ) ;
39093: LD_INT 175
39095: PPUSH
39096: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39100: LD_INT 1
39102: PPUSH
39103: LD_INT 5
39105: PPUSH
39106: CALL_OW 12
39110: PPUSH
39111: LD_INT 113
39113: PPUSH
39114: LD_INT 117
39116: PPUSH
39117: LD_INT 25
39119: PPUSH
39120: LD_INT 1
39122: PPUSH
39123: CALL_OW 56
// end ;
39127: GO 39090
39129: POP
39130: POP
// end ; if Prob ( 40 ) then
39131: LD_INT 40
39133: PPUSH
39134: CALL_OW 13
39138: IFFALSE 39184
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39140: LD_INT 385
39142: PPUSH
39143: LD_INT 945
39145: PPUSH
39146: CALL_OW 12
39150: PPUSH
39151: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39155: LD_INT 1
39157: PPUSH
39158: LD_INT 5
39160: PPUSH
39161: CALL_OW 12
39165: PPUSH
39166: LD_INT 21
39168: PPUSH
39169: LD_INT 26
39171: PPUSH
39172: LD_INT 12
39174: PPUSH
39175: LD_INT 1
39177: PPUSH
39178: CALL_OW 56
// end else
39182: GO 39220
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39184: LD_INT 700
39186: PPUSH
39187: LD_INT 1225
39189: PPUSH
39190: CALL_OW 12
39194: PPUSH
39195: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39199: LD_INT 1
39201: PPUSH
39202: LD_INT 5
39204: PPUSH
39205: CALL_OW 12
39209: PPUSH
39210: LD_INT 16
39212: PPUSH
39213: LD_INT 1
39215: PPUSH
39216: CALL_OW 55
// end ; if Prob ( 50 ) then
39220: LD_INT 50
39222: PPUSH
39223: CALL_OW 13
39227: IFFALSE 39273
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39229: LD_INT 700
39231: PPUSH
39232: LD_INT 1050
39234: PPUSH
39235: CALL_OW 12
39239: PPUSH
39240: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39244: LD_INT 1
39246: PPUSH
39247: LD_INT 5
39249: PPUSH
39250: CALL_OW 12
39254: PPUSH
39255: LD_INT 168
39257: PPUSH
39258: LD_INT 168
39260: PPUSH
39261: LD_INT 16
39263: PPUSH
39264: LD_INT 1
39266: PPUSH
39267: CALL_OW 56
// end else
39271: GO 39309
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39273: LD_INT 350
39275: PPUSH
39276: LD_INT 525
39278: PPUSH
39279: CALL_OW 12
39283: PPUSH
39284: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39288: LD_INT 1
39290: PPUSH
39291: LD_INT 5
39293: PPUSH
39294: CALL_OW 12
39298: PPUSH
39299: LD_INT 15
39301: PPUSH
39302: LD_INT 1
39304: PPUSH
39305: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39309: LD_INT 175
39311: PPUSH
39312: LD_INT 315
39314: PPUSH
39315: CALL_OW 12
39319: PPUSH
39320: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39324: LD_INT 1
39326: PPUSH
39327: LD_INT 5
39329: PPUSH
39330: CALL_OW 12
39334: PPUSH
39335: LD_INT 103
39337: PPUSH
39338: LD_INT 140
39340: PPUSH
39341: LD_INT 20
39343: PPUSH
39344: LD_INT 1
39346: PPUSH
39347: CALL_OW 56
// time := time + 0 0$2 ;
39351: LD_ADDR_VAR 0 2
39355: PUSH
39356: LD_VAR 0 2
39360: PUSH
39361: LD_INT 70
39363: PLUS
39364: ST_TO_ADDR
// if time > 1 1$20 then
39365: LD_VAR 0 2
39369: PUSH
39370: LD_INT 2800
39372: GREATER
39373: IFFALSE 39383
// time := 0 0$30 ;
39375: LD_ADDR_VAR 0 2
39379: PUSH
39380: LD_INT 1050
39382: ST_TO_ADDR
// until false ;
39383: LD_INT 0
39385: IFFALSE 39009
// end ; end_of_file
39387: PPOPN 2
39389: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39390: LD_EXP 13
39394: PUSH
39395: LD_EXP 15
39399: PUSH
39400: LD_INT 6
39402: GREATEREQUAL
39403: AND
39404: IFFALSE 39441
39406: GO 39408
39408: DISABLE
// begin enable ;
39409: ENABLE
// missionTime := missionTime + 0 0$1 ;
39410: LD_ADDR_EXP 14
39414: PUSH
39415: LD_EXP 14
39419: PUSH
39420: LD_INT 35
39422: PLUS
39423: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39424: LD_ADDR_OWVAR 47
39428: PUSH
39429: LD_STRING #Am15-1
39431: PUSH
39432: LD_EXP 14
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: ST_TO_ADDR
// end ; end_of_file
39441: END
// export function InitNature ; begin
39442: LD_INT 0
39444: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39445: LD_INT 3
39447: PPUSH
39448: LD_INT 3
39450: PPUSH
39451: LD_INT 2
39453: PPUSH
39454: LD_INT 1
39456: PPUSH
39457: LD_INT 1
39459: PPUSH
39460: LD_INT 0
39462: PPUSH
39463: LD_INT 0
39465: PPUSH
39466: LD_INT 20
39468: PPUSH
39469: LD_INT 0
39471: PPUSH
39472: CALL 104650 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39476: LD_INT 2
39478: PPUSH
39479: LD_INT 1
39481: PPUSH
39482: LD_INT 1
39484: PPUSH
39485: LD_INT 1
39487: PPUSH
39488: LD_INT 1
39490: PPUSH
39491: LD_INT 0
39493: PPUSH
39494: LD_INT 0
39496: PPUSH
39497: LD_INT 21
39499: PPUSH
39500: LD_INT 0
39502: PPUSH
39503: CALL 104650 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39507: LD_INT 4
39509: PPUSH
39510: LD_INT 1
39512: PPUSH
39513: LD_INT 2
39515: PPUSH
39516: LD_INT 4
39518: PPUSH
39519: LD_INT 2
39521: PPUSH
39522: LD_INT 1
39524: PPUSH
39525: LD_INT 0
39527: PPUSH
39528: LD_INT 22
39530: PPUSH
39531: LD_INT 0
39533: PPUSH
39534: CALL 104650 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39538: LD_INT 0
39540: PPUSH
39541: LD_INT 0
39543: PPUSH
39544: LD_INT 0
39546: PPUSH
39547: LD_INT 0
39549: PPUSH
39550: LD_INT 0
39552: PPUSH
39553: LD_INT 0
39555: PPUSH
39556: LD_INT 9
39558: PPUSH
39559: LD_INT 0
39561: PPUSH
39562: LD_INT 23
39564: PPUSH
39565: CALL 104650 0 9
// end ; end_of_file
39569: LD_VAR 0 1
39573: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39574: LD_INT 0
39576: PPUSH
39577: PPUSH
// skirmish := false ;
39578: LD_ADDR_EXP 100
39582: PUSH
39583: LD_INT 0
39585: ST_TO_ADDR
// debug_mc := false ;
39586: LD_ADDR_EXP 101
39590: PUSH
39591: LD_INT 0
39593: ST_TO_ADDR
// mc_bases := [ ] ;
39594: LD_ADDR_EXP 102
39598: PUSH
39599: EMPTY
39600: ST_TO_ADDR
// mc_sides := [ ] ;
39601: LD_ADDR_EXP 128
39605: PUSH
39606: EMPTY
39607: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39608: LD_ADDR_EXP 103
39612: PUSH
39613: EMPTY
39614: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39615: LD_ADDR_EXP 104
39619: PUSH
39620: EMPTY
39621: ST_TO_ADDR
// mc_need_heal := [ ] ;
39622: LD_ADDR_EXP 105
39626: PUSH
39627: EMPTY
39628: ST_TO_ADDR
// mc_healers := [ ] ;
39629: LD_ADDR_EXP 106
39633: PUSH
39634: EMPTY
39635: ST_TO_ADDR
// mc_build_list := [ ] ;
39636: LD_ADDR_EXP 107
39640: PUSH
39641: EMPTY
39642: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39643: LD_ADDR_EXP 134
39647: PUSH
39648: EMPTY
39649: ST_TO_ADDR
// mc_builders := [ ] ;
39650: LD_ADDR_EXP 108
39654: PUSH
39655: EMPTY
39656: ST_TO_ADDR
// mc_construct_list := [ ] ;
39657: LD_ADDR_EXP 109
39661: PUSH
39662: EMPTY
39663: ST_TO_ADDR
// mc_turret_list := [ ] ;
39664: LD_ADDR_EXP 110
39668: PUSH
39669: EMPTY
39670: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39671: LD_ADDR_EXP 111
39675: PUSH
39676: EMPTY
39677: ST_TO_ADDR
// mc_miners := [ ] ;
39678: LD_ADDR_EXP 116
39682: PUSH
39683: EMPTY
39684: ST_TO_ADDR
// mc_mines := [ ] ;
39685: LD_ADDR_EXP 115
39689: PUSH
39690: EMPTY
39691: ST_TO_ADDR
// mc_minefields := [ ] ;
39692: LD_ADDR_EXP 117
39696: PUSH
39697: EMPTY
39698: ST_TO_ADDR
// mc_crates := [ ] ;
39699: LD_ADDR_EXP 118
39703: PUSH
39704: EMPTY
39705: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39706: LD_ADDR_EXP 119
39710: PUSH
39711: EMPTY
39712: ST_TO_ADDR
// mc_crates_area := [ ] ;
39713: LD_ADDR_EXP 120
39717: PUSH
39718: EMPTY
39719: ST_TO_ADDR
// mc_vehicles := [ ] ;
39720: LD_ADDR_EXP 121
39724: PUSH
39725: EMPTY
39726: ST_TO_ADDR
// mc_attack := [ ] ;
39727: LD_ADDR_EXP 122
39731: PUSH
39732: EMPTY
39733: ST_TO_ADDR
// mc_produce := [ ] ;
39734: LD_ADDR_EXP 123
39738: PUSH
39739: EMPTY
39740: ST_TO_ADDR
// mc_defender := [ ] ;
39741: LD_ADDR_EXP 124
39745: PUSH
39746: EMPTY
39747: ST_TO_ADDR
// mc_parking := [ ] ;
39748: LD_ADDR_EXP 126
39752: PUSH
39753: EMPTY
39754: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39755: LD_ADDR_EXP 112
39759: PUSH
39760: EMPTY
39761: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39762: LD_ADDR_EXP 114
39766: PUSH
39767: EMPTY
39768: ST_TO_ADDR
// mc_scan := [ ] ;
39769: LD_ADDR_EXP 125
39773: PUSH
39774: EMPTY
39775: ST_TO_ADDR
// mc_scan_area := [ ] ;
39776: LD_ADDR_EXP 127
39780: PUSH
39781: EMPTY
39782: ST_TO_ADDR
// mc_tech := [ ] ;
39783: LD_ADDR_EXP 129
39787: PUSH
39788: EMPTY
39789: ST_TO_ADDR
// mc_class := [ ] ;
39790: LD_ADDR_EXP 143
39794: PUSH
39795: EMPTY
39796: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39797: LD_ADDR_EXP 144
39801: PUSH
39802: EMPTY
39803: ST_TO_ADDR
// mc_is_defending := [ ] ;
39804: LD_ADDR_EXP 145
39808: PUSH
39809: EMPTY
39810: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39811: LD_ADDR_EXP 136
39815: PUSH
39816: EMPTY
39817: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39818: LD_ADDR_EXP 146
39822: PUSH
39823: LD_INT 0
39825: ST_TO_ADDR
// end ;
39826: LD_VAR 0 1
39830: RET
// export function MC_Kill ( base ) ; begin
39831: LD_INT 0
39833: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39834: LD_ADDR_EXP 102
39838: PUSH
39839: LD_EXP 102
39843: PPUSH
39844: LD_VAR 0 1
39848: PPUSH
39849: EMPTY
39850: PPUSH
39851: CALL_OW 1
39855: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39856: LD_ADDR_EXP 103
39860: PUSH
39861: LD_EXP 103
39865: PPUSH
39866: LD_VAR 0 1
39870: PPUSH
39871: EMPTY
39872: PPUSH
39873: CALL_OW 1
39877: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39878: LD_ADDR_EXP 104
39882: PUSH
39883: LD_EXP 104
39887: PPUSH
39888: LD_VAR 0 1
39892: PPUSH
39893: EMPTY
39894: PPUSH
39895: CALL_OW 1
39899: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39900: LD_ADDR_EXP 105
39904: PUSH
39905: LD_EXP 105
39909: PPUSH
39910: LD_VAR 0 1
39914: PPUSH
39915: EMPTY
39916: PPUSH
39917: CALL_OW 1
39921: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39922: LD_ADDR_EXP 106
39926: PUSH
39927: LD_EXP 106
39931: PPUSH
39932: LD_VAR 0 1
39936: PPUSH
39937: EMPTY
39938: PPUSH
39939: CALL_OW 1
39943: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39944: LD_ADDR_EXP 107
39948: PUSH
39949: LD_EXP 107
39953: PPUSH
39954: LD_VAR 0 1
39958: PPUSH
39959: EMPTY
39960: PPUSH
39961: CALL_OW 1
39965: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39966: LD_ADDR_EXP 108
39970: PUSH
39971: LD_EXP 108
39975: PPUSH
39976: LD_VAR 0 1
39980: PPUSH
39981: EMPTY
39982: PPUSH
39983: CALL_OW 1
39987: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39988: LD_ADDR_EXP 109
39992: PUSH
39993: LD_EXP 109
39997: PPUSH
39998: LD_VAR 0 1
40002: PPUSH
40003: EMPTY
40004: PPUSH
40005: CALL_OW 1
40009: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40010: LD_ADDR_EXP 110
40014: PUSH
40015: LD_EXP 110
40019: PPUSH
40020: LD_VAR 0 1
40024: PPUSH
40025: EMPTY
40026: PPUSH
40027: CALL_OW 1
40031: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40032: LD_ADDR_EXP 111
40036: PUSH
40037: LD_EXP 111
40041: PPUSH
40042: LD_VAR 0 1
40046: PPUSH
40047: EMPTY
40048: PPUSH
40049: CALL_OW 1
40053: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40054: LD_ADDR_EXP 112
40058: PUSH
40059: LD_EXP 112
40063: PPUSH
40064: LD_VAR 0 1
40068: PPUSH
40069: EMPTY
40070: PPUSH
40071: CALL_OW 1
40075: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40076: LD_ADDR_EXP 113
40080: PUSH
40081: LD_EXP 113
40085: PPUSH
40086: LD_VAR 0 1
40090: PPUSH
40091: LD_INT 0
40093: PPUSH
40094: CALL_OW 1
40098: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40099: LD_ADDR_EXP 114
40103: PUSH
40104: LD_EXP 114
40108: PPUSH
40109: LD_VAR 0 1
40113: PPUSH
40114: EMPTY
40115: PPUSH
40116: CALL_OW 1
40120: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40121: LD_ADDR_EXP 115
40125: PUSH
40126: LD_EXP 115
40130: PPUSH
40131: LD_VAR 0 1
40135: PPUSH
40136: EMPTY
40137: PPUSH
40138: CALL_OW 1
40142: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40143: LD_ADDR_EXP 116
40147: PUSH
40148: LD_EXP 116
40152: PPUSH
40153: LD_VAR 0 1
40157: PPUSH
40158: EMPTY
40159: PPUSH
40160: CALL_OW 1
40164: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40165: LD_ADDR_EXP 117
40169: PUSH
40170: LD_EXP 117
40174: PPUSH
40175: LD_VAR 0 1
40179: PPUSH
40180: EMPTY
40181: PPUSH
40182: CALL_OW 1
40186: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40187: LD_ADDR_EXP 118
40191: PUSH
40192: LD_EXP 118
40196: PPUSH
40197: LD_VAR 0 1
40201: PPUSH
40202: EMPTY
40203: PPUSH
40204: CALL_OW 1
40208: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40209: LD_ADDR_EXP 119
40213: PUSH
40214: LD_EXP 119
40218: PPUSH
40219: LD_VAR 0 1
40223: PPUSH
40224: EMPTY
40225: PPUSH
40226: CALL_OW 1
40230: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40231: LD_ADDR_EXP 120
40235: PUSH
40236: LD_EXP 120
40240: PPUSH
40241: LD_VAR 0 1
40245: PPUSH
40246: EMPTY
40247: PPUSH
40248: CALL_OW 1
40252: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40253: LD_ADDR_EXP 121
40257: PUSH
40258: LD_EXP 121
40262: PPUSH
40263: LD_VAR 0 1
40267: PPUSH
40268: EMPTY
40269: PPUSH
40270: CALL_OW 1
40274: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40275: LD_ADDR_EXP 122
40279: PUSH
40280: LD_EXP 122
40284: PPUSH
40285: LD_VAR 0 1
40289: PPUSH
40290: EMPTY
40291: PPUSH
40292: CALL_OW 1
40296: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40297: LD_ADDR_EXP 123
40301: PUSH
40302: LD_EXP 123
40306: PPUSH
40307: LD_VAR 0 1
40311: PPUSH
40312: EMPTY
40313: PPUSH
40314: CALL_OW 1
40318: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40319: LD_ADDR_EXP 124
40323: PUSH
40324: LD_EXP 124
40328: PPUSH
40329: LD_VAR 0 1
40333: PPUSH
40334: EMPTY
40335: PPUSH
40336: CALL_OW 1
40340: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40341: LD_ADDR_EXP 125
40345: PUSH
40346: LD_EXP 125
40350: PPUSH
40351: LD_VAR 0 1
40355: PPUSH
40356: EMPTY
40357: PPUSH
40358: CALL_OW 1
40362: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40363: LD_ADDR_EXP 126
40367: PUSH
40368: LD_EXP 126
40372: PPUSH
40373: LD_VAR 0 1
40377: PPUSH
40378: EMPTY
40379: PPUSH
40380: CALL_OW 1
40384: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40385: LD_ADDR_EXP 127
40389: PUSH
40390: LD_EXP 127
40394: PPUSH
40395: LD_VAR 0 1
40399: PPUSH
40400: EMPTY
40401: PPUSH
40402: CALL_OW 1
40406: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40407: LD_ADDR_EXP 129
40411: PUSH
40412: LD_EXP 129
40416: PPUSH
40417: LD_VAR 0 1
40421: PPUSH
40422: EMPTY
40423: PPUSH
40424: CALL_OW 1
40428: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40429: LD_ADDR_EXP 131
40433: PUSH
40434: LD_EXP 131
40438: PPUSH
40439: LD_VAR 0 1
40443: PPUSH
40444: EMPTY
40445: PPUSH
40446: CALL_OW 1
40450: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40451: LD_ADDR_EXP 132
40455: PUSH
40456: LD_EXP 132
40460: PPUSH
40461: LD_VAR 0 1
40465: PPUSH
40466: EMPTY
40467: PPUSH
40468: CALL_OW 1
40472: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40473: LD_ADDR_EXP 133
40477: PUSH
40478: LD_EXP 133
40482: PPUSH
40483: LD_VAR 0 1
40487: PPUSH
40488: EMPTY
40489: PPUSH
40490: CALL_OW 1
40494: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40495: LD_ADDR_EXP 134
40499: PUSH
40500: LD_EXP 134
40504: PPUSH
40505: LD_VAR 0 1
40509: PPUSH
40510: EMPTY
40511: PPUSH
40512: CALL_OW 1
40516: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40517: LD_ADDR_EXP 135
40521: PUSH
40522: LD_EXP 135
40526: PPUSH
40527: LD_VAR 0 1
40531: PPUSH
40532: EMPTY
40533: PPUSH
40534: CALL_OW 1
40538: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40539: LD_ADDR_EXP 136
40543: PUSH
40544: LD_EXP 136
40548: PPUSH
40549: LD_VAR 0 1
40553: PPUSH
40554: EMPTY
40555: PPUSH
40556: CALL_OW 1
40560: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40561: LD_ADDR_EXP 137
40565: PUSH
40566: LD_EXP 137
40570: PPUSH
40571: LD_VAR 0 1
40575: PPUSH
40576: EMPTY
40577: PPUSH
40578: CALL_OW 1
40582: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40583: LD_ADDR_EXP 138
40587: PUSH
40588: LD_EXP 138
40592: PPUSH
40593: LD_VAR 0 1
40597: PPUSH
40598: EMPTY
40599: PPUSH
40600: CALL_OW 1
40604: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40605: LD_ADDR_EXP 139
40609: PUSH
40610: LD_EXP 139
40614: PPUSH
40615: LD_VAR 0 1
40619: PPUSH
40620: EMPTY
40621: PPUSH
40622: CALL_OW 1
40626: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40627: LD_ADDR_EXP 140
40631: PUSH
40632: LD_EXP 140
40636: PPUSH
40637: LD_VAR 0 1
40641: PPUSH
40642: EMPTY
40643: PPUSH
40644: CALL_OW 1
40648: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40649: LD_ADDR_EXP 141
40653: PUSH
40654: LD_EXP 141
40658: PPUSH
40659: LD_VAR 0 1
40663: PPUSH
40664: EMPTY
40665: PPUSH
40666: CALL_OW 1
40670: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40671: LD_ADDR_EXP 142
40675: PUSH
40676: LD_EXP 142
40680: PPUSH
40681: LD_VAR 0 1
40685: PPUSH
40686: EMPTY
40687: PPUSH
40688: CALL_OW 1
40692: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40693: LD_ADDR_EXP 143
40697: PUSH
40698: LD_EXP 143
40702: PPUSH
40703: LD_VAR 0 1
40707: PPUSH
40708: EMPTY
40709: PPUSH
40710: CALL_OW 1
40714: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40715: LD_ADDR_EXP 144
40719: PUSH
40720: LD_EXP 144
40724: PPUSH
40725: LD_VAR 0 1
40729: PPUSH
40730: LD_INT 0
40732: PPUSH
40733: CALL_OW 1
40737: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40738: LD_ADDR_EXP 145
40742: PUSH
40743: LD_EXP 145
40747: PPUSH
40748: LD_VAR 0 1
40752: PPUSH
40753: LD_INT 0
40755: PPUSH
40756: CALL_OW 1
40760: ST_TO_ADDR
// end ;
40761: LD_VAR 0 2
40765: RET
// export function MC_Add ( side , units ) ; var base ; begin
40766: LD_INT 0
40768: PPUSH
40769: PPUSH
// base := mc_bases + 1 ;
40770: LD_ADDR_VAR 0 4
40774: PUSH
40775: LD_EXP 102
40779: PUSH
40780: LD_INT 1
40782: PLUS
40783: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40784: LD_ADDR_EXP 128
40788: PUSH
40789: LD_EXP 128
40793: PPUSH
40794: LD_VAR 0 4
40798: PPUSH
40799: LD_VAR 0 1
40803: PPUSH
40804: CALL_OW 1
40808: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40809: LD_ADDR_EXP 102
40813: PUSH
40814: LD_EXP 102
40818: PPUSH
40819: LD_VAR 0 4
40823: PPUSH
40824: LD_VAR 0 2
40828: PPUSH
40829: CALL_OW 1
40833: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40834: LD_ADDR_EXP 103
40838: PUSH
40839: LD_EXP 103
40843: PPUSH
40844: LD_VAR 0 4
40848: PPUSH
40849: EMPTY
40850: PPUSH
40851: CALL_OW 1
40855: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40856: LD_ADDR_EXP 104
40860: PUSH
40861: LD_EXP 104
40865: PPUSH
40866: LD_VAR 0 4
40870: PPUSH
40871: EMPTY
40872: PPUSH
40873: CALL_OW 1
40877: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40878: LD_ADDR_EXP 105
40882: PUSH
40883: LD_EXP 105
40887: PPUSH
40888: LD_VAR 0 4
40892: PPUSH
40893: EMPTY
40894: PPUSH
40895: CALL_OW 1
40899: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40900: LD_ADDR_EXP 106
40904: PUSH
40905: LD_EXP 106
40909: PPUSH
40910: LD_VAR 0 4
40914: PPUSH
40915: EMPTY
40916: PPUSH
40917: CALL_OW 1
40921: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40922: LD_ADDR_EXP 107
40926: PUSH
40927: LD_EXP 107
40931: PPUSH
40932: LD_VAR 0 4
40936: PPUSH
40937: EMPTY
40938: PPUSH
40939: CALL_OW 1
40943: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40944: LD_ADDR_EXP 108
40948: PUSH
40949: LD_EXP 108
40953: PPUSH
40954: LD_VAR 0 4
40958: PPUSH
40959: EMPTY
40960: PPUSH
40961: CALL_OW 1
40965: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40966: LD_ADDR_EXP 109
40970: PUSH
40971: LD_EXP 109
40975: PPUSH
40976: LD_VAR 0 4
40980: PPUSH
40981: EMPTY
40982: PPUSH
40983: CALL_OW 1
40987: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40988: LD_ADDR_EXP 110
40992: PUSH
40993: LD_EXP 110
40997: PPUSH
40998: LD_VAR 0 4
41002: PPUSH
41003: EMPTY
41004: PPUSH
41005: CALL_OW 1
41009: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41010: LD_ADDR_EXP 111
41014: PUSH
41015: LD_EXP 111
41019: PPUSH
41020: LD_VAR 0 4
41024: PPUSH
41025: EMPTY
41026: PPUSH
41027: CALL_OW 1
41031: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41032: LD_ADDR_EXP 112
41036: PUSH
41037: LD_EXP 112
41041: PPUSH
41042: LD_VAR 0 4
41046: PPUSH
41047: EMPTY
41048: PPUSH
41049: CALL_OW 1
41053: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41054: LD_ADDR_EXP 113
41058: PUSH
41059: LD_EXP 113
41063: PPUSH
41064: LD_VAR 0 4
41068: PPUSH
41069: LD_INT 0
41071: PPUSH
41072: CALL_OW 1
41076: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41077: LD_ADDR_EXP 114
41081: PUSH
41082: LD_EXP 114
41086: PPUSH
41087: LD_VAR 0 4
41091: PPUSH
41092: EMPTY
41093: PPUSH
41094: CALL_OW 1
41098: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41099: LD_ADDR_EXP 115
41103: PUSH
41104: LD_EXP 115
41108: PPUSH
41109: LD_VAR 0 4
41113: PPUSH
41114: EMPTY
41115: PPUSH
41116: CALL_OW 1
41120: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41121: LD_ADDR_EXP 116
41125: PUSH
41126: LD_EXP 116
41130: PPUSH
41131: LD_VAR 0 4
41135: PPUSH
41136: EMPTY
41137: PPUSH
41138: CALL_OW 1
41142: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41143: LD_ADDR_EXP 117
41147: PUSH
41148: LD_EXP 117
41152: PPUSH
41153: LD_VAR 0 4
41157: PPUSH
41158: EMPTY
41159: PPUSH
41160: CALL_OW 1
41164: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41165: LD_ADDR_EXP 118
41169: PUSH
41170: LD_EXP 118
41174: PPUSH
41175: LD_VAR 0 4
41179: PPUSH
41180: EMPTY
41181: PPUSH
41182: CALL_OW 1
41186: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41187: LD_ADDR_EXP 119
41191: PUSH
41192: LD_EXP 119
41196: PPUSH
41197: LD_VAR 0 4
41201: PPUSH
41202: EMPTY
41203: PPUSH
41204: CALL_OW 1
41208: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41209: LD_ADDR_EXP 120
41213: PUSH
41214: LD_EXP 120
41218: PPUSH
41219: LD_VAR 0 4
41223: PPUSH
41224: EMPTY
41225: PPUSH
41226: CALL_OW 1
41230: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41231: LD_ADDR_EXP 121
41235: PUSH
41236: LD_EXP 121
41240: PPUSH
41241: LD_VAR 0 4
41245: PPUSH
41246: EMPTY
41247: PPUSH
41248: CALL_OW 1
41252: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41253: LD_ADDR_EXP 122
41257: PUSH
41258: LD_EXP 122
41262: PPUSH
41263: LD_VAR 0 4
41267: PPUSH
41268: EMPTY
41269: PPUSH
41270: CALL_OW 1
41274: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41275: LD_ADDR_EXP 123
41279: PUSH
41280: LD_EXP 123
41284: PPUSH
41285: LD_VAR 0 4
41289: PPUSH
41290: EMPTY
41291: PPUSH
41292: CALL_OW 1
41296: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41297: LD_ADDR_EXP 124
41301: PUSH
41302: LD_EXP 124
41306: PPUSH
41307: LD_VAR 0 4
41311: PPUSH
41312: EMPTY
41313: PPUSH
41314: CALL_OW 1
41318: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41319: LD_ADDR_EXP 125
41323: PUSH
41324: LD_EXP 125
41328: PPUSH
41329: LD_VAR 0 4
41333: PPUSH
41334: EMPTY
41335: PPUSH
41336: CALL_OW 1
41340: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41341: LD_ADDR_EXP 126
41345: PUSH
41346: LD_EXP 126
41350: PPUSH
41351: LD_VAR 0 4
41355: PPUSH
41356: EMPTY
41357: PPUSH
41358: CALL_OW 1
41362: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41363: LD_ADDR_EXP 127
41367: PUSH
41368: LD_EXP 127
41372: PPUSH
41373: LD_VAR 0 4
41377: PPUSH
41378: EMPTY
41379: PPUSH
41380: CALL_OW 1
41384: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41385: LD_ADDR_EXP 129
41389: PUSH
41390: LD_EXP 129
41394: PPUSH
41395: LD_VAR 0 4
41399: PPUSH
41400: EMPTY
41401: PPUSH
41402: CALL_OW 1
41406: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41407: LD_ADDR_EXP 131
41411: PUSH
41412: LD_EXP 131
41416: PPUSH
41417: LD_VAR 0 4
41421: PPUSH
41422: EMPTY
41423: PPUSH
41424: CALL_OW 1
41428: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41429: LD_ADDR_EXP 132
41433: PUSH
41434: LD_EXP 132
41438: PPUSH
41439: LD_VAR 0 4
41443: PPUSH
41444: EMPTY
41445: PPUSH
41446: CALL_OW 1
41450: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41451: LD_ADDR_EXP 133
41455: PUSH
41456: LD_EXP 133
41460: PPUSH
41461: LD_VAR 0 4
41465: PPUSH
41466: EMPTY
41467: PPUSH
41468: CALL_OW 1
41472: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41473: LD_ADDR_EXP 134
41477: PUSH
41478: LD_EXP 134
41482: PPUSH
41483: LD_VAR 0 4
41487: PPUSH
41488: EMPTY
41489: PPUSH
41490: CALL_OW 1
41494: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41495: LD_ADDR_EXP 135
41499: PUSH
41500: LD_EXP 135
41504: PPUSH
41505: LD_VAR 0 4
41509: PPUSH
41510: EMPTY
41511: PPUSH
41512: CALL_OW 1
41516: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41517: LD_ADDR_EXP 136
41521: PUSH
41522: LD_EXP 136
41526: PPUSH
41527: LD_VAR 0 4
41531: PPUSH
41532: EMPTY
41533: PPUSH
41534: CALL_OW 1
41538: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41539: LD_ADDR_EXP 137
41543: PUSH
41544: LD_EXP 137
41548: PPUSH
41549: LD_VAR 0 4
41553: PPUSH
41554: EMPTY
41555: PPUSH
41556: CALL_OW 1
41560: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41561: LD_ADDR_EXP 138
41565: PUSH
41566: LD_EXP 138
41570: PPUSH
41571: LD_VAR 0 4
41575: PPUSH
41576: EMPTY
41577: PPUSH
41578: CALL_OW 1
41582: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41583: LD_ADDR_EXP 139
41587: PUSH
41588: LD_EXP 139
41592: PPUSH
41593: LD_VAR 0 4
41597: PPUSH
41598: EMPTY
41599: PPUSH
41600: CALL_OW 1
41604: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41605: LD_ADDR_EXP 140
41609: PUSH
41610: LD_EXP 140
41614: PPUSH
41615: LD_VAR 0 4
41619: PPUSH
41620: EMPTY
41621: PPUSH
41622: CALL_OW 1
41626: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41627: LD_ADDR_EXP 141
41631: PUSH
41632: LD_EXP 141
41636: PPUSH
41637: LD_VAR 0 4
41641: PPUSH
41642: EMPTY
41643: PPUSH
41644: CALL_OW 1
41648: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41649: LD_ADDR_EXP 142
41653: PUSH
41654: LD_EXP 142
41658: PPUSH
41659: LD_VAR 0 4
41663: PPUSH
41664: EMPTY
41665: PPUSH
41666: CALL_OW 1
41670: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41671: LD_ADDR_EXP 143
41675: PUSH
41676: LD_EXP 143
41680: PPUSH
41681: LD_VAR 0 4
41685: PPUSH
41686: EMPTY
41687: PPUSH
41688: CALL_OW 1
41692: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41693: LD_ADDR_EXP 144
41697: PUSH
41698: LD_EXP 144
41702: PPUSH
41703: LD_VAR 0 4
41707: PPUSH
41708: LD_INT 0
41710: PPUSH
41711: CALL_OW 1
41715: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41716: LD_ADDR_EXP 145
41720: PUSH
41721: LD_EXP 145
41725: PPUSH
41726: LD_VAR 0 4
41730: PPUSH
41731: LD_INT 0
41733: PPUSH
41734: CALL_OW 1
41738: ST_TO_ADDR
// result := base ;
41739: LD_ADDR_VAR 0 3
41743: PUSH
41744: LD_VAR 0 4
41748: ST_TO_ADDR
// end ;
41749: LD_VAR 0 3
41753: RET
// export function MC_Start ( ) ; var i ; begin
41754: LD_INT 0
41756: PPUSH
41757: PPUSH
// for i = 1 to mc_bases do
41758: LD_ADDR_VAR 0 2
41762: PUSH
41763: DOUBLE
41764: LD_INT 1
41766: DEC
41767: ST_TO_ADDR
41768: LD_EXP 102
41772: PUSH
41773: FOR_TO
41774: IFFALSE 42874
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41776: LD_ADDR_EXP 102
41780: PUSH
41781: LD_EXP 102
41785: PPUSH
41786: LD_VAR 0 2
41790: PPUSH
41791: LD_EXP 102
41795: PUSH
41796: LD_VAR 0 2
41800: ARRAY
41801: PUSH
41802: LD_INT 0
41804: DIFF
41805: PPUSH
41806: CALL_OW 1
41810: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41811: LD_ADDR_EXP 103
41815: PUSH
41816: LD_EXP 103
41820: PPUSH
41821: LD_VAR 0 2
41825: PPUSH
41826: EMPTY
41827: PPUSH
41828: CALL_OW 1
41832: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41833: LD_ADDR_EXP 104
41837: PUSH
41838: LD_EXP 104
41842: PPUSH
41843: LD_VAR 0 2
41847: PPUSH
41848: EMPTY
41849: PPUSH
41850: CALL_OW 1
41854: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41855: LD_ADDR_EXP 105
41859: PUSH
41860: LD_EXP 105
41864: PPUSH
41865: LD_VAR 0 2
41869: PPUSH
41870: EMPTY
41871: PPUSH
41872: CALL_OW 1
41876: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41877: LD_ADDR_EXP 106
41881: PUSH
41882: LD_EXP 106
41886: PPUSH
41887: LD_VAR 0 2
41891: PPUSH
41892: EMPTY
41893: PUSH
41894: EMPTY
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PPUSH
41900: CALL_OW 1
41904: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41905: LD_ADDR_EXP 107
41909: PUSH
41910: LD_EXP 107
41914: PPUSH
41915: LD_VAR 0 2
41919: PPUSH
41920: EMPTY
41921: PPUSH
41922: CALL_OW 1
41926: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41927: LD_ADDR_EXP 134
41931: PUSH
41932: LD_EXP 134
41936: PPUSH
41937: LD_VAR 0 2
41941: PPUSH
41942: EMPTY
41943: PPUSH
41944: CALL_OW 1
41948: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41949: LD_ADDR_EXP 108
41953: PUSH
41954: LD_EXP 108
41958: PPUSH
41959: LD_VAR 0 2
41963: PPUSH
41964: EMPTY
41965: PPUSH
41966: CALL_OW 1
41970: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41971: LD_ADDR_EXP 109
41975: PUSH
41976: LD_EXP 109
41980: PPUSH
41981: LD_VAR 0 2
41985: PPUSH
41986: EMPTY
41987: PPUSH
41988: CALL_OW 1
41992: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41993: LD_ADDR_EXP 110
41997: PUSH
41998: LD_EXP 110
42002: PPUSH
42003: LD_VAR 0 2
42007: PPUSH
42008: LD_EXP 102
42012: PUSH
42013: LD_VAR 0 2
42017: ARRAY
42018: PPUSH
42019: LD_INT 2
42021: PUSH
42022: LD_INT 30
42024: PUSH
42025: LD_INT 32
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: LD_INT 30
42034: PUSH
42035: LD_INT 33
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: LIST
42046: PPUSH
42047: CALL_OW 72
42051: PPUSH
42052: CALL_OW 1
42056: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42057: LD_ADDR_EXP 111
42061: PUSH
42062: LD_EXP 111
42066: PPUSH
42067: LD_VAR 0 2
42071: PPUSH
42072: LD_EXP 102
42076: PUSH
42077: LD_VAR 0 2
42081: ARRAY
42082: PPUSH
42083: LD_INT 2
42085: PUSH
42086: LD_INT 30
42088: PUSH
42089: LD_INT 32
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 30
42098: PUSH
42099: LD_INT 31
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 58
42113: PUSH
42114: EMPTY
42115: LIST
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PPUSH
42121: CALL_OW 72
42125: PPUSH
42126: CALL_OW 1
42130: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42131: LD_ADDR_EXP 112
42135: PUSH
42136: LD_EXP 112
42140: PPUSH
42141: LD_VAR 0 2
42145: PPUSH
42146: EMPTY
42147: PPUSH
42148: CALL_OW 1
42152: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42153: LD_ADDR_EXP 116
42157: PUSH
42158: LD_EXP 116
42162: PPUSH
42163: LD_VAR 0 2
42167: PPUSH
42168: EMPTY
42169: PPUSH
42170: CALL_OW 1
42174: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42175: LD_ADDR_EXP 115
42179: PUSH
42180: LD_EXP 115
42184: PPUSH
42185: LD_VAR 0 2
42189: PPUSH
42190: EMPTY
42191: PPUSH
42192: CALL_OW 1
42196: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42197: LD_ADDR_EXP 117
42201: PUSH
42202: LD_EXP 117
42206: PPUSH
42207: LD_VAR 0 2
42211: PPUSH
42212: EMPTY
42213: PPUSH
42214: CALL_OW 1
42218: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42219: LD_ADDR_EXP 118
42223: PUSH
42224: LD_EXP 118
42228: PPUSH
42229: LD_VAR 0 2
42233: PPUSH
42234: EMPTY
42235: PPUSH
42236: CALL_OW 1
42240: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42241: LD_ADDR_EXP 119
42245: PUSH
42246: LD_EXP 119
42250: PPUSH
42251: LD_VAR 0 2
42255: PPUSH
42256: EMPTY
42257: PPUSH
42258: CALL_OW 1
42262: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42263: LD_ADDR_EXP 120
42267: PUSH
42268: LD_EXP 120
42272: PPUSH
42273: LD_VAR 0 2
42277: PPUSH
42278: EMPTY
42279: PPUSH
42280: CALL_OW 1
42284: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42285: LD_ADDR_EXP 121
42289: PUSH
42290: LD_EXP 121
42294: PPUSH
42295: LD_VAR 0 2
42299: PPUSH
42300: EMPTY
42301: PPUSH
42302: CALL_OW 1
42306: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42307: LD_ADDR_EXP 122
42311: PUSH
42312: LD_EXP 122
42316: PPUSH
42317: LD_VAR 0 2
42321: PPUSH
42322: EMPTY
42323: PPUSH
42324: CALL_OW 1
42328: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42329: LD_ADDR_EXP 123
42333: PUSH
42334: LD_EXP 123
42338: PPUSH
42339: LD_VAR 0 2
42343: PPUSH
42344: EMPTY
42345: PPUSH
42346: CALL_OW 1
42350: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42351: LD_ADDR_EXP 124
42355: PUSH
42356: LD_EXP 124
42360: PPUSH
42361: LD_VAR 0 2
42365: PPUSH
42366: EMPTY
42367: PPUSH
42368: CALL_OW 1
42372: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42373: LD_ADDR_EXP 113
42377: PUSH
42378: LD_EXP 113
42382: PPUSH
42383: LD_VAR 0 2
42387: PPUSH
42388: LD_INT 0
42390: PPUSH
42391: CALL_OW 1
42395: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42396: LD_ADDR_EXP 126
42400: PUSH
42401: LD_EXP 126
42405: PPUSH
42406: LD_VAR 0 2
42410: PPUSH
42411: LD_INT 0
42413: PPUSH
42414: CALL_OW 1
42418: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42419: LD_ADDR_EXP 114
42423: PUSH
42424: LD_EXP 114
42428: PPUSH
42429: LD_VAR 0 2
42433: PPUSH
42434: EMPTY
42435: PPUSH
42436: CALL_OW 1
42440: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42441: LD_ADDR_EXP 125
42445: PUSH
42446: LD_EXP 125
42450: PPUSH
42451: LD_VAR 0 2
42455: PPUSH
42456: LD_INT 0
42458: PPUSH
42459: CALL_OW 1
42463: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42464: LD_ADDR_EXP 127
42468: PUSH
42469: LD_EXP 127
42473: PPUSH
42474: LD_VAR 0 2
42478: PPUSH
42479: EMPTY
42480: PPUSH
42481: CALL_OW 1
42485: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42486: LD_ADDR_EXP 130
42490: PUSH
42491: LD_EXP 130
42495: PPUSH
42496: LD_VAR 0 2
42500: PPUSH
42501: LD_INT 0
42503: PPUSH
42504: CALL_OW 1
42508: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42509: LD_ADDR_EXP 131
42513: PUSH
42514: LD_EXP 131
42518: PPUSH
42519: LD_VAR 0 2
42523: PPUSH
42524: EMPTY
42525: PPUSH
42526: CALL_OW 1
42530: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42531: LD_ADDR_EXP 132
42535: PUSH
42536: LD_EXP 132
42540: PPUSH
42541: LD_VAR 0 2
42545: PPUSH
42546: EMPTY
42547: PPUSH
42548: CALL_OW 1
42552: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42553: LD_ADDR_EXP 133
42557: PUSH
42558: LD_EXP 133
42562: PPUSH
42563: LD_VAR 0 2
42567: PPUSH
42568: EMPTY
42569: PPUSH
42570: CALL_OW 1
42574: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42575: LD_ADDR_EXP 135
42579: PUSH
42580: LD_EXP 135
42584: PPUSH
42585: LD_VAR 0 2
42589: PPUSH
42590: LD_EXP 102
42594: PUSH
42595: LD_VAR 0 2
42599: ARRAY
42600: PPUSH
42601: LD_INT 2
42603: PUSH
42604: LD_INT 30
42606: PUSH
42607: LD_INT 6
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 30
42616: PUSH
42617: LD_INT 7
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 30
42626: PUSH
42627: LD_INT 8
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: PPUSH
42640: CALL_OW 72
42644: PPUSH
42645: CALL_OW 1
42649: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42650: LD_ADDR_EXP 136
42654: PUSH
42655: LD_EXP 136
42659: PPUSH
42660: LD_VAR 0 2
42664: PPUSH
42665: EMPTY
42666: PPUSH
42667: CALL_OW 1
42671: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42672: LD_ADDR_EXP 137
42676: PUSH
42677: LD_EXP 137
42681: PPUSH
42682: LD_VAR 0 2
42686: PPUSH
42687: EMPTY
42688: PPUSH
42689: CALL_OW 1
42693: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42694: LD_ADDR_EXP 138
42698: PUSH
42699: LD_EXP 138
42703: PPUSH
42704: LD_VAR 0 2
42708: PPUSH
42709: EMPTY
42710: PPUSH
42711: CALL_OW 1
42715: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42716: LD_ADDR_EXP 139
42720: PUSH
42721: LD_EXP 139
42725: PPUSH
42726: LD_VAR 0 2
42730: PPUSH
42731: EMPTY
42732: PPUSH
42733: CALL_OW 1
42737: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42738: LD_ADDR_EXP 140
42742: PUSH
42743: LD_EXP 140
42747: PPUSH
42748: LD_VAR 0 2
42752: PPUSH
42753: EMPTY
42754: PPUSH
42755: CALL_OW 1
42759: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42760: LD_ADDR_EXP 141
42764: PUSH
42765: LD_EXP 141
42769: PPUSH
42770: LD_VAR 0 2
42774: PPUSH
42775: EMPTY
42776: PPUSH
42777: CALL_OW 1
42781: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42782: LD_ADDR_EXP 142
42786: PUSH
42787: LD_EXP 142
42791: PPUSH
42792: LD_VAR 0 2
42796: PPUSH
42797: EMPTY
42798: PPUSH
42799: CALL_OW 1
42803: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42804: LD_ADDR_EXP 143
42808: PUSH
42809: LD_EXP 143
42813: PPUSH
42814: LD_VAR 0 2
42818: PPUSH
42819: EMPTY
42820: PPUSH
42821: CALL_OW 1
42825: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42826: LD_ADDR_EXP 144
42830: PUSH
42831: LD_EXP 144
42835: PPUSH
42836: LD_VAR 0 2
42840: PPUSH
42841: LD_INT 0
42843: PPUSH
42844: CALL_OW 1
42848: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42849: LD_ADDR_EXP 145
42853: PUSH
42854: LD_EXP 145
42858: PPUSH
42859: LD_VAR 0 2
42863: PPUSH
42864: LD_INT 0
42866: PPUSH
42867: CALL_OW 1
42871: ST_TO_ADDR
// end ;
42872: GO 41773
42874: POP
42875: POP
// MC_InitSides ( ) ;
42876: CALL 43162 0 0
// MC_InitResearch ( ) ;
42880: CALL 42901 0 0
// CustomInitMacro ( ) ;
42884: CALL 475 0 0
// skirmish := true ;
42888: LD_ADDR_EXP 100
42892: PUSH
42893: LD_INT 1
42895: ST_TO_ADDR
// end ;
42896: LD_VAR 0 1
42900: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42901: LD_INT 0
42903: PPUSH
42904: PPUSH
42905: PPUSH
42906: PPUSH
42907: PPUSH
42908: PPUSH
// if not mc_bases then
42909: LD_EXP 102
42913: NOT
42914: IFFALSE 42918
// exit ;
42916: GO 43157
// for i = 1 to 8 do
42918: LD_ADDR_VAR 0 2
42922: PUSH
42923: DOUBLE
42924: LD_INT 1
42926: DEC
42927: ST_TO_ADDR
42928: LD_INT 8
42930: PUSH
42931: FOR_TO
42932: IFFALSE 42958
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42934: LD_ADDR_EXP 129
42938: PUSH
42939: LD_EXP 129
42943: PPUSH
42944: LD_VAR 0 2
42948: PPUSH
42949: EMPTY
42950: PPUSH
42951: CALL_OW 1
42955: ST_TO_ADDR
42956: GO 42931
42958: POP
42959: POP
// tmp := [ ] ;
42960: LD_ADDR_VAR 0 5
42964: PUSH
42965: EMPTY
42966: ST_TO_ADDR
// for i = 1 to mc_sides do
42967: LD_ADDR_VAR 0 2
42971: PUSH
42972: DOUBLE
42973: LD_INT 1
42975: DEC
42976: ST_TO_ADDR
42977: LD_EXP 128
42981: PUSH
42982: FOR_TO
42983: IFFALSE 43041
// if not mc_sides [ i ] in tmp then
42985: LD_EXP 128
42989: PUSH
42990: LD_VAR 0 2
42994: ARRAY
42995: PUSH
42996: LD_VAR 0 5
43000: IN
43001: NOT
43002: IFFALSE 43039
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_VAR 0 5
43013: PPUSH
43014: LD_VAR 0 5
43018: PUSH
43019: LD_INT 1
43021: PLUS
43022: PPUSH
43023: LD_EXP 128
43027: PUSH
43028: LD_VAR 0 2
43032: ARRAY
43033: PPUSH
43034: CALL_OW 2
43038: ST_TO_ADDR
43039: GO 42982
43041: POP
43042: POP
// if not tmp then
43043: LD_VAR 0 5
43047: NOT
43048: IFFALSE 43052
// exit ;
43050: GO 43157
// for j in tmp do
43052: LD_ADDR_VAR 0 3
43056: PUSH
43057: LD_VAR 0 5
43061: PUSH
43062: FOR_IN
43063: IFFALSE 43155
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43065: LD_ADDR_VAR 0 6
43069: PUSH
43070: LD_INT 22
43072: PUSH
43073: LD_VAR 0 3
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PPUSH
43082: CALL_OW 69
43086: ST_TO_ADDR
// if not un then
43087: LD_VAR 0 6
43091: NOT
43092: IFFALSE 43096
// continue ;
43094: GO 43062
// nation := GetNation ( un [ 1 ] ) ;
43096: LD_ADDR_VAR 0 4
43100: PUSH
43101: LD_VAR 0 6
43105: PUSH
43106: LD_INT 1
43108: ARRAY
43109: PPUSH
43110: CALL_OW 248
43114: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43115: LD_ADDR_EXP 129
43119: PUSH
43120: LD_EXP 129
43124: PPUSH
43125: LD_VAR 0 3
43129: PPUSH
43130: LD_VAR 0 3
43134: PPUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: LD_INT 1
43142: PPUSH
43143: CALL 70345 0 3
43147: PPUSH
43148: CALL_OW 1
43152: ST_TO_ADDR
// end ;
43153: GO 43062
43155: POP
43156: POP
// end ;
43157: LD_VAR 0 1
43161: RET
// export function MC_InitSides ( ) ; var i ; begin
43162: LD_INT 0
43164: PPUSH
43165: PPUSH
// if not mc_bases then
43166: LD_EXP 102
43170: NOT
43171: IFFALSE 43175
// exit ;
43173: GO 43249
// for i = 1 to mc_bases do
43175: LD_ADDR_VAR 0 2
43179: PUSH
43180: DOUBLE
43181: LD_INT 1
43183: DEC
43184: ST_TO_ADDR
43185: LD_EXP 102
43189: PUSH
43190: FOR_TO
43191: IFFALSE 43247
// if mc_bases [ i ] then
43193: LD_EXP 102
43197: PUSH
43198: LD_VAR 0 2
43202: ARRAY
43203: IFFALSE 43245
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43205: LD_ADDR_EXP 128
43209: PUSH
43210: LD_EXP 128
43214: PPUSH
43215: LD_VAR 0 2
43219: PPUSH
43220: LD_EXP 102
43224: PUSH
43225: LD_VAR 0 2
43229: ARRAY
43230: PUSH
43231: LD_INT 1
43233: ARRAY
43234: PPUSH
43235: CALL_OW 255
43239: PPUSH
43240: CALL_OW 1
43244: ST_TO_ADDR
43245: GO 43190
43247: POP
43248: POP
// end ;
43249: LD_VAR 0 1
43253: RET
// every 0 0$03 trigger skirmish do
43254: LD_EXP 100
43258: IFFALSE 43412
43260: GO 43262
43262: DISABLE
// begin enable ;
43263: ENABLE
// MC_CheckBuildings ( ) ;
43264: CALL 47924 0 0
// MC_CheckPeopleLife ( ) ;
43268: CALL 48085 0 0
// RaiseSailEvent ( 100 ) ;
43272: LD_INT 100
43274: PPUSH
43275: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43279: LD_INT 103
43281: PPUSH
43282: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43286: LD_INT 104
43288: PPUSH
43289: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43293: LD_INT 105
43295: PPUSH
43296: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43300: LD_INT 106
43302: PPUSH
43303: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43307: LD_INT 107
43309: PPUSH
43310: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43314: LD_INT 108
43316: PPUSH
43317: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43321: LD_INT 109
43323: PPUSH
43324: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43328: LD_INT 110
43330: PPUSH
43331: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43335: LD_INT 111
43337: PPUSH
43338: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43342: LD_INT 112
43344: PPUSH
43345: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43349: LD_INT 113
43351: PPUSH
43352: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43356: LD_INT 120
43358: PPUSH
43359: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43363: LD_INT 121
43365: PPUSH
43366: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43370: LD_INT 122
43372: PPUSH
43373: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43377: LD_INT 123
43379: PPUSH
43380: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43384: LD_INT 124
43386: PPUSH
43387: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43391: LD_INT 125
43393: PPUSH
43394: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43398: LD_INT 126
43400: PPUSH
43401: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43405: LD_INT 200
43407: PPUSH
43408: CALL_OW 427
// end ;
43412: END
// on SailEvent ( event ) do begin if event < 100 then
43413: LD_VAR 0 1
43417: PUSH
43418: LD_INT 100
43420: LESS
43421: IFFALSE 43432
// CustomEvent ( event ) ;
43423: LD_VAR 0 1
43427: PPUSH
43428: CALL 37788 0 1
// if event = 100 then
43432: LD_VAR 0 1
43436: PUSH
43437: LD_INT 100
43439: EQUAL
43440: IFFALSE 43446
// MC_ClassManager ( ) ;
43442: CALL 43838 0 0
// if event = 101 then
43446: LD_VAR 0 1
43450: PUSH
43451: LD_INT 101
43453: EQUAL
43454: IFFALSE 43460
// MC_RepairBuildings ( ) ;
43456: CALL 48670 0 0
// if event = 102 then
43460: LD_VAR 0 1
43464: PUSH
43465: LD_INT 102
43467: EQUAL
43468: IFFALSE 43474
// MC_Heal ( ) ;
43470: CALL 49605 0 0
// if event = 103 then
43474: LD_VAR 0 1
43478: PUSH
43479: LD_INT 103
43481: EQUAL
43482: IFFALSE 43488
// MC_Build ( ) ;
43484: CALL 50027 0 0
// if event = 104 then
43488: LD_VAR 0 1
43492: PUSH
43493: LD_INT 104
43495: EQUAL
43496: IFFALSE 43502
// MC_TurretWeapon ( ) ;
43498: CALL 51661 0 0
// if event = 105 then
43502: LD_VAR 0 1
43506: PUSH
43507: LD_INT 105
43509: EQUAL
43510: IFFALSE 43516
// MC_BuildUpgrade ( ) ;
43512: CALL 51212 0 0
// if event = 106 then
43516: LD_VAR 0 1
43520: PUSH
43521: LD_INT 106
43523: EQUAL
43524: IFFALSE 43530
// MC_PlantMines ( ) ;
43526: CALL 52091 0 0
// if event = 107 then
43530: LD_VAR 0 1
43534: PUSH
43535: LD_INT 107
43537: EQUAL
43538: IFFALSE 43544
// MC_CollectCrates ( ) ;
43540: CALL 52889 0 0
// if event = 108 then
43544: LD_VAR 0 1
43548: PUSH
43549: LD_INT 108
43551: EQUAL
43552: IFFALSE 43558
// MC_LinkRemoteControl ( ) ;
43554: CALL 54739 0 0
// if event = 109 then
43558: LD_VAR 0 1
43562: PUSH
43563: LD_INT 109
43565: EQUAL
43566: IFFALSE 43572
// MC_ProduceVehicle ( ) ;
43568: CALL 54920 0 0
// if event = 110 then
43572: LD_VAR 0 1
43576: PUSH
43577: LD_INT 110
43579: EQUAL
43580: IFFALSE 43586
// MC_SendAttack ( ) ;
43582: CALL 55386 0 0
// if event = 111 then
43586: LD_VAR 0 1
43590: PUSH
43591: LD_INT 111
43593: EQUAL
43594: IFFALSE 43600
// MC_Defend ( ) ;
43596: CALL 55494 0 0
// if event = 112 then
43600: LD_VAR 0 1
43604: PUSH
43605: LD_INT 112
43607: EQUAL
43608: IFFALSE 43614
// MC_Research ( ) ;
43610: CALL 56374 0 0
// if event = 113 then
43614: LD_VAR 0 1
43618: PUSH
43619: LD_INT 113
43621: EQUAL
43622: IFFALSE 43628
// MC_MinesTrigger ( ) ;
43624: CALL 57488 0 0
// if event = 120 then
43628: LD_VAR 0 1
43632: PUSH
43633: LD_INT 120
43635: EQUAL
43636: IFFALSE 43642
// MC_RepairVehicle ( ) ;
43638: CALL 57587 0 0
// if event = 121 then
43642: LD_VAR 0 1
43646: PUSH
43647: LD_INT 121
43649: EQUAL
43650: IFFALSE 43656
// MC_TameApe ( ) ;
43652: CALL 58356 0 0
// if event = 122 then
43656: LD_VAR 0 1
43660: PUSH
43661: LD_INT 122
43663: EQUAL
43664: IFFALSE 43670
// MC_ChangeApeClass ( ) ;
43666: CALL 59185 0 0
// if event = 123 then
43670: LD_VAR 0 1
43674: PUSH
43675: LD_INT 123
43677: EQUAL
43678: IFFALSE 43684
// MC_Bazooka ( ) ;
43680: CALL 59835 0 0
// if event = 124 then
43684: LD_VAR 0 1
43688: PUSH
43689: LD_INT 124
43691: EQUAL
43692: IFFALSE 43698
// MC_TeleportExit ( ) ;
43694: CALL 60033 0 0
// if event = 125 then
43698: LD_VAR 0 1
43702: PUSH
43703: LD_INT 125
43705: EQUAL
43706: IFFALSE 43712
// MC_Deposits ( ) ;
43708: CALL 60680 0 0
// if event = 126 then
43712: LD_VAR 0 1
43716: PUSH
43717: LD_INT 126
43719: EQUAL
43720: IFFALSE 43726
// MC_RemoteDriver ( ) ;
43722: CALL 61305 0 0
// if event = 200 then
43726: LD_VAR 0 1
43730: PUSH
43731: LD_INT 200
43733: EQUAL
43734: IFFALSE 43740
// MC_Idle ( ) ;
43736: CALL 63212 0 0
// end ;
43740: PPOPN 1
43742: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43743: LD_INT 0
43745: PPUSH
43746: PPUSH
// if not mc_bases [ base ] or not tag then
43747: LD_EXP 102
43751: PUSH
43752: LD_VAR 0 1
43756: ARRAY
43757: NOT
43758: PUSH
43759: LD_VAR 0 2
43763: NOT
43764: OR
43765: IFFALSE 43769
// exit ;
43767: GO 43833
// for i in mc_bases [ base ] union mc_ape [ base ] do
43769: LD_ADDR_VAR 0 4
43773: PUSH
43774: LD_EXP 102
43778: PUSH
43779: LD_VAR 0 1
43783: ARRAY
43784: PUSH
43785: LD_EXP 131
43789: PUSH
43790: LD_VAR 0 1
43794: ARRAY
43795: UNION
43796: PUSH
43797: FOR_IN
43798: IFFALSE 43831
// if GetTag ( i ) = tag then
43800: LD_VAR 0 4
43804: PPUSH
43805: CALL_OW 110
43809: PUSH
43810: LD_VAR 0 2
43814: EQUAL
43815: IFFALSE 43829
// SetTag ( i , 0 ) ;
43817: LD_VAR 0 4
43821: PPUSH
43822: LD_INT 0
43824: PPUSH
43825: CALL_OW 109
43829: GO 43797
43831: POP
43832: POP
// end ;
43833: LD_VAR 0 3
43837: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43838: LD_INT 0
43840: PPUSH
43841: PPUSH
43842: PPUSH
43843: PPUSH
43844: PPUSH
43845: PPUSH
43846: PPUSH
43847: PPUSH
// if not mc_bases then
43848: LD_EXP 102
43852: NOT
43853: IFFALSE 43857
// exit ;
43855: GO 44306
// for i = 1 to mc_bases do
43857: LD_ADDR_VAR 0 2
43861: PUSH
43862: DOUBLE
43863: LD_INT 1
43865: DEC
43866: ST_TO_ADDR
43867: LD_EXP 102
43871: PUSH
43872: FOR_TO
43873: IFFALSE 44304
// begin tmp := MC_ClassCheckReq ( i ) ;
43875: LD_ADDR_VAR 0 4
43879: PUSH
43880: LD_VAR 0 2
43884: PPUSH
43885: CALL 44311 0 1
43889: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43890: LD_ADDR_EXP 143
43894: PUSH
43895: LD_EXP 143
43899: PPUSH
43900: LD_VAR 0 2
43904: PPUSH
43905: LD_VAR 0 4
43909: PPUSH
43910: CALL_OW 1
43914: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43915: LD_ADDR_VAR 0 6
43919: PUSH
43920: LD_EXP 102
43924: PUSH
43925: LD_VAR 0 2
43929: ARRAY
43930: PPUSH
43931: LD_INT 2
43933: PUSH
43934: LD_INT 30
43936: PUSH
43937: LD_INT 4
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 30
43946: PUSH
43947: LD_INT 5
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: LIST
43958: PPUSH
43959: CALL_OW 72
43963: PUSH
43964: LD_EXP 102
43968: PUSH
43969: LD_VAR 0 2
43973: ARRAY
43974: PPUSH
43975: LD_INT 2
43977: PUSH
43978: LD_INT 30
43980: PUSH
43981: LD_INT 0
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 30
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: LIST
44002: PPUSH
44003: CALL_OW 72
44007: PUSH
44008: LD_EXP 102
44012: PUSH
44013: LD_VAR 0 2
44017: ARRAY
44018: PPUSH
44019: LD_INT 30
44021: PUSH
44022: LD_INT 3
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PPUSH
44029: CALL_OW 72
44033: PUSH
44034: LD_EXP 102
44038: PUSH
44039: LD_VAR 0 2
44043: ARRAY
44044: PPUSH
44045: LD_INT 2
44047: PUSH
44048: LD_INT 30
44050: PUSH
44051: LD_INT 6
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 30
44060: PUSH
44061: LD_INT 7
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 30
44070: PUSH
44071: LD_INT 8
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: PPUSH
44084: CALL_OW 72
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: ST_TO_ADDR
// for j := 1 to 4 do
44095: LD_ADDR_VAR 0 3
44099: PUSH
44100: DOUBLE
44101: LD_INT 1
44103: DEC
44104: ST_TO_ADDR
44105: LD_INT 4
44107: PUSH
44108: FOR_TO
44109: IFFALSE 44300
// begin if not tmp [ j ] then
44111: LD_VAR 0 4
44115: PUSH
44116: LD_VAR 0 3
44120: ARRAY
44121: NOT
44122: IFFALSE 44126
// continue ;
44124: GO 44108
// for p in tmp [ j ] do
44126: LD_ADDR_VAR 0 5
44130: PUSH
44131: LD_VAR 0 4
44135: PUSH
44136: LD_VAR 0 3
44140: ARRAY
44141: PUSH
44142: FOR_IN
44143: IFFALSE 44296
// begin if not b [ j ] then
44145: LD_VAR 0 6
44149: PUSH
44150: LD_VAR 0 3
44154: ARRAY
44155: NOT
44156: IFFALSE 44160
// break ;
44158: GO 44296
// e := 0 ;
44160: LD_ADDR_VAR 0 7
44164: PUSH
44165: LD_INT 0
44167: ST_TO_ADDR
// for k in b [ j ] do
44168: LD_ADDR_VAR 0 8
44172: PUSH
44173: LD_VAR 0 6
44177: PUSH
44178: LD_VAR 0 3
44182: ARRAY
44183: PUSH
44184: FOR_IN
44185: IFFALSE 44212
// if IsNotFull ( k ) then
44187: LD_VAR 0 8
44191: PPUSH
44192: CALL 72466 0 1
44196: IFFALSE 44210
// begin e := k ;
44198: LD_ADDR_VAR 0 7
44202: PUSH
44203: LD_VAR 0 8
44207: ST_TO_ADDR
// break ;
44208: GO 44212
// end ;
44210: GO 44184
44212: POP
44213: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44214: LD_VAR 0 7
44218: PUSH
44219: LD_VAR 0 5
44223: PPUSH
44224: LD_VAR 0 7
44228: PPUSH
44229: CALL 106605 0 2
44233: NOT
44234: AND
44235: IFFALSE 44294
// begin if IsInUnit ( p ) then
44237: LD_VAR 0 5
44241: PPUSH
44242: CALL_OW 310
44246: IFFALSE 44257
// ComExitBuilding ( p ) ;
44248: LD_VAR 0 5
44252: PPUSH
44253: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44257: LD_VAR 0 5
44261: PPUSH
44262: LD_VAR 0 7
44266: PPUSH
44267: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44271: LD_VAR 0 5
44275: PPUSH
44276: LD_VAR 0 3
44280: PPUSH
44281: CALL_OW 183
// AddComExitBuilding ( p ) ;
44285: LD_VAR 0 5
44289: PPUSH
44290: CALL_OW 182
// end ; end ;
44294: GO 44142
44296: POP
44297: POP
// end ;
44298: GO 44108
44300: POP
44301: POP
// end ;
44302: GO 43872
44304: POP
44305: POP
// end ;
44306: LD_VAR 0 1
44310: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44311: LD_INT 0
44313: PPUSH
44314: PPUSH
44315: PPUSH
44316: PPUSH
44317: PPUSH
44318: PPUSH
44319: PPUSH
44320: PPUSH
44321: PPUSH
44322: PPUSH
44323: PPUSH
44324: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44325: LD_ADDR_VAR 0 2
44329: PUSH
44330: LD_INT 0
44332: PUSH
44333: LD_INT 0
44335: PUSH
44336: LD_INT 0
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44348: LD_VAR 0 1
44352: NOT
44353: PUSH
44354: LD_EXP 102
44358: PUSH
44359: LD_VAR 0 1
44363: ARRAY
44364: NOT
44365: OR
44366: PUSH
44367: LD_EXP 102
44371: PUSH
44372: LD_VAR 0 1
44376: ARRAY
44377: PPUSH
44378: LD_INT 2
44380: PUSH
44381: LD_INT 30
44383: PUSH
44384: LD_INT 0
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 30
44393: PUSH
44394: LD_INT 1
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: LIST
44405: PPUSH
44406: CALL_OW 72
44410: NOT
44411: OR
44412: IFFALSE 44416
// exit ;
44414: GO 47919
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44416: LD_ADDR_VAR 0 4
44420: PUSH
44421: LD_EXP 102
44425: PUSH
44426: LD_VAR 0 1
44430: ARRAY
44431: PPUSH
44432: LD_INT 2
44434: PUSH
44435: LD_INT 25
44437: PUSH
44438: LD_INT 1
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 25
44447: PUSH
44448: LD_INT 2
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 25
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 25
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 25
44477: PUSH
44478: LD_INT 5
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 25
44487: PUSH
44488: LD_INT 8
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 25
44497: PUSH
44498: LD_INT 9
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: LIST
44513: LIST
44514: PPUSH
44515: CALL_OW 72
44519: ST_TO_ADDR
// if not tmp then
44520: LD_VAR 0 4
44524: NOT
44525: IFFALSE 44529
// exit ;
44527: GO 47919
// for i in tmp do
44529: LD_ADDR_VAR 0 3
44533: PUSH
44534: LD_VAR 0 4
44538: PUSH
44539: FOR_IN
44540: IFFALSE 44571
// if GetTag ( i ) then
44542: LD_VAR 0 3
44546: PPUSH
44547: CALL_OW 110
44551: IFFALSE 44569
// tmp := tmp diff i ;
44553: LD_ADDR_VAR 0 4
44557: PUSH
44558: LD_VAR 0 4
44562: PUSH
44563: LD_VAR 0 3
44567: DIFF
44568: ST_TO_ADDR
44569: GO 44539
44571: POP
44572: POP
// if not tmp then
44573: LD_VAR 0 4
44577: NOT
44578: IFFALSE 44582
// exit ;
44580: GO 47919
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44582: LD_ADDR_VAR 0 5
44586: PUSH
44587: LD_EXP 102
44591: PUSH
44592: LD_VAR 0 1
44596: ARRAY
44597: PPUSH
44598: LD_INT 2
44600: PUSH
44601: LD_INT 25
44603: PUSH
44604: LD_INT 1
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 25
44613: PUSH
44614: LD_INT 5
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 25
44623: PUSH
44624: LD_INT 8
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 25
44633: PUSH
44634: LD_INT 9
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: PPUSH
44648: CALL_OW 72
44652: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44653: LD_ADDR_VAR 0 6
44657: PUSH
44658: LD_EXP 102
44662: PUSH
44663: LD_VAR 0 1
44667: ARRAY
44668: PPUSH
44669: LD_INT 25
44671: PUSH
44672: LD_INT 2
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PPUSH
44679: CALL_OW 72
44683: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44684: LD_ADDR_VAR 0 7
44688: PUSH
44689: LD_EXP 102
44693: PUSH
44694: LD_VAR 0 1
44698: ARRAY
44699: PPUSH
44700: LD_INT 25
44702: PUSH
44703: LD_INT 3
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PPUSH
44710: CALL_OW 72
44714: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44715: LD_ADDR_VAR 0 8
44719: PUSH
44720: LD_EXP 102
44724: PUSH
44725: LD_VAR 0 1
44729: ARRAY
44730: PPUSH
44731: LD_INT 25
44733: PUSH
44734: LD_INT 4
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: LD_INT 24
44743: PUSH
44744: LD_INT 251
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PPUSH
44755: CALL_OW 72
44759: ST_TO_ADDR
// if mc_is_defending [ base ] then
44760: LD_EXP 145
44764: PUSH
44765: LD_VAR 0 1
44769: ARRAY
44770: IFFALSE 45231
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44772: LD_ADDR_EXP 144
44776: PUSH
44777: LD_EXP 144
44781: PPUSH
44782: LD_VAR 0 1
44786: PPUSH
44787: LD_INT 4
44789: PPUSH
44790: CALL_OW 1
44794: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44795: LD_ADDR_VAR 0 12
44799: PUSH
44800: LD_EXP 102
44804: PUSH
44805: LD_VAR 0 1
44809: ARRAY
44810: PPUSH
44811: LD_INT 2
44813: PUSH
44814: LD_INT 30
44816: PUSH
44817: LD_INT 4
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: LD_INT 30
44826: PUSH
44827: LD_INT 5
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: LIST
44838: PPUSH
44839: CALL_OW 72
44843: ST_TO_ADDR
// if not b then
44844: LD_VAR 0 12
44848: NOT
44849: IFFALSE 44853
// exit ;
44851: GO 47919
// p := [ ] ;
44853: LD_ADDR_VAR 0 11
44857: PUSH
44858: EMPTY
44859: ST_TO_ADDR
// if sci >= 2 then
44860: LD_VAR 0 8
44864: PUSH
44865: LD_INT 2
44867: GREATEREQUAL
44868: IFFALSE 44899
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44870: LD_ADDR_VAR 0 8
44874: PUSH
44875: LD_VAR 0 8
44879: PUSH
44880: LD_INT 1
44882: ARRAY
44883: PUSH
44884: LD_VAR 0 8
44888: PUSH
44889: LD_INT 2
44891: ARRAY
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: ST_TO_ADDR
44897: GO 44960
// if sci = 1 then
44899: LD_VAR 0 8
44903: PUSH
44904: LD_INT 1
44906: EQUAL
44907: IFFALSE 44928
// sci := [ sci [ 1 ] ] else
44909: LD_ADDR_VAR 0 8
44913: PUSH
44914: LD_VAR 0 8
44918: PUSH
44919: LD_INT 1
44921: ARRAY
44922: PUSH
44923: EMPTY
44924: LIST
44925: ST_TO_ADDR
44926: GO 44960
// if sci = 0 then
44928: LD_VAR 0 8
44932: PUSH
44933: LD_INT 0
44935: EQUAL
44936: IFFALSE 44960
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44938: LD_ADDR_VAR 0 11
44942: PUSH
44943: LD_VAR 0 4
44947: PPUSH
44948: LD_INT 4
44950: PPUSH
44951: CALL 106477 0 2
44955: PUSH
44956: LD_INT 1
44958: ARRAY
44959: ST_TO_ADDR
// if eng > 4 then
44960: LD_VAR 0 6
44964: PUSH
44965: LD_INT 4
44967: GREATER
44968: IFFALSE 45014
// for i = eng downto 4 do
44970: LD_ADDR_VAR 0 3
44974: PUSH
44975: DOUBLE
44976: LD_VAR 0 6
44980: INC
44981: ST_TO_ADDR
44982: LD_INT 4
44984: PUSH
44985: FOR_DOWNTO
44986: IFFALSE 45012
// eng := eng diff eng [ i ] ;
44988: LD_ADDR_VAR 0 6
44992: PUSH
44993: LD_VAR 0 6
44997: PUSH
44998: LD_VAR 0 6
45002: PUSH
45003: LD_VAR 0 3
45007: ARRAY
45008: DIFF
45009: ST_TO_ADDR
45010: GO 44985
45012: POP
45013: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45014: LD_ADDR_VAR 0 4
45018: PUSH
45019: LD_VAR 0 4
45023: PUSH
45024: LD_VAR 0 5
45028: PUSH
45029: LD_VAR 0 6
45033: UNION
45034: PUSH
45035: LD_VAR 0 7
45039: UNION
45040: PUSH
45041: LD_VAR 0 8
45045: UNION
45046: DIFF
45047: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45048: LD_ADDR_VAR 0 13
45052: PUSH
45053: LD_EXP 102
45057: PUSH
45058: LD_VAR 0 1
45062: ARRAY
45063: PPUSH
45064: LD_INT 2
45066: PUSH
45067: LD_INT 30
45069: PUSH
45070: LD_INT 32
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 30
45079: PUSH
45080: LD_INT 31
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: LIST
45091: PPUSH
45092: CALL_OW 72
45096: PUSH
45097: LD_EXP 102
45101: PUSH
45102: LD_VAR 0 1
45106: ARRAY
45107: PPUSH
45108: LD_INT 2
45110: PUSH
45111: LD_INT 30
45113: PUSH
45114: LD_INT 4
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 30
45123: PUSH
45124: LD_INT 5
45126: PUSH
45127: EMPTY
45128: LIST
45129: LIST
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: LIST
45135: PPUSH
45136: CALL_OW 72
45140: PUSH
45141: LD_INT 6
45143: MUL
45144: PLUS
45145: ST_TO_ADDR
// if bcount < tmp then
45146: LD_VAR 0 13
45150: PUSH
45151: LD_VAR 0 4
45155: LESS
45156: IFFALSE 45202
// for i = tmp downto bcount do
45158: LD_ADDR_VAR 0 3
45162: PUSH
45163: DOUBLE
45164: LD_VAR 0 4
45168: INC
45169: ST_TO_ADDR
45170: LD_VAR 0 13
45174: PUSH
45175: FOR_DOWNTO
45176: IFFALSE 45200
// tmp := Delete ( tmp , tmp ) ;
45178: LD_ADDR_VAR 0 4
45182: PUSH
45183: LD_VAR 0 4
45187: PPUSH
45188: LD_VAR 0 4
45192: PPUSH
45193: CALL_OW 3
45197: ST_TO_ADDR
45198: GO 45175
45200: POP
45201: POP
// result := [ tmp , 0 , 0 , p ] ;
45202: LD_ADDR_VAR 0 2
45206: PUSH
45207: LD_VAR 0 4
45211: PUSH
45212: LD_INT 0
45214: PUSH
45215: LD_INT 0
45217: PUSH
45218: LD_VAR 0 11
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: ST_TO_ADDR
// exit ;
45229: GO 47919
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45231: LD_EXP 102
45235: PUSH
45236: LD_VAR 0 1
45240: ARRAY
45241: PPUSH
45242: LD_INT 2
45244: PUSH
45245: LD_INT 30
45247: PUSH
45248: LD_INT 6
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: LD_INT 30
45257: PUSH
45258: LD_INT 7
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PUSH
45265: LD_INT 30
45267: PUSH
45268: LD_INT 8
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: PPUSH
45281: CALL_OW 72
45285: NOT
45286: PUSH
45287: LD_EXP 102
45291: PUSH
45292: LD_VAR 0 1
45296: ARRAY
45297: PPUSH
45298: LD_INT 30
45300: PUSH
45301: LD_INT 3
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PPUSH
45308: CALL_OW 72
45312: NOT
45313: AND
45314: IFFALSE 45386
// begin if eng = tmp then
45316: LD_VAR 0 6
45320: PUSH
45321: LD_VAR 0 4
45325: EQUAL
45326: IFFALSE 45330
// exit ;
45328: GO 47919
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45330: LD_ADDR_EXP 144
45334: PUSH
45335: LD_EXP 144
45339: PPUSH
45340: LD_VAR 0 1
45344: PPUSH
45345: LD_INT 1
45347: PPUSH
45348: CALL_OW 1
45352: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45353: LD_ADDR_VAR 0 2
45357: PUSH
45358: LD_INT 0
45360: PUSH
45361: LD_VAR 0 4
45365: PUSH
45366: LD_VAR 0 6
45370: DIFF
45371: PUSH
45372: LD_INT 0
45374: PUSH
45375: LD_INT 0
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: ST_TO_ADDR
// exit ;
45384: GO 47919
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45386: LD_EXP 129
45390: PUSH
45391: LD_EXP 128
45395: PUSH
45396: LD_VAR 0 1
45400: ARRAY
45401: ARRAY
45402: PUSH
45403: LD_EXP 102
45407: PUSH
45408: LD_VAR 0 1
45412: ARRAY
45413: PPUSH
45414: LD_INT 2
45416: PUSH
45417: LD_INT 30
45419: PUSH
45420: LD_INT 6
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 30
45429: PUSH
45430: LD_INT 7
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 30
45439: PUSH
45440: LD_INT 8
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: PPUSH
45453: CALL_OW 72
45457: AND
45458: PUSH
45459: LD_EXP 102
45463: PUSH
45464: LD_VAR 0 1
45468: ARRAY
45469: PPUSH
45470: LD_INT 30
45472: PUSH
45473: LD_INT 3
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PPUSH
45480: CALL_OW 72
45484: NOT
45485: AND
45486: IFFALSE 45700
// begin if sci >= 6 then
45488: LD_VAR 0 8
45492: PUSH
45493: LD_INT 6
45495: GREATEREQUAL
45496: IFFALSE 45500
// exit ;
45498: GO 47919
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45500: LD_ADDR_EXP 144
45504: PUSH
45505: LD_EXP 144
45509: PPUSH
45510: LD_VAR 0 1
45514: PPUSH
45515: LD_INT 2
45517: PPUSH
45518: CALL_OW 1
45522: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45523: LD_ADDR_VAR 0 9
45527: PUSH
45528: LD_VAR 0 4
45532: PUSH
45533: LD_VAR 0 8
45537: DIFF
45538: PPUSH
45539: LD_INT 4
45541: PPUSH
45542: CALL 106477 0 2
45546: ST_TO_ADDR
// p := [ ] ;
45547: LD_ADDR_VAR 0 11
45551: PUSH
45552: EMPTY
45553: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45554: LD_VAR 0 8
45558: PUSH
45559: LD_INT 6
45561: LESS
45562: PUSH
45563: LD_VAR 0 9
45567: PUSH
45568: LD_INT 6
45570: GREATER
45571: AND
45572: IFFALSE 45653
// begin for i = 1 to 6 - sci do
45574: LD_ADDR_VAR 0 3
45578: PUSH
45579: DOUBLE
45580: LD_INT 1
45582: DEC
45583: ST_TO_ADDR
45584: LD_INT 6
45586: PUSH
45587: LD_VAR 0 8
45591: MINUS
45592: PUSH
45593: FOR_TO
45594: IFFALSE 45649
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45596: LD_ADDR_VAR 0 11
45600: PUSH
45601: LD_VAR 0 11
45605: PPUSH
45606: LD_VAR 0 11
45610: PUSH
45611: LD_INT 1
45613: PLUS
45614: PPUSH
45615: LD_VAR 0 9
45619: PUSH
45620: LD_INT 1
45622: ARRAY
45623: PPUSH
45624: CALL_OW 2
45628: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45629: LD_ADDR_VAR 0 9
45633: PUSH
45634: LD_VAR 0 9
45638: PPUSH
45639: LD_INT 1
45641: PPUSH
45642: CALL_OW 3
45646: ST_TO_ADDR
// end ;
45647: GO 45593
45649: POP
45650: POP
// end else
45651: GO 45673
// if sort then
45653: LD_VAR 0 9
45657: IFFALSE 45673
// p := sort [ 1 ] ;
45659: LD_ADDR_VAR 0 11
45663: PUSH
45664: LD_VAR 0 9
45668: PUSH
45669: LD_INT 1
45671: ARRAY
45672: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45673: LD_ADDR_VAR 0 2
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: LD_INT 0
45683: PUSH
45684: LD_INT 0
45686: PUSH
45687: LD_VAR 0 11
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: ST_TO_ADDR
// exit ;
45698: GO 47919
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45700: LD_EXP 129
45704: PUSH
45705: LD_EXP 128
45709: PUSH
45710: LD_VAR 0 1
45714: ARRAY
45715: ARRAY
45716: PUSH
45717: LD_EXP 102
45721: PUSH
45722: LD_VAR 0 1
45726: ARRAY
45727: PPUSH
45728: LD_INT 2
45730: PUSH
45731: LD_INT 30
45733: PUSH
45734: LD_INT 6
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 30
45743: PUSH
45744: LD_INT 7
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: LD_INT 30
45753: PUSH
45754: LD_INT 8
45756: PUSH
45757: EMPTY
45758: LIST
45759: LIST
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: PPUSH
45767: CALL_OW 72
45771: AND
45772: PUSH
45773: LD_EXP 102
45777: PUSH
45778: LD_VAR 0 1
45782: ARRAY
45783: PPUSH
45784: LD_INT 30
45786: PUSH
45787: LD_INT 3
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PPUSH
45794: CALL_OW 72
45798: AND
45799: IFFALSE 46533
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45801: LD_ADDR_EXP 144
45805: PUSH
45806: LD_EXP 144
45810: PPUSH
45811: LD_VAR 0 1
45815: PPUSH
45816: LD_INT 3
45818: PPUSH
45819: CALL_OW 1
45823: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45824: LD_ADDR_VAR 0 2
45828: PUSH
45829: LD_INT 0
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: LD_INT 0
45837: PUSH
45838: LD_INT 0
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: ST_TO_ADDR
// if not eng then
45847: LD_VAR 0 6
45851: NOT
45852: IFFALSE 45915
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45854: LD_ADDR_VAR 0 11
45858: PUSH
45859: LD_VAR 0 4
45863: PPUSH
45864: LD_INT 2
45866: PPUSH
45867: CALL 106477 0 2
45871: PUSH
45872: LD_INT 1
45874: ARRAY
45875: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45876: LD_ADDR_VAR 0 2
45880: PUSH
45881: LD_VAR 0 2
45885: PPUSH
45886: LD_INT 2
45888: PPUSH
45889: LD_VAR 0 11
45893: PPUSH
45894: CALL_OW 1
45898: ST_TO_ADDR
// tmp := tmp diff p ;
45899: LD_ADDR_VAR 0 4
45903: PUSH
45904: LD_VAR 0 4
45908: PUSH
45909: LD_VAR 0 11
45913: DIFF
45914: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45915: LD_VAR 0 4
45919: PUSH
45920: LD_VAR 0 8
45924: PUSH
45925: LD_INT 6
45927: LESS
45928: AND
45929: IFFALSE 46117
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45931: LD_ADDR_VAR 0 9
45935: PUSH
45936: LD_VAR 0 4
45940: PUSH
45941: LD_VAR 0 8
45945: PUSH
45946: LD_VAR 0 7
45950: UNION
45951: DIFF
45952: PPUSH
45953: LD_INT 4
45955: PPUSH
45956: CALL 106477 0 2
45960: ST_TO_ADDR
// p := [ ] ;
45961: LD_ADDR_VAR 0 11
45965: PUSH
45966: EMPTY
45967: ST_TO_ADDR
// if sort then
45968: LD_VAR 0 9
45972: IFFALSE 46088
// for i = 1 to 6 - sci do
45974: LD_ADDR_VAR 0 3
45978: PUSH
45979: DOUBLE
45980: LD_INT 1
45982: DEC
45983: ST_TO_ADDR
45984: LD_INT 6
45986: PUSH
45987: LD_VAR 0 8
45991: MINUS
45992: PUSH
45993: FOR_TO
45994: IFFALSE 46086
// begin if i = sort then
45996: LD_VAR 0 3
46000: PUSH
46001: LD_VAR 0 9
46005: EQUAL
46006: IFFALSE 46010
// break ;
46008: GO 46086
// if GetClass ( i ) = 4 then
46010: LD_VAR 0 3
46014: PPUSH
46015: CALL_OW 257
46019: PUSH
46020: LD_INT 4
46022: EQUAL
46023: IFFALSE 46027
// continue ;
46025: GO 45993
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46027: LD_ADDR_VAR 0 11
46031: PUSH
46032: LD_VAR 0 11
46036: PPUSH
46037: LD_VAR 0 11
46041: PUSH
46042: LD_INT 1
46044: PLUS
46045: PPUSH
46046: LD_VAR 0 9
46050: PUSH
46051: LD_VAR 0 3
46055: ARRAY
46056: PPUSH
46057: CALL_OW 2
46061: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46062: LD_ADDR_VAR 0 4
46066: PUSH
46067: LD_VAR 0 4
46071: PUSH
46072: LD_VAR 0 9
46076: PUSH
46077: LD_VAR 0 3
46081: ARRAY
46082: DIFF
46083: ST_TO_ADDR
// end ;
46084: GO 45993
46086: POP
46087: POP
// if p then
46088: LD_VAR 0 11
46092: IFFALSE 46117
// result := Replace ( result , 4 , p ) ;
46094: LD_ADDR_VAR 0 2
46098: PUSH
46099: LD_VAR 0 2
46103: PPUSH
46104: LD_INT 4
46106: PPUSH
46107: LD_VAR 0 11
46111: PPUSH
46112: CALL_OW 1
46116: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46117: LD_VAR 0 4
46121: PUSH
46122: LD_VAR 0 7
46126: PUSH
46127: LD_INT 6
46129: LESS
46130: AND
46131: IFFALSE 46319
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46133: LD_ADDR_VAR 0 9
46137: PUSH
46138: LD_VAR 0 4
46142: PUSH
46143: LD_VAR 0 8
46147: PUSH
46148: LD_VAR 0 7
46152: UNION
46153: DIFF
46154: PPUSH
46155: LD_INT 3
46157: PPUSH
46158: CALL 106477 0 2
46162: ST_TO_ADDR
// p := [ ] ;
46163: LD_ADDR_VAR 0 11
46167: PUSH
46168: EMPTY
46169: ST_TO_ADDR
// if sort then
46170: LD_VAR 0 9
46174: IFFALSE 46290
// for i = 1 to 6 - mech do
46176: LD_ADDR_VAR 0 3
46180: PUSH
46181: DOUBLE
46182: LD_INT 1
46184: DEC
46185: ST_TO_ADDR
46186: LD_INT 6
46188: PUSH
46189: LD_VAR 0 7
46193: MINUS
46194: PUSH
46195: FOR_TO
46196: IFFALSE 46288
// begin if i = sort then
46198: LD_VAR 0 3
46202: PUSH
46203: LD_VAR 0 9
46207: EQUAL
46208: IFFALSE 46212
// break ;
46210: GO 46288
// if GetClass ( i ) = 3 then
46212: LD_VAR 0 3
46216: PPUSH
46217: CALL_OW 257
46221: PUSH
46222: LD_INT 3
46224: EQUAL
46225: IFFALSE 46229
// continue ;
46227: GO 46195
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46229: LD_ADDR_VAR 0 11
46233: PUSH
46234: LD_VAR 0 11
46238: PPUSH
46239: LD_VAR 0 11
46243: PUSH
46244: LD_INT 1
46246: PLUS
46247: PPUSH
46248: LD_VAR 0 9
46252: PUSH
46253: LD_VAR 0 3
46257: ARRAY
46258: PPUSH
46259: CALL_OW 2
46263: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46264: LD_ADDR_VAR 0 4
46268: PUSH
46269: LD_VAR 0 4
46273: PUSH
46274: LD_VAR 0 9
46278: PUSH
46279: LD_VAR 0 3
46283: ARRAY
46284: DIFF
46285: ST_TO_ADDR
// end ;
46286: GO 46195
46288: POP
46289: POP
// if p then
46290: LD_VAR 0 11
46294: IFFALSE 46319
// result := Replace ( result , 3 , p ) ;
46296: LD_ADDR_VAR 0 2
46300: PUSH
46301: LD_VAR 0 2
46305: PPUSH
46306: LD_INT 3
46308: PPUSH
46309: LD_VAR 0 11
46313: PPUSH
46314: CALL_OW 1
46318: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46319: LD_VAR 0 4
46323: PUSH
46324: LD_INT 6
46326: GREATER
46327: PUSH
46328: LD_VAR 0 6
46332: PUSH
46333: LD_INT 6
46335: LESS
46336: AND
46337: IFFALSE 46531
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46339: LD_ADDR_VAR 0 9
46343: PUSH
46344: LD_VAR 0 4
46348: PUSH
46349: LD_VAR 0 8
46353: PUSH
46354: LD_VAR 0 7
46358: UNION
46359: PUSH
46360: LD_VAR 0 6
46364: UNION
46365: DIFF
46366: PPUSH
46367: LD_INT 2
46369: PPUSH
46370: CALL 106477 0 2
46374: ST_TO_ADDR
// p := [ ] ;
46375: LD_ADDR_VAR 0 11
46379: PUSH
46380: EMPTY
46381: ST_TO_ADDR
// if sort then
46382: LD_VAR 0 9
46386: IFFALSE 46502
// for i = 1 to 6 - eng do
46388: LD_ADDR_VAR 0 3
46392: PUSH
46393: DOUBLE
46394: LD_INT 1
46396: DEC
46397: ST_TO_ADDR
46398: LD_INT 6
46400: PUSH
46401: LD_VAR 0 6
46405: MINUS
46406: PUSH
46407: FOR_TO
46408: IFFALSE 46500
// begin if i = sort then
46410: LD_VAR 0 3
46414: PUSH
46415: LD_VAR 0 9
46419: EQUAL
46420: IFFALSE 46424
// break ;
46422: GO 46500
// if GetClass ( i ) = 2 then
46424: LD_VAR 0 3
46428: PPUSH
46429: CALL_OW 257
46433: PUSH
46434: LD_INT 2
46436: EQUAL
46437: IFFALSE 46441
// continue ;
46439: GO 46407
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46441: LD_ADDR_VAR 0 11
46445: PUSH
46446: LD_VAR 0 11
46450: PPUSH
46451: LD_VAR 0 11
46455: PUSH
46456: LD_INT 1
46458: PLUS
46459: PPUSH
46460: LD_VAR 0 9
46464: PUSH
46465: LD_VAR 0 3
46469: ARRAY
46470: PPUSH
46471: CALL_OW 2
46475: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46476: LD_ADDR_VAR 0 4
46480: PUSH
46481: LD_VAR 0 4
46485: PUSH
46486: LD_VAR 0 9
46490: PUSH
46491: LD_VAR 0 3
46495: ARRAY
46496: DIFF
46497: ST_TO_ADDR
// end ;
46498: GO 46407
46500: POP
46501: POP
// if p then
46502: LD_VAR 0 11
46506: IFFALSE 46531
// result := Replace ( result , 2 , p ) ;
46508: LD_ADDR_VAR 0 2
46512: PUSH
46513: LD_VAR 0 2
46517: PPUSH
46518: LD_INT 2
46520: PPUSH
46521: LD_VAR 0 11
46525: PPUSH
46526: CALL_OW 1
46530: ST_TO_ADDR
// end ; exit ;
46531: GO 47919
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46533: LD_EXP 129
46537: PUSH
46538: LD_EXP 128
46542: PUSH
46543: LD_VAR 0 1
46547: ARRAY
46548: ARRAY
46549: NOT
46550: PUSH
46551: LD_EXP 102
46555: PUSH
46556: LD_VAR 0 1
46560: ARRAY
46561: PPUSH
46562: LD_INT 30
46564: PUSH
46565: LD_INT 3
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PPUSH
46572: CALL_OW 72
46576: AND
46577: PUSH
46578: LD_EXP 107
46582: PUSH
46583: LD_VAR 0 1
46587: ARRAY
46588: AND
46589: IFFALSE 47197
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46591: LD_ADDR_EXP 144
46595: PUSH
46596: LD_EXP 144
46600: PPUSH
46601: LD_VAR 0 1
46605: PPUSH
46606: LD_INT 5
46608: PPUSH
46609: CALL_OW 1
46613: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46614: LD_ADDR_VAR 0 2
46618: PUSH
46619: LD_INT 0
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: LD_INT 0
46627: PUSH
46628: LD_INT 0
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: ST_TO_ADDR
// if sci > 1 then
46637: LD_VAR 0 8
46641: PUSH
46642: LD_INT 1
46644: GREATER
46645: IFFALSE 46673
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46647: LD_ADDR_VAR 0 4
46651: PUSH
46652: LD_VAR 0 4
46656: PUSH
46657: LD_VAR 0 8
46661: PUSH
46662: LD_VAR 0 8
46666: PUSH
46667: LD_INT 1
46669: ARRAY
46670: DIFF
46671: DIFF
46672: ST_TO_ADDR
// if tmp and not sci then
46673: LD_VAR 0 4
46677: PUSH
46678: LD_VAR 0 8
46682: NOT
46683: AND
46684: IFFALSE 46753
// begin sort := SortBySkill ( tmp , 4 ) ;
46686: LD_ADDR_VAR 0 9
46690: PUSH
46691: LD_VAR 0 4
46695: PPUSH
46696: LD_INT 4
46698: PPUSH
46699: CALL 106477 0 2
46703: ST_TO_ADDR
// if sort then
46704: LD_VAR 0 9
46708: IFFALSE 46724
// p := sort [ 1 ] ;
46710: LD_ADDR_VAR 0 11
46714: PUSH
46715: LD_VAR 0 9
46719: PUSH
46720: LD_INT 1
46722: ARRAY
46723: ST_TO_ADDR
// if p then
46724: LD_VAR 0 11
46728: IFFALSE 46753
// result := Replace ( result , 4 , p ) ;
46730: LD_ADDR_VAR 0 2
46734: PUSH
46735: LD_VAR 0 2
46739: PPUSH
46740: LD_INT 4
46742: PPUSH
46743: LD_VAR 0 11
46747: PPUSH
46748: CALL_OW 1
46752: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46753: LD_ADDR_VAR 0 4
46757: PUSH
46758: LD_VAR 0 4
46762: PUSH
46763: LD_VAR 0 7
46767: DIFF
46768: ST_TO_ADDR
// if tmp and mech < 6 then
46769: LD_VAR 0 4
46773: PUSH
46774: LD_VAR 0 7
46778: PUSH
46779: LD_INT 6
46781: LESS
46782: AND
46783: IFFALSE 46971
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46785: LD_ADDR_VAR 0 9
46789: PUSH
46790: LD_VAR 0 4
46794: PUSH
46795: LD_VAR 0 8
46799: PUSH
46800: LD_VAR 0 7
46804: UNION
46805: DIFF
46806: PPUSH
46807: LD_INT 3
46809: PPUSH
46810: CALL 106477 0 2
46814: ST_TO_ADDR
// p := [ ] ;
46815: LD_ADDR_VAR 0 11
46819: PUSH
46820: EMPTY
46821: ST_TO_ADDR
// if sort then
46822: LD_VAR 0 9
46826: IFFALSE 46942
// for i = 1 to 6 - mech do
46828: LD_ADDR_VAR 0 3
46832: PUSH
46833: DOUBLE
46834: LD_INT 1
46836: DEC
46837: ST_TO_ADDR
46838: LD_INT 6
46840: PUSH
46841: LD_VAR 0 7
46845: MINUS
46846: PUSH
46847: FOR_TO
46848: IFFALSE 46940
// begin if i = sort then
46850: LD_VAR 0 3
46854: PUSH
46855: LD_VAR 0 9
46859: EQUAL
46860: IFFALSE 46864
// break ;
46862: GO 46940
// if GetClass ( i ) = 3 then
46864: LD_VAR 0 3
46868: PPUSH
46869: CALL_OW 257
46873: PUSH
46874: LD_INT 3
46876: EQUAL
46877: IFFALSE 46881
// continue ;
46879: GO 46847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46881: LD_ADDR_VAR 0 11
46885: PUSH
46886: LD_VAR 0 11
46890: PPUSH
46891: LD_VAR 0 11
46895: PUSH
46896: LD_INT 1
46898: PLUS
46899: PPUSH
46900: LD_VAR 0 9
46904: PUSH
46905: LD_VAR 0 3
46909: ARRAY
46910: PPUSH
46911: CALL_OW 2
46915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46916: LD_ADDR_VAR 0 4
46920: PUSH
46921: LD_VAR 0 4
46925: PUSH
46926: LD_VAR 0 9
46930: PUSH
46931: LD_VAR 0 3
46935: ARRAY
46936: DIFF
46937: ST_TO_ADDR
// end ;
46938: GO 46847
46940: POP
46941: POP
// if p then
46942: LD_VAR 0 11
46946: IFFALSE 46971
// result := Replace ( result , 3 , p ) ;
46948: LD_ADDR_VAR 0 2
46952: PUSH
46953: LD_VAR 0 2
46957: PPUSH
46958: LD_INT 3
46960: PPUSH
46961: LD_VAR 0 11
46965: PPUSH
46966: CALL_OW 1
46970: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46971: LD_ADDR_VAR 0 4
46975: PUSH
46976: LD_VAR 0 4
46980: PUSH
46981: LD_VAR 0 6
46985: DIFF
46986: ST_TO_ADDR
// if tmp and eng < 6 then
46987: LD_VAR 0 4
46991: PUSH
46992: LD_VAR 0 6
46996: PUSH
46997: LD_INT 6
46999: LESS
47000: AND
47001: IFFALSE 47195
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47003: LD_ADDR_VAR 0 9
47007: PUSH
47008: LD_VAR 0 4
47012: PUSH
47013: LD_VAR 0 8
47017: PUSH
47018: LD_VAR 0 7
47022: UNION
47023: PUSH
47024: LD_VAR 0 6
47028: UNION
47029: DIFF
47030: PPUSH
47031: LD_INT 2
47033: PPUSH
47034: CALL 106477 0 2
47038: ST_TO_ADDR
// p := [ ] ;
47039: LD_ADDR_VAR 0 11
47043: PUSH
47044: EMPTY
47045: ST_TO_ADDR
// if sort then
47046: LD_VAR 0 9
47050: IFFALSE 47166
// for i = 1 to 6 - eng do
47052: LD_ADDR_VAR 0 3
47056: PUSH
47057: DOUBLE
47058: LD_INT 1
47060: DEC
47061: ST_TO_ADDR
47062: LD_INT 6
47064: PUSH
47065: LD_VAR 0 6
47069: MINUS
47070: PUSH
47071: FOR_TO
47072: IFFALSE 47164
// begin if i = sort then
47074: LD_VAR 0 3
47078: PUSH
47079: LD_VAR 0 9
47083: EQUAL
47084: IFFALSE 47088
// break ;
47086: GO 47164
// if GetClass ( i ) = 2 then
47088: LD_VAR 0 3
47092: PPUSH
47093: CALL_OW 257
47097: PUSH
47098: LD_INT 2
47100: EQUAL
47101: IFFALSE 47105
// continue ;
47103: GO 47071
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47105: LD_ADDR_VAR 0 11
47109: PUSH
47110: LD_VAR 0 11
47114: PPUSH
47115: LD_VAR 0 11
47119: PUSH
47120: LD_INT 1
47122: PLUS
47123: PPUSH
47124: LD_VAR 0 9
47128: PUSH
47129: LD_VAR 0 3
47133: ARRAY
47134: PPUSH
47135: CALL_OW 2
47139: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47140: LD_ADDR_VAR 0 4
47144: PUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_VAR 0 9
47154: PUSH
47155: LD_VAR 0 3
47159: ARRAY
47160: DIFF
47161: ST_TO_ADDR
// end ;
47162: GO 47071
47164: POP
47165: POP
// if p then
47166: LD_VAR 0 11
47170: IFFALSE 47195
// result := Replace ( result , 2 , p ) ;
47172: LD_ADDR_VAR 0 2
47176: PUSH
47177: LD_VAR 0 2
47181: PPUSH
47182: LD_INT 2
47184: PPUSH
47185: LD_VAR 0 11
47189: PPUSH
47190: CALL_OW 1
47194: ST_TO_ADDR
// end ; exit ;
47195: GO 47919
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47197: LD_EXP 129
47201: PUSH
47202: LD_EXP 128
47206: PUSH
47207: LD_VAR 0 1
47211: ARRAY
47212: ARRAY
47213: NOT
47214: PUSH
47215: LD_EXP 102
47219: PUSH
47220: LD_VAR 0 1
47224: ARRAY
47225: PPUSH
47226: LD_INT 30
47228: PUSH
47229: LD_INT 3
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PPUSH
47236: CALL_OW 72
47240: AND
47241: PUSH
47242: LD_EXP 107
47246: PUSH
47247: LD_VAR 0 1
47251: ARRAY
47252: NOT
47253: AND
47254: IFFALSE 47919
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47256: LD_ADDR_EXP 144
47260: PUSH
47261: LD_EXP 144
47265: PPUSH
47266: LD_VAR 0 1
47270: PPUSH
47271: LD_INT 6
47273: PPUSH
47274: CALL_OW 1
47278: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47279: LD_ADDR_VAR 0 2
47283: PUSH
47284: LD_INT 0
47286: PUSH
47287: LD_INT 0
47289: PUSH
47290: LD_INT 0
47292: PUSH
47293: LD_INT 0
47295: PUSH
47296: EMPTY
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: ST_TO_ADDR
// if sci >= 1 then
47302: LD_VAR 0 8
47306: PUSH
47307: LD_INT 1
47309: GREATEREQUAL
47310: IFFALSE 47332
// tmp := tmp diff sci [ 1 ] ;
47312: LD_ADDR_VAR 0 4
47316: PUSH
47317: LD_VAR 0 4
47321: PUSH
47322: LD_VAR 0 8
47326: PUSH
47327: LD_INT 1
47329: ARRAY
47330: DIFF
47331: ST_TO_ADDR
// if tmp and not sci then
47332: LD_VAR 0 4
47336: PUSH
47337: LD_VAR 0 8
47341: NOT
47342: AND
47343: IFFALSE 47412
// begin sort := SortBySkill ( tmp , 4 ) ;
47345: LD_ADDR_VAR 0 9
47349: PUSH
47350: LD_VAR 0 4
47354: PPUSH
47355: LD_INT 4
47357: PPUSH
47358: CALL 106477 0 2
47362: ST_TO_ADDR
// if sort then
47363: LD_VAR 0 9
47367: IFFALSE 47383
// p := sort [ 1 ] ;
47369: LD_ADDR_VAR 0 11
47373: PUSH
47374: LD_VAR 0 9
47378: PUSH
47379: LD_INT 1
47381: ARRAY
47382: ST_TO_ADDR
// if p then
47383: LD_VAR 0 11
47387: IFFALSE 47412
// result := Replace ( result , 4 , p ) ;
47389: LD_ADDR_VAR 0 2
47393: PUSH
47394: LD_VAR 0 2
47398: PPUSH
47399: LD_INT 4
47401: PPUSH
47402: LD_VAR 0 11
47406: PPUSH
47407: CALL_OW 1
47411: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47412: LD_ADDR_VAR 0 4
47416: PUSH
47417: LD_VAR 0 4
47421: PUSH
47422: LD_VAR 0 7
47426: DIFF
47427: ST_TO_ADDR
// if tmp and mech < 6 then
47428: LD_VAR 0 4
47432: PUSH
47433: LD_VAR 0 7
47437: PUSH
47438: LD_INT 6
47440: LESS
47441: AND
47442: IFFALSE 47624
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47444: LD_ADDR_VAR 0 9
47448: PUSH
47449: LD_VAR 0 4
47453: PUSH
47454: LD_VAR 0 7
47458: DIFF
47459: PPUSH
47460: LD_INT 3
47462: PPUSH
47463: CALL 106477 0 2
47467: ST_TO_ADDR
// p := [ ] ;
47468: LD_ADDR_VAR 0 11
47472: PUSH
47473: EMPTY
47474: ST_TO_ADDR
// if sort then
47475: LD_VAR 0 9
47479: IFFALSE 47595
// for i = 1 to 6 - mech do
47481: LD_ADDR_VAR 0 3
47485: PUSH
47486: DOUBLE
47487: LD_INT 1
47489: DEC
47490: ST_TO_ADDR
47491: LD_INT 6
47493: PUSH
47494: LD_VAR 0 7
47498: MINUS
47499: PUSH
47500: FOR_TO
47501: IFFALSE 47593
// begin if i = sort then
47503: LD_VAR 0 3
47507: PUSH
47508: LD_VAR 0 9
47512: EQUAL
47513: IFFALSE 47517
// break ;
47515: GO 47593
// if GetClass ( i ) = 3 then
47517: LD_VAR 0 3
47521: PPUSH
47522: CALL_OW 257
47526: PUSH
47527: LD_INT 3
47529: EQUAL
47530: IFFALSE 47534
// continue ;
47532: GO 47500
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47534: LD_ADDR_VAR 0 11
47538: PUSH
47539: LD_VAR 0 11
47543: PPUSH
47544: LD_VAR 0 11
47548: PUSH
47549: LD_INT 1
47551: PLUS
47552: PPUSH
47553: LD_VAR 0 9
47557: PUSH
47558: LD_VAR 0 3
47562: ARRAY
47563: PPUSH
47564: CALL_OW 2
47568: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47569: LD_ADDR_VAR 0 4
47573: PUSH
47574: LD_VAR 0 4
47578: PUSH
47579: LD_VAR 0 9
47583: PUSH
47584: LD_VAR 0 3
47588: ARRAY
47589: DIFF
47590: ST_TO_ADDR
// end ;
47591: GO 47500
47593: POP
47594: POP
// if p then
47595: LD_VAR 0 11
47599: IFFALSE 47624
// result := Replace ( result , 3 , p ) ;
47601: LD_ADDR_VAR 0 2
47605: PUSH
47606: LD_VAR 0 2
47610: PPUSH
47611: LD_INT 3
47613: PPUSH
47614: LD_VAR 0 11
47618: PPUSH
47619: CALL_OW 1
47623: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47624: LD_ADDR_VAR 0 4
47628: PUSH
47629: LD_VAR 0 4
47633: PUSH
47634: LD_VAR 0 6
47638: DIFF
47639: ST_TO_ADDR
// if tmp and eng < 4 then
47640: LD_VAR 0 4
47644: PUSH
47645: LD_VAR 0 6
47649: PUSH
47650: LD_INT 4
47652: LESS
47653: AND
47654: IFFALSE 47844
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47656: LD_ADDR_VAR 0 9
47660: PUSH
47661: LD_VAR 0 4
47665: PUSH
47666: LD_VAR 0 7
47670: PUSH
47671: LD_VAR 0 6
47675: UNION
47676: DIFF
47677: PPUSH
47678: LD_INT 2
47680: PPUSH
47681: CALL 106477 0 2
47685: ST_TO_ADDR
// p := [ ] ;
47686: LD_ADDR_VAR 0 11
47690: PUSH
47691: EMPTY
47692: ST_TO_ADDR
// if sort then
47693: LD_VAR 0 9
47697: IFFALSE 47813
// for i = 1 to 4 - eng do
47699: LD_ADDR_VAR 0 3
47703: PUSH
47704: DOUBLE
47705: LD_INT 1
47707: DEC
47708: ST_TO_ADDR
47709: LD_INT 4
47711: PUSH
47712: LD_VAR 0 6
47716: MINUS
47717: PUSH
47718: FOR_TO
47719: IFFALSE 47811
// begin if i = sort then
47721: LD_VAR 0 3
47725: PUSH
47726: LD_VAR 0 9
47730: EQUAL
47731: IFFALSE 47735
// break ;
47733: GO 47811
// if GetClass ( i ) = 2 then
47735: LD_VAR 0 3
47739: PPUSH
47740: CALL_OW 257
47744: PUSH
47745: LD_INT 2
47747: EQUAL
47748: IFFALSE 47752
// continue ;
47750: GO 47718
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47752: LD_ADDR_VAR 0 11
47756: PUSH
47757: LD_VAR 0 11
47761: PPUSH
47762: LD_VAR 0 11
47766: PUSH
47767: LD_INT 1
47769: PLUS
47770: PPUSH
47771: LD_VAR 0 9
47775: PUSH
47776: LD_VAR 0 3
47780: ARRAY
47781: PPUSH
47782: CALL_OW 2
47786: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47787: LD_ADDR_VAR 0 4
47791: PUSH
47792: LD_VAR 0 4
47796: PUSH
47797: LD_VAR 0 9
47801: PUSH
47802: LD_VAR 0 3
47806: ARRAY
47807: DIFF
47808: ST_TO_ADDR
// end ;
47809: GO 47718
47811: POP
47812: POP
// if p then
47813: LD_VAR 0 11
47817: IFFALSE 47842
// result := Replace ( result , 2 , p ) ;
47819: LD_ADDR_VAR 0 2
47823: PUSH
47824: LD_VAR 0 2
47828: PPUSH
47829: LD_INT 2
47831: PPUSH
47832: LD_VAR 0 11
47836: PPUSH
47837: CALL_OW 1
47841: ST_TO_ADDR
// end else
47842: GO 47888
// for i = eng downto 5 do
47844: LD_ADDR_VAR 0 3
47848: PUSH
47849: DOUBLE
47850: LD_VAR 0 6
47854: INC
47855: ST_TO_ADDR
47856: LD_INT 5
47858: PUSH
47859: FOR_DOWNTO
47860: IFFALSE 47886
// tmp := tmp union eng [ i ] ;
47862: LD_ADDR_VAR 0 4
47866: PUSH
47867: LD_VAR 0 4
47871: PUSH
47872: LD_VAR 0 6
47876: PUSH
47877: LD_VAR 0 3
47881: ARRAY
47882: UNION
47883: ST_TO_ADDR
47884: GO 47859
47886: POP
47887: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47888: LD_ADDR_VAR 0 2
47892: PUSH
47893: LD_VAR 0 2
47897: PPUSH
47898: LD_INT 1
47900: PPUSH
47901: LD_VAR 0 4
47905: PUSH
47906: LD_VAR 0 5
47910: DIFF
47911: PPUSH
47912: CALL_OW 1
47916: ST_TO_ADDR
// exit ;
47917: GO 47919
// end ; end ;
47919: LD_VAR 0 2
47923: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47924: LD_INT 0
47926: PPUSH
47927: PPUSH
47928: PPUSH
// if not mc_bases then
47929: LD_EXP 102
47933: NOT
47934: IFFALSE 47938
// exit ;
47936: GO 48080
// for i = 1 to mc_bases do
47938: LD_ADDR_VAR 0 2
47942: PUSH
47943: DOUBLE
47944: LD_INT 1
47946: DEC
47947: ST_TO_ADDR
47948: LD_EXP 102
47952: PUSH
47953: FOR_TO
47954: IFFALSE 48071
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47956: LD_ADDR_VAR 0 3
47960: PUSH
47961: LD_EXP 102
47965: PUSH
47966: LD_VAR 0 2
47970: ARRAY
47971: PPUSH
47972: LD_INT 21
47974: PUSH
47975: LD_INT 3
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: LD_INT 3
47984: PUSH
47985: LD_INT 2
47987: PUSH
47988: LD_INT 30
47990: PUSH
47991: LD_INT 29
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: LD_INT 30
48000: PUSH
48001: LD_INT 30
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: LIST
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 3
48019: PUSH
48020: LD_INT 24
48022: PUSH
48023: LD_INT 1000
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: LIST
48038: PPUSH
48039: CALL_OW 72
48043: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48044: LD_ADDR_EXP 103
48048: PUSH
48049: LD_EXP 103
48053: PPUSH
48054: LD_VAR 0 2
48058: PPUSH
48059: LD_VAR 0 3
48063: PPUSH
48064: CALL_OW 1
48068: ST_TO_ADDR
// end ;
48069: GO 47953
48071: POP
48072: POP
// RaiseSailEvent ( 101 ) ;
48073: LD_INT 101
48075: PPUSH
48076: CALL_OW 427
// end ;
48080: LD_VAR 0 1
48084: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48085: LD_INT 0
48087: PPUSH
48088: PPUSH
48089: PPUSH
48090: PPUSH
48091: PPUSH
48092: PPUSH
48093: PPUSH
// if not mc_bases then
48094: LD_EXP 102
48098: NOT
48099: IFFALSE 48103
// exit ;
48101: GO 48665
// for i = 1 to mc_bases do
48103: LD_ADDR_VAR 0 2
48107: PUSH
48108: DOUBLE
48109: LD_INT 1
48111: DEC
48112: ST_TO_ADDR
48113: LD_EXP 102
48117: PUSH
48118: FOR_TO
48119: IFFALSE 48656
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48121: LD_ADDR_VAR 0 5
48125: PUSH
48126: LD_EXP 102
48130: PUSH
48131: LD_VAR 0 2
48135: ARRAY
48136: PUSH
48137: LD_EXP 131
48141: PUSH
48142: LD_VAR 0 2
48146: ARRAY
48147: UNION
48148: PPUSH
48149: LD_INT 21
48151: PUSH
48152: LD_INT 1
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: PUSH
48159: LD_INT 1
48161: PUSH
48162: LD_INT 3
48164: PUSH
48165: LD_INT 54
48167: PUSH
48168: EMPTY
48169: LIST
48170: PUSH
48171: EMPTY
48172: LIST
48173: LIST
48174: PUSH
48175: LD_INT 3
48177: PUSH
48178: LD_INT 24
48180: PUSH
48181: LD_INT 1000
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: PUSH
48192: EMPTY
48193: LIST
48194: LIST
48195: LIST
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PPUSH
48201: CALL_OW 72
48205: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48206: LD_ADDR_VAR 0 6
48210: PUSH
48211: LD_EXP 102
48215: PUSH
48216: LD_VAR 0 2
48220: ARRAY
48221: PPUSH
48222: LD_INT 21
48224: PUSH
48225: LD_INT 1
48227: PUSH
48228: EMPTY
48229: LIST
48230: LIST
48231: PUSH
48232: LD_INT 1
48234: PUSH
48235: LD_INT 3
48237: PUSH
48238: LD_INT 54
48240: PUSH
48241: EMPTY
48242: LIST
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 3
48250: PUSH
48251: LD_INT 24
48253: PUSH
48254: LD_INT 250
48256: PUSH
48257: EMPTY
48258: LIST
48259: LIST
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: LIST
48269: PUSH
48270: EMPTY
48271: LIST
48272: LIST
48273: PPUSH
48274: CALL_OW 72
48278: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48279: LD_ADDR_VAR 0 7
48283: PUSH
48284: LD_VAR 0 5
48288: PUSH
48289: LD_VAR 0 6
48293: DIFF
48294: ST_TO_ADDR
// if not need_heal_1 then
48295: LD_VAR 0 6
48299: NOT
48300: IFFALSE 48333
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48302: LD_ADDR_EXP 105
48306: PUSH
48307: LD_EXP 105
48311: PPUSH
48312: LD_VAR 0 2
48316: PUSH
48317: LD_INT 1
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: PPUSH
48324: EMPTY
48325: PPUSH
48326: CALL 75244 0 3
48330: ST_TO_ADDR
48331: GO 48403
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48333: LD_ADDR_EXP 105
48337: PUSH
48338: LD_EXP 105
48342: PPUSH
48343: LD_VAR 0 2
48347: PUSH
48348: LD_INT 1
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PPUSH
48355: LD_EXP 105
48359: PUSH
48360: LD_VAR 0 2
48364: ARRAY
48365: PUSH
48366: LD_INT 1
48368: ARRAY
48369: PPUSH
48370: LD_INT 3
48372: PUSH
48373: LD_INT 24
48375: PUSH
48376: LD_INT 1000
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: PPUSH
48387: CALL_OW 72
48391: PUSH
48392: LD_VAR 0 6
48396: UNION
48397: PPUSH
48398: CALL 75244 0 3
48402: ST_TO_ADDR
// if not need_heal_2 then
48403: LD_VAR 0 7
48407: NOT
48408: IFFALSE 48441
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48410: LD_ADDR_EXP 105
48414: PUSH
48415: LD_EXP 105
48419: PPUSH
48420: LD_VAR 0 2
48424: PUSH
48425: LD_INT 2
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PPUSH
48432: EMPTY
48433: PPUSH
48434: CALL 75244 0 3
48438: ST_TO_ADDR
48439: GO 48473
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48441: LD_ADDR_EXP 105
48445: PUSH
48446: LD_EXP 105
48450: PPUSH
48451: LD_VAR 0 2
48455: PUSH
48456: LD_INT 2
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PPUSH
48463: LD_VAR 0 7
48467: PPUSH
48468: CALL 75244 0 3
48472: ST_TO_ADDR
// if need_heal_2 then
48473: LD_VAR 0 7
48477: IFFALSE 48638
// for j in need_heal_2 do
48479: LD_ADDR_VAR 0 3
48483: PUSH
48484: LD_VAR 0 7
48488: PUSH
48489: FOR_IN
48490: IFFALSE 48636
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48492: LD_ADDR_VAR 0 5
48496: PUSH
48497: LD_EXP 102
48501: PUSH
48502: LD_VAR 0 2
48506: ARRAY
48507: PPUSH
48508: LD_INT 2
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 6
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 30
48523: PUSH
48524: LD_INT 7
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 30
48533: PUSH
48534: LD_INT 8
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 30
48543: PUSH
48544: LD_INT 0
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: LD_INT 30
48553: PUSH
48554: LD_INT 1
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PPUSH
48569: CALL_OW 72
48573: ST_TO_ADDR
// if tmp then
48574: LD_VAR 0 5
48578: IFFALSE 48634
// begin k := NearestUnitToUnit ( tmp , j ) ;
48580: LD_ADDR_VAR 0 4
48584: PUSH
48585: LD_VAR 0 5
48589: PPUSH
48590: LD_VAR 0 3
48594: PPUSH
48595: CALL_OW 74
48599: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48600: LD_VAR 0 3
48604: PPUSH
48605: LD_VAR 0 4
48609: PPUSH
48610: CALL_OW 296
48614: PUSH
48615: LD_INT 5
48617: GREATER
48618: IFFALSE 48634
// ComMoveToNearbyEntrance ( j , k ) ;
48620: LD_VAR 0 3
48624: PPUSH
48625: LD_VAR 0 4
48629: PPUSH
48630: CALL 108850 0 2
// end ; end ;
48634: GO 48489
48636: POP
48637: POP
// if not need_heal_1 and not need_heal_2 then
48638: LD_VAR 0 6
48642: NOT
48643: PUSH
48644: LD_VAR 0 7
48648: NOT
48649: AND
48650: IFFALSE 48654
// continue ;
48652: GO 48118
// end ;
48654: GO 48118
48656: POP
48657: POP
// RaiseSailEvent ( 102 ) ;
48658: LD_INT 102
48660: PPUSH
48661: CALL_OW 427
// end ;
48665: LD_VAR 0 1
48669: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48670: LD_INT 0
48672: PPUSH
48673: PPUSH
48674: PPUSH
48675: PPUSH
48676: PPUSH
48677: PPUSH
48678: PPUSH
48679: PPUSH
// if not mc_bases then
48680: LD_EXP 102
48684: NOT
48685: IFFALSE 48689
// exit ;
48687: GO 49600
// for i = 1 to mc_bases do
48689: LD_ADDR_VAR 0 2
48693: PUSH
48694: DOUBLE
48695: LD_INT 1
48697: DEC
48698: ST_TO_ADDR
48699: LD_EXP 102
48703: PUSH
48704: FOR_TO
48705: IFFALSE 49598
// begin if not mc_building_need_repair [ i ] then
48707: LD_EXP 103
48711: PUSH
48712: LD_VAR 0 2
48716: ARRAY
48717: NOT
48718: IFFALSE 48903
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48720: LD_ADDR_VAR 0 6
48724: PUSH
48725: LD_EXP 121
48729: PUSH
48730: LD_VAR 0 2
48734: ARRAY
48735: PPUSH
48736: LD_INT 3
48738: PUSH
48739: LD_INT 24
48741: PUSH
48742: LD_INT 1000
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: PUSH
48749: EMPTY
48750: LIST
48751: LIST
48752: PUSH
48753: LD_INT 2
48755: PUSH
48756: LD_INT 34
48758: PUSH
48759: LD_INT 13
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 34
48768: PUSH
48769: LD_INT 52
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: PUSH
48776: LD_INT 34
48778: PUSH
48779: LD_INT 88
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: PUSH
48792: EMPTY
48793: LIST
48794: LIST
48795: PPUSH
48796: CALL_OW 72
48800: ST_TO_ADDR
// if cranes then
48801: LD_VAR 0 6
48805: IFFALSE 48867
// for j in cranes do
48807: LD_ADDR_VAR 0 3
48811: PUSH
48812: LD_VAR 0 6
48816: PUSH
48817: FOR_IN
48818: IFFALSE 48865
// if not IsInArea ( j , mc_parking [ i ] ) then
48820: LD_VAR 0 3
48824: PPUSH
48825: LD_EXP 126
48829: PUSH
48830: LD_VAR 0 2
48834: ARRAY
48835: PPUSH
48836: CALL_OW 308
48840: NOT
48841: IFFALSE 48863
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48843: LD_VAR 0 3
48847: PPUSH
48848: LD_EXP 126
48852: PUSH
48853: LD_VAR 0 2
48857: ARRAY
48858: PPUSH
48859: CALL_OW 113
48863: GO 48817
48865: POP
48866: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48867: LD_ADDR_EXP 104
48871: PUSH
48872: LD_EXP 104
48876: PPUSH
48877: LD_VAR 0 2
48881: PPUSH
48882: EMPTY
48883: PPUSH
48884: CALL_OW 1
48888: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48889: LD_VAR 0 2
48893: PPUSH
48894: LD_INT 101
48896: PPUSH
48897: CALL 43743 0 2
// continue ;
48901: GO 48704
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48903: LD_ADDR_EXP 108
48907: PUSH
48908: LD_EXP 108
48912: PPUSH
48913: LD_VAR 0 2
48917: PPUSH
48918: EMPTY
48919: PPUSH
48920: CALL_OW 1
48924: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48925: LD_VAR 0 2
48929: PPUSH
48930: LD_INT 103
48932: PPUSH
48933: CALL 43743 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48937: LD_ADDR_VAR 0 5
48941: PUSH
48942: LD_EXP 102
48946: PUSH
48947: LD_VAR 0 2
48951: ARRAY
48952: PUSH
48953: LD_EXP 131
48957: PUSH
48958: LD_VAR 0 2
48962: ARRAY
48963: UNION
48964: PPUSH
48965: LD_INT 2
48967: PUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 2
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 25
48980: PUSH
48981: LD_INT 16
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: LIST
48992: PUSH
48993: EMPTY
48994: LIST
48995: PPUSH
48996: CALL_OW 72
49000: ST_TO_ADDR
// if mc_need_heal [ i ] then
49001: LD_EXP 105
49005: PUSH
49006: LD_VAR 0 2
49010: ARRAY
49011: IFFALSE 49055
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49013: LD_ADDR_VAR 0 5
49017: PUSH
49018: LD_VAR 0 5
49022: PUSH
49023: LD_EXP 105
49027: PUSH
49028: LD_VAR 0 2
49032: ARRAY
49033: PUSH
49034: LD_INT 1
49036: ARRAY
49037: PUSH
49038: LD_EXP 105
49042: PUSH
49043: LD_VAR 0 2
49047: ARRAY
49048: PUSH
49049: LD_INT 2
49051: ARRAY
49052: UNION
49053: DIFF
49054: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49055: LD_ADDR_VAR 0 6
49059: PUSH
49060: LD_EXP 121
49064: PUSH
49065: LD_VAR 0 2
49069: ARRAY
49070: PPUSH
49071: LD_INT 2
49073: PUSH
49074: LD_INT 34
49076: PUSH
49077: LD_INT 13
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PUSH
49084: LD_INT 34
49086: PUSH
49087: LD_INT 52
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 34
49096: PUSH
49097: LD_INT 88
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: PPUSH
49110: CALL_OW 72
49114: ST_TO_ADDR
// if cranes then
49115: LD_VAR 0 6
49119: IFFALSE 49287
// begin for j in cranes do
49121: LD_ADDR_VAR 0 3
49125: PUSH
49126: LD_VAR 0 6
49130: PUSH
49131: FOR_IN
49132: IFFALSE 49285
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49134: LD_VAR 0 3
49138: PPUSH
49139: CALL_OW 256
49143: PUSH
49144: LD_INT 1000
49146: EQUAL
49147: PUSH
49148: LD_VAR 0 3
49152: PPUSH
49153: CALL_OW 314
49157: NOT
49158: AND
49159: IFFALSE 49225
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49161: LD_ADDR_VAR 0 8
49165: PUSH
49166: LD_EXP 103
49170: PUSH
49171: LD_VAR 0 2
49175: ARRAY
49176: PPUSH
49177: LD_VAR 0 3
49181: PPUSH
49182: CALL_OW 74
49186: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49187: LD_VAR 0 8
49191: PPUSH
49192: LD_INT 16
49194: PPUSH
49195: CALL 78209 0 2
49199: PUSH
49200: LD_INT 4
49202: ARRAY
49203: PUSH
49204: LD_INT 10
49206: LESS
49207: IFFALSE 49223
// ComRepairBuilding ( j , to_repair ) ;
49209: LD_VAR 0 3
49213: PPUSH
49214: LD_VAR 0 8
49218: PPUSH
49219: CALL_OW 130
// end else
49223: GO 49283
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49225: LD_VAR 0 3
49229: PPUSH
49230: CALL_OW 256
49234: PUSH
49235: LD_INT 500
49237: LESS
49238: PUSH
49239: LD_VAR 0 3
49243: PPUSH
49244: LD_EXP 126
49248: PUSH
49249: LD_VAR 0 2
49253: ARRAY
49254: PPUSH
49255: CALL_OW 308
49259: NOT
49260: AND
49261: IFFALSE 49283
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49263: LD_VAR 0 3
49267: PPUSH
49268: LD_EXP 126
49272: PUSH
49273: LD_VAR 0 2
49277: ARRAY
49278: PPUSH
49279: CALL_OW 113
// end ;
49283: GO 49131
49285: POP
49286: POP
// end ; if tmp > 3 then
49287: LD_VAR 0 5
49291: PUSH
49292: LD_INT 3
49294: GREATER
49295: IFFALSE 49315
// tmp := ShrinkArray ( tmp , 4 ) ;
49297: LD_ADDR_VAR 0 5
49301: PUSH
49302: LD_VAR 0 5
49306: PPUSH
49307: LD_INT 4
49309: PPUSH
49310: CALL 108288 0 2
49314: ST_TO_ADDR
// if not tmp then
49315: LD_VAR 0 5
49319: NOT
49320: IFFALSE 49324
// continue ;
49322: GO 48704
// for j in tmp do
49324: LD_ADDR_VAR 0 3
49328: PUSH
49329: LD_VAR 0 5
49333: PUSH
49334: FOR_IN
49335: IFFALSE 49594
// begin if IsInUnit ( j ) then
49337: LD_VAR 0 3
49341: PPUSH
49342: CALL_OW 310
49346: IFFALSE 49357
// ComExitBuilding ( j ) ;
49348: LD_VAR 0 3
49352: PPUSH
49353: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49357: LD_VAR 0 3
49361: PUSH
49362: LD_EXP 104
49366: PUSH
49367: LD_VAR 0 2
49371: ARRAY
49372: IN
49373: NOT
49374: IFFALSE 49432
// begin SetTag ( j , 101 ) ;
49376: LD_VAR 0 3
49380: PPUSH
49381: LD_INT 101
49383: PPUSH
49384: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49388: LD_ADDR_EXP 104
49392: PUSH
49393: LD_EXP 104
49397: PPUSH
49398: LD_VAR 0 2
49402: PUSH
49403: LD_EXP 104
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: PUSH
49414: LD_INT 1
49416: PLUS
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PPUSH
49422: LD_VAR 0 3
49426: PPUSH
49427: CALL 75244 0 3
49431: ST_TO_ADDR
// end ; wait ( 1 ) ;
49432: LD_INT 1
49434: PPUSH
49435: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49439: LD_ADDR_VAR 0 7
49443: PUSH
49444: LD_EXP 103
49448: PUSH
49449: LD_VAR 0 2
49453: ARRAY
49454: ST_TO_ADDR
// if mc_scan [ i ] then
49455: LD_EXP 125
49459: PUSH
49460: LD_VAR 0 2
49464: ARRAY
49465: IFFALSE 49527
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49467: LD_ADDR_VAR 0 7
49471: PUSH
49472: LD_EXP 103
49476: PUSH
49477: LD_VAR 0 2
49481: ARRAY
49482: PPUSH
49483: LD_INT 3
49485: PUSH
49486: LD_INT 30
49488: PUSH
49489: LD_INT 32
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 30
49498: PUSH
49499: LD_INT 33
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: LD_INT 30
49508: PUSH
49509: LD_INT 31
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: PPUSH
49522: CALL_OW 72
49526: ST_TO_ADDR
// if not to_repair_tmp then
49527: LD_VAR 0 7
49531: NOT
49532: IFFALSE 49536
// continue ;
49534: GO 49334
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49536: LD_ADDR_VAR 0 8
49540: PUSH
49541: LD_VAR 0 7
49545: PPUSH
49546: LD_VAR 0 3
49550: PPUSH
49551: CALL_OW 74
49555: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49556: LD_VAR 0 8
49560: PPUSH
49561: LD_INT 16
49563: PPUSH
49564: CALL 78209 0 2
49568: PUSH
49569: LD_INT 4
49571: ARRAY
49572: PUSH
49573: LD_INT 14
49575: LESS
49576: IFFALSE 49592
// ComRepairBuilding ( j , to_repair ) ;
49578: LD_VAR 0 3
49582: PPUSH
49583: LD_VAR 0 8
49587: PPUSH
49588: CALL_OW 130
// end ;
49592: GO 49334
49594: POP
49595: POP
// end ;
49596: GO 48704
49598: POP
49599: POP
// end ;
49600: LD_VAR 0 1
49604: RET
// export function MC_Heal ; var i , j , tmp ; begin
49605: LD_INT 0
49607: PPUSH
49608: PPUSH
49609: PPUSH
49610: PPUSH
// if not mc_bases then
49611: LD_EXP 102
49615: NOT
49616: IFFALSE 49620
// exit ;
49618: GO 50022
// for i = 1 to mc_bases do
49620: LD_ADDR_VAR 0 2
49624: PUSH
49625: DOUBLE
49626: LD_INT 1
49628: DEC
49629: ST_TO_ADDR
49630: LD_EXP 102
49634: PUSH
49635: FOR_TO
49636: IFFALSE 50020
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49638: LD_EXP 105
49642: PUSH
49643: LD_VAR 0 2
49647: ARRAY
49648: PUSH
49649: LD_INT 1
49651: ARRAY
49652: NOT
49653: PUSH
49654: LD_EXP 105
49658: PUSH
49659: LD_VAR 0 2
49663: ARRAY
49664: PUSH
49665: LD_INT 2
49667: ARRAY
49668: NOT
49669: AND
49670: IFFALSE 49708
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49672: LD_ADDR_EXP 106
49676: PUSH
49677: LD_EXP 106
49681: PPUSH
49682: LD_VAR 0 2
49686: PPUSH
49687: EMPTY
49688: PPUSH
49689: CALL_OW 1
49693: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49694: LD_VAR 0 2
49698: PPUSH
49699: LD_INT 102
49701: PPUSH
49702: CALL 43743 0 2
// continue ;
49706: GO 49635
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49708: LD_ADDR_VAR 0 4
49712: PUSH
49713: LD_EXP 102
49717: PUSH
49718: LD_VAR 0 2
49722: ARRAY
49723: PPUSH
49724: LD_INT 25
49726: PUSH
49727: LD_INT 4
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PPUSH
49734: CALL_OW 72
49738: ST_TO_ADDR
// if not tmp then
49739: LD_VAR 0 4
49743: NOT
49744: IFFALSE 49748
// continue ;
49746: GO 49635
// if mc_taming [ i ] then
49748: LD_EXP 133
49752: PUSH
49753: LD_VAR 0 2
49757: ARRAY
49758: IFFALSE 49782
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49760: LD_ADDR_EXP 133
49764: PUSH
49765: LD_EXP 133
49769: PPUSH
49770: LD_VAR 0 2
49774: PPUSH
49775: EMPTY
49776: PPUSH
49777: CALL_OW 1
49781: ST_TO_ADDR
// for j in tmp do
49782: LD_ADDR_VAR 0 3
49786: PUSH
49787: LD_VAR 0 4
49791: PUSH
49792: FOR_IN
49793: IFFALSE 50016
// begin if IsInUnit ( j ) then
49795: LD_VAR 0 3
49799: PPUSH
49800: CALL_OW 310
49804: IFFALSE 49815
// ComExitBuilding ( j ) ;
49806: LD_VAR 0 3
49810: PPUSH
49811: CALL_OW 122
// if not j in mc_healers [ i ] then
49815: LD_VAR 0 3
49819: PUSH
49820: LD_EXP 106
49824: PUSH
49825: LD_VAR 0 2
49829: ARRAY
49830: IN
49831: NOT
49832: IFFALSE 49878
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49834: LD_ADDR_EXP 106
49838: PUSH
49839: LD_EXP 106
49843: PPUSH
49844: LD_VAR 0 2
49848: PUSH
49849: LD_EXP 106
49853: PUSH
49854: LD_VAR 0 2
49858: ARRAY
49859: PUSH
49860: LD_INT 1
49862: PLUS
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PPUSH
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL 75244 0 3
49877: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49878: LD_VAR 0 3
49882: PPUSH
49883: CALL_OW 110
49887: PUSH
49888: LD_INT 102
49890: NONEQUAL
49891: IFFALSE 49905
// SetTag ( j , 102 ) ;
49893: LD_VAR 0 3
49897: PPUSH
49898: LD_INT 102
49900: PPUSH
49901: CALL_OW 109
// Wait ( 3 ) ;
49905: LD_INT 3
49907: PPUSH
49908: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49912: LD_EXP 105
49916: PUSH
49917: LD_VAR 0 2
49921: ARRAY
49922: PUSH
49923: LD_INT 1
49925: ARRAY
49926: IFFALSE 49958
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49928: LD_VAR 0 3
49932: PPUSH
49933: LD_EXP 105
49937: PUSH
49938: LD_VAR 0 2
49942: ARRAY
49943: PUSH
49944: LD_INT 1
49946: ARRAY
49947: PUSH
49948: LD_INT 1
49950: ARRAY
49951: PPUSH
49952: CALL_OW 128
49956: GO 50014
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49958: LD_VAR 0 3
49962: PPUSH
49963: CALL_OW 314
49967: NOT
49968: PUSH
49969: LD_EXP 105
49973: PUSH
49974: LD_VAR 0 2
49978: ARRAY
49979: PUSH
49980: LD_INT 2
49982: ARRAY
49983: AND
49984: IFFALSE 50014
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49986: LD_VAR 0 3
49990: PPUSH
49991: LD_EXP 105
49995: PUSH
49996: LD_VAR 0 2
50000: ARRAY
50001: PUSH
50002: LD_INT 2
50004: ARRAY
50005: PUSH
50006: LD_INT 1
50008: ARRAY
50009: PPUSH
50010: CALL_OW 128
// end ;
50014: GO 49792
50016: POP
50017: POP
// end ;
50018: GO 49635
50020: POP
50021: POP
// end ;
50022: LD_VAR 0 1
50026: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50027: LD_INT 0
50029: PPUSH
50030: PPUSH
50031: PPUSH
50032: PPUSH
50033: PPUSH
50034: PPUSH
// if not mc_bases then
50035: LD_EXP 102
50039: NOT
50040: IFFALSE 50044
// exit ;
50042: GO 51207
// for i = 1 to mc_bases do
50044: LD_ADDR_VAR 0 2
50048: PUSH
50049: DOUBLE
50050: LD_INT 1
50052: DEC
50053: ST_TO_ADDR
50054: LD_EXP 102
50058: PUSH
50059: FOR_TO
50060: IFFALSE 51205
// begin if mc_scan [ i ] then
50062: LD_EXP 125
50066: PUSH
50067: LD_VAR 0 2
50071: ARRAY
50072: IFFALSE 50076
// continue ;
50074: GO 50059
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50076: LD_EXP 107
50080: PUSH
50081: LD_VAR 0 2
50085: ARRAY
50086: NOT
50087: PUSH
50088: LD_EXP 109
50092: PUSH
50093: LD_VAR 0 2
50097: ARRAY
50098: NOT
50099: AND
50100: PUSH
50101: LD_EXP 108
50105: PUSH
50106: LD_VAR 0 2
50110: ARRAY
50111: AND
50112: IFFALSE 50150
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50114: LD_ADDR_EXP 108
50118: PUSH
50119: LD_EXP 108
50123: PPUSH
50124: LD_VAR 0 2
50128: PPUSH
50129: EMPTY
50130: PPUSH
50131: CALL_OW 1
50135: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50136: LD_VAR 0 2
50140: PPUSH
50141: LD_INT 103
50143: PPUSH
50144: CALL 43743 0 2
// continue ;
50148: GO 50059
// end ; if mc_construct_list [ i ] then
50150: LD_EXP 109
50154: PUSH
50155: LD_VAR 0 2
50159: ARRAY
50160: IFFALSE 50380
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50162: LD_ADDR_VAR 0 5
50166: PUSH
50167: LD_EXP 102
50171: PUSH
50172: LD_VAR 0 2
50176: ARRAY
50177: PPUSH
50178: LD_INT 25
50180: PUSH
50181: LD_INT 2
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PPUSH
50188: CALL_OW 72
50192: PUSH
50193: LD_EXP 104
50197: PUSH
50198: LD_VAR 0 2
50202: ARRAY
50203: DIFF
50204: ST_TO_ADDR
// if not tmp then
50205: LD_VAR 0 5
50209: NOT
50210: IFFALSE 50214
// continue ;
50212: GO 50059
// for j in tmp do
50214: LD_ADDR_VAR 0 3
50218: PUSH
50219: LD_VAR 0 5
50223: PUSH
50224: FOR_IN
50225: IFFALSE 50376
// begin if not mc_builders [ i ] then
50227: LD_EXP 108
50231: PUSH
50232: LD_VAR 0 2
50236: ARRAY
50237: NOT
50238: IFFALSE 50296
// begin SetTag ( j , 103 ) ;
50240: LD_VAR 0 3
50244: PPUSH
50245: LD_INT 103
50247: PPUSH
50248: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50252: LD_ADDR_EXP 108
50256: PUSH
50257: LD_EXP 108
50261: PPUSH
50262: LD_VAR 0 2
50266: PUSH
50267: LD_EXP 108
50271: PUSH
50272: LD_VAR 0 2
50276: ARRAY
50277: PUSH
50278: LD_INT 1
50280: PLUS
50281: PUSH
50282: EMPTY
50283: LIST
50284: LIST
50285: PPUSH
50286: LD_VAR 0 3
50290: PPUSH
50291: CALL 75244 0 3
50295: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50296: LD_VAR 0 3
50300: PPUSH
50301: CALL_OW 310
50305: IFFALSE 50316
// ComExitBuilding ( j ) ;
50307: LD_VAR 0 3
50311: PPUSH
50312: CALL_OW 122
// wait ( 3 ) ;
50316: LD_INT 3
50318: PPUSH
50319: CALL_OW 67
// if not mc_construct_list [ i ] then
50323: LD_EXP 109
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: NOT
50334: IFFALSE 50338
// break ;
50336: GO 50376
// if not HasTask ( j ) then
50338: LD_VAR 0 3
50342: PPUSH
50343: CALL_OW 314
50347: NOT
50348: IFFALSE 50374
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50350: LD_VAR 0 3
50354: PPUSH
50355: LD_EXP 109
50359: PUSH
50360: LD_VAR 0 2
50364: ARRAY
50365: PUSH
50366: LD_INT 1
50368: ARRAY
50369: PPUSH
50370: CALL 78482 0 2
// end ;
50374: GO 50224
50376: POP
50377: POP
// end else
50378: GO 51203
// if mc_build_list [ i ] then
50380: LD_EXP 107
50384: PUSH
50385: LD_VAR 0 2
50389: ARRAY
50390: IFFALSE 51203
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50392: LD_EXP 107
50396: PUSH
50397: LD_VAR 0 2
50401: ARRAY
50402: PUSH
50403: LD_INT 1
50405: ARRAY
50406: PUSH
50407: LD_INT 1
50409: ARRAY
50410: PPUSH
50411: CALL 78306 0 1
50415: PUSH
50416: LD_EXP 102
50420: PUSH
50421: LD_VAR 0 2
50425: ARRAY
50426: PPUSH
50427: LD_INT 2
50429: PUSH
50430: LD_INT 30
50432: PUSH
50433: LD_INT 2
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: PUSH
50440: LD_INT 30
50442: PUSH
50443: LD_INT 3
50445: PUSH
50446: EMPTY
50447: LIST
50448: LIST
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: LIST
50454: PPUSH
50455: CALL_OW 72
50459: NOT
50460: AND
50461: IFFALSE 50566
// begin for j = 1 to mc_build_list [ i ] do
50463: LD_ADDR_VAR 0 3
50467: PUSH
50468: DOUBLE
50469: LD_INT 1
50471: DEC
50472: ST_TO_ADDR
50473: LD_EXP 107
50477: PUSH
50478: LD_VAR 0 2
50482: ARRAY
50483: PUSH
50484: FOR_TO
50485: IFFALSE 50564
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50487: LD_EXP 107
50491: PUSH
50492: LD_VAR 0 2
50496: ARRAY
50497: PUSH
50498: LD_VAR 0 3
50502: ARRAY
50503: PUSH
50504: LD_INT 1
50506: ARRAY
50507: PUSH
50508: LD_INT 2
50510: EQUAL
50511: IFFALSE 50562
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50513: LD_ADDR_EXP 107
50517: PUSH
50518: LD_EXP 107
50522: PPUSH
50523: LD_VAR 0 2
50527: PPUSH
50528: LD_EXP 107
50532: PUSH
50533: LD_VAR 0 2
50537: ARRAY
50538: PPUSH
50539: LD_VAR 0 3
50543: PPUSH
50544: LD_INT 1
50546: PPUSH
50547: LD_INT 0
50549: PPUSH
50550: CALL 74662 0 4
50554: PPUSH
50555: CALL_OW 1
50559: ST_TO_ADDR
// break ;
50560: GO 50564
// end ;
50562: GO 50484
50564: POP
50565: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50566: LD_ADDR_VAR 0 6
50570: PUSH
50571: LD_EXP 102
50575: PUSH
50576: LD_VAR 0 2
50580: ARRAY
50581: PPUSH
50582: LD_INT 2
50584: PUSH
50585: LD_INT 30
50587: PUSH
50588: LD_INT 0
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 30
50597: PUSH
50598: LD_INT 1
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: EMPTY
50606: LIST
50607: LIST
50608: LIST
50609: PPUSH
50610: CALL_OW 72
50614: ST_TO_ADDR
// for k := 1 to depot do
50615: LD_ADDR_VAR 0 4
50619: PUSH
50620: DOUBLE
50621: LD_INT 1
50623: DEC
50624: ST_TO_ADDR
50625: LD_VAR 0 6
50629: PUSH
50630: FOR_TO
50631: IFFALSE 51201
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50633: LD_EXP 107
50637: PUSH
50638: LD_VAR 0 2
50642: ARRAY
50643: PUSH
50644: LD_INT 1
50646: ARRAY
50647: PUSH
50648: LD_INT 1
50650: ARRAY
50651: PUSH
50652: LD_INT 0
50654: EQUAL
50655: PUSH
50656: LD_VAR 0 6
50660: PUSH
50661: LD_VAR 0 4
50665: ARRAY
50666: PPUSH
50667: LD_EXP 107
50671: PUSH
50672: LD_VAR 0 2
50676: ARRAY
50677: PUSH
50678: LD_INT 1
50680: ARRAY
50681: PUSH
50682: LD_INT 1
50684: ARRAY
50685: PPUSH
50686: LD_EXP 107
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: PUSH
50697: LD_INT 1
50699: ARRAY
50700: PUSH
50701: LD_INT 2
50703: ARRAY
50704: PPUSH
50705: LD_EXP 107
50709: PUSH
50710: LD_VAR 0 2
50714: ARRAY
50715: PUSH
50716: LD_INT 1
50718: ARRAY
50719: PUSH
50720: LD_INT 3
50722: ARRAY
50723: PPUSH
50724: LD_EXP 107
50728: PUSH
50729: LD_VAR 0 2
50733: ARRAY
50734: PUSH
50735: LD_INT 1
50737: ARRAY
50738: PUSH
50739: LD_INT 4
50741: ARRAY
50742: PPUSH
50743: CALL 83718 0 5
50747: OR
50748: IFFALSE 51029
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50750: LD_ADDR_VAR 0 5
50754: PUSH
50755: LD_EXP 102
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: PPUSH
50766: LD_INT 25
50768: PUSH
50769: LD_INT 2
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: PPUSH
50776: CALL_OW 72
50780: PUSH
50781: LD_EXP 104
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: DIFF
50792: ST_TO_ADDR
// if not tmp then
50793: LD_VAR 0 5
50797: NOT
50798: IFFALSE 50802
// continue ;
50800: GO 50630
// for j in tmp do
50802: LD_ADDR_VAR 0 3
50806: PUSH
50807: LD_VAR 0 5
50811: PUSH
50812: FOR_IN
50813: IFFALSE 51025
// begin if not mc_builders [ i ] then
50815: LD_EXP 108
50819: PUSH
50820: LD_VAR 0 2
50824: ARRAY
50825: NOT
50826: IFFALSE 50884
// begin SetTag ( j , 103 ) ;
50828: LD_VAR 0 3
50832: PPUSH
50833: LD_INT 103
50835: PPUSH
50836: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50840: LD_ADDR_EXP 108
50844: PUSH
50845: LD_EXP 108
50849: PPUSH
50850: LD_VAR 0 2
50854: PUSH
50855: LD_EXP 108
50859: PUSH
50860: LD_VAR 0 2
50864: ARRAY
50865: PUSH
50866: LD_INT 1
50868: PLUS
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PPUSH
50874: LD_VAR 0 3
50878: PPUSH
50879: CALL 75244 0 3
50883: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50884: LD_VAR 0 3
50888: PPUSH
50889: CALL_OW 310
50893: IFFALSE 50904
// ComExitBuilding ( j ) ;
50895: LD_VAR 0 3
50899: PPUSH
50900: CALL_OW 122
// wait ( 3 ) ;
50904: LD_INT 3
50906: PPUSH
50907: CALL_OW 67
// if not mc_build_list [ i ] then
50911: LD_EXP 107
50915: PUSH
50916: LD_VAR 0 2
50920: ARRAY
50921: NOT
50922: IFFALSE 50926
// break ;
50924: GO 51025
// if not HasTask ( j ) then
50926: LD_VAR 0 3
50930: PPUSH
50931: CALL_OW 314
50935: NOT
50936: IFFALSE 51023
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50938: LD_VAR 0 3
50942: PPUSH
50943: LD_EXP 107
50947: PUSH
50948: LD_VAR 0 2
50952: ARRAY
50953: PUSH
50954: LD_INT 1
50956: ARRAY
50957: PUSH
50958: LD_INT 1
50960: ARRAY
50961: PPUSH
50962: LD_EXP 107
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: PUSH
50973: LD_INT 1
50975: ARRAY
50976: PUSH
50977: LD_INT 2
50979: ARRAY
50980: PPUSH
50981: LD_EXP 107
50985: PUSH
50986: LD_VAR 0 2
50990: ARRAY
50991: PUSH
50992: LD_INT 1
50994: ARRAY
50995: PUSH
50996: LD_INT 3
50998: ARRAY
50999: PPUSH
51000: LD_EXP 107
51004: PUSH
51005: LD_VAR 0 2
51009: ARRAY
51010: PUSH
51011: LD_INT 1
51013: ARRAY
51014: PUSH
51015: LD_INT 4
51017: ARRAY
51018: PPUSH
51019: CALL_OW 145
// end ;
51023: GO 50812
51025: POP
51026: POP
// end else
51027: GO 51199
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51029: LD_EXP 102
51033: PUSH
51034: LD_VAR 0 2
51038: ARRAY
51039: PPUSH
51040: LD_EXP 107
51044: PUSH
51045: LD_VAR 0 2
51049: ARRAY
51050: PUSH
51051: LD_INT 1
51053: ARRAY
51054: PUSH
51055: LD_INT 1
51057: ARRAY
51058: PPUSH
51059: LD_EXP 107
51063: PUSH
51064: LD_VAR 0 2
51068: ARRAY
51069: PUSH
51070: LD_INT 1
51072: ARRAY
51073: PUSH
51074: LD_INT 2
51076: ARRAY
51077: PPUSH
51078: LD_EXP 107
51082: PUSH
51083: LD_VAR 0 2
51087: ARRAY
51088: PUSH
51089: LD_INT 1
51091: ARRAY
51092: PUSH
51093: LD_INT 3
51095: ARRAY
51096: PPUSH
51097: LD_EXP 107
51101: PUSH
51102: LD_VAR 0 2
51106: ARRAY
51107: PUSH
51108: LD_INT 1
51110: ARRAY
51111: PUSH
51112: LD_INT 4
51114: ARRAY
51115: PPUSH
51116: LD_EXP 102
51120: PUSH
51121: LD_VAR 0 2
51125: ARRAY
51126: PPUSH
51127: LD_INT 21
51129: PUSH
51130: LD_INT 3
51132: PUSH
51133: EMPTY
51134: LIST
51135: LIST
51136: PPUSH
51137: CALL_OW 72
51141: PPUSH
51142: EMPTY
51143: PPUSH
51144: CALL 82472 0 7
51148: NOT
51149: IFFALSE 51199
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51151: LD_ADDR_EXP 107
51155: PUSH
51156: LD_EXP 107
51160: PPUSH
51161: LD_VAR 0 2
51165: PPUSH
51166: LD_EXP 107
51170: PUSH
51171: LD_VAR 0 2
51175: ARRAY
51176: PPUSH
51177: LD_INT 1
51179: PPUSH
51180: LD_INT 1
51182: NEG
51183: PPUSH
51184: LD_INT 0
51186: PPUSH
51187: CALL 74662 0 4
51191: PPUSH
51192: CALL_OW 1
51196: ST_TO_ADDR
// continue ;
51197: GO 50630
// end ; end ;
51199: GO 50630
51201: POP
51202: POP
// end ; end ;
51203: GO 50059
51205: POP
51206: POP
// end ;
51207: LD_VAR 0 1
51211: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51212: LD_INT 0
51214: PPUSH
51215: PPUSH
51216: PPUSH
51217: PPUSH
51218: PPUSH
51219: PPUSH
// if not mc_bases then
51220: LD_EXP 102
51224: NOT
51225: IFFALSE 51229
// exit ;
51227: GO 51656
// for i = 1 to mc_bases do
51229: LD_ADDR_VAR 0 2
51233: PUSH
51234: DOUBLE
51235: LD_INT 1
51237: DEC
51238: ST_TO_ADDR
51239: LD_EXP 102
51243: PUSH
51244: FOR_TO
51245: IFFALSE 51654
// begin tmp := mc_build_upgrade [ i ] ;
51247: LD_ADDR_VAR 0 4
51251: PUSH
51252: LD_EXP 134
51256: PUSH
51257: LD_VAR 0 2
51261: ARRAY
51262: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51263: LD_ADDR_VAR 0 6
51267: PUSH
51268: LD_EXP 135
51272: PUSH
51273: LD_VAR 0 2
51277: ARRAY
51278: PPUSH
51279: LD_INT 2
51281: PUSH
51282: LD_INT 30
51284: PUSH
51285: LD_INT 6
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: PUSH
51292: LD_INT 30
51294: PUSH
51295: LD_INT 7
51297: PUSH
51298: EMPTY
51299: LIST
51300: LIST
51301: PUSH
51302: EMPTY
51303: LIST
51304: LIST
51305: LIST
51306: PPUSH
51307: CALL_OW 72
51311: ST_TO_ADDR
// if not tmp and not lab then
51312: LD_VAR 0 4
51316: NOT
51317: PUSH
51318: LD_VAR 0 6
51322: NOT
51323: AND
51324: IFFALSE 51328
// continue ;
51326: GO 51244
// if tmp then
51328: LD_VAR 0 4
51332: IFFALSE 51452
// for j in tmp do
51334: LD_ADDR_VAR 0 3
51338: PUSH
51339: LD_VAR 0 4
51343: PUSH
51344: FOR_IN
51345: IFFALSE 51450
// begin if UpgradeCost ( j ) then
51347: LD_VAR 0 3
51351: PPUSH
51352: CALL 82132 0 1
51356: IFFALSE 51448
// begin ComUpgrade ( j ) ;
51358: LD_VAR 0 3
51362: PPUSH
51363: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51367: LD_ADDR_EXP 134
51371: PUSH
51372: LD_EXP 134
51376: PPUSH
51377: LD_VAR 0 2
51381: PPUSH
51382: LD_EXP 134
51386: PUSH
51387: LD_VAR 0 2
51391: ARRAY
51392: PUSH
51393: LD_VAR 0 3
51397: DIFF
51398: PPUSH
51399: CALL_OW 1
51403: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51404: LD_ADDR_EXP 109
51408: PUSH
51409: LD_EXP 109
51413: PPUSH
51414: LD_VAR 0 2
51418: PUSH
51419: LD_EXP 109
51423: PUSH
51424: LD_VAR 0 2
51428: ARRAY
51429: PUSH
51430: LD_INT 1
51432: PLUS
51433: PUSH
51434: EMPTY
51435: LIST
51436: LIST
51437: PPUSH
51438: LD_VAR 0 3
51442: PPUSH
51443: CALL 75244 0 3
51447: ST_TO_ADDR
// end ; end ;
51448: GO 51344
51450: POP
51451: POP
// if not lab or not mc_lab_upgrade [ i ] then
51452: LD_VAR 0 6
51456: NOT
51457: PUSH
51458: LD_EXP 136
51462: PUSH
51463: LD_VAR 0 2
51467: ARRAY
51468: NOT
51469: OR
51470: IFFALSE 51474
// continue ;
51472: GO 51244
// for j in lab do
51474: LD_ADDR_VAR 0 3
51478: PUSH
51479: LD_VAR 0 6
51483: PUSH
51484: FOR_IN
51485: IFFALSE 51650
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51487: LD_VAR 0 3
51491: PPUSH
51492: CALL_OW 266
51496: PUSH
51497: LD_INT 6
51499: PUSH
51500: LD_INT 7
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: IN
51507: PUSH
51508: LD_VAR 0 3
51512: PPUSH
51513: CALL_OW 461
51517: PUSH
51518: LD_INT 1
51520: NONEQUAL
51521: AND
51522: IFFALSE 51648
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51524: LD_VAR 0 3
51528: PPUSH
51529: LD_EXP 136
51533: PUSH
51534: LD_VAR 0 2
51538: ARRAY
51539: PUSH
51540: LD_INT 1
51542: ARRAY
51543: PPUSH
51544: CALL 82337 0 2
51548: IFFALSE 51648
// begin ComCancel ( j ) ;
51550: LD_VAR 0 3
51554: PPUSH
51555: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51559: LD_VAR 0 3
51563: PPUSH
51564: LD_EXP 136
51568: PUSH
51569: LD_VAR 0 2
51573: ARRAY
51574: PUSH
51575: LD_INT 1
51577: ARRAY
51578: PPUSH
51579: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51583: LD_VAR 0 3
51587: PUSH
51588: LD_EXP 109
51592: PUSH
51593: LD_VAR 0 2
51597: ARRAY
51598: IN
51599: NOT
51600: IFFALSE 51646
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51602: LD_ADDR_EXP 109
51606: PUSH
51607: LD_EXP 109
51611: PPUSH
51612: LD_VAR 0 2
51616: PUSH
51617: LD_EXP 109
51621: PUSH
51622: LD_VAR 0 2
51626: ARRAY
51627: PUSH
51628: LD_INT 1
51630: PLUS
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: PPUSH
51636: LD_VAR 0 3
51640: PPUSH
51641: CALL 75244 0 3
51645: ST_TO_ADDR
// break ;
51646: GO 51650
// end ; end ; end ;
51648: GO 51484
51650: POP
51651: POP
// end ;
51652: GO 51244
51654: POP
51655: POP
// end ;
51656: LD_VAR 0 1
51660: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51661: LD_INT 0
51663: PPUSH
51664: PPUSH
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
// if not mc_bases then
51672: LD_EXP 102
51676: NOT
51677: IFFALSE 51681
// exit ;
51679: GO 52086
// for i = 1 to mc_bases do
51681: LD_ADDR_VAR 0 2
51685: PUSH
51686: DOUBLE
51687: LD_INT 1
51689: DEC
51690: ST_TO_ADDR
51691: LD_EXP 102
51695: PUSH
51696: FOR_TO
51697: IFFALSE 52084
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51699: LD_EXP 110
51703: PUSH
51704: LD_VAR 0 2
51708: ARRAY
51709: NOT
51710: PUSH
51711: LD_EXP 102
51715: PUSH
51716: LD_VAR 0 2
51720: ARRAY
51721: PPUSH
51722: LD_INT 30
51724: PUSH
51725: LD_INT 3
51727: PUSH
51728: EMPTY
51729: LIST
51730: LIST
51731: PPUSH
51732: CALL_OW 72
51736: NOT
51737: OR
51738: IFFALSE 51742
// continue ;
51740: GO 51696
// busy := false ;
51742: LD_ADDR_VAR 0 8
51746: PUSH
51747: LD_INT 0
51749: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51750: LD_ADDR_VAR 0 4
51754: PUSH
51755: LD_EXP 102
51759: PUSH
51760: LD_VAR 0 2
51764: ARRAY
51765: PPUSH
51766: LD_INT 30
51768: PUSH
51769: LD_INT 3
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PPUSH
51776: CALL_OW 72
51780: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51781: LD_ADDR_VAR 0 6
51785: PUSH
51786: LD_EXP 110
51790: PUSH
51791: LD_VAR 0 2
51795: ARRAY
51796: PPUSH
51797: LD_INT 2
51799: PUSH
51800: LD_INT 30
51802: PUSH
51803: LD_INT 32
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PUSH
51810: LD_INT 30
51812: PUSH
51813: LD_INT 33
51815: PUSH
51816: EMPTY
51817: LIST
51818: LIST
51819: PUSH
51820: EMPTY
51821: LIST
51822: LIST
51823: LIST
51824: PPUSH
51825: CALL_OW 72
51829: ST_TO_ADDR
// if not t then
51830: LD_VAR 0 6
51834: NOT
51835: IFFALSE 51839
// continue ;
51837: GO 51696
// for j in tmp do
51839: LD_ADDR_VAR 0 3
51843: PUSH
51844: LD_VAR 0 4
51848: PUSH
51849: FOR_IN
51850: IFFALSE 51880
// if not BuildingStatus ( j ) = bs_idle then
51852: LD_VAR 0 3
51856: PPUSH
51857: CALL_OW 461
51861: PUSH
51862: LD_INT 2
51864: EQUAL
51865: NOT
51866: IFFALSE 51878
// begin busy := true ;
51868: LD_ADDR_VAR 0 8
51872: PUSH
51873: LD_INT 1
51875: ST_TO_ADDR
// break ;
51876: GO 51880
// end ;
51878: GO 51849
51880: POP
51881: POP
// if busy then
51882: LD_VAR 0 8
51886: IFFALSE 51890
// continue ;
51888: GO 51696
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51890: LD_ADDR_VAR 0 7
51894: PUSH
51895: LD_VAR 0 6
51899: PPUSH
51900: LD_INT 35
51902: PUSH
51903: LD_INT 0
51905: PUSH
51906: EMPTY
51907: LIST
51908: LIST
51909: PPUSH
51910: CALL_OW 72
51914: ST_TO_ADDR
// if tw then
51915: LD_VAR 0 7
51919: IFFALSE 51996
// begin tw := tw [ 1 ] ;
51921: LD_ADDR_VAR 0 7
51925: PUSH
51926: LD_VAR 0 7
51930: PUSH
51931: LD_INT 1
51933: ARRAY
51934: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51935: LD_ADDR_VAR 0 9
51939: PUSH
51940: LD_VAR 0 7
51944: PPUSH
51945: LD_EXP 127
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PPUSH
51956: CALL 80629 0 2
51960: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51961: LD_EXP 141
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: IFFALSE 51994
// if not weapon in mc_allowed_tower_weapons [ i ] then
51973: LD_VAR 0 9
51977: PUSH
51978: LD_EXP 141
51982: PUSH
51983: LD_VAR 0 2
51987: ARRAY
51988: IN
51989: NOT
51990: IFFALSE 51994
// continue ;
51992: GO 51696
// end else
51994: GO 52059
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51996: LD_ADDR_VAR 0 5
52000: PUSH
52001: LD_EXP 110
52005: PUSH
52006: LD_VAR 0 2
52010: ARRAY
52011: PPUSH
52012: LD_VAR 0 4
52016: PPUSH
52017: CALL 107521 0 2
52021: ST_TO_ADDR
// if not tmp2 then
52022: LD_VAR 0 5
52026: NOT
52027: IFFALSE 52031
// continue ;
52029: GO 51696
// tw := tmp2 [ 1 ] ;
52031: LD_ADDR_VAR 0 7
52035: PUSH
52036: LD_VAR 0 5
52040: PUSH
52041: LD_INT 1
52043: ARRAY
52044: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52045: LD_ADDR_VAR 0 9
52049: PUSH
52050: LD_VAR 0 5
52054: PUSH
52055: LD_INT 2
52057: ARRAY
52058: ST_TO_ADDR
// end ; if not weapon then
52059: LD_VAR 0 9
52063: NOT
52064: IFFALSE 52068
// continue ;
52066: GO 51696
// ComPlaceWeapon ( tw , weapon ) ;
52068: LD_VAR 0 7
52072: PPUSH
52073: LD_VAR 0 9
52077: PPUSH
52078: CALL_OW 148
// end ;
52082: GO 51696
52084: POP
52085: POP
// end ;
52086: LD_VAR 0 1
52090: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52091: LD_INT 0
52093: PPUSH
52094: PPUSH
52095: PPUSH
52096: PPUSH
52097: PPUSH
52098: PPUSH
52099: PPUSH
// if not mc_bases then
52100: LD_EXP 102
52104: NOT
52105: IFFALSE 52109
// exit ;
52107: GO 52884
// for i = 1 to mc_bases do
52109: LD_ADDR_VAR 0 2
52113: PUSH
52114: DOUBLE
52115: LD_INT 1
52117: DEC
52118: ST_TO_ADDR
52119: LD_EXP 102
52123: PUSH
52124: FOR_TO
52125: IFFALSE 52882
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52127: LD_EXP 115
52131: PUSH
52132: LD_VAR 0 2
52136: ARRAY
52137: NOT
52138: PUSH
52139: LD_EXP 115
52143: PUSH
52144: LD_VAR 0 2
52148: ARRAY
52149: PUSH
52150: LD_EXP 116
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: EQUAL
52161: OR
52162: PUSH
52163: LD_EXP 125
52167: PUSH
52168: LD_VAR 0 2
52172: ARRAY
52173: OR
52174: IFFALSE 52178
// continue ;
52176: GO 52124
// if mc_miners [ i ] then
52178: LD_EXP 116
52182: PUSH
52183: LD_VAR 0 2
52187: ARRAY
52188: IFFALSE 52569
// begin for j = mc_miners [ i ] downto 1 do
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: DOUBLE
52196: LD_EXP 116
52200: PUSH
52201: LD_VAR 0 2
52205: ARRAY
52206: INC
52207: ST_TO_ADDR
52208: LD_INT 1
52210: PUSH
52211: FOR_DOWNTO
52212: IFFALSE 52567
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52214: LD_EXP 116
52218: PUSH
52219: LD_VAR 0 2
52223: ARRAY
52224: PUSH
52225: LD_VAR 0 3
52229: ARRAY
52230: PPUSH
52231: CALL_OW 301
52235: PUSH
52236: LD_EXP 116
52240: PUSH
52241: LD_VAR 0 2
52245: ARRAY
52246: PUSH
52247: LD_VAR 0 3
52251: ARRAY
52252: PPUSH
52253: CALL_OW 257
52257: PUSH
52258: LD_INT 1
52260: NONEQUAL
52261: OR
52262: IFFALSE 52325
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52264: LD_ADDR_VAR 0 5
52268: PUSH
52269: LD_EXP 116
52273: PUSH
52274: LD_VAR 0 2
52278: ARRAY
52279: PUSH
52280: LD_EXP 116
52284: PUSH
52285: LD_VAR 0 2
52289: ARRAY
52290: PUSH
52291: LD_VAR 0 3
52295: ARRAY
52296: DIFF
52297: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52298: LD_ADDR_EXP 116
52302: PUSH
52303: LD_EXP 116
52307: PPUSH
52308: LD_VAR 0 2
52312: PPUSH
52313: LD_VAR 0 5
52317: PPUSH
52318: CALL_OW 1
52322: ST_TO_ADDR
// continue ;
52323: GO 52211
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52325: LD_EXP 116
52329: PUSH
52330: LD_VAR 0 2
52334: ARRAY
52335: PUSH
52336: LD_VAR 0 3
52340: ARRAY
52341: PPUSH
52342: CALL_OW 257
52346: PUSH
52347: LD_INT 1
52349: EQUAL
52350: PUSH
52351: LD_EXP 116
52355: PUSH
52356: LD_VAR 0 2
52360: ARRAY
52361: PUSH
52362: LD_VAR 0 3
52366: ARRAY
52367: PPUSH
52368: CALL_OW 459
52372: NOT
52373: AND
52374: PUSH
52375: LD_EXP 116
52379: PUSH
52380: LD_VAR 0 2
52384: ARRAY
52385: PUSH
52386: LD_VAR 0 3
52390: ARRAY
52391: PPUSH
52392: CALL_OW 314
52396: NOT
52397: AND
52398: IFFALSE 52565
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52400: LD_EXP 116
52404: PUSH
52405: LD_VAR 0 2
52409: ARRAY
52410: PUSH
52411: LD_VAR 0 3
52415: ARRAY
52416: PPUSH
52417: CALL_OW 310
52421: IFFALSE 52444
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52423: LD_EXP 116
52427: PUSH
52428: LD_VAR 0 2
52432: ARRAY
52433: PUSH
52434: LD_VAR 0 3
52438: ARRAY
52439: PPUSH
52440: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52444: LD_EXP 116
52448: PUSH
52449: LD_VAR 0 2
52453: ARRAY
52454: PUSH
52455: LD_VAR 0 3
52459: ARRAY
52460: PPUSH
52461: CALL_OW 314
52465: NOT
52466: IFFALSE 52565
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52468: LD_ADDR_VAR 0 7
52472: PUSH
52473: LD_VAR 0 3
52477: PUSH
52478: LD_EXP 115
52482: PUSH
52483: LD_VAR 0 2
52487: ARRAY
52488: PPUSH
52489: CALL 72384 0 1
52493: MOD
52494: PUSH
52495: LD_INT 1
52497: PLUS
52498: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52499: LD_EXP 116
52503: PUSH
52504: LD_VAR 0 2
52508: ARRAY
52509: PUSH
52510: LD_VAR 0 3
52514: ARRAY
52515: PPUSH
52516: LD_EXP 115
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: PUSH
52527: LD_VAR 0 7
52531: ARRAY
52532: PUSH
52533: LD_INT 1
52535: ARRAY
52536: PPUSH
52537: LD_EXP 115
52541: PUSH
52542: LD_VAR 0 2
52546: ARRAY
52547: PUSH
52548: LD_VAR 0 7
52552: ARRAY
52553: PUSH
52554: LD_INT 2
52556: ARRAY
52557: PPUSH
52558: LD_INT 0
52560: PPUSH
52561: CALL_OW 193
// end ; end ; end ;
52565: GO 52211
52567: POP
52568: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52569: LD_ADDR_VAR 0 5
52573: PUSH
52574: LD_EXP 102
52578: PUSH
52579: LD_VAR 0 2
52583: ARRAY
52584: PPUSH
52585: LD_INT 2
52587: PUSH
52588: LD_INT 30
52590: PUSH
52591: LD_INT 4
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: PUSH
52598: LD_INT 30
52600: PUSH
52601: LD_INT 5
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: PUSH
52608: LD_INT 30
52610: PUSH
52611: LD_INT 32
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: LIST
52622: LIST
52623: PPUSH
52624: CALL_OW 72
52628: ST_TO_ADDR
// if not tmp then
52629: LD_VAR 0 5
52633: NOT
52634: IFFALSE 52638
// continue ;
52636: GO 52124
// list := [ ] ;
52638: LD_ADDR_VAR 0 6
52642: PUSH
52643: EMPTY
52644: ST_TO_ADDR
// for j in tmp do
52645: LD_ADDR_VAR 0 3
52649: PUSH
52650: LD_VAR 0 5
52654: PUSH
52655: FOR_IN
52656: IFFALSE 52725
// begin for k in UnitsInside ( j ) do
52658: LD_ADDR_VAR 0 4
52662: PUSH
52663: LD_VAR 0 3
52667: PPUSH
52668: CALL_OW 313
52672: PUSH
52673: FOR_IN
52674: IFFALSE 52721
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52676: LD_VAR 0 4
52680: PPUSH
52681: CALL_OW 257
52685: PUSH
52686: LD_INT 1
52688: EQUAL
52689: PUSH
52690: LD_VAR 0 4
52694: PPUSH
52695: CALL_OW 459
52699: NOT
52700: AND
52701: IFFALSE 52719
// list := list ^ k ;
52703: LD_ADDR_VAR 0 6
52707: PUSH
52708: LD_VAR 0 6
52712: PUSH
52713: LD_VAR 0 4
52717: ADD
52718: ST_TO_ADDR
52719: GO 52673
52721: POP
52722: POP
// end ;
52723: GO 52655
52725: POP
52726: POP
// list := list diff mc_miners [ i ] ;
52727: LD_ADDR_VAR 0 6
52731: PUSH
52732: LD_VAR 0 6
52736: PUSH
52737: LD_EXP 116
52741: PUSH
52742: LD_VAR 0 2
52746: ARRAY
52747: DIFF
52748: ST_TO_ADDR
// if not list then
52749: LD_VAR 0 6
52753: NOT
52754: IFFALSE 52758
// continue ;
52756: GO 52124
// k := mc_mines [ i ] - mc_miners [ i ] ;
52758: LD_ADDR_VAR 0 4
52762: PUSH
52763: LD_EXP 115
52767: PUSH
52768: LD_VAR 0 2
52772: ARRAY
52773: PUSH
52774: LD_EXP 116
52778: PUSH
52779: LD_VAR 0 2
52783: ARRAY
52784: MINUS
52785: ST_TO_ADDR
// if k > list then
52786: LD_VAR 0 4
52790: PUSH
52791: LD_VAR 0 6
52795: GREATER
52796: IFFALSE 52808
// k := list ;
52798: LD_ADDR_VAR 0 4
52802: PUSH
52803: LD_VAR 0 6
52807: ST_TO_ADDR
// for j = 1 to k do
52808: LD_ADDR_VAR 0 3
52812: PUSH
52813: DOUBLE
52814: LD_INT 1
52816: DEC
52817: ST_TO_ADDR
52818: LD_VAR 0 4
52822: PUSH
52823: FOR_TO
52824: IFFALSE 52878
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52826: LD_ADDR_EXP 116
52830: PUSH
52831: LD_EXP 116
52835: PPUSH
52836: LD_VAR 0 2
52840: PUSH
52841: LD_EXP 116
52845: PUSH
52846: LD_VAR 0 2
52850: ARRAY
52851: PUSH
52852: LD_INT 1
52854: PLUS
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PPUSH
52860: LD_VAR 0 6
52864: PUSH
52865: LD_VAR 0 3
52869: ARRAY
52870: PPUSH
52871: CALL 75244 0 3
52875: ST_TO_ADDR
52876: GO 52823
52878: POP
52879: POP
// end ;
52880: GO 52124
52882: POP
52883: POP
// end ;
52884: LD_VAR 0 1
52888: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52889: LD_INT 0
52891: PPUSH
52892: PPUSH
52893: PPUSH
52894: PPUSH
52895: PPUSH
52896: PPUSH
52897: PPUSH
52898: PPUSH
52899: PPUSH
52900: PPUSH
52901: PPUSH
// if not mc_bases then
52902: LD_EXP 102
52906: NOT
52907: IFFALSE 52911
// exit ;
52909: GO 54734
// for i = 1 to mc_bases do
52911: LD_ADDR_VAR 0 2
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_EXP 102
52925: PUSH
52926: FOR_TO
52927: IFFALSE 54732
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52929: LD_EXP 102
52933: PUSH
52934: LD_VAR 0 2
52938: ARRAY
52939: NOT
52940: PUSH
52941: LD_EXP 109
52945: PUSH
52946: LD_VAR 0 2
52950: ARRAY
52951: OR
52952: IFFALSE 52956
// continue ;
52954: GO 52926
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52956: LD_EXP 118
52960: PUSH
52961: LD_VAR 0 2
52965: ARRAY
52966: NOT
52967: PUSH
52968: LD_EXP 119
52972: PUSH
52973: LD_VAR 0 2
52977: ARRAY
52978: AND
52979: IFFALSE 53017
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52981: LD_ADDR_EXP 119
52985: PUSH
52986: LD_EXP 119
52990: PPUSH
52991: LD_VAR 0 2
52995: PPUSH
52996: EMPTY
52997: PPUSH
52998: CALL_OW 1
53002: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53003: LD_VAR 0 2
53007: PPUSH
53008: LD_INT 107
53010: PPUSH
53011: CALL 43743 0 2
// continue ;
53015: GO 52926
// end ; target := [ ] ;
53017: LD_ADDR_VAR 0 7
53021: PUSH
53022: EMPTY
53023: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53024: LD_ADDR_VAR 0 6
53028: PUSH
53029: LD_EXP 102
53033: PUSH
53034: LD_VAR 0 2
53038: ARRAY
53039: PUSH
53040: LD_INT 1
53042: ARRAY
53043: PPUSH
53044: CALL_OW 255
53048: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53049: LD_ADDR_VAR 0 9
53053: PUSH
53054: LD_EXP 102
53058: PUSH
53059: LD_VAR 0 2
53063: ARRAY
53064: PPUSH
53065: LD_INT 2
53067: PUSH
53068: LD_INT 30
53070: PUSH
53071: LD_INT 0
53073: PUSH
53074: EMPTY
53075: LIST
53076: LIST
53077: PUSH
53078: LD_INT 30
53080: PUSH
53081: LD_INT 1
53083: PUSH
53084: EMPTY
53085: LIST
53086: LIST
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: LIST
53092: PPUSH
53093: CALL_OW 72
53097: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53098: LD_ADDR_VAR 0 3
53102: PUSH
53103: DOUBLE
53104: LD_EXP 118
53108: PUSH
53109: LD_VAR 0 2
53113: ARRAY
53114: INC
53115: ST_TO_ADDR
53116: LD_INT 1
53118: PUSH
53119: FOR_DOWNTO
53120: IFFALSE 53365
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53122: LD_EXP 118
53126: PUSH
53127: LD_VAR 0 2
53131: ARRAY
53132: PUSH
53133: LD_VAR 0 3
53137: ARRAY
53138: PUSH
53139: LD_INT 2
53141: ARRAY
53142: PPUSH
53143: LD_EXP 118
53147: PUSH
53148: LD_VAR 0 2
53152: ARRAY
53153: PUSH
53154: LD_VAR 0 3
53158: ARRAY
53159: PUSH
53160: LD_INT 3
53162: ARRAY
53163: PPUSH
53164: CALL_OW 488
53168: PUSH
53169: LD_EXP 118
53173: PUSH
53174: LD_VAR 0 2
53178: ARRAY
53179: PUSH
53180: LD_VAR 0 3
53184: ARRAY
53185: PUSH
53186: LD_INT 2
53188: ARRAY
53189: PPUSH
53190: LD_EXP 118
53194: PUSH
53195: LD_VAR 0 2
53199: ARRAY
53200: PUSH
53201: LD_VAR 0 3
53205: ARRAY
53206: PUSH
53207: LD_INT 3
53209: ARRAY
53210: PPUSH
53211: CALL_OW 284
53215: PUSH
53216: LD_INT 0
53218: EQUAL
53219: AND
53220: IFFALSE 53275
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53222: LD_ADDR_VAR 0 5
53226: PUSH
53227: LD_EXP 118
53231: PUSH
53232: LD_VAR 0 2
53236: ARRAY
53237: PPUSH
53238: LD_VAR 0 3
53242: PPUSH
53243: CALL_OW 3
53247: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53248: LD_ADDR_EXP 118
53252: PUSH
53253: LD_EXP 118
53257: PPUSH
53258: LD_VAR 0 2
53262: PPUSH
53263: LD_VAR 0 5
53267: PPUSH
53268: CALL_OW 1
53272: ST_TO_ADDR
// continue ;
53273: GO 53119
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53275: LD_VAR 0 6
53279: PPUSH
53280: LD_EXP 118
53284: PUSH
53285: LD_VAR 0 2
53289: ARRAY
53290: PUSH
53291: LD_VAR 0 3
53295: ARRAY
53296: PUSH
53297: LD_INT 2
53299: ARRAY
53300: PPUSH
53301: LD_EXP 118
53305: PUSH
53306: LD_VAR 0 2
53310: ARRAY
53311: PUSH
53312: LD_VAR 0 3
53316: ARRAY
53317: PUSH
53318: LD_INT 3
53320: ARRAY
53321: PPUSH
53322: LD_INT 30
53324: PPUSH
53325: CALL 76508 0 4
53329: PUSH
53330: LD_INT 4
53332: ARRAY
53333: PUSH
53334: LD_INT 0
53336: EQUAL
53337: IFFALSE 53363
// begin target := mc_crates [ i ] [ j ] ;
53339: LD_ADDR_VAR 0 7
53343: PUSH
53344: LD_EXP 118
53348: PUSH
53349: LD_VAR 0 2
53353: ARRAY
53354: PUSH
53355: LD_VAR 0 3
53359: ARRAY
53360: ST_TO_ADDR
// break ;
53361: GO 53365
// end ; end ;
53363: GO 53119
53365: POP
53366: POP
// if not target then
53367: LD_VAR 0 7
53371: NOT
53372: IFFALSE 53376
// continue ;
53374: GO 52926
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53376: LD_ADDR_VAR 0 8
53380: PUSH
53381: LD_EXP 121
53385: PUSH
53386: LD_VAR 0 2
53390: ARRAY
53391: PPUSH
53392: LD_INT 2
53394: PUSH
53395: LD_INT 3
53397: PUSH
53398: LD_INT 58
53400: PUSH
53401: EMPTY
53402: LIST
53403: PUSH
53404: EMPTY
53405: LIST
53406: LIST
53407: PUSH
53408: LD_INT 61
53410: PUSH
53411: EMPTY
53412: LIST
53413: PUSH
53414: LD_INT 33
53416: PUSH
53417: LD_INT 5
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: LD_INT 33
53426: PUSH
53427: LD_INT 3
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: LIST
53438: LIST
53439: LIST
53440: PUSH
53441: LD_INT 2
53443: PUSH
53444: LD_INT 34
53446: PUSH
53447: LD_INT 32
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: PUSH
53454: LD_INT 34
53456: PUSH
53457: LD_INT 51
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: LD_INT 34
53466: PUSH
53467: LD_INT 12
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PUSH
53474: EMPTY
53475: LIST
53476: LIST
53477: LIST
53478: LIST
53479: PUSH
53480: EMPTY
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 72
53488: ST_TO_ADDR
// if not cargo then
53489: LD_VAR 0 8
53493: NOT
53494: IFFALSE 54200
// begin if mc_crates_collector [ i ] < 5 then
53496: LD_EXP 119
53500: PUSH
53501: LD_VAR 0 2
53505: ARRAY
53506: PUSH
53507: LD_INT 5
53509: LESS
53510: IFFALSE 53876
// begin if mc_ape [ i ] then
53512: LD_EXP 131
53516: PUSH
53517: LD_VAR 0 2
53521: ARRAY
53522: IFFALSE 53569
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53524: LD_ADDR_VAR 0 5
53528: PUSH
53529: LD_EXP 131
53533: PUSH
53534: LD_VAR 0 2
53538: ARRAY
53539: PPUSH
53540: LD_INT 25
53542: PUSH
53543: LD_INT 16
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: LD_INT 24
53552: PUSH
53553: LD_INT 750
53555: PUSH
53556: EMPTY
53557: LIST
53558: LIST
53559: PUSH
53560: EMPTY
53561: LIST
53562: LIST
53563: PPUSH
53564: CALL_OW 72
53568: ST_TO_ADDR
// if not tmp then
53569: LD_VAR 0 5
53573: NOT
53574: IFFALSE 53621
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53576: LD_ADDR_VAR 0 5
53580: PUSH
53581: LD_EXP 102
53585: PUSH
53586: LD_VAR 0 2
53590: ARRAY
53591: PPUSH
53592: LD_INT 25
53594: PUSH
53595: LD_INT 2
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: LD_INT 24
53604: PUSH
53605: LD_INT 750
53607: PUSH
53608: EMPTY
53609: LIST
53610: LIST
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: PPUSH
53616: CALL_OW 72
53620: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53621: LD_EXP 131
53625: PUSH
53626: LD_VAR 0 2
53630: ARRAY
53631: PUSH
53632: LD_EXP 102
53636: PUSH
53637: LD_VAR 0 2
53641: ARRAY
53642: PPUSH
53643: LD_INT 25
53645: PUSH
53646: LD_INT 2
53648: PUSH
53649: EMPTY
53650: LIST
53651: LIST
53652: PUSH
53653: LD_INT 24
53655: PUSH
53656: LD_INT 750
53658: PUSH
53659: EMPTY
53660: LIST
53661: LIST
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PPUSH
53667: CALL_OW 72
53671: AND
53672: PUSH
53673: LD_VAR 0 5
53677: PUSH
53678: LD_INT 5
53680: LESS
53681: AND
53682: IFFALSE 53764
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53684: LD_ADDR_VAR 0 3
53688: PUSH
53689: LD_EXP 102
53693: PUSH
53694: LD_VAR 0 2
53698: ARRAY
53699: PPUSH
53700: LD_INT 25
53702: PUSH
53703: LD_INT 2
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: PUSH
53710: LD_INT 24
53712: PUSH
53713: LD_INT 750
53715: PUSH
53716: EMPTY
53717: LIST
53718: LIST
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: PPUSH
53724: CALL_OW 72
53728: PUSH
53729: FOR_IN
53730: IFFALSE 53762
// begin tmp := tmp union j ;
53732: LD_ADDR_VAR 0 5
53736: PUSH
53737: LD_VAR 0 5
53741: PUSH
53742: LD_VAR 0 3
53746: UNION
53747: ST_TO_ADDR
// if tmp >= 5 then
53748: LD_VAR 0 5
53752: PUSH
53753: LD_INT 5
53755: GREATEREQUAL
53756: IFFALSE 53760
// break ;
53758: GO 53762
// end ;
53760: GO 53729
53762: POP
53763: POP
// end ; if not tmp then
53764: LD_VAR 0 5
53768: NOT
53769: IFFALSE 53773
// continue ;
53771: GO 52926
// for j in tmp do
53773: LD_ADDR_VAR 0 3
53777: PUSH
53778: LD_VAR 0 5
53782: PUSH
53783: FOR_IN
53784: IFFALSE 53874
// if not GetTag ( j ) then
53786: LD_VAR 0 3
53790: PPUSH
53791: CALL_OW 110
53795: NOT
53796: IFFALSE 53872
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53798: LD_ADDR_EXP 119
53802: PUSH
53803: LD_EXP 119
53807: PPUSH
53808: LD_VAR 0 2
53812: PUSH
53813: LD_EXP 119
53817: PUSH
53818: LD_VAR 0 2
53822: ARRAY
53823: PUSH
53824: LD_INT 1
53826: PLUS
53827: PUSH
53828: EMPTY
53829: LIST
53830: LIST
53831: PPUSH
53832: LD_VAR 0 3
53836: PPUSH
53837: CALL 75244 0 3
53841: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53842: LD_VAR 0 3
53846: PPUSH
53847: LD_INT 107
53849: PPUSH
53850: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53854: LD_EXP 119
53858: PUSH
53859: LD_VAR 0 2
53863: ARRAY
53864: PUSH
53865: LD_INT 5
53867: GREATEREQUAL
53868: IFFALSE 53872
// break ;
53870: GO 53874
// end ;
53872: GO 53783
53874: POP
53875: POP
// end ; if mc_crates_collector [ i ] and target then
53876: LD_EXP 119
53880: PUSH
53881: LD_VAR 0 2
53885: ARRAY
53886: PUSH
53887: LD_VAR 0 7
53891: AND
53892: IFFALSE 54198
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53894: LD_EXP 119
53898: PUSH
53899: LD_VAR 0 2
53903: ARRAY
53904: PUSH
53905: LD_VAR 0 7
53909: PUSH
53910: LD_INT 1
53912: ARRAY
53913: LESS
53914: IFFALSE 53934
// tmp := mc_crates_collector [ i ] else
53916: LD_ADDR_VAR 0 5
53920: PUSH
53921: LD_EXP 119
53925: PUSH
53926: LD_VAR 0 2
53930: ARRAY
53931: ST_TO_ADDR
53932: GO 53948
// tmp := target [ 1 ] ;
53934: LD_ADDR_VAR 0 5
53938: PUSH
53939: LD_VAR 0 7
53943: PUSH
53944: LD_INT 1
53946: ARRAY
53947: ST_TO_ADDR
// k := 0 ;
53948: LD_ADDR_VAR 0 4
53952: PUSH
53953: LD_INT 0
53955: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53956: LD_ADDR_VAR 0 3
53960: PUSH
53961: LD_EXP 119
53965: PUSH
53966: LD_VAR 0 2
53970: ARRAY
53971: PUSH
53972: FOR_IN
53973: IFFALSE 54196
// begin k := k + 1 ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_VAR 0 4
53984: PUSH
53985: LD_INT 1
53987: PLUS
53988: ST_TO_ADDR
// if k > tmp then
53989: LD_VAR 0 4
53993: PUSH
53994: LD_VAR 0 5
53998: GREATER
53999: IFFALSE 54003
// break ;
54001: GO 54196
// if not GetClass ( j ) in [ 2 , 16 ] then
54003: LD_VAR 0 3
54007: PPUSH
54008: CALL_OW 257
54012: PUSH
54013: LD_INT 2
54015: PUSH
54016: LD_INT 16
54018: PUSH
54019: EMPTY
54020: LIST
54021: LIST
54022: IN
54023: NOT
54024: IFFALSE 54077
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54026: LD_ADDR_EXP 119
54030: PUSH
54031: LD_EXP 119
54035: PPUSH
54036: LD_VAR 0 2
54040: PPUSH
54041: LD_EXP 119
54045: PUSH
54046: LD_VAR 0 2
54050: ARRAY
54051: PUSH
54052: LD_VAR 0 3
54056: DIFF
54057: PPUSH
54058: CALL_OW 1
54062: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54063: LD_VAR 0 3
54067: PPUSH
54068: LD_INT 0
54070: PPUSH
54071: CALL_OW 109
// continue ;
54075: GO 53972
// end ; if IsInUnit ( j ) then
54077: LD_VAR 0 3
54081: PPUSH
54082: CALL_OW 310
54086: IFFALSE 54097
// ComExitBuilding ( j ) ;
54088: LD_VAR 0 3
54092: PPUSH
54093: CALL_OW 122
// wait ( 3 ) ;
54097: LD_INT 3
54099: PPUSH
54100: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54104: LD_VAR 0 3
54108: PPUSH
54109: CALL_OW 314
54113: PUSH
54114: LD_VAR 0 6
54118: PPUSH
54119: LD_VAR 0 7
54123: PUSH
54124: LD_INT 2
54126: ARRAY
54127: PPUSH
54128: LD_VAR 0 7
54132: PUSH
54133: LD_INT 3
54135: ARRAY
54136: PPUSH
54137: LD_INT 30
54139: PPUSH
54140: CALL 76508 0 4
54144: PUSH
54145: LD_INT 4
54147: ARRAY
54148: AND
54149: IFFALSE 54167
// ComStandNearbyBuilding ( j , depot ) else
54151: LD_VAR 0 3
54155: PPUSH
54156: LD_VAR 0 9
54160: PPUSH
54161: CALL 71846 0 2
54165: GO 54194
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54167: LD_VAR 0 3
54171: PPUSH
54172: LD_VAR 0 7
54176: PUSH
54177: LD_INT 2
54179: ARRAY
54180: PPUSH
54181: LD_VAR 0 7
54185: PUSH
54186: LD_INT 3
54188: ARRAY
54189: PPUSH
54190: CALL_OW 117
// end ;
54194: GO 53972
54196: POP
54197: POP
// end ; end else
54198: GO 54730
// begin for j in cargo do
54200: LD_ADDR_VAR 0 3
54204: PUSH
54205: LD_VAR 0 8
54209: PUSH
54210: FOR_IN
54211: IFFALSE 54728
// begin if GetTag ( j ) <> 0 then
54213: LD_VAR 0 3
54217: PPUSH
54218: CALL_OW 110
54222: PUSH
54223: LD_INT 0
54225: NONEQUAL
54226: IFFALSE 54230
// continue ;
54228: GO 54210
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54230: LD_VAR 0 3
54234: PPUSH
54235: CALL_OW 256
54239: PUSH
54240: LD_INT 1000
54242: LESS
54243: PUSH
54244: LD_VAR 0 3
54248: PPUSH
54249: LD_EXP 126
54253: PUSH
54254: LD_VAR 0 2
54258: ARRAY
54259: PPUSH
54260: CALL_OW 308
54264: NOT
54265: AND
54266: IFFALSE 54288
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54268: LD_VAR 0 3
54272: PPUSH
54273: LD_EXP 126
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: PPUSH
54284: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54288: LD_VAR 0 3
54292: PPUSH
54293: CALL_OW 256
54297: PUSH
54298: LD_INT 1000
54300: LESS
54301: PUSH
54302: LD_VAR 0 3
54306: PPUSH
54307: LD_EXP 126
54311: PUSH
54312: LD_VAR 0 2
54316: ARRAY
54317: PPUSH
54318: CALL_OW 308
54322: AND
54323: IFFALSE 54327
// continue ;
54325: GO 54210
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54327: LD_VAR 0 3
54331: PPUSH
54332: CALL_OW 262
54336: PUSH
54337: LD_INT 2
54339: EQUAL
54340: PUSH
54341: LD_VAR 0 3
54345: PPUSH
54346: CALL_OW 261
54350: PUSH
54351: LD_INT 15
54353: LESS
54354: AND
54355: IFFALSE 54359
// continue ;
54357: GO 54210
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54359: LD_VAR 0 3
54363: PPUSH
54364: CALL_OW 262
54368: PUSH
54369: LD_INT 1
54371: EQUAL
54372: PUSH
54373: LD_VAR 0 3
54377: PPUSH
54378: CALL_OW 261
54382: PUSH
54383: LD_INT 10
54385: LESS
54386: AND
54387: IFFALSE 54667
// begin if not depot then
54389: LD_VAR 0 9
54393: NOT
54394: IFFALSE 54398
// continue ;
54396: GO 54210
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54398: LD_VAR 0 3
54402: PPUSH
54403: LD_VAR 0 9
54407: PPUSH
54408: LD_VAR 0 3
54412: PPUSH
54413: CALL_OW 74
54417: PPUSH
54418: CALL_OW 296
54422: PUSH
54423: LD_INT 6
54425: LESS
54426: IFFALSE 54442
// SetFuel ( j , 100 ) else
54428: LD_VAR 0 3
54432: PPUSH
54433: LD_INT 100
54435: PPUSH
54436: CALL_OW 240
54440: GO 54667
// if GetFuel ( j ) = 0 then
54442: LD_VAR 0 3
54446: PPUSH
54447: CALL_OW 261
54451: PUSH
54452: LD_INT 0
54454: EQUAL
54455: IFFALSE 54667
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54457: LD_ADDR_EXP 121
54461: PUSH
54462: LD_EXP 121
54466: PPUSH
54467: LD_VAR 0 2
54471: PPUSH
54472: LD_EXP 121
54476: PUSH
54477: LD_VAR 0 2
54481: ARRAY
54482: PUSH
54483: LD_VAR 0 3
54487: DIFF
54488: PPUSH
54489: CALL_OW 1
54493: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54494: LD_VAR 0 3
54498: PPUSH
54499: CALL_OW 263
54503: PUSH
54504: LD_INT 1
54506: EQUAL
54507: IFFALSE 54523
// ComExitVehicle ( IsInUnit ( j ) ) ;
54509: LD_VAR 0 3
54513: PPUSH
54514: CALL_OW 310
54518: PPUSH
54519: CALL_OW 121
// if GetControl ( j ) = control_remote then
54523: LD_VAR 0 3
54527: PPUSH
54528: CALL_OW 263
54532: PUSH
54533: LD_INT 2
54535: EQUAL
54536: IFFALSE 54547
// ComUnlink ( j ) ;
54538: LD_VAR 0 3
54542: PPUSH
54543: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54547: LD_ADDR_VAR 0 10
54551: PUSH
54552: LD_VAR 0 2
54556: PPUSH
54557: LD_INT 3
54559: PPUSH
54560: CALL 64311 0 2
54564: ST_TO_ADDR
// if fac then
54565: LD_VAR 0 10
54569: IFFALSE 54665
// begin for k in fac do
54571: LD_ADDR_VAR 0 4
54575: PUSH
54576: LD_VAR 0 10
54580: PUSH
54581: FOR_IN
54582: IFFALSE 54663
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54584: LD_ADDR_VAR 0 11
54588: PUSH
54589: LD_VAR 0 10
54593: PPUSH
54594: LD_VAR 0 3
54598: PPUSH
54599: CALL_OW 265
54603: PPUSH
54604: LD_VAR 0 3
54608: PPUSH
54609: CALL_OW 262
54613: PPUSH
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 263
54623: PPUSH
54624: LD_VAR 0 3
54628: PPUSH
54629: CALL_OW 264
54633: PPUSH
54634: CALL 72742 0 5
54638: ST_TO_ADDR
// if components then
54639: LD_VAR 0 11
54643: IFFALSE 54661
// begin MC_InsertProduceList ( i , components ) ;
54645: LD_VAR 0 2
54649: PPUSH
54650: LD_VAR 0 11
54654: PPUSH
54655: CALL 63856 0 2
// break ;
54659: GO 54663
// end ; end ;
54661: GO 54581
54663: POP
54664: POP
// end ; continue ;
54665: GO 54210
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54667: LD_VAR 0 3
54671: PPUSH
54672: LD_INT 1
54674: PPUSH
54675: CALL_OW 289
54679: PUSH
54680: LD_INT 100
54682: LESS
54683: PUSH
54684: LD_VAR 0 3
54688: PPUSH
54689: CALL_OW 314
54693: NOT
54694: AND
54695: IFFALSE 54724
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54697: LD_VAR 0 3
54701: PPUSH
54702: LD_VAR 0 7
54706: PUSH
54707: LD_INT 2
54709: ARRAY
54710: PPUSH
54711: LD_VAR 0 7
54715: PUSH
54716: LD_INT 3
54718: ARRAY
54719: PPUSH
54720: CALL_OW 117
// break ;
54724: GO 54728
// end ;
54726: GO 54210
54728: POP
54729: POP
// end ; end ;
54730: GO 52926
54732: POP
54733: POP
// end ;
54734: LD_VAR 0 1
54738: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54739: LD_INT 0
54741: PPUSH
54742: PPUSH
54743: PPUSH
54744: PPUSH
// if not mc_bases then
54745: LD_EXP 102
54749: NOT
54750: IFFALSE 54754
// exit ;
54752: GO 54915
// for i = 1 to mc_bases do
54754: LD_ADDR_VAR 0 2
54758: PUSH
54759: DOUBLE
54760: LD_INT 1
54762: DEC
54763: ST_TO_ADDR
54764: LD_EXP 102
54768: PUSH
54769: FOR_TO
54770: IFFALSE 54913
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54772: LD_ADDR_VAR 0 4
54776: PUSH
54777: LD_EXP 121
54781: PUSH
54782: LD_VAR 0 2
54786: ARRAY
54787: PUSH
54788: LD_EXP 124
54792: PUSH
54793: LD_VAR 0 2
54797: ARRAY
54798: UNION
54799: PPUSH
54800: LD_INT 33
54802: PUSH
54803: LD_INT 2
54805: PUSH
54806: EMPTY
54807: LIST
54808: LIST
54809: PPUSH
54810: CALL_OW 72
54814: ST_TO_ADDR
// if tmp then
54815: LD_VAR 0 4
54819: IFFALSE 54911
// for j in tmp do
54821: LD_ADDR_VAR 0 3
54825: PUSH
54826: LD_VAR 0 4
54830: PUSH
54831: FOR_IN
54832: IFFALSE 54909
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54834: LD_VAR 0 3
54838: PPUSH
54839: CALL_OW 312
54843: NOT
54844: PUSH
54845: LD_VAR 0 3
54849: PPUSH
54850: CALL_OW 256
54854: PUSH
54855: LD_INT 250
54857: GREATEREQUAL
54858: AND
54859: IFFALSE 54872
// Connect ( j ) else
54861: LD_VAR 0 3
54865: PPUSH
54866: CALL 78590 0 1
54870: GO 54907
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54872: LD_VAR 0 3
54876: PPUSH
54877: CALL_OW 256
54881: PUSH
54882: LD_INT 250
54884: LESS
54885: PUSH
54886: LD_VAR 0 3
54890: PPUSH
54891: CALL_OW 312
54895: AND
54896: IFFALSE 54907
// ComUnlink ( j ) ;
54898: LD_VAR 0 3
54902: PPUSH
54903: CALL_OW 136
54907: GO 54831
54909: POP
54910: POP
// end ;
54911: GO 54769
54913: POP
54914: POP
// end ;
54915: LD_VAR 0 1
54919: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54920: LD_INT 0
54922: PPUSH
54923: PPUSH
54924: PPUSH
54925: PPUSH
54926: PPUSH
// if not mc_bases then
54927: LD_EXP 102
54931: NOT
54932: IFFALSE 54936
// exit ;
54934: GO 55381
// for i = 1 to mc_bases do
54936: LD_ADDR_VAR 0 2
54940: PUSH
54941: DOUBLE
54942: LD_INT 1
54944: DEC
54945: ST_TO_ADDR
54946: LD_EXP 102
54950: PUSH
54951: FOR_TO
54952: IFFALSE 55379
// begin if not mc_produce [ i ] then
54954: LD_EXP 123
54958: PUSH
54959: LD_VAR 0 2
54963: ARRAY
54964: NOT
54965: IFFALSE 54969
// continue ;
54967: GO 54951
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54969: LD_ADDR_VAR 0 5
54973: PUSH
54974: LD_EXP 102
54978: PUSH
54979: LD_VAR 0 2
54983: ARRAY
54984: PPUSH
54985: LD_INT 30
54987: PUSH
54988: LD_INT 3
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: PPUSH
54995: CALL_OW 72
54999: ST_TO_ADDR
// if not fac then
55000: LD_VAR 0 5
55004: NOT
55005: IFFALSE 55009
// continue ;
55007: GO 54951
// for j in fac do
55009: LD_ADDR_VAR 0 3
55013: PUSH
55014: LD_VAR 0 5
55018: PUSH
55019: FOR_IN
55020: IFFALSE 55375
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55022: LD_VAR 0 3
55026: PPUSH
55027: CALL_OW 461
55031: PUSH
55032: LD_INT 2
55034: NONEQUAL
55035: PUSH
55036: LD_VAR 0 3
55040: PPUSH
55041: LD_INT 15
55043: PPUSH
55044: CALL 78209 0 2
55048: PUSH
55049: LD_INT 4
55051: ARRAY
55052: OR
55053: IFFALSE 55057
// continue ;
55055: GO 55019
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55057: LD_VAR 0 3
55061: PPUSH
55062: LD_EXP 123
55066: PUSH
55067: LD_VAR 0 2
55071: ARRAY
55072: PUSH
55073: LD_INT 1
55075: ARRAY
55076: PUSH
55077: LD_INT 1
55079: ARRAY
55080: PPUSH
55081: LD_EXP 123
55085: PUSH
55086: LD_VAR 0 2
55090: ARRAY
55091: PUSH
55092: LD_INT 1
55094: ARRAY
55095: PUSH
55096: LD_INT 2
55098: ARRAY
55099: PPUSH
55100: LD_EXP 123
55104: PUSH
55105: LD_VAR 0 2
55109: ARRAY
55110: PUSH
55111: LD_INT 1
55113: ARRAY
55114: PUSH
55115: LD_INT 3
55117: ARRAY
55118: PPUSH
55119: LD_EXP 123
55123: PUSH
55124: LD_VAR 0 2
55128: ARRAY
55129: PUSH
55130: LD_INT 1
55132: ARRAY
55133: PUSH
55134: LD_INT 4
55136: ARRAY
55137: PPUSH
55138: CALL_OW 448
55142: PUSH
55143: LD_VAR 0 3
55147: PPUSH
55148: LD_EXP 123
55152: PUSH
55153: LD_VAR 0 2
55157: ARRAY
55158: PUSH
55159: LD_INT 1
55161: ARRAY
55162: PUSH
55163: LD_INT 1
55165: ARRAY
55166: PUSH
55167: LD_EXP 123
55171: PUSH
55172: LD_VAR 0 2
55176: ARRAY
55177: PUSH
55178: LD_INT 1
55180: ARRAY
55181: PUSH
55182: LD_INT 2
55184: ARRAY
55185: PUSH
55186: LD_EXP 123
55190: PUSH
55191: LD_VAR 0 2
55195: ARRAY
55196: PUSH
55197: LD_INT 1
55199: ARRAY
55200: PUSH
55201: LD_INT 3
55203: ARRAY
55204: PUSH
55205: LD_EXP 123
55209: PUSH
55210: LD_VAR 0 2
55214: ARRAY
55215: PUSH
55216: LD_INT 1
55218: ARRAY
55219: PUSH
55220: LD_INT 4
55222: ARRAY
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: LIST
55228: LIST
55229: PPUSH
55230: CALL 81985 0 2
55234: AND
55235: IFFALSE 55373
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55237: LD_VAR 0 3
55241: PPUSH
55242: LD_EXP 123
55246: PUSH
55247: LD_VAR 0 2
55251: ARRAY
55252: PUSH
55253: LD_INT 1
55255: ARRAY
55256: PUSH
55257: LD_INT 1
55259: ARRAY
55260: PPUSH
55261: LD_EXP 123
55265: PUSH
55266: LD_VAR 0 2
55270: ARRAY
55271: PUSH
55272: LD_INT 1
55274: ARRAY
55275: PUSH
55276: LD_INT 2
55278: ARRAY
55279: PPUSH
55280: LD_EXP 123
55284: PUSH
55285: LD_VAR 0 2
55289: ARRAY
55290: PUSH
55291: LD_INT 1
55293: ARRAY
55294: PUSH
55295: LD_INT 3
55297: ARRAY
55298: PPUSH
55299: LD_EXP 123
55303: PUSH
55304: LD_VAR 0 2
55308: ARRAY
55309: PUSH
55310: LD_INT 1
55312: ARRAY
55313: PUSH
55314: LD_INT 4
55316: ARRAY
55317: PPUSH
55318: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55322: LD_ADDR_VAR 0 4
55326: PUSH
55327: LD_EXP 123
55331: PUSH
55332: LD_VAR 0 2
55336: ARRAY
55337: PPUSH
55338: LD_INT 1
55340: PPUSH
55341: CALL_OW 3
55345: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55346: LD_ADDR_EXP 123
55350: PUSH
55351: LD_EXP 123
55355: PPUSH
55356: LD_VAR 0 2
55360: PPUSH
55361: LD_VAR 0 4
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
// break ;
55371: GO 55375
// end ; end ;
55373: GO 55019
55375: POP
55376: POP
// end ;
55377: GO 54951
55379: POP
55380: POP
// end ;
55381: LD_VAR 0 1
55385: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55386: LD_INT 0
55388: PPUSH
55389: PPUSH
55390: PPUSH
// if not mc_bases then
55391: LD_EXP 102
55395: NOT
55396: IFFALSE 55400
// exit ;
55398: GO 55489
// for i = 1 to mc_bases do
55400: LD_ADDR_VAR 0 2
55404: PUSH
55405: DOUBLE
55406: LD_INT 1
55408: DEC
55409: ST_TO_ADDR
55410: LD_EXP 102
55414: PUSH
55415: FOR_TO
55416: IFFALSE 55487
// begin if mc_attack [ i ] then
55418: LD_EXP 122
55422: PUSH
55423: LD_VAR 0 2
55427: ARRAY
55428: IFFALSE 55485
// begin tmp := mc_attack [ i ] [ 1 ] ;
55430: LD_ADDR_VAR 0 3
55434: PUSH
55435: LD_EXP 122
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: PUSH
55446: LD_INT 1
55448: ARRAY
55449: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55450: LD_ADDR_EXP 122
55454: PUSH
55455: LD_EXP 122
55459: PPUSH
55460: LD_VAR 0 2
55464: PPUSH
55465: EMPTY
55466: PPUSH
55467: CALL_OW 1
55471: ST_TO_ADDR
// Attack ( tmp ) ;
55472: LD_VAR 0 3
55476: PPUSH
55477: CALL 133782 0 1
// exit ;
55481: POP
55482: POP
55483: GO 55489
// end ; end ;
55485: GO 55415
55487: POP
55488: POP
// end ;
55489: LD_VAR 0 1
55493: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55494: LD_INT 0
55496: PPUSH
55497: PPUSH
55498: PPUSH
55499: PPUSH
55500: PPUSH
55501: PPUSH
55502: PPUSH
// if not mc_bases then
55503: LD_EXP 102
55507: NOT
55508: IFFALSE 55512
// exit ;
55510: GO 56369
// for i = 1 to mc_bases do
55512: LD_ADDR_VAR 0 2
55516: PUSH
55517: DOUBLE
55518: LD_INT 1
55520: DEC
55521: ST_TO_ADDR
55522: LD_EXP 102
55526: PUSH
55527: FOR_TO
55528: IFFALSE 56367
// begin if not mc_bases [ i ] then
55530: LD_EXP 102
55534: PUSH
55535: LD_VAR 0 2
55539: ARRAY
55540: NOT
55541: IFFALSE 55545
// continue ;
55543: GO 55527
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55545: LD_ADDR_VAR 0 7
55549: PUSH
55550: LD_EXP 102
55554: PUSH
55555: LD_VAR 0 2
55559: ARRAY
55560: PUSH
55561: LD_INT 1
55563: ARRAY
55564: PPUSH
55565: CALL 72068 0 1
55569: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55570: LD_ADDR_EXP 125
55574: PUSH
55575: LD_EXP 125
55579: PPUSH
55580: LD_VAR 0 2
55584: PPUSH
55585: LD_EXP 102
55589: PUSH
55590: LD_VAR 0 2
55594: ARRAY
55595: PUSH
55596: LD_INT 1
55598: ARRAY
55599: PPUSH
55600: CALL_OW 255
55604: PPUSH
55605: LD_EXP 127
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: PPUSH
55616: CALL 72033 0 2
55620: PPUSH
55621: CALL_OW 1
55625: ST_TO_ADDR
// if not mc_scan [ i ] then
55626: LD_EXP 125
55630: PUSH
55631: LD_VAR 0 2
55635: ARRAY
55636: NOT
55637: IFFALSE 55815
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55639: LD_ADDR_EXP 145
55643: PUSH
55644: LD_EXP 145
55648: PPUSH
55649: LD_VAR 0 2
55653: PPUSH
55654: LD_INT 0
55656: PPUSH
55657: CALL_OW 1
55661: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55662: LD_ADDR_VAR 0 4
55666: PUSH
55667: LD_EXP 102
55671: PUSH
55672: LD_VAR 0 2
55676: ARRAY
55677: PPUSH
55678: LD_INT 2
55680: PUSH
55681: LD_INT 25
55683: PUSH
55684: LD_INT 5
55686: PUSH
55687: EMPTY
55688: LIST
55689: LIST
55690: PUSH
55691: LD_INT 25
55693: PUSH
55694: LD_INT 8
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: PUSH
55701: LD_INT 25
55703: PUSH
55704: LD_INT 9
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: PUSH
55711: EMPTY
55712: LIST
55713: LIST
55714: LIST
55715: LIST
55716: PPUSH
55717: CALL_OW 72
55721: ST_TO_ADDR
// if not tmp then
55722: LD_VAR 0 4
55726: NOT
55727: IFFALSE 55731
// continue ;
55729: GO 55527
// for j in tmp do
55731: LD_ADDR_VAR 0 3
55735: PUSH
55736: LD_VAR 0 4
55740: PUSH
55741: FOR_IN
55742: IFFALSE 55813
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55744: LD_VAR 0 3
55748: PPUSH
55749: CALL_OW 310
55753: PPUSH
55754: CALL_OW 266
55758: PUSH
55759: LD_INT 5
55761: EQUAL
55762: PUSH
55763: LD_VAR 0 3
55767: PPUSH
55768: CALL_OW 257
55772: PUSH
55773: LD_INT 1
55775: EQUAL
55776: AND
55777: PUSH
55778: LD_VAR 0 3
55782: PPUSH
55783: CALL_OW 459
55787: NOT
55788: AND
55789: PUSH
55790: LD_VAR 0 7
55794: AND
55795: IFFALSE 55811
// ComChangeProfession ( j , class ) ;
55797: LD_VAR 0 3
55801: PPUSH
55802: LD_VAR 0 7
55806: PPUSH
55807: CALL_OW 123
55811: GO 55741
55813: POP
55814: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55815: LD_EXP 125
55819: PUSH
55820: LD_VAR 0 2
55824: ARRAY
55825: PUSH
55826: LD_EXP 145
55830: PUSH
55831: LD_VAR 0 2
55835: ARRAY
55836: NOT
55837: AND
55838: PUSH
55839: LD_EXP 124
55843: PUSH
55844: LD_VAR 0 2
55848: ARRAY
55849: NOT
55850: AND
55851: PUSH
55852: LD_EXP 102
55856: PUSH
55857: LD_VAR 0 2
55861: ARRAY
55862: PPUSH
55863: LD_INT 50
55865: PUSH
55866: EMPTY
55867: LIST
55868: PUSH
55869: LD_INT 2
55871: PUSH
55872: LD_INT 30
55874: PUSH
55875: LD_INT 32
55877: PUSH
55878: EMPTY
55879: LIST
55880: LIST
55881: PUSH
55882: LD_INT 30
55884: PUSH
55885: LD_INT 33
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PUSH
55892: LD_INT 30
55894: PUSH
55895: LD_INT 4
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PUSH
55902: LD_INT 30
55904: PUSH
55905: LD_INT 5
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: PUSH
55912: EMPTY
55913: LIST
55914: LIST
55915: LIST
55916: LIST
55917: LIST
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: PPUSH
55923: CALL_OW 72
55927: PUSH
55928: LD_INT 4
55930: LESS
55931: PUSH
55932: LD_EXP 102
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PPUSH
55943: LD_INT 3
55945: PUSH
55946: LD_INT 24
55948: PUSH
55949: LD_INT 1000
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: PUSH
55956: EMPTY
55957: LIST
55958: LIST
55959: PUSH
55960: LD_INT 2
55962: PUSH
55963: LD_INT 30
55965: PUSH
55966: LD_INT 0
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: PUSH
55973: LD_INT 30
55975: PUSH
55976: LD_INT 1
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: LIST
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: PPUSH
55992: CALL_OW 72
55996: OR
55997: AND
55998: IFFALSE 56249
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56000: LD_ADDR_EXP 145
56004: PUSH
56005: LD_EXP 145
56009: PPUSH
56010: LD_VAR 0 2
56014: PPUSH
56015: LD_INT 1
56017: PPUSH
56018: CALL_OW 1
56022: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56023: LD_ADDR_VAR 0 4
56027: PUSH
56028: LD_EXP 102
56032: PUSH
56033: LD_VAR 0 2
56037: ARRAY
56038: PPUSH
56039: LD_INT 2
56041: PUSH
56042: LD_INT 25
56044: PUSH
56045: LD_INT 1
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: LD_INT 25
56054: PUSH
56055: LD_INT 5
56057: PUSH
56058: EMPTY
56059: LIST
56060: LIST
56061: PUSH
56062: LD_INT 25
56064: PUSH
56065: LD_INT 8
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: PUSH
56072: LD_INT 25
56074: PUSH
56075: LD_INT 9
56077: PUSH
56078: EMPTY
56079: LIST
56080: LIST
56081: PUSH
56082: EMPTY
56083: LIST
56084: LIST
56085: LIST
56086: LIST
56087: LIST
56088: PPUSH
56089: CALL_OW 72
56093: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56094: LD_ADDR_VAR 0 4
56098: PUSH
56099: LD_VAR 0 4
56103: PUSH
56104: LD_VAR 0 4
56108: PPUSH
56109: LD_INT 18
56111: PPUSH
56112: CALL 105542 0 2
56116: DIFF
56117: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56118: LD_VAR 0 4
56122: NOT
56123: PUSH
56124: LD_EXP 102
56128: PUSH
56129: LD_VAR 0 2
56133: ARRAY
56134: PPUSH
56135: LD_INT 2
56137: PUSH
56138: LD_INT 30
56140: PUSH
56141: LD_INT 4
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: LD_INT 30
56150: PUSH
56151: LD_INT 5
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: PUSH
56158: EMPTY
56159: LIST
56160: LIST
56161: LIST
56162: PPUSH
56163: CALL_OW 72
56167: NOT
56168: AND
56169: IFFALSE 56231
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56171: LD_ADDR_VAR 0 4
56175: PUSH
56176: LD_EXP 102
56180: PUSH
56181: LD_VAR 0 2
56185: ARRAY
56186: PPUSH
56187: LD_INT 2
56189: PUSH
56190: LD_INT 25
56192: PUSH
56193: LD_INT 2
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: LD_INT 25
56202: PUSH
56203: LD_INT 3
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: PUSH
56210: LD_INT 25
56212: PUSH
56213: LD_INT 4
56215: PUSH
56216: EMPTY
56217: LIST
56218: LIST
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: LIST
56224: LIST
56225: PPUSH
56226: CALL_OW 72
56230: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56231: LD_VAR 0 2
56235: PPUSH
56236: LD_VAR 0 4
56240: PPUSH
56241: CALL 138491 0 2
// exit ;
56245: POP
56246: POP
56247: GO 56369
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56249: LD_EXP 125
56253: PUSH
56254: LD_VAR 0 2
56258: ARRAY
56259: PUSH
56260: LD_EXP 145
56264: PUSH
56265: LD_VAR 0 2
56269: ARRAY
56270: NOT
56271: AND
56272: PUSH
56273: LD_EXP 124
56277: PUSH
56278: LD_VAR 0 2
56282: ARRAY
56283: AND
56284: IFFALSE 56365
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56286: LD_ADDR_EXP 145
56290: PUSH
56291: LD_EXP 145
56295: PPUSH
56296: LD_VAR 0 2
56300: PPUSH
56301: LD_INT 1
56303: PPUSH
56304: CALL_OW 1
56308: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56309: LD_ADDR_VAR 0 4
56313: PUSH
56314: LD_EXP 124
56318: PUSH
56319: LD_VAR 0 2
56323: ARRAY
56324: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56325: LD_ADDR_EXP 124
56329: PUSH
56330: LD_EXP 124
56334: PPUSH
56335: LD_VAR 0 2
56339: PPUSH
56340: EMPTY
56341: PPUSH
56342: CALL_OW 1
56346: ST_TO_ADDR
// Defend ( i , tmp ) ;
56347: LD_VAR 0 2
56351: PPUSH
56352: LD_VAR 0 4
56356: PPUSH
56357: CALL 139087 0 2
// exit ;
56361: POP
56362: POP
56363: GO 56369
// end ; end ;
56365: GO 55527
56367: POP
56368: POP
// end ;
56369: LD_VAR 0 1
56373: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56374: LD_INT 0
56376: PPUSH
56377: PPUSH
56378: PPUSH
56379: PPUSH
56380: PPUSH
56381: PPUSH
56382: PPUSH
56383: PPUSH
56384: PPUSH
56385: PPUSH
56386: PPUSH
// if not mc_bases then
56387: LD_EXP 102
56391: NOT
56392: IFFALSE 56396
// exit ;
56394: GO 57483
// for i = 1 to mc_bases do
56396: LD_ADDR_VAR 0 2
56400: PUSH
56401: DOUBLE
56402: LD_INT 1
56404: DEC
56405: ST_TO_ADDR
56406: LD_EXP 102
56410: PUSH
56411: FOR_TO
56412: IFFALSE 57481
// begin tmp := mc_lab [ i ] ;
56414: LD_ADDR_VAR 0 6
56418: PUSH
56419: LD_EXP 135
56423: PUSH
56424: LD_VAR 0 2
56428: ARRAY
56429: ST_TO_ADDR
// if not tmp then
56430: LD_VAR 0 6
56434: NOT
56435: IFFALSE 56439
// continue ;
56437: GO 56411
// idle_lab := 0 ;
56439: LD_ADDR_VAR 0 11
56443: PUSH
56444: LD_INT 0
56446: ST_TO_ADDR
// for j in tmp do
56447: LD_ADDR_VAR 0 3
56451: PUSH
56452: LD_VAR 0 6
56456: PUSH
56457: FOR_IN
56458: IFFALSE 57477
// begin researching := false ;
56460: LD_ADDR_VAR 0 10
56464: PUSH
56465: LD_INT 0
56467: ST_TO_ADDR
// side := GetSide ( j ) ;
56468: LD_ADDR_VAR 0 4
56472: PUSH
56473: LD_VAR 0 3
56477: PPUSH
56478: CALL_OW 255
56482: ST_TO_ADDR
// if not mc_tech [ side ] then
56483: LD_EXP 129
56487: PUSH
56488: LD_VAR 0 4
56492: ARRAY
56493: NOT
56494: IFFALSE 56498
// continue ;
56496: GO 56457
// if BuildingStatus ( j ) = bs_idle then
56498: LD_VAR 0 3
56502: PPUSH
56503: CALL_OW 461
56507: PUSH
56508: LD_INT 2
56510: EQUAL
56511: IFFALSE 56699
// begin if idle_lab and UnitsInside ( j ) < 6 then
56513: LD_VAR 0 11
56517: PUSH
56518: LD_VAR 0 3
56522: PPUSH
56523: CALL_OW 313
56527: PUSH
56528: LD_INT 6
56530: LESS
56531: AND
56532: IFFALSE 56603
// begin tmp2 := UnitsInside ( idle_lab ) ;
56534: LD_ADDR_VAR 0 9
56538: PUSH
56539: LD_VAR 0 11
56543: PPUSH
56544: CALL_OW 313
56548: ST_TO_ADDR
// if tmp2 then
56549: LD_VAR 0 9
56553: IFFALSE 56595
// for x in tmp2 do
56555: LD_ADDR_VAR 0 7
56559: PUSH
56560: LD_VAR 0 9
56564: PUSH
56565: FOR_IN
56566: IFFALSE 56593
// begin ComExitBuilding ( x ) ;
56568: LD_VAR 0 7
56572: PPUSH
56573: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56577: LD_VAR 0 7
56581: PPUSH
56582: LD_VAR 0 3
56586: PPUSH
56587: CALL_OW 180
// end ;
56591: GO 56565
56593: POP
56594: POP
// idle_lab := 0 ;
56595: LD_ADDR_VAR 0 11
56599: PUSH
56600: LD_INT 0
56602: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56603: LD_ADDR_VAR 0 5
56607: PUSH
56608: LD_EXP 129
56612: PUSH
56613: LD_VAR 0 4
56617: ARRAY
56618: PUSH
56619: FOR_IN
56620: IFFALSE 56680
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56622: LD_VAR 0 3
56626: PPUSH
56627: LD_VAR 0 5
56631: PPUSH
56632: CALL_OW 430
56636: PUSH
56637: LD_VAR 0 4
56641: PPUSH
56642: LD_VAR 0 5
56646: PPUSH
56647: CALL 71138 0 2
56651: AND
56652: IFFALSE 56678
// begin researching := true ;
56654: LD_ADDR_VAR 0 10
56658: PUSH
56659: LD_INT 1
56661: ST_TO_ADDR
// ComResearch ( j , t ) ;
56662: LD_VAR 0 3
56666: PPUSH
56667: LD_VAR 0 5
56671: PPUSH
56672: CALL_OW 124
// break ;
56676: GO 56680
// end ;
56678: GO 56619
56680: POP
56681: POP
// if not researching then
56682: LD_VAR 0 10
56686: NOT
56687: IFFALSE 56699
// idle_lab := j ;
56689: LD_ADDR_VAR 0 11
56693: PUSH
56694: LD_VAR 0 3
56698: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56699: LD_VAR 0 3
56703: PPUSH
56704: CALL_OW 461
56708: PUSH
56709: LD_INT 10
56711: EQUAL
56712: IFFALSE 57300
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56714: LD_EXP 131
56718: PUSH
56719: LD_VAR 0 2
56723: ARRAY
56724: NOT
56725: PUSH
56726: LD_EXP 132
56730: PUSH
56731: LD_VAR 0 2
56735: ARRAY
56736: NOT
56737: AND
56738: PUSH
56739: LD_EXP 129
56743: PUSH
56744: LD_VAR 0 4
56748: ARRAY
56749: PUSH
56750: LD_INT 1
56752: GREATER
56753: AND
56754: IFFALSE 56885
// begin ComCancel ( j ) ;
56756: LD_VAR 0 3
56760: PPUSH
56761: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56765: LD_ADDR_EXP 129
56769: PUSH
56770: LD_EXP 129
56774: PPUSH
56775: LD_VAR 0 4
56779: PPUSH
56780: LD_EXP 129
56784: PUSH
56785: LD_VAR 0 4
56789: ARRAY
56790: PPUSH
56791: LD_EXP 129
56795: PUSH
56796: LD_VAR 0 4
56800: ARRAY
56801: PUSH
56802: LD_INT 1
56804: MINUS
56805: PPUSH
56806: LD_EXP 129
56810: PUSH
56811: LD_VAR 0 4
56815: ARRAY
56816: PPUSH
56817: LD_INT 0
56819: PPUSH
56820: CALL 74662 0 4
56824: PPUSH
56825: CALL_OW 1
56829: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56830: LD_ADDR_EXP 129
56834: PUSH
56835: LD_EXP 129
56839: PPUSH
56840: LD_VAR 0 4
56844: PPUSH
56845: LD_EXP 129
56849: PUSH
56850: LD_VAR 0 4
56854: ARRAY
56855: PPUSH
56856: LD_EXP 129
56860: PUSH
56861: LD_VAR 0 4
56865: ARRAY
56866: PPUSH
56867: LD_INT 1
56869: PPUSH
56870: LD_INT 0
56872: PPUSH
56873: CALL 74662 0 4
56877: PPUSH
56878: CALL_OW 1
56882: ST_TO_ADDR
// continue ;
56883: GO 56457
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56885: LD_EXP 131
56889: PUSH
56890: LD_VAR 0 2
56894: ARRAY
56895: PUSH
56896: LD_EXP 132
56900: PUSH
56901: LD_VAR 0 2
56905: ARRAY
56906: NOT
56907: AND
56908: IFFALSE 57035
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56910: LD_ADDR_EXP 132
56914: PUSH
56915: LD_EXP 132
56919: PPUSH
56920: LD_VAR 0 2
56924: PUSH
56925: LD_EXP 132
56929: PUSH
56930: LD_VAR 0 2
56934: ARRAY
56935: PUSH
56936: LD_INT 1
56938: PLUS
56939: PUSH
56940: EMPTY
56941: LIST
56942: LIST
56943: PPUSH
56944: LD_EXP 131
56948: PUSH
56949: LD_VAR 0 2
56953: ARRAY
56954: PUSH
56955: LD_INT 1
56957: ARRAY
56958: PPUSH
56959: CALL 75244 0 3
56963: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56964: LD_EXP 131
56968: PUSH
56969: LD_VAR 0 2
56973: ARRAY
56974: PUSH
56975: LD_INT 1
56977: ARRAY
56978: PPUSH
56979: LD_INT 112
56981: PPUSH
56982: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56986: LD_ADDR_VAR 0 9
56990: PUSH
56991: LD_EXP 131
56995: PUSH
56996: LD_VAR 0 2
57000: ARRAY
57001: PPUSH
57002: LD_INT 1
57004: PPUSH
57005: CALL_OW 3
57009: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57010: LD_ADDR_EXP 131
57014: PUSH
57015: LD_EXP 131
57019: PPUSH
57020: LD_VAR 0 2
57024: PPUSH
57025: LD_VAR 0 9
57029: PPUSH
57030: CALL_OW 1
57034: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57035: LD_EXP 131
57039: PUSH
57040: LD_VAR 0 2
57044: ARRAY
57045: PUSH
57046: LD_EXP 132
57050: PUSH
57051: LD_VAR 0 2
57055: ARRAY
57056: AND
57057: PUSH
57058: LD_EXP 132
57062: PUSH
57063: LD_VAR 0 2
57067: ARRAY
57068: PUSH
57069: LD_INT 1
57071: ARRAY
57072: PPUSH
57073: CALL_OW 310
57077: NOT
57078: AND
57079: PUSH
57080: LD_VAR 0 3
57084: PPUSH
57085: CALL_OW 313
57089: PUSH
57090: LD_INT 6
57092: EQUAL
57093: AND
57094: IFFALSE 57150
// begin tmp2 := UnitsInside ( j ) ;
57096: LD_ADDR_VAR 0 9
57100: PUSH
57101: LD_VAR 0 3
57105: PPUSH
57106: CALL_OW 313
57110: ST_TO_ADDR
// if tmp2 = 6 then
57111: LD_VAR 0 9
57115: PUSH
57116: LD_INT 6
57118: EQUAL
57119: IFFALSE 57150
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57121: LD_VAR 0 9
57125: PUSH
57126: LD_INT 1
57128: ARRAY
57129: PPUSH
57130: LD_INT 112
57132: PPUSH
57133: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57137: LD_VAR 0 9
57141: PUSH
57142: LD_INT 1
57144: ARRAY
57145: PPUSH
57146: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57150: LD_EXP 132
57154: PUSH
57155: LD_VAR 0 2
57159: ARRAY
57160: PUSH
57161: LD_EXP 132
57165: PUSH
57166: LD_VAR 0 2
57170: ARRAY
57171: PUSH
57172: LD_INT 1
57174: ARRAY
57175: PPUSH
57176: CALL_OW 314
57180: NOT
57181: AND
57182: PUSH
57183: LD_EXP 132
57187: PUSH
57188: LD_VAR 0 2
57192: ARRAY
57193: PUSH
57194: LD_INT 1
57196: ARRAY
57197: PPUSH
57198: CALL_OW 310
57202: NOT
57203: AND
57204: IFFALSE 57230
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57206: LD_EXP 132
57210: PUSH
57211: LD_VAR 0 2
57215: ARRAY
57216: PUSH
57217: LD_INT 1
57219: ARRAY
57220: PPUSH
57221: LD_VAR 0 3
57225: PPUSH
57226: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57230: LD_EXP 132
57234: PUSH
57235: LD_VAR 0 2
57239: ARRAY
57240: PUSH
57241: LD_INT 1
57243: ARRAY
57244: PPUSH
57245: CALL_OW 310
57249: PUSH
57250: LD_EXP 132
57254: PUSH
57255: LD_VAR 0 2
57259: ARRAY
57260: PUSH
57261: LD_INT 1
57263: ARRAY
57264: PPUSH
57265: CALL_OW 310
57269: PPUSH
57270: CALL_OW 461
57274: PUSH
57275: LD_INT 3
57277: NONEQUAL
57278: AND
57279: IFFALSE 57300
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57281: LD_EXP 132
57285: PUSH
57286: LD_VAR 0 2
57290: ARRAY
57291: PUSH
57292: LD_INT 1
57294: ARRAY
57295: PPUSH
57296: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57300: LD_VAR 0 3
57304: PPUSH
57305: CALL_OW 461
57309: PUSH
57310: LD_INT 6
57312: EQUAL
57313: PUSH
57314: LD_VAR 0 6
57318: PUSH
57319: LD_INT 1
57321: GREATER
57322: AND
57323: IFFALSE 57475
// begin sci := [ ] ;
57325: LD_ADDR_VAR 0 8
57329: PUSH
57330: EMPTY
57331: ST_TO_ADDR
// for x in ( tmp diff j ) do
57332: LD_ADDR_VAR 0 7
57336: PUSH
57337: LD_VAR 0 6
57341: PUSH
57342: LD_VAR 0 3
57346: DIFF
57347: PUSH
57348: FOR_IN
57349: IFFALSE 57401
// begin if sci = 6 then
57351: LD_VAR 0 8
57355: PUSH
57356: LD_INT 6
57358: EQUAL
57359: IFFALSE 57363
// break ;
57361: GO 57401
// if BuildingStatus ( x ) = bs_idle then
57363: LD_VAR 0 7
57367: PPUSH
57368: CALL_OW 461
57372: PUSH
57373: LD_INT 2
57375: EQUAL
57376: IFFALSE 57399
// sci := sci ^ UnitsInside ( x ) ;
57378: LD_ADDR_VAR 0 8
57382: PUSH
57383: LD_VAR 0 8
57387: PUSH
57388: LD_VAR 0 7
57392: PPUSH
57393: CALL_OW 313
57397: ADD
57398: ST_TO_ADDR
// end ;
57399: GO 57348
57401: POP
57402: POP
// if not sci then
57403: LD_VAR 0 8
57407: NOT
57408: IFFALSE 57412
// continue ;
57410: GO 56457
// for x in sci do
57412: LD_ADDR_VAR 0 7
57416: PUSH
57417: LD_VAR 0 8
57421: PUSH
57422: FOR_IN
57423: IFFALSE 57473
// if IsInUnit ( x ) and not HasTask ( x ) then
57425: LD_VAR 0 7
57429: PPUSH
57430: CALL_OW 310
57434: PUSH
57435: LD_VAR 0 7
57439: PPUSH
57440: CALL_OW 314
57444: NOT
57445: AND
57446: IFFALSE 57471
// begin ComExitBuilding ( x ) ;
57448: LD_VAR 0 7
57452: PPUSH
57453: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57457: LD_VAR 0 7
57461: PPUSH
57462: LD_VAR 0 3
57466: PPUSH
57467: CALL_OW 180
// end ;
57471: GO 57422
57473: POP
57474: POP
// end ; end ;
57475: GO 56457
57477: POP
57478: POP
// end ;
57479: GO 56411
57481: POP
57482: POP
// end ;
57483: LD_VAR 0 1
57487: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57488: LD_INT 0
57490: PPUSH
57491: PPUSH
// if not mc_bases then
57492: LD_EXP 102
57496: NOT
57497: IFFALSE 57501
// exit ;
57499: GO 57582
// for i = 1 to mc_bases do
57501: LD_ADDR_VAR 0 2
57505: PUSH
57506: DOUBLE
57507: LD_INT 1
57509: DEC
57510: ST_TO_ADDR
57511: LD_EXP 102
57515: PUSH
57516: FOR_TO
57517: IFFALSE 57580
// if mc_mines [ i ] and mc_miners [ i ] then
57519: LD_EXP 115
57523: PUSH
57524: LD_VAR 0 2
57528: ARRAY
57529: PUSH
57530: LD_EXP 116
57534: PUSH
57535: LD_VAR 0 2
57539: ARRAY
57540: AND
57541: IFFALSE 57578
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
57543: LD_EXP 116
57547: PUSH
57548: LD_VAR 0 2
57552: ARRAY
57553: PUSH
57554: LD_INT 1
57556: ARRAY
57557: PPUSH
57558: CALL_OW 255
57562: PPUSH
57563: LD_EXP 115
57567: PUSH
57568: LD_VAR 0 2
57572: ARRAY
57573: PPUSH
57574: CALL 72221 0 2
57578: GO 57516
57580: POP
57581: POP
// end ;
57582: LD_VAR 0 1
57586: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57587: LD_INT 0
57589: PPUSH
57590: PPUSH
57591: PPUSH
57592: PPUSH
57593: PPUSH
57594: PPUSH
57595: PPUSH
57596: PPUSH
// if not mc_bases or not mc_parking then
57597: LD_EXP 102
57601: NOT
57602: PUSH
57603: LD_EXP 126
57607: NOT
57608: OR
57609: IFFALSE 57613
// exit ;
57611: GO 58351
// for i = 1 to mc_bases do
57613: LD_ADDR_VAR 0 2
57617: PUSH
57618: DOUBLE
57619: LD_INT 1
57621: DEC
57622: ST_TO_ADDR
57623: LD_EXP 102
57627: PUSH
57628: FOR_TO
57629: IFFALSE 58349
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57631: LD_EXP 102
57635: PUSH
57636: LD_VAR 0 2
57640: ARRAY
57641: NOT
57642: PUSH
57643: LD_EXP 126
57647: PUSH
57648: LD_VAR 0 2
57652: ARRAY
57653: NOT
57654: OR
57655: IFFALSE 57659
// continue ;
57657: GO 57628
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57659: LD_ADDR_VAR 0 5
57663: PUSH
57664: LD_EXP 102
57668: PUSH
57669: LD_VAR 0 2
57673: ARRAY
57674: PUSH
57675: LD_INT 1
57677: ARRAY
57678: PPUSH
57679: CALL_OW 255
57683: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57684: LD_ADDR_VAR 0 6
57688: PUSH
57689: LD_EXP 102
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PPUSH
57700: LD_INT 30
57702: PUSH
57703: LD_INT 3
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PPUSH
57710: CALL_OW 72
57714: ST_TO_ADDR
// if not fac then
57715: LD_VAR 0 6
57719: NOT
57720: IFFALSE 57771
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57722: LD_ADDR_VAR 0 6
57726: PUSH
57727: LD_EXP 102
57731: PUSH
57732: LD_VAR 0 2
57736: ARRAY
57737: PPUSH
57738: LD_INT 2
57740: PUSH
57741: LD_INT 30
57743: PUSH
57744: LD_INT 0
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: LD_INT 30
57753: PUSH
57754: LD_INT 1
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: LIST
57765: PPUSH
57766: CALL_OW 72
57770: ST_TO_ADDR
// if not fac then
57771: LD_VAR 0 6
57775: NOT
57776: IFFALSE 57780
// continue ;
57778: GO 57628
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57780: LD_ADDR_VAR 0 7
57784: PUSH
57785: LD_EXP 126
57789: PUSH
57790: LD_VAR 0 2
57794: ARRAY
57795: PPUSH
57796: LD_INT 22
57798: PUSH
57799: LD_VAR 0 5
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: LD_INT 21
57810: PUSH
57811: LD_INT 2
57813: PUSH
57814: EMPTY
57815: LIST
57816: LIST
57817: PUSH
57818: LD_INT 3
57820: PUSH
57821: LD_INT 60
57823: PUSH
57824: EMPTY
57825: LIST
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: PUSH
57831: LD_INT 3
57833: PUSH
57834: LD_INT 24
57836: PUSH
57837: LD_INT 1000
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PUSH
57848: EMPTY
57849: LIST
57850: LIST
57851: LIST
57852: LIST
57853: PPUSH
57854: CALL_OW 70
57858: ST_TO_ADDR
// for j in fac do
57859: LD_ADDR_VAR 0 3
57863: PUSH
57864: LD_VAR 0 6
57868: PUSH
57869: FOR_IN
57870: IFFALSE 57965
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57872: LD_ADDR_VAR 0 7
57876: PUSH
57877: LD_VAR 0 7
57881: PUSH
57882: LD_INT 22
57884: PUSH
57885: LD_VAR 0 5
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: PUSH
57894: LD_INT 91
57896: PUSH
57897: LD_VAR 0 3
57901: PUSH
57902: LD_INT 15
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: LIST
57909: PUSH
57910: LD_INT 21
57912: PUSH
57913: LD_INT 2
57915: PUSH
57916: EMPTY
57917: LIST
57918: LIST
57919: PUSH
57920: LD_INT 3
57922: PUSH
57923: LD_INT 60
57925: PUSH
57926: EMPTY
57927: LIST
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: PUSH
57933: LD_INT 3
57935: PUSH
57936: LD_INT 24
57938: PUSH
57939: LD_INT 1000
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: LIST
57954: LIST
57955: LIST
57956: PPUSH
57957: CALL_OW 69
57961: UNION
57962: ST_TO_ADDR
57963: GO 57869
57965: POP
57966: POP
// if not vehs then
57967: LD_VAR 0 7
57971: NOT
57972: IFFALSE 57998
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57974: LD_ADDR_EXP 114
57978: PUSH
57979: LD_EXP 114
57983: PPUSH
57984: LD_VAR 0 2
57988: PPUSH
57989: EMPTY
57990: PPUSH
57991: CALL_OW 1
57995: ST_TO_ADDR
// continue ;
57996: GO 57628
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57998: LD_ADDR_VAR 0 8
58002: PUSH
58003: LD_EXP 102
58007: PUSH
58008: LD_VAR 0 2
58012: ARRAY
58013: PPUSH
58014: LD_INT 30
58016: PUSH
58017: LD_INT 3
58019: PUSH
58020: EMPTY
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
// if tmp then
58029: LD_VAR 0 8
58033: IFFALSE 58136
// begin for j in tmp do
58035: LD_ADDR_VAR 0 3
58039: PUSH
58040: LD_VAR 0 8
58044: PUSH
58045: FOR_IN
58046: IFFALSE 58134
// for k in UnitsInside ( j ) do
58048: LD_ADDR_VAR 0 4
58052: PUSH
58053: LD_VAR 0 3
58057: PPUSH
58058: CALL_OW 313
58062: PUSH
58063: FOR_IN
58064: IFFALSE 58130
// if k then
58066: LD_VAR 0 4
58070: IFFALSE 58128
// if not k in mc_repair_vehicle [ i ] then
58072: LD_VAR 0 4
58076: PUSH
58077: LD_EXP 114
58081: PUSH
58082: LD_VAR 0 2
58086: ARRAY
58087: IN
58088: NOT
58089: IFFALSE 58128
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58091: LD_ADDR_EXP 114
58095: PUSH
58096: LD_EXP 114
58100: PPUSH
58101: LD_VAR 0 2
58105: PPUSH
58106: LD_EXP 114
58110: PUSH
58111: LD_VAR 0 2
58115: ARRAY
58116: PUSH
58117: LD_VAR 0 4
58121: UNION
58122: PPUSH
58123: CALL_OW 1
58127: ST_TO_ADDR
58128: GO 58063
58130: POP
58131: POP
58132: GO 58045
58134: POP
58135: POP
// end ; if not mc_repair_vehicle [ i ] then
58136: LD_EXP 114
58140: PUSH
58141: LD_VAR 0 2
58145: ARRAY
58146: NOT
58147: IFFALSE 58151
// continue ;
58149: GO 57628
// for j in mc_repair_vehicle [ i ] do
58151: LD_ADDR_VAR 0 3
58155: PUSH
58156: LD_EXP 114
58160: PUSH
58161: LD_VAR 0 2
58165: ARRAY
58166: PUSH
58167: FOR_IN
58168: IFFALSE 58345
// begin if GetClass ( j ) <> 3 then
58170: LD_VAR 0 3
58174: PPUSH
58175: CALL_OW 257
58179: PUSH
58180: LD_INT 3
58182: NONEQUAL
58183: IFFALSE 58224
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58185: LD_ADDR_EXP 114
58189: PUSH
58190: LD_EXP 114
58194: PPUSH
58195: LD_VAR 0 2
58199: PPUSH
58200: LD_EXP 114
58204: PUSH
58205: LD_VAR 0 2
58209: ARRAY
58210: PUSH
58211: LD_VAR 0 3
58215: DIFF
58216: PPUSH
58217: CALL_OW 1
58221: ST_TO_ADDR
// continue ;
58222: GO 58167
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58224: LD_VAR 0 3
58228: PPUSH
58229: CALL_OW 311
58233: NOT
58234: PUSH
58235: LD_VAR 0 3
58239: PUSH
58240: LD_EXP 105
58244: PUSH
58245: LD_VAR 0 2
58249: ARRAY
58250: PUSH
58251: LD_INT 1
58253: ARRAY
58254: IN
58255: NOT
58256: AND
58257: PUSH
58258: LD_VAR 0 3
58262: PUSH
58263: LD_EXP 105
58267: PUSH
58268: LD_VAR 0 2
58272: ARRAY
58273: PUSH
58274: LD_INT 2
58276: ARRAY
58277: IN
58278: NOT
58279: AND
58280: IFFALSE 58343
// begin if IsInUnit ( j ) then
58282: LD_VAR 0 3
58286: PPUSH
58287: CALL_OW 310
58291: IFFALSE 58304
// ComExitBuilding ( j ) else
58293: LD_VAR 0 3
58297: PPUSH
58298: CALL_OW 122
58302: GO 58343
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58304: LD_VAR 0 3
58308: PPUSH
58309: LD_VAR 0 7
58313: PUSH
58314: LD_INT 1
58316: ARRAY
58317: PPUSH
58318: CALL 110038 0 2
58322: NOT
58323: IFFALSE 58343
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58325: LD_VAR 0 3
58329: PPUSH
58330: LD_VAR 0 7
58334: PUSH
58335: LD_INT 1
58337: ARRAY
58338: PPUSH
58339: CALL_OW 129
// end ; end ;
58343: GO 58167
58345: POP
58346: POP
// end ;
58347: GO 57628
58349: POP
58350: POP
// end ;
58351: LD_VAR 0 1
58355: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58356: LD_INT 0
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
58362: PPUSH
58363: PPUSH
58364: PPUSH
58365: PPUSH
58366: PPUSH
58367: PPUSH
58368: PPUSH
// if not mc_bases then
58369: LD_EXP 102
58373: NOT
58374: IFFALSE 58378
// exit ;
58376: GO 59180
// for i = 1 to mc_bases do
58378: LD_ADDR_VAR 0 2
58382: PUSH
58383: DOUBLE
58384: LD_INT 1
58386: DEC
58387: ST_TO_ADDR
58388: LD_EXP 102
58392: PUSH
58393: FOR_TO
58394: IFFALSE 59178
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58396: LD_EXP 130
58400: PUSH
58401: LD_VAR 0 2
58405: ARRAY
58406: NOT
58407: PUSH
58408: LD_EXP 105
58412: PUSH
58413: LD_VAR 0 2
58417: ARRAY
58418: PUSH
58419: LD_INT 1
58421: ARRAY
58422: OR
58423: PUSH
58424: LD_EXP 105
58428: PUSH
58429: LD_VAR 0 2
58433: ARRAY
58434: PUSH
58435: LD_INT 2
58437: ARRAY
58438: OR
58439: PUSH
58440: LD_EXP 128
58444: PUSH
58445: LD_VAR 0 2
58449: ARRAY
58450: PPUSH
58451: LD_INT 1
58453: PPUSH
58454: CALL_OW 325
58458: NOT
58459: OR
58460: PUSH
58461: LD_EXP 125
58465: PUSH
58466: LD_VAR 0 2
58470: ARRAY
58471: OR
58472: IFFALSE 58476
// continue ;
58474: GO 58393
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58476: LD_ADDR_VAR 0 8
58480: PUSH
58481: LD_EXP 102
58485: PUSH
58486: LD_VAR 0 2
58490: ARRAY
58491: PPUSH
58492: LD_INT 25
58494: PUSH
58495: LD_INT 4
58497: PUSH
58498: EMPTY
58499: LIST
58500: LIST
58501: PUSH
58502: LD_INT 50
58504: PUSH
58505: EMPTY
58506: LIST
58507: PUSH
58508: LD_INT 3
58510: PUSH
58511: LD_INT 60
58513: PUSH
58514: EMPTY
58515: LIST
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: PUSH
58521: EMPTY
58522: LIST
58523: LIST
58524: LIST
58525: PPUSH
58526: CALL_OW 72
58530: PUSH
58531: LD_EXP 106
58535: PUSH
58536: LD_VAR 0 2
58540: ARRAY
58541: DIFF
58542: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58543: LD_ADDR_VAR 0 9
58547: PUSH
58548: LD_EXP 102
58552: PUSH
58553: LD_VAR 0 2
58557: ARRAY
58558: PPUSH
58559: LD_INT 2
58561: PUSH
58562: LD_INT 30
58564: PUSH
58565: LD_INT 0
58567: PUSH
58568: EMPTY
58569: LIST
58570: LIST
58571: PUSH
58572: LD_INT 30
58574: PUSH
58575: LD_INT 1
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: LIST
58586: PPUSH
58587: CALL_OW 72
58591: ST_TO_ADDR
// if not tmp or not dep then
58592: LD_VAR 0 8
58596: NOT
58597: PUSH
58598: LD_VAR 0 9
58602: NOT
58603: OR
58604: IFFALSE 58608
// continue ;
58606: GO 58393
// side := GetSide ( tmp [ 1 ] ) ;
58608: LD_ADDR_VAR 0 11
58612: PUSH
58613: LD_VAR 0 8
58617: PUSH
58618: LD_INT 1
58620: ARRAY
58621: PPUSH
58622: CALL_OW 255
58626: ST_TO_ADDR
// dep := dep [ 1 ] ;
58627: LD_ADDR_VAR 0 9
58631: PUSH
58632: LD_VAR 0 9
58636: PUSH
58637: LD_INT 1
58639: ARRAY
58640: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58641: LD_ADDR_VAR 0 7
58645: PUSH
58646: LD_EXP 130
58650: PUSH
58651: LD_VAR 0 2
58655: ARRAY
58656: PPUSH
58657: LD_INT 22
58659: PUSH
58660: LD_INT 0
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: LD_INT 25
58669: PUSH
58670: LD_INT 12
58672: PUSH
58673: EMPTY
58674: LIST
58675: LIST
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: PPUSH
58681: CALL_OW 70
58685: PUSH
58686: LD_INT 22
58688: PUSH
58689: LD_INT 0
58691: PUSH
58692: EMPTY
58693: LIST
58694: LIST
58695: PUSH
58696: LD_INT 25
58698: PUSH
58699: LD_INT 12
58701: PUSH
58702: EMPTY
58703: LIST
58704: LIST
58705: PUSH
58706: LD_INT 91
58708: PUSH
58709: LD_VAR 0 9
58713: PUSH
58714: LD_INT 20
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: LIST
58721: PUSH
58722: EMPTY
58723: LIST
58724: LIST
58725: LIST
58726: PPUSH
58727: CALL_OW 69
58731: UNION
58732: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58733: LD_ADDR_VAR 0 10
58737: PUSH
58738: LD_EXP 130
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PPUSH
58749: LD_INT 81
58751: PUSH
58752: LD_VAR 0 11
58756: PUSH
58757: EMPTY
58758: LIST
58759: LIST
58760: PPUSH
58761: CALL_OW 70
58765: ST_TO_ADDR
// if not apes or danger_at_area then
58766: LD_VAR 0 7
58770: NOT
58771: PUSH
58772: LD_VAR 0 10
58776: OR
58777: IFFALSE 58827
// begin if mc_taming [ i ] then
58779: LD_EXP 133
58783: PUSH
58784: LD_VAR 0 2
58788: ARRAY
58789: IFFALSE 58825
// begin MC_Reset ( i , 121 ) ;
58791: LD_VAR 0 2
58795: PPUSH
58796: LD_INT 121
58798: PPUSH
58799: CALL 43743 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58803: LD_ADDR_EXP 133
58807: PUSH
58808: LD_EXP 133
58812: PPUSH
58813: LD_VAR 0 2
58817: PPUSH
58818: EMPTY
58819: PPUSH
58820: CALL_OW 1
58824: ST_TO_ADDR
// end ; continue ;
58825: GO 58393
// end ; for j in tmp do
58827: LD_ADDR_VAR 0 3
58831: PUSH
58832: LD_VAR 0 8
58836: PUSH
58837: FOR_IN
58838: IFFALSE 59174
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58840: LD_VAR 0 3
58844: PUSH
58845: LD_EXP 133
58849: PUSH
58850: LD_VAR 0 2
58854: ARRAY
58855: IN
58856: NOT
58857: PUSH
58858: LD_EXP 133
58862: PUSH
58863: LD_VAR 0 2
58867: ARRAY
58868: PUSH
58869: LD_INT 3
58871: LESS
58872: AND
58873: IFFALSE 58931
// begin SetTag ( j , 121 ) ;
58875: LD_VAR 0 3
58879: PPUSH
58880: LD_INT 121
58882: PPUSH
58883: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58887: LD_ADDR_EXP 133
58891: PUSH
58892: LD_EXP 133
58896: PPUSH
58897: LD_VAR 0 2
58901: PUSH
58902: LD_EXP 133
58906: PUSH
58907: LD_VAR 0 2
58911: ARRAY
58912: PUSH
58913: LD_INT 1
58915: PLUS
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: PPUSH
58921: LD_VAR 0 3
58925: PPUSH
58926: CALL 75244 0 3
58930: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58931: LD_VAR 0 3
58935: PUSH
58936: LD_EXP 133
58940: PUSH
58941: LD_VAR 0 2
58945: ARRAY
58946: IN
58947: IFFALSE 59172
// begin if GetClass ( j ) <> 4 then
58949: LD_VAR 0 3
58953: PPUSH
58954: CALL_OW 257
58958: PUSH
58959: LD_INT 4
58961: NONEQUAL
58962: IFFALSE 59015
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58964: LD_ADDR_EXP 133
58968: PUSH
58969: LD_EXP 133
58973: PPUSH
58974: LD_VAR 0 2
58978: PPUSH
58979: LD_EXP 133
58983: PUSH
58984: LD_VAR 0 2
58988: ARRAY
58989: PUSH
58990: LD_VAR 0 3
58994: DIFF
58995: PPUSH
58996: CALL_OW 1
59000: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59001: LD_VAR 0 3
59005: PPUSH
59006: LD_INT 0
59008: PPUSH
59009: CALL_OW 109
// continue ;
59013: GO 58837
// end ; if IsInUnit ( j ) then
59015: LD_VAR 0 3
59019: PPUSH
59020: CALL_OW 310
59024: IFFALSE 59035
// ComExitBuilding ( j ) ;
59026: LD_VAR 0 3
59030: PPUSH
59031: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59035: LD_ADDR_VAR 0 6
59039: PUSH
59040: LD_VAR 0 7
59044: PPUSH
59045: LD_VAR 0 3
59049: PPUSH
59050: CALL_OW 74
59054: ST_TO_ADDR
// if not ape then
59055: LD_VAR 0 6
59059: NOT
59060: IFFALSE 59064
// break ;
59062: GO 59174
// x := GetX ( ape ) ;
59064: LD_ADDR_VAR 0 4
59068: PUSH
59069: LD_VAR 0 6
59073: PPUSH
59074: CALL_OW 250
59078: ST_TO_ADDR
// y := GetY ( ape ) ;
59079: LD_ADDR_VAR 0 5
59083: PUSH
59084: LD_VAR 0 6
59088: PPUSH
59089: CALL_OW 251
59093: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59094: LD_VAR 0 4
59098: PPUSH
59099: LD_VAR 0 5
59103: PPUSH
59104: CALL_OW 488
59108: NOT
59109: PUSH
59110: LD_VAR 0 11
59114: PPUSH
59115: LD_VAR 0 4
59119: PPUSH
59120: LD_VAR 0 5
59124: PPUSH
59125: LD_INT 20
59127: PPUSH
59128: CALL 76508 0 4
59132: PUSH
59133: LD_INT 4
59135: ARRAY
59136: OR
59137: IFFALSE 59141
// break ;
59139: GO 59174
// if not HasTask ( j ) then
59141: LD_VAR 0 3
59145: PPUSH
59146: CALL_OW 314
59150: NOT
59151: IFFALSE 59172
// ComTameXY ( j , x , y ) ;
59153: LD_VAR 0 3
59157: PPUSH
59158: LD_VAR 0 4
59162: PPUSH
59163: LD_VAR 0 5
59167: PPUSH
59168: CALL_OW 131
// end ; end ;
59172: GO 58837
59174: POP
59175: POP
// end ;
59176: GO 58393
59178: POP
59179: POP
// end ;
59180: LD_VAR 0 1
59184: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59185: LD_INT 0
59187: PPUSH
59188: PPUSH
59189: PPUSH
59190: PPUSH
59191: PPUSH
59192: PPUSH
59193: PPUSH
59194: PPUSH
// if not mc_bases then
59195: LD_EXP 102
59199: NOT
59200: IFFALSE 59204
// exit ;
59202: GO 59830
// for i = 1 to mc_bases do
59204: LD_ADDR_VAR 0 2
59208: PUSH
59209: DOUBLE
59210: LD_INT 1
59212: DEC
59213: ST_TO_ADDR
59214: LD_EXP 102
59218: PUSH
59219: FOR_TO
59220: IFFALSE 59828
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59222: LD_EXP 131
59226: PUSH
59227: LD_VAR 0 2
59231: ARRAY
59232: NOT
59233: PUSH
59234: LD_EXP 131
59238: PUSH
59239: LD_VAR 0 2
59243: ARRAY
59244: PPUSH
59245: LD_INT 25
59247: PUSH
59248: LD_INT 12
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PPUSH
59255: CALL_OW 72
59259: NOT
59260: OR
59261: IFFALSE 59265
// continue ;
59263: GO 59219
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59265: LD_ADDR_VAR 0 5
59269: PUSH
59270: LD_EXP 131
59274: PUSH
59275: LD_VAR 0 2
59279: ARRAY
59280: PUSH
59281: LD_INT 1
59283: ARRAY
59284: PPUSH
59285: CALL_OW 255
59289: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59290: LD_VAR 0 5
59294: PPUSH
59295: LD_INT 2
59297: PPUSH
59298: CALL_OW 325
59302: IFFALSE 59555
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59304: LD_ADDR_VAR 0 4
59308: PUSH
59309: LD_EXP 131
59313: PUSH
59314: LD_VAR 0 2
59318: ARRAY
59319: PPUSH
59320: LD_INT 25
59322: PUSH
59323: LD_INT 16
59325: PUSH
59326: EMPTY
59327: LIST
59328: LIST
59329: PPUSH
59330: CALL_OW 72
59334: ST_TO_ADDR
// if tmp < 6 then
59335: LD_VAR 0 4
59339: PUSH
59340: LD_INT 6
59342: LESS
59343: IFFALSE 59555
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59345: LD_ADDR_VAR 0 6
59349: PUSH
59350: LD_EXP 102
59354: PUSH
59355: LD_VAR 0 2
59359: ARRAY
59360: PPUSH
59361: LD_INT 2
59363: PUSH
59364: LD_INT 30
59366: PUSH
59367: LD_INT 0
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PUSH
59374: LD_INT 30
59376: PUSH
59377: LD_INT 1
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: LIST
59388: PPUSH
59389: CALL_OW 72
59393: ST_TO_ADDR
// if depot then
59394: LD_VAR 0 6
59398: IFFALSE 59555
// begin selected := 0 ;
59400: LD_ADDR_VAR 0 7
59404: PUSH
59405: LD_INT 0
59407: ST_TO_ADDR
// for j in depot do
59408: LD_ADDR_VAR 0 3
59412: PUSH
59413: LD_VAR 0 6
59417: PUSH
59418: FOR_IN
59419: IFFALSE 59450
// begin if UnitsInside ( j ) < 6 then
59421: LD_VAR 0 3
59425: PPUSH
59426: CALL_OW 313
59430: PUSH
59431: LD_INT 6
59433: LESS
59434: IFFALSE 59448
// begin selected := j ;
59436: LD_ADDR_VAR 0 7
59440: PUSH
59441: LD_VAR 0 3
59445: ST_TO_ADDR
// break ;
59446: GO 59450
// end ; end ;
59448: GO 59418
59450: POP
59451: POP
// if selected then
59452: LD_VAR 0 7
59456: IFFALSE 59555
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59458: LD_ADDR_VAR 0 3
59462: PUSH
59463: LD_EXP 131
59467: PUSH
59468: LD_VAR 0 2
59472: ARRAY
59473: PPUSH
59474: LD_INT 25
59476: PUSH
59477: LD_INT 12
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: PPUSH
59484: CALL_OW 72
59488: PUSH
59489: FOR_IN
59490: IFFALSE 59553
// if not HasTask ( j ) then
59492: LD_VAR 0 3
59496: PPUSH
59497: CALL_OW 314
59501: NOT
59502: IFFALSE 59551
// begin if not IsInUnit ( j ) then
59504: LD_VAR 0 3
59508: PPUSH
59509: CALL_OW 310
59513: NOT
59514: IFFALSE 59530
// ComEnterUnit ( j , selected ) ;
59516: LD_VAR 0 3
59520: PPUSH
59521: LD_VAR 0 7
59525: PPUSH
59526: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
59530: LD_VAR 0 3
59534: PPUSH
59535: LD_INT 16
59537: PPUSH
59538: CALL_OW 183
// AddComExitBuilding ( j ) ;
59542: LD_VAR 0 3
59546: PPUSH
59547: CALL_OW 182
// end ;
59551: GO 59489
59553: POP
59554: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
59555: LD_VAR 0 5
59559: PPUSH
59560: LD_INT 11
59562: PPUSH
59563: CALL_OW 325
59567: IFFALSE 59826
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59569: LD_ADDR_VAR 0 4
59573: PUSH
59574: LD_EXP 131
59578: PUSH
59579: LD_VAR 0 2
59583: ARRAY
59584: PPUSH
59585: LD_INT 25
59587: PUSH
59588: LD_INT 16
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: PPUSH
59595: CALL_OW 72
59599: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59600: LD_VAR 0 4
59604: PUSH
59605: LD_INT 6
59607: GREATEREQUAL
59608: PUSH
59609: LD_VAR 0 5
59613: PPUSH
59614: LD_INT 2
59616: PPUSH
59617: CALL_OW 325
59621: NOT
59622: OR
59623: IFFALSE 59826
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59625: LD_ADDR_VAR 0 8
59629: PUSH
59630: LD_EXP 102
59634: PUSH
59635: LD_VAR 0 2
59639: ARRAY
59640: PPUSH
59641: LD_INT 2
59643: PUSH
59644: LD_INT 30
59646: PUSH
59647: LD_INT 4
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: LD_INT 30
59656: PUSH
59657: LD_INT 5
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: LIST
59668: PPUSH
59669: CALL_OW 72
59673: ST_TO_ADDR
// if barracks then
59674: LD_VAR 0 8
59678: IFFALSE 59826
// begin selected := 0 ;
59680: LD_ADDR_VAR 0 7
59684: PUSH
59685: LD_INT 0
59687: ST_TO_ADDR
// for j in barracks do
59688: LD_ADDR_VAR 0 3
59692: PUSH
59693: LD_VAR 0 8
59697: PUSH
59698: FOR_IN
59699: IFFALSE 59730
// begin if UnitsInside ( j ) < 6 then
59701: LD_VAR 0 3
59705: PPUSH
59706: CALL_OW 313
59710: PUSH
59711: LD_INT 6
59713: LESS
59714: IFFALSE 59728
// begin selected := j ;
59716: LD_ADDR_VAR 0 7
59720: PUSH
59721: LD_VAR 0 3
59725: ST_TO_ADDR
// break ;
59726: GO 59730
// end ; end ;
59728: GO 59698
59730: POP
59731: POP
// if selected then
59732: LD_VAR 0 7
59736: IFFALSE 59826
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59738: LD_ADDR_VAR 0 3
59742: PUSH
59743: LD_EXP 131
59747: PUSH
59748: LD_VAR 0 2
59752: ARRAY
59753: PPUSH
59754: LD_INT 25
59756: PUSH
59757: LD_INT 12
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: PPUSH
59764: CALL_OW 72
59768: PUSH
59769: FOR_IN
59770: IFFALSE 59824
// if not IsInUnit ( j ) and not HasTask ( j ) then
59772: LD_VAR 0 3
59776: PPUSH
59777: CALL_OW 310
59781: NOT
59782: PUSH
59783: LD_VAR 0 3
59787: PPUSH
59788: CALL_OW 314
59792: NOT
59793: AND
59794: IFFALSE 59822
// begin ComEnterUnit ( j , selected ) ;
59796: LD_VAR 0 3
59800: PPUSH
59801: LD_VAR 0 7
59805: PPUSH
59806: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59810: LD_VAR 0 3
59814: PPUSH
59815: LD_INT 15
59817: PPUSH
59818: CALL_OW 183
// end ;
59822: GO 59769
59824: POP
59825: POP
// end ; end ; end ; end ; end ;
59826: GO 59219
59828: POP
59829: POP
// end ;
59830: LD_VAR 0 1
59834: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59835: LD_INT 0
59837: PPUSH
59838: PPUSH
59839: PPUSH
59840: PPUSH
// if not mc_bases then
59841: LD_EXP 102
59845: NOT
59846: IFFALSE 59850
// exit ;
59848: GO 60028
// for i = 1 to mc_bases do
59850: LD_ADDR_VAR 0 2
59854: PUSH
59855: DOUBLE
59856: LD_INT 1
59858: DEC
59859: ST_TO_ADDR
59860: LD_EXP 102
59864: PUSH
59865: FOR_TO
59866: IFFALSE 60026
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59868: LD_ADDR_VAR 0 4
59872: PUSH
59873: LD_EXP 102
59877: PUSH
59878: LD_VAR 0 2
59882: ARRAY
59883: PPUSH
59884: LD_INT 25
59886: PUSH
59887: LD_INT 9
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: PPUSH
59894: CALL_OW 72
59898: ST_TO_ADDR
// if not tmp then
59899: LD_VAR 0 4
59903: NOT
59904: IFFALSE 59908
// continue ;
59906: GO 59865
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59908: LD_EXP 128
59912: PUSH
59913: LD_VAR 0 2
59917: ARRAY
59918: PPUSH
59919: LD_INT 29
59921: PPUSH
59922: CALL_OW 325
59926: NOT
59927: PUSH
59928: LD_EXP 128
59932: PUSH
59933: LD_VAR 0 2
59937: ARRAY
59938: PPUSH
59939: LD_INT 28
59941: PPUSH
59942: CALL_OW 325
59946: NOT
59947: AND
59948: IFFALSE 59952
// continue ;
59950: GO 59865
// for j in tmp do
59952: LD_ADDR_VAR 0 3
59956: PUSH
59957: LD_VAR 0 4
59961: PUSH
59962: FOR_IN
59963: IFFALSE 60022
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59965: LD_VAR 0 3
59969: PUSH
59970: LD_EXP 105
59974: PUSH
59975: LD_VAR 0 2
59979: ARRAY
59980: PUSH
59981: LD_INT 1
59983: ARRAY
59984: IN
59985: NOT
59986: PUSH
59987: LD_VAR 0 3
59991: PUSH
59992: LD_EXP 105
59996: PUSH
59997: LD_VAR 0 2
60001: ARRAY
60002: PUSH
60003: LD_INT 2
60005: ARRAY
60006: IN
60007: NOT
60008: AND
60009: IFFALSE 60020
// ComSpaceTimeShoot ( j ) ;
60011: LD_VAR 0 3
60015: PPUSH
60016: CALL 71229 0 1
60020: GO 59962
60022: POP
60023: POP
// end ;
60024: GO 59865
60026: POP
60027: POP
// end ;
60028: LD_VAR 0 1
60032: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60033: LD_INT 0
60035: PPUSH
60036: PPUSH
60037: PPUSH
60038: PPUSH
60039: PPUSH
60040: PPUSH
60041: PPUSH
60042: PPUSH
60043: PPUSH
// if not mc_bases then
60044: LD_EXP 102
60048: NOT
60049: IFFALSE 60053
// exit ;
60051: GO 60675
// for i = 1 to mc_bases do
60053: LD_ADDR_VAR 0 2
60057: PUSH
60058: DOUBLE
60059: LD_INT 1
60061: DEC
60062: ST_TO_ADDR
60063: LD_EXP 102
60067: PUSH
60068: FOR_TO
60069: IFFALSE 60673
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60071: LD_EXP 137
60075: PUSH
60076: LD_VAR 0 2
60080: ARRAY
60081: NOT
60082: PUSH
60083: LD_INT 38
60085: PPUSH
60086: LD_EXP 128
60090: PUSH
60091: LD_VAR 0 2
60095: ARRAY
60096: PPUSH
60097: CALL_OW 321
60101: PUSH
60102: LD_INT 2
60104: NONEQUAL
60105: OR
60106: IFFALSE 60110
// continue ;
60108: GO 60068
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60110: LD_ADDR_VAR 0 8
60114: PUSH
60115: LD_EXP 102
60119: PUSH
60120: LD_VAR 0 2
60124: ARRAY
60125: PPUSH
60126: LD_INT 30
60128: PUSH
60129: LD_INT 34
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PPUSH
60136: CALL_OW 72
60140: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60141: LD_ADDR_VAR 0 9
60145: PUSH
60146: LD_EXP 102
60150: PUSH
60151: LD_VAR 0 2
60155: ARRAY
60156: PPUSH
60157: LD_INT 25
60159: PUSH
60160: LD_INT 4
60162: PUSH
60163: EMPTY
60164: LIST
60165: LIST
60166: PPUSH
60167: CALL_OW 72
60171: PPUSH
60172: LD_INT 0
60174: PPUSH
60175: CALL 105542 0 2
60179: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60180: LD_VAR 0 9
60184: NOT
60185: PUSH
60186: LD_VAR 0 8
60190: NOT
60191: OR
60192: PUSH
60193: LD_EXP 102
60197: PUSH
60198: LD_VAR 0 2
60202: ARRAY
60203: PPUSH
60204: LD_INT 124
60206: PPUSH
60207: CALL 105542 0 2
60211: OR
60212: IFFALSE 60216
// continue ;
60214: GO 60068
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60216: LD_EXP 138
60220: PUSH
60221: LD_VAR 0 2
60225: ARRAY
60226: PUSH
60227: LD_EXP 137
60231: PUSH
60232: LD_VAR 0 2
60236: ARRAY
60237: LESS
60238: PUSH
60239: LD_EXP 138
60243: PUSH
60244: LD_VAR 0 2
60248: ARRAY
60249: PUSH
60250: LD_VAR 0 8
60254: LESS
60255: AND
60256: IFFALSE 60671
// begin tmp := sci [ 1 ] ;
60258: LD_ADDR_VAR 0 7
60262: PUSH
60263: LD_VAR 0 9
60267: PUSH
60268: LD_INT 1
60270: ARRAY
60271: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60272: LD_VAR 0 7
60276: PPUSH
60277: LD_INT 124
60279: PPUSH
60280: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60284: LD_ADDR_VAR 0 3
60288: PUSH
60289: DOUBLE
60290: LD_EXP 137
60294: PUSH
60295: LD_VAR 0 2
60299: ARRAY
60300: INC
60301: ST_TO_ADDR
60302: LD_EXP 137
60306: PUSH
60307: LD_VAR 0 2
60311: ARRAY
60312: PUSH
60313: FOR_DOWNTO
60314: IFFALSE 60657
// begin if IsInUnit ( tmp ) then
60316: LD_VAR 0 7
60320: PPUSH
60321: CALL_OW 310
60325: IFFALSE 60336
// ComExitBuilding ( tmp ) ;
60327: LD_VAR 0 7
60331: PPUSH
60332: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60336: LD_INT 35
60338: PPUSH
60339: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60343: LD_VAR 0 7
60347: PPUSH
60348: CALL_OW 310
60352: NOT
60353: PUSH
60354: LD_VAR 0 7
60358: PPUSH
60359: CALL_OW 314
60363: NOT
60364: AND
60365: IFFALSE 60336
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60367: LD_ADDR_VAR 0 6
60371: PUSH
60372: LD_VAR 0 7
60376: PPUSH
60377: CALL_OW 250
60381: PUSH
60382: LD_VAR 0 7
60386: PPUSH
60387: CALL_OW 251
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60396: LD_INT 35
60398: PPUSH
60399: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60403: LD_ADDR_VAR 0 4
60407: PUSH
60408: LD_EXP 137
60412: PUSH
60413: LD_VAR 0 2
60417: ARRAY
60418: PUSH
60419: LD_VAR 0 3
60423: ARRAY
60424: PUSH
60425: LD_INT 1
60427: ARRAY
60428: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60429: LD_ADDR_VAR 0 5
60433: PUSH
60434: LD_EXP 137
60438: PUSH
60439: LD_VAR 0 2
60443: ARRAY
60444: PUSH
60445: LD_VAR 0 3
60449: ARRAY
60450: PUSH
60451: LD_INT 2
60453: ARRAY
60454: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60455: LD_VAR 0 7
60459: PPUSH
60460: LD_INT 10
60462: PPUSH
60463: CALL 78209 0 2
60467: PUSH
60468: LD_INT 4
60470: ARRAY
60471: IFFALSE 60509
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60473: LD_VAR 0 7
60477: PPUSH
60478: LD_VAR 0 6
60482: PUSH
60483: LD_INT 1
60485: ARRAY
60486: PPUSH
60487: LD_VAR 0 6
60491: PUSH
60492: LD_INT 2
60494: ARRAY
60495: PPUSH
60496: CALL_OW 111
// wait ( 0 0$10 ) ;
60500: LD_INT 350
60502: PPUSH
60503: CALL_OW 67
// end else
60507: GO 60535
// begin ComMoveXY ( tmp , x , y ) ;
60509: LD_VAR 0 7
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: LD_VAR 0 5
60523: PPUSH
60524: CALL_OW 111
// wait ( 0 0$3 ) ;
60528: LD_INT 105
60530: PPUSH
60531: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
60535: LD_VAR 0 7
60539: PPUSH
60540: LD_VAR 0 4
60544: PPUSH
60545: LD_VAR 0 5
60549: PPUSH
60550: CALL_OW 307
60554: IFFALSE 60396
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
60556: LD_VAR 0 7
60560: PPUSH
60561: LD_VAR 0 4
60565: PPUSH
60566: LD_VAR 0 5
60570: PPUSH
60571: LD_VAR 0 8
60575: PUSH
60576: LD_VAR 0 3
60580: ARRAY
60581: PPUSH
60582: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60586: LD_INT 35
60588: PPUSH
60589: CALL_OW 67
// until not HasTask ( tmp ) ;
60593: LD_VAR 0 7
60597: PPUSH
60598: CALL_OW 314
60602: NOT
60603: IFFALSE 60586
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60605: LD_ADDR_EXP 138
60609: PUSH
60610: LD_EXP 138
60614: PPUSH
60615: LD_VAR 0 2
60619: PUSH
60620: LD_EXP 138
60624: PUSH
60625: LD_VAR 0 2
60629: ARRAY
60630: PUSH
60631: LD_INT 1
60633: PLUS
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PPUSH
60639: LD_VAR 0 8
60643: PUSH
60644: LD_VAR 0 3
60648: ARRAY
60649: PPUSH
60650: CALL 75244 0 3
60654: ST_TO_ADDR
// end ;
60655: GO 60313
60657: POP
60658: POP
// MC_Reset ( i , 124 ) ;
60659: LD_VAR 0 2
60663: PPUSH
60664: LD_INT 124
60666: PPUSH
60667: CALL 43743 0 2
// end ; end ;
60671: GO 60068
60673: POP
60674: POP
// end ;
60675: LD_VAR 0 1
60679: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60680: LD_INT 0
60682: PPUSH
60683: PPUSH
60684: PPUSH
// if not mc_bases then
60685: LD_EXP 102
60689: NOT
60690: IFFALSE 60694
// exit ;
60692: GO 61300
// for i = 1 to mc_bases do
60694: LD_ADDR_VAR 0 2
60698: PUSH
60699: DOUBLE
60700: LD_INT 1
60702: DEC
60703: ST_TO_ADDR
60704: LD_EXP 102
60708: PUSH
60709: FOR_TO
60710: IFFALSE 61298
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60712: LD_ADDR_VAR 0 3
60716: PUSH
60717: LD_EXP 102
60721: PUSH
60722: LD_VAR 0 2
60726: ARRAY
60727: PPUSH
60728: LD_INT 25
60730: PUSH
60731: LD_INT 4
60733: PUSH
60734: EMPTY
60735: LIST
60736: LIST
60737: PPUSH
60738: CALL_OW 72
60742: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60743: LD_VAR 0 3
60747: NOT
60748: PUSH
60749: LD_EXP 139
60753: PUSH
60754: LD_VAR 0 2
60758: ARRAY
60759: NOT
60760: OR
60761: PUSH
60762: LD_EXP 102
60766: PUSH
60767: LD_VAR 0 2
60771: ARRAY
60772: PPUSH
60773: LD_INT 2
60775: PUSH
60776: LD_INT 30
60778: PUSH
60779: LD_INT 0
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: LD_INT 30
60788: PUSH
60789: LD_INT 1
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: LIST
60800: PPUSH
60801: CALL_OW 72
60805: NOT
60806: OR
60807: IFFALSE 60857
// begin if mc_deposits_finder [ i ] then
60809: LD_EXP 140
60813: PUSH
60814: LD_VAR 0 2
60818: ARRAY
60819: IFFALSE 60855
// begin MC_Reset ( i , 125 ) ;
60821: LD_VAR 0 2
60825: PPUSH
60826: LD_INT 125
60828: PPUSH
60829: CALL 43743 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60833: LD_ADDR_EXP 140
60837: PUSH
60838: LD_EXP 140
60842: PPUSH
60843: LD_VAR 0 2
60847: PPUSH
60848: EMPTY
60849: PPUSH
60850: CALL_OW 1
60854: ST_TO_ADDR
// end ; continue ;
60855: GO 60709
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60857: LD_EXP 139
60861: PUSH
60862: LD_VAR 0 2
60866: ARRAY
60867: PUSH
60868: LD_INT 1
60870: ARRAY
60871: PUSH
60872: LD_INT 3
60874: ARRAY
60875: PUSH
60876: LD_INT 1
60878: EQUAL
60879: PUSH
60880: LD_INT 20
60882: PPUSH
60883: LD_EXP 128
60887: PUSH
60888: LD_VAR 0 2
60892: ARRAY
60893: PPUSH
60894: CALL_OW 321
60898: PUSH
60899: LD_INT 2
60901: NONEQUAL
60902: AND
60903: IFFALSE 60953
// begin if mc_deposits_finder [ i ] then
60905: LD_EXP 140
60909: PUSH
60910: LD_VAR 0 2
60914: ARRAY
60915: IFFALSE 60951
// begin MC_Reset ( i , 125 ) ;
60917: LD_VAR 0 2
60921: PPUSH
60922: LD_INT 125
60924: PPUSH
60925: CALL 43743 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60929: LD_ADDR_EXP 140
60933: PUSH
60934: LD_EXP 140
60938: PPUSH
60939: LD_VAR 0 2
60943: PPUSH
60944: EMPTY
60945: PPUSH
60946: CALL_OW 1
60950: ST_TO_ADDR
// end ; continue ;
60951: GO 60709
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60953: LD_EXP 139
60957: PUSH
60958: LD_VAR 0 2
60962: ARRAY
60963: PUSH
60964: LD_INT 1
60966: ARRAY
60967: PUSH
60968: LD_INT 1
60970: ARRAY
60971: PPUSH
60972: LD_EXP 139
60976: PUSH
60977: LD_VAR 0 2
60981: ARRAY
60982: PUSH
60983: LD_INT 1
60985: ARRAY
60986: PUSH
60987: LD_INT 2
60989: ARRAY
60990: PPUSH
60991: LD_EXP 128
60995: PUSH
60996: LD_VAR 0 2
61000: ARRAY
61001: PPUSH
61002: CALL_OW 440
61006: IFFALSE 61049
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61008: LD_ADDR_EXP 139
61012: PUSH
61013: LD_EXP 139
61017: PPUSH
61018: LD_VAR 0 2
61022: PPUSH
61023: LD_EXP 139
61027: PUSH
61028: LD_VAR 0 2
61032: ARRAY
61033: PPUSH
61034: LD_INT 1
61036: PPUSH
61037: CALL_OW 3
61041: PPUSH
61042: CALL_OW 1
61046: ST_TO_ADDR
61047: GO 61296
// begin if not mc_deposits_finder [ i ] then
61049: LD_EXP 140
61053: PUSH
61054: LD_VAR 0 2
61058: ARRAY
61059: NOT
61060: IFFALSE 61112
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61062: LD_ADDR_EXP 140
61066: PUSH
61067: LD_EXP 140
61071: PPUSH
61072: LD_VAR 0 2
61076: PPUSH
61077: LD_VAR 0 3
61081: PUSH
61082: LD_INT 1
61084: ARRAY
61085: PUSH
61086: EMPTY
61087: LIST
61088: PPUSH
61089: CALL_OW 1
61093: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61094: LD_VAR 0 3
61098: PUSH
61099: LD_INT 1
61101: ARRAY
61102: PPUSH
61103: LD_INT 125
61105: PPUSH
61106: CALL_OW 109
// end else
61110: GO 61296
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61112: LD_EXP 140
61116: PUSH
61117: LD_VAR 0 2
61121: ARRAY
61122: PUSH
61123: LD_INT 1
61125: ARRAY
61126: PPUSH
61127: CALL_OW 310
61131: IFFALSE 61154
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61133: LD_EXP 140
61137: PUSH
61138: LD_VAR 0 2
61142: ARRAY
61143: PUSH
61144: LD_INT 1
61146: ARRAY
61147: PPUSH
61148: CALL_OW 122
61152: GO 61296
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61154: LD_EXP 140
61158: PUSH
61159: LD_VAR 0 2
61163: ARRAY
61164: PUSH
61165: LD_INT 1
61167: ARRAY
61168: PPUSH
61169: CALL_OW 314
61173: NOT
61174: PUSH
61175: LD_EXP 140
61179: PUSH
61180: LD_VAR 0 2
61184: ARRAY
61185: PUSH
61186: LD_INT 1
61188: ARRAY
61189: PPUSH
61190: LD_EXP 139
61194: PUSH
61195: LD_VAR 0 2
61199: ARRAY
61200: PUSH
61201: LD_INT 1
61203: ARRAY
61204: PUSH
61205: LD_INT 1
61207: ARRAY
61208: PPUSH
61209: LD_EXP 139
61213: PUSH
61214: LD_VAR 0 2
61218: ARRAY
61219: PUSH
61220: LD_INT 1
61222: ARRAY
61223: PUSH
61224: LD_INT 2
61226: ARRAY
61227: PPUSH
61228: CALL_OW 297
61232: PUSH
61233: LD_INT 6
61235: GREATER
61236: AND
61237: IFFALSE 61296
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61239: LD_EXP 140
61243: PUSH
61244: LD_VAR 0 2
61248: ARRAY
61249: PUSH
61250: LD_INT 1
61252: ARRAY
61253: PPUSH
61254: LD_EXP 139
61258: PUSH
61259: LD_VAR 0 2
61263: ARRAY
61264: PUSH
61265: LD_INT 1
61267: ARRAY
61268: PUSH
61269: LD_INT 1
61271: ARRAY
61272: PPUSH
61273: LD_EXP 139
61277: PUSH
61278: LD_VAR 0 2
61282: ARRAY
61283: PUSH
61284: LD_INT 1
61286: ARRAY
61287: PUSH
61288: LD_INT 2
61290: ARRAY
61291: PPUSH
61292: CALL_OW 111
// end ; end ; end ;
61296: GO 60709
61298: POP
61299: POP
// end ;
61300: LD_VAR 0 1
61304: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61305: LD_INT 0
61307: PPUSH
61308: PPUSH
61309: PPUSH
61310: PPUSH
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
// if not mc_bases then
61318: LD_EXP 102
61322: NOT
61323: IFFALSE 61327
// exit ;
61325: GO 62267
// for i = 1 to mc_bases do
61327: LD_ADDR_VAR 0 2
61331: PUSH
61332: DOUBLE
61333: LD_INT 1
61335: DEC
61336: ST_TO_ADDR
61337: LD_EXP 102
61341: PUSH
61342: FOR_TO
61343: IFFALSE 62265
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61345: LD_EXP 102
61349: PUSH
61350: LD_VAR 0 2
61354: ARRAY
61355: NOT
61356: PUSH
61357: LD_EXP 125
61361: PUSH
61362: LD_VAR 0 2
61366: ARRAY
61367: OR
61368: IFFALSE 61372
// continue ;
61370: GO 61342
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61372: LD_ADDR_VAR 0 7
61376: PUSH
61377: LD_EXP 102
61381: PUSH
61382: LD_VAR 0 2
61386: ARRAY
61387: PUSH
61388: LD_INT 1
61390: ARRAY
61391: PPUSH
61392: CALL_OW 248
61396: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61397: LD_VAR 0 7
61401: PUSH
61402: LD_INT 3
61404: EQUAL
61405: PUSH
61406: LD_EXP 121
61410: PUSH
61411: LD_VAR 0 2
61415: ARRAY
61416: PUSH
61417: LD_EXP 124
61421: PUSH
61422: LD_VAR 0 2
61426: ARRAY
61427: UNION
61428: PPUSH
61429: LD_INT 33
61431: PUSH
61432: LD_INT 2
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PPUSH
61439: CALL_OW 72
61443: NOT
61444: OR
61445: IFFALSE 61449
// continue ;
61447: GO 61342
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61449: LD_ADDR_VAR 0 9
61453: PUSH
61454: LD_EXP 102
61458: PUSH
61459: LD_VAR 0 2
61463: ARRAY
61464: PPUSH
61465: LD_INT 30
61467: PUSH
61468: LD_INT 36
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: PPUSH
61475: CALL_OW 72
61479: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
61480: LD_ADDR_VAR 0 10
61484: PUSH
61485: LD_EXP 121
61489: PUSH
61490: LD_VAR 0 2
61494: ARRAY
61495: PPUSH
61496: LD_INT 34
61498: PUSH
61499: LD_INT 31
61501: PUSH
61502: EMPTY
61503: LIST
61504: LIST
61505: PPUSH
61506: CALL_OW 72
61510: ST_TO_ADDR
// if not cts and not mcts then
61511: LD_VAR 0 9
61515: NOT
61516: PUSH
61517: LD_VAR 0 10
61521: NOT
61522: AND
61523: IFFALSE 61527
// continue ;
61525: GO 61342
// x := cts ;
61527: LD_ADDR_VAR 0 11
61531: PUSH
61532: LD_VAR 0 9
61536: ST_TO_ADDR
// if not x then
61537: LD_VAR 0 11
61541: NOT
61542: IFFALSE 61554
// x := mcts ;
61544: LD_ADDR_VAR 0 11
61548: PUSH
61549: LD_VAR 0 10
61553: ST_TO_ADDR
// if not x then
61554: LD_VAR 0 11
61558: NOT
61559: IFFALSE 61563
// continue ;
61561: GO 61342
// if mc_remote_driver [ i ] then
61563: LD_EXP 142
61567: PUSH
61568: LD_VAR 0 2
61572: ARRAY
61573: IFFALSE 61960
// for j in mc_remote_driver [ i ] do
61575: LD_ADDR_VAR 0 3
61579: PUSH
61580: LD_EXP 142
61584: PUSH
61585: LD_VAR 0 2
61589: ARRAY
61590: PUSH
61591: FOR_IN
61592: IFFALSE 61958
// begin if GetClass ( j ) <> 3 then
61594: LD_VAR 0 3
61598: PPUSH
61599: CALL_OW 257
61603: PUSH
61604: LD_INT 3
61606: NONEQUAL
61607: IFFALSE 61660
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61609: LD_ADDR_EXP 142
61613: PUSH
61614: LD_EXP 142
61618: PPUSH
61619: LD_VAR 0 2
61623: PPUSH
61624: LD_EXP 142
61628: PUSH
61629: LD_VAR 0 2
61633: ARRAY
61634: PUSH
61635: LD_VAR 0 3
61639: DIFF
61640: PPUSH
61641: CALL_OW 1
61645: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61646: LD_VAR 0 3
61650: PPUSH
61651: LD_INT 0
61653: PPUSH
61654: CALL_OW 109
// continue ;
61658: GO 61591
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61660: LD_EXP 121
61664: PUSH
61665: LD_VAR 0 2
61669: ARRAY
61670: PPUSH
61671: LD_INT 34
61673: PUSH
61674: LD_INT 31
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PUSH
61681: LD_INT 58
61683: PUSH
61684: EMPTY
61685: LIST
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PPUSH
61691: CALL_OW 72
61695: PUSH
61696: LD_VAR 0 3
61700: PPUSH
61701: CALL 105577 0 1
61705: NOT
61706: AND
61707: IFFALSE 61778
// begin if IsInUnit ( j ) then
61709: LD_VAR 0 3
61713: PPUSH
61714: CALL_OW 310
61718: IFFALSE 61729
// ComExitBuilding ( j ) ;
61720: LD_VAR 0 3
61724: PPUSH
61725: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61729: LD_VAR 0 3
61733: PPUSH
61734: LD_EXP 121
61738: PUSH
61739: LD_VAR 0 2
61743: ARRAY
61744: PPUSH
61745: LD_INT 34
61747: PUSH
61748: LD_INT 31
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PUSH
61755: LD_INT 58
61757: PUSH
61758: EMPTY
61759: LIST
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PPUSH
61765: CALL_OW 72
61769: PUSH
61770: LD_INT 1
61772: ARRAY
61773: PPUSH
61774: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61778: LD_VAR 0 3
61782: PPUSH
61783: CALL_OW 310
61787: NOT
61788: PUSH
61789: LD_VAR 0 3
61793: PPUSH
61794: CALL_OW 310
61798: PPUSH
61799: CALL_OW 266
61803: PUSH
61804: LD_INT 36
61806: NONEQUAL
61807: PUSH
61808: LD_VAR 0 3
61812: PPUSH
61813: CALL 105577 0 1
61817: NOT
61818: AND
61819: OR
61820: IFFALSE 61956
// begin if IsInUnit ( j ) then
61822: LD_VAR 0 3
61826: PPUSH
61827: CALL_OW 310
61831: IFFALSE 61842
// ComExitBuilding ( j ) ;
61833: LD_VAR 0 3
61837: PPUSH
61838: CALL_OW 122
// ct := 0 ;
61842: LD_ADDR_VAR 0 8
61846: PUSH
61847: LD_INT 0
61849: ST_TO_ADDR
// for k in x do
61850: LD_ADDR_VAR 0 4
61854: PUSH
61855: LD_VAR 0 11
61859: PUSH
61860: FOR_IN
61861: IFFALSE 61934
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61863: LD_VAR 0 4
61867: PPUSH
61868: CALL_OW 264
61872: PUSH
61873: LD_INT 31
61875: EQUAL
61876: PUSH
61877: LD_VAR 0 4
61881: PPUSH
61882: CALL_OW 311
61886: NOT
61887: AND
61888: PUSH
61889: LD_VAR 0 4
61893: PPUSH
61894: CALL_OW 266
61898: PUSH
61899: LD_INT 36
61901: EQUAL
61902: PUSH
61903: LD_VAR 0 4
61907: PPUSH
61908: CALL_OW 313
61912: PUSH
61913: LD_INT 3
61915: LESS
61916: AND
61917: OR
61918: IFFALSE 61932
// begin ct := k ;
61920: LD_ADDR_VAR 0 8
61924: PUSH
61925: LD_VAR 0 4
61929: ST_TO_ADDR
// break ;
61930: GO 61934
// end ;
61932: GO 61860
61934: POP
61935: POP
// if ct then
61936: LD_VAR 0 8
61940: IFFALSE 61956
// ComEnterUnit ( j , ct ) ;
61942: LD_VAR 0 3
61946: PPUSH
61947: LD_VAR 0 8
61951: PPUSH
61952: CALL_OW 120
// end ; end ;
61956: GO 61591
61958: POP
61959: POP
// places := 0 ;
61960: LD_ADDR_VAR 0 5
61964: PUSH
61965: LD_INT 0
61967: ST_TO_ADDR
// for j = 1 to x do
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: DOUBLE
61974: LD_INT 1
61976: DEC
61977: ST_TO_ADDR
61978: LD_VAR 0 11
61982: PUSH
61983: FOR_TO
61984: IFFALSE 62060
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61986: LD_VAR 0 11
61990: PUSH
61991: LD_VAR 0 3
61995: ARRAY
61996: PPUSH
61997: CALL_OW 264
62001: PUSH
62002: LD_INT 31
62004: EQUAL
62005: IFFALSE 62023
// places := places + 1 else
62007: LD_ADDR_VAR 0 5
62011: PUSH
62012: LD_VAR 0 5
62016: PUSH
62017: LD_INT 1
62019: PLUS
62020: ST_TO_ADDR
62021: GO 62058
// if GetBType ( x [ j ] ) = b_control_tower then
62023: LD_VAR 0 11
62027: PUSH
62028: LD_VAR 0 3
62032: ARRAY
62033: PPUSH
62034: CALL_OW 266
62038: PUSH
62039: LD_INT 36
62041: EQUAL
62042: IFFALSE 62058
// places := places + 3 ;
62044: LD_ADDR_VAR 0 5
62048: PUSH
62049: LD_VAR 0 5
62053: PUSH
62054: LD_INT 3
62056: PLUS
62057: ST_TO_ADDR
62058: GO 61983
62060: POP
62061: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62062: LD_VAR 0 5
62066: PUSH
62067: LD_INT 0
62069: EQUAL
62070: PUSH
62071: LD_VAR 0 5
62075: PUSH
62076: LD_EXP 142
62080: PUSH
62081: LD_VAR 0 2
62085: ARRAY
62086: LESSEQUAL
62087: OR
62088: IFFALSE 62092
// continue ;
62090: GO 61342
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62092: LD_ADDR_VAR 0 6
62096: PUSH
62097: LD_EXP 102
62101: PUSH
62102: LD_VAR 0 2
62106: ARRAY
62107: PPUSH
62108: LD_INT 25
62110: PUSH
62111: LD_INT 3
62113: PUSH
62114: EMPTY
62115: LIST
62116: LIST
62117: PPUSH
62118: CALL_OW 72
62122: PUSH
62123: LD_EXP 142
62127: PUSH
62128: LD_VAR 0 2
62132: ARRAY
62133: DIFF
62134: PPUSH
62135: LD_INT 3
62137: PPUSH
62138: CALL 106477 0 2
62142: ST_TO_ADDR
// for j in tmp do
62143: LD_ADDR_VAR 0 3
62147: PUSH
62148: LD_VAR 0 6
62152: PUSH
62153: FOR_IN
62154: IFFALSE 62189
// if GetTag ( j ) > 0 then
62156: LD_VAR 0 3
62160: PPUSH
62161: CALL_OW 110
62165: PUSH
62166: LD_INT 0
62168: GREATER
62169: IFFALSE 62187
// tmp := tmp diff j ;
62171: LD_ADDR_VAR 0 6
62175: PUSH
62176: LD_VAR 0 6
62180: PUSH
62181: LD_VAR 0 3
62185: DIFF
62186: ST_TO_ADDR
62187: GO 62153
62189: POP
62190: POP
// if not tmp then
62191: LD_VAR 0 6
62195: NOT
62196: IFFALSE 62200
// continue ;
62198: GO 61342
// if places then
62200: LD_VAR 0 5
62204: IFFALSE 62263
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62206: LD_ADDR_EXP 142
62210: PUSH
62211: LD_EXP 142
62215: PPUSH
62216: LD_VAR 0 2
62220: PPUSH
62221: LD_EXP 142
62225: PUSH
62226: LD_VAR 0 2
62230: ARRAY
62231: PUSH
62232: LD_VAR 0 6
62236: PUSH
62237: LD_INT 1
62239: ARRAY
62240: UNION
62241: PPUSH
62242: CALL_OW 1
62246: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62247: LD_VAR 0 6
62251: PUSH
62252: LD_INT 1
62254: ARRAY
62255: PPUSH
62256: LD_INT 126
62258: PPUSH
62259: CALL_OW 109
// end ; end ;
62263: GO 61342
62265: POP
62266: POP
// end ;
62267: LD_VAR 0 1
62271: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62272: LD_INT 0
62274: PPUSH
62275: PPUSH
62276: PPUSH
62277: PPUSH
62278: PPUSH
62279: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62280: LD_VAR 0 1
62284: NOT
62285: PUSH
62286: LD_VAR 0 2
62290: NOT
62291: OR
62292: PUSH
62293: LD_VAR 0 3
62297: NOT
62298: OR
62299: PUSH
62300: LD_VAR 0 4
62304: PUSH
62305: LD_INT 1
62307: PUSH
62308: LD_INT 2
62310: PUSH
62311: LD_INT 3
62313: PUSH
62314: LD_INT 4
62316: PUSH
62317: LD_INT 5
62319: PUSH
62320: LD_INT 8
62322: PUSH
62323: LD_INT 9
62325: PUSH
62326: LD_INT 15
62328: PUSH
62329: LD_INT 16
62331: PUSH
62332: EMPTY
62333: LIST
62334: LIST
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: IN
62343: NOT
62344: OR
62345: IFFALSE 62349
// exit ;
62347: GO 63207
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62349: LD_ADDR_VAR 0 2
62353: PUSH
62354: LD_VAR 0 2
62358: PPUSH
62359: LD_INT 21
62361: PUSH
62362: LD_INT 3
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PUSH
62369: LD_INT 24
62371: PUSH
62372: LD_INT 250
62374: PUSH
62375: EMPTY
62376: LIST
62377: LIST
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PPUSH
62383: CALL_OW 72
62387: ST_TO_ADDR
// case class of 1 , 15 :
62388: LD_VAR 0 4
62392: PUSH
62393: LD_INT 1
62395: DOUBLE
62396: EQUAL
62397: IFTRUE 62407
62399: LD_INT 15
62401: DOUBLE
62402: EQUAL
62403: IFTRUE 62407
62405: GO 62492
62407: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62408: LD_ADDR_VAR 0 8
62412: PUSH
62413: LD_VAR 0 2
62417: PPUSH
62418: LD_INT 2
62420: PUSH
62421: LD_INT 30
62423: PUSH
62424: LD_INT 32
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: LD_INT 30
62433: PUSH
62434: LD_INT 31
62436: PUSH
62437: EMPTY
62438: LIST
62439: LIST
62440: PUSH
62441: EMPTY
62442: LIST
62443: LIST
62444: LIST
62445: PPUSH
62446: CALL_OW 72
62450: PUSH
62451: LD_VAR 0 2
62455: PPUSH
62456: LD_INT 2
62458: PUSH
62459: LD_INT 30
62461: PUSH
62462: LD_INT 4
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: LD_INT 30
62471: PUSH
62472: LD_INT 5
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: PUSH
62479: EMPTY
62480: LIST
62481: LIST
62482: LIST
62483: PPUSH
62484: CALL_OW 72
62488: ADD
62489: ST_TO_ADDR
62490: GO 62738
62492: LD_INT 2
62494: DOUBLE
62495: EQUAL
62496: IFTRUE 62506
62498: LD_INT 16
62500: DOUBLE
62501: EQUAL
62502: IFTRUE 62506
62504: GO 62552
62506: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
62507: LD_ADDR_VAR 0 8
62511: PUSH
62512: LD_VAR 0 2
62516: PPUSH
62517: LD_INT 2
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 0
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: LD_INT 30
62532: PUSH
62533: LD_INT 1
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: LIST
62544: PPUSH
62545: CALL_OW 72
62549: ST_TO_ADDR
62550: GO 62738
62552: LD_INT 3
62554: DOUBLE
62555: EQUAL
62556: IFTRUE 62560
62558: GO 62606
62560: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
62561: LD_ADDR_VAR 0 8
62565: PUSH
62566: LD_VAR 0 2
62570: PPUSH
62571: LD_INT 2
62573: PUSH
62574: LD_INT 30
62576: PUSH
62577: LD_INT 2
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: LD_INT 30
62586: PUSH
62587: LD_INT 3
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: LIST
62598: PPUSH
62599: CALL_OW 72
62603: ST_TO_ADDR
62604: GO 62738
62606: LD_INT 4
62608: DOUBLE
62609: EQUAL
62610: IFTRUE 62614
62612: GO 62671
62614: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62615: LD_ADDR_VAR 0 8
62619: PUSH
62620: LD_VAR 0 2
62624: PPUSH
62625: LD_INT 2
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 6
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: LD_INT 7
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 30
62650: PUSH
62651: LD_INT 8
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: LIST
62662: LIST
62663: PPUSH
62664: CALL_OW 72
62668: ST_TO_ADDR
62669: GO 62738
62671: LD_INT 5
62673: DOUBLE
62674: EQUAL
62675: IFTRUE 62691
62677: LD_INT 8
62679: DOUBLE
62680: EQUAL
62681: IFTRUE 62691
62683: LD_INT 9
62685: DOUBLE
62686: EQUAL
62687: IFTRUE 62691
62689: GO 62737
62691: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62692: LD_ADDR_VAR 0 8
62696: PUSH
62697: LD_VAR 0 2
62701: PPUSH
62702: LD_INT 2
62704: PUSH
62705: LD_INT 30
62707: PUSH
62708: LD_INT 4
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PUSH
62715: LD_INT 30
62717: PUSH
62718: LD_INT 5
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: LIST
62729: PPUSH
62730: CALL_OW 72
62734: ST_TO_ADDR
62735: GO 62738
62737: POP
// if not tmp then
62738: LD_VAR 0 8
62742: NOT
62743: IFFALSE 62747
// exit ;
62745: GO 63207
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62747: LD_VAR 0 4
62751: PUSH
62752: LD_INT 1
62754: PUSH
62755: LD_INT 15
62757: PUSH
62758: EMPTY
62759: LIST
62760: LIST
62761: IN
62762: PUSH
62763: LD_EXP 111
62767: PUSH
62768: LD_VAR 0 1
62772: ARRAY
62773: AND
62774: IFFALSE 62930
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62776: LD_ADDR_VAR 0 9
62780: PUSH
62781: LD_EXP 111
62785: PUSH
62786: LD_VAR 0 1
62790: ARRAY
62791: PUSH
62792: LD_INT 1
62794: ARRAY
62795: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62796: LD_VAR 0 9
62800: PUSH
62801: LD_EXP 112
62805: PUSH
62806: LD_VAR 0 1
62810: ARRAY
62811: IN
62812: NOT
62813: IFFALSE 62928
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62815: LD_ADDR_EXP 112
62819: PUSH
62820: LD_EXP 112
62824: PPUSH
62825: LD_VAR 0 1
62829: PUSH
62830: LD_EXP 112
62834: PUSH
62835: LD_VAR 0 1
62839: ARRAY
62840: PUSH
62841: LD_INT 1
62843: PLUS
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PPUSH
62849: LD_VAR 0 9
62853: PPUSH
62854: CALL 75244 0 3
62858: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62859: LD_ADDR_EXP 111
62863: PUSH
62864: LD_EXP 111
62868: PPUSH
62869: LD_VAR 0 1
62873: PPUSH
62874: LD_EXP 111
62878: PUSH
62879: LD_VAR 0 1
62883: ARRAY
62884: PUSH
62885: LD_VAR 0 9
62889: DIFF
62890: PPUSH
62891: CALL_OW 1
62895: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62896: LD_VAR 0 3
62900: PPUSH
62901: LD_EXP 112
62905: PUSH
62906: LD_VAR 0 1
62910: ARRAY
62911: PUSH
62912: LD_EXP 112
62916: PUSH
62917: LD_VAR 0 1
62921: ARRAY
62922: ARRAY
62923: PPUSH
62924: CALL_OW 120
// end ; exit ;
62928: GO 63207
// end ; if tmp > 1 then
62930: LD_VAR 0 8
62934: PUSH
62935: LD_INT 1
62937: GREATER
62938: IFFALSE 63042
// for i = 2 to tmp do
62940: LD_ADDR_VAR 0 6
62944: PUSH
62945: DOUBLE
62946: LD_INT 2
62948: DEC
62949: ST_TO_ADDR
62950: LD_VAR 0 8
62954: PUSH
62955: FOR_TO
62956: IFFALSE 63040
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62958: LD_VAR 0 8
62962: PUSH
62963: LD_VAR 0 6
62967: ARRAY
62968: PPUSH
62969: CALL_OW 461
62973: PUSH
62974: LD_INT 6
62976: EQUAL
62977: IFFALSE 63038
// begin x := tmp [ i ] ;
62979: LD_ADDR_VAR 0 9
62983: PUSH
62984: LD_VAR 0 8
62988: PUSH
62989: LD_VAR 0 6
62993: ARRAY
62994: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62995: LD_ADDR_VAR 0 8
62999: PUSH
63000: LD_VAR 0 8
63004: PPUSH
63005: LD_VAR 0 6
63009: PPUSH
63010: CALL_OW 3
63014: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63015: LD_ADDR_VAR 0 8
63019: PUSH
63020: LD_VAR 0 8
63024: PPUSH
63025: LD_INT 1
63027: PPUSH
63028: LD_VAR 0 9
63032: PPUSH
63033: CALL_OW 2
63037: ST_TO_ADDR
// end ;
63038: GO 62955
63040: POP
63041: POP
// for i in tmp do
63042: LD_ADDR_VAR 0 6
63046: PUSH
63047: LD_VAR 0 8
63051: PUSH
63052: FOR_IN
63053: IFFALSE 63080
// begin if IsNotFull ( i ) then
63055: LD_VAR 0 6
63059: PPUSH
63060: CALL 72466 0 1
63064: IFFALSE 63078
// begin j := i ;
63066: LD_ADDR_VAR 0 7
63070: PUSH
63071: LD_VAR 0 6
63075: ST_TO_ADDR
// break ;
63076: GO 63080
// end ; end ;
63078: GO 63052
63080: POP
63081: POP
// if j then
63082: LD_VAR 0 7
63086: IFFALSE 63104
// ComEnterUnit ( unit , j ) else
63088: LD_VAR 0 3
63092: PPUSH
63093: LD_VAR 0 7
63097: PPUSH
63098: CALL_OW 120
63102: GO 63207
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63104: LD_ADDR_VAR 0 10
63108: PUSH
63109: LD_VAR 0 2
63113: PPUSH
63114: LD_INT 2
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_INT 0
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 30
63129: PUSH
63130: LD_INT 1
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: LIST
63141: PPUSH
63142: CALL_OW 72
63146: ST_TO_ADDR
// if depot then
63147: LD_VAR 0 10
63151: IFFALSE 63207
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63153: LD_ADDR_VAR 0 10
63157: PUSH
63158: LD_VAR 0 10
63162: PPUSH
63163: LD_VAR 0 3
63167: PPUSH
63168: CALL_OW 74
63172: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63173: LD_VAR 0 3
63177: PPUSH
63178: LD_VAR 0 10
63182: PPUSH
63183: CALL_OW 296
63187: PUSH
63188: LD_INT 10
63190: GREATER
63191: IFFALSE 63207
// ComStandNearbyBuilding ( unit , depot ) ;
63193: LD_VAR 0 3
63197: PPUSH
63198: LD_VAR 0 10
63202: PPUSH
63203: CALL 71846 0 2
// end ; end ; end ;
63207: LD_VAR 0 5
63211: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63212: LD_INT 0
63214: PPUSH
63215: PPUSH
63216: PPUSH
63217: PPUSH
// if not mc_bases then
63218: LD_EXP 102
63222: NOT
63223: IFFALSE 63227
// exit ;
63225: GO 63466
// for i = 1 to mc_bases do
63227: LD_ADDR_VAR 0 2
63231: PUSH
63232: DOUBLE
63233: LD_INT 1
63235: DEC
63236: ST_TO_ADDR
63237: LD_EXP 102
63241: PUSH
63242: FOR_TO
63243: IFFALSE 63464
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63245: LD_ADDR_VAR 0 4
63249: PUSH
63250: LD_EXP 102
63254: PUSH
63255: LD_VAR 0 2
63259: ARRAY
63260: PPUSH
63261: LD_INT 21
63263: PUSH
63264: LD_INT 1
63266: PUSH
63267: EMPTY
63268: LIST
63269: LIST
63270: PPUSH
63271: CALL_OW 72
63275: PUSH
63276: LD_EXP 131
63280: PUSH
63281: LD_VAR 0 2
63285: ARRAY
63286: UNION
63287: ST_TO_ADDR
// if not tmp then
63288: LD_VAR 0 4
63292: NOT
63293: IFFALSE 63297
// continue ;
63295: GO 63242
// for j in tmp do
63297: LD_ADDR_VAR 0 3
63301: PUSH
63302: LD_VAR 0 4
63306: PUSH
63307: FOR_IN
63308: IFFALSE 63460
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63310: LD_VAR 0 3
63314: PPUSH
63315: CALL_OW 110
63319: NOT
63320: PUSH
63321: LD_VAR 0 3
63325: PPUSH
63326: CALL_OW 314
63330: NOT
63331: AND
63332: PUSH
63333: LD_VAR 0 3
63337: PPUSH
63338: CALL_OW 311
63342: NOT
63343: AND
63344: PUSH
63345: LD_VAR 0 3
63349: PPUSH
63350: CALL_OW 310
63354: NOT
63355: AND
63356: PUSH
63357: LD_VAR 0 3
63361: PUSH
63362: LD_EXP 105
63366: PUSH
63367: LD_VAR 0 2
63371: ARRAY
63372: PUSH
63373: LD_INT 1
63375: ARRAY
63376: IN
63377: NOT
63378: AND
63379: PUSH
63380: LD_VAR 0 3
63384: PUSH
63385: LD_EXP 105
63389: PUSH
63390: LD_VAR 0 2
63394: ARRAY
63395: PUSH
63396: LD_INT 2
63398: ARRAY
63399: IN
63400: NOT
63401: AND
63402: PUSH
63403: LD_VAR 0 3
63407: PUSH
63408: LD_EXP 114
63412: PUSH
63413: LD_VAR 0 2
63417: ARRAY
63418: IN
63419: NOT
63420: AND
63421: IFFALSE 63458
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63423: LD_VAR 0 2
63427: PPUSH
63428: LD_EXP 102
63432: PUSH
63433: LD_VAR 0 2
63437: ARRAY
63438: PPUSH
63439: LD_VAR 0 3
63443: PPUSH
63444: LD_VAR 0 3
63448: PPUSH
63449: CALL_OW 257
63453: PPUSH
63454: CALL 62272 0 4
// end ;
63458: GO 63307
63460: POP
63461: POP
// end ;
63462: GO 63242
63464: POP
63465: POP
// end ;
63466: LD_VAR 0 1
63470: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
63471: LD_INT 0
63473: PPUSH
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
63478: PPUSH
// if not mc_bases [ base ] then
63479: LD_EXP 102
63483: PUSH
63484: LD_VAR 0 1
63488: ARRAY
63489: NOT
63490: IFFALSE 63494
// exit ;
63492: GO 63695
// tmp := [ ] ;
63494: LD_ADDR_VAR 0 6
63498: PUSH
63499: EMPTY
63500: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
63501: LD_ADDR_VAR 0 7
63505: PUSH
63506: LD_VAR 0 3
63510: PPUSH
63511: LD_INT 0
63513: PPUSH
63514: CALL_OW 517
63518: ST_TO_ADDR
// if not list then
63519: LD_VAR 0 7
63523: NOT
63524: IFFALSE 63528
// exit ;
63526: GO 63695
// c := Count ( list [ 1 ] ) ;
63528: LD_ADDR_VAR 0 9
63532: PUSH
63533: LD_VAR 0 7
63537: PUSH
63538: LD_INT 1
63540: ARRAY
63541: PPUSH
63542: CALL 72384 0 1
63546: ST_TO_ADDR
// if amount > c then
63547: LD_VAR 0 2
63551: PUSH
63552: LD_VAR 0 9
63556: GREATER
63557: IFFALSE 63569
// amount := c ;
63559: LD_ADDR_VAR 0 2
63563: PUSH
63564: LD_VAR 0 9
63568: ST_TO_ADDR
// for i := 1 to amount do
63569: LD_ADDR_VAR 0 5
63573: PUSH
63574: DOUBLE
63575: LD_INT 1
63577: DEC
63578: ST_TO_ADDR
63579: LD_VAR 0 2
63583: PUSH
63584: FOR_TO
63585: IFFALSE 63643
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63587: LD_ADDR_VAR 0 6
63591: PUSH
63592: LD_VAR 0 6
63596: PPUSH
63597: LD_VAR 0 5
63601: PPUSH
63602: LD_VAR 0 7
63606: PUSH
63607: LD_INT 1
63609: ARRAY
63610: PUSH
63611: LD_VAR 0 5
63615: ARRAY
63616: PUSH
63617: LD_VAR 0 7
63621: PUSH
63622: LD_INT 2
63624: ARRAY
63625: PUSH
63626: LD_VAR 0 5
63630: ARRAY
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: PPUSH
63636: CALL_OW 1
63640: ST_TO_ADDR
63641: GO 63584
63643: POP
63644: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63645: LD_ADDR_EXP 115
63649: PUSH
63650: LD_EXP 115
63654: PPUSH
63655: LD_VAR 0 1
63659: PPUSH
63660: LD_VAR 0 6
63664: PPUSH
63665: CALL_OW 1
63669: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63670: LD_ADDR_EXP 117
63674: PUSH
63675: LD_EXP 117
63679: PPUSH
63680: LD_VAR 0 1
63684: PPUSH
63685: LD_VAR 0 3
63689: PPUSH
63690: CALL_OW 1
63694: ST_TO_ADDR
// end ;
63695: LD_VAR 0 4
63699: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63700: LD_INT 0
63702: PPUSH
// if not mc_bases [ base ] then
63703: LD_EXP 102
63707: PUSH
63708: LD_VAR 0 1
63712: ARRAY
63713: NOT
63714: IFFALSE 63718
// exit ;
63716: GO 63743
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63718: LD_ADDR_EXP 107
63722: PUSH
63723: LD_EXP 107
63727: PPUSH
63728: LD_VAR 0 1
63732: PPUSH
63733: LD_VAR 0 2
63737: PPUSH
63738: CALL_OW 1
63742: ST_TO_ADDR
// end ;
63743: LD_VAR 0 3
63747: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63748: LD_INT 0
63750: PPUSH
// if not mc_bases [ base ] then
63751: LD_EXP 102
63755: PUSH
63756: LD_VAR 0 1
63760: ARRAY
63761: NOT
63762: IFFALSE 63766
// exit ;
63764: GO 63803
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63766: LD_ADDR_EXP 107
63770: PUSH
63771: LD_EXP 107
63775: PPUSH
63776: LD_VAR 0 1
63780: PPUSH
63781: LD_EXP 107
63785: PUSH
63786: LD_VAR 0 1
63790: ARRAY
63791: PUSH
63792: LD_VAR 0 2
63796: UNION
63797: PPUSH
63798: CALL_OW 1
63802: ST_TO_ADDR
// end ;
63803: LD_VAR 0 3
63807: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63808: LD_INT 0
63810: PPUSH
// if not mc_bases [ base ] then
63811: LD_EXP 102
63815: PUSH
63816: LD_VAR 0 1
63820: ARRAY
63821: NOT
63822: IFFALSE 63826
// exit ;
63824: GO 63851
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63826: LD_ADDR_EXP 123
63830: PUSH
63831: LD_EXP 123
63835: PPUSH
63836: LD_VAR 0 1
63840: PPUSH
63841: LD_VAR 0 2
63845: PPUSH
63846: CALL_OW 1
63850: ST_TO_ADDR
// end ;
63851: LD_VAR 0 3
63855: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63856: LD_INT 0
63858: PPUSH
// if not mc_bases [ base ] then
63859: LD_EXP 102
63863: PUSH
63864: LD_VAR 0 1
63868: ARRAY
63869: NOT
63870: IFFALSE 63874
// exit ;
63872: GO 63911
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63874: LD_ADDR_EXP 123
63878: PUSH
63879: LD_EXP 123
63883: PPUSH
63884: LD_VAR 0 1
63888: PPUSH
63889: LD_EXP 123
63893: PUSH
63894: LD_VAR 0 1
63898: ARRAY
63899: PUSH
63900: LD_VAR 0 2
63904: ADD
63905: PPUSH
63906: CALL_OW 1
63910: ST_TO_ADDR
// end ;
63911: LD_VAR 0 3
63915: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63916: LD_INT 0
63918: PPUSH
// if not mc_bases [ base ] then
63919: LD_EXP 102
63923: PUSH
63924: LD_VAR 0 1
63928: ARRAY
63929: NOT
63930: IFFALSE 63934
// exit ;
63932: GO 63988
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63934: LD_ADDR_EXP 124
63938: PUSH
63939: LD_EXP 124
63943: PPUSH
63944: LD_VAR 0 1
63948: PPUSH
63949: LD_VAR 0 2
63953: PPUSH
63954: CALL_OW 1
63958: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63959: LD_ADDR_EXP 113
63963: PUSH
63964: LD_EXP 113
63968: PPUSH
63969: LD_VAR 0 1
63973: PPUSH
63974: LD_VAR 0 2
63978: PUSH
63979: LD_INT 0
63981: PLUS
63982: PPUSH
63983: CALL_OW 1
63987: ST_TO_ADDR
// end ;
63988: LD_VAR 0 3
63992: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63993: LD_INT 0
63995: PPUSH
// if not mc_bases [ base ] then
63996: LD_EXP 102
64000: PUSH
64001: LD_VAR 0 1
64005: ARRAY
64006: NOT
64007: IFFALSE 64011
// exit ;
64009: GO 64036
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64011: LD_ADDR_EXP 113
64015: PUSH
64016: LD_EXP 113
64020: PPUSH
64021: LD_VAR 0 1
64025: PPUSH
64026: LD_VAR 0 2
64030: PPUSH
64031: CALL_OW 1
64035: ST_TO_ADDR
// end ;
64036: LD_VAR 0 3
64040: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64041: LD_INT 0
64043: PPUSH
64044: PPUSH
64045: PPUSH
64046: PPUSH
// if not mc_bases [ base ] then
64047: LD_EXP 102
64051: PUSH
64052: LD_VAR 0 1
64056: ARRAY
64057: NOT
64058: IFFALSE 64062
// exit ;
64060: GO 64127
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64062: LD_ADDR_EXP 122
64066: PUSH
64067: LD_EXP 122
64071: PPUSH
64072: LD_VAR 0 1
64076: PUSH
64077: LD_EXP 122
64081: PUSH
64082: LD_VAR 0 1
64086: ARRAY
64087: PUSH
64088: LD_INT 1
64090: PLUS
64091: PUSH
64092: EMPTY
64093: LIST
64094: LIST
64095: PPUSH
64096: LD_VAR 0 1
64100: PUSH
64101: LD_VAR 0 2
64105: PUSH
64106: LD_VAR 0 3
64110: PUSH
64111: LD_VAR 0 4
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: PPUSH
64122: CALL 75244 0 3
64126: ST_TO_ADDR
// end ;
64127: LD_VAR 0 5
64131: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64132: LD_INT 0
64134: PPUSH
// if not mc_bases [ base ] then
64135: LD_EXP 102
64139: PUSH
64140: LD_VAR 0 1
64144: ARRAY
64145: NOT
64146: IFFALSE 64150
// exit ;
64148: GO 64175
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64150: LD_ADDR_EXP 139
64154: PUSH
64155: LD_EXP 139
64159: PPUSH
64160: LD_VAR 0 1
64164: PPUSH
64165: LD_VAR 0 2
64169: PPUSH
64170: CALL_OW 1
64174: ST_TO_ADDR
// end ;
64175: LD_VAR 0 3
64179: RET
// export function MC_GetMinesField ( base ) ; begin
64180: LD_INT 0
64182: PPUSH
// result := mc_mines [ base ] ;
64183: LD_ADDR_VAR 0 2
64187: PUSH
64188: LD_EXP 115
64192: PUSH
64193: LD_VAR 0 1
64197: ARRAY
64198: ST_TO_ADDR
// end ;
64199: LD_VAR 0 2
64203: RET
// export function MC_GetProduceList ( base ) ; begin
64204: LD_INT 0
64206: PPUSH
// result := mc_produce [ base ] ;
64207: LD_ADDR_VAR 0 2
64211: PUSH
64212: LD_EXP 123
64216: PUSH
64217: LD_VAR 0 1
64221: ARRAY
64222: ST_TO_ADDR
// end ;
64223: LD_VAR 0 2
64227: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64228: LD_INT 0
64230: PPUSH
64231: PPUSH
// if not mc_bases then
64232: LD_EXP 102
64236: NOT
64237: IFFALSE 64241
// exit ;
64239: GO 64306
// if mc_bases [ base ] then
64241: LD_EXP 102
64245: PUSH
64246: LD_VAR 0 1
64250: ARRAY
64251: IFFALSE 64306
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64253: LD_ADDR_VAR 0 3
64257: PUSH
64258: LD_EXP 102
64262: PUSH
64263: LD_VAR 0 1
64267: ARRAY
64268: PPUSH
64269: LD_INT 30
64271: PUSH
64272: LD_VAR 0 2
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PPUSH
64281: CALL_OW 72
64285: ST_TO_ADDR
// if result then
64286: LD_VAR 0 3
64290: IFFALSE 64306
// result := result [ 1 ] ;
64292: LD_ADDR_VAR 0 3
64296: PUSH
64297: LD_VAR 0 3
64301: PUSH
64302: LD_INT 1
64304: ARRAY
64305: ST_TO_ADDR
// end ; end ;
64306: LD_VAR 0 3
64310: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64311: LD_INT 0
64313: PPUSH
64314: PPUSH
// if not mc_bases then
64315: LD_EXP 102
64319: NOT
64320: IFFALSE 64324
// exit ;
64322: GO 64369
// if mc_bases [ base ] then
64324: LD_EXP 102
64328: PUSH
64329: LD_VAR 0 1
64333: ARRAY
64334: IFFALSE 64369
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64336: LD_ADDR_VAR 0 3
64340: PUSH
64341: LD_EXP 102
64345: PUSH
64346: LD_VAR 0 1
64350: ARRAY
64351: PPUSH
64352: LD_INT 30
64354: PUSH
64355: LD_VAR 0 2
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: PPUSH
64364: CALL_OW 72
64368: ST_TO_ADDR
// end ;
64369: LD_VAR 0 3
64373: RET
// export function MC_SetTame ( base , area ) ; begin
64374: LD_INT 0
64376: PPUSH
// if not mc_bases or not base then
64377: LD_EXP 102
64381: NOT
64382: PUSH
64383: LD_VAR 0 1
64387: NOT
64388: OR
64389: IFFALSE 64393
// exit ;
64391: GO 64418
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64393: LD_ADDR_EXP 130
64397: PUSH
64398: LD_EXP 130
64402: PPUSH
64403: LD_VAR 0 1
64407: PPUSH
64408: LD_VAR 0 2
64412: PPUSH
64413: CALL_OW 1
64417: ST_TO_ADDR
// end ;
64418: LD_VAR 0 3
64422: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64423: LD_INT 0
64425: PPUSH
64426: PPUSH
// if not mc_bases or not base then
64427: LD_EXP 102
64431: NOT
64432: PUSH
64433: LD_VAR 0 1
64437: NOT
64438: OR
64439: IFFALSE 64443
// exit ;
64441: GO 64545
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64443: LD_ADDR_VAR 0 4
64447: PUSH
64448: LD_EXP 102
64452: PUSH
64453: LD_VAR 0 1
64457: ARRAY
64458: PPUSH
64459: LD_INT 30
64461: PUSH
64462: LD_VAR 0 2
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PPUSH
64471: CALL_OW 72
64475: ST_TO_ADDR
// if not tmp then
64476: LD_VAR 0 4
64480: NOT
64481: IFFALSE 64485
// exit ;
64483: GO 64545
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
64485: LD_ADDR_EXP 134
64489: PUSH
64490: LD_EXP 134
64494: PPUSH
64495: LD_VAR 0 1
64499: PPUSH
64500: LD_EXP 134
64504: PUSH
64505: LD_VAR 0 1
64509: ARRAY
64510: PPUSH
64511: LD_EXP 134
64515: PUSH
64516: LD_VAR 0 1
64520: ARRAY
64521: PUSH
64522: LD_INT 1
64524: PLUS
64525: PPUSH
64526: LD_VAR 0 4
64530: PUSH
64531: LD_INT 1
64533: ARRAY
64534: PPUSH
64535: CALL_OW 2
64539: PPUSH
64540: CALL_OW 1
64544: ST_TO_ADDR
// end ;
64545: LD_VAR 0 3
64549: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
64550: LD_INT 0
64552: PPUSH
64553: PPUSH
// if not mc_bases or not base or not kinds then
64554: LD_EXP 102
64558: NOT
64559: PUSH
64560: LD_VAR 0 1
64564: NOT
64565: OR
64566: PUSH
64567: LD_VAR 0 2
64571: NOT
64572: OR
64573: IFFALSE 64577
// exit ;
64575: GO 64638
// for i in kinds do
64577: LD_ADDR_VAR 0 4
64581: PUSH
64582: LD_VAR 0 2
64586: PUSH
64587: FOR_IN
64588: IFFALSE 64636
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64590: LD_ADDR_EXP 136
64594: PUSH
64595: LD_EXP 136
64599: PPUSH
64600: LD_VAR 0 1
64604: PUSH
64605: LD_EXP 136
64609: PUSH
64610: LD_VAR 0 1
64614: ARRAY
64615: PUSH
64616: LD_INT 1
64618: PLUS
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: PPUSH
64624: LD_VAR 0 4
64628: PPUSH
64629: CALL 75244 0 3
64633: ST_TO_ADDR
64634: GO 64587
64636: POP
64637: POP
// end ;
64638: LD_VAR 0 3
64642: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64643: LD_INT 0
64645: PPUSH
// if not mc_bases or not base or not areas then
64646: LD_EXP 102
64650: NOT
64651: PUSH
64652: LD_VAR 0 1
64656: NOT
64657: OR
64658: PUSH
64659: LD_VAR 0 2
64663: NOT
64664: OR
64665: IFFALSE 64669
// exit ;
64667: GO 64694
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64669: LD_ADDR_EXP 120
64673: PUSH
64674: LD_EXP 120
64678: PPUSH
64679: LD_VAR 0 1
64683: PPUSH
64684: LD_VAR 0 2
64688: PPUSH
64689: CALL_OW 1
64693: ST_TO_ADDR
// end ;
64694: LD_VAR 0 3
64698: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64699: LD_INT 0
64701: PPUSH
// if not mc_bases or not base or not teleports_exit then
64702: LD_EXP 102
64706: NOT
64707: PUSH
64708: LD_VAR 0 1
64712: NOT
64713: OR
64714: PUSH
64715: LD_VAR 0 2
64719: NOT
64720: OR
64721: IFFALSE 64725
// exit ;
64723: GO 64750
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64725: LD_ADDR_EXP 137
64729: PUSH
64730: LD_EXP 137
64734: PPUSH
64735: LD_VAR 0 1
64739: PPUSH
64740: LD_VAR 0 2
64744: PPUSH
64745: CALL_OW 1
64749: ST_TO_ADDR
// end ;
64750: LD_VAR 0 3
64754: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64755: LD_INT 0
64757: PPUSH
64758: PPUSH
64759: PPUSH
// if not mc_bases or not base or not ext_list then
64760: LD_EXP 102
64764: NOT
64765: PUSH
64766: LD_VAR 0 1
64770: NOT
64771: OR
64772: PUSH
64773: LD_VAR 0 5
64777: NOT
64778: OR
64779: IFFALSE 64783
// exit ;
64781: GO 64956
// tmp := GetFacExtXYD ( x , y , d ) ;
64783: LD_ADDR_VAR 0 8
64787: PUSH
64788: LD_VAR 0 2
64792: PPUSH
64793: LD_VAR 0 3
64797: PPUSH
64798: LD_VAR 0 4
64802: PPUSH
64803: CALL 105607 0 3
64807: ST_TO_ADDR
// if not tmp then
64808: LD_VAR 0 8
64812: NOT
64813: IFFALSE 64817
// exit ;
64815: GO 64956
// for i in tmp do
64817: LD_ADDR_VAR 0 7
64821: PUSH
64822: LD_VAR 0 8
64826: PUSH
64827: FOR_IN
64828: IFFALSE 64954
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64830: LD_ADDR_EXP 107
64834: PUSH
64835: LD_EXP 107
64839: PPUSH
64840: LD_VAR 0 1
64844: PPUSH
64845: LD_EXP 107
64849: PUSH
64850: LD_VAR 0 1
64854: ARRAY
64855: PPUSH
64856: LD_EXP 107
64860: PUSH
64861: LD_VAR 0 1
64865: ARRAY
64866: PUSH
64867: LD_INT 1
64869: PLUS
64870: PPUSH
64871: LD_VAR 0 5
64875: PUSH
64876: LD_INT 1
64878: ARRAY
64879: PUSH
64880: LD_VAR 0 7
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PUSH
64889: LD_VAR 0 7
64893: PUSH
64894: LD_INT 2
64896: ARRAY
64897: PUSH
64898: LD_VAR 0 7
64902: PUSH
64903: LD_INT 3
64905: ARRAY
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: PPUSH
64913: CALL_OW 2
64917: PPUSH
64918: CALL_OW 1
64922: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64923: LD_ADDR_VAR 0 5
64927: PUSH
64928: LD_VAR 0 5
64932: PPUSH
64933: LD_INT 1
64935: PPUSH
64936: CALL_OW 3
64940: ST_TO_ADDR
// if not ext_list then
64941: LD_VAR 0 5
64945: NOT
64946: IFFALSE 64952
// exit ;
64948: POP
64949: POP
64950: GO 64956
// end ;
64952: GO 64827
64954: POP
64955: POP
// end ;
64956: LD_VAR 0 6
64960: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64961: LD_INT 0
64963: PPUSH
// if not mc_bases or not base or not weapon_list then
64964: LD_EXP 102
64968: NOT
64969: PUSH
64970: LD_VAR 0 1
64974: NOT
64975: OR
64976: PUSH
64977: LD_VAR 0 2
64981: NOT
64982: OR
64983: IFFALSE 64987
// exit ;
64985: GO 65012
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64987: LD_ADDR_EXP 141
64991: PUSH
64992: LD_EXP 141
64996: PPUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: LD_VAR 0 2
65006: PPUSH
65007: CALL_OW 1
65011: ST_TO_ADDR
// end ;
65012: LD_VAR 0 3
65016: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65017: LD_INT 0
65019: PPUSH
// if not mc_bases or not base or not tech_list then
65020: LD_EXP 102
65024: NOT
65025: PUSH
65026: LD_VAR 0 1
65030: NOT
65031: OR
65032: PUSH
65033: LD_VAR 0 2
65037: NOT
65038: OR
65039: IFFALSE 65043
// exit ;
65041: GO 65068
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65043: LD_ADDR_EXP 129
65047: PUSH
65048: LD_EXP 129
65052: PPUSH
65053: LD_VAR 0 1
65057: PPUSH
65058: LD_VAR 0 2
65062: PPUSH
65063: CALL_OW 1
65067: ST_TO_ADDR
// end ;
65068: LD_VAR 0 3
65072: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65073: LD_INT 0
65075: PPUSH
// if not mc_bases or not parking_area or not base then
65076: LD_EXP 102
65080: NOT
65081: PUSH
65082: LD_VAR 0 2
65086: NOT
65087: OR
65088: PUSH
65089: LD_VAR 0 1
65093: NOT
65094: OR
65095: IFFALSE 65099
// exit ;
65097: GO 65124
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65099: LD_ADDR_EXP 126
65103: PUSH
65104: LD_EXP 126
65108: PPUSH
65109: LD_VAR 0 1
65113: PPUSH
65114: LD_VAR 0 2
65118: PPUSH
65119: CALL_OW 1
65123: ST_TO_ADDR
// end ;
65124: LD_VAR 0 3
65128: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65129: LD_INT 0
65131: PPUSH
// if not mc_bases or not base or not scan_area then
65132: LD_EXP 102
65136: NOT
65137: PUSH
65138: LD_VAR 0 1
65142: NOT
65143: OR
65144: PUSH
65145: LD_VAR 0 2
65149: NOT
65150: OR
65151: IFFALSE 65155
// exit ;
65153: GO 65180
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65155: LD_ADDR_EXP 127
65159: PUSH
65160: LD_EXP 127
65164: PPUSH
65165: LD_VAR 0 1
65169: PPUSH
65170: LD_VAR 0 2
65174: PPUSH
65175: CALL_OW 1
65179: ST_TO_ADDR
// end ;
65180: LD_VAR 0 3
65184: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65185: LD_INT 0
65187: PPUSH
65188: PPUSH
// if not mc_bases or not base then
65189: LD_EXP 102
65193: NOT
65194: PUSH
65195: LD_VAR 0 1
65199: NOT
65200: OR
65201: IFFALSE 65205
// exit ;
65203: GO 65269
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65205: LD_ADDR_VAR 0 3
65209: PUSH
65210: LD_INT 1
65212: PUSH
65213: LD_INT 2
65215: PUSH
65216: LD_INT 3
65218: PUSH
65219: LD_INT 4
65221: PUSH
65222: LD_INT 11
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65232: LD_ADDR_EXP 129
65236: PUSH
65237: LD_EXP 129
65241: PPUSH
65242: LD_VAR 0 1
65246: PPUSH
65247: LD_EXP 129
65251: PUSH
65252: LD_VAR 0 1
65256: ARRAY
65257: PUSH
65258: LD_VAR 0 3
65262: DIFF
65263: PPUSH
65264: CALL_OW 1
65268: ST_TO_ADDR
// end ;
65269: LD_VAR 0 2
65273: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65274: LD_INT 0
65276: PPUSH
// result := mc_vehicles [ base ] ;
65277: LD_ADDR_VAR 0 3
65281: PUSH
65282: LD_EXP 121
65286: PUSH
65287: LD_VAR 0 1
65291: ARRAY
65292: ST_TO_ADDR
// if onlyCombat then
65293: LD_VAR 0 2
65297: IFFALSE 65469
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65299: LD_ADDR_VAR 0 3
65303: PUSH
65304: LD_VAR 0 3
65308: PUSH
65309: LD_VAR 0 3
65313: PPUSH
65314: LD_INT 2
65316: PUSH
65317: LD_INT 34
65319: PUSH
65320: LD_INT 12
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 34
65329: PUSH
65330: LD_INT 51
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 34
65339: PUSH
65340: LD_INT 89
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 34
65349: PUSH
65350: LD_INT 32
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 34
65359: PUSH
65360: LD_INT 13
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 34
65369: PUSH
65370: LD_INT 52
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 34
65379: PUSH
65380: LD_INT 88
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 34
65389: PUSH
65390: LD_INT 14
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 34
65399: PUSH
65400: LD_INT 53
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 34
65409: PUSH
65410: LD_INT 98
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 34
65419: PUSH
65420: LD_INT 31
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 34
65429: PUSH
65430: LD_INT 48
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 34
65439: PUSH
65440: LD_INT 8
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: PPUSH
65463: CALL_OW 72
65467: DIFF
65468: ST_TO_ADDR
// end ; end_of_file
65469: LD_VAR 0 3
65473: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
65474: LD_INT 0
65476: PPUSH
65477: PPUSH
65478: PPUSH
// if not mc_bases or not skirmish then
65479: LD_EXP 102
65483: NOT
65484: PUSH
65485: LD_EXP 100
65489: NOT
65490: OR
65491: IFFALSE 65495
// exit ;
65493: GO 65660
// for i = 1 to mc_bases do
65495: LD_ADDR_VAR 0 4
65499: PUSH
65500: DOUBLE
65501: LD_INT 1
65503: DEC
65504: ST_TO_ADDR
65505: LD_EXP 102
65509: PUSH
65510: FOR_TO
65511: IFFALSE 65658
// begin if sci in mc_bases [ i ] then
65513: LD_VAR 0 2
65517: PUSH
65518: LD_EXP 102
65522: PUSH
65523: LD_VAR 0 4
65527: ARRAY
65528: IN
65529: IFFALSE 65656
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
65531: LD_ADDR_EXP 131
65535: PUSH
65536: LD_EXP 131
65540: PPUSH
65541: LD_VAR 0 4
65545: PUSH
65546: LD_EXP 131
65550: PUSH
65551: LD_VAR 0 4
65555: ARRAY
65556: PUSH
65557: LD_INT 1
65559: PLUS
65560: PUSH
65561: EMPTY
65562: LIST
65563: LIST
65564: PPUSH
65565: LD_VAR 0 1
65569: PPUSH
65570: CALL 75244 0 3
65574: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65575: LD_ADDR_VAR 0 5
65579: PUSH
65580: LD_EXP 102
65584: PUSH
65585: LD_VAR 0 4
65589: ARRAY
65590: PPUSH
65591: LD_INT 2
65593: PUSH
65594: LD_INT 30
65596: PUSH
65597: LD_INT 0
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 30
65606: PUSH
65607: LD_INT 1
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: LIST
65618: PPUSH
65619: CALL_OW 72
65623: PPUSH
65624: LD_VAR 0 1
65628: PPUSH
65629: CALL_OW 74
65633: ST_TO_ADDR
// if tmp then
65634: LD_VAR 0 5
65638: IFFALSE 65654
// ComStandNearbyBuilding ( ape , tmp ) ;
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 5
65649: PPUSH
65650: CALL 71846 0 2
// break ;
65654: GO 65658
// end ; end ;
65656: GO 65510
65658: POP
65659: POP
// end ;
65660: LD_VAR 0 3
65664: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65665: LD_INT 0
65667: PPUSH
65668: PPUSH
65669: PPUSH
// if not mc_bases or not skirmish then
65670: LD_EXP 102
65674: NOT
65675: PUSH
65676: LD_EXP 100
65680: NOT
65681: OR
65682: IFFALSE 65686
// exit ;
65684: GO 65775
// for i = 1 to mc_bases do
65686: LD_ADDR_VAR 0 4
65690: PUSH
65691: DOUBLE
65692: LD_INT 1
65694: DEC
65695: ST_TO_ADDR
65696: LD_EXP 102
65700: PUSH
65701: FOR_TO
65702: IFFALSE 65773
// begin if building in mc_busy_turret_list [ i ] then
65704: LD_VAR 0 1
65708: PUSH
65709: LD_EXP 112
65713: PUSH
65714: LD_VAR 0 4
65718: ARRAY
65719: IN
65720: IFFALSE 65771
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65722: LD_ADDR_VAR 0 5
65726: PUSH
65727: LD_EXP 112
65731: PUSH
65732: LD_VAR 0 4
65736: ARRAY
65737: PUSH
65738: LD_VAR 0 1
65742: DIFF
65743: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65744: LD_ADDR_EXP 112
65748: PUSH
65749: LD_EXP 112
65753: PPUSH
65754: LD_VAR 0 4
65758: PPUSH
65759: LD_VAR 0 5
65763: PPUSH
65764: CALL_OW 1
65768: ST_TO_ADDR
// break ;
65769: GO 65773
// end ; end ;
65771: GO 65701
65773: POP
65774: POP
// end ;
65775: LD_VAR 0 3
65779: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65780: LD_INT 0
65782: PPUSH
65783: PPUSH
65784: PPUSH
// if not mc_bases or not skirmish then
65785: LD_EXP 102
65789: NOT
65790: PUSH
65791: LD_EXP 100
65795: NOT
65796: OR
65797: IFFALSE 65801
// exit ;
65799: GO 66000
// for i = 1 to mc_bases do
65801: LD_ADDR_VAR 0 5
65805: PUSH
65806: DOUBLE
65807: LD_INT 1
65809: DEC
65810: ST_TO_ADDR
65811: LD_EXP 102
65815: PUSH
65816: FOR_TO
65817: IFFALSE 65998
// if building in mc_bases [ i ] then
65819: LD_VAR 0 1
65823: PUSH
65824: LD_EXP 102
65828: PUSH
65829: LD_VAR 0 5
65833: ARRAY
65834: IN
65835: IFFALSE 65996
// begin tmp := mc_bases [ i ] diff building ;
65837: LD_ADDR_VAR 0 6
65841: PUSH
65842: LD_EXP 102
65846: PUSH
65847: LD_VAR 0 5
65851: ARRAY
65852: PUSH
65853: LD_VAR 0 1
65857: DIFF
65858: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65859: LD_ADDR_EXP 102
65863: PUSH
65864: LD_EXP 102
65868: PPUSH
65869: LD_VAR 0 5
65873: PPUSH
65874: LD_VAR 0 6
65878: PPUSH
65879: CALL_OW 1
65883: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65884: LD_VAR 0 1
65888: PUSH
65889: LD_EXP 110
65893: PUSH
65894: LD_VAR 0 5
65898: ARRAY
65899: IN
65900: IFFALSE 65939
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65902: LD_ADDR_EXP 110
65906: PUSH
65907: LD_EXP 110
65911: PPUSH
65912: LD_VAR 0 5
65916: PPUSH
65917: LD_EXP 110
65921: PUSH
65922: LD_VAR 0 5
65926: ARRAY
65927: PUSH
65928: LD_VAR 0 1
65932: DIFF
65933: PPUSH
65934: CALL_OW 1
65938: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65939: LD_VAR 0 1
65943: PUSH
65944: LD_EXP 111
65948: PUSH
65949: LD_VAR 0 5
65953: ARRAY
65954: IN
65955: IFFALSE 65994
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65957: LD_ADDR_EXP 111
65961: PUSH
65962: LD_EXP 111
65966: PPUSH
65967: LD_VAR 0 5
65971: PPUSH
65972: LD_EXP 111
65976: PUSH
65977: LD_VAR 0 5
65981: ARRAY
65982: PUSH
65983: LD_VAR 0 1
65987: DIFF
65988: PPUSH
65989: CALL_OW 1
65993: ST_TO_ADDR
// break ;
65994: GO 65998
// end ;
65996: GO 65816
65998: POP
65999: POP
// end ;
66000: LD_VAR 0 4
66004: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66005: LD_INT 0
66007: PPUSH
66008: PPUSH
66009: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66010: LD_EXP 102
66014: NOT
66015: PUSH
66016: LD_EXP 100
66020: NOT
66021: OR
66022: PUSH
66023: LD_VAR 0 3
66027: PUSH
66028: LD_EXP 128
66032: IN
66033: NOT
66034: OR
66035: IFFALSE 66039
// exit ;
66037: GO 66162
// for i = 1 to mc_vehicles do
66039: LD_ADDR_VAR 0 6
66043: PUSH
66044: DOUBLE
66045: LD_INT 1
66047: DEC
66048: ST_TO_ADDR
66049: LD_EXP 121
66053: PUSH
66054: FOR_TO
66055: IFFALSE 66160
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66057: LD_VAR 0 2
66061: PUSH
66062: LD_EXP 121
66066: PUSH
66067: LD_VAR 0 6
66071: ARRAY
66072: IN
66073: PUSH
66074: LD_VAR 0 1
66078: PUSH
66079: LD_EXP 121
66083: PUSH
66084: LD_VAR 0 6
66088: ARRAY
66089: IN
66090: OR
66091: IFFALSE 66158
// begin tmp := mc_vehicles [ i ] diff old ;
66093: LD_ADDR_VAR 0 7
66097: PUSH
66098: LD_EXP 121
66102: PUSH
66103: LD_VAR 0 6
66107: ARRAY
66108: PUSH
66109: LD_VAR 0 2
66113: DIFF
66114: ST_TO_ADDR
// tmp := tmp diff new ;
66115: LD_ADDR_VAR 0 7
66119: PUSH
66120: LD_VAR 0 7
66124: PUSH
66125: LD_VAR 0 1
66129: DIFF
66130: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66131: LD_ADDR_EXP 121
66135: PUSH
66136: LD_EXP 121
66140: PPUSH
66141: LD_VAR 0 6
66145: PPUSH
66146: LD_VAR 0 7
66150: PPUSH
66151: CALL_OW 1
66155: ST_TO_ADDR
// break ;
66156: GO 66160
// end ;
66158: GO 66054
66160: POP
66161: POP
// end ;
66162: LD_VAR 0 5
66166: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66167: LD_INT 0
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
// if not mc_bases or not skirmish then
66173: LD_EXP 102
66177: NOT
66178: PUSH
66179: LD_EXP 100
66183: NOT
66184: OR
66185: IFFALSE 66189
// exit ;
66187: GO 66609
// repeat wait ( 0 0$1 ) ;
66189: LD_INT 35
66191: PPUSH
66192: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66196: LD_EXP 146
66200: NOT
66201: IFFALSE 66189
// mc_block_vehicle_constructed_thread := true ;
66203: LD_ADDR_EXP 146
66207: PUSH
66208: LD_INT 1
66210: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66211: LD_ADDR_VAR 0 5
66215: PUSH
66216: LD_VAR 0 1
66220: PPUSH
66221: CALL_OW 255
66225: ST_TO_ADDR
// for i = 1 to mc_bases do
66226: LD_ADDR_VAR 0 4
66230: PUSH
66231: DOUBLE
66232: LD_INT 1
66234: DEC
66235: ST_TO_ADDR
66236: LD_EXP 102
66240: PUSH
66241: FOR_TO
66242: IFFALSE 66599
// begin if factory in mc_bases [ i ] then
66244: LD_VAR 0 2
66248: PUSH
66249: LD_EXP 102
66253: PUSH
66254: LD_VAR 0 4
66258: ARRAY
66259: IN
66260: IFFALSE 66597
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66262: LD_EXP 124
66266: PUSH
66267: LD_VAR 0 4
66271: ARRAY
66272: PUSH
66273: LD_EXP 113
66277: PUSH
66278: LD_VAR 0 4
66282: ARRAY
66283: LESS
66284: PUSH
66285: LD_VAR 0 1
66289: PPUSH
66290: CALL_OW 264
66294: PUSH
66295: LD_INT 31
66297: PUSH
66298: LD_INT 32
66300: PUSH
66301: LD_INT 51
66303: PUSH
66304: LD_INT 89
66306: PUSH
66307: LD_INT 12
66309: PUSH
66310: LD_INT 30
66312: PUSH
66313: LD_INT 98
66315: PUSH
66316: LD_INT 11
66318: PUSH
66319: LD_INT 53
66321: PUSH
66322: LD_INT 14
66324: PUSH
66325: LD_INT 91
66327: PUSH
66328: LD_INT 29
66330: PUSH
66331: LD_INT 99
66333: PUSH
66334: LD_INT 13
66336: PUSH
66337: LD_INT 52
66339: PUSH
66340: LD_INT 88
66342: PUSH
66343: LD_INT 48
66345: PUSH
66346: LD_INT 8
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: IN
66369: NOT
66370: AND
66371: IFFALSE 66419
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66373: LD_ADDR_EXP 124
66377: PUSH
66378: LD_EXP 124
66382: PPUSH
66383: LD_VAR 0 4
66387: PUSH
66388: LD_EXP 124
66392: PUSH
66393: LD_VAR 0 4
66397: ARRAY
66398: PUSH
66399: LD_INT 1
66401: PLUS
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PPUSH
66407: LD_VAR 0 1
66411: PPUSH
66412: CALL 75244 0 3
66416: ST_TO_ADDR
66417: GO 66463
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
66419: LD_ADDR_EXP 121
66423: PUSH
66424: LD_EXP 121
66428: PPUSH
66429: LD_VAR 0 4
66433: PUSH
66434: LD_EXP 121
66438: PUSH
66439: LD_VAR 0 4
66443: ARRAY
66444: PUSH
66445: LD_INT 1
66447: PLUS
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PPUSH
66453: LD_VAR 0 1
66457: PPUSH
66458: CALL 75244 0 3
66462: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
66463: LD_ADDR_EXP 146
66467: PUSH
66468: LD_INT 0
66470: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
66471: LD_VAR 0 1
66475: PPUSH
66476: CALL_OW 263
66480: PUSH
66481: LD_INT 2
66483: EQUAL
66484: IFFALSE 66513
// begin repeat wait ( 0 0$3 ) ;
66486: LD_INT 105
66488: PPUSH
66489: CALL_OW 67
// Connect ( vehicle ) ;
66493: LD_VAR 0 1
66497: PPUSH
66498: CALL 78590 0 1
// until IsControledBy ( vehicle ) ;
66502: LD_VAR 0 1
66506: PPUSH
66507: CALL_OW 312
66511: IFFALSE 66486
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
66513: LD_VAR 0 1
66517: PPUSH
66518: LD_EXP 126
66522: PUSH
66523: LD_VAR 0 4
66527: ARRAY
66528: PPUSH
66529: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
66533: LD_VAR 0 1
66537: PPUSH
66538: CALL_OW 263
66542: PUSH
66543: LD_INT 1
66545: NONEQUAL
66546: IFFALSE 66550
// break ;
66548: GO 66599
// repeat wait ( 0 0$1 ) ;
66550: LD_INT 35
66552: PPUSH
66553: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
66557: LD_VAR 0 1
66561: PPUSH
66562: LD_EXP 126
66566: PUSH
66567: LD_VAR 0 4
66571: ARRAY
66572: PPUSH
66573: CALL_OW 308
66577: IFFALSE 66550
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66579: LD_VAR 0 1
66583: PPUSH
66584: CALL_OW 311
66588: PPUSH
66589: CALL_OW 121
// exit ;
66593: POP
66594: POP
66595: GO 66609
// end ; end ;
66597: GO 66241
66599: POP
66600: POP
// mc_block_vehicle_constructed_thread := false ;
66601: LD_ADDR_EXP 146
66605: PUSH
66606: LD_INT 0
66608: ST_TO_ADDR
// end ;
66609: LD_VAR 0 3
66613: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66614: LD_INT 0
66616: PPUSH
66617: PPUSH
66618: PPUSH
66619: PPUSH
// if not mc_bases or not skirmish then
66620: LD_EXP 102
66624: NOT
66625: PUSH
66626: LD_EXP 100
66630: NOT
66631: OR
66632: IFFALSE 66636
// exit ;
66634: GO 66989
// repeat wait ( 0 0$1 ) ;
66636: LD_INT 35
66638: PPUSH
66639: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66643: LD_VAR 0 2
66647: PPUSH
66648: LD_VAR 0 3
66652: PPUSH
66653: CALL_OW 284
66657: IFFALSE 66636
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66659: LD_VAR 0 2
66663: PPUSH
66664: LD_VAR 0 3
66668: PPUSH
66669: CALL_OW 283
66673: PUSH
66674: LD_INT 4
66676: EQUAL
66677: IFFALSE 66681
// exit ;
66679: GO 66989
// for i = 1 to mc_bases do
66681: LD_ADDR_VAR 0 7
66685: PUSH
66686: DOUBLE
66687: LD_INT 1
66689: DEC
66690: ST_TO_ADDR
66691: LD_EXP 102
66695: PUSH
66696: FOR_TO
66697: IFFALSE 66987
// begin if mc_crates_area [ i ] then
66699: LD_EXP 120
66703: PUSH
66704: LD_VAR 0 7
66708: ARRAY
66709: IFFALSE 66820
// for j in mc_crates_area [ i ] do
66711: LD_ADDR_VAR 0 8
66715: PUSH
66716: LD_EXP 120
66720: PUSH
66721: LD_VAR 0 7
66725: ARRAY
66726: PUSH
66727: FOR_IN
66728: IFFALSE 66818
// if InArea ( x , y , j ) then
66730: LD_VAR 0 2
66734: PPUSH
66735: LD_VAR 0 3
66739: PPUSH
66740: LD_VAR 0 8
66744: PPUSH
66745: CALL_OW 309
66749: IFFALSE 66816
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66751: LD_ADDR_EXP 118
66755: PUSH
66756: LD_EXP 118
66760: PPUSH
66761: LD_VAR 0 7
66765: PUSH
66766: LD_EXP 118
66770: PUSH
66771: LD_VAR 0 7
66775: ARRAY
66776: PUSH
66777: LD_INT 1
66779: PLUS
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PPUSH
66785: LD_VAR 0 4
66789: PUSH
66790: LD_VAR 0 2
66794: PUSH
66795: LD_VAR 0 3
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: LIST
66804: PPUSH
66805: CALL 75244 0 3
66809: ST_TO_ADDR
// exit ;
66810: POP
66811: POP
66812: POP
66813: POP
66814: GO 66989
// end ;
66816: GO 66727
66818: POP
66819: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66820: LD_ADDR_VAR 0 9
66824: PUSH
66825: LD_EXP 102
66829: PUSH
66830: LD_VAR 0 7
66834: ARRAY
66835: PPUSH
66836: LD_INT 2
66838: PUSH
66839: LD_INT 30
66841: PUSH
66842: LD_INT 0
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 30
66851: PUSH
66852: LD_INT 1
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: LIST
66863: PPUSH
66864: CALL_OW 72
66868: ST_TO_ADDR
// if not depot then
66869: LD_VAR 0 9
66873: NOT
66874: IFFALSE 66878
// continue ;
66876: GO 66696
// for j in depot do
66878: LD_ADDR_VAR 0 8
66882: PUSH
66883: LD_VAR 0 9
66887: PUSH
66888: FOR_IN
66889: IFFALSE 66983
// if GetDistUnitXY ( j , x , y ) < 30 then
66891: LD_VAR 0 8
66895: PPUSH
66896: LD_VAR 0 2
66900: PPUSH
66901: LD_VAR 0 3
66905: PPUSH
66906: CALL_OW 297
66910: PUSH
66911: LD_INT 30
66913: LESS
66914: IFFALSE 66981
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66916: LD_ADDR_EXP 118
66920: PUSH
66921: LD_EXP 118
66925: PPUSH
66926: LD_VAR 0 7
66930: PUSH
66931: LD_EXP 118
66935: PUSH
66936: LD_VAR 0 7
66940: ARRAY
66941: PUSH
66942: LD_INT 1
66944: PLUS
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PPUSH
66950: LD_VAR 0 4
66954: PUSH
66955: LD_VAR 0 2
66959: PUSH
66960: LD_VAR 0 3
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: LIST
66969: PPUSH
66970: CALL 75244 0 3
66974: ST_TO_ADDR
// exit ;
66975: POP
66976: POP
66977: POP
66978: POP
66979: GO 66989
// end ;
66981: GO 66888
66983: POP
66984: POP
// end ;
66985: GO 66696
66987: POP
66988: POP
// end ;
66989: LD_VAR 0 6
66993: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66994: LD_INT 0
66996: PPUSH
66997: PPUSH
66998: PPUSH
66999: PPUSH
// if not mc_bases or not skirmish then
67000: LD_EXP 102
67004: NOT
67005: PUSH
67006: LD_EXP 100
67010: NOT
67011: OR
67012: IFFALSE 67016
// exit ;
67014: GO 67293
// side := GetSide ( lab ) ;
67016: LD_ADDR_VAR 0 4
67020: PUSH
67021: LD_VAR 0 2
67025: PPUSH
67026: CALL_OW 255
67030: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67031: LD_VAR 0 4
67035: PUSH
67036: LD_EXP 128
67040: IN
67041: NOT
67042: PUSH
67043: LD_EXP 129
67047: NOT
67048: OR
67049: PUSH
67050: LD_EXP 102
67054: NOT
67055: OR
67056: IFFALSE 67060
// exit ;
67058: GO 67293
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67060: LD_ADDR_EXP 129
67064: PUSH
67065: LD_EXP 129
67069: PPUSH
67070: LD_VAR 0 4
67074: PPUSH
67075: LD_EXP 129
67079: PUSH
67080: LD_VAR 0 4
67084: ARRAY
67085: PUSH
67086: LD_VAR 0 1
67090: DIFF
67091: PPUSH
67092: CALL_OW 1
67096: ST_TO_ADDR
// for i = 1 to mc_bases do
67097: LD_ADDR_VAR 0 5
67101: PUSH
67102: DOUBLE
67103: LD_INT 1
67105: DEC
67106: ST_TO_ADDR
67107: LD_EXP 102
67111: PUSH
67112: FOR_TO
67113: IFFALSE 67291
// begin if lab in mc_bases [ i ] then
67115: LD_VAR 0 2
67119: PUSH
67120: LD_EXP 102
67124: PUSH
67125: LD_VAR 0 5
67129: ARRAY
67130: IN
67131: IFFALSE 67289
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67133: LD_VAR 0 1
67137: PUSH
67138: LD_INT 11
67140: PUSH
67141: LD_INT 4
67143: PUSH
67144: LD_INT 3
67146: PUSH
67147: LD_INT 2
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: IN
67156: PUSH
67157: LD_EXP 132
67161: PUSH
67162: LD_VAR 0 5
67166: ARRAY
67167: AND
67168: IFFALSE 67289
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67170: LD_ADDR_VAR 0 6
67174: PUSH
67175: LD_EXP 132
67179: PUSH
67180: LD_VAR 0 5
67184: ARRAY
67185: PUSH
67186: LD_INT 1
67188: ARRAY
67189: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67190: LD_ADDR_EXP 132
67194: PUSH
67195: LD_EXP 132
67199: PPUSH
67200: LD_VAR 0 5
67204: PPUSH
67205: EMPTY
67206: PPUSH
67207: CALL_OW 1
67211: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67212: LD_VAR 0 6
67216: PPUSH
67217: LD_INT 0
67219: PPUSH
67220: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67224: LD_VAR 0 6
67228: PPUSH
67229: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67233: LD_ADDR_EXP 131
67237: PUSH
67238: LD_EXP 131
67242: PPUSH
67243: LD_VAR 0 5
67247: PPUSH
67248: LD_EXP 131
67252: PUSH
67253: LD_VAR 0 5
67257: ARRAY
67258: PPUSH
67259: LD_INT 1
67261: PPUSH
67262: LD_VAR 0 6
67266: PPUSH
67267: CALL_OW 2
67271: PPUSH
67272: CALL_OW 1
67276: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67277: LD_VAR 0 5
67281: PPUSH
67282: LD_INT 112
67284: PPUSH
67285: CALL 43743 0 2
// end ; end ; end ;
67289: GO 67112
67291: POP
67292: POP
// end ;
67293: LD_VAR 0 3
67297: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67298: LD_INT 0
67300: PPUSH
67301: PPUSH
67302: PPUSH
67303: PPUSH
67304: PPUSH
67305: PPUSH
67306: PPUSH
67307: PPUSH
// if not mc_bases or not skirmish then
67308: LD_EXP 102
67312: NOT
67313: PUSH
67314: LD_EXP 100
67318: NOT
67319: OR
67320: IFFALSE 67324
// exit ;
67322: GO 68693
// for i = 1 to mc_bases do
67324: LD_ADDR_VAR 0 3
67328: PUSH
67329: DOUBLE
67330: LD_INT 1
67332: DEC
67333: ST_TO_ADDR
67334: LD_EXP 102
67338: PUSH
67339: FOR_TO
67340: IFFALSE 68691
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67342: LD_VAR 0 1
67346: PUSH
67347: LD_EXP 102
67351: PUSH
67352: LD_VAR 0 3
67356: ARRAY
67357: IN
67358: PUSH
67359: LD_VAR 0 1
67363: PUSH
67364: LD_EXP 109
67368: PUSH
67369: LD_VAR 0 3
67373: ARRAY
67374: IN
67375: OR
67376: PUSH
67377: LD_VAR 0 1
67381: PUSH
67382: LD_EXP 124
67386: PUSH
67387: LD_VAR 0 3
67391: ARRAY
67392: IN
67393: OR
67394: PUSH
67395: LD_VAR 0 1
67399: PUSH
67400: LD_EXP 121
67404: PUSH
67405: LD_VAR 0 3
67409: ARRAY
67410: IN
67411: OR
67412: PUSH
67413: LD_VAR 0 1
67417: PUSH
67418: LD_EXP 131
67422: PUSH
67423: LD_VAR 0 3
67427: ARRAY
67428: IN
67429: OR
67430: PUSH
67431: LD_VAR 0 1
67435: PUSH
67436: LD_EXP 132
67440: PUSH
67441: LD_VAR 0 3
67445: ARRAY
67446: IN
67447: OR
67448: IFFALSE 68689
// begin if un in mc_ape [ i ] then
67450: LD_VAR 0 1
67454: PUSH
67455: LD_EXP 131
67459: PUSH
67460: LD_VAR 0 3
67464: ARRAY
67465: IN
67466: IFFALSE 67505
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
67468: LD_ADDR_EXP 131
67472: PUSH
67473: LD_EXP 131
67477: PPUSH
67478: LD_VAR 0 3
67482: PPUSH
67483: LD_EXP 131
67487: PUSH
67488: LD_VAR 0 3
67492: ARRAY
67493: PUSH
67494: LD_VAR 0 1
67498: DIFF
67499: PPUSH
67500: CALL_OW 1
67504: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
67505: LD_VAR 0 1
67509: PUSH
67510: LD_EXP 132
67514: PUSH
67515: LD_VAR 0 3
67519: ARRAY
67520: IN
67521: IFFALSE 67545
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67523: LD_ADDR_EXP 132
67527: PUSH
67528: LD_EXP 132
67532: PPUSH
67533: LD_VAR 0 3
67537: PPUSH
67538: EMPTY
67539: PPUSH
67540: CALL_OW 1
67544: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
67545: LD_VAR 0 1
67549: PPUSH
67550: CALL_OW 247
67554: PUSH
67555: LD_INT 2
67557: EQUAL
67558: PUSH
67559: LD_VAR 0 1
67563: PPUSH
67564: CALL_OW 110
67568: PUSH
67569: LD_INT 20
67571: EQUAL
67572: PUSH
67573: LD_VAR 0 1
67577: PUSH
67578: LD_EXP 124
67582: PUSH
67583: LD_VAR 0 3
67587: ARRAY
67588: IN
67589: OR
67590: PUSH
67591: LD_VAR 0 1
67595: PPUSH
67596: CALL_OW 264
67600: PUSH
67601: LD_INT 12
67603: PUSH
67604: LD_INT 51
67606: PUSH
67607: LD_INT 89
67609: PUSH
67610: LD_INT 32
67612: PUSH
67613: LD_INT 13
67615: PUSH
67616: LD_INT 52
67618: PUSH
67619: LD_INT 31
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: IN
67631: OR
67632: AND
67633: IFFALSE 67941
// begin if un in mc_defender [ i ] then
67635: LD_VAR 0 1
67639: PUSH
67640: LD_EXP 124
67644: PUSH
67645: LD_VAR 0 3
67649: ARRAY
67650: IN
67651: IFFALSE 67690
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67653: LD_ADDR_EXP 124
67657: PUSH
67658: LD_EXP 124
67662: PPUSH
67663: LD_VAR 0 3
67667: PPUSH
67668: LD_EXP 124
67672: PUSH
67673: LD_VAR 0 3
67677: ARRAY
67678: PUSH
67679: LD_VAR 0 1
67683: DIFF
67684: PPUSH
67685: CALL_OW 1
67689: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67690: LD_ADDR_VAR 0 8
67694: PUSH
67695: LD_VAR 0 3
67699: PPUSH
67700: LD_INT 3
67702: PPUSH
67703: CALL 64311 0 2
67707: ST_TO_ADDR
// if fac then
67708: LD_VAR 0 8
67712: IFFALSE 67941
// begin for j in fac do
67714: LD_ADDR_VAR 0 4
67718: PUSH
67719: LD_VAR 0 8
67723: PUSH
67724: FOR_IN
67725: IFFALSE 67939
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67727: LD_ADDR_VAR 0 9
67731: PUSH
67732: LD_VAR 0 8
67736: PPUSH
67737: LD_VAR 0 1
67741: PPUSH
67742: CALL_OW 265
67746: PPUSH
67747: LD_VAR 0 1
67751: PPUSH
67752: CALL_OW 262
67756: PPUSH
67757: LD_VAR 0 1
67761: PPUSH
67762: CALL_OW 263
67766: PPUSH
67767: LD_VAR 0 1
67771: PPUSH
67772: CALL_OW 264
67776: PPUSH
67777: CALL 72742 0 5
67781: ST_TO_ADDR
// if components then
67782: LD_VAR 0 9
67786: IFFALSE 67937
// begin if GetWeapon ( un ) = ar_control_tower then
67788: LD_VAR 0 1
67792: PPUSH
67793: CALL_OW 264
67797: PUSH
67798: LD_INT 31
67800: EQUAL
67801: IFFALSE 67918
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67803: LD_VAR 0 1
67807: PPUSH
67808: CALL_OW 311
67812: PPUSH
67813: LD_INT 0
67815: PPUSH
67816: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67820: LD_ADDR_EXP 142
67824: PUSH
67825: LD_EXP 142
67829: PPUSH
67830: LD_VAR 0 3
67834: PPUSH
67835: LD_EXP 142
67839: PUSH
67840: LD_VAR 0 3
67844: ARRAY
67845: PUSH
67846: LD_VAR 0 1
67850: PPUSH
67851: CALL_OW 311
67855: DIFF
67856: PPUSH
67857: CALL_OW 1
67861: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67862: LD_ADDR_VAR 0 7
67866: PUSH
67867: LD_EXP 123
67871: PUSH
67872: LD_VAR 0 3
67876: ARRAY
67877: PPUSH
67878: LD_INT 1
67880: PPUSH
67881: LD_VAR 0 9
67885: PPUSH
67886: CALL_OW 2
67890: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67891: LD_ADDR_EXP 123
67895: PUSH
67896: LD_EXP 123
67900: PPUSH
67901: LD_VAR 0 3
67905: PPUSH
67906: LD_VAR 0 7
67910: PPUSH
67911: CALL_OW 1
67915: ST_TO_ADDR
// end else
67916: GO 67935
// MC_InsertProduceList ( i , [ components ] ) ;
67918: LD_VAR 0 3
67922: PPUSH
67923: LD_VAR 0 9
67927: PUSH
67928: EMPTY
67929: LIST
67930: PPUSH
67931: CALL 63856 0 2
// break ;
67935: GO 67939
// end ; end ;
67937: GO 67724
67939: POP
67940: POP
// end ; end ; if GetType ( un ) = unit_building then
67941: LD_VAR 0 1
67945: PPUSH
67946: CALL_OW 247
67950: PUSH
67951: LD_INT 3
67953: EQUAL
67954: IFFALSE 68357
// begin btype := GetBType ( un ) ;
67956: LD_ADDR_VAR 0 5
67960: PUSH
67961: LD_VAR 0 1
67965: PPUSH
67966: CALL_OW 266
67970: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67971: LD_VAR 0 5
67975: PUSH
67976: LD_INT 29
67978: PUSH
67979: LD_INT 30
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: IN
67986: IFFALSE 68059
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67988: LD_VAR 0 1
67992: PPUSH
67993: CALL_OW 250
67997: PPUSH
67998: LD_VAR 0 1
68002: PPUSH
68003: CALL_OW 251
68007: PPUSH
68008: LD_VAR 0 1
68012: PPUSH
68013: CALL_OW 255
68017: PPUSH
68018: CALL_OW 440
68022: NOT
68023: IFFALSE 68059
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68025: LD_VAR 0 1
68029: PPUSH
68030: CALL_OW 250
68034: PPUSH
68035: LD_VAR 0 1
68039: PPUSH
68040: CALL_OW 251
68044: PPUSH
68045: LD_VAR 0 1
68049: PPUSH
68050: CALL_OW 255
68054: PPUSH
68055: CALL_OW 441
// end ; if btype = b_warehouse then
68059: LD_VAR 0 5
68063: PUSH
68064: LD_INT 1
68066: EQUAL
68067: IFFALSE 68085
// begin btype := b_depot ;
68069: LD_ADDR_VAR 0 5
68073: PUSH
68074: LD_INT 0
68076: ST_TO_ADDR
// pos := 1 ;
68077: LD_ADDR_VAR 0 6
68081: PUSH
68082: LD_INT 1
68084: ST_TO_ADDR
// end ; if btype = b_factory then
68085: LD_VAR 0 5
68089: PUSH
68090: LD_INT 3
68092: EQUAL
68093: IFFALSE 68111
// begin btype := b_workshop ;
68095: LD_ADDR_VAR 0 5
68099: PUSH
68100: LD_INT 2
68102: ST_TO_ADDR
// pos := 1 ;
68103: LD_ADDR_VAR 0 6
68107: PUSH
68108: LD_INT 1
68110: ST_TO_ADDR
// end ; if btype = b_barracks then
68111: LD_VAR 0 5
68115: PUSH
68116: LD_INT 5
68118: EQUAL
68119: IFFALSE 68129
// btype := b_armoury ;
68121: LD_ADDR_VAR 0 5
68125: PUSH
68126: LD_INT 4
68128: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68129: LD_VAR 0 5
68133: PUSH
68134: LD_INT 7
68136: PUSH
68137: LD_INT 8
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: IN
68144: IFFALSE 68154
// btype := b_lab ;
68146: LD_ADDR_VAR 0 5
68150: PUSH
68151: LD_INT 6
68153: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68154: LD_ADDR_EXP 107
68158: PUSH
68159: LD_EXP 107
68163: PPUSH
68164: LD_VAR 0 3
68168: PUSH
68169: LD_EXP 107
68173: PUSH
68174: LD_VAR 0 3
68178: ARRAY
68179: PUSH
68180: LD_INT 1
68182: PLUS
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PPUSH
68188: LD_VAR 0 5
68192: PUSH
68193: LD_VAR 0 1
68197: PPUSH
68198: CALL_OW 250
68202: PUSH
68203: LD_VAR 0 1
68207: PPUSH
68208: CALL_OW 251
68212: PUSH
68213: LD_VAR 0 1
68217: PPUSH
68218: CALL_OW 254
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: PPUSH
68229: CALL 75244 0 3
68233: ST_TO_ADDR
// if pos = 1 then
68234: LD_VAR 0 6
68238: PUSH
68239: LD_INT 1
68241: EQUAL
68242: IFFALSE 68357
// begin tmp := mc_build_list [ i ] ;
68244: LD_ADDR_VAR 0 7
68248: PUSH
68249: LD_EXP 107
68253: PUSH
68254: LD_VAR 0 3
68258: ARRAY
68259: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68260: LD_VAR 0 7
68264: PPUSH
68265: LD_INT 2
68267: PUSH
68268: LD_INT 30
68270: PUSH
68271: LD_INT 0
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 30
68280: PUSH
68281: LD_INT 1
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: LIST
68292: PPUSH
68293: CALL_OW 72
68297: IFFALSE 68307
// pos := 2 ;
68299: LD_ADDR_VAR 0 6
68303: PUSH
68304: LD_INT 2
68306: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68307: LD_ADDR_VAR 0 7
68311: PUSH
68312: LD_VAR 0 7
68316: PPUSH
68317: LD_VAR 0 6
68321: PPUSH
68322: LD_VAR 0 7
68326: PPUSH
68327: CALL 75570 0 3
68331: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68332: LD_ADDR_EXP 107
68336: PUSH
68337: LD_EXP 107
68341: PPUSH
68342: LD_VAR 0 3
68346: PPUSH
68347: LD_VAR 0 7
68351: PPUSH
68352: CALL_OW 1
68356: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68357: LD_VAR 0 1
68361: PUSH
68362: LD_EXP 102
68366: PUSH
68367: LD_VAR 0 3
68371: ARRAY
68372: IN
68373: IFFALSE 68412
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
68375: LD_ADDR_EXP 102
68379: PUSH
68380: LD_EXP 102
68384: PPUSH
68385: LD_VAR 0 3
68389: PPUSH
68390: LD_EXP 102
68394: PUSH
68395: LD_VAR 0 3
68399: ARRAY
68400: PUSH
68401: LD_VAR 0 1
68405: DIFF
68406: PPUSH
68407: CALL_OW 1
68411: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
68412: LD_VAR 0 1
68416: PUSH
68417: LD_EXP 109
68421: PUSH
68422: LD_VAR 0 3
68426: ARRAY
68427: IN
68428: IFFALSE 68467
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
68430: LD_ADDR_EXP 109
68434: PUSH
68435: LD_EXP 109
68439: PPUSH
68440: LD_VAR 0 3
68444: PPUSH
68445: LD_EXP 109
68449: PUSH
68450: LD_VAR 0 3
68454: ARRAY
68455: PUSH
68456: LD_VAR 0 1
68460: DIFF
68461: PPUSH
68462: CALL_OW 1
68466: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
68467: LD_VAR 0 1
68471: PUSH
68472: LD_EXP 121
68476: PUSH
68477: LD_VAR 0 3
68481: ARRAY
68482: IN
68483: IFFALSE 68522
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
68485: LD_ADDR_EXP 121
68489: PUSH
68490: LD_EXP 121
68494: PPUSH
68495: LD_VAR 0 3
68499: PPUSH
68500: LD_EXP 121
68504: PUSH
68505: LD_VAR 0 3
68509: ARRAY
68510: PUSH
68511: LD_VAR 0 1
68515: DIFF
68516: PPUSH
68517: CALL_OW 1
68521: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
68522: LD_VAR 0 1
68526: PUSH
68527: LD_EXP 124
68531: PUSH
68532: LD_VAR 0 3
68536: ARRAY
68537: IN
68538: IFFALSE 68577
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68540: LD_ADDR_EXP 124
68544: PUSH
68545: LD_EXP 124
68549: PPUSH
68550: LD_VAR 0 3
68554: PPUSH
68555: LD_EXP 124
68559: PUSH
68560: LD_VAR 0 3
68564: ARRAY
68565: PUSH
68566: LD_VAR 0 1
68570: DIFF
68571: PPUSH
68572: CALL_OW 1
68576: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68577: LD_VAR 0 1
68581: PUSH
68582: LD_EXP 111
68586: PUSH
68587: LD_VAR 0 3
68591: ARRAY
68592: IN
68593: IFFALSE 68632
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68595: LD_ADDR_EXP 111
68599: PUSH
68600: LD_EXP 111
68604: PPUSH
68605: LD_VAR 0 3
68609: PPUSH
68610: LD_EXP 111
68614: PUSH
68615: LD_VAR 0 3
68619: ARRAY
68620: PUSH
68621: LD_VAR 0 1
68625: DIFF
68626: PPUSH
68627: CALL_OW 1
68631: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68632: LD_VAR 0 1
68636: PUSH
68637: LD_EXP 110
68641: PUSH
68642: LD_VAR 0 3
68646: ARRAY
68647: IN
68648: IFFALSE 68687
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68650: LD_ADDR_EXP 110
68654: PUSH
68655: LD_EXP 110
68659: PPUSH
68660: LD_VAR 0 3
68664: PPUSH
68665: LD_EXP 110
68669: PUSH
68670: LD_VAR 0 3
68674: ARRAY
68675: PUSH
68676: LD_VAR 0 1
68680: DIFF
68681: PPUSH
68682: CALL_OW 1
68686: ST_TO_ADDR
// end ; break ;
68687: GO 68691
// end ;
68689: GO 67339
68691: POP
68692: POP
// end ;
68693: LD_VAR 0 2
68697: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68698: LD_INT 0
68700: PPUSH
68701: PPUSH
68702: PPUSH
// if not mc_bases or not skirmish then
68703: LD_EXP 102
68707: NOT
68708: PUSH
68709: LD_EXP 100
68713: NOT
68714: OR
68715: IFFALSE 68719
// exit ;
68717: GO 68934
// for i = 1 to mc_bases do
68719: LD_ADDR_VAR 0 3
68723: PUSH
68724: DOUBLE
68725: LD_INT 1
68727: DEC
68728: ST_TO_ADDR
68729: LD_EXP 102
68733: PUSH
68734: FOR_TO
68735: IFFALSE 68932
// begin if building in mc_construct_list [ i ] then
68737: LD_VAR 0 1
68741: PUSH
68742: LD_EXP 109
68746: PUSH
68747: LD_VAR 0 3
68751: ARRAY
68752: IN
68753: IFFALSE 68930
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68755: LD_ADDR_EXP 109
68759: PUSH
68760: LD_EXP 109
68764: PPUSH
68765: LD_VAR 0 3
68769: PPUSH
68770: LD_EXP 109
68774: PUSH
68775: LD_VAR 0 3
68779: ARRAY
68780: PUSH
68781: LD_VAR 0 1
68785: DIFF
68786: PPUSH
68787: CALL_OW 1
68791: ST_TO_ADDR
// if building in mc_lab [ i ] then
68792: LD_VAR 0 1
68796: PUSH
68797: LD_EXP 135
68801: PUSH
68802: LD_VAR 0 3
68806: ARRAY
68807: IN
68808: IFFALSE 68863
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68810: LD_ADDR_EXP 136
68814: PUSH
68815: LD_EXP 136
68819: PPUSH
68820: LD_VAR 0 3
68824: PPUSH
68825: LD_EXP 136
68829: PUSH
68830: LD_VAR 0 3
68834: ARRAY
68835: PPUSH
68836: LD_INT 1
68838: PPUSH
68839: LD_EXP 136
68843: PUSH
68844: LD_VAR 0 3
68848: ARRAY
68849: PPUSH
68850: LD_INT 0
68852: PPUSH
68853: CALL 74662 0 4
68857: PPUSH
68858: CALL_OW 1
68862: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68863: LD_VAR 0 1
68867: PUSH
68868: LD_EXP 102
68872: PUSH
68873: LD_VAR 0 3
68877: ARRAY
68878: IN
68879: NOT
68880: IFFALSE 68926
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68882: LD_ADDR_EXP 102
68886: PUSH
68887: LD_EXP 102
68891: PPUSH
68892: LD_VAR 0 3
68896: PUSH
68897: LD_EXP 102
68901: PUSH
68902: LD_VAR 0 3
68906: ARRAY
68907: PUSH
68908: LD_INT 1
68910: PLUS
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PPUSH
68916: LD_VAR 0 1
68920: PPUSH
68921: CALL 75244 0 3
68925: ST_TO_ADDR
// exit ;
68926: POP
68927: POP
68928: GO 68934
// end ; end ;
68930: GO 68734
68932: POP
68933: POP
// end ;
68934: LD_VAR 0 2
68938: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68939: LD_INT 0
68941: PPUSH
68942: PPUSH
68943: PPUSH
68944: PPUSH
68945: PPUSH
68946: PPUSH
68947: PPUSH
// if not mc_bases or not skirmish then
68948: LD_EXP 102
68952: NOT
68953: PUSH
68954: LD_EXP 100
68958: NOT
68959: OR
68960: IFFALSE 68964
// exit ;
68962: GO 69625
// for i = 1 to mc_bases do
68964: LD_ADDR_VAR 0 3
68968: PUSH
68969: DOUBLE
68970: LD_INT 1
68972: DEC
68973: ST_TO_ADDR
68974: LD_EXP 102
68978: PUSH
68979: FOR_TO
68980: IFFALSE 69623
// begin if building in mc_construct_list [ i ] then
68982: LD_VAR 0 1
68986: PUSH
68987: LD_EXP 109
68991: PUSH
68992: LD_VAR 0 3
68996: ARRAY
68997: IN
68998: IFFALSE 69621
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69000: LD_ADDR_EXP 109
69004: PUSH
69005: LD_EXP 109
69009: PPUSH
69010: LD_VAR 0 3
69014: PPUSH
69015: LD_EXP 109
69019: PUSH
69020: LD_VAR 0 3
69024: ARRAY
69025: PUSH
69026: LD_VAR 0 1
69030: DIFF
69031: PPUSH
69032: CALL_OW 1
69036: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69037: LD_ADDR_EXP 102
69041: PUSH
69042: LD_EXP 102
69046: PPUSH
69047: LD_VAR 0 3
69051: PUSH
69052: LD_EXP 102
69056: PUSH
69057: LD_VAR 0 3
69061: ARRAY
69062: PUSH
69063: LD_INT 1
69065: PLUS
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PPUSH
69071: LD_VAR 0 1
69075: PPUSH
69076: CALL 75244 0 3
69080: ST_TO_ADDR
// btype := GetBType ( building ) ;
69081: LD_ADDR_VAR 0 5
69085: PUSH
69086: LD_VAR 0 1
69090: PPUSH
69091: CALL_OW 266
69095: ST_TO_ADDR
// side := GetSide ( building ) ;
69096: LD_ADDR_VAR 0 8
69100: PUSH
69101: LD_VAR 0 1
69105: PPUSH
69106: CALL_OW 255
69110: ST_TO_ADDR
// if btype = b_lab then
69111: LD_VAR 0 5
69115: PUSH
69116: LD_INT 6
69118: EQUAL
69119: IFFALSE 69169
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69121: LD_ADDR_EXP 135
69125: PUSH
69126: LD_EXP 135
69130: PPUSH
69131: LD_VAR 0 3
69135: PUSH
69136: LD_EXP 135
69140: PUSH
69141: LD_VAR 0 3
69145: ARRAY
69146: PUSH
69147: LD_INT 1
69149: PLUS
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PPUSH
69155: LD_VAR 0 1
69159: PPUSH
69160: CALL 75244 0 3
69164: ST_TO_ADDR
// exit ;
69165: POP
69166: POP
69167: GO 69625
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69169: LD_VAR 0 5
69173: PUSH
69174: LD_INT 0
69176: PUSH
69177: LD_INT 2
69179: PUSH
69180: LD_INT 4
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: LIST
69187: IN
69188: IFFALSE 69312
// begin if btype = b_armoury then
69190: LD_VAR 0 5
69194: PUSH
69195: LD_INT 4
69197: EQUAL
69198: IFFALSE 69208
// btype := b_barracks ;
69200: LD_ADDR_VAR 0 5
69204: PUSH
69205: LD_INT 5
69207: ST_TO_ADDR
// if btype = b_depot then
69208: LD_VAR 0 5
69212: PUSH
69213: LD_INT 0
69215: EQUAL
69216: IFFALSE 69226
// btype := b_warehouse ;
69218: LD_ADDR_VAR 0 5
69222: PUSH
69223: LD_INT 1
69225: ST_TO_ADDR
// if btype = b_workshop then
69226: LD_VAR 0 5
69230: PUSH
69231: LD_INT 2
69233: EQUAL
69234: IFFALSE 69244
// btype := b_factory ;
69236: LD_ADDR_VAR 0 5
69240: PUSH
69241: LD_INT 3
69243: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69244: LD_VAR 0 5
69248: PPUSH
69249: LD_VAR 0 8
69253: PPUSH
69254: CALL_OW 323
69258: PUSH
69259: LD_INT 1
69261: EQUAL
69262: IFFALSE 69308
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69264: LD_ADDR_EXP 134
69268: PUSH
69269: LD_EXP 134
69273: PPUSH
69274: LD_VAR 0 3
69278: PUSH
69279: LD_EXP 134
69283: PUSH
69284: LD_VAR 0 3
69288: ARRAY
69289: PUSH
69290: LD_INT 1
69292: PLUS
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PPUSH
69298: LD_VAR 0 1
69302: PPUSH
69303: CALL 75244 0 3
69307: ST_TO_ADDR
// exit ;
69308: POP
69309: POP
69310: GO 69625
// end ; if btype in [ b_bunker , b_turret ] then
69312: LD_VAR 0 5
69316: PUSH
69317: LD_INT 32
69319: PUSH
69320: LD_INT 33
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: IN
69327: IFFALSE 69617
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69329: LD_ADDR_EXP 110
69333: PUSH
69334: LD_EXP 110
69338: PPUSH
69339: LD_VAR 0 3
69343: PUSH
69344: LD_EXP 110
69348: PUSH
69349: LD_VAR 0 3
69353: ARRAY
69354: PUSH
69355: LD_INT 1
69357: PLUS
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PPUSH
69363: LD_VAR 0 1
69367: PPUSH
69368: CALL 75244 0 3
69372: ST_TO_ADDR
// if btype = b_bunker then
69373: LD_VAR 0 5
69377: PUSH
69378: LD_INT 32
69380: EQUAL
69381: IFFALSE 69617
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69383: LD_ADDR_EXP 111
69387: PUSH
69388: LD_EXP 111
69392: PPUSH
69393: LD_VAR 0 3
69397: PUSH
69398: LD_EXP 111
69402: PUSH
69403: LD_VAR 0 3
69407: ARRAY
69408: PUSH
69409: LD_INT 1
69411: PLUS
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PPUSH
69417: LD_VAR 0 1
69421: PPUSH
69422: CALL 75244 0 3
69426: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
69427: LD_ADDR_VAR 0 6
69431: PUSH
69432: LD_EXP 102
69436: PUSH
69437: LD_VAR 0 3
69441: ARRAY
69442: PPUSH
69443: LD_INT 25
69445: PUSH
69446: LD_INT 1
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 3
69455: PUSH
69456: LD_INT 54
69458: PUSH
69459: EMPTY
69460: LIST
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PPUSH
69470: CALL_OW 72
69474: ST_TO_ADDR
// if tmp then
69475: LD_VAR 0 6
69479: IFFALSE 69485
// exit ;
69481: POP
69482: POP
69483: GO 69625
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69485: LD_ADDR_VAR 0 6
69489: PUSH
69490: LD_EXP 102
69494: PUSH
69495: LD_VAR 0 3
69499: ARRAY
69500: PPUSH
69501: LD_INT 2
69503: PUSH
69504: LD_INT 30
69506: PUSH
69507: LD_INT 4
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 30
69516: PUSH
69517: LD_INT 5
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: LIST
69528: PPUSH
69529: CALL_OW 72
69533: ST_TO_ADDR
// if not tmp then
69534: LD_VAR 0 6
69538: NOT
69539: IFFALSE 69545
// exit ;
69541: POP
69542: POP
69543: GO 69625
// for j in tmp do
69545: LD_ADDR_VAR 0 4
69549: PUSH
69550: LD_VAR 0 6
69554: PUSH
69555: FOR_IN
69556: IFFALSE 69615
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
69558: LD_ADDR_VAR 0 7
69562: PUSH
69563: LD_VAR 0 4
69567: PPUSH
69568: CALL_OW 313
69572: PPUSH
69573: LD_INT 25
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PPUSH
69583: CALL_OW 72
69587: ST_TO_ADDR
// if units then
69588: LD_VAR 0 7
69592: IFFALSE 69613
// begin ComExitBuilding ( units [ 1 ] ) ;
69594: LD_VAR 0 7
69598: PUSH
69599: LD_INT 1
69601: ARRAY
69602: PPUSH
69603: CALL_OW 122
// exit ;
69607: POP
69608: POP
69609: POP
69610: POP
69611: GO 69625
// end ; end ;
69613: GO 69555
69615: POP
69616: POP
// end ; end ; exit ;
69617: POP
69618: POP
69619: GO 69625
// end ; end ;
69621: GO 68979
69623: POP
69624: POP
// end ;
69625: LD_VAR 0 2
69629: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69630: LD_INT 0
69632: PPUSH
69633: PPUSH
69634: PPUSH
69635: PPUSH
69636: PPUSH
69637: PPUSH
69638: PPUSH
// if not mc_bases or not skirmish then
69639: LD_EXP 102
69643: NOT
69644: PUSH
69645: LD_EXP 100
69649: NOT
69650: OR
69651: IFFALSE 69655
// exit ;
69653: GO 69920
// btype := GetBType ( building ) ;
69655: LD_ADDR_VAR 0 6
69659: PUSH
69660: LD_VAR 0 1
69664: PPUSH
69665: CALL_OW 266
69669: ST_TO_ADDR
// x := GetX ( building ) ;
69670: LD_ADDR_VAR 0 7
69674: PUSH
69675: LD_VAR 0 1
69679: PPUSH
69680: CALL_OW 250
69684: ST_TO_ADDR
// y := GetY ( building ) ;
69685: LD_ADDR_VAR 0 8
69689: PUSH
69690: LD_VAR 0 1
69694: PPUSH
69695: CALL_OW 251
69699: ST_TO_ADDR
// d := GetDir ( building ) ;
69700: LD_ADDR_VAR 0 9
69704: PUSH
69705: LD_VAR 0 1
69709: PPUSH
69710: CALL_OW 254
69714: ST_TO_ADDR
// for i = 1 to mc_bases do
69715: LD_ADDR_VAR 0 4
69719: PUSH
69720: DOUBLE
69721: LD_INT 1
69723: DEC
69724: ST_TO_ADDR
69725: LD_EXP 102
69729: PUSH
69730: FOR_TO
69731: IFFALSE 69918
// begin if not mc_build_list [ i ] then
69733: LD_EXP 107
69737: PUSH
69738: LD_VAR 0 4
69742: ARRAY
69743: NOT
69744: IFFALSE 69748
// continue ;
69746: GO 69730
// for j := 1 to mc_build_list [ i ] do
69748: LD_ADDR_VAR 0 5
69752: PUSH
69753: DOUBLE
69754: LD_INT 1
69756: DEC
69757: ST_TO_ADDR
69758: LD_EXP 107
69762: PUSH
69763: LD_VAR 0 4
69767: ARRAY
69768: PUSH
69769: FOR_TO
69770: IFFALSE 69914
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69772: LD_VAR 0 6
69776: PUSH
69777: LD_VAR 0 7
69781: PUSH
69782: LD_VAR 0 8
69786: PUSH
69787: LD_VAR 0 9
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: PPUSH
69798: LD_EXP 107
69802: PUSH
69803: LD_VAR 0 4
69807: ARRAY
69808: PUSH
69809: LD_VAR 0 5
69813: ARRAY
69814: PPUSH
69815: CALL 81801 0 2
69819: IFFALSE 69912
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69821: LD_ADDR_EXP 107
69825: PUSH
69826: LD_EXP 107
69830: PPUSH
69831: LD_VAR 0 4
69835: PPUSH
69836: LD_EXP 107
69840: PUSH
69841: LD_VAR 0 4
69845: ARRAY
69846: PPUSH
69847: LD_VAR 0 5
69851: PPUSH
69852: CALL_OW 3
69856: PPUSH
69857: CALL_OW 1
69861: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69862: LD_ADDR_EXP 109
69866: PUSH
69867: LD_EXP 109
69871: PPUSH
69872: LD_VAR 0 4
69876: PUSH
69877: LD_EXP 109
69881: PUSH
69882: LD_VAR 0 4
69886: ARRAY
69887: PUSH
69888: LD_INT 1
69890: PLUS
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PPUSH
69896: LD_VAR 0 1
69900: PPUSH
69901: CALL 75244 0 3
69905: ST_TO_ADDR
// exit ;
69906: POP
69907: POP
69908: POP
69909: POP
69910: GO 69920
// end ;
69912: GO 69769
69914: POP
69915: POP
// end ;
69916: GO 69730
69918: POP
69919: POP
// end ;
69920: LD_VAR 0 3
69924: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69925: LD_INT 0
69927: PPUSH
69928: PPUSH
69929: PPUSH
// if not mc_bases or not skirmish then
69930: LD_EXP 102
69934: NOT
69935: PUSH
69936: LD_EXP 100
69940: NOT
69941: OR
69942: IFFALSE 69946
// exit ;
69944: GO 70136
// for i = 1 to mc_bases do
69946: LD_ADDR_VAR 0 4
69950: PUSH
69951: DOUBLE
69952: LD_INT 1
69954: DEC
69955: ST_TO_ADDR
69956: LD_EXP 102
69960: PUSH
69961: FOR_TO
69962: IFFALSE 70049
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69964: LD_VAR 0 1
69968: PUSH
69969: LD_EXP 110
69973: PUSH
69974: LD_VAR 0 4
69978: ARRAY
69979: IN
69980: PUSH
69981: LD_VAR 0 1
69985: PUSH
69986: LD_EXP 111
69990: PUSH
69991: LD_VAR 0 4
69995: ARRAY
69996: IN
69997: NOT
69998: AND
69999: IFFALSE 70047
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70001: LD_ADDR_EXP 111
70005: PUSH
70006: LD_EXP 111
70010: PPUSH
70011: LD_VAR 0 4
70015: PUSH
70016: LD_EXP 111
70020: PUSH
70021: LD_VAR 0 4
70025: ARRAY
70026: PUSH
70027: LD_INT 1
70029: PLUS
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PPUSH
70035: LD_VAR 0 1
70039: PPUSH
70040: CALL 75244 0 3
70044: ST_TO_ADDR
// break ;
70045: GO 70049
// end ; end ;
70047: GO 69961
70049: POP
70050: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70051: LD_VAR 0 1
70055: PPUSH
70056: CALL_OW 257
70060: PUSH
70061: LD_EXP 128
70065: IN
70066: PUSH
70067: LD_VAR 0 1
70071: PPUSH
70072: CALL_OW 266
70076: PUSH
70077: LD_INT 5
70079: EQUAL
70080: AND
70081: PUSH
70082: LD_VAR 0 2
70086: PPUSH
70087: CALL_OW 110
70091: PUSH
70092: LD_INT 18
70094: NONEQUAL
70095: AND
70096: IFFALSE 70136
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70098: LD_VAR 0 2
70102: PPUSH
70103: CALL_OW 257
70107: PUSH
70108: LD_INT 5
70110: PUSH
70111: LD_INT 8
70113: PUSH
70114: LD_INT 9
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: LIST
70121: IN
70122: IFFALSE 70136
// SetClass ( unit , 1 ) ;
70124: LD_VAR 0 2
70128: PPUSH
70129: LD_INT 1
70131: PPUSH
70132: CALL_OW 336
// end ;
70136: LD_VAR 0 3
70140: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70141: LD_INT 0
70143: PPUSH
70144: PPUSH
// if not mc_bases or not skirmish then
70145: LD_EXP 102
70149: NOT
70150: PUSH
70151: LD_EXP 100
70155: NOT
70156: OR
70157: IFFALSE 70161
// exit ;
70159: GO 70277
// if GetLives ( abandoned_vehicle ) > 250 then
70161: LD_VAR 0 2
70165: PPUSH
70166: CALL_OW 256
70170: PUSH
70171: LD_INT 250
70173: GREATER
70174: IFFALSE 70178
// exit ;
70176: GO 70277
// for i = 1 to mc_bases do
70178: LD_ADDR_VAR 0 6
70182: PUSH
70183: DOUBLE
70184: LD_INT 1
70186: DEC
70187: ST_TO_ADDR
70188: LD_EXP 102
70192: PUSH
70193: FOR_TO
70194: IFFALSE 70275
// begin if driver in mc_bases [ i ] then
70196: LD_VAR 0 1
70200: PUSH
70201: LD_EXP 102
70205: PUSH
70206: LD_VAR 0 6
70210: ARRAY
70211: IN
70212: IFFALSE 70273
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70214: LD_VAR 0 1
70218: PPUSH
70219: LD_EXP 102
70223: PUSH
70224: LD_VAR 0 6
70228: ARRAY
70229: PPUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 30
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 30
70245: PUSH
70246: LD_INT 1
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: LIST
70257: PPUSH
70258: CALL_OW 72
70262: PUSH
70263: LD_INT 1
70265: ARRAY
70266: PPUSH
70267: CALL 108850 0 2
// break ;
70271: GO 70275
// end ; end ;
70273: GO 70193
70275: POP
70276: POP
// end ; end_of_file
70277: LD_VAR 0 5
70281: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70282: LD_INT 0
70284: PPUSH
70285: PPUSH
// if exist_mode then
70286: LD_VAR 0 2
70290: IFFALSE 70315
// unit := CreateCharacter ( prefix & ident ) else
70292: LD_ADDR_VAR 0 5
70296: PUSH
70297: LD_VAR 0 3
70301: PUSH
70302: LD_VAR 0 1
70306: STR
70307: PPUSH
70308: CALL_OW 34
70312: ST_TO_ADDR
70313: GO 70330
// unit := NewCharacter ( ident ) ;
70315: LD_ADDR_VAR 0 5
70319: PUSH
70320: LD_VAR 0 1
70324: PPUSH
70325: CALL_OW 25
70329: ST_TO_ADDR
// result := unit ;
70330: LD_ADDR_VAR 0 4
70334: PUSH
70335: LD_VAR 0 5
70339: ST_TO_ADDR
// end ;
70340: LD_VAR 0 4
70344: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
70345: LD_INT 0
70347: PPUSH
70348: PPUSH
// if not side or not nation then
70349: LD_VAR 0 1
70353: NOT
70354: PUSH
70355: LD_VAR 0 2
70359: NOT
70360: OR
70361: IFFALSE 70365
// exit ;
70363: GO 71133
// case nation of nation_american :
70365: LD_VAR 0 2
70369: PUSH
70370: LD_INT 1
70372: DOUBLE
70373: EQUAL
70374: IFTRUE 70378
70376: GO 70592
70378: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
70379: LD_ADDR_VAR 0 4
70383: PUSH
70384: LD_INT 35
70386: PUSH
70387: LD_INT 45
70389: PUSH
70390: LD_INT 46
70392: PUSH
70393: LD_INT 47
70395: PUSH
70396: LD_INT 82
70398: PUSH
70399: LD_INT 83
70401: PUSH
70402: LD_INT 84
70404: PUSH
70405: LD_INT 85
70407: PUSH
70408: LD_INT 86
70410: PUSH
70411: LD_INT 1
70413: PUSH
70414: LD_INT 2
70416: PUSH
70417: LD_INT 6
70419: PUSH
70420: LD_INT 15
70422: PUSH
70423: LD_INT 16
70425: PUSH
70426: LD_INT 7
70428: PUSH
70429: LD_INT 12
70431: PUSH
70432: LD_INT 13
70434: PUSH
70435: LD_INT 10
70437: PUSH
70438: LD_INT 14
70440: PUSH
70441: LD_INT 20
70443: PUSH
70444: LD_INT 21
70446: PUSH
70447: LD_INT 22
70449: PUSH
70450: LD_INT 25
70452: PUSH
70453: LD_INT 32
70455: PUSH
70456: LD_INT 27
70458: PUSH
70459: LD_INT 36
70461: PUSH
70462: LD_INT 69
70464: PUSH
70465: LD_INT 39
70467: PUSH
70468: LD_INT 34
70470: PUSH
70471: LD_INT 40
70473: PUSH
70474: LD_INT 48
70476: PUSH
70477: LD_INT 49
70479: PUSH
70480: LD_INT 50
70482: PUSH
70483: LD_INT 51
70485: PUSH
70486: LD_INT 52
70488: PUSH
70489: LD_INT 53
70491: PUSH
70492: LD_INT 54
70494: PUSH
70495: LD_INT 55
70497: PUSH
70498: LD_INT 56
70500: PUSH
70501: LD_INT 57
70503: PUSH
70504: LD_INT 58
70506: PUSH
70507: LD_INT 59
70509: PUSH
70510: LD_INT 60
70512: PUSH
70513: LD_INT 61
70515: PUSH
70516: LD_INT 62
70518: PUSH
70519: LD_INT 80
70521: PUSH
70522: LD_INT 82
70524: PUSH
70525: LD_INT 83
70527: PUSH
70528: LD_INT 84
70530: PUSH
70531: LD_INT 85
70533: PUSH
70534: LD_INT 86
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: ST_TO_ADDR
70590: GO 71057
70592: LD_INT 2
70594: DOUBLE
70595: EQUAL
70596: IFTRUE 70600
70598: GO 70826
70600: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70601: LD_ADDR_VAR 0 4
70605: PUSH
70606: LD_INT 35
70608: PUSH
70609: LD_INT 45
70611: PUSH
70612: LD_INT 46
70614: PUSH
70615: LD_INT 47
70617: PUSH
70618: LD_INT 82
70620: PUSH
70621: LD_INT 83
70623: PUSH
70624: LD_INT 84
70626: PUSH
70627: LD_INT 85
70629: PUSH
70630: LD_INT 87
70632: PUSH
70633: LD_INT 70
70635: PUSH
70636: LD_INT 1
70638: PUSH
70639: LD_INT 11
70641: PUSH
70642: LD_INT 3
70644: PUSH
70645: LD_INT 4
70647: PUSH
70648: LD_INT 5
70650: PUSH
70651: LD_INT 6
70653: PUSH
70654: LD_INT 15
70656: PUSH
70657: LD_INT 18
70659: PUSH
70660: LD_INT 7
70662: PUSH
70663: LD_INT 17
70665: PUSH
70666: LD_INT 8
70668: PUSH
70669: LD_INT 20
70671: PUSH
70672: LD_INT 21
70674: PUSH
70675: LD_INT 22
70677: PUSH
70678: LD_INT 72
70680: PUSH
70681: LD_INT 26
70683: PUSH
70684: LD_INT 69
70686: PUSH
70687: LD_INT 39
70689: PUSH
70690: LD_INT 40
70692: PUSH
70693: LD_INT 41
70695: PUSH
70696: LD_INT 42
70698: PUSH
70699: LD_INT 43
70701: PUSH
70702: LD_INT 48
70704: PUSH
70705: LD_INT 49
70707: PUSH
70708: LD_INT 50
70710: PUSH
70711: LD_INT 51
70713: PUSH
70714: LD_INT 52
70716: PUSH
70717: LD_INT 53
70719: PUSH
70720: LD_INT 54
70722: PUSH
70723: LD_INT 55
70725: PUSH
70726: LD_INT 56
70728: PUSH
70729: LD_INT 60
70731: PUSH
70732: LD_INT 61
70734: PUSH
70735: LD_INT 62
70737: PUSH
70738: LD_INT 66
70740: PUSH
70741: LD_INT 67
70743: PUSH
70744: LD_INT 68
70746: PUSH
70747: LD_INT 81
70749: PUSH
70750: LD_INT 82
70752: PUSH
70753: LD_INT 83
70755: PUSH
70756: LD_INT 84
70758: PUSH
70759: LD_INT 85
70761: PUSH
70762: LD_INT 87
70764: PUSH
70765: LD_INT 88
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: ST_TO_ADDR
70824: GO 71057
70826: LD_INT 3
70828: DOUBLE
70829: EQUAL
70830: IFTRUE 70834
70832: GO 71056
70834: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70835: LD_ADDR_VAR 0 4
70839: PUSH
70840: LD_INT 46
70842: PUSH
70843: LD_INT 47
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: LD_INT 2
70851: PUSH
70852: LD_INT 82
70854: PUSH
70855: LD_INT 83
70857: PUSH
70858: LD_INT 84
70860: PUSH
70861: LD_INT 85
70863: PUSH
70864: LD_INT 86
70866: PUSH
70867: LD_INT 11
70869: PUSH
70870: LD_INT 9
70872: PUSH
70873: LD_INT 20
70875: PUSH
70876: LD_INT 19
70878: PUSH
70879: LD_INT 21
70881: PUSH
70882: LD_INT 24
70884: PUSH
70885: LD_INT 22
70887: PUSH
70888: LD_INT 25
70890: PUSH
70891: LD_INT 28
70893: PUSH
70894: LD_INT 29
70896: PUSH
70897: LD_INT 30
70899: PUSH
70900: LD_INT 31
70902: PUSH
70903: LD_INT 37
70905: PUSH
70906: LD_INT 38
70908: PUSH
70909: LD_INT 32
70911: PUSH
70912: LD_INT 27
70914: PUSH
70915: LD_INT 33
70917: PUSH
70918: LD_INT 69
70920: PUSH
70921: LD_INT 39
70923: PUSH
70924: LD_INT 34
70926: PUSH
70927: LD_INT 40
70929: PUSH
70930: LD_INT 71
70932: PUSH
70933: LD_INT 23
70935: PUSH
70936: LD_INT 44
70938: PUSH
70939: LD_INT 48
70941: PUSH
70942: LD_INT 49
70944: PUSH
70945: LD_INT 50
70947: PUSH
70948: LD_INT 51
70950: PUSH
70951: LD_INT 52
70953: PUSH
70954: LD_INT 53
70956: PUSH
70957: LD_INT 54
70959: PUSH
70960: LD_INT 55
70962: PUSH
70963: LD_INT 56
70965: PUSH
70966: LD_INT 57
70968: PUSH
70969: LD_INT 58
70971: PUSH
70972: LD_INT 59
70974: PUSH
70975: LD_INT 63
70977: PUSH
70978: LD_INT 64
70980: PUSH
70981: LD_INT 65
70983: PUSH
70984: LD_INT 82
70986: PUSH
70987: LD_INT 83
70989: PUSH
70990: LD_INT 84
70992: PUSH
70993: LD_INT 85
70995: PUSH
70996: LD_INT 86
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: ST_TO_ADDR
71054: GO 71057
71056: POP
// if state > - 1 and state < 3 then
71057: LD_VAR 0 3
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: GREATER
71066: PUSH
71067: LD_VAR 0 3
71071: PUSH
71072: LD_INT 3
71074: LESS
71075: AND
71076: IFFALSE 71133
// for i in result do
71078: LD_ADDR_VAR 0 5
71082: PUSH
71083: LD_VAR 0 4
71087: PUSH
71088: FOR_IN
71089: IFFALSE 71131
// if GetTech ( i , side ) <> state then
71091: LD_VAR 0 5
71095: PPUSH
71096: LD_VAR 0 1
71100: PPUSH
71101: CALL_OW 321
71105: PUSH
71106: LD_VAR 0 3
71110: NONEQUAL
71111: IFFALSE 71129
// result := result diff i ;
71113: LD_ADDR_VAR 0 4
71117: PUSH
71118: LD_VAR 0 4
71122: PUSH
71123: LD_VAR 0 5
71127: DIFF
71128: ST_TO_ADDR
71129: GO 71088
71131: POP
71132: POP
// end ;
71133: LD_VAR 0 4
71137: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71138: LD_INT 0
71140: PPUSH
71141: PPUSH
71142: PPUSH
// result := true ;
71143: LD_ADDR_VAR 0 3
71147: PUSH
71148: LD_INT 1
71150: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71151: LD_ADDR_VAR 0 5
71155: PUSH
71156: LD_VAR 0 2
71160: PPUSH
71161: CALL_OW 480
71165: ST_TO_ADDR
// if not tmp then
71166: LD_VAR 0 5
71170: NOT
71171: IFFALSE 71175
// exit ;
71173: GO 71224
// for i in tmp do
71175: LD_ADDR_VAR 0 4
71179: PUSH
71180: LD_VAR 0 5
71184: PUSH
71185: FOR_IN
71186: IFFALSE 71222
// if GetTech ( i , side ) <> state_researched then
71188: LD_VAR 0 4
71192: PPUSH
71193: LD_VAR 0 1
71197: PPUSH
71198: CALL_OW 321
71202: PUSH
71203: LD_INT 2
71205: NONEQUAL
71206: IFFALSE 71220
// begin result := false ;
71208: LD_ADDR_VAR 0 3
71212: PUSH
71213: LD_INT 0
71215: ST_TO_ADDR
// exit ;
71216: POP
71217: POP
71218: GO 71224
// end ;
71220: GO 71185
71222: POP
71223: POP
// end ;
71224: LD_VAR 0 3
71228: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71229: LD_INT 0
71231: PPUSH
71232: PPUSH
71233: PPUSH
71234: PPUSH
71235: PPUSH
71236: PPUSH
71237: PPUSH
71238: PPUSH
71239: PPUSH
71240: PPUSH
71241: PPUSH
71242: PPUSH
71243: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71244: LD_VAR 0 1
71248: NOT
71249: PUSH
71250: LD_VAR 0 1
71254: PPUSH
71255: CALL_OW 257
71259: PUSH
71260: LD_INT 9
71262: NONEQUAL
71263: OR
71264: IFFALSE 71268
// exit ;
71266: GO 71841
// side := GetSide ( unit ) ;
71268: LD_ADDR_VAR 0 9
71272: PUSH
71273: LD_VAR 0 1
71277: PPUSH
71278: CALL_OW 255
71282: ST_TO_ADDR
// tech_space := tech_spacanom ;
71283: LD_ADDR_VAR 0 12
71287: PUSH
71288: LD_INT 29
71290: ST_TO_ADDR
// tech_time := tech_taurad ;
71291: LD_ADDR_VAR 0 13
71295: PUSH
71296: LD_INT 28
71298: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
71299: LD_ADDR_VAR 0 11
71303: PUSH
71304: LD_VAR 0 1
71308: PPUSH
71309: CALL_OW 310
71313: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
71314: LD_VAR 0 11
71318: PPUSH
71319: CALL_OW 247
71323: PUSH
71324: LD_INT 2
71326: EQUAL
71327: IFFALSE 71331
// exit ;
71329: GO 71841
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71331: LD_ADDR_VAR 0 8
71335: PUSH
71336: LD_INT 81
71338: PUSH
71339: LD_VAR 0 9
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 3
71350: PUSH
71351: LD_INT 21
71353: PUSH
71354: LD_INT 3
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PPUSH
71369: CALL_OW 69
71373: ST_TO_ADDR
// if not tmp then
71374: LD_VAR 0 8
71378: NOT
71379: IFFALSE 71383
// exit ;
71381: GO 71841
// if in_unit then
71383: LD_VAR 0 11
71387: IFFALSE 71411
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
71389: LD_ADDR_VAR 0 10
71393: PUSH
71394: LD_VAR 0 8
71398: PPUSH
71399: LD_VAR 0 11
71403: PPUSH
71404: CALL_OW 74
71408: ST_TO_ADDR
71409: GO 71431
// enemy := NearestUnitToUnit ( tmp , unit ) ;
71411: LD_ADDR_VAR 0 10
71415: PUSH
71416: LD_VAR 0 8
71420: PPUSH
71421: LD_VAR 0 1
71425: PPUSH
71426: CALL_OW 74
71430: ST_TO_ADDR
// if not enemy then
71431: LD_VAR 0 10
71435: NOT
71436: IFFALSE 71440
// exit ;
71438: GO 71841
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
71440: LD_VAR 0 11
71444: PUSH
71445: LD_VAR 0 11
71449: PPUSH
71450: LD_VAR 0 10
71454: PPUSH
71455: CALL_OW 296
71459: PUSH
71460: LD_INT 13
71462: GREATER
71463: AND
71464: PUSH
71465: LD_VAR 0 1
71469: PPUSH
71470: LD_VAR 0 10
71474: PPUSH
71475: CALL_OW 296
71479: PUSH
71480: LD_INT 12
71482: GREATER
71483: OR
71484: IFFALSE 71488
// exit ;
71486: GO 71841
// missile := [ 1 ] ;
71488: LD_ADDR_VAR 0 14
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: EMPTY
71497: LIST
71498: ST_TO_ADDR
// if Researched ( side , tech_space ) then
71499: LD_VAR 0 9
71503: PPUSH
71504: LD_VAR 0 12
71508: PPUSH
71509: CALL_OW 325
71513: IFFALSE 71542
// missile := Replace ( missile , missile + 1 , 2 ) ;
71515: LD_ADDR_VAR 0 14
71519: PUSH
71520: LD_VAR 0 14
71524: PPUSH
71525: LD_VAR 0 14
71529: PUSH
71530: LD_INT 1
71532: PLUS
71533: PPUSH
71534: LD_INT 2
71536: PPUSH
71537: CALL_OW 1
71541: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
71542: LD_VAR 0 9
71546: PPUSH
71547: LD_VAR 0 13
71551: PPUSH
71552: CALL_OW 325
71556: PUSH
71557: LD_VAR 0 10
71561: PPUSH
71562: CALL_OW 255
71566: PPUSH
71567: LD_VAR 0 13
71571: PPUSH
71572: CALL_OW 325
71576: NOT
71577: AND
71578: IFFALSE 71607
// missile := Replace ( missile , missile + 1 , 3 ) ;
71580: LD_ADDR_VAR 0 14
71584: PUSH
71585: LD_VAR 0 14
71589: PPUSH
71590: LD_VAR 0 14
71594: PUSH
71595: LD_INT 1
71597: PLUS
71598: PPUSH
71599: LD_INT 3
71601: PPUSH
71602: CALL_OW 1
71606: ST_TO_ADDR
// if missile < 2 then
71607: LD_VAR 0 14
71611: PUSH
71612: LD_INT 2
71614: LESS
71615: IFFALSE 71619
// exit ;
71617: GO 71841
// x := GetX ( enemy ) ;
71619: LD_ADDR_VAR 0 4
71623: PUSH
71624: LD_VAR 0 10
71628: PPUSH
71629: CALL_OW 250
71633: ST_TO_ADDR
// y := GetY ( enemy ) ;
71634: LD_ADDR_VAR 0 5
71638: PUSH
71639: LD_VAR 0 10
71643: PPUSH
71644: CALL_OW 251
71648: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71649: LD_ADDR_VAR 0 6
71653: PUSH
71654: LD_VAR 0 4
71658: PUSH
71659: LD_INT 1
71661: NEG
71662: PPUSH
71663: LD_INT 1
71665: PPUSH
71666: CALL_OW 12
71670: PLUS
71671: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71672: LD_ADDR_VAR 0 7
71676: PUSH
71677: LD_VAR 0 5
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PPUSH
71686: LD_INT 1
71688: PPUSH
71689: CALL_OW 12
71693: PLUS
71694: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71695: LD_VAR 0 6
71699: PPUSH
71700: LD_VAR 0 7
71704: PPUSH
71705: CALL_OW 488
71709: NOT
71710: IFFALSE 71732
// begin _x := x ;
71712: LD_ADDR_VAR 0 6
71716: PUSH
71717: LD_VAR 0 4
71721: ST_TO_ADDR
// _y := y ;
71722: LD_ADDR_VAR 0 7
71726: PUSH
71727: LD_VAR 0 5
71731: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71732: LD_ADDR_VAR 0 3
71736: PUSH
71737: LD_INT 1
71739: PPUSH
71740: LD_VAR 0 14
71744: PPUSH
71745: CALL_OW 12
71749: ST_TO_ADDR
// case i of 1 :
71750: LD_VAR 0 3
71754: PUSH
71755: LD_INT 1
71757: DOUBLE
71758: EQUAL
71759: IFTRUE 71763
71761: GO 71780
71763: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71764: LD_VAR 0 1
71768: PPUSH
71769: LD_VAR 0 10
71773: PPUSH
71774: CALL_OW 115
71778: GO 71841
71780: LD_INT 2
71782: DOUBLE
71783: EQUAL
71784: IFTRUE 71788
71786: GO 71810
71788: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71789: LD_VAR 0 1
71793: PPUSH
71794: LD_VAR 0 6
71798: PPUSH
71799: LD_VAR 0 7
71803: PPUSH
71804: CALL_OW 153
71808: GO 71841
71810: LD_INT 3
71812: DOUBLE
71813: EQUAL
71814: IFTRUE 71818
71816: GO 71840
71818: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71819: LD_VAR 0 1
71823: PPUSH
71824: LD_VAR 0 6
71828: PPUSH
71829: LD_VAR 0 7
71833: PPUSH
71834: CALL_OW 154
71838: GO 71841
71840: POP
// end ;
71841: LD_VAR 0 2
71845: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71846: LD_INT 0
71848: PPUSH
71849: PPUSH
71850: PPUSH
71851: PPUSH
71852: PPUSH
71853: PPUSH
// if not unit or not building then
71854: LD_VAR 0 1
71858: NOT
71859: PUSH
71860: LD_VAR 0 2
71864: NOT
71865: OR
71866: IFFALSE 71870
// exit ;
71868: GO 72028
// x := GetX ( building ) ;
71870: LD_ADDR_VAR 0 5
71874: PUSH
71875: LD_VAR 0 2
71879: PPUSH
71880: CALL_OW 250
71884: ST_TO_ADDR
// y := GetY ( building ) ;
71885: LD_ADDR_VAR 0 6
71889: PUSH
71890: LD_VAR 0 2
71894: PPUSH
71895: CALL_OW 251
71899: ST_TO_ADDR
// for i = 0 to 5 do
71900: LD_ADDR_VAR 0 4
71904: PUSH
71905: DOUBLE
71906: LD_INT 0
71908: DEC
71909: ST_TO_ADDR
71910: LD_INT 5
71912: PUSH
71913: FOR_TO
71914: IFFALSE 72026
// begin _x := ShiftX ( x , i , 3 ) ;
71916: LD_ADDR_VAR 0 7
71920: PUSH
71921: LD_VAR 0 5
71925: PPUSH
71926: LD_VAR 0 4
71930: PPUSH
71931: LD_INT 3
71933: PPUSH
71934: CALL_OW 272
71938: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71939: LD_ADDR_VAR 0 8
71943: PUSH
71944: LD_VAR 0 6
71948: PPUSH
71949: LD_VAR 0 4
71953: PPUSH
71954: LD_INT 3
71956: PPUSH
71957: CALL_OW 273
71961: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71962: LD_VAR 0 7
71966: PPUSH
71967: LD_VAR 0 8
71971: PPUSH
71972: CALL_OW 488
71976: NOT
71977: IFFALSE 71981
// continue ;
71979: GO 71913
// if HexInfo ( _x , _y ) = 0 then
71981: LD_VAR 0 7
71985: PPUSH
71986: LD_VAR 0 8
71990: PPUSH
71991: CALL_OW 428
71995: PUSH
71996: LD_INT 0
71998: EQUAL
71999: IFFALSE 72024
// begin ComMoveXY ( unit , _x , _y ) ;
72001: LD_VAR 0 1
72005: PPUSH
72006: LD_VAR 0 7
72010: PPUSH
72011: LD_VAR 0 8
72015: PPUSH
72016: CALL_OW 111
// exit ;
72020: POP
72021: POP
72022: GO 72028
// end ; end ;
72024: GO 71913
72026: POP
72027: POP
// end ;
72028: LD_VAR 0 3
72032: RET
// export function ScanBase ( side , base_area ) ; begin
72033: LD_INT 0
72035: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72036: LD_ADDR_VAR 0 3
72040: PUSH
72041: LD_VAR 0 2
72045: PPUSH
72046: LD_INT 81
72048: PUSH
72049: LD_VAR 0 1
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PPUSH
72058: CALL_OW 70
72062: ST_TO_ADDR
// end ;
72063: LD_VAR 0 3
72067: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72068: LD_INT 0
72070: PPUSH
72071: PPUSH
72072: PPUSH
72073: PPUSH
// result := false ;
72074: LD_ADDR_VAR 0 2
72078: PUSH
72079: LD_INT 0
72081: ST_TO_ADDR
// side := GetSide ( unit ) ;
72082: LD_ADDR_VAR 0 3
72086: PUSH
72087: LD_VAR 0 1
72091: PPUSH
72092: CALL_OW 255
72096: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72097: LD_ADDR_VAR 0 4
72101: PUSH
72102: LD_VAR 0 1
72106: PPUSH
72107: CALL_OW 248
72111: ST_TO_ADDR
// case nat of 1 :
72112: LD_VAR 0 4
72116: PUSH
72117: LD_INT 1
72119: DOUBLE
72120: EQUAL
72121: IFTRUE 72125
72123: GO 72136
72125: POP
// tech := tech_lassight ; 2 :
72126: LD_ADDR_VAR 0 5
72130: PUSH
72131: LD_INT 12
72133: ST_TO_ADDR
72134: GO 72175
72136: LD_INT 2
72138: DOUBLE
72139: EQUAL
72140: IFTRUE 72144
72142: GO 72155
72144: POP
// tech := tech_mortar ; 3 :
72145: LD_ADDR_VAR 0 5
72149: PUSH
72150: LD_INT 41
72152: ST_TO_ADDR
72153: GO 72175
72155: LD_INT 3
72157: DOUBLE
72158: EQUAL
72159: IFTRUE 72163
72161: GO 72174
72163: POP
// tech := tech_bazooka ; end ;
72164: LD_ADDR_VAR 0 5
72168: PUSH
72169: LD_INT 44
72171: ST_TO_ADDR
72172: GO 72175
72174: POP
// if Researched ( side , tech ) then
72175: LD_VAR 0 3
72179: PPUSH
72180: LD_VAR 0 5
72184: PPUSH
72185: CALL_OW 325
72189: IFFALSE 72216
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72191: LD_ADDR_VAR 0 2
72195: PUSH
72196: LD_INT 5
72198: PUSH
72199: LD_INT 8
72201: PUSH
72202: LD_INT 9
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: LIST
72209: PUSH
72210: LD_VAR 0 4
72214: ARRAY
72215: ST_TO_ADDR
// end ;
72216: LD_VAR 0 2
72220: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72221: LD_INT 0
72223: PPUSH
72224: PPUSH
72225: PPUSH
// if not mines then
72226: LD_VAR 0 2
72230: NOT
72231: IFFALSE 72235
// exit ;
72233: GO 72379
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72235: LD_ADDR_VAR 0 5
72239: PUSH
72240: LD_INT 81
72242: PUSH
72243: LD_VAR 0 1
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 3
72254: PUSH
72255: LD_INT 21
72257: PUSH
72258: LD_INT 3
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PPUSH
72273: CALL_OW 69
72277: ST_TO_ADDR
// for i in mines do
72278: LD_ADDR_VAR 0 4
72282: PUSH
72283: LD_VAR 0 2
72287: PUSH
72288: FOR_IN
72289: IFFALSE 72377
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
72291: LD_VAR 0 4
72295: PUSH
72296: LD_INT 1
72298: ARRAY
72299: PPUSH
72300: LD_VAR 0 4
72304: PUSH
72305: LD_INT 2
72307: ARRAY
72308: PPUSH
72309: CALL_OW 458
72313: NOT
72314: IFFALSE 72318
// continue ;
72316: GO 72288
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
72318: LD_VAR 0 4
72322: PUSH
72323: LD_INT 1
72325: ARRAY
72326: PPUSH
72327: LD_VAR 0 4
72331: PUSH
72332: LD_INT 2
72334: ARRAY
72335: PPUSH
72336: CALL_OW 428
72340: PUSH
72341: LD_VAR 0 5
72345: IN
72346: IFFALSE 72375
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
72348: LD_VAR 0 4
72352: PUSH
72353: LD_INT 1
72355: ARRAY
72356: PPUSH
72357: LD_VAR 0 4
72361: PUSH
72362: LD_INT 2
72364: ARRAY
72365: PPUSH
72366: LD_VAR 0 1
72370: PPUSH
72371: CALL_OW 456
// end ;
72375: GO 72288
72377: POP
72378: POP
// end ;
72379: LD_VAR 0 3
72383: RET
// export function Count ( array ) ; begin
72384: LD_INT 0
72386: PPUSH
// result := array + 0 ;
72387: LD_ADDR_VAR 0 2
72391: PUSH
72392: LD_VAR 0 1
72396: PUSH
72397: LD_INT 0
72399: PLUS
72400: ST_TO_ADDR
// end ;
72401: LD_VAR 0 2
72405: RET
// export function IsEmpty ( building ) ; begin
72406: LD_INT 0
72408: PPUSH
// if not building then
72409: LD_VAR 0 1
72413: NOT
72414: IFFALSE 72418
// exit ;
72416: GO 72461
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
72418: LD_ADDR_VAR 0 2
72422: PUSH
72423: LD_VAR 0 1
72427: PUSH
72428: LD_INT 22
72430: PUSH
72431: LD_VAR 0 1
72435: PPUSH
72436: CALL_OW 255
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 58
72447: PUSH
72448: EMPTY
72449: LIST
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PPUSH
72455: CALL_OW 69
72459: IN
72460: ST_TO_ADDR
// end ;
72461: LD_VAR 0 2
72465: RET
// export function IsNotFull ( building ) ; var places ; begin
72466: LD_INT 0
72468: PPUSH
72469: PPUSH
// if not building then
72470: LD_VAR 0 1
72474: NOT
72475: IFFALSE 72479
// exit ;
72477: GO 72507
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
72479: LD_ADDR_VAR 0 2
72483: PUSH
72484: LD_VAR 0 1
72488: PPUSH
72489: LD_INT 3
72491: PUSH
72492: LD_INT 62
72494: PUSH
72495: EMPTY
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: CALL_OW 72
72506: ST_TO_ADDR
// end ;
72507: LD_VAR 0 2
72511: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
72512: LD_INT 0
72514: PPUSH
72515: PPUSH
72516: PPUSH
72517: PPUSH
// tmp := [ ] ;
72518: LD_ADDR_VAR 0 3
72522: PUSH
72523: EMPTY
72524: ST_TO_ADDR
// list := [ ] ;
72525: LD_ADDR_VAR 0 5
72529: PUSH
72530: EMPTY
72531: ST_TO_ADDR
// for i = 16 to 25 do
72532: LD_ADDR_VAR 0 4
72536: PUSH
72537: DOUBLE
72538: LD_INT 16
72540: DEC
72541: ST_TO_ADDR
72542: LD_INT 25
72544: PUSH
72545: FOR_TO
72546: IFFALSE 72619
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
72548: LD_ADDR_VAR 0 3
72552: PUSH
72553: LD_VAR 0 3
72557: PUSH
72558: LD_INT 22
72560: PUSH
72561: LD_VAR 0 1
72565: PPUSH
72566: CALL_OW 255
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 91
72577: PUSH
72578: LD_VAR 0 1
72582: PUSH
72583: LD_INT 6
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 30
72593: PUSH
72594: LD_VAR 0 4
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: EMPTY
72604: LIST
72605: LIST
72606: LIST
72607: PUSH
72608: EMPTY
72609: LIST
72610: PPUSH
72611: CALL_OW 69
72615: ADD
72616: ST_TO_ADDR
72617: GO 72545
72619: POP
72620: POP
// for i = 1 to tmp do
72621: LD_ADDR_VAR 0 4
72625: PUSH
72626: DOUBLE
72627: LD_INT 1
72629: DEC
72630: ST_TO_ADDR
72631: LD_VAR 0 3
72635: PUSH
72636: FOR_TO
72637: IFFALSE 72725
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72639: LD_ADDR_VAR 0 5
72643: PUSH
72644: LD_VAR 0 5
72648: PUSH
72649: LD_VAR 0 3
72653: PUSH
72654: LD_VAR 0 4
72658: ARRAY
72659: PPUSH
72660: CALL_OW 266
72664: PUSH
72665: LD_VAR 0 3
72669: PUSH
72670: LD_VAR 0 4
72674: ARRAY
72675: PPUSH
72676: CALL_OW 250
72680: PUSH
72681: LD_VAR 0 3
72685: PUSH
72686: LD_VAR 0 4
72690: ARRAY
72691: PPUSH
72692: CALL_OW 251
72696: PUSH
72697: LD_VAR 0 3
72701: PUSH
72702: LD_VAR 0 4
72706: ARRAY
72707: PPUSH
72708: CALL_OW 254
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: LIST
72717: LIST
72718: PUSH
72719: EMPTY
72720: LIST
72721: ADD
72722: ST_TO_ADDR
72723: GO 72636
72725: POP
72726: POP
// result := list ;
72727: LD_ADDR_VAR 0 2
72731: PUSH
72732: LD_VAR 0 5
72736: ST_TO_ADDR
// end ;
72737: LD_VAR 0 2
72741: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72742: LD_INT 0
72744: PPUSH
72745: PPUSH
72746: PPUSH
72747: PPUSH
72748: PPUSH
72749: PPUSH
72750: PPUSH
// if not factory then
72751: LD_VAR 0 1
72755: NOT
72756: IFFALSE 72760
// exit ;
72758: GO 73353
// if control = control_apeman then
72760: LD_VAR 0 4
72764: PUSH
72765: LD_INT 5
72767: EQUAL
72768: IFFALSE 72877
// begin tmp := UnitsInside ( factory ) ;
72770: LD_ADDR_VAR 0 8
72774: PUSH
72775: LD_VAR 0 1
72779: PPUSH
72780: CALL_OW 313
72784: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72785: LD_VAR 0 8
72789: PPUSH
72790: LD_INT 25
72792: PUSH
72793: LD_INT 12
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PPUSH
72800: CALL_OW 72
72804: NOT
72805: IFFALSE 72815
// control := control_manual ;
72807: LD_ADDR_VAR 0 4
72811: PUSH
72812: LD_INT 1
72814: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72815: LD_ADDR_VAR 0 8
72819: PUSH
72820: LD_VAR 0 1
72824: PPUSH
72825: CALL 72512 0 1
72829: ST_TO_ADDR
// if tmp then
72830: LD_VAR 0 8
72834: IFFALSE 72877
// begin for i in tmp do
72836: LD_ADDR_VAR 0 7
72840: PUSH
72841: LD_VAR 0 8
72845: PUSH
72846: FOR_IN
72847: IFFALSE 72875
// if i [ 1 ] = b_ext_radio then
72849: LD_VAR 0 7
72853: PUSH
72854: LD_INT 1
72856: ARRAY
72857: PUSH
72858: LD_INT 22
72860: EQUAL
72861: IFFALSE 72873
// begin control := control_remote ;
72863: LD_ADDR_VAR 0 4
72867: PUSH
72868: LD_INT 2
72870: ST_TO_ADDR
// break ;
72871: GO 72875
// end ;
72873: GO 72846
72875: POP
72876: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72877: LD_VAR 0 1
72881: PPUSH
72882: LD_VAR 0 2
72886: PPUSH
72887: LD_VAR 0 3
72891: PPUSH
72892: LD_VAR 0 4
72896: PPUSH
72897: LD_VAR 0 5
72901: PPUSH
72902: CALL_OW 448
72906: IFFALSE 72941
// begin result := [ chassis , engine , control , weapon ] ;
72908: LD_ADDR_VAR 0 6
72912: PUSH
72913: LD_VAR 0 2
72917: PUSH
72918: LD_VAR 0 3
72922: PUSH
72923: LD_VAR 0 4
72927: PUSH
72928: LD_VAR 0 5
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: ST_TO_ADDR
// exit ;
72939: GO 73353
// end ; _chassis := AvailableChassisList ( factory ) ;
72941: LD_ADDR_VAR 0 9
72945: PUSH
72946: LD_VAR 0 1
72950: PPUSH
72951: CALL_OW 475
72955: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72956: LD_ADDR_VAR 0 11
72960: PUSH
72961: LD_VAR 0 1
72965: PPUSH
72966: CALL_OW 476
72970: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72971: LD_ADDR_VAR 0 12
72975: PUSH
72976: LD_VAR 0 1
72980: PPUSH
72981: CALL_OW 477
72985: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72986: LD_ADDR_VAR 0 10
72990: PUSH
72991: LD_VAR 0 1
72995: PPUSH
72996: CALL_OW 478
73000: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73001: LD_VAR 0 9
73005: NOT
73006: PUSH
73007: LD_VAR 0 11
73011: NOT
73012: OR
73013: PUSH
73014: LD_VAR 0 12
73018: NOT
73019: OR
73020: PUSH
73021: LD_VAR 0 10
73025: NOT
73026: OR
73027: IFFALSE 73062
// begin result := [ chassis , engine , control , weapon ] ;
73029: LD_ADDR_VAR 0 6
73033: PUSH
73034: LD_VAR 0 2
73038: PUSH
73039: LD_VAR 0 3
73043: PUSH
73044: LD_VAR 0 4
73048: PUSH
73049: LD_VAR 0 5
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: ST_TO_ADDR
// exit ;
73060: GO 73353
// end ; if not chassis in _chassis then
73062: LD_VAR 0 2
73066: PUSH
73067: LD_VAR 0 9
73071: IN
73072: NOT
73073: IFFALSE 73099
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73075: LD_ADDR_VAR 0 2
73079: PUSH
73080: LD_VAR 0 9
73084: PUSH
73085: LD_INT 1
73087: PPUSH
73088: LD_VAR 0 9
73092: PPUSH
73093: CALL_OW 12
73097: ARRAY
73098: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73099: LD_VAR 0 2
73103: PPUSH
73104: LD_VAR 0 3
73108: PPUSH
73109: CALL 73358 0 2
73113: NOT
73114: IFFALSE 73173
// repeat engine := _engine [ 1 ] ;
73116: LD_ADDR_VAR 0 3
73120: PUSH
73121: LD_VAR 0 11
73125: PUSH
73126: LD_INT 1
73128: ARRAY
73129: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73130: LD_ADDR_VAR 0 11
73134: PUSH
73135: LD_VAR 0 11
73139: PPUSH
73140: LD_INT 1
73142: PPUSH
73143: CALL_OW 3
73147: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73148: LD_VAR 0 2
73152: PPUSH
73153: LD_VAR 0 3
73157: PPUSH
73158: CALL 73358 0 2
73162: PUSH
73163: LD_VAR 0 11
73167: PUSH
73168: EMPTY
73169: EQUAL
73170: OR
73171: IFFALSE 73116
// if not control in _control then
73173: LD_VAR 0 4
73177: PUSH
73178: LD_VAR 0 12
73182: IN
73183: NOT
73184: IFFALSE 73210
// control := _control [ rand ( 1 , _control ) ] ;
73186: LD_ADDR_VAR 0 4
73190: PUSH
73191: LD_VAR 0 12
73195: PUSH
73196: LD_INT 1
73198: PPUSH
73199: LD_VAR 0 12
73203: PPUSH
73204: CALL_OW 12
73208: ARRAY
73209: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73210: LD_VAR 0 2
73214: PPUSH
73215: LD_VAR 0 5
73219: PPUSH
73220: CALL 73578 0 2
73224: NOT
73225: IFFALSE 73284
// repeat weapon := _weapon [ 1 ] ;
73227: LD_ADDR_VAR 0 5
73231: PUSH
73232: LD_VAR 0 10
73236: PUSH
73237: LD_INT 1
73239: ARRAY
73240: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
73241: LD_ADDR_VAR 0 10
73245: PUSH
73246: LD_VAR 0 10
73250: PPUSH
73251: LD_INT 1
73253: PPUSH
73254: CALL_OW 3
73258: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
73259: LD_VAR 0 2
73263: PPUSH
73264: LD_VAR 0 5
73268: PPUSH
73269: CALL 73578 0 2
73273: PUSH
73274: LD_VAR 0 10
73278: PUSH
73279: EMPTY
73280: EQUAL
73281: OR
73282: IFFALSE 73227
// result := [ ] ;
73284: LD_ADDR_VAR 0 6
73288: PUSH
73289: EMPTY
73290: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73291: LD_VAR 0 1
73295: PPUSH
73296: LD_VAR 0 2
73300: PPUSH
73301: LD_VAR 0 3
73305: PPUSH
73306: LD_VAR 0 4
73310: PPUSH
73311: LD_VAR 0 5
73315: PPUSH
73316: CALL_OW 448
73320: IFFALSE 73353
// result := [ chassis , engine , control , weapon ] ;
73322: LD_ADDR_VAR 0 6
73326: PUSH
73327: LD_VAR 0 2
73331: PUSH
73332: LD_VAR 0 3
73336: PUSH
73337: LD_VAR 0 4
73341: PUSH
73342: LD_VAR 0 5
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: ST_TO_ADDR
// end ;
73353: LD_VAR 0 6
73357: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
73358: LD_INT 0
73360: PPUSH
// if not chassis or not engine then
73361: LD_VAR 0 1
73365: NOT
73366: PUSH
73367: LD_VAR 0 2
73371: NOT
73372: OR
73373: IFFALSE 73377
// exit ;
73375: GO 73573
// case engine of engine_solar :
73377: LD_VAR 0 2
73381: PUSH
73382: LD_INT 2
73384: DOUBLE
73385: EQUAL
73386: IFTRUE 73390
73388: GO 73428
73390: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
73391: LD_ADDR_VAR 0 3
73395: PUSH
73396: LD_INT 11
73398: PUSH
73399: LD_INT 12
73401: PUSH
73402: LD_INT 13
73404: PUSH
73405: LD_INT 14
73407: PUSH
73408: LD_INT 1
73410: PUSH
73411: LD_INT 2
73413: PUSH
73414: LD_INT 3
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: ST_TO_ADDR
73426: GO 73557
73428: LD_INT 1
73430: DOUBLE
73431: EQUAL
73432: IFTRUE 73436
73434: GO 73498
73436: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
73437: LD_ADDR_VAR 0 3
73441: PUSH
73442: LD_INT 11
73444: PUSH
73445: LD_INT 12
73447: PUSH
73448: LD_INT 13
73450: PUSH
73451: LD_INT 14
73453: PUSH
73454: LD_INT 1
73456: PUSH
73457: LD_INT 2
73459: PUSH
73460: LD_INT 3
73462: PUSH
73463: LD_INT 4
73465: PUSH
73466: LD_INT 5
73468: PUSH
73469: LD_INT 21
73471: PUSH
73472: LD_INT 23
73474: PUSH
73475: LD_INT 22
73477: PUSH
73478: LD_INT 24
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: LIST
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: ST_TO_ADDR
73496: GO 73557
73498: LD_INT 3
73500: DOUBLE
73501: EQUAL
73502: IFTRUE 73506
73504: GO 73556
73506: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73507: LD_ADDR_VAR 0 3
73511: PUSH
73512: LD_INT 13
73514: PUSH
73515: LD_INT 14
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: LD_INT 3
73523: PUSH
73524: LD_INT 4
73526: PUSH
73527: LD_INT 5
73529: PUSH
73530: LD_INT 21
73532: PUSH
73533: LD_INT 22
73535: PUSH
73536: LD_INT 23
73538: PUSH
73539: LD_INT 24
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: ST_TO_ADDR
73554: GO 73557
73556: POP
// result := ( chassis in result ) ;
73557: LD_ADDR_VAR 0 3
73561: PUSH
73562: LD_VAR 0 1
73566: PUSH
73567: LD_VAR 0 3
73571: IN
73572: ST_TO_ADDR
// end ;
73573: LD_VAR 0 3
73577: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73578: LD_INT 0
73580: PPUSH
// if not chassis or not weapon then
73581: LD_VAR 0 1
73585: NOT
73586: PUSH
73587: LD_VAR 0 2
73591: NOT
73592: OR
73593: IFFALSE 73597
// exit ;
73595: GO 74657
// case weapon of us_machine_gun :
73597: LD_VAR 0 2
73601: PUSH
73602: LD_INT 2
73604: DOUBLE
73605: EQUAL
73606: IFTRUE 73610
73608: GO 73640
73610: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73611: LD_ADDR_VAR 0 3
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 2
73621: PUSH
73622: LD_INT 3
73624: PUSH
73625: LD_INT 4
73627: PUSH
73628: LD_INT 5
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: ST_TO_ADDR
73638: GO 74641
73640: LD_INT 3
73642: DOUBLE
73643: EQUAL
73644: IFTRUE 73648
73646: GO 73678
73648: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73649: LD_ADDR_VAR 0 3
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: LD_INT 2
73659: PUSH
73660: LD_INT 3
73662: PUSH
73663: LD_INT 4
73665: PUSH
73666: LD_INT 5
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: LIST
73673: LIST
73674: LIST
73675: ST_TO_ADDR
73676: GO 74641
73678: LD_INT 11
73680: DOUBLE
73681: EQUAL
73682: IFTRUE 73686
73684: GO 73716
73686: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73687: LD_ADDR_VAR 0 3
73691: PUSH
73692: LD_INT 1
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: LD_INT 3
73700: PUSH
73701: LD_INT 4
73703: PUSH
73704: LD_INT 5
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: ST_TO_ADDR
73714: GO 74641
73716: LD_INT 4
73718: DOUBLE
73719: EQUAL
73720: IFTRUE 73724
73722: GO 73750
73724: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73725: LD_ADDR_VAR 0 3
73729: PUSH
73730: LD_INT 2
73732: PUSH
73733: LD_INT 3
73735: PUSH
73736: LD_INT 4
73738: PUSH
73739: LD_INT 5
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: ST_TO_ADDR
73748: GO 74641
73750: LD_INT 5
73752: DOUBLE
73753: EQUAL
73754: IFTRUE 73758
73756: GO 73784
73758: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73759: LD_ADDR_VAR 0 3
73763: PUSH
73764: LD_INT 2
73766: PUSH
73767: LD_INT 3
73769: PUSH
73770: LD_INT 4
73772: PUSH
73773: LD_INT 5
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: ST_TO_ADDR
73782: GO 74641
73784: LD_INT 9
73786: DOUBLE
73787: EQUAL
73788: IFTRUE 73792
73790: GO 73818
73792: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73793: LD_ADDR_VAR 0 3
73797: PUSH
73798: LD_INT 2
73800: PUSH
73801: LD_INT 3
73803: PUSH
73804: LD_INT 4
73806: PUSH
73807: LD_INT 5
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: ST_TO_ADDR
73816: GO 74641
73818: LD_INT 7
73820: DOUBLE
73821: EQUAL
73822: IFTRUE 73826
73824: GO 73852
73826: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73827: LD_ADDR_VAR 0 3
73831: PUSH
73832: LD_INT 2
73834: PUSH
73835: LD_INT 3
73837: PUSH
73838: LD_INT 4
73840: PUSH
73841: LD_INT 5
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: ST_TO_ADDR
73850: GO 74641
73852: LD_INT 12
73854: DOUBLE
73855: EQUAL
73856: IFTRUE 73860
73858: GO 73886
73860: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73861: LD_ADDR_VAR 0 3
73865: PUSH
73866: LD_INT 2
73868: PUSH
73869: LD_INT 3
73871: PUSH
73872: LD_INT 4
73874: PUSH
73875: LD_INT 5
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: ST_TO_ADDR
73884: GO 74641
73886: LD_INT 13
73888: DOUBLE
73889: EQUAL
73890: IFTRUE 73894
73892: GO 73920
73894: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73895: LD_ADDR_VAR 0 3
73899: PUSH
73900: LD_INT 2
73902: PUSH
73903: LD_INT 3
73905: PUSH
73906: LD_INT 4
73908: PUSH
73909: LD_INT 5
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: ST_TO_ADDR
73918: GO 74641
73920: LD_INT 14
73922: DOUBLE
73923: EQUAL
73924: IFTRUE 73928
73926: GO 73946
73928: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73929: LD_ADDR_VAR 0 3
73933: PUSH
73934: LD_INT 4
73936: PUSH
73937: LD_INT 5
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: ST_TO_ADDR
73944: GO 74641
73946: LD_INT 6
73948: DOUBLE
73949: EQUAL
73950: IFTRUE 73954
73952: GO 73972
73954: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73955: LD_ADDR_VAR 0 3
73959: PUSH
73960: LD_INT 4
73962: PUSH
73963: LD_INT 5
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: ST_TO_ADDR
73970: GO 74641
73972: LD_INT 10
73974: DOUBLE
73975: EQUAL
73976: IFTRUE 73980
73978: GO 73998
73980: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73981: LD_ADDR_VAR 0 3
73985: PUSH
73986: LD_INT 4
73988: PUSH
73989: LD_INT 5
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: ST_TO_ADDR
73996: GO 74641
73998: LD_INT 22
74000: DOUBLE
74001: EQUAL
74002: IFTRUE 74006
74004: GO 74032
74006: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74007: LD_ADDR_VAR 0 3
74011: PUSH
74012: LD_INT 11
74014: PUSH
74015: LD_INT 12
74017: PUSH
74018: LD_INT 13
74020: PUSH
74021: LD_INT 14
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: ST_TO_ADDR
74030: GO 74641
74032: LD_INT 23
74034: DOUBLE
74035: EQUAL
74036: IFTRUE 74040
74038: GO 74066
74040: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74041: LD_ADDR_VAR 0 3
74045: PUSH
74046: LD_INT 11
74048: PUSH
74049: LD_INT 12
74051: PUSH
74052: LD_INT 13
74054: PUSH
74055: LD_INT 14
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: ST_TO_ADDR
74064: GO 74641
74066: LD_INT 24
74068: DOUBLE
74069: EQUAL
74070: IFTRUE 74074
74072: GO 74100
74074: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74075: LD_ADDR_VAR 0 3
74079: PUSH
74080: LD_INT 11
74082: PUSH
74083: LD_INT 12
74085: PUSH
74086: LD_INT 13
74088: PUSH
74089: LD_INT 14
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: LIST
74096: LIST
74097: ST_TO_ADDR
74098: GO 74641
74100: LD_INT 30
74102: DOUBLE
74103: EQUAL
74104: IFTRUE 74108
74106: GO 74134
74108: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74109: LD_ADDR_VAR 0 3
74113: PUSH
74114: LD_INT 11
74116: PUSH
74117: LD_INT 12
74119: PUSH
74120: LD_INT 13
74122: PUSH
74123: LD_INT 14
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: ST_TO_ADDR
74132: GO 74641
74134: LD_INT 25
74136: DOUBLE
74137: EQUAL
74138: IFTRUE 74142
74140: GO 74160
74142: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74143: LD_ADDR_VAR 0 3
74147: PUSH
74148: LD_INT 13
74150: PUSH
74151: LD_INT 14
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: ST_TO_ADDR
74158: GO 74641
74160: LD_INT 27
74162: DOUBLE
74163: EQUAL
74164: IFTRUE 74168
74166: GO 74186
74168: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74169: LD_ADDR_VAR 0 3
74173: PUSH
74174: LD_INT 13
74176: PUSH
74177: LD_INT 14
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: ST_TO_ADDR
74184: GO 74641
74186: LD_INT 92
74188: DOUBLE
74189: EQUAL
74190: IFTRUE 74194
74192: GO 74220
74194: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74195: LD_ADDR_VAR 0 3
74199: PUSH
74200: LD_INT 11
74202: PUSH
74203: LD_INT 12
74205: PUSH
74206: LD_INT 13
74208: PUSH
74209: LD_INT 14
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: ST_TO_ADDR
74218: GO 74641
74220: LD_INT 28
74222: DOUBLE
74223: EQUAL
74224: IFTRUE 74228
74226: GO 74246
74228: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74229: LD_ADDR_VAR 0 3
74233: PUSH
74234: LD_INT 13
74236: PUSH
74237: LD_INT 14
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: ST_TO_ADDR
74244: GO 74641
74246: LD_INT 29
74248: DOUBLE
74249: EQUAL
74250: IFTRUE 74254
74252: GO 74272
74254: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
74255: LD_ADDR_VAR 0 3
74259: PUSH
74260: LD_INT 13
74262: PUSH
74263: LD_INT 14
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: ST_TO_ADDR
74270: GO 74641
74272: LD_INT 31
74274: DOUBLE
74275: EQUAL
74276: IFTRUE 74280
74278: GO 74298
74280: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
74281: LD_ADDR_VAR 0 3
74285: PUSH
74286: LD_INT 13
74288: PUSH
74289: LD_INT 14
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: ST_TO_ADDR
74296: GO 74641
74298: LD_INT 26
74300: DOUBLE
74301: EQUAL
74302: IFTRUE 74306
74304: GO 74324
74306: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
74307: LD_ADDR_VAR 0 3
74311: PUSH
74312: LD_INT 13
74314: PUSH
74315: LD_INT 14
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: ST_TO_ADDR
74322: GO 74641
74324: LD_INT 42
74326: DOUBLE
74327: EQUAL
74328: IFTRUE 74332
74330: GO 74358
74332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
74333: LD_ADDR_VAR 0 3
74337: PUSH
74338: LD_INT 21
74340: PUSH
74341: LD_INT 22
74343: PUSH
74344: LD_INT 23
74346: PUSH
74347: LD_INT 24
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: ST_TO_ADDR
74356: GO 74641
74358: LD_INT 43
74360: DOUBLE
74361: EQUAL
74362: IFTRUE 74366
74364: GO 74392
74366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
74367: LD_ADDR_VAR 0 3
74371: PUSH
74372: LD_INT 21
74374: PUSH
74375: LD_INT 22
74377: PUSH
74378: LD_INT 23
74380: PUSH
74381: LD_INT 24
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: ST_TO_ADDR
74390: GO 74641
74392: LD_INT 44
74394: DOUBLE
74395: EQUAL
74396: IFTRUE 74400
74398: GO 74426
74400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
74401: LD_ADDR_VAR 0 3
74405: PUSH
74406: LD_INT 21
74408: PUSH
74409: LD_INT 22
74411: PUSH
74412: LD_INT 23
74414: PUSH
74415: LD_INT 24
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: ST_TO_ADDR
74424: GO 74641
74426: LD_INT 45
74428: DOUBLE
74429: EQUAL
74430: IFTRUE 74434
74432: GO 74460
74434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
74435: LD_ADDR_VAR 0 3
74439: PUSH
74440: LD_INT 21
74442: PUSH
74443: LD_INT 22
74445: PUSH
74446: LD_INT 23
74448: PUSH
74449: LD_INT 24
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: ST_TO_ADDR
74458: GO 74641
74460: LD_INT 49
74462: DOUBLE
74463: EQUAL
74464: IFTRUE 74468
74466: GO 74494
74468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
74469: LD_ADDR_VAR 0 3
74473: PUSH
74474: LD_INT 21
74476: PUSH
74477: LD_INT 22
74479: PUSH
74480: LD_INT 23
74482: PUSH
74483: LD_INT 24
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: ST_TO_ADDR
74492: GO 74641
74494: LD_INT 51
74496: DOUBLE
74497: EQUAL
74498: IFTRUE 74502
74500: GO 74528
74502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
74503: LD_ADDR_VAR 0 3
74507: PUSH
74508: LD_INT 21
74510: PUSH
74511: LD_INT 22
74513: PUSH
74514: LD_INT 23
74516: PUSH
74517: LD_INT 24
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: ST_TO_ADDR
74526: GO 74641
74528: LD_INT 52
74530: DOUBLE
74531: EQUAL
74532: IFTRUE 74536
74534: GO 74562
74536: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
74537: LD_ADDR_VAR 0 3
74541: PUSH
74542: LD_INT 21
74544: PUSH
74545: LD_INT 22
74547: PUSH
74548: LD_INT 23
74550: PUSH
74551: LD_INT 24
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: ST_TO_ADDR
74560: GO 74641
74562: LD_INT 53
74564: DOUBLE
74565: EQUAL
74566: IFTRUE 74570
74568: GO 74588
74570: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74571: LD_ADDR_VAR 0 3
74575: PUSH
74576: LD_INT 23
74578: PUSH
74579: LD_INT 24
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: ST_TO_ADDR
74586: GO 74641
74588: LD_INT 46
74590: DOUBLE
74591: EQUAL
74592: IFTRUE 74596
74594: GO 74614
74596: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74597: LD_ADDR_VAR 0 3
74601: PUSH
74602: LD_INT 23
74604: PUSH
74605: LD_INT 24
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: ST_TO_ADDR
74612: GO 74641
74614: LD_INT 47
74616: DOUBLE
74617: EQUAL
74618: IFTRUE 74622
74620: GO 74640
74622: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74623: LD_ADDR_VAR 0 3
74627: PUSH
74628: LD_INT 23
74630: PUSH
74631: LD_INT 24
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: ST_TO_ADDR
74638: GO 74641
74640: POP
// result := ( chassis in result ) ;
74641: LD_ADDR_VAR 0 3
74645: PUSH
74646: LD_VAR 0 1
74650: PUSH
74651: LD_VAR 0 3
74655: IN
74656: ST_TO_ADDR
// end ;
74657: LD_VAR 0 3
74661: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74662: LD_INT 0
74664: PPUSH
74665: PPUSH
74666: PPUSH
74667: PPUSH
74668: PPUSH
74669: PPUSH
74670: PPUSH
// result := array ;
74671: LD_ADDR_VAR 0 5
74675: PUSH
74676: LD_VAR 0 1
74680: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74681: LD_VAR 0 1
74685: NOT
74686: PUSH
74687: LD_VAR 0 2
74691: NOT
74692: OR
74693: PUSH
74694: LD_VAR 0 3
74698: NOT
74699: OR
74700: PUSH
74701: LD_VAR 0 2
74705: PUSH
74706: LD_VAR 0 1
74710: GREATER
74711: OR
74712: PUSH
74713: LD_VAR 0 3
74717: PUSH
74718: LD_VAR 0 1
74722: GREATER
74723: OR
74724: IFFALSE 74728
// exit ;
74726: GO 75024
// if direction then
74728: LD_VAR 0 4
74732: IFFALSE 74796
// begin d := 1 ;
74734: LD_ADDR_VAR 0 9
74738: PUSH
74739: LD_INT 1
74741: ST_TO_ADDR
// if i_from > i_to then
74742: LD_VAR 0 2
74746: PUSH
74747: LD_VAR 0 3
74751: GREATER
74752: IFFALSE 74778
// length := ( array - i_from ) + i_to else
74754: LD_ADDR_VAR 0 11
74758: PUSH
74759: LD_VAR 0 1
74763: PUSH
74764: LD_VAR 0 2
74768: MINUS
74769: PUSH
74770: LD_VAR 0 3
74774: PLUS
74775: ST_TO_ADDR
74776: GO 74794
// length := i_to - i_from ;
74778: LD_ADDR_VAR 0 11
74782: PUSH
74783: LD_VAR 0 3
74787: PUSH
74788: LD_VAR 0 2
74792: MINUS
74793: ST_TO_ADDR
// end else
74794: GO 74857
// begin d := - 1 ;
74796: LD_ADDR_VAR 0 9
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: ST_TO_ADDR
// if i_from > i_to then
74805: LD_VAR 0 2
74809: PUSH
74810: LD_VAR 0 3
74814: GREATER
74815: IFFALSE 74835
// length := i_from - i_to else
74817: LD_ADDR_VAR 0 11
74821: PUSH
74822: LD_VAR 0 2
74826: PUSH
74827: LD_VAR 0 3
74831: MINUS
74832: ST_TO_ADDR
74833: GO 74857
// length := ( array - i_to ) + i_from ;
74835: LD_ADDR_VAR 0 11
74839: PUSH
74840: LD_VAR 0 1
74844: PUSH
74845: LD_VAR 0 3
74849: MINUS
74850: PUSH
74851: LD_VAR 0 2
74855: PLUS
74856: ST_TO_ADDR
// end ; if not length then
74857: LD_VAR 0 11
74861: NOT
74862: IFFALSE 74866
// exit ;
74864: GO 75024
// tmp := array ;
74866: LD_ADDR_VAR 0 10
74870: PUSH
74871: LD_VAR 0 1
74875: ST_TO_ADDR
// for i = 1 to length do
74876: LD_ADDR_VAR 0 6
74880: PUSH
74881: DOUBLE
74882: LD_INT 1
74884: DEC
74885: ST_TO_ADDR
74886: LD_VAR 0 11
74890: PUSH
74891: FOR_TO
74892: IFFALSE 75012
// begin for j = 1 to array do
74894: LD_ADDR_VAR 0 7
74898: PUSH
74899: DOUBLE
74900: LD_INT 1
74902: DEC
74903: ST_TO_ADDR
74904: LD_VAR 0 1
74908: PUSH
74909: FOR_TO
74910: IFFALSE 74998
// begin k := j + d ;
74912: LD_ADDR_VAR 0 8
74916: PUSH
74917: LD_VAR 0 7
74921: PUSH
74922: LD_VAR 0 9
74926: PLUS
74927: ST_TO_ADDR
// if k > array then
74928: LD_VAR 0 8
74932: PUSH
74933: LD_VAR 0 1
74937: GREATER
74938: IFFALSE 74948
// k := 1 ;
74940: LD_ADDR_VAR 0 8
74944: PUSH
74945: LD_INT 1
74947: ST_TO_ADDR
// if not k then
74948: LD_VAR 0 8
74952: NOT
74953: IFFALSE 74965
// k := array ;
74955: LD_ADDR_VAR 0 8
74959: PUSH
74960: LD_VAR 0 1
74964: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74965: LD_ADDR_VAR 0 10
74969: PUSH
74970: LD_VAR 0 10
74974: PPUSH
74975: LD_VAR 0 8
74979: PPUSH
74980: LD_VAR 0 1
74984: PUSH
74985: LD_VAR 0 7
74989: ARRAY
74990: PPUSH
74991: CALL_OW 1
74995: ST_TO_ADDR
// end ;
74996: GO 74909
74998: POP
74999: POP
// array := tmp ;
75000: LD_ADDR_VAR 0 1
75004: PUSH
75005: LD_VAR 0 10
75009: ST_TO_ADDR
// end ;
75010: GO 74891
75012: POP
75013: POP
// result := array ;
75014: LD_ADDR_VAR 0 5
75018: PUSH
75019: LD_VAR 0 1
75023: ST_TO_ADDR
// end ;
75024: LD_VAR 0 5
75028: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75029: LD_INT 0
75031: PPUSH
75032: PPUSH
// result := 0 ;
75033: LD_ADDR_VAR 0 3
75037: PUSH
75038: LD_INT 0
75040: ST_TO_ADDR
// if not array or not value in array then
75041: LD_VAR 0 1
75045: NOT
75046: PUSH
75047: LD_VAR 0 2
75051: PUSH
75052: LD_VAR 0 1
75056: IN
75057: NOT
75058: OR
75059: IFFALSE 75063
// exit ;
75061: GO 75117
// for i = 1 to array do
75063: LD_ADDR_VAR 0 4
75067: PUSH
75068: DOUBLE
75069: LD_INT 1
75071: DEC
75072: ST_TO_ADDR
75073: LD_VAR 0 1
75077: PUSH
75078: FOR_TO
75079: IFFALSE 75115
// if value = array [ i ] then
75081: LD_VAR 0 2
75085: PUSH
75086: LD_VAR 0 1
75090: PUSH
75091: LD_VAR 0 4
75095: ARRAY
75096: EQUAL
75097: IFFALSE 75113
// begin result := i ;
75099: LD_ADDR_VAR 0 3
75103: PUSH
75104: LD_VAR 0 4
75108: ST_TO_ADDR
// exit ;
75109: POP
75110: POP
75111: GO 75117
// end ;
75113: GO 75078
75115: POP
75116: POP
// end ;
75117: LD_VAR 0 3
75121: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75122: LD_INT 0
75124: PPUSH
// vc_chassis := chassis ;
75125: LD_ADDR_OWVAR 37
75129: PUSH
75130: LD_VAR 0 1
75134: ST_TO_ADDR
// vc_engine := engine ;
75135: LD_ADDR_OWVAR 39
75139: PUSH
75140: LD_VAR 0 2
75144: ST_TO_ADDR
// vc_control := control ;
75145: LD_ADDR_OWVAR 38
75149: PUSH
75150: LD_VAR 0 3
75154: ST_TO_ADDR
// vc_weapon := weapon ;
75155: LD_ADDR_OWVAR 40
75159: PUSH
75160: LD_VAR 0 4
75164: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75165: LD_ADDR_OWVAR 41
75169: PUSH
75170: LD_VAR 0 5
75174: ST_TO_ADDR
// end ;
75175: LD_VAR 0 6
75179: RET
// export function WantPlant ( unit ) ; var task ; begin
75180: LD_INT 0
75182: PPUSH
75183: PPUSH
// result := false ;
75184: LD_ADDR_VAR 0 2
75188: PUSH
75189: LD_INT 0
75191: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75192: LD_ADDR_VAR 0 3
75196: PUSH
75197: LD_VAR 0 1
75201: PPUSH
75202: CALL_OW 437
75206: ST_TO_ADDR
// if task then
75207: LD_VAR 0 3
75211: IFFALSE 75239
// if task [ 1 ] [ 1 ] = p then
75213: LD_VAR 0 3
75217: PUSH
75218: LD_INT 1
75220: ARRAY
75221: PUSH
75222: LD_INT 1
75224: ARRAY
75225: PUSH
75226: LD_STRING p
75228: EQUAL
75229: IFFALSE 75239
// result := true ;
75231: LD_ADDR_VAR 0 2
75235: PUSH
75236: LD_INT 1
75238: ST_TO_ADDR
// end ;
75239: LD_VAR 0 2
75243: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
75244: LD_INT 0
75246: PPUSH
75247: PPUSH
75248: PPUSH
75249: PPUSH
// if pos < 1 then
75250: LD_VAR 0 2
75254: PUSH
75255: LD_INT 1
75257: LESS
75258: IFFALSE 75262
// exit ;
75260: GO 75565
// if pos = 1 then
75262: LD_VAR 0 2
75266: PUSH
75267: LD_INT 1
75269: EQUAL
75270: IFFALSE 75303
// result := Replace ( arr , pos [ 1 ] , value ) else
75272: LD_ADDR_VAR 0 4
75276: PUSH
75277: LD_VAR 0 1
75281: PPUSH
75282: LD_VAR 0 2
75286: PUSH
75287: LD_INT 1
75289: ARRAY
75290: PPUSH
75291: LD_VAR 0 3
75295: PPUSH
75296: CALL_OW 1
75300: ST_TO_ADDR
75301: GO 75565
// begin tmp := arr ;
75303: LD_ADDR_VAR 0 6
75307: PUSH
75308: LD_VAR 0 1
75312: ST_TO_ADDR
// s_arr := [ tmp ] ;
75313: LD_ADDR_VAR 0 7
75317: PUSH
75318: LD_VAR 0 6
75322: PUSH
75323: EMPTY
75324: LIST
75325: ST_TO_ADDR
// for i = 1 to pos - 1 do
75326: LD_ADDR_VAR 0 5
75330: PUSH
75331: DOUBLE
75332: LD_INT 1
75334: DEC
75335: ST_TO_ADDR
75336: LD_VAR 0 2
75340: PUSH
75341: LD_INT 1
75343: MINUS
75344: PUSH
75345: FOR_TO
75346: IFFALSE 75391
// begin tmp := tmp [ pos [ i ] ] ;
75348: LD_ADDR_VAR 0 6
75352: PUSH
75353: LD_VAR 0 6
75357: PUSH
75358: LD_VAR 0 2
75362: PUSH
75363: LD_VAR 0 5
75367: ARRAY
75368: ARRAY
75369: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
75370: LD_ADDR_VAR 0 7
75374: PUSH
75375: LD_VAR 0 7
75379: PUSH
75380: LD_VAR 0 6
75384: PUSH
75385: EMPTY
75386: LIST
75387: ADD
75388: ST_TO_ADDR
// end ;
75389: GO 75345
75391: POP
75392: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
75393: LD_ADDR_VAR 0 6
75397: PUSH
75398: LD_VAR 0 6
75402: PPUSH
75403: LD_VAR 0 2
75407: PUSH
75408: LD_VAR 0 2
75412: ARRAY
75413: PPUSH
75414: LD_VAR 0 3
75418: PPUSH
75419: CALL_OW 1
75423: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
75424: LD_ADDR_VAR 0 7
75428: PUSH
75429: LD_VAR 0 7
75433: PPUSH
75434: LD_VAR 0 7
75438: PPUSH
75439: LD_VAR 0 6
75443: PPUSH
75444: CALL_OW 1
75448: ST_TO_ADDR
// for i = s_arr downto 2 do
75449: LD_ADDR_VAR 0 5
75453: PUSH
75454: DOUBLE
75455: LD_VAR 0 7
75459: INC
75460: ST_TO_ADDR
75461: LD_INT 2
75463: PUSH
75464: FOR_DOWNTO
75465: IFFALSE 75549
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
75467: LD_ADDR_VAR 0 6
75471: PUSH
75472: LD_VAR 0 7
75476: PUSH
75477: LD_VAR 0 5
75481: PUSH
75482: LD_INT 1
75484: MINUS
75485: ARRAY
75486: PPUSH
75487: LD_VAR 0 2
75491: PUSH
75492: LD_VAR 0 5
75496: PUSH
75497: LD_INT 1
75499: MINUS
75500: ARRAY
75501: PPUSH
75502: LD_VAR 0 7
75506: PUSH
75507: LD_VAR 0 5
75511: ARRAY
75512: PPUSH
75513: CALL_OW 1
75517: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
75518: LD_ADDR_VAR 0 7
75522: PUSH
75523: LD_VAR 0 7
75527: PPUSH
75528: LD_VAR 0 5
75532: PUSH
75533: LD_INT 1
75535: MINUS
75536: PPUSH
75537: LD_VAR 0 6
75541: PPUSH
75542: CALL_OW 1
75546: ST_TO_ADDR
// end ;
75547: GO 75464
75549: POP
75550: POP
// result := s_arr [ 1 ] ;
75551: LD_ADDR_VAR 0 4
75555: PUSH
75556: LD_VAR 0 7
75560: PUSH
75561: LD_INT 1
75563: ARRAY
75564: ST_TO_ADDR
// end ; end ;
75565: LD_VAR 0 4
75569: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75570: LD_INT 0
75572: PPUSH
75573: PPUSH
// if not list then
75574: LD_VAR 0 1
75578: NOT
75579: IFFALSE 75583
// exit ;
75581: GO 75674
// i := list [ pos1 ] ;
75583: LD_ADDR_VAR 0 5
75587: PUSH
75588: LD_VAR 0 1
75592: PUSH
75593: LD_VAR 0 2
75597: ARRAY
75598: ST_TO_ADDR
// if not i then
75599: LD_VAR 0 5
75603: NOT
75604: IFFALSE 75608
// exit ;
75606: GO 75674
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75608: LD_ADDR_VAR 0 1
75612: PUSH
75613: LD_VAR 0 1
75617: PPUSH
75618: LD_VAR 0 2
75622: PPUSH
75623: LD_VAR 0 1
75627: PUSH
75628: LD_VAR 0 3
75632: ARRAY
75633: PPUSH
75634: CALL_OW 1
75638: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75639: LD_ADDR_VAR 0 1
75643: PUSH
75644: LD_VAR 0 1
75648: PPUSH
75649: LD_VAR 0 3
75653: PPUSH
75654: LD_VAR 0 5
75658: PPUSH
75659: CALL_OW 1
75663: ST_TO_ADDR
// result := list ;
75664: LD_ADDR_VAR 0 4
75668: PUSH
75669: LD_VAR 0 1
75673: ST_TO_ADDR
// end ;
75674: LD_VAR 0 4
75678: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75679: LD_INT 0
75681: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75682: LD_ADDR_VAR 0 5
75686: PUSH
75687: LD_VAR 0 1
75691: PPUSH
75692: CALL_OW 250
75696: PPUSH
75697: LD_VAR 0 1
75701: PPUSH
75702: CALL_OW 251
75706: PPUSH
75707: LD_VAR 0 2
75711: PPUSH
75712: LD_VAR 0 3
75716: PPUSH
75717: LD_VAR 0 4
75721: PPUSH
75722: CALL 76100 0 5
75726: ST_TO_ADDR
// end ;
75727: LD_VAR 0 5
75731: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75732: LD_INT 0
75734: PPUSH
75735: PPUSH
75736: PPUSH
75737: PPUSH
// if not list or not unit then
75738: LD_VAR 0 2
75742: NOT
75743: PUSH
75744: LD_VAR 0 1
75748: NOT
75749: OR
75750: IFFALSE 75754
// exit ;
75752: GO 76095
// result := [ ] ;
75754: LD_ADDR_VAR 0 5
75758: PUSH
75759: EMPTY
75760: ST_TO_ADDR
// for i in list do
75761: LD_ADDR_VAR 0 6
75765: PUSH
75766: LD_VAR 0 2
75770: PUSH
75771: FOR_IN
75772: IFFALSE 75990
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75774: LD_ADDR_VAR 0 8
75778: PUSH
75779: LD_VAR 0 1
75783: PPUSH
75784: LD_VAR 0 6
75788: PUSH
75789: LD_INT 1
75791: ARRAY
75792: PPUSH
75793: LD_VAR 0 6
75797: PUSH
75798: LD_INT 2
75800: ARRAY
75801: PPUSH
75802: CALL_OW 297
75806: ST_TO_ADDR
// if not Count ( result ) then
75807: LD_VAR 0 5
75811: PPUSH
75812: CALL 72384 0 1
75816: NOT
75817: IFFALSE 75850
// begin result := Join ( result , [ i , tmp ] ) ;
75819: LD_ADDR_VAR 0 5
75823: PUSH
75824: LD_VAR 0 5
75828: PPUSH
75829: LD_VAR 0 6
75833: PUSH
75834: LD_VAR 0 8
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PPUSH
75843: CALL 107973 0 2
75847: ST_TO_ADDR
// continue ;
75848: GO 75771
// end ; if result [ result ] [ 2 ] <= tmp then
75850: LD_VAR 0 5
75854: PUSH
75855: LD_VAR 0 5
75859: ARRAY
75860: PUSH
75861: LD_INT 2
75863: ARRAY
75864: PUSH
75865: LD_VAR 0 8
75869: LESSEQUAL
75870: IFFALSE 75903
// result := Join ( result , [ i , tmp ] ) else
75872: LD_ADDR_VAR 0 5
75876: PUSH
75877: LD_VAR 0 5
75881: PPUSH
75882: LD_VAR 0 6
75886: PUSH
75887: LD_VAR 0 8
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PPUSH
75896: CALL 107973 0 2
75900: ST_TO_ADDR
75901: GO 75988
// begin for j := 1 to Count ( result ) do
75903: LD_ADDR_VAR 0 7
75907: PUSH
75908: DOUBLE
75909: LD_INT 1
75911: DEC
75912: ST_TO_ADDR
75913: LD_VAR 0 5
75917: PPUSH
75918: CALL 72384 0 1
75922: PUSH
75923: FOR_TO
75924: IFFALSE 75986
// begin if tmp < result [ j ] [ 2 ] then
75926: LD_VAR 0 8
75930: PUSH
75931: LD_VAR 0 5
75935: PUSH
75936: LD_VAR 0 7
75940: ARRAY
75941: PUSH
75942: LD_INT 2
75944: ARRAY
75945: LESS
75946: IFFALSE 75984
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75948: LD_ADDR_VAR 0 5
75952: PUSH
75953: LD_VAR 0 5
75957: PPUSH
75958: LD_VAR 0 7
75962: PPUSH
75963: LD_VAR 0 6
75967: PUSH
75968: LD_VAR 0 8
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PPUSH
75977: CALL_OW 2
75981: ST_TO_ADDR
// break ;
75982: GO 75986
// end ; end ;
75984: GO 75923
75986: POP
75987: POP
// end ; end ;
75988: GO 75771
75990: POP
75991: POP
// if result and not asc then
75992: LD_VAR 0 5
75996: PUSH
75997: LD_VAR 0 3
76001: NOT
76002: AND
76003: IFFALSE 76020
// result := ReverseArray ( result ) ;
76005: LD_ADDR_VAR 0 5
76009: PUSH
76010: LD_VAR 0 5
76014: PPUSH
76015: CALL 103260 0 1
76019: ST_TO_ADDR
// tmp := [ ] ;
76020: LD_ADDR_VAR 0 8
76024: PUSH
76025: EMPTY
76026: ST_TO_ADDR
// if mode then
76027: LD_VAR 0 4
76031: IFFALSE 76095
// begin for i := 1 to result do
76033: LD_ADDR_VAR 0 6
76037: PUSH
76038: DOUBLE
76039: LD_INT 1
76041: DEC
76042: ST_TO_ADDR
76043: LD_VAR 0 5
76047: PUSH
76048: FOR_TO
76049: IFFALSE 76083
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76051: LD_ADDR_VAR 0 8
76055: PUSH
76056: LD_VAR 0 8
76060: PPUSH
76061: LD_VAR 0 5
76065: PUSH
76066: LD_VAR 0 6
76070: ARRAY
76071: PUSH
76072: LD_INT 1
76074: ARRAY
76075: PPUSH
76076: CALL 107973 0 2
76080: ST_TO_ADDR
76081: GO 76048
76083: POP
76084: POP
// result := tmp ;
76085: LD_ADDR_VAR 0 5
76089: PUSH
76090: LD_VAR 0 8
76094: ST_TO_ADDR
// end ; end ;
76095: LD_VAR 0 5
76099: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76100: LD_INT 0
76102: PPUSH
76103: PPUSH
76104: PPUSH
76105: PPUSH
// if not list then
76106: LD_VAR 0 3
76110: NOT
76111: IFFALSE 76115
// exit ;
76113: GO 76503
// result := [ ] ;
76115: LD_ADDR_VAR 0 6
76119: PUSH
76120: EMPTY
76121: ST_TO_ADDR
// for i in list do
76122: LD_ADDR_VAR 0 7
76126: PUSH
76127: LD_VAR 0 3
76131: PUSH
76132: FOR_IN
76133: IFFALSE 76335
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76135: LD_ADDR_VAR 0 9
76139: PUSH
76140: LD_VAR 0 7
76144: PPUSH
76145: LD_VAR 0 1
76149: PPUSH
76150: LD_VAR 0 2
76154: PPUSH
76155: CALL_OW 297
76159: ST_TO_ADDR
// if not result then
76160: LD_VAR 0 6
76164: NOT
76165: IFFALSE 76191
// result := [ [ i , tmp ] ] else
76167: LD_ADDR_VAR 0 6
76171: PUSH
76172: LD_VAR 0 7
76176: PUSH
76177: LD_VAR 0 9
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: EMPTY
76187: LIST
76188: ST_TO_ADDR
76189: GO 76333
// begin if result [ result ] [ 2 ] < tmp then
76191: LD_VAR 0 6
76195: PUSH
76196: LD_VAR 0 6
76200: ARRAY
76201: PUSH
76202: LD_INT 2
76204: ARRAY
76205: PUSH
76206: LD_VAR 0 9
76210: LESS
76211: IFFALSE 76253
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76213: LD_ADDR_VAR 0 6
76217: PUSH
76218: LD_VAR 0 6
76222: PPUSH
76223: LD_VAR 0 6
76227: PUSH
76228: LD_INT 1
76230: PLUS
76231: PPUSH
76232: LD_VAR 0 7
76236: PUSH
76237: LD_VAR 0 9
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PPUSH
76246: CALL_OW 2
76250: ST_TO_ADDR
76251: GO 76333
// for j = 1 to result do
76253: LD_ADDR_VAR 0 8
76257: PUSH
76258: DOUBLE
76259: LD_INT 1
76261: DEC
76262: ST_TO_ADDR
76263: LD_VAR 0 6
76267: PUSH
76268: FOR_TO
76269: IFFALSE 76331
// begin if tmp < result [ j ] [ 2 ] then
76271: LD_VAR 0 9
76275: PUSH
76276: LD_VAR 0 6
76280: PUSH
76281: LD_VAR 0 8
76285: ARRAY
76286: PUSH
76287: LD_INT 2
76289: ARRAY
76290: LESS
76291: IFFALSE 76329
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76293: LD_ADDR_VAR 0 6
76297: PUSH
76298: LD_VAR 0 6
76302: PPUSH
76303: LD_VAR 0 8
76307: PPUSH
76308: LD_VAR 0 7
76312: PUSH
76313: LD_VAR 0 9
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PPUSH
76322: CALL_OW 2
76326: ST_TO_ADDR
// break ;
76327: GO 76331
// end ; end ;
76329: GO 76268
76331: POP
76332: POP
// end ; end ;
76333: GO 76132
76335: POP
76336: POP
// if result and not asc then
76337: LD_VAR 0 6
76341: PUSH
76342: LD_VAR 0 4
76346: NOT
76347: AND
76348: IFFALSE 76423
// begin tmp := result ;
76350: LD_ADDR_VAR 0 9
76354: PUSH
76355: LD_VAR 0 6
76359: ST_TO_ADDR
// for i = tmp downto 1 do
76360: LD_ADDR_VAR 0 7
76364: PUSH
76365: DOUBLE
76366: LD_VAR 0 9
76370: INC
76371: ST_TO_ADDR
76372: LD_INT 1
76374: PUSH
76375: FOR_DOWNTO
76376: IFFALSE 76421
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
76378: LD_ADDR_VAR 0 6
76382: PUSH
76383: LD_VAR 0 6
76387: PPUSH
76388: LD_VAR 0 9
76392: PUSH
76393: LD_VAR 0 7
76397: MINUS
76398: PUSH
76399: LD_INT 1
76401: PLUS
76402: PPUSH
76403: LD_VAR 0 9
76407: PUSH
76408: LD_VAR 0 7
76412: ARRAY
76413: PPUSH
76414: CALL_OW 1
76418: ST_TO_ADDR
76419: GO 76375
76421: POP
76422: POP
// end ; tmp := [ ] ;
76423: LD_ADDR_VAR 0 9
76427: PUSH
76428: EMPTY
76429: ST_TO_ADDR
// if mode then
76430: LD_VAR 0 5
76434: IFFALSE 76503
// begin for i = 1 to result do
76436: LD_ADDR_VAR 0 7
76440: PUSH
76441: DOUBLE
76442: LD_INT 1
76444: DEC
76445: ST_TO_ADDR
76446: LD_VAR 0 6
76450: PUSH
76451: FOR_TO
76452: IFFALSE 76491
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
76454: LD_ADDR_VAR 0 9
76458: PUSH
76459: LD_VAR 0 9
76463: PPUSH
76464: LD_VAR 0 7
76468: PPUSH
76469: LD_VAR 0 6
76473: PUSH
76474: LD_VAR 0 7
76478: ARRAY
76479: PUSH
76480: LD_INT 1
76482: ARRAY
76483: PPUSH
76484: CALL_OW 1
76488: ST_TO_ADDR
76489: GO 76451
76491: POP
76492: POP
// result := tmp ;
76493: LD_ADDR_VAR 0 6
76497: PUSH
76498: LD_VAR 0 9
76502: ST_TO_ADDR
// end ; end ;
76503: LD_VAR 0 6
76507: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
76508: LD_INT 0
76510: PPUSH
76511: PPUSH
76512: PPUSH
76513: PPUSH
76514: PPUSH
76515: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
76516: LD_ADDR_VAR 0 5
76520: PUSH
76521: LD_INT 0
76523: PUSH
76524: LD_INT 0
76526: PUSH
76527: LD_INT 0
76529: PUSH
76530: EMPTY
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: ST_TO_ADDR
// if not x or not y then
76538: LD_VAR 0 2
76542: NOT
76543: PUSH
76544: LD_VAR 0 3
76548: NOT
76549: OR
76550: IFFALSE 76554
// exit ;
76552: GO 78204
// if not range then
76554: LD_VAR 0 4
76558: NOT
76559: IFFALSE 76569
// range := 10 ;
76561: LD_ADDR_VAR 0 4
76565: PUSH
76566: LD_INT 10
76568: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76569: LD_ADDR_VAR 0 8
76573: PUSH
76574: LD_INT 81
76576: PUSH
76577: LD_VAR 0 1
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 92
76588: PUSH
76589: LD_VAR 0 2
76593: PUSH
76594: LD_VAR 0 3
76598: PUSH
76599: LD_VAR 0 4
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 3
76612: PUSH
76613: LD_INT 21
76615: PUSH
76616: LD_INT 3
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: LIST
76631: PPUSH
76632: CALL_OW 69
76636: ST_TO_ADDR
// if not tmp then
76637: LD_VAR 0 8
76641: NOT
76642: IFFALSE 76646
// exit ;
76644: GO 78204
// for i in tmp do
76646: LD_ADDR_VAR 0 6
76650: PUSH
76651: LD_VAR 0 8
76655: PUSH
76656: FOR_IN
76657: IFFALSE 78179
// begin points := [ 0 , 0 , 0 ] ;
76659: LD_ADDR_VAR 0 9
76663: PUSH
76664: LD_INT 0
76666: PUSH
76667: LD_INT 0
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: LIST
76677: ST_TO_ADDR
// bpoints := 1 ;
76678: LD_ADDR_VAR 0 10
76682: PUSH
76683: LD_INT 1
76685: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76686: LD_VAR 0 6
76690: PPUSH
76691: CALL_OW 247
76695: PUSH
76696: LD_INT 1
76698: DOUBLE
76699: EQUAL
76700: IFTRUE 76704
76702: GO 77282
76704: POP
// begin if GetClass ( i ) = 1 then
76705: LD_VAR 0 6
76709: PPUSH
76710: CALL_OW 257
76714: PUSH
76715: LD_INT 1
76717: EQUAL
76718: IFFALSE 76739
// points := [ 10 , 5 , 3 ] ;
76720: LD_ADDR_VAR 0 9
76724: PUSH
76725: LD_INT 10
76727: PUSH
76728: LD_INT 5
76730: PUSH
76731: LD_INT 3
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: LIST
76738: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76739: LD_VAR 0 6
76743: PPUSH
76744: CALL_OW 257
76748: PUSH
76749: LD_INT 2
76751: PUSH
76752: LD_INT 3
76754: PUSH
76755: LD_INT 4
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: LIST
76762: IN
76763: IFFALSE 76784
// points := [ 3 , 2 , 1 ] ;
76765: LD_ADDR_VAR 0 9
76769: PUSH
76770: LD_INT 3
76772: PUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 1
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: LIST
76783: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76784: LD_VAR 0 6
76788: PPUSH
76789: CALL_OW 257
76793: PUSH
76794: LD_INT 5
76796: EQUAL
76797: IFFALSE 76818
// points := [ 130 , 5 , 2 ] ;
76799: LD_ADDR_VAR 0 9
76803: PUSH
76804: LD_INT 130
76806: PUSH
76807: LD_INT 5
76809: PUSH
76810: LD_INT 2
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: LIST
76817: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76818: LD_VAR 0 6
76822: PPUSH
76823: CALL_OW 257
76827: PUSH
76828: LD_INT 8
76830: EQUAL
76831: IFFALSE 76852
// points := [ 35 , 35 , 30 ] ;
76833: LD_ADDR_VAR 0 9
76837: PUSH
76838: LD_INT 35
76840: PUSH
76841: LD_INT 35
76843: PUSH
76844: LD_INT 30
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: LIST
76851: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76852: LD_VAR 0 6
76856: PPUSH
76857: CALL_OW 257
76861: PUSH
76862: LD_INT 9
76864: EQUAL
76865: IFFALSE 76886
// points := [ 20 , 55 , 40 ] ;
76867: LD_ADDR_VAR 0 9
76871: PUSH
76872: LD_INT 20
76874: PUSH
76875: LD_INT 55
76877: PUSH
76878: LD_INT 40
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: LIST
76885: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76886: LD_VAR 0 6
76890: PPUSH
76891: CALL_OW 257
76895: PUSH
76896: LD_INT 12
76898: PUSH
76899: LD_INT 16
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: IN
76906: IFFALSE 76927
// points := [ 5 , 3 , 2 ] ;
76908: LD_ADDR_VAR 0 9
76912: PUSH
76913: LD_INT 5
76915: PUSH
76916: LD_INT 3
76918: PUSH
76919: LD_INT 2
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: LIST
76926: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76927: LD_VAR 0 6
76931: PPUSH
76932: CALL_OW 257
76936: PUSH
76937: LD_INT 17
76939: EQUAL
76940: IFFALSE 76961
// points := [ 100 , 50 , 75 ] ;
76942: LD_ADDR_VAR 0 9
76946: PUSH
76947: LD_INT 100
76949: PUSH
76950: LD_INT 50
76952: PUSH
76953: LD_INT 75
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: LIST
76960: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76961: LD_VAR 0 6
76965: PPUSH
76966: CALL_OW 257
76970: PUSH
76971: LD_INT 15
76973: EQUAL
76974: IFFALSE 76995
// points := [ 10 , 5 , 3 ] ;
76976: LD_ADDR_VAR 0 9
76980: PUSH
76981: LD_INT 10
76983: PUSH
76984: LD_INT 5
76986: PUSH
76987: LD_INT 3
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: LIST
76994: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76995: LD_VAR 0 6
76999: PPUSH
77000: CALL_OW 257
77004: PUSH
77005: LD_INT 14
77007: EQUAL
77008: IFFALSE 77029
// points := [ 10 , 0 , 0 ] ;
77010: LD_ADDR_VAR 0 9
77014: PUSH
77015: LD_INT 10
77017: PUSH
77018: LD_INT 0
77020: PUSH
77021: LD_INT 0
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: LIST
77028: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77029: LD_VAR 0 6
77033: PPUSH
77034: CALL_OW 257
77038: PUSH
77039: LD_INT 11
77041: EQUAL
77042: IFFALSE 77063
// points := [ 30 , 10 , 5 ] ;
77044: LD_ADDR_VAR 0 9
77048: PUSH
77049: LD_INT 30
77051: PUSH
77052: LD_INT 10
77054: PUSH
77055: LD_INT 5
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: LIST
77062: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77063: LD_VAR 0 1
77067: PPUSH
77068: LD_INT 5
77070: PPUSH
77071: CALL_OW 321
77075: PUSH
77076: LD_INT 2
77078: EQUAL
77079: IFFALSE 77096
// bpoints := bpoints * 1.8 ;
77081: LD_ADDR_VAR 0 10
77085: PUSH
77086: LD_VAR 0 10
77090: PUSH
77091: LD_REAL  1.80000000000000E+0000
77094: MUL
77095: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77096: LD_VAR 0 6
77100: PPUSH
77101: CALL_OW 257
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: LD_INT 2
77111: PUSH
77112: LD_INT 3
77114: PUSH
77115: LD_INT 4
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: IN
77124: PUSH
77125: LD_VAR 0 1
77129: PPUSH
77130: LD_INT 51
77132: PPUSH
77133: CALL_OW 321
77137: PUSH
77138: LD_INT 2
77140: EQUAL
77141: AND
77142: IFFALSE 77159
// bpoints := bpoints * 1.2 ;
77144: LD_ADDR_VAR 0 10
77148: PUSH
77149: LD_VAR 0 10
77153: PUSH
77154: LD_REAL  1.20000000000000E+0000
77157: MUL
77158: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77159: LD_VAR 0 6
77163: PPUSH
77164: CALL_OW 257
77168: PUSH
77169: LD_INT 5
77171: PUSH
77172: LD_INT 7
77174: PUSH
77175: LD_INT 9
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: LIST
77182: IN
77183: PUSH
77184: LD_VAR 0 1
77188: PPUSH
77189: LD_INT 52
77191: PPUSH
77192: CALL_OW 321
77196: PUSH
77197: LD_INT 2
77199: EQUAL
77200: AND
77201: IFFALSE 77218
// bpoints := bpoints * 1.5 ;
77203: LD_ADDR_VAR 0 10
77207: PUSH
77208: LD_VAR 0 10
77212: PUSH
77213: LD_REAL  1.50000000000000E+0000
77216: MUL
77217: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
77218: LD_VAR 0 1
77222: PPUSH
77223: LD_INT 66
77225: PPUSH
77226: CALL_OW 321
77230: PUSH
77231: LD_INT 2
77233: EQUAL
77234: IFFALSE 77251
// bpoints := bpoints * 1.1 ;
77236: LD_ADDR_VAR 0 10
77240: PUSH
77241: LD_VAR 0 10
77245: PUSH
77246: LD_REAL  1.10000000000000E+0000
77249: MUL
77250: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
77251: LD_ADDR_VAR 0 10
77255: PUSH
77256: LD_VAR 0 10
77260: PUSH
77261: LD_VAR 0 6
77265: PPUSH
77266: LD_INT 1
77268: PPUSH
77269: CALL_OW 259
77273: PUSH
77274: LD_REAL  1.15000000000000E+0000
77277: MUL
77278: MUL
77279: ST_TO_ADDR
// end ; unit_vehicle :
77280: GO 78108
77282: LD_INT 2
77284: DOUBLE
77285: EQUAL
77286: IFTRUE 77290
77288: GO 78096
77290: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
77291: LD_VAR 0 6
77295: PPUSH
77296: CALL_OW 264
77300: PUSH
77301: LD_INT 2
77303: PUSH
77304: LD_INT 42
77306: PUSH
77307: LD_INT 24
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: LIST
77314: IN
77315: IFFALSE 77336
// points := [ 25 , 5 , 3 ] ;
77317: LD_ADDR_VAR 0 9
77321: PUSH
77322: LD_INT 25
77324: PUSH
77325: LD_INT 5
77327: PUSH
77328: LD_INT 3
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: LIST
77335: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
77336: LD_VAR 0 6
77340: PPUSH
77341: CALL_OW 264
77345: PUSH
77346: LD_INT 4
77348: PUSH
77349: LD_INT 43
77351: PUSH
77352: LD_INT 25
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: LIST
77359: IN
77360: IFFALSE 77381
// points := [ 40 , 15 , 5 ] ;
77362: LD_ADDR_VAR 0 9
77366: PUSH
77367: LD_INT 40
77369: PUSH
77370: LD_INT 15
77372: PUSH
77373: LD_INT 5
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: LIST
77380: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
77381: LD_VAR 0 6
77385: PPUSH
77386: CALL_OW 264
77390: PUSH
77391: LD_INT 3
77393: PUSH
77394: LD_INT 23
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: IN
77401: IFFALSE 77422
// points := [ 7 , 25 , 8 ] ;
77403: LD_ADDR_VAR 0 9
77407: PUSH
77408: LD_INT 7
77410: PUSH
77411: LD_INT 25
77413: PUSH
77414: LD_INT 8
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
77422: LD_VAR 0 6
77426: PPUSH
77427: CALL_OW 264
77431: PUSH
77432: LD_INT 5
77434: PUSH
77435: LD_INT 27
77437: PUSH
77438: LD_INT 44
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: LIST
77445: IN
77446: IFFALSE 77467
// points := [ 14 , 50 , 16 ] ;
77448: LD_ADDR_VAR 0 9
77452: PUSH
77453: LD_INT 14
77455: PUSH
77456: LD_INT 50
77458: PUSH
77459: LD_INT 16
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: LIST
77466: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
77467: LD_VAR 0 6
77471: PPUSH
77472: CALL_OW 264
77476: PUSH
77477: LD_INT 6
77479: PUSH
77480: LD_INT 46
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: IN
77487: IFFALSE 77508
// points := [ 32 , 120 , 70 ] ;
77489: LD_ADDR_VAR 0 9
77493: PUSH
77494: LD_INT 32
77496: PUSH
77497: LD_INT 120
77499: PUSH
77500: LD_INT 70
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: LIST
77507: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
77508: LD_VAR 0 6
77512: PPUSH
77513: CALL_OW 264
77517: PUSH
77518: LD_INT 7
77520: PUSH
77521: LD_INT 28
77523: PUSH
77524: LD_INT 45
77526: PUSH
77527: LD_INT 92
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: LIST
77534: LIST
77535: IN
77536: IFFALSE 77557
// points := [ 35 , 20 , 45 ] ;
77538: LD_ADDR_VAR 0 9
77542: PUSH
77543: LD_INT 35
77545: PUSH
77546: LD_INT 20
77548: PUSH
77549: LD_INT 45
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: LIST
77556: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
77557: LD_VAR 0 6
77561: PPUSH
77562: CALL_OW 264
77566: PUSH
77567: LD_INT 47
77569: PUSH
77570: EMPTY
77571: LIST
77572: IN
77573: IFFALSE 77594
// points := [ 67 , 45 , 75 ] ;
77575: LD_ADDR_VAR 0 9
77579: PUSH
77580: LD_INT 67
77582: PUSH
77583: LD_INT 45
77585: PUSH
77586: LD_INT 75
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: LIST
77593: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77594: LD_VAR 0 6
77598: PPUSH
77599: CALL_OW 264
77603: PUSH
77604: LD_INT 26
77606: PUSH
77607: EMPTY
77608: LIST
77609: IN
77610: IFFALSE 77631
// points := [ 120 , 30 , 80 ] ;
77612: LD_ADDR_VAR 0 9
77616: PUSH
77617: LD_INT 120
77619: PUSH
77620: LD_INT 30
77622: PUSH
77623: LD_INT 80
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: LIST
77630: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77631: LD_VAR 0 6
77635: PPUSH
77636: CALL_OW 264
77640: PUSH
77641: LD_INT 22
77643: PUSH
77644: EMPTY
77645: LIST
77646: IN
77647: IFFALSE 77668
// points := [ 40 , 1 , 1 ] ;
77649: LD_ADDR_VAR 0 9
77653: PUSH
77654: LD_INT 40
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: LD_INT 1
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77668: LD_VAR 0 6
77672: PPUSH
77673: CALL_OW 264
77677: PUSH
77678: LD_INT 29
77680: PUSH
77681: EMPTY
77682: LIST
77683: IN
77684: IFFALSE 77705
// points := [ 70 , 200 , 400 ] ;
77686: LD_ADDR_VAR 0 9
77690: PUSH
77691: LD_INT 70
77693: PUSH
77694: LD_INT 200
77696: PUSH
77697: LD_INT 400
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: LIST
77704: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77705: LD_VAR 0 6
77709: PPUSH
77710: CALL_OW 264
77714: PUSH
77715: LD_INT 14
77717: PUSH
77718: LD_INT 53
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: IN
77725: IFFALSE 77746
// points := [ 40 , 10 , 20 ] ;
77727: LD_ADDR_VAR 0 9
77731: PUSH
77732: LD_INT 40
77734: PUSH
77735: LD_INT 10
77737: PUSH
77738: LD_INT 20
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: LIST
77745: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77746: LD_VAR 0 6
77750: PPUSH
77751: CALL_OW 264
77755: PUSH
77756: LD_INT 9
77758: PUSH
77759: EMPTY
77760: LIST
77761: IN
77762: IFFALSE 77783
// points := [ 5 , 70 , 20 ] ;
77764: LD_ADDR_VAR 0 9
77768: PUSH
77769: LD_INT 5
77771: PUSH
77772: LD_INT 70
77774: PUSH
77775: LD_INT 20
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: LIST
77782: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77783: LD_VAR 0 6
77787: PPUSH
77788: CALL_OW 264
77792: PUSH
77793: LD_INT 10
77795: PUSH
77796: EMPTY
77797: LIST
77798: IN
77799: IFFALSE 77820
// points := [ 35 , 110 , 70 ] ;
77801: LD_ADDR_VAR 0 9
77805: PUSH
77806: LD_INT 35
77808: PUSH
77809: LD_INT 110
77811: PUSH
77812: LD_INT 70
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: LIST
77819: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77820: LD_VAR 0 6
77824: PPUSH
77825: CALL_OW 265
77829: PUSH
77830: LD_INT 25
77832: EQUAL
77833: IFFALSE 77854
// points := [ 80 , 65 , 100 ] ;
77835: LD_ADDR_VAR 0 9
77839: PUSH
77840: LD_INT 80
77842: PUSH
77843: LD_INT 65
77845: PUSH
77846: LD_INT 100
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: LIST
77853: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77854: LD_VAR 0 6
77858: PPUSH
77859: CALL_OW 263
77863: PUSH
77864: LD_INT 1
77866: EQUAL
77867: IFFALSE 77902
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77869: LD_ADDR_VAR 0 10
77873: PUSH
77874: LD_VAR 0 10
77878: PUSH
77879: LD_VAR 0 6
77883: PPUSH
77884: CALL_OW 311
77888: PPUSH
77889: LD_INT 3
77891: PPUSH
77892: CALL_OW 259
77896: PUSH
77897: LD_INT 4
77899: MUL
77900: MUL
77901: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77902: LD_VAR 0 6
77906: PPUSH
77907: CALL_OW 263
77911: PUSH
77912: LD_INT 2
77914: EQUAL
77915: IFFALSE 77966
// begin j := IsControledBy ( i ) ;
77917: LD_ADDR_VAR 0 7
77921: PUSH
77922: LD_VAR 0 6
77926: PPUSH
77927: CALL_OW 312
77931: ST_TO_ADDR
// if j then
77932: LD_VAR 0 7
77936: IFFALSE 77966
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77938: LD_ADDR_VAR 0 10
77942: PUSH
77943: LD_VAR 0 10
77947: PUSH
77948: LD_VAR 0 7
77952: PPUSH
77953: LD_INT 3
77955: PPUSH
77956: CALL_OW 259
77960: PUSH
77961: LD_INT 3
77963: MUL
77964: MUL
77965: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77966: LD_VAR 0 6
77970: PPUSH
77971: CALL_OW 264
77975: PUSH
77976: LD_INT 5
77978: PUSH
77979: LD_INT 6
77981: PUSH
77982: LD_INT 46
77984: PUSH
77985: LD_INT 44
77987: PUSH
77988: LD_INT 47
77990: PUSH
77991: LD_INT 45
77993: PUSH
77994: LD_INT 28
77996: PUSH
77997: LD_INT 7
77999: PUSH
78000: LD_INT 27
78002: PUSH
78003: LD_INT 29
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: IN
78018: PUSH
78019: LD_VAR 0 1
78023: PPUSH
78024: LD_INT 52
78026: PPUSH
78027: CALL_OW 321
78031: PUSH
78032: LD_INT 2
78034: EQUAL
78035: AND
78036: IFFALSE 78053
// bpoints := bpoints * 1.2 ;
78038: LD_ADDR_VAR 0 10
78042: PUSH
78043: LD_VAR 0 10
78047: PUSH
78048: LD_REAL  1.20000000000000E+0000
78051: MUL
78052: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78053: LD_VAR 0 6
78057: PPUSH
78058: CALL_OW 264
78062: PUSH
78063: LD_INT 6
78065: PUSH
78066: LD_INT 46
78068: PUSH
78069: LD_INT 47
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: LIST
78076: IN
78077: IFFALSE 78094
// bpoints := bpoints * 1.2 ;
78079: LD_ADDR_VAR 0 10
78083: PUSH
78084: LD_VAR 0 10
78088: PUSH
78089: LD_REAL  1.20000000000000E+0000
78092: MUL
78093: ST_TO_ADDR
// end ; unit_building :
78094: GO 78108
78096: LD_INT 3
78098: DOUBLE
78099: EQUAL
78100: IFTRUE 78104
78102: GO 78107
78104: POP
// ; end ;
78105: GO 78108
78107: POP
// for j = 1 to 3 do
78108: LD_ADDR_VAR 0 7
78112: PUSH
78113: DOUBLE
78114: LD_INT 1
78116: DEC
78117: ST_TO_ADDR
78118: LD_INT 3
78120: PUSH
78121: FOR_TO
78122: IFFALSE 78175
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78124: LD_ADDR_VAR 0 5
78128: PUSH
78129: LD_VAR 0 5
78133: PPUSH
78134: LD_VAR 0 7
78138: PPUSH
78139: LD_VAR 0 5
78143: PUSH
78144: LD_VAR 0 7
78148: ARRAY
78149: PUSH
78150: LD_VAR 0 9
78154: PUSH
78155: LD_VAR 0 7
78159: ARRAY
78160: PUSH
78161: LD_VAR 0 10
78165: MUL
78166: PLUS
78167: PPUSH
78168: CALL_OW 1
78172: ST_TO_ADDR
78173: GO 78121
78175: POP
78176: POP
// end ;
78177: GO 76656
78179: POP
78180: POP
// result := Replace ( result , 4 , tmp ) ;
78181: LD_ADDR_VAR 0 5
78185: PUSH
78186: LD_VAR 0 5
78190: PPUSH
78191: LD_INT 4
78193: PPUSH
78194: LD_VAR 0 8
78198: PPUSH
78199: CALL_OW 1
78203: ST_TO_ADDR
// end ;
78204: LD_VAR 0 5
78208: RET
// export function DangerAtRange ( unit , range ) ; begin
78209: LD_INT 0
78211: PPUSH
// if not unit then
78212: LD_VAR 0 1
78216: NOT
78217: IFFALSE 78221
// exit ;
78219: GO 78266
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
78221: LD_ADDR_VAR 0 3
78225: PUSH
78226: LD_VAR 0 1
78230: PPUSH
78231: CALL_OW 255
78235: PPUSH
78236: LD_VAR 0 1
78240: PPUSH
78241: CALL_OW 250
78245: PPUSH
78246: LD_VAR 0 1
78250: PPUSH
78251: CALL_OW 251
78255: PPUSH
78256: LD_VAR 0 2
78260: PPUSH
78261: CALL 76508 0 4
78265: ST_TO_ADDR
// end ;
78266: LD_VAR 0 3
78270: RET
// export function DangerInArea ( side , area ) ; begin
78271: LD_INT 0
78273: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
78274: LD_ADDR_VAR 0 3
78278: PUSH
78279: LD_VAR 0 2
78283: PPUSH
78284: LD_INT 81
78286: PUSH
78287: LD_VAR 0 1
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PPUSH
78296: CALL_OW 70
78300: ST_TO_ADDR
// end ;
78301: LD_VAR 0 3
78305: RET
// export function IsExtension ( b ) ; begin
78306: LD_INT 0
78308: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
78309: LD_ADDR_VAR 0 2
78313: PUSH
78314: LD_VAR 0 1
78318: PUSH
78319: LD_INT 23
78321: PUSH
78322: LD_INT 20
78324: PUSH
78325: LD_INT 22
78327: PUSH
78328: LD_INT 17
78330: PUSH
78331: LD_INT 24
78333: PUSH
78334: LD_INT 21
78336: PUSH
78337: LD_INT 19
78339: PUSH
78340: LD_INT 16
78342: PUSH
78343: LD_INT 25
78345: PUSH
78346: LD_INT 18
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: IN
78361: ST_TO_ADDR
// end ;
78362: LD_VAR 0 2
78366: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
78367: LD_INT 0
78369: PPUSH
78370: PPUSH
78371: PPUSH
// result := [ ] ;
78372: LD_ADDR_VAR 0 4
78376: PUSH
78377: EMPTY
78378: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
78379: LD_ADDR_VAR 0 5
78383: PUSH
78384: LD_VAR 0 2
78388: PPUSH
78389: LD_INT 21
78391: PUSH
78392: LD_INT 3
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PPUSH
78399: CALL_OW 70
78403: ST_TO_ADDR
// if not tmp then
78404: LD_VAR 0 5
78408: NOT
78409: IFFALSE 78413
// exit ;
78411: GO 78477
// if checkLink then
78413: LD_VAR 0 3
78417: IFFALSE 78467
// begin for i in tmp do
78419: LD_ADDR_VAR 0 6
78423: PUSH
78424: LD_VAR 0 5
78428: PUSH
78429: FOR_IN
78430: IFFALSE 78465
// if GetBase ( i ) <> base then
78432: LD_VAR 0 6
78436: PPUSH
78437: CALL_OW 274
78441: PUSH
78442: LD_VAR 0 1
78446: NONEQUAL
78447: IFFALSE 78463
// ComLinkToBase ( base , i ) ;
78449: LD_VAR 0 1
78453: PPUSH
78454: LD_VAR 0 6
78458: PPUSH
78459: CALL_OW 169
78463: GO 78429
78465: POP
78466: POP
// end ; result := tmp ;
78467: LD_ADDR_VAR 0 4
78471: PUSH
78472: LD_VAR 0 5
78476: ST_TO_ADDR
// end ;
78477: LD_VAR 0 4
78481: RET
// export function ComComplete ( units , b ) ; var i ; begin
78482: LD_INT 0
78484: PPUSH
78485: PPUSH
// if not units then
78486: LD_VAR 0 1
78490: NOT
78491: IFFALSE 78495
// exit ;
78493: GO 78585
// for i in units do
78495: LD_ADDR_VAR 0 4
78499: PUSH
78500: LD_VAR 0 1
78504: PUSH
78505: FOR_IN
78506: IFFALSE 78583
// if BuildingStatus ( b ) = bs_build then
78508: LD_VAR 0 2
78512: PPUSH
78513: CALL_OW 461
78517: PUSH
78518: LD_INT 1
78520: EQUAL
78521: IFFALSE 78581
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
78523: LD_VAR 0 4
78527: PPUSH
78528: LD_STRING h
78530: PUSH
78531: LD_VAR 0 2
78535: PPUSH
78536: CALL_OW 250
78540: PUSH
78541: LD_VAR 0 2
78545: PPUSH
78546: CALL_OW 251
78550: PUSH
78551: LD_VAR 0 2
78555: PUSH
78556: LD_INT 0
78558: PUSH
78559: LD_INT 0
78561: PUSH
78562: LD_INT 0
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: PUSH
78574: EMPTY
78575: LIST
78576: PPUSH
78577: CALL_OW 446
78581: GO 78505
78583: POP
78584: POP
// end ;
78585: LD_VAR 0 3
78589: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78590: LD_INT 0
78592: PPUSH
78593: PPUSH
78594: PPUSH
78595: PPUSH
78596: PPUSH
78597: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78598: LD_VAR 0 1
78602: NOT
78603: PUSH
78604: LD_VAR 0 1
78608: PPUSH
78609: CALL_OW 263
78613: PUSH
78614: LD_INT 2
78616: NONEQUAL
78617: OR
78618: IFFALSE 78622
// exit ;
78620: GO 78938
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78622: LD_ADDR_VAR 0 6
78626: PUSH
78627: LD_INT 22
78629: PUSH
78630: LD_VAR 0 1
78634: PPUSH
78635: CALL_OW 255
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 2
78646: PUSH
78647: LD_INT 30
78649: PUSH
78650: LD_INT 36
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 34
78659: PUSH
78660: LD_INT 31
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: LIST
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PPUSH
78676: CALL_OW 69
78680: ST_TO_ADDR
// if not tmp then
78681: LD_VAR 0 6
78685: NOT
78686: IFFALSE 78690
// exit ;
78688: GO 78938
// result := [ ] ;
78690: LD_ADDR_VAR 0 2
78694: PUSH
78695: EMPTY
78696: ST_TO_ADDR
// for i in tmp do
78697: LD_ADDR_VAR 0 3
78701: PUSH
78702: LD_VAR 0 6
78706: PUSH
78707: FOR_IN
78708: IFFALSE 78779
// begin t := UnitsInside ( i ) ;
78710: LD_ADDR_VAR 0 4
78714: PUSH
78715: LD_VAR 0 3
78719: PPUSH
78720: CALL_OW 313
78724: ST_TO_ADDR
// if t then
78725: LD_VAR 0 4
78729: IFFALSE 78777
// for j in t do
78731: LD_ADDR_VAR 0 7
78735: PUSH
78736: LD_VAR 0 4
78740: PUSH
78741: FOR_IN
78742: IFFALSE 78775
// result := Replace ( result , result + 1 , j ) ;
78744: LD_ADDR_VAR 0 2
78748: PUSH
78749: LD_VAR 0 2
78753: PPUSH
78754: LD_VAR 0 2
78758: PUSH
78759: LD_INT 1
78761: PLUS
78762: PPUSH
78763: LD_VAR 0 7
78767: PPUSH
78768: CALL_OW 1
78772: ST_TO_ADDR
78773: GO 78741
78775: POP
78776: POP
// end ;
78777: GO 78707
78779: POP
78780: POP
// if not result then
78781: LD_VAR 0 2
78785: NOT
78786: IFFALSE 78790
// exit ;
78788: GO 78938
// mech := result [ 1 ] ;
78790: LD_ADDR_VAR 0 5
78794: PUSH
78795: LD_VAR 0 2
78799: PUSH
78800: LD_INT 1
78802: ARRAY
78803: ST_TO_ADDR
// if result > 1 then
78804: LD_VAR 0 2
78808: PUSH
78809: LD_INT 1
78811: GREATER
78812: IFFALSE 78924
// begin for i = 2 to result do
78814: LD_ADDR_VAR 0 3
78818: PUSH
78819: DOUBLE
78820: LD_INT 2
78822: DEC
78823: ST_TO_ADDR
78824: LD_VAR 0 2
78828: PUSH
78829: FOR_TO
78830: IFFALSE 78922
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78832: LD_ADDR_VAR 0 4
78836: PUSH
78837: LD_VAR 0 2
78841: PUSH
78842: LD_VAR 0 3
78846: ARRAY
78847: PPUSH
78848: LD_INT 3
78850: PPUSH
78851: CALL_OW 259
78855: PUSH
78856: LD_VAR 0 2
78860: PUSH
78861: LD_VAR 0 3
78865: ARRAY
78866: PPUSH
78867: CALL_OW 432
78871: MINUS
78872: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78873: LD_VAR 0 4
78877: PUSH
78878: LD_VAR 0 5
78882: PPUSH
78883: LD_INT 3
78885: PPUSH
78886: CALL_OW 259
78890: PUSH
78891: LD_VAR 0 5
78895: PPUSH
78896: CALL_OW 432
78900: MINUS
78901: GREATEREQUAL
78902: IFFALSE 78920
// mech := result [ i ] ;
78904: LD_ADDR_VAR 0 5
78908: PUSH
78909: LD_VAR 0 2
78913: PUSH
78914: LD_VAR 0 3
78918: ARRAY
78919: ST_TO_ADDR
// end ;
78920: GO 78829
78922: POP
78923: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78924: LD_VAR 0 1
78928: PPUSH
78929: LD_VAR 0 5
78933: PPUSH
78934: CALL_OW 135
// end ;
78938: LD_VAR 0 2
78942: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78943: LD_INT 0
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
78950: PPUSH
78951: PPUSH
78952: PPUSH
78953: PPUSH
78954: PPUSH
78955: PPUSH
78956: PPUSH
78957: PPUSH
// result := [ ] ;
78958: LD_ADDR_VAR 0 7
78962: PUSH
78963: EMPTY
78964: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78965: LD_VAR 0 1
78969: PPUSH
78970: CALL_OW 266
78974: PUSH
78975: LD_INT 0
78977: PUSH
78978: LD_INT 1
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: IN
78985: NOT
78986: IFFALSE 78990
// exit ;
78988: GO 80624
// if name then
78990: LD_VAR 0 3
78994: IFFALSE 79010
// SetBName ( base_dep , name ) ;
78996: LD_VAR 0 1
79000: PPUSH
79001: LD_VAR 0 3
79005: PPUSH
79006: CALL_OW 500
// base := GetBase ( base_dep ) ;
79010: LD_ADDR_VAR 0 15
79014: PUSH
79015: LD_VAR 0 1
79019: PPUSH
79020: CALL_OW 274
79024: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79025: LD_ADDR_VAR 0 16
79029: PUSH
79030: LD_VAR 0 1
79034: PPUSH
79035: CALL_OW 255
79039: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79040: LD_ADDR_VAR 0 17
79044: PUSH
79045: LD_VAR 0 1
79049: PPUSH
79050: CALL_OW 248
79054: ST_TO_ADDR
// if sources then
79055: LD_VAR 0 5
79059: IFFALSE 79106
// for i = 1 to 3 do
79061: LD_ADDR_VAR 0 8
79065: PUSH
79066: DOUBLE
79067: LD_INT 1
79069: DEC
79070: ST_TO_ADDR
79071: LD_INT 3
79073: PUSH
79074: FOR_TO
79075: IFFALSE 79104
// AddResourceType ( base , i , sources [ i ] ) ;
79077: LD_VAR 0 15
79081: PPUSH
79082: LD_VAR 0 8
79086: PPUSH
79087: LD_VAR 0 5
79091: PUSH
79092: LD_VAR 0 8
79096: ARRAY
79097: PPUSH
79098: CALL_OW 276
79102: GO 79074
79104: POP
79105: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79106: LD_ADDR_VAR 0 18
79110: PUSH
79111: LD_VAR 0 15
79115: PPUSH
79116: LD_VAR 0 2
79120: PPUSH
79121: LD_INT 1
79123: PPUSH
79124: CALL 78367 0 3
79128: ST_TO_ADDR
// InitHc ;
79129: CALL_OW 19
// InitUc ;
79133: CALL_OW 18
// uc_side := side ;
79137: LD_ADDR_OWVAR 20
79141: PUSH
79142: LD_VAR 0 16
79146: ST_TO_ADDR
// uc_nation := nation ;
79147: LD_ADDR_OWVAR 21
79151: PUSH
79152: LD_VAR 0 17
79156: ST_TO_ADDR
// if buildings then
79157: LD_VAR 0 18
79161: IFFALSE 80483
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79163: LD_ADDR_VAR 0 19
79167: PUSH
79168: LD_VAR 0 18
79172: PPUSH
79173: LD_INT 2
79175: PUSH
79176: LD_INT 30
79178: PUSH
79179: LD_INT 29
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 30
79188: PUSH
79189: LD_INT 30
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: LIST
79200: PPUSH
79201: CALL_OW 72
79205: ST_TO_ADDR
// if tmp then
79206: LD_VAR 0 19
79210: IFFALSE 79258
// for i in tmp do
79212: LD_ADDR_VAR 0 8
79216: PUSH
79217: LD_VAR 0 19
79221: PUSH
79222: FOR_IN
79223: IFFALSE 79256
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
79225: LD_VAR 0 8
79229: PPUSH
79230: CALL_OW 250
79234: PPUSH
79235: LD_VAR 0 8
79239: PPUSH
79240: CALL_OW 251
79244: PPUSH
79245: LD_VAR 0 16
79249: PPUSH
79250: CALL_OW 441
79254: GO 79222
79256: POP
79257: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
79258: LD_VAR 0 18
79262: PPUSH
79263: LD_INT 2
79265: PUSH
79266: LD_INT 30
79268: PUSH
79269: LD_INT 32
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 30
79278: PUSH
79279: LD_INT 33
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: LIST
79290: PPUSH
79291: CALL_OW 72
79295: IFFALSE 79383
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
79297: LD_ADDR_VAR 0 8
79301: PUSH
79302: LD_VAR 0 18
79306: PPUSH
79307: LD_INT 2
79309: PUSH
79310: LD_INT 30
79312: PUSH
79313: LD_INT 32
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 30
79322: PUSH
79323: LD_INT 33
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: LIST
79334: PPUSH
79335: CALL_OW 72
79339: PUSH
79340: FOR_IN
79341: IFFALSE 79381
// begin if not GetBWeapon ( i ) then
79343: LD_VAR 0 8
79347: PPUSH
79348: CALL_OW 269
79352: NOT
79353: IFFALSE 79379
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
79355: LD_VAR 0 8
79359: PPUSH
79360: LD_VAR 0 8
79364: PPUSH
79365: LD_VAR 0 2
79369: PPUSH
79370: CALL 80629 0 2
79374: PPUSH
79375: CALL_OW 431
// end ;
79379: GO 79340
79381: POP
79382: POP
// end ; for i = 1 to personel do
79383: LD_ADDR_VAR 0 8
79387: PUSH
79388: DOUBLE
79389: LD_INT 1
79391: DEC
79392: ST_TO_ADDR
79393: LD_VAR 0 6
79397: PUSH
79398: FOR_TO
79399: IFFALSE 80463
// begin if i > 4 then
79401: LD_VAR 0 8
79405: PUSH
79406: LD_INT 4
79408: GREATER
79409: IFFALSE 79413
// break ;
79411: GO 80463
// case i of 1 :
79413: LD_VAR 0 8
79417: PUSH
79418: LD_INT 1
79420: DOUBLE
79421: EQUAL
79422: IFTRUE 79426
79424: GO 79506
79426: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
79427: LD_ADDR_VAR 0 12
79431: PUSH
79432: LD_VAR 0 18
79436: PPUSH
79437: LD_INT 22
79439: PUSH
79440: LD_VAR 0 16
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 58
79451: PUSH
79452: EMPTY
79453: LIST
79454: PUSH
79455: LD_INT 2
79457: PUSH
79458: LD_INT 30
79460: PUSH
79461: LD_INT 32
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 30
79470: PUSH
79471: LD_INT 4
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 30
79480: PUSH
79481: LD_INT 5
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: LIST
79498: PPUSH
79499: CALL_OW 72
79503: ST_TO_ADDR
79504: GO 79728
79506: LD_INT 2
79508: DOUBLE
79509: EQUAL
79510: IFTRUE 79514
79512: GO 79576
79514: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
79515: LD_ADDR_VAR 0 12
79519: PUSH
79520: LD_VAR 0 18
79524: PPUSH
79525: LD_INT 22
79527: PUSH
79528: LD_VAR 0 16
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 2
79539: PUSH
79540: LD_INT 30
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 30
79552: PUSH
79553: LD_INT 1
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: LIST
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PPUSH
79569: CALL_OW 72
79573: ST_TO_ADDR
79574: GO 79728
79576: LD_INT 3
79578: DOUBLE
79579: EQUAL
79580: IFTRUE 79584
79582: GO 79646
79584: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79585: LD_ADDR_VAR 0 12
79589: PUSH
79590: LD_VAR 0 18
79594: PPUSH
79595: LD_INT 22
79597: PUSH
79598: LD_VAR 0 16
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 2
79609: PUSH
79610: LD_INT 30
79612: PUSH
79613: LD_INT 2
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 30
79622: PUSH
79623: LD_INT 3
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: LIST
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PPUSH
79639: CALL_OW 72
79643: ST_TO_ADDR
79644: GO 79728
79646: LD_INT 4
79648: DOUBLE
79649: EQUAL
79650: IFTRUE 79654
79652: GO 79727
79654: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79655: LD_ADDR_VAR 0 12
79659: PUSH
79660: LD_VAR 0 18
79664: PPUSH
79665: LD_INT 22
79667: PUSH
79668: LD_VAR 0 16
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 2
79679: PUSH
79680: LD_INT 30
79682: PUSH
79683: LD_INT 6
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 30
79692: PUSH
79693: LD_INT 7
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: LD_INT 30
79702: PUSH
79703: LD_INT 8
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PPUSH
79720: CALL_OW 72
79724: ST_TO_ADDR
79725: GO 79728
79727: POP
// if i = 1 then
79728: LD_VAR 0 8
79732: PUSH
79733: LD_INT 1
79735: EQUAL
79736: IFFALSE 79847
// begin tmp := [ ] ;
79738: LD_ADDR_VAR 0 19
79742: PUSH
79743: EMPTY
79744: ST_TO_ADDR
// for j in f do
79745: LD_ADDR_VAR 0 9
79749: PUSH
79750: LD_VAR 0 12
79754: PUSH
79755: FOR_IN
79756: IFFALSE 79829
// if GetBType ( j ) = b_bunker then
79758: LD_VAR 0 9
79762: PPUSH
79763: CALL_OW 266
79767: PUSH
79768: LD_INT 32
79770: EQUAL
79771: IFFALSE 79798
// tmp := Insert ( tmp , 1 , j ) else
79773: LD_ADDR_VAR 0 19
79777: PUSH
79778: LD_VAR 0 19
79782: PPUSH
79783: LD_INT 1
79785: PPUSH
79786: LD_VAR 0 9
79790: PPUSH
79791: CALL_OW 2
79795: ST_TO_ADDR
79796: GO 79827
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79798: LD_ADDR_VAR 0 19
79802: PUSH
79803: LD_VAR 0 19
79807: PPUSH
79808: LD_VAR 0 19
79812: PUSH
79813: LD_INT 1
79815: PLUS
79816: PPUSH
79817: LD_VAR 0 9
79821: PPUSH
79822: CALL_OW 2
79826: ST_TO_ADDR
79827: GO 79755
79829: POP
79830: POP
// if tmp then
79831: LD_VAR 0 19
79835: IFFALSE 79847
// f := tmp ;
79837: LD_ADDR_VAR 0 12
79841: PUSH
79842: LD_VAR 0 19
79846: ST_TO_ADDR
// end ; x := personel [ i ] ;
79847: LD_ADDR_VAR 0 13
79851: PUSH
79852: LD_VAR 0 6
79856: PUSH
79857: LD_VAR 0 8
79861: ARRAY
79862: ST_TO_ADDR
// if x = - 1 then
79863: LD_VAR 0 13
79867: PUSH
79868: LD_INT 1
79870: NEG
79871: EQUAL
79872: IFFALSE 80081
// begin for j in f do
79874: LD_ADDR_VAR 0 9
79878: PUSH
79879: LD_VAR 0 12
79883: PUSH
79884: FOR_IN
79885: IFFALSE 80077
// repeat InitHc ;
79887: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79891: LD_VAR 0 9
79895: PPUSH
79896: CALL_OW 266
79900: PUSH
79901: LD_INT 5
79903: EQUAL
79904: IFFALSE 79974
// begin if UnitsInside ( j ) < 3 then
79906: LD_VAR 0 9
79910: PPUSH
79911: CALL_OW 313
79915: PUSH
79916: LD_INT 3
79918: LESS
79919: IFFALSE 79955
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79921: LD_INT 0
79923: PPUSH
79924: LD_INT 5
79926: PUSH
79927: LD_INT 8
79929: PUSH
79930: LD_INT 9
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: LIST
79937: PUSH
79938: LD_VAR 0 17
79942: ARRAY
79943: PPUSH
79944: LD_VAR 0 4
79948: PPUSH
79949: CALL_OW 380
79953: GO 79972
// PrepareHuman ( false , i , skill ) ;
79955: LD_INT 0
79957: PPUSH
79958: LD_VAR 0 8
79962: PPUSH
79963: LD_VAR 0 4
79967: PPUSH
79968: CALL_OW 380
// end else
79972: GO 79991
// PrepareHuman ( false , i , skill ) ;
79974: LD_INT 0
79976: PPUSH
79977: LD_VAR 0 8
79981: PPUSH
79982: LD_VAR 0 4
79986: PPUSH
79987: CALL_OW 380
// un := CreateHuman ;
79991: LD_ADDR_VAR 0 14
79995: PUSH
79996: CALL_OW 44
80000: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80001: LD_ADDR_VAR 0 7
80005: PUSH
80006: LD_VAR 0 7
80010: PPUSH
80011: LD_INT 1
80013: PPUSH
80014: LD_VAR 0 14
80018: PPUSH
80019: CALL_OW 2
80023: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80024: LD_VAR 0 14
80028: PPUSH
80029: LD_VAR 0 9
80033: PPUSH
80034: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80038: LD_VAR 0 9
80042: PPUSH
80043: CALL_OW 313
80047: PUSH
80048: LD_INT 6
80050: EQUAL
80051: PUSH
80052: LD_VAR 0 9
80056: PPUSH
80057: CALL_OW 266
80061: PUSH
80062: LD_INT 32
80064: PUSH
80065: LD_INT 31
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: IN
80072: OR
80073: IFFALSE 79887
80075: GO 79884
80077: POP
80078: POP
// end else
80079: GO 80461
// for j = 1 to x do
80081: LD_ADDR_VAR 0 9
80085: PUSH
80086: DOUBLE
80087: LD_INT 1
80089: DEC
80090: ST_TO_ADDR
80091: LD_VAR 0 13
80095: PUSH
80096: FOR_TO
80097: IFFALSE 80459
// begin InitHc ;
80099: CALL_OW 19
// if not f then
80103: LD_VAR 0 12
80107: NOT
80108: IFFALSE 80197
// begin PrepareHuman ( false , i , skill ) ;
80110: LD_INT 0
80112: PPUSH
80113: LD_VAR 0 8
80117: PPUSH
80118: LD_VAR 0 4
80122: PPUSH
80123: CALL_OW 380
// un := CreateHuman ;
80127: LD_ADDR_VAR 0 14
80131: PUSH
80132: CALL_OW 44
80136: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80137: LD_ADDR_VAR 0 7
80141: PUSH
80142: LD_VAR 0 7
80146: PPUSH
80147: LD_INT 1
80149: PPUSH
80150: LD_VAR 0 14
80154: PPUSH
80155: CALL_OW 2
80159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80160: LD_VAR 0 14
80164: PPUSH
80165: LD_VAR 0 1
80169: PPUSH
80170: CALL_OW 250
80174: PPUSH
80175: LD_VAR 0 1
80179: PPUSH
80180: CALL_OW 251
80184: PPUSH
80185: LD_INT 10
80187: PPUSH
80188: LD_INT 0
80190: PPUSH
80191: CALL_OW 50
// continue ;
80195: GO 80096
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80197: LD_VAR 0 12
80201: PUSH
80202: LD_INT 1
80204: ARRAY
80205: PPUSH
80206: CALL_OW 313
80210: PUSH
80211: LD_VAR 0 12
80215: PUSH
80216: LD_INT 1
80218: ARRAY
80219: PPUSH
80220: CALL_OW 266
80224: PUSH
80225: LD_INT 32
80227: PUSH
80228: LD_INT 31
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: IN
80235: AND
80236: PUSH
80237: LD_VAR 0 12
80241: PUSH
80242: LD_INT 1
80244: ARRAY
80245: PPUSH
80246: CALL_OW 313
80250: PUSH
80251: LD_INT 6
80253: EQUAL
80254: OR
80255: IFFALSE 80275
// f := Delete ( f , 1 ) ;
80257: LD_ADDR_VAR 0 12
80261: PUSH
80262: LD_VAR 0 12
80266: PPUSH
80267: LD_INT 1
80269: PPUSH
80270: CALL_OW 3
80274: ST_TO_ADDR
// if not f then
80275: LD_VAR 0 12
80279: NOT
80280: IFFALSE 80298
// begin x := x + 2 ;
80282: LD_ADDR_VAR 0 13
80286: PUSH
80287: LD_VAR 0 13
80291: PUSH
80292: LD_INT 2
80294: PLUS
80295: ST_TO_ADDR
// continue ;
80296: GO 80096
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
80298: LD_VAR 0 12
80302: PUSH
80303: LD_INT 1
80305: ARRAY
80306: PPUSH
80307: CALL_OW 266
80311: PUSH
80312: LD_INT 5
80314: EQUAL
80315: IFFALSE 80389
// begin if UnitsInside ( f [ 1 ] ) < 3 then
80317: LD_VAR 0 12
80321: PUSH
80322: LD_INT 1
80324: ARRAY
80325: PPUSH
80326: CALL_OW 313
80330: PUSH
80331: LD_INT 3
80333: LESS
80334: IFFALSE 80370
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80336: LD_INT 0
80338: PPUSH
80339: LD_INT 5
80341: PUSH
80342: LD_INT 8
80344: PUSH
80345: LD_INT 9
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: LIST
80352: PUSH
80353: LD_VAR 0 17
80357: ARRAY
80358: PPUSH
80359: LD_VAR 0 4
80363: PPUSH
80364: CALL_OW 380
80368: GO 80387
// PrepareHuman ( false , i , skill ) ;
80370: LD_INT 0
80372: PPUSH
80373: LD_VAR 0 8
80377: PPUSH
80378: LD_VAR 0 4
80382: PPUSH
80383: CALL_OW 380
// end else
80387: GO 80406
// PrepareHuman ( false , i , skill ) ;
80389: LD_INT 0
80391: PPUSH
80392: LD_VAR 0 8
80396: PPUSH
80397: LD_VAR 0 4
80401: PPUSH
80402: CALL_OW 380
// un := CreateHuman ;
80406: LD_ADDR_VAR 0 14
80410: PUSH
80411: CALL_OW 44
80415: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80416: LD_ADDR_VAR 0 7
80420: PUSH
80421: LD_VAR 0 7
80425: PPUSH
80426: LD_INT 1
80428: PPUSH
80429: LD_VAR 0 14
80433: PPUSH
80434: CALL_OW 2
80438: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
80439: LD_VAR 0 14
80443: PPUSH
80444: LD_VAR 0 12
80448: PUSH
80449: LD_INT 1
80451: ARRAY
80452: PPUSH
80453: CALL_OW 52
// end ;
80457: GO 80096
80459: POP
80460: POP
// end ;
80461: GO 79398
80463: POP
80464: POP
// result := result ^ buildings ;
80465: LD_ADDR_VAR 0 7
80469: PUSH
80470: LD_VAR 0 7
80474: PUSH
80475: LD_VAR 0 18
80479: ADD
80480: ST_TO_ADDR
// end else
80481: GO 80624
// begin for i = 1 to personel do
80483: LD_ADDR_VAR 0 8
80487: PUSH
80488: DOUBLE
80489: LD_INT 1
80491: DEC
80492: ST_TO_ADDR
80493: LD_VAR 0 6
80497: PUSH
80498: FOR_TO
80499: IFFALSE 80622
// begin if i > 4 then
80501: LD_VAR 0 8
80505: PUSH
80506: LD_INT 4
80508: GREATER
80509: IFFALSE 80513
// break ;
80511: GO 80622
// x := personel [ i ] ;
80513: LD_ADDR_VAR 0 13
80517: PUSH
80518: LD_VAR 0 6
80522: PUSH
80523: LD_VAR 0 8
80527: ARRAY
80528: ST_TO_ADDR
// if x = - 1 then
80529: LD_VAR 0 13
80533: PUSH
80534: LD_INT 1
80536: NEG
80537: EQUAL
80538: IFFALSE 80542
// continue ;
80540: GO 80498
// PrepareHuman ( false , i , skill ) ;
80542: LD_INT 0
80544: PPUSH
80545: LD_VAR 0 8
80549: PPUSH
80550: LD_VAR 0 4
80554: PPUSH
80555: CALL_OW 380
// un := CreateHuman ;
80559: LD_ADDR_VAR 0 14
80563: PUSH
80564: CALL_OW 44
80568: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80569: LD_VAR 0 14
80573: PPUSH
80574: LD_VAR 0 1
80578: PPUSH
80579: CALL_OW 250
80583: PPUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL_OW 251
80593: PPUSH
80594: LD_INT 10
80596: PPUSH
80597: LD_INT 0
80599: PPUSH
80600: CALL_OW 50
// result := result ^ un ;
80604: LD_ADDR_VAR 0 7
80608: PUSH
80609: LD_VAR 0 7
80613: PUSH
80614: LD_VAR 0 14
80618: ADD
80619: ST_TO_ADDR
// end ;
80620: GO 80498
80622: POP
80623: POP
// end ; end ;
80624: LD_VAR 0 7
80628: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80629: LD_INT 0
80631: PPUSH
80632: PPUSH
80633: PPUSH
80634: PPUSH
80635: PPUSH
80636: PPUSH
80637: PPUSH
80638: PPUSH
80639: PPUSH
80640: PPUSH
80641: PPUSH
80642: PPUSH
80643: PPUSH
80644: PPUSH
80645: PPUSH
80646: PPUSH
// result := false ;
80647: LD_ADDR_VAR 0 3
80651: PUSH
80652: LD_INT 0
80654: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80655: LD_VAR 0 1
80659: NOT
80660: PUSH
80661: LD_VAR 0 1
80665: PPUSH
80666: CALL_OW 266
80670: PUSH
80671: LD_INT 32
80673: PUSH
80674: LD_INT 33
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: IN
80681: NOT
80682: OR
80683: IFFALSE 80687
// exit ;
80685: GO 81796
// nat := GetNation ( tower ) ;
80687: LD_ADDR_VAR 0 12
80691: PUSH
80692: LD_VAR 0 1
80696: PPUSH
80697: CALL_OW 248
80701: ST_TO_ADDR
// side := GetSide ( tower ) ;
80702: LD_ADDR_VAR 0 16
80706: PUSH
80707: LD_VAR 0 1
80711: PPUSH
80712: CALL_OW 255
80716: ST_TO_ADDR
// x := GetX ( tower ) ;
80717: LD_ADDR_VAR 0 10
80721: PUSH
80722: LD_VAR 0 1
80726: PPUSH
80727: CALL_OW 250
80731: ST_TO_ADDR
// y := GetY ( tower ) ;
80732: LD_ADDR_VAR 0 11
80736: PUSH
80737: LD_VAR 0 1
80741: PPUSH
80742: CALL_OW 251
80746: ST_TO_ADDR
// if not x or not y then
80747: LD_VAR 0 10
80751: NOT
80752: PUSH
80753: LD_VAR 0 11
80757: NOT
80758: OR
80759: IFFALSE 80763
// exit ;
80761: GO 81796
// weapon := 0 ;
80763: LD_ADDR_VAR 0 18
80767: PUSH
80768: LD_INT 0
80770: ST_TO_ADDR
// fac_list := [ ] ;
80771: LD_ADDR_VAR 0 17
80775: PUSH
80776: EMPTY
80777: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80778: LD_ADDR_VAR 0 6
80782: PUSH
80783: LD_VAR 0 1
80787: PPUSH
80788: CALL_OW 274
80792: PPUSH
80793: LD_VAR 0 2
80797: PPUSH
80798: LD_INT 0
80800: PPUSH
80801: CALL 78367 0 3
80805: PPUSH
80806: LD_INT 30
80808: PUSH
80809: LD_INT 3
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PPUSH
80816: CALL_OW 72
80820: ST_TO_ADDR
// if not factories then
80821: LD_VAR 0 6
80825: NOT
80826: IFFALSE 80830
// exit ;
80828: GO 81796
// for i in factories do
80830: LD_ADDR_VAR 0 8
80834: PUSH
80835: LD_VAR 0 6
80839: PUSH
80840: FOR_IN
80841: IFFALSE 80866
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80843: LD_ADDR_VAR 0 17
80847: PUSH
80848: LD_VAR 0 17
80852: PUSH
80853: LD_VAR 0 8
80857: PPUSH
80858: CALL_OW 478
80862: UNION
80863: ST_TO_ADDR
80864: GO 80840
80866: POP
80867: POP
// if not fac_list then
80868: LD_VAR 0 17
80872: NOT
80873: IFFALSE 80877
// exit ;
80875: GO 81796
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80877: LD_ADDR_VAR 0 5
80881: PUSH
80882: LD_INT 4
80884: PUSH
80885: LD_INT 5
80887: PUSH
80888: LD_INT 9
80890: PUSH
80891: LD_INT 10
80893: PUSH
80894: LD_INT 6
80896: PUSH
80897: LD_INT 7
80899: PUSH
80900: LD_INT 11
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: PUSH
80912: LD_INT 27
80914: PUSH
80915: LD_INT 28
80917: PUSH
80918: LD_INT 26
80920: PUSH
80921: LD_INT 30
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 43
80932: PUSH
80933: LD_INT 44
80935: PUSH
80936: LD_INT 46
80938: PUSH
80939: LD_INT 45
80941: PUSH
80942: LD_INT 47
80944: PUSH
80945: LD_INT 49
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: LIST
80960: PUSH
80961: LD_VAR 0 12
80965: ARRAY
80966: ST_TO_ADDR
// list := list isect fac_list ;
80967: LD_ADDR_VAR 0 5
80971: PUSH
80972: LD_VAR 0 5
80976: PUSH
80977: LD_VAR 0 17
80981: ISECT
80982: ST_TO_ADDR
// if not list then
80983: LD_VAR 0 5
80987: NOT
80988: IFFALSE 80992
// exit ;
80990: GO 81796
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80992: LD_VAR 0 12
80996: PUSH
80997: LD_INT 3
80999: EQUAL
81000: PUSH
81001: LD_INT 49
81003: PUSH
81004: LD_VAR 0 5
81008: IN
81009: AND
81010: PUSH
81011: LD_INT 31
81013: PPUSH
81014: LD_VAR 0 16
81018: PPUSH
81019: CALL_OW 321
81023: PUSH
81024: LD_INT 2
81026: EQUAL
81027: AND
81028: IFFALSE 81088
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81030: LD_INT 22
81032: PUSH
81033: LD_VAR 0 16
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 35
81044: PUSH
81045: LD_INT 49
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 91
81054: PUSH
81055: LD_VAR 0 1
81059: PUSH
81060: LD_INT 10
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: LIST
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: LIST
81072: PPUSH
81073: CALL_OW 69
81077: NOT
81078: IFFALSE 81088
// weapon := ru_time_lapser ;
81080: LD_ADDR_VAR 0 18
81084: PUSH
81085: LD_INT 49
81087: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81088: LD_VAR 0 12
81092: PUSH
81093: LD_INT 1
81095: PUSH
81096: LD_INT 2
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: IN
81103: PUSH
81104: LD_INT 11
81106: PUSH
81107: LD_VAR 0 5
81111: IN
81112: PUSH
81113: LD_INT 30
81115: PUSH
81116: LD_VAR 0 5
81120: IN
81121: OR
81122: AND
81123: PUSH
81124: LD_INT 6
81126: PPUSH
81127: LD_VAR 0 16
81131: PPUSH
81132: CALL_OW 321
81136: PUSH
81137: LD_INT 2
81139: EQUAL
81140: AND
81141: IFFALSE 81306
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81143: LD_INT 22
81145: PUSH
81146: LD_VAR 0 16
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 2
81157: PUSH
81158: LD_INT 35
81160: PUSH
81161: LD_INT 11
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 35
81170: PUSH
81171: LD_INT 30
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 91
81185: PUSH
81186: LD_VAR 0 1
81190: PUSH
81191: LD_INT 18
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: LIST
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: LIST
81203: PPUSH
81204: CALL_OW 69
81208: NOT
81209: PUSH
81210: LD_INT 22
81212: PUSH
81213: LD_VAR 0 16
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 2
81224: PUSH
81225: LD_INT 30
81227: PUSH
81228: LD_INT 32
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 30
81237: PUSH
81238: LD_INT 33
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 91
81252: PUSH
81253: LD_VAR 0 1
81257: PUSH
81258: LD_INT 12
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: LIST
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: LIST
81270: PUSH
81271: EMPTY
81272: LIST
81273: PPUSH
81274: CALL_OW 69
81278: PUSH
81279: LD_INT 2
81281: GREATER
81282: AND
81283: IFFALSE 81306
// weapon := [ us_radar , ar_radar ] [ nat ] ;
81285: LD_ADDR_VAR 0 18
81289: PUSH
81290: LD_INT 11
81292: PUSH
81293: LD_INT 30
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_VAR 0 12
81304: ARRAY
81305: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
81306: LD_VAR 0 18
81310: NOT
81311: PUSH
81312: LD_INT 40
81314: PPUSH
81315: LD_VAR 0 16
81319: PPUSH
81320: CALL_OW 321
81324: PUSH
81325: LD_INT 2
81327: EQUAL
81328: AND
81329: PUSH
81330: LD_INT 7
81332: PUSH
81333: LD_VAR 0 5
81337: IN
81338: PUSH
81339: LD_INT 28
81341: PUSH
81342: LD_VAR 0 5
81346: IN
81347: OR
81348: PUSH
81349: LD_INT 45
81351: PUSH
81352: LD_VAR 0 5
81356: IN
81357: OR
81358: AND
81359: IFFALSE 81613
// begin hex := GetHexInfo ( x , y ) ;
81361: LD_ADDR_VAR 0 4
81365: PUSH
81366: LD_VAR 0 10
81370: PPUSH
81371: LD_VAR 0 11
81375: PPUSH
81376: CALL_OW 546
81380: ST_TO_ADDR
// if hex [ 1 ] then
81381: LD_VAR 0 4
81385: PUSH
81386: LD_INT 1
81388: ARRAY
81389: IFFALSE 81393
// exit ;
81391: GO 81796
// height := hex [ 2 ] ;
81393: LD_ADDR_VAR 0 15
81397: PUSH
81398: LD_VAR 0 4
81402: PUSH
81403: LD_INT 2
81405: ARRAY
81406: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
81407: LD_ADDR_VAR 0 14
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: LD_INT 3
81420: PUSH
81421: LD_INT 5
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: ST_TO_ADDR
// for i in tmp do
81430: LD_ADDR_VAR 0 8
81434: PUSH
81435: LD_VAR 0 14
81439: PUSH
81440: FOR_IN
81441: IFFALSE 81611
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
81443: LD_ADDR_VAR 0 9
81447: PUSH
81448: LD_VAR 0 10
81452: PPUSH
81453: LD_VAR 0 8
81457: PPUSH
81458: LD_INT 5
81460: PPUSH
81461: CALL_OW 272
81465: PUSH
81466: LD_VAR 0 11
81470: PPUSH
81471: LD_VAR 0 8
81475: PPUSH
81476: LD_INT 5
81478: PPUSH
81479: CALL_OW 273
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81488: LD_VAR 0 9
81492: PUSH
81493: LD_INT 1
81495: ARRAY
81496: PPUSH
81497: LD_VAR 0 9
81501: PUSH
81502: LD_INT 2
81504: ARRAY
81505: PPUSH
81506: CALL_OW 488
81510: IFFALSE 81609
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
81512: LD_ADDR_VAR 0 4
81516: PUSH
81517: LD_VAR 0 9
81521: PUSH
81522: LD_INT 1
81524: ARRAY
81525: PPUSH
81526: LD_VAR 0 9
81530: PUSH
81531: LD_INT 2
81533: ARRAY
81534: PPUSH
81535: CALL_OW 546
81539: ST_TO_ADDR
// if hex [ 1 ] then
81540: LD_VAR 0 4
81544: PUSH
81545: LD_INT 1
81547: ARRAY
81548: IFFALSE 81552
// continue ;
81550: GO 81440
// h := hex [ 2 ] ;
81552: LD_ADDR_VAR 0 13
81556: PUSH
81557: LD_VAR 0 4
81561: PUSH
81562: LD_INT 2
81564: ARRAY
81565: ST_TO_ADDR
// if h + 7 < height then
81566: LD_VAR 0 13
81570: PUSH
81571: LD_INT 7
81573: PLUS
81574: PUSH
81575: LD_VAR 0 15
81579: LESS
81580: IFFALSE 81609
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81582: LD_ADDR_VAR 0 18
81586: PUSH
81587: LD_INT 7
81589: PUSH
81590: LD_INT 28
81592: PUSH
81593: LD_INT 45
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: LIST
81600: PUSH
81601: LD_VAR 0 12
81605: ARRAY
81606: ST_TO_ADDR
// break ;
81607: GO 81611
// end ; end ; end ;
81609: GO 81440
81611: POP
81612: POP
// end ; if not weapon then
81613: LD_VAR 0 18
81617: NOT
81618: IFFALSE 81678
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81620: LD_ADDR_VAR 0 5
81624: PUSH
81625: LD_VAR 0 5
81629: PUSH
81630: LD_INT 11
81632: PUSH
81633: LD_INT 30
81635: PUSH
81636: LD_INT 49
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: LIST
81643: DIFF
81644: ST_TO_ADDR
// if not list then
81645: LD_VAR 0 5
81649: NOT
81650: IFFALSE 81654
// exit ;
81652: GO 81796
// weapon := list [ rand ( 1 , list ) ] ;
81654: LD_ADDR_VAR 0 18
81658: PUSH
81659: LD_VAR 0 5
81663: PUSH
81664: LD_INT 1
81666: PPUSH
81667: LD_VAR 0 5
81671: PPUSH
81672: CALL_OW 12
81676: ARRAY
81677: ST_TO_ADDR
// end ; if weapon then
81678: LD_VAR 0 18
81682: IFFALSE 81796
// begin tmp := CostOfWeapon ( weapon ) ;
81684: LD_ADDR_VAR 0 14
81688: PUSH
81689: LD_VAR 0 18
81693: PPUSH
81694: CALL_OW 451
81698: ST_TO_ADDR
// j := GetBase ( tower ) ;
81699: LD_ADDR_VAR 0 9
81703: PUSH
81704: LD_VAR 0 1
81708: PPUSH
81709: CALL_OW 274
81713: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81714: LD_VAR 0 9
81718: PPUSH
81719: LD_INT 1
81721: PPUSH
81722: CALL_OW 275
81726: PUSH
81727: LD_VAR 0 14
81731: PUSH
81732: LD_INT 1
81734: ARRAY
81735: GREATEREQUAL
81736: PUSH
81737: LD_VAR 0 9
81741: PPUSH
81742: LD_INT 2
81744: PPUSH
81745: CALL_OW 275
81749: PUSH
81750: LD_VAR 0 14
81754: PUSH
81755: LD_INT 2
81757: ARRAY
81758: GREATEREQUAL
81759: AND
81760: PUSH
81761: LD_VAR 0 9
81765: PPUSH
81766: LD_INT 3
81768: PPUSH
81769: CALL_OW 275
81773: PUSH
81774: LD_VAR 0 14
81778: PUSH
81779: LD_INT 3
81781: ARRAY
81782: GREATEREQUAL
81783: AND
81784: IFFALSE 81796
// result := weapon ;
81786: LD_ADDR_VAR 0 3
81790: PUSH
81791: LD_VAR 0 18
81795: ST_TO_ADDR
// end ; end ;
81796: LD_VAR 0 3
81800: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81801: LD_INT 0
81803: PPUSH
81804: PPUSH
// result := true ;
81805: LD_ADDR_VAR 0 3
81809: PUSH
81810: LD_INT 1
81812: ST_TO_ADDR
// if array1 = array2 then
81813: LD_VAR 0 1
81817: PUSH
81818: LD_VAR 0 2
81822: EQUAL
81823: IFFALSE 81883
// begin for i = 1 to array1 do
81825: LD_ADDR_VAR 0 4
81829: PUSH
81830: DOUBLE
81831: LD_INT 1
81833: DEC
81834: ST_TO_ADDR
81835: LD_VAR 0 1
81839: PUSH
81840: FOR_TO
81841: IFFALSE 81879
// if array1 [ i ] <> array2 [ i ] then
81843: LD_VAR 0 1
81847: PUSH
81848: LD_VAR 0 4
81852: ARRAY
81853: PUSH
81854: LD_VAR 0 2
81858: PUSH
81859: LD_VAR 0 4
81863: ARRAY
81864: NONEQUAL
81865: IFFALSE 81877
// begin result := false ;
81867: LD_ADDR_VAR 0 3
81871: PUSH
81872: LD_INT 0
81874: ST_TO_ADDR
// break ;
81875: GO 81879
// end ;
81877: GO 81840
81879: POP
81880: POP
// end else
81881: GO 81891
// result := false ;
81883: LD_ADDR_VAR 0 3
81887: PUSH
81888: LD_INT 0
81890: ST_TO_ADDR
// end ;
81891: LD_VAR 0 3
81895: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81896: LD_INT 0
81898: PPUSH
81899: PPUSH
// if not array1 or not array2 then
81900: LD_VAR 0 1
81904: NOT
81905: PUSH
81906: LD_VAR 0 2
81910: NOT
81911: OR
81912: IFFALSE 81916
// exit ;
81914: GO 81980
// result := true ;
81916: LD_ADDR_VAR 0 3
81920: PUSH
81921: LD_INT 1
81923: ST_TO_ADDR
// for i = 1 to array1 do
81924: LD_ADDR_VAR 0 4
81928: PUSH
81929: DOUBLE
81930: LD_INT 1
81932: DEC
81933: ST_TO_ADDR
81934: LD_VAR 0 1
81938: PUSH
81939: FOR_TO
81940: IFFALSE 81978
// if array1 [ i ] <> array2 [ i ] then
81942: LD_VAR 0 1
81946: PUSH
81947: LD_VAR 0 4
81951: ARRAY
81952: PUSH
81953: LD_VAR 0 2
81957: PUSH
81958: LD_VAR 0 4
81962: ARRAY
81963: NONEQUAL
81964: IFFALSE 81976
// begin result := false ;
81966: LD_ADDR_VAR 0 3
81970: PUSH
81971: LD_INT 0
81973: ST_TO_ADDR
// break ;
81974: GO 81978
// end ;
81976: GO 81939
81978: POP
81979: POP
// end ;
81980: LD_VAR 0 3
81984: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81985: LD_INT 0
81987: PPUSH
81988: PPUSH
81989: PPUSH
// pom := GetBase ( fac ) ;
81990: LD_ADDR_VAR 0 5
81994: PUSH
81995: LD_VAR 0 1
81999: PPUSH
82000: CALL_OW 274
82004: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82005: LD_ADDR_VAR 0 4
82009: PUSH
82010: LD_VAR 0 2
82014: PUSH
82015: LD_INT 1
82017: ARRAY
82018: PPUSH
82019: LD_VAR 0 2
82023: PUSH
82024: LD_INT 2
82026: ARRAY
82027: PPUSH
82028: LD_VAR 0 2
82032: PUSH
82033: LD_INT 3
82035: ARRAY
82036: PPUSH
82037: LD_VAR 0 2
82041: PUSH
82042: LD_INT 4
82044: ARRAY
82045: PPUSH
82046: CALL_OW 449
82050: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82051: LD_ADDR_VAR 0 3
82055: PUSH
82056: LD_VAR 0 5
82060: PPUSH
82061: LD_INT 1
82063: PPUSH
82064: CALL_OW 275
82068: PUSH
82069: LD_VAR 0 4
82073: PUSH
82074: LD_INT 1
82076: ARRAY
82077: GREATEREQUAL
82078: PUSH
82079: LD_VAR 0 5
82083: PPUSH
82084: LD_INT 2
82086: PPUSH
82087: CALL_OW 275
82091: PUSH
82092: LD_VAR 0 4
82096: PUSH
82097: LD_INT 2
82099: ARRAY
82100: GREATEREQUAL
82101: AND
82102: PUSH
82103: LD_VAR 0 5
82107: PPUSH
82108: LD_INT 3
82110: PPUSH
82111: CALL_OW 275
82115: PUSH
82116: LD_VAR 0 4
82120: PUSH
82121: LD_INT 3
82123: ARRAY
82124: GREATEREQUAL
82125: AND
82126: ST_TO_ADDR
// end ;
82127: LD_VAR 0 3
82131: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82132: LD_INT 0
82134: PPUSH
82135: PPUSH
82136: PPUSH
82137: PPUSH
// pom := GetBase ( building ) ;
82138: LD_ADDR_VAR 0 3
82142: PUSH
82143: LD_VAR 0 1
82147: PPUSH
82148: CALL_OW 274
82152: ST_TO_ADDR
// if not pom then
82153: LD_VAR 0 3
82157: NOT
82158: IFFALSE 82162
// exit ;
82160: GO 82332
// btype := GetBType ( building ) ;
82162: LD_ADDR_VAR 0 5
82166: PUSH
82167: LD_VAR 0 1
82171: PPUSH
82172: CALL_OW 266
82176: ST_TO_ADDR
// if btype = b_armoury then
82177: LD_VAR 0 5
82181: PUSH
82182: LD_INT 4
82184: EQUAL
82185: IFFALSE 82195
// btype := b_barracks ;
82187: LD_ADDR_VAR 0 5
82191: PUSH
82192: LD_INT 5
82194: ST_TO_ADDR
// if btype = b_depot then
82195: LD_VAR 0 5
82199: PUSH
82200: LD_INT 0
82202: EQUAL
82203: IFFALSE 82213
// btype := b_warehouse ;
82205: LD_ADDR_VAR 0 5
82209: PUSH
82210: LD_INT 1
82212: ST_TO_ADDR
// if btype = b_workshop then
82213: LD_VAR 0 5
82217: PUSH
82218: LD_INT 2
82220: EQUAL
82221: IFFALSE 82231
// btype := b_factory ;
82223: LD_ADDR_VAR 0 5
82227: PUSH
82228: LD_INT 3
82230: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82231: LD_ADDR_VAR 0 4
82235: PUSH
82236: LD_VAR 0 5
82240: PPUSH
82241: LD_VAR 0 1
82245: PPUSH
82246: CALL_OW 248
82250: PPUSH
82251: CALL_OW 450
82255: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82256: LD_ADDR_VAR 0 2
82260: PUSH
82261: LD_VAR 0 3
82265: PPUSH
82266: LD_INT 1
82268: PPUSH
82269: CALL_OW 275
82273: PUSH
82274: LD_VAR 0 4
82278: PUSH
82279: LD_INT 1
82281: ARRAY
82282: GREATEREQUAL
82283: PUSH
82284: LD_VAR 0 3
82288: PPUSH
82289: LD_INT 2
82291: PPUSH
82292: CALL_OW 275
82296: PUSH
82297: LD_VAR 0 4
82301: PUSH
82302: LD_INT 2
82304: ARRAY
82305: GREATEREQUAL
82306: AND
82307: PUSH
82308: LD_VAR 0 3
82312: PPUSH
82313: LD_INT 3
82315: PPUSH
82316: CALL_OW 275
82320: PUSH
82321: LD_VAR 0 4
82325: PUSH
82326: LD_INT 3
82328: ARRAY
82329: GREATEREQUAL
82330: AND
82331: ST_TO_ADDR
// end ;
82332: LD_VAR 0 2
82336: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
82337: LD_INT 0
82339: PPUSH
82340: PPUSH
82341: PPUSH
// pom := GetBase ( building ) ;
82342: LD_ADDR_VAR 0 4
82346: PUSH
82347: LD_VAR 0 1
82351: PPUSH
82352: CALL_OW 274
82356: ST_TO_ADDR
// if not pom then
82357: LD_VAR 0 4
82361: NOT
82362: IFFALSE 82366
// exit ;
82364: GO 82467
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82366: LD_ADDR_VAR 0 5
82370: PUSH
82371: LD_VAR 0 2
82375: PPUSH
82376: LD_VAR 0 1
82380: PPUSH
82381: CALL_OW 248
82385: PPUSH
82386: CALL_OW 450
82390: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82391: LD_ADDR_VAR 0 3
82395: PUSH
82396: LD_VAR 0 4
82400: PPUSH
82401: LD_INT 1
82403: PPUSH
82404: CALL_OW 275
82408: PUSH
82409: LD_VAR 0 5
82413: PUSH
82414: LD_INT 1
82416: ARRAY
82417: GREATEREQUAL
82418: PUSH
82419: LD_VAR 0 4
82423: PPUSH
82424: LD_INT 2
82426: PPUSH
82427: CALL_OW 275
82431: PUSH
82432: LD_VAR 0 5
82436: PUSH
82437: LD_INT 2
82439: ARRAY
82440: GREATEREQUAL
82441: AND
82442: PUSH
82443: LD_VAR 0 4
82447: PPUSH
82448: LD_INT 3
82450: PPUSH
82451: CALL_OW 275
82455: PUSH
82456: LD_VAR 0 5
82460: PUSH
82461: LD_INT 3
82463: ARRAY
82464: GREATEREQUAL
82465: AND
82466: ST_TO_ADDR
// end ;
82467: LD_VAR 0 3
82471: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
82472: LD_INT 0
82474: PPUSH
82475: PPUSH
82476: PPUSH
82477: PPUSH
82478: PPUSH
82479: PPUSH
82480: PPUSH
82481: PPUSH
82482: PPUSH
82483: PPUSH
82484: PPUSH
// result := false ;
82485: LD_ADDR_VAR 0 8
82489: PUSH
82490: LD_INT 0
82492: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
82493: LD_VAR 0 5
82497: NOT
82498: PUSH
82499: LD_VAR 0 1
82503: NOT
82504: OR
82505: PUSH
82506: LD_VAR 0 2
82510: NOT
82511: OR
82512: PUSH
82513: LD_VAR 0 3
82517: NOT
82518: OR
82519: IFFALSE 82523
// exit ;
82521: GO 83337
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
82523: LD_ADDR_VAR 0 14
82527: PUSH
82528: LD_VAR 0 1
82532: PPUSH
82533: LD_VAR 0 2
82537: PPUSH
82538: LD_VAR 0 3
82542: PPUSH
82543: LD_VAR 0 4
82547: PPUSH
82548: LD_VAR 0 5
82552: PUSH
82553: LD_INT 1
82555: ARRAY
82556: PPUSH
82557: CALL_OW 248
82561: PPUSH
82562: LD_INT 0
82564: PPUSH
82565: CALL 84590 0 6
82569: ST_TO_ADDR
// if not hexes then
82570: LD_VAR 0 14
82574: NOT
82575: IFFALSE 82579
// exit ;
82577: GO 83337
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82579: LD_ADDR_VAR 0 17
82583: PUSH
82584: LD_VAR 0 5
82588: PPUSH
82589: LD_INT 22
82591: PUSH
82592: LD_VAR 0 13
82596: PPUSH
82597: CALL_OW 255
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 2
82608: PUSH
82609: LD_INT 30
82611: PUSH
82612: LD_INT 0
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 30
82621: PUSH
82622: LD_INT 1
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: LIST
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PPUSH
82638: CALL_OW 72
82642: ST_TO_ADDR
// for i = 1 to hexes do
82643: LD_ADDR_VAR 0 9
82647: PUSH
82648: DOUBLE
82649: LD_INT 1
82651: DEC
82652: ST_TO_ADDR
82653: LD_VAR 0 14
82657: PUSH
82658: FOR_TO
82659: IFFALSE 83335
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82661: LD_ADDR_VAR 0 13
82665: PUSH
82666: LD_VAR 0 14
82670: PUSH
82671: LD_VAR 0 9
82675: ARRAY
82676: PUSH
82677: LD_INT 1
82679: ARRAY
82680: PPUSH
82681: LD_VAR 0 14
82685: PUSH
82686: LD_VAR 0 9
82690: ARRAY
82691: PUSH
82692: LD_INT 2
82694: ARRAY
82695: PPUSH
82696: CALL_OW 428
82700: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82701: LD_VAR 0 14
82705: PUSH
82706: LD_VAR 0 9
82710: ARRAY
82711: PUSH
82712: LD_INT 1
82714: ARRAY
82715: PPUSH
82716: LD_VAR 0 14
82720: PUSH
82721: LD_VAR 0 9
82725: ARRAY
82726: PUSH
82727: LD_INT 2
82729: ARRAY
82730: PPUSH
82731: CALL_OW 351
82735: PUSH
82736: LD_VAR 0 14
82740: PUSH
82741: LD_VAR 0 9
82745: ARRAY
82746: PUSH
82747: LD_INT 1
82749: ARRAY
82750: PPUSH
82751: LD_VAR 0 14
82755: PUSH
82756: LD_VAR 0 9
82760: ARRAY
82761: PUSH
82762: LD_INT 2
82764: ARRAY
82765: PPUSH
82766: CALL_OW 488
82770: NOT
82771: OR
82772: PUSH
82773: LD_VAR 0 13
82777: PPUSH
82778: CALL_OW 247
82782: PUSH
82783: LD_INT 3
82785: EQUAL
82786: OR
82787: IFFALSE 82793
// exit ;
82789: POP
82790: POP
82791: GO 83337
// if not tmp then
82793: LD_VAR 0 13
82797: NOT
82798: IFFALSE 82802
// continue ;
82800: GO 82658
// result := true ;
82802: LD_ADDR_VAR 0 8
82806: PUSH
82807: LD_INT 1
82809: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82810: LD_VAR 0 6
82814: PUSH
82815: LD_VAR 0 13
82819: PPUSH
82820: CALL_OW 247
82824: PUSH
82825: LD_INT 2
82827: EQUAL
82828: AND
82829: PUSH
82830: LD_VAR 0 13
82834: PPUSH
82835: CALL_OW 263
82839: PUSH
82840: LD_INT 1
82842: EQUAL
82843: AND
82844: IFFALSE 83008
// begin if IsDrivenBy ( tmp ) then
82846: LD_VAR 0 13
82850: PPUSH
82851: CALL_OW 311
82855: IFFALSE 82859
// continue ;
82857: GO 82658
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82859: LD_VAR 0 6
82863: PPUSH
82864: LD_INT 3
82866: PUSH
82867: LD_INT 60
82869: PUSH
82870: EMPTY
82871: LIST
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 3
82879: PUSH
82880: LD_INT 55
82882: PUSH
82883: EMPTY
82884: LIST
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PPUSH
82894: CALL_OW 72
82898: IFFALSE 83006
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82900: LD_ADDR_VAR 0 18
82904: PUSH
82905: LD_VAR 0 6
82909: PPUSH
82910: LD_INT 3
82912: PUSH
82913: LD_INT 60
82915: PUSH
82916: EMPTY
82917: LIST
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 3
82925: PUSH
82926: LD_INT 55
82928: PUSH
82929: EMPTY
82930: LIST
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PPUSH
82940: CALL_OW 72
82944: PUSH
82945: LD_INT 1
82947: ARRAY
82948: ST_TO_ADDR
// if IsInUnit ( driver ) then
82949: LD_VAR 0 18
82953: PPUSH
82954: CALL_OW 310
82958: IFFALSE 82969
// ComExit ( driver ) ;
82960: LD_VAR 0 18
82964: PPUSH
82965: CALL 108371 0 1
// AddComEnterUnit ( driver , tmp ) ;
82969: LD_VAR 0 18
82973: PPUSH
82974: LD_VAR 0 13
82978: PPUSH
82979: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82983: LD_VAR 0 18
82987: PPUSH
82988: LD_VAR 0 7
82992: PPUSH
82993: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82997: LD_VAR 0 18
83001: PPUSH
83002: CALL_OW 181
// end ; continue ;
83006: GO 82658
// end ; if not cleaners or not tmp in cleaners then
83008: LD_VAR 0 6
83012: NOT
83013: PUSH
83014: LD_VAR 0 13
83018: PUSH
83019: LD_VAR 0 6
83023: IN
83024: NOT
83025: OR
83026: IFFALSE 83333
// begin if dep then
83028: LD_VAR 0 17
83032: IFFALSE 83168
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83034: LD_ADDR_VAR 0 16
83038: PUSH
83039: LD_VAR 0 17
83043: PUSH
83044: LD_INT 1
83046: ARRAY
83047: PPUSH
83048: CALL_OW 250
83052: PPUSH
83053: LD_VAR 0 17
83057: PUSH
83058: LD_INT 1
83060: ARRAY
83061: PPUSH
83062: CALL_OW 254
83066: PPUSH
83067: LD_INT 5
83069: PPUSH
83070: CALL_OW 272
83074: PUSH
83075: LD_VAR 0 17
83079: PUSH
83080: LD_INT 1
83082: ARRAY
83083: PPUSH
83084: CALL_OW 251
83088: PPUSH
83089: LD_VAR 0 17
83093: PUSH
83094: LD_INT 1
83096: ARRAY
83097: PPUSH
83098: CALL_OW 254
83102: PPUSH
83103: LD_INT 5
83105: PPUSH
83106: CALL_OW 273
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83115: LD_VAR 0 16
83119: PUSH
83120: LD_INT 1
83122: ARRAY
83123: PPUSH
83124: LD_VAR 0 16
83128: PUSH
83129: LD_INT 2
83131: ARRAY
83132: PPUSH
83133: CALL_OW 488
83137: IFFALSE 83168
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83139: LD_VAR 0 13
83143: PPUSH
83144: LD_VAR 0 16
83148: PUSH
83149: LD_INT 1
83151: ARRAY
83152: PPUSH
83153: LD_VAR 0 16
83157: PUSH
83158: LD_INT 2
83160: ARRAY
83161: PPUSH
83162: CALL_OW 111
// continue ;
83166: GO 82658
// end ; end ; r := GetDir ( tmp ) ;
83168: LD_ADDR_VAR 0 15
83172: PUSH
83173: LD_VAR 0 13
83177: PPUSH
83178: CALL_OW 254
83182: ST_TO_ADDR
// if r = 5 then
83183: LD_VAR 0 15
83187: PUSH
83188: LD_INT 5
83190: EQUAL
83191: IFFALSE 83201
// r := 0 ;
83193: LD_ADDR_VAR 0 15
83197: PUSH
83198: LD_INT 0
83200: ST_TO_ADDR
// for j = r to 5 do
83201: LD_ADDR_VAR 0 10
83205: PUSH
83206: DOUBLE
83207: LD_VAR 0 15
83211: DEC
83212: ST_TO_ADDR
83213: LD_INT 5
83215: PUSH
83216: FOR_TO
83217: IFFALSE 83331
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
83219: LD_ADDR_VAR 0 11
83223: PUSH
83224: LD_VAR 0 13
83228: PPUSH
83229: CALL_OW 250
83233: PPUSH
83234: LD_VAR 0 10
83238: PPUSH
83239: LD_INT 2
83241: PPUSH
83242: CALL_OW 272
83246: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
83247: LD_ADDR_VAR 0 12
83251: PUSH
83252: LD_VAR 0 13
83256: PPUSH
83257: CALL_OW 251
83261: PPUSH
83262: LD_VAR 0 10
83266: PPUSH
83267: LD_INT 2
83269: PPUSH
83270: CALL_OW 273
83274: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
83275: LD_VAR 0 11
83279: PPUSH
83280: LD_VAR 0 12
83284: PPUSH
83285: CALL_OW 488
83289: PUSH
83290: LD_VAR 0 11
83294: PPUSH
83295: LD_VAR 0 12
83299: PPUSH
83300: CALL_OW 428
83304: NOT
83305: AND
83306: IFFALSE 83329
// begin ComMoveXY ( tmp , _x , _y ) ;
83308: LD_VAR 0 13
83312: PPUSH
83313: LD_VAR 0 11
83317: PPUSH
83318: LD_VAR 0 12
83322: PPUSH
83323: CALL_OW 111
// break ;
83327: GO 83331
// end ; end ;
83329: GO 83216
83331: POP
83332: POP
// end ; end ;
83333: GO 82658
83335: POP
83336: POP
// end ;
83337: LD_VAR 0 8
83341: RET
// export function BuildingTechInvented ( side , btype ) ; begin
83342: LD_INT 0
83344: PPUSH
// result := true ;
83345: LD_ADDR_VAR 0 3
83349: PUSH
83350: LD_INT 1
83352: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
83353: LD_VAR 0 2
83357: PUSH
83358: LD_INT 24
83360: DOUBLE
83361: EQUAL
83362: IFTRUE 83372
83364: LD_INT 33
83366: DOUBLE
83367: EQUAL
83368: IFTRUE 83372
83370: GO 83397
83372: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
83373: LD_ADDR_VAR 0 3
83377: PUSH
83378: LD_INT 32
83380: PPUSH
83381: LD_VAR 0 1
83385: PPUSH
83386: CALL_OW 321
83390: PUSH
83391: LD_INT 2
83393: EQUAL
83394: ST_TO_ADDR
83395: GO 83713
83397: LD_INT 20
83399: DOUBLE
83400: EQUAL
83401: IFTRUE 83405
83403: GO 83430
83405: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
83406: LD_ADDR_VAR 0 3
83410: PUSH
83411: LD_INT 6
83413: PPUSH
83414: LD_VAR 0 1
83418: PPUSH
83419: CALL_OW 321
83423: PUSH
83424: LD_INT 2
83426: EQUAL
83427: ST_TO_ADDR
83428: GO 83713
83430: LD_INT 22
83432: DOUBLE
83433: EQUAL
83434: IFTRUE 83444
83436: LD_INT 36
83438: DOUBLE
83439: EQUAL
83440: IFTRUE 83444
83442: GO 83469
83444: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
83445: LD_ADDR_VAR 0 3
83449: PUSH
83450: LD_INT 15
83452: PPUSH
83453: LD_VAR 0 1
83457: PPUSH
83458: CALL_OW 321
83462: PUSH
83463: LD_INT 2
83465: EQUAL
83466: ST_TO_ADDR
83467: GO 83713
83469: LD_INT 30
83471: DOUBLE
83472: EQUAL
83473: IFTRUE 83477
83475: GO 83502
83477: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
83478: LD_ADDR_VAR 0 3
83482: PUSH
83483: LD_INT 20
83485: PPUSH
83486: LD_VAR 0 1
83490: PPUSH
83491: CALL_OW 321
83495: PUSH
83496: LD_INT 2
83498: EQUAL
83499: ST_TO_ADDR
83500: GO 83713
83502: LD_INT 28
83504: DOUBLE
83505: EQUAL
83506: IFTRUE 83516
83508: LD_INT 21
83510: DOUBLE
83511: EQUAL
83512: IFTRUE 83516
83514: GO 83541
83516: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
83517: LD_ADDR_VAR 0 3
83521: PUSH
83522: LD_INT 21
83524: PPUSH
83525: LD_VAR 0 1
83529: PPUSH
83530: CALL_OW 321
83534: PUSH
83535: LD_INT 2
83537: EQUAL
83538: ST_TO_ADDR
83539: GO 83713
83541: LD_INT 16
83543: DOUBLE
83544: EQUAL
83545: IFTRUE 83549
83547: GO 83574
83549: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
83550: LD_ADDR_VAR 0 3
83554: PUSH
83555: LD_INT 84
83557: PPUSH
83558: LD_VAR 0 1
83562: PPUSH
83563: CALL_OW 321
83567: PUSH
83568: LD_INT 2
83570: EQUAL
83571: ST_TO_ADDR
83572: GO 83713
83574: LD_INT 19
83576: DOUBLE
83577: EQUAL
83578: IFTRUE 83588
83580: LD_INT 23
83582: DOUBLE
83583: EQUAL
83584: IFTRUE 83588
83586: GO 83613
83588: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83589: LD_ADDR_VAR 0 3
83593: PUSH
83594: LD_INT 83
83596: PPUSH
83597: LD_VAR 0 1
83601: PPUSH
83602: CALL_OW 321
83606: PUSH
83607: LD_INT 2
83609: EQUAL
83610: ST_TO_ADDR
83611: GO 83713
83613: LD_INT 17
83615: DOUBLE
83616: EQUAL
83617: IFTRUE 83621
83619: GO 83646
83621: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83622: LD_ADDR_VAR 0 3
83626: PUSH
83627: LD_INT 39
83629: PPUSH
83630: LD_VAR 0 1
83634: PPUSH
83635: CALL_OW 321
83639: PUSH
83640: LD_INT 2
83642: EQUAL
83643: ST_TO_ADDR
83644: GO 83713
83646: LD_INT 18
83648: DOUBLE
83649: EQUAL
83650: IFTRUE 83654
83652: GO 83679
83654: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83655: LD_ADDR_VAR 0 3
83659: PUSH
83660: LD_INT 40
83662: PPUSH
83663: LD_VAR 0 1
83667: PPUSH
83668: CALL_OW 321
83672: PUSH
83673: LD_INT 2
83675: EQUAL
83676: ST_TO_ADDR
83677: GO 83713
83679: LD_INT 27
83681: DOUBLE
83682: EQUAL
83683: IFTRUE 83687
83685: GO 83712
83687: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83688: LD_ADDR_VAR 0 3
83692: PUSH
83693: LD_INT 35
83695: PPUSH
83696: LD_VAR 0 1
83700: PPUSH
83701: CALL_OW 321
83705: PUSH
83706: LD_INT 2
83708: EQUAL
83709: ST_TO_ADDR
83710: GO 83713
83712: POP
// end ;
83713: LD_VAR 0 3
83717: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83718: LD_INT 0
83720: PPUSH
83721: PPUSH
83722: PPUSH
83723: PPUSH
83724: PPUSH
83725: PPUSH
83726: PPUSH
83727: PPUSH
83728: PPUSH
83729: PPUSH
83730: PPUSH
// result := false ;
83731: LD_ADDR_VAR 0 6
83735: PUSH
83736: LD_INT 0
83738: ST_TO_ADDR
// if btype = b_depot then
83739: LD_VAR 0 2
83743: PUSH
83744: LD_INT 0
83746: EQUAL
83747: IFFALSE 83759
// begin result := true ;
83749: LD_ADDR_VAR 0 6
83753: PUSH
83754: LD_INT 1
83756: ST_TO_ADDR
// exit ;
83757: GO 84585
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83759: LD_VAR 0 1
83763: NOT
83764: PUSH
83765: LD_VAR 0 1
83769: PPUSH
83770: CALL_OW 266
83774: PUSH
83775: LD_INT 0
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: IN
83785: NOT
83786: OR
83787: PUSH
83788: LD_VAR 0 2
83792: NOT
83793: OR
83794: PUSH
83795: LD_VAR 0 5
83799: PUSH
83800: LD_INT 0
83802: PUSH
83803: LD_INT 1
83805: PUSH
83806: LD_INT 2
83808: PUSH
83809: LD_INT 3
83811: PUSH
83812: LD_INT 4
83814: PUSH
83815: LD_INT 5
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: IN
83826: NOT
83827: OR
83828: PUSH
83829: LD_VAR 0 3
83833: PPUSH
83834: LD_VAR 0 4
83838: PPUSH
83839: CALL_OW 488
83843: NOT
83844: OR
83845: IFFALSE 83849
// exit ;
83847: GO 84585
// side := GetSide ( depot ) ;
83849: LD_ADDR_VAR 0 9
83853: PUSH
83854: LD_VAR 0 1
83858: PPUSH
83859: CALL_OW 255
83863: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83864: LD_VAR 0 9
83868: PPUSH
83869: LD_VAR 0 2
83873: PPUSH
83874: CALL 83342 0 2
83878: NOT
83879: IFFALSE 83883
// exit ;
83881: GO 84585
// pom := GetBase ( depot ) ;
83883: LD_ADDR_VAR 0 10
83887: PUSH
83888: LD_VAR 0 1
83892: PPUSH
83893: CALL_OW 274
83897: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83898: LD_ADDR_VAR 0 11
83902: PUSH
83903: LD_VAR 0 2
83907: PPUSH
83908: LD_VAR 0 1
83912: PPUSH
83913: CALL_OW 248
83917: PPUSH
83918: CALL_OW 450
83922: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83923: LD_VAR 0 10
83927: PPUSH
83928: LD_INT 1
83930: PPUSH
83931: CALL_OW 275
83935: PUSH
83936: LD_VAR 0 11
83940: PUSH
83941: LD_INT 1
83943: ARRAY
83944: GREATEREQUAL
83945: PUSH
83946: LD_VAR 0 10
83950: PPUSH
83951: LD_INT 2
83953: PPUSH
83954: CALL_OW 275
83958: PUSH
83959: LD_VAR 0 11
83963: PUSH
83964: LD_INT 2
83966: ARRAY
83967: GREATEREQUAL
83968: AND
83969: PUSH
83970: LD_VAR 0 10
83974: PPUSH
83975: LD_INT 3
83977: PPUSH
83978: CALL_OW 275
83982: PUSH
83983: LD_VAR 0 11
83987: PUSH
83988: LD_INT 3
83990: ARRAY
83991: GREATEREQUAL
83992: AND
83993: NOT
83994: IFFALSE 83998
// exit ;
83996: GO 84585
// if GetBType ( depot ) = b_depot then
83998: LD_VAR 0 1
84002: PPUSH
84003: CALL_OW 266
84007: PUSH
84008: LD_INT 0
84010: EQUAL
84011: IFFALSE 84023
// dist := 28 else
84013: LD_ADDR_VAR 0 14
84017: PUSH
84018: LD_INT 28
84020: ST_TO_ADDR
84021: GO 84031
// dist := 36 ;
84023: LD_ADDR_VAR 0 14
84027: PUSH
84028: LD_INT 36
84030: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84031: LD_VAR 0 1
84035: PPUSH
84036: LD_VAR 0 3
84040: PPUSH
84041: LD_VAR 0 4
84045: PPUSH
84046: CALL_OW 297
84050: PUSH
84051: LD_VAR 0 14
84055: GREATER
84056: IFFALSE 84060
// exit ;
84058: GO 84585
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84060: LD_ADDR_VAR 0 12
84064: PUSH
84065: LD_VAR 0 2
84069: PPUSH
84070: LD_VAR 0 3
84074: PPUSH
84075: LD_VAR 0 4
84079: PPUSH
84080: LD_VAR 0 5
84084: PPUSH
84085: LD_VAR 0 1
84089: PPUSH
84090: CALL_OW 248
84094: PPUSH
84095: LD_INT 0
84097: PPUSH
84098: CALL 84590 0 6
84102: ST_TO_ADDR
// if not hexes then
84103: LD_VAR 0 12
84107: NOT
84108: IFFALSE 84112
// exit ;
84110: GO 84585
// hex := GetHexInfo ( x , y ) ;
84112: LD_ADDR_VAR 0 15
84116: PUSH
84117: LD_VAR 0 3
84121: PPUSH
84122: LD_VAR 0 4
84126: PPUSH
84127: CALL_OW 546
84131: ST_TO_ADDR
// if hex [ 1 ] then
84132: LD_VAR 0 15
84136: PUSH
84137: LD_INT 1
84139: ARRAY
84140: IFFALSE 84144
// exit ;
84142: GO 84585
// height := hex [ 2 ] ;
84144: LD_ADDR_VAR 0 13
84148: PUSH
84149: LD_VAR 0 15
84153: PUSH
84154: LD_INT 2
84156: ARRAY
84157: ST_TO_ADDR
// for i = 1 to hexes do
84158: LD_ADDR_VAR 0 7
84162: PUSH
84163: DOUBLE
84164: LD_INT 1
84166: DEC
84167: ST_TO_ADDR
84168: LD_VAR 0 12
84172: PUSH
84173: FOR_TO
84174: IFFALSE 84504
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
84176: LD_VAR 0 12
84180: PUSH
84181: LD_VAR 0 7
84185: ARRAY
84186: PUSH
84187: LD_INT 1
84189: ARRAY
84190: PPUSH
84191: LD_VAR 0 12
84195: PUSH
84196: LD_VAR 0 7
84200: ARRAY
84201: PUSH
84202: LD_INT 2
84204: ARRAY
84205: PPUSH
84206: CALL_OW 488
84210: NOT
84211: PUSH
84212: LD_VAR 0 12
84216: PUSH
84217: LD_VAR 0 7
84221: ARRAY
84222: PUSH
84223: LD_INT 1
84225: ARRAY
84226: PPUSH
84227: LD_VAR 0 12
84231: PUSH
84232: LD_VAR 0 7
84236: ARRAY
84237: PUSH
84238: LD_INT 2
84240: ARRAY
84241: PPUSH
84242: CALL_OW 428
84246: PUSH
84247: LD_INT 0
84249: GREATER
84250: OR
84251: PUSH
84252: LD_VAR 0 12
84256: PUSH
84257: LD_VAR 0 7
84261: ARRAY
84262: PUSH
84263: LD_INT 1
84265: ARRAY
84266: PPUSH
84267: LD_VAR 0 12
84271: PUSH
84272: LD_VAR 0 7
84276: ARRAY
84277: PUSH
84278: LD_INT 2
84280: ARRAY
84281: PPUSH
84282: CALL_OW 351
84286: OR
84287: IFFALSE 84293
// exit ;
84289: POP
84290: POP
84291: GO 84585
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84293: LD_ADDR_VAR 0 8
84297: PUSH
84298: LD_VAR 0 12
84302: PUSH
84303: LD_VAR 0 7
84307: ARRAY
84308: PUSH
84309: LD_INT 1
84311: ARRAY
84312: PPUSH
84313: LD_VAR 0 12
84317: PUSH
84318: LD_VAR 0 7
84322: ARRAY
84323: PUSH
84324: LD_INT 2
84326: ARRAY
84327: PPUSH
84328: CALL_OW 546
84332: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
84333: LD_VAR 0 8
84337: PUSH
84338: LD_INT 1
84340: ARRAY
84341: PUSH
84342: LD_VAR 0 8
84346: PUSH
84347: LD_INT 2
84349: ARRAY
84350: PUSH
84351: LD_VAR 0 13
84355: PUSH
84356: LD_INT 2
84358: PLUS
84359: GREATER
84360: OR
84361: PUSH
84362: LD_VAR 0 8
84366: PUSH
84367: LD_INT 2
84369: ARRAY
84370: PUSH
84371: LD_VAR 0 13
84375: PUSH
84376: LD_INT 2
84378: MINUS
84379: LESS
84380: OR
84381: PUSH
84382: LD_VAR 0 8
84386: PUSH
84387: LD_INT 3
84389: ARRAY
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 8
84396: PUSH
84397: LD_INT 9
84399: PUSH
84400: LD_INT 10
84402: PUSH
84403: LD_INT 11
84405: PUSH
84406: LD_INT 12
84408: PUSH
84409: LD_INT 13
84411: PUSH
84412: LD_INT 16
84414: PUSH
84415: LD_INT 17
84417: PUSH
84418: LD_INT 18
84420: PUSH
84421: LD_INT 19
84423: PUSH
84424: LD_INT 20
84426: PUSH
84427: LD_INT 21
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: IN
84445: NOT
84446: OR
84447: PUSH
84448: LD_VAR 0 8
84452: PUSH
84453: LD_INT 5
84455: ARRAY
84456: NOT
84457: OR
84458: PUSH
84459: LD_VAR 0 8
84463: PUSH
84464: LD_INT 6
84466: ARRAY
84467: PUSH
84468: LD_INT 1
84470: PUSH
84471: LD_INT 2
84473: PUSH
84474: LD_INT 7
84476: PUSH
84477: LD_INT 9
84479: PUSH
84480: LD_INT 10
84482: PUSH
84483: LD_INT 11
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: IN
84494: NOT
84495: OR
84496: IFFALSE 84502
// exit ;
84498: POP
84499: POP
84500: GO 84585
// end ;
84502: GO 84173
84504: POP
84505: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
84506: LD_VAR 0 9
84510: PPUSH
84511: LD_VAR 0 3
84515: PPUSH
84516: LD_VAR 0 4
84520: PPUSH
84521: LD_INT 20
84523: PPUSH
84524: CALL 76508 0 4
84528: PUSH
84529: LD_INT 4
84531: ARRAY
84532: IFFALSE 84536
// exit ;
84534: GO 84585
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
84536: LD_VAR 0 2
84540: PUSH
84541: LD_INT 29
84543: PUSH
84544: LD_INT 30
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: IN
84551: PUSH
84552: LD_VAR 0 3
84556: PPUSH
84557: LD_VAR 0 4
84561: PPUSH
84562: LD_VAR 0 9
84566: PPUSH
84567: CALL_OW 440
84571: NOT
84572: AND
84573: IFFALSE 84577
// exit ;
84575: GO 84585
// result := true ;
84577: LD_ADDR_VAR 0 6
84581: PUSH
84582: LD_INT 1
84584: ST_TO_ADDR
// end ;
84585: LD_VAR 0 6
84589: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84590: LD_INT 0
84592: PPUSH
84593: PPUSH
84594: PPUSH
84595: PPUSH
84596: PPUSH
84597: PPUSH
84598: PPUSH
84599: PPUSH
84600: PPUSH
84601: PPUSH
84602: PPUSH
84603: PPUSH
84604: PPUSH
84605: PPUSH
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
84622: PPUSH
84623: PPUSH
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
84628: PPUSH
84629: PPUSH
84630: PPUSH
84631: PPUSH
84632: PPUSH
84633: PPUSH
84634: PPUSH
84635: PPUSH
84636: PPUSH
84637: PPUSH
84638: PPUSH
84639: PPUSH
84640: PPUSH
84641: PPUSH
84642: PPUSH
84643: PPUSH
84644: PPUSH
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
84649: PPUSH
// result = [ ] ;
84650: LD_ADDR_VAR 0 7
84654: PUSH
84655: EMPTY
84656: ST_TO_ADDR
// temp_list = [ ] ;
84657: LD_ADDR_VAR 0 9
84661: PUSH
84662: EMPTY
84663: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84664: LD_VAR 0 4
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: LD_INT 2
84677: PUSH
84678: LD_INT 3
84680: PUSH
84681: LD_INT 4
84683: PUSH
84684: LD_INT 5
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: IN
84695: NOT
84696: PUSH
84697: LD_VAR 0 1
84701: PUSH
84702: LD_INT 0
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: IN
84712: PUSH
84713: LD_VAR 0 5
84717: PUSH
84718: LD_INT 1
84720: PUSH
84721: LD_INT 2
84723: PUSH
84724: LD_INT 3
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: LIST
84731: IN
84732: NOT
84733: AND
84734: OR
84735: IFFALSE 84739
// exit ;
84737: GO 103130
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84739: LD_VAR 0 1
84743: PUSH
84744: LD_INT 6
84746: PUSH
84747: LD_INT 7
84749: PUSH
84750: LD_INT 8
84752: PUSH
84753: LD_INT 13
84755: PUSH
84756: LD_INT 12
84758: PUSH
84759: LD_INT 15
84761: PUSH
84762: LD_INT 11
84764: PUSH
84765: LD_INT 14
84767: PUSH
84768: LD_INT 10
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: IN
84782: IFFALSE 84792
// btype = b_lab ;
84784: LD_ADDR_VAR 0 1
84788: PUSH
84789: LD_INT 6
84791: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84792: LD_VAR 0 6
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: LD_INT 1
84802: PUSH
84803: LD_INT 2
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: LIST
84810: IN
84811: NOT
84812: PUSH
84813: LD_VAR 0 1
84817: PUSH
84818: LD_INT 0
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: LD_INT 3
84829: PUSH
84830: LD_INT 6
84832: PUSH
84833: LD_INT 36
84835: PUSH
84836: LD_INT 4
84838: PUSH
84839: LD_INT 5
84841: PUSH
84842: LD_INT 31
84844: PUSH
84845: LD_INT 32
84847: PUSH
84848: LD_INT 33
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: IN
84864: NOT
84865: PUSH
84866: LD_VAR 0 6
84870: PUSH
84871: LD_INT 1
84873: EQUAL
84874: AND
84875: OR
84876: PUSH
84877: LD_VAR 0 1
84881: PUSH
84882: LD_INT 2
84884: PUSH
84885: LD_INT 3
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: IN
84892: NOT
84893: PUSH
84894: LD_VAR 0 6
84898: PUSH
84899: LD_INT 2
84901: EQUAL
84902: AND
84903: OR
84904: IFFALSE 84914
// mode = 0 ;
84906: LD_ADDR_VAR 0 6
84910: PUSH
84911: LD_INT 0
84913: ST_TO_ADDR
// case mode of 0 :
84914: LD_VAR 0 6
84918: PUSH
84919: LD_INT 0
84921: DOUBLE
84922: EQUAL
84923: IFTRUE 84927
84925: GO 96380
84927: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84928: LD_ADDR_VAR 0 11
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: LD_INT 0
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 0
84945: PUSH
84946: LD_INT 1
84948: NEG
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 1
84956: PUSH
84957: LD_INT 0
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 1
84966: PUSH
84967: LD_INT 1
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 0
84976: PUSH
84977: LD_INT 1
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 1
84986: NEG
84987: PUSH
84988: LD_INT 0
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 1
85001: NEG
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 1
85009: NEG
85010: PUSH
85011: LD_INT 2
85013: NEG
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 0
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: LD_INT 2
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 0
85053: PUSH
85054: LD_INT 2
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 1
85063: NEG
85064: PUSH
85065: LD_INT 1
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: LD_INT 3
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: LD_INT 3
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 1
85094: NEG
85095: PUSH
85096: LD_INT 2
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85121: LD_ADDR_VAR 0 12
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: LD_INT 0
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 0
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: PUSH
85150: LD_INT 0
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 1
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 0
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: EMPTY
85174: LIST
85175: LIST
85176: PUSH
85177: LD_INT 1
85179: NEG
85180: PUSH
85181: LD_INT 0
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 1
85190: NEG
85191: PUSH
85192: LD_INT 1
85194: NEG
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 1
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 2
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 2
85223: PUSH
85224: LD_INT 1
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 2
85244: NEG
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: NEG
85256: PUSH
85257: LD_INT 1
85259: NEG
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 2
85267: NEG
85268: PUSH
85269: LD_INT 1
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 3
85278: NEG
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 3
85289: NEG
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85317: LD_ADDR_VAR 0 13
85321: PUSH
85322: LD_INT 0
85324: PUSH
85325: LD_INT 0
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 0
85334: PUSH
85335: LD_INT 1
85337: NEG
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 1
85355: PUSH
85356: LD_INT 1
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 0
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 1
85375: NEG
85376: PUSH
85377: LD_INT 0
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 1
85386: NEG
85387: PUSH
85388: LD_INT 1
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 2
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: PUSH
85411: LD_INT 1
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 2
85420: PUSH
85421: LD_INT 2
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 1
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 2
85440: NEG
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 2
85452: NEG
85453: PUSH
85454: LD_INT 2
85456: NEG
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 2
85464: NEG
85465: PUSH
85466: LD_INT 3
85468: NEG
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 3
85476: NEG
85477: PUSH
85478: LD_INT 2
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 3
85488: NEG
85489: PUSH
85490: LD_INT 3
85492: NEG
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85516: LD_ADDR_VAR 0 14
85520: PUSH
85521: LD_INT 0
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 0
85533: PUSH
85534: LD_INT 1
85536: NEG
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 1
85544: PUSH
85545: LD_INT 0
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 1
85554: PUSH
85555: LD_INT 1
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 0
85564: PUSH
85565: LD_INT 1
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 1
85574: NEG
85575: PUSH
85576: LD_INT 0
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: NEG
85586: PUSH
85587: LD_INT 1
85589: NEG
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PUSH
85595: LD_INT 1
85597: NEG
85598: PUSH
85599: LD_INT 2
85601: NEG
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 0
85609: PUSH
85610: LD_INT 2
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 1
85620: PUSH
85621: LD_INT 1
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 2
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: LD_INT 3
85666: NEG
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 0
85674: PUSH
85675: LD_INT 3
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 2
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85712: LD_ADDR_VAR 0 15
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 0
85729: PUSH
85730: LD_INT 1
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 1
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 0
85760: PUSH
85761: LD_INT 1
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: NEG
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 1
85793: PUSH
85794: LD_INT 1
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 2
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 2
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: LD_INT 1
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 2
85835: NEG
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 2
85846: NEG
85847: PUSH
85848: LD_INT 1
85850: NEG
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 2
85858: PUSH
85859: LD_INT 1
85861: NEG
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 3
85869: PUSH
85870: LD_INT 0
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 3
85879: PUSH
85880: LD_INT 1
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85905: LD_ADDR_VAR 0 16
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 1
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 1
85963: NEG
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: NEG
85975: PUSH
85976: LD_INT 1
85978: NEG
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 1
85986: NEG
85987: PUSH
85988: LD_INT 2
85990: NEG
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 2
86008: PUSH
86009: LD_INT 2
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: LD_INT 1
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 2
86028: NEG
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 2
86040: NEG
86041: PUSH
86042: LD_INT 2
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 3
86052: PUSH
86053: LD_INT 2
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 3
86062: PUSH
86063: LD_INT 3
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 2
86072: PUSH
86073: LD_INT 3
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86098: LD_ADDR_VAR 0 17
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 0
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 0
86115: PUSH
86116: LD_INT 1
86118: NEG
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 1
86126: PUSH
86127: LD_INT 0
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PUSH
86134: LD_INT 1
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 0
86146: PUSH
86147: LD_INT 1
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: LD_INT 0
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 1
86167: NEG
86168: PUSH
86169: LD_INT 1
86171: NEG
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: LD_INT 2
86183: NEG
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 0
86191: PUSH
86192: LD_INT 2
86194: NEG
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 1
86202: PUSH
86203: LD_INT 1
86205: NEG
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 2
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 2
86223: PUSH
86224: LD_INT 1
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 2
86233: PUSH
86234: LD_INT 2
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 1
86243: PUSH
86244: LD_INT 2
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 0
86253: PUSH
86254: LD_INT 2
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: LD_INT 1
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: LD_INT 0
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: PUSH
86283: LD_INT 2
86285: NEG
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 2
86297: NEG
86298: PUSH
86299: LD_INT 2
86301: NEG
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86328: LD_ADDR_VAR 0 18
86332: PUSH
86333: LD_INT 0
86335: PUSH
86336: LD_INT 0
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: LD_INT 1
86348: NEG
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 1
86356: PUSH
86357: LD_INT 0
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 1
86366: PUSH
86367: LD_INT 1
86369: PUSH
86370: EMPTY
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: LD_INT 1
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PUSH
86384: LD_INT 1
86386: NEG
86387: PUSH
86388: LD_INT 0
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 1
86401: NEG
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: PUSH
86407: LD_INT 1
86409: NEG
86410: PUSH
86411: LD_INT 2
86413: NEG
86414: PUSH
86415: EMPTY
86416: LIST
86417: LIST
86418: PUSH
86419: LD_INT 0
86421: PUSH
86422: LD_INT 2
86424: NEG
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: LD_INT 1
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 2
86443: PUSH
86444: LD_INT 0
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 2
86453: PUSH
86454: LD_INT 1
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 2
86463: PUSH
86464: LD_INT 2
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 1
86473: PUSH
86474: LD_INT 2
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: LD_INT 2
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: LD_INT 0
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 2
86515: NEG
86516: PUSH
86517: LD_INT 1
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 2
86527: NEG
86528: PUSH
86529: LD_INT 2
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86558: LD_ADDR_VAR 0 19
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: LD_INT 1
86578: NEG
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: LD_INT 0
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: LD_INT 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 1
86616: NEG
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: NEG
86628: PUSH
86629: LD_INT 1
86631: NEG
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 1
86639: NEG
86640: PUSH
86641: LD_INT 2
86643: NEG
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: LD_INT 2
86654: NEG
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 2
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 2
86683: PUSH
86684: LD_INT 1
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PUSH
86691: LD_INT 2
86693: PUSH
86694: LD_INT 2
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: LD_INT 2
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: LD_INT 2
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 1
86723: NEG
86724: PUSH
86725: LD_INT 1
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 2
86734: NEG
86735: PUSH
86736: LD_INT 0
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 2
86745: NEG
86746: PUSH
86747: LD_INT 1
86749: NEG
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 2
86757: NEG
86758: PUSH
86759: LD_INT 2
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86788: LD_ADDR_VAR 0 20
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: LD_INT 0
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 0
86805: PUSH
86806: LD_INT 1
86808: NEG
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 1
86816: PUSH
86817: LD_INT 0
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 0
86836: PUSH
86837: LD_INT 1
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: PUSH
86844: LD_INT 1
86846: NEG
86847: PUSH
86848: LD_INT 0
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 1
86857: NEG
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: NEG
86870: PUSH
86871: LD_INT 2
86873: NEG
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 0
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 1
86892: PUSH
86893: LD_INT 1
86895: NEG
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 2
86903: PUSH
86904: LD_INT 0
86906: PUSH
86907: EMPTY
86908: LIST
86909: LIST
86910: PUSH
86911: LD_INT 2
86913: PUSH
86914: LD_INT 1
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 2
86923: PUSH
86924: LD_INT 2
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 1
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 0
86943: PUSH
86944: LD_INT 2
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 1
86953: NEG
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 2
86964: NEG
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 2
86975: NEG
86976: PUSH
86977: LD_INT 1
86979: NEG
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 2
86987: NEG
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87018: LD_ADDR_VAR 0 21
87022: PUSH
87023: LD_INT 0
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: LD_INT 1
87038: NEG
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: LD_INT 0
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 1
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 0
87066: PUSH
87067: LD_INT 1
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: LD_INT 0
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: LD_INT 1
87091: NEG
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 1
87099: NEG
87100: PUSH
87101: LD_INT 2
87103: NEG
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 0
87111: PUSH
87112: LD_INT 2
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 1
87122: PUSH
87123: LD_INT 1
87125: NEG
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 2
87133: PUSH
87134: LD_INT 0
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 2
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 2
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 1
87163: PUSH
87164: LD_INT 2
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: LD_INT 2
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 2
87194: NEG
87195: PUSH
87196: LD_INT 0
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 2
87205: NEG
87206: PUSH
87207: LD_INT 1
87209: NEG
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 2
87217: NEG
87218: PUSH
87219: LD_INT 2
87221: NEG
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87248: LD_ADDR_VAR 0 22
87252: PUSH
87253: LD_INT 0
87255: PUSH
87256: LD_INT 0
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: PUSH
87263: LD_INT 0
87265: PUSH
87266: LD_INT 1
87268: NEG
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: LD_INT 0
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 1
87286: PUSH
87287: LD_INT 1
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 1
87317: NEG
87318: PUSH
87319: LD_INT 1
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: NEG
87330: PUSH
87331: LD_INT 2
87333: NEG
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 0
87341: PUSH
87342: LD_INT 2
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 1
87352: PUSH
87353: LD_INT 1
87355: NEG
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 2
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 2
87373: PUSH
87374: LD_INT 1
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 2
87383: PUSH
87384: LD_INT 2
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 1
87393: PUSH
87394: LD_INT 2
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: LD_INT 2
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: LD_INT 1
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 2
87424: NEG
87425: PUSH
87426: LD_INT 0
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 2
87435: NEG
87436: PUSH
87437: LD_INT 1
87439: NEG
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 2
87447: NEG
87448: PUSH
87449: LD_INT 2
87451: NEG
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87478: LD_ADDR_VAR 0 23
87482: PUSH
87483: LD_INT 0
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 0
87495: PUSH
87496: LD_INT 1
87498: NEG
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 0
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 1
87516: PUSH
87517: LD_INT 1
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 0
87526: PUSH
87527: LD_INT 1
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: NEG
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: NEG
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 1
87559: NEG
87560: PUSH
87561: LD_INT 2
87563: NEG
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 2
87574: NEG
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 1
87585: NEG
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 2
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: LD_INT 1
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 2
87613: PUSH
87614: LD_INT 2
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 1
87623: PUSH
87624: LD_INT 2
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 0
87633: PUSH
87634: LD_INT 2
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 2
87654: NEG
87655: PUSH
87656: LD_INT 0
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 2
87665: NEG
87666: PUSH
87667: LD_INT 1
87669: NEG
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 2
87677: NEG
87678: PUSH
87679: LD_INT 2
87681: NEG
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 2
87689: NEG
87690: PUSH
87691: LD_INT 3
87693: NEG
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 1
87701: NEG
87702: PUSH
87703: LD_INT 3
87705: NEG
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: PUSH
87714: LD_INT 2
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 2
87724: PUSH
87725: LD_INT 1
87727: NEG
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87758: LD_ADDR_VAR 0 24
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: LD_INT 0
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: LD_INT 1
87778: NEG
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: LD_INT 0
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: LD_INT 1
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: LD_INT 1
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: NEG
87817: PUSH
87818: LD_INT 0
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 1
87827: NEG
87828: PUSH
87829: LD_INT 1
87831: NEG
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: LD_INT 2
87843: NEG
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: LD_INT 2
87854: NEG
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: PUSH
87863: LD_INT 1
87865: NEG
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 2
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 2
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 2
87893: PUSH
87894: LD_INT 2
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: LD_INT 2
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: LD_INT 1
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 2
87934: NEG
87935: PUSH
87936: LD_INT 0
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 2
87945: NEG
87946: PUSH
87947: LD_INT 1
87949: NEG
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: LD_INT 2
87957: NEG
87958: PUSH
87959: LD_INT 2
87961: NEG
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 1
87969: PUSH
87970: LD_INT 2
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 2
87980: PUSH
87981: LD_INT 1
87983: NEG
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 3
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 3
88001: PUSH
88002: LD_INT 2
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88034: LD_ADDR_VAR 0 25
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 0
88051: PUSH
88052: LD_INT 1
88054: NEG
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 1
88072: PUSH
88073: LD_INT 1
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: LD_INT 1
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 1
88103: NEG
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: LD_INT 2
88119: NEG
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 0
88127: PUSH
88128: LD_INT 2
88130: NEG
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 1
88138: PUSH
88139: LD_INT 1
88141: NEG
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 2
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 2
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 2
88169: PUSH
88170: LD_INT 2
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 1
88179: PUSH
88180: LD_INT 2
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 0
88189: PUSH
88190: LD_INT 2
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: LD_INT 1
88199: NEG
88200: PUSH
88201: LD_INT 1
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 2
88210: NEG
88211: PUSH
88212: LD_INT 0
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 2
88221: NEG
88222: PUSH
88223: LD_INT 1
88225: NEG
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 2
88233: NEG
88234: PUSH
88235: LD_INT 2
88237: NEG
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 3
88245: PUSH
88246: LD_INT 1
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 3
88255: PUSH
88256: LD_INT 2
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 2
88265: PUSH
88266: LD_INT 3
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: LD_INT 3
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88308: LD_ADDR_VAR 0 26
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: LD_INT 0
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: LD_INT 1
88328: NEG
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: LD_INT 0
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 1
88366: NEG
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: LD_INT 1
88381: NEG
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 1
88389: NEG
88390: PUSH
88391: LD_INT 2
88393: NEG
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 0
88401: PUSH
88402: LD_INT 2
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 1
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 2
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 2
88443: PUSH
88444: LD_INT 2
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: PUSH
88454: LD_INT 2
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 0
88463: PUSH
88464: LD_INT 2
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 1
88473: NEG
88474: PUSH
88475: LD_INT 1
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 2
88484: NEG
88485: PUSH
88486: LD_INT 0
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 2
88495: NEG
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 2
88507: NEG
88508: PUSH
88509: LD_INT 2
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 2
88519: PUSH
88520: LD_INT 3
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: LD_INT 1
88529: PUSH
88530: LD_INT 3
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 2
88550: NEG
88551: PUSH
88552: LD_INT 1
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88584: LD_ADDR_VAR 0 27
88588: PUSH
88589: LD_INT 0
88591: PUSH
88592: LD_INT 0
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 0
88601: PUSH
88602: LD_INT 1
88604: NEG
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 1
88612: PUSH
88613: LD_INT 0
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 1
88642: NEG
88643: PUSH
88644: LD_INT 0
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 1
88653: NEG
88654: PUSH
88655: LD_INT 1
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 1
88665: NEG
88666: PUSH
88667: LD_INT 2
88669: NEG
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 0
88677: PUSH
88678: LD_INT 2
88680: NEG
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 1
88688: PUSH
88689: LD_INT 1
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 2
88699: PUSH
88700: LD_INT 0
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 2
88709: PUSH
88710: LD_INT 1
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 2
88719: PUSH
88720: LD_INT 2
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 1
88729: PUSH
88730: LD_INT 2
88732: PUSH
88733: EMPTY
88734: LIST
88735: LIST
88736: PUSH
88737: LD_INT 0
88739: PUSH
88740: LD_INT 2
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 1
88749: NEG
88750: PUSH
88751: LD_INT 1
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 2
88760: NEG
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: PUSH
88769: LD_INT 2
88771: NEG
88772: PUSH
88773: LD_INT 1
88775: NEG
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 2
88783: NEG
88784: PUSH
88785: LD_INT 2
88787: NEG
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: NEG
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 2
88806: NEG
88807: PUSH
88808: LD_INT 1
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 3
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: NEG
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 3
88829: NEG
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88864: LD_ADDR_VAR 0 28
88868: PUSH
88869: LD_INT 0
88871: PUSH
88872: LD_INT 0
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 0
88881: PUSH
88882: LD_INT 1
88884: NEG
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: PUSH
88903: LD_INT 1
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 0
88912: PUSH
88913: LD_INT 1
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 1
88922: NEG
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: LD_INT 1
88937: NEG
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 1
88945: NEG
88946: PUSH
88947: LD_INT 2
88949: NEG
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 0
88957: PUSH
88958: LD_INT 2
88960: NEG
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 1
88968: PUSH
88969: LD_INT 1
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: PUSH
88990: LD_INT 1
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 2
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: LD_INT 2
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: LD_INT 2
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 1
89029: NEG
89030: PUSH
89031: LD_INT 1
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 2
89040: NEG
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: NEG
89052: PUSH
89053: LD_INT 1
89055: NEG
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 2
89063: NEG
89064: PUSH
89065: LD_INT 2
89067: NEG
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 2
89075: NEG
89076: PUSH
89077: LD_INT 3
89079: NEG
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 1
89087: NEG
89088: PUSH
89089: LD_INT 3
89091: NEG
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: PUSH
89097: LD_INT 3
89099: NEG
89100: PUSH
89101: LD_INT 1
89103: NEG
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PUSH
89109: LD_INT 3
89111: NEG
89112: PUSH
89113: LD_INT 2
89115: NEG
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89146: LD_ADDR_VAR 0 29
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 0
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: LD_INT 0
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: LD_INT 1
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 0
89194: PUSH
89195: LD_INT 1
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: LD_INT 0
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: LD_INT 1
89219: NEG
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 1
89227: NEG
89228: PUSH
89229: LD_INT 2
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 2
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: LD_INT 1
89253: NEG
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 2
89261: PUSH
89262: LD_INT 0
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 2
89271: PUSH
89272: LD_INT 1
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 1
89281: PUSH
89282: LD_INT 2
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 0
89291: PUSH
89292: LD_INT 2
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: NEG
89302: PUSH
89303: LD_INT 1
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 2
89312: NEG
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 2
89324: NEG
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 2
89336: NEG
89337: PUSH
89338: LD_INT 3
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 2
89348: PUSH
89349: LD_INT 1
89351: NEG
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 3
89359: PUSH
89360: LD_INT 1
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 1
89369: PUSH
89370: LD_INT 3
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 1
89379: NEG
89380: PUSH
89381: LD_INT 2
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 3
89390: NEG
89391: PUSH
89392: LD_INT 2
89394: NEG
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89425: LD_ADDR_VAR 0 30
89429: PUSH
89430: LD_INT 0
89432: PUSH
89433: LD_INT 0
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 0
89442: PUSH
89443: LD_INT 1
89445: NEG
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PUSH
89461: LD_INT 1
89463: PUSH
89464: LD_INT 1
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 0
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: LD_INT 1
89483: NEG
89484: PUSH
89485: LD_INT 0
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: LD_INT 1
89498: NEG
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: LD_INT 1
89506: NEG
89507: PUSH
89508: LD_INT 2
89510: NEG
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: LD_INT 0
89518: PUSH
89519: LD_INT 2
89521: NEG
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 1
89529: PUSH
89530: LD_INT 1
89532: NEG
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 2
89540: PUSH
89541: LD_INT 0
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 2
89550: PUSH
89551: LD_INT 1
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 2
89560: PUSH
89561: LD_INT 2
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 1
89570: PUSH
89571: LD_INT 2
89573: PUSH
89574: EMPTY
89575: LIST
89576: LIST
89577: PUSH
89578: LD_INT 1
89580: NEG
89581: PUSH
89582: LD_INT 1
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 2
89591: NEG
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 2
89602: NEG
89603: PUSH
89604: LD_INT 1
89606: NEG
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 1
89614: NEG
89615: PUSH
89616: LD_INT 3
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 1
89626: PUSH
89627: LD_INT 2
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 3
89637: PUSH
89638: LD_INT 2
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 2
89647: PUSH
89648: LD_INT 3
89650: PUSH
89651: EMPTY
89652: LIST
89653: LIST
89654: PUSH
89655: LD_INT 2
89657: NEG
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 3
89668: NEG
89669: PUSH
89670: LD_INT 1
89672: NEG
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89703: LD_ADDR_VAR 0 31
89707: PUSH
89708: LD_INT 0
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 0
89720: PUSH
89721: LD_INT 1
89723: NEG
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 1
89731: PUSH
89732: LD_INT 0
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: LD_INT 1
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: LD_INT 1
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 1
89761: NEG
89762: PUSH
89763: LD_INT 0
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 1
89772: NEG
89773: PUSH
89774: LD_INT 1
89776: NEG
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 1
89784: NEG
89785: PUSH
89786: LD_INT 2
89788: NEG
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: LD_INT 1
89799: NEG
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 2
89807: PUSH
89808: LD_INT 0
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 2
89817: PUSH
89818: LD_INT 1
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 2
89827: PUSH
89828: LD_INT 2
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: LD_INT 2
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: LD_INT 2
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 1
89857: NEG
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 2
89868: NEG
89869: PUSH
89870: LD_INT 1
89872: NEG
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 2
89880: NEG
89881: PUSH
89882: LD_INT 2
89884: NEG
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 2
89892: NEG
89893: PUSH
89894: LD_INT 3
89896: NEG
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 2
89904: PUSH
89905: LD_INT 1
89907: NEG
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 3
89915: PUSH
89916: LD_INT 1
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 1
89925: PUSH
89926: LD_INT 3
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 1
89935: NEG
89936: PUSH
89937: LD_INT 2
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 3
89946: NEG
89947: PUSH
89948: LD_INT 2
89950: NEG
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89981: LD_ADDR_VAR 0 32
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 1
90019: PUSH
90020: LD_INT 1
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 1
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: LD_INT 1
90039: NEG
90040: PUSH
90041: LD_INT 0
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 1
90050: NEG
90051: PUSH
90052: LD_INT 1
90054: NEG
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: PUSH
90060: LD_INT 1
90062: NEG
90063: PUSH
90064: LD_INT 2
90066: NEG
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 0
90074: PUSH
90075: LD_INT 2
90077: NEG
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 1
90085: PUSH
90086: LD_INT 1
90088: NEG
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 2
90096: PUSH
90097: LD_INT 1
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 2
90106: PUSH
90107: LD_INT 2
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 0
90126: PUSH
90127: LD_INT 2
90129: PUSH
90130: EMPTY
90131: LIST
90132: LIST
90133: PUSH
90134: LD_INT 1
90136: NEG
90137: PUSH
90138: LD_INT 1
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: LD_INT 2
90147: NEG
90148: PUSH
90149: LD_INT 0
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 2
90158: NEG
90159: PUSH
90160: LD_INT 1
90162: NEG
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: LD_INT 3
90174: NEG
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 1
90182: PUSH
90183: LD_INT 2
90185: NEG
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 3
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 2
90203: PUSH
90204: LD_INT 3
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 2
90213: NEG
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 3
90224: NEG
90225: PUSH
90226: LD_INT 1
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90259: LD_ADDR_VAR 0 33
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: LD_INT 1
90279: NEG
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: LD_INT 0
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 1
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 0
90307: PUSH
90308: LD_INT 1
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: LD_INT 1
90317: NEG
90318: PUSH
90319: LD_INT 0
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 1
90328: NEG
90329: PUSH
90330: LD_INT 1
90332: NEG
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 1
90340: NEG
90341: PUSH
90342: LD_INT 2
90344: NEG
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 1
90352: PUSH
90353: LD_INT 1
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 2
90363: PUSH
90364: LD_INT 0
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 2
90373: PUSH
90374: LD_INT 1
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: LD_INT 2
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: LD_INT 2
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: LD_INT 1
90403: NEG
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 2
90414: NEG
90415: PUSH
90416: LD_INT 0
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 2
90425: NEG
90426: PUSH
90427: LD_INT 1
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 2
90437: NEG
90438: PUSH
90439: LD_INT 2
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 2
90449: NEG
90450: PUSH
90451: LD_INT 3
90453: NEG
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 2
90461: PUSH
90462: LD_INT 1
90464: NEG
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 3
90472: PUSH
90473: LD_INT 1
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 3
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 2
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 3
90503: NEG
90504: PUSH
90505: LD_INT 2
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90538: LD_ADDR_VAR 0 34
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: LD_INT 1
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: LD_INT 0
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 1
90576: PUSH
90577: LD_INT 1
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 0
90586: PUSH
90587: LD_INT 1
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 1
90596: NEG
90597: PUSH
90598: LD_INT 0
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 1
90607: NEG
90608: PUSH
90609: LD_INT 1
90611: NEG
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 1
90619: NEG
90620: PUSH
90621: LD_INT 2
90623: NEG
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 0
90631: PUSH
90632: LD_INT 2
90634: NEG
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 1
90642: PUSH
90643: LD_INT 1
90645: NEG
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 2
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: PUSH
90664: LD_INT 2
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 1
90673: PUSH
90674: LD_INT 2
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: LD_INT 1
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 2
90694: NEG
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 2
90705: NEG
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 2
90717: NEG
90718: PUSH
90719: LD_INT 2
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 1
90729: NEG
90730: PUSH
90731: LD_INT 3
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 1
90741: PUSH
90742: LD_INT 2
90744: NEG
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 3
90752: PUSH
90753: LD_INT 2
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 2
90762: PUSH
90763: LD_INT 3
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 2
90772: NEG
90773: PUSH
90774: LD_INT 1
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 3
90783: NEG
90784: PUSH
90785: LD_INT 1
90787: NEG
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90818: LD_ADDR_VAR 0 35
90822: PUSH
90823: LD_INT 0
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: PUSH
90833: LD_INT 0
90835: PUSH
90836: LD_INT 1
90838: NEG
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 1
90846: PUSH
90847: LD_INT 0
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 1
90856: PUSH
90857: LD_INT 1
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: LD_INT 1
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 1
90887: NEG
90888: PUSH
90889: LD_INT 1
90891: NEG
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 2
90899: PUSH
90900: LD_INT 1
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 2
90909: NEG
90910: PUSH
90911: LD_INT 1
90913: NEG
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90930: LD_ADDR_VAR 0 36
90934: PUSH
90935: LD_INT 0
90937: PUSH
90938: LD_INT 0
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: LD_INT 1
90950: NEG
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PUSH
90956: LD_INT 1
90958: PUSH
90959: LD_INT 0
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: LD_INT 1
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: LD_INT 1
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 1
90988: NEG
90989: PUSH
90990: LD_INT 0
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 1
90999: NEG
91000: PUSH
91001: LD_INT 1
91003: NEG
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: LD_INT 1
91011: NEG
91012: PUSH
91013: LD_INT 2
91015: NEG
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: LD_INT 1
91023: PUSH
91024: LD_INT 2
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91042: LD_ADDR_VAR 0 37
91046: PUSH
91047: LD_INT 0
91049: PUSH
91050: LD_INT 0
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: LD_INT 1
91062: NEG
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: LD_INT 0
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 1
91080: PUSH
91081: LD_INT 1
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 0
91090: PUSH
91091: LD_INT 1
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 1
91100: NEG
91101: PUSH
91102: LD_INT 0
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: LD_INT 1
91115: NEG
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 1
91123: PUSH
91124: LD_INT 1
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: NEG
91135: PUSH
91136: LD_INT 1
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91154: LD_ADDR_VAR 0 38
91158: PUSH
91159: LD_INT 0
91161: PUSH
91162: LD_INT 0
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 1
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 1
91192: PUSH
91193: LD_INT 1
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: LD_INT 1
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 1
91212: NEG
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 1
91223: NEG
91224: PUSH
91225: LD_INT 1
91227: NEG
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 2
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 2
91245: NEG
91246: PUSH
91247: LD_INT 1
91249: NEG
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91266: LD_ADDR_VAR 0 39
91270: PUSH
91271: LD_INT 0
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: PUSH
91281: LD_INT 0
91283: PUSH
91284: LD_INT 1
91286: NEG
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 1
91294: PUSH
91295: LD_INT 0
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: PUSH
91305: LD_INT 1
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: PUSH
91312: LD_INT 0
91314: PUSH
91315: LD_INT 1
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 1
91324: NEG
91325: PUSH
91326: LD_INT 0
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: LD_INT 1
91339: NEG
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: LD_INT 2
91351: NEG
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 1
91359: PUSH
91360: LD_INT 2
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91378: LD_ADDR_VAR 0 40
91382: PUSH
91383: LD_INT 0
91385: PUSH
91386: LD_INT 0
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 0
91395: PUSH
91396: LD_INT 1
91398: NEG
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 1
91406: PUSH
91407: LD_INT 0
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: LD_INT 1
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: PUSH
91424: LD_INT 0
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 1
91436: NEG
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 1
91447: NEG
91448: PUSH
91449: LD_INT 1
91451: NEG
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 1
91459: PUSH
91460: LD_INT 1
91462: NEG
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: LD_INT 1
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91490: LD_ADDR_VAR 0 41
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: LD_INT 1
91510: NEG
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: LD_INT 0
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 1
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: LD_INT 1
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 1
91559: NEG
91560: PUSH
91561: LD_INT 1
91563: NEG
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 1
91571: NEG
91572: PUSH
91573: LD_INT 2
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 1
91583: PUSH
91584: LD_INT 1
91586: NEG
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 2
91594: PUSH
91595: LD_INT 0
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 2
91604: PUSH
91605: LD_INT 1
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 2
91614: PUSH
91615: LD_INT 2
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 1
91624: PUSH
91625: LD_INT 2
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: LD_INT 1
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: PUSH
91643: LD_INT 2
91645: NEG
91646: PUSH
91647: LD_INT 0
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: NEG
91657: PUSH
91658: LD_INT 1
91660: NEG
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 2
91668: NEG
91669: PUSH
91670: LD_INT 2
91672: NEG
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 2
91680: NEG
91681: PUSH
91682: LD_INT 3
91684: NEG
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 2
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 3
91703: PUSH
91704: LD_INT 0
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: LD_INT 3
91713: PUSH
91714: LD_INT 1
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: LD_INT 3
91723: PUSH
91724: LD_INT 2
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: PUSH
91731: LD_INT 3
91733: PUSH
91734: LD_INT 3
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 2
91743: PUSH
91744: LD_INT 3
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 2
91753: NEG
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: LD_INT 0
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 3
91775: NEG
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 3
91787: NEG
91788: PUSH
91789: LD_INT 2
91791: NEG
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 3
91799: NEG
91800: PUSH
91801: LD_INT 3
91803: NEG
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91840: LD_ADDR_VAR 0 42
91844: PUSH
91845: LD_INT 0
91847: PUSH
91848: LD_INT 0
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: LD_INT 1
91860: NEG
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 1
91868: PUSH
91869: LD_INT 0
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 1
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 0
91888: PUSH
91889: LD_INT 1
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 1
91898: NEG
91899: PUSH
91900: LD_INT 0
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: LD_INT 1
91913: NEG
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 1
91921: NEG
91922: PUSH
91923: LD_INT 2
91925: NEG
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 2
91936: NEG
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 2
91955: PUSH
91956: LD_INT 1
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 2
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 1
91975: PUSH
91976: LD_INT 2
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 0
91985: PUSH
91986: LD_INT 2
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 1
91995: NEG
91996: PUSH
91997: LD_INT 1
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 2
92006: NEG
92007: PUSH
92008: LD_INT 1
92010: NEG
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 2
92018: NEG
92019: PUSH
92020: LD_INT 2
92022: NEG
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: PUSH
92028: LD_INT 2
92030: NEG
92031: PUSH
92032: LD_INT 3
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 1
92042: NEG
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 1
92065: PUSH
92066: LD_INT 2
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 3
92076: PUSH
92077: LD_INT 2
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 3
92086: PUSH
92087: LD_INT 3
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 2
92096: PUSH
92097: LD_INT 3
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 1
92106: PUSH
92107: LD_INT 3
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 0
92116: PUSH
92117: LD_INT 3
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 1
92126: NEG
92127: PUSH
92128: LD_INT 2
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 3
92137: NEG
92138: PUSH
92139: LD_INT 2
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 3
92149: NEG
92150: PUSH
92151: LD_INT 3
92153: NEG
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92190: LD_ADDR_VAR 0 43
92194: PUSH
92195: LD_INT 0
92197: PUSH
92198: LD_INT 0
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 0
92207: PUSH
92208: LD_INT 1
92210: NEG
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 1
92218: PUSH
92219: LD_INT 0
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: LD_INT 1
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 0
92238: PUSH
92239: LD_INT 1
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 1
92248: NEG
92249: PUSH
92250: LD_INT 0
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 1
92259: NEG
92260: PUSH
92261: LD_INT 1
92263: NEG
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 1
92271: NEG
92272: PUSH
92273: LD_INT 2
92275: NEG
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: PUSH
92281: LD_INT 0
92283: PUSH
92284: LD_INT 2
92286: NEG
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 1
92294: PUSH
92295: LD_INT 1
92297: NEG
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 2
92305: PUSH
92306: LD_INT 0
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PUSH
92313: LD_INT 2
92315: PUSH
92316: LD_INT 1
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: LD_INT 2
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: LD_INT 0
92335: PUSH
92336: LD_INT 2
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: LD_INT 1
92345: NEG
92346: PUSH
92347: LD_INT 1
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 2
92356: NEG
92357: PUSH
92358: LD_INT 0
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 2
92367: NEG
92368: PUSH
92369: LD_INT 1
92371: NEG
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 1
92379: NEG
92380: PUSH
92381: LD_INT 3
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: LD_INT 0
92391: PUSH
92392: LD_INT 3
92394: NEG
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 1
92402: PUSH
92403: LD_INT 2
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 2
92413: PUSH
92414: LD_INT 1
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 3
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 3
92434: PUSH
92435: LD_INT 1
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 1
92444: PUSH
92445: LD_INT 3
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 0
92454: PUSH
92455: LD_INT 3
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 1
92464: NEG
92465: PUSH
92466: LD_INT 2
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 2
92475: NEG
92476: PUSH
92477: LD_INT 1
92479: PUSH
92480: EMPTY
92481: LIST
92482: LIST
92483: PUSH
92484: LD_INT 3
92486: NEG
92487: PUSH
92488: LD_INT 0
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 3
92497: NEG
92498: PUSH
92499: LD_INT 1
92501: NEG
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92538: LD_ADDR_VAR 0 44
92542: PUSH
92543: LD_INT 0
92545: PUSH
92546: LD_INT 0
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 0
92555: PUSH
92556: LD_INT 1
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: PUSH
92567: LD_INT 0
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 1
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 0
92586: PUSH
92587: LD_INT 1
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 1
92596: NEG
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 1
92607: NEG
92608: PUSH
92609: LD_INT 1
92611: NEG
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: LD_INT 2
92623: NEG
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 1
92631: PUSH
92632: LD_INT 1
92634: NEG
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 2
92642: PUSH
92643: LD_INT 0
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 2
92652: PUSH
92653: LD_INT 1
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: LD_INT 2
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: LD_INT 2
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 1
92682: NEG
92683: PUSH
92684: LD_INT 1
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 2
92693: NEG
92694: PUSH
92695: LD_INT 0
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: LD_INT 2
92704: NEG
92705: PUSH
92706: LD_INT 1
92708: NEG
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 2
92716: NEG
92717: PUSH
92718: LD_INT 2
92720: NEG
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 2
92728: NEG
92729: PUSH
92730: LD_INT 3
92732: NEG
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 2
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 3
92751: PUSH
92752: LD_INT 0
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 3
92761: PUSH
92762: LD_INT 1
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 3
92771: PUSH
92772: LD_INT 2
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 3
92781: PUSH
92782: LD_INT 3
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 2
92791: PUSH
92792: LD_INT 3
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 2
92801: NEG
92802: PUSH
92803: LD_INT 1
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 3
92812: NEG
92813: PUSH
92814: LD_INT 0
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 3
92823: NEG
92824: PUSH
92825: LD_INT 1
92827: NEG
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 3
92835: NEG
92836: PUSH
92837: LD_INT 2
92839: NEG
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 3
92847: NEG
92848: PUSH
92849: LD_INT 3
92851: NEG
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92888: LD_ADDR_VAR 0 45
92892: PUSH
92893: LD_INT 0
92895: PUSH
92896: LD_INT 0
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 0
92905: PUSH
92906: LD_INT 1
92908: NEG
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 1
92916: PUSH
92917: LD_INT 0
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: LD_INT 1
92926: PUSH
92927: LD_INT 1
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 0
92936: PUSH
92937: LD_INT 1
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PUSH
92944: LD_INT 1
92946: NEG
92947: PUSH
92948: LD_INT 0
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 1
92957: NEG
92958: PUSH
92959: LD_INT 1
92961: NEG
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PUSH
92967: LD_INT 1
92969: NEG
92970: PUSH
92971: LD_INT 2
92973: NEG
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 0
92981: PUSH
92982: LD_INT 2
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 1
92992: PUSH
92993: LD_INT 1
92995: NEG
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 2
93003: PUSH
93004: LD_INT 1
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 2
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 1
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 0
93033: PUSH
93034: LD_INT 2
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 1
93043: NEG
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 2
93054: NEG
93055: PUSH
93056: LD_INT 1
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 2
93066: NEG
93067: PUSH
93068: LD_INT 2
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 2
93078: NEG
93079: PUSH
93080: LD_INT 3
93082: NEG
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 1
93090: NEG
93091: PUSH
93092: LD_INT 3
93094: NEG
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 0
93102: PUSH
93103: LD_INT 3
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 1
93113: PUSH
93114: LD_INT 2
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 3
93124: PUSH
93125: LD_INT 2
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 3
93134: PUSH
93135: LD_INT 3
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 2
93144: PUSH
93145: LD_INT 3
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 1
93154: PUSH
93155: LD_INT 3
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 0
93164: PUSH
93165: LD_INT 3
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 1
93174: NEG
93175: PUSH
93176: LD_INT 2
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: LD_INT 3
93185: NEG
93186: PUSH
93187: LD_INT 2
93189: NEG
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 3
93197: NEG
93198: PUSH
93199: LD_INT 3
93201: NEG
93202: PUSH
93203: EMPTY
93204: LIST
93205: LIST
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93238: LD_ADDR_VAR 0 46
93242: PUSH
93243: LD_INT 0
93245: PUSH
93246: LD_INT 0
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 0
93255: PUSH
93256: LD_INT 1
93258: NEG
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 1
93266: PUSH
93267: LD_INT 0
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 1
93276: PUSH
93277: LD_INT 1
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 0
93286: PUSH
93287: LD_INT 1
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 1
93296: NEG
93297: PUSH
93298: LD_INT 0
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: LD_INT 1
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: LD_INT 2
93323: NEG
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 0
93331: PUSH
93332: LD_INT 2
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 1
93342: PUSH
93343: LD_INT 1
93345: NEG
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 2
93353: PUSH
93354: LD_INT 0
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 2
93363: PUSH
93364: LD_INT 1
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: LD_INT 1
93373: PUSH
93374: LD_INT 2
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 0
93383: PUSH
93384: LD_INT 2
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 1
93393: NEG
93394: PUSH
93395: LD_INT 1
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: LD_INT 2
93404: NEG
93405: PUSH
93406: LD_INT 0
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 2
93415: NEG
93416: PUSH
93417: LD_INT 1
93419: NEG
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 1
93427: NEG
93428: PUSH
93429: LD_INT 3
93431: NEG
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 0
93439: PUSH
93440: LD_INT 3
93442: NEG
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 1
93450: PUSH
93451: LD_INT 2
93453: NEG
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 2
93461: PUSH
93462: LD_INT 1
93464: NEG
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 3
93472: PUSH
93473: LD_INT 0
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 3
93482: PUSH
93483: LD_INT 1
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: LD_INT 3
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 0
93502: PUSH
93503: LD_INT 3
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: LD_INT 2
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 2
93523: NEG
93524: PUSH
93525: LD_INT 1
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 3
93534: NEG
93535: PUSH
93536: LD_INT 0
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 3
93545: NEG
93546: PUSH
93547: LD_INT 1
93549: NEG
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93586: LD_ADDR_VAR 0 47
93590: PUSH
93591: LD_INT 0
93593: PUSH
93594: LD_INT 0
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 0
93603: PUSH
93604: LD_INT 1
93606: NEG
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 1
93614: PUSH
93615: LD_INT 0
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 1
93624: PUSH
93625: LD_INT 1
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 0
93634: PUSH
93635: LD_INT 1
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: LD_INT 1
93644: NEG
93645: PUSH
93646: LD_INT 0
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: LD_INT 1
93655: NEG
93656: PUSH
93657: LD_INT 1
93659: NEG
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 1
93667: NEG
93668: PUSH
93669: LD_INT 2
93671: NEG
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 0
93679: PUSH
93680: LD_INT 2
93682: NEG
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 1
93690: PUSH
93691: LD_INT 1
93693: NEG
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 2
93701: NEG
93702: PUSH
93703: LD_INT 1
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 2
93713: NEG
93714: PUSH
93715: LD_INT 2
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93737: LD_ADDR_VAR 0 48
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: LD_INT 0
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 0
93754: PUSH
93755: LD_INT 1
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: LD_INT 0
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 1
93775: PUSH
93776: LD_INT 1
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 0
93785: PUSH
93786: LD_INT 1
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 1
93795: NEG
93796: PUSH
93797: LD_INT 0
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 1
93806: NEG
93807: PUSH
93808: LD_INT 1
93810: NEG
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: LD_INT 1
93818: NEG
93819: PUSH
93820: LD_INT 2
93822: NEG
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: PUSH
93828: LD_INT 0
93830: PUSH
93831: LD_INT 2
93833: NEG
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 1
93841: PUSH
93842: LD_INT 1
93844: NEG
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 2
93852: PUSH
93853: LD_INT 0
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 2
93862: PUSH
93863: LD_INT 1
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93884: LD_ADDR_VAR 0 49
93888: PUSH
93889: LD_INT 0
93891: PUSH
93892: LD_INT 0
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 0
93901: PUSH
93902: LD_INT 1
93904: NEG
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 1
93912: PUSH
93913: LD_INT 0
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 1
93922: PUSH
93923: LD_INT 1
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 0
93932: PUSH
93933: LD_INT 1
93935: PUSH
93936: EMPTY
93937: LIST
93938: LIST
93939: PUSH
93940: LD_INT 1
93942: NEG
93943: PUSH
93944: LD_INT 0
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 1
93953: NEG
93954: PUSH
93955: LD_INT 1
93957: NEG
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 1
93965: PUSH
93966: LD_INT 1
93968: NEG
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 2
93976: PUSH
93977: LD_INT 0
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 2
93986: PUSH
93987: LD_INT 1
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 2
93996: PUSH
93997: LD_INT 2
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 1
94006: PUSH
94007: LD_INT 2
94009: PUSH
94010: EMPTY
94011: LIST
94012: LIST
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94028: LD_ADDR_VAR 0 50
94032: PUSH
94033: LD_INT 0
94035: PUSH
94036: LD_INT 0
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 0
94045: PUSH
94046: LD_INT 1
94048: NEG
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 1
94056: PUSH
94057: LD_INT 0
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 1
94066: PUSH
94067: LD_INT 1
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 0
94076: PUSH
94077: LD_INT 1
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 1
94086: NEG
94087: PUSH
94088: LD_INT 0
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 1
94097: NEG
94098: PUSH
94099: LD_INT 1
94101: NEG
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 2
94109: PUSH
94110: LD_INT 1
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: PUSH
94117: LD_INT 2
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: PUSH
94127: LD_INT 1
94129: PUSH
94130: LD_INT 2
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 0
94139: PUSH
94140: LD_INT 2
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 1
94149: NEG
94150: PUSH
94151: LD_INT 1
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94172: LD_ADDR_VAR 0 51
94176: PUSH
94177: LD_INT 0
94179: PUSH
94180: LD_INT 0
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 0
94189: PUSH
94190: LD_INT 1
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 1
94200: PUSH
94201: LD_INT 0
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 1
94210: PUSH
94211: LD_INT 1
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 0
94220: PUSH
94221: LD_INT 1
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 1
94230: NEG
94231: PUSH
94232: LD_INT 0
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 1
94241: NEG
94242: PUSH
94243: LD_INT 1
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 1
94253: PUSH
94254: LD_INT 2
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 0
94263: PUSH
94264: LD_INT 2
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 1
94273: NEG
94274: PUSH
94275: LD_INT 1
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 2
94284: NEG
94285: PUSH
94286: LD_INT 0
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 2
94295: NEG
94296: PUSH
94297: LD_INT 1
94299: NEG
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94319: LD_ADDR_VAR 0 52
94323: PUSH
94324: LD_INT 0
94326: PUSH
94327: LD_INT 0
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 0
94336: PUSH
94337: LD_INT 1
94339: NEG
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 1
94347: PUSH
94348: LD_INT 0
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 1
94357: PUSH
94358: LD_INT 1
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 0
94367: PUSH
94368: LD_INT 1
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 1
94377: NEG
94378: PUSH
94379: LD_INT 0
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 1
94388: NEG
94389: PUSH
94390: LD_INT 1
94392: NEG
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 1
94400: NEG
94401: PUSH
94402: LD_INT 2
94404: NEG
94405: PUSH
94406: EMPTY
94407: LIST
94408: LIST
94409: PUSH
94410: LD_INT 1
94412: NEG
94413: PUSH
94414: LD_INT 1
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 2
94423: NEG
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 2
94434: NEG
94435: PUSH
94436: LD_INT 1
94438: NEG
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 2
94446: NEG
94447: PUSH
94448: LD_INT 2
94450: NEG
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94470: LD_ADDR_VAR 0 53
94474: PUSH
94475: LD_INT 0
94477: PUSH
94478: LD_INT 0
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 0
94487: PUSH
94488: LD_INT 1
94490: NEG
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 1
94498: PUSH
94499: LD_INT 0
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 1
94508: PUSH
94509: LD_INT 1
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: LD_INT 1
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 1
94528: NEG
94529: PUSH
94530: LD_INT 0
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 1
94539: NEG
94540: PUSH
94541: LD_INT 1
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 1
94551: NEG
94552: PUSH
94553: LD_INT 2
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 0
94563: PUSH
94564: LD_INT 2
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 1
94574: PUSH
94575: LD_INT 1
94577: NEG
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 2
94585: PUSH
94586: LD_INT 0
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 2
94595: PUSH
94596: LD_INT 1
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 2
94605: PUSH
94606: LD_INT 2
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 1
94615: PUSH
94616: LD_INT 2
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 0
94625: PUSH
94626: LD_INT 2
94628: PUSH
94629: EMPTY
94630: LIST
94631: LIST
94632: PUSH
94633: LD_INT 1
94635: NEG
94636: PUSH
94637: LD_INT 1
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 2
94646: NEG
94647: PUSH
94648: LD_INT 0
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 2
94657: NEG
94658: PUSH
94659: LD_INT 1
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 2
94669: NEG
94670: PUSH
94671: LD_INT 2
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94700: LD_ADDR_VAR 0 54
94704: PUSH
94705: LD_INT 0
94707: PUSH
94708: LD_INT 0
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 0
94717: PUSH
94718: LD_INT 1
94720: NEG
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 1
94728: PUSH
94729: LD_INT 0
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: LD_INT 1
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 0
94748: PUSH
94749: LD_INT 1
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 1
94758: NEG
94759: PUSH
94760: LD_INT 0
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 1
94769: NEG
94770: PUSH
94771: LD_INT 1
94773: NEG
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 1
94781: NEG
94782: PUSH
94783: LD_INT 2
94785: NEG
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: PUSH
94791: LD_INT 0
94793: PUSH
94794: LD_INT 2
94796: NEG
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 1
94804: PUSH
94805: LD_INT 1
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 2
94815: PUSH
94816: LD_INT 0
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 2
94825: PUSH
94826: LD_INT 1
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 2
94835: PUSH
94836: LD_INT 2
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 1
94845: PUSH
94846: LD_INT 2
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 0
94855: PUSH
94856: LD_INT 2
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: PUSH
94863: LD_INT 1
94865: NEG
94866: PUSH
94867: LD_INT 1
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 2
94876: NEG
94877: PUSH
94878: LD_INT 0
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 2
94887: NEG
94888: PUSH
94889: LD_INT 1
94891: NEG
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: PUSH
94897: LD_INT 2
94899: NEG
94900: PUSH
94901: LD_INT 2
94903: NEG
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94930: LD_ADDR_VAR 0 55
94934: PUSH
94935: LD_INT 0
94937: PUSH
94938: LD_INT 0
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 0
94947: PUSH
94948: LD_INT 1
94950: NEG
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 1
94958: PUSH
94959: LD_INT 0
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 1
94968: PUSH
94969: LD_INT 1
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: LD_INT 1
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 1
94988: NEG
94989: PUSH
94990: LD_INT 0
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: LD_INT 1
95003: NEG
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: PUSH
95009: LD_INT 1
95011: NEG
95012: PUSH
95013: LD_INT 2
95015: NEG
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: LD_INT 0
95023: PUSH
95024: LD_INT 2
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 1
95034: PUSH
95035: LD_INT 1
95037: NEG
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 2
95045: PUSH
95046: LD_INT 0
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 2
95055: PUSH
95056: LD_INT 1
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 2
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 1
95075: PUSH
95076: LD_INT 2
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 0
95085: PUSH
95086: LD_INT 2
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 1
95095: NEG
95096: PUSH
95097: LD_INT 1
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 2
95106: NEG
95107: PUSH
95108: LD_INT 0
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 2
95117: NEG
95118: PUSH
95119: LD_INT 1
95121: NEG
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 2
95129: NEG
95130: PUSH
95131: LD_INT 2
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95160: LD_ADDR_VAR 0 56
95164: PUSH
95165: LD_INT 0
95167: PUSH
95168: LD_INT 0
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 0
95177: PUSH
95178: LD_INT 1
95180: NEG
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 1
95188: PUSH
95189: LD_INT 0
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 1
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: LD_INT 0
95208: PUSH
95209: LD_INT 1
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 1
95218: NEG
95219: PUSH
95220: LD_INT 0
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: NEG
95230: PUSH
95231: LD_INT 1
95233: NEG
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 1
95241: NEG
95242: PUSH
95243: LD_INT 2
95245: NEG
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 0
95253: PUSH
95254: LD_INT 2
95256: NEG
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: LD_INT 1
95264: PUSH
95265: LD_INT 1
95267: NEG
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 2
95275: PUSH
95276: LD_INT 0
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 2
95285: PUSH
95286: LD_INT 1
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 2
95295: PUSH
95296: LD_INT 2
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 1
95305: PUSH
95306: LD_INT 2
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 0
95315: PUSH
95316: LD_INT 2
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 1
95325: NEG
95326: PUSH
95327: LD_INT 1
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 2
95336: NEG
95337: PUSH
95338: LD_INT 0
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 2
95347: NEG
95348: PUSH
95349: LD_INT 1
95351: NEG
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 2
95359: NEG
95360: PUSH
95361: LD_INT 2
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: EMPTY
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95390: LD_ADDR_VAR 0 57
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: LD_INT 0
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: PUSH
95405: LD_INT 0
95407: PUSH
95408: LD_INT 1
95410: NEG
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: LD_INT 1
95418: PUSH
95419: LD_INT 0
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 1
95428: PUSH
95429: LD_INT 1
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: PUSH
95436: LD_INT 0
95438: PUSH
95439: LD_INT 1
95441: PUSH
95442: EMPTY
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 1
95448: NEG
95449: PUSH
95450: LD_INT 0
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: LD_INT 1
95463: NEG
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 1
95471: NEG
95472: PUSH
95473: LD_INT 2
95475: NEG
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 0
95483: PUSH
95484: LD_INT 2
95486: NEG
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 1
95494: PUSH
95495: LD_INT 1
95497: NEG
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 2
95505: PUSH
95506: LD_INT 0
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 2
95515: PUSH
95516: LD_INT 1
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 2
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 1
95535: PUSH
95536: LD_INT 2
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 0
95545: PUSH
95546: LD_INT 2
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 1
95555: NEG
95556: PUSH
95557: LD_INT 1
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: LD_INT 2
95566: NEG
95567: PUSH
95568: LD_INT 0
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PUSH
95575: LD_INT 2
95577: NEG
95578: PUSH
95579: LD_INT 1
95581: NEG
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: LD_INT 2
95589: NEG
95590: PUSH
95591: LD_INT 2
95593: NEG
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95620: LD_ADDR_VAR 0 58
95624: PUSH
95625: LD_INT 0
95627: PUSH
95628: LD_INT 0
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 0
95637: PUSH
95638: LD_INT 1
95640: NEG
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 1
95648: PUSH
95649: LD_INT 0
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 1
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 0
95668: PUSH
95669: LD_INT 1
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 1
95678: NEG
95679: PUSH
95680: LD_INT 0
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 1
95689: NEG
95690: PUSH
95691: LD_INT 1
95693: NEG
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 1
95701: NEG
95702: PUSH
95703: LD_INT 2
95705: NEG
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 0
95713: PUSH
95714: LD_INT 2
95716: NEG
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 1
95724: PUSH
95725: LD_INT 1
95727: NEG
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 2
95735: PUSH
95736: LD_INT 0
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: PUSH
95743: LD_INT 2
95745: PUSH
95746: LD_INT 1
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 2
95755: PUSH
95756: LD_INT 2
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PUSH
95763: LD_INT 1
95765: PUSH
95766: LD_INT 2
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 0
95775: PUSH
95776: LD_INT 2
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: LD_INT 1
95785: NEG
95786: PUSH
95787: LD_INT 1
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 2
95796: NEG
95797: PUSH
95798: LD_INT 0
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: LD_INT 1
95811: NEG
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 2
95819: NEG
95820: PUSH
95821: LD_INT 2
95823: NEG
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95850: LD_ADDR_VAR 0 59
95854: PUSH
95855: LD_INT 0
95857: PUSH
95858: LD_INT 0
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 0
95867: PUSH
95868: LD_INT 1
95870: NEG
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: LD_INT 0
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 1
95888: PUSH
95889: LD_INT 1
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 0
95898: PUSH
95899: LD_INT 1
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 1
95908: NEG
95909: PUSH
95910: LD_INT 0
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 1
95919: NEG
95920: PUSH
95921: LD_INT 1
95923: NEG
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95938: LD_ADDR_VAR 0 60
95942: PUSH
95943: LD_INT 0
95945: PUSH
95946: LD_INT 0
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 0
95955: PUSH
95956: LD_INT 1
95958: NEG
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 1
95966: PUSH
95967: LD_INT 0
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 1
95976: PUSH
95977: LD_INT 1
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 0
95986: PUSH
95987: LD_INT 1
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 1
95996: NEG
95997: PUSH
95998: LD_INT 0
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 1
96007: NEG
96008: PUSH
96009: LD_INT 1
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96026: LD_ADDR_VAR 0 61
96030: PUSH
96031: LD_INT 0
96033: PUSH
96034: LD_INT 0
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 0
96043: PUSH
96044: LD_INT 1
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 1
96054: PUSH
96055: LD_INT 0
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 1
96064: PUSH
96065: LD_INT 1
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 0
96074: PUSH
96075: LD_INT 1
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 1
96084: NEG
96085: PUSH
96086: LD_INT 0
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 1
96095: NEG
96096: PUSH
96097: LD_INT 1
96099: NEG
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96114: LD_ADDR_VAR 0 62
96118: PUSH
96119: LD_INT 0
96121: PUSH
96122: LD_INT 0
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 0
96131: PUSH
96132: LD_INT 1
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 1
96142: PUSH
96143: LD_INT 0
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 1
96152: PUSH
96153: LD_INT 1
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 0
96162: PUSH
96163: LD_INT 1
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 1
96172: NEG
96173: PUSH
96174: LD_INT 0
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 1
96183: NEG
96184: PUSH
96185: LD_INT 1
96187: NEG
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96202: LD_ADDR_VAR 0 63
96206: PUSH
96207: LD_INT 0
96209: PUSH
96210: LD_INT 0
96212: PUSH
96213: EMPTY
96214: LIST
96215: LIST
96216: PUSH
96217: LD_INT 0
96219: PUSH
96220: LD_INT 1
96222: NEG
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 1
96230: PUSH
96231: LD_INT 0
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 1
96240: PUSH
96241: LD_INT 1
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 0
96250: PUSH
96251: LD_INT 1
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 1
96260: NEG
96261: PUSH
96262: LD_INT 0
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 1
96271: NEG
96272: PUSH
96273: LD_INT 1
96275: NEG
96276: PUSH
96277: EMPTY
96278: LIST
96279: LIST
96280: PUSH
96281: EMPTY
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96290: LD_ADDR_VAR 0 64
96294: PUSH
96295: LD_INT 0
96297: PUSH
96298: LD_INT 0
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 0
96307: PUSH
96308: LD_INT 1
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: LD_INT 0
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 1
96328: PUSH
96329: LD_INT 1
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 0
96338: PUSH
96339: LD_INT 1
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 1
96348: NEG
96349: PUSH
96350: LD_INT 0
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: PUSH
96357: LD_INT 1
96359: NEG
96360: PUSH
96361: LD_INT 1
96363: NEG
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: ST_TO_ADDR
// end ; 1 :
96378: GO 102275
96380: LD_INT 1
96382: DOUBLE
96383: EQUAL
96384: IFTRUE 96388
96386: GO 99011
96388: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96389: LD_ADDR_VAR 0 11
96393: PUSH
96394: LD_INT 1
96396: NEG
96397: PUSH
96398: LD_INT 3
96400: NEG
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 0
96408: PUSH
96409: LD_INT 3
96411: NEG
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: LD_INT 1
96419: PUSH
96420: LD_INT 2
96422: NEG
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: EMPTY
96429: LIST
96430: LIST
96431: LIST
96432: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96433: LD_ADDR_VAR 0 12
96437: PUSH
96438: LD_INT 2
96440: PUSH
96441: LD_INT 1
96443: NEG
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 3
96451: PUSH
96452: LD_INT 0
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 3
96461: PUSH
96462: LD_INT 1
96464: PUSH
96465: EMPTY
96466: LIST
96467: LIST
96468: PUSH
96469: EMPTY
96470: LIST
96471: LIST
96472: LIST
96473: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96474: LD_ADDR_VAR 0 13
96478: PUSH
96479: LD_INT 3
96481: PUSH
96482: LD_INT 2
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: LD_INT 3
96491: PUSH
96492: LD_INT 3
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: PUSH
96499: LD_INT 2
96501: PUSH
96502: LD_INT 3
96504: PUSH
96505: EMPTY
96506: LIST
96507: LIST
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: LIST
96513: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96514: LD_ADDR_VAR 0 14
96518: PUSH
96519: LD_INT 1
96521: PUSH
96522: LD_INT 3
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 0
96531: PUSH
96532: LD_INT 3
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: LD_INT 2
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: LIST
96554: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96555: LD_ADDR_VAR 0 15
96559: PUSH
96560: LD_INT 2
96562: NEG
96563: PUSH
96564: LD_INT 1
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: LD_INT 3
96573: NEG
96574: PUSH
96575: LD_INT 0
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 3
96584: NEG
96585: PUSH
96586: LD_INT 1
96588: NEG
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: LIST
96598: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96599: LD_ADDR_VAR 0 16
96603: PUSH
96604: LD_INT 2
96606: NEG
96607: PUSH
96608: LD_INT 3
96610: NEG
96611: PUSH
96612: EMPTY
96613: LIST
96614: LIST
96615: PUSH
96616: LD_INT 3
96618: NEG
96619: PUSH
96620: LD_INT 2
96622: NEG
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PUSH
96628: LD_INT 3
96630: NEG
96631: PUSH
96632: LD_INT 3
96634: NEG
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: LIST
96644: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96645: LD_ADDR_VAR 0 17
96649: PUSH
96650: LD_INT 1
96652: NEG
96653: PUSH
96654: LD_INT 3
96656: NEG
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 0
96664: PUSH
96665: LD_INT 3
96667: NEG
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 1
96675: PUSH
96676: LD_INT 2
96678: NEG
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: LIST
96688: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96689: LD_ADDR_VAR 0 18
96693: PUSH
96694: LD_INT 2
96696: PUSH
96697: LD_INT 1
96699: NEG
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 3
96707: PUSH
96708: LD_INT 0
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 3
96717: PUSH
96718: LD_INT 1
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: LIST
96729: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96730: LD_ADDR_VAR 0 19
96734: PUSH
96735: LD_INT 3
96737: PUSH
96738: LD_INT 2
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 3
96747: PUSH
96748: LD_INT 3
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 2
96757: PUSH
96758: LD_INT 3
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: LIST
96769: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96770: LD_ADDR_VAR 0 20
96774: PUSH
96775: LD_INT 1
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 0
96787: PUSH
96788: LD_INT 3
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 1
96797: NEG
96798: PUSH
96799: LD_INT 2
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: LIST
96810: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96811: LD_ADDR_VAR 0 21
96815: PUSH
96816: LD_INT 2
96818: NEG
96819: PUSH
96820: LD_INT 1
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: LD_INT 3
96829: NEG
96830: PUSH
96831: LD_INT 0
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 3
96840: NEG
96841: PUSH
96842: LD_INT 1
96844: NEG
96845: PUSH
96846: EMPTY
96847: LIST
96848: LIST
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: LIST
96854: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96855: LD_ADDR_VAR 0 22
96859: PUSH
96860: LD_INT 2
96862: NEG
96863: PUSH
96864: LD_INT 3
96866: NEG
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: PUSH
96872: LD_INT 3
96874: NEG
96875: PUSH
96876: LD_INT 2
96878: NEG
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: PUSH
96884: LD_INT 3
96886: NEG
96887: PUSH
96888: LD_INT 3
96890: NEG
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: LIST
96900: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96901: LD_ADDR_VAR 0 23
96905: PUSH
96906: LD_INT 0
96908: PUSH
96909: LD_INT 3
96911: NEG
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 1
96919: NEG
96920: PUSH
96921: LD_INT 4
96923: NEG
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PUSH
96929: LD_INT 1
96931: PUSH
96932: LD_INT 3
96934: NEG
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: LIST
96944: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96945: LD_ADDR_VAR 0 24
96949: PUSH
96950: LD_INT 3
96952: PUSH
96953: LD_INT 0
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: PUSH
96960: LD_INT 3
96962: PUSH
96963: LD_INT 1
96965: NEG
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 4
96973: PUSH
96974: LD_INT 1
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: LIST
96985: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96986: LD_ADDR_VAR 0 25
96990: PUSH
96991: LD_INT 3
96993: PUSH
96994: LD_INT 3
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 4
97003: PUSH
97004: LD_INT 3
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: LD_INT 3
97013: PUSH
97014: LD_INT 4
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: LIST
97025: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97026: LD_ADDR_VAR 0 26
97030: PUSH
97031: LD_INT 0
97033: PUSH
97034: LD_INT 3
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 1
97043: PUSH
97044: LD_INT 4
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 1
97053: NEG
97054: PUSH
97055: LD_INT 3
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: LIST
97066: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97067: LD_ADDR_VAR 0 27
97071: PUSH
97072: LD_INT 3
97074: NEG
97075: PUSH
97076: LD_INT 0
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 3
97085: NEG
97086: PUSH
97087: LD_INT 1
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PUSH
97094: LD_INT 4
97096: NEG
97097: PUSH
97098: LD_INT 1
97100: NEG
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: LIST
97110: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
97111: LD_ADDR_VAR 0 28
97115: PUSH
97116: LD_INT 3
97118: NEG
97119: PUSH
97120: LD_INT 3
97122: NEG
97123: PUSH
97124: EMPTY
97125: LIST
97126: LIST
97127: PUSH
97128: LD_INT 3
97130: NEG
97131: PUSH
97132: LD_INT 4
97134: NEG
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 4
97142: NEG
97143: PUSH
97144: LD_INT 3
97146: NEG
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: LIST
97156: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
97157: LD_ADDR_VAR 0 29
97161: PUSH
97162: LD_INT 1
97164: NEG
97165: PUSH
97166: LD_INT 3
97168: NEG
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: PUSH
97174: LD_INT 0
97176: PUSH
97177: LD_INT 3
97179: NEG
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 1
97187: PUSH
97188: LD_INT 2
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 1
97198: NEG
97199: PUSH
97200: LD_INT 4
97202: NEG
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 0
97210: PUSH
97211: LD_INT 4
97213: NEG
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: PUSH
97219: LD_INT 1
97221: PUSH
97222: LD_INT 3
97224: NEG
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 1
97232: NEG
97233: PUSH
97234: LD_INT 5
97236: NEG
97237: PUSH
97238: EMPTY
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 0
97244: PUSH
97245: LD_INT 5
97247: NEG
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PUSH
97253: LD_INT 1
97255: PUSH
97256: LD_INT 4
97258: NEG
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PUSH
97264: LD_INT 1
97266: NEG
97267: PUSH
97268: LD_INT 6
97270: NEG
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 0
97278: PUSH
97279: LD_INT 6
97281: NEG
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 1
97289: PUSH
97290: LD_INT 5
97292: NEG
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
97312: LD_ADDR_VAR 0 30
97316: PUSH
97317: LD_INT 2
97319: PUSH
97320: LD_INT 1
97322: NEG
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 3
97330: PUSH
97331: LD_INT 0
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 3
97340: PUSH
97341: LD_INT 1
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 3
97350: PUSH
97351: LD_INT 1
97353: NEG
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 4
97361: PUSH
97362: LD_INT 0
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 4
97371: PUSH
97372: LD_INT 1
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: PUSH
97379: LD_INT 4
97381: PUSH
97382: LD_INT 1
97384: NEG
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 5
97392: PUSH
97393: LD_INT 0
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PUSH
97400: LD_INT 5
97402: PUSH
97403: LD_INT 1
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: PUSH
97410: LD_INT 5
97412: PUSH
97413: LD_INT 1
97415: NEG
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 6
97423: PUSH
97424: LD_INT 0
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: PUSH
97431: LD_INT 6
97433: PUSH
97434: LD_INT 1
97436: PUSH
97437: EMPTY
97438: LIST
97439: LIST
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
97455: LD_ADDR_VAR 0 31
97459: PUSH
97460: LD_INT 3
97462: PUSH
97463: LD_INT 2
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 3
97472: PUSH
97473: LD_INT 3
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 2
97482: PUSH
97483: LD_INT 3
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 4
97492: PUSH
97493: LD_INT 3
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 4
97502: PUSH
97503: LD_INT 4
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: PUSH
97510: LD_INT 3
97512: PUSH
97513: LD_INT 4
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 5
97522: PUSH
97523: LD_INT 4
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: LD_INT 5
97532: PUSH
97533: LD_INT 5
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: LD_INT 4
97542: PUSH
97543: LD_INT 5
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 6
97552: PUSH
97553: LD_INT 5
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: LD_INT 6
97562: PUSH
97563: LD_INT 6
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 5
97572: PUSH
97573: LD_INT 6
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97594: LD_ADDR_VAR 0 32
97598: PUSH
97599: LD_INT 1
97601: PUSH
97602: LD_INT 3
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: LD_INT 0
97611: PUSH
97612: LD_INT 3
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: PUSH
97619: LD_INT 1
97621: NEG
97622: PUSH
97623: LD_INT 2
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 1
97632: PUSH
97633: LD_INT 4
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 0
97642: PUSH
97643: LD_INT 4
97645: PUSH
97646: EMPTY
97647: LIST
97648: LIST
97649: PUSH
97650: LD_INT 1
97652: NEG
97653: PUSH
97654: LD_INT 3
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 1
97663: PUSH
97664: LD_INT 5
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 0
97673: PUSH
97674: LD_INT 5
97676: PUSH
97677: EMPTY
97678: LIST
97679: LIST
97680: PUSH
97681: LD_INT 1
97683: NEG
97684: PUSH
97685: LD_INT 4
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: LD_INT 1
97694: PUSH
97695: LD_INT 6
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PUSH
97702: LD_INT 0
97704: PUSH
97705: LD_INT 6
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: LD_INT 1
97714: NEG
97715: PUSH
97716: LD_INT 5
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97737: LD_ADDR_VAR 0 33
97741: PUSH
97742: LD_INT 2
97744: NEG
97745: PUSH
97746: LD_INT 1
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: PUSH
97753: LD_INT 3
97755: NEG
97756: PUSH
97757: LD_INT 0
97759: PUSH
97760: EMPTY
97761: LIST
97762: LIST
97763: PUSH
97764: LD_INT 3
97766: NEG
97767: PUSH
97768: LD_INT 1
97770: NEG
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: PUSH
97776: LD_INT 3
97778: NEG
97779: PUSH
97780: LD_INT 1
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: LD_INT 4
97789: NEG
97790: PUSH
97791: LD_INT 0
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 4
97800: NEG
97801: PUSH
97802: LD_INT 1
97804: NEG
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 4
97812: NEG
97813: PUSH
97814: LD_INT 1
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: LD_INT 5
97823: NEG
97824: PUSH
97825: LD_INT 0
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 5
97834: NEG
97835: PUSH
97836: LD_INT 1
97838: NEG
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: PUSH
97844: LD_INT 5
97846: NEG
97847: PUSH
97848: LD_INT 1
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 6
97857: NEG
97858: PUSH
97859: LD_INT 0
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 6
97868: NEG
97869: PUSH
97870: LD_INT 1
97872: NEG
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: EMPTY
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97892: LD_ADDR_VAR 0 34
97896: PUSH
97897: LD_INT 2
97899: NEG
97900: PUSH
97901: LD_INT 3
97903: NEG
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: PUSH
97909: LD_INT 3
97911: NEG
97912: PUSH
97913: LD_INT 2
97915: NEG
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PUSH
97921: LD_INT 3
97923: NEG
97924: PUSH
97925: LD_INT 3
97927: NEG
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: LD_INT 3
97935: NEG
97936: PUSH
97937: LD_INT 4
97939: NEG
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: PUSH
97945: LD_INT 4
97947: NEG
97948: PUSH
97949: LD_INT 3
97951: NEG
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 4
97959: NEG
97960: PUSH
97961: LD_INT 4
97963: NEG
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PUSH
97969: LD_INT 4
97971: NEG
97972: PUSH
97973: LD_INT 5
97975: NEG
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 5
97983: NEG
97984: PUSH
97985: LD_INT 4
97987: NEG
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: LD_INT 5
97995: NEG
97996: PUSH
97997: LD_INT 5
97999: NEG
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: LD_INT 5
98007: NEG
98008: PUSH
98009: LD_INT 6
98011: NEG
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: LD_INT 6
98019: NEG
98020: PUSH
98021: LD_INT 5
98023: NEG
98024: PUSH
98025: EMPTY
98026: LIST
98027: LIST
98028: PUSH
98029: LD_INT 6
98031: NEG
98032: PUSH
98033: LD_INT 6
98035: NEG
98036: PUSH
98037: EMPTY
98038: LIST
98039: LIST
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98055: LD_ADDR_VAR 0 41
98059: PUSH
98060: LD_INT 0
98062: PUSH
98063: LD_INT 2
98065: NEG
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: PUSH
98071: LD_INT 1
98073: NEG
98074: PUSH
98075: LD_INT 3
98077: NEG
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: LD_INT 1
98085: PUSH
98086: LD_INT 2
98088: NEG
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: EMPTY
98095: LIST
98096: LIST
98097: LIST
98098: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
98099: LD_ADDR_VAR 0 42
98103: PUSH
98104: LD_INT 2
98106: PUSH
98107: LD_INT 0
98109: PUSH
98110: EMPTY
98111: LIST
98112: LIST
98113: PUSH
98114: LD_INT 2
98116: PUSH
98117: LD_INT 1
98119: NEG
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: PUSH
98125: LD_INT 3
98127: PUSH
98128: LD_INT 1
98130: PUSH
98131: EMPTY
98132: LIST
98133: LIST
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: LIST
98139: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
98140: LD_ADDR_VAR 0 43
98144: PUSH
98145: LD_INT 2
98147: PUSH
98148: LD_INT 2
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 3
98157: PUSH
98158: LD_INT 2
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: PUSH
98165: LD_INT 2
98167: PUSH
98168: LD_INT 3
98170: PUSH
98171: EMPTY
98172: LIST
98173: LIST
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: LIST
98179: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
98180: LD_ADDR_VAR 0 44
98184: PUSH
98185: LD_INT 0
98187: PUSH
98188: LD_INT 2
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 1
98197: PUSH
98198: LD_INT 3
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: LD_INT 1
98207: NEG
98208: PUSH
98209: LD_INT 2
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: LIST
98220: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
98221: LD_ADDR_VAR 0 45
98225: PUSH
98226: LD_INT 2
98228: NEG
98229: PUSH
98230: LD_INT 0
98232: PUSH
98233: EMPTY
98234: LIST
98235: LIST
98236: PUSH
98237: LD_INT 2
98239: NEG
98240: PUSH
98241: LD_INT 1
98243: PUSH
98244: EMPTY
98245: LIST
98246: LIST
98247: PUSH
98248: LD_INT 3
98250: NEG
98251: PUSH
98252: LD_INT 1
98254: NEG
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PUSH
98260: EMPTY
98261: LIST
98262: LIST
98263: LIST
98264: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
98265: LD_ADDR_VAR 0 46
98269: PUSH
98270: LD_INT 2
98272: NEG
98273: PUSH
98274: LD_INT 2
98276: NEG
98277: PUSH
98278: EMPTY
98279: LIST
98280: LIST
98281: PUSH
98282: LD_INT 2
98284: NEG
98285: PUSH
98286: LD_INT 3
98288: NEG
98289: PUSH
98290: EMPTY
98291: LIST
98292: LIST
98293: PUSH
98294: LD_INT 3
98296: NEG
98297: PUSH
98298: LD_INT 2
98300: NEG
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: PUSH
98306: EMPTY
98307: LIST
98308: LIST
98309: LIST
98310: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
98311: LD_ADDR_VAR 0 47
98315: PUSH
98316: LD_INT 2
98318: NEG
98319: PUSH
98320: LD_INT 3
98322: NEG
98323: PUSH
98324: EMPTY
98325: LIST
98326: LIST
98327: PUSH
98328: LD_INT 1
98330: NEG
98331: PUSH
98332: LD_INT 3
98334: NEG
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
98344: LD_ADDR_VAR 0 48
98348: PUSH
98349: LD_INT 1
98351: PUSH
98352: LD_INT 2
98354: NEG
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 2
98362: PUSH
98363: LD_INT 1
98365: NEG
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
98375: LD_ADDR_VAR 0 49
98379: PUSH
98380: LD_INT 3
98382: PUSH
98383: LD_INT 1
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 3
98392: PUSH
98393: LD_INT 2
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
98404: LD_ADDR_VAR 0 50
98408: PUSH
98409: LD_INT 2
98411: PUSH
98412: LD_INT 3
98414: PUSH
98415: EMPTY
98416: LIST
98417: LIST
98418: PUSH
98419: LD_INT 1
98421: PUSH
98422: LD_INT 3
98424: PUSH
98425: EMPTY
98426: LIST
98427: LIST
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
98433: LD_ADDR_VAR 0 51
98437: PUSH
98438: LD_INT 1
98440: NEG
98441: PUSH
98442: LD_INT 2
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 2
98451: NEG
98452: PUSH
98453: LD_INT 1
98455: PUSH
98456: EMPTY
98457: LIST
98458: LIST
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
98464: LD_ADDR_VAR 0 52
98468: PUSH
98469: LD_INT 3
98471: NEG
98472: PUSH
98473: LD_INT 1
98475: NEG
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: LD_INT 3
98483: NEG
98484: PUSH
98485: LD_INT 2
98487: NEG
98488: PUSH
98489: EMPTY
98490: LIST
98491: LIST
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
98497: LD_ADDR_VAR 0 53
98501: PUSH
98502: LD_INT 1
98504: NEG
98505: PUSH
98506: LD_INT 3
98508: NEG
98509: PUSH
98510: EMPTY
98511: LIST
98512: LIST
98513: PUSH
98514: LD_INT 0
98516: PUSH
98517: LD_INT 3
98519: NEG
98520: PUSH
98521: EMPTY
98522: LIST
98523: LIST
98524: PUSH
98525: LD_INT 1
98527: PUSH
98528: LD_INT 2
98530: NEG
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: EMPTY
98537: LIST
98538: LIST
98539: LIST
98540: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
98541: LD_ADDR_VAR 0 54
98545: PUSH
98546: LD_INT 2
98548: PUSH
98549: LD_INT 1
98551: NEG
98552: PUSH
98553: EMPTY
98554: LIST
98555: LIST
98556: PUSH
98557: LD_INT 3
98559: PUSH
98560: LD_INT 0
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 3
98569: PUSH
98570: LD_INT 1
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PUSH
98577: EMPTY
98578: LIST
98579: LIST
98580: LIST
98581: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98582: LD_ADDR_VAR 0 55
98586: PUSH
98587: LD_INT 3
98589: PUSH
98590: LD_INT 2
98592: PUSH
98593: EMPTY
98594: LIST
98595: LIST
98596: PUSH
98597: LD_INT 3
98599: PUSH
98600: LD_INT 3
98602: PUSH
98603: EMPTY
98604: LIST
98605: LIST
98606: PUSH
98607: LD_INT 2
98609: PUSH
98610: LD_INT 3
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: LIST
98621: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98622: LD_ADDR_VAR 0 56
98626: PUSH
98627: LD_INT 1
98629: PUSH
98630: LD_INT 3
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_INT 0
98639: PUSH
98640: LD_INT 3
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PUSH
98647: LD_INT 1
98649: NEG
98650: PUSH
98651: LD_INT 2
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: LIST
98662: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98663: LD_ADDR_VAR 0 57
98667: PUSH
98668: LD_INT 2
98670: NEG
98671: PUSH
98672: LD_INT 1
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: PUSH
98679: LD_INT 3
98681: NEG
98682: PUSH
98683: LD_INT 0
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 3
98692: NEG
98693: PUSH
98694: LD_INT 1
98696: NEG
98697: PUSH
98698: EMPTY
98699: LIST
98700: LIST
98701: PUSH
98702: EMPTY
98703: LIST
98704: LIST
98705: LIST
98706: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98707: LD_ADDR_VAR 0 58
98711: PUSH
98712: LD_INT 2
98714: NEG
98715: PUSH
98716: LD_INT 3
98718: NEG
98719: PUSH
98720: EMPTY
98721: LIST
98722: LIST
98723: PUSH
98724: LD_INT 3
98726: NEG
98727: PUSH
98728: LD_INT 2
98730: NEG
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 3
98738: NEG
98739: PUSH
98740: LD_INT 3
98742: NEG
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: EMPTY
98749: LIST
98750: LIST
98751: LIST
98752: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98753: LD_ADDR_VAR 0 59
98757: PUSH
98758: LD_INT 1
98760: NEG
98761: PUSH
98762: LD_INT 2
98764: NEG
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: PUSH
98770: LD_INT 0
98772: PUSH
98773: LD_INT 2
98775: NEG
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_INT 1
98783: PUSH
98784: LD_INT 1
98786: NEG
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: PUSH
98792: EMPTY
98793: LIST
98794: LIST
98795: LIST
98796: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98797: LD_ADDR_VAR 0 60
98801: PUSH
98802: LD_INT 1
98804: PUSH
98805: LD_INT 1
98807: NEG
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: LD_INT 2
98815: PUSH
98816: LD_INT 0
98818: PUSH
98819: EMPTY
98820: LIST
98821: LIST
98822: PUSH
98823: LD_INT 2
98825: PUSH
98826: LD_INT 1
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: LIST
98837: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98838: LD_ADDR_VAR 0 61
98842: PUSH
98843: LD_INT 2
98845: PUSH
98846: LD_INT 1
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: LD_INT 2
98855: PUSH
98856: LD_INT 2
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 1
98865: PUSH
98866: LD_INT 2
98868: PUSH
98869: EMPTY
98870: LIST
98871: LIST
98872: PUSH
98873: EMPTY
98874: LIST
98875: LIST
98876: LIST
98877: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98878: LD_ADDR_VAR 0 62
98882: PUSH
98883: LD_INT 1
98885: PUSH
98886: LD_INT 2
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: PUSH
98893: LD_INT 0
98895: PUSH
98896: LD_INT 2
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PUSH
98903: LD_INT 1
98905: NEG
98906: PUSH
98907: LD_INT 1
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: LIST
98918: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98919: LD_ADDR_VAR 0 63
98923: PUSH
98924: LD_INT 1
98926: NEG
98927: PUSH
98928: LD_INT 1
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 2
98937: NEG
98938: PUSH
98939: LD_INT 0
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 2
98948: NEG
98949: PUSH
98950: LD_INT 1
98952: NEG
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: LIST
98962: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98963: LD_ADDR_VAR 0 64
98967: PUSH
98968: LD_INT 1
98970: NEG
98971: PUSH
98972: LD_INT 2
98974: NEG
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: PUSH
98980: LD_INT 2
98982: NEG
98983: PUSH
98984: LD_INT 1
98986: NEG
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: PUSH
98992: LD_INT 2
98994: NEG
98995: PUSH
98996: LD_INT 2
98998: NEG
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: LIST
99008: ST_TO_ADDR
// end ; 2 :
99009: GO 102275
99011: LD_INT 2
99013: DOUBLE
99014: EQUAL
99015: IFTRUE 99019
99017: GO 102274
99019: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99020: LD_ADDR_VAR 0 29
99024: PUSH
99025: LD_INT 4
99027: PUSH
99028: LD_INT 0
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: PUSH
99035: LD_INT 4
99037: PUSH
99038: LD_INT 1
99040: NEG
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 5
99048: PUSH
99049: LD_INT 0
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 5
99058: PUSH
99059: LD_INT 1
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 4
99068: PUSH
99069: LD_INT 1
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 3
99078: PUSH
99079: LD_INT 0
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: PUSH
99086: LD_INT 3
99088: PUSH
99089: LD_INT 1
99091: NEG
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: PUSH
99097: LD_INT 3
99099: PUSH
99100: LD_INT 2
99102: NEG
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 5
99110: PUSH
99111: LD_INT 2
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 3
99120: PUSH
99121: LD_INT 3
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PUSH
99128: LD_INT 3
99130: PUSH
99131: LD_INT 2
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 4
99140: PUSH
99141: LD_INT 3
99143: PUSH
99144: EMPTY
99145: LIST
99146: LIST
99147: PUSH
99148: LD_INT 4
99150: PUSH
99151: LD_INT 4
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PUSH
99158: LD_INT 3
99160: PUSH
99161: LD_INT 4
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PUSH
99168: LD_INT 2
99170: PUSH
99171: LD_INT 3
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PUSH
99178: LD_INT 2
99180: PUSH
99181: LD_INT 2
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 4
99190: PUSH
99191: LD_INT 2
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: LD_INT 2
99200: PUSH
99201: LD_INT 4
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 0
99210: PUSH
99211: LD_INT 4
99213: PUSH
99214: EMPTY
99215: LIST
99216: LIST
99217: PUSH
99218: LD_INT 0
99220: PUSH
99221: LD_INT 3
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: PUSH
99228: LD_INT 1
99230: PUSH
99231: LD_INT 4
99233: PUSH
99234: EMPTY
99235: LIST
99236: LIST
99237: PUSH
99238: LD_INT 1
99240: PUSH
99241: LD_INT 5
99243: PUSH
99244: EMPTY
99245: LIST
99246: LIST
99247: PUSH
99248: LD_INT 0
99250: PUSH
99251: LD_INT 5
99253: PUSH
99254: EMPTY
99255: LIST
99256: LIST
99257: PUSH
99258: LD_INT 1
99260: NEG
99261: PUSH
99262: LD_INT 4
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: PUSH
99269: LD_INT 1
99271: NEG
99272: PUSH
99273: LD_INT 3
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 2
99282: PUSH
99283: LD_INT 5
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: PUSH
99290: LD_INT 2
99292: NEG
99293: PUSH
99294: LD_INT 3
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: PUSH
99301: LD_INT 3
99303: NEG
99304: PUSH
99305: LD_INT 0
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 3
99314: NEG
99315: PUSH
99316: LD_INT 1
99318: NEG
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_INT 2
99326: NEG
99327: PUSH
99328: LD_INT 0
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: LD_INT 2
99337: NEG
99338: PUSH
99339: LD_INT 1
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: PUSH
99346: LD_INT 3
99348: NEG
99349: PUSH
99350: LD_INT 1
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: PUSH
99357: LD_INT 4
99359: NEG
99360: PUSH
99361: LD_INT 0
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: PUSH
99368: LD_INT 4
99370: NEG
99371: PUSH
99372: LD_INT 1
99374: NEG
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PUSH
99380: LD_INT 4
99382: NEG
99383: PUSH
99384: LD_INT 2
99386: NEG
99387: PUSH
99388: EMPTY
99389: LIST
99390: LIST
99391: PUSH
99392: LD_INT 2
99394: NEG
99395: PUSH
99396: LD_INT 2
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: LD_INT 4
99405: NEG
99406: PUSH
99407: LD_INT 4
99409: NEG
99410: PUSH
99411: EMPTY
99412: LIST
99413: LIST
99414: PUSH
99415: LD_INT 4
99417: NEG
99418: PUSH
99419: LD_INT 5
99421: NEG
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: PUSH
99427: LD_INT 3
99429: NEG
99430: PUSH
99431: LD_INT 4
99433: NEG
99434: PUSH
99435: EMPTY
99436: LIST
99437: LIST
99438: PUSH
99439: LD_INT 3
99441: NEG
99442: PUSH
99443: LD_INT 3
99445: NEG
99446: PUSH
99447: EMPTY
99448: LIST
99449: LIST
99450: PUSH
99451: LD_INT 4
99453: NEG
99454: PUSH
99455: LD_INT 3
99457: NEG
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: PUSH
99463: LD_INT 5
99465: NEG
99466: PUSH
99467: LD_INT 4
99469: NEG
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: PUSH
99475: LD_INT 5
99477: NEG
99478: PUSH
99479: LD_INT 5
99481: NEG
99482: PUSH
99483: EMPTY
99484: LIST
99485: LIST
99486: PUSH
99487: LD_INT 3
99489: NEG
99490: PUSH
99491: LD_INT 5
99493: NEG
99494: PUSH
99495: EMPTY
99496: LIST
99497: LIST
99498: PUSH
99499: LD_INT 5
99501: NEG
99502: PUSH
99503: LD_INT 3
99505: NEG
99506: PUSH
99507: EMPTY
99508: LIST
99509: LIST
99510: PUSH
99511: EMPTY
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
99558: LD_ADDR_VAR 0 30
99562: PUSH
99563: LD_INT 4
99565: PUSH
99566: LD_INT 4
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: PUSH
99573: LD_INT 4
99575: PUSH
99576: LD_INT 3
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: PUSH
99583: LD_INT 5
99585: PUSH
99586: LD_INT 4
99588: PUSH
99589: EMPTY
99590: LIST
99591: LIST
99592: PUSH
99593: LD_INT 5
99595: PUSH
99596: LD_INT 5
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: PUSH
99603: LD_INT 4
99605: PUSH
99606: LD_INT 5
99608: PUSH
99609: EMPTY
99610: LIST
99611: LIST
99612: PUSH
99613: LD_INT 3
99615: PUSH
99616: LD_INT 4
99618: PUSH
99619: EMPTY
99620: LIST
99621: LIST
99622: PUSH
99623: LD_INT 3
99625: PUSH
99626: LD_INT 3
99628: PUSH
99629: EMPTY
99630: LIST
99631: LIST
99632: PUSH
99633: LD_INT 5
99635: PUSH
99636: LD_INT 3
99638: PUSH
99639: EMPTY
99640: LIST
99641: LIST
99642: PUSH
99643: LD_INT 3
99645: PUSH
99646: LD_INT 5
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: PUSH
99653: LD_INT 0
99655: PUSH
99656: LD_INT 3
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: PUSH
99663: LD_INT 0
99665: PUSH
99666: LD_INT 2
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: PUSH
99673: LD_INT 1
99675: PUSH
99676: LD_INT 3
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PUSH
99683: LD_INT 1
99685: PUSH
99686: LD_INT 4
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: LD_INT 0
99695: PUSH
99696: LD_INT 4
99698: PUSH
99699: EMPTY
99700: LIST
99701: LIST
99702: PUSH
99703: LD_INT 1
99705: NEG
99706: PUSH
99707: LD_INT 3
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: PUSH
99714: LD_INT 1
99716: NEG
99717: PUSH
99718: LD_INT 2
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 2
99727: PUSH
99728: LD_INT 4
99730: PUSH
99731: EMPTY
99732: LIST
99733: LIST
99734: PUSH
99735: LD_INT 2
99737: NEG
99738: PUSH
99739: LD_INT 2
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: PUSH
99746: LD_INT 4
99748: NEG
99749: PUSH
99750: LD_INT 0
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PUSH
99757: LD_INT 4
99759: NEG
99760: PUSH
99761: LD_INT 1
99763: NEG
99764: PUSH
99765: EMPTY
99766: LIST
99767: LIST
99768: PUSH
99769: LD_INT 3
99771: NEG
99772: PUSH
99773: LD_INT 0
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: LD_INT 3
99782: NEG
99783: PUSH
99784: LD_INT 1
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 4
99793: NEG
99794: PUSH
99795: LD_INT 1
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: PUSH
99802: LD_INT 5
99804: NEG
99805: PUSH
99806: LD_INT 0
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 5
99815: NEG
99816: PUSH
99817: LD_INT 1
99819: NEG
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: PUSH
99825: LD_INT 5
99827: NEG
99828: PUSH
99829: LD_INT 2
99831: NEG
99832: PUSH
99833: EMPTY
99834: LIST
99835: LIST
99836: PUSH
99837: LD_INT 3
99839: NEG
99840: PUSH
99841: LD_INT 2
99843: PUSH
99844: EMPTY
99845: LIST
99846: LIST
99847: PUSH
99848: LD_INT 3
99850: NEG
99851: PUSH
99852: LD_INT 3
99854: NEG
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 3
99862: NEG
99863: PUSH
99864: LD_INT 4
99866: NEG
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: PUSH
99872: LD_INT 2
99874: NEG
99875: PUSH
99876: LD_INT 3
99878: NEG
99879: PUSH
99880: EMPTY
99881: LIST
99882: LIST
99883: PUSH
99884: LD_INT 2
99886: NEG
99887: PUSH
99888: LD_INT 2
99890: NEG
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PUSH
99896: LD_INT 3
99898: NEG
99899: PUSH
99900: LD_INT 2
99902: NEG
99903: PUSH
99904: EMPTY
99905: LIST
99906: LIST
99907: PUSH
99908: LD_INT 4
99910: NEG
99911: PUSH
99912: LD_INT 3
99914: NEG
99915: PUSH
99916: EMPTY
99917: LIST
99918: LIST
99919: PUSH
99920: LD_INT 4
99922: NEG
99923: PUSH
99924: LD_INT 4
99926: NEG
99927: PUSH
99928: EMPTY
99929: LIST
99930: LIST
99931: PUSH
99932: LD_INT 2
99934: NEG
99935: PUSH
99936: LD_INT 4
99938: NEG
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PUSH
99944: LD_INT 4
99946: NEG
99947: PUSH
99948: LD_INT 2
99950: NEG
99951: PUSH
99952: EMPTY
99953: LIST
99954: LIST
99955: PUSH
99956: LD_INT 0
99958: PUSH
99959: LD_INT 4
99961: NEG
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PUSH
99967: LD_INT 0
99969: PUSH
99970: LD_INT 5
99972: NEG
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PUSH
99978: LD_INT 1
99980: PUSH
99981: LD_INT 4
99983: NEG
99984: PUSH
99985: EMPTY
99986: LIST
99987: LIST
99988: PUSH
99989: LD_INT 1
99991: PUSH
99992: LD_INT 3
99994: NEG
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: PUSH
100000: LD_INT 0
100002: PUSH
100003: LD_INT 3
100005: NEG
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: LD_INT 1
100013: NEG
100014: PUSH
100015: LD_INT 4
100017: NEG
100018: PUSH
100019: EMPTY
100020: LIST
100021: LIST
100022: PUSH
100023: LD_INT 1
100025: NEG
100026: PUSH
100027: LD_INT 5
100029: NEG
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PUSH
100035: LD_INT 2
100037: PUSH
100038: LD_INT 3
100040: NEG
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 2
100048: NEG
100049: PUSH
100050: LD_INT 5
100052: NEG
100053: PUSH
100054: EMPTY
100055: LIST
100056: LIST
100057: PUSH
100058: EMPTY
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
100105: LD_ADDR_VAR 0 31
100109: PUSH
100110: LD_INT 0
100112: PUSH
100113: LD_INT 4
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PUSH
100120: LD_INT 0
100122: PUSH
100123: LD_INT 3
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: PUSH
100130: LD_INT 1
100132: PUSH
100133: LD_INT 4
100135: PUSH
100136: EMPTY
100137: LIST
100138: LIST
100139: PUSH
100140: LD_INT 1
100142: PUSH
100143: LD_INT 5
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: PUSH
100150: LD_INT 0
100152: PUSH
100153: LD_INT 5
100155: PUSH
100156: EMPTY
100157: LIST
100158: LIST
100159: PUSH
100160: LD_INT 1
100162: NEG
100163: PUSH
100164: LD_INT 4
100166: PUSH
100167: EMPTY
100168: LIST
100169: LIST
100170: PUSH
100171: LD_INT 1
100173: NEG
100174: PUSH
100175: LD_INT 3
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PUSH
100182: LD_INT 2
100184: PUSH
100185: LD_INT 5
100187: PUSH
100188: EMPTY
100189: LIST
100190: LIST
100191: PUSH
100192: LD_INT 2
100194: NEG
100195: PUSH
100196: LD_INT 3
100198: PUSH
100199: EMPTY
100200: LIST
100201: LIST
100202: PUSH
100203: LD_INT 3
100205: NEG
100206: PUSH
100207: LD_INT 0
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: PUSH
100214: LD_INT 3
100216: NEG
100217: PUSH
100218: LD_INT 1
100220: NEG
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: PUSH
100226: LD_INT 2
100228: NEG
100229: PUSH
100230: LD_INT 0
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: LD_INT 2
100239: NEG
100240: PUSH
100241: LD_INT 1
100243: PUSH
100244: EMPTY
100245: LIST
100246: LIST
100247: PUSH
100248: LD_INT 3
100250: NEG
100251: PUSH
100252: LD_INT 1
100254: PUSH
100255: EMPTY
100256: LIST
100257: LIST
100258: PUSH
100259: LD_INT 4
100261: NEG
100262: PUSH
100263: LD_INT 0
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PUSH
100270: LD_INT 4
100272: NEG
100273: PUSH
100274: LD_INT 1
100276: NEG
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: PUSH
100282: LD_INT 4
100284: NEG
100285: PUSH
100286: LD_INT 2
100288: NEG
100289: PUSH
100290: EMPTY
100291: LIST
100292: LIST
100293: PUSH
100294: LD_INT 2
100296: NEG
100297: PUSH
100298: LD_INT 2
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 4
100307: NEG
100308: PUSH
100309: LD_INT 4
100311: NEG
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: LD_INT 4
100319: NEG
100320: PUSH
100321: LD_INT 5
100323: NEG
100324: PUSH
100325: EMPTY
100326: LIST
100327: LIST
100328: PUSH
100329: LD_INT 3
100331: NEG
100332: PUSH
100333: LD_INT 4
100335: NEG
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: LD_INT 3
100343: NEG
100344: PUSH
100345: LD_INT 3
100347: NEG
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PUSH
100353: LD_INT 4
100355: NEG
100356: PUSH
100357: LD_INT 3
100359: NEG
100360: PUSH
100361: EMPTY
100362: LIST
100363: LIST
100364: PUSH
100365: LD_INT 5
100367: NEG
100368: PUSH
100369: LD_INT 4
100371: NEG
100372: PUSH
100373: EMPTY
100374: LIST
100375: LIST
100376: PUSH
100377: LD_INT 5
100379: NEG
100380: PUSH
100381: LD_INT 5
100383: NEG
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 3
100391: NEG
100392: PUSH
100393: LD_INT 5
100395: NEG
100396: PUSH
100397: EMPTY
100398: LIST
100399: LIST
100400: PUSH
100401: LD_INT 5
100403: NEG
100404: PUSH
100405: LD_INT 3
100407: NEG
100408: PUSH
100409: EMPTY
100410: LIST
100411: LIST
100412: PUSH
100413: LD_INT 0
100415: PUSH
100416: LD_INT 3
100418: NEG
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: LD_INT 0
100426: PUSH
100427: LD_INT 4
100429: NEG
100430: PUSH
100431: EMPTY
100432: LIST
100433: LIST
100434: PUSH
100435: LD_INT 1
100437: PUSH
100438: LD_INT 3
100440: NEG
100441: PUSH
100442: EMPTY
100443: LIST
100444: LIST
100445: PUSH
100446: LD_INT 1
100448: PUSH
100449: LD_INT 2
100451: NEG
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: PUSH
100457: LD_INT 0
100459: PUSH
100460: LD_INT 2
100462: NEG
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: PUSH
100468: LD_INT 1
100470: NEG
100471: PUSH
100472: LD_INT 3
100474: NEG
100475: PUSH
100476: EMPTY
100477: LIST
100478: LIST
100479: PUSH
100480: LD_INT 1
100482: NEG
100483: PUSH
100484: LD_INT 4
100486: NEG
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: PUSH
100492: LD_INT 2
100494: PUSH
100495: LD_INT 2
100497: NEG
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: PUSH
100503: LD_INT 2
100505: NEG
100506: PUSH
100507: LD_INT 4
100509: NEG
100510: PUSH
100511: EMPTY
100512: LIST
100513: LIST
100514: PUSH
100515: LD_INT 4
100517: PUSH
100518: LD_INT 0
100520: PUSH
100521: EMPTY
100522: LIST
100523: LIST
100524: PUSH
100525: LD_INT 4
100527: PUSH
100528: LD_INT 1
100530: NEG
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: PUSH
100536: LD_INT 5
100538: PUSH
100539: LD_INT 0
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: PUSH
100546: LD_INT 5
100548: PUSH
100549: LD_INT 1
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PUSH
100556: LD_INT 4
100558: PUSH
100559: LD_INT 1
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PUSH
100566: LD_INT 3
100568: PUSH
100569: LD_INT 0
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: PUSH
100576: LD_INT 3
100578: PUSH
100579: LD_INT 1
100581: NEG
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PUSH
100587: LD_INT 3
100589: PUSH
100590: LD_INT 2
100592: NEG
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: LD_INT 5
100600: PUSH
100601: LD_INT 2
100603: PUSH
100604: EMPTY
100605: LIST
100606: LIST
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: LIST
100615: LIST
100616: LIST
100617: LIST
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100655: LD_ADDR_VAR 0 32
100659: PUSH
100660: LD_INT 4
100662: NEG
100663: PUSH
100664: LD_INT 0
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: PUSH
100671: LD_INT 4
100673: NEG
100674: PUSH
100675: LD_INT 1
100677: NEG
100678: PUSH
100679: EMPTY
100680: LIST
100681: LIST
100682: PUSH
100683: LD_INT 3
100685: NEG
100686: PUSH
100687: LD_INT 0
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 3
100696: NEG
100697: PUSH
100698: LD_INT 1
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: PUSH
100705: LD_INT 4
100707: NEG
100708: PUSH
100709: LD_INT 1
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: LD_INT 5
100718: NEG
100719: PUSH
100720: LD_INT 0
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 5
100729: NEG
100730: PUSH
100731: LD_INT 1
100733: NEG
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 5
100741: NEG
100742: PUSH
100743: LD_INT 2
100745: NEG
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: LD_INT 3
100753: NEG
100754: PUSH
100755: LD_INT 2
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 3
100764: NEG
100765: PUSH
100766: LD_INT 3
100768: NEG
100769: PUSH
100770: EMPTY
100771: LIST
100772: LIST
100773: PUSH
100774: LD_INT 3
100776: NEG
100777: PUSH
100778: LD_INT 4
100780: NEG
100781: PUSH
100782: EMPTY
100783: LIST
100784: LIST
100785: PUSH
100786: LD_INT 2
100788: NEG
100789: PUSH
100790: LD_INT 3
100792: NEG
100793: PUSH
100794: EMPTY
100795: LIST
100796: LIST
100797: PUSH
100798: LD_INT 2
100800: NEG
100801: PUSH
100802: LD_INT 2
100804: NEG
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: PUSH
100810: LD_INT 3
100812: NEG
100813: PUSH
100814: LD_INT 2
100816: NEG
100817: PUSH
100818: EMPTY
100819: LIST
100820: LIST
100821: PUSH
100822: LD_INT 4
100824: NEG
100825: PUSH
100826: LD_INT 3
100828: NEG
100829: PUSH
100830: EMPTY
100831: LIST
100832: LIST
100833: PUSH
100834: LD_INT 4
100836: NEG
100837: PUSH
100838: LD_INT 4
100840: NEG
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: PUSH
100846: LD_INT 2
100848: NEG
100849: PUSH
100850: LD_INT 4
100852: NEG
100853: PUSH
100854: EMPTY
100855: LIST
100856: LIST
100857: PUSH
100858: LD_INT 4
100860: NEG
100861: PUSH
100862: LD_INT 2
100864: NEG
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: PUSH
100870: LD_INT 0
100872: PUSH
100873: LD_INT 4
100875: NEG
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: PUSH
100881: LD_INT 0
100883: PUSH
100884: LD_INT 5
100886: NEG
100887: PUSH
100888: EMPTY
100889: LIST
100890: LIST
100891: PUSH
100892: LD_INT 1
100894: PUSH
100895: LD_INT 4
100897: NEG
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 1
100905: PUSH
100906: LD_INT 3
100908: NEG
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 0
100916: PUSH
100917: LD_INT 3
100919: NEG
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PUSH
100925: LD_INT 1
100927: NEG
100928: PUSH
100929: LD_INT 4
100931: NEG
100932: PUSH
100933: EMPTY
100934: LIST
100935: LIST
100936: PUSH
100937: LD_INT 1
100939: NEG
100940: PUSH
100941: LD_INT 5
100943: NEG
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: PUSH
100949: LD_INT 2
100951: PUSH
100952: LD_INT 3
100954: NEG
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: PUSH
100960: LD_INT 2
100962: NEG
100963: PUSH
100964: LD_INT 5
100966: NEG
100967: PUSH
100968: EMPTY
100969: LIST
100970: LIST
100971: PUSH
100972: LD_INT 3
100974: PUSH
100975: LD_INT 0
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PUSH
100982: LD_INT 3
100984: PUSH
100985: LD_INT 1
100987: NEG
100988: PUSH
100989: EMPTY
100990: LIST
100991: LIST
100992: PUSH
100993: LD_INT 4
100995: PUSH
100996: LD_INT 0
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 4
101005: PUSH
101006: LD_INT 1
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: LD_INT 3
101015: PUSH
101016: LD_INT 1
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: PUSH
101023: LD_INT 2
101025: PUSH
101026: LD_INT 0
101028: PUSH
101029: EMPTY
101030: LIST
101031: LIST
101032: PUSH
101033: LD_INT 2
101035: PUSH
101036: LD_INT 1
101038: NEG
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PUSH
101044: LD_INT 2
101046: PUSH
101047: LD_INT 2
101049: NEG
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: PUSH
101055: LD_INT 4
101057: PUSH
101058: LD_INT 2
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: PUSH
101065: LD_INT 4
101067: PUSH
101068: LD_INT 4
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: PUSH
101075: LD_INT 4
101077: PUSH
101078: LD_INT 3
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: PUSH
101085: LD_INT 5
101087: PUSH
101088: LD_INT 4
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PUSH
101095: LD_INT 5
101097: PUSH
101098: LD_INT 5
101100: PUSH
101101: EMPTY
101102: LIST
101103: LIST
101104: PUSH
101105: LD_INT 4
101107: PUSH
101108: LD_INT 5
101110: PUSH
101111: EMPTY
101112: LIST
101113: LIST
101114: PUSH
101115: LD_INT 3
101117: PUSH
101118: LD_INT 4
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PUSH
101125: LD_INT 3
101127: PUSH
101128: LD_INT 3
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: LD_INT 5
101137: PUSH
101138: LD_INT 3
101140: PUSH
101141: EMPTY
101142: LIST
101143: LIST
101144: PUSH
101145: LD_INT 3
101147: PUSH
101148: LD_INT 5
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: EMPTY
101156: LIST
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: LIST
101196: LIST
101197: LIST
101198: LIST
101199: LIST
101200: LIST
101201: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
101202: LD_ADDR_VAR 0 33
101206: PUSH
101207: LD_INT 4
101209: NEG
101210: PUSH
101211: LD_INT 4
101213: NEG
101214: PUSH
101215: EMPTY
101216: LIST
101217: LIST
101218: PUSH
101219: LD_INT 4
101221: NEG
101222: PUSH
101223: LD_INT 5
101225: NEG
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: LD_INT 3
101233: NEG
101234: PUSH
101235: LD_INT 4
101237: NEG
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: PUSH
101243: LD_INT 3
101245: NEG
101246: PUSH
101247: LD_INT 3
101249: NEG
101250: PUSH
101251: EMPTY
101252: LIST
101253: LIST
101254: PUSH
101255: LD_INT 4
101257: NEG
101258: PUSH
101259: LD_INT 3
101261: NEG
101262: PUSH
101263: EMPTY
101264: LIST
101265: LIST
101266: PUSH
101267: LD_INT 5
101269: NEG
101270: PUSH
101271: LD_INT 4
101273: NEG
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: PUSH
101279: LD_INT 5
101281: NEG
101282: PUSH
101283: LD_INT 5
101285: NEG
101286: PUSH
101287: EMPTY
101288: LIST
101289: LIST
101290: PUSH
101291: LD_INT 3
101293: NEG
101294: PUSH
101295: LD_INT 5
101297: NEG
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: PUSH
101303: LD_INT 5
101305: NEG
101306: PUSH
101307: LD_INT 3
101309: NEG
101310: PUSH
101311: EMPTY
101312: LIST
101313: LIST
101314: PUSH
101315: LD_INT 0
101317: PUSH
101318: LD_INT 3
101320: NEG
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 0
101328: PUSH
101329: LD_INT 4
101331: NEG
101332: PUSH
101333: EMPTY
101334: LIST
101335: LIST
101336: PUSH
101337: LD_INT 1
101339: PUSH
101340: LD_INT 3
101342: NEG
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: LD_INT 1
101350: PUSH
101351: LD_INT 2
101353: NEG
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: PUSH
101359: LD_INT 0
101361: PUSH
101362: LD_INT 2
101364: NEG
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PUSH
101370: LD_INT 1
101372: NEG
101373: PUSH
101374: LD_INT 3
101376: NEG
101377: PUSH
101378: EMPTY
101379: LIST
101380: LIST
101381: PUSH
101382: LD_INT 1
101384: NEG
101385: PUSH
101386: LD_INT 4
101388: NEG
101389: PUSH
101390: EMPTY
101391: LIST
101392: LIST
101393: PUSH
101394: LD_INT 2
101396: PUSH
101397: LD_INT 2
101399: NEG
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 2
101407: NEG
101408: PUSH
101409: LD_INT 4
101411: NEG
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PUSH
101417: LD_INT 4
101419: PUSH
101420: LD_INT 0
101422: PUSH
101423: EMPTY
101424: LIST
101425: LIST
101426: PUSH
101427: LD_INT 4
101429: PUSH
101430: LD_INT 1
101432: NEG
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 5
101440: PUSH
101441: LD_INT 0
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: LD_INT 5
101450: PUSH
101451: LD_INT 1
101453: PUSH
101454: EMPTY
101455: LIST
101456: LIST
101457: PUSH
101458: LD_INT 4
101460: PUSH
101461: LD_INT 1
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PUSH
101468: LD_INT 3
101470: PUSH
101471: LD_INT 0
101473: PUSH
101474: EMPTY
101475: LIST
101476: LIST
101477: PUSH
101478: LD_INT 3
101480: PUSH
101481: LD_INT 1
101483: NEG
101484: PUSH
101485: EMPTY
101486: LIST
101487: LIST
101488: PUSH
101489: LD_INT 3
101491: PUSH
101492: LD_INT 2
101494: NEG
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 5
101502: PUSH
101503: LD_INT 2
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: PUSH
101510: LD_INT 3
101512: PUSH
101513: LD_INT 3
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: PUSH
101520: LD_INT 3
101522: PUSH
101523: LD_INT 2
101525: PUSH
101526: EMPTY
101527: LIST
101528: LIST
101529: PUSH
101530: LD_INT 4
101532: PUSH
101533: LD_INT 3
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: PUSH
101540: LD_INT 4
101542: PUSH
101543: LD_INT 4
101545: PUSH
101546: EMPTY
101547: LIST
101548: LIST
101549: PUSH
101550: LD_INT 3
101552: PUSH
101553: LD_INT 4
101555: PUSH
101556: EMPTY
101557: LIST
101558: LIST
101559: PUSH
101560: LD_INT 2
101562: PUSH
101563: LD_INT 3
101565: PUSH
101566: EMPTY
101567: LIST
101568: LIST
101569: PUSH
101570: LD_INT 2
101572: PUSH
101573: LD_INT 2
101575: PUSH
101576: EMPTY
101577: LIST
101578: LIST
101579: PUSH
101580: LD_INT 4
101582: PUSH
101583: LD_INT 2
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PUSH
101590: LD_INT 2
101592: PUSH
101593: LD_INT 4
101595: PUSH
101596: EMPTY
101597: LIST
101598: LIST
101599: PUSH
101600: LD_INT 0
101602: PUSH
101603: LD_INT 4
101605: PUSH
101606: EMPTY
101607: LIST
101608: LIST
101609: PUSH
101610: LD_INT 0
101612: PUSH
101613: LD_INT 3
101615: PUSH
101616: EMPTY
101617: LIST
101618: LIST
101619: PUSH
101620: LD_INT 1
101622: PUSH
101623: LD_INT 4
101625: PUSH
101626: EMPTY
101627: LIST
101628: LIST
101629: PUSH
101630: LD_INT 1
101632: PUSH
101633: LD_INT 5
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PUSH
101640: LD_INT 0
101642: PUSH
101643: LD_INT 5
101645: PUSH
101646: EMPTY
101647: LIST
101648: LIST
101649: PUSH
101650: LD_INT 1
101652: NEG
101653: PUSH
101654: LD_INT 4
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: PUSH
101661: LD_INT 1
101663: NEG
101664: PUSH
101665: LD_INT 3
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PUSH
101672: LD_INT 2
101674: PUSH
101675: LD_INT 5
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: PUSH
101682: LD_INT 2
101684: NEG
101685: PUSH
101686: LD_INT 3
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PUSH
101693: EMPTY
101694: LIST
101695: LIST
101696: LIST
101697: LIST
101698: LIST
101699: LIST
101700: LIST
101701: LIST
101702: LIST
101703: LIST
101704: LIST
101705: LIST
101706: LIST
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: LIST
101725: LIST
101726: LIST
101727: LIST
101728: LIST
101729: LIST
101730: LIST
101731: LIST
101732: LIST
101733: LIST
101734: LIST
101735: LIST
101736: LIST
101737: LIST
101738: LIST
101739: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101740: LD_ADDR_VAR 0 34
101744: PUSH
101745: LD_INT 0
101747: PUSH
101748: LD_INT 4
101750: NEG
101751: PUSH
101752: EMPTY
101753: LIST
101754: LIST
101755: PUSH
101756: LD_INT 0
101758: PUSH
101759: LD_INT 5
101761: NEG
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PUSH
101767: LD_INT 1
101769: PUSH
101770: LD_INT 4
101772: NEG
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PUSH
101778: LD_INT 1
101780: PUSH
101781: LD_INT 3
101783: NEG
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: PUSH
101789: LD_INT 0
101791: PUSH
101792: LD_INT 3
101794: NEG
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PUSH
101800: LD_INT 1
101802: NEG
101803: PUSH
101804: LD_INT 4
101806: NEG
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: PUSH
101812: LD_INT 1
101814: NEG
101815: PUSH
101816: LD_INT 5
101818: NEG
101819: PUSH
101820: EMPTY
101821: LIST
101822: LIST
101823: PUSH
101824: LD_INT 2
101826: PUSH
101827: LD_INT 3
101829: NEG
101830: PUSH
101831: EMPTY
101832: LIST
101833: LIST
101834: PUSH
101835: LD_INT 2
101837: NEG
101838: PUSH
101839: LD_INT 5
101841: NEG
101842: PUSH
101843: EMPTY
101844: LIST
101845: LIST
101846: PUSH
101847: LD_INT 3
101849: PUSH
101850: LD_INT 0
101852: PUSH
101853: EMPTY
101854: LIST
101855: LIST
101856: PUSH
101857: LD_INT 3
101859: PUSH
101860: LD_INT 1
101862: NEG
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PUSH
101868: LD_INT 4
101870: PUSH
101871: LD_INT 0
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: LD_INT 4
101880: PUSH
101881: LD_INT 1
101883: PUSH
101884: EMPTY
101885: LIST
101886: LIST
101887: PUSH
101888: LD_INT 3
101890: PUSH
101891: LD_INT 1
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: LD_INT 2
101900: PUSH
101901: LD_INT 0
101903: PUSH
101904: EMPTY
101905: LIST
101906: LIST
101907: PUSH
101908: LD_INT 2
101910: PUSH
101911: LD_INT 1
101913: NEG
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: LD_INT 2
101921: PUSH
101922: LD_INT 2
101924: NEG
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: PUSH
101930: LD_INT 4
101932: PUSH
101933: LD_INT 2
101935: PUSH
101936: EMPTY
101937: LIST
101938: LIST
101939: PUSH
101940: LD_INT 4
101942: PUSH
101943: LD_INT 4
101945: PUSH
101946: EMPTY
101947: LIST
101948: LIST
101949: PUSH
101950: LD_INT 4
101952: PUSH
101953: LD_INT 3
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PUSH
101960: LD_INT 5
101962: PUSH
101963: LD_INT 4
101965: PUSH
101966: EMPTY
101967: LIST
101968: LIST
101969: PUSH
101970: LD_INT 5
101972: PUSH
101973: LD_INT 5
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PUSH
101980: LD_INT 4
101982: PUSH
101983: LD_INT 5
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: PUSH
101990: LD_INT 3
101992: PUSH
101993: LD_INT 4
101995: PUSH
101996: EMPTY
101997: LIST
101998: LIST
101999: PUSH
102000: LD_INT 3
102002: PUSH
102003: LD_INT 3
102005: PUSH
102006: EMPTY
102007: LIST
102008: LIST
102009: PUSH
102010: LD_INT 5
102012: PUSH
102013: LD_INT 3
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: PUSH
102020: LD_INT 3
102022: PUSH
102023: LD_INT 5
102025: PUSH
102026: EMPTY
102027: LIST
102028: LIST
102029: PUSH
102030: LD_INT 0
102032: PUSH
102033: LD_INT 3
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: PUSH
102040: LD_INT 0
102042: PUSH
102043: LD_INT 2
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PUSH
102050: LD_INT 1
102052: PUSH
102053: LD_INT 3
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: PUSH
102060: LD_INT 1
102062: PUSH
102063: LD_INT 4
102065: PUSH
102066: EMPTY
102067: LIST
102068: LIST
102069: PUSH
102070: LD_INT 0
102072: PUSH
102073: LD_INT 4
102075: PUSH
102076: EMPTY
102077: LIST
102078: LIST
102079: PUSH
102080: LD_INT 1
102082: NEG
102083: PUSH
102084: LD_INT 3
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: PUSH
102091: LD_INT 1
102093: NEG
102094: PUSH
102095: LD_INT 2
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PUSH
102102: LD_INT 2
102104: PUSH
102105: LD_INT 4
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: PUSH
102112: LD_INT 2
102114: NEG
102115: PUSH
102116: LD_INT 2
102118: PUSH
102119: EMPTY
102120: LIST
102121: LIST
102122: PUSH
102123: LD_INT 4
102125: NEG
102126: PUSH
102127: LD_INT 0
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: PUSH
102134: LD_INT 4
102136: NEG
102137: PUSH
102138: LD_INT 1
102140: NEG
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: PUSH
102146: LD_INT 3
102148: NEG
102149: PUSH
102150: LD_INT 0
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: PUSH
102157: LD_INT 3
102159: NEG
102160: PUSH
102161: LD_INT 1
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 4
102170: NEG
102171: PUSH
102172: LD_INT 1
102174: PUSH
102175: EMPTY
102176: LIST
102177: LIST
102178: PUSH
102179: LD_INT 5
102181: NEG
102182: PUSH
102183: LD_INT 0
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: PUSH
102190: LD_INT 5
102192: NEG
102193: PUSH
102194: LD_INT 1
102196: NEG
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 5
102204: NEG
102205: PUSH
102206: LD_INT 2
102208: NEG
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PUSH
102214: LD_INT 3
102216: NEG
102217: PUSH
102218: LD_INT 2
102220: PUSH
102221: EMPTY
102222: LIST
102223: LIST
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: LIST
102246: LIST
102247: LIST
102248: LIST
102249: LIST
102250: LIST
102251: LIST
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: LIST
102257: LIST
102258: LIST
102259: LIST
102260: LIST
102261: LIST
102262: LIST
102263: LIST
102264: LIST
102265: LIST
102266: LIST
102267: LIST
102268: LIST
102269: LIST
102270: LIST
102271: ST_TO_ADDR
// end ; end ;
102272: GO 102275
102274: POP
// case btype of b_depot , b_warehouse :
102275: LD_VAR 0 1
102279: PUSH
102280: LD_INT 0
102282: DOUBLE
102283: EQUAL
102284: IFTRUE 102294
102286: LD_INT 1
102288: DOUBLE
102289: EQUAL
102290: IFTRUE 102294
102292: GO 102495
102294: POP
// case nation of nation_american :
102295: LD_VAR 0 5
102299: PUSH
102300: LD_INT 1
102302: DOUBLE
102303: EQUAL
102304: IFTRUE 102308
102306: GO 102364
102308: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
102309: LD_ADDR_VAR 0 9
102313: PUSH
102314: LD_VAR 0 11
102318: PUSH
102319: LD_VAR 0 12
102323: PUSH
102324: LD_VAR 0 13
102328: PUSH
102329: LD_VAR 0 14
102333: PUSH
102334: LD_VAR 0 15
102338: PUSH
102339: LD_VAR 0 16
102343: PUSH
102344: EMPTY
102345: LIST
102346: LIST
102347: LIST
102348: LIST
102349: LIST
102350: LIST
102351: PUSH
102352: LD_VAR 0 4
102356: PUSH
102357: LD_INT 1
102359: PLUS
102360: ARRAY
102361: ST_TO_ADDR
102362: GO 102493
102364: LD_INT 2
102366: DOUBLE
102367: EQUAL
102368: IFTRUE 102372
102370: GO 102428
102372: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
102373: LD_ADDR_VAR 0 9
102377: PUSH
102378: LD_VAR 0 17
102382: PUSH
102383: LD_VAR 0 18
102387: PUSH
102388: LD_VAR 0 19
102392: PUSH
102393: LD_VAR 0 20
102397: PUSH
102398: LD_VAR 0 21
102402: PUSH
102403: LD_VAR 0 22
102407: PUSH
102408: EMPTY
102409: LIST
102410: LIST
102411: LIST
102412: LIST
102413: LIST
102414: LIST
102415: PUSH
102416: LD_VAR 0 4
102420: PUSH
102421: LD_INT 1
102423: PLUS
102424: ARRAY
102425: ST_TO_ADDR
102426: GO 102493
102428: LD_INT 3
102430: DOUBLE
102431: EQUAL
102432: IFTRUE 102436
102434: GO 102492
102436: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
102437: LD_ADDR_VAR 0 9
102441: PUSH
102442: LD_VAR 0 23
102446: PUSH
102447: LD_VAR 0 24
102451: PUSH
102452: LD_VAR 0 25
102456: PUSH
102457: LD_VAR 0 26
102461: PUSH
102462: LD_VAR 0 27
102466: PUSH
102467: LD_VAR 0 28
102471: PUSH
102472: EMPTY
102473: LIST
102474: LIST
102475: LIST
102476: LIST
102477: LIST
102478: LIST
102479: PUSH
102480: LD_VAR 0 4
102484: PUSH
102485: LD_INT 1
102487: PLUS
102488: ARRAY
102489: ST_TO_ADDR
102490: GO 102493
102492: POP
102493: GO 103048
102495: LD_INT 2
102497: DOUBLE
102498: EQUAL
102499: IFTRUE 102509
102501: LD_INT 3
102503: DOUBLE
102504: EQUAL
102505: IFTRUE 102509
102507: GO 102565
102509: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
102510: LD_ADDR_VAR 0 9
102514: PUSH
102515: LD_VAR 0 29
102519: PUSH
102520: LD_VAR 0 30
102524: PUSH
102525: LD_VAR 0 31
102529: PUSH
102530: LD_VAR 0 32
102534: PUSH
102535: LD_VAR 0 33
102539: PUSH
102540: LD_VAR 0 34
102544: PUSH
102545: EMPTY
102546: LIST
102547: LIST
102548: LIST
102549: LIST
102550: LIST
102551: LIST
102552: PUSH
102553: LD_VAR 0 4
102557: PUSH
102558: LD_INT 1
102560: PLUS
102561: ARRAY
102562: ST_TO_ADDR
102563: GO 103048
102565: LD_INT 16
102567: DOUBLE
102568: EQUAL
102569: IFTRUE 102627
102571: LD_INT 17
102573: DOUBLE
102574: EQUAL
102575: IFTRUE 102627
102577: LD_INT 18
102579: DOUBLE
102580: EQUAL
102581: IFTRUE 102627
102583: LD_INT 19
102585: DOUBLE
102586: EQUAL
102587: IFTRUE 102627
102589: LD_INT 22
102591: DOUBLE
102592: EQUAL
102593: IFTRUE 102627
102595: LD_INT 20
102597: DOUBLE
102598: EQUAL
102599: IFTRUE 102627
102601: LD_INT 21
102603: DOUBLE
102604: EQUAL
102605: IFTRUE 102627
102607: LD_INT 23
102609: DOUBLE
102610: EQUAL
102611: IFTRUE 102627
102613: LD_INT 24
102615: DOUBLE
102616: EQUAL
102617: IFTRUE 102627
102619: LD_INT 25
102621: DOUBLE
102622: EQUAL
102623: IFTRUE 102627
102625: GO 102683
102627: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102628: LD_ADDR_VAR 0 9
102632: PUSH
102633: LD_VAR 0 35
102637: PUSH
102638: LD_VAR 0 36
102642: PUSH
102643: LD_VAR 0 37
102647: PUSH
102648: LD_VAR 0 38
102652: PUSH
102653: LD_VAR 0 39
102657: PUSH
102658: LD_VAR 0 40
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: LIST
102667: LIST
102668: LIST
102669: LIST
102670: PUSH
102671: LD_VAR 0 4
102675: PUSH
102676: LD_INT 1
102678: PLUS
102679: ARRAY
102680: ST_TO_ADDR
102681: GO 103048
102683: LD_INT 6
102685: DOUBLE
102686: EQUAL
102687: IFTRUE 102739
102689: LD_INT 7
102691: DOUBLE
102692: EQUAL
102693: IFTRUE 102739
102695: LD_INT 8
102697: DOUBLE
102698: EQUAL
102699: IFTRUE 102739
102701: LD_INT 13
102703: DOUBLE
102704: EQUAL
102705: IFTRUE 102739
102707: LD_INT 12
102709: DOUBLE
102710: EQUAL
102711: IFTRUE 102739
102713: LD_INT 15
102715: DOUBLE
102716: EQUAL
102717: IFTRUE 102739
102719: LD_INT 11
102721: DOUBLE
102722: EQUAL
102723: IFTRUE 102739
102725: LD_INT 14
102727: DOUBLE
102728: EQUAL
102729: IFTRUE 102739
102731: LD_INT 10
102733: DOUBLE
102734: EQUAL
102735: IFTRUE 102739
102737: GO 102795
102739: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102740: LD_ADDR_VAR 0 9
102744: PUSH
102745: LD_VAR 0 41
102749: PUSH
102750: LD_VAR 0 42
102754: PUSH
102755: LD_VAR 0 43
102759: PUSH
102760: LD_VAR 0 44
102764: PUSH
102765: LD_VAR 0 45
102769: PUSH
102770: LD_VAR 0 46
102774: PUSH
102775: EMPTY
102776: LIST
102777: LIST
102778: LIST
102779: LIST
102780: LIST
102781: LIST
102782: PUSH
102783: LD_VAR 0 4
102787: PUSH
102788: LD_INT 1
102790: PLUS
102791: ARRAY
102792: ST_TO_ADDR
102793: GO 103048
102795: LD_INT 36
102797: DOUBLE
102798: EQUAL
102799: IFTRUE 102803
102801: GO 102859
102803: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102804: LD_ADDR_VAR 0 9
102808: PUSH
102809: LD_VAR 0 47
102813: PUSH
102814: LD_VAR 0 48
102818: PUSH
102819: LD_VAR 0 49
102823: PUSH
102824: LD_VAR 0 50
102828: PUSH
102829: LD_VAR 0 51
102833: PUSH
102834: LD_VAR 0 52
102838: PUSH
102839: EMPTY
102840: LIST
102841: LIST
102842: LIST
102843: LIST
102844: LIST
102845: LIST
102846: PUSH
102847: LD_VAR 0 4
102851: PUSH
102852: LD_INT 1
102854: PLUS
102855: ARRAY
102856: ST_TO_ADDR
102857: GO 103048
102859: LD_INT 4
102861: DOUBLE
102862: EQUAL
102863: IFTRUE 102885
102865: LD_INT 5
102867: DOUBLE
102868: EQUAL
102869: IFTRUE 102885
102871: LD_INT 34
102873: DOUBLE
102874: EQUAL
102875: IFTRUE 102885
102877: LD_INT 37
102879: DOUBLE
102880: EQUAL
102881: IFTRUE 102885
102883: GO 102941
102885: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102886: LD_ADDR_VAR 0 9
102890: PUSH
102891: LD_VAR 0 53
102895: PUSH
102896: LD_VAR 0 54
102900: PUSH
102901: LD_VAR 0 55
102905: PUSH
102906: LD_VAR 0 56
102910: PUSH
102911: LD_VAR 0 57
102915: PUSH
102916: LD_VAR 0 58
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: LIST
102925: LIST
102926: LIST
102927: LIST
102928: PUSH
102929: LD_VAR 0 4
102933: PUSH
102934: LD_INT 1
102936: PLUS
102937: ARRAY
102938: ST_TO_ADDR
102939: GO 103048
102941: LD_INT 31
102943: DOUBLE
102944: EQUAL
102945: IFTRUE 102991
102947: LD_INT 32
102949: DOUBLE
102950: EQUAL
102951: IFTRUE 102991
102953: LD_INT 33
102955: DOUBLE
102956: EQUAL
102957: IFTRUE 102991
102959: LD_INT 27
102961: DOUBLE
102962: EQUAL
102963: IFTRUE 102991
102965: LD_INT 26
102967: DOUBLE
102968: EQUAL
102969: IFTRUE 102991
102971: LD_INT 28
102973: DOUBLE
102974: EQUAL
102975: IFTRUE 102991
102977: LD_INT 29
102979: DOUBLE
102980: EQUAL
102981: IFTRUE 102991
102983: LD_INT 30
102985: DOUBLE
102986: EQUAL
102987: IFTRUE 102991
102989: GO 103047
102991: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102992: LD_ADDR_VAR 0 9
102996: PUSH
102997: LD_VAR 0 59
103001: PUSH
103002: LD_VAR 0 60
103006: PUSH
103007: LD_VAR 0 61
103011: PUSH
103012: LD_VAR 0 62
103016: PUSH
103017: LD_VAR 0 63
103021: PUSH
103022: LD_VAR 0 64
103026: PUSH
103027: EMPTY
103028: LIST
103029: LIST
103030: LIST
103031: LIST
103032: LIST
103033: LIST
103034: PUSH
103035: LD_VAR 0 4
103039: PUSH
103040: LD_INT 1
103042: PLUS
103043: ARRAY
103044: ST_TO_ADDR
103045: GO 103048
103047: POP
// temp_list2 = [ ] ;
103048: LD_ADDR_VAR 0 10
103052: PUSH
103053: EMPTY
103054: ST_TO_ADDR
// for i in temp_list do
103055: LD_ADDR_VAR 0 8
103059: PUSH
103060: LD_VAR 0 9
103064: PUSH
103065: FOR_IN
103066: IFFALSE 103118
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103068: LD_ADDR_VAR 0 10
103072: PUSH
103073: LD_VAR 0 10
103077: PUSH
103078: LD_VAR 0 8
103082: PUSH
103083: LD_INT 1
103085: ARRAY
103086: PUSH
103087: LD_VAR 0 2
103091: PLUS
103092: PUSH
103093: LD_VAR 0 8
103097: PUSH
103098: LD_INT 2
103100: ARRAY
103101: PUSH
103102: LD_VAR 0 3
103106: PLUS
103107: PUSH
103108: EMPTY
103109: LIST
103110: LIST
103111: PUSH
103112: EMPTY
103113: LIST
103114: ADD
103115: ST_TO_ADDR
103116: GO 103065
103118: POP
103119: POP
// result = temp_list2 ;
103120: LD_ADDR_VAR 0 7
103124: PUSH
103125: LD_VAR 0 10
103129: ST_TO_ADDR
// end ;
103130: LD_VAR 0 7
103134: RET
// export function EnemyInRange ( unit , dist ) ; begin
103135: LD_INT 0
103137: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
103138: LD_ADDR_VAR 0 3
103142: PUSH
103143: LD_VAR 0 1
103147: PPUSH
103148: CALL_OW 255
103152: PPUSH
103153: LD_VAR 0 1
103157: PPUSH
103158: CALL_OW 250
103162: PPUSH
103163: LD_VAR 0 1
103167: PPUSH
103168: CALL_OW 251
103172: PPUSH
103173: LD_VAR 0 2
103177: PPUSH
103178: CALL 76508 0 4
103182: PUSH
103183: LD_INT 4
103185: ARRAY
103186: ST_TO_ADDR
// end ;
103187: LD_VAR 0 3
103191: RET
// export function PlayerSeeMe ( unit ) ; begin
103192: LD_INT 0
103194: PPUSH
// result := See ( your_side , unit ) ;
103195: LD_ADDR_VAR 0 2
103199: PUSH
103200: LD_OWVAR 2
103204: PPUSH
103205: LD_VAR 0 1
103209: PPUSH
103210: CALL_OW 292
103214: ST_TO_ADDR
// end ;
103215: LD_VAR 0 2
103219: RET
// export function ReverseDir ( unit ) ; begin
103220: LD_INT 0
103222: PPUSH
// if not unit then
103223: LD_VAR 0 1
103227: NOT
103228: IFFALSE 103232
// exit ;
103230: GO 103255
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
103232: LD_ADDR_VAR 0 2
103236: PUSH
103237: LD_VAR 0 1
103241: PPUSH
103242: CALL_OW 254
103246: PUSH
103247: LD_INT 3
103249: PLUS
103250: PUSH
103251: LD_INT 6
103253: MOD
103254: ST_TO_ADDR
// end ;
103255: LD_VAR 0 2
103259: RET
// export function ReverseArray ( array ) ; var i ; begin
103260: LD_INT 0
103262: PPUSH
103263: PPUSH
// if not array then
103264: LD_VAR 0 1
103268: NOT
103269: IFFALSE 103273
// exit ;
103271: GO 103328
// result := [ ] ;
103273: LD_ADDR_VAR 0 2
103277: PUSH
103278: EMPTY
103279: ST_TO_ADDR
// for i := array downto 1 do
103280: LD_ADDR_VAR 0 3
103284: PUSH
103285: DOUBLE
103286: LD_VAR 0 1
103290: INC
103291: ST_TO_ADDR
103292: LD_INT 1
103294: PUSH
103295: FOR_DOWNTO
103296: IFFALSE 103326
// result := Join ( result , array [ i ] ) ;
103298: LD_ADDR_VAR 0 2
103302: PUSH
103303: LD_VAR 0 2
103307: PPUSH
103308: LD_VAR 0 1
103312: PUSH
103313: LD_VAR 0 3
103317: ARRAY
103318: PPUSH
103319: CALL 107973 0 2
103323: ST_TO_ADDR
103324: GO 103295
103326: POP
103327: POP
// end ;
103328: LD_VAR 0 2
103332: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
103333: LD_INT 0
103335: PPUSH
103336: PPUSH
103337: PPUSH
103338: PPUSH
103339: PPUSH
103340: PPUSH
// if not unit or not hexes then
103341: LD_VAR 0 1
103345: NOT
103346: PUSH
103347: LD_VAR 0 2
103351: NOT
103352: OR
103353: IFFALSE 103357
// exit ;
103355: GO 103480
// dist := 9999 ;
103357: LD_ADDR_VAR 0 5
103361: PUSH
103362: LD_INT 9999
103364: ST_TO_ADDR
// for i = 1 to hexes do
103365: LD_ADDR_VAR 0 4
103369: PUSH
103370: DOUBLE
103371: LD_INT 1
103373: DEC
103374: ST_TO_ADDR
103375: LD_VAR 0 2
103379: PUSH
103380: FOR_TO
103381: IFFALSE 103468
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
103383: LD_ADDR_VAR 0 6
103387: PUSH
103388: LD_VAR 0 1
103392: PPUSH
103393: LD_VAR 0 2
103397: PUSH
103398: LD_VAR 0 4
103402: ARRAY
103403: PUSH
103404: LD_INT 1
103406: ARRAY
103407: PPUSH
103408: LD_VAR 0 2
103412: PUSH
103413: LD_VAR 0 4
103417: ARRAY
103418: PUSH
103419: LD_INT 2
103421: ARRAY
103422: PPUSH
103423: CALL_OW 297
103427: ST_TO_ADDR
// if tdist < dist then
103428: LD_VAR 0 6
103432: PUSH
103433: LD_VAR 0 5
103437: LESS
103438: IFFALSE 103466
// begin hex := hexes [ i ] ;
103440: LD_ADDR_VAR 0 8
103444: PUSH
103445: LD_VAR 0 2
103449: PUSH
103450: LD_VAR 0 4
103454: ARRAY
103455: ST_TO_ADDR
// dist := tdist ;
103456: LD_ADDR_VAR 0 5
103460: PUSH
103461: LD_VAR 0 6
103465: ST_TO_ADDR
// end ; end ;
103466: GO 103380
103468: POP
103469: POP
// result := hex ;
103470: LD_ADDR_VAR 0 3
103474: PUSH
103475: LD_VAR 0 8
103479: ST_TO_ADDR
// end ;
103480: LD_VAR 0 3
103484: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
103485: LD_INT 0
103487: PPUSH
103488: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103489: LD_VAR 0 1
103493: NOT
103494: PUSH
103495: LD_VAR 0 1
103499: PUSH
103500: LD_INT 21
103502: PUSH
103503: LD_INT 2
103505: PUSH
103506: EMPTY
103507: LIST
103508: LIST
103509: PUSH
103510: LD_INT 23
103512: PUSH
103513: LD_INT 2
103515: PUSH
103516: EMPTY
103517: LIST
103518: LIST
103519: PUSH
103520: EMPTY
103521: LIST
103522: LIST
103523: PPUSH
103524: CALL_OW 69
103528: IN
103529: NOT
103530: OR
103531: IFFALSE 103535
// exit ;
103533: GO 103582
// for i = 1 to 3 do
103535: LD_ADDR_VAR 0 3
103539: PUSH
103540: DOUBLE
103541: LD_INT 1
103543: DEC
103544: ST_TO_ADDR
103545: LD_INT 3
103547: PUSH
103548: FOR_TO
103549: IFFALSE 103580
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
103551: LD_VAR 0 1
103555: PPUSH
103556: CALL_OW 250
103560: PPUSH
103561: LD_VAR 0 1
103565: PPUSH
103566: CALL_OW 251
103570: PPUSH
103571: LD_INT 1
103573: PPUSH
103574: CALL_OW 453
103578: GO 103548
103580: POP
103581: POP
// end ;
103582: LD_VAR 0 2
103586: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103587: LD_INT 0
103589: PPUSH
103590: PPUSH
103591: PPUSH
103592: PPUSH
103593: PPUSH
103594: PPUSH
// if not unit or not enemy_unit then
103595: LD_VAR 0 1
103599: NOT
103600: PUSH
103601: LD_VAR 0 2
103605: NOT
103606: OR
103607: IFFALSE 103611
// exit ;
103609: GO 104078
// if GetLives ( i ) < 250 then
103611: LD_VAR 0 4
103615: PPUSH
103616: CALL_OW 256
103620: PUSH
103621: LD_INT 250
103623: LESS
103624: IFFALSE 103637
// begin ComAutodestruct ( i ) ;
103626: LD_VAR 0 4
103630: PPUSH
103631: CALL 103485 0 1
// exit ;
103635: GO 104078
// end ; x := GetX ( enemy_unit ) ;
103637: LD_ADDR_VAR 0 7
103641: PUSH
103642: LD_VAR 0 2
103646: PPUSH
103647: CALL_OW 250
103651: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103652: LD_ADDR_VAR 0 8
103656: PUSH
103657: LD_VAR 0 2
103661: PPUSH
103662: CALL_OW 251
103666: ST_TO_ADDR
// if not x or not y then
103667: LD_VAR 0 7
103671: NOT
103672: PUSH
103673: LD_VAR 0 8
103677: NOT
103678: OR
103679: IFFALSE 103683
// exit ;
103681: GO 104078
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103683: LD_ADDR_VAR 0 6
103687: PUSH
103688: LD_VAR 0 7
103692: PPUSH
103693: LD_INT 0
103695: PPUSH
103696: LD_INT 4
103698: PPUSH
103699: CALL_OW 272
103703: PUSH
103704: LD_VAR 0 8
103708: PPUSH
103709: LD_INT 0
103711: PPUSH
103712: LD_INT 4
103714: PPUSH
103715: CALL_OW 273
103719: PUSH
103720: EMPTY
103721: LIST
103722: LIST
103723: PUSH
103724: LD_VAR 0 7
103728: PPUSH
103729: LD_INT 1
103731: PPUSH
103732: LD_INT 4
103734: PPUSH
103735: CALL_OW 272
103739: PUSH
103740: LD_VAR 0 8
103744: PPUSH
103745: LD_INT 1
103747: PPUSH
103748: LD_INT 4
103750: PPUSH
103751: CALL_OW 273
103755: PUSH
103756: EMPTY
103757: LIST
103758: LIST
103759: PUSH
103760: LD_VAR 0 7
103764: PPUSH
103765: LD_INT 2
103767: PPUSH
103768: LD_INT 4
103770: PPUSH
103771: CALL_OW 272
103775: PUSH
103776: LD_VAR 0 8
103780: PPUSH
103781: LD_INT 2
103783: PPUSH
103784: LD_INT 4
103786: PPUSH
103787: CALL_OW 273
103791: PUSH
103792: EMPTY
103793: LIST
103794: LIST
103795: PUSH
103796: LD_VAR 0 7
103800: PPUSH
103801: LD_INT 3
103803: PPUSH
103804: LD_INT 4
103806: PPUSH
103807: CALL_OW 272
103811: PUSH
103812: LD_VAR 0 8
103816: PPUSH
103817: LD_INT 3
103819: PPUSH
103820: LD_INT 4
103822: PPUSH
103823: CALL_OW 273
103827: PUSH
103828: EMPTY
103829: LIST
103830: LIST
103831: PUSH
103832: LD_VAR 0 7
103836: PPUSH
103837: LD_INT 4
103839: PPUSH
103840: LD_INT 4
103842: PPUSH
103843: CALL_OW 272
103847: PUSH
103848: LD_VAR 0 8
103852: PPUSH
103853: LD_INT 4
103855: PPUSH
103856: LD_INT 4
103858: PPUSH
103859: CALL_OW 273
103863: PUSH
103864: EMPTY
103865: LIST
103866: LIST
103867: PUSH
103868: LD_VAR 0 7
103872: PPUSH
103873: LD_INT 5
103875: PPUSH
103876: LD_INT 4
103878: PPUSH
103879: CALL_OW 272
103883: PUSH
103884: LD_VAR 0 8
103888: PPUSH
103889: LD_INT 5
103891: PPUSH
103892: LD_INT 4
103894: PPUSH
103895: CALL_OW 273
103899: PUSH
103900: EMPTY
103901: LIST
103902: LIST
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: LIST
103911: ST_TO_ADDR
// for i = tmp downto 1 do
103912: LD_ADDR_VAR 0 4
103916: PUSH
103917: DOUBLE
103918: LD_VAR 0 6
103922: INC
103923: ST_TO_ADDR
103924: LD_INT 1
103926: PUSH
103927: FOR_DOWNTO
103928: IFFALSE 104029
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103930: LD_VAR 0 6
103934: PUSH
103935: LD_VAR 0 4
103939: ARRAY
103940: PUSH
103941: LD_INT 1
103943: ARRAY
103944: PPUSH
103945: LD_VAR 0 6
103949: PUSH
103950: LD_VAR 0 4
103954: ARRAY
103955: PUSH
103956: LD_INT 2
103958: ARRAY
103959: PPUSH
103960: CALL_OW 488
103964: NOT
103965: PUSH
103966: LD_VAR 0 6
103970: PUSH
103971: LD_VAR 0 4
103975: ARRAY
103976: PUSH
103977: LD_INT 1
103979: ARRAY
103980: PPUSH
103981: LD_VAR 0 6
103985: PUSH
103986: LD_VAR 0 4
103990: ARRAY
103991: PUSH
103992: LD_INT 2
103994: ARRAY
103995: PPUSH
103996: CALL_OW 428
104000: PUSH
104001: LD_INT 0
104003: NONEQUAL
104004: OR
104005: IFFALSE 104027
// tmp := Delete ( tmp , i ) ;
104007: LD_ADDR_VAR 0 6
104011: PUSH
104012: LD_VAR 0 6
104016: PPUSH
104017: LD_VAR 0 4
104021: PPUSH
104022: CALL_OW 3
104026: ST_TO_ADDR
104027: GO 103927
104029: POP
104030: POP
// j := GetClosestHex ( unit , tmp ) ;
104031: LD_ADDR_VAR 0 5
104035: PUSH
104036: LD_VAR 0 1
104040: PPUSH
104041: LD_VAR 0 6
104045: PPUSH
104046: CALL 103333 0 2
104050: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104051: LD_VAR 0 1
104055: PPUSH
104056: LD_VAR 0 5
104060: PUSH
104061: LD_INT 1
104063: ARRAY
104064: PPUSH
104065: LD_VAR 0 5
104069: PUSH
104070: LD_INT 2
104072: ARRAY
104073: PPUSH
104074: CALL_OW 111
// end ;
104078: LD_VAR 0 3
104082: RET
// export function PrepareApemanSoldier ( ) ; begin
104083: LD_INT 0
104085: PPUSH
// uc_nation := 0 ;
104086: LD_ADDR_OWVAR 21
104090: PUSH
104091: LD_INT 0
104093: ST_TO_ADDR
// hc_sex := sex_male ;
104094: LD_ADDR_OWVAR 27
104098: PUSH
104099: LD_INT 1
104101: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
104102: LD_ADDR_OWVAR 28
104106: PUSH
104107: LD_INT 15
104109: ST_TO_ADDR
// hc_gallery :=  ;
104110: LD_ADDR_OWVAR 33
104114: PUSH
104115: LD_STRING 
104117: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104118: LD_ADDR_OWVAR 31
104122: PUSH
104123: LD_INT 0
104125: PPUSH
104126: LD_INT 3
104128: PPUSH
104129: CALL_OW 12
104133: PUSH
104134: LD_INT 0
104136: PPUSH
104137: LD_INT 3
104139: PPUSH
104140: CALL_OW 12
104144: PUSH
104145: LD_INT 0
104147: PUSH
104148: LD_INT 0
104150: PUSH
104151: EMPTY
104152: LIST
104153: LIST
104154: LIST
104155: LIST
104156: ST_TO_ADDR
// end ;
104157: LD_VAR 0 1
104161: RET
// export function PrepareApemanEngineer ( ) ; begin
104162: LD_INT 0
104164: PPUSH
// uc_nation := 0 ;
104165: LD_ADDR_OWVAR 21
104169: PUSH
104170: LD_INT 0
104172: ST_TO_ADDR
// hc_sex := sex_male ;
104173: LD_ADDR_OWVAR 27
104177: PUSH
104178: LD_INT 1
104180: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
104181: LD_ADDR_OWVAR 28
104185: PUSH
104186: LD_INT 16
104188: ST_TO_ADDR
// hc_gallery :=  ;
104189: LD_ADDR_OWVAR 33
104193: PUSH
104194: LD_STRING 
104196: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104197: LD_ADDR_OWVAR 31
104201: PUSH
104202: LD_INT 0
104204: PPUSH
104205: LD_INT 3
104207: PPUSH
104208: CALL_OW 12
104212: PUSH
104213: LD_INT 0
104215: PPUSH
104216: LD_INT 3
104218: PPUSH
104219: CALL_OW 12
104223: PUSH
104224: LD_INT 0
104226: PUSH
104227: LD_INT 0
104229: PUSH
104230: EMPTY
104231: LIST
104232: LIST
104233: LIST
104234: LIST
104235: ST_TO_ADDR
// end ;
104236: LD_VAR 0 1
104240: RET
// export function PrepareApeman ( agressivity ) ; begin
104241: LD_INT 0
104243: PPUSH
// uc_side := 0 ;
104244: LD_ADDR_OWVAR 20
104248: PUSH
104249: LD_INT 0
104251: ST_TO_ADDR
// uc_nation := 0 ;
104252: LD_ADDR_OWVAR 21
104256: PUSH
104257: LD_INT 0
104259: ST_TO_ADDR
// hc_sex := sex_male ;
104260: LD_ADDR_OWVAR 27
104264: PUSH
104265: LD_INT 1
104267: ST_TO_ADDR
// hc_class := class_apeman ;
104268: LD_ADDR_OWVAR 28
104272: PUSH
104273: LD_INT 12
104275: ST_TO_ADDR
// hc_gallery :=  ;
104276: LD_ADDR_OWVAR 33
104280: PUSH
104281: LD_STRING 
104283: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104284: LD_ADDR_OWVAR 35
104288: PUSH
104289: LD_VAR 0 1
104293: NEG
104294: PPUSH
104295: LD_VAR 0 1
104299: PPUSH
104300: CALL_OW 12
104304: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104305: LD_ADDR_OWVAR 31
104309: PUSH
104310: LD_INT 0
104312: PPUSH
104313: LD_INT 3
104315: PPUSH
104316: CALL_OW 12
104320: PUSH
104321: LD_INT 0
104323: PPUSH
104324: LD_INT 3
104326: PPUSH
104327: CALL_OW 12
104331: PUSH
104332: LD_INT 0
104334: PUSH
104335: LD_INT 0
104337: PUSH
104338: EMPTY
104339: LIST
104340: LIST
104341: LIST
104342: LIST
104343: ST_TO_ADDR
// end ;
104344: LD_VAR 0 2
104348: RET
// export function PrepareTiger ( agressivity ) ; begin
104349: LD_INT 0
104351: PPUSH
// uc_side := 0 ;
104352: LD_ADDR_OWVAR 20
104356: PUSH
104357: LD_INT 0
104359: ST_TO_ADDR
// uc_nation := 0 ;
104360: LD_ADDR_OWVAR 21
104364: PUSH
104365: LD_INT 0
104367: ST_TO_ADDR
// hc_class := class_tiger ;
104368: LD_ADDR_OWVAR 28
104372: PUSH
104373: LD_INT 14
104375: ST_TO_ADDR
// hc_gallery :=  ;
104376: LD_ADDR_OWVAR 33
104380: PUSH
104381: LD_STRING 
104383: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104384: LD_ADDR_OWVAR 35
104388: PUSH
104389: LD_VAR 0 1
104393: NEG
104394: PPUSH
104395: LD_VAR 0 1
104399: PPUSH
104400: CALL_OW 12
104404: ST_TO_ADDR
// end ;
104405: LD_VAR 0 2
104409: RET
// export function PrepareEnchidna ( ) ; begin
104410: LD_INT 0
104412: PPUSH
// uc_side := 0 ;
104413: LD_ADDR_OWVAR 20
104417: PUSH
104418: LD_INT 0
104420: ST_TO_ADDR
// uc_nation := 0 ;
104421: LD_ADDR_OWVAR 21
104425: PUSH
104426: LD_INT 0
104428: ST_TO_ADDR
// hc_class := class_baggie ;
104429: LD_ADDR_OWVAR 28
104433: PUSH
104434: LD_INT 13
104436: ST_TO_ADDR
// hc_gallery :=  ;
104437: LD_ADDR_OWVAR 33
104441: PUSH
104442: LD_STRING 
104444: ST_TO_ADDR
// end ;
104445: LD_VAR 0 1
104449: RET
// export function PrepareFrog ( ) ; begin
104450: LD_INT 0
104452: PPUSH
// uc_side := 0 ;
104453: LD_ADDR_OWVAR 20
104457: PUSH
104458: LD_INT 0
104460: ST_TO_ADDR
// uc_nation := 0 ;
104461: LD_ADDR_OWVAR 21
104465: PUSH
104466: LD_INT 0
104468: ST_TO_ADDR
// hc_class := class_frog ;
104469: LD_ADDR_OWVAR 28
104473: PUSH
104474: LD_INT 19
104476: ST_TO_ADDR
// hc_gallery :=  ;
104477: LD_ADDR_OWVAR 33
104481: PUSH
104482: LD_STRING 
104484: ST_TO_ADDR
// end ;
104485: LD_VAR 0 1
104489: RET
// export function PrepareFish ( ) ; begin
104490: LD_INT 0
104492: PPUSH
// uc_side := 0 ;
104493: LD_ADDR_OWVAR 20
104497: PUSH
104498: LD_INT 0
104500: ST_TO_ADDR
// uc_nation := 0 ;
104501: LD_ADDR_OWVAR 21
104505: PUSH
104506: LD_INT 0
104508: ST_TO_ADDR
// hc_class := class_fish ;
104509: LD_ADDR_OWVAR 28
104513: PUSH
104514: LD_INT 20
104516: ST_TO_ADDR
// hc_gallery :=  ;
104517: LD_ADDR_OWVAR 33
104521: PUSH
104522: LD_STRING 
104524: ST_TO_ADDR
// end ;
104525: LD_VAR 0 1
104529: RET
// export function PrepareBird ( ) ; begin
104530: LD_INT 0
104532: PPUSH
// uc_side := 0 ;
104533: LD_ADDR_OWVAR 20
104537: PUSH
104538: LD_INT 0
104540: ST_TO_ADDR
// uc_nation := 0 ;
104541: LD_ADDR_OWVAR 21
104545: PUSH
104546: LD_INT 0
104548: ST_TO_ADDR
// hc_class := class_phororhacos ;
104549: LD_ADDR_OWVAR 28
104553: PUSH
104554: LD_INT 18
104556: ST_TO_ADDR
// hc_gallery :=  ;
104557: LD_ADDR_OWVAR 33
104561: PUSH
104562: LD_STRING 
104564: ST_TO_ADDR
// end ;
104565: LD_VAR 0 1
104569: RET
// export function PrepareHorse ( ) ; begin
104570: LD_INT 0
104572: PPUSH
// uc_side := 0 ;
104573: LD_ADDR_OWVAR 20
104577: PUSH
104578: LD_INT 0
104580: ST_TO_ADDR
// uc_nation := 0 ;
104581: LD_ADDR_OWVAR 21
104585: PUSH
104586: LD_INT 0
104588: ST_TO_ADDR
// hc_class := class_horse ;
104589: LD_ADDR_OWVAR 28
104593: PUSH
104594: LD_INT 21
104596: ST_TO_ADDR
// hc_gallery :=  ;
104597: LD_ADDR_OWVAR 33
104601: PUSH
104602: LD_STRING 
104604: ST_TO_ADDR
// end ;
104605: LD_VAR 0 1
104609: RET
// export function PrepareMastodont ( ) ; begin
104610: LD_INT 0
104612: PPUSH
// uc_side := 0 ;
104613: LD_ADDR_OWVAR 20
104617: PUSH
104618: LD_INT 0
104620: ST_TO_ADDR
// uc_nation := 0 ;
104621: LD_ADDR_OWVAR 21
104625: PUSH
104626: LD_INT 0
104628: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104629: LD_ADDR_OWVAR 37
104633: PUSH
104634: LD_INT 31
104636: ST_TO_ADDR
// vc_control := control_rider ;
104637: LD_ADDR_OWVAR 38
104641: PUSH
104642: LD_INT 4
104644: ST_TO_ADDR
// end ;
104645: LD_VAR 0 1
104649: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104650: LD_INT 0
104652: PPUSH
104653: PPUSH
104654: PPUSH
// uc_side = 0 ;
104655: LD_ADDR_OWVAR 20
104659: PUSH
104660: LD_INT 0
104662: ST_TO_ADDR
// uc_nation = 0 ;
104663: LD_ADDR_OWVAR 21
104667: PUSH
104668: LD_INT 0
104670: ST_TO_ADDR
// InitHc_All ( ) ;
104671: CALL_OW 584
// InitVc ;
104675: CALL_OW 20
// if mastodonts then
104679: LD_VAR 0 6
104683: IFFALSE 104750
// for i = 1 to mastodonts do
104685: LD_ADDR_VAR 0 11
104689: PUSH
104690: DOUBLE
104691: LD_INT 1
104693: DEC
104694: ST_TO_ADDR
104695: LD_VAR 0 6
104699: PUSH
104700: FOR_TO
104701: IFFALSE 104748
// begin vc_chassis := 31 ;
104703: LD_ADDR_OWVAR 37
104707: PUSH
104708: LD_INT 31
104710: ST_TO_ADDR
// vc_control := control_rider ;
104711: LD_ADDR_OWVAR 38
104715: PUSH
104716: LD_INT 4
104718: ST_TO_ADDR
// animal := CreateVehicle ;
104719: LD_ADDR_VAR 0 12
104723: PUSH
104724: CALL_OW 45
104728: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104729: LD_VAR 0 12
104733: PPUSH
104734: LD_VAR 0 8
104738: PPUSH
104739: LD_INT 0
104741: PPUSH
104742: CALL 106878 0 3
// end ;
104746: GO 104700
104748: POP
104749: POP
// if horses then
104750: LD_VAR 0 5
104754: IFFALSE 104821
// for i = 1 to horses do
104756: LD_ADDR_VAR 0 11
104760: PUSH
104761: DOUBLE
104762: LD_INT 1
104764: DEC
104765: ST_TO_ADDR
104766: LD_VAR 0 5
104770: PUSH
104771: FOR_TO
104772: IFFALSE 104819
// begin hc_class := 21 ;
104774: LD_ADDR_OWVAR 28
104778: PUSH
104779: LD_INT 21
104781: ST_TO_ADDR
// hc_gallery :=  ;
104782: LD_ADDR_OWVAR 33
104786: PUSH
104787: LD_STRING 
104789: ST_TO_ADDR
// animal := CreateHuman ;
104790: LD_ADDR_VAR 0 12
104794: PUSH
104795: CALL_OW 44
104799: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104800: LD_VAR 0 12
104804: PPUSH
104805: LD_VAR 0 8
104809: PPUSH
104810: LD_INT 0
104812: PPUSH
104813: CALL 106878 0 3
// end ;
104817: GO 104771
104819: POP
104820: POP
// if birds then
104821: LD_VAR 0 1
104825: IFFALSE 104892
// for i = 1 to birds do
104827: LD_ADDR_VAR 0 11
104831: PUSH
104832: DOUBLE
104833: LD_INT 1
104835: DEC
104836: ST_TO_ADDR
104837: LD_VAR 0 1
104841: PUSH
104842: FOR_TO
104843: IFFALSE 104890
// begin hc_class := 18 ;
104845: LD_ADDR_OWVAR 28
104849: PUSH
104850: LD_INT 18
104852: ST_TO_ADDR
// hc_gallery =  ;
104853: LD_ADDR_OWVAR 33
104857: PUSH
104858: LD_STRING 
104860: ST_TO_ADDR
// animal := CreateHuman ;
104861: LD_ADDR_VAR 0 12
104865: PUSH
104866: CALL_OW 44
104870: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104871: LD_VAR 0 12
104875: PPUSH
104876: LD_VAR 0 8
104880: PPUSH
104881: LD_INT 0
104883: PPUSH
104884: CALL 106878 0 3
// end ;
104888: GO 104842
104890: POP
104891: POP
// if tigers then
104892: LD_VAR 0 2
104896: IFFALSE 104980
// for i = 1 to tigers do
104898: LD_ADDR_VAR 0 11
104902: PUSH
104903: DOUBLE
104904: LD_INT 1
104906: DEC
104907: ST_TO_ADDR
104908: LD_VAR 0 2
104912: PUSH
104913: FOR_TO
104914: IFFALSE 104978
// begin hc_class = class_tiger ;
104916: LD_ADDR_OWVAR 28
104920: PUSH
104921: LD_INT 14
104923: ST_TO_ADDR
// hc_gallery =  ;
104924: LD_ADDR_OWVAR 33
104928: PUSH
104929: LD_STRING 
104931: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104932: LD_ADDR_OWVAR 35
104936: PUSH
104937: LD_INT 7
104939: NEG
104940: PPUSH
104941: LD_INT 7
104943: PPUSH
104944: CALL_OW 12
104948: ST_TO_ADDR
// animal := CreateHuman ;
104949: LD_ADDR_VAR 0 12
104953: PUSH
104954: CALL_OW 44
104958: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104959: LD_VAR 0 12
104963: PPUSH
104964: LD_VAR 0 8
104968: PPUSH
104969: LD_INT 0
104971: PPUSH
104972: CALL 106878 0 3
// end ;
104976: GO 104913
104978: POP
104979: POP
// if apemans then
104980: LD_VAR 0 3
104984: IFFALSE 105107
// for i = 1 to apemans do
104986: LD_ADDR_VAR 0 11
104990: PUSH
104991: DOUBLE
104992: LD_INT 1
104994: DEC
104995: ST_TO_ADDR
104996: LD_VAR 0 3
105000: PUSH
105001: FOR_TO
105002: IFFALSE 105105
// begin hc_class = class_apeman ;
105004: LD_ADDR_OWVAR 28
105008: PUSH
105009: LD_INT 12
105011: ST_TO_ADDR
// hc_gallery =  ;
105012: LD_ADDR_OWVAR 33
105016: PUSH
105017: LD_STRING 
105019: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
105020: LD_ADDR_OWVAR 35
105024: PUSH
105025: LD_INT 2
105027: NEG
105028: PPUSH
105029: LD_INT 2
105031: PPUSH
105032: CALL_OW 12
105036: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
105037: LD_ADDR_OWVAR 31
105041: PUSH
105042: LD_INT 1
105044: PPUSH
105045: LD_INT 3
105047: PPUSH
105048: CALL_OW 12
105052: PUSH
105053: LD_INT 1
105055: PPUSH
105056: LD_INT 3
105058: PPUSH
105059: CALL_OW 12
105063: PUSH
105064: LD_INT 0
105066: PUSH
105067: LD_INT 0
105069: PUSH
105070: EMPTY
105071: LIST
105072: LIST
105073: LIST
105074: LIST
105075: ST_TO_ADDR
// animal := CreateHuman ;
105076: LD_ADDR_VAR 0 12
105080: PUSH
105081: CALL_OW 44
105085: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105086: LD_VAR 0 12
105090: PPUSH
105091: LD_VAR 0 8
105095: PPUSH
105096: LD_INT 0
105098: PPUSH
105099: CALL 106878 0 3
// end ;
105103: GO 105001
105105: POP
105106: POP
// if enchidnas then
105107: LD_VAR 0 4
105111: IFFALSE 105178
// for i = 1 to enchidnas do
105113: LD_ADDR_VAR 0 11
105117: PUSH
105118: DOUBLE
105119: LD_INT 1
105121: DEC
105122: ST_TO_ADDR
105123: LD_VAR 0 4
105127: PUSH
105128: FOR_TO
105129: IFFALSE 105176
// begin hc_class = 13 ;
105131: LD_ADDR_OWVAR 28
105135: PUSH
105136: LD_INT 13
105138: ST_TO_ADDR
// hc_gallery =  ;
105139: LD_ADDR_OWVAR 33
105143: PUSH
105144: LD_STRING 
105146: ST_TO_ADDR
// animal := CreateHuman ;
105147: LD_ADDR_VAR 0 12
105151: PUSH
105152: CALL_OW 44
105156: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105157: LD_VAR 0 12
105161: PPUSH
105162: LD_VAR 0 8
105166: PPUSH
105167: LD_INT 0
105169: PPUSH
105170: CALL 106878 0 3
// end ;
105174: GO 105128
105176: POP
105177: POP
// if fishes then
105178: LD_VAR 0 7
105182: IFFALSE 105249
// for i = 1 to fishes do
105184: LD_ADDR_VAR 0 11
105188: PUSH
105189: DOUBLE
105190: LD_INT 1
105192: DEC
105193: ST_TO_ADDR
105194: LD_VAR 0 7
105198: PUSH
105199: FOR_TO
105200: IFFALSE 105247
// begin hc_class = 20 ;
105202: LD_ADDR_OWVAR 28
105206: PUSH
105207: LD_INT 20
105209: ST_TO_ADDR
// hc_gallery =  ;
105210: LD_ADDR_OWVAR 33
105214: PUSH
105215: LD_STRING 
105217: ST_TO_ADDR
// animal := CreateHuman ;
105218: LD_ADDR_VAR 0 12
105222: PUSH
105223: CALL_OW 44
105227: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
105228: LD_VAR 0 12
105232: PPUSH
105233: LD_VAR 0 9
105237: PPUSH
105238: LD_INT 0
105240: PPUSH
105241: CALL 106878 0 3
// end ;
105245: GO 105199
105247: POP
105248: POP
// end ;
105249: LD_VAR 0 10
105253: RET
// export function WantHeal ( sci , unit ) ; begin
105254: LD_INT 0
105256: PPUSH
// if GetTaskList ( sci ) > 0 then
105257: LD_VAR 0 1
105261: PPUSH
105262: CALL_OW 437
105266: PUSH
105267: LD_INT 0
105269: GREATER
105270: IFFALSE 105340
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
105272: LD_VAR 0 1
105276: PPUSH
105277: CALL_OW 437
105281: PUSH
105282: LD_INT 1
105284: ARRAY
105285: PUSH
105286: LD_INT 1
105288: ARRAY
105289: PUSH
105290: LD_STRING l
105292: EQUAL
105293: PUSH
105294: LD_VAR 0 1
105298: PPUSH
105299: CALL_OW 437
105303: PUSH
105304: LD_INT 1
105306: ARRAY
105307: PUSH
105308: LD_INT 4
105310: ARRAY
105311: PUSH
105312: LD_VAR 0 2
105316: EQUAL
105317: AND
105318: IFFALSE 105330
// result := true else
105320: LD_ADDR_VAR 0 3
105324: PUSH
105325: LD_INT 1
105327: ST_TO_ADDR
105328: GO 105338
// result := false ;
105330: LD_ADDR_VAR 0 3
105334: PUSH
105335: LD_INT 0
105337: ST_TO_ADDR
// end else
105338: GO 105348
// result := false ;
105340: LD_ADDR_VAR 0 3
105344: PUSH
105345: LD_INT 0
105347: ST_TO_ADDR
// end ;
105348: LD_VAR 0 3
105352: RET
// export function HealTarget ( sci ) ; begin
105353: LD_INT 0
105355: PPUSH
// if not sci then
105356: LD_VAR 0 1
105360: NOT
105361: IFFALSE 105365
// exit ;
105363: GO 105430
// result := 0 ;
105365: LD_ADDR_VAR 0 2
105369: PUSH
105370: LD_INT 0
105372: ST_TO_ADDR
// if GetTaskList ( sci ) then
105373: LD_VAR 0 1
105377: PPUSH
105378: CALL_OW 437
105382: IFFALSE 105430
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
105384: LD_VAR 0 1
105388: PPUSH
105389: CALL_OW 437
105393: PUSH
105394: LD_INT 1
105396: ARRAY
105397: PUSH
105398: LD_INT 1
105400: ARRAY
105401: PUSH
105402: LD_STRING l
105404: EQUAL
105405: IFFALSE 105430
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
105407: LD_ADDR_VAR 0 2
105411: PUSH
105412: LD_VAR 0 1
105416: PPUSH
105417: CALL_OW 437
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: PUSH
105426: LD_INT 4
105428: ARRAY
105429: ST_TO_ADDR
// end ;
105430: LD_VAR 0 2
105434: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105435: LD_INT 0
105437: PPUSH
105438: PPUSH
105439: PPUSH
105440: PPUSH
// if not base_units then
105441: LD_VAR 0 1
105445: NOT
105446: IFFALSE 105450
// exit ;
105448: GO 105537
// result := false ;
105450: LD_ADDR_VAR 0 2
105454: PUSH
105455: LD_INT 0
105457: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105458: LD_ADDR_VAR 0 5
105462: PUSH
105463: LD_VAR 0 1
105467: PPUSH
105468: LD_INT 21
105470: PUSH
105471: LD_INT 3
105473: PUSH
105474: EMPTY
105475: LIST
105476: LIST
105477: PPUSH
105478: CALL_OW 72
105482: ST_TO_ADDR
// if not tmp then
105483: LD_VAR 0 5
105487: NOT
105488: IFFALSE 105492
// exit ;
105490: GO 105537
// for i in tmp do
105492: LD_ADDR_VAR 0 3
105496: PUSH
105497: LD_VAR 0 5
105501: PUSH
105502: FOR_IN
105503: IFFALSE 105535
// begin result := EnemyInRange ( i , 22 ) ;
105505: LD_ADDR_VAR 0 2
105509: PUSH
105510: LD_VAR 0 3
105514: PPUSH
105515: LD_INT 22
105517: PPUSH
105518: CALL 103135 0 2
105522: ST_TO_ADDR
// if result then
105523: LD_VAR 0 2
105527: IFFALSE 105533
// exit ;
105529: POP
105530: POP
105531: GO 105537
// end ;
105533: GO 105502
105535: POP
105536: POP
// end ;
105537: LD_VAR 0 2
105541: RET
// export function FilterByTag ( units , tag ) ; begin
105542: LD_INT 0
105544: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
105545: LD_ADDR_VAR 0 3
105549: PUSH
105550: LD_VAR 0 1
105554: PPUSH
105555: LD_INT 120
105557: PUSH
105558: LD_VAR 0 2
105562: PUSH
105563: EMPTY
105564: LIST
105565: LIST
105566: PPUSH
105567: CALL_OW 72
105571: ST_TO_ADDR
// end ;
105572: LD_VAR 0 3
105576: RET
// export function IsDriver ( un ) ; begin
105577: LD_INT 0
105579: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105580: LD_ADDR_VAR 0 2
105584: PUSH
105585: LD_VAR 0 1
105589: PUSH
105590: LD_INT 55
105592: PUSH
105593: EMPTY
105594: LIST
105595: PPUSH
105596: CALL_OW 69
105600: IN
105601: ST_TO_ADDR
// end ;
105602: LD_VAR 0 2
105606: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105607: LD_INT 0
105609: PPUSH
105610: PPUSH
// list := [ ] ;
105611: LD_ADDR_VAR 0 5
105615: PUSH
105616: EMPTY
105617: ST_TO_ADDR
// case d of 0 :
105618: LD_VAR 0 3
105622: PUSH
105623: LD_INT 0
105625: DOUBLE
105626: EQUAL
105627: IFTRUE 105631
105629: GO 105764
105631: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105632: LD_ADDR_VAR 0 5
105636: PUSH
105637: LD_VAR 0 1
105641: PUSH
105642: LD_INT 4
105644: MINUS
105645: PUSH
105646: LD_VAR 0 2
105650: PUSH
105651: LD_INT 4
105653: MINUS
105654: PUSH
105655: LD_INT 2
105657: PUSH
105658: EMPTY
105659: LIST
105660: LIST
105661: LIST
105662: PUSH
105663: LD_VAR 0 1
105667: PUSH
105668: LD_INT 3
105670: MINUS
105671: PUSH
105672: LD_VAR 0 2
105676: PUSH
105677: LD_INT 1
105679: PUSH
105680: EMPTY
105681: LIST
105682: LIST
105683: LIST
105684: PUSH
105685: LD_VAR 0 1
105689: PUSH
105690: LD_INT 4
105692: PLUS
105693: PUSH
105694: LD_VAR 0 2
105698: PUSH
105699: LD_INT 4
105701: PUSH
105702: EMPTY
105703: LIST
105704: LIST
105705: LIST
105706: PUSH
105707: LD_VAR 0 1
105711: PUSH
105712: LD_INT 3
105714: PLUS
105715: PUSH
105716: LD_VAR 0 2
105720: PUSH
105721: LD_INT 3
105723: PLUS
105724: PUSH
105725: LD_INT 5
105727: PUSH
105728: EMPTY
105729: LIST
105730: LIST
105731: LIST
105732: PUSH
105733: LD_VAR 0 1
105737: PUSH
105738: LD_VAR 0 2
105742: PUSH
105743: LD_INT 4
105745: PLUS
105746: PUSH
105747: LD_INT 0
105749: PUSH
105750: EMPTY
105751: LIST
105752: LIST
105753: LIST
105754: PUSH
105755: EMPTY
105756: LIST
105757: LIST
105758: LIST
105759: LIST
105760: LIST
105761: ST_TO_ADDR
// end ; 1 :
105762: GO 106462
105764: LD_INT 1
105766: DOUBLE
105767: EQUAL
105768: IFTRUE 105772
105770: GO 105905
105772: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105773: LD_ADDR_VAR 0 5
105777: PUSH
105778: LD_VAR 0 1
105782: PUSH
105783: LD_VAR 0 2
105787: PUSH
105788: LD_INT 4
105790: MINUS
105791: PUSH
105792: LD_INT 3
105794: PUSH
105795: EMPTY
105796: LIST
105797: LIST
105798: LIST
105799: PUSH
105800: LD_VAR 0 1
105804: PUSH
105805: LD_INT 3
105807: MINUS
105808: PUSH
105809: LD_VAR 0 2
105813: PUSH
105814: LD_INT 3
105816: MINUS
105817: PUSH
105818: LD_INT 2
105820: PUSH
105821: EMPTY
105822: LIST
105823: LIST
105824: LIST
105825: PUSH
105826: LD_VAR 0 1
105830: PUSH
105831: LD_INT 4
105833: MINUS
105834: PUSH
105835: LD_VAR 0 2
105839: PUSH
105840: LD_INT 1
105842: PUSH
105843: EMPTY
105844: LIST
105845: LIST
105846: LIST
105847: PUSH
105848: LD_VAR 0 1
105852: PUSH
105853: LD_VAR 0 2
105857: PUSH
105858: LD_INT 3
105860: PLUS
105861: PUSH
105862: LD_INT 0
105864: PUSH
105865: EMPTY
105866: LIST
105867: LIST
105868: LIST
105869: PUSH
105870: LD_VAR 0 1
105874: PUSH
105875: LD_INT 4
105877: PLUS
105878: PUSH
105879: LD_VAR 0 2
105883: PUSH
105884: LD_INT 4
105886: PLUS
105887: PUSH
105888: LD_INT 5
105890: PUSH
105891: EMPTY
105892: LIST
105893: LIST
105894: LIST
105895: PUSH
105896: EMPTY
105897: LIST
105898: LIST
105899: LIST
105900: LIST
105901: LIST
105902: ST_TO_ADDR
// end ; 2 :
105903: GO 106462
105905: LD_INT 2
105907: DOUBLE
105908: EQUAL
105909: IFTRUE 105913
105911: GO 106042
105913: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105914: LD_ADDR_VAR 0 5
105918: PUSH
105919: LD_VAR 0 1
105923: PUSH
105924: LD_VAR 0 2
105928: PUSH
105929: LD_INT 3
105931: MINUS
105932: PUSH
105933: LD_INT 3
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: LIST
105940: PUSH
105941: LD_VAR 0 1
105945: PUSH
105946: LD_INT 4
105948: PLUS
105949: PUSH
105950: LD_VAR 0 2
105954: PUSH
105955: LD_INT 4
105957: PUSH
105958: EMPTY
105959: LIST
105960: LIST
105961: LIST
105962: PUSH
105963: LD_VAR 0 1
105967: PUSH
105968: LD_VAR 0 2
105972: PUSH
105973: LD_INT 4
105975: PLUS
105976: PUSH
105977: LD_INT 0
105979: PUSH
105980: EMPTY
105981: LIST
105982: LIST
105983: LIST
105984: PUSH
105985: LD_VAR 0 1
105989: PUSH
105990: LD_INT 3
105992: MINUS
105993: PUSH
105994: LD_VAR 0 2
105998: PUSH
105999: LD_INT 1
106001: PUSH
106002: EMPTY
106003: LIST
106004: LIST
106005: LIST
106006: PUSH
106007: LD_VAR 0 1
106011: PUSH
106012: LD_INT 4
106014: MINUS
106015: PUSH
106016: LD_VAR 0 2
106020: PUSH
106021: LD_INT 4
106023: MINUS
106024: PUSH
106025: LD_INT 2
106027: PUSH
106028: EMPTY
106029: LIST
106030: LIST
106031: LIST
106032: PUSH
106033: EMPTY
106034: LIST
106035: LIST
106036: LIST
106037: LIST
106038: LIST
106039: ST_TO_ADDR
// end ; 3 :
106040: GO 106462
106042: LD_INT 3
106044: DOUBLE
106045: EQUAL
106046: IFTRUE 106050
106048: GO 106183
106050: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106051: LD_ADDR_VAR 0 5
106055: PUSH
106056: LD_VAR 0 1
106060: PUSH
106061: LD_INT 3
106063: PLUS
106064: PUSH
106065: LD_VAR 0 2
106069: PUSH
106070: LD_INT 4
106072: PUSH
106073: EMPTY
106074: LIST
106075: LIST
106076: LIST
106077: PUSH
106078: LD_VAR 0 1
106082: PUSH
106083: LD_INT 4
106085: PLUS
106086: PUSH
106087: LD_VAR 0 2
106091: PUSH
106092: LD_INT 4
106094: PLUS
106095: PUSH
106096: LD_INT 5
106098: PUSH
106099: EMPTY
106100: LIST
106101: LIST
106102: LIST
106103: PUSH
106104: LD_VAR 0 1
106108: PUSH
106109: LD_INT 4
106111: MINUS
106112: PUSH
106113: LD_VAR 0 2
106117: PUSH
106118: LD_INT 1
106120: PUSH
106121: EMPTY
106122: LIST
106123: LIST
106124: LIST
106125: PUSH
106126: LD_VAR 0 1
106130: PUSH
106131: LD_VAR 0 2
106135: PUSH
106136: LD_INT 4
106138: MINUS
106139: PUSH
106140: LD_INT 3
106142: PUSH
106143: EMPTY
106144: LIST
106145: LIST
106146: LIST
106147: PUSH
106148: LD_VAR 0 1
106152: PUSH
106153: LD_INT 3
106155: MINUS
106156: PUSH
106157: LD_VAR 0 2
106161: PUSH
106162: LD_INT 3
106164: MINUS
106165: PUSH
106166: LD_INT 2
106168: PUSH
106169: EMPTY
106170: LIST
106171: LIST
106172: LIST
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: LIST
106178: LIST
106179: LIST
106180: ST_TO_ADDR
// end ; 4 :
106181: GO 106462
106183: LD_INT 4
106185: DOUBLE
106186: EQUAL
106187: IFTRUE 106191
106189: GO 106324
106191: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106192: LD_ADDR_VAR 0 5
106196: PUSH
106197: LD_VAR 0 1
106201: PUSH
106202: LD_VAR 0 2
106206: PUSH
106207: LD_INT 4
106209: PLUS
106210: PUSH
106211: LD_INT 0
106213: PUSH
106214: EMPTY
106215: LIST
106216: LIST
106217: LIST
106218: PUSH
106219: LD_VAR 0 1
106223: PUSH
106224: LD_INT 3
106226: PLUS
106227: PUSH
106228: LD_VAR 0 2
106232: PUSH
106233: LD_INT 3
106235: PLUS
106236: PUSH
106237: LD_INT 5
106239: PUSH
106240: EMPTY
106241: LIST
106242: LIST
106243: LIST
106244: PUSH
106245: LD_VAR 0 1
106249: PUSH
106250: LD_INT 4
106252: PLUS
106253: PUSH
106254: LD_VAR 0 2
106258: PUSH
106259: LD_INT 4
106261: PUSH
106262: EMPTY
106263: LIST
106264: LIST
106265: LIST
106266: PUSH
106267: LD_VAR 0 1
106271: PUSH
106272: LD_VAR 0 2
106276: PUSH
106277: LD_INT 3
106279: MINUS
106280: PUSH
106281: LD_INT 3
106283: PUSH
106284: EMPTY
106285: LIST
106286: LIST
106287: LIST
106288: PUSH
106289: LD_VAR 0 1
106293: PUSH
106294: LD_INT 4
106296: MINUS
106297: PUSH
106298: LD_VAR 0 2
106302: PUSH
106303: LD_INT 4
106305: MINUS
106306: PUSH
106307: LD_INT 2
106309: PUSH
106310: EMPTY
106311: LIST
106312: LIST
106313: LIST
106314: PUSH
106315: EMPTY
106316: LIST
106317: LIST
106318: LIST
106319: LIST
106320: LIST
106321: ST_TO_ADDR
// end ; 5 :
106322: GO 106462
106324: LD_INT 5
106326: DOUBLE
106327: EQUAL
106328: IFTRUE 106332
106330: GO 106461
106332: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106333: LD_ADDR_VAR 0 5
106337: PUSH
106338: LD_VAR 0 1
106342: PUSH
106343: LD_INT 4
106345: MINUS
106346: PUSH
106347: LD_VAR 0 2
106351: PUSH
106352: LD_INT 1
106354: PUSH
106355: EMPTY
106356: LIST
106357: LIST
106358: LIST
106359: PUSH
106360: LD_VAR 0 1
106364: PUSH
106365: LD_VAR 0 2
106369: PUSH
106370: LD_INT 4
106372: MINUS
106373: PUSH
106374: LD_INT 3
106376: PUSH
106377: EMPTY
106378: LIST
106379: LIST
106380: LIST
106381: PUSH
106382: LD_VAR 0 1
106386: PUSH
106387: LD_INT 4
106389: PLUS
106390: PUSH
106391: LD_VAR 0 2
106395: PUSH
106396: LD_INT 4
106398: PLUS
106399: PUSH
106400: LD_INT 5
106402: PUSH
106403: EMPTY
106404: LIST
106405: LIST
106406: LIST
106407: PUSH
106408: LD_VAR 0 1
106412: PUSH
106413: LD_INT 3
106415: PLUS
106416: PUSH
106417: LD_VAR 0 2
106421: PUSH
106422: LD_INT 4
106424: PUSH
106425: EMPTY
106426: LIST
106427: LIST
106428: LIST
106429: PUSH
106430: LD_VAR 0 1
106434: PUSH
106435: LD_VAR 0 2
106439: PUSH
106440: LD_INT 3
106442: PLUS
106443: PUSH
106444: LD_INT 0
106446: PUSH
106447: EMPTY
106448: LIST
106449: LIST
106450: LIST
106451: PUSH
106452: EMPTY
106453: LIST
106454: LIST
106455: LIST
106456: LIST
106457: LIST
106458: ST_TO_ADDR
// end ; end ;
106459: GO 106462
106461: POP
// result := list ;
106462: LD_ADDR_VAR 0 4
106466: PUSH
106467: LD_VAR 0 5
106471: ST_TO_ADDR
// end ;
106472: LD_VAR 0 4
106476: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106477: LD_INT 0
106479: PPUSH
106480: PPUSH
106481: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106482: LD_VAR 0 1
106486: NOT
106487: PUSH
106488: LD_VAR 0 2
106492: PUSH
106493: LD_INT 1
106495: PUSH
106496: LD_INT 2
106498: PUSH
106499: LD_INT 3
106501: PUSH
106502: LD_INT 4
106504: PUSH
106505: EMPTY
106506: LIST
106507: LIST
106508: LIST
106509: LIST
106510: IN
106511: NOT
106512: OR
106513: IFFALSE 106517
// exit ;
106515: GO 106600
// tmp := [ ] ;
106517: LD_ADDR_VAR 0 5
106521: PUSH
106522: EMPTY
106523: ST_TO_ADDR
// for i in units do
106524: LD_ADDR_VAR 0 4
106528: PUSH
106529: LD_VAR 0 1
106533: PUSH
106534: FOR_IN
106535: IFFALSE 106569
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
106537: LD_ADDR_VAR 0 5
106541: PUSH
106542: LD_VAR 0 5
106546: PPUSH
106547: LD_VAR 0 4
106551: PPUSH
106552: LD_VAR 0 2
106556: PPUSH
106557: CALL_OW 259
106561: PPUSH
106562: CALL 107973 0 2
106566: ST_TO_ADDR
106567: GO 106534
106569: POP
106570: POP
// if not tmp then
106571: LD_VAR 0 5
106575: NOT
106576: IFFALSE 106580
// exit ;
106578: GO 106600
// result := SortListByListDesc ( units , tmp ) ;
106580: LD_ADDR_VAR 0 3
106584: PUSH
106585: LD_VAR 0 1
106589: PPUSH
106590: LD_VAR 0 5
106594: PPUSH
106595: CALL_OW 77
106599: ST_TO_ADDR
// end ;
106600: LD_VAR 0 3
106604: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106605: LD_INT 0
106607: PPUSH
106608: PPUSH
106609: PPUSH
// result := false ;
106610: LD_ADDR_VAR 0 3
106614: PUSH
106615: LD_INT 0
106617: ST_TO_ADDR
// if not building then
106618: LD_VAR 0 2
106622: NOT
106623: IFFALSE 106627
// exit ;
106625: GO 106765
// x := GetX ( building ) ;
106627: LD_ADDR_VAR 0 4
106631: PUSH
106632: LD_VAR 0 2
106636: PPUSH
106637: CALL_OW 250
106641: ST_TO_ADDR
// y := GetY ( building ) ;
106642: LD_ADDR_VAR 0 5
106646: PUSH
106647: LD_VAR 0 2
106651: PPUSH
106652: CALL_OW 251
106656: ST_TO_ADDR
// if not x or not y then
106657: LD_VAR 0 4
106661: NOT
106662: PUSH
106663: LD_VAR 0 5
106667: NOT
106668: OR
106669: IFFALSE 106673
// exit ;
106671: GO 106765
// if GetTaskList ( unit ) then
106673: LD_VAR 0 1
106677: PPUSH
106678: CALL_OW 437
106682: IFFALSE 106765
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106684: LD_STRING e
106686: PUSH
106687: LD_VAR 0 1
106691: PPUSH
106692: CALL_OW 437
106696: PUSH
106697: LD_INT 1
106699: ARRAY
106700: PUSH
106701: LD_INT 1
106703: ARRAY
106704: EQUAL
106705: PUSH
106706: LD_VAR 0 4
106710: PUSH
106711: LD_VAR 0 1
106715: PPUSH
106716: CALL_OW 437
106720: PUSH
106721: LD_INT 1
106723: ARRAY
106724: PUSH
106725: LD_INT 2
106727: ARRAY
106728: EQUAL
106729: AND
106730: PUSH
106731: LD_VAR 0 5
106735: PUSH
106736: LD_VAR 0 1
106740: PPUSH
106741: CALL_OW 437
106745: PUSH
106746: LD_INT 1
106748: ARRAY
106749: PUSH
106750: LD_INT 3
106752: ARRAY
106753: EQUAL
106754: AND
106755: IFFALSE 106765
// result := true end ;
106757: LD_ADDR_VAR 0 3
106761: PUSH
106762: LD_INT 1
106764: ST_TO_ADDR
// end ;
106765: LD_VAR 0 3
106769: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106770: LD_INT 0
106772: PPUSH
// result := false ;
106773: LD_ADDR_VAR 0 4
106777: PUSH
106778: LD_INT 0
106780: ST_TO_ADDR
// if GetTaskList ( unit ) then
106781: LD_VAR 0 1
106785: PPUSH
106786: CALL_OW 437
106790: IFFALSE 106873
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106792: LD_STRING M
106794: PUSH
106795: LD_VAR 0 1
106799: PPUSH
106800: CALL_OW 437
106804: PUSH
106805: LD_INT 1
106807: ARRAY
106808: PUSH
106809: LD_INT 1
106811: ARRAY
106812: EQUAL
106813: PUSH
106814: LD_VAR 0 2
106818: PUSH
106819: LD_VAR 0 1
106823: PPUSH
106824: CALL_OW 437
106828: PUSH
106829: LD_INT 1
106831: ARRAY
106832: PUSH
106833: LD_INT 2
106835: ARRAY
106836: EQUAL
106837: AND
106838: PUSH
106839: LD_VAR 0 3
106843: PUSH
106844: LD_VAR 0 1
106848: PPUSH
106849: CALL_OW 437
106853: PUSH
106854: LD_INT 1
106856: ARRAY
106857: PUSH
106858: LD_INT 3
106860: ARRAY
106861: EQUAL
106862: AND
106863: IFFALSE 106873
// result := true ;
106865: LD_ADDR_VAR 0 4
106869: PUSH
106870: LD_INT 1
106872: ST_TO_ADDR
// end ; end ;
106873: LD_VAR 0 4
106877: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106878: LD_INT 0
106880: PPUSH
106881: PPUSH
106882: PPUSH
106883: PPUSH
// if not unit or not area then
106884: LD_VAR 0 1
106888: NOT
106889: PUSH
106890: LD_VAR 0 2
106894: NOT
106895: OR
106896: IFFALSE 106900
// exit ;
106898: GO 107076
// tmp := AreaToList ( area , i ) ;
106900: LD_ADDR_VAR 0 6
106904: PUSH
106905: LD_VAR 0 2
106909: PPUSH
106910: LD_VAR 0 5
106914: PPUSH
106915: CALL_OW 517
106919: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106920: LD_ADDR_VAR 0 5
106924: PUSH
106925: DOUBLE
106926: LD_INT 1
106928: DEC
106929: ST_TO_ADDR
106930: LD_VAR 0 6
106934: PUSH
106935: LD_INT 1
106937: ARRAY
106938: PUSH
106939: FOR_TO
106940: IFFALSE 107074
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106942: LD_ADDR_VAR 0 7
106946: PUSH
106947: LD_VAR 0 6
106951: PUSH
106952: LD_INT 1
106954: ARRAY
106955: PUSH
106956: LD_VAR 0 5
106960: ARRAY
106961: PUSH
106962: LD_VAR 0 6
106966: PUSH
106967: LD_INT 2
106969: ARRAY
106970: PUSH
106971: LD_VAR 0 5
106975: ARRAY
106976: PUSH
106977: EMPTY
106978: LIST
106979: LIST
106980: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106981: LD_INT 92
106983: PUSH
106984: LD_VAR 0 7
106988: PUSH
106989: LD_INT 1
106991: ARRAY
106992: PUSH
106993: LD_VAR 0 7
106997: PUSH
106998: LD_INT 2
107000: ARRAY
107001: PUSH
107002: LD_INT 2
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: LIST
107009: LIST
107010: PPUSH
107011: CALL_OW 69
107015: PUSH
107016: LD_INT 0
107018: EQUAL
107019: IFFALSE 107072
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107021: LD_VAR 0 1
107025: PPUSH
107026: LD_VAR 0 7
107030: PUSH
107031: LD_INT 1
107033: ARRAY
107034: PPUSH
107035: LD_VAR 0 7
107039: PUSH
107040: LD_INT 2
107042: ARRAY
107043: PPUSH
107044: LD_VAR 0 3
107048: PPUSH
107049: CALL_OW 48
// result := IsPlaced ( unit ) ;
107053: LD_ADDR_VAR 0 4
107057: PUSH
107058: LD_VAR 0 1
107062: PPUSH
107063: CALL_OW 305
107067: ST_TO_ADDR
// exit ;
107068: POP
107069: POP
107070: GO 107076
// end ; end ;
107072: GO 106939
107074: POP
107075: POP
// end ;
107076: LD_VAR 0 4
107080: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107081: LD_INT 0
107083: PPUSH
107084: PPUSH
107085: PPUSH
// if not side or side > 8 then
107086: LD_VAR 0 1
107090: NOT
107091: PUSH
107092: LD_VAR 0 1
107096: PUSH
107097: LD_INT 8
107099: GREATER
107100: OR
107101: IFFALSE 107105
// exit ;
107103: GO 107292
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107105: LD_ADDR_VAR 0 4
107109: PUSH
107110: LD_INT 22
107112: PUSH
107113: LD_VAR 0 1
107117: PUSH
107118: EMPTY
107119: LIST
107120: LIST
107121: PUSH
107122: LD_INT 21
107124: PUSH
107125: LD_INT 3
107127: PUSH
107128: EMPTY
107129: LIST
107130: LIST
107131: PUSH
107132: EMPTY
107133: LIST
107134: LIST
107135: PPUSH
107136: CALL_OW 69
107140: ST_TO_ADDR
// if not tmp then
107141: LD_VAR 0 4
107145: NOT
107146: IFFALSE 107150
// exit ;
107148: GO 107292
// enable_addtolog := true ;
107150: LD_ADDR_OWVAR 81
107154: PUSH
107155: LD_INT 1
107157: ST_TO_ADDR
// AddToLog ( [ ) ;
107158: LD_STRING [
107160: PPUSH
107161: CALL_OW 561
// for i in tmp do
107165: LD_ADDR_VAR 0 3
107169: PUSH
107170: LD_VAR 0 4
107174: PUSH
107175: FOR_IN
107176: IFFALSE 107283
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107178: LD_STRING [
107180: PUSH
107181: LD_VAR 0 3
107185: PPUSH
107186: CALL_OW 266
107190: STR
107191: PUSH
107192: LD_STRING , 
107194: STR
107195: PUSH
107196: LD_VAR 0 3
107200: PPUSH
107201: CALL_OW 250
107205: STR
107206: PUSH
107207: LD_STRING , 
107209: STR
107210: PUSH
107211: LD_VAR 0 3
107215: PPUSH
107216: CALL_OW 251
107220: STR
107221: PUSH
107222: LD_STRING , 
107224: STR
107225: PUSH
107226: LD_VAR 0 3
107230: PPUSH
107231: CALL_OW 254
107235: STR
107236: PUSH
107237: LD_STRING , 
107239: STR
107240: PUSH
107241: LD_VAR 0 3
107245: PPUSH
107246: LD_INT 1
107248: PPUSH
107249: CALL_OW 268
107253: STR
107254: PUSH
107255: LD_STRING , 
107257: STR
107258: PUSH
107259: LD_VAR 0 3
107263: PPUSH
107264: LD_INT 2
107266: PPUSH
107267: CALL_OW 268
107271: STR
107272: PUSH
107273: LD_STRING ],
107275: STR
107276: PPUSH
107277: CALL_OW 561
// end ;
107281: GO 107175
107283: POP
107284: POP
// AddToLog ( ]; ) ;
107285: LD_STRING ];
107287: PPUSH
107288: CALL_OW 561
// end ;
107292: LD_VAR 0 2
107296: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107297: LD_INT 0
107299: PPUSH
107300: PPUSH
107301: PPUSH
107302: PPUSH
107303: PPUSH
// if not area or not rate or not max then
107304: LD_VAR 0 1
107308: NOT
107309: PUSH
107310: LD_VAR 0 2
107314: NOT
107315: OR
107316: PUSH
107317: LD_VAR 0 4
107321: NOT
107322: OR
107323: IFFALSE 107327
// exit ;
107325: GO 107516
// while 1 do
107327: LD_INT 1
107329: IFFALSE 107516
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107331: LD_ADDR_VAR 0 9
107335: PUSH
107336: LD_VAR 0 1
107340: PPUSH
107341: LD_INT 1
107343: PPUSH
107344: CALL_OW 287
107348: PUSH
107349: LD_INT 10
107351: MUL
107352: ST_TO_ADDR
// r := rate / 10 ;
107353: LD_ADDR_VAR 0 7
107357: PUSH
107358: LD_VAR 0 2
107362: PUSH
107363: LD_INT 10
107365: DIVREAL
107366: ST_TO_ADDR
// time := 1 1$00 ;
107367: LD_ADDR_VAR 0 8
107371: PUSH
107372: LD_INT 2100
107374: ST_TO_ADDR
// if amount < min then
107375: LD_VAR 0 9
107379: PUSH
107380: LD_VAR 0 3
107384: LESS
107385: IFFALSE 107403
// r := r * 2 else
107387: LD_ADDR_VAR 0 7
107391: PUSH
107392: LD_VAR 0 7
107396: PUSH
107397: LD_INT 2
107399: MUL
107400: ST_TO_ADDR
107401: GO 107429
// if amount > max then
107403: LD_VAR 0 9
107407: PUSH
107408: LD_VAR 0 4
107412: GREATER
107413: IFFALSE 107429
// r := r / 2 ;
107415: LD_ADDR_VAR 0 7
107419: PUSH
107420: LD_VAR 0 7
107424: PUSH
107425: LD_INT 2
107427: DIVREAL
107428: ST_TO_ADDR
// time := time / r ;
107429: LD_ADDR_VAR 0 8
107433: PUSH
107434: LD_VAR 0 8
107438: PUSH
107439: LD_VAR 0 7
107443: DIVREAL
107444: ST_TO_ADDR
// if time < 0 then
107445: LD_VAR 0 8
107449: PUSH
107450: LD_INT 0
107452: LESS
107453: IFFALSE 107470
// time := time * - 1 ;
107455: LD_ADDR_VAR 0 8
107459: PUSH
107460: LD_VAR 0 8
107464: PUSH
107465: LD_INT 1
107467: NEG
107468: MUL
107469: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
107470: LD_VAR 0 8
107474: PUSH
107475: LD_INT 35
107477: PPUSH
107478: LD_INT 875
107480: PPUSH
107481: CALL_OW 12
107485: PLUS
107486: PPUSH
107487: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107491: LD_INT 1
107493: PPUSH
107494: LD_INT 5
107496: PPUSH
107497: CALL_OW 12
107501: PPUSH
107502: LD_VAR 0 1
107506: PPUSH
107507: LD_INT 1
107509: PPUSH
107510: CALL_OW 55
// end ;
107514: GO 107327
// end ;
107516: LD_VAR 0 5
107520: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107521: LD_INT 0
107523: PPUSH
107524: PPUSH
107525: PPUSH
107526: PPUSH
107527: PPUSH
107528: PPUSH
107529: PPUSH
107530: PPUSH
// if not turrets or not factories then
107531: LD_VAR 0 1
107535: NOT
107536: PUSH
107537: LD_VAR 0 2
107541: NOT
107542: OR
107543: IFFALSE 107547
// exit ;
107545: GO 107854
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107547: LD_ADDR_VAR 0 10
107551: PUSH
107552: LD_INT 5
107554: PUSH
107555: LD_INT 6
107557: PUSH
107558: EMPTY
107559: LIST
107560: LIST
107561: PUSH
107562: LD_INT 2
107564: PUSH
107565: LD_INT 4
107567: PUSH
107568: EMPTY
107569: LIST
107570: LIST
107571: PUSH
107572: LD_INT 3
107574: PUSH
107575: LD_INT 5
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PUSH
107582: EMPTY
107583: LIST
107584: LIST
107585: LIST
107586: PUSH
107587: LD_INT 24
107589: PUSH
107590: LD_INT 25
107592: PUSH
107593: EMPTY
107594: LIST
107595: LIST
107596: PUSH
107597: LD_INT 23
107599: PUSH
107600: LD_INT 27
107602: PUSH
107603: EMPTY
107604: LIST
107605: LIST
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: PUSH
107611: LD_INT 42
107613: PUSH
107614: LD_INT 43
107616: PUSH
107617: EMPTY
107618: LIST
107619: LIST
107620: PUSH
107621: LD_INT 44
107623: PUSH
107624: LD_INT 46
107626: PUSH
107627: EMPTY
107628: LIST
107629: LIST
107630: PUSH
107631: LD_INT 45
107633: PUSH
107634: LD_INT 47
107636: PUSH
107637: EMPTY
107638: LIST
107639: LIST
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: LIST
107645: PUSH
107646: EMPTY
107647: LIST
107648: LIST
107649: LIST
107650: ST_TO_ADDR
// result := [ ] ;
107651: LD_ADDR_VAR 0 3
107655: PUSH
107656: EMPTY
107657: ST_TO_ADDR
// for i in turrets do
107658: LD_ADDR_VAR 0 4
107662: PUSH
107663: LD_VAR 0 1
107667: PUSH
107668: FOR_IN
107669: IFFALSE 107852
// begin nat := GetNation ( i ) ;
107671: LD_ADDR_VAR 0 7
107675: PUSH
107676: LD_VAR 0 4
107680: PPUSH
107681: CALL_OW 248
107685: ST_TO_ADDR
// weapon := 0 ;
107686: LD_ADDR_VAR 0 8
107690: PUSH
107691: LD_INT 0
107693: ST_TO_ADDR
// if not nat then
107694: LD_VAR 0 7
107698: NOT
107699: IFFALSE 107703
// continue ;
107701: GO 107668
// for j in list [ nat ] do
107703: LD_ADDR_VAR 0 5
107707: PUSH
107708: LD_VAR 0 10
107712: PUSH
107713: LD_VAR 0 7
107717: ARRAY
107718: PUSH
107719: FOR_IN
107720: IFFALSE 107761
// if GetBWeapon ( i ) = j [ 1 ] then
107722: LD_VAR 0 4
107726: PPUSH
107727: CALL_OW 269
107731: PUSH
107732: LD_VAR 0 5
107736: PUSH
107737: LD_INT 1
107739: ARRAY
107740: EQUAL
107741: IFFALSE 107759
// begin weapon := j [ 2 ] ;
107743: LD_ADDR_VAR 0 8
107747: PUSH
107748: LD_VAR 0 5
107752: PUSH
107753: LD_INT 2
107755: ARRAY
107756: ST_TO_ADDR
// break ;
107757: GO 107761
// end ;
107759: GO 107719
107761: POP
107762: POP
// if not weapon then
107763: LD_VAR 0 8
107767: NOT
107768: IFFALSE 107772
// continue ;
107770: GO 107668
// for k in factories do
107772: LD_ADDR_VAR 0 6
107776: PUSH
107777: LD_VAR 0 2
107781: PUSH
107782: FOR_IN
107783: IFFALSE 107848
// begin weapons := AvailableWeaponList ( k ) ;
107785: LD_ADDR_VAR 0 9
107789: PUSH
107790: LD_VAR 0 6
107794: PPUSH
107795: CALL_OW 478
107799: ST_TO_ADDR
// if not weapons then
107800: LD_VAR 0 9
107804: NOT
107805: IFFALSE 107809
// continue ;
107807: GO 107782
// if weapon in weapons then
107809: LD_VAR 0 8
107813: PUSH
107814: LD_VAR 0 9
107818: IN
107819: IFFALSE 107846
// begin result := [ i , weapon ] ;
107821: LD_ADDR_VAR 0 3
107825: PUSH
107826: LD_VAR 0 4
107830: PUSH
107831: LD_VAR 0 8
107835: PUSH
107836: EMPTY
107837: LIST
107838: LIST
107839: ST_TO_ADDR
// exit ;
107840: POP
107841: POP
107842: POP
107843: POP
107844: GO 107854
// end ; end ;
107846: GO 107782
107848: POP
107849: POP
// end ;
107850: GO 107668
107852: POP
107853: POP
// end ;
107854: LD_VAR 0 3
107858: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107859: LD_INT 0
107861: PPUSH
// if not side or side > 8 then
107862: LD_VAR 0 3
107866: NOT
107867: PUSH
107868: LD_VAR 0 3
107872: PUSH
107873: LD_INT 8
107875: GREATER
107876: OR
107877: IFFALSE 107881
// exit ;
107879: GO 107940
// if not range then
107881: LD_VAR 0 4
107885: NOT
107886: IFFALSE 107897
// range := - 12 ;
107888: LD_ADDR_VAR 0 4
107892: PUSH
107893: LD_INT 12
107895: NEG
107896: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107897: LD_VAR 0 1
107901: PPUSH
107902: LD_VAR 0 2
107906: PPUSH
107907: LD_VAR 0 3
107911: PPUSH
107912: LD_VAR 0 4
107916: PPUSH
107917: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107921: LD_VAR 0 1
107925: PPUSH
107926: LD_VAR 0 2
107930: PPUSH
107931: LD_VAR 0 3
107935: PPUSH
107936: CALL_OW 331
// end ;
107940: LD_VAR 0 5
107944: RET
// export function Video ( mode ) ; begin
107945: LD_INT 0
107947: PPUSH
// ingame_video = mode ;
107948: LD_ADDR_OWVAR 52
107952: PUSH
107953: LD_VAR 0 1
107957: ST_TO_ADDR
// interface_hidden = mode ;
107958: LD_ADDR_OWVAR 54
107962: PUSH
107963: LD_VAR 0 1
107967: ST_TO_ADDR
// end ;
107968: LD_VAR 0 2
107972: RET
// export function Join ( array , element ) ; begin
107973: LD_INT 0
107975: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107976: LD_ADDR_VAR 0 3
107980: PUSH
107981: LD_VAR 0 1
107985: PPUSH
107986: LD_VAR 0 1
107990: PUSH
107991: LD_INT 1
107993: PLUS
107994: PPUSH
107995: LD_VAR 0 2
107999: PPUSH
108000: CALL_OW 1
108004: ST_TO_ADDR
// end ;
108005: LD_VAR 0 3
108009: RET
// export function JoinUnion ( array , element ) ; begin
108010: LD_INT 0
108012: PPUSH
// result := array union element ;
108013: LD_ADDR_VAR 0 3
108017: PUSH
108018: LD_VAR 0 1
108022: PUSH
108023: LD_VAR 0 2
108027: UNION
108028: ST_TO_ADDR
// end ;
108029: LD_VAR 0 3
108033: RET
// export function GetBehemoths ( side ) ; begin
108034: LD_INT 0
108036: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
108037: LD_ADDR_VAR 0 2
108041: PUSH
108042: LD_INT 22
108044: PUSH
108045: LD_VAR 0 1
108049: PUSH
108050: EMPTY
108051: LIST
108052: LIST
108053: PUSH
108054: LD_INT 31
108056: PUSH
108057: LD_INT 25
108059: PUSH
108060: EMPTY
108061: LIST
108062: LIST
108063: PUSH
108064: EMPTY
108065: LIST
108066: LIST
108067: PPUSH
108068: CALL_OW 69
108072: ST_TO_ADDR
// end ;
108073: LD_VAR 0 2
108077: RET
// export function Shuffle ( array ) ; var i , index ; begin
108078: LD_INT 0
108080: PPUSH
108081: PPUSH
108082: PPUSH
// result := [ ] ;
108083: LD_ADDR_VAR 0 2
108087: PUSH
108088: EMPTY
108089: ST_TO_ADDR
// if not array then
108090: LD_VAR 0 1
108094: NOT
108095: IFFALSE 108099
// exit ;
108097: GO 108198
// Randomize ;
108099: CALL_OW 10
// for i = array downto 1 do
108103: LD_ADDR_VAR 0 3
108107: PUSH
108108: DOUBLE
108109: LD_VAR 0 1
108113: INC
108114: ST_TO_ADDR
108115: LD_INT 1
108117: PUSH
108118: FOR_DOWNTO
108119: IFFALSE 108196
// begin index := rand ( 1 , array ) ;
108121: LD_ADDR_VAR 0 4
108125: PUSH
108126: LD_INT 1
108128: PPUSH
108129: LD_VAR 0 1
108133: PPUSH
108134: CALL_OW 12
108138: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108139: LD_ADDR_VAR 0 2
108143: PUSH
108144: LD_VAR 0 2
108148: PPUSH
108149: LD_VAR 0 2
108153: PUSH
108154: LD_INT 1
108156: PLUS
108157: PPUSH
108158: LD_VAR 0 1
108162: PUSH
108163: LD_VAR 0 4
108167: ARRAY
108168: PPUSH
108169: CALL_OW 2
108173: ST_TO_ADDR
// array := Delete ( array , index ) ;
108174: LD_ADDR_VAR 0 1
108178: PUSH
108179: LD_VAR 0 1
108183: PPUSH
108184: LD_VAR 0 4
108188: PPUSH
108189: CALL_OW 3
108193: ST_TO_ADDR
// end ;
108194: GO 108118
108196: POP
108197: POP
// end ;
108198: LD_VAR 0 2
108202: RET
// export function GetBaseMaterials ( base ) ; begin
108203: LD_INT 0
108205: PPUSH
// result := [ 0 , 0 , 0 ] ;
108206: LD_ADDR_VAR 0 2
108210: PUSH
108211: LD_INT 0
108213: PUSH
108214: LD_INT 0
108216: PUSH
108217: LD_INT 0
108219: PUSH
108220: EMPTY
108221: LIST
108222: LIST
108223: LIST
108224: ST_TO_ADDR
// if not base then
108225: LD_VAR 0 1
108229: NOT
108230: IFFALSE 108234
// exit ;
108232: GO 108283
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108234: LD_ADDR_VAR 0 2
108238: PUSH
108239: LD_VAR 0 1
108243: PPUSH
108244: LD_INT 1
108246: PPUSH
108247: CALL_OW 275
108251: PUSH
108252: LD_VAR 0 1
108256: PPUSH
108257: LD_INT 2
108259: PPUSH
108260: CALL_OW 275
108264: PUSH
108265: LD_VAR 0 1
108269: PPUSH
108270: LD_INT 3
108272: PPUSH
108273: CALL_OW 275
108277: PUSH
108278: EMPTY
108279: LIST
108280: LIST
108281: LIST
108282: ST_TO_ADDR
// end ;
108283: LD_VAR 0 2
108287: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
108288: LD_INT 0
108290: PPUSH
108291: PPUSH
// result := array ;
108292: LD_ADDR_VAR 0 3
108296: PUSH
108297: LD_VAR 0 1
108301: ST_TO_ADDR
// if size >= result then
108302: LD_VAR 0 2
108306: PUSH
108307: LD_VAR 0 3
108311: GREATEREQUAL
108312: IFFALSE 108316
// exit ;
108314: GO 108366
// if size then
108316: LD_VAR 0 2
108320: IFFALSE 108366
// for i := array downto size do
108322: LD_ADDR_VAR 0 4
108326: PUSH
108327: DOUBLE
108328: LD_VAR 0 1
108332: INC
108333: ST_TO_ADDR
108334: LD_VAR 0 2
108338: PUSH
108339: FOR_DOWNTO
108340: IFFALSE 108364
// result := Delete ( result , result ) ;
108342: LD_ADDR_VAR 0 3
108346: PUSH
108347: LD_VAR 0 3
108351: PPUSH
108352: LD_VAR 0 3
108356: PPUSH
108357: CALL_OW 3
108361: ST_TO_ADDR
108362: GO 108339
108364: POP
108365: POP
// end ;
108366: LD_VAR 0 3
108370: RET
// export function ComExit ( unit ) ; var tmp ; begin
108371: LD_INT 0
108373: PPUSH
108374: PPUSH
// if not IsInUnit ( unit ) then
108375: LD_VAR 0 1
108379: PPUSH
108380: CALL_OW 310
108384: NOT
108385: IFFALSE 108389
// exit ;
108387: GO 108449
// tmp := IsInUnit ( unit ) ;
108389: LD_ADDR_VAR 0 3
108393: PUSH
108394: LD_VAR 0 1
108398: PPUSH
108399: CALL_OW 310
108403: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
108404: LD_VAR 0 3
108408: PPUSH
108409: CALL_OW 247
108413: PUSH
108414: LD_INT 2
108416: EQUAL
108417: IFFALSE 108430
// ComExitVehicle ( unit ) else
108419: LD_VAR 0 1
108423: PPUSH
108424: CALL_OW 121
108428: GO 108439
// ComExitBuilding ( unit ) ;
108430: LD_VAR 0 1
108434: PPUSH
108435: CALL_OW 122
// result := tmp ;
108439: LD_ADDR_VAR 0 2
108443: PUSH
108444: LD_VAR 0 3
108448: ST_TO_ADDR
// end ;
108449: LD_VAR 0 2
108453: RET
// export function ComExitAll ( units ) ; var i ; begin
108454: LD_INT 0
108456: PPUSH
108457: PPUSH
// if not units then
108458: LD_VAR 0 1
108462: NOT
108463: IFFALSE 108467
// exit ;
108465: GO 108493
// for i in units do
108467: LD_ADDR_VAR 0 3
108471: PUSH
108472: LD_VAR 0 1
108476: PUSH
108477: FOR_IN
108478: IFFALSE 108491
// ComExit ( i ) ;
108480: LD_VAR 0 3
108484: PPUSH
108485: CALL 108371 0 1
108489: GO 108477
108491: POP
108492: POP
// end ;
108493: LD_VAR 0 2
108497: RET
// export function ResetHc ; begin
108498: LD_INT 0
108500: PPUSH
// InitHc ;
108501: CALL_OW 19
// hc_importance := 0 ;
108505: LD_ADDR_OWVAR 32
108509: PUSH
108510: LD_INT 0
108512: ST_TO_ADDR
// end ;
108513: LD_VAR 0 1
108517: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
108518: LD_INT 0
108520: PPUSH
108521: PPUSH
108522: PPUSH
// _x := ( x1 + x2 ) div 2 ;
108523: LD_ADDR_VAR 0 6
108527: PUSH
108528: LD_VAR 0 1
108532: PUSH
108533: LD_VAR 0 3
108537: PLUS
108538: PUSH
108539: LD_INT 2
108541: DIV
108542: ST_TO_ADDR
// if _x < 0 then
108543: LD_VAR 0 6
108547: PUSH
108548: LD_INT 0
108550: LESS
108551: IFFALSE 108568
// _x := _x * - 1 ;
108553: LD_ADDR_VAR 0 6
108557: PUSH
108558: LD_VAR 0 6
108562: PUSH
108563: LD_INT 1
108565: NEG
108566: MUL
108567: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108568: LD_ADDR_VAR 0 7
108572: PUSH
108573: LD_VAR 0 2
108577: PUSH
108578: LD_VAR 0 4
108582: PLUS
108583: PUSH
108584: LD_INT 2
108586: DIV
108587: ST_TO_ADDR
// if _y < 0 then
108588: LD_VAR 0 7
108592: PUSH
108593: LD_INT 0
108595: LESS
108596: IFFALSE 108613
// _y := _y * - 1 ;
108598: LD_ADDR_VAR 0 7
108602: PUSH
108603: LD_VAR 0 7
108607: PUSH
108608: LD_INT 1
108610: NEG
108611: MUL
108612: ST_TO_ADDR
// result := [ _x , _y ] ;
108613: LD_ADDR_VAR 0 5
108617: PUSH
108618: LD_VAR 0 6
108622: PUSH
108623: LD_VAR 0 7
108627: PUSH
108628: EMPTY
108629: LIST
108630: LIST
108631: ST_TO_ADDR
// end ;
108632: LD_VAR 0 5
108636: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108637: LD_INT 0
108639: PPUSH
108640: PPUSH
108641: PPUSH
108642: PPUSH
// task := GetTaskList ( unit ) ;
108643: LD_ADDR_VAR 0 7
108647: PUSH
108648: LD_VAR 0 1
108652: PPUSH
108653: CALL_OW 437
108657: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108658: LD_VAR 0 7
108662: NOT
108663: PUSH
108664: LD_VAR 0 1
108668: PPUSH
108669: LD_VAR 0 2
108673: PPUSH
108674: CALL_OW 308
108678: NOT
108679: AND
108680: IFFALSE 108684
// exit ;
108682: GO 108802
// if IsInArea ( unit , area ) then
108684: LD_VAR 0 1
108688: PPUSH
108689: LD_VAR 0 2
108693: PPUSH
108694: CALL_OW 308
108698: IFFALSE 108716
// begin ComMoveToArea ( unit , goAway ) ;
108700: LD_VAR 0 1
108704: PPUSH
108705: LD_VAR 0 3
108709: PPUSH
108710: CALL_OW 113
// exit ;
108714: GO 108802
// end ; if task [ 1 ] [ 1 ] <> M then
108716: LD_VAR 0 7
108720: PUSH
108721: LD_INT 1
108723: ARRAY
108724: PUSH
108725: LD_INT 1
108727: ARRAY
108728: PUSH
108729: LD_STRING M
108731: NONEQUAL
108732: IFFALSE 108736
// exit ;
108734: GO 108802
// x := task [ 1 ] [ 2 ] ;
108736: LD_ADDR_VAR 0 5
108740: PUSH
108741: LD_VAR 0 7
108745: PUSH
108746: LD_INT 1
108748: ARRAY
108749: PUSH
108750: LD_INT 2
108752: ARRAY
108753: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108754: LD_ADDR_VAR 0 6
108758: PUSH
108759: LD_VAR 0 7
108763: PUSH
108764: LD_INT 1
108766: ARRAY
108767: PUSH
108768: LD_INT 3
108770: ARRAY
108771: ST_TO_ADDR
// if InArea ( x , y , area ) then
108772: LD_VAR 0 5
108776: PPUSH
108777: LD_VAR 0 6
108781: PPUSH
108782: LD_VAR 0 2
108786: PPUSH
108787: CALL_OW 309
108791: IFFALSE 108802
// ComStop ( unit ) ;
108793: LD_VAR 0 1
108797: PPUSH
108798: CALL_OW 141
// end ;
108802: LD_VAR 0 4
108806: RET
// export function Abs ( value ) ; begin
108807: LD_INT 0
108809: PPUSH
// result := value ;
108810: LD_ADDR_VAR 0 2
108814: PUSH
108815: LD_VAR 0 1
108819: ST_TO_ADDR
// if value < 0 then
108820: LD_VAR 0 1
108824: PUSH
108825: LD_INT 0
108827: LESS
108828: IFFALSE 108845
// result := value * - 1 ;
108830: LD_ADDR_VAR 0 2
108834: PUSH
108835: LD_VAR 0 1
108839: PUSH
108840: LD_INT 1
108842: NEG
108843: MUL
108844: ST_TO_ADDR
// end ;
108845: LD_VAR 0 2
108849: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108850: LD_INT 0
108852: PPUSH
108853: PPUSH
108854: PPUSH
108855: PPUSH
108856: PPUSH
108857: PPUSH
108858: PPUSH
108859: PPUSH
// if not unit or not building then
108860: LD_VAR 0 1
108864: NOT
108865: PUSH
108866: LD_VAR 0 2
108870: NOT
108871: OR
108872: IFFALSE 108876
// exit ;
108874: GO 109102
// x := GetX ( building ) ;
108876: LD_ADDR_VAR 0 4
108880: PUSH
108881: LD_VAR 0 2
108885: PPUSH
108886: CALL_OW 250
108890: ST_TO_ADDR
// y := GetY ( building ) ;
108891: LD_ADDR_VAR 0 6
108895: PUSH
108896: LD_VAR 0 2
108900: PPUSH
108901: CALL_OW 251
108905: ST_TO_ADDR
// d := GetDir ( building ) ;
108906: LD_ADDR_VAR 0 8
108910: PUSH
108911: LD_VAR 0 2
108915: PPUSH
108916: CALL_OW 254
108920: ST_TO_ADDR
// r := 4 ;
108921: LD_ADDR_VAR 0 9
108925: PUSH
108926: LD_INT 4
108928: ST_TO_ADDR
// for i := 1 to 5 do
108929: LD_ADDR_VAR 0 10
108933: PUSH
108934: DOUBLE
108935: LD_INT 1
108937: DEC
108938: ST_TO_ADDR
108939: LD_INT 5
108941: PUSH
108942: FOR_TO
108943: IFFALSE 109100
// begin _x := ShiftX ( x , d , r + i ) ;
108945: LD_ADDR_VAR 0 5
108949: PUSH
108950: LD_VAR 0 4
108954: PPUSH
108955: LD_VAR 0 8
108959: PPUSH
108960: LD_VAR 0 9
108964: PUSH
108965: LD_VAR 0 10
108969: PLUS
108970: PPUSH
108971: CALL_OW 272
108975: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108976: LD_ADDR_VAR 0 7
108980: PUSH
108981: LD_VAR 0 6
108985: PPUSH
108986: LD_VAR 0 8
108990: PPUSH
108991: LD_VAR 0 9
108995: PUSH
108996: LD_VAR 0 10
109000: PLUS
109001: PPUSH
109002: CALL_OW 273
109006: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
109007: LD_VAR 0 5
109011: PPUSH
109012: LD_VAR 0 7
109016: PPUSH
109017: CALL_OW 488
109021: PUSH
109022: LD_VAR 0 5
109026: PPUSH
109027: LD_VAR 0 7
109031: PPUSH
109032: CALL_OW 428
109036: PPUSH
109037: CALL_OW 247
109041: PUSH
109042: LD_INT 3
109044: PUSH
109045: LD_INT 2
109047: PUSH
109048: EMPTY
109049: LIST
109050: LIST
109051: IN
109052: NOT
109053: AND
109054: IFFALSE 109098
// begin ComMoveXY ( unit , _x , _y ) ;
109056: LD_VAR 0 1
109060: PPUSH
109061: LD_VAR 0 5
109065: PPUSH
109066: LD_VAR 0 7
109070: PPUSH
109071: CALL_OW 111
// result := [ _x , _y ] ;
109075: LD_ADDR_VAR 0 3
109079: PUSH
109080: LD_VAR 0 5
109084: PUSH
109085: LD_VAR 0 7
109089: PUSH
109090: EMPTY
109091: LIST
109092: LIST
109093: ST_TO_ADDR
// exit ;
109094: POP
109095: POP
109096: GO 109102
// end ; end ;
109098: GO 108942
109100: POP
109101: POP
// end ;
109102: LD_VAR 0 3
109106: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
109107: LD_INT 0
109109: PPUSH
109110: PPUSH
109111: PPUSH
// result := 0 ;
109112: LD_ADDR_VAR 0 3
109116: PUSH
109117: LD_INT 0
109119: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
109120: LD_VAR 0 1
109124: PUSH
109125: LD_INT 0
109127: LESS
109128: PUSH
109129: LD_VAR 0 1
109133: PUSH
109134: LD_INT 8
109136: GREATER
109137: OR
109138: PUSH
109139: LD_VAR 0 2
109143: PUSH
109144: LD_INT 0
109146: LESS
109147: OR
109148: PUSH
109149: LD_VAR 0 2
109153: PUSH
109154: LD_INT 8
109156: GREATER
109157: OR
109158: IFFALSE 109162
// exit ;
109160: GO 109237
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
109162: LD_ADDR_VAR 0 4
109166: PUSH
109167: LD_INT 22
109169: PUSH
109170: LD_VAR 0 2
109174: PUSH
109175: EMPTY
109176: LIST
109177: LIST
109178: PPUSH
109179: CALL_OW 69
109183: PUSH
109184: FOR_IN
109185: IFFALSE 109235
// begin un := UnitShoot ( i ) ;
109187: LD_ADDR_VAR 0 5
109191: PUSH
109192: LD_VAR 0 4
109196: PPUSH
109197: CALL_OW 504
109201: ST_TO_ADDR
// if GetSide ( un ) = side1 then
109202: LD_VAR 0 5
109206: PPUSH
109207: CALL_OW 255
109211: PUSH
109212: LD_VAR 0 1
109216: EQUAL
109217: IFFALSE 109233
// begin result := un ;
109219: LD_ADDR_VAR 0 3
109223: PUSH
109224: LD_VAR 0 5
109228: ST_TO_ADDR
// exit ;
109229: POP
109230: POP
109231: GO 109237
// end ; end ;
109233: GO 109184
109235: POP
109236: POP
// end ;
109237: LD_VAR 0 3
109241: RET
// export function GetCargoBay ( units ) ; begin
109242: LD_INT 0
109244: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
109245: LD_ADDR_VAR 0 2
109249: PUSH
109250: LD_VAR 0 1
109254: PPUSH
109255: LD_INT 2
109257: PUSH
109258: LD_INT 34
109260: PUSH
109261: LD_INT 12
109263: PUSH
109264: EMPTY
109265: LIST
109266: LIST
109267: PUSH
109268: LD_INT 34
109270: PUSH
109271: LD_INT 51
109273: PUSH
109274: EMPTY
109275: LIST
109276: LIST
109277: PUSH
109278: LD_INT 34
109280: PUSH
109281: LD_INT 32
109283: PUSH
109284: EMPTY
109285: LIST
109286: LIST
109287: PUSH
109288: LD_INT 34
109290: PUSH
109291: LD_INT 89
109293: PUSH
109294: EMPTY
109295: LIST
109296: LIST
109297: PUSH
109298: EMPTY
109299: LIST
109300: LIST
109301: LIST
109302: LIST
109303: LIST
109304: PPUSH
109305: CALL_OW 72
109309: ST_TO_ADDR
// end ;
109310: LD_VAR 0 2
109314: RET
// export function Negate ( value ) ; begin
109315: LD_INT 0
109317: PPUSH
// result := not value ;
109318: LD_ADDR_VAR 0 2
109322: PUSH
109323: LD_VAR 0 1
109327: NOT
109328: ST_TO_ADDR
// end ;
109329: LD_VAR 0 2
109333: RET
// export function Inc ( value ) ; begin
109334: LD_INT 0
109336: PPUSH
// result := value + 1 ;
109337: LD_ADDR_VAR 0 2
109341: PUSH
109342: LD_VAR 0 1
109346: PUSH
109347: LD_INT 1
109349: PLUS
109350: ST_TO_ADDR
// end ;
109351: LD_VAR 0 2
109355: RET
// export function Dec ( value ) ; begin
109356: LD_INT 0
109358: PPUSH
// result := value - 1 ;
109359: LD_ADDR_VAR 0 2
109363: PUSH
109364: LD_VAR 0 1
109368: PUSH
109369: LD_INT 1
109371: MINUS
109372: ST_TO_ADDR
// end ;
109373: LD_VAR 0 2
109377: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
109378: LD_INT 0
109380: PPUSH
109381: PPUSH
109382: PPUSH
109383: PPUSH
109384: PPUSH
109385: PPUSH
109386: PPUSH
109387: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
109388: LD_VAR 0 1
109392: PPUSH
109393: LD_VAR 0 2
109397: PPUSH
109398: CALL_OW 488
109402: NOT
109403: PUSH
109404: LD_VAR 0 3
109408: PPUSH
109409: LD_VAR 0 4
109413: PPUSH
109414: CALL_OW 488
109418: NOT
109419: OR
109420: IFFALSE 109433
// begin result := - 1 ;
109422: LD_ADDR_VAR 0 5
109426: PUSH
109427: LD_INT 1
109429: NEG
109430: ST_TO_ADDR
// exit ;
109431: GO 109668
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
109433: LD_ADDR_VAR 0 12
109437: PUSH
109438: LD_VAR 0 1
109442: PPUSH
109443: LD_VAR 0 2
109447: PPUSH
109448: LD_VAR 0 3
109452: PPUSH
109453: LD_VAR 0 4
109457: PPUSH
109458: CALL 108518 0 4
109462: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
109463: LD_ADDR_VAR 0 11
109467: PUSH
109468: LD_VAR 0 1
109472: PPUSH
109473: LD_VAR 0 2
109477: PPUSH
109478: LD_VAR 0 12
109482: PUSH
109483: LD_INT 1
109485: ARRAY
109486: PPUSH
109487: LD_VAR 0 12
109491: PUSH
109492: LD_INT 2
109494: ARRAY
109495: PPUSH
109496: CALL_OW 298
109500: ST_TO_ADDR
// distance := 9999 ;
109501: LD_ADDR_VAR 0 10
109505: PUSH
109506: LD_INT 9999
109508: ST_TO_ADDR
// for i := 0 to 5 do
109509: LD_ADDR_VAR 0 6
109513: PUSH
109514: DOUBLE
109515: LD_INT 0
109517: DEC
109518: ST_TO_ADDR
109519: LD_INT 5
109521: PUSH
109522: FOR_TO
109523: IFFALSE 109666
// begin _x := ShiftX ( x1 , i , centerDist ) ;
109525: LD_ADDR_VAR 0 7
109529: PUSH
109530: LD_VAR 0 1
109534: PPUSH
109535: LD_VAR 0 6
109539: PPUSH
109540: LD_VAR 0 11
109544: PPUSH
109545: CALL_OW 272
109549: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
109550: LD_ADDR_VAR 0 8
109554: PUSH
109555: LD_VAR 0 2
109559: PPUSH
109560: LD_VAR 0 6
109564: PPUSH
109565: LD_VAR 0 11
109569: PPUSH
109570: CALL_OW 273
109574: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109575: LD_VAR 0 7
109579: PPUSH
109580: LD_VAR 0 8
109584: PPUSH
109585: CALL_OW 488
109589: NOT
109590: IFFALSE 109594
// continue ;
109592: GO 109522
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109594: LD_ADDR_VAR 0 9
109598: PUSH
109599: LD_VAR 0 12
109603: PUSH
109604: LD_INT 1
109606: ARRAY
109607: PPUSH
109608: LD_VAR 0 12
109612: PUSH
109613: LD_INT 2
109615: ARRAY
109616: PPUSH
109617: LD_VAR 0 7
109621: PPUSH
109622: LD_VAR 0 8
109626: PPUSH
109627: CALL_OW 298
109631: ST_TO_ADDR
// if tmp < distance then
109632: LD_VAR 0 9
109636: PUSH
109637: LD_VAR 0 10
109641: LESS
109642: IFFALSE 109664
// begin result := i ;
109644: LD_ADDR_VAR 0 5
109648: PUSH
109649: LD_VAR 0 6
109653: ST_TO_ADDR
// distance := tmp ;
109654: LD_ADDR_VAR 0 10
109658: PUSH
109659: LD_VAR 0 9
109663: ST_TO_ADDR
// end ; end ;
109664: GO 109522
109666: POP
109667: POP
// end ;
109668: LD_VAR 0 5
109672: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109673: LD_INT 0
109675: PPUSH
109676: PPUSH
// if not driver or not IsInUnit ( driver ) then
109677: LD_VAR 0 1
109681: NOT
109682: PUSH
109683: LD_VAR 0 1
109687: PPUSH
109688: CALL_OW 310
109692: NOT
109693: OR
109694: IFFALSE 109698
// exit ;
109696: GO 109788
// vehicle := IsInUnit ( driver ) ;
109698: LD_ADDR_VAR 0 3
109702: PUSH
109703: LD_VAR 0 1
109707: PPUSH
109708: CALL_OW 310
109712: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109713: LD_VAR 0 1
109717: PPUSH
109718: LD_STRING \
109720: PUSH
109721: LD_INT 0
109723: PUSH
109724: LD_INT 0
109726: PUSH
109727: LD_INT 0
109729: PUSH
109730: LD_INT 0
109732: PUSH
109733: LD_INT 0
109735: PUSH
109736: LD_INT 0
109738: PUSH
109739: EMPTY
109740: LIST
109741: LIST
109742: LIST
109743: LIST
109744: LIST
109745: LIST
109746: LIST
109747: PUSH
109748: LD_STRING E
109750: PUSH
109751: LD_INT 0
109753: PUSH
109754: LD_INT 0
109756: PUSH
109757: LD_VAR 0 3
109761: PUSH
109762: LD_INT 0
109764: PUSH
109765: LD_INT 0
109767: PUSH
109768: LD_INT 0
109770: PUSH
109771: EMPTY
109772: LIST
109773: LIST
109774: LIST
109775: LIST
109776: LIST
109777: LIST
109778: LIST
109779: PUSH
109780: EMPTY
109781: LIST
109782: LIST
109783: PPUSH
109784: CALL_OW 446
// end ;
109788: LD_VAR 0 2
109792: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109793: LD_INT 0
109795: PPUSH
109796: PPUSH
// if not driver or not IsInUnit ( driver ) then
109797: LD_VAR 0 1
109801: NOT
109802: PUSH
109803: LD_VAR 0 1
109807: PPUSH
109808: CALL_OW 310
109812: NOT
109813: OR
109814: IFFALSE 109818
// exit ;
109816: GO 109908
// vehicle := IsInUnit ( driver ) ;
109818: LD_ADDR_VAR 0 3
109822: PUSH
109823: LD_VAR 0 1
109827: PPUSH
109828: CALL_OW 310
109832: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109833: LD_VAR 0 1
109837: PPUSH
109838: LD_STRING \
109840: PUSH
109841: LD_INT 0
109843: PUSH
109844: LD_INT 0
109846: PUSH
109847: LD_INT 0
109849: PUSH
109850: LD_INT 0
109852: PUSH
109853: LD_INT 0
109855: PUSH
109856: LD_INT 0
109858: PUSH
109859: EMPTY
109860: LIST
109861: LIST
109862: LIST
109863: LIST
109864: LIST
109865: LIST
109866: LIST
109867: PUSH
109868: LD_STRING E
109870: PUSH
109871: LD_INT 0
109873: PUSH
109874: LD_INT 0
109876: PUSH
109877: LD_VAR 0 3
109881: PUSH
109882: LD_INT 0
109884: PUSH
109885: LD_INT 0
109887: PUSH
109888: LD_INT 0
109890: PUSH
109891: EMPTY
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: LIST
109898: LIST
109899: PUSH
109900: EMPTY
109901: LIST
109902: LIST
109903: PPUSH
109904: CALL_OW 447
// end ;
109908: LD_VAR 0 2
109912: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109913: LD_INT 0
109915: PPUSH
109916: PPUSH
109917: PPUSH
// tmp := [ ] ;
109918: LD_ADDR_VAR 0 5
109922: PUSH
109923: EMPTY
109924: ST_TO_ADDR
// for i in units do
109925: LD_ADDR_VAR 0 4
109929: PUSH
109930: LD_VAR 0 1
109934: PUSH
109935: FOR_IN
109936: IFFALSE 109974
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109938: LD_ADDR_VAR 0 5
109942: PUSH
109943: LD_VAR 0 5
109947: PPUSH
109948: LD_VAR 0 5
109952: PUSH
109953: LD_INT 1
109955: PLUS
109956: PPUSH
109957: LD_VAR 0 4
109961: PPUSH
109962: CALL_OW 256
109966: PPUSH
109967: CALL_OW 2
109971: ST_TO_ADDR
109972: GO 109935
109974: POP
109975: POP
// if not tmp then
109976: LD_VAR 0 5
109980: NOT
109981: IFFALSE 109985
// exit ;
109983: GO 110033
// if asc then
109985: LD_VAR 0 2
109989: IFFALSE 110013
// result := SortListByListAsc ( units , tmp ) else
109991: LD_ADDR_VAR 0 3
109995: PUSH
109996: LD_VAR 0 1
110000: PPUSH
110001: LD_VAR 0 5
110005: PPUSH
110006: CALL_OW 76
110010: ST_TO_ADDR
110011: GO 110033
// result := SortListByListDesc ( units , tmp ) ;
110013: LD_ADDR_VAR 0 3
110017: PUSH
110018: LD_VAR 0 1
110022: PPUSH
110023: LD_VAR 0 5
110027: PPUSH
110028: CALL_OW 77
110032: ST_TO_ADDR
// end ;
110033: LD_VAR 0 3
110037: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
110038: LD_INT 0
110040: PPUSH
110041: PPUSH
// task := GetTaskList ( mech ) ;
110042: LD_ADDR_VAR 0 4
110046: PUSH
110047: LD_VAR 0 1
110051: PPUSH
110052: CALL_OW 437
110056: ST_TO_ADDR
// if not task then
110057: LD_VAR 0 4
110061: NOT
110062: IFFALSE 110066
// exit ;
110064: GO 110108
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
110066: LD_ADDR_VAR 0 3
110070: PUSH
110071: LD_VAR 0 4
110075: PUSH
110076: LD_INT 1
110078: ARRAY
110079: PUSH
110080: LD_INT 1
110082: ARRAY
110083: PUSH
110084: LD_STRING r
110086: EQUAL
110087: PUSH
110088: LD_VAR 0 4
110092: PUSH
110093: LD_INT 1
110095: ARRAY
110096: PUSH
110097: LD_INT 4
110099: ARRAY
110100: PUSH
110101: LD_VAR 0 2
110105: EQUAL
110106: AND
110107: ST_TO_ADDR
// end ;
110108: LD_VAR 0 3
110112: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
110113: LD_INT 0
110115: PPUSH
// SetDir ( unit , d ) ;
110116: LD_VAR 0 1
110120: PPUSH
110121: LD_VAR 0 4
110125: PPUSH
110126: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
110130: LD_VAR 0 1
110134: PPUSH
110135: LD_VAR 0 2
110139: PPUSH
110140: LD_VAR 0 3
110144: PPUSH
110145: LD_VAR 0 5
110149: PPUSH
110150: CALL_OW 48
// end ;
110154: LD_VAR 0 6
110158: RET
// export function ToNaturalNumber ( number ) ; begin
110159: LD_INT 0
110161: PPUSH
// result := number div 1 ;
110162: LD_ADDR_VAR 0 2
110166: PUSH
110167: LD_VAR 0 1
110171: PUSH
110172: LD_INT 1
110174: DIV
110175: ST_TO_ADDR
// if number < 0 then
110176: LD_VAR 0 1
110180: PUSH
110181: LD_INT 0
110183: LESS
110184: IFFALSE 110194
// result := 0 ;
110186: LD_ADDR_VAR 0 2
110190: PUSH
110191: LD_INT 0
110193: ST_TO_ADDR
// end ;
110194: LD_VAR 0 2
110198: RET
// export function SortByClass ( units , class ) ; var un ; begin
110199: LD_INT 0
110201: PPUSH
110202: PPUSH
// if not units or not class then
110203: LD_VAR 0 1
110207: NOT
110208: PUSH
110209: LD_VAR 0 2
110213: NOT
110214: OR
110215: IFFALSE 110219
// exit ;
110217: GO 110314
// result := [ ] ;
110219: LD_ADDR_VAR 0 3
110223: PUSH
110224: EMPTY
110225: ST_TO_ADDR
// for un in units do
110226: LD_ADDR_VAR 0 4
110230: PUSH
110231: LD_VAR 0 1
110235: PUSH
110236: FOR_IN
110237: IFFALSE 110312
// if GetClass ( un ) = class then
110239: LD_VAR 0 4
110243: PPUSH
110244: CALL_OW 257
110248: PUSH
110249: LD_VAR 0 2
110253: EQUAL
110254: IFFALSE 110281
// result := Insert ( result , 1 , un ) else
110256: LD_ADDR_VAR 0 3
110260: PUSH
110261: LD_VAR 0 3
110265: PPUSH
110266: LD_INT 1
110268: PPUSH
110269: LD_VAR 0 4
110273: PPUSH
110274: CALL_OW 2
110278: ST_TO_ADDR
110279: GO 110310
// result := Replace ( result , result + 1 , un ) ;
110281: LD_ADDR_VAR 0 3
110285: PUSH
110286: LD_VAR 0 3
110290: PPUSH
110291: LD_VAR 0 3
110295: PUSH
110296: LD_INT 1
110298: PLUS
110299: PPUSH
110300: LD_VAR 0 4
110304: PPUSH
110305: CALL_OW 1
110309: ST_TO_ADDR
110310: GO 110236
110312: POP
110313: POP
// end ;
110314: LD_VAR 0 3
110318: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
110319: LD_INT 0
110321: PPUSH
110322: PPUSH
110323: PPUSH
110324: PPUSH
110325: PPUSH
110326: PPUSH
110327: PPUSH
// result := [ ] ;
110328: LD_ADDR_VAR 0 4
110332: PUSH
110333: EMPTY
110334: ST_TO_ADDR
// if x - r < 0 then
110335: LD_VAR 0 1
110339: PUSH
110340: LD_VAR 0 3
110344: MINUS
110345: PUSH
110346: LD_INT 0
110348: LESS
110349: IFFALSE 110361
// min_x := 0 else
110351: LD_ADDR_VAR 0 8
110355: PUSH
110356: LD_INT 0
110358: ST_TO_ADDR
110359: GO 110377
// min_x := x - r ;
110361: LD_ADDR_VAR 0 8
110365: PUSH
110366: LD_VAR 0 1
110370: PUSH
110371: LD_VAR 0 3
110375: MINUS
110376: ST_TO_ADDR
// if y - r < 0 then
110377: LD_VAR 0 2
110381: PUSH
110382: LD_VAR 0 3
110386: MINUS
110387: PUSH
110388: LD_INT 0
110390: LESS
110391: IFFALSE 110403
// min_y := 0 else
110393: LD_ADDR_VAR 0 7
110397: PUSH
110398: LD_INT 0
110400: ST_TO_ADDR
110401: GO 110419
// min_y := y - r ;
110403: LD_ADDR_VAR 0 7
110407: PUSH
110408: LD_VAR 0 2
110412: PUSH
110413: LD_VAR 0 3
110417: MINUS
110418: ST_TO_ADDR
// max_x := x + r ;
110419: LD_ADDR_VAR 0 9
110423: PUSH
110424: LD_VAR 0 1
110428: PUSH
110429: LD_VAR 0 3
110433: PLUS
110434: ST_TO_ADDR
// max_y := y + r ;
110435: LD_ADDR_VAR 0 10
110439: PUSH
110440: LD_VAR 0 2
110444: PUSH
110445: LD_VAR 0 3
110449: PLUS
110450: ST_TO_ADDR
// for _x = min_x to max_x do
110451: LD_ADDR_VAR 0 5
110455: PUSH
110456: DOUBLE
110457: LD_VAR 0 8
110461: DEC
110462: ST_TO_ADDR
110463: LD_VAR 0 9
110467: PUSH
110468: FOR_TO
110469: IFFALSE 110570
// for _y = min_y to max_y do
110471: LD_ADDR_VAR 0 6
110475: PUSH
110476: DOUBLE
110477: LD_VAR 0 7
110481: DEC
110482: ST_TO_ADDR
110483: LD_VAR 0 10
110487: PUSH
110488: FOR_TO
110489: IFFALSE 110566
// begin if not ValidHex ( _x , _y ) then
110491: LD_VAR 0 5
110495: PPUSH
110496: LD_VAR 0 6
110500: PPUSH
110501: CALL_OW 488
110505: NOT
110506: IFFALSE 110510
// continue ;
110508: GO 110488
// if GetResourceTypeXY ( _x , _y ) then
110510: LD_VAR 0 5
110514: PPUSH
110515: LD_VAR 0 6
110519: PPUSH
110520: CALL_OW 283
110524: IFFALSE 110564
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
110526: LD_ADDR_VAR 0 4
110530: PUSH
110531: LD_VAR 0 4
110535: PPUSH
110536: LD_VAR 0 4
110540: PUSH
110541: LD_INT 1
110543: PLUS
110544: PPUSH
110545: LD_VAR 0 5
110549: PUSH
110550: LD_VAR 0 6
110554: PUSH
110555: EMPTY
110556: LIST
110557: LIST
110558: PPUSH
110559: CALL_OW 1
110563: ST_TO_ADDR
// end ;
110564: GO 110488
110566: POP
110567: POP
110568: GO 110468
110570: POP
110571: POP
// end ;
110572: LD_VAR 0 4
110576: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110577: LD_INT 0
110579: PPUSH
110580: PPUSH
110581: PPUSH
110582: PPUSH
110583: PPUSH
110584: PPUSH
110585: PPUSH
110586: PPUSH
// if not units then
110587: LD_VAR 0 1
110591: NOT
110592: IFFALSE 110596
// exit ;
110594: GO 111124
// result := UnitFilter ( units , [ f_ok ] ) ;
110596: LD_ADDR_VAR 0 3
110600: PUSH
110601: LD_VAR 0 1
110605: PPUSH
110606: LD_INT 50
110608: PUSH
110609: EMPTY
110610: LIST
110611: PPUSH
110612: CALL_OW 72
110616: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110617: LD_ADDR_VAR 0 8
110621: PUSH
110622: LD_VAR 0 1
110626: PUSH
110627: LD_INT 1
110629: ARRAY
110630: PPUSH
110631: CALL_OW 255
110635: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110636: LD_ADDR_VAR 0 10
110640: PUSH
110641: LD_INT 29
110643: PUSH
110644: LD_INT 91
110646: PUSH
110647: LD_INT 49
110649: PUSH
110650: EMPTY
110651: LIST
110652: LIST
110653: LIST
110654: ST_TO_ADDR
// if not result then
110655: LD_VAR 0 3
110659: NOT
110660: IFFALSE 110664
// exit ;
110662: GO 111124
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110664: LD_ADDR_VAR 0 5
110668: PUSH
110669: LD_INT 81
110671: PUSH
110672: LD_VAR 0 8
110676: PUSH
110677: EMPTY
110678: LIST
110679: LIST
110680: PPUSH
110681: CALL_OW 69
110685: ST_TO_ADDR
// for i in result do
110686: LD_ADDR_VAR 0 4
110690: PUSH
110691: LD_VAR 0 3
110695: PUSH
110696: FOR_IN
110697: IFFALSE 111122
// begin tag := GetTag ( i ) + 1 ;
110699: LD_ADDR_VAR 0 9
110703: PUSH
110704: LD_VAR 0 4
110708: PPUSH
110709: CALL_OW 110
110713: PUSH
110714: LD_INT 1
110716: PLUS
110717: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
110718: LD_ADDR_VAR 0 7
110722: PUSH
110723: LD_VAR 0 4
110727: PPUSH
110728: CALL_OW 250
110732: PPUSH
110733: LD_VAR 0 4
110737: PPUSH
110738: CALL_OW 251
110742: PPUSH
110743: LD_INT 4
110745: PPUSH
110746: CALL 110319 0 3
110750: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
110751: LD_VAR 0 4
110755: PPUSH
110756: CALL_OW 247
110760: PUSH
110761: LD_INT 2
110763: EQUAL
110764: PUSH
110765: LD_VAR 0 7
110769: PUSH
110770: LD_INT 2
110772: GREATER
110773: AND
110774: PUSH
110775: LD_VAR 0 4
110779: PPUSH
110780: CALL_OW 264
110784: PUSH
110785: LD_VAR 0 10
110789: IN
110790: NOT
110791: AND
110792: IFFALSE 110831
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110794: LD_VAR 0 4
110798: PPUSH
110799: LD_VAR 0 7
110803: PUSH
110804: LD_INT 1
110806: ARRAY
110807: PUSH
110808: LD_INT 1
110810: ARRAY
110811: PPUSH
110812: LD_VAR 0 7
110816: PUSH
110817: LD_INT 1
110819: ARRAY
110820: PUSH
110821: LD_INT 2
110823: ARRAY
110824: PPUSH
110825: CALL_OW 116
110829: GO 111120
// if path > tag then
110831: LD_VAR 0 2
110835: PUSH
110836: LD_VAR 0 9
110840: GREATER
110841: IFFALSE 111049
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110843: LD_ADDR_VAR 0 6
110847: PUSH
110848: LD_VAR 0 5
110852: PPUSH
110853: LD_INT 91
110855: PUSH
110856: LD_VAR 0 4
110860: PUSH
110861: LD_INT 8
110863: PUSH
110864: EMPTY
110865: LIST
110866: LIST
110867: LIST
110868: PPUSH
110869: CALL_OW 72
110873: ST_TO_ADDR
// if nearEnemy then
110874: LD_VAR 0 6
110878: IFFALSE 110947
// begin if GetWeapon ( i ) = ru_time_lapser then
110880: LD_VAR 0 4
110884: PPUSH
110885: CALL_OW 264
110889: PUSH
110890: LD_INT 49
110892: EQUAL
110893: IFFALSE 110921
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110895: LD_VAR 0 4
110899: PPUSH
110900: LD_VAR 0 6
110904: PPUSH
110905: LD_VAR 0 4
110909: PPUSH
110910: CALL_OW 74
110914: PPUSH
110915: CALL_OW 112
110919: GO 110945
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110921: LD_VAR 0 4
110925: PPUSH
110926: LD_VAR 0 6
110930: PPUSH
110931: LD_VAR 0 4
110935: PPUSH
110936: CALL_OW 74
110940: PPUSH
110941: CALL 112195 0 2
// end else
110945: GO 111047
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110947: LD_VAR 0 4
110951: PPUSH
110952: LD_VAR 0 2
110956: PUSH
110957: LD_VAR 0 9
110961: ARRAY
110962: PUSH
110963: LD_INT 1
110965: ARRAY
110966: PPUSH
110967: LD_VAR 0 2
110971: PUSH
110972: LD_VAR 0 9
110976: ARRAY
110977: PUSH
110978: LD_INT 2
110980: ARRAY
110981: PPUSH
110982: CALL_OW 297
110986: PUSH
110987: LD_INT 6
110989: GREATER
110990: IFFALSE 111033
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110992: LD_VAR 0 4
110996: PPUSH
110997: LD_VAR 0 2
111001: PUSH
111002: LD_VAR 0 9
111006: ARRAY
111007: PUSH
111008: LD_INT 1
111010: ARRAY
111011: PPUSH
111012: LD_VAR 0 2
111016: PUSH
111017: LD_VAR 0 9
111021: ARRAY
111022: PUSH
111023: LD_INT 2
111025: ARRAY
111026: PPUSH
111027: CALL_OW 114
111031: GO 111047
// SetTag ( i , tag ) ;
111033: LD_VAR 0 4
111037: PPUSH
111038: LD_VAR 0 9
111042: PPUSH
111043: CALL_OW 109
// end else
111047: GO 111120
// if enemy then
111049: LD_VAR 0 5
111053: IFFALSE 111120
// begin if GetWeapon ( i ) = ru_time_lapser then
111055: LD_VAR 0 4
111059: PPUSH
111060: CALL_OW 264
111064: PUSH
111065: LD_INT 49
111067: EQUAL
111068: IFFALSE 111096
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111070: LD_VAR 0 4
111074: PPUSH
111075: LD_VAR 0 5
111079: PPUSH
111080: LD_VAR 0 4
111084: PPUSH
111085: CALL_OW 74
111089: PPUSH
111090: CALL_OW 112
111094: GO 111120
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
111096: LD_VAR 0 4
111100: PPUSH
111101: LD_VAR 0 5
111105: PPUSH
111106: LD_VAR 0 4
111110: PPUSH
111111: CALL_OW 74
111115: PPUSH
111116: CALL 112195 0 2
// end ; end ;
111120: GO 110696
111122: POP
111123: POP
// end ;
111124: LD_VAR 0 3
111128: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
111129: LD_INT 0
111131: PPUSH
111132: PPUSH
111133: PPUSH
// if not unit or IsInUnit ( unit ) then
111134: LD_VAR 0 1
111138: NOT
111139: PUSH
111140: LD_VAR 0 1
111144: PPUSH
111145: CALL_OW 310
111149: OR
111150: IFFALSE 111154
// exit ;
111152: GO 111245
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
111154: LD_ADDR_VAR 0 4
111158: PUSH
111159: LD_VAR 0 1
111163: PPUSH
111164: CALL_OW 250
111168: PPUSH
111169: LD_VAR 0 2
111173: PPUSH
111174: LD_INT 1
111176: PPUSH
111177: CALL_OW 272
111181: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
111182: LD_ADDR_VAR 0 5
111186: PUSH
111187: LD_VAR 0 1
111191: PPUSH
111192: CALL_OW 251
111196: PPUSH
111197: LD_VAR 0 2
111201: PPUSH
111202: LD_INT 1
111204: PPUSH
111205: CALL_OW 273
111209: ST_TO_ADDR
// if ValidHex ( x , y ) then
111210: LD_VAR 0 4
111214: PPUSH
111215: LD_VAR 0 5
111219: PPUSH
111220: CALL_OW 488
111224: IFFALSE 111245
// ComTurnXY ( unit , x , y ) ;
111226: LD_VAR 0 1
111230: PPUSH
111231: LD_VAR 0 4
111235: PPUSH
111236: LD_VAR 0 5
111240: PPUSH
111241: CALL_OW 118
// end ;
111245: LD_VAR 0 3
111249: RET
// export function SeeUnits ( side , units ) ; var i ; begin
111250: LD_INT 0
111252: PPUSH
111253: PPUSH
// result := false ;
111254: LD_ADDR_VAR 0 3
111258: PUSH
111259: LD_INT 0
111261: ST_TO_ADDR
// if not units then
111262: LD_VAR 0 2
111266: NOT
111267: IFFALSE 111271
// exit ;
111269: GO 111316
// for i in units do
111271: LD_ADDR_VAR 0 4
111275: PUSH
111276: LD_VAR 0 2
111280: PUSH
111281: FOR_IN
111282: IFFALSE 111314
// if See ( side , i ) then
111284: LD_VAR 0 1
111288: PPUSH
111289: LD_VAR 0 4
111293: PPUSH
111294: CALL_OW 292
111298: IFFALSE 111312
// begin result := true ;
111300: LD_ADDR_VAR 0 3
111304: PUSH
111305: LD_INT 1
111307: ST_TO_ADDR
// exit ;
111308: POP
111309: POP
111310: GO 111316
// end ;
111312: GO 111281
111314: POP
111315: POP
// end ;
111316: LD_VAR 0 3
111320: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
111321: LD_INT 0
111323: PPUSH
111324: PPUSH
111325: PPUSH
111326: PPUSH
// if not unit or not points then
111327: LD_VAR 0 1
111331: NOT
111332: PUSH
111333: LD_VAR 0 2
111337: NOT
111338: OR
111339: IFFALSE 111343
// exit ;
111341: GO 111433
// dist := 99999 ;
111343: LD_ADDR_VAR 0 5
111347: PUSH
111348: LD_INT 99999
111350: ST_TO_ADDR
// for i in points do
111351: LD_ADDR_VAR 0 4
111355: PUSH
111356: LD_VAR 0 2
111360: PUSH
111361: FOR_IN
111362: IFFALSE 111431
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
111364: LD_ADDR_VAR 0 6
111368: PUSH
111369: LD_VAR 0 1
111373: PPUSH
111374: LD_VAR 0 4
111378: PUSH
111379: LD_INT 1
111381: ARRAY
111382: PPUSH
111383: LD_VAR 0 4
111387: PUSH
111388: LD_INT 2
111390: ARRAY
111391: PPUSH
111392: CALL_OW 297
111396: ST_TO_ADDR
// if tmpDist < dist then
111397: LD_VAR 0 6
111401: PUSH
111402: LD_VAR 0 5
111406: LESS
111407: IFFALSE 111429
// begin result := i ;
111409: LD_ADDR_VAR 0 3
111413: PUSH
111414: LD_VAR 0 4
111418: ST_TO_ADDR
// dist := tmpDist ;
111419: LD_ADDR_VAR 0 5
111423: PUSH
111424: LD_VAR 0 6
111428: ST_TO_ADDR
// end ; end ;
111429: GO 111361
111431: POP
111432: POP
// end ;
111433: LD_VAR 0 3
111437: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
111438: LD_INT 0
111440: PPUSH
// uc_side := side ;
111441: LD_ADDR_OWVAR 20
111445: PUSH
111446: LD_VAR 0 1
111450: ST_TO_ADDR
// uc_nation := 3 ;
111451: LD_ADDR_OWVAR 21
111455: PUSH
111456: LD_INT 3
111458: ST_TO_ADDR
// vc_chassis := 25 ;
111459: LD_ADDR_OWVAR 37
111463: PUSH
111464: LD_INT 25
111466: ST_TO_ADDR
// vc_engine := engine_siberite ;
111467: LD_ADDR_OWVAR 39
111471: PUSH
111472: LD_INT 3
111474: ST_TO_ADDR
// vc_control := control_computer ;
111475: LD_ADDR_OWVAR 38
111479: PUSH
111480: LD_INT 3
111482: ST_TO_ADDR
// vc_weapon := 59 ;
111483: LD_ADDR_OWVAR 40
111487: PUSH
111488: LD_INT 59
111490: ST_TO_ADDR
// result := CreateVehicle ;
111491: LD_ADDR_VAR 0 5
111495: PUSH
111496: CALL_OW 45
111500: ST_TO_ADDR
// SetDir ( result , d ) ;
111501: LD_VAR 0 5
111505: PPUSH
111506: LD_VAR 0 4
111510: PPUSH
111511: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
111515: LD_VAR 0 5
111519: PPUSH
111520: LD_VAR 0 2
111524: PPUSH
111525: LD_VAR 0 3
111529: PPUSH
111530: LD_INT 0
111532: PPUSH
111533: CALL_OW 48
// end ;
111537: LD_VAR 0 5
111541: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
111542: LD_INT 0
111544: PPUSH
111545: PPUSH
111546: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
111547: LD_ADDR_VAR 0 2
111551: PUSH
111552: LD_INT 0
111554: PUSH
111555: LD_INT 0
111557: PUSH
111558: LD_INT 0
111560: PUSH
111561: LD_INT 0
111563: PUSH
111564: EMPTY
111565: LIST
111566: LIST
111567: LIST
111568: LIST
111569: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111570: LD_VAR 0 1
111574: NOT
111575: PUSH
111576: LD_VAR 0 1
111580: PPUSH
111581: CALL_OW 264
111585: PUSH
111586: LD_INT 12
111588: PUSH
111589: LD_INT 51
111591: PUSH
111592: LD_INT 32
111594: PUSH
111595: LD_INT 89
111597: PUSH
111598: EMPTY
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: IN
111604: NOT
111605: OR
111606: IFFALSE 111610
// exit ;
111608: GO 111708
// for i := 1 to 3 do
111610: LD_ADDR_VAR 0 3
111614: PUSH
111615: DOUBLE
111616: LD_INT 1
111618: DEC
111619: ST_TO_ADDR
111620: LD_INT 3
111622: PUSH
111623: FOR_TO
111624: IFFALSE 111706
// begin tmp := GetCargo ( cargo , i ) ;
111626: LD_ADDR_VAR 0 4
111630: PUSH
111631: LD_VAR 0 1
111635: PPUSH
111636: LD_VAR 0 3
111640: PPUSH
111641: CALL_OW 289
111645: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111646: LD_ADDR_VAR 0 2
111650: PUSH
111651: LD_VAR 0 2
111655: PPUSH
111656: LD_VAR 0 3
111660: PPUSH
111661: LD_VAR 0 4
111665: PPUSH
111666: CALL_OW 1
111670: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111671: LD_ADDR_VAR 0 2
111675: PUSH
111676: LD_VAR 0 2
111680: PPUSH
111681: LD_INT 4
111683: PPUSH
111684: LD_VAR 0 2
111688: PUSH
111689: LD_INT 4
111691: ARRAY
111692: PUSH
111693: LD_VAR 0 4
111697: PLUS
111698: PPUSH
111699: CALL_OW 1
111703: ST_TO_ADDR
// end ;
111704: GO 111623
111706: POP
111707: POP
// end ;
111708: LD_VAR 0 2
111712: RET
// export function Length ( array ) ; begin
111713: LD_INT 0
111715: PPUSH
// result := array + 0 ;
111716: LD_ADDR_VAR 0 2
111720: PUSH
111721: LD_VAR 0 1
111725: PUSH
111726: LD_INT 0
111728: PLUS
111729: ST_TO_ADDR
// end ;
111730: LD_VAR 0 2
111734: RET
// export function PrepareArray ( array ) ; begin
111735: LD_INT 0
111737: PPUSH
// result := array diff 0 ;
111738: LD_ADDR_VAR 0 2
111742: PUSH
111743: LD_VAR 0 1
111747: PUSH
111748: LD_INT 0
111750: DIFF
111751: ST_TO_ADDR
// if not result [ 1 ] then
111752: LD_VAR 0 2
111756: PUSH
111757: LD_INT 1
111759: ARRAY
111760: NOT
111761: IFFALSE 111781
// result := Delete ( result , 1 ) ;
111763: LD_ADDR_VAR 0 2
111767: PUSH
111768: LD_VAR 0 2
111772: PPUSH
111773: LD_INT 1
111775: PPUSH
111776: CALL_OW 3
111780: ST_TO_ADDR
// end ;
111781: LD_VAR 0 2
111785: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111786: LD_INT 0
111788: PPUSH
111789: PPUSH
111790: PPUSH
111791: PPUSH
// sibRocketRange := 25 ;
111792: LD_ADDR_VAR 0 6
111796: PUSH
111797: LD_INT 25
111799: ST_TO_ADDR
// result := false ;
111800: LD_ADDR_VAR 0 4
111804: PUSH
111805: LD_INT 0
111807: ST_TO_ADDR
// for i := 0 to 5 do
111808: LD_ADDR_VAR 0 5
111812: PUSH
111813: DOUBLE
111814: LD_INT 0
111816: DEC
111817: ST_TO_ADDR
111818: LD_INT 5
111820: PUSH
111821: FOR_TO
111822: IFFALSE 111889
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111824: LD_VAR 0 1
111828: PPUSH
111829: LD_VAR 0 5
111833: PPUSH
111834: LD_VAR 0 6
111838: PPUSH
111839: CALL_OW 272
111843: PPUSH
111844: LD_VAR 0 2
111848: PPUSH
111849: LD_VAR 0 5
111853: PPUSH
111854: LD_VAR 0 6
111858: PPUSH
111859: CALL_OW 273
111863: PPUSH
111864: LD_VAR 0 3
111868: PPUSH
111869: CALL_OW 309
111873: IFFALSE 111887
// begin result := true ;
111875: LD_ADDR_VAR 0 4
111879: PUSH
111880: LD_INT 1
111882: ST_TO_ADDR
// exit ;
111883: POP
111884: POP
111885: GO 111891
// end ;
111887: GO 111821
111889: POP
111890: POP
// end ;
111891: LD_VAR 0 4
111895: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111896: LD_INT 0
111898: PPUSH
111899: PPUSH
111900: PPUSH
// if btype = b_depot then
111901: LD_VAR 0 2
111905: PUSH
111906: LD_INT 0
111908: EQUAL
111909: IFFALSE 111921
// begin result := true ;
111911: LD_ADDR_VAR 0 3
111915: PUSH
111916: LD_INT 1
111918: ST_TO_ADDR
// exit ;
111919: GO 112037
// end ; pom := GetBase ( depot ) ;
111921: LD_ADDR_VAR 0 4
111925: PUSH
111926: LD_VAR 0 1
111930: PPUSH
111931: CALL_OW 274
111935: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111936: LD_ADDR_VAR 0 5
111940: PUSH
111941: LD_VAR 0 2
111945: PPUSH
111946: LD_VAR 0 1
111950: PPUSH
111951: CALL_OW 248
111955: PPUSH
111956: CALL_OW 450
111960: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111961: LD_ADDR_VAR 0 3
111965: PUSH
111966: LD_VAR 0 4
111970: PPUSH
111971: LD_INT 1
111973: PPUSH
111974: CALL_OW 275
111978: PUSH
111979: LD_VAR 0 5
111983: PUSH
111984: LD_INT 1
111986: ARRAY
111987: GREATEREQUAL
111988: PUSH
111989: LD_VAR 0 4
111993: PPUSH
111994: LD_INT 2
111996: PPUSH
111997: CALL_OW 275
112001: PUSH
112002: LD_VAR 0 5
112006: PUSH
112007: LD_INT 2
112009: ARRAY
112010: GREATEREQUAL
112011: AND
112012: PUSH
112013: LD_VAR 0 4
112017: PPUSH
112018: LD_INT 3
112020: PPUSH
112021: CALL_OW 275
112025: PUSH
112026: LD_VAR 0 5
112030: PUSH
112031: LD_INT 3
112033: ARRAY
112034: GREATEREQUAL
112035: AND
112036: ST_TO_ADDR
// end ;
112037: LD_VAR 0 3
112041: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
112042: LD_INT 0
112044: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
112045: LD_VAR 0 1
112049: PPUSH
112050: LD_VAR 0 2
112054: PPUSH
112055: LD_INT 0
112057: PPUSH
112058: LD_INT 0
112060: PPUSH
112061: LD_INT 1
112063: PPUSH
112064: LD_INT 0
112066: PPUSH
112067: CALL_OW 587
// end ;
112071: LD_VAR 0 3
112075: RET
// export function CenterOnNow ( unit ) ; begin
112076: LD_INT 0
112078: PPUSH
// result := IsInUnit ( unit ) ;
112079: LD_ADDR_VAR 0 2
112083: PUSH
112084: LD_VAR 0 1
112088: PPUSH
112089: CALL_OW 310
112093: ST_TO_ADDR
// if not result then
112094: LD_VAR 0 2
112098: NOT
112099: IFFALSE 112111
// result := unit ;
112101: LD_ADDR_VAR 0 2
112105: PUSH
112106: LD_VAR 0 1
112110: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
112111: LD_VAR 0 1
112115: PPUSH
112116: CALL_OW 87
// end ;
112120: LD_VAR 0 2
112124: RET
// export function ComMoveHex ( unit , hex ) ; begin
112125: LD_INT 0
112127: PPUSH
// if not hex then
112128: LD_VAR 0 2
112132: NOT
112133: IFFALSE 112137
// exit ;
112135: GO 112190
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
112137: LD_VAR 0 2
112141: PUSH
112142: LD_INT 1
112144: ARRAY
112145: PPUSH
112146: LD_VAR 0 2
112150: PUSH
112151: LD_INT 2
112153: ARRAY
112154: PPUSH
112155: CALL_OW 428
112159: IFFALSE 112163
// exit ;
112161: GO 112190
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
112163: LD_VAR 0 1
112167: PPUSH
112168: LD_VAR 0 2
112172: PUSH
112173: LD_INT 1
112175: ARRAY
112176: PPUSH
112177: LD_VAR 0 2
112181: PUSH
112182: LD_INT 2
112184: ARRAY
112185: PPUSH
112186: CALL_OW 111
// end ;
112190: LD_VAR 0 3
112194: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
112195: LD_INT 0
112197: PPUSH
112198: PPUSH
112199: PPUSH
// if not unit or not enemy then
112200: LD_VAR 0 1
112204: NOT
112205: PUSH
112206: LD_VAR 0 2
112210: NOT
112211: OR
112212: IFFALSE 112216
// exit ;
112214: GO 112340
// x := GetX ( enemy ) ;
112216: LD_ADDR_VAR 0 4
112220: PUSH
112221: LD_VAR 0 2
112225: PPUSH
112226: CALL_OW 250
112230: ST_TO_ADDR
// y := GetY ( enemy ) ;
112231: LD_ADDR_VAR 0 5
112235: PUSH
112236: LD_VAR 0 2
112240: PPUSH
112241: CALL_OW 251
112245: ST_TO_ADDR
// if ValidHex ( x , y ) then
112246: LD_VAR 0 4
112250: PPUSH
112251: LD_VAR 0 5
112255: PPUSH
112256: CALL_OW 488
112260: IFFALSE 112340
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
112262: LD_VAR 0 2
112266: PPUSH
112267: CALL_OW 247
112271: PUSH
112272: LD_INT 3
112274: PUSH
112275: LD_INT 2
112277: PUSH
112278: EMPTY
112279: LIST
112280: LIST
112281: IN
112282: PUSH
112283: LD_VAR 0 1
112287: PPUSH
112288: CALL_OW 255
112292: PPUSH
112293: LD_VAR 0 2
112297: PPUSH
112298: CALL_OW 292
112302: OR
112303: IFFALSE 112321
// ComAttackUnit ( unit , enemy ) else
112305: LD_VAR 0 1
112309: PPUSH
112310: LD_VAR 0 2
112314: PPUSH
112315: CALL_OW 115
112319: GO 112340
// ComAgressiveMove ( unit , x , y ) ;
112321: LD_VAR 0 1
112325: PPUSH
112326: LD_VAR 0 4
112330: PPUSH
112331: LD_VAR 0 5
112335: PPUSH
112336: CALL_OW 114
// end ;
112340: LD_VAR 0 3
112344: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
112345: LD_INT 0
112347: PPUSH
112348: PPUSH
112349: PPUSH
// list := AreaToList ( area , 0 ) ;
112350: LD_ADDR_VAR 0 5
112354: PUSH
112355: LD_VAR 0 1
112359: PPUSH
112360: LD_INT 0
112362: PPUSH
112363: CALL_OW 517
112367: ST_TO_ADDR
// if not list then
112368: LD_VAR 0 5
112372: NOT
112373: IFFALSE 112377
// exit ;
112375: GO 112507
// if all then
112377: LD_VAR 0 2
112381: IFFALSE 112469
// begin for i := 1 to list [ 1 ] do
112383: LD_ADDR_VAR 0 4
112387: PUSH
112388: DOUBLE
112389: LD_INT 1
112391: DEC
112392: ST_TO_ADDR
112393: LD_VAR 0 5
112397: PUSH
112398: LD_INT 1
112400: ARRAY
112401: PUSH
112402: FOR_TO
112403: IFFALSE 112465
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112405: LD_ADDR_VAR 0 3
112409: PUSH
112410: LD_VAR 0 3
112414: PPUSH
112415: LD_VAR 0 3
112419: PUSH
112420: LD_INT 1
112422: PLUS
112423: PPUSH
112424: LD_VAR 0 5
112428: PUSH
112429: LD_INT 1
112431: ARRAY
112432: PUSH
112433: LD_VAR 0 4
112437: ARRAY
112438: PUSH
112439: LD_VAR 0 5
112443: PUSH
112444: LD_INT 2
112446: ARRAY
112447: PUSH
112448: LD_VAR 0 4
112452: ARRAY
112453: PUSH
112454: EMPTY
112455: LIST
112456: LIST
112457: PPUSH
112458: CALL_OW 1
112462: ST_TO_ADDR
112463: GO 112402
112465: POP
112466: POP
// exit ;
112467: GO 112507
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
112469: LD_ADDR_VAR 0 3
112473: PUSH
112474: LD_VAR 0 5
112478: PUSH
112479: LD_INT 1
112481: ARRAY
112482: PUSH
112483: LD_INT 1
112485: ARRAY
112486: PUSH
112487: LD_VAR 0 5
112491: PUSH
112492: LD_INT 2
112494: ARRAY
112495: PUSH
112496: LD_INT 1
112498: ARRAY
112499: PUSH
112500: EMPTY
112501: LIST
112502: LIST
112503: PUSH
112504: EMPTY
112505: LIST
112506: ST_TO_ADDR
// end ;
112507: LD_VAR 0 3
112511: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
112512: LD_INT 0
112514: PPUSH
112515: PPUSH
// list := AreaToList ( area , 0 ) ;
112516: LD_ADDR_VAR 0 4
112520: PUSH
112521: LD_VAR 0 1
112525: PPUSH
112526: LD_INT 0
112528: PPUSH
112529: CALL_OW 517
112533: ST_TO_ADDR
// if not list then
112534: LD_VAR 0 4
112538: NOT
112539: IFFALSE 112543
// exit ;
112541: GO 112584
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
112543: LD_ADDR_VAR 0 3
112547: PUSH
112548: LD_VAR 0 4
112552: PUSH
112553: LD_INT 1
112555: ARRAY
112556: PUSH
112557: LD_INT 1
112559: ARRAY
112560: PUSH
112561: LD_VAR 0 4
112565: PUSH
112566: LD_INT 2
112568: ARRAY
112569: PUSH
112570: LD_INT 1
112572: ARRAY
112573: PUSH
112574: LD_VAR 0 2
112578: PUSH
112579: EMPTY
112580: LIST
112581: LIST
112582: LIST
112583: ST_TO_ADDR
// end ;
112584: LD_VAR 0 3
112588: RET
// export function First ( array ) ; begin
112589: LD_INT 0
112591: PPUSH
// if not array then
112592: LD_VAR 0 1
112596: NOT
112597: IFFALSE 112601
// exit ;
112599: GO 112615
// result := array [ 1 ] ;
112601: LD_ADDR_VAR 0 2
112605: PUSH
112606: LD_VAR 0 1
112610: PUSH
112611: LD_INT 1
112613: ARRAY
112614: ST_TO_ADDR
// end ;
112615: LD_VAR 0 2
112619: RET
// export function Last ( array ) ; begin
112620: LD_INT 0
112622: PPUSH
// if not array then
112623: LD_VAR 0 1
112627: NOT
112628: IFFALSE 112632
// exit ;
112630: GO 112648
// result := array [ array ] ;
112632: LD_ADDR_VAR 0 2
112636: PUSH
112637: LD_VAR 0 1
112641: PUSH
112642: LD_VAR 0 1
112646: ARRAY
112647: ST_TO_ADDR
// end ;
112648: LD_VAR 0 2
112652: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112653: LD_INT 0
112655: PPUSH
112656: PPUSH
// result := [ ] ;
112657: LD_ADDR_VAR 0 5
112661: PUSH
112662: EMPTY
112663: ST_TO_ADDR
// if not array then
112664: LD_VAR 0 1
112668: NOT
112669: IFFALSE 112673
// exit ;
112671: GO 112785
// for i := 1 to array do
112673: LD_ADDR_VAR 0 6
112677: PUSH
112678: DOUBLE
112679: LD_INT 1
112681: DEC
112682: ST_TO_ADDR
112683: LD_VAR 0 1
112687: PUSH
112688: FOR_TO
112689: IFFALSE 112783
// if array [ i ] [ index ] = value then
112691: LD_VAR 0 1
112695: PUSH
112696: LD_VAR 0 6
112700: ARRAY
112701: PUSH
112702: LD_VAR 0 2
112706: ARRAY
112707: PUSH
112708: LD_VAR 0 3
112712: EQUAL
112713: IFFALSE 112781
// begin if indexColumn then
112715: LD_VAR 0 4
112719: IFFALSE 112755
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112721: LD_ADDR_VAR 0 5
112725: PUSH
112726: LD_VAR 0 5
112730: PPUSH
112731: LD_VAR 0 1
112735: PUSH
112736: LD_VAR 0 6
112740: ARRAY
112741: PUSH
112742: LD_VAR 0 4
112746: ARRAY
112747: PPUSH
112748: CALL 107973 0 2
112752: ST_TO_ADDR
112753: GO 112781
// result := Join ( result , array [ i ] ) ;
112755: LD_ADDR_VAR 0 5
112759: PUSH
112760: LD_VAR 0 5
112764: PPUSH
112765: LD_VAR 0 1
112769: PUSH
112770: LD_VAR 0 6
112774: ARRAY
112775: PPUSH
112776: CALL 107973 0 2
112780: ST_TO_ADDR
// end ;
112781: GO 112688
112783: POP
112784: POP
// end ;
112785: LD_VAR 0 5
112789: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112790: LD_INT 0
112792: PPUSH
// if not vehicles or not parkingPoint then
112793: LD_VAR 0 1
112797: NOT
112798: PUSH
112799: LD_VAR 0 2
112803: NOT
112804: OR
112805: IFFALSE 112809
// exit ;
112807: GO 112907
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112809: LD_ADDR_VAR 0 1
112813: PUSH
112814: LD_VAR 0 1
112818: PPUSH
112819: LD_INT 50
112821: PUSH
112822: EMPTY
112823: LIST
112824: PUSH
112825: LD_INT 3
112827: PUSH
112828: LD_INT 92
112830: PUSH
112831: LD_VAR 0 2
112835: PUSH
112836: LD_INT 1
112838: ARRAY
112839: PUSH
112840: LD_VAR 0 2
112844: PUSH
112845: LD_INT 2
112847: ARRAY
112848: PUSH
112849: LD_INT 8
112851: PUSH
112852: EMPTY
112853: LIST
112854: LIST
112855: LIST
112856: LIST
112857: PUSH
112858: EMPTY
112859: LIST
112860: LIST
112861: PUSH
112862: EMPTY
112863: LIST
112864: LIST
112865: PPUSH
112866: CALL_OW 72
112870: ST_TO_ADDR
// if not vehicles then
112871: LD_VAR 0 1
112875: NOT
112876: IFFALSE 112880
// exit ;
112878: GO 112907
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112880: LD_VAR 0 1
112884: PPUSH
112885: LD_VAR 0 2
112889: PUSH
112890: LD_INT 1
112892: ARRAY
112893: PPUSH
112894: LD_VAR 0 2
112898: PUSH
112899: LD_INT 2
112901: ARRAY
112902: PPUSH
112903: CALL_OW 111
// end ;
112907: LD_VAR 0 3
112911: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112912: LD_INT 0
112914: PPUSH
112915: PPUSH
112916: PPUSH
// if not side or not area then
112917: LD_VAR 0 1
112921: NOT
112922: PUSH
112923: LD_VAR 0 2
112927: NOT
112928: OR
112929: IFFALSE 112933
// exit ;
112931: GO 113052
// tmp := AreaToList ( area , 0 ) ;
112933: LD_ADDR_VAR 0 5
112937: PUSH
112938: LD_VAR 0 2
112942: PPUSH
112943: LD_INT 0
112945: PPUSH
112946: CALL_OW 517
112950: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112951: LD_ADDR_VAR 0 4
112955: PUSH
112956: DOUBLE
112957: LD_INT 1
112959: DEC
112960: ST_TO_ADDR
112961: LD_VAR 0 5
112965: PUSH
112966: LD_INT 1
112968: ARRAY
112969: PUSH
112970: FOR_TO
112971: IFFALSE 113050
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112973: LD_VAR 0 5
112977: PUSH
112978: LD_INT 1
112980: ARRAY
112981: PUSH
112982: LD_VAR 0 4
112986: ARRAY
112987: PPUSH
112988: LD_VAR 0 5
112992: PUSH
112993: LD_INT 2
112995: ARRAY
112996: PUSH
112997: LD_VAR 0 4
113001: ARRAY
113002: PPUSH
113003: CALL_OW 351
113007: IFFALSE 113048
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
113009: LD_VAR 0 5
113013: PUSH
113014: LD_INT 1
113016: ARRAY
113017: PUSH
113018: LD_VAR 0 4
113022: ARRAY
113023: PPUSH
113024: LD_VAR 0 5
113028: PUSH
113029: LD_INT 2
113031: ARRAY
113032: PUSH
113033: LD_VAR 0 4
113037: ARRAY
113038: PPUSH
113039: LD_VAR 0 1
113043: PPUSH
113044: CALL_OW 244
// end ;
113048: GO 112970
113050: POP
113051: POP
// end ; end_of_file end_of_file
113052: LD_VAR 0 3
113056: RET
// export globalGameSaveCounter ; every 0 0$1 do
113057: GO 113059
113059: DISABLE
// begin enable ;
113060: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
113061: LD_STRING updateTimer(
113063: PUSH
113064: LD_OWVAR 1
113068: STR
113069: PUSH
113070: LD_STRING );
113072: STR
113073: PPUSH
113074: CALL_OW 559
// end ;
113078: END
// every 0 0$1 do
113079: GO 113081
113081: DISABLE
// begin globalGameSaveCounter := 0 ;
113082: LD_ADDR_EXP 147
113086: PUSH
113087: LD_INT 0
113089: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
113090: LD_STRING setGameSaveCounter(0)
113092: PPUSH
113093: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
113097: LD_STRING initStreamRollete();
113099: PPUSH
113100: CALL_OW 559
// InitStreamMode ;
113104: CALL 114447 0 0
// DefineStreamItems ( false ) ;
113108: LD_INT 0
113110: PPUSH
113111: CALL 114911 0 1
// end ;
113115: END
// export function SOS_MapStart ( ) ; begin
113116: LD_INT 0
113118: PPUSH
// if streamModeActive then
113119: LD_EXP 148
113123: IFFALSE 113132
// DefineStreamItems ( true ) ;
113125: LD_INT 1
113127: PPUSH
113128: CALL 114911 0 1
// UpdateLuaVariables ( ) ;
113132: CALL 113149 0 0
// UpdateFactoryWaypoints ( ) ;
113136: CALL 127780 0 0
// UpdateWarehouseGatheringPoints ( ) ;
113140: CALL 128037 0 0
// end ;
113144: LD_VAR 0 1
113148: RET
// function UpdateLuaVariables ( ) ; begin
113149: LD_INT 0
113151: PPUSH
// if globalGameSaveCounter then
113152: LD_EXP 147
113156: IFFALSE 113190
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
113158: LD_ADDR_EXP 147
113162: PUSH
113163: LD_EXP 147
113167: PPUSH
113168: CALL 109334 0 1
113172: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113173: LD_STRING setGameSaveCounter(
113175: PUSH
113176: LD_EXP 147
113180: STR
113181: PUSH
113182: LD_STRING )
113184: STR
113185: PPUSH
113186: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
113190: LD_STRING setGameDifficulty(
113192: PUSH
113193: LD_OWVAR 67
113197: STR
113198: PUSH
113199: LD_STRING )
113201: STR
113202: PPUSH
113203: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
113207: LD_STRING displayDifficulty(
113209: PUSH
113210: LD_OWVAR 67
113214: STR
113215: PUSH
113216: LD_STRING )
113218: STR
113219: PPUSH
113220: CALL_OW 559
// end ;
113224: LD_VAR 0 1
113228: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113229: LD_INT 0
113231: PPUSH
// if p2 = stream_mode then
113232: LD_VAR 0 2
113236: PUSH
113237: LD_INT 100
113239: EQUAL
113240: IFFALSE 114243
// begin if not StreamModeActive then
113242: LD_EXP 148
113246: NOT
113247: IFFALSE 113257
// StreamModeActive := true ;
113249: LD_ADDR_EXP 148
113253: PUSH
113254: LD_INT 1
113256: ST_TO_ADDR
// if p3 = 0 then
113257: LD_VAR 0 3
113261: PUSH
113262: LD_INT 0
113264: EQUAL
113265: IFFALSE 113271
// InitStreamMode ;
113267: CALL 114447 0 0
// if p3 = 1 then
113271: LD_VAR 0 3
113275: PUSH
113276: LD_INT 1
113278: EQUAL
113279: IFFALSE 113289
// sRocket := true ;
113281: LD_ADDR_EXP 153
113285: PUSH
113286: LD_INT 1
113288: ST_TO_ADDR
// if p3 = 2 then
113289: LD_VAR 0 3
113293: PUSH
113294: LD_INT 2
113296: EQUAL
113297: IFFALSE 113307
// sSpeed := true ;
113299: LD_ADDR_EXP 152
113303: PUSH
113304: LD_INT 1
113306: ST_TO_ADDR
// if p3 = 3 then
113307: LD_VAR 0 3
113311: PUSH
113312: LD_INT 3
113314: EQUAL
113315: IFFALSE 113325
// sEngine := true ;
113317: LD_ADDR_EXP 154
113321: PUSH
113322: LD_INT 1
113324: ST_TO_ADDR
// if p3 = 4 then
113325: LD_VAR 0 3
113329: PUSH
113330: LD_INT 4
113332: EQUAL
113333: IFFALSE 113343
// sSpec := true ;
113335: LD_ADDR_EXP 151
113339: PUSH
113340: LD_INT 1
113342: ST_TO_ADDR
// if p3 = 5 then
113343: LD_VAR 0 3
113347: PUSH
113348: LD_INT 5
113350: EQUAL
113351: IFFALSE 113361
// sLevel := true ;
113353: LD_ADDR_EXP 155
113357: PUSH
113358: LD_INT 1
113360: ST_TO_ADDR
// if p3 = 6 then
113361: LD_VAR 0 3
113365: PUSH
113366: LD_INT 6
113368: EQUAL
113369: IFFALSE 113379
// sArmoury := true ;
113371: LD_ADDR_EXP 156
113375: PUSH
113376: LD_INT 1
113378: ST_TO_ADDR
// if p3 = 7 then
113379: LD_VAR 0 3
113383: PUSH
113384: LD_INT 7
113386: EQUAL
113387: IFFALSE 113397
// sRadar := true ;
113389: LD_ADDR_EXP 157
113393: PUSH
113394: LD_INT 1
113396: ST_TO_ADDR
// if p3 = 8 then
113397: LD_VAR 0 3
113401: PUSH
113402: LD_INT 8
113404: EQUAL
113405: IFFALSE 113415
// sBunker := true ;
113407: LD_ADDR_EXP 158
113411: PUSH
113412: LD_INT 1
113414: ST_TO_ADDR
// if p3 = 9 then
113415: LD_VAR 0 3
113419: PUSH
113420: LD_INT 9
113422: EQUAL
113423: IFFALSE 113433
// sHack := true ;
113425: LD_ADDR_EXP 159
113429: PUSH
113430: LD_INT 1
113432: ST_TO_ADDR
// if p3 = 10 then
113433: LD_VAR 0 3
113437: PUSH
113438: LD_INT 10
113440: EQUAL
113441: IFFALSE 113451
// sFire := true ;
113443: LD_ADDR_EXP 160
113447: PUSH
113448: LD_INT 1
113450: ST_TO_ADDR
// if p3 = 11 then
113451: LD_VAR 0 3
113455: PUSH
113456: LD_INT 11
113458: EQUAL
113459: IFFALSE 113469
// sRefresh := true ;
113461: LD_ADDR_EXP 161
113465: PUSH
113466: LD_INT 1
113468: ST_TO_ADDR
// if p3 = 12 then
113469: LD_VAR 0 3
113473: PUSH
113474: LD_INT 12
113476: EQUAL
113477: IFFALSE 113487
// sExp := true ;
113479: LD_ADDR_EXP 162
113483: PUSH
113484: LD_INT 1
113486: ST_TO_ADDR
// if p3 = 13 then
113487: LD_VAR 0 3
113491: PUSH
113492: LD_INT 13
113494: EQUAL
113495: IFFALSE 113505
// sDepot := true ;
113497: LD_ADDR_EXP 163
113501: PUSH
113502: LD_INT 1
113504: ST_TO_ADDR
// if p3 = 14 then
113505: LD_VAR 0 3
113509: PUSH
113510: LD_INT 14
113512: EQUAL
113513: IFFALSE 113523
// sFlag := true ;
113515: LD_ADDR_EXP 164
113519: PUSH
113520: LD_INT 1
113522: ST_TO_ADDR
// if p3 = 15 then
113523: LD_VAR 0 3
113527: PUSH
113528: LD_INT 15
113530: EQUAL
113531: IFFALSE 113541
// sKamikadze := true ;
113533: LD_ADDR_EXP 172
113537: PUSH
113538: LD_INT 1
113540: ST_TO_ADDR
// if p3 = 16 then
113541: LD_VAR 0 3
113545: PUSH
113546: LD_INT 16
113548: EQUAL
113549: IFFALSE 113559
// sTroll := true ;
113551: LD_ADDR_EXP 173
113555: PUSH
113556: LD_INT 1
113558: ST_TO_ADDR
// if p3 = 17 then
113559: LD_VAR 0 3
113563: PUSH
113564: LD_INT 17
113566: EQUAL
113567: IFFALSE 113577
// sSlow := true ;
113569: LD_ADDR_EXP 174
113573: PUSH
113574: LD_INT 1
113576: ST_TO_ADDR
// if p3 = 18 then
113577: LD_VAR 0 3
113581: PUSH
113582: LD_INT 18
113584: EQUAL
113585: IFFALSE 113595
// sLack := true ;
113587: LD_ADDR_EXP 175
113591: PUSH
113592: LD_INT 1
113594: ST_TO_ADDR
// if p3 = 19 then
113595: LD_VAR 0 3
113599: PUSH
113600: LD_INT 19
113602: EQUAL
113603: IFFALSE 113613
// sTank := true ;
113605: LD_ADDR_EXP 177
113609: PUSH
113610: LD_INT 1
113612: ST_TO_ADDR
// if p3 = 20 then
113613: LD_VAR 0 3
113617: PUSH
113618: LD_INT 20
113620: EQUAL
113621: IFFALSE 113631
// sRemote := true ;
113623: LD_ADDR_EXP 178
113627: PUSH
113628: LD_INT 1
113630: ST_TO_ADDR
// if p3 = 21 then
113631: LD_VAR 0 3
113635: PUSH
113636: LD_INT 21
113638: EQUAL
113639: IFFALSE 113649
// sPowell := true ;
113641: LD_ADDR_EXP 179
113645: PUSH
113646: LD_INT 1
113648: ST_TO_ADDR
// if p3 = 22 then
113649: LD_VAR 0 3
113653: PUSH
113654: LD_INT 22
113656: EQUAL
113657: IFFALSE 113667
// sTeleport := true ;
113659: LD_ADDR_EXP 182
113663: PUSH
113664: LD_INT 1
113666: ST_TO_ADDR
// if p3 = 23 then
113667: LD_VAR 0 3
113671: PUSH
113672: LD_INT 23
113674: EQUAL
113675: IFFALSE 113685
// sOilTower := true ;
113677: LD_ADDR_EXP 184
113681: PUSH
113682: LD_INT 1
113684: ST_TO_ADDR
// if p3 = 24 then
113685: LD_VAR 0 3
113689: PUSH
113690: LD_INT 24
113692: EQUAL
113693: IFFALSE 113703
// sShovel := true ;
113695: LD_ADDR_EXP 185
113699: PUSH
113700: LD_INT 1
113702: ST_TO_ADDR
// if p3 = 25 then
113703: LD_VAR 0 3
113707: PUSH
113708: LD_INT 25
113710: EQUAL
113711: IFFALSE 113721
// sSheik := true ;
113713: LD_ADDR_EXP 186
113717: PUSH
113718: LD_INT 1
113720: ST_TO_ADDR
// if p3 = 26 then
113721: LD_VAR 0 3
113725: PUSH
113726: LD_INT 26
113728: EQUAL
113729: IFFALSE 113739
// sEarthquake := true ;
113731: LD_ADDR_EXP 188
113735: PUSH
113736: LD_INT 1
113738: ST_TO_ADDR
// if p3 = 27 then
113739: LD_VAR 0 3
113743: PUSH
113744: LD_INT 27
113746: EQUAL
113747: IFFALSE 113757
// sAI := true ;
113749: LD_ADDR_EXP 189
113753: PUSH
113754: LD_INT 1
113756: ST_TO_ADDR
// if p3 = 28 then
113757: LD_VAR 0 3
113761: PUSH
113762: LD_INT 28
113764: EQUAL
113765: IFFALSE 113775
// sCargo := true ;
113767: LD_ADDR_EXP 192
113771: PUSH
113772: LD_INT 1
113774: ST_TO_ADDR
// if p3 = 29 then
113775: LD_VAR 0 3
113779: PUSH
113780: LD_INT 29
113782: EQUAL
113783: IFFALSE 113793
// sDLaser := true ;
113785: LD_ADDR_EXP 193
113789: PUSH
113790: LD_INT 1
113792: ST_TO_ADDR
// if p3 = 30 then
113793: LD_VAR 0 3
113797: PUSH
113798: LD_INT 30
113800: EQUAL
113801: IFFALSE 113811
// sExchange := true ;
113803: LD_ADDR_EXP 194
113807: PUSH
113808: LD_INT 1
113810: ST_TO_ADDR
// if p3 = 31 then
113811: LD_VAR 0 3
113815: PUSH
113816: LD_INT 31
113818: EQUAL
113819: IFFALSE 113829
// sFac := true ;
113821: LD_ADDR_EXP 195
113825: PUSH
113826: LD_INT 1
113828: ST_TO_ADDR
// if p3 = 32 then
113829: LD_VAR 0 3
113833: PUSH
113834: LD_INT 32
113836: EQUAL
113837: IFFALSE 113847
// sPower := true ;
113839: LD_ADDR_EXP 196
113843: PUSH
113844: LD_INT 1
113846: ST_TO_ADDR
// if p3 = 33 then
113847: LD_VAR 0 3
113851: PUSH
113852: LD_INT 33
113854: EQUAL
113855: IFFALSE 113865
// sRandom := true ;
113857: LD_ADDR_EXP 197
113861: PUSH
113862: LD_INT 1
113864: ST_TO_ADDR
// if p3 = 34 then
113865: LD_VAR 0 3
113869: PUSH
113870: LD_INT 34
113872: EQUAL
113873: IFFALSE 113883
// sShield := true ;
113875: LD_ADDR_EXP 198
113879: PUSH
113880: LD_INT 1
113882: ST_TO_ADDR
// if p3 = 35 then
113883: LD_VAR 0 3
113887: PUSH
113888: LD_INT 35
113890: EQUAL
113891: IFFALSE 113901
// sTime := true ;
113893: LD_ADDR_EXP 199
113897: PUSH
113898: LD_INT 1
113900: ST_TO_ADDR
// if p3 = 36 then
113901: LD_VAR 0 3
113905: PUSH
113906: LD_INT 36
113908: EQUAL
113909: IFFALSE 113919
// sTools := true ;
113911: LD_ADDR_EXP 200
113915: PUSH
113916: LD_INT 1
113918: ST_TO_ADDR
// if p3 = 101 then
113919: LD_VAR 0 3
113923: PUSH
113924: LD_INT 101
113926: EQUAL
113927: IFFALSE 113937
// sSold := true ;
113929: LD_ADDR_EXP 165
113933: PUSH
113934: LD_INT 1
113936: ST_TO_ADDR
// if p3 = 102 then
113937: LD_VAR 0 3
113941: PUSH
113942: LD_INT 102
113944: EQUAL
113945: IFFALSE 113955
// sDiff := true ;
113947: LD_ADDR_EXP 166
113951: PUSH
113952: LD_INT 1
113954: ST_TO_ADDR
// if p3 = 103 then
113955: LD_VAR 0 3
113959: PUSH
113960: LD_INT 103
113962: EQUAL
113963: IFFALSE 113973
// sFog := true ;
113965: LD_ADDR_EXP 169
113969: PUSH
113970: LD_INT 1
113972: ST_TO_ADDR
// if p3 = 104 then
113973: LD_VAR 0 3
113977: PUSH
113978: LD_INT 104
113980: EQUAL
113981: IFFALSE 113991
// sReset := true ;
113983: LD_ADDR_EXP 170
113987: PUSH
113988: LD_INT 1
113990: ST_TO_ADDR
// if p3 = 105 then
113991: LD_VAR 0 3
113995: PUSH
113996: LD_INT 105
113998: EQUAL
113999: IFFALSE 114009
// sSun := true ;
114001: LD_ADDR_EXP 171
114005: PUSH
114006: LD_INT 1
114008: ST_TO_ADDR
// if p3 = 106 then
114009: LD_VAR 0 3
114013: PUSH
114014: LD_INT 106
114016: EQUAL
114017: IFFALSE 114027
// sTiger := true ;
114019: LD_ADDR_EXP 167
114023: PUSH
114024: LD_INT 1
114026: ST_TO_ADDR
// if p3 = 107 then
114027: LD_VAR 0 3
114031: PUSH
114032: LD_INT 107
114034: EQUAL
114035: IFFALSE 114045
// sBomb := true ;
114037: LD_ADDR_EXP 168
114041: PUSH
114042: LD_INT 1
114044: ST_TO_ADDR
// if p3 = 108 then
114045: LD_VAR 0 3
114049: PUSH
114050: LD_INT 108
114052: EQUAL
114053: IFFALSE 114063
// sWound := true ;
114055: LD_ADDR_EXP 176
114059: PUSH
114060: LD_INT 1
114062: ST_TO_ADDR
// if p3 = 109 then
114063: LD_VAR 0 3
114067: PUSH
114068: LD_INT 109
114070: EQUAL
114071: IFFALSE 114081
// sBetray := true ;
114073: LD_ADDR_EXP 180
114077: PUSH
114078: LD_INT 1
114080: ST_TO_ADDR
// if p3 = 110 then
114081: LD_VAR 0 3
114085: PUSH
114086: LD_INT 110
114088: EQUAL
114089: IFFALSE 114099
// sContamin := true ;
114091: LD_ADDR_EXP 181
114095: PUSH
114096: LD_INT 1
114098: ST_TO_ADDR
// if p3 = 111 then
114099: LD_VAR 0 3
114103: PUSH
114104: LD_INT 111
114106: EQUAL
114107: IFFALSE 114117
// sOil := true ;
114109: LD_ADDR_EXP 183
114113: PUSH
114114: LD_INT 1
114116: ST_TO_ADDR
// if p3 = 112 then
114117: LD_VAR 0 3
114121: PUSH
114122: LD_INT 112
114124: EQUAL
114125: IFFALSE 114135
// sStu := true ;
114127: LD_ADDR_EXP 187
114131: PUSH
114132: LD_INT 1
114134: ST_TO_ADDR
// if p3 = 113 then
114135: LD_VAR 0 3
114139: PUSH
114140: LD_INT 113
114142: EQUAL
114143: IFFALSE 114153
// sBazooka := true ;
114145: LD_ADDR_EXP 190
114149: PUSH
114150: LD_INT 1
114152: ST_TO_ADDR
// if p3 = 114 then
114153: LD_VAR 0 3
114157: PUSH
114158: LD_INT 114
114160: EQUAL
114161: IFFALSE 114171
// sMortar := true ;
114163: LD_ADDR_EXP 191
114167: PUSH
114168: LD_INT 1
114170: ST_TO_ADDR
// if p3 = 115 then
114171: LD_VAR 0 3
114175: PUSH
114176: LD_INT 115
114178: EQUAL
114179: IFFALSE 114189
// sRanger := true ;
114181: LD_ADDR_EXP 201
114185: PUSH
114186: LD_INT 1
114188: ST_TO_ADDR
// if p3 = 116 then
114189: LD_VAR 0 3
114193: PUSH
114194: LD_INT 116
114196: EQUAL
114197: IFFALSE 114207
// sComputer := true ;
114199: LD_ADDR_EXP 202
114203: PUSH
114204: LD_INT 1
114206: ST_TO_ADDR
// if p3 = 117 then
114207: LD_VAR 0 3
114211: PUSH
114212: LD_INT 117
114214: EQUAL
114215: IFFALSE 114225
// s30 := true ;
114217: LD_ADDR_EXP 203
114221: PUSH
114222: LD_INT 1
114224: ST_TO_ADDR
// if p3 = 118 then
114225: LD_VAR 0 3
114229: PUSH
114230: LD_INT 118
114232: EQUAL
114233: IFFALSE 114243
// s60 := true ;
114235: LD_ADDR_EXP 204
114239: PUSH
114240: LD_INT 1
114242: ST_TO_ADDR
// end ; if p2 = hack_mode then
114243: LD_VAR 0 2
114247: PUSH
114248: LD_INT 101
114250: EQUAL
114251: IFFALSE 114379
// begin case p3 of 1 :
114253: LD_VAR 0 3
114257: PUSH
114258: LD_INT 1
114260: DOUBLE
114261: EQUAL
114262: IFTRUE 114266
114264: GO 114273
114266: POP
// hHackUnlimitedResources ; 2 :
114267: CALL 126526 0 0
114271: GO 114379
114273: LD_INT 2
114275: DOUBLE
114276: EQUAL
114277: IFTRUE 114281
114279: GO 114288
114281: POP
// hHackSetLevel10 ; 3 :
114282: CALL 126659 0 0
114286: GO 114379
114288: LD_INT 3
114290: DOUBLE
114291: EQUAL
114292: IFTRUE 114296
114294: GO 114303
114296: POP
// hHackSetLevel10YourUnits ; 4 :
114297: CALL 126744 0 0
114301: GO 114379
114303: LD_INT 4
114305: DOUBLE
114306: EQUAL
114307: IFTRUE 114311
114309: GO 114318
114311: POP
// hHackInvincible ; 5 :
114312: CALL 127192 0 0
114316: GO 114379
114318: LD_INT 5
114320: DOUBLE
114321: EQUAL
114322: IFTRUE 114326
114324: GO 114333
114326: POP
// hHackInvisible ; 6 :
114327: CALL 127303 0 0
114331: GO 114379
114333: LD_INT 6
114335: DOUBLE
114336: EQUAL
114337: IFTRUE 114341
114339: GO 114348
114341: POP
// hHackChangeYourSide ; 7 :
114342: CALL 127360 0 0
114346: GO 114379
114348: LD_INT 7
114350: DOUBLE
114351: EQUAL
114352: IFTRUE 114356
114354: GO 114363
114356: POP
// hHackChangeUnitSide ; 8 :
114357: CALL 127402 0 0
114361: GO 114379
114363: LD_INT 8
114365: DOUBLE
114366: EQUAL
114367: IFTRUE 114371
114369: GO 114378
114371: POP
// hHackFog ; end ;
114372: CALL 127503 0 0
114376: GO 114379
114378: POP
// end ; if p2 = game_save_mode then
114379: LD_VAR 0 2
114383: PUSH
114384: LD_INT 102
114386: EQUAL
114387: IFFALSE 114442
// begin if p3 = 1 then
114389: LD_VAR 0 3
114393: PUSH
114394: LD_INT 1
114396: EQUAL
114397: IFFALSE 114409
// globalGameSaveCounter := p4 ;
114399: LD_ADDR_EXP 147
114403: PUSH
114404: LD_VAR 0 4
114408: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
114409: LD_VAR 0 3
114413: PUSH
114414: LD_INT 2
114416: EQUAL
114417: PUSH
114418: LD_EXP 147
114422: AND
114423: IFFALSE 114442
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114425: LD_STRING setGameSaveCounter(
114427: PUSH
114428: LD_EXP 147
114432: STR
114433: PUSH
114434: LD_STRING )
114436: STR
114437: PPUSH
114438: CALL_OW 559
// end ; end ;
114442: LD_VAR 0 7
114446: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
114447: LD_INT 0
114449: PPUSH
// streamModeActive := false ;
114450: LD_ADDR_EXP 148
114454: PUSH
114455: LD_INT 0
114457: ST_TO_ADDR
// normalCounter := 36 ;
114458: LD_ADDR_EXP 149
114462: PUSH
114463: LD_INT 36
114465: ST_TO_ADDR
// hardcoreCounter := 18 ;
114466: LD_ADDR_EXP 150
114470: PUSH
114471: LD_INT 18
114473: ST_TO_ADDR
// sRocket := false ;
114474: LD_ADDR_EXP 153
114478: PUSH
114479: LD_INT 0
114481: ST_TO_ADDR
// sSpeed := false ;
114482: LD_ADDR_EXP 152
114486: PUSH
114487: LD_INT 0
114489: ST_TO_ADDR
// sEngine := false ;
114490: LD_ADDR_EXP 154
114494: PUSH
114495: LD_INT 0
114497: ST_TO_ADDR
// sSpec := false ;
114498: LD_ADDR_EXP 151
114502: PUSH
114503: LD_INT 0
114505: ST_TO_ADDR
// sLevel := false ;
114506: LD_ADDR_EXP 155
114510: PUSH
114511: LD_INT 0
114513: ST_TO_ADDR
// sArmoury := false ;
114514: LD_ADDR_EXP 156
114518: PUSH
114519: LD_INT 0
114521: ST_TO_ADDR
// sRadar := false ;
114522: LD_ADDR_EXP 157
114526: PUSH
114527: LD_INT 0
114529: ST_TO_ADDR
// sBunker := false ;
114530: LD_ADDR_EXP 158
114534: PUSH
114535: LD_INT 0
114537: ST_TO_ADDR
// sHack := false ;
114538: LD_ADDR_EXP 159
114542: PUSH
114543: LD_INT 0
114545: ST_TO_ADDR
// sFire := false ;
114546: LD_ADDR_EXP 160
114550: PUSH
114551: LD_INT 0
114553: ST_TO_ADDR
// sRefresh := false ;
114554: LD_ADDR_EXP 161
114558: PUSH
114559: LD_INT 0
114561: ST_TO_ADDR
// sExp := false ;
114562: LD_ADDR_EXP 162
114566: PUSH
114567: LD_INT 0
114569: ST_TO_ADDR
// sDepot := false ;
114570: LD_ADDR_EXP 163
114574: PUSH
114575: LD_INT 0
114577: ST_TO_ADDR
// sFlag := false ;
114578: LD_ADDR_EXP 164
114582: PUSH
114583: LD_INT 0
114585: ST_TO_ADDR
// sKamikadze := false ;
114586: LD_ADDR_EXP 172
114590: PUSH
114591: LD_INT 0
114593: ST_TO_ADDR
// sTroll := false ;
114594: LD_ADDR_EXP 173
114598: PUSH
114599: LD_INT 0
114601: ST_TO_ADDR
// sSlow := false ;
114602: LD_ADDR_EXP 174
114606: PUSH
114607: LD_INT 0
114609: ST_TO_ADDR
// sLack := false ;
114610: LD_ADDR_EXP 175
114614: PUSH
114615: LD_INT 0
114617: ST_TO_ADDR
// sTank := false ;
114618: LD_ADDR_EXP 177
114622: PUSH
114623: LD_INT 0
114625: ST_TO_ADDR
// sRemote := false ;
114626: LD_ADDR_EXP 178
114630: PUSH
114631: LD_INT 0
114633: ST_TO_ADDR
// sPowell := false ;
114634: LD_ADDR_EXP 179
114638: PUSH
114639: LD_INT 0
114641: ST_TO_ADDR
// sTeleport := false ;
114642: LD_ADDR_EXP 182
114646: PUSH
114647: LD_INT 0
114649: ST_TO_ADDR
// sOilTower := false ;
114650: LD_ADDR_EXP 184
114654: PUSH
114655: LD_INT 0
114657: ST_TO_ADDR
// sShovel := false ;
114658: LD_ADDR_EXP 185
114662: PUSH
114663: LD_INT 0
114665: ST_TO_ADDR
// sSheik := false ;
114666: LD_ADDR_EXP 186
114670: PUSH
114671: LD_INT 0
114673: ST_TO_ADDR
// sEarthquake := false ;
114674: LD_ADDR_EXP 188
114678: PUSH
114679: LD_INT 0
114681: ST_TO_ADDR
// sAI := false ;
114682: LD_ADDR_EXP 189
114686: PUSH
114687: LD_INT 0
114689: ST_TO_ADDR
// sCargo := false ;
114690: LD_ADDR_EXP 192
114694: PUSH
114695: LD_INT 0
114697: ST_TO_ADDR
// sDLaser := false ;
114698: LD_ADDR_EXP 193
114702: PUSH
114703: LD_INT 0
114705: ST_TO_ADDR
// sExchange := false ;
114706: LD_ADDR_EXP 194
114710: PUSH
114711: LD_INT 0
114713: ST_TO_ADDR
// sFac := false ;
114714: LD_ADDR_EXP 195
114718: PUSH
114719: LD_INT 0
114721: ST_TO_ADDR
// sPower := false ;
114722: LD_ADDR_EXP 196
114726: PUSH
114727: LD_INT 0
114729: ST_TO_ADDR
// sRandom := false ;
114730: LD_ADDR_EXP 197
114734: PUSH
114735: LD_INT 0
114737: ST_TO_ADDR
// sShield := false ;
114738: LD_ADDR_EXP 198
114742: PUSH
114743: LD_INT 0
114745: ST_TO_ADDR
// sTime := false ;
114746: LD_ADDR_EXP 199
114750: PUSH
114751: LD_INT 0
114753: ST_TO_ADDR
// sTools := false ;
114754: LD_ADDR_EXP 200
114758: PUSH
114759: LD_INT 0
114761: ST_TO_ADDR
// sSold := false ;
114762: LD_ADDR_EXP 165
114766: PUSH
114767: LD_INT 0
114769: ST_TO_ADDR
// sDiff := false ;
114770: LD_ADDR_EXP 166
114774: PUSH
114775: LD_INT 0
114777: ST_TO_ADDR
// sFog := false ;
114778: LD_ADDR_EXP 169
114782: PUSH
114783: LD_INT 0
114785: ST_TO_ADDR
// sReset := false ;
114786: LD_ADDR_EXP 170
114790: PUSH
114791: LD_INT 0
114793: ST_TO_ADDR
// sSun := false ;
114794: LD_ADDR_EXP 171
114798: PUSH
114799: LD_INT 0
114801: ST_TO_ADDR
// sTiger := false ;
114802: LD_ADDR_EXP 167
114806: PUSH
114807: LD_INT 0
114809: ST_TO_ADDR
// sBomb := false ;
114810: LD_ADDR_EXP 168
114814: PUSH
114815: LD_INT 0
114817: ST_TO_ADDR
// sWound := false ;
114818: LD_ADDR_EXP 176
114822: PUSH
114823: LD_INT 0
114825: ST_TO_ADDR
// sBetray := false ;
114826: LD_ADDR_EXP 180
114830: PUSH
114831: LD_INT 0
114833: ST_TO_ADDR
// sContamin := false ;
114834: LD_ADDR_EXP 181
114838: PUSH
114839: LD_INT 0
114841: ST_TO_ADDR
// sOil := false ;
114842: LD_ADDR_EXP 183
114846: PUSH
114847: LD_INT 0
114849: ST_TO_ADDR
// sStu := false ;
114850: LD_ADDR_EXP 187
114854: PUSH
114855: LD_INT 0
114857: ST_TO_ADDR
// sBazooka := false ;
114858: LD_ADDR_EXP 190
114862: PUSH
114863: LD_INT 0
114865: ST_TO_ADDR
// sMortar := false ;
114866: LD_ADDR_EXP 191
114870: PUSH
114871: LD_INT 0
114873: ST_TO_ADDR
// sRanger := false ;
114874: LD_ADDR_EXP 201
114878: PUSH
114879: LD_INT 0
114881: ST_TO_ADDR
// sComputer := false ;
114882: LD_ADDR_EXP 202
114886: PUSH
114887: LD_INT 0
114889: ST_TO_ADDR
// s30 := false ;
114890: LD_ADDR_EXP 203
114894: PUSH
114895: LD_INT 0
114897: ST_TO_ADDR
// s60 := false ;
114898: LD_ADDR_EXP 204
114902: PUSH
114903: LD_INT 0
114905: ST_TO_ADDR
// end ;
114906: LD_VAR 0 1
114910: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114911: LD_INT 0
114913: PPUSH
114914: PPUSH
114915: PPUSH
114916: PPUSH
114917: PPUSH
114918: PPUSH
114919: PPUSH
// result := [ ] ;
114920: LD_ADDR_VAR 0 2
114924: PUSH
114925: EMPTY
114926: ST_TO_ADDR
// if campaign_id = 1 then
114927: LD_OWVAR 69
114931: PUSH
114932: LD_INT 1
114934: EQUAL
114935: IFFALSE 118101
// begin case mission_number of 1 :
114937: LD_OWVAR 70
114941: PUSH
114942: LD_INT 1
114944: DOUBLE
114945: EQUAL
114946: IFTRUE 114950
114948: GO 115026
114950: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114951: LD_ADDR_VAR 0 2
114955: PUSH
114956: LD_INT 2
114958: PUSH
114959: LD_INT 4
114961: PUSH
114962: LD_INT 11
114964: PUSH
114965: LD_INT 12
114967: PUSH
114968: LD_INT 15
114970: PUSH
114971: LD_INT 16
114973: PUSH
114974: LD_INT 22
114976: PUSH
114977: LD_INT 23
114979: PUSH
114980: LD_INT 26
114982: PUSH
114983: EMPTY
114984: LIST
114985: LIST
114986: LIST
114987: LIST
114988: LIST
114989: LIST
114990: LIST
114991: LIST
114992: LIST
114993: PUSH
114994: LD_INT 101
114996: PUSH
114997: LD_INT 102
114999: PUSH
115000: LD_INT 106
115002: PUSH
115003: LD_INT 116
115005: PUSH
115006: LD_INT 117
115008: PUSH
115009: LD_INT 118
115011: PUSH
115012: EMPTY
115013: LIST
115014: LIST
115015: LIST
115016: LIST
115017: LIST
115018: LIST
115019: PUSH
115020: EMPTY
115021: LIST
115022: LIST
115023: ST_TO_ADDR
115024: GO 118099
115026: LD_INT 2
115028: DOUBLE
115029: EQUAL
115030: IFTRUE 115034
115032: GO 115118
115034: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
115035: LD_ADDR_VAR 0 2
115039: PUSH
115040: LD_INT 2
115042: PUSH
115043: LD_INT 4
115045: PUSH
115046: LD_INT 11
115048: PUSH
115049: LD_INT 12
115051: PUSH
115052: LD_INT 15
115054: PUSH
115055: LD_INT 16
115057: PUSH
115058: LD_INT 22
115060: PUSH
115061: LD_INT 23
115063: PUSH
115064: LD_INT 26
115066: PUSH
115067: EMPTY
115068: LIST
115069: LIST
115070: LIST
115071: LIST
115072: LIST
115073: LIST
115074: LIST
115075: LIST
115076: LIST
115077: PUSH
115078: LD_INT 101
115080: PUSH
115081: LD_INT 102
115083: PUSH
115084: LD_INT 105
115086: PUSH
115087: LD_INT 106
115089: PUSH
115090: LD_INT 108
115092: PUSH
115093: LD_INT 116
115095: PUSH
115096: LD_INT 117
115098: PUSH
115099: LD_INT 118
115101: PUSH
115102: EMPTY
115103: LIST
115104: LIST
115105: LIST
115106: LIST
115107: LIST
115108: LIST
115109: LIST
115110: LIST
115111: PUSH
115112: EMPTY
115113: LIST
115114: LIST
115115: ST_TO_ADDR
115116: GO 118099
115118: LD_INT 3
115120: DOUBLE
115121: EQUAL
115122: IFTRUE 115126
115124: GO 115214
115126: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
115127: LD_ADDR_VAR 0 2
115131: PUSH
115132: LD_INT 2
115134: PUSH
115135: LD_INT 4
115137: PUSH
115138: LD_INT 5
115140: PUSH
115141: LD_INT 11
115143: PUSH
115144: LD_INT 12
115146: PUSH
115147: LD_INT 15
115149: PUSH
115150: LD_INT 16
115152: PUSH
115153: LD_INT 22
115155: PUSH
115156: LD_INT 26
115158: PUSH
115159: LD_INT 36
115161: PUSH
115162: EMPTY
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: PUSH
115174: LD_INT 101
115176: PUSH
115177: LD_INT 102
115179: PUSH
115180: LD_INT 105
115182: PUSH
115183: LD_INT 106
115185: PUSH
115186: LD_INT 108
115188: PUSH
115189: LD_INT 116
115191: PUSH
115192: LD_INT 117
115194: PUSH
115195: LD_INT 118
115197: PUSH
115198: EMPTY
115199: LIST
115200: LIST
115201: LIST
115202: LIST
115203: LIST
115204: LIST
115205: LIST
115206: LIST
115207: PUSH
115208: EMPTY
115209: LIST
115210: LIST
115211: ST_TO_ADDR
115212: GO 118099
115214: LD_INT 4
115216: DOUBLE
115217: EQUAL
115218: IFTRUE 115222
115220: GO 115318
115222: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
115223: LD_ADDR_VAR 0 2
115227: PUSH
115228: LD_INT 2
115230: PUSH
115231: LD_INT 4
115233: PUSH
115234: LD_INT 5
115236: PUSH
115237: LD_INT 8
115239: PUSH
115240: LD_INT 11
115242: PUSH
115243: LD_INT 12
115245: PUSH
115246: LD_INT 15
115248: PUSH
115249: LD_INT 16
115251: PUSH
115252: LD_INT 22
115254: PUSH
115255: LD_INT 23
115257: PUSH
115258: LD_INT 26
115260: PUSH
115261: LD_INT 36
115263: PUSH
115264: EMPTY
115265: LIST
115266: LIST
115267: LIST
115268: LIST
115269: LIST
115270: LIST
115271: LIST
115272: LIST
115273: LIST
115274: LIST
115275: LIST
115276: LIST
115277: PUSH
115278: LD_INT 101
115280: PUSH
115281: LD_INT 102
115283: PUSH
115284: LD_INT 105
115286: PUSH
115287: LD_INT 106
115289: PUSH
115290: LD_INT 108
115292: PUSH
115293: LD_INT 116
115295: PUSH
115296: LD_INT 117
115298: PUSH
115299: LD_INT 118
115301: PUSH
115302: EMPTY
115303: LIST
115304: LIST
115305: LIST
115306: LIST
115307: LIST
115308: LIST
115309: LIST
115310: LIST
115311: PUSH
115312: EMPTY
115313: LIST
115314: LIST
115315: ST_TO_ADDR
115316: GO 118099
115318: LD_INT 5
115320: DOUBLE
115321: EQUAL
115322: IFTRUE 115326
115324: GO 115438
115326: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
115327: LD_ADDR_VAR 0 2
115331: PUSH
115332: LD_INT 2
115334: PUSH
115335: LD_INT 4
115337: PUSH
115338: LD_INT 5
115340: PUSH
115341: LD_INT 6
115343: PUSH
115344: LD_INT 8
115346: PUSH
115347: LD_INT 11
115349: PUSH
115350: LD_INT 12
115352: PUSH
115353: LD_INT 15
115355: PUSH
115356: LD_INT 16
115358: PUSH
115359: LD_INT 22
115361: PUSH
115362: LD_INT 23
115364: PUSH
115365: LD_INT 25
115367: PUSH
115368: LD_INT 26
115370: PUSH
115371: LD_INT 36
115373: PUSH
115374: EMPTY
115375: LIST
115376: LIST
115377: LIST
115378: LIST
115379: LIST
115380: LIST
115381: LIST
115382: LIST
115383: LIST
115384: LIST
115385: LIST
115386: LIST
115387: LIST
115388: LIST
115389: PUSH
115390: LD_INT 101
115392: PUSH
115393: LD_INT 102
115395: PUSH
115396: LD_INT 105
115398: PUSH
115399: LD_INT 106
115401: PUSH
115402: LD_INT 108
115404: PUSH
115405: LD_INT 109
115407: PUSH
115408: LD_INT 112
115410: PUSH
115411: LD_INT 116
115413: PUSH
115414: LD_INT 117
115416: PUSH
115417: LD_INT 118
115419: PUSH
115420: EMPTY
115421: LIST
115422: LIST
115423: LIST
115424: LIST
115425: LIST
115426: LIST
115427: LIST
115428: LIST
115429: LIST
115430: LIST
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: ST_TO_ADDR
115436: GO 118099
115438: LD_INT 6
115440: DOUBLE
115441: EQUAL
115442: IFTRUE 115446
115444: GO 115578
115446: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
115447: LD_ADDR_VAR 0 2
115451: PUSH
115452: LD_INT 2
115454: PUSH
115455: LD_INT 4
115457: PUSH
115458: LD_INT 5
115460: PUSH
115461: LD_INT 6
115463: PUSH
115464: LD_INT 8
115466: PUSH
115467: LD_INT 11
115469: PUSH
115470: LD_INT 12
115472: PUSH
115473: LD_INT 15
115475: PUSH
115476: LD_INT 16
115478: PUSH
115479: LD_INT 20
115481: PUSH
115482: LD_INT 21
115484: PUSH
115485: LD_INT 22
115487: PUSH
115488: LD_INT 23
115490: PUSH
115491: LD_INT 25
115493: PUSH
115494: LD_INT 26
115496: PUSH
115497: LD_INT 30
115499: PUSH
115500: LD_INT 31
115502: PUSH
115503: LD_INT 32
115505: PUSH
115506: LD_INT 36
115508: PUSH
115509: EMPTY
115510: LIST
115511: LIST
115512: LIST
115513: LIST
115514: LIST
115515: LIST
115516: LIST
115517: LIST
115518: LIST
115519: LIST
115520: LIST
115521: LIST
115522: LIST
115523: LIST
115524: LIST
115525: LIST
115526: LIST
115527: LIST
115528: LIST
115529: PUSH
115530: LD_INT 101
115532: PUSH
115533: LD_INT 102
115535: PUSH
115536: LD_INT 105
115538: PUSH
115539: LD_INT 106
115541: PUSH
115542: LD_INT 108
115544: PUSH
115545: LD_INT 109
115547: PUSH
115548: LD_INT 112
115550: PUSH
115551: LD_INT 116
115553: PUSH
115554: LD_INT 117
115556: PUSH
115557: LD_INT 118
115559: PUSH
115560: EMPTY
115561: LIST
115562: LIST
115563: LIST
115564: LIST
115565: LIST
115566: LIST
115567: LIST
115568: LIST
115569: LIST
115570: LIST
115571: PUSH
115572: EMPTY
115573: LIST
115574: LIST
115575: ST_TO_ADDR
115576: GO 118099
115578: LD_INT 7
115580: DOUBLE
115581: EQUAL
115582: IFTRUE 115586
115584: GO 115698
115586: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115587: LD_ADDR_VAR 0 2
115591: PUSH
115592: LD_INT 2
115594: PUSH
115595: LD_INT 4
115597: PUSH
115598: LD_INT 5
115600: PUSH
115601: LD_INT 7
115603: PUSH
115604: LD_INT 11
115606: PUSH
115607: LD_INT 12
115609: PUSH
115610: LD_INT 15
115612: PUSH
115613: LD_INT 16
115615: PUSH
115616: LD_INT 20
115618: PUSH
115619: LD_INT 21
115621: PUSH
115622: LD_INT 22
115624: PUSH
115625: LD_INT 23
115627: PUSH
115628: LD_INT 25
115630: PUSH
115631: LD_INT 26
115633: PUSH
115634: EMPTY
115635: LIST
115636: LIST
115637: LIST
115638: LIST
115639: LIST
115640: LIST
115641: LIST
115642: LIST
115643: LIST
115644: LIST
115645: LIST
115646: LIST
115647: LIST
115648: LIST
115649: PUSH
115650: LD_INT 101
115652: PUSH
115653: LD_INT 102
115655: PUSH
115656: LD_INT 103
115658: PUSH
115659: LD_INT 105
115661: PUSH
115662: LD_INT 106
115664: PUSH
115665: LD_INT 108
115667: PUSH
115668: LD_INT 112
115670: PUSH
115671: LD_INT 116
115673: PUSH
115674: LD_INT 117
115676: PUSH
115677: LD_INT 118
115679: PUSH
115680: EMPTY
115681: LIST
115682: LIST
115683: LIST
115684: LIST
115685: LIST
115686: LIST
115687: LIST
115688: LIST
115689: LIST
115690: LIST
115691: PUSH
115692: EMPTY
115693: LIST
115694: LIST
115695: ST_TO_ADDR
115696: GO 118099
115698: LD_INT 8
115700: DOUBLE
115701: EQUAL
115702: IFTRUE 115706
115704: GO 115846
115706: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115707: LD_ADDR_VAR 0 2
115711: PUSH
115712: LD_INT 2
115714: PUSH
115715: LD_INT 4
115717: PUSH
115718: LD_INT 5
115720: PUSH
115721: LD_INT 6
115723: PUSH
115724: LD_INT 7
115726: PUSH
115727: LD_INT 8
115729: PUSH
115730: LD_INT 11
115732: PUSH
115733: LD_INT 12
115735: PUSH
115736: LD_INT 15
115738: PUSH
115739: LD_INT 16
115741: PUSH
115742: LD_INT 20
115744: PUSH
115745: LD_INT 21
115747: PUSH
115748: LD_INT 22
115750: PUSH
115751: LD_INT 23
115753: PUSH
115754: LD_INT 25
115756: PUSH
115757: LD_INT 26
115759: PUSH
115760: LD_INT 30
115762: PUSH
115763: LD_INT 31
115765: PUSH
115766: LD_INT 32
115768: PUSH
115769: LD_INT 36
115771: PUSH
115772: EMPTY
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: LIST
115784: LIST
115785: LIST
115786: LIST
115787: LIST
115788: LIST
115789: LIST
115790: LIST
115791: LIST
115792: LIST
115793: PUSH
115794: LD_INT 101
115796: PUSH
115797: LD_INT 102
115799: PUSH
115800: LD_INT 103
115802: PUSH
115803: LD_INT 105
115805: PUSH
115806: LD_INT 106
115808: PUSH
115809: LD_INT 108
115811: PUSH
115812: LD_INT 109
115814: PUSH
115815: LD_INT 112
115817: PUSH
115818: LD_INT 116
115820: PUSH
115821: LD_INT 117
115823: PUSH
115824: LD_INT 118
115826: PUSH
115827: EMPTY
115828: LIST
115829: LIST
115830: LIST
115831: LIST
115832: LIST
115833: LIST
115834: LIST
115835: LIST
115836: LIST
115837: LIST
115838: LIST
115839: PUSH
115840: EMPTY
115841: LIST
115842: LIST
115843: ST_TO_ADDR
115844: GO 118099
115846: LD_INT 9
115848: DOUBLE
115849: EQUAL
115850: IFTRUE 115854
115852: GO 116002
115854: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115855: LD_ADDR_VAR 0 2
115859: PUSH
115860: LD_INT 2
115862: PUSH
115863: LD_INT 4
115865: PUSH
115866: LD_INT 5
115868: PUSH
115869: LD_INT 6
115871: PUSH
115872: LD_INT 7
115874: PUSH
115875: LD_INT 8
115877: PUSH
115878: LD_INT 11
115880: PUSH
115881: LD_INT 12
115883: PUSH
115884: LD_INT 15
115886: PUSH
115887: LD_INT 16
115889: PUSH
115890: LD_INT 20
115892: PUSH
115893: LD_INT 21
115895: PUSH
115896: LD_INT 22
115898: PUSH
115899: LD_INT 23
115901: PUSH
115902: LD_INT 25
115904: PUSH
115905: LD_INT 26
115907: PUSH
115908: LD_INT 28
115910: PUSH
115911: LD_INT 30
115913: PUSH
115914: LD_INT 31
115916: PUSH
115917: LD_INT 32
115919: PUSH
115920: LD_INT 36
115922: PUSH
115923: EMPTY
115924: LIST
115925: LIST
115926: LIST
115927: LIST
115928: LIST
115929: LIST
115930: LIST
115931: LIST
115932: LIST
115933: LIST
115934: LIST
115935: LIST
115936: LIST
115937: LIST
115938: LIST
115939: LIST
115940: LIST
115941: LIST
115942: LIST
115943: LIST
115944: LIST
115945: PUSH
115946: LD_INT 101
115948: PUSH
115949: LD_INT 102
115951: PUSH
115952: LD_INT 103
115954: PUSH
115955: LD_INT 105
115957: PUSH
115958: LD_INT 106
115960: PUSH
115961: LD_INT 108
115963: PUSH
115964: LD_INT 109
115966: PUSH
115967: LD_INT 112
115969: PUSH
115970: LD_INT 114
115972: PUSH
115973: LD_INT 116
115975: PUSH
115976: LD_INT 117
115978: PUSH
115979: LD_INT 118
115981: PUSH
115982: EMPTY
115983: LIST
115984: LIST
115985: LIST
115986: LIST
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: LIST
115992: LIST
115993: LIST
115994: LIST
115995: PUSH
115996: EMPTY
115997: LIST
115998: LIST
115999: ST_TO_ADDR
116000: GO 118099
116002: LD_INT 10
116004: DOUBLE
116005: EQUAL
116006: IFTRUE 116010
116008: GO 116206
116010: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
116011: LD_ADDR_VAR 0 2
116015: PUSH
116016: LD_INT 2
116018: PUSH
116019: LD_INT 4
116021: PUSH
116022: LD_INT 5
116024: PUSH
116025: LD_INT 6
116027: PUSH
116028: LD_INT 7
116030: PUSH
116031: LD_INT 8
116033: PUSH
116034: LD_INT 9
116036: PUSH
116037: LD_INT 10
116039: PUSH
116040: LD_INT 11
116042: PUSH
116043: LD_INT 12
116045: PUSH
116046: LD_INT 13
116048: PUSH
116049: LD_INT 14
116051: PUSH
116052: LD_INT 15
116054: PUSH
116055: LD_INT 16
116057: PUSH
116058: LD_INT 17
116060: PUSH
116061: LD_INT 18
116063: PUSH
116064: LD_INT 19
116066: PUSH
116067: LD_INT 20
116069: PUSH
116070: LD_INT 21
116072: PUSH
116073: LD_INT 22
116075: PUSH
116076: LD_INT 23
116078: PUSH
116079: LD_INT 24
116081: PUSH
116082: LD_INT 25
116084: PUSH
116085: LD_INT 26
116087: PUSH
116088: LD_INT 28
116090: PUSH
116091: LD_INT 30
116093: PUSH
116094: LD_INT 31
116096: PUSH
116097: LD_INT 32
116099: PUSH
116100: LD_INT 36
116102: PUSH
116103: EMPTY
116104: LIST
116105: LIST
116106: LIST
116107: LIST
116108: LIST
116109: LIST
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: LIST
116115: LIST
116116: LIST
116117: LIST
116118: LIST
116119: LIST
116120: LIST
116121: LIST
116122: LIST
116123: LIST
116124: LIST
116125: LIST
116126: LIST
116127: LIST
116128: LIST
116129: LIST
116130: LIST
116131: LIST
116132: LIST
116133: PUSH
116134: LD_INT 101
116136: PUSH
116137: LD_INT 102
116139: PUSH
116140: LD_INT 103
116142: PUSH
116143: LD_INT 104
116145: PUSH
116146: LD_INT 105
116148: PUSH
116149: LD_INT 106
116151: PUSH
116152: LD_INT 107
116154: PUSH
116155: LD_INT 108
116157: PUSH
116158: LD_INT 109
116160: PUSH
116161: LD_INT 110
116163: PUSH
116164: LD_INT 111
116166: PUSH
116167: LD_INT 112
116169: PUSH
116170: LD_INT 114
116172: PUSH
116173: LD_INT 116
116175: PUSH
116176: LD_INT 117
116178: PUSH
116179: LD_INT 118
116181: PUSH
116182: EMPTY
116183: LIST
116184: LIST
116185: LIST
116186: LIST
116187: LIST
116188: LIST
116189: LIST
116190: LIST
116191: LIST
116192: LIST
116193: LIST
116194: LIST
116195: LIST
116196: LIST
116197: LIST
116198: LIST
116199: PUSH
116200: EMPTY
116201: LIST
116202: LIST
116203: ST_TO_ADDR
116204: GO 118099
116206: LD_INT 11
116208: DOUBLE
116209: EQUAL
116210: IFTRUE 116214
116212: GO 116418
116214: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
116215: LD_ADDR_VAR 0 2
116219: PUSH
116220: LD_INT 2
116222: PUSH
116223: LD_INT 3
116225: PUSH
116226: LD_INT 4
116228: PUSH
116229: LD_INT 5
116231: PUSH
116232: LD_INT 6
116234: PUSH
116235: LD_INT 7
116237: PUSH
116238: LD_INT 8
116240: PUSH
116241: LD_INT 9
116243: PUSH
116244: LD_INT 10
116246: PUSH
116247: LD_INT 11
116249: PUSH
116250: LD_INT 12
116252: PUSH
116253: LD_INT 13
116255: PUSH
116256: LD_INT 14
116258: PUSH
116259: LD_INT 15
116261: PUSH
116262: LD_INT 16
116264: PUSH
116265: LD_INT 17
116267: PUSH
116268: LD_INT 18
116270: PUSH
116271: LD_INT 19
116273: PUSH
116274: LD_INT 20
116276: PUSH
116277: LD_INT 21
116279: PUSH
116280: LD_INT 22
116282: PUSH
116283: LD_INT 23
116285: PUSH
116286: LD_INT 24
116288: PUSH
116289: LD_INT 25
116291: PUSH
116292: LD_INT 26
116294: PUSH
116295: LD_INT 28
116297: PUSH
116298: LD_INT 30
116300: PUSH
116301: LD_INT 31
116303: PUSH
116304: LD_INT 32
116306: PUSH
116307: LD_INT 34
116309: PUSH
116310: LD_INT 36
116312: PUSH
116313: EMPTY
116314: LIST
116315: LIST
116316: LIST
116317: LIST
116318: LIST
116319: LIST
116320: LIST
116321: LIST
116322: LIST
116323: LIST
116324: LIST
116325: LIST
116326: LIST
116327: LIST
116328: LIST
116329: LIST
116330: LIST
116331: LIST
116332: LIST
116333: LIST
116334: LIST
116335: LIST
116336: LIST
116337: LIST
116338: LIST
116339: LIST
116340: LIST
116341: LIST
116342: LIST
116343: LIST
116344: LIST
116345: PUSH
116346: LD_INT 101
116348: PUSH
116349: LD_INT 102
116351: PUSH
116352: LD_INT 103
116354: PUSH
116355: LD_INT 104
116357: PUSH
116358: LD_INT 105
116360: PUSH
116361: LD_INT 106
116363: PUSH
116364: LD_INT 107
116366: PUSH
116367: LD_INT 108
116369: PUSH
116370: LD_INT 109
116372: PUSH
116373: LD_INT 110
116375: PUSH
116376: LD_INT 111
116378: PUSH
116379: LD_INT 112
116381: PUSH
116382: LD_INT 114
116384: PUSH
116385: LD_INT 116
116387: PUSH
116388: LD_INT 117
116390: PUSH
116391: LD_INT 118
116393: PUSH
116394: EMPTY
116395: LIST
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: LIST
116402: LIST
116403: LIST
116404: LIST
116405: LIST
116406: LIST
116407: LIST
116408: LIST
116409: LIST
116410: LIST
116411: PUSH
116412: EMPTY
116413: LIST
116414: LIST
116415: ST_TO_ADDR
116416: GO 118099
116418: LD_INT 12
116420: DOUBLE
116421: EQUAL
116422: IFTRUE 116426
116424: GO 116646
116426: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
116427: LD_ADDR_VAR 0 2
116431: PUSH
116432: LD_INT 1
116434: PUSH
116435: LD_INT 2
116437: PUSH
116438: LD_INT 3
116440: PUSH
116441: LD_INT 4
116443: PUSH
116444: LD_INT 5
116446: PUSH
116447: LD_INT 6
116449: PUSH
116450: LD_INT 7
116452: PUSH
116453: LD_INT 8
116455: PUSH
116456: LD_INT 9
116458: PUSH
116459: LD_INT 10
116461: PUSH
116462: LD_INT 11
116464: PUSH
116465: LD_INT 12
116467: PUSH
116468: LD_INT 13
116470: PUSH
116471: LD_INT 14
116473: PUSH
116474: LD_INT 15
116476: PUSH
116477: LD_INT 16
116479: PUSH
116480: LD_INT 17
116482: PUSH
116483: LD_INT 18
116485: PUSH
116486: LD_INT 19
116488: PUSH
116489: LD_INT 20
116491: PUSH
116492: LD_INT 21
116494: PUSH
116495: LD_INT 22
116497: PUSH
116498: LD_INT 23
116500: PUSH
116501: LD_INT 24
116503: PUSH
116504: LD_INT 25
116506: PUSH
116507: LD_INT 26
116509: PUSH
116510: LD_INT 27
116512: PUSH
116513: LD_INT 28
116515: PUSH
116516: LD_INT 30
116518: PUSH
116519: LD_INT 31
116521: PUSH
116522: LD_INT 32
116524: PUSH
116525: LD_INT 33
116527: PUSH
116528: LD_INT 34
116530: PUSH
116531: LD_INT 36
116533: PUSH
116534: EMPTY
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: LIST
116546: LIST
116547: LIST
116548: LIST
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: LIST
116554: LIST
116555: LIST
116556: LIST
116557: LIST
116558: LIST
116559: LIST
116560: LIST
116561: LIST
116562: LIST
116563: LIST
116564: LIST
116565: LIST
116566: LIST
116567: LIST
116568: LIST
116569: PUSH
116570: LD_INT 101
116572: PUSH
116573: LD_INT 102
116575: PUSH
116576: LD_INT 103
116578: PUSH
116579: LD_INT 104
116581: PUSH
116582: LD_INT 105
116584: PUSH
116585: LD_INT 106
116587: PUSH
116588: LD_INT 107
116590: PUSH
116591: LD_INT 108
116593: PUSH
116594: LD_INT 109
116596: PUSH
116597: LD_INT 110
116599: PUSH
116600: LD_INT 111
116602: PUSH
116603: LD_INT 112
116605: PUSH
116606: LD_INT 113
116608: PUSH
116609: LD_INT 114
116611: PUSH
116612: LD_INT 116
116614: PUSH
116615: LD_INT 117
116617: PUSH
116618: LD_INT 118
116620: PUSH
116621: EMPTY
116622: LIST
116623: LIST
116624: LIST
116625: LIST
116626: LIST
116627: LIST
116628: LIST
116629: LIST
116630: LIST
116631: LIST
116632: LIST
116633: LIST
116634: LIST
116635: LIST
116636: LIST
116637: LIST
116638: LIST
116639: PUSH
116640: EMPTY
116641: LIST
116642: LIST
116643: ST_TO_ADDR
116644: GO 118099
116646: LD_INT 13
116648: DOUBLE
116649: EQUAL
116650: IFTRUE 116654
116652: GO 116862
116654: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116655: LD_ADDR_VAR 0 2
116659: PUSH
116660: LD_INT 1
116662: PUSH
116663: LD_INT 2
116665: PUSH
116666: LD_INT 3
116668: PUSH
116669: LD_INT 4
116671: PUSH
116672: LD_INT 5
116674: PUSH
116675: LD_INT 8
116677: PUSH
116678: LD_INT 9
116680: PUSH
116681: LD_INT 10
116683: PUSH
116684: LD_INT 11
116686: PUSH
116687: LD_INT 12
116689: PUSH
116690: LD_INT 14
116692: PUSH
116693: LD_INT 15
116695: PUSH
116696: LD_INT 16
116698: PUSH
116699: LD_INT 17
116701: PUSH
116702: LD_INT 18
116704: PUSH
116705: LD_INT 19
116707: PUSH
116708: LD_INT 20
116710: PUSH
116711: LD_INT 21
116713: PUSH
116714: LD_INT 22
116716: PUSH
116717: LD_INT 23
116719: PUSH
116720: LD_INT 24
116722: PUSH
116723: LD_INT 25
116725: PUSH
116726: LD_INT 26
116728: PUSH
116729: LD_INT 27
116731: PUSH
116732: LD_INT 28
116734: PUSH
116735: LD_INT 30
116737: PUSH
116738: LD_INT 31
116740: PUSH
116741: LD_INT 32
116743: PUSH
116744: LD_INT 33
116746: PUSH
116747: LD_INT 34
116749: PUSH
116750: LD_INT 36
116752: PUSH
116753: EMPTY
116754: LIST
116755: LIST
116756: LIST
116757: LIST
116758: LIST
116759: LIST
116760: LIST
116761: LIST
116762: LIST
116763: LIST
116764: LIST
116765: LIST
116766: LIST
116767: LIST
116768: LIST
116769: LIST
116770: LIST
116771: LIST
116772: LIST
116773: LIST
116774: LIST
116775: LIST
116776: LIST
116777: LIST
116778: LIST
116779: LIST
116780: LIST
116781: LIST
116782: LIST
116783: LIST
116784: LIST
116785: PUSH
116786: LD_INT 101
116788: PUSH
116789: LD_INT 102
116791: PUSH
116792: LD_INT 103
116794: PUSH
116795: LD_INT 104
116797: PUSH
116798: LD_INT 105
116800: PUSH
116801: LD_INT 106
116803: PUSH
116804: LD_INT 107
116806: PUSH
116807: LD_INT 108
116809: PUSH
116810: LD_INT 109
116812: PUSH
116813: LD_INT 110
116815: PUSH
116816: LD_INT 111
116818: PUSH
116819: LD_INT 112
116821: PUSH
116822: LD_INT 113
116824: PUSH
116825: LD_INT 114
116827: PUSH
116828: LD_INT 116
116830: PUSH
116831: LD_INT 117
116833: PUSH
116834: LD_INT 118
116836: PUSH
116837: EMPTY
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: LIST
116847: LIST
116848: LIST
116849: LIST
116850: LIST
116851: LIST
116852: LIST
116853: LIST
116854: LIST
116855: PUSH
116856: EMPTY
116857: LIST
116858: LIST
116859: ST_TO_ADDR
116860: GO 118099
116862: LD_INT 14
116864: DOUBLE
116865: EQUAL
116866: IFTRUE 116870
116868: GO 117094
116870: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116871: LD_ADDR_VAR 0 2
116875: PUSH
116876: LD_INT 1
116878: PUSH
116879: LD_INT 2
116881: PUSH
116882: LD_INT 3
116884: PUSH
116885: LD_INT 4
116887: PUSH
116888: LD_INT 5
116890: PUSH
116891: LD_INT 6
116893: PUSH
116894: LD_INT 7
116896: PUSH
116897: LD_INT 8
116899: PUSH
116900: LD_INT 9
116902: PUSH
116903: LD_INT 10
116905: PUSH
116906: LD_INT 11
116908: PUSH
116909: LD_INT 12
116911: PUSH
116912: LD_INT 13
116914: PUSH
116915: LD_INT 14
116917: PUSH
116918: LD_INT 15
116920: PUSH
116921: LD_INT 16
116923: PUSH
116924: LD_INT 17
116926: PUSH
116927: LD_INT 18
116929: PUSH
116930: LD_INT 19
116932: PUSH
116933: LD_INT 20
116935: PUSH
116936: LD_INT 21
116938: PUSH
116939: LD_INT 22
116941: PUSH
116942: LD_INT 23
116944: PUSH
116945: LD_INT 24
116947: PUSH
116948: LD_INT 25
116950: PUSH
116951: LD_INT 26
116953: PUSH
116954: LD_INT 27
116956: PUSH
116957: LD_INT 28
116959: PUSH
116960: LD_INT 29
116962: PUSH
116963: LD_INT 30
116965: PUSH
116966: LD_INT 31
116968: PUSH
116969: LD_INT 32
116971: PUSH
116972: LD_INT 33
116974: PUSH
116975: LD_INT 34
116977: PUSH
116978: LD_INT 36
116980: PUSH
116981: EMPTY
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: LIST
116993: LIST
116994: LIST
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: LIST
117000: LIST
117001: LIST
117002: LIST
117003: LIST
117004: LIST
117005: LIST
117006: LIST
117007: LIST
117008: LIST
117009: LIST
117010: LIST
117011: LIST
117012: LIST
117013: LIST
117014: LIST
117015: LIST
117016: LIST
117017: PUSH
117018: LD_INT 101
117020: PUSH
117021: LD_INT 102
117023: PUSH
117024: LD_INT 103
117026: PUSH
117027: LD_INT 104
117029: PUSH
117030: LD_INT 105
117032: PUSH
117033: LD_INT 106
117035: PUSH
117036: LD_INT 107
117038: PUSH
117039: LD_INT 108
117041: PUSH
117042: LD_INT 109
117044: PUSH
117045: LD_INT 110
117047: PUSH
117048: LD_INT 111
117050: PUSH
117051: LD_INT 112
117053: PUSH
117054: LD_INT 113
117056: PUSH
117057: LD_INT 114
117059: PUSH
117060: LD_INT 116
117062: PUSH
117063: LD_INT 117
117065: PUSH
117066: LD_INT 118
117068: PUSH
117069: EMPTY
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: LIST
117075: LIST
117076: LIST
117077: LIST
117078: LIST
117079: LIST
117080: LIST
117081: LIST
117082: LIST
117083: LIST
117084: LIST
117085: LIST
117086: LIST
117087: PUSH
117088: EMPTY
117089: LIST
117090: LIST
117091: ST_TO_ADDR
117092: GO 118099
117094: LD_INT 15
117096: DOUBLE
117097: EQUAL
117098: IFTRUE 117102
117100: GO 117326
117102: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
117103: LD_ADDR_VAR 0 2
117107: PUSH
117108: LD_INT 1
117110: PUSH
117111: LD_INT 2
117113: PUSH
117114: LD_INT 3
117116: PUSH
117117: LD_INT 4
117119: PUSH
117120: LD_INT 5
117122: PUSH
117123: LD_INT 6
117125: PUSH
117126: LD_INT 7
117128: PUSH
117129: LD_INT 8
117131: PUSH
117132: LD_INT 9
117134: PUSH
117135: LD_INT 10
117137: PUSH
117138: LD_INT 11
117140: PUSH
117141: LD_INT 12
117143: PUSH
117144: LD_INT 13
117146: PUSH
117147: LD_INT 14
117149: PUSH
117150: LD_INT 15
117152: PUSH
117153: LD_INT 16
117155: PUSH
117156: LD_INT 17
117158: PUSH
117159: LD_INT 18
117161: PUSH
117162: LD_INT 19
117164: PUSH
117165: LD_INT 20
117167: PUSH
117168: LD_INT 21
117170: PUSH
117171: LD_INT 22
117173: PUSH
117174: LD_INT 23
117176: PUSH
117177: LD_INT 24
117179: PUSH
117180: LD_INT 25
117182: PUSH
117183: LD_INT 26
117185: PUSH
117186: LD_INT 27
117188: PUSH
117189: LD_INT 28
117191: PUSH
117192: LD_INT 29
117194: PUSH
117195: LD_INT 30
117197: PUSH
117198: LD_INT 31
117200: PUSH
117201: LD_INT 32
117203: PUSH
117204: LD_INT 33
117206: PUSH
117207: LD_INT 34
117209: PUSH
117210: LD_INT 36
117212: PUSH
117213: EMPTY
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: LIST
117236: LIST
117237: LIST
117238: LIST
117239: LIST
117240: LIST
117241: LIST
117242: LIST
117243: LIST
117244: LIST
117245: LIST
117246: LIST
117247: LIST
117248: LIST
117249: PUSH
117250: LD_INT 101
117252: PUSH
117253: LD_INT 102
117255: PUSH
117256: LD_INT 103
117258: PUSH
117259: LD_INT 104
117261: PUSH
117262: LD_INT 105
117264: PUSH
117265: LD_INT 106
117267: PUSH
117268: LD_INT 107
117270: PUSH
117271: LD_INT 108
117273: PUSH
117274: LD_INT 109
117276: PUSH
117277: LD_INT 110
117279: PUSH
117280: LD_INT 111
117282: PUSH
117283: LD_INT 112
117285: PUSH
117286: LD_INT 113
117288: PUSH
117289: LD_INT 114
117291: PUSH
117292: LD_INT 116
117294: PUSH
117295: LD_INT 117
117297: PUSH
117298: LD_INT 118
117300: PUSH
117301: EMPTY
117302: LIST
117303: LIST
117304: LIST
117305: LIST
117306: LIST
117307: LIST
117308: LIST
117309: LIST
117310: LIST
117311: LIST
117312: LIST
117313: LIST
117314: LIST
117315: LIST
117316: LIST
117317: LIST
117318: LIST
117319: PUSH
117320: EMPTY
117321: LIST
117322: LIST
117323: ST_TO_ADDR
117324: GO 118099
117326: LD_INT 16
117328: DOUBLE
117329: EQUAL
117330: IFTRUE 117334
117332: GO 117470
117334: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
117335: LD_ADDR_VAR 0 2
117339: PUSH
117340: LD_INT 2
117342: PUSH
117343: LD_INT 4
117345: PUSH
117346: LD_INT 5
117348: PUSH
117349: LD_INT 7
117351: PUSH
117352: LD_INT 11
117354: PUSH
117355: LD_INT 12
117357: PUSH
117358: LD_INT 15
117360: PUSH
117361: LD_INT 16
117363: PUSH
117364: LD_INT 20
117366: PUSH
117367: LD_INT 21
117369: PUSH
117370: LD_INT 22
117372: PUSH
117373: LD_INT 23
117375: PUSH
117376: LD_INT 25
117378: PUSH
117379: LD_INT 26
117381: PUSH
117382: LD_INT 30
117384: PUSH
117385: LD_INT 31
117387: PUSH
117388: LD_INT 32
117390: PUSH
117391: LD_INT 33
117393: PUSH
117394: LD_INT 34
117396: PUSH
117397: EMPTY
117398: LIST
117399: LIST
117400: LIST
117401: LIST
117402: LIST
117403: LIST
117404: LIST
117405: LIST
117406: LIST
117407: LIST
117408: LIST
117409: LIST
117410: LIST
117411: LIST
117412: LIST
117413: LIST
117414: LIST
117415: LIST
117416: LIST
117417: PUSH
117418: LD_INT 101
117420: PUSH
117421: LD_INT 102
117423: PUSH
117424: LD_INT 103
117426: PUSH
117427: LD_INT 106
117429: PUSH
117430: LD_INT 108
117432: PUSH
117433: LD_INT 112
117435: PUSH
117436: LD_INT 113
117438: PUSH
117439: LD_INT 114
117441: PUSH
117442: LD_INT 116
117444: PUSH
117445: LD_INT 117
117447: PUSH
117448: LD_INT 118
117450: PUSH
117451: EMPTY
117452: LIST
117453: LIST
117454: LIST
117455: LIST
117456: LIST
117457: LIST
117458: LIST
117459: LIST
117460: LIST
117461: LIST
117462: LIST
117463: PUSH
117464: EMPTY
117465: LIST
117466: LIST
117467: ST_TO_ADDR
117468: GO 118099
117470: LD_INT 17
117472: DOUBLE
117473: EQUAL
117474: IFTRUE 117478
117476: GO 117702
117478: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
117479: LD_ADDR_VAR 0 2
117483: PUSH
117484: LD_INT 1
117486: PUSH
117487: LD_INT 2
117489: PUSH
117490: LD_INT 3
117492: PUSH
117493: LD_INT 4
117495: PUSH
117496: LD_INT 5
117498: PUSH
117499: LD_INT 6
117501: PUSH
117502: LD_INT 7
117504: PUSH
117505: LD_INT 8
117507: PUSH
117508: LD_INT 9
117510: PUSH
117511: LD_INT 10
117513: PUSH
117514: LD_INT 11
117516: PUSH
117517: LD_INT 12
117519: PUSH
117520: LD_INT 13
117522: PUSH
117523: LD_INT 14
117525: PUSH
117526: LD_INT 15
117528: PUSH
117529: LD_INT 16
117531: PUSH
117532: LD_INT 17
117534: PUSH
117535: LD_INT 18
117537: PUSH
117538: LD_INT 19
117540: PUSH
117541: LD_INT 20
117543: PUSH
117544: LD_INT 21
117546: PUSH
117547: LD_INT 22
117549: PUSH
117550: LD_INT 23
117552: PUSH
117553: LD_INT 24
117555: PUSH
117556: LD_INT 25
117558: PUSH
117559: LD_INT 26
117561: PUSH
117562: LD_INT 27
117564: PUSH
117565: LD_INT 28
117567: PUSH
117568: LD_INT 29
117570: PUSH
117571: LD_INT 30
117573: PUSH
117574: LD_INT 31
117576: PUSH
117577: LD_INT 32
117579: PUSH
117580: LD_INT 33
117582: PUSH
117583: LD_INT 34
117585: PUSH
117586: LD_INT 36
117588: PUSH
117589: EMPTY
117590: LIST
117591: LIST
117592: LIST
117593: LIST
117594: LIST
117595: LIST
117596: LIST
117597: LIST
117598: LIST
117599: LIST
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: LIST
117605: LIST
117606: LIST
117607: LIST
117608: LIST
117609: LIST
117610: LIST
117611: LIST
117612: LIST
117613: LIST
117614: LIST
117615: LIST
117616: LIST
117617: LIST
117618: LIST
117619: LIST
117620: LIST
117621: LIST
117622: LIST
117623: LIST
117624: LIST
117625: PUSH
117626: LD_INT 101
117628: PUSH
117629: LD_INT 102
117631: PUSH
117632: LD_INT 103
117634: PUSH
117635: LD_INT 104
117637: PUSH
117638: LD_INT 105
117640: PUSH
117641: LD_INT 106
117643: PUSH
117644: LD_INT 107
117646: PUSH
117647: LD_INT 108
117649: PUSH
117650: LD_INT 109
117652: PUSH
117653: LD_INT 110
117655: PUSH
117656: LD_INT 111
117658: PUSH
117659: LD_INT 112
117661: PUSH
117662: LD_INT 113
117664: PUSH
117665: LD_INT 114
117667: PUSH
117668: LD_INT 116
117670: PUSH
117671: LD_INT 117
117673: PUSH
117674: LD_INT 118
117676: PUSH
117677: EMPTY
117678: LIST
117679: LIST
117680: LIST
117681: LIST
117682: LIST
117683: LIST
117684: LIST
117685: LIST
117686: LIST
117687: LIST
117688: LIST
117689: LIST
117690: LIST
117691: LIST
117692: LIST
117693: LIST
117694: LIST
117695: PUSH
117696: EMPTY
117697: LIST
117698: LIST
117699: ST_TO_ADDR
117700: GO 118099
117702: LD_INT 18
117704: DOUBLE
117705: EQUAL
117706: IFTRUE 117710
117708: GO 117858
117710: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117711: LD_ADDR_VAR 0 2
117715: PUSH
117716: LD_INT 2
117718: PUSH
117719: LD_INT 4
117721: PUSH
117722: LD_INT 5
117724: PUSH
117725: LD_INT 7
117727: PUSH
117728: LD_INT 11
117730: PUSH
117731: LD_INT 12
117733: PUSH
117734: LD_INT 15
117736: PUSH
117737: LD_INT 16
117739: PUSH
117740: LD_INT 20
117742: PUSH
117743: LD_INT 21
117745: PUSH
117746: LD_INT 22
117748: PUSH
117749: LD_INT 23
117751: PUSH
117752: LD_INT 25
117754: PUSH
117755: LD_INT 26
117757: PUSH
117758: LD_INT 30
117760: PUSH
117761: LD_INT 31
117763: PUSH
117764: LD_INT 32
117766: PUSH
117767: LD_INT 33
117769: PUSH
117770: LD_INT 34
117772: PUSH
117773: LD_INT 35
117775: PUSH
117776: LD_INT 36
117778: PUSH
117779: EMPTY
117780: LIST
117781: LIST
117782: LIST
117783: LIST
117784: LIST
117785: LIST
117786: LIST
117787: LIST
117788: LIST
117789: LIST
117790: LIST
117791: LIST
117792: LIST
117793: LIST
117794: LIST
117795: LIST
117796: LIST
117797: LIST
117798: LIST
117799: LIST
117800: LIST
117801: PUSH
117802: LD_INT 101
117804: PUSH
117805: LD_INT 102
117807: PUSH
117808: LD_INT 103
117810: PUSH
117811: LD_INT 106
117813: PUSH
117814: LD_INT 108
117816: PUSH
117817: LD_INT 112
117819: PUSH
117820: LD_INT 113
117822: PUSH
117823: LD_INT 114
117825: PUSH
117826: LD_INT 115
117828: PUSH
117829: LD_INT 116
117831: PUSH
117832: LD_INT 117
117834: PUSH
117835: LD_INT 118
117837: PUSH
117838: EMPTY
117839: LIST
117840: LIST
117841: LIST
117842: LIST
117843: LIST
117844: LIST
117845: LIST
117846: LIST
117847: LIST
117848: LIST
117849: LIST
117850: LIST
117851: PUSH
117852: EMPTY
117853: LIST
117854: LIST
117855: ST_TO_ADDR
117856: GO 118099
117858: LD_INT 19
117860: DOUBLE
117861: EQUAL
117862: IFTRUE 117866
117864: GO 118098
117866: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117867: LD_ADDR_VAR 0 2
117871: PUSH
117872: LD_INT 1
117874: PUSH
117875: LD_INT 2
117877: PUSH
117878: LD_INT 3
117880: PUSH
117881: LD_INT 4
117883: PUSH
117884: LD_INT 5
117886: PUSH
117887: LD_INT 6
117889: PUSH
117890: LD_INT 7
117892: PUSH
117893: LD_INT 8
117895: PUSH
117896: LD_INT 9
117898: PUSH
117899: LD_INT 10
117901: PUSH
117902: LD_INT 11
117904: PUSH
117905: LD_INT 12
117907: PUSH
117908: LD_INT 13
117910: PUSH
117911: LD_INT 14
117913: PUSH
117914: LD_INT 15
117916: PUSH
117917: LD_INT 16
117919: PUSH
117920: LD_INT 17
117922: PUSH
117923: LD_INT 18
117925: PUSH
117926: LD_INT 19
117928: PUSH
117929: LD_INT 20
117931: PUSH
117932: LD_INT 21
117934: PUSH
117935: LD_INT 22
117937: PUSH
117938: LD_INT 23
117940: PUSH
117941: LD_INT 24
117943: PUSH
117944: LD_INT 25
117946: PUSH
117947: LD_INT 26
117949: PUSH
117950: LD_INT 27
117952: PUSH
117953: LD_INT 28
117955: PUSH
117956: LD_INT 29
117958: PUSH
117959: LD_INT 30
117961: PUSH
117962: LD_INT 31
117964: PUSH
117965: LD_INT 32
117967: PUSH
117968: LD_INT 33
117970: PUSH
117971: LD_INT 34
117973: PUSH
117974: LD_INT 35
117976: PUSH
117977: LD_INT 36
117979: PUSH
117980: EMPTY
117981: LIST
117982: LIST
117983: LIST
117984: LIST
117985: LIST
117986: LIST
117987: LIST
117988: LIST
117989: LIST
117990: LIST
117991: LIST
117992: LIST
117993: LIST
117994: LIST
117995: LIST
117996: LIST
117997: LIST
117998: LIST
117999: LIST
118000: LIST
118001: LIST
118002: LIST
118003: LIST
118004: LIST
118005: LIST
118006: LIST
118007: LIST
118008: LIST
118009: LIST
118010: LIST
118011: LIST
118012: LIST
118013: LIST
118014: LIST
118015: LIST
118016: LIST
118017: PUSH
118018: LD_INT 101
118020: PUSH
118021: LD_INT 102
118023: PUSH
118024: LD_INT 103
118026: PUSH
118027: LD_INT 104
118029: PUSH
118030: LD_INT 105
118032: PUSH
118033: LD_INT 106
118035: PUSH
118036: LD_INT 107
118038: PUSH
118039: LD_INT 108
118041: PUSH
118042: LD_INT 109
118044: PUSH
118045: LD_INT 110
118047: PUSH
118048: LD_INT 111
118050: PUSH
118051: LD_INT 112
118053: PUSH
118054: LD_INT 113
118056: PUSH
118057: LD_INT 114
118059: PUSH
118060: LD_INT 115
118062: PUSH
118063: LD_INT 116
118065: PUSH
118066: LD_INT 117
118068: PUSH
118069: LD_INT 118
118071: PUSH
118072: EMPTY
118073: LIST
118074: LIST
118075: LIST
118076: LIST
118077: LIST
118078: LIST
118079: LIST
118080: LIST
118081: LIST
118082: LIST
118083: LIST
118084: LIST
118085: LIST
118086: LIST
118087: LIST
118088: LIST
118089: LIST
118090: LIST
118091: PUSH
118092: EMPTY
118093: LIST
118094: LIST
118095: ST_TO_ADDR
118096: GO 118099
118098: POP
// end else
118099: GO 118330
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
118101: LD_ADDR_VAR 0 2
118105: PUSH
118106: LD_INT 1
118108: PUSH
118109: LD_INT 2
118111: PUSH
118112: LD_INT 3
118114: PUSH
118115: LD_INT 4
118117: PUSH
118118: LD_INT 5
118120: PUSH
118121: LD_INT 6
118123: PUSH
118124: LD_INT 7
118126: PUSH
118127: LD_INT 8
118129: PUSH
118130: LD_INT 9
118132: PUSH
118133: LD_INT 10
118135: PUSH
118136: LD_INT 11
118138: PUSH
118139: LD_INT 12
118141: PUSH
118142: LD_INT 13
118144: PUSH
118145: LD_INT 14
118147: PUSH
118148: LD_INT 15
118150: PUSH
118151: LD_INT 16
118153: PUSH
118154: LD_INT 17
118156: PUSH
118157: LD_INT 18
118159: PUSH
118160: LD_INT 19
118162: PUSH
118163: LD_INT 20
118165: PUSH
118166: LD_INT 21
118168: PUSH
118169: LD_INT 22
118171: PUSH
118172: LD_INT 23
118174: PUSH
118175: LD_INT 24
118177: PUSH
118178: LD_INT 25
118180: PUSH
118181: LD_INT 26
118183: PUSH
118184: LD_INT 27
118186: PUSH
118187: LD_INT 28
118189: PUSH
118190: LD_INT 29
118192: PUSH
118193: LD_INT 30
118195: PUSH
118196: LD_INT 31
118198: PUSH
118199: LD_INT 32
118201: PUSH
118202: LD_INT 33
118204: PUSH
118205: LD_INT 34
118207: PUSH
118208: LD_INT 35
118210: PUSH
118211: LD_INT 36
118213: PUSH
118214: EMPTY
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: LIST
118221: LIST
118222: LIST
118223: LIST
118224: LIST
118225: LIST
118226: LIST
118227: LIST
118228: LIST
118229: LIST
118230: LIST
118231: LIST
118232: LIST
118233: LIST
118234: LIST
118235: LIST
118236: LIST
118237: LIST
118238: LIST
118239: LIST
118240: LIST
118241: LIST
118242: LIST
118243: LIST
118244: LIST
118245: LIST
118246: LIST
118247: LIST
118248: LIST
118249: LIST
118250: LIST
118251: PUSH
118252: LD_INT 101
118254: PUSH
118255: LD_INT 102
118257: PUSH
118258: LD_INT 103
118260: PUSH
118261: LD_INT 104
118263: PUSH
118264: LD_INT 105
118266: PUSH
118267: LD_INT 106
118269: PUSH
118270: LD_INT 107
118272: PUSH
118273: LD_INT 108
118275: PUSH
118276: LD_INT 109
118278: PUSH
118279: LD_INT 110
118281: PUSH
118282: LD_INT 111
118284: PUSH
118285: LD_INT 112
118287: PUSH
118288: LD_INT 113
118290: PUSH
118291: LD_INT 114
118293: PUSH
118294: LD_INT 115
118296: PUSH
118297: LD_INT 116
118299: PUSH
118300: LD_INT 117
118302: PUSH
118303: LD_INT 118
118305: PUSH
118306: EMPTY
118307: LIST
118308: LIST
118309: LIST
118310: LIST
118311: LIST
118312: LIST
118313: LIST
118314: LIST
118315: LIST
118316: LIST
118317: LIST
118318: LIST
118319: LIST
118320: LIST
118321: LIST
118322: LIST
118323: LIST
118324: LIST
118325: PUSH
118326: EMPTY
118327: LIST
118328: LIST
118329: ST_TO_ADDR
// if result then
118330: LD_VAR 0 2
118334: IFFALSE 119120
// begin normal :=  ;
118336: LD_ADDR_VAR 0 5
118340: PUSH
118341: LD_STRING 
118343: ST_TO_ADDR
// hardcore :=  ;
118344: LD_ADDR_VAR 0 6
118348: PUSH
118349: LD_STRING 
118351: ST_TO_ADDR
// active :=  ;
118352: LD_ADDR_VAR 0 7
118356: PUSH
118357: LD_STRING 
118359: ST_TO_ADDR
// for i = 1 to normalCounter do
118360: LD_ADDR_VAR 0 8
118364: PUSH
118365: DOUBLE
118366: LD_INT 1
118368: DEC
118369: ST_TO_ADDR
118370: LD_EXP 149
118374: PUSH
118375: FOR_TO
118376: IFFALSE 118477
// begin tmp := 0 ;
118378: LD_ADDR_VAR 0 3
118382: PUSH
118383: LD_STRING 0
118385: ST_TO_ADDR
// if result [ 1 ] then
118386: LD_VAR 0 2
118390: PUSH
118391: LD_INT 1
118393: ARRAY
118394: IFFALSE 118459
// if result [ 1 ] [ 1 ] = i then
118396: LD_VAR 0 2
118400: PUSH
118401: LD_INT 1
118403: ARRAY
118404: PUSH
118405: LD_INT 1
118407: ARRAY
118408: PUSH
118409: LD_VAR 0 8
118413: EQUAL
118414: IFFALSE 118459
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
118416: LD_ADDR_VAR 0 2
118420: PUSH
118421: LD_VAR 0 2
118425: PPUSH
118426: LD_INT 1
118428: PPUSH
118429: LD_VAR 0 2
118433: PUSH
118434: LD_INT 1
118436: ARRAY
118437: PPUSH
118438: LD_INT 1
118440: PPUSH
118441: CALL_OW 3
118445: PPUSH
118446: CALL_OW 1
118450: ST_TO_ADDR
// tmp := 1 ;
118451: LD_ADDR_VAR 0 3
118455: PUSH
118456: LD_STRING 1
118458: ST_TO_ADDR
// end ; normal := normal & tmp ;
118459: LD_ADDR_VAR 0 5
118463: PUSH
118464: LD_VAR 0 5
118468: PUSH
118469: LD_VAR 0 3
118473: STR
118474: ST_TO_ADDR
// end ;
118475: GO 118375
118477: POP
118478: POP
// for i = 1 to hardcoreCounter do
118479: LD_ADDR_VAR 0 8
118483: PUSH
118484: DOUBLE
118485: LD_INT 1
118487: DEC
118488: ST_TO_ADDR
118489: LD_EXP 150
118493: PUSH
118494: FOR_TO
118495: IFFALSE 118600
// begin tmp := 0 ;
118497: LD_ADDR_VAR 0 3
118501: PUSH
118502: LD_STRING 0
118504: ST_TO_ADDR
// if result [ 2 ] then
118505: LD_VAR 0 2
118509: PUSH
118510: LD_INT 2
118512: ARRAY
118513: IFFALSE 118582
// if result [ 2 ] [ 1 ] = 100 + i then
118515: LD_VAR 0 2
118519: PUSH
118520: LD_INT 2
118522: ARRAY
118523: PUSH
118524: LD_INT 1
118526: ARRAY
118527: PUSH
118528: LD_INT 100
118530: PUSH
118531: LD_VAR 0 8
118535: PLUS
118536: EQUAL
118537: IFFALSE 118582
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
118539: LD_ADDR_VAR 0 2
118543: PUSH
118544: LD_VAR 0 2
118548: PPUSH
118549: LD_INT 2
118551: PPUSH
118552: LD_VAR 0 2
118556: PUSH
118557: LD_INT 2
118559: ARRAY
118560: PPUSH
118561: LD_INT 1
118563: PPUSH
118564: CALL_OW 3
118568: PPUSH
118569: CALL_OW 1
118573: ST_TO_ADDR
// tmp := 1 ;
118574: LD_ADDR_VAR 0 3
118578: PUSH
118579: LD_STRING 1
118581: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118582: LD_ADDR_VAR 0 6
118586: PUSH
118587: LD_VAR 0 6
118591: PUSH
118592: LD_VAR 0 3
118596: STR
118597: ST_TO_ADDR
// end ;
118598: GO 118494
118600: POP
118601: POP
// if isGameLoad then
118602: LD_VAR 0 1
118606: IFFALSE 119081
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118608: LD_ADDR_VAR 0 4
118612: PUSH
118613: LD_EXP 153
118617: PUSH
118618: LD_EXP 152
118622: PUSH
118623: LD_EXP 154
118627: PUSH
118628: LD_EXP 151
118632: PUSH
118633: LD_EXP 155
118637: PUSH
118638: LD_EXP 156
118642: PUSH
118643: LD_EXP 157
118647: PUSH
118648: LD_EXP 158
118652: PUSH
118653: LD_EXP 159
118657: PUSH
118658: LD_EXP 160
118662: PUSH
118663: LD_EXP 161
118667: PUSH
118668: LD_EXP 162
118672: PUSH
118673: LD_EXP 163
118677: PUSH
118678: LD_EXP 164
118682: PUSH
118683: LD_EXP 172
118687: PUSH
118688: LD_EXP 173
118692: PUSH
118693: LD_EXP 174
118697: PUSH
118698: LD_EXP 175
118702: PUSH
118703: LD_EXP 177
118707: PUSH
118708: LD_EXP 178
118712: PUSH
118713: LD_EXP 179
118717: PUSH
118718: LD_EXP 182
118722: PUSH
118723: LD_EXP 184
118727: PUSH
118728: LD_EXP 185
118732: PUSH
118733: LD_EXP 186
118737: PUSH
118738: LD_EXP 188
118742: PUSH
118743: LD_EXP 189
118747: PUSH
118748: LD_EXP 192
118752: PUSH
118753: LD_EXP 193
118757: PUSH
118758: LD_EXP 194
118762: PUSH
118763: LD_EXP 195
118767: PUSH
118768: LD_EXP 196
118772: PUSH
118773: LD_EXP 197
118777: PUSH
118778: LD_EXP 198
118782: PUSH
118783: LD_EXP 199
118787: PUSH
118788: LD_EXP 200
118792: PUSH
118793: LD_EXP 165
118797: PUSH
118798: LD_EXP 166
118802: PUSH
118803: LD_EXP 169
118807: PUSH
118808: LD_EXP 170
118812: PUSH
118813: LD_EXP 171
118817: PUSH
118818: LD_EXP 167
118822: PUSH
118823: LD_EXP 168
118827: PUSH
118828: LD_EXP 176
118832: PUSH
118833: LD_EXP 180
118837: PUSH
118838: LD_EXP 181
118842: PUSH
118843: LD_EXP 183
118847: PUSH
118848: LD_EXP 187
118852: PUSH
118853: LD_EXP 190
118857: PUSH
118858: LD_EXP 191
118862: PUSH
118863: LD_EXP 201
118867: PUSH
118868: LD_EXP 202
118872: PUSH
118873: LD_EXP 203
118877: PUSH
118878: LD_EXP 204
118882: PUSH
118883: EMPTY
118884: LIST
118885: LIST
118886: LIST
118887: LIST
118888: LIST
118889: LIST
118890: LIST
118891: LIST
118892: LIST
118893: LIST
118894: LIST
118895: LIST
118896: LIST
118897: LIST
118898: LIST
118899: LIST
118900: LIST
118901: LIST
118902: LIST
118903: LIST
118904: LIST
118905: LIST
118906: LIST
118907: LIST
118908: LIST
118909: LIST
118910: LIST
118911: LIST
118912: LIST
118913: LIST
118914: LIST
118915: LIST
118916: LIST
118917: LIST
118918: LIST
118919: LIST
118920: LIST
118921: LIST
118922: LIST
118923: LIST
118924: LIST
118925: LIST
118926: LIST
118927: LIST
118928: LIST
118929: LIST
118930: LIST
118931: LIST
118932: LIST
118933: LIST
118934: LIST
118935: LIST
118936: LIST
118937: LIST
118938: ST_TO_ADDR
// tmp :=  ;
118939: LD_ADDR_VAR 0 3
118943: PUSH
118944: LD_STRING 
118946: ST_TO_ADDR
// for i = 1 to normalCounter do
118947: LD_ADDR_VAR 0 8
118951: PUSH
118952: DOUBLE
118953: LD_INT 1
118955: DEC
118956: ST_TO_ADDR
118957: LD_EXP 149
118961: PUSH
118962: FOR_TO
118963: IFFALSE 118999
// begin if flags [ i ] then
118965: LD_VAR 0 4
118969: PUSH
118970: LD_VAR 0 8
118974: ARRAY
118975: IFFALSE 118997
// tmp := tmp & i & ; ;
118977: LD_ADDR_VAR 0 3
118981: PUSH
118982: LD_VAR 0 3
118986: PUSH
118987: LD_VAR 0 8
118991: STR
118992: PUSH
118993: LD_STRING ;
118995: STR
118996: ST_TO_ADDR
// end ;
118997: GO 118962
118999: POP
119000: POP
// for i = 1 to hardcoreCounter do
119001: LD_ADDR_VAR 0 8
119005: PUSH
119006: DOUBLE
119007: LD_INT 1
119009: DEC
119010: ST_TO_ADDR
119011: LD_EXP 150
119015: PUSH
119016: FOR_TO
119017: IFFALSE 119063
// begin if flags [ normalCounter + i ] then
119019: LD_VAR 0 4
119023: PUSH
119024: LD_EXP 149
119028: PUSH
119029: LD_VAR 0 8
119033: PLUS
119034: ARRAY
119035: IFFALSE 119061
// tmp := tmp & ( 100 + i ) & ; ;
119037: LD_ADDR_VAR 0 3
119041: PUSH
119042: LD_VAR 0 3
119046: PUSH
119047: LD_INT 100
119049: PUSH
119050: LD_VAR 0 8
119054: PLUS
119055: STR
119056: PUSH
119057: LD_STRING ;
119059: STR
119060: ST_TO_ADDR
// end ;
119061: GO 119016
119063: POP
119064: POP
// if tmp then
119065: LD_VAR 0 3
119069: IFFALSE 119081
// active := tmp ;
119071: LD_ADDR_VAR 0 7
119075: PUSH
119076: LD_VAR 0 3
119080: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
119081: LD_STRING getStreamItemsFromMission("
119083: PUSH
119084: LD_VAR 0 5
119088: STR
119089: PUSH
119090: LD_STRING ","
119092: STR
119093: PUSH
119094: LD_VAR 0 6
119098: STR
119099: PUSH
119100: LD_STRING ","
119102: STR
119103: PUSH
119104: LD_VAR 0 7
119108: STR
119109: PUSH
119110: LD_STRING ")
119112: STR
119113: PPUSH
119114: CALL_OW 559
// end else
119118: GO 119127
// ToLua ( getStreamItemsFromMission("","","") ) ;
119120: LD_STRING getStreamItemsFromMission("","","")
119122: PPUSH
119123: CALL_OW 559
// end ;
119127: LD_VAR 0 2
119131: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
119132: LD_EXP 148
119136: PUSH
119137: LD_EXP 153
119141: AND
119142: IFFALSE 119266
119144: GO 119146
119146: DISABLE
119147: LD_INT 0
119149: PPUSH
119150: PPUSH
// begin enable ;
119151: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
119152: LD_ADDR_VAR 0 2
119156: PUSH
119157: LD_INT 22
119159: PUSH
119160: LD_OWVAR 2
119164: PUSH
119165: EMPTY
119166: LIST
119167: LIST
119168: PUSH
119169: LD_INT 2
119171: PUSH
119172: LD_INT 34
119174: PUSH
119175: LD_INT 7
119177: PUSH
119178: EMPTY
119179: LIST
119180: LIST
119181: PUSH
119182: LD_INT 34
119184: PUSH
119185: LD_INT 45
119187: PUSH
119188: EMPTY
119189: LIST
119190: LIST
119191: PUSH
119192: LD_INT 34
119194: PUSH
119195: LD_INT 28
119197: PUSH
119198: EMPTY
119199: LIST
119200: LIST
119201: PUSH
119202: LD_INT 34
119204: PUSH
119205: LD_INT 47
119207: PUSH
119208: EMPTY
119209: LIST
119210: LIST
119211: PUSH
119212: EMPTY
119213: LIST
119214: LIST
119215: LIST
119216: LIST
119217: LIST
119218: PUSH
119219: EMPTY
119220: LIST
119221: LIST
119222: PPUSH
119223: CALL_OW 69
119227: ST_TO_ADDR
// if not tmp then
119228: LD_VAR 0 2
119232: NOT
119233: IFFALSE 119237
// exit ;
119235: GO 119266
// for i in tmp do
119237: LD_ADDR_VAR 0 1
119241: PUSH
119242: LD_VAR 0 2
119246: PUSH
119247: FOR_IN
119248: IFFALSE 119264
// begin SetLives ( i , 0 ) ;
119250: LD_VAR 0 1
119254: PPUSH
119255: LD_INT 0
119257: PPUSH
119258: CALL_OW 234
// end ;
119262: GO 119247
119264: POP
119265: POP
// end ;
119266: PPOPN 2
119268: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
119269: LD_EXP 148
119273: PUSH
119274: LD_EXP 154
119278: AND
119279: IFFALSE 119363
119281: GO 119283
119283: DISABLE
119284: LD_INT 0
119286: PPUSH
119287: PPUSH
// begin enable ;
119288: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
119289: LD_ADDR_VAR 0 2
119293: PUSH
119294: LD_INT 22
119296: PUSH
119297: LD_OWVAR 2
119301: PUSH
119302: EMPTY
119303: LIST
119304: LIST
119305: PUSH
119306: LD_INT 32
119308: PUSH
119309: LD_INT 3
119311: PUSH
119312: EMPTY
119313: LIST
119314: LIST
119315: PUSH
119316: EMPTY
119317: LIST
119318: LIST
119319: PPUSH
119320: CALL_OW 69
119324: ST_TO_ADDR
// if not tmp then
119325: LD_VAR 0 2
119329: NOT
119330: IFFALSE 119334
// exit ;
119332: GO 119363
// for i in tmp do
119334: LD_ADDR_VAR 0 1
119338: PUSH
119339: LD_VAR 0 2
119343: PUSH
119344: FOR_IN
119345: IFFALSE 119361
// begin SetLives ( i , 0 ) ;
119347: LD_VAR 0 1
119351: PPUSH
119352: LD_INT 0
119354: PPUSH
119355: CALL_OW 234
// end ;
119359: GO 119344
119361: POP
119362: POP
// end ;
119363: PPOPN 2
119365: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
119366: LD_EXP 148
119370: PUSH
119371: LD_EXP 151
119375: AND
119376: IFFALSE 119469
119378: GO 119380
119380: DISABLE
119381: LD_INT 0
119383: PPUSH
// begin enable ;
119384: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
119385: LD_ADDR_VAR 0 1
119389: PUSH
119390: LD_INT 22
119392: PUSH
119393: LD_OWVAR 2
119397: PUSH
119398: EMPTY
119399: LIST
119400: LIST
119401: PUSH
119402: LD_INT 2
119404: PUSH
119405: LD_INT 25
119407: PUSH
119408: LD_INT 5
119410: PUSH
119411: EMPTY
119412: LIST
119413: LIST
119414: PUSH
119415: LD_INT 25
119417: PUSH
119418: LD_INT 9
119420: PUSH
119421: EMPTY
119422: LIST
119423: LIST
119424: PUSH
119425: LD_INT 25
119427: PUSH
119428: LD_INT 8
119430: PUSH
119431: EMPTY
119432: LIST
119433: LIST
119434: PUSH
119435: EMPTY
119436: LIST
119437: LIST
119438: LIST
119439: LIST
119440: PUSH
119441: EMPTY
119442: LIST
119443: LIST
119444: PPUSH
119445: CALL_OW 69
119449: PUSH
119450: FOR_IN
119451: IFFALSE 119467
// begin SetClass ( i , 1 ) ;
119453: LD_VAR 0 1
119457: PPUSH
119458: LD_INT 1
119460: PPUSH
119461: CALL_OW 336
// end ;
119465: GO 119450
119467: POP
119468: POP
// end ;
119469: PPOPN 1
119471: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
119472: LD_EXP 148
119476: PUSH
119477: LD_EXP 152
119481: AND
119482: PUSH
119483: LD_OWVAR 65
119487: PUSH
119488: LD_INT 7
119490: LESS
119491: AND
119492: IFFALSE 119506
119494: GO 119496
119496: DISABLE
// begin enable ;
119497: ENABLE
// game_speed := 7 ;
119498: LD_ADDR_OWVAR 65
119502: PUSH
119503: LD_INT 7
119505: ST_TO_ADDR
// end ;
119506: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
119507: LD_EXP 148
119511: PUSH
119512: LD_EXP 155
119516: AND
119517: IFFALSE 119719
119519: GO 119521
119521: DISABLE
119522: LD_INT 0
119524: PPUSH
119525: PPUSH
119526: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119527: LD_ADDR_VAR 0 3
119531: PUSH
119532: LD_INT 81
119534: PUSH
119535: LD_OWVAR 2
119539: PUSH
119540: EMPTY
119541: LIST
119542: LIST
119543: PUSH
119544: LD_INT 21
119546: PUSH
119547: LD_INT 1
119549: PUSH
119550: EMPTY
119551: LIST
119552: LIST
119553: PUSH
119554: EMPTY
119555: LIST
119556: LIST
119557: PPUSH
119558: CALL_OW 69
119562: ST_TO_ADDR
// if not tmp then
119563: LD_VAR 0 3
119567: NOT
119568: IFFALSE 119572
// exit ;
119570: GO 119719
// if tmp > 5 then
119572: LD_VAR 0 3
119576: PUSH
119577: LD_INT 5
119579: GREATER
119580: IFFALSE 119592
// k := 5 else
119582: LD_ADDR_VAR 0 2
119586: PUSH
119587: LD_INT 5
119589: ST_TO_ADDR
119590: GO 119602
// k := tmp ;
119592: LD_ADDR_VAR 0 2
119596: PUSH
119597: LD_VAR 0 3
119601: ST_TO_ADDR
// for i := 1 to k do
119602: LD_ADDR_VAR 0 1
119606: PUSH
119607: DOUBLE
119608: LD_INT 1
119610: DEC
119611: ST_TO_ADDR
119612: LD_VAR 0 2
119616: PUSH
119617: FOR_TO
119618: IFFALSE 119717
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119620: LD_VAR 0 3
119624: PUSH
119625: LD_VAR 0 1
119629: ARRAY
119630: PPUSH
119631: LD_VAR 0 1
119635: PUSH
119636: LD_INT 4
119638: MOD
119639: PUSH
119640: LD_INT 1
119642: PLUS
119643: PPUSH
119644: CALL_OW 259
119648: PUSH
119649: LD_INT 10
119651: LESS
119652: IFFALSE 119715
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119654: LD_VAR 0 3
119658: PUSH
119659: LD_VAR 0 1
119663: ARRAY
119664: PPUSH
119665: LD_VAR 0 1
119669: PUSH
119670: LD_INT 4
119672: MOD
119673: PUSH
119674: LD_INT 1
119676: PLUS
119677: PPUSH
119678: LD_VAR 0 3
119682: PUSH
119683: LD_VAR 0 1
119687: ARRAY
119688: PPUSH
119689: LD_VAR 0 1
119693: PUSH
119694: LD_INT 4
119696: MOD
119697: PUSH
119698: LD_INT 1
119700: PLUS
119701: PPUSH
119702: CALL_OW 259
119706: PUSH
119707: LD_INT 1
119709: PLUS
119710: PPUSH
119711: CALL_OW 237
119715: GO 119617
119717: POP
119718: POP
// end ;
119719: PPOPN 3
119721: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119722: LD_EXP 148
119726: PUSH
119727: LD_EXP 156
119731: AND
119732: IFFALSE 119752
119734: GO 119736
119736: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119737: LD_INT 4
119739: PPUSH
119740: LD_OWVAR 2
119744: PPUSH
119745: LD_INT 0
119747: PPUSH
119748: CALL_OW 324
119752: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119753: LD_EXP 148
119757: PUSH
119758: LD_EXP 185
119762: AND
119763: IFFALSE 119783
119765: GO 119767
119767: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119768: LD_INT 19
119770: PPUSH
119771: LD_OWVAR 2
119775: PPUSH
119776: LD_INT 0
119778: PPUSH
119779: CALL_OW 324
119783: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119784: LD_EXP 148
119788: PUSH
119789: LD_EXP 157
119793: AND
119794: IFFALSE 119896
119796: GO 119798
119798: DISABLE
119799: LD_INT 0
119801: PPUSH
119802: PPUSH
// begin enable ;
119803: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119804: LD_ADDR_VAR 0 2
119808: PUSH
119809: LD_INT 22
119811: PUSH
119812: LD_OWVAR 2
119816: PUSH
119817: EMPTY
119818: LIST
119819: LIST
119820: PUSH
119821: LD_INT 2
119823: PUSH
119824: LD_INT 34
119826: PUSH
119827: LD_INT 11
119829: PUSH
119830: EMPTY
119831: LIST
119832: LIST
119833: PUSH
119834: LD_INT 34
119836: PUSH
119837: LD_INT 30
119839: PUSH
119840: EMPTY
119841: LIST
119842: LIST
119843: PUSH
119844: EMPTY
119845: LIST
119846: LIST
119847: LIST
119848: PUSH
119849: EMPTY
119850: LIST
119851: LIST
119852: PPUSH
119853: CALL_OW 69
119857: ST_TO_ADDR
// if not tmp then
119858: LD_VAR 0 2
119862: NOT
119863: IFFALSE 119867
// exit ;
119865: GO 119896
// for i in tmp do
119867: LD_ADDR_VAR 0 1
119871: PUSH
119872: LD_VAR 0 2
119876: PUSH
119877: FOR_IN
119878: IFFALSE 119894
// begin SetLives ( i , 0 ) ;
119880: LD_VAR 0 1
119884: PPUSH
119885: LD_INT 0
119887: PPUSH
119888: CALL_OW 234
// end ;
119892: GO 119877
119894: POP
119895: POP
// end ;
119896: PPOPN 2
119898: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119899: LD_EXP 148
119903: PUSH
119904: LD_EXP 158
119908: AND
119909: IFFALSE 119929
119911: GO 119913
119913: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119914: LD_INT 32
119916: PPUSH
119917: LD_OWVAR 2
119921: PPUSH
119922: LD_INT 0
119924: PPUSH
119925: CALL_OW 324
119929: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119930: LD_EXP 148
119934: PUSH
119935: LD_EXP 159
119939: AND
119940: IFFALSE 120121
119942: GO 119944
119944: DISABLE
119945: LD_INT 0
119947: PPUSH
119948: PPUSH
119949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119950: LD_ADDR_VAR 0 2
119954: PUSH
119955: LD_INT 22
119957: PUSH
119958: LD_OWVAR 2
119962: PUSH
119963: EMPTY
119964: LIST
119965: LIST
119966: PUSH
119967: LD_INT 33
119969: PUSH
119970: LD_INT 3
119972: PUSH
119973: EMPTY
119974: LIST
119975: LIST
119976: PUSH
119977: EMPTY
119978: LIST
119979: LIST
119980: PPUSH
119981: CALL_OW 69
119985: ST_TO_ADDR
// if not tmp then
119986: LD_VAR 0 2
119990: NOT
119991: IFFALSE 119995
// exit ;
119993: GO 120121
// side := 0 ;
119995: LD_ADDR_VAR 0 3
119999: PUSH
120000: LD_INT 0
120002: ST_TO_ADDR
// for i := 1 to 8 do
120003: LD_ADDR_VAR 0 1
120007: PUSH
120008: DOUBLE
120009: LD_INT 1
120011: DEC
120012: ST_TO_ADDR
120013: LD_INT 8
120015: PUSH
120016: FOR_TO
120017: IFFALSE 120065
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
120019: LD_OWVAR 2
120023: PUSH
120024: LD_VAR 0 1
120028: NONEQUAL
120029: PUSH
120030: LD_OWVAR 2
120034: PPUSH
120035: LD_VAR 0 1
120039: PPUSH
120040: CALL_OW 81
120044: PUSH
120045: LD_INT 2
120047: EQUAL
120048: AND
120049: IFFALSE 120063
// begin side := i ;
120051: LD_ADDR_VAR 0 3
120055: PUSH
120056: LD_VAR 0 1
120060: ST_TO_ADDR
// break ;
120061: GO 120065
// end ;
120063: GO 120016
120065: POP
120066: POP
// if not side then
120067: LD_VAR 0 3
120071: NOT
120072: IFFALSE 120076
// exit ;
120074: GO 120121
// for i := 1 to tmp do
120076: LD_ADDR_VAR 0 1
120080: PUSH
120081: DOUBLE
120082: LD_INT 1
120084: DEC
120085: ST_TO_ADDR
120086: LD_VAR 0 2
120090: PUSH
120091: FOR_TO
120092: IFFALSE 120119
// if Prob ( 60 ) then
120094: LD_INT 60
120096: PPUSH
120097: CALL_OW 13
120101: IFFALSE 120117
// SetSide ( i , side ) ;
120103: LD_VAR 0 1
120107: PPUSH
120108: LD_VAR 0 3
120112: PPUSH
120113: CALL_OW 235
120117: GO 120091
120119: POP
120120: POP
// end ;
120121: PPOPN 3
120123: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
120124: LD_EXP 148
120128: PUSH
120129: LD_EXP 161
120133: AND
120134: IFFALSE 120253
120136: GO 120138
120138: DISABLE
120139: LD_INT 0
120141: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
120142: LD_ADDR_VAR 0 1
120146: PUSH
120147: LD_INT 22
120149: PUSH
120150: LD_OWVAR 2
120154: PUSH
120155: EMPTY
120156: LIST
120157: LIST
120158: PUSH
120159: LD_INT 21
120161: PUSH
120162: LD_INT 1
120164: PUSH
120165: EMPTY
120166: LIST
120167: LIST
120168: PUSH
120169: LD_INT 3
120171: PUSH
120172: LD_INT 23
120174: PUSH
120175: LD_INT 0
120177: PUSH
120178: EMPTY
120179: LIST
120180: LIST
120181: PUSH
120182: EMPTY
120183: LIST
120184: LIST
120185: PUSH
120186: EMPTY
120187: LIST
120188: LIST
120189: LIST
120190: PPUSH
120191: CALL_OW 69
120195: PUSH
120196: FOR_IN
120197: IFFALSE 120251
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
120199: LD_VAR 0 1
120203: PPUSH
120204: CALL_OW 257
120208: PUSH
120209: LD_INT 1
120211: PUSH
120212: LD_INT 2
120214: PUSH
120215: LD_INT 3
120217: PUSH
120218: LD_INT 4
120220: PUSH
120221: EMPTY
120222: LIST
120223: LIST
120224: LIST
120225: LIST
120226: IN
120227: IFFALSE 120249
// SetClass ( un , rand ( 1 , 4 ) ) ;
120229: LD_VAR 0 1
120233: PPUSH
120234: LD_INT 1
120236: PPUSH
120237: LD_INT 4
120239: PPUSH
120240: CALL_OW 12
120244: PPUSH
120245: CALL_OW 336
120249: GO 120196
120251: POP
120252: POP
// end ;
120253: PPOPN 1
120255: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
120256: LD_EXP 148
120260: PUSH
120261: LD_EXP 160
120265: AND
120266: IFFALSE 120345
120268: GO 120270
120270: DISABLE
120271: LD_INT 0
120273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120274: LD_ADDR_VAR 0 1
120278: PUSH
120279: LD_INT 22
120281: PUSH
120282: LD_OWVAR 2
120286: PUSH
120287: EMPTY
120288: LIST
120289: LIST
120290: PUSH
120291: LD_INT 21
120293: PUSH
120294: LD_INT 3
120296: PUSH
120297: EMPTY
120298: LIST
120299: LIST
120300: PUSH
120301: EMPTY
120302: LIST
120303: LIST
120304: PPUSH
120305: CALL_OW 69
120309: ST_TO_ADDR
// if not tmp then
120310: LD_VAR 0 1
120314: NOT
120315: IFFALSE 120319
// exit ;
120317: GO 120345
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
120319: LD_VAR 0 1
120323: PUSH
120324: LD_INT 1
120326: PPUSH
120327: LD_VAR 0 1
120331: PPUSH
120332: CALL_OW 12
120336: ARRAY
120337: PPUSH
120338: LD_INT 100
120340: PPUSH
120341: CALL_OW 234
// end ;
120345: PPOPN 1
120347: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
120348: LD_EXP 148
120352: PUSH
120353: LD_EXP 162
120357: AND
120358: IFFALSE 120456
120360: GO 120362
120362: DISABLE
120363: LD_INT 0
120365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120366: LD_ADDR_VAR 0 1
120370: PUSH
120371: LD_INT 22
120373: PUSH
120374: LD_OWVAR 2
120378: PUSH
120379: EMPTY
120380: LIST
120381: LIST
120382: PUSH
120383: LD_INT 21
120385: PUSH
120386: LD_INT 1
120388: PUSH
120389: EMPTY
120390: LIST
120391: LIST
120392: PUSH
120393: EMPTY
120394: LIST
120395: LIST
120396: PPUSH
120397: CALL_OW 69
120401: ST_TO_ADDR
// if not tmp then
120402: LD_VAR 0 1
120406: NOT
120407: IFFALSE 120411
// exit ;
120409: GO 120456
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
120411: LD_VAR 0 1
120415: PUSH
120416: LD_INT 1
120418: PPUSH
120419: LD_VAR 0 1
120423: PPUSH
120424: CALL_OW 12
120428: ARRAY
120429: PPUSH
120430: LD_INT 1
120432: PPUSH
120433: LD_INT 4
120435: PPUSH
120436: CALL_OW 12
120440: PPUSH
120441: LD_INT 3000
120443: PPUSH
120444: LD_INT 9000
120446: PPUSH
120447: CALL_OW 12
120451: PPUSH
120452: CALL_OW 492
// end ;
120456: PPOPN 1
120458: END
// every 0 0$1 trigger StreamModeActive and sDepot do
120459: LD_EXP 148
120463: PUSH
120464: LD_EXP 163
120468: AND
120469: IFFALSE 120489
120471: GO 120473
120473: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
120474: LD_INT 1
120476: PPUSH
120477: LD_OWVAR 2
120481: PPUSH
120482: LD_INT 0
120484: PPUSH
120485: CALL_OW 324
120489: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
120490: LD_EXP 148
120494: PUSH
120495: LD_EXP 164
120499: AND
120500: IFFALSE 120583
120502: GO 120504
120504: DISABLE
120505: LD_INT 0
120507: PPUSH
120508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120509: LD_ADDR_VAR 0 2
120513: PUSH
120514: LD_INT 22
120516: PUSH
120517: LD_OWVAR 2
120521: PUSH
120522: EMPTY
120523: LIST
120524: LIST
120525: PUSH
120526: LD_INT 21
120528: PUSH
120529: LD_INT 3
120531: PUSH
120532: EMPTY
120533: LIST
120534: LIST
120535: PUSH
120536: EMPTY
120537: LIST
120538: LIST
120539: PPUSH
120540: CALL_OW 69
120544: ST_TO_ADDR
// if not tmp then
120545: LD_VAR 0 2
120549: NOT
120550: IFFALSE 120554
// exit ;
120552: GO 120583
// for i in tmp do
120554: LD_ADDR_VAR 0 1
120558: PUSH
120559: LD_VAR 0 2
120563: PUSH
120564: FOR_IN
120565: IFFALSE 120581
// SetBLevel ( i , 10 ) ;
120567: LD_VAR 0 1
120571: PPUSH
120572: LD_INT 10
120574: PPUSH
120575: CALL_OW 241
120579: GO 120564
120581: POP
120582: POP
// end ;
120583: PPOPN 2
120585: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120586: LD_EXP 148
120590: PUSH
120591: LD_EXP 165
120595: AND
120596: IFFALSE 120707
120598: GO 120600
120600: DISABLE
120601: LD_INT 0
120603: PPUSH
120604: PPUSH
120605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120606: LD_ADDR_VAR 0 3
120610: PUSH
120611: LD_INT 22
120613: PUSH
120614: LD_OWVAR 2
120618: PUSH
120619: EMPTY
120620: LIST
120621: LIST
120622: PUSH
120623: LD_INT 25
120625: PUSH
120626: LD_INT 1
120628: PUSH
120629: EMPTY
120630: LIST
120631: LIST
120632: PUSH
120633: EMPTY
120634: LIST
120635: LIST
120636: PPUSH
120637: CALL_OW 69
120641: ST_TO_ADDR
// if not tmp then
120642: LD_VAR 0 3
120646: NOT
120647: IFFALSE 120651
// exit ;
120649: GO 120707
// un := tmp [ rand ( 1 , tmp ) ] ;
120651: LD_ADDR_VAR 0 2
120655: PUSH
120656: LD_VAR 0 3
120660: PUSH
120661: LD_INT 1
120663: PPUSH
120664: LD_VAR 0 3
120668: PPUSH
120669: CALL_OW 12
120673: ARRAY
120674: ST_TO_ADDR
// if Crawls ( un ) then
120675: LD_VAR 0 2
120679: PPUSH
120680: CALL_OW 318
120684: IFFALSE 120695
// ComWalk ( un ) ;
120686: LD_VAR 0 2
120690: PPUSH
120691: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120695: LD_VAR 0 2
120699: PPUSH
120700: LD_INT 5
120702: PPUSH
120703: CALL_OW 336
// end ;
120707: PPOPN 3
120709: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120710: LD_EXP 148
120714: PUSH
120715: LD_EXP 166
120719: AND
120720: PUSH
120721: LD_OWVAR 67
120725: PUSH
120726: LD_INT 4
120728: LESS
120729: AND
120730: IFFALSE 120749
120732: GO 120734
120734: DISABLE
// begin Difficulty := Difficulty + 1 ;
120735: LD_ADDR_OWVAR 67
120739: PUSH
120740: LD_OWVAR 67
120744: PUSH
120745: LD_INT 1
120747: PLUS
120748: ST_TO_ADDR
// end ;
120749: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120750: LD_EXP 148
120754: PUSH
120755: LD_EXP 167
120759: AND
120760: IFFALSE 120863
120762: GO 120764
120764: DISABLE
120765: LD_INT 0
120767: PPUSH
// begin for i := 1 to 5 do
120768: LD_ADDR_VAR 0 1
120772: PUSH
120773: DOUBLE
120774: LD_INT 1
120776: DEC
120777: ST_TO_ADDR
120778: LD_INT 5
120780: PUSH
120781: FOR_TO
120782: IFFALSE 120861
// begin uc_nation := nation_nature ;
120784: LD_ADDR_OWVAR 21
120788: PUSH
120789: LD_INT 0
120791: ST_TO_ADDR
// uc_side := 0 ;
120792: LD_ADDR_OWVAR 20
120796: PUSH
120797: LD_INT 0
120799: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120800: LD_ADDR_OWVAR 29
120804: PUSH
120805: LD_INT 12
120807: PUSH
120808: LD_INT 12
120810: PUSH
120811: EMPTY
120812: LIST
120813: LIST
120814: ST_TO_ADDR
// hc_agressivity := 20 ;
120815: LD_ADDR_OWVAR 35
120819: PUSH
120820: LD_INT 20
120822: ST_TO_ADDR
// hc_class := class_tiger ;
120823: LD_ADDR_OWVAR 28
120827: PUSH
120828: LD_INT 14
120830: ST_TO_ADDR
// hc_gallery :=  ;
120831: LD_ADDR_OWVAR 33
120835: PUSH
120836: LD_STRING 
120838: ST_TO_ADDR
// hc_name :=  ;
120839: LD_ADDR_OWVAR 26
120843: PUSH
120844: LD_STRING 
120846: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120847: CALL_OW 44
120851: PPUSH
120852: LD_INT 0
120854: PPUSH
120855: CALL_OW 51
// end ;
120859: GO 120781
120861: POP
120862: POP
// end ;
120863: PPOPN 1
120865: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120866: LD_EXP 148
120870: PUSH
120871: LD_EXP 168
120875: AND
120876: IFFALSE 120885
120878: GO 120880
120880: DISABLE
// StreamSibBomb ;
120881: CALL 120886 0 0
120885: END
// export function StreamSibBomb ; var i , x , y ; begin
120886: LD_INT 0
120888: PPUSH
120889: PPUSH
120890: PPUSH
120891: PPUSH
// result := false ;
120892: LD_ADDR_VAR 0 1
120896: PUSH
120897: LD_INT 0
120899: ST_TO_ADDR
// for i := 1 to 16 do
120900: LD_ADDR_VAR 0 2
120904: PUSH
120905: DOUBLE
120906: LD_INT 1
120908: DEC
120909: ST_TO_ADDR
120910: LD_INT 16
120912: PUSH
120913: FOR_TO
120914: IFFALSE 121113
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120916: LD_ADDR_VAR 0 3
120920: PUSH
120921: LD_INT 10
120923: PUSH
120924: LD_INT 20
120926: PUSH
120927: LD_INT 30
120929: PUSH
120930: LD_INT 40
120932: PUSH
120933: LD_INT 50
120935: PUSH
120936: LD_INT 60
120938: PUSH
120939: LD_INT 70
120941: PUSH
120942: LD_INT 80
120944: PUSH
120945: LD_INT 90
120947: PUSH
120948: LD_INT 100
120950: PUSH
120951: LD_INT 110
120953: PUSH
120954: LD_INT 120
120956: PUSH
120957: LD_INT 130
120959: PUSH
120960: LD_INT 140
120962: PUSH
120963: LD_INT 150
120965: PUSH
120966: EMPTY
120967: LIST
120968: LIST
120969: LIST
120970: LIST
120971: LIST
120972: LIST
120973: LIST
120974: LIST
120975: LIST
120976: LIST
120977: LIST
120978: LIST
120979: LIST
120980: LIST
120981: LIST
120982: PUSH
120983: LD_INT 1
120985: PPUSH
120986: LD_INT 15
120988: PPUSH
120989: CALL_OW 12
120993: ARRAY
120994: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120995: LD_ADDR_VAR 0 4
120999: PUSH
121000: LD_INT 10
121002: PUSH
121003: LD_INT 20
121005: PUSH
121006: LD_INT 30
121008: PUSH
121009: LD_INT 40
121011: PUSH
121012: LD_INT 50
121014: PUSH
121015: LD_INT 60
121017: PUSH
121018: LD_INT 70
121020: PUSH
121021: LD_INT 80
121023: PUSH
121024: LD_INT 90
121026: PUSH
121027: LD_INT 100
121029: PUSH
121030: LD_INT 110
121032: PUSH
121033: LD_INT 120
121035: PUSH
121036: LD_INT 130
121038: PUSH
121039: LD_INT 140
121041: PUSH
121042: LD_INT 150
121044: PUSH
121045: EMPTY
121046: LIST
121047: LIST
121048: LIST
121049: LIST
121050: LIST
121051: LIST
121052: LIST
121053: LIST
121054: LIST
121055: LIST
121056: LIST
121057: LIST
121058: LIST
121059: LIST
121060: LIST
121061: PUSH
121062: LD_INT 1
121064: PPUSH
121065: LD_INT 15
121067: PPUSH
121068: CALL_OW 12
121072: ARRAY
121073: ST_TO_ADDR
// if ValidHex ( x , y ) then
121074: LD_VAR 0 3
121078: PPUSH
121079: LD_VAR 0 4
121083: PPUSH
121084: CALL_OW 488
121088: IFFALSE 121111
// begin result := [ x , y ] ;
121090: LD_ADDR_VAR 0 1
121094: PUSH
121095: LD_VAR 0 3
121099: PUSH
121100: LD_VAR 0 4
121104: PUSH
121105: EMPTY
121106: LIST
121107: LIST
121108: ST_TO_ADDR
// break ;
121109: GO 121113
// end ; end ;
121111: GO 120913
121113: POP
121114: POP
// if result then
121115: LD_VAR 0 1
121119: IFFALSE 121179
// begin ToLua ( playSibBomb() ) ;
121121: LD_STRING playSibBomb()
121123: PPUSH
121124: CALL_OW 559
// wait ( 0 0$14 ) ;
121128: LD_INT 490
121130: PPUSH
121131: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
121135: LD_VAR 0 1
121139: PUSH
121140: LD_INT 1
121142: ARRAY
121143: PPUSH
121144: LD_VAR 0 1
121148: PUSH
121149: LD_INT 2
121151: ARRAY
121152: PPUSH
121153: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
121157: LD_VAR 0 1
121161: PUSH
121162: LD_INT 1
121164: ARRAY
121165: PPUSH
121166: LD_VAR 0 1
121170: PUSH
121171: LD_INT 2
121173: ARRAY
121174: PPUSH
121175: CALL_OW 429
// end ; end ;
121179: LD_VAR 0 1
121183: RET
// every 0 0$1 trigger StreamModeActive and sReset do
121184: LD_EXP 148
121188: PUSH
121189: LD_EXP 170
121193: AND
121194: IFFALSE 121206
121196: GO 121198
121198: DISABLE
// YouLost (  ) ;
121199: LD_STRING 
121201: PPUSH
121202: CALL_OW 104
121206: END
// every 0 0$1 trigger StreamModeActive and sFog do
121207: LD_EXP 148
121211: PUSH
121212: LD_EXP 169
121216: AND
121217: IFFALSE 121231
121219: GO 121221
121221: DISABLE
// FogOff ( your_side ) ;
121222: LD_OWVAR 2
121226: PPUSH
121227: CALL_OW 344
121231: END
// every 0 0$1 trigger StreamModeActive and sSun do
121232: LD_EXP 148
121236: PUSH
121237: LD_EXP 171
121241: AND
121242: IFFALSE 121270
121244: GO 121246
121246: DISABLE
// begin solar_recharge_percent := 0 ;
121247: LD_ADDR_OWVAR 79
121251: PUSH
121252: LD_INT 0
121254: ST_TO_ADDR
// wait ( 5 5$00 ) ;
121255: LD_INT 10500
121257: PPUSH
121258: CALL_OW 67
// solar_recharge_percent := 100 ;
121262: LD_ADDR_OWVAR 79
121266: PUSH
121267: LD_INT 100
121269: ST_TO_ADDR
// end ;
121270: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
121271: LD_EXP 148
121275: PUSH
121276: LD_EXP 172
121280: AND
121281: IFFALSE 121520
121283: GO 121285
121285: DISABLE
121286: LD_INT 0
121288: PPUSH
121289: PPUSH
121290: PPUSH
// begin tmp := [ ] ;
121291: LD_ADDR_VAR 0 3
121295: PUSH
121296: EMPTY
121297: ST_TO_ADDR
// for i := 1 to 6 do
121298: LD_ADDR_VAR 0 1
121302: PUSH
121303: DOUBLE
121304: LD_INT 1
121306: DEC
121307: ST_TO_ADDR
121308: LD_INT 6
121310: PUSH
121311: FOR_TO
121312: IFFALSE 121417
// begin uc_nation := nation_nature ;
121314: LD_ADDR_OWVAR 21
121318: PUSH
121319: LD_INT 0
121321: ST_TO_ADDR
// uc_side := 0 ;
121322: LD_ADDR_OWVAR 20
121326: PUSH
121327: LD_INT 0
121329: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
121330: LD_ADDR_OWVAR 29
121334: PUSH
121335: LD_INT 12
121337: PUSH
121338: LD_INT 12
121340: PUSH
121341: EMPTY
121342: LIST
121343: LIST
121344: ST_TO_ADDR
// hc_agressivity := 20 ;
121345: LD_ADDR_OWVAR 35
121349: PUSH
121350: LD_INT 20
121352: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
121353: LD_ADDR_OWVAR 28
121357: PUSH
121358: LD_INT 17
121360: ST_TO_ADDR
// hc_gallery :=  ;
121361: LD_ADDR_OWVAR 33
121365: PUSH
121366: LD_STRING 
121368: ST_TO_ADDR
// hc_name :=  ;
121369: LD_ADDR_OWVAR 26
121373: PUSH
121374: LD_STRING 
121376: ST_TO_ADDR
// un := CreateHuman ;
121377: LD_ADDR_VAR 0 2
121381: PUSH
121382: CALL_OW 44
121386: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
121387: LD_VAR 0 2
121391: PPUSH
121392: LD_INT 1
121394: PPUSH
121395: CALL_OW 51
// tmp := tmp ^ un ;
121399: LD_ADDR_VAR 0 3
121403: PUSH
121404: LD_VAR 0 3
121408: PUSH
121409: LD_VAR 0 2
121413: ADD
121414: ST_TO_ADDR
// end ;
121415: GO 121311
121417: POP
121418: POP
// repeat wait ( 0 0$1 ) ;
121419: LD_INT 35
121421: PPUSH
121422: CALL_OW 67
// for un in tmp do
121426: LD_ADDR_VAR 0 2
121430: PUSH
121431: LD_VAR 0 3
121435: PUSH
121436: FOR_IN
121437: IFFALSE 121511
// begin if IsDead ( un ) then
121439: LD_VAR 0 2
121443: PPUSH
121444: CALL_OW 301
121448: IFFALSE 121468
// begin tmp := tmp diff un ;
121450: LD_ADDR_VAR 0 3
121454: PUSH
121455: LD_VAR 0 3
121459: PUSH
121460: LD_VAR 0 2
121464: DIFF
121465: ST_TO_ADDR
// continue ;
121466: GO 121436
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
121468: LD_VAR 0 2
121472: PPUSH
121473: LD_INT 3
121475: PUSH
121476: LD_INT 22
121478: PUSH
121479: LD_INT 0
121481: PUSH
121482: EMPTY
121483: LIST
121484: LIST
121485: PUSH
121486: EMPTY
121487: LIST
121488: LIST
121489: PPUSH
121490: CALL_OW 69
121494: PPUSH
121495: LD_VAR 0 2
121499: PPUSH
121500: CALL_OW 74
121504: PPUSH
121505: CALL_OW 115
// end ;
121509: GO 121436
121511: POP
121512: POP
// until not tmp ;
121513: LD_VAR 0 3
121517: NOT
121518: IFFALSE 121419
// end ;
121520: PPOPN 3
121522: END
// every 0 0$1 trigger StreamModeActive and sTroll do
121523: LD_EXP 148
121527: PUSH
121528: LD_EXP 173
121532: AND
121533: IFFALSE 121587
121535: GO 121537
121537: DISABLE
// begin ToLua ( displayTroll(); ) ;
121538: LD_STRING displayTroll();
121540: PPUSH
121541: CALL_OW 559
// wait ( 3 3$00 ) ;
121545: LD_INT 6300
121547: PPUSH
121548: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121552: LD_STRING hideTroll();
121554: PPUSH
121555: CALL_OW 559
// wait ( 1 1$00 ) ;
121559: LD_INT 2100
121561: PPUSH
121562: CALL_OW 67
// ToLua ( displayTroll(); ) ;
121566: LD_STRING displayTroll();
121568: PPUSH
121569: CALL_OW 559
// wait ( 1 1$00 ) ;
121573: LD_INT 2100
121575: PPUSH
121576: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121580: LD_STRING hideTroll();
121582: PPUSH
121583: CALL_OW 559
// end ;
121587: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121588: LD_EXP 148
121592: PUSH
121593: LD_EXP 174
121597: AND
121598: IFFALSE 121661
121600: GO 121602
121602: DISABLE
121603: LD_INT 0
121605: PPUSH
// begin p := 0 ;
121606: LD_ADDR_VAR 0 1
121610: PUSH
121611: LD_INT 0
121613: ST_TO_ADDR
// repeat game_speed := 1 ;
121614: LD_ADDR_OWVAR 65
121618: PUSH
121619: LD_INT 1
121621: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121622: LD_INT 35
121624: PPUSH
121625: CALL_OW 67
// p := p + 1 ;
121629: LD_ADDR_VAR 0 1
121633: PUSH
121634: LD_VAR 0 1
121638: PUSH
121639: LD_INT 1
121641: PLUS
121642: ST_TO_ADDR
// until p >= 60 ;
121643: LD_VAR 0 1
121647: PUSH
121648: LD_INT 60
121650: GREATEREQUAL
121651: IFFALSE 121614
// game_speed := 4 ;
121653: LD_ADDR_OWVAR 65
121657: PUSH
121658: LD_INT 4
121660: ST_TO_ADDR
// end ;
121661: PPOPN 1
121663: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121664: LD_EXP 148
121668: PUSH
121669: LD_EXP 175
121673: AND
121674: IFFALSE 121820
121676: GO 121678
121678: DISABLE
121679: LD_INT 0
121681: PPUSH
121682: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121683: LD_ADDR_VAR 0 1
121687: PUSH
121688: LD_INT 22
121690: PUSH
121691: LD_OWVAR 2
121695: PUSH
121696: EMPTY
121697: LIST
121698: LIST
121699: PUSH
121700: LD_INT 2
121702: PUSH
121703: LD_INT 30
121705: PUSH
121706: LD_INT 0
121708: PUSH
121709: EMPTY
121710: LIST
121711: LIST
121712: PUSH
121713: LD_INT 30
121715: PUSH
121716: LD_INT 1
121718: PUSH
121719: EMPTY
121720: LIST
121721: LIST
121722: PUSH
121723: EMPTY
121724: LIST
121725: LIST
121726: LIST
121727: PUSH
121728: EMPTY
121729: LIST
121730: LIST
121731: PPUSH
121732: CALL_OW 69
121736: ST_TO_ADDR
// if not depot then
121737: LD_VAR 0 1
121741: NOT
121742: IFFALSE 121746
// exit ;
121744: GO 121820
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121746: LD_ADDR_VAR 0 2
121750: PUSH
121751: LD_VAR 0 1
121755: PUSH
121756: LD_INT 1
121758: PPUSH
121759: LD_VAR 0 1
121763: PPUSH
121764: CALL_OW 12
121768: ARRAY
121769: PPUSH
121770: CALL_OW 274
121774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121775: LD_VAR 0 2
121779: PPUSH
121780: LD_INT 1
121782: PPUSH
121783: LD_INT 0
121785: PPUSH
121786: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121790: LD_VAR 0 2
121794: PPUSH
121795: LD_INT 2
121797: PPUSH
121798: LD_INT 0
121800: PPUSH
121801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121805: LD_VAR 0 2
121809: PPUSH
121810: LD_INT 3
121812: PPUSH
121813: LD_INT 0
121815: PPUSH
121816: CALL_OW 277
// end ;
121820: PPOPN 2
121822: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121823: LD_EXP 148
121827: PUSH
121828: LD_EXP 176
121832: AND
121833: IFFALSE 121930
121835: GO 121837
121837: DISABLE
121838: LD_INT 0
121840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121841: LD_ADDR_VAR 0 1
121845: PUSH
121846: LD_INT 22
121848: PUSH
121849: LD_OWVAR 2
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: PUSH
121858: LD_INT 21
121860: PUSH
121861: LD_INT 1
121863: PUSH
121864: EMPTY
121865: LIST
121866: LIST
121867: PUSH
121868: LD_INT 3
121870: PUSH
121871: LD_INT 23
121873: PUSH
121874: LD_INT 0
121876: PUSH
121877: EMPTY
121878: LIST
121879: LIST
121880: PUSH
121881: EMPTY
121882: LIST
121883: LIST
121884: PUSH
121885: EMPTY
121886: LIST
121887: LIST
121888: LIST
121889: PPUSH
121890: CALL_OW 69
121894: ST_TO_ADDR
// if not tmp then
121895: LD_VAR 0 1
121899: NOT
121900: IFFALSE 121904
// exit ;
121902: GO 121930
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121904: LD_VAR 0 1
121908: PUSH
121909: LD_INT 1
121911: PPUSH
121912: LD_VAR 0 1
121916: PPUSH
121917: CALL_OW 12
121921: ARRAY
121922: PPUSH
121923: LD_INT 200
121925: PPUSH
121926: CALL_OW 234
// end ;
121930: PPOPN 1
121932: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121933: LD_EXP 148
121937: PUSH
121938: LD_EXP 177
121942: AND
121943: IFFALSE 122022
121945: GO 121947
121947: DISABLE
121948: LD_INT 0
121950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121951: LD_ADDR_VAR 0 1
121955: PUSH
121956: LD_INT 22
121958: PUSH
121959: LD_OWVAR 2
121963: PUSH
121964: EMPTY
121965: LIST
121966: LIST
121967: PUSH
121968: LD_INT 21
121970: PUSH
121971: LD_INT 2
121973: PUSH
121974: EMPTY
121975: LIST
121976: LIST
121977: PUSH
121978: EMPTY
121979: LIST
121980: LIST
121981: PPUSH
121982: CALL_OW 69
121986: ST_TO_ADDR
// if not tmp then
121987: LD_VAR 0 1
121991: NOT
121992: IFFALSE 121996
// exit ;
121994: GO 122022
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121996: LD_VAR 0 1
122000: PUSH
122001: LD_INT 1
122003: PPUSH
122004: LD_VAR 0 1
122008: PPUSH
122009: CALL_OW 12
122013: ARRAY
122014: PPUSH
122015: LD_INT 60
122017: PPUSH
122018: CALL_OW 234
// end ;
122022: PPOPN 1
122024: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
122025: LD_EXP 148
122029: PUSH
122030: LD_EXP 178
122034: AND
122035: IFFALSE 122134
122037: GO 122039
122039: DISABLE
122040: LD_INT 0
122042: PPUSH
122043: PPUSH
// begin enable ;
122044: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
122045: LD_ADDR_VAR 0 1
122049: PUSH
122050: LD_INT 22
122052: PUSH
122053: LD_OWVAR 2
122057: PUSH
122058: EMPTY
122059: LIST
122060: LIST
122061: PUSH
122062: LD_INT 61
122064: PUSH
122065: EMPTY
122066: LIST
122067: PUSH
122068: LD_INT 33
122070: PUSH
122071: LD_INT 2
122073: PUSH
122074: EMPTY
122075: LIST
122076: LIST
122077: PUSH
122078: EMPTY
122079: LIST
122080: LIST
122081: LIST
122082: PPUSH
122083: CALL_OW 69
122087: ST_TO_ADDR
// if not tmp then
122088: LD_VAR 0 1
122092: NOT
122093: IFFALSE 122097
// exit ;
122095: GO 122134
// for i in tmp do
122097: LD_ADDR_VAR 0 2
122101: PUSH
122102: LD_VAR 0 1
122106: PUSH
122107: FOR_IN
122108: IFFALSE 122132
// if IsControledBy ( i ) then
122110: LD_VAR 0 2
122114: PPUSH
122115: CALL_OW 312
122119: IFFALSE 122130
// ComUnlink ( i ) ;
122121: LD_VAR 0 2
122125: PPUSH
122126: CALL_OW 136
122130: GO 122107
122132: POP
122133: POP
// end ;
122134: PPOPN 2
122136: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
122137: LD_EXP 148
122141: PUSH
122142: LD_EXP 179
122146: AND
122147: IFFALSE 122287
122149: GO 122151
122151: DISABLE
122152: LD_INT 0
122154: PPUSH
122155: PPUSH
// begin ToLua ( displayPowell(); ) ;
122156: LD_STRING displayPowell();
122158: PPUSH
122159: CALL_OW 559
// uc_side := 0 ;
122163: LD_ADDR_OWVAR 20
122167: PUSH
122168: LD_INT 0
122170: ST_TO_ADDR
// uc_nation := 2 ;
122171: LD_ADDR_OWVAR 21
122175: PUSH
122176: LD_INT 2
122178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
122179: LD_ADDR_OWVAR 37
122183: PUSH
122184: LD_INT 14
122186: ST_TO_ADDR
// vc_engine := engine_siberite ;
122187: LD_ADDR_OWVAR 39
122191: PUSH
122192: LD_INT 3
122194: ST_TO_ADDR
// vc_control := control_apeman ;
122195: LD_ADDR_OWVAR 38
122199: PUSH
122200: LD_INT 5
122202: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
122203: LD_ADDR_OWVAR 40
122207: PUSH
122208: LD_INT 29
122210: ST_TO_ADDR
// un := CreateVehicle ;
122211: LD_ADDR_VAR 0 2
122215: PUSH
122216: CALL_OW 45
122220: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122221: LD_VAR 0 2
122225: PPUSH
122226: LD_INT 1
122228: PPUSH
122229: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122233: LD_INT 35
122235: PPUSH
122236: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122240: LD_VAR 0 2
122244: PPUSH
122245: LD_INT 22
122247: PUSH
122248: LD_OWVAR 2
122252: PUSH
122253: EMPTY
122254: LIST
122255: LIST
122256: PPUSH
122257: CALL_OW 69
122261: PPUSH
122262: LD_VAR 0 2
122266: PPUSH
122267: CALL_OW 74
122271: PPUSH
122272: CALL_OW 115
// until IsDead ( un ) ;
122276: LD_VAR 0 2
122280: PPUSH
122281: CALL_OW 301
122285: IFFALSE 122233
// end ;
122287: PPOPN 2
122289: END
// every 0 0$1 trigger StreamModeActive and sStu do
122290: LD_EXP 148
122294: PUSH
122295: LD_EXP 187
122299: AND
122300: IFFALSE 122316
122302: GO 122304
122304: DISABLE
// begin ToLua ( displayStucuk(); ) ;
122305: LD_STRING displayStucuk();
122307: PPUSH
122308: CALL_OW 559
// ResetFog ;
122312: CALL_OW 335
// end ;
122316: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
122317: LD_EXP 148
122321: PUSH
122322: LD_EXP 180
122326: AND
122327: IFFALSE 122468
122329: GO 122331
122331: DISABLE
122332: LD_INT 0
122334: PPUSH
122335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122336: LD_ADDR_VAR 0 2
122340: PUSH
122341: LD_INT 22
122343: PUSH
122344: LD_OWVAR 2
122348: PUSH
122349: EMPTY
122350: LIST
122351: LIST
122352: PUSH
122353: LD_INT 21
122355: PUSH
122356: LD_INT 1
122358: PUSH
122359: EMPTY
122360: LIST
122361: LIST
122362: PUSH
122363: EMPTY
122364: LIST
122365: LIST
122366: PPUSH
122367: CALL_OW 69
122371: ST_TO_ADDR
// if not tmp then
122372: LD_VAR 0 2
122376: NOT
122377: IFFALSE 122381
// exit ;
122379: GO 122468
// un := tmp [ rand ( 1 , tmp ) ] ;
122381: LD_ADDR_VAR 0 1
122385: PUSH
122386: LD_VAR 0 2
122390: PUSH
122391: LD_INT 1
122393: PPUSH
122394: LD_VAR 0 2
122398: PPUSH
122399: CALL_OW 12
122403: ARRAY
122404: ST_TO_ADDR
// SetSide ( un , 0 ) ;
122405: LD_VAR 0 1
122409: PPUSH
122410: LD_INT 0
122412: PPUSH
122413: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
122417: LD_VAR 0 1
122421: PPUSH
122422: LD_OWVAR 3
122426: PUSH
122427: LD_VAR 0 1
122431: DIFF
122432: PPUSH
122433: LD_VAR 0 1
122437: PPUSH
122438: CALL_OW 74
122442: PPUSH
122443: CALL_OW 115
// wait ( 0 0$20 ) ;
122447: LD_INT 700
122449: PPUSH
122450: CALL_OW 67
// SetSide ( un , your_side ) ;
122454: LD_VAR 0 1
122458: PPUSH
122459: LD_OWVAR 2
122463: PPUSH
122464: CALL_OW 235
// end ;
122468: PPOPN 2
122470: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
122471: LD_EXP 148
122475: PUSH
122476: LD_EXP 181
122480: AND
122481: IFFALSE 122587
122483: GO 122485
122485: DISABLE
122486: LD_INT 0
122488: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122489: LD_ADDR_VAR 0 1
122493: PUSH
122494: LD_INT 22
122496: PUSH
122497: LD_OWVAR 2
122501: PUSH
122502: EMPTY
122503: LIST
122504: LIST
122505: PUSH
122506: LD_INT 2
122508: PUSH
122509: LD_INT 30
122511: PUSH
122512: LD_INT 0
122514: PUSH
122515: EMPTY
122516: LIST
122517: LIST
122518: PUSH
122519: LD_INT 30
122521: PUSH
122522: LD_INT 1
122524: PUSH
122525: EMPTY
122526: LIST
122527: LIST
122528: PUSH
122529: EMPTY
122530: LIST
122531: LIST
122532: LIST
122533: PUSH
122534: EMPTY
122535: LIST
122536: LIST
122537: PPUSH
122538: CALL_OW 69
122542: ST_TO_ADDR
// if not depot then
122543: LD_VAR 0 1
122547: NOT
122548: IFFALSE 122552
// exit ;
122550: GO 122587
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
122552: LD_VAR 0 1
122556: PUSH
122557: LD_INT 1
122559: ARRAY
122560: PPUSH
122561: CALL_OW 250
122565: PPUSH
122566: LD_VAR 0 1
122570: PUSH
122571: LD_INT 1
122573: ARRAY
122574: PPUSH
122575: CALL_OW 251
122579: PPUSH
122580: LD_INT 70
122582: PPUSH
122583: CALL_OW 495
// end ;
122587: PPOPN 1
122589: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122590: LD_EXP 148
122594: PUSH
122595: LD_EXP 182
122599: AND
122600: IFFALSE 122811
122602: GO 122604
122604: DISABLE
122605: LD_INT 0
122607: PPUSH
122608: PPUSH
122609: PPUSH
122610: PPUSH
122611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122612: LD_ADDR_VAR 0 5
122616: PUSH
122617: LD_INT 22
122619: PUSH
122620: LD_OWVAR 2
122624: PUSH
122625: EMPTY
122626: LIST
122627: LIST
122628: PUSH
122629: LD_INT 21
122631: PUSH
122632: LD_INT 1
122634: PUSH
122635: EMPTY
122636: LIST
122637: LIST
122638: PUSH
122639: EMPTY
122640: LIST
122641: LIST
122642: PPUSH
122643: CALL_OW 69
122647: ST_TO_ADDR
// if not tmp then
122648: LD_VAR 0 5
122652: NOT
122653: IFFALSE 122657
// exit ;
122655: GO 122811
// for i in tmp do
122657: LD_ADDR_VAR 0 1
122661: PUSH
122662: LD_VAR 0 5
122666: PUSH
122667: FOR_IN
122668: IFFALSE 122809
// begin d := rand ( 0 , 5 ) ;
122670: LD_ADDR_VAR 0 4
122674: PUSH
122675: LD_INT 0
122677: PPUSH
122678: LD_INT 5
122680: PPUSH
122681: CALL_OW 12
122685: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122686: LD_ADDR_VAR 0 2
122690: PUSH
122691: LD_VAR 0 1
122695: PPUSH
122696: CALL_OW 250
122700: PPUSH
122701: LD_VAR 0 4
122705: PPUSH
122706: LD_INT 3
122708: PPUSH
122709: LD_INT 12
122711: PPUSH
122712: CALL_OW 12
122716: PPUSH
122717: CALL_OW 272
122721: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122722: LD_ADDR_VAR 0 3
122726: PUSH
122727: LD_VAR 0 1
122731: PPUSH
122732: CALL_OW 251
122736: PPUSH
122737: LD_VAR 0 4
122741: PPUSH
122742: LD_INT 3
122744: PPUSH
122745: LD_INT 12
122747: PPUSH
122748: CALL_OW 12
122752: PPUSH
122753: CALL_OW 273
122757: ST_TO_ADDR
// if ValidHex ( x , y ) then
122758: LD_VAR 0 2
122762: PPUSH
122763: LD_VAR 0 3
122767: PPUSH
122768: CALL_OW 488
122772: IFFALSE 122807
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122774: LD_VAR 0 1
122778: PPUSH
122779: LD_VAR 0 2
122783: PPUSH
122784: LD_VAR 0 3
122788: PPUSH
122789: LD_INT 3
122791: PPUSH
122792: LD_INT 6
122794: PPUSH
122795: CALL_OW 12
122799: PPUSH
122800: LD_INT 1
122802: PPUSH
122803: CALL_OW 483
// end ;
122807: GO 122667
122809: POP
122810: POP
// end ;
122811: PPOPN 5
122813: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122814: LD_EXP 148
122818: PUSH
122819: LD_EXP 183
122823: AND
122824: IFFALSE 122918
122826: GO 122828
122828: DISABLE
122829: LD_INT 0
122831: PPUSH
122832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122833: LD_ADDR_VAR 0 2
122837: PUSH
122838: LD_INT 22
122840: PUSH
122841: LD_OWVAR 2
122845: PUSH
122846: EMPTY
122847: LIST
122848: LIST
122849: PUSH
122850: LD_INT 32
122852: PUSH
122853: LD_INT 1
122855: PUSH
122856: EMPTY
122857: LIST
122858: LIST
122859: PUSH
122860: LD_INT 21
122862: PUSH
122863: LD_INT 2
122865: PUSH
122866: EMPTY
122867: LIST
122868: LIST
122869: PUSH
122870: EMPTY
122871: LIST
122872: LIST
122873: LIST
122874: PPUSH
122875: CALL_OW 69
122879: ST_TO_ADDR
// if not tmp then
122880: LD_VAR 0 2
122884: NOT
122885: IFFALSE 122889
// exit ;
122887: GO 122918
// for i in tmp do
122889: LD_ADDR_VAR 0 1
122893: PUSH
122894: LD_VAR 0 2
122898: PUSH
122899: FOR_IN
122900: IFFALSE 122916
// SetFuel ( i , 0 ) ;
122902: LD_VAR 0 1
122906: PPUSH
122907: LD_INT 0
122909: PPUSH
122910: CALL_OW 240
122914: GO 122899
122916: POP
122917: POP
// end ;
122918: PPOPN 2
122920: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122921: LD_EXP 148
122925: PUSH
122926: LD_EXP 184
122930: AND
122931: IFFALSE 122997
122933: GO 122935
122935: DISABLE
122936: LD_INT 0
122938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122939: LD_ADDR_VAR 0 1
122943: PUSH
122944: LD_INT 22
122946: PUSH
122947: LD_OWVAR 2
122951: PUSH
122952: EMPTY
122953: LIST
122954: LIST
122955: PUSH
122956: LD_INT 30
122958: PUSH
122959: LD_INT 29
122961: PUSH
122962: EMPTY
122963: LIST
122964: LIST
122965: PUSH
122966: EMPTY
122967: LIST
122968: LIST
122969: PPUSH
122970: CALL_OW 69
122974: ST_TO_ADDR
// if not tmp then
122975: LD_VAR 0 1
122979: NOT
122980: IFFALSE 122984
// exit ;
122982: GO 122997
// DestroyUnit ( tmp [ 1 ] ) ;
122984: LD_VAR 0 1
122988: PUSH
122989: LD_INT 1
122991: ARRAY
122992: PPUSH
122993: CALL_OW 65
// end ;
122997: PPOPN 1
122999: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
123000: LD_EXP 148
123004: PUSH
123005: LD_EXP 186
123009: AND
123010: IFFALSE 123139
123012: GO 123014
123014: DISABLE
123015: LD_INT 0
123017: PPUSH
// begin uc_side := 0 ;
123018: LD_ADDR_OWVAR 20
123022: PUSH
123023: LD_INT 0
123025: ST_TO_ADDR
// uc_nation := nation_arabian ;
123026: LD_ADDR_OWVAR 21
123030: PUSH
123031: LD_INT 2
123033: ST_TO_ADDR
// hc_gallery :=  ;
123034: LD_ADDR_OWVAR 33
123038: PUSH
123039: LD_STRING 
123041: ST_TO_ADDR
// hc_name :=  ;
123042: LD_ADDR_OWVAR 26
123046: PUSH
123047: LD_STRING 
123049: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
123050: LD_INT 1
123052: PPUSH
123053: LD_INT 11
123055: PPUSH
123056: LD_INT 10
123058: PPUSH
123059: CALL_OW 380
// un := CreateHuman ;
123063: LD_ADDR_VAR 0 1
123067: PUSH
123068: CALL_OW 44
123072: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123073: LD_VAR 0 1
123077: PPUSH
123078: LD_INT 1
123080: PPUSH
123081: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123085: LD_INT 35
123087: PPUSH
123088: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123092: LD_VAR 0 1
123096: PPUSH
123097: LD_INT 22
123099: PUSH
123100: LD_OWVAR 2
123104: PUSH
123105: EMPTY
123106: LIST
123107: LIST
123108: PPUSH
123109: CALL_OW 69
123113: PPUSH
123114: LD_VAR 0 1
123118: PPUSH
123119: CALL_OW 74
123123: PPUSH
123124: CALL_OW 115
// until IsDead ( un ) ;
123128: LD_VAR 0 1
123132: PPUSH
123133: CALL_OW 301
123137: IFFALSE 123085
// end ;
123139: PPOPN 1
123141: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
123142: LD_EXP 148
123146: PUSH
123147: LD_EXP 188
123151: AND
123152: IFFALSE 123164
123154: GO 123156
123156: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
123157: LD_STRING earthquake(getX(game), 0, 32)
123159: PPUSH
123160: CALL_OW 559
123164: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
123165: LD_EXP 148
123169: PUSH
123170: LD_EXP 189
123174: AND
123175: IFFALSE 123266
123177: GO 123179
123179: DISABLE
123180: LD_INT 0
123182: PPUSH
// begin enable ;
123183: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
123184: LD_ADDR_VAR 0 1
123188: PUSH
123189: LD_INT 22
123191: PUSH
123192: LD_OWVAR 2
123196: PUSH
123197: EMPTY
123198: LIST
123199: LIST
123200: PUSH
123201: LD_INT 21
123203: PUSH
123204: LD_INT 2
123206: PUSH
123207: EMPTY
123208: LIST
123209: LIST
123210: PUSH
123211: LD_INT 33
123213: PUSH
123214: LD_INT 3
123216: PUSH
123217: EMPTY
123218: LIST
123219: LIST
123220: PUSH
123221: EMPTY
123222: LIST
123223: LIST
123224: LIST
123225: PPUSH
123226: CALL_OW 69
123230: ST_TO_ADDR
// if not tmp then
123231: LD_VAR 0 1
123235: NOT
123236: IFFALSE 123240
// exit ;
123238: GO 123266
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123240: LD_VAR 0 1
123244: PUSH
123245: LD_INT 1
123247: PPUSH
123248: LD_VAR 0 1
123252: PPUSH
123253: CALL_OW 12
123257: ARRAY
123258: PPUSH
123259: LD_INT 1
123261: PPUSH
123262: CALL_OW 234
// end ;
123266: PPOPN 1
123268: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
123269: LD_EXP 148
123273: PUSH
123274: LD_EXP 190
123278: AND
123279: IFFALSE 123420
123281: GO 123283
123283: DISABLE
123284: LD_INT 0
123286: PPUSH
123287: PPUSH
123288: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123289: LD_ADDR_VAR 0 3
123293: PUSH
123294: LD_INT 22
123296: PUSH
123297: LD_OWVAR 2
123301: PUSH
123302: EMPTY
123303: LIST
123304: LIST
123305: PUSH
123306: LD_INT 25
123308: PUSH
123309: LD_INT 1
123311: PUSH
123312: EMPTY
123313: LIST
123314: LIST
123315: PUSH
123316: EMPTY
123317: LIST
123318: LIST
123319: PPUSH
123320: CALL_OW 69
123324: ST_TO_ADDR
// if not tmp then
123325: LD_VAR 0 3
123329: NOT
123330: IFFALSE 123334
// exit ;
123332: GO 123420
// un := tmp [ rand ( 1 , tmp ) ] ;
123334: LD_ADDR_VAR 0 2
123338: PUSH
123339: LD_VAR 0 3
123343: PUSH
123344: LD_INT 1
123346: PPUSH
123347: LD_VAR 0 3
123351: PPUSH
123352: CALL_OW 12
123356: ARRAY
123357: ST_TO_ADDR
// if Crawls ( un ) then
123358: LD_VAR 0 2
123362: PPUSH
123363: CALL_OW 318
123367: IFFALSE 123378
// ComWalk ( un ) ;
123369: LD_VAR 0 2
123373: PPUSH
123374: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
123378: LD_VAR 0 2
123382: PPUSH
123383: LD_INT 9
123385: PPUSH
123386: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
123390: LD_INT 28
123392: PPUSH
123393: LD_OWVAR 2
123397: PPUSH
123398: LD_INT 2
123400: PPUSH
123401: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
123405: LD_INT 29
123407: PPUSH
123408: LD_OWVAR 2
123412: PPUSH
123413: LD_INT 2
123415: PPUSH
123416: CALL_OW 322
// end ;
123420: PPOPN 3
123422: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
123423: LD_EXP 148
123427: PUSH
123428: LD_EXP 191
123432: AND
123433: IFFALSE 123544
123435: GO 123437
123437: DISABLE
123438: LD_INT 0
123440: PPUSH
123441: PPUSH
123442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123443: LD_ADDR_VAR 0 3
123447: PUSH
123448: LD_INT 22
123450: PUSH
123451: LD_OWVAR 2
123455: PUSH
123456: EMPTY
123457: LIST
123458: LIST
123459: PUSH
123460: LD_INT 25
123462: PUSH
123463: LD_INT 1
123465: PUSH
123466: EMPTY
123467: LIST
123468: LIST
123469: PUSH
123470: EMPTY
123471: LIST
123472: LIST
123473: PPUSH
123474: CALL_OW 69
123478: ST_TO_ADDR
// if not tmp then
123479: LD_VAR 0 3
123483: NOT
123484: IFFALSE 123488
// exit ;
123486: GO 123544
// un := tmp [ rand ( 1 , tmp ) ] ;
123488: LD_ADDR_VAR 0 2
123492: PUSH
123493: LD_VAR 0 3
123497: PUSH
123498: LD_INT 1
123500: PPUSH
123501: LD_VAR 0 3
123505: PPUSH
123506: CALL_OW 12
123510: ARRAY
123511: ST_TO_ADDR
// if Crawls ( un ) then
123512: LD_VAR 0 2
123516: PPUSH
123517: CALL_OW 318
123521: IFFALSE 123532
// ComWalk ( un ) ;
123523: LD_VAR 0 2
123527: PPUSH
123528: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123532: LD_VAR 0 2
123536: PPUSH
123537: LD_INT 8
123539: PPUSH
123540: CALL_OW 336
// end ;
123544: PPOPN 3
123546: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
123547: LD_EXP 148
123551: PUSH
123552: LD_EXP 192
123556: AND
123557: IFFALSE 123701
123559: GO 123561
123561: DISABLE
123562: LD_INT 0
123564: PPUSH
123565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
123566: LD_ADDR_VAR 0 2
123570: PUSH
123571: LD_INT 22
123573: PUSH
123574: LD_OWVAR 2
123578: PUSH
123579: EMPTY
123580: LIST
123581: LIST
123582: PUSH
123583: LD_INT 21
123585: PUSH
123586: LD_INT 2
123588: PUSH
123589: EMPTY
123590: LIST
123591: LIST
123592: PUSH
123593: LD_INT 2
123595: PUSH
123596: LD_INT 34
123598: PUSH
123599: LD_INT 12
123601: PUSH
123602: EMPTY
123603: LIST
123604: LIST
123605: PUSH
123606: LD_INT 34
123608: PUSH
123609: LD_INT 51
123611: PUSH
123612: EMPTY
123613: LIST
123614: LIST
123615: PUSH
123616: LD_INT 34
123618: PUSH
123619: LD_INT 32
123621: PUSH
123622: EMPTY
123623: LIST
123624: LIST
123625: PUSH
123626: EMPTY
123627: LIST
123628: LIST
123629: LIST
123630: LIST
123631: PUSH
123632: EMPTY
123633: LIST
123634: LIST
123635: LIST
123636: PPUSH
123637: CALL_OW 69
123641: ST_TO_ADDR
// if not tmp then
123642: LD_VAR 0 2
123646: NOT
123647: IFFALSE 123651
// exit ;
123649: GO 123701
// for i in tmp do
123651: LD_ADDR_VAR 0 1
123655: PUSH
123656: LD_VAR 0 2
123660: PUSH
123661: FOR_IN
123662: IFFALSE 123699
// if GetCargo ( i , mat_artifact ) = 0 then
123664: LD_VAR 0 1
123668: PPUSH
123669: LD_INT 4
123671: PPUSH
123672: CALL_OW 289
123676: PUSH
123677: LD_INT 0
123679: EQUAL
123680: IFFALSE 123697
// SetCargo ( i , mat_siberit , 100 ) ;
123682: LD_VAR 0 1
123686: PPUSH
123687: LD_INT 3
123689: PPUSH
123690: LD_INT 100
123692: PPUSH
123693: CALL_OW 290
123697: GO 123661
123699: POP
123700: POP
// end ;
123701: PPOPN 2
123703: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123704: LD_EXP 148
123708: PUSH
123709: LD_EXP 193
123713: AND
123714: IFFALSE 123897
123716: GO 123718
123718: DISABLE
123719: LD_INT 0
123721: PPUSH
123722: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123723: LD_ADDR_VAR 0 2
123727: PUSH
123728: LD_INT 22
123730: PUSH
123731: LD_OWVAR 2
123735: PUSH
123736: EMPTY
123737: LIST
123738: LIST
123739: PPUSH
123740: CALL_OW 69
123744: ST_TO_ADDR
// if not tmp then
123745: LD_VAR 0 2
123749: NOT
123750: IFFALSE 123754
// exit ;
123752: GO 123897
// for i := 1 to 2 do
123754: LD_ADDR_VAR 0 1
123758: PUSH
123759: DOUBLE
123760: LD_INT 1
123762: DEC
123763: ST_TO_ADDR
123764: LD_INT 2
123766: PUSH
123767: FOR_TO
123768: IFFALSE 123895
// begin uc_side := your_side ;
123770: LD_ADDR_OWVAR 20
123774: PUSH
123775: LD_OWVAR 2
123779: ST_TO_ADDR
// uc_nation := nation_american ;
123780: LD_ADDR_OWVAR 21
123784: PUSH
123785: LD_INT 1
123787: ST_TO_ADDR
// vc_chassis := us_morphling ;
123788: LD_ADDR_OWVAR 37
123792: PUSH
123793: LD_INT 5
123795: ST_TO_ADDR
// vc_engine := engine_siberite ;
123796: LD_ADDR_OWVAR 39
123800: PUSH
123801: LD_INT 3
123803: ST_TO_ADDR
// vc_control := control_computer ;
123804: LD_ADDR_OWVAR 38
123808: PUSH
123809: LD_INT 3
123811: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123812: LD_ADDR_OWVAR 40
123816: PUSH
123817: LD_INT 10
123819: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123820: LD_VAR 0 2
123824: PUSH
123825: LD_INT 1
123827: ARRAY
123828: PPUSH
123829: CALL_OW 310
123833: NOT
123834: IFFALSE 123881
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123836: CALL_OW 45
123840: PPUSH
123841: LD_VAR 0 2
123845: PUSH
123846: LD_INT 1
123848: ARRAY
123849: PPUSH
123850: CALL_OW 250
123854: PPUSH
123855: LD_VAR 0 2
123859: PUSH
123860: LD_INT 1
123862: ARRAY
123863: PPUSH
123864: CALL_OW 251
123868: PPUSH
123869: LD_INT 12
123871: PPUSH
123872: LD_INT 1
123874: PPUSH
123875: CALL_OW 50
123879: GO 123893
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123881: CALL_OW 45
123885: PPUSH
123886: LD_INT 1
123888: PPUSH
123889: CALL_OW 51
// end ;
123893: GO 123767
123895: POP
123896: POP
// end ;
123897: PPOPN 2
123899: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123900: LD_EXP 148
123904: PUSH
123905: LD_EXP 194
123909: AND
123910: IFFALSE 124132
123912: GO 123914
123914: DISABLE
123915: LD_INT 0
123917: PPUSH
123918: PPUSH
123919: PPUSH
123920: PPUSH
123921: PPUSH
123922: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123923: LD_ADDR_VAR 0 6
123927: PUSH
123928: LD_INT 22
123930: PUSH
123931: LD_OWVAR 2
123935: PUSH
123936: EMPTY
123937: LIST
123938: LIST
123939: PUSH
123940: LD_INT 21
123942: PUSH
123943: LD_INT 1
123945: PUSH
123946: EMPTY
123947: LIST
123948: LIST
123949: PUSH
123950: LD_INT 3
123952: PUSH
123953: LD_INT 23
123955: PUSH
123956: LD_INT 0
123958: PUSH
123959: EMPTY
123960: LIST
123961: LIST
123962: PUSH
123963: EMPTY
123964: LIST
123965: LIST
123966: PUSH
123967: EMPTY
123968: LIST
123969: LIST
123970: LIST
123971: PPUSH
123972: CALL_OW 69
123976: ST_TO_ADDR
// if not tmp then
123977: LD_VAR 0 6
123981: NOT
123982: IFFALSE 123986
// exit ;
123984: GO 124132
// s1 := rand ( 1 , 4 ) ;
123986: LD_ADDR_VAR 0 2
123990: PUSH
123991: LD_INT 1
123993: PPUSH
123994: LD_INT 4
123996: PPUSH
123997: CALL_OW 12
124001: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
124002: LD_ADDR_VAR 0 4
124006: PUSH
124007: LD_VAR 0 6
124011: PUSH
124012: LD_INT 1
124014: ARRAY
124015: PPUSH
124016: LD_VAR 0 2
124020: PPUSH
124021: CALL_OW 259
124025: ST_TO_ADDR
// if s1 = 1 then
124026: LD_VAR 0 2
124030: PUSH
124031: LD_INT 1
124033: EQUAL
124034: IFFALSE 124054
// s2 := rand ( 2 , 4 ) else
124036: LD_ADDR_VAR 0 3
124040: PUSH
124041: LD_INT 2
124043: PPUSH
124044: LD_INT 4
124046: PPUSH
124047: CALL_OW 12
124051: ST_TO_ADDR
124052: GO 124062
// s2 := 1 ;
124054: LD_ADDR_VAR 0 3
124058: PUSH
124059: LD_INT 1
124061: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
124062: LD_ADDR_VAR 0 5
124066: PUSH
124067: LD_VAR 0 6
124071: PUSH
124072: LD_INT 1
124074: ARRAY
124075: PPUSH
124076: LD_VAR 0 3
124080: PPUSH
124081: CALL_OW 259
124085: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
124086: LD_VAR 0 6
124090: PUSH
124091: LD_INT 1
124093: ARRAY
124094: PPUSH
124095: LD_VAR 0 2
124099: PPUSH
124100: LD_VAR 0 5
124104: PPUSH
124105: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
124109: LD_VAR 0 6
124113: PUSH
124114: LD_INT 1
124116: ARRAY
124117: PPUSH
124118: LD_VAR 0 3
124122: PPUSH
124123: LD_VAR 0 4
124127: PPUSH
124128: CALL_OW 237
// end ;
124132: PPOPN 6
124134: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
124135: LD_EXP 148
124139: PUSH
124140: LD_EXP 195
124144: AND
124145: IFFALSE 124224
124147: GO 124149
124149: DISABLE
124150: LD_INT 0
124152: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
124153: LD_ADDR_VAR 0 1
124157: PUSH
124158: LD_INT 22
124160: PUSH
124161: LD_OWVAR 2
124165: PUSH
124166: EMPTY
124167: LIST
124168: LIST
124169: PUSH
124170: LD_INT 30
124172: PUSH
124173: LD_INT 3
124175: PUSH
124176: EMPTY
124177: LIST
124178: LIST
124179: PUSH
124180: EMPTY
124181: LIST
124182: LIST
124183: PPUSH
124184: CALL_OW 69
124188: ST_TO_ADDR
// if not tmp then
124189: LD_VAR 0 1
124193: NOT
124194: IFFALSE 124198
// exit ;
124196: GO 124224
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124198: LD_VAR 0 1
124202: PUSH
124203: LD_INT 1
124205: PPUSH
124206: LD_VAR 0 1
124210: PPUSH
124211: CALL_OW 12
124215: ARRAY
124216: PPUSH
124217: LD_INT 1
124219: PPUSH
124220: CALL_OW 234
// end ;
124224: PPOPN 1
124226: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
124227: LD_EXP 148
124231: PUSH
124232: LD_EXP 196
124236: AND
124237: IFFALSE 124349
124239: GO 124241
124241: DISABLE
124242: LD_INT 0
124244: PPUSH
124245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
124246: LD_ADDR_VAR 0 2
124250: PUSH
124251: LD_INT 22
124253: PUSH
124254: LD_OWVAR 2
124258: PUSH
124259: EMPTY
124260: LIST
124261: LIST
124262: PUSH
124263: LD_INT 2
124265: PUSH
124266: LD_INT 30
124268: PUSH
124269: LD_INT 27
124271: PUSH
124272: EMPTY
124273: LIST
124274: LIST
124275: PUSH
124276: LD_INT 30
124278: PUSH
124279: LD_INT 26
124281: PUSH
124282: EMPTY
124283: LIST
124284: LIST
124285: PUSH
124286: LD_INT 30
124288: PUSH
124289: LD_INT 28
124291: PUSH
124292: EMPTY
124293: LIST
124294: LIST
124295: PUSH
124296: EMPTY
124297: LIST
124298: LIST
124299: LIST
124300: LIST
124301: PUSH
124302: EMPTY
124303: LIST
124304: LIST
124305: PPUSH
124306: CALL_OW 69
124310: ST_TO_ADDR
// if not tmp then
124311: LD_VAR 0 2
124315: NOT
124316: IFFALSE 124320
// exit ;
124318: GO 124349
// for i in tmp do
124320: LD_ADDR_VAR 0 1
124324: PUSH
124325: LD_VAR 0 2
124329: PUSH
124330: FOR_IN
124331: IFFALSE 124347
// SetLives ( i , 1 ) ;
124333: LD_VAR 0 1
124337: PPUSH
124338: LD_INT 1
124340: PPUSH
124341: CALL_OW 234
124345: GO 124330
124347: POP
124348: POP
// end ;
124349: PPOPN 2
124351: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
124352: LD_EXP 148
124356: PUSH
124357: LD_EXP 197
124361: AND
124362: IFFALSE 124649
124364: GO 124366
124366: DISABLE
124367: LD_INT 0
124369: PPUSH
124370: PPUSH
124371: PPUSH
// begin i := rand ( 1 , 7 ) ;
124372: LD_ADDR_VAR 0 1
124376: PUSH
124377: LD_INT 1
124379: PPUSH
124380: LD_INT 7
124382: PPUSH
124383: CALL_OW 12
124387: ST_TO_ADDR
// case i of 1 :
124388: LD_VAR 0 1
124392: PUSH
124393: LD_INT 1
124395: DOUBLE
124396: EQUAL
124397: IFTRUE 124401
124399: GO 124411
124401: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
124402: LD_STRING earthquake(getX(game), 0, 32)
124404: PPUSH
124405: CALL_OW 559
124409: GO 124649
124411: LD_INT 2
124413: DOUBLE
124414: EQUAL
124415: IFTRUE 124419
124417: GO 124433
124419: POP
// begin ToLua ( displayStucuk(); ) ;
124420: LD_STRING displayStucuk();
124422: PPUSH
124423: CALL_OW 559
// ResetFog ;
124427: CALL_OW 335
// end ; 3 :
124431: GO 124649
124433: LD_INT 3
124435: DOUBLE
124436: EQUAL
124437: IFTRUE 124441
124439: GO 124545
124441: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124442: LD_ADDR_VAR 0 2
124446: PUSH
124447: LD_INT 22
124449: PUSH
124450: LD_OWVAR 2
124454: PUSH
124455: EMPTY
124456: LIST
124457: LIST
124458: PUSH
124459: LD_INT 25
124461: PUSH
124462: LD_INT 1
124464: PUSH
124465: EMPTY
124466: LIST
124467: LIST
124468: PUSH
124469: EMPTY
124470: LIST
124471: LIST
124472: PPUSH
124473: CALL_OW 69
124477: ST_TO_ADDR
// if not tmp then
124478: LD_VAR 0 2
124482: NOT
124483: IFFALSE 124487
// exit ;
124485: GO 124649
// un := tmp [ rand ( 1 , tmp ) ] ;
124487: LD_ADDR_VAR 0 3
124491: PUSH
124492: LD_VAR 0 2
124496: PUSH
124497: LD_INT 1
124499: PPUSH
124500: LD_VAR 0 2
124504: PPUSH
124505: CALL_OW 12
124509: ARRAY
124510: ST_TO_ADDR
// if Crawls ( un ) then
124511: LD_VAR 0 3
124515: PPUSH
124516: CALL_OW 318
124520: IFFALSE 124531
// ComWalk ( un ) ;
124522: LD_VAR 0 3
124526: PPUSH
124527: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124531: LD_VAR 0 3
124535: PPUSH
124536: LD_INT 8
124538: PPUSH
124539: CALL_OW 336
// end ; 4 :
124543: GO 124649
124545: LD_INT 4
124547: DOUBLE
124548: EQUAL
124549: IFTRUE 124553
124551: GO 124627
124553: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124554: LD_ADDR_VAR 0 2
124558: PUSH
124559: LD_INT 22
124561: PUSH
124562: LD_OWVAR 2
124566: PUSH
124567: EMPTY
124568: LIST
124569: LIST
124570: PUSH
124571: LD_INT 30
124573: PUSH
124574: LD_INT 29
124576: PUSH
124577: EMPTY
124578: LIST
124579: LIST
124580: PUSH
124581: EMPTY
124582: LIST
124583: LIST
124584: PPUSH
124585: CALL_OW 69
124589: ST_TO_ADDR
// if not tmp then
124590: LD_VAR 0 2
124594: NOT
124595: IFFALSE 124599
// exit ;
124597: GO 124649
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124599: LD_VAR 0 2
124603: PUSH
124604: LD_INT 1
124606: ARRAY
124607: PPUSH
124608: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124612: LD_VAR 0 2
124616: PUSH
124617: LD_INT 1
124619: ARRAY
124620: PPUSH
124621: CALL_OW 65
// end ; 5 .. 7 :
124625: GO 124649
124627: LD_INT 5
124629: DOUBLE
124630: GREATEREQUAL
124631: IFFALSE 124639
124633: LD_INT 7
124635: DOUBLE
124636: LESSEQUAL
124637: IFTRUE 124641
124639: GO 124648
124641: POP
// StreamSibBomb ; end ;
124642: CALL 120886 0 0
124646: GO 124649
124648: POP
// end ;
124649: PPOPN 3
124651: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124652: LD_EXP 148
124656: PUSH
124657: LD_EXP 198
124661: AND
124662: IFFALSE 124818
124664: GO 124666
124666: DISABLE
124667: LD_INT 0
124669: PPUSH
124670: PPUSH
124671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124672: LD_ADDR_VAR 0 2
124676: PUSH
124677: LD_INT 81
124679: PUSH
124680: LD_OWVAR 2
124684: PUSH
124685: EMPTY
124686: LIST
124687: LIST
124688: PUSH
124689: LD_INT 2
124691: PUSH
124692: LD_INT 21
124694: PUSH
124695: LD_INT 1
124697: PUSH
124698: EMPTY
124699: LIST
124700: LIST
124701: PUSH
124702: LD_INT 21
124704: PUSH
124705: LD_INT 2
124707: PUSH
124708: EMPTY
124709: LIST
124710: LIST
124711: PUSH
124712: EMPTY
124713: LIST
124714: LIST
124715: LIST
124716: PUSH
124717: EMPTY
124718: LIST
124719: LIST
124720: PPUSH
124721: CALL_OW 69
124725: ST_TO_ADDR
// if not tmp then
124726: LD_VAR 0 2
124730: NOT
124731: IFFALSE 124735
// exit ;
124733: GO 124818
// p := 0 ;
124735: LD_ADDR_VAR 0 3
124739: PUSH
124740: LD_INT 0
124742: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124743: LD_INT 35
124745: PPUSH
124746: CALL_OW 67
// p := p + 1 ;
124750: LD_ADDR_VAR 0 3
124754: PUSH
124755: LD_VAR 0 3
124759: PUSH
124760: LD_INT 1
124762: PLUS
124763: ST_TO_ADDR
// for i in tmp do
124764: LD_ADDR_VAR 0 1
124768: PUSH
124769: LD_VAR 0 2
124773: PUSH
124774: FOR_IN
124775: IFFALSE 124806
// if GetLives ( i ) < 1000 then
124777: LD_VAR 0 1
124781: PPUSH
124782: CALL_OW 256
124786: PUSH
124787: LD_INT 1000
124789: LESS
124790: IFFALSE 124804
// SetLives ( i , 1000 ) ;
124792: LD_VAR 0 1
124796: PPUSH
124797: LD_INT 1000
124799: PPUSH
124800: CALL_OW 234
124804: GO 124774
124806: POP
124807: POP
// until p > 20 ;
124808: LD_VAR 0 3
124812: PUSH
124813: LD_INT 20
124815: GREATER
124816: IFFALSE 124743
// end ;
124818: PPOPN 3
124820: END
// every 0 0$1 trigger StreamModeActive and sTime do
124821: LD_EXP 148
124825: PUSH
124826: LD_EXP 199
124830: AND
124831: IFFALSE 124866
124833: GO 124835
124835: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124836: LD_INT 28
124838: PPUSH
124839: LD_OWVAR 2
124843: PPUSH
124844: LD_INT 2
124846: PPUSH
124847: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124851: LD_INT 30
124853: PPUSH
124854: LD_OWVAR 2
124858: PPUSH
124859: LD_INT 2
124861: PPUSH
124862: CALL_OW 322
// end ;
124866: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124867: LD_EXP 148
124871: PUSH
124872: LD_EXP 200
124876: AND
124877: IFFALSE 124998
124879: GO 124881
124881: DISABLE
124882: LD_INT 0
124884: PPUSH
124885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124886: LD_ADDR_VAR 0 2
124890: PUSH
124891: LD_INT 22
124893: PUSH
124894: LD_OWVAR 2
124898: PUSH
124899: EMPTY
124900: LIST
124901: LIST
124902: PUSH
124903: LD_INT 21
124905: PUSH
124906: LD_INT 1
124908: PUSH
124909: EMPTY
124910: LIST
124911: LIST
124912: PUSH
124913: LD_INT 3
124915: PUSH
124916: LD_INT 23
124918: PUSH
124919: LD_INT 0
124921: PUSH
124922: EMPTY
124923: LIST
124924: LIST
124925: PUSH
124926: EMPTY
124927: LIST
124928: LIST
124929: PUSH
124930: EMPTY
124931: LIST
124932: LIST
124933: LIST
124934: PPUSH
124935: CALL_OW 69
124939: ST_TO_ADDR
// if not tmp then
124940: LD_VAR 0 2
124944: NOT
124945: IFFALSE 124949
// exit ;
124947: GO 124998
// for i in tmp do
124949: LD_ADDR_VAR 0 1
124953: PUSH
124954: LD_VAR 0 2
124958: PUSH
124959: FOR_IN
124960: IFFALSE 124996
// begin if Crawls ( i ) then
124962: LD_VAR 0 1
124966: PPUSH
124967: CALL_OW 318
124971: IFFALSE 124982
// ComWalk ( i ) ;
124973: LD_VAR 0 1
124977: PPUSH
124978: CALL_OW 138
// SetClass ( i , 2 ) ;
124982: LD_VAR 0 1
124986: PPUSH
124987: LD_INT 2
124989: PPUSH
124990: CALL_OW 336
// end ;
124994: GO 124959
124996: POP
124997: POP
// end ;
124998: PPOPN 2
125000: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
125001: LD_EXP 148
125005: PUSH
125006: LD_EXP 201
125010: AND
125011: IFFALSE 125299
125013: GO 125015
125015: DISABLE
125016: LD_INT 0
125018: PPUSH
125019: PPUSH
125020: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
125021: LD_OWVAR 2
125025: PPUSH
125026: LD_INT 9
125028: PPUSH
125029: LD_INT 1
125031: PPUSH
125032: LD_INT 1
125034: PPUSH
125035: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
125039: LD_INT 9
125041: PPUSH
125042: LD_OWVAR 2
125046: PPUSH
125047: CALL_OW 343
// uc_side := 9 ;
125051: LD_ADDR_OWVAR 20
125055: PUSH
125056: LD_INT 9
125058: ST_TO_ADDR
// uc_nation := 2 ;
125059: LD_ADDR_OWVAR 21
125063: PUSH
125064: LD_INT 2
125066: ST_TO_ADDR
// hc_name := Dark Warrior ;
125067: LD_ADDR_OWVAR 26
125071: PUSH
125072: LD_STRING Dark Warrior
125074: ST_TO_ADDR
// hc_gallery :=  ;
125075: LD_ADDR_OWVAR 33
125079: PUSH
125080: LD_STRING 
125082: ST_TO_ADDR
// hc_noskilllimit := true ;
125083: LD_ADDR_OWVAR 76
125087: PUSH
125088: LD_INT 1
125090: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
125091: LD_ADDR_OWVAR 31
125095: PUSH
125096: LD_INT 30
125098: PUSH
125099: LD_INT 30
125101: PUSH
125102: LD_INT 30
125104: PUSH
125105: LD_INT 30
125107: PUSH
125108: EMPTY
125109: LIST
125110: LIST
125111: LIST
125112: LIST
125113: ST_TO_ADDR
// un := CreateHuman ;
125114: LD_ADDR_VAR 0 3
125118: PUSH
125119: CALL_OW 44
125123: ST_TO_ADDR
// hc_noskilllimit := false ;
125124: LD_ADDR_OWVAR 76
125128: PUSH
125129: LD_INT 0
125131: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
125132: LD_VAR 0 3
125136: PPUSH
125137: LD_INT 1
125139: PPUSH
125140: CALL_OW 51
// ToLua ( playRanger() ) ;
125144: LD_STRING playRanger()
125146: PPUSH
125147: CALL_OW 559
// p := 0 ;
125151: LD_ADDR_VAR 0 2
125155: PUSH
125156: LD_INT 0
125158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
125159: LD_INT 35
125161: PPUSH
125162: CALL_OW 67
// p := p + 1 ;
125166: LD_ADDR_VAR 0 2
125170: PUSH
125171: LD_VAR 0 2
125175: PUSH
125176: LD_INT 1
125178: PLUS
125179: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
125180: LD_VAR 0 3
125184: PPUSH
125185: CALL_OW 256
125189: PUSH
125190: LD_INT 1000
125192: LESS
125193: IFFALSE 125207
// SetLives ( un , 1000 ) ;
125195: LD_VAR 0 3
125199: PPUSH
125200: LD_INT 1000
125202: PPUSH
125203: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
125207: LD_VAR 0 3
125211: PPUSH
125212: LD_INT 81
125214: PUSH
125215: LD_OWVAR 2
125219: PUSH
125220: EMPTY
125221: LIST
125222: LIST
125223: PUSH
125224: LD_INT 91
125226: PUSH
125227: LD_VAR 0 3
125231: PUSH
125232: LD_INT 30
125234: PUSH
125235: EMPTY
125236: LIST
125237: LIST
125238: LIST
125239: PUSH
125240: EMPTY
125241: LIST
125242: LIST
125243: PPUSH
125244: CALL_OW 69
125248: PPUSH
125249: LD_VAR 0 3
125253: PPUSH
125254: CALL_OW 74
125258: PPUSH
125259: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
125263: LD_VAR 0 2
125267: PUSH
125268: LD_INT 80
125270: GREATER
125271: PUSH
125272: LD_VAR 0 3
125276: PPUSH
125277: CALL_OW 301
125281: OR
125282: IFFALSE 125159
// if un then
125284: LD_VAR 0 3
125288: IFFALSE 125299
// RemoveUnit ( un ) ;
125290: LD_VAR 0 3
125294: PPUSH
125295: CALL_OW 64
// end ;
125299: PPOPN 3
125301: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
125302: LD_EXP 202
125306: IFFALSE 125422
125308: GO 125310
125310: DISABLE
125311: LD_INT 0
125313: PPUSH
125314: PPUSH
125315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
125316: LD_ADDR_VAR 0 2
125320: PUSH
125321: LD_INT 81
125323: PUSH
125324: LD_OWVAR 2
125328: PUSH
125329: EMPTY
125330: LIST
125331: LIST
125332: PUSH
125333: LD_INT 21
125335: PUSH
125336: LD_INT 1
125338: PUSH
125339: EMPTY
125340: LIST
125341: LIST
125342: PUSH
125343: EMPTY
125344: LIST
125345: LIST
125346: PPUSH
125347: CALL_OW 69
125351: ST_TO_ADDR
// ToLua ( playComputer() ) ;
125352: LD_STRING playComputer()
125354: PPUSH
125355: CALL_OW 559
// if not tmp then
125359: LD_VAR 0 2
125363: NOT
125364: IFFALSE 125368
// exit ;
125366: GO 125422
// for i in tmp do
125368: LD_ADDR_VAR 0 1
125372: PUSH
125373: LD_VAR 0 2
125377: PUSH
125378: FOR_IN
125379: IFFALSE 125420
// for j := 1 to 4 do
125381: LD_ADDR_VAR 0 3
125385: PUSH
125386: DOUBLE
125387: LD_INT 1
125389: DEC
125390: ST_TO_ADDR
125391: LD_INT 4
125393: PUSH
125394: FOR_TO
125395: IFFALSE 125416
// SetSkill ( i , j , 10 ) ;
125397: LD_VAR 0 1
125401: PPUSH
125402: LD_VAR 0 3
125406: PPUSH
125407: LD_INT 10
125409: PPUSH
125410: CALL_OW 237
125414: GO 125394
125416: POP
125417: POP
125418: GO 125378
125420: POP
125421: POP
// end ;
125422: PPOPN 3
125424: END
// every 0 0$1 trigger s30 do var i , tmp ;
125425: LD_EXP 203
125429: IFFALSE 125498
125431: GO 125433
125433: DISABLE
125434: LD_INT 0
125436: PPUSH
125437: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125438: LD_ADDR_VAR 0 2
125442: PUSH
125443: LD_INT 22
125445: PUSH
125446: LD_OWVAR 2
125450: PUSH
125451: EMPTY
125452: LIST
125453: LIST
125454: PPUSH
125455: CALL_OW 69
125459: ST_TO_ADDR
// if not tmp then
125460: LD_VAR 0 2
125464: NOT
125465: IFFALSE 125469
// exit ;
125467: GO 125498
// for i in tmp do
125469: LD_ADDR_VAR 0 1
125473: PUSH
125474: LD_VAR 0 2
125478: PUSH
125479: FOR_IN
125480: IFFALSE 125496
// SetLives ( i , 300 ) ;
125482: LD_VAR 0 1
125486: PPUSH
125487: LD_INT 300
125489: PPUSH
125490: CALL_OW 234
125494: GO 125479
125496: POP
125497: POP
// end ;
125498: PPOPN 2
125500: END
// every 0 0$1 trigger s60 do var i , tmp ;
125501: LD_EXP 204
125505: IFFALSE 125574
125507: GO 125509
125509: DISABLE
125510: LD_INT 0
125512: PPUSH
125513: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125514: LD_ADDR_VAR 0 2
125518: PUSH
125519: LD_INT 22
125521: PUSH
125522: LD_OWVAR 2
125526: PUSH
125527: EMPTY
125528: LIST
125529: LIST
125530: PPUSH
125531: CALL_OW 69
125535: ST_TO_ADDR
// if not tmp then
125536: LD_VAR 0 2
125540: NOT
125541: IFFALSE 125545
// exit ;
125543: GO 125574
// for i in tmp do
125545: LD_ADDR_VAR 0 1
125549: PUSH
125550: LD_VAR 0 2
125554: PUSH
125555: FOR_IN
125556: IFFALSE 125572
// SetLives ( i , 600 ) ;
125558: LD_VAR 0 1
125562: PPUSH
125563: LD_INT 600
125565: PPUSH
125566: CALL_OW 234
125570: GO 125555
125572: POP
125573: POP
// end ;
125574: PPOPN 2
125576: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125577: LD_INT 0
125579: PPUSH
// case cmd of 301 :
125580: LD_VAR 0 1
125584: PUSH
125585: LD_INT 301
125587: DOUBLE
125588: EQUAL
125589: IFTRUE 125593
125591: GO 125625
125593: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125594: LD_VAR 0 6
125598: PPUSH
125599: LD_VAR 0 7
125603: PPUSH
125604: LD_VAR 0 8
125608: PPUSH
125609: LD_VAR 0 4
125613: PPUSH
125614: LD_VAR 0 5
125618: PPUSH
125619: CALL 126834 0 5
125623: GO 125746
125625: LD_INT 302
125627: DOUBLE
125628: EQUAL
125629: IFTRUE 125633
125631: GO 125670
125633: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125634: LD_VAR 0 6
125638: PPUSH
125639: LD_VAR 0 7
125643: PPUSH
125644: LD_VAR 0 8
125648: PPUSH
125649: LD_VAR 0 9
125653: PPUSH
125654: LD_VAR 0 4
125658: PPUSH
125659: LD_VAR 0 5
125663: PPUSH
125664: CALL 126925 0 6
125668: GO 125746
125670: LD_INT 303
125672: DOUBLE
125673: EQUAL
125674: IFTRUE 125678
125676: GO 125715
125678: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125679: LD_VAR 0 6
125683: PPUSH
125684: LD_VAR 0 7
125688: PPUSH
125689: LD_VAR 0 8
125693: PPUSH
125694: LD_VAR 0 9
125698: PPUSH
125699: LD_VAR 0 4
125703: PPUSH
125704: LD_VAR 0 5
125708: PPUSH
125709: CALL 125751 0 6
125713: GO 125746
125715: LD_INT 304
125717: DOUBLE
125718: EQUAL
125719: IFTRUE 125723
125721: GO 125745
125723: POP
// hHackTeleport ( unit , x , y ) ; end ;
125724: LD_VAR 0 2
125728: PPUSH
125729: LD_VAR 0 4
125733: PPUSH
125734: LD_VAR 0 5
125738: PPUSH
125739: CALL 127518 0 3
125743: GO 125746
125745: POP
// end ;
125746: LD_VAR 0 12
125750: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125751: LD_INT 0
125753: PPUSH
125754: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125755: LD_VAR 0 1
125759: PUSH
125760: LD_INT 1
125762: LESS
125763: PUSH
125764: LD_VAR 0 1
125768: PUSH
125769: LD_INT 3
125771: GREATER
125772: OR
125773: PUSH
125774: LD_VAR 0 5
125778: PPUSH
125779: LD_VAR 0 6
125783: PPUSH
125784: CALL_OW 428
125788: OR
125789: IFFALSE 125793
// exit ;
125791: GO 126521
// uc_side := your_side ;
125793: LD_ADDR_OWVAR 20
125797: PUSH
125798: LD_OWVAR 2
125802: ST_TO_ADDR
// uc_nation := nation ;
125803: LD_ADDR_OWVAR 21
125807: PUSH
125808: LD_VAR 0 1
125812: ST_TO_ADDR
// bc_level = 1 ;
125813: LD_ADDR_OWVAR 43
125817: PUSH
125818: LD_INT 1
125820: ST_TO_ADDR
// case btype of 1 :
125821: LD_VAR 0 2
125825: PUSH
125826: LD_INT 1
125828: DOUBLE
125829: EQUAL
125830: IFTRUE 125834
125832: GO 125845
125834: POP
// bc_type := b_depot ; 2 :
125835: LD_ADDR_OWVAR 42
125839: PUSH
125840: LD_INT 0
125842: ST_TO_ADDR
125843: GO 126465
125845: LD_INT 2
125847: DOUBLE
125848: EQUAL
125849: IFTRUE 125853
125851: GO 125864
125853: POP
// bc_type := b_warehouse ; 3 :
125854: LD_ADDR_OWVAR 42
125858: PUSH
125859: LD_INT 1
125861: ST_TO_ADDR
125862: GO 126465
125864: LD_INT 3
125866: DOUBLE
125867: EQUAL
125868: IFTRUE 125872
125870: GO 125883
125872: POP
// bc_type := b_lab ; 4 .. 9 :
125873: LD_ADDR_OWVAR 42
125877: PUSH
125878: LD_INT 6
125880: ST_TO_ADDR
125881: GO 126465
125883: LD_INT 4
125885: DOUBLE
125886: GREATEREQUAL
125887: IFFALSE 125895
125889: LD_INT 9
125891: DOUBLE
125892: LESSEQUAL
125893: IFTRUE 125897
125895: GO 125957
125897: POP
// begin bc_type := b_lab_half ;
125898: LD_ADDR_OWVAR 42
125902: PUSH
125903: LD_INT 7
125905: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125906: LD_ADDR_OWVAR 44
125910: PUSH
125911: LD_INT 10
125913: PUSH
125914: LD_INT 11
125916: PUSH
125917: LD_INT 12
125919: PUSH
125920: LD_INT 15
125922: PUSH
125923: LD_INT 14
125925: PUSH
125926: LD_INT 13
125928: PUSH
125929: EMPTY
125930: LIST
125931: LIST
125932: LIST
125933: LIST
125934: LIST
125935: LIST
125936: PUSH
125937: LD_VAR 0 2
125941: PUSH
125942: LD_INT 3
125944: MINUS
125945: ARRAY
125946: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125947: LD_ADDR_OWVAR 45
125951: PUSH
125952: LD_INT 9
125954: ST_TO_ADDR
// end ; 10 .. 13 :
125955: GO 126465
125957: LD_INT 10
125959: DOUBLE
125960: GREATEREQUAL
125961: IFFALSE 125969
125963: LD_INT 13
125965: DOUBLE
125966: LESSEQUAL
125967: IFTRUE 125971
125969: GO 126048
125971: POP
// begin bc_type := b_lab_full ;
125972: LD_ADDR_OWVAR 42
125976: PUSH
125977: LD_INT 8
125979: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125980: LD_ADDR_OWVAR 44
125984: PUSH
125985: LD_INT 10
125987: PUSH
125988: LD_INT 12
125990: PUSH
125991: LD_INT 14
125993: PUSH
125994: LD_INT 13
125996: PUSH
125997: EMPTY
125998: LIST
125999: LIST
126000: LIST
126001: LIST
126002: PUSH
126003: LD_VAR 0 2
126007: PUSH
126008: LD_INT 9
126010: MINUS
126011: ARRAY
126012: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
126013: LD_ADDR_OWVAR 45
126017: PUSH
126018: LD_INT 11
126020: PUSH
126021: LD_INT 15
126023: PUSH
126024: LD_INT 12
126026: PUSH
126027: LD_INT 15
126029: PUSH
126030: EMPTY
126031: LIST
126032: LIST
126033: LIST
126034: LIST
126035: PUSH
126036: LD_VAR 0 2
126040: PUSH
126041: LD_INT 9
126043: MINUS
126044: ARRAY
126045: ST_TO_ADDR
// end ; 14 :
126046: GO 126465
126048: LD_INT 14
126050: DOUBLE
126051: EQUAL
126052: IFTRUE 126056
126054: GO 126067
126056: POP
// bc_type := b_workshop ; 15 :
126057: LD_ADDR_OWVAR 42
126061: PUSH
126062: LD_INT 2
126064: ST_TO_ADDR
126065: GO 126465
126067: LD_INT 15
126069: DOUBLE
126070: EQUAL
126071: IFTRUE 126075
126073: GO 126086
126075: POP
// bc_type := b_factory ; 16 :
126076: LD_ADDR_OWVAR 42
126080: PUSH
126081: LD_INT 3
126083: ST_TO_ADDR
126084: GO 126465
126086: LD_INT 16
126088: DOUBLE
126089: EQUAL
126090: IFTRUE 126094
126092: GO 126105
126094: POP
// bc_type := b_ext_gun ; 17 :
126095: LD_ADDR_OWVAR 42
126099: PUSH
126100: LD_INT 17
126102: ST_TO_ADDR
126103: GO 126465
126105: LD_INT 17
126107: DOUBLE
126108: EQUAL
126109: IFTRUE 126113
126111: GO 126141
126113: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
126114: LD_ADDR_OWVAR 42
126118: PUSH
126119: LD_INT 19
126121: PUSH
126122: LD_INT 23
126124: PUSH
126125: LD_INT 19
126127: PUSH
126128: EMPTY
126129: LIST
126130: LIST
126131: LIST
126132: PUSH
126133: LD_VAR 0 1
126137: ARRAY
126138: ST_TO_ADDR
126139: GO 126465
126141: LD_INT 18
126143: DOUBLE
126144: EQUAL
126145: IFTRUE 126149
126147: GO 126160
126149: POP
// bc_type := b_ext_radar ; 19 :
126150: LD_ADDR_OWVAR 42
126154: PUSH
126155: LD_INT 20
126157: ST_TO_ADDR
126158: GO 126465
126160: LD_INT 19
126162: DOUBLE
126163: EQUAL
126164: IFTRUE 126168
126166: GO 126179
126168: POP
// bc_type := b_ext_radio ; 20 :
126169: LD_ADDR_OWVAR 42
126173: PUSH
126174: LD_INT 22
126176: ST_TO_ADDR
126177: GO 126465
126179: LD_INT 20
126181: DOUBLE
126182: EQUAL
126183: IFTRUE 126187
126185: GO 126198
126187: POP
// bc_type := b_ext_siberium ; 21 :
126188: LD_ADDR_OWVAR 42
126192: PUSH
126193: LD_INT 21
126195: ST_TO_ADDR
126196: GO 126465
126198: LD_INT 21
126200: DOUBLE
126201: EQUAL
126202: IFTRUE 126206
126204: GO 126217
126206: POP
// bc_type := b_ext_computer ; 22 :
126207: LD_ADDR_OWVAR 42
126211: PUSH
126212: LD_INT 24
126214: ST_TO_ADDR
126215: GO 126465
126217: LD_INT 22
126219: DOUBLE
126220: EQUAL
126221: IFTRUE 126225
126223: GO 126236
126225: POP
// bc_type := b_ext_track ; 23 :
126226: LD_ADDR_OWVAR 42
126230: PUSH
126231: LD_INT 16
126233: ST_TO_ADDR
126234: GO 126465
126236: LD_INT 23
126238: DOUBLE
126239: EQUAL
126240: IFTRUE 126244
126242: GO 126255
126244: POP
// bc_type := b_ext_laser ; 24 :
126245: LD_ADDR_OWVAR 42
126249: PUSH
126250: LD_INT 25
126252: ST_TO_ADDR
126253: GO 126465
126255: LD_INT 24
126257: DOUBLE
126258: EQUAL
126259: IFTRUE 126263
126261: GO 126274
126263: POP
// bc_type := b_control_tower ; 25 :
126264: LD_ADDR_OWVAR 42
126268: PUSH
126269: LD_INT 36
126271: ST_TO_ADDR
126272: GO 126465
126274: LD_INT 25
126276: DOUBLE
126277: EQUAL
126278: IFTRUE 126282
126280: GO 126293
126282: POP
// bc_type := b_breastwork ; 26 :
126283: LD_ADDR_OWVAR 42
126287: PUSH
126288: LD_INT 31
126290: ST_TO_ADDR
126291: GO 126465
126293: LD_INT 26
126295: DOUBLE
126296: EQUAL
126297: IFTRUE 126301
126299: GO 126312
126301: POP
// bc_type := b_bunker ; 27 :
126302: LD_ADDR_OWVAR 42
126306: PUSH
126307: LD_INT 32
126309: ST_TO_ADDR
126310: GO 126465
126312: LD_INT 27
126314: DOUBLE
126315: EQUAL
126316: IFTRUE 126320
126318: GO 126331
126320: POP
// bc_type := b_turret ; 28 :
126321: LD_ADDR_OWVAR 42
126325: PUSH
126326: LD_INT 33
126328: ST_TO_ADDR
126329: GO 126465
126331: LD_INT 28
126333: DOUBLE
126334: EQUAL
126335: IFTRUE 126339
126337: GO 126350
126339: POP
// bc_type := b_armoury ; 29 :
126340: LD_ADDR_OWVAR 42
126344: PUSH
126345: LD_INT 4
126347: ST_TO_ADDR
126348: GO 126465
126350: LD_INT 29
126352: DOUBLE
126353: EQUAL
126354: IFTRUE 126358
126356: GO 126369
126358: POP
// bc_type := b_barracks ; 30 :
126359: LD_ADDR_OWVAR 42
126363: PUSH
126364: LD_INT 5
126366: ST_TO_ADDR
126367: GO 126465
126369: LD_INT 30
126371: DOUBLE
126372: EQUAL
126373: IFTRUE 126377
126375: GO 126388
126377: POP
// bc_type := b_solar_power ; 31 :
126378: LD_ADDR_OWVAR 42
126382: PUSH
126383: LD_INT 27
126385: ST_TO_ADDR
126386: GO 126465
126388: LD_INT 31
126390: DOUBLE
126391: EQUAL
126392: IFTRUE 126396
126394: GO 126407
126396: POP
// bc_type := b_oil_power ; 32 :
126397: LD_ADDR_OWVAR 42
126401: PUSH
126402: LD_INT 26
126404: ST_TO_ADDR
126405: GO 126465
126407: LD_INT 32
126409: DOUBLE
126410: EQUAL
126411: IFTRUE 126415
126413: GO 126426
126415: POP
// bc_type := b_siberite_power ; 33 :
126416: LD_ADDR_OWVAR 42
126420: PUSH
126421: LD_INT 28
126423: ST_TO_ADDR
126424: GO 126465
126426: LD_INT 33
126428: DOUBLE
126429: EQUAL
126430: IFTRUE 126434
126432: GO 126445
126434: POP
// bc_type := b_oil_mine ; 34 :
126435: LD_ADDR_OWVAR 42
126439: PUSH
126440: LD_INT 29
126442: ST_TO_ADDR
126443: GO 126465
126445: LD_INT 34
126447: DOUBLE
126448: EQUAL
126449: IFTRUE 126453
126451: GO 126464
126453: POP
// bc_type := b_siberite_mine ; end ;
126454: LD_ADDR_OWVAR 42
126458: PUSH
126459: LD_INT 30
126461: ST_TO_ADDR
126462: GO 126465
126464: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
126465: LD_ADDR_VAR 0 8
126469: PUSH
126470: LD_VAR 0 5
126474: PPUSH
126475: LD_VAR 0 6
126479: PPUSH
126480: LD_VAR 0 3
126484: PPUSH
126485: CALL_OW 47
126489: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
126490: LD_OWVAR 42
126494: PUSH
126495: LD_INT 32
126497: PUSH
126498: LD_INT 33
126500: PUSH
126501: EMPTY
126502: LIST
126503: LIST
126504: IN
126505: IFFALSE 126521
// PlaceWeaponTurret ( b , weapon ) ;
126507: LD_VAR 0 8
126511: PPUSH
126512: LD_VAR 0 4
126516: PPUSH
126517: CALL_OW 431
// end ;
126521: LD_VAR 0 7
126525: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
126526: LD_INT 0
126528: PPUSH
126529: PPUSH
126530: PPUSH
126531: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
126532: LD_ADDR_VAR 0 4
126536: PUSH
126537: LD_INT 22
126539: PUSH
126540: LD_OWVAR 2
126544: PUSH
126545: EMPTY
126546: LIST
126547: LIST
126548: PUSH
126549: LD_INT 2
126551: PUSH
126552: LD_INT 30
126554: PUSH
126555: LD_INT 0
126557: PUSH
126558: EMPTY
126559: LIST
126560: LIST
126561: PUSH
126562: LD_INT 30
126564: PUSH
126565: LD_INT 1
126567: PUSH
126568: EMPTY
126569: LIST
126570: LIST
126571: PUSH
126572: EMPTY
126573: LIST
126574: LIST
126575: LIST
126576: PUSH
126577: EMPTY
126578: LIST
126579: LIST
126580: PPUSH
126581: CALL_OW 69
126585: ST_TO_ADDR
// if not tmp then
126586: LD_VAR 0 4
126590: NOT
126591: IFFALSE 126595
// exit ;
126593: GO 126654
// for i in tmp do
126595: LD_ADDR_VAR 0 2
126599: PUSH
126600: LD_VAR 0 4
126604: PUSH
126605: FOR_IN
126606: IFFALSE 126652
// for j = 1 to 3 do
126608: LD_ADDR_VAR 0 3
126612: PUSH
126613: DOUBLE
126614: LD_INT 1
126616: DEC
126617: ST_TO_ADDR
126618: LD_INT 3
126620: PUSH
126621: FOR_TO
126622: IFFALSE 126648
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126624: LD_VAR 0 2
126628: PPUSH
126629: CALL_OW 274
126633: PPUSH
126634: LD_VAR 0 3
126638: PPUSH
126639: LD_INT 99999
126641: PPUSH
126642: CALL_OW 277
126646: GO 126621
126648: POP
126649: POP
126650: GO 126605
126652: POP
126653: POP
// end ;
126654: LD_VAR 0 1
126658: RET
// export function hHackSetLevel10 ; var i , j ; begin
126659: LD_INT 0
126661: PPUSH
126662: PPUSH
126663: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126664: LD_ADDR_VAR 0 2
126668: PUSH
126669: LD_INT 21
126671: PUSH
126672: LD_INT 1
126674: PUSH
126675: EMPTY
126676: LIST
126677: LIST
126678: PPUSH
126679: CALL_OW 69
126683: PUSH
126684: FOR_IN
126685: IFFALSE 126737
// if IsSelected ( i ) then
126687: LD_VAR 0 2
126691: PPUSH
126692: CALL_OW 306
126696: IFFALSE 126735
// begin for j := 1 to 4 do
126698: LD_ADDR_VAR 0 3
126702: PUSH
126703: DOUBLE
126704: LD_INT 1
126706: DEC
126707: ST_TO_ADDR
126708: LD_INT 4
126710: PUSH
126711: FOR_TO
126712: IFFALSE 126733
// SetSkill ( i , j , 10 ) ;
126714: LD_VAR 0 2
126718: PPUSH
126719: LD_VAR 0 3
126723: PPUSH
126724: LD_INT 10
126726: PPUSH
126727: CALL_OW 237
126731: GO 126711
126733: POP
126734: POP
// end ;
126735: GO 126684
126737: POP
126738: POP
// end ;
126739: LD_VAR 0 1
126743: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126744: LD_INT 0
126746: PPUSH
126747: PPUSH
126748: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126749: LD_ADDR_VAR 0 2
126753: PUSH
126754: LD_INT 22
126756: PUSH
126757: LD_OWVAR 2
126761: PUSH
126762: EMPTY
126763: LIST
126764: LIST
126765: PUSH
126766: LD_INT 21
126768: PUSH
126769: LD_INT 1
126771: PUSH
126772: EMPTY
126773: LIST
126774: LIST
126775: PUSH
126776: EMPTY
126777: LIST
126778: LIST
126779: PPUSH
126780: CALL_OW 69
126784: PUSH
126785: FOR_IN
126786: IFFALSE 126827
// begin for j := 1 to 4 do
126788: LD_ADDR_VAR 0 3
126792: PUSH
126793: DOUBLE
126794: LD_INT 1
126796: DEC
126797: ST_TO_ADDR
126798: LD_INT 4
126800: PUSH
126801: FOR_TO
126802: IFFALSE 126823
// SetSkill ( i , j , 10 ) ;
126804: LD_VAR 0 2
126808: PPUSH
126809: LD_VAR 0 3
126813: PPUSH
126814: LD_INT 10
126816: PPUSH
126817: CALL_OW 237
126821: GO 126801
126823: POP
126824: POP
// end ;
126825: GO 126785
126827: POP
126828: POP
// end ;
126829: LD_VAR 0 1
126833: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126834: LD_INT 0
126836: PPUSH
// uc_side := your_side ;
126837: LD_ADDR_OWVAR 20
126841: PUSH
126842: LD_OWVAR 2
126846: ST_TO_ADDR
// uc_nation := nation ;
126847: LD_ADDR_OWVAR 21
126851: PUSH
126852: LD_VAR 0 1
126856: ST_TO_ADDR
// InitHc ;
126857: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126861: LD_INT 0
126863: PPUSH
126864: LD_VAR 0 2
126868: PPUSH
126869: LD_VAR 0 3
126873: PPUSH
126874: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126878: LD_VAR 0 4
126882: PPUSH
126883: LD_VAR 0 5
126887: PPUSH
126888: CALL_OW 428
126892: PUSH
126893: LD_INT 0
126895: EQUAL
126896: IFFALSE 126920
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126898: CALL_OW 44
126902: PPUSH
126903: LD_VAR 0 4
126907: PPUSH
126908: LD_VAR 0 5
126912: PPUSH
126913: LD_INT 1
126915: PPUSH
126916: CALL_OW 48
// end ;
126920: LD_VAR 0 6
126924: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126925: LD_INT 0
126927: PPUSH
126928: PPUSH
// uc_side := your_side ;
126929: LD_ADDR_OWVAR 20
126933: PUSH
126934: LD_OWVAR 2
126938: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126939: LD_VAR 0 1
126943: PUSH
126944: LD_INT 1
126946: PUSH
126947: LD_INT 2
126949: PUSH
126950: LD_INT 3
126952: PUSH
126953: LD_INT 4
126955: PUSH
126956: LD_INT 5
126958: PUSH
126959: EMPTY
126960: LIST
126961: LIST
126962: LIST
126963: LIST
126964: LIST
126965: IN
126966: IFFALSE 126978
// uc_nation := nation_american else
126968: LD_ADDR_OWVAR 21
126972: PUSH
126973: LD_INT 1
126975: ST_TO_ADDR
126976: GO 127021
// if chassis in [ 11 , 12 , 13 , 14 ] then
126978: LD_VAR 0 1
126982: PUSH
126983: LD_INT 11
126985: PUSH
126986: LD_INT 12
126988: PUSH
126989: LD_INT 13
126991: PUSH
126992: LD_INT 14
126994: PUSH
126995: EMPTY
126996: LIST
126997: LIST
126998: LIST
126999: LIST
127000: IN
127001: IFFALSE 127013
// uc_nation := nation_arabian else
127003: LD_ADDR_OWVAR 21
127007: PUSH
127008: LD_INT 2
127010: ST_TO_ADDR
127011: GO 127021
// uc_nation := nation_russian ;
127013: LD_ADDR_OWVAR 21
127017: PUSH
127018: LD_INT 3
127020: ST_TO_ADDR
// vc_chassis := chassis ;
127021: LD_ADDR_OWVAR 37
127025: PUSH
127026: LD_VAR 0 1
127030: ST_TO_ADDR
// vc_engine := engine ;
127031: LD_ADDR_OWVAR 39
127035: PUSH
127036: LD_VAR 0 2
127040: ST_TO_ADDR
// vc_control := control ;
127041: LD_ADDR_OWVAR 38
127045: PUSH
127046: LD_VAR 0 3
127050: ST_TO_ADDR
// vc_weapon := weapon ;
127051: LD_ADDR_OWVAR 40
127055: PUSH
127056: LD_VAR 0 4
127060: ST_TO_ADDR
// un := CreateVehicle ;
127061: LD_ADDR_VAR 0 8
127065: PUSH
127066: CALL_OW 45
127070: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
127071: LD_VAR 0 8
127075: PPUSH
127076: LD_INT 0
127078: PPUSH
127079: LD_INT 5
127081: PPUSH
127082: CALL_OW 12
127086: PPUSH
127087: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
127091: LD_VAR 0 8
127095: PPUSH
127096: LD_VAR 0 5
127100: PPUSH
127101: LD_VAR 0 6
127105: PPUSH
127106: LD_INT 1
127108: PPUSH
127109: CALL_OW 48
// end ;
127113: LD_VAR 0 7
127117: RET
// export hInvincible ; every 1 do
127118: GO 127120
127120: DISABLE
// hInvincible := [ ] ;
127121: LD_ADDR_EXP 205
127125: PUSH
127126: EMPTY
127127: ST_TO_ADDR
127128: END
// every 10 do var i ;
127129: GO 127131
127131: DISABLE
127132: LD_INT 0
127134: PPUSH
// begin enable ;
127135: ENABLE
// if not hInvincible then
127136: LD_EXP 205
127140: NOT
127141: IFFALSE 127145
// exit ;
127143: GO 127189
// for i in hInvincible do
127145: LD_ADDR_VAR 0 1
127149: PUSH
127150: LD_EXP 205
127154: PUSH
127155: FOR_IN
127156: IFFALSE 127187
// if GetLives ( i ) < 1000 then
127158: LD_VAR 0 1
127162: PPUSH
127163: CALL_OW 256
127167: PUSH
127168: LD_INT 1000
127170: LESS
127171: IFFALSE 127185
// SetLives ( i , 1000 ) ;
127173: LD_VAR 0 1
127177: PPUSH
127178: LD_INT 1000
127180: PPUSH
127181: CALL_OW 234
127185: GO 127155
127187: POP
127188: POP
// end ;
127189: PPOPN 1
127191: END
// export function hHackInvincible ; var i ; begin
127192: LD_INT 0
127194: PPUSH
127195: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
127196: LD_ADDR_VAR 0 2
127200: PUSH
127201: LD_INT 2
127203: PUSH
127204: LD_INT 21
127206: PUSH
127207: LD_INT 1
127209: PUSH
127210: EMPTY
127211: LIST
127212: LIST
127213: PUSH
127214: LD_INT 21
127216: PUSH
127217: LD_INT 2
127219: PUSH
127220: EMPTY
127221: LIST
127222: LIST
127223: PUSH
127224: EMPTY
127225: LIST
127226: LIST
127227: LIST
127228: PPUSH
127229: CALL_OW 69
127233: PUSH
127234: FOR_IN
127235: IFFALSE 127296
// if IsSelected ( i ) then
127237: LD_VAR 0 2
127241: PPUSH
127242: CALL_OW 306
127246: IFFALSE 127294
// begin if i in hInvincible then
127248: LD_VAR 0 2
127252: PUSH
127253: LD_EXP 205
127257: IN
127258: IFFALSE 127278
// hInvincible := hInvincible diff i else
127260: LD_ADDR_EXP 205
127264: PUSH
127265: LD_EXP 205
127269: PUSH
127270: LD_VAR 0 2
127274: DIFF
127275: ST_TO_ADDR
127276: GO 127294
// hInvincible := hInvincible union i ;
127278: LD_ADDR_EXP 205
127282: PUSH
127283: LD_EXP 205
127287: PUSH
127288: LD_VAR 0 2
127292: UNION
127293: ST_TO_ADDR
// end ;
127294: GO 127234
127296: POP
127297: POP
// end ;
127298: LD_VAR 0 1
127302: RET
// export function hHackInvisible ; var i , j ; begin
127303: LD_INT 0
127305: PPUSH
127306: PPUSH
127307: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
127308: LD_ADDR_VAR 0 2
127312: PUSH
127313: LD_INT 21
127315: PUSH
127316: LD_INT 1
127318: PUSH
127319: EMPTY
127320: LIST
127321: LIST
127322: PPUSH
127323: CALL_OW 69
127327: PUSH
127328: FOR_IN
127329: IFFALSE 127353
// if IsSelected ( i ) then
127331: LD_VAR 0 2
127335: PPUSH
127336: CALL_OW 306
127340: IFFALSE 127351
// ComForceInvisible ( i ) ;
127342: LD_VAR 0 2
127346: PPUSH
127347: CALL_OW 496
127351: GO 127328
127353: POP
127354: POP
// end ;
127355: LD_VAR 0 1
127359: RET
// export function hHackChangeYourSide ; begin
127360: LD_INT 0
127362: PPUSH
// if your_side = 8 then
127363: LD_OWVAR 2
127367: PUSH
127368: LD_INT 8
127370: EQUAL
127371: IFFALSE 127383
// your_side := 0 else
127373: LD_ADDR_OWVAR 2
127377: PUSH
127378: LD_INT 0
127380: ST_TO_ADDR
127381: GO 127397
// your_side := your_side + 1 ;
127383: LD_ADDR_OWVAR 2
127387: PUSH
127388: LD_OWVAR 2
127392: PUSH
127393: LD_INT 1
127395: PLUS
127396: ST_TO_ADDR
// end ;
127397: LD_VAR 0 1
127401: RET
// export function hHackChangeUnitSide ; var i , j ; begin
127402: LD_INT 0
127404: PPUSH
127405: PPUSH
127406: PPUSH
// for i in all_units do
127407: LD_ADDR_VAR 0 2
127411: PUSH
127412: LD_OWVAR 3
127416: PUSH
127417: FOR_IN
127418: IFFALSE 127496
// if IsSelected ( i ) then
127420: LD_VAR 0 2
127424: PPUSH
127425: CALL_OW 306
127429: IFFALSE 127494
// begin j := GetSide ( i ) ;
127431: LD_ADDR_VAR 0 3
127435: PUSH
127436: LD_VAR 0 2
127440: PPUSH
127441: CALL_OW 255
127445: ST_TO_ADDR
// if j = 8 then
127446: LD_VAR 0 3
127450: PUSH
127451: LD_INT 8
127453: EQUAL
127454: IFFALSE 127466
// j := 0 else
127456: LD_ADDR_VAR 0 3
127460: PUSH
127461: LD_INT 0
127463: ST_TO_ADDR
127464: GO 127480
// j := j + 1 ;
127466: LD_ADDR_VAR 0 3
127470: PUSH
127471: LD_VAR 0 3
127475: PUSH
127476: LD_INT 1
127478: PLUS
127479: ST_TO_ADDR
// SetSide ( i , j ) ;
127480: LD_VAR 0 2
127484: PPUSH
127485: LD_VAR 0 3
127489: PPUSH
127490: CALL_OW 235
// end ;
127494: GO 127417
127496: POP
127497: POP
// end ;
127498: LD_VAR 0 1
127502: RET
// export function hHackFog ; begin
127503: LD_INT 0
127505: PPUSH
// FogOff ( true ) ;
127506: LD_INT 1
127508: PPUSH
127509: CALL_OW 344
// end ;
127513: LD_VAR 0 1
127517: RET
// export function hHackTeleport ( unit , x , y ) ; begin
127518: LD_INT 0
127520: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
127521: LD_VAR 0 1
127525: PPUSH
127526: LD_VAR 0 2
127530: PPUSH
127531: LD_VAR 0 3
127535: PPUSH
127536: LD_INT 1
127538: PPUSH
127539: LD_INT 1
127541: PPUSH
127542: CALL_OW 483
// CenterOnXY ( x , y ) ;
127546: LD_VAR 0 2
127550: PPUSH
127551: LD_VAR 0 3
127555: PPUSH
127556: CALL_OW 84
// end ;
127560: LD_VAR 0 4
127564: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
127565: LD_INT 0
127567: PPUSH
127568: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127569: LD_VAR 0 1
127573: NOT
127574: PUSH
127575: LD_VAR 0 2
127579: PPUSH
127580: LD_VAR 0 3
127584: PPUSH
127585: CALL_OW 488
127589: NOT
127590: OR
127591: PUSH
127592: LD_VAR 0 1
127596: PPUSH
127597: CALL_OW 266
127601: PUSH
127602: LD_INT 3
127604: NONEQUAL
127605: PUSH
127606: LD_VAR 0 1
127610: PPUSH
127611: CALL_OW 247
127615: PUSH
127616: LD_INT 1
127618: EQUAL
127619: NOT
127620: AND
127621: OR
127622: IFFALSE 127626
// exit ;
127624: GO 127775
// if GetType ( factory ) = unit_human then
127626: LD_VAR 0 1
127630: PPUSH
127631: CALL_OW 247
127635: PUSH
127636: LD_INT 1
127638: EQUAL
127639: IFFALSE 127656
// factory := IsInUnit ( factory ) ;
127641: LD_ADDR_VAR 0 1
127645: PUSH
127646: LD_VAR 0 1
127650: PPUSH
127651: CALL_OW 310
127655: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127656: LD_VAR 0 1
127660: PPUSH
127661: CALL_OW 266
127665: PUSH
127666: LD_INT 3
127668: NONEQUAL
127669: IFFALSE 127673
// exit ;
127671: GO 127775
// if HexInfo ( x , y ) = factory then
127673: LD_VAR 0 2
127677: PPUSH
127678: LD_VAR 0 3
127682: PPUSH
127683: CALL_OW 428
127687: PUSH
127688: LD_VAR 0 1
127692: EQUAL
127693: IFFALSE 127720
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
127695: LD_ADDR_EXP 206
127699: PUSH
127700: LD_EXP 206
127704: PPUSH
127705: LD_VAR 0 1
127709: PPUSH
127710: LD_INT 0
127712: PPUSH
127713: CALL_OW 1
127717: ST_TO_ADDR
127718: GO 127771
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
127720: LD_ADDR_EXP 206
127724: PUSH
127725: LD_EXP 206
127729: PPUSH
127730: LD_VAR 0 1
127734: PPUSH
127735: LD_VAR 0 1
127739: PPUSH
127740: CALL_OW 255
127744: PUSH
127745: LD_VAR 0 1
127749: PUSH
127750: LD_VAR 0 2
127754: PUSH
127755: LD_VAR 0 3
127759: PUSH
127760: EMPTY
127761: LIST
127762: LIST
127763: LIST
127764: LIST
127765: PPUSH
127766: CALL_OW 1
127770: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127771: CALL 127780 0 0
// end ;
127775: LD_VAR 0 4
127779: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127780: LD_INT 0
127782: PPUSH
127783: PPUSH
127784: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127785: LD_STRING resetFactoryWaypoint();
127787: PPUSH
127788: CALL_OW 559
// if factoryWaypoints then
127792: LD_EXP 206
127796: IFFALSE 127922
// begin list := PrepareArray ( factoryWaypoints ) ;
127798: LD_ADDR_VAR 0 3
127802: PUSH
127803: LD_EXP 206
127807: PPUSH
127808: CALL 111735 0 1
127812: ST_TO_ADDR
// for i := 1 to list do
127813: LD_ADDR_VAR 0 2
127817: PUSH
127818: DOUBLE
127819: LD_INT 1
127821: DEC
127822: ST_TO_ADDR
127823: LD_VAR 0 3
127827: PUSH
127828: FOR_TO
127829: IFFALSE 127920
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127831: LD_STRING setFactoryWaypointXY(
127833: PUSH
127834: LD_VAR 0 3
127838: PUSH
127839: LD_VAR 0 2
127843: ARRAY
127844: PUSH
127845: LD_INT 1
127847: ARRAY
127848: STR
127849: PUSH
127850: LD_STRING ,
127852: STR
127853: PUSH
127854: LD_VAR 0 3
127858: PUSH
127859: LD_VAR 0 2
127863: ARRAY
127864: PUSH
127865: LD_INT 2
127867: ARRAY
127868: STR
127869: PUSH
127870: LD_STRING ,
127872: STR
127873: PUSH
127874: LD_VAR 0 3
127878: PUSH
127879: LD_VAR 0 2
127883: ARRAY
127884: PUSH
127885: LD_INT 3
127887: ARRAY
127888: STR
127889: PUSH
127890: LD_STRING ,
127892: STR
127893: PUSH
127894: LD_VAR 0 3
127898: PUSH
127899: LD_VAR 0 2
127903: ARRAY
127904: PUSH
127905: LD_INT 4
127907: ARRAY
127908: STR
127909: PUSH
127910: LD_STRING )
127912: STR
127913: PPUSH
127914: CALL_OW 559
127918: GO 127828
127920: POP
127921: POP
// end ; end ;
127922: LD_VAR 0 1
127926: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127927: LD_INT 0
127929: PPUSH
// if HexInfo ( x , y ) = warehouse then
127930: LD_VAR 0 2
127934: PPUSH
127935: LD_VAR 0 3
127939: PPUSH
127940: CALL_OW 428
127944: PUSH
127945: LD_VAR 0 1
127949: EQUAL
127950: IFFALSE 127977
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127952: LD_ADDR_EXP 207
127956: PUSH
127957: LD_EXP 207
127961: PPUSH
127962: LD_VAR 0 1
127966: PPUSH
127967: LD_INT 0
127969: PPUSH
127970: CALL_OW 1
127974: ST_TO_ADDR
127975: GO 128028
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127977: LD_ADDR_EXP 207
127981: PUSH
127982: LD_EXP 207
127986: PPUSH
127987: LD_VAR 0 1
127991: PPUSH
127992: LD_VAR 0 1
127996: PPUSH
127997: CALL_OW 255
128001: PUSH
128002: LD_VAR 0 1
128006: PUSH
128007: LD_VAR 0 2
128011: PUSH
128012: LD_VAR 0 3
128016: PUSH
128017: EMPTY
128018: LIST
128019: LIST
128020: LIST
128021: LIST
128022: PPUSH
128023: CALL_OW 1
128027: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
128028: CALL 128037 0 0
// end ;
128032: LD_VAR 0 4
128036: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
128037: LD_INT 0
128039: PPUSH
128040: PPUSH
128041: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
128042: LD_STRING resetWarehouseGatheringPoints();
128044: PPUSH
128045: CALL_OW 559
// if warehouseGatheringPoints then
128049: LD_EXP 207
128053: IFFALSE 128179
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
128055: LD_ADDR_VAR 0 3
128059: PUSH
128060: LD_EXP 207
128064: PPUSH
128065: CALL 111735 0 1
128069: ST_TO_ADDR
// for i := 1 to list do
128070: LD_ADDR_VAR 0 2
128074: PUSH
128075: DOUBLE
128076: LD_INT 1
128078: DEC
128079: ST_TO_ADDR
128080: LD_VAR 0 3
128084: PUSH
128085: FOR_TO
128086: IFFALSE 128177
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128088: LD_STRING setWarehouseGatheringPointXY(
128090: PUSH
128091: LD_VAR 0 3
128095: PUSH
128096: LD_VAR 0 2
128100: ARRAY
128101: PUSH
128102: LD_INT 1
128104: ARRAY
128105: STR
128106: PUSH
128107: LD_STRING ,
128109: STR
128110: PUSH
128111: LD_VAR 0 3
128115: PUSH
128116: LD_VAR 0 2
128120: ARRAY
128121: PUSH
128122: LD_INT 2
128124: ARRAY
128125: STR
128126: PUSH
128127: LD_STRING ,
128129: STR
128130: PUSH
128131: LD_VAR 0 3
128135: PUSH
128136: LD_VAR 0 2
128140: ARRAY
128141: PUSH
128142: LD_INT 3
128144: ARRAY
128145: STR
128146: PUSH
128147: LD_STRING ,
128149: STR
128150: PUSH
128151: LD_VAR 0 3
128155: PUSH
128156: LD_VAR 0 2
128160: ARRAY
128161: PUSH
128162: LD_INT 4
128164: ARRAY
128165: STR
128166: PUSH
128167: LD_STRING )
128169: STR
128170: PPUSH
128171: CALL_OW 559
128175: GO 128085
128177: POP
128178: POP
// end ; end ;
128179: LD_VAR 0 1
128183: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
128184: LD_EXP 207
128188: IFFALSE 128873
128190: GO 128192
128192: DISABLE
128193: LD_INT 0
128195: PPUSH
128196: PPUSH
128197: PPUSH
128198: PPUSH
128199: PPUSH
128200: PPUSH
128201: PPUSH
128202: PPUSH
128203: PPUSH
// begin enable ;
128204: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
128205: LD_ADDR_VAR 0 3
128209: PUSH
128210: LD_EXP 207
128214: PPUSH
128215: CALL 111735 0 1
128219: ST_TO_ADDR
// if not list then
128220: LD_VAR 0 3
128224: NOT
128225: IFFALSE 128229
// exit ;
128227: GO 128873
// for i := 1 to list do
128229: LD_ADDR_VAR 0 1
128233: PUSH
128234: DOUBLE
128235: LD_INT 1
128237: DEC
128238: ST_TO_ADDR
128239: LD_VAR 0 3
128243: PUSH
128244: FOR_TO
128245: IFFALSE 128871
// begin depot := list [ i ] [ 2 ] ;
128247: LD_ADDR_VAR 0 8
128251: PUSH
128252: LD_VAR 0 3
128256: PUSH
128257: LD_VAR 0 1
128261: ARRAY
128262: PUSH
128263: LD_INT 2
128265: ARRAY
128266: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
128267: LD_ADDR_VAR 0 5
128271: PUSH
128272: LD_VAR 0 3
128276: PUSH
128277: LD_VAR 0 1
128281: ARRAY
128282: PUSH
128283: LD_INT 1
128285: ARRAY
128286: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
128287: LD_VAR 0 8
128291: PPUSH
128292: CALL_OW 301
128296: PUSH
128297: LD_VAR 0 5
128301: PUSH
128302: LD_VAR 0 8
128306: PPUSH
128307: CALL_OW 255
128311: NONEQUAL
128312: OR
128313: IFFALSE 128342
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
128315: LD_ADDR_EXP 207
128319: PUSH
128320: LD_EXP 207
128324: PPUSH
128325: LD_VAR 0 8
128329: PPUSH
128330: LD_INT 0
128332: PPUSH
128333: CALL_OW 1
128337: ST_TO_ADDR
// exit ;
128338: POP
128339: POP
128340: GO 128873
// end ; x := list [ i ] [ 3 ] ;
128342: LD_ADDR_VAR 0 6
128346: PUSH
128347: LD_VAR 0 3
128351: PUSH
128352: LD_VAR 0 1
128356: ARRAY
128357: PUSH
128358: LD_INT 3
128360: ARRAY
128361: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
128362: LD_ADDR_VAR 0 7
128366: PUSH
128367: LD_VAR 0 3
128371: PUSH
128372: LD_VAR 0 1
128376: ARRAY
128377: PUSH
128378: LD_INT 4
128380: ARRAY
128381: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
128382: LD_ADDR_VAR 0 9
128386: PUSH
128387: LD_VAR 0 6
128391: PPUSH
128392: LD_VAR 0 7
128396: PPUSH
128397: LD_INT 16
128399: PPUSH
128400: CALL 110319 0 3
128404: ST_TO_ADDR
// if not cratesNearbyPoint then
128405: LD_VAR 0 9
128409: NOT
128410: IFFALSE 128416
// exit ;
128412: POP
128413: POP
128414: GO 128873
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
128416: LD_ADDR_VAR 0 4
128420: PUSH
128421: LD_INT 22
128423: PUSH
128424: LD_VAR 0 5
128428: PUSH
128429: EMPTY
128430: LIST
128431: LIST
128432: PUSH
128433: LD_INT 3
128435: PUSH
128436: LD_INT 60
128438: PUSH
128439: EMPTY
128440: LIST
128441: PUSH
128442: EMPTY
128443: LIST
128444: LIST
128445: PUSH
128446: LD_INT 91
128448: PUSH
128449: LD_VAR 0 8
128453: PUSH
128454: LD_INT 6
128456: PUSH
128457: EMPTY
128458: LIST
128459: LIST
128460: LIST
128461: PUSH
128462: LD_INT 2
128464: PUSH
128465: LD_INT 25
128467: PUSH
128468: LD_INT 2
128470: PUSH
128471: EMPTY
128472: LIST
128473: LIST
128474: PUSH
128475: LD_INT 25
128477: PUSH
128478: LD_INT 16
128480: PUSH
128481: EMPTY
128482: LIST
128483: LIST
128484: PUSH
128485: EMPTY
128486: LIST
128487: LIST
128488: LIST
128489: PUSH
128490: EMPTY
128491: LIST
128492: LIST
128493: LIST
128494: LIST
128495: PPUSH
128496: CALL_OW 69
128500: PUSH
128501: LD_VAR 0 8
128505: PPUSH
128506: CALL_OW 313
128510: PPUSH
128511: LD_INT 3
128513: PUSH
128514: LD_INT 60
128516: PUSH
128517: EMPTY
128518: LIST
128519: PUSH
128520: EMPTY
128521: LIST
128522: LIST
128523: PUSH
128524: LD_INT 2
128526: PUSH
128527: LD_INT 25
128529: PUSH
128530: LD_INT 2
128532: PUSH
128533: EMPTY
128534: LIST
128535: LIST
128536: PUSH
128537: LD_INT 25
128539: PUSH
128540: LD_INT 16
128542: PUSH
128543: EMPTY
128544: LIST
128545: LIST
128546: PUSH
128547: EMPTY
128548: LIST
128549: LIST
128550: LIST
128551: PUSH
128552: EMPTY
128553: LIST
128554: LIST
128555: PPUSH
128556: CALL_OW 72
128560: UNION
128561: ST_TO_ADDR
// if tmp then
128562: LD_VAR 0 4
128566: IFFALSE 128646
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128568: LD_ADDR_VAR 0 4
128572: PUSH
128573: LD_VAR 0 4
128577: PPUSH
128578: LD_INT 3
128580: PPUSH
128581: CALL 108288 0 2
128585: ST_TO_ADDR
// for j in tmp do
128586: LD_ADDR_VAR 0 2
128590: PUSH
128591: LD_VAR 0 4
128595: PUSH
128596: FOR_IN
128597: IFFALSE 128640
// begin if IsInUnit ( j ) then
128599: LD_VAR 0 2
128603: PPUSH
128604: CALL_OW 310
128608: IFFALSE 128619
// ComExit ( j ) ;
128610: LD_VAR 0 2
128614: PPUSH
128615: CALL 108371 0 1
// AddComCollect ( j , x , y ) ;
128619: LD_VAR 0 2
128623: PPUSH
128624: LD_VAR 0 6
128628: PPUSH
128629: LD_VAR 0 7
128633: PPUSH
128634: CALL_OW 177
// end ;
128638: GO 128596
128640: POP
128641: POP
// exit ;
128642: POP
128643: POP
128644: GO 128873
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128646: LD_ADDR_VAR 0 4
128650: PUSH
128651: LD_INT 22
128653: PUSH
128654: LD_VAR 0 5
128658: PUSH
128659: EMPTY
128660: LIST
128661: LIST
128662: PUSH
128663: LD_INT 91
128665: PUSH
128666: LD_VAR 0 8
128670: PUSH
128671: LD_INT 8
128673: PUSH
128674: EMPTY
128675: LIST
128676: LIST
128677: LIST
128678: PUSH
128679: LD_INT 2
128681: PUSH
128682: LD_INT 34
128684: PUSH
128685: LD_INT 12
128687: PUSH
128688: EMPTY
128689: LIST
128690: LIST
128691: PUSH
128692: LD_INT 34
128694: PUSH
128695: LD_INT 51
128697: PUSH
128698: EMPTY
128699: LIST
128700: LIST
128701: PUSH
128702: LD_INT 34
128704: PUSH
128705: LD_INT 32
128707: PUSH
128708: EMPTY
128709: LIST
128710: LIST
128711: PUSH
128712: LD_INT 34
128714: PUSH
128715: LD_INT 89
128717: PUSH
128718: EMPTY
128719: LIST
128720: LIST
128721: PUSH
128722: EMPTY
128723: LIST
128724: LIST
128725: LIST
128726: LIST
128727: LIST
128728: PUSH
128729: EMPTY
128730: LIST
128731: LIST
128732: LIST
128733: PPUSH
128734: CALL_OW 69
128738: ST_TO_ADDR
// if tmp then
128739: LD_VAR 0 4
128743: IFFALSE 128869
// begin for j in tmp do
128745: LD_ADDR_VAR 0 2
128749: PUSH
128750: LD_VAR 0 4
128754: PUSH
128755: FOR_IN
128756: IFFALSE 128867
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128758: LD_VAR 0 2
128762: PPUSH
128763: CALL_OW 262
128767: PUSH
128768: LD_INT 3
128770: EQUAL
128771: PUSH
128772: LD_VAR 0 2
128776: PPUSH
128777: CALL_OW 261
128781: PUSH
128782: LD_INT 20
128784: GREATER
128785: OR
128786: PUSH
128787: LD_VAR 0 2
128791: PPUSH
128792: CALL_OW 314
128796: NOT
128797: AND
128798: PUSH
128799: LD_VAR 0 2
128803: PPUSH
128804: CALL_OW 263
128808: PUSH
128809: LD_INT 1
128811: NONEQUAL
128812: PUSH
128813: LD_VAR 0 2
128817: PPUSH
128818: CALL_OW 311
128822: OR
128823: AND
128824: IFFALSE 128865
// begin ComCollect ( j , x , y ) ;
128826: LD_VAR 0 2
128830: PPUSH
128831: LD_VAR 0 6
128835: PPUSH
128836: LD_VAR 0 7
128840: PPUSH
128841: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128845: LD_VAR 0 2
128849: PPUSH
128850: LD_VAR 0 8
128854: PPUSH
128855: CALL_OW 172
// exit ;
128859: POP
128860: POP
128861: POP
128862: POP
128863: GO 128873
// end ;
128865: GO 128755
128867: POP
128868: POP
// end ; end ;
128869: GO 128244
128871: POP
128872: POP
// end ; end_of_file
128873: PPOPN 9
128875: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
128876: LD_INT 0
128878: PPUSH
128879: PPUSH
128880: PPUSH
128881: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
128882: LD_VAR 0 1
128886: PPUSH
128887: CALL_OW 264
128891: PUSH
128892: LD_INT 91
128894: EQUAL
128895: IFFALSE 128967
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
128897: LD_INT 68
128899: PPUSH
128900: LD_VAR 0 1
128904: PPUSH
128905: CALL_OW 255
128909: PPUSH
128910: CALL_OW 321
128914: PUSH
128915: LD_INT 2
128917: EQUAL
128918: IFFALSE 128930
// eff := 70 else
128920: LD_ADDR_VAR 0 4
128924: PUSH
128925: LD_INT 70
128927: ST_TO_ADDR
128928: GO 128938
// eff := 30 ;
128930: LD_ADDR_VAR 0 4
128934: PUSH
128935: LD_INT 30
128937: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
128938: LD_VAR 0 1
128942: PPUSH
128943: CALL_OW 250
128947: PPUSH
128948: LD_VAR 0 1
128952: PPUSH
128953: CALL_OW 251
128957: PPUSH
128958: LD_VAR 0 4
128962: PPUSH
128963: CALL_OW 495
// end ; end ;
128967: LD_VAR 0 2
128971: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128972: LD_INT 0
128974: PPUSH
// end ;
128975: LD_VAR 0 4
128979: RET
// export function SOS_Command ( cmd ) ; begin
128980: LD_INT 0
128982: PPUSH
// end ;
128983: LD_VAR 0 2
128987: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128988: LD_INT 0
128990: PPUSH
// end ;
128991: LD_VAR 0 6
128995: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
128996: LD_INT 0
128998: PPUSH
128999: PPUSH
// if not vehicle or not factory then
129000: LD_VAR 0 1
129004: NOT
129005: PUSH
129006: LD_VAR 0 2
129010: NOT
129011: OR
129012: IFFALSE 129016
// exit ;
129014: GO 129259
// if factoryWaypoints >= factory then
129016: LD_EXP 206
129020: PUSH
129021: LD_VAR 0 2
129025: GREATEREQUAL
129026: IFFALSE 129259
// if factoryWaypoints [ factory ] then
129028: LD_EXP 206
129032: PUSH
129033: LD_VAR 0 2
129037: ARRAY
129038: IFFALSE 129259
// begin if GetControl ( vehicle ) = control_manual then
129040: LD_VAR 0 1
129044: PPUSH
129045: CALL_OW 263
129049: PUSH
129050: LD_INT 1
129052: EQUAL
129053: IFFALSE 129146
// begin driver := IsDrivenBy ( vehicle ) ;
129055: LD_ADDR_VAR 0 4
129059: PUSH
129060: LD_VAR 0 1
129064: PPUSH
129065: CALL_OW 311
129069: ST_TO_ADDR
// if not HasTask ( driver ) then
129070: LD_VAR 0 4
129074: PPUSH
129075: CALL_OW 314
129079: NOT
129080: IFFALSE 129144
// begin ComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129082: LD_VAR 0 4
129086: PPUSH
129087: LD_EXP 206
129091: PUSH
129092: LD_VAR 0 2
129096: ARRAY
129097: PUSH
129098: LD_INT 3
129100: ARRAY
129101: PPUSH
129102: LD_EXP 206
129106: PUSH
129107: LD_VAR 0 2
129111: ARRAY
129112: PUSH
129113: LD_INT 4
129115: ARRAY
129116: PPUSH
129117: CALL_OW 111
// AddComExitVehicle ( driver ) ;
129121: LD_VAR 0 4
129125: PPUSH
129126: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
129130: LD_VAR 0 4
129134: PPUSH
129135: LD_VAR 0 2
129139: PPUSH
129140: CALL_OW 180
// end ; end else
129144: GO 129259
// if GetControl ( vehicle ) = control_remote then
129146: LD_VAR 0 1
129150: PPUSH
129151: CALL_OW 263
129155: PUSH
129156: LD_INT 2
129158: EQUAL
129159: IFFALSE 129220
// begin wait ( 0 0$2 ) ;
129161: LD_INT 70
129163: PPUSH
129164: CALL_OW 67
// if Connect ( vehicle ) then
129168: LD_VAR 0 1
129172: PPUSH
129173: CALL 78590 0 1
129177: IFFALSE 129218
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129179: LD_VAR 0 1
129183: PPUSH
129184: LD_EXP 206
129188: PUSH
129189: LD_VAR 0 2
129193: ARRAY
129194: PUSH
129195: LD_INT 3
129197: ARRAY
129198: PPUSH
129199: LD_EXP 206
129203: PUSH
129204: LD_VAR 0 2
129208: ARRAY
129209: PUSH
129210: LD_INT 4
129212: ARRAY
129213: PPUSH
129214: CALL_OW 171
// end else
129218: GO 129259
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129220: LD_VAR 0 1
129224: PPUSH
129225: LD_EXP 206
129229: PUSH
129230: LD_VAR 0 2
129234: ARRAY
129235: PUSH
129236: LD_INT 3
129238: ARRAY
129239: PPUSH
129240: LD_EXP 206
129244: PUSH
129245: LD_VAR 0 2
129249: ARRAY
129250: PUSH
129251: LD_INT 4
129253: ARRAY
129254: PPUSH
129255: CALL_OW 171
// end ; end ;
129259: LD_VAR 0 3
129263: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
129264: LD_INT 0
129266: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
129267: LD_VAR 0 1
129271: PUSH
129272: LD_INT 250
129274: EQUAL
129275: PUSH
129276: LD_VAR 0 2
129280: PPUSH
129281: CALL_OW 264
129285: PUSH
129286: LD_INT 81
129288: EQUAL
129289: AND
129290: IFFALSE 129311
// MinerPlaceMine ( unit , x , y ) ;
129292: LD_VAR 0 2
129296: PPUSH
129297: LD_VAR 0 4
129301: PPUSH
129302: LD_VAR 0 5
129306: PPUSH
129307: CALL 132301 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
129311: LD_VAR 0 1
129315: PUSH
129316: LD_INT 251
129318: EQUAL
129319: PUSH
129320: LD_VAR 0 2
129324: PPUSH
129325: CALL_OW 264
129329: PUSH
129330: LD_INT 81
129332: EQUAL
129333: AND
129334: IFFALSE 129355
// MinerDetonateMine ( unit , x , y ) ;
129336: LD_VAR 0 2
129340: PPUSH
129341: LD_VAR 0 4
129345: PPUSH
129346: LD_VAR 0 5
129350: PPUSH
129351: CALL 132576 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
129355: LD_VAR 0 1
129359: PUSH
129360: LD_INT 252
129362: EQUAL
129363: PUSH
129364: LD_VAR 0 2
129368: PPUSH
129369: CALL_OW 264
129373: PUSH
129374: LD_INT 81
129376: EQUAL
129377: AND
129378: IFFALSE 129399
// MinerCreateMinefield ( unit , x , y ) ;
129380: LD_VAR 0 2
129384: PPUSH
129385: LD_VAR 0 4
129389: PPUSH
129390: LD_VAR 0 5
129394: PPUSH
129395: CALL 132993 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
129399: LD_VAR 0 1
129403: PUSH
129404: LD_INT 253
129406: EQUAL
129407: PUSH
129408: LD_VAR 0 2
129412: PPUSH
129413: CALL_OW 257
129417: PUSH
129418: LD_INT 5
129420: EQUAL
129421: AND
129422: IFFALSE 129443
// ComBinocular ( unit , x , y ) ;
129424: LD_VAR 0 2
129428: PPUSH
129429: LD_VAR 0 4
129433: PPUSH
129434: LD_VAR 0 5
129438: PPUSH
129439: CALL 133362 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
129443: LD_VAR 0 1
129447: PUSH
129448: LD_INT 254
129450: EQUAL
129451: PUSH
129452: LD_VAR 0 2
129456: PPUSH
129457: CALL_OW 264
129461: PUSH
129462: LD_INT 99
129464: EQUAL
129465: AND
129466: PUSH
129467: LD_VAR 0 3
129471: PPUSH
129472: CALL_OW 263
129476: PUSH
129477: LD_INT 3
129479: EQUAL
129480: AND
129481: IFFALSE 129497
// HackDestroyVehicle ( unit , selectedUnit ) ;
129483: LD_VAR 0 2
129487: PPUSH
129488: LD_VAR 0 3
129492: PPUSH
129493: CALL 131665 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
129497: LD_VAR 0 1
129501: PUSH
129502: LD_INT 255
129504: EQUAL
129505: PUSH
129506: LD_VAR 0 2
129510: PPUSH
129511: CALL_OW 264
129515: PUSH
129516: LD_INT 14
129518: PUSH
129519: LD_INT 53
129521: PUSH
129522: EMPTY
129523: LIST
129524: LIST
129525: IN
129526: AND
129527: PUSH
129528: LD_VAR 0 4
129532: PPUSH
129533: LD_VAR 0 5
129537: PPUSH
129538: CALL_OW 488
129542: AND
129543: IFFALSE 129567
// CutTreeXYR ( unit , x , y , 12 ) ;
129545: LD_VAR 0 2
129549: PPUSH
129550: LD_VAR 0 4
129554: PPUSH
129555: LD_VAR 0 5
129559: PPUSH
129560: LD_INT 12
129562: PPUSH
129563: CALL 129662 0 4
// if cmd = 256 then
129567: LD_VAR 0 1
129571: PUSH
129572: LD_INT 256
129574: EQUAL
129575: IFFALSE 129596
// SetFactoryWaypoint ( unit , x , y ) ;
129577: LD_VAR 0 2
129581: PPUSH
129582: LD_VAR 0 4
129586: PPUSH
129587: LD_VAR 0 5
129591: PPUSH
129592: CALL 127565 0 3
// if cmd = 257 then
129596: LD_VAR 0 1
129600: PUSH
129601: LD_INT 257
129603: EQUAL
129604: IFFALSE 129625
// SetWarehouseGatheringPoint ( unit , x , y ) ;
129606: LD_VAR 0 2
129610: PPUSH
129611: LD_VAR 0 4
129615: PPUSH
129616: LD_VAR 0 5
129620: PPUSH
129621: CALL 127927 0 3
// if cmd = 258 then
129625: LD_VAR 0 1
129629: PUSH
129630: LD_INT 258
129632: EQUAL
129633: IFFALSE 129657
// BurnTreeXYR ( unit , x , y , 8 ) ;
129635: LD_VAR 0 2
129639: PPUSH
129640: LD_VAR 0 4
129644: PPUSH
129645: LD_VAR 0 5
129649: PPUSH
129650: LD_INT 8
129652: PPUSH
129653: CALL 130056 0 4
// end ;
129657: LD_VAR 0 6
129661: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
129662: LD_INT 0
129664: PPUSH
129665: PPUSH
129666: PPUSH
129667: PPUSH
129668: PPUSH
129669: PPUSH
129670: PPUSH
129671: PPUSH
129672: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
129673: LD_VAR 0 1
129677: PPUSH
129678: CALL_OW 302
129682: NOT
129683: PUSH
129684: LD_VAR 0 2
129688: PPUSH
129689: LD_VAR 0 3
129693: PPUSH
129694: CALL_OW 488
129698: NOT
129699: OR
129700: PUSH
129701: LD_VAR 0 4
129705: NOT
129706: OR
129707: IFFALSE 129711
// exit ;
129709: GO 130051
// list := [ ] ;
129711: LD_ADDR_VAR 0 13
129715: PUSH
129716: EMPTY
129717: ST_TO_ADDR
// if x - r < 0 then
129718: LD_VAR 0 2
129722: PUSH
129723: LD_VAR 0 4
129727: MINUS
129728: PUSH
129729: LD_INT 0
129731: LESS
129732: IFFALSE 129744
// min_x := 0 else
129734: LD_ADDR_VAR 0 7
129738: PUSH
129739: LD_INT 0
129741: ST_TO_ADDR
129742: GO 129760
// min_x := x - r ;
129744: LD_ADDR_VAR 0 7
129748: PUSH
129749: LD_VAR 0 2
129753: PUSH
129754: LD_VAR 0 4
129758: MINUS
129759: ST_TO_ADDR
// if y - r < 0 then
129760: LD_VAR 0 3
129764: PUSH
129765: LD_VAR 0 4
129769: MINUS
129770: PUSH
129771: LD_INT 0
129773: LESS
129774: IFFALSE 129786
// min_y := 0 else
129776: LD_ADDR_VAR 0 8
129780: PUSH
129781: LD_INT 0
129783: ST_TO_ADDR
129784: GO 129802
// min_y := y - r ;
129786: LD_ADDR_VAR 0 8
129790: PUSH
129791: LD_VAR 0 3
129795: PUSH
129796: LD_VAR 0 4
129800: MINUS
129801: ST_TO_ADDR
// max_x := x + r ;
129802: LD_ADDR_VAR 0 9
129806: PUSH
129807: LD_VAR 0 2
129811: PUSH
129812: LD_VAR 0 4
129816: PLUS
129817: ST_TO_ADDR
// max_y := y + r ;
129818: LD_ADDR_VAR 0 10
129822: PUSH
129823: LD_VAR 0 3
129827: PUSH
129828: LD_VAR 0 4
129832: PLUS
129833: ST_TO_ADDR
// for _x = min_x to max_x do
129834: LD_ADDR_VAR 0 11
129838: PUSH
129839: DOUBLE
129840: LD_VAR 0 7
129844: DEC
129845: ST_TO_ADDR
129846: LD_VAR 0 9
129850: PUSH
129851: FOR_TO
129852: IFFALSE 129969
// for _y = min_y to max_y do
129854: LD_ADDR_VAR 0 12
129858: PUSH
129859: DOUBLE
129860: LD_VAR 0 8
129864: DEC
129865: ST_TO_ADDR
129866: LD_VAR 0 10
129870: PUSH
129871: FOR_TO
129872: IFFALSE 129965
// begin if not ValidHex ( _x , _y ) then
129874: LD_VAR 0 11
129878: PPUSH
129879: LD_VAR 0 12
129883: PPUSH
129884: CALL_OW 488
129888: NOT
129889: IFFALSE 129893
// continue ;
129891: GO 129871
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129893: LD_VAR 0 11
129897: PPUSH
129898: LD_VAR 0 12
129902: PPUSH
129903: CALL_OW 351
129907: PUSH
129908: LD_VAR 0 11
129912: PPUSH
129913: LD_VAR 0 12
129917: PPUSH
129918: CALL_OW 554
129922: AND
129923: IFFALSE 129963
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129925: LD_ADDR_VAR 0 13
129929: PUSH
129930: LD_VAR 0 13
129934: PPUSH
129935: LD_VAR 0 13
129939: PUSH
129940: LD_INT 1
129942: PLUS
129943: PPUSH
129944: LD_VAR 0 11
129948: PUSH
129949: LD_VAR 0 12
129953: PUSH
129954: EMPTY
129955: LIST
129956: LIST
129957: PPUSH
129958: CALL_OW 2
129962: ST_TO_ADDR
// end ;
129963: GO 129871
129965: POP
129966: POP
129967: GO 129851
129969: POP
129970: POP
// if not list then
129971: LD_VAR 0 13
129975: NOT
129976: IFFALSE 129980
// exit ;
129978: GO 130051
// for i in list do
129980: LD_ADDR_VAR 0 6
129984: PUSH
129985: LD_VAR 0 13
129989: PUSH
129990: FOR_IN
129991: IFFALSE 130049
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
129993: LD_VAR 0 1
129997: PPUSH
129998: LD_STRING M
130000: PUSH
130001: LD_VAR 0 6
130005: PUSH
130006: LD_INT 1
130008: ARRAY
130009: PUSH
130010: LD_VAR 0 6
130014: PUSH
130015: LD_INT 2
130017: ARRAY
130018: PUSH
130019: LD_INT 0
130021: PUSH
130022: LD_INT 0
130024: PUSH
130025: LD_INT 0
130027: PUSH
130028: LD_INT 0
130030: PUSH
130031: EMPTY
130032: LIST
130033: LIST
130034: LIST
130035: LIST
130036: LIST
130037: LIST
130038: LIST
130039: PUSH
130040: EMPTY
130041: LIST
130042: PPUSH
130043: CALL_OW 447
130047: GO 129990
130049: POP
130050: POP
// end ;
130051: LD_VAR 0 5
130055: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
130056: LD_INT 0
130058: PPUSH
130059: PPUSH
130060: PPUSH
130061: PPUSH
130062: PPUSH
130063: PPUSH
130064: PPUSH
130065: PPUSH
130066: PPUSH
130067: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
130068: LD_VAR 0 1
130072: PPUSH
130073: CALL_OW 302
130077: NOT
130078: PUSH
130079: LD_VAR 0 2
130083: PPUSH
130084: LD_VAR 0 3
130088: PPUSH
130089: CALL_OW 488
130093: NOT
130094: OR
130095: PUSH
130096: LD_VAR 0 4
130100: NOT
130101: OR
130102: IFFALSE 130106
// exit ;
130104: GO 130619
// list := [ ] ;
130106: LD_ADDR_VAR 0 13
130110: PUSH
130111: EMPTY
130112: ST_TO_ADDR
// if x - r < 0 then
130113: LD_VAR 0 2
130117: PUSH
130118: LD_VAR 0 4
130122: MINUS
130123: PUSH
130124: LD_INT 0
130126: LESS
130127: IFFALSE 130139
// min_x := 0 else
130129: LD_ADDR_VAR 0 7
130133: PUSH
130134: LD_INT 0
130136: ST_TO_ADDR
130137: GO 130155
// min_x := x - r ;
130139: LD_ADDR_VAR 0 7
130143: PUSH
130144: LD_VAR 0 2
130148: PUSH
130149: LD_VAR 0 4
130153: MINUS
130154: ST_TO_ADDR
// if y - r < 0 then
130155: LD_VAR 0 3
130159: PUSH
130160: LD_VAR 0 4
130164: MINUS
130165: PUSH
130166: LD_INT 0
130168: LESS
130169: IFFALSE 130181
// min_y := 0 else
130171: LD_ADDR_VAR 0 8
130175: PUSH
130176: LD_INT 0
130178: ST_TO_ADDR
130179: GO 130197
// min_y := y - r ;
130181: LD_ADDR_VAR 0 8
130185: PUSH
130186: LD_VAR 0 3
130190: PUSH
130191: LD_VAR 0 4
130195: MINUS
130196: ST_TO_ADDR
// max_x := x + r ;
130197: LD_ADDR_VAR 0 9
130201: PUSH
130202: LD_VAR 0 2
130206: PUSH
130207: LD_VAR 0 4
130211: PLUS
130212: ST_TO_ADDR
// max_y := y + r ;
130213: LD_ADDR_VAR 0 10
130217: PUSH
130218: LD_VAR 0 3
130222: PUSH
130223: LD_VAR 0 4
130227: PLUS
130228: ST_TO_ADDR
// for _x = min_x to max_x do
130229: LD_ADDR_VAR 0 11
130233: PUSH
130234: DOUBLE
130235: LD_VAR 0 7
130239: DEC
130240: ST_TO_ADDR
130241: LD_VAR 0 9
130245: PUSH
130246: FOR_TO
130247: IFFALSE 130364
// for _y = min_y to max_y do
130249: LD_ADDR_VAR 0 12
130253: PUSH
130254: DOUBLE
130255: LD_VAR 0 8
130259: DEC
130260: ST_TO_ADDR
130261: LD_VAR 0 10
130265: PUSH
130266: FOR_TO
130267: IFFALSE 130360
// begin if not ValidHex ( _x , _y ) then
130269: LD_VAR 0 11
130273: PPUSH
130274: LD_VAR 0 12
130278: PPUSH
130279: CALL_OW 488
130283: NOT
130284: IFFALSE 130288
// continue ;
130286: GO 130266
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130288: LD_VAR 0 11
130292: PPUSH
130293: LD_VAR 0 12
130297: PPUSH
130298: CALL_OW 351
130302: PUSH
130303: LD_VAR 0 11
130307: PPUSH
130308: LD_VAR 0 12
130312: PPUSH
130313: CALL_OW 554
130317: AND
130318: IFFALSE 130358
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130320: LD_ADDR_VAR 0 13
130324: PUSH
130325: LD_VAR 0 13
130329: PPUSH
130330: LD_VAR 0 13
130334: PUSH
130335: LD_INT 1
130337: PLUS
130338: PPUSH
130339: LD_VAR 0 11
130343: PUSH
130344: LD_VAR 0 12
130348: PUSH
130349: EMPTY
130350: LIST
130351: LIST
130352: PPUSH
130353: CALL_OW 2
130357: ST_TO_ADDR
// end ;
130358: GO 130266
130360: POP
130361: POP
130362: GO 130246
130364: POP
130365: POP
// if not list then
130366: LD_VAR 0 13
130370: NOT
130371: IFFALSE 130375
// exit ;
130373: GO 130619
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
130375: LD_ADDR_VAR 0 13
130379: PUSH
130380: LD_VAR 0 1
130384: PPUSH
130385: LD_VAR 0 13
130389: PPUSH
130390: LD_INT 1
130392: PPUSH
130393: LD_INT 1
130395: PPUSH
130396: CALL 75732 0 4
130400: ST_TO_ADDR
// ComStop ( flame ) ;
130401: LD_VAR 0 1
130405: PPUSH
130406: CALL_OW 141
// for i in list do
130410: LD_ADDR_VAR 0 6
130414: PUSH
130415: LD_VAR 0 13
130419: PUSH
130420: FOR_IN
130421: IFFALSE 130452
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
130423: LD_VAR 0 1
130427: PPUSH
130428: LD_VAR 0 6
130432: PUSH
130433: LD_INT 1
130435: ARRAY
130436: PPUSH
130437: LD_VAR 0 6
130441: PUSH
130442: LD_INT 2
130444: ARRAY
130445: PPUSH
130446: CALL_OW 176
130450: GO 130420
130452: POP
130453: POP
// repeat wait ( 0 0$1 ) ;
130454: LD_INT 35
130456: PPUSH
130457: CALL_OW 67
// task := GetTaskList ( flame ) ;
130461: LD_ADDR_VAR 0 14
130465: PUSH
130466: LD_VAR 0 1
130470: PPUSH
130471: CALL_OW 437
130475: ST_TO_ADDR
// if not task then
130476: LD_VAR 0 14
130480: NOT
130481: IFFALSE 130485
// exit ;
130483: GO 130619
// if task [ 1 ] [ 1 ] <> | then
130485: LD_VAR 0 14
130489: PUSH
130490: LD_INT 1
130492: ARRAY
130493: PUSH
130494: LD_INT 1
130496: ARRAY
130497: PUSH
130498: LD_STRING |
130500: NONEQUAL
130501: IFFALSE 130505
// exit ;
130503: GO 130619
// _x := task [ 1 ] [ 2 ] ;
130505: LD_ADDR_VAR 0 11
130509: PUSH
130510: LD_VAR 0 14
130514: PUSH
130515: LD_INT 1
130517: ARRAY
130518: PUSH
130519: LD_INT 2
130521: ARRAY
130522: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
130523: LD_ADDR_VAR 0 12
130527: PUSH
130528: LD_VAR 0 14
130532: PUSH
130533: LD_INT 1
130535: ARRAY
130536: PUSH
130537: LD_INT 3
130539: ARRAY
130540: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
130541: LD_VAR 0 11
130545: PPUSH
130546: LD_VAR 0 12
130550: PPUSH
130551: CALL_OW 351
130555: NOT
130556: PUSH
130557: LD_VAR 0 11
130561: PPUSH
130562: LD_VAR 0 12
130566: PPUSH
130567: CALL_OW 554
130571: NOT
130572: OR
130573: IFFALSE 130607
// begin task := Delete ( task , 1 ) ;
130575: LD_ADDR_VAR 0 14
130579: PUSH
130580: LD_VAR 0 14
130584: PPUSH
130585: LD_INT 1
130587: PPUSH
130588: CALL_OW 3
130592: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
130593: LD_VAR 0 1
130597: PPUSH
130598: LD_VAR 0 14
130602: PPUSH
130603: CALL_OW 446
// end ; until not HasTask ( flame ) ;
130607: LD_VAR 0 1
130611: PPUSH
130612: CALL_OW 314
130616: NOT
130617: IFFALSE 130454
// end ;
130619: LD_VAR 0 5
130623: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
130624: LD_EXP 209
130628: NOT
130629: IFFALSE 130679
130631: GO 130633
130633: DISABLE
// begin initHack := true ;
130634: LD_ADDR_EXP 209
130638: PUSH
130639: LD_INT 1
130641: ST_TO_ADDR
// hackTanks := [ ] ;
130642: LD_ADDR_EXP 210
130646: PUSH
130647: EMPTY
130648: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
130649: LD_ADDR_EXP 211
130653: PUSH
130654: EMPTY
130655: ST_TO_ADDR
// hackLimit := 3 ;
130656: LD_ADDR_EXP 212
130660: PUSH
130661: LD_INT 3
130663: ST_TO_ADDR
// hackDist := 12 ;
130664: LD_ADDR_EXP 213
130668: PUSH
130669: LD_INT 12
130671: ST_TO_ADDR
// hackCounter := [ ] ;
130672: LD_ADDR_EXP 214
130676: PUSH
130677: EMPTY
130678: ST_TO_ADDR
// end ;
130679: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
130680: LD_EXP 209
130684: PUSH
130685: LD_INT 34
130687: PUSH
130688: LD_INT 99
130690: PUSH
130691: EMPTY
130692: LIST
130693: LIST
130694: PPUSH
130695: CALL_OW 69
130699: AND
130700: IFFALSE 130953
130702: GO 130704
130704: DISABLE
130705: LD_INT 0
130707: PPUSH
130708: PPUSH
// begin enable ;
130709: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
130710: LD_ADDR_VAR 0 1
130714: PUSH
130715: LD_INT 34
130717: PUSH
130718: LD_INT 99
130720: PUSH
130721: EMPTY
130722: LIST
130723: LIST
130724: PPUSH
130725: CALL_OW 69
130729: PUSH
130730: FOR_IN
130731: IFFALSE 130951
// begin if not i in hackTanks then
130733: LD_VAR 0 1
130737: PUSH
130738: LD_EXP 210
130742: IN
130743: NOT
130744: IFFALSE 130827
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
130746: LD_ADDR_EXP 210
130750: PUSH
130751: LD_EXP 210
130755: PPUSH
130756: LD_EXP 210
130760: PUSH
130761: LD_INT 1
130763: PLUS
130764: PPUSH
130765: LD_VAR 0 1
130769: PPUSH
130770: CALL_OW 1
130774: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
130775: LD_ADDR_EXP 211
130779: PUSH
130780: LD_EXP 211
130784: PPUSH
130785: LD_EXP 211
130789: PUSH
130790: LD_INT 1
130792: PLUS
130793: PPUSH
130794: EMPTY
130795: PPUSH
130796: CALL_OW 1
130800: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
130801: LD_ADDR_EXP 214
130805: PUSH
130806: LD_EXP 214
130810: PPUSH
130811: LD_EXP 214
130815: PUSH
130816: LD_INT 1
130818: PLUS
130819: PPUSH
130820: EMPTY
130821: PPUSH
130822: CALL_OW 1
130826: ST_TO_ADDR
// end ; if not IsOk ( i ) then
130827: LD_VAR 0 1
130831: PPUSH
130832: CALL_OW 302
130836: NOT
130837: IFFALSE 130850
// begin HackUnlinkAll ( i ) ;
130839: LD_VAR 0 1
130843: PPUSH
130844: CALL 130956 0 1
// continue ;
130848: GO 130730
// end ; HackCheckCapturedStatus ( i ) ;
130850: LD_VAR 0 1
130854: PPUSH
130855: CALL 131399 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
130859: LD_ADDR_VAR 0 2
130863: PUSH
130864: LD_INT 81
130866: PUSH
130867: LD_VAR 0 1
130871: PPUSH
130872: CALL_OW 255
130876: PUSH
130877: EMPTY
130878: LIST
130879: LIST
130880: PUSH
130881: LD_INT 33
130883: PUSH
130884: LD_INT 3
130886: PUSH
130887: EMPTY
130888: LIST
130889: LIST
130890: PUSH
130891: LD_INT 91
130893: PUSH
130894: LD_VAR 0 1
130898: PUSH
130899: LD_EXP 213
130903: PUSH
130904: EMPTY
130905: LIST
130906: LIST
130907: LIST
130908: PUSH
130909: LD_INT 50
130911: PUSH
130912: EMPTY
130913: LIST
130914: PUSH
130915: EMPTY
130916: LIST
130917: LIST
130918: LIST
130919: LIST
130920: PPUSH
130921: CALL_OW 69
130925: ST_TO_ADDR
// if not tmp then
130926: LD_VAR 0 2
130930: NOT
130931: IFFALSE 130935
// continue ;
130933: GO 130730
// HackLink ( i , tmp ) ;
130935: LD_VAR 0 1
130939: PPUSH
130940: LD_VAR 0 2
130944: PPUSH
130945: CALL 131092 0 2
// end ;
130949: GO 130730
130951: POP
130952: POP
// end ;
130953: PPOPN 2
130955: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
130956: LD_INT 0
130958: PPUSH
130959: PPUSH
130960: PPUSH
// if not hack in hackTanks then
130961: LD_VAR 0 1
130965: PUSH
130966: LD_EXP 210
130970: IN
130971: NOT
130972: IFFALSE 130976
// exit ;
130974: GO 131087
// index := GetElementIndex ( hackTanks , hack ) ;
130976: LD_ADDR_VAR 0 4
130980: PUSH
130981: LD_EXP 210
130985: PPUSH
130986: LD_VAR 0 1
130990: PPUSH
130991: CALL 75029 0 2
130995: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
130996: LD_EXP 211
131000: PUSH
131001: LD_VAR 0 4
131005: ARRAY
131006: IFFALSE 131087
// begin for i in hackTanksCaptured [ index ] do
131008: LD_ADDR_VAR 0 3
131012: PUSH
131013: LD_EXP 211
131017: PUSH
131018: LD_VAR 0 4
131022: ARRAY
131023: PUSH
131024: FOR_IN
131025: IFFALSE 131051
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
131027: LD_VAR 0 3
131031: PUSH
131032: LD_INT 1
131034: ARRAY
131035: PPUSH
131036: LD_VAR 0 3
131040: PUSH
131041: LD_INT 2
131043: ARRAY
131044: PPUSH
131045: CALL_OW 235
131049: GO 131024
131051: POP
131052: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
131053: LD_ADDR_EXP 211
131057: PUSH
131058: LD_EXP 211
131062: PPUSH
131063: LD_VAR 0 4
131067: PPUSH
131068: EMPTY
131069: PPUSH
131070: CALL_OW 1
131074: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
131075: LD_VAR 0 1
131079: PPUSH
131080: LD_INT 0
131082: PPUSH
131083: CALL_OW 505
// end ; end ;
131087: LD_VAR 0 2
131091: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
131092: LD_INT 0
131094: PPUSH
131095: PPUSH
131096: PPUSH
// if not hack in hackTanks or not vehicles then
131097: LD_VAR 0 1
131101: PUSH
131102: LD_EXP 210
131106: IN
131107: NOT
131108: PUSH
131109: LD_VAR 0 2
131113: NOT
131114: OR
131115: IFFALSE 131119
// exit ;
131117: GO 131394
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
131119: LD_ADDR_VAR 0 2
131123: PUSH
131124: LD_VAR 0 1
131128: PPUSH
131129: LD_VAR 0 2
131133: PPUSH
131134: LD_INT 1
131136: PPUSH
131137: LD_INT 1
131139: PPUSH
131140: CALL 75679 0 4
131144: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
131145: LD_ADDR_VAR 0 5
131149: PUSH
131150: LD_EXP 210
131154: PPUSH
131155: LD_VAR 0 1
131159: PPUSH
131160: CALL 75029 0 2
131164: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
131165: LD_EXP 211
131169: PUSH
131170: LD_VAR 0 5
131174: ARRAY
131175: PUSH
131176: LD_EXP 212
131180: LESS
131181: IFFALSE 131370
// begin for i := 1 to vehicles do
131183: LD_ADDR_VAR 0 4
131187: PUSH
131188: DOUBLE
131189: LD_INT 1
131191: DEC
131192: ST_TO_ADDR
131193: LD_VAR 0 2
131197: PUSH
131198: FOR_TO
131199: IFFALSE 131368
// begin if hackTanksCaptured [ index ] = hackLimit then
131201: LD_EXP 211
131205: PUSH
131206: LD_VAR 0 5
131210: ARRAY
131211: PUSH
131212: LD_EXP 212
131216: EQUAL
131217: IFFALSE 131221
// break ;
131219: GO 131368
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
131221: LD_ADDR_EXP 214
131225: PUSH
131226: LD_EXP 214
131230: PPUSH
131231: LD_VAR 0 5
131235: PPUSH
131236: LD_EXP 214
131240: PUSH
131241: LD_VAR 0 5
131245: ARRAY
131246: PUSH
131247: LD_INT 1
131249: PLUS
131250: PPUSH
131251: CALL_OW 1
131255: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
131256: LD_ADDR_EXP 211
131260: PUSH
131261: LD_EXP 211
131265: PPUSH
131266: LD_VAR 0 5
131270: PUSH
131271: LD_EXP 211
131275: PUSH
131276: LD_VAR 0 5
131280: ARRAY
131281: PUSH
131282: LD_INT 1
131284: PLUS
131285: PUSH
131286: EMPTY
131287: LIST
131288: LIST
131289: PPUSH
131290: LD_VAR 0 2
131294: PUSH
131295: LD_VAR 0 4
131299: ARRAY
131300: PUSH
131301: LD_VAR 0 2
131305: PUSH
131306: LD_VAR 0 4
131310: ARRAY
131311: PPUSH
131312: CALL_OW 255
131316: PUSH
131317: EMPTY
131318: LIST
131319: LIST
131320: PPUSH
131321: CALL 75244 0 3
131325: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
131326: LD_VAR 0 2
131330: PUSH
131331: LD_VAR 0 4
131335: ARRAY
131336: PPUSH
131337: LD_VAR 0 1
131341: PPUSH
131342: CALL_OW 255
131346: PPUSH
131347: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
131351: LD_VAR 0 2
131355: PUSH
131356: LD_VAR 0 4
131360: ARRAY
131361: PPUSH
131362: CALL_OW 141
// end ;
131366: GO 131198
131368: POP
131369: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131370: LD_VAR 0 1
131374: PPUSH
131375: LD_EXP 211
131379: PUSH
131380: LD_VAR 0 5
131384: ARRAY
131385: PUSH
131386: LD_INT 0
131388: PLUS
131389: PPUSH
131390: CALL_OW 505
// end ;
131394: LD_VAR 0 3
131398: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
131399: LD_INT 0
131401: PPUSH
131402: PPUSH
131403: PPUSH
131404: PPUSH
// if not hack in hackTanks then
131405: LD_VAR 0 1
131409: PUSH
131410: LD_EXP 210
131414: IN
131415: NOT
131416: IFFALSE 131420
// exit ;
131418: GO 131660
// index := GetElementIndex ( hackTanks , hack ) ;
131420: LD_ADDR_VAR 0 4
131424: PUSH
131425: LD_EXP 210
131429: PPUSH
131430: LD_VAR 0 1
131434: PPUSH
131435: CALL 75029 0 2
131439: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
131440: LD_ADDR_VAR 0 3
131444: PUSH
131445: DOUBLE
131446: LD_EXP 211
131450: PUSH
131451: LD_VAR 0 4
131455: ARRAY
131456: INC
131457: ST_TO_ADDR
131458: LD_INT 1
131460: PUSH
131461: FOR_DOWNTO
131462: IFFALSE 131634
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
131464: LD_ADDR_VAR 0 5
131468: PUSH
131469: LD_EXP 211
131473: PUSH
131474: LD_VAR 0 4
131478: ARRAY
131479: PUSH
131480: LD_VAR 0 3
131484: ARRAY
131485: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
131486: LD_VAR 0 5
131490: PUSH
131491: LD_INT 1
131493: ARRAY
131494: PPUSH
131495: CALL_OW 302
131499: NOT
131500: PUSH
131501: LD_VAR 0 5
131505: PUSH
131506: LD_INT 1
131508: ARRAY
131509: PPUSH
131510: CALL_OW 255
131514: PUSH
131515: LD_VAR 0 1
131519: PPUSH
131520: CALL_OW 255
131524: NONEQUAL
131525: OR
131526: IFFALSE 131632
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
131528: LD_VAR 0 5
131532: PUSH
131533: LD_INT 1
131535: ARRAY
131536: PPUSH
131537: CALL_OW 305
131541: PUSH
131542: LD_VAR 0 5
131546: PUSH
131547: LD_INT 1
131549: ARRAY
131550: PPUSH
131551: CALL_OW 255
131555: PUSH
131556: LD_VAR 0 1
131560: PPUSH
131561: CALL_OW 255
131565: EQUAL
131566: AND
131567: IFFALSE 131591
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
131569: LD_VAR 0 5
131573: PUSH
131574: LD_INT 1
131576: ARRAY
131577: PPUSH
131578: LD_VAR 0 5
131582: PUSH
131583: LD_INT 2
131585: ARRAY
131586: PPUSH
131587: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
131591: LD_ADDR_EXP 211
131595: PUSH
131596: LD_EXP 211
131600: PPUSH
131601: LD_VAR 0 4
131605: PPUSH
131606: LD_EXP 211
131610: PUSH
131611: LD_VAR 0 4
131615: ARRAY
131616: PPUSH
131617: LD_VAR 0 3
131621: PPUSH
131622: CALL_OW 3
131626: PPUSH
131627: CALL_OW 1
131631: ST_TO_ADDR
// end ; end ;
131632: GO 131461
131634: POP
131635: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131636: LD_VAR 0 1
131640: PPUSH
131641: LD_EXP 211
131645: PUSH
131646: LD_VAR 0 4
131650: ARRAY
131651: PUSH
131652: LD_INT 0
131654: PLUS
131655: PPUSH
131656: CALL_OW 505
// end ;
131660: LD_VAR 0 2
131664: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
131665: LD_INT 0
131667: PPUSH
131668: PPUSH
131669: PPUSH
131670: PPUSH
// if not hack in hackTanks then
131671: LD_VAR 0 1
131675: PUSH
131676: LD_EXP 210
131680: IN
131681: NOT
131682: IFFALSE 131686
// exit ;
131684: GO 131771
// index := GetElementIndex ( hackTanks , hack ) ;
131686: LD_ADDR_VAR 0 5
131690: PUSH
131691: LD_EXP 210
131695: PPUSH
131696: LD_VAR 0 1
131700: PPUSH
131701: CALL 75029 0 2
131705: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
131706: LD_ADDR_VAR 0 4
131710: PUSH
131711: DOUBLE
131712: LD_INT 1
131714: DEC
131715: ST_TO_ADDR
131716: LD_EXP 211
131720: PUSH
131721: LD_VAR 0 5
131725: ARRAY
131726: PUSH
131727: FOR_TO
131728: IFFALSE 131769
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
131730: LD_EXP 211
131734: PUSH
131735: LD_VAR 0 5
131739: ARRAY
131740: PUSH
131741: LD_VAR 0 4
131745: ARRAY
131746: PUSH
131747: LD_INT 1
131749: ARRAY
131750: PUSH
131751: LD_VAR 0 2
131755: EQUAL
131756: IFFALSE 131767
// KillUnit ( vehicle ) ;
131758: LD_VAR 0 2
131762: PPUSH
131763: CALL_OW 66
131767: GO 131727
131769: POP
131770: POP
// end ;
131771: LD_VAR 0 3
131775: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
131776: LD_EXP 215
131780: NOT
131781: IFFALSE 131816
131783: GO 131785
131785: DISABLE
// begin initMiner := true ;
131786: LD_ADDR_EXP 215
131790: PUSH
131791: LD_INT 1
131793: ST_TO_ADDR
// minersList := [ ] ;
131794: LD_ADDR_EXP 216
131798: PUSH
131799: EMPTY
131800: ST_TO_ADDR
// minerMinesList := [ ] ;
131801: LD_ADDR_EXP 217
131805: PUSH
131806: EMPTY
131807: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
131808: LD_ADDR_EXP 218
131812: PUSH
131813: LD_INT 5
131815: ST_TO_ADDR
// end ;
131816: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
131817: LD_EXP 215
131821: PUSH
131822: LD_INT 34
131824: PUSH
131825: LD_INT 81
131827: PUSH
131828: EMPTY
131829: LIST
131830: LIST
131831: PPUSH
131832: CALL_OW 69
131836: AND
131837: IFFALSE 132298
131839: GO 131841
131841: DISABLE
131842: LD_INT 0
131844: PPUSH
131845: PPUSH
131846: PPUSH
131847: PPUSH
// begin enable ;
131848: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
131849: LD_ADDR_VAR 0 1
131853: PUSH
131854: LD_INT 34
131856: PUSH
131857: LD_INT 81
131859: PUSH
131860: EMPTY
131861: LIST
131862: LIST
131863: PPUSH
131864: CALL_OW 69
131868: PUSH
131869: FOR_IN
131870: IFFALSE 131942
// begin if not i in minersList then
131872: LD_VAR 0 1
131876: PUSH
131877: LD_EXP 216
131881: IN
131882: NOT
131883: IFFALSE 131940
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
131885: LD_ADDR_EXP 216
131889: PUSH
131890: LD_EXP 216
131894: PPUSH
131895: LD_EXP 216
131899: PUSH
131900: LD_INT 1
131902: PLUS
131903: PPUSH
131904: LD_VAR 0 1
131908: PPUSH
131909: CALL_OW 1
131913: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
131914: LD_ADDR_EXP 217
131918: PUSH
131919: LD_EXP 217
131923: PPUSH
131924: LD_EXP 217
131928: PUSH
131929: LD_INT 1
131931: PLUS
131932: PPUSH
131933: EMPTY
131934: PPUSH
131935: CALL_OW 1
131939: ST_TO_ADDR
// end end ;
131940: GO 131869
131942: POP
131943: POP
// for i := minerMinesList downto 1 do
131944: LD_ADDR_VAR 0 1
131948: PUSH
131949: DOUBLE
131950: LD_EXP 217
131954: INC
131955: ST_TO_ADDR
131956: LD_INT 1
131958: PUSH
131959: FOR_DOWNTO
131960: IFFALSE 132296
// begin if IsLive ( minersList [ i ] ) then
131962: LD_EXP 216
131966: PUSH
131967: LD_VAR 0 1
131971: ARRAY
131972: PPUSH
131973: CALL_OW 300
131977: IFFALSE 132005
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
131979: LD_EXP 216
131983: PUSH
131984: LD_VAR 0 1
131988: ARRAY
131989: PPUSH
131990: LD_EXP 217
131994: PUSH
131995: LD_VAR 0 1
131999: ARRAY
132000: PPUSH
132001: CALL_OW 505
// if not minerMinesList [ i ] then
132005: LD_EXP 217
132009: PUSH
132010: LD_VAR 0 1
132014: ARRAY
132015: NOT
132016: IFFALSE 132020
// continue ;
132018: GO 131959
// for j := minerMinesList [ i ] downto 1 do
132020: LD_ADDR_VAR 0 2
132024: PUSH
132025: DOUBLE
132026: LD_EXP 217
132030: PUSH
132031: LD_VAR 0 1
132035: ARRAY
132036: INC
132037: ST_TO_ADDR
132038: LD_INT 1
132040: PUSH
132041: FOR_DOWNTO
132042: IFFALSE 132292
// begin side := GetSide ( minersList [ i ] ) ;
132044: LD_ADDR_VAR 0 3
132048: PUSH
132049: LD_EXP 216
132053: PUSH
132054: LD_VAR 0 1
132058: ARRAY
132059: PPUSH
132060: CALL_OW 255
132064: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
132065: LD_ADDR_VAR 0 4
132069: PUSH
132070: LD_EXP 217
132074: PUSH
132075: LD_VAR 0 1
132079: ARRAY
132080: PUSH
132081: LD_VAR 0 2
132085: ARRAY
132086: PUSH
132087: LD_INT 1
132089: ARRAY
132090: PPUSH
132091: LD_EXP 217
132095: PUSH
132096: LD_VAR 0 1
132100: ARRAY
132101: PUSH
132102: LD_VAR 0 2
132106: ARRAY
132107: PUSH
132108: LD_INT 2
132110: ARRAY
132111: PPUSH
132112: CALL_OW 428
132116: ST_TO_ADDR
// if not tmp then
132117: LD_VAR 0 4
132121: NOT
132122: IFFALSE 132126
// continue ;
132124: GO 132041
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
132126: LD_VAR 0 4
132130: PUSH
132131: LD_INT 81
132133: PUSH
132134: LD_VAR 0 3
132138: PUSH
132139: EMPTY
132140: LIST
132141: LIST
132142: PPUSH
132143: CALL_OW 69
132147: IN
132148: PUSH
132149: LD_EXP 217
132153: PUSH
132154: LD_VAR 0 1
132158: ARRAY
132159: PUSH
132160: LD_VAR 0 2
132164: ARRAY
132165: PUSH
132166: LD_INT 1
132168: ARRAY
132169: PPUSH
132170: LD_EXP 217
132174: PUSH
132175: LD_VAR 0 1
132179: ARRAY
132180: PUSH
132181: LD_VAR 0 2
132185: ARRAY
132186: PUSH
132187: LD_INT 2
132189: ARRAY
132190: PPUSH
132191: CALL_OW 458
132195: AND
132196: IFFALSE 132290
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
132198: LD_EXP 217
132202: PUSH
132203: LD_VAR 0 1
132207: ARRAY
132208: PUSH
132209: LD_VAR 0 2
132213: ARRAY
132214: PUSH
132215: LD_INT 1
132217: ARRAY
132218: PPUSH
132219: LD_EXP 217
132223: PUSH
132224: LD_VAR 0 1
132228: ARRAY
132229: PUSH
132230: LD_VAR 0 2
132234: ARRAY
132235: PUSH
132236: LD_INT 2
132238: ARRAY
132239: PPUSH
132240: LD_VAR 0 3
132244: PPUSH
132245: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
132249: LD_ADDR_EXP 217
132253: PUSH
132254: LD_EXP 217
132258: PPUSH
132259: LD_VAR 0 1
132263: PPUSH
132264: LD_EXP 217
132268: PUSH
132269: LD_VAR 0 1
132273: ARRAY
132274: PPUSH
132275: LD_VAR 0 2
132279: PPUSH
132280: CALL_OW 3
132284: PPUSH
132285: CALL_OW 1
132289: ST_TO_ADDR
// end ; end ;
132290: GO 132041
132292: POP
132293: POP
// end ;
132294: GO 131959
132296: POP
132297: POP
// end ;
132298: PPOPN 4
132300: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
132301: LD_INT 0
132303: PPUSH
132304: PPUSH
// result := false ;
132305: LD_ADDR_VAR 0 4
132309: PUSH
132310: LD_INT 0
132312: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
132313: LD_VAR 0 1
132317: PPUSH
132318: CALL_OW 264
132322: PUSH
132323: LD_INT 81
132325: EQUAL
132326: NOT
132327: IFFALSE 132331
// exit ;
132329: GO 132571
// index := GetElementIndex ( minersList , unit ) ;
132331: LD_ADDR_VAR 0 5
132335: PUSH
132336: LD_EXP 216
132340: PPUSH
132341: LD_VAR 0 1
132345: PPUSH
132346: CALL 75029 0 2
132350: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
132351: LD_EXP 217
132355: PUSH
132356: LD_VAR 0 5
132360: ARRAY
132361: PUSH
132362: LD_EXP 218
132366: GREATEREQUAL
132367: IFFALSE 132371
// exit ;
132369: GO 132571
// ComMoveXY ( unit , x , y ) ;
132371: LD_VAR 0 1
132375: PPUSH
132376: LD_VAR 0 2
132380: PPUSH
132381: LD_VAR 0 3
132385: PPUSH
132386: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132390: LD_INT 35
132392: PPUSH
132393: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
132397: LD_VAR 0 1
132401: PPUSH
132402: LD_VAR 0 2
132406: PPUSH
132407: LD_VAR 0 3
132411: PPUSH
132412: CALL 106770 0 3
132416: NOT
132417: PUSH
132418: LD_VAR 0 1
132422: PPUSH
132423: CALL_OW 314
132427: AND
132428: IFFALSE 132432
// exit ;
132430: GO 132571
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
132432: LD_VAR 0 2
132436: PPUSH
132437: LD_VAR 0 3
132441: PPUSH
132442: CALL_OW 428
132446: PUSH
132447: LD_VAR 0 1
132451: EQUAL
132452: PUSH
132453: LD_VAR 0 1
132457: PPUSH
132458: CALL_OW 314
132462: NOT
132463: AND
132464: IFFALSE 132390
// PlaySoundXY ( x , y , PlantMine ) ;
132466: LD_VAR 0 2
132470: PPUSH
132471: LD_VAR 0 3
132475: PPUSH
132476: LD_STRING PlantMine
132478: PPUSH
132479: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
132483: LD_VAR 0 2
132487: PPUSH
132488: LD_VAR 0 3
132492: PPUSH
132493: LD_VAR 0 1
132497: PPUSH
132498: CALL_OW 255
132502: PPUSH
132503: LD_INT 0
132505: PPUSH
132506: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
132510: LD_ADDR_EXP 217
132514: PUSH
132515: LD_EXP 217
132519: PPUSH
132520: LD_VAR 0 5
132524: PUSH
132525: LD_EXP 217
132529: PUSH
132530: LD_VAR 0 5
132534: ARRAY
132535: PUSH
132536: LD_INT 1
132538: PLUS
132539: PUSH
132540: EMPTY
132541: LIST
132542: LIST
132543: PPUSH
132544: LD_VAR 0 2
132548: PUSH
132549: LD_VAR 0 3
132553: PUSH
132554: EMPTY
132555: LIST
132556: LIST
132557: PPUSH
132558: CALL 75244 0 3
132562: ST_TO_ADDR
// result := true ;
132563: LD_ADDR_VAR 0 4
132567: PUSH
132568: LD_INT 1
132570: ST_TO_ADDR
// end ;
132571: LD_VAR 0 4
132575: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
132576: LD_INT 0
132578: PPUSH
132579: PPUSH
132580: PPUSH
// if not unit in minersList then
132581: LD_VAR 0 1
132585: PUSH
132586: LD_EXP 216
132590: IN
132591: NOT
132592: IFFALSE 132596
// exit ;
132594: GO 132988
// index := GetElementIndex ( minersList , unit ) ;
132596: LD_ADDR_VAR 0 6
132600: PUSH
132601: LD_EXP 216
132605: PPUSH
132606: LD_VAR 0 1
132610: PPUSH
132611: CALL 75029 0 2
132615: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
132616: LD_ADDR_VAR 0 5
132620: PUSH
132621: DOUBLE
132622: LD_EXP 217
132626: PUSH
132627: LD_VAR 0 6
132631: ARRAY
132632: INC
132633: ST_TO_ADDR
132634: LD_INT 1
132636: PUSH
132637: FOR_DOWNTO
132638: IFFALSE 132799
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
132640: LD_EXP 217
132644: PUSH
132645: LD_VAR 0 6
132649: ARRAY
132650: PUSH
132651: LD_VAR 0 5
132655: ARRAY
132656: PUSH
132657: LD_INT 1
132659: ARRAY
132660: PUSH
132661: LD_VAR 0 2
132665: EQUAL
132666: PUSH
132667: LD_EXP 217
132671: PUSH
132672: LD_VAR 0 6
132676: ARRAY
132677: PUSH
132678: LD_VAR 0 5
132682: ARRAY
132683: PUSH
132684: LD_INT 2
132686: ARRAY
132687: PUSH
132688: LD_VAR 0 3
132692: EQUAL
132693: AND
132694: IFFALSE 132797
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132696: LD_EXP 217
132700: PUSH
132701: LD_VAR 0 6
132705: ARRAY
132706: PUSH
132707: LD_VAR 0 5
132711: ARRAY
132712: PUSH
132713: LD_INT 1
132715: ARRAY
132716: PPUSH
132717: LD_EXP 217
132721: PUSH
132722: LD_VAR 0 6
132726: ARRAY
132727: PUSH
132728: LD_VAR 0 5
132732: ARRAY
132733: PUSH
132734: LD_INT 2
132736: ARRAY
132737: PPUSH
132738: LD_VAR 0 1
132742: PPUSH
132743: CALL_OW 255
132747: PPUSH
132748: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132752: LD_ADDR_EXP 217
132756: PUSH
132757: LD_EXP 217
132761: PPUSH
132762: LD_VAR 0 6
132766: PPUSH
132767: LD_EXP 217
132771: PUSH
132772: LD_VAR 0 6
132776: ARRAY
132777: PPUSH
132778: LD_VAR 0 5
132782: PPUSH
132783: CALL_OW 3
132787: PPUSH
132788: CALL_OW 1
132792: ST_TO_ADDR
// exit ;
132793: POP
132794: POP
132795: GO 132988
// end ; end ;
132797: GO 132637
132799: POP
132800: POP
// for i := minerMinesList [ index ] downto 1 do
132801: LD_ADDR_VAR 0 5
132805: PUSH
132806: DOUBLE
132807: LD_EXP 217
132811: PUSH
132812: LD_VAR 0 6
132816: ARRAY
132817: INC
132818: ST_TO_ADDR
132819: LD_INT 1
132821: PUSH
132822: FOR_DOWNTO
132823: IFFALSE 132986
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
132825: LD_EXP 217
132829: PUSH
132830: LD_VAR 0 6
132834: ARRAY
132835: PUSH
132836: LD_VAR 0 5
132840: ARRAY
132841: PUSH
132842: LD_INT 1
132844: ARRAY
132845: PPUSH
132846: LD_EXP 217
132850: PUSH
132851: LD_VAR 0 6
132855: ARRAY
132856: PUSH
132857: LD_VAR 0 5
132861: ARRAY
132862: PUSH
132863: LD_INT 2
132865: ARRAY
132866: PPUSH
132867: LD_VAR 0 2
132871: PPUSH
132872: LD_VAR 0 3
132876: PPUSH
132877: CALL_OW 298
132881: PUSH
132882: LD_INT 6
132884: LESS
132885: IFFALSE 132984
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132887: LD_EXP 217
132891: PUSH
132892: LD_VAR 0 6
132896: ARRAY
132897: PUSH
132898: LD_VAR 0 5
132902: ARRAY
132903: PUSH
132904: LD_INT 1
132906: ARRAY
132907: PPUSH
132908: LD_EXP 217
132912: PUSH
132913: LD_VAR 0 6
132917: ARRAY
132918: PUSH
132919: LD_VAR 0 5
132923: ARRAY
132924: PUSH
132925: LD_INT 2
132927: ARRAY
132928: PPUSH
132929: LD_VAR 0 1
132933: PPUSH
132934: CALL_OW 255
132938: PPUSH
132939: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132943: LD_ADDR_EXP 217
132947: PUSH
132948: LD_EXP 217
132952: PPUSH
132953: LD_VAR 0 6
132957: PPUSH
132958: LD_EXP 217
132962: PUSH
132963: LD_VAR 0 6
132967: ARRAY
132968: PPUSH
132969: LD_VAR 0 5
132973: PPUSH
132974: CALL_OW 3
132978: PPUSH
132979: CALL_OW 1
132983: ST_TO_ADDR
// end ; end ;
132984: GO 132822
132986: POP
132987: POP
// end ;
132988: LD_VAR 0 4
132992: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
132993: LD_INT 0
132995: PPUSH
132996: PPUSH
132997: PPUSH
132998: PPUSH
132999: PPUSH
133000: PPUSH
133001: PPUSH
133002: PPUSH
133003: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
133004: LD_VAR 0 1
133008: PPUSH
133009: CALL_OW 264
133013: PUSH
133014: LD_INT 81
133016: EQUAL
133017: NOT
133018: PUSH
133019: LD_VAR 0 1
133023: PUSH
133024: LD_EXP 216
133028: IN
133029: NOT
133030: OR
133031: IFFALSE 133035
// exit ;
133033: GO 133357
// index := GetElementIndex ( minersList , unit ) ;
133035: LD_ADDR_VAR 0 6
133039: PUSH
133040: LD_EXP 216
133044: PPUSH
133045: LD_VAR 0 1
133049: PPUSH
133050: CALL 75029 0 2
133054: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
133055: LD_ADDR_VAR 0 8
133059: PUSH
133060: LD_EXP 218
133064: PUSH
133065: LD_EXP 217
133069: PUSH
133070: LD_VAR 0 6
133074: ARRAY
133075: MINUS
133076: ST_TO_ADDR
// if not minesFreeAmount then
133077: LD_VAR 0 8
133081: NOT
133082: IFFALSE 133086
// exit ;
133084: GO 133357
// tmp := [ ] ;
133086: LD_ADDR_VAR 0 7
133090: PUSH
133091: EMPTY
133092: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
133093: LD_ADDR_VAR 0 5
133097: PUSH
133098: DOUBLE
133099: LD_INT 1
133101: DEC
133102: ST_TO_ADDR
133103: LD_VAR 0 8
133107: PUSH
133108: FOR_TO
133109: IFFALSE 133304
// begin _d := rand ( 0 , 5 ) ;
133111: LD_ADDR_VAR 0 11
133115: PUSH
133116: LD_INT 0
133118: PPUSH
133119: LD_INT 5
133121: PPUSH
133122: CALL_OW 12
133126: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
133127: LD_ADDR_VAR 0 12
133131: PUSH
133132: LD_INT 2
133134: PPUSH
133135: LD_INT 6
133137: PPUSH
133138: CALL_OW 12
133142: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
133143: LD_ADDR_VAR 0 9
133147: PUSH
133148: LD_VAR 0 2
133152: PPUSH
133153: LD_VAR 0 11
133157: PPUSH
133158: LD_VAR 0 12
133162: PPUSH
133163: CALL_OW 272
133167: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
133168: LD_ADDR_VAR 0 10
133172: PUSH
133173: LD_VAR 0 3
133177: PPUSH
133178: LD_VAR 0 11
133182: PPUSH
133183: LD_VAR 0 12
133187: PPUSH
133188: CALL_OW 273
133192: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
133193: LD_VAR 0 9
133197: PPUSH
133198: LD_VAR 0 10
133202: PPUSH
133203: CALL_OW 488
133207: PUSH
133208: LD_VAR 0 9
133212: PUSH
133213: LD_VAR 0 10
133217: PUSH
133218: EMPTY
133219: LIST
133220: LIST
133221: PUSH
133222: LD_VAR 0 7
133226: IN
133227: NOT
133228: AND
133229: PUSH
133230: LD_VAR 0 9
133234: PPUSH
133235: LD_VAR 0 10
133239: PPUSH
133240: CALL_OW 458
133244: NOT
133245: AND
133246: IFFALSE 133288
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
133248: LD_ADDR_VAR 0 7
133252: PUSH
133253: LD_VAR 0 7
133257: PPUSH
133258: LD_VAR 0 7
133262: PUSH
133263: LD_INT 1
133265: PLUS
133266: PPUSH
133267: LD_VAR 0 9
133271: PUSH
133272: LD_VAR 0 10
133276: PUSH
133277: EMPTY
133278: LIST
133279: LIST
133280: PPUSH
133281: CALL_OW 1
133285: ST_TO_ADDR
133286: GO 133302
// i := i - 1 ;
133288: LD_ADDR_VAR 0 5
133292: PUSH
133293: LD_VAR 0 5
133297: PUSH
133298: LD_INT 1
133300: MINUS
133301: ST_TO_ADDR
// end ;
133302: GO 133108
133304: POP
133305: POP
// for i in tmp do
133306: LD_ADDR_VAR 0 5
133310: PUSH
133311: LD_VAR 0 7
133315: PUSH
133316: FOR_IN
133317: IFFALSE 133355
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
133319: LD_VAR 0 1
133323: PPUSH
133324: LD_VAR 0 5
133328: PUSH
133329: LD_INT 1
133331: ARRAY
133332: PPUSH
133333: LD_VAR 0 5
133337: PUSH
133338: LD_INT 2
133340: ARRAY
133341: PPUSH
133342: CALL 132301 0 3
133346: NOT
133347: IFFALSE 133353
// exit ;
133349: POP
133350: POP
133351: GO 133357
133353: GO 133316
133355: POP
133356: POP
// end ;
133357: LD_VAR 0 4
133361: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
133362: LD_INT 0
133364: PPUSH
133365: PPUSH
133366: PPUSH
133367: PPUSH
133368: PPUSH
133369: PPUSH
133370: PPUSH
// if not GetClass ( unit ) = class_sniper then
133371: LD_VAR 0 1
133375: PPUSH
133376: CALL_OW 257
133380: PUSH
133381: LD_INT 5
133383: EQUAL
133384: NOT
133385: IFFALSE 133389
// exit ;
133387: GO 133777
// dist := 8 ;
133389: LD_ADDR_VAR 0 5
133393: PUSH
133394: LD_INT 8
133396: ST_TO_ADDR
// viewRange := 12 ;
133397: LD_ADDR_VAR 0 7
133401: PUSH
133402: LD_INT 12
133404: ST_TO_ADDR
// side := GetSide ( unit ) ;
133405: LD_ADDR_VAR 0 6
133409: PUSH
133410: LD_VAR 0 1
133414: PPUSH
133415: CALL_OW 255
133419: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
133420: LD_INT 61
133422: PPUSH
133423: LD_VAR 0 6
133427: PPUSH
133428: CALL_OW 321
133432: PUSH
133433: LD_INT 2
133435: EQUAL
133436: IFFALSE 133446
// viewRange := 16 ;
133438: LD_ADDR_VAR 0 7
133442: PUSH
133443: LD_INT 16
133445: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
133446: LD_VAR 0 1
133450: PPUSH
133451: LD_VAR 0 2
133455: PPUSH
133456: LD_VAR 0 3
133460: PPUSH
133461: CALL_OW 297
133465: PUSH
133466: LD_VAR 0 5
133470: GREATER
133471: IFFALSE 133550
// begin ComMoveXY ( unit , x , y ) ;
133473: LD_VAR 0 1
133477: PPUSH
133478: LD_VAR 0 2
133482: PPUSH
133483: LD_VAR 0 3
133487: PPUSH
133488: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
133492: LD_INT 35
133494: PPUSH
133495: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
133499: LD_VAR 0 1
133503: PPUSH
133504: LD_VAR 0 2
133508: PPUSH
133509: LD_VAR 0 3
133513: PPUSH
133514: CALL 106770 0 3
133518: NOT
133519: IFFALSE 133523
// exit ;
133521: GO 133777
// until GetDistUnitXY ( unit , x , y ) < dist ;
133523: LD_VAR 0 1
133527: PPUSH
133528: LD_VAR 0 2
133532: PPUSH
133533: LD_VAR 0 3
133537: PPUSH
133538: CALL_OW 297
133542: PUSH
133543: LD_VAR 0 5
133547: LESS
133548: IFFALSE 133492
// end ; ComTurnXY ( unit , x , y ) ;
133550: LD_VAR 0 1
133554: PPUSH
133555: LD_VAR 0 2
133559: PPUSH
133560: LD_VAR 0 3
133564: PPUSH
133565: CALL_OW 118
// wait ( 5 ) ;
133569: LD_INT 5
133571: PPUSH
133572: CALL_OW 67
// _d := GetDir ( unit ) ;
133576: LD_ADDR_VAR 0 10
133580: PUSH
133581: LD_VAR 0 1
133585: PPUSH
133586: CALL_OW 254
133590: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
133591: LD_ADDR_VAR 0 8
133595: PUSH
133596: LD_VAR 0 1
133600: PPUSH
133601: CALL_OW 250
133605: PPUSH
133606: LD_VAR 0 10
133610: PPUSH
133611: LD_VAR 0 5
133615: PPUSH
133616: CALL_OW 272
133620: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
133621: LD_ADDR_VAR 0 9
133625: PUSH
133626: LD_VAR 0 1
133630: PPUSH
133631: CALL_OW 251
133635: PPUSH
133636: LD_VAR 0 10
133640: PPUSH
133641: LD_VAR 0 5
133645: PPUSH
133646: CALL_OW 273
133650: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
133651: LD_VAR 0 8
133655: PPUSH
133656: LD_VAR 0 9
133660: PPUSH
133661: CALL_OW 488
133665: NOT
133666: IFFALSE 133670
// exit ;
133668: GO 133777
// ComAnimCustom ( unit , 1 ) ;
133670: LD_VAR 0 1
133674: PPUSH
133675: LD_INT 1
133677: PPUSH
133678: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
133682: LD_VAR 0 8
133686: PPUSH
133687: LD_VAR 0 9
133691: PPUSH
133692: LD_VAR 0 6
133696: PPUSH
133697: LD_VAR 0 7
133701: PPUSH
133702: CALL_OW 330
// repeat wait ( 1 ) ;
133706: LD_INT 1
133708: PPUSH
133709: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
133713: LD_VAR 0 1
133717: PPUSH
133718: CALL_OW 316
133722: PUSH
133723: LD_VAR 0 1
133727: PPUSH
133728: CALL_OW 314
133732: OR
133733: PUSH
133734: LD_VAR 0 1
133738: PPUSH
133739: CALL_OW 302
133743: NOT
133744: OR
133745: PUSH
133746: LD_VAR 0 1
133750: PPUSH
133751: CALL_OW 301
133755: OR
133756: IFFALSE 133706
// RemoveSeeing ( _x , _y , side ) ;
133758: LD_VAR 0 8
133762: PPUSH
133763: LD_VAR 0 9
133767: PPUSH
133768: LD_VAR 0 6
133772: PPUSH
133773: CALL_OW 331
// end ; end_of_file
133777: LD_VAR 0 4
133781: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
133782: LD_INT 0
133784: PPUSH
133785: PPUSH
133786: PPUSH
133787: PPUSH
133788: PPUSH
133789: PPUSH
133790: PPUSH
133791: PPUSH
133792: PPUSH
133793: PPUSH
133794: PPUSH
133795: PPUSH
133796: PPUSH
133797: PPUSH
133798: PPUSH
133799: PPUSH
133800: PPUSH
133801: PPUSH
133802: PPUSH
133803: PPUSH
133804: PPUSH
133805: PPUSH
133806: PPUSH
133807: PPUSH
133808: PPUSH
133809: PPUSH
133810: PPUSH
133811: PPUSH
133812: PPUSH
133813: PPUSH
133814: PPUSH
133815: PPUSH
133816: PPUSH
133817: PPUSH
// if not list then
133818: LD_VAR 0 1
133822: NOT
133823: IFFALSE 133827
// exit ;
133825: GO 138486
// base := list [ 1 ] ;
133827: LD_ADDR_VAR 0 3
133831: PUSH
133832: LD_VAR 0 1
133836: PUSH
133837: LD_INT 1
133839: ARRAY
133840: ST_TO_ADDR
// group := list [ 2 ] ;
133841: LD_ADDR_VAR 0 4
133845: PUSH
133846: LD_VAR 0 1
133850: PUSH
133851: LD_INT 2
133853: ARRAY
133854: ST_TO_ADDR
// path := list [ 3 ] ;
133855: LD_ADDR_VAR 0 5
133859: PUSH
133860: LD_VAR 0 1
133864: PUSH
133865: LD_INT 3
133867: ARRAY
133868: ST_TO_ADDR
// flags := list [ 4 ] ;
133869: LD_ADDR_VAR 0 6
133873: PUSH
133874: LD_VAR 0 1
133878: PUSH
133879: LD_INT 4
133881: ARRAY
133882: ST_TO_ADDR
// mined := [ ] ;
133883: LD_ADDR_VAR 0 27
133887: PUSH
133888: EMPTY
133889: ST_TO_ADDR
// bombed := [ ] ;
133890: LD_ADDR_VAR 0 28
133894: PUSH
133895: EMPTY
133896: ST_TO_ADDR
// healers := [ ] ;
133897: LD_ADDR_VAR 0 31
133901: PUSH
133902: EMPTY
133903: ST_TO_ADDR
// to_heal := [ ] ;
133904: LD_ADDR_VAR 0 30
133908: PUSH
133909: EMPTY
133910: ST_TO_ADDR
// repairs := [ ] ;
133911: LD_ADDR_VAR 0 33
133915: PUSH
133916: EMPTY
133917: ST_TO_ADDR
// to_repair := [ ] ;
133918: LD_ADDR_VAR 0 32
133922: PUSH
133923: EMPTY
133924: ST_TO_ADDR
// if not group or not path then
133925: LD_VAR 0 4
133929: NOT
133930: PUSH
133931: LD_VAR 0 5
133935: NOT
133936: OR
133937: IFFALSE 133941
// exit ;
133939: GO 138486
// side := GetSide ( group [ 1 ] ) ;
133941: LD_ADDR_VAR 0 35
133945: PUSH
133946: LD_VAR 0 4
133950: PUSH
133951: LD_INT 1
133953: ARRAY
133954: PPUSH
133955: CALL_OW 255
133959: ST_TO_ADDR
// if flags then
133960: LD_VAR 0 6
133964: IFFALSE 134108
// begin f_ignore_area := flags [ 1 ] ;
133966: LD_ADDR_VAR 0 17
133970: PUSH
133971: LD_VAR 0 6
133975: PUSH
133976: LD_INT 1
133978: ARRAY
133979: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
133980: LD_ADDR_VAR 0 18
133984: PUSH
133985: LD_VAR 0 6
133989: PUSH
133990: LD_INT 2
133992: ARRAY
133993: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
133994: LD_ADDR_VAR 0 19
133998: PUSH
133999: LD_VAR 0 6
134003: PUSH
134004: LD_INT 3
134006: ARRAY
134007: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
134008: LD_ADDR_VAR 0 20
134012: PUSH
134013: LD_VAR 0 6
134017: PUSH
134018: LD_INT 4
134020: ARRAY
134021: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
134022: LD_ADDR_VAR 0 21
134026: PUSH
134027: LD_VAR 0 6
134031: PUSH
134032: LD_INT 5
134034: ARRAY
134035: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
134036: LD_ADDR_VAR 0 22
134040: PUSH
134041: LD_VAR 0 6
134045: PUSH
134046: LD_INT 6
134048: ARRAY
134049: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
134050: LD_ADDR_VAR 0 23
134054: PUSH
134055: LD_VAR 0 6
134059: PUSH
134060: LD_INT 7
134062: ARRAY
134063: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
134064: LD_ADDR_VAR 0 24
134068: PUSH
134069: LD_VAR 0 6
134073: PUSH
134074: LD_INT 8
134076: ARRAY
134077: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
134078: LD_ADDR_VAR 0 25
134082: PUSH
134083: LD_VAR 0 6
134087: PUSH
134088: LD_INT 9
134090: ARRAY
134091: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
134092: LD_ADDR_VAR 0 26
134096: PUSH
134097: LD_VAR 0 6
134101: PUSH
134102: LD_INT 10
134104: ARRAY
134105: ST_TO_ADDR
// end else
134106: GO 134188
// begin f_ignore_area := false ;
134108: LD_ADDR_VAR 0 17
134112: PUSH
134113: LD_INT 0
134115: ST_TO_ADDR
// f_capture := false ;
134116: LD_ADDR_VAR 0 18
134120: PUSH
134121: LD_INT 0
134123: ST_TO_ADDR
// f_ignore_civ := false ;
134124: LD_ADDR_VAR 0 19
134128: PUSH
134129: LD_INT 0
134131: ST_TO_ADDR
// f_murder := false ;
134132: LD_ADDR_VAR 0 20
134136: PUSH
134137: LD_INT 0
134139: ST_TO_ADDR
// f_mines := false ;
134140: LD_ADDR_VAR 0 21
134144: PUSH
134145: LD_INT 0
134147: ST_TO_ADDR
// f_repair := false ;
134148: LD_ADDR_VAR 0 22
134152: PUSH
134153: LD_INT 0
134155: ST_TO_ADDR
// f_heal := false ;
134156: LD_ADDR_VAR 0 23
134160: PUSH
134161: LD_INT 0
134163: ST_TO_ADDR
// f_spacetime := false ;
134164: LD_ADDR_VAR 0 24
134168: PUSH
134169: LD_INT 0
134171: ST_TO_ADDR
// f_attack_depot := false ;
134172: LD_ADDR_VAR 0 25
134176: PUSH
134177: LD_INT 0
134179: ST_TO_ADDR
// f_crawl := false ;
134180: LD_ADDR_VAR 0 26
134184: PUSH
134185: LD_INT 0
134187: ST_TO_ADDR
// end ; if f_heal then
134188: LD_VAR 0 23
134192: IFFALSE 134219
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
134194: LD_ADDR_VAR 0 31
134198: PUSH
134199: LD_VAR 0 4
134203: PPUSH
134204: LD_INT 25
134206: PUSH
134207: LD_INT 4
134209: PUSH
134210: EMPTY
134211: LIST
134212: LIST
134213: PPUSH
134214: CALL_OW 72
134218: ST_TO_ADDR
// if f_repair then
134219: LD_VAR 0 22
134223: IFFALSE 134250
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
134225: LD_ADDR_VAR 0 33
134229: PUSH
134230: LD_VAR 0 4
134234: PPUSH
134235: LD_INT 25
134237: PUSH
134238: LD_INT 3
134240: PUSH
134241: EMPTY
134242: LIST
134243: LIST
134244: PPUSH
134245: CALL_OW 72
134249: ST_TO_ADDR
// units_path := [ ] ;
134250: LD_ADDR_VAR 0 16
134254: PUSH
134255: EMPTY
134256: ST_TO_ADDR
// for i = 1 to group do
134257: LD_ADDR_VAR 0 7
134261: PUSH
134262: DOUBLE
134263: LD_INT 1
134265: DEC
134266: ST_TO_ADDR
134267: LD_VAR 0 4
134271: PUSH
134272: FOR_TO
134273: IFFALSE 134302
// units_path := Replace ( units_path , i , path ) ;
134275: LD_ADDR_VAR 0 16
134279: PUSH
134280: LD_VAR 0 16
134284: PPUSH
134285: LD_VAR 0 7
134289: PPUSH
134290: LD_VAR 0 5
134294: PPUSH
134295: CALL_OW 1
134299: ST_TO_ADDR
134300: GO 134272
134302: POP
134303: POP
// repeat for i = group downto 1 do
134304: LD_ADDR_VAR 0 7
134308: PUSH
134309: DOUBLE
134310: LD_VAR 0 4
134314: INC
134315: ST_TO_ADDR
134316: LD_INT 1
134318: PUSH
134319: FOR_DOWNTO
134320: IFFALSE 138442
// begin wait ( 5 ) ;
134322: LD_INT 5
134324: PPUSH
134325: CALL_OW 67
// tmp := [ ] ;
134329: LD_ADDR_VAR 0 14
134333: PUSH
134334: EMPTY
134335: ST_TO_ADDR
// attacking := false ;
134336: LD_ADDR_VAR 0 29
134340: PUSH
134341: LD_INT 0
134343: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
134344: LD_VAR 0 4
134348: PUSH
134349: LD_VAR 0 7
134353: ARRAY
134354: PPUSH
134355: CALL_OW 301
134359: PUSH
134360: LD_VAR 0 4
134364: PUSH
134365: LD_VAR 0 7
134369: ARRAY
134370: NOT
134371: OR
134372: IFFALSE 134481
// begin if GetType ( group [ i ] ) = unit_human then
134374: LD_VAR 0 4
134378: PUSH
134379: LD_VAR 0 7
134383: ARRAY
134384: PPUSH
134385: CALL_OW 247
134389: PUSH
134390: LD_INT 1
134392: EQUAL
134393: IFFALSE 134439
// begin to_heal := to_heal diff group [ i ] ;
134395: LD_ADDR_VAR 0 30
134399: PUSH
134400: LD_VAR 0 30
134404: PUSH
134405: LD_VAR 0 4
134409: PUSH
134410: LD_VAR 0 7
134414: ARRAY
134415: DIFF
134416: ST_TO_ADDR
// healers := healers diff group [ i ] ;
134417: LD_ADDR_VAR 0 31
134421: PUSH
134422: LD_VAR 0 31
134426: PUSH
134427: LD_VAR 0 4
134431: PUSH
134432: LD_VAR 0 7
134436: ARRAY
134437: DIFF
134438: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
134439: LD_ADDR_VAR 0 4
134443: PUSH
134444: LD_VAR 0 4
134448: PPUSH
134449: LD_VAR 0 7
134453: PPUSH
134454: CALL_OW 3
134458: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
134459: LD_ADDR_VAR 0 16
134463: PUSH
134464: LD_VAR 0 16
134468: PPUSH
134469: LD_VAR 0 7
134473: PPUSH
134474: CALL_OW 3
134478: ST_TO_ADDR
// continue ;
134479: GO 134319
// end ; if f_repair then
134481: LD_VAR 0 22
134485: IFFALSE 134974
// begin if GetType ( group [ i ] ) = unit_vehicle then
134487: LD_VAR 0 4
134491: PUSH
134492: LD_VAR 0 7
134496: ARRAY
134497: PPUSH
134498: CALL_OW 247
134502: PUSH
134503: LD_INT 2
134505: EQUAL
134506: IFFALSE 134696
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
134508: LD_VAR 0 4
134512: PUSH
134513: LD_VAR 0 7
134517: ARRAY
134518: PPUSH
134519: CALL_OW 256
134523: PUSH
134524: LD_INT 700
134526: LESS
134527: PUSH
134528: LD_VAR 0 4
134532: PUSH
134533: LD_VAR 0 7
134537: ARRAY
134538: PUSH
134539: LD_VAR 0 32
134543: IN
134544: NOT
134545: AND
134546: IFFALSE 134570
// to_repair := to_repair union group [ i ] ;
134548: LD_ADDR_VAR 0 32
134552: PUSH
134553: LD_VAR 0 32
134557: PUSH
134558: LD_VAR 0 4
134562: PUSH
134563: LD_VAR 0 7
134567: ARRAY
134568: UNION
134569: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
134570: LD_VAR 0 4
134574: PUSH
134575: LD_VAR 0 7
134579: ARRAY
134580: PPUSH
134581: CALL_OW 256
134585: PUSH
134586: LD_INT 1000
134588: EQUAL
134589: PUSH
134590: LD_VAR 0 4
134594: PUSH
134595: LD_VAR 0 7
134599: ARRAY
134600: PUSH
134601: LD_VAR 0 32
134605: IN
134606: AND
134607: IFFALSE 134631
// to_repair := to_repair diff group [ i ] ;
134609: LD_ADDR_VAR 0 32
134613: PUSH
134614: LD_VAR 0 32
134618: PUSH
134619: LD_VAR 0 4
134623: PUSH
134624: LD_VAR 0 7
134628: ARRAY
134629: DIFF
134630: ST_TO_ADDR
// if group [ i ] in to_repair then
134631: LD_VAR 0 4
134635: PUSH
134636: LD_VAR 0 7
134640: ARRAY
134641: PUSH
134642: LD_VAR 0 32
134646: IN
134647: IFFALSE 134694
// begin if not IsInArea ( group [ i ] , f_repair ) then
134649: LD_VAR 0 4
134653: PUSH
134654: LD_VAR 0 7
134658: ARRAY
134659: PPUSH
134660: LD_VAR 0 22
134664: PPUSH
134665: CALL_OW 308
134669: NOT
134670: IFFALSE 134692
// ComMoveToArea ( group [ i ] , f_repair ) ;
134672: LD_VAR 0 4
134676: PUSH
134677: LD_VAR 0 7
134681: ARRAY
134682: PPUSH
134683: LD_VAR 0 22
134687: PPUSH
134688: CALL_OW 113
// continue ;
134692: GO 134319
// end ; end else
134694: GO 134974
// if group [ i ] in repairs then
134696: LD_VAR 0 4
134700: PUSH
134701: LD_VAR 0 7
134705: ARRAY
134706: PUSH
134707: LD_VAR 0 33
134711: IN
134712: IFFALSE 134974
// begin if IsInUnit ( group [ i ] ) then
134714: LD_VAR 0 4
134718: PUSH
134719: LD_VAR 0 7
134723: ARRAY
134724: PPUSH
134725: CALL_OW 310
134729: IFFALSE 134797
// begin z := IsInUnit ( group [ i ] ) ;
134731: LD_ADDR_VAR 0 13
134735: PUSH
134736: LD_VAR 0 4
134740: PUSH
134741: LD_VAR 0 7
134745: ARRAY
134746: PPUSH
134747: CALL_OW 310
134751: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
134752: LD_VAR 0 13
134756: PUSH
134757: LD_VAR 0 32
134761: IN
134762: PUSH
134763: LD_VAR 0 13
134767: PPUSH
134768: LD_VAR 0 22
134772: PPUSH
134773: CALL_OW 308
134777: AND
134778: IFFALSE 134795
// ComExitVehicle ( group [ i ] ) ;
134780: LD_VAR 0 4
134784: PUSH
134785: LD_VAR 0 7
134789: ARRAY
134790: PPUSH
134791: CALL_OW 121
// end else
134795: GO 134974
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
134797: LD_ADDR_VAR 0 13
134801: PUSH
134802: LD_VAR 0 4
134806: PPUSH
134807: LD_INT 95
134809: PUSH
134810: LD_VAR 0 22
134814: PUSH
134815: EMPTY
134816: LIST
134817: LIST
134818: PUSH
134819: LD_INT 58
134821: PUSH
134822: EMPTY
134823: LIST
134824: PUSH
134825: EMPTY
134826: LIST
134827: LIST
134828: PPUSH
134829: CALL_OW 72
134833: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
134834: LD_VAR 0 4
134838: PUSH
134839: LD_VAR 0 7
134843: ARRAY
134844: PPUSH
134845: CALL_OW 314
134849: NOT
134850: IFFALSE 134972
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
134852: LD_ADDR_VAR 0 10
134856: PUSH
134857: LD_VAR 0 13
134861: PPUSH
134862: LD_VAR 0 4
134866: PUSH
134867: LD_VAR 0 7
134871: ARRAY
134872: PPUSH
134873: CALL_OW 74
134877: ST_TO_ADDR
// if not x then
134878: LD_VAR 0 10
134882: NOT
134883: IFFALSE 134887
// continue ;
134885: GO 134319
// if GetLives ( x ) < 1000 then
134887: LD_VAR 0 10
134891: PPUSH
134892: CALL_OW 256
134896: PUSH
134897: LD_INT 1000
134899: LESS
134900: IFFALSE 134924
// ComRepairVehicle ( group [ i ] , x ) else
134902: LD_VAR 0 4
134906: PUSH
134907: LD_VAR 0 7
134911: ARRAY
134912: PPUSH
134913: LD_VAR 0 10
134917: PPUSH
134918: CALL_OW 129
134922: GO 134972
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
134924: LD_VAR 0 23
134928: PUSH
134929: LD_VAR 0 4
134933: PUSH
134934: LD_VAR 0 7
134938: ARRAY
134939: PPUSH
134940: CALL_OW 256
134944: PUSH
134945: LD_INT 1000
134947: LESS
134948: AND
134949: NOT
134950: IFFALSE 134972
// ComEnterUnit ( group [ i ] , x ) ;
134952: LD_VAR 0 4
134956: PUSH
134957: LD_VAR 0 7
134961: ARRAY
134962: PPUSH
134963: LD_VAR 0 10
134967: PPUSH
134968: CALL_OW 120
// end ; continue ;
134972: GO 134319
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
134974: LD_VAR 0 23
134978: PUSH
134979: LD_VAR 0 4
134983: PUSH
134984: LD_VAR 0 7
134988: ARRAY
134989: PPUSH
134990: CALL_OW 247
134994: PUSH
134995: LD_INT 1
134997: EQUAL
134998: AND
134999: IFFALSE 135477
// begin if group [ i ] in healers then
135001: LD_VAR 0 4
135005: PUSH
135006: LD_VAR 0 7
135010: ARRAY
135011: PUSH
135012: LD_VAR 0 31
135016: IN
135017: IFFALSE 135290
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
135019: LD_VAR 0 4
135023: PUSH
135024: LD_VAR 0 7
135028: ARRAY
135029: PPUSH
135030: LD_VAR 0 23
135034: PPUSH
135035: CALL_OW 308
135039: NOT
135040: PUSH
135041: LD_VAR 0 4
135045: PUSH
135046: LD_VAR 0 7
135050: ARRAY
135051: PPUSH
135052: CALL_OW 314
135056: NOT
135057: AND
135058: IFFALSE 135082
// ComMoveToArea ( group [ i ] , f_heal ) else
135060: LD_VAR 0 4
135064: PUSH
135065: LD_VAR 0 7
135069: ARRAY
135070: PPUSH
135071: LD_VAR 0 23
135075: PPUSH
135076: CALL_OW 113
135080: GO 135288
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
135082: LD_VAR 0 4
135086: PUSH
135087: LD_VAR 0 7
135091: ARRAY
135092: PPUSH
135093: CALL 105353 0 1
135097: PPUSH
135098: CALL_OW 256
135102: PUSH
135103: LD_INT 1000
135105: EQUAL
135106: IFFALSE 135125
// ComStop ( group [ i ] ) else
135108: LD_VAR 0 4
135112: PUSH
135113: LD_VAR 0 7
135117: ARRAY
135118: PPUSH
135119: CALL_OW 141
135123: GO 135288
// if not HasTask ( group [ i ] ) and to_heal then
135125: LD_VAR 0 4
135129: PUSH
135130: LD_VAR 0 7
135134: ARRAY
135135: PPUSH
135136: CALL_OW 314
135140: NOT
135141: PUSH
135142: LD_VAR 0 30
135146: AND
135147: IFFALSE 135288
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
135149: LD_ADDR_VAR 0 13
135153: PUSH
135154: LD_VAR 0 30
135158: PPUSH
135159: LD_INT 3
135161: PUSH
135162: LD_INT 54
135164: PUSH
135165: EMPTY
135166: LIST
135167: PUSH
135168: EMPTY
135169: LIST
135170: LIST
135171: PPUSH
135172: CALL_OW 72
135176: PPUSH
135177: LD_VAR 0 4
135181: PUSH
135182: LD_VAR 0 7
135186: ARRAY
135187: PPUSH
135188: CALL_OW 74
135192: ST_TO_ADDR
// if z then
135193: LD_VAR 0 13
135197: IFFALSE 135288
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
135199: LD_INT 91
135201: PUSH
135202: LD_VAR 0 13
135206: PUSH
135207: LD_INT 10
135209: PUSH
135210: EMPTY
135211: LIST
135212: LIST
135213: LIST
135214: PUSH
135215: LD_INT 81
135217: PUSH
135218: LD_VAR 0 13
135222: PPUSH
135223: CALL_OW 255
135227: PUSH
135228: EMPTY
135229: LIST
135230: LIST
135231: PUSH
135232: EMPTY
135233: LIST
135234: LIST
135235: PPUSH
135236: CALL_OW 69
135240: PUSH
135241: LD_INT 0
135243: EQUAL
135244: IFFALSE 135268
// ComHeal ( group [ i ] , z ) else
135246: LD_VAR 0 4
135250: PUSH
135251: LD_VAR 0 7
135255: ARRAY
135256: PPUSH
135257: LD_VAR 0 13
135261: PPUSH
135262: CALL_OW 128
135266: GO 135288
// ComMoveToArea ( group [ i ] , f_heal ) ;
135268: LD_VAR 0 4
135272: PUSH
135273: LD_VAR 0 7
135277: ARRAY
135278: PPUSH
135279: LD_VAR 0 23
135283: PPUSH
135284: CALL_OW 113
// end ; continue ;
135288: GO 134319
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
135290: LD_VAR 0 4
135294: PUSH
135295: LD_VAR 0 7
135299: ARRAY
135300: PPUSH
135301: CALL_OW 256
135305: PUSH
135306: LD_INT 700
135308: LESS
135309: PUSH
135310: LD_VAR 0 4
135314: PUSH
135315: LD_VAR 0 7
135319: ARRAY
135320: PUSH
135321: LD_VAR 0 30
135325: IN
135326: NOT
135327: AND
135328: IFFALSE 135352
// to_heal := to_heal union group [ i ] ;
135330: LD_ADDR_VAR 0 30
135334: PUSH
135335: LD_VAR 0 30
135339: PUSH
135340: LD_VAR 0 4
135344: PUSH
135345: LD_VAR 0 7
135349: ARRAY
135350: UNION
135351: ST_TO_ADDR
// if group [ i ] in to_heal then
135352: LD_VAR 0 4
135356: PUSH
135357: LD_VAR 0 7
135361: ARRAY
135362: PUSH
135363: LD_VAR 0 30
135367: IN
135368: IFFALSE 135477
// begin if GetLives ( group [ i ] ) = 1000 then
135370: LD_VAR 0 4
135374: PUSH
135375: LD_VAR 0 7
135379: ARRAY
135380: PPUSH
135381: CALL_OW 256
135385: PUSH
135386: LD_INT 1000
135388: EQUAL
135389: IFFALSE 135415
// to_heal := to_heal diff group [ i ] else
135391: LD_ADDR_VAR 0 30
135395: PUSH
135396: LD_VAR 0 30
135400: PUSH
135401: LD_VAR 0 4
135405: PUSH
135406: LD_VAR 0 7
135410: ARRAY
135411: DIFF
135412: ST_TO_ADDR
135413: GO 135477
// begin if not IsInArea ( group [ i ] , to_heal ) then
135415: LD_VAR 0 4
135419: PUSH
135420: LD_VAR 0 7
135424: ARRAY
135425: PPUSH
135426: LD_VAR 0 30
135430: PPUSH
135431: CALL_OW 308
135435: NOT
135436: IFFALSE 135460
// ComMoveToArea ( group [ i ] , f_heal ) else
135438: LD_VAR 0 4
135442: PUSH
135443: LD_VAR 0 7
135447: ARRAY
135448: PPUSH
135449: LD_VAR 0 23
135453: PPUSH
135454: CALL_OW 113
135458: GO 135475
// ComHold ( group [ i ] ) ;
135460: LD_VAR 0 4
135464: PUSH
135465: LD_VAR 0 7
135469: ARRAY
135470: PPUSH
135471: CALL_OW 140
// continue ;
135475: GO 134319
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
135477: LD_VAR 0 4
135481: PUSH
135482: LD_VAR 0 7
135486: ARRAY
135487: PPUSH
135488: LD_INT 10
135490: PPUSH
135491: CALL 103135 0 2
135495: NOT
135496: PUSH
135497: LD_VAR 0 16
135501: PUSH
135502: LD_VAR 0 7
135506: ARRAY
135507: PUSH
135508: EMPTY
135509: EQUAL
135510: NOT
135511: AND
135512: IFFALSE 135778
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
135514: LD_VAR 0 4
135518: PUSH
135519: LD_VAR 0 7
135523: ARRAY
135524: PPUSH
135525: CALL_OW 262
135529: PUSH
135530: LD_INT 1
135532: PUSH
135533: LD_INT 2
135535: PUSH
135536: EMPTY
135537: LIST
135538: LIST
135539: IN
135540: IFFALSE 135581
// if GetFuel ( group [ i ] ) < 10 then
135542: LD_VAR 0 4
135546: PUSH
135547: LD_VAR 0 7
135551: ARRAY
135552: PPUSH
135553: CALL_OW 261
135557: PUSH
135558: LD_INT 10
135560: LESS
135561: IFFALSE 135581
// SetFuel ( group [ i ] , 12 ) ;
135563: LD_VAR 0 4
135567: PUSH
135568: LD_VAR 0 7
135572: ARRAY
135573: PPUSH
135574: LD_INT 12
135576: PPUSH
135577: CALL_OW 240
// if units_path [ i ] then
135581: LD_VAR 0 16
135585: PUSH
135586: LD_VAR 0 7
135590: ARRAY
135591: IFFALSE 135776
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
135593: LD_VAR 0 4
135597: PUSH
135598: LD_VAR 0 7
135602: ARRAY
135603: PPUSH
135604: LD_VAR 0 16
135608: PUSH
135609: LD_VAR 0 7
135613: ARRAY
135614: PUSH
135615: LD_INT 1
135617: ARRAY
135618: PUSH
135619: LD_INT 1
135621: ARRAY
135622: PPUSH
135623: LD_VAR 0 16
135627: PUSH
135628: LD_VAR 0 7
135632: ARRAY
135633: PUSH
135634: LD_INT 1
135636: ARRAY
135637: PUSH
135638: LD_INT 2
135640: ARRAY
135641: PPUSH
135642: CALL_OW 297
135646: PUSH
135647: LD_INT 6
135649: GREATER
135650: IFFALSE 135725
// begin if not HasTask ( group [ i ] ) then
135652: LD_VAR 0 4
135656: PUSH
135657: LD_VAR 0 7
135661: ARRAY
135662: PPUSH
135663: CALL_OW 314
135667: NOT
135668: IFFALSE 135723
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
135670: LD_VAR 0 4
135674: PUSH
135675: LD_VAR 0 7
135679: ARRAY
135680: PPUSH
135681: LD_VAR 0 16
135685: PUSH
135686: LD_VAR 0 7
135690: ARRAY
135691: PUSH
135692: LD_INT 1
135694: ARRAY
135695: PUSH
135696: LD_INT 1
135698: ARRAY
135699: PPUSH
135700: LD_VAR 0 16
135704: PUSH
135705: LD_VAR 0 7
135709: ARRAY
135710: PUSH
135711: LD_INT 1
135713: ARRAY
135714: PUSH
135715: LD_INT 2
135717: ARRAY
135718: PPUSH
135719: CALL_OW 114
// end else
135723: GO 135776
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
135725: LD_ADDR_VAR 0 15
135729: PUSH
135730: LD_VAR 0 16
135734: PUSH
135735: LD_VAR 0 7
135739: ARRAY
135740: PPUSH
135741: LD_INT 1
135743: PPUSH
135744: CALL_OW 3
135748: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
135749: LD_ADDR_VAR 0 16
135753: PUSH
135754: LD_VAR 0 16
135758: PPUSH
135759: LD_VAR 0 7
135763: PPUSH
135764: LD_VAR 0 15
135768: PPUSH
135769: CALL_OW 1
135773: ST_TO_ADDR
// continue ;
135774: GO 134319
// end ; end ; end else
135776: GO 138440
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
135778: LD_ADDR_VAR 0 14
135782: PUSH
135783: LD_INT 81
135785: PUSH
135786: LD_VAR 0 4
135790: PUSH
135791: LD_VAR 0 7
135795: ARRAY
135796: PPUSH
135797: CALL_OW 255
135801: PUSH
135802: EMPTY
135803: LIST
135804: LIST
135805: PPUSH
135806: CALL_OW 69
135810: ST_TO_ADDR
// if not tmp then
135811: LD_VAR 0 14
135815: NOT
135816: IFFALSE 135820
// continue ;
135818: GO 134319
// if f_ignore_area then
135820: LD_VAR 0 17
135824: IFFALSE 135912
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
135826: LD_ADDR_VAR 0 15
135830: PUSH
135831: LD_VAR 0 14
135835: PPUSH
135836: LD_INT 3
135838: PUSH
135839: LD_INT 92
135841: PUSH
135842: LD_VAR 0 17
135846: PUSH
135847: LD_INT 1
135849: ARRAY
135850: PUSH
135851: LD_VAR 0 17
135855: PUSH
135856: LD_INT 2
135858: ARRAY
135859: PUSH
135860: LD_VAR 0 17
135864: PUSH
135865: LD_INT 3
135867: ARRAY
135868: PUSH
135869: EMPTY
135870: LIST
135871: LIST
135872: LIST
135873: LIST
135874: PUSH
135875: EMPTY
135876: LIST
135877: LIST
135878: PPUSH
135879: CALL_OW 72
135883: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135884: LD_VAR 0 14
135888: PUSH
135889: LD_VAR 0 15
135893: DIFF
135894: IFFALSE 135912
// tmp := tmp diff tmp2 ;
135896: LD_ADDR_VAR 0 14
135900: PUSH
135901: LD_VAR 0 14
135905: PUSH
135906: LD_VAR 0 15
135910: DIFF
135911: ST_TO_ADDR
// end ; if not f_murder then
135912: LD_VAR 0 20
135916: NOT
135917: IFFALSE 135975
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
135919: LD_ADDR_VAR 0 15
135923: PUSH
135924: LD_VAR 0 14
135928: PPUSH
135929: LD_INT 3
135931: PUSH
135932: LD_INT 50
135934: PUSH
135935: EMPTY
135936: LIST
135937: PUSH
135938: EMPTY
135939: LIST
135940: LIST
135941: PPUSH
135942: CALL_OW 72
135946: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135947: LD_VAR 0 14
135951: PUSH
135952: LD_VAR 0 15
135956: DIFF
135957: IFFALSE 135975
// tmp := tmp diff tmp2 ;
135959: LD_ADDR_VAR 0 14
135963: PUSH
135964: LD_VAR 0 14
135968: PUSH
135969: LD_VAR 0 15
135973: DIFF
135974: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
135975: LD_ADDR_VAR 0 14
135979: PUSH
135980: LD_VAR 0 4
135984: PUSH
135985: LD_VAR 0 7
135989: ARRAY
135990: PPUSH
135991: LD_VAR 0 14
135995: PPUSH
135996: LD_INT 1
135998: PPUSH
135999: LD_INT 1
136001: PPUSH
136002: CALL 75679 0 4
136006: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
136007: LD_VAR 0 4
136011: PUSH
136012: LD_VAR 0 7
136016: ARRAY
136017: PPUSH
136018: CALL_OW 257
136022: PUSH
136023: LD_INT 1
136025: EQUAL
136026: IFFALSE 136474
// begin if WantPlant ( group [ i ] ) then
136028: LD_VAR 0 4
136032: PUSH
136033: LD_VAR 0 7
136037: ARRAY
136038: PPUSH
136039: CALL 75180 0 1
136043: IFFALSE 136047
// continue ;
136045: GO 134319
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
136047: LD_VAR 0 18
136051: PUSH
136052: LD_VAR 0 4
136056: PUSH
136057: LD_VAR 0 7
136061: ARRAY
136062: PPUSH
136063: CALL_OW 310
136067: NOT
136068: AND
136069: PUSH
136070: LD_VAR 0 14
136074: PUSH
136075: LD_INT 1
136077: ARRAY
136078: PUSH
136079: LD_VAR 0 14
136083: PPUSH
136084: LD_INT 21
136086: PUSH
136087: LD_INT 2
136089: PUSH
136090: EMPTY
136091: LIST
136092: LIST
136093: PUSH
136094: LD_INT 58
136096: PUSH
136097: EMPTY
136098: LIST
136099: PUSH
136100: EMPTY
136101: LIST
136102: LIST
136103: PPUSH
136104: CALL_OW 72
136108: IN
136109: AND
136110: IFFALSE 136146
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
136112: LD_VAR 0 4
136116: PUSH
136117: LD_VAR 0 7
136121: ARRAY
136122: PPUSH
136123: LD_VAR 0 14
136127: PUSH
136128: LD_INT 1
136130: ARRAY
136131: PPUSH
136132: CALL_OW 120
// attacking := true ;
136136: LD_ADDR_VAR 0 29
136140: PUSH
136141: LD_INT 1
136143: ST_TO_ADDR
// continue ;
136144: GO 134319
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
136146: LD_VAR 0 26
136150: PUSH
136151: LD_VAR 0 4
136155: PUSH
136156: LD_VAR 0 7
136160: ARRAY
136161: PPUSH
136162: CALL_OW 257
136166: PUSH
136167: LD_INT 1
136169: EQUAL
136170: AND
136171: PUSH
136172: LD_VAR 0 4
136176: PUSH
136177: LD_VAR 0 7
136181: ARRAY
136182: PPUSH
136183: CALL_OW 256
136187: PUSH
136188: LD_INT 800
136190: LESS
136191: AND
136192: PUSH
136193: LD_VAR 0 4
136197: PUSH
136198: LD_VAR 0 7
136202: ARRAY
136203: PPUSH
136204: CALL_OW 318
136208: NOT
136209: AND
136210: IFFALSE 136227
// ComCrawl ( group [ i ] ) ;
136212: LD_VAR 0 4
136216: PUSH
136217: LD_VAR 0 7
136221: ARRAY
136222: PPUSH
136223: CALL_OW 137
// if f_mines then
136227: LD_VAR 0 21
136231: IFFALSE 136474
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
136233: LD_VAR 0 14
136237: PUSH
136238: LD_INT 1
136240: ARRAY
136241: PPUSH
136242: CALL_OW 247
136246: PUSH
136247: LD_INT 3
136249: EQUAL
136250: PUSH
136251: LD_VAR 0 14
136255: PUSH
136256: LD_INT 1
136258: ARRAY
136259: PUSH
136260: LD_VAR 0 27
136264: IN
136265: NOT
136266: AND
136267: IFFALSE 136474
// begin x := GetX ( tmp [ 1 ] ) ;
136269: LD_ADDR_VAR 0 10
136273: PUSH
136274: LD_VAR 0 14
136278: PUSH
136279: LD_INT 1
136281: ARRAY
136282: PPUSH
136283: CALL_OW 250
136287: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
136288: LD_ADDR_VAR 0 11
136292: PUSH
136293: LD_VAR 0 14
136297: PUSH
136298: LD_INT 1
136300: ARRAY
136301: PPUSH
136302: CALL_OW 251
136306: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
136307: LD_ADDR_VAR 0 12
136311: PUSH
136312: LD_VAR 0 4
136316: PUSH
136317: LD_VAR 0 7
136321: ARRAY
136322: PPUSH
136323: CALL 103220 0 1
136327: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
136328: LD_VAR 0 4
136332: PUSH
136333: LD_VAR 0 7
136337: ARRAY
136338: PPUSH
136339: LD_VAR 0 10
136343: PPUSH
136344: LD_VAR 0 11
136348: PPUSH
136349: LD_VAR 0 14
136353: PUSH
136354: LD_INT 1
136356: ARRAY
136357: PPUSH
136358: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
136362: LD_VAR 0 4
136366: PUSH
136367: LD_VAR 0 7
136371: ARRAY
136372: PPUSH
136373: LD_VAR 0 10
136377: PPUSH
136378: LD_VAR 0 12
136382: PPUSH
136383: LD_INT 7
136385: PPUSH
136386: CALL_OW 272
136390: PPUSH
136391: LD_VAR 0 11
136395: PPUSH
136396: LD_VAR 0 12
136400: PPUSH
136401: LD_INT 7
136403: PPUSH
136404: CALL_OW 273
136408: PPUSH
136409: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
136413: LD_VAR 0 4
136417: PUSH
136418: LD_VAR 0 7
136422: ARRAY
136423: PPUSH
136424: LD_INT 71
136426: PPUSH
136427: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
136431: LD_ADDR_VAR 0 27
136435: PUSH
136436: LD_VAR 0 27
136440: PPUSH
136441: LD_VAR 0 27
136445: PUSH
136446: LD_INT 1
136448: PLUS
136449: PPUSH
136450: LD_VAR 0 14
136454: PUSH
136455: LD_INT 1
136457: ARRAY
136458: PPUSH
136459: CALL_OW 1
136463: ST_TO_ADDR
// attacking := true ;
136464: LD_ADDR_VAR 0 29
136468: PUSH
136469: LD_INT 1
136471: ST_TO_ADDR
// continue ;
136472: GO 134319
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
136474: LD_VAR 0 4
136478: PUSH
136479: LD_VAR 0 7
136483: ARRAY
136484: PPUSH
136485: CALL_OW 257
136489: PUSH
136490: LD_INT 17
136492: EQUAL
136493: PUSH
136494: LD_VAR 0 4
136498: PUSH
136499: LD_VAR 0 7
136503: ARRAY
136504: PPUSH
136505: CALL_OW 110
136509: PUSH
136510: LD_INT 71
136512: EQUAL
136513: NOT
136514: AND
136515: IFFALSE 136661
// begin attacking := false ;
136517: LD_ADDR_VAR 0 29
136521: PUSH
136522: LD_INT 0
136524: ST_TO_ADDR
// k := 5 ;
136525: LD_ADDR_VAR 0 9
136529: PUSH
136530: LD_INT 5
136532: ST_TO_ADDR
// if tmp < k then
136533: LD_VAR 0 14
136537: PUSH
136538: LD_VAR 0 9
136542: LESS
136543: IFFALSE 136555
// k := tmp ;
136545: LD_ADDR_VAR 0 9
136549: PUSH
136550: LD_VAR 0 14
136554: ST_TO_ADDR
// for j = 1 to k do
136555: LD_ADDR_VAR 0 8
136559: PUSH
136560: DOUBLE
136561: LD_INT 1
136563: DEC
136564: ST_TO_ADDR
136565: LD_VAR 0 9
136569: PUSH
136570: FOR_TO
136571: IFFALSE 136659
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
136573: LD_VAR 0 14
136577: PUSH
136578: LD_VAR 0 8
136582: ARRAY
136583: PUSH
136584: LD_VAR 0 14
136588: PPUSH
136589: LD_INT 58
136591: PUSH
136592: EMPTY
136593: LIST
136594: PPUSH
136595: CALL_OW 72
136599: IN
136600: NOT
136601: IFFALSE 136657
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136603: LD_VAR 0 4
136607: PUSH
136608: LD_VAR 0 7
136612: ARRAY
136613: PPUSH
136614: LD_VAR 0 14
136618: PUSH
136619: LD_VAR 0 8
136623: ARRAY
136624: PPUSH
136625: CALL_OW 115
// attacking := true ;
136629: LD_ADDR_VAR 0 29
136633: PUSH
136634: LD_INT 1
136636: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
136637: LD_VAR 0 4
136641: PUSH
136642: LD_VAR 0 7
136646: ARRAY
136647: PPUSH
136648: LD_INT 71
136650: PPUSH
136651: CALL_OW 109
// continue ;
136655: GO 136570
// end ; end ;
136657: GO 136570
136659: POP
136660: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
136661: LD_VAR 0 4
136665: PUSH
136666: LD_VAR 0 7
136670: ARRAY
136671: PPUSH
136672: CALL_OW 257
136676: PUSH
136677: LD_INT 8
136679: EQUAL
136680: PUSH
136681: LD_VAR 0 4
136685: PUSH
136686: LD_VAR 0 7
136690: ARRAY
136691: PPUSH
136692: CALL_OW 264
136696: PUSH
136697: LD_INT 28
136699: PUSH
136700: LD_INT 45
136702: PUSH
136703: LD_INT 7
136705: PUSH
136706: LD_INT 47
136708: PUSH
136709: EMPTY
136710: LIST
136711: LIST
136712: LIST
136713: LIST
136714: IN
136715: OR
136716: IFFALSE 136972
// begin attacking := false ;
136718: LD_ADDR_VAR 0 29
136722: PUSH
136723: LD_INT 0
136725: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
136726: LD_VAR 0 14
136730: PUSH
136731: LD_INT 1
136733: ARRAY
136734: PPUSH
136735: CALL_OW 266
136739: PUSH
136740: LD_INT 32
136742: PUSH
136743: LD_INT 31
136745: PUSH
136746: LD_INT 33
136748: PUSH
136749: LD_INT 4
136751: PUSH
136752: LD_INT 5
136754: PUSH
136755: EMPTY
136756: LIST
136757: LIST
136758: LIST
136759: LIST
136760: LIST
136761: IN
136762: IFFALSE 136948
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
136764: LD_ADDR_VAR 0 9
136768: PUSH
136769: LD_VAR 0 14
136773: PUSH
136774: LD_INT 1
136776: ARRAY
136777: PPUSH
136778: CALL_OW 266
136782: PPUSH
136783: LD_VAR 0 14
136787: PUSH
136788: LD_INT 1
136790: ARRAY
136791: PPUSH
136792: CALL_OW 250
136796: PPUSH
136797: LD_VAR 0 14
136801: PUSH
136802: LD_INT 1
136804: ARRAY
136805: PPUSH
136806: CALL_OW 251
136810: PPUSH
136811: LD_VAR 0 14
136815: PUSH
136816: LD_INT 1
136818: ARRAY
136819: PPUSH
136820: CALL_OW 254
136824: PPUSH
136825: LD_VAR 0 14
136829: PUSH
136830: LD_INT 1
136832: ARRAY
136833: PPUSH
136834: CALL_OW 248
136838: PPUSH
136839: LD_INT 0
136841: PPUSH
136842: CALL 84590 0 6
136846: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
136847: LD_ADDR_VAR 0 8
136851: PUSH
136852: LD_VAR 0 4
136856: PUSH
136857: LD_VAR 0 7
136861: ARRAY
136862: PPUSH
136863: LD_VAR 0 9
136867: PPUSH
136868: CALL 103333 0 2
136872: ST_TO_ADDR
// if j then
136873: LD_VAR 0 8
136877: IFFALSE 136946
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
136879: LD_VAR 0 8
136883: PUSH
136884: LD_INT 1
136886: ARRAY
136887: PPUSH
136888: LD_VAR 0 8
136892: PUSH
136893: LD_INT 2
136895: ARRAY
136896: PPUSH
136897: CALL_OW 488
136901: IFFALSE 136946
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
136903: LD_VAR 0 4
136907: PUSH
136908: LD_VAR 0 7
136912: ARRAY
136913: PPUSH
136914: LD_VAR 0 8
136918: PUSH
136919: LD_INT 1
136921: ARRAY
136922: PPUSH
136923: LD_VAR 0 8
136927: PUSH
136928: LD_INT 2
136930: ARRAY
136931: PPUSH
136932: CALL_OW 116
// attacking := true ;
136936: LD_ADDR_VAR 0 29
136940: PUSH
136941: LD_INT 1
136943: ST_TO_ADDR
// continue ;
136944: GO 134319
// end ; end else
136946: GO 136972
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136948: LD_VAR 0 4
136952: PUSH
136953: LD_VAR 0 7
136957: ARRAY
136958: PPUSH
136959: LD_VAR 0 14
136963: PUSH
136964: LD_INT 1
136966: ARRAY
136967: PPUSH
136968: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
136972: LD_VAR 0 4
136976: PUSH
136977: LD_VAR 0 7
136981: ARRAY
136982: PPUSH
136983: CALL_OW 265
136987: PUSH
136988: LD_INT 11
136990: EQUAL
136991: IFFALSE 137269
// begin k := 10 ;
136993: LD_ADDR_VAR 0 9
136997: PUSH
136998: LD_INT 10
137000: ST_TO_ADDR
// x := 0 ;
137001: LD_ADDR_VAR 0 10
137005: PUSH
137006: LD_INT 0
137008: ST_TO_ADDR
// if tmp < k then
137009: LD_VAR 0 14
137013: PUSH
137014: LD_VAR 0 9
137018: LESS
137019: IFFALSE 137031
// k := tmp ;
137021: LD_ADDR_VAR 0 9
137025: PUSH
137026: LD_VAR 0 14
137030: ST_TO_ADDR
// for j = k downto 1 do
137031: LD_ADDR_VAR 0 8
137035: PUSH
137036: DOUBLE
137037: LD_VAR 0 9
137041: INC
137042: ST_TO_ADDR
137043: LD_INT 1
137045: PUSH
137046: FOR_DOWNTO
137047: IFFALSE 137122
// begin if GetType ( tmp [ j ] ) = unit_human then
137049: LD_VAR 0 14
137053: PUSH
137054: LD_VAR 0 8
137058: ARRAY
137059: PPUSH
137060: CALL_OW 247
137064: PUSH
137065: LD_INT 1
137067: EQUAL
137068: IFFALSE 137120
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
137070: LD_VAR 0 4
137074: PUSH
137075: LD_VAR 0 7
137079: ARRAY
137080: PPUSH
137081: LD_VAR 0 14
137085: PUSH
137086: LD_VAR 0 8
137090: ARRAY
137091: PPUSH
137092: CALL 103587 0 2
// x := tmp [ j ] ;
137096: LD_ADDR_VAR 0 10
137100: PUSH
137101: LD_VAR 0 14
137105: PUSH
137106: LD_VAR 0 8
137110: ARRAY
137111: ST_TO_ADDR
// attacking := true ;
137112: LD_ADDR_VAR 0 29
137116: PUSH
137117: LD_INT 1
137119: ST_TO_ADDR
// end ; end ;
137120: GO 137046
137122: POP
137123: POP
// if not x then
137124: LD_VAR 0 10
137128: NOT
137129: IFFALSE 137269
// begin attacking := true ;
137131: LD_ADDR_VAR 0 29
137135: PUSH
137136: LD_INT 1
137138: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
137139: LD_VAR 0 4
137143: PUSH
137144: LD_VAR 0 7
137148: ARRAY
137149: PPUSH
137150: CALL_OW 250
137154: PPUSH
137155: LD_VAR 0 4
137159: PUSH
137160: LD_VAR 0 7
137164: ARRAY
137165: PPUSH
137166: CALL_OW 251
137170: PPUSH
137171: CALL_OW 546
137175: PUSH
137176: LD_INT 2
137178: ARRAY
137179: PUSH
137180: LD_VAR 0 14
137184: PUSH
137185: LD_INT 1
137187: ARRAY
137188: PPUSH
137189: CALL_OW 250
137193: PPUSH
137194: LD_VAR 0 14
137198: PUSH
137199: LD_INT 1
137201: ARRAY
137202: PPUSH
137203: CALL_OW 251
137207: PPUSH
137208: CALL_OW 546
137212: PUSH
137213: LD_INT 2
137215: ARRAY
137216: EQUAL
137217: IFFALSE 137245
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
137219: LD_VAR 0 4
137223: PUSH
137224: LD_VAR 0 7
137228: ARRAY
137229: PPUSH
137230: LD_VAR 0 14
137234: PUSH
137235: LD_INT 1
137237: ARRAY
137238: PPUSH
137239: CALL 103587 0 2
137243: GO 137269
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137245: LD_VAR 0 4
137249: PUSH
137250: LD_VAR 0 7
137254: ARRAY
137255: PPUSH
137256: LD_VAR 0 14
137260: PUSH
137261: LD_INT 1
137263: ARRAY
137264: PPUSH
137265: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
137269: LD_VAR 0 4
137273: PUSH
137274: LD_VAR 0 7
137278: ARRAY
137279: PPUSH
137280: CALL_OW 264
137284: PUSH
137285: LD_INT 29
137287: EQUAL
137288: IFFALSE 137654
// begin if WantsToAttack ( group [ i ] ) in bombed then
137290: LD_VAR 0 4
137294: PUSH
137295: LD_VAR 0 7
137299: ARRAY
137300: PPUSH
137301: CALL_OW 319
137305: PUSH
137306: LD_VAR 0 28
137310: IN
137311: IFFALSE 137315
// continue ;
137313: GO 134319
// k := 8 ;
137315: LD_ADDR_VAR 0 9
137319: PUSH
137320: LD_INT 8
137322: ST_TO_ADDR
// x := 0 ;
137323: LD_ADDR_VAR 0 10
137327: PUSH
137328: LD_INT 0
137330: ST_TO_ADDR
// if tmp < k then
137331: LD_VAR 0 14
137335: PUSH
137336: LD_VAR 0 9
137340: LESS
137341: IFFALSE 137353
// k := tmp ;
137343: LD_ADDR_VAR 0 9
137347: PUSH
137348: LD_VAR 0 14
137352: ST_TO_ADDR
// for j = 1 to k do
137353: LD_ADDR_VAR 0 8
137357: PUSH
137358: DOUBLE
137359: LD_INT 1
137361: DEC
137362: ST_TO_ADDR
137363: LD_VAR 0 9
137367: PUSH
137368: FOR_TO
137369: IFFALSE 137501
// begin if GetType ( tmp [ j ] ) = unit_building then
137371: LD_VAR 0 14
137375: PUSH
137376: LD_VAR 0 8
137380: ARRAY
137381: PPUSH
137382: CALL_OW 247
137386: PUSH
137387: LD_INT 3
137389: EQUAL
137390: IFFALSE 137499
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
137392: LD_VAR 0 14
137396: PUSH
137397: LD_VAR 0 8
137401: ARRAY
137402: PUSH
137403: LD_VAR 0 28
137407: IN
137408: NOT
137409: PUSH
137410: LD_VAR 0 14
137414: PUSH
137415: LD_VAR 0 8
137419: ARRAY
137420: PPUSH
137421: CALL_OW 313
137425: AND
137426: IFFALSE 137499
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137428: LD_VAR 0 4
137432: PUSH
137433: LD_VAR 0 7
137437: ARRAY
137438: PPUSH
137439: LD_VAR 0 14
137443: PUSH
137444: LD_VAR 0 8
137448: ARRAY
137449: PPUSH
137450: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
137454: LD_ADDR_VAR 0 28
137458: PUSH
137459: LD_VAR 0 28
137463: PPUSH
137464: LD_VAR 0 28
137468: PUSH
137469: LD_INT 1
137471: PLUS
137472: PPUSH
137473: LD_VAR 0 14
137477: PUSH
137478: LD_VAR 0 8
137482: ARRAY
137483: PPUSH
137484: CALL_OW 1
137488: ST_TO_ADDR
// attacking := true ;
137489: LD_ADDR_VAR 0 29
137493: PUSH
137494: LD_INT 1
137496: ST_TO_ADDR
// break ;
137497: GO 137501
// end ; end ;
137499: GO 137368
137501: POP
137502: POP
// if not attacking and f_attack_depot then
137503: LD_VAR 0 29
137507: NOT
137508: PUSH
137509: LD_VAR 0 25
137513: AND
137514: IFFALSE 137609
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
137516: LD_ADDR_VAR 0 13
137520: PUSH
137521: LD_VAR 0 14
137525: PPUSH
137526: LD_INT 2
137528: PUSH
137529: LD_INT 30
137531: PUSH
137532: LD_INT 0
137534: PUSH
137535: EMPTY
137536: LIST
137537: LIST
137538: PUSH
137539: LD_INT 30
137541: PUSH
137542: LD_INT 1
137544: PUSH
137545: EMPTY
137546: LIST
137547: LIST
137548: PUSH
137549: EMPTY
137550: LIST
137551: LIST
137552: LIST
137553: PPUSH
137554: CALL_OW 72
137558: ST_TO_ADDR
// if z then
137559: LD_VAR 0 13
137563: IFFALSE 137609
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
137565: LD_VAR 0 4
137569: PUSH
137570: LD_VAR 0 7
137574: ARRAY
137575: PPUSH
137576: LD_VAR 0 13
137580: PPUSH
137581: LD_VAR 0 4
137585: PUSH
137586: LD_VAR 0 7
137590: ARRAY
137591: PPUSH
137592: CALL_OW 74
137596: PPUSH
137597: CALL_OW 115
// attacking := true ;
137601: LD_ADDR_VAR 0 29
137605: PUSH
137606: LD_INT 1
137608: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
137609: LD_VAR 0 4
137613: PUSH
137614: LD_VAR 0 7
137618: ARRAY
137619: PPUSH
137620: CALL_OW 256
137624: PUSH
137625: LD_INT 500
137627: LESS
137628: IFFALSE 137654
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137630: LD_VAR 0 4
137634: PUSH
137635: LD_VAR 0 7
137639: ARRAY
137640: PPUSH
137641: LD_VAR 0 14
137645: PUSH
137646: LD_INT 1
137648: ARRAY
137649: PPUSH
137650: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
137654: LD_VAR 0 4
137658: PUSH
137659: LD_VAR 0 7
137663: ARRAY
137664: PPUSH
137665: CALL_OW 264
137669: PUSH
137670: LD_INT 49
137672: EQUAL
137673: IFFALSE 137794
// begin if not HasTask ( group [ i ] ) then
137675: LD_VAR 0 4
137679: PUSH
137680: LD_VAR 0 7
137684: ARRAY
137685: PPUSH
137686: CALL_OW 314
137690: NOT
137691: IFFALSE 137794
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
137693: LD_ADDR_VAR 0 9
137697: PUSH
137698: LD_INT 81
137700: PUSH
137701: LD_VAR 0 4
137705: PUSH
137706: LD_VAR 0 7
137710: ARRAY
137711: PPUSH
137712: CALL_OW 255
137716: PUSH
137717: EMPTY
137718: LIST
137719: LIST
137720: PPUSH
137721: CALL_OW 69
137725: PPUSH
137726: LD_VAR 0 4
137730: PUSH
137731: LD_VAR 0 7
137735: ARRAY
137736: PPUSH
137737: CALL_OW 74
137741: ST_TO_ADDR
// if k then
137742: LD_VAR 0 9
137746: IFFALSE 137794
// if GetDistUnits ( group [ i ] , k ) > 10 then
137748: LD_VAR 0 4
137752: PUSH
137753: LD_VAR 0 7
137757: ARRAY
137758: PPUSH
137759: LD_VAR 0 9
137763: PPUSH
137764: CALL_OW 296
137768: PUSH
137769: LD_INT 10
137771: GREATER
137772: IFFALSE 137794
// ComMoveUnit ( group [ i ] , k ) ;
137774: LD_VAR 0 4
137778: PUSH
137779: LD_VAR 0 7
137783: ARRAY
137784: PPUSH
137785: LD_VAR 0 9
137789: PPUSH
137790: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
137794: LD_VAR 0 4
137798: PUSH
137799: LD_VAR 0 7
137803: ARRAY
137804: PPUSH
137805: CALL_OW 256
137809: PUSH
137810: LD_INT 250
137812: LESS
137813: PUSH
137814: LD_VAR 0 4
137818: PUSH
137819: LD_VAR 0 7
137823: ARRAY
137824: PUSH
137825: LD_INT 21
137827: PUSH
137828: LD_INT 2
137830: PUSH
137831: EMPTY
137832: LIST
137833: LIST
137834: PUSH
137835: LD_INT 23
137837: PUSH
137838: LD_INT 2
137840: PUSH
137841: EMPTY
137842: LIST
137843: LIST
137844: PUSH
137845: EMPTY
137846: LIST
137847: LIST
137848: PPUSH
137849: CALL_OW 69
137853: IN
137854: AND
137855: IFFALSE 137980
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
137857: LD_ADDR_VAR 0 9
137861: PUSH
137862: LD_OWVAR 3
137866: PUSH
137867: LD_VAR 0 4
137871: PUSH
137872: LD_VAR 0 7
137876: ARRAY
137877: DIFF
137878: PPUSH
137879: LD_VAR 0 4
137883: PUSH
137884: LD_VAR 0 7
137888: ARRAY
137889: PPUSH
137890: CALL_OW 74
137894: ST_TO_ADDR
// if not k then
137895: LD_VAR 0 9
137899: NOT
137900: IFFALSE 137904
// continue ;
137902: GO 134319
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
137904: LD_VAR 0 9
137908: PUSH
137909: LD_INT 81
137911: PUSH
137912: LD_VAR 0 4
137916: PUSH
137917: LD_VAR 0 7
137921: ARRAY
137922: PPUSH
137923: CALL_OW 255
137927: PUSH
137928: EMPTY
137929: LIST
137930: LIST
137931: PPUSH
137932: CALL_OW 69
137936: IN
137937: PUSH
137938: LD_VAR 0 9
137942: PPUSH
137943: LD_VAR 0 4
137947: PUSH
137948: LD_VAR 0 7
137952: ARRAY
137953: PPUSH
137954: CALL_OW 296
137958: PUSH
137959: LD_INT 5
137961: LESS
137962: AND
137963: IFFALSE 137980
// ComAutodestruct ( group [ i ] ) ;
137965: LD_VAR 0 4
137969: PUSH
137970: LD_VAR 0 7
137974: ARRAY
137975: PPUSH
137976: CALL 103485 0 1
// end ; if f_attack_depot then
137980: LD_VAR 0 25
137984: IFFALSE 138096
// begin k := 6 ;
137986: LD_ADDR_VAR 0 9
137990: PUSH
137991: LD_INT 6
137993: ST_TO_ADDR
// if tmp < k then
137994: LD_VAR 0 14
137998: PUSH
137999: LD_VAR 0 9
138003: LESS
138004: IFFALSE 138016
// k := tmp ;
138006: LD_ADDR_VAR 0 9
138010: PUSH
138011: LD_VAR 0 14
138015: ST_TO_ADDR
// for j = 1 to k do
138016: LD_ADDR_VAR 0 8
138020: PUSH
138021: DOUBLE
138022: LD_INT 1
138024: DEC
138025: ST_TO_ADDR
138026: LD_VAR 0 9
138030: PUSH
138031: FOR_TO
138032: IFFALSE 138094
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
138034: LD_VAR 0 8
138038: PPUSH
138039: CALL_OW 266
138043: PUSH
138044: LD_INT 0
138046: PUSH
138047: LD_INT 1
138049: PUSH
138050: EMPTY
138051: LIST
138052: LIST
138053: IN
138054: IFFALSE 138092
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138056: LD_VAR 0 4
138060: PUSH
138061: LD_VAR 0 7
138065: ARRAY
138066: PPUSH
138067: LD_VAR 0 14
138071: PUSH
138072: LD_VAR 0 8
138076: ARRAY
138077: PPUSH
138078: CALL_OW 115
// attacking := true ;
138082: LD_ADDR_VAR 0 29
138086: PUSH
138087: LD_INT 1
138089: ST_TO_ADDR
// break ;
138090: GO 138094
// end ;
138092: GO 138031
138094: POP
138095: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
138096: LD_VAR 0 4
138100: PUSH
138101: LD_VAR 0 7
138105: ARRAY
138106: PPUSH
138107: CALL_OW 302
138111: PUSH
138112: LD_VAR 0 29
138116: NOT
138117: AND
138118: IFFALSE 138440
// begin if GetTag ( group [ i ] ) = 71 then
138120: LD_VAR 0 4
138124: PUSH
138125: LD_VAR 0 7
138129: ARRAY
138130: PPUSH
138131: CALL_OW 110
138135: PUSH
138136: LD_INT 71
138138: EQUAL
138139: IFFALSE 138180
// begin if HasTask ( group [ i ] ) then
138141: LD_VAR 0 4
138145: PUSH
138146: LD_VAR 0 7
138150: ARRAY
138151: PPUSH
138152: CALL_OW 314
138156: IFFALSE 138162
// continue else
138158: GO 134319
138160: GO 138180
// SetTag ( group [ i ] , 0 ) ;
138162: LD_VAR 0 4
138166: PUSH
138167: LD_VAR 0 7
138171: ARRAY
138172: PPUSH
138173: LD_INT 0
138175: PPUSH
138176: CALL_OW 109
// end ; k := 8 ;
138180: LD_ADDR_VAR 0 9
138184: PUSH
138185: LD_INT 8
138187: ST_TO_ADDR
// x := 0 ;
138188: LD_ADDR_VAR 0 10
138192: PUSH
138193: LD_INT 0
138195: ST_TO_ADDR
// if tmp < k then
138196: LD_VAR 0 14
138200: PUSH
138201: LD_VAR 0 9
138205: LESS
138206: IFFALSE 138218
// k := tmp ;
138208: LD_ADDR_VAR 0 9
138212: PUSH
138213: LD_VAR 0 14
138217: ST_TO_ADDR
// for j = 1 to k do
138218: LD_ADDR_VAR 0 8
138222: PUSH
138223: DOUBLE
138224: LD_INT 1
138226: DEC
138227: ST_TO_ADDR
138228: LD_VAR 0 9
138232: PUSH
138233: FOR_TO
138234: IFFALSE 138332
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
138236: LD_VAR 0 14
138240: PUSH
138241: LD_VAR 0 8
138245: ARRAY
138246: PPUSH
138247: CALL_OW 247
138251: PUSH
138252: LD_INT 1
138254: EQUAL
138255: PUSH
138256: LD_VAR 0 14
138260: PUSH
138261: LD_VAR 0 8
138265: ARRAY
138266: PPUSH
138267: CALL_OW 256
138271: PUSH
138272: LD_INT 250
138274: LESS
138275: PUSH
138276: LD_VAR 0 20
138280: AND
138281: PUSH
138282: LD_VAR 0 20
138286: NOT
138287: PUSH
138288: LD_VAR 0 14
138292: PUSH
138293: LD_VAR 0 8
138297: ARRAY
138298: PPUSH
138299: CALL_OW 256
138303: PUSH
138304: LD_INT 250
138306: GREATEREQUAL
138307: AND
138308: OR
138309: AND
138310: IFFALSE 138330
// begin x := tmp [ j ] ;
138312: LD_ADDR_VAR 0 10
138316: PUSH
138317: LD_VAR 0 14
138321: PUSH
138322: LD_VAR 0 8
138326: ARRAY
138327: ST_TO_ADDR
// break ;
138328: GO 138332
// end ;
138330: GO 138233
138332: POP
138333: POP
// if x then
138334: LD_VAR 0 10
138338: IFFALSE 138362
// ComAttackUnit ( group [ i ] , x ) else
138340: LD_VAR 0 4
138344: PUSH
138345: LD_VAR 0 7
138349: ARRAY
138350: PPUSH
138351: LD_VAR 0 10
138355: PPUSH
138356: CALL_OW 115
138360: GO 138386
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138362: LD_VAR 0 4
138366: PUSH
138367: LD_VAR 0 7
138371: ARRAY
138372: PPUSH
138373: LD_VAR 0 14
138377: PUSH
138378: LD_INT 1
138380: ARRAY
138381: PPUSH
138382: CALL_OW 115
// if not HasTask ( group [ i ] ) then
138386: LD_VAR 0 4
138390: PUSH
138391: LD_VAR 0 7
138395: ARRAY
138396: PPUSH
138397: CALL_OW 314
138401: NOT
138402: IFFALSE 138440
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
138404: LD_VAR 0 4
138408: PUSH
138409: LD_VAR 0 7
138413: ARRAY
138414: PPUSH
138415: LD_VAR 0 14
138419: PPUSH
138420: LD_VAR 0 4
138424: PUSH
138425: LD_VAR 0 7
138429: ARRAY
138430: PPUSH
138431: CALL_OW 74
138435: PPUSH
138436: CALL_OW 115
// end ; end ; end ;
138440: GO 134319
138442: POP
138443: POP
// wait ( 0 0$2 ) ;
138444: LD_INT 70
138446: PPUSH
138447: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
138451: LD_VAR 0 4
138455: NOT
138456: PUSH
138457: LD_VAR 0 4
138461: PUSH
138462: EMPTY
138463: EQUAL
138464: OR
138465: PUSH
138466: LD_INT 81
138468: PUSH
138469: LD_VAR 0 35
138473: PUSH
138474: EMPTY
138475: LIST
138476: LIST
138477: PPUSH
138478: CALL_OW 69
138482: NOT
138483: OR
138484: IFFALSE 134304
// end ;
138486: LD_VAR 0 2
138490: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
138491: LD_INT 0
138493: PPUSH
138494: PPUSH
138495: PPUSH
138496: PPUSH
138497: PPUSH
138498: PPUSH
// if not base or not mc_bases [ base ] or not solds then
138499: LD_VAR 0 1
138503: NOT
138504: PUSH
138505: LD_EXP 102
138509: PUSH
138510: LD_VAR 0 1
138514: ARRAY
138515: NOT
138516: OR
138517: PUSH
138518: LD_VAR 0 2
138522: NOT
138523: OR
138524: IFFALSE 138528
// exit ;
138526: GO 139082
// side := mc_sides [ base ] ;
138528: LD_ADDR_VAR 0 6
138532: PUSH
138533: LD_EXP 128
138537: PUSH
138538: LD_VAR 0 1
138542: ARRAY
138543: ST_TO_ADDR
// if not side then
138544: LD_VAR 0 6
138548: NOT
138549: IFFALSE 138553
// exit ;
138551: GO 139082
// for i in solds do
138553: LD_ADDR_VAR 0 7
138557: PUSH
138558: LD_VAR 0 2
138562: PUSH
138563: FOR_IN
138564: IFFALSE 138625
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
138566: LD_VAR 0 7
138570: PPUSH
138571: CALL_OW 310
138575: PPUSH
138576: CALL_OW 266
138580: PUSH
138581: LD_INT 32
138583: PUSH
138584: LD_INT 31
138586: PUSH
138587: EMPTY
138588: LIST
138589: LIST
138590: IN
138591: IFFALSE 138611
// solds := solds diff i else
138593: LD_ADDR_VAR 0 2
138597: PUSH
138598: LD_VAR 0 2
138602: PUSH
138603: LD_VAR 0 7
138607: DIFF
138608: ST_TO_ADDR
138609: GO 138623
// SetTag ( i , 18 ) ;
138611: LD_VAR 0 7
138615: PPUSH
138616: LD_INT 18
138618: PPUSH
138619: CALL_OW 109
138623: GO 138563
138625: POP
138626: POP
// if not solds then
138627: LD_VAR 0 2
138631: NOT
138632: IFFALSE 138636
// exit ;
138634: GO 139082
// repeat wait ( 0 0$2 ) ;
138636: LD_INT 70
138638: PPUSH
138639: CALL_OW 67
// enemy := mc_scan [ base ] ;
138643: LD_ADDR_VAR 0 4
138647: PUSH
138648: LD_EXP 125
138652: PUSH
138653: LD_VAR 0 1
138657: ARRAY
138658: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138659: LD_EXP 102
138663: PUSH
138664: LD_VAR 0 1
138668: ARRAY
138669: NOT
138670: PUSH
138671: LD_EXP 102
138675: PUSH
138676: LD_VAR 0 1
138680: ARRAY
138681: PUSH
138682: EMPTY
138683: EQUAL
138684: OR
138685: IFFALSE 138722
// begin for i in solds do
138687: LD_ADDR_VAR 0 7
138691: PUSH
138692: LD_VAR 0 2
138696: PUSH
138697: FOR_IN
138698: IFFALSE 138711
// ComStop ( i ) ;
138700: LD_VAR 0 7
138704: PPUSH
138705: CALL_OW 141
138709: GO 138697
138711: POP
138712: POP
// solds := [ ] ;
138713: LD_ADDR_VAR 0 2
138717: PUSH
138718: EMPTY
138719: ST_TO_ADDR
// exit ;
138720: GO 139082
// end ; for i in solds do
138722: LD_ADDR_VAR 0 7
138726: PUSH
138727: LD_VAR 0 2
138731: PUSH
138732: FOR_IN
138733: IFFALSE 139054
// begin if IsInUnit ( i ) then
138735: LD_VAR 0 7
138739: PPUSH
138740: CALL_OW 310
138744: IFFALSE 138755
// ComExitBuilding ( i ) ;
138746: LD_VAR 0 7
138750: PPUSH
138751: CALL_OW 122
// if GetLives ( i ) > 500 then
138755: LD_VAR 0 7
138759: PPUSH
138760: CALL_OW 256
138764: PUSH
138765: LD_INT 500
138767: GREATER
138768: IFFALSE 138821
// begin e := NearestUnitToUnit ( enemy , i ) ;
138770: LD_ADDR_VAR 0 5
138774: PUSH
138775: LD_VAR 0 4
138779: PPUSH
138780: LD_VAR 0 7
138784: PPUSH
138785: CALL_OW 74
138789: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
138790: LD_VAR 0 7
138794: PPUSH
138795: LD_VAR 0 5
138799: PPUSH
138800: CALL_OW 250
138804: PPUSH
138805: LD_VAR 0 5
138809: PPUSH
138810: CALL_OW 251
138814: PPUSH
138815: CALL_OW 114
// end else
138819: GO 139052
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
138821: LD_VAR 0 7
138825: PPUSH
138826: LD_EXP 102
138830: PUSH
138831: LD_VAR 0 1
138835: ARRAY
138836: PPUSH
138837: LD_INT 2
138839: PUSH
138840: LD_INT 30
138842: PUSH
138843: LD_INT 0
138845: PUSH
138846: EMPTY
138847: LIST
138848: LIST
138849: PUSH
138850: LD_INT 30
138852: PUSH
138853: LD_INT 1
138855: PUSH
138856: EMPTY
138857: LIST
138858: LIST
138859: PUSH
138860: LD_INT 30
138862: PUSH
138863: LD_INT 6
138865: PUSH
138866: EMPTY
138867: LIST
138868: LIST
138869: PUSH
138870: EMPTY
138871: LIST
138872: LIST
138873: LIST
138874: LIST
138875: PPUSH
138876: CALL_OW 72
138880: PPUSH
138881: LD_VAR 0 7
138885: PPUSH
138886: CALL_OW 74
138890: PPUSH
138891: CALL_OW 296
138895: PUSH
138896: LD_INT 10
138898: GREATER
138899: IFFALSE 139052
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
138901: LD_ADDR_VAR 0 8
138905: PUSH
138906: LD_EXP 102
138910: PUSH
138911: LD_VAR 0 1
138915: ARRAY
138916: PPUSH
138917: LD_INT 2
138919: PUSH
138920: LD_INT 30
138922: PUSH
138923: LD_INT 0
138925: PUSH
138926: EMPTY
138927: LIST
138928: LIST
138929: PUSH
138930: LD_INT 30
138932: PUSH
138933: LD_INT 1
138935: PUSH
138936: EMPTY
138937: LIST
138938: LIST
138939: PUSH
138940: LD_INT 30
138942: PUSH
138943: LD_INT 6
138945: PUSH
138946: EMPTY
138947: LIST
138948: LIST
138949: PUSH
138950: EMPTY
138951: LIST
138952: LIST
138953: LIST
138954: LIST
138955: PPUSH
138956: CALL_OW 72
138960: PPUSH
138961: LD_VAR 0 7
138965: PPUSH
138966: CALL_OW 74
138970: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
138971: LD_VAR 0 7
138975: PPUSH
138976: LD_VAR 0 8
138980: PPUSH
138981: CALL_OW 250
138985: PPUSH
138986: LD_INT 3
138988: PPUSH
138989: LD_INT 5
138991: PPUSH
138992: CALL_OW 272
138996: PPUSH
138997: LD_VAR 0 8
139001: PPUSH
139002: CALL_OW 251
139006: PPUSH
139007: LD_INT 3
139009: PPUSH
139010: LD_INT 5
139012: PPUSH
139013: CALL_OW 273
139017: PPUSH
139018: CALL_OW 111
// SetTag ( i , 0 ) ;
139022: LD_VAR 0 7
139026: PPUSH
139027: LD_INT 0
139029: PPUSH
139030: CALL_OW 109
// solds := solds diff i ;
139034: LD_ADDR_VAR 0 2
139038: PUSH
139039: LD_VAR 0 2
139043: PUSH
139044: LD_VAR 0 7
139048: DIFF
139049: ST_TO_ADDR
// continue ;
139050: GO 138732
// end ; end ;
139052: GO 138732
139054: POP
139055: POP
// until not solds or not enemy ;
139056: LD_VAR 0 2
139060: NOT
139061: PUSH
139062: LD_VAR 0 4
139066: NOT
139067: OR
139068: IFFALSE 138636
// MC_Reset ( base , 18 ) ;
139070: LD_VAR 0 1
139074: PPUSH
139075: LD_INT 18
139077: PPUSH
139078: CALL 43743 0 2
// end ;
139082: LD_VAR 0 3
139086: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
139087: LD_INT 0
139089: PPUSH
139090: PPUSH
139091: PPUSH
139092: PPUSH
139093: PPUSH
139094: PPUSH
139095: PPUSH
139096: PPUSH
139097: PPUSH
139098: PPUSH
139099: PPUSH
139100: PPUSH
139101: PPUSH
139102: PPUSH
139103: PPUSH
139104: PPUSH
139105: PPUSH
139106: PPUSH
139107: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
139108: LD_ADDR_VAR 0 12
139112: PUSH
139113: LD_EXP 102
139117: PUSH
139118: LD_VAR 0 1
139122: ARRAY
139123: PPUSH
139124: LD_INT 25
139126: PUSH
139127: LD_INT 3
139129: PUSH
139130: EMPTY
139131: LIST
139132: LIST
139133: PPUSH
139134: CALL_OW 72
139138: ST_TO_ADDR
// if mc_remote_driver [ base ] then
139139: LD_EXP 142
139143: PUSH
139144: LD_VAR 0 1
139148: ARRAY
139149: IFFALSE 139173
// mechs := mechs diff mc_remote_driver [ base ] ;
139151: LD_ADDR_VAR 0 12
139155: PUSH
139156: LD_VAR 0 12
139160: PUSH
139161: LD_EXP 142
139165: PUSH
139166: LD_VAR 0 1
139170: ARRAY
139171: DIFF
139172: ST_TO_ADDR
// for i in mechs do
139173: LD_ADDR_VAR 0 4
139177: PUSH
139178: LD_VAR 0 12
139182: PUSH
139183: FOR_IN
139184: IFFALSE 139219
// if GetTag ( i ) > 0 then
139186: LD_VAR 0 4
139190: PPUSH
139191: CALL_OW 110
139195: PUSH
139196: LD_INT 0
139198: GREATER
139199: IFFALSE 139217
// mechs := mechs diff i ;
139201: LD_ADDR_VAR 0 12
139205: PUSH
139206: LD_VAR 0 12
139210: PUSH
139211: LD_VAR 0 4
139215: DIFF
139216: ST_TO_ADDR
139217: GO 139183
139219: POP
139220: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139221: LD_ADDR_VAR 0 8
139225: PUSH
139226: LD_EXP 102
139230: PUSH
139231: LD_VAR 0 1
139235: ARRAY
139236: PPUSH
139237: LD_INT 2
139239: PUSH
139240: LD_INT 25
139242: PUSH
139243: LD_INT 1
139245: PUSH
139246: EMPTY
139247: LIST
139248: LIST
139249: PUSH
139250: LD_INT 25
139252: PUSH
139253: LD_INT 5
139255: PUSH
139256: EMPTY
139257: LIST
139258: LIST
139259: PUSH
139260: LD_INT 25
139262: PUSH
139263: LD_INT 8
139265: PUSH
139266: EMPTY
139267: LIST
139268: LIST
139269: PUSH
139270: LD_INT 25
139272: PUSH
139273: LD_INT 9
139275: PUSH
139276: EMPTY
139277: LIST
139278: LIST
139279: PUSH
139280: EMPTY
139281: LIST
139282: LIST
139283: LIST
139284: LIST
139285: LIST
139286: PPUSH
139287: CALL_OW 72
139291: ST_TO_ADDR
// if not defenders and not solds then
139292: LD_VAR 0 2
139296: NOT
139297: PUSH
139298: LD_VAR 0 8
139302: NOT
139303: AND
139304: IFFALSE 139308
// exit ;
139306: GO 141078
// depot_under_attack := false ;
139308: LD_ADDR_VAR 0 16
139312: PUSH
139313: LD_INT 0
139315: ST_TO_ADDR
// sold_defenders := [ ] ;
139316: LD_ADDR_VAR 0 17
139320: PUSH
139321: EMPTY
139322: ST_TO_ADDR
// if mechs then
139323: LD_VAR 0 12
139327: IFFALSE 139480
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
139329: LD_ADDR_VAR 0 4
139333: PUSH
139334: LD_VAR 0 2
139338: PPUSH
139339: LD_INT 21
139341: PUSH
139342: LD_INT 2
139344: PUSH
139345: EMPTY
139346: LIST
139347: LIST
139348: PPUSH
139349: CALL_OW 72
139353: PUSH
139354: FOR_IN
139355: IFFALSE 139478
// begin if GetTag ( i ) <> 20 then
139357: LD_VAR 0 4
139361: PPUSH
139362: CALL_OW 110
139366: PUSH
139367: LD_INT 20
139369: NONEQUAL
139370: IFFALSE 139384
// SetTag ( i , 20 ) ;
139372: LD_VAR 0 4
139376: PPUSH
139377: LD_INT 20
139379: PPUSH
139380: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
139384: LD_VAR 0 4
139388: PPUSH
139389: CALL_OW 263
139393: PUSH
139394: LD_INT 1
139396: EQUAL
139397: PUSH
139398: LD_VAR 0 4
139402: PPUSH
139403: CALL_OW 311
139407: NOT
139408: AND
139409: IFFALSE 139476
// begin un := mechs [ 1 ] ;
139411: LD_ADDR_VAR 0 10
139415: PUSH
139416: LD_VAR 0 12
139420: PUSH
139421: LD_INT 1
139423: ARRAY
139424: ST_TO_ADDR
// ComExit ( un ) ;
139425: LD_VAR 0 10
139429: PPUSH
139430: CALL 108371 0 1
// AddComEnterUnit ( un , i ) ;
139434: LD_VAR 0 10
139438: PPUSH
139439: LD_VAR 0 4
139443: PPUSH
139444: CALL_OW 180
// SetTag ( un , 19 ) ;
139448: LD_VAR 0 10
139452: PPUSH
139453: LD_INT 19
139455: PPUSH
139456: CALL_OW 109
// mechs := mechs diff un ;
139460: LD_ADDR_VAR 0 12
139464: PUSH
139465: LD_VAR 0 12
139469: PUSH
139470: LD_VAR 0 10
139474: DIFF
139475: ST_TO_ADDR
// end ; end ;
139476: GO 139354
139478: POP
139479: POP
// if solds then
139480: LD_VAR 0 8
139484: IFFALSE 139543
// for i in solds do
139486: LD_ADDR_VAR 0 4
139490: PUSH
139491: LD_VAR 0 8
139495: PUSH
139496: FOR_IN
139497: IFFALSE 139541
// if not GetTag ( i ) then
139499: LD_VAR 0 4
139503: PPUSH
139504: CALL_OW 110
139508: NOT
139509: IFFALSE 139539
// begin defenders := defenders union i ;
139511: LD_ADDR_VAR 0 2
139515: PUSH
139516: LD_VAR 0 2
139520: PUSH
139521: LD_VAR 0 4
139525: UNION
139526: ST_TO_ADDR
// SetTag ( i , 18 ) ;
139527: LD_VAR 0 4
139531: PPUSH
139532: LD_INT 18
139534: PPUSH
139535: CALL_OW 109
// end ;
139539: GO 139496
139541: POP
139542: POP
// repeat wait ( 0 0$2 ) ;
139543: LD_INT 70
139545: PPUSH
139546: CALL_OW 67
// enemy := mc_scan [ base ] ;
139550: LD_ADDR_VAR 0 21
139554: PUSH
139555: LD_EXP 125
139559: PUSH
139560: LD_VAR 0 1
139564: ARRAY
139565: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139566: LD_EXP 102
139570: PUSH
139571: LD_VAR 0 1
139575: ARRAY
139576: NOT
139577: PUSH
139578: LD_EXP 102
139582: PUSH
139583: LD_VAR 0 1
139587: ARRAY
139588: PUSH
139589: EMPTY
139590: EQUAL
139591: OR
139592: IFFALSE 139629
// begin for i in defenders do
139594: LD_ADDR_VAR 0 4
139598: PUSH
139599: LD_VAR 0 2
139603: PUSH
139604: FOR_IN
139605: IFFALSE 139618
// ComStop ( i ) ;
139607: LD_VAR 0 4
139611: PPUSH
139612: CALL_OW 141
139616: GO 139604
139618: POP
139619: POP
// defenders := [ ] ;
139620: LD_ADDR_VAR 0 2
139624: PUSH
139625: EMPTY
139626: ST_TO_ADDR
// exit ;
139627: GO 141078
// end ; for i in defenders do
139629: LD_ADDR_VAR 0 4
139633: PUSH
139634: LD_VAR 0 2
139638: PUSH
139639: FOR_IN
139640: IFFALSE 140538
// begin e := NearestUnitToUnit ( enemy , i ) ;
139642: LD_ADDR_VAR 0 13
139646: PUSH
139647: LD_VAR 0 21
139651: PPUSH
139652: LD_VAR 0 4
139656: PPUSH
139657: CALL_OW 74
139661: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
139662: LD_ADDR_VAR 0 7
139666: PUSH
139667: LD_EXP 102
139671: PUSH
139672: LD_VAR 0 1
139676: ARRAY
139677: PPUSH
139678: LD_INT 2
139680: PUSH
139681: LD_INT 30
139683: PUSH
139684: LD_INT 0
139686: PUSH
139687: EMPTY
139688: LIST
139689: LIST
139690: PUSH
139691: LD_INT 30
139693: PUSH
139694: LD_INT 1
139696: PUSH
139697: EMPTY
139698: LIST
139699: LIST
139700: PUSH
139701: EMPTY
139702: LIST
139703: LIST
139704: LIST
139705: PPUSH
139706: CALL_OW 72
139710: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
139711: LD_ADDR_VAR 0 16
139715: PUSH
139716: LD_VAR 0 7
139720: NOT
139721: PUSH
139722: LD_VAR 0 7
139726: PPUSH
139727: LD_INT 3
139729: PUSH
139730: LD_INT 24
139732: PUSH
139733: LD_INT 600
139735: PUSH
139736: EMPTY
139737: LIST
139738: LIST
139739: PUSH
139740: EMPTY
139741: LIST
139742: LIST
139743: PPUSH
139744: CALL_OW 72
139748: OR
139749: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
139750: LD_VAR 0 4
139754: PPUSH
139755: CALL_OW 247
139759: PUSH
139760: LD_INT 2
139762: DOUBLE
139763: EQUAL
139764: IFTRUE 139768
139766: GO 140164
139768: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
139769: LD_VAR 0 4
139773: PPUSH
139774: CALL_OW 256
139778: PUSH
139779: LD_INT 1000
139781: EQUAL
139782: PUSH
139783: LD_VAR 0 4
139787: PPUSH
139788: LD_VAR 0 13
139792: PPUSH
139793: CALL_OW 296
139797: PUSH
139798: LD_INT 40
139800: LESS
139801: PUSH
139802: LD_VAR 0 13
139806: PPUSH
139807: LD_EXP 127
139811: PUSH
139812: LD_VAR 0 1
139816: ARRAY
139817: PPUSH
139818: CALL_OW 308
139822: OR
139823: AND
139824: IFFALSE 139946
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
139826: LD_VAR 0 4
139830: PPUSH
139831: CALL_OW 262
139835: PUSH
139836: LD_INT 1
139838: EQUAL
139839: PUSH
139840: LD_VAR 0 4
139844: PPUSH
139845: CALL_OW 261
139849: PUSH
139850: LD_INT 30
139852: LESS
139853: AND
139854: PUSH
139855: LD_VAR 0 7
139859: AND
139860: IFFALSE 139930
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
139862: LD_VAR 0 4
139866: PPUSH
139867: LD_VAR 0 7
139871: PPUSH
139872: LD_VAR 0 4
139876: PPUSH
139877: CALL_OW 74
139881: PPUSH
139882: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
139886: LD_VAR 0 4
139890: PPUSH
139891: LD_VAR 0 7
139895: PPUSH
139896: LD_VAR 0 4
139900: PPUSH
139901: CALL_OW 74
139905: PPUSH
139906: CALL_OW 296
139910: PUSH
139911: LD_INT 6
139913: LESS
139914: IFFALSE 139928
// SetFuel ( i , 100 ) ;
139916: LD_VAR 0 4
139920: PPUSH
139921: LD_INT 100
139923: PPUSH
139924: CALL_OW 240
// end else
139928: GO 139944
// ComAttackUnit ( i , e ) ;
139930: LD_VAR 0 4
139934: PPUSH
139935: LD_VAR 0 13
139939: PPUSH
139940: CALL_OW 115
// end else
139944: GO 140047
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
139946: LD_VAR 0 13
139950: PPUSH
139951: LD_EXP 127
139955: PUSH
139956: LD_VAR 0 1
139960: ARRAY
139961: PPUSH
139962: CALL_OW 308
139966: NOT
139967: PUSH
139968: LD_VAR 0 4
139972: PPUSH
139973: LD_VAR 0 13
139977: PPUSH
139978: CALL_OW 296
139982: PUSH
139983: LD_INT 40
139985: GREATEREQUAL
139986: AND
139987: PUSH
139988: LD_VAR 0 4
139992: PPUSH
139993: CALL_OW 256
139997: PUSH
139998: LD_INT 650
140000: LESSEQUAL
140001: OR
140002: PUSH
140003: LD_VAR 0 4
140007: PPUSH
140008: LD_EXP 126
140012: PUSH
140013: LD_VAR 0 1
140017: ARRAY
140018: PPUSH
140019: CALL_OW 308
140023: NOT
140024: AND
140025: IFFALSE 140047
// ComMoveToArea ( i , mc_parking [ base ] ) ;
140027: LD_VAR 0 4
140031: PPUSH
140032: LD_EXP 126
140036: PUSH
140037: LD_VAR 0 1
140041: ARRAY
140042: PPUSH
140043: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
140047: LD_VAR 0 4
140051: PPUSH
140052: CALL_OW 256
140056: PUSH
140057: LD_INT 1000
140059: LESS
140060: PUSH
140061: LD_VAR 0 4
140065: PPUSH
140066: CALL_OW 263
140070: PUSH
140071: LD_INT 1
140073: EQUAL
140074: AND
140075: PUSH
140076: LD_VAR 0 4
140080: PPUSH
140081: CALL_OW 311
140085: AND
140086: PUSH
140087: LD_VAR 0 4
140091: PPUSH
140092: LD_EXP 126
140096: PUSH
140097: LD_VAR 0 1
140101: ARRAY
140102: PPUSH
140103: CALL_OW 308
140107: AND
140108: IFFALSE 140162
// begin mech := IsDrivenBy ( i ) ;
140110: LD_ADDR_VAR 0 9
140114: PUSH
140115: LD_VAR 0 4
140119: PPUSH
140120: CALL_OW 311
140124: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
140125: LD_VAR 0 9
140129: PPUSH
140130: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
140134: LD_VAR 0 9
140138: PPUSH
140139: LD_VAR 0 4
140143: PPUSH
140144: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
140148: LD_VAR 0 9
140152: PPUSH
140153: LD_VAR 0 4
140157: PPUSH
140158: CALL_OW 180
// end ; end ; unit_human :
140162: GO 140509
140164: LD_INT 1
140166: DOUBLE
140167: EQUAL
140168: IFTRUE 140172
140170: GO 140508
140172: POP
// begin b := IsInUnit ( i ) ;
140173: LD_ADDR_VAR 0 18
140177: PUSH
140178: LD_VAR 0 4
140182: PPUSH
140183: CALL_OW 310
140187: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
140188: LD_ADDR_VAR 0 19
140192: PUSH
140193: LD_VAR 0 18
140197: NOT
140198: PUSH
140199: LD_VAR 0 18
140203: PPUSH
140204: CALL_OW 266
140208: PUSH
140209: LD_INT 32
140211: PUSH
140212: LD_INT 31
140214: PUSH
140215: EMPTY
140216: LIST
140217: LIST
140218: IN
140219: OR
140220: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
140221: LD_VAR 0 18
140225: PPUSH
140226: CALL_OW 266
140230: PUSH
140231: LD_INT 5
140233: EQUAL
140234: PUSH
140235: LD_VAR 0 4
140239: PPUSH
140240: CALL_OW 257
140244: PUSH
140245: LD_INT 1
140247: PUSH
140248: LD_INT 2
140250: PUSH
140251: LD_INT 3
140253: PUSH
140254: LD_INT 4
140256: PUSH
140257: EMPTY
140258: LIST
140259: LIST
140260: LIST
140261: LIST
140262: IN
140263: AND
140264: IFFALSE 140301
// begin class := AllowSpecClass ( i ) ;
140266: LD_ADDR_VAR 0 20
140270: PUSH
140271: LD_VAR 0 4
140275: PPUSH
140276: CALL 72068 0 1
140280: ST_TO_ADDR
// if class then
140281: LD_VAR 0 20
140285: IFFALSE 140301
// ComChangeProfession ( i , class ) ;
140287: LD_VAR 0 4
140291: PPUSH
140292: LD_VAR 0 20
140296: PPUSH
140297: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
140301: LD_VAR 0 16
140305: PUSH
140306: LD_VAR 0 2
140310: PPUSH
140311: LD_INT 21
140313: PUSH
140314: LD_INT 2
140316: PUSH
140317: EMPTY
140318: LIST
140319: LIST
140320: PPUSH
140321: CALL_OW 72
140325: PUSH
140326: LD_INT 1
140328: LESSEQUAL
140329: OR
140330: PUSH
140331: LD_VAR 0 19
140335: AND
140336: PUSH
140337: LD_VAR 0 4
140341: PUSH
140342: LD_VAR 0 17
140346: IN
140347: NOT
140348: AND
140349: IFFALSE 140442
// begin if b then
140351: LD_VAR 0 18
140355: IFFALSE 140404
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
140357: LD_VAR 0 18
140361: PPUSH
140362: LD_VAR 0 21
140366: PPUSH
140367: LD_VAR 0 18
140371: PPUSH
140372: CALL_OW 74
140376: PPUSH
140377: CALL_OW 296
140381: PUSH
140382: LD_INT 10
140384: LESS
140385: PUSH
140386: LD_VAR 0 18
140390: PPUSH
140391: CALL_OW 461
140395: PUSH
140396: LD_INT 7
140398: NONEQUAL
140399: AND
140400: IFFALSE 140404
// continue ;
140402: GO 139639
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
140404: LD_ADDR_VAR 0 17
140408: PUSH
140409: LD_VAR 0 17
140413: PPUSH
140414: LD_VAR 0 17
140418: PUSH
140419: LD_INT 1
140421: PLUS
140422: PPUSH
140423: LD_VAR 0 4
140427: PPUSH
140428: CALL_OW 1
140432: ST_TO_ADDR
// ComExitBuilding ( i ) ;
140433: LD_VAR 0 4
140437: PPUSH
140438: CALL_OW 122
// end ; if sold_defenders then
140442: LD_VAR 0 17
140446: IFFALSE 140506
// if i in sold_defenders then
140448: LD_VAR 0 4
140452: PUSH
140453: LD_VAR 0 17
140457: IN
140458: IFFALSE 140506
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
140460: LD_VAR 0 4
140464: PPUSH
140465: CALL_OW 314
140469: NOT
140470: PUSH
140471: LD_VAR 0 4
140475: PPUSH
140476: LD_VAR 0 13
140480: PPUSH
140481: CALL_OW 296
140485: PUSH
140486: LD_INT 30
140488: LESS
140489: AND
140490: IFFALSE 140506
// ComAttackUnit ( i , e ) ;
140492: LD_VAR 0 4
140496: PPUSH
140497: LD_VAR 0 13
140501: PPUSH
140502: CALL_OW 115
// end ; end ; end ;
140506: GO 140509
140508: POP
// if IsDead ( i ) then
140509: LD_VAR 0 4
140513: PPUSH
140514: CALL_OW 301
140518: IFFALSE 140536
// defenders := defenders diff i ;
140520: LD_ADDR_VAR 0 2
140524: PUSH
140525: LD_VAR 0 2
140529: PUSH
140530: LD_VAR 0 4
140534: DIFF
140535: ST_TO_ADDR
// end ;
140536: GO 139639
140538: POP
140539: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
140540: LD_VAR 0 21
140544: NOT
140545: PUSH
140546: LD_VAR 0 2
140550: NOT
140551: OR
140552: PUSH
140553: LD_EXP 102
140557: PUSH
140558: LD_VAR 0 1
140562: ARRAY
140563: NOT
140564: OR
140565: IFFALSE 139543
// MC_Reset ( base , 18 ) ;
140567: LD_VAR 0 1
140571: PPUSH
140572: LD_INT 18
140574: PPUSH
140575: CALL 43743 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
140579: LD_ADDR_VAR 0 2
140583: PUSH
140584: LD_VAR 0 2
140588: PUSH
140589: LD_VAR 0 2
140593: PPUSH
140594: LD_INT 2
140596: PUSH
140597: LD_INT 25
140599: PUSH
140600: LD_INT 1
140602: PUSH
140603: EMPTY
140604: LIST
140605: LIST
140606: PUSH
140607: LD_INT 25
140609: PUSH
140610: LD_INT 5
140612: PUSH
140613: EMPTY
140614: LIST
140615: LIST
140616: PUSH
140617: LD_INT 25
140619: PUSH
140620: LD_INT 8
140622: PUSH
140623: EMPTY
140624: LIST
140625: LIST
140626: PUSH
140627: LD_INT 25
140629: PUSH
140630: LD_INT 9
140632: PUSH
140633: EMPTY
140634: LIST
140635: LIST
140636: PUSH
140637: EMPTY
140638: LIST
140639: LIST
140640: LIST
140641: LIST
140642: LIST
140643: PPUSH
140644: CALL_OW 72
140648: DIFF
140649: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
140650: LD_VAR 0 21
140654: NOT
140655: PUSH
140656: LD_VAR 0 2
140660: PPUSH
140661: LD_INT 21
140663: PUSH
140664: LD_INT 2
140666: PUSH
140667: EMPTY
140668: LIST
140669: LIST
140670: PPUSH
140671: CALL_OW 72
140675: AND
140676: IFFALSE 141014
// begin tmp := FilterByTag ( defenders , 19 ) ;
140678: LD_ADDR_VAR 0 11
140682: PUSH
140683: LD_VAR 0 2
140687: PPUSH
140688: LD_INT 19
140690: PPUSH
140691: CALL 105542 0 2
140695: ST_TO_ADDR
// if tmp then
140696: LD_VAR 0 11
140700: IFFALSE 140770
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
140702: LD_ADDR_VAR 0 11
140706: PUSH
140707: LD_VAR 0 11
140711: PPUSH
140712: LD_INT 25
140714: PUSH
140715: LD_INT 3
140717: PUSH
140718: EMPTY
140719: LIST
140720: LIST
140721: PPUSH
140722: CALL_OW 72
140726: ST_TO_ADDR
// if tmp then
140727: LD_VAR 0 11
140731: IFFALSE 140770
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
140733: LD_ADDR_EXP 114
140737: PUSH
140738: LD_EXP 114
140742: PPUSH
140743: LD_VAR 0 1
140747: PPUSH
140748: LD_EXP 114
140752: PUSH
140753: LD_VAR 0 1
140757: ARRAY
140758: PUSH
140759: LD_VAR 0 11
140763: UNION
140764: PPUSH
140765: CALL_OW 1
140769: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
140770: LD_VAR 0 1
140774: PPUSH
140775: LD_INT 19
140777: PPUSH
140778: CALL 43743 0 2
// repeat wait ( 0 0$1 ) ;
140782: LD_INT 35
140784: PPUSH
140785: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140789: LD_EXP 102
140793: PUSH
140794: LD_VAR 0 1
140798: ARRAY
140799: NOT
140800: PUSH
140801: LD_EXP 102
140805: PUSH
140806: LD_VAR 0 1
140810: ARRAY
140811: PUSH
140812: EMPTY
140813: EQUAL
140814: OR
140815: IFFALSE 140852
// begin for i in defenders do
140817: LD_ADDR_VAR 0 4
140821: PUSH
140822: LD_VAR 0 2
140826: PUSH
140827: FOR_IN
140828: IFFALSE 140841
// ComStop ( i ) ;
140830: LD_VAR 0 4
140834: PPUSH
140835: CALL_OW 141
140839: GO 140827
140841: POP
140842: POP
// defenders := [ ] ;
140843: LD_ADDR_VAR 0 2
140847: PUSH
140848: EMPTY
140849: ST_TO_ADDR
// exit ;
140850: GO 141078
// end ; for i in defenders do
140852: LD_ADDR_VAR 0 4
140856: PUSH
140857: LD_VAR 0 2
140861: PUSH
140862: FOR_IN
140863: IFFALSE 140952
// begin if not IsInArea ( i , mc_parking [ base ] ) then
140865: LD_VAR 0 4
140869: PPUSH
140870: LD_EXP 126
140874: PUSH
140875: LD_VAR 0 1
140879: ARRAY
140880: PPUSH
140881: CALL_OW 308
140885: NOT
140886: IFFALSE 140910
// ComMoveToArea ( i , mc_parking [ base ] ) else
140888: LD_VAR 0 4
140892: PPUSH
140893: LD_EXP 126
140897: PUSH
140898: LD_VAR 0 1
140902: ARRAY
140903: PPUSH
140904: CALL_OW 113
140908: GO 140950
// if GetControl ( i ) = control_manual then
140910: LD_VAR 0 4
140914: PPUSH
140915: CALL_OW 263
140919: PUSH
140920: LD_INT 1
140922: EQUAL
140923: IFFALSE 140950
// if IsDrivenBy ( i ) then
140925: LD_VAR 0 4
140929: PPUSH
140930: CALL_OW 311
140934: IFFALSE 140950
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
140936: LD_VAR 0 4
140940: PPUSH
140941: CALL_OW 311
140945: PPUSH
140946: CALL_OW 121
// end ;
140950: GO 140862
140952: POP
140953: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
140954: LD_VAR 0 2
140958: PPUSH
140959: LD_INT 95
140961: PUSH
140962: LD_EXP 126
140966: PUSH
140967: LD_VAR 0 1
140971: ARRAY
140972: PUSH
140973: EMPTY
140974: LIST
140975: LIST
140976: PPUSH
140977: CALL_OW 72
140981: PUSH
140982: LD_VAR 0 2
140986: EQUAL
140987: PUSH
140988: LD_EXP 125
140992: PUSH
140993: LD_VAR 0 1
140997: ARRAY
140998: OR
140999: PUSH
141000: LD_EXP 102
141004: PUSH
141005: LD_VAR 0 1
141009: ARRAY
141010: NOT
141011: OR
141012: IFFALSE 140782
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
141014: LD_ADDR_EXP 124
141018: PUSH
141019: LD_EXP 124
141023: PPUSH
141024: LD_VAR 0 1
141028: PPUSH
141029: LD_VAR 0 2
141033: PPUSH
141034: LD_INT 21
141036: PUSH
141037: LD_INT 2
141039: PUSH
141040: EMPTY
141041: LIST
141042: LIST
141043: PPUSH
141044: CALL_OW 72
141048: PPUSH
141049: CALL_OW 1
141053: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
141054: LD_VAR 0 1
141058: PPUSH
141059: LD_INT 19
141061: PPUSH
141062: CALL 43743 0 2
// MC_Reset ( base , 20 ) ;
141066: LD_VAR 0 1
141070: PPUSH
141071: LD_INT 20
141073: PPUSH
141074: CALL 43743 0 2
// end ; end_of_file
141078: LD_VAR 0 3
141082: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
141083: LD_VAR 0 1
141087: PUSH
141088: LD_INT 200
141090: DOUBLE
141091: GREATEREQUAL
141092: IFFALSE 141100
141094: LD_INT 299
141096: DOUBLE
141097: LESSEQUAL
141098: IFTRUE 141102
141100: GO 141134
141102: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
141103: LD_VAR 0 1
141107: PPUSH
141108: LD_VAR 0 2
141112: PPUSH
141113: LD_VAR 0 3
141117: PPUSH
141118: LD_VAR 0 4
141122: PPUSH
141123: LD_VAR 0 5
141127: PPUSH
141128: CALL 129264 0 5
141132: GO 141211
141134: LD_INT 300
141136: DOUBLE
141137: GREATEREQUAL
141138: IFFALSE 141146
141140: LD_INT 399
141142: DOUBLE
141143: LESSEQUAL
141144: IFTRUE 141148
141146: GO 141210
141148: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
141149: LD_VAR 0 1
141153: PPUSH
141154: LD_VAR 0 2
141158: PPUSH
141159: LD_VAR 0 3
141163: PPUSH
141164: LD_VAR 0 4
141168: PPUSH
141169: LD_VAR 0 5
141173: PPUSH
141174: LD_VAR 0 6
141178: PPUSH
141179: LD_VAR 0 7
141183: PPUSH
141184: LD_VAR 0 8
141188: PPUSH
141189: LD_VAR 0 9
141193: PPUSH
141194: LD_VAR 0 10
141198: PPUSH
141199: LD_VAR 0 11
141203: PPUSH
141204: CALL 125577 0 11
141208: GO 141211
141210: POP
// end ;
141211: PPOPN 11
141213: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
141214: LD_VAR 0 1
141218: PPUSH
141219: LD_VAR 0 2
141223: PPUSH
141224: LD_VAR 0 3
141228: PPUSH
141229: LD_VAR 0 4
141233: PPUSH
141234: LD_VAR 0 5
141238: PPUSH
141239: CALL 128988 0 5
// end ; end_of_file
141243: PPOPN 5
141245: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
141246: LD_VAR 0 1
141250: PPUSH
141251: LD_VAR 0 2
141255: PPUSH
141256: LD_VAR 0 3
141260: PPUSH
141261: LD_VAR 0 4
141265: PPUSH
141266: LD_VAR 0 5
141270: PPUSH
141271: LD_VAR 0 6
141275: PPUSH
141276: CALL 113229 0 6
// end ;
141280: PPOPN 6
141282: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
141283: LD_INT 0
141285: PPUSH
// begin if not units then
141286: LD_VAR 0 1
141290: NOT
141291: IFFALSE 141295
// exit ;
141293: GO 141295
// end ;
141295: PPOPN 7
141297: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
141298: CALL 113116 0 0
// end ;
141302: PPOPN 1
141304: END
