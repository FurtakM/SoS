// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35061 0 0
// InitNature ;
  19: CALL 34813 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11072 0 0
// PrepareRussian ;
  40: CALL 6956 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14966 0 0
// MC_Start ( ) ;
  60: CALL 37173 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 135
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 136
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59434 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59527 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58877 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58692 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59434 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59527 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58692 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58877 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59307 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58374 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59434 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59527 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 140
 955: PUSH
 956: LD_EXP 140
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58692 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59434 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59527 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58584 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59845 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 59016 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59307 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59307 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59639 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58692 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59258 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 65084 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69908 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69908 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69908 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69908 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69908 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 65084 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 65084 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 65084 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 65084 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 65084 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 65084 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 65084 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 65084 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 65084 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 65084 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 65084 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 65084 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 65084 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 65084 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 65084 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 65084 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 65084 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 65084 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 65084 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 65084 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 65084 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 65084 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 65084 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 65084 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 65084 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 65084 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 65084 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 65084 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 16 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 16
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 16 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 16
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69908 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 65084 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 65084 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 65084 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4448: LD_EXP 61
4452: PPUSH
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 10
4458: PPUSH
4459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_VAR 0 3
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PUSH
4480: LD_INT 30
4482: PUSH
4483: LD_INT 32
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 58
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: PPUSH
4501: CALL_OW 69
4505: ST_TO_ADDR
// for i = 1 to 10 do
4506: LD_ADDR_VAR 0 2
4510: PUSH
4511: DOUBLE
4512: LD_INT 1
4514: DEC
4515: ST_TO_ADDR
4516: LD_INT 10
4518: PUSH
4519: FOR_TO
4520: IFFALSE 4592
// begin uc_nation := nation_nature ;
4522: LD_ADDR_OWVAR 21
4526: PUSH
4527: LD_INT 0
4529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4530: LD_ADDR_OWVAR 28
4534: PUSH
4535: LD_INT 15
4537: ST_TO_ADDR
// hc_gallery :=  ;
4538: LD_ADDR_OWVAR 33
4542: PUSH
4543: LD_STRING 
4545: ST_TO_ADDR
// hc_name :=  ;
4546: LD_ADDR_OWVAR 26
4550: PUSH
4551: LD_STRING 
4553: ST_TO_ADDR
// un := CreateHuman ;
4554: LD_ADDR_VAR 0 4
4558: PUSH
4559: CALL_OW 44
4563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4564: LD_VAR 0 4
4568: PPUSH
4569: LD_VAR 0 5
4573: PUSH
4574: LD_VAR 0 5
4578: PUSH
4579: LD_VAR 0 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// end ;
4590: GO 4519
4592: POP
4593: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4594: LD_ADDR_VAR 0 5
4598: PUSH
4599: LD_STRING 12_kurt_squad
4601: PPUSH
4602: CALL_OW 31
4606: ST_TO_ADDR
// if tmp then
4607: LD_VAR 0 5
4611: IFFALSE 4645
// for i in tmp do
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_VAR 0 5
4622: PUSH
4623: FOR_IN
4624: IFFALSE 4643
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4626: LD_VAR 0 2
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 0
4636: PPUSH
4637: CALL_OW 49
4641: GO 4623
4643: POP
4644: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4645: LD_INT 324
4647: PPUSH
4648: LD_INT 5
4650: PPUSH
4651: LD_STRING 
4653: PPUSH
4654: LD_INT 8
4656: PUSH
4657: LD_INT 9
4659: PUSH
4660: LD_INT 10
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_OWVAR 67
4672: ARRAY
4673: PPUSH
4674: LD_INT 3000
4676: PUSH
4677: LD_INT 500
4679: PUSH
4680: LD_INT 150
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: LIST
4687: PPUSH
4688: LD_INT 16
4690: PUSH
4691: LD_INT 6
4693: PUSH
4694: LD_INT 6
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PPUSH
4706: CALL 73317 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4710: LD_ADDR_EXP 111
4714: PUSH
4715: LD_EXP 111
4719: PPUSH
4720: LD_INT 3
4722: PPUSH
4723: LD_INT 22
4725: PUSH
4726: LD_VAR 0 3
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 3
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 2
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: PUSH
4772: LD_EXP 60
4776: DIFF
4777: PPUSH
4778: CALL_OW 1
4782: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 7
4788: PPUSH
4789: CALL_OW 383
// Friend := CreateHuman ;
4793: LD_ADDR_EXP 62
4797: PUSH
4798: CALL_OW 44
4802: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4803: LD_INT 14
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 1
4811: PPUSH
4812: LD_INT 29
4814: PPUSH
4815: LD_INT 100
4817: PPUSH
4818: CALL 69908 0 5
// powellBomb := CreateVehicle ;
4822: LD_ADDR_EXP 63
4826: PUSH
4827: CALL_OW 45
4831: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4832: LD_EXP 63
4836: PPUSH
4837: LD_INT 90
4839: PPUSH
4840: LD_INT 51
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 48
// end ;
4850: LD_VAR 0 1
4854: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4855: LD_INT 0
4857: PPUSH
4858: PPUSH
4859: PPUSH
// if IsLive ( kozlov_fac ) then
4860: LD_INT 332
4862: PPUSH
4863: CALL_OW 300
4867: IFFALSE 4871
// exit ;
4869: GO 5438
// ComExitBuilding ( Kozlov ) ;
4871: LD_EXP 61
4875: PPUSH
4876: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4880: LD_EXP 61
4884: PPUSH
4885: CALL_OW 257
4889: PUSH
4890: LD_INT 2
4892: NONEQUAL
4893: IFFALSE 4928
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4895: LD_EXP 61
4899: PPUSH
4900: LD_INT 324
4902: PPUSH
4903: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4907: LD_EXP 61
4911: PPUSH
4912: LD_INT 2
4914: PPUSH
4915: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4919: LD_EXP 61
4923: PPUSH
4924: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4928: LD_EXP 61
4932: PPUSH
4933: LD_INT 2
4935: PPUSH
4936: LD_INT 93
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4956: LD_INT 22
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 3
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PUSH
4986: LD_INT 57
4988: PUSH
4989: EMPTY
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: IFFALSE 4949
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 8
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 3
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 23
5031: PUSH
5032: LD_INT 3
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 57
5041: PUSH
5042: EMPTY
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 1
5058: ARRAY
5059: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5060: LD_INT 22
5062: PUSH
5063: LD_INT 8
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 3
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 21
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 69
5099: NOT
5100: IFFALSE 5178
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5102: LD_EXP 61
5106: PPUSH
5107: LD_INT 21
5109: PPUSH
5110: LD_INT 97
5112: PPUSH
5113: LD_INT 36
5115: PPUSH
5116: LD_INT 5
5118: PPUSH
5119: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5130: LD_INT 22
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 23
5142: PUSH
5143: LD_INT 3
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 30
5152: PUSH
5153: LD_INT 21
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 57
5162: PUSH
5163: EMPTY
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: IFFALSE 5123
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5178: LD_INT 22
5180: PUSH
5181: LD_INT 8
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: LD_INT 23
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 30
5200: PUSH
5201: LD_INT 18
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 69
5217: NOT
5218: IFFALSE 5296
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5220: LD_EXP 61
5224: PPUSH
5225: LD_INT 18
5227: PPUSH
5228: LD_INT 89
5230: PPUSH
5231: LD_INT 32
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5241: LD_INT 35
5243: PPUSH
5244: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5248: LD_INT 22
5250: PUSH
5251: LD_INT 8
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: LD_INT 23
5260: PUSH
5261: LD_INT 3
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: LD_INT 18
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 57
5280: PUSH
5281: EMPTY
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 69
5294: IFFALSE 5241
// end ; lab := kozlov_lab ;
5296: LD_ADDR_VAR 0 3
5300: PUSH
5301: LD_INT 336
5303: ST_TO_ADDR
// if not lab then
5304: LD_VAR 0 3
5308: NOT
5309: IFFALSE 5313
// exit ;
5311: GO 5438
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5313: LD_EXP 61
5317: PPUSH
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 1
5325: ARRAY
5326: PPUSH
5327: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5331: LD_EXP 61
5335: PPUSH
5336: LD_INT 4
5338: PPUSH
5339: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: LD_INT 25
5354: PPUSH
5355: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5359: LD_INT 35
5361: PPUSH
5362: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5366: LD_INT 25
5368: PPUSH
5369: LD_INT 8
5371: PPUSH
5372: CALL_OW 321
5376: PUSH
5377: LD_INT 2
5379: EQUAL
5380: IFFALSE 5359
// ComExitBuilding ( Kozlov ) ;
5382: LD_EXP 61
5386: PPUSH
5387: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5391: LD_EXP 61
5395: PPUSH
5396: LD_VAR 0 2
5400: PPUSH
5401: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5405: LD_EXP 61
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_INT 23
5424: PPUSH
5425: LD_INT 3
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 48
5433: PPUSH
5434: CALL_OW 125
// end ;
5438: LD_VAR 0 1
5442: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5443: LD_EXP 22
5447: NOT
5448: PUSH
5449: LD_EXP 15
5453: PUSH
5454: LD_INT 6
5456: GREATEREQUAL
5457: AND
5458: IFFALSE 5539
5460: GO 5462
5462: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5463: LD_INT 3
5465: PPUSH
5466: LD_INT 3
5468: PPUSH
5469: CALL 58877 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5473: LD_INT 3
5475: PPUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 14
5496: PUSH
5497: LD_INT 1
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 28
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 14
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 28
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 58740 0 2
// end ;
5539: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5540: LD_EXP 22
5544: NOT
5545: PUSH
5546: LD_EXP 15
5550: PUSH
5551: LD_INT 6
5553: GREATEREQUAL
5554: AND
5555: PUSH
5556: LD_INT 3
5558: PPUSH
5559: LD_INT 1
5561: PPUSH
5562: CALL 60158 0 2
5566: NOT
5567: AND
5568: IFFALSE 6408
5570: GO 5572
5572: DISABLE
5573: LD_INT 0
5575: PPUSH
5576: PPUSH
5577: PPUSH
// begin enable ;
5578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5579: LD_INT 22
5581: PUSH
5582: LD_INT 8
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 23
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 6408
// if Prob ( 40 ) then
5623: LD_INT 40
5625: PPUSH
5626: CALL_OW 13
5630: IFFALSE 5757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5632: LD_INT 3
5634: PPUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 28
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PPUSH
5751: CALL 58740 0 2
// end else
5755: GO 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 14
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 27
5771: PUSH
5772: LD_INT 26
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_OWVAR 67
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 14
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 27
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: PUSH
5853: LD_OWVAR 67
5857: ARRAY
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: PUSH
5865: LD_INT 13
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: LD_INT 2
5873: PUSH
5874: LD_INT 26
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: LD_INT 29
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 13
5902: PUSH
5903: LD_INT 1
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: LD_INT 29
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 14
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: LD_INT 26
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL 58740 0 2
// end ; repeat wait ( 0 0$1 ) ;
5948: LD_INT 35
5950: PPUSH
5951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5955: LD_INT 3
5957: PPUSH
5958: LD_INT 1
5960: PPUSH
5961: CALL 60158 0 2
5965: PUSH
5966: LD_INT 6
5968: GREATEREQUAL
5969: IFFALSE 5948
// wait ( 0 0$30 ) ;
5971: LD_INT 1050
5973: PPUSH
5974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_INT 3
5985: PPUSH
5986: LD_INT 1
5988: PPUSH
5989: CALL 60158 0 2
5993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5994: LD_ADDR_EXP 130
5998: PUSH
5999: LD_EXP 130
6003: PPUSH
6004: LD_INT 3
6006: PPUSH
6007: LD_EXP 130
6011: PUSH
6012: LD_INT 3
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 2
6020: DIFF
6021: PPUSH
6022: CALL_OW 1
6026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6027: LD_ADDR_VAR 0 3
6031: PUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: CALL_OW 12
6042: ST_TO_ADDR
// if target then
6043: LD_VAR 0 3
6047: IFFALSE 6175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 24
6061: PUSH
6062: LD_INT 250
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i in tmp do
6074: LD_ADDR_VAR 0 1
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: FOR_IN
6085: IFFALSE 6125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6087: LD_VAR 0 1
6091: PPUSH
6092: LD_INT 89
6094: PPUSH
6095: LD_INT 71
6097: PPUSH
6098: CALL_OW 297
6102: PUSH
6103: LD_INT 9
6105: GREATER
6106: IFFALSE 6123
// ComMoveXY ( i , 89 , 71 ) ;
6108: LD_VAR 0 1
6112: PPUSH
6113: LD_INT 89
6115: PPUSH
6116: LD_INT 71
6118: PPUSH
6119: CALL_OW 111
6123: GO 6084
6125: POP
6126: POP
// wait ( 0 0$1 ) ;
6127: LD_INT 35
6129: PPUSH
6130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: LD_INT 92
6141: PUSH
6142: LD_INT 89
6144: PUSH
6145: LD_INT 71
6147: PUSH
6148: LD_INT 9
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 72
6161: PUSH
6162: LD_VAR 0 2
6166: PUSH
6167: LD_INT 1
6169: MINUS
6170: GREATEREQUAL
6171: IFFALSE 6049
// end else
6173: GO 6299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_VAR 0 2
6184: PPUSH
6185: LD_INT 24
6187: PUSH
6188: LD_INT 250
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 72
6199: ST_TO_ADDR
// for i in tmp do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_IN
6211: IFFALSE 6251
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 125
6220: PPUSH
6221: LD_INT 129
6223: PPUSH
6224: CALL_OW 297
6228: PUSH
6229: LD_INT 9
6231: GREATER
6232: IFFALSE 6249
// ComMoveXY ( i , 125 , 129 ) ;
6234: LD_VAR 0 1
6238: PPUSH
6239: LD_INT 125
6241: PPUSH
6242: LD_INT 129
6244: PPUSH
6245: CALL_OW 111
6249: GO 6210
6251: POP
6252: POP
// wait ( 0 0$1 ) ;
6253: LD_INT 35
6255: PPUSH
6256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 92
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 129
6273: PUSH
6274: LD_INT 9
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PPUSH
6283: CALL_OW 72
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: LD_INT 1
6295: MINUS
6296: GREATEREQUAL
6297: IFFALSE 6175
// end ; repeat wait ( 0 0$1 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// for i in tmp do
6306: LD_ADDR_VAR 0 1
6310: PUSH
6311: LD_VAR 0 2
6315: PUSH
6316: FOR_IN
6317: IFFALSE 6399
// begin if GetLives ( i ) > 251 then
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 256
6328: PUSH
6329: LD_INT 251
6331: GREATER
6332: IFFALSE 6370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_INT 81
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PPUSH
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 74
6363: PPUSH
6364: CALL_OW 115
6368: GO 6397
// if IsDead ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 301
6379: IFFALSE 6397
// tmp := tmp diff i ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PUSH
6391: LD_VAR 0 1
6395: DIFF
6396: ST_TO_ADDR
// end ;
6397: GO 6316
6399: POP
6400: POP
// until not tmp ;
6401: LD_VAR 0 2
6405: NOT
6406: IFFALSE 6299
// end ;
6408: PPOPN 3
6410: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6411: LD_EXP 22
6415: NOT
6416: PUSH
6417: LD_EXP 15
6421: PUSH
6422: LD_INT 6
6424: GREATEREQUAL
6425: AND
6426: PUSH
6427: LD_OWVAR 67
6431: PUSH
6432: LD_INT 1
6434: GREATER
6435: AND
6436: IFFALSE 6953
6438: GO 6440
6440: DISABLE
6441: LD_INT 0
6443: PPUSH
6444: PPUSH
6445: PPUSH
// begin enable ;
6446: ENABLE
// tmp := [ ] ;
6447: LD_ADDR_VAR 0 3
6451: PUSH
6452: EMPTY
6453: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6454: LD_ADDR_VAR 0 1
6458: PUSH
6459: DOUBLE
6460: LD_INT 1
6462: DEC
6463: ST_TO_ADDR
6464: LD_INT 4
6466: PUSH
6467: LD_INT 6
6469: PUSH
6470: LD_INT 7
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_OWVAR 67
6482: ARRAY
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6645
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6503: LD_INT 13
6505: PUSH
6506: LD_INT 14
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_INT 5
6530: PPUSH
6531: LD_INT 27
6533: PUSH
6534: LD_INT 28
6536: PUSH
6537: LD_INT 26
6539: PUSH
6540: LD_INT 25
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 1
6551: PPUSH
6552: LD_INT 4
6554: PPUSH
6555: CALL_OW 12
6559: ARRAY
6560: PPUSH
6561: LD_INT 88
6563: PPUSH
6564: CALL 69908 0 5
// un := CreateVehicle ;
6568: LD_ADDR_VAR 0 2
6572: PUSH
6573: CALL_OW 45
6577: ST_TO_ADDR
// tmp := tmp ^ un ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: ADD
6593: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 30
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6621: LD_VAR 0 2
6625: PPUSH
6626: LD_INT 16
6628: PPUSH
6629: LD_INT 11
6631: PPUSH
6632: CALL_OW 111
// wait ( 0 0$2 ) ;
6636: LD_INT 70
6638: PPUSH
6639: CALL_OW 67
// end ;
6643: GO 6484
6645: POP
6646: POP
// for i = 1 to Difficulty do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_OWVAR 67
6661: PUSH
6662: FOR_TO
6663: IFFALSE 6788
// begin uc_side := 8 ;
6665: LD_ADDR_OWVAR 20
6669: PUSH
6670: LD_INT 8
6672: ST_TO_ADDR
// uc_nation := 2 ;
6673: LD_ADDR_OWVAR 21
6677: PUSH
6678: LD_INT 2
6680: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6681: LD_INT 0
6683: PPUSH
6684: LD_INT 8
6686: PPUSH
6687: LD_INT 8
6689: PUSH
6690: LD_INT 8
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: PUSH
6701: LD_OWVAR 67
6705: ARRAY
6706: PPUSH
6707: CALL_OW 380
// un := CreateHuman ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: CALL_OW 44
6720: ST_TO_ADDR
// tmp := tmp ^ un ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: ADD
6736: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6737: LD_VAR 0 2
6741: PPUSH
6742: LD_INT 3
6744: PPUSH
6745: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 30
6756: PPUSH
6757: LD_INT 0
6759: PPUSH
6760: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6764: LD_VAR 0 2
6768: PPUSH
6769: LD_INT 16
6771: PPUSH
6772: LD_INT 11
6774: PPUSH
6775: CALL_OW 111
// wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// end ;
6786: GO 6662
6788: POP
6789: POP
// repeat wait ( 0 0$1 ) ;
6790: LD_INT 35
6792: PPUSH
6793: CALL_OW 67
// for i in tmp do
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: FOR_IN
6808: IFFALSE 6944
// begin if GetLives ( i ) > 250 then
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 250
6822: GREATER
6823: IFFALSE 6915
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6825: LD_INT 81
6827: PUSH
6828: LD_INT 8
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 91
6837: PUSH
6838: LD_VAR 0 1
6842: PUSH
6843: LD_INT 10
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: NOT
6860: IFFALSE 6879
// ComAgressiveMove ( i , 67 , 110 ) else
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 67
6869: PPUSH
6870: LD_INT 110
6872: PPUSH
6873: CALL_OW 114
6877: GO 6913
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 81
6886: PUSH
6887: LD_INT 8
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: CALL_OW 74
6908: PPUSH
6909: CALL_OW 115
// end else
6913: GO 6942
// if IsDead ( i ) then
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 301
6924: IFFALSE 6942
// tmp := tmp diff i ;
6926: LD_ADDR_VAR 0 3
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 1
6940: DIFF
6941: ST_TO_ADDR
// end ;
6942: GO 6807
6944: POP
6945: POP
// until not tmp ;
6946: LD_VAR 0 3
6950: NOT
6951: IFFALSE 6790
// end ; end_of_file
6953: PPOPN 3
6955: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
// side := 3 ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_INT 3
6974: ST_TO_ADDR
// uc_side := side ;
6975: LD_ADDR_OWVAR 20
6979: PUSH
6980: LD_VAR 0 6
6984: ST_TO_ADDR
// uc_nation := 3 ;
6985: LD_ADDR_OWVAR 21
6989: PUSH
6990: LD_INT 3
6992: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_VAR 0 6
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 21
7012: PUSH
7013: LD_INT 3
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 69
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetBLevel ( i , 10 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 10
7039: PPUSH
7040: CALL_OW 241
7044: GO 7029
7046: POP
7047: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7048: LD_ADDR_VAR 0 9
7052: PUSH
7053: LD_INT 22
7055: PUSH
7056: LD_VAR 0 6
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 34
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PPUSH
7079: CALL_OW 69
7083: ST_TO_ADDR
// if teleport then
7084: LD_VAR 0 9
7088: IFFALSE 7109
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7090: LD_VAR 0 9
7094: PUSH
7095: LD_INT 1
7097: ARRAY
7098: PPUSH
7099: LD_INT 123
7101: PPUSH
7102: LD_INT 122
7104: PPUSH
7105: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7109: LD_ADDR_EXP 64
7113: PUSH
7114: LD_STRING Platonov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7122: LD_ADDR_EXP 65
7126: PUSH
7127: LD_STRING Kovalyuk
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7135: LD_ADDR_EXP 67
7139: PUSH
7140: LD_STRING Yakotich
7142: PPUSH
7143: LD_EXP 1
7147: NOT
7148: PPUSH
7149: LD_STRING 09_
7151: PPUSH
7152: CALL 65084 0 3
7156: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7157: LD_ADDR_EXP 66
7161: PUSH
7162: LD_STRING Bystrov
7164: PPUSH
7165: CALL_OW 25
7169: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7170: LD_ADDR_EXP 68
7174: PUSH
7175: LD_STRING Gleb
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7183: LD_STRING 03_Cornel
7185: PPUSH
7186: CALL_OW 28
7190: IFFALSE 7238
// begin Bierezov := NewCharacter ( Mikhail ) ;
7192: LD_ADDR_EXP 69
7196: PUSH
7197: LD_STRING Mikhail
7199: PPUSH
7200: CALL_OW 25
7204: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7205: LD_EXP 69
7209: PPUSH
7210: LD_INT 197
7212: PPUSH
7213: LD_INT 111
7215: PPUSH
7216: LD_INT 9
7218: PPUSH
7219: LD_INT 0
7221: PPUSH
7222: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 3
7233: PPUSH
7234: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7238: LD_EXP 64
7242: PPUSH
7243: LD_INT 126
7245: PPUSH
7246: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7250: LD_EXP 65
7254: PPUSH
7255: LD_INT 134
7257: PPUSH
7258: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7262: LD_EXP 67
7266: PPUSH
7267: LD_INT 197
7269: PPUSH
7270: LD_INT 111
7272: PPUSH
7273: LD_INT 9
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7283: LD_EXP 66
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7304: LD_EXP 68
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: LD_INT 126
7332: PPUSH
7333: LD_INT 4
7335: PPUSH
7336: LD_STRING zhukov
7338: PPUSH
7339: LD_INT 9
7341: PUSH
7342: LD_INT 10
7344: PUSH
7345: LD_INT 10
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PUSH
7353: LD_OWVAR 67
7357: ARRAY
7358: PPUSH
7359: LD_INT 90000
7361: PUSH
7362: LD_INT 1000
7364: PUSH
7365: LD_INT 300
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PPUSH
7373: LD_INT 18
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: LD_INT 13
7381: PUSH
7382: LD_INT 8
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PPUSH
7391: CALL 73317 0 6
7395: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7396: LD_ADDR_VAR 0 4
7400: PUSH
7401: LD_INT 267
7403: PPUSH
7404: CALL_OW 274
7408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 1
7416: PPUSH
7417: LD_INT 5000
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7439: LD_VAR 0 4
7443: PPUSH
7444: LD_INT 3
7446: PPUSH
7447: LD_INT 200
7449: PPUSH
7450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7454: LD_ADDR_EXP 111
7458: PUSH
7459: LD_EXP 111
7463: PPUSH
7464: LD_INT 2
7466: PPUSH
7467: LD_VAR 0 5
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_VAR 0 6
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 21
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: UNION
7510: PUSH
7511: LD_EXP 64
7515: DIFF
7516: PPUSH
7517: CALL_OW 1
7521: ST_TO_ADDR
// behemoths := [ ] ;
7522: LD_ADDR_EXP 72
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// behemothBuilders := [ ] ;
7529: LD_ADDR_EXP 73
7533: PUSH
7534: EMPTY
7535: ST_TO_ADDR
// if Kovalyuk then
7536: LD_EXP 65
7540: IFFALSE 7562
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7542: LD_ADDR_EXP 73
7546: PUSH
7547: LD_EXP 73
7551: PPUSH
7552: LD_EXP 65
7556: PPUSH
7557: CALL 100954 0 2
7561: ST_TO_ADDR
// j := 3 ;
7562: LD_ADDR_VAR 0 3
7566: PUSH
7567: LD_INT 3
7569: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 25
7587: PUSH
7588: LD_INT 3
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: PUSH
7604: LD_EXP 65
7608: DIFF
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7661
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7613: LD_ADDR_EXP 73
7617: PUSH
7618: LD_EXP 73
7622: PPUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: CALL 100954 0 2
7632: ST_TO_ADDR
// j := j - 1 ;
7633: LD_ADDR_VAR 0 3
7637: PUSH
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 1
7645: MINUS
7646: ST_TO_ADDR
// if j = 0 then
7647: LD_VAR 0 3
7651: PUSH
7652: LD_INT 0
7654: EQUAL
7655: IFFALSE 7659
// break ;
7657: GO 7661
// end ;
7659: GO 7610
7661: POP
7662: POP
// end ;
7663: LD_VAR 0 1
7667: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7668: LD_INT 0
7670: PPUSH
7671: PPUSH
7672: PPUSH
7673: PPUSH
7674: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 209
7682: PUSH
7683: LD_INT 149
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 219
7692: PUSH
7693: LD_INT 154
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 223
7702: PUSH
7703: LD_INT 149
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 232
7712: PUSH
7713: LD_INT 155
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: ST_TO_ADDR
// if not behemothBuilders then
7726: LD_EXP 73
7730: NOT
7731: IFFALSE 7735
// exit ;
7733: GO 7839
// j := 1 ;
7735: LD_ADDR_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ST_TO_ADDR
// for i in behemothBuilders do
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_EXP 73
7752: PUSH
7753: FOR_IN
7754: IFFALSE 7837
// begin if IsInUnit ( i ) then
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 310
7765: IFFALSE 7776
// ComExitBuilding ( i ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 37
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 1
7797: ARRAY
7798: PPUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 3
7808: ARRAY
7809: PUSH
7810: LD_INT 2
7812: ARRAY
7813: PPUSH
7814: LD_INT 0
7816: PPUSH
7817: CALL_OW 230
// j := j + 1 ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_VAR 0 3
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7753
7837: POP
7838: POP
// end ;
7839: LD_VAR 0 1
7843: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7844: LD_INT 24
7846: PPUSH
7847: LD_INT 30
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 70
7861: IFFALSE 7874
7863: GO 7865
7865: DISABLE
// behemothUnderConstruct := true ;
7866: LD_ADDR_EXP 26
7870: PUSH
7871: LD_INT 1
7873: ST_TO_ADDR
7874: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7875: LD_INT 3
7877: PPUSH
7878: CALL 101002 0 1
7882: PUSH
7883: LD_INT 22
7885: PUSH
7886: LD_INT 3
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: LD_INT 30
7895: PUSH
7896: LD_INT 37
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: NOT
7912: AND
7913: IFFALSE 8099
7915: GO 7917
7917: DISABLE
7918: LD_INT 0
7920: PPUSH
7921: PPUSH
// begin enable ;
7922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7923: LD_ADDR_VAR 0 2
7927: PUSH
7928: LD_INT 3
7930: PPUSH
7931: CALL 101002 0 1
7935: ST_TO_ADDR
// for i in tmp do
7936: LD_ADDR_VAR 0 1
7940: PUSH
7941: LD_VAR 0 2
7945: PUSH
7946: FOR_IN
7947: IFFALSE 8097
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 9
7956: PPUSH
7957: CALL_OW 308
7961: PUSH
7962: LD_VAR 0 1
7966: PPUSH
7967: CALL_OW 110
7971: PUSH
7972: LD_INT 2
7974: EQUAL
7975: NOT
7976: AND
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7991: LD_INT 81
7993: PUSH
7994: LD_INT 3
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 91
8003: PUSH
8004: LD_VAR 0 1
8008: PUSH
8009: LD_INT 12
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: NOT
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8061
// ComAgressiveMove ( i , 64 , 93 ) else
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 64
8051: PPUSH
8052: LD_INT 93
8054: PPUSH
8055: CALL_OW 114
8059: GO 8095
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8061: LD_VAR 0 1
8065: PPUSH
8066: LD_INT 81
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: PPUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 74
8090: PPUSH
8091: CALL_OW 115
// end ;
8095: GO 7946
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
8106: PPUSH
// result := [ ] ;
8107: LD_ADDR_VAR 0 2
8111: PUSH
8112: EMPTY
8113: ST_TO_ADDR
// uc_side := 6 ;
8114: LD_ADDR_OWVAR 20
8118: PUSH
8119: LD_INT 6
8121: ST_TO_ADDR
// uc_nation := 3 ;
8122: LD_ADDR_OWVAR 21
8126: PUSH
8127: LD_INT 3
8129: ST_TO_ADDR
// case strength of 1 :
8130: LD_VAR 0 1
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8281
8143: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8144: LD_ADDR_VAR 0 3
8148: PUSH
8149: DOUBLE
8150: LD_INT 1
8152: DEC
8153: ST_TO_ADDR
8154: LD_INT 4
8156: PUSH
8157: LD_INT 5
8159: PUSH
8160: LD_INT 6
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_OWVAR 67
8172: ARRAY
8173: PUSH
8174: FOR_TO
8175: IFFALSE 8277
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8177: LD_INT 22
8179: PUSH
8180: LD_INT 24
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 2
8194: MOD
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: ARRAY
8200: PPUSH
8201: LD_INT 1
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_INT 2
8216: PPUSH
8217: CALL_OW 12
8221: ARRAY
8222: PPUSH
8223: LD_INT 3
8225: PPUSH
8226: LD_INT 43
8228: PUSH
8229: LD_INT 44
8231: PUSH
8232: LD_INT 45
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 3
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 80
8254: PPUSH
8255: CALL 69908 0 5
// result := result union CreateVehicle ;
8259: LD_ADDR_VAR 0 2
8263: PUSH
8264: LD_VAR 0 2
8268: PUSH
8269: CALL_OW 45
8273: UNION
8274: ST_TO_ADDR
// end ;
8275: GO 8174
8277: POP
8278: POP
// end ; 2 :
8279: GO 9232
8281: LD_INT 2
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8445
8289: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_OWVAR 67
8318: ARRAY
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8323: LD_INT 22
8325: PUSH
8326: LD_INT 24
8328: PUSH
8329: LD_INT 24
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 3
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: LD_INT 44
8387: PUSH
8388: LD_INT 46
8390: PUSH
8391: LD_INT 46
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 6
8409: MOD
8410: PUSH
8411: LD_INT 1
8413: PLUS
8414: ARRAY
8415: PPUSH
8416: LD_INT 80
8418: PPUSH
8419: CALL 69908 0 5
// result := result union CreateVehicle ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: CALL_OW 45
8437: UNION
8438: ST_TO_ADDR
// end ;
8439: GO 8320
8441: POP
8442: POP
// end ; 3 :
8443: GO 9232
8445: LD_INT 3
8447: DOUBLE
8448: EQUAL
8449: IFTRUE 8453
8451: GO 8609
8453: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8454: LD_ADDR_VAR 0 3
8458: PUSH
8459: DOUBLE
8460: LD_INT 1
8462: DEC
8463: ST_TO_ADDR
8464: LD_INT 5
8466: PUSH
8467: LD_INT 7
8469: PUSH
8470: LD_INT 8
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: FOR_TO
8485: IFFALSE 8605
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8487: LD_INT 22
8489: PUSH
8490: LD_INT 24
8492: PUSH
8493: LD_INT 24
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: LIST
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_INT 3
8508: MOD
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PUSH
8518: LD_INT 3
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 1
8527: PPUSH
8528: LD_INT 2
8530: PPUSH
8531: CALL_OW 12
8535: ARRAY
8536: PPUSH
8537: LD_INT 3
8539: PPUSH
8540: LD_INT 43
8542: PUSH
8543: LD_INT 47
8545: PUSH
8546: LD_INT 45
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: LD_INT 46
8554: PUSH
8555: LD_INT 46
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: PUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 6
8573: MOD
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: ARRAY
8579: PPUSH
8580: LD_INT 80
8582: PPUSH
8583: CALL 69908 0 5
// result := result union CreateVehicle ;
8587: LD_ADDR_VAR 0 2
8591: PUSH
8592: LD_VAR 0 2
8596: PUSH
8597: CALL_OW 45
8601: UNION
8602: ST_TO_ADDR
// end ;
8603: GO 8484
8605: POP
8606: POP
// end ; 4 :
8607: GO 9232
8609: LD_INT 4
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 9231
8617: POP
// begin uc_nation := 3 ;
8618: LD_ADDR_OWVAR 21
8622: PUSH
8623: LD_INT 3
8625: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8626: LD_ADDR_VAR 0 3
8630: PUSH
8631: DOUBLE
8632: LD_INT 1
8634: DEC
8635: ST_TO_ADDR
8636: LD_INT 6
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 9
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: FOR_TO
8657: IFFALSE 8777
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8659: LD_INT 22
8661: PUSH
8662: LD_INT 24
8664: PUSH
8665: LD_INT 24
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: LD_INT 3
8680: MOD
8681: PUSH
8682: LD_INT 1
8684: PLUS
8685: ARRAY
8686: PPUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ARRAY
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 47
8717: PUSH
8718: LD_INT 47
8720: PUSH
8721: LD_INT 45
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: LD_INT 46
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 6
8745: MOD
8746: PUSH
8747: LD_INT 1
8749: PLUS
8750: ARRAY
8751: PPUSH
8752: LD_INT 80
8754: PPUSH
8755: CALL 69908 0 5
// result := result union CreateVehicle ;
8759: LD_ADDR_VAR 0 2
8763: PUSH
8764: LD_VAR 0 2
8768: PUSH
8769: CALL_OW 45
8773: UNION
8774: ST_TO_ADDR
// end ;
8775: GO 8656
8777: POP
8778: POP
// if not KappaStatus then
8779: LD_EXP 2
8783: NOT
8784: IFFALSE 9019
// begin uc_nation := 1 ;
8786: LD_ADDR_OWVAR 21
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// for i = 1 to 3 do
8794: LD_ADDR_VAR 0 3
8798: PUSH
8799: DOUBLE
8800: LD_INT 1
8802: DEC
8803: ST_TO_ADDR
8804: LD_INT 3
8806: PUSH
8807: FOR_TO
8808: IFFALSE 8944
// begin j := rand ( 0 , 1 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 0
8817: PPUSH
8818: LD_INT 1
8820: PPUSH
8821: CALL_OW 12
8825: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8826: LD_INT 3
8828: PUSH
8829: LD_INT 5
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_VAR 0 4
8848: PUSH
8849: LD_INT 1
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: CALL_OW 12
8859: PLUS
8860: ARRAY
8861: PPUSH
8862: LD_INT 1
8864: PUSH
8865: LD_INT 3
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: PUSH
8872: LD_INT 1
8874: PPUSH
8875: LD_INT 2
8877: PPUSH
8878: CALL_OW 12
8882: ARRAY
8883: PPUSH
8884: LD_INT 3
8886: PPUSH
8887: LD_INT 9
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: LD_INT 6
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_VAR 0 4
8905: PUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 12
8916: PLUS
8917: ARRAY
8918: PPUSH
8919: LD_INT 85
8921: PPUSH
8922: CALL 69908 0 5
// result := result union CreateVehicle ;
8926: LD_ADDR_VAR 0 2
8930: PUSH
8931: LD_VAR 0 2
8935: PUSH
8936: CALL_OW 45
8940: UNION
8941: ST_TO_ADDR
// end ;
8942: GO 8807
8944: POP
8945: POP
// if vsevolodFirstAttack then
8946: LD_EXP 24
8950: IFFALSE 9017
// begin vsevolodFirstAttack := false ;
8952: LD_ADDR_EXP 24
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8960: LD_INT 5
8962: PPUSH
8963: LD_INT 3
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 6
8971: PPUSH
8972: LD_INT 100
8974: PPUSH
8975: CALL 69908 0 5
// sewiVeh := CreateVehicle ;
8979: LD_ADDR_EXP 71
8983: PUSH
8984: CALL_OW 45
8988: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8989: LD_EXP 71
8993: PPUSH
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 242
// result := result union sewiVeh ;
9001: LD_ADDR_VAR 0 2
9005: PUSH
9006: LD_VAR 0 2
9010: PUSH
9011: LD_EXP 71
9015: UNION
9016: ST_TO_ADDR
// end ; end else
9017: GO 9229
// if vsevolodFirstAttack then
9019: LD_EXP 24
9023: IFFALSE 9229
// begin vsevolodFirstAttack := false ;
9025: LD_ADDR_EXP 24
9029: PUSH
9030: LD_INT 0
9032: ST_TO_ADDR
// uc_nation := 3 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 3
9040: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 2
9053: PUSH
9054: LD_OWVAR 67
9058: PLUS
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9169
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9063: LD_INT 22
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 24
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 3
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: PPUSH
9091: LD_INT 1
9093: PUSH
9094: LD_INT 3
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 2
9106: PPUSH
9107: CALL_OW 12
9111: ARRAY
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 45
9118: PUSH
9119: LD_INT 47
9121: PUSH
9122: LD_INT 47
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 80
9146: PPUSH
9147: CALL 69908 0 5
// result := result union CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: LD_VAR 0 2
9160: PUSH
9161: CALL_OW 45
9165: UNION
9166: ST_TO_ADDR
// end ;
9167: GO 9060
9169: POP
9170: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9171: LD_INT 24
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: LD_INT 47
9182: PPUSH
9183: LD_INT 100
9185: PPUSH
9186: CALL 69908 0 5
// sewiVeh := CreateVehicle ;
9190: LD_ADDR_EXP 71
9194: PUSH
9195: CALL_OW 45
9199: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9200: LD_EXP 71
9204: PPUSH
9205: LD_INT 6
9207: NEG
9208: PPUSH
9209: CALL_OW 242
// result := result union sewiVeh ;
9213: LD_ADDR_VAR 0 2
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_EXP 71
9227: UNION
9228: ST_TO_ADDR
// end ; end ; end ;
9229: GO 9232
9231: POP
// end ;
9232: LD_VAR 0 2
9236: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9237: LD_EXP 16
9241: IFFALSE 10082
9243: GO 9245
9245: DISABLE
9246: LD_INT 0
9248: PPUSH
9249: PPUSH
9250: PPUSH
9251: PPUSH
9252: PPUSH
9253: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9254: LD_ADDR_VAR 0 4
9258: PUSH
9259: LD_INT 11
9261: PUSH
9262: LD_INT 12
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9269: LD_ADDR_VAR 0 3
9273: PUSH
9274: LD_INT 11550
9276: PUSH
9277: LD_INT 10150
9279: PUSH
9280: LD_INT 9800
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_OWVAR 67
9292: ARRAY
9293: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9294: LD_ADDR_VAR 0 6
9298: PUSH
9299: LD_INT 70
9301: PUSH
9302: LD_INT 118
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: LD_INT 78
9311: PUSH
9312: LD_INT 31
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: ST_TO_ADDR
// repeat if missionStage = 2 then
9323: LD_EXP 15
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9342
// wait ( 1 1$30 ) else
9333: LD_INT 3150
9335: PPUSH
9336: CALL_OW 67
9340: GO 9351
// wait ( time ) ;
9342: LD_VAR 0 3
9346: PPUSH
9347: CALL_OW 67
// if missionStage = 6 then
9351: LD_EXP 15
9355: PUSH
9356: LD_INT 6
9358: EQUAL
9359: IFFALSE 9387
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9361: LD_INT 51
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: LD_INT 2
9369: PPUSH
9370: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9374: LD_INT 57
9376: PPUSH
9377: LD_INT 6
9379: PPUSH
9380: LD_INT 2
9382: PPUSH
9383: CALL_OW 322
// end ; if missionStage = 8 then
9387: LD_EXP 15
9391: PUSH
9392: LD_INT 8
9394: EQUAL
9395: IFFALSE 9423
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9397: LD_INT 52
9399: PPUSH
9400: LD_INT 6
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9410: LD_INT 58
9412: PPUSH
9413: LD_INT 6
9415: PPUSH
9416: LD_INT 2
9418: PPUSH
9419: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9423: LD_EXP 15
9427: PUSH
9428: LD_INT 10
9430: EQUAL
9431: PUSH
9432: LD_OWVAR 67
9436: PUSH
9437: LD_INT 1
9439: GREATER
9440: AND
9441: IFFALSE 9469
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9443: LD_INT 53
9445: PPUSH
9446: LD_INT 6
9448: PPUSH
9449: LD_INT 2
9451: PPUSH
9452: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9456: LD_INT 59
9458: PPUSH
9459: LD_INT 6
9461: PPUSH
9462: LD_INT 2
9464: PPUSH
9465: CALL_OW 322
// end ; if activeAttacks then
9469: LD_EXP 16
9473: IFFALSE 10076
// begin if missionStage = 2 then
9475: LD_EXP 15
9479: PUSH
9480: LD_INT 2
9482: EQUAL
9483: IFFALSE 9493
// strength := 1 ;
9485: LD_ADDR_VAR 0 5
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// if missionStage > 2 then
9493: LD_EXP 15
9497: PUSH
9498: LD_INT 2
9500: GREATER
9501: IFFALSE 9511
// strength := 2 ;
9503: LD_ADDR_VAR 0 5
9507: PUSH
9508: LD_INT 2
9510: ST_TO_ADDR
// if missionStage > 6 then
9511: LD_EXP 15
9515: PUSH
9516: LD_INT 6
9518: GREATER
9519: IFFALSE 9529
// strength := 3 ;
9521: LD_ADDR_VAR 0 5
9525: PUSH
9526: LD_INT 3
9528: ST_TO_ADDR
// if missionStage > 10 then
9529: LD_EXP 15
9533: PUSH
9534: LD_INT 10
9536: GREATER
9537: IFFALSE 9547
// strength := 4 ;
9539: LD_ADDR_VAR 0 5
9543: PUSH
9544: LD_INT 4
9546: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9547: LD_ADDR_VAR 0 2
9551: PUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: CALL 8102 0 1
9561: ST_TO_ADDR
// for i in tmp do
9562: LD_ADDR_VAR 0 1
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: FOR_IN
9573: IFFALSE 9756
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9575: LD_VAR 0 1
9579: PPUSH
9580: LD_VAR 0 4
9584: PUSH
9585: LD_INT 1
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 12
9595: ARRAY
9596: PPUSH
9597: LD_INT 0
9599: PPUSH
9600: CALL_OW 49
// if i = sewiVeh then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 71
9613: EQUAL
9614: IFFALSE 9651
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9616: LD_ADDR_EXP 70
9620: PUSH
9621: LD_STRING Vsevolod
9623: PPUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_STRING 
9629: PPUSH
9630: CALL 65084 0 3
9634: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9635: LD_EXP 70
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 52
// end else
9649: GO 9732
// if GetControl ( i ) = control_manual then
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 263
9660: PUSH
9661: LD_INT 1
9663: EQUAL
9664: IFFALSE 9732
// begin uc_side := 6 ;
9666: LD_ADDR_OWVAR 20
9670: PUSH
9671: LD_INT 6
9673: ST_TO_ADDR
// uc_nation := 3 ;
9674: LD_ADDR_OWVAR 21
9678: PUSH
9679: LD_INT 3
9681: ST_TO_ADDR
// hc_gallery :=  ;
9682: LD_ADDR_OWVAR 33
9686: PUSH
9687: LD_STRING 
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9698: LD_INT 0
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: LD_INT 10
9706: PPUSH
9707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9711: CALL_OW 44
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9725: LD_INT 10
9727: PPUSH
9728: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: LD_INT 111
9739: PPUSH
9740: LD_INT 197
9742: PPUSH
9743: CALL_OW 111
// wait ( 0 0$2 ) ;
9747: LD_INT 70
9749: PPUSH
9750: CALL_OW 67
// end ;
9754: GO 9572
9756: POP
9757: POP
// repeat wait ( 0 0$1 ) ;
9758: LD_INT 35
9760: PPUSH
9761: CALL_OW 67
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 10057
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9778: LD_INT 81
9780: PUSH
9781: LD_INT 6
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 91
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_INT 12
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9870
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 81
9821: PUSH
9822: LD_INT 6
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 91
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_INT 12
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 74
9863: PPUSH
9864: CALL_OW 115
9868: GO 10055
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9870: LD_INT 9
9872: PPUSH
9873: LD_INT 81
9875: PUSH
9876: LD_INT 6
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PPUSH
9883: CALL_OW 70
9887: IFFALSE 10021
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 6
9898: PUSH
9899: LD_INT 1
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 6
9911: PUSH
9912: LD_INT 1
9914: ARRAY
9915: PUSH
9916: LD_INT 2
9918: ARRAY
9919: PPUSH
9920: CALL_OW 297
9924: PUSH
9925: LD_INT 10
9927: GREATER
9928: PUSH
9929: LD_VAR 0 1
9933: PPUSH
9934: LD_INT 9
9936: PPUSH
9937: CALL_OW 308
9941: NOT
9942: AND
9943: IFFALSE 9982
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_VAR 0 6
9954: PUSH
9955: LD_INT 1
9957: ARRAY
9958: PUSH
9959: LD_INT 1
9961: ARRAY
9962: PPUSH
9963: LD_VAR 0 6
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PUSH
9972: LD_INT 2
9974: ARRAY
9975: PPUSH
9976: CALL_OW 114
9980: GO 10019
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_INT 9
9989: PPUSH
9990: LD_INT 81
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PPUSH
10000: CALL_OW 70
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 74
10014: PPUSH
10015: CALL_OW 115
// end else
10019: GO 10055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 81
10028: PUSH
10029: LD_INT 6
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 69
10040: PPUSH
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 74
10050: PPUSH
10051: CALL_OW 115
// end ;
10055: GO 9775
10057: POP
10058: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10059: LD_INT 22
10061: PUSH
10062: LD_INT 6
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: NOT
10074: IFFALSE 9758
// end ; until russianDestroyed ;
10076: LD_EXP 21
10080: IFFALSE 9323
// end ;
10082: PPOPN 6
10084: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10085: LD_EXP 21
10089: NOT
10090: PUSH
10091: LD_EXP 15
10095: PUSH
10096: LD_INT 6
10098: GREATEREQUAL
10099: AND
10100: PUSH
10101: LD_INT 2
10103: PPUSH
10104: LD_INT 1
10106: PPUSH
10107: CALL 60158 0 2
10111: NOT
10112: AND
10113: IFFALSE 11069
10115: GO 10117
10117: DISABLE
10118: LD_INT 0
10120: PPUSH
10121: PPUSH
10122: PPUSH
10123: PPUSH
// begin enable ;
10124: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10125: LD_INT 22
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 30
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 69
10153: NOT
10154: IFFALSE 10158
// exit ;
10156: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10158: LD_ADDR_VAR 0 4
10162: PUSH
10163: LD_INT 22
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 30
10175: PUSH
10176: LD_INT 34
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PPUSH
10187: CALL_OW 69
10191: ST_TO_ADDR
// if Prob ( 40 ) then
10192: LD_INT 40
10194: PPUSH
10195: CALL_OW 13
10199: IFFALSE 10326
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 49
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 22
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 49
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 22
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 49
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 24
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 24
10278: PUSH
10279: LD_INT 3
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 24
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 46
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL 58740 0 2
// end else
10324: GO 10449
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 24
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 47
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 24
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 47
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 24
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 47
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 24
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 46
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 24
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 46
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 24
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 46
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PPUSH
10445: CALL 58740 0 2
// end ; if Difficulty > 1 then
10449: LD_OWVAR 67
10453: PUSH
10454: LD_INT 1
10456: GREATER
10457: IFFALSE 10487
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 47
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: PPUSH
10483: CALL 58740 0 2
// repeat wait ( 0 0$1 ) ;
10487: LD_INT 35
10489: PPUSH
10490: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10494: LD_INT 2
10496: PPUSH
10497: LD_INT 1
10499: PPUSH
10500: CALL 60158 0 2
10504: PUSH
10505: LD_INT 6
10507: PUSH
10508: LD_INT 7
10510: PUSH
10511: LD_INT 7
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: LD_OWVAR 67
10523: ARRAY
10524: GREATEREQUAL
10525: IFFALSE 10487
// wait ( 0 0$30 ) ;
10527: LD_INT 1050
10529: PPUSH
10530: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10534: LD_ADDR_VAR 0 2
10538: PUSH
10539: LD_INT 2
10541: PPUSH
10542: LD_INT 1
10544: PPUSH
10545: CALL 60158 0 2
10549: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10550: LD_ADDR_EXP 130
10554: PUSH
10555: LD_EXP 130
10559: PPUSH
10560: LD_INT 2
10562: PPUSH
10563: LD_EXP 130
10567: PUSH
10568: LD_INT 2
10570: ARRAY
10571: PUSH
10572: LD_VAR 0 2
10576: DIFF
10577: PPUSH
10578: CALL_OW 1
10582: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10583: LD_ADDR_VAR 0 3
10587: PUSH
10588: LD_INT 0
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 12
10598: ST_TO_ADDR
// if target then
10599: LD_VAR 0 3
10603: IFFALSE 10731
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: LD_INT 24
10617: PUSH
10618: LD_INT 250
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 72
10629: ST_TO_ADDR
// for i in tmp do
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: LD_VAR 0 2
10639: PUSH
10640: FOR_IN
10641: IFFALSE 10681
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 139
10650: PPUSH
10651: LD_INT 89
10653: PPUSH
10654: CALL_OW 297
10658: PUSH
10659: LD_INT 9
10661: GREATER
10662: IFFALSE 10679
// ComMoveXY ( i , 139 , 89 ) ;
10664: LD_VAR 0 1
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: LD_INT 89
10674: PPUSH
10675: CALL_OW 111
10679: GO 10640
10681: POP
10682: POP
// wait ( 0 0$1 ) ;
10683: LD_INT 35
10685: PPUSH
10686: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10690: LD_VAR 0 2
10694: PPUSH
10695: LD_INT 92
10697: PUSH
10698: LD_INT 139
10700: PUSH
10701: LD_INT 89
10703: PUSH
10704: LD_INT 9
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 72
10717: PUSH
10718: LD_VAR 0 2
10722: PUSH
10723: LD_INT 1
10725: MINUS
10726: GREATEREQUAL
10727: IFFALSE 10605
// end else
10729: GO 10873
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10731: LD_VAR 0 2
10735: PPUSH
10736: LD_VAR 0 4
10740: PUSH
10741: LD_INT 1
10743: ARRAY
10744: PPUSH
10745: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 250
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 72
10773: ST_TO_ADDR
// for i in tmp do
10774: LD_ADDR_VAR 0 1
10778: PUSH
10779: LD_VAR 0 2
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10825
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 124
10794: PPUSH
10795: LD_INT 139
10797: PPUSH
10798: CALL_OW 297
10802: PUSH
10803: LD_INT 9
10805: GREATER
10806: IFFALSE 10823
// ComMoveXY ( i , 124 , 139 ) ;
10808: LD_VAR 0 1
10812: PPUSH
10813: LD_INT 124
10815: PPUSH
10816: LD_INT 139
10818: PPUSH
10819: CALL_OW 111
10823: GO 10784
10825: POP
10826: POP
// wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_INT 92
10841: PUSH
10842: LD_INT 124
10844: PUSH
10845: LD_INT 139
10847: PUSH
10848: LD_INT 9
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: PUSH
10862: LD_VAR 0 2
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: GREATEREQUAL
10871: IFFALSE 10749
// end ; repeat wait ( 0 0$1 ) ;
10873: LD_INT 35
10875: PPUSH
10876: CALL_OW 67
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 251
10905: GREATER
10906: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 49
10920: EQUAL
10921: IFFALSE 10977
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 2
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 1
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 8
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 112
10975: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_INT 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 8
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10890
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10873
// end ; end_of_file
11069: PPOPN 4
11071: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11072: LD_INT 0
11074: PPUSH
11075: PPUSH
11076: PPUSH
11077: PPUSH
11078: PPUSH
11079: PPUSH
// side := 7 ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 7
11087: ST_TO_ADDR
// uc_side := side ;
11088: LD_ADDR_OWVAR 20
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
// uc_nation := 1 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_VAR 0 5
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: LD_INT 21
11125: PUSH
11126: LD_INT 3
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PPUSH
11137: CALL_OW 69
11141: PUSH
11142: FOR_IN
11143: IFFALSE 11159
// SetBLevel ( i , 10 ) ;
11145: LD_VAR 0 2
11149: PPUSH
11150: LD_INT 10
11152: PPUSH
11153: CALL_OW 241
11157: GO 11142
11159: POP
11160: POP
// base := GetBase ( al_depot ) ;
11161: LD_ADDR_VAR 0 4
11165: PUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 274
11173: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11174: LD_ADDR_VAR 0 6
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_VAR 0 5
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 34
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: ST_TO_ADDR
// if teleport then
11210: LD_VAR 0 6
11214: IFFALSE 11235
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11216: LD_VAR 0 6
11220: PUSH
11221: LD_INT 1
11223: ARRAY
11224: PPUSH
11225: LD_INT 262
11227: PPUSH
11228: LD_INT 119
11230: PPUSH
11231: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: LD_INT 19500
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 2
11257: PPUSH
11258: LD_INT 200
11260: PPUSH
11261: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 650
11275: PPUSH
11276: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11280: LD_ADDR_EXP 74
11284: PUSH
11285: LD_STRING Roth
11287: PPUSH
11288: CALL_OW 25
11292: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11293: LD_ADDR_EXP 75
11297: PUSH
11298: LD_STRING Simms
11300: PPUSH
11301: LD_EXP 1
11305: NOT
11306: PPUSH
11307: LD_STRING 10c_
11309: PPUSH
11310: CALL 65084 0 3
11314: ST_TO_ADDR
// if not Simms then
11315: LD_EXP 75
11319: NOT
11320: IFFALSE 11350
// begin uc_nation := 1 ;
11322: LD_ADDR_OWVAR 21
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11330: LD_INT 2
11332: PPUSH
11333: LD_INT 10
11335: PPUSH
11336: CALL_OW 384
// Simms := CreateHuman ;
11340: LD_ADDR_EXP 75
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// end ; uc_nation := 3 ;
11350: LD_ADDR_OWVAR 21
11354: PUSH
11355: LD_INT 3
11357: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11358: LD_ADDR_EXP 76
11362: PUSH
11363: LD_STRING Kirilenkova
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11371: LD_ADDR_EXP 90
11375: PUSH
11376: LD_STRING Oblukov
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11384: LD_ADDR_EXP 77
11388: PUSH
11389: LD_STRING Dolgov
11391: PPUSH
11392: CALL_OW 25
11396: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11397: LD_ADDR_EXP 78
11401: PUSH
11402: LD_STRING Petrosyan
11404: PPUSH
11405: CALL_OW 25
11409: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11410: LD_ADDR_EXP 89
11414: PUSH
11415: LD_STRING Scholtze
11417: PPUSH
11418: CALL_OW 25
11422: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11423: LD_ADDR_EXP 88
11427: PUSH
11428: LD_STRING Kapitsova
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11436: LD_ADDR_EXP 79
11440: PUSH
11441: LD_STRING Petrovova
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11449: LD_ADDR_EXP 80
11453: PUSH
11454: LD_STRING Kuzmov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11462: LD_ADDR_EXP 87
11466: PUSH
11467: LD_STRING Karamazov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11475: LD_STRING 13_Lipshchin_1
11477: PPUSH
11478: LD_INT 0
11480: PPUSH
11481: CALL_OW 30
11485: IFFALSE 11500
// Lipshchin := NewCharacter ( Lipshchin ) ;
11487: LD_ADDR_EXP 81
11491: PUSH
11492: LD_STRING Lipshchin
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11500: LD_STRING 13_Titov_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Titov := NewCharacter ( Titov ) ;
11512: LD_ADDR_EXP 83
11516: PUSH
11517: LD_STRING Titov
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11525: LD_STRING 13_Gnyevko_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Gnyevko := NewCharacter ( Gnyevko ) ;
11537: LD_ADDR_EXP 82
11541: PUSH
11542: LD_STRING Gnyevko
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11550: LD_STRING 13_Xavier_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Xavier := NewCharacter ( Xavier2 ) ;
11562: LD_ADDR_EXP 84
11566: PUSH
11567: LD_STRING Xavier2
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11575: LD_STRING 13_Belkov_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Belkov := NewCharacter ( Belkov ) ;
11587: LD_ADDR_EXP 85
11591: PUSH
11592: LD_STRING Belkov
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if not BurlakStatus then
11600: LD_EXP 9
11604: NOT
11605: IFFALSE 11620
// Burlak = NewCharacter ( Burlak ) ;
11607: LD_ADDR_EXP 86
11611: PUSH
11612: LD_STRING Burlak
11614: PPUSH
11615: CALL_OW 25
11619: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11620: LD_ADDR_VAR 0 3
11624: PUSH
11625: LD_EXP 74
11629: PUSH
11630: LD_EXP 76
11634: PUSH
11635: LD_EXP 90
11639: PUSH
11640: LD_EXP 77
11644: PUSH
11645: LD_EXP 78
11649: PUSH
11650: LD_EXP 89
11654: PUSH
11655: LD_EXP 88
11659: PUSH
11660: LD_EXP 79
11664: PUSH
11665: LD_EXP 80
11669: PUSH
11670: LD_EXP 87
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: ST_TO_ADDR
// if Simms then
11687: LD_EXP 75
11691: IFFALSE 11709
// tmp := tmp ^ Simms ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_EXP 75
11707: ADD
11708: ST_TO_ADDR
// if Titov then
11709: LD_EXP 83
11713: IFFALSE 11731
// tmp := tmp ^ Titov ;
11715: LD_ADDR_VAR 0 3
11719: PUSH
11720: LD_VAR 0 3
11724: PUSH
11725: LD_EXP 83
11729: ADD
11730: ST_TO_ADDR
// if Lipshchin then
11731: LD_EXP 81
11735: IFFALSE 11753
// tmp := tmp ^ Lipshchin ;
11737: LD_ADDR_VAR 0 3
11741: PUSH
11742: LD_VAR 0 3
11746: PUSH
11747: LD_EXP 81
11751: ADD
11752: ST_TO_ADDR
// if Gnyevko then
11753: LD_EXP 82
11757: IFFALSE 11775
// tmp := tmp ^ Gnyevko ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_VAR 0 3
11768: PUSH
11769: LD_EXP 82
11773: ADD
11774: ST_TO_ADDR
// if Xavier then
11775: LD_EXP 84
11779: IFFALSE 11797
// tmp := tmp ^ Xavier ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: LD_EXP 84
11795: ADD
11796: ST_TO_ADDR
// if Belkov then
11797: LD_EXP 85
11801: IFFALSE 11819
// tmp := tmp ^ Belkov ;
11803: LD_ADDR_VAR 0 3
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_EXP 85
11817: ADD
11818: ST_TO_ADDR
// if Burlak then
11819: LD_EXP 86
11823: IFFALSE 11841
// tmp := tmp ^ Burlak ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_VAR 0 3
11834: PUSH
11835: LD_EXP 86
11839: ADD
11840: ST_TO_ADDR
// for i = 1 to 11 do
11841: LD_ADDR_VAR 0 2
11845: PUSH
11846: DOUBLE
11847: LD_INT 1
11849: DEC
11850: ST_TO_ADDR
11851: LD_INT 11
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11921
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11857: LD_ADDR_OWVAR 21
11861: PUSH
11862: LD_INT 1
11864: PUSH
11865: LD_INT 3
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 1
11874: PPUSH
11875: LD_INT 2
11877: PPUSH
11878: CALL_OW 12
11882: ARRAY
11883: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11884: LD_INT 0
11886: PPUSH
11887: LD_VAR 0 2
11891: PUSH
11892: LD_INT 2
11894: DIV
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11903: LD_ADDR_VAR 0 3
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: CALL_OW 44
11917: ADD
11918: ST_TO_ADDR
// end ;
11919: GO 11854
11921: POP
11922: POP
// for i in tmp do
11923: LD_ADDR_VAR 0 2
11927: PUSH
11928: LD_VAR 0 3
11932: PUSH
11933: FOR_IN
11934: IFFALSE 11959
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11936: LD_VAR 0 2
11940: PPUSH
11941: LD_INT 260
11943: PPUSH
11944: LD_INT 235
11946: PPUSH
11947: LD_INT 8
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 50
11957: GO 11933
11959: POP
11960: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11961: LD_ADDR_EXP 111
11965: PUSH
11966: LD_EXP 111
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: LD_INT 21
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: PUSH
12012: LD_EXP 74
12016: PUSH
12017: LD_EXP 75
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: DIFF
12026: PPUSH
12027: CALL_OW 1
12031: ST_TO_ADDR
// uc_side := 0 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
// uc_nation := 0 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// for i = 1 to 5 do
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: DOUBLE
12054: LD_INT 1
12056: DEC
12057: ST_TO_ADDR
12058: LD_INT 5
12060: PUSH
12061: FOR_TO
12062: IFFALSE 12099
// begin InitHc ;
12064: CALL_OW 19
// hc_class := class_apeman ;
12068: LD_ADDR_OWVAR 28
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12076: CALL_OW 44
12080: PPUSH
12081: LD_INT 299
12083: PPUSH
12084: LD_INT 229
12086: PPUSH
12087: LD_INT 10
12089: PPUSH
12090: LD_INT 0
12092: PPUSH
12093: CALL_OW 50
// end ;
12097: GO 12061
12099: POP
12100: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 259
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12116: LD_EXP 74
12120: PPUSH
12121: LD_INT 262
12123: PPUSH
12124: LD_INT 235
12126: PPUSH
12127: CALL_OW 178
// if Simms then
12131: LD_EXP 75
12135: IFFALSE 12166
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_INT 262
12144: PPUSH
12145: LD_INT 235
12147: PPUSH
12148: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12152: LD_EXP 75
12156: PPUSH
12157: LD_EXP 74
12161: PPUSH
12162: CALL_OW 179
// end ; end ;
12166: LD_VAR 0 1
12170: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12171: LD_EXP 31
12175: PUSH
12176: LD_EXP 23
12180: NOT
12181: AND
12182: IFFALSE 12358
12184: GO 12186
12186: DISABLE
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// begin enable ;
12192: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 81
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 2
12210: PUSH
12211: LD_INT 32
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 30
12233: PUSH
12234: LD_INT 28
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 34
12243: PUSH
12244: LD_INT 49
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 34
12253: PUSH
12254: LD_INT 10
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: LD_INT 34
12263: PUSH
12264: LD_INT 8
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ST_TO_ADDR
// if not tmp then
12289: LD_VAR 0 2
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12358
// target := tmp [ rand ( 1 , tmp ) ] ;
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_VAR 0 2
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 12
12320: ARRAY
12321: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 255
12331: PUSH
12332: LD_INT 1
12334: EQUAL
12335: IFFALSE 12346
// CenterNowOnUnits ( target ) ;
12337: LD_VAR 0 3
12341: PPUSH
12342: CALL_OW 87
// SetLives ( target , 0 ) ;
12346: LD_VAR 0 3
12350: PPUSH
12351: LD_INT 0
12353: PPUSH
12354: CALL_OW 234
// end ;
12358: PPOPN 3
12360: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12361: LD_EXP 23
12365: NOT
12366: PUSH
12367: LD_EXP 31
12371: AND
12372: IFFALSE 12894
12374: GO 12376
12376: DISABLE
12377: LD_INT 0
12379: PPUSH
12380: PPUSH
12381: PPUSH
// begin uc_side := 7 ;
12382: LD_ADDR_OWVAR 20
12386: PUSH
12387: LD_INT 7
12389: ST_TO_ADDR
// uc_nation := 1 ;
12390: LD_ADDR_OWVAR 21
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 125
12405: PUSH
12406: LD_INT 163
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 185
12415: PUSH
12416: LD_INT 168
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 111
12425: PUSH
12426: LD_INT 97
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: PPUSH
12438: CALL 101046 0 1
12442: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12443: LD_ADDR_EXP 91
12447: PUSH
12448: EMPTY
12449: ST_TO_ADDR
// for i = 1 to Difficulty do
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_OWVAR 67
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12624
// begin InitHc ;
12468: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12472: LD_INT 0
12474: PPUSH
12475: LD_INT 8
12477: PPUSH
12478: CALL_OW 381
// un := CreateHuman ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 258
12499: PPUSH
12500: LD_INT 267
12502: PPUSH
12503: LD_INT 4
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12513: LD_ADDR_EXP 91
12517: PUSH
12518: LD_EXP 91
12522: PUSH
12523: LD_VAR 0 2
12527: UNION
12528: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12529: LD_VAR 0 2
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 1
12547: ARRAY
12548: PPUSH
12549: LD_VAR 0 3
12553: PUSH
12554: LD_VAR 0 1
12558: ARRAY
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 4
12566: PPUSH
12567: LD_INT 1
12569: PPUSH
12570: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 1
12592: ARRAY
12593: PPUSH
12594: LD_VAR 0 3
12598: PUSH
12599: LD_VAR 0 1
12603: ARRAY
12604: PUSH
12605: LD_INT 2
12607: ARRAY
12608: PPUSH
12609: CALL_OW 171
// AddComInvisible ( un ) ;
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL_OW 212
// end ;
12622: GO 12465
12624: POP
12625: POP
// repeat wait ( 0 0$20 ) ;
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 67
// for i in allianceSpecialForce do
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_EXP 91
12642: PUSH
12643: FOR_IN
12644: IFFALSE 12879
// begin if IsInvisible ( i ) then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 571
12655: IFFALSE 12848
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12657: LD_ADDR_VAR 0 3
12661: PUSH
12662: LD_INT 22
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 50
12674: PUSH
12675: EMPTY
12676: LIST
12677: PUSH
12678: LD_INT 56
12680: PUSH
12681: EMPTY
12682: LIST
12683: PUSH
12684: LD_INT 91
12686: PUSH
12687: LD_VAR 0 1
12691: PUSH
12692: LD_INT 25
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 35
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 2
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 25
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 25
12742: PUSH
12743: LD_INT 3
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 25
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 25
12762: PUSH
12763: LD_INT 5
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 25
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 3
12805: NOT
12806: IFFALSE 12810
// continue ;
12808: GO 12643
// if Prob ( 30 * Difficulty ) then
12810: LD_INT 30
12812: PUSH
12813: LD_OWVAR 67
12817: MUL
12818: PPUSH
12819: CALL_OW 13
12823: IFFALSE 12848
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_VAR 0 3
12837: PPUSH
12838: CALL_OW 12
12842: ARRAY
12843: PPUSH
12844: CALL 31141 0 1
// end ; if IsDead ( i ) then
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 301
12857: IFFALSE 12877
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12859: LD_ADDR_EXP 91
12863: PUSH
12864: LD_EXP 91
12868: PUSH
12869: LD_VAR 0 1
12873: DIFF
12874: ST_TO_ADDR
// continue ;
12875: GO 12643
// end ; end ;
12877: GO 12643
12879: POP
12880: POP
// until allianceDestroyed or not allianceSpecialForce ;
12881: LD_EXP 23
12885: PUSH
12886: LD_EXP 91
12890: NOT
12891: OR
12892: IFFALSE 12626
// end ;
12894: PPOPN 3
12896: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12897: LD_EXP 23
12901: NOT
12902: PUSH
12903: LD_EXP 31
12907: AND
12908: IFFALSE 13875
12910: GO 12912
12912: DISABLE
12913: LD_INT 0
12915: PPUSH
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12920: LD_INT 22
12922: PUSH
12923: LD_INT 7
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 30
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PPUSH
12944: CALL_OW 69
12948: NOT
12949: IFFALSE 12953
// exit ;
12951: GO 13875
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12953: LD_ADDR_VAR 0 4
12957: PUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 7
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: ST_TO_ADDR
// if Prob ( 40 ) then
12987: LD_INT 40
12989: PPUSH
12990: CALL_OW 13
12994: IFFALSE 13121
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 5
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 6
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 6
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 24
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 45
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 47
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58740 0 2
// end else
13119: GO 13244
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 24
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 47
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 24
13144: PUSH
13145: LD_INT 3
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 47
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 5
13162: PUSH
13163: LD_INT 3
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 5
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: LD_INT 2
13186: PUSH
13187: LD_INT 9
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 24
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: LD_INT 3
13204: PUSH
13205: LD_INT 45
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 45
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: PPUSH
13240: CALL 58740 0 2
// end ; if Difficulty > 1 then
13244: LD_OWVAR 67
13248: PUSH
13249: LD_INT 1
13251: GREATER
13252: IFFALSE 13282
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13254: LD_INT 1
13256: PPUSH
13257: LD_INT 24
13259: PUSH
13260: LD_INT 3
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 47
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: PPUSH
13278: CALL 58740 0 2
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13289: LD_INT 1
13291: PPUSH
13292: LD_INT 1
13294: PPUSH
13295: CALL 60158 0 2
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: PUSH
13314: LD_OWVAR 67
13318: ARRAY
13319: GREATEREQUAL
13320: IFFALSE 13282
// wait ( 0 0$40 ) ;
13322: LD_INT 1400
13324: PPUSH
13325: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13329: LD_ADDR_VAR 0 2
13333: PUSH
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 1
13339: PPUSH
13340: CALL 60158 0 2
13344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13345: LD_ADDR_EXP 130
13349: PUSH
13350: LD_EXP 130
13354: PPUSH
13355: LD_INT 1
13357: PPUSH
13358: LD_EXP 130
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PUSH
13367: LD_VAR 0 2
13371: DIFF
13372: PPUSH
13373: CALL_OW 1
13377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13378: LD_ADDR_VAR 0 3
13382: PUSH
13383: LD_INT 0
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 12
13393: ST_TO_ADDR
// if target then
13394: LD_VAR 0 3
13398: IFFALSE 13564
// begin for i in tmp do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13436
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: LD_INT 179
13420: PPUSH
13421: LD_INT 209
13423: PPUSH
13424: LD_INT 8
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 483
13434: GO 13410
13436: POP
13437: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 250
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PPUSH
13458: CALL_OW 72
13462: ST_TO_ADDR
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13514
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 179
13483: PPUSH
13484: LD_INT 209
13486: PPUSH
13487: CALL_OW 297
13491: PUSH
13492: LD_INT 9
13494: GREATER
13495: IFFALSE 13512
// ComMoveXY ( i , 179 , 209 ) ;
13497: LD_VAR 0 1
13501: PPUSH
13502: LD_INT 179
13504: PPUSH
13505: LD_INT 209
13507: PPUSH
13508: CALL_OW 111
13512: GO 13473
13514: POP
13515: POP
// wait ( 0 0$1 ) ;
13516: LD_INT 35
13518: PPUSH
13519: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: LD_INT 92
13530: PUSH
13531: LD_INT 179
13533: PUSH
13534: LD_INT 209
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: PPUSH
13546: CALL_OW 72
13550: PUSH
13551: LD_VAR 0 2
13555: PUSH
13556: LD_INT 1
13558: MINUS
13559: GREATEREQUAL
13560: IFFALSE 13438
// end else
13562: GO 13726
// begin for i in tmp do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: FOR_IN
13575: IFFALSE 13600
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 285
13584: PPUSH
13585: LD_INT 163
13587: PPUSH
13588: LD_INT 8
13590: PPUSH
13591: LD_INT 1
13593: PPUSH
13594: CALL_OW 483
13598: GO 13574
13600: POP
13601: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13602: LD_ADDR_VAR 0 2
13606: PUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: LD_INT 24
13614: PUSH
13615: LD_INT 250
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13678
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13640: LD_VAR 0 1
13644: PPUSH
13645: LD_INT 285
13647: PPUSH
13648: LD_INT 163
13650: PPUSH
13651: CALL_OW 297
13655: PUSH
13656: LD_INT 9
13658: GREATER
13659: IFFALSE 13676
// ComMoveXY ( i , 285 , 163 ) ;
13661: LD_VAR 0 1
13665: PPUSH
13666: LD_INT 285
13668: PPUSH
13669: LD_INT 163
13671: PPUSH
13672: CALL_OW 111
13676: GO 13637
13678: POP
13679: POP
// wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 92
13694: PUSH
13695: LD_INT 285
13697: PUSH
13698: LD_INT 163
13700: PUSH
13701: LD_INT 9
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 72
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: MINUS
13723: GREATEREQUAL
13724: IFFALSE 13602
// end ; repeat wait ( 0 0$1 ) ;
13726: LD_INT 35
13728: PPUSH
13729: CALL_OW 67
// for i in tmp do
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_VAR 0 2
13742: PUSH
13743: FOR_IN
13744: IFFALSE 13866
// if GetLives ( i ) > 251 then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 256
13755: PUSH
13756: LD_INT 251
13758: GREATER
13759: IFFALSE 13848
// begin if GetWeapon ( i ) = ru_time_lapser then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 264
13770: PUSH
13771: LD_INT 49
13773: EQUAL
13774: IFFALSE 13812
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13776: LD_VAR 0 1
13780: PPUSH
13781: LD_INT 81
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: PPUSH
13796: LD_VAR 0 1
13800: PPUSH
13801: CALL_OW 74
13805: PPUSH
13806: CALL_OW 112
13810: GO 13846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_INT 81
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PPUSH
13827: CALL_OW 69
13831: PPUSH
13832: LD_VAR 0 1
13836: PPUSH
13837: CALL_OW 74
13841: PPUSH
13842: CALL_OW 115
// end else
13846: GO 13864
// tmp := tmp diff i ;
13848: LD_ADDR_VAR 0 2
13852: PUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 1
13862: DIFF
13863: ST_TO_ADDR
13864: GO 13743
13866: POP
13867: POP
// until not tmp ;
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13726
// end ; end_of_file
13875: PPOPN 4
13877: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
13882: PPUSH
13883: PPUSH
// missionStage := 13 ;
13884: LD_ADDR_EXP 15
13888: PUSH
13889: LD_INT 13
13891: ST_TO_ADDR
// uc_side := 2 ;
13892: LD_ADDR_OWVAR 20
13896: PUSH
13897: LD_INT 2
13899: ST_TO_ADDR
// uc_nation := 2 ;
13900: LD_ADDR_OWVAR 21
13904: PUSH
13905: LD_INT 2
13907: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13908: LD_ADDR_EXP 92
13912: PUSH
13913: LD_STRING Omar
13915: PPUSH
13916: CALL_OW 25
13920: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13921: LD_EXP 92
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13933: LD_EXP 92
13937: PPUSH
13938: LD_INT 242
13940: PPUSH
13941: LD_INT 75
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13951: LD_ADDR_EXP 93
13955: PUSH
13956: LD_STRING Heike
13958: PPUSH
13959: CALL_OW 25
13963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13964: LD_INT 14
13966: PPUSH
13967: LD_INT 3
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: LD_INT 27
13975: PPUSH
13976: LD_INT 100
13978: PPUSH
13979: CALL 69908 0 5
// veh := CreateVehicle ;
13983: LD_ADDR_VAR 0 3
13987: PUSH
13988: CALL_OW 45
13992: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13993: LD_VAR 0 3
13997: PPUSH
13998: LD_INT 1
14000: PPUSH
14001: CALL_OW 242
// SetDir ( veh , 4 ) ;
14005: LD_VAR 0 3
14009: PPUSH
14010: LD_INT 4
14012: PPUSH
14013: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 241
14024: PPUSH
14025: LD_INT 72
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14035: LD_EXP 93
14039: PPUSH
14040: LD_VAR 0 3
14044: PPUSH
14045: CALL_OW 52
// if KhatamStatus then
14049: LD_EXP 8
14053: IFFALSE 14104
// begin Khatam := NewCharacter ( Khatam ) ;
14055: LD_ADDR_EXP 94
14059: PUSH
14060: LD_STRING Khatam
14062: PPUSH
14063: CALL_OW 25
14067: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14068: LD_EXP 94
14072: PPUSH
14073: LD_INT 245
14075: PPUSH
14076: LD_INT 78
14078: PPUSH
14079: LD_INT 3
14081: PPUSH
14082: LD_INT 0
14084: PPUSH
14085: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14089: LD_EXP 94
14093: PPUSH
14094: LD_INT 4
14096: PPUSH
14097: LD_INT 10
14099: PPUSH
14100: CALL_OW 237
// end ; for i = 1 to Difficulty do
14104: LD_ADDR_VAR 0 2
14108: PUSH
14109: DOUBLE
14110: LD_INT 1
14112: DEC
14113: ST_TO_ADDR
14114: LD_OWVAR 67
14118: PUSH
14119: FOR_TO
14120: IFFALSE 14186
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 7
14127: PUSH
14128: LD_OWVAR 67
14132: PLUS
14133: PPUSH
14134: CALL_OW 384
// un := CreateHuman ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: CALL_OW 44
14147: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14148: LD_VAR 0 4
14152: PPUSH
14153: LD_INT 28
14155: PUSH
14156: LD_INT 29
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 2
14170: MOD
14171: PUSH
14172: LD_INT 1
14174: PLUS
14175: ARRAY
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14119
14186: POP
14187: POP
// for i = 1 to 6 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 6
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14247
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 7
14209: PUSH
14210: LD_OWVAR 67
14214: PLUS
14215: PPUSH
14216: CALL_OW 381
// un := CreateHuman ;
14220: LD_ADDR_VAR 0 4
14224: PUSH
14225: CALL_OW 44
14229: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_INT 28
14237: PPUSH
14238: LD_INT 0
14240: PPUSH
14241: CALL_OW 49
// end ;
14245: GO 14201
14247: POP
14248: POP
// for i = 1 to 3 do
14249: LD_ADDR_VAR 0 2
14253: PUSH
14254: DOUBLE
14255: LD_INT 1
14257: DEC
14258: ST_TO_ADDR
14259: LD_INT 3
14261: PUSH
14262: FOR_TO
14263: IFFALSE 14311
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14265: LD_INT 0
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 7
14273: PUSH
14274: LD_OWVAR 67
14278: PLUS
14279: PPUSH
14280: CALL_OW 380
// un := CreateHuman ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: CALL_OW 44
14293: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14294: LD_VAR 0 4
14298: PPUSH
14299: LD_INT 28
14301: PPUSH
14302: LD_INT 0
14304: PPUSH
14305: CALL_OW 49
// end ;
14309: GO 14262
14311: POP
14312: POP
// for i = 1 to 3 do
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: DOUBLE
14319: LD_INT 1
14321: DEC
14322: ST_TO_ADDR
14323: LD_INT 3
14325: PUSH
14326: FOR_TO
14327: IFFALSE 14417
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14329: LD_INT 14
14331: PPUSH
14332: LD_INT 2
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_INT 28
14340: PPUSH
14341: LD_INT 80
14343: PPUSH
14344: CALL 69908 0 5
// veh := CreateVehicle ;
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: CALL_OW 45
14357: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 3
14365: PPUSH
14366: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 29
14377: PPUSH
14378: LD_INT 0
14380: PPUSH
14381: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14385: LD_INT 0
14387: PPUSH
14388: LD_INT 7
14390: PUSH
14391: LD_OWVAR 67
14395: PLUS
14396: PPUSH
14397: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14401: CALL_OW 44
14405: PPUSH
14406: LD_VAR 0 3
14410: PPUSH
14411: CALL_OW 52
// end ;
14415: GO 14326
14417: POP
14418: POP
// for i = 1 to 5 + Difficulty do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_INT 5
14431: PUSH
14432: LD_OWVAR 67
14436: PLUS
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14566
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: LD_INT 3
14449: PPUSH
14450: CALL_OW 12
14454: PPUSH
14455: LD_INT 1
14457: PPUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 26
14463: PUSH
14464: LD_INT 27
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: LD_INT 4
14483: MOD
14484: PUSH
14485: LD_INT 1
14487: PLUS
14488: ARRAY
14489: PPUSH
14490: LD_INT 80
14492: PPUSH
14493: CALL 69908 0 5
// veh := CreateVehicle ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: CALL_OW 45
14506: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14507: LD_VAR 0 3
14511: PPUSH
14512: LD_INT 4
14514: PPUSH
14515: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 28
14526: PPUSH
14527: LD_INT 0
14529: PPUSH
14530: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14534: LD_INT 0
14536: PPUSH
14537: LD_INT 7
14539: PUSH
14540: LD_OWVAR 67
14544: PLUS
14545: PPUSH
14546: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14550: CALL_OW 44
14554: PPUSH
14555: LD_VAR 0 3
14559: PPUSH
14560: CALL_OW 52
// end ;
14564: GO 14438
14566: POP
14567: POP
// for i = 1 to 3 do
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: DOUBLE
14574: LD_INT 1
14576: DEC
14577: ST_TO_ADDR
14578: LD_INT 3
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14642
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14584: LD_INT 14
14586: PPUSH
14587: LD_INT 3
14589: PPUSH
14590: LD_INT 5
14592: PPUSH
14593: LD_INT 29
14595: PPUSH
14596: LD_INT 80
14598: PPUSH
14599: CALL 69908 0 5
// veh := CreateVehicle ;
14603: LD_ADDR_VAR 0 3
14607: PUSH
14608: CALL_OW 45
14612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 4
14620: PPUSH
14621: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 28
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// end ;
14640: GO 14581
14642: POP
14643: POP
// end ;
14644: LD_VAR 0 1
14648: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14649: LD_INT 22
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: IFFALSE 14963
14665: GO 14667
14667: DISABLE
14668: LD_INT 0
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 22
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PUSH
14688: LD_INT 25
14690: PUSH
14691: LD_INT 4
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PPUSH
14702: CALL_OW 69
14706: PUSH
14707: LD_EXP 94
14711: DIFF
14712: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14713: LD_ADDR_VAR 0 2
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 94
14737: PUSH
14738: LD_VAR 0 3
14742: UNION
14743: DIFF
14744: ST_TO_ADDR
// if Khatam then
14745: LD_EXP 94
14749: IFFALSE 14766
// ComMoveXY ( Khatam , 211 , 92 ) ;
14751: LD_EXP 94
14755: PPUSH
14756: LD_INT 211
14758: PPUSH
14759: LD_INT 92
14761: PPUSH
14762: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14766: LD_INT 197
14768: PPUSH
14769: LD_INT 80
14771: PPUSH
14772: LD_INT 2
14774: PPUSH
14775: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14779: LD_INT 213
14781: PPUSH
14782: LD_INT 90
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14792: LD_INT 215
14794: PPUSH
14795: LD_INT 129
14797: PPUSH
14798: LD_INT 2
14800: PPUSH
14801: CALL_OW 441
// if sci then
14805: LD_VAR 0 3
14809: IFFALSE 14830
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14811: LD_VAR 0 3
14815: PUSH
14816: LD_INT 1
14818: ARRAY
14819: PPUSH
14820: LD_INT 197
14822: PPUSH
14823: LD_INT 80
14825: PPUSH
14826: CALL_OW 158
// if sci > 1 then
14830: LD_VAR 0 3
14834: PUSH
14835: LD_INT 1
14837: GREATER
14838: IFFALSE 14859
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 2
14847: ARRAY
14848: PPUSH
14849: LD_INT 213
14851: PPUSH
14852: LD_INT 90
14854: PPUSH
14855: CALL_OW 158
// if sci > 2 then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_INT 2
14866: GREATER
14867: IFFALSE 14888
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 3
14876: ARRAY
14877: PPUSH
14878: LD_INT 215
14880: PPUSH
14881: LD_INT 129
14883: PPUSH
14884: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14888: LD_INT 35
14890: PPUSH
14891: CALL_OW 67
// for i in tmp do
14895: LD_ADDR_VAR 0 1
14899: PUSH
14900: LD_VAR 0 2
14904: PUSH
14905: FOR_IN
14906: IFFALSE 14944
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14908: LD_VAR 0 1
14912: PPUSH
14913: LD_INT 81
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: PPUSH
14923: CALL_OW 69
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 74
14937: PPUSH
14938: CALL_OW 115
14942: GO 14905
14944: POP
14945: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14946: LD_INT 22
14948: PUSH
14949: LD_INT 2
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: CALL_OW 69
14960: NOT
14961: IFFALSE 14888
// end ; end_of_file
14963: PPOPN 3
14965: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
// Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 100926 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 7
14991: PPUSH
14992: LD_INT 0
14994: PPUSH
14995: CALL_OW 517
14999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15000: LD_ADDR_VAR 0 2
15004: PUSH
15005: DOUBLE
15006: LD_INT 1
15008: DEC
15009: ST_TO_ADDR
15010: LD_VAR 0 5
15014: PUSH
15015: LD_INT 1
15017: ARRAY
15018: PUSH
15019: FOR_TO
15020: IFFALSE 15065
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 2
15044: ARRAY
15045: PUSH
15046: LD_VAR 0 2
15050: ARRAY
15051: PPUSH
15052: LD_INT 1
15054: PPUSH
15055: LD_INT 15
15057: NEG
15058: PPUSH
15059: CALL 100840 0 4
15063: GO 15019
15065: POP
15066: POP
// CenterNowOnUnits ( Powell ) ;
15067: LD_EXP 58
15071: PPUSH
15072: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: LD_EXP 56
15085: PUSH
15086: EMPTY
15087: LIST
15088: ST_TO_ADDR
// if GirlNewVeh then
15089: LD_EXP 57
15093: IFFALSE 15111
// tmp := tmp ^ GirlNewVeh ;
15095: LD_ADDR_VAR 0 5
15099: PUSH
15100: LD_VAR 0 5
15104: PUSH
15105: LD_EXP 57
15109: ADD
15110: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15111: LD_VAR 0 5
15115: PPUSH
15116: LD_INT 60
15118: PPUSH
15119: LD_INT 109
15121: PPUSH
15122: CALL_OW 111
// if KappaStatus then
15126: LD_EXP 2
15130: IFFALSE 15182
// begin Say ( JMM , D1nT-JMM-1 ) ;
15132: LD_EXP 39
15136: PPUSH
15137: LD_STRING D1nT-JMM-1
15139: PPUSH
15140: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15144: LD_EXP 58
15148: PPUSH
15149: LD_STRING D1T-Pow-1
15151: PPUSH
15152: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15156: LD_EXP 39
15160: PPUSH
15161: LD_STRING D1T-JMM-2
15163: PPUSH
15164: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15168: LD_EXP 58
15172: PPUSH
15173: LD_STRING D1T-Pow-2
15175: PPUSH
15176: CALL_OW 88
// end else
15180: GO 15388
// if JMMGirlStatus then
15182: LD_EXP 6
15186: IFFALSE 15331
// begin Say ( JMM , D1T-JMM-1 ) ;
15188: LD_EXP 39
15192: PPUSH
15193: LD_STRING D1T-JMM-1
15195: PPUSH
15196: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15200: LD_EXP 58
15204: PPUSH
15205: LD_STRING D1T-Pow-1
15207: PPUSH
15208: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-3
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-3
15231: PPUSH
15232: CALL_OW 88
// if JMMGirl then
15236: LD_EXP 7
15240: IFFALSE 15329
// begin case JMMGirl of 1 :
15242: LD_EXP 7
15246: PUSH
15247: LD_INT 1
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15270
15255: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15256: LD_EXP 40
15260: PPUSH
15261: LD_STRING D1T-Joan-3
15263: PPUSH
15264: CALL_OW 88
15268: GO 15317
15270: LD_INT 2
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15293
15278: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15279: LD_EXP 42
15283: PPUSH
15284: LD_STRING D1T-Lisa-3
15286: PPUSH
15287: CALL_OW 88
15291: GO 15317
15293: LD_INT 3
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15316
15301: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15302: LD_EXP 54
15306: PPUSH
15307: LD_STRING D1T-Con-3
15309: PPUSH
15310: CALL_OW 88
15314: GO 15317
15316: POP
// Say ( Powell , D1T-Pow-4 ) ;
15317: LD_EXP 58
15321: PPUSH
15322: LD_STRING D1T-Pow-4
15324: PPUSH
15325: CALL_OW 88
// end ; end else
15329: GO 15388
// if not FastEnd then
15331: LD_EXP 11
15335: NOT
15336: IFFALSE 15364
// begin Say ( JMM , D1T-JMM-4 ) ;
15338: LD_EXP 39
15342: PPUSH
15343: LD_STRING D1T-JMM-4
15345: PPUSH
15346: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15350: LD_EXP 58
15354: PPUSH
15355: LD_STRING D1T-Pow-5
15357: PPUSH
15358: CALL_OW 88
// end else
15362: GO 15388
// begin Say ( JMM , D1nT-JMM-1 ) ;
15364: LD_EXP 39
15368: PPUSH
15369: LD_STRING D1nT-JMM-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15376: LD_EXP 58
15380: PPUSH
15381: LD_STRING D1nT-Pow-1
15383: PPUSH
15384: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15388: LD_INT 35
15390: PPUSH
15391: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15395: LD_EXP 56
15399: PPUSH
15400: CALL_OW 314
15404: NOT
15405: IFFALSE 15388
// ComExitVehicle ( JMM ) ;
15407: LD_EXP 39
15411: PPUSH
15412: CALL_OW 121
// wait ( 3 ) ;
15416: LD_INT 3
15418: PPUSH
15419: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_INT 60
15430: PPUSH
15431: LD_INT 94
15433: PPUSH
15434: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15438: LD_EXP 39
15442: PPUSH
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 179
// if Joan then
15452: LD_EXP 40
15456: IFFALSE 15510
// begin ComExitVehicle ( Joan ) ;
15458: LD_EXP 40
15462: PPUSH
15463: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15467: LD_EXP 40
15471: PPUSH
15472: LD_INT 35
15474: PPUSH
15475: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_INT 65
15486: PPUSH
15487: LD_INT 104
15489: PPUSH
15490: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15494: LD_EXP 40
15498: PPUSH
15499: LD_EXP 39
15503: PPUSH
15504: CALL_OW 179
// end else
15508: GO 15644
// if Lisa and JMMGirl = 2 then
15510: LD_EXP 42
15514: PUSH
15515: LD_EXP 7
15519: PUSH
15520: LD_INT 2
15522: EQUAL
15523: AND
15524: IFFALSE 15578
// begin ComExitVehicle ( Lisa ) ;
15526: LD_EXP 42
15530: PPUSH
15531: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15535: LD_EXP 42
15539: PPUSH
15540: LD_INT 35
15542: PPUSH
15543: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_INT 65
15554: PPUSH
15555: LD_INT 104
15557: PPUSH
15558: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15562: LD_EXP 42
15566: PPUSH
15567: LD_EXP 39
15571: PPUSH
15572: CALL_OW 179
// end else
15576: GO 15644
// if Connie and JMMGirl = 3 then
15578: LD_EXP 54
15582: PUSH
15583: LD_EXP 7
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15644
// begin ComExitVehicle ( Connie ) ;
15594: LD_EXP 54
15598: PPUSH
15599: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15603: LD_EXP 54
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_INT 65
15622: PPUSH
15623: LD_INT 104
15625: PPUSH
15626: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15630: LD_EXP 54
15634: PPUSH
15635: LD_EXP 39
15639: PPUSH
15640: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15644: LD_INT 35
15646: PPUSH
15647: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15651: LD_EXP 39
15655: PPUSH
15656: LD_EXP 58
15660: PPUSH
15661: CALL_OW 296
15665: PUSH
15666: LD_INT 6
15668: LESS
15669: IFFALSE 15644
// wait ( 0 0$0.5 ) ;
15671: LD_INT 18
15673: PPUSH
15674: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15678: LD_EXP 39
15682: PPUSH
15683: LD_STRING D1-JMM-1
15685: PPUSH
15686: CALL_OW 88
// async ;
15690: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15691: LD_EXP 58
15695: PPUSH
15696: LD_STRING D1-Pow-1
15698: PPUSH
15699: CALL_OW 88
// if not dialogue_skipped then
15703: LD_OWVAR 59
15707: NOT
15708: IFFALSE 15717
// wait ( 0 0$2 ) ;
15710: LD_INT 70
15712: PPUSH
15713: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15717: LD_INT 170
15719: PPUSH
15720: LD_INT 99
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: LD_INT 6
15728: NEG
15729: PPUSH
15730: CALL 100840 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15734: LD_INT 174
15736: PPUSH
15737: LD_INT 115
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 6
15745: NEG
15746: PPUSH
15747: CALL 100840 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15751: LD_INT 169
15753: PPUSH
15754: LD_INT 71
15756: PPUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 6
15762: NEG
15763: PPUSH
15764: CALL 100840 0 4
// if not dialogue_skipped then
15768: LD_OWVAR 59
15772: NOT
15773: IFFALSE 15792
// begin CenterOnXY ( 170 , 99 ) ;
15775: LD_INT 170
15777: PPUSH
15778: LD_INT 99
15780: PPUSH
15781: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15785: LD_INT 80
15787: PPUSH
15788: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15792: LD_INT 75
15794: PPUSH
15795: LD_INT 53
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: LD_INT 9
15803: NEG
15804: PPUSH
15805: CALL 100840 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15809: LD_INT 54
15811: PPUSH
15812: LD_INT 42
15814: PPUSH
15815: LD_INT 1
15817: PPUSH
15818: LD_INT 9
15820: NEG
15821: PPUSH
15822: CALL 100840 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15826: LD_INT 62
15828: PPUSH
15829: LD_INT 51
15831: PPUSH
15832: LD_INT 1
15834: PPUSH
15835: LD_INT 9
15837: NEG
15838: PPUSH
15839: CALL 100840 0 4
// if not dialogue_skipped then
15843: LD_OWVAR 59
15847: NOT
15848: IFFALSE 15867
// begin CenterOnXY ( 75 , 53 ) ;
15850: LD_INT 75
15852: PPUSH
15853: LD_INT 53
15855: PPUSH
15856: CALL_OW 84
// wait ( 0 0$4 ) ;
15860: LD_INT 140
15862: PPUSH
15863: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15867: LD_EXP 58
15871: PPUSH
15872: CALL_OW 87
// if not dialogue_skipped then
15876: LD_OWVAR 59
15880: NOT
15881: IFFALSE 15890
// wait ( 0 0$2 ) ;
15883: LD_INT 70
15885: PPUSH
15886: CALL_OW 67
// sync ;
15890: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15891: LD_EXP 39
15895: PPUSH
15896: LD_STRING D1-JMM-2
15898: PPUSH
15899: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15903: LD_EXP 58
15907: PPUSH
15908: LD_STRING D1-Pow-2
15910: PPUSH
15911: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15915: LD_EXP 39
15919: PPUSH
15920: LD_STRING D1-JMM-3
15922: PPUSH
15923: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15927: LD_EXP 58
15931: PPUSH
15932: LD_STRING D1-Pow-3
15934: PPUSH
15935: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15939: LD_EXP 39
15943: PPUSH
15944: LD_STRING D1-JMM-4
15946: PPUSH
15947: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15951: LD_EXP 58
15955: PPUSH
15956: LD_STRING D1-Pow-4
15958: PPUSH
15959: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15963: LD_EXP 39
15967: PPUSH
15968: LD_STRING D1-JMM-5
15970: PPUSH
15971: CALL_OW 88
// async ;
15975: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-5
15983: PPUSH
15984: CALL_OW 88
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$3.6 ) ;
15995: LD_INT 126
15997: PPUSH
15998: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16002: LD_INT 134
16004: PPUSH
16005: LD_INT 210
16007: PPUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_INT 11
16013: NEG
16014: PPUSH
16015: CALL 100840 0 4
// if not dialogue_skipped then
16019: LD_OWVAR 59
16023: NOT
16024: IFFALSE 16043
// begin CenterOnXY ( 134 , 210 ) ;
16026: LD_INT 134
16028: PPUSH
16029: LD_INT 210
16031: PPUSH
16032: CALL_OW 84
// wait ( 0 0$2 ) ;
16036: LD_INT 70
16038: PPUSH
16039: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16043: LD_INT 101
16045: PPUSH
16046: LD_INT 159
16048: PPUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_INT 10
16054: NEG
16055: PPUSH
16056: CALL 100840 0 4
// if not dialogue_skipped then
16060: LD_OWVAR 59
16064: NOT
16065: IFFALSE 16084
// begin CenterOnXY ( 101 , 159 ) ;
16067: LD_INT 101
16069: PPUSH
16070: LD_INT 159
16072: PPUSH
16073: CALL_OW 84
// wait ( 0 0$2 ) ;
16077: LD_INT 70
16079: PPUSH
16080: CALL_OW 67
// end ; sync ;
16084: SYNC
// CenterNowOnUnits ( Powell ) ;
16085: LD_EXP 58
16089: PPUSH
16090: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 5
16113: PUSH
16114: LD_INT 6
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: ST_TO_ADDR
// if not dialogue_skipped then
16125: LD_OWVAR 59
16129: NOT
16130: IFFALSE 16299
// begin game_speed := 4 ;
16132: LD_ADDR_OWVAR 65
16136: PUSH
16137: LD_INT 4
16139: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16140: LD_INT 210
16142: PPUSH
16143: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16147: LD_ADDR_VAR 0 7
16151: PUSH
16152: LD_STRING Q1
16154: PPUSH
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 98
16164: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_STRING Q1
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 98
16182: ST_TO_ADDR
// options = options diff dec ;
16183: LD_ADDR_VAR 0 6
16187: PUSH
16188: LD_VAR 0 6
16192: PUSH
16193: LD_VAR 0 7
16197: DIFF
16198: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16199: LD_VAR 0 7
16203: PPUSH
16204: LD_VAR 0 6
16208: PPUSH
16209: CALL 17771 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16213: LD_VAR 0 7
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 6
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: IN
16228: PUSH
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 2
16236: EQUAL
16237: OR
16238: IFFALSE 16165
// if not ( dec in [ 5 , 6 ] ) then
16240: LD_VAR 0 7
16244: PUSH
16245: LD_INT 5
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: IN
16255: NOT
16256: IFFALSE 16299
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16258: LD_ADDR_VAR 0 7
16262: PUSH
16263: LD_STRING Q1a
16265: PPUSH
16266: LD_INT 1
16268: PUSH
16269: LD_INT 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 98
16280: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16281: LD_VAR 0 7
16285: PUSH
16286: LD_INT 4
16288: PLUS
16289: PPUSH
16290: LD_VAR 0 6
16294: PPUSH
16295: CALL 17771 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16299: LD_INT 81
16301: PPUSH
16302: LD_INT 127
16304: PPUSH
16305: CALL_OW 84
// amount := 5 ;
16309: LD_ADDR_VAR 0 8
16313: PUSH
16314: LD_INT 5
16316: ST_TO_ADDR
// macmilan_squad := [ ] ;
16317: LD_ADDR_VAR 0 9
16321: PUSH
16322: EMPTY
16323: ST_TO_ADDR
// if vip < amount then
16324: LD_EXP 59
16328: PUSH
16329: LD_VAR 0 8
16333: LESS
16334: IFFALSE 16378
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16336: LD_ADDR_VAR 0 5
16340: PUSH
16341: LD_EXP 59
16345: PUSH
16346: LD_INT 22
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: UNION
16375: ST_TO_ADDR
16376: GO 16388
// tmp := vip ;
16378: LD_ADDR_VAR 0 5
16382: PUSH
16383: LD_EXP 59
16387: ST_TO_ADDR
// tmp := tmp diff Powell ;
16388: LD_ADDR_VAR 0 5
16392: PUSH
16393: LD_VAR 0 5
16397: PUSH
16398: LD_EXP 58
16402: DIFF
16403: ST_TO_ADDR
// if tmp < amount then
16404: LD_VAR 0 5
16408: PUSH
16409: LD_VAR 0 8
16413: LESS
16414: IFFALSE 16426
// amount := tmp ;
16416: LD_ADDR_VAR 0 8
16420: PUSH
16421: LD_VAR 0 5
16425: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16426: LD_VAR 0 5
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 257
16439: PUSH
16440: LD_INT 2
16442: NONEQUAL
16443: IFFALSE 16505
// begin if IsInUnit ( tmp [ 1 ] ) then
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 310
16458: IFFALSE 16473
// ComExitBuilding ( tmp [ 1 ] ) ;
16460: LD_VAR 0 5
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16473: LD_VAR 0 5
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: PPUSH
16482: LD_INT 387
16484: PPUSH
16485: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16489: LD_VAR 0 5
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PPUSH
16498: LD_INT 2
16500: PPUSH
16501: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_INT 82
16512: PPUSH
16513: LD_INT 129
16515: PPUSH
16516: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16520: LD_EXP 39
16524: PPUSH
16525: LD_EXP 58
16529: PPUSH
16530: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16534: LD_INT 22
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: PUSH
16549: LD_EXP 39
16553: DIFF
16554: PPUSH
16555: LD_INT 84
16557: PPUSH
16558: LD_INT 128
16560: PPUSH
16561: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 39
16584: DIFF
16585: PPUSH
16586: LD_EXP 39
16590: PPUSH
16591: CALL_OW 179
// for i = 1 to amount do
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: DOUBLE
16601: LD_INT 1
16603: DEC
16604: ST_TO_ADDR
16605: LD_VAR 0 8
16609: PUSH
16610: FOR_TO
16611: IFFALSE 16779
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16613: LD_ADDR_VAR 0 9
16617: PUSH
16618: LD_VAR 0 9
16622: PUSH
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: ADD
16634: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: CALL_OW 310
16650: IFFALSE 16667
// AddComExitBuilding ( tmp [ i ] ) ;
16652: LD_VAR 0 5
16656: PUSH
16657: LD_VAR 0 2
16661: ARRAY
16662: PPUSH
16663: CALL_OW 182
// if i = 2 and JMMNewVeh then
16667: LD_VAR 0 2
16671: PUSH
16672: LD_INT 2
16674: EQUAL
16675: PUSH
16676: LD_EXP 56
16680: AND
16681: IFFALSE 16739
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 2
16692: ARRAY
16693: PPUSH
16694: LD_EXP 56
16698: PPUSH
16699: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16703: LD_VAR 0 5
16707: PUSH
16708: LD_VAR 0 2
16712: ARRAY
16713: PPUSH
16714: LD_INT 86
16716: PPUSH
16717: LD_INT 133
16719: PPUSH
16720: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16739: LD_VAR 0 5
16743: PUSH
16744: LD_VAR 0 2
16748: ARRAY
16749: PPUSH
16750: LD_INT 8
16752: PPUSH
16753: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: LD_EXP 39
16772: PPUSH
16773: CALL_OW 179
// end ;
16777: GO 16610
16779: POP
16780: POP
// if GirlNewVeh then
16781: LD_EXP 57
16785: IFFALSE 16799
// SetSide ( GirlNewVeh , 4 ) ;
16787: LD_EXP 57
16791: PPUSH
16792: LD_INT 4
16794: PPUSH
16795: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16799: LD_INT 35
16801: PPUSH
16802: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16806: LD_VAR 0 9
16810: PPUSH
16811: LD_INT 95
16813: PUSH
16814: LD_INT 9
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PPUSH
16821: CALL_OW 72
16825: PUSH
16826: LD_INT 0
16828: EQUAL
16829: PUSH
16830: LD_EXP 39
16834: PPUSH
16835: LD_INT 9
16837: PPUSH
16838: CALL_OW 308
16842: NOT
16843: AND
16844: IFFALSE 16799
// wait ( 0 0$2 ) ;
16846: LD_INT 70
16848: PPUSH
16849: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16853: LD_VAR 0 9
16857: PPUSH
16858: LD_INT 1
16860: PPUSH
16861: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16865: LD_INT 21
16867: PUSH
16868: LD_INT 2
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 92
16877: PUSH
16878: LD_INT 83
16880: PUSH
16881: LD_INT 130
16883: PUSH
16884: LD_INT 10
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PPUSH
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 235
// Video ( false ) ;
16909: LD_INT 0
16911: PPUSH
16912: CALL 100926 0 1
// ChangeMissionObjectives ( M1 ) ;
16916: LD_STRING M1
16918: PPUSH
16919: CALL_OW 337
// SaveForQuickRestart ;
16923: CALL_OW 22
// missionStart := true ;
16927: LD_ADDR_EXP 13
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// missionStage := 2 ;
16935: LD_ADDR_EXP 15
16939: PUSH
16940: LD_INT 2
16942: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16943: LD_INT 105
16945: PPUSH
16946: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16950: LD_ADDR_VAR 0 5
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 21
16967: PUSH
16968: LD_INT 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_EXP 58
16988: DIFF
16989: ST_TO_ADDR
// if not tmp then
16990: LD_VAR 0 5
16994: NOT
16995: IFFALSE 17010
// tmp := [ Powell ] ;
16997: LD_ADDR_VAR 0 5
17001: PUSH
17002: LD_EXP 58
17006: PUSH
17007: EMPTY
17008: LIST
17009: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17010: LD_ADDR_EXP 111
17014: PUSH
17015: LD_EXP 111
17019: PPUSH
17020: LD_INT 4
17022: PPUSH
17023: LD_INT 22
17025: PUSH
17026: LD_INT 4
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 23
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: PUSH
17070: LD_EXP 58
17074: DIFF
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17081: LD_ADDR_VAR 0 4
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 4
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 34
17098: PUSH
17099: LD_INT 12
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 310
17132: IFFALSE 17147
// ComExitBuilding ( tmp [ 1 ] ) ;
17134: LD_VAR 0 5
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17147: LD_VAR 0 5
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PPUSH
17156: LD_VAR 0 4
17160: PPUSH
17161: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17165: LD_VAR 0 5
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PPUSH
17174: LD_INT 80
17176: PPUSH
17177: LD_INT 136
17179: PPUSH
17180: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17184: LD_VAR 0 5
17188: PUSH
17189: LD_INT 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17197: LD_VAR 0 5
17201: PUSH
17202: LD_INT 1
17204: ARRAY
17205: PPUSH
17206: LD_INT 59
17208: PPUSH
17209: LD_INT 112
17211: PPUSH
17212: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17229: LD_EXP 40
17233: PUSH
17234: LD_EXP 40
17238: PPUSH
17239: CALL_OW 255
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: AND
17248: IFFALSE 17274
// begin Say ( Joan , D3W-Joan-1 ) ;
17250: LD_EXP 40
17254: PPUSH
17255: LD_STRING D3W-Joan-1
17257: PPUSH
17258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17262: LD_EXP 39
17266: PPUSH
17267: LD_STRING D3W-JMM-1
17269: PPUSH
17270: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17274: LD_EXP 42
17278: PUSH
17279: LD_EXP 42
17283: PPUSH
17284: CALL_OW 255
17288: PUSH
17289: LD_INT 1
17291: EQUAL
17292: AND
17293: PUSH
17294: LD_EXP 42
17298: PUSH
17299: LD_EXP 59
17303: IN
17304: NOT
17305: AND
17306: IFFALSE 17332
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17308: LD_EXP 42
17312: PPUSH
17313: LD_STRING D3W-Lisa-1
17315: PPUSH
17316: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17320: LD_EXP 39
17324: PPUSH
17325: LD_STRING D3W-JMM-1
17327: PPUSH
17328: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17332: LD_EXP 54
17336: PUSH
17337: LD_EXP 54
17341: PPUSH
17342: CALL_OW 255
17346: PUSH
17347: LD_INT 1
17349: EQUAL
17350: AND
17351: IFFALSE 17377
// begin Say ( Connie , D3W-Con-1 ) ;
17353: LD_EXP 54
17357: PPUSH
17358: LD_STRING D3W-Con-1
17360: PPUSH
17361: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17365: LD_EXP 39
17369: PPUSH
17370: LD_STRING D3W-JMM-1
17372: PPUSH
17373: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17377: LD_EXP 42
17381: PUSH
17382: LD_EXP 59
17386: IN
17387: PUSH
17388: LD_EXP 42
17392: PPUSH
17393: CALL_OW 255
17397: PUSH
17398: LD_INT 1
17400: EQUAL
17401: AND
17402: IFFALSE 17418
// Say ( Lisa , D3nW-Lisa-1 ) else
17404: LD_EXP 42
17408: PPUSH
17409: LD_STRING D3nW-Lisa-1
17411: PPUSH
17412: CALL_OW 88
17416: GO 17662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17418: LD_EXP 45
17422: PUSH
17423: LD_EXP 59
17427: IN
17428: PUSH
17429: LD_EXP 45
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 1
17441: EQUAL
17442: AND
17443: IFFALSE 17459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17445: LD_EXP 45
17449: PPUSH
17450: LD_STRING D3nW-Cyrus-1
17452: PPUSH
17453: CALL_OW 88
17457: GO 17662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17459: LD_EXP 44
17463: PUSH
17464: LD_EXP 59
17468: IN
17469: PUSH
17470: LD_EXP 44
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: AND
17484: IFFALSE 17500
// Say ( Bobby , D3nW-Bobby-1 ) else
17486: LD_EXP 44
17490: PPUSH
17491: LD_STRING D3nW-Bobby-1
17493: PPUSH
17494: CALL_OW 88
17498: GO 17662
// if Gary in vip and GetSide ( Gary ) = 1 then
17500: LD_EXP 51
17504: PUSH
17505: LD_EXP 59
17509: IN
17510: PUSH
17511: LD_EXP 51
17515: PPUSH
17516: CALL_OW 255
17520: PUSH
17521: LD_INT 1
17523: EQUAL
17524: AND
17525: IFFALSE 17541
// Say ( Gary , D3nW-Gary-1 ) else
17527: LD_EXP 51
17531: PPUSH
17532: LD_STRING D3nW-Gary-1
17534: PPUSH
17535: CALL_OW 88
17539: GO 17662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17541: LD_EXP 43
17545: PUSH
17546: LD_EXP 59
17550: IN
17551: PUSH
17552: LD_EXP 43
17556: PPUSH
17557: CALL_OW 255
17561: PUSH
17562: LD_INT 1
17564: EQUAL
17565: AND
17566: IFFALSE 17582
// Say ( Donaldson , D3nW-Don-1 ) else
17568: LD_EXP 43
17572: PPUSH
17573: LD_STRING D3nW-Don-1
17575: PPUSH
17576: CALL_OW 88
17580: GO 17662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17582: LD_EXP 50
17586: PUSH
17587: LD_EXP 59
17591: IN
17592: PUSH
17593: LD_EXP 50
17597: PPUSH
17598: CALL_OW 255
17602: PUSH
17603: LD_INT 1
17605: EQUAL
17606: AND
17607: IFFALSE 17623
// Say ( Cornel , D3nW-Corn-1 ) else
17609: LD_EXP 50
17613: PPUSH
17614: LD_STRING D3nW-Corn-1
17616: PPUSH
17617: CALL_OW 88
17621: GO 17662
// if Frank in vip and GetSide ( Frank ) = 1 then
17623: LD_EXP 52
17627: PUSH
17628: LD_EXP 59
17632: IN
17633: PUSH
17634: LD_EXP 52
17638: PPUSH
17639: CALL_OW 255
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: AND
17648: IFFALSE 17662
// Say ( Frank , D3nW-Frank-1 ) ;
17650: LD_EXP 52
17654: PPUSH
17655: LD_STRING D3nW-Frank-1
17657: PPUSH
17658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17662: LD_EXP 59
17666: PPUSH
17667: LD_INT 22
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PPUSH
17677: CALL_OW 72
17681: IFFALSE 17707
// begin Say ( JMM , D3nW-JMM-1 ) ;
17683: LD_EXP 39
17687: PPUSH
17688: LD_STRING D3nW-JMM-1
17690: PPUSH
17691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17695: LD_EXP 39
17699: PPUSH
17700: LD_STRING D3nW-JMM-1a
17702: PPUSH
17703: CALL_OW 88
// end ; t := 0 0$00 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17715: LD_INT 35
17717: PPUSH
17718: CALL_OW 67
// t := t + 0 0$1 ;
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_VAR 0 3
17731: PUSH
17732: LD_INT 35
17734: PLUS
17735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17736: LD_INT 59
17738: PPUSH
17739: LD_INT 112
17741: PPUSH
17742: CALL_OW 428
17746: PUSH
17747: LD_VAR 0 3
17751: PUSH
17752: LD_INT 2100
17754: GREATER
17755: OR
17756: IFFALSE 17715
// activeAttacks := true ;
17758: LD_ADDR_EXP 16
17762: PUSH
17763: LD_INT 1
17765: ST_TO_ADDR
// end ;
17766: LD_VAR 0 1
17770: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17771: LD_INT 0
17773: PPUSH
// case question of 1 :
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 1
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17838
17787: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D2Mot-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17800: LD_EXP 58
17804: PPUSH
17805: LD_STRING D2Mot-Pow-1
17807: PPUSH
17808: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17812: LD_EXP 39
17816: PPUSH
17817: LD_STRING D2Mot-JMM-2
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17824: LD_EXP 58
17828: PPUSH
17829: LD_STRING D2Mot-Pow-2
17831: PPUSH
17832: CALL_OW 88
// end ; 2 :
17836: GO 18189
17838: LD_INT 2
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17922
17846: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17847: LD_EXP 39
17851: PPUSH
17852: LD_STRING D2Rus-JMM-1
17854: PPUSH
17855: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17859: LD_EXP 58
17863: PPUSH
17864: LD_STRING D2Rus-Pow-1
17866: PPUSH
17867: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17871: LD_EXP 39
17875: PPUSH
17876: LD_STRING D2Rus-JMM-2
17878: PPUSH
17879: CALL_OW 88
// if not ( 3 in list_of_q ) then
17883: LD_INT 3
17885: PUSH
17886: LD_VAR 0 2
17890: IN
17891: NOT
17892: IFFALSE 17908
// Say ( Powell , D2Rus-Pow-2 ) else
17894: LD_EXP 58
17898: PPUSH
17899: LD_STRING D2Rus-Pow-2
17901: PPUSH
17902: CALL_OW 88
17906: GO 17920
// Say ( Powell , D2Rus-Pow-2a ) ;
17908: LD_EXP 58
17912: PPUSH
17913: LD_STRING D2Rus-Pow-2a
17915: PPUSH
17916: CALL_OW 88
// end ; 3 :
17920: GO 18189
17922: LD_INT 3
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18015
17930: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Leg-JMM-1
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17943: LD_EXP 58
17947: PPUSH
17948: LD_STRING D2Leg-Pow-1
17950: PPUSH
17951: CALL_OW 88
// if 2 in list_of_q then
17955: LD_INT 2
17957: PUSH
17958: LD_VAR 0 2
17962: IN
17963: IFFALSE 17989
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Leg-JMM-2
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Leg-Pow-2
17984: PPUSH
17985: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Leg-JMM-3
17996: PPUSH
17997: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18001: LD_EXP 58
18005: PPUSH
18006: LD_STRING D2Leg-Pow-3
18008: PPUSH
18009: CALL_OW 88
// end ; 4 :
18013: GO 18189
18015: LD_INT 4
18017: DOUBLE
18018: EQUAL
18019: IFTRUE 18023
18021: GO 18098
18023: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18024: LD_EXP 39
18028: PPUSH
18029: LD_STRING D2Ar-JMM-1
18031: PPUSH
18032: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18036: LD_EXP 58
18040: PPUSH
18041: LD_STRING D2Ar-Pow-1
18043: PPUSH
18044: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18048: LD_EXP 39
18052: PPUSH
18053: LD_STRING D2Ar-JMM-2
18055: PPUSH
18056: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18060: LD_EXP 58
18064: PPUSH
18065: LD_STRING D2Ar-Pow-2
18067: PPUSH
18068: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18072: LD_EXP 39
18076: PPUSH
18077: LD_STRING D2Ar-JMM-3
18079: PPUSH
18080: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18084: LD_EXP 58
18088: PPUSH
18089: LD_STRING D2Ar-Pow-3
18091: PPUSH
18092: CALL_OW 88
// end ; 5 :
18096: GO 18189
18098: LD_INT 5
18100: DOUBLE
18101: EQUAL
18102: IFTRUE 18106
18104: GO 18121
18106: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Conf-JMM-1
18114: PPUSH
18115: CALL_OW 88
18119: GO 18189
18121: LD_INT 6
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18188
18129: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18130: LD_EXP 39
18134: PPUSH
18135: LD_STRING D2Com-JMM-1
18137: PPUSH
18138: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18142: LD_EXP 58
18146: PPUSH
18147: LD_STRING D2Com-Pow-1
18149: PPUSH
18150: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18154: LD_EXP 39
18158: PPUSH
18159: LD_STRING D2Com-JMM-2
18161: PPUSH
18162: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18166: LD_EXP 58
18170: PPUSH
18171: LD_STRING D2Com-Pow-2
18173: PPUSH
18174: CALL_OW 88
// powellAngerQuery := true ;
18178: LD_ADDR_EXP 36
18182: PUSH
18183: LD_INT 1
18185: ST_TO_ADDR
// end ; end ;
18186: GO 18189
18188: POP
// end ;
18189: LD_VAR 0 3
18193: RET
// every 0 0$5 trigger missionStart do var tmp ;
18194: LD_EXP 13
18198: IFFALSE 18481
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18213: LD_INT 14
18215: PPUSH
18216: LD_INT 22
18218: PUSH
18219: LD_INT 1
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PPUSH
18226: CALL_OW 70
18230: PUSH
18231: LD_EXP 15
18235: PUSH
18236: LD_INT 2
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: LD_INT 4
18244: PUSH
18245: LD_INT 5
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: IN
18254: AND
18255: IFFALSE 18471
// begin powellAnger := powellAnger + 1 ;
18257: LD_ADDR_EXP 17
18261: PUSH
18262: LD_EXP 17
18266: PUSH
18267: LD_INT 1
18269: PLUS
18270: ST_TO_ADDR
// Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 100926 0 1
// CenterNowOnUnits ( tmp ) ;
18278: LD_VAR 0 1
18282: PPUSH
18283: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18287: LD_INT 14
18289: PPUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PPUSH
18300: CALL_OW 70
18304: PPUSH
18305: LD_INT 86
18307: PPUSH
18308: LD_INT 133
18310: PPUSH
18311: CALL_OW 111
// async ;
18315: ASYNC
// case powellAnger of 1 :
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 1
18323: DOUBLE
18324: EQUAL
18325: IFTRUE 18329
18327: GO 18344
18329: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18330: LD_EXP 58
18334: PPUSH
18335: LD_STRING DBack1-Pow-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18391
18344: LD_INT 2
18346: DOUBLE
18347: EQUAL
18348: IFTRUE 18352
18350: GO 18367
18352: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18353: LD_EXP 58
18357: PPUSH
18358: LD_STRING DBack2-Pow-1
18360: PPUSH
18361: CALL_OW 88
18365: GO 18391
18367: LD_INT 3
18369: DOUBLE
18370: EQUAL
18371: IFTRUE 18375
18373: GO 18390
18375: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18376: LD_EXP 58
18380: PPUSH
18381: LD_STRING DBack3-Pow-1
18383: PPUSH
18384: CALL_OW 88
18388: GO 18391
18390: POP
// sync ;
18391: SYNC
// repeat wait ( 0 0$1 ) ;
18392: LD_INT 35
18394: PPUSH
18395: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18427: LD_INT 14
18429: PPUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 70
18444: NOT
18445: IFFALSE 18392
// if powellAnger >= 3 then
18447: LD_EXP 17
18451: PUSH
18452: LD_INT 3
18454: GREATEREQUAL
18455: IFFALSE 18464
// YouLost ( Dismissed ) ;
18457: LD_STRING Dismissed
18459: PPUSH
18460: CALL_OW 104
// Video ( false ) ;
18464: LD_INT 0
18466: PPUSH
18467: CALL 100926 0 1
// end ; until missionStage > 5 ;
18471: LD_EXP 15
18475: PUSH
18476: LD_INT 5
18478: GREATER
18479: IFFALSE 18206
// end ;
18481: PPOPN 1
18483: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18484: LD_EXP 13
18488: PUSH
18489: LD_INT 22
18491: PUSH
18492: LD_INT 4
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 21
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: PPUSH
18513: CALL_OW 69
18517: PUSH
18518: LD_INT 4
18520: GREATEREQUAL
18521: AND
18522: PUSH
18523: LD_EXP 15
18527: PUSH
18528: LD_INT 2
18530: EQUAL
18531: AND
18532: IFFALSE 20355
18534: GO 18536
18536: DISABLE
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
18541: PPUSH
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
18546: PPUSH
// begin missionStage := 3 ;
18547: LD_ADDR_EXP 15
18551: PUSH
18552: LD_INT 3
18554: ST_TO_ADDR
// retreat := false ;
18555: LD_ADDR_VAR 0 4
18559: PUSH
18560: LD_INT 0
18562: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18563: LD_ADDR_VAR 0 5
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 4
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18597: LD_ADDR_VAR 0 6
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_INT 4
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 5
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: ST_TO_ADDR
// if not bar then
18631: LD_VAR 0 6
18635: NOT
18636: IFFALSE 18689
// begin repeat wait ( 0 0$1 ) ;
18638: LD_INT 35
18640: PPUSH
18641: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18645: LD_INT 22
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: LD_INT 57
18660: PUSH
18661: EMPTY
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 30
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: PPUSH
18683: CALL_OW 69
18687: IFFALSE 18638
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18689: LD_ADDR_VAR 0 6
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 4
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 30
18706: PUSH
18707: LD_INT 5
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL_OW 69
18722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18723: LD_INT 35
18725: PPUSH
18726: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18730: LD_EXP 130
18734: PUSH
18735: LD_INT 4
18737: ARRAY
18738: PUSH
18739: LD_INT 4
18741: GREATEREQUAL
18742: IFFALSE 18723
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_INT 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 2
18761: PUSH
18762: LD_INT 25
18764: PUSH
18765: LD_INT 1
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 25
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 25
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 25
18794: PUSH
18795: LD_INT 4
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 25
18804: PUSH
18805: LD_INT 5
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL_OW 69
18828: PUSH
18829: LD_EXP 58
18833: PUSH
18834: LD_EXP 59
18838: ADD
18839: DIFF
18840: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18841: LD_ADDR_VAR 0 3
18845: PUSH
18846: LD_VAR 0 2
18850: PPUSH
18851: LD_INT 26
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PPUSH
18861: CALL_OW 72
18865: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18866: LD_ADDR_VAR 0 2
18870: PUSH
18871: LD_VAR 0 2
18875: PUSH
18876: LD_VAR 0 3
18880: DIFF
18881: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18882: LD_ADDR_VAR 0 2
18886: PUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: LD_INT 1
18894: PPUSH
18895: CALL 99579 0 2
18899: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 3
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 99579 0 2
18917: ST_TO_ADDR
// for i = 1 to 4 do
18918: LD_ADDR_VAR 0 1
18922: PUSH
18923: DOUBLE
18924: LD_INT 1
18926: DEC
18927: ST_TO_ADDR
18928: LD_INT 4
18930: PUSH
18931: FOR_TO
18932: IFFALSE 19098
// begin if tmp2 then
18934: LD_VAR 0 3
18938: IFFALSE 19019
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18940: LD_ADDR_EXP 18
18944: PUSH
18945: LD_EXP 18
18949: PPUSH
18950: LD_INT 1
18952: PPUSH
18953: LD_EXP 18
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PUSH
18962: LD_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: ARRAY
18972: ADD
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18979: LD_VAR 0 3
18983: PUSH
18984: LD_VAR 0 3
18988: ARRAY
18989: PPUSH
18990: LD_INT 1
18992: PPUSH
18993: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 3
19011: PPUSH
19012: CALL_OW 3
19016: ST_TO_ADDR
// end else
19017: GO 19096
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19019: LD_ADDR_EXP 18
19023: PUSH
19024: LD_EXP 18
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: LD_EXP 18
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 2
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 2
19067: ARRAY
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 3
19095: ST_TO_ADDR
// end ; end ;
19096: GO 18931
19098: POP
19099: POP
// if tmp2 then
19100: LD_VAR 0 3
19104: IFFALSE 19122
// tmp := tmp union tmp2 ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 2
19115: PUSH
19116: LD_VAR 0 3
19120: UNION
19121: ST_TO_ADDR
// for i = 1 to 4 do
19122: LD_ADDR_VAR 0 1
19126: PUSH
19127: DOUBLE
19128: LD_INT 1
19130: DEC
19131: ST_TO_ADDR
19132: LD_INT 4
19134: PUSH
19135: FOR_TO
19136: IFFALSE 19185
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19138: LD_ADDR_EXP 18
19142: PUSH
19143: LD_EXP 18
19147: PPUSH
19148: LD_INT 2
19150: PPUSH
19151: LD_EXP 18
19155: PUSH
19156: LD_INT 2
19158: ARRAY
19159: PUSH
19160: LD_VAR 0 2
19164: PUSH
19165: LD_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: MINUS
19175: ARRAY
19176: ADD
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
19183: GO 19135
19185: POP
19186: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19187: LD_ADDR_EXP 111
19191: PUSH
19192: LD_EXP 111
19196: PPUSH
19197: LD_INT 4
19199: PPUSH
19200: LD_EXP 111
19204: PUSH
19205: LD_INT 4
19207: ARRAY
19208: PUSH
19209: LD_EXP 18
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: DIFF
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_INT 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 313
19237: IFFALSE 19292
// begin for i in UnitsInside ( arm [ 1 ] ) do
19239: LD_ADDR_VAR 0 1
19243: PUSH
19244: LD_VAR 0 5
19248: PUSH
19249: LD_INT 1
19251: ARRAY
19252: PPUSH
19253: CALL_OW 313
19257: PUSH
19258: FOR_IN
19259: IFFALSE 19290
// begin ComExitBuilding ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_VAR 0 6
19279: PUSH
19280: LD_INT 1
19282: ARRAY
19283: PPUSH
19284: CALL_OW 180
// end ;
19288: GO 19258
19290: POP
19291: POP
// end ; wait ( 0 0$3 ) ;
19292: LD_INT 105
19294: PPUSH
19295: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19299: LD_ADDR_VAR 0 1
19303: PUSH
19304: LD_EXP 18
19308: PUSH
19309: LD_INT 1
19311: ARRAY
19312: PUSH
19313: FOR_IN
19314: IFFALSE 19421
// begin if IsInUnit ( i ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 310
19325: IFFALSE 19336
// ComExitBuilding ( i ) ;
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 122
// if GetClass ( i ) <> 1 then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 257
19345: PUSH
19346: LD_INT 1
19348: NONEQUAL
19349: IFFALSE 19390
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19351: LD_VAR 0 1
19355: PPUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 183
// AddComExitBuilding ( i ) ;
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_INT 60
19397: PPUSH
19398: LD_INT 94
19400: PPUSH
19401: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_EXP 58
19414: PPUSH
19415: CALL_OW 179
// end ;
19419: GO 19313
19421: POP
19422: POP
// wait ( 0 0$15 ) ;
19423: LD_INT 525
19425: PPUSH
19426: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19430: LD_EXP 58
19434: PPUSH
19435: LD_STRING D4-Pow-1
19437: PPUSH
19438: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19442: LD_ADDR_VAR 0 2
19446: PUSH
19447: LD_EXP 18
19451: PUSH
19452: LD_INT 1
19454: ARRAY
19455: PPUSH
19456: LD_INT 26
19458: PUSH
19459: LD_INT 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 72
19470: ST_TO_ADDR
// if tmp then
19471: LD_VAR 0 2
19475: IFFALSE 19493
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19477: LD_VAR 0 2
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_STRING D4-Sol1-1
19488: PPUSH
19489: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19493: LD_EXP 58
19497: PPUSH
19498: LD_STRING D4-Pow-2
19500: PPUSH
19501: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19505: LD_ADDR_VAR 0 1
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_EXP 18
19519: PUSH
19520: LD_INT 1
19522: ARRAY
19523: PUSH
19524: FOR_TO
19525: IFFALSE 19618
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: PPUSH
19542: LD_EXP 130
19546: PUSH
19547: LD_INT 4
19549: ARRAY
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19559: LD_ADDR_EXP 130
19563: PUSH
19564: LD_EXP 130
19568: PPUSH
19569: LD_INT 4
19571: PPUSH
19572: LD_EXP 130
19576: PUSH
19577: LD_INT 4
19579: ARRAY
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: CALL_OW 3
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19594: LD_INT 8
19596: PPUSH
19597: LD_EXP 18
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 471
// end ;
19616: GO 19524
19618: POP
19619: POP
// repeat wait ( 0 0$1 ) ;
19620: LD_INT 35
19622: PPUSH
19623: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PPUSH
19636: LD_INT 55
19638: PUSH
19639: EMPTY
19640: LIST
19641: PPUSH
19642: CALL_OW 72
19646: PUSH
19647: LD_INT 4
19649: GREATEREQUAL
19650: IFFALSE 19620
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 69
19663: PPUSH
19664: LD_INT 94
19666: PPUSH
19667: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19671: LD_EXP 18
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: PPUSH
19680: LD_INT 82
19682: PPUSH
19683: LD_INT 83
19685: PPUSH
19686: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19690: LD_EXP 18
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: LD_INT 77
19701: PPUSH
19702: LD_INT 69
19704: PPUSH
19705: CALL_OW 174
// repeat wait ( 3 ) ;
19709: LD_INT 3
19711: PPUSH
19712: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19716: LD_ADDR_VAR 0 1
19720: PUSH
19721: LD_EXP 18
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: FOR_IN
19731: IFFALSE 19867
// begin if GetLives ( i ) < 990 then
19733: LD_VAR 0 1
19737: PPUSH
19738: CALL_OW 256
19742: PUSH
19743: LD_INT 990
19745: LESS
19746: IFFALSE 19760
// SetLives ( i , 1000 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_INT 1000
19755: PPUSH
19756: CALL_OW 234
// if not IsInUnit ( i ) then
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 310
19769: NOT
19770: IFFALSE 19865
// begin if not HasTask ( i ) then
19772: LD_VAR 0 1
19776: PPUSH
19777: CALL_OW 314
19781: NOT
19782: IFFALSE 19799
// ComMoveXY ( i , 64 , 93 ) ;
19784: LD_VAR 0 1
19788: PPUSH
19789: LD_INT 64
19791: PPUSH
19792: LD_INT 93
19794: PPUSH
19795: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19799: LD_VAR 0 4
19803: NOT
19804: PUSH
19805: LD_VAR 0 1
19809: PPUSH
19810: CALL_OW 258
19814: PUSH
19815: LD_INT 1
19817: EQUAL
19818: AND
19819: IFFALSE 19865
// begin retreat := true ;
19821: LD_ADDR_VAR 0 4
19825: PUSH
19826: LD_INT 1
19828: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: LD_STRING D4a-Sol1-1
19848: PPUSH
19849: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19853: LD_EXP 58
19857: PPUSH
19858: LD_STRING D4a-Pow-1
19860: PPUSH
19861: CALL_OW 88
// end ; end ; end ;
19865: GO 19730
19867: POP
19868: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19869: LD_EXP 18
19873: PUSH
19874: LD_INT 1
19876: ARRAY
19877: PPUSH
19878: LD_INT 95
19880: PUSH
19881: LD_INT 9
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 55
19893: PUSH
19894: EMPTY
19895: LIST
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: PUSH
19910: LD_INT 4
19912: GREATEREQUAL
19913: IFFALSE 19709
// for i in powellSquadAttack [ 1 ] do
19915: LD_ADDR_VAR 0 1
19919: PUSH
19920: LD_EXP 18
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PUSH
19929: FOR_IN
19930: IFFALSE 20066
// begin if GetTag ( i ) = 2 then
19932: LD_VAR 0 1
19936: PPUSH
19937: CALL_OW 110
19941: PUSH
19942: LD_INT 2
19944: EQUAL
19945: IFFALSE 20007
// begin ComMoveXY ( i , 60 , 94 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 60
19954: PPUSH
19955: LD_INT 94
19957: PPUSH
19958: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_EXP 58
19971: PPUSH
19972: CALL_OW 179
// wait ( 0 0$3 ) ;
19976: LD_INT 105
19978: PPUSH
19979: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19983: LD_VAR 0 1
19987: PPUSH
19988: LD_STRING D4a-Sol1-2
19990: PPUSH
19991: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19995: LD_EXP 58
19999: PPUSH
20000: LD_STRING D4a-Pow-2
20002: PPUSH
20003: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20007: LD_VAR 0 1
20011: PPUSH
20012: LD_INT 0
20014: PPUSH
20015: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20019: LD_ADDR_EXP 111
20023: PUSH
20024: LD_EXP 111
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: LD_EXP 111
20036: PUSH
20037: LD_INT 4
20039: ARRAY
20040: PUSH
20041: LD_VAR 0 1
20045: UNION
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20052: LD_INT 8
20054: PPUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: CALL_OW 472
// end ;
20064: GO 19929
20066: POP
20067: POP
// wait ( 4 4$00 ) ;
20068: LD_INT 8400
20070: PPUSH
20071: CALL_OW 67
// uc_side := 6 ;
20075: LD_ADDR_OWVAR 20
20079: PUSH
20080: LD_INT 6
20082: ST_TO_ADDR
// uc_nation := 3 ;
20083: LD_ADDR_OWVAR 21
20087: PUSH
20088: LD_INT 3
20090: ST_TO_ADDR
// ru := [ ] ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: EMPTY
20097: ST_TO_ADDR
// for i = 1 to 4 do
20098: LD_ADDR_VAR 0 1
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_INT 4
20110: PUSH
20111: FOR_TO
20112: IFFALSE 20213
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20114: LD_INT 22
20116: PPUSH
20117: LD_INT 1
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 43
20125: PUSH
20126: LD_INT 44
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 2
20138: PPUSH
20139: CALL_OW 12
20143: ARRAY
20144: PPUSH
20145: LD_INT 89
20147: PPUSH
20148: CALL 69908 0 5
// un := CreateVehicle ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: CALL_OW 45
20161: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20162: LD_VAR 0 8
20166: PPUSH
20167: LD_INT 4
20169: PPUSH
20170: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20174: LD_VAR 0 8
20178: PPUSH
20179: LD_INT 136
20181: PPUSH
20182: LD_INT 90
20184: PPUSH
20185: LD_INT 8
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 50
// ru := ru ^ un ;
20195: LD_ADDR_VAR 0 7
20199: PUSH
20200: LD_VAR 0 7
20204: PUSH
20205: LD_VAR 0 8
20209: ADD
20210: ST_TO_ADDR
// end ;
20211: GO 20111
20213: POP
20214: POP
// if ru then
20215: LD_VAR 0 7
20219: IFFALSE 20236
// ComAgressiveMove ( ru , 80 , 92 ) ;
20221: LD_VAR 0 7
20225: PPUSH
20226: LD_INT 80
20228: PPUSH
20229: LD_INT 92
20231: PPUSH
20232: CALL_OW 114
// wait ( 8 8$00 ) ;
20236: LD_INT 16800
20238: PPUSH
20239: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20243: LD_INT 4
20245: PPUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 1
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 5
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: PUSH
20264: LD_INT 4
20266: PUSH
20267: LD_INT 1
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 6
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 1
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 3
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 7
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 3
20320: PUSH
20321: LD_INT 1
20323: PUSH
20324: LD_INT 1
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 58692 0 2
// missionStage := 4 ;
20347: LD_ADDR_EXP 15
20351: PUSH
20352: LD_INT 4
20354: ST_TO_ADDR
// end ;
20355: PPOPN 8
20357: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20358: LD_EXP 15
20362: PUSH
20363: LD_INT 4
20365: EQUAL
20366: PUSH
20367: LD_INT 22
20369: PUSH
20370: LD_INT 4
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 21
20379: PUSH
20380: LD_INT 2
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PPUSH
20391: CALL_OW 69
20395: PUSH
20396: LD_INT 5
20398: GREATEREQUAL
20399: AND
20400: IFFALSE 24505
20402: GO 20404
20404: DISABLE
20405: LD_INT 0
20407: PPUSH
20408: PPUSH
20409: PPUSH
20410: PPUSH
20411: PPUSH
20412: PPUSH
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
20419: PPUSH
// begin missionStage := 5 ;
20420: LD_ADDR_EXP 15
20424: PUSH
20425: LD_INT 5
20427: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20428: LD_ADDR_VAR 0 10
20432: PUSH
20433: LD_INT 22
20435: PUSH
20436: LD_INT 4
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: LD_INT 2
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 4
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 30
20458: PUSH
20459: LD_INT 5
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PPUSH
20475: CALL_OW 69
20479: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20480: LD_ADDR_VAR 0 6
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 1
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 3
20507: PUSH
20508: LD_INT 25
20510: PUSH
20511: LD_INT 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 3
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 12
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: PPUSH
20545: CALL_OW 69
20549: PUSH
20550: LD_EXP 58
20554: DIFF
20555: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20556: LD_ADDR_VAR 0 9
20560: PUSH
20561: LD_INT 22
20563: PUSH
20564: LD_INT 4
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 3
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PPUSH
20585: CALL_OW 69
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20594: LD_INT 35
20596: PPUSH
20597: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20601: LD_EXP 130
20605: PUSH
20606: LD_INT 4
20608: ARRAY
20609: PUSH
20610: LD_INT 5
20612: GREATEREQUAL
20613: PUSH
20614: LD_EXP 130
20618: PUSH
20619: LD_INT 4
20621: ARRAY
20622: PPUSH
20623: LD_INT 58
20625: PUSH
20626: EMPTY
20627: LIST
20628: PPUSH
20629: CALL_OW 72
20633: PUSH
20634: LD_INT 5
20636: GREATEREQUAL
20637: AND
20638: IFFALSE 20594
// powellAllowRetreat := false ;
20640: LD_ADDR_EXP 19
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20648: LD_INT 700
20650: PPUSH
20651: CALL_OW 67
// activeAttacks := false ;
20655: LD_ADDR_EXP 16
20659: PUSH
20660: LD_INT 0
20662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20663: LD_INT 35
20665: PPUSH
20666: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20670: LD_INT 22
20672: PUSH
20673: LD_INT 6
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: LD_INT 0
20687: EQUAL
20688: IFFALSE 20663
// tmp := mc_vehicles [ 4 ] ;
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_EXP 130
20699: PUSH
20700: LD_INT 4
20702: ARRAY
20703: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20704: LD_ADDR_VAR 0 1
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_EXP 18
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20981
// begin for j in powellSquadAttack [ i ] do
20722: LD_ADDR_VAR 0 2
20726: PUSH
20727: LD_EXP 18
20731: PUSH
20732: LD_VAR 0 1
20736: ARRAY
20737: PUSH
20738: FOR_IN
20739: IFFALSE 20977
// begin forces := forces diff j ;
20741: LD_ADDR_VAR 0 6
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: LD_VAR 0 2
20755: DIFF
20756: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20757: LD_VAR 0 2
20761: PPUSH
20762: LD_INT 1
20764: PPUSH
20765: CALL_OW 109
// wait ( 0 0$2 ) ;
20769: LD_INT 70
20771: PPUSH
20772: CALL_OW 67
// if IsInUnit ( j ) then
20776: LD_VAR 0 2
20780: PPUSH
20781: CALL_OW 310
20785: IFFALSE 20796
// ComExitBuilding ( j ) ;
20787: LD_VAR 0 2
20791: PPUSH
20792: CALL_OW 122
// if GetClass ( j ) <> 1 then
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 1
20808: NONEQUAL
20809: IFFALSE 20889
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20811: LD_VAR 0 10
20815: PUSH
20816: LD_INT 1
20818: ARRAY
20819: PPUSH
20820: CALL_OW 313
20824: PUSH
20825: LD_INT 5
20827: GREATEREQUAL
20828: IFFALSE 20850
// AddComEnterUnit ( j , arm [ 2 ] ) else
20830: LD_VAR 0 2
20834: PPUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: PPUSH
20844: CALL_OW 180
20848: GO 20868
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20850: LD_VAR 0 2
20854: PPUSH
20855: LD_VAR 0 10
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20868: LD_VAR 0 2
20872: PPUSH
20873: LD_INT 1
20875: PPUSH
20876: CALL_OW 183
// AddComExitBuilding ( j ) ;
20880: LD_VAR 0 2
20884: PPUSH
20885: CALL_OW 182
// end ; if i = 2 then
20889: LD_VAR 0 1
20893: PUSH
20894: LD_INT 2
20896: EQUAL
20897: IFFALSE 20914
// AddComMoveXY ( j , 61 , 93 ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: LD_INT 61
20906: PPUSH
20907: LD_INT 93
20909: PPUSH
20910: CALL_OW 171
// if i = 1 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 1
20921: EQUAL
20922: IFFALSE 20975
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_VAR 0 3
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_VAR 0 3
20951: PPUSH
20952: LD_INT 1
20954: PPUSH
20955: CALL_OW 3
20959: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_INT 69
20967: PPUSH
20968: LD_INT 94
20970: PPUSH
20971: CALL_OW 171
// end ; end ;
20975: GO 20738
20977: POP
20978: POP
// end ;
20979: GO 20719
20981: POP
20982: POP
// wait ( 0 0$55 ) ;
20983: LD_INT 1925
20985: PPUSH
20986: CALL_OW 67
// MC_Kill ( 4 ) ;
20990: LD_INT 4
20992: PPUSH
20993: CALL 35296 0 1
// tmp := UnitsInside ( fac ) ;
20997: LD_ADDR_VAR 0 3
21001: PUSH
21002: LD_VAR 0 9
21006: PPUSH
21007: CALL_OW 313
21011: ST_TO_ADDR
// if tmp then
21012: LD_VAR 0 3
21016: IFFALSE 21137
// for i in tmp do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 3
21027: PUSH
21028: FOR_IN
21029: IFFALSE 21135
// begin ComExitBuilding ( i ) ;
21031: LD_VAR 0 1
21035: PPUSH
21036: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21040: LD_VAR 0 10
21044: PUSH
21045: LD_INT 2
21047: ARRAY
21048: PPUSH
21049: CALL_OW 313
21053: PUSH
21054: LD_INT 6
21056: LESS
21057: IFFALSE 21079
// AddComEnterUnit ( i , arm [ 2 ] ) else
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 2
21071: ARRAY
21072: PPUSH
21073: CALL_OW 180
21077: GO 21133
// if UnitsInside ( arm [ 1 ] ) < 6 then
21079: LD_VAR 0 10
21083: PUSH
21084: LD_INT 1
21086: ARRAY
21087: PPUSH
21088: CALL_OW 313
21092: PUSH
21093: LD_INT 6
21095: LESS
21096: IFFALSE 21118
// AddComEnterUnit ( i , arm [ 1 ] ) else
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 10
21107: PUSH
21108: LD_INT 1
21110: ARRAY
21111: PPUSH
21112: CALL_OW 180
21116: GO 21133
// AddComMoveXY ( i , 37 , 68 ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_INT 37
21125: PPUSH
21126: LD_INT 68
21128: PPUSH
21129: CALL_OW 171
// end ;
21133: GO 21028
21135: POP
21136: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21137: LD_ADDR_VAR 0 11
21141: PUSH
21142: LD_VAR 0 6
21146: PPUSH
21147: LD_INT 26
21149: PUSH
21150: LD_INT 1
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL_OW 72
21161: PUSH
21162: LD_EXP 59
21166: DIFF
21167: ST_TO_ADDR
// if not speaker then
21168: LD_VAR 0 11
21172: NOT
21173: IFFALSE 21200
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21175: LD_ADDR_VAR 0 11
21179: PUSH
21180: LD_VAR 0 6
21184: PPUSH
21185: LD_INT 26
21187: PUSH
21188: LD_INT 1
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PPUSH
21195: CALL_OW 72
21199: ST_TO_ADDR
// if speaker then
21200: LD_VAR 0 11
21204: IFFALSE 21220
// speaker := speaker [ 1 ] ;
21206: LD_ADDR_VAR 0 11
21210: PUSH
21211: LD_VAR 0 11
21215: PUSH
21216: LD_INT 1
21218: ARRAY
21219: ST_TO_ADDR
// Video ( true ) ;
21220: LD_INT 1
21222: PPUSH
21223: CALL 100926 0 1
// CenterNowOnUnits ( Powell ) ;
21227: LD_EXP 58
21231: PPUSH
21232: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 6
21245: PPUSH
21246: LD_INT 3
21248: PUSH
21249: LD_INT 25
21251: PUSH
21252: LD_INT 1
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 72
21267: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21268: LD_ADDR_VAR 0 12
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 30
21285: PUSH
21286: LD_INT 32
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 58
21295: PUSH
21296: EMPTY
21297: LIST
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 69
21308: ST_TO_ADDR
// for i = 1 to 6 do
21309: LD_ADDR_VAR 0 1
21313: PUSH
21314: DOUBLE
21315: LD_INT 1
21317: DEC
21318: ST_TO_ADDR
21319: LD_INT 6
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21464
// begin if IsInUnit ( tmp [ i ] ) then
21325: LD_VAR 0 3
21329: PUSH
21330: LD_VAR 0 1
21334: ARRAY
21335: PPUSH
21336: CALL_OW 310
21340: IFFALSE 21357
// ComExitBuilding ( tmp [ i ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21357: LD_VAR 0 3
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: PPUSH
21368: LD_VAR 0 10
21372: PUSH
21373: LD_INT 1
21375: ARRAY
21376: PPUSH
21377: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21381: LD_VAR 0 3
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PPUSH
21392: LD_INT 1
21394: PPUSH
21395: CALL_OW 183
// if emp_towers then
21399: LD_VAR 0 12
21403: IFFALSE 21462
// begin AddComExitBuilding ( tmp [ i ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_VAR 0 1
21429: ARRAY
21430: PPUSH
21431: LD_VAR 0 12
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21444: LD_ADDR_VAR 0 12
21448: PUSH
21449: LD_VAR 0 12
21453: PPUSH
21454: LD_INT 1
21456: PPUSH
21457: CALL_OW 3
21461: ST_TO_ADDR
// end ; end ;
21462: GO 21322
21464: POP
21465: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_EXP 18
21475: PUSH
21476: LD_INT 1
21478: ARRAY
21479: PUSH
21480: LD_EXP 18
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: ADD
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 2
21517: ARRAY
21518: PUSH
21519: FOR_IN
21520: IFFALSE 21538
// ComTurnUnit ( i , Powell ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_EXP 58
21531: PPUSH
21532: CALL_OW 119
21536: GO 21519
21538: POP
21539: POP
// Say ( Powell , D5-Pow-1 ) ;
21540: LD_EXP 58
21544: PPUSH
21545: LD_STRING D5-Pow-1
21547: PPUSH
21548: CALL_OW 88
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21574
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PPUSH
21567: LD_STRING D5-Sol2-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21574: LD_EXP 58
21578: PPUSH
21579: LD_STRING D5-Pow-2
21581: PPUSH
21582: CALL_OW 88
// if tmp > 1 then
21586: LD_VAR 0 3
21590: PUSH
21591: LD_INT 1
21593: GREATER
21594: IFFALSE 21612
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 2
21603: ARRAY
21604: PPUSH
21605: LD_STRING D5-Sol2-2
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5-Pow-3
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21631: LD_ADDR_VAR 0 3
21635: PUSH
21636: LD_EXP 18
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PUSH
21645: LD_EXP 18
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: UNION
21654: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21655: LD_VAR 0 3
21659: PPUSH
21660: LD_INT 80
21662: PPUSH
21663: LD_INT 67
21665: PPUSH
21666: CALL_OW 114
// wait ( 0 0$2 ) ;
21670: LD_INT 70
21672: PPUSH
21673: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21677: LD_INT 79
21679: PPUSH
21680: LD_INT 72
21682: PPUSH
21683: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21687: LD_INT 35
21689: PPUSH
21690: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_INT 3
21701: PUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1000
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: IFFALSE 21687
// Say ( Powell , D5a-Pow-1 ) ;
21722: LD_EXP 58
21726: PPUSH
21727: LD_STRING D5a-Pow-1
21729: PPUSH
21730: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21734: LD_EXP 58
21738: PPUSH
21739: LD_STRING D5a-Pow-1a
21741: PPUSH
21742: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21746: LD_INT 10
21748: PPUSH
21749: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21753: LD_EXP 58
21757: PPUSH
21758: LD_STRING D5a-Pow-1b
21760: PPUSH
21761: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21765: LD_EXP 58
21769: PPUSH
21770: LD_STRING D5a-Pow-1c
21772: PPUSH
21773: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21777: LD_EXP 58
21781: PPUSH
21782: LD_STRING D5a-Pow-1d
21784: PPUSH
21785: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21789: LD_INT 35
21791: PPUSH
21792: CALL_OW 67
// if not HasTask ( tmp ) then
21796: LD_VAR 0 3
21800: PPUSH
21801: CALL_OW 314
21805: NOT
21806: IFFALSE 21823
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 80
21815: PPUSH
21816: LD_INT 67
21818: PPUSH
21819: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 24
21830: PUSH
21831: LD_INT 1
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 72
21842: NOT
21843: IFFALSE 21789
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_INT 22
21852: PUSH
21853: LD_INT 4
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 92
21862: PUSH
21863: LD_INT 60
21865: PUSH
21866: LD_INT 93
21868: PUSH
21869: LD_INT 10
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 3
21880: PUSH
21881: LD_INT 54
21883: PUSH
21884: EMPTY
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PPUSH
21896: CALL_OW 69
21900: PUSH
21901: LD_EXP 58
21905: DIFF
21906: ST_TO_ADDR
// if tmp then
21907: LD_VAR 0 3
21911: IFFALSE 21945
// for i in tmp do
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_VAR 0 3
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21943
// ComMoveXY ( i , 36 , 67 ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_INT 36
21933: PPUSH
21934: LD_INT 67
21936: PPUSH
21937: CALL_OW 111
21941: GO 21923
21943: POP
21944: POP
// wait ( 0 0$3 ) ;
21945: LD_INT 105
21947: PPUSH
21948: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6-Sol3-1
21959: PPUSH
21960: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21964: LD_EXP 58
21968: PPUSH
21969: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21973: LD_EXP 58
21977: PPUSH
21978: LD_STRING D6-Pow-1
21980: PPUSH
21981: CALL_OW 88
// tmp := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// for i = 1 to 2 do
21992: LD_ADDR_VAR 0 1
21996: PUSH
21997: DOUBLE
21998: LD_INT 1
22000: DEC
22001: ST_TO_ADDR
22002: LD_INT 2
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22120
// begin uc_side := 8 ;
22008: LD_ADDR_OWVAR 20
22012: PUSH
22013: LD_INT 8
22015: ST_TO_ADDR
// uc_nation := 2 ;
22016: LD_ADDR_OWVAR 21
22020: PUSH
22021: LD_INT 2
22023: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22024: LD_INT 14
22026: PPUSH
22027: LD_INT 3
22029: PPUSH
22030: LD_INT 2
22032: PPUSH
22033: LD_INT 29
22035: PPUSH
22036: LD_INT 100
22038: PPUSH
22039: CALL 69908 0 5
// veh := CreateVehicle ;
22043: LD_ADDR_VAR 0 13
22047: PUSH
22048: CALL_OW 45
22052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22053: LD_VAR 0 13
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22065: LD_VAR 0 13
22069: PPUSH
22070: LD_INT 99
22072: PPUSH
22073: LD_INT 83
22075: PPUSH
22076: LD_INT 6
22078: PPUSH
22079: LD_INT 0
22081: PPUSH
22082: CALL_OW 50
// wait ( 3 ) ;
22086: LD_INT 3
22088: PPUSH
22089: CALL_OW 67
// Connect ( veh ) ;
22093: LD_VAR 0 13
22097: PPUSH
22098: CALL 72963 0 1
// tmp := tmp ^ veh ;
22102: LD_ADDR_VAR 0 3
22106: PUSH
22107: LD_VAR 0 3
22111: PUSH
22112: LD_VAR 0 13
22116: ADD
22117: ST_TO_ADDR
// end ;
22118: GO 22005
22120: POP
22121: POP
// wait ( 0 0$1 ) ;
22122: LD_INT 35
22124: PPUSH
22125: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22129: LD_INT 99
22131: PPUSH
22132: LD_INT 83
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 10
22140: PPUSH
22141: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22145: LD_INT 99
22147: PPUSH
22148: LD_INT 83
22150: PPUSH
22151: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22155: LD_VAR 0 11
22159: PPUSH
22160: LD_STRING D6-Sol3-2
22162: PPUSH
22163: CALL_OW 88
// async ;
22167: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22168: LD_EXP 58
22172: PPUSH
22173: LD_STRING D6-Pow-2
22175: PPUSH
22176: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_VAR 0 9
22193: PPUSH
22194: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22198: LD_VAR 0 3
22202: PUSH
22203: LD_INT 2
22205: ARRAY
22206: PPUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 21
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: PPUSH
22236: LD_VAR 0 3
22240: PUSH
22241: LD_INT 2
22243: ARRAY
22244: PPUSH
22245: CALL_OW 74
22249: PPUSH
22250: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22254: LD_EXP 58
22258: PPUSH
22259: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22263: LD_INT 99
22265: PPUSH
22266: LD_INT 83
22268: PPUSH
22269: LD_INT 1
22271: PPUSH
22272: CALL_OW 331
// repeat wait ( 4 ) ;
22276: LD_INT 4
22278: PPUSH
22279: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22283: LD_VAR 0 3
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 256
22296: PUSH
22297: LD_INT 1000
22299: LESS
22300: IFFALSE 22318
// SetLives ( tmp [ 1 ] , 1000 ) ;
22302: LD_VAR 0 3
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_INT 1000
22313: PPUSH
22314: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22318: LD_INT 22
22320: PUSH
22321: LD_INT 4
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 30
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_INT 0
22349: EQUAL
22350: IFFALSE 22276
// sync ;
22352: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22353: LD_EXP 58
22357: PPUSH
22358: LD_STRING D6a-Pow-1
22360: PPUSH
22361: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22365: LD_VAR 0 11
22369: PPUSH
22370: LD_STRING D6a-Sol3-1
22372: PPUSH
22373: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22377: LD_EXP 58
22381: PPUSH
22382: LD_STRING D6a-Pow-2
22384: PPUSH
22385: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22389: LD_VAR 0 11
22393: PPUSH
22394: LD_STRING D6a-Sol3-2
22396: PPUSH
22397: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22401: LD_EXP 58
22405: PPUSH
22406: LD_STRING D6a-Pow-3
22408: PPUSH
22409: CALL_OW 88
// powellCenterCameraMode := true ;
22413: LD_ADDR_EXP 20
22417: PUSH
22418: LD_INT 1
22420: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: LD_INT 22
22428: PUSH
22429: LD_INT 8
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PPUSH
22450: CALL_OW 69
22454: PUSH
22455: FOR_IN
22456: IFFALSE 22511
// begin SetTag ( i , 1 ) ;
22458: LD_VAR 0 1
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 109
// ComExitBuilding ( i ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 35
22486: PPUSH
22487: LD_INT 6
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 53
22501: PPUSH
22502: LD_INT 4
22504: PPUSH
22505: CALL_OW 171
// end ;
22509: GO 22455
22511: POP
22512: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 22
22520: PUSH
22521: LD_INT 4
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 21
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 3
22540: PUSH
22541: LD_INT 34
22543: PUSH
22544: LD_INT 12
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22565: LD_EXP 58
22569: PPUSH
22570: LD_VAR 0 3
22574: PPUSH
22575: LD_EXP 58
22579: PPUSH
22580: CALL_OW 74
22584: PPUSH
22585: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 88
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 100
22611: PPUSH
22612: LD_INT 75
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22619: LD_EXP 58
22623: PPUSH
22624: LD_INT 88
22626: PPUSH
22627: LD_INT 53
22629: PPUSH
22630: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22634: LD_INT 8
22636: PPUSH
22637: LD_EXP 58
22641: PPUSH
22642: CALL_OW 471
// repeat wait ( 3 ) ;
22646: LD_INT 3
22648: PPUSH
22649: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 92
22665: PUSH
22666: LD_INT 100
22668: PUSH
22669: LD_INT 75
22671: PUSH
22672: LD_INT 6
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 69
22689: IFFALSE 22646
// async ;
22691: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_STRING D6b-Pow-1
22699: PPUSH
22700: CALL_OW 88
// repeat wait ( 3 ) ;
22704: LD_INT 3
22706: PPUSH
22707: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: PPUSH
22721: CALL_OW 256
22725: PUSH
22726: LD_INT 1000
22728: LESS
22729: IFFALSE 22748
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: CALL_OW 310
22740: PPUSH
22741: LD_INT 1000
22743: PPUSH
22744: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22748: LD_EXP 58
22752: PPUSH
22753: CALL_OW 256
22757: PUSH
22758: LD_INT 1000
22760: LESS
22761: IFFALSE 22775
// SetLives ( Powell , 1000 ) ;
22763: LD_EXP 58
22767: PPUSH
22768: LD_INT 1000
22770: PPUSH
22771: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22775: LD_EXP 58
22779: PPUSH
22780: LD_EXP 63
22784: PPUSH
22785: CALL_OW 296
22789: PUSH
22790: LD_INT 5
22792: LESS
22793: PUSH
22794: LD_EXP 58
22798: PPUSH
22799: CALL_OW 310
22803: PPUSH
22804: LD_EXP 63
22808: PPUSH
22809: CALL_OW 296
22813: PUSH
22814: LD_INT 5
22816: LESS
22817: OR
22818: IFFALSE 22837
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: CALL_OW 310
22829: PPUSH
22830: LD_INT 100
22832: PPUSH
22833: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22837: LD_EXP 58
22841: PPUSH
22842: CALL_OW 310
22846: NOT
22847: IFFALSE 22704
// DoNotAttack ( 8 , powellBomb ) ;
22849: LD_INT 8
22851: PPUSH
22852: LD_EXP 63
22856: PPUSH
22857: CALL_OW 471
// game_speed := 4 ;
22861: LD_ADDR_OWVAR 65
22865: PUSH
22866: LD_INT 4
22868: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_STRING D6b-Pow-1a
22876: PPUSH
22877: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22881: LD_EXP 58
22885: PPUSH
22886: LD_EXP 63
22890: PPUSH
22891: CALL_OW 180
// sync ;
22895: SYNC
// repeat wait ( 0 0$1 ) ;
22896: LD_INT 35
22898: PPUSH
22899: CALL_OW 67
// until IsInUnit ( Powell ) ;
22903: LD_EXP 58
22907: PPUSH
22908: CALL_OW 310
22912: IFFALSE 22896
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22914: LD_INT 8
22916: PPUSH
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 91
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 44
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 96
22968: PPUSH
22969: LD_INT 41
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 92
22983: PPUSH
22984: LD_INT 39
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 88
22998: PPUSH
22999: LD_INT 41
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 91
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 44
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 96
23043: PPUSH
23044: LD_INT 41
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 92
23058: PPUSH
23059: LD_INT 39
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 88
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 91
23088: PPUSH
23089: LD_INT 44
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 39
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 93
23118: PPUSH
23119: LD_INT 36
23121: PPUSH
23122: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23126: LD_INT 122
23128: PPUSH
23129: CALL_OW 67
// game_speed := 4 ;
23133: LD_ADDR_OWVAR 65
23137: PUSH
23138: LD_INT 4
23140: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_STRING D6b-Pow-1b
23148: PPUSH
23149: CALL_OW 88
// tmp := [ ] ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_INT 78
23167: PUSH
23168: LD_INT 47
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: LD_INT 106
23177: PUSH
23178: LD_INT 53
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_INT 8
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 21
23206: PUSH
23207: LD_INT 3
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 92
23216: PUSH
23217: LD_INT 90
23219: PUSH
23220: LD_INT 52
23222: PUSH
23223: LD_INT 12
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: PPUSH
23237: CALL_OW 69
23241: PUSH
23242: FOR_IN
23243: IFFALSE 23268
// tmp := tmp ^ UnitsInside ( i ) ;
23245: LD_ADDR_VAR 0 3
23249: PUSH
23250: LD_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 313
23264: ADD
23265: ST_TO_ADDR
23266: GO 23242
23268: POP
23269: POP
// for i in tmp do
23270: LD_ADDR_VAR 0 1
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23443
// begin dist := 9999 ;
23283: LD_ADDR_VAR 0 8
23287: PUSH
23288: LD_INT 9999
23290: ST_TO_ADDR
// _xy := [ ] ;
23291: LD_ADDR_VAR 0 7
23295: PUSH
23296: EMPTY
23297: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23298: LD_VAR 0 1
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 109
// ComExitBuilding ( i ) ;
23310: LD_VAR 0 1
23314: PPUSH
23315: CALL_OW 122
// for j in xy do
23319: LD_ADDR_VAR 0 2
23323: PUSH
23324: LD_VAR 0 5
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23412
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23332: LD_VAR 0 1
23336: PPUSH
23337: LD_VAR 0 2
23341: PUSH
23342: LD_INT 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 2
23350: PUSH
23351: LD_INT 2
23353: ARRAY
23354: PPUSH
23355: CALL_OW 297
23359: PUSH
23360: LD_VAR 0 8
23364: LESS
23365: IFFALSE 23410
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_VAR 0 1
23376: PPUSH
23377: LD_VAR 0 2
23381: PUSH
23382: LD_INT 1
23384: ARRAY
23385: PPUSH
23386: LD_VAR 0 2
23390: PUSH
23391: LD_INT 2
23393: ARRAY
23394: PPUSH
23395: CALL_OW 297
23399: ST_TO_ADDR
// _xy := j ;
23400: LD_ADDR_VAR 0 7
23404: PUSH
23405: LD_VAR 0 2
23409: ST_TO_ADDR
// end ;
23410: GO 23329
23412: POP
23413: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: LD_VAR 0 7
23423: PUSH
23424: LD_INT 1
23426: ARRAY
23427: PPUSH
23428: LD_VAR 0 7
23432: PUSH
23433: LD_INT 2
23435: ARRAY
23436: PPUSH
23437: CALL_OW 171
// end ;
23441: GO 23280
23443: POP
23444: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: LD_INT 26
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 25
23467: PUSH
23468: LD_INT 1
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PPUSH
23479: CALL_OW 72
23483: ST_TO_ADDR
// if tmp2 < 2 then
23484: LD_VAR 0 4
23488: PUSH
23489: LD_INT 2
23491: LESS
23492: IFFALSE 23561
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23494: LD_ADDR_VAR 0 4
23498: PUSH
23499: LD_INT 22
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: LD_INT 1
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 3
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 15
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: LIST
23540: PPUSH
23541: CALL_OW 69
23545: PUSH
23546: LD_EXP 60
23550: PUSH
23551: LD_EXP 61
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: DIFF
23560: ST_TO_ADDR
// if tmp2 then
23561: LD_VAR 0 4
23565: IFFALSE 23583
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23567: LD_VAR 0 4
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_STRING D6b-ArSol1-1
23578: PPUSH
23579: CALL_OW 88
// async ;
23583: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23584: LD_EXP 58
23588: PPUSH
23589: LD_STRING D6b-Pow-2
23591: PPUSH
23592: CALL_OW 88
// wait ( 0 0$1 ) ;
23596: LD_INT 35
23598: PPUSH
23599: CALL_OW 67
// if tmp2 > 1 then
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 1
23610: GREATER
23611: IFFALSE 23629
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: LD_STRING D6b-ArSol2-1
23624: PPUSH
23625: CALL_OW 88
// sync ;
23629: SYNC
// repeat wait ( 5 ) ;
23630: LD_INT 5
23632: PPUSH
23633: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23637: LD_INT 93
23639: PPUSH
23640: LD_INT 36
23642: PPUSH
23643: CALL_OW 428
23647: PPUSH
23648: CALL_OW 255
23652: PUSH
23653: LD_INT 4
23655: EQUAL
23656: IFFALSE 23630
// DialogueOn ;
23658: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23662: LD_INT 10
23664: PPUSH
23665: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23669: LD_EXP 58
23673: PPUSH
23674: LD_STRING D6b-Pow-2a
23676: PPUSH
23677: CALL_OW 88
// DialogueOff ;
23681: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23685: LD_EXP 58
23689: PPUSH
23690: CALL_OW 310
23694: PPUSH
23695: LD_INT 332
23697: PPUSH
23698: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23702: LD_INT 93
23704: PPUSH
23705: LD_INT 35
23707: PPUSH
23708: LD_INT 1
23710: PPUSH
23711: LD_INT 6
23713: NEG
23714: PPUSH
23715: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23719: LD_INT 35
23721: PPUSH
23722: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23726: LD_INT 332
23728: PPUSH
23729: CALL_OW 256
23733: PUSH
23734: LD_INT 1000
23736: LESS
23737: PUSH
23738: LD_INT 332
23740: PPUSH
23741: CALL_OW 300
23745: AND
23746: IFFALSE 23758
// SetLives ( kozlov_fac , 0 ) ;
23748: LD_INT 332
23750: PPUSH
23751: LD_INT 0
23753: PPUSH
23754: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23758: LD_INT 332
23760: PPUSH
23761: CALL_OW 301
23765: PUSH
23766: LD_EXP 58
23770: PPUSH
23771: CALL_OW 301
23775: OR
23776: IFFALSE 23719
// game_speed := 4 ;
23778: LD_ADDR_OWVAR 65
23782: PUSH
23783: LD_INT 4
23785: ST_TO_ADDR
// powellCenterCameraMode := false ;
23786: LD_ADDR_EXP 20
23790: PUSH
23791: LD_INT 0
23793: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23794: LD_ADDR_VAR 0 1
23798: PUSH
23799: LD_VAR 0 3
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 8
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 25
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 69
23832: UNION
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23851
// SetTag ( i , 0 ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 0
23844: PPUSH
23845: CALL_OW 109
23849: GO 23834
23851: POP
23852: POP
// wait ( 0 0$3 ) ;
23853: LD_INT 105
23855: PPUSH
23856: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23860: LD_INT 93
23862: PPUSH
23863: LD_INT 35
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 331
// DialogueOn ;
23873: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23877: LD_VAR 0 11
23881: PPUSH
23882: LD_STRING D6c-Sol3-1
23884: PPUSH
23885: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23889: LD_INT 10
23891: PPUSH
23892: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23896: LD_EXP 39
23900: PPUSH
23901: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23905: LD_EXP 39
23909: PPUSH
23910: LD_STRING D6c-JMM-1
23912: PPUSH
23913: CALL_OW 88
// if Cyrus then
23917: LD_EXP 45
23921: IFFALSE 23935
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23923: LD_EXP 45
23927: PPUSH
23928: LD_STRING D6c-Cyrus-1
23930: PPUSH
23931: CALL_OW 88
// if Bobby then
23935: LD_EXP 44
23939: IFFALSE 23953
// Say ( Bobby , D6c-Bobby-1 ) ;
23941: LD_EXP 44
23945: PPUSH
23946: LD_STRING D6c-Bobby-1
23948: PPUSH
23949: CALL_OW 88
// if Cornel then
23953: LD_EXP 50
23957: IFFALSE 23971
// Say ( Cornel , D6c-Corn-1 ) ;
23959: LD_EXP 50
23963: PPUSH
23964: LD_STRING D6c-Corn-1
23966: PPUSH
23967: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23971: LD_ADDR_VAR 0 4
23975: PUSH
23976: LD_INT 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_INT 1
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 4
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 26
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 3
24016: PUSH
24017: LD_INT 25
24019: PUSH
24020: LD_INT 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 25
24029: PUSH
24030: LD_INT 12
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: PPUSH
24047: CALL_OW 69
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_EXP 39
24061: UNION
24062: PUSH
24063: LD_EXP 59
24067: UNION
24068: PUSH
24069: EMPTY
24070: LIST
24071: DIFF
24072: ST_TO_ADDR
// if tmp2 then
24073: LD_VAR 0 4
24077: IFFALSE 24095
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24079: LD_VAR 0 4
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: PPUSH
24088: LD_STRING D6c-Sol1-1
24090: PPUSH
24091: CALL_OW 88
// if Lisa then
24095: LD_EXP 42
24099: IFFALSE 24113
// Say ( Lisa , D6c-Lisa-1 ) ;
24101: LD_EXP 42
24105: PPUSH
24106: LD_STRING D6c-Lisa-1
24108: PPUSH
24109: CALL_OW 88
// if Gary then
24113: LD_EXP 51
24117: IFFALSE 24131
// Say ( Gary , D6c-Gary-1 ) ;
24119: LD_EXP 51
24123: PPUSH
24124: LD_STRING D6c-Gary-1
24126: PPUSH
24127: CALL_OW 88
// if Donaldson then
24131: LD_EXP 43
24135: IFFALSE 24149
// Say ( Donaldson , D6c-Don-1 ) ;
24137: LD_EXP 43
24141: PPUSH
24142: LD_STRING D6c-Don-1
24144: PPUSH
24145: CALL_OW 88
// if tmp2 > 1 then
24149: LD_VAR 0 4
24153: PUSH
24154: LD_INT 1
24156: GREATER
24157: IFFALSE 24175
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24159: LD_VAR 0 4
24163: PUSH
24164: LD_INT 2
24166: ARRAY
24167: PPUSH
24168: LD_STRING D6c-Sol2-1
24170: PPUSH
24171: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24175: LD_VAR 0 11
24179: PPUSH
24180: LD_STRING D6c-Sol3-2
24182: PPUSH
24183: CALL_OW 88
// dwait ( 0 0$1 ) ;
24187: LD_INT 35
24189: PPUSH
24190: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24194: LD_EXP 39
24198: PPUSH
24199: LD_STRING D6c-JMM-2
24201: PPUSH
24202: CALL_OW 88
// DialogueOff ;
24206: CALL_OW 7
// Video ( false ) ;
24210: LD_INT 0
24212: PPUSH
24213: CALL 100926 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24217: LD_INT 22
24219: PUSH
24220: LD_INT 4
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PPUSH
24227: CALL_OW 69
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 4
24244: PPUSH
24245: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24249: LD_ADDR_VAR 0 1
24253: PUSH
24254: LD_INT 4
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 65147 0 3
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24306
// if GetTech ( i , 1 ) <> state_researched then
24271: LD_VAR 0 1
24275: PPUSH
24276: LD_INT 1
24278: PPUSH
24279: CALL_OW 321
24283: PUSH
24284: LD_INT 2
24286: NONEQUAL
24287: IFFALSE 24304
// SetTech ( i , 1 , state_researched ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 1
24296: PPUSH
24297: LD_INT 2
24299: PPUSH
24300: CALL_OW 322
24304: GO 24268
24306: POP
24307: POP
// missionStage := 6 ;
24308: LD_ADDR_EXP 15
24312: PUSH
24313: LD_INT 6
24315: ST_TO_ADDR
// activeAttacks := true ;
24316: LD_ADDR_EXP 16
24320: PUSH
24321: LD_INT 1
24323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24324: LD_STRING M2
24326: PPUSH
24327: CALL_OW 337
// SaveForQuickRestart ;
24331: CALL_OW 22
// wait ( 0 0$40 ) ;
24335: LD_INT 1400
24337: PPUSH
24338: CALL_OW 67
// DialogueOn ;
24342: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24346: LD_EXP 62
24350: PPUSH
24351: LD_STRING D7-Friend-1
24353: PPUSH
24354: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24358: LD_EXP 39
24362: PPUSH
24363: LD_STRING D7-JMM-1
24365: PPUSH
24366: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24370: LD_EXP 62
24374: PPUSH
24375: LD_STRING D7-Friend-2
24377: PPUSH
24378: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24382: LD_EXP 39
24386: PPUSH
24387: LD_STRING D7-JMM-2
24389: PPUSH
24390: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24394: LD_EXP 62
24398: PPUSH
24399: LD_STRING D7-Friend-3
24401: PPUSH
24402: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24406: LD_EXP 39
24410: PPUSH
24411: LD_STRING D7-JMM-3
24413: PPUSH
24414: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24418: LD_EXP 62
24422: PPUSH
24423: LD_STRING D7-Friend-4
24425: PPUSH
24426: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24430: LD_EXP 39
24434: PPUSH
24435: LD_STRING D7-JMM-4
24437: PPUSH
24438: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24442: LD_EXP 62
24446: PPUSH
24447: LD_STRING D7-Friend-5
24449: PPUSH
24450: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24454: LD_EXP 39
24458: PPUSH
24459: LD_STRING D7-JMM-5
24461: PPUSH
24462: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24466: LD_EXP 62
24470: PPUSH
24471: LD_STRING D7-Friend-6
24473: PPUSH
24474: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24478: LD_EXP 39
24482: PPUSH
24483: LD_STRING D7-JMM-6
24485: PPUSH
24486: CALL_OW 88
// DialogueOff ;
24490: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24494: LD_STRING Mlegion
24496: PPUSH
24497: CALL_OW 337
// RebuildKozlovFactory ;
24501: CALL 4855 0 0
// end ;
24505: PPOPN 13
24507: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24508: LD_EXP 20
24512: PUSH
24513: LD_EXP 58
24517: PPUSH
24518: CALL_OW 300
24522: AND
24523: IFFALSE 24565
24525: GO 24527
24527: DISABLE
// begin enable ;
24528: ENABLE
// if IsInUnit ( Powell ) then
24529: LD_EXP 58
24533: PPUSH
24534: CALL_OW 310
24538: IFFALSE 24556
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24540: LD_EXP 58
24544: PPUSH
24545: CALL_OW 310
24549: PPUSH
24550: CALL_OW 85
24554: GO 24565
// CenterOnUnits ( Powell ) ;
24556: LD_EXP 58
24560: PPUSH
24561: CALL_OW 85
// end ;
24565: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24566: LD_INT 22
24568: PUSH
24569: LD_INT 8
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 34
24578: PUSH
24579: LD_INT 48
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 69
24594: IFFALSE 24868
24596: GO 24598
24598: DISABLE
24599: LD_INT 0
24601: PPUSH
24602: PPUSH
// begin if missionStage < 9 then
24603: LD_EXP 15
24607: PUSH
24608: LD_INT 9
24610: LESS
24611: IFFALSE 24621
// missionStage := 9 ;
24613: LD_ADDR_EXP 15
24617: PUSH
24618: LD_INT 9
24620: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24621: LD_ADDR_VAR 0 1
24625: PUSH
24626: LD_INT 22
24628: PUSH
24629: LD_INT 8
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 34
24638: PUSH
24639: LD_INT 48
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PPUSH
24650: CALL_OW 69
24654: PUSH
24655: LD_INT 1
24657: ARRAY
24658: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24659: LD_INT 175
24661: PPUSH
24662: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24666: LD_EXP 12
24670: PUSH
24671: LD_EXP 3
24675: PUSH
24676: LD_INT 0
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: IN
24686: OR
24687: IFFALSE 24710
// target := [ 68 , 108 , 1 ] else
24689: LD_ADDR_VAR 0 2
24693: PUSH
24694: LD_INT 68
24696: PUSH
24697: LD_INT 108
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: ST_TO_ADDR
24708: GO 24729
// target := [ 181 , 88 , 2 ] ;
24710: LD_ADDR_VAR 0 2
24714: PUSH
24715: LD_INT 181
24717: PUSH
24718: LD_INT 88
24720: PUSH
24721: LD_INT 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24729: LD_VAR 0 1
24733: PPUSH
24734: LD_VAR 0 2
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 2
24747: PUSH
24748: LD_INT 2
24750: ARRAY
24751: PPUSH
24752: CALL_OW 176
// if target [ 3 ] = 1 then
24756: LD_VAR 0 2
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 1
24767: EQUAL
24768: IFFALSE 24784
// SayRadio ( Kurt , D12-Kurt-1 ) else
24770: LD_EXP 60
24774: PPUSH
24775: LD_STRING D12-Kurt-1
24777: PPUSH
24778: CALL_OW 94
24782: GO 24808
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D12a-Kurt-1
24791: PPUSH
24792: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24796: LD_EXP 74
24800: PPUSH
24801: LD_STRING D12a-Roth-1
24803: PPUSH
24804: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24808: LD_INT 350
24810: PPUSH
24811: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24815: LD_VAR 0 1
24819: PPUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 23
24832: PUSH
24833: LD_INT 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 30
24842: PUSH
24843: LD_INT 3
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: CALL_OW 228
// end ;
24868: PPOPN 2
24870: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24871: LD_EXP 60
24875: PPUSH
24876: CALL_OW 256
24880: PUSH
24881: LD_INT 999
24883: LESS
24884: PUSH
24885: LD_INT 22
24887: PUSH
24888: LD_INT 8
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 21
24897: PUSH
24898: LD_INT 1
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 23
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: LD_INT 8
24930: PUSH
24931: LD_INT 7
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_OWVAR 67
24943: ARRAY
24944: LESSEQUAL
24945: OR
24946: PUSH
24947: LD_INT 22
24949: PUSH
24950: LD_INT 8
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 34
24959: PUSH
24960: LD_INT 48
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PPUSH
24971: CALL_OW 69
24975: NOT
24976: AND
24977: PUSH
24978: LD_EXP 60
24982: PPUSH
24983: CALL_OW 302
24987: AND
24988: PUSH
24989: LD_INT 5
24991: PPUSH
24992: LD_INT 22
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PPUSH
25002: CALL_OW 70
25006: AND
25007: IFFALSE 25712
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
25016: PPUSH
// begin DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25021: LD_EXP 39
25025: PPUSH
25026: LD_STRING D13-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25033: LD_EXP 60
25037: PPUSH
25038: LD_STRING D13-Kurt-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25045: LD_EXP 39
25049: PPUSH
25050: LD_STRING D13-JMM-2
25052: PPUSH
25053: CALL_OW 88
// if FakeInfo then
25057: LD_EXP 12
25061: IFFALSE 25081
// begin Say ( Kurt , D13-Kurt-2 ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_STRING D13-Kurt-2
25070: PPUSH
25071: CALL_OW 88
// DialogueOff ;
25075: CALL_OW 7
// exit ;
25079: GO 25712
// end ; if not KurtStatus then
25081: LD_EXP 3
25085: NOT
25086: IFFALSE 25102
// Say ( Kurt , D13-Kurt-2b ) else
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2b
25095: PPUSH
25096: CALL_OW 88
25100: GO 25114
// Say ( Kurt , D13-Kurt-2a ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_STRING D13-Kurt-2a
25109: PPUSH
25110: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25114: LD_EXP 39
25118: PPUSH
25119: LD_STRING D13-JMM-3
25121: PPUSH
25122: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25126: LD_EXP 60
25130: PPUSH
25131: LD_STRING D13-Kurt-3
25133: PPUSH
25134: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-4
25145: PPUSH
25146: CALL_OW 88
// DialogueOff ;
25150: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25154: LD_STRING MlegionOut
25156: PPUSH
25157: CALL_OW 337
// legionDestroyed := true ;
25161: LD_ADDR_EXP 22
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25169: LD_INT 3
25171: PPUSH
25172: CALL 35296 0 1
// KillUnit ( Kozlov ) ;
25176: LD_EXP 61
25180: PPUSH
25181: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_INT 22
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 23
25202: PUSH
25203: LD_INT 3
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 3
25212: PUSH
25213: LD_INT 21
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 69
25236: PUSH
25237: FOR_IN
25238: IFFALSE 25251
// KillUnit ( i ) ;
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 66
25249: GO 25237
25251: POP
25252: POP
// ChangeSideFog ( 8 , 1 ) ;
25253: LD_INT 8
25255: PPUSH
25256: LD_INT 1
25258: PPUSH
25259: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25263: LD_ADDR_VAR 0 2
25267: PUSH
25268: LD_INT 22
25270: PUSH
25271: LD_INT 8
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 21
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PPUSH
25292: CALL_OW 69
25296: PUSH
25297: LD_EXP 61
25301: PUSH
25302: LD_EXP 60
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: DIFF
25311: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25312: LD_VAR 0 2
25316: PUSH
25317: LD_INT 6
25319: PUSH
25320: LD_INT 5
25322: PUSH
25323: LD_INT 4
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_OWVAR 67
25335: ARRAY
25336: GREATEREQUAL
25337: IFFALSE 25511
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_INT 6
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: LD_INT 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_OWVAR 67
25362: ARRAY
25363: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25364: LD_ADDR_VAR 0 1
25368: PUSH
25369: DOUBLE
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: PLUS
25383: MINUS
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25507
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25392: LD_ADDR_EXP 38
25396: PUSH
25397: LD_EXP 38
25401: PUSH
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: ADD
25413: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_VAR 0 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 310
25429: IFFALSE 25446
// ComExitBuilding ( tmp [ i ] ) ;
25431: LD_VAR 0 2
25435: PUSH
25436: LD_VAR 0 1
25440: ARRAY
25441: PPUSH
25442: CALL_OW 122
// if IsInUnit ( i ) then
25446: LD_VAR 0 1
25450: PPUSH
25451: CALL_OW 310
25455: IFFALSE 25472
// ComExitVehicle ( tmp [ i ] ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 1
25481: ARRAY
25482: PPUSH
25483: LD_INT 34
25485: PUSH
25486: LD_INT 0
25488: PPUSH
25489: LD_INT 6
25491: PPUSH
25492: CALL_OW 12
25496: PLUS
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: CALL_OW 171
// end ;
25505: GO 25389
25507: POP
25508: POP
// end else
25509: GO 25521
// x := tmp ;
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: LD_VAR 0 2
25520: ST_TO_ADDR
// for i := tmp downto tmp - x do
25521: LD_ADDR_VAR 0 1
25525: PUSH
25526: DOUBLE
25527: LD_VAR 0 2
25531: INC
25532: ST_TO_ADDR
25533: LD_VAR 0 2
25537: PUSH
25538: LD_VAR 0 3
25542: MINUS
25543: PUSH
25544: FOR_DOWNTO
25545: IFFALSE 25599
// begin if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitVehicle ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25579: LD_VAR 0 2
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: PPUSH
25590: LD_INT 1
25592: PPUSH
25593: CALL_OW 235
// end ;
25597: GO 25544
25599: POP
25600: POP
// SetSide ( Kurt , 1 ) ;
25601: LD_EXP 60
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25613: LD_INT 22
25615: PUSH
25616: LD_INT 8
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 21
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PPUSH
25637: CALL_OW 69
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25649: LD_INT 8
25651: PPUSH
25652: LD_INT 1
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: LD_INT 1
25660: PPUSH
25661: CALL_OW 80
// wait ( 1 1$20 ) ;
25665: LD_INT 2800
25667: PPUSH
25668: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25672: LD_EXP 62
25676: PPUSH
25677: LD_INT 37
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 48
// wait ( 0 0$1 ) ;
25690: LD_INT 35
25692: PPUSH
25693: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 60
25704: PPUSH
25705: LD_INT 95
25707: PPUSH
25708: CALL_OW 111
// end ;
25712: PPOPN 3
25714: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25715: LD_EXP 22
25719: NOT
25720: PUSH
25721: LD_INT 22
25723: PUSH
25724: LD_INT 8
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 21
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PPUSH
25745: CALL_OW 69
25749: PUSH
25750: LD_INT 0
25752: EQUAL
25753: AND
25754: IFFALSE 25774
25756: GO 25758
25758: DISABLE
// begin legionDestroyed := true ;
25759: LD_ADDR_EXP 22
25763: PUSH
25764: LD_INT 1
25766: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25767: LD_STRING MlegionOut
25769: PPUSH
25770: CALL_OW 337
// end ;
25774: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25775: LD_EXP 38
25779: IFFALSE 25854
25781: GO 25783
25783: DISABLE
25784: LD_INT 0
25786: PPUSH
// begin enable ;
25787: ENABLE
// for i in legionEscapeUnits do
25788: LD_ADDR_VAR 0 1
25792: PUSH
25793: LD_EXP 38
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25852
// begin if IsInArea ( i , legionEscapeArea ) then
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 31
25808: PPUSH
25809: CALL_OW 308
25813: IFFALSE 25826
// RemoveUnit ( i ) else
25815: LD_VAR 0 1
25819: PPUSH
25820: CALL_OW 64
25824: GO 25850
// if not HasTask ( i ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: CALL_OW 314
25835: NOT
25836: IFFALSE 25850
// ComMoveToArea ( i , legionEscapeArea ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 31
25845: PPUSH
25846: CALL_OW 113
// end ;
25850: GO 25798
25852: POP
25853: POP
// end ;
25854: PPOPN 1
25856: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25857: LD_INT 1
25859: PPUSH
25860: LD_EXP 62
25864: PPUSH
25865: CALL_OW 292
25869: IFFALSE 26167
25871: GO 25873
25873: DISABLE
25874: LD_INT 0
25876: PPUSH
// begin wait ( 0 0$2 ) ;
25877: LD_INT 70
25879: PPUSH
25880: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25884: LD_EXP 62
25888: PPUSH
25889: CALL_OW 87
// DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14-JMM-2
25928: PPUSH
25929: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25933: LD_EXP 62
25937: PPUSH
25938: LD_STRING D14-Friend-2
25940: PPUSH
25941: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25945: LD_EXP 39
25949: PPUSH
25950: LD_STRING D14-JMM-3
25952: PPUSH
25953: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25957: LD_EXP 62
25961: PPUSH
25962: LD_STRING D14-Friend-3
25964: PPUSH
25965: CALL_OW 88
// DialogueOff ;
25969: CALL_OW 7
// dec = Query ( Q14 ) ;
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: LD_STRING Q14
25980: PPUSH
25981: CALL_OW 97
25985: ST_TO_ADDR
// if dec = 1 then
25986: LD_VAR 0 1
25990: PUSH
25991: LD_INT 1
25993: EQUAL
25994: IFFALSE 26028
// begin DialogueOn ;
25996: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26000: LD_EXP 39
26004: PPUSH
26005: LD_STRING D14a-JMM-1
26007: PPUSH
26008: CALL_OW 88
// DialogueOff ;
26012: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26016: LD_EXP 62
26020: PPUSH
26021: LD_INT 1
26023: PPUSH
26024: CALL_OW 235
// end ; if dec = 2 then
26028: LD_VAR 0 1
26032: PUSH
26033: LD_INT 2
26035: EQUAL
26036: IFFALSE 26089
// begin DialogueOn ;
26038: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26042: LD_EXP 39
26046: PPUSH
26047: LD_STRING D14b-JMM-1
26049: PPUSH
26050: CALL_OW 88
// DialogueOff ;
26054: CALL_OW 7
// wait ( 0 0$1 ) ;
26058: LD_INT 35
26060: PPUSH
26061: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26065: LD_EXP 62
26069: PPUSH
26070: LD_INT 9
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL_OW 111
// AddComHold ( Friend ) ;
26080: LD_EXP 62
26084: PPUSH
26085: CALL_OW 200
// end ; if dec = 3 then
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 3
26096: EQUAL
26097: IFFALSE 26167
// begin DialogueOn ;
26099: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26103: LD_EXP 39
26107: PPUSH
26108: LD_STRING D14c-JMM-1
26110: PPUSH
26111: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26115: LD_EXP 62
26119: PPUSH
26120: LD_STRING D14c-Friend-1
26122: PPUSH
26123: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26127: LD_EXP 39
26131: PPUSH
26132: LD_STRING D14c-JMM-2
26134: PPUSH
26135: CALL_OW 88
// DialogueOff ;
26139: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26143: LD_EXP 62
26147: PPUSH
26148: LD_INT 9
26150: PPUSH
26151: LD_INT 2
26153: PPUSH
26154: CALL_OW 111
// AddComHold ( Friend ) ;
26158: LD_EXP 62
26162: PPUSH
26163: CALL_OW 200
// end ; end ;
26167: PPOPN 1
26169: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26170: LD_INT 9
26172: PPUSH
26173: LD_INT 2
26175: PPUSH
26176: CALL_OW 428
26180: PUSH
26181: LD_EXP 62
26185: EQUAL
26186: PUSH
26187: LD_EXP 62
26191: PPUSH
26192: CALL_OW 255
26196: PUSH
26197: LD_INT 8
26199: EQUAL
26200: AND
26201: IFFALSE 26215
26203: GO 26205
26205: DISABLE
// RemoveUnit ( Friend ) ;
26206: LD_EXP 62
26210: PPUSH
26211: CALL_OW 64
26215: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26216: LD_EXP 14
26220: PUSH
26221: LD_INT 31500
26223: GREATEREQUAL
26224: PUSH
26225: LD_EXP 7
26229: AND
26230: PUSH
26231: LD_EXP 2
26235: AND
26236: IFFALSE 26666
26238: GO 26240
26240: DISABLE
26241: LD_INT 0
26243: PPUSH
26244: PPUSH
26245: PPUSH
// begin missionStage := 7 ;
26246: LD_ADDR_EXP 15
26250: PUSH
26251: LD_INT 7
26253: ST_TO_ADDR
// uc_side = 1 ;
26254: LD_ADDR_OWVAR 20
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// uc_nation = 1 ;
26262: LD_ADDR_OWVAR 21
26266: PUSH
26267: LD_INT 1
26269: ST_TO_ADDR
// for i = 1 to 5 do
26270: LD_ADDR_VAR 0 1
26274: PUSH
26275: DOUBLE
26276: LD_INT 1
26278: DEC
26279: ST_TO_ADDR
26280: LD_INT 5
26282: PUSH
26283: FOR_TO
26284: IFFALSE 26380
// begin vc_engine = 3 ;
26286: LD_ADDR_OWVAR 39
26290: PUSH
26291: LD_INT 3
26293: ST_TO_ADDR
// vc_control = 3 ;
26294: LD_ADDR_OWVAR 38
26298: PUSH
26299: LD_INT 3
26301: ST_TO_ADDR
// vc_chassis = 3 ;
26302: LD_ADDR_OWVAR 37
26306: PUSH
26307: LD_INT 3
26309: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26310: LD_ADDR_OWVAR 40
26314: PUSH
26315: LD_INT 5
26317: PUSH
26318: LD_INT 9
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PPUSH
26332: LD_INT 3
26334: PPUSH
26335: CALL_OW 12
26339: ARRAY
26340: ST_TO_ADDR
// veh = CreateVehicle ;
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: CALL_OW 45
26350: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26351: LD_VAR 0 2
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26363: LD_VAR 0 2
26367: PPUSH
26368: LD_INT 19
26370: PPUSH
26371: LD_INT 0
26373: PPUSH
26374: CALL_OW 49
// end ;
26378: GO 26283
26380: POP
26381: POP
// vc_engine = 3 ;
26382: LD_ADDR_OWVAR 39
26386: PUSH
26387: LD_INT 3
26389: ST_TO_ADDR
// vc_control = 1 ;
26390: LD_ADDR_OWVAR 38
26394: PUSH
26395: LD_INT 1
26397: ST_TO_ADDR
// vc_chassis = 3 ;
26398: LD_ADDR_OWVAR 37
26402: PUSH
26403: LD_INT 3
26405: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26406: LD_ADDR_OWVAR 40
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: LD_INT 9
26416: PUSH
26417: LD_INT 7
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 1
26427: PPUSH
26428: LD_INT 3
26430: PPUSH
26431: CALL_OW 12
26435: ARRAY
26436: ST_TO_ADDR
// vehG = CreateVehicle ;
26437: LD_ADDR_VAR 0 3
26441: PUSH
26442: CALL_OW 45
26446: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26447: LD_VAR 0 3
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26459: LD_VAR 0 3
26463: PPUSH
26464: LD_INT 19
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 49
// if JMMGirl = 1 then
26474: LD_EXP 7
26478: PUSH
26479: LD_INT 1
26481: EQUAL
26482: IFFALSE 26538
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26484: LD_ADDR_EXP 40
26488: PUSH
26489: LD_STRING Joan
26491: PPUSH
26492: LD_INT 1
26494: PPUSH
26495: LD_STRING 14_
26497: PPUSH
26498: CALL 65084 0 3
26502: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26503: LD_EXP 40
26507: PPUSH
26508: LD_VAR 0 3
26512: PPUSH
26513: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26517: LD_VAR 0 3
26521: PPUSH
26522: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26526: LD_EXP 40
26530: PPUSH
26531: LD_STRING D10BW-Joan-1
26533: PPUSH
26534: CALL_OW 94
// end ; if JMMGirl = 2 then
26538: LD_EXP 7
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: IFFALSE 26602
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26548: LD_ADDR_EXP 42
26552: PUSH
26553: LD_STRING Lisa
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_STRING 14_
26561: PPUSH
26562: CALL 65084 0 3
26566: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26567: LD_EXP 42
26571: PPUSH
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26590: LD_EXP 42
26594: PPUSH
26595: LD_STRING D10BW-Lisa-1
26597: PPUSH
26598: CALL_OW 94
// end ; if JMMGirl = 3 then
26602: LD_EXP 7
26606: PUSH
26607: LD_INT 3
26609: EQUAL
26610: IFFALSE 26666
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26612: LD_ADDR_EXP 54
26616: PUSH
26617: LD_STRING Connie
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_STRING 14_
26625: PPUSH
26626: CALL 65084 0 3
26630: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26631: LD_EXP 54
26635: PPUSH
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26654: LD_EXP 54
26658: PPUSH
26659: LD_STRING D10BW-Con-1
26661: PPUSH
26662: CALL_OW 94
// end ; end ;
26666: PPOPN 3
26668: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26669: LD_EXP 14
26673: PUSH
26674: LD_INT 94500
26676: GREATEREQUAL
26677: IFFALSE 27089
26679: GO 26681
26681: DISABLE
26682: LD_INT 0
26684: PPUSH
26685: PPUSH
26686: PPUSH
// begin tmp := PrepareStevensSquad ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: CALL 2197 0 0
26696: ST_TO_ADDR
// if not tmp then
26697: LD_VAR 0 3
26701: NOT
26702: IFFALSE 26706
// exit ;
26704: GO 27089
// uc_side := 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation := 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i in tmp do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_VAR 0 3
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26830
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26735: LD_INT 3
26737: PPUSH
26738: LD_INT 3
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: PPUSH
26761: LD_INT 3
26763: PPUSH
26764: CALL_OW 12
26768: ARRAY
26769: PPUSH
26770: LD_INT 40
26772: PPUSH
26773: CALL 69908 0 5
// veh := CreateVehicle ;
26777: LD_ADDR_VAR 0 2
26781: PUSH
26782: CALL_OW 45
26786: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26787: LD_VAR 0 2
26791: PPUSH
26792: LD_INT 1
26794: PPUSH
26795: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26799: LD_VAR 0 2
26803: PPUSH
26804: LD_INT 19
26806: PPUSH
26807: LD_INT 0
26809: PPUSH
26810: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26814: LD_VAR 0 1
26818: PPUSH
26819: LD_VAR 0 2
26823: PPUSH
26824: CALL_OW 52
// end ;
26828: GO 26732
26830: POP
26831: POP
// missionStage := 8 ;
26832: LD_ADDR_EXP 15
26836: PUSH
26837: LD_INT 8
26839: ST_TO_ADDR
// DialogueOn ;
26840: CALL_OW 6
// if Stevens then
26844: LD_EXP 41
26848: IFFALSE 26962
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26850: LD_EXP 41
26854: PPUSH
26855: CALL_OW 310
26859: PPUSH
26860: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26864: LD_EXP 41
26868: PPUSH
26869: LD_STRING D8-Huck-1
26871: PPUSH
26872: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26876: LD_EXP 39
26880: PPUSH
26881: LD_STRING D8-JMM-1
26883: PPUSH
26884: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26888: LD_EXP 41
26892: PPUSH
26893: LD_STRING D8-Huck-2
26895: PPUSH
26896: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26900: LD_EXP 39
26904: PPUSH
26905: LD_STRING D8-JMM-2
26907: PPUSH
26908: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26912: LD_EXP 41
26916: PPUSH
26917: LD_STRING D8-Huck-3
26919: PPUSH
26920: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26924: LD_EXP 39
26928: PPUSH
26929: LD_STRING D8-JMM-3
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26936: LD_EXP 41
26940: PPUSH
26941: LD_STRING D8-Huck-4
26943: PPUSH
26944: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26948: LD_EXP 39
26952: PPUSH
26953: LD_STRING D8-JMM-4
26955: PPUSH
26956: CALL_OW 88
// end else
26960: GO 27072
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26962: LD_EXP 55
26966: PPUSH
26967: CALL_OW 310
26971: PPUSH
26972: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26976: LD_EXP 55
26980: PPUSH
26981: LD_STRING D8-Huck-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D8-JMM-1a
26995: PPUSH
26996: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27000: LD_EXP 55
27004: PPUSH
27005: LD_STRING D8-Huck-2
27007: PPUSH
27008: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27012: LD_EXP 39
27016: PPUSH
27017: LD_STRING D8-JMM-2
27019: PPUSH
27020: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27024: LD_EXP 55
27028: PPUSH
27029: LD_STRING D8-Huck-3
27031: PPUSH
27032: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27036: LD_EXP 39
27040: PPUSH
27041: LD_STRING D8-JMM-3
27043: PPUSH
27044: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27048: LD_EXP 55
27052: PPUSH
27053: LD_STRING D8-Huck-4
27055: PPUSH
27056: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27060: LD_EXP 39
27064: PPUSH
27065: LD_STRING D8-JMM-4
27067: PPUSH
27068: CALL_OW 88
// end ; DialogueOff ;
27072: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27076: LD_INT 25
27078: PPUSH
27079: LD_INT 1
27081: PPUSH
27082: LD_INT 1
27084: PPUSH
27085: CALL_OW 322
// end ;
27089: PPOPN 3
27091: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27092: LD_INT 1
27094: PPUSH
27095: LD_EXP 71
27099: PPUSH
27100: CALL_OW 292
27104: IFFALSE 27355
27106: GO 27108
27108: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27109: LD_EXP 71
27113: PPUSH
27114: CALL_OW 87
// DialogueOn ;
27118: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-1
27129: PPUSH
27130: CALL_OW 88
// if BurlakStatus = 1 then
27134: LD_EXP 9
27138: PUSH
27139: LD_INT 1
27141: EQUAL
27142: IFFALSE 27156
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-1a
27151: PPUSH
27152: CALL_OW 94
// end ; if BurlakStatus = 0 then
27156: LD_EXP 9
27160: PUSH
27161: LD_INT 0
27163: EQUAL
27164: IFFALSE 27178
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27166: LD_EXP 70
27170: PPUSH
27171: LD_STRING D10nB-Vse-1
27173: PPUSH
27174: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27178: LD_EXP 39
27182: PPUSH
27183: LD_STRING D10nB-JMM-2
27185: PPUSH
27186: CALL_OW 88
// if KappaStatus then
27190: LD_EXP 2
27194: IFFALSE 27208
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27196: LD_EXP 70
27200: PPUSH
27201: LD_STRING D10nB-Vse-5a
27203: PPUSH
27204: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27208: LD_EXP 2
27212: NOT
27213: PUSH
27214: LD_EXP 6
27218: PUSH
27219: LD_INT 0
27221: EQUAL
27222: AND
27223: IFFALSE 27351
// begin if JMMGirl = 1 then
27225: LD_EXP 7
27229: PUSH
27230: LD_INT 1
27232: EQUAL
27233: IFFALSE 27283
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27235: LD_EXP 70
27239: PPUSH
27240: LD_STRING D10nB-Vse-2
27242: PPUSH
27243: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27259: LD_EXP 70
27263: PPUSH
27264: LD_STRING D10nB-Vse-3
27266: PPUSH
27267: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27271: LD_EXP 39
27275: PPUSH
27276: LD_STRING D10nB-JMM-4
27278: PPUSH
27279: CALL_OW 88
// end ; if JMMGirl = 2 then
27283: LD_EXP 7
27287: PUSH
27288: LD_INT 2
27290: EQUAL
27291: IFFALSE 27317
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27293: LD_EXP 70
27297: PPUSH
27298: LD_STRING D10nB-Vse-4
27300: PPUSH
27301: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27305: LD_EXP 39
27309: PPUSH
27310: LD_STRING D10nB-JMM-5
27312: PPUSH
27313: CALL_OW 88
// end ; if JMMGirl = 3 then
27317: LD_EXP 7
27321: PUSH
27322: LD_INT 3
27324: EQUAL
27325: IFFALSE 27351
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27327: LD_EXP 70
27331: PPUSH
27332: LD_STRING D10nB-Vse-5
27334: PPUSH
27335: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27339: LD_EXP 39
27343: PPUSH
27344: LD_STRING D10nB-JMM-6
27346: PPUSH
27347: CALL_OW 88
// end ; end ; DialogueOff ;
27351: CALL_OW 7
// end ;
27355: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27356: LD_EXP 14
27360: PUSH
27361: LD_INT 115500
27363: GREATEREQUAL
27364: IFFALSE 27740
27366: GO 27368
27368: DISABLE
27369: LD_INT 0
27371: PPUSH
// begin missionStage := 10 ;
27372: LD_ADDR_EXP 15
27376: PUSH
27377: LD_INT 10
27379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27380: LD_ADDR_VAR 0 1
27384: PUSH
27385: LD_INT 22
27387: PUSH
27388: LD_INT 1
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 23
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 26
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 25
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 3
27434: PUSH
27435: LD_INT 25
27437: PUSH
27438: LD_INT 16
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PPUSH
27456: CALL_OW 69
27460: PUSH
27461: LD_EXP 39
27465: PUSH
27466: LD_EXP 60
27470: PUSH
27471: LD_EXP 41
27475: PUSH
27476: LD_EXP 55
27480: PUSH
27481: LD_EXP 42
27485: PUSH
27486: LD_EXP 43
27490: PUSH
27491: LD_EXP 44
27495: PUSH
27496: LD_EXP 45
27500: PUSH
27501: LD_EXP 46
27505: PUSH
27506: LD_EXP 47
27510: PUSH
27511: LD_EXP 48
27515: PUSH
27516: LD_EXP 49
27520: PUSH
27521: LD_EXP 50
27525: PUSH
27526: LD_EXP 51
27530: PUSH
27531: LD_EXP 52
27535: PUSH
27536: LD_EXP 53
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// if not tmp and Brown then
27560: LD_VAR 0 1
27564: NOT
27565: PUSH
27566: LD_EXP 47
27570: AND
27571: IFFALSE 27586
// tmp := [ Brown ] ;
27573: LD_ADDR_VAR 0 1
27577: PUSH
27578: LD_EXP 47
27582: PUSH
27583: EMPTY
27584: LIST
27585: ST_TO_ADDR
// DialogueOn ;
27586: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27590: LD_VAR 0 1
27594: PUSH
27595: LD_INT 1
27597: ARRAY
27598: PPUSH
27599: LD_STRING D11-Sol1-1
27601: PPUSH
27602: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27606: LD_EXP 64
27610: PPUSH
27611: LD_STRING D11-Pla-1
27613: PPUSH
27614: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27618: LD_EXP 65
27622: PPUSH
27623: LD_STRING D11-Kov-1
27625: PPUSH
27626: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27630: LD_EXP 64
27634: PPUSH
27635: LD_STRING D11-Pla-2
27637: PPUSH
27638: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27642: LD_VAR 0 1
27646: PUSH
27647: LD_INT 1
27649: ARRAY
27650: PPUSH
27651: LD_STRING D11-Sol1-2
27653: PPUSH
27654: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27658: LD_EXP 39
27662: PPUSH
27663: LD_STRING D11-JMM-2
27665: PPUSH
27666: CALL_OW 88
// DialogueOff ;
27670: CALL_OW 7
// allowBehemothConstruct := true ;
27674: LD_ADDR_EXP 25
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27682: LD_STRING M4
27684: PPUSH
27685: CALL_OW 337
// BuildBehemoths ;
27689: CALL 7668 0 0
// repeat wait ( 15 15$00 ) ;
27693: LD_INT 31500
27695: PPUSH
27696: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27700: LD_EXP 27
27704: IFFALSE 27708
// break ;
27706: GO 27740
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27708: LD_INT 267
27710: PPUSH
27711: CALL_OW 274
27715: PPUSH
27716: LD_INT 1
27718: PPUSH
27719: CALL_OW 275
27723: PUSH
27724: LD_INT 1000
27726: GREATEREQUAL
27727: IFFALSE 27733
// BuildBehemoths ;
27729: CALL 7668 0 0
// until not behemothBuilders ;
27733: LD_EXP 73
27737: NOT
27738: IFFALSE 27693
// end ;
27740: PPOPN 1
27742: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27743: LD_EXP 73
27747: NOT
27748: PUSH
27749: LD_EXP 28
27753: NOT
27754: AND
27755: PUSH
27756: LD_EXP 25
27760: AND
27761: IFFALSE 27781
27763: GO 27765
27765: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27766: LD_STRING M4a
27768: PPUSH
27769: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27773: LD_ADDR_EXP 27
27777: PUSH
27778: LD_INT 1
27780: ST_TO_ADDR
// end ;
27781: END
// every 0 0$1 trigger behemothDone do
27782: LD_EXP 28
27786: IFFALSE 27798
27788: GO 27790
27790: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27791: LD_STRING M4b
27793: PPUSH
27794: CALL_OW 337
27798: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27799: LD_EXP 29
27803: NOT
27804: IFFALSE 28000
27806: GO 27808
27808: DISABLE
27809: LD_INT 0
27811: PPUSH
27812: PPUSH
// begin enable ;
27813: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27814: LD_ADDR_VAR 0 1
27818: PUSH
27819: LD_INT 3
27821: PPUSH
27822: CALL 101002 0 1
27826: ST_TO_ADDR
// if not tmp and not behemothDone then
27827: LD_VAR 0 1
27831: NOT
27832: PUSH
27833: LD_EXP 28
27837: NOT
27838: AND
27839: IFFALSE 27875
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27841: LD_ADDR_VAR 0 1
27845: PUSH
27846: LD_INT 22
27848: PUSH
27849: LD_INT 3
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 37
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: ST_TO_ADDR
// if not tmp then
27875: LD_VAR 0 1
27879: NOT
27880: IFFALSE 27884
// exit ;
27882: GO 28000
// for i in tmp do
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: FOR_IN
27895: IFFALSE 27998
// if See ( 1 , i ) then
27897: LD_INT 1
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: CALL_OW 292
27909: IFFALSE 27996
// begin if GetType ( i ) = unit_building then
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 247
27920: PUSH
27921: LD_INT 3
27923: EQUAL
27924: IFFALSE 27962
// begin CenterNowOnUnits ( i ) ;
27926: LD_VAR 0 2
27930: PPUSH
27931: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27935: LD_EXP 39
27939: PPUSH
27940: LD_STRING D17a-JMM-1
27942: PPUSH
27943: CALL_OW 88
// seeBehemoth := true ;
27947: LD_ADDR_EXP 29
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// disable ;
27955: DISABLE
// exit ;
27956: POP
27957: POP
27958: GO 28000
// end else
27960: GO 27996
// begin CenterNowOnUnits ( i ) ;
27962: LD_VAR 0 2
27966: PPUSH
27967: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27971: LD_EXP 39
27975: PPUSH
27976: LD_STRING D17b-JMM-1
27978: PPUSH
27979: CALL_OW 88
// seeBehemoth := true ;
27983: LD_ADDR_EXP 29
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// disable ;
27991: DISABLE
// exit ;
27992: POP
27993: POP
27994: GO 28000
// end ; end ;
27996: GO 27894
27998: POP
27999: POP
// end ;
28000: PPOPN 2
28002: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28003: LD_EXP 14
28007: PUSH
28008: LD_INT 123200
28010: GREATEREQUAL
28011: IFFALSE 29187
28013: GO 28015
28015: DISABLE
28016: LD_INT 0
28018: PPUSH
28019: PPUSH
28020: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28021: LD_INT 2
28023: PPUSH
28024: LD_INT 23
28026: PUSH
28027: LD_INT 3
28029: PUSH
28030: LD_INT 3
28032: PUSH
28033: LD_INT 48
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: EMPTY
28043: LIST
28044: PPUSH
28045: CALL 58740 0 2
// repeat wait ( 0 0$1 ) ;
28049: LD_INT 35
28051: PPUSH
28052: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28056: LD_INT 22
28058: PUSH
28059: LD_INT 3
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 34
28068: PUSH
28069: LD_INT 48
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 69
28084: IFFALSE 28049
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28086: LD_ADDR_VAR 0 1
28090: PUSH
28091: LD_INT 22
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 48
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: ST_TO_ADDR
// missionStage := 12 ;
28124: LD_ADDR_EXP 15
28128: PUSH
28129: LD_INT 12
28131: ST_TO_ADDR
// platonovHasBomb := true ;
28132: LD_ADDR_EXP 30
28136: PUSH
28137: LD_INT 1
28139: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 181
28147: PPUSH
28148: LD_INT 86
28150: PPUSH
28151: CALL_OW 171
// AddComHold ( bomb ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 200
// wait ( 0 0$10 ) ;
28164: LD_INT 350
28166: PPUSH
28167: CALL_OW 67
// DialogueOn ;
28171: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28175: LD_EXP 64
28179: PPUSH
28180: LD_STRING D15-Pla-1
28182: PPUSH
28183: CALL_OW 94
// dec = Query ( Q15a ) ;
28187: LD_ADDR_VAR 0 2
28191: PUSH
28192: LD_STRING Q15a
28194: PPUSH
28195: CALL_OW 97
28199: ST_TO_ADDR
// if dec = 1 then
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28231
// begin Say ( JMM , D15a-JMM-1 ) ;
28210: LD_EXP 39
28214: PPUSH
28215: LD_STRING D15a-JMM-1
28217: PPUSH
28218: CALL_OW 88
// YouLost ( Surrender ) ;
28222: LD_STRING Surrender
28224: PPUSH
28225: CALL_OW 104
// exit ;
28229: GO 29187
// end ; if dec = 2 then
28231: LD_VAR 0 2
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28308
// begin Say ( JMM , D15b-JMM-1 ) ;
28241: LD_EXP 39
28245: PPUSH
28246: LD_STRING D15b-JMM-1
28248: PPUSH
28249: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28253: LD_EXP 64
28257: PPUSH
28258: LD_STRING D15b-Pla-1
28260: PPUSH
28261: CALL_OW 94
// DialogueOff ;
28265: CALL_OW 7
// wait ( 3 3$00 ) ;
28269: LD_INT 6300
28271: PPUSH
28272: CALL_OW 67
// DialogueOn ;
28276: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28280: LD_EXP 39
28284: PPUSH
28285: LD_STRING D15d-JMM-1a
28287: PPUSH
28288: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28292: LD_EXP 64
28296: PPUSH
28297: LD_STRING D15d-Pla-1
28299: PPUSH
28300: CALL_OW 94
// DialogueOff ;
28304: CALL_OW 7
// end ; if dec = 3 then
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 3
28315: EQUAL
28316: IFFALSE 28370
// begin Say ( JMM , D15c-JMM-1 ) ;
28318: LD_EXP 39
28322: PPUSH
28323: LD_STRING D15c-JMM-1
28325: PPUSH
28326: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28330: LD_EXP 64
28334: PPUSH
28335: LD_STRING D15c-Pla-1
28337: PPUSH
28338: CALL_OW 94
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$15 ) ;
28346: LD_INT 525
28348: PPUSH
28349: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28353: LD_VAR 0 1
28357: PPUSH
28358: LD_INT 60
28360: PPUSH
28361: LD_INT 95
28363: PPUSH
28364: CALL_OW 116
// exit ;
28368: GO 29187
// end ; if dec = 4 then
28370: LD_VAR 0 2
28374: PUSH
28375: LD_INT 4
28377: EQUAL
28378: IFFALSE 28408
// begin Say ( JMM , D15d-JMM-1 ) ;
28380: LD_EXP 39
28384: PPUSH
28385: LD_STRING D15d-JMM-1
28387: PPUSH
28388: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28392: LD_EXP 64
28396: PPUSH
28397: LD_STRING D15d-Pla-1
28399: PPUSH
28400: CALL_OW 94
// DialogueOff ;
28404: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28408: LD_EXP 62
28412: PPUSH
28413: CALL_OW 302
28417: PUSH
28418: LD_EXP 62
28422: PPUSH
28423: CALL_OW 255
28427: PUSH
28428: LD_INT 1
28430: EQUAL
28431: AND
28432: PUSH
28433: LD_INT 22
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 34
28445: PUSH
28446: LD_INT 8
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PPUSH
28457: CALL_OW 69
28461: NOT
28462: AND
28463: IFFALSE 29088
// begin SetSide ( Friend , 8 ) ;
28465: LD_EXP 62
28469: PPUSH
28470: LD_INT 8
28472: PPUSH
28473: CALL_OW 235
// if IsInUnit ( Friend ) then
28477: LD_EXP 62
28481: PPUSH
28482: CALL_OW 310
28486: IFFALSE 28497
// ComExitBuilding ( Friend ) ;
28488: LD_EXP 62
28492: PPUSH
28493: CALL_OW 122
// if IsDriver ( Friend ) then
28497: LD_EXP 62
28501: PPUSH
28502: CALL 98679 0 1
28506: IFFALSE 28517
// ComExitVehicle ( Friend ) ;
28508: LD_EXP 62
28512: PPUSH
28513: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28517: LD_EXP 62
28521: PPUSH
28522: LD_INT 9
28524: PPUSH
28525: LD_INT 2
28527: PPUSH
28528: CALL_OW 171
// wait ( 0 0$05 ) ;
28532: LD_INT 175
28534: PPUSH
28535: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28539: LD_EXP 62
28543: PPUSH
28544: CALL_OW 87
// DialogueOn ;
28548: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28552: LD_EXP 39
28556: PPUSH
28557: LD_STRING D16-JMM-1
28559: PPUSH
28560: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28564: LD_EXP 62
28568: PPUSH
28569: LD_STRING D16-Friend-1
28571: PPUSH
28572: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28576: LD_EXP 39
28580: PPUSH
28581: LD_STRING D16-JMM-2
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28592: LD_EXP 62
28596: PPUSH
28597: LD_INT 1
28599: PPUSH
28600: CALL_OW 235
// ComHold ( Friend ) ;
28604: LD_EXP 62
28608: PPUSH
28609: CALL_OW 140
// wait ( 0 0$20 ) ;
28613: LD_INT 700
28615: PPUSH
28616: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28620: LD_EXP 62
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 297
28635: PUSH
28636: LD_INT 30
28638: LESS
28639: IFFALSE 28708
// begin SetSide ( Friend , 8 ) ;
28641: LD_EXP 62
28645: PPUSH
28646: LD_INT 8
28648: PPUSH
28649: CALL_OW 235
// if IsInUnit ( Friend ) then
28653: LD_EXP 62
28657: PPUSH
28658: CALL_OW 310
28662: IFFALSE 28673
// ComExitBuilding ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 122
// if IsDriver ( Friend ) then
28673: LD_EXP 62
28677: PPUSH
28678: CALL 98679 0 1
28682: IFFALSE 28693
// ComExitVehicle ( Friend ) ;
28684: LD_EXP 62
28688: PPUSH
28689: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28693: LD_EXP 62
28697: PPUSH
28698: LD_INT 9
28700: PPUSH
28701: LD_INT 2
28703: PPUSH
28704: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28708: LD_INT 1050
28710: PPUSH
28711: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28715: LD_INT 22
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 34
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: NOT
28744: IFFALSE 29066
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28746: LD_ADDR_VAR 0 3
28750: PUSH
28751: LD_INT 22
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 26
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: PUSH
28774: LD_INT 25
28776: PUSH
28777: LD_INT 12
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 25
28786: PUSH
28787: LD_INT 16
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PPUSH
28804: CALL_OW 69
28808: PUSH
28809: LD_EXP 39
28813: PUSH
28814: LD_EXP 41
28818: PUSH
28819: LD_EXP 55
28823: PUSH
28824: LD_EXP 42
28828: PUSH
28829: LD_EXP 43
28833: PUSH
28834: LD_EXP 44
28838: PUSH
28839: LD_EXP 45
28843: PUSH
28844: LD_EXP 46
28848: PUSH
28849: LD_EXP 47
28853: PUSH
28854: LD_EXP 48
28858: PUSH
28859: LD_EXP 49
28863: PUSH
28864: LD_EXP 50
28868: PUSH
28869: LD_EXP 51
28873: PUSH
28874: LD_EXP 52
28878: PUSH
28879: LD_EXP 53
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: DIFF
28901: ST_TO_ADDR
// DialogueOn ;
28902: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28906: LD_EXP 64
28910: PPUSH
28911: LD_STRING D16a-Pla-1
28913: PPUSH
28914: CALL_OW 94
// if Stevens then
28918: LD_EXP 41
28922: IFFALSE 28938
// Say ( Stevens , D16a-Huck-1 ) else
28924: LD_EXP 41
28928: PPUSH
28929: LD_STRING D16a-Huck-1
28931: PPUSH
28932: CALL_OW 88
28936: GO 28980
// if Baker then
28938: LD_EXP 55
28942: IFFALSE 28958
// Say ( Baker , D16a-Huck-1 ) else
28944: LD_EXP 55
28948: PPUSH
28949: LD_STRING D16a-Huck-1
28951: PPUSH
28952: CALL_OW 88
28956: GO 28980
// if tmp then
28958: LD_VAR 0 3
28962: IFFALSE 28980
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28964: LD_VAR 0 3
28968: PUSH
28969: LD_INT 1
28971: ARRAY
28972: PPUSH
28973: LD_STRING D16a-Sol1-1
28975: PPUSH
28976: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28980: LD_EXP 62
28984: PPUSH
28985: CALL_OW 255
28989: PUSH
28990: LD_INT 8
28992: EQUAL
28993: IFFALSE 29009
// Say ( JMM , D16a-JMM-1 ) else
28995: LD_EXP 39
28999: PPUSH
29000: LD_STRING D16a-JMM-1
29002: PPUSH
29003: CALL_OW 88
29007: GO 29045
// begin Say ( JMM , D16a-JMM-1a ) ;
29009: LD_EXP 39
29013: PPUSH
29014: LD_STRING D16a-JMM-1a
29016: PPUSH
29017: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29021: LD_EXP 62
29025: PPUSH
29026: LD_STRING D16a-Friend-1
29028: PPUSH
29029: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29033: LD_EXP 62
29037: PPUSH
29038: LD_INT 3
29040: PPUSH
29041: CALL_OW 235
// end ; DialogueOff ;
29045: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29049: LD_VAR 0 1
29053: PPUSH
29054: LD_INT 60
29056: PPUSH
29057: LD_INT 95
29059: PPUSH
29060: CALL_OW 116
// end else
29064: GO 29086
// begin DialogueOn ;
29066: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29070: LD_EXP 64
29074: PPUSH
29075: LD_STRING D16c-Pla-
29077: PPUSH
29078: CALL_OW 94
// DialogueOff ;
29082: CALL_OW 7
// end ; end else
29086: GO 29187
// begin wait ( 3 3$00 ) ;
29088: LD_INT 6300
29090: PPUSH
29091: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29095: LD_INT 22
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 34
29107: PUSH
29108: LD_INT 8
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: CALL_OW 69
29123: NOT
29124: IFFALSE 29167
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29126: LD_EXP 64
29130: PPUSH
29131: LD_STRING D16b-Pla-1
29133: PPUSH
29134: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29138: LD_EXP 39
29142: PPUSH
29143: LD_STRING D16b-JMM-
29145: PPUSH
29146: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29150: LD_VAR 0 1
29154: PPUSH
29155: LD_INT 60
29157: PPUSH
29158: LD_INT 95
29160: PPUSH
29161: CALL_OW 116
// end else
29165: GO 29187
// begin DialogueOn ;
29167: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D16c-Pla-
29178: PPUSH
29179: CALL_OW 94
// DialogueOff ;
29183: CALL_OW 7
// end ; end ; end ;
29187: PPOPN 3
29189: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29190: LD_EXP 14
29194: PUSH
29195: LD_INT 126000
29197: GREATEREQUAL
29198: PUSH
29199: LD_EXP 23
29203: NOT
29204: AND
29205: PUSH
29206: LD_EXP 74
29210: PPUSH
29211: CALL_OW 302
29215: AND
29216: IFFALSE 29574
29218: GO 29220
29220: DISABLE
29221: LD_INT 0
29223: PPUSH
// begin missionStage = 11 ;
29224: LD_ADDR_EXP 15
29228: PUSH
29229: LD_INT 11
29231: ST_TO_ADDR
// DialogueOn ;
29232: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9-Roth-1
29243: PPUSH
29244: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29248: LD_EXP 39
29252: PPUSH
29253: LD_STRING D9-JMM-1
29255: PPUSH
29256: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29260: LD_EXP 74
29264: PPUSH
29265: LD_STRING D9-Roth-2
29267: PPUSH
29268: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29272: LD_EXP 74
29276: PPUSH
29277: LD_STRING D9-Roth-2a
29279: PPUSH
29280: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29284: LD_EXP 64
29288: PPUSH
29289: LD_STRING D9-Pla-2
29291: PPUSH
29292: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29296: LD_EXP 74
29300: PPUSH
29301: LD_STRING D9-Roth-3
29303: PPUSH
29304: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29308: LD_EXP 64
29312: PPUSH
29313: LD_STRING D9-Pla-3
29315: PPUSH
29316: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29320: LD_EXP 74
29324: PPUSH
29325: LD_STRING D9-Roth-4
29327: PPUSH
29328: CALL_OW 94
// dec = Query ( Q9 ) ;
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_STRING Q9
29339: PPUSH
29340: CALL_OW 97
29344: ST_TO_ADDR
// if dec = 1 then
29345: LD_VAR 0 1
29349: PUSH
29350: LD_INT 1
29352: EQUAL
29353: IFFALSE 29367
// SayRadio ( Roth , D9a-Roth-1 ) ;
29355: LD_EXP 74
29359: PPUSH
29360: LD_STRING D9a-Roth-1
29362: PPUSH
29363: CALL_OW 94
// if dec = 2 then
29367: LD_VAR 0 1
29371: PUSH
29372: LD_INT 2
29374: EQUAL
29375: IFFALSE 29401
// begin Say ( JMM , D9b-JMM-1 ) ;
29377: LD_EXP 39
29381: PPUSH
29382: LD_STRING D9b-JMM-1
29384: PPUSH
29385: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9b-Roth-1
29396: PPUSH
29397: CALL_OW 94
// end ; if dec = 3 then
29401: LD_VAR 0 1
29405: PUSH
29406: LD_INT 3
29408: EQUAL
29409: IFFALSE 29471
// begin Say ( JMM , D9c-JMM-1 ) ;
29411: LD_EXP 39
29415: PPUSH
29416: LD_STRING D9c-JMM-1
29418: PPUSH
29419: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29423: LD_EXP 74
29427: PPUSH
29428: LD_STRING D9c-Roth-1
29430: PPUSH
29431: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29435: LD_EXP 39
29439: PPUSH
29440: LD_STRING D9c-JMM-2
29442: PPUSH
29443: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29447: LD_EXP 74
29451: PPUSH
29452: LD_STRING D9c-Roth-2
29454: PPUSH
29455: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29459: LD_EXP 39
29463: PPUSH
29464: LD_STRING D9c-JMM-3
29466: PPUSH
29467: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29471: LD_EXP 74
29475: PPUSH
29476: LD_STRING D9c-Roth-3
29478: PPUSH
29479: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29483: LD_EXP 74
29487: PPUSH
29488: LD_STRING D9cont-Roth-1
29490: PPUSH
29491: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29495: LD_EXP 39
29499: PPUSH
29500: LD_STRING D9cont-JMM-1
29502: PPUSH
29503: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29507: LD_EXP 74
29511: PPUSH
29512: LD_STRING D9cont-Roth-2
29514: PPUSH
29515: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29519: LD_EXP 39
29523: PPUSH
29524: LD_STRING D9cont-JMM-2
29526: PPUSH
29527: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29531: LD_EXP 74
29535: PPUSH
29536: LD_STRING D9cont-Roth-3
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29543: LD_EXP 39
29547: PPUSH
29548: LD_STRING D9cont-JMM-3
29550: PPUSH
29551: CALL_OW 88
// DialogueOff ;
29555: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29559: LD_STRING M3
29561: PPUSH
29562: CALL_OW 337
// allianceActive := true ;
29566: LD_ADDR_EXP 31
29570: PUSH
29571: LD_INT 1
29573: ST_TO_ADDR
// end ;
29574: PPOPN 1
29576: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29577: LD_INT 1
29579: PPUSH
29580: LD_INT 126
29582: PPUSH
29583: CALL_OW 292
29587: PUSH
29588: LD_EXP 64
29592: PPUSH
29593: CALL_OW 310
29597: AND
29598: IFFALSE 29678
29600: GO 29602
29602: DISABLE
29603: LD_INT 0
29605: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29606: LD_EXP 64
29610: PPUSH
29611: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 4
29622: PPUSH
29623: LD_INT 22
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 70
29637: PPUSH
29638: LD_EXP 64
29642: PPUSH
29643: CALL_OW 74
29647: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29648: LD_EXP 64
29652: PPUSH
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 1
29660: ARRAY
29661: PPUSH
29662: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29666: LD_EXP 64
29670: PPUSH
29671: LD_STRING D18-Pla-1
29673: PPUSH
29674: CALL_OW 88
// end ;
29678: PPOPN 1
29680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29681: LD_EXP 64
29685: PPUSH
29686: CALL_OW 301
29690: PUSH
29691: LD_EXP 67
29695: PPUSH
29696: CALL_OW 301
29700: AND
29701: PUSH
29702: LD_INT 22
29704: PUSH
29705: LD_INT 3
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 21
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 50
29724: PUSH
29725: EMPTY
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PUSH
29738: LD_INT 7
29740: PUSH
29741: LD_INT 8
29743: PUSH
29744: LD_INT 9
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_OWVAR 67
29756: ARRAY
29757: LESS
29758: AND
29759: IFFALSE 30530
29761: GO 29763
29763: DISABLE
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
// begin MC_Kill ( 1 ) ;
29770: LD_INT 1
29772: PPUSH
29773: CALL 35296 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29777: LD_INT 1
29779: PPUSH
29780: LD_INT 3
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: LD_INT 1
29788: PPUSH
29789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29793: LD_ADDR_VAR 0 1
29797: PUSH
29798: LD_INT 22
29800: PUSH
29801: LD_INT 3
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 21
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 24
29820: PUSH
29821: LD_INT 900
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 69
29837: PUSH
29838: FOR_IN
29839: IFFALSE 29870
// if GetSex ( i ) = sex_male then
29841: LD_VAR 0 1
29845: PPUSH
29846: CALL_OW 258
29850: PUSH
29851: LD_INT 1
29853: EQUAL
29854: IFFALSE 29868
// begin tmp = i ;
29856: LD_ADDR_VAR 0 2
29860: PUSH
29861: LD_VAR 0 1
29865: ST_TO_ADDR
// break ;
29866: GO 29870
// end ;
29868: GO 29838
29870: POP
29871: POP
// if tmp = 0 then
29872: LD_VAR 0 2
29876: PUSH
29877: LD_INT 0
29879: EQUAL
29880: IFFALSE 29934
// begin uc_side = 3 ;
29882: LD_ADDR_OWVAR 20
29886: PUSH
29887: LD_INT 3
29889: ST_TO_ADDR
// uc_nation = 3 ;
29890: LD_ADDR_OWVAR 21
29894: PUSH
29895: LD_INT 3
29897: ST_TO_ADDR
// hc_name =  ;
29898: LD_ADDR_OWVAR 26
29902: PUSH
29903: LD_STRING 
29905: ST_TO_ADDR
// hc_gallery =  ;
29906: LD_ADDR_OWVAR 33
29910: PUSH
29911: LD_STRING 
29913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 10
29919: PPUSH
29920: CALL_OW 381
// tmp = CreateHuman ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: CALL_OW 44
29933: ST_TO_ADDR
// end ; DialogueOn ;
29934: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_STRING DSurrenderRussians-RSol1-1a
29945: PPUSH
29946: CALL_OW 94
// DialogueOff ;
29950: CALL_OW 7
// russianDestroyed := true ;
29954: LD_ADDR_EXP 21
29958: PUSH
29959: LD_INT 1
29961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29962: LD_INT 22
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 21
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PPUSH
29986: CALL_OW 69
29990: PPUSH
29991: CALL_OW 122
// wait ( 0 0$1 ) ;
29995: LD_INT 35
29997: PPUSH
29998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30002: LD_INT 22
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 21
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 69
30030: PPUSH
30031: LD_INT 25
30033: PPUSH
30034: CALL_OW 173
// wait ( 0 0$10 ) ;
30038: LD_INT 350
30040: PPUSH
30041: CALL_OW 67
// PrepareOmarInvasion ;
30045: CALL 13878 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30049: LD_ADDR_VAR 0 2
30053: PUSH
30054: LD_EXP 92
30058: PPUSH
30059: CALL_OW 250
30063: PUSH
30064: LD_EXP 92
30068: PPUSH
30069: CALL_OW 251
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30078: LD_VAR 0 2
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: LD_VAR 0 2
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: PPUSH
30096: LD_INT 1
30098: PPUSH
30099: LD_INT 8
30101: NEG
30102: PPUSH
30103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30107: LD_EXP 92
30111: PPUSH
30112: CALL_OW 87
// DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30120: LD_EXP 39
30124: PPUSH
30125: LD_STRING D19-JMM-1
30127: PPUSH
30128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30132: LD_ADDR_VAR 0 3
30136: PUSH
30137: LD_INT 22
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 26
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 2
30159: PUSH
30160: LD_INT 25
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 25
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 25
30182: PUSH
30183: LD_INT 3
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 25
30192: PUSH
30193: LD_INT 4
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 25
30202: PUSH
30203: LD_INT 5
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 25
30212: PUSH
30213: LD_INT 8
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 69
30238: PUSH
30239: LD_EXP 39
30243: PUSH
30244: LD_EXP 40
30248: PUSH
30249: LD_EXP 41
30253: PUSH
30254: LD_EXP 42
30258: PUSH
30259: LD_EXP 43
30263: PUSH
30264: LD_EXP 44
30268: PUSH
30269: LD_EXP 45
30273: PUSH
30274: LD_EXP 46
30278: PUSH
30279: LD_EXP 47
30283: PUSH
30284: LD_EXP 48
30288: PUSH
30289: LD_EXP 49
30293: PUSH
30294: LD_EXP 50
30298: PUSH
30299: LD_EXP 51
30303: PUSH
30304: LD_EXP 52
30308: PUSH
30309: LD_EXP 53
30313: PUSH
30314: LD_EXP 54
30318: PUSH
30319: LD_EXP 55
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: DIFF
30343: ST_TO_ADDR
// if tmp2 then
30344: LD_VAR 0 3
30348: IFFALSE 30366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30350: LD_VAR 0 3
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: LD_STRING D19-Sol1-1
30361: PPUSH
30362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30366: LD_EXP 39
30370: PPUSH
30371: LD_STRING D19-JMM-2
30373: PPUSH
30374: CALL_OW 88
// DialogueOff ;
30378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30382: LD_VAR 0 2
30386: PUSH
30387: LD_INT 1
30389: ARRAY
30390: PPUSH
30391: LD_VAR 0 2
30395: PUSH
30396: LD_INT 2
30398: ARRAY
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30407: LD_STRING M5
30409: PPUSH
30410: CALL_OW 337
// omarOnMotherLode := false ;
30414: LD_ADDR_VAR 0 4
30418: PUSH
30419: LD_INT 0
30421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30422: LD_INT 35
30424: PPUSH
30425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30429: LD_EXP 92
30433: PPUSH
30434: LD_INT 215
30436: PPUSH
30437: LD_INT 100
30439: PPUSH
30440: CALL_OW 297
30444: PUSH
30445: LD_INT 10
30447: LESS
30448: PUSH
30449: LD_VAR 0 4
30453: NOT
30454: AND
30455: IFFALSE 30489
// begin omarOnMotherLode := true ;
30457: LD_ADDR_VAR 0 4
30461: PUSH
30462: LD_INT 1
30464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30465: LD_EXP 39
30469: PPUSH
30470: LD_STRING D19b-JMM-1
30472: PPUSH
30473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30477: LD_EXP 92
30481: PPUSH
30482: LD_STRING DOmarContam-Omar-1
30484: PPUSH
30485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30489: LD_EXP 92
30493: PPUSH
30494: CALL_OW 301
30498: IFFALSE 30422
// Say ( JMM , D19a-JMM-1 ) ;
30500: LD_EXP 39
30504: PPUSH
30505: LD_STRING D19a-JMM-1
30507: PPUSH
30508: CALL_OW 88
// if Heike then
30512: LD_EXP 93
30516: IFFALSE 30530
// Say ( Heike , D19a-Hke-1 ) ;
30518: LD_EXP 93
30522: PPUSH
30523: LD_STRING D19a-Hke-1
30525: PPUSH
30526: CALL_OW 88
// end ;
30530: PPOPN 4
30532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30533: LD_INT 22
30535: PUSH
30536: LD_INT 3
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 21
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 69
30561: PUSH
30562: LD_EXP 21
30566: AND
30567: IFFALSE 30635
30569: GO 30571
30571: DISABLE
30572: LD_INT 0
30574: PPUSH
30575: PPUSH
// begin enable ;
30576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_INT 25
30584: PPUSH
30585: LD_INT 22
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 70
30599: ST_TO_ADDR
// if not tmp then
30600: LD_VAR 0 2
30604: NOT
30605: IFFALSE 30609
// exit ;
30607: GO 30635
// for i in tmp do
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_VAR 0 2
30618: PUSH
30619: FOR_IN
30620: IFFALSE 30633
// RemoveUnit ( i ) ;
30622: LD_VAR 0 1
30626: PPUSH
30627: CALL_OW 64
30631: GO 30619
30633: POP
30634: POP
// end ;
30635: PPOPN 2
30637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30638: LD_INT 22
30640: PUSH
30641: LD_INT 7
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 21
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 69
30666: PUSH
30667: LD_INT 6
30669: LESS
30670: IFFALSE 31138
30672: GO 30674
30674: DISABLE
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
// begin MC_Kill ( 1 ) ;
30679: LD_INT 1
30681: PPUSH
30682: CALL 35296 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30686: LD_INT 7
30688: PPUSH
30689: LD_INT 1
30691: PPUSH
30692: LD_INT 1
30694: PPUSH
30695: LD_INT 1
30697: PPUSH
30698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30702: LD_ADDR_VAR 0 1
30706: PUSH
30707: LD_INT 22
30709: PUSH
30710: LD_INT 7
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 26
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 69
30735: PUSH
30736: LD_EXP 74
30740: DIFF
30741: ST_TO_ADDR
// if tmp then
30742: LD_VAR 0 1
30746: IFFALSE 30764
// tmp := tmp [ 1 ] else
30748: LD_ADDR_VAR 0 1
30752: PUSH
30753: LD_VAR 0 1
30757: PUSH
30758: LD_INT 1
30760: ARRAY
30761: ST_TO_ADDR
30762: GO 30800
// begin uc_side := 7 ;
30764: LD_ADDR_OWVAR 20
30768: PUSH
30769: LD_INT 7
30771: ST_TO_ADDR
// uc_nation := 1 ;
30772: LD_ADDR_OWVAR 21
30776: PUSH
30777: LD_INT 1
30779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30780: LD_INT 1
30782: PPUSH
30783: LD_INT 8
30785: PPUSH
30786: CALL_OW 384
// tmp := CreateHuman ;
30790: LD_ADDR_VAR 0 1
30794: PUSH
30795: CALL_OW 44
30799: ST_TO_ADDR
// end ; DialogueOn ;
30800: CALL_OW 6
// if IsOK ( Roth ) then
30804: LD_EXP 74
30808: PPUSH
30809: CALL_OW 302
30813: IFFALSE 30827
// Say ( JMM , DAb-JMM-1 ) ;
30815: LD_EXP 39
30819: PPUSH
30820: LD_STRING DAb-JMM-1
30822: PPUSH
30823: CALL_OW 88
// if IsOK ( Roth ) then
30827: LD_EXP 74
30831: PPUSH
30832: CALL_OW 302
30836: IFFALSE 30860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30838: LD_EXP 74
30842: PPUSH
30843: LD_STRING DSurrenderAlliance-Roth-1
30845: PPUSH
30846: CALL_OW 88
// RothCaptured := true ;
30850: LD_ADDR_EXP 33
30854: PUSH
30855: LD_INT 1
30857: ST_TO_ADDR
// end else
30858: GO 30872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30860: LD_VAR 0 1
30864: PPUSH
30865: LD_STRING DSurrenderAlliance-Sci1-1
30867: PPUSH
30868: CALL_OW 88
// DialogueOff ;
30872: CALL_OW 7
// allianceDestroyed := true ;
30876: LD_ADDR_EXP 23
30880: PUSH
30881: LD_INT 1
30883: ST_TO_ADDR
// if capturedUnit = 0 then
30884: LD_EXP 34
30888: PUSH
30889: LD_INT 0
30891: EQUAL
30892: IFFALSE 30901
// SetAchievement ( ACH_ALLIANCE ) ;
30894: LD_STRING ACH_ALLIANCE
30896: PPUSH
30897: CALL_OW 543
// if trueAmericans then
30901: LD_EXP 35
30905: IFFALSE 30981
// begin if trueAmericans = 1 then
30907: LD_EXP 35
30911: PUSH
30912: LD_INT 1
30914: EQUAL
30915: IFFALSE 30931
// Say ( JMM , DAb-JMM-1a ) else
30917: LD_EXP 39
30921: PPUSH
30922: LD_STRING DAb-JMM-1a
30924: PPUSH
30925: CALL_OW 88
30929: GO 30943
// Say ( JMM , DAb-JMM-1b ) ;
30931: LD_EXP 39
30935: PPUSH
30936: LD_STRING DAb-JMM-1b
30938: PPUSH
30939: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30943: LD_EXP 35
30947: PPUSH
30948: CALL_OW 87
// for i in trueAmericans do
30952: LD_ADDR_VAR 0 2
30956: PUSH
30957: LD_EXP 35
30961: PUSH
30962: FOR_IN
30963: IFFALSE 30979
// SetSide ( i , 1 ) ;
30965: LD_VAR 0 2
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 235
30977: GO 30962
30979: POP
30980: POP
// end ; repeat wait ( 0 0$1 ) ;
30981: LD_INT 35
30983: PPUSH
30984: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30988: LD_ADDR_VAR 0 2
30992: PUSH
30993: LD_INT 22
30995: PUSH
30996: LD_INT 7
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 21
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: CALL_OW 69
31021: PUSH
31022: FOR_IN
31023: IFFALSE 31105
// begin if IsInUnit ( i ) then
31025: LD_VAR 0 2
31029: PPUSH
31030: CALL_OW 310
31034: IFFALSE 31045
// ComExitBuilding ( i ) ;
31036: LD_VAR 0 2
31040: PPUSH
31041: CALL_OW 122
// if IsDriver ( i ) then
31045: LD_VAR 0 2
31049: PPUSH
31050: CALL 98679 0 1
31054: IFFALSE 31065
// ComExitVehicle ( i ) ;
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31065: LD_VAR 0 2
31069: PPUSH
31070: LD_INT 26
31072: PPUSH
31073: CALL_OW 308
31077: NOT
31078: IFFALSE 31094
// AddComMoveToArea ( i , allianceEscapeArea ) else
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_INT 26
31087: PPUSH
31088: CALL_OW 173
31092: GO 31103
// RemoveUnit ( i ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: CALL_OW 64
// end ;
31103: GO 31022
31105: POP
31106: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31107: LD_INT 22
31109: PUSH
31110: LD_INT 7
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 21
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: NOT
31136: IFFALSE 30981
// end ;
31138: PPOPN 2
31140: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31141: LD_INT 0
31143: PPUSH
31144: PPUSH
// if not unit then
31145: LD_VAR 0 1
31149: NOT
31150: IFFALSE 31154
// exit ;
31152: GO 32652
// DoNotAttack ( 7 , unit ) ;
31154: LD_INT 7
31156: PPUSH
31157: LD_VAR 0 1
31161: PPUSH
31162: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_INT 260
31173: PPUSH
31174: LD_INT 235
31176: PPUSH
31177: LD_INT 3
31179: PPUSH
31180: LD_INT 1
31182: PPUSH
31183: CALL_OW 483
// SetSide ( unit , 4 ) ;
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_INT 4
31194: PPUSH
31195: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31199: LD_ADDR_EXP 34
31203: PUSH
31204: LD_EXP 34
31208: PUSH
31209: LD_INT 1
31211: PLUS
31212: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31213: LD_INT 70
31215: PPUSH
31216: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31220: LD_INT 260
31222: PPUSH
31223: LD_INT 235
31225: PPUSH
31226: LD_INT 1
31228: PPUSH
31229: LD_INT 8
31231: NEG
31232: PPUSH
31233: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31237: LD_VAR 0 1
31241: PPUSH
31242: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31246: LD_VAR 0 1
31250: PPUSH
31251: LD_EXP 74
31255: PPUSH
31256: CALL_OW 119
// DialogueOn ;
31260: CALL_OW 6
// case unit of JMM :
31264: LD_VAR 0 1
31268: PUSH
31269: LD_EXP 39
31273: DOUBLE
31274: EQUAL
31275: IFTRUE 31279
31277: GO 31294
31279: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31280: LD_EXP 39
31284: PPUSH
31285: LD_STRING DA1-JMM-1
31287: PPUSH
31288: CALL_OW 91
31292: GO 31736
31294: LD_EXP 40
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31305: LD_EXP 40
31309: PPUSH
31310: LD_STRING DA1-Joan-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31736
31319: LD_EXP 42
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31330: LD_EXP 42
31334: PPUSH
31335: LD_STRING DA1-Lisa-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31736
31344: LD_EXP 43
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31355: LD_EXP 43
31359: PPUSH
31360: LD_STRING DA1-Don-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31736
31369: LD_EXP 50
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31380: LD_EXP 50
31384: PPUSH
31385: LD_STRING DA1-Corn-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31736
31394: LD_EXP 46
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31405: LD_EXP 46
31409: PPUSH
31410: LD_STRING DA1-Den-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31736
31419: LD_EXP 44
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31430: LD_EXP 44
31434: PPUSH
31435: LD_STRING DA1-Bobby-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31736
31444: LD_EXP 48
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31455: LD_EXP 48
31459: PPUSH
31460: LD_STRING DA1-Glad-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31736
31469: LD_EXP 45
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31480: LD_EXP 45
31484: PPUSH
31485: LD_STRING DA1-Cyrus-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31736
31494: LD_EXP 41
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31505: LD_EXP 41
31509: PPUSH
31510: LD_STRING DA1-Huck-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31736
31519: LD_EXP 55
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31530: LD_EXP 55
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31736
31544: LD_EXP 47
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31555: LD_EXP 47
31559: PPUSH
31560: LD_STRING DA1-Brown-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31736
31569: LD_EXP 51
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31580: LD_EXP 51
31584: PPUSH
31585: LD_STRING DA1-Gary-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31736
31594: LD_EXP 54
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31605: LD_EXP 54
31609: PPUSH
31610: LD_STRING DA1-Con-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31736
31619: LD_EXP 60
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31630: LD_EXP 60
31634: PPUSH
31635: LD_STRING DA1-Kurt-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31736
31644: LD_EXP 53
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31655: LD_EXP 53
31659: PPUSH
31660: LD_STRING DA1-Yam-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31736
31669: LD_EXP 52
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31680: LD_EXP 52
31684: PPUSH
31685: LD_STRING DA1-Frank-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31736
31694: POP
// begin if GetSex ( unit ) = sex_male then
31695: LD_VAR 0 1
31699: PPUSH
31700: CALL_OW 258
31704: PUSH
31705: LD_INT 1
31707: EQUAL
31708: IFFALSE 31724
// ForceSay ( unit , DA1-Sol1-1 ) else
31710: LD_VAR 0 1
31714: PPUSH
31715: LD_STRING DA1-Sol1-1
31717: PPUSH
31718: CALL_OW 91
31722: GO 31736
// ForceSay ( unit , DA1-FSol1-1 ) ;
31724: LD_VAR 0 1
31728: PPUSH
31729: LD_STRING DA1-FSol1-1
31731: PPUSH
31732: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31736: LD_EXP 74
31740: PPUSH
31741: LD_STRING DA-Roth-1
31743: PPUSH
31744: CALL_OW 88
// if capturedUnit = 1 then
31748: LD_EXP 34
31752: PUSH
31753: LD_INT 1
31755: EQUAL
31756: IFFALSE 31784
// begin Say ( Simms , DA-Sim-1 ) ;
31758: LD_EXP 75
31762: PPUSH
31763: LD_STRING DA-Sim-1
31765: PPUSH
31766: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31770: LD_EXP 74
31774: PPUSH
31775: LD_STRING DA-Roth-2
31777: PPUSH
31778: CALL_OW 88
// end else
31782: GO 31796
// Say ( Simms , DA-Sim-2 ) ;
31784: LD_EXP 75
31788: PPUSH
31789: LD_STRING DA-Sim-2
31791: PPUSH
31792: CALL_OW 88
// case unit of JMM :
31796: LD_VAR 0 1
31800: PUSH
31801: LD_EXP 39
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31812: LD_EXP 39
31816: PPUSH
31817: LD_STRING DA1-JMM-1a
31819: PPUSH
31820: CALL_OW 91
31824: GO 32333
31826: LD_EXP 40
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31837: LD_EXP 40
31841: PPUSH
31842: LD_STRING DA1-Joan-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32333
31851: LD_EXP 42
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31862: LD_EXP 42
31866: PPUSH
31867: LD_STRING DA1-Lisa-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32333
31876: LD_EXP 43
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31887: LD_EXP 43
31891: PPUSH
31892: LD_STRING DA1-Don-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32333
31901: LD_EXP 50
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31912: LD_EXP 50
31916: PPUSH
31917: LD_STRING DA1-Corn-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32333
31926: LD_EXP 46
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31937: LD_EXP 46
31941: PPUSH
31942: LD_STRING DA1-Den-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32333
31951: LD_EXP 44
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31962: LD_EXP 44
31966: PPUSH
31967: LD_STRING DA1-Bobby-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32333
31976: LD_EXP 48
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31987: LD_EXP 48
31991: PPUSH
31992: LD_STRING DA1-Glad-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32333
32001: LD_EXP 45
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32012: LD_EXP 45
32016: PPUSH
32017: LD_STRING DA1-Cyrus-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32333
32026: LD_EXP 41
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32037: LD_EXP 41
32041: PPUSH
32042: LD_STRING DA1-Huck-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32333
32051: LD_EXP 55
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32062: LD_EXP 55
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32333
32076: LD_EXP 47
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32087: LD_EXP 47
32091: PPUSH
32092: LD_STRING DA1-Brown-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32333
32101: LD_EXP 51
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32112: LD_EXP 51
32116: PPUSH
32117: LD_STRING DA1-Gary-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32333
32126: LD_EXP 54
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32137: LD_EXP 54
32141: PPUSH
32142: LD_STRING DA1-Con-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32333
32151: LD_EXP 60
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32162: LD_EXP 60
32166: PPUSH
32167: LD_STRING DA1-Kurt-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32333
32176: LD_EXP 53
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32187: LD_EXP 53
32191: PPUSH
32192: LD_STRING DA1-Yam-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32333
32201: LD_EXP 52
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32212: LD_EXP 52
32216: PPUSH
32217: LD_STRING DA1-Frank-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32333
32226: POP
// begin join := rand ( 0 , 1 ) ;
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: LD_INT 0
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: CALL_OW 12
32242: ST_TO_ADDR
// if join then
32243: LD_VAR 0 3
32247: IFFALSE 32292
// begin if GetSex ( unit ) = sex_male then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 258
32258: PUSH
32259: LD_INT 1
32261: EQUAL
32262: IFFALSE 32278
// ForceSay ( unit , DA1-Sol1-1b ) else
32264: LD_VAR 0 1
32268: PPUSH
32269: LD_STRING DA1-Sol1-1b
32271: PPUSH
32272: CALL_OW 91
32276: GO 32290
// ForceSay ( unit , DA1-FSol1-1b ) ;
32278: LD_VAR 0 1
32282: PPUSH
32283: LD_STRING DA1-FSol1-1b
32285: PPUSH
32286: CALL_OW 91
// end else
32290: GO 32333
// begin if GetSex ( unit ) = sex_male then
32292: LD_VAR 0 1
32296: PPUSH
32297: CALL_OW 258
32301: PUSH
32302: LD_INT 1
32304: EQUAL
32305: IFFALSE 32321
// ForceSay ( unit , DA1-Sol1-1a ) else
32307: LD_VAR 0 1
32311: PPUSH
32312: LD_STRING DA1-Sol1-1a
32314: PPUSH
32315: CALL_OW 91
32319: GO 32333
// ForceSay ( unit , DA1-FSol1-1a ) ;
32321: LD_VAR 0 1
32325: PPUSH
32326: LD_STRING DA1-FSol1-1a
32328: PPUSH
32329: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32333: LD_VAR 0 1
32337: PUSH
32338: LD_EXP 39
32342: EQUAL
32343: IFFALSE 32354
// begin YouLost ( JMMCaptured ) ;
32345: LD_STRING JMMCaptured
32347: PPUSH
32348: CALL_OW 104
// exit ;
32352: GO 32652
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32354: LD_VAR 0 1
32358: PUSH
32359: LD_EXP 43
32363: PUSH
32364: LD_EXP 46
32368: PUSH
32369: LD_EXP 44
32373: PUSH
32374: LD_EXP 41
32378: PUSH
32379: LD_EXP 55
32383: PUSH
32384: LD_EXP 47
32388: PUSH
32389: LD_EXP 53
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: IN
32403: PUSH
32404: LD_VAR 0 3
32408: OR
32409: IFFALSE 32508
// begin Say ( Roth , DA-Roth-3 ) ;
32411: LD_EXP 74
32415: PPUSH
32416: LD_STRING DA-Roth-3
32418: PPUSH
32419: CALL_OW 88
// SetSide ( unit , 7 ) ;
32423: LD_VAR 0 1
32427: PPUSH
32428: LD_INT 7
32430: PPUSH
32431: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32435: LD_ADDR_EXP 111
32439: PUSH
32440: LD_EXP 111
32444: PPUSH
32445: LD_INT 1
32447: PPUSH
32448: LD_EXP 111
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: PUSH
32457: LD_VAR 0 1
32461: ADD
32462: PPUSH
32463: CALL_OW 1
32467: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32468: LD_INT 260
32470: PPUSH
32471: LD_INT 235
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32481: LD_VAR 0 1
32485: PPUSH
32486: LD_INT 1000
32488: PPUSH
32489: CALL_OW 234
// DialogueOff ;
32493: CALL_OW 7
// ComFree ( unit ) ;
32497: LD_VAR 0 1
32501: PPUSH
32502: CALL_OW 139
// end else
32506: GO 32589
// begin Say ( Roth , DA-Roth-3a ) ;
32508: LD_EXP 74
32512: PPUSH
32513: LD_STRING DA-Roth-3a
32515: PPUSH
32516: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32520: LD_ADDR_EXP 35
32524: PUSH
32525: LD_EXP 35
32529: PUSH
32530: LD_VAR 0 1
32534: ADD
32535: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32536: LD_INT 260
32538: PPUSH
32539: LD_INT 235
32541: PPUSH
32542: LD_INT 1
32544: PPUSH
32545: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32549: LD_VAR 0 1
32553: PPUSH
32554: LD_INT 1000
32556: PPUSH
32557: CALL_OW 234
// DialogueOff ;
32561: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 272
32572: PPUSH
32573: LD_INT 254
32575: PPUSH
32576: CALL_OW 111
// AddComHold ( unit ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: CALL_OW 200
// end ; if capturedUnit = 1 then
32589: LD_EXP 34
32593: PUSH
32594: LD_INT 1
32596: EQUAL
32597: IFFALSE 32652
// begin DialogueOn ;
32599: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32603: LD_EXP 39
32607: PPUSH
32608: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32612: LD_EXP 39
32616: PPUSH
32617: LD_STRING DAa-JMM-1
32619: PPUSH
32620: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32624: LD_EXP 39
32628: PPUSH
32629: LD_STRING DAa-JMM-1a
32631: PPUSH
32632: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32636: LD_EXP 39
32640: PPUSH
32641: LD_STRING DAa-JMM-1b
32643: PPUSH
32644: CALL_OW 88
// DialogueOff ;
32648: CALL_OW 7
// end ; end ;
32652: LD_VAR 0 2
32656: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32657: LD_EXP 15
32661: PUSH
32662: LD_INT 13
32664: GREATEREQUAL
32665: PUSH
32666: LD_INT 22
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 21
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 69
32694: PUSH
32695: LD_INT 0
32697: EQUAL
32698: AND
32699: PUSH
32700: LD_INT 22
32702: PUSH
32703: LD_INT 2
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 21
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 50
32722: PUSH
32723: EMPTY
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: AND
32740: PUSH
32741: LD_EXP 21
32745: AND
32746: PUSH
32747: LD_EXP 22
32751: AND
32752: PUSH
32753: LD_EXP 23
32757: AND
32758: IFFALSE 33400
32760: GO 32762
32762: DISABLE
32763: LD_INT 0
32765: PPUSH
32766: PPUSH
32767: PPUSH
// begin m1 := false ;
32768: LD_ADDR_VAR 0 1
32772: PUSH
32773: LD_INT 0
32775: ST_TO_ADDR
// m2 := false ;
32776: LD_ADDR_VAR 0 2
32780: PUSH
32781: LD_INT 0
32783: ST_TO_ADDR
// m3 := false ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 0
32791: ST_TO_ADDR
// if not bombExploded then
32792: LD_EXP 37
32796: NOT
32797: IFFALSE 32806
// SetAchievement ( ACH_SIBROCKET ) ;
32799: LD_STRING ACH_SIBROCKET
32801: PPUSH
32802: CALL_OW 543
// if tick <= 120 120$00 then
32806: LD_OWVAR 1
32810: PUSH
32811: LD_INT 252000
32813: LESSEQUAL
32814: IFFALSE 32830
// begin wait ( 3 ) ;
32816: LD_INT 3
32818: PPUSH
32819: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32823: LD_STRING ACH_ASPEED_15
32825: PPUSH
32826: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32830: LD_EXP 39
32834: PPUSH
32835: CALL_OW 87
// music_class := 5 ;
32839: LD_ADDR_OWVAR 72
32843: PUSH
32844: LD_INT 5
32846: ST_TO_ADDR
// music_nat := 5 ;
32847: LD_ADDR_OWVAR 71
32851: PUSH
32852: LD_INT 5
32854: ST_TO_ADDR
// DialogueOn ;
32855: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32859: LD_EXP 39
32863: PPUSH
32864: LD_STRING D20-JMM-1
32866: PPUSH
32867: CALL_OW 88
// if IsOK ( Joan ) then
32871: LD_EXP 40
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Joan , D20-Joan-1 ) ;
32882: LD_EXP 40
32886: PPUSH
32887: LD_STRING D20-Joan-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Lisa ) then
32894: LD_EXP 42
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Lisa , D20-Lisa-1 ) ;
32905: LD_EXP 42
32909: PPUSH
32910: LD_STRING D20-Lisa-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Donaldson ) then
32917: LD_EXP 43
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Donaldson , D20-Don-1 ) ;
32928: LD_EXP 43
32932: PPUSH
32933: LD_STRING D20-Don-1
32935: PPUSH
32936: CALL_OW 88
// if IsOK ( Cornel ) then
32940: LD_EXP 50
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Cornel , D20-Corn-1 ) ;
32951: LD_EXP 50
32955: PPUSH
32956: LD_STRING D20-Corn-1
32958: PPUSH
32959: CALL_OW 88
// if IsOk ( Denis ) then
32963: LD_EXP 46
32967: PPUSH
32968: CALL_OW 302
32972: IFFALSE 32986
// Say ( Denis , D20-Den-1 ) ;
32974: LD_EXP 46
32978: PPUSH
32979: LD_STRING D20-Den-1
32981: PPUSH
32982: CALL_OW 88
// if IsOk ( Bobby ) then
32986: LD_EXP 44
32990: PPUSH
32991: CALL_OW 302
32995: IFFALSE 33009
// Say ( Bobby , D20-Bobby-1 ) ;
32997: LD_EXP 44
33001: PPUSH
33002: LD_STRING D20-Bobby-1
33004: PPUSH
33005: CALL_OW 88
// if IsOk ( Gladstone ) then
33009: LD_EXP 48
33013: PPUSH
33014: CALL_OW 302
33018: IFFALSE 33032
// Say ( Gladstone , D20-Glad-1 ) ;
33020: LD_EXP 48
33024: PPUSH
33025: LD_STRING D20-Glad-1
33027: PPUSH
33028: CALL_OW 88
// if IsOk ( Cyrus ) then
33032: LD_EXP 45
33036: PPUSH
33037: CALL_OW 302
33041: IFFALSE 33055
// Say ( Cyrus , D20-Cyrus-1 ) ;
33043: LD_EXP 45
33047: PPUSH
33048: LD_STRING D20-Cyrus-1
33050: PPUSH
33051: CALL_OW 88
// if IsOk ( Stevens ) then
33055: LD_EXP 41
33059: PPUSH
33060: CALL_OW 302
33064: IFFALSE 33078
// Say ( Stevens , D20-Huck-1 ) ;
33066: LD_EXP 41
33070: PPUSH
33071: LD_STRING D20-Huck-1
33073: PPUSH
33074: CALL_OW 88
// if IsOk ( Brown ) then
33078: LD_EXP 47
33082: PPUSH
33083: CALL_OW 302
33087: IFFALSE 33101
// Say ( Brown , D20-Brown-1 ) ;
33089: LD_EXP 47
33093: PPUSH
33094: LD_STRING D20-Brown-1
33096: PPUSH
33097: CALL_OW 88
// if IsOk ( Gary ) then
33101: LD_EXP 51
33105: PPUSH
33106: CALL_OW 302
33110: IFFALSE 33124
// Say ( Gary , D20-Gary-1 ) ;
33112: LD_EXP 51
33116: PPUSH
33117: LD_STRING D20-Gary-1
33119: PPUSH
33120: CALL_OW 88
// if IsOk ( Connie ) then
33124: LD_EXP 54
33128: PPUSH
33129: CALL_OW 302
33133: IFFALSE 33147
// Say ( Connie , D20-Con-1 ) ;
33135: LD_EXP 54
33139: PPUSH
33140: LD_STRING D20-Con-1
33142: PPUSH
33143: CALL_OW 88
// if IsOk ( Kurt ) then
33147: LD_EXP 60
33151: PPUSH
33152: CALL_OW 302
33156: IFFALSE 33170
// Say ( Kurt , D20-Kurt-1 ) ;
33158: LD_EXP 60
33162: PPUSH
33163: LD_STRING D20-Kurt-1
33165: PPUSH
33166: CALL_OW 88
// if IsOk ( Kikuchi ) then
33170: LD_EXP 53
33174: PPUSH
33175: CALL_OW 302
33179: IFFALSE 33193
// Say ( Kikuchi , D20-Yam-1 ) ;
33181: LD_EXP 53
33185: PPUSH
33186: LD_STRING D20-Yam-1
33188: PPUSH
33189: CALL_OW 88
// if IsOk ( Frank ) then
33193: LD_EXP 52
33197: PPUSH
33198: CALL_OW 302
33202: IFFALSE 33216
// Say ( Frank , D20-Frank-1 ) ;
33204: LD_EXP 52
33208: PPUSH
33209: LD_STRING D20-Frank-1
33211: PPUSH
33212: CALL_OW 88
// DialogueOff ;
33216: CALL_OW 7
// if RothCaptured then
33220: LD_EXP 33
33224: IFFALSE 33246
// begin m1 := true ;
33226: LD_ADDR_VAR 0 1
33230: PUSH
33231: LD_INT 1
33233: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33234: LD_STRING Roth
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 101
// end else
33244: GO 33257
// AddMedal ( Roth , - 1 ) ;
33246: LD_STRING Roth
33248: PPUSH
33249: LD_INT 1
33251: NEG
33252: PPUSH
33253: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33257: LD_EXP 27
33261: IFFALSE 33283
// begin m2 := true ;
33263: LD_ADDR_VAR 0 2
33267: PUSH
33268: LD_INT 1
33270: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33271: LD_STRING Project
33273: PPUSH
33274: LD_INT 1
33276: PPUSH
33277: CALL_OW 101
// end else
33281: GO 33294
// AddMedal ( Project , - 1 ) ;
33283: LD_STRING Project
33285: PPUSH
33286: LD_INT 1
33288: NEG
33289: PPUSH
33290: CALL_OW 101
// if lostCounter = 0 then
33294: LD_EXP 32
33298: PUSH
33299: LD_INT 0
33301: EQUAL
33302: IFFALSE 33324
// begin m3 := true ;
33304: LD_ADDR_VAR 0 3
33308: PUSH
33309: LD_INT 1
33311: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33312: LD_STRING NoLosses
33314: PPUSH
33315: LD_INT 1
33317: PPUSH
33318: CALL_OW 101
// end else
33322: GO 33335
// AddMedal ( NoLosses , - 1 ) ;
33324: LD_STRING NoLosses
33326: PPUSH
33327: LD_INT 1
33329: NEG
33330: PPUSH
33331: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33335: LD_VAR 0 1
33339: PUSH
33340: LD_VAR 0 2
33344: AND
33345: PUSH
33346: LD_VAR 0 3
33350: AND
33351: PUSH
33352: LD_OWVAR 67
33356: PUSH
33357: LD_INT 3
33359: EQUAL
33360: AND
33361: IFFALSE 33373
// SetAchievementEX ( ACH_AMER , 15 ) ;
33363: LD_STRING ACH_AMER
33365: PPUSH
33366: LD_INT 15
33368: PPUSH
33369: CALL_OW 564
// GiveMedals ( MAIN ) ;
33373: LD_STRING MAIN
33375: PPUSH
33376: CALL_OW 102
// music_class := 4 ;
33380: LD_ADDR_OWVAR 72
33384: PUSH
33385: LD_INT 4
33387: ST_TO_ADDR
// music_nat := 1 ;
33388: LD_ADDR_OWVAR 71
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// YouWin ;
33396: CALL_OW 103
// end ; end_of_file
33400: PPOPN 3
33402: END
// export function CustomEvent ( event ) ; begin
33403: LD_INT 0
33405: PPUSH
// end ;
33406: LD_VAR 0 2
33410: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 2
33424: PUSH
33425: LD_INT 4
33427: EQUAL
33428: AND
33429: PUSH
33430: LD_EXP 58
33434: PPUSH
33435: CALL_OW 300
33439: AND
33440: IFFALSE 33456
// begin wait ( 0 0$2 ) ;
33442: LD_INT 70
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Dismissed ) ;
33449: LD_STRING Dismissed
33451: PPUSH
33452: CALL_OW 104
// end ; end ;
33456: PPOPN 2
33458: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33459: LD_VAR 0 2
33463: PPUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_INT 18
33471: PPUSH
33472: CALL_OW 309
33476: IFFALSE 33485
// YouLost ( Motherlode3 ) ;
33478: LD_STRING Motherlode3
33480: PPUSH
33481: CALL_OW 104
// end ;
33485: PPOPN 3
33487: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33488: LD_EXP 27
33492: NOT
33493: IFFALSE 33503
// behemothDone := true ;
33495: LD_ADDR_EXP 28
33499: PUSH
33500: LD_INT 1
33502: ST_TO_ADDR
// end ;
33503: PPOPN 1
33505: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33506: LD_VAR 0 1
33510: PPUSH
33511: CALL_OW 255
33515: PUSH
33516: LD_INT 1
33518: EQUAL
33519: IFFALSE 33529
// bombExploded := true ;
33521: LD_ADDR_EXP 37
33525: PUSH
33526: LD_INT 1
33528: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33529: LD_VAR 0 1
33533: PPUSH
33534: CALL_OW 255
33538: PUSH
33539: LD_INT 1
33541: EQUAL
33542: PUSH
33543: LD_EXP 30
33547: AND
33548: PUSH
33549: LD_INT 22
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 34
33561: PUSH
33562: LD_INT 48
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PPUSH
33573: CALL_OW 69
33577: AND
33578: PUSH
33579: LD_INT 22
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 34
33591: PUSH
33592: LD_INT 8
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PPUSH
33603: CALL_OW 69
33607: NOT
33608: AND
33609: IFFALSE 33661
// begin wait ( 0 0$5 ) ;
33611: LD_INT 175
33613: PPUSH
33614: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33618: LD_INT 22
33620: PUSH
33621: LD_INT 3
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 34
33630: PUSH
33631: LD_INT 48
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PPUSH
33642: CALL_OW 69
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: LD_INT 60
33653: PPUSH
33654: LD_INT 95
33656: PPUSH
33657: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33661: LD_VAR 0 2
33665: PPUSH
33666: LD_VAR 0 3
33670: PPUSH
33671: LD_INT 18
33673: PPUSH
33674: CALL_OW 309
33678: IFFALSE 33738
// begin if GetSide ( unit ) = 1 then
33680: LD_VAR 0 1
33684: PPUSH
33685: CALL_OW 255
33689: PUSH
33690: LD_INT 1
33692: EQUAL
33693: IFFALSE 33709
// begin wait ( 0 0$6 ) ;
33695: LD_INT 210
33697: PPUSH
33698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33702: LD_STRING Motherlode2
33704: PPUSH
33705: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33709: LD_VAR 0 1
33713: PPUSH
33714: CALL_OW 255
33718: PUSH
33719: LD_INT 8
33721: EQUAL
33722: IFFALSE 33738
// begin wait ( 0 0$6 ) ;
33724: LD_INT 210
33726: PPUSH
33727: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33731: LD_STRING Motherlode1
33733: PPUSH
33734: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33738: LD_VAR 0 1
33742: PPUSH
33743: CALL_OW 255
33747: PUSH
33748: LD_INT 3
33750: EQUAL
33751: IFFALSE 33772
// begin wait ( 0 0$5 ) ;
33753: LD_INT 175
33755: PPUSH
33756: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33760: LD_EXP 64
33764: PPUSH
33765: LD_STRING D18-Pla-1
33767: PPUSH
33768: CALL_OW 94
// end ; end ;
33772: PPOPN 3
33774: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33775: LD_VAR 0 1
33779: PUSH
33780: LD_INT 22
33782: PUSH
33783: LD_INT 1
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 21
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 23
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: PPUSH
33815: CALL_OW 69
33819: IN
33820: IFFALSE 33836
// lostCounter := lostCounter + 1 ;
33822: LD_ADDR_EXP 32
33826: PUSH
33827: LD_EXP 32
33831: PUSH
33832: LD_INT 1
33834: PLUS
33835: ST_TO_ADDR
// if un in behemothBuilders then
33836: LD_VAR 0 1
33840: PUSH
33841: LD_EXP 73
33845: IN
33846: IFFALSE 33866
// begin behemothBuilders := behemothBuilders diff un ;
33848: LD_ADDR_EXP 73
33852: PUSH
33853: LD_EXP 73
33857: PUSH
33858: LD_VAR 0 1
33862: DIFF
33863: ST_TO_ADDR
// exit ;
33864: GO 33896
// end ; if un = JMM then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 39
33875: EQUAL
33876: IFFALSE 33887
// begin YouLost ( JMM ) ;
33878: LD_STRING JMM
33880: PPUSH
33881: CALL_OW 104
// exit ;
33885: GO 33896
// end ; MCE_UnitDestroyed ( un ) ;
33887: LD_VAR 0 1
33891: PPUSH
33892: CALL 62132 0 1
// end ;
33896: PPOPN 1
33898: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33899: LD_VAR 0 1
33903: PPUSH
33904: LD_VAR 0 2
33908: PPUSH
33909: CALL 64466 0 2
// end ;
33913: PPOPN 2
33915: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL 63534 0 1
// end ;
33925: PPOPN 1
33927: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33928: LD_VAR 0 1
33932: PUSH
33933: LD_INT 22
33935: PUSH
33936: LD_INT 8
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 30
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 23
33955: PUSH
33956: LD_INT 3
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: LIST
33967: PPUSH
33968: CALL_OW 69
33972: IN
33973: IFFALSE 34000
// begin ComUpgrade ( building ) ;
33975: LD_VAR 0 1
33979: PPUSH
33980: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33984: LD_EXP 61
33988: PPUSH
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL 72881 0 2
// exit ;
33998: GO 34009
// end ; MCE_BuildingComplete ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL 63775 0 1
// end ;
34009: PPOPN 1
34011: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34012: LD_VAR 0 1
34016: PPUSH
34017: LD_VAR 0 2
34021: PPUSH
34022: CALL 61828 0 2
// end ;
34026: PPOPN 2
34028: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_VAR 0 3
34043: PPUSH
34044: LD_VAR 0 4
34048: PPUSH
34049: LD_VAR 0 5
34053: PPUSH
34054: CALL 61448 0 5
// end ;
34058: PPOPN 5
34060: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: CALL 61044 0 2
// end ;
34075: PPOPN 2
34077: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34078: LD_VAR 0 1
34082: PPUSH
34083: LD_VAR 0 2
34087: PPUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: LD_VAR 0 4
34097: PPUSH
34098: CALL 60882 0 4
// end ;
34102: PPOPN 4
34104: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34105: LD_VAR 0 1
34109: PPUSH
34110: LD_VAR 0 2
34114: PPUSH
34115: LD_VAR 0 3
34119: PPUSH
34120: CALL 60657 0 3
// end ;
34124: PPOPN 3
34126: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34127: LD_VAR 0 1
34131: PPUSH
34132: LD_VAR 0 2
34136: PPUSH
34137: CALL 60542 0 2
// end ;
34141: PPOPN 2
34143: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: LD_VAR 0 2
34153: PPUSH
34154: CALL 64727 0 2
// end ;
34158: PPOPN 2
34160: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 255
34170: PUSH
34171: LD_INT 4
34173: EQUAL
34174: PUSH
34175: LD_VAR 0 1
34179: PUSH
34180: LD_EXP 18
34184: PUSH
34185: LD_INT 1
34187: ARRAY
34188: IN
34189: AND
34190: PUSH
34191: LD_EXP 19
34195: AND
34196: IFFALSE 34215
// begin ComMoveXY ( driver , 61 , 93 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 61
34205: PPUSH
34206: LD_INT 93
34208: PPUSH
34209: CALL_OW 111
// exit ;
34213: GO 34239
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34215: LD_VAR 0 1
34219: PPUSH
34220: LD_VAR 0 2
34224: PPUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: LD_VAR 0 4
34234: PPUSH
34235: CALL 64943 0 4
// end ;
34239: PPOPN 4
34241: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34242: LD_VAR 0 1
34246: PPUSH
34247: LD_VAR 0 2
34251: PPUSH
34252: CALL 60351 0 2
// end ;
34256: PPOPN 2
34258: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: CALL 112589 0 1
// end ; end_of_file
34268: PPOPN 1
34270: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34271: LD_EXP 15
34275: PUSH
34276: LD_INT 2
34278: EQUAL
34279: IFFALSE 34758
34281: GO 34283
34283: DISABLE
34284: LD_INT 0
34286: PPUSH
// begin time := 0 0$40 ;
34287: LD_ADDR_VAR 0 1
34291: PUSH
34292: LD_INT 1400
34294: ST_TO_ADDR
// repeat wait ( time ) ;
34295: LD_VAR 0 1
34299: PPUSH
34300: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34304: LD_INT 1
34306: PPUSH
34307: LD_INT 5
34309: PPUSH
34310: CALL_OW 12
34314: PPUSH
34315: LD_INT 106
34317: PPUSH
34318: LD_INT 150
34320: PPUSH
34321: LD_INT 19
34323: PPUSH
34324: LD_INT 1
34326: PPUSH
34327: CALL_OW 56
// time := time + 0 0$9 ;
34331: LD_ADDR_VAR 0 1
34335: PUSH
34336: LD_VAR 0 1
34340: PUSH
34341: LD_INT 315
34343: PLUS
34344: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34345: LD_INT 455
34347: PPUSH
34348: LD_INT 840
34350: PPUSH
34351: CALL_OW 12
34355: PPUSH
34356: CALL_OW 67
// if Prob ( 50 ) then
34360: LD_INT 50
34362: PPUSH
34363: CALL_OW 13
34367: IFFALSE 34396
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34369: LD_INT 1
34371: PPUSH
34372: LD_INT 5
34374: PPUSH
34375: CALL_OW 12
34379: PPUSH
34380: LD_INT 62
34382: PPUSH
34383: LD_INT 108
34385: PPUSH
34386: LD_INT 10
34388: PPUSH
34389: LD_INT 1
34391: PPUSH
34392: CALL_OW 56
// until missionStage > 4 ;
34396: LD_EXP 15
34400: PUSH
34401: LD_INT 4
34403: GREATER
34404: IFFALSE 34295
// repeat wait ( 0 0$1 ) ;
34406: LD_INT 35
34408: PPUSH
34409: CALL_OW 67
// until missionStage = 6 ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 6
34420: EQUAL
34421: IFFALSE 34406
// time := 0 0$50 ;
34423: LD_ADDR_VAR 0 1
34427: PUSH
34428: LD_INT 1750
34430: ST_TO_ADDR
// repeat wait ( time ) ;
34431: LD_VAR 0 1
34435: PPUSH
34436: CALL_OW 67
// if Prob ( 50 ) then
34440: LD_INT 50
34442: PPUSH
34443: CALL_OW 13
34447: IFFALSE 34476
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34449: LD_INT 1
34451: PPUSH
34452: LD_INT 5
34454: PPUSH
34455: CALL_OW 12
34459: PPUSH
34460: LD_INT 106
34462: PPUSH
34463: LD_INT 89
34465: PPUSH
34466: LD_INT 45
34468: PPUSH
34469: LD_INT 1
34471: PPUSH
34472: CALL_OW 56
// time := time + 0 0$2 ;
34476: LD_ADDR_VAR 0 1
34480: PUSH
34481: LD_VAR 0 1
34485: PUSH
34486: LD_INT 70
34488: PLUS
34489: ST_TO_ADDR
// if Prob ( 30 ) then
34490: LD_INT 30
34492: PPUSH
34493: CALL_OW 13
34497: IFFALSE 34543
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34499: LD_INT 385
34501: PPUSH
34502: LD_INT 945
34504: PPUSH
34505: CALL_OW 12
34509: PPUSH
34510: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34514: LD_INT 1
34516: PPUSH
34517: LD_INT 5
34519: PPUSH
34520: CALL_OW 12
34524: PPUSH
34525: LD_INT 21
34527: PPUSH
34528: LD_INT 26
34530: PPUSH
34531: LD_INT 12
34533: PPUSH
34534: LD_INT 1
34536: PPUSH
34537: CALL_OW 56
// end else
34541: GO 34579
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34543: LD_INT 700
34545: PPUSH
34546: LD_INT 1225
34548: PPUSH
34549: CALL_OW 12
34553: PPUSH
34554: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34558: LD_INT 1
34560: PPUSH
34561: LD_INT 5
34563: PPUSH
34564: CALL_OW 12
34568: PPUSH
34569: LD_INT 16
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: CALL_OW 55
// end ; if Prob ( 50 ) then
34579: LD_INT 50
34581: PPUSH
34582: CALL_OW 13
34586: IFFALSE 34632
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34588: LD_INT 700
34590: PPUSH
34591: LD_INT 1050
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34603: LD_INT 1
34605: PPUSH
34606: LD_INT 5
34608: PPUSH
34609: CALL_OW 12
34613: PPUSH
34614: LD_INT 181
34616: PPUSH
34617: LD_INT 218
34619: PPUSH
34620: LD_INT 16
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 56
// end else
34630: GO 34668
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34632: LD_INT 350
34634: PPUSH
34635: LD_INT 525
34637: PPUSH
34638: CALL_OW 12
34642: PPUSH
34643: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34647: LD_INT 1
34649: PPUSH
34650: LD_INT 5
34652: PPUSH
34653: CALL_OW 12
34657: PPUSH
34658: LD_INT 15
34660: PPUSH
34661: LD_INT 1
34663: PPUSH
34664: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34668: LD_INT 45
34670: PUSH
34671: LD_INT 32
34673: PUSH
34674: LD_INT 25
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: PUSH
34682: LD_OWVAR 67
34686: ARRAY
34687: PPUSH
34688: CALL_OW 13
34692: IFFALSE 34736
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34694: LD_INT 175
34696: PPUSH
34697: LD_INT 315
34699: PPUSH
34700: CALL_OW 12
34704: PPUSH
34705: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34709: LD_INT 1
34711: PPUSH
34712: LD_INT 5
34714: PPUSH
34715: CALL_OW 12
34719: PPUSH
34720: LD_INT 103
34722: PPUSH
34723: LD_INT 140
34725: PPUSH
34726: LD_INT 20
34728: PPUSH
34729: LD_INT 1
34731: PPUSH
34732: CALL_OW 56
// end ; if time > 1 1$20 then
34736: LD_VAR 0 1
34740: PUSH
34741: LD_INT 2800
34743: GREATER
34744: IFFALSE 34754
// time := 0 0$30 ;
34746: LD_ADDR_VAR 0 1
34750: PUSH
34751: LD_INT 1050
34753: ST_TO_ADDR
// until false ;
34754: LD_INT 0
34756: IFFALSE 34431
// end ; end_of_file
34758: PPOPN 1
34760: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34761: LD_EXP 13
34765: PUSH
34766: LD_EXP 15
34770: PUSH
34771: LD_INT 6
34773: GREATEREQUAL
34774: AND
34775: IFFALSE 34812
34777: GO 34779
34779: DISABLE
// begin enable ;
34780: ENABLE
// missionTime := missionTime + 0 0$1 ;
34781: LD_ADDR_EXP 14
34785: PUSH
34786: LD_EXP 14
34790: PUSH
34791: LD_INT 35
34793: PLUS
34794: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34795: LD_ADDR_OWVAR 47
34799: PUSH
34800: LD_STRING #Am15-1
34802: PUSH
34803: LD_EXP 14
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: ST_TO_ADDR
// end ; end_of_file
34812: END
// export function InitNature ; begin
34813: LD_INT 0
34815: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34816: LD_INT 3
34818: PPUSH
34819: LD_INT 3
34821: PPUSH
34822: LD_INT 2
34824: PPUSH
34825: LD_INT 1
34827: PPUSH
34828: LD_INT 1
34830: PPUSH
34831: LD_INT 0
34833: PPUSH
34834: LD_INT 0
34836: PPUSH
34837: LD_INT 20
34839: PPUSH
34840: LD_INT 0
34842: PPUSH
34843: CALL 97699 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 1
34858: PPUSH
34859: LD_INT 1
34861: PPUSH
34862: LD_INT 0
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: LD_INT 21
34870: PPUSH
34871: LD_INT 0
34873: PPUSH
34874: CALL 97699 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34878: LD_INT 4
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 2
34886: PPUSH
34887: LD_INT 4
34889: PPUSH
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: LD_INT 22
34901: PPUSH
34902: LD_INT 0
34904: PPUSH
34905: CALL 97699 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34909: LD_INT 0
34911: PPUSH
34912: LD_INT 0
34914: PPUSH
34915: LD_INT 0
34917: PPUSH
34918: LD_INT 0
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 0
34926: PPUSH
34927: LD_INT 9
34929: PPUSH
34930: LD_INT 0
34932: PPUSH
34933: LD_INT 23
34935: PPUSH
34936: CALL 97699 0 9
// end ; end_of_file
34940: LD_VAR 0 1
34944: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
34945: GO 34947
34947: DISABLE
// begin ru_radar := 98 ;
34948: LD_ADDR_EXP 95
34952: PUSH
34953: LD_INT 98
34955: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34956: LD_ADDR_EXP 96
34960: PUSH
34961: LD_INT 89
34963: ST_TO_ADDR
// us_hack := 99 ;
34964: LD_ADDR_EXP 97
34968: PUSH
34969: LD_INT 99
34971: ST_TO_ADDR
// us_artillery := 97 ;
34972: LD_ADDR_EXP 98
34976: PUSH
34977: LD_INT 97
34979: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34980: LD_ADDR_EXP 99
34984: PUSH
34985: LD_INT 91
34987: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
34988: LD_ADDR_EXP 100
34992: PUSH
34993: LD_INT 92
34995: ST_TO_ADDR
// tech_Artillery := 80 ;
34996: LD_ADDR_EXP 101
35000: PUSH
35001: LD_INT 80
35003: ST_TO_ADDR
// tech_RadMat := 81 ;
35004: LD_ADDR_EXP 102
35008: PUSH
35009: LD_INT 81
35011: ST_TO_ADDR
// tech_BasicTools := 82 ;
35012: LD_ADDR_EXP 103
35016: PUSH
35017: LD_INT 82
35019: ST_TO_ADDR
// tech_Cargo := 83 ;
35020: LD_ADDR_EXP 104
35024: PUSH
35025: LD_INT 83
35027: ST_TO_ADDR
// tech_Track := 84 ;
35028: LD_ADDR_EXP 105
35032: PUSH
35033: LD_INT 84
35035: ST_TO_ADDR
// tech_Crane := 85 ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_INT 85
35043: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35044: LD_ADDR_EXP 107
35048: PUSH
35049: LD_INT 86
35051: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35052: LD_ADDR_EXP 108
35056: PUSH
35057: LD_INT 87
35059: ST_TO_ADDR
// end ; end_of_file
35060: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35061: LD_INT 0
35063: PPUSH
35064: PPUSH
// skirmish := false ;
35065: LD_ADDR_EXP 109
35069: PUSH
35070: LD_INT 0
35072: ST_TO_ADDR
// debug_mc := false ;
35073: LD_ADDR_EXP 110
35077: PUSH
35078: LD_INT 0
35080: ST_TO_ADDR
// mc_bases := [ ] ;
35081: LD_ADDR_EXP 111
35085: PUSH
35086: EMPTY
35087: ST_TO_ADDR
// mc_sides := [ ] ;
35088: LD_ADDR_EXP 137
35092: PUSH
35093: EMPTY
35094: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35095: LD_ADDR_EXP 112
35099: PUSH
35100: EMPTY
35101: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35102: LD_ADDR_EXP 113
35106: PUSH
35107: EMPTY
35108: ST_TO_ADDR
// mc_need_heal := [ ] ;
35109: LD_ADDR_EXP 114
35113: PUSH
35114: EMPTY
35115: ST_TO_ADDR
// mc_healers := [ ] ;
35116: LD_ADDR_EXP 115
35120: PUSH
35121: EMPTY
35122: ST_TO_ADDR
// mc_build_list := [ ] ;
35123: LD_ADDR_EXP 116
35127: PUSH
35128: EMPTY
35129: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35130: LD_ADDR_EXP 143
35134: PUSH
35135: EMPTY
35136: ST_TO_ADDR
// mc_builders := [ ] ;
35137: LD_ADDR_EXP 117
35141: PUSH
35142: EMPTY
35143: ST_TO_ADDR
// mc_construct_list := [ ] ;
35144: LD_ADDR_EXP 118
35148: PUSH
35149: EMPTY
35150: ST_TO_ADDR
// mc_turret_list := [ ] ;
35151: LD_ADDR_EXP 119
35155: PUSH
35156: EMPTY
35157: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35158: LD_ADDR_EXP 120
35162: PUSH
35163: EMPTY
35164: ST_TO_ADDR
// mc_miners := [ ] ;
35165: LD_ADDR_EXP 125
35169: PUSH
35170: EMPTY
35171: ST_TO_ADDR
// mc_mines := [ ] ;
35172: LD_ADDR_EXP 124
35176: PUSH
35177: EMPTY
35178: ST_TO_ADDR
// mc_minefields := [ ] ;
35179: LD_ADDR_EXP 126
35183: PUSH
35184: EMPTY
35185: ST_TO_ADDR
// mc_crates := [ ] ;
35186: LD_ADDR_EXP 127
35190: PUSH
35191: EMPTY
35192: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35193: LD_ADDR_EXP 128
35197: PUSH
35198: EMPTY
35199: ST_TO_ADDR
// mc_crates_area := [ ] ;
35200: LD_ADDR_EXP 129
35204: PUSH
35205: EMPTY
35206: ST_TO_ADDR
// mc_vehicles := [ ] ;
35207: LD_ADDR_EXP 130
35211: PUSH
35212: EMPTY
35213: ST_TO_ADDR
// mc_attack := [ ] ;
35214: LD_ADDR_EXP 131
35218: PUSH
35219: EMPTY
35220: ST_TO_ADDR
// mc_produce := [ ] ;
35221: LD_ADDR_EXP 132
35225: PUSH
35226: EMPTY
35227: ST_TO_ADDR
// mc_defender := [ ] ;
35228: LD_ADDR_EXP 133
35232: PUSH
35233: EMPTY
35234: ST_TO_ADDR
// mc_parking := [ ] ;
35235: LD_ADDR_EXP 135
35239: PUSH
35240: EMPTY
35241: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35242: LD_ADDR_EXP 121
35246: PUSH
35247: EMPTY
35248: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35249: LD_ADDR_EXP 123
35253: PUSH
35254: EMPTY
35255: ST_TO_ADDR
// mc_scan := [ ] ;
35256: LD_ADDR_EXP 134
35260: PUSH
35261: EMPTY
35262: ST_TO_ADDR
// mc_scan_area := [ ] ;
35263: LD_ADDR_EXP 136
35267: PUSH
35268: EMPTY
35269: ST_TO_ADDR
// mc_tech := [ ] ;
35270: LD_ADDR_EXP 138
35274: PUSH
35275: EMPTY
35276: ST_TO_ADDR
// mc_class := [ ] ;
35277: LD_ADDR_EXP 152
35281: PUSH
35282: EMPTY
35283: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35284: LD_ADDR_EXP 153
35288: PUSH
35289: EMPTY
35290: ST_TO_ADDR
// end ;
35291: LD_VAR 0 1
35295: RET
// export function MC_Kill ( base ) ; begin
35296: LD_INT 0
35298: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35299: LD_ADDR_EXP 111
35303: PUSH
35304: LD_EXP 111
35308: PPUSH
35309: LD_VAR 0 1
35313: PPUSH
35314: EMPTY
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35321: LD_ADDR_EXP 112
35325: PUSH
35326: LD_EXP 112
35330: PPUSH
35331: LD_VAR 0 1
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL_OW 1
35342: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35343: LD_ADDR_EXP 113
35347: PUSH
35348: LD_EXP 113
35352: PPUSH
35353: LD_VAR 0 1
35357: PPUSH
35358: EMPTY
35359: PPUSH
35360: CALL_OW 1
35364: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35365: LD_ADDR_EXP 114
35369: PUSH
35370: LD_EXP 114
35374: PPUSH
35375: LD_VAR 0 1
35379: PPUSH
35380: EMPTY
35381: PPUSH
35382: CALL_OW 1
35386: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35387: LD_ADDR_EXP 115
35391: PUSH
35392: LD_EXP 115
35396: PPUSH
35397: LD_VAR 0 1
35401: PPUSH
35402: EMPTY
35403: PPUSH
35404: CALL_OW 1
35408: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35409: LD_ADDR_EXP 116
35413: PUSH
35414: LD_EXP 116
35418: PPUSH
35419: LD_VAR 0 1
35423: PPUSH
35424: EMPTY
35425: PPUSH
35426: CALL_OW 1
35430: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35431: LD_ADDR_EXP 117
35435: PUSH
35436: LD_EXP 117
35440: PPUSH
35441: LD_VAR 0 1
35445: PPUSH
35446: EMPTY
35447: PPUSH
35448: CALL_OW 1
35452: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35453: LD_ADDR_EXP 118
35457: PUSH
35458: LD_EXP 118
35462: PPUSH
35463: LD_VAR 0 1
35467: PPUSH
35468: EMPTY
35469: PPUSH
35470: CALL_OW 1
35474: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35475: LD_ADDR_EXP 119
35479: PUSH
35480: LD_EXP 119
35484: PPUSH
35485: LD_VAR 0 1
35489: PPUSH
35490: EMPTY
35491: PPUSH
35492: CALL_OW 1
35496: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35497: LD_ADDR_EXP 120
35501: PUSH
35502: LD_EXP 120
35506: PPUSH
35507: LD_VAR 0 1
35511: PPUSH
35512: EMPTY
35513: PPUSH
35514: CALL_OW 1
35518: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35519: LD_ADDR_EXP 121
35523: PUSH
35524: LD_EXP 121
35528: PPUSH
35529: LD_VAR 0 1
35533: PPUSH
35534: EMPTY
35535: PPUSH
35536: CALL_OW 1
35540: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35541: LD_ADDR_EXP 122
35545: PUSH
35546: LD_EXP 122
35550: PPUSH
35551: LD_VAR 0 1
35555: PPUSH
35556: LD_INT 0
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35564: LD_ADDR_EXP 123
35568: PUSH
35569: LD_EXP 123
35573: PPUSH
35574: LD_VAR 0 1
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35586: LD_ADDR_EXP 124
35590: PUSH
35591: LD_EXP 124
35595: PPUSH
35596: LD_VAR 0 1
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35608: LD_ADDR_EXP 125
35612: PUSH
35613: LD_EXP 125
35617: PPUSH
35618: LD_VAR 0 1
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35630: LD_ADDR_EXP 126
35634: PUSH
35635: LD_EXP 126
35639: PPUSH
35640: LD_VAR 0 1
35644: PPUSH
35645: EMPTY
35646: PPUSH
35647: CALL_OW 1
35651: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35652: LD_ADDR_EXP 127
35656: PUSH
35657: LD_EXP 127
35661: PPUSH
35662: LD_VAR 0 1
35666: PPUSH
35667: EMPTY
35668: PPUSH
35669: CALL_OW 1
35673: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35674: LD_ADDR_EXP 128
35678: PUSH
35679: LD_EXP 128
35683: PPUSH
35684: LD_VAR 0 1
35688: PPUSH
35689: EMPTY
35690: PPUSH
35691: CALL_OW 1
35695: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35696: LD_ADDR_EXP 129
35700: PUSH
35701: LD_EXP 129
35705: PPUSH
35706: LD_VAR 0 1
35710: PPUSH
35711: EMPTY
35712: PPUSH
35713: CALL_OW 1
35717: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35718: LD_ADDR_EXP 130
35722: PUSH
35723: LD_EXP 130
35727: PPUSH
35728: LD_VAR 0 1
35732: PPUSH
35733: EMPTY
35734: PPUSH
35735: CALL_OW 1
35739: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35740: LD_ADDR_EXP 131
35744: PUSH
35745: LD_EXP 131
35749: PPUSH
35750: LD_VAR 0 1
35754: PPUSH
35755: EMPTY
35756: PPUSH
35757: CALL_OW 1
35761: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35762: LD_ADDR_EXP 132
35766: PUSH
35767: LD_EXP 132
35771: PPUSH
35772: LD_VAR 0 1
35776: PPUSH
35777: EMPTY
35778: PPUSH
35779: CALL_OW 1
35783: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35784: LD_ADDR_EXP 133
35788: PUSH
35789: LD_EXP 133
35793: PPUSH
35794: LD_VAR 0 1
35798: PPUSH
35799: EMPTY
35800: PPUSH
35801: CALL_OW 1
35805: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35806: LD_ADDR_EXP 134
35810: PUSH
35811: LD_EXP 134
35815: PPUSH
35816: LD_VAR 0 1
35820: PPUSH
35821: EMPTY
35822: PPUSH
35823: CALL_OW 1
35827: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35828: LD_ADDR_EXP 135
35832: PUSH
35833: LD_EXP 135
35837: PPUSH
35838: LD_VAR 0 1
35842: PPUSH
35843: EMPTY
35844: PPUSH
35845: CALL_OW 1
35849: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35850: LD_ADDR_EXP 136
35854: PUSH
35855: LD_EXP 136
35859: PPUSH
35860: LD_VAR 0 1
35864: PPUSH
35865: EMPTY
35866: PPUSH
35867: CALL_OW 1
35871: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35872: LD_ADDR_EXP 138
35876: PUSH
35877: LD_EXP 138
35881: PPUSH
35882: LD_VAR 0 1
35886: PPUSH
35887: EMPTY
35888: PPUSH
35889: CALL_OW 1
35893: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35894: LD_ADDR_EXP 140
35898: PUSH
35899: LD_EXP 140
35903: PPUSH
35904: LD_VAR 0 1
35908: PPUSH
35909: EMPTY
35910: PPUSH
35911: CALL_OW 1
35915: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35916: LD_ADDR_EXP 141
35920: PUSH
35921: LD_EXP 141
35925: PPUSH
35926: LD_VAR 0 1
35930: PPUSH
35931: EMPTY
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35938: LD_ADDR_EXP 142
35942: PUSH
35943: LD_EXP 142
35947: PPUSH
35948: LD_VAR 0 1
35952: PPUSH
35953: EMPTY
35954: PPUSH
35955: CALL_OW 1
35959: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35960: LD_ADDR_EXP 143
35964: PUSH
35965: LD_EXP 143
35969: PPUSH
35970: LD_VAR 0 1
35974: PPUSH
35975: EMPTY
35976: PPUSH
35977: CALL_OW 1
35981: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35982: LD_ADDR_EXP 144
35986: PUSH
35987: LD_EXP 144
35991: PPUSH
35992: LD_VAR 0 1
35996: PPUSH
35997: EMPTY
35998: PPUSH
35999: CALL_OW 1
36003: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36004: LD_ADDR_EXP 145
36008: PUSH
36009: LD_EXP 145
36013: PPUSH
36014: LD_VAR 0 1
36018: PPUSH
36019: EMPTY
36020: PPUSH
36021: CALL_OW 1
36025: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36026: LD_ADDR_EXP 146
36030: PUSH
36031: LD_EXP 146
36035: PPUSH
36036: LD_VAR 0 1
36040: PPUSH
36041: EMPTY
36042: PPUSH
36043: CALL_OW 1
36047: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36048: LD_ADDR_EXP 147
36052: PUSH
36053: LD_EXP 147
36057: PPUSH
36058: LD_VAR 0 1
36062: PPUSH
36063: EMPTY
36064: PPUSH
36065: CALL_OW 1
36069: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36070: LD_ADDR_EXP 148
36074: PUSH
36075: LD_EXP 148
36079: PPUSH
36080: LD_VAR 0 1
36084: PPUSH
36085: EMPTY
36086: PPUSH
36087: CALL_OW 1
36091: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36092: LD_ADDR_EXP 149
36096: PUSH
36097: LD_EXP 149
36101: PPUSH
36102: LD_VAR 0 1
36106: PPUSH
36107: EMPTY
36108: PPUSH
36109: CALL_OW 1
36113: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36114: LD_ADDR_EXP 150
36118: PUSH
36119: LD_EXP 150
36123: PPUSH
36124: LD_VAR 0 1
36128: PPUSH
36129: EMPTY
36130: PPUSH
36131: CALL_OW 1
36135: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36136: LD_ADDR_EXP 151
36140: PUSH
36141: LD_EXP 151
36145: PPUSH
36146: LD_VAR 0 1
36150: PPUSH
36151: EMPTY
36152: PPUSH
36153: CALL_OW 1
36157: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36158: LD_ADDR_EXP 152
36162: PUSH
36163: LD_EXP 152
36167: PPUSH
36168: LD_VAR 0 1
36172: PPUSH
36173: EMPTY
36174: PPUSH
36175: CALL_OW 1
36179: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36180: LD_ADDR_EXP 153
36184: PUSH
36185: LD_EXP 153
36189: PPUSH
36190: LD_VAR 0 1
36194: PPUSH
36195: LD_INT 0
36197: PPUSH
36198: CALL_OW 1
36202: ST_TO_ADDR
// end ;
36203: LD_VAR 0 2
36207: RET
// export function MC_Add ( side , units ) ; var base ; begin
36208: LD_INT 0
36210: PPUSH
36211: PPUSH
// base := mc_bases + 1 ;
36212: LD_ADDR_VAR 0 4
36216: PUSH
36217: LD_EXP 111
36221: PUSH
36222: LD_INT 1
36224: PLUS
36225: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36226: LD_ADDR_EXP 137
36230: PUSH
36231: LD_EXP 137
36235: PPUSH
36236: LD_VAR 0 4
36240: PPUSH
36241: LD_VAR 0 1
36245: PPUSH
36246: CALL_OW 1
36250: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36251: LD_ADDR_EXP 111
36255: PUSH
36256: LD_EXP 111
36260: PPUSH
36261: LD_VAR 0 4
36265: PPUSH
36266: LD_VAR 0 2
36270: PPUSH
36271: CALL_OW 1
36275: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36276: LD_ADDR_EXP 112
36280: PUSH
36281: LD_EXP 112
36285: PPUSH
36286: LD_VAR 0 4
36290: PPUSH
36291: EMPTY
36292: PPUSH
36293: CALL_OW 1
36297: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36298: LD_ADDR_EXP 113
36302: PUSH
36303: LD_EXP 113
36307: PPUSH
36308: LD_VAR 0 4
36312: PPUSH
36313: EMPTY
36314: PPUSH
36315: CALL_OW 1
36319: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36320: LD_ADDR_EXP 114
36324: PUSH
36325: LD_EXP 114
36329: PPUSH
36330: LD_VAR 0 4
36334: PPUSH
36335: EMPTY
36336: PPUSH
36337: CALL_OW 1
36341: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36342: LD_ADDR_EXP 115
36346: PUSH
36347: LD_EXP 115
36351: PPUSH
36352: LD_VAR 0 4
36356: PPUSH
36357: EMPTY
36358: PPUSH
36359: CALL_OW 1
36363: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36364: LD_ADDR_EXP 116
36368: PUSH
36369: LD_EXP 116
36373: PPUSH
36374: LD_VAR 0 4
36378: PPUSH
36379: EMPTY
36380: PPUSH
36381: CALL_OW 1
36385: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36386: LD_ADDR_EXP 117
36390: PUSH
36391: LD_EXP 117
36395: PPUSH
36396: LD_VAR 0 4
36400: PPUSH
36401: EMPTY
36402: PPUSH
36403: CALL_OW 1
36407: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36408: LD_ADDR_EXP 118
36412: PUSH
36413: LD_EXP 118
36417: PPUSH
36418: LD_VAR 0 4
36422: PPUSH
36423: EMPTY
36424: PPUSH
36425: CALL_OW 1
36429: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36430: LD_ADDR_EXP 119
36434: PUSH
36435: LD_EXP 119
36439: PPUSH
36440: LD_VAR 0 4
36444: PPUSH
36445: EMPTY
36446: PPUSH
36447: CALL_OW 1
36451: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36452: LD_ADDR_EXP 120
36456: PUSH
36457: LD_EXP 120
36461: PPUSH
36462: LD_VAR 0 4
36466: PPUSH
36467: EMPTY
36468: PPUSH
36469: CALL_OW 1
36473: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36474: LD_ADDR_EXP 121
36478: PUSH
36479: LD_EXP 121
36483: PPUSH
36484: LD_VAR 0 4
36488: PPUSH
36489: EMPTY
36490: PPUSH
36491: CALL_OW 1
36495: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36496: LD_ADDR_EXP 122
36500: PUSH
36501: LD_EXP 122
36505: PPUSH
36506: LD_VAR 0 4
36510: PPUSH
36511: LD_INT 0
36513: PPUSH
36514: CALL_OW 1
36518: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36519: LD_ADDR_EXP 123
36523: PUSH
36524: LD_EXP 123
36528: PPUSH
36529: LD_VAR 0 4
36533: PPUSH
36534: EMPTY
36535: PPUSH
36536: CALL_OW 1
36540: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36541: LD_ADDR_EXP 124
36545: PUSH
36546: LD_EXP 124
36550: PPUSH
36551: LD_VAR 0 4
36555: PPUSH
36556: EMPTY
36557: PPUSH
36558: CALL_OW 1
36562: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36563: LD_ADDR_EXP 125
36567: PUSH
36568: LD_EXP 125
36572: PPUSH
36573: LD_VAR 0 4
36577: PPUSH
36578: EMPTY
36579: PPUSH
36580: CALL_OW 1
36584: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36585: LD_ADDR_EXP 126
36589: PUSH
36590: LD_EXP 126
36594: PPUSH
36595: LD_VAR 0 4
36599: PPUSH
36600: EMPTY
36601: PPUSH
36602: CALL_OW 1
36606: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36607: LD_ADDR_EXP 127
36611: PUSH
36612: LD_EXP 127
36616: PPUSH
36617: LD_VAR 0 4
36621: PPUSH
36622: EMPTY
36623: PPUSH
36624: CALL_OW 1
36628: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36629: LD_ADDR_EXP 128
36633: PUSH
36634: LD_EXP 128
36638: PPUSH
36639: LD_VAR 0 4
36643: PPUSH
36644: EMPTY
36645: PPUSH
36646: CALL_OW 1
36650: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36651: LD_ADDR_EXP 129
36655: PUSH
36656: LD_EXP 129
36660: PPUSH
36661: LD_VAR 0 4
36665: PPUSH
36666: EMPTY
36667: PPUSH
36668: CALL_OW 1
36672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36673: LD_ADDR_EXP 130
36677: PUSH
36678: LD_EXP 130
36682: PPUSH
36683: LD_VAR 0 4
36687: PPUSH
36688: EMPTY
36689: PPUSH
36690: CALL_OW 1
36694: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36695: LD_ADDR_EXP 131
36699: PUSH
36700: LD_EXP 131
36704: PPUSH
36705: LD_VAR 0 4
36709: PPUSH
36710: EMPTY
36711: PPUSH
36712: CALL_OW 1
36716: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36717: LD_ADDR_EXP 132
36721: PUSH
36722: LD_EXP 132
36726: PPUSH
36727: LD_VAR 0 4
36731: PPUSH
36732: EMPTY
36733: PPUSH
36734: CALL_OW 1
36738: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36739: LD_ADDR_EXP 133
36743: PUSH
36744: LD_EXP 133
36748: PPUSH
36749: LD_VAR 0 4
36753: PPUSH
36754: EMPTY
36755: PPUSH
36756: CALL_OW 1
36760: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36761: LD_ADDR_EXP 134
36765: PUSH
36766: LD_EXP 134
36770: PPUSH
36771: LD_VAR 0 4
36775: PPUSH
36776: EMPTY
36777: PPUSH
36778: CALL_OW 1
36782: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36783: LD_ADDR_EXP 135
36787: PUSH
36788: LD_EXP 135
36792: PPUSH
36793: LD_VAR 0 4
36797: PPUSH
36798: EMPTY
36799: PPUSH
36800: CALL_OW 1
36804: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36805: LD_ADDR_EXP 136
36809: PUSH
36810: LD_EXP 136
36814: PPUSH
36815: LD_VAR 0 4
36819: PPUSH
36820: EMPTY
36821: PPUSH
36822: CALL_OW 1
36826: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36827: LD_ADDR_EXP 138
36831: PUSH
36832: LD_EXP 138
36836: PPUSH
36837: LD_VAR 0 4
36841: PPUSH
36842: EMPTY
36843: PPUSH
36844: CALL_OW 1
36848: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36849: LD_ADDR_EXP 140
36853: PUSH
36854: LD_EXP 140
36858: PPUSH
36859: LD_VAR 0 4
36863: PPUSH
36864: EMPTY
36865: PPUSH
36866: CALL_OW 1
36870: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36871: LD_ADDR_EXP 141
36875: PUSH
36876: LD_EXP 141
36880: PPUSH
36881: LD_VAR 0 4
36885: PPUSH
36886: EMPTY
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36893: LD_ADDR_EXP 142
36897: PUSH
36898: LD_EXP 142
36902: PPUSH
36903: LD_VAR 0 4
36907: PPUSH
36908: EMPTY
36909: PPUSH
36910: CALL_OW 1
36914: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36915: LD_ADDR_EXP 143
36919: PUSH
36920: LD_EXP 143
36924: PPUSH
36925: LD_VAR 0 4
36929: PPUSH
36930: EMPTY
36931: PPUSH
36932: CALL_OW 1
36936: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36937: LD_ADDR_EXP 144
36941: PUSH
36942: LD_EXP 144
36946: PPUSH
36947: LD_VAR 0 4
36951: PPUSH
36952: EMPTY
36953: PPUSH
36954: CALL_OW 1
36958: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36959: LD_ADDR_EXP 145
36963: PUSH
36964: LD_EXP 145
36968: PPUSH
36969: LD_VAR 0 4
36973: PPUSH
36974: EMPTY
36975: PPUSH
36976: CALL_OW 1
36980: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36981: LD_ADDR_EXP 146
36985: PUSH
36986: LD_EXP 146
36990: PPUSH
36991: LD_VAR 0 4
36995: PPUSH
36996: EMPTY
36997: PPUSH
36998: CALL_OW 1
37002: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37003: LD_ADDR_EXP 147
37007: PUSH
37008: LD_EXP 147
37012: PPUSH
37013: LD_VAR 0 4
37017: PPUSH
37018: EMPTY
37019: PPUSH
37020: CALL_OW 1
37024: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37025: LD_ADDR_EXP 148
37029: PUSH
37030: LD_EXP 148
37034: PPUSH
37035: LD_VAR 0 4
37039: PPUSH
37040: EMPTY
37041: PPUSH
37042: CALL_OW 1
37046: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37047: LD_ADDR_EXP 149
37051: PUSH
37052: LD_EXP 149
37056: PPUSH
37057: LD_VAR 0 4
37061: PPUSH
37062: EMPTY
37063: PPUSH
37064: CALL_OW 1
37068: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37069: LD_ADDR_EXP 150
37073: PUSH
37074: LD_EXP 150
37078: PPUSH
37079: LD_VAR 0 4
37083: PPUSH
37084: EMPTY
37085: PPUSH
37086: CALL_OW 1
37090: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37091: LD_ADDR_EXP 151
37095: PUSH
37096: LD_EXP 151
37100: PPUSH
37101: LD_VAR 0 4
37105: PPUSH
37106: EMPTY
37107: PPUSH
37108: CALL_OW 1
37112: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37113: LD_ADDR_EXP 152
37117: PUSH
37118: LD_EXP 152
37122: PPUSH
37123: LD_VAR 0 4
37127: PPUSH
37128: EMPTY
37129: PPUSH
37130: CALL_OW 1
37134: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37135: LD_ADDR_EXP 153
37139: PUSH
37140: LD_EXP 153
37144: PPUSH
37145: LD_VAR 0 4
37149: PPUSH
37150: LD_INT 0
37152: PPUSH
37153: CALL_OW 1
37157: ST_TO_ADDR
// result := base ;
37158: LD_ADDR_VAR 0 3
37162: PUSH
37163: LD_VAR 0 4
37167: ST_TO_ADDR
// end ;
37168: LD_VAR 0 3
37172: RET
// export function MC_Start ( ) ; var i ; begin
37173: LD_INT 0
37175: PPUSH
37176: PPUSH
// for i = 1 to mc_bases do
37177: LD_ADDR_VAR 0 2
37181: PUSH
37182: DOUBLE
37183: LD_INT 1
37185: DEC
37186: ST_TO_ADDR
37187: LD_EXP 111
37191: PUSH
37192: FOR_TO
37193: IFFALSE 38270
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37195: LD_ADDR_EXP 111
37199: PUSH
37200: LD_EXP 111
37204: PPUSH
37205: LD_VAR 0 2
37209: PPUSH
37210: LD_EXP 111
37214: PUSH
37215: LD_VAR 0 2
37219: ARRAY
37220: PUSH
37221: LD_INT 0
37223: DIFF
37224: PPUSH
37225: CALL_OW 1
37229: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37230: LD_ADDR_EXP 112
37234: PUSH
37235: LD_EXP 112
37239: PPUSH
37240: LD_VAR 0 2
37244: PPUSH
37245: EMPTY
37246: PPUSH
37247: CALL_OW 1
37251: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37252: LD_ADDR_EXP 113
37256: PUSH
37257: LD_EXP 113
37261: PPUSH
37262: LD_VAR 0 2
37266: PPUSH
37267: EMPTY
37268: PPUSH
37269: CALL_OW 1
37273: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37274: LD_ADDR_EXP 114
37278: PUSH
37279: LD_EXP 114
37283: PPUSH
37284: LD_VAR 0 2
37288: PPUSH
37289: EMPTY
37290: PPUSH
37291: CALL_OW 1
37295: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37296: LD_ADDR_EXP 115
37300: PUSH
37301: LD_EXP 115
37305: PPUSH
37306: LD_VAR 0 2
37310: PPUSH
37311: EMPTY
37312: PUSH
37313: EMPTY
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PPUSH
37319: CALL_OW 1
37323: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37324: LD_ADDR_EXP 116
37328: PUSH
37329: LD_EXP 116
37333: PPUSH
37334: LD_VAR 0 2
37338: PPUSH
37339: EMPTY
37340: PPUSH
37341: CALL_OW 1
37345: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37346: LD_ADDR_EXP 143
37350: PUSH
37351: LD_EXP 143
37355: PPUSH
37356: LD_VAR 0 2
37360: PPUSH
37361: EMPTY
37362: PPUSH
37363: CALL_OW 1
37367: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37368: LD_ADDR_EXP 117
37372: PUSH
37373: LD_EXP 117
37377: PPUSH
37378: LD_VAR 0 2
37382: PPUSH
37383: EMPTY
37384: PPUSH
37385: CALL_OW 1
37389: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37390: LD_ADDR_EXP 118
37394: PUSH
37395: LD_EXP 118
37399: PPUSH
37400: LD_VAR 0 2
37404: PPUSH
37405: EMPTY
37406: PPUSH
37407: CALL_OW 1
37411: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37412: LD_ADDR_EXP 119
37416: PUSH
37417: LD_EXP 119
37421: PPUSH
37422: LD_VAR 0 2
37426: PPUSH
37427: LD_EXP 111
37431: PUSH
37432: LD_VAR 0 2
37436: ARRAY
37437: PPUSH
37438: LD_INT 2
37440: PUSH
37441: LD_INT 30
37443: PUSH
37444: LD_INT 32
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 30
37453: PUSH
37454: LD_INT 33
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: PPUSH
37466: CALL_OW 72
37470: PPUSH
37471: CALL_OW 1
37475: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37476: LD_ADDR_EXP 120
37480: PUSH
37481: LD_EXP 120
37485: PPUSH
37486: LD_VAR 0 2
37490: PPUSH
37491: LD_EXP 111
37495: PUSH
37496: LD_VAR 0 2
37500: ARRAY
37501: PPUSH
37502: LD_INT 2
37504: PUSH
37505: LD_INT 30
37507: PUSH
37508: LD_INT 32
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 30
37517: PUSH
37518: LD_INT 31
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 58
37532: PUSH
37533: EMPTY
37534: LIST
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PPUSH
37540: CALL_OW 72
37544: PPUSH
37545: CALL_OW 1
37549: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37550: LD_ADDR_EXP 121
37554: PUSH
37555: LD_EXP 121
37559: PPUSH
37560: LD_VAR 0 2
37564: PPUSH
37565: EMPTY
37566: PPUSH
37567: CALL_OW 1
37571: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37572: LD_ADDR_EXP 125
37576: PUSH
37577: LD_EXP 125
37581: PPUSH
37582: LD_VAR 0 2
37586: PPUSH
37587: EMPTY
37588: PPUSH
37589: CALL_OW 1
37593: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37594: LD_ADDR_EXP 124
37598: PUSH
37599: LD_EXP 124
37603: PPUSH
37604: LD_VAR 0 2
37608: PPUSH
37609: EMPTY
37610: PPUSH
37611: CALL_OW 1
37615: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37616: LD_ADDR_EXP 126
37620: PUSH
37621: LD_EXP 126
37625: PPUSH
37626: LD_VAR 0 2
37630: PPUSH
37631: EMPTY
37632: PPUSH
37633: CALL_OW 1
37637: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37638: LD_ADDR_EXP 127
37642: PUSH
37643: LD_EXP 127
37647: PPUSH
37648: LD_VAR 0 2
37652: PPUSH
37653: EMPTY
37654: PPUSH
37655: CALL_OW 1
37659: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37660: LD_ADDR_EXP 128
37664: PUSH
37665: LD_EXP 128
37669: PPUSH
37670: LD_VAR 0 2
37674: PPUSH
37675: EMPTY
37676: PPUSH
37677: CALL_OW 1
37681: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37682: LD_ADDR_EXP 129
37686: PUSH
37687: LD_EXP 129
37691: PPUSH
37692: LD_VAR 0 2
37696: PPUSH
37697: EMPTY
37698: PPUSH
37699: CALL_OW 1
37703: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37704: LD_ADDR_EXP 130
37708: PUSH
37709: LD_EXP 130
37713: PPUSH
37714: LD_VAR 0 2
37718: PPUSH
37719: EMPTY
37720: PPUSH
37721: CALL_OW 1
37725: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37726: LD_ADDR_EXP 131
37730: PUSH
37731: LD_EXP 131
37735: PPUSH
37736: LD_VAR 0 2
37740: PPUSH
37741: EMPTY
37742: PPUSH
37743: CALL_OW 1
37747: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37748: LD_ADDR_EXP 132
37752: PUSH
37753: LD_EXP 132
37757: PPUSH
37758: LD_VAR 0 2
37762: PPUSH
37763: EMPTY
37764: PPUSH
37765: CALL_OW 1
37769: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37770: LD_ADDR_EXP 133
37774: PUSH
37775: LD_EXP 133
37779: PPUSH
37780: LD_VAR 0 2
37784: PPUSH
37785: EMPTY
37786: PPUSH
37787: CALL_OW 1
37791: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37792: LD_ADDR_EXP 122
37796: PUSH
37797: LD_EXP 122
37801: PPUSH
37802: LD_VAR 0 2
37806: PPUSH
37807: LD_INT 0
37809: PPUSH
37810: CALL_OW 1
37814: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37815: LD_ADDR_EXP 135
37819: PUSH
37820: LD_EXP 135
37824: PPUSH
37825: LD_VAR 0 2
37829: PPUSH
37830: LD_INT 0
37832: PPUSH
37833: CALL_OW 1
37837: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37838: LD_ADDR_EXP 123
37842: PUSH
37843: LD_EXP 123
37847: PPUSH
37848: LD_VAR 0 2
37852: PPUSH
37853: EMPTY
37854: PPUSH
37855: CALL_OW 1
37859: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37860: LD_ADDR_EXP 134
37864: PUSH
37865: LD_EXP 134
37869: PPUSH
37870: LD_VAR 0 2
37874: PPUSH
37875: LD_INT 0
37877: PPUSH
37878: CALL_OW 1
37882: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37883: LD_ADDR_EXP 136
37887: PUSH
37888: LD_EXP 136
37892: PPUSH
37893: LD_VAR 0 2
37897: PPUSH
37898: EMPTY
37899: PPUSH
37900: CALL_OW 1
37904: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37905: LD_ADDR_EXP 139
37909: PUSH
37910: LD_EXP 139
37914: PPUSH
37915: LD_VAR 0 2
37919: PPUSH
37920: LD_INT 0
37922: PPUSH
37923: CALL_OW 1
37927: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37928: LD_ADDR_EXP 140
37932: PUSH
37933: LD_EXP 140
37937: PPUSH
37938: LD_VAR 0 2
37942: PPUSH
37943: EMPTY
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37950: LD_ADDR_EXP 141
37954: PUSH
37955: LD_EXP 141
37959: PPUSH
37960: LD_VAR 0 2
37964: PPUSH
37965: EMPTY
37966: PPUSH
37967: CALL_OW 1
37971: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37972: LD_ADDR_EXP 142
37976: PUSH
37977: LD_EXP 142
37981: PPUSH
37982: LD_VAR 0 2
37986: PPUSH
37987: EMPTY
37988: PPUSH
37989: CALL_OW 1
37993: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37994: LD_ADDR_EXP 144
37998: PUSH
37999: LD_EXP 144
38003: PPUSH
38004: LD_VAR 0 2
38008: PPUSH
38009: LD_EXP 111
38013: PUSH
38014: LD_VAR 0 2
38018: ARRAY
38019: PPUSH
38020: LD_INT 2
38022: PUSH
38023: LD_INT 30
38025: PUSH
38026: LD_INT 6
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 30
38035: PUSH
38036: LD_INT 7
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 30
38045: PUSH
38046: LD_INT 8
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: PPUSH
38059: CALL_OW 72
38063: PPUSH
38064: CALL_OW 1
38068: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38069: LD_ADDR_EXP 145
38073: PUSH
38074: LD_EXP 145
38078: PPUSH
38079: LD_VAR 0 2
38083: PPUSH
38084: EMPTY
38085: PPUSH
38086: CALL_OW 1
38090: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38091: LD_ADDR_EXP 146
38095: PUSH
38096: LD_EXP 146
38100: PPUSH
38101: LD_VAR 0 2
38105: PPUSH
38106: EMPTY
38107: PPUSH
38108: CALL_OW 1
38112: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38113: LD_ADDR_EXP 147
38117: PUSH
38118: LD_EXP 147
38122: PPUSH
38123: LD_VAR 0 2
38127: PPUSH
38128: EMPTY
38129: PPUSH
38130: CALL_OW 1
38134: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38135: LD_ADDR_EXP 148
38139: PUSH
38140: LD_EXP 148
38144: PPUSH
38145: LD_VAR 0 2
38149: PPUSH
38150: EMPTY
38151: PPUSH
38152: CALL_OW 1
38156: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38157: LD_ADDR_EXP 149
38161: PUSH
38162: LD_EXP 149
38166: PPUSH
38167: LD_VAR 0 2
38171: PPUSH
38172: EMPTY
38173: PPUSH
38174: CALL_OW 1
38178: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38179: LD_ADDR_EXP 150
38183: PUSH
38184: LD_EXP 150
38188: PPUSH
38189: LD_VAR 0 2
38193: PPUSH
38194: EMPTY
38195: PPUSH
38196: CALL_OW 1
38200: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38201: LD_ADDR_EXP 151
38205: PUSH
38206: LD_EXP 151
38210: PPUSH
38211: LD_VAR 0 2
38215: PPUSH
38216: EMPTY
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38223: LD_ADDR_EXP 152
38227: PUSH
38228: LD_EXP 152
38232: PPUSH
38233: LD_VAR 0 2
38237: PPUSH
38238: EMPTY
38239: PPUSH
38240: CALL_OW 1
38244: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38245: LD_ADDR_EXP 153
38249: PUSH
38250: LD_EXP 153
38254: PPUSH
38255: LD_VAR 0 2
38259: PPUSH
38260: LD_INT 0
38262: PPUSH
38263: CALL_OW 1
38267: ST_TO_ADDR
// end ;
38268: GO 37192
38270: POP
38271: POP
// MC_InitSides ( ) ;
38272: CALL 38558 0 0
// MC_InitResearch ( ) ;
38276: CALL 38297 0 0
// CustomInitMacro ( ) ;
38280: CALL 467 0 0
// skirmish := true ;
38284: LD_ADDR_EXP 109
38288: PUSH
38289: LD_INT 1
38291: ST_TO_ADDR
// end ;
38292: LD_VAR 0 1
38296: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38297: LD_INT 0
38299: PPUSH
38300: PPUSH
38301: PPUSH
38302: PPUSH
38303: PPUSH
38304: PPUSH
// if not mc_bases then
38305: LD_EXP 111
38309: NOT
38310: IFFALSE 38314
// exit ;
38312: GO 38553
// for i = 1 to 8 do
38314: LD_ADDR_VAR 0 2
38318: PUSH
38319: DOUBLE
38320: LD_INT 1
38322: DEC
38323: ST_TO_ADDR
38324: LD_INT 8
38326: PUSH
38327: FOR_TO
38328: IFFALSE 38354
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38330: LD_ADDR_EXP 138
38334: PUSH
38335: LD_EXP 138
38339: PPUSH
38340: LD_VAR 0 2
38344: PPUSH
38345: EMPTY
38346: PPUSH
38347: CALL_OW 1
38351: ST_TO_ADDR
38352: GO 38327
38354: POP
38355: POP
// tmp := [ ] ;
38356: LD_ADDR_VAR 0 5
38360: PUSH
38361: EMPTY
38362: ST_TO_ADDR
// for i = 1 to mc_sides do
38363: LD_ADDR_VAR 0 2
38367: PUSH
38368: DOUBLE
38369: LD_INT 1
38371: DEC
38372: ST_TO_ADDR
38373: LD_EXP 137
38377: PUSH
38378: FOR_TO
38379: IFFALSE 38437
// if not mc_sides [ i ] in tmp then
38381: LD_EXP 137
38385: PUSH
38386: LD_VAR 0 2
38390: ARRAY
38391: PUSH
38392: LD_VAR 0 5
38396: IN
38397: NOT
38398: IFFALSE 38435
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38400: LD_ADDR_VAR 0 5
38404: PUSH
38405: LD_VAR 0 5
38409: PPUSH
38410: LD_VAR 0 5
38414: PUSH
38415: LD_INT 1
38417: PLUS
38418: PPUSH
38419: LD_EXP 137
38423: PUSH
38424: LD_VAR 0 2
38428: ARRAY
38429: PPUSH
38430: CALL_OW 2
38434: ST_TO_ADDR
38435: GO 38378
38437: POP
38438: POP
// if not tmp then
38439: LD_VAR 0 5
38443: NOT
38444: IFFALSE 38448
// exit ;
38446: GO 38553
// for j in tmp do
38448: LD_ADDR_VAR 0 3
38452: PUSH
38453: LD_VAR 0 5
38457: PUSH
38458: FOR_IN
38459: IFFALSE 38551
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38461: LD_ADDR_VAR 0 6
38465: PUSH
38466: LD_INT 22
38468: PUSH
38469: LD_VAR 0 3
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PPUSH
38478: CALL_OW 69
38482: ST_TO_ADDR
// if not un then
38483: LD_VAR 0 6
38487: NOT
38488: IFFALSE 38492
// continue ;
38490: GO 38458
// nation := GetNation ( un [ 1 ] ) ;
38492: LD_ADDR_VAR 0 4
38496: PUSH
38497: LD_VAR 0 6
38501: PUSH
38502: LD_INT 1
38504: ARRAY
38505: PPUSH
38506: CALL_OW 248
38510: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38511: LD_ADDR_EXP 138
38515: PUSH
38516: LD_EXP 138
38520: PPUSH
38521: LD_VAR 0 3
38525: PPUSH
38526: LD_VAR 0 3
38530: PPUSH
38531: LD_VAR 0 4
38535: PPUSH
38536: LD_INT 1
38538: PPUSH
38539: CALL 65147 0 3
38543: PPUSH
38544: CALL_OW 1
38548: ST_TO_ADDR
// end ;
38549: GO 38458
38551: POP
38552: POP
// end ;
38553: LD_VAR 0 1
38557: RET
// export function MC_InitSides ( ) ; var i ; begin
38558: LD_INT 0
38560: PPUSH
38561: PPUSH
// if not mc_bases then
38562: LD_EXP 111
38566: NOT
38567: IFFALSE 38571
// exit ;
38569: GO 38645
// for i = 1 to mc_bases do
38571: LD_ADDR_VAR 0 2
38575: PUSH
38576: DOUBLE
38577: LD_INT 1
38579: DEC
38580: ST_TO_ADDR
38581: LD_EXP 111
38585: PUSH
38586: FOR_TO
38587: IFFALSE 38643
// if mc_bases [ i ] then
38589: LD_EXP 111
38593: PUSH
38594: LD_VAR 0 2
38598: ARRAY
38599: IFFALSE 38641
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38601: LD_ADDR_EXP 137
38605: PUSH
38606: LD_EXP 137
38610: PPUSH
38611: LD_VAR 0 2
38615: PPUSH
38616: LD_EXP 111
38620: PUSH
38621: LD_VAR 0 2
38625: ARRAY
38626: PUSH
38627: LD_INT 1
38629: ARRAY
38630: PPUSH
38631: CALL_OW 255
38635: PPUSH
38636: CALL_OW 1
38640: ST_TO_ADDR
38641: GO 38586
38643: POP
38644: POP
// end ;
38645: LD_VAR 0 1
38649: RET
// every 0 0$01 trigger skirmish do
38650: LD_EXP 109
38654: IFFALSE 38808
38656: GO 38658
38658: DISABLE
// begin enable ;
38659: ENABLE
// MC_CheckBuildings ( ) ;
38660: CALL 43306 0 0
// MC_CheckPeopleLife ( ) ;
38664: CALL 43431 0 0
// RaiseSailEvent ( 100 ) ;
38668: LD_INT 100
38670: PPUSH
38671: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38675: LD_INT 103
38677: PPUSH
38678: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38682: LD_INT 104
38684: PPUSH
38685: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38689: LD_INT 105
38691: PPUSH
38692: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38696: LD_INT 106
38698: PPUSH
38699: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38703: LD_INT 107
38705: PPUSH
38706: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38710: LD_INT 108
38712: PPUSH
38713: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38717: LD_INT 109
38719: PPUSH
38720: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38724: LD_INT 110
38726: PPUSH
38727: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38731: LD_INT 111
38733: PPUSH
38734: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38738: LD_INT 112
38740: PPUSH
38741: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38745: LD_INT 113
38747: PPUSH
38748: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38752: LD_INT 120
38754: PPUSH
38755: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38759: LD_INT 121
38761: PPUSH
38762: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38766: LD_INT 122
38768: PPUSH
38769: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38773: LD_INT 123
38775: PPUSH
38776: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38780: LD_INT 124
38782: PPUSH
38783: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38787: LD_INT 125
38789: PPUSH
38790: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38794: LD_INT 126
38796: PPUSH
38797: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38801: LD_INT 200
38803: PPUSH
38804: CALL_OW 427
// end ;
38808: END
// on SailEvent ( event ) do begin if event < 100 then
38809: LD_VAR 0 1
38813: PUSH
38814: LD_INT 100
38816: LESS
38817: IFFALSE 38828
// CustomEvent ( event ) ;
38819: LD_VAR 0 1
38823: PPUSH
38824: CALL 33403 0 1
// if event = 100 then
38828: LD_VAR 0 1
38832: PUSH
38833: LD_INT 100
38835: EQUAL
38836: IFFALSE 38842
// MC_ClassManager ( ) ;
38838: CALL 39234 0 0
// if event = 101 then
38842: LD_VAR 0 1
38846: PUSH
38847: LD_INT 101
38849: EQUAL
38850: IFFALSE 38856
// MC_RepairBuildings ( ) ;
38852: CALL 44016 0 0
// if event = 102 then
38856: LD_VAR 0 1
38860: PUSH
38861: LD_INT 102
38863: EQUAL
38864: IFFALSE 38870
// MC_Heal ( ) ;
38866: CALL 44875 0 0
// if event = 103 then
38870: LD_VAR 0 1
38874: PUSH
38875: LD_INT 103
38877: EQUAL
38878: IFFALSE 38884
// MC_Build ( ) ;
38880: CALL 45297 0 0
// if event = 104 then
38884: LD_VAR 0 1
38888: PUSH
38889: LD_INT 104
38891: EQUAL
38892: IFFALSE 38898
// MC_TurretWeapon ( ) ;
38894: CALL 46910 0 0
// if event = 105 then
38898: LD_VAR 0 1
38902: PUSH
38903: LD_INT 105
38905: EQUAL
38906: IFFALSE 38912
// MC_BuildUpgrade ( ) ;
38908: CALL 46461 0 0
// if event = 106 then
38912: LD_VAR 0 1
38916: PUSH
38917: LD_INT 106
38919: EQUAL
38920: IFFALSE 38926
// MC_PlantMines ( ) ;
38922: CALL 47340 0 0
// if event = 107 then
38926: LD_VAR 0 1
38930: PUSH
38931: LD_INT 107
38933: EQUAL
38934: IFFALSE 38940
// MC_CollectCrates ( ) ;
38936: CALL 48138 0 0
// if event = 108 then
38940: LD_VAR 0 1
38944: PUSH
38945: LD_INT 108
38947: EQUAL
38948: IFFALSE 38954
// MC_LinkRemoteControl ( ) ;
38950: CALL 49914 0 0
// if event = 109 then
38954: LD_VAR 0 1
38958: PUSH
38959: LD_INT 109
38961: EQUAL
38962: IFFALSE 38968
// MC_ProduceVehicle ( ) ;
38964: CALL 50095 0 0
// if event = 110 then
38968: LD_VAR 0 1
38972: PUSH
38973: LD_INT 110
38975: EQUAL
38976: IFFALSE 38982
// MC_SendAttack ( ) ;
38978: CALL 50561 0 0
// if event = 111 then
38982: LD_VAR 0 1
38986: PUSH
38987: LD_INT 111
38989: EQUAL
38990: IFFALSE 38996
// MC_Defend ( ) ;
38992: CALL 50669 0 0
// if event = 112 then
38996: LD_VAR 0 1
39000: PUSH
39001: LD_INT 112
39003: EQUAL
39004: IFFALSE 39010
// MC_Research ( ) ;
39006: CALL 51274 0 0
// if event = 113 then
39010: LD_VAR 0 1
39014: PUSH
39015: LD_INT 113
39017: EQUAL
39018: IFFALSE 39024
// MC_MinesTrigger ( ) ;
39020: CALL 52388 0 0
// if event = 120 then
39024: LD_VAR 0 1
39028: PUSH
39029: LD_INT 120
39031: EQUAL
39032: IFFALSE 39038
// MC_RepairVehicle ( ) ;
39034: CALL 52487 0 0
// if event = 121 then
39038: LD_VAR 0 1
39042: PUSH
39043: LD_INT 121
39045: EQUAL
39046: IFFALSE 39052
// MC_TameApe ( ) ;
39048: CALL 53217 0 0
// if event = 122 then
39052: LD_VAR 0 1
39056: PUSH
39057: LD_INT 122
39059: EQUAL
39060: IFFALSE 39066
// MC_ChangeApeClass ( ) ;
39062: CALL 54046 0 0
// if event = 123 then
39066: LD_VAR 0 1
39070: PUSH
39071: LD_INT 123
39073: EQUAL
39074: IFFALSE 39080
// MC_Bazooka ( ) ;
39076: CALL 54696 0 0
// if event = 124 then
39080: LD_VAR 0 1
39084: PUSH
39085: LD_INT 124
39087: EQUAL
39088: IFFALSE 39094
// MC_TeleportExit ( ) ;
39090: CALL 54894 0 0
// if event = 125 then
39094: LD_VAR 0 1
39098: PUSH
39099: LD_INT 125
39101: EQUAL
39102: IFFALSE 39108
// MC_Deposits ( ) ;
39104: CALL 55541 0 0
// if event = 126 then
39108: LD_VAR 0 1
39112: PUSH
39113: LD_INT 126
39115: EQUAL
39116: IFFALSE 39122
// MC_RemoteDriver ( ) ;
39118: CALL 56166 0 0
// if event = 200 then
39122: LD_VAR 0 1
39126: PUSH
39127: LD_INT 200
39129: EQUAL
39130: IFFALSE 39136
// MC_Idle ( ) ;
39132: CALL 58115 0 0
// end ;
39136: PPOPN 1
39138: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39139: LD_INT 0
39141: PPUSH
39142: PPUSH
// if not mc_bases [ base ] or not tag then
39143: LD_EXP 111
39147: PUSH
39148: LD_VAR 0 1
39152: ARRAY
39153: NOT
39154: PUSH
39155: LD_VAR 0 2
39159: NOT
39160: OR
39161: IFFALSE 39165
// exit ;
39163: GO 39229
// for i in mc_bases [ base ] union mc_ape [ base ] do
39165: LD_ADDR_VAR 0 4
39169: PUSH
39170: LD_EXP 111
39174: PUSH
39175: LD_VAR 0 1
39179: ARRAY
39180: PUSH
39181: LD_EXP 140
39185: PUSH
39186: LD_VAR 0 1
39190: ARRAY
39191: UNION
39192: PUSH
39193: FOR_IN
39194: IFFALSE 39227
// if GetTag ( i ) = tag then
39196: LD_VAR 0 4
39200: PPUSH
39201: CALL_OW 110
39205: PUSH
39206: LD_VAR 0 2
39210: EQUAL
39211: IFFALSE 39225
// SetTag ( i , 0 ) ;
39213: LD_VAR 0 4
39217: PPUSH
39218: LD_INT 0
39220: PPUSH
39221: CALL_OW 109
39225: GO 39193
39227: POP
39228: POP
// end ;
39229: LD_VAR 0 3
39233: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39234: LD_INT 0
39236: PPUSH
39237: PPUSH
39238: PPUSH
39239: PPUSH
39240: PPUSH
39241: PPUSH
39242: PPUSH
39243: PPUSH
// if not mc_bases then
39244: LD_EXP 111
39248: NOT
39249: IFFALSE 39253
// exit ;
39251: GO 39711
// for i = 1 to mc_bases do
39253: LD_ADDR_VAR 0 2
39257: PUSH
39258: DOUBLE
39259: LD_INT 1
39261: DEC
39262: ST_TO_ADDR
39263: LD_EXP 111
39267: PUSH
39268: FOR_TO
39269: IFFALSE 39709
// begin tmp := MC_ClassCheckReq ( i ) ;
39271: LD_ADDR_VAR 0 4
39275: PUSH
39276: LD_VAR 0 2
39280: PPUSH
39281: CALL 39716 0 1
39285: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39286: LD_ADDR_EXP 152
39290: PUSH
39291: LD_EXP 152
39295: PPUSH
39296: LD_VAR 0 2
39300: PPUSH
39301: LD_VAR 0 4
39305: PPUSH
39306: CALL_OW 1
39310: ST_TO_ADDR
// if not tmp then
39311: LD_VAR 0 4
39315: NOT
39316: IFFALSE 39320
// continue ;
39318: GO 39268
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39320: LD_ADDR_VAR 0 6
39324: PUSH
39325: LD_EXP 111
39329: PUSH
39330: LD_VAR 0 2
39334: ARRAY
39335: PPUSH
39336: LD_INT 2
39338: PUSH
39339: LD_INT 30
39341: PUSH
39342: LD_INT 4
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 30
39351: PUSH
39352: LD_INT 5
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: PPUSH
39364: CALL_OW 72
39368: PUSH
39369: LD_EXP 111
39373: PUSH
39374: LD_VAR 0 2
39378: ARRAY
39379: PPUSH
39380: LD_INT 2
39382: PUSH
39383: LD_INT 30
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 30
39395: PUSH
39396: LD_INT 1
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: LIST
39407: PPUSH
39408: CALL_OW 72
39412: PUSH
39413: LD_EXP 111
39417: PUSH
39418: LD_VAR 0 2
39422: ARRAY
39423: PPUSH
39424: LD_INT 30
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PPUSH
39434: CALL_OW 72
39438: PUSH
39439: LD_EXP 111
39443: PUSH
39444: LD_VAR 0 2
39448: ARRAY
39449: PPUSH
39450: LD_INT 2
39452: PUSH
39453: LD_INT 30
39455: PUSH
39456: LD_INT 6
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 30
39465: PUSH
39466: LD_INT 7
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 30
39475: PUSH
39476: LD_INT 8
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: PPUSH
39489: CALL_OW 72
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: ST_TO_ADDR
// for j = 1 to 4 do
39500: LD_ADDR_VAR 0 3
39504: PUSH
39505: DOUBLE
39506: LD_INT 1
39508: DEC
39509: ST_TO_ADDR
39510: LD_INT 4
39512: PUSH
39513: FOR_TO
39514: IFFALSE 39705
// begin if not tmp [ j ] then
39516: LD_VAR 0 4
39520: PUSH
39521: LD_VAR 0 3
39525: ARRAY
39526: NOT
39527: IFFALSE 39531
// continue ;
39529: GO 39513
// for p in tmp [ j ] do
39531: LD_ADDR_VAR 0 5
39535: PUSH
39536: LD_VAR 0 4
39540: PUSH
39541: LD_VAR 0 3
39545: ARRAY
39546: PUSH
39547: FOR_IN
39548: IFFALSE 39701
// begin if not b [ j ] then
39550: LD_VAR 0 6
39554: PUSH
39555: LD_VAR 0 3
39559: ARRAY
39560: NOT
39561: IFFALSE 39565
// break ;
39563: GO 39701
// e := 0 ;
39565: LD_ADDR_VAR 0 7
39569: PUSH
39570: LD_INT 0
39572: ST_TO_ADDR
// for k in b [ j ] do
39573: LD_ADDR_VAR 0 8
39577: PUSH
39578: LD_VAR 0 6
39582: PUSH
39583: LD_VAR 0 3
39587: ARRAY
39588: PUSH
39589: FOR_IN
39590: IFFALSE 39617
// if IsNotFull ( k ) then
39592: LD_VAR 0 8
39596: PPUSH
39597: CALL 67296 0 1
39601: IFFALSE 39615
// begin e := k ;
39603: LD_ADDR_VAR 0 7
39607: PUSH
39608: LD_VAR 0 8
39612: ST_TO_ADDR
// break ;
39613: GO 39617
// end ;
39615: GO 39589
39617: POP
39618: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39619: LD_VAR 0 7
39623: PUSH
39624: LD_VAR 0 5
39628: PPUSH
39629: LD_VAR 0 7
39633: PPUSH
39634: CALL 99716 0 2
39638: NOT
39639: AND
39640: IFFALSE 39699
// begin if IsInUnit ( p ) then
39642: LD_VAR 0 5
39646: PPUSH
39647: CALL_OW 310
39651: IFFALSE 39662
// ComExitBuilding ( p ) ;
39653: LD_VAR 0 5
39657: PPUSH
39658: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39662: LD_VAR 0 5
39666: PPUSH
39667: LD_VAR 0 7
39671: PPUSH
39672: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39676: LD_VAR 0 5
39680: PPUSH
39681: LD_VAR 0 3
39685: PPUSH
39686: CALL_OW 183
// AddComExitBuilding ( p ) ;
39690: LD_VAR 0 5
39694: PPUSH
39695: CALL_OW 182
// end ; end ;
39699: GO 39547
39701: POP
39702: POP
// end ;
39703: GO 39513
39705: POP
39706: POP
// end ;
39707: GO 39268
39709: POP
39710: POP
// end ;
39711: LD_VAR 0 1
39715: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39716: LD_INT 0
39718: PPUSH
39719: PPUSH
39720: PPUSH
39721: PPUSH
39722: PPUSH
39723: PPUSH
39724: PPUSH
39725: PPUSH
39726: PPUSH
39727: PPUSH
39728: PPUSH
39729: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39730: LD_VAR 0 1
39734: NOT
39735: PUSH
39736: LD_EXP 111
39740: PUSH
39741: LD_VAR 0 1
39745: ARRAY
39746: NOT
39747: OR
39748: PUSH
39749: LD_EXP 111
39753: PUSH
39754: LD_VAR 0 1
39758: ARRAY
39759: PPUSH
39760: LD_INT 2
39762: PUSH
39763: LD_INT 30
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 30
39775: PUSH
39776: LD_INT 1
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: LIST
39787: PPUSH
39788: CALL_OW 72
39792: NOT
39793: OR
39794: IFFALSE 39798
// exit ;
39796: GO 43301
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39798: LD_ADDR_VAR 0 4
39802: PUSH
39803: LD_EXP 111
39807: PUSH
39808: LD_VAR 0 1
39812: ARRAY
39813: PPUSH
39814: LD_INT 2
39816: PUSH
39817: LD_INT 25
39819: PUSH
39820: LD_INT 1
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 25
39829: PUSH
39830: LD_INT 2
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 25
39839: PUSH
39840: LD_INT 3
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 25
39849: PUSH
39850: LD_INT 4
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 25
39859: PUSH
39860: LD_INT 5
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 25
39869: PUSH
39870: LD_INT 8
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 25
39879: PUSH
39880: LD_INT 9
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: PPUSH
39897: CALL_OW 72
39901: ST_TO_ADDR
// if not tmp then
39902: LD_VAR 0 4
39906: NOT
39907: IFFALSE 39911
// exit ;
39909: GO 43301
// for i in tmp do
39911: LD_ADDR_VAR 0 3
39915: PUSH
39916: LD_VAR 0 4
39920: PUSH
39921: FOR_IN
39922: IFFALSE 39953
// if GetTag ( i ) then
39924: LD_VAR 0 3
39928: PPUSH
39929: CALL_OW 110
39933: IFFALSE 39951
// tmp := tmp diff i ;
39935: LD_ADDR_VAR 0 4
39939: PUSH
39940: LD_VAR 0 4
39944: PUSH
39945: LD_VAR 0 3
39949: DIFF
39950: ST_TO_ADDR
39951: GO 39921
39953: POP
39954: POP
// if not tmp then
39955: LD_VAR 0 4
39959: NOT
39960: IFFALSE 39964
// exit ;
39962: GO 43301
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39964: LD_ADDR_VAR 0 5
39968: PUSH
39969: LD_EXP 111
39973: PUSH
39974: LD_VAR 0 1
39978: ARRAY
39979: PPUSH
39980: LD_INT 2
39982: PUSH
39983: LD_INT 25
39985: PUSH
39986: LD_INT 1
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 25
39995: PUSH
39996: LD_INT 5
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 25
40005: PUSH
40006: LD_INT 8
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 25
40015: PUSH
40016: LD_INT 9
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: PPUSH
40030: CALL_OW 72
40034: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40035: LD_ADDR_VAR 0 6
40039: PUSH
40040: LD_EXP 111
40044: PUSH
40045: LD_VAR 0 1
40049: ARRAY
40050: PPUSH
40051: LD_INT 25
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PPUSH
40061: CALL_OW 72
40065: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40066: LD_ADDR_VAR 0 7
40070: PUSH
40071: LD_EXP 111
40075: PUSH
40076: LD_VAR 0 1
40080: ARRAY
40081: PPUSH
40082: LD_INT 25
40084: PUSH
40085: LD_INT 3
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PPUSH
40092: CALL_OW 72
40096: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40097: LD_ADDR_VAR 0 8
40101: PUSH
40102: LD_EXP 111
40106: PUSH
40107: LD_VAR 0 1
40111: ARRAY
40112: PPUSH
40113: LD_INT 25
40115: PUSH
40116: LD_INT 4
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 24
40125: PUSH
40126: LD_INT 251
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PPUSH
40137: CALL_OW 72
40141: ST_TO_ADDR
// if mc_scan [ base ] then
40142: LD_EXP 134
40146: PUSH
40147: LD_VAR 0 1
40151: ARRAY
40152: IFFALSE 40613
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40154: LD_ADDR_EXP 153
40158: PUSH
40159: LD_EXP 153
40163: PPUSH
40164: LD_VAR 0 1
40168: PPUSH
40169: LD_INT 4
40171: PPUSH
40172: CALL_OW 1
40176: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40177: LD_ADDR_VAR 0 12
40181: PUSH
40182: LD_EXP 111
40186: PUSH
40187: LD_VAR 0 1
40191: ARRAY
40192: PPUSH
40193: LD_INT 2
40195: PUSH
40196: LD_INT 30
40198: PUSH
40199: LD_INT 4
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 30
40208: PUSH
40209: LD_INT 5
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: LIST
40220: PPUSH
40221: CALL_OW 72
40225: ST_TO_ADDR
// if not b then
40226: LD_VAR 0 12
40230: NOT
40231: IFFALSE 40235
// exit ;
40233: GO 43301
// p := [ ] ;
40235: LD_ADDR_VAR 0 11
40239: PUSH
40240: EMPTY
40241: ST_TO_ADDR
// if sci >= 2 then
40242: LD_VAR 0 8
40246: PUSH
40247: LD_INT 2
40249: GREATEREQUAL
40250: IFFALSE 40281
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40252: LD_ADDR_VAR 0 8
40256: PUSH
40257: LD_VAR 0 8
40261: PUSH
40262: LD_INT 1
40264: ARRAY
40265: PUSH
40266: LD_VAR 0 8
40270: PUSH
40271: LD_INT 2
40273: ARRAY
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: ST_TO_ADDR
40279: GO 40342
// if sci = 1 then
40281: LD_VAR 0 8
40285: PUSH
40286: LD_INT 1
40288: EQUAL
40289: IFFALSE 40310
// sci := [ sci [ 1 ] ] else
40291: LD_ADDR_VAR 0 8
40295: PUSH
40296: LD_VAR 0 8
40300: PUSH
40301: LD_INT 1
40303: ARRAY
40304: PUSH
40305: EMPTY
40306: LIST
40307: ST_TO_ADDR
40308: GO 40342
// if sci = 0 then
40310: LD_VAR 0 8
40314: PUSH
40315: LD_INT 0
40317: EQUAL
40318: IFFALSE 40342
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40320: LD_ADDR_VAR 0 11
40324: PUSH
40325: LD_VAR 0 4
40329: PPUSH
40330: LD_INT 4
40332: PPUSH
40333: CALL 99579 0 2
40337: PUSH
40338: LD_INT 1
40340: ARRAY
40341: ST_TO_ADDR
// if eng > 4 then
40342: LD_VAR 0 6
40346: PUSH
40347: LD_INT 4
40349: GREATER
40350: IFFALSE 40396
// for i = eng downto 4 do
40352: LD_ADDR_VAR 0 3
40356: PUSH
40357: DOUBLE
40358: LD_VAR 0 6
40362: INC
40363: ST_TO_ADDR
40364: LD_INT 4
40366: PUSH
40367: FOR_DOWNTO
40368: IFFALSE 40394
// eng := eng diff eng [ i ] ;
40370: LD_ADDR_VAR 0 6
40374: PUSH
40375: LD_VAR 0 6
40379: PUSH
40380: LD_VAR 0 6
40384: PUSH
40385: LD_VAR 0 3
40389: ARRAY
40390: DIFF
40391: ST_TO_ADDR
40392: GO 40367
40394: POP
40395: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40396: LD_ADDR_VAR 0 4
40400: PUSH
40401: LD_VAR 0 4
40405: PUSH
40406: LD_VAR 0 5
40410: PUSH
40411: LD_VAR 0 6
40415: UNION
40416: PUSH
40417: LD_VAR 0 7
40421: UNION
40422: PUSH
40423: LD_VAR 0 8
40427: UNION
40428: DIFF
40429: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40430: LD_ADDR_VAR 0 13
40434: PUSH
40435: LD_EXP 111
40439: PUSH
40440: LD_VAR 0 1
40444: ARRAY
40445: PPUSH
40446: LD_INT 2
40448: PUSH
40449: LD_INT 30
40451: PUSH
40452: LD_INT 32
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 30
40461: PUSH
40462: LD_INT 31
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: LIST
40473: PPUSH
40474: CALL_OW 72
40478: PUSH
40479: LD_EXP 111
40483: PUSH
40484: LD_VAR 0 1
40488: ARRAY
40489: PPUSH
40490: LD_INT 2
40492: PUSH
40493: LD_INT 30
40495: PUSH
40496: LD_INT 4
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 30
40505: PUSH
40506: LD_INT 5
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: LIST
40517: PPUSH
40518: CALL_OW 72
40522: PUSH
40523: LD_INT 6
40525: MUL
40526: PLUS
40527: ST_TO_ADDR
// if bcount < tmp then
40528: LD_VAR 0 13
40532: PUSH
40533: LD_VAR 0 4
40537: LESS
40538: IFFALSE 40584
// for i = tmp downto bcount do
40540: LD_ADDR_VAR 0 3
40544: PUSH
40545: DOUBLE
40546: LD_VAR 0 4
40550: INC
40551: ST_TO_ADDR
40552: LD_VAR 0 13
40556: PUSH
40557: FOR_DOWNTO
40558: IFFALSE 40582
// tmp := Delete ( tmp , tmp ) ;
40560: LD_ADDR_VAR 0 4
40564: PUSH
40565: LD_VAR 0 4
40569: PPUSH
40570: LD_VAR 0 4
40574: PPUSH
40575: CALL_OW 3
40579: ST_TO_ADDR
40580: GO 40557
40582: POP
40583: POP
// result := [ tmp , 0 , 0 , p ] ;
40584: LD_ADDR_VAR 0 2
40588: PUSH
40589: LD_VAR 0 4
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_VAR 0 11
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: ST_TO_ADDR
// exit ;
40611: GO 43301
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40613: LD_EXP 111
40617: PUSH
40618: LD_VAR 0 1
40622: ARRAY
40623: PPUSH
40624: LD_INT 2
40626: PUSH
40627: LD_INT 30
40629: PUSH
40630: LD_INT 6
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 30
40639: PUSH
40640: LD_INT 7
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 30
40649: PUSH
40650: LD_INT 8
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: PPUSH
40663: CALL_OW 72
40667: NOT
40668: PUSH
40669: LD_EXP 111
40673: PUSH
40674: LD_VAR 0 1
40678: ARRAY
40679: PPUSH
40680: LD_INT 30
40682: PUSH
40683: LD_INT 3
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PPUSH
40690: CALL_OW 72
40694: NOT
40695: AND
40696: IFFALSE 40768
// begin if eng = tmp then
40698: LD_VAR 0 6
40702: PUSH
40703: LD_VAR 0 4
40707: EQUAL
40708: IFFALSE 40712
// exit ;
40710: GO 43301
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40712: LD_ADDR_EXP 153
40716: PUSH
40717: LD_EXP 153
40721: PPUSH
40722: LD_VAR 0 1
40726: PPUSH
40727: LD_INT 1
40729: PPUSH
40730: CALL_OW 1
40734: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40735: LD_ADDR_VAR 0 2
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: LD_VAR 0 4
40747: PUSH
40748: LD_VAR 0 6
40752: DIFF
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: LD_INT 0
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: ST_TO_ADDR
// exit ;
40766: GO 43301
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40768: LD_EXP 138
40772: PUSH
40773: LD_EXP 137
40777: PUSH
40778: LD_VAR 0 1
40782: ARRAY
40783: ARRAY
40784: PUSH
40785: LD_EXP 111
40789: PUSH
40790: LD_VAR 0 1
40794: ARRAY
40795: PPUSH
40796: LD_INT 2
40798: PUSH
40799: LD_INT 30
40801: PUSH
40802: LD_INT 6
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 30
40811: PUSH
40812: LD_INT 7
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 30
40821: PUSH
40822: LD_INT 8
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: LIST
40833: LIST
40834: PPUSH
40835: CALL_OW 72
40839: AND
40840: PUSH
40841: LD_EXP 111
40845: PUSH
40846: LD_VAR 0 1
40850: ARRAY
40851: PPUSH
40852: LD_INT 30
40854: PUSH
40855: LD_INT 3
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PPUSH
40862: CALL_OW 72
40866: NOT
40867: AND
40868: IFFALSE 41082
// begin if sci >= 6 then
40870: LD_VAR 0 8
40874: PUSH
40875: LD_INT 6
40877: GREATEREQUAL
40878: IFFALSE 40882
// exit ;
40880: GO 43301
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40882: LD_ADDR_EXP 153
40886: PUSH
40887: LD_EXP 153
40891: PPUSH
40892: LD_VAR 0 1
40896: PPUSH
40897: LD_INT 2
40899: PPUSH
40900: CALL_OW 1
40904: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40905: LD_ADDR_VAR 0 9
40909: PUSH
40910: LD_VAR 0 4
40914: PUSH
40915: LD_VAR 0 8
40919: DIFF
40920: PPUSH
40921: LD_INT 4
40923: PPUSH
40924: CALL 99579 0 2
40928: ST_TO_ADDR
// p := [ ] ;
40929: LD_ADDR_VAR 0 11
40933: PUSH
40934: EMPTY
40935: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40936: LD_VAR 0 8
40940: PUSH
40941: LD_INT 6
40943: LESS
40944: PUSH
40945: LD_VAR 0 9
40949: PUSH
40950: LD_INT 6
40952: GREATER
40953: AND
40954: IFFALSE 41035
// begin for i = 1 to 6 - sci do
40956: LD_ADDR_VAR 0 3
40960: PUSH
40961: DOUBLE
40962: LD_INT 1
40964: DEC
40965: ST_TO_ADDR
40966: LD_INT 6
40968: PUSH
40969: LD_VAR 0 8
40973: MINUS
40974: PUSH
40975: FOR_TO
40976: IFFALSE 41031
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40978: LD_ADDR_VAR 0 11
40982: PUSH
40983: LD_VAR 0 11
40987: PPUSH
40988: LD_VAR 0 11
40992: PUSH
40993: LD_INT 1
40995: PLUS
40996: PPUSH
40997: LD_VAR 0 9
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 2
41010: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41011: LD_ADDR_VAR 0 9
41015: PUSH
41016: LD_VAR 0 9
41020: PPUSH
41021: LD_INT 1
41023: PPUSH
41024: CALL_OW 3
41028: ST_TO_ADDR
// end ;
41029: GO 40975
41031: POP
41032: POP
// end else
41033: GO 41055
// if sort then
41035: LD_VAR 0 9
41039: IFFALSE 41055
// p := sort [ 1 ] ;
41041: LD_ADDR_VAR 0 11
41045: PUSH
41046: LD_VAR 0 9
41050: PUSH
41051: LD_INT 1
41053: ARRAY
41054: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41055: LD_ADDR_VAR 0 2
41059: PUSH
41060: LD_INT 0
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: LD_INT 0
41068: PUSH
41069: LD_VAR 0 11
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: ST_TO_ADDR
// exit ;
41080: GO 43301
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41082: LD_EXP 138
41086: PUSH
41087: LD_EXP 137
41091: PUSH
41092: LD_VAR 0 1
41096: ARRAY
41097: ARRAY
41098: PUSH
41099: LD_EXP 111
41103: PUSH
41104: LD_VAR 0 1
41108: ARRAY
41109: PPUSH
41110: LD_INT 2
41112: PUSH
41113: LD_INT 30
41115: PUSH
41116: LD_INT 6
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 30
41125: PUSH
41126: LD_INT 7
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 30
41135: PUSH
41136: LD_INT 8
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: PPUSH
41149: CALL_OW 72
41153: AND
41154: PUSH
41155: LD_EXP 111
41159: PUSH
41160: LD_VAR 0 1
41164: ARRAY
41165: PPUSH
41166: LD_INT 30
41168: PUSH
41169: LD_INT 3
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PPUSH
41176: CALL_OW 72
41180: AND
41181: IFFALSE 41915
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41183: LD_ADDR_EXP 153
41187: PUSH
41188: LD_EXP 153
41192: PPUSH
41193: LD_VAR 0 1
41197: PPUSH
41198: LD_INT 3
41200: PPUSH
41201: CALL_OW 1
41205: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41206: LD_ADDR_VAR 0 2
41210: PUSH
41211: LD_INT 0
41213: PUSH
41214: LD_INT 0
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 0
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: ST_TO_ADDR
// if not eng then
41229: LD_VAR 0 6
41233: NOT
41234: IFFALSE 41297
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41236: LD_ADDR_VAR 0 11
41240: PUSH
41241: LD_VAR 0 4
41245: PPUSH
41246: LD_INT 2
41248: PPUSH
41249: CALL 99579 0 2
41253: PUSH
41254: LD_INT 1
41256: ARRAY
41257: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41258: LD_ADDR_VAR 0 2
41262: PUSH
41263: LD_VAR 0 2
41267: PPUSH
41268: LD_INT 2
41270: PPUSH
41271: LD_VAR 0 11
41275: PPUSH
41276: CALL_OW 1
41280: ST_TO_ADDR
// tmp := tmp diff p ;
41281: LD_ADDR_VAR 0 4
41285: PUSH
41286: LD_VAR 0 4
41290: PUSH
41291: LD_VAR 0 11
41295: DIFF
41296: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41297: LD_VAR 0 4
41301: PUSH
41302: LD_VAR 0 8
41306: PUSH
41307: LD_INT 6
41309: LESS
41310: AND
41311: IFFALSE 41499
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41313: LD_ADDR_VAR 0 9
41317: PUSH
41318: LD_VAR 0 4
41322: PUSH
41323: LD_VAR 0 8
41327: PUSH
41328: LD_VAR 0 7
41332: UNION
41333: DIFF
41334: PPUSH
41335: LD_INT 4
41337: PPUSH
41338: CALL 99579 0 2
41342: ST_TO_ADDR
// p := [ ] ;
41343: LD_ADDR_VAR 0 11
41347: PUSH
41348: EMPTY
41349: ST_TO_ADDR
// if sort then
41350: LD_VAR 0 9
41354: IFFALSE 41470
// for i = 1 to 6 - sci do
41356: LD_ADDR_VAR 0 3
41360: PUSH
41361: DOUBLE
41362: LD_INT 1
41364: DEC
41365: ST_TO_ADDR
41366: LD_INT 6
41368: PUSH
41369: LD_VAR 0 8
41373: MINUS
41374: PUSH
41375: FOR_TO
41376: IFFALSE 41468
// begin if i = sort then
41378: LD_VAR 0 3
41382: PUSH
41383: LD_VAR 0 9
41387: EQUAL
41388: IFFALSE 41392
// break ;
41390: GO 41468
// if GetClass ( i ) = 4 then
41392: LD_VAR 0 3
41396: PPUSH
41397: CALL_OW 257
41401: PUSH
41402: LD_INT 4
41404: EQUAL
41405: IFFALSE 41409
// continue ;
41407: GO 41375
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41409: LD_ADDR_VAR 0 11
41413: PUSH
41414: LD_VAR 0 11
41418: PPUSH
41419: LD_VAR 0 11
41423: PUSH
41424: LD_INT 1
41426: PLUS
41427: PPUSH
41428: LD_VAR 0 9
41432: PUSH
41433: LD_VAR 0 3
41437: ARRAY
41438: PPUSH
41439: CALL_OW 2
41443: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41444: LD_ADDR_VAR 0 4
41448: PUSH
41449: LD_VAR 0 4
41453: PUSH
41454: LD_VAR 0 9
41458: PUSH
41459: LD_VAR 0 3
41463: ARRAY
41464: DIFF
41465: ST_TO_ADDR
// end ;
41466: GO 41375
41468: POP
41469: POP
// if p then
41470: LD_VAR 0 11
41474: IFFALSE 41499
// result := Replace ( result , 4 , p ) ;
41476: LD_ADDR_VAR 0 2
41480: PUSH
41481: LD_VAR 0 2
41485: PPUSH
41486: LD_INT 4
41488: PPUSH
41489: LD_VAR 0 11
41493: PPUSH
41494: CALL_OW 1
41498: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41499: LD_VAR 0 4
41503: PUSH
41504: LD_VAR 0 7
41508: PUSH
41509: LD_INT 6
41511: LESS
41512: AND
41513: IFFALSE 41701
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41515: LD_ADDR_VAR 0 9
41519: PUSH
41520: LD_VAR 0 4
41524: PUSH
41525: LD_VAR 0 8
41529: PUSH
41530: LD_VAR 0 7
41534: UNION
41535: DIFF
41536: PPUSH
41537: LD_INT 3
41539: PPUSH
41540: CALL 99579 0 2
41544: ST_TO_ADDR
// p := [ ] ;
41545: LD_ADDR_VAR 0 11
41549: PUSH
41550: EMPTY
41551: ST_TO_ADDR
// if sort then
41552: LD_VAR 0 9
41556: IFFALSE 41672
// for i = 1 to 6 - mech do
41558: LD_ADDR_VAR 0 3
41562: PUSH
41563: DOUBLE
41564: LD_INT 1
41566: DEC
41567: ST_TO_ADDR
41568: LD_INT 6
41570: PUSH
41571: LD_VAR 0 7
41575: MINUS
41576: PUSH
41577: FOR_TO
41578: IFFALSE 41670
// begin if i = sort then
41580: LD_VAR 0 3
41584: PUSH
41585: LD_VAR 0 9
41589: EQUAL
41590: IFFALSE 41594
// break ;
41592: GO 41670
// if GetClass ( i ) = 3 then
41594: LD_VAR 0 3
41598: PPUSH
41599: CALL_OW 257
41603: PUSH
41604: LD_INT 3
41606: EQUAL
41607: IFFALSE 41611
// continue ;
41609: GO 41577
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41611: LD_ADDR_VAR 0 11
41615: PUSH
41616: LD_VAR 0 11
41620: PPUSH
41621: LD_VAR 0 11
41625: PUSH
41626: LD_INT 1
41628: PLUS
41629: PPUSH
41630: LD_VAR 0 9
41634: PUSH
41635: LD_VAR 0 3
41639: ARRAY
41640: PPUSH
41641: CALL_OW 2
41645: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41646: LD_ADDR_VAR 0 4
41650: PUSH
41651: LD_VAR 0 4
41655: PUSH
41656: LD_VAR 0 9
41660: PUSH
41661: LD_VAR 0 3
41665: ARRAY
41666: DIFF
41667: ST_TO_ADDR
// end ;
41668: GO 41577
41670: POP
41671: POP
// if p then
41672: LD_VAR 0 11
41676: IFFALSE 41701
// result := Replace ( result , 3 , p ) ;
41678: LD_ADDR_VAR 0 2
41682: PUSH
41683: LD_VAR 0 2
41687: PPUSH
41688: LD_INT 3
41690: PPUSH
41691: LD_VAR 0 11
41695: PPUSH
41696: CALL_OW 1
41700: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41701: LD_VAR 0 4
41705: PUSH
41706: LD_INT 6
41708: GREATER
41709: PUSH
41710: LD_VAR 0 6
41714: PUSH
41715: LD_INT 6
41717: LESS
41718: AND
41719: IFFALSE 41913
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41721: LD_ADDR_VAR 0 9
41725: PUSH
41726: LD_VAR 0 4
41730: PUSH
41731: LD_VAR 0 8
41735: PUSH
41736: LD_VAR 0 7
41740: UNION
41741: PUSH
41742: LD_VAR 0 6
41746: UNION
41747: DIFF
41748: PPUSH
41749: LD_INT 2
41751: PPUSH
41752: CALL 99579 0 2
41756: ST_TO_ADDR
// p := [ ] ;
41757: LD_ADDR_VAR 0 11
41761: PUSH
41762: EMPTY
41763: ST_TO_ADDR
// if sort then
41764: LD_VAR 0 9
41768: IFFALSE 41884
// for i = 1 to 6 - eng do
41770: LD_ADDR_VAR 0 3
41774: PUSH
41775: DOUBLE
41776: LD_INT 1
41778: DEC
41779: ST_TO_ADDR
41780: LD_INT 6
41782: PUSH
41783: LD_VAR 0 6
41787: MINUS
41788: PUSH
41789: FOR_TO
41790: IFFALSE 41882
// begin if i = sort then
41792: LD_VAR 0 3
41796: PUSH
41797: LD_VAR 0 9
41801: EQUAL
41802: IFFALSE 41806
// break ;
41804: GO 41882
// if GetClass ( i ) = 2 then
41806: LD_VAR 0 3
41810: PPUSH
41811: CALL_OW 257
41815: PUSH
41816: LD_INT 2
41818: EQUAL
41819: IFFALSE 41823
// continue ;
41821: GO 41789
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41823: LD_ADDR_VAR 0 11
41827: PUSH
41828: LD_VAR 0 11
41832: PPUSH
41833: LD_VAR 0 11
41837: PUSH
41838: LD_INT 1
41840: PLUS
41841: PPUSH
41842: LD_VAR 0 9
41846: PUSH
41847: LD_VAR 0 3
41851: ARRAY
41852: PPUSH
41853: CALL_OW 2
41857: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41858: LD_ADDR_VAR 0 4
41862: PUSH
41863: LD_VAR 0 4
41867: PUSH
41868: LD_VAR 0 9
41872: PUSH
41873: LD_VAR 0 3
41877: ARRAY
41878: DIFF
41879: ST_TO_ADDR
// end ;
41880: GO 41789
41882: POP
41883: POP
// if p then
41884: LD_VAR 0 11
41888: IFFALSE 41913
// result := Replace ( result , 2 , p ) ;
41890: LD_ADDR_VAR 0 2
41894: PUSH
41895: LD_VAR 0 2
41899: PPUSH
41900: LD_INT 2
41902: PPUSH
41903: LD_VAR 0 11
41907: PPUSH
41908: CALL_OW 1
41912: ST_TO_ADDR
// end ; exit ;
41913: GO 43301
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41915: LD_EXP 138
41919: PUSH
41920: LD_EXP 137
41924: PUSH
41925: LD_VAR 0 1
41929: ARRAY
41930: ARRAY
41931: NOT
41932: PUSH
41933: LD_EXP 111
41937: PUSH
41938: LD_VAR 0 1
41942: ARRAY
41943: PPUSH
41944: LD_INT 30
41946: PUSH
41947: LD_INT 3
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PPUSH
41954: CALL_OW 72
41958: AND
41959: PUSH
41960: LD_EXP 116
41964: PUSH
41965: LD_VAR 0 1
41969: ARRAY
41970: AND
41971: IFFALSE 42579
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41973: LD_ADDR_EXP 153
41977: PUSH
41978: LD_EXP 153
41982: PPUSH
41983: LD_VAR 0 1
41987: PPUSH
41988: LD_INT 5
41990: PPUSH
41991: CALL_OW 1
41995: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41996: LD_ADDR_VAR 0 2
42000: PUSH
42001: LD_INT 0
42003: PUSH
42004: LD_INT 0
42006: PUSH
42007: LD_INT 0
42009: PUSH
42010: LD_INT 0
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: ST_TO_ADDR
// if sci > 1 then
42019: LD_VAR 0 8
42023: PUSH
42024: LD_INT 1
42026: GREATER
42027: IFFALSE 42055
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42029: LD_ADDR_VAR 0 4
42033: PUSH
42034: LD_VAR 0 4
42038: PUSH
42039: LD_VAR 0 8
42043: PUSH
42044: LD_VAR 0 8
42048: PUSH
42049: LD_INT 1
42051: ARRAY
42052: DIFF
42053: DIFF
42054: ST_TO_ADDR
// if tmp and not sci then
42055: LD_VAR 0 4
42059: PUSH
42060: LD_VAR 0 8
42064: NOT
42065: AND
42066: IFFALSE 42135
// begin sort := SortBySkill ( tmp , 4 ) ;
42068: LD_ADDR_VAR 0 9
42072: PUSH
42073: LD_VAR 0 4
42077: PPUSH
42078: LD_INT 4
42080: PPUSH
42081: CALL 99579 0 2
42085: ST_TO_ADDR
// if sort then
42086: LD_VAR 0 9
42090: IFFALSE 42106
// p := sort [ 1 ] ;
42092: LD_ADDR_VAR 0 11
42096: PUSH
42097: LD_VAR 0 9
42101: PUSH
42102: LD_INT 1
42104: ARRAY
42105: ST_TO_ADDR
// if p then
42106: LD_VAR 0 11
42110: IFFALSE 42135
// result := Replace ( result , 4 , p ) ;
42112: LD_ADDR_VAR 0 2
42116: PUSH
42117: LD_VAR 0 2
42121: PPUSH
42122: LD_INT 4
42124: PPUSH
42125: LD_VAR 0 11
42129: PPUSH
42130: CALL_OW 1
42134: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42135: LD_ADDR_VAR 0 4
42139: PUSH
42140: LD_VAR 0 4
42144: PUSH
42145: LD_VAR 0 7
42149: DIFF
42150: ST_TO_ADDR
// if tmp and mech < 6 then
42151: LD_VAR 0 4
42155: PUSH
42156: LD_VAR 0 7
42160: PUSH
42161: LD_INT 6
42163: LESS
42164: AND
42165: IFFALSE 42353
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42167: LD_ADDR_VAR 0 9
42171: PUSH
42172: LD_VAR 0 4
42176: PUSH
42177: LD_VAR 0 8
42181: PUSH
42182: LD_VAR 0 7
42186: UNION
42187: DIFF
42188: PPUSH
42189: LD_INT 3
42191: PPUSH
42192: CALL 99579 0 2
42196: ST_TO_ADDR
// p := [ ] ;
42197: LD_ADDR_VAR 0 11
42201: PUSH
42202: EMPTY
42203: ST_TO_ADDR
// if sort then
42204: LD_VAR 0 9
42208: IFFALSE 42324
// for i = 1 to 6 - mech do
42210: LD_ADDR_VAR 0 3
42214: PUSH
42215: DOUBLE
42216: LD_INT 1
42218: DEC
42219: ST_TO_ADDR
42220: LD_INT 6
42222: PUSH
42223: LD_VAR 0 7
42227: MINUS
42228: PUSH
42229: FOR_TO
42230: IFFALSE 42322
// begin if i = sort then
42232: LD_VAR 0 3
42236: PUSH
42237: LD_VAR 0 9
42241: EQUAL
42242: IFFALSE 42246
// break ;
42244: GO 42322
// if GetClass ( i ) = 3 then
42246: LD_VAR 0 3
42250: PPUSH
42251: CALL_OW 257
42255: PUSH
42256: LD_INT 3
42258: EQUAL
42259: IFFALSE 42263
// continue ;
42261: GO 42229
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42263: LD_ADDR_VAR 0 11
42267: PUSH
42268: LD_VAR 0 11
42272: PPUSH
42273: LD_VAR 0 11
42277: PUSH
42278: LD_INT 1
42280: PLUS
42281: PPUSH
42282: LD_VAR 0 9
42286: PUSH
42287: LD_VAR 0 3
42291: ARRAY
42292: PPUSH
42293: CALL_OW 2
42297: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42298: LD_ADDR_VAR 0 4
42302: PUSH
42303: LD_VAR 0 4
42307: PUSH
42308: LD_VAR 0 9
42312: PUSH
42313: LD_VAR 0 3
42317: ARRAY
42318: DIFF
42319: ST_TO_ADDR
// end ;
42320: GO 42229
42322: POP
42323: POP
// if p then
42324: LD_VAR 0 11
42328: IFFALSE 42353
// result := Replace ( result , 3 , p ) ;
42330: LD_ADDR_VAR 0 2
42334: PUSH
42335: LD_VAR 0 2
42339: PPUSH
42340: LD_INT 3
42342: PPUSH
42343: LD_VAR 0 11
42347: PPUSH
42348: CALL_OW 1
42352: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42353: LD_ADDR_VAR 0 4
42357: PUSH
42358: LD_VAR 0 4
42362: PUSH
42363: LD_VAR 0 6
42367: DIFF
42368: ST_TO_ADDR
// if tmp and eng < 6 then
42369: LD_VAR 0 4
42373: PUSH
42374: LD_VAR 0 6
42378: PUSH
42379: LD_INT 6
42381: LESS
42382: AND
42383: IFFALSE 42577
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42385: LD_ADDR_VAR 0 9
42389: PUSH
42390: LD_VAR 0 4
42394: PUSH
42395: LD_VAR 0 8
42399: PUSH
42400: LD_VAR 0 7
42404: UNION
42405: PUSH
42406: LD_VAR 0 6
42410: UNION
42411: DIFF
42412: PPUSH
42413: LD_INT 2
42415: PPUSH
42416: CALL 99579 0 2
42420: ST_TO_ADDR
// p := [ ] ;
42421: LD_ADDR_VAR 0 11
42425: PUSH
42426: EMPTY
42427: ST_TO_ADDR
// if sort then
42428: LD_VAR 0 9
42432: IFFALSE 42548
// for i = 1 to 6 - eng do
42434: LD_ADDR_VAR 0 3
42438: PUSH
42439: DOUBLE
42440: LD_INT 1
42442: DEC
42443: ST_TO_ADDR
42444: LD_INT 6
42446: PUSH
42447: LD_VAR 0 6
42451: MINUS
42452: PUSH
42453: FOR_TO
42454: IFFALSE 42546
// begin if i = sort then
42456: LD_VAR 0 3
42460: PUSH
42461: LD_VAR 0 9
42465: EQUAL
42466: IFFALSE 42470
// break ;
42468: GO 42546
// if GetClass ( i ) = 2 then
42470: LD_VAR 0 3
42474: PPUSH
42475: CALL_OW 257
42479: PUSH
42480: LD_INT 2
42482: EQUAL
42483: IFFALSE 42487
// continue ;
42485: GO 42453
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42487: LD_ADDR_VAR 0 11
42491: PUSH
42492: LD_VAR 0 11
42496: PPUSH
42497: LD_VAR 0 11
42501: PUSH
42502: LD_INT 1
42504: PLUS
42505: PPUSH
42506: LD_VAR 0 9
42510: PUSH
42511: LD_VAR 0 3
42515: ARRAY
42516: PPUSH
42517: CALL_OW 2
42521: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42522: LD_ADDR_VAR 0 4
42526: PUSH
42527: LD_VAR 0 4
42531: PUSH
42532: LD_VAR 0 9
42536: PUSH
42537: LD_VAR 0 3
42541: ARRAY
42542: DIFF
42543: ST_TO_ADDR
// end ;
42544: GO 42453
42546: POP
42547: POP
// if p then
42548: LD_VAR 0 11
42552: IFFALSE 42577
// result := Replace ( result , 2 , p ) ;
42554: LD_ADDR_VAR 0 2
42558: PUSH
42559: LD_VAR 0 2
42563: PPUSH
42564: LD_INT 2
42566: PPUSH
42567: LD_VAR 0 11
42571: PPUSH
42572: CALL_OW 1
42576: ST_TO_ADDR
// end ; exit ;
42577: GO 43301
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42579: LD_EXP 138
42583: PUSH
42584: LD_EXP 137
42588: PUSH
42589: LD_VAR 0 1
42593: ARRAY
42594: ARRAY
42595: NOT
42596: PUSH
42597: LD_EXP 111
42601: PUSH
42602: LD_VAR 0 1
42606: ARRAY
42607: PPUSH
42608: LD_INT 30
42610: PUSH
42611: LD_INT 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PPUSH
42618: CALL_OW 72
42622: AND
42623: PUSH
42624: LD_EXP 116
42628: PUSH
42629: LD_VAR 0 1
42633: ARRAY
42634: NOT
42635: AND
42636: IFFALSE 43301
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42638: LD_ADDR_EXP 153
42642: PUSH
42643: LD_EXP 153
42647: PPUSH
42648: LD_VAR 0 1
42652: PPUSH
42653: LD_INT 6
42655: PPUSH
42656: CALL_OW 1
42660: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42661: LD_ADDR_VAR 0 2
42665: PUSH
42666: LD_INT 0
42668: PUSH
42669: LD_INT 0
42671: PUSH
42672: LD_INT 0
42674: PUSH
42675: LD_INT 0
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: LIST
42682: LIST
42683: ST_TO_ADDR
// if sci >= 1 then
42684: LD_VAR 0 8
42688: PUSH
42689: LD_INT 1
42691: GREATEREQUAL
42692: IFFALSE 42714
// tmp := tmp diff sci [ 1 ] ;
42694: LD_ADDR_VAR 0 4
42698: PUSH
42699: LD_VAR 0 4
42703: PUSH
42704: LD_VAR 0 8
42708: PUSH
42709: LD_INT 1
42711: ARRAY
42712: DIFF
42713: ST_TO_ADDR
// if tmp and not sci then
42714: LD_VAR 0 4
42718: PUSH
42719: LD_VAR 0 8
42723: NOT
42724: AND
42725: IFFALSE 42794
// begin sort := SortBySkill ( tmp , 4 ) ;
42727: LD_ADDR_VAR 0 9
42731: PUSH
42732: LD_VAR 0 4
42736: PPUSH
42737: LD_INT 4
42739: PPUSH
42740: CALL 99579 0 2
42744: ST_TO_ADDR
// if sort then
42745: LD_VAR 0 9
42749: IFFALSE 42765
// p := sort [ 1 ] ;
42751: LD_ADDR_VAR 0 11
42755: PUSH
42756: LD_VAR 0 9
42760: PUSH
42761: LD_INT 1
42763: ARRAY
42764: ST_TO_ADDR
// if p then
42765: LD_VAR 0 11
42769: IFFALSE 42794
// result := Replace ( result , 4 , p ) ;
42771: LD_ADDR_VAR 0 2
42775: PUSH
42776: LD_VAR 0 2
42780: PPUSH
42781: LD_INT 4
42783: PPUSH
42784: LD_VAR 0 11
42788: PPUSH
42789: CALL_OW 1
42793: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42794: LD_ADDR_VAR 0 4
42798: PUSH
42799: LD_VAR 0 4
42803: PUSH
42804: LD_VAR 0 7
42808: DIFF
42809: ST_TO_ADDR
// if tmp and mech < 6 then
42810: LD_VAR 0 4
42814: PUSH
42815: LD_VAR 0 7
42819: PUSH
42820: LD_INT 6
42822: LESS
42823: AND
42824: IFFALSE 43006
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42826: LD_ADDR_VAR 0 9
42830: PUSH
42831: LD_VAR 0 4
42835: PUSH
42836: LD_VAR 0 7
42840: DIFF
42841: PPUSH
42842: LD_INT 3
42844: PPUSH
42845: CALL 99579 0 2
42849: ST_TO_ADDR
// p := [ ] ;
42850: LD_ADDR_VAR 0 11
42854: PUSH
42855: EMPTY
42856: ST_TO_ADDR
// if sort then
42857: LD_VAR 0 9
42861: IFFALSE 42977
// for i = 1 to 6 - mech do
42863: LD_ADDR_VAR 0 3
42867: PUSH
42868: DOUBLE
42869: LD_INT 1
42871: DEC
42872: ST_TO_ADDR
42873: LD_INT 6
42875: PUSH
42876: LD_VAR 0 7
42880: MINUS
42881: PUSH
42882: FOR_TO
42883: IFFALSE 42975
// begin if i = sort then
42885: LD_VAR 0 3
42889: PUSH
42890: LD_VAR 0 9
42894: EQUAL
42895: IFFALSE 42899
// break ;
42897: GO 42975
// if GetClass ( i ) = 3 then
42899: LD_VAR 0 3
42903: PPUSH
42904: CALL_OW 257
42908: PUSH
42909: LD_INT 3
42911: EQUAL
42912: IFFALSE 42916
// continue ;
42914: GO 42882
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42916: LD_ADDR_VAR 0 11
42920: PUSH
42921: LD_VAR 0 11
42925: PPUSH
42926: LD_VAR 0 11
42930: PUSH
42931: LD_INT 1
42933: PLUS
42934: PPUSH
42935: LD_VAR 0 9
42939: PUSH
42940: LD_VAR 0 3
42944: ARRAY
42945: PPUSH
42946: CALL_OW 2
42950: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42951: LD_ADDR_VAR 0 4
42955: PUSH
42956: LD_VAR 0 4
42960: PUSH
42961: LD_VAR 0 9
42965: PUSH
42966: LD_VAR 0 3
42970: ARRAY
42971: DIFF
42972: ST_TO_ADDR
// end ;
42973: GO 42882
42975: POP
42976: POP
// if p then
42977: LD_VAR 0 11
42981: IFFALSE 43006
// result := Replace ( result , 3 , p ) ;
42983: LD_ADDR_VAR 0 2
42987: PUSH
42988: LD_VAR 0 2
42992: PPUSH
42993: LD_INT 3
42995: PPUSH
42996: LD_VAR 0 11
43000: PPUSH
43001: CALL_OW 1
43005: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43006: LD_ADDR_VAR 0 4
43010: PUSH
43011: LD_VAR 0 4
43015: PUSH
43016: LD_VAR 0 6
43020: DIFF
43021: ST_TO_ADDR
// if tmp and eng < 4 then
43022: LD_VAR 0 4
43026: PUSH
43027: LD_VAR 0 6
43031: PUSH
43032: LD_INT 4
43034: LESS
43035: AND
43036: IFFALSE 43226
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43038: LD_ADDR_VAR 0 9
43042: PUSH
43043: LD_VAR 0 4
43047: PUSH
43048: LD_VAR 0 7
43052: PUSH
43053: LD_VAR 0 6
43057: UNION
43058: DIFF
43059: PPUSH
43060: LD_INT 2
43062: PPUSH
43063: CALL 99579 0 2
43067: ST_TO_ADDR
// p := [ ] ;
43068: LD_ADDR_VAR 0 11
43072: PUSH
43073: EMPTY
43074: ST_TO_ADDR
// if sort then
43075: LD_VAR 0 9
43079: IFFALSE 43195
// for i = 1 to 4 - eng do
43081: LD_ADDR_VAR 0 3
43085: PUSH
43086: DOUBLE
43087: LD_INT 1
43089: DEC
43090: ST_TO_ADDR
43091: LD_INT 4
43093: PUSH
43094: LD_VAR 0 6
43098: MINUS
43099: PUSH
43100: FOR_TO
43101: IFFALSE 43193
// begin if i = sort then
43103: LD_VAR 0 3
43107: PUSH
43108: LD_VAR 0 9
43112: EQUAL
43113: IFFALSE 43117
// break ;
43115: GO 43193
// if GetClass ( i ) = 2 then
43117: LD_VAR 0 3
43121: PPUSH
43122: CALL_OW 257
43126: PUSH
43127: LD_INT 2
43129: EQUAL
43130: IFFALSE 43134
// continue ;
43132: GO 43100
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43134: LD_ADDR_VAR 0 11
43138: PUSH
43139: LD_VAR 0 11
43143: PPUSH
43144: LD_VAR 0 11
43148: PUSH
43149: LD_INT 1
43151: PLUS
43152: PPUSH
43153: LD_VAR 0 9
43157: PUSH
43158: LD_VAR 0 3
43162: ARRAY
43163: PPUSH
43164: CALL_OW 2
43168: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43169: LD_ADDR_VAR 0 4
43173: PUSH
43174: LD_VAR 0 4
43178: PUSH
43179: LD_VAR 0 9
43183: PUSH
43184: LD_VAR 0 3
43188: ARRAY
43189: DIFF
43190: ST_TO_ADDR
// end ;
43191: GO 43100
43193: POP
43194: POP
// if p then
43195: LD_VAR 0 11
43199: IFFALSE 43224
// result := Replace ( result , 2 , p ) ;
43201: LD_ADDR_VAR 0 2
43205: PUSH
43206: LD_VAR 0 2
43210: PPUSH
43211: LD_INT 2
43213: PPUSH
43214: LD_VAR 0 11
43218: PPUSH
43219: CALL_OW 1
43223: ST_TO_ADDR
// end else
43224: GO 43270
// for i = eng downto 5 do
43226: LD_ADDR_VAR 0 3
43230: PUSH
43231: DOUBLE
43232: LD_VAR 0 6
43236: INC
43237: ST_TO_ADDR
43238: LD_INT 5
43240: PUSH
43241: FOR_DOWNTO
43242: IFFALSE 43268
// tmp := tmp union eng [ i ] ;
43244: LD_ADDR_VAR 0 4
43248: PUSH
43249: LD_VAR 0 4
43253: PUSH
43254: LD_VAR 0 6
43258: PUSH
43259: LD_VAR 0 3
43263: ARRAY
43264: UNION
43265: ST_TO_ADDR
43266: GO 43241
43268: POP
43269: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43270: LD_ADDR_VAR 0 2
43274: PUSH
43275: LD_VAR 0 2
43279: PPUSH
43280: LD_INT 1
43282: PPUSH
43283: LD_VAR 0 4
43287: PUSH
43288: LD_VAR 0 5
43292: DIFF
43293: PPUSH
43294: CALL_OW 1
43298: ST_TO_ADDR
// exit ;
43299: GO 43301
// end ; end ;
43301: LD_VAR 0 2
43305: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43306: LD_INT 0
43308: PPUSH
43309: PPUSH
43310: PPUSH
// if not mc_bases then
43311: LD_EXP 111
43315: NOT
43316: IFFALSE 43320
// exit ;
43318: GO 43426
// for i = 1 to mc_bases do
43320: LD_ADDR_VAR 0 2
43324: PUSH
43325: DOUBLE
43326: LD_INT 1
43328: DEC
43329: ST_TO_ADDR
43330: LD_EXP 111
43334: PUSH
43335: FOR_TO
43336: IFFALSE 43417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43338: LD_ADDR_VAR 0 3
43342: PUSH
43343: LD_EXP 111
43347: PUSH
43348: LD_VAR 0 2
43352: ARRAY
43353: PPUSH
43354: LD_INT 21
43356: PUSH
43357: LD_INT 3
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 3
43366: PUSH
43367: LD_INT 24
43369: PUSH
43370: LD_INT 1000
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PPUSH
43385: CALL_OW 72
43389: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43390: LD_ADDR_EXP 112
43394: PUSH
43395: LD_EXP 112
43399: PPUSH
43400: LD_VAR 0 2
43404: PPUSH
43405: LD_VAR 0 3
43409: PPUSH
43410: CALL_OW 1
43414: ST_TO_ADDR
// end ;
43415: GO 43335
43417: POP
43418: POP
// RaiseSailEvent ( 101 ) ;
43419: LD_INT 101
43421: PPUSH
43422: CALL_OW 427
// end ;
43426: LD_VAR 0 1
43430: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43431: LD_INT 0
43433: PPUSH
43434: PPUSH
43435: PPUSH
43436: PPUSH
43437: PPUSH
43438: PPUSH
43439: PPUSH
// if not mc_bases then
43440: LD_EXP 111
43444: NOT
43445: IFFALSE 43449
// exit ;
43447: GO 44011
// for i = 1 to mc_bases do
43449: LD_ADDR_VAR 0 2
43453: PUSH
43454: DOUBLE
43455: LD_INT 1
43457: DEC
43458: ST_TO_ADDR
43459: LD_EXP 111
43463: PUSH
43464: FOR_TO
43465: IFFALSE 44002
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43467: LD_ADDR_VAR 0 5
43471: PUSH
43472: LD_EXP 111
43476: PUSH
43477: LD_VAR 0 2
43481: ARRAY
43482: PUSH
43483: LD_EXP 140
43487: PUSH
43488: LD_VAR 0 2
43492: ARRAY
43493: UNION
43494: PPUSH
43495: LD_INT 21
43497: PUSH
43498: LD_INT 1
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: LD_INT 3
43510: PUSH
43511: LD_INT 54
43513: PUSH
43514: EMPTY
43515: LIST
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: PUSH
43521: LD_INT 3
43523: PUSH
43524: LD_INT 24
43526: PUSH
43527: LD_INT 800
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PPUSH
43547: CALL_OW 72
43551: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43552: LD_ADDR_VAR 0 6
43556: PUSH
43557: LD_EXP 111
43561: PUSH
43562: LD_VAR 0 2
43566: ARRAY
43567: PPUSH
43568: LD_INT 21
43570: PUSH
43571: LD_INT 1
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 3
43583: PUSH
43584: LD_INT 54
43586: PUSH
43587: EMPTY
43588: LIST
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 3
43596: PUSH
43597: LD_INT 24
43599: PUSH
43600: LD_INT 250
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: LIST
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: PPUSH
43620: CALL_OW 72
43624: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43625: LD_ADDR_VAR 0 7
43629: PUSH
43630: LD_VAR 0 5
43634: PUSH
43635: LD_VAR 0 6
43639: DIFF
43640: ST_TO_ADDR
// if not need_heal_1 then
43641: LD_VAR 0 6
43645: NOT
43646: IFFALSE 43679
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43648: LD_ADDR_EXP 114
43652: PUSH
43653: LD_EXP 114
43657: PPUSH
43658: LD_VAR 0 2
43662: PUSH
43663: LD_INT 1
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PPUSH
43670: EMPTY
43671: PPUSH
43672: CALL 70030 0 3
43676: ST_TO_ADDR
43677: GO 43749
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43679: LD_ADDR_EXP 114
43683: PUSH
43684: LD_EXP 114
43688: PPUSH
43689: LD_VAR 0 2
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PPUSH
43701: LD_EXP 114
43705: PUSH
43706: LD_VAR 0 2
43710: ARRAY
43711: PUSH
43712: LD_INT 1
43714: ARRAY
43715: PPUSH
43716: LD_INT 3
43718: PUSH
43719: LD_INT 24
43721: PUSH
43722: LD_INT 1000
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PPUSH
43733: CALL_OW 72
43737: PUSH
43738: LD_VAR 0 6
43742: UNION
43743: PPUSH
43744: CALL 70030 0 3
43748: ST_TO_ADDR
// if not need_heal_2 then
43749: LD_VAR 0 7
43753: NOT
43754: IFFALSE 43787
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43756: LD_ADDR_EXP 114
43760: PUSH
43761: LD_EXP 114
43765: PPUSH
43766: LD_VAR 0 2
43770: PUSH
43771: LD_INT 2
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PPUSH
43778: EMPTY
43779: PPUSH
43780: CALL 70030 0 3
43784: ST_TO_ADDR
43785: GO 43819
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43787: LD_ADDR_EXP 114
43791: PUSH
43792: LD_EXP 114
43796: PPUSH
43797: LD_VAR 0 2
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PPUSH
43809: LD_VAR 0 7
43813: PPUSH
43814: CALL 70030 0 3
43818: ST_TO_ADDR
// if need_heal_2 then
43819: LD_VAR 0 7
43823: IFFALSE 43984
// for j in need_heal_2 do
43825: LD_ADDR_VAR 0 3
43829: PUSH
43830: LD_VAR 0 7
43834: PUSH
43835: FOR_IN
43836: IFFALSE 43982
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43838: LD_ADDR_VAR 0 5
43842: PUSH
43843: LD_EXP 111
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PPUSH
43854: LD_INT 2
43856: PUSH
43857: LD_INT 30
43859: PUSH
43860: LD_INT 6
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 30
43869: PUSH
43870: LD_INT 7
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 30
43879: PUSH
43880: LD_INT 8
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 30
43889: PUSH
43890: LD_INT 0
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 30
43899: PUSH
43900: LD_INT 1
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: PPUSH
43915: CALL_OW 72
43919: ST_TO_ADDR
// if tmp then
43920: LD_VAR 0 5
43924: IFFALSE 43980
// begin k := NearestUnitToUnit ( tmp , j ) ;
43926: LD_ADDR_VAR 0 4
43930: PUSH
43931: LD_VAR 0 5
43935: PPUSH
43936: LD_VAR 0 3
43940: PPUSH
43941: CALL_OW 74
43945: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43946: LD_VAR 0 3
43950: PPUSH
43951: LD_VAR 0 4
43955: PPUSH
43956: CALL_OW 296
43960: PUSH
43961: LD_INT 5
43963: GREATER
43964: IFFALSE 43980
// ComMoveUnit ( j , k ) ;
43966: LD_VAR 0 3
43970: PPUSH
43971: LD_VAR 0 4
43975: PPUSH
43976: CALL_OW 112
// end ; end ;
43980: GO 43835
43982: POP
43983: POP
// if not need_heal_1 and not need_heal_2 then
43984: LD_VAR 0 6
43988: NOT
43989: PUSH
43990: LD_VAR 0 7
43994: NOT
43995: AND
43996: IFFALSE 44000
// continue ;
43998: GO 43464
// end ;
44000: GO 43464
44002: POP
44003: POP
// RaiseSailEvent ( 102 ) ;
44004: LD_INT 102
44006: PPUSH
44007: CALL_OW 427
// end ;
44011: LD_VAR 0 1
44015: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44016: LD_INT 0
44018: PPUSH
44019: PPUSH
44020: PPUSH
44021: PPUSH
44022: PPUSH
44023: PPUSH
44024: PPUSH
44025: PPUSH
// if not mc_bases then
44026: LD_EXP 111
44030: NOT
44031: IFFALSE 44035
// exit ;
44033: GO 44870
// for i = 1 to mc_bases do
44035: LD_ADDR_VAR 0 2
44039: PUSH
44040: DOUBLE
44041: LD_INT 1
44043: DEC
44044: ST_TO_ADDR
44045: LD_EXP 111
44049: PUSH
44050: FOR_TO
44051: IFFALSE 44868
// begin if not mc_building_need_repair [ i ] then
44053: LD_EXP 112
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: NOT
44064: IFFALSE 44238
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
44066: LD_ADDR_VAR 0 6
44070: PUSH
44071: LD_EXP 130
44075: PUSH
44076: LD_VAR 0 2
44080: ARRAY
44081: PPUSH
44082: LD_INT 3
44084: PUSH
44085: LD_INT 24
44087: PUSH
44088: LD_INT 1000
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 2
44101: PUSH
44102: LD_INT 34
44104: PUSH
44105: LD_INT 13
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 34
44114: PUSH
44115: LD_INT 52
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: LIST
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PPUSH
44131: CALL_OW 72
44135: ST_TO_ADDR
// if cranes then
44136: LD_VAR 0 6
44140: IFFALSE 44202
// for j in cranes do
44142: LD_ADDR_VAR 0 3
44146: PUSH
44147: LD_VAR 0 6
44151: PUSH
44152: FOR_IN
44153: IFFALSE 44200
// if not IsInArea ( j , mc_parking [ i ] ) then
44155: LD_VAR 0 3
44159: PPUSH
44160: LD_EXP 135
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: PPUSH
44171: CALL_OW 308
44175: NOT
44176: IFFALSE 44198
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44178: LD_VAR 0 3
44182: PPUSH
44183: LD_EXP 135
44187: PUSH
44188: LD_VAR 0 2
44192: ARRAY
44193: PPUSH
44194: CALL_OW 113
44198: GO 44152
44200: POP
44201: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44202: LD_ADDR_EXP 113
44206: PUSH
44207: LD_EXP 113
44211: PPUSH
44212: LD_VAR 0 2
44216: PPUSH
44217: EMPTY
44218: PPUSH
44219: CALL_OW 1
44223: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44224: LD_VAR 0 2
44228: PPUSH
44229: LD_INT 101
44231: PPUSH
44232: CALL 39139 0 2
// continue ;
44236: GO 44050
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44238: LD_ADDR_EXP 117
44242: PUSH
44243: LD_EXP 117
44247: PPUSH
44248: LD_VAR 0 2
44252: PPUSH
44253: EMPTY
44254: PPUSH
44255: CALL_OW 1
44259: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44260: LD_VAR 0 2
44264: PPUSH
44265: LD_INT 103
44267: PPUSH
44268: CALL 39139 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44272: LD_ADDR_VAR 0 5
44276: PUSH
44277: LD_EXP 111
44281: PUSH
44282: LD_VAR 0 2
44286: ARRAY
44287: PUSH
44288: LD_EXP 140
44292: PUSH
44293: LD_VAR 0 2
44297: ARRAY
44298: UNION
44299: PPUSH
44300: LD_INT 2
44302: PUSH
44303: LD_INT 25
44305: PUSH
44306: LD_INT 2
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 25
44315: PUSH
44316: LD_INT 16
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: PPUSH
44331: CALL_OW 72
44335: PUSH
44336: LD_EXP 114
44340: PUSH
44341: LD_VAR 0 2
44345: ARRAY
44346: PUSH
44347: LD_INT 1
44349: ARRAY
44350: PUSH
44351: LD_EXP 114
44355: PUSH
44356: LD_VAR 0 2
44360: ARRAY
44361: PUSH
44362: LD_INT 2
44364: ARRAY
44365: UNION
44366: DIFF
44367: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44368: LD_ADDR_VAR 0 6
44372: PUSH
44373: LD_EXP 130
44377: PUSH
44378: LD_VAR 0 2
44382: ARRAY
44383: PPUSH
44384: LD_INT 2
44386: PUSH
44387: LD_INT 34
44389: PUSH
44390: LD_INT 13
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 34
44399: PUSH
44400: LD_INT 52
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: LIST
44411: PPUSH
44412: CALL_OW 72
44416: ST_TO_ADDR
// if cranes then
44417: LD_VAR 0 6
44421: IFFALSE 44557
// begin for j in cranes do
44423: LD_ADDR_VAR 0 3
44427: PUSH
44428: LD_VAR 0 6
44432: PUSH
44433: FOR_IN
44434: IFFALSE 44555
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44436: LD_VAR 0 3
44440: PPUSH
44441: CALL_OW 256
44445: PUSH
44446: LD_INT 500
44448: GREATEREQUAL
44449: PUSH
44450: LD_VAR 0 3
44454: PPUSH
44455: CALL_OW 314
44459: NOT
44460: AND
44461: IFFALSE 44495
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44463: LD_VAR 0 3
44467: PPUSH
44468: LD_EXP 112
44472: PUSH
44473: LD_VAR 0 2
44477: ARRAY
44478: PPUSH
44479: LD_VAR 0 3
44483: PPUSH
44484: CALL_OW 74
44488: PPUSH
44489: CALL_OW 130
44493: GO 44553
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44495: LD_VAR 0 3
44499: PPUSH
44500: CALL_OW 256
44504: PUSH
44505: LD_INT 500
44507: LESS
44508: PUSH
44509: LD_VAR 0 3
44513: PPUSH
44514: LD_EXP 135
44518: PUSH
44519: LD_VAR 0 2
44523: ARRAY
44524: PPUSH
44525: CALL_OW 308
44529: NOT
44530: AND
44531: IFFALSE 44553
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44533: LD_VAR 0 3
44537: PPUSH
44538: LD_EXP 135
44542: PUSH
44543: LD_VAR 0 2
44547: ARRAY
44548: PPUSH
44549: CALL_OW 113
44553: GO 44433
44555: POP
44556: POP
// end ; if tmp > 3 then
44557: LD_VAR 0 5
44561: PUSH
44562: LD_INT 3
44564: GREATER
44565: IFFALSE 44585
// tmp := ShrinkArray ( tmp , 4 ) ;
44567: LD_ADDR_VAR 0 5
44571: PUSH
44572: LD_VAR 0 5
44576: PPUSH
44577: LD_INT 4
44579: PPUSH
44580: CALL 101256 0 2
44584: ST_TO_ADDR
// if not tmp then
44585: LD_VAR 0 5
44589: NOT
44590: IFFALSE 44594
// continue ;
44592: GO 44050
// for j in tmp do
44594: LD_ADDR_VAR 0 3
44598: PUSH
44599: LD_VAR 0 5
44603: PUSH
44604: FOR_IN
44605: IFFALSE 44864
// begin if IsInUnit ( j ) then
44607: LD_VAR 0 3
44611: PPUSH
44612: CALL_OW 310
44616: IFFALSE 44627
// ComExitBuilding ( j ) ;
44618: LD_VAR 0 3
44622: PPUSH
44623: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44627: LD_VAR 0 3
44631: PUSH
44632: LD_EXP 113
44636: PUSH
44637: LD_VAR 0 2
44641: ARRAY
44642: IN
44643: NOT
44644: IFFALSE 44702
// begin SetTag ( j , 101 ) ;
44646: LD_VAR 0 3
44650: PPUSH
44651: LD_INT 101
44653: PPUSH
44654: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44658: LD_ADDR_EXP 113
44662: PUSH
44663: LD_EXP 113
44667: PPUSH
44668: LD_VAR 0 2
44672: PUSH
44673: LD_EXP 113
44677: PUSH
44678: LD_VAR 0 2
44682: ARRAY
44683: PUSH
44684: LD_INT 1
44686: PLUS
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PPUSH
44692: LD_VAR 0 3
44696: PPUSH
44697: CALL 70030 0 3
44701: ST_TO_ADDR
// end ; wait ( 1 ) ;
44702: LD_INT 1
44704: PPUSH
44705: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44709: LD_ADDR_VAR 0 7
44713: PUSH
44714: LD_EXP 112
44718: PUSH
44719: LD_VAR 0 2
44723: ARRAY
44724: ST_TO_ADDR
// if mc_scan [ i ] then
44725: LD_EXP 134
44729: PUSH
44730: LD_VAR 0 2
44734: ARRAY
44735: IFFALSE 44797
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44737: LD_ADDR_VAR 0 7
44741: PUSH
44742: LD_EXP 112
44746: PUSH
44747: LD_VAR 0 2
44751: ARRAY
44752: PPUSH
44753: LD_INT 3
44755: PUSH
44756: LD_INT 30
44758: PUSH
44759: LD_INT 32
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 30
44768: PUSH
44769: LD_INT 33
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 30
44778: PUSH
44779: LD_INT 31
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: PPUSH
44792: CALL_OW 72
44796: ST_TO_ADDR
// if not to_repair_tmp then
44797: LD_VAR 0 7
44801: NOT
44802: IFFALSE 44806
// continue ;
44804: GO 44604
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44806: LD_ADDR_VAR 0 8
44810: PUSH
44811: LD_VAR 0 7
44815: PPUSH
44816: LD_VAR 0 3
44820: PPUSH
44821: CALL_OW 74
44825: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
44826: LD_VAR 0 8
44830: PPUSH
44831: LD_INT 16
44833: PPUSH
44834: CALL 72623 0 2
44838: PUSH
44839: LD_INT 4
44841: ARRAY
44842: PUSH
44843: LD_INT 5
44845: LESS
44846: IFFALSE 44862
// ComRepairBuilding ( j , to_repair ) ;
44848: LD_VAR 0 3
44852: PPUSH
44853: LD_VAR 0 8
44857: PPUSH
44858: CALL_OW 130
// end ;
44862: GO 44604
44864: POP
44865: POP
// end ;
44866: GO 44050
44868: POP
44869: POP
// end ;
44870: LD_VAR 0 1
44874: RET
// export function MC_Heal ; var i , j , tmp ; begin
44875: LD_INT 0
44877: PPUSH
44878: PPUSH
44879: PPUSH
44880: PPUSH
// if not mc_bases then
44881: LD_EXP 111
44885: NOT
44886: IFFALSE 44890
// exit ;
44888: GO 45292
// for i = 1 to mc_bases do
44890: LD_ADDR_VAR 0 2
44894: PUSH
44895: DOUBLE
44896: LD_INT 1
44898: DEC
44899: ST_TO_ADDR
44900: LD_EXP 111
44904: PUSH
44905: FOR_TO
44906: IFFALSE 45290
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44908: LD_EXP 114
44912: PUSH
44913: LD_VAR 0 2
44917: ARRAY
44918: PUSH
44919: LD_INT 1
44921: ARRAY
44922: NOT
44923: PUSH
44924: LD_EXP 114
44928: PUSH
44929: LD_VAR 0 2
44933: ARRAY
44934: PUSH
44935: LD_INT 2
44937: ARRAY
44938: NOT
44939: AND
44940: IFFALSE 44978
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44942: LD_ADDR_EXP 115
44946: PUSH
44947: LD_EXP 115
44951: PPUSH
44952: LD_VAR 0 2
44956: PPUSH
44957: EMPTY
44958: PPUSH
44959: CALL_OW 1
44963: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44964: LD_VAR 0 2
44968: PPUSH
44969: LD_INT 102
44971: PPUSH
44972: CALL 39139 0 2
// continue ;
44976: GO 44905
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44978: LD_ADDR_VAR 0 4
44982: PUSH
44983: LD_EXP 111
44987: PUSH
44988: LD_VAR 0 2
44992: ARRAY
44993: PPUSH
44994: LD_INT 25
44996: PUSH
44997: LD_INT 4
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PPUSH
45004: CALL_OW 72
45008: ST_TO_ADDR
// if not tmp then
45009: LD_VAR 0 4
45013: NOT
45014: IFFALSE 45018
// continue ;
45016: GO 44905
// if mc_taming [ i ] then
45018: LD_EXP 142
45022: PUSH
45023: LD_VAR 0 2
45027: ARRAY
45028: IFFALSE 45052
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45030: LD_ADDR_EXP 142
45034: PUSH
45035: LD_EXP 142
45039: PPUSH
45040: LD_VAR 0 2
45044: PPUSH
45045: EMPTY
45046: PPUSH
45047: CALL_OW 1
45051: ST_TO_ADDR
// for j in tmp do
45052: LD_ADDR_VAR 0 3
45056: PUSH
45057: LD_VAR 0 4
45061: PUSH
45062: FOR_IN
45063: IFFALSE 45286
// begin if IsInUnit ( j ) then
45065: LD_VAR 0 3
45069: PPUSH
45070: CALL_OW 310
45074: IFFALSE 45085
// ComExitBuilding ( j ) ;
45076: LD_VAR 0 3
45080: PPUSH
45081: CALL_OW 122
// if not j in mc_healers [ i ] then
45085: LD_VAR 0 3
45089: PUSH
45090: LD_EXP 115
45094: PUSH
45095: LD_VAR 0 2
45099: ARRAY
45100: IN
45101: NOT
45102: IFFALSE 45148
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45104: LD_ADDR_EXP 115
45108: PUSH
45109: LD_EXP 115
45113: PPUSH
45114: LD_VAR 0 2
45118: PUSH
45119: LD_EXP 115
45123: PUSH
45124: LD_VAR 0 2
45128: ARRAY
45129: PUSH
45130: LD_INT 1
45132: PLUS
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PPUSH
45138: LD_VAR 0 3
45142: PPUSH
45143: CALL 70030 0 3
45147: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45148: LD_VAR 0 3
45152: PPUSH
45153: CALL_OW 110
45157: PUSH
45158: LD_INT 102
45160: NONEQUAL
45161: IFFALSE 45175
// SetTag ( j , 102 ) ;
45163: LD_VAR 0 3
45167: PPUSH
45168: LD_INT 102
45170: PPUSH
45171: CALL_OW 109
// Wait ( 3 ) ;
45175: LD_INT 3
45177: PPUSH
45178: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45182: LD_EXP 114
45186: PUSH
45187: LD_VAR 0 2
45191: ARRAY
45192: PUSH
45193: LD_INT 1
45195: ARRAY
45196: IFFALSE 45228
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45198: LD_VAR 0 3
45202: PPUSH
45203: LD_EXP 114
45207: PUSH
45208: LD_VAR 0 2
45212: ARRAY
45213: PUSH
45214: LD_INT 1
45216: ARRAY
45217: PUSH
45218: LD_INT 1
45220: ARRAY
45221: PPUSH
45222: CALL_OW 128
45226: GO 45284
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45228: LD_VAR 0 3
45232: PPUSH
45233: CALL_OW 314
45237: NOT
45238: PUSH
45239: LD_EXP 114
45243: PUSH
45244: LD_VAR 0 2
45248: ARRAY
45249: PUSH
45250: LD_INT 2
45252: ARRAY
45253: AND
45254: IFFALSE 45284
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45256: LD_VAR 0 3
45260: PPUSH
45261: LD_EXP 114
45265: PUSH
45266: LD_VAR 0 2
45270: ARRAY
45271: PUSH
45272: LD_INT 2
45274: ARRAY
45275: PUSH
45276: LD_INT 1
45278: ARRAY
45279: PPUSH
45280: CALL_OW 128
// end ;
45284: GO 45062
45286: POP
45287: POP
// end ;
45288: GO 44905
45290: POP
45291: POP
// end ;
45292: LD_VAR 0 1
45296: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45297: LD_INT 0
45299: PPUSH
45300: PPUSH
45301: PPUSH
45302: PPUSH
45303: PPUSH
// if not mc_bases then
45304: LD_EXP 111
45308: NOT
45309: IFFALSE 45313
// exit ;
45311: GO 46456
// for i = 1 to mc_bases do
45313: LD_ADDR_VAR 0 2
45317: PUSH
45318: DOUBLE
45319: LD_INT 1
45321: DEC
45322: ST_TO_ADDR
45323: LD_EXP 111
45327: PUSH
45328: FOR_TO
45329: IFFALSE 46454
// begin if mc_scan [ i ] then
45331: LD_EXP 134
45335: PUSH
45336: LD_VAR 0 2
45340: ARRAY
45341: IFFALSE 45345
// continue ;
45343: GO 45328
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45345: LD_EXP 116
45349: PUSH
45350: LD_VAR 0 2
45354: ARRAY
45355: NOT
45356: PUSH
45357: LD_EXP 118
45361: PUSH
45362: LD_VAR 0 2
45366: ARRAY
45367: NOT
45368: AND
45369: PUSH
45370: LD_EXP 117
45374: PUSH
45375: LD_VAR 0 2
45379: ARRAY
45380: AND
45381: IFFALSE 45419
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45383: LD_ADDR_EXP 117
45387: PUSH
45388: LD_EXP 117
45392: PPUSH
45393: LD_VAR 0 2
45397: PPUSH
45398: EMPTY
45399: PPUSH
45400: CALL_OW 1
45404: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45405: LD_VAR 0 2
45409: PPUSH
45410: LD_INT 103
45412: PPUSH
45413: CALL 39139 0 2
// continue ;
45417: GO 45328
// end ; if mc_construct_list [ i ] then
45419: LD_EXP 118
45423: PUSH
45424: LD_VAR 0 2
45428: ARRAY
45429: IFFALSE 45649
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45431: LD_ADDR_VAR 0 4
45435: PUSH
45436: LD_EXP 111
45440: PUSH
45441: LD_VAR 0 2
45445: ARRAY
45446: PPUSH
45447: LD_INT 25
45449: PUSH
45450: LD_INT 2
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: PPUSH
45457: CALL_OW 72
45461: PUSH
45462: LD_EXP 113
45466: PUSH
45467: LD_VAR 0 2
45471: ARRAY
45472: DIFF
45473: ST_TO_ADDR
// if not tmp then
45474: LD_VAR 0 4
45478: NOT
45479: IFFALSE 45483
// continue ;
45481: GO 45328
// for j in tmp do
45483: LD_ADDR_VAR 0 3
45487: PUSH
45488: LD_VAR 0 4
45492: PUSH
45493: FOR_IN
45494: IFFALSE 45645
// begin if not mc_builders [ i ] then
45496: LD_EXP 117
45500: PUSH
45501: LD_VAR 0 2
45505: ARRAY
45506: NOT
45507: IFFALSE 45565
// begin SetTag ( j , 103 ) ;
45509: LD_VAR 0 3
45513: PPUSH
45514: LD_INT 103
45516: PPUSH
45517: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45521: LD_ADDR_EXP 117
45525: PUSH
45526: LD_EXP 117
45530: PPUSH
45531: LD_VAR 0 2
45535: PUSH
45536: LD_EXP 117
45540: PUSH
45541: LD_VAR 0 2
45545: ARRAY
45546: PUSH
45547: LD_INT 1
45549: PLUS
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PPUSH
45555: LD_VAR 0 3
45559: PPUSH
45560: CALL 70030 0 3
45564: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45565: LD_VAR 0 3
45569: PPUSH
45570: CALL_OW 310
45574: IFFALSE 45585
// ComExitBuilding ( j ) ;
45576: LD_VAR 0 3
45580: PPUSH
45581: CALL_OW 122
// wait ( 3 ) ;
45585: LD_INT 3
45587: PPUSH
45588: CALL_OW 67
// if not mc_construct_list [ i ] then
45592: LD_EXP 118
45596: PUSH
45597: LD_VAR 0 2
45601: ARRAY
45602: NOT
45603: IFFALSE 45607
// break ;
45605: GO 45645
// if not HasTask ( j ) then
45607: LD_VAR 0 3
45611: PPUSH
45612: CALL_OW 314
45616: NOT
45617: IFFALSE 45643
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45619: LD_VAR 0 3
45623: PPUSH
45624: LD_EXP 118
45628: PUSH
45629: LD_VAR 0 2
45633: ARRAY
45634: PUSH
45635: LD_INT 1
45637: ARRAY
45638: PPUSH
45639: CALL 72881 0 2
// end ;
45643: GO 45493
45645: POP
45646: POP
// end else
45647: GO 46452
// if mc_build_list [ i ] then
45649: LD_EXP 116
45653: PUSH
45654: LD_VAR 0 2
45658: ARRAY
45659: IFFALSE 46452
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45661: LD_ADDR_VAR 0 5
45665: PUSH
45666: LD_EXP 111
45670: PUSH
45671: LD_VAR 0 2
45675: ARRAY
45676: PPUSH
45677: LD_INT 2
45679: PUSH
45680: LD_INT 30
45682: PUSH
45683: LD_INT 0
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 30
45692: PUSH
45693: LD_INT 1
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: LIST
45704: PPUSH
45705: CALL_OW 72
45709: ST_TO_ADDR
// if depot then
45710: LD_VAR 0 5
45714: IFFALSE 45732
// depot := depot [ 1 ] else
45716: LD_ADDR_VAR 0 5
45720: PUSH
45721: LD_VAR 0 5
45725: PUSH
45726: LD_INT 1
45728: ARRAY
45729: ST_TO_ADDR
45730: GO 45740
// depot := 0 ;
45732: LD_ADDR_VAR 0 5
45736: PUSH
45737: LD_INT 0
45739: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45740: LD_EXP 116
45744: PUSH
45745: LD_VAR 0 2
45749: ARRAY
45750: PUSH
45751: LD_INT 1
45753: ARRAY
45754: PUSH
45755: LD_INT 1
45757: ARRAY
45758: PPUSH
45759: CALL 72711 0 1
45763: PUSH
45764: LD_EXP 111
45768: PUSH
45769: LD_VAR 0 2
45773: ARRAY
45774: PPUSH
45775: LD_INT 2
45777: PUSH
45778: LD_INT 30
45780: PUSH
45781: LD_INT 2
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 30
45790: PUSH
45791: LD_INT 3
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: LIST
45802: PPUSH
45803: CALL_OW 72
45807: NOT
45808: AND
45809: IFFALSE 45914
// begin for j = 1 to mc_build_list [ i ] do
45811: LD_ADDR_VAR 0 3
45815: PUSH
45816: DOUBLE
45817: LD_INT 1
45819: DEC
45820: ST_TO_ADDR
45821: LD_EXP 116
45825: PUSH
45826: LD_VAR 0 2
45830: ARRAY
45831: PUSH
45832: FOR_TO
45833: IFFALSE 45912
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45835: LD_EXP 116
45839: PUSH
45840: LD_VAR 0 2
45844: ARRAY
45845: PUSH
45846: LD_VAR 0 3
45850: ARRAY
45851: PUSH
45852: LD_INT 1
45854: ARRAY
45855: PUSH
45856: LD_INT 2
45858: EQUAL
45859: IFFALSE 45910
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45861: LD_ADDR_EXP 116
45865: PUSH
45866: LD_EXP 116
45870: PPUSH
45871: LD_VAR 0 2
45875: PPUSH
45876: LD_EXP 116
45880: PUSH
45881: LD_VAR 0 2
45885: ARRAY
45886: PPUSH
45887: LD_VAR 0 3
45891: PPUSH
45892: LD_INT 1
45894: PPUSH
45895: LD_INT 0
45897: PPUSH
45898: CALL 69448 0 4
45902: PPUSH
45903: CALL_OW 1
45907: ST_TO_ADDR
// break ;
45908: GO 45912
// end ;
45910: GO 45832
45912: POP
45913: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45914: LD_EXP 116
45918: PUSH
45919: LD_VAR 0 2
45923: ARRAY
45924: PUSH
45925: LD_INT 1
45927: ARRAY
45928: PUSH
45929: LD_INT 1
45931: ARRAY
45932: PUSH
45933: LD_INT 0
45935: EQUAL
45936: PUSH
45937: LD_VAR 0 5
45941: PUSH
45942: LD_VAR 0 5
45946: PPUSH
45947: LD_EXP 116
45951: PUSH
45952: LD_VAR 0 2
45956: ARRAY
45957: PUSH
45958: LD_INT 1
45960: ARRAY
45961: PUSH
45962: LD_INT 1
45964: ARRAY
45965: PPUSH
45966: LD_EXP 116
45970: PUSH
45971: LD_VAR 0 2
45975: ARRAY
45976: PUSH
45977: LD_INT 1
45979: ARRAY
45980: PUSH
45981: LD_INT 2
45983: ARRAY
45984: PPUSH
45985: LD_EXP 116
45989: PUSH
45990: LD_VAR 0 2
45994: ARRAY
45995: PUSH
45996: LD_INT 1
45998: ARRAY
45999: PUSH
46000: LD_INT 3
46002: ARRAY
46003: PPUSH
46004: LD_EXP 116
46008: PUSH
46009: LD_VAR 0 2
46013: ARRAY
46014: PUSH
46015: LD_INT 1
46017: ARRAY
46018: PUSH
46019: LD_INT 4
46021: ARRAY
46022: PPUSH
46023: CALL 77445 0 5
46027: AND
46028: OR
46029: IFFALSE 46310
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46031: LD_ADDR_VAR 0 4
46035: PUSH
46036: LD_EXP 111
46040: PUSH
46041: LD_VAR 0 2
46045: ARRAY
46046: PPUSH
46047: LD_INT 25
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PPUSH
46057: CALL_OW 72
46061: PUSH
46062: LD_EXP 113
46066: PUSH
46067: LD_VAR 0 2
46071: ARRAY
46072: DIFF
46073: ST_TO_ADDR
// if not tmp then
46074: LD_VAR 0 4
46078: NOT
46079: IFFALSE 46083
// continue ;
46081: GO 45328
// for j in tmp do
46083: LD_ADDR_VAR 0 3
46087: PUSH
46088: LD_VAR 0 4
46092: PUSH
46093: FOR_IN
46094: IFFALSE 46306
// begin if not mc_builders [ i ] then
46096: LD_EXP 117
46100: PUSH
46101: LD_VAR 0 2
46105: ARRAY
46106: NOT
46107: IFFALSE 46165
// begin SetTag ( j , 103 ) ;
46109: LD_VAR 0 3
46113: PPUSH
46114: LD_INT 103
46116: PPUSH
46117: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46121: LD_ADDR_EXP 117
46125: PUSH
46126: LD_EXP 117
46130: PPUSH
46131: LD_VAR 0 2
46135: PUSH
46136: LD_EXP 117
46140: PUSH
46141: LD_VAR 0 2
46145: ARRAY
46146: PUSH
46147: LD_INT 1
46149: PLUS
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PPUSH
46155: LD_VAR 0 3
46159: PPUSH
46160: CALL 70030 0 3
46164: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46165: LD_VAR 0 3
46169: PPUSH
46170: CALL_OW 310
46174: IFFALSE 46185
// ComExitBuilding ( j ) ;
46176: LD_VAR 0 3
46180: PPUSH
46181: CALL_OW 122
// wait ( 3 ) ;
46185: LD_INT 3
46187: PPUSH
46188: CALL_OW 67
// if not mc_build_list [ i ] then
46192: LD_EXP 116
46196: PUSH
46197: LD_VAR 0 2
46201: ARRAY
46202: NOT
46203: IFFALSE 46207
// break ;
46205: GO 46306
// if not HasTask ( j ) then
46207: LD_VAR 0 3
46211: PPUSH
46212: CALL_OW 314
46216: NOT
46217: IFFALSE 46304
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46219: LD_VAR 0 3
46223: PPUSH
46224: LD_EXP 116
46228: PUSH
46229: LD_VAR 0 2
46233: ARRAY
46234: PUSH
46235: LD_INT 1
46237: ARRAY
46238: PUSH
46239: LD_INT 1
46241: ARRAY
46242: PPUSH
46243: LD_EXP 116
46247: PUSH
46248: LD_VAR 0 2
46252: ARRAY
46253: PUSH
46254: LD_INT 1
46256: ARRAY
46257: PUSH
46258: LD_INT 2
46260: ARRAY
46261: PPUSH
46262: LD_EXP 116
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: PUSH
46273: LD_INT 1
46275: ARRAY
46276: PUSH
46277: LD_INT 3
46279: ARRAY
46280: PPUSH
46281: LD_EXP 116
46285: PUSH
46286: LD_VAR 0 2
46290: ARRAY
46291: PUSH
46292: LD_INT 1
46294: ARRAY
46295: PUSH
46296: LD_INT 4
46298: ARRAY
46299: PPUSH
46300: CALL_OW 145
// end ;
46304: GO 46093
46306: POP
46307: POP
// end else
46308: GO 46452
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46310: LD_EXP 111
46314: PUSH
46315: LD_VAR 0 2
46319: ARRAY
46320: PPUSH
46321: LD_EXP 116
46325: PUSH
46326: LD_VAR 0 2
46330: ARRAY
46331: PUSH
46332: LD_INT 1
46334: ARRAY
46335: PUSH
46336: LD_INT 1
46338: ARRAY
46339: PPUSH
46340: LD_EXP 116
46344: PUSH
46345: LD_VAR 0 2
46349: ARRAY
46350: PUSH
46351: LD_INT 1
46353: ARRAY
46354: PUSH
46355: LD_INT 2
46357: ARRAY
46358: PPUSH
46359: LD_EXP 116
46363: PUSH
46364: LD_VAR 0 2
46368: ARRAY
46369: PUSH
46370: LD_INT 1
46372: ARRAY
46373: PUSH
46374: LD_INT 3
46376: ARRAY
46377: PPUSH
46378: LD_EXP 116
46382: PUSH
46383: LD_VAR 0 2
46387: ARRAY
46388: PUSH
46389: LD_INT 1
46391: ARRAY
46392: PUSH
46393: LD_INT 4
46395: ARRAY
46396: PPUSH
46397: CALL 76781 0 5
46401: NOT
46402: IFFALSE 46452
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46404: LD_ADDR_EXP 116
46408: PUSH
46409: LD_EXP 116
46413: PPUSH
46414: LD_VAR 0 2
46418: PPUSH
46419: LD_EXP 116
46423: PUSH
46424: LD_VAR 0 2
46428: ARRAY
46429: PPUSH
46430: LD_INT 1
46432: PPUSH
46433: LD_INT 1
46435: NEG
46436: PPUSH
46437: LD_INT 0
46439: PPUSH
46440: CALL 69448 0 4
46444: PPUSH
46445: CALL_OW 1
46449: ST_TO_ADDR
// continue ;
46450: GO 45328
// end ; end ; end ;
46452: GO 45328
46454: POP
46455: POP
// end ;
46456: LD_VAR 0 1
46460: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46461: LD_INT 0
46463: PPUSH
46464: PPUSH
46465: PPUSH
46466: PPUSH
46467: PPUSH
46468: PPUSH
// if not mc_bases then
46469: LD_EXP 111
46473: NOT
46474: IFFALSE 46478
// exit ;
46476: GO 46905
// for i = 1 to mc_bases do
46478: LD_ADDR_VAR 0 2
46482: PUSH
46483: DOUBLE
46484: LD_INT 1
46486: DEC
46487: ST_TO_ADDR
46488: LD_EXP 111
46492: PUSH
46493: FOR_TO
46494: IFFALSE 46903
// begin tmp := mc_build_upgrade [ i ] ;
46496: LD_ADDR_VAR 0 4
46500: PUSH
46501: LD_EXP 143
46505: PUSH
46506: LD_VAR 0 2
46510: ARRAY
46511: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46512: LD_ADDR_VAR 0 6
46516: PUSH
46517: LD_EXP 144
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: PPUSH
46528: LD_INT 2
46530: PUSH
46531: LD_INT 30
46533: PUSH
46534: LD_INT 6
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 30
46543: PUSH
46544: LD_INT 7
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: EMPTY
46552: LIST
46553: LIST
46554: LIST
46555: PPUSH
46556: CALL_OW 72
46560: ST_TO_ADDR
// if not tmp and not lab then
46561: LD_VAR 0 4
46565: NOT
46566: PUSH
46567: LD_VAR 0 6
46571: NOT
46572: AND
46573: IFFALSE 46577
// continue ;
46575: GO 46493
// if tmp then
46577: LD_VAR 0 4
46581: IFFALSE 46701
// for j in tmp do
46583: LD_ADDR_VAR 0 3
46587: PUSH
46588: LD_VAR 0 4
46592: PUSH
46593: FOR_IN
46594: IFFALSE 46699
// begin if UpgradeCost ( j ) then
46596: LD_VAR 0 3
46600: PPUSH
46601: CALL 76441 0 1
46605: IFFALSE 46697
// begin ComUpgrade ( j ) ;
46607: LD_VAR 0 3
46611: PPUSH
46612: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46616: LD_ADDR_EXP 143
46620: PUSH
46621: LD_EXP 143
46625: PPUSH
46626: LD_VAR 0 2
46630: PPUSH
46631: LD_EXP 143
46635: PUSH
46636: LD_VAR 0 2
46640: ARRAY
46641: PUSH
46642: LD_VAR 0 3
46646: DIFF
46647: PPUSH
46648: CALL_OW 1
46652: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46653: LD_ADDR_EXP 118
46657: PUSH
46658: LD_EXP 118
46662: PPUSH
46663: LD_VAR 0 2
46667: PUSH
46668: LD_EXP 118
46672: PUSH
46673: LD_VAR 0 2
46677: ARRAY
46678: PUSH
46679: LD_INT 1
46681: PLUS
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PPUSH
46687: LD_VAR 0 3
46691: PPUSH
46692: CALL 70030 0 3
46696: ST_TO_ADDR
// end ; end ;
46697: GO 46593
46699: POP
46700: POP
// if not lab or not mc_lab_upgrade [ i ] then
46701: LD_VAR 0 6
46705: NOT
46706: PUSH
46707: LD_EXP 145
46711: PUSH
46712: LD_VAR 0 2
46716: ARRAY
46717: NOT
46718: OR
46719: IFFALSE 46723
// continue ;
46721: GO 46493
// for j in lab do
46723: LD_ADDR_VAR 0 3
46727: PUSH
46728: LD_VAR 0 6
46732: PUSH
46733: FOR_IN
46734: IFFALSE 46899
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46736: LD_VAR 0 3
46740: PPUSH
46741: CALL_OW 266
46745: PUSH
46746: LD_INT 6
46748: PUSH
46749: LD_INT 7
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: IN
46756: PUSH
46757: LD_VAR 0 3
46761: PPUSH
46762: CALL_OW 461
46766: PUSH
46767: LD_INT 1
46769: NONEQUAL
46770: AND
46771: IFFALSE 46897
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46773: LD_VAR 0 3
46777: PPUSH
46778: LD_EXP 145
46782: PUSH
46783: LD_VAR 0 2
46787: ARRAY
46788: PUSH
46789: LD_INT 1
46791: ARRAY
46792: PPUSH
46793: CALL 76646 0 2
46797: IFFALSE 46897
// begin ComCancel ( j ) ;
46799: LD_VAR 0 3
46803: PPUSH
46804: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46808: LD_VAR 0 3
46812: PPUSH
46813: LD_EXP 145
46817: PUSH
46818: LD_VAR 0 2
46822: ARRAY
46823: PUSH
46824: LD_INT 1
46826: ARRAY
46827: PPUSH
46828: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46832: LD_VAR 0 3
46836: PUSH
46837: LD_EXP 118
46841: PUSH
46842: LD_VAR 0 2
46846: ARRAY
46847: IN
46848: NOT
46849: IFFALSE 46895
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46851: LD_ADDR_EXP 118
46855: PUSH
46856: LD_EXP 118
46860: PPUSH
46861: LD_VAR 0 2
46865: PUSH
46866: LD_EXP 118
46870: PUSH
46871: LD_VAR 0 2
46875: ARRAY
46876: PUSH
46877: LD_INT 1
46879: PLUS
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PPUSH
46885: LD_VAR 0 3
46889: PPUSH
46890: CALL 70030 0 3
46894: ST_TO_ADDR
// break ;
46895: GO 46899
// end ; end ; end ;
46897: GO 46733
46899: POP
46900: POP
// end ;
46901: GO 46493
46903: POP
46904: POP
// end ;
46905: LD_VAR 0 1
46909: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46910: LD_INT 0
46912: PPUSH
46913: PPUSH
46914: PPUSH
46915: PPUSH
46916: PPUSH
46917: PPUSH
46918: PPUSH
46919: PPUSH
46920: PPUSH
// if not mc_bases then
46921: LD_EXP 111
46925: NOT
46926: IFFALSE 46930
// exit ;
46928: GO 47335
// for i = 1 to mc_bases do
46930: LD_ADDR_VAR 0 2
46934: PUSH
46935: DOUBLE
46936: LD_INT 1
46938: DEC
46939: ST_TO_ADDR
46940: LD_EXP 111
46944: PUSH
46945: FOR_TO
46946: IFFALSE 47333
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46948: LD_EXP 119
46952: PUSH
46953: LD_VAR 0 2
46957: ARRAY
46958: NOT
46959: PUSH
46960: LD_EXP 111
46964: PUSH
46965: LD_VAR 0 2
46969: ARRAY
46970: PPUSH
46971: LD_INT 30
46973: PUSH
46974: LD_INT 3
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: PPUSH
46981: CALL_OW 72
46985: NOT
46986: OR
46987: IFFALSE 46991
// continue ;
46989: GO 46945
// busy := false ;
46991: LD_ADDR_VAR 0 8
46995: PUSH
46996: LD_INT 0
46998: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46999: LD_ADDR_VAR 0 4
47003: PUSH
47004: LD_EXP 111
47008: PUSH
47009: LD_VAR 0 2
47013: ARRAY
47014: PPUSH
47015: LD_INT 30
47017: PUSH
47018: LD_INT 3
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PPUSH
47025: CALL_OW 72
47029: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47030: LD_ADDR_VAR 0 6
47034: PUSH
47035: LD_EXP 119
47039: PUSH
47040: LD_VAR 0 2
47044: ARRAY
47045: PPUSH
47046: LD_INT 2
47048: PUSH
47049: LD_INT 30
47051: PUSH
47052: LD_INT 32
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: PUSH
47059: LD_INT 30
47061: PUSH
47062: LD_INT 33
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: LIST
47073: PPUSH
47074: CALL_OW 72
47078: ST_TO_ADDR
// if not t then
47079: LD_VAR 0 6
47083: NOT
47084: IFFALSE 47088
// continue ;
47086: GO 46945
// for j in tmp do
47088: LD_ADDR_VAR 0 3
47092: PUSH
47093: LD_VAR 0 4
47097: PUSH
47098: FOR_IN
47099: IFFALSE 47129
// if not BuildingStatus ( j ) = bs_idle then
47101: LD_VAR 0 3
47105: PPUSH
47106: CALL_OW 461
47110: PUSH
47111: LD_INT 2
47113: EQUAL
47114: NOT
47115: IFFALSE 47127
// begin busy := true ;
47117: LD_ADDR_VAR 0 8
47121: PUSH
47122: LD_INT 1
47124: ST_TO_ADDR
// break ;
47125: GO 47129
// end ;
47127: GO 47098
47129: POP
47130: POP
// if busy then
47131: LD_VAR 0 8
47135: IFFALSE 47139
// continue ;
47137: GO 46945
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47139: LD_ADDR_VAR 0 7
47143: PUSH
47144: LD_VAR 0 6
47148: PPUSH
47149: LD_INT 35
47151: PUSH
47152: LD_INT 0
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: PPUSH
47159: CALL_OW 72
47163: ST_TO_ADDR
// if tw then
47164: LD_VAR 0 7
47168: IFFALSE 47245
// begin tw := tw [ 1 ] ;
47170: LD_ADDR_VAR 0 7
47174: PUSH
47175: LD_VAR 0 7
47179: PUSH
47180: LD_INT 1
47182: ARRAY
47183: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47184: LD_ADDR_VAR 0 9
47188: PUSH
47189: LD_VAR 0 7
47193: PPUSH
47194: LD_EXP 136
47198: PUSH
47199: LD_VAR 0 2
47203: ARRAY
47204: PPUSH
47205: CALL 75000 0 2
47209: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47210: LD_EXP 150
47214: PUSH
47215: LD_VAR 0 2
47219: ARRAY
47220: IFFALSE 47243
// if not weapon in mc_allowed_tower_weapons [ i ] then
47222: LD_VAR 0 9
47226: PUSH
47227: LD_EXP 150
47231: PUSH
47232: LD_VAR 0 2
47236: ARRAY
47237: IN
47238: NOT
47239: IFFALSE 47243
// continue ;
47241: GO 46945
// end else
47243: GO 47308
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47245: LD_ADDR_VAR 0 5
47249: PUSH
47250: LD_EXP 119
47254: PUSH
47255: LD_VAR 0 2
47259: ARRAY
47260: PPUSH
47261: LD_VAR 0 4
47265: PPUSH
47266: CALL 100502 0 2
47270: ST_TO_ADDR
// if not tmp2 then
47271: LD_VAR 0 5
47275: NOT
47276: IFFALSE 47280
// continue ;
47278: GO 46945
// tw := tmp2 [ 1 ] ;
47280: LD_ADDR_VAR 0 7
47284: PUSH
47285: LD_VAR 0 5
47289: PUSH
47290: LD_INT 1
47292: ARRAY
47293: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47294: LD_ADDR_VAR 0 9
47298: PUSH
47299: LD_VAR 0 5
47303: PUSH
47304: LD_INT 2
47306: ARRAY
47307: ST_TO_ADDR
// end ; if not weapon then
47308: LD_VAR 0 9
47312: NOT
47313: IFFALSE 47317
// continue ;
47315: GO 46945
// ComPlaceWeapon ( tw , weapon ) ;
47317: LD_VAR 0 7
47321: PPUSH
47322: LD_VAR 0 9
47326: PPUSH
47327: CALL_OW 148
// end ;
47331: GO 46945
47333: POP
47334: POP
// end ;
47335: LD_VAR 0 1
47339: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47340: LD_INT 0
47342: PPUSH
47343: PPUSH
47344: PPUSH
47345: PPUSH
47346: PPUSH
47347: PPUSH
// if not mc_bases then
47348: LD_EXP 111
47352: NOT
47353: IFFALSE 47357
// exit ;
47355: GO 48133
// for i = 1 to mc_bases do
47357: LD_ADDR_VAR 0 2
47361: PUSH
47362: DOUBLE
47363: LD_INT 1
47365: DEC
47366: ST_TO_ADDR
47367: LD_EXP 111
47371: PUSH
47372: FOR_TO
47373: IFFALSE 48131
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47375: LD_EXP 124
47379: PUSH
47380: LD_VAR 0 2
47384: ARRAY
47385: NOT
47386: PUSH
47387: LD_EXP 124
47391: PUSH
47392: LD_VAR 0 2
47396: ARRAY
47397: PUSH
47398: LD_EXP 125
47402: PUSH
47403: LD_VAR 0 2
47407: ARRAY
47408: EQUAL
47409: OR
47410: PUSH
47411: LD_EXP 134
47415: PUSH
47416: LD_VAR 0 2
47420: ARRAY
47421: OR
47422: IFFALSE 47426
// continue ;
47424: GO 47372
// if mc_miners [ i ] then
47426: LD_EXP 125
47430: PUSH
47431: LD_VAR 0 2
47435: ARRAY
47436: IFFALSE 47818
// begin for j = mc_miners [ i ] downto 1 do
47438: LD_ADDR_VAR 0 3
47442: PUSH
47443: DOUBLE
47444: LD_EXP 125
47448: PUSH
47449: LD_VAR 0 2
47453: ARRAY
47454: INC
47455: ST_TO_ADDR
47456: LD_INT 1
47458: PUSH
47459: FOR_DOWNTO
47460: IFFALSE 47816
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47462: LD_EXP 125
47466: PUSH
47467: LD_VAR 0 2
47471: ARRAY
47472: PUSH
47473: LD_VAR 0 3
47477: ARRAY
47478: PPUSH
47479: CALL_OW 301
47483: PUSH
47484: LD_EXP 125
47488: PUSH
47489: LD_VAR 0 2
47493: ARRAY
47494: PUSH
47495: LD_VAR 0 3
47499: ARRAY
47500: PPUSH
47501: CALL_OW 257
47505: PUSH
47506: LD_INT 1
47508: NONEQUAL
47509: OR
47510: IFFALSE 47573
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47512: LD_ADDR_VAR 0 5
47516: PUSH
47517: LD_EXP 125
47521: PUSH
47522: LD_VAR 0 2
47526: ARRAY
47527: PUSH
47528: LD_EXP 125
47532: PUSH
47533: LD_VAR 0 2
47537: ARRAY
47538: PUSH
47539: LD_VAR 0 3
47543: ARRAY
47544: DIFF
47545: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47546: LD_ADDR_EXP 125
47550: PUSH
47551: LD_EXP 125
47555: PPUSH
47556: LD_VAR 0 2
47560: PPUSH
47561: LD_VAR 0 5
47565: PPUSH
47566: CALL_OW 1
47570: ST_TO_ADDR
// continue ;
47571: GO 47459
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47573: LD_EXP 125
47577: PUSH
47578: LD_VAR 0 2
47582: ARRAY
47583: PUSH
47584: LD_VAR 0 3
47588: ARRAY
47589: PPUSH
47590: CALL_OW 257
47594: PUSH
47595: LD_INT 1
47597: EQUAL
47598: PUSH
47599: LD_EXP 125
47603: PUSH
47604: LD_VAR 0 2
47608: ARRAY
47609: PUSH
47610: LD_VAR 0 3
47614: ARRAY
47615: PPUSH
47616: CALL_OW 459
47620: NOT
47621: AND
47622: PUSH
47623: LD_EXP 125
47627: PUSH
47628: LD_VAR 0 2
47632: ARRAY
47633: PUSH
47634: LD_VAR 0 3
47638: ARRAY
47639: PPUSH
47640: CALL_OW 314
47644: NOT
47645: AND
47646: IFFALSE 47814
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47648: LD_EXP 125
47652: PUSH
47653: LD_VAR 0 2
47657: ARRAY
47658: PUSH
47659: LD_VAR 0 3
47663: ARRAY
47664: PPUSH
47665: CALL_OW 310
47669: IFFALSE 47692
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47671: LD_EXP 125
47675: PUSH
47676: LD_VAR 0 2
47680: ARRAY
47681: PUSH
47682: LD_VAR 0 3
47686: ARRAY
47687: PPUSH
47688: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47692: LD_EXP 125
47696: PUSH
47697: LD_VAR 0 2
47701: ARRAY
47702: PUSH
47703: LD_VAR 0 3
47707: ARRAY
47708: PPUSH
47709: CALL_OW 314
47713: NOT
47714: IFFALSE 47814
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47716: LD_EXP 125
47720: PUSH
47721: LD_VAR 0 2
47725: ARRAY
47726: PUSH
47727: LD_VAR 0 3
47731: ARRAY
47732: PPUSH
47733: LD_EXP 124
47737: PUSH
47738: LD_VAR 0 2
47742: ARRAY
47743: PUSH
47744: LD_VAR 0 3
47748: PUSH
47749: LD_EXP 124
47753: PUSH
47754: LD_VAR 0 2
47758: ARRAY
47759: MOD
47760: PUSH
47761: LD_INT 1
47763: PLUS
47764: ARRAY
47765: PUSH
47766: LD_INT 1
47768: ARRAY
47769: PPUSH
47770: LD_EXP 124
47774: PUSH
47775: LD_VAR 0 2
47779: ARRAY
47780: PUSH
47781: LD_VAR 0 3
47785: PUSH
47786: LD_EXP 124
47790: PUSH
47791: LD_VAR 0 2
47795: ARRAY
47796: MOD
47797: PUSH
47798: LD_INT 1
47800: PLUS
47801: ARRAY
47802: PUSH
47803: LD_INT 2
47805: ARRAY
47806: PPUSH
47807: LD_INT 0
47809: PPUSH
47810: CALL_OW 193
// end ; end ;
47814: GO 47459
47816: POP
47817: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47818: LD_ADDR_VAR 0 5
47822: PUSH
47823: LD_EXP 111
47827: PUSH
47828: LD_VAR 0 2
47832: ARRAY
47833: PPUSH
47834: LD_INT 2
47836: PUSH
47837: LD_INT 30
47839: PUSH
47840: LD_INT 4
47842: PUSH
47843: EMPTY
47844: LIST
47845: LIST
47846: PUSH
47847: LD_INT 30
47849: PUSH
47850: LD_INT 5
47852: PUSH
47853: EMPTY
47854: LIST
47855: LIST
47856: PUSH
47857: LD_INT 30
47859: PUSH
47860: LD_INT 32
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: PPUSH
47873: CALL_OW 72
47877: ST_TO_ADDR
// if not tmp then
47878: LD_VAR 0 5
47882: NOT
47883: IFFALSE 47887
// continue ;
47885: GO 47372
// list := [ ] ;
47887: LD_ADDR_VAR 0 6
47891: PUSH
47892: EMPTY
47893: ST_TO_ADDR
// for j in tmp do
47894: LD_ADDR_VAR 0 3
47898: PUSH
47899: LD_VAR 0 5
47903: PUSH
47904: FOR_IN
47905: IFFALSE 47974
// begin for k in UnitsInside ( j ) do
47907: LD_ADDR_VAR 0 4
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: CALL_OW 313
47921: PUSH
47922: FOR_IN
47923: IFFALSE 47970
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47925: LD_VAR 0 4
47929: PPUSH
47930: CALL_OW 257
47934: PUSH
47935: LD_INT 1
47937: EQUAL
47938: PUSH
47939: LD_VAR 0 4
47943: PPUSH
47944: CALL_OW 459
47948: NOT
47949: AND
47950: IFFALSE 47968
// list := list ^ k ;
47952: LD_ADDR_VAR 0 6
47956: PUSH
47957: LD_VAR 0 6
47961: PUSH
47962: LD_VAR 0 4
47966: ADD
47967: ST_TO_ADDR
47968: GO 47922
47970: POP
47971: POP
// end ;
47972: GO 47904
47974: POP
47975: POP
// list := list diff mc_miners [ i ] ;
47976: LD_ADDR_VAR 0 6
47980: PUSH
47981: LD_VAR 0 6
47985: PUSH
47986: LD_EXP 125
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: DIFF
47997: ST_TO_ADDR
// if not list then
47998: LD_VAR 0 6
48002: NOT
48003: IFFALSE 48007
// continue ;
48005: GO 47372
// k := mc_mines [ i ] - mc_miners [ i ] ;
48007: LD_ADDR_VAR 0 4
48011: PUSH
48012: LD_EXP 124
48016: PUSH
48017: LD_VAR 0 2
48021: ARRAY
48022: PUSH
48023: LD_EXP 125
48027: PUSH
48028: LD_VAR 0 2
48032: ARRAY
48033: MINUS
48034: ST_TO_ADDR
// if k > list then
48035: LD_VAR 0 4
48039: PUSH
48040: LD_VAR 0 6
48044: GREATER
48045: IFFALSE 48057
// k := list ;
48047: LD_ADDR_VAR 0 4
48051: PUSH
48052: LD_VAR 0 6
48056: ST_TO_ADDR
// for j = 1 to k do
48057: LD_ADDR_VAR 0 3
48061: PUSH
48062: DOUBLE
48063: LD_INT 1
48065: DEC
48066: ST_TO_ADDR
48067: LD_VAR 0 4
48071: PUSH
48072: FOR_TO
48073: IFFALSE 48127
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48075: LD_ADDR_EXP 125
48079: PUSH
48080: LD_EXP 125
48084: PPUSH
48085: LD_VAR 0 2
48089: PUSH
48090: LD_EXP 125
48094: PUSH
48095: LD_VAR 0 2
48099: ARRAY
48100: PUSH
48101: LD_INT 1
48103: PLUS
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: PPUSH
48109: LD_VAR 0 6
48113: PUSH
48114: LD_VAR 0 3
48118: ARRAY
48119: PPUSH
48120: CALL 70030 0 3
48124: ST_TO_ADDR
48125: GO 48072
48127: POP
48128: POP
// end ;
48129: GO 47372
48131: POP
48132: POP
// end ;
48133: LD_VAR 0 1
48137: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48138: LD_INT 0
48140: PPUSH
48141: PPUSH
48142: PPUSH
48143: PPUSH
48144: PPUSH
48145: PPUSH
48146: PPUSH
48147: PPUSH
48148: PPUSH
48149: PPUSH
// if not mc_bases then
48150: LD_EXP 111
48154: NOT
48155: IFFALSE 48159
// exit ;
48157: GO 49909
// for i = 1 to mc_bases do
48159: LD_ADDR_VAR 0 2
48163: PUSH
48164: DOUBLE
48165: LD_INT 1
48167: DEC
48168: ST_TO_ADDR
48169: LD_EXP 111
48173: PUSH
48174: FOR_TO
48175: IFFALSE 49907
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48177: LD_EXP 111
48181: PUSH
48182: LD_VAR 0 2
48186: ARRAY
48187: NOT
48188: PUSH
48189: LD_EXP 118
48193: PUSH
48194: LD_VAR 0 2
48198: ARRAY
48199: OR
48200: IFFALSE 48204
// continue ;
48202: GO 48174
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48204: LD_EXP 127
48208: PUSH
48209: LD_VAR 0 2
48213: ARRAY
48214: NOT
48215: PUSH
48216: LD_EXP 128
48220: PUSH
48221: LD_VAR 0 2
48225: ARRAY
48226: AND
48227: IFFALSE 48265
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48229: LD_ADDR_EXP 128
48233: PUSH
48234: LD_EXP 128
48238: PPUSH
48239: LD_VAR 0 2
48243: PPUSH
48244: EMPTY
48245: PPUSH
48246: CALL_OW 1
48250: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48251: LD_VAR 0 2
48255: PPUSH
48256: LD_INT 107
48258: PPUSH
48259: CALL 39139 0 2
// continue ;
48263: GO 48174
// end ; target := [ ] ;
48265: LD_ADDR_VAR 0 6
48269: PUSH
48270: EMPTY
48271: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48272: LD_ADDR_VAR 0 3
48276: PUSH
48277: DOUBLE
48278: LD_EXP 127
48282: PUSH
48283: LD_VAR 0 2
48287: ARRAY
48288: INC
48289: ST_TO_ADDR
48290: LD_INT 1
48292: PUSH
48293: FOR_DOWNTO
48294: IFFALSE 48554
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48296: LD_EXP 127
48300: PUSH
48301: LD_VAR 0 2
48305: ARRAY
48306: PUSH
48307: LD_VAR 0 3
48311: ARRAY
48312: PUSH
48313: LD_INT 2
48315: ARRAY
48316: PPUSH
48317: LD_EXP 127
48321: PUSH
48322: LD_VAR 0 2
48326: ARRAY
48327: PUSH
48328: LD_VAR 0 3
48332: ARRAY
48333: PUSH
48334: LD_INT 3
48336: ARRAY
48337: PPUSH
48338: CALL_OW 488
48342: PUSH
48343: LD_EXP 127
48347: PUSH
48348: LD_VAR 0 2
48352: ARRAY
48353: PUSH
48354: LD_VAR 0 3
48358: ARRAY
48359: PUSH
48360: LD_INT 2
48362: ARRAY
48363: PPUSH
48364: LD_EXP 127
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: PUSH
48375: LD_VAR 0 3
48379: ARRAY
48380: PUSH
48381: LD_INT 3
48383: ARRAY
48384: PPUSH
48385: CALL_OW 284
48389: PUSH
48390: LD_INT 0
48392: EQUAL
48393: AND
48394: IFFALSE 48449
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48396: LD_ADDR_VAR 0 5
48400: PUSH
48401: LD_EXP 127
48405: PUSH
48406: LD_VAR 0 2
48410: ARRAY
48411: PPUSH
48412: LD_VAR 0 3
48416: PPUSH
48417: CALL_OW 3
48421: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48422: LD_ADDR_EXP 127
48426: PUSH
48427: LD_EXP 127
48431: PPUSH
48432: LD_VAR 0 2
48436: PPUSH
48437: LD_VAR 0 5
48441: PPUSH
48442: CALL_OW 1
48446: ST_TO_ADDR
// continue ;
48447: GO 48293
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48449: LD_EXP 111
48453: PUSH
48454: LD_VAR 0 2
48458: ARRAY
48459: PUSH
48460: LD_INT 1
48462: ARRAY
48463: PPUSH
48464: CALL_OW 255
48468: PPUSH
48469: LD_EXP 127
48473: PUSH
48474: LD_VAR 0 2
48478: ARRAY
48479: PUSH
48480: LD_VAR 0 3
48484: ARRAY
48485: PUSH
48486: LD_INT 2
48488: ARRAY
48489: PPUSH
48490: LD_EXP 127
48494: PUSH
48495: LD_VAR 0 2
48499: ARRAY
48500: PUSH
48501: LD_VAR 0 3
48505: ARRAY
48506: PUSH
48507: LD_INT 3
48509: ARRAY
48510: PPUSH
48511: LD_INT 30
48513: PPUSH
48514: CALL 70926 0 4
48518: PUSH
48519: LD_INT 4
48521: ARRAY
48522: PUSH
48523: LD_INT 0
48525: EQUAL
48526: IFFALSE 48552
// begin target := mc_crates [ i ] [ j ] ;
48528: LD_ADDR_VAR 0 6
48532: PUSH
48533: LD_EXP 127
48537: PUSH
48538: LD_VAR 0 2
48542: ARRAY
48543: PUSH
48544: LD_VAR 0 3
48548: ARRAY
48549: ST_TO_ADDR
// break ;
48550: GO 48554
// end ; end ;
48552: GO 48293
48554: POP
48555: POP
// if not target then
48556: LD_VAR 0 6
48560: NOT
48561: IFFALSE 48565
// continue ;
48563: GO 48174
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48565: LD_ADDR_VAR 0 7
48569: PUSH
48570: LD_EXP 130
48574: PUSH
48575: LD_VAR 0 2
48579: ARRAY
48580: PPUSH
48581: LD_INT 2
48583: PUSH
48584: LD_INT 3
48586: PUSH
48587: LD_INT 58
48589: PUSH
48590: EMPTY
48591: LIST
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 61
48599: PUSH
48600: EMPTY
48601: LIST
48602: PUSH
48603: LD_INT 33
48605: PUSH
48606: LD_INT 5
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: LD_INT 33
48615: PUSH
48616: LD_INT 3
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: PUSH
48630: LD_INT 2
48632: PUSH
48633: LD_INT 34
48635: PUSH
48636: LD_INT 32
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_INT 34
48645: PUSH
48646: LD_INT 51
48648: PUSH
48649: EMPTY
48650: LIST
48651: LIST
48652: PUSH
48653: LD_INT 34
48655: PUSH
48656: LD_INT 12
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: EMPTY
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PPUSH
48673: CALL_OW 72
48677: ST_TO_ADDR
// if not cargo then
48678: LD_VAR 0 7
48682: NOT
48683: IFFALSE 49326
// begin if mc_crates_collector [ i ] < 5 then
48685: LD_EXP 128
48689: PUSH
48690: LD_VAR 0 2
48694: ARRAY
48695: PUSH
48696: LD_INT 5
48698: LESS
48699: IFFALSE 49065
// begin if mc_ape [ i ] then
48701: LD_EXP 140
48705: PUSH
48706: LD_VAR 0 2
48710: ARRAY
48711: IFFALSE 48758
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48713: LD_ADDR_VAR 0 5
48717: PUSH
48718: LD_EXP 140
48722: PUSH
48723: LD_VAR 0 2
48727: ARRAY
48728: PPUSH
48729: LD_INT 25
48731: PUSH
48732: LD_INT 16
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: LD_INT 24
48741: PUSH
48742: LD_INT 750
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: PUSH
48749: EMPTY
48750: LIST
48751: LIST
48752: PPUSH
48753: CALL_OW 72
48757: ST_TO_ADDR
// if not tmp then
48758: LD_VAR 0 5
48762: NOT
48763: IFFALSE 48810
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48765: LD_ADDR_VAR 0 5
48769: PUSH
48770: LD_EXP 111
48774: PUSH
48775: LD_VAR 0 2
48779: ARRAY
48780: PPUSH
48781: LD_INT 25
48783: PUSH
48784: LD_INT 2
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: PUSH
48791: LD_INT 24
48793: PUSH
48794: LD_INT 750
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PPUSH
48805: CALL_OW 72
48809: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48810: LD_EXP 140
48814: PUSH
48815: LD_VAR 0 2
48819: ARRAY
48820: PUSH
48821: LD_EXP 111
48825: PUSH
48826: LD_VAR 0 2
48830: ARRAY
48831: PPUSH
48832: LD_INT 25
48834: PUSH
48835: LD_INT 2
48837: PUSH
48838: EMPTY
48839: LIST
48840: LIST
48841: PUSH
48842: LD_INT 24
48844: PUSH
48845: LD_INT 750
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: PUSH
48852: EMPTY
48853: LIST
48854: LIST
48855: PPUSH
48856: CALL_OW 72
48860: AND
48861: PUSH
48862: LD_VAR 0 5
48866: PUSH
48867: LD_INT 5
48869: LESS
48870: AND
48871: IFFALSE 48953
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48873: LD_ADDR_VAR 0 3
48877: PUSH
48878: LD_EXP 111
48882: PUSH
48883: LD_VAR 0 2
48887: ARRAY
48888: PPUSH
48889: LD_INT 25
48891: PUSH
48892: LD_INT 2
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_INT 24
48901: PUSH
48902: LD_INT 750
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: PPUSH
48913: CALL_OW 72
48917: PUSH
48918: FOR_IN
48919: IFFALSE 48951
// begin tmp := tmp union j ;
48921: LD_ADDR_VAR 0 5
48925: PUSH
48926: LD_VAR 0 5
48930: PUSH
48931: LD_VAR 0 3
48935: UNION
48936: ST_TO_ADDR
// if tmp >= 5 then
48937: LD_VAR 0 5
48941: PUSH
48942: LD_INT 5
48944: GREATEREQUAL
48945: IFFALSE 48949
// break ;
48947: GO 48951
// end ;
48949: GO 48918
48951: POP
48952: POP
// end ; if not tmp then
48953: LD_VAR 0 5
48957: NOT
48958: IFFALSE 48962
// continue ;
48960: GO 48174
// for j in tmp do
48962: LD_ADDR_VAR 0 3
48966: PUSH
48967: LD_VAR 0 5
48971: PUSH
48972: FOR_IN
48973: IFFALSE 49063
// if not GetTag ( j ) then
48975: LD_VAR 0 3
48979: PPUSH
48980: CALL_OW 110
48984: NOT
48985: IFFALSE 49061
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48987: LD_ADDR_EXP 128
48991: PUSH
48992: LD_EXP 128
48996: PPUSH
48997: LD_VAR 0 2
49001: PUSH
49002: LD_EXP 128
49006: PUSH
49007: LD_VAR 0 2
49011: ARRAY
49012: PUSH
49013: LD_INT 1
49015: PLUS
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PPUSH
49021: LD_VAR 0 3
49025: PPUSH
49026: CALL 70030 0 3
49030: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49031: LD_VAR 0 3
49035: PPUSH
49036: LD_INT 107
49038: PPUSH
49039: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49043: LD_EXP 128
49047: PUSH
49048: LD_VAR 0 2
49052: ARRAY
49053: PUSH
49054: LD_INT 5
49056: GREATEREQUAL
49057: IFFALSE 49061
// break ;
49059: GO 49063
// end ;
49061: GO 48972
49063: POP
49064: POP
// end ; if mc_crates_collector [ i ] and target then
49065: LD_EXP 128
49069: PUSH
49070: LD_VAR 0 2
49074: ARRAY
49075: PUSH
49076: LD_VAR 0 6
49080: AND
49081: IFFALSE 49324
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49083: LD_EXP 128
49087: PUSH
49088: LD_VAR 0 2
49092: ARRAY
49093: PUSH
49094: LD_VAR 0 6
49098: PUSH
49099: LD_INT 1
49101: ARRAY
49102: LESS
49103: IFFALSE 49123
// tmp := mc_crates_collector [ i ] else
49105: LD_ADDR_VAR 0 5
49109: PUSH
49110: LD_EXP 128
49114: PUSH
49115: LD_VAR 0 2
49119: ARRAY
49120: ST_TO_ADDR
49121: GO 49137
// tmp := target [ 1 ] ;
49123: LD_ADDR_VAR 0 5
49127: PUSH
49128: LD_VAR 0 6
49132: PUSH
49133: LD_INT 1
49135: ARRAY
49136: ST_TO_ADDR
// k := 0 ;
49137: LD_ADDR_VAR 0 4
49141: PUSH
49142: LD_INT 0
49144: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49145: LD_ADDR_VAR 0 3
49149: PUSH
49150: LD_EXP 128
49154: PUSH
49155: LD_VAR 0 2
49159: ARRAY
49160: PUSH
49161: FOR_IN
49162: IFFALSE 49322
// begin k := k + 1 ;
49164: LD_ADDR_VAR 0 4
49168: PUSH
49169: LD_VAR 0 4
49173: PUSH
49174: LD_INT 1
49176: PLUS
49177: ST_TO_ADDR
// if k > tmp then
49178: LD_VAR 0 4
49182: PUSH
49183: LD_VAR 0 5
49187: GREATER
49188: IFFALSE 49192
// break ;
49190: GO 49322
// if not GetClass ( j ) in [ 2 , 16 ] then
49192: LD_VAR 0 3
49196: PPUSH
49197: CALL_OW 257
49201: PUSH
49202: LD_INT 2
49204: PUSH
49205: LD_INT 16
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: IN
49212: NOT
49213: IFFALSE 49266
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49215: LD_ADDR_EXP 128
49219: PUSH
49220: LD_EXP 128
49224: PPUSH
49225: LD_VAR 0 2
49229: PPUSH
49230: LD_EXP 128
49234: PUSH
49235: LD_VAR 0 2
49239: ARRAY
49240: PUSH
49241: LD_VAR 0 3
49245: DIFF
49246: PPUSH
49247: CALL_OW 1
49251: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49252: LD_VAR 0 3
49256: PPUSH
49257: LD_INT 0
49259: PPUSH
49260: CALL_OW 109
// continue ;
49264: GO 49161
// end ; if IsInUnit ( j ) then
49266: LD_VAR 0 3
49270: PPUSH
49271: CALL_OW 310
49275: IFFALSE 49286
// ComExitBuilding ( j ) ;
49277: LD_VAR 0 3
49281: PPUSH
49282: CALL_OW 122
// wait ( 3 ) ;
49286: LD_INT 3
49288: PPUSH
49289: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49293: LD_VAR 0 3
49297: PPUSH
49298: LD_VAR 0 6
49302: PUSH
49303: LD_INT 2
49305: ARRAY
49306: PPUSH
49307: LD_VAR 0 6
49311: PUSH
49312: LD_INT 3
49314: ARRAY
49315: PPUSH
49316: CALL_OW 117
// end ;
49320: GO 49161
49322: POP
49323: POP
// end ; end else
49324: GO 49905
// begin for j in cargo do
49326: LD_ADDR_VAR 0 3
49330: PUSH
49331: LD_VAR 0 7
49335: PUSH
49336: FOR_IN
49337: IFFALSE 49903
// begin if GetTag ( j ) <> 0 then
49339: LD_VAR 0 3
49343: PPUSH
49344: CALL_OW 110
49348: PUSH
49349: LD_INT 0
49351: NONEQUAL
49352: IFFALSE 49356
// continue ;
49354: GO 49336
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49356: LD_VAR 0 3
49360: PPUSH
49361: CALL_OW 256
49365: PUSH
49366: LD_INT 1000
49368: LESS
49369: PUSH
49370: LD_VAR 0 3
49374: PPUSH
49375: LD_EXP 135
49379: PUSH
49380: LD_VAR 0 2
49384: ARRAY
49385: PPUSH
49386: CALL_OW 308
49390: NOT
49391: AND
49392: IFFALSE 49414
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49394: LD_VAR 0 3
49398: PPUSH
49399: LD_EXP 135
49403: PUSH
49404: LD_VAR 0 2
49408: ARRAY
49409: PPUSH
49410: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49414: LD_VAR 0 3
49418: PPUSH
49419: CALL_OW 256
49423: PUSH
49424: LD_INT 1000
49426: LESS
49427: PUSH
49428: LD_VAR 0 3
49432: PPUSH
49433: LD_EXP 135
49437: PUSH
49438: LD_VAR 0 2
49442: ARRAY
49443: PPUSH
49444: CALL_OW 308
49448: AND
49449: IFFALSE 49453
// continue ;
49451: GO 49336
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49453: LD_VAR 0 3
49457: PPUSH
49458: CALL_OW 262
49462: PUSH
49463: LD_INT 2
49465: EQUAL
49466: PUSH
49467: LD_VAR 0 3
49471: PPUSH
49472: CALL_OW 261
49476: PUSH
49477: LD_INT 15
49479: LESS
49480: AND
49481: IFFALSE 49485
// continue ;
49483: GO 49336
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49485: LD_VAR 0 3
49489: PPUSH
49490: CALL_OW 262
49494: PUSH
49495: LD_INT 1
49497: EQUAL
49498: PUSH
49499: LD_VAR 0 3
49503: PPUSH
49504: CALL_OW 261
49508: PUSH
49509: LD_INT 10
49511: LESS
49512: AND
49513: IFFALSE 49842
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49515: LD_ADDR_VAR 0 8
49519: PUSH
49520: LD_EXP 111
49524: PUSH
49525: LD_VAR 0 2
49529: ARRAY
49530: PPUSH
49531: LD_INT 2
49533: PUSH
49534: LD_INT 30
49536: PUSH
49537: LD_INT 0
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PUSH
49544: LD_INT 30
49546: PUSH
49547: LD_INT 1
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: LIST
49558: PPUSH
49559: CALL_OW 72
49563: ST_TO_ADDR
// if not depot then
49564: LD_VAR 0 8
49568: NOT
49569: IFFALSE 49573
// continue ;
49571: GO 49336
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49573: LD_VAR 0 3
49577: PPUSH
49578: LD_VAR 0 8
49582: PPUSH
49583: LD_VAR 0 3
49587: PPUSH
49588: CALL_OW 74
49592: PPUSH
49593: CALL_OW 296
49597: PUSH
49598: LD_INT 6
49600: LESS
49601: IFFALSE 49617
// SetFuel ( j , 100 ) else
49603: LD_VAR 0 3
49607: PPUSH
49608: LD_INT 100
49610: PPUSH
49611: CALL_OW 240
49615: GO 49842
// if GetFuel ( j ) = 0 then
49617: LD_VAR 0 3
49621: PPUSH
49622: CALL_OW 261
49626: PUSH
49627: LD_INT 0
49629: EQUAL
49630: IFFALSE 49842
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49632: LD_ADDR_EXP 130
49636: PUSH
49637: LD_EXP 130
49641: PPUSH
49642: LD_VAR 0 2
49646: PPUSH
49647: LD_EXP 130
49651: PUSH
49652: LD_VAR 0 2
49656: ARRAY
49657: PUSH
49658: LD_VAR 0 3
49662: DIFF
49663: PPUSH
49664: CALL_OW 1
49668: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49669: LD_VAR 0 3
49673: PPUSH
49674: CALL_OW 263
49678: PUSH
49679: LD_INT 1
49681: EQUAL
49682: IFFALSE 49698
// ComExitVehicle ( IsInUnit ( j ) ) ;
49684: LD_VAR 0 3
49688: PPUSH
49689: CALL_OW 310
49693: PPUSH
49694: CALL_OW 121
// if GetControl ( j ) = control_remote then
49698: LD_VAR 0 3
49702: PPUSH
49703: CALL_OW 263
49707: PUSH
49708: LD_INT 2
49710: EQUAL
49711: IFFALSE 49722
// ComUnlink ( j ) ;
49713: LD_VAR 0 3
49717: PPUSH
49718: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49722: LD_ADDR_VAR 0 9
49726: PUSH
49727: LD_VAR 0 2
49731: PPUSH
49732: LD_INT 3
49734: PPUSH
49735: CALL 59195 0 2
49739: ST_TO_ADDR
// if fac then
49740: LD_VAR 0 9
49744: IFFALSE 49840
// begin for k in fac do
49746: LD_ADDR_VAR 0 4
49750: PUSH
49751: LD_VAR 0 9
49755: PUSH
49756: FOR_IN
49757: IFFALSE 49838
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49759: LD_ADDR_VAR 0 10
49763: PUSH
49764: LD_VAR 0 9
49768: PPUSH
49769: LD_VAR 0 3
49773: PPUSH
49774: CALL_OW 265
49778: PPUSH
49779: LD_VAR 0 3
49783: PPUSH
49784: CALL_OW 262
49788: PPUSH
49789: LD_VAR 0 3
49793: PPUSH
49794: CALL_OW 263
49798: PPUSH
49799: LD_VAR 0 3
49803: PPUSH
49804: CALL_OW 264
49808: PPUSH
49809: CALL 67562 0 5
49813: ST_TO_ADDR
// if components then
49814: LD_VAR 0 10
49818: IFFALSE 49836
// begin MC_InsertProduceList ( i , components ) ;
49820: LD_VAR 0 2
49824: PPUSH
49825: LD_VAR 0 10
49829: PPUSH
49830: CALL 58740 0 2
// break ;
49834: GO 49838
// end ; end ;
49836: GO 49756
49838: POP
49839: POP
// end ; continue ;
49840: GO 49336
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49842: LD_VAR 0 3
49846: PPUSH
49847: LD_INT 1
49849: PPUSH
49850: CALL_OW 289
49854: PUSH
49855: LD_INT 100
49857: LESS
49858: PUSH
49859: LD_VAR 0 3
49863: PPUSH
49864: CALL_OW 314
49868: NOT
49869: AND
49870: IFFALSE 49899
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49872: LD_VAR 0 3
49876: PPUSH
49877: LD_VAR 0 6
49881: PUSH
49882: LD_INT 2
49884: ARRAY
49885: PPUSH
49886: LD_VAR 0 6
49890: PUSH
49891: LD_INT 3
49893: ARRAY
49894: PPUSH
49895: CALL_OW 117
// break ;
49899: GO 49903
// end ;
49901: GO 49336
49903: POP
49904: POP
// end ; end ;
49905: GO 48174
49907: POP
49908: POP
// end ;
49909: LD_VAR 0 1
49913: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49914: LD_INT 0
49916: PPUSH
49917: PPUSH
49918: PPUSH
49919: PPUSH
// if not mc_bases then
49920: LD_EXP 111
49924: NOT
49925: IFFALSE 49929
// exit ;
49927: GO 50090
// for i = 1 to mc_bases do
49929: LD_ADDR_VAR 0 2
49933: PUSH
49934: DOUBLE
49935: LD_INT 1
49937: DEC
49938: ST_TO_ADDR
49939: LD_EXP 111
49943: PUSH
49944: FOR_TO
49945: IFFALSE 50088
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49947: LD_ADDR_VAR 0 4
49951: PUSH
49952: LD_EXP 130
49956: PUSH
49957: LD_VAR 0 2
49961: ARRAY
49962: PUSH
49963: LD_EXP 133
49967: PUSH
49968: LD_VAR 0 2
49972: ARRAY
49973: UNION
49974: PPUSH
49975: LD_INT 33
49977: PUSH
49978: LD_INT 2
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PPUSH
49985: CALL_OW 72
49989: ST_TO_ADDR
// if tmp then
49990: LD_VAR 0 4
49994: IFFALSE 50086
// for j in tmp do
49996: LD_ADDR_VAR 0 3
50000: PUSH
50001: LD_VAR 0 4
50005: PUSH
50006: FOR_IN
50007: IFFALSE 50084
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50009: LD_VAR 0 3
50013: PPUSH
50014: CALL_OW 312
50018: NOT
50019: PUSH
50020: LD_VAR 0 3
50024: PPUSH
50025: CALL_OW 256
50029: PUSH
50030: LD_INT 250
50032: GREATEREQUAL
50033: AND
50034: IFFALSE 50047
// Connect ( j ) else
50036: LD_VAR 0 3
50040: PPUSH
50041: CALL 72963 0 1
50045: GO 50082
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50047: LD_VAR 0 3
50051: PPUSH
50052: CALL_OW 256
50056: PUSH
50057: LD_INT 250
50059: LESS
50060: PUSH
50061: LD_VAR 0 3
50065: PPUSH
50066: CALL_OW 312
50070: AND
50071: IFFALSE 50082
// ComUnlink ( j ) ;
50073: LD_VAR 0 3
50077: PPUSH
50078: CALL_OW 136
50082: GO 50006
50084: POP
50085: POP
// end ;
50086: GO 49944
50088: POP
50089: POP
// end ;
50090: LD_VAR 0 1
50094: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50095: LD_INT 0
50097: PPUSH
50098: PPUSH
50099: PPUSH
50100: PPUSH
50101: PPUSH
// if not mc_bases then
50102: LD_EXP 111
50106: NOT
50107: IFFALSE 50111
// exit ;
50109: GO 50556
// for i = 1 to mc_bases do
50111: LD_ADDR_VAR 0 2
50115: PUSH
50116: DOUBLE
50117: LD_INT 1
50119: DEC
50120: ST_TO_ADDR
50121: LD_EXP 111
50125: PUSH
50126: FOR_TO
50127: IFFALSE 50554
// begin if not mc_produce [ i ] then
50129: LD_EXP 132
50133: PUSH
50134: LD_VAR 0 2
50138: ARRAY
50139: NOT
50140: IFFALSE 50144
// continue ;
50142: GO 50126
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50144: LD_ADDR_VAR 0 5
50148: PUSH
50149: LD_EXP 111
50153: PUSH
50154: LD_VAR 0 2
50158: ARRAY
50159: PPUSH
50160: LD_INT 30
50162: PUSH
50163: LD_INT 3
50165: PUSH
50166: EMPTY
50167: LIST
50168: LIST
50169: PPUSH
50170: CALL_OW 72
50174: ST_TO_ADDR
// if not fac then
50175: LD_VAR 0 5
50179: NOT
50180: IFFALSE 50184
// continue ;
50182: GO 50126
// for j in fac do
50184: LD_ADDR_VAR 0 3
50188: PUSH
50189: LD_VAR 0 5
50193: PUSH
50194: FOR_IN
50195: IFFALSE 50550
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50197: LD_VAR 0 3
50201: PPUSH
50202: CALL_OW 461
50206: PUSH
50207: LD_INT 2
50209: NONEQUAL
50210: PUSH
50211: LD_VAR 0 3
50215: PPUSH
50216: LD_INT 15
50218: PPUSH
50219: CALL 72623 0 2
50223: PUSH
50224: LD_INT 4
50226: ARRAY
50227: OR
50228: IFFALSE 50232
// continue ;
50230: GO 50194
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50232: LD_VAR 0 3
50236: PPUSH
50237: LD_EXP 132
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: PUSH
50248: LD_INT 1
50250: ARRAY
50251: PUSH
50252: LD_INT 1
50254: ARRAY
50255: PPUSH
50256: LD_EXP 132
50260: PUSH
50261: LD_VAR 0 2
50265: ARRAY
50266: PUSH
50267: LD_INT 1
50269: ARRAY
50270: PUSH
50271: LD_INT 2
50273: ARRAY
50274: PPUSH
50275: LD_EXP 132
50279: PUSH
50280: LD_VAR 0 2
50284: ARRAY
50285: PUSH
50286: LD_INT 1
50288: ARRAY
50289: PUSH
50290: LD_INT 3
50292: ARRAY
50293: PPUSH
50294: LD_EXP 132
50298: PUSH
50299: LD_VAR 0 2
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PUSH
50309: LD_INT 4
50311: ARRAY
50312: PPUSH
50313: CALL_OW 448
50317: PUSH
50318: LD_VAR 0 3
50322: PPUSH
50323: LD_EXP 132
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 1
50340: ARRAY
50341: PUSH
50342: LD_EXP 132
50346: PUSH
50347: LD_VAR 0 2
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: ARRAY
50356: PUSH
50357: LD_INT 2
50359: ARRAY
50360: PUSH
50361: LD_EXP 132
50365: PUSH
50366: LD_VAR 0 2
50370: ARRAY
50371: PUSH
50372: LD_INT 1
50374: ARRAY
50375: PUSH
50376: LD_INT 3
50378: ARRAY
50379: PUSH
50380: LD_EXP 132
50384: PUSH
50385: LD_VAR 0 2
50389: ARRAY
50390: PUSH
50391: LD_INT 1
50393: ARRAY
50394: PUSH
50395: LD_INT 4
50397: ARRAY
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: PPUSH
50405: CALL 76294 0 2
50409: AND
50410: IFFALSE 50548
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50412: LD_VAR 0 3
50416: PPUSH
50417: LD_EXP 132
50421: PUSH
50422: LD_VAR 0 2
50426: ARRAY
50427: PUSH
50428: LD_INT 1
50430: ARRAY
50431: PUSH
50432: LD_INT 1
50434: ARRAY
50435: PPUSH
50436: LD_EXP 132
50440: PUSH
50441: LD_VAR 0 2
50445: ARRAY
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: PUSH
50451: LD_INT 2
50453: ARRAY
50454: PPUSH
50455: LD_EXP 132
50459: PUSH
50460: LD_VAR 0 2
50464: ARRAY
50465: PUSH
50466: LD_INT 1
50468: ARRAY
50469: PUSH
50470: LD_INT 3
50472: ARRAY
50473: PPUSH
50474: LD_EXP 132
50478: PUSH
50479: LD_VAR 0 2
50483: ARRAY
50484: PUSH
50485: LD_INT 1
50487: ARRAY
50488: PUSH
50489: LD_INT 4
50491: ARRAY
50492: PPUSH
50493: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50497: LD_ADDR_VAR 0 4
50501: PUSH
50502: LD_EXP 132
50506: PUSH
50507: LD_VAR 0 2
50511: ARRAY
50512: PPUSH
50513: LD_INT 1
50515: PPUSH
50516: CALL_OW 3
50520: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50521: LD_ADDR_EXP 132
50525: PUSH
50526: LD_EXP 132
50530: PPUSH
50531: LD_VAR 0 2
50535: PPUSH
50536: LD_VAR 0 4
50540: PPUSH
50541: CALL_OW 1
50545: ST_TO_ADDR
// break ;
50546: GO 50550
// end ; end ;
50548: GO 50194
50550: POP
50551: POP
// end ;
50552: GO 50126
50554: POP
50555: POP
// end ;
50556: LD_VAR 0 1
50560: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50561: LD_INT 0
50563: PPUSH
50564: PPUSH
50565: PPUSH
// if not mc_bases then
50566: LD_EXP 111
50570: NOT
50571: IFFALSE 50575
// exit ;
50573: GO 50664
// for i = 1 to mc_bases do
50575: LD_ADDR_VAR 0 2
50579: PUSH
50580: DOUBLE
50581: LD_INT 1
50583: DEC
50584: ST_TO_ADDR
50585: LD_EXP 111
50589: PUSH
50590: FOR_TO
50591: IFFALSE 50662
// begin if mc_attack [ i ] then
50593: LD_EXP 131
50597: PUSH
50598: LD_VAR 0 2
50602: ARRAY
50603: IFFALSE 50660
// begin tmp := mc_attack [ i ] [ 1 ] ;
50605: LD_ADDR_VAR 0 3
50609: PUSH
50610: LD_EXP 131
50614: PUSH
50615: LD_VAR 0 2
50619: ARRAY
50620: PUSH
50621: LD_INT 1
50623: ARRAY
50624: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50625: LD_ADDR_EXP 131
50629: PUSH
50630: LD_EXP 131
50634: PPUSH
50635: LD_VAR 0 2
50639: PPUSH
50640: EMPTY
50641: PPUSH
50642: CALL_OW 1
50646: ST_TO_ADDR
// Attack ( tmp ) ;
50647: LD_VAR 0 3
50651: PPUSH
50652: CALL 113059 0 1
// exit ;
50656: POP
50657: POP
50658: GO 50664
// end ; end ;
50660: GO 50590
50662: POP
50663: POP
// end ;
50664: LD_VAR 0 1
50668: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
50677: PPUSH
// if not mc_bases then
50678: LD_EXP 111
50682: NOT
50683: IFFALSE 50687
// exit ;
50685: GO 51269
// for i = 1 to mc_bases do
50687: LD_ADDR_VAR 0 2
50691: PUSH
50692: DOUBLE
50693: LD_INT 1
50695: DEC
50696: ST_TO_ADDR
50697: LD_EXP 111
50701: PUSH
50702: FOR_TO
50703: IFFALSE 51267
// begin if not mc_bases [ i ] then
50705: LD_EXP 111
50709: PUSH
50710: LD_VAR 0 2
50714: ARRAY
50715: NOT
50716: IFFALSE 50720
// continue ;
50718: GO 50702
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50720: LD_ADDR_VAR 0 7
50724: PUSH
50725: LD_EXP 111
50729: PUSH
50730: LD_VAR 0 2
50734: ARRAY
50735: PUSH
50736: LD_INT 1
50738: ARRAY
50739: PPUSH
50740: CALL 66866 0 1
50744: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50745: LD_ADDR_EXP 134
50749: PUSH
50750: LD_EXP 134
50754: PPUSH
50755: LD_VAR 0 2
50759: PPUSH
50760: LD_EXP 111
50764: PUSH
50765: LD_VAR 0 2
50769: ARRAY
50770: PUSH
50771: LD_INT 1
50773: ARRAY
50774: PPUSH
50775: CALL_OW 255
50779: PPUSH
50780: LD_EXP 136
50784: PUSH
50785: LD_VAR 0 2
50789: ARRAY
50790: PPUSH
50791: CALL 66831 0 2
50795: PPUSH
50796: CALL_OW 1
50800: ST_TO_ADDR
// if not mc_scan [ i ] then
50801: LD_EXP 134
50805: PUSH
50806: LD_VAR 0 2
50810: ARRAY
50811: NOT
50812: IFFALSE 50967
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50814: LD_ADDR_VAR 0 4
50818: PUSH
50819: LD_EXP 111
50823: PUSH
50824: LD_VAR 0 2
50828: ARRAY
50829: PPUSH
50830: LD_INT 2
50832: PUSH
50833: LD_INT 25
50835: PUSH
50836: LD_INT 5
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 25
50845: PUSH
50846: LD_INT 8
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PUSH
50853: LD_INT 25
50855: PUSH
50856: LD_INT 9
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: PPUSH
50869: CALL_OW 72
50873: ST_TO_ADDR
// if not tmp then
50874: LD_VAR 0 4
50878: NOT
50879: IFFALSE 50883
// continue ;
50881: GO 50702
// for j in tmp do
50883: LD_ADDR_VAR 0 3
50887: PUSH
50888: LD_VAR 0 4
50892: PUSH
50893: FOR_IN
50894: IFFALSE 50965
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50896: LD_VAR 0 3
50900: PPUSH
50901: CALL_OW 310
50905: PPUSH
50906: CALL_OW 266
50910: PUSH
50911: LD_INT 5
50913: EQUAL
50914: PUSH
50915: LD_VAR 0 3
50919: PPUSH
50920: CALL_OW 257
50924: PUSH
50925: LD_INT 1
50927: EQUAL
50928: AND
50929: PUSH
50930: LD_VAR 0 3
50934: PPUSH
50935: CALL_OW 459
50939: NOT
50940: AND
50941: PUSH
50942: LD_VAR 0 7
50946: AND
50947: IFFALSE 50963
// ComChangeProfession ( j , class ) ;
50949: LD_VAR 0 3
50953: PPUSH
50954: LD_VAR 0 7
50958: PPUSH
50959: CALL_OW 123
50963: GO 50893
50965: POP
50966: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50967: LD_EXP 134
50971: PUSH
50972: LD_VAR 0 2
50976: ARRAY
50977: PUSH
50978: LD_EXP 133
50982: PUSH
50983: LD_VAR 0 2
50987: ARRAY
50988: NOT
50989: AND
50990: PUSH
50991: LD_EXP 111
50995: PUSH
50996: LD_VAR 0 2
51000: ARRAY
51001: PPUSH
51002: LD_INT 30
51004: PUSH
51005: LD_INT 32
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PPUSH
51012: CALL_OW 72
51016: NOT
51017: AND
51018: PUSH
51019: LD_EXP 111
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: PPUSH
51030: LD_INT 2
51032: PUSH
51033: LD_INT 30
51035: PUSH
51036: LD_INT 4
51038: PUSH
51039: EMPTY
51040: LIST
51041: LIST
51042: PUSH
51043: LD_INT 30
51045: PUSH
51046: LD_INT 5
51048: PUSH
51049: EMPTY
51050: LIST
51051: LIST
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: LIST
51057: PPUSH
51058: CALL_OW 72
51062: NOT
51063: AND
51064: IFFALSE 51196
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51066: LD_ADDR_VAR 0 4
51070: PUSH
51071: LD_EXP 111
51075: PUSH
51076: LD_VAR 0 2
51080: ARRAY
51081: PPUSH
51082: LD_INT 2
51084: PUSH
51085: LD_INT 25
51087: PUSH
51088: LD_INT 1
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: PUSH
51095: LD_INT 25
51097: PUSH
51098: LD_INT 5
51100: PUSH
51101: EMPTY
51102: LIST
51103: LIST
51104: PUSH
51105: LD_INT 25
51107: PUSH
51108: LD_INT 8
51110: PUSH
51111: EMPTY
51112: LIST
51113: LIST
51114: PUSH
51115: LD_INT 25
51117: PUSH
51118: LD_INT 9
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: PUSH
51125: EMPTY
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: PPUSH
51132: CALL_OW 72
51136: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51137: LD_ADDR_VAR 0 4
51141: PUSH
51142: LD_VAR 0 4
51146: PUSH
51147: LD_VAR 0 4
51151: PPUSH
51152: LD_INT 18
51154: PPUSH
51155: CALL 98591 0 2
51159: DIFF
51160: ST_TO_ADDR
// if tmp then
51161: LD_VAR 0 4
51165: IFFALSE 51196
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51167: LD_VAR 0 2
51171: PPUSH
51172: LD_VAR 0 4
51176: PPUSH
51177: LD_EXP 136
51181: PUSH
51182: LD_VAR 0 2
51186: ARRAY
51187: PPUSH
51188: CALL 117768 0 3
// exit ;
51192: POP
51193: POP
51194: GO 51269
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51196: LD_EXP 134
51200: PUSH
51201: LD_VAR 0 2
51205: ARRAY
51206: PUSH
51207: LD_EXP 133
51211: PUSH
51212: LD_VAR 0 2
51216: ARRAY
51217: AND
51218: IFFALSE 51265
// begin tmp := mc_defender [ i ] ;
51220: LD_ADDR_VAR 0 4
51224: PUSH
51225: LD_EXP 133
51229: PUSH
51230: LD_VAR 0 2
51234: ARRAY
51235: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51236: LD_VAR 0 2
51240: PPUSH
51241: LD_VAR 0 4
51245: PPUSH
51246: LD_EXP 134
51250: PUSH
51251: LD_VAR 0 2
51255: ARRAY
51256: PPUSH
51257: CALL 118329 0 3
// exit ;
51261: POP
51262: POP
51263: GO 51269
// end ; end ;
51265: GO 50702
51267: POP
51268: POP
// end ;
51269: LD_VAR 0 1
51273: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51274: LD_INT 0
51276: PPUSH
51277: PPUSH
51278: PPUSH
51279: PPUSH
51280: PPUSH
51281: PPUSH
51282: PPUSH
51283: PPUSH
51284: PPUSH
51285: PPUSH
51286: PPUSH
// if not mc_bases then
51287: LD_EXP 111
51291: NOT
51292: IFFALSE 51296
// exit ;
51294: GO 52383
// for i = 1 to mc_bases do
51296: LD_ADDR_VAR 0 2
51300: PUSH
51301: DOUBLE
51302: LD_INT 1
51304: DEC
51305: ST_TO_ADDR
51306: LD_EXP 111
51310: PUSH
51311: FOR_TO
51312: IFFALSE 52381
// begin tmp := mc_lab [ i ] ;
51314: LD_ADDR_VAR 0 6
51318: PUSH
51319: LD_EXP 144
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: ST_TO_ADDR
// if not tmp then
51330: LD_VAR 0 6
51334: NOT
51335: IFFALSE 51339
// continue ;
51337: GO 51311
// idle_lab := 0 ;
51339: LD_ADDR_VAR 0 11
51343: PUSH
51344: LD_INT 0
51346: ST_TO_ADDR
// for j in tmp do
51347: LD_ADDR_VAR 0 3
51351: PUSH
51352: LD_VAR 0 6
51356: PUSH
51357: FOR_IN
51358: IFFALSE 52377
// begin researching := false ;
51360: LD_ADDR_VAR 0 10
51364: PUSH
51365: LD_INT 0
51367: ST_TO_ADDR
// side := GetSide ( j ) ;
51368: LD_ADDR_VAR 0 4
51372: PUSH
51373: LD_VAR 0 3
51377: PPUSH
51378: CALL_OW 255
51382: ST_TO_ADDR
// if not mc_tech [ side ] then
51383: LD_EXP 138
51387: PUSH
51388: LD_VAR 0 4
51392: ARRAY
51393: NOT
51394: IFFALSE 51398
// continue ;
51396: GO 51357
// if BuildingStatus ( j ) = bs_idle then
51398: LD_VAR 0 3
51402: PPUSH
51403: CALL_OW 461
51407: PUSH
51408: LD_INT 2
51410: EQUAL
51411: IFFALSE 51599
// begin if idle_lab and UnitsInside ( j ) < 6 then
51413: LD_VAR 0 11
51417: PUSH
51418: LD_VAR 0 3
51422: PPUSH
51423: CALL_OW 313
51427: PUSH
51428: LD_INT 6
51430: LESS
51431: AND
51432: IFFALSE 51503
// begin tmp2 := UnitsInside ( idle_lab ) ;
51434: LD_ADDR_VAR 0 9
51438: PUSH
51439: LD_VAR 0 11
51443: PPUSH
51444: CALL_OW 313
51448: ST_TO_ADDR
// if tmp2 then
51449: LD_VAR 0 9
51453: IFFALSE 51495
// for x in tmp2 do
51455: LD_ADDR_VAR 0 7
51459: PUSH
51460: LD_VAR 0 9
51464: PUSH
51465: FOR_IN
51466: IFFALSE 51493
// begin ComExitBuilding ( x ) ;
51468: LD_VAR 0 7
51472: PPUSH
51473: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51477: LD_VAR 0 7
51481: PPUSH
51482: LD_VAR 0 3
51486: PPUSH
51487: CALL_OW 180
// end ;
51491: GO 51465
51493: POP
51494: POP
// idle_lab := 0 ;
51495: LD_ADDR_VAR 0 11
51499: PUSH
51500: LD_INT 0
51502: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51503: LD_ADDR_VAR 0 5
51507: PUSH
51508: LD_EXP 138
51512: PUSH
51513: LD_VAR 0 4
51517: ARRAY
51518: PUSH
51519: FOR_IN
51520: IFFALSE 51580
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51522: LD_VAR 0 3
51526: PPUSH
51527: LD_VAR 0 5
51531: PPUSH
51532: CALL_OW 430
51536: PUSH
51537: LD_VAR 0 4
51541: PPUSH
51542: LD_VAR 0 5
51546: PPUSH
51547: CALL 65936 0 2
51551: AND
51552: IFFALSE 51578
// begin researching := true ;
51554: LD_ADDR_VAR 0 10
51558: PUSH
51559: LD_INT 1
51561: ST_TO_ADDR
// ComResearch ( j , t ) ;
51562: LD_VAR 0 3
51566: PPUSH
51567: LD_VAR 0 5
51571: PPUSH
51572: CALL_OW 124
// break ;
51576: GO 51580
// end ;
51578: GO 51519
51580: POP
51581: POP
// if not researching then
51582: LD_VAR 0 10
51586: NOT
51587: IFFALSE 51599
// idle_lab := j ;
51589: LD_ADDR_VAR 0 11
51593: PUSH
51594: LD_VAR 0 3
51598: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51599: LD_VAR 0 3
51603: PPUSH
51604: CALL_OW 461
51608: PUSH
51609: LD_INT 10
51611: EQUAL
51612: IFFALSE 52200
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51614: LD_EXP 140
51618: PUSH
51619: LD_VAR 0 2
51623: ARRAY
51624: NOT
51625: PUSH
51626: LD_EXP 141
51630: PUSH
51631: LD_VAR 0 2
51635: ARRAY
51636: NOT
51637: AND
51638: PUSH
51639: LD_EXP 138
51643: PUSH
51644: LD_VAR 0 4
51648: ARRAY
51649: PUSH
51650: LD_INT 1
51652: GREATER
51653: AND
51654: IFFALSE 51785
// begin ComCancel ( j ) ;
51656: LD_VAR 0 3
51660: PPUSH
51661: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51665: LD_ADDR_EXP 138
51669: PUSH
51670: LD_EXP 138
51674: PPUSH
51675: LD_VAR 0 4
51679: PPUSH
51680: LD_EXP 138
51684: PUSH
51685: LD_VAR 0 4
51689: ARRAY
51690: PPUSH
51691: LD_EXP 138
51695: PUSH
51696: LD_VAR 0 4
51700: ARRAY
51701: PUSH
51702: LD_INT 1
51704: MINUS
51705: PPUSH
51706: LD_EXP 138
51710: PUSH
51711: LD_VAR 0 4
51715: ARRAY
51716: PPUSH
51717: LD_INT 0
51719: PPUSH
51720: CALL 69448 0 4
51724: PPUSH
51725: CALL_OW 1
51729: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51730: LD_ADDR_EXP 138
51734: PUSH
51735: LD_EXP 138
51739: PPUSH
51740: LD_VAR 0 4
51744: PPUSH
51745: LD_EXP 138
51749: PUSH
51750: LD_VAR 0 4
51754: ARRAY
51755: PPUSH
51756: LD_EXP 138
51760: PUSH
51761: LD_VAR 0 4
51765: ARRAY
51766: PPUSH
51767: LD_INT 1
51769: PPUSH
51770: LD_INT 0
51772: PPUSH
51773: CALL 69448 0 4
51777: PPUSH
51778: CALL_OW 1
51782: ST_TO_ADDR
// continue ;
51783: GO 51357
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51785: LD_EXP 140
51789: PUSH
51790: LD_VAR 0 2
51794: ARRAY
51795: PUSH
51796: LD_EXP 141
51800: PUSH
51801: LD_VAR 0 2
51805: ARRAY
51806: NOT
51807: AND
51808: IFFALSE 51935
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51810: LD_ADDR_EXP 141
51814: PUSH
51815: LD_EXP 141
51819: PPUSH
51820: LD_VAR 0 2
51824: PUSH
51825: LD_EXP 141
51829: PUSH
51830: LD_VAR 0 2
51834: ARRAY
51835: PUSH
51836: LD_INT 1
51838: PLUS
51839: PUSH
51840: EMPTY
51841: LIST
51842: LIST
51843: PPUSH
51844: LD_EXP 140
51848: PUSH
51849: LD_VAR 0 2
51853: ARRAY
51854: PUSH
51855: LD_INT 1
51857: ARRAY
51858: PPUSH
51859: CALL 70030 0 3
51863: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51864: LD_EXP 140
51868: PUSH
51869: LD_VAR 0 2
51873: ARRAY
51874: PUSH
51875: LD_INT 1
51877: ARRAY
51878: PPUSH
51879: LD_INT 112
51881: PPUSH
51882: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51886: LD_ADDR_VAR 0 9
51890: PUSH
51891: LD_EXP 140
51895: PUSH
51896: LD_VAR 0 2
51900: ARRAY
51901: PPUSH
51902: LD_INT 1
51904: PPUSH
51905: CALL_OW 3
51909: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51910: LD_ADDR_EXP 140
51914: PUSH
51915: LD_EXP 140
51919: PPUSH
51920: LD_VAR 0 2
51924: PPUSH
51925: LD_VAR 0 9
51929: PPUSH
51930: CALL_OW 1
51934: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51935: LD_EXP 140
51939: PUSH
51940: LD_VAR 0 2
51944: ARRAY
51945: PUSH
51946: LD_EXP 141
51950: PUSH
51951: LD_VAR 0 2
51955: ARRAY
51956: AND
51957: PUSH
51958: LD_EXP 141
51962: PUSH
51963: LD_VAR 0 2
51967: ARRAY
51968: PUSH
51969: LD_INT 1
51971: ARRAY
51972: PPUSH
51973: CALL_OW 310
51977: NOT
51978: AND
51979: PUSH
51980: LD_VAR 0 3
51984: PPUSH
51985: CALL_OW 313
51989: PUSH
51990: LD_INT 6
51992: EQUAL
51993: AND
51994: IFFALSE 52050
// begin tmp2 := UnitsInside ( j ) ;
51996: LD_ADDR_VAR 0 9
52000: PUSH
52001: LD_VAR 0 3
52005: PPUSH
52006: CALL_OW 313
52010: ST_TO_ADDR
// if tmp2 = 6 then
52011: LD_VAR 0 9
52015: PUSH
52016: LD_INT 6
52018: EQUAL
52019: IFFALSE 52050
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52021: LD_VAR 0 9
52025: PUSH
52026: LD_INT 1
52028: ARRAY
52029: PPUSH
52030: LD_INT 112
52032: PPUSH
52033: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52037: LD_VAR 0 9
52041: PUSH
52042: LD_INT 1
52044: ARRAY
52045: PPUSH
52046: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52050: LD_EXP 141
52054: PUSH
52055: LD_VAR 0 2
52059: ARRAY
52060: PUSH
52061: LD_EXP 141
52065: PUSH
52066: LD_VAR 0 2
52070: ARRAY
52071: PUSH
52072: LD_INT 1
52074: ARRAY
52075: PPUSH
52076: CALL_OW 314
52080: NOT
52081: AND
52082: PUSH
52083: LD_EXP 141
52087: PUSH
52088: LD_VAR 0 2
52092: ARRAY
52093: PUSH
52094: LD_INT 1
52096: ARRAY
52097: PPUSH
52098: CALL_OW 310
52102: NOT
52103: AND
52104: IFFALSE 52130
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52106: LD_EXP 141
52110: PUSH
52111: LD_VAR 0 2
52115: ARRAY
52116: PUSH
52117: LD_INT 1
52119: ARRAY
52120: PPUSH
52121: LD_VAR 0 3
52125: PPUSH
52126: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52130: LD_EXP 141
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PUSH
52141: LD_INT 1
52143: ARRAY
52144: PPUSH
52145: CALL_OW 310
52149: PUSH
52150: LD_EXP 141
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: PUSH
52161: LD_INT 1
52163: ARRAY
52164: PPUSH
52165: CALL_OW 310
52169: PPUSH
52170: CALL_OW 461
52174: PUSH
52175: LD_INT 3
52177: NONEQUAL
52178: AND
52179: IFFALSE 52200
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52181: LD_EXP 141
52185: PUSH
52186: LD_VAR 0 2
52190: ARRAY
52191: PUSH
52192: LD_INT 1
52194: ARRAY
52195: PPUSH
52196: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52200: LD_VAR 0 3
52204: PPUSH
52205: CALL_OW 461
52209: PUSH
52210: LD_INT 6
52212: EQUAL
52213: PUSH
52214: LD_VAR 0 6
52218: PUSH
52219: LD_INT 1
52221: GREATER
52222: AND
52223: IFFALSE 52375
// begin sci := [ ] ;
52225: LD_ADDR_VAR 0 8
52229: PUSH
52230: EMPTY
52231: ST_TO_ADDR
// for x in ( tmp diff j ) do
52232: LD_ADDR_VAR 0 7
52236: PUSH
52237: LD_VAR 0 6
52241: PUSH
52242: LD_VAR 0 3
52246: DIFF
52247: PUSH
52248: FOR_IN
52249: IFFALSE 52301
// begin if sci = 6 then
52251: LD_VAR 0 8
52255: PUSH
52256: LD_INT 6
52258: EQUAL
52259: IFFALSE 52263
// break ;
52261: GO 52301
// if BuildingStatus ( x ) = bs_idle then
52263: LD_VAR 0 7
52267: PPUSH
52268: CALL_OW 461
52272: PUSH
52273: LD_INT 2
52275: EQUAL
52276: IFFALSE 52299
// sci := sci ^ UnitsInside ( x ) ;
52278: LD_ADDR_VAR 0 8
52282: PUSH
52283: LD_VAR 0 8
52287: PUSH
52288: LD_VAR 0 7
52292: PPUSH
52293: CALL_OW 313
52297: ADD
52298: ST_TO_ADDR
// end ;
52299: GO 52248
52301: POP
52302: POP
// if not sci then
52303: LD_VAR 0 8
52307: NOT
52308: IFFALSE 52312
// continue ;
52310: GO 51357
// for x in sci do
52312: LD_ADDR_VAR 0 7
52316: PUSH
52317: LD_VAR 0 8
52321: PUSH
52322: FOR_IN
52323: IFFALSE 52373
// if IsInUnit ( x ) and not HasTask ( x ) then
52325: LD_VAR 0 7
52329: PPUSH
52330: CALL_OW 310
52334: PUSH
52335: LD_VAR 0 7
52339: PPUSH
52340: CALL_OW 314
52344: NOT
52345: AND
52346: IFFALSE 52371
// begin ComExitBuilding ( x ) ;
52348: LD_VAR 0 7
52352: PPUSH
52353: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52357: LD_VAR 0 7
52361: PPUSH
52362: LD_VAR 0 3
52366: PPUSH
52367: CALL_OW 180
// end ;
52371: GO 52322
52373: POP
52374: POP
// end ; end ;
52375: GO 51357
52377: POP
52378: POP
// end ;
52379: GO 51311
52381: POP
52382: POP
// end ;
52383: LD_VAR 0 1
52387: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52388: LD_INT 0
52390: PPUSH
52391: PPUSH
// if not mc_bases then
52392: LD_EXP 111
52396: NOT
52397: IFFALSE 52401
// exit ;
52399: GO 52482
// for i = 1 to mc_bases do
52401: LD_ADDR_VAR 0 2
52405: PUSH
52406: DOUBLE
52407: LD_INT 1
52409: DEC
52410: ST_TO_ADDR
52411: LD_EXP 111
52415: PUSH
52416: FOR_TO
52417: IFFALSE 52480
// if mc_mines [ i ] and mc_miners [ i ] then
52419: LD_EXP 124
52423: PUSH
52424: LD_VAR 0 2
52428: ARRAY
52429: PUSH
52430: LD_EXP 125
52434: PUSH
52435: LD_VAR 0 2
52439: ARRAY
52440: AND
52441: IFFALSE 52478
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52443: LD_EXP 125
52447: PUSH
52448: LD_VAR 0 2
52452: ARRAY
52453: PUSH
52454: LD_INT 1
52456: ARRAY
52457: PPUSH
52458: CALL_OW 255
52462: PPUSH
52463: LD_EXP 124
52467: PUSH
52468: LD_VAR 0 2
52472: ARRAY
52473: PPUSH
52474: CALL 67019 0 2
52478: GO 52416
52480: POP
52481: POP
// end ;
52482: LD_VAR 0 1
52486: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52487: LD_INT 0
52489: PPUSH
52490: PPUSH
52491: PPUSH
52492: PPUSH
52493: PPUSH
52494: PPUSH
52495: PPUSH
52496: PPUSH
// if not mc_bases or not mc_parking then
52497: LD_EXP 111
52501: NOT
52502: PUSH
52503: LD_EXP 135
52507: NOT
52508: OR
52509: IFFALSE 52513
// exit ;
52511: GO 53212
// for i = 1 to mc_bases do
52513: LD_ADDR_VAR 0 2
52517: PUSH
52518: DOUBLE
52519: LD_INT 1
52521: DEC
52522: ST_TO_ADDR
52523: LD_EXP 111
52527: PUSH
52528: FOR_TO
52529: IFFALSE 53210
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52531: LD_EXP 111
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: NOT
52542: PUSH
52543: LD_EXP 135
52547: PUSH
52548: LD_VAR 0 2
52552: ARRAY
52553: NOT
52554: OR
52555: IFFALSE 52559
// continue ;
52557: GO 52528
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52559: LD_ADDR_VAR 0 5
52563: PUSH
52564: LD_EXP 111
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PUSH
52575: LD_INT 1
52577: ARRAY
52578: PPUSH
52579: CALL_OW 255
52583: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52584: LD_ADDR_VAR 0 6
52588: PUSH
52589: LD_EXP 111
52593: PUSH
52594: LD_VAR 0 2
52598: ARRAY
52599: PPUSH
52600: LD_INT 30
52602: PUSH
52603: LD_INT 3
52605: PUSH
52606: EMPTY
52607: LIST
52608: LIST
52609: PPUSH
52610: CALL_OW 72
52614: ST_TO_ADDR
// if not fac then
52615: LD_VAR 0 6
52619: NOT
52620: IFFALSE 52671
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52622: LD_ADDR_VAR 0 6
52626: PUSH
52627: LD_EXP 111
52631: PUSH
52632: LD_VAR 0 2
52636: ARRAY
52637: PPUSH
52638: LD_INT 2
52640: PUSH
52641: LD_INT 30
52643: PUSH
52644: LD_INT 0
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: PUSH
52651: LD_INT 30
52653: PUSH
52654: LD_INT 1
52656: PUSH
52657: EMPTY
52658: LIST
52659: LIST
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: LIST
52665: PPUSH
52666: CALL_OW 72
52670: ST_TO_ADDR
// if not fac then
52671: LD_VAR 0 6
52675: NOT
52676: IFFALSE 52680
// continue ;
52678: GO 52528
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52680: LD_ADDR_VAR 0 7
52684: PUSH
52685: LD_EXP 135
52689: PUSH
52690: LD_VAR 0 2
52694: ARRAY
52695: PPUSH
52696: LD_INT 22
52698: PUSH
52699: LD_VAR 0 5
52703: PUSH
52704: EMPTY
52705: LIST
52706: LIST
52707: PUSH
52708: LD_INT 21
52710: PUSH
52711: LD_INT 2
52713: PUSH
52714: EMPTY
52715: LIST
52716: LIST
52717: PUSH
52718: LD_INT 3
52720: PUSH
52721: LD_INT 24
52723: PUSH
52724: LD_INT 1000
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: EMPTY
52732: LIST
52733: LIST
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: PPUSH
52740: CALL_OW 70
52744: ST_TO_ADDR
// for j in fac do
52745: LD_ADDR_VAR 0 3
52749: PUSH
52750: LD_VAR 0 6
52754: PUSH
52755: FOR_IN
52756: IFFALSE 52837
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52758: LD_ADDR_VAR 0 7
52762: PUSH
52763: LD_VAR 0 7
52767: PUSH
52768: LD_INT 22
52770: PUSH
52771: LD_VAR 0 5
52775: PUSH
52776: EMPTY
52777: LIST
52778: LIST
52779: PUSH
52780: LD_INT 91
52782: PUSH
52783: LD_VAR 0 3
52787: PUSH
52788: LD_INT 15
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: LIST
52795: PUSH
52796: LD_INT 21
52798: PUSH
52799: LD_INT 2
52801: PUSH
52802: EMPTY
52803: LIST
52804: LIST
52805: PUSH
52806: LD_INT 3
52808: PUSH
52809: LD_INT 24
52811: PUSH
52812: LD_INT 1000
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: LIST
52827: LIST
52828: PPUSH
52829: CALL_OW 69
52833: UNION
52834: ST_TO_ADDR
52835: GO 52755
52837: POP
52838: POP
// if not vehs then
52839: LD_VAR 0 7
52843: NOT
52844: IFFALSE 52870
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52846: LD_ADDR_EXP 123
52850: PUSH
52851: LD_EXP 123
52855: PPUSH
52856: LD_VAR 0 2
52860: PPUSH
52861: EMPTY
52862: PPUSH
52863: CALL_OW 1
52867: ST_TO_ADDR
// continue ;
52868: GO 52528
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52870: LD_ADDR_VAR 0 8
52874: PUSH
52875: LD_EXP 111
52879: PUSH
52880: LD_VAR 0 2
52884: ARRAY
52885: PPUSH
52886: LD_INT 30
52888: PUSH
52889: LD_INT 3
52891: PUSH
52892: EMPTY
52893: LIST
52894: LIST
52895: PPUSH
52896: CALL_OW 72
52900: ST_TO_ADDR
// if tmp then
52901: LD_VAR 0 8
52905: IFFALSE 53008
// begin for j in tmp do
52907: LD_ADDR_VAR 0 3
52911: PUSH
52912: LD_VAR 0 8
52916: PUSH
52917: FOR_IN
52918: IFFALSE 53006
// for k in UnitsInside ( j ) do
52920: LD_ADDR_VAR 0 4
52924: PUSH
52925: LD_VAR 0 3
52929: PPUSH
52930: CALL_OW 313
52934: PUSH
52935: FOR_IN
52936: IFFALSE 53002
// if k then
52938: LD_VAR 0 4
52942: IFFALSE 53000
// if not k in mc_repair_vehicle [ i ] then
52944: LD_VAR 0 4
52948: PUSH
52949: LD_EXP 123
52953: PUSH
52954: LD_VAR 0 2
52958: ARRAY
52959: IN
52960: NOT
52961: IFFALSE 53000
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52963: LD_ADDR_EXP 123
52967: PUSH
52968: LD_EXP 123
52972: PPUSH
52973: LD_VAR 0 2
52977: PPUSH
52978: LD_EXP 123
52982: PUSH
52983: LD_VAR 0 2
52987: ARRAY
52988: PUSH
52989: LD_VAR 0 4
52993: UNION
52994: PPUSH
52995: CALL_OW 1
52999: ST_TO_ADDR
53000: GO 52935
53002: POP
53003: POP
53004: GO 52917
53006: POP
53007: POP
// end ; if not mc_repair_vehicle [ i ] then
53008: LD_EXP 123
53012: PUSH
53013: LD_VAR 0 2
53017: ARRAY
53018: NOT
53019: IFFALSE 53023
// continue ;
53021: GO 52528
// for j in mc_repair_vehicle [ i ] do
53023: LD_ADDR_VAR 0 3
53027: PUSH
53028: LD_EXP 123
53032: PUSH
53033: LD_VAR 0 2
53037: ARRAY
53038: PUSH
53039: FOR_IN
53040: IFFALSE 53206
// begin if GetClass ( j ) <> 3 then
53042: LD_VAR 0 3
53046: PPUSH
53047: CALL_OW 257
53051: PUSH
53052: LD_INT 3
53054: NONEQUAL
53055: IFFALSE 53096
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53057: LD_ADDR_EXP 123
53061: PUSH
53062: LD_EXP 123
53066: PPUSH
53067: LD_VAR 0 2
53071: PPUSH
53072: LD_EXP 123
53076: PUSH
53077: LD_VAR 0 2
53081: ARRAY
53082: PUSH
53083: LD_VAR 0 3
53087: DIFF
53088: PPUSH
53089: CALL_OW 1
53093: ST_TO_ADDR
// continue ;
53094: GO 53039
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53096: LD_VAR 0 3
53100: PPUSH
53101: CALL_OW 311
53105: NOT
53106: PUSH
53107: LD_VAR 0 3
53111: PUSH
53112: LD_EXP 114
53116: PUSH
53117: LD_VAR 0 2
53121: ARRAY
53122: PUSH
53123: LD_INT 1
53125: ARRAY
53126: IN
53127: NOT
53128: AND
53129: PUSH
53130: LD_VAR 0 3
53134: PUSH
53135: LD_EXP 114
53139: PUSH
53140: LD_VAR 0 2
53144: ARRAY
53145: PUSH
53146: LD_INT 2
53148: ARRAY
53149: IN
53150: NOT
53151: AND
53152: IFFALSE 53204
// begin if IsInUnit ( j ) then
53154: LD_VAR 0 3
53158: PPUSH
53159: CALL_OW 310
53163: IFFALSE 53174
// ComExitBuilding ( j ) ;
53165: LD_VAR 0 3
53169: PPUSH
53170: CALL_OW 122
// if not HasTask ( j ) then
53174: LD_VAR 0 3
53178: PPUSH
53179: CALL_OW 314
53183: NOT
53184: IFFALSE 53204
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53186: LD_VAR 0 3
53190: PPUSH
53191: LD_VAR 0 7
53195: PUSH
53196: LD_INT 1
53198: ARRAY
53199: PPUSH
53200: CALL_OW 189
// end ; end ;
53204: GO 53039
53206: POP
53207: POP
// end ;
53208: GO 52528
53210: POP
53211: POP
// end ;
53212: LD_VAR 0 1
53216: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53217: LD_INT 0
53219: PPUSH
53220: PPUSH
53221: PPUSH
53222: PPUSH
53223: PPUSH
53224: PPUSH
53225: PPUSH
53226: PPUSH
53227: PPUSH
53228: PPUSH
53229: PPUSH
// if not mc_bases then
53230: LD_EXP 111
53234: NOT
53235: IFFALSE 53239
// exit ;
53237: GO 54041
// for i = 1 to mc_bases do
53239: LD_ADDR_VAR 0 2
53243: PUSH
53244: DOUBLE
53245: LD_INT 1
53247: DEC
53248: ST_TO_ADDR
53249: LD_EXP 111
53253: PUSH
53254: FOR_TO
53255: IFFALSE 54039
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53257: LD_EXP 139
53261: PUSH
53262: LD_VAR 0 2
53266: ARRAY
53267: NOT
53268: PUSH
53269: LD_EXP 114
53273: PUSH
53274: LD_VAR 0 2
53278: ARRAY
53279: PUSH
53280: LD_INT 1
53282: ARRAY
53283: OR
53284: PUSH
53285: LD_EXP 114
53289: PUSH
53290: LD_VAR 0 2
53294: ARRAY
53295: PUSH
53296: LD_INT 2
53298: ARRAY
53299: OR
53300: PUSH
53301: LD_EXP 137
53305: PUSH
53306: LD_VAR 0 2
53310: ARRAY
53311: PPUSH
53312: LD_INT 1
53314: PPUSH
53315: CALL_OW 325
53319: NOT
53320: OR
53321: PUSH
53322: LD_EXP 134
53326: PUSH
53327: LD_VAR 0 2
53331: ARRAY
53332: OR
53333: IFFALSE 53337
// continue ;
53335: GO 53254
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53337: LD_ADDR_VAR 0 8
53341: PUSH
53342: LD_EXP 111
53346: PUSH
53347: LD_VAR 0 2
53351: ARRAY
53352: PPUSH
53353: LD_INT 25
53355: PUSH
53356: LD_INT 4
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: PUSH
53363: LD_INT 50
53365: PUSH
53366: EMPTY
53367: LIST
53368: PUSH
53369: LD_INT 3
53371: PUSH
53372: LD_INT 60
53374: PUSH
53375: EMPTY
53376: LIST
53377: PUSH
53378: EMPTY
53379: LIST
53380: LIST
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: LIST
53386: PPUSH
53387: CALL_OW 72
53391: PUSH
53392: LD_EXP 115
53396: PUSH
53397: LD_VAR 0 2
53401: ARRAY
53402: DIFF
53403: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53404: LD_ADDR_VAR 0 9
53408: PUSH
53409: LD_EXP 111
53413: PUSH
53414: LD_VAR 0 2
53418: ARRAY
53419: PPUSH
53420: LD_INT 2
53422: PUSH
53423: LD_INT 30
53425: PUSH
53426: LD_INT 0
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: PUSH
53433: LD_INT 30
53435: PUSH
53436: LD_INT 1
53438: PUSH
53439: EMPTY
53440: LIST
53441: LIST
53442: PUSH
53443: EMPTY
53444: LIST
53445: LIST
53446: LIST
53447: PPUSH
53448: CALL_OW 72
53452: ST_TO_ADDR
// if not tmp or not dep then
53453: LD_VAR 0 8
53457: NOT
53458: PUSH
53459: LD_VAR 0 9
53463: NOT
53464: OR
53465: IFFALSE 53469
// continue ;
53467: GO 53254
// side := GetSide ( tmp [ 1 ] ) ;
53469: LD_ADDR_VAR 0 11
53473: PUSH
53474: LD_VAR 0 8
53478: PUSH
53479: LD_INT 1
53481: ARRAY
53482: PPUSH
53483: CALL_OW 255
53487: ST_TO_ADDR
// dep := dep [ 1 ] ;
53488: LD_ADDR_VAR 0 9
53492: PUSH
53493: LD_VAR 0 9
53497: PUSH
53498: LD_INT 1
53500: ARRAY
53501: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53502: LD_ADDR_VAR 0 7
53506: PUSH
53507: LD_EXP 139
53511: PUSH
53512: LD_VAR 0 2
53516: ARRAY
53517: PPUSH
53518: LD_INT 22
53520: PUSH
53521: LD_INT 0
53523: PUSH
53524: EMPTY
53525: LIST
53526: LIST
53527: PUSH
53528: LD_INT 25
53530: PUSH
53531: LD_INT 12
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: PPUSH
53542: CALL_OW 70
53546: PUSH
53547: LD_INT 22
53549: PUSH
53550: LD_INT 0
53552: PUSH
53553: EMPTY
53554: LIST
53555: LIST
53556: PUSH
53557: LD_INT 25
53559: PUSH
53560: LD_INT 12
53562: PUSH
53563: EMPTY
53564: LIST
53565: LIST
53566: PUSH
53567: LD_INT 91
53569: PUSH
53570: LD_VAR 0 9
53574: PUSH
53575: LD_INT 20
53577: PUSH
53578: EMPTY
53579: LIST
53580: LIST
53581: LIST
53582: PUSH
53583: EMPTY
53584: LIST
53585: LIST
53586: LIST
53587: PPUSH
53588: CALL_OW 69
53592: UNION
53593: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53594: LD_ADDR_VAR 0 10
53598: PUSH
53599: LD_EXP 139
53603: PUSH
53604: LD_VAR 0 2
53608: ARRAY
53609: PPUSH
53610: LD_INT 81
53612: PUSH
53613: LD_VAR 0 11
53617: PUSH
53618: EMPTY
53619: LIST
53620: LIST
53621: PPUSH
53622: CALL_OW 70
53626: ST_TO_ADDR
// if not apes or danger_at_area then
53627: LD_VAR 0 7
53631: NOT
53632: PUSH
53633: LD_VAR 0 10
53637: OR
53638: IFFALSE 53688
// begin if mc_taming [ i ] then
53640: LD_EXP 142
53644: PUSH
53645: LD_VAR 0 2
53649: ARRAY
53650: IFFALSE 53686
// begin MC_Reset ( i , 121 ) ;
53652: LD_VAR 0 2
53656: PPUSH
53657: LD_INT 121
53659: PPUSH
53660: CALL 39139 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53664: LD_ADDR_EXP 142
53668: PUSH
53669: LD_EXP 142
53673: PPUSH
53674: LD_VAR 0 2
53678: PPUSH
53679: EMPTY
53680: PPUSH
53681: CALL_OW 1
53685: ST_TO_ADDR
// end ; continue ;
53686: GO 53254
// end ; for j in tmp do
53688: LD_ADDR_VAR 0 3
53692: PUSH
53693: LD_VAR 0 8
53697: PUSH
53698: FOR_IN
53699: IFFALSE 54035
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53701: LD_VAR 0 3
53705: PUSH
53706: LD_EXP 142
53710: PUSH
53711: LD_VAR 0 2
53715: ARRAY
53716: IN
53717: NOT
53718: PUSH
53719: LD_EXP 142
53723: PUSH
53724: LD_VAR 0 2
53728: ARRAY
53729: PUSH
53730: LD_INT 3
53732: LESS
53733: AND
53734: IFFALSE 53792
// begin SetTag ( j , 121 ) ;
53736: LD_VAR 0 3
53740: PPUSH
53741: LD_INT 121
53743: PPUSH
53744: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53748: LD_ADDR_EXP 142
53752: PUSH
53753: LD_EXP 142
53757: PPUSH
53758: LD_VAR 0 2
53762: PUSH
53763: LD_EXP 142
53767: PUSH
53768: LD_VAR 0 2
53772: ARRAY
53773: PUSH
53774: LD_INT 1
53776: PLUS
53777: PUSH
53778: EMPTY
53779: LIST
53780: LIST
53781: PPUSH
53782: LD_VAR 0 3
53786: PPUSH
53787: CALL 70030 0 3
53791: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53792: LD_VAR 0 3
53796: PUSH
53797: LD_EXP 142
53801: PUSH
53802: LD_VAR 0 2
53806: ARRAY
53807: IN
53808: IFFALSE 54033
// begin if GetClass ( j ) <> 4 then
53810: LD_VAR 0 3
53814: PPUSH
53815: CALL_OW 257
53819: PUSH
53820: LD_INT 4
53822: NONEQUAL
53823: IFFALSE 53876
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53825: LD_ADDR_EXP 142
53829: PUSH
53830: LD_EXP 142
53834: PPUSH
53835: LD_VAR 0 2
53839: PPUSH
53840: LD_EXP 142
53844: PUSH
53845: LD_VAR 0 2
53849: ARRAY
53850: PUSH
53851: LD_VAR 0 3
53855: DIFF
53856: PPUSH
53857: CALL_OW 1
53861: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53862: LD_VAR 0 3
53866: PPUSH
53867: LD_INT 0
53869: PPUSH
53870: CALL_OW 109
// continue ;
53874: GO 53698
// end ; if IsInUnit ( j ) then
53876: LD_VAR 0 3
53880: PPUSH
53881: CALL_OW 310
53885: IFFALSE 53896
// ComExitBuilding ( j ) ;
53887: LD_VAR 0 3
53891: PPUSH
53892: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53896: LD_ADDR_VAR 0 6
53900: PUSH
53901: LD_VAR 0 7
53905: PPUSH
53906: LD_VAR 0 3
53910: PPUSH
53911: CALL_OW 74
53915: ST_TO_ADDR
// if not ape then
53916: LD_VAR 0 6
53920: NOT
53921: IFFALSE 53925
// break ;
53923: GO 54035
// x := GetX ( ape ) ;
53925: LD_ADDR_VAR 0 4
53929: PUSH
53930: LD_VAR 0 6
53934: PPUSH
53935: CALL_OW 250
53939: ST_TO_ADDR
// y := GetY ( ape ) ;
53940: LD_ADDR_VAR 0 5
53944: PUSH
53945: LD_VAR 0 6
53949: PPUSH
53950: CALL_OW 251
53954: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53955: LD_VAR 0 4
53959: PPUSH
53960: LD_VAR 0 5
53964: PPUSH
53965: CALL_OW 488
53969: NOT
53970: PUSH
53971: LD_VAR 0 11
53975: PPUSH
53976: LD_VAR 0 4
53980: PPUSH
53981: LD_VAR 0 5
53985: PPUSH
53986: LD_INT 20
53988: PPUSH
53989: CALL 70926 0 4
53993: PUSH
53994: LD_INT 4
53996: ARRAY
53997: OR
53998: IFFALSE 54002
// break ;
54000: GO 54035
// if not HasTask ( j ) then
54002: LD_VAR 0 3
54006: PPUSH
54007: CALL_OW 314
54011: NOT
54012: IFFALSE 54033
// ComTameXY ( j , x , y ) ;
54014: LD_VAR 0 3
54018: PPUSH
54019: LD_VAR 0 4
54023: PPUSH
54024: LD_VAR 0 5
54028: PPUSH
54029: CALL_OW 131
// end ; end ;
54033: GO 53698
54035: POP
54036: POP
// end ;
54037: GO 53254
54039: POP
54040: POP
// end ;
54041: LD_VAR 0 1
54045: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54046: LD_INT 0
54048: PPUSH
54049: PPUSH
54050: PPUSH
54051: PPUSH
54052: PPUSH
54053: PPUSH
54054: PPUSH
54055: PPUSH
// if not mc_bases then
54056: LD_EXP 111
54060: NOT
54061: IFFALSE 54065
// exit ;
54063: GO 54691
// for i = 1 to mc_bases do
54065: LD_ADDR_VAR 0 2
54069: PUSH
54070: DOUBLE
54071: LD_INT 1
54073: DEC
54074: ST_TO_ADDR
54075: LD_EXP 111
54079: PUSH
54080: FOR_TO
54081: IFFALSE 54689
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54083: LD_EXP 140
54087: PUSH
54088: LD_VAR 0 2
54092: ARRAY
54093: NOT
54094: PUSH
54095: LD_EXP 140
54099: PUSH
54100: LD_VAR 0 2
54104: ARRAY
54105: PPUSH
54106: LD_INT 25
54108: PUSH
54109: LD_INT 12
54111: PUSH
54112: EMPTY
54113: LIST
54114: LIST
54115: PPUSH
54116: CALL_OW 72
54120: NOT
54121: OR
54122: IFFALSE 54126
// continue ;
54124: GO 54080
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54126: LD_ADDR_VAR 0 5
54130: PUSH
54131: LD_EXP 140
54135: PUSH
54136: LD_VAR 0 2
54140: ARRAY
54141: PUSH
54142: LD_INT 1
54144: ARRAY
54145: PPUSH
54146: CALL_OW 255
54150: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54151: LD_VAR 0 5
54155: PPUSH
54156: LD_INT 2
54158: PPUSH
54159: CALL_OW 325
54163: IFFALSE 54416
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54165: LD_ADDR_VAR 0 4
54169: PUSH
54170: LD_EXP 140
54174: PUSH
54175: LD_VAR 0 2
54179: ARRAY
54180: PPUSH
54181: LD_INT 25
54183: PUSH
54184: LD_INT 16
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: PPUSH
54191: CALL_OW 72
54195: ST_TO_ADDR
// if tmp < 6 then
54196: LD_VAR 0 4
54200: PUSH
54201: LD_INT 6
54203: LESS
54204: IFFALSE 54416
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54206: LD_ADDR_VAR 0 6
54210: PUSH
54211: LD_EXP 111
54215: PUSH
54216: LD_VAR 0 2
54220: ARRAY
54221: PPUSH
54222: LD_INT 2
54224: PUSH
54225: LD_INT 30
54227: PUSH
54228: LD_INT 0
54230: PUSH
54231: EMPTY
54232: LIST
54233: LIST
54234: PUSH
54235: LD_INT 30
54237: PUSH
54238: LD_INT 1
54240: PUSH
54241: EMPTY
54242: LIST
54243: LIST
54244: PUSH
54245: EMPTY
54246: LIST
54247: LIST
54248: LIST
54249: PPUSH
54250: CALL_OW 72
54254: ST_TO_ADDR
// if depot then
54255: LD_VAR 0 6
54259: IFFALSE 54416
// begin selected := 0 ;
54261: LD_ADDR_VAR 0 7
54265: PUSH
54266: LD_INT 0
54268: ST_TO_ADDR
// for j in depot do
54269: LD_ADDR_VAR 0 3
54273: PUSH
54274: LD_VAR 0 6
54278: PUSH
54279: FOR_IN
54280: IFFALSE 54311
// begin if UnitsInside ( j ) < 6 then
54282: LD_VAR 0 3
54286: PPUSH
54287: CALL_OW 313
54291: PUSH
54292: LD_INT 6
54294: LESS
54295: IFFALSE 54309
// begin selected := j ;
54297: LD_ADDR_VAR 0 7
54301: PUSH
54302: LD_VAR 0 3
54306: ST_TO_ADDR
// break ;
54307: GO 54311
// end ; end ;
54309: GO 54279
54311: POP
54312: POP
// if selected then
54313: LD_VAR 0 7
54317: IFFALSE 54416
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54319: LD_ADDR_VAR 0 3
54323: PUSH
54324: LD_EXP 140
54328: PUSH
54329: LD_VAR 0 2
54333: ARRAY
54334: PPUSH
54335: LD_INT 25
54337: PUSH
54338: LD_INT 12
54340: PUSH
54341: EMPTY
54342: LIST
54343: LIST
54344: PPUSH
54345: CALL_OW 72
54349: PUSH
54350: FOR_IN
54351: IFFALSE 54414
// if not HasTask ( j ) then
54353: LD_VAR 0 3
54357: PPUSH
54358: CALL_OW 314
54362: NOT
54363: IFFALSE 54412
// begin if not IsInUnit ( j ) then
54365: LD_VAR 0 3
54369: PPUSH
54370: CALL_OW 310
54374: NOT
54375: IFFALSE 54391
// ComEnterUnit ( j , selected ) ;
54377: LD_VAR 0 3
54381: PPUSH
54382: LD_VAR 0 7
54386: PPUSH
54387: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54391: LD_VAR 0 3
54395: PPUSH
54396: LD_INT 16
54398: PPUSH
54399: CALL_OW 183
// AddComExitBuilding ( j ) ;
54403: LD_VAR 0 3
54407: PPUSH
54408: CALL_OW 182
// end ;
54412: GO 54350
54414: POP
54415: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54416: LD_VAR 0 5
54420: PPUSH
54421: LD_INT 11
54423: PPUSH
54424: CALL_OW 325
54428: IFFALSE 54687
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54430: LD_ADDR_VAR 0 4
54434: PUSH
54435: LD_EXP 140
54439: PUSH
54440: LD_VAR 0 2
54444: ARRAY
54445: PPUSH
54446: LD_INT 25
54448: PUSH
54449: LD_INT 16
54451: PUSH
54452: EMPTY
54453: LIST
54454: LIST
54455: PPUSH
54456: CALL_OW 72
54460: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54461: LD_VAR 0 4
54465: PUSH
54466: LD_INT 6
54468: GREATEREQUAL
54469: PUSH
54470: LD_VAR 0 5
54474: PPUSH
54475: LD_INT 2
54477: PPUSH
54478: CALL_OW 325
54482: NOT
54483: OR
54484: IFFALSE 54687
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54486: LD_ADDR_VAR 0 8
54490: PUSH
54491: LD_EXP 111
54495: PUSH
54496: LD_VAR 0 2
54500: ARRAY
54501: PPUSH
54502: LD_INT 2
54504: PUSH
54505: LD_INT 30
54507: PUSH
54508: LD_INT 4
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: PUSH
54515: LD_INT 30
54517: PUSH
54518: LD_INT 5
54520: PUSH
54521: EMPTY
54522: LIST
54523: LIST
54524: PUSH
54525: EMPTY
54526: LIST
54527: LIST
54528: LIST
54529: PPUSH
54530: CALL_OW 72
54534: ST_TO_ADDR
// if barracks then
54535: LD_VAR 0 8
54539: IFFALSE 54687
// begin selected := 0 ;
54541: LD_ADDR_VAR 0 7
54545: PUSH
54546: LD_INT 0
54548: ST_TO_ADDR
// for j in barracks do
54549: LD_ADDR_VAR 0 3
54553: PUSH
54554: LD_VAR 0 8
54558: PUSH
54559: FOR_IN
54560: IFFALSE 54591
// begin if UnitsInside ( j ) < 6 then
54562: LD_VAR 0 3
54566: PPUSH
54567: CALL_OW 313
54571: PUSH
54572: LD_INT 6
54574: LESS
54575: IFFALSE 54589
// begin selected := j ;
54577: LD_ADDR_VAR 0 7
54581: PUSH
54582: LD_VAR 0 3
54586: ST_TO_ADDR
// break ;
54587: GO 54591
// end ; end ;
54589: GO 54559
54591: POP
54592: POP
// if selected then
54593: LD_VAR 0 7
54597: IFFALSE 54687
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54599: LD_ADDR_VAR 0 3
54603: PUSH
54604: LD_EXP 140
54608: PUSH
54609: LD_VAR 0 2
54613: ARRAY
54614: PPUSH
54615: LD_INT 25
54617: PUSH
54618: LD_INT 12
54620: PUSH
54621: EMPTY
54622: LIST
54623: LIST
54624: PPUSH
54625: CALL_OW 72
54629: PUSH
54630: FOR_IN
54631: IFFALSE 54685
// if not IsInUnit ( j ) and not HasTask ( j ) then
54633: LD_VAR 0 3
54637: PPUSH
54638: CALL_OW 310
54642: NOT
54643: PUSH
54644: LD_VAR 0 3
54648: PPUSH
54649: CALL_OW 314
54653: NOT
54654: AND
54655: IFFALSE 54683
// begin ComEnterUnit ( j , selected ) ;
54657: LD_VAR 0 3
54661: PPUSH
54662: LD_VAR 0 7
54666: PPUSH
54667: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54671: LD_VAR 0 3
54675: PPUSH
54676: LD_INT 15
54678: PPUSH
54679: CALL_OW 183
// end ;
54683: GO 54630
54685: POP
54686: POP
// end ; end ; end ; end ; end ;
54687: GO 54080
54689: POP
54690: POP
// end ;
54691: LD_VAR 0 1
54695: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54696: LD_INT 0
54698: PPUSH
54699: PPUSH
54700: PPUSH
54701: PPUSH
// if not mc_bases then
54702: LD_EXP 111
54706: NOT
54707: IFFALSE 54711
// exit ;
54709: GO 54889
// for i = 1 to mc_bases do
54711: LD_ADDR_VAR 0 2
54715: PUSH
54716: DOUBLE
54717: LD_INT 1
54719: DEC
54720: ST_TO_ADDR
54721: LD_EXP 111
54725: PUSH
54726: FOR_TO
54727: IFFALSE 54887
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54729: LD_ADDR_VAR 0 4
54733: PUSH
54734: LD_EXP 111
54738: PUSH
54739: LD_VAR 0 2
54743: ARRAY
54744: PPUSH
54745: LD_INT 25
54747: PUSH
54748: LD_INT 9
54750: PUSH
54751: EMPTY
54752: LIST
54753: LIST
54754: PPUSH
54755: CALL_OW 72
54759: ST_TO_ADDR
// if not tmp then
54760: LD_VAR 0 4
54764: NOT
54765: IFFALSE 54769
// continue ;
54767: GO 54726
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54769: LD_EXP 137
54773: PUSH
54774: LD_VAR 0 2
54778: ARRAY
54779: PPUSH
54780: LD_INT 29
54782: PPUSH
54783: CALL_OW 325
54787: NOT
54788: PUSH
54789: LD_EXP 137
54793: PUSH
54794: LD_VAR 0 2
54798: ARRAY
54799: PPUSH
54800: LD_INT 28
54802: PPUSH
54803: CALL_OW 325
54807: NOT
54808: AND
54809: IFFALSE 54813
// continue ;
54811: GO 54726
// for j in tmp do
54813: LD_ADDR_VAR 0 3
54817: PUSH
54818: LD_VAR 0 4
54822: PUSH
54823: FOR_IN
54824: IFFALSE 54883
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54826: LD_VAR 0 3
54830: PUSH
54831: LD_EXP 114
54835: PUSH
54836: LD_VAR 0 2
54840: ARRAY
54841: PUSH
54842: LD_INT 1
54844: ARRAY
54845: IN
54846: NOT
54847: PUSH
54848: LD_VAR 0 3
54852: PUSH
54853: LD_EXP 114
54857: PUSH
54858: LD_VAR 0 2
54862: ARRAY
54863: PUSH
54864: LD_INT 2
54866: ARRAY
54867: IN
54868: NOT
54869: AND
54870: IFFALSE 54881
// ComSpaceTimeShoot ( j ) ;
54872: LD_VAR 0 3
54876: PPUSH
54877: CALL 66027 0 1
54881: GO 54823
54883: POP
54884: POP
// end ;
54885: GO 54726
54887: POP
54888: POP
// end ;
54889: LD_VAR 0 1
54893: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54894: LD_INT 0
54896: PPUSH
54897: PPUSH
54898: PPUSH
54899: PPUSH
54900: PPUSH
54901: PPUSH
54902: PPUSH
54903: PPUSH
54904: PPUSH
// if not mc_bases then
54905: LD_EXP 111
54909: NOT
54910: IFFALSE 54914
// exit ;
54912: GO 55536
// for i = 1 to mc_bases do
54914: LD_ADDR_VAR 0 2
54918: PUSH
54919: DOUBLE
54920: LD_INT 1
54922: DEC
54923: ST_TO_ADDR
54924: LD_EXP 111
54928: PUSH
54929: FOR_TO
54930: IFFALSE 55534
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54932: LD_EXP 146
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: NOT
54943: PUSH
54944: LD_INT 38
54946: PPUSH
54947: LD_EXP 137
54951: PUSH
54952: LD_VAR 0 2
54956: ARRAY
54957: PPUSH
54958: CALL_OW 321
54962: PUSH
54963: LD_INT 2
54965: NONEQUAL
54966: OR
54967: IFFALSE 54971
// continue ;
54969: GO 54929
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54971: LD_ADDR_VAR 0 8
54975: PUSH
54976: LD_EXP 111
54980: PUSH
54981: LD_VAR 0 2
54985: ARRAY
54986: PPUSH
54987: LD_INT 30
54989: PUSH
54990: LD_INT 34
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: PPUSH
54997: CALL_OW 72
55001: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55002: LD_ADDR_VAR 0 9
55006: PUSH
55007: LD_EXP 111
55011: PUSH
55012: LD_VAR 0 2
55016: ARRAY
55017: PPUSH
55018: LD_INT 25
55020: PUSH
55021: LD_INT 4
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: PPUSH
55028: CALL_OW 72
55032: PPUSH
55033: LD_INT 0
55035: PPUSH
55036: CALL 98591 0 2
55040: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55041: LD_VAR 0 9
55045: NOT
55046: PUSH
55047: LD_VAR 0 8
55051: NOT
55052: OR
55053: PUSH
55054: LD_EXP 111
55058: PUSH
55059: LD_VAR 0 2
55063: ARRAY
55064: PPUSH
55065: LD_INT 124
55067: PPUSH
55068: CALL 98591 0 2
55072: OR
55073: IFFALSE 55077
// continue ;
55075: GO 54929
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55077: LD_EXP 147
55081: PUSH
55082: LD_VAR 0 2
55086: ARRAY
55087: PUSH
55088: LD_EXP 146
55092: PUSH
55093: LD_VAR 0 2
55097: ARRAY
55098: LESS
55099: PUSH
55100: LD_EXP 147
55104: PUSH
55105: LD_VAR 0 2
55109: ARRAY
55110: PUSH
55111: LD_VAR 0 8
55115: LESS
55116: AND
55117: IFFALSE 55532
// begin tmp := sci [ 1 ] ;
55119: LD_ADDR_VAR 0 7
55123: PUSH
55124: LD_VAR 0 9
55128: PUSH
55129: LD_INT 1
55131: ARRAY
55132: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55133: LD_VAR 0 7
55137: PPUSH
55138: LD_INT 124
55140: PPUSH
55141: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55145: LD_ADDR_VAR 0 3
55149: PUSH
55150: DOUBLE
55151: LD_EXP 146
55155: PUSH
55156: LD_VAR 0 2
55160: ARRAY
55161: INC
55162: ST_TO_ADDR
55163: LD_EXP 146
55167: PUSH
55168: LD_VAR 0 2
55172: ARRAY
55173: PUSH
55174: FOR_DOWNTO
55175: IFFALSE 55518
// begin if IsInUnit ( tmp ) then
55177: LD_VAR 0 7
55181: PPUSH
55182: CALL_OW 310
55186: IFFALSE 55197
// ComExitBuilding ( tmp ) ;
55188: LD_VAR 0 7
55192: PPUSH
55193: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55197: LD_INT 35
55199: PPUSH
55200: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55204: LD_VAR 0 7
55208: PPUSH
55209: CALL_OW 310
55213: NOT
55214: PUSH
55215: LD_VAR 0 7
55219: PPUSH
55220: CALL_OW 314
55224: NOT
55225: AND
55226: IFFALSE 55197
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55228: LD_ADDR_VAR 0 6
55232: PUSH
55233: LD_VAR 0 7
55237: PPUSH
55238: CALL_OW 250
55242: PUSH
55243: LD_VAR 0 7
55247: PPUSH
55248: CALL_OW 251
55252: PUSH
55253: EMPTY
55254: LIST
55255: LIST
55256: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55257: LD_INT 35
55259: PPUSH
55260: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55264: LD_ADDR_VAR 0 4
55268: PUSH
55269: LD_EXP 146
55273: PUSH
55274: LD_VAR 0 2
55278: ARRAY
55279: PUSH
55280: LD_VAR 0 3
55284: ARRAY
55285: PUSH
55286: LD_INT 1
55288: ARRAY
55289: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55290: LD_ADDR_VAR 0 5
55294: PUSH
55295: LD_EXP 146
55299: PUSH
55300: LD_VAR 0 2
55304: ARRAY
55305: PUSH
55306: LD_VAR 0 3
55310: ARRAY
55311: PUSH
55312: LD_INT 2
55314: ARRAY
55315: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55316: LD_VAR 0 7
55320: PPUSH
55321: LD_INT 10
55323: PPUSH
55324: CALL 72623 0 2
55328: PUSH
55329: LD_INT 4
55331: ARRAY
55332: IFFALSE 55370
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55334: LD_VAR 0 7
55338: PPUSH
55339: LD_VAR 0 6
55343: PUSH
55344: LD_INT 1
55346: ARRAY
55347: PPUSH
55348: LD_VAR 0 6
55352: PUSH
55353: LD_INT 2
55355: ARRAY
55356: PPUSH
55357: CALL_OW 111
// wait ( 0 0$10 ) ;
55361: LD_INT 350
55363: PPUSH
55364: CALL_OW 67
// end else
55368: GO 55396
// begin ComMoveXY ( tmp , x , y ) ;
55370: LD_VAR 0 7
55374: PPUSH
55375: LD_VAR 0 4
55379: PPUSH
55380: LD_VAR 0 5
55384: PPUSH
55385: CALL_OW 111
// wait ( 0 0$3 ) ;
55389: LD_INT 105
55391: PPUSH
55392: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55396: LD_VAR 0 7
55400: PPUSH
55401: LD_VAR 0 4
55405: PPUSH
55406: LD_VAR 0 5
55410: PPUSH
55411: CALL_OW 307
55415: IFFALSE 55257
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55417: LD_VAR 0 7
55421: PPUSH
55422: LD_VAR 0 4
55426: PPUSH
55427: LD_VAR 0 5
55431: PPUSH
55432: LD_VAR 0 8
55436: PUSH
55437: LD_VAR 0 3
55441: ARRAY
55442: PPUSH
55443: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55447: LD_INT 35
55449: PPUSH
55450: CALL_OW 67
// until not HasTask ( tmp ) ;
55454: LD_VAR 0 7
55458: PPUSH
55459: CALL_OW 314
55463: NOT
55464: IFFALSE 55447
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55466: LD_ADDR_EXP 147
55470: PUSH
55471: LD_EXP 147
55475: PPUSH
55476: LD_VAR 0 2
55480: PUSH
55481: LD_EXP 147
55485: PUSH
55486: LD_VAR 0 2
55490: ARRAY
55491: PUSH
55492: LD_INT 1
55494: PLUS
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PPUSH
55500: LD_VAR 0 8
55504: PUSH
55505: LD_VAR 0 3
55509: ARRAY
55510: PPUSH
55511: CALL 70030 0 3
55515: ST_TO_ADDR
// end ;
55516: GO 55174
55518: POP
55519: POP
// MC_Reset ( i , 124 ) ;
55520: LD_VAR 0 2
55524: PPUSH
55525: LD_INT 124
55527: PPUSH
55528: CALL 39139 0 2
// end ; end ;
55532: GO 54929
55534: POP
55535: POP
// end ;
55536: LD_VAR 0 1
55540: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55541: LD_INT 0
55543: PPUSH
55544: PPUSH
55545: PPUSH
// if not mc_bases then
55546: LD_EXP 111
55550: NOT
55551: IFFALSE 55555
// exit ;
55553: GO 56161
// for i = 1 to mc_bases do
55555: LD_ADDR_VAR 0 2
55559: PUSH
55560: DOUBLE
55561: LD_INT 1
55563: DEC
55564: ST_TO_ADDR
55565: LD_EXP 111
55569: PUSH
55570: FOR_TO
55571: IFFALSE 56159
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55573: LD_ADDR_VAR 0 3
55577: PUSH
55578: LD_EXP 111
55582: PUSH
55583: LD_VAR 0 2
55587: ARRAY
55588: PPUSH
55589: LD_INT 25
55591: PUSH
55592: LD_INT 4
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PPUSH
55599: CALL_OW 72
55603: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55604: LD_VAR 0 3
55608: NOT
55609: PUSH
55610: LD_EXP 148
55614: PUSH
55615: LD_VAR 0 2
55619: ARRAY
55620: NOT
55621: OR
55622: PUSH
55623: LD_EXP 111
55627: PUSH
55628: LD_VAR 0 2
55632: ARRAY
55633: PPUSH
55634: LD_INT 2
55636: PUSH
55637: LD_INT 30
55639: PUSH
55640: LD_INT 0
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: PUSH
55647: LD_INT 30
55649: PUSH
55650: LD_INT 1
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: LIST
55661: PPUSH
55662: CALL_OW 72
55666: NOT
55667: OR
55668: IFFALSE 55718
// begin if mc_deposits_finder [ i ] then
55670: LD_EXP 149
55674: PUSH
55675: LD_VAR 0 2
55679: ARRAY
55680: IFFALSE 55716
// begin MC_Reset ( i , 125 ) ;
55682: LD_VAR 0 2
55686: PPUSH
55687: LD_INT 125
55689: PPUSH
55690: CALL 39139 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55694: LD_ADDR_EXP 149
55698: PUSH
55699: LD_EXP 149
55703: PPUSH
55704: LD_VAR 0 2
55708: PPUSH
55709: EMPTY
55710: PPUSH
55711: CALL_OW 1
55715: ST_TO_ADDR
// end ; continue ;
55716: GO 55570
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55718: LD_EXP 148
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: ARRAY
55732: PUSH
55733: LD_INT 3
55735: ARRAY
55736: PUSH
55737: LD_INT 1
55739: EQUAL
55740: PUSH
55741: LD_INT 20
55743: PPUSH
55744: LD_EXP 137
55748: PUSH
55749: LD_VAR 0 2
55753: ARRAY
55754: PPUSH
55755: CALL_OW 321
55759: PUSH
55760: LD_INT 2
55762: NONEQUAL
55763: AND
55764: IFFALSE 55814
// begin if mc_deposits_finder [ i ] then
55766: LD_EXP 149
55770: PUSH
55771: LD_VAR 0 2
55775: ARRAY
55776: IFFALSE 55812
// begin MC_Reset ( i , 125 ) ;
55778: LD_VAR 0 2
55782: PPUSH
55783: LD_INT 125
55785: PPUSH
55786: CALL 39139 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55790: LD_ADDR_EXP 149
55794: PUSH
55795: LD_EXP 149
55799: PPUSH
55800: LD_VAR 0 2
55804: PPUSH
55805: EMPTY
55806: PPUSH
55807: CALL_OW 1
55811: ST_TO_ADDR
// end ; continue ;
55812: GO 55570
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55814: LD_EXP 148
55818: PUSH
55819: LD_VAR 0 2
55823: ARRAY
55824: PUSH
55825: LD_INT 1
55827: ARRAY
55828: PUSH
55829: LD_INT 1
55831: ARRAY
55832: PPUSH
55833: LD_EXP 148
55837: PUSH
55838: LD_VAR 0 2
55842: ARRAY
55843: PUSH
55844: LD_INT 1
55846: ARRAY
55847: PUSH
55848: LD_INT 2
55850: ARRAY
55851: PPUSH
55852: LD_EXP 137
55856: PUSH
55857: LD_VAR 0 2
55861: ARRAY
55862: PPUSH
55863: CALL_OW 440
55867: IFFALSE 55910
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55869: LD_ADDR_EXP 148
55873: PUSH
55874: LD_EXP 148
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: LD_EXP 148
55888: PUSH
55889: LD_VAR 0 2
55893: ARRAY
55894: PPUSH
55895: LD_INT 1
55897: PPUSH
55898: CALL_OW 3
55902: PPUSH
55903: CALL_OW 1
55907: ST_TO_ADDR
55908: GO 56157
// begin if not mc_deposits_finder [ i ] then
55910: LD_EXP 149
55914: PUSH
55915: LD_VAR 0 2
55919: ARRAY
55920: NOT
55921: IFFALSE 55973
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55923: LD_ADDR_EXP 149
55927: PUSH
55928: LD_EXP 149
55932: PPUSH
55933: LD_VAR 0 2
55937: PPUSH
55938: LD_VAR 0 3
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: PUSH
55947: EMPTY
55948: LIST
55949: PPUSH
55950: CALL_OW 1
55954: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55955: LD_VAR 0 3
55959: PUSH
55960: LD_INT 1
55962: ARRAY
55963: PPUSH
55964: LD_INT 125
55966: PPUSH
55967: CALL_OW 109
// end else
55971: GO 56157
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55973: LD_EXP 149
55977: PUSH
55978: LD_VAR 0 2
55982: ARRAY
55983: PUSH
55984: LD_INT 1
55986: ARRAY
55987: PPUSH
55988: CALL_OW 310
55992: IFFALSE 56015
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55994: LD_EXP 149
55998: PUSH
55999: LD_VAR 0 2
56003: ARRAY
56004: PUSH
56005: LD_INT 1
56007: ARRAY
56008: PPUSH
56009: CALL_OW 122
56013: GO 56157
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56015: LD_EXP 149
56019: PUSH
56020: LD_VAR 0 2
56024: ARRAY
56025: PUSH
56026: LD_INT 1
56028: ARRAY
56029: PPUSH
56030: CALL_OW 314
56034: NOT
56035: PUSH
56036: LD_EXP 149
56040: PUSH
56041: LD_VAR 0 2
56045: ARRAY
56046: PUSH
56047: LD_INT 1
56049: ARRAY
56050: PPUSH
56051: LD_EXP 148
56055: PUSH
56056: LD_VAR 0 2
56060: ARRAY
56061: PUSH
56062: LD_INT 1
56064: ARRAY
56065: PUSH
56066: LD_INT 1
56068: ARRAY
56069: PPUSH
56070: LD_EXP 148
56074: PUSH
56075: LD_VAR 0 2
56079: ARRAY
56080: PUSH
56081: LD_INT 1
56083: ARRAY
56084: PUSH
56085: LD_INT 2
56087: ARRAY
56088: PPUSH
56089: CALL_OW 297
56093: PUSH
56094: LD_INT 6
56096: GREATER
56097: AND
56098: IFFALSE 56157
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56100: LD_EXP 149
56104: PUSH
56105: LD_VAR 0 2
56109: ARRAY
56110: PUSH
56111: LD_INT 1
56113: ARRAY
56114: PPUSH
56115: LD_EXP 148
56119: PUSH
56120: LD_VAR 0 2
56124: ARRAY
56125: PUSH
56126: LD_INT 1
56128: ARRAY
56129: PUSH
56130: LD_INT 1
56132: ARRAY
56133: PPUSH
56134: LD_EXP 148
56138: PUSH
56139: LD_VAR 0 2
56143: ARRAY
56144: PUSH
56145: LD_INT 1
56147: ARRAY
56148: PUSH
56149: LD_INT 2
56151: ARRAY
56152: PPUSH
56153: CALL_OW 111
// end ; end ; end ;
56157: GO 55570
56159: POP
56160: POP
// end ;
56161: LD_VAR 0 1
56165: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56166: LD_INT 0
56168: PPUSH
56169: PPUSH
56170: PPUSH
56171: PPUSH
56172: PPUSH
56173: PPUSH
56174: PPUSH
56175: PPUSH
56176: PPUSH
56177: PPUSH
56178: PPUSH
// if not mc_bases then
56179: LD_EXP 111
56183: NOT
56184: IFFALSE 56188
// exit ;
56186: GO 57128
// for i = 1 to mc_bases do
56188: LD_ADDR_VAR 0 2
56192: PUSH
56193: DOUBLE
56194: LD_INT 1
56196: DEC
56197: ST_TO_ADDR
56198: LD_EXP 111
56202: PUSH
56203: FOR_TO
56204: IFFALSE 57126
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56206: LD_EXP 111
56210: PUSH
56211: LD_VAR 0 2
56215: ARRAY
56216: NOT
56217: PUSH
56218: LD_EXP 134
56222: PUSH
56223: LD_VAR 0 2
56227: ARRAY
56228: OR
56229: IFFALSE 56233
// continue ;
56231: GO 56203
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56233: LD_ADDR_VAR 0 7
56237: PUSH
56238: LD_EXP 111
56242: PUSH
56243: LD_VAR 0 2
56247: ARRAY
56248: PUSH
56249: LD_INT 1
56251: ARRAY
56252: PPUSH
56253: CALL_OW 248
56257: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56258: LD_VAR 0 7
56262: PUSH
56263: LD_INT 3
56265: EQUAL
56266: PUSH
56267: LD_EXP 130
56271: PUSH
56272: LD_VAR 0 2
56276: ARRAY
56277: PUSH
56278: LD_EXP 133
56282: PUSH
56283: LD_VAR 0 2
56287: ARRAY
56288: UNION
56289: PPUSH
56290: LD_INT 33
56292: PUSH
56293: LD_INT 2
56295: PUSH
56296: EMPTY
56297: LIST
56298: LIST
56299: PPUSH
56300: CALL_OW 72
56304: NOT
56305: OR
56306: IFFALSE 56310
// continue ;
56308: GO 56203
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56310: LD_ADDR_VAR 0 9
56314: PUSH
56315: LD_EXP 111
56319: PUSH
56320: LD_VAR 0 2
56324: ARRAY
56325: PPUSH
56326: LD_INT 30
56328: PUSH
56329: LD_INT 36
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: PPUSH
56336: CALL_OW 72
56340: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56341: LD_ADDR_VAR 0 10
56345: PUSH
56346: LD_EXP 130
56350: PUSH
56351: LD_VAR 0 2
56355: ARRAY
56356: PPUSH
56357: LD_INT 34
56359: PUSH
56360: LD_INT 31
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: PPUSH
56367: CALL_OW 72
56371: ST_TO_ADDR
// if not cts and not mcts then
56372: LD_VAR 0 9
56376: NOT
56377: PUSH
56378: LD_VAR 0 10
56382: NOT
56383: AND
56384: IFFALSE 56388
// continue ;
56386: GO 56203
// x := cts ;
56388: LD_ADDR_VAR 0 11
56392: PUSH
56393: LD_VAR 0 9
56397: ST_TO_ADDR
// if not x then
56398: LD_VAR 0 11
56402: NOT
56403: IFFALSE 56415
// x := mcts ;
56405: LD_ADDR_VAR 0 11
56409: PUSH
56410: LD_VAR 0 10
56414: ST_TO_ADDR
// if not x then
56415: LD_VAR 0 11
56419: NOT
56420: IFFALSE 56424
// continue ;
56422: GO 56203
// if mc_remote_driver [ i ] then
56424: LD_EXP 151
56428: PUSH
56429: LD_VAR 0 2
56433: ARRAY
56434: IFFALSE 56821
// for j in mc_remote_driver [ i ] do
56436: LD_ADDR_VAR 0 3
56440: PUSH
56441: LD_EXP 151
56445: PUSH
56446: LD_VAR 0 2
56450: ARRAY
56451: PUSH
56452: FOR_IN
56453: IFFALSE 56819
// begin if GetClass ( j ) <> 3 then
56455: LD_VAR 0 3
56459: PPUSH
56460: CALL_OW 257
56464: PUSH
56465: LD_INT 3
56467: NONEQUAL
56468: IFFALSE 56521
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56470: LD_ADDR_EXP 151
56474: PUSH
56475: LD_EXP 151
56479: PPUSH
56480: LD_VAR 0 2
56484: PPUSH
56485: LD_EXP 151
56489: PUSH
56490: LD_VAR 0 2
56494: ARRAY
56495: PUSH
56496: LD_VAR 0 3
56500: DIFF
56501: PPUSH
56502: CALL_OW 1
56506: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56507: LD_VAR 0 3
56511: PPUSH
56512: LD_INT 0
56514: PPUSH
56515: CALL_OW 109
// continue ;
56519: GO 56452
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56521: LD_EXP 130
56525: PUSH
56526: LD_VAR 0 2
56530: ARRAY
56531: PPUSH
56532: LD_INT 34
56534: PUSH
56535: LD_INT 31
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: LD_INT 58
56544: PUSH
56545: EMPTY
56546: LIST
56547: PUSH
56548: EMPTY
56549: LIST
56550: LIST
56551: PPUSH
56552: CALL_OW 72
56556: PUSH
56557: LD_VAR 0 3
56561: PPUSH
56562: CALL 98679 0 1
56566: NOT
56567: AND
56568: IFFALSE 56639
// begin if IsInUnit ( j ) then
56570: LD_VAR 0 3
56574: PPUSH
56575: CALL_OW 310
56579: IFFALSE 56590
// ComExitBuilding ( j ) ;
56581: LD_VAR 0 3
56585: PPUSH
56586: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56590: LD_VAR 0 3
56594: PPUSH
56595: LD_EXP 130
56599: PUSH
56600: LD_VAR 0 2
56604: ARRAY
56605: PPUSH
56606: LD_INT 34
56608: PUSH
56609: LD_INT 31
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: PUSH
56616: LD_INT 58
56618: PUSH
56619: EMPTY
56620: LIST
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: PPUSH
56626: CALL_OW 72
56630: PUSH
56631: LD_INT 1
56633: ARRAY
56634: PPUSH
56635: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56639: LD_VAR 0 3
56643: PPUSH
56644: CALL_OW 310
56648: NOT
56649: PUSH
56650: LD_VAR 0 3
56654: PPUSH
56655: CALL_OW 310
56659: PPUSH
56660: CALL_OW 266
56664: PUSH
56665: LD_INT 36
56667: NONEQUAL
56668: PUSH
56669: LD_VAR 0 3
56673: PPUSH
56674: CALL 98679 0 1
56678: NOT
56679: AND
56680: OR
56681: IFFALSE 56817
// begin if IsInUnit ( j ) then
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 310
56692: IFFALSE 56703
// ComExitBuilding ( j ) ;
56694: LD_VAR 0 3
56698: PPUSH
56699: CALL_OW 122
// ct := 0 ;
56703: LD_ADDR_VAR 0 8
56707: PUSH
56708: LD_INT 0
56710: ST_TO_ADDR
// for k in x do
56711: LD_ADDR_VAR 0 4
56715: PUSH
56716: LD_VAR 0 11
56720: PUSH
56721: FOR_IN
56722: IFFALSE 56795
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56724: LD_VAR 0 4
56728: PPUSH
56729: CALL_OW 264
56733: PUSH
56734: LD_INT 31
56736: EQUAL
56737: PUSH
56738: LD_VAR 0 4
56742: PPUSH
56743: CALL_OW 311
56747: NOT
56748: AND
56749: PUSH
56750: LD_VAR 0 4
56754: PPUSH
56755: CALL_OW 266
56759: PUSH
56760: LD_INT 36
56762: EQUAL
56763: PUSH
56764: LD_VAR 0 4
56768: PPUSH
56769: CALL_OW 313
56773: PUSH
56774: LD_INT 3
56776: LESS
56777: AND
56778: OR
56779: IFFALSE 56793
// begin ct := k ;
56781: LD_ADDR_VAR 0 8
56785: PUSH
56786: LD_VAR 0 4
56790: ST_TO_ADDR
// break ;
56791: GO 56795
// end ;
56793: GO 56721
56795: POP
56796: POP
// if ct then
56797: LD_VAR 0 8
56801: IFFALSE 56817
// ComEnterUnit ( j , ct ) ;
56803: LD_VAR 0 3
56807: PPUSH
56808: LD_VAR 0 8
56812: PPUSH
56813: CALL_OW 120
// end ; end ;
56817: GO 56452
56819: POP
56820: POP
// places := 0 ;
56821: LD_ADDR_VAR 0 5
56825: PUSH
56826: LD_INT 0
56828: ST_TO_ADDR
// for j = 1 to x do
56829: LD_ADDR_VAR 0 3
56833: PUSH
56834: DOUBLE
56835: LD_INT 1
56837: DEC
56838: ST_TO_ADDR
56839: LD_VAR 0 11
56843: PUSH
56844: FOR_TO
56845: IFFALSE 56921
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56847: LD_VAR 0 11
56851: PUSH
56852: LD_VAR 0 3
56856: ARRAY
56857: PPUSH
56858: CALL_OW 264
56862: PUSH
56863: LD_INT 31
56865: EQUAL
56866: IFFALSE 56884
// places := places + 1 else
56868: LD_ADDR_VAR 0 5
56872: PUSH
56873: LD_VAR 0 5
56877: PUSH
56878: LD_INT 1
56880: PLUS
56881: ST_TO_ADDR
56882: GO 56919
// if GetBType ( x [ j ] ) = b_control_tower then
56884: LD_VAR 0 11
56888: PUSH
56889: LD_VAR 0 3
56893: ARRAY
56894: PPUSH
56895: CALL_OW 266
56899: PUSH
56900: LD_INT 36
56902: EQUAL
56903: IFFALSE 56919
// places := places + 3 ;
56905: LD_ADDR_VAR 0 5
56909: PUSH
56910: LD_VAR 0 5
56914: PUSH
56915: LD_INT 3
56917: PLUS
56918: ST_TO_ADDR
56919: GO 56844
56921: POP
56922: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56923: LD_VAR 0 5
56927: PUSH
56928: LD_INT 0
56930: EQUAL
56931: PUSH
56932: LD_VAR 0 5
56936: PUSH
56937: LD_EXP 151
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: LESSEQUAL
56948: OR
56949: IFFALSE 56953
// continue ;
56951: GO 56203
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56953: LD_ADDR_VAR 0 6
56957: PUSH
56958: LD_EXP 111
56962: PUSH
56963: LD_VAR 0 2
56967: ARRAY
56968: PPUSH
56969: LD_INT 25
56971: PUSH
56972: LD_INT 3
56974: PUSH
56975: EMPTY
56976: LIST
56977: LIST
56978: PPUSH
56979: CALL_OW 72
56983: PUSH
56984: LD_EXP 151
56988: PUSH
56989: LD_VAR 0 2
56993: ARRAY
56994: DIFF
56995: PPUSH
56996: LD_INT 3
56998: PPUSH
56999: CALL 99579 0 2
57003: ST_TO_ADDR
// for j in tmp do
57004: LD_ADDR_VAR 0 3
57008: PUSH
57009: LD_VAR 0 6
57013: PUSH
57014: FOR_IN
57015: IFFALSE 57050
// if GetTag ( j ) > 0 then
57017: LD_VAR 0 3
57021: PPUSH
57022: CALL_OW 110
57026: PUSH
57027: LD_INT 0
57029: GREATER
57030: IFFALSE 57048
// tmp := tmp diff j ;
57032: LD_ADDR_VAR 0 6
57036: PUSH
57037: LD_VAR 0 6
57041: PUSH
57042: LD_VAR 0 3
57046: DIFF
57047: ST_TO_ADDR
57048: GO 57014
57050: POP
57051: POP
// if not tmp then
57052: LD_VAR 0 6
57056: NOT
57057: IFFALSE 57061
// continue ;
57059: GO 56203
// if places then
57061: LD_VAR 0 5
57065: IFFALSE 57124
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57067: LD_ADDR_EXP 151
57071: PUSH
57072: LD_EXP 151
57076: PPUSH
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_EXP 151
57086: PUSH
57087: LD_VAR 0 2
57091: ARRAY
57092: PUSH
57093: LD_VAR 0 6
57097: PUSH
57098: LD_INT 1
57100: ARRAY
57101: UNION
57102: PPUSH
57103: CALL_OW 1
57107: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57108: LD_VAR 0 6
57112: PUSH
57113: LD_INT 1
57115: ARRAY
57116: PPUSH
57117: LD_INT 126
57119: PPUSH
57120: CALL_OW 109
// end ; end ;
57124: GO 56203
57126: POP
57127: POP
// end ;
57128: LD_VAR 0 1
57132: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57133: LD_INT 0
57135: PPUSH
57136: PPUSH
57137: PPUSH
57138: PPUSH
57139: PPUSH
57140: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57141: LD_VAR 0 1
57145: NOT
57146: PUSH
57147: LD_VAR 0 2
57151: NOT
57152: OR
57153: PUSH
57154: LD_VAR 0 3
57158: NOT
57159: OR
57160: PUSH
57161: LD_VAR 0 4
57165: PUSH
57166: LD_INT 1
57168: PUSH
57169: LD_INT 2
57171: PUSH
57172: LD_INT 3
57174: PUSH
57175: LD_INT 4
57177: PUSH
57178: LD_INT 5
57180: PUSH
57181: LD_INT 8
57183: PUSH
57184: LD_INT 9
57186: PUSH
57187: LD_INT 15
57189: PUSH
57190: LD_INT 16
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: LIST
57197: LIST
57198: LIST
57199: LIST
57200: LIST
57201: LIST
57202: LIST
57203: IN
57204: NOT
57205: OR
57206: IFFALSE 57210
// exit ;
57208: GO 58110
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57210: LD_ADDR_VAR 0 2
57214: PUSH
57215: LD_VAR 0 2
57219: PPUSH
57220: LD_INT 21
57222: PUSH
57223: LD_INT 3
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: PUSH
57230: LD_INT 24
57232: PUSH
57233: LD_INT 250
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PPUSH
57244: CALL_OW 72
57248: ST_TO_ADDR
// case class of 1 , 15 :
57249: LD_VAR 0 4
57253: PUSH
57254: LD_INT 1
57256: DOUBLE
57257: EQUAL
57258: IFTRUE 57268
57260: LD_INT 15
57262: DOUBLE
57263: EQUAL
57264: IFTRUE 57268
57266: GO 57353
57268: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57269: LD_ADDR_VAR 0 8
57273: PUSH
57274: LD_VAR 0 2
57278: PPUSH
57279: LD_INT 2
57281: PUSH
57282: LD_INT 30
57284: PUSH
57285: LD_INT 32
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: PUSH
57292: LD_INT 30
57294: PUSH
57295: LD_INT 31
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: PUSH
57302: EMPTY
57303: LIST
57304: LIST
57305: LIST
57306: PPUSH
57307: CALL_OW 72
57311: PUSH
57312: LD_VAR 0 2
57316: PPUSH
57317: LD_INT 2
57319: PUSH
57320: LD_INT 30
57322: PUSH
57323: LD_INT 4
57325: PUSH
57326: EMPTY
57327: LIST
57328: LIST
57329: PUSH
57330: LD_INT 30
57332: PUSH
57333: LD_INT 5
57335: PUSH
57336: EMPTY
57337: LIST
57338: LIST
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: LIST
57344: PPUSH
57345: CALL_OW 72
57349: ADD
57350: ST_TO_ADDR
57351: GO 57599
57353: LD_INT 2
57355: DOUBLE
57356: EQUAL
57357: IFTRUE 57367
57359: LD_INT 16
57361: DOUBLE
57362: EQUAL
57363: IFTRUE 57367
57365: GO 57413
57367: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57368: LD_ADDR_VAR 0 8
57372: PUSH
57373: LD_VAR 0 2
57377: PPUSH
57378: LD_INT 2
57380: PUSH
57381: LD_INT 30
57383: PUSH
57384: LD_INT 0
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PUSH
57391: LD_INT 30
57393: PUSH
57394: LD_INT 1
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: LIST
57405: PPUSH
57406: CALL_OW 72
57410: ST_TO_ADDR
57411: GO 57599
57413: LD_INT 3
57415: DOUBLE
57416: EQUAL
57417: IFTRUE 57421
57419: GO 57467
57421: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57422: LD_ADDR_VAR 0 8
57426: PUSH
57427: LD_VAR 0 2
57431: PPUSH
57432: LD_INT 2
57434: PUSH
57435: LD_INT 30
57437: PUSH
57438: LD_INT 2
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: PUSH
57445: LD_INT 30
57447: PUSH
57448: LD_INT 3
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: PUSH
57455: EMPTY
57456: LIST
57457: LIST
57458: LIST
57459: PPUSH
57460: CALL_OW 72
57464: ST_TO_ADDR
57465: GO 57599
57467: LD_INT 4
57469: DOUBLE
57470: EQUAL
57471: IFTRUE 57475
57473: GO 57532
57475: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57476: LD_ADDR_VAR 0 8
57480: PUSH
57481: LD_VAR 0 2
57485: PPUSH
57486: LD_INT 2
57488: PUSH
57489: LD_INT 30
57491: PUSH
57492: LD_INT 6
57494: PUSH
57495: EMPTY
57496: LIST
57497: LIST
57498: PUSH
57499: LD_INT 30
57501: PUSH
57502: LD_INT 7
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: PUSH
57509: LD_INT 30
57511: PUSH
57512: LD_INT 8
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: PUSH
57519: EMPTY
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: PPUSH
57525: CALL_OW 72
57529: ST_TO_ADDR
57530: GO 57599
57532: LD_INT 5
57534: DOUBLE
57535: EQUAL
57536: IFTRUE 57552
57538: LD_INT 8
57540: DOUBLE
57541: EQUAL
57542: IFTRUE 57552
57544: LD_INT 9
57546: DOUBLE
57547: EQUAL
57548: IFTRUE 57552
57550: GO 57598
57552: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57553: LD_ADDR_VAR 0 8
57557: PUSH
57558: LD_VAR 0 2
57562: PPUSH
57563: LD_INT 2
57565: PUSH
57566: LD_INT 30
57568: PUSH
57569: LD_INT 4
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: PUSH
57576: LD_INT 30
57578: PUSH
57579: LD_INT 5
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: PUSH
57586: EMPTY
57587: LIST
57588: LIST
57589: LIST
57590: PPUSH
57591: CALL_OW 72
57595: ST_TO_ADDR
57596: GO 57599
57598: POP
// if not tmp then
57599: LD_VAR 0 8
57603: NOT
57604: IFFALSE 57608
// exit ;
57606: GO 58110
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57608: LD_VAR 0 4
57612: PUSH
57613: LD_INT 1
57615: PUSH
57616: LD_INT 15
57618: PUSH
57619: EMPTY
57620: LIST
57621: LIST
57622: IN
57623: PUSH
57624: LD_EXP 120
57628: PUSH
57629: LD_VAR 0 1
57633: ARRAY
57634: AND
57635: IFFALSE 57791
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57637: LD_ADDR_VAR 0 9
57641: PUSH
57642: LD_EXP 120
57646: PUSH
57647: LD_VAR 0 1
57651: ARRAY
57652: PUSH
57653: LD_INT 1
57655: ARRAY
57656: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57657: LD_VAR 0 9
57661: PUSH
57662: LD_EXP 121
57666: PUSH
57667: LD_VAR 0 1
57671: ARRAY
57672: IN
57673: NOT
57674: IFFALSE 57789
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57676: LD_ADDR_EXP 121
57680: PUSH
57681: LD_EXP 121
57685: PPUSH
57686: LD_VAR 0 1
57690: PUSH
57691: LD_EXP 121
57695: PUSH
57696: LD_VAR 0 1
57700: ARRAY
57701: PUSH
57702: LD_INT 1
57704: PLUS
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PPUSH
57710: LD_VAR 0 9
57714: PPUSH
57715: CALL 70030 0 3
57719: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57720: LD_ADDR_EXP 120
57724: PUSH
57725: LD_EXP 120
57729: PPUSH
57730: LD_VAR 0 1
57734: PPUSH
57735: LD_EXP 120
57739: PUSH
57740: LD_VAR 0 1
57744: ARRAY
57745: PUSH
57746: LD_VAR 0 9
57750: DIFF
57751: PPUSH
57752: CALL_OW 1
57756: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57757: LD_VAR 0 3
57761: PPUSH
57762: LD_EXP 121
57766: PUSH
57767: LD_VAR 0 1
57771: ARRAY
57772: PUSH
57773: LD_EXP 121
57777: PUSH
57778: LD_VAR 0 1
57782: ARRAY
57783: ARRAY
57784: PPUSH
57785: CALL_OW 120
// end ; exit ;
57789: GO 58110
// end ; if tmp > 1 then
57791: LD_VAR 0 8
57795: PUSH
57796: LD_INT 1
57798: GREATER
57799: IFFALSE 57903
// for i = 2 to tmp do
57801: LD_ADDR_VAR 0 6
57805: PUSH
57806: DOUBLE
57807: LD_INT 2
57809: DEC
57810: ST_TO_ADDR
57811: LD_VAR 0 8
57815: PUSH
57816: FOR_TO
57817: IFFALSE 57901
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57819: LD_VAR 0 8
57823: PUSH
57824: LD_VAR 0 6
57828: ARRAY
57829: PPUSH
57830: CALL_OW 461
57834: PUSH
57835: LD_INT 6
57837: EQUAL
57838: IFFALSE 57899
// begin x := tmp [ i ] ;
57840: LD_ADDR_VAR 0 9
57844: PUSH
57845: LD_VAR 0 8
57849: PUSH
57850: LD_VAR 0 6
57854: ARRAY
57855: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57856: LD_ADDR_VAR 0 8
57860: PUSH
57861: LD_VAR 0 8
57865: PPUSH
57866: LD_VAR 0 6
57870: PPUSH
57871: CALL_OW 3
57875: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57876: LD_ADDR_VAR 0 8
57880: PUSH
57881: LD_VAR 0 8
57885: PPUSH
57886: LD_INT 1
57888: PPUSH
57889: LD_VAR 0 9
57893: PPUSH
57894: CALL_OW 2
57898: ST_TO_ADDR
// end ;
57899: GO 57816
57901: POP
57902: POP
// for i in tmp do
57903: LD_ADDR_VAR 0 6
57907: PUSH
57908: LD_VAR 0 8
57912: PUSH
57913: FOR_IN
57914: IFFALSE 57983
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57916: LD_VAR 0 6
57920: PPUSH
57921: CALL_OW 313
57925: PUSH
57926: LD_INT 6
57928: LESS
57929: PUSH
57930: LD_VAR 0 6
57934: PPUSH
57935: CALL_OW 266
57939: PUSH
57940: LD_INT 31
57942: PUSH
57943: LD_INT 32
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: IN
57950: NOT
57951: AND
57952: PUSH
57953: LD_VAR 0 6
57957: PPUSH
57958: CALL_OW 313
57962: PUSH
57963: LD_INT 0
57965: EQUAL
57966: OR
57967: IFFALSE 57981
// begin j := i ;
57969: LD_ADDR_VAR 0 7
57973: PUSH
57974: LD_VAR 0 6
57978: ST_TO_ADDR
// break ;
57979: GO 57983
// end ; end ;
57981: GO 57913
57983: POP
57984: POP
// if j then
57985: LD_VAR 0 7
57989: IFFALSE 58007
// ComEnterUnit ( unit , j ) else
57991: LD_VAR 0 3
57995: PPUSH
57996: LD_VAR 0 7
58000: PPUSH
58001: CALL_OW 120
58005: GO 58110
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58007: LD_ADDR_VAR 0 10
58011: PUSH
58012: LD_VAR 0 2
58016: PPUSH
58017: LD_INT 2
58019: PUSH
58020: LD_INT 30
58022: PUSH
58023: LD_INT 0
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: PUSH
58030: LD_INT 30
58032: PUSH
58033: LD_INT 1
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: PUSH
58040: EMPTY
58041: LIST
58042: LIST
58043: LIST
58044: PPUSH
58045: CALL_OW 72
58049: ST_TO_ADDR
// if depot then
58050: LD_VAR 0 10
58054: IFFALSE 58110
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58056: LD_ADDR_VAR 0 10
58060: PUSH
58061: LD_VAR 0 10
58065: PPUSH
58066: LD_VAR 0 3
58070: PPUSH
58071: CALL_OW 74
58075: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58076: LD_VAR 0 3
58080: PPUSH
58081: LD_VAR 0 10
58085: PPUSH
58086: CALL_OW 296
58090: PUSH
58091: LD_INT 10
58093: GREATER
58094: IFFALSE 58110
// ComStandNearbyBuilding ( unit , depot ) ;
58096: LD_VAR 0 3
58100: PPUSH
58101: LD_VAR 0 10
58105: PPUSH
58106: CALL 66644 0 2
// end ; end ; end ;
58110: LD_VAR 0 5
58114: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58115: LD_INT 0
58117: PPUSH
58118: PPUSH
58119: PPUSH
58120: PPUSH
// if not mc_bases then
58121: LD_EXP 111
58125: NOT
58126: IFFALSE 58130
// exit ;
58128: GO 58369
// for i = 1 to mc_bases do
58130: LD_ADDR_VAR 0 2
58134: PUSH
58135: DOUBLE
58136: LD_INT 1
58138: DEC
58139: ST_TO_ADDR
58140: LD_EXP 111
58144: PUSH
58145: FOR_TO
58146: IFFALSE 58367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58148: LD_ADDR_VAR 0 4
58152: PUSH
58153: LD_EXP 111
58157: PUSH
58158: LD_VAR 0 2
58162: ARRAY
58163: PPUSH
58164: LD_INT 21
58166: PUSH
58167: LD_INT 1
58169: PUSH
58170: EMPTY
58171: LIST
58172: LIST
58173: PPUSH
58174: CALL_OW 72
58178: PUSH
58179: LD_EXP 140
58183: PUSH
58184: LD_VAR 0 2
58188: ARRAY
58189: UNION
58190: ST_TO_ADDR
// if not tmp then
58191: LD_VAR 0 4
58195: NOT
58196: IFFALSE 58200
// continue ;
58198: GO 58145
// for j in tmp do
58200: LD_ADDR_VAR 0 3
58204: PUSH
58205: LD_VAR 0 4
58209: PUSH
58210: FOR_IN
58211: IFFALSE 58363
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58213: LD_VAR 0 3
58217: PPUSH
58218: CALL_OW 110
58222: NOT
58223: PUSH
58224: LD_VAR 0 3
58228: PPUSH
58229: CALL_OW 314
58233: NOT
58234: AND
58235: PUSH
58236: LD_VAR 0 3
58240: PPUSH
58241: CALL_OW 311
58245: NOT
58246: AND
58247: PUSH
58248: LD_VAR 0 3
58252: PPUSH
58253: CALL_OW 310
58257: NOT
58258: AND
58259: PUSH
58260: LD_VAR 0 3
58264: PUSH
58265: LD_EXP 114
58269: PUSH
58270: LD_VAR 0 2
58274: ARRAY
58275: PUSH
58276: LD_INT 1
58278: ARRAY
58279: IN
58280: NOT
58281: AND
58282: PUSH
58283: LD_VAR 0 3
58287: PUSH
58288: LD_EXP 114
58292: PUSH
58293: LD_VAR 0 2
58297: ARRAY
58298: PUSH
58299: LD_INT 2
58301: ARRAY
58302: IN
58303: NOT
58304: AND
58305: PUSH
58306: LD_VAR 0 3
58310: PUSH
58311: LD_EXP 123
58315: PUSH
58316: LD_VAR 0 2
58320: ARRAY
58321: IN
58322: NOT
58323: AND
58324: IFFALSE 58361
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58326: LD_VAR 0 2
58330: PPUSH
58331: LD_EXP 111
58335: PUSH
58336: LD_VAR 0 2
58340: ARRAY
58341: PPUSH
58342: LD_VAR 0 3
58346: PPUSH
58347: LD_VAR 0 3
58351: PPUSH
58352: CALL_OW 257
58356: PPUSH
58357: CALL 57133 0 4
// end ;
58361: GO 58210
58363: POP
58364: POP
// end ;
58365: GO 58145
58367: POP
58368: POP
// end ;
58369: LD_VAR 0 1
58373: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58374: LD_INT 0
58376: PPUSH
58377: PPUSH
58378: PPUSH
58379: PPUSH
58380: PPUSH
58381: PPUSH
// if not mc_bases [ base ] then
58382: LD_EXP 111
58386: PUSH
58387: LD_VAR 0 1
58391: ARRAY
58392: NOT
58393: IFFALSE 58397
// exit ;
58395: GO 58579
// tmp := [ ] ;
58397: LD_ADDR_VAR 0 6
58401: PUSH
58402: EMPTY
58403: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58404: LD_ADDR_VAR 0 7
58408: PUSH
58409: LD_VAR 0 3
58413: PPUSH
58414: LD_INT 0
58416: PPUSH
58417: CALL_OW 517
58421: ST_TO_ADDR
// if not list then
58422: LD_VAR 0 7
58426: NOT
58427: IFFALSE 58431
// exit ;
58429: GO 58579
// for i = 1 to amount do
58431: LD_ADDR_VAR 0 5
58435: PUSH
58436: DOUBLE
58437: LD_INT 1
58439: DEC
58440: ST_TO_ADDR
58441: LD_VAR 0 2
58445: PUSH
58446: FOR_TO
58447: IFFALSE 58527
// begin x := rand ( 1 , list [ 1 ] ) ;
58449: LD_ADDR_VAR 0 8
58453: PUSH
58454: LD_INT 1
58456: PPUSH
58457: LD_VAR 0 7
58461: PUSH
58462: LD_INT 1
58464: ARRAY
58465: PPUSH
58466: CALL_OW 12
58470: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58471: LD_ADDR_VAR 0 6
58475: PUSH
58476: LD_VAR 0 6
58480: PPUSH
58481: LD_VAR 0 5
58485: PPUSH
58486: LD_VAR 0 7
58490: PUSH
58491: LD_INT 1
58493: ARRAY
58494: PUSH
58495: LD_VAR 0 8
58499: ARRAY
58500: PUSH
58501: LD_VAR 0 7
58505: PUSH
58506: LD_INT 2
58508: ARRAY
58509: PUSH
58510: LD_VAR 0 8
58514: ARRAY
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: PPUSH
58520: CALL_OW 1
58524: ST_TO_ADDR
// end ;
58525: GO 58446
58527: POP
58528: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58529: LD_ADDR_EXP 124
58533: PUSH
58534: LD_EXP 124
58538: PPUSH
58539: LD_VAR 0 1
58543: PPUSH
58544: LD_VAR 0 6
58548: PPUSH
58549: CALL_OW 1
58553: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58554: LD_ADDR_EXP 126
58558: PUSH
58559: LD_EXP 126
58563: PPUSH
58564: LD_VAR 0 1
58568: PPUSH
58569: LD_VAR 0 3
58573: PPUSH
58574: CALL_OW 1
58578: ST_TO_ADDR
// end ;
58579: LD_VAR 0 4
58583: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58584: LD_INT 0
58586: PPUSH
// if not mc_bases [ base ] then
58587: LD_EXP 111
58591: PUSH
58592: LD_VAR 0 1
58596: ARRAY
58597: NOT
58598: IFFALSE 58602
// exit ;
58600: GO 58627
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58602: LD_ADDR_EXP 116
58606: PUSH
58607: LD_EXP 116
58611: PPUSH
58612: LD_VAR 0 1
58616: PPUSH
58617: LD_VAR 0 2
58621: PPUSH
58622: CALL_OW 1
58626: ST_TO_ADDR
// end ;
58627: LD_VAR 0 3
58631: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58632: LD_INT 0
58634: PPUSH
// if not mc_bases [ base ] then
58635: LD_EXP 111
58639: PUSH
58640: LD_VAR 0 1
58644: ARRAY
58645: NOT
58646: IFFALSE 58650
// exit ;
58648: GO 58687
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58650: LD_ADDR_EXP 116
58654: PUSH
58655: LD_EXP 116
58659: PPUSH
58660: LD_VAR 0 1
58664: PPUSH
58665: LD_EXP 116
58669: PUSH
58670: LD_VAR 0 1
58674: ARRAY
58675: PUSH
58676: LD_VAR 0 2
58680: UNION
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// end ;
58687: LD_VAR 0 3
58691: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58692: LD_INT 0
58694: PPUSH
// if not mc_bases [ base ] then
58695: LD_EXP 111
58699: PUSH
58700: LD_VAR 0 1
58704: ARRAY
58705: NOT
58706: IFFALSE 58710
// exit ;
58708: GO 58735
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58710: LD_ADDR_EXP 132
58714: PUSH
58715: LD_EXP 132
58719: PPUSH
58720: LD_VAR 0 1
58724: PPUSH
58725: LD_VAR 0 2
58729: PPUSH
58730: CALL_OW 1
58734: ST_TO_ADDR
// end ;
58735: LD_VAR 0 3
58739: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58740: LD_INT 0
58742: PPUSH
// if not mc_bases [ base ] then
58743: LD_EXP 111
58747: PUSH
58748: LD_VAR 0 1
58752: ARRAY
58753: NOT
58754: IFFALSE 58758
// exit ;
58756: GO 58795
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58758: LD_ADDR_EXP 132
58762: PUSH
58763: LD_EXP 132
58767: PPUSH
58768: LD_VAR 0 1
58772: PPUSH
58773: LD_EXP 132
58777: PUSH
58778: LD_VAR 0 1
58782: ARRAY
58783: PUSH
58784: LD_VAR 0 2
58788: ADD
58789: PPUSH
58790: CALL_OW 1
58794: ST_TO_ADDR
// end ;
58795: LD_VAR 0 3
58799: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58800: LD_INT 0
58802: PPUSH
// if not mc_bases [ base ] then
58803: LD_EXP 111
58807: PUSH
58808: LD_VAR 0 1
58812: ARRAY
58813: NOT
58814: IFFALSE 58818
// exit ;
58816: GO 58872
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58818: LD_ADDR_EXP 133
58822: PUSH
58823: LD_EXP 133
58827: PPUSH
58828: LD_VAR 0 1
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: CALL_OW 1
58842: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58843: LD_ADDR_EXP 122
58847: PUSH
58848: LD_EXP 122
58852: PPUSH
58853: LD_VAR 0 1
58857: PPUSH
58858: LD_VAR 0 2
58862: PUSH
58863: LD_INT 0
58865: PLUS
58866: PPUSH
58867: CALL_OW 1
58871: ST_TO_ADDR
// end ;
58872: LD_VAR 0 3
58876: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58877: LD_INT 0
58879: PPUSH
// if not mc_bases [ base ] then
58880: LD_EXP 111
58884: PUSH
58885: LD_VAR 0 1
58889: ARRAY
58890: NOT
58891: IFFALSE 58895
// exit ;
58893: GO 58920
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58895: LD_ADDR_EXP 122
58899: PUSH
58900: LD_EXP 122
58904: PPUSH
58905: LD_VAR 0 1
58909: PPUSH
58910: LD_VAR 0 2
58914: PPUSH
58915: CALL_OW 1
58919: ST_TO_ADDR
// end ;
58920: LD_VAR 0 3
58924: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58925: LD_INT 0
58927: PPUSH
58928: PPUSH
58929: PPUSH
58930: PPUSH
// if not mc_bases [ base ] then
58931: LD_EXP 111
58935: PUSH
58936: LD_VAR 0 1
58940: ARRAY
58941: NOT
58942: IFFALSE 58946
// exit ;
58944: GO 59011
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58946: LD_ADDR_EXP 131
58950: PUSH
58951: LD_EXP 131
58955: PPUSH
58956: LD_VAR 0 1
58960: PUSH
58961: LD_EXP 131
58965: PUSH
58966: LD_VAR 0 1
58970: ARRAY
58971: PUSH
58972: LD_INT 1
58974: PLUS
58975: PUSH
58976: EMPTY
58977: LIST
58978: LIST
58979: PPUSH
58980: LD_VAR 0 1
58984: PUSH
58985: LD_VAR 0 2
58989: PUSH
58990: LD_VAR 0 3
58994: PUSH
58995: LD_VAR 0 4
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: LIST
59004: LIST
59005: PPUSH
59006: CALL 70030 0 3
59010: ST_TO_ADDR
// end ;
59011: LD_VAR 0 5
59015: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59016: LD_INT 0
59018: PPUSH
// if not mc_bases [ base ] then
59019: LD_EXP 111
59023: PUSH
59024: LD_VAR 0 1
59028: ARRAY
59029: NOT
59030: IFFALSE 59034
// exit ;
59032: GO 59059
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59034: LD_ADDR_EXP 148
59038: PUSH
59039: LD_EXP 148
59043: PPUSH
59044: LD_VAR 0 1
59048: PPUSH
59049: LD_VAR 0 2
59053: PPUSH
59054: CALL_OW 1
59058: ST_TO_ADDR
// end ;
59059: LD_VAR 0 3
59063: RET
// export function MC_GetMinesField ( base ) ; begin
59064: LD_INT 0
59066: PPUSH
// result := mc_mines [ base ] ;
59067: LD_ADDR_VAR 0 2
59071: PUSH
59072: LD_EXP 124
59076: PUSH
59077: LD_VAR 0 1
59081: ARRAY
59082: ST_TO_ADDR
// end ;
59083: LD_VAR 0 2
59087: RET
// export function MC_GetProduceList ( base ) ; begin
59088: LD_INT 0
59090: PPUSH
// result := mc_produce [ base ] ;
59091: LD_ADDR_VAR 0 2
59095: PUSH
59096: LD_EXP 132
59100: PUSH
59101: LD_VAR 0 1
59105: ARRAY
59106: ST_TO_ADDR
// end ;
59107: LD_VAR 0 2
59111: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59112: LD_INT 0
59114: PPUSH
59115: PPUSH
// if not mc_bases then
59116: LD_EXP 111
59120: NOT
59121: IFFALSE 59125
// exit ;
59123: GO 59190
// if mc_bases [ base ] then
59125: LD_EXP 111
59129: PUSH
59130: LD_VAR 0 1
59134: ARRAY
59135: IFFALSE 59190
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59137: LD_ADDR_VAR 0 3
59141: PUSH
59142: LD_EXP 111
59146: PUSH
59147: LD_VAR 0 1
59151: ARRAY
59152: PPUSH
59153: LD_INT 30
59155: PUSH
59156: LD_VAR 0 2
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: PPUSH
59165: CALL_OW 72
59169: ST_TO_ADDR
// if result then
59170: LD_VAR 0 3
59174: IFFALSE 59190
// result := result [ 1 ] ;
59176: LD_ADDR_VAR 0 3
59180: PUSH
59181: LD_VAR 0 3
59185: PUSH
59186: LD_INT 1
59188: ARRAY
59189: ST_TO_ADDR
// end ; end ;
59190: LD_VAR 0 3
59194: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59195: LD_INT 0
59197: PPUSH
59198: PPUSH
// if not mc_bases then
59199: LD_EXP 111
59203: NOT
59204: IFFALSE 59208
// exit ;
59206: GO 59253
// if mc_bases [ base ] then
59208: LD_EXP 111
59212: PUSH
59213: LD_VAR 0 1
59217: ARRAY
59218: IFFALSE 59253
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59220: LD_ADDR_VAR 0 3
59224: PUSH
59225: LD_EXP 111
59229: PUSH
59230: LD_VAR 0 1
59234: ARRAY
59235: PPUSH
59236: LD_INT 30
59238: PUSH
59239: LD_VAR 0 2
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: PPUSH
59248: CALL_OW 72
59252: ST_TO_ADDR
// end ;
59253: LD_VAR 0 3
59257: RET
// export function MC_SetTame ( base , area ) ; begin
59258: LD_INT 0
59260: PPUSH
// if not mc_bases or not base then
59261: LD_EXP 111
59265: NOT
59266: PUSH
59267: LD_VAR 0 1
59271: NOT
59272: OR
59273: IFFALSE 59277
// exit ;
59275: GO 59302
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59277: LD_ADDR_EXP 139
59281: PUSH
59282: LD_EXP 139
59286: PPUSH
59287: LD_VAR 0 1
59291: PPUSH
59292: LD_VAR 0 2
59296: PPUSH
59297: CALL_OW 1
59301: ST_TO_ADDR
// end ;
59302: LD_VAR 0 3
59306: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59307: LD_INT 0
59309: PPUSH
59310: PPUSH
// if not mc_bases or not base then
59311: LD_EXP 111
59315: NOT
59316: PUSH
59317: LD_VAR 0 1
59321: NOT
59322: OR
59323: IFFALSE 59327
// exit ;
59325: GO 59429
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59327: LD_ADDR_VAR 0 4
59331: PUSH
59332: LD_EXP 111
59336: PUSH
59337: LD_VAR 0 1
59341: ARRAY
59342: PPUSH
59343: LD_INT 30
59345: PUSH
59346: LD_VAR 0 2
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: PPUSH
59355: CALL_OW 72
59359: ST_TO_ADDR
// if not tmp then
59360: LD_VAR 0 4
59364: NOT
59365: IFFALSE 59369
// exit ;
59367: GO 59429
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59369: LD_ADDR_EXP 143
59373: PUSH
59374: LD_EXP 143
59378: PPUSH
59379: LD_VAR 0 1
59383: PPUSH
59384: LD_EXP 143
59388: PUSH
59389: LD_VAR 0 1
59393: ARRAY
59394: PPUSH
59395: LD_EXP 143
59399: PUSH
59400: LD_VAR 0 1
59404: ARRAY
59405: PUSH
59406: LD_INT 1
59408: PLUS
59409: PPUSH
59410: LD_VAR 0 4
59414: PUSH
59415: LD_INT 1
59417: ARRAY
59418: PPUSH
59419: CALL_OW 2
59423: PPUSH
59424: CALL_OW 1
59428: ST_TO_ADDR
// end ;
59429: LD_VAR 0 3
59433: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59434: LD_INT 0
59436: PPUSH
59437: PPUSH
// if not mc_bases or not base or not kinds then
59438: LD_EXP 111
59442: NOT
59443: PUSH
59444: LD_VAR 0 1
59448: NOT
59449: OR
59450: PUSH
59451: LD_VAR 0 2
59455: NOT
59456: OR
59457: IFFALSE 59461
// exit ;
59459: GO 59522
// for i in kinds do
59461: LD_ADDR_VAR 0 4
59465: PUSH
59466: LD_VAR 0 2
59470: PUSH
59471: FOR_IN
59472: IFFALSE 59520
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59474: LD_ADDR_EXP 145
59478: PUSH
59479: LD_EXP 145
59483: PPUSH
59484: LD_VAR 0 1
59488: PUSH
59489: LD_EXP 145
59493: PUSH
59494: LD_VAR 0 1
59498: ARRAY
59499: PUSH
59500: LD_INT 1
59502: PLUS
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PPUSH
59508: LD_VAR 0 4
59512: PPUSH
59513: CALL 70030 0 3
59517: ST_TO_ADDR
59518: GO 59471
59520: POP
59521: POP
// end ;
59522: LD_VAR 0 3
59526: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59527: LD_INT 0
59529: PPUSH
// if not mc_bases or not base or not areas then
59530: LD_EXP 111
59534: NOT
59535: PUSH
59536: LD_VAR 0 1
59540: NOT
59541: OR
59542: PUSH
59543: LD_VAR 0 2
59547: NOT
59548: OR
59549: IFFALSE 59553
// exit ;
59551: GO 59578
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59553: LD_ADDR_EXP 129
59557: PUSH
59558: LD_EXP 129
59562: PPUSH
59563: LD_VAR 0 1
59567: PPUSH
59568: LD_VAR 0 2
59572: PPUSH
59573: CALL_OW 1
59577: ST_TO_ADDR
// end ;
59578: LD_VAR 0 3
59582: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59583: LD_INT 0
59585: PPUSH
// if not mc_bases or not base or not teleports_exit then
59586: LD_EXP 111
59590: NOT
59591: PUSH
59592: LD_VAR 0 1
59596: NOT
59597: OR
59598: PUSH
59599: LD_VAR 0 2
59603: NOT
59604: OR
59605: IFFALSE 59609
// exit ;
59607: GO 59634
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59609: LD_ADDR_EXP 146
59613: PUSH
59614: LD_EXP 146
59618: PPUSH
59619: LD_VAR 0 1
59623: PPUSH
59624: LD_VAR 0 2
59628: PPUSH
59629: CALL_OW 1
59633: ST_TO_ADDR
// end ;
59634: LD_VAR 0 3
59638: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59639: LD_INT 0
59641: PPUSH
59642: PPUSH
59643: PPUSH
// if not mc_bases or not base or not ext_list then
59644: LD_EXP 111
59648: NOT
59649: PUSH
59650: LD_VAR 0 1
59654: NOT
59655: OR
59656: PUSH
59657: LD_VAR 0 5
59661: NOT
59662: OR
59663: IFFALSE 59667
// exit ;
59665: GO 59840
// tmp := GetFacExtXYD ( x , y , d ) ;
59667: LD_ADDR_VAR 0 8
59671: PUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: LD_VAR 0 3
59681: PPUSH
59682: LD_VAR 0 4
59686: PPUSH
59687: CALL 98709 0 3
59691: ST_TO_ADDR
// if not tmp then
59692: LD_VAR 0 8
59696: NOT
59697: IFFALSE 59701
// exit ;
59699: GO 59840
// for i in tmp do
59701: LD_ADDR_VAR 0 7
59705: PUSH
59706: LD_VAR 0 8
59710: PUSH
59711: FOR_IN
59712: IFFALSE 59838
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59714: LD_ADDR_EXP 116
59718: PUSH
59719: LD_EXP 116
59723: PPUSH
59724: LD_VAR 0 1
59728: PPUSH
59729: LD_EXP 116
59733: PUSH
59734: LD_VAR 0 1
59738: ARRAY
59739: PPUSH
59740: LD_EXP 116
59744: PUSH
59745: LD_VAR 0 1
59749: ARRAY
59750: PUSH
59751: LD_INT 1
59753: PLUS
59754: PPUSH
59755: LD_VAR 0 5
59759: PUSH
59760: LD_INT 1
59762: ARRAY
59763: PUSH
59764: LD_VAR 0 7
59768: PUSH
59769: LD_INT 1
59771: ARRAY
59772: PUSH
59773: LD_VAR 0 7
59777: PUSH
59778: LD_INT 2
59780: ARRAY
59781: PUSH
59782: LD_VAR 0 7
59786: PUSH
59787: LD_INT 3
59789: ARRAY
59790: PUSH
59791: EMPTY
59792: LIST
59793: LIST
59794: LIST
59795: LIST
59796: PPUSH
59797: CALL_OW 2
59801: PPUSH
59802: CALL_OW 1
59806: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59807: LD_ADDR_VAR 0 5
59811: PUSH
59812: LD_VAR 0 5
59816: PPUSH
59817: LD_INT 1
59819: PPUSH
59820: CALL_OW 3
59824: ST_TO_ADDR
// if not ext_list then
59825: LD_VAR 0 5
59829: NOT
59830: IFFALSE 59836
// exit ;
59832: POP
59833: POP
59834: GO 59840
// end ;
59836: GO 59711
59838: POP
59839: POP
// end ;
59840: LD_VAR 0 6
59844: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59845: LD_INT 0
59847: PPUSH
// if not mc_bases or not base or not weapon_list then
59848: LD_EXP 111
59852: NOT
59853: PUSH
59854: LD_VAR 0 1
59858: NOT
59859: OR
59860: PUSH
59861: LD_VAR 0 2
59865: NOT
59866: OR
59867: IFFALSE 59871
// exit ;
59869: GO 59896
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59871: LD_ADDR_EXP 150
59875: PUSH
59876: LD_EXP 150
59880: PPUSH
59881: LD_VAR 0 1
59885: PPUSH
59886: LD_VAR 0 2
59890: PPUSH
59891: CALL_OW 1
59895: ST_TO_ADDR
// end ;
59896: LD_VAR 0 3
59900: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59901: LD_INT 0
59903: PPUSH
// if not mc_bases or not base or not tech_list then
59904: LD_EXP 111
59908: NOT
59909: PUSH
59910: LD_VAR 0 1
59914: NOT
59915: OR
59916: PUSH
59917: LD_VAR 0 2
59921: NOT
59922: OR
59923: IFFALSE 59927
// exit ;
59925: GO 59952
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59927: LD_ADDR_EXP 138
59931: PUSH
59932: LD_EXP 138
59936: PPUSH
59937: LD_VAR 0 1
59941: PPUSH
59942: LD_VAR 0 2
59946: PPUSH
59947: CALL_OW 1
59951: ST_TO_ADDR
// end ;
59952: LD_VAR 0 3
59956: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59957: LD_INT 0
59959: PPUSH
// if not mc_bases or not parking_area or not base then
59960: LD_EXP 111
59964: NOT
59965: PUSH
59966: LD_VAR 0 2
59970: NOT
59971: OR
59972: PUSH
59973: LD_VAR 0 1
59977: NOT
59978: OR
59979: IFFALSE 59983
// exit ;
59981: GO 60008
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59983: LD_ADDR_EXP 135
59987: PUSH
59988: LD_EXP 135
59992: PPUSH
59993: LD_VAR 0 1
59997: PPUSH
59998: LD_VAR 0 2
60002: PPUSH
60003: CALL_OW 1
60007: ST_TO_ADDR
// end ;
60008: LD_VAR 0 3
60012: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60013: LD_INT 0
60015: PPUSH
// if not mc_bases or not base or not scan_area then
60016: LD_EXP 111
60020: NOT
60021: PUSH
60022: LD_VAR 0 1
60026: NOT
60027: OR
60028: PUSH
60029: LD_VAR 0 2
60033: NOT
60034: OR
60035: IFFALSE 60039
// exit ;
60037: GO 60064
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60039: LD_ADDR_EXP 136
60043: PUSH
60044: LD_EXP 136
60048: PPUSH
60049: LD_VAR 0 1
60053: PPUSH
60054: LD_VAR 0 2
60058: PPUSH
60059: CALL_OW 1
60063: ST_TO_ADDR
// end ;
60064: LD_VAR 0 3
60068: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60069: LD_INT 0
60071: PPUSH
60072: PPUSH
// if not mc_bases or not base then
60073: LD_EXP 111
60077: NOT
60078: PUSH
60079: LD_VAR 0 1
60083: NOT
60084: OR
60085: IFFALSE 60089
// exit ;
60087: GO 60153
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60089: LD_ADDR_VAR 0 3
60093: PUSH
60094: LD_INT 1
60096: PUSH
60097: LD_INT 2
60099: PUSH
60100: LD_INT 3
60102: PUSH
60103: LD_INT 4
60105: PUSH
60106: LD_INT 11
60108: PUSH
60109: EMPTY
60110: LIST
60111: LIST
60112: LIST
60113: LIST
60114: LIST
60115: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60116: LD_ADDR_EXP 138
60120: PUSH
60121: LD_EXP 138
60125: PPUSH
60126: LD_VAR 0 1
60130: PPUSH
60131: LD_EXP 138
60135: PUSH
60136: LD_VAR 0 1
60140: ARRAY
60141: PUSH
60142: LD_VAR 0 3
60146: DIFF
60147: PPUSH
60148: CALL_OW 1
60152: ST_TO_ADDR
// end ;
60153: LD_VAR 0 2
60157: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60158: LD_INT 0
60160: PPUSH
// result := mc_vehicles [ base ] ;
60161: LD_ADDR_VAR 0 3
60165: PUSH
60166: LD_EXP 130
60170: PUSH
60171: LD_VAR 0 1
60175: ARRAY
60176: ST_TO_ADDR
// if onlyCombat then
60177: LD_VAR 0 2
60181: IFFALSE 60346
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60183: LD_ADDR_VAR 0 3
60187: PUSH
60188: LD_VAR 0 3
60192: PUSH
60193: LD_VAR 0 3
60197: PPUSH
60198: LD_INT 2
60200: PUSH
60201: LD_INT 34
60203: PUSH
60204: LD_INT 12
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PUSH
60211: LD_INT 34
60213: PUSH
60214: LD_INT 51
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: PUSH
60221: LD_INT 34
60223: PUSH
60224: LD_EXP 96
60228: PUSH
60229: EMPTY
60230: LIST
60231: LIST
60232: PUSH
60233: LD_INT 34
60235: PUSH
60236: LD_INT 32
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: PUSH
60243: LD_INT 34
60245: PUSH
60246: LD_INT 13
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: PUSH
60253: LD_INT 34
60255: PUSH
60256: LD_INT 52
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 34
60265: PUSH
60266: LD_INT 14
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: PUSH
60273: LD_INT 34
60275: PUSH
60276: LD_INT 53
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: PUSH
60283: LD_INT 34
60285: PUSH
60286: LD_EXP 95
60290: PUSH
60291: EMPTY
60292: LIST
60293: LIST
60294: PUSH
60295: LD_INT 34
60297: PUSH
60298: LD_INT 31
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: PUSH
60305: LD_INT 34
60307: PUSH
60308: LD_INT 48
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PUSH
60315: LD_INT 34
60317: PUSH
60318: LD_INT 8
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: PUSH
60325: EMPTY
60326: LIST
60327: LIST
60328: LIST
60329: LIST
60330: LIST
60331: LIST
60332: LIST
60333: LIST
60334: LIST
60335: LIST
60336: LIST
60337: LIST
60338: LIST
60339: PPUSH
60340: CALL_OW 72
60344: DIFF
60345: ST_TO_ADDR
// end ; end_of_file
60346: LD_VAR 0 3
60350: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60351: LD_INT 0
60353: PPUSH
60354: PPUSH
60355: PPUSH
// if not mc_bases or not skirmish then
60356: LD_EXP 111
60360: NOT
60361: PUSH
60362: LD_EXP 109
60366: NOT
60367: OR
60368: IFFALSE 60372
// exit ;
60370: GO 60537
// for i = 1 to mc_bases do
60372: LD_ADDR_VAR 0 4
60376: PUSH
60377: DOUBLE
60378: LD_INT 1
60380: DEC
60381: ST_TO_ADDR
60382: LD_EXP 111
60386: PUSH
60387: FOR_TO
60388: IFFALSE 60535
// begin if sci in mc_bases [ i ] then
60390: LD_VAR 0 2
60394: PUSH
60395: LD_EXP 111
60399: PUSH
60400: LD_VAR 0 4
60404: ARRAY
60405: IN
60406: IFFALSE 60533
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60408: LD_ADDR_EXP 140
60412: PUSH
60413: LD_EXP 140
60417: PPUSH
60418: LD_VAR 0 4
60422: PUSH
60423: LD_EXP 140
60427: PUSH
60428: LD_VAR 0 4
60432: ARRAY
60433: PUSH
60434: LD_INT 1
60436: PLUS
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: PPUSH
60442: LD_VAR 0 1
60446: PPUSH
60447: CALL 70030 0 3
60451: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60452: LD_ADDR_VAR 0 5
60456: PUSH
60457: LD_EXP 111
60461: PUSH
60462: LD_VAR 0 4
60466: ARRAY
60467: PPUSH
60468: LD_INT 2
60470: PUSH
60471: LD_INT 30
60473: PUSH
60474: LD_INT 0
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: PUSH
60481: LD_INT 30
60483: PUSH
60484: LD_INT 1
60486: PUSH
60487: EMPTY
60488: LIST
60489: LIST
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: LIST
60495: PPUSH
60496: CALL_OW 72
60500: PPUSH
60501: LD_VAR 0 1
60505: PPUSH
60506: CALL_OW 74
60510: ST_TO_ADDR
// if tmp then
60511: LD_VAR 0 5
60515: IFFALSE 60531
// ComStandNearbyBuilding ( ape , tmp ) ;
60517: LD_VAR 0 1
60521: PPUSH
60522: LD_VAR 0 5
60526: PPUSH
60527: CALL 66644 0 2
// break ;
60531: GO 60535
// end ; end ;
60533: GO 60387
60535: POP
60536: POP
// end ;
60537: LD_VAR 0 3
60541: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60542: LD_INT 0
60544: PPUSH
60545: PPUSH
60546: PPUSH
// if not mc_bases or not skirmish then
60547: LD_EXP 111
60551: NOT
60552: PUSH
60553: LD_EXP 109
60557: NOT
60558: OR
60559: IFFALSE 60563
// exit ;
60561: GO 60652
// for i = 1 to mc_bases do
60563: LD_ADDR_VAR 0 4
60567: PUSH
60568: DOUBLE
60569: LD_INT 1
60571: DEC
60572: ST_TO_ADDR
60573: LD_EXP 111
60577: PUSH
60578: FOR_TO
60579: IFFALSE 60650
// begin if building in mc_busy_turret_list [ i ] then
60581: LD_VAR 0 1
60585: PUSH
60586: LD_EXP 121
60590: PUSH
60591: LD_VAR 0 4
60595: ARRAY
60596: IN
60597: IFFALSE 60648
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60599: LD_ADDR_VAR 0 5
60603: PUSH
60604: LD_EXP 121
60608: PUSH
60609: LD_VAR 0 4
60613: ARRAY
60614: PUSH
60615: LD_VAR 0 1
60619: DIFF
60620: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60621: LD_ADDR_EXP 121
60625: PUSH
60626: LD_EXP 121
60630: PPUSH
60631: LD_VAR 0 4
60635: PPUSH
60636: LD_VAR 0 5
60640: PPUSH
60641: CALL_OW 1
60645: ST_TO_ADDR
// break ;
60646: GO 60650
// end ; end ;
60648: GO 60578
60650: POP
60651: POP
// end ;
60652: LD_VAR 0 3
60656: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60657: LD_INT 0
60659: PPUSH
60660: PPUSH
60661: PPUSH
// if not mc_bases or not skirmish then
60662: LD_EXP 111
60666: NOT
60667: PUSH
60668: LD_EXP 109
60672: NOT
60673: OR
60674: IFFALSE 60678
// exit ;
60676: GO 60877
// for i = 1 to mc_bases do
60678: LD_ADDR_VAR 0 5
60682: PUSH
60683: DOUBLE
60684: LD_INT 1
60686: DEC
60687: ST_TO_ADDR
60688: LD_EXP 111
60692: PUSH
60693: FOR_TO
60694: IFFALSE 60875
// if building in mc_bases [ i ] then
60696: LD_VAR 0 1
60700: PUSH
60701: LD_EXP 111
60705: PUSH
60706: LD_VAR 0 5
60710: ARRAY
60711: IN
60712: IFFALSE 60873
// begin tmp := mc_bases [ i ] diff building ;
60714: LD_ADDR_VAR 0 6
60718: PUSH
60719: LD_EXP 111
60723: PUSH
60724: LD_VAR 0 5
60728: ARRAY
60729: PUSH
60730: LD_VAR 0 1
60734: DIFF
60735: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60736: LD_ADDR_EXP 111
60740: PUSH
60741: LD_EXP 111
60745: PPUSH
60746: LD_VAR 0 5
60750: PPUSH
60751: LD_VAR 0 6
60755: PPUSH
60756: CALL_OW 1
60760: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60761: LD_VAR 0 1
60765: PUSH
60766: LD_EXP 119
60770: PUSH
60771: LD_VAR 0 5
60775: ARRAY
60776: IN
60777: IFFALSE 60816
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60779: LD_ADDR_EXP 119
60783: PUSH
60784: LD_EXP 119
60788: PPUSH
60789: LD_VAR 0 5
60793: PPUSH
60794: LD_EXP 119
60798: PUSH
60799: LD_VAR 0 5
60803: ARRAY
60804: PUSH
60805: LD_VAR 0 1
60809: DIFF
60810: PPUSH
60811: CALL_OW 1
60815: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60816: LD_VAR 0 1
60820: PUSH
60821: LD_EXP 120
60825: PUSH
60826: LD_VAR 0 5
60830: ARRAY
60831: IN
60832: IFFALSE 60871
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60834: LD_ADDR_EXP 120
60838: PUSH
60839: LD_EXP 120
60843: PPUSH
60844: LD_VAR 0 5
60848: PPUSH
60849: LD_EXP 120
60853: PUSH
60854: LD_VAR 0 5
60858: ARRAY
60859: PUSH
60860: LD_VAR 0 1
60864: DIFF
60865: PPUSH
60866: CALL_OW 1
60870: ST_TO_ADDR
// break ;
60871: GO 60875
// end ;
60873: GO 60693
60875: POP
60876: POP
// end ;
60877: LD_VAR 0 4
60881: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60882: LD_INT 0
60884: PPUSH
60885: PPUSH
60886: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60887: LD_EXP 111
60891: NOT
60892: PUSH
60893: LD_EXP 109
60897: NOT
60898: OR
60899: PUSH
60900: LD_VAR 0 3
60904: PUSH
60905: LD_EXP 137
60909: IN
60910: NOT
60911: OR
60912: IFFALSE 60916
// exit ;
60914: GO 61039
// for i = 1 to mc_vehicles do
60916: LD_ADDR_VAR 0 6
60920: PUSH
60921: DOUBLE
60922: LD_INT 1
60924: DEC
60925: ST_TO_ADDR
60926: LD_EXP 130
60930: PUSH
60931: FOR_TO
60932: IFFALSE 61037
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60934: LD_VAR 0 2
60938: PUSH
60939: LD_EXP 130
60943: PUSH
60944: LD_VAR 0 6
60948: ARRAY
60949: IN
60950: PUSH
60951: LD_VAR 0 1
60955: PUSH
60956: LD_EXP 130
60960: PUSH
60961: LD_VAR 0 6
60965: ARRAY
60966: IN
60967: OR
60968: IFFALSE 61035
// begin tmp := mc_vehicles [ i ] diff old ;
60970: LD_ADDR_VAR 0 7
60974: PUSH
60975: LD_EXP 130
60979: PUSH
60980: LD_VAR 0 6
60984: ARRAY
60985: PUSH
60986: LD_VAR 0 2
60990: DIFF
60991: ST_TO_ADDR
// tmp := tmp diff new ;
60992: LD_ADDR_VAR 0 7
60996: PUSH
60997: LD_VAR 0 7
61001: PUSH
61002: LD_VAR 0 1
61006: DIFF
61007: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61008: LD_ADDR_EXP 130
61012: PUSH
61013: LD_EXP 130
61017: PPUSH
61018: LD_VAR 0 6
61022: PPUSH
61023: LD_VAR 0 7
61027: PPUSH
61028: CALL_OW 1
61032: ST_TO_ADDR
// break ;
61033: GO 61037
// end ;
61035: GO 60931
61037: POP
61038: POP
// end ;
61039: LD_VAR 0 5
61043: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61044: LD_INT 0
61046: PPUSH
61047: PPUSH
61048: PPUSH
61049: PPUSH
// if not mc_bases or not skirmish then
61050: LD_EXP 111
61054: NOT
61055: PUSH
61056: LD_EXP 109
61060: NOT
61061: OR
61062: IFFALSE 61066
// exit ;
61064: GO 61443
// side := GetSide ( vehicle ) ;
61066: LD_ADDR_VAR 0 5
61070: PUSH
61071: LD_VAR 0 1
61075: PPUSH
61076: CALL_OW 255
61080: ST_TO_ADDR
// for i = 1 to mc_bases do
61081: LD_ADDR_VAR 0 4
61085: PUSH
61086: DOUBLE
61087: LD_INT 1
61089: DEC
61090: ST_TO_ADDR
61091: LD_EXP 111
61095: PUSH
61096: FOR_TO
61097: IFFALSE 61441
// begin if factory in mc_bases [ i ] then
61099: LD_VAR 0 2
61103: PUSH
61104: LD_EXP 111
61108: PUSH
61109: LD_VAR 0 4
61113: ARRAY
61114: IN
61115: IFFALSE 61439
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61117: LD_EXP 133
61121: PUSH
61122: LD_VAR 0 4
61126: ARRAY
61127: PUSH
61128: LD_EXP 122
61132: PUSH
61133: LD_VAR 0 4
61137: ARRAY
61138: LESS
61139: PUSH
61140: LD_VAR 0 1
61144: PPUSH
61145: CALL_OW 264
61149: PUSH
61150: LD_INT 31
61152: PUSH
61153: LD_INT 32
61155: PUSH
61156: LD_INT 51
61158: PUSH
61159: LD_EXP 96
61163: PUSH
61164: LD_INT 12
61166: PUSH
61167: LD_INT 30
61169: PUSH
61170: LD_EXP 95
61174: PUSH
61175: LD_INT 11
61177: PUSH
61178: LD_INT 53
61180: PUSH
61181: LD_INT 14
61183: PUSH
61184: LD_EXP 99
61188: PUSH
61189: LD_INT 29
61191: PUSH
61192: LD_EXP 97
61196: PUSH
61197: LD_INT 13
61199: PUSH
61200: LD_INT 52
61202: PUSH
61203: LD_INT 48
61205: PUSH
61206: LD_INT 8
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: IN
61228: NOT
61229: AND
61230: IFFALSE 61278
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61232: LD_ADDR_EXP 133
61236: PUSH
61237: LD_EXP 133
61241: PPUSH
61242: LD_VAR 0 4
61246: PUSH
61247: LD_EXP 133
61251: PUSH
61252: LD_VAR 0 4
61256: ARRAY
61257: PUSH
61258: LD_INT 1
61260: PLUS
61261: PUSH
61262: EMPTY
61263: LIST
61264: LIST
61265: PPUSH
61266: LD_VAR 0 1
61270: PPUSH
61271: CALL 70030 0 3
61275: ST_TO_ADDR
61276: GO 61322
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61278: LD_ADDR_EXP 130
61282: PUSH
61283: LD_EXP 130
61287: PPUSH
61288: LD_VAR 0 4
61292: PUSH
61293: LD_EXP 130
61297: PUSH
61298: LD_VAR 0 4
61302: ARRAY
61303: PUSH
61304: LD_INT 1
61306: PLUS
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: PPUSH
61312: LD_VAR 0 1
61316: PPUSH
61317: CALL 70030 0 3
61321: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61322: LD_VAR 0 1
61326: PPUSH
61327: CALL_OW 263
61331: PUSH
61332: LD_INT 2
61334: EQUAL
61335: IFFALSE 61355
// begin repeat wait ( 0 0$1 ) ;
61337: LD_INT 35
61339: PPUSH
61340: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61344: LD_VAR 0 1
61348: PPUSH
61349: CALL_OW 312
61353: IFFALSE 61337
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61355: LD_VAR 0 1
61359: PPUSH
61360: LD_EXP 135
61364: PUSH
61365: LD_VAR 0 4
61369: ARRAY
61370: PPUSH
61371: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61375: LD_VAR 0 1
61379: PPUSH
61380: CALL_OW 263
61384: PUSH
61385: LD_INT 1
61387: NONEQUAL
61388: IFFALSE 61392
// break ;
61390: GO 61441
// repeat wait ( 0 0$1 ) ;
61392: LD_INT 35
61394: PPUSH
61395: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61399: LD_VAR 0 1
61403: PPUSH
61404: LD_EXP 135
61408: PUSH
61409: LD_VAR 0 4
61413: ARRAY
61414: PPUSH
61415: CALL_OW 308
61419: IFFALSE 61392
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61421: LD_VAR 0 1
61425: PPUSH
61426: CALL_OW 311
61430: PPUSH
61431: CALL_OW 121
// exit ;
61435: POP
61436: POP
61437: GO 61443
// end ; end ;
61439: GO 61096
61441: POP
61442: POP
// end ;
61443: LD_VAR 0 3
61447: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61448: LD_INT 0
61450: PPUSH
61451: PPUSH
61452: PPUSH
61453: PPUSH
// if not mc_bases or not skirmish then
61454: LD_EXP 111
61458: NOT
61459: PUSH
61460: LD_EXP 109
61464: NOT
61465: OR
61466: IFFALSE 61470
// exit ;
61468: GO 61823
// repeat wait ( 0 0$1 ) ;
61470: LD_INT 35
61472: PPUSH
61473: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61477: LD_VAR 0 2
61481: PPUSH
61482: LD_VAR 0 3
61486: PPUSH
61487: CALL_OW 284
61491: IFFALSE 61470
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61493: LD_VAR 0 2
61497: PPUSH
61498: LD_VAR 0 3
61502: PPUSH
61503: CALL_OW 283
61507: PUSH
61508: LD_INT 4
61510: EQUAL
61511: IFFALSE 61515
// exit ;
61513: GO 61823
// for i = 1 to mc_bases do
61515: LD_ADDR_VAR 0 7
61519: PUSH
61520: DOUBLE
61521: LD_INT 1
61523: DEC
61524: ST_TO_ADDR
61525: LD_EXP 111
61529: PUSH
61530: FOR_TO
61531: IFFALSE 61821
// begin if mc_crates_area [ i ] then
61533: LD_EXP 129
61537: PUSH
61538: LD_VAR 0 7
61542: ARRAY
61543: IFFALSE 61654
// for j in mc_crates_area [ i ] do
61545: LD_ADDR_VAR 0 8
61549: PUSH
61550: LD_EXP 129
61554: PUSH
61555: LD_VAR 0 7
61559: ARRAY
61560: PUSH
61561: FOR_IN
61562: IFFALSE 61652
// if InArea ( x , y , j ) then
61564: LD_VAR 0 2
61568: PPUSH
61569: LD_VAR 0 3
61573: PPUSH
61574: LD_VAR 0 8
61578: PPUSH
61579: CALL_OW 309
61583: IFFALSE 61650
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61585: LD_ADDR_EXP 127
61589: PUSH
61590: LD_EXP 127
61594: PPUSH
61595: LD_VAR 0 7
61599: PUSH
61600: LD_EXP 127
61604: PUSH
61605: LD_VAR 0 7
61609: ARRAY
61610: PUSH
61611: LD_INT 1
61613: PLUS
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PPUSH
61619: LD_VAR 0 4
61623: PUSH
61624: LD_VAR 0 2
61628: PUSH
61629: LD_VAR 0 3
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: LIST
61638: PPUSH
61639: CALL 70030 0 3
61643: ST_TO_ADDR
// exit ;
61644: POP
61645: POP
61646: POP
61647: POP
61648: GO 61823
// end ;
61650: GO 61561
61652: POP
61653: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61654: LD_ADDR_VAR 0 9
61658: PUSH
61659: LD_EXP 111
61663: PUSH
61664: LD_VAR 0 7
61668: ARRAY
61669: PPUSH
61670: LD_INT 2
61672: PUSH
61673: LD_INT 30
61675: PUSH
61676: LD_INT 0
61678: PUSH
61679: EMPTY
61680: LIST
61681: LIST
61682: PUSH
61683: LD_INT 30
61685: PUSH
61686: LD_INT 1
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: LIST
61697: PPUSH
61698: CALL_OW 72
61702: ST_TO_ADDR
// if not depot then
61703: LD_VAR 0 9
61707: NOT
61708: IFFALSE 61712
// continue ;
61710: GO 61530
// for j in depot do
61712: LD_ADDR_VAR 0 8
61716: PUSH
61717: LD_VAR 0 9
61721: PUSH
61722: FOR_IN
61723: IFFALSE 61817
// if GetDistUnitXY ( j , x , y ) < 30 then
61725: LD_VAR 0 8
61729: PPUSH
61730: LD_VAR 0 2
61734: PPUSH
61735: LD_VAR 0 3
61739: PPUSH
61740: CALL_OW 297
61744: PUSH
61745: LD_INT 30
61747: LESS
61748: IFFALSE 61815
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61750: LD_ADDR_EXP 127
61754: PUSH
61755: LD_EXP 127
61759: PPUSH
61760: LD_VAR 0 7
61764: PUSH
61765: LD_EXP 127
61769: PUSH
61770: LD_VAR 0 7
61774: ARRAY
61775: PUSH
61776: LD_INT 1
61778: PLUS
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: PPUSH
61784: LD_VAR 0 4
61788: PUSH
61789: LD_VAR 0 2
61793: PUSH
61794: LD_VAR 0 3
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: LIST
61803: PPUSH
61804: CALL 70030 0 3
61808: ST_TO_ADDR
// exit ;
61809: POP
61810: POP
61811: POP
61812: POP
61813: GO 61823
// end ;
61815: GO 61722
61817: POP
61818: POP
// end ;
61819: GO 61530
61821: POP
61822: POP
// end ;
61823: LD_VAR 0 6
61827: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61828: LD_INT 0
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
// if not mc_bases or not skirmish then
61834: LD_EXP 111
61838: NOT
61839: PUSH
61840: LD_EXP 109
61844: NOT
61845: OR
61846: IFFALSE 61850
// exit ;
61848: GO 62127
// side := GetSide ( lab ) ;
61850: LD_ADDR_VAR 0 4
61854: PUSH
61855: LD_VAR 0 2
61859: PPUSH
61860: CALL_OW 255
61864: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61865: LD_VAR 0 4
61869: PUSH
61870: LD_EXP 137
61874: IN
61875: NOT
61876: PUSH
61877: LD_EXP 138
61881: NOT
61882: OR
61883: PUSH
61884: LD_EXP 111
61888: NOT
61889: OR
61890: IFFALSE 61894
// exit ;
61892: GO 62127
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61894: LD_ADDR_EXP 138
61898: PUSH
61899: LD_EXP 138
61903: PPUSH
61904: LD_VAR 0 4
61908: PPUSH
61909: LD_EXP 138
61913: PUSH
61914: LD_VAR 0 4
61918: ARRAY
61919: PUSH
61920: LD_VAR 0 1
61924: DIFF
61925: PPUSH
61926: CALL_OW 1
61930: ST_TO_ADDR
// for i = 1 to mc_bases do
61931: LD_ADDR_VAR 0 5
61935: PUSH
61936: DOUBLE
61937: LD_INT 1
61939: DEC
61940: ST_TO_ADDR
61941: LD_EXP 111
61945: PUSH
61946: FOR_TO
61947: IFFALSE 62125
// begin if lab in mc_bases [ i ] then
61949: LD_VAR 0 2
61953: PUSH
61954: LD_EXP 111
61958: PUSH
61959: LD_VAR 0 5
61963: ARRAY
61964: IN
61965: IFFALSE 62123
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61967: LD_VAR 0 1
61971: PUSH
61972: LD_INT 11
61974: PUSH
61975: LD_INT 4
61977: PUSH
61978: LD_INT 3
61980: PUSH
61981: LD_INT 2
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: LIST
61988: LIST
61989: IN
61990: PUSH
61991: LD_EXP 141
61995: PUSH
61996: LD_VAR 0 5
62000: ARRAY
62001: AND
62002: IFFALSE 62123
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62004: LD_ADDR_VAR 0 6
62008: PUSH
62009: LD_EXP 141
62013: PUSH
62014: LD_VAR 0 5
62018: ARRAY
62019: PUSH
62020: LD_INT 1
62022: ARRAY
62023: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62024: LD_ADDR_EXP 141
62028: PUSH
62029: LD_EXP 141
62033: PPUSH
62034: LD_VAR 0 5
62038: PPUSH
62039: EMPTY
62040: PPUSH
62041: CALL_OW 1
62045: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62046: LD_VAR 0 6
62050: PPUSH
62051: LD_INT 0
62053: PPUSH
62054: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62058: LD_VAR 0 6
62062: PPUSH
62063: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62067: LD_ADDR_EXP 140
62071: PUSH
62072: LD_EXP 140
62076: PPUSH
62077: LD_VAR 0 5
62081: PPUSH
62082: LD_EXP 140
62086: PUSH
62087: LD_VAR 0 5
62091: ARRAY
62092: PPUSH
62093: LD_INT 1
62095: PPUSH
62096: LD_VAR 0 6
62100: PPUSH
62101: CALL_OW 2
62105: PPUSH
62106: CALL_OW 1
62110: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62111: LD_VAR 0 5
62115: PPUSH
62116: LD_INT 112
62118: PPUSH
62119: CALL 39139 0 2
// end ; end ; end ;
62123: GO 61946
62125: POP
62126: POP
// end ;
62127: LD_VAR 0 3
62131: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62132: LD_INT 0
62134: PPUSH
62135: PPUSH
62136: PPUSH
62137: PPUSH
62138: PPUSH
62139: PPUSH
62140: PPUSH
62141: PPUSH
// if not mc_bases or not skirmish then
62142: LD_EXP 111
62146: NOT
62147: PUSH
62148: LD_EXP 109
62152: NOT
62153: OR
62154: IFFALSE 62158
// exit ;
62156: GO 63529
// for i = 1 to mc_bases do
62158: LD_ADDR_VAR 0 3
62162: PUSH
62163: DOUBLE
62164: LD_INT 1
62166: DEC
62167: ST_TO_ADDR
62168: LD_EXP 111
62172: PUSH
62173: FOR_TO
62174: IFFALSE 63527
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62176: LD_VAR 0 1
62180: PUSH
62181: LD_EXP 111
62185: PUSH
62186: LD_VAR 0 3
62190: ARRAY
62191: IN
62192: PUSH
62193: LD_VAR 0 1
62197: PUSH
62198: LD_EXP 118
62202: PUSH
62203: LD_VAR 0 3
62207: ARRAY
62208: IN
62209: OR
62210: PUSH
62211: LD_VAR 0 1
62215: PUSH
62216: LD_EXP 133
62220: PUSH
62221: LD_VAR 0 3
62225: ARRAY
62226: IN
62227: OR
62228: PUSH
62229: LD_VAR 0 1
62233: PUSH
62234: LD_EXP 130
62238: PUSH
62239: LD_VAR 0 3
62243: ARRAY
62244: IN
62245: OR
62246: PUSH
62247: LD_VAR 0 1
62251: PUSH
62252: LD_EXP 140
62256: PUSH
62257: LD_VAR 0 3
62261: ARRAY
62262: IN
62263: OR
62264: PUSH
62265: LD_VAR 0 1
62269: PUSH
62270: LD_EXP 141
62274: PUSH
62275: LD_VAR 0 3
62279: ARRAY
62280: IN
62281: OR
62282: IFFALSE 63525
// begin if un in mc_ape [ i ] then
62284: LD_VAR 0 1
62288: PUSH
62289: LD_EXP 140
62293: PUSH
62294: LD_VAR 0 3
62298: ARRAY
62299: IN
62300: IFFALSE 62339
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62302: LD_ADDR_EXP 140
62306: PUSH
62307: LD_EXP 140
62311: PPUSH
62312: LD_VAR 0 3
62316: PPUSH
62317: LD_EXP 140
62321: PUSH
62322: LD_VAR 0 3
62326: ARRAY
62327: PUSH
62328: LD_VAR 0 1
62332: DIFF
62333: PPUSH
62334: CALL_OW 1
62338: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62339: LD_VAR 0 1
62343: PUSH
62344: LD_EXP 141
62348: PUSH
62349: LD_VAR 0 3
62353: ARRAY
62354: IN
62355: IFFALSE 62379
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62357: LD_ADDR_EXP 141
62361: PUSH
62362: LD_EXP 141
62366: PPUSH
62367: LD_VAR 0 3
62371: PPUSH
62372: EMPTY
62373: PPUSH
62374: CALL_OW 1
62378: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62379: LD_VAR 0 1
62383: PPUSH
62384: CALL_OW 247
62388: PUSH
62389: LD_INT 2
62391: EQUAL
62392: PUSH
62393: LD_VAR 0 1
62397: PPUSH
62398: CALL_OW 110
62402: PUSH
62403: LD_INT 20
62405: EQUAL
62406: PUSH
62407: LD_VAR 0 1
62411: PUSH
62412: LD_EXP 133
62416: PUSH
62417: LD_VAR 0 3
62421: ARRAY
62422: IN
62423: OR
62424: PUSH
62425: LD_VAR 0 1
62429: PPUSH
62430: CALL_OW 264
62434: PUSH
62435: LD_INT 12
62437: PUSH
62438: LD_INT 51
62440: PUSH
62441: LD_EXP 96
62445: PUSH
62446: LD_INT 32
62448: PUSH
62449: LD_INT 13
62451: PUSH
62452: LD_INT 52
62454: PUSH
62455: LD_INT 31
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: LIST
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: IN
62467: OR
62468: AND
62469: IFFALSE 62777
// begin if un in mc_defender [ i ] then
62471: LD_VAR 0 1
62475: PUSH
62476: LD_EXP 133
62480: PUSH
62481: LD_VAR 0 3
62485: ARRAY
62486: IN
62487: IFFALSE 62526
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62489: LD_ADDR_EXP 133
62493: PUSH
62494: LD_EXP 133
62498: PPUSH
62499: LD_VAR 0 3
62503: PPUSH
62504: LD_EXP 133
62508: PUSH
62509: LD_VAR 0 3
62513: ARRAY
62514: PUSH
62515: LD_VAR 0 1
62519: DIFF
62520: PPUSH
62521: CALL_OW 1
62525: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62526: LD_ADDR_VAR 0 8
62530: PUSH
62531: LD_VAR 0 3
62535: PPUSH
62536: LD_INT 3
62538: PPUSH
62539: CALL 59195 0 2
62543: ST_TO_ADDR
// if fac then
62544: LD_VAR 0 8
62548: IFFALSE 62777
// begin for j in fac do
62550: LD_ADDR_VAR 0 4
62554: PUSH
62555: LD_VAR 0 8
62559: PUSH
62560: FOR_IN
62561: IFFALSE 62775
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62563: LD_ADDR_VAR 0 9
62567: PUSH
62568: LD_VAR 0 8
62572: PPUSH
62573: LD_VAR 0 1
62577: PPUSH
62578: CALL_OW 265
62582: PPUSH
62583: LD_VAR 0 1
62587: PPUSH
62588: CALL_OW 262
62592: PPUSH
62593: LD_VAR 0 1
62597: PPUSH
62598: CALL_OW 263
62602: PPUSH
62603: LD_VAR 0 1
62607: PPUSH
62608: CALL_OW 264
62612: PPUSH
62613: CALL 67562 0 5
62617: ST_TO_ADDR
// if components then
62618: LD_VAR 0 9
62622: IFFALSE 62773
// begin if GetWeapon ( un ) = ar_control_tower then
62624: LD_VAR 0 1
62628: PPUSH
62629: CALL_OW 264
62633: PUSH
62634: LD_INT 31
62636: EQUAL
62637: IFFALSE 62754
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62639: LD_VAR 0 1
62643: PPUSH
62644: CALL_OW 311
62648: PPUSH
62649: LD_INT 0
62651: PPUSH
62652: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62656: LD_ADDR_EXP 151
62660: PUSH
62661: LD_EXP 151
62665: PPUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_EXP 151
62675: PUSH
62676: LD_VAR 0 3
62680: ARRAY
62681: PUSH
62682: LD_VAR 0 1
62686: PPUSH
62687: CALL_OW 311
62691: DIFF
62692: PPUSH
62693: CALL_OW 1
62697: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62698: LD_ADDR_VAR 0 7
62702: PUSH
62703: LD_EXP 132
62707: PUSH
62708: LD_VAR 0 3
62712: ARRAY
62713: PPUSH
62714: LD_INT 1
62716: PPUSH
62717: LD_VAR 0 9
62721: PPUSH
62722: CALL_OW 2
62726: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62727: LD_ADDR_EXP 132
62731: PUSH
62732: LD_EXP 132
62736: PPUSH
62737: LD_VAR 0 3
62741: PPUSH
62742: LD_VAR 0 7
62746: PPUSH
62747: CALL_OW 1
62751: ST_TO_ADDR
// end else
62752: GO 62771
// MC_InsertProduceList ( i , [ components ] ) ;
62754: LD_VAR 0 3
62758: PPUSH
62759: LD_VAR 0 9
62763: PUSH
62764: EMPTY
62765: LIST
62766: PPUSH
62767: CALL 58740 0 2
// break ;
62771: GO 62775
// end ; end ;
62773: GO 62560
62775: POP
62776: POP
// end ; end ; if GetType ( un ) = unit_building then
62777: LD_VAR 0 1
62781: PPUSH
62782: CALL_OW 247
62786: PUSH
62787: LD_INT 3
62789: EQUAL
62790: IFFALSE 63193
// begin btype := GetBType ( un ) ;
62792: LD_ADDR_VAR 0 5
62796: PUSH
62797: LD_VAR 0 1
62801: PPUSH
62802: CALL_OW 266
62806: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62807: LD_VAR 0 5
62811: PUSH
62812: LD_INT 29
62814: PUSH
62815: LD_INT 30
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: IN
62822: IFFALSE 62895
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62824: LD_VAR 0 1
62828: PPUSH
62829: CALL_OW 250
62833: PPUSH
62834: LD_VAR 0 1
62838: PPUSH
62839: CALL_OW 251
62843: PPUSH
62844: LD_VAR 0 1
62848: PPUSH
62849: CALL_OW 255
62853: PPUSH
62854: CALL_OW 440
62858: NOT
62859: IFFALSE 62895
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62861: LD_VAR 0 1
62865: PPUSH
62866: CALL_OW 250
62870: PPUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: CALL_OW 251
62880: PPUSH
62881: LD_VAR 0 1
62885: PPUSH
62886: CALL_OW 255
62890: PPUSH
62891: CALL_OW 441
// end ; if btype = b_warehouse then
62895: LD_VAR 0 5
62899: PUSH
62900: LD_INT 1
62902: EQUAL
62903: IFFALSE 62921
// begin btype := b_depot ;
62905: LD_ADDR_VAR 0 5
62909: PUSH
62910: LD_INT 0
62912: ST_TO_ADDR
// pos := 1 ;
62913: LD_ADDR_VAR 0 6
62917: PUSH
62918: LD_INT 1
62920: ST_TO_ADDR
// end ; if btype = b_factory then
62921: LD_VAR 0 5
62925: PUSH
62926: LD_INT 3
62928: EQUAL
62929: IFFALSE 62947
// begin btype := b_workshop ;
62931: LD_ADDR_VAR 0 5
62935: PUSH
62936: LD_INT 2
62938: ST_TO_ADDR
// pos := 1 ;
62939: LD_ADDR_VAR 0 6
62943: PUSH
62944: LD_INT 1
62946: ST_TO_ADDR
// end ; if btype = b_barracks then
62947: LD_VAR 0 5
62951: PUSH
62952: LD_INT 5
62954: EQUAL
62955: IFFALSE 62965
// btype := b_armoury ;
62957: LD_ADDR_VAR 0 5
62961: PUSH
62962: LD_INT 4
62964: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62965: LD_VAR 0 5
62969: PUSH
62970: LD_INT 7
62972: PUSH
62973: LD_INT 8
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: IN
62980: IFFALSE 62990
// btype := b_lab ;
62982: LD_ADDR_VAR 0 5
62986: PUSH
62987: LD_INT 6
62989: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62990: LD_ADDR_EXP 116
62994: PUSH
62995: LD_EXP 116
62999: PPUSH
63000: LD_VAR 0 3
63004: PUSH
63005: LD_EXP 116
63009: PUSH
63010: LD_VAR 0 3
63014: ARRAY
63015: PUSH
63016: LD_INT 1
63018: PLUS
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PPUSH
63024: LD_VAR 0 5
63028: PUSH
63029: LD_VAR 0 1
63033: PPUSH
63034: CALL_OW 250
63038: PUSH
63039: LD_VAR 0 1
63043: PPUSH
63044: CALL_OW 251
63048: PUSH
63049: LD_VAR 0 1
63053: PPUSH
63054: CALL_OW 254
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: PPUSH
63065: CALL 70030 0 3
63069: ST_TO_ADDR
// if pos = 1 then
63070: LD_VAR 0 6
63074: PUSH
63075: LD_INT 1
63077: EQUAL
63078: IFFALSE 63193
// begin tmp := mc_build_list [ i ] ;
63080: LD_ADDR_VAR 0 7
63084: PUSH
63085: LD_EXP 116
63089: PUSH
63090: LD_VAR 0 3
63094: ARRAY
63095: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63096: LD_VAR 0 7
63100: PPUSH
63101: LD_INT 2
63103: PUSH
63104: LD_INT 30
63106: PUSH
63107: LD_INT 0
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PUSH
63114: LD_INT 30
63116: PUSH
63117: LD_INT 1
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: LIST
63128: PPUSH
63129: CALL_OW 72
63133: IFFALSE 63143
// pos := 2 ;
63135: LD_ADDR_VAR 0 6
63139: PUSH
63140: LD_INT 2
63142: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63143: LD_ADDR_VAR 0 7
63147: PUSH
63148: LD_VAR 0 7
63152: PPUSH
63153: LD_VAR 0 6
63157: PPUSH
63158: LD_VAR 0 7
63162: PPUSH
63163: CALL 70356 0 3
63167: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63168: LD_ADDR_EXP 116
63172: PUSH
63173: LD_EXP 116
63177: PPUSH
63178: LD_VAR 0 3
63182: PPUSH
63183: LD_VAR 0 7
63187: PPUSH
63188: CALL_OW 1
63192: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63193: LD_VAR 0 1
63197: PUSH
63198: LD_EXP 111
63202: PUSH
63203: LD_VAR 0 3
63207: ARRAY
63208: IN
63209: IFFALSE 63248
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63211: LD_ADDR_EXP 111
63215: PUSH
63216: LD_EXP 111
63220: PPUSH
63221: LD_VAR 0 3
63225: PPUSH
63226: LD_EXP 111
63230: PUSH
63231: LD_VAR 0 3
63235: ARRAY
63236: PUSH
63237: LD_VAR 0 1
63241: DIFF
63242: PPUSH
63243: CALL_OW 1
63247: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63248: LD_VAR 0 1
63252: PUSH
63253: LD_EXP 118
63257: PUSH
63258: LD_VAR 0 3
63262: ARRAY
63263: IN
63264: IFFALSE 63303
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63266: LD_ADDR_EXP 118
63270: PUSH
63271: LD_EXP 118
63275: PPUSH
63276: LD_VAR 0 3
63280: PPUSH
63281: LD_EXP 118
63285: PUSH
63286: LD_VAR 0 3
63290: ARRAY
63291: PUSH
63292: LD_VAR 0 1
63296: DIFF
63297: PPUSH
63298: CALL_OW 1
63302: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63303: LD_VAR 0 1
63307: PUSH
63308: LD_EXP 130
63312: PUSH
63313: LD_VAR 0 3
63317: ARRAY
63318: IN
63319: IFFALSE 63358
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63321: LD_ADDR_EXP 130
63325: PUSH
63326: LD_EXP 130
63330: PPUSH
63331: LD_VAR 0 3
63335: PPUSH
63336: LD_EXP 130
63340: PUSH
63341: LD_VAR 0 3
63345: ARRAY
63346: PUSH
63347: LD_VAR 0 1
63351: DIFF
63352: PPUSH
63353: CALL_OW 1
63357: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63358: LD_VAR 0 1
63362: PUSH
63363: LD_EXP 133
63367: PUSH
63368: LD_VAR 0 3
63372: ARRAY
63373: IN
63374: IFFALSE 63413
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63376: LD_ADDR_EXP 133
63380: PUSH
63381: LD_EXP 133
63385: PPUSH
63386: LD_VAR 0 3
63390: PPUSH
63391: LD_EXP 133
63395: PUSH
63396: LD_VAR 0 3
63400: ARRAY
63401: PUSH
63402: LD_VAR 0 1
63406: DIFF
63407: PPUSH
63408: CALL_OW 1
63412: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63413: LD_VAR 0 1
63417: PUSH
63418: LD_EXP 120
63422: PUSH
63423: LD_VAR 0 3
63427: ARRAY
63428: IN
63429: IFFALSE 63468
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63431: LD_ADDR_EXP 120
63435: PUSH
63436: LD_EXP 120
63440: PPUSH
63441: LD_VAR 0 3
63445: PPUSH
63446: LD_EXP 120
63450: PUSH
63451: LD_VAR 0 3
63455: ARRAY
63456: PUSH
63457: LD_VAR 0 1
63461: DIFF
63462: PPUSH
63463: CALL_OW 1
63467: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63468: LD_VAR 0 1
63472: PUSH
63473: LD_EXP 119
63477: PUSH
63478: LD_VAR 0 3
63482: ARRAY
63483: IN
63484: IFFALSE 63523
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63486: LD_ADDR_EXP 119
63490: PUSH
63491: LD_EXP 119
63495: PPUSH
63496: LD_VAR 0 3
63500: PPUSH
63501: LD_EXP 119
63505: PUSH
63506: LD_VAR 0 3
63510: ARRAY
63511: PUSH
63512: LD_VAR 0 1
63516: DIFF
63517: PPUSH
63518: CALL_OW 1
63522: ST_TO_ADDR
// end ; break ;
63523: GO 63527
// end ;
63525: GO 62173
63527: POP
63528: POP
// end ;
63529: LD_VAR 0 2
63533: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63534: LD_INT 0
63536: PPUSH
63537: PPUSH
63538: PPUSH
// if not mc_bases or not skirmish then
63539: LD_EXP 111
63543: NOT
63544: PUSH
63545: LD_EXP 109
63549: NOT
63550: OR
63551: IFFALSE 63555
// exit ;
63553: GO 63770
// for i = 1 to mc_bases do
63555: LD_ADDR_VAR 0 3
63559: PUSH
63560: DOUBLE
63561: LD_INT 1
63563: DEC
63564: ST_TO_ADDR
63565: LD_EXP 111
63569: PUSH
63570: FOR_TO
63571: IFFALSE 63768
// begin if building in mc_construct_list [ i ] then
63573: LD_VAR 0 1
63577: PUSH
63578: LD_EXP 118
63582: PUSH
63583: LD_VAR 0 3
63587: ARRAY
63588: IN
63589: IFFALSE 63766
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63591: LD_ADDR_EXP 118
63595: PUSH
63596: LD_EXP 118
63600: PPUSH
63601: LD_VAR 0 3
63605: PPUSH
63606: LD_EXP 118
63610: PUSH
63611: LD_VAR 0 3
63615: ARRAY
63616: PUSH
63617: LD_VAR 0 1
63621: DIFF
63622: PPUSH
63623: CALL_OW 1
63627: ST_TO_ADDR
// if building in mc_lab [ i ] then
63628: LD_VAR 0 1
63632: PUSH
63633: LD_EXP 144
63637: PUSH
63638: LD_VAR 0 3
63642: ARRAY
63643: IN
63644: IFFALSE 63699
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63646: LD_ADDR_EXP 145
63650: PUSH
63651: LD_EXP 145
63655: PPUSH
63656: LD_VAR 0 3
63660: PPUSH
63661: LD_EXP 145
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: PPUSH
63672: LD_INT 1
63674: PPUSH
63675: LD_EXP 145
63679: PUSH
63680: LD_VAR 0 3
63684: ARRAY
63685: PPUSH
63686: LD_INT 0
63688: PPUSH
63689: CALL 69448 0 4
63693: PPUSH
63694: CALL_OW 1
63698: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63699: LD_VAR 0 1
63703: PUSH
63704: LD_EXP 111
63708: PUSH
63709: LD_VAR 0 3
63713: ARRAY
63714: IN
63715: NOT
63716: IFFALSE 63762
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63718: LD_ADDR_EXP 111
63722: PUSH
63723: LD_EXP 111
63727: PPUSH
63728: LD_VAR 0 3
63732: PUSH
63733: LD_EXP 111
63737: PUSH
63738: LD_VAR 0 3
63742: ARRAY
63743: PUSH
63744: LD_INT 1
63746: PLUS
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PPUSH
63752: LD_VAR 0 1
63756: PPUSH
63757: CALL 70030 0 3
63761: ST_TO_ADDR
// exit ;
63762: POP
63763: POP
63764: GO 63770
// end ; end ;
63766: GO 63570
63768: POP
63769: POP
// end ;
63770: LD_VAR 0 2
63774: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63775: LD_INT 0
63777: PPUSH
63778: PPUSH
63779: PPUSH
63780: PPUSH
63781: PPUSH
63782: PPUSH
63783: PPUSH
// if not mc_bases or not skirmish then
63784: LD_EXP 111
63788: NOT
63789: PUSH
63790: LD_EXP 109
63794: NOT
63795: OR
63796: IFFALSE 63800
// exit ;
63798: GO 64461
// for i = 1 to mc_bases do
63800: LD_ADDR_VAR 0 3
63804: PUSH
63805: DOUBLE
63806: LD_INT 1
63808: DEC
63809: ST_TO_ADDR
63810: LD_EXP 111
63814: PUSH
63815: FOR_TO
63816: IFFALSE 64459
// begin if building in mc_construct_list [ i ] then
63818: LD_VAR 0 1
63822: PUSH
63823: LD_EXP 118
63827: PUSH
63828: LD_VAR 0 3
63832: ARRAY
63833: IN
63834: IFFALSE 64457
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63836: LD_ADDR_EXP 118
63840: PUSH
63841: LD_EXP 118
63845: PPUSH
63846: LD_VAR 0 3
63850: PPUSH
63851: LD_EXP 118
63855: PUSH
63856: LD_VAR 0 3
63860: ARRAY
63861: PUSH
63862: LD_VAR 0 1
63866: DIFF
63867: PPUSH
63868: CALL_OW 1
63872: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63873: LD_ADDR_EXP 111
63877: PUSH
63878: LD_EXP 111
63882: PPUSH
63883: LD_VAR 0 3
63887: PUSH
63888: LD_EXP 111
63892: PUSH
63893: LD_VAR 0 3
63897: ARRAY
63898: PUSH
63899: LD_INT 1
63901: PLUS
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PPUSH
63907: LD_VAR 0 1
63911: PPUSH
63912: CALL 70030 0 3
63916: ST_TO_ADDR
// btype := GetBType ( building ) ;
63917: LD_ADDR_VAR 0 5
63921: PUSH
63922: LD_VAR 0 1
63926: PPUSH
63927: CALL_OW 266
63931: ST_TO_ADDR
// side := GetSide ( building ) ;
63932: LD_ADDR_VAR 0 8
63936: PUSH
63937: LD_VAR 0 1
63941: PPUSH
63942: CALL_OW 255
63946: ST_TO_ADDR
// if btype = b_lab then
63947: LD_VAR 0 5
63951: PUSH
63952: LD_INT 6
63954: EQUAL
63955: IFFALSE 64005
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63957: LD_ADDR_EXP 144
63961: PUSH
63962: LD_EXP 144
63966: PPUSH
63967: LD_VAR 0 3
63971: PUSH
63972: LD_EXP 144
63976: PUSH
63977: LD_VAR 0 3
63981: ARRAY
63982: PUSH
63983: LD_INT 1
63985: PLUS
63986: PUSH
63987: EMPTY
63988: LIST
63989: LIST
63990: PPUSH
63991: LD_VAR 0 1
63995: PPUSH
63996: CALL 70030 0 3
64000: ST_TO_ADDR
// exit ;
64001: POP
64002: POP
64003: GO 64461
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64005: LD_VAR 0 5
64009: PUSH
64010: LD_INT 0
64012: PUSH
64013: LD_INT 2
64015: PUSH
64016: LD_INT 4
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: LIST
64023: IN
64024: IFFALSE 64148
// begin if btype = b_armoury then
64026: LD_VAR 0 5
64030: PUSH
64031: LD_INT 4
64033: EQUAL
64034: IFFALSE 64044
// btype := b_barracks ;
64036: LD_ADDR_VAR 0 5
64040: PUSH
64041: LD_INT 5
64043: ST_TO_ADDR
// if btype = b_depot then
64044: LD_VAR 0 5
64048: PUSH
64049: LD_INT 0
64051: EQUAL
64052: IFFALSE 64062
// btype := b_warehouse ;
64054: LD_ADDR_VAR 0 5
64058: PUSH
64059: LD_INT 1
64061: ST_TO_ADDR
// if btype = b_workshop then
64062: LD_VAR 0 5
64066: PUSH
64067: LD_INT 2
64069: EQUAL
64070: IFFALSE 64080
// btype := b_factory ;
64072: LD_ADDR_VAR 0 5
64076: PUSH
64077: LD_INT 3
64079: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64080: LD_VAR 0 5
64084: PPUSH
64085: LD_VAR 0 8
64089: PPUSH
64090: CALL_OW 323
64094: PUSH
64095: LD_INT 1
64097: EQUAL
64098: IFFALSE 64144
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64100: LD_ADDR_EXP 143
64104: PUSH
64105: LD_EXP 143
64109: PPUSH
64110: LD_VAR 0 3
64114: PUSH
64115: LD_EXP 143
64119: PUSH
64120: LD_VAR 0 3
64124: ARRAY
64125: PUSH
64126: LD_INT 1
64128: PLUS
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: PPUSH
64134: LD_VAR 0 1
64138: PPUSH
64139: CALL 70030 0 3
64143: ST_TO_ADDR
// exit ;
64144: POP
64145: POP
64146: GO 64461
// end ; if btype in [ b_bunker , b_turret ] then
64148: LD_VAR 0 5
64152: PUSH
64153: LD_INT 32
64155: PUSH
64156: LD_INT 33
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: IN
64163: IFFALSE 64453
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64165: LD_ADDR_EXP 119
64169: PUSH
64170: LD_EXP 119
64174: PPUSH
64175: LD_VAR 0 3
64179: PUSH
64180: LD_EXP 119
64184: PUSH
64185: LD_VAR 0 3
64189: ARRAY
64190: PUSH
64191: LD_INT 1
64193: PLUS
64194: PUSH
64195: EMPTY
64196: LIST
64197: LIST
64198: PPUSH
64199: LD_VAR 0 1
64203: PPUSH
64204: CALL 70030 0 3
64208: ST_TO_ADDR
// if btype = b_bunker then
64209: LD_VAR 0 5
64213: PUSH
64214: LD_INT 32
64216: EQUAL
64217: IFFALSE 64453
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64219: LD_ADDR_EXP 120
64223: PUSH
64224: LD_EXP 120
64228: PPUSH
64229: LD_VAR 0 3
64233: PUSH
64234: LD_EXP 120
64238: PUSH
64239: LD_VAR 0 3
64243: ARRAY
64244: PUSH
64245: LD_INT 1
64247: PLUS
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PPUSH
64253: LD_VAR 0 1
64257: PPUSH
64258: CALL 70030 0 3
64262: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64263: LD_ADDR_VAR 0 6
64267: PUSH
64268: LD_EXP 111
64272: PUSH
64273: LD_VAR 0 3
64277: ARRAY
64278: PPUSH
64279: LD_INT 25
64281: PUSH
64282: LD_INT 1
64284: PUSH
64285: EMPTY
64286: LIST
64287: LIST
64288: PUSH
64289: LD_INT 3
64291: PUSH
64292: LD_INT 54
64294: PUSH
64295: EMPTY
64296: LIST
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: EMPTY
64303: LIST
64304: LIST
64305: PPUSH
64306: CALL_OW 72
64310: ST_TO_ADDR
// if tmp then
64311: LD_VAR 0 6
64315: IFFALSE 64321
// exit ;
64317: POP
64318: POP
64319: GO 64461
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64321: LD_ADDR_VAR 0 6
64325: PUSH
64326: LD_EXP 111
64330: PUSH
64331: LD_VAR 0 3
64335: ARRAY
64336: PPUSH
64337: LD_INT 2
64339: PUSH
64340: LD_INT 30
64342: PUSH
64343: LD_INT 4
64345: PUSH
64346: EMPTY
64347: LIST
64348: LIST
64349: PUSH
64350: LD_INT 30
64352: PUSH
64353: LD_INT 5
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: LIST
64364: PPUSH
64365: CALL_OW 72
64369: ST_TO_ADDR
// if not tmp then
64370: LD_VAR 0 6
64374: NOT
64375: IFFALSE 64381
// exit ;
64377: POP
64378: POP
64379: GO 64461
// for j in tmp do
64381: LD_ADDR_VAR 0 4
64385: PUSH
64386: LD_VAR 0 6
64390: PUSH
64391: FOR_IN
64392: IFFALSE 64451
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64394: LD_ADDR_VAR 0 7
64398: PUSH
64399: LD_VAR 0 4
64403: PPUSH
64404: CALL_OW 313
64408: PPUSH
64409: LD_INT 25
64411: PUSH
64412: LD_INT 1
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PPUSH
64419: CALL_OW 72
64423: ST_TO_ADDR
// if units then
64424: LD_VAR 0 7
64428: IFFALSE 64449
// begin ComExitBuilding ( units [ 1 ] ) ;
64430: LD_VAR 0 7
64434: PUSH
64435: LD_INT 1
64437: ARRAY
64438: PPUSH
64439: CALL_OW 122
// exit ;
64443: POP
64444: POP
64445: POP
64446: POP
64447: GO 64461
// end ; end ;
64449: GO 64391
64451: POP
64452: POP
// end ; end ; exit ;
64453: POP
64454: POP
64455: GO 64461
// end ; end ;
64457: GO 63815
64459: POP
64460: POP
// end ;
64461: LD_VAR 0 2
64465: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64466: LD_INT 0
64468: PPUSH
64469: PPUSH
64470: PPUSH
64471: PPUSH
64472: PPUSH
64473: PPUSH
64474: PPUSH
// if not mc_bases or not skirmish then
64475: LD_EXP 111
64479: NOT
64480: PUSH
64481: LD_EXP 109
64485: NOT
64486: OR
64487: IFFALSE 64491
// exit ;
64489: GO 64722
// btype := GetBType ( building ) ;
64491: LD_ADDR_VAR 0 6
64495: PUSH
64496: LD_VAR 0 1
64500: PPUSH
64501: CALL_OW 266
64505: ST_TO_ADDR
// x := GetX ( building ) ;
64506: LD_ADDR_VAR 0 7
64510: PUSH
64511: LD_VAR 0 1
64515: PPUSH
64516: CALL_OW 250
64520: ST_TO_ADDR
// y := GetY ( building ) ;
64521: LD_ADDR_VAR 0 8
64525: PUSH
64526: LD_VAR 0 1
64530: PPUSH
64531: CALL_OW 251
64535: ST_TO_ADDR
// d := GetDir ( building ) ;
64536: LD_ADDR_VAR 0 9
64540: PUSH
64541: LD_VAR 0 1
64545: PPUSH
64546: CALL_OW 254
64550: ST_TO_ADDR
// for i = 1 to mc_bases do
64551: LD_ADDR_VAR 0 4
64555: PUSH
64556: DOUBLE
64557: LD_INT 1
64559: DEC
64560: ST_TO_ADDR
64561: LD_EXP 111
64565: PUSH
64566: FOR_TO
64567: IFFALSE 64720
// begin if not mc_build_list [ i ] then
64569: LD_EXP 116
64573: PUSH
64574: LD_VAR 0 4
64578: ARRAY
64579: NOT
64580: IFFALSE 64584
// continue ;
64582: GO 64566
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64584: LD_VAR 0 6
64588: PUSH
64589: LD_VAR 0 7
64593: PUSH
64594: LD_VAR 0 8
64598: PUSH
64599: LD_VAR 0 9
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: PPUSH
64610: LD_EXP 116
64614: PUSH
64615: LD_VAR 0 4
64619: ARRAY
64620: PUSH
64621: LD_INT 1
64623: ARRAY
64624: PPUSH
64625: CALL 76199 0 2
64629: IFFALSE 64718
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64631: LD_ADDR_EXP 116
64635: PUSH
64636: LD_EXP 116
64640: PPUSH
64641: LD_VAR 0 4
64645: PPUSH
64646: LD_EXP 116
64650: PUSH
64651: LD_VAR 0 4
64655: ARRAY
64656: PPUSH
64657: LD_INT 1
64659: PPUSH
64660: CALL_OW 3
64664: PPUSH
64665: CALL_OW 1
64669: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64670: LD_ADDR_EXP 118
64674: PUSH
64675: LD_EXP 118
64679: PPUSH
64680: LD_VAR 0 4
64684: PUSH
64685: LD_EXP 118
64689: PUSH
64690: LD_VAR 0 4
64694: ARRAY
64695: PUSH
64696: LD_INT 1
64698: PLUS
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: PPUSH
64704: LD_VAR 0 1
64708: PPUSH
64709: CALL 70030 0 3
64713: ST_TO_ADDR
// exit ;
64714: POP
64715: POP
64716: GO 64722
// end ; end ;
64718: GO 64566
64720: POP
64721: POP
// end ;
64722: LD_VAR 0 3
64726: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64727: LD_INT 0
64729: PPUSH
64730: PPUSH
64731: PPUSH
// if not mc_bases or not skirmish then
64732: LD_EXP 111
64736: NOT
64737: PUSH
64738: LD_EXP 109
64742: NOT
64743: OR
64744: IFFALSE 64748
// exit ;
64746: GO 64938
// for i = 1 to mc_bases do
64748: LD_ADDR_VAR 0 4
64752: PUSH
64753: DOUBLE
64754: LD_INT 1
64756: DEC
64757: ST_TO_ADDR
64758: LD_EXP 111
64762: PUSH
64763: FOR_TO
64764: IFFALSE 64851
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64766: LD_VAR 0 1
64770: PUSH
64771: LD_EXP 119
64775: PUSH
64776: LD_VAR 0 4
64780: ARRAY
64781: IN
64782: PUSH
64783: LD_VAR 0 1
64787: PUSH
64788: LD_EXP 120
64792: PUSH
64793: LD_VAR 0 4
64797: ARRAY
64798: IN
64799: NOT
64800: AND
64801: IFFALSE 64849
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64803: LD_ADDR_EXP 120
64807: PUSH
64808: LD_EXP 120
64812: PPUSH
64813: LD_VAR 0 4
64817: PUSH
64818: LD_EXP 120
64822: PUSH
64823: LD_VAR 0 4
64827: ARRAY
64828: PUSH
64829: LD_INT 1
64831: PLUS
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PPUSH
64837: LD_VAR 0 1
64841: PPUSH
64842: CALL 70030 0 3
64846: ST_TO_ADDR
// break ;
64847: GO 64851
// end ; end ;
64849: GO 64763
64851: POP
64852: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64853: LD_VAR 0 1
64857: PPUSH
64858: CALL_OW 257
64862: PUSH
64863: LD_EXP 137
64867: IN
64868: PUSH
64869: LD_VAR 0 1
64873: PPUSH
64874: CALL_OW 266
64878: PUSH
64879: LD_INT 5
64881: EQUAL
64882: AND
64883: PUSH
64884: LD_VAR 0 2
64888: PPUSH
64889: CALL_OW 110
64893: PUSH
64894: LD_INT 18
64896: NONEQUAL
64897: AND
64898: IFFALSE 64938
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64900: LD_VAR 0 2
64904: PPUSH
64905: CALL_OW 257
64909: PUSH
64910: LD_INT 5
64912: PUSH
64913: LD_INT 8
64915: PUSH
64916: LD_INT 9
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: LIST
64923: IN
64924: IFFALSE 64938
// SetClass ( unit , 1 ) ;
64926: LD_VAR 0 2
64930: PPUSH
64931: LD_INT 1
64933: PPUSH
64934: CALL_OW 336
// end ;
64938: LD_VAR 0 3
64942: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64943: LD_INT 0
64945: PPUSH
64946: PPUSH
// if not mc_bases or not skirmish then
64947: LD_EXP 111
64951: NOT
64952: PUSH
64953: LD_EXP 109
64957: NOT
64958: OR
64959: IFFALSE 64963
// exit ;
64961: GO 65079
// if GetLives ( abandoned_vehicle ) > 250 then
64963: LD_VAR 0 2
64967: PPUSH
64968: CALL_OW 256
64972: PUSH
64973: LD_INT 250
64975: GREATER
64976: IFFALSE 64980
// exit ;
64978: GO 65079
// for i = 1 to mc_bases do
64980: LD_ADDR_VAR 0 6
64984: PUSH
64985: DOUBLE
64986: LD_INT 1
64988: DEC
64989: ST_TO_ADDR
64990: LD_EXP 111
64994: PUSH
64995: FOR_TO
64996: IFFALSE 65077
// begin if driver in mc_bases [ i ] then
64998: LD_VAR 0 1
65002: PUSH
65003: LD_EXP 111
65007: PUSH
65008: LD_VAR 0 6
65012: ARRAY
65013: IN
65014: IFFALSE 65075
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65016: LD_VAR 0 1
65020: PPUSH
65021: LD_EXP 111
65025: PUSH
65026: LD_VAR 0 6
65030: ARRAY
65031: PPUSH
65032: LD_INT 2
65034: PUSH
65035: LD_INT 30
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 30
65047: PUSH
65048: LD_INT 1
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: LIST
65059: PPUSH
65060: CALL_OW 72
65064: PUSH
65065: LD_INT 1
65067: ARRAY
65068: PPUSH
65069: CALL_OW 112
// break ;
65073: GO 65077
// end ; end ;
65075: GO 64995
65077: POP
65078: POP
// end ; end_of_file
65079: LD_VAR 0 5
65083: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65084: LD_INT 0
65086: PPUSH
65087: PPUSH
// if exist_mode then
65088: LD_VAR 0 2
65092: IFFALSE 65117
// unit := CreateCharacter ( prefix & ident ) else
65094: LD_ADDR_VAR 0 5
65098: PUSH
65099: LD_VAR 0 3
65103: PUSH
65104: LD_VAR 0 1
65108: STR
65109: PPUSH
65110: CALL_OW 34
65114: ST_TO_ADDR
65115: GO 65132
// unit := NewCharacter ( ident ) ;
65117: LD_ADDR_VAR 0 5
65121: PUSH
65122: LD_VAR 0 1
65126: PPUSH
65127: CALL_OW 25
65131: ST_TO_ADDR
// result := unit ;
65132: LD_ADDR_VAR 0 4
65136: PUSH
65137: LD_VAR 0 5
65141: ST_TO_ADDR
// end ;
65142: LD_VAR 0 4
65146: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65147: LD_INT 0
65149: PPUSH
65150: PPUSH
// if not side or not nation then
65151: LD_VAR 0 1
65155: NOT
65156: PUSH
65157: LD_VAR 0 2
65161: NOT
65162: OR
65163: IFFALSE 65167
// exit ;
65165: GO 65931
// case nation of nation_american :
65167: LD_VAR 0 2
65171: PUSH
65172: LD_INT 1
65174: DOUBLE
65175: EQUAL
65176: IFTRUE 65180
65178: GO 65394
65180: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65181: LD_ADDR_VAR 0 4
65185: PUSH
65186: LD_INT 35
65188: PUSH
65189: LD_INT 45
65191: PUSH
65192: LD_INT 46
65194: PUSH
65195: LD_INT 47
65197: PUSH
65198: LD_INT 82
65200: PUSH
65201: LD_INT 83
65203: PUSH
65204: LD_INT 84
65206: PUSH
65207: LD_INT 85
65209: PUSH
65210: LD_INT 86
65212: PUSH
65213: LD_INT 1
65215: PUSH
65216: LD_INT 2
65218: PUSH
65219: LD_INT 6
65221: PUSH
65222: LD_INT 15
65224: PUSH
65225: LD_INT 16
65227: PUSH
65228: LD_INT 7
65230: PUSH
65231: LD_INT 12
65233: PUSH
65234: LD_INT 13
65236: PUSH
65237: LD_INT 10
65239: PUSH
65240: LD_INT 14
65242: PUSH
65243: LD_INT 20
65245: PUSH
65246: LD_INT 21
65248: PUSH
65249: LD_INT 22
65251: PUSH
65252: LD_INT 25
65254: PUSH
65255: LD_INT 32
65257: PUSH
65258: LD_INT 27
65260: PUSH
65261: LD_INT 36
65263: PUSH
65264: LD_INT 69
65266: PUSH
65267: LD_INT 39
65269: PUSH
65270: LD_INT 34
65272: PUSH
65273: LD_INT 40
65275: PUSH
65276: LD_INT 48
65278: PUSH
65279: LD_INT 49
65281: PUSH
65282: LD_INT 50
65284: PUSH
65285: LD_INT 51
65287: PUSH
65288: LD_INT 52
65290: PUSH
65291: LD_INT 53
65293: PUSH
65294: LD_INT 54
65296: PUSH
65297: LD_INT 55
65299: PUSH
65300: LD_INT 56
65302: PUSH
65303: LD_INT 57
65305: PUSH
65306: LD_INT 58
65308: PUSH
65309: LD_INT 59
65311: PUSH
65312: LD_INT 60
65314: PUSH
65315: LD_INT 61
65317: PUSH
65318: LD_INT 62
65320: PUSH
65321: LD_INT 80
65323: PUSH
65324: LD_INT 82
65326: PUSH
65327: LD_INT 83
65329: PUSH
65330: LD_INT 84
65332: PUSH
65333: LD_INT 85
65335: PUSH
65336: LD_INT 86
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: ST_TO_ADDR
65392: GO 65855
65394: LD_INT 2
65396: DOUBLE
65397: EQUAL
65398: IFTRUE 65402
65400: GO 65624
65402: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65403: LD_ADDR_VAR 0 4
65407: PUSH
65408: LD_INT 35
65410: PUSH
65411: LD_INT 45
65413: PUSH
65414: LD_INT 46
65416: PUSH
65417: LD_INT 47
65419: PUSH
65420: LD_INT 82
65422: PUSH
65423: LD_INT 83
65425: PUSH
65426: LD_INT 84
65428: PUSH
65429: LD_INT 85
65431: PUSH
65432: LD_INT 87
65434: PUSH
65435: LD_INT 70
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: LD_INT 11
65443: PUSH
65444: LD_INT 3
65446: PUSH
65447: LD_INT 4
65449: PUSH
65450: LD_INT 5
65452: PUSH
65453: LD_INT 6
65455: PUSH
65456: LD_INT 15
65458: PUSH
65459: LD_INT 18
65461: PUSH
65462: LD_INT 7
65464: PUSH
65465: LD_INT 17
65467: PUSH
65468: LD_INT 8
65470: PUSH
65471: LD_INT 20
65473: PUSH
65474: LD_INT 21
65476: PUSH
65477: LD_INT 22
65479: PUSH
65480: LD_INT 72
65482: PUSH
65483: LD_INT 26
65485: PUSH
65486: LD_INT 69
65488: PUSH
65489: LD_INT 39
65491: PUSH
65492: LD_INT 40
65494: PUSH
65495: LD_INT 41
65497: PUSH
65498: LD_INT 42
65500: PUSH
65501: LD_INT 43
65503: PUSH
65504: LD_INT 48
65506: PUSH
65507: LD_INT 49
65509: PUSH
65510: LD_INT 50
65512: PUSH
65513: LD_INT 51
65515: PUSH
65516: LD_INT 52
65518: PUSH
65519: LD_INT 53
65521: PUSH
65522: LD_INT 54
65524: PUSH
65525: LD_INT 55
65527: PUSH
65528: LD_INT 56
65530: PUSH
65531: LD_INT 60
65533: PUSH
65534: LD_INT 61
65536: PUSH
65537: LD_INT 62
65539: PUSH
65540: LD_INT 66
65542: PUSH
65543: LD_INT 67
65545: PUSH
65546: LD_INT 68
65548: PUSH
65549: LD_INT 81
65551: PUSH
65552: LD_INT 82
65554: PUSH
65555: LD_INT 83
65557: PUSH
65558: LD_INT 84
65560: PUSH
65561: LD_INT 85
65563: PUSH
65564: LD_INT 87
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: ST_TO_ADDR
65622: GO 65855
65624: LD_INT 3
65626: DOUBLE
65627: EQUAL
65628: IFTRUE 65632
65630: GO 65854
65632: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65633: LD_ADDR_VAR 0 4
65637: PUSH
65638: LD_INT 46
65640: PUSH
65641: LD_INT 47
65643: PUSH
65644: LD_INT 1
65646: PUSH
65647: LD_INT 2
65649: PUSH
65650: LD_INT 82
65652: PUSH
65653: LD_INT 83
65655: PUSH
65656: LD_INT 84
65658: PUSH
65659: LD_INT 85
65661: PUSH
65662: LD_INT 86
65664: PUSH
65665: LD_INT 11
65667: PUSH
65668: LD_INT 9
65670: PUSH
65671: LD_INT 20
65673: PUSH
65674: LD_INT 19
65676: PUSH
65677: LD_INT 21
65679: PUSH
65680: LD_INT 24
65682: PUSH
65683: LD_INT 22
65685: PUSH
65686: LD_INT 25
65688: PUSH
65689: LD_INT 28
65691: PUSH
65692: LD_INT 29
65694: PUSH
65695: LD_INT 30
65697: PUSH
65698: LD_INT 31
65700: PUSH
65701: LD_INT 37
65703: PUSH
65704: LD_INT 38
65706: PUSH
65707: LD_INT 32
65709: PUSH
65710: LD_INT 27
65712: PUSH
65713: LD_INT 33
65715: PUSH
65716: LD_INT 69
65718: PUSH
65719: LD_INT 39
65721: PUSH
65722: LD_INT 34
65724: PUSH
65725: LD_INT 40
65727: PUSH
65728: LD_INT 71
65730: PUSH
65731: LD_INT 23
65733: PUSH
65734: LD_INT 44
65736: PUSH
65737: LD_INT 48
65739: PUSH
65740: LD_INT 49
65742: PUSH
65743: LD_INT 50
65745: PUSH
65746: LD_INT 51
65748: PUSH
65749: LD_INT 52
65751: PUSH
65752: LD_INT 53
65754: PUSH
65755: LD_INT 54
65757: PUSH
65758: LD_INT 55
65760: PUSH
65761: LD_INT 56
65763: PUSH
65764: LD_INT 57
65766: PUSH
65767: LD_INT 58
65769: PUSH
65770: LD_INT 59
65772: PUSH
65773: LD_INT 63
65775: PUSH
65776: LD_INT 64
65778: PUSH
65779: LD_INT 65
65781: PUSH
65782: LD_INT 82
65784: PUSH
65785: LD_INT 83
65787: PUSH
65788: LD_INT 84
65790: PUSH
65791: LD_INT 85
65793: PUSH
65794: LD_INT 86
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: ST_TO_ADDR
65852: GO 65855
65854: POP
// if state > - 1 and state < 3 then
65855: LD_VAR 0 3
65859: PUSH
65860: LD_INT 1
65862: NEG
65863: GREATER
65864: PUSH
65865: LD_VAR 0 3
65869: PUSH
65870: LD_INT 3
65872: LESS
65873: AND
65874: IFFALSE 65931
// for i in result do
65876: LD_ADDR_VAR 0 5
65880: PUSH
65881: LD_VAR 0 4
65885: PUSH
65886: FOR_IN
65887: IFFALSE 65929
// if GetTech ( i , side ) <> state then
65889: LD_VAR 0 5
65893: PPUSH
65894: LD_VAR 0 1
65898: PPUSH
65899: CALL_OW 321
65903: PUSH
65904: LD_VAR 0 3
65908: NONEQUAL
65909: IFFALSE 65927
// result := result diff i ;
65911: LD_ADDR_VAR 0 4
65915: PUSH
65916: LD_VAR 0 4
65920: PUSH
65921: LD_VAR 0 5
65925: DIFF
65926: ST_TO_ADDR
65927: GO 65886
65929: POP
65930: POP
// end ;
65931: LD_VAR 0 4
65935: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65936: LD_INT 0
65938: PPUSH
65939: PPUSH
65940: PPUSH
// result := true ;
65941: LD_ADDR_VAR 0 3
65945: PUSH
65946: LD_INT 1
65948: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65949: LD_ADDR_VAR 0 5
65953: PUSH
65954: LD_VAR 0 2
65958: PPUSH
65959: CALL_OW 480
65963: ST_TO_ADDR
// if not tmp then
65964: LD_VAR 0 5
65968: NOT
65969: IFFALSE 65973
// exit ;
65971: GO 66022
// for i in tmp do
65973: LD_ADDR_VAR 0 4
65977: PUSH
65978: LD_VAR 0 5
65982: PUSH
65983: FOR_IN
65984: IFFALSE 66020
// if GetTech ( i , side ) <> state_researched then
65986: LD_VAR 0 4
65990: PPUSH
65991: LD_VAR 0 1
65995: PPUSH
65996: CALL_OW 321
66000: PUSH
66001: LD_INT 2
66003: NONEQUAL
66004: IFFALSE 66018
// begin result := false ;
66006: LD_ADDR_VAR 0 3
66010: PUSH
66011: LD_INT 0
66013: ST_TO_ADDR
// exit ;
66014: POP
66015: POP
66016: GO 66022
// end ;
66018: GO 65983
66020: POP
66021: POP
// end ;
66022: LD_VAR 0 3
66026: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66027: LD_INT 0
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
66034: PPUSH
66035: PPUSH
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
66041: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66042: LD_VAR 0 1
66046: NOT
66047: PUSH
66048: LD_VAR 0 1
66052: PPUSH
66053: CALL_OW 257
66057: PUSH
66058: LD_INT 9
66060: NONEQUAL
66061: OR
66062: IFFALSE 66066
// exit ;
66064: GO 66639
// side := GetSide ( unit ) ;
66066: LD_ADDR_VAR 0 9
66070: PUSH
66071: LD_VAR 0 1
66075: PPUSH
66076: CALL_OW 255
66080: ST_TO_ADDR
// tech_space := tech_spacanom ;
66081: LD_ADDR_VAR 0 12
66085: PUSH
66086: LD_INT 29
66088: ST_TO_ADDR
// tech_time := tech_taurad ;
66089: LD_ADDR_VAR 0 13
66093: PUSH
66094: LD_INT 28
66096: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66097: LD_ADDR_VAR 0 11
66101: PUSH
66102: LD_VAR 0 1
66106: PPUSH
66107: CALL_OW 310
66111: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66112: LD_VAR 0 11
66116: PPUSH
66117: CALL_OW 247
66121: PUSH
66122: LD_INT 2
66124: EQUAL
66125: IFFALSE 66129
// exit ;
66127: GO 66639
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66129: LD_ADDR_VAR 0 8
66133: PUSH
66134: LD_INT 81
66136: PUSH
66137: LD_VAR 0 9
66141: PUSH
66142: EMPTY
66143: LIST
66144: LIST
66145: PUSH
66146: LD_INT 3
66148: PUSH
66149: LD_INT 21
66151: PUSH
66152: LD_INT 3
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PPUSH
66167: CALL_OW 69
66171: ST_TO_ADDR
// if not tmp then
66172: LD_VAR 0 8
66176: NOT
66177: IFFALSE 66181
// exit ;
66179: GO 66639
// if in_unit then
66181: LD_VAR 0 11
66185: IFFALSE 66209
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66187: LD_ADDR_VAR 0 10
66191: PUSH
66192: LD_VAR 0 8
66196: PPUSH
66197: LD_VAR 0 11
66201: PPUSH
66202: CALL_OW 74
66206: ST_TO_ADDR
66207: GO 66229
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66209: LD_ADDR_VAR 0 10
66213: PUSH
66214: LD_VAR 0 8
66218: PPUSH
66219: LD_VAR 0 1
66223: PPUSH
66224: CALL_OW 74
66228: ST_TO_ADDR
// if not enemy then
66229: LD_VAR 0 10
66233: NOT
66234: IFFALSE 66238
// exit ;
66236: GO 66639
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66238: LD_VAR 0 11
66242: PUSH
66243: LD_VAR 0 11
66247: PPUSH
66248: LD_VAR 0 10
66252: PPUSH
66253: CALL_OW 296
66257: PUSH
66258: LD_INT 13
66260: GREATER
66261: AND
66262: PUSH
66263: LD_VAR 0 1
66267: PPUSH
66268: LD_VAR 0 10
66272: PPUSH
66273: CALL_OW 296
66277: PUSH
66278: LD_INT 12
66280: GREATER
66281: OR
66282: IFFALSE 66286
// exit ;
66284: GO 66639
// missile := [ 1 ] ;
66286: LD_ADDR_VAR 0 14
66290: PUSH
66291: LD_INT 1
66293: PUSH
66294: EMPTY
66295: LIST
66296: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66297: LD_VAR 0 9
66301: PPUSH
66302: LD_VAR 0 12
66306: PPUSH
66307: CALL_OW 325
66311: IFFALSE 66340
// missile := Insert ( missile , missile + 1 , 2 ) ;
66313: LD_ADDR_VAR 0 14
66317: PUSH
66318: LD_VAR 0 14
66322: PPUSH
66323: LD_VAR 0 14
66327: PUSH
66328: LD_INT 1
66330: PLUS
66331: PPUSH
66332: LD_INT 2
66334: PPUSH
66335: CALL_OW 2
66339: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66340: LD_VAR 0 9
66344: PPUSH
66345: LD_VAR 0 13
66349: PPUSH
66350: CALL_OW 325
66354: PUSH
66355: LD_VAR 0 10
66359: PPUSH
66360: CALL_OW 255
66364: PPUSH
66365: LD_VAR 0 13
66369: PPUSH
66370: CALL_OW 325
66374: NOT
66375: AND
66376: IFFALSE 66405
// missile := Insert ( missile , missile + 1 , 3 ) ;
66378: LD_ADDR_VAR 0 14
66382: PUSH
66383: LD_VAR 0 14
66387: PPUSH
66388: LD_VAR 0 14
66392: PUSH
66393: LD_INT 1
66395: PLUS
66396: PPUSH
66397: LD_INT 3
66399: PPUSH
66400: CALL_OW 2
66404: ST_TO_ADDR
// if missile < 2 then
66405: LD_VAR 0 14
66409: PUSH
66410: LD_INT 2
66412: LESS
66413: IFFALSE 66417
// exit ;
66415: GO 66639
// x := GetX ( enemy ) ;
66417: LD_ADDR_VAR 0 4
66421: PUSH
66422: LD_VAR 0 10
66426: PPUSH
66427: CALL_OW 250
66431: ST_TO_ADDR
// y := GetY ( enemy ) ;
66432: LD_ADDR_VAR 0 5
66436: PUSH
66437: LD_VAR 0 10
66441: PPUSH
66442: CALL_OW 251
66446: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66447: LD_ADDR_VAR 0 6
66451: PUSH
66452: LD_VAR 0 4
66456: PUSH
66457: LD_INT 1
66459: NEG
66460: PPUSH
66461: LD_INT 1
66463: PPUSH
66464: CALL_OW 12
66468: PLUS
66469: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66470: LD_ADDR_VAR 0 7
66474: PUSH
66475: LD_VAR 0 5
66479: PUSH
66480: LD_INT 1
66482: NEG
66483: PPUSH
66484: LD_INT 1
66486: PPUSH
66487: CALL_OW 12
66491: PLUS
66492: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66493: LD_VAR 0 6
66497: PPUSH
66498: LD_VAR 0 7
66502: PPUSH
66503: CALL_OW 488
66507: NOT
66508: IFFALSE 66530
// begin _x := x ;
66510: LD_ADDR_VAR 0 6
66514: PUSH
66515: LD_VAR 0 4
66519: ST_TO_ADDR
// _y := y ;
66520: LD_ADDR_VAR 0 7
66524: PUSH
66525: LD_VAR 0 5
66529: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66530: LD_ADDR_VAR 0 3
66534: PUSH
66535: LD_INT 1
66537: PPUSH
66538: LD_VAR 0 14
66542: PPUSH
66543: CALL_OW 12
66547: ST_TO_ADDR
// case i of 1 :
66548: LD_VAR 0 3
66552: PUSH
66553: LD_INT 1
66555: DOUBLE
66556: EQUAL
66557: IFTRUE 66561
66559: GO 66578
66561: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66562: LD_VAR 0 1
66566: PPUSH
66567: LD_VAR 0 10
66571: PPUSH
66572: CALL_OW 115
66576: GO 66639
66578: LD_INT 2
66580: DOUBLE
66581: EQUAL
66582: IFTRUE 66586
66584: GO 66608
66586: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66587: LD_VAR 0 1
66591: PPUSH
66592: LD_VAR 0 6
66596: PPUSH
66597: LD_VAR 0 7
66601: PPUSH
66602: CALL_OW 153
66606: GO 66639
66608: LD_INT 3
66610: DOUBLE
66611: EQUAL
66612: IFTRUE 66616
66614: GO 66638
66616: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66617: LD_VAR 0 1
66621: PPUSH
66622: LD_VAR 0 6
66626: PPUSH
66627: LD_VAR 0 7
66631: PPUSH
66632: CALL_OW 154
66636: GO 66639
66638: POP
// end ;
66639: LD_VAR 0 2
66643: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66644: LD_INT 0
66646: PPUSH
66647: PPUSH
66648: PPUSH
66649: PPUSH
66650: PPUSH
66651: PPUSH
// if not unit or not building then
66652: LD_VAR 0 1
66656: NOT
66657: PUSH
66658: LD_VAR 0 2
66662: NOT
66663: OR
66664: IFFALSE 66668
// exit ;
66666: GO 66826
// x := GetX ( building ) ;
66668: LD_ADDR_VAR 0 5
66672: PUSH
66673: LD_VAR 0 2
66677: PPUSH
66678: CALL_OW 250
66682: ST_TO_ADDR
// y := GetY ( building ) ;
66683: LD_ADDR_VAR 0 6
66687: PUSH
66688: LD_VAR 0 2
66692: PPUSH
66693: CALL_OW 251
66697: ST_TO_ADDR
// for i = 0 to 5 do
66698: LD_ADDR_VAR 0 4
66702: PUSH
66703: DOUBLE
66704: LD_INT 0
66706: DEC
66707: ST_TO_ADDR
66708: LD_INT 5
66710: PUSH
66711: FOR_TO
66712: IFFALSE 66824
// begin _x := ShiftX ( x , i , 3 ) ;
66714: LD_ADDR_VAR 0 7
66718: PUSH
66719: LD_VAR 0 5
66723: PPUSH
66724: LD_VAR 0 4
66728: PPUSH
66729: LD_INT 3
66731: PPUSH
66732: CALL_OW 272
66736: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66737: LD_ADDR_VAR 0 8
66741: PUSH
66742: LD_VAR 0 6
66746: PPUSH
66747: LD_VAR 0 4
66751: PPUSH
66752: LD_INT 3
66754: PPUSH
66755: CALL_OW 273
66759: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66760: LD_VAR 0 7
66764: PPUSH
66765: LD_VAR 0 8
66769: PPUSH
66770: CALL_OW 488
66774: NOT
66775: IFFALSE 66779
// continue ;
66777: GO 66711
// if HexInfo ( _x , _y ) = 0 then
66779: LD_VAR 0 7
66783: PPUSH
66784: LD_VAR 0 8
66788: PPUSH
66789: CALL_OW 428
66793: PUSH
66794: LD_INT 0
66796: EQUAL
66797: IFFALSE 66822
// begin ComMoveXY ( unit , _x , _y ) ;
66799: LD_VAR 0 1
66803: PPUSH
66804: LD_VAR 0 7
66808: PPUSH
66809: LD_VAR 0 8
66813: PPUSH
66814: CALL_OW 111
// exit ;
66818: POP
66819: POP
66820: GO 66826
// end ; end ;
66822: GO 66711
66824: POP
66825: POP
// end ;
66826: LD_VAR 0 3
66830: RET
// export function ScanBase ( side , base_area ) ; begin
66831: LD_INT 0
66833: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66834: LD_ADDR_VAR 0 3
66838: PUSH
66839: LD_VAR 0 2
66843: PPUSH
66844: LD_INT 81
66846: PUSH
66847: LD_VAR 0 1
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PPUSH
66856: CALL_OW 70
66860: ST_TO_ADDR
// end ;
66861: LD_VAR 0 3
66865: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66866: LD_INT 0
66868: PPUSH
66869: PPUSH
66870: PPUSH
66871: PPUSH
// result := false ;
66872: LD_ADDR_VAR 0 2
66876: PUSH
66877: LD_INT 0
66879: ST_TO_ADDR
// side := GetSide ( unit ) ;
66880: LD_ADDR_VAR 0 3
66884: PUSH
66885: LD_VAR 0 1
66889: PPUSH
66890: CALL_OW 255
66894: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66895: LD_ADDR_VAR 0 4
66899: PUSH
66900: LD_VAR 0 1
66904: PPUSH
66905: CALL_OW 248
66909: ST_TO_ADDR
// case nat of 1 :
66910: LD_VAR 0 4
66914: PUSH
66915: LD_INT 1
66917: DOUBLE
66918: EQUAL
66919: IFTRUE 66923
66921: GO 66934
66923: POP
// tech := tech_lassight ; 2 :
66924: LD_ADDR_VAR 0 5
66928: PUSH
66929: LD_INT 12
66931: ST_TO_ADDR
66932: GO 66973
66934: LD_INT 2
66936: DOUBLE
66937: EQUAL
66938: IFTRUE 66942
66940: GO 66953
66942: POP
// tech := tech_mortar ; 3 :
66943: LD_ADDR_VAR 0 5
66947: PUSH
66948: LD_INT 41
66950: ST_TO_ADDR
66951: GO 66973
66953: LD_INT 3
66955: DOUBLE
66956: EQUAL
66957: IFTRUE 66961
66959: GO 66972
66961: POP
// tech := tech_bazooka ; end ;
66962: LD_ADDR_VAR 0 5
66966: PUSH
66967: LD_INT 44
66969: ST_TO_ADDR
66970: GO 66973
66972: POP
// if Researched ( side , tech ) then
66973: LD_VAR 0 3
66977: PPUSH
66978: LD_VAR 0 5
66982: PPUSH
66983: CALL_OW 325
66987: IFFALSE 67014
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66989: LD_ADDR_VAR 0 2
66993: PUSH
66994: LD_INT 5
66996: PUSH
66997: LD_INT 8
66999: PUSH
67000: LD_INT 9
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: LIST
67007: PUSH
67008: LD_VAR 0 4
67012: ARRAY
67013: ST_TO_ADDR
// end ;
67014: LD_VAR 0 2
67018: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67019: LD_INT 0
67021: PPUSH
67022: PPUSH
67023: PPUSH
// if not mines then
67024: LD_VAR 0 2
67028: NOT
67029: IFFALSE 67033
// exit ;
67031: GO 67177
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67033: LD_ADDR_VAR 0 5
67037: PUSH
67038: LD_INT 81
67040: PUSH
67041: LD_VAR 0 1
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 3
67052: PUSH
67053: LD_INT 21
67055: PUSH
67056: LD_INT 3
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PPUSH
67071: CALL_OW 69
67075: ST_TO_ADDR
// for i in mines do
67076: LD_ADDR_VAR 0 4
67080: PUSH
67081: LD_VAR 0 2
67085: PUSH
67086: FOR_IN
67087: IFFALSE 67175
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67089: LD_VAR 0 4
67093: PUSH
67094: LD_INT 1
67096: ARRAY
67097: PPUSH
67098: LD_VAR 0 4
67102: PUSH
67103: LD_INT 2
67105: ARRAY
67106: PPUSH
67107: CALL_OW 458
67111: NOT
67112: IFFALSE 67116
// continue ;
67114: GO 67086
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67116: LD_VAR 0 4
67120: PUSH
67121: LD_INT 1
67123: ARRAY
67124: PPUSH
67125: LD_VAR 0 4
67129: PUSH
67130: LD_INT 2
67132: ARRAY
67133: PPUSH
67134: CALL_OW 428
67138: PUSH
67139: LD_VAR 0 5
67143: IN
67144: IFFALSE 67173
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67146: LD_VAR 0 4
67150: PUSH
67151: LD_INT 1
67153: ARRAY
67154: PPUSH
67155: LD_VAR 0 4
67159: PUSH
67160: LD_INT 2
67162: ARRAY
67163: PPUSH
67164: LD_VAR 0 1
67168: PPUSH
67169: CALL_OW 456
// end ;
67173: GO 67086
67175: POP
67176: POP
// end ;
67177: LD_VAR 0 3
67181: RET
// export function Count ( array ) ; var i ; begin
67182: LD_INT 0
67184: PPUSH
67185: PPUSH
// result := 0 ;
67186: LD_ADDR_VAR 0 2
67190: PUSH
67191: LD_INT 0
67193: ST_TO_ADDR
// for i in array do
67194: LD_ADDR_VAR 0 3
67198: PUSH
67199: LD_VAR 0 1
67203: PUSH
67204: FOR_IN
67205: IFFALSE 67229
// if i then
67207: LD_VAR 0 3
67211: IFFALSE 67227
// result := result + 1 ;
67213: LD_ADDR_VAR 0 2
67217: PUSH
67218: LD_VAR 0 2
67222: PUSH
67223: LD_INT 1
67225: PLUS
67226: ST_TO_ADDR
67227: GO 67204
67229: POP
67230: POP
// end ;
67231: LD_VAR 0 2
67235: RET
// export function IsEmpty ( building ) ; begin
67236: LD_INT 0
67238: PPUSH
// if not building then
67239: LD_VAR 0 1
67243: NOT
67244: IFFALSE 67248
// exit ;
67246: GO 67291
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67248: LD_ADDR_VAR 0 2
67252: PUSH
67253: LD_VAR 0 1
67257: PUSH
67258: LD_INT 22
67260: PUSH
67261: LD_VAR 0 1
67265: PPUSH
67266: CALL_OW 255
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 58
67277: PUSH
67278: EMPTY
67279: LIST
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PPUSH
67285: CALL_OW 69
67289: IN
67290: ST_TO_ADDR
// end ;
67291: LD_VAR 0 2
67295: RET
// export function IsNotFull ( building ) ; begin
67296: LD_INT 0
67298: PPUSH
// if not building then
67299: LD_VAR 0 1
67303: NOT
67304: IFFALSE 67308
// exit ;
67306: GO 67327
// result := UnitsInside ( building ) < 6 ;
67308: LD_ADDR_VAR 0 2
67312: PUSH
67313: LD_VAR 0 1
67317: PPUSH
67318: CALL_OW 313
67322: PUSH
67323: LD_INT 6
67325: LESS
67326: ST_TO_ADDR
// end ;
67327: LD_VAR 0 2
67331: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67332: LD_INT 0
67334: PPUSH
67335: PPUSH
67336: PPUSH
67337: PPUSH
// tmp := [ ] ;
67338: LD_ADDR_VAR 0 3
67342: PUSH
67343: EMPTY
67344: ST_TO_ADDR
// list := [ ] ;
67345: LD_ADDR_VAR 0 5
67349: PUSH
67350: EMPTY
67351: ST_TO_ADDR
// for i = 16 to 25 do
67352: LD_ADDR_VAR 0 4
67356: PUSH
67357: DOUBLE
67358: LD_INT 16
67360: DEC
67361: ST_TO_ADDR
67362: LD_INT 25
67364: PUSH
67365: FOR_TO
67366: IFFALSE 67439
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67368: LD_ADDR_VAR 0 3
67372: PUSH
67373: LD_VAR 0 3
67377: PUSH
67378: LD_INT 22
67380: PUSH
67381: LD_VAR 0 1
67385: PPUSH
67386: CALL_OW 255
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 91
67397: PUSH
67398: LD_VAR 0 1
67402: PUSH
67403: LD_INT 6
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 30
67413: PUSH
67414: LD_VAR 0 4
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: LIST
67427: PUSH
67428: EMPTY
67429: LIST
67430: PPUSH
67431: CALL_OW 69
67435: ADD
67436: ST_TO_ADDR
67437: GO 67365
67439: POP
67440: POP
// for i = 1 to tmp do
67441: LD_ADDR_VAR 0 4
67445: PUSH
67446: DOUBLE
67447: LD_INT 1
67449: DEC
67450: ST_TO_ADDR
67451: LD_VAR 0 3
67455: PUSH
67456: FOR_TO
67457: IFFALSE 67545
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67459: LD_ADDR_VAR 0 5
67463: PUSH
67464: LD_VAR 0 5
67468: PUSH
67469: LD_VAR 0 3
67473: PUSH
67474: LD_VAR 0 4
67478: ARRAY
67479: PPUSH
67480: CALL_OW 266
67484: PUSH
67485: LD_VAR 0 3
67489: PUSH
67490: LD_VAR 0 4
67494: ARRAY
67495: PPUSH
67496: CALL_OW 250
67500: PUSH
67501: LD_VAR 0 3
67505: PUSH
67506: LD_VAR 0 4
67510: ARRAY
67511: PPUSH
67512: CALL_OW 251
67516: PUSH
67517: LD_VAR 0 3
67521: PUSH
67522: LD_VAR 0 4
67526: ARRAY
67527: PPUSH
67528: CALL_OW 254
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: PUSH
67539: EMPTY
67540: LIST
67541: ADD
67542: ST_TO_ADDR
67543: GO 67456
67545: POP
67546: POP
// result := list ;
67547: LD_ADDR_VAR 0 2
67551: PUSH
67552: LD_VAR 0 5
67556: ST_TO_ADDR
// end ;
67557: LD_VAR 0 2
67561: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67562: LD_INT 0
67564: PPUSH
67565: PPUSH
67566: PPUSH
67567: PPUSH
67568: PPUSH
67569: PPUSH
67570: PPUSH
// if not factory then
67571: LD_VAR 0 1
67575: NOT
67576: IFFALSE 67580
// exit ;
67578: GO 68173
// if control = control_apeman then
67580: LD_VAR 0 4
67584: PUSH
67585: LD_INT 5
67587: EQUAL
67588: IFFALSE 67697
// begin tmp := UnitsInside ( factory ) ;
67590: LD_ADDR_VAR 0 8
67594: PUSH
67595: LD_VAR 0 1
67599: PPUSH
67600: CALL_OW 313
67604: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67605: LD_VAR 0 8
67609: PPUSH
67610: LD_INT 25
67612: PUSH
67613: LD_INT 12
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PPUSH
67620: CALL_OW 72
67624: NOT
67625: IFFALSE 67635
// control := control_manual ;
67627: LD_ADDR_VAR 0 4
67631: PUSH
67632: LD_INT 1
67634: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67635: LD_ADDR_VAR 0 8
67639: PUSH
67640: LD_VAR 0 1
67644: PPUSH
67645: CALL 67332 0 1
67649: ST_TO_ADDR
// if tmp then
67650: LD_VAR 0 8
67654: IFFALSE 67697
// begin for i in tmp do
67656: LD_ADDR_VAR 0 7
67660: PUSH
67661: LD_VAR 0 8
67665: PUSH
67666: FOR_IN
67667: IFFALSE 67695
// if i [ 1 ] = b_ext_radio then
67669: LD_VAR 0 7
67673: PUSH
67674: LD_INT 1
67676: ARRAY
67677: PUSH
67678: LD_INT 22
67680: EQUAL
67681: IFFALSE 67693
// begin control := control_remote ;
67683: LD_ADDR_VAR 0 4
67687: PUSH
67688: LD_INT 2
67690: ST_TO_ADDR
// break ;
67691: GO 67695
// end ;
67693: GO 67666
67695: POP
67696: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67697: LD_VAR 0 1
67701: PPUSH
67702: LD_VAR 0 2
67706: PPUSH
67707: LD_VAR 0 3
67711: PPUSH
67712: LD_VAR 0 4
67716: PPUSH
67717: LD_VAR 0 5
67721: PPUSH
67722: CALL_OW 448
67726: IFFALSE 67761
// begin result := [ chassis , engine , control , weapon ] ;
67728: LD_ADDR_VAR 0 6
67732: PUSH
67733: LD_VAR 0 2
67737: PUSH
67738: LD_VAR 0 3
67742: PUSH
67743: LD_VAR 0 4
67747: PUSH
67748: LD_VAR 0 5
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: ST_TO_ADDR
// exit ;
67759: GO 68173
// end ; _chassis := AvailableChassisList ( factory ) ;
67761: LD_ADDR_VAR 0 9
67765: PUSH
67766: LD_VAR 0 1
67770: PPUSH
67771: CALL_OW 475
67775: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67776: LD_ADDR_VAR 0 11
67780: PUSH
67781: LD_VAR 0 1
67785: PPUSH
67786: CALL_OW 476
67790: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67791: LD_ADDR_VAR 0 12
67795: PUSH
67796: LD_VAR 0 1
67800: PPUSH
67801: CALL_OW 477
67805: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67806: LD_ADDR_VAR 0 10
67810: PUSH
67811: LD_VAR 0 1
67815: PPUSH
67816: CALL_OW 478
67820: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67821: LD_VAR 0 9
67825: NOT
67826: PUSH
67827: LD_VAR 0 11
67831: NOT
67832: OR
67833: PUSH
67834: LD_VAR 0 12
67838: NOT
67839: OR
67840: PUSH
67841: LD_VAR 0 10
67845: NOT
67846: OR
67847: IFFALSE 67882
// begin result := [ chassis , engine , control , weapon ] ;
67849: LD_ADDR_VAR 0 6
67853: PUSH
67854: LD_VAR 0 2
67858: PUSH
67859: LD_VAR 0 3
67863: PUSH
67864: LD_VAR 0 4
67868: PUSH
67869: LD_VAR 0 5
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: ST_TO_ADDR
// exit ;
67880: GO 68173
// end ; if not chassis in _chassis then
67882: LD_VAR 0 2
67886: PUSH
67887: LD_VAR 0 9
67891: IN
67892: NOT
67893: IFFALSE 67919
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67895: LD_ADDR_VAR 0 2
67899: PUSH
67900: LD_VAR 0 9
67904: PUSH
67905: LD_INT 1
67907: PPUSH
67908: LD_VAR 0 9
67912: PPUSH
67913: CALL_OW 12
67917: ARRAY
67918: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67919: LD_VAR 0 2
67923: PPUSH
67924: LD_VAR 0 3
67928: PPUSH
67929: CALL 68178 0 2
67933: NOT
67934: IFFALSE 67993
// repeat engine := _engine [ 1 ] ;
67936: LD_ADDR_VAR 0 3
67940: PUSH
67941: LD_VAR 0 11
67945: PUSH
67946: LD_INT 1
67948: ARRAY
67949: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67950: LD_ADDR_VAR 0 11
67954: PUSH
67955: LD_VAR 0 11
67959: PPUSH
67960: LD_INT 1
67962: PPUSH
67963: CALL_OW 3
67967: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67968: LD_VAR 0 2
67972: PPUSH
67973: LD_VAR 0 3
67977: PPUSH
67978: CALL 68178 0 2
67982: PUSH
67983: LD_VAR 0 11
67987: PUSH
67988: EMPTY
67989: EQUAL
67990: OR
67991: IFFALSE 67936
// if not control in _control then
67993: LD_VAR 0 4
67997: PUSH
67998: LD_VAR 0 12
68002: IN
68003: NOT
68004: IFFALSE 68030
// control := _control [ rand ( 1 , _control ) ] ;
68006: LD_ADDR_VAR 0 4
68010: PUSH
68011: LD_VAR 0 12
68015: PUSH
68016: LD_INT 1
68018: PPUSH
68019: LD_VAR 0 12
68023: PPUSH
68024: CALL_OW 12
68028: ARRAY
68029: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68030: LD_VAR 0 2
68034: PPUSH
68035: LD_VAR 0 5
68039: PPUSH
68040: CALL 68398 0 2
68044: NOT
68045: IFFALSE 68104
// repeat weapon := _weapon [ 1 ] ;
68047: LD_ADDR_VAR 0 5
68051: PUSH
68052: LD_VAR 0 10
68056: PUSH
68057: LD_INT 1
68059: ARRAY
68060: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68061: LD_ADDR_VAR 0 10
68065: PUSH
68066: LD_VAR 0 10
68070: PPUSH
68071: LD_INT 1
68073: PPUSH
68074: CALL_OW 3
68078: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68079: LD_VAR 0 2
68083: PPUSH
68084: LD_VAR 0 5
68088: PPUSH
68089: CALL 68398 0 2
68093: PUSH
68094: LD_VAR 0 10
68098: PUSH
68099: EMPTY
68100: EQUAL
68101: OR
68102: IFFALSE 68047
// result := [ ] ;
68104: LD_ADDR_VAR 0 6
68108: PUSH
68109: EMPTY
68110: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68111: LD_VAR 0 1
68115: PPUSH
68116: LD_VAR 0 2
68120: PPUSH
68121: LD_VAR 0 3
68125: PPUSH
68126: LD_VAR 0 4
68130: PPUSH
68131: LD_VAR 0 5
68135: PPUSH
68136: CALL_OW 448
68140: IFFALSE 68173
// result := [ chassis , engine , control , weapon ] ;
68142: LD_ADDR_VAR 0 6
68146: PUSH
68147: LD_VAR 0 2
68151: PUSH
68152: LD_VAR 0 3
68156: PUSH
68157: LD_VAR 0 4
68161: PUSH
68162: LD_VAR 0 5
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: ST_TO_ADDR
// end ;
68173: LD_VAR 0 6
68177: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68178: LD_INT 0
68180: PPUSH
// if not chassis or not engine then
68181: LD_VAR 0 1
68185: NOT
68186: PUSH
68187: LD_VAR 0 2
68191: NOT
68192: OR
68193: IFFALSE 68197
// exit ;
68195: GO 68393
// case engine of engine_solar :
68197: LD_VAR 0 2
68201: PUSH
68202: LD_INT 2
68204: DOUBLE
68205: EQUAL
68206: IFTRUE 68210
68208: GO 68248
68210: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68211: LD_ADDR_VAR 0 3
68215: PUSH
68216: LD_INT 11
68218: PUSH
68219: LD_INT 12
68221: PUSH
68222: LD_INT 13
68224: PUSH
68225: LD_INT 14
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 2
68233: PUSH
68234: LD_INT 3
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: ST_TO_ADDR
68246: GO 68377
68248: LD_INT 1
68250: DOUBLE
68251: EQUAL
68252: IFTRUE 68256
68254: GO 68318
68256: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68257: LD_ADDR_VAR 0 3
68261: PUSH
68262: LD_INT 11
68264: PUSH
68265: LD_INT 12
68267: PUSH
68268: LD_INT 13
68270: PUSH
68271: LD_INT 14
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 3
68282: PUSH
68283: LD_INT 4
68285: PUSH
68286: LD_INT 5
68288: PUSH
68289: LD_INT 21
68291: PUSH
68292: LD_INT 23
68294: PUSH
68295: LD_INT 22
68297: PUSH
68298: LD_INT 24
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: ST_TO_ADDR
68316: GO 68377
68318: LD_INT 3
68320: DOUBLE
68321: EQUAL
68322: IFTRUE 68326
68324: GO 68376
68326: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68327: LD_ADDR_VAR 0 3
68331: PUSH
68332: LD_INT 13
68334: PUSH
68335: LD_INT 14
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: LD_INT 3
68343: PUSH
68344: LD_INT 4
68346: PUSH
68347: LD_INT 5
68349: PUSH
68350: LD_INT 21
68352: PUSH
68353: LD_INT 22
68355: PUSH
68356: LD_INT 23
68358: PUSH
68359: LD_INT 24
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: LIST
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: LIST
68371: LIST
68372: LIST
68373: ST_TO_ADDR
68374: GO 68377
68376: POP
// result := ( chassis in result ) ;
68377: LD_ADDR_VAR 0 3
68381: PUSH
68382: LD_VAR 0 1
68386: PUSH
68387: LD_VAR 0 3
68391: IN
68392: ST_TO_ADDR
// end ;
68393: LD_VAR 0 3
68397: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68398: LD_INT 0
68400: PPUSH
// if not chassis or not weapon then
68401: LD_VAR 0 1
68405: NOT
68406: PUSH
68407: LD_VAR 0 2
68411: NOT
68412: OR
68413: IFFALSE 68417
// exit ;
68415: GO 69443
// case weapon of us_machine_gun :
68417: LD_VAR 0 2
68421: PUSH
68422: LD_INT 2
68424: DOUBLE
68425: EQUAL
68426: IFTRUE 68430
68428: GO 68460
68430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68431: LD_ADDR_VAR 0 3
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: LD_INT 2
68441: PUSH
68442: LD_INT 3
68444: PUSH
68445: LD_INT 4
68447: PUSH
68448: LD_INT 5
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: ST_TO_ADDR
68458: GO 69427
68460: LD_INT 3
68462: DOUBLE
68463: EQUAL
68464: IFTRUE 68468
68466: GO 68498
68468: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68469: LD_ADDR_VAR 0 3
68473: PUSH
68474: LD_INT 1
68476: PUSH
68477: LD_INT 2
68479: PUSH
68480: LD_INT 3
68482: PUSH
68483: LD_INT 4
68485: PUSH
68486: LD_INT 5
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: ST_TO_ADDR
68496: GO 69427
68498: LD_INT 11
68500: DOUBLE
68501: EQUAL
68502: IFTRUE 68506
68504: GO 68536
68506: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68507: LD_ADDR_VAR 0 3
68511: PUSH
68512: LD_INT 1
68514: PUSH
68515: LD_INT 2
68517: PUSH
68518: LD_INT 3
68520: PUSH
68521: LD_INT 4
68523: PUSH
68524: LD_INT 5
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: ST_TO_ADDR
68534: GO 69427
68536: LD_INT 4
68538: DOUBLE
68539: EQUAL
68540: IFTRUE 68544
68542: GO 68570
68544: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68545: LD_ADDR_VAR 0 3
68549: PUSH
68550: LD_INT 2
68552: PUSH
68553: LD_INT 3
68555: PUSH
68556: LD_INT 4
68558: PUSH
68559: LD_INT 5
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: ST_TO_ADDR
68568: GO 69427
68570: LD_INT 5
68572: DOUBLE
68573: EQUAL
68574: IFTRUE 68578
68576: GO 68604
68578: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68579: LD_ADDR_VAR 0 3
68583: PUSH
68584: LD_INT 2
68586: PUSH
68587: LD_INT 3
68589: PUSH
68590: LD_INT 4
68592: PUSH
68593: LD_INT 5
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: ST_TO_ADDR
68602: GO 69427
68604: LD_INT 9
68606: DOUBLE
68607: EQUAL
68608: IFTRUE 68612
68610: GO 68638
68612: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68613: LD_ADDR_VAR 0 3
68617: PUSH
68618: LD_INT 2
68620: PUSH
68621: LD_INT 3
68623: PUSH
68624: LD_INT 4
68626: PUSH
68627: LD_INT 5
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: ST_TO_ADDR
68636: GO 69427
68638: LD_INT 7
68640: DOUBLE
68641: EQUAL
68642: IFTRUE 68646
68644: GO 68672
68646: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68647: LD_ADDR_VAR 0 3
68651: PUSH
68652: LD_INT 2
68654: PUSH
68655: LD_INT 3
68657: PUSH
68658: LD_INT 4
68660: PUSH
68661: LD_INT 5
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: ST_TO_ADDR
68670: GO 69427
68672: LD_INT 12
68674: DOUBLE
68675: EQUAL
68676: IFTRUE 68680
68678: GO 68706
68680: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68681: LD_ADDR_VAR 0 3
68685: PUSH
68686: LD_INT 2
68688: PUSH
68689: LD_INT 3
68691: PUSH
68692: LD_INT 4
68694: PUSH
68695: LD_INT 5
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: ST_TO_ADDR
68704: GO 69427
68706: LD_INT 13
68708: DOUBLE
68709: EQUAL
68710: IFTRUE 68714
68712: GO 68740
68714: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68715: LD_ADDR_VAR 0 3
68719: PUSH
68720: LD_INT 2
68722: PUSH
68723: LD_INT 3
68725: PUSH
68726: LD_INT 4
68728: PUSH
68729: LD_INT 5
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: ST_TO_ADDR
68738: GO 69427
68740: LD_INT 14
68742: DOUBLE
68743: EQUAL
68744: IFTRUE 68748
68746: GO 68766
68748: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68749: LD_ADDR_VAR 0 3
68753: PUSH
68754: LD_INT 4
68756: PUSH
68757: LD_INT 5
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: ST_TO_ADDR
68764: GO 69427
68766: LD_INT 6
68768: DOUBLE
68769: EQUAL
68770: IFTRUE 68774
68772: GO 68792
68774: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68775: LD_ADDR_VAR 0 3
68779: PUSH
68780: LD_INT 4
68782: PUSH
68783: LD_INT 5
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: ST_TO_ADDR
68790: GO 69427
68792: LD_INT 10
68794: DOUBLE
68795: EQUAL
68796: IFTRUE 68800
68798: GO 68818
68800: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68801: LD_ADDR_VAR 0 3
68805: PUSH
68806: LD_INT 4
68808: PUSH
68809: LD_INT 5
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: ST_TO_ADDR
68816: GO 69427
68818: LD_INT 22
68820: DOUBLE
68821: EQUAL
68822: IFTRUE 68826
68824: GO 68852
68826: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68827: LD_ADDR_VAR 0 3
68831: PUSH
68832: LD_INT 11
68834: PUSH
68835: LD_INT 12
68837: PUSH
68838: LD_INT 13
68840: PUSH
68841: LD_INT 14
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: ST_TO_ADDR
68850: GO 69427
68852: LD_INT 23
68854: DOUBLE
68855: EQUAL
68856: IFTRUE 68860
68858: GO 68886
68860: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68861: LD_ADDR_VAR 0 3
68865: PUSH
68866: LD_INT 11
68868: PUSH
68869: LD_INT 12
68871: PUSH
68872: LD_INT 13
68874: PUSH
68875: LD_INT 14
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: ST_TO_ADDR
68884: GO 69427
68886: LD_INT 24
68888: DOUBLE
68889: EQUAL
68890: IFTRUE 68894
68892: GO 68920
68894: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68895: LD_ADDR_VAR 0 3
68899: PUSH
68900: LD_INT 11
68902: PUSH
68903: LD_INT 12
68905: PUSH
68906: LD_INT 13
68908: PUSH
68909: LD_INT 14
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: ST_TO_ADDR
68918: GO 69427
68920: LD_INT 30
68922: DOUBLE
68923: EQUAL
68924: IFTRUE 68928
68926: GO 68954
68928: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68929: LD_ADDR_VAR 0 3
68933: PUSH
68934: LD_INT 11
68936: PUSH
68937: LD_INT 12
68939: PUSH
68940: LD_INT 13
68942: PUSH
68943: LD_INT 14
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: ST_TO_ADDR
68952: GO 69427
68954: LD_INT 25
68956: DOUBLE
68957: EQUAL
68958: IFTRUE 68962
68960: GO 68980
68962: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68963: LD_ADDR_VAR 0 3
68967: PUSH
68968: LD_INT 13
68970: PUSH
68971: LD_INT 14
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: ST_TO_ADDR
68978: GO 69427
68980: LD_INT 27
68982: DOUBLE
68983: EQUAL
68984: IFTRUE 68988
68986: GO 69006
68988: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68989: LD_ADDR_VAR 0 3
68993: PUSH
68994: LD_INT 13
68996: PUSH
68997: LD_INT 14
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: ST_TO_ADDR
69004: GO 69427
69006: LD_INT 28
69008: DOUBLE
69009: EQUAL
69010: IFTRUE 69014
69012: GO 69032
69014: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69015: LD_ADDR_VAR 0 3
69019: PUSH
69020: LD_INT 13
69022: PUSH
69023: LD_INT 14
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: ST_TO_ADDR
69030: GO 69427
69032: LD_INT 29
69034: DOUBLE
69035: EQUAL
69036: IFTRUE 69040
69038: GO 69058
69040: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69041: LD_ADDR_VAR 0 3
69045: PUSH
69046: LD_INT 13
69048: PUSH
69049: LD_INT 14
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: ST_TO_ADDR
69056: GO 69427
69058: LD_INT 31
69060: DOUBLE
69061: EQUAL
69062: IFTRUE 69066
69064: GO 69084
69066: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69067: LD_ADDR_VAR 0 3
69071: PUSH
69072: LD_INT 13
69074: PUSH
69075: LD_INT 14
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: ST_TO_ADDR
69082: GO 69427
69084: LD_INT 26
69086: DOUBLE
69087: EQUAL
69088: IFTRUE 69092
69090: GO 69110
69092: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69093: LD_ADDR_VAR 0 3
69097: PUSH
69098: LD_INT 13
69100: PUSH
69101: LD_INT 14
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: ST_TO_ADDR
69108: GO 69427
69110: LD_INT 42
69112: DOUBLE
69113: EQUAL
69114: IFTRUE 69118
69116: GO 69144
69118: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69119: LD_ADDR_VAR 0 3
69123: PUSH
69124: LD_INT 21
69126: PUSH
69127: LD_INT 22
69129: PUSH
69130: LD_INT 23
69132: PUSH
69133: LD_INT 24
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: ST_TO_ADDR
69142: GO 69427
69144: LD_INT 43
69146: DOUBLE
69147: EQUAL
69148: IFTRUE 69152
69150: GO 69178
69152: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69153: LD_ADDR_VAR 0 3
69157: PUSH
69158: LD_INT 21
69160: PUSH
69161: LD_INT 22
69163: PUSH
69164: LD_INT 23
69166: PUSH
69167: LD_INT 24
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: ST_TO_ADDR
69176: GO 69427
69178: LD_INT 44
69180: DOUBLE
69181: EQUAL
69182: IFTRUE 69186
69184: GO 69212
69186: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69187: LD_ADDR_VAR 0 3
69191: PUSH
69192: LD_INT 21
69194: PUSH
69195: LD_INT 22
69197: PUSH
69198: LD_INT 23
69200: PUSH
69201: LD_INT 24
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: ST_TO_ADDR
69210: GO 69427
69212: LD_INT 45
69214: DOUBLE
69215: EQUAL
69216: IFTRUE 69220
69218: GO 69246
69220: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69221: LD_ADDR_VAR 0 3
69225: PUSH
69226: LD_INT 21
69228: PUSH
69229: LD_INT 22
69231: PUSH
69232: LD_INT 23
69234: PUSH
69235: LD_INT 24
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: ST_TO_ADDR
69244: GO 69427
69246: LD_INT 49
69248: DOUBLE
69249: EQUAL
69250: IFTRUE 69254
69252: GO 69280
69254: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69255: LD_ADDR_VAR 0 3
69259: PUSH
69260: LD_INT 21
69262: PUSH
69263: LD_INT 22
69265: PUSH
69266: LD_INT 23
69268: PUSH
69269: LD_INT 24
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: LIST
69276: LIST
69277: ST_TO_ADDR
69278: GO 69427
69280: LD_INT 51
69282: DOUBLE
69283: EQUAL
69284: IFTRUE 69288
69286: GO 69314
69288: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69289: LD_ADDR_VAR 0 3
69293: PUSH
69294: LD_INT 21
69296: PUSH
69297: LD_INT 22
69299: PUSH
69300: LD_INT 23
69302: PUSH
69303: LD_INT 24
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: ST_TO_ADDR
69312: GO 69427
69314: LD_INT 52
69316: DOUBLE
69317: EQUAL
69318: IFTRUE 69322
69320: GO 69348
69322: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69323: LD_ADDR_VAR 0 3
69327: PUSH
69328: LD_INT 21
69330: PUSH
69331: LD_INT 22
69333: PUSH
69334: LD_INT 23
69336: PUSH
69337: LD_INT 24
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: ST_TO_ADDR
69346: GO 69427
69348: LD_INT 53
69350: DOUBLE
69351: EQUAL
69352: IFTRUE 69356
69354: GO 69374
69356: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69357: LD_ADDR_VAR 0 3
69361: PUSH
69362: LD_INT 23
69364: PUSH
69365: LD_INT 24
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: ST_TO_ADDR
69372: GO 69427
69374: LD_INT 46
69376: DOUBLE
69377: EQUAL
69378: IFTRUE 69382
69380: GO 69400
69382: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69383: LD_ADDR_VAR 0 3
69387: PUSH
69388: LD_INT 23
69390: PUSH
69391: LD_INT 24
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: ST_TO_ADDR
69398: GO 69427
69400: LD_INT 47
69402: DOUBLE
69403: EQUAL
69404: IFTRUE 69408
69406: GO 69426
69408: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69409: LD_ADDR_VAR 0 3
69413: PUSH
69414: LD_INT 23
69416: PUSH
69417: LD_INT 24
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: ST_TO_ADDR
69424: GO 69427
69426: POP
// result := ( chassis in result ) ;
69427: LD_ADDR_VAR 0 3
69431: PUSH
69432: LD_VAR 0 1
69436: PUSH
69437: LD_VAR 0 3
69441: IN
69442: ST_TO_ADDR
// end ;
69443: LD_VAR 0 3
69447: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69448: LD_INT 0
69450: PPUSH
69451: PPUSH
69452: PPUSH
69453: PPUSH
69454: PPUSH
69455: PPUSH
69456: PPUSH
// result := array ;
69457: LD_ADDR_VAR 0 5
69461: PUSH
69462: LD_VAR 0 1
69466: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69467: LD_VAR 0 1
69471: NOT
69472: PUSH
69473: LD_VAR 0 2
69477: NOT
69478: OR
69479: PUSH
69480: LD_VAR 0 3
69484: NOT
69485: OR
69486: PUSH
69487: LD_VAR 0 2
69491: PUSH
69492: LD_VAR 0 1
69496: GREATER
69497: OR
69498: PUSH
69499: LD_VAR 0 3
69503: PUSH
69504: LD_VAR 0 1
69508: GREATER
69509: OR
69510: IFFALSE 69514
// exit ;
69512: GO 69810
// if direction then
69514: LD_VAR 0 4
69518: IFFALSE 69582
// begin d := 1 ;
69520: LD_ADDR_VAR 0 9
69524: PUSH
69525: LD_INT 1
69527: ST_TO_ADDR
// if i_from > i_to then
69528: LD_VAR 0 2
69532: PUSH
69533: LD_VAR 0 3
69537: GREATER
69538: IFFALSE 69564
// length := ( array - i_from ) + i_to else
69540: LD_ADDR_VAR 0 11
69544: PUSH
69545: LD_VAR 0 1
69549: PUSH
69550: LD_VAR 0 2
69554: MINUS
69555: PUSH
69556: LD_VAR 0 3
69560: PLUS
69561: ST_TO_ADDR
69562: GO 69580
// length := i_to - i_from ;
69564: LD_ADDR_VAR 0 11
69568: PUSH
69569: LD_VAR 0 3
69573: PUSH
69574: LD_VAR 0 2
69578: MINUS
69579: ST_TO_ADDR
// end else
69580: GO 69643
// begin d := - 1 ;
69582: LD_ADDR_VAR 0 9
69586: PUSH
69587: LD_INT 1
69589: NEG
69590: ST_TO_ADDR
// if i_from > i_to then
69591: LD_VAR 0 2
69595: PUSH
69596: LD_VAR 0 3
69600: GREATER
69601: IFFALSE 69621
// length := i_from - i_to else
69603: LD_ADDR_VAR 0 11
69607: PUSH
69608: LD_VAR 0 2
69612: PUSH
69613: LD_VAR 0 3
69617: MINUS
69618: ST_TO_ADDR
69619: GO 69643
// length := ( array - i_to ) + i_from ;
69621: LD_ADDR_VAR 0 11
69625: PUSH
69626: LD_VAR 0 1
69630: PUSH
69631: LD_VAR 0 3
69635: MINUS
69636: PUSH
69637: LD_VAR 0 2
69641: PLUS
69642: ST_TO_ADDR
// end ; if not length then
69643: LD_VAR 0 11
69647: NOT
69648: IFFALSE 69652
// exit ;
69650: GO 69810
// tmp := array ;
69652: LD_ADDR_VAR 0 10
69656: PUSH
69657: LD_VAR 0 1
69661: ST_TO_ADDR
// for i = 1 to length do
69662: LD_ADDR_VAR 0 6
69666: PUSH
69667: DOUBLE
69668: LD_INT 1
69670: DEC
69671: ST_TO_ADDR
69672: LD_VAR 0 11
69676: PUSH
69677: FOR_TO
69678: IFFALSE 69798
// begin for j = 1 to array do
69680: LD_ADDR_VAR 0 7
69684: PUSH
69685: DOUBLE
69686: LD_INT 1
69688: DEC
69689: ST_TO_ADDR
69690: LD_VAR 0 1
69694: PUSH
69695: FOR_TO
69696: IFFALSE 69784
// begin k := j + d ;
69698: LD_ADDR_VAR 0 8
69702: PUSH
69703: LD_VAR 0 7
69707: PUSH
69708: LD_VAR 0 9
69712: PLUS
69713: ST_TO_ADDR
// if k > array then
69714: LD_VAR 0 8
69718: PUSH
69719: LD_VAR 0 1
69723: GREATER
69724: IFFALSE 69734
// k := 1 ;
69726: LD_ADDR_VAR 0 8
69730: PUSH
69731: LD_INT 1
69733: ST_TO_ADDR
// if not k then
69734: LD_VAR 0 8
69738: NOT
69739: IFFALSE 69751
// k := array ;
69741: LD_ADDR_VAR 0 8
69745: PUSH
69746: LD_VAR 0 1
69750: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69751: LD_ADDR_VAR 0 10
69755: PUSH
69756: LD_VAR 0 10
69760: PPUSH
69761: LD_VAR 0 8
69765: PPUSH
69766: LD_VAR 0 1
69770: PUSH
69771: LD_VAR 0 7
69775: ARRAY
69776: PPUSH
69777: CALL_OW 1
69781: ST_TO_ADDR
// end ;
69782: GO 69695
69784: POP
69785: POP
// array := tmp ;
69786: LD_ADDR_VAR 0 1
69790: PUSH
69791: LD_VAR 0 10
69795: ST_TO_ADDR
// end ;
69796: GO 69677
69798: POP
69799: POP
// result := array ;
69800: LD_ADDR_VAR 0 5
69804: PUSH
69805: LD_VAR 0 1
69809: ST_TO_ADDR
// end ;
69810: LD_VAR 0 5
69814: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69815: LD_INT 0
69817: PPUSH
69818: PPUSH
// result := 0 ;
69819: LD_ADDR_VAR 0 3
69823: PUSH
69824: LD_INT 0
69826: ST_TO_ADDR
// if not array or not value in array then
69827: LD_VAR 0 1
69831: NOT
69832: PUSH
69833: LD_VAR 0 2
69837: PUSH
69838: LD_VAR 0 1
69842: IN
69843: NOT
69844: OR
69845: IFFALSE 69849
// exit ;
69847: GO 69903
// for i = 1 to array do
69849: LD_ADDR_VAR 0 4
69853: PUSH
69854: DOUBLE
69855: LD_INT 1
69857: DEC
69858: ST_TO_ADDR
69859: LD_VAR 0 1
69863: PUSH
69864: FOR_TO
69865: IFFALSE 69901
// if value = array [ i ] then
69867: LD_VAR 0 2
69871: PUSH
69872: LD_VAR 0 1
69876: PUSH
69877: LD_VAR 0 4
69881: ARRAY
69882: EQUAL
69883: IFFALSE 69899
// begin result := i ;
69885: LD_ADDR_VAR 0 3
69889: PUSH
69890: LD_VAR 0 4
69894: ST_TO_ADDR
// exit ;
69895: POP
69896: POP
69897: GO 69903
// end ;
69899: GO 69864
69901: POP
69902: POP
// end ;
69903: LD_VAR 0 3
69907: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69908: LD_INT 0
69910: PPUSH
// vc_chassis := chassis ;
69911: LD_ADDR_OWVAR 37
69915: PUSH
69916: LD_VAR 0 1
69920: ST_TO_ADDR
// vc_engine := engine ;
69921: LD_ADDR_OWVAR 39
69925: PUSH
69926: LD_VAR 0 2
69930: ST_TO_ADDR
// vc_control := control ;
69931: LD_ADDR_OWVAR 38
69935: PUSH
69936: LD_VAR 0 3
69940: ST_TO_ADDR
// vc_weapon := weapon ;
69941: LD_ADDR_OWVAR 40
69945: PUSH
69946: LD_VAR 0 4
69950: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69951: LD_ADDR_OWVAR 41
69955: PUSH
69956: LD_VAR 0 5
69960: ST_TO_ADDR
// end ;
69961: LD_VAR 0 6
69965: RET
// export function WantPlant ( unit ) ; var task ; begin
69966: LD_INT 0
69968: PPUSH
69969: PPUSH
// result := false ;
69970: LD_ADDR_VAR 0 2
69974: PUSH
69975: LD_INT 0
69977: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69978: LD_ADDR_VAR 0 3
69982: PUSH
69983: LD_VAR 0 1
69987: PPUSH
69988: CALL_OW 437
69992: ST_TO_ADDR
// if task then
69993: LD_VAR 0 3
69997: IFFALSE 70025
// if task [ 1 ] [ 1 ] = p then
69999: LD_VAR 0 3
70003: PUSH
70004: LD_INT 1
70006: ARRAY
70007: PUSH
70008: LD_INT 1
70010: ARRAY
70011: PUSH
70012: LD_STRING p
70014: EQUAL
70015: IFFALSE 70025
// result := true ;
70017: LD_ADDR_VAR 0 2
70021: PUSH
70022: LD_INT 1
70024: ST_TO_ADDR
// end ;
70025: LD_VAR 0 2
70029: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70030: LD_INT 0
70032: PPUSH
70033: PPUSH
70034: PPUSH
70035: PPUSH
// if pos < 1 then
70036: LD_VAR 0 2
70040: PUSH
70041: LD_INT 1
70043: LESS
70044: IFFALSE 70048
// exit ;
70046: GO 70351
// if pos = 1 then
70048: LD_VAR 0 2
70052: PUSH
70053: LD_INT 1
70055: EQUAL
70056: IFFALSE 70089
// result := Replace ( arr , pos [ 1 ] , value ) else
70058: LD_ADDR_VAR 0 4
70062: PUSH
70063: LD_VAR 0 1
70067: PPUSH
70068: LD_VAR 0 2
70072: PUSH
70073: LD_INT 1
70075: ARRAY
70076: PPUSH
70077: LD_VAR 0 3
70081: PPUSH
70082: CALL_OW 1
70086: ST_TO_ADDR
70087: GO 70351
// begin tmp := arr ;
70089: LD_ADDR_VAR 0 6
70093: PUSH
70094: LD_VAR 0 1
70098: ST_TO_ADDR
// s_arr := [ tmp ] ;
70099: LD_ADDR_VAR 0 7
70103: PUSH
70104: LD_VAR 0 6
70108: PUSH
70109: EMPTY
70110: LIST
70111: ST_TO_ADDR
// for i = 1 to pos - 1 do
70112: LD_ADDR_VAR 0 5
70116: PUSH
70117: DOUBLE
70118: LD_INT 1
70120: DEC
70121: ST_TO_ADDR
70122: LD_VAR 0 2
70126: PUSH
70127: LD_INT 1
70129: MINUS
70130: PUSH
70131: FOR_TO
70132: IFFALSE 70177
// begin tmp := tmp [ pos [ i ] ] ;
70134: LD_ADDR_VAR 0 6
70138: PUSH
70139: LD_VAR 0 6
70143: PUSH
70144: LD_VAR 0 2
70148: PUSH
70149: LD_VAR 0 5
70153: ARRAY
70154: ARRAY
70155: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70156: LD_ADDR_VAR 0 7
70160: PUSH
70161: LD_VAR 0 7
70165: PUSH
70166: LD_VAR 0 6
70170: PUSH
70171: EMPTY
70172: LIST
70173: ADD
70174: ST_TO_ADDR
// end ;
70175: GO 70131
70177: POP
70178: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70179: LD_ADDR_VAR 0 6
70183: PUSH
70184: LD_VAR 0 6
70188: PPUSH
70189: LD_VAR 0 2
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PPUSH
70200: LD_VAR 0 3
70204: PPUSH
70205: CALL_OW 1
70209: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70210: LD_ADDR_VAR 0 7
70214: PUSH
70215: LD_VAR 0 7
70219: PPUSH
70220: LD_VAR 0 7
70224: PPUSH
70225: LD_VAR 0 6
70229: PPUSH
70230: CALL_OW 1
70234: ST_TO_ADDR
// for i = s_arr downto 2 do
70235: LD_ADDR_VAR 0 5
70239: PUSH
70240: DOUBLE
70241: LD_VAR 0 7
70245: INC
70246: ST_TO_ADDR
70247: LD_INT 2
70249: PUSH
70250: FOR_DOWNTO
70251: IFFALSE 70335
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70253: LD_ADDR_VAR 0 6
70257: PUSH
70258: LD_VAR 0 7
70262: PUSH
70263: LD_VAR 0 5
70267: PUSH
70268: LD_INT 1
70270: MINUS
70271: ARRAY
70272: PPUSH
70273: LD_VAR 0 2
70277: PUSH
70278: LD_VAR 0 5
70282: PUSH
70283: LD_INT 1
70285: MINUS
70286: ARRAY
70287: PPUSH
70288: LD_VAR 0 7
70292: PUSH
70293: LD_VAR 0 5
70297: ARRAY
70298: PPUSH
70299: CALL_OW 1
70303: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70304: LD_ADDR_VAR 0 7
70308: PUSH
70309: LD_VAR 0 7
70313: PPUSH
70314: LD_VAR 0 5
70318: PUSH
70319: LD_INT 1
70321: MINUS
70322: PPUSH
70323: LD_VAR 0 6
70327: PPUSH
70328: CALL_OW 1
70332: ST_TO_ADDR
// end ;
70333: GO 70250
70335: POP
70336: POP
// result := s_arr [ 1 ] ;
70337: LD_ADDR_VAR 0 4
70341: PUSH
70342: LD_VAR 0 7
70346: PUSH
70347: LD_INT 1
70349: ARRAY
70350: ST_TO_ADDR
// end ; end ;
70351: LD_VAR 0 4
70355: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70356: LD_INT 0
70358: PPUSH
70359: PPUSH
// if not list then
70360: LD_VAR 0 1
70364: NOT
70365: IFFALSE 70369
// exit ;
70367: GO 70460
// i := list [ pos1 ] ;
70369: LD_ADDR_VAR 0 5
70373: PUSH
70374: LD_VAR 0 1
70378: PUSH
70379: LD_VAR 0 2
70383: ARRAY
70384: ST_TO_ADDR
// if not i then
70385: LD_VAR 0 5
70389: NOT
70390: IFFALSE 70394
// exit ;
70392: GO 70460
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70394: LD_ADDR_VAR 0 1
70398: PUSH
70399: LD_VAR 0 1
70403: PPUSH
70404: LD_VAR 0 2
70408: PPUSH
70409: LD_VAR 0 1
70413: PUSH
70414: LD_VAR 0 3
70418: ARRAY
70419: PPUSH
70420: CALL_OW 1
70424: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70425: LD_ADDR_VAR 0 1
70429: PUSH
70430: LD_VAR 0 1
70434: PPUSH
70435: LD_VAR 0 3
70439: PPUSH
70440: LD_VAR 0 5
70444: PPUSH
70445: CALL_OW 1
70449: ST_TO_ADDR
// result := list ;
70450: LD_ADDR_VAR 0 4
70454: PUSH
70455: LD_VAR 0 1
70459: ST_TO_ADDR
// end ;
70460: LD_VAR 0 4
70464: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70465: LD_INT 0
70467: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70468: LD_ADDR_VAR 0 5
70472: PUSH
70473: LD_VAR 0 1
70477: PPUSH
70478: CALL_OW 250
70482: PPUSH
70483: LD_VAR 0 1
70487: PPUSH
70488: CALL_OW 251
70492: PPUSH
70493: LD_VAR 0 2
70497: PPUSH
70498: LD_VAR 0 3
70502: PPUSH
70503: LD_VAR 0 4
70507: PPUSH
70508: CALL 70518 0 5
70512: ST_TO_ADDR
// end ;
70513: LD_VAR 0 5
70517: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70518: LD_INT 0
70520: PPUSH
70521: PPUSH
70522: PPUSH
70523: PPUSH
// if not list then
70524: LD_VAR 0 3
70528: NOT
70529: IFFALSE 70533
// exit ;
70531: GO 70921
// result := [ ] ;
70533: LD_ADDR_VAR 0 6
70537: PUSH
70538: EMPTY
70539: ST_TO_ADDR
// for i in list do
70540: LD_ADDR_VAR 0 7
70544: PUSH
70545: LD_VAR 0 3
70549: PUSH
70550: FOR_IN
70551: IFFALSE 70753
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70553: LD_ADDR_VAR 0 9
70557: PUSH
70558: LD_VAR 0 7
70562: PPUSH
70563: LD_VAR 0 1
70567: PPUSH
70568: LD_VAR 0 2
70572: PPUSH
70573: CALL_OW 297
70577: ST_TO_ADDR
// if not result then
70578: LD_VAR 0 6
70582: NOT
70583: IFFALSE 70609
// result := [ [ i , tmp ] ] else
70585: LD_ADDR_VAR 0 6
70589: PUSH
70590: LD_VAR 0 7
70594: PUSH
70595: LD_VAR 0 9
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: EMPTY
70605: LIST
70606: ST_TO_ADDR
70607: GO 70751
// begin if result [ result ] [ 2 ] < tmp then
70609: LD_VAR 0 6
70613: PUSH
70614: LD_VAR 0 6
70618: ARRAY
70619: PUSH
70620: LD_INT 2
70622: ARRAY
70623: PUSH
70624: LD_VAR 0 9
70628: LESS
70629: IFFALSE 70671
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70631: LD_ADDR_VAR 0 6
70635: PUSH
70636: LD_VAR 0 6
70640: PPUSH
70641: LD_VAR 0 6
70645: PUSH
70646: LD_INT 1
70648: PLUS
70649: PPUSH
70650: LD_VAR 0 7
70654: PUSH
70655: LD_VAR 0 9
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PPUSH
70664: CALL_OW 2
70668: ST_TO_ADDR
70669: GO 70751
// for j = 1 to result do
70671: LD_ADDR_VAR 0 8
70675: PUSH
70676: DOUBLE
70677: LD_INT 1
70679: DEC
70680: ST_TO_ADDR
70681: LD_VAR 0 6
70685: PUSH
70686: FOR_TO
70687: IFFALSE 70749
// begin if tmp < result [ j ] [ 2 ] then
70689: LD_VAR 0 9
70693: PUSH
70694: LD_VAR 0 6
70698: PUSH
70699: LD_VAR 0 8
70703: ARRAY
70704: PUSH
70705: LD_INT 2
70707: ARRAY
70708: LESS
70709: IFFALSE 70747
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70711: LD_ADDR_VAR 0 6
70715: PUSH
70716: LD_VAR 0 6
70720: PPUSH
70721: LD_VAR 0 8
70725: PPUSH
70726: LD_VAR 0 7
70730: PUSH
70731: LD_VAR 0 9
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PPUSH
70740: CALL_OW 2
70744: ST_TO_ADDR
// break ;
70745: GO 70749
// end ; end ;
70747: GO 70686
70749: POP
70750: POP
// end ; end ;
70751: GO 70550
70753: POP
70754: POP
// if result and not asc then
70755: LD_VAR 0 6
70759: PUSH
70760: LD_VAR 0 4
70764: NOT
70765: AND
70766: IFFALSE 70841
// begin tmp := result ;
70768: LD_ADDR_VAR 0 9
70772: PUSH
70773: LD_VAR 0 6
70777: ST_TO_ADDR
// for i = tmp downto 1 do
70778: LD_ADDR_VAR 0 7
70782: PUSH
70783: DOUBLE
70784: LD_VAR 0 9
70788: INC
70789: ST_TO_ADDR
70790: LD_INT 1
70792: PUSH
70793: FOR_DOWNTO
70794: IFFALSE 70839
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70796: LD_ADDR_VAR 0 6
70800: PUSH
70801: LD_VAR 0 6
70805: PPUSH
70806: LD_VAR 0 9
70810: PUSH
70811: LD_VAR 0 7
70815: MINUS
70816: PUSH
70817: LD_INT 1
70819: PLUS
70820: PPUSH
70821: LD_VAR 0 9
70825: PUSH
70826: LD_VAR 0 7
70830: ARRAY
70831: PPUSH
70832: CALL_OW 1
70836: ST_TO_ADDR
70837: GO 70793
70839: POP
70840: POP
// end ; tmp := [ ] ;
70841: LD_ADDR_VAR 0 9
70845: PUSH
70846: EMPTY
70847: ST_TO_ADDR
// if mode then
70848: LD_VAR 0 5
70852: IFFALSE 70921
// begin for i = 1 to result do
70854: LD_ADDR_VAR 0 7
70858: PUSH
70859: DOUBLE
70860: LD_INT 1
70862: DEC
70863: ST_TO_ADDR
70864: LD_VAR 0 6
70868: PUSH
70869: FOR_TO
70870: IFFALSE 70909
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70872: LD_ADDR_VAR 0 9
70876: PUSH
70877: LD_VAR 0 9
70881: PPUSH
70882: LD_VAR 0 7
70886: PPUSH
70887: LD_VAR 0 6
70891: PUSH
70892: LD_VAR 0 7
70896: ARRAY
70897: PUSH
70898: LD_INT 1
70900: ARRAY
70901: PPUSH
70902: CALL_OW 1
70906: ST_TO_ADDR
70907: GO 70869
70909: POP
70910: POP
// result := tmp ;
70911: LD_ADDR_VAR 0 6
70915: PUSH
70916: LD_VAR 0 9
70920: ST_TO_ADDR
// end ; end ;
70921: LD_VAR 0 6
70925: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70926: LD_INT 0
70928: PPUSH
70929: PPUSH
70930: PPUSH
70931: PPUSH
70932: PPUSH
70933: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70934: LD_ADDR_VAR 0 5
70938: PUSH
70939: LD_INT 0
70941: PUSH
70942: LD_INT 0
70944: PUSH
70945: LD_INT 0
70947: PUSH
70948: EMPTY
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: ST_TO_ADDR
// if not x or not y then
70956: LD_VAR 0 2
70960: NOT
70961: PUSH
70962: LD_VAR 0 3
70966: NOT
70967: OR
70968: IFFALSE 70972
// exit ;
70970: GO 72618
// if not range then
70972: LD_VAR 0 4
70976: NOT
70977: IFFALSE 70987
// range := 10 ;
70979: LD_ADDR_VAR 0 4
70983: PUSH
70984: LD_INT 10
70986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70987: LD_ADDR_VAR 0 8
70991: PUSH
70992: LD_INT 81
70994: PUSH
70995: LD_VAR 0 1
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 92
71006: PUSH
71007: LD_VAR 0 2
71011: PUSH
71012: LD_VAR 0 3
71016: PUSH
71017: LD_VAR 0 4
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 3
71030: PUSH
71031: LD_INT 21
71033: PUSH
71034: LD_INT 3
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: LIST
71049: PPUSH
71050: CALL_OW 69
71054: ST_TO_ADDR
// if not tmp then
71055: LD_VAR 0 8
71059: NOT
71060: IFFALSE 71064
// exit ;
71062: GO 72618
// for i in tmp do
71064: LD_ADDR_VAR 0 6
71068: PUSH
71069: LD_VAR 0 8
71073: PUSH
71074: FOR_IN
71075: IFFALSE 72593
// begin points := [ 0 , 0 , 0 ] ;
71077: LD_ADDR_VAR 0 9
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: LIST
71095: ST_TO_ADDR
// bpoints := 1 ;
71096: LD_ADDR_VAR 0 10
71100: PUSH
71101: LD_INT 1
71103: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71104: LD_VAR 0 6
71108: PPUSH
71109: CALL_OW 247
71113: PUSH
71114: LD_INT 1
71116: DOUBLE
71117: EQUAL
71118: IFTRUE 71122
71120: GO 71700
71122: POP
// begin if GetClass ( i ) = 1 then
71123: LD_VAR 0 6
71127: PPUSH
71128: CALL_OW 257
71132: PUSH
71133: LD_INT 1
71135: EQUAL
71136: IFFALSE 71157
// points := [ 10 , 5 , 3 ] ;
71138: LD_ADDR_VAR 0 9
71142: PUSH
71143: LD_INT 10
71145: PUSH
71146: LD_INT 5
71148: PUSH
71149: LD_INT 3
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: LIST
71156: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71157: LD_VAR 0 6
71161: PPUSH
71162: CALL_OW 257
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: LD_INT 3
71172: PUSH
71173: LD_INT 4
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: LIST
71180: IN
71181: IFFALSE 71202
// points := [ 3 , 2 , 1 ] ;
71183: LD_ADDR_VAR 0 9
71187: PUSH
71188: LD_INT 3
71190: PUSH
71191: LD_INT 2
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: LIST
71201: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71202: LD_VAR 0 6
71206: PPUSH
71207: CALL_OW 257
71211: PUSH
71212: LD_INT 5
71214: EQUAL
71215: IFFALSE 71236
// points := [ 130 , 5 , 2 ] ;
71217: LD_ADDR_VAR 0 9
71221: PUSH
71222: LD_INT 130
71224: PUSH
71225: LD_INT 5
71227: PUSH
71228: LD_INT 2
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: LIST
71235: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71236: LD_VAR 0 6
71240: PPUSH
71241: CALL_OW 257
71245: PUSH
71246: LD_INT 8
71248: EQUAL
71249: IFFALSE 71270
// points := [ 35 , 35 , 30 ] ;
71251: LD_ADDR_VAR 0 9
71255: PUSH
71256: LD_INT 35
71258: PUSH
71259: LD_INT 35
71261: PUSH
71262: LD_INT 30
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: LIST
71269: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71270: LD_VAR 0 6
71274: PPUSH
71275: CALL_OW 257
71279: PUSH
71280: LD_INT 9
71282: EQUAL
71283: IFFALSE 71304
// points := [ 20 , 55 , 40 ] ;
71285: LD_ADDR_VAR 0 9
71289: PUSH
71290: LD_INT 20
71292: PUSH
71293: LD_INT 55
71295: PUSH
71296: LD_INT 40
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: LIST
71303: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71304: LD_VAR 0 6
71308: PPUSH
71309: CALL_OW 257
71313: PUSH
71314: LD_INT 12
71316: PUSH
71317: LD_INT 16
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: IN
71324: IFFALSE 71345
// points := [ 5 , 3 , 2 ] ;
71326: LD_ADDR_VAR 0 9
71330: PUSH
71331: LD_INT 5
71333: PUSH
71334: LD_INT 3
71336: PUSH
71337: LD_INT 2
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: LIST
71344: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71345: LD_VAR 0 6
71349: PPUSH
71350: CALL_OW 257
71354: PUSH
71355: LD_INT 17
71357: EQUAL
71358: IFFALSE 71379
// points := [ 100 , 50 , 75 ] ;
71360: LD_ADDR_VAR 0 9
71364: PUSH
71365: LD_INT 100
71367: PUSH
71368: LD_INT 50
71370: PUSH
71371: LD_INT 75
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: LIST
71378: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71379: LD_VAR 0 6
71383: PPUSH
71384: CALL_OW 257
71388: PUSH
71389: LD_INT 15
71391: EQUAL
71392: IFFALSE 71413
// points := [ 10 , 5 , 3 ] ;
71394: LD_ADDR_VAR 0 9
71398: PUSH
71399: LD_INT 10
71401: PUSH
71402: LD_INT 5
71404: PUSH
71405: LD_INT 3
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: LIST
71412: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71413: LD_VAR 0 6
71417: PPUSH
71418: CALL_OW 257
71422: PUSH
71423: LD_INT 14
71425: EQUAL
71426: IFFALSE 71447
// points := [ 10 , 0 , 0 ] ;
71428: LD_ADDR_VAR 0 9
71432: PUSH
71433: LD_INT 10
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: LD_INT 0
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: LIST
71446: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71447: LD_VAR 0 6
71451: PPUSH
71452: CALL_OW 257
71456: PUSH
71457: LD_INT 11
71459: EQUAL
71460: IFFALSE 71481
// points := [ 30 , 10 , 5 ] ;
71462: LD_ADDR_VAR 0 9
71466: PUSH
71467: LD_INT 30
71469: PUSH
71470: LD_INT 10
71472: PUSH
71473: LD_INT 5
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: LIST
71480: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71481: LD_VAR 0 1
71485: PPUSH
71486: LD_INT 5
71488: PPUSH
71489: CALL_OW 321
71493: PUSH
71494: LD_INT 2
71496: EQUAL
71497: IFFALSE 71514
// bpoints := bpoints * 1.8 ;
71499: LD_ADDR_VAR 0 10
71503: PUSH
71504: LD_VAR 0 10
71508: PUSH
71509: LD_REAL  1.80000000000000E+0000
71512: MUL
71513: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71514: LD_VAR 0 6
71518: PPUSH
71519: CALL_OW 257
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: LD_INT 2
71529: PUSH
71530: LD_INT 3
71532: PUSH
71533: LD_INT 4
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: IN
71542: PUSH
71543: LD_VAR 0 1
71547: PPUSH
71548: LD_INT 51
71550: PPUSH
71551: CALL_OW 321
71555: PUSH
71556: LD_INT 2
71558: EQUAL
71559: AND
71560: IFFALSE 71577
// bpoints := bpoints * 1.2 ;
71562: LD_ADDR_VAR 0 10
71566: PUSH
71567: LD_VAR 0 10
71571: PUSH
71572: LD_REAL  1.20000000000000E+0000
71575: MUL
71576: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71577: LD_VAR 0 6
71581: PPUSH
71582: CALL_OW 257
71586: PUSH
71587: LD_INT 5
71589: PUSH
71590: LD_INT 7
71592: PUSH
71593: LD_INT 9
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: LIST
71600: IN
71601: PUSH
71602: LD_VAR 0 1
71606: PPUSH
71607: LD_INT 52
71609: PPUSH
71610: CALL_OW 321
71614: PUSH
71615: LD_INT 2
71617: EQUAL
71618: AND
71619: IFFALSE 71636
// bpoints := bpoints * 1.5 ;
71621: LD_ADDR_VAR 0 10
71625: PUSH
71626: LD_VAR 0 10
71630: PUSH
71631: LD_REAL  1.50000000000000E+0000
71634: MUL
71635: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71636: LD_VAR 0 1
71640: PPUSH
71641: LD_INT 66
71643: PPUSH
71644: CALL_OW 321
71648: PUSH
71649: LD_INT 2
71651: EQUAL
71652: IFFALSE 71669
// bpoints := bpoints * 1.1 ;
71654: LD_ADDR_VAR 0 10
71658: PUSH
71659: LD_VAR 0 10
71663: PUSH
71664: LD_REAL  1.10000000000000E+0000
71667: MUL
71668: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71669: LD_ADDR_VAR 0 10
71673: PUSH
71674: LD_VAR 0 10
71678: PUSH
71679: LD_VAR 0 6
71683: PPUSH
71684: LD_INT 1
71686: PPUSH
71687: CALL_OW 259
71691: PUSH
71692: LD_REAL  1.15000000000000E+0000
71695: MUL
71696: MUL
71697: ST_TO_ADDR
// end ; unit_vehicle :
71698: GO 72522
71700: LD_INT 2
71702: DOUBLE
71703: EQUAL
71704: IFTRUE 71708
71706: GO 72510
71708: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71709: LD_VAR 0 6
71713: PPUSH
71714: CALL_OW 264
71718: PUSH
71719: LD_INT 2
71721: PUSH
71722: LD_INT 42
71724: PUSH
71725: LD_INT 24
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: LIST
71732: IN
71733: IFFALSE 71754
// points := [ 25 , 5 , 3 ] ;
71735: LD_ADDR_VAR 0 9
71739: PUSH
71740: LD_INT 25
71742: PUSH
71743: LD_INT 5
71745: PUSH
71746: LD_INT 3
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: LIST
71753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71754: LD_VAR 0 6
71758: PPUSH
71759: CALL_OW 264
71763: PUSH
71764: LD_INT 4
71766: PUSH
71767: LD_INT 43
71769: PUSH
71770: LD_INT 25
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: LIST
71777: IN
71778: IFFALSE 71799
// points := [ 40 , 15 , 5 ] ;
71780: LD_ADDR_VAR 0 9
71784: PUSH
71785: LD_INT 40
71787: PUSH
71788: LD_INT 15
71790: PUSH
71791: LD_INT 5
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: LIST
71798: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71799: LD_VAR 0 6
71803: PPUSH
71804: CALL_OW 264
71808: PUSH
71809: LD_INT 3
71811: PUSH
71812: LD_INT 23
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: IN
71819: IFFALSE 71840
// points := [ 7 , 25 , 8 ] ;
71821: LD_ADDR_VAR 0 9
71825: PUSH
71826: LD_INT 7
71828: PUSH
71829: LD_INT 25
71831: PUSH
71832: LD_INT 8
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: LIST
71839: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71840: LD_VAR 0 6
71844: PPUSH
71845: CALL_OW 264
71849: PUSH
71850: LD_INT 5
71852: PUSH
71853: LD_INT 27
71855: PUSH
71856: LD_INT 44
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: LIST
71863: IN
71864: IFFALSE 71885
// points := [ 14 , 50 , 16 ] ;
71866: LD_ADDR_VAR 0 9
71870: PUSH
71871: LD_INT 14
71873: PUSH
71874: LD_INT 50
71876: PUSH
71877: LD_INT 16
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: LIST
71884: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71885: LD_VAR 0 6
71889: PPUSH
71890: CALL_OW 264
71894: PUSH
71895: LD_INT 6
71897: PUSH
71898: LD_INT 46
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: IN
71905: IFFALSE 71926
// points := [ 32 , 120 , 70 ] ;
71907: LD_ADDR_VAR 0 9
71911: PUSH
71912: LD_INT 32
71914: PUSH
71915: LD_INT 120
71917: PUSH
71918: LD_INT 70
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: LIST
71925: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71926: LD_VAR 0 6
71930: PPUSH
71931: CALL_OW 264
71935: PUSH
71936: LD_INT 7
71938: PUSH
71939: LD_INT 28
71941: PUSH
71942: LD_INT 45
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: LIST
71949: IN
71950: IFFALSE 71971
// points := [ 35 , 20 , 45 ] ;
71952: LD_ADDR_VAR 0 9
71956: PUSH
71957: LD_INT 35
71959: PUSH
71960: LD_INT 20
71962: PUSH
71963: LD_INT 45
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: LIST
71970: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71971: LD_VAR 0 6
71975: PPUSH
71976: CALL_OW 264
71980: PUSH
71981: LD_INT 47
71983: PUSH
71984: EMPTY
71985: LIST
71986: IN
71987: IFFALSE 72008
// points := [ 67 , 45 , 75 ] ;
71989: LD_ADDR_VAR 0 9
71993: PUSH
71994: LD_INT 67
71996: PUSH
71997: LD_INT 45
71999: PUSH
72000: LD_INT 75
72002: PUSH
72003: EMPTY
72004: LIST
72005: LIST
72006: LIST
72007: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72008: LD_VAR 0 6
72012: PPUSH
72013: CALL_OW 264
72017: PUSH
72018: LD_INT 26
72020: PUSH
72021: EMPTY
72022: LIST
72023: IN
72024: IFFALSE 72045
// points := [ 120 , 30 , 80 ] ;
72026: LD_ADDR_VAR 0 9
72030: PUSH
72031: LD_INT 120
72033: PUSH
72034: LD_INT 30
72036: PUSH
72037: LD_INT 80
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: LIST
72044: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72045: LD_VAR 0 6
72049: PPUSH
72050: CALL_OW 264
72054: PUSH
72055: LD_INT 22
72057: PUSH
72058: EMPTY
72059: LIST
72060: IN
72061: IFFALSE 72082
// points := [ 40 , 1 , 1 ] ;
72063: LD_ADDR_VAR 0 9
72067: PUSH
72068: LD_INT 40
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: LD_INT 1
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: LIST
72081: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72082: LD_VAR 0 6
72086: PPUSH
72087: CALL_OW 264
72091: PUSH
72092: LD_INT 29
72094: PUSH
72095: EMPTY
72096: LIST
72097: IN
72098: IFFALSE 72119
// points := [ 70 , 200 , 400 ] ;
72100: LD_ADDR_VAR 0 9
72104: PUSH
72105: LD_INT 70
72107: PUSH
72108: LD_INT 200
72110: PUSH
72111: LD_INT 400
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: LIST
72118: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72119: LD_VAR 0 6
72123: PPUSH
72124: CALL_OW 264
72128: PUSH
72129: LD_INT 14
72131: PUSH
72132: LD_INT 53
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: IN
72139: IFFALSE 72160
// points := [ 40 , 10 , 20 ] ;
72141: LD_ADDR_VAR 0 9
72145: PUSH
72146: LD_INT 40
72148: PUSH
72149: LD_INT 10
72151: PUSH
72152: LD_INT 20
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: LIST
72159: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72160: LD_VAR 0 6
72164: PPUSH
72165: CALL_OW 264
72169: PUSH
72170: LD_INT 9
72172: PUSH
72173: EMPTY
72174: LIST
72175: IN
72176: IFFALSE 72197
// points := [ 5 , 70 , 20 ] ;
72178: LD_ADDR_VAR 0 9
72182: PUSH
72183: LD_INT 5
72185: PUSH
72186: LD_INT 70
72188: PUSH
72189: LD_INT 20
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: LIST
72196: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72197: LD_VAR 0 6
72201: PPUSH
72202: CALL_OW 264
72206: PUSH
72207: LD_INT 10
72209: PUSH
72210: EMPTY
72211: LIST
72212: IN
72213: IFFALSE 72234
// points := [ 35 , 110 , 70 ] ;
72215: LD_ADDR_VAR 0 9
72219: PUSH
72220: LD_INT 35
72222: PUSH
72223: LD_INT 110
72225: PUSH
72226: LD_INT 70
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: LIST
72233: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72234: LD_VAR 0 6
72238: PPUSH
72239: CALL_OW 265
72243: PUSH
72244: LD_INT 25
72246: EQUAL
72247: IFFALSE 72268
// points := [ 80 , 65 , 100 ] ;
72249: LD_ADDR_VAR 0 9
72253: PUSH
72254: LD_INT 80
72256: PUSH
72257: LD_INT 65
72259: PUSH
72260: LD_INT 100
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: LIST
72267: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72268: LD_VAR 0 6
72272: PPUSH
72273: CALL_OW 263
72277: PUSH
72278: LD_INT 1
72280: EQUAL
72281: IFFALSE 72316
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72283: LD_ADDR_VAR 0 10
72287: PUSH
72288: LD_VAR 0 10
72292: PUSH
72293: LD_VAR 0 6
72297: PPUSH
72298: CALL_OW 311
72302: PPUSH
72303: LD_INT 3
72305: PPUSH
72306: CALL_OW 259
72310: PUSH
72311: LD_INT 4
72313: MUL
72314: MUL
72315: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72316: LD_VAR 0 6
72320: PPUSH
72321: CALL_OW 263
72325: PUSH
72326: LD_INT 2
72328: EQUAL
72329: IFFALSE 72380
// begin j := IsControledBy ( i ) ;
72331: LD_ADDR_VAR 0 7
72335: PUSH
72336: LD_VAR 0 6
72340: PPUSH
72341: CALL_OW 312
72345: ST_TO_ADDR
// if j then
72346: LD_VAR 0 7
72350: IFFALSE 72380
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72352: LD_ADDR_VAR 0 10
72356: PUSH
72357: LD_VAR 0 10
72361: PUSH
72362: LD_VAR 0 7
72366: PPUSH
72367: LD_INT 3
72369: PPUSH
72370: CALL_OW 259
72374: PUSH
72375: LD_INT 3
72377: MUL
72378: MUL
72379: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72380: LD_VAR 0 6
72384: PPUSH
72385: CALL_OW 264
72389: PUSH
72390: LD_INT 5
72392: PUSH
72393: LD_INT 6
72395: PUSH
72396: LD_INT 46
72398: PUSH
72399: LD_INT 44
72401: PUSH
72402: LD_INT 47
72404: PUSH
72405: LD_INT 45
72407: PUSH
72408: LD_INT 28
72410: PUSH
72411: LD_INT 7
72413: PUSH
72414: LD_INT 27
72416: PUSH
72417: LD_INT 29
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: IN
72432: PUSH
72433: LD_VAR 0 1
72437: PPUSH
72438: LD_INT 52
72440: PPUSH
72441: CALL_OW 321
72445: PUSH
72446: LD_INT 2
72448: EQUAL
72449: AND
72450: IFFALSE 72467
// bpoints := bpoints * 1.2 ;
72452: LD_ADDR_VAR 0 10
72456: PUSH
72457: LD_VAR 0 10
72461: PUSH
72462: LD_REAL  1.20000000000000E+0000
72465: MUL
72466: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72467: LD_VAR 0 6
72471: PPUSH
72472: CALL_OW 264
72476: PUSH
72477: LD_INT 6
72479: PUSH
72480: LD_INT 46
72482: PUSH
72483: LD_INT 47
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: LIST
72490: IN
72491: IFFALSE 72508
// bpoints := bpoints * 1.2 ;
72493: LD_ADDR_VAR 0 10
72497: PUSH
72498: LD_VAR 0 10
72502: PUSH
72503: LD_REAL  1.20000000000000E+0000
72506: MUL
72507: ST_TO_ADDR
// end ; unit_building :
72508: GO 72522
72510: LD_INT 3
72512: DOUBLE
72513: EQUAL
72514: IFTRUE 72518
72516: GO 72521
72518: POP
// ; end ;
72519: GO 72522
72521: POP
// for j = 1 to 3 do
72522: LD_ADDR_VAR 0 7
72526: PUSH
72527: DOUBLE
72528: LD_INT 1
72530: DEC
72531: ST_TO_ADDR
72532: LD_INT 3
72534: PUSH
72535: FOR_TO
72536: IFFALSE 72589
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72538: LD_ADDR_VAR 0 5
72542: PUSH
72543: LD_VAR 0 5
72547: PPUSH
72548: LD_VAR 0 7
72552: PPUSH
72553: LD_VAR 0 5
72557: PUSH
72558: LD_VAR 0 7
72562: ARRAY
72563: PUSH
72564: LD_VAR 0 9
72568: PUSH
72569: LD_VAR 0 7
72573: ARRAY
72574: PUSH
72575: LD_VAR 0 10
72579: MUL
72580: PLUS
72581: PPUSH
72582: CALL_OW 1
72586: ST_TO_ADDR
72587: GO 72535
72589: POP
72590: POP
// end ;
72591: GO 71074
72593: POP
72594: POP
// result := Replace ( result , 4 , tmp ) ;
72595: LD_ADDR_VAR 0 5
72599: PUSH
72600: LD_VAR 0 5
72604: PPUSH
72605: LD_INT 4
72607: PPUSH
72608: LD_VAR 0 8
72612: PPUSH
72613: CALL_OW 1
72617: ST_TO_ADDR
// end ;
72618: LD_VAR 0 5
72622: RET
// export function DangerAtRange ( unit , range ) ; begin
72623: LD_INT 0
72625: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72626: LD_ADDR_VAR 0 3
72630: PUSH
72631: LD_VAR 0 1
72635: PPUSH
72636: CALL_OW 255
72640: PPUSH
72641: LD_VAR 0 1
72645: PPUSH
72646: CALL_OW 250
72650: PPUSH
72651: LD_VAR 0 1
72655: PPUSH
72656: CALL_OW 251
72660: PPUSH
72661: LD_VAR 0 2
72665: PPUSH
72666: CALL 70926 0 4
72670: ST_TO_ADDR
// end ;
72671: LD_VAR 0 3
72675: RET
// export function DangerInArea ( side , area ) ; begin
72676: LD_INT 0
72678: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72679: LD_ADDR_VAR 0 3
72683: PUSH
72684: LD_VAR 0 2
72688: PPUSH
72689: LD_INT 81
72691: PUSH
72692: LD_VAR 0 1
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PPUSH
72701: CALL_OW 70
72705: ST_TO_ADDR
// end ;
72706: LD_VAR 0 3
72710: RET
// export function IsExtension ( b ) ; begin
72711: LD_INT 0
72713: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72714: LD_ADDR_VAR 0 2
72718: PUSH
72719: LD_VAR 0 1
72723: PUSH
72724: LD_INT 23
72726: PUSH
72727: LD_INT 20
72729: PUSH
72730: LD_INT 22
72732: PUSH
72733: LD_INT 17
72735: PUSH
72736: LD_INT 24
72738: PUSH
72739: LD_INT 21
72741: PUSH
72742: LD_INT 19
72744: PUSH
72745: LD_INT 16
72747: PUSH
72748: LD_INT 25
72750: PUSH
72751: LD_INT 18
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: LIST
72758: LIST
72759: LIST
72760: LIST
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: IN
72766: ST_TO_ADDR
// end ;
72767: LD_VAR 0 2
72771: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72772: LD_INT 0
72774: PPUSH
72775: PPUSH
72776: PPUSH
// result := [ ] ;
72777: LD_ADDR_VAR 0 3
72781: PUSH
72782: EMPTY
72783: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72784: LD_ADDR_VAR 0 4
72788: PUSH
72789: LD_VAR 0 2
72793: PPUSH
72794: LD_INT 21
72796: PUSH
72797: LD_INT 3
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PPUSH
72804: CALL_OW 70
72808: ST_TO_ADDR
// if not tmp then
72809: LD_VAR 0 4
72813: NOT
72814: IFFALSE 72818
// exit ;
72816: GO 72876
// for i in tmp do
72818: LD_ADDR_VAR 0 5
72822: PUSH
72823: LD_VAR 0 4
72827: PUSH
72828: FOR_IN
72829: IFFALSE 72864
// if GetBase ( i ) <> base then
72831: LD_VAR 0 5
72835: PPUSH
72836: CALL_OW 274
72840: PUSH
72841: LD_VAR 0 1
72845: NONEQUAL
72846: IFFALSE 72862
// ComLinkToBase ( base , i ) ;
72848: LD_VAR 0 1
72852: PPUSH
72853: LD_VAR 0 5
72857: PPUSH
72858: CALL_OW 169
72862: GO 72828
72864: POP
72865: POP
// result := tmp ;
72866: LD_ADDR_VAR 0 3
72870: PUSH
72871: LD_VAR 0 4
72875: ST_TO_ADDR
// end ;
72876: LD_VAR 0 3
72880: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72881: LD_INT 0
72883: PPUSH
72884: PPUSH
// if BuildingStatus ( b ) = bs_build then
72885: LD_VAR 0 2
72889: PPUSH
72890: CALL_OW 461
72894: PUSH
72895: LD_INT 1
72897: EQUAL
72898: IFFALSE 72958
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72900: LD_VAR 0 1
72904: PPUSH
72905: LD_STRING h
72907: PUSH
72908: LD_VAR 0 2
72912: PPUSH
72913: CALL_OW 250
72917: PUSH
72918: LD_VAR 0 2
72922: PPUSH
72923: CALL_OW 251
72927: PUSH
72928: LD_VAR 0 2
72932: PUSH
72933: LD_INT 0
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 0
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: LIST
72950: PUSH
72951: EMPTY
72952: LIST
72953: PPUSH
72954: CALL_OW 446
// end ;
72958: LD_VAR 0 3
72962: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72963: LD_INT 0
72965: PPUSH
72966: PPUSH
72967: PPUSH
72968: PPUSH
72969: PPUSH
72970: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72971: LD_VAR 0 1
72975: NOT
72976: PUSH
72977: LD_VAR 0 1
72981: PPUSH
72982: CALL_OW 263
72986: PUSH
72987: LD_INT 2
72989: EQUAL
72990: NOT
72991: OR
72992: IFFALSE 72996
// exit ;
72994: GO 73312
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72996: LD_ADDR_VAR 0 6
73000: PUSH
73001: LD_INT 22
73003: PUSH
73004: LD_VAR 0 1
73008: PPUSH
73009: CALL_OW 255
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 2
73020: PUSH
73021: LD_INT 30
73023: PUSH
73024: LD_INT 36
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 34
73033: PUSH
73034: LD_INT 31
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: LIST
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PPUSH
73050: CALL_OW 69
73054: ST_TO_ADDR
// if not tmp then
73055: LD_VAR 0 6
73059: NOT
73060: IFFALSE 73064
// exit ;
73062: GO 73312
// result := [ ] ;
73064: LD_ADDR_VAR 0 2
73068: PUSH
73069: EMPTY
73070: ST_TO_ADDR
// for i in tmp do
73071: LD_ADDR_VAR 0 3
73075: PUSH
73076: LD_VAR 0 6
73080: PUSH
73081: FOR_IN
73082: IFFALSE 73153
// begin t := UnitsInside ( i ) ;
73084: LD_ADDR_VAR 0 4
73088: PUSH
73089: LD_VAR 0 3
73093: PPUSH
73094: CALL_OW 313
73098: ST_TO_ADDR
// if t then
73099: LD_VAR 0 4
73103: IFFALSE 73151
// for j in t do
73105: LD_ADDR_VAR 0 7
73109: PUSH
73110: LD_VAR 0 4
73114: PUSH
73115: FOR_IN
73116: IFFALSE 73149
// result := Insert ( result , result + 1 , j ) ;
73118: LD_ADDR_VAR 0 2
73122: PUSH
73123: LD_VAR 0 2
73127: PPUSH
73128: LD_VAR 0 2
73132: PUSH
73133: LD_INT 1
73135: PLUS
73136: PPUSH
73137: LD_VAR 0 7
73141: PPUSH
73142: CALL_OW 2
73146: ST_TO_ADDR
73147: GO 73115
73149: POP
73150: POP
// end ;
73151: GO 73081
73153: POP
73154: POP
// if not result then
73155: LD_VAR 0 2
73159: NOT
73160: IFFALSE 73164
// exit ;
73162: GO 73312
// mech := result [ 1 ] ;
73164: LD_ADDR_VAR 0 5
73168: PUSH
73169: LD_VAR 0 2
73173: PUSH
73174: LD_INT 1
73176: ARRAY
73177: ST_TO_ADDR
// if result > 1 then
73178: LD_VAR 0 2
73182: PUSH
73183: LD_INT 1
73185: GREATER
73186: IFFALSE 73298
// for i = 2 to result do
73188: LD_ADDR_VAR 0 3
73192: PUSH
73193: DOUBLE
73194: LD_INT 2
73196: DEC
73197: ST_TO_ADDR
73198: LD_VAR 0 2
73202: PUSH
73203: FOR_TO
73204: IFFALSE 73296
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73206: LD_ADDR_VAR 0 4
73210: PUSH
73211: LD_VAR 0 2
73215: PUSH
73216: LD_VAR 0 3
73220: ARRAY
73221: PPUSH
73222: LD_INT 3
73224: PPUSH
73225: CALL_OW 259
73229: PUSH
73230: LD_VAR 0 2
73234: PUSH
73235: LD_VAR 0 3
73239: ARRAY
73240: PPUSH
73241: CALL_OW 432
73245: MINUS
73246: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73247: LD_VAR 0 4
73251: PUSH
73252: LD_VAR 0 5
73256: PPUSH
73257: LD_INT 3
73259: PPUSH
73260: CALL_OW 259
73264: PUSH
73265: LD_VAR 0 5
73269: PPUSH
73270: CALL_OW 432
73274: MINUS
73275: GREATEREQUAL
73276: IFFALSE 73294
// mech := result [ i ] ;
73278: LD_ADDR_VAR 0 5
73282: PUSH
73283: LD_VAR 0 2
73287: PUSH
73288: LD_VAR 0 3
73292: ARRAY
73293: ST_TO_ADDR
// end ;
73294: GO 73203
73296: POP
73297: POP
// ComLinkTo ( vehicle , mech ) ;
73298: LD_VAR 0 1
73302: PPUSH
73303: LD_VAR 0 5
73307: PPUSH
73308: CALL_OW 135
// end ;
73312: LD_VAR 0 2
73316: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73317: LD_INT 0
73319: PPUSH
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
73324: PPUSH
73325: PPUSH
73326: PPUSH
73327: PPUSH
73328: PPUSH
73329: PPUSH
73330: PPUSH
73331: PPUSH
// result := [ ] ;
73332: LD_ADDR_VAR 0 7
73336: PUSH
73337: EMPTY
73338: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73339: LD_VAR 0 1
73343: PPUSH
73344: CALL_OW 266
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: LD_INT 1
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: IN
73359: NOT
73360: IFFALSE 73364
// exit ;
73362: GO 74995
// if name then
73364: LD_VAR 0 3
73368: IFFALSE 73384
// SetBName ( base_dep , name ) ;
73370: LD_VAR 0 1
73374: PPUSH
73375: LD_VAR 0 3
73379: PPUSH
73380: CALL_OW 500
// base := GetBase ( base_dep ) ;
73384: LD_ADDR_VAR 0 15
73388: PUSH
73389: LD_VAR 0 1
73393: PPUSH
73394: CALL_OW 274
73398: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73399: LD_ADDR_VAR 0 16
73403: PUSH
73404: LD_VAR 0 1
73408: PPUSH
73409: CALL_OW 255
73413: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73414: LD_ADDR_VAR 0 17
73418: PUSH
73419: LD_VAR 0 1
73423: PPUSH
73424: CALL_OW 248
73428: ST_TO_ADDR
// if sources then
73429: LD_VAR 0 5
73433: IFFALSE 73480
// for i = 1 to 3 do
73435: LD_ADDR_VAR 0 8
73439: PUSH
73440: DOUBLE
73441: LD_INT 1
73443: DEC
73444: ST_TO_ADDR
73445: LD_INT 3
73447: PUSH
73448: FOR_TO
73449: IFFALSE 73478
// AddResourceType ( base , i , sources [ i ] ) ;
73451: LD_VAR 0 15
73455: PPUSH
73456: LD_VAR 0 8
73460: PPUSH
73461: LD_VAR 0 5
73465: PUSH
73466: LD_VAR 0 8
73470: ARRAY
73471: PPUSH
73472: CALL_OW 276
73476: GO 73448
73478: POP
73479: POP
// buildings := GetBaseBuildings ( base , area ) ;
73480: LD_ADDR_VAR 0 18
73484: PUSH
73485: LD_VAR 0 15
73489: PPUSH
73490: LD_VAR 0 2
73494: PPUSH
73495: CALL 72772 0 2
73499: ST_TO_ADDR
// InitHc ;
73500: CALL_OW 19
// InitUc ;
73504: CALL_OW 18
// uc_side := side ;
73508: LD_ADDR_OWVAR 20
73512: PUSH
73513: LD_VAR 0 16
73517: ST_TO_ADDR
// uc_nation := nation ;
73518: LD_ADDR_OWVAR 21
73522: PUSH
73523: LD_VAR 0 17
73527: ST_TO_ADDR
// if buildings then
73528: LD_VAR 0 18
73532: IFFALSE 74854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73534: LD_ADDR_VAR 0 19
73538: PUSH
73539: LD_VAR 0 18
73543: PPUSH
73544: LD_INT 2
73546: PUSH
73547: LD_INT 30
73549: PUSH
73550: LD_INT 29
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 30
73559: PUSH
73560: LD_INT 30
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: LIST
73571: PPUSH
73572: CALL_OW 72
73576: ST_TO_ADDR
// if tmp then
73577: LD_VAR 0 19
73581: IFFALSE 73629
// for i in tmp do
73583: LD_ADDR_VAR 0 8
73587: PUSH
73588: LD_VAR 0 19
73592: PUSH
73593: FOR_IN
73594: IFFALSE 73627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73596: LD_VAR 0 8
73600: PPUSH
73601: CALL_OW 250
73605: PPUSH
73606: LD_VAR 0 8
73610: PPUSH
73611: CALL_OW 251
73615: PPUSH
73616: LD_VAR 0 16
73620: PPUSH
73621: CALL_OW 441
73625: GO 73593
73627: POP
73628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73629: LD_VAR 0 18
73633: PPUSH
73634: LD_INT 2
73636: PUSH
73637: LD_INT 30
73639: PUSH
73640: LD_INT 32
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 30
73649: PUSH
73650: LD_INT 33
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: LIST
73661: PPUSH
73662: CALL_OW 72
73666: IFFALSE 73754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73668: LD_ADDR_VAR 0 8
73672: PUSH
73673: LD_VAR 0 18
73677: PPUSH
73678: LD_INT 2
73680: PUSH
73681: LD_INT 30
73683: PUSH
73684: LD_INT 32
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 30
73693: PUSH
73694: LD_INT 33
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: LIST
73705: PPUSH
73706: CALL_OW 72
73710: PUSH
73711: FOR_IN
73712: IFFALSE 73752
// begin if not GetBWeapon ( i ) then
73714: LD_VAR 0 8
73718: PPUSH
73719: CALL_OW 269
73723: NOT
73724: IFFALSE 73750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73726: LD_VAR 0 8
73730: PPUSH
73731: LD_VAR 0 8
73735: PPUSH
73736: LD_VAR 0 2
73740: PPUSH
73741: CALL 75000 0 2
73745: PPUSH
73746: CALL_OW 431
// end ;
73750: GO 73711
73752: POP
73753: POP
// end ; for i = 1 to personel do
73754: LD_ADDR_VAR 0 8
73758: PUSH
73759: DOUBLE
73760: LD_INT 1
73762: DEC
73763: ST_TO_ADDR
73764: LD_VAR 0 6
73768: PUSH
73769: FOR_TO
73770: IFFALSE 74834
// begin if i > 4 then
73772: LD_VAR 0 8
73776: PUSH
73777: LD_INT 4
73779: GREATER
73780: IFFALSE 73784
// break ;
73782: GO 74834
// case i of 1 :
73784: LD_VAR 0 8
73788: PUSH
73789: LD_INT 1
73791: DOUBLE
73792: EQUAL
73793: IFTRUE 73797
73795: GO 73877
73797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73798: LD_ADDR_VAR 0 12
73802: PUSH
73803: LD_VAR 0 18
73807: PPUSH
73808: LD_INT 22
73810: PUSH
73811: LD_VAR 0 16
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 58
73822: PUSH
73823: EMPTY
73824: LIST
73825: PUSH
73826: LD_INT 2
73828: PUSH
73829: LD_INT 30
73831: PUSH
73832: LD_INT 32
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 30
73841: PUSH
73842: LD_INT 4
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 30
73851: PUSH
73852: LD_INT 5
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: LIST
73869: PPUSH
73870: CALL_OW 72
73874: ST_TO_ADDR
73875: GO 74099
73877: LD_INT 2
73879: DOUBLE
73880: EQUAL
73881: IFTRUE 73885
73883: GO 73947
73885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73886: LD_ADDR_VAR 0 12
73890: PUSH
73891: LD_VAR 0 18
73895: PPUSH
73896: LD_INT 22
73898: PUSH
73899: LD_VAR 0 16
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PUSH
73908: LD_INT 2
73910: PUSH
73911: LD_INT 30
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 30
73923: PUSH
73924: LD_INT 1
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PPUSH
73940: CALL_OW 72
73944: ST_TO_ADDR
73945: GO 74099
73947: LD_INT 3
73949: DOUBLE
73950: EQUAL
73951: IFTRUE 73955
73953: GO 74017
73955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73956: LD_ADDR_VAR 0 12
73960: PUSH
73961: LD_VAR 0 18
73965: PPUSH
73966: LD_INT 22
73968: PUSH
73969: LD_VAR 0 16
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: LD_INT 30
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 30
73993: PUSH
73994: LD_INT 3
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: LIST
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PPUSH
74010: CALL_OW 72
74014: ST_TO_ADDR
74015: GO 74099
74017: LD_INT 4
74019: DOUBLE
74020: EQUAL
74021: IFTRUE 74025
74023: GO 74098
74025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74026: LD_ADDR_VAR 0 12
74030: PUSH
74031: LD_VAR 0 18
74035: PPUSH
74036: LD_INT 22
74038: PUSH
74039: LD_VAR 0 16
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: LD_INT 2
74050: PUSH
74051: LD_INT 30
74053: PUSH
74054: LD_INT 6
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 30
74063: PUSH
74064: LD_INT 7
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 30
74073: PUSH
74074: LD_INT 8
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: LIST
74085: LIST
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PPUSH
74091: CALL_OW 72
74095: ST_TO_ADDR
74096: GO 74099
74098: POP
// if i = 1 then
74099: LD_VAR 0 8
74103: PUSH
74104: LD_INT 1
74106: EQUAL
74107: IFFALSE 74218
// begin tmp := [ ] ;
74109: LD_ADDR_VAR 0 19
74113: PUSH
74114: EMPTY
74115: ST_TO_ADDR
// for j in f do
74116: LD_ADDR_VAR 0 9
74120: PUSH
74121: LD_VAR 0 12
74125: PUSH
74126: FOR_IN
74127: IFFALSE 74200
// if GetBType ( j ) = b_bunker then
74129: LD_VAR 0 9
74133: PPUSH
74134: CALL_OW 266
74138: PUSH
74139: LD_INT 32
74141: EQUAL
74142: IFFALSE 74169
// tmp := Insert ( tmp , 1 , j ) else
74144: LD_ADDR_VAR 0 19
74148: PUSH
74149: LD_VAR 0 19
74153: PPUSH
74154: LD_INT 1
74156: PPUSH
74157: LD_VAR 0 9
74161: PPUSH
74162: CALL_OW 2
74166: ST_TO_ADDR
74167: GO 74198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74169: LD_ADDR_VAR 0 19
74173: PUSH
74174: LD_VAR 0 19
74178: PPUSH
74179: LD_VAR 0 19
74183: PUSH
74184: LD_INT 1
74186: PLUS
74187: PPUSH
74188: LD_VAR 0 9
74192: PPUSH
74193: CALL_OW 2
74197: ST_TO_ADDR
74198: GO 74126
74200: POP
74201: POP
// if tmp then
74202: LD_VAR 0 19
74206: IFFALSE 74218
// f := tmp ;
74208: LD_ADDR_VAR 0 12
74212: PUSH
74213: LD_VAR 0 19
74217: ST_TO_ADDR
// end ; x := personel [ i ] ;
74218: LD_ADDR_VAR 0 13
74222: PUSH
74223: LD_VAR 0 6
74227: PUSH
74228: LD_VAR 0 8
74232: ARRAY
74233: ST_TO_ADDR
// if x = - 1 then
74234: LD_VAR 0 13
74238: PUSH
74239: LD_INT 1
74241: NEG
74242: EQUAL
74243: IFFALSE 74452
// begin for j in f do
74245: LD_ADDR_VAR 0 9
74249: PUSH
74250: LD_VAR 0 12
74254: PUSH
74255: FOR_IN
74256: IFFALSE 74448
// repeat InitHc ;
74258: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74262: LD_VAR 0 9
74266: PPUSH
74267: CALL_OW 266
74271: PUSH
74272: LD_INT 5
74274: EQUAL
74275: IFFALSE 74345
// begin if UnitsInside ( j ) < 3 then
74277: LD_VAR 0 9
74281: PPUSH
74282: CALL_OW 313
74286: PUSH
74287: LD_INT 3
74289: LESS
74290: IFFALSE 74326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74292: LD_INT 0
74294: PPUSH
74295: LD_INT 5
74297: PUSH
74298: LD_INT 8
74300: PUSH
74301: LD_INT 9
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: LIST
74308: PUSH
74309: LD_VAR 0 17
74313: ARRAY
74314: PPUSH
74315: LD_VAR 0 4
74319: PPUSH
74320: CALL_OW 380
74324: GO 74343
// PrepareHuman ( false , i , skill ) ;
74326: LD_INT 0
74328: PPUSH
74329: LD_VAR 0 8
74333: PPUSH
74334: LD_VAR 0 4
74338: PPUSH
74339: CALL_OW 380
// end else
74343: GO 74362
// PrepareHuman ( false , i , skill ) ;
74345: LD_INT 0
74347: PPUSH
74348: LD_VAR 0 8
74352: PPUSH
74353: LD_VAR 0 4
74357: PPUSH
74358: CALL_OW 380
// un := CreateHuman ;
74362: LD_ADDR_VAR 0 14
74366: PUSH
74367: CALL_OW 44
74371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74372: LD_ADDR_VAR 0 7
74376: PUSH
74377: LD_VAR 0 7
74381: PPUSH
74382: LD_INT 1
74384: PPUSH
74385: LD_VAR 0 14
74389: PPUSH
74390: CALL_OW 2
74394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74395: LD_VAR 0 14
74399: PPUSH
74400: LD_VAR 0 9
74404: PPUSH
74405: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74409: LD_VAR 0 9
74413: PPUSH
74414: CALL_OW 313
74418: PUSH
74419: LD_INT 6
74421: EQUAL
74422: PUSH
74423: LD_VAR 0 9
74427: PPUSH
74428: CALL_OW 266
74432: PUSH
74433: LD_INT 32
74435: PUSH
74436: LD_INT 31
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: IN
74443: OR
74444: IFFALSE 74258
74446: GO 74255
74448: POP
74449: POP
// end else
74450: GO 74832
// for j = 1 to x do
74452: LD_ADDR_VAR 0 9
74456: PUSH
74457: DOUBLE
74458: LD_INT 1
74460: DEC
74461: ST_TO_ADDR
74462: LD_VAR 0 13
74466: PUSH
74467: FOR_TO
74468: IFFALSE 74830
// begin InitHc ;
74470: CALL_OW 19
// if not f then
74474: LD_VAR 0 12
74478: NOT
74479: IFFALSE 74568
// begin PrepareHuman ( false , i , skill ) ;
74481: LD_INT 0
74483: PPUSH
74484: LD_VAR 0 8
74488: PPUSH
74489: LD_VAR 0 4
74493: PPUSH
74494: CALL_OW 380
// un := CreateHuman ;
74498: LD_ADDR_VAR 0 14
74502: PUSH
74503: CALL_OW 44
74507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74508: LD_ADDR_VAR 0 7
74512: PUSH
74513: LD_VAR 0 7
74517: PPUSH
74518: LD_INT 1
74520: PPUSH
74521: LD_VAR 0 14
74525: PPUSH
74526: CALL_OW 2
74530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74531: LD_VAR 0 14
74535: PPUSH
74536: LD_VAR 0 1
74540: PPUSH
74541: CALL_OW 250
74545: PPUSH
74546: LD_VAR 0 1
74550: PPUSH
74551: CALL_OW 251
74555: PPUSH
74556: LD_INT 10
74558: PPUSH
74559: LD_INT 0
74561: PPUSH
74562: CALL_OW 50
// continue ;
74566: GO 74467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74568: LD_VAR 0 12
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: PPUSH
74577: CALL_OW 313
74581: PUSH
74582: LD_VAR 0 12
74586: PUSH
74587: LD_INT 1
74589: ARRAY
74590: PPUSH
74591: CALL_OW 266
74595: PUSH
74596: LD_INT 32
74598: PUSH
74599: LD_INT 31
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: IN
74606: AND
74607: PUSH
74608: LD_VAR 0 12
74612: PUSH
74613: LD_INT 1
74615: ARRAY
74616: PPUSH
74617: CALL_OW 313
74621: PUSH
74622: LD_INT 6
74624: EQUAL
74625: OR
74626: IFFALSE 74646
// f := Delete ( f , 1 ) ;
74628: LD_ADDR_VAR 0 12
74632: PUSH
74633: LD_VAR 0 12
74637: PPUSH
74638: LD_INT 1
74640: PPUSH
74641: CALL_OW 3
74645: ST_TO_ADDR
// if not f then
74646: LD_VAR 0 12
74650: NOT
74651: IFFALSE 74669
// begin x := x + 2 ;
74653: LD_ADDR_VAR 0 13
74657: PUSH
74658: LD_VAR 0 13
74662: PUSH
74663: LD_INT 2
74665: PLUS
74666: ST_TO_ADDR
// continue ;
74667: GO 74467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74669: LD_VAR 0 12
74673: PUSH
74674: LD_INT 1
74676: ARRAY
74677: PPUSH
74678: CALL_OW 266
74682: PUSH
74683: LD_INT 5
74685: EQUAL
74686: IFFALSE 74760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74688: LD_VAR 0 12
74692: PUSH
74693: LD_INT 1
74695: ARRAY
74696: PPUSH
74697: CALL_OW 313
74701: PUSH
74702: LD_INT 3
74704: LESS
74705: IFFALSE 74741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74707: LD_INT 0
74709: PPUSH
74710: LD_INT 5
74712: PUSH
74713: LD_INT 8
74715: PUSH
74716: LD_INT 9
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: LIST
74723: PUSH
74724: LD_VAR 0 17
74728: ARRAY
74729: PPUSH
74730: LD_VAR 0 4
74734: PPUSH
74735: CALL_OW 380
74739: GO 74758
// PrepareHuman ( false , i , skill ) ;
74741: LD_INT 0
74743: PPUSH
74744: LD_VAR 0 8
74748: PPUSH
74749: LD_VAR 0 4
74753: PPUSH
74754: CALL_OW 380
// end else
74758: GO 74777
// PrepareHuman ( false , i , skill ) ;
74760: LD_INT 0
74762: PPUSH
74763: LD_VAR 0 8
74767: PPUSH
74768: LD_VAR 0 4
74772: PPUSH
74773: CALL_OW 380
// un := CreateHuman ;
74777: LD_ADDR_VAR 0 14
74781: PUSH
74782: CALL_OW 44
74786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74787: LD_ADDR_VAR 0 7
74791: PUSH
74792: LD_VAR 0 7
74796: PPUSH
74797: LD_INT 1
74799: PPUSH
74800: LD_VAR 0 14
74804: PPUSH
74805: CALL_OW 2
74809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74810: LD_VAR 0 14
74814: PPUSH
74815: LD_VAR 0 12
74819: PUSH
74820: LD_INT 1
74822: ARRAY
74823: PPUSH
74824: CALL_OW 52
// end ;
74828: GO 74467
74830: POP
74831: POP
// end ;
74832: GO 73769
74834: POP
74835: POP
// result := result ^ buildings ;
74836: LD_ADDR_VAR 0 7
74840: PUSH
74841: LD_VAR 0 7
74845: PUSH
74846: LD_VAR 0 18
74850: ADD
74851: ST_TO_ADDR
// end else
74852: GO 74995
// begin for i = 1 to personel do
74854: LD_ADDR_VAR 0 8
74858: PUSH
74859: DOUBLE
74860: LD_INT 1
74862: DEC
74863: ST_TO_ADDR
74864: LD_VAR 0 6
74868: PUSH
74869: FOR_TO
74870: IFFALSE 74993
// begin if i > 4 then
74872: LD_VAR 0 8
74876: PUSH
74877: LD_INT 4
74879: GREATER
74880: IFFALSE 74884
// break ;
74882: GO 74993
// x := personel [ i ] ;
74884: LD_ADDR_VAR 0 13
74888: PUSH
74889: LD_VAR 0 6
74893: PUSH
74894: LD_VAR 0 8
74898: ARRAY
74899: ST_TO_ADDR
// if x = - 1 then
74900: LD_VAR 0 13
74904: PUSH
74905: LD_INT 1
74907: NEG
74908: EQUAL
74909: IFFALSE 74913
// continue ;
74911: GO 74869
// PrepareHuman ( false , i , skill ) ;
74913: LD_INT 0
74915: PPUSH
74916: LD_VAR 0 8
74920: PPUSH
74921: LD_VAR 0 4
74925: PPUSH
74926: CALL_OW 380
// un := CreateHuman ;
74930: LD_ADDR_VAR 0 14
74934: PUSH
74935: CALL_OW 44
74939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74940: LD_VAR 0 14
74944: PPUSH
74945: LD_VAR 0 1
74949: PPUSH
74950: CALL_OW 250
74954: PPUSH
74955: LD_VAR 0 1
74959: PPUSH
74960: CALL_OW 251
74964: PPUSH
74965: LD_INT 10
74967: PPUSH
74968: LD_INT 0
74970: PPUSH
74971: CALL_OW 50
// result := result ^ un ;
74975: LD_ADDR_VAR 0 7
74979: PUSH
74980: LD_VAR 0 7
74984: PUSH
74985: LD_VAR 0 14
74989: ADD
74990: ST_TO_ADDR
// end ;
74991: GO 74869
74993: POP
74994: POP
// end ; end ;
74995: LD_VAR 0 7
74999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75000: LD_INT 0
75002: PPUSH
75003: PPUSH
75004: PPUSH
75005: PPUSH
75006: PPUSH
75007: PPUSH
75008: PPUSH
75009: PPUSH
75010: PPUSH
75011: PPUSH
75012: PPUSH
75013: PPUSH
75014: PPUSH
75015: PPUSH
75016: PPUSH
75017: PPUSH
// result := false ;
75018: LD_ADDR_VAR 0 3
75022: PUSH
75023: LD_INT 0
75025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75026: LD_VAR 0 1
75030: NOT
75031: PUSH
75032: LD_VAR 0 1
75036: PPUSH
75037: CALL_OW 266
75041: PUSH
75042: LD_INT 32
75044: PUSH
75045: LD_INT 33
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: IN
75052: NOT
75053: OR
75054: IFFALSE 75058
// exit ;
75056: GO 76194
// nat := GetNation ( tower ) ;
75058: LD_ADDR_VAR 0 12
75062: PUSH
75063: LD_VAR 0 1
75067: PPUSH
75068: CALL_OW 248
75072: ST_TO_ADDR
// side := GetSide ( tower ) ;
75073: LD_ADDR_VAR 0 16
75077: PUSH
75078: LD_VAR 0 1
75082: PPUSH
75083: CALL_OW 255
75087: ST_TO_ADDR
// x := GetX ( tower ) ;
75088: LD_ADDR_VAR 0 10
75092: PUSH
75093: LD_VAR 0 1
75097: PPUSH
75098: CALL_OW 250
75102: ST_TO_ADDR
// y := GetY ( tower ) ;
75103: LD_ADDR_VAR 0 11
75107: PUSH
75108: LD_VAR 0 1
75112: PPUSH
75113: CALL_OW 251
75117: ST_TO_ADDR
// if not x or not y then
75118: LD_VAR 0 10
75122: NOT
75123: PUSH
75124: LD_VAR 0 11
75128: NOT
75129: OR
75130: IFFALSE 75134
// exit ;
75132: GO 76194
// weapon := 0 ;
75134: LD_ADDR_VAR 0 18
75138: PUSH
75139: LD_INT 0
75141: ST_TO_ADDR
// fac_list := [ ] ;
75142: LD_ADDR_VAR 0 17
75146: PUSH
75147: EMPTY
75148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75149: LD_ADDR_VAR 0 6
75153: PUSH
75154: LD_VAR 0 1
75158: PPUSH
75159: CALL_OW 274
75163: PPUSH
75164: LD_VAR 0 2
75168: PPUSH
75169: CALL 72772 0 2
75173: PPUSH
75174: LD_INT 30
75176: PUSH
75177: LD_INT 3
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PPUSH
75184: CALL_OW 72
75188: ST_TO_ADDR
// if not factories then
75189: LD_VAR 0 6
75193: NOT
75194: IFFALSE 75198
// exit ;
75196: GO 76194
// for i in factories do
75198: LD_ADDR_VAR 0 8
75202: PUSH
75203: LD_VAR 0 6
75207: PUSH
75208: FOR_IN
75209: IFFALSE 75234
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75211: LD_ADDR_VAR 0 17
75215: PUSH
75216: LD_VAR 0 17
75220: PUSH
75221: LD_VAR 0 8
75225: PPUSH
75226: CALL_OW 478
75230: UNION
75231: ST_TO_ADDR
75232: GO 75208
75234: POP
75235: POP
// if not fac_list then
75236: LD_VAR 0 17
75240: NOT
75241: IFFALSE 75245
// exit ;
75243: GO 76194
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75245: LD_ADDR_VAR 0 5
75249: PUSH
75250: LD_INT 4
75252: PUSH
75253: LD_INT 5
75255: PUSH
75256: LD_INT 9
75258: PUSH
75259: LD_INT 10
75261: PUSH
75262: LD_INT 6
75264: PUSH
75265: LD_INT 7
75267: PUSH
75268: LD_INT 11
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 27
75282: PUSH
75283: LD_INT 28
75285: PUSH
75286: LD_INT 26
75288: PUSH
75289: LD_INT 30
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 43
75300: PUSH
75301: LD_INT 44
75303: PUSH
75304: LD_INT 46
75306: PUSH
75307: LD_INT 45
75309: PUSH
75310: LD_INT 47
75312: PUSH
75313: LD_INT 49
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: LIST
75328: PUSH
75329: LD_VAR 0 12
75333: ARRAY
75334: ST_TO_ADDR
// for i in list do
75335: LD_ADDR_VAR 0 8
75339: PUSH
75340: LD_VAR 0 5
75344: PUSH
75345: FOR_IN
75346: IFFALSE 75379
// if not i in fac_list then
75348: LD_VAR 0 8
75352: PUSH
75353: LD_VAR 0 17
75357: IN
75358: NOT
75359: IFFALSE 75377
// list := list diff i ;
75361: LD_ADDR_VAR 0 5
75365: PUSH
75366: LD_VAR 0 5
75370: PUSH
75371: LD_VAR 0 8
75375: DIFF
75376: ST_TO_ADDR
75377: GO 75345
75379: POP
75380: POP
// if not list then
75381: LD_VAR 0 5
75385: NOT
75386: IFFALSE 75390
// exit ;
75388: GO 76194
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75390: LD_VAR 0 12
75394: PUSH
75395: LD_INT 3
75397: EQUAL
75398: PUSH
75399: LD_INT 49
75401: PUSH
75402: LD_VAR 0 5
75406: IN
75407: AND
75408: PUSH
75409: LD_INT 31
75411: PPUSH
75412: LD_VAR 0 16
75416: PPUSH
75417: CALL_OW 321
75421: PUSH
75422: LD_INT 2
75424: EQUAL
75425: AND
75426: IFFALSE 75486
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75428: LD_INT 22
75430: PUSH
75431: LD_VAR 0 16
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 35
75442: PUSH
75443: LD_INT 49
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 91
75452: PUSH
75453: LD_VAR 0 1
75457: PUSH
75458: LD_INT 10
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: LIST
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: LIST
75470: PPUSH
75471: CALL_OW 69
75475: NOT
75476: IFFALSE 75486
// weapon := ru_time_lapser ;
75478: LD_ADDR_VAR 0 18
75482: PUSH
75483: LD_INT 49
75485: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75486: LD_VAR 0 12
75490: PUSH
75491: LD_INT 1
75493: PUSH
75494: LD_INT 2
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: IN
75501: PUSH
75502: LD_INT 11
75504: PUSH
75505: LD_VAR 0 5
75509: IN
75510: PUSH
75511: LD_INT 30
75513: PUSH
75514: LD_VAR 0 5
75518: IN
75519: OR
75520: AND
75521: PUSH
75522: LD_INT 6
75524: PPUSH
75525: LD_VAR 0 16
75529: PPUSH
75530: CALL_OW 321
75534: PUSH
75535: LD_INT 2
75537: EQUAL
75538: AND
75539: IFFALSE 75704
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75541: LD_INT 22
75543: PUSH
75544: LD_VAR 0 16
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 2
75555: PUSH
75556: LD_INT 35
75558: PUSH
75559: LD_INT 11
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 35
75568: PUSH
75569: LD_INT 30
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 91
75583: PUSH
75584: LD_VAR 0 1
75588: PUSH
75589: LD_INT 18
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: LIST
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: LIST
75601: PPUSH
75602: CALL_OW 69
75606: NOT
75607: PUSH
75608: LD_INT 22
75610: PUSH
75611: LD_VAR 0 16
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 2
75622: PUSH
75623: LD_INT 30
75625: PUSH
75626: LD_INT 32
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 30
75635: PUSH
75636: LD_INT 33
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 91
75650: PUSH
75651: LD_VAR 0 1
75655: PUSH
75656: LD_INT 12
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: LIST
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: LIST
75668: PUSH
75669: EMPTY
75670: LIST
75671: PPUSH
75672: CALL_OW 69
75676: PUSH
75677: LD_INT 2
75679: GREATER
75680: AND
75681: IFFALSE 75704
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75683: LD_ADDR_VAR 0 18
75687: PUSH
75688: LD_INT 11
75690: PUSH
75691: LD_INT 30
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_VAR 0 12
75702: ARRAY
75703: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75704: LD_VAR 0 18
75708: NOT
75709: PUSH
75710: LD_INT 40
75712: PPUSH
75713: LD_VAR 0 16
75717: PPUSH
75718: CALL_OW 321
75722: PUSH
75723: LD_INT 2
75725: EQUAL
75726: AND
75727: PUSH
75728: LD_INT 7
75730: PUSH
75731: LD_VAR 0 5
75735: IN
75736: PUSH
75737: LD_INT 28
75739: PUSH
75740: LD_VAR 0 5
75744: IN
75745: OR
75746: PUSH
75747: LD_INT 45
75749: PUSH
75750: LD_VAR 0 5
75754: IN
75755: OR
75756: AND
75757: IFFALSE 76011
// begin hex := GetHexInfo ( x , y ) ;
75759: LD_ADDR_VAR 0 4
75763: PUSH
75764: LD_VAR 0 10
75768: PPUSH
75769: LD_VAR 0 11
75773: PPUSH
75774: CALL_OW 546
75778: ST_TO_ADDR
// if hex [ 1 ] then
75779: LD_VAR 0 4
75783: PUSH
75784: LD_INT 1
75786: ARRAY
75787: IFFALSE 75791
// exit ;
75789: GO 76194
// height := hex [ 2 ] ;
75791: LD_ADDR_VAR 0 15
75795: PUSH
75796: LD_VAR 0 4
75800: PUSH
75801: LD_INT 2
75803: ARRAY
75804: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75805: LD_ADDR_VAR 0 14
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: LD_INT 2
75815: PUSH
75816: LD_INT 3
75818: PUSH
75819: LD_INT 5
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: ST_TO_ADDR
// for i in tmp do
75828: LD_ADDR_VAR 0 8
75832: PUSH
75833: LD_VAR 0 14
75837: PUSH
75838: FOR_IN
75839: IFFALSE 76009
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75841: LD_ADDR_VAR 0 9
75845: PUSH
75846: LD_VAR 0 10
75850: PPUSH
75851: LD_VAR 0 8
75855: PPUSH
75856: LD_INT 5
75858: PPUSH
75859: CALL_OW 272
75863: PUSH
75864: LD_VAR 0 11
75868: PPUSH
75869: LD_VAR 0 8
75873: PPUSH
75874: LD_INT 5
75876: PPUSH
75877: CALL_OW 273
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75886: LD_VAR 0 9
75890: PUSH
75891: LD_INT 1
75893: ARRAY
75894: PPUSH
75895: LD_VAR 0 9
75899: PUSH
75900: LD_INT 2
75902: ARRAY
75903: PPUSH
75904: CALL_OW 488
75908: IFFALSE 76007
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75910: LD_ADDR_VAR 0 4
75914: PUSH
75915: LD_VAR 0 9
75919: PUSH
75920: LD_INT 1
75922: ARRAY
75923: PPUSH
75924: LD_VAR 0 9
75928: PUSH
75929: LD_INT 2
75931: ARRAY
75932: PPUSH
75933: CALL_OW 546
75937: ST_TO_ADDR
// if hex [ 1 ] then
75938: LD_VAR 0 4
75942: PUSH
75943: LD_INT 1
75945: ARRAY
75946: IFFALSE 75950
// continue ;
75948: GO 75838
// h := hex [ 2 ] ;
75950: LD_ADDR_VAR 0 13
75954: PUSH
75955: LD_VAR 0 4
75959: PUSH
75960: LD_INT 2
75962: ARRAY
75963: ST_TO_ADDR
// if h + 7 < height then
75964: LD_VAR 0 13
75968: PUSH
75969: LD_INT 7
75971: PLUS
75972: PUSH
75973: LD_VAR 0 15
75977: LESS
75978: IFFALSE 76007
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75980: LD_ADDR_VAR 0 18
75984: PUSH
75985: LD_INT 7
75987: PUSH
75988: LD_INT 28
75990: PUSH
75991: LD_INT 45
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: LIST
75998: PUSH
75999: LD_VAR 0 12
76003: ARRAY
76004: ST_TO_ADDR
// break ;
76005: GO 76009
// end ; end ; end ;
76007: GO 75838
76009: POP
76010: POP
// end ; if not weapon then
76011: LD_VAR 0 18
76015: NOT
76016: IFFALSE 76076
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76018: LD_ADDR_VAR 0 5
76022: PUSH
76023: LD_VAR 0 5
76027: PUSH
76028: LD_INT 11
76030: PUSH
76031: LD_INT 30
76033: PUSH
76034: LD_INT 49
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: LIST
76041: DIFF
76042: ST_TO_ADDR
// if not list then
76043: LD_VAR 0 5
76047: NOT
76048: IFFALSE 76052
// exit ;
76050: GO 76194
// weapon := list [ rand ( 1 , list ) ] ;
76052: LD_ADDR_VAR 0 18
76056: PUSH
76057: LD_VAR 0 5
76061: PUSH
76062: LD_INT 1
76064: PPUSH
76065: LD_VAR 0 5
76069: PPUSH
76070: CALL_OW 12
76074: ARRAY
76075: ST_TO_ADDR
// end ; if weapon then
76076: LD_VAR 0 18
76080: IFFALSE 76194
// begin tmp := CostOfWeapon ( weapon ) ;
76082: LD_ADDR_VAR 0 14
76086: PUSH
76087: LD_VAR 0 18
76091: PPUSH
76092: CALL_OW 451
76096: ST_TO_ADDR
// j := GetBase ( tower ) ;
76097: LD_ADDR_VAR 0 9
76101: PUSH
76102: LD_VAR 0 1
76106: PPUSH
76107: CALL_OW 274
76111: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76112: LD_VAR 0 9
76116: PPUSH
76117: LD_INT 1
76119: PPUSH
76120: CALL_OW 275
76124: PUSH
76125: LD_VAR 0 14
76129: PUSH
76130: LD_INT 1
76132: ARRAY
76133: GREATEREQUAL
76134: PUSH
76135: LD_VAR 0 9
76139: PPUSH
76140: LD_INT 2
76142: PPUSH
76143: CALL_OW 275
76147: PUSH
76148: LD_VAR 0 14
76152: PUSH
76153: LD_INT 2
76155: ARRAY
76156: GREATEREQUAL
76157: AND
76158: PUSH
76159: LD_VAR 0 9
76163: PPUSH
76164: LD_INT 3
76166: PPUSH
76167: CALL_OW 275
76171: PUSH
76172: LD_VAR 0 14
76176: PUSH
76177: LD_INT 3
76179: ARRAY
76180: GREATEREQUAL
76181: AND
76182: IFFALSE 76194
// result := weapon ;
76184: LD_ADDR_VAR 0 3
76188: PUSH
76189: LD_VAR 0 18
76193: ST_TO_ADDR
// end ; end ;
76194: LD_VAR 0 3
76198: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76199: LD_INT 0
76201: PPUSH
76202: PPUSH
// result := true ;
76203: LD_ADDR_VAR 0 3
76207: PUSH
76208: LD_INT 1
76210: ST_TO_ADDR
// if array1 = array2 then
76211: LD_VAR 0 1
76215: PUSH
76216: LD_VAR 0 2
76220: EQUAL
76221: IFFALSE 76281
// begin for i = 1 to array1 do
76223: LD_ADDR_VAR 0 4
76227: PUSH
76228: DOUBLE
76229: LD_INT 1
76231: DEC
76232: ST_TO_ADDR
76233: LD_VAR 0 1
76237: PUSH
76238: FOR_TO
76239: IFFALSE 76277
// if array1 [ i ] <> array2 [ i ] then
76241: LD_VAR 0 1
76245: PUSH
76246: LD_VAR 0 4
76250: ARRAY
76251: PUSH
76252: LD_VAR 0 2
76256: PUSH
76257: LD_VAR 0 4
76261: ARRAY
76262: NONEQUAL
76263: IFFALSE 76275
// begin result := false ;
76265: LD_ADDR_VAR 0 3
76269: PUSH
76270: LD_INT 0
76272: ST_TO_ADDR
// break ;
76273: GO 76277
// end ;
76275: GO 76238
76277: POP
76278: POP
// end else
76279: GO 76289
// result := false ;
76281: LD_ADDR_VAR 0 3
76285: PUSH
76286: LD_INT 0
76288: ST_TO_ADDR
// end ;
76289: LD_VAR 0 3
76293: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76294: LD_INT 0
76296: PPUSH
76297: PPUSH
76298: PPUSH
// pom := GetBase ( fac ) ;
76299: LD_ADDR_VAR 0 5
76303: PUSH
76304: LD_VAR 0 1
76308: PPUSH
76309: CALL_OW 274
76313: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76314: LD_ADDR_VAR 0 4
76318: PUSH
76319: LD_VAR 0 2
76323: PUSH
76324: LD_INT 1
76326: ARRAY
76327: PPUSH
76328: LD_VAR 0 2
76332: PUSH
76333: LD_INT 2
76335: ARRAY
76336: PPUSH
76337: LD_VAR 0 2
76341: PUSH
76342: LD_INT 3
76344: ARRAY
76345: PPUSH
76346: LD_VAR 0 2
76350: PUSH
76351: LD_INT 4
76353: ARRAY
76354: PPUSH
76355: CALL_OW 449
76359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76360: LD_ADDR_VAR 0 3
76364: PUSH
76365: LD_VAR 0 5
76369: PPUSH
76370: LD_INT 1
76372: PPUSH
76373: CALL_OW 275
76377: PUSH
76378: LD_VAR 0 4
76382: PUSH
76383: LD_INT 1
76385: ARRAY
76386: GREATEREQUAL
76387: PUSH
76388: LD_VAR 0 5
76392: PPUSH
76393: LD_INT 2
76395: PPUSH
76396: CALL_OW 275
76400: PUSH
76401: LD_VAR 0 4
76405: PUSH
76406: LD_INT 2
76408: ARRAY
76409: GREATEREQUAL
76410: AND
76411: PUSH
76412: LD_VAR 0 5
76416: PPUSH
76417: LD_INT 3
76419: PPUSH
76420: CALL_OW 275
76424: PUSH
76425: LD_VAR 0 4
76429: PUSH
76430: LD_INT 3
76432: ARRAY
76433: GREATEREQUAL
76434: AND
76435: ST_TO_ADDR
// end ;
76436: LD_VAR 0 3
76440: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76441: LD_INT 0
76443: PPUSH
76444: PPUSH
76445: PPUSH
76446: PPUSH
// pom := GetBase ( building ) ;
76447: LD_ADDR_VAR 0 3
76451: PUSH
76452: LD_VAR 0 1
76456: PPUSH
76457: CALL_OW 274
76461: ST_TO_ADDR
// if not pom then
76462: LD_VAR 0 3
76466: NOT
76467: IFFALSE 76471
// exit ;
76469: GO 76641
// btype := GetBType ( building ) ;
76471: LD_ADDR_VAR 0 5
76475: PUSH
76476: LD_VAR 0 1
76480: PPUSH
76481: CALL_OW 266
76485: ST_TO_ADDR
// if btype = b_armoury then
76486: LD_VAR 0 5
76490: PUSH
76491: LD_INT 4
76493: EQUAL
76494: IFFALSE 76504
// btype := b_barracks ;
76496: LD_ADDR_VAR 0 5
76500: PUSH
76501: LD_INT 5
76503: ST_TO_ADDR
// if btype = b_depot then
76504: LD_VAR 0 5
76508: PUSH
76509: LD_INT 0
76511: EQUAL
76512: IFFALSE 76522
// btype := b_warehouse ;
76514: LD_ADDR_VAR 0 5
76518: PUSH
76519: LD_INT 1
76521: ST_TO_ADDR
// if btype = b_workshop then
76522: LD_VAR 0 5
76526: PUSH
76527: LD_INT 2
76529: EQUAL
76530: IFFALSE 76540
// btype := b_factory ;
76532: LD_ADDR_VAR 0 5
76536: PUSH
76537: LD_INT 3
76539: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76540: LD_ADDR_VAR 0 4
76544: PUSH
76545: LD_VAR 0 5
76549: PPUSH
76550: LD_VAR 0 1
76554: PPUSH
76555: CALL_OW 248
76559: PPUSH
76560: CALL_OW 450
76564: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76565: LD_ADDR_VAR 0 2
76569: PUSH
76570: LD_VAR 0 3
76574: PPUSH
76575: LD_INT 1
76577: PPUSH
76578: CALL_OW 275
76582: PUSH
76583: LD_VAR 0 4
76587: PUSH
76588: LD_INT 1
76590: ARRAY
76591: GREATEREQUAL
76592: PUSH
76593: LD_VAR 0 3
76597: PPUSH
76598: LD_INT 2
76600: PPUSH
76601: CALL_OW 275
76605: PUSH
76606: LD_VAR 0 4
76610: PUSH
76611: LD_INT 2
76613: ARRAY
76614: GREATEREQUAL
76615: AND
76616: PUSH
76617: LD_VAR 0 3
76621: PPUSH
76622: LD_INT 3
76624: PPUSH
76625: CALL_OW 275
76629: PUSH
76630: LD_VAR 0 4
76634: PUSH
76635: LD_INT 3
76637: ARRAY
76638: GREATEREQUAL
76639: AND
76640: ST_TO_ADDR
// end ;
76641: LD_VAR 0 2
76645: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76646: LD_INT 0
76648: PPUSH
76649: PPUSH
76650: PPUSH
// pom := GetBase ( building ) ;
76651: LD_ADDR_VAR 0 4
76655: PUSH
76656: LD_VAR 0 1
76660: PPUSH
76661: CALL_OW 274
76665: ST_TO_ADDR
// if not pom then
76666: LD_VAR 0 4
76670: NOT
76671: IFFALSE 76675
// exit ;
76673: GO 76776
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76675: LD_ADDR_VAR 0 5
76679: PUSH
76680: LD_VAR 0 2
76684: PPUSH
76685: LD_VAR 0 1
76689: PPUSH
76690: CALL_OW 248
76694: PPUSH
76695: CALL_OW 450
76699: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76700: LD_ADDR_VAR 0 3
76704: PUSH
76705: LD_VAR 0 4
76709: PPUSH
76710: LD_INT 1
76712: PPUSH
76713: CALL_OW 275
76717: PUSH
76718: LD_VAR 0 5
76722: PUSH
76723: LD_INT 1
76725: ARRAY
76726: GREATEREQUAL
76727: PUSH
76728: LD_VAR 0 4
76732: PPUSH
76733: LD_INT 2
76735: PPUSH
76736: CALL_OW 275
76740: PUSH
76741: LD_VAR 0 5
76745: PUSH
76746: LD_INT 2
76748: ARRAY
76749: GREATEREQUAL
76750: AND
76751: PUSH
76752: LD_VAR 0 4
76756: PPUSH
76757: LD_INT 3
76759: PPUSH
76760: CALL_OW 275
76764: PUSH
76765: LD_VAR 0 5
76769: PUSH
76770: LD_INT 3
76772: ARRAY
76773: GREATEREQUAL
76774: AND
76775: ST_TO_ADDR
// end ;
76776: LD_VAR 0 3
76780: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76781: LD_INT 0
76783: PPUSH
76784: PPUSH
76785: PPUSH
76786: PPUSH
76787: PPUSH
76788: PPUSH
76789: PPUSH
76790: PPUSH
76791: PPUSH
76792: PPUSH
// result := false ;
76793: LD_ADDR_VAR 0 6
76797: PUSH
76798: LD_INT 0
76800: ST_TO_ADDR
// if not base or not btype or not x or not y then
76801: LD_VAR 0 1
76805: NOT
76806: PUSH
76807: LD_VAR 0 2
76811: NOT
76812: OR
76813: PUSH
76814: LD_VAR 0 3
76818: NOT
76819: OR
76820: PUSH
76821: LD_VAR 0 4
76825: NOT
76826: OR
76827: IFFALSE 76831
// exit ;
76829: GO 77440
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76831: LD_ADDR_VAR 0 12
76835: PUSH
76836: LD_VAR 0 2
76840: PPUSH
76841: LD_VAR 0 3
76845: PPUSH
76846: LD_VAR 0 4
76850: PPUSH
76851: LD_VAR 0 5
76855: PPUSH
76856: LD_VAR 0 1
76860: PUSH
76861: LD_INT 1
76863: ARRAY
76864: PPUSH
76865: CALL_OW 248
76869: PPUSH
76870: LD_INT 0
76872: PPUSH
76873: CALL 78277 0 6
76877: ST_TO_ADDR
// if not hexes then
76878: LD_VAR 0 12
76882: NOT
76883: IFFALSE 76887
// exit ;
76885: GO 77440
// for i = 1 to hexes do
76887: LD_ADDR_VAR 0 7
76891: PUSH
76892: DOUBLE
76893: LD_INT 1
76895: DEC
76896: ST_TO_ADDR
76897: LD_VAR 0 12
76901: PUSH
76902: FOR_TO
76903: IFFALSE 77438
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76905: LD_ADDR_VAR 0 11
76909: PUSH
76910: LD_VAR 0 12
76914: PUSH
76915: LD_VAR 0 7
76919: ARRAY
76920: PUSH
76921: LD_INT 1
76923: ARRAY
76924: PPUSH
76925: LD_VAR 0 12
76929: PUSH
76930: LD_VAR 0 7
76934: ARRAY
76935: PUSH
76936: LD_INT 2
76938: ARRAY
76939: PPUSH
76940: CALL_OW 428
76944: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76945: LD_VAR 0 12
76949: PUSH
76950: LD_VAR 0 7
76954: ARRAY
76955: PUSH
76956: LD_INT 1
76958: ARRAY
76959: PPUSH
76960: LD_VAR 0 12
76964: PUSH
76965: LD_VAR 0 7
76969: ARRAY
76970: PUSH
76971: LD_INT 2
76973: ARRAY
76974: PPUSH
76975: CALL_OW 351
76979: PUSH
76980: LD_VAR 0 12
76984: PUSH
76985: LD_VAR 0 7
76989: ARRAY
76990: PUSH
76991: LD_INT 1
76993: ARRAY
76994: PPUSH
76995: LD_VAR 0 12
76999: PUSH
77000: LD_VAR 0 7
77004: ARRAY
77005: PUSH
77006: LD_INT 2
77008: ARRAY
77009: PPUSH
77010: CALL_OW 488
77014: NOT
77015: OR
77016: PUSH
77017: LD_VAR 0 11
77021: PPUSH
77022: CALL_OW 247
77026: PUSH
77027: LD_INT 3
77029: EQUAL
77030: OR
77031: IFFALSE 77037
// exit ;
77033: POP
77034: POP
77035: GO 77440
// if not tmp or not tmp in base then
77037: LD_VAR 0 11
77041: NOT
77042: PUSH
77043: LD_VAR 0 11
77047: PUSH
77048: LD_VAR 0 1
77052: IN
77053: NOT
77054: OR
77055: IFFALSE 77059
// continue ;
77057: GO 76902
// result := true ;
77059: LD_ADDR_VAR 0 6
77063: PUSH
77064: LD_INT 1
77066: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77067: LD_ADDR_VAR 0 15
77071: PUSH
77072: LD_VAR 0 1
77076: PPUSH
77077: LD_INT 22
77079: PUSH
77080: LD_VAR 0 11
77084: PPUSH
77085: CALL_OW 255
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: LD_INT 30
77099: PUSH
77100: LD_INT 0
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 30
77109: PUSH
77110: LD_INT 1
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: LIST
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PPUSH
77126: CALL_OW 72
77130: ST_TO_ADDR
// if dep then
77131: LD_VAR 0 15
77135: IFFALSE 77271
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77137: LD_ADDR_VAR 0 14
77141: PUSH
77142: LD_VAR 0 15
77146: PUSH
77147: LD_INT 1
77149: ARRAY
77150: PPUSH
77151: CALL_OW 250
77155: PPUSH
77156: LD_VAR 0 15
77160: PUSH
77161: LD_INT 1
77163: ARRAY
77164: PPUSH
77165: CALL_OW 254
77169: PPUSH
77170: LD_INT 5
77172: PPUSH
77173: CALL_OW 272
77177: PUSH
77178: LD_VAR 0 15
77182: PUSH
77183: LD_INT 1
77185: ARRAY
77186: PPUSH
77187: CALL_OW 251
77191: PPUSH
77192: LD_VAR 0 15
77196: PUSH
77197: LD_INT 1
77199: ARRAY
77200: PPUSH
77201: CALL_OW 254
77205: PPUSH
77206: LD_INT 5
77208: PPUSH
77209: CALL_OW 273
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77218: LD_VAR 0 14
77222: PUSH
77223: LD_INT 1
77225: ARRAY
77226: PPUSH
77227: LD_VAR 0 14
77231: PUSH
77232: LD_INT 2
77234: ARRAY
77235: PPUSH
77236: CALL_OW 488
77240: IFFALSE 77271
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77242: LD_VAR 0 11
77246: PPUSH
77247: LD_VAR 0 14
77251: PUSH
77252: LD_INT 1
77254: ARRAY
77255: PPUSH
77256: LD_VAR 0 14
77260: PUSH
77261: LD_INT 2
77263: ARRAY
77264: PPUSH
77265: CALL_OW 111
// continue ;
77269: GO 76902
// end ; end ; r := GetDir ( tmp ) ;
77271: LD_ADDR_VAR 0 13
77275: PUSH
77276: LD_VAR 0 11
77280: PPUSH
77281: CALL_OW 254
77285: ST_TO_ADDR
// if r = 5 then
77286: LD_VAR 0 13
77290: PUSH
77291: LD_INT 5
77293: EQUAL
77294: IFFALSE 77304
// r := 0 ;
77296: LD_ADDR_VAR 0 13
77300: PUSH
77301: LD_INT 0
77303: ST_TO_ADDR
// for j = r to 5 do
77304: LD_ADDR_VAR 0 8
77308: PUSH
77309: DOUBLE
77310: LD_VAR 0 13
77314: DEC
77315: ST_TO_ADDR
77316: LD_INT 5
77318: PUSH
77319: FOR_TO
77320: IFFALSE 77434
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77322: LD_ADDR_VAR 0 9
77326: PUSH
77327: LD_VAR 0 11
77331: PPUSH
77332: CALL_OW 250
77336: PPUSH
77337: LD_VAR 0 8
77341: PPUSH
77342: LD_INT 2
77344: PPUSH
77345: CALL_OW 272
77349: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77350: LD_ADDR_VAR 0 10
77354: PUSH
77355: LD_VAR 0 11
77359: PPUSH
77360: CALL_OW 251
77364: PPUSH
77365: LD_VAR 0 8
77369: PPUSH
77370: LD_INT 2
77372: PPUSH
77373: CALL_OW 273
77377: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77378: LD_VAR 0 9
77382: PPUSH
77383: LD_VAR 0 10
77387: PPUSH
77388: CALL_OW 488
77392: PUSH
77393: LD_VAR 0 9
77397: PPUSH
77398: LD_VAR 0 10
77402: PPUSH
77403: CALL_OW 428
77407: NOT
77408: AND
77409: IFFALSE 77432
// begin ComMoveXY ( tmp , _x , _y ) ;
77411: LD_VAR 0 11
77415: PPUSH
77416: LD_VAR 0 9
77420: PPUSH
77421: LD_VAR 0 10
77425: PPUSH
77426: CALL_OW 111
// break ;
77430: GO 77434
// end ; end ;
77432: GO 77319
77434: POP
77435: POP
// end ;
77436: GO 76902
77438: POP
77439: POP
// end ;
77440: LD_VAR 0 6
77444: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77445: LD_INT 0
77447: PPUSH
77448: PPUSH
77449: PPUSH
77450: PPUSH
77451: PPUSH
77452: PPUSH
77453: PPUSH
77454: PPUSH
77455: PPUSH
77456: PPUSH
// result := false ;
77457: LD_ADDR_VAR 0 6
77461: PUSH
77462: LD_INT 0
77464: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77465: LD_VAR 0 1
77469: NOT
77470: PUSH
77471: LD_VAR 0 1
77475: PPUSH
77476: CALL_OW 266
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: LD_INT 1
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: IN
77491: NOT
77492: OR
77493: PUSH
77494: LD_VAR 0 2
77498: NOT
77499: OR
77500: PUSH
77501: LD_VAR 0 5
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: LD_INT 1
77511: PUSH
77512: LD_INT 2
77514: PUSH
77515: LD_INT 3
77517: PUSH
77518: LD_INT 4
77520: PUSH
77521: LD_INT 5
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: LIST
77528: LIST
77529: LIST
77530: LIST
77531: IN
77532: NOT
77533: OR
77534: PUSH
77535: LD_VAR 0 3
77539: PPUSH
77540: LD_VAR 0 4
77544: PPUSH
77545: CALL_OW 488
77549: NOT
77550: OR
77551: IFFALSE 77555
// exit ;
77553: GO 78272
// pom := GetBase ( depot ) ;
77555: LD_ADDR_VAR 0 10
77559: PUSH
77560: LD_VAR 0 1
77564: PPUSH
77565: CALL_OW 274
77569: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77570: LD_ADDR_VAR 0 11
77574: PUSH
77575: LD_VAR 0 2
77579: PPUSH
77580: LD_VAR 0 1
77584: PPUSH
77585: CALL_OW 248
77589: PPUSH
77590: CALL_OW 450
77594: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77595: LD_VAR 0 10
77599: PPUSH
77600: LD_INT 1
77602: PPUSH
77603: CALL_OW 275
77607: PUSH
77608: LD_VAR 0 11
77612: PUSH
77613: LD_INT 1
77615: ARRAY
77616: GREATEREQUAL
77617: PUSH
77618: LD_VAR 0 10
77622: PPUSH
77623: LD_INT 2
77625: PPUSH
77626: CALL_OW 275
77630: PUSH
77631: LD_VAR 0 11
77635: PUSH
77636: LD_INT 2
77638: ARRAY
77639: GREATEREQUAL
77640: AND
77641: PUSH
77642: LD_VAR 0 10
77646: PPUSH
77647: LD_INT 3
77649: PPUSH
77650: CALL_OW 275
77654: PUSH
77655: LD_VAR 0 11
77659: PUSH
77660: LD_INT 3
77662: ARRAY
77663: GREATEREQUAL
77664: AND
77665: NOT
77666: IFFALSE 77670
// exit ;
77668: GO 78272
// if GetBType ( depot ) = b_depot then
77670: LD_VAR 0 1
77674: PPUSH
77675: CALL_OW 266
77679: PUSH
77680: LD_INT 0
77682: EQUAL
77683: IFFALSE 77695
// dist := 28 else
77685: LD_ADDR_VAR 0 14
77689: PUSH
77690: LD_INT 28
77692: ST_TO_ADDR
77693: GO 77703
// dist := 36 ;
77695: LD_ADDR_VAR 0 14
77699: PUSH
77700: LD_INT 36
77702: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77703: LD_VAR 0 1
77707: PPUSH
77708: LD_VAR 0 3
77712: PPUSH
77713: LD_VAR 0 4
77717: PPUSH
77718: CALL_OW 297
77722: PUSH
77723: LD_VAR 0 14
77727: GREATER
77728: IFFALSE 77732
// exit ;
77730: GO 78272
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77732: LD_ADDR_VAR 0 12
77736: PUSH
77737: LD_VAR 0 2
77741: PPUSH
77742: LD_VAR 0 3
77746: PPUSH
77747: LD_VAR 0 4
77751: PPUSH
77752: LD_VAR 0 5
77756: PPUSH
77757: LD_VAR 0 1
77761: PPUSH
77762: CALL_OW 248
77766: PPUSH
77767: LD_INT 0
77769: PPUSH
77770: CALL 78277 0 6
77774: ST_TO_ADDR
// if not hexes then
77775: LD_VAR 0 12
77779: NOT
77780: IFFALSE 77784
// exit ;
77782: GO 78272
// hex := GetHexInfo ( x , y ) ;
77784: LD_ADDR_VAR 0 15
77788: PUSH
77789: LD_VAR 0 3
77793: PPUSH
77794: LD_VAR 0 4
77798: PPUSH
77799: CALL_OW 546
77803: ST_TO_ADDR
// if hex [ 1 ] then
77804: LD_VAR 0 15
77808: PUSH
77809: LD_INT 1
77811: ARRAY
77812: IFFALSE 77816
// exit ;
77814: GO 78272
// height := hex [ 2 ] ;
77816: LD_ADDR_VAR 0 13
77820: PUSH
77821: LD_VAR 0 15
77825: PUSH
77826: LD_INT 2
77828: ARRAY
77829: ST_TO_ADDR
// for i = 1 to hexes do
77830: LD_ADDR_VAR 0 7
77834: PUSH
77835: DOUBLE
77836: LD_INT 1
77838: DEC
77839: ST_TO_ADDR
77840: LD_VAR 0 12
77844: PUSH
77845: FOR_TO
77846: IFFALSE 78176
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77848: LD_VAR 0 12
77852: PUSH
77853: LD_VAR 0 7
77857: ARRAY
77858: PUSH
77859: LD_INT 1
77861: ARRAY
77862: PPUSH
77863: LD_VAR 0 12
77867: PUSH
77868: LD_VAR 0 7
77872: ARRAY
77873: PUSH
77874: LD_INT 2
77876: ARRAY
77877: PPUSH
77878: CALL_OW 488
77882: NOT
77883: PUSH
77884: LD_VAR 0 12
77888: PUSH
77889: LD_VAR 0 7
77893: ARRAY
77894: PUSH
77895: LD_INT 1
77897: ARRAY
77898: PPUSH
77899: LD_VAR 0 12
77903: PUSH
77904: LD_VAR 0 7
77908: ARRAY
77909: PUSH
77910: LD_INT 2
77912: ARRAY
77913: PPUSH
77914: CALL_OW 428
77918: PUSH
77919: LD_INT 0
77921: GREATER
77922: OR
77923: PUSH
77924: LD_VAR 0 12
77928: PUSH
77929: LD_VAR 0 7
77933: ARRAY
77934: PUSH
77935: LD_INT 1
77937: ARRAY
77938: PPUSH
77939: LD_VAR 0 12
77943: PUSH
77944: LD_VAR 0 7
77948: ARRAY
77949: PUSH
77950: LD_INT 2
77952: ARRAY
77953: PPUSH
77954: CALL_OW 351
77958: OR
77959: IFFALSE 77965
// exit ;
77961: POP
77962: POP
77963: GO 78272
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77965: LD_ADDR_VAR 0 8
77969: PUSH
77970: LD_VAR 0 12
77974: PUSH
77975: LD_VAR 0 7
77979: ARRAY
77980: PUSH
77981: LD_INT 1
77983: ARRAY
77984: PPUSH
77985: LD_VAR 0 12
77989: PUSH
77990: LD_VAR 0 7
77994: ARRAY
77995: PUSH
77996: LD_INT 2
77998: ARRAY
77999: PPUSH
78000: CALL_OW 546
78004: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78005: LD_VAR 0 8
78009: PUSH
78010: LD_INT 1
78012: ARRAY
78013: PUSH
78014: LD_VAR 0 8
78018: PUSH
78019: LD_INT 2
78021: ARRAY
78022: PUSH
78023: LD_VAR 0 13
78027: PUSH
78028: LD_INT 2
78030: PLUS
78031: GREATER
78032: OR
78033: PUSH
78034: LD_VAR 0 8
78038: PUSH
78039: LD_INT 2
78041: ARRAY
78042: PUSH
78043: LD_VAR 0 13
78047: PUSH
78048: LD_INT 2
78050: MINUS
78051: LESS
78052: OR
78053: PUSH
78054: LD_VAR 0 8
78058: PUSH
78059: LD_INT 3
78061: ARRAY
78062: PUSH
78063: LD_INT 0
78065: PUSH
78066: LD_INT 8
78068: PUSH
78069: LD_INT 9
78071: PUSH
78072: LD_INT 10
78074: PUSH
78075: LD_INT 11
78077: PUSH
78078: LD_INT 12
78080: PUSH
78081: LD_INT 13
78083: PUSH
78084: LD_INT 16
78086: PUSH
78087: LD_INT 17
78089: PUSH
78090: LD_INT 18
78092: PUSH
78093: LD_INT 19
78095: PUSH
78096: LD_INT 20
78098: PUSH
78099: LD_INT 21
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: LIST
78106: LIST
78107: LIST
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: IN
78117: NOT
78118: OR
78119: PUSH
78120: LD_VAR 0 8
78124: PUSH
78125: LD_INT 5
78127: ARRAY
78128: NOT
78129: OR
78130: PUSH
78131: LD_VAR 0 8
78135: PUSH
78136: LD_INT 6
78138: ARRAY
78139: PUSH
78140: LD_INT 1
78142: PUSH
78143: LD_INT 2
78145: PUSH
78146: LD_INT 7
78148: PUSH
78149: LD_INT 9
78151: PUSH
78152: LD_INT 10
78154: PUSH
78155: LD_INT 11
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: IN
78166: NOT
78167: OR
78168: IFFALSE 78174
// exit ;
78170: POP
78171: POP
78172: GO 78272
// end ;
78174: GO 77845
78176: POP
78177: POP
// side := GetSide ( depot ) ;
78178: LD_ADDR_VAR 0 9
78182: PUSH
78183: LD_VAR 0 1
78187: PPUSH
78188: CALL_OW 255
78192: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78193: LD_VAR 0 9
78197: PPUSH
78198: LD_VAR 0 3
78202: PPUSH
78203: LD_VAR 0 4
78207: PPUSH
78208: LD_INT 20
78210: PPUSH
78211: CALL 70926 0 4
78215: PUSH
78216: LD_INT 4
78218: ARRAY
78219: IFFALSE 78223
// exit ;
78221: GO 78272
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78223: LD_VAR 0 2
78227: PUSH
78228: LD_INT 29
78230: PUSH
78231: LD_INT 30
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: IN
78238: PUSH
78239: LD_VAR 0 3
78243: PPUSH
78244: LD_VAR 0 4
78248: PPUSH
78249: LD_VAR 0 9
78253: PPUSH
78254: CALL_OW 440
78258: NOT
78259: AND
78260: IFFALSE 78264
// exit ;
78262: GO 78272
// result := true ;
78264: LD_ADDR_VAR 0 6
78268: PUSH
78269: LD_INT 1
78271: ST_TO_ADDR
// end ;
78272: LD_VAR 0 6
78276: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78277: LD_INT 0
78279: PPUSH
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
78288: PPUSH
78289: PPUSH
78290: PPUSH
78291: PPUSH
78292: PPUSH
78293: PPUSH
78294: PPUSH
78295: PPUSH
78296: PPUSH
78297: PPUSH
78298: PPUSH
78299: PPUSH
78300: PPUSH
78301: PPUSH
78302: PPUSH
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
78320: PPUSH
78321: PPUSH
78322: PPUSH
78323: PPUSH
78324: PPUSH
78325: PPUSH
78326: PPUSH
78327: PPUSH
78328: PPUSH
78329: PPUSH
78330: PPUSH
78331: PPUSH
78332: PPUSH
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
// result = [ ] ;
78337: LD_ADDR_VAR 0 7
78341: PUSH
78342: EMPTY
78343: ST_TO_ADDR
// temp_list = [ ] ;
78344: LD_ADDR_VAR 0 9
78348: PUSH
78349: EMPTY
78350: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78351: LD_VAR 0 4
78355: PUSH
78356: LD_INT 0
78358: PUSH
78359: LD_INT 1
78361: PUSH
78362: LD_INT 2
78364: PUSH
78365: LD_INT 3
78367: PUSH
78368: LD_INT 4
78370: PUSH
78371: LD_INT 5
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: IN
78382: NOT
78383: PUSH
78384: LD_VAR 0 1
78388: PUSH
78389: LD_INT 0
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: IN
78399: PUSH
78400: LD_VAR 0 5
78404: PUSH
78405: LD_INT 1
78407: PUSH
78408: LD_INT 2
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: LIST
78418: IN
78419: NOT
78420: AND
78421: OR
78422: IFFALSE 78426
// exit ;
78424: GO 96817
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78426: LD_VAR 0 1
78430: PUSH
78431: LD_INT 6
78433: PUSH
78434: LD_INT 7
78436: PUSH
78437: LD_INT 8
78439: PUSH
78440: LD_INT 13
78442: PUSH
78443: LD_INT 12
78445: PUSH
78446: LD_INT 15
78448: PUSH
78449: LD_INT 11
78451: PUSH
78452: LD_INT 14
78454: PUSH
78455: LD_INT 10
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: IN
78469: IFFALSE 78479
// btype = b_lab ;
78471: LD_ADDR_VAR 0 1
78475: PUSH
78476: LD_INT 6
78478: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78479: LD_VAR 0 6
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: LD_INT 1
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: LIST
78497: IN
78498: NOT
78499: PUSH
78500: LD_VAR 0 1
78504: PUSH
78505: LD_INT 0
78507: PUSH
78508: LD_INT 1
78510: PUSH
78511: LD_INT 2
78513: PUSH
78514: LD_INT 3
78516: PUSH
78517: LD_INT 6
78519: PUSH
78520: LD_INT 36
78522: PUSH
78523: LD_INT 4
78525: PUSH
78526: LD_INT 5
78528: PUSH
78529: LD_INT 31
78531: PUSH
78532: LD_INT 32
78534: PUSH
78535: LD_INT 33
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: IN
78551: NOT
78552: PUSH
78553: LD_VAR 0 6
78557: PUSH
78558: LD_INT 1
78560: EQUAL
78561: AND
78562: OR
78563: PUSH
78564: LD_VAR 0 1
78568: PUSH
78569: LD_INT 2
78571: PUSH
78572: LD_INT 3
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: IN
78579: NOT
78580: PUSH
78581: LD_VAR 0 6
78585: PUSH
78586: LD_INT 2
78588: EQUAL
78589: AND
78590: OR
78591: IFFALSE 78601
// mode = 0 ;
78593: LD_ADDR_VAR 0 6
78597: PUSH
78598: LD_INT 0
78600: ST_TO_ADDR
// case mode of 0 :
78601: LD_VAR 0 6
78605: PUSH
78606: LD_INT 0
78608: DOUBLE
78609: EQUAL
78610: IFTRUE 78614
78612: GO 90067
78614: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78615: LD_ADDR_VAR 0 11
78619: PUSH
78620: LD_INT 0
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: LD_INT 1
78635: NEG
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 1
78643: PUSH
78644: LD_INT 0
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 0
78663: PUSH
78664: LD_INT 1
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 1
78673: NEG
78674: PUSH
78675: LD_INT 0
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 1
78684: NEG
78685: PUSH
78686: LD_INT 1
78688: NEG
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 1
78696: NEG
78697: PUSH
78698: LD_INT 2
78700: NEG
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: PUSH
78706: LD_INT 0
78708: PUSH
78709: LD_INT 2
78711: NEG
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 1
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 1
78730: PUSH
78731: LD_INT 2
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 0
78740: PUSH
78741: LD_INT 2
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 1
78750: NEG
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 1
78761: PUSH
78762: LD_INT 3
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 0
78771: PUSH
78772: LD_INT 3
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 1
78781: NEG
78782: PUSH
78783: LD_INT 2
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78808: LD_ADDR_VAR 0 12
78812: PUSH
78813: LD_INT 0
78815: PUSH
78816: LD_INT 0
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 0
78825: PUSH
78826: LD_INT 1
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 1
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 1
78846: PUSH
78847: LD_INT 1
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 0
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 1
78866: NEG
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 1
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 1
78889: PUSH
78890: LD_INT 1
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 2
78900: PUSH
78901: LD_INT 0
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: LD_INT 2
78910: PUSH
78911: LD_INT 1
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 1
78920: NEG
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: NEG
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 2
78942: NEG
78943: PUSH
78944: LD_INT 1
78946: NEG
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 2
78954: NEG
78955: PUSH
78956: LD_INT 1
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 3
78965: NEG
78966: PUSH
78967: LD_INT 0
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: LD_INT 1
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79004: LD_ADDR_VAR 0 13
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: LD_INT 0
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 0
79021: PUSH
79022: LD_INT 1
79024: NEG
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 1
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 1
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: LD_INT 1
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 1
79062: NEG
79063: PUSH
79064: LD_INT 0
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 1
79073: NEG
79074: PUSH
79075: LD_INT 1
79077: NEG
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: LD_INT 2
79089: NEG
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 2
79097: PUSH
79098: LD_INT 1
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 2
79107: PUSH
79108: LD_INT 2
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 1
79117: PUSH
79118: LD_INT 2
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 2
79127: NEG
79128: PUSH
79129: LD_INT 1
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 2
79139: NEG
79140: PUSH
79141: LD_INT 2
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 2
79151: NEG
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: NEG
79164: PUSH
79165: LD_INT 2
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 3
79175: NEG
79176: PUSH
79177: LD_INT 3
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79203: LD_ADDR_VAR 0 14
79207: PUSH
79208: LD_INT 0
79210: PUSH
79211: LD_INT 0
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 0
79220: PUSH
79221: LD_INT 1
79223: NEG
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 1
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 1
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: LD_INT 1
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 1
79261: NEG
79262: PUSH
79263: LD_INT 0
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: LD_INT 1
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 1
79284: NEG
79285: PUSH
79286: LD_INT 2
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 0
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 1
79307: PUSH
79308: LD_INT 1
79310: NEG
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 1
79318: PUSH
79319: LD_INT 2
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: LD_INT 2
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: LD_INT 1
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: NEG
79350: PUSH
79351: LD_INT 3
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: LD_INT 3
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 1
79372: PUSH
79373: LD_INT 2
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79399: LD_ADDR_VAR 0 15
79403: PUSH
79404: LD_INT 0
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: LD_INT 1
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 1
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 0
79447: PUSH
79448: LD_INT 1
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 1
79457: NEG
79458: PUSH
79459: LD_INT 0
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 1
79468: NEG
79469: PUSH
79470: LD_INT 1
79472: NEG
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: LD_INT 1
79483: NEG
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: LD_INT 0
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 2
79501: PUSH
79502: LD_INT 1
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 1
79511: NEG
79512: PUSH
79513: LD_INT 1
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 2
79522: NEG
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 2
79533: NEG
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 2
79545: PUSH
79546: LD_INT 1
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 3
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 3
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79592: LD_ADDR_VAR 0 16
79596: PUSH
79597: LD_INT 0
79599: PUSH
79600: LD_INT 0
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: LD_INT 1
79612: NEG
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 1
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 1
79630: PUSH
79631: LD_INT 1
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 0
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 1
79650: NEG
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 1
79661: NEG
79662: PUSH
79663: LD_INT 1
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 1
79673: NEG
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 2
79685: PUSH
79686: LD_INT 1
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 2
79695: PUSH
79696: LD_INT 2
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 1
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 2
79715: NEG
79716: PUSH
79717: LD_INT 1
79719: NEG
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: LD_INT 2
79727: NEG
79728: PUSH
79729: LD_INT 2
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 3
79739: PUSH
79740: LD_INT 2
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 3
79749: PUSH
79750: LD_INT 3
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 2
79759: PUSH
79760: LD_INT 3
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79785: LD_ADDR_VAR 0 17
79789: PUSH
79790: LD_INT 0
79792: PUSH
79793: LD_INT 0
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 1
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 1
79823: PUSH
79824: LD_INT 1
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: LD_INT 1
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: LD_INT 1
79843: NEG
79844: PUSH
79845: LD_INT 0
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 1
79854: NEG
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 1
79866: NEG
79867: PUSH
79868: LD_INT 2
79870: NEG
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: LD_INT 2
79881: NEG
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: LD_INT 1
79889: PUSH
79890: LD_INT 1
79892: NEG
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 2
79900: PUSH
79901: LD_INT 0
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 2
79910: PUSH
79911: LD_INT 1
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 2
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: LD_INT 2
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 2
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 2
79961: NEG
79962: PUSH
79963: LD_INT 0
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 2
79972: NEG
79973: PUSH
79974: LD_INT 1
79976: NEG
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 2
79984: NEG
79985: PUSH
79986: LD_INT 2
79988: NEG
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80015: LD_ADDR_VAR 0 18
80019: PUSH
80020: LD_INT 0
80022: PUSH
80023: LD_INT 0
80025: PUSH
80026: EMPTY
80027: LIST
80028: LIST
80029: PUSH
80030: LD_INT 0
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 1
80043: PUSH
80044: LD_INT 0
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: LD_INT 1
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 0
80063: PUSH
80064: LD_INT 1
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: LD_INT 0
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 1
80084: NEG
80085: PUSH
80086: LD_INT 1
80088: NEG
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: LD_INT 2
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 0
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: LD_INT 1
80119: PUSH
80120: LD_INT 1
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 2
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 2
80140: PUSH
80141: LD_INT 1
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: LD_INT 2
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: LD_INT 2
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 0
80170: PUSH
80171: LD_INT 2
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 1
80180: NEG
80181: PUSH
80182: LD_INT 1
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 2
80191: NEG
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 2
80202: NEG
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 2
80214: NEG
80215: PUSH
80216: LD_INT 2
80218: NEG
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: LIST
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80245: LD_ADDR_VAR 0 19
80249: PUSH
80250: LD_INT 0
80252: PUSH
80253: LD_INT 0
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: LD_INT 1
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: PUSH
80274: LD_INT 0
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 1
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: LD_INT 1
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 1
80303: NEG
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 1
80314: NEG
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 0
80338: PUSH
80339: LD_INT 2
80341: NEG
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 1
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 2
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 2
80370: PUSH
80371: LD_INT 1
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: LD_INT 2
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: LD_INT 1
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 2
80421: NEG
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 2
80432: NEG
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 2
80444: NEG
80445: PUSH
80446: LD_INT 2
80448: NEG
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80475: LD_ADDR_VAR 0 20
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: LD_INT 0
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 1
80503: PUSH
80504: LD_INT 0
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 1
80513: PUSH
80514: LD_INT 1
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 0
80523: PUSH
80524: LD_INT 1
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 1
80533: NEG
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: LD_INT 2
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 0
80568: PUSH
80569: LD_INT 2
80571: NEG
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 1
80579: PUSH
80580: LD_INT 1
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 2
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 2
80600: PUSH
80601: LD_INT 1
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 2
80610: PUSH
80611: LD_INT 2
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 1
80620: PUSH
80621: LD_INT 2
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: LD_INT 2
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 1
80640: NEG
80641: PUSH
80642: LD_INT 1
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 2
80651: NEG
80652: PUSH
80653: LD_INT 0
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 2
80662: NEG
80663: PUSH
80664: LD_INT 1
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 2
80674: NEG
80675: PUSH
80676: LD_INT 2
80678: NEG
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80705: LD_ADDR_VAR 0 21
80709: PUSH
80710: LD_INT 0
80712: PUSH
80713: LD_INT 0
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 0
80722: PUSH
80723: LD_INT 1
80725: NEG
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 1
80733: PUSH
80734: LD_INT 0
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 1
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: LD_INT 1
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 1
80763: NEG
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 1
80774: NEG
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 1
80786: NEG
80787: PUSH
80788: LD_INT 2
80790: NEG
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 0
80798: PUSH
80799: LD_INT 2
80801: NEG
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 1
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 2
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 2
80830: PUSH
80831: LD_INT 1
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 2
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: LD_INT 2
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 0
80860: PUSH
80861: LD_INT 2
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 1
80870: NEG
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 2
80881: NEG
80882: PUSH
80883: LD_INT 0
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 2
80892: NEG
80893: PUSH
80894: LD_INT 1
80896: NEG
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 2
80904: NEG
80905: PUSH
80906: LD_INT 2
80908: NEG
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80935: LD_ADDR_VAR 0 22
80939: PUSH
80940: LD_INT 0
80942: PUSH
80943: LD_INT 0
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: LD_INT 1
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 1
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 0
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 1
80993: NEG
80994: PUSH
80995: LD_INT 0
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 1
81004: NEG
81005: PUSH
81006: LD_INT 1
81008: NEG
81009: PUSH
81010: EMPTY
81011: LIST
81012: LIST
81013: PUSH
81014: LD_INT 1
81016: NEG
81017: PUSH
81018: LD_INT 2
81020: NEG
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 0
81028: PUSH
81029: LD_INT 2
81031: NEG
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 1
81039: PUSH
81040: LD_INT 1
81042: NEG
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 2
81060: PUSH
81061: LD_INT 1
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 2
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: LD_INT 2
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 0
81090: PUSH
81091: LD_INT 2
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 1
81100: NEG
81101: PUSH
81102: LD_INT 1
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 2
81111: NEG
81112: PUSH
81113: LD_INT 0
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 2
81122: NEG
81123: PUSH
81124: LD_INT 1
81126: NEG
81127: PUSH
81128: EMPTY
81129: LIST
81130: LIST
81131: PUSH
81132: LD_INT 2
81134: NEG
81135: PUSH
81136: LD_INT 2
81138: NEG
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81165: LD_ADDR_VAR 0 23
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: LD_INT 1
81185: NEG
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: LD_INT 0
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 1
81203: PUSH
81204: LD_INT 1
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: LD_INT 1
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 1
81223: NEG
81224: PUSH
81225: LD_INT 0
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 1
81234: NEG
81235: PUSH
81236: LD_INT 1
81238: NEG
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: LD_INT 2
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 0
81258: PUSH
81259: LD_INT 2
81261: NEG
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 1
81269: PUSH
81270: LD_INT 1
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 2
81280: PUSH
81281: LD_INT 0
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 2
81290: PUSH
81291: LD_INT 1
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: LD_INT 2
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 1
81310: PUSH
81311: LD_INT 2
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 0
81320: PUSH
81321: LD_INT 2
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 1
81330: NEG
81331: PUSH
81332: LD_INT 1
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 2
81341: NEG
81342: PUSH
81343: LD_INT 0
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 2
81352: NEG
81353: PUSH
81354: LD_INT 1
81356: NEG
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: LD_INT 2
81368: NEG
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 2
81376: NEG
81377: PUSH
81378: LD_INT 3
81380: NEG
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 1
81388: NEG
81389: PUSH
81390: LD_INT 3
81392: NEG
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 1
81400: PUSH
81401: LD_INT 2
81403: NEG
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 2
81411: PUSH
81412: LD_INT 1
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81445: LD_ADDR_VAR 0 24
81449: PUSH
81450: LD_INT 0
81452: PUSH
81453: LD_INT 0
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: LD_INT 1
81465: NEG
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: PUSH
81474: LD_INT 0
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 1
81483: PUSH
81484: LD_INT 1
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 0
81493: PUSH
81494: LD_INT 1
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: NEG
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 1
81514: NEG
81515: PUSH
81516: LD_INT 1
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 2
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 0
81538: PUSH
81539: LD_INT 2
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: PUSH
81550: LD_INT 1
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: PUSH
81561: LD_INT 0
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 2
81570: PUSH
81571: LD_INT 1
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 2
81580: PUSH
81581: LD_INT 2
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 1
81590: PUSH
81591: LD_INT 2
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 0
81600: PUSH
81601: LD_INT 2
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 1
81610: NEG
81611: PUSH
81612: LD_INT 1
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 2
81621: NEG
81622: PUSH
81623: LD_INT 0
81625: PUSH
81626: EMPTY
81627: LIST
81628: LIST
81629: PUSH
81630: LD_INT 2
81632: NEG
81633: PUSH
81634: LD_INT 1
81636: NEG
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 2
81644: NEG
81645: PUSH
81646: LD_INT 2
81648: NEG
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 1
81656: PUSH
81657: LD_INT 2
81659: NEG
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 2
81667: PUSH
81668: LD_INT 1
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 3
81678: PUSH
81679: LD_INT 1
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 3
81688: PUSH
81689: LD_INT 2
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81721: LD_ADDR_VAR 0 25
81725: PUSH
81726: LD_INT 0
81728: PUSH
81729: LD_INT 0
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 0
81738: PUSH
81739: LD_INT 1
81741: NEG
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 1
81749: PUSH
81750: LD_INT 0
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: PUSH
81760: LD_INT 1
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: LD_INT 1
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 1
81779: NEG
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 1
81802: NEG
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 0
81814: PUSH
81815: LD_INT 2
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 2
81836: PUSH
81837: LD_INT 0
81839: PUSH
81840: EMPTY
81841: LIST
81842: LIST
81843: PUSH
81844: LD_INT 2
81846: PUSH
81847: LD_INT 1
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 2
81856: PUSH
81857: LD_INT 2
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: LD_INT 2
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 0
81876: PUSH
81877: LD_INT 2
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 1
81886: NEG
81887: PUSH
81888: LD_INT 1
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 2
81897: NEG
81898: PUSH
81899: LD_INT 0
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 2
81908: NEG
81909: PUSH
81910: LD_INT 1
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: LD_INT 2
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 3
81932: PUSH
81933: LD_INT 1
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 3
81942: PUSH
81943: LD_INT 2
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: LD_INT 3
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: LD_INT 3
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81995: LD_ADDR_VAR 0 26
81999: PUSH
82000: LD_INT 0
82002: PUSH
82003: LD_INT 0
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 0
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 1
82023: PUSH
82024: LD_INT 0
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 1
82033: PUSH
82034: LD_INT 1
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 0
82043: PUSH
82044: LD_INT 1
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 1
82053: NEG
82054: PUSH
82055: LD_INT 0
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: LD_INT 1
82068: NEG
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: LD_INT 2
82080: NEG
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 0
82088: PUSH
82089: LD_INT 2
82091: NEG
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: LD_INT 1
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 2
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 2
82120: PUSH
82121: LD_INT 1
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 2
82130: PUSH
82131: LD_INT 2
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 1
82140: PUSH
82141: LD_INT 2
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 0
82150: PUSH
82151: LD_INT 2
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: NEG
82161: PUSH
82162: LD_INT 1
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: NEG
82183: PUSH
82184: LD_INT 1
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 2
82194: NEG
82195: PUSH
82196: LD_INT 2
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 2
82206: PUSH
82207: LD_INT 3
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 1
82216: PUSH
82217: LD_INT 3
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: NEG
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 2
82237: NEG
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82271: LD_ADDR_VAR 0 27
82275: PUSH
82276: LD_INT 0
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 0
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 1
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 1
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 0
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 1
82329: NEG
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 1
82340: NEG
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 1
82352: NEG
82353: PUSH
82354: LD_INT 2
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 2
82367: NEG
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: LD_INT 1
82378: NEG
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 2
82386: PUSH
82387: LD_INT 0
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 2
82396: PUSH
82397: LD_INT 1
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: PUSH
82407: LD_INT 2
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 1
82416: PUSH
82417: LD_INT 2
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: NEG
82437: PUSH
82438: LD_INT 1
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 2
82447: NEG
82448: PUSH
82449: LD_INT 0
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 2
82458: NEG
82459: PUSH
82460: LD_INT 1
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 2
82470: NEG
82471: PUSH
82472: LD_INT 2
82474: NEG
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: LD_INT 2
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 2
82493: NEG
82494: PUSH
82495: LD_INT 1
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 3
82504: NEG
82505: PUSH
82506: LD_INT 1
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 3
82516: NEG
82517: PUSH
82518: LD_INT 2
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82551: LD_ADDR_VAR 0 28
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: LD_INT 0
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 0
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 1
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 1
82589: PUSH
82590: LD_INT 1
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: LD_INT 1
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: NEG
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 1
82620: NEG
82621: PUSH
82622: LD_INT 1
82624: NEG
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 1
82632: NEG
82633: PUSH
82634: LD_INT 2
82636: NEG
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 0
82644: PUSH
82645: LD_INT 2
82647: NEG
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 1
82655: PUSH
82656: LD_INT 1
82658: NEG
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 2
82666: PUSH
82667: LD_INT 0
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: PUSH
82674: LD_INT 2
82676: PUSH
82677: LD_INT 1
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 2
82686: PUSH
82687: LD_INT 2
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: LD_INT 2
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 2
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 1
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 2
82727: NEG
82728: PUSH
82729: LD_INT 0
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 2
82738: NEG
82739: PUSH
82740: LD_INT 1
82742: NEG
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: PUSH
82748: LD_INT 2
82750: NEG
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 2
82762: NEG
82763: PUSH
82764: LD_INT 3
82766: NEG
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 1
82774: NEG
82775: PUSH
82776: LD_INT 3
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 3
82786: NEG
82787: PUSH
82788: LD_INT 1
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 3
82798: NEG
82799: PUSH
82800: LD_INT 2
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82833: LD_ADDR_VAR 0 29
82837: PUSH
82838: LD_INT 0
82840: PUSH
82841: LD_INT 0
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 0
82850: PUSH
82851: LD_INT 1
82853: NEG
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 1
82861: PUSH
82862: LD_INT 0
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: PUSH
82872: LD_INT 1
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 0
82881: PUSH
82882: LD_INT 1
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: NEG
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: LD_INT 1
82906: NEG
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 1
82914: NEG
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 0
82926: PUSH
82927: LD_INT 2
82929: NEG
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 1
82937: PUSH
82938: LD_INT 1
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 2
82948: PUSH
82949: LD_INT 0
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 2
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 1
82968: PUSH
82969: LD_INT 2
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 0
82978: PUSH
82979: LD_INT 2
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 1
82988: NEG
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 2
82999: NEG
83000: PUSH
83001: LD_INT 1
83003: NEG
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 2
83011: NEG
83012: PUSH
83013: LD_INT 2
83015: NEG
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: LD_INT 3
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 2
83035: PUSH
83036: LD_INT 1
83038: NEG
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 3
83046: PUSH
83047: LD_INT 1
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 1
83056: PUSH
83057: LD_INT 3
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: LD_INT 2
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 3
83077: NEG
83078: PUSH
83079: LD_INT 2
83081: NEG
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83112: LD_ADDR_VAR 0 30
83116: PUSH
83117: LD_INT 0
83119: PUSH
83120: LD_INT 0
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 0
83129: PUSH
83130: LD_INT 1
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: LD_INT 0
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 1
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: NEG
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 1
83181: NEG
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: LD_INT 2
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: LD_INT 2
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 1
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 2
83227: PUSH
83228: LD_INT 0
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 2
83237: PUSH
83238: LD_INT 1
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: LD_INT 2
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 1
83257: PUSH
83258: LD_INT 2
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 1
83267: NEG
83268: PUSH
83269: LD_INT 1
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 2
83278: NEG
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: NEG
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: LD_INT 3
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: LD_INT 2
83316: NEG
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 3
83324: PUSH
83325: LD_INT 2
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 2
83334: PUSH
83335: LD_INT 3
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 2
83344: NEG
83345: PUSH
83346: LD_INT 1
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 3
83355: NEG
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83390: LD_ADDR_VAR 0 31
83394: PUSH
83395: LD_INT 0
83397: PUSH
83398: LD_INT 0
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 0
83407: PUSH
83408: LD_INT 1
83410: NEG
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 1
83418: PUSH
83419: LD_INT 0
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 1
83428: PUSH
83429: LD_INT 1
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 0
83438: PUSH
83439: LD_INT 1
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 1
83448: NEG
83449: PUSH
83450: LD_INT 0
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 1
83459: NEG
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: LD_INT 2
83475: NEG
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 1
83483: PUSH
83484: LD_INT 1
83486: NEG
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 2
83494: PUSH
83495: LD_INT 0
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 2
83504: PUSH
83505: LD_INT 1
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 2
83514: PUSH
83515: LD_INT 2
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 1
83524: PUSH
83525: LD_INT 2
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: LD_INT 2
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: LD_INT 1
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 2
83555: NEG
83556: PUSH
83557: LD_INT 1
83559: NEG
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 2
83567: NEG
83568: PUSH
83569: LD_INT 2
83571: NEG
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 2
83579: NEG
83580: PUSH
83581: LD_INT 3
83583: NEG
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 2
83591: PUSH
83592: LD_INT 1
83594: NEG
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 3
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 1
83612: PUSH
83613: LD_INT 3
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 2
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 3
83633: NEG
83634: PUSH
83635: LD_INT 2
83637: NEG
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83668: LD_ADDR_VAR 0 32
83672: PUSH
83673: LD_INT 0
83675: PUSH
83676: LD_INT 0
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: LD_INT 1
83688: NEG
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: PUSH
83694: LD_INT 1
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 1
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: LD_INT 1
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: LD_INT 1
83726: NEG
83727: PUSH
83728: LD_INT 0
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 1
83737: NEG
83738: PUSH
83739: LD_INT 1
83741: NEG
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: LD_INT 2
83753: NEG
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: LD_INT 2
83764: NEG
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 1
83772: PUSH
83773: LD_INT 1
83775: NEG
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 2
83783: PUSH
83784: LD_INT 1
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: LD_INT 2
83793: PUSH
83794: LD_INT 2
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 1
83803: PUSH
83804: LD_INT 2
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 0
83813: PUSH
83814: LD_INT 2
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 1
83823: NEG
83824: PUSH
83825: LD_INT 1
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 2
83834: NEG
83835: PUSH
83836: LD_INT 0
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: NEG
83846: PUSH
83847: LD_INT 1
83849: NEG
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: LD_INT 3
83861: NEG
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 1
83869: PUSH
83870: LD_INT 2
83872: NEG
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 3
83880: PUSH
83881: LD_INT 2
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 2
83890: PUSH
83891: LD_INT 3
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: LD_INT 2
83900: NEG
83901: PUSH
83902: LD_INT 1
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: PUSH
83909: LD_INT 3
83911: NEG
83912: PUSH
83913: LD_INT 1
83915: NEG
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83946: LD_ADDR_VAR 0 33
83950: PUSH
83951: LD_INT 0
83953: PUSH
83954: LD_INT 0
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 0
83963: PUSH
83964: LD_INT 1
83966: NEG
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 1
83974: PUSH
83975: LD_INT 0
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 1
83984: PUSH
83985: LD_INT 1
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: PUSH
83992: LD_INT 0
83994: PUSH
83995: LD_INT 1
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 1
84004: NEG
84005: PUSH
84006: LD_INT 0
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: LD_INT 1
84015: NEG
84016: PUSH
84017: LD_INT 1
84019: NEG
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 1
84027: NEG
84028: PUSH
84029: LD_INT 2
84031: NEG
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 1
84039: PUSH
84040: LD_INT 1
84042: NEG
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 2
84050: PUSH
84051: LD_INT 0
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 2
84060: PUSH
84061: LD_INT 1
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 1
84070: PUSH
84071: LD_INT 2
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 0
84080: PUSH
84081: LD_INT 2
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 1
84090: NEG
84091: PUSH
84092: LD_INT 1
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 2
84101: NEG
84102: PUSH
84103: LD_INT 0
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 2
84112: NEG
84113: PUSH
84114: LD_INT 1
84116: NEG
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 2
84124: NEG
84125: PUSH
84126: LD_INT 2
84128: NEG
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: LD_INT 3
84140: NEG
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 2
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 3
84159: PUSH
84160: LD_INT 1
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: PUSH
84170: LD_INT 3
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 1
84179: NEG
84180: PUSH
84181: LD_INT 2
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 3
84190: NEG
84191: PUSH
84192: LD_INT 2
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84225: LD_ADDR_VAR 0 34
84229: PUSH
84230: LD_INT 0
84232: PUSH
84233: LD_INT 0
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 0
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 1
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 1
84263: PUSH
84264: LD_INT 1
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 0
84273: PUSH
84274: LD_INT 1
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 1
84283: NEG
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 1
84294: NEG
84295: PUSH
84296: LD_INT 1
84298: NEG
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 1
84306: NEG
84307: PUSH
84308: LD_INT 2
84310: NEG
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: LD_INT 2
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: LD_INT 1
84332: NEG
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 2
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 2
84350: PUSH
84351: LD_INT 2
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: LD_INT 2
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 1
84370: NEG
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 2
84381: NEG
84382: PUSH
84383: LD_INT 0
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 2
84392: NEG
84393: PUSH
84394: LD_INT 1
84396: NEG
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 2
84404: NEG
84405: PUSH
84406: LD_INT 2
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 1
84416: NEG
84417: PUSH
84418: LD_INT 3
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: LD_INT 2
84431: NEG
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 3
84439: PUSH
84440: LD_INT 2
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 2
84449: PUSH
84450: LD_INT 3
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: LD_INT 1
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 3
84470: NEG
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84505: LD_ADDR_VAR 0 35
84509: PUSH
84510: LD_INT 0
84512: PUSH
84513: LD_INT 0
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: LD_INT 1
84525: NEG
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 1
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 1
84543: PUSH
84544: LD_INT 1
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: LD_INT 1
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 1
84563: NEG
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 1
84574: NEG
84575: PUSH
84576: LD_INT 1
84578: NEG
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 2
84586: PUSH
84587: LD_INT 1
84589: PUSH
84590: EMPTY
84591: LIST
84592: LIST
84593: PUSH
84594: LD_INT 2
84596: NEG
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84617: LD_ADDR_VAR 0 36
84621: PUSH
84622: LD_INT 0
84624: PUSH
84625: LD_INT 0
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: LD_INT 1
84637: NEG
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 1
84645: PUSH
84646: LD_INT 0
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: PUSH
84656: LD_INT 1
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: LD_INT 1
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 1
84675: NEG
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 1
84686: NEG
84687: PUSH
84688: LD_INT 1
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: LD_INT 2
84702: NEG
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 1
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84729: LD_ADDR_VAR 0 37
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: LD_INT 0
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: LD_INT 1
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: PUSH
84758: LD_INT 0
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 1
84767: PUSH
84768: LD_INT 1
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 0
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 1
84787: NEG
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 1
84798: NEG
84799: PUSH
84800: LD_INT 1
84802: NEG
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 1
84810: PUSH
84811: LD_INT 1
84813: NEG
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: PUSH
84819: LD_INT 1
84821: NEG
84822: PUSH
84823: LD_INT 1
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84841: LD_ADDR_VAR 0 38
84845: PUSH
84846: LD_INT 0
84848: PUSH
84849: LD_INT 0
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 0
84858: PUSH
84859: LD_INT 1
84861: NEG
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 1
84869: PUSH
84870: LD_INT 0
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 1
84879: PUSH
84880: LD_INT 1
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 1
84899: NEG
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 1
84910: NEG
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 2
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 2
84932: NEG
84933: PUSH
84934: LD_INT 1
84936: NEG
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84953: LD_ADDR_VAR 0 39
84957: PUSH
84958: LD_INT 0
84960: PUSH
84961: LD_INT 0
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 1
84981: PUSH
84982: LD_INT 0
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 1
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 1
85011: NEG
85012: PUSH
85013: LD_INT 0
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 1
85022: NEG
85023: PUSH
85024: LD_INT 1
85026: NEG
85027: PUSH
85028: EMPTY
85029: LIST
85030: LIST
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: LD_INT 2
85038: NEG
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: PUSH
85044: LD_INT 1
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85065: LD_ADDR_VAR 0 40
85069: PUSH
85070: LD_INT 0
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 0
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: PUSH
85094: LD_INT 0
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: LD_INT 0
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 1
85134: NEG
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 1
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 1
85157: NEG
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85177: LD_ADDR_VAR 0 41
85181: PUSH
85182: LD_INT 0
85184: PUSH
85185: LD_INT 0
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: LD_INT 1
85197: NEG
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: LD_INT 0
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: PUSH
85216: LD_INT 1
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: LD_INT 0
85225: PUSH
85226: LD_INT 1
85228: PUSH
85229: EMPTY
85230: LIST
85231: LIST
85232: PUSH
85233: LD_INT 1
85235: NEG
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 1
85246: NEG
85247: PUSH
85248: LD_INT 1
85250: NEG
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 1
85258: NEG
85259: PUSH
85260: LD_INT 2
85262: NEG
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: LD_INT 1
85273: NEG
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 2
85281: PUSH
85282: LD_INT 0
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 2
85291: PUSH
85292: LD_INT 1
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 2
85301: PUSH
85302: LD_INT 2
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 1
85311: PUSH
85312: LD_INT 2
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: NEG
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 2
85332: NEG
85333: PUSH
85334: LD_INT 0
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 2
85343: NEG
85344: PUSH
85345: LD_INT 1
85347: NEG
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 2
85355: NEG
85356: PUSH
85357: LD_INT 2
85359: NEG
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 2
85367: NEG
85368: PUSH
85369: LD_INT 3
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 2
85379: PUSH
85380: LD_INT 1
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 3
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 3
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 3
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 3
85420: PUSH
85421: LD_INT 3
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: PUSH
85431: LD_INT 3
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 2
85440: NEG
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 3
85451: NEG
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 3
85462: NEG
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 3
85474: NEG
85475: PUSH
85476: LD_INT 2
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 3
85486: NEG
85487: PUSH
85488: LD_INT 3
85490: NEG
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85527: LD_ADDR_VAR 0 42
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 1
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 1
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: NEG
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 1
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: LD_INT 2
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 2
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 2
85642: PUSH
85643: LD_INT 1
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 2
85652: PUSH
85653: LD_INT 2
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: PUSH
85663: LD_INT 2
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 0
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 1
85682: NEG
85683: PUSH
85684: LD_INT 1
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 2
85693: NEG
85694: PUSH
85695: LD_INT 1
85697: NEG
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 2
85705: NEG
85706: PUSH
85707: LD_INT 2
85709: NEG
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 2
85717: NEG
85718: PUSH
85719: LD_INT 3
85721: NEG
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 1
85729: NEG
85730: PUSH
85731: LD_INT 3
85733: NEG
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 0
85741: PUSH
85742: LD_INT 3
85744: NEG
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 1
85752: PUSH
85753: LD_INT 2
85755: NEG
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 3
85763: PUSH
85764: LD_INT 2
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PUSH
85771: LD_INT 3
85773: PUSH
85774: LD_INT 3
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 2
85783: PUSH
85784: LD_INT 3
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 1
85793: PUSH
85794: LD_INT 3
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 0
85803: PUSH
85804: LD_INT 3
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 1
85813: NEG
85814: PUSH
85815: LD_INT 2
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 3
85824: NEG
85825: PUSH
85826: LD_INT 2
85828: NEG
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 3
85836: NEG
85837: PUSH
85838: LD_INT 3
85840: NEG
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85877: LD_ADDR_VAR 0 43
85881: PUSH
85882: LD_INT 0
85884: PUSH
85885: LD_INT 0
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: LD_INT 0
85894: PUSH
85895: LD_INT 1
85897: NEG
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: PUSH
85903: LD_INT 1
85905: PUSH
85906: LD_INT 0
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: LD_INT 1
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 0
85925: PUSH
85926: LD_INT 1
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 1
85935: NEG
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 1
85946: NEG
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 1
85958: NEG
85959: PUSH
85960: LD_INT 2
85962: NEG
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 0
85970: PUSH
85971: LD_INT 2
85973: NEG
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 1
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 2
85992: PUSH
85993: LD_INT 0
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: PUSH
86000: LD_INT 2
86002: PUSH
86003: LD_INT 1
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: LD_INT 2
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 0
86022: PUSH
86023: LD_INT 2
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: PUSH
86034: LD_INT 1
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 2
86043: NEG
86044: PUSH
86045: LD_INT 0
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 2
86054: NEG
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: LD_INT 3
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 0
86078: PUSH
86079: LD_INT 3
86081: NEG
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 1
86089: PUSH
86090: LD_INT 2
86092: NEG
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: LD_INT 1
86103: NEG
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 3
86111: PUSH
86112: LD_INT 0
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PUSH
86119: LD_INT 3
86121: PUSH
86122: LD_INT 1
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 1
86131: PUSH
86132: LD_INT 3
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 0
86141: PUSH
86142: LD_INT 3
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: PUSH
86149: LD_INT 1
86151: NEG
86152: PUSH
86153: LD_INT 2
86155: PUSH
86156: EMPTY
86157: LIST
86158: LIST
86159: PUSH
86160: LD_INT 2
86162: NEG
86163: PUSH
86164: LD_INT 1
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 3
86173: NEG
86174: PUSH
86175: LD_INT 0
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 3
86184: NEG
86185: PUSH
86186: LD_INT 1
86188: NEG
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86225: LD_ADDR_VAR 0 44
86229: PUSH
86230: LD_INT 0
86232: PUSH
86233: LD_INT 0
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 0
86242: PUSH
86243: LD_INT 1
86245: NEG
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 1
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: PUSH
86264: LD_INT 1
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: LD_INT 1
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: LD_INT 1
86283: NEG
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 1
86294: NEG
86295: PUSH
86296: LD_INT 1
86298: NEG
86299: PUSH
86300: EMPTY
86301: LIST
86302: LIST
86303: PUSH
86304: LD_INT 1
86306: NEG
86307: PUSH
86308: LD_INT 2
86310: NEG
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 1
86318: PUSH
86319: LD_INT 1
86321: NEG
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 2
86329: PUSH
86330: LD_INT 0
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 1
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: PUSH
86350: LD_INT 2
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 2
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: LD_INT 1
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 2
86380: NEG
86381: PUSH
86382: LD_INT 0
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 2
86391: NEG
86392: PUSH
86393: LD_INT 1
86395: NEG
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 2
86403: NEG
86404: PUSH
86405: LD_INT 2
86407: NEG
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: PUSH
86413: LD_INT 2
86415: NEG
86416: PUSH
86417: LD_INT 3
86419: NEG
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 2
86427: PUSH
86428: LD_INT 1
86430: NEG
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 3
86438: PUSH
86439: LD_INT 0
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 3
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 3
86458: PUSH
86459: LD_INT 2
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 3
86468: PUSH
86469: LD_INT 3
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 2
86478: PUSH
86479: LD_INT 3
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 2
86488: NEG
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 3
86499: NEG
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 3
86510: NEG
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 3
86522: NEG
86523: PUSH
86524: LD_INT 2
86526: NEG
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 3
86534: NEG
86535: PUSH
86536: LD_INT 3
86538: NEG
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86575: LD_ADDR_VAR 0 45
86579: PUSH
86580: LD_INT 0
86582: PUSH
86583: LD_INT 0
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: LD_INT 1
86595: NEG
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: LD_INT 1
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 1
86633: NEG
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: NEG
86645: PUSH
86646: LD_INT 1
86648: NEG
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: LD_INT 2
86660: NEG
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: LD_INT 2
86671: NEG
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: LD_INT 1
86682: NEG
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 2
86690: PUSH
86691: LD_INT 1
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 2
86700: PUSH
86701: LD_INT 2
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: LD_INT 2
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: LD_INT 2
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 1
86730: NEG
86731: PUSH
86732: LD_INT 1
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PUSH
86739: LD_INT 2
86741: NEG
86742: PUSH
86743: LD_INT 1
86745: NEG
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 2
86753: NEG
86754: PUSH
86755: LD_INT 2
86757: NEG
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 2
86765: NEG
86766: PUSH
86767: LD_INT 3
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 1
86777: NEG
86778: PUSH
86779: LD_INT 3
86781: NEG
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 0
86789: PUSH
86790: LD_INT 3
86792: NEG
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 1
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 3
86811: PUSH
86812: LD_INT 2
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: LD_INT 3
86821: PUSH
86822: LD_INT 3
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 2
86831: PUSH
86832: LD_INT 3
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: LD_INT 3
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 0
86851: PUSH
86852: LD_INT 3
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 2
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 3
86872: NEG
86873: PUSH
86874: LD_INT 2
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 3
86884: NEG
86885: PUSH
86886: LD_INT 3
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86925: LD_ADDR_VAR 0 46
86929: PUSH
86930: LD_INT 0
86932: PUSH
86933: LD_INT 0
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: LD_INT 1
86945: NEG
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 1
86953: PUSH
86954: LD_INT 0
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 1
86963: PUSH
86964: LD_INT 1
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: LD_INT 1
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 1
86994: NEG
86995: PUSH
86996: LD_INT 1
86998: NEG
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 1
87006: NEG
87007: PUSH
87008: LD_INT 2
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 0
87018: PUSH
87019: LD_INT 2
87021: NEG
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 1
87029: PUSH
87030: LD_INT 1
87032: NEG
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 2
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 2
87050: PUSH
87051: LD_INT 1
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 1
87060: PUSH
87061: LD_INT 2
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 0
87070: PUSH
87071: LD_INT 2
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: NEG
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 2
87091: NEG
87092: PUSH
87093: LD_INT 0
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 2
87102: NEG
87103: PUSH
87104: LD_INT 1
87106: NEG
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: LD_INT 3
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: LD_INT 3
87129: NEG
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: PUSH
87138: LD_INT 2
87140: NEG
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 2
87148: PUSH
87149: LD_INT 1
87151: NEG
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 3
87159: PUSH
87160: LD_INT 0
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 3
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 1
87179: PUSH
87180: LD_INT 3
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PUSH
87187: LD_INT 0
87189: PUSH
87190: LD_INT 3
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: NEG
87200: PUSH
87201: LD_INT 2
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 2
87210: NEG
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 3
87221: NEG
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 3
87232: NEG
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87273: LD_ADDR_VAR 0 47
87277: PUSH
87278: LD_INT 0
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 0
87290: PUSH
87291: LD_INT 1
87293: NEG
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 1
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 1
87311: PUSH
87312: LD_INT 1
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: LD_INT 1
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: NEG
87332: PUSH
87333: LD_INT 0
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: NEG
87343: PUSH
87344: LD_INT 1
87346: NEG
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: LD_INT 2
87358: NEG
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: LD_INT 2
87369: NEG
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 1
87377: PUSH
87378: LD_INT 1
87380: NEG
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 2
87388: NEG
87389: PUSH
87390: LD_INT 1
87392: NEG
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_INT 2
87400: NEG
87401: PUSH
87402: LD_INT 2
87404: NEG
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87424: LD_ADDR_VAR 0 48
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: LD_INT 0
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: PUSH
87453: LD_INT 0
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: PUSH
87463: LD_INT 1
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 0
87472: PUSH
87473: LD_INT 1
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 1
87482: NEG
87483: PUSH
87484: LD_INT 0
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 1
87493: NEG
87494: PUSH
87495: LD_INT 1
87497: NEG
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 1
87505: NEG
87506: PUSH
87507: LD_INT 2
87509: NEG
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 0
87517: PUSH
87518: LD_INT 2
87520: NEG
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: PUSH
87529: LD_INT 1
87531: NEG
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 2
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 2
87549: PUSH
87550: LD_INT 1
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87571: LD_ADDR_VAR 0 49
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: LD_INT 0
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: LD_INT 1
87591: NEG
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: PUSH
87610: LD_INT 1
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: LD_INT 1
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 1
87629: NEG
87630: PUSH
87631: LD_INT 0
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: PUSH
87638: LD_INT 1
87640: NEG
87641: PUSH
87642: LD_INT 1
87644: NEG
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 1
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 2
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 2
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 2
87683: PUSH
87684: LD_INT 2
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87715: LD_ADDR_VAR 0 50
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: LD_INT 0
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 1
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 1
87753: PUSH
87754: LD_INT 1
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 0
87763: PUSH
87764: LD_INT 1
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: NEG
87774: PUSH
87775: LD_INT 0
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 1
87784: NEG
87785: PUSH
87786: LD_INT 1
87788: NEG
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 2
87796: PUSH
87797: LD_INT 1
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: LD_INT 2
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: PUSH
87817: LD_INT 2
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 0
87826: PUSH
87827: LD_INT 2
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: NEG
87837: PUSH
87838: LD_INT 1
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87859: LD_ADDR_VAR 0 51
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: LD_INT 1
87879: NEG
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PUSH
87885: LD_INT 1
87887: PUSH
87888: LD_INT 0
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: LD_INT 1
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 1
87917: NEG
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 1
87928: NEG
87929: PUSH
87930: LD_INT 1
87932: NEG
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 1
87940: PUSH
87941: LD_INT 2
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 0
87950: PUSH
87951: LD_INT 2
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: LD_INT 1
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: NEG
87972: PUSH
87973: LD_INT 0
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 2
87982: NEG
87983: PUSH
87984: LD_INT 1
87986: NEG
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88006: LD_ADDR_VAR 0 52
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 0
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 1
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 1
88044: PUSH
88045: LD_INT 1
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 0
88054: PUSH
88055: LD_INT 1
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 1
88064: NEG
88065: PUSH
88066: LD_INT 0
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: LD_INT 1
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 1
88087: NEG
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 1
88099: NEG
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 2
88110: NEG
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 2
88121: NEG
88122: PUSH
88123: LD_INT 1
88125: NEG
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 2
88133: NEG
88134: PUSH
88135: LD_INT 2
88137: NEG
88138: PUSH
88139: EMPTY
88140: LIST
88141: LIST
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88157: LD_ADDR_VAR 0 53
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: LD_INT 0
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 1
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 0
88205: PUSH
88206: LD_INT 1
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 1
88215: NEG
88216: PUSH
88217: LD_INT 0
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 1
88226: NEG
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 1
88238: NEG
88239: PUSH
88240: LD_INT 2
88242: NEG
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 0
88250: PUSH
88251: LD_INT 2
88253: NEG
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 1
88261: PUSH
88262: LD_INT 1
88264: NEG
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: LD_INT 0
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: PUSH
88283: LD_INT 1
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 2
88292: PUSH
88293: LD_INT 2
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 1
88302: PUSH
88303: LD_INT 2
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 0
88312: PUSH
88313: LD_INT 2
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 1
88322: NEG
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 2
88333: NEG
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: LD_INT 1
88348: NEG
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 2
88356: NEG
88357: PUSH
88358: LD_INT 2
88360: NEG
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88387: LD_ADDR_VAR 0 54
88391: PUSH
88392: LD_INT 0
88394: PUSH
88395: LD_INT 0
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: LD_INT 0
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: LD_INT 1
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 1
88425: PUSH
88426: LD_INT 1
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 0
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 1
88445: NEG
88446: PUSH
88447: LD_INT 0
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 1
88456: NEG
88457: PUSH
88458: LD_INT 1
88460: NEG
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: LD_INT 2
88472: NEG
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: LD_INT 2
88483: NEG
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 1
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 2
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 2
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 2
88522: PUSH
88523: LD_INT 2
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: PUSH
88533: LD_INT 2
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 0
88542: PUSH
88543: LD_INT 2
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: NEG
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 2
88563: NEG
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 2
88574: NEG
88575: PUSH
88576: LD_INT 1
88578: NEG
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 2
88586: NEG
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88617: LD_ADDR_VAR 0 55
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: LD_INT 0
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: PUSH
88632: LD_INT 0
88634: PUSH
88635: LD_INT 1
88637: NEG
88638: PUSH
88639: EMPTY
88640: LIST
88641: LIST
88642: PUSH
88643: LD_INT 1
88645: PUSH
88646: LD_INT 0
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 1
88655: PUSH
88656: LD_INT 1
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 0
88665: PUSH
88666: LD_INT 1
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 1
88675: NEG
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: NEG
88687: PUSH
88688: LD_INT 1
88690: NEG
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 1
88698: NEG
88699: PUSH
88700: LD_INT 2
88702: NEG
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_INT 2
88713: NEG
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: LD_INT 1
88724: NEG
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 2
88732: PUSH
88733: LD_INT 0
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 2
88742: PUSH
88743: LD_INT 1
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 2
88752: PUSH
88753: LD_INT 2
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 1
88762: PUSH
88763: LD_INT 2
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: LD_INT 2
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 1
88782: NEG
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 2
88793: NEG
88794: PUSH
88795: LD_INT 0
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 2
88804: NEG
88805: PUSH
88806: LD_INT 1
88808: NEG
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 2
88816: NEG
88817: PUSH
88818: LD_INT 2
88820: NEG
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88847: LD_ADDR_VAR 0 56
88851: PUSH
88852: LD_INT 0
88854: PUSH
88855: LD_INT 0
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: LD_INT 1
88867: NEG
88868: PUSH
88869: EMPTY
88870: LIST
88871: LIST
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: LD_INT 0
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PUSH
88883: LD_INT 1
88885: PUSH
88886: LD_INT 1
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: LD_INT 1
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 1
88905: NEG
88906: PUSH
88907: LD_INT 0
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 1
88916: NEG
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: LD_INT 2
88932: NEG
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 0
88940: PUSH
88941: LD_INT 2
88943: NEG
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 1
88951: PUSH
88952: LD_INT 1
88954: NEG
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 2
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 2
88972: PUSH
88973: LD_INT 1
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 2
88982: PUSH
88983: LD_INT 2
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 1
88992: PUSH
88993: LD_INT 2
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 0
89002: PUSH
89003: LD_INT 2
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 1
89012: NEG
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 2
89023: NEG
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 2
89034: NEG
89035: PUSH
89036: LD_INT 1
89038: NEG
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 2
89046: NEG
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89077: LD_ADDR_VAR 0 57
89081: PUSH
89082: LD_INT 0
89084: PUSH
89085: LD_INT 0
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: LD_INT 1
89105: PUSH
89106: LD_INT 0
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 1
89115: PUSH
89116: LD_INT 1
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 1
89135: NEG
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 1
89146: NEG
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: LD_INT 2
89162: NEG
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 0
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: LD_INT 1
89184: NEG
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 2
89192: PUSH
89193: LD_INT 0
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 2
89202: PUSH
89203: LD_INT 1
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 2
89212: PUSH
89213: LD_INT 2
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 1
89222: PUSH
89223: LD_INT 2
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 0
89232: PUSH
89233: LD_INT 2
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: LD_INT 1
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 2
89253: NEG
89254: PUSH
89255: LD_INT 0
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: LD_INT 2
89264: NEG
89265: PUSH
89266: LD_INT 1
89268: NEG
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 2
89276: NEG
89277: PUSH
89278: LD_INT 2
89280: NEG
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89307: LD_ADDR_VAR 0 58
89311: PUSH
89312: LD_INT 0
89314: PUSH
89315: LD_INT 0
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 0
89324: PUSH
89325: LD_INT 1
89327: NEG
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 1
89335: PUSH
89336: LD_INT 0
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 1
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: LD_INT 1
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: LD_INT 0
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: PUSH
89374: LD_INT 1
89376: NEG
89377: PUSH
89378: LD_INT 1
89380: NEG
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: LD_INT 2
89392: NEG
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: LD_INT 2
89403: NEG
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 1
89411: PUSH
89412: LD_INT 1
89414: NEG
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 2
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 2
89432: PUSH
89433: LD_INT 1
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: LD_INT 2
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 1
89452: PUSH
89453: LD_INT 2
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: LD_INT 2
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 1
89472: NEG
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: LD_INT 2
89483: NEG
89484: PUSH
89485: LD_INT 0
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 2
89494: NEG
89495: PUSH
89496: LD_INT 1
89498: NEG
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: LD_INT 2
89506: NEG
89507: PUSH
89508: LD_INT 2
89510: NEG
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89537: LD_ADDR_VAR 0 59
89541: PUSH
89542: LD_INT 0
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: LD_INT 1
89557: NEG
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 1
89565: PUSH
89566: LD_INT 0
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: LD_INT 1
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 1
89595: NEG
89596: PUSH
89597: LD_INT 0
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: NEG
89607: PUSH
89608: LD_INT 1
89610: NEG
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89625: LD_ADDR_VAR 0 60
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: LD_INT 0
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: LD_INT 1
89645: NEG
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 1
89653: PUSH
89654: LD_INT 0
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: LD_INT 1
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 0
89673: PUSH
89674: LD_INT 1
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 1
89683: NEG
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: LD_INT 1
89694: NEG
89695: PUSH
89696: LD_INT 1
89698: NEG
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89713: LD_ADDR_VAR 0 61
89717: PUSH
89718: LD_INT 0
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: LD_INT 1
89733: NEG
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: LD_INT 0
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: LD_INT 1
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 1
89782: NEG
89783: PUSH
89784: LD_INT 1
89786: NEG
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89801: LD_ADDR_VAR 0 62
89805: PUSH
89806: LD_INT 0
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 1
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: LD_INT 1
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: LD_INT 1
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89889: LD_ADDR_VAR 0 63
89893: PUSH
89894: LD_INT 0
89896: PUSH
89897: LD_INT 0
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 0
89906: PUSH
89907: LD_INT 1
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 1
89927: PUSH
89928: LD_INT 1
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 0
89937: PUSH
89938: LD_INT 1
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 1
89947: NEG
89948: PUSH
89949: LD_INT 0
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 1
89958: NEG
89959: PUSH
89960: LD_INT 1
89962: NEG
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89977: LD_ADDR_VAR 0 64
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: LD_INT 1
89997: NEG
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: PUSH
90006: LD_INT 0
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 1
90015: PUSH
90016: LD_INT 1
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 0
90025: PUSH
90026: LD_INT 1
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: LD_INT 0
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: LD_INT 1
90050: NEG
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: ST_TO_ADDR
// end ; 1 :
90065: GO 95962
90067: LD_INT 1
90069: DOUBLE
90070: EQUAL
90071: IFTRUE 90075
90073: GO 92698
90075: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90076: LD_ADDR_VAR 0 11
90080: PUSH
90081: LD_INT 1
90083: NEG
90084: PUSH
90085: LD_INT 3
90087: NEG
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 0
90095: PUSH
90096: LD_INT 3
90098: NEG
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: LD_INT 2
90109: NEG
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: LIST
90119: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90120: LD_ADDR_VAR 0 12
90124: PUSH
90125: LD_INT 2
90127: PUSH
90128: LD_INT 1
90130: NEG
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 3
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 3
90148: PUSH
90149: LD_INT 1
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: LIST
90160: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90161: LD_ADDR_VAR 0 13
90165: PUSH
90166: LD_INT 3
90168: PUSH
90169: LD_INT 2
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 3
90178: PUSH
90179: LD_INT 3
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 2
90188: PUSH
90189: LD_INT 3
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: LIST
90200: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90201: LD_ADDR_VAR 0 14
90205: PUSH
90206: LD_INT 1
90208: PUSH
90209: LD_INT 3
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 0
90218: PUSH
90219: LD_INT 3
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PUSH
90226: LD_INT 1
90228: NEG
90229: PUSH
90230: LD_INT 2
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: EMPTY
90238: LIST
90239: LIST
90240: LIST
90241: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90242: LD_ADDR_VAR 0 15
90246: PUSH
90247: LD_INT 2
90249: NEG
90250: PUSH
90251: LD_INT 1
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 3
90260: NEG
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 3
90271: NEG
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: LIST
90285: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90286: LD_ADDR_VAR 0 16
90290: PUSH
90291: LD_INT 2
90293: NEG
90294: PUSH
90295: LD_INT 3
90297: NEG
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 3
90305: NEG
90306: PUSH
90307: LD_INT 2
90309: NEG
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: LD_INT 3
90317: NEG
90318: PUSH
90319: LD_INT 3
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: LIST
90331: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90332: LD_ADDR_VAR 0 17
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 3
90343: NEG
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 0
90351: PUSH
90352: LD_INT 3
90354: NEG
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PUSH
90360: LD_INT 1
90362: PUSH
90363: LD_INT 2
90365: NEG
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: LIST
90375: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90376: LD_ADDR_VAR 0 18
90380: PUSH
90381: LD_INT 2
90383: PUSH
90384: LD_INT 1
90386: NEG
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 3
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 3
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90417: LD_ADDR_VAR 0 19
90421: PUSH
90422: LD_INT 3
90424: PUSH
90425: LD_INT 2
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 3
90434: PUSH
90435: LD_INT 3
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 2
90444: PUSH
90445: LD_INT 3
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90457: LD_ADDR_VAR 0 20
90461: PUSH
90462: LD_INT 1
90464: PUSH
90465: LD_INT 3
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 3
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: LIST
90497: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90498: LD_ADDR_VAR 0 21
90502: PUSH
90503: LD_INT 2
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 3
90516: NEG
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 3
90527: NEG
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: LIST
90541: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90542: LD_ADDR_VAR 0 22
90546: PUSH
90547: LD_INT 2
90549: NEG
90550: PUSH
90551: LD_INT 3
90553: NEG
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 3
90561: NEG
90562: PUSH
90563: LD_INT 2
90565: NEG
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 3
90573: NEG
90574: PUSH
90575: LD_INT 3
90577: NEG
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: LIST
90587: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90588: LD_ADDR_VAR 0 23
90592: PUSH
90593: LD_INT 0
90595: PUSH
90596: LD_INT 3
90598: NEG
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 1
90606: NEG
90607: PUSH
90608: LD_INT 4
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 1
90618: PUSH
90619: LD_INT 3
90621: NEG
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: LIST
90631: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90632: LD_ADDR_VAR 0 24
90636: PUSH
90637: LD_INT 3
90639: PUSH
90640: LD_INT 0
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 3
90649: PUSH
90650: LD_INT 1
90652: NEG
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 4
90660: PUSH
90661: LD_INT 1
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: LIST
90672: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90673: LD_ADDR_VAR 0 25
90677: PUSH
90678: LD_INT 3
90680: PUSH
90681: LD_INT 3
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 4
90690: PUSH
90691: LD_INT 3
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 3
90700: PUSH
90701: LD_INT 4
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: LIST
90712: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90713: LD_ADDR_VAR 0 26
90717: PUSH
90718: LD_INT 0
90720: PUSH
90721: LD_INT 3
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: LD_INT 4
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 1
90740: NEG
90741: PUSH
90742: LD_INT 3
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: LIST
90753: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90754: LD_ADDR_VAR 0 27
90758: PUSH
90759: LD_INT 3
90761: NEG
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 3
90772: NEG
90773: PUSH
90774: LD_INT 1
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 4
90783: NEG
90784: PUSH
90785: LD_INT 1
90787: NEG
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: LIST
90797: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90798: LD_ADDR_VAR 0 28
90802: PUSH
90803: LD_INT 3
90805: NEG
90806: PUSH
90807: LD_INT 3
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 3
90817: NEG
90818: PUSH
90819: LD_INT 4
90821: NEG
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 4
90829: NEG
90830: PUSH
90831: LD_INT 3
90833: NEG
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: LIST
90843: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90844: LD_ADDR_VAR 0 29
90848: PUSH
90849: LD_INT 1
90851: NEG
90852: PUSH
90853: LD_INT 3
90855: NEG
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: LD_INT 3
90866: NEG
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: LD_INT 2
90877: NEG
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: LD_INT 4
90889: NEG
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 0
90897: PUSH
90898: LD_INT 4
90900: NEG
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 1
90908: PUSH
90909: LD_INT 3
90911: NEG
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 1
90919: NEG
90920: PUSH
90921: LD_INT 5
90923: NEG
90924: PUSH
90925: EMPTY
90926: LIST
90927: LIST
90928: PUSH
90929: LD_INT 0
90931: PUSH
90932: LD_INT 5
90934: NEG
90935: PUSH
90936: EMPTY
90937: LIST
90938: LIST
90939: PUSH
90940: LD_INT 1
90942: PUSH
90943: LD_INT 4
90945: NEG
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: PUSH
90951: LD_INT 1
90953: NEG
90954: PUSH
90955: LD_INT 6
90957: NEG
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 0
90965: PUSH
90966: LD_INT 6
90968: NEG
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 1
90976: PUSH
90977: LD_INT 5
90979: NEG
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90999: LD_ADDR_VAR 0 30
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: LD_INT 1
91009: NEG
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 3
91017: PUSH
91018: LD_INT 0
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 3
91027: PUSH
91028: LD_INT 1
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PUSH
91035: LD_INT 3
91037: PUSH
91038: LD_INT 1
91040: NEG
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 4
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 4
91058: PUSH
91059: LD_INT 1
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 4
91068: PUSH
91069: LD_INT 1
91071: NEG
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 5
91079: PUSH
91080: LD_INT 0
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PUSH
91087: LD_INT 5
91089: PUSH
91090: LD_INT 1
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 5
91099: PUSH
91100: LD_INT 1
91102: NEG
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 6
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 6
91120: PUSH
91121: LD_INT 1
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91142: LD_ADDR_VAR 0 31
91146: PUSH
91147: LD_INT 3
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 3
91159: PUSH
91160: LD_INT 3
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 2
91169: PUSH
91170: LD_INT 3
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: PUSH
91177: LD_INT 4
91179: PUSH
91180: LD_INT 3
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 4
91189: PUSH
91190: LD_INT 4
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 3
91199: PUSH
91200: LD_INT 4
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 5
91209: PUSH
91210: LD_INT 4
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 5
91219: PUSH
91220: LD_INT 5
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 4
91229: PUSH
91230: LD_INT 5
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 6
91239: PUSH
91240: LD_INT 5
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 6
91249: PUSH
91250: LD_INT 6
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 5
91259: PUSH
91260: LD_INT 6
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91281: LD_ADDR_VAR 0 32
91285: PUSH
91286: LD_INT 1
91288: PUSH
91289: LD_INT 3
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: LD_INT 3
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 1
91308: NEG
91309: PUSH
91310: LD_INT 2
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: PUSH
91320: LD_INT 4
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 0
91329: PUSH
91330: LD_INT 4
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 1
91339: NEG
91340: PUSH
91341: LD_INT 3
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 1
91350: PUSH
91351: LD_INT 5
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 0
91360: PUSH
91361: LD_INT 5
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: NEG
91371: PUSH
91372: LD_INT 4
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 1
91381: PUSH
91382: LD_INT 6
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PUSH
91389: LD_INT 0
91391: PUSH
91392: LD_INT 6
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 1
91401: NEG
91402: PUSH
91403: LD_INT 5
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91424: LD_ADDR_VAR 0 33
91428: PUSH
91429: LD_INT 2
91431: NEG
91432: PUSH
91433: LD_INT 1
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 3
91442: NEG
91443: PUSH
91444: LD_INT 0
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 3
91453: NEG
91454: PUSH
91455: LD_INT 1
91457: NEG
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: PUSH
91463: LD_INT 3
91465: NEG
91466: PUSH
91467: LD_INT 1
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: PUSH
91474: LD_INT 4
91476: NEG
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 4
91487: NEG
91488: PUSH
91489: LD_INT 1
91491: NEG
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 4
91499: NEG
91500: PUSH
91501: LD_INT 1
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: LD_INT 5
91510: NEG
91511: PUSH
91512: LD_INT 0
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 5
91521: NEG
91522: PUSH
91523: LD_INT 1
91525: NEG
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 5
91533: NEG
91534: PUSH
91535: LD_INT 1
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: PUSH
91542: LD_INT 6
91544: NEG
91545: PUSH
91546: LD_INT 0
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 6
91555: NEG
91556: PUSH
91557: LD_INT 1
91559: NEG
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91579: LD_ADDR_VAR 0 34
91583: PUSH
91584: LD_INT 2
91586: NEG
91587: PUSH
91588: LD_INT 3
91590: NEG
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 3
91598: NEG
91599: PUSH
91600: LD_INT 2
91602: NEG
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: LD_INT 3
91610: NEG
91611: PUSH
91612: LD_INT 3
91614: NEG
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 3
91622: NEG
91623: PUSH
91624: LD_INT 4
91626: NEG
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 4
91634: NEG
91635: PUSH
91636: LD_INT 3
91638: NEG
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 4
91646: NEG
91647: PUSH
91648: LD_INT 4
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 4
91658: NEG
91659: PUSH
91660: LD_INT 5
91662: NEG
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 5
91670: NEG
91671: PUSH
91672: LD_INT 4
91674: NEG
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 5
91682: NEG
91683: PUSH
91684: LD_INT 5
91686: NEG
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 5
91694: NEG
91695: PUSH
91696: LD_INT 6
91698: NEG
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 6
91706: NEG
91707: PUSH
91708: LD_INT 5
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 6
91718: NEG
91719: PUSH
91720: LD_INT 6
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91742: LD_ADDR_VAR 0 41
91746: PUSH
91747: LD_INT 0
91749: PUSH
91750: LD_INT 2
91752: NEG
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 1
91760: NEG
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 1
91772: PUSH
91773: LD_INT 2
91775: NEG
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91786: LD_ADDR_VAR 0 42
91790: PUSH
91791: LD_INT 2
91793: PUSH
91794: LD_INT 0
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 2
91803: PUSH
91804: LD_INT 1
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 3
91814: PUSH
91815: LD_INT 1
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: LIST
91826: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91827: LD_ADDR_VAR 0 43
91831: PUSH
91832: LD_INT 2
91834: PUSH
91835: LD_INT 2
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: LD_INT 2
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: LIST
91866: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91867: LD_ADDR_VAR 0 44
91871: PUSH
91872: LD_INT 0
91874: PUSH
91875: LD_INT 2
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 1
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 1
91894: NEG
91895: PUSH
91896: LD_INT 2
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: LIST
91907: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91908: LD_ADDR_VAR 0 45
91912: PUSH
91913: LD_INT 2
91915: NEG
91916: PUSH
91917: LD_INT 0
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 2
91926: NEG
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 3
91937: NEG
91938: PUSH
91939: LD_INT 1
91941: NEG
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: LIST
91951: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91952: LD_ADDR_VAR 0 46
91956: PUSH
91957: LD_INT 2
91959: NEG
91960: PUSH
91961: LD_INT 2
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 2
91971: NEG
91972: PUSH
91973: LD_INT 3
91975: NEG
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: NEG
91984: PUSH
91985: LD_INT 2
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91998: LD_ADDR_VAR 0 47
92002: PUSH
92003: LD_INT 2
92005: NEG
92006: PUSH
92007: LD_INT 3
92009: NEG
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 1
92017: NEG
92018: PUSH
92019: LD_INT 3
92021: NEG
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92031: LD_ADDR_VAR 0 48
92035: PUSH
92036: LD_INT 1
92038: PUSH
92039: LD_INT 2
92041: NEG
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 2
92049: PUSH
92050: LD_INT 1
92052: NEG
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92062: LD_ADDR_VAR 0 49
92066: PUSH
92067: LD_INT 3
92069: PUSH
92070: LD_INT 1
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: PUSH
92077: LD_INT 3
92079: PUSH
92080: LD_INT 2
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92091: LD_ADDR_VAR 0 50
92095: PUSH
92096: LD_INT 2
92098: PUSH
92099: LD_INT 3
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: PUSH
92109: LD_INT 3
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92120: LD_ADDR_VAR 0 51
92124: PUSH
92125: LD_INT 1
92127: NEG
92128: PUSH
92129: LD_INT 2
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: PUSH
92136: LD_INT 2
92138: NEG
92139: PUSH
92140: LD_INT 1
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92151: LD_ADDR_VAR 0 52
92155: PUSH
92156: LD_INT 3
92158: NEG
92159: PUSH
92160: LD_INT 1
92162: NEG
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: LD_INT 3
92170: NEG
92171: PUSH
92172: LD_INT 2
92174: NEG
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92184: LD_ADDR_VAR 0 53
92188: PUSH
92189: LD_INT 1
92191: NEG
92192: PUSH
92193: LD_INT 3
92195: NEG
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 0
92203: PUSH
92204: LD_INT 3
92206: NEG
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 1
92214: PUSH
92215: LD_INT 2
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: LIST
92227: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92228: LD_ADDR_VAR 0 54
92232: PUSH
92233: LD_INT 2
92235: PUSH
92236: LD_INT 1
92238: NEG
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: PUSH
92244: LD_INT 3
92246: PUSH
92247: LD_INT 0
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PUSH
92254: LD_INT 3
92256: PUSH
92257: LD_INT 1
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: LIST
92268: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92269: LD_ADDR_VAR 0 55
92273: PUSH
92274: LD_INT 3
92276: PUSH
92277: LD_INT 2
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 3
92286: PUSH
92287: LD_INT 3
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 2
92296: PUSH
92297: LD_INT 3
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: LIST
92308: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92309: LD_ADDR_VAR 0 56
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: LD_INT 3
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 0
92326: PUSH
92327: LD_INT 3
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 1
92336: NEG
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: LIST
92349: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92350: LD_ADDR_VAR 0 57
92354: PUSH
92355: LD_INT 2
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 3
92368: NEG
92369: PUSH
92370: LD_INT 0
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 3
92379: NEG
92380: PUSH
92381: LD_INT 1
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: LIST
92393: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92394: LD_ADDR_VAR 0 58
92398: PUSH
92399: LD_INT 2
92401: NEG
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 3
92413: NEG
92414: PUSH
92415: LD_INT 2
92417: NEG
92418: PUSH
92419: EMPTY
92420: LIST
92421: LIST
92422: PUSH
92423: LD_INT 3
92425: NEG
92426: PUSH
92427: LD_INT 3
92429: NEG
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: LIST
92439: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92440: LD_ADDR_VAR 0 59
92444: PUSH
92445: LD_INT 1
92447: NEG
92448: PUSH
92449: LD_INT 2
92451: NEG
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 0
92459: PUSH
92460: LD_INT 2
92462: NEG
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 1
92470: PUSH
92471: LD_INT 1
92473: NEG
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: LIST
92483: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92484: LD_ADDR_VAR 0 60
92488: PUSH
92489: LD_INT 1
92491: PUSH
92492: LD_INT 1
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 2
92502: PUSH
92503: LD_INT 0
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 2
92512: PUSH
92513: LD_INT 1
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: LIST
92524: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92525: LD_ADDR_VAR 0 61
92529: PUSH
92530: LD_INT 2
92532: PUSH
92533: LD_INT 1
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 2
92542: PUSH
92543: LD_INT 2
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: PUSH
92550: LD_INT 1
92552: PUSH
92553: LD_INT 2
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: LIST
92564: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92565: LD_ADDR_VAR 0 62
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: LD_INT 2
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 0
92582: PUSH
92583: LD_INT 2
92585: PUSH
92586: EMPTY
92587: LIST
92588: LIST
92589: PUSH
92590: LD_INT 1
92592: NEG
92593: PUSH
92594: LD_INT 1
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: LIST
92605: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92606: LD_ADDR_VAR 0 63
92610: PUSH
92611: LD_INT 1
92613: NEG
92614: PUSH
92615: LD_INT 1
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 2
92624: NEG
92625: PUSH
92626: LD_INT 0
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: PUSH
92633: LD_INT 2
92635: NEG
92636: PUSH
92637: LD_INT 1
92639: NEG
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: LIST
92649: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92650: LD_ADDR_VAR 0 64
92654: PUSH
92655: LD_INT 1
92657: NEG
92658: PUSH
92659: LD_INT 2
92661: NEG
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 2
92669: NEG
92670: PUSH
92671: LD_INT 1
92673: NEG
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: PUSH
92679: LD_INT 2
92681: NEG
92682: PUSH
92683: LD_INT 2
92685: NEG
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: LIST
92695: ST_TO_ADDR
// end ; 2 :
92696: GO 95962
92698: LD_INT 2
92700: DOUBLE
92701: EQUAL
92702: IFTRUE 92706
92704: GO 95961
92706: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92707: LD_ADDR_VAR 0 29
92711: PUSH
92712: LD_INT 4
92714: PUSH
92715: LD_INT 0
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 4
92724: PUSH
92725: LD_INT 1
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 5
92735: PUSH
92736: LD_INT 0
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 5
92745: PUSH
92746: LD_INT 1
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 4
92755: PUSH
92756: LD_INT 1
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 3
92765: PUSH
92766: LD_INT 0
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 3
92775: PUSH
92776: LD_INT 1
92778: NEG
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 3
92786: PUSH
92787: LD_INT 2
92789: NEG
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 5
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 3
92807: PUSH
92808: LD_INT 3
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 3
92817: PUSH
92818: LD_INT 2
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 4
92827: PUSH
92828: LD_INT 3
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 4
92837: PUSH
92838: LD_INT 4
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 3
92847: PUSH
92848: LD_INT 4
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 2
92857: PUSH
92858: LD_INT 3
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 2
92867: PUSH
92868: LD_INT 2
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 4
92877: PUSH
92878: LD_INT 2
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 2
92887: PUSH
92888: LD_INT 4
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 0
92897: PUSH
92898: LD_INT 4
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 0
92907: PUSH
92908: LD_INT 3
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 1
92917: PUSH
92918: LD_INT 4
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 1
92927: PUSH
92928: LD_INT 5
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 0
92937: PUSH
92938: LD_INT 5
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 1
92947: NEG
92948: PUSH
92949: LD_INT 4
92951: PUSH
92952: EMPTY
92953: LIST
92954: LIST
92955: PUSH
92956: LD_INT 1
92958: NEG
92959: PUSH
92960: LD_INT 3
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PUSH
92967: LD_INT 2
92969: PUSH
92970: LD_INT 5
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 2
92979: NEG
92980: PUSH
92981: LD_INT 3
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 3
92990: NEG
92991: PUSH
92992: LD_INT 0
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 3
93001: NEG
93002: PUSH
93003: LD_INT 1
93005: NEG
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 2
93013: NEG
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 2
93024: NEG
93025: PUSH
93026: LD_INT 1
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 3
93035: NEG
93036: PUSH
93037: LD_INT 1
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 4
93046: NEG
93047: PUSH
93048: LD_INT 0
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 4
93057: NEG
93058: PUSH
93059: LD_INT 1
93061: NEG
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 4
93069: NEG
93070: PUSH
93071: LD_INT 2
93073: NEG
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 2
93081: NEG
93082: PUSH
93083: LD_INT 2
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 4
93092: NEG
93093: PUSH
93094: LD_INT 4
93096: NEG
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 4
93104: NEG
93105: PUSH
93106: LD_INT 5
93108: NEG
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 3
93116: NEG
93117: PUSH
93118: LD_INT 4
93120: NEG
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 3
93128: NEG
93129: PUSH
93130: LD_INT 3
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 4
93140: NEG
93141: PUSH
93142: LD_INT 3
93144: NEG
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 5
93152: NEG
93153: PUSH
93154: LD_INT 4
93156: NEG
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 5
93164: NEG
93165: PUSH
93166: LD_INT 5
93168: NEG
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: LD_INT 3
93176: NEG
93177: PUSH
93178: LD_INT 5
93180: NEG
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 5
93188: NEG
93189: PUSH
93190: LD_INT 3
93192: NEG
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93245: LD_ADDR_VAR 0 30
93249: PUSH
93250: LD_INT 4
93252: PUSH
93253: LD_INT 4
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 4
93262: PUSH
93263: LD_INT 3
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 5
93272: PUSH
93273: LD_INT 4
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 5
93282: PUSH
93283: LD_INT 5
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 4
93292: PUSH
93293: LD_INT 5
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: LD_INT 3
93302: PUSH
93303: LD_INT 4
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: PUSH
93310: LD_INT 3
93312: PUSH
93313: LD_INT 3
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: LD_INT 5
93322: PUSH
93323: LD_INT 3
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 3
93332: PUSH
93333: LD_INT 5
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 0
93342: PUSH
93343: LD_INT 3
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 0
93352: PUSH
93353: LD_INT 2
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 1
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 1
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 0
93382: PUSH
93383: LD_INT 4
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 1
93392: NEG
93393: PUSH
93394: LD_INT 3
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 1
93403: NEG
93404: PUSH
93405: LD_INT 2
93407: PUSH
93408: EMPTY
93409: LIST
93410: LIST
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: LD_INT 4
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 2
93424: NEG
93425: PUSH
93426: LD_INT 2
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 4
93435: NEG
93436: PUSH
93437: LD_INT 0
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 4
93446: NEG
93447: PUSH
93448: LD_INT 1
93450: NEG
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 3
93458: NEG
93459: PUSH
93460: LD_INT 0
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 3
93469: NEG
93470: PUSH
93471: LD_INT 1
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 4
93480: NEG
93481: PUSH
93482: LD_INT 1
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 5
93491: NEG
93492: PUSH
93493: LD_INT 0
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 5
93502: NEG
93503: PUSH
93504: LD_INT 1
93506: NEG
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 5
93514: NEG
93515: PUSH
93516: LD_INT 2
93518: NEG
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 3
93526: NEG
93527: PUSH
93528: LD_INT 2
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 3
93537: NEG
93538: PUSH
93539: LD_INT 3
93541: NEG
93542: PUSH
93543: EMPTY
93544: LIST
93545: LIST
93546: PUSH
93547: LD_INT 3
93549: NEG
93550: PUSH
93551: LD_INT 4
93553: NEG
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PUSH
93559: LD_INT 2
93561: NEG
93562: PUSH
93563: LD_INT 3
93565: NEG
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 2
93573: NEG
93574: PUSH
93575: LD_INT 2
93577: NEG
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 3
93585: NEG
93586: PUSH
93587: LD_INT 2
93589: NEG
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 4
93597: NEG
93598: PUSH
93599: LD_INT 3
93601: NEG
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: LD_INT 4
93609: NEG
93610: PUSH
93611: LD_INT 4
93613: NEG
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: NEG
93622: PUSH
93623: LD_INT 4
93625: NEG
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 4
93633: NEG
93634: PUSH
93635: LD_INT 2
93637: NEG
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 0
93645: PUSH
93646: LD_INT 4
93648: NEG
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: LD_INT 5
93659: NEG
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 1
93667: PUSH
93668: LD_INT 4
93670: NEG
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: LD_INT 1
93678: PUSH
93679: LD_INT 3
93681: NEG
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 0
93689: PUSH
93690: LD_INT 3
93692: NEG
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: LD_INT 1
93700: NEG
93701: PUSH
93702: LD_INT 4
93704: NEG
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: PUSH
93710: LD_INT 1
93712: NEG
93713: PUSH
93714: LD_INT 5
93716: NEG
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 2
93724: PUSH
93725: LD_INT 3
93727: NEG
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 2
93735: NEG
93736: PUSH
93737: LD_INT 5
93739: NEG
93740: PUSH
93741: EMPTY
93742: LIST
93743: LIST
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93792: LD_ADDR_VAR 0 31
93796: PUSH
93797: LD_INT 0
93799: PUSH
93800: LD_INT 4
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 0
93809: PUSH
93810: LD_INT 3
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 1
93819: PUSH
93820: LD_INT 4
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 1
93829: PUSH
93830: LD_INT 5
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 0
93839: PUSH
93840: LD_INT 5
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 1
93849: NEG
93850: PUSH
93851: LD_INT 4
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: LD_INT 1
93860: NEG
93861: PUSH
93862: LD_INT 3
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: LD_INT 2
93871: PUSH
93872: LD_INT 5
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 2
93881: NEG
93882: PUSH
93883: LD_INT 3
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: LD_INT 3
93892: NEG
93893: PUSH
93894: LD_INT 0
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 3
93903: NEG
93904: PUSH
93905: LD_INT 1
93907: NEG
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 2
93915: NEG
93916: PUSH
93917: LD_INT 0
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 2
93926: NEG
93927: PUSH
93928: LD_INT 1
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: PUSH
93935: LD_INT 3
93937: NEG
93938: PUSH
93939: LD_INT 1
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 4
93948: NEG
93949: PUSH
93950: LD_INT 0
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 4
93959: NEG
93960: PUSH
93961: LD_INT 1
93963: NEG
93964: PUSH
93965: EMPTY
93966: LIST
93967: LIST
93968: PUSH
93969: LD_INT 4
93971: NEG
93972: PUSH
93973: LD_INT 2
93975: NEG
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 2
93983: NEG
93984: PUSH
93985: LD_INT 2
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 4
93994: NEG
93995: PUSH
93996: LD_INT 4
93998: NEG
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 4
94006: NEG
94007: PUSH
94008: LD_INT 5
94010: NEG
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: PUSH
94016: LD_INT 3
94018: NEG
94019: PUSH
94020: LD_INT 4
94022: NEG
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 3
94030: NEG
94031: PUSH
94032: LD_INT 3
94034: NEG
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 4
94042: NEG
94043: PUSH
94044: LD_INT 3
94046: NEG
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: PUSH
94052: LD_INT 5
94054: NEG
94055: PUSH
94056: LD_INT 4
94058: NEG
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 5
94066: NEG
94067: PUSH
94068: LD_INT 5
94070: NEG
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 3
94078: NEG
94079: PUSH
94080: LD_INT 5
94082: NEG
94083: PUSH
94084: EMPTY
94085: LIST
94086: LIST
94087: PUSH
94088: LD_INT 5
94090: NEG
94091: PUSH
94092: LD_INT 3
94094: NEG
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: LD_INT 3
94105: NEG
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 0
94113: PUSH
94114: LD_INT 4
94116: NEG
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 1
94124: PUSH
94125: LD_INT 3
94127: NEG
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 1
94135: PUSH
94136: LD_INT 2
94138: NEG
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: PUSH
94144: LD_INT 0
94146: PUSH
94147: LD_INT 2
94149: NEG
94150: PUSH
94151: EMPTY
94152: LIST
94153: LIST
94154: PUSH
94155: LD_INT 1
94157: NEG
94158: PUSH
94159: LD_INT 3
94161: NEG
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 1
94169: NEG
94170: PUSH
94171: LD_INT 4
94173: NEG
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 2
94181: PUSH
94182: LD_INT 2
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 2
94192: NEG
94193: PUSH
94194: LD_INT 4
94196: NEG
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 4
94204: PUSH
94205: LD_INT 0
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 4
94214: PUSH
94215: LD_INT 1
94217: NEG
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 5
94225: PUSH
94226: LD_INT 0
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 5
94235: PUSH
94236: LD_INT 1
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 4
94245: PUSH
94246: LD_INT 1
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 3
94255: PUSH
94256: LD_INT 0
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 3
94265: PUSH
94266: LD_INT 1
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 3
94276: PUSH
94277: LD_INT 2
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 5
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94342: LD_ADDR_VAR 0 32
94346: PUSH
94347: LD_INT 4
94349: NEG
94350: PUSH
94351: LD_INT 0
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 4
94360: NEG
94361: PUSH
94362: LD_INT 1
94364: NEG
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 3
94372: NEG
94373: PUSH
94374: LD_INT 0
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 3
94383: NEG
94384: PUSH
94385: LD_INT 1
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: LD_INT 4
94394: NEG
94395: PUSH
94396: LD_INT 1
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: LD_INT 5
94405: NEG
94406: PUSH
94407: LD_INT 0
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 5
94416: NEG
94417: PUSH
94418: LD_INT 1
94420: NEG
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 5
94428: NEG
94429: PUSH
94430: LD_INT 2
94432: NEG
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PUSH
94438: LD_INT 3
94440: NEG
94441: PUSH
94442: LD_INT 2
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 3
94451: NEG
94452: PUSH
94453: LD_INT 3
94455: NEG
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 3
94463: NEG
94464: PUSH
94465: LD_INT 4
94467: NEG
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 2
94475: NEG
94476: PUSH
94477: LD_INT 3
94479: NEG
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 2
94487: NEG
94488: PUSH
94489: LD_INT 2
94491: NEG
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 3
94499: NEG
94500: PUSH
94501: LD_INT 2
94503: NEG
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 4
94511: NEG
94512: PUSH
94513: LD_INT 3
94515: NEG
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: LD_INT 4
94523: NEG
94524: PUSH
94525: LD_INT 4
94527: NEG
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 2
94535: NEG
94536: PUSH
94537: LD_INT 4
94539: NEG
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: LD_INT 4
94547: NEG
94548: PUSH
94549: LD_INT 2
94551: NEG
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 0
94559: PUSH
94560: LD_INT 4
94562: NEG
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: PUSH
94568: LD_INT 0
94570: PUSH
94571: LD_INT 5
94573: NEG
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: PUSH
94579: LD_INT 1
94581: PUSH
94582: LD_INT 4
94584: NEG
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 1
94592: PUSH
94593: LD_INT 3
94595: NEG
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 0
94603: PUSH
94604: LD_INT 3
94606: NEG
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 1
94614: NEG
94615: PUSH
94616: LD_INT 4
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 1
94626: NEG
94627: PUSH
94628: LD_INT 5
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 2
94638: PUSH
94639: LD_INT 3
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 2
94649: NEG
94650: PUSH
94651: LD_INT 5
94653: NEG
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: PUSH
94659: LD_INT 3
94661: PUSH
94662: LD_INT 0
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 3
94671: PUSH
94672: LD_INT 1
94674: NEG
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: LD_INT 4
94682: PUSH
94683: LD_INT 0
94685: PUSH
94686: EMPTY
94687: LIST
94688: LIST
94689: PUSH
94690: LD_INT 4
94692: PUSH
94693: LD_INT 1
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 3
94702: PUSH
94703: LD_INT 1
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 2
94712: PUSH
94713: LD_INT 0
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 2
94722: PUSH
94723: LD_INT 1
94725: NEG
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: PUSH
94731: LD_INT 2
94733: PUSH
94734: LD_INT 2
94736: NEG
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 4
94744: PUSH
94745: LD_INT 2
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 4
94754: PUSH
94755: LD_INT 4
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 4
94764: PUSH
94765: LD_INT 3
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 5
94774: PUSH
94775: LD_INT 4
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 5
94784: PUSH
94785: LD_INT 5
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 4
94794: PUSH
94795: LD_INT 5
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 3
94804: PUSH
94805: LD_INT 4
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 3
94814: PUSH
94815: LD_INT 3
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 5
94824: PUSH
94825: LD_INT 3
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 3
94834: PUSH
94835: LD_INT 5
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94889: LD_ADDR_VAR 0 33
94893: PUSH
94894: LD_INT 4
94896: NEG
94897: PUSH
94898: LD_INT 4
94900: NEG
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: LD_INT 4
94908: NEG
94909: PUSH
94910: LD_INT 5
94912: NEG
94913: PUSH
94914: EMPTY
94915: LIST
94916: LIST
94917: PUSH
94918: LD_INT 3
94920: NEG
94921: PUSH
94922: LD_INT 4
94924: NEG
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 3
94932: NEG
94933: PUSH
94934: LD_INT 3
94936: NEG
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 4
94944: NEG
94945: PUSH
94946: LD_INT 3
94948: NEG
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PUSH
94954: LD_INT 5
94956: NEG
94957: PUSH
94958: LD_INT 4
94960: NEG
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 5
94968: NEG
94969: PUSH
94970: LD_INT 5
94972: NEG
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 3
94980: NEG
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 5
94992: NEG
94993: PUSH
94994: LD_INT 3
94996: NEG
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 0
95004: PUSH
95005: LD_INT 3
95007: NEG
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 0
95015: PUSH
95016: LD_INT 4
95018: NEG
95019: PUSH
95020: EMPTY
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 1
95026: PUSH
95027: LD_INT 3
95029: NEG
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 1
95037: PUSH
95038: LD_INT 2
95040: NEG
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 0
95048: PUSH
95049: LD_INT 2
95051: NEG
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 1
95059: NEG
95060: PUSH
95061: LD_INT 3
95063: NEG
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 1
95071: NEG
95072: PUSH
95073: LD_INT 4
95075: NEG
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 2
95083: PUSH
95084: LD_INT 2
95086: NEG
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 2
95094: NEG
95095: PUSH
95096: LD_INT 4
95098: NEG
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 4
95106: PUSH
95107: LD_INT 0
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 4
95116: PUSH
95117: LD_INT 1
95119: NEG
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: PUSH
95125: LD_INT 5
95127: PUSH
95128: LD_INT 0
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: PUSH
95135: LD_INT 5
95137: PUSH
95138: LD_INT 1
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 4
95147: PUSH
95148: LD_INT 1
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 3
95157: PUSH
95158: LD_INT 0
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 3
95167: PUSH
95168: LD_INT 1
95170: NEG
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: LD_INT 3
95178: PUSH
95179: LD_INT 2
95181: NEG
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 5
95189: PUSH
95190: LD_INT 2
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 3
95199: PUSH
95200: LD_INT 3
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 3
95209: PUSH
95210: LD_INT 2
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 4
95219: PUSH
95220: LD_INT 3
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 4
95229: PUSH
95230: LD_INT 4
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 3
95239: PUSH
95240: LD_INT 4
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 2
95249: PUSH
95250: LD_INT 3
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 2
95259: PUSH
95260: LD_INT 2
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 4
95269: PUSH
95270: LD_INT 2
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PUSH
95277: LD_INT 2
95279: PUSH
95280: LD_INT 4
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 0
95289: PUSH
95290: LD_INT 4
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 0
95299: PUSH
95300: LD_INT 3
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 1
95309: PUSH
95310: LD_INT 4
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 1
95319: PUSH
95320: LD_INT 5
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 0
95329: PUSH
95330: LD_INT 5
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 1
95339: NEG
95340: PUSH
95341: LD_INT 4
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 1
95350: NEG
95351: PUSH
95352: LD_INT 3
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 2
95361: PUSH
95362: LD_INT 5
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 2
95371: NEG
95372: PUSH
95373: LD_INT 3
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95427: LD_ADDR_VAR 0 34
95431: PUSH
95432: LD_INT 0
95434: PUSH
95435: LD_INT 4
95437: NEG
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_INT 0
95445: PUSH
95446: LD_INT 5
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 1
95456: PUSH
95457: LD_INT 4
95459: NEG
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 1
95467: PUSH
95468: LD_INT 3
95470: NEG
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 0
95478: PUSH
95479: LD_INT 3
95481: NEG
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 1
95489: NEG
95490: PUSH
95491: LD_INT 4
95493: NEG
95494: PUSH
95495: EMPTY
95496: LIST
95497: LIST
95498: PUSH
95499: LD_INT 1
95501: NEG
95502: PUSH
95503: LD_INT 5
95505: NEG
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 2
95513: PUSH
95514: LD_INT 3
95516: NEG
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 2
95524: NEG
95525: PUSH
95526: LD_INT 5
95528: NEG
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 3
95536: PUSH
95537: LD_INT 0
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 3
95546: PUSH
95547: LD_INT 1
95549: NEG
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 4
95557: PUSH
95558: LD_INT 0
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 4
95567: PUSH
95568: LD_INT 1
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PUSH
95575: LD_INT 3
95577: PUSH
95578: LD_INT 1
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 2
95587: PUSH
95588: LD_INT 0
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 2
95597: PUSH
95598: LD_INT 1
95600: NEG
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: LD_INT 2
95608: PUSH
95609: LD_INT 2
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 4
95619: PUSH
95620: LD_INT 2
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: PUSH
95627: LD_INT 4
95629: PUSH
95630: LD_INT 4
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 4
95639: PUSH
95640: LD_INT 3
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 5
95649: PUSH
95650: LD_INT 4
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 5
95659: PUSH
95660: LD_INT 5
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 4
95669: PUSH
95670: LD_INT 5
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 3
95679: PUSH
95680: LD_INT 4
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 3
95689: PUSH
95690: LD_INT 3
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: PUSH
95697: LD_INT 5
95699: PUSH
95700: LD_INT 3
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 3
95709: PUSH
95710: LD_INT 5
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: PUSH
95717: LD_INT 0
95719: PUSH
95720: LD_INT 3
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 0
95729: PUSH
95730: LD_INT 2
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 1
95739: PUSH
95740: LD_INT 3
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 1
95749: PUSH
95750: LD_INT 4
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 0
95759: PUSH
95760: LD_INT 4
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 1
95769: NEG
95770: PUSH
95771: LD_INT 3
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 1
95780: NEG
95781: PUSH
95782: LD_INT 2
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: PUSH
95789: LD_INT 2
95791: PUSH
95792: LD_INT 4
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 2
95801: NEG
95802: PUSH
95803: LD_INT 2
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: LD_INT 4
95812: NEG
95813: PUSH
95814: LD_INT 0
95816: PUSH
95817: EMPTY
95818: LIST
95819: LIST
95820: PUSH
95821: LD_INT 4
95823: NEG
95824: PUSH
95825: LD_INT 1
95827: NEG
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 3
95835: NEG
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: LD_INT 3
95846: NEG
95847: PUSH
95848: LD_INT 1
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 4
95857: NEG
95858: PUSH
95859: LD_INT 1
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: PUSH
95866: LD_INT 5
95868: NEG
95869: PUSH
95870: LD_INT 0
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 5
95879: NEG
95880: PUSH
95881: LD_INT 1
95883: NEG
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: PUSH
95889: LD_INT 5
95891: NEG
95892: PUSH
95893: LD_INT 2
95895: NEG
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: LD_INT 3
95903: NEG
95904: PUSH
95905: LD_INT 2
95907: PUSH
95908: EMPTY
95909: LIST
95910: LIST
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: ST_TO_ADDR
// end ; end ;
95959: GO 95962
95961: POP
// case btype of b_depot , b_warehouse :
95962: LD_VAR 0 1
95966: PUSH
95967: LD_INT 0
95969: DOUBLE
95970: EQUAL
95971: IFTRUE 95981
95973: LD_INT 1
95975: DOUBLE
95976: EQUAL
95977: IFTRUE 95981
95979: GO 96182
95981: POP
// case nation of nation_american :
95982: LD_VAR 0 5
95986: PUSH
95987: LD_INT 1
95989: DOUBLE
95990: EQUAL
95991: IFTRUE 95995
95993: GO 96051
95995: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95996: LD_ADDR_VAR 0 9
96000: PUSH
96001: LD_VAR 0 11
96005: PUSH
96006: LD_VAR 0 12
96010: PUSH
96011: LD_VAR 0 13
96015: PUSH
96016: LD_VAR 0 14
96020: PUSH
96021: LD_VAR 0 15
96025: PUSH
96026: LD_VAR 0 16
96030: PUSH
96031: EMPTY
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: PUSH
96039: LD_VAR 0 4
96043: PUSH
96044: LD_INT 1
96046: PLUS
96047: ARRAY
96048: ST_TO_ADDR
96049: GO 96180
96051: LD_INT 2
96053: DOUBLE
96054: EQUAL
96055: IFTRUE 96059
96057: GO 96115
96059: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96060: LD_ADDR_VAR 0 9
96064: PUSH
96065: LD_VAR 0 17
96069: PUSH
96070: LD_VAR 0 18
96074: PUSH
96075: LD_VAR 0 19
96079: PUSH
96080: LD_VAR 0 20
96084: PUSH
96085: LD_VAR 0 21
96089: PUSH
96090: LD_VAR 0 22
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: PUSH
96103: LD_VAR 0 4
96107: PUSH
96108: LD_INT 1
96110: PLUS
96111: ARRAY
96112: ST_TO_ADDR
96113: GO 96180
96115: LD_INT 3
96117: DOUBLE
96118: EQUAL
96119: IFTRUE 96123
96121: GO 96179
96123: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96124: LD_ADDR_VAR 0 9
96128: PUSH
96129: LD_VAR 0 23
96133: PUSH
96134: LD_VAR 0 24
96138: PUSH
96139: LD_VAR 0 25
96143: PUSH
96144: LD_VAR 0 26
96148: PUSH
96149: LD_VAR 0 27
96153: PUSH
96154: LD_VAR 0 28
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: PUSH
96167: LD_VAR 0 4
96171: PUSH
96172: LD_INT 1
96174: PLUS
96175: ARRAY
96176: ST_TO_ADDR
96177: GO 96180
96179: POP
96180: GO 96735
96182: LD_INT 2
96184: DOUBLE
96185: EQUAL
96186: IFTRUE 96196
96188: LD_INT 3
96190: DOUBLE
96191: EQUAL
96192: IFTRUE 96196
96194: GO 96252
96196: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96197: LD_ADDR_VAR 0 9
96201: PUSH
96202: LD_VAR 0 29
96206: PUSH
96207: LD_VAR 0 30
96211: PUSH
96212: LD_VAR 0 31
96216: PUSH
96217: LD_VAR 0 32
96221: PUSH
96222: LD_VAR 0 33
96226: PUSH
96227: LD_VAR 0 34
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: LIST
96236: LIST
96237: LIST
96238: LIST
96239: PUSH
96240: LD_VAR 0 4
96244: PUSH
96245: LD_INT 1
96247: PLUS
96248: ARRAY
96249: ST_TO_ADDR
96250: GO 96735
96252: LD_INT 16
96254: DOUBLE
96255: EQUAL
96256: IFTRUE 96314
96258: LD_INT 17
96260: DOUBLE
96261: EQUAL
96262: IFTRUE 96314
96264: LD_INT 18
96266: DOUBLE
96267: EQUAL
96268: IFTRUE 96314
96270: LD_INT 19
96272: DOUBLE
96273: EQUAL
96274: IFTRUE 96314
96276: LD_INT 22
96278: DOUBLE
96279: EQUAL
96280: IFTRUE 96314
96282: LD_INT 20
96284: DOUBLE
96285: EQUAL
96286: IFTRUE 96314
96288: LD_INT 21
96290: DOUBLE
96291: EQUAL
96292: IFTRUE 96314
96294: LD_INT 23
96296: DOUBLE
96297: EQUAL
96298: IFTRUE 96314
96300: LD_INT 24
96302: DOUBLE
96303: EQUAL
96304: IFTRUE 96314
96306: LD_INT 25
96308: DOUBLE
96309: EQUAL
96310: IFTRUE 96314
96312: GO 96370
96314: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96315: LD_ADDR_VAR 0 9
96319: PUSH
96320: LD_VAR 0 35
96324: PUSH
96325: LD_VAR 0 36
96329: PUSH
96330: LD_VAR 0 37
96334: PUSH
96335: LD_VAR 0 38
96339: PUSH
96340: LD_VAR 0 39
96344: PUSH
96345: LD_VAR 0 40
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: PUSH
96358: LD_VAR 0 4
96362: PUSH
96363: LD_INT 1
96365: PLUS
96366: ARRAY
96367: ST_TO_ADDR
96368: GO 96735
96370: LD_INT 6
96372: DOUBLE
96373: EQUAL
96374: IFTRUE 96426
96376: LD_INT 7
96378: DOUBLE
96379: EQUAL
96380: IFTRUE 96426
96382: LD_INT 8
96384: DOUBLE
96385: EQUAL
96386: IFTRUE 96426
96388: LD_INT 13
96390: DOUBLE
96391: EQUAL
96392: IFTRUE 96426
96394: LD_INT 12
96396: DOUBLE
96397: EQUAL
96398: IFTRUE 96426
96400: LD_INT 15
96402: DOUBLE
96403: EQUAL
96404: IFTRUE 96426
96406: LD_INT 11
96408: DOUBLE
96409: EQUAL
96410: IFTRUE 96426
96412: LD_INT 14
96414: DOUBLE
96415: EQUAL
96416: IFTRUE 96426
96418: LD_INT 10
96420: DOUBLE
96421: EQUAL
96422: IFTRUE 96426
96424: GO 96482
96426: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96427: LD_ADDR_VAR 0 9
96431: PUSH
96432: LD_VAR 0 41
96436: PUSH
96437: LD_VAR 0 42
96441: PUSH
96442: LD_VAR 0 43
96446: PUSH
96447: LD_VAR 0 44
96451: PUSH
96452: LD_VAR 0 45
96456: PUSH
96457: LD_VAR 0 46
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: PUSH
96470: LD_VAR 0 4
96474: PUSH
96475: LD_INT 1
96477: PLUS
96478: ARRAY
96479: ST_TO_ADDR
96480: GO 96735
96482: LD_INT 36
96484: DOUBLE
96485: EQUAL
96486: IFTRUE 96490
96488: GO 96546
96490: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96491: LD_ADDR_VAR 0 9
96495: PUSH
96496: LD_VAR 0 47
96500: PUSH
96501: LD_VAR 0 48
96505: PUSH
96506: LD_VAR 0 49
96510: PUSH
96511: LD_VAR 0 50
96515: PUSH
96516: LD_VAR 0 51
96520: PUSH
96521: LD_VAR 0 52
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: PUSH
96534: LD_VAR 0 4
96538: PUSH
96539: LD_INT 1
96541: PLUS
96542: ARRAY
96543: ST_TO_ADDR
96544: GO 96735
96546: LD_INT 4
96548: DOUBLE
96549: EQUAL
96550: IFTRUE 96572
96552: LD_INT 5
96554: DOUBLE
96555: EQUAL
96556: IFTRUE 96572
96558: LD_INT 34
96560: DOUBLE
96561: EQUAL
96562: IFTRUE 96572
96564: LD_INT 37
96566: DOUBLE
96567: EQUAL
96568: IFTRUE 96572
96570: GO 96628
96572: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96573: LD_ADDR_VAR 0 9
96577: PUSH
96578: LD_VAR 0 53
96582: PUSH
96583: LD_VAR 0 54
96587: PUSH
96588: LD_VAR 0 55
96592: PUSH
96593: LD_VAR 0 56
96597: PUSH
96598: LD_VAR 0 57
96602: PUSH
96603: LD_VAR 0 58
96607: PUSH
96608: EMPTY
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: PUSH
96616: LD_VAR 0 4
96620: PUSH
96621: LD_INT 1
96623: PLUS
96624: ARRAY
96625: ST_TO_ADDR
96626: GO 96735
96628: LD_INT 31
96630: DOUBLE
96631: EQUAL
96632: IFTRUE 96678
96634: LD_INT 32
96636: DOUBLE
96637: EQUAL
96638: IFTRUE 96678
96640: LD_INT 33
96642: DOUBLE
96643: EQUAL
96644: IFTRUE 96678
96646: LD_INT 27
96648: DOUBLE
96649: EQUAL
96650: IFTRUE 96678
96652: LD_INT 26
96654: DOUBLE
96655: EQUAL
96656: IFTRUE 96678
96658: LD_INT 28
96660: DOUBLE
96661: EQUAL
96662: IFTRUE 96678
96664: LD_INT 29
96666: DOUBLE
96667: EQUAL
96668: IFTRUE 96678
96670: LD_INT 30
96672: DOUBLE
96673: EQUAL
96674: IFTRUE 96678
96676: GO 96734
96678: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96679: LD_ADDR_VAR 0 9
96683: PUSH
96684: LD_VAR 0 59
96688: PUSH
96689: LD_VAR 0 60
96693: PUSH
96694: LD_VAR 0 61
96698: PUSH
96699: LD_VAR 0 62
96703: PUSH
96704: LD_VAR 0 63
96708: PUSH
96709: LD_VAR 0 64
96713: PUSH
96714: EMPTY
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: LIST
96721: PUSH
96722: LD_VAR 0 4
96726: PUSH
96727: LD_INT 1
96729: PLUS
96730: ARRAY
96731: ST_TO_ADDR
96732: GO 96735
96734: POP
// temp_list2 = [ ] ;
96735: LD_ADDR_VAR 0 10
96739: PUSH
96740: EMPTY
96741: ST_TO_ADDR
// for i in temp_list do
96742: LD_ADDR_VAR 0 8
96746: PUSH
96747: LD_VAR 0 9
96751: PUSH
96752: FOR_IN
96753: IFFALSE 96805
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96755: LD_ADDR_VAR 0 10
96759: PUSH
96760: LD_VAR 0 10
96764: PUSH
96765: LD_VAR 0 8
96769: PUSH
96770: LD_INT 1
96772: ARRAY
96773: PUSH
96774: LD_VAR 0 2
96778: PLUS
96779: PUSH
96780: LD_VAR 0 8
96784: PUSH
96785: LD_INT 2
96787: ARRAY
96788: PUSH
96789: LD_VAR 0 3
96793: PLUS
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: PUSH
96799: EMPTY
96800: LIST
96801: ADD
96802: ST_TO_ADDR
96803: GO 96752
96805: POP
96806: POP
// result = temp_list2 ;
96807: LD_ADDR_VAR 0 7
96811: PUSH
96812: LD_VAR 0 10
96816: ST_TO_ADDR
// end ;
96817: LD_VAR 0 7
96821: RET
// export function EnemyInRange ( unit , dist ) ; begin
96822: LD_INT 0
96824: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96825: LD_ADDR_VAR 0 3
96829: PUSH
96830: LD_VAR 0 1
96834: PPUSH
96835: CALL_OW 255
96839: PPUSH
96840: LD_VAR 0 1
96844: PPUSH
96845: CALL_OW 250
96849: PPUSH
96850: LD_VAR 0 1
96854: PPUSH
96855: CALL_OW 251
96859: PPUSH
96860: LD_VAR 0 2
96864: PPUSH
96865: CALL 70926 0 4
96869: PUSH
96870: LD_INT 4
96872: ARRAY
96873: ST_TO_ADDR
// end ;
96874: LD_VAR 0 3
96878: RET
// export function PlayerSeeMe ( unit ) ; begin
96879: LD_INT 0
96881: PPUSH
// result := See ( your_side , unit ) ;
96882: LD_ADDR_VAR 0 2
96886: PUSH
96887: LD_OWVAR 2
96891: PPUSH
96892: LD_VAR 0 1
96896: PPUSH
96897: CALL_OW 292
96901: ST_TO_ADDR
// end ;
96902: LD_VAR 0 2
96906: RET
// export function ReverseDir ( unit ) ; begin
96907: LD_INT 0
96909: PPUSH
// if not unit then
96910: LD_VAR 0 1
96914: NOT
96915: IFFALSE 96919
// exit ;
96917: GO 96942
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96919: LD_ADDR_VAR 0 2
96923: PUSH
96924: LD_VAR 0 1
96928: PPUSH
96929: CALL_OW 254
96933: PUSH
96934: LD_INT 3
96936: PLUS
96937: PUSH
96938: LD_INT 6
96940: MOD
96941: ST_TO_ADDR
// end ;
96942: LD_VAR 0 2
96946: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96947: LD_INT 0
96949: PPUSH
96950: PPUSH
96951: PPUSH
96952: PPUSH
96953: PPUSH
// if not hexes then
96954: LD_VAR 0 2
96958: NOT
96959: IFFALSE 96963
// exit ;
96961: GO 97111
// dist := 9999 ;
96963: LD_ADDR_VAR 0 5
96967: PUSH
96968: LD_INT 9999
96970: ST_TO_ADDR
// for i = 1 to hexes do
96971: LD_ADDR_VAR 0 4
96975: PUSH
96976: DOUBLE
96977: LD_INT 1
96979: DEC
96980: ST_TO_ADDR
96981: LD_VAR 0 2
96985: PUSH
96986: FOR_TO
96987: IFFALSE 97099
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96989: LD_VAR 0 1
96993: PPUSH
96994: LD_VAR 0 2
96998: PUSH
96999: LD_VAR 0 4
97003: ARRAY
97004: PUSH
97005: LD_INT 1
97007: ARRAY
97008: PPUSH
97009: LD_VAR 0 2
97013: PUSH
97014: LD_VAR 0 4
97018: ARRAY
97019: PUSH
97020: LD_INT 2
97022: ARRAY
97023: PPUSH
97024: CALL_OW 297
97028: PUSH
97029: LD_VAR 0 5
97033: LESS
97034: IFFALSE 97097
// begin hex := hexes [ i ] ;
97036: LD_ADDR_VAR 0 7
97040: PUSH
97041: LD_VAR 0 2
97045: PUSH
97046: LD_VAR 0 4
97050: ARRAY
97051: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97052: LD_ADDR_VAR 0 5
97056: PUSH
97057: LD_VAR 0 1
97061: PPUSH
97062: LD_VAR 0 2
97066: PUSH
97067: LD_VAR 0 4
97071: ARRAY
97072: PUSH
97073: LD_INT 1
97075: ARRAY
97076: PPUSH
97077: LD_VAR 0 2
97081: PUSH
97082: LD_VAR 0 4
97086: ARRAY
97087: PUSH
97088: LD_INT 2
97090: ARRAY
97091: PPUSH
97092: CALL_OW 297
97096: ST_TO_ADDR
// end ; end ;
97097: GO 96986
97099: POP
97100: POP
// result := hex ;
97101: LD_ADDR_VAR 0 3
97105: PUSH
97106: LD_VAR 0 7
97110: ST_TO_ADDR
// end ;
97111: LD_VAR 0 3
97115: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97116: LD_INT 0
97118: PPUSH
97119: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97120: LD_VAR 0 1
97124: NOT
97125: PUSH
97126: LD_VAR 0 1
97130: PUSH
97131: LD_INT 21
97133: PUSH
97134: LD_INT 2
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 23
97143: PUSH
97144: LD_INT 2
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PPUSH
97155: CALL_OW 69
97159: IN
97160: NOT
97161: OR
97162: IFFALSE 97166
// exit ;
97164: GO 97213
// for i = 1 to 3 do
97166: LD_ADDR_VAR 0 3
97170: PUSH
97171: DOUBLE
97172: LD_INT 1
97174: DEC
97175: ST_TO_ADDR
97176: LD_INT 3
97178: PUSH
97179: FOR_TO
97180: IFFALSE 97211
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97182: LD_VAR 0 1
97186: PPUSH
97187: CALL_OW 250
97191: PPUSH
97192: LD_VAR 0 1
97196: PPUSH
97197: CALL_OW 251
97201: PPUSH
97202: LD_INT 1
97204: PPUSH
97205: CALL_OW 453
97209: GO 97179
97211: POP
97212: POP
// end ;
97213: LD_VAR 0 2
97217: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97218: LD_INT 0
97220: PPUSH
97221: PPUSH
97222: PPUSH
97223: PPUSH
97224: PPUSH
97225: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97226: LD_VAR 0 1
97230: NOT
97231: PUSH
97232: LD_VAR 0 2
97236: NOT
97237: OR
97238: PUSH
97239: LD_VAR 0 1
97243: PPUSH
97244: CALL_OW 314
97248: OR
97249: IFFALSE 97253
// exit ;
97251: GO 97694
// x := GetX ( enemy_unit ) ;
97253: LD_ADDR_VAR 0 7
97257: PUSH
97258: LD_VAR 0 2
97262: PPUSH
97263: CALL_OW 250
97267: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97268: LD_ADDR_VAR 0 8
97272: PUSH
97273: LD_VAR 0 2
97277: PPUSH
97278: CALL_OW 251
97282: ST_TO_ADDR
// if not x or not y then
97283: LD_VAR 0 7
97287: NOT
97288: PUSH
97289: LD_VAR 0 8
97293: NOT
97294: OR
97295: IFFALSE 97299
// exit ;
97297: GO 97694
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97299: LD_ADDR_VAR 0 6
97303: PUSH
97304: LD_VAR 0 7
97308: PPUSH
97309: LD_INT 0
97311: PPUSH
97312: LD_INT 4
97314: PPUSH
97315: CALL_OW 272
97319: PUSH
97320: LD_VAR 0 8
97324: PPUSH
97325: LD_INT 0
97327: PPUSH
97328: LD_INT 4
97330: PPUSH
97331: CALL_OW 273
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: LD_VAR 0 7
97344: PPUSH
97345: LD_INT 1
97347: PPUSH
97348: LD_INT 4
97350: PPUSH
97351: CALL_OW 272
97355: PUSH
97356: LD_VAR 0 8
97360: PPUSH
97361: LD_INT 1
97363: PPUSH
97364: LD_INT 4
97366: PPUSH
97367: CALL_OW 273
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: LD_VAR 0 7
97380: PPUSH
97381: LD_INT 2
97383: PPUSH
97384: LD_INT 4
97386: PPUSH
97387: CALL_OW 272
97391: PUSH
97392: LD_VAR 0 8
97396: PPUSH
97397: LD_INT 2
97399: PPUSH
97400: LD_INT 4
97402: PPUSH
97403: CALL_OW 273
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_VAR 0 7
97416: PPUSH
97417: LD_INT 3
97419: PPUSH
97420: LD_INT 4
97422: PPUSH
97423: CALL_OW 272
97427: PUSH
97428: LD_VAR 0 8
97432: PPUSH
97433: LD_INT 3
97435: PPUSH
97436: LD_INT 4
97438: PPUSH
97439: CALL_OW 273
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: PUSH
97448: LD_VAR 0 7
97452: PPUSH
97453: LD_INT 4
97455: PPUSH
97456: LD_INT 4
97458: PPUSH
97459: CALL_OW 272
97463: PUSH
97464: LD_VAR 0 8
97468: PPUSH
97469: LD_INT 4
97471: PPUSH
97472: LD_INT 4
97474: PPUSH
97475: CALL_OW 273
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: LD_VAR 0 7
97488: PPUSH
97489: LD_INT 5
97491: PPUSH
97492: LD_INT 4
97494: PPUSH
97495: CALL_OW 272
97499: PUSH
97500: LD_VAR 0 8
97504: PPUSH
97505: LD_INT 5
97507: PPUSH
97508: LD_INT 4
97510: PPUSH
97511: CALL_OW 273
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: ST_TO_ADDR
// for i = tmp downto 1 do
97528: LD_ADDR_VAR 0 4
97532: PUSH
97533: DOUBLE
97534: LD_VAR 0 6
97538: INC
97539: ST_TO_ADDR
97540: LD_INT 1
97542: PUSH
97543: FOR_DOWNTO
97544: IFFALSE 97645
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97546: LD_VAR 0 6
97550: PUSH
97551: LD_VAR 0 4
97555: ARRAY
97556: PUSH
97557: LD_INT 1
97559: ARRAY
97560: PPUSH
97561: LD_VAR 0 6
97565: PUSH
97566: LD_VAR 0 4
97570: ARRAY
97571: PUSH
97572: LD_INT 2
97574: ARRAY
97575: PPUSH
97576: CALL_OW 488
97580: NOT
97581: PUSH
97582: LD_VAR 0 6
97586: PUSH
97587: LD_VAR 0 4
97591: ARRAY
97592: PUSH
97593: LD_INT 1
97595: ARRAY
97596: PPUSH
97597: LD_VAR 0 6
97601: PUSH
97602: LD_VAR 0 4
97606: ARRAY
97607: PUSH
97608: LD_INT 2
97610: ARRAY
97611: PPUSH
97612: CALL_OW 428
97616: PUSH
97617: LD_INT 0
97619: NONEQUAL
97620: OR
97621: IFFALSE 97643
// tmp := Delete ( tmp , i ) ;
97623: LD_ADDR_VAR 0 6
97627: PUSH
97628: LD_VAR 0 6
97632: PPUSH
97633: LD_VAR 0 4
97637: PPUSH
97638: CALL_OW 3
97642: ST_TO_ADDR
97643: GO 97543
97645: POP
97646: POP
// j := GetClosestHex ( unit , tmp ) ;
97647: LD_ADDR_VAR 0 5
97651: PUSH
97652: LD_VAR 0 1
97656: PPUSH
97657: LD_VAR 0 6
97661: PPUSH
97662: CALL 96947 0 2
97666: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97667: LD_VAR 0 1
97671: PPUSH
97672: LD_VAR 0 5
97676: PUSH
97677: LD_INT 1
97679: ARRAY
97680: PPUSH
97681: LD_VAR 0 5
97685: PUSH
97686: LD_INT 2
97688: ARRAY
97689: PPUSH
97690: CALL_OW 111
// end ;
97694: LD_VAR 0 3
97698: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97699: LD_INT 0
97701: PPUSH
97702: PPUSH
97703: PPUSH
// uc_side = 0 ;
97704: LD_ADDR_OWVAR 20
97708: PUSH
97709: LD_INT 0
97711: ST_TO_ADDR
// uc_nation = 0 ;
97712: LD_ADDR_OWVAR 21
97716: PUSH
97717: LD_INT 0
97719: ST_TO_ADDR
// InitHc ;
97720: CALL_OW 19
// InitVc ;
97724: CALL_OW 20
// if mastodonts then
97728: LD_VAR 0 6
97732: IFFALSE 97799
// for i = 1 to mastodonts do
97734: LD_ADDR_VAR 0 11
97738: PUSH
97739: DOUBLE
97740: LD_INT 1
97742: DEC
97743: ST_TO_ADDR
97744: LD_VAR 0 6
97748: PUSH
97749: FOR_TO
97750: IFFALSE 97797
// begin vc_chassis := 31 ;
97752: LD_ADDR_OWVAR 37
97756: PUSH
97757: LD_INT 31
97759: ST_TO_ADDR
// vc_control := control_rider ;
97760: LD_ADDR_OWVAR 38
97764: PUSH
97765: LD_INT 4
97767: ST_TO_ADDR
// animal := CreateVehicle ;
97768: LD_ADDR_VAR 0 12
97772: PUSH
97773: CALL_OW 45
97777: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97778: LD_VAR 0 12
97782: PPUSH
97783: LD_VAR 0 8
97787: PPUSH
97788: LD_INT 0
97790: PPUSH
97791: CALL 99868 0 3
// end ;
97795: GO 97749
97797: POP
97798: POP
// if horses then
97799: LD_VAR 0 5
97803: IFFALSE 97870
// for i = 1 to horses do
97805: LD_ADDR_VAR 0 11
97809: PUSH
97810: DOUBLE
97811: LD_INT 1
97813: DEC
97814: ST_TO_ADDR
97815: LD_VAR 0 5
97819: PUSH
97820: FOR_TO
97821: IFFALSE 97868
// begin hc_class := 21 ;
97823: LD_ADDR_OWVAR 28
97827: PUSH
97828: LD_INT 21
97830: ST_TO_ADDR
// hc_gallery :=  ;
97831: LD_ADDR_OWVAR 33
97835: PUSH
97836: LD_STRING 
97838: ST_TO_ADDR
// animal := CreateHuman ;
97839: LD_ADDR_VAR 0 12
97843: PUSH
97844: CALL_OW 44
97848: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97849: LD_VAR 0 12
97853: PPUSH
97854: LD_VAR 0 8
97858: PPUSH
97859: LD_INT 0
97861: PPUSH
97862: CALL 99868 0 3
// end ;
97866: GO 97820
97868: POP
97869: POP
// if birds then
97870: LD_VAR 0 1
97874: IFFALSE 97941
// for i = 1 to birds do
97876: LD_ADDR_VAR 0 11
97880: PUSH
97881: DOUBLE
97882: LD_INT 1
97884: DEC
97885: ST_TO_ADDR
97886: LD_VAR 0 1
97890: PUSH
97891: FOR_TO
97892: IFFALSE 97939
// begin hc_class = 18 ;
97894: LD_ADDR_OWVAR 28
97898: PUSH
97899: LD_INT 18
97901: ST_TO_ADDR
// hc_gallery =  ;
97902: LD_ADDR_OWVAR 33
97906: PUSH
97907: LD_STRING 
97909: ST_TO_ADDR
// animal := CreateHuman ;
97910: LD_ADDR_VAR 0 12
97914: PUSH
97915: CALL_OW 44
97919: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97920: LD_VAR 0 12
97924: PPUSH
97925: LD_VAR 0 8
97929: PPUSH
97930: LD_INT 0
97932: PPUSH
97933: CALL 99868 0 3
// end ;
97937: GO 97891
97939: POP
97940: POP
// if tigers then
97941: LD_VAR 0 2
97945: IFFALSE 98029
// for i = 1 to tigers do
97947: LD_ADDR_VAR 0 11
97951: PUSH
97952: DOUBLE
97953: LD_INT 1
97955: DEC
97956: ST_TO_ADDR
97957: LD_VAR 0 2
97961: PUSH
97962: FOR_TO
97963: IFFALSE 98027
// begin hc_class = class_tiger ;
97965: LD_ADDR_OWVAR 28
97969: PUSH
97970: LD_INT 14
97972: ST_TO_ADDR
// hc_gallery =  ;
97973: LD_ADDR_OWVAR 33
97977: PUSH
97978: LD_STRING 
97980: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97981: LD_ADDR_OWVAR 35
97985: PUSH
97986: LD_INT 7
97988: NEG
97989: PPUSH
97990: LD_INT 7
97992: PPUSH
97993: CALL_OW 12
97997: ST_TO_ADDR
// animal := CreateHuman ;
97998: LD_ADDR_VAR 0 12
98002: PUSH
98003: CALL_OW 44
98007: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98008: LD_VAR 0 12
98012: PPUSH
98013: LD_VAR 0 8
98017: PPUSH
98018: LD_INT 0
98020: PPUSH
98021: CALL 99868 0 3
// end ;
98025: GO 97962
98027: POP
98028: POP
// if apemans then
98029: LD_VAR 0 3
98033: IFFALSE 98156
// for i = 1 to apemans do
98035: LD_ADDR_VAR 0 11
98039: PUSH
98040: DOUBLE
98041: LD_INT 1
98043: DEC
98044: ST_TO_ADDR
98045: LD_VAR 0 3
98049: PUSH
98050: FOR_TO
98051: IFFALSE 98154
// begin hc_class = class_apeman ;
98053: LD_ADDR_OWVAR 28
98057: PUSH
98058: LD_INT 12
98060: ST_TO_ADDR
// hc_gallery =  ;
98061: LD_ADDR_OWVAR 33
98065: PUSH
98066: LD_STRING 
98068: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98069: LD_ADDR_OWVAR 35
98073: PUSH
98074: LD_INT 5
98076: NEG
98077: PPUSH
98078: LD_INT 5
98080: PPUSH
98081: CALL_OW 12
98085: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98086: LD_ADDR_OWVAR 31
98090: PUSH
98091: LD_INT 1
98093: PPUSH
98094: LD_INT 3
98096: PPUSH
98097: CALL_OW 12
98101: PUSH
98102: LD_INT 1
98104: PPUSH
98105: LD_INT 3
98107: PPUSH
98108: CALL_OW 12
98112: PUSH
98113: LD_INT 0
98115: PUSH
98116: LD_INT 0
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: ST_TO_ADDR
// animal := CreateHuman ;
98125: LD_ADDR_VAR 0 12
98129: PUSH
98130: CALL_OW 44
98134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98135: LD_VAR 0 12
98139: PPUSH
98140: LD_VAR 0 8
98144: PPUSH
98145: LD_INT 0
98147: PPUSH
98148: CALL 99868 0 3
// end ;
98152: GO 98050
98154: POP
98155: POP
// if enchidnas then
98156: LD_VAR 0 4
98160: IFFALSE 98227
// for i = 1 to enchidnas do
98162: LD_ADDR_VAR 0 11
98166: PUSH
98167: DOUBLE
98168: LD_INT 1
98170: DEC
98171: ST_TO_ADDR
98172: LD_VAR 0 4
98176: PUSH
98177: FOR_TO
98178: IFFALSE 98225
// begin hc_class = 13 ;
98180: LD_ADDR_OWVAR 28
98184: PUSH
98185: LD_INT 13
98187: ST_TO_ADDR
// hc_gallery =  ;
98188: LD_ADDR_OWVAR 33
98192: PUSH
98193: LD_STRING 
98195: ST_TO_ADDR
// animal := CreateHuman ;
98196: LD_ADDR_VAR 0 12
98200: PUSH
98201: CALL_OW 44
98205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98206: LD_VAR 0 12
98210: PPUSH
98211: LD_VAR 0 8
98215: PPUSH
98216: LD_INT 0
98218: PPUSH
98219: CALL 99868 0 3
// end ;
98223: GO 98177
98225: POP
98226: POP
// if fishes then
98227: LD_VAR 0 7
98231: IFFALSE 98298
// for i = 1 to fishes do
98233: LD_ADDR_VAR 0 11
98237: PUSH
98238: DOUBLE
98239: LD_INT 1
98241: DEC
98242: ST_TO_ADDR
98243: LD_VAR 0 7
98247: PUSH
98248: FOR_TO
98249: IFFALSE 98296
// begin hc_class = 20 ;
98251: LD_ADDR_OWVAR 28
98255: PUSH
98256: LD_INT 20
98258: ST_TO_ADDR
// hc_gallery =  ;
98259: LD_ADDR_OWVAR 33
98263: PUSH
98264: LD_STRING 
98266: ST_TO_ADDR
// animal := CreateHuman ;
98267: LD_ADDR_VAR 0 12
98271: PUSH
98272: CALL_OW 44
98276: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98277: LD_VAR 0 12
98281: PPUSH
98282: LD_VAR 0 9
98286: PPUSH
98287: LD_INT 0
98289: PPUSH
98290: CALL 99868 0 3
// end ;
98294: GO 98248
98296: POP
98297: POP
// end ;
98298: LD_VAR 0 10
98302: RET
// export function WantHeal ( sci , unit ) ; begin
98303: LD_INT 0
98305: PPUSH
// if GetTaskList ( sci ) > 0 then
98306: LD_VAR 0 1
98310: PPUSH
98311: CALL_OW 437
98315: PUSH
98316: LD_INT 0
98318: GREATER
98319: IFFALSE 98389
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98321: LD_VAR 0 1
98325: PPUSH
98326: CALL_OW 437
98330: PUSH
98331: LD_INT 1
98333: ARRAY
98334: PUSH
98335: LD_INT 1
98337: ARRAY
98338: PUSH
98339: LD_STRING l
98341: EQUAL
98342: PUSH
98343: LD_VAR 0 1
98347: PPUSH
98348: CALL_OW 437
98352: PUSH
98353: LD_INT 1
98355: ARRAY
98356: PUSH
98357: LD_INT 4
98359: ARRAY
98360: PUSH
98361: LD_VAR 0 2
98365: EQUAL
98366: AND
98367: IFFALSE 98379
// result := true else
98369: LD_ADDR_VAR 0 3
98373: PUSH
98374: LD_INT 1
98376: ST_TO_ADDR
98377: GO 98387
// result := false ;
98379: LD_ADDR_VAR 0 3
98383: PUSH
98384: LD_INT 0
98386: ST_TO_ADDR
// end else
98387: GO 98397
// result := false ;
98389: LD_ADDR_VAR 0 3
98393: PUSH
98394: LD_INT 0
98396: ST_TO_ADDR
// end ;
98397: LD_VAR 0 3
98401: RET
// export function HealTarget ( sci ) ; begin
98402: LD_INT 0
98404: PPUSH
// if not sci then
98405: LD_VAR 0 1
98409: NOT
98410: IFFALSE 98414
// exit ;
98412: GO 98479
// result := 0 ;
98414: LD_ADDR_VAR 0 2
98418: PUSH
98419: LD_INT 0
98421: ST_TO_ADDR
// if GetTaskList ( sci ) then
98422: LD_VAR 0 1
98426: PPUSH
98427: CALL_OW 437
98431: IFFALSE 98479
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98433: LD_VAR 0 1
98437: PPUSH
98438: CALL_OW 437
98442: PUSH
98443: LD_INT 1
98445: ARRAY
98446: PUSH
98447: LD_INT 1
98449: ARRAY
98450: PUSH
98451: LD_STRING l
98453: EQUAL
98454: IFFALSE 98479
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98456: LD_ADDR_VAR 0 2
98460: PUSH
98461: LD_VAR 0 1
98465: PPUSH
98466: CALL_OW 437
98470: PUSH
98471: LD_INT 1
98473: ARRAY
98474: PUSH
98475: LD_INT 4
98477: ARRAY
98478: ST_TO_ADDR
// end ;
98479: LD_VAR 0 2
98483: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98484: LD_INT 0
98486: PPUSH
98487: PPUSH
98488: PPUSH
98489: PPUSH
// if not base_units then
98490: LD_VAR 0 1
98494: NOT
98495: IFFALSE 98499
// exit ;
98497: GO 98586
// result := false ;
98499: LD_ADDR_VAR 0 2
98503: PUSH
98504: LD_INT 0
98506: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98507: LD_ADDR_VAR 0 5
98511: PUSH
98512: LD_VAR 0 1
98516: PPUSH
98517: LD_INT 21
98519: PUSH
98520: LD_INT 3
98522: PUSH
98523: EMPTY
98524: LIST
98525: LIST
98526: PPUSH
98527: CALL_OW 72
98531: ST_TO_ADDR
// if not tmp then
98532: LD_VAR 0 5
98536: NOT
98537: IFFALSE 98541
// exit ;
98539: GO 98586
// for i in tmp do
98541: LD_ADDR_VAR 0 3
98545: PUSH
98546: LD_VAR 0 5
98550: PUSH
98551: FOR_IN
98552: IFFALSE 98584
// begin result := EnemyInRange ( i , 22 ) ;
98554: LD_ADDR_VAR 0 2
98558: PUSH
98559: LD_VAR 0 3
98563: PPUSH
98564: LD_INT 22
98566: PPUSH
98567: CALL 96822 0 2
98571: ST_TO_ADDR
// if result then
98572: LD_VAR 0 2
98576: IFFALSE 98582
// exit ;
98578: POP
98579: POP
98580: GO 98586
// end ;
98582: GO 98551
98584: POP
98585: POP
// end ;
98586: LD_VAR 0 2
98590: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98591: LD_INT 0
98593: PPUSH
98594: PPUSH
// if not units then
98595: LD_VAR 0 1
98599: NOT
98600: IFFALSE 98604
// exit ;
98602: GO 98674
// result := [ ] ;
98604: LD_ADDR_VAR 0 3
98608: PUSH
98609: EMPTY
98610: ST_TO_ADDR
// for i in units do
98611: LD_ADDR_VAR 0 4
98615: PUSH
98616: LD_VAR 0 1
98620: PUSH
98621: FOR_IN
98622: IFFALSE 98672
// if GetTag ( i ) = tag then
98624: LD_VAR 0 4
98628: PPUSH
98629: CALL_OW 110
98633: PUSH
98634: LD_VAR 0 2
98638: EQUAL
98639: IFFALSE 98670
// result := Insert ( result , result + 1 , i ) ;
98641: LD_ADDR_VAR 0 3
98645: PUSH
98646: LD_VAR 0 3
98650: PPUSH
98651: LD_VAR 0 3
98655: PUSH
98656: LD_INT 1
98658: PLUS
98659: PPUSH
98660: LD_VAR 0 4
98664: PPUSH
98665: CALL_OW 2
98669: ST_TO_ADDR
98670: GO 98621
98672: POP
98673: POP
// end ;
98674: LD_VAR 0 3
98678: RET
// export function IsDriver ( un ) ; begin
98679: LD_INT 0
98681: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98682: LD_ADDR_VAR 0 2
98686: PUSH
98687: LD_VAR 0 1
98691: PUSH
98692: LD_INT 55
98694: PUSH
98695: EMPTY
98696: LIST
98697: PPUSH
98698: CALL_OW 69
98702: IN
98703: ST_TO_ADDR
// end ;
98704: LD_VAR 0 2
98708: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98709: LD_INT 0
98711: PPUSH
98712: PPUSH
// list := [ ] ;
98713: LD_ADDR_VAR 0 5
98717: PUSH
98718: EMPTY
98719: ST_TO_ADDR
// case d of 0 :
98720: LD_VAR 0 3
98724: PUSH
98725: LD_INT 0
98727: DOUBLE
98728: EQUAL
98729: IFTRUE 98733
98731: GO 98866
98733: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98734: LD_ADDR_VAR 0 5
98738: PUSH
98739: LD_VAR 0 1
98743: PUSH
98744: LD_INT 4
98746: MINUS
98747: PUSH
98748: LD_VAR 0 2
98752: PUSH
98753: LD_INT 4
98755: MINUS
98756: PUSH
98757: LD_INT 2
98759: PUSH
98760: EMPTY
98761: LIST
98762: LIST
98763: LIST
98764: PUSH
98765: LD_VAR 0 1
98769: PUSH
98770: LD_INT 3
98772: MINUS
98773: PUSH
98774: LD_VAR 0 2
98778: PUSH
98779: LD_INT 1
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: LIST
98786: PUSH
98787: LD_VAR 0 1
98791: PUSH
98792: LD_INT 4
98794: PLUS
98795: PUSH
98796: LD_VAR 0 2
98800: PUSH
98801: LD_INT 4
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: LIST
98808: PUSH
98809: LD_VAR 0 1
98813: PUSH
98814: LD_INT 3
98816: PLUS
98817: PUSH
98818: LD_VAR 0 2
98822: PUSH
98823: LD_INT 3
98825: PLUS
98826: PUSH
98827: LD_INT 5
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: LIST
98834: PUSH
98835: LD_VAR 0 1
98839: PUSH
98840: LD_VAR 0 2
98844: PUSH
98845: LD_INT 4
98847: PLUS
98848: PUSH
98849: LD_INT 0
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: LIST
98856: PUSH
98857: EMPTY
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: ST_TO_ADDR
// end ; 1 :
98864: GO 99564
98866: LD_INT 1
98868: DOUBLE
98869: EQUAL
98870: IFTRUE 98874
98872: GO 99007
98874: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98875: LD_ADDR_VAR 0 5
98879: PUSH
98880: LD_VAR 0 1
98884: PUSH
98885: LD_VAR 0 2
98889: PUSH
98890: LD_INT 4
98892: MINUS
98893: PUSH
98894: LD_INT 3
98896: PUSH
98897: EMPTY
98898: LIST
98899: LIST
98900: LIST
98901: PUSH
98902: LD_VAR 0 1
98906: PUSH
98907: LD_INT 3
98909: MINUS
98910: PUSH
98911: LD_VAR 0 2
98915: PUSH
98916: LD_INT 3
98918: MINUS
98919: PUSH
98920: LD_INT 2
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: LIST
98927: PUSH
98928: LD_VAR 0 1
98932: PUSH
98933: LD_INT 4
98935: MINUS
98936: PUSH
98937: LD_VAR 0 2
98941: PUSH
98942: LD_INT 1
98944: PUSH
98945: EMPTY
98946: LIST
98947: LIST
98948: LIST
98949: PUSH
98950: LD_VAR 0 1
98954: PUSH
98955: LD_VAR 0 2
98959: PUSH
98960: LD_INT 3
98962: PLUS
98963: PUSH
98964: LD_INT 0
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: LIST
98971: PUSH
98972: LD_VAR 0 1
98976: PUSH
98977: LD_INT 4
98979: PLUS
98980: PUSH
98981: LD_VAR 0 2
98985: PUSH
98986: LD_INT 4
98988: PLUS
98989: PUSH
98990: LD_INT 5
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: LIST
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: ST_TO_ADDR
// end ; 2 :
99005: GO 99564
99007: LD_INT 2
99009: DOUBLE
99010: EQUAL
99011: IFTRUE 99015
99013: GO 99144
99015: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99016: LD_ADDR_VAR 0 5
99020: PUSH
99021: LD_VAR 0 1
99025: PUSH
99026: LD_VAR 0 2
99030: PUSH
99031: LD_INT 3
99033: MINUS
99034: PUSH
99035: LD_INT 3
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: LIST
99042: PUSH
99043: LD_VAR 0 1
99047: PUSH
99048: LD_INT 4
99050: PLUS
99051: PUSH
99052: LD_VAR 0 2
99056: PUSH
99057: LD_INT 4
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: LIST
99064: PUSH
99065: LD_VAR 0 1
99069: PUSH
99070: LD_VAR 0 2
99074: PUSH
99075: LD_INT 4
99077: PLUS
99078: PUSH
99079: LD_INT 0
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: LIST
99086: PUSH
99087: LD_VAR 0 1
99091: PUSH
99092: LD_INT 3
99094: MINUS
99095: PUSH
99096: LD_VAR 0 2
99100: PUSH
99101: LD_INT 1
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: LIST
99108: PUSH
99109: LD_VAR 0 1
99113: PUSH
99114: LD_INT 4
99116: MINUS
99117: PUSH
99118: LD_VAR 0 2
99122: PUSH
99123: LD_INT 4
99125: MINUS
99126: PUSH
99127: LD_INT 2
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: LIST
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: ST_TO_ADDR
// end ; 3 :
99142: GO 99564
99144: LD_INT 3
99146: DOUBLE
99147: EQUAL
99148: IFTRUE 99152
99150: GO 99285
99152: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99153: LD_ADDR_VAR 0 5
99157: PUSH
99158: LD_VAR 0 1
99162: PUSH
99163: LD_INT 3
99165: PLUS
99166: PUSH
99167: LD_VAR 0 2
99171: PUSH
99172: LD_INT 4
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: LIST
99179: PUSH
99180: LD_VAR 0 1
99184: PUSH
99185: LD_INT 4
99187: PLUS
99188: PUSH
99189: LD_VAR 0 2
99193: PUSH
99194: LD_INT 4
99196: PLUS
99197: PUSH
99198: LD_INT 5
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: LIST
99205: PUSH
99206: LD_VAR 0 1
99210: PUSH
99211: LD_INT 4
99213: MINUS
99214: PUSH
99215: LD_VAR 0 2
99219: PUSH
99220: LD_INT 1
99222: PUSH
99223: EMPTY
99224: LIST
99225: LIST
99226: LIST
99227: PUSH
99228: LD_VAR 0 1
99232: PUSH
99233: LD_VAR 0 2
99237: PUSH
99238: LD_INT 4
99240: MINUS
99241: PUSH
99242: LD_INT 3
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: LIST
99249: PUSH
99250: LD_VAR 0 1
99254: PUSH
99255: LD_INT 3
99257: MINUS
99258: PUSH
99259: LD_VAR 0 2
99263: PUSH
99264: LD_INT 3
99266: MINUS
99267: PUSH
99268: LD_INT 2
99270: PUSH
99271: EMPTY
99272: LIST
99273: LIST
99274: LIST
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: ST_TO_ADDR
// end ; 4 :
99283: GO 99564
99285: LD_INT 4
99287: DOUBLE
99288: EQUAL
99289: IFTRUE 99293
99291: GO 99426
99293: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99294: LD_ADDR_VAR 0 5
99298: PUSH
99299: LD_VAR 0 1
99303: PUSH
99304: LD_VAR 0 2
99308: PUSH
99309: LD_INT 4
99311: PLUS
99312: PUSH
99313: LD_INT 0
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: LIST
99320: PUSH
99321: LD_VAR 0 1
99325: PUSH
99326: LD_INT 3
99328: PLUS
99329: PUSH
99330: LD_VAR 0 2
99334: PUSH
99335: LD_INT 3
99337: PLUS
99338: PUSH
99339: LD_INT 5
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: LIST
99346: PUSH
99347: LD_VAR 0 1
99351: PUSH
99352: LD_INT 4
99354: PLUS
99355: PUSH
99356: LD_VAR 0 2
99360: PUSH
99361: LD_INT 4
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: LIST
99368: PUSH
99369: LD_VAR 0 1
99373: PUSH
99374: LD_VAR 0 2
99378: PUSH
99379: LD_INT 3
99381: MINUS
99382: PUSH
99383: LD_INT 3
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: LIST
99390: PUSH
99391: LD_VAR 0 1
99395: PUSH
99396: LD_INT 4
99398: MINUS
99399: PUSH
99400: LD_VAR 0 2
99404: PUSH
99405: LD_INT 4
99407: MINUS
99408: PUSH
99409: LD_INT 2
99411: PUSH
99412: EMPTY
99413: LIST
99414: LIST
99415: LIST
99416: PUSH
99417: EMPTY
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: ST_TO_ADDR
// end ; 5 :
99424: GO 99564
99426: LD_INT 5
99428: DOUBLE
99429: EQUAL
99430: IFTRUE 99434
99432: GO 99563
99434: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99435: LD_ADDR_VAR 0 5
99439: PUSH
99440: LD_VAR 0 1
99444: PUSH
99445: LD_INT 4
99447: MINUS
99448: PUSH
99449: LD_VAR 0 2
99453: PUSH
99454: LD_INT 1
99456: PUSH
99457: EMPTY
99458: LIST
99459: LIST
99460: LIST
99461: PUSH
99462: LD_VAR 0 1
99466: PUSH
99467: LD_VAR 0 2
99471: PUSH
99472: LD_INT 4
99474: MINUS
99475: PUSH
99476: LD_INT 3
99478: PUSH
99479: EMPTY
99480: LIST
99481: LIST
99482: LIST
99483: PUSH
99484: LD_VAR 0 1
99488: PUSH
99489: LD_INT 4
99491: PLUS
99492: PUSH
99493: LD_VAR 0 2
99497: PUSH
99498: LD_INT 4
99500: PLUS
99501: PUSH
99502: LD_INT 5
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: LIST
99509: PUSH
99510: LD_VAR 0 1
99514: PUSH
99515: LD_INT 3
99517: PLUS
99518: PUSH
99519: LD_VAR 0 2
99523: PUSH
99524: LD_INT 4
99526: PUSH
99527: EMPTY
99528: LIST
99529: LIST
99530: LIST
99531: PUSH
99532: LD_VAR 0 1
99536: PUSH
99537: LD_VAR 0 2
99541: PUSH
99542: LD_INT 3
99544: PLUS
99545: PUSH
99546: LD_INT 0
99548: PUSH
99549: EMPTY
99550: LIST
99551: LIST
99552: LIST
99553: PUSH
99554: EMPTY
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: ST_TO_ADDR
// end ; end ;
99561: GO 99564
99563: POP
// result := list ;
99564: LD_ADDR_VAR 0 4
99568: PUSH
99569: LD_VAR 0 5
99573: ST_TO_ADDR
// end ;
99574: LD_VAR 0 4
99578: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99579: LD_INT 0
99581: PPUSH
99582: PPUSH
99583: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99584: LD_VAR 0 1
99588: NOT
99589: PUSH
99590: LD_VAR 0 2
99594: PUSH
99595: LD_INT 1
99597: PUSH
99598: LD_INT 2
99600: PUSH
99601: LD_INT 3
99603: PUSH
99604: LD_INT 4
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: IN
99613: NOT
99614: OR
99615: IFFALSE 99619
// exit ;
99617: GO 99711
// tmp := [ ] ;
99619: LD_ADDR_VAR 0 5
99623: PUSH
99624: EMPTY
99625: ST_TO_ADDR
// for i in units do
99626: LD_ADDR_VAR 0 4
99630: PUSH
99631: LD_VAR 0 1
99635: PUSH
99636: FOR_IN
99637: IFFALSE 99680
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99639: LD_ADDR_VAR 0 5
99643: PUSH
99644: LD_VAR 0 5
99648: PPUSH
99649: LD_VAR 0 5
99653: PUSH
99654: LD_INT 1
99656: PLUS
99657: PPUSH
99658: LD_VAR 0 4
99662: PPUSH
99663: LD_VAR 0 2
99667: PPUSH
99668: CALL_OW 259
99672: PPUSH
99673: CALL_OW 2
99677: ST_TO_ADDR
99678: GO 99636
99680: POP
99681: POP
// if not tmp then
99682: LD_VAR 0 5
99686: NOT
99687: IFFALSE 99691
// exit ;
99689: GO 99711
// result := SortListByListDesc ( units , tmp ) ;
99691: LD_ADDR_VAR 0 3
99695: PUSH
99696: LD_VAR 0 1
99700: PPUSH
99701: LD_VAR 0 5
99705: PPUSH
99706: CALL_OW 77
99710: ST_TO_ADDR
// end ;
99711: LD_VAR 0 3
99715: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99716: LD_INT 0
99718: PPUSH
99719: PPUSH
99720: PPUSH
// x := GetX ( building ) ;
99721: LD_ADDR_VAR 0 4
99725: PUSH
99726: LD_VAR 0 2
99730: PPUSH
99731: CALL_OW 250
99735: ST_TO_ADDR
// y := GetY ( building ) ;
99736: LD_ADDR_VAR 0 5
99740: PUSH
99741: LD_VAR 0 2
99745: PPUSH
99746: CALL_OW 251
99750: ST_TO_ADDR
// if GetTaskList ( unit ) then
99751: LD_VAR 0 1
99755: PPUSH
99756: CALL_OW 437
99760: IFFALSE 99855
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99762: LD_STRING e
99764: PUSH
99765: LD_VAR 0 1
99769: PPUSH
99770: CALL_OW 437
99774: PUSH
99775: LD_INT 1
99777: ARRAY
99778: PUSH
99779: LD_INT 1
99781: ARRAY
99782: EQUAL
99783: PUSH
99784: LD_VAR 0 4
99788: PUSH
99789: LD_VAR 0 1
99793: PPUSH
99794: CALL_OW 437
99798: PUSH
99799: LD_INT 1
99801: ARRAY
99802: PUSH
99803: LD_INT 2
99805: ARRAY
99806: EQUAL
99807: AND
99808: PUSH
99809: LD_VAR 0 5
99813: PUSH
99814: LD_VAR 0 1
99818: PPUSH
99819: CALL_OW 437
99823: PUSH
99824: LD_INT 1
99826: ARRAY
99827: PUSH
99828: LD_INT 3
99830: ARRAY
99831: EQUAL
99832: AND
99833: IFFALSE 99845
// result := true else
99835: LD_ADDR_VAR 0 3
99839: PUSH
99840: LD_INT 1
99842: ST_TO_ADDR
99843: GO 99853
// result := false ;
99845: LD_ADDR_VAR 0 3
99849: PUSH
99850: LD_INT 0
99852: ST_TO_ADDR
// end else
99853: GO 99863
// result := false ;
99855: LD_ADDR_VAR 0 3
99859: PUSH
99860: LD_INT 0
99862: ST_TO_ADDR
// end ;
99863: LD_VAR 0 3
99867: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99868: LD_INT 0
99870: PPUSH
99871: PPUSH
99872: PPUSH
99873: PPUSH
// if not unit or not area then
99874: LD_VAR 0 1
99878: NOT
99879: PUSH
99880: LD_VAR 0 2
99884: NOT
99885: OR
99886: IFFALSE 99890
// exit ;
99888: GO 100054
// tmp := AreaToList ( area , i ) ;
99890: LD_ADDR_VAR 0 6
99894: PUSH
99895: LD_VAR 0 2
99899: PPUSH
99900: LD_VAR 0 5
99904: PPUSH
99905: CALL_OW 517
99909: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99910: LD_ADDR_VAR 0 5
99914: PUSH
99915: DOUBLE
99916: LD_INT 1
99918: DEC
99919: ST_TO_ADDR
99920: LD_VAR 0 6
99924: PUSH
99925: LD_INT 1
99927: ARRAY
99928: PUSH
99929: FOR_TO
99930: IFFALSE 100052
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99932: LD_ADDR_VAR 0 7
99936: PUSH
99937: LD_VAR 0 6
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PUSH
99946: LD_VAR 0 5
99950: ARRAY
99951: PUSH
99952: LD_VAR 0 6
99956: PUSH
99957: LD_INT 2
99959: ARRAY
99960: PUSH
99961: LD_VAR 0 5
99965: ARRAY
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99971: LD_VAR 0 7
99975: PUSH
99976: LD_INT 1
99978: ARRAY
99979: PPUSH
99980: LD_VAR 0 7
99984: PUSH
99985: LD_INT 2
99987: ARRAY
99988: PPUSH
99989: CALL_OW 428
99993: PUSH
99994: LD_INT 0
99996: EQUAL
99997: IFFALSE 100050
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99999: LD_VAR 0 1
100003: PPUSH
100004: LD_VAR 0 7
100008: PUSH
100009: LD_INT 1
100011: ARRAY
100012: PPUSH
100013: LD_VAR 0 7
100017: PUSH
100018: LD_INT 2
100020: ARRAY
100021: PPUSH
100022: LD_VAR 0 3
100026: PPUSH
100027: CALL_OW 48
// result := IsPlaced ( unit ) ;
100031: LD_ADDR_VAR 0 4
100035: PUSH
100036: LD_VAR 0 1
100040: PPUSH
100041: CALL_OW 305
100045: ST_TO_ADDR
// exit ;
100046: POP
100047: POP
100048: GO 100054
// end ; end ;
100050: GO 99929
100052: POP
100053: POP
// end ;
100054: LD_VAR 0 4
100058: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100059: LD_INT 0
100061: PPUSH
100062: PPUSH
100063: PPUSH
// if not side or side > 8 then
100064: LD_VAR 0 1
100068: NOT
100069: PUSH
100070: LD_VAR 0 1
100074: PUSH
100075: LD_INT 8
100077: GREATER
100078: OR
100079: IFFALSE 100083
// exit ;
100081: GO 100270
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100083: LD_ADDR_VAR 0 4
100087: PUSH
100088: LD_INT 22
100090: PUSH
100091: LD_VAR 0 1
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: PUSH
100100: LD_INT 21
100102: PUSH
100103: LD_INT 3
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: PUSH
100110: EMPTY
100111: LIST
100112: LIST
100113: PPUSH
100114: CALL_OW 69
100118: ST_TO_ADDR
// if not tmp then
100119: LD_VAR 0 4
100123: NOT
100124: IFFALSE 100128
// exit ;
100126: GO 100270
// enable_addtolog := true ;
100128: LD_ADDR_OWVAR 81
100132: PUSH
100133: LD_INT 1
100135: ST_TO_ADDR
// AddToLog ( [ ) ;
100136: LD_STRING [
100138: PPUSH
100139: CALL_OW 561
// for i in tmp do
100143: LD_ADDR_VAR 0 3
100147: PUSH
100148: LD_VAR 0 4
100152: PUSH
100153: FOR_IN
100154: IFFALSE 100261
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100156: LD_STRING [
100158: PUSH
100159: LD_VAR 0 3
100163: PPUSH
100164: CALL_OW 266
100168: STR
100169: PUSH
100170: LD_STRING , 
100172: STR
100173: PUSH
100174: LD_VAR 0 3
100178: PPUSH
100179: CALL_OW 250
100183: STR
100184: PUSH
100185: LD_STRING , 
100187: STR
100188: PUSH
100189: LD_VAR 0 3
100193: PPUSH
100194: CALL_OW 251
100198: STR
100199: PUSH
100200: LD_STRING , 
100202: STR
100203: PUSH
100204: LD_VAR 0 3
100208: PPUSH
100209: CALL_OW 254
100213: STR
100214: PUSH
100215: LD_STRING , 
100217: STR
100218: PUSH
100219: LD_VAR 0 3
100223: PPUSH
100224: LD_INT 1
100226: PPUSH
100227: CALL_OW 268
100231: STR
100232: PUSH
100233: LD_STRING , 
100235: STR
100236: PUSH
100237: LD_VAR 0 3
100241: PPUSH
100242: LD_INT 2
100244: PPUSH
100245: CALL_OW 268
100249: STR
100250: PUSH
100251: LD_STRING ],
100253: STR
100254: PPUSH
100255: CALL_OW 561
// end ;
100259: GO 100153
100261: POP
100262: POP
// AddToLog ( ]; ) ;
100263: LD_STRING ];
100265: PPUSH
100266: CALL_OW 561
// end ;
100270: LD_VAR 0 2
100274: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100275: LD_INT 0
100277: PPUSH
100278: PPUSH
100279: PPUSH
100280: PPUSH
100281: PPUSH
// if not area or not rate or not max then
100282: LD_VAR 0 1
100286: NOT
100287: PUSH
100288: LD_VAR 0 2
100292: NOT
100293: OR
100294: PUSH
100295: LD_VAR 0 4
100299: NOT
100300: OR
100301: IFFALSE 100305
// exit ;
100303: GO 100497
// while 1 do
100305: LD_INT 1
100307: IFFALSE 100497
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100309: LD_ADDR_VAR 0 9
100313: PUSH
100314: LD_VAR 0 1
100318: PPUSH
100319: LD_INT 1
100321: PPUSH
100322: CALL_OW 287
100326: PUSH
100327: LD_INT 10
100329: MUL
100330: ST_TO_ADDR
// r := rate / 10 ;
100331: LD_ADDR_VAR 0 7
100335: PUSH
100336: LD_VAR 0 2
100340: PUSH
100341: LD_INT 10
100343: DIVREAL
100344: ST_TO_ADDR
// time := 1 1$00 ;
100345: LD_ADDR_VAR 0 8
100349: PUSH
100350: LD_INT 2100
100352: ST_TO_ADDR
// if amount < min then
100353: LD_VAR 0 9
100357: PUSH
100358: LD_VAR 0 3
100362: LESS
100363: IFFALSE 100381
// r := r * 2 else
100365: LD_ADDR_VAR 0 7
100369: PUSH
100370: LD_VAR 0 7
100374: PUSH
100375: LD_INT 2
100377: MUL
100378: ST_TO_ADDR
100379: GO 100407
// if amount > max then
100381: LD_VAR 0 9
100385: PUSH
100386: LD_VAR 0 4
100390: GREATER
100391: IFFALSE 100407
// r := r / 2 ;
100393: LD_ADDR_VAR 0 7
100397: PUSH
100398: LD_VAR 0 7
100402: PUSH
100403: LD_INT 2
100405: DIVREAL
100406: ST_TO_ADDR
// time := time / r ;
100407: LD_ADDR_VAR 0 8
100411: PUSH
100412: LD_VAR 0 8
100416: PUSH
100417: LD_VAR 0 7
100421: DIVREAL
100422: ST_TO_ADDR
// if time < 0 then
100423: LD_VAR 0 8
100427: PUSH
100428: LD_INT 0
100430: LESS
100431: IFFALSE 100448
// time := time * - 1 ;
100433: LD_ADDR_VAR 0 8
100437: PUSH
100438: LD_VAR 0 8
100442: PUSH
100443: LD_INT 1
100445: NEG
100446: MUL
100447: ST_TO_ADDR
// wait ( time ) ;
100448: LD_VAR 0 8
100452: PPUSH
100453: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100457: LD_INT 35
100459: PPUSH
100460: LD_INT 875
100462: PPUSH
100463: CALL_OW 12
100467: PPUSH
100468: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100472: LD_INT 1
100474: PPUSH
100475: LD_INT 5
100477: PPUSH
100478: CALL_OW 12
100482: PPUSH
100483: LD_VAR 0 1
100487: PPUSH
100488: LD_INT 1
100490: PPUSH
100491: CALL_OW 55
// end ;
100495: GO 100305
// end ;
100497: LD_VAR 0 5
100501: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100502: LD_INT 0
100504: PPUSH
100505: PPUSH
100506: PPUSH
100507: PPUSH
100508: PPUSH
100509: PPUSH
100510: PPUSH
100511: PPUSH
// if not turrets or not factories then
100512: LD_VAR 0 1
100516: NOT
100517: PUSH
100518: LD_VAR 0 2
100522: NOT
100523: OR
100524: IFFALSE 100528
// exit ;
100526: GO 100835
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100528: LD_ADDR_VAR 0 10
100532: PUSH
100533: LD_INT 5
100535: PUSH
100536: LD_INT 6
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: LD_INT 2
100545: PUSH
100546: LD_INT 4
100548: PUSH
100549: EMPTY
100550: LIST
100551: LIST
100552: PUSH
100553: LD_INT 3
100555: PUSH
100556: LD_INT 5
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: EMPTY
100564: LIST
100565: LIST
100566: LIST
100567: PUSH
100568: LD_INT 24
100570: PUSH
100571: LD_INT 25
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: LD_INT 23
100580: PUSH
100581: LD_INT 27
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: EMPTY
100589: LIST
100590: LIST
100591: PUSH
100592: LD_INT 42
100594: PUSH
100595: LD_INT 43
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: PUSH
100602: LD_INT 44
100604: PUSH
100605: LD_INT 46
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_INT 45
100614: PUSH
100615: LD_INT 47
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: EMPTY
100623: LIST
100624: LIST
100625: LIST
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: LIST
100631: ST_TO_ADDR
// result := [ ] ;
100632: LD_ADDR_VAR 0 3
100636: PUSH
100637: EMPTY
100638: ST_TO_ADDR
// for i in turrets do
100639: LD_ADDR_VAR 0 4
100643: PUSH
100644: LD_VAR 0 1
100648: PUSH
100649: FOR_IN
100650: IFFALSE 100833
// begin nat := GetNation ( i ) ;
100652: LD_ADDR_VAR 0 7
100656: PUSH
100657: LD_VAR 0 4
100661: PPUSH
100662: CALL_OW 248
100666: ST_TO_ADDR
// weapon := 0 ;
100667: LD_ADDR_VAR 0 8
100671: PUSH
100672: LD_INT 0
100674: ST_TO_ADDR
// if not nat then
100675: LD_VAR 0 7
100679: NOT
100680: IFFALSE 100684
// continue ;
100682: GO 100649
// for j in list [ nat ] do
100684: LD_ADDR_VAR 0 5
100688: PUSH
100689: LD_VAR 0 10
100693: PUSH
100694: LD_VAR 0 7
100698: ARRAY
100699: PUSH
100700: FOR_IN
100701: IFFALSE 100742
// if GetBWeapon ( i ) = j [ 1 ] then
100703: LD_VAR 0 4
100707: PPUSH
100708: CALL_OW 269
100712: PUSH
100713: LD_VAR 0 5
100717: PUSH
100718: LD_INT 1
100720: ARRAY
100721: EQUAL
100722: IFFALSE 100740
// begin weapon := j [ 2 ] ;
100724: LD_ADDR_VAR 0 8
100728: PUSH
100729: LD_VAR 0 5
100733: PUSH
100734: LD_INT 2
100736: ARRAY
100737: ST_TO_ADDR
// break ;
100738: GO 100742
// end ;
100740: GO 100700
100742: POP
100743: POP
// if not weapon then
100744: LD_VAR 0 8
100748: NOT
100749: IFFALSE 100753
// continue ;
100751: GO 100649
// for k in factories do
100753: LD_ADDR_VAR 0 6
100757: PUSH
100758: LD_VAR 0 2
100762: PUSH
100763: FOR_IN
100764: IFFALSE 100829
// begin weapons := AvailableWeaponList ( k ) ;
100766: LD_ADDR_VAR 0 9
100770: PUSH
100771: LD_VAR 0 6
100775: PPUSH
100776: CALL_OW 478
100780: ST_TO_ADDR
// if not weapons then
100781: LD_VAR 0 9
100785: NOT
100786: IFFALSE 100790
// continue ;
100788: GO 100763
// if weapon in weapons then
100790: LD_VAR 0 8
100794: PUSH
100795: LD_VAR 0 9
100799: IN
100800: IFFALSE 100827
// begin result := [ i , weapon ] ;
100802: LD_ADDR_VAR 0 3
100806: PUSH
100807: LD_VAR 0 4
100811: PUSH
100812: LD_VAR 0 8
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: ST_TO_ADDR
// exit ;
100821: POP
100822: POP
100823: POP
100824: POP
100825: GO 100835
// end ; end ;
100827: GO 100763
100829: POP
100830: POP
// end ;
100831: GO 100649
100833: POP
100834: POP
// end ;
100835: LD_VAR 0 3
100839: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100840: LD_INT 0
100842: PPUSH
// if not side or side > 8 then
100843: LD_VAR 0 3
100847: NOT
100848: PUSH
100849: LD_VAR 0 3
100853: PUSH
100854: LD_INT 8
100856: GREATER
100857: OR
100858: IFFALSE 100862
// exit ;
100860: GO 100921
// if not range then
100862: LD_VAR 0 4
100866: NOT
100867: IFFALSE 100878
// range := - 12 ;
100869: LD_ADDR_VAR 0 4
100873: PUSH
100874: LD_INT 12
100876: NEG
100877: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100878: LD_VAR 0 1
100882: PPUSH
100883: LD_VAR 0 2
100887: PPUSH
100888: LD_VAR 0 3
100892: PPUSH
100893: LD_VAR 0 4
100897: PPUSH
100898: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100902: LD_VAR 0 1
100906: PPUSH
100907: LD_VAR 0 2
100911: PPUSH
100912: LD_VAR 0 3
100916: PPUSH
100917: CALL_OW 331
// end ;
100921: LD_VAR 0 5
100925: RET
// export function Video ( mode ) ; begin
100926: LD_INT 0
100928: PPUSH
// ingame_video = mode ;
100929: LD_ADDR_OWVAR 52
100933: PUSH
100934: LD_VAR 0 1
100938: ST_TO_ADDR
// interface_hidden = mode ;
100939: LD_ADDR_OWVAR 54
100943: PUSH
100944: LD_VAR 0 1
100948: ST_TO_ADDR
// end ;
100949: LD_VAR 0 2
100953: RET
// export function Join ( array , element ) ; begin
100954: LD_INT 0
100956: PPUSH
// result := array ^ element ;
100957: LD_ADDR_VAR 0 3
100961: PUSH
100962: LD_VAR 0 1
100966: PUSH
100967: LD_VAR 0 2
100971: ADD
100972: ST_TO_ADDR
// end ;
100973: LD_VAR 0 3
100977: RET
// export function JoinUnion ( array , element ) ; begin
100978: LD_INT 0
100980: PPUSH
// result := array union element ;
100981: LD_ADDR_VAR 0 3
100985: PUSH
100986: LD_VAR 0 1
100990: PUSH
100991: LD_VAR 0 2
100995: UNION
100996: ST_TO_ADDR
// end ;
100997: LD_VAR 0 3
101001: RET
// export function GetBehemoths ( side ) ; begin
101002: LD_INT 0
101004: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101005: LD_ADDR_VAR 0 2
101009: PUSH
101010: LD_INT 22
101012: PUSH
101013: LD_VAR 0 1
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PUSH
101022: LD_INT 31
101024: PUSH
101025: LD_INT 25
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: PPUSH
101036: CALL_OW 69
101040: ST_TO_ADDR
// end ;
101041: LD_VAR 0 2
101045: RET
// export function Shuffle ( array ) ; var i , index ; begin
101046: LD_INT 0
101048: PPUSH
101049: PPUSH
101050: PPUSH
// result := [ ] ;
101051: LD_ADDR_VAR 0 2
101055: PUSH
101056: EMPTY
101057: ST_TO_ADDR
// if not array then
101058: LD_VAR 0 1
101062: NOT
101063: IFFALSE 101067
// exit ;
101065: GO 101166
// Randomize ;
101067: CALL_OW 10
// for i = array downto 1 do
101071: LD_ADDR_VAR 0 3
101075: PUSH
101076: DOUBLE
101077: LD_VAR 0 1
101081: INC
101082: ST_TO_ADDR
101083: LD_INT 1
101085: PUSH
101086: FOR_DOWNTO
101087: IFFALSE 101164
// begin index := rand ( 1 , array ) ;
101089: LD_ADDR_VAR 0 4
101093: PUSH
101094: LD_INT 1
101096: PPUSH
101097: LD_VAR 0 1
101101: PPUSH
101102: CALL_OW 12
101106: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101107: LD_ADDR_VAR 0 2
101111: PUSH
101112: LD_VAR 0 2
101116: PPUSH
101117: LD_VAR 0 2
101121: PUSH
101122: LD_INT 1
101124: PLUS
101125: PPUSH
101126: LD_VAR 0 1
101130: PUSH
101131: LD_VAR 0 4
101135: ARRAY
101136: PPUSH
101137: CALL_OW 2
101141: ST_TO_ADDR
// array := Delete ( array , index ) ;
101142: LD_ADDR_VAR 0 1
101146: PUSH
101147: LD_VAR 0 1
101151: PPUSH
101152: LD_VAR 0 4
101156: PPUSH
101157: CALL_OW 3
101161: ST_TO_ADDR
// end ;
101162: GO 101086
101164: POP
101165: POP
// end ;
101166: LD_VAR 0 2
101170: RET
// export function GetBaseMaterials ( base ) ; begin
101171: LD_INT 0
101173: PPUSH
// result := [ 0 , 0 , 0 ] ;
101174: LD_ADDR_VAR 0 2
101178: PUSH
101179: LD_INT 0
101181: PUSH
101182: LD_INT 0
101184: PUSH
101185: LD_INT 0
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: LIST
101192: ST_TO_ADDR
// if not base then
101193: LD_VAR 0 1
101197: NOT
101198: IFFALSE 101202
// exit ;
101200: GO 101251
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101202: LD_ADDR_VAR 0 2
101206: PUSH
101207: LD_VAR 0 1
101211: PPUSH
101212: LD_INT 1
101214: PPUSH
101215: CALL_OW 275
101219: PUSH
101220: LD_VAR 0 1
101224: PPUSH
101225: LD_INT 2
101227: PPUSH
101228: CALL_OW 275
101232: PUSH
101233: LD_VAR 0 1
101237: PPUSH
101238: LD_INT 3
101240: PPUSH
101241: CALL_OW 275
101245: PUSH
101246: EMPTY
101247: LIST
101248: LIST
101249: LIST
101250: ST_TO_ADDR
// end ;
101251: LD_VAR 0 2
101255: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101256: LD_INT 0
101258: PPUSH
101259: PPUSH
// result := array ;
101260: LD_ADDR_VAR 0 3
101264: PUSH
101265: LD_VAR 0 1
101269: ST_TO_ADDR
// if size > 0 then
101270: LD_VAR 0 2
101274: PUSH
101275: LD_INT 0
101277: GREATER
101278: IFFALSE 101324
// for i := array downto size do
101280: LD_ADDR_VAR 0 4
101284: PUSH
101285: DOUBLE
101286: LD_VAR 0 1
101290: INC
101291: ST_TO_ADDR
101292: LD_VAR 0 2
101296: PUSH
101297: FOR_DOWNTO
101298: IFFALSE 101322
// result := Delete ( result , result ) ;
101300: LD_ADDR_VAR 0 3
101304: PUSH
101305: LD_VAR 0 3
101309: PPUSH
101310: LD_VAR 0 3
101314: PPUSH
101315: CALL_OW 3
101319: ST_TO_ADDR
101320: GO 101297
101322: POP
101323: POP
// end ;
101324: LD_VAR 0 3
101328: RET
// export function ComExit ( unit ) ; var tmp ; begin
101329: LD_INT 0
101331: PPUSH
101332: PPUSH
// if not IsInUnit ( unit ) then
101333: LD_VAR 0 1
101337: PPUSH
101338: CALL_OW 310
101342: NOT
101343: IFFALSE 101347
// exit ;
101345: GO 101407
// tmp := IsInUnit ( unit ) ;
101347: LD_ADDR_VAR 0 3
101351: PUSH
101352: LD_VAR 0 1
101356: PPUSH
101357: CALL_OW 310
101361: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101362: LD_VAR 0 3
101366: PPUSH
101367: CALL_OW 247
101371: PUSH
101372: LD_INT 2
101374: EQUAL
101375: IFFALSE 101388
// ComExitVehicle ( unit ) else
101377: LD_VAR 0 1
101381: PPUSH
101382: CALL_OW 121
101386: GO 101397
// ComExitBuilding ( unit ) ;
101388: LD_VAR 0 1
101392: PPUSH
101393: CALL_OW 122
// result := tmp ;
101397: LD_ADDR_VAR 0 2
101401: PUSH
101402: LD_VAR 0 3
101406: ST_TO_ADDR
// end ;
101407: LD_VAR 0 2
101411: RET
// export function ResetHc ; begin
101412: LD_INT 0
101414: PPUSH
// InitHc ;
101415: CALL_OW 19
// hc_importance := 0 ;
101419: LD_ADDR_OWVAR 32
101423: PUSH
101424: LD_INT 0
101426: ST_TO_ADDR
// end ; end_of_file end_of_file
101427: LD_VAR 0 1
101431: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
101432: GO 101434
101434: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
101435: LD_STRING initStreamRollete();
101437: PPUSH
101438: CALL_OW 559
// InitStreamMode ;
101442: CALL 101451 0 0
// DefineStreamItems ( ) ;
101446: CALL 101891 0 0
// end ;
101450: END
// function InitStreamMode ; begin
101451: LD_INT 0
101453: PPUSH
// streamModeActive := false ;
101454: LD_ADDR_EXP 154
101458: PUSH
101459: LD_INT 0
101461: ST_TO_ADDR
// normalCounter := 36 ;
101462: LD_ADDR_EXP 155
101466: PUSH
101467: LD_INT 36
101469: ST_TO_ADDR
// hardcoreCounter := 16 ;
101470: LD_ADDR_EXP 156
101474: PUSH
101475: LD_INT 16
101477: ST_TO_ADDR
// sRocket := false ;
101478: LD_ADDR_EXP 159
101482: PUSH
101483: LD_INT 0
101485: ST_TO_ADDR
// sSpeed := false ;
101486: LD_ADDR_EXP 158
101490: PUSH
101491: LD_INT 0
101493: ST_TO_ADDR
// sEngine := false ;
101494: LD_ADDR_EXP 160
101498: PUSH
101499: LD_INT 0
101501: ST_TO_ADDR
// sSpec := false ;
101502: LD_ADDR_EXP 157
101506: PUSH
101507: LD_INT 0
101509: ST_TO_ADDR
// sLevel := false ;
101510: LD_ADDR_EXP 161
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
// sArmoury := false ;
101518: LD_ADDR_EXP 162
101522: PUSH
101523: LD_INT 0
101525: ST_TO_ADDR
// sRadar := false ;
101526: LD_ADDR_EXP 163
101530: PUSH
101531: LD_INT 0
101533: ST_TO_ADDR
// sBunker := false ;
101534: LD_ADDR_EXP 164
101538: PUSH
101539: LD_INT 0
101541: ST_TO_ADDR
// sHack := false ;
101542: LD_ADDR_EXP 165
101546: PUSH
101547: LD_INT 0
101549: ST_TO_ADDR
// sFire := false ;
101550: LD_ADDR_EXP 166
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// sRefresh := false ;
101558: LD_ADDR_EXP 167
101562: PUSH
101563: LD_INT 0
101565: ST_TO_ADDR
// sExp := false ;
101566: LD_ADDR_EXP 168
101570: PUSH
101571: LD_INT 0
101573: ST_TO_ADDR
// sDepot := false ;
101574: LD_ADDR_EXP 169
101578: PUSH
101579: LD_INT 0
101581: ST_TO_ADDR
// sFlag := false ;
101582: LD_ADDR_EXP 170
101586: PUSH
101587: LD_INT 0
101589: ST_TO_ADDR
// sKamikadze := false ;
101590: LD_ADDR_EXP 178
101594: PUSH
101595: LD_INT 0
101597: ST_TO_ADDR
// sTroll := false ;
101598: LD_ADDR_EXP 179
101602: PUSH
101603: LD_INT 0
101605: ST_TO_ADDR
// sSlow := false ;
101606: LD_ADDR_EXP 180
101610: PUSH
101611: LD_INT 0
101613: ST_TO_ADDR
// sLack := false ;
101614: LD_ADDR_EXP 181
101618: PUSH
101619: LD_INT 0
101621: ST_TO_ADDR
// sTank := false ;
101622: LD_ADDR_EXP 183
101626: PUSH
101627: LD_INT 0
101629: ST_TO_ADDR
// sRemote := false ;
101630: LD_ADDR_EXP 184
101634: PUSH
101635: LD_INT 0
101637: ST_TO_ADDR
// sPowell := false ;
101638: LD_ADDR_EXP 185
101642: PUSH
101643: LD_INT 0
101645: ST_TO_ADDR
// sTeleport := false ;
101646: LD_ADDR_EXP 188
101650: PUSH
101651: LD_INT 0
101653: ST_TO_ADDR
// sOilTower := false ;
101654: LD_ADDR_EXP 190
101658: PUSH
101659: LD_INT 0
101661: ST_TO_ADDR
// sShovel := false ;
101662: LD_ADDR_EXP 191
101666: PUSH
101667: LD_INT 0
101669: ST_TO_ADDR
// sSheik := false ;
101670: LD_ADDR_EXP 192
101674: PUSH
101675: LD_INT 0
101677: ST_TO_ADDR
// sEarthquake := false ;
101678: LD_ADDR_EXP 194
101682: PUSH
101683: LD_INT 0
101685: ST_TO_ADDR
// sAI := false ;
101686: LD_ADDR_EXP 195
101690: PUSH
101691: LD_INT 0
101693: ST_TO_ADDR
// sCargo := false ;
101694: LD_ADDR_EXP 198
101698: PUSH
101699: LD_INT 0
101701: ST_TO_ADDR
// sDLaser := false ;
101702: LD_ADDR_EXP 199
101706: PUSH
101707: LD_INT 0
101709: ST_TO_ADDR
// sExchange := false ;
101710: LD_ADDR_EXP 200
101714: PUSH
101715: LD_INT 0
101717: ST_TO_ADDR
// sFac := false ;
101718: LD_ADDR_EXP 201
101722: PUSH
101723: LD_INT 0
101725: ST_TO_ADDR
// sPower := false ;
101726: LD_ADDR_EXP 202
101730: PUSH
101731: LD_INT 0
101733: ST_TO_ADDR
// sRandom := false ;
101734: LD_ADDR_EXP 203
101738: PUSH
101739: LD_INT 0
101741: ST_TO_ADDR
// sShield := false ;
101742: LD_ADDR_EXP 204
101746: PUSH
101747: LD_INT 0
101749: ST_TO_ADDR
// sTime := false ;
101750: LD_ADDR_EXP 205
101754: PUSH
101755: LD_INT 0
101757: ST_TO_ADDR
// sTools := false ;
101758: LD_ADDR_EXP 206
101762: PUSH
101763: LD_INT 0
101765: ST_TO_ADDR
// sSold := false ;
101766: LD_ADDR_EXP 171
101770: PUSH
101771: LD_INT 0
101773: ST_TO_ADDR
// sDiff := false ;
101774: LD_ADDR_EXP 172
101778: PUSH
101779: LD_INT 0
101781: ST_TO_ADDR
// sFog := false ;
101782: LD_ADDR_EXP 175
101786: PUSH
101787: LD_INT 0
101789: ST_TO_ADDR
// sReset := false ;
101790: LD_ADDR_EXP 176
101794: PUSH
101795: LD_INT 0
101797: ST_TO_ADDR
// sSun := false ;
101798: LD_ADDR_EXP 177
101802: PUSH
101803: LD_INT 0
101805: ST_TO_ADDR
// sTiger := false ;
101806: LD_ADDR_EXP 173
101810: PUSH
101811: LD_INT 0
101813: ST_TO_ADDR
// sBomb := false ;
101814: LD_ADDR_EXP 174
101818: PUSH
101819: LD_INT 0
101821: ST_TO_ADDR
// sWound := false ;
101822: LD_ADDR_EXP 182
101826: PUSH
101827: LD_INT 0
101829: ST_TO_ADDR
// sBetray := false ;
101830: LD_ADDR_EXP 186
101834: PUSH
101835: LD_INT 0
101837: ST_TO_ADDR
// sContamin := false ;
101838: LD_ADDR_EXP 187
101842: PUSH
101843: LD_INT 0
101845: ST_TO_ADDR
// sOil := false ;
101846: LD_ADDR_EXP 189
101850: PUSH
101851: LD_INT 0
101853: ST_TO_ADDR
// sStu := false ;
101854: LD_ADDR_EXP 193
101858: PUSH
101859: LD_INT 0
101861: ST_TO_ADDR
// sBazooka := false ;
101862: LD_ADDR_EXP 196
101866: PUSH
101867: LD_INT 0
101869: ST_TO_ADDR
// sMortar := false ;
101870: LD_ADDR_EXP 197
101874: PUSH
101875: LD_INT 0
101877: ST_TO_ADDR
// sRanger := false ;
101878: LD_ADDR_EXP 207
101882: PUSH
101883: LD_INT 0
101885: ST_TO_ADDR
// end ;
101886: LD_VAR 0 1
101890: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
101891: LD_INT 0
101893: PPUSH
101894: PPUSH
101895: PPUSH
101896: PPUSH
101897: PPUSH
// result := [ ] ;
101898: LD_ADDR_VAR 0 1
101902: PUSH
101903: EMPTY
101904: ST_TO_ADDR
// if campaign_id = 1 then
101905: LD_OWVAR 69
101909: PUSH
101910: LD_INT 1
101912: EQUAL
101913: IFFALSE 104851
// begin case mission_number of 1 :
101915: LD_OWVAR 70
101919: PUSH
101920: LD_INT 1
101922: DOUBLE
101923: EQUAL
101924: IFTRUE 101928
101926: GO 101992
101928: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
101929: LD_ADDR_VAR 0 1
101933: PUSH
101934: LD_INT 2
101936: PUSH
101937: LD_INT 4
101939: PUSH
101940: LD_INT 11
101942: PUSH
101943: LD_INT 12
101945: PUSH
101946: LD_INT 15
101948: PUSH
101949: LD_INT 16
101951: PUSH
101952: LD_INT 22
101954: PUSH
101955: LD_INT 23
101957: PUSH
101958: LD_INT 26
101960: PUSH
101961: EMPTY
101962: LIST
101963: LIST
101964: LIST
101965: LIST
101966: LIST
101967: LIST
101968: LIST
101969: LIST
101970: LIST
101971: PUSH
101972: LD_INT 101
101974: PUSH
101975: LD_INT 102
101977: PUSH
101978: LD_INT 106
101980: PUSH
101981: EMPTY
101982: LIST
101983: LIST
101984: LIST
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: ST_TO_ADDR
101990: GO 104849
101992: LD_INT 2
101994: DOUBLE
101995: EQUAL
101996: IFTRUE 102000
101998: GO 102072
102000: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
102001: LD_ADDR_VAR 0 1
102005: PUSH
102006: LD_INT 2
102008: PUSH
102009: LD_INT 4
102011: PUSH
102012: LD_INT 11
102014: PUSH
102015: LD_INT 12
102017: PUSH
102018: LD_INT 15
102020: PUSH
102021: LD_INT 16
102023: PUSH
102024: LD_INT 22
102026: PUSH
102027: LD_INT 23
102029: PUSH
102030: LD_INT 26
102032: PUSH
102033: EMPTY
102034: LIST
102035: LIST
102036: LIST
102037: LIST
102038: LIST
102039: LIST
102040: LIST
102041: LIST
102042: LIST
102043: PUSH
102044: LD_INT 101
102046: PUSH
102047: LD_INT 102
102049: PUSH
102050: LD_INT 105
102052: PUSH
102053: LD_INT 106
102055: PUSH
102056: LD_INT 108
102058: PUSH
102059: EMPTY
102060: LIST
102061: LIST
102062: LIST
102063: LIST
102064: LIST
102065: PUSH
102066: EMPTY
102067: LIST
102068: LIST
102069: ST_TO_ADDR
102070: GO 104849
102072: LD_INT 3
102074: DOUBLE
102075: EQUAL
102076: IFTRUE 102080
102078: GO 102156
102080: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
102081: LD_ADDR_VAR 0 1
102085: PUSH
102086: LD_INT 2
102088: PUSH
102089: LD_INT 4
102091: PUSH
102092: LD_INT 5
102094: PUSH
102095: LD_INT 11
102097: PUSH
102098: LD_INT 12
102100: PUSH
102101: LD_INT 15
102103: PUSH
102104: LD_INT 16
102106: PUSH
102107: LD_INT 22
102109: PUSH
102110: LD_INT 26
102112: PUSH
102113: LD_INT 36
102115: PUSH
102116: EMPTY
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: LIST
102127: PUSH
102128: LD_INT 101
102130: PUSH
102131: LD_INT 102
102133: PUSH
102134: LD_INT 105
102136: PUSH
102137: LD_INT 106
102139: PUSH
102140: LD_INT 108
102142: PUSH
102143: EMPTY
102144: LIST
102145: LIST
102146: LIST
102147: LIST
102148: LIST
102149: PUSH
102150: EMPTY
102151: LIST
102152: LIST
102153: ST_TO_ADDR
102154: GO 104849
102156: LD_INT 4
102158: DOUBLE
102159: EQUAL
102160: IFTRUE 102164
102162: GO 102248
102164: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
102165: LD_ADDR_VAR 0 1
102169: PUSH
102170: LD_INT 2
102172: PUSH
102173: LD_INT 4
102175: PUSH
102176: LD_INT 5
102178: PUSH
102179: LD_INT 8
102181: PUSH
102182: LD_INT 11
102184: PUSH
102185: LD_INT 12
102187: PUSH
102188: LD_INT 15
102190: PUSH
102191: LD_INT 16
102193: PUSH
102194: LD_INT 22
102196: PUSH
102197: LD_INT 23
102199: PUSH
102200: LD_INT 26
102202: PUSH
102203: LD_INT 36
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: LIST
102219: PUSH
102220: LD_INT 101
102222: PUSH
102223: LD_INT 102
102225: PUSH
102226: LD_INT 105
102228: PUSH
102229: LD_INT 106
102231: PUSH
102232: LD_INT 108
102234: PUSH
102235: EMPTY
102236: LIST
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: PUSH
102242: EMPTY
102243: LIST
102244: LIST
102245: ST_TO_ADDR
102246: GO 104849
102248: LD_INT 5
102250: DOUBLE
102251: EQUAL
102252: IFTRUE 102256
102254: GO 102356
102256: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
102257: LD_ADDR_VAR 0 1
102261: PUSH
102262: LD_INT 2
102264: PUSH
102265: LD_INT 4
102267: PUSH
102268: LD_INT 5
102270: PUSH
102271: LD_INT 6
102273: PUSH
102274: LD_INT 8
102276: PUSH
102277: LD_INT 11
102279: PUSH
102280: LD_INT 12
102282: PUSH
102283: LD_INT 15
102285: PUSH
102286: LD_INT 16
102288: PUSH
102289: LD_INT 22
102291: PUSH
102292: LD_INT 23
102294: PUSH
102295: LD_INT 25
102297: PUSH
102298: LD_INT 26
102300: PUSH
102301: LD_INT 36
102303: PUSH
102304: EMPTY
102305: LIST
102306: LIST
102307: LIST
102308: LIST
102309: LIST
102310: LIST
102311: LIST
102312: LIST
102313: LIST
102314: LIST
102315: LIST
102316: LIST
102317: LIST
102318: LIST
102319: PUSH
102320: LD_INT 101
102322: PUSH
102323: LD_INT 102
102325: PUSH
102326: LD_INT 105
102328: PUSH
102329: LD_INT 106
102331: PUSH
102332: LD_INT 108
102334: PUSH
102335: LD_INT 109
102337: PUSH
102338: LD_INT 112
102340: PUSH
102341: EMPTY
102342: LIST
102343: LIST
102344: LIST
102345: LIST
102346: LIST
102347: LIST
102348: LIST
102349: PUSH
102350: EMPTY
102351: LIST
102352: LIST
102353: ST_TO_ADDR
102354: GO 104849
102356: LD_INT 6
102358: DOUBLE
102359: EQUAL
102360: IFTRUE 102364
102362: GO 102484
102364: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
102365: LD_ADDR_VAR 0 1
102369: PUSH
102370: LD_INT 2
102372: PUSH
102373: LD_INT 4
102375: PUSH
102376: LD_INT 5
102378: PUSH
102379: LD_INT 6
102381: PUSH
102382: LD_INT 8
102384: PUSH
102385: LD_INT 11
102387: PUSH
102388: LD_INT 12
102390: PUSH
102391: LD_INT 15
102393: PUSH
102394: LD_INT 16
102396: PUSH
102397: LD_INT 20
102399: PUSH
102400: LD_INT 21
102402: PUSH
102403: LD_INT 22
102405: PUSH
102406: LD_INT 23
102408: PUSH
102409: LD_INT 25
102411: PUSH
102412: LD_INT 26
102414: PUSH
102415: LD_INT 30
102417: PUSH
102418: LD_INT 31
102420: PUSH
102421: LD_INT 32
102423: PUSH
102424: LD_INT 36
102426: PUSH
102427: EMPTY
102428: LIST
102429: LIST
102430: LIST
102431: LIST
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: LIST
102437: LIST
102438: LIST
102439: LIST
102440: LIST
102441: LIST
102442: LIST
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: PUSH
102448: LD_INT 101
102450: PUSH
102451: LD_INT 102
102453: PUSH
102454: LD_INT 105
102456: PUSH
102457: LD_INT 106
102459: PUSH
102460: LD_INT 108
102462: PUSH
102463: LD_INT 109
102465: PUSH
102466: LD_INT 112
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: LIST
102473: LIST
102474: LIST
102475: LIST
102476: LIST
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: ST_TO_ADDR
102482: GO 104849
102484: LD_INT 7
102486: DOUBLE
102487: EQUAL
102488: IFTRUE 102492
102490: GO 102592
102492: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
102493: LD_ADDR_VAR 0 1
102497: PUSH
102498: LD_INT 2
102500: PUSH
102501: LD_INT 4
102503: PUSH
102504: LD_INT 5
102506: PUSH
102507: LD_INT 7
102509: PUSH
102510: LD_INT 11
102512: PUSH
102513: LD_INT 12
102515: PUSH
102516: LD_INT 15
102518: PUSH
102519: LD_INT 16
102521: PUSH
102522: LD_INT 20
102524: PUSH
102525: LD_INT 21
102527: PUSH
102528: LD_INT 22
102530: PUSH
102531: LD_INT 23
102533: PUSH
102534: LD_INT 25
102536: PUSH
102537: LD_INT 26
102539: PUSH
102540: EMPTY
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: LIST
102546: LIST
102547: LIST
102548: LIST
102549: LIST
102550: LIST
102551: LIST
102552: LIST
102553: LIST
102554: LIST
102555: PUSH
102556: LD_INT 101
102558: PUSH
102559: LD_INT 102
102561: PUSH
102562: LD_INT 103
102564: PUSH
102565: LD_INT 105
102567: PUSH
102568: LD_INT 106
102570: PUSH
102571: LD_INT 108
102573: PUSH
102574: LD_INT 112
102576: PUSH
102577: EMPTY
102578: LIST
102579: LIST
102580: LIST
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: PUSH
102586: EMPTY
102587: LIST
102588: LIST
102589: ST_TO_ADDR
102590: GO 104849
102592: LD_INT 8
102594: DOUBLE
102595: EQUAL
102596: IFTRUE 102600
102598: GO 102728
102600: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
102601: LD_ADDR_VAR 0 1
102605: PUSH
102606: LD_INT 2
102608: PUSH
102609: LD_INT 4
102611: PUSH
102612: LD_INT 5
102614: PUSH
102615: LD_INT 6
102617: PUSH
102618: LD_INT 7
102620: PUSH
102621: LD_INT 8
102623: PUSH
102624: LD_INT 11
102626: PUSH
102627: LD_INT 12
102629: PUSH
102630: LD_INT 15
102632: PUSH
102633: LD_INT 16
102635: PUSH
102636: LD_INT 20
102638: PUSH
102639: LD_INT 21
102641: PUSH
102642: LD_INT 22
102644: PUSH
102645: LD_INT 23
102647: PUSH
102648: LD_INT 25
102650: PUSH
102651: LD_INT 26
102653: PUSH
102654: LD_INT 30
102656: PUSH
102657: LD_INT 31
102659: PUSH
102660: LD_INT 32
102662: PUSH
102663: LD_INT 36
102665: PUSH
102666: EMPTY
102667: LIST
102668: LIST
102669: LIST
102670: LIST
102671: LIST
102672: LIST
102673: LIST
102674: LIST
102675: LIST
102676: LIST
102677: LIST
102678: LIST
102679: LIST
102680: LIST
102681: LIST
102682: LIST
102683: LIST
102684: LIST
102685: LIST
102686: LIST
102687: PUSH
102688: LD_INT 101
102690: PUSH
102691: LD_INT 102
102693: PUSH
102694: LD_INT 103
102696: PUSH
102697: LD_INT 105
102699: PUSH
102700: LD_INT 106
102702: PUSH
102703: LD_INT 108
102705: PUSH
102706: LD_INT 109
102708: PUSH
102709: LD_INT 112
102711: PUSH
102712: EMPTY
102713: LIST
102714: LIST
102715: LIST
102716: LIST
102717: LIST
102718: LIST
102719: LIST
102720: LIST
102721: PUSH
102722: EMPTY
102723: LIST
102724: LIST
102725: ST_TO_ADDR
102726: GO 104849
102728: LD_INT 9
102730: DOUBLE
102731: EQUAL
102732: IFTRUE 102736
102734: GO 102872
102736: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
102737: LD_ADDR_VAR 0 1
102741: PUSH
102742: LD_INT 2
102744: PUSH
102745: LD_INT 4
102747: PUSH
102748: LD_INT 5
102750: PUSH
102751: LD_INT 6
102753: PUSH
102754: LD_INT 7
102756: PUSH
102757: LD_INT 8
102759: PUSH
102760: LD_INT 11
102762: PUSH
102763: LD_INT 12
102765: PUSH
102766: LD_INT 15
102768: PUSH
102769: LD_INT 16
102771: PUSH
102772: LD_INT 20
102774: PUSH
102775: LD_INT 21
102777: PUSH
102778: LD_INT 22
102780: PUSH
102781: LD_INT 23
102783: PUSH
102784: LD_INT 25
102786: PUSH
102787: LD_INT 26
102789: PUSH
102790: LD_INT 28
102792: PUSH
102793: LD_INT 30
102795: PUSH
102796: LD_INT 31
102798: PUSH
102799: LD_INT 32
102801: PUSH
102802: LD_INT 36
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: LIST
102809: LIST
102810: LIST
102811: LIST
102812: LIST
102813: LIST
102814: LIST
102815: LIST
102816: LIST
102817: LIST
102818: LIST
102819: LIST
102820: LIST
102821: LIST
102822: LIST
102823: LIST
102824: LIST
102825: LIST
102826: LIST
102827: PUSH
102828: LD_INT 101
102830: PUSH
102831: LD_INT 102
102833: PUSH
102834: LD_INT 103
102836: PUSH
102837: LD_INT 105
102839: PUSH
102840: LD_INT 106
102842: PUSH
102843: LD_INT 108
102845: PUSH
102846: LD_INT 109
102848: PUSH
102849: LD_INT 112
102851: PUSH
102852: LD_INT 114
102854: PUSH
102855: EMPTY
102856: LIST
102857: LIST
102858: LIST
102859: LIST
102860: LIST
102861: LIST
102862: LIST
102863: LIST
102864: LIST
102865: PUSH
102866: EMPTY
102867: LIST
102868: LIST
102869: ST_TO_ADDR
102870: GO 104849
102872: LD_INT 10
102874: DOUBLE
102875: EQUAL
102876: IFTRUE 102880
102878: GO 103064
102880: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
102881: LD_ADDR_VAR 0 1
102885: PUSH
102886: LD_INT 2
102888: PUSH
102889: LD_INT 4
102891: PUSH
102892: LD_INT 5
102894: PUSH
102895: LD_INT 6
102897: PUSH
102898: LD_INT 7
102900: PUSH
102901: LD_INT 8
102903: PUSH
102904: LD_INT 9
102906: PUSH
102907: LD_INT 10
102909: PUSH
102910: LD_INT 11
102912: PUSH
102913: LD_INT 12
102915: PUSH
102916: LD_INT 13
102918: PUSH
102919: LD_INT 14
102921: PUSH
102922: LD_INT 15
102924: PUSH
102925: LD_INT 16
102927: PUSH
102928: LD_INT 17
102930: PUSH
102931: LD_INT 18
102933: PUSH
102934: LD_INT 19
102936: PUSH
102937: LD_INT 20
102939: PUSH
102940: LD_INT 21
102942: PUSH
102943: LD_INT 22
102945: PUSH
102946: LD_INT 23
102948: PUSH
102949: LD_INT 24
102951: PUSH
102952: LD_INT 25
102954: PUSH
102955: LD_INT 26
102957: PUSH
102958: LD_INT 28
102960: PUSH
102961: LD_INT 30
102963: PUSH
102964: LD_INT 31
102966: PUSH
102967: LD_INT 32
102969: PUSH
102970: LD_INT 36
102972: PUSH
102973: EMPTY
102974: LIST
102975: LIST
102976: LIST
102977: LIST
102978: LIST
102979: LIST
102980: LIST
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: LIST
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: LIST
102991: LIST
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: LIST
102997: LIST
102998: LIST
102999: LIST
103000: LIST
103001: LIST
103002: LIST
103003: PUSH
103004: LD_INT 101
103006: PUSH
103007: LD_INT 102
103009: PUSH
103010: LD_INT 103
103012: PUSH
103013: LD_INT 104
103015: PUSH
103016: LD_INT 105
103018: PUSH
103019: LD_INT 106
103021: PUSH
103022: LD_INT 107
103024: PUSH
103025: LD_INT 108
103027: PUSH
103028: LD_INT 109
103030: PUSH
103031: LD_INT 110
103033: PUSH
103034: LD_INT 111
103036: PUSH
103037: LD_INT 112
103039: PUSH
103040: LD_INT 114
103042: PUSH
103043: EMPTY
103044: LIST
103045: LIST
103046: LIST
103047: LIST
103048: LIST
103049: LIST
103050: LIST
103051: LIST
103052: LIST
103053: LIST
103054: LIST
103055: LIST
103056: LIST
103057: PUSH
103058: EMPTY
103059: LIST
103060: LIST
103061: ST_TO_ADDR
103062: GO 104849
103064: LD_INT 11
103066: DOUBLE
103067: EQUAL
103068: IFTRUE 103072
103070: GO 103264
103072: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
103073: LD_ADDR_VAR 0 1
103077: PUSH
103078: LD_INT 2
103080: PUSH
103081: LD_INT 3
103083: PUSH
103084: LD_INT 4
103086: PUSH
103087: LD_INT 5
103089: PUSH
103090: LD_INT 6
103092: PUSH
103093: LD_INT 7
103095: PUSH
103096: LD_INT 8
103098: PUSH
103099: LD_INT 9
103101: PUSH
103102: LD_INT 10
103104: PUSH
103105: LD_INT 11
103107: PUSH
103108: LD_INT 12
103110: PUSH
103111: LD_INT 13
103113: PUSH
103114: LD_INT 14
103116: PUSH
103117: LD_INT 15
103119: PUSH
103120: LD_INT 16
103122: PUSH
103123: LD_INT 17
103125: PUSH
103126: LD_INT 18
103128: PUSH
103129: LD_INT 19
103131: PUSH
103132: LD_INT 20
103134: PUSH
103135: LD_INT 21
103137: PUSH
103138: LD_INT 22
103140: PUSH
103141: LD_INT 23
103143: PUSH
103144: LD_INT 24
103146: PUSH
103147: LD_INT 25
103149: PUSH
103150: LD_INT 26
103152: PUSH
103153: LD_INT 28
103155: PUSH
103156: LD_INT 30
103158: PUSH
103159: LD_INT 31
103161: PUSH
103162: LD_INT 32
103164: PUSH
103165: LD_INT 34
103167: PUSH
103168: LD_INT 36
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: LIST
103175: LIST
103176: LIST
103177: LIST
103178: LIST
103179: LIST
103180: LIST
103181: LIST
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: LIST
103194: LIST
103195: LIST
103196: LIST
103197: LIST
103198: LIST
103199: LIST
103200: LIST
103201: LIST
103202: LIST
103203: PUSH
103204: LD_INT 101
103206: PUSH
103207: LD_INT 102
103209: PUSH
103210: LD_INT 103
103212: PUSH
103213: LD_INT 104
103215: PUSH
103216: LD_INT 105
103218: PUSH
103219: LD_INT 106
103221: PUSH
103222: LD_INT 107
103224: PUSH
103225: LD_INT 108
103227: PUSH
103228: LD_INT 109
103230: PUSH
103231: LD_INT 110
103233: PUSH
103234: LD_INT 111
103236: PUSH
103237: LD_INT 112
103239: PUSH
103240: LD_INT 114
103242: PUSH
103243: EMPTY
103244: LIST
103245: LIST
103246: LIST
103247: LIST
103248: LIST
103249: LIST
103250: LIST
103251: LIST
103252: LIST
103253: LIST
103254: LIST
103255: LIST
103256: LIST
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: ST_TO_ADDR
103262: GO 104849
103264: LD_INT 12
103266: DOUBLE
103267: EQUAL
103268: IFTRUE 103272
103270: GO 103480
103272: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
103273: LD_ADDR_VAR 0 1
103277: PUSH
103278: LD_INT 1
103280: PUSH
103281: LD_INT 2
103283: PUSH
103284: LD_INT 3
103286: PUSH
103287: LD_INT 4
103289: PUSH
103290: LD_INT 5
103292: PUSH
103293: LD_INT 6
103295: PUSH
103296: LD_INT 7
103298: PUSH
103299: LD_INT 8
103301: PUSH
103302: LD_INT 9
103304: PUSH
103305: LD_INT 10
103307: PUSH
103308: LD_INT 11
103310: PUSH
103311: LD_INT 12
103313: PUSH
103314: LD_INT 13
103316: PUSH
103317: LD_INT 14
103319: PUSH
103320: LD_INT 15
103322: PUSH
103323: LD_INT 16
103325: PUSH
103326: LD_INT 17
103328: PUSH
103329: LD_INT 18
103331: PUSH
103332: LD_INT 19
103334: PUSH
103335: LD_INT 20
103337: PUSH
103338: LD_INT 21
103340: PUSH
103341: LD_INT 22
103343: PUSH
103344: LD_INT 23
103346: PUSH
103347: LD_INT 24
103349: PUSH
103350: LD_INT 25
103352: PUSH
103353: LD_INT 26
103355: PUSH
103356: LD_INT 27
103358: PUSH
103359: LD_INT 28
103361: PUSH
103362: LD_INT 30
103364: PUSH
103365: LD_INT 31
103367: PUSH
103368: LD_INT 32
103370: PUSH
103371: LD_INT 33
103373: PUSH
103374: LD_INT 34
103376: PUSH
103377: LD_INT 36
103379: PUSH
103380: EMPTY
103381: LIST
103382: LIST
103383: LIST
103384: LIST
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: LIST
103391: LIST
103392: LIST
103393: LIST
103394: LIST
103395: LIST
103396: LIST
103397: LIST
103398: LIST
103399: LIST
103400: LIST
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: LIST
103407: LIST
103408: LIST
103409: LIST
103410: LIST
103411: LIST
103412: LIST
103413: LIST
103414: LIST
103415: PUSH
103416: LD_INT 101
103418: PUSH
103419: LD_INT 102
103421: PUSH
103422: LD_INT 103
103424: PUSH
103425: LD_INT 104
103427: PUSH
103428: LD_INT 105
103430: PUSH
103431: LD_INT 106
103433: PUSH
103434: LD_INT 107
103436: PUSH
103437: LD_INT 108
103439: PUSH
103440: LD_INT 109
103442: PUSH
103443: LD_INT 110
103445: PUSH
103446: LD_INT 111
103448: PUSH
103449: LD_INT 112
103451: PUSH
103452: LD_INT 113
103454: PUSH
103455: LD_INT 114
103457: PUSH
103458: EMPTY
103459: LIST
103460: LIST
103461: LIST
103462: LIST
103463: LIST
103464: LIST
103465: LIST
103466: LIST
103467: LIST
103468: LIST
103469: LIST
103470: LIST
103471: LIST
103472: LIST
103473: PUSH
103474: EMPTY
103475: LIST
103476: LIST
103477: ST_TO_ADDR
103478: GO 104849
103480: LD_INT 13
103482: DOUBLE
103483: EQUAL
103484: IFTRUE 103488
103486: GO 103684
103488: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
103489: LD_ADDR_VAR 0 1
103493: PUSH
103494: LD_INT 1
103496: PUSH
103497: LD_INT 2
103499: PUSH
103500: LD_INT 3
103502: PUSH
103503: LD_INT 4
103505: PUSH
103506: LD_INT 5
103508: PUSH
103509: LD_INT 8
103511: PUSH
103512: LD_INT 9
103514: PUSH
103515: LD_INT 10
103517: PUSH
103518: LD_INT 11
103520: PUSH
103521: LD_INT 12
103523: PUSH
103524: LD_INT 14
103526: PUSH
103527: LD_INT 15
103529: PUSH
103530: LD_INT 16
103532: PUSH
103533: LD_INT 17
103535: PUSH
103536: LD_INT 18
103538: PUSH
103539: LD_INT 19
103541: PUSH
103542: LD_INT 20
103544: PUSH
103545: LD_INT 21
103547: PUSH
103548: LD_INT 22
103550: PUSH
103551: LD_INT 23
103553: PUSH
103554: LD_INT 24
103556: PUSH
103557: LD_INT 25
103559: PUSH
103560: LD_INT 26
103562: PUSH
103563: LD_INT 27
103565: PUSH
103566: LD_INT 28
103568: PUSH
103569: LD_INT 30
103571: PUSH
103572: LD_INT 31
103574: PUSH
103575: LD_INT 32
103577: PUSH
103578: LD_INT 33
103580: PUSH
103581: LD_INT 34
103583: PUSH
103584: LD_INT 36
103586: PUSH
103587: EMPTY
103588: LIST
103589: LIST
103590: LIST
103591: LIST
103592: LIST
103593: LIST
103594: LIST
103595: LIST
103596: LIST
103597: LIST
103598: LIST
103599: LIST
103600: LIST
103601: LIST
103602: LIST
103603: LIST
103604: LIST
103605: LIST
103606: LIST
103607: LIST
103608: LIST
103609: LIST
103610: LIST
103611: LIST
103612: LIST
103613: LIST
103614: LIST
103615: LIST
103616: LIST
103617: LIST
103618: LIST
103619: PUSH
103620: LD_INT 101
103622: PUSH
103623: LD_INT 102
103625: PUSH
103626: LD_INT 103
103628: PUSH
103629: LD_INT 104
103631: PUSH
103632: LD_INT 105
103634: PUSH
103635: LD_INT 106
103637: PUSH
103638: LD_INT 107
103640: PUSH
103641: LD_INT 108
103643: PUSH
103644: LD_INT 109
103646: PUSH
103647: LD_INT 110
103649: PUSH
103650: LD_INT 111
103652: PUSH
103653: LD_INT 112
103655: PUSH
103656: LD_INT 113
103658: PUSH
103659: LD_INT 114
103661: PUSH
103662: EMPTY
103663: LIST
103664: LIST
103665: LIST
103666: LIST
103667: LIST
103668: LIST
103669: LIST
103670: LIST
103671: LIST
103672: LIST
103673: LIST
103674: LIST
103675: LIST
103676: LIST
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: ST_TO_ADDR
103682: GO 104849
103684: LD_INT 14
103686: DOUBLE
103687: EQUAL
103688: IFTRUE 103692
103690: GO 103904
103692: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
103693: LD_ADDR_VAR 0 1
103697: PUSH
103698: LD_INT 1
103700: PUSH
103701: LD_INT 2
103703: PUSH
103704: LD_INT 3
103706: PUSH
103707: LD_INT 4
103709: PUSH
103710: LD_INT 5
103712: PUSH
103713: LD_INT 6
103715: PUSH
103716: LD_INT 7
103718: PUSH
103719: LD_INT 8
103721: PUSH
103722: LD_INT 9
103724: PUSH
103725: LD_INT 10
103727: PUSH
103728: LD_INT 11
103730: PUSH
103731: LD_INT 12
103733: PUSH
103734: LD_INT 13
103736: PUSH
103737: LD_INT 14
103739: PUSH
103740: LD_INT 15
103742: PUSH
103743: LD_INT 16
103745: PUSH
103746: LD_INT 17
103748: PUSH
103749: LD_INT 18
103751: PUSH
103752: LD_INT 19
103754: PUSH
103755: LD_INT 20
103757: PUSH
103758: LD_INT 21
103760: PUSH
103761: LD_INT 22
103763: PUSH
103764: LD_INT 23
103766: PUSH
103767: LD_INT 24
103769: PUSH
103770: LD_INT 25
103772: PUSH
103773: LD_INT 26
103775: PUSH
103776: LD_INT 27
103778: PUSH
103779: LD_INT 28
103781: PUSH
103782: LD_INT 29
103784: PUSH
103785: LD_INT 30
103787: PUSH
103788: LD_INT 31
103790: PUSH
103791: LD_INT 32
103793: PUSH
103794: LD_INT 33
103796: PUSH
103797: LD_INT 34
103799: PUSH
103800: LD_INT 36
103802: PUSH
103803: EMPTY
103804: LIST
103805: LIST
103806: LIST
103807: LIST
103808: LIST
103809: LIST
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: LIST
103815: LIST
103816: LIST
103817: LIST
103818: LIST
103819: LIST
103820: LIST
103821: LIST
103822: LIST
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: LIST
103830: LIST
103831: LIST
103832: LIST
103833: LIST
103834: LIST
103835: LIST
103836: LIST
103837: LIST
103838: LIST
103839: PUSH
103840: LD_INT 101
103842: PUSH
103843: LD_INT 102
103845: PUSH
103846: LD_INT 103
103848: PUSH
103849: LD_INT 104
103851: PUSH
103852: LD_INT 105
103854: PUSH
103855: LD_INT 106
103857: PUSH
103858: LD_INT 107
103860: PUSH
103861: LD_INT 108
103863: PUSH
103864: LD_INT 109
103866: PUSH
103867: LD_INT 110
103869: PUSH
103870: LD_INT 111
103872: PUSH
103873: LD_INT 112
103875: PUSH
103876: LD_INT 113
103878: PUSH
103879: LD_INT 114
103881: PUSH
103882: EMPTY
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: LIST
103888: LIST
103889: LIST
103890: LIST
103891: LIST
103892: LIST
103893: LIST
103894: LIST
103895: LIST
103896: LIST
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: ST_TO_ADDR
103902: GO 104849
103904: LD_INT 15
103906: DOUBLE
103907: EQUAL
103908: IFTRUE 103912
103910: GO 104124
103912: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
103913: LD_ADDR_VAR 0 1
103917: PUSH
103918: LD_INT 1
103920: PUSH
103921: LD_INT 2
103923: PUSH
103924: LD_INT 3
103926: PUSH
103927: LD_INT 4
103929: PUSH
103930: LD_INT 5
103932: PUSH
103933: LD_INT 6
103935: PUSH
103936: LD_INT 7
103938: PUSH
103939: LD_INT 8
103941: PUSH
103942: LD_INT 9
103944: PUSH
103945: LD_INT 10
103947: PUSH
103948: LD_INT 11
103950: PUSH
103951: LD_INT 12
103953: PUSH
103954: LD_INT 13
103956: PUSH
103957: LD_INT 14
103959: PUSH
103960: LD_INT 15
103962: PUSH
103963: LD_INT 16
103965: PUSH
103966: LD_INT 17
103968: PUSH
103969: LD_INT 18
103971: PUSH
103972: LD_INT 19
103974: PUSH
103975: LD_INT 20
103977: PUSH
103978: LD_INT 21
103980: PUSH
103981: LD_INT 22
103983: PUSH
103984: LD_INT 23
103986: PUSH
103987: LD_INT 24
103989: PUSH
103990: LD_INT 25
103992: PUSH
103993: LD_INT 26
103995: PUSH
103996: LD_INT 27
103998: PUSH
103999: LD_INT 28
104001: PUSH
104002: LD_INT 29
104004: PUSH
104005: LD_INT 30
104007: PUSH
104008: LD_INT 31
104010: PUSH
104011: LD_INT 32
104013: PUSH
104014: LD_INT 33
104016: PUSH
104017: LD_INT 34
104019: PUSH
104020: LD_INT 36
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: LIST
104027: LIST
104028: LIST
104029: LIST
104030: LIST
104031: LIST
104032: LIST
104033: LIST
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: LIST
104039: LIST
104040: LIST
104041: LIST
104042: LIST
104043: LIST
104044: LIST
104045: LIST
104046: LIST
104047: LIST
104048: LIST
104049: LIST
104050: LIST
104051: LIST
104052: LIST
104053: LIST
104054: LIST
104055: LIST
104056: LIST
104057: LIST
104058: LIST
104059: PUSH
104060: LD_INT 101
104062: PUSH
104063: LD_INT 102
104065: PUSH
104066: LD_INT 103
104068: PUSH
104069: LD_INT 104
104071: PUSH
104072: LD_INT 105
104074: PUSH
104075: LD_INT 106
104077: PUSH
104078: LD_INT 107
104080: PUSH
104081: LD_INT 108
104083: PUSH
104084: LD_INT 109
104086: PUSH
104087: LD_INT 110
104089: PUSH
104090: LD_INT 111
104092: PUSH
104093: LD_INT 112
104095: PUSH
104096: LD_INT 113
104098: PUSH
104099: LD_INT 114
104101: PUSH
104102: EMPTY
104103: LIST
104104: LIST
104105: LIST
104106: LIST
104107: LIST
104108: LIST
104109: LIST
104110: LIST
104111: LIST
104112: LIST
104113: LIST
104114: LIST
104115: LIST
104116: LIST
104117: PUSH
104118: EMPTY
104119: LIST
104120: LIST
104121: ST_TO_ADDR
104122: GO 104849
104124: LD_INT 16
104126: DOUBLE
104127: EQUAL
104128: IFTRUE 104132
104130: GO 104256
104132: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
104133: LD_ADDR_VAR 0 1
104137: PUSH
104138: LD_INT 2
104140: PUSH
104141: LD_INT 4
104143: PUSH
104144: LD_INT 5
104146: PUSH
104147: LD_INT 7
104149: PUSH
104150: LD_INT 11
104152: PUSH
104153: LD_INT 12
104155: PUSH
104156: LD_INT 15
104158: PUSH
104159: LD_INT 16
104161: PUSH
104162: LD_INT 20
104164: PUSH
104165: LD_INT 21
104167: PUSH
104168: LD_INT 22
104170: PUSH
104171: LD_INT 23
104173: PUSH
104174: LD_INT 25
104176: PUSH
104177: LD_INT 26
104179: PUSH
104180: LD_INT 30
104182: PUSH
104183: LD_INT 31
104185: PUSH
104186: LD_INT 32
104188: PUSH
104189: LD_INT 33
104191: PUSH
104192: LD_INT 34
104194: PUSH
104195: EMPTY
104196: LIST
104197: LIST
104198: LIST
104199: LIST
104200: LIST
104201: LIST
104202: LIST
104203: LIST
104204: LIST
104205: LIST
104206: LIST
104207: LIST
104208: LIST
104209: LIST
104210: LIST
104211: LIST
104212: LIST
104213: LIST
104214: LIST
104215: PUSH
104216: LD_INT 101
104218: PUSH
104219: LD_INT 102
104221: PUSH
104222: LD_INT 103
104224: PUSH
104225: LD_INT 106
104227: PUSH
104228: LD_INT 108
104230: PUSH
104231: LD_INT 112
104233: PUSH
104234: LD_INT 113
104236: PUSH
104237: LD_INT 114
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: LIST
104247: LIST
104248: LIST
104249: PUSH
104250: EMPTY
104251: LIST
104252: LIST
104253: ST_TO_ADDR
104254: GO 104849
104256: LD_INT 17
104258: DOUBLE
104259: EQUAL
104260: IFTRUE 104264
104262: GO 104476
104264: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
104265: LD_ADDR_VAR 0 1
104269: PUSH
104270: LD_INT 1
104272: PUSH
104273: LD_INT 2
104275: PUSH
104276: LD_INT 3
104278: PUSH
104279: LD_INT 4
104281: PUSH
104282: LD_INT 5
104284: PUSH
104285: LD_INT 6
104287: PUSH
104288: LD_INT 7
104290: PUSH
104291: LD_INT 8
104293: PUSH
104294: LD_INT 9
104296: PUSH
104297: LD_INT 10
104299: PUSH
104300: LD_INT 11
104302: PUSH
104303: LD_INT 12
104305: PUSH
104306: LD_INT 13
104308: PUSH
104309: LD_INT 14
104311: PUSH
104312: LD_INT 15
104314: PUSH
104315: LD_INT 16
104317: PUSH
104318: LD_INT 17
104320: PUSH
104321: LD_INT 18
104323: PUSH
104324: LD_INT 19
104326: PUSH
104327: LD_INT 20
104329: PUSH
104330: LD_INT 21
104332: PUSH
104333: LD_INT 22
104335: PUSH
104336: LD_INT 23
104338: PUSH
104339: LD_INT 24
104341: PUSH
104342: LD_INT 25
104344: PUSH
104345: LD_INT 26
104347: PUSH
104348: LD_INT 27
104350: PUSH
104351: LD_INT 28
104353: PUSH
104354: LD_INT 29
104356: PUSH
104357: LD_INT 30
104359: PUSH
104360: LD_INT 31
104362: PUSH
104363: LD_INT 32
104365: PUSH
104366: LD_INT 33
104368: PUSH
104369: LD_INT 34
104371: PUSH
104372: LD_INT 36
104374: PUSH
104375: EMPTY
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: LIST
104393: LIST
104394: LIST
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: LIST
104400: LIST
104401: LIST
104402: LIST
104403: LIST
104404: LIST
104405: LIST
104406: LIST
104407: LIST
104408: LIST
104409: LIST
104410: LIST
104411: PUSH
104412: LD_INT 101
104414: PUSH
104415: LD_INT 102
104417: PUSH
104418: LD_INT 103
104420: PUSH
104421: LD_INT 104
104423: PUSH
104424: LD_INT 105
104426: PUSH
104427: LD_INT 106
104429: PUSH
104430: LD_INT 107
104432: PUSH
104433: LD_INT 108
104435: PUSH
104436: LD_INT 109
104438: PUSH
104439: LD_INT 110
104441: PUSH
104442: LD_INT 111
104444: PUSH
104445: LD_INT 112
104447: PUSH
104448: LD_INT 113
104450: PUSH
104451: LD_INT 114
104453: PUSH
104454: EMPTY
104455: LIST
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: LIST
104462: LIST
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: LIST
104468: LIST
104469: PUSH
104470: EMPTY
104471: LIST
104472: LIST
104473: ST_TO_ADDR
104474: GO 104849
104476: LD_INT 18
104478: DOUBLE
104479: EQUAL
104480: IFTRUE 104484
104482: GO 104620
104484: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
104485: LD_ADDR_VAR 0 1
104489: PUSH
104490: LD_INT 2
104492: PUSH
104493: LD_INT 4
104495: PUSH
104496: LD_INT 5
104498: PUSH
104499: LD_INT 7
104501: PUSH
104502: LD_INT 11
104504: PUSH
104505: LD_INT 12
104507: PUSH
104508: LD_INT 15
104510: PUSH
104511: LD_INT 16
104513: PUSH
104514: LD_INT 20
104516: PUSH
104517: LD_INT 21
104519: PUSH
104520: LD_INT 22
104522: PUSH
104523: LD_INT 23
104525: PUSH
104526: LD_INT 25
104528: PUSH
104529: LD_INT 26
104531: PUSH
104532: LD_INT 30
104534: PUSH
104535: LD_INT 31
104537: PUSH
104538: LD_INT 32
104540: PUSH
104541: LD_INT 33
104543: PUSH
104544: LD_INT 34
104546: PUSH
104547: LD_INT 35
104549: PUSH
104550: LD_INT 36
104552: PUSH
104553: EMPTY
104554: LIST
104555: LIST
104556: LIST
104557: LIST
104558: LIST
104559: LIST
104560: LIST
104561: LIST
104562: LIST
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: LIST
104568: LIST
104569: LIST
104570: LIST
104571: LIST
104572: LIST
104573: LIST
104574: LIST
104575: PUSH
104576: LD_INT 101
104578: PUSH
104579: LD_INT 102
104581: PUSH
104582: LD_INT 103
104584: PUSH
104585: LD_INT 106
104587: PUSH
104588: LD_INT 108
104590: PUSH
104591: LD_INT 112
104593: PUSH
104594: LD_INT 113
104596: PUSH
104597: LD_INT 114
104599: PUSH
104600: LD_INT 115
104602: PUSH
104603: EMPTY
104604: LIST
104605: LIST
104606: LIST
104607: LIST
104608: LIST
104609: LIST
104610: LIST
104611: LIST
104612: LIST
104613: PUSH
104614: EMPTY
104615: LIST
104616: LIST
104617: ST_TO_ADDR
104618: GO 104849
104620: LD_INT 19
104622: DOUBLE
104623: EQUAL
104624: IFTRUE 104628
104626: GO 104848
104628: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
104629: LD_ADDR_VAR 0 1
104633: PUSH
104634: LD_INT 1
104636: PUSH
104637: LD_INT 2
104639: PUSH
104640: LD_INT 3
104642: PUSH
104643: LD_INT 4
104645: PUSH
104646: LD_INT 5
104648: PUSH
104649: LD_INT 6
104651: PUSH
104652: LD_INT 7
104654: PUSH
104655: LD_INT 8
104657: PUSH
104658: LD_INT 9
104660: PUSH
104661: LD_INT 10
104663: PUSH
104664: LD_INT 11
104666: PUSH
104667: LD_INT 12
104669: PUSH
104670: LD_INT 13
104672: PUSH
104673: LD_INT 14
104675: PUSH
104676: LD_INT 15
104678: PUSH
104679: LD_INT 16
104681: PUSH
104682: LD_INT 17
104684: PUSH
104685: LD_INT 18
104687: PUSH
104688: LD_INT 19
104690: PUSH
104691: LD_INT 20
104693: PUSH
104694: LD_INT 21
104696: PUSH
104697: LD_INT 22
104699: PUSH
104700: LD_INT 23
104702: PUSH
104703: LD_INT 24
104705: PUSH
104706: LD_INT 25
104708: PUSH
104709: LD_INT 26
104711: PUSH
104712: LD_INT 27
104714: PUSH
104715: LD_INT 28
104717: PUSH
104718: LD_INT 29
104720: PUSH
104721: LD_INT 30
104723: PUSH
104724: LD_INT 31
104726: PUSH
104727: LD_INT 32
104729: PUSH
104730: LD_INT 33
104732: PUSH
104733: LD_INT 34
104735: PUSH
104736: LD_INT 35
104738: PUSH
104739: LD_INT 36
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: LIST
104746: LIST
104747: LIST
104748: LIST
104749: LIST
104750: LIST
104751: LIST
104752: LIST
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: LIST
104758: LIST
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: PUSH
104780: LD_INT 101
104782: PUSH
104783: LD_INT 102
104785: PUSH
104786: LD_INT 103
104788: PUSH
104789: LD_INT 104
104791: PUSH
104792: LD_INT 105
104794: PUSH
104795: LD_INT 106
104797: PUSH
104798: LD_INT 107
104800: PUSH
104801: LD_INT 108
104803: PUSH
104804: LD_INT 109
104806: PUSH
104807: LD_INT 110
104809: PUSH
104810: LD_INT 111
104812: PUSH
104813: LD_INT 112
104815: PUSH
104816: LD_INT 113
104818: PUSH
104819: LD_INT 114
104821: PUSH
104822: LD_INT 115
104824: PUSH
104825: EMPTY
104826: LIST
104827: LIST
104828: LIST
104829: LIST
104830: LIST
104831: LIST
104832: LIST
104833: LIST
104834: LIST
104835: LIST
104836: LIST
104837: LIST
104838: LIST
104839: LIST
104840: LIST
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: ST_TO_ADDR
104846: GO 104849
104848: POP
// end else
104849: GO 105068
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
104851: LD_ADDR_VAR 0 1
104855: PUSH
104856: LD_INT 1
104858: PUSH
104859: LD_INT 2
104861: PUSH
104862: LD_INT 3
104864: PUSH
104865: LD_INT 4
104867: PUSH
104868: LD_INT 5
104870: PUSH
104871: LD_INT 6
104873: PUSH
104874: LD_INT 7
104876: PUSH
104877: LD_INT 8
104879: PUSH
104880: LD_INT 9
104882: PUSH
104883: LD_INT 10
104885: PUSH
104886: LD_INT 11
104888: PUSH
104889: LD_INT 12
104891: PUSH
104892: LD_INT 13
104894: PUSH
104895: LD_INT 14
104897: PUSH
104898: LD_INT 15
104900: PUSH
104901: LD_INT 16
104903: PUSH
104904: LD_INT 17
104906: PUSH
104907: LD_INT 18
104909: PUSH
104910: LD_INT 19
104912: PUSH
104913: LD_INT 20
104915: PUSH
104916: LD_INT 21
104918: PUSH
104919: LD_INT 22
104921: PUSH
104922: LD_INT 23
104924: PUSH
104925: LD_INT 24
104927: PUSH
104928: LD_INT 25
104930: PUSH
104931: LD_INT 26
104933: PUSH
104934: LD_INT 27
104936: PUSH
104937: LD_INT 28
104939: PUSH
104940: LD_INT 29
104942: PUSH
104943: LD_INT 30
104945: PUSH
104946: LD_INT 31
104948: PUSH
104949: LD_INT 32
104951: PUSH
104952: LD_INT 33
104954: PUSH
104955: LD_INT 34
104957: PUSH
104958: LD_INT 35
104960: PUSH
104961: LD_INT 36
104963: PUSH
104964: EMPTY
104965: LIST
104966: LIST
104967: LIST
104968: LIST
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: LIST
104974: LIST
104975: LIST
104976: LIST
104977: LIST
104978: LIST
104979: LIST
104980: LIST
104981: LIST
104982: LIST
104983: LIST
104984: LIST
104985: LIST
104986: LIST
104987: LIST
104988: LIST
104989: LIST
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: LIST
104995: LIST
104996: LIST
104997: LIST
104998: LIST
104999: LIST
105000: LIST
105001: PUSH
105002: LD_INT 101
105004: PUSH
105005: LD_INT 102
105007: PUSH
105008: LD_INT 103
105010: PUSH
105011: LD_INT 104
105013: PUSH
105014: LD_INT 105
105016: PUSH
105017: LD_INT 106
105019: PUSH
105020: LD_INT 107
105022: PUSH
105023: LD_INT 108
105025: PUSH
105026: LD_INT 109
105028: PUSH
105029: LD_INT 110
105031: PUSH
105032: LD_INT 111
105034: PUSH
105035: LD_INT 112
105037: PUSH
105038: LD_INT 113
105040: PUSH
105041: LD_INT 114
105043: PUSH
105044: LD_INT 115
105046: PUSH
105047: EMPTY
105048: LIST
105049: LIST
105050: LIST
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: LIST
105056: LIST
105057: LIST
105058: LIST
105059: LIST
105060: LIST
105061: LIST
105062: LIST
105063: PUSH
105064: EMPTY
105065: LIST
105066: LIST
105067: ST_TO_ADDR
// if result then
105068: LD_VAR 0 1
105072: IFFALSE 105361
// begin normal :=  ;
105074: LD_ADDR_VAR 0 3
105078: PUSH
105079: LD_STRING 
105081: ST_TO_ADDR
// hardcore :=  ;
105082: LD_ADDR_VAR 0 4
105086: PUSH
105087: LD_STRING 
105089: ST_TO_ADDR
// for i = 1 to normalCounter do
105090: LD_ADDR_VAR 0 5
105094: PUSH
105095: DOUBLE
105096: LD_INT 1
105098: DEC
105099: ST_TO_ADDR
105100: LD_EXP 155
105104: PUSH
105105: FOR_TO
105106: IFFALSE 105207
// begin tmp := 0 ;
105108: LD_ADDR_VAR 0 2
105112: PUSH
105113: LD_STRING 0
105115: ST_TO_ADDR
// if result [ 1 ] then
105116: LD_VAR 0 1
105120: PUSH
105121: LD_INT 1
105123: ARRAY
105124: IFFALSE 105189
// if result [ 1 ] [ 1 ] = i then
105126: LD_VAR 0 1
105130: PUSH
105131: LD_INT 1
105133: ARRAY
105134: PUSH
105135: LD_INT 1
105137: ARRAY
105138: PUSH
105139: LD_VAR 0 5
105143: EQUAL
105144: IFFALSE 105189
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
105146: LD_ADDR_VAR 0 1
105150: PUSH
105151: LD_VAR 0 1
105155: PPUSH
105156: LD_INT 1
105158: PPUSH
105159: LD_VAR 0 1
105163: PUSH
105164: LD_INT 1
105166: ARRAY
105167: PPUSH
105168: LD_INT 1
105170: PPUSH
105171: CALL_OW 3
105175: PPUSH
105176: CALL_OW 1
105180: ST_TO_ADDR
// tmp := 1 ;
105181: LD_ADDR_VAR 0 2
105185: PUSH
105186: LD_STRING 1
105188: ST_TO_ADDR
// end ; normal := normal & tmp ;
105189: LD_ADDR_VAR 0 3
105193: PUSH
105194: LD_VAR 0 3
105198: PUSH
105199: LD_VAR 0 2
105203: STR
105204: ST_TO_ADDR
// end ;
105205: GO 105105
105207: POP
105208: POP
// for i = 1 to hardcoreCounter do
105209: LD_ADDR_VAR 0 5
105213: PUSH
105214: DOUBLE
105215: LD_INT 1
105217: DEC
105218: ST_TO_ADDR
105219: LD_EXP 156
105223: PUSH
105224: FOR_TO
105225: IFFALSE 105330
// begin tmp := 0 ;
105227: LD_ADDR_VAR 0 2
105231: PUSH
105232: LD_STRING 0
105234: ST_TO_ADDR
// if result [ 2 ] then
105235: LD_VAR 0 1
105239: PUSH
105240: LD_INT 2
105242: ARRAY
105243: IFFALSE 105312
// if result [ 2 ] [ 1 ] = 100 + i then
105245: LD_VAR 0 1
105249: PUSH
105250: LD_INT 2
105252: ARRAY
105253: PUSH
105254: LD_INT 1
105256: ARRAY
105257: PUSH
105258: LD_INT 100
105260: PUSH
105261: LD_VAR 0 5
105265: PLUS
105266: EQUAL
105267: IFFALSE 105312
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
105269: LD_ADDR_VAR 0 1
105273: PUSH
105274: LD_VAR 0 1
105278: PPUSH
105279: LD_INT 2
105281: PPUSH
105282: LD_VAR 0 1
105286: PUSH
105287: LD_INT 2
105289: ARRAY
105290: PPUSH
105291: LD_INT 1
105293: PPUSH
105294: CALL_OW 3
105298: PPUSH
105299: CALL_OW 1
105303: ST_TO_ADDR
// tmp := 1 ;
105304: LD_ADDR_VAR 0 2
105308: PUSH
105309: LD_STRING 1
105311: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105312: LD_ADDR_VAR 0 4
105316: PUSH
105317: LD_VAR 0 4
105321: PUSH
105322: LD_VAR 0 2
105326: STR
105327: ST_TO_ADDR
// end ;
105328: GO 105224
105330: POP
105331: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
105332: LD_STRING getStreamItemsFromMission("
105334: PUSH
105335: LD_VAR 0 3
105339: STR
105340: PUSH
105341: LD_STRING ","
105343: STR
105344: PUSH
105345: LD_VAR 0 4
105349: STR
105350: PUSH
105351: LD_STRING ")
105353: STR
105354: PPUSH
105355: CALL_OW 559
// end else
105359: GO 105368
// ToLua ( getStreamItemsFromMission("","") ) ;
105361: LD_STRING getStreamItemsFromMission("","")
105363: PPUSH
105364: CALL_OW 559
// end ;
105368: LD_VAR 0 1
105372: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
105373: LD_VAR 0 2
105377: PUSH
105378: LD_INT 100
105380: EQUAL
105381: IFFALSE 106330
// begin if not StreamModeActive then
105383: LD_EXP 154
105387: NOT
105388: IFFALSE 105398
// StreamModeActive := true ;
105390: LD_ADDR_EXP 154
105394: PUSH
105395: LD_INT 1
105397: ST_TO_ADDR
// if p3 = 0 then
105398: LD_VAR 0 3
105402: PUSH
105403: LD_INT 0
105405: EQUAL
105406: IFFALSE 105412
// InitStreamMode ;
105408: CALL 101451 0 0
// if p3 = 1 then
105412: LD_VAR 0 3
105416: PUSH
105417: LD_INT 1
105419: EQUAL
105420: IFFALSE 105430
// sRocket := true ;
105422: LD_ADDR_EXP 159
105426: PUSH
105427: LD_INT 1
105429: ST_TO_ADDR
// if p3 = 2 then
105430: LD_VAR 0 3
105434: PUSH
105435: LD_INT 2
105437: EQUAL
105438: IFFALSE 105448
// sSpeed := true ;
105440: LD_ADDR_EXP 158
105444: PUSH
105445: LD_INT 1
105447: ST_TO_ADDR
// if p3 = 3 then
105448: LD_VAR 0 3
105452: PUSH
105453: LD_INT 3
105455: EQUAL
105456: IFFALSE 105466
// sEngine := true ;
105458: LD_ADDR_EXP 160
105462: PUSH
105463: LD_INT 1
105465: ST_TO_ADDR
// if p3 = 4 then
105466: LD_VAR 0 3
105470: PUSH
105471: LD_INT 4
105473: EQUAL
105474: IFFALSE 105484
// sSpec := true ;
105476: LD_ADDR_EXP 157
105480: PUSH
105481: LD_INT 1
105483: ST_TO_ADDR
// if p3 = 5 then
105484: LD_VAR 0 3
105488: PUSH
105489: LD_INT 5
105491: EQUAL
105492: IFFALSE 105502
// sLevel := true ;
105494: LD_ADDR_EXP 161
105498: PUSH
105499: LD_INT 1
105501: ST_TO_ADDR
// if p3 = 6 then
105502: LD_VAR 0 3
105506: PUSH
105507: LD_INT 6
105509: EQUAL
105510: IFFALSE 105520
// sArmoury := true ;
105512: LD_ADDR_EXP 162
105516: PUSH
105517: LD_INT 1
105519: ST_TO_ADDR
// if p3 = 7 then
105520: LD_VAR 0 3
105524: PUSH
105525: LD_INT 7
105527: EQUAL
105528: IFFALSE 105538
// sRadar := true ;
105530: LD_ADDR_EXP 163
105534: PUSH
105535: LD_INT 1
105537: ST_TO_ADDR
// if p3 = 8 then
105538: LD_VAR 0 3
105542: PUSH
105543: LD_INT 8
105545: EQUAL
105546: IFFALSE 105556
// sBunker := true ;
105548: LD_ADDR_EXP 164
105552: PUSH
105553: LD_INT 1
105555: ST_TO_ADDR
// if p3 = 9 then
105556: LD_VAR 0 3
105560: PUSH
105561: LD_INT 9
105563: EQUAL
105564: IFFALSE 105574
// sHack := true ;
105566: LD_ADDR_EXP 165
105570: PUSH
105571: LD_INT 1
105573: ST_TO_ADDR
// if p3 = 10 then
105574: LD_VAR 0 3
105578: PUSH
105579: LD_INT 10
105581: EQUAL
105582: IFFALSE 105592
// sFire := true ;
105584: LD_ADDR_EXP 166
105588: PUSH
105589: LD_INT 1
105591: ST_TO_ADDR
// if p3 = 11 then
105592: LD_VAR 0 3
105596: PUSH
105597: LD_INT 11
105599: EQUAL
105600: IFFALSE 105610
// sRefresh := true ;
105602: LD_ADDR_EXP 167
105606: PUSH
105607: LD_INT 1
105609: ST_TO_ADDR
// if p3 = 12 then
105610: LD_VAR 0 3
105614: PUSH
105615: LD_INT 12
105617: EQUAL
105618: IFFALSE 105628
// sExp := true ;
105620: LD_ADDR_EXP 168
105624: PUSH
105625: LD_INT 1
105627: ST_TO_ADDR
// if p3 = 13 then
105628: LD_VAR 0 3
105632: PUSH
105633: LD_INT 13
105635: EQUAL
105636: IFFALSE 105646
// sDepot := true ;
105638: LD_ADDR_EXP 169
105642: PUSH
105643: LD_INT 1
105645: ST_TO_ADDR
// if p3 = 14 then
105646: LD_VAR 0 3
105650: PUSH
105651: LD_INT 14
105653: EQUAL
105654: IFFALSE 105664
// sFlag := true ;
105656: LD_ADDR_EXP 170
105660: PUSH
105661: LD_INT 1
105663: ST_TO_ADDR
// if p3 = 15 then
105664: LD_VAR 0 3
105668: PUSH
105669: LD_INT 15
105671: EQUAL
105672: IFFALSE 105682
// sKamikadze := true ;
105674: LD_ADDR_EXP 178
105678: PUSH
105679: LD_INT 1
105681: ST_TO_ADDR
// if p3 = 16 then
105682: LD_VAR 0 3
105686: PUSH
105687: LD_INT 16
105689: EQUAL
105690: IFFALSE 105700
// sTroll := true ;
105692: LD_ADDR_EXP 179
105696: PUSH
105697: LD_INT 1
105699: ST_TO_ADDR
// if p3 = 17 then
105700: LD_VAR 0 3
105704: PUSH
105705: LD_INT 17
105707: EQUAL
105708: IFFALSE 105718
// sSlow := true ;
105710: LD_ADDR_EXP 180
105714: PUSH
105715: LD_INT 1
105717: ST_TO_ADDR
// if p3 = 18 then
105718: LD_VAR 0 3
105722: PUSH
105723: LD_INT 18
105725: EQUAL
105726: IFFALSE 105736
// sLack := true ;
105728: LD_ADDR_EXP 181
105732: PUSH
105733: LD_INT 1
105735: ST_TO_ADDR
// if p3 = 19 then
105736: LD_VAR 0 3
105740: PUSH
105741: LD_INT 19
105743: EQUAL
105744: IFFALSE 105754
// sTank := true ;
105746: LD_ADDR_EXP 183
105750: PUSH
105751: LD_INT 1
105753: ST_TO_ADDR
// if p3 = 20 then
105754: LD_VAR 0 3
105758: PUSH
105759: LD_INT 20
105761: EQUAL
105762: IFFALSE 105772
// sRemote := true ;
105764: LD_ADDR_EXP 184
105768: PUSH
105769: LD_INT 1
105771: ST_TO_ADDR
// if p3 = 21 then
105772: LD_VAR 0 3
105776: PUSH
105777: LD_INT 21
105779: EQUAL
105780: IFFALSE 105790
// sPowell := true ;
105782: LD_ADDR_EXP 185
105786: PUSH
105787: LD_INT 1
105789: ST_TO_ADDR
// if p3 = 22 then
105790: LD_VAR 0 3
105794: PUSH
105795: LD_INT 22
105797: EQUAL
105798: IFFALSE 105808
// sTeleport := true ;
105800: LD_ADDR_EXP 188
105804: PUSH
105805: LD_INT 1
105807: ST_TO_ADDR
// if p3 = 23 then
105808: LD_VAR 0 3
105812: PUSH
105813: LD_INT 23
105815: EQUAL
105816: IFFALSE 105826
// sOilTower := true ;
105818: LD_ADDR_EXP 190
105822: PUSH
105823: LD_INT 1
105825: ST_TO_ADDR
// if p3 = 24 then
105826: LD_VAR 0 3
105830: PUSH
105831: LD_INT 24
105833: EQUAL
105834: IFFALSE 105844
// sShovel := true ;
105836: LD_ADDR_EXP 191
105840: PUSH
105841: LD_INT 1
105843: ST_TO_ADDR
// if p3 = 25 then
105844: LD_VAR 0 3
105848: PUSH
105849: LD_INT 25
105851: EQUAL
105852: IFFALSE 105862
// sSheik := true ;
105854: LD_ADDR_EXP 192
105858: PUSH
105859: LD_INT 1
105861: ST_TO_ADDR
// if p3 = 26 then
105862: LD_VAR 0 3
105866: PUSH
105867: LD_INT 26
105869: EQUAL
105870: IFFALSE 105880
// sEarthquake := true ;
105872: LD_ADDR_EXP 194
105876: PUSH
105877: LD_INT 1
105879: ST_TO_ADDR
// if p3 = 27 then
105880: LD_VAR 0 3
105884: PUSH
105885: LD_INT 27
105887: EQUAL
105888: IFFALSE 105898
// sAI := true ;
105890: LD_ADDR_EXP 195
105894: PUSH
105895: LD_INT 1
105897: ST_TO_ADDR
// if p3 = 28 then
105898: LD_VAR 0 3
105902: PUSH
105903: LD_INT 28
105905: EQUAL
105906: IFFALSE 105916
// sCargo := true ;
105908: LD_ADDR_EXP 198
105912: PUSH
105913: LD_INT 1
105915: ST_TO_ADDR
// if p3 = 29 then
105916: LD_VAR 0 3
105920: PUSH
105921: LD_INT 29
105923: EQUAL
105924: IFFALSE 105934
// sDLaser := true ;
105926: LD_ADDR_EXP 199
105930: PUSH
105931: LD_INT 1
105933: ST_TO_ADDR
// if p3 = 30 then
105934: LD_VAR 0 3
105938: PUSH
105939: LD_INT 30
105941: EQUAL
105942: IFFALSE 105952
// sExchange := true ;
105944: LD_ADDR_EXP 200
105948: PUSH
105949: LD_INT 1
105951: ST_TO_ADDR
// if p3 = 31 then
105952: LD_VAR 0 3
105956: PUSH
105957: LD_INT 31
105959: EQUAL
105960: IFFALSE 105970
// sFac := true ;
105962: LD_ADDR_EXP 201
105966: PUSH
105967: LD_INT 1
105969: ST_TO_ADDR
// if p3 = 32 then
105970: LD_VAR 0 3
105974: PUSH
105975: LD_INT 32
105977: EQUAL
105978: IFFALSE 105988
// sPower := true ;
105980: LD_ADDR_EXP 202
105984: PUSH
105985: LD_INT 1
105987: ST_TO_ADDR
// if p3 = 33 then
105988: LD_VAR 0 3
105992: PUSH
105993: LD_INT 33
105995: EQUAL
105996: IFFALSE 106006
// sRandom := true ;
105998: LD_ADDR_EXP 203
106002: PUSH
106003: LD_INT 1
106005: ST_TO_ADDR
// if p3 = 34 then
106006: LD_VAR 0 3
106010: PUSH
106011: LD_INT 34
106013: EQUAL
106014: IFFALSE 106024
// sShield := true ;
106016: LD_ADDR_EXP 204
106020: PUSH
106021: LD_INT 1
106023: ST_TO_ADDR
// if p3 = 35 then
106024: LD_VAR 0 3
106028: PUSH
106029: LD_INT 35
106031: EQUAL
106032: IFFALSE 106042
// sTime := true ;
106034: LD_ADDR_EXP 205
106038: PUSH
106039: LD_INT 1
106041: ST_TO_ADDR
// if p3 = 36 then
106042: LD_VAR 0 3
106046: PUSH
106047: LD_INT 36
106049: EQUAL
106050: IFFALSE 106060
// sTools := true ;
106052: LD_ADDR_EXP 206
106056: PUSH
106057: LD_INT 1
106059: ST_TO_ADDR
// if p3 = 101 then
106060: LD_VAR 0 3
106064: PUSH
106065: LD_INT 101
106067: EQUAL
106068: IFFALSE 106078
// sSold := true ;
106070: LD_ADDR_EXP 171
106074: PUSH
106075: LD_INT 1
106077: ST_TO_ADDR
// if p3 = 102 then
106078: LD_VAR 0 3
106082: PUSH
106083: LD_INT 102
106085: EQUAL
106086: IFFALSE 106096
// sDiff := true ;
106088: LD_ADDR_EXP 172
106092: PUSH
106093: LD_INT 1
106095: ST_TO_ADDR
// if p3 = 103 then
106096: LD_VAR 0 3
106100: PUSH
106101: LD_INT 103
106103: EQUAL
106104: IFFALSE 106114
// sFog := true ;
106106: LD_ADDR_EXP 175
106110: PUSH
106111: LD_INT 1
106113: ST_TO_ADDR
// if p3 = 104 then
106114: LD_VAR 0 3
106118: PUSH
106119: LD_INT 104
106121: EQUAL
106122: IFFALSE 106132
// sReset := true ;
106124: LD_ADDR_EXP 176
106128: PUSH
106129: LD_INT 1
106131: ST_TO_ADDR
// if p3 = 105 then
106132: LD_VAR 0 3
106136: PUSH
106137: LD_INT 105
106139: EQUAL
106140: IFFALSE 106150
// sSun := true ;
106142: LD_ADDR_EXP 177
106146: PUSH
106147: LD_INT 1
106149: ST_TO_ADDR
// if p3 = 106 then
106150: LD_VAR 0 3
106154: PUSH
106155: LD_INT 106
106157: EQUAL
106158: IFFALSE 106168
// sTiger := true ;
106160: LD_ADDR_EXP 173
106164: PUSH
106165: LD_INT 1
106167: ST_TO_ADDR
// if p3 = 107 then
106168: LD_VAR 0 3
106172: PUSH
106173: LD_INT 107
106175: EQUAL
106176: IFFALSE 106186
// sBomb := true ;
106178: LD_ADDR_EXP 174
106182: PUSH
106183: LD_INT 1
106185: ST_TO_ADDR
// if p3 = 108 then
106186: LD_VAR 0 3
106190: PUSH
106191: LD_INT 108
106193: EQUAL
106194: IFFALSE 106204
// sWound := true ;
106196: LD_ADDR_EXP 182
106200: PUSH
106201: LD_INT 1
106203: ST_TO_ADDR
// if p3 = 109 then
106204: LD_VAR 0 3
106208: PUSH
106209: LD_INT 109
106211: EQUAL
106212: IFFALSE 106222
// sBetray := true ;
106214: LD_ADDR_EXP 186
106218: PUSH
106219: LD_INT 1
106221: ST_TO_ADDR
// if p3 = 110 then
106222: LD_VAR 0 3
106226: PUSH
106227: LD_INT 110
106229: EQUAL
106230: IFFALSE 106240
// sContamin := true ;
106232: LD_ADDR_EXP 187
106236: PUSH
106237: LD_INT 1
106239: ST_TO_ADDR
// if p3 = 111 then
106240: LD_VAR 0 3
106244: PUSH
106245: LD_INT 111
106247: EQUAL
106248: IFFALSE 106258
// sOil := true ;
106250: LD_ADDR_EXP 189
106254: PUSH
106255: LD_INT 1
106257: ST_TO_ADDR
// if p3 = 112 then
106258: LD_VAR 0 3
106262: PUSH
106263: LD_INT 112
106265: EQUAL
106266: IFFALSE 106276
// sStu := true ;
106268: LD_ADDR_EXP 193
106272: PUSH
106273: LD_INT 1
106275: ST_TO_ADDR
// if p3 = 113 then
106276: LD_VAR 0 3
106280: PUSH
106281: LD_INT 113
106283: EQUAL
106284: IFFALSE 106294
// sBazooka := true ;
106286: LD_ADDR_EXP 196
106290: PUSH
106291: LD_INT 1
106293: ST_TO_ADDR
// if p3 = 114 then
106294: LD_VAR 0 3
106298: PUSH
106299: LD_INT 114
106301: EQUAL
106302: IFFALSE 106312
// sMortar := true ;
106304: LD_ADDR_EXP 197
106308: PUSH
106309: LD_INT 1
106311: ST_TO_ADDR
// if p3 = 115 then
106312: LD_VAR 0 3
106316: PUSH
106317: LD_INT 115
106319: EQUAL
106320: IFFALSE 106330
// sRanger := true ;
106322: LD_ADDR_EXP 207
106326: PUSH
106327: LD_INT 1
106329: ST_TO_ADDR
// end ; end ;
106330: PPOPN 6
106332: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106333: LD_EXP 154
106337: PUSH
106338: LD_EXP 159
106342: AND
106343: IFFALSE 106467
106345: GO 106347
106347: DISABLE
106348: LD_INT 0
106350: PPUSH
106351: PPUSH
// begin enable ;
106352: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106353: LD_ADDR_VAR 0 2
106357: PUSH
106358: LD_INT 22
106360: PUSH
106361: LD_OWVAR 2
106365: PUSH
106366: EMPTY
106367: LIST
106368: LIST
106369: PUSH
106370: LD_INT 2
106372: PUSH
106373: LD_INT 34
106375: PUSH
106376: LD_INT 7
106378: PUSH
106379: EMPTY
106380: LIST
106381: LIST
106382: PUSH
106383: LD_INT 34
106385: PUSH
106386: LD_INT 45
106388: PUSH
106389: EMPTY
106390: LIST
106391: LIST
106392: PUSH
106393: LD_INT 34
106395: PUSH
106396: LD_INT 28
106398: PUSH
106399: EMPTY
106400: LIST
106401: LIST
106402: PUSH
106403: LD_INT 34
106405: PUSH
106406: LD_INT 47
106408: PUSH
106409: EMPTY
106410: LIST
106411: LIST
106412: PUSH
106413: EMPTY
106414: LIST
106415: LIST
106416: LIST
106417: LIST
106418: LIST
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PPUSH
106424: CALL_OW 69
106428: ST_TO_ADDR
// if not tmp then
106429: LD_VAR 0 2
106433: NOT
106434: IFFALSE 106438
// exit ;
106436: GO 106467
// for i in tmp do
106438: LD_ADDR_VAR 0 1
106442: PUSH
106443: LD_VAR 0 2
106447: PUSH
106448: FOR_IN
106449: IFFALSE 106465
// begin SetLives ( i , 0 ) ;
106451: LD_VAR 0 1
106455: PPUSH
106456: LD_INT 0
106458: PPUSH
106459: CALL_OW 234
// end ;
106463: GO 106448
106465: POP
106466: POP
// end ;
106467: PPOPN 2
106469: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106470: LD_EXP 154
106474: PUSH
106475: LD_EXP 160
106479: AND
106480: IFFALSE 106564
106482: GO 106484
106484: DISABLE
106485: LD_INT 0
106487: PPUSH
106488: PPUSH
// begin enable ;
106489: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106490: LD_ADDR_VAR 0 2
106494: PUSH
106495: LD_INT 22
106497: PUSH
106498: LD_OWVAR 2
106502: PUSH
106503: EMPTY
106504: LIST
106505: LIST
106506: PUSH
106507: LD_INT 32
106509: PUSH
106510: LD_INT 3
106512: PUSH
106513: EMPTY
106514: LIST
106515: LIST
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: PPUSH
106521: CALL_OW 69
106525: ST_TO_ADDR
// if not tmp then
106526: LD_VAR 0 2
106530: NOT
106531: IFFALSE 106535
// exit ;
106533: GO 106564
// for i in tmp do
106535: LD_ADDR_VAR 0 1
106539: PUSH
106540: LD_VAR 0 2
106544: PUSH
106545: FOR_IN
106546: IFFALSE 106562
// begin SetLives ( i , 0 ) ;
106548: LD_VAR 0 1
106552: PPUSH
106553: LD_INT 0
106555: PPUSH
106556: CALL_OW 234
// end ;
106560: GO 106545
106562: POP
106563: POP
// end ;
106564: PPOPN 2
106566: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106567: LD_EXP 154
106571: PUSH
106572: LD_EXP 157
106576: AND
106577: IFFALSE 106670
106579: GO 106581
106581: DISABLE
106582: LD_INT 0
106584: PPUSH
// begin enable ;
106585: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106586: LD_ADDR_VAR 0 1
106590: PUSH
106591: LD_INT 22
106593: PUSH
106594: LD_OWVAR 2
106598: PUSH
106599: EMPTY
106600: LIST
106601: LIST
106602: PUSH
106603: LD_INT 2
106605: PUSH
106606: LD_INT 25
106608: PUSH
106609: LD_INT 5
106611: PUSH
106612: EMPTY
106613: LIST
106614: LIST
106615: PUSH
106616: LD_INT 25
106618: PUSH
106619: LD_INT 9
106621: PUSH
106622: EMPTY
106623: LIST
106624: LIST
106625: PUSH
106626: LD_INT 25
106628: PUSH
106629: LD_INT 8
106631: PUSH
106632: EMPTY
106633: LIST
106634: LIST
106635: PUSH
106636: EMPTY
106637: LIST
106638: LIST
106639: LIST
106640: LIST
106641: PUSH
106642: EMPTY
106643: LIST
106644: LIST
106645: PPUSH
106646: CALL_OW 69
106650: PUSH
106651: FOR_IN
106652: IFFALSE 106668
// begin SetClass ( i , 1 ) ;
106654: LD_VAR 0 1
106658: PPUSH
106659: LD_INT 1
106661: PPUSH
106662: CALL_OW 336
// end ;
106666: GO 106651
106668: POP
106669: POP
// end ;
106670: PPOPN 1
106672: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106673: LD_EXP 154
106677: PUSH
106678: LD_EXP 158
106682: AND
106683: PUSH
106684: LD_OWVAR 65
106688: PUSH
106689: LD_INT 7
106691: LESS
106692: AND
106693: IFFALSE 106707
106695: GO 106697
106697: DISABLE
// begin enable ;
106698: ENABLE
// game_speed := 7 ;
106699: LD_ADDR_OWVAR 65
106703: PUSH
106704: LD_INT 7
106706: ST_TO_ADDR
// end ;
106707: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106708: LD_EXP 154
106712: PUSH
106713: LD_EXP 161
106717: AND
106718: IFFALSE 106920
106720: GO 106722
106722: DISABLE
106723: LD_INT 0
106725: PPUSH
106726: PPUSH
106727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106728: LD_ADDR_VAR 0 3
106732: PUSH
106733: LD_INT 81
106735: PUSH
106736: LD_OWVAR 2
106740: PUSH
106741: EMPTY
106742: LIST
106743: LIST
106744: PUSH
106745: LD_INT 21
106747: PUSH
106748: LD_INT 1
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: PUSH
106755: EMPTY
106756: LIST
106757: LIST
106758: PPUSH
106759: CALL_OW 69
106763: ST_TO_ADDR
// if not tmp then
106764: LD_VAR 0 3
106768: NOT
106769: IFFALSE 106773
// exit ;
106771: GO 106920
// if tmp > 5 then
106773: LD_VAR 0 3
106777: PUSH
106778: LD_INT 5
106780: GREATER
106781: IFFALSE 106793
// k := 5 else
106783: LD_ADDR_VAR 0 2
106787: PUSH
106788: LD_INT 5
106790: ST_TO_ADDR
106791: GO 106803
// k := tmp ;
106793: LD_ADDR_VAR 0 2
106797: PUSH
106798: LD_VAR 0 3
106802: ST_TO_ADDR
// for i := 1 to k do
106803: LD_ADDR_VAR 0 1
106807: PUSH
106808: DOUBLE
106809: LD_INT 1
106811: DEC
106812: ST_TO_ADDR
106813: LD_VAR 0 2
106817: PUSH
106818: FOR_TO
106819: IFFALSE 106918
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106821: LD_VAR 0 3
106825: PUSH
106826: LD_VAR 0 1
106830: ARRAY
106831: PPUSH
106832: LD_VAR 0 1
106836: PUSH
106837: LD_INT 4
106839: MOD
106840: PUSH
106841: LD_INT 1
106843: PLUS
106844: PPUSH
106845: CALL_OW 259
106849: PUSH
106850: LD_INT 10
106852: LESS
106853: IFFALSE 106916
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106855: LD_VAR 0 3
106859: PUSH
106860: LD_VAR 0 1
106864: ARRAY
106865: PPUSH
106866: LD_VAR 0 1
106870: PUSH
106871: LD_INT 4
106873: MOD
106874: PUSH
106875: LD_INT 1
106877: PLUS
106878: PPUSH
106879: LD_VAR 0 3
106883: PUSH
106884: LD_VAR 0 1
106888: ARRAY
106889: PPUSH
106890: LD_VAR 0 1
106894: PUSH
106895: LD_INT 4
106897: MOD
106898: PUSH
106899: LD_INT 1
106901: PLUS
106902: PPUSH
106903: CALL_OW 259
106907: PUSH
106908: LD_INT 1
106910: PLUS
106911: PPUSH
106912: CALL_OW 237
106916: GO 106818
106918: POP
106919: POP
// end ;
106920: PPOPN 3
106922: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106923: LD_EXP 154
106927: PUSH
106928: LD_EXP 162
106932: AND
106933: IFFALSE 106953
106935: GO 106937
106937: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106938: LD_INT 4
106940: PPUSH
106941: LD_OWVAR 2
106945: PPUSH
106946: LD_INT 0
106948: PPUSH
106949: CALL_OW 324
106953: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106954: LD_EXP 154
106958: PUSH
106959: LD_EXP 191
106963: AND
106964: IFFALSE 106984
106966: GO 106968
106968: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106969: LD_INT 19
106971: PPUSH
106972: LD_OWVAR 2
106976: PPUSH
106977: LD_INT 0
106979: PPUSH
106980: CALL_OW 324
106984: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106985: LD_EXP 154
106989: PUSH
106990: LD_EXP 163
106994: AND
106995: IFFALSE 107097
106997: GO 106999
106999: DISABLE
107000: LD_INT 0
107002: PPUSH
107003: PPUSH
// begin enable ;
107004: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107005: LD_ADDR_VAR 0 2
107009: PUSH
107010: LD_INT 22
107012: PUSH
107013: LD_OWVAR 2
107017: PUSH
107018: EMPTY
107019: LIST
107020: LIST
107021: PUSH
107022: LD_INT 2
107024: PUSH
107025: LD_INT 34
107027: PUSH
107028: LD_INT 11
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: PUSH
107035: LD_INT 34
107037: PUSH
107038: LD_INT 30
107040: PUSH
107041: EMPTY
107042: LIST
107043: LIST
107044: PUSH
107045: EMPTY
107046: LIST
107047: LIST
107048: LIST
107049: PUSH
107050: EMPTY
107051: LIST
107052: LIST
107053: PPUSH
107054: CALL_OW 69
107058: ST_TO_ADDR
// if not tmp then
107059: LD_VAR 0 2
107063: NOT
107064: IFFALSE 107068
// exit ;
107066: GO 107097
// for i in tmp do
107068: LD_ADDR_VAR 0 1
107072: PUSH
107073: LD_VAR 0 2
107077: PUSH
107078: FOR_IN
107079: IFFALSE 107095
// begin SetLives ( i , 0 ) ;
107081: LD_VAR 0 1
107085: PPUSH
107086: LD_INT 0
107088: PPUSH
107089: CALL_OW 234
// end ;
107093: GO 107078
107095: POP
107096: POP
// end ;
107097: PPOPN 2
107099: END
// every 0 0$1 trigger StreamModeActive and sBunker do
107100: LD_EXP 154
107104: PUSH
107105: LD_EXP 164
107109: AND
107110: IFFALSE 107130
107112: GO 107114
107114: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
107115: LD_INT 32
107117: PPUSH
107118: LD_OWVAR 2
107122: PPUSH
107123: LD_INT 0
107125: PPUSH
107126: CALL_OW 324
107130: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
107131: LD_EXP 154
107135: PUSH
107136: LD_EXP 165
107140: AND
107141: IFFALSE 107322
107143: GO 107145
107145: DISABLE
107146: LD_INT 0
107148: PPUSH
107149: PPUSH
107150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
107151: LD_ADDR_VAR 0 2
107155: PUSH
107156: LD_INT 22
107158: PUSH
107159: LD_OWVAR 2
107163: PUSH
107164: EMPTY
107165: LIST
107166: LIST
107167: PUSH
107168: LD_INT 33
107170: PUSH
107171: LD_INT 3
107173: PUSH
107174: EMPTY
107175: LIST
107176: LIST
107177: PUSH
107178: EMPTY
107179: LIST
107180: LIST
107181: PPUSH
107182: CALL_OW 69
107186: ST_TO_ADDR
// if not tmp then
107187: LD_VAR 0 2
107191: NOT
107192: IFFALSE 107196
// exit ;
107194: GO 107322
// side := 0 ;
107196: LD_ADDR_VAR 0 3
107200: PUSH
107201: LD_INT 0
107203: ST_TO_ADDR
// for i := 1 to 8 do
107204: LD_ADDR_VAR 0 1
107208: PUSH
107209: DOUBLE
107210: LD_INT 1
107212: DEC
107213: ST_TO_ADDR
107214: LD_INT 8
107216: PUSH
107217: FOR_TO
107218: IFFALSE 107266
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
107220: LD_OWVAR 2
107224: PUSH
107225: LD_VAR 0 1
107229: NONEQUAL
107230: PUSH
107231: LD_OWVAR 2
107235: PPUSH
107236: LD_VAR 0 1
107240: PPUSH
107241: CALL_OW 81
107245: PUSH
107246: LD_INT 2
107248: EQUAL
107249: AND
107250: IFFALSE 107264
// begin side := i ;
107252: LD_ADDR_VAR 0 3
107256: PUSH
107257: LD_VAR 0 1
107261: ST_TO_ADDR
// break ;
107262: GO 107266
// end ;
107264: GO 107217
107266: POP
107267: POP
// if not side then
107268: LD_VAR 0 3
107272: NOT
107273: IFFALSE 107277
// exit ;
107275: GO 107322
// for i := 1 to tmp do
107277: LD_ADDR_VAR 0 1
107281: PUSH
107282: DOUBLE
107283: LD_INT 1
107285: DEC
107286: ST_TO_ADDR
107287: LD_VAR 0 2
107291: PUSH
107292: FOR_TO
107293: IFFALSE 107320
// if Prob ( 60 ) then
107295: LD_INT 60
107297: PPUSH
107298: CALL_OW 13
107302: IFFALSE 107318
// SetSide ( i , side ) ;
107304: LD_VAR 0 1
107308: PPUSH
107309: LD_VAR 0 3
107313: PPUSH
107314: CALL_OW 235
107318: GO 107292
107320: POP
107321: POP
// end ;
107322: PPOPN 3
107324: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107325: LD_EXP 154
107329: PUSH
107330: LD_EXP 167
107334: AND
107335: IFFALSE 107454
107337: GO 107339
107339: DISABLE
107340: LD_INT 0
107342: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107343: LD_ADDR_VAR 0 1
107347: PUSH
107348: LD_INT 22
107350: PUSH
107351: LD_OWVAR 2
107355: PUSH
107356: EMPTY
107357: LIST
107358: LIST
107359: PUSH
107360: LD_INT 21
107362: PUSH
107363: LD_INT 1
107365: PUSH
107366: EMPTY
107367: LIST
107368: LIST
107369: PUSH
107370: LD_INT 3
107372: PUSH
107373: LD_INT 23
107375: PUSH
107376: LD_INT 0
107378: PUSH
107379: EMPTY
107380: LIST
107381: LIST
107382: PUSH
107383: EMPTY
107384: LIST
107385: LIST
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: LIST
107391: PPUSH
107392: CALL_OW 69
107396: PUSH
107397: FOR_IN
107398: IFFALSE 107452
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107400: LD_VAR 0 1
107404: PPUSH
107405: CALL_OW 257
107409: PUSH
107410: LD_INT 1
107412: PUSH
107413: LD_INT 2
107415: PUSH
107416: LD_INT 3
107418: PUSH
107419: LD_INT 4
107421: PUSH
107422: EMPTY
107423: LIST
107424: LIST
107425: LIST
107426: LIST
107427: IN
107428: IFFALSE 107450
// SetClass ( un , rand ( 1 , 4 ) ) ;
107430: LD_VAR 0 1
107434: PPUSH
107435: LD_INT 1
107437: PPUSH
107438: LD_INT 4
107440: PPUSH
107441: CALL_OW 12
107445: PPUSH
107446: CALL_OW 336
107450: GO 107397
107452: POP
107453: POP
// end ;
107454: PPOPN 1
107456: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107457: LD_EXP 154
107461: PUSH
107462: LD_EXP 166
107466: AND
107467: IFFALSE 107546
107469: GO 107471
107471: DISABLE
107472: LD_INT 0
107474: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107475: LD_ADDR_VAR 0 1
107479: PUSH
107480: LD_INT 22
107482: PUSH
107483: LD_OWVAR 2
107487: PUSH
107488: EMPTY
107489: LIST
107490: LIST
107491: PUSH
107492: LD_INT 21
107494: PUSH
107495: LD_INT 3
107497: PUSH
107498: EMPTY
107499: LIST
107500: LIST
107501: PUSH
107502: EMPTY
107503: LIST
107504: LIST
107505: PPUSH
107506: CALL_OW 69
107510: ST_TO_ADDR
// if not tmp then
107511: LD_VAR 0 1
107515: NOT
107516: IFFALSE 107520
// exit ;
107518: GO 107546
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107520: LD_VAR 0 1
107524: PUSH
107525: LD_INT 1
107527: PPUSH
107528: LD_VAR 0 1
107532: PPUSH
107533: CALL_OW 12
107537: ARRAY
107538: PPUSH
107539: LD_INT 100
107541: PPUSH
107542: CALL_OW 234
// end ;
107546: PPOPN 1
107548: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107549: LD_EXP 154
107553: PUSH
107554: LD_EXP 168
107558: AND
107559: IFFALSE 107657
107561: GO 107563
107563: DISABLE
107564: LD_INT 0
107566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107567: LD_ADDR_VAR 0 1
107571: PUSH
107572: LD_INT 22
107574: PUSH
107575: LD_OWVAR 2
107579: PUSH
107580: EMPTY
107581: LIST
107582: LIST
107583: PUSH
107584: LD_INT 21
107586: PUSH
107587: LD_INT 1
107589: PUSH
107590: EMPTY
107591: LIST
107592: LIST
107593: PUSH
107594: EMPTY
107595: LIST
107596: LIST
107597: PPUSH
107598: CALL_OW 69
107602: ST_TO_ADDR
// if not tmp then
107603: LD_VAR 0 1
107607: NOT
107608: IFFALSE 107612
// exit ;
107610: GO 107657
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107612: LD_VAR 0 1
107616: PUSH
107617: LD_INT 1
107619: PPUSH
107620: LD_VAR 0 1
107624: PPUSH
107625: CALL_OW 12
107629: ARRAY
107630: PPUSH
107631: LD_INT 1
107633: PPUSH
107634: LD_INT 4
107636: PPUSH
107637: CALL_OW 12
107641: PPUSH
107642: LD_INT 3000
107644: PPUSH
107645: LD_INT 9000
107647: PPUSH
107648: CALL_OW 12
107652: PPUSH
107653: CALL_OW 492
// end ;
107657: PPOPN 1
107659: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107660: LD_EXP 154
107664: PUSH
107665: LD_EXP 169
107669: AND
107670: IFFALSE 107690
107672: GO 107674
107674: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107675: LD_INT 1
107677: PPUSH
107678: LD_OWVAR 2
107682: PPUSH
107683: LD_INT 0
107685: PPUSH
107686: CALL_OW 324
107690: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107691: LD_EXP 154
107695: PUSH
107696: LD_EXP 170
107700: AND
107701: IFFALSE 107784
107703: GO 107705
107705: DISABLE
107706: LD_INT 0
107708: PPUSH
107709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107710: LD_ADDR_VAR 0 2
107714: PUSH
107715: LD_INT 22
107717: PUSH
107718: LD_OWVAR 2
107722: PUSH
107723: EMPTY
107724: LIST
107725: LIST
107726: PUSH
107727: LD_INT 21
107729: PUSH
107730: LD_INT 3
107732: PUSH
107733: EMPTY
107734: LIST
107735: LIST
107736: PUSH
107737: EMPTY
107738: LIST
107739: LIST
107740: PPUSH
107741: CALL_OW 69
107745: ST_TO_ADDR
// if not tmp then
107746: LD_VAR 0 2
107750: NOT
107751: IFFALSE 107755
// exit ;
107753: GO 107784
// for i in tmp do
107755: LD_ADDR_VAR 0 1
107759: PUSH
107760: LD_VAR 0 2
107764: PUSH
107765: FOR_IN
107766: IFFALSE 107782
// SetBLevel ( i , 10 ) ;
107768: LD_VAR 0 1
107772: PPUSH
107773: LD_INT 10
107775: PPUSH
107776: CALL_OW 241
107780: GO 107765
107782: POP
107783: POP
// end ;
107784: PPOPN 2
107786: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107787: LD_EXP 154
107791: PUSH
107792: LD_EXP 171
107796: AND
107797: IFFALSE 107908
107799: GO 107801
107801: DISABLE
107802: LD_INT 0
107804: PPUSH
107805: PPUSH
107806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107807: LD_ADDR_VAR 0 3
107811: PUSH
107812: LD_INT 22
107814: PUSH
107815: LD_OWVAR 2
107819: PUSH
107820: EMPTY
107821: LIST
107822: LIST
107823: PUSH
107824: LD_INT 25
107826: PUSH
107827: LD_INT 1
107829: PUSH
107830: EMPTY
107831: LIST
107832: LIST
107833: PUSH
107834: EMPTY
107835: LIST
107836: LIST
107837: PPUSH
107838: CALL_OW 69
107842: ST_TO_ADDR
// if not tmp then
107843: LD_VAR 0 3
107847: NOT
107848: IFFALSE 107852
// exit ;
107850: GO 107908
// un := tmp [ rand ( 1 , tmp ) ] ;
107852: LD_ADDR_VAR 0 2
107856: PUSH
107857: LD_VAR 0 3
107861: PUSH
107862: LD_INT 1
107864: PPUSH
107865: LD_VAR 0 3
107869: PPUSH
107870: CALL_OW 12
107874: ARRAY
107875: ST_TO_ADDR
// if Crawls ( un ) then
107876: LD_VAR 0 2
107880: PPUSH
107881: CALL_OW 318
107885: IFFALSE 107896
// ComWalk ( un ) ;
107887: LD_VAR 0 2
107891: PPUSH
107892: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107896: LD_VAR 0 2
107900: PPUSH
107901: LD_INT 5
107903: PPUSH
107904: CALL_OW 336
// end ;
107908: PPOPN 3
107910: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
107911: LD_EXP 154
107915: PUSH
107916: LD_EXP 172
107920: AND
107921: PUSH
107922: LD_OWVAR 67
107926: PUSH
107927: LD_INT 3
107929: LESS
107930: AND
107931: IFFALSE 107950
107933: GO 107935
107935: DISABLE
// Difficulty := Difficulty + 1 ;
107936: LD_ADDR_OWVAR 67
107940: PUSH
107941: LD_OWVAR 67
107945: PUSH
107946: LD_INT 1
107948: PLUS
107949: ST_TO_ADDR
107950: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107951: LD_EXP 154
107955: PUSH
107956: LD_EXP 173
107960: AND
107961: IFFALSE 108064
107963: GO 107965
107965: DISABLE
107966: LD_INT 0
107968: PPUSH
// begin for i := 1 to 5 do
107969: LD_ADDR_VAR 0 1
107973: PUSH
107974: DOUBLE
107975: LD_INT 1
107977: DEC
107978: ST_TO_ADDR
107979: LD_INT 5
107981: PUSH
107982: FOR_TO
107983: IFFALSE 108062
// begin uc_nation := nation_nature ;
107985: LD_ADDR_OWVAR 21
107989: PUSH
107990: LD_INT 0
107992: ST_TO_ADDR
// uc_side := 0 ;
107993: LD_ADDR_OWVAR 20
107997: PUSH
107998: LD_INT 0
108000: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108001: LD_ADDR_OWVAR 29
108005: PUSH
108006: LD_INT 12
108008: PUSH
108009: LD_INT 12
108011: PUSH
108012: EMPTY
108013: LIST
108014: LIST
108015: ST_TO_ADDR
// hc_agressivity := 20 ;
108016: LD_ADDR_OWVAR 35
108020: PUSH
108021: LD_INT 20
108023: ST_TO_ADDR
// hc_class := class_tiger ;
108024: LD_ADDR_OWVAR 28
108028: PUSH
108029: LD_INT 14
108031: ST_TO_ADDR
// hc_gallery :=  ;
108032: LD_ADDR_OWVAR 33
108036: PUSH
108037: LD_STRING 
108039: ST_TO_ADDR
// hc_name :=  ;
108040: LD_ADDR_OWVAR 26
108044: PUSH
108045: LD_STRING 
108047: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
108048: CALL_OW 44
108052: PPUSH
108053: LD_INT 0
108055: PPUSH
108056: CALL_OW 51
// end ;
108060: GO 107982
108062: POP
108063: POP
// end ;
108064: PPOPN 1
108066: END
// every 0 0$1 trigger StreamModeActive and sBomb do
108067: LD_EXP 154
108071: PUSH
108072: LD_EXP 174
108076: AND
108077: IFFALSE 108086
108079: GO 108081
108081: DISABLE
// StreamSibBomb ;
108082: CALL 108087 0 0
108086: END
// export function StreamSibBomb ; var i , x , y ; begin
108087: LD_INT 0
108089: PPUSH
108090: PPUSH
108091: PPUSH
108092: PPUSH
// result := false ;
108093: LD_ADDR_VAR 0 1
108097: PUSH
108098: LD_INT 0
108100: ST_TO_ADDR
// for i := 1 to 16 do
108101: LD_ADDR_VAR 0 2
108105: PUSH
108106: DOUBLE
108107: LD_INT 1
108109: DEC
108110: ST_TO_ADDR
108111: LD_INT 16
108113: PUSH
108114: FOR_TO
108115: IFFALSE 108314
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108117: LD_ADDR_VAR 0 3
108121: PUSH
108122: LD_INT 10
108124: PUSH
108125: LD_INT 20
108127: PUSH
108128: LD_INT 30
108130: PUSH
108131: LD_INT 40
108133: PUSH
108134: LD_INT 50
108136: PUSH
108137: LD_INT 60
108139: PUSH
108140: LD_INT 70
108142: PUSH
108143: LD_INT 80
108145: PUSH
108146: LD_INT 90
108148: PUSH
108149: LD_INT 100
108151: PUSH
108152: LD_INT 110
108154: PUSH
108155: LD_INT 120
108157: PUSH
108158: LD_INT 130
108160: PUSH
108161: LD_INT 140
108163: PUSH
108164: LD_INT 150
108166: PUSH
108167: EMPTY
108168: LIST
108169: LIST
108170: LIST
108171: LIST
108172: LIST
108173: LIST
108174: LIST
108175: LIST
108176: LIST
108177: LIST
108178: LIST
108179: LIST
108180: LIST
108181: LIST
108182: LIST
108183: PUSH
108184: LD_INT 1
108186: PPUSH
108187: LD_INT 15
108189: PPUSH
108190: CALL_OW 12
108194: ARRAY
108195: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108196: LD_ADDR_VAR 0 4
108200: PUSH
108201: LD_INT 10
108203: PUSH
108204: LD_INT 20
108206: PUSH
108207: LD_INT 30
108209: PUSH
108210: LD_INT 40
108212: PUSH
108213: LD_INT 50
108215: PUSH
108216: LD_INT 60
108218: PUSH
108219: LD_INT 70
108221: PUSH
108222: LD_INT 80
108224: PUSH
108225: LD_INT 90
108227: PUSH
108228: LD_INT 100
108230: PUSH
108231: LD_INT 110
108233: PUSH
108234: LD_INT 120
108236: PUSH
108237: LD_INT 130
108239: PUSH
108240: LD_INT 140
108242: PUSH
108243: LD_INT 150
108245: PUSH
108246: EMPTY
108247: LIST
108248: LIST
108249: LIST
108250: LIST
108251: LIST
108252: LIST
108253: LIST
108254: LIST
108255: LIST
108256: LIST
108257: LIST
108258: LIST
108259: LIST
108260: LIST
108261: LIST
108262: PUSH
108263: LD_INT 1
108265: PPUSH
108266: LD_INT 15
108268: PPUSH
108269: CALL_OW 12
108273: ARRAY
108274: ST_TO_ADDR
// if ValidHex ( x , y ) then
108275: LD_VAR 0 3
108279: PPUSH
108280: LD_VAR 0 4
108284: PPUSH
108285: CALL_OW 488
108289: IFFALSE 108312
// begin result := [ x , y ] ;
108291: LD_ADDR_VAR 0 1
108295: PUSH
108296: LD_VAR 0 3
108300: PUSH
108301: LD_VAR 0 4
108305: PUSH
108306: EMPTY
108307: LIST
108308: LIST
108309: ST_TO_ADDR
// break ;
108310: GO 108314
// end ; end ;
108312: GO 108114
108314: POP
108315: POP
// if result then
108316: LD_VAR 0 1
108320: IFFALSE 108380
// begin ToLua ( playSibBomb() ) ;
108322: LD_STRING playSibBomb()
108324: PPUSH
108325: CALL_OW 559
// wait ( 0 0$14 ) ;
108329: LD_INT 490
108331: PPUSH
108332: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108336: LD_VAR 0 1
108340: PUSH
108341: LD_INT 1
108343: ARRAY
108344: PPUSH
108345: LD_VAR 0 1
108349: PUSH
108350: LD_INT 2
108352: ARRAY
108353: PPUSH
108354: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108358: LD_VAR 0 1
108362: PUSH
108363: LD_INT 1
108365: ARRAY
108366: PPUSH
108367: LD_VAR 0 1
108371: PUSH
108372: LD_INT 2
108374: ARRAY
108375: PPUSH
108376: CALL_OW 429
// end ; end ;
108380: LD_VAR 0 1
108384: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108385: LD_EXP 154
108389: PUSH
108390: LD_EXP 176
108394: AND
108395: IFFALSE 108407
108397: GO 108399
108399: DISABLE
// YouLost (  ) ;
108400: LD_STRING 
108402: PPUSH
108403: CALL_OW 104
108407: END
// every 0 0$1 trigger StreamModeActive and sFog do
108408: LD_EXP 154
108412: PUSH
108413: LD_EXP 175
108417: AND
108418: IFFALSE 108432
108420: GO 108422
108422: DISABLE
// FogOff ( your_side ) ;
108423: LD_OWVAR 2
108427: PPUSH
108428: CALL_OW 344
108432: END
// every 0 0$1 trigger StreamModeActive and sSun do
108433: LD_EXP 154
108437: PUSH
108438: LD_EXP 177
108442: AND
108443: IFFALSE 108471
108445: GO 108447
108447: DISABLE
// begin solar_recharge_percent := 0 ;
108448: LD_ADDR_OWVAR 79
108452: PUSH
108453: LD_INT 0
108455: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108456: LD_INT 10500
108458: PPUSH
108459: CALL_OW 67
// solar_recharge_percent := 100 ;
108463: LD_ADDR_OWVAR 79
108467: PUSH
108468: LD_INT 100
108470: ST_TO_ADDR
// end ;
108471: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108472: LD_EXP 154
108476: PUSH
108477: LD_EXP 178
108481: AND
108482: IFFALSE 108721
108484: GO 108486
108486: DISABLE
108487: LD_INT 0
108489: PPUSH
108490: PPUSH
108491: PPUSH
// begin tmp := [ ] ;
108492: LD_ADDR_VAR 0 3
108496: PUSH
108497: EMPTY
108498: ST_TO_ADDR
// for i := 1 to 6 do
108499: LD_ADDR_VAR 0 1
108503: PUSH
108504: DOUBLE
108505: LD_INT 1
108507: DEC
108508: ST_TO_ADDR
108509: LD_INT 6
108511: PUSH
108512: FOR_TO
108513: IFFALSE 108618
// begin uc_nation := nation_nature ;
108515: LD_ADDR_OWVAR 21
108519: PUSH
108520: LD_INT 0
108522: ST_TO_ADDR
// uc_side := 0 ;
108523: LD_ADDR_OWVAR 20
108527: PUSH
108528: LD_INT 0
108530: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108531: LD_ADDR_OWVAR 29
108535: PUSH
108536: LD_INT 12
108538: PUSH
108539: LD_INT 12
108541: PUSH
108542: EMPTY
108543: LIST
108544: LIST
108545: ST_TO_ADDR
// hc_agressivity := 20 ;
108546: LD_ADDR_OWVAR 35
108550: PUSH
108551: LD_INT 20
108553: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108554: LD_ADDR_OWVAR 28
108558: PUSH
108559: LD_INT 17
108561: ST_TO_ADDR
// hc_gallery :=  ;
108562: LD_ADDR_OWVAR 33
108566: PUSH
108567: LD_STRING 
108569: ST_TO_ADDR
// hc_name :=  ;
108570: LD_ADDR_OWVAR 26
108574: PUSH
108575: LD_STRING 
108577: ST_TO_ADDR
// un := CreateHuman ;
108578: LD_ADDR_VAR 0 2
108582: PUSH
108583: CALL_OW 44
108587: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108588: LD_VAR 0 2
108592: PPUSH
108593: LD_INT 1
108595: PPUSH
108596: CALL_OW 51
// tmp := tmp ^ un ;
108600: LD_ADDR_VAR 0 3
108604: PUSH
108605: LD_VAR 0 3
108609: PUSH
108610: LD_VAR 0 2
108614: ADD
108615: ST_TO_ADDR
// end ;
108616: GO 108512
108618: POP
108619: POP
// repeat wait ( 0 0$1 ) ;
108620: LD_INT 35
108622: PPUSH
108623: CALL_OW 67
// for un in tmp do
108627: LD_ADDR_VAR 0 2
108631: PUSH
108632: LD_VAR 0 3
108636: PUSH
108637: FOR_IN
108638: IFFALSE 108712
// begin if IsDead ( un ) then
108640: LD_VAR 0 2
108644: PPUSH
108645: CALL_OW 301
108649: IFFALSE 108669
// begin tmp := tmp diff un ;
108651: LD_ADDR_VAR 0 3
108655: PUSH
108656: LD_VAR 0 3
108660: PUSH
108661: LD_VAR 0 2
108665: DIFF
108666: ST_TO_ADDR
// continue ;
108667: GO 108637
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108669: LD_VAR 0 2
108673: PPUSH
108674: LD_INT 3
108676: PUSH
108677: LD_INT 22
108679: PUSH
108680: LD_INT 0
108682: PUSH
108683: EMPTY
108684: LIST
108685: LIST
108686: PUSH
108687: EMPTY
108688: LIST
108689: LIST
108690: PPUSH
108691: CALL_OW 69
108695: PPUSH
108696: LD_VAR 0 2
108700: PPUSH
108701: CALL_OW 74
108705: PPUSH
108706: CALL_OW 115
// end ;
108710: GO 108637
108712: POP
108713: POP
// until not tmp ;
108714: LD_VAR 0 3
108718: NOT
108719: IFFALSE 108620
// end ;
108721: PPOPN 3
108723: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108724: LD_EXP 154
108728: PUSH
108729: LD_EXP 179
108733: AND
108734: IFFALSE 108788
108736: GO 108738
108738: DISABLE
// begin ToLua ( displayTroll(); ) ;
108739: LD_STRING displayTroll();
108741: PPUSH
108742: CALL_OW 559
// wait ( 3 3$00 ) ;
108746: LD_INT 6300
108748: PPUSH
108749: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108753: LD_STRING hideTroll();
108755: PPUSH
108756: CALL_OW 559
// wait ( 1 1$00 ) ;
108760: LD_INT 2100
108762: PPUSH
108763: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108767: LD_STRING displayTroll();
108769: PPUSH
108770: CALL_OW 559
// wait ( 1 1$00 ) ;
108774: LD_INT 2100
108776: PPUSH
108777: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108781: LD_STRING hideTroll();
108783: PPUSH
108784: CALL_OW 559
// end ;
108788: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108789: LD_EXP 154
108793: PUSH
108794: LD_EXP 180
108798: AND
108799: IFFALSE 108862
108801: GO 108803
108803: DISABLE
108804: LD_INT 0
108806: PPUSH
// begin p := 0 ;
108807: LD_ADDR_VAR 0 1
108811: PUSH
108812: LD_INT 0
108814: ST_TO_ADDR
// repeat game_speed := 1 ;
108815: LD_ADDR_OWVAR 65
108819: PUSH
108820: LD_INT 1
108822: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108823: LD_INT 35
108825: PPUSH
108826: CALL_OW 67
// p := p + 1 ;
108830: LD_ADDR_VAR 0 1
108834: PUSH
108835: LD_VAR 0 1
108839: PUSH
108840: LD_INT 1
108842: PLUS
108843: ST_TO_ADDR
// until p >= 60 ;
108844: LD_VAR 0 1
108848: PUSH
108849: LD_INT 60
108851: GREATEREQUAL
108852: IFFALSE 108815
// game_speed := 4 ;
108854: LD_ADDR_OWVAR 65
108858: PUSH
108859: LD_INT 4
108861: ST_TO_ADDR
// end ;
108862: PPOPN 1
108864: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108865: LD_EXP 154
108869: PUSH
108870: LD_EXP 181
108874: AND
108875: IFFALSE 109021
108877: GO 108879
108879: DISABLE
108880: LD_INT 0
108882: PPUSH
108883: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108884: LD_ADDR_VAR 0 1
108888: PUSH
108889: LD_INT 22
108891: PUSH
108892: LD_OWVAR 2
108896: PUSH
108897: EMPTY
108898: LIST
108899: LIST
108900: PUSH
108901: LD_INT 2
108903: PUSH
108904: LD_INT 30
108906: PUSH
108907: LD_INT 0
108909: PUSH
108910: EMPTY
108911: LIST
108912: LIST
108913: PUSH
108914: LD_INT 30
108916: PUSH
108917: LD_INT 1
108919: PUSH
108920: EMPTY
108921: LIST
108922: LIST
108923: PUSH
108924: EMPTY
108925: LIST
108926: LIST
108927: LIST
108928: PUSH
108929: EMPTY
108930: LIST
108931: LIST
108932: PPUSH
108933: CALL_OW 69
108937: ST_TO_ADDR
// if not depot then
108938: LD_VAR 0 1
108942: NOT
108943: IFFALSE 108947
// exit ;
108945: GO 109021
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108947: LD_ADDR_VAR 0 2
108951: PUSH
108952: LD_VAR 0 1
108956: PUSH
108957: LD_INT 1
108959: PPUSH
108960: LD_VAR 0 1
108964: PPUSH
108965: CALL_OW 12
108969: ARRAY
108970: PPUSH
108971: CALL_OW 274
108975: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108976: LD_VAR 0 2
108980: PPUSH
108981: LD_INT 1
108983: PPUSH
108984: LD_INT 0
108986: PPUSH
108987: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108991: LD_VAR 0 2
108995: PPUSH
108996: LD_INT 2
108998: PPUSH
108999: LD_INT 0
109001: PPUSH
109002: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109006: LD_VAR 0 2
109010: PPUSH
109011: LD_INT 3
109013: PPUSH
109014: LD_INT 0
109016: PPUSH
109017: CALL_OW 277
// end ;
109021: PPOPN 2
109023: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
109024: LD_EXP 154
109028: PUSH
109029: LD_EXP 182
109033: AND
109034: IFFALSE 109131
109036: GO 109038
109038: DISABLE
109039: LD_INT 0
109041: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109042: LD_ADDR_VAR 0 1
109046: PUSH
109047: LD_INT 22
109049: PUSH
109050: LD_OWVAR 2
109054: PUSH
109055: EMPTY
109056: LIST
109057: LIST
109058: PUSH
109059: LD_INT 21
109061: PUSH
109062: LD_INT 1
109064: PUSH
109065: EMPTY
109066: LIST
109067: LIST
109068: PUSH
109069: LD_INT 3
109071: PUSH
109072: LD_INT 23
109074: PUSH
109075: LD_INT 0
109077: PUSH
109078: EMPTY
109079: LIST
109080: LIST
109081: PUSH
109082: EMPTY
109083: LIST
109084: LIST
109085: PUSH
109086: EMPTY
109087: LIST
109088: LIST
109089: LIST
109090: PPUSH
109091: CALL_OW 69
109095: ST_TO_ADDR
// if not tmp then
109096: LD_VAR 0 1
109100: NOT
109101: IFFALSE 109105
// exit ;
109103: GO 109131
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
109105: LD_VAR 0 1
109109: PUSH
109110: LD_INT 1
109112: PPUSH
109113: LD_VAR 0 1
109117: PPUSH
109118: CALL_OW 12
109122: ARRAY
109123: PPUSH
109124: LD_INT 200
109126: PPUSH
109127: CALL_OW 234
// end ;
109131: PPOPN 1
109133: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
109134: LD_EXP 154
109138: PUSH
109139: LD_EXP 183
109143: AND
109144: IFFALSE 109223
109146: GO 109148
109148: DISABLE
109149: LD_INT 0
109151: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
109152: LD_ADDR_VAR 0 1
109156: PUSH
109157: LD_INT 22
109159: PUSH
109160: LD_OWVAR 2
109164: PUSH
109165: EMPTY
109166: LIST
109167: LIST
109168: PUSH
109169: LD_INT 21
109171: PUSH
109172: LD_INT 2
109174: PUSH
109175: EMPTY
109176: LIST
109177: LIST
109178: PUSH
109179: EMPTY
109180: LIST
109181: LIST
109182: PPUSH
109183: CALL_OW 69
109187: ST_TO_ADDR
// if not tmp then
109188: LD_VAR 0 1
109192: NOT
109193: IFFALSE 109197
// exit ;
109195: GO 109223
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
109197: LD_VAR 0 1
109201: PUSH
109202: LD_INT 1
109204: PPUSH
109205: LD_VAR 0 1
109209: PPUSH
109210: CALL_OW 12
109214: ARRAY
109215: PPUSH
109216: LD_INT 60
109218: PPUSH
109219: CALL_OW 234
// end ;
109223: PPOPN 1
109225: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
109226: LD_EXP 154
109230: PUSH
109231: LD_EXP 184
109235: AND
109236: IFFALSE 109335
109238: GO 109240
109240: DISABLE
109241: LD_INT 0
109243: PPUSH
109244: PPUSH
// begin enable ;
109245: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
109246: LD_ADDR_VAR 0 1
109250: PUSH
109251: LD_INT 22
109253: PUSH
109254: LD_OWVAR 2
109258: PUSH
109259: EMPTY
109260: LIST
109261: LIST
109262: PUSH
109263: LD_INT 61
109265: PUSH
109266: EMPTY
109267: LIST
109268: PUSH
109269: LD_INT 33
109271: PUSH
109272: LD_INT 2
109274: PUSH
109275: EMPTY
109276: LIST
109277: LIST
109278: PUSH
109279: EMPTY
109280: LIST
109281: LIST
109282: LIST
109283: PPUSH
109284: CALL_OW 69
109288: ST_TO_ADDR
// if not tmp then
109289: LD_VAR 0 1
109293: NOT
109294: IFFALSE 109298
// exit ;
109296: GO 109335
// for i in tmp do
109298: LD_ADDR_VAR 0 2
109302: PUSH
109303: LD_VAR 0 1
109307: PUSH
109308: FOR_IN
109309: IFFALSE 109333
// if IsControledBy ( i ) then
109311: LD_VAR 0 2
109315: PPUSH
109316: CALL_OW 312
109320: IFFALSE 109331
// ComUnlink ( i ) ;
109322: LD_VAR 0 2
109326: PPUSH
109327: CALL_OW 136
109331: GO 109308
109333: POP
109334: POP
// end ;
109335: PPOPN 2
109337: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109338: LD_EXP 154
109342: PUSH
109343: LD_EXP 185
109347: AND
109348: IFFALSE 109488
109350: GO 109352
109352: DISABLE
109353: LD_INT 0
109355: PPUSH
109356: PPUSH
// begin ToLua ( displayPowell(); ) ;
109357: LD_STRING displayPowell();
109359: PPUSH
109360: CALL_OW 559
// uc_side := 0 ;
109364: LD_ADDR_OWVAR 20
109368: PUSH
109369: LD_INT 0
109371: ST_TO_ADDR
// uc_nation := 2 ;
109372: LD_ADDR_OWVAR 21
109376: PUSH
109377: LD_INT 2
109379: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109380: LD_ADDR_OWVAR 37
109384: PUSH
109385: LD_INT 14
109387: ST_TO_ADDR
// vc_engine := engine_siberite ;
109388: LD_ADDR_OWVAR 39
109392: PUSH
109393: LD_INT 3
109395: ST_TO_ADDR
// vc_control := control_apeman ;
109396: LD_ADDR_OWVAR 38
109400: PUSH
109401: LD_INT 5
109403: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109404: LD_ADDR_OWVAR 40
109408: PUSH
109409: LD_INT 29
109411: ST_TO_ADDR
// un := CreateVehicle ;
109412: LD_ADDR_VAR 0 2
109416: PUSH
109417: CALL_OW 45
109421: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109422: LD_VAR 0 2
109426: PPUSH
109427: LD_INT 1
109429: PPUSH
109430: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109434: LD_INT 35
109436: PPUSH
109437: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109441: LD_VAR 0 2
109445: PPUSH
109446: LD_INT 22
109448: PUSH
109449: LD_OWVAR 2
109453: PUSH
109454: EMPTY
109455: LIST
109456: LIST
109457: PPUSH
109458: CALL_OW 69
109462: PPUSH
109463: LD_VAR 0 2
109467: PPUSH
109468: CALL_OW 74
109472: PPUSH
109473: CALL_OW 115
// until IsDead ( un ) ;
109477: LD_VAR 0 2
109481: PPUSH
109482: CALL_OW 301
109486: IFFALSE 109434
// end ;
109488: PPOPN 2
109490: END
// every 0 0$1 trigger StreamModeActive and sStu do
109491: LD_EXP 154
109495: PUSH
109496: LD_EXP 193
109500: AND
109501: IFFALSE 109517
109503: GO 109505
109505: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109506: LD_STRING displayStucuk();
109508: PPUSH
109509: CALL_OW 559
// ResetFog ;
109513: CALL_OW 335
// end ;
109517: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109518: LD_EXP 154
109522: PUSH
109523: LD_EXP 186
109527: AND
109528: IFFALSE 109669
109530: GO 109532
109532: DISABLE
109533: LD_INT 0
109535: PPUSH
109536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109537: LD_ADDR_VAR 0 2
109541: PUSH
109542: LD_INT 22
109544: PUSH
109545: LD_OWVAR 2
109549: PUSH
109550: EMPTY
109551: LIST
109552: LIST
109553: PUSH
109554: LD_INT 21
109556: PUSH
109557: LD_INT 1
109559: PUSH
109560: EMPTY
109561: LIST
109562: LIST
109563: PUSH
109564: EMPTY
109565: LIST
109566: LIST
109567: PPUSH
109568: CALL_OW 69
109572: ST_TO_ADDR
// if not tmp then
109573: LD_VAR 0 2
109577: NOT
109578: IFFALSE 109582
// exit ;
109580: GO 109669
// un := tmp [ rand ( 1 , tmp ) ] ;
109582: LD_ADDR_VAR 0 1
109586: PUSH
109587: LD_VAR 0 2
109591: PUSH
109592: LD_INT 1
109594: PPUSH
109595: LD_VAR 0 2
109599: PPUSH
109600: CALL_OW 12
109604: ARRAY
109605: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109606: LD_VAR 0 1
109610: PPUSH
109611: LD_INT 0
109613: PPUSH
109614: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109618: LD_VAR 0 1
109622: PPUSH
109623: LD_OWVAR 3
109627: PUSH
109628: LD_VAR 0 1
109632: DIFF
109633: PPUSH
109634: LD_VAR 0 1
109638: PPUSH
109639: CALL_OW 74
109643: PPUSH
109644: CALL_OW 115
// wait ( 0 0$20 ) ;
109648: LD_INT 700
109650: PPUSH
109651: CALL_OW 67
// SetSide ( un , your_side ) ;
109655: LD_VAR 0 1
109659: PPUSH
109660: LD_OWVAR 2
109664: PPUSH
109665: CALL_OW 235
// end ;
109669: PPOPN 2
109671: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109672: LD_EXP 154
109676: PUSH
109677: LD_EXP 187
109681: AND
109682: IFFALSE 109788
109684: GO 109686
109686: DISABLE
109687: LD_INT 0
109689: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109690: LD_ADDR_VAR 0 1
109694: PUSH
109695: LD_INT 22
109697: PUSH
109698: LD_OWVAR 2
109702: PUSH
109703: EMPTY
109704: LIST
109705: LIST
109706: PUSH
109707: LD_INT 2
109709: PUSH
109710: LD_INT 30
109712: PUSH
109713: LD_INT 0
109715: PUSH
109716: EMPTY
109717: LIST
109718: LIST
109719: PUSH
109720: LD_INT 30
109722: PUSH
109723: LD_INT 1
109725: PUSH
109726: EMPTY
109727: LIST
109728: LIST
109729: PUSH
109730: EMPTY
109731: LIST
109732: LIST
109733: LIST
109734: PUSH
109735: EMPTY
109736: LIST
109737: LIST
109738: PPUSH
109739: CALL_OW 69
109743: ST_TO_ADDR
// if not depot then
109744: LD_VAR 0 1
109748: NOT
109749: IFFALSE 109753
// exit ;
109751: GO 109788
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109753: LD_VAR 0 1
109757: PUSH
109758: LD_INT 1
109760: ARRAY
109761: PPUSH
109762: CALL_OW 250
109766: PPUSH
109767: LD_VAR 0 1
109771: PUSH
109772: LD_INT 1
109774: ARRAY
109775: PPUSH
109776: CALL_OW 251
109780: PPUSH
109781: LD_INT 70
109783: PPUSH
109784: CALL_OW 495
// end ;
109788: PPOPN 1
109790: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109791: LD_EXP 154
109795: PUSH
109796: LD_EXP 188
109800: AND
109801: IFFALSE 110012
109803: GO 109805
109805: DISABLE
109806: LD_INT 0
109808: PPUSH
109809: PPUSH
109810: PPUSH
109811: PPUSH
109812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109813: LD_ADDR_VAR 0 5
109817: PUSH
109818: LD_INT 22
109820: PUSH
109821: LD_OWVAR 2
109825: PUSH
109826: EMPTY
109827: LIST
109828: LIST
109829: PUSH
109830: LD_INT 21
109832: PUSH
109833: LD_INT 1
109835: PUSH
109836: EMPTY
109837: LIST
109838: LIST
109839: PUSH
109840: EMPTY
109841: LIST
109842: LIST
109843: PPUSH
109844: CALL_OW 69
109848: ST_TO_ADDR
// if not tmp then
109849: LD_VAR 0 5
109853: NOT
109854: IFFALSE 109858
// exit ;
109856: GO 110012
// for i in tmp do
109858: LD_ADDR_VAR 0 1
109862: PUSH
109863: LD_VAR 0 5
109867: PUSH
109868: FOR_IN
109869: IFFALSE 110010
// begin d := rand ( 0 , 5 ) ;
109871: LD_ADDR_VAR 0 4
109875: PUSH
109876: LD_INT 0
109878: PPUSH
109879: LD_INT 5
109881: PPUSH
109882: CALL_OW 12
109886: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109887: LD_ADDR_VAR 0 2
109891: PUSH
109892: LD_VAR 0 1
109896: PPUSH
109897: CALL_OW 250
109901: PPUSH
109902: LD_VAR 0 4
109906: PPUSH
109907: LD_INT 3
109909: PPUSH
109910: LD_INT 12
109912: PPUSH
109913: CALL_OW 12
109917: PPUSH
109918: CALL_OW 272
109922: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109923: LD_ADDR_VAR 0 3
109927: PUSH
109928: LD_VAR 0 1
109932: PPUSH
109933: CALL_OW 251
109937: PPUSH
109938: LD_VAR 0 4
109942: PPUSH
109943: LD_INT 3
109945: PPUSH
109946: LD_INT 12
109948: PPUSH
109949: CALL_OW 12
109953: PPUSH
109954: CALL_OW 273
109958: ST_TO_ADDR
// if ValidHex ( x , y ) then
109959: LD_VAR 0 2
109963: PPUSH
109964: LD_VAR 0 3
109968: PPUSH
109969: CALL_OW 488
109973: IFFALSE 110008
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109975: LD_VAR 0 1
109979: PPUSH
109980: LD_VAR 0 2
109984: PPUSH
109985: LD_VAR 0 3
109989: PPUSH
109990: LD_INT 3
109992: PPUSH
109993: LD_INT 6
109995: PPUSH
109996: CALL_OW 12
110000: PPUSH
110001: LD_INT 1
110003: PPUSH
110004: CALL_OW 483
// end ;
110008: GO 109868
110010: POP
110011: POP
// end ;
110012: PPOPN 5
110014: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110015: LD_EXP 154
110019: PUSH
110020: LD_EXP 189
110024: AND
110025: IFFALSE 110119
110027: GO 110029
110029: DISABLE
110030: LD_INT 0
110032: PPUSH
110033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
110034: LD_ADDR_VAR 0 2
110038: PUSH
110039: LD_INT 22
110041: PUSH
110042: LD_OWVAR 2
110046: PUSH
110047: EMPTY
110048: LIST
110049: LIST
110050: PUSH
110051: LD_INT 32
110053: PUSH
110054: LD_INT 1
110056: PUSH
110057: EMPTY
110058: LIST
110059: LIST
110060: PUSH
110061: LD_INT 21
110063: PUSH
110064: LD_INT 2
110066: PUSH
110067: EMPTY
110068: LIST
110069: LIST
110070: PUSH
110071: EMPTY
110072: LIST
110073: LIST
110074: LIST
110075: PPUSH
110076: CALL_OW 69
110080: ST_TO_ADDR
// if not tmp then
110081: LD_VAR 0 2
110085: NOT
110086: IFFALSE 110090
// exit ;
110088: GO 110119
// for i in tmp do
110090: LD_ADDR_VAR 0 1
110094: PUSH
110095: LD_VAR 0 2
110099: PUSH
110100: FOR_IN
110101: IFFALSE 110117
// SetFuel ( i , 0 ) ;
110103: LD_VAR 0 1
110107: PPUSH
110108: LD_INT 0
110110: PPUSH
110111: CALL_OW 240
110115: GO 110100
110117: POP
110118: POP
// end ;
110119: PPOPN 2
110121: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
110122: LD_EXP 154
110126: PUSH
110127: LD_EXP 190
110131: AND
110132: IFFALSE 110198
110134: GO 110136
110136: DISABLE
110137: LD_INT 0
110139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
110140: LD_ADDR_VAR 0 1
110144: PUSH
110145: LD_INT 22
110147: PUSH
110148: LD_OWVAR 2
110152: PUSH
110153: EMPTY
110154: LIST
110155: LIST
110156: PUSH
110157: LD_INT 30
110159: PUSH
110160: LD_INT 29
110162: PUSH
110163: EMPTY
110164: LIST
110165: LIST
110166: PUSH
110167: EMPTY
110168: LIST
110169: LIST
110170: PPUSH
110171: CALL_OW 69
110175: ST_TO_ADDR
// if not tmp then
110176: LD_VAR 0 1
110180: NOT
110181: IFFALSE 110185
// exit ;
110183: GO 110198
// DestroyUnit ( tmp [ 1 ] ) ;
110185: LD_VAR 0 1
110189: PUSH
110190: LD_INT 1
110192: ARRAY
110193: PPUSH
110194: CALL_OW 65
// end ;
110198: PPOPN 1
110200: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
110201: LD_EXP 154
110205: PUSH
110206: LD_EXP 192
110210: AND
110211: IFFALSE 110340
110213: GO 110215
110215: DISABLE
110216: LD_INT 0
110218: PPUSH
// begin uc_side := 0 ;
110219: LD_ADDR_OWVAR 20
110223: PUSH
110224: LD_INT 0
110226: ST_TO_ADDR
// uc_nation := nation_arabian ;
110227: LD_ADDR_OWVAR 21
110231: PUSH
110232: LD_INT 2
110234: ST_TO_ADDR
// hc_gallery :=  ;
110235: LD_ADDR_OWVAR 33
110239: PUSH
110240: LD_STRING 
110242: ST_TO_ADDR
// hc_name :=  ;
110243: LD_ADDR_OWVAR 26
110247: PUSH
110248: LD_STRING 
110250: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
110251: LD_INT 1
110253: PPUSH
110254: LD_INT 11
110256: PPUSH
110257: LD_INT 10
110259: PPUSH
110260: CALL_OW 380
// un := CreateHuman ;
110264: LD_ADDR_VAR 0 1
110268: PUSH
110269: CALL_OW 44
110273: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110274: LD_VAR 0 1
110278: PPUSH
110279: LD_INT 1
110281: PPUSH
110282: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110286: LD_INT 35
110288: PPUSH
110289: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110293: LD_VAR 0 1
110297: PPUSH
110298: LD_INT 22
110300: PUSH
110301: LD_OWVAR 2
110305: PUSH
110306: EMPTY
110307: LIST
110308: LIST
110309: PPUSH
110310: CALL_OW 69
110314: PPUSH
110315: LD_VAR 0 1
110319: PPUSH
110320: CALL_OW 74
110324: PPUSH
110325: CALL_OW 115
// until IsDead ( un ) ;
110329: LD_VAR 0 1
110333: PPUSH
110334: CALL_OW 301
110338: IFFALSE 110286
// end ;
110340: PPOPN 1
110342: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110343: LD_EXP 154
110347: PUSH
110348: LD_EXP 194
110352: AND
110353: IFFALSE 110365
110355: GO 110357
110357: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110358: LD_STRING earthquake(getX(game), 0, 32)
110360: PPUSH
110361: CALL_OW 559
110365: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110366: LD_EXP 154
110370: PUSH
110371: LD_EXP 195
110375: AND
110376: IFFALSE 110467
110378: GO 110380
110380: DISABLE
110381: LD_INT 0
110383: PPUSH
// begin enable ;
110384: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110385: LD_ADDR_VAR 0 1
110389: PUSH
110390: LD_INT 22
110392: PUSH
110393: LD_OWVAR 2
110397: PUSH
110398: EMPTY
110399: LIST
110400: LIST
110401: PUSH
110402: LD_INT 21
110404: PUSH
110405: LD_INT 2
110407: PUSH
110408: EMPTY
110409: LIST
110410: LIST
110411: PUSH
110412: LD_INT 33
110414: PUSH
110415: LD_INT 3
110417: PUSH
110418: EMPTY
110419: LIST
110420: LIST
110421: PUSH
110422: EMPTY
110423: LIST
110424: LIST
110425: LIST
110426: PPUSH
110427: CALL_OW 69
110431: ST_TO_ADDR
// if not tmp then
110432: LD_VAR 0 1
110436: NOT
110437: IFFALSE 110441
// exit ;
110439: GO 110467
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110441: LD_VAR 0 1
110445: PUSH
110446: LD_INT 1
110448: PPUSH
110449: LD_VAR 0 1
110453: PPUSH
110454: CALL_OW 12
110458: ARRAY
110459: PPUSH
110460: LD_INT 1
110462: PPUSH
110463: CALL_OW 234
// end ;
110467: PPOPN 1
110469: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110470: LD_EXP 154
110474: PUSH
110475: LD_EXP 196
110479: AND
110480: IFFALSE 110621
110482: GO 110484
110484: DISABLE
110485: LD_INT 0
110487: PPUSH
110488: PPUSH
110489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110490: LD_ADDR_VAR 0 3
110494: PUSH
110495: LD_INT 22
110497: PUSH
110498: LD_OWVAR 2
110502: PUSH
110503: EMPTY
110504: LIST
110505: LIST
110506: PUSH
110507: LD_INT 25
110509: PUSH
110510: LD_INT 1
110512: PUSH
110513: EMPTY
110514: LIST
110515: LIST
110516: PUSH
110517: EMPTY
110518: LIST
110519: LIST
110520: PPUSH
110521: CALL_OW 69
110525: ST_TO_ADDR
// if not tmp then
110526: LD_VAR 0 3
110530: NOT
110531: IFFALSE 110535
// exit ;
110533: GO 110621
// un := tmp [ rand ( 1 , tmp ) ] ;
110535: LD_ADDR_VAR 0 2
110539: PUSH
110540: LD_VAR 0 3
110544: PUSH
110545: LD_INT 1
110547: PPUSH
110548: LD_VAR 0 3
110552: PPUSH
110553: CALL_OW 12
110557: ARRAY
110558: ST_TO_ADDR
// if Crawls ( un ) then
110559: LD_VAR 0 2
110563: PPUSH
110564: CALL_OW 318
110568: IFFALSE 110579
// ComWalk ( un ) ;
110570: LD_VAR 0 2
110574: PPUSH
110575: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110579: LD_VAR 0 2
110583: PPUSH
110584: LD_INT 9
110586: PPUSH
110587: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110591: LD_INT 28
110593: PPUSH
110594: LD_OWVAR 2
110598: PPUSH
110599: LD_INT 2
110601: PPUSH
110602: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110606: LD_INT 29
110608: PPUSH
110609: LD_OWVAR 2
110613: PPUSH
110614: LD_INT 2
110616: PPUSH
110617: CALL_OW 322
// end ;
110621: PPOPN 3
110623: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110624: LD_EXP 154
110628: PUSH
110629: LD_EXP 197
110633: AND
110634: IFFALSE 110745
110636: GO 110638
110638: DISABLE
110639: LD_INT 0
110641: PPUSH
110642: PPUSH
110643: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110644: LD_ADDR_VAR 0 3
110648: PUSH
110649: LD_INT 22
110651: PUSH
110652: LD_OWVAR 2
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: PUSH
110661: LD_INT 25
110663: PUSH
110664: LD_INT 1
110666: PUSH
110667: EMPTY
110668: LIST
110669: LIST
110670: PUSH
110671: EMPTY
110672: LIST
110673: LIST
110674: PPUSH
110675: CALL_OW 69
110679: ST_TO_ADDR
// if not tmp then
110680: LD_VAR 0 3
110684: NOT
110685: IFFALSE 110689
// exit ;
110687: GO 110745
// un := tmp [ rand ( 1 , tmp ) ] ;
110689: LD_ADDR_VAR 0 2
110693: PUSH
110694: LD_VAR 0 3
110698: PUSH
110699: LD_INT 1
110701: PPUSH
110702: LD_VAR 0 3
110706: PPUSH
110707: CALL_OW 12
110711: ARRAY
110712: ST_TO_ADDR
// if Crawls ( un ) then
110713: LD_VAR 0 2
110717: PPUSH
110718: CALL_OW 318
110722: IFFALSE 110733
// ComWalk ( un ) ;
110724: LD_VAR 0 2
110728: PPUSH
110729: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110733: LD_VAR 0 2
110737: PPUSH
110738: LD_INT 8
110740: PPUSH
110741: CALL_OW 336
// end ;
110745: PPOPN 3
110747: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110748: LD_EXP 154
110752: PUSH
110753: LD_EXP 198
110757: AND
110758: IFFALSE 110902
110760: GO 110762
110762: DISABLE
110763: LD_INT 0
110765: PPUSH
110766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110767: LD_ADDR_VAR 0 2
110771: PUSH
110772: LD_INT 22
110774: PUSH
110775: LD_OWVAR 2
110779: PUSH
110780: EMPTY
110781: LIST
110782: LIST
110783: PUSH
110784: LD_INT 21
110786: PUSH
110787: LD_INT 2
110789: PUSH
110790: EMPTY
110791: LIST
110792: LIST
110793: PUSH
110794: LD_INT 2
110796: PUSH
110797: LD_INT 34
110799: PUSH
110800: LD_INT 12
110802: PUSH
110803: EMPTY
110804: LIST
110805: LIST
110806: PUSH
110807: LD_INT 34
110809: PUSH
110810: LD_INT 51
110812: PUSH
110813: EMPTY
110814: LIST
110815: LIST
110816: PUSH
110817: LD_INT 34
110819: PUSH
110820: LD_INT 32
110822: PUSH
110823: EMPTY
110824: LIST
110825: LIST
110826: PUSH
110827: EMPTY
110828: LIST
110829: LIST
110830: LIST
110831: LIST
110832: PUSH
110833: EMPTY
110834: LIST
110835: LIST
110836: LIST
110837: PPUSH
110838: CALL_OW 69
110842: ST_TO_ADDR
// if not tmp then
110843: LD_VAR 0 2
110847: NOT
110848: IFFALSE 110852
// exit ;
110850: GO 110902
// for i in tmp do
110852: LD_ADDR_VAR 0 1
110856: PUSH
110857: LD_VAR 0 2
110861: PUSH
110862: FOR_IN
110863: IFFALSE 110900
// if GetCargo ( i , mat_artifact ) = 0 then
110865: LD_VAR 0 1
110869: PPUSH
110870: LD_INT 4
110872: PPUSH
110873: CALL_OW 289
110877: PUSH
110878: LD_INT 0
110880: EQUAL
110881: IFFALSE 110898
// SetCargo ( i , mat_siberit , 100 ) ;
110883: LD_VAR 0 1
110887: PPUSH
110888: LD_INT 3
110890: PPUSH
110891: LD_INT 100
110893: PPUSH
110894: CALL_OW 290
110898: GO 110862
110900: POP
110901: POP
// end ;
110902: PPOPN 2
110904: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110905: LD_EXP 154
110909: PUSH
110910: LD_EXP 199
110914: AND
110915: IFFALSE 111098
110917: GO 110919
110919: DISABLE
110920: LD_INT 0
110922: PPUSH
110923: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110924: LD_ADDR_VAR 0 2
110928: PUSH
110929: LD_INT 22
110931: PUSH
110932: LD_OWVAR 2
110936: PUSH
110937: EMPTY
110938: LIST
110939: LIST
110940: PPUSH
110941: CALL_OW 69
110945: ST_TO_ADDR
// if not tmp then
110946: LD_VAR 0 2
110950: NOT
110951: IFFALSE 110955
// exit ;
110953: GO 111098
// for i := 1 to 2 do
110955: LD_ADDR_VAR 0 1
110959: PUSH
110960: DOUBLE
110961: LD_INT 1
110963: DEC
110964: ST_TO_ADDR
110965: LD_INT 2
110967: PUSH
110968: FOR_TO
110969: IFFALSE 111096
// begin uc_side := your_side ;
110971: LD_ADDR_OWVAR 20
110975: PUSH
110976: LD_OWVAR 2
110980: ST_TO_ADDR
// uc_nation := nation_american ;
110981: LD_ADDR_OWVAR 21
110985: PUSH
110986: LD_INT 1
110988: ST_TO_ADDR
// vc_chassis := us_morphling ;
110989: LD_ADDR_OWVAR 37
110993: PUSH
110994: LD_INT 5
110996: ST_TO_ADDR
// vc_engine := engine_siberite ;
110997: LD_ADDR_OWVAR 39
111001: PUSH
111002: LD_INT 3
111004: ST_TO_ADDR
// vc_control := control_computer ;
111005: LD_ADDR_OWVAR 38
111009: PUSH
111010: LD_INT 3
111012: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111013: LD_ADDR_OWVAR 40
111017: PUSH
111018: LD_INT 10
111020: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111021: LD_VAR 0 2
111025: PUSH
111026: LD_INT 1
111028: ARRAY
111029: PPUSH
111030: CALL_OW 310
111034: NOT
111035: IFFALSE 111082
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
111037: CALL_OW 45
111041: PPUSH
111042: LD_VAR 0 2
111046: PUSH
111047: LD_INT 1
111049: ARRAY
111050: PPUSH
111051: CALL_OW 250
111055: PPUSH
111056: LD_VAR 0 2
111060: PUSH
111061: LD_INT 1
111063: ARRAY
111064: PPUSH
111065: CALL_OW 251
111069: PPUSH
111070: LD_INT 12
111072: PPUSH
111073: LD_INT 1
111075: PPUSH
111076: CALL_OW 50
111080: GO 111094
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
111082: CALL_OW 45
111086: PPUSH
111087: LD_INT 1
111089: PPUSH
111090: CALL_OW 51
// end ;
111094: GO 110968
111096: POP
111097: POP
// end ;
111098: PPOPN 2
111100: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
111101: LD_EXP 154
111105: PUSH
111106: LD_EXP 200
111110: AND
111111: IFFALSE 111333
111113: GO 111115
111115: DISABLE
111116: LD_INT 0
111118: PPUSH
111119: PPUSH
111120: PPUSH
111121: PPUSH
111122: PPUSH
111123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111124: LD_ADDR_VAR 0 6
111128: PUSH
111129: LD_INT 22
111131: PUSH
111132: LD_OWVAR 2
111136: PUSH
111137: EMPTY
111138: LIST
111139: LIST
111140: PUSH
111141: LD_INT 21
111143: PUSH
111144: LD_INT 1
111146: PUSH
111147: EMPTY
111148: LIST
111149: LIST
111150: PUSH
111151: LD_INT 3
111153: PUSH
111154: LD_INT 23
111156: PUSH
111157: LD_INT 0
111159: PUSH
111160: EMPTY
111161: LIST
111162: LIST
111163: PUSH
111164: EMPTY
111165: LIST
111166: LIST
111167: PUSH
111168: EMPTY
111169: LIST
111170: LIST
111171: LIST
111172: PPUSH
111173: CALL_OW 69
111177: ST_TO_ADDR
// if not tmp then
111178: LD_VAR 0 6
111182: NOT
111183: IFFALSE 111187
// exit ;
111185: GO 111333
// s1 := rand ( 1 , 4 ) ;
111187: LD_ADDR_VAR 0 2
111191: PUSH
111192: LD_INT 1
111194: PPUSH
111195: LD_INT 4
111197: PPUSH
111198: CALL_OW 12
111202: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
111203: LD_ADDR_VAR 0 4
111207: PUSH
111208: LD_VAR 0 6
111212: PUSH
111213: LD_INT 1
111215: ARRAY
111216: PPUSH
111217: LD_VAR 0 2
111221: PPUSH
111222: CALL_OW 259
111226: ST_TO_ADDR
// if s1 = 1 then
111227: LD_VAR 0 2
111231: PUSH
111232: LD_INT 1
111234: EQUAL
111235: IFFALSE 111255
// s2 := rand ( 2 , 4 ) else
111237: LD_ADDR_VAR 0 3
111241: PUSH
111242: LD_INT 2
111244: PPUSH
111245: LD_INT 4
111247: PPUSH
111248: CALL_OW 12
111252: ST_TO_ADDR
111253: GO 111263
// s2 := 1 ;
111255: LD_ADDR_VAR 0 3
111259: PUSH
111260: LD_INT 1
111262: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
111263: LD_ADDR_VAR 0 5
111267: PUSH
111268: LD_VAR 0 6
111272: PUSH
111273: LD_INT 1
111275: ARRAY
111276: PPUSH
111277: LD_VAR 0 3
111281: PPUSH
111282: CALL_OW 259
111286: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
111287: LD_VAR 0 6
111291: PUSH
111292: LD_INT 1
111294: ARRAY
111295: PPUSH
111296: LD_VAR 0 2
111300: PPUSH
111301: LD_VAR 0 5
111305: PPUSH
111306: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111310: LD_VAR 0 6
111314: PUSH
111315: LD_INT 1
111317: ARRAY
111318: PPUSH
111319: LD_VAR 0 3
111323: PPUSH
111324: LD_VAR 0 4
111328: PPUSH
111329: CALL_OW 237
// end ;
111333: PPOPN 6
111335: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111336: LD_EXP 154
111340: PUSH
111341: LD_EXP 201
111345: AND
111346: IFFALSE 111425
111348: GO 111350
111350: DISABLE
111351: LD_INT 0
111353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111354: LD_ADDR_VAR 0 1
111358: PUSH
111359: LD_INT 22
111361: PUSH
111362: LD_OWVAR 2
111366: PUSH
111367: EMPTY
111368: LIST
111369: LIST
111370: PUSH
111371: LD_INT 30
111373: PUSH
111374: LD_INT 3
111376: PUSH
111377: EMPTY
111378: LIST
111379: LIST
111380: PUSH
111381: EMPTY
111382: LIST
111383: LIST
111384: PPUSH
111385: CALL_OW 69
111389: ST_TO_ADDR
// if not tmp then
111390: LD_VAR 0 1
111394: NOT
111395: IFFALSE 111399
// exit ;
111397: GO 111425
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111399: LD_VAR 0 1
111403: PUSH
111404: LD_INT 1
111406: PPUSH
111407: LD_VAR 0 1
111411: PPUSH
111412: CALL_OW 12
111416: ARRAY
111417: PPUSH
111418: LD_INT 1
111420: PPUSH
111421: CALL_OW 234
// end ;
111425: PPOPN 1
111427: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111428: LD_EXP 154
111432: PUSH
111433: LD_EXP 202
111437: AND
111438: IFFALSE 111550
111440: GO 111442
111442: DISABLE
111443: LD_INT 0
111445: PPUSH
111446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111447: LD_ADDR_VAR 0 2
111451: PUSH
111452: LD_INT 22
111454: PUSH
111455: LD_OWVAR 2
111459: PUSH
111460: EMPTY
111461: LIST
111462: LIST
111463: PUSH
111464: LD_INT 2
111466: PUSH
111467: LD_INT 30
111469: PUSH
111470: LD_INT 27
111472: PUSH
111473: EMPTY
111474: LIST
111475: LIST
111476: PUSH
111477: LD_INT 30
111479: PUSH
111480: LD_INT 26
111482: PUSH
111483: EMPTY
111484: LIST
111485: LIST
111486: PUSH
111487: LD_INT 30
111489: PUSH
111490: LD_INT 28
111492: PUSH
111493: EMPTY
111494: LIST
111495: LIST
111496: PUSH
111497: EMPTY
111498: LIST
111499: LIST
111500: LIST
111501: LIST
111502: PUSH
111503: EMPTY
111504: LIST
111505: LIST
111506: PPUSH
111507: CALL_OW 69
111511: ST_TO_ADDR
// if not tmp then
111512: LD_VAR 0 2
111516: NOT
111517: IFFALSE 111521
// exit ;
111519: GO 111550
// for i in tmp do
111521: LD_ADDR_VAR 0 1
111525: PUSH
111526: LD_VAR 0 2
111530: PUSH
111531: FOR_IN
111532: IFFALSE 111548
// SetLives ( i , 1 ) ;
111534: LD_VAR 0 1
111538: PPUSH
111539: LD_INT 1
111541: PPUSH
111542: CALL_OW 234
111546: GO 111531
111548: POP
111549: POP
// end ;
111550: PPOPN 2
111552: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111553: LD_EXP 154
111557: PUSH
111558: LD_EXP 203
111562: AND
111563: IFFALSE 111837
111565: GO 111567
111567: DISABLE
111568: LD_INT 0
111570: PPUSH
111571: PPUSH
111572: PPUSH
// begin i := rand ( 1 , 7 ) ;
111573: LD_ADDR_VAR 0 1
111577: PUSH
111578: LD_INT 1
111580: PPUSH
111581: LD_INT 7
111583: PPUSH
111584: CALL_OW 12
111588: ST_TO_ADDR
// case i of 1 :
111589: LD_VAR 0 1
111593: PUSH
111594: LD_INT 1
111596: DOUBLE
111597: EQUAL
111598: IFTRUE 111602
111600: GO 111612
111602: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111603: LD_STRING earthquake(getX(game), 0, 32)
111605: PPUSH
111606: CALL_OW 559
111610: GO 111837
111612: LD_INT 2
111614: DOUBLE
111615: EQUAL
111616: IFTRUE 111620
111618: GO 111634
111620: POP
// begin ToLua ( displayStucuk(); ) ;
111621: LD_STRING displayStucuk();
111623: PPUSH
111624: CALL_OW 559
// ResetFog ;
111628: CALL_OW 335
// end ; 3 :
111632: GO 111837
111634: LD_INT 3
111636: DOUBLE
111637: EQUAL
111638: IFTRUE 111642
111640: GO 111746
111642: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111643: LD_ADDR_VAR 0 2
111647: PUSH
111648: LD_INT 22
111650: PUSH
111651: LD_OWVAR 2
111655: PUSH
111656: EMPTY
111657: LIST
111658: LIST
111659: PUSH
111660: LD_INT 25
111662: PUSH
111663: LD_INT 1
111665: PUSH
111666: EMPTY
111667: LIST
111668: LIST
111669: PUSH
111670: EMPTY
111671: LIST
111672: LIST
111673: PPUSH
111674: CALL_OW 69
111678: ST_TO_ADDR
// if not tmp then
111679: LD_VAR 0 2
111683: NOT
111684: IFFALSE 111688
// exit ;
111686: GO 111837
// un := tmp [ rand ( 1 , tmp ) ] ;
111688: LD_ADDR_VAR 0 3
111692: PUSH
111693: LD_VAR 0 2
111697: PUSH
111698: LD_INT 1
111700: PPUSH
111701: LD_VAR 0 2
111705: PPUSH
111706: CALL_OW 12
111710: ARRAY
111711: ST_TO_ADDR
// if Crawls ( un ) then
111712: LD_VAR 0 3
111716: PPUSH
111717: CALL_OW 318
111721: IFFALSE 111732
// ComWalk ( un ) ;
111723: LD_VAR 0 3
111727: PPUSH
111728: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111732: LD_VAR 0 3
111736: PPUSH
111737: LD_INT 8
111739: PPUSH
111740: CALL_OW 336
// end ; 4 :
111744: GO 111837
111746: LD_INT 4
111748: DOUBLE
111749: EQUAL
111750: IFTRUE 111754
111752: GO 111815
111754: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111755: LD_ADDR_VAR 0 2
111759: PUSH
111760: LD_INT 22
111762: PUSH
111763: LD_OWVAR 2
111767: PUSH
111768: EMPTY
111769: LIST
111770: LIST
111771: PUSH
111772: LD_INT 30
111774: PUSH
111775: LD_INT 29
111777: PUSH
111778: EMPTY
111779: LIST
111780: LIST
111781: PUSH
111782: EMPTY
111783: LIST
111784: LIST
111785: PPUSH
111786: CALL_OW 69
111790: ST_TO_ADDR
// if not tmp then
111791: LD_VAR 0 2
111795: NOT
111796: IFFALSE 111800
// exit ;
111798: GO 111837
// DestroyUnit ( tmp [ 1 ] ) ;
111800: LD_VAR 0 2
111804: PUSH
111805: LD_INT 1
111807: ARRAY
111808: PPUSH
111809: CALL_OW 65
// end ; 5 .. 7 :
111813: GO 111837
111815: LD_INT 5
111817: DOUBLE
111818: GREATEREQUAL
111819: IFFALSE 111827
111821: LD_INT 7
111823: DOUBLE
111824: LESSEQUAL
111825: IFTRUE 111829
111827: GO 111836
111829: POP
// StreamSibBomb ; end ;
111830: CALL 108087 0 0
111834: GO 111837
111836: POP
// end ;
111837: PPOPN 3
111839: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111840: LD_EXP 154
111844: PUSH
111845: LD_EXP 204
111849: AND
111850: IFFALSE 112006
111852: GO 111854
111854: DISABLE
111855: LD_INT 0
111857: PPUSH
111858: PPUSH
111859: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111860: LD_ADDR_VAR 0 2
111864: PUSH
111865: LD_INT 81
111867: PUSH
111868: LD_OWVAR 2
111872: PUSH
111873: EMPTY
111874: LIST
111875: LIST
111876: PUSH
111877: LD_INT 2
111879: PUSH
111880: LD_INT 21
111882: PUSH
111883: LD_INT 1
111885: PUSH
111886: EMPTY
111887: LIST
111888: LIST
111889: PUSH
111890: LD_INT 21
111892: PUSH
111893: LD_INT 2
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: PUSH
111900: EMPTY
111901: LIST
111902: LIST
111903: LIST
111904: PUSH
111905: EMPTY
111906: LIST
111907: LIST
111908: PPUSH
111909: CALL_OW 69
111913: ST_TO_ADDR
// if not tmp then
111914: LD_VAR 0 2
111918: NOT
111919: IFFALSE 111923
// exit ;
111921: GO 112006
// p := 0 ;
111923: LD_ADDR_VAR 0 3
111927: PUSH
111928: LD_INT 0
111930: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111931: LD_INT 35
111933: PPUSH
111934: CALL_OW 67
// p := p + 1 ;
111938: LD_ADDR_VAR 0 3
111942: PUSH
111943: LD_VAR 0 3
111947: PUSH
111948: LD_INT 1
111950: PLUS
111951: ST_TO_ADDR
// for i in tmp do
111952: LD_ADDR_VAR 0 1
111956: PUSH
111957: LD_VAR 0 2
111961: PUSH
111962: FOR_IN
111963: IFFALSE 111994
// if GetLives ( i ) < 1000 then
111965: LD_VAR 0 1
111969: PPUSH
111970: CALL_OW 256
111974: PUSH
111975: LD_INT 1000
111977: LESS
111978: IFFALSE 111992
// SetLives ( i , 1000 ) ;
111980: LD_VAR 0 1
111984: PPUSH
111985: LD_INT 1000
111987: PPUSH
111988: CALL_OW 234
111992: GO 111962
111994: POP
111995: POP
// until p > 20 ;
111996: LD_VAR 0 3
112000: PUSH
112001: LD_INT 20
112003: GREATER
112004: IFFALSE 111931
// end ;
112006: PPOPN 3
112008: END
// every 0 0$1 trigger StreamModeActive and sTime do
112009: LD_EXP 154
112013: PUSH
112014: LD_EXP 205
112018: AND
112019: IFFALSE 112054
112021: GO 112023
112023: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
112024: LD_INT 28
112026: PPUSH
112027: LD_OWVAR 2
112031: PPUSH
112032: LD_INT 2
112034: PPUSH
112035: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
112039: LD_INT 30
112041: PPUSH
112042: LD_OWVAR 2
112046: PPUSH
112047: LD_INT 2
112049: PPUSH
112050: CALL_OW 322
// end ;
112054: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
112055: LD_EXP 154
112059: PUSH
112060: LD_EXP 206
112064: AND
112065: IFFALSE 112186
112067: GO 112069
112069: DISABLE
112070: LD_INT 0
112072: PPUSH
112073: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112074: LD_ADDR_VAR 0 2
112078: PUSH
112079: LD_INT 22
112081: PUSH
112082: LD_OWVAR 2
112086: PUSH
112087: EMPTY
112088: LIST
112089: LIST
112090: PUSH
112091: LD_INT 21
112093: PUSH
112094: LD_INT 1
112096: PUSH
112097: EMPTY
112098: LIST
112099: LIST
112100: PUSH
112101: LD_INT 3
112103: PUSH
112104: LD_INT 23
112106: PUSH
112107: LD_INT 0
112109: PUSH
112110: EMPTY
112111: LIST
112112: LIST
112113: PUSH
112114: EMPTY
112115: LIST
112116: LIST
112117: PUSH
112118: EMPTY
112119: LIST
112120: LIST
112121: LIST
112122: PPUSH
112123: CALL_OW 69
112127: ST_TO_ADDR
// if not tmp then
112128: LD_VAR 0 2
112132: NOT
112133: IFFALSE 112137
// exit ;
112135: GO 112186
// for i in tmp do
112137: LD_ADDR_VAR 0 1
112141: PUSH
112142: LD_VAR 0 2
112146: PUSH
112147: FOR_IN
112148: IFFALSE 112184
// begin if Crawls ( i ) then
112150: LD_VAR 0 1
112154: PPUSH
112155: CALL_OW 318
112159: IFFALSE 112170
// ComWalk ( i ) ;
112161: LD_VAR 0 1
112165: PPUSH
112166: CALL_OW 138
// SetClass ( i , 2 ) ;
112170: LD_VAR 0 1
112174: PPUSH
112175: LD_INT 2
112177: PPUSH
112178: CALL_OW 336
// end ;
112182: GO 112147
112184: POP
112185: POP
// end ;
112186: PPOPN 2
112188: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
112189: LD_EXP 154
112193: PUSH
112194: LD_EXP 207
112198: AND
112199: IFFALSE 112480
112201: GO 112203
112203: DISABLE
112204: LD_INT 0
112206: PPUSH
112207: PPUSH
112208: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
112209: LD_OWVAR 2
112213: PPUSH
112214: LD_INT 9
112216: PPUSH
112217: LD_INT 1
112219: PPUSH
112220: LD_INT 1
112222: PPUSH
112223: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
112227: LD_INT 9
112229: PPUSH
112230: LD_OWVAR 2
112234: PPUSH
112235: CALL_OW 343
// uc_side := 9 ;
112239: LD_ADDR_OWVAR 20
112243: PUSH
112244: LD_INT 9
112246: ST_TO_ADDR
// uc_nation := 2 ;
112247: LD_ADDR_OWVAR 21
112251: PUSH
112252: LD_INT 2
112254: ST_TO_ADDR
// hc_name := Dark Warrior ;
112255: LD_ADDR_OWVAR 26
112259: PUSH
112260: LD_STRING Dark Warrior
112262: ST_TO_ADDR
// hc_gallery :=  ;
112263: LD_ADDR_OWVAR 33
112267: PUSH
112268: LD_STRING 
112270: ST_TO_ADDR
// hc_noskilllimit := true ;
112271: LD_ADDR_OWVAR 76
112275: PUSH
112276: LD_INT 1
112278: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
112279: LD_ADDR_OWVAR 31
112283: PUSH
112284: LD_INT 30
112286: PUSH
112287: LD_INT 30
112289: PUSH
112290: LD_INT 30
112292: PUSH
112293: LD_INT 30
112295: PUSH
112296: EMPTY
112297: LIST
112298: LIST
112299: LIST
112300: LIST
112301: ST_TO_ADDR
// un := CreateHuman ;
112302: LD_ADDR_VAR 0 3
112306: PUSH
112307: CALL_OW 44
112311: ST_TO_ADDR
// hc_noskilllimit := false ;
112312: LD_ADDR_OWVAR 76
112316: PUSH
112317: LD_INT 0
112319: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112320: LD_VAR 0 3
112324: PPUSH
112325: LD_INT 1
112327: PPUSH
112328: CALL_OW 51
// p := 0 ;
112332: LD_ADDR_VAR 0 2
112336: PUSH
112337: LD_INT 0
112339: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112340: LD_INT 35
112342: PPUSH
112343: CALL_OW 67
// p := p + 1 ;
112347: LD_ADDR_VAR 0 2
112351: PUSH
112352: LD_VAR 0 2
112356: PUSH
112357: LD_INT 1
112359: PLUS
112360: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112361: LD_VAR 0 3
112365: PPUSH
112366: CALL_OW 256
112370: PUSH
112371: LD_INT 1000
112373: LESS
112374: IFFALSE 112388
// SetLives ( un , 1000 ) ;
112376: LD_VAR 0 3
112380: PPUSH
112381: LD_INT 1000
112383: PPUSH
112384: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112388: LD_VAR 0 3
112392: PPUSH
112393: LD_INT 81
112395: PUSH
112396: LD_OWVAR 2
112400: PUSH
112401: EMPTY
112402: LIST
112403: LIST
112404: PUSH
112405: LD_INT 91
112407: PUSH
112408: LD_VAR 0 3
112412: PUSH
112413: LD_INT 30
112415: PUSH
112416: EMPTY
112417: LIST
112418: LIST
112419: LIST
112420: PUSH
112421: EMPTY
112422: LIST
112423: LIST
112424: PPUSH
112425: CALL_OW 69
112429: PPUSH
112430: LD_VAR 0 3
112434: PPUSH
112435: CALL_OW 74
112439: PPUSH
112440: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
112444: LD_VAR 0 2
112448: PUSH
112449: LD_INT 60
112451: GREATER
112452: PUSH
112453: LD_VAR 0 3
112457: PPUSH
112458: CALL_OW 301
112462: OR
112463: IFFALSE 112340
// if un then
112465: LD_VAR 0 3
112469: IFFALSE 112480
// RemoveUnit ( un ) ;
112471: LD_VAR 0 3
112475: PPUSH
112476: CALL_OW 64
// end ; end_of_file
112480: PPOPN 3
112482: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112483: LD_INT 0
112485: PPUSH
112486: PPUSH
112487: PPUSH
112488: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112489: LD_VAR 0 1
112493: PPUSH
112494: CALL_OW 264
112498: PUSH
112499: LD_EXP 99
112503: EQUAL
112504: IFFALSE 112576
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112506: LD_INT 68
112508: PPUSH
112509: LD_VAR 0 1
112513: PPUSH
112514: CALL_OW 255
112518: PPUSH
112519: CALL_OW 321
112523: PUSH
112524: LD_INT 2
112526: EQUAL
112527: IFFALSE 112539
// eff := 70 else
112529: LD_ADDR_VAR 0 4
112533: PUSH
112534: LD_INT 70
112536: ST_TO_ADDR
112537: GO 112547
// eff := 30 ;
112539: LD_ADDR_VAR 0 4
112543: PUSH
112544: LD_INT 30
112546: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112547: LD_VAR 0 1
112551: PPUSH
112552: CALL_OW 250
112556: PPUSH
112557: LD_VAR 0 1
112561: PPUSH
112562: CALL_OW 251
112566: PPUSH
112567: LD_VAR 0 4
112571: PPUSH
112572: CALL_OW 495
// end ; end ;
112576: LD_VAR 0 2
112580: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112581: LD_INT 0
112583: PPUSH
// end ;
112584: LD_VAR 0 4
112588: RET
// export function SOS_Command ( cmd ) ; begin
112589: LD_INT 0
112591: PPUSH
// end ;
112592: LD_VAR 0 2
112596: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112597: LD_VAR 0 1
112601: PUSH
112602: LD_INT 255
112604: EQUAL
112605: PUSH
112606: LD_VAR 0 2
112610: PPUSH
112611: CALL_OW 264
112615: PUSH
112616: LD_INT 14
112618: PUSH
112619: LD_INT 53
112621: PUSH
112622: EMPTY
112623: LIST
112624: LIST
112625: IN
112626: AND
112627: PUSH
112628: LD_VAR 0 4
112632: PPUSH
112633: LD_VAR 0 5
112637: PPUSH
112638: CALL_OW 488
112642: AND
112643: IFFALSE 112667
// CutTreeXYR ( unit , x , y , 12 ) ;
112645: LD_VAR 0 2
112649: PPUSH
112650: LD_VAR 0 4
112654: PPUSH
112655: LD_VAR 0 5
112659: PPUSH
112660: LD_INT 12
112662: PPUSH
112663: CALL 112670 0 4
// end ;
112667: PPOPN 5
112669: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112670: LD_INT 0
112672: PPUSH
112673: PPUSH
112674: PPUSH
112675: PPUSH
112676: PPUSH
112677: PPUSH
112678: PPUSH
112679: PPUSH
112680: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
112681: LD_VAR 0 1
112685: NOT
112686: PUSH
112687: LD_VAR 0 2
112691: PPUSH
112692: LD_VAR 0 3
112696: PPUSH
112697: CALL_OW 488
112701: NOT
112702: OR
112703: PUSH
112704: LD_VAR 0 4
112708: NOT
112709: OR
112710: IFFALSE 112714
// exit ;
112712: GO 113054
// list := [ ] ;
112714: LD_ADDR_VAR 0 13
112718: PUSH
112719: EMPTY
112720: ST_TO_ADDR
// if x - r < 0 then
112721: LD_VAR 0 2
112725: PUSH
112726: LD_VAR 0 4
112730: MINUS
112731: PUSH
112732: LD_INT 0
112734: LESS
112735: IFFALSE 112747
// min_x := 0 else
112737: LD_ADDR_VAR 0 7
112741: PUSH
112742: LD_INT 0
112744: ST_TO_ADDR
112745: GO 112763
// min_x := x - r ;
112747: LD_ADDR_VAR 0 7
112751: PUSH
112752: LD_VAR 0 2
112756: PUSH
112757: LD_VAR 0 4
112761: MINUS
112762: ST_TO_ADDR
// if y - r < 0 then
112763: LD_VAR 0 3
112767: PUSH
112768: LD_VAR 0 4
112772: MINUS
112773: PUSH
112774: LD_INT 0
112776: LESS
112777: IFFALSE 112789
// min_y := 0 else
112779: LD_ADDR_VAR 0 8
112783: PUSH
112784: LD_INT 0
112786: ST_TO_ADDR
112787: GO 112805
// min_y := y - r ;
112789: LD_ADDR_VAR 0 8
112793: PUSH
112794: LD_VAR 0 3
112798: PUSH
112799: LD_VAR 0 4
112803: MINUS
112804: ST_TO_ADDR
// max_x := x + r ;
112805: LD_ADDR_VAR 0 9
112809: PUSH
112810: LD_VAR 0 2
112814: PUSH
112815: LD_VAR 0 4
112819: PLUS
112820: ST_TO_ADDR
// max_y := y + r ;
112821: LD_ADDR_VAR 0 10
112825: PUSH
112826: LD_VAR 0 3
112830: PUSH
112831: LD_VAR 0 4
112835: PLUS
112836: ST_TO_ADDR
// for _x = min_x to max_x do
112837: LD_ADDR_VAR 0 11
112841: PUSH
112842: DOUBLE
112843: LD_VAR 0 7
112847: DEC
112848: ST_TO_ADDR
112849: LD_VAR 0 9
112853: PUSH
112854: FOR_TO
112855: IFFALSE 112972
// for _y = min_y to max_y do
112857: LD_ADDR_VAR 0 12
112861: PUSH
112862: DOUBLE
112863: LD_VAR 0 8
112867: DEC
112868: ST_TO_ADDR
112869: LD_VAR 0 10
112873: PUSH
112874: FOR_TO
112875: IFFALSE 112968
// begin if not ValidHex ( _x , _y ) then
112877: LD_VAR 0 11
112881: PPUSH
112882: LD_VAR 0 12
112886: PPUSH
112887: CALL_OW 488
112891: NOT
112892: IFFALSE 112896
// continue ;
112894: GO 112874
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112896: LD_VAR 0 11
112900: PPUSH
112901: LD_VAR 0 12
112905: PPUSH
112906: CALL_OW 351
112910: PUSH
112911: LD_VAR 0 11
112915: PPUSH
112916: LD_VAR 0 12
112920: PPUSH
112921: CALL_OW 554
112925: AND
112926: IFFALSE 112966
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112928: LD_ADDR_VAR 0 13
112932: PUSH
112933: LD_VAR 0 13
112937: PPUSH
112938: LD_VAR 0 13
112942: PUSH
112943: LD_INT 1
112945: PLUS
112946: PPUSH
112947: LD_VAR 0 11
112951: PUSH
112952: LD_VAR 0 12
112956: PUSH
112957: EMPTY
112958: LIST
112959: LIST
112960: PPUSH
112961: CALL_OW 2
112965: ST_TO_ADDR
// end ;
112966: GO 112874
112968: POP
112969: POP
112970: GO 112854
112972: POP
112973: POP
// if not list then
112974: LD_VAR 0 13
112978: NOT
112979: IFFALSE 112983
// exit ;
112981: GO 113054
// for i in list do
112983: LD_ADDR_VAR 0 6
112987: PUSH
112988: LD_VAR 0 13
112992: PUSH
112993: FOR_IN
112994: IFFALSE 113052
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112996: LD_VAR 0 1
113000: PPUSH
113001: LD_STRING M
113003: PUSH
113004: LD_VAR 0 6
113008: PUSH
113009: LD_INT 1
113011: ARRAY
113012: PUSH
113013: LD_VAR 0 6
113017: PUSH
113018: LD_INT 2
113020: ARRAY
113021: PUSH
113022: LD_INT 0
113024: PUSH
113025: LD_INT 0
113027: PUSH
113028: LD_INT 0
113030: PUSH
113031: LD_INT 0
113033: PUSH
113034: EMPTY
113035: LIST
113036: LIST
113037: LIST
113038: LIST
113039: LIST
113040: LIST
113041: LIST
113042: PUSH
113043: EMPTY
113044: LIST
113045: PPUSH
113046: CALL_OW 447
113050: GO 112993
113052: POP
113053: POP
// end ; end_of_file
113054: LD_VAR 0 5
113058: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113059: LD_INT 0
113061: PPUSH
113062: PPUSH
113063: PPUSH
113064: PPUSH
113065: PPUSH
113066: PPUSH
113067: PPUSH
113068: PPUSH
113069: PPUSH
113070: PPUSH
113071: PPUSH
113072: PPUSH
113073: PPUSH
113074: PPUSH
113075: PPUSH
113076: PPUSH
113077: PPUSH
113078: PPUSH
113079: PPUSH
113080: PPUSH
113081: PPUSH
113082: PPUSH
113083: PPUSH
113084: PPUSH
113085: PPUSH
113086: PPUSH
113087: PPUSH
113088: PPUSH
113089: PPUSH
113090: PPUSH
113091: PPUSH
113092: PPUSH
113093: PPUSH
113094: PPUSH
// if not list then
113095: LD_VAR 0 1
113099: NOT
113100: IFFALSE 113104
// exit ;
113102: GO 117763
// base := list [ 1 ] ;
113104: LD_ADDR_VAR 0 3
113108: PUSH
113109: LD_VAR 0 1
113113: PUSH
113114: LD_INT 1
113116: ARRAY
113117: ST_TO_ADDR
// group := list [ 2 ] ;
113118: LD_ADDR_VAR 0 4
113122: PUSH
113123: LD_VAR 0 1
113127: PUSH
113128: LD_INT 2
113130: ARRAY
113131: ST_TO_ADDR
// path := list [ 3 ] ;
113132: LD_ADDR_VAR 0 5
113136: PUSH
113137: LD_VAR 0 1
113141: PUSH
113142: LD_INT 3
113144: ARRAY
113145: ST_TO_ADDR
// flags := list [ 4 ] ;
113146: LD_ADDR_VAR 0 6
113150: PUSH
113151: LD_VAR 0 1
113155: PUSH
113156: LD_INT 4
113158: ARRAY
113159: ST_TO_ADDR
// mined := [ ] ;
113160: LD_ADDR_VAR 0 27
113164: PUSH
113165: EMPTY
113166: ST_TO_ADDR
// bombed := [ ] ;
113167: LD_ADDR_VAR 0 28
113171: PUSH
113172: EMPTY
113173: ST_TO_ADDR
// healers := [ ] ;
113174: LD_ADDR_VAR 0 31
113178: PUSH
113179: EMPTY
113180: ST_TO_ADDR
// to_heal := [ ] ;
113181: LD_ADDR_VAR 0 30
113185: PUSH
113186: EMPTY
113187: ST_TO_ADDR
// repairs := [ ] ;
113188: LD_ADDR_VAR 0 33
113192: PUSH
113193: EMPTY
113194: ST_TO_ADDR
// to_repair := [ ] ;
113195: LD_ADDR_VAR 0 32
113199: PUSH
113200: EMPTY
113201: ST_TO_ADDR
// if not group or not path then
113202: LD_VAR 0 4
113206: NOT
113207: PUSH
113208: LD_VAR 0 5
113212: NOT
113213: OR
113214: IFFALSE 113218
// exit ;
113216: GO 117763
// side := GetSide ( group [ 1 ] ) ;
113218: LD_ADDR_VAR 0 35
113222: PUSH
113223: LD_VAR 0 4
113227: PUSH
113228: LD_INT 1
113230: ARRAY
113231: PPUSH
113232: CALL_OW 255
113236: ST_TO_ADDR
// if flags then
113237: LD_VAR 0 6
113241: IFFALSE 113385
// begin f_ignore_area := flags [ 1 ] ;
113243: LD_ADDR_VAR 0 17
113247: PUSH
113248: LD_VAR 0 6
113252: PUSH
113253: LD_INT 1
113255: ARRAY
113256: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113257: LD_ADDR_VAR 0 18
113261: PUSH
113262: LD_VAR 0 6
113266: PUSH
113267: LD_INT 2
113269: ARRAY
113270: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113271: LD_ADDR_VAR 0 19
113275: PUSH
113276: LD_VAR 0 6
113280: PUSH
113281: LD_INT 3
113283: ARRAY
113284: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113285: LD_ADDR_VAR 0 20
113289: PUSH
113290: LD_VAR 0 6
113294: PUSH
113295: LD_INT 4
113297: ARRAY
113298: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113299: LD_ADDR_VAR 0 21
113303: PUSH
113304: LD_VAR 0 6
113308: PUSH
113309: LD_INT 5
113311: ARRAY
113312: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113313: LD_ADDR_VAR 0 22
113317: PUSH
113318: LD_VAR 0 6
113322: PUSH
113323: LD_INT 6
113325: ARRAY
113326: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113327: LD_ADDR_VAR 0 23
113331: PUSH
113332: LD_VAR 0 6
113336: PUSH
113337: LD_INT 7
113339: ARRAY
113340: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113341: LD_ADDR_VAR 0 24
113345: PUSH
113346: LD_VAR 0 6
113350: PUSH
113351: LD_INT 8
113353: ARRAY
113354: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113355: LD_ADDR_VAR 0 25
113359: PUSH
113360: LD_VAR 0 6
113364: PUSH
113365: LD_INT 9
113367: ARRAY
113368: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113369: LD_ADDR_VAR 0 26
113373: PUSH
113374: LD_VAR 0 6
113378: PUSH
113379: LD_INT 10
113381: ARRAY
113382: ST_TO_ADDR
// end else
113383: GO 113465
// begin f_ignore_area := false ;
113385: LD_ADDR_VAR 0 17
113389: PUSH
113390: LD_INT 0
113392: ST_TO_ADDR
// f_capture := false ;
113393: LD_ADDR_VAR 0 18
113397: PUSH
113398: LD_INT 0
113400: ST_TO_ADDR
// f_ignore_civ := false ;
113401: LD_ADDR_VAR 0 19
113405: PUSH
113406: LD_INT 0
113408: ST_TO_ADDR
// f_murder := false ;
113409: LD_ADDR_VAR 0 20
113413: PUSH
113414: LD_INT 0
113416: ST_TO_ADDR
// f_mines := false ;
113417: LD_ADDR_VAR 0 21
113421: PUSH
113422: LD_INT 0
113424: ST_TO_ADDR
// f_repair := false ;
113425: LD_ADDR_VAR 0 22
113429: PUSH
113430: LD_INT 0
113432: ST_TO_ADDR
// f_heal := false ;
113433: LD_ADDR_VAR 0 23
113437: PUSH
113438: LD_INT 0
113440: ST_TO_ADDR
// f_spacetime := false ;
113441: LD_ADDR_VAR 0 24
113445: PUSH
113446: LD_INT 0
113448: ST_TO_ADDR
// f_attack_depot := false ;
113449: LD_ADDR_VAR 0 25
113453: PUSH
113454: LD_INT 0
113456: ST_TO_ADDR
// f_crawl := false ;
113457: LD_ADDR_VAR 0 26
113461: PUSH
113462: LD_INT 0
113464: ST_TO_ADDR
// end ; if f_heal then
113465: LD_VAR 0 23
113469: IFFALSE 113496
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113471: LD_ADDR_VAR 0 31
113475: PUSH
113476: LD_VAR 0 4
113480: PPUSH
113481: LD_INT 25
113483: PUSH
113484: LD_INT 4
113486: PUSH
113487: EMPTY
113488: LIST
113489: LIST
113490: PPUSH
113491: CALL_OW 72
113495: ST_TO_ADDR
// if f_repair then
113496: LD_VAR 0 22
113500: IFFALSE 113527
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113502: LD_ADDR_VAR 0 33
113506: PUSH
113507: LD_VAR 0 4
113511: PPUSH
113512: LD_INT 25
113514: PUSH
113515: LD_INT 3
113517: PUSH
113518: EMPTY
113519: LIST
113520: LIST
113521: PPUSH
113522: CALL_OW 72
113526: ST_TO_ADDR
// units_path := [ ] ;
113527: LD_ADDR_VAR 0 16
113531: PUSH
113532: EMPTY
113533: ST_TO_ADDR
// for i = 1 to group do
113534: LD_ADDR_VAR 0 7
113538: PUSH
113539: DOUBLE
113540: LD_INT 1
113542: DEC
113543: ST_TO_ADDR
113544: LD_VAR 0 4
113548: PUSH
113549: FOR_TO
113550: IFFALSE 113579
// units_path := Replace ( units_path , i , path ) ;
113552: LD_ADDR_VAR 0 16
113556: PUSH
113557: LD_VAR 0 16
113561: PPUSH
113562: LD_VAR 0 7
113566: PPUSH
113567: LD_VAR 0 5
113571: PPUSH
113572: CALL_OW 1
113576: ST_TO_ADDR
113577: GO 113549
113579: POP
113580: POP
// repeat for i = group downto 1 do
113581: LD_ADDR_VAR 0 7
113585: PUSH
113586: DOUBLE
113587: LD_VAR 0 4
113591: INC
113592: ST_TO_ADDR
113593: LD_INT 1
113595: PUSH
113596: FOR_DOWNTO
113597: IFFALSE 117719
// begin wait ( 5 ) ;
113599: LD_INT 5
113601: PPUSH
113602: CALL_OW 67
// tmp := [ ] ;
113606: LD_ADDR_VAR 0 14
113610: PUSH
113611: EMPTY
113612: ST_TO_ADDR
// attacking := false ;
113613: LD_ADDR_VAR 0 29
113617: PUSH
113618: LD_INT 0
113620: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113621: LD_VAR 0 4
113625: PUSH
113626: LD_VAR 0 7
113630: ARRAY
113631: PPUSH
113632: CALL_OW 301
113636: PUSH
113637: LD_VAR 0 4
113641: PUSH
113642: LD_VAR 0 7
113646: ARRAY
113647: NOT
113648: OR
113649: IFFALSE 113758
// begin if GetType ( group [ i ] ) = unit_human then
113651: LD_VAR 0 4
113655: PUSH
113656: LD_VAR 0 7
113660: ARRAY
113661: PPUSH
113662: CALL_OW 247
113666: PUSH
113667: LD_INT 1
113669: EQUAL
113670: IFFALSE 113716
// begin to_heal := to_heal diff group [ i ] ;
113672: LD_ADDR_VAR 0 30
113676: PUSH
113677: LD_VAR 0 30
113681: PUSH
113682: LD_VAR 0 4
113686: PUSH
113687: LD_VAR 0 7
113691: ARRAY
113692: DIFF
113693: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113694: LD_ADDR_VAR 0 31
113698: PUSH
113699: LD_VAR 0 31
113703: PUSH
113704: LD_VAR 0 4
113708: PUSH
113709: LD_VAR 0 7
113713: ARRAY
113714: DIFF
113715: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113716: LD_ADDR_VAR 0 4
113720: PUSH
113721: LD_VAR 0 4
113725: PPUSH
113726: LD_VAR 0 7
113730: PPUSH
113731: CALL_OW 3
113735: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113736: LD_ADDR_VAR 0 16
113740: PUSH
113741: LD_VAR 0 16
113745: PPUSH
113746: LD_VAR 0 7
113750: PPUSH
113751: CALL_OW 3
113755: ST_TO_ADDR
// continue ;
113756: GO 113596
// end ; if f_repair then
113758: LD_VAR 0 22
113762: IFFALSE 114251
// begin if GetType ( group [ i ] ) = unit_vehicle then
113764: LD_VAR 0 4
113768: PUSH
113769: LD_VAR 0 7
113773: ARRAY
113774: PPUSH
113775: CALL_OW 247
113779: PUSH
113780: LD_INT 2
113782: EQUAL
113783: IFFALSE 113973
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113785: LD_VAR 0 4
113789: PUSH
113790: LD_VAR 0 7
113794: ARRAY
113795: PPUSH
113796: CALL_OW 256
113800: PUSH
113801: LD_INT 700
113803: LESS
113804: PUSH
113805: LD_VAR 0 4
113809: PUSH
113810: LD_VAR 0 7
113814: ARRAY
113815: PUSH
113816: LD_VAR 0 32
113820: IN
113821: NOT
113822: AND
113823: IFFALSE 113847
// to_repair := to_repair union group [ i ] ;
113825: LD_ADDR_VAR 0 32
113829: PUSH
113830: LD_VAR 0 32
113834: PUSH
113835: LD_VAR 0 4
113839: PUSH
113840: LD_VAR 0 7
113844: ARRAY
113845: UNION
113846: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113847: LD_VAR 0 4
113851: PUSH
113852: LD_VAR 0 7
113856: ARRAY
113857: PPUSH
113858: CALL_OW 256
113862: PUSH
113863: LD_INT 1000
113865: EQUAL
113866: PUSH
113867: LD_VAR 0 4
113871: PUSH
113872: LD_VAR 0 7
113876: ARRAY
113877: PUSH
113878: LD_VAR 0 32
113882: IN
113883: AND
113884: IFFALSE 113908
// to_repair := to_repair diff group [ i ] ;
113886: LD_ADDR_VAR 0 32
113890: PUSH
113891: LD_VAR 0 32
113895: PUSH
113896: LD_VAR 0 4
113900: PUSH
113901: LD_VAR 0 7
113905: ARRAY
113906: DIFF
113907: ST_TO_ADDR
// if group [ i ] in to_repair then
113908: LD_VAR 0 4
113912: PUSH
113913: LD_VAR 0 7
113917: ARRAY
113918: PUSH
113919: LD_VAR 0 32
113923: IN
113924: IFFALSE 113971
// begin if not IsInArea ( group [ i ] , f_repair ) then
113926: LD_VAR 0 4
113930: PUSH
113931: LD_VAR 0 7
113935: ARRAY
113936: PPUSH
113937: LD_VAR 0 22
113941: PPUSH
113942: CALL_OW 308
113946: NOT
113947: IFFALSE 113969
// ComMoveToArea ( group [ i ] , f_repair ) ;
113949: LD_VAR 0 4
113953: PUSH
113954: LD_VAR 0 7
113958: ARRAY
113959: PPUSH
113960: LD_VAR 0 22
113964: PPUSH
113965: CALL_OW 113
// continue ;
113969: GO 113596
// end ; end else
113971: GO 114251
// if group [ i ] in repairs then
113973: LD_VAR 0 4
113977: PUSH
113978: LD_VAR 0 7
113982: ARRAY
113983: PUSH
113984: LD_VAR 0 33
113988: IN
113989: IFFALSE 114251
// begin if IsInUnit ( group [ i ] ) then
113991: LD_VAR 0 4
113995: PUSH
113996: LD_VAR 0 7
114000: ARRAY
114001: PPUSH
114002: CALL_OW 310
114006: IFFALSE 114074
// begin z := IsInUnit ( group [ i ] ) ;
114008: LD_ADDR_VAR 0 13
114012: PUSH
114013: LD_VAR 0 4
114017: PUSH
114018: LD_VAR 0 7
114022: ARRAY
114023: PPUSH
114024: CALL_OW 310
114028: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114029: LD_VAR 0 13
114033: PUSH
114034: LD_VAR 0 32
114038: IN
114039: PUSH
114040: LD_VAR 0 13
114044: PPUSH
114045: LD_VAR 0 22
114049: PPUSH
114050: CALL_OW 308
114054: AND
114055: IFFALSE 114072
// ComExitVehicle ( group [ i ] ) ;
114057: LD_VAR 0 4
114061: PUSH
114062: LD_VAR 0 7
114066: ARRAY
114067: PPUSH
114068: CALL_OW 121
// end else
114072: GO 114251
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114074: LD_ADDR_VAR 0 13
114078: PUSH
114079: LD_VAR 0 4
114083: PPUSH
114084: LD_INT 95
114086: PUSH
114087: LD_VAR 0 22
114091: PUSH
114092: EMPTY
114093: LIST
114094: LIST
114095: PUSH
114096: LD_INT 58
114098: PUSH
114099: EMPTY
114100: LIST
114101: PUSH
114102: EMPTY
114103: LIST
114104: LIST
114105: PPUSH
114106: CALL_OW 72
114110: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114111: LD_VAR 0 4
114115: PUSH
114116: LD_VAR 0 7
114120: ARRAY
114121: PPUSH
114122: CALL_OW 314
114126: NOT
114127: IFFALSE 114249
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114129: LD_ADDR_VAR 0 10
114133: PUSH
114134: LD_VAR 0 13
114138: PPUSH
114139: LD_VAR 0 4
114143: PUSH
114144: LD_VAR 0 7
114148: ARRAY
114149: PPUSH
114150: CALL_OW 74
114154: ST_TO_ADDR
// if not x then
114155: LD_VAR 0 10
114159: NOT
114160: IFFALSE 114164
// continue ;
114162: GO 113596
// if GetLives ( x ) < 1000 then
114164: LD_VAR 0 10
114168: PPUSH
114169: CALL_OW 256
114173: PUSH
114174: LD_INT 1000
114176: LESS
114177: IFFALSE 114201
// ComRepairVehicle ( group [ i ] , x ) else
114179: LD_VAR 0 4
114183: PUSH
114184: LD_VAR 0 7
114188: ARRAY
114189: PPUSH
114190: LD_VAR 0 10
114194: PPUSH
114195: CALL_OW 129
114199: GO 114249
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114201: LD_VAR 0 23
114205: PUSH
114206: LD_VAR 0 4
114210: PUSH
114211: LD_VAR 0 7
114215: ARRAY
114216: PPUSH
114217: CALL_OW 256
114221: PUSH
114222: LD_INT 1000
114224: LESS
114225: AND
114226: NOT
114227: IFFALSE 114249
// ComEnterUnit ( group [ i ] , x ) ;
114229: LD_VAR 0 4
114233: PUSH
114234: LD_VAR 0 7
114238: ARRAY
114239: PPUSH
114240: LD_VAR 0 10
114244: PPUSH
114245: CALL_OW 120
// end ; continue ;
114249: GO 113596
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114251: LD_VAR 0 23
114255: PUSH
114256: LD_VAR 0 4
114260: PUSH
114261: LD_VAR 0 7
114265: ARRAY
114266: PPUSH
114267: CALL_OW 247
114271: PUSH
114272: LD_INT 1
114274: EQUAL
114275: AND
114276: IFFALSE 114754
// begin if group [ i ] in healers then
114278: LD_VAR 0 4
114282: PUSH
114283: LD_VAR 0 7
114287: ARRAY
114288: PUSH
114289: LD_VAR 0 31
114293: IN
114294: IFFALSE 114567
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114296: LD_VAR 0 4
114300: PUSH
114301: LD_VAR 0 7
114305: ARRAY
114306: PPUSH
114307: LD_VAR 0 23
114311: PPUSH
114312: CALL_OW 308
114316: NOT
114317: PUSH
114318: LD_VAR 0 4
114322: PUSH
114323: LD_VAR 0 7
114327: ARRAY
114328: PPUSH
114329: CALL_OW 314
114333: NOT
114334: AND
114335: IFFALSE 114359
// ComMoveToArea ( group [ i ] , f_heal ) else
114337: LD_VAR 0 4
114341: PUSH
114342: LD_VAR 0 7
114346: ARRAY
114347: PPUSH
114348: LD_VAR 0 23
114352: PPUSH
114353: CALL_OW 113
114357: GO 114565
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114359: LD_VAR 0 4
114363: PUSH
114364: LD_VAR 0 7
114368: ARRAY
114369: PPUSH
114370: CALL 98402 0 1
114374: PPUSH
114375: CALL_OW 256
114379: PUSH
114380: LD_INT 1000
114382: EQUAL
114383: IFFALSE 114402
// ComStop ( group [ i ] ) else
114385: LD_VAR 0 4
114389: PUSH
114390: LD_VAR 0 7
114394: ARRAY
114395: PPUSH
114396: CALL_OW 141
114400: GO 114565
// if not HasTask ( group [ i ] ) and to_heal then
114402: LD_VAR 0 4
114406: PUSH
114407: LD_VAR 0 7
114411: ARRAY
114412: PPUSH
114413: CALL_OW 314
114417: NOT
114418: PUSH
114419: LD_VAR 0 30
114423: AND
114424: IFFALSE 114565
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114426: LD_ADDR_VAR 0 13
114430: PUSH
114431: LD_VAR 0 30
114435: PPUSH
114436: LD_INT 3
114438: PUSH
114439: LD_INT 54
114441: PUSH
114442: EMPTY
114443: LIST
114444: PUSH
114445: EMPTY
114446: LIST
114447: LIST
114448: PPUSH
114449: CALL_OW 72
114453: PPUSH
114454: LD_VAR 0 4
114458: PUSH
114459: LD_VAR 0 7
114463: ARRAY
114464: PPUSH
114465: CALL_OW 74
114469: ST_TO_ADDR
// if z then
114470: LD_VAR 0 13
114474: IFFALSE 114565
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114476: LD_INT 91
114478: PUSH
114479: LD_VAR 0 13
114483: PUSH
114484: LD_INT 10
114486: PUSH
114487: EMPTY
114488: LIST
114489: LIST
114490: LIST
114491: PUSH
114492: LD_INT 81
114494: PUSH
114495: LD_VAR 0 13
114499: PPUSH
114500: CALL_OW 255
114504: PUSH
114505: EMPTY
114506: LIST
114507: LIST
114508: PUSH
114509: EMPTY
114510: LIST
114511: LIST
114512: PPUSH
114513: CALL_OW 69
114517: PUSH
114518: LD_INT 0
114520: EQUAL
114521: IFFALSE 114545
// ComHeal ( group [ i ] , z ) else
114523: LD_VAR 0 4
114527: PUSH
114528: LD_VAR 0 7
114532: ARRAY
114533: PPUSH
114534: LD_VAR 0 13
114538: PPUSH
114539: CALL_OW 128
114543: GO 114565
// ComMoveToArea ( group [ i ] , f_heal ) ;
114545: LD_VAR 0 4
114549: PUSH
114550: LD_VAR 0 7
114554: ARRAY
114555: PPUSH
114556: LD_VAR 0 23
114560: PPUSH
114561: CALL_OW 113
// end ; continue ;
114565: GO 113596
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114567: LD_VAR 0 4
114571: PUSH
114572: LD_VAR 0 7
114576: ARRAY
114577: PPUSH
114578: CALL_OW 256
114582: PUSH
114583: LD_INT 700
114585: LESS
114586: PUSH
114587: LD_VAR 0 4
114591: PUSH
114592: LD_VAR 0 7
114596: ARRAY
114597: PUSH
114598: LD_VAR 0 30
114602: IN
114603: NOT
114604: AND
114605: IFFALSE 114629
// to_heal := to_heal union group [ i ] ;
114607: LD_ADDR_VAR 0 30
114611: PUSH
114612: LD_VAR 0 30
114616: PUSH
114617: LD_VAR 0 4
114621: PUSH
114622: LD_VAR 0 7
114626: ARRAY
114627: UNION
114628: ST_TO_ADDR
// if group [ i ] in to_heal then
114629: LD_VAR 0 4
114633: PUSH
114634: LD_VAR 0 7
114638: ARRAY
114639: PUSH
114640: LD_VAR 0 30
114644: IN
114645: IFFALSE 114754
// begin if GetLives ( group [ i ] ) = 1000 then
114647: LD_VAR 0 4
114651: PUSH
114652: LD_VAR 0 7
114656: ARRAY
114657: PPUSH
114658: CALL_OW 256
114662: PUSH
114663: LD_INT 1000
114665: EQUAL
114666: IFFALSE 114692
// to_heal := to_heal diff group [ i ] else
114668: LD_ADDR_VAR 0 30
114672: PUSH
114673: LD_VAR 0 30
114677: PUSH
114678: LD_VAR 0 4
114682: PUSH
114683: LD_VAR 0 7
114687: ARRAY
114688: DIFF
114689: ST_TO_ADDR
114690: GO 114754
// begin if not IsInArea ( group [ i ] , to_heal ) then
114692: LD_VAR 0 4
114696: PUSH
114697: LD_VAR 0 7
114701: ARRAY
114702: PPUSH
114703: LD_VAR 0 30
114707: PPUSH
114708: CALL_OW 308
114712: NOT
114713: IFFALSE 114737
// ComMoveToArea ( group [ i ] , f_heal ) else
114715: LD_VAR 0 4
114719: PUSH
114720: LD_VAR 0 7
114724: ARRAY
114725: PPUSH
114726: LD_VAR 0 23
114730: PPUSH
114731: CALL_OW 113
114735: GO 114752
// ComHold ( group [ i ] ) ;
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: CALL_OW 140
// continue ;
114752: GO 113596
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114754: LD_VAR 0 4
114758: PUSH
114759: LD_VAR 0 7
114763: ARRAY
114764: PPUSH
114765: LD_INT 10
114767: PPUSH
114768: CALL 96822 0 2
114772: NOT
114773: PUSH
114774: LD_VAR 0 16
114778: PUSH
114779: LD_VAR 0 7
114783: ARRAY
114784: PUSH
114785: EMPTY
114786: EQUAL
114787: NOT
114788: AND
114789: IFFALSE 115055
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114791: LD_VAR 0 4
114795: PUSH
114796: LD_VAR 0 7
114800: ARRAY
114801: PPUSH
114802: CALL_OW 262
114806: PUSH
114807: LD_INT 1
114809: PUSH
114810: LD_INT 2
114812: PUSH
114813: EMPTY
114814: LIST
114815: LIST
114816: IN
114817: IFFALSE 114858
// if GetFuel ( group [ i ] ) < 10 then
114819: LD_VAR 0 4
114823: PUSH
114824: LD_VAR 0 7
114828: ARRAY
114829: PPUSH
114830: CALL_OW 261
114834: PUSH
114835: LD_INT 10
114837: LESS
114838: IFFALSE 114858
// SetFuel ( group [ i ] , 12 ) ;
114840: LD_VAR 0 4
114844: PUSH
114845: LD_VAR 0 7
114849: ARRAY
114850: PPUSH
114851: LD_INT 12
114853: PPUSH
114854: CALL_OW 240
// if units_path [ i ] then
114858: LD_VAR 0 16
114862: PUSH
114863: LD_VAR 0 7
114867: ARRAY
114868: IFFALSE 115053
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114870: LD_VAR 0 4
114874: PUSH
114875: LD_VAR 0 7
114879: ARRAY
114880: PPUSH
114881: LD_VAR 0 16
114885: PUSH
114886: LD_VAR 0 7
114890: ARRAY
114891: PUSH
114892: LD_INT 1
114894: ARRAY
114895: PUSH
114896: LD_INT 1
114898: ARRAY
114899: PPUSH
114900: LD_VAR 0 16
114904: PUSH
114905: LD_VAR 0 7
114909: ARRAY
114910: PUSH
114911: LD_INT 1
114913: ARRAY
114914: PUSH
114915: LD_INT 2
114917: ARRAY
114918: PPUSH
114919: CALL_OW 297
114923: PUSH
114924: LD_INT 6
114926: GREATER
114927: IFFALSE 115002
// begin if not HasTask ( group [ i ] ) then
114929: LD_VAR 0 4
114933: PUSH
114934: LD_VAR 0 7
114938: ARRAY
114939: PPUSH
114940: CALL_OW 314
114944: NOT
114945: IFFALSE 115000
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114947: LD_VAR 0 4
114951: PUSH
114952: LD_VAR 0 7
114956: ARRAY
114957: PPUSH
114958: LD_VAR 0 16
114962: PUSH
114963: LD_VAR 0 7
114967: ARRAY
114968: PUSH
114969: LD_INT 1
114971: ARRAY
114972: PUSH
114973: LD_INT 1
114975: ARRAY
114976: PPUSH
114977: LD_VAR 0 16
114981: PUSH
114982: LD_VAR 0 7
114986: ARRAY
114987: PUSH
114988: LD_INT 1
114990: ARRAY
114991: PUSH
114992: LD_INT 2
114994: ARRAY
114995: PPUSH
114996: CALL_OW 114
// end else
115000: GO 115053
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115002: LD_ADDR_VAR 0 15
115006: PUSH
115007: LD_VAR 0 16
115011: PUSH
115012: LD_VAR 0 7
115016: ARRAY
115017: PPUSH
115018: LD_INT 1
115020: PPUSH
115021: CALL_OW 3
115025: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115026: LD_ADDR_VAR 0 16
115030: PUSH
115031: LD_VAR 0 16
115035: PPUSH
115036: LD_VAR 0 7
115040: PPUSH
115041: LD_VAR 0 15
115045: PPUSH
115046: CALL_OW 1
115050: ST_TO_ADDR
// continue ;
115051: GO 113596
// end ; end ; end else
115053: GO 117717
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115055: LD_ADDR_VAR 0 14
115059: PUSH
115060: LD_INT 81
115062: PUSH
115063: LD_VAR 0 4
115067: PUSH
115068: LD_VAR 0 7
115072: ARRAY
115073: PPUSH
115074: CALL_OW 255
115078: PUSH
115079: EMPTY
115080: LIST
115081: LIST
115082: PPUSH
115083: CALL_OW 69
115087: ST_TO_ADDR
// if not tmp then
115088: LD_VAR 0 14
115092: NOT
115093: IFFALSE 115097
// continue ;
115095: GO 113596
// if f_ignore_area then
115097: LD_VAR 0 17
115101: IFFALSE 115189
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115103: LD_ADDR_VAR 0 15
115107: PUSH
115108: LD_VAR 0 14
115112: PPUSH
115113: LD_INT 3
115115: PUSH
115116: LD_INT 92
115118: PUSH
115119: LD_VAR 0 17
115123: PUSH
115124: LD_INT 1
115126: ARRAY
115127: PUSH
115128: LD_VAR 0 17
115132: PUSH
115133: LD_INT 2
115135: ARRAY
115136: PUSH
115137: LD_VAR 0 17
115141: PUSH
115142: LD_INT 3
115144: ARRAY
115145: PUSH
115146: EMPTY
115147: LIST
115148: LIST
115149: LIST
115150: LIST
115151: PUSH
115152: EMPTY
115153: LIST
115154: LIST
115155: PPUSH
115156: CALL_OW 72
115160: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115161: LD_VAR 0 14
115165: PUSH
115166: LD_VAR 0 15
115170: DIFF
115171: IFFALSE 115189
// tmp := tmp diff tmp2 ;
115173: LD_ADDR_VAR 0 14
115177: PUSH
115178: LD_VAR 0 14
115182: PUSH
115183: LD_VAR 0 15
115187: DIFF
115188: ST_TO_ADDR
// end ; if not f_murder then
115189: LD_VAR 0 20
115193: NOT
115194: IFFALSE 115252
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115196: LD_ADDR_VAR 0 15
115200: PUSH
115201: LD_VAR 0 14
115205: PPUSH
115206: LD_INT 3
115208: PUSH
115209: LD_INT 50
115211: PUSH
115212: EMPTY
115213: LIST
115214: PUSH
115215: EMPTY
115216: LIST
115217: LIST
115218: PPUSH
115219: CALL_OW 72
115223: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115224: LD_VAR 0 14
115228: PUSH
115229: LD_VAR 0 15
115233: DIFF
115234: IFFALSE 115252
// tmp := tmp diff tmp2 ;
115236: LD_ADDR_VAR 0 14
115240: PUSH
115241: LD_VAR 0 14
115245: PUSH
115246: LD_VAR 0 15
115250: DIFF
115251: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115252: LD_ADDR_VAR 0 14
115256: PUSH
115257: LD_VAR 0 4
115261: PUSH
115262: LD_VAR 0 7
115266: ARRAY
115267: PPUSH
115268: LD_VAR 0 14
115272: PPUSH
115273: LD_INT 1
115275: PPUSH
115276: LD_INT 1
115278: PPUSH
115279: CALL 70465 0 4
115283: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115284: LD_VAR 0 4
115288: PUSH
115289: LD_VAR 0 7
115293: ARRAY
115294: PPUSH
115295: CALL_OW 257
115299: PUSH
115300: LD_INT 1
115302: EQUAL
115303: IFFALSE 115751
// begin if WantPlant ( group [ i ] ) then
115305: LD_VAR 0 4
115309: PUSH
115310: LD_VAR 0 7
115314: ARRAY
115315: PPUSH
115316: CALL 69966 0 1
115320: IFFALSE 115324
// continue ;
115322: GO 113596
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115324: LD_VAR 0 18
115328: PUSH
115329: LD_VAR 0 4
115333: PUSH
115334: LD_VAR 0 7
115338: ARRAY
115339: PPUSH
115340: CALL_OW 310
115344: NOT
115345: AND
115346: PUSH
115347: LD_VAR 0 14
115351: PUSH
115352: LD_INT 1
115354: ARRAY
115355: PUSH
115356: LD_VAR 0 14
115360: PPUSH
115361: LD_INT 21
115363: PUSH
115364: LD_INT 2
115366: PUSH
115367: EMPTY
115368: LIST
115369: LIST
115370: PUSH
115371: LD_INT 58
115373: PUSH
115374: EMPTY
115375: LIST
115376: PUSH
115377: EMPTY
115378: LIST
115379: LIST
115380: PPUSH
115381: CALL_OW 72
115385: IN
115386: AND
115387: IFFALSE 115423
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115389: LD_VAR 0 4
115393: PUSH
115394: LD_VAR 0 7
115398: ARRAY
115399: PPUSH
115400: LD_VAR 0 14
115404: PUSH
115405: LD_INT 1
115407: ARRAY
115408: PPUSH
115409: CALL_OW 120
// attacking := true ;
115413: LD_ADDR_VAR 0 29
115417: PUSH
115418: LD_INT 1
115420: ST_TO_ADDR
// continue ;
115421: GO 113596
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115423: LD_VAR 0 26
115427: PUSH
115428: LD_VAR 0 4
115432: PUSH
115433: LD_VAR 0 7
115437: ARRAY
115438: PPUSH
115439: CALL_OW 257
115443: PUSH
115444: LD_INT 1
115446: EQUAL
115447: AND
115448: PUSH
115449: LD_VAR 0 4
115453: PUSH
115454: LD_VAR 0 7
115458: ARRAY
115459: PPUSH
115460: CALL_OW 256
115464: PUSH
115465: LD_INT 800
115467: LESS
115468: AND
115469: PUSH
115470: LD_VAR 0 4
115474: PUSH
115475: LD_VAR 0 7
115479: ARRAY
115480: PPUSH
115481: CALL_OW 318
115485: NOT
115486: AND
115487: IFFALSE 115504
// ComCrawl ( group [ i ] ) ;
115489: LD_VAR 0 4
115493: PUSH
115494: LD_VAR 0 7
115498: ARRAY
115499: PPUSH
115500: CALL_OW 137
// if f_mines then
115504: LD_VAR 0 21
115508: IFFALSE 115751
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115510: LD_VAR 0 14
115514: PUSH
115515: LD_INT 1
115517: ARRAY
115518: PPUSH
115519: CALL_OW 247
115523: PUSH
115524: LD_INT 3
115526: EQUAL
115527: PUSH
115528: LD_VAR 0 14
115532: PUSH
115533: LD_INT 1
115535: ARRAY
115536: PUSH
115537: LD_VAR 0 27
115541: IN
115542: NOT
115543: AND
115544: IFFALSE 115751
// begin x := GetX ( tmp [ 1 ] ) ;
115546: LD_ADDR_VAR 0 10
115550: PUSH
115551: LD_VAR 0 14
115555: PUSH
115556: LD_INT 1
115558: ARRAY
115559: PPUSH
115560: CALL_OW 250
115564: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115565: LD_ADDR_VAR 0 11
115569: PUSH
115570: LD_VAR 0 14
115574: PUSH
115575: LD_INT 1
115577: ARRAY
115578: PPUSH
115579: CALL_OW 251
115583: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115584: LD_ADDR_VAR 0 12
115588: PUSH
115589: LD_VAR 0 4
115593: PUSH
115594: LD_VAR 0 7
115598: ARRAY
115599: PPUSH
115600: CALL 96907 0 1
115604: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115605: LD_VAR 0 4
115609: PUSH
115610: LD_VAR 0 7
115614: ARRAY
115615: PPUSH
115616: LD_VAR 0 10
115620: PPUSH
115621: LD_VAR 0 11
115625: PPUSH
115626: LD_VAR 0 14
115630: PUSH
115631: LD_INT 1
115633: ARRAY
115634: PPUSH
115635: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115639: LD_VAR 0 4
115643: PUSH
115644: LD_VAR 0 7
115648: ARRAY
115649: PPUSH
115650: LD_VAR 0 10
115654: PPUSH
115655: LD_VAR 0 12
115659: PPUSH
115660: LD_INT 7
115662: PPUSH
115663: CALL_OW 272
115667: PPUSH
115668: LD_VAR 0 11
115672: PPUSH
115673: LD_VAR 0 12
115677: PPUSH
115678: LD_INT 7
115680: PPUSH
115681: CALL_OW 273
115685: PPUSH
115686: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115690: LD_VAR 0 4
115694: PUSH
115695: LD_VAR 0 7
115699: ARRAY
115700: PPUSH
115701: LD_INT 71
115703: PPUSH
115704: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115708: LD_ADDR_VAR 0 27
115712: PUSH
115713: LD_VAR 0 27
115717: PPUSH
115718: LD_VAR 0 27
115722: PUSH
115723: LD_INT 1
115725: PLUS
115726: PPUSH
115727: LD_VAR 0 14
115731: PUSH
115732: LD_INT 1
115734: ARRAY
115735: PPUSH
115736: CALL_OW 1
115740: ST_TO_ADDR
// attacking := true ;
115741: LD_ADDR_VAR 0 29
115745: PUSH
115746: LD_INT 1
115748: ST_TO_ADDR
// continue ;
115749: GO 113596
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115751: LD_VAR 0 4
115755: PUSH
115756: LD_VAR 0 7
115760: ARRAY
115761: PPUSH
115762: CALL_OW 257
115766: PUSH
115767: LD_INT 17
115769: EQUAL
115770: PUSH
115771: LD_VAR 0 4
115775: PUSH
115776: LD_VAR 0 7
115780: ARRAY
115781: PPUSH
115782: CALL_OW 110
115786: PUSH
115787: LD_INT 71
115789: EQUAL
115790: NOT
115791: AND
115792: IFFALSE 115938
// begin attacking := false ;
115794: LD_ADDR_VAR 0 29
115798: PUSH
115799: LD_INT 0
115801: ST_TO_ADDR
// k := 5 ;
115802: LD_ADDR_VAR 0 9
115806: PUSH
115807: LD_INT 5
115809: ST_TO_ADDR
// if tmp < k then
115810: LD_VAR 0 14
115814: PUSH
115815: LD_VAR 0 9
115819: LESS
115820: IFFALSE 115832
// k := tmp ;
115822: LD_ADDR_VAR 0 9
115826: PUSH
115827: LD_VAR 0 14
115831: ST_TO_ADDR
// for j = 1 to k do
115832: LD_ADDR_VAR 0 8
115836: PUSH
115837: DOUBLE
115838: LD_INT 1
115840: DEC
115841: ST_TO_ADDR
115842: LD_VAR 0 9
115846: PUSH
115847: FOR_TO
115848: IFFALSE 115936
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115850: LD_VAR 0 14
115854: PUSH
115855: LD_VAR 0 8
115859: ARRAY
115860: PUSH
115861: LD_VAR 0 14
115865: PPUSH
115866: LD_INT 58
115868: PUSH
115869: EMPTY
115870: LIST
115871: PPUSH
115872: CALL_OW 72
115876: IN
115877: NOT
115878: IFFALSE 115934
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115880: LD_VAR 0 4
115884: PUSH
115885: LD_VAR 0 7
115889: ARRAY
115890: PPUSH
115891: LD_VAR 0 14
115895: PUSH
115896: LD_VAR 0 8
115900: ARRAY
115901: PPUSH
115902: CALL_OW 115
// attacking := true ;
115906: LD_ADDR_VAR 0 29
115910: PUSH
115911: LD_INT 1
115913: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115914: LD_VAR 0 4
115918: PUSH
115919: LD_VAR 0 7
115923: ARRAY
115924: PPUSH
115925: LD_INT 71
115927: PPUSH
115928: CALL_OW 109
// continue ;
115932: GO 115847
// end ; end ;
115934: GO 115847
115936: POP
115937: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115938: LD_VAR 0 4
115942: PUSH
115943: LD_VAR 0 7
115947: ARRAY
115948: PPUSH
115949: CALL_OW 257
115953: PUSH
115954: LD_INT 8
115956: EQUAL
115957: PUSH
115958: LD_VAR 0 4
115962: PUSH
115963: LD_VAR 0 7
115967: ARRAY
115968: PPUSH
115969: CALL_OW 264
115973: PUSH
115974: LD_INT 28
115976: PUSH
115977: LD_INT 45
115979: PUSH
115980: LD_INT 7
115982: PUSH
115983: LD_INT 47
115985: PUSH
115986: EMPTY
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: IN
115992: OR
115993: IFFALSE 116249
// begin attacking := false ;
115995: LD_ADDR_VAR 0 29
115999: PUSH
116000: LD_INT 0
116002: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116003: LD_VAR 0 14
116007: PUSH
116008: LD_INT 1
116010: ARRAY
116011: PPUSH
116012: CALL_OW 266
116016: PUSH
116017: LD_INT 32
116019: PUSH
116020: LD_INT 31
116022: PUSH
116023: LD_INT 33
116025: PUSH
116026: LD_INT 4
116028: PUSH
116029: LD_INT 5
116031: PUSH
116032: EMPTY
116033: LIST
116034: LIST
116035: LIST
116036: LIST
116037: LIST
116038: IN
116039: IFFALSE 116225
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116041: LD_ADDR_VAR 0 9
116045: PUSH
116046: LD_VAR 0 14
116050: PUSH
116051: LD_INT 1
116053: ARRAY
116054: PPUSH
116055: CALL_OW 266
116059: PPUSH
116060: LD_VAR 0 14
116064: PUSH
116065: LD_INT 1
116067: ARRAY
116068: PPUSH
116069: CALL_OW 250
116073: PPUSH
116074: LD_VAR 0 14
116078: PUSH
116079: LD_INT 1
116081: ARRAY
116082: PPUSH
116083: CALL_OW 251
116087: PPUSH
116088: LD_VAR 0 14
116092: PUSH
116093: LD_INT 1
116095: ARRAY
116096: PPUSH
116097: CALL_OW 254
116101: PPUSH
116102: LD_VAR 0 14
116106: PUSH
116107: LD_INT 1
116109: ARRAY
116110: PPUSH
116111: CALL_OW 248
116115: PPUSH
116116: LD_INT 0
116118: PPUSH
116119: CALL 78277 0 6
116123: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116124: LD_ADDR_VAR 0 8
116128: PUSH
116129: LD_VAR 0 4
116133: PUSH
116134: LD_VAR 0 7
116138: ARRAY
116139: PPUSH
116140: LD_VAR 0 9
116144: PPUSH
116145: CALL 96947 0 2
116149: ST_TO_ADDR
// if j then
116150: LD_VAR 0 8
116154: IFFALSE 116223
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116156: LD_VAR 0 8
116160: PUSH
116161: LD_INT 1
116163: ARRAY
116164: PPUSH
116165: LD_VAR 0 8
116169: PUSH
116170: LD_INT 2
116172: ARRAY
116173: PPUSH
116174: CALL_OW 488
116178: IFFALSE 116223
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116180: LD_VAR 0 4
116184: PUSH
116185: LD_VAR 0 7
116189: ARRAY
116190: PPUSH
116191: LD_VAR 0 8
116195: PUSH
116196: LD_INT 1
116198: ARRAY
116199: PPUSH
116200: LD_VAR 0 8
116204: PUSH
116205: LD_INT 2
116207: ARRAY
116208: PPUSH
116209: CALL_OW 116
// attacking := true ;
116213: LD_ADDR_VAR 0 29
116217: PUSH
116218: LD_INT 1
116220: ST_TO_ADDR
// continue ;
116221: GO 113596
// end ; end else
116223: GO 116249
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116225: LD_VAR 0 4
116229: PUSH
116230: LD_VAR 0 7
116234: ARRAY
116235: PPUSH
116236: LD_VAR 0 14
116240: PUSH
116241: LD_INT 1
116243: ARRAY
116244: PPUSH
116245: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116249: LD_VAR 0 4
116253: PUSH
116254: LD_VAR 0 7
116258: ARRAY
116259: PPUSH
116260: CALL_OW 265
116264: PUSH
116265: LD_INT 11
116267: EQUAL
116268: IFFALSE 116546
// begin k := 10 ;
116270: LD_ADDR_VAR 0 9
116274: PUSH
116275: LD_INT 10
116277: ST_TO_ADDR
// x := 0 ;
116278: LD_ADDR_VAR 0 10
116282: PUSH
116283: LD_INT 0
116285: ST_TO_ADDR
// if tmp < k then
116286: LD_VAR 0 14
116290: PUSH
116291: LD_VAR 0 9
116295: LESS
116296: IFFALSE 116308
// k := tmp ;
116298: LD_ADDR_VAR 0 9
116302: PUSH
116303: LD_VAR 0 14
116307: ST_TO_ADDR
// for j = k downto 1 do
116308: LD_ADDR_VAR 0 8
116312: PUSH
116313: DOUBLE
116314: LD_VAR 0 9
116318: INC
116319: ST_TO_ADDR
116320: LD_INT 1
116322: PUSH
116323: FOR_DOWNTO
116324: IFFALSE 116399
// begin if GetType ( tmp [ j ] ) = unit_human then
116326: LD_VAR 0 14
116330: PUSH
116331: LD_VAR 0 8
116335: ARRAY
116336: PPUSH
116337: CALL_OW 247
116341: PUSH
116342: LD_INT 1
116344: EQUAL
116345: IFFALSE 116397
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116347: LD_VAR 0 4
116351: PUSH
116352: LD_VAR 0 7
116356: ARRAY
116357: PPUSH
116358: LD_VAR 0 14
116362: PUSH
116363: LD_VAR 0 8
116367: ARRAY
116368: PPUSH
116369: CALL 97218 0 2
// x := tmp [ j ] ;
116373: LD_ADDR_VAR 0 10
116377: PUSH
116378: LD_VAR 0 14
116382: PUSH
116383: LD_VAR 0 8
116387: ARRAY
116388: ST_TO_ADDR
// attacking := true ;
116389: LD_ADDR_VAR 0 29
116393: PUSH
116394: LD_INT 1
116396: ST_TO_ADDR
// end ; end ;
116397: GO 116323
116399: POP
116400: POP
// if not x then
116401: LD_VAR 0 10
116405: NOT
116406: IFFALSE 116546
// begin attacking := true ;
116408: LD_ADDR_VAR 0 29
116412: PUSH
116413: LD_INT 1
116415: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116416: LD_VAR 0 4
116420: PUSH
116421: LD_VAR 0 7
116425: ARRAY
116426: PPUSH
116427: CALL_OW 250
116431: PPUSH
116432: LD_VAR 0 4
116436: PUSH
116437: LD_VAR 0 7
116441: ARRAY
116442: PPUSH
116443: CALL_OW 251
116447: PPUSH
116448: CALL_OW 546
116452: PUSH
116453: LD_INT 2
116455: ARRAY
116456: PUSH
116457: LD_VAR 0 14
116461: PUSH
116462: LD_INT 1
116464: ARRAY
116465: PPUSH
116466: CALL_OW 250
116470: PPUSH
116471: LD_VAR 0 14
116475: PUSH
116476: LD_INT 1
116478: ARRAY
116479: PPUSH
116480: CALL_OW 251
116484: PPUSH
116485: CALL_OW 546
116489: PUSH
116490: LD_INT 2
116492: ARRAY
116493: EQUAL
116494: IFFALSE 116522
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116496: LD_VAR 0 4
116500: PUSH
116501: LD_VAR 0 7
116505: ARRAY
116506: PPUSH
116507: LD_VAR 0 14
116511: PUSH
116512: LD_INT 1
116514: ARRAY
116515: PPUSH
116516: CALL 97218 0 2
116520: GO 116546
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116522: LD_VAR 0 4
116526: PUSH
116527: LD_VAR 0 7
116531: ARRAY
116532: PPUSH
116533: LD_VAR 0 14
116537: PUSH
116538: LD_INT 1
116540: ARRAY
116541: PPUSH
116542: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116546: LD_VAR 0 4
116550: PUSH
116551: LD_VAR 0 7
116555: ARRAY
116556: PPUSH
116557: CALL_OW 264
116561: PUSH
116562: LD_INT 29
116564: EQUAL
116565: IFFALSE 116931
// begin if WantsToAttack ( group [ i ] ) in bombed then
116567: LD_VAR 0 4
116571: PUSH
116572: LD_VAR 0 7
116576: ARRAY
116577: PPUSH
116578: CALL_OW 319
116582: PUSH
116583: LD_VAR 0 28
116587: IN
116588: IFFALSE 116592
// continue ;
116590: GO 113596
// k := 8 ;
116592: LD_ADDR_VAR 0 9
116596: PUSH
116597: LD_INT 8
116599: ST_TO_ADDR
// x := 0 ;
116600: LD_ADDR_VAR 0 10
116604: PUSH
116605: LD_INT 0
116607: ST_TO_ADDR
// if tmp < k then
116608: LD_VAR 0 14
116612: PUSH
116613: LD_VAR 0 9
116617: LESS
116618: IFFALSE 116630
// k := tmp ;
116620: LD_ADDR_VAR 0 9
116624: PUSH
116625: LD_VAR 0 14
116629: ST_TO_ADDR
// for j = 1 to k do
116630: LD_ADDR_VAR 0 8
116634: PUSH
116635: DOUBLE
116636: LD_INT 1
116638: DEC
116639: ST_TO_ADDR
116640: LD_VAR 0 9
116644: PUSH
116645: FOR_TO
116646: IFFALSE 116778
// begin if GetType ( tmp [ j ] ) = unit_building then
116648: LD_VAR 0 14
116652: PUSH
116653: LD_VAR 0 8
116657: ARRAY
116658: PPUSH
116659: CALL_OW 247
116663: PUSH
116664: LD_INT 3
116666: EQUAL
116667: IFFALSE 116776
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116669: LD_VAR 0 14
116673: PUSH
116674: LD_VAR 0 8
116678: ARRAY
116679: PUSH
116680: LD_VAR 0 28
116684: IN
116685: NOT
116686: PUSH
116687: LD_VAR 0 14
116691: PUSH
116692: LD_VAR 0 8
116696: ARRAY
116697: PPUSH
116698: CALL_OW 313
116702: AND
116703: IFFALSE 116776
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116705: LD_VAR 0 4
116709: PUSH
116710: LD_VAR 0 7
116714: ARRAY
116715: PPUSH
116716: LD_VAR 0 14
116720: PUSH
116721: LD_VAR 0 8
116725: ARRAY
116726: PPUSH
116727: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116731: LD_ADDR_VAR 0 28
116735: PUSH
116736: LD_VAR 0 28
116740: PPUSH
116741: LD_VAR 0 28
116745: PUSH
116746: LD_INT 1
116748: PLUS
116749: PPUSH
116750: LD_VAR 0 14
116754: PUSH
116755: LD_VAR 0 8
116759: ARRAY
116760: PPUSH
116761: CALL_OW 1
116765: ST_TO_ADDR
// attacking := true ;
116766: LD_ADDR_VAR 0 29
116770: PUSH
116771: LD_INT 1
116773: ST_TO_ADDR
// break ;
116774: GO 116778
// end ; end ;
116776: GO 116645
116778: POP
116779: POP
// if not attacking and f_attack_depot then
116780: LD_VAR 0 29
116784: NOT
116785: PUSH
116786: LD_VAR 0 25
116790: AND
116791: IFFALSE 116886
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116793: LD_ADDR_VAR 0 13
116797: PUSH
116798: LD_VAR 0 14
116802: PPUSH
116803: LD_INT 2
116805: PUSH
116806: LD_INT 30
116808: PUSH
116809: LD_INT 0
116811: PUSH
116812: EMPTY
116813: LIST
116814: LIST
116815: PUSH
116816: LD_INT 30
116818: PUSH
116819: LD_INT 1
116821: PUSH
116822: EMPTY
116823: LIST
116824: LIST
116825: PUSH
116826: EMPTY
116827: LIST
116828: LIST
116829: LIST
116830: PPUSH
116831: CALL_OW 72
116835: ST_TO_ADDR
// if z then
116836: LD_VAR 0 13
116840: IFFALSE 116886
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116842: LD_VAR 0 4
116846: PUSH
116847: LD_VAR 0 7
116851: ARRAY
116852: PPUSH
116853: LD_VAR 0 13
116857: PPUSH
116858: LD_VAR 0 4
116862: PUSH
116863: LD_VAR 0 7
116867: ARRAY
116868: PPUSH
116869: CALL_OW 74
116873: PPUSH
116874: CALL_OW 115
// attacking := true ;
116878: LD_ADDR_VAR 0 29
116882: PUSH
116883: LD_INT 1
116885: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116886: LD_VAR 0 4
116890: PUSH
116891: LD_VAR 0 7
116895: ARRAY
116896: PPUSH
116897: CALL_OW 256
116901: PUSH
116902: LD_INT 500
116904: LESS
116905: IFFALSE 116931
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116907: LD_VAR 0 4
116911: PUSH
116912: LD_VAR 0 7
116916: ARRAY
116917: PPUSH
116918: LD_VAR 0 14
116922: PUSH
116923: LD_INT 1
116925: ARRAY
116926: PPUSH
116927: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116931: LD_VAR 0 4
116935: PUSH
116936: LD_VAR 0 7
116940: ARRAY
116941: PPUSH
116942: CALL_OW 264
116946: PUSH
116947: LD_INT 49
116949: EQUAL
116950: IFFALSE 117071
// begin if not HasTask ( group [ i ] ) then
116952: LD_VAR 0 4
116956: PUSH
116957: LD_VAR 0 7
116961: ARRAY
116962: PPUSH
116963: CALL_OW 314
116967: NOT
116968: IFFALSE 117071
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116970: LD_ADDR_VAR 0 9
116974: PUSH
116975: LD_INT 81
116977: PUSH
116978: LD_VAR 0 4
116982: PUSH
116983: LD_VAR 0 7
116987: ARRAY
116988: PPUSH
116989: CALL_OW 255
116993: PUSH
116994: EMPTY
116995: LIST
116996: LIST
116997: PPUSH
116998: CALL_OW 69
117002: PPUSH
117003: LD_VAR 0 4
117007: PUSH
117008: LD_VAR 0 7
117012: ARRAY
117013: PPUSH
117014: CALL_OW 74
117018: ST_TO_ADDR
// if k then
117019: LD_VAR 0 9
117023: IFFALSE 117071
// if GetDistUnits ( group [ i ] , k ) > 10 then
117025: LD_VAR 0 4
117029: PUSH
117030: LD_VAR 0 7
117034: ARRAY
117035: PPUSH
117036: LD_VAR 0 9
117040: PPUSH
117041: CALL_OW 296
117045: PUSH
117046: LD_INT 10
117048: GREATER
117049: IFFALSE 117071
// ComMoveUnit ( group [ i ] , k ) ;
117051: LD_VAR 0 4
117055: PUSH
117056: LD_VAR 0 7
117060: ARRAY
117061: PPUSH
117062: LD_VAR 0 9
117066: PPUSH
117067: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117071: LD_VAR 0 4
117075: PUSH
117076: LD_VAR 0 7
117080: ARRAY
117081: PPUSH
117082: CALL_OW 256
117086: PUSH
117087: LD_INT 250
117089: LESS
117090: PUSH
117091: LD_VAR 0 4
117095: PUSH
117096: LD_VAR 0 7
117100: ARRAY
117101: PUSH
117102: LD_INT 21
117104: PUSH
117105: LD_INT 2
117107: PUSH
117108: EMPTY
117109: LIST
117110: LIST
117111: PUSH
117112: LD_INT 23
117114: PUSH
117115: LD_INT 2
117117: PUSH
117118: EMPTY
117119: LIST
117120: LIST
117121: PUSH
117122: EMPTY
117123: LIST
117124: LIST
117125: PPUSH
117126: CALL_OW 69
117130: IN
117131: AND
117132: IFFALSE 117257
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117134: LD_ADDR_VAR 0 9
117138: PUSH
117139: LD_OWVAR 3
117143: PUSH
117144: LD_VAR 0 4
117148: PUSH
117149: LD_VAR 0 7
117153: ARRAY
117154: DIFF
117155: PPUSH
117156: LD_VAR 0 4
117160: PUSH
117161: LD_VAR 0 7
117165: ARRAY
117166: PPUSH
117167: CALL_OW 74
117171: ST_TO_ADDR
// if not k then
117172: LD_VAR 0 9
117176: NOT
117177: IFFALSE 117181
// continue ;
117179: GO 113596
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117181: LD_VAR 0 9
117185: PUSH
117186: LD_INT 81
117188: PUSH
117189: LD_VAR 0 4
117193: PUSH
117194: LD_VAR 0 7
117198: ARRAY
117199: PPUSH
117200: CALL_OW 255
117204: PUSH
117205: EMPTY
117206: LIST
117207: LIST
117208: PPUSH
117209: CALL_OW 69
117213: IN
117214: PUSH
117215: LD_VAR 0 9
117219: PPUSH
117220: LD_VAR 0 4
117224: PUSH
117225: LD_VAR 0 7
117229: ARRAY
117230: PPUSH
117231: CALL_OW 296
117235: PUSH
117236: LD_INT 5
117238: LESS
117239: AND
117240: IFFALSE 117257
// ComAutodestruct ( group [ i ] ) ;
117242: LD_VAR 0 4
117246: PUSH
117247: LD_VAR 0 7
117251: ARRAY
117252: PPUSH
117253: CALL 97116 0 1
// end ; if f_attack_depot then
117257: LD_VAR 0 25
117261: IFFALSE 117373
// begin k := 6 ;
117263: LD_ADDR_VAR 0 9
117267: PUSH
117268: LD_INT 6
117270: ST_TO_ADDR
// if tmp < k then
117271: LD_VAR 0 14
117275: PUSH
117276: LD_VAR 0 9
117280: LESS
117281: IFFALSE 117293
// k := tmp ;
117283: LD_ADDR_VAR 0 9
117287: PUSH
117288: LD_VAR 0 14
117292: ST_TO_ADDR
// for j = 1 to k do
117293: LD_ADDR_VAR 0 8
117297: PUSH
117298: DOUBLE
117299: LD_INT 1
117301: DEC
117302: ST_TO_ADDR
117303: LD_VAR 0 9
117307: PUSH
117308: FOR_TO
117309: IFFALSE 117371
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117311: LD_VAR 0 8
117315: PPUSH
117316: CALL_OW 266
117320: PUSH
117321: LD_INT 0
117323: PUSH
117324: LD_INT 1
117326: PUSH
117327: EMPTY
117328: LIST
117329: LIST
117330: IN
117331: IFFALSE 117369
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117333: LD_VAR 0 4
117337: PUSH
117338: LD_VAR 0 7
117342: ARRAY
117343: PPUSH
117344: LD_VAR 0 14
117348: PUSH
117349: LD_VAR 0 8
117353: ARRAY
117354: PPUSH
117355: CALL_OW 115
// attacking := true ;
117359: LD_ADDR_VAR 0 29
117363: PUSH
117364: LD_INT 1
117366: ST_TO_ADDR
// break ;
117367: GO 117371
// end ;
117369: GO 117308
117371: POP
117372: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117373: LD_VAR 0 4
117377: PUSH
117378: LD_VAR 0 7
117382: ARRAY
117383: PPUSH
117384: CALL_OW 302
117388: PUSH
117389: LD_VAR 0 29
117393: NOT
117394: AND
117395: IFFALSE 117717
// begin if GetTag ( group [ i ] ) = 71 then
117397: LD_VAR 0 4
117401: PUSH
117402: LD_VAR 0 7
117406: ARRAY
117407: PPUSH
117408: CALL_OW 110
117412: PUSH
117413: LD_INT 71
117415: EQUAL
117416: IFFALSE 117457
// begin if HasTask ( group [ i ] ) then
117418: LD_VAR 0 4
117422: PUSH
117423: LD_VAR 0 7
117427: ARRAY
117428: PPUSH
117429: CALL_OW 314
117433: IFFALSE 117439
// continue else
117435: GO 113596
117437: GO 117457
// SetTag ( group [ i ] , 0 ) ;
117439: LD_VAR 0 4
117443: PUSH
117444: LD_VAR 0 7
117448: ARRAY
117449: PPUSH
117450: LD_INT 0
117452: PPUSH
117453: CALL_OW 109
// end ; k := 8 ;
117457: LD_ADDR_VAR 0 9
117461: PUSH
117462: LD_INT 8
117464: ST_TO_ADDR
// x := 0 ;
117465: LD_ADDR_VAR 0 10
117469: PUSH
117470: LD_INT 0
117472: ST_TO_ADDR
// if tmp < k then
117473: LD_VAR 0 14
117477: PUSH
117478: LD_VAR 0 9
117482: LESS
117483: IFFALSE 117495
// k := tmp ;
117485: LD_ADDR_VAR 0 9
117489: PUSH
117490: LD_VAR 0 14
117494: ST_TO_ADDR
// for j = 1 to k do
117495: LD_ADDR_VAR 0 8
117499: PUSH
117500: DOUBLE
117501: LD_INT 1
117503: DEC
117504: ST_TO_ADDR
117505: LD_VAR 0 9
117509: PUSH
117510: FOR_TO
117511: IFFALSE 117609
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117513: LD_VAR 0 14
117517: PUSH
117518: LD_VAR 0 8
117522: ARRAY
117523: PPUSH
117524: CALL_OW 247
117528: PUSH
117529: LD_INT 1
117531: EQUAL
117532: PUSH
117533: LD_VAR 0 14
117537: PUSH
117538: LD_VAR 0 8
117542: ARRAY
117543: PPUSH
117544: CALL_OW 256
117548: PUSH
117549: LD_INT 250
117551: LESS
117552: PUSH
117553: LD_VAR 0 20
117557: AND
117558: PUSH
117559: LD_VAR 0 20
117563: NOT
117564: PUSH
117565: LD_VAR 0 14
117569: PUSH
117570: LD_VAR 0 8
117574: ARRAY
117575: PPUSH
117576: CALL_OW 256
117580: PUSH
117581: LD_INT 250
117583: GREATEREQUAL
117584: AND
117585: OR
117586: AND
117587: IFFALSE 117607
// begin x := tmp [ j ] ;
117589: LD_ADDR_VAR 0 10
117593: PUSH
117594: LD_VAR 0 14
117598: PUSH
117599: LD_VAR 0 8
117603: ARRAY
117604: ST_TO_ADDR
// break ;
117605: GO 117609
// end ;
117607: GO 117510
117609: POP
117610: POP
// if x then
117611: LD_VAR 0 10
117615: IFFALSE 117639
// ComAttackUnit ( group [ i ] , x ) else
117617: LD_VAR 0 4
117621: PUSH
117622: LD_VAR 0 7
117626: ARRAY
117627: PPUSH
117628: LD_VAR 0 10
117632: PPUSH
117633: CALL_OW 115
117637: GO 117663
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117639: LD_VAR 0 4
117643: PUSH
117644: LD_VAR 0 7
117648: ARRAY
117649: PPUSH
117650: LD_VAR 0 14
117654: PUSH
117655: LD_INT 1
117657: ARRAY
117658: PPUSH
117659: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117663: LD_VAR 0 4
117667: PUSH
117668: LD_VAR 0 7
117672: ARRAY
117673: PPUSH
117674: CALL_OW 314
117678: NOT
117679: IFFALSE 117717
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117681: LD_VAR 0 4
117685: PUSH
117686: LD_VAR 0 7
117690: ARRAY
117691: PPUSH
117692: LD_VAR 0 14
117696: PPUSH
117697: LD_VAR 0 4
117701: PUSH
117702: LD_VAR 0 7
117706: ARRAY
117707: PPUSH
117708: CALL_OW 74
117712: PPUSH
117713: CALL_OW 115
// end ; end ; end ;
117717: GO 113596
117719: POP
117720: POP
// wait ( 0 0$2 ) ;
117721: LD_INT 70
117723: PPUSH
117724: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117728: LD_VAR 0 4
117732: NOT
117733: PUSH
117734: LD_VAR 0 4
117738: PUSH
117739: EMPTY
117740: EQUAL
117741: OR
117742: PUSH
117743: LD_INT 81
117745: PUSH
117746: LD_VAR 0 35
117750: PUSH
117751: EMPTY
117752: LIST
117753: LIST
117754: PPUSH
117755: CALL_OW 69
117759: NOT
117760: OR
117761: IFFALSE 113581
// end ;
117763: LD_VAR 0 2
117767: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
117768: LD_INT 0
117770: PPUSH
117771: PPUSH
117772: PPUSH
117773: PPUSH
117774: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
117775: LD_VAR 0 1
117779: NOT
117780: PUSH
117781: LD_EXP 111
117785: PUSH
117786: LD_VAR 0 1
117790: ARRAY
117791: NOT
117792: OR
117793: PUSH
117794: LD_VAR 0 2
117798: NOT
117799: OR
117800: PUSH
117801: LD_VAR 0 3
117805: NOT
117806: OR
117807: IFFALSE 117811
// exit ;
117809: GO 118324
// side := mc_sides [ base ] ;
117811: LD_ADDR_VAR 0 6
117815: PUSH
117816: LD_EXP 137
117820: PUSH
117821: LD_VAR 0 1
117825: ARRAY
117826: ST_TO_ADDR
// if not side then
117827: LD_VAR 0 6
117831: NOT
117832: IFFALSE 117836
// exit ;
117834: GO 118324
// for i in solds do
117836: LD_ADDR_VAR 0 7
117840: PUSH
117841: LD_VAR 0 2
117845: PUSH
117846: FOR_IN
117847: IFFALSE 117908
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117849: LD_VAR 0 7
117853: PPUSH
117854: CALL_OW 310
117858: PPUSH
117859: CALL_OW 266
117863: PUSH
117864: LD_INT 32
117866: PUSH
117867: LD_INT 31
117869: PUSH
117870: EMPTY
117871: LIST
117872: LIST
117873: IN
117874: IFFALSE 117894
// solds := solds diff i else
117876: LD_ADDR_VAR 0 2
117880: PUSH
117881: LD_VAR 0 2
117885: PUSH
117886: LD_VAR 0 7
117890: DIFF
117891: ST_TO_ADDR
117892: GO 117906
// SetTag ( i , 18 ) ;
117894: LD_VAR 0 7
117898: PPUSH
117899: LD_INT 18
117901: PPUSH
117902: CALL_OW 109
117906: GO 117846
117908: POP
117909: POP
// if not solds then
117910: LD_VAR 0 2
117914: NOT
117915: IFFALSE 117919
// exit ;
117917: GO 118324
// repeat wait ( 0 0$1 ) ;
117919: LD_INT 35
117921: PPUSH
117922: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
117926: LD_ADDR_VAR 0 5
117930: PUSH
117931: LD_VAR 0 6
117935: PPUSH
117936: LD_VAR 0 3
117940: PPUSH
117941: CALL 66831 0 2
117945: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117946: LD_EXP 111
117950: PUSH
117951: LD_VAR 0 1
117955: ARRAY
117956: NOT
117957: PUSH
117958: LD_EXP 111
117962: PUSH
117963: LD_VAR 0 1
117967: ARRAY
117968: PUSH
117969: EMPTY
117970: EQUAL
117971: OR
117972: IFFALSE 118009
// begin for i in solds do
117974: LD_ADDR_VAR 0 7
117978: PUSH
117979: LD_VAR 0 2
117983: PUSH
117984: FOR_IN
117985: IFFALSE 117998
// ComStop ( i ) ;
117987: LD_VAR 0 7
117991: PPUSH
117992: CALL_OW 141
117996: GO 117984
117998: POP
117999: POP
// solds := [ ] ;
118000: LD_ADDR_VAR 0 2
118004: PUSH
118005: EMPTY
118006: ST_TO_ADDR
// exit ;
118007: GO 118324
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
118009: LD_VAR 0 5
118013: NOT
118014: PUSH
118015: LD_VAR 0 5
118019: PUSH
118020: LD_INT 3
118022: GREATER
118023: OR
118024: PUSH
118025: LD_EXP 133
118029: PUSH
118030: LD_VAR 0 1
118034: ARRAY
118035: OR
118036: IFFALSE 118077
// begin for i in solds do
118038: LD_ADDR_VAR 0 7
118042: PUSH
118043: LD_VAR 0 2
118047: PUSH
118048: FOR_IN
118049: IFFALSE 118073
// if HasTask ( i ) then
118051: LD_VAR 0 7
118055: PPUSH
118056: CALL_OW 314
118060: IFFALSE 118071
// ComStop ( i ) ;
118062: LD_VAR 0 7
118066: PPUSH
118067: CALL_OW 141
118071: GO 118048
118073: POP
118074: POP
// break ;
118075: GO 118312
// end ; for i in solds do
118077: LD_ADDR_VAR 0 7
118081: PUSH
118082: LD_VAR 0 2
118086: PUSH
118087: FOR_IN
118088: IFFALSE 118304
// begin if IsInUnit ( i ) then
118090: LD_VAR 0 7
118094: PPUSH
118095: CALL_OW 310
118099: IFFALSE 118110
// ComExitBuilding ( i ) ;
118101: LD_VAR 0 7
118105: PPUSH
118106: CALL_OW 122
// if GetLives ( i ) > 333 then
118110: LD_VAR 0 7
118114: PPUSH
118115: CALL_OW 256
118119: PUSH
118120: LD_INT 333
118122: GREATER
118123: IFFALSE 118151
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
118125: LD_VAR 0 7
118129: PPUSH
118130: LD_VAR 0 5
118134: PPUSH
118135: LD_VAR 0 7
118139: PPUSH
118140: CALL_OW 74
118144: PPUSH
118145: CALL_OW 115
118149: GO 118302
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118151: LD_ADDR_VAR 0 8
118155: PUSH
118156: LD_EXP 111
118160: PUSH
118161: LD_VAR 0 1
118165: ARRAY
118166: PPUSH
118167: LD_INT 2
118169: PUSH
118170: LD_INT 30
118172: PUSH
118173: LD_INT 0
118175: PUSH
118176: EMPTY
118177: LIST
118178: LIST
118179: PUSH
118180: LD_INT 30
118182: PUSH
118183: LD_INT 1
118185: PUSH
118186: EMPTY
118187: LIST
118188: LIST
118189: PUSH
118190: LD_INT 30
118192: PUSH
118193: LD_INT 6
118195: PUSH
118196: EMPTY
118197: LIST
118198: LIST
118199: PUSH
118200: EMPTY
118201: LIST
118202: LIST
118203: LIST
118204: LIST
118205: PPUSH
118206: CALL_OW 72
118210: PPUSH
118211: LD_VAR 0 7
118215: PPUSH
118216: CALL_OW 74
118220: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118221: LD_VAR 0 7
118225: PPUSH
118226: LD_VAR 0 8
118230: PPUSH
118231: CALL_OW 250
118235: PPUSH
118236: LD_INT 3
118238: PPUSH
118239: LD_INT 5
118241: PPUSH
118242: CALL_OW 272
118246: PPUSH
118247: LD_VAR 0 8
118251: PPUSH
118252: CALL_OW 251
118256: PPUSH
118257: LD_INT 3
118259: PPUSH
118260: LD_INT 5
118262: PPUSH
118263: CALL_OW 273
118267: PPUSH
118268: CALL_OW 111
// SetTag ( i , 0 ) ;
118272: LD_VAR 0 7
118276: PPUSH
118277: LD_INT 0
118279: PPUSH
118280: CALL_OW 109
// solds := solds diff i ;
118284: LD_ADDR_VAR 0 2
118288: PUSH
118289: LD_VAR 0 2
118293: PUSH
118294: LD_VAR 0 7
118298: DIFF
118299: ST_TO_ADDR
// continue ;
118300: GO 118087
// end ; end ;
118302: GO 118087
118304: POP
118305: POP
// until solds ;
118306: LD_VAR 0 2
118310: IFFALSE 117919
// MC_Reset ( base , 18 ) ;
118312: LD_VAR 0 1
118316: PPUSH
118317: LD_INT 18
118319: PPUSH
118320: CALL 39139 0 2
// end ;
118324: LD_VAR 0 4
118328: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
118329: LD_INT 0
118331: PPUSH
118332: PPUSH
118333: PPUSH
118334: PPUSH
118335: PPUSH
118336: PPUSH
118337: PPUSH
118338: PPUSH
118339: PPUSH
118340: PPUSH
118341: PPUSH
118342: PPUSH
118343: PPUSH
118344: PPUSH
118345: PPUSH
118346: PPUSH
118347: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118348: LD_ADDR_VAR 0 13
118352: PUSH
118353: LD_EXP 111
118357: PUSH
118358: LD_VAR 0 1
118362: ARRAY
118363: PPUSH
118364: LD_INT 25
118366: PUSH
118367: LD_INT 3
118369: PUSH
118370: EMPTY
118371: LIST
118372: LIST
118373: PPUSH
118374: CALL_OW 72
118378: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118379: LD_EXP 151
118383: PUSH
118384: LD_VAR 0 1
118388: ARRAY
118389: IFFALSE 118413
// mechs := mechs diff mc_remote_driver [ base ] ;
118391: LD_ADDR_VAR 0 13
118395: PUSH
118396: LD_VAR 0 13
118400: PUSH
118401: LD_EXP 151
118405: PUSH
118406: LD_VAR 0 1
118410: ARRAY
118411: DIFF
118412: ST_TO_ADDR
// for i in mechs do
118413: LD_ADDR_VAR 0 5
118417: PUSH
118418: LD_VAR 0 13
118422: PUSH
118423: FOR_IN
118424: IFFALSE 118459
// if GetTag ( i ) > 0 then
118426: LD_VAR 0 5
118430: PPUSH
118431: CALL_OW 110
118435: PUSH
118436: LD_INT 0
118438: GREATER
118439: IFFALSE 118457
// mechs := mechs diff i ;
118441: LD_ADDR_VAR 0 13
118445: PUSH
118446: LD_VAR 0 13
118450: PUSH
118451: LD_VAR 0 5
118455: DIFF
118456: ST_TO_ADDR
118457: GO 118423
118459: POP
118460: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118461: LD_ADDR_VAR 0 9
118465: PUSH
118466: LD_EXP 111
118470: PUSH
118471: LD_VAR 0 1
118475: ARRAY
118476: PPUSH
118477: LD_INT 2
118479: PUSH
118480: LD_INT 25
118482: PUSH
118483: LD_INT 1
118485: PUSH
118486: EMPTY
118487: LIST
118488: LIST
118489: PUSH
118490: LD_INT 25
118492: PUSH
118493: LD_INT 5
118495: PUSH
118496: EMPTY
118497: LIST
118498: LIST
118499: PUSH
118500: LD_INT 25
118502: PUSH
118503: LD_INT 8
118505: PUSH
118506: EMPTY
118507: LIST
118508: LIST
118509: PUSH
118510: LD_INT 25
118512: PUSH
118513: LD_INT 9
118515: PUSH
118516: EMPTY
118517: LIST
118518: LIST
118519: PUSH
118520: EMPTY
118521: LIST
118522: LIST
118523: LIST
118524: LIST
118525: LIST
118526: PPUSH
118527: CALL_OW 72
118531: ST_TO_ADDR
// if not defenders and not solds then
118532: LD_VAR 0 2
118536: NOT
118537: PUSH
118538: LD_VAR 0 9
118542: NOT
118543: AND
118544: IFFALSE 118548
// exit ;
118546: GO 120174
// depot_under_attack := false ;
118548: LD_ADDR_VAR 0 17
118552: PUSH
118553: LD_INT 0
118555: ST_TO_ADDR
// sold_defenders := [ ] ;
118556: LD_ADDR_VAR 0 18
118560: PUSH
118561: EMPTY
118562: ST_TO_ADDR
// if mechs then
118563: LD_VAR 0 13
118567: IFFALSE 118696
// for i in defenders do
118569: LD_ADDR_VAR 0 5
118573: PUSH
118574: LD_VAR 0 2
118578: PUSH
118579: FOR_IN
118580: IFFALSE 118694
// begin SetTag ( i , 20 ) ;
118582: LD_VAR 0 5
118586: PPUSH
118587: LD_INT 20
118589: PPUSH
118590: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
118594: LD_VAR 0 5
118598: PPUSH
118599: CALL_OW 263
118603: PUSH
118604: LD_INT 1
118606: EQUAL
118607: PUSH
118608: LD_VAR 0 5
118612: PPUSH
118613: CALL_OW 311
118617: NOT
118618: AND
118619: PUSH
118620: LD_VAR 0 13
118624: AND
118625: IFFALSE 118692
// begin un := mechs [ 1 ] ;
118627: LD_ADDR_VAR 0 11
118631: PUSH
118632: LD_VAR 0 13
118636: PUSH
118637: LD_INT 1
118639: ARRAY
118640: ST_TO_ADDR
// ComExitBuilding ( un ) ;
118641: LD_VAR 0 11
118645: PPUSH
118646: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
118650: LD_VAR 0 11
118654: PPUSH
118655: LD_VAR 0 5
118659: PPUSH
118660: CALL_OW 180
// SetTag ( un , 19 ) ;
118664: LD_VAR 0 11
118668: PPUSH
118669: LD_INT 19
118671: PPUSH
118672: CALL_OW 109
// mechs := mechs diff un ;
118676: LD_ADDR_VAR 0 13
118680: PUSH
118681: LD_VAR 0 13
118685: PUSH
118686: LD_VAR 0 11
118690: DIFF
118691: ST_TO_ADDR
// end ; end ;
118692: GO 118579
118694: POP
118695: POP
// if solds then
118696: LD_VAR 0 9
118700: IFFALSE 118759
// for i in solds do
118702: LD_ADDR_VAR 0 5
118706: PUSH
118707: LD_VAR 0 9
118711: PUSH
118712: FOR_IN
118713: IFFALSE 118757
// if not GetTag ( i ) then
118715: LD_VAR 0 5
118719: PPUSH
118720: CALL_OW 110
118724: NOT
118725: IFFALSE 118755
// begin defenders := defenders union i ;
118727: LD_ADDR_VAR 0 2
118731: PUSH
118732: LD_VAR 0 2
118736: PUSH
118737: LD_VAR 0 5
118741: UNION
118742: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118743: LD_VAR 0 5
118747: PPUSH
118748: LD_INT 18
118750: PPUSH
118751: CALL_OW 109
// end ;
118755: GO 118712
118757: POP
118758: POP
// repeat wait ( 0 0$1 ) ;
118759: LD_INT 35
118761: PPUSH
118762: CALL_OW 67
// enemy := mc_scan [ base ] ;
118766: LD_ADDR_VAR 0 3
118770: PUSH
118771: LD_EXP 134
118775: PUSH
118776: LD_VAR 0 1
118780: ARRAY
118781: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118782: LD_EXP 111
118786: PUSH
118787: LD_VAR 0 1
118791: ARRAY
118792: NOT
118793: PUSH
118794: LD_EXP 111
118798: PUSH
118799: LD_VAR 0 1
118803: ARRAY
118804: PUSH
118805: EMPTY
118806: EQUAL
118807: OR
118808: IFFALSE 118845
// begin for i in defenders do
118810: LD_ADDR_VAR 0 5
118814: PUSH
118815: LD_VAR 0 2
118819: PUSH
118820: FOR_IN
118821: IFFALSE 118834
// ComStop ( i ) ;
118823: LD_VAR 0 5
118827: PPUSH
118828: CALL_OW 141
118832: GO 118820
118834: POP
118835: POP
// defenders := [ ] ;
118836: LD_ADDR_VAR 0 2
118840: PUSH
118841: EMPTY
118842: ST_TO_ADDR
// exit ;
118843: GO 120174
// end ; for i in defenders do
118845: LD_ADDR_VAR 0 5
118849: PUSH
118850: LD_VAR 0 2
118854: PUSH
118855: FOR_IN
118856: IFFALSE 119674
// begin e := NearestUnitToUnit ( enemy , i ) ;
118858: LD_ADDR_VAR 0 14
118862: PUSH
118863: LD_VAR 0 3
118867: PPUSH
118868: LD_VAR 0 5
118872: PPUSH
118873: CALL_OW 74
118877: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118878: LD_ADDR_VAR 0 8
118882: PUSH
118883: LD_EXP 111
118887: PUSH
118888: LD_VAR 0 1
118892: ARRAY
118893: PPUSH
118894: LD_INT 2
118896: PUSH
118897: LD_INT 30
118899: PUSH
118900: LD_INT 0
118902: PUSH
118903: EMPTY
118904: LIST
118905: LIST
118906: PUSH
118907: LD_INT 30
118909: PUSH
118910: LD_INT 1
118912: PUSH
118913: EMPTY
118914: LIST
118915: LIST
118916: PUSH
118917: EMPTY
118918: LIST
118919: LIST
118920: LIST
118921: PPUSH
118922: CALL_OW 72
118926: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118927: LD_ADDR_VAR 0 17
118931: PUSH
118932: LD_VAR 0 8
118936: NOT
118937: PUSH
118938: LD_VAR 0 8
118942: PPUSH
118943: LD_INT 3
118945: PUSH
118946: LD_INT 24
118948: PUSH
118949: LD_INT 600
118951: PUSH
118952: EMPTY
118953: LIST
118954: LIST
118955: PUSH
118956: EMPTY
118957: LIST
118958: LIST
118959: PPUSH
118960: CALL_OW 72
118964: OR
118965: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118966: LD_VAR 0 5
118970: PPUSH
118971: CALL_OW 247
118975: PUSH
118976: LD_INT 2
118978: DOUBLE
118979: EQUAL
118980: IFTRUE 118984
118982: GO 119380
118984: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118985: LD_VAR 0 5
118989: PPUSH
118990: CALL_OW 256
118994: PUSH
118995: LD_INT 650
118997: GREATER
118998: PUSH
118999: LD_VAR 0 5
119003: PPUSH
119004: LD_VAR 0 14
119008: PPUSH
119009: CALL_OW 296
119013: PUSH
119014: LD_INT 40
119016: LESS
119017: PUSH
119018: LD_VAR 0 14
119022: PPUSH
119023: LD_EXP 136
119027: PUSH
119028: LD_VAR 0 1
119032: ARRAY
119033: PPUSH
119034: CALL_OW 308
119038: OR
119039: AND
119040: IFFALSE 119162
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119042: LD_VAR 0 5
119046: PPUSH
119047: CALL_OW 262
119051: PUSH
119052: LD_INT 1
119054: EQUAL
119055: PUSH
119056: LD_VAR 0 5
119060: PPUSH
119061: CALL_OW 261
119065: PUSH
119066: LD_INT 30
119068: LESS
119069: AND
119070: PUSH
119071: LD_VAR 0 8
119075: AND
119076: IFFALSE 119146
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119078: LD_VAR 0 5
119082: PPUSH
119083: LD_VAR 0 8
119087: PPUSH
119088: LD_VAR 0 5
119092: PPUSH
119093: CALL_OW 74
119097: PPUSH
119098: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119102: LD_VAR 0 5
119106: PPUSH
119107: LD_VAR 0 8
119111: PPUSH
119112: LD_VAR 0 5
119116: PPUSH
119117: CALL_OW 74
119121: PPUSH
119122: CALL_OW 296
119126: PUSH
119127: LD_INT 6
119129: LESS
119130: IFFALSE 119144
// SetFuel ( i , 100 ) ;
119132: LD_VAR 0 5
119136: PPUSH
119137: LD_INT 100
119139: PPUSH
119140: CALL_OW 240
// end else
119144: GO 119160
// ComAttackUnit ( i , e ) ;
119146: LD_VAR 0 5
119150: PPUSH
119151: LD_VAR 0 14
119155: PPUSH
119156: CALL_OW 115
// end else
119160: GO 119263
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119162: LD_VAR 0 14
119166: PPUSH
119167: LD_EXP 136
119171: PUSH
119172: LD_VAR 0 1
119176: ARRAY
119177: PPUSH
119178: CALL_OW 308
119182: NOT
119183: PUSH
119184: LD_VAR 0 5
119188: PPUSH
119189: LD_VAR 0 14
119193: PPUSH
119194: CALL_OW 296
119198: PUSH
119199: LD_INT 40
119201: GREATEREQUAL
119202: AND
119203: PUSH
119204: LD_VAR 0 5
119208: PPUSH
119209: CALL_OW 256
119213: PUSH
119214: LD_INT 650
119216: LESSEQUAL
119217: OR
119218: PUSH
119219: LD_VAR 0 5
119223: PPUSH
119224: LD_EXP 135
119228: PUSH
119229: LD_VAR 0 1
119233: ARRAY
119234: PPUSH
119235: CALL_OW 308
119239: NOT
119240: AND
119241: IFFALSE 119263
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119243: LD_VAR 0 5
119247: PPUSH
119248: LD_EXP 135
119252: PUSH
119253: LD_VAR 0 1
119257: ARRAY
119258: PPUSH
119259: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119263: LD_VAR 0 5
119267: PPUSH
119268: CALL_OW 256
119272: PUSH
119273: LD_INT 998
119275: LESS
119276: PUSH
119277: LD_VAR 0 5
119281: PPUSH
119282: CALL_OW 263
119286: PUSH
119287: LD_INT 1
119289: EQUAL
119290: AND
119291: PUSH
119292: LD_VAR 0 5
119296: PPUSH
119297: CALL_OW 311
119301: AND
119302: PUSH
119303: LD_VAR 0 5
119307: PPUSH
119308: LD_EXP 135
119312: PUSH
119313: LD_VAR 0 1
119317: ARRAY
119318: PPUSH
119319: CALL_OW 308
119323: AND
119324: IFFALSE 119378
// begin mech := IsDrivenBy ( i ) ;
119326: LD_ADDR_VAR 0 10
119330: PUSH
119331: LD_VAR 0 5
119335: PPUSH
119336: CALL_OW 311
119340: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119341: LD_VAR 0 10
119345: PPUSH
119346: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119350: LD_VAR 0 10
119354: PPUSH
119355: LD_VAR 0 5
119359: PPUSH
119360: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119364: LD_VAR 0 10
119368: PPUSH
119369: LD_VAR 0 5
119373: PPUSH
119374: CALL_OW 180
// end ; end ; unit_human :
119378: GO 119645
119380: LD_INT 1
119382: DOUBLE
119383: EQUAL
119384: IFTRUE 119388
119386: GO 119644
119388: POP
// begin b := IsInUnit ( i ) ;
119389: LD_ADDR_VAR 0 19
119393: PUSH
119394: LD_VAR 0 5
119398: PPUSH
119399: CALL_OW 310
119403: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119404: LD_ADDR_VAR 0 20
119408: PUSH
119409: LD_VAR 0 19
119413: NOT
119414: PUSH
119415: LD_VAR 0 19
119419: PPUSH
119420: CALL_OW 266
119424: PUSH
119425: LD_INT 32
119427: PUSH
119428: LD_INT 31
119430: PUSH
119431: EMPTY
119432: LIST
119433: LIST
119434: IN
119435: OR
119436: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119437: LD_VAR 0 17
119441: PUSH
119442: LD_VAR 0 2
119446: PPUSH
119447: LD_INT 21
119449: PUSH
119450: LD_INT 2
119452: PUSH
119453: EMPTY
119454: LIST
119455: LIST
119456: PPUSH
119457: CALL_OW 72
119461: PUSH
119462: LD_INT 1
119464: LESSEQUAL
119465: OR
119466: PUSH
119467: LD_VAR 0 20
119471: AND
119472: PUSH
119473: LD_VAR 0 5
119477: PUSH
119478: LD_VAR 0 18
119482: IN
119483: NOT
119484: AND
119485: IFFALSE 119578
// begin if b then
119487: LD_VAR 0 19
119491: IFFALSE 119540
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119493: LD_VAR 0 19
119497: PPUSH
119498: LD_VAR 0 3
119502: PPUSH
119503: LD_VAR 0 19
119507: PPUSH
119508: CALL_OW 74
119512: PPUSH
119513: CALL_OW 296
119517: PUSH
119518: LD_INT 10
119520: LESS
119521: PUSH
119522: LD_VAR 0 19
119526: PPUSH
119527: CALL_OW 461
119531: PUSH
119532: LD_INT 7
119534: NONEQUAL
119535: AND
119536: IFFALSE 119540
// continue ;
119538: GO 118855
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119540: LD_ADDR_VAR 0 18
119544: PUSH
119545: LD_VAR 0 18
119549: PPUSH
119550: LD_VAR 0 18
119554: PUSH
119555: LD_INT 1
119557: PLUS
119558: PPUSH
119559: LD_VAR 0 5
119563: PPUSH
119564: CALL_OW 1
119568: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119569: LD_VAR 0 5
119573: PPUSH
119574: CALL_OW 122
// end ; if sold_defenders then
119578: LD_VAR 0 18
119582: IFFALSE 119642
// if i in sold_defenders then
119584: LD_VAR 0 5
119588: PUSH
119589: LD_VAR 0 18
119593: IN
119594: IFFALSE 119642
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119596: LD_VAR 0 5
119600: PPUSH
119601: CALL_OW 314
119605: NOT
119606: PUSH
119607: LD_VAR 0 5
119611: PPUSH
119612: LD_VAR 0 14
119616: PPUSH
119617: CALL_OW 296
119621: PUSH
119622: LD_INT 30
119624: LESS
119625: AND
119626: IFFALSE 119642
// ComAttackUnit ( i , e ) ;
119628: LD_VAR 0 5
119632: PPUSH
119633: LD_VAR 0 14
119637: PPUSH
119638: CALL_OW 115
// end ; end ; end ;
119642: GO 119645
119644: POP
// if IsDead ( i ) then
119645: LD_VAR 0 5
119649: PPUSH
119650: CALL_OW 301
119654: IFFALSE 119672
// defenders := defenders diff i ;
119656: LD_ADDR_VAR 0 2
119660: PUSH
119661: LD_VAR 0 2
119665: PUSH
119666: LD_VAR 0 5
119670: DIFF
119671: ST_TO_ADDR
// end ;
119672: GO 118855
119674: POP
119675: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119676: LD_VAR 0 3
119680: NOT
119681: PUSH
119682: LD_VAR 0 2
119686: NOT
119687: OR
119688: PUSH
119689: LD_EXP 111
119693: PUSH
119694: LD_VAR 0 1
119698: ARRAY
119699: NOT
119700: OR
119701: IFFALSE 118759
// MC_Reset ( base , 18 ) ;
119703: LD_VAR 0 1
119707: PPUSH
119708: LD_INT 18
119710: PPUSH
119711: CALL 39139 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119715: LD_ADDR_VAR 0 2
119719: PUSH
119720: LD_VAR 0 2
119724: PUSH
119725: LD_VAR 0 2
119729: PPUSH
119730: LD_INT 2
119732: PUSH
119733: LD_INT 25
119735: PUSH
119736: LD_INT 1
119738: PUSH
119739: EMPTY
119740: LIST
119741: LIST
119742: PUSH
119743: LD_INT 25
119745: PUSH
119746: LD_INT 5
119748: PUSH
119749: EMPTY
119750: LIST
119751: LIST
119752: PUSH
119753: LD_INT 25
119755: PUSH
119756: LD_INT 8
119758: PUSH
119759: EMPTY
119760: LIST
119761: LIST
119762: PUSH
119763: LD_INT 25
119765: PUSH
119766: LD_INT 9
119768: PUSH
119769: EMPTY
119770: LIST
119771: LIST
119772: PUSH
119773: EMPTY
119774: LIST
119775: LIST
119776: LIST
119777: LIST
119778: LIST
119779: PPUSH
119780: CALL_OW 72
119784: DIFF
119785: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119786: LD_VAR 0 3
119790: NOT
119791: PUSH
119792: LD_VAR 0 2
119796: PPUSH
119797: LD_INT 21
119799: PUSH
119800: LD_INT 2
119802: PUSH
119803: EMPTY
119804: LIST
119805: LIST
119806: PPUSH
119807: CALL_OW 72
119811: AND
119812: IFFALSE 120150
// begin tmp := FilterByTag ( defenders , 19 ) ;
119814: LD_ADDR_VAR 0 12
119818: PUSH
119819: LD_VAR 0 2
119823: PPUSH
119824: LD_INT 19
119826: PPUSH
119827: CALL 98591 0 2
119831: ST_TO_ADDR
// if tmp then
119832: LD_VAR 0 12
119836: IFFALSE 119906
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119838: LD_ADDR_VAR 0 12
119842: PUSH
119843: LD_VAR 0 12
119847: PPUSH
119848: LD_INT 25
119850: PUSH
119851: LD_INT 3
119853: PUSH
119854: EMPTY
119855: LIST
119856: LIST
119857: PPUSH
119858: CALL_OW 72
119862: ST_TO_ADDR
// if tmp then
119863: LD_VAR 0 12
119867: IFFALSE 119906
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119869: LD_ADDR_EXP 123
119873: PUSH
119874: LD_EXP 123
119878: PPUSH
119879: LD_VAR 0 1
119883: PPUSH
119884: LD_EXP 123
119888: PUSH
119889: LD_VAR 0 1
119893: ARRAY
119894: PUSH
119895: LD_VAR 0 12
119899: UNION
119900: PPUSH
119901: CALL_OW 1
119905: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119906: LD_VAR 0 1
119910: PPUSH
119911: LD_INT 19
119913: PPUSH
119914: CALL 39139 0 2
// repeat wait ( 0 0$1 ) ;
119918: LD_INT 35
119920: PPUSH
119921: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119925: LD_EXP 111
119929: PUSH
119930: LD_VAR 0 1
119934: ARRAY
119935: NOT
119936: PUSH
119937: LD_EXP 111
119941: PUSH
119942: LD_VAR 0 1
119946: ARRAY
119947: PUSH
119948: EMPTY
119949: EQUAL
119950: OR
119951: IFFALSE 119988
// begin for i in defenders do
119953: LD_ADDR_VAR 0 5
119957: PUSH
119958: LD_VAR 0 2
119962: PUSH
119963: FOR_IN
119964: IFFALSE 119977
// ComStop ( i ) ;
119966: LD_VAR 0 5
119970: PPUSH
119971: CALL_OW 141
119975: GO 119963
119977: POP
119978: POP
// defenders := [ ] ;
119979: LD_ADDR_VAR 0 2
119983: PUSH
119984: EMPTY
119985: ST_TO_ADDR
// exit ;
119986: GO 120174
// end ; for i in defenders do
119988: LD_ADDR_VAR 0 5
119992: PUSH
119993: LD_VAR 0 2
119997: PUSH
119998: FOR_IN
119999: IFFALSE 120088
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120001: LD_VAR 0 5
120005: PPUSH
120006: LD_EXP 135
120010: PUSH
120011: LD_VAR 0 1
120015: ARRAY
120016: PPUSH
120017: CALL_OW 308
120021: NOT
120022: IFFALSE 120046
// ComMoveToArea ( i , mc_parking [ base ] ) else
120024: LD_VAR 0 5
120028: PPUSH
120029: LD_EXP 135
120033: PUSH
120034: LD_VAR 0 1
120038: ARRAY
120039: PPUSH
120040: CALL_OW 113
120044: GO 120086
// if GetControl ( i ) = control_manual then
120046: LD_VAR 0 5
120050: PPUSH
120051: CALL_OW 263
120055: PUSH
120056: LD_INT 1
120058: EQUAL
120059: IFFALSE 120086
// if IsDrivenBy ( i ) then
120061: LD_VAR 0 5
120065: PPUSH
120066: CALL_OW 311
120070: IFFALSE 120086
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120072: LD_VAR 0 5
120076: PPUSH
120077: CALL_OW 311
120081: PPUSH
120082: CALL_OW 121
// end ;
120086: GO 119998
120088: POP
120089: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120090: LD_VAR 0 2
120094: PPUSH
120095: LD_INT 95
120097: PUSH
120098: LD_EXP 135
120102: PUSH
120103: LD_VAR 0 1
120107: ARRAY
120108: PUSH
120109: EMPTY
120110: LIST
120111: LIST
120112: PPUSH
120113: CALL_OW 72
120117: PUSH
120118: LD_VAR 0 2
120122: EQUAL
120123: PUSH
120124: LD_EXP 134
120128: PUSH
120129: LD_VAR 0 1
120133: ARRAY
120134: OR
120135: PUSH
120136: LD_EXP 111
120140: PUSH
120141: LD_VAR 0 1
120145: ARRAY
120146: NOT
120147: OR
120148: IFFALSE 119918
// end ; MC_Reset ( base , 19 ) ;
120150: LD_VAR 0 1
120154: PPUSH
120155: LD_INT 19
120157: PPUSH
120158: CALL 39139 0 2
// MC_Reset ( base , 20 ) ;
120162: LD_VAR 0 1
120166: PPUSH
120167: LD_INT 20
120169: PPUSH
120170: CALL 39139 0 2
// end ;
120174: LD_VAR 0 4
120178: RET
