// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33752 0 0
// InitNature ;
  19: CALL 33576 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10843 0 0
// PrepareRussian ;
  40: CALL 6836 0 0
// PrepareLegion ;
  44: CALL 4076 0 0
// PreparePowell ;
  48: CALL 2830 0 0
// PrepareAmerican ;
  52: CALL 1602 0 0
// Action ;
  56: CALL 14750 0 0
// MC_Start ( ) ;
  60: CALL 35864 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 57604 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 57697 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57110 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 56925 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 57604 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 57697 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 24
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 47
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 24
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 47
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 56925 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 802: LD_INT 2
 804: PPUSH
 805: LD_INT 5
 807: PPUSH
 808: CALL 57110 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 812: LD_INT 2
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL 57477 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 822: LD_INT 3
 824: PPUSH
 825: LD_INT 10
 827: PUSH
 828: LD_INT 12
 830: PUSH
 831: LD_INT 15
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: LIST
 838: PUSH
 839: LD_OWVAR 67
 843: ARRAY
 844: PPUSH
 845: LD_INT 27
 847: PPUSH
 848: CALL 56607 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 852: LD_INT 3
 854: PPUSH
 855: LD_INT 10
 857: PUSH
 858: LD_INT 11
 860: PUSH
 861: LD_INT 13
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL 57604 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 15
 882: PUSH
 883: EMPTY
 884: LIST
 885: PPUSH
 886: CALL 57697 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 890: LD_ADDR_EXP 128
 894: PUSH
 895: LD_EXP 128
 899: PPUSH
 900: LD_INT 3
 902: PPUSH
 903: LD_INT 22
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 25
 915: PUSH
 916: LD_INT 15
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL_OW 69
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 13
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 31
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 13
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 31
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 13
 978: PUSH
 979: LD_INT 3
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: LD_INT 32
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: LIST
 992: LIST
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: PPUSH
 999: CALL 56925 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1003: LD_INT 4
1005: PPUSH
1006: LD_INT 10
1008: PUSH
1009: LD_INT 12
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL 57604 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1020: LD_INT 4
1022: PPUSH
1023: LD_INT 9
1025: PUSH
1026: EMPTY
1027: LIST
1028: PPUSH
1029: CALL 57697 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1033: LD_INT 4
1035: PPUSH
1036: LD_INT 26
1038: PUSH
1039: LD_INT 74
1041: PUSH
1042: LD_INT 107
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: LD_INT 77
1059: PUSH
1060: LD_INT 101
1062: PUSH
1063: LD_INT 4
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_INT 32
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 86
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_INT 27
1092: PUSH
1093: LD_INT 77
1095: PUSH
1096: LD_INT 110
1098: PUSH
1099: LD_INT 3
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 27
1110: PUSH
1111: LD_INT 42
1113: PUSH
1114: LD_INT 79
1116: PUSH
1117: LD_INT 5
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 29
1128: PUSH
1129: LD_INT 86
1131: PUSH
1132: LD_INT 105
1134: PUSH
1135: LD_INT 2
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 30
1146: PUSH
1147: LD_INT 40
1149: PUSH
1150: LD_INT 75
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 80
1167: PUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: LD_INT 75
1185: PUSH
1186: LD_INT 114
1188: PUSH
1189: LD_INT 5
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 32
1200: PUSH
1201: LD_INT 82
1203: PUSH
1204: LD_INT 110
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 62
1221: PUSH
1222: LD_INT 78
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 4
1236: PUSH
1237: LD_INT 39
1239: PUSH
1240: LD_INT 61
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 56817 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 5
1275: PUSH
1276: LD_INT 6
1278: PUSH
1279: LD_INT 7
1281: PUSH
1282: LD_INT 9
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PPUSH
1291: CALL 58015 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 40
1300: PUSH
1301: LD_INT 75
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_INT 86
1314: PUSH
1315: LD_INT 105
1317: PUSH
1318: LD_INT 0
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL 57249 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 2
1339: PPUSH
1340: CALL 57477 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1344: LD_INT 4
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 57477 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 54
1359: PPUSH
1360: LD_INT 85
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: LD_INT 19
1368: PUSH
1369: LD_INT 16
1371: PUSH
1372: LD_INT 17
1374: PUSH
1375: LD_INT 18
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 57809 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 4
1411: PUSH
1412: LD_INT 1
1414: PUSH
1415: LD_INT 1
1417: PUSH
1418: LD_INT 6
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_INT 4
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 7
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 4
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PPUSH
1469: CALL 56925 0 2
// MC_SetTame ( 4 , powellApe ) ;
1473: LD_INT 4
1475: PPUSH
1476: LD_INT 13
1478: PPUSH
1479: CALL 57428 0 2
// end ;
1483: LD_VAR 0 1
1487: RET
// every 0 0$1 trigger debug do var i , tmp ;
1488: LD_EXP 1
1492: IFFALSE 1599
1494: GO 1496
1496: DISABLE
1497: LD_INT 0
1499: PPUSH
1500: PPUSH
// begin enable ;
1501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1502: LD_ADDR_VAR 0 2
1506: PUSH
1507: LD_INT 22
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 21
1522: PUSH
1523: LD_INT 3
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 3
1536: PUSH
1537: LD_INT 24
1539: PUSH
1540: LD_INT 999
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PPUSH
1556: CALL_OW 69
1560: ST_TO_ADDR
// if not tmp then
1561: LD_VAR 0 2
1565: NOT
1566: IFFALSE 1570
// exit ;
1568: GO 1599
// for i in tmp do
1570: LD_ADDR_VAR 0 1
1574: PUSH
1575: LD_VAR 0 2
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1597
// SetLives ( i , 1000 ) ;
1583: LD_VAR 0 1
1587: PPUSH
1588: LD_INT 1000
1590: PPUSH
1591: CALL_OW 234
1595: GO 1580
1597: POP
1598: POP
// end ; end_of_file
1599: PPOPN 2
1601: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1602: LD_INT 0
1604: PPUSH
// uc_side := 1 ;
1605: LD_ADDR_OWVAR 20
1609: PUSH
1610: LD_INT 1
1612: ST_TO_ADDR
// uc_nation := 1 ;
1613: LD_ADDR_OWVAR 21
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1621: LD_ADDR_EXP 36
1625: PUSH
1626: LD_STRING JMM
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 14_
1637: PPUSH
1638: CALL 62975 0 3
1642: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1643: LD_EXP 4
1647: NOT
1648: PUSH
1649: LD_EXP 4
1653: PUSH
1654: LD_INT 1
1656: ARRAY
1657: PUSH
1658: LD_INT 1
1660: ARRAY
1661: NOT
1662: OR
1663: IFFALSE 1686
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 1
1673: PPUSH
1674: LD_INT 5
1676: PPUSH
1677: LD_INT 100
1679: PPUSH
1680: CALL 69586 0 5
1684: GO 1745
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1686: LD_EXP 4
1690: PUSH
1691: LD_INT 1
1693: ARRAY
1694: PUSH
1695: LD_INT 1
1697: ARRAY
1698: PPUSH
1699: LD_EXP 4
1703: PUSH
1704: LD_INT 2
1706: ARRAY
1707: PUSH
1708: LD_INT 1
1710: ARRAY
1711: PPUSH
1712: LD_EXP 4
1716: PUSH
1717: LD_INT 3
1719: ARRAY
1720: PUSH
1721: LD_INT 1
1723: ARRAY
1724: PPUSH
1725: LD_EXP 4
1729: PUSH
1730: LD_INT 4
1732: ARRAY
1733: PUSH
1734: LD_INT 1
1736: ARRAY
1737: PPUSH
1738: LD_INT 30
1740: PPUSH
1741: CALL 69586 0 5
// JMMNewVeh := CreateVehicle ;
1745: LD_ADDR_EXP 53
1749: PUSH
1750: CALL_OW 45
1754: ST_TO_ADDR
// if not JMMNewVeh then
1755: LD_EXP 53
1759: NOT
1760: IFFALSE 1791
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1762: LD_INT 3
1764: PPUSH
1765: LD_INT 3
1767: PPUSH
1768: LD_INT 1
1770: PPUSH
1771: LD_INT 5
1773: PPUSH
1774: LD_INT 100
1776: PPUSH
1777: CALL 69586 0 5
// JMMNewVeh := CreateVehicle ;
1781: LD_ADDR_EXP 53
1785: PUSH
1786: CALL_OW 45
1790: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1791: LD_EXP 53
1795: PPUSH
1796: LD_INT 4
1798: PPUSH
1799: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1803: LD_EXP 53
1807: PPUSH
1808: LD_INT 79
1810: PPUSH
1811: LD_INT 91
1813: PPUSH
1814: LD_INT 0
1816: PPUSH
1817: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1821: LD_EXP 36
1825: PPUSH
1826: LD_EXP 53
1830: PPUSH
1831: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1835: LD_EXP 6
1839: PUSH
1840: LD_EXP 2
1844: NOT
1845: AND
1846: IFFALSE 2104
// begin if not JMMGirlVeh then
1848: LD_EXP 5
1852: NOT
1853: IFFALSE 1876
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1855: LD_INT 3
1857: PPUSH
1858: LD_INT 3
1860: PPUSH
1861: LD_INT 1
1863: PPUSH
1864: LD_INT 9
1866: PPUSH
1867: LD_INT 100
1869: PPUSH
1870: CALL 69586 0 5
1874: GO 1935
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1876: LD_EXP 5
1880: PUSH
1881: LD_INT 1
1883: ARRAY
1884: PUSH
1885: LD_INT 1
1887: ARRAY
1888: PPUSH
1889: LD_EXP 5
1893: PUSH
1894: LD_INT 2
1896: ARRAY
1897: PUSH
1898: LD_INT 1
1900: ARRAY
1901: PPUSH
1902: LD_EXP 5
1906: PUSH
1907: LD_INT 3
1909: ARRAY
1910: PUSH
1911: LD_INT 1
1913: ARRAY
1914: PPUSH
1915: LD_EXP 5
1919: PUSH
1920: LD_INT 4
1922: ARRAY
1923: PUSH
1924: LD_INT 1
1926: ARRAY
1927: PPUSH
1928: LD_INT 30
1930: PPUSH
1931: CALL 69586 0 5
// GirlNewVeh := CreateVehicle ;
1935: LD_ADDR_EXP 54
1939: PUSH
1940: CALL_OW 45
1944: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1945: LD_EXP 54
1949: PPUSH
1950: LD_INT 4
1952: PPUSH
1953: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1957: LD_EXP 54
1961: PPUSH
1962: LD_INT 82
1964: PPUSH
1965: LD_INT 96
1967: PPUSH
1968: LD_INT 0
1970: PPUSH
1971: CALL_OW 48
// if JMMGirl = 1 then
1975: LD_EXP 7
1979: PUSH
1980: LD_INT 1
1982: EQUAL
1983: IFFALSE 2018
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1985: LD_ADDR_EXP 37
1989: PUSH
1990: LD_STRING Joan
1992: PPUSH
1993: LD_INT 1
1995: PPUSH
1996: LD_STRING 14_
1998: PPUSH
1999: CALL 62975 0 3
2003: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2004: LD_EXP 37
2008: PPUSH
2009: LD_EXP 54
2013: PPUSH
2014: CALL_OW 52
// end ; if JMMGirl = 2 then
2018: LD_EXP 7
2022: PUSH
2023: LD_INT 2
2025: EQUAL
2026: IFFALSE 2061
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2028: LD_ADDR_EXP 39
2032: PUSH
2033: LD_STRING Lisa
2035: PPUSH
2036: LD_INT 1
2038: PPUSH
2039: LD_STRING 14_
2041: PPUSH
2042: CALL 62975 0 3
2046: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2047: LD_EXP 39
2051: PPUSH
2052: LD_EXP 54
2056: PPUSH
2057: CALL_OW 52
// end ; if JMMGirl = 3 then
2061: LD_EXP 7
2065: PUSH
2066: LD_INT 3
2068: EQUAL
2069: IFFALSE 2104
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2071: LD_ADDR_EXP 51
2075: PUSH
2076: LD_STRING Connie
2078: PPUSH
2079: LD_INT 1
2081: PPUSH
2082: LD_STRING 14_
2084: PPUSH
2085: CALL 62975 0 3
2089: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2090: LD_EXP 51
2094: PPUSH
2095: LD_EXP 54
2099: PPUSH
2100: CALL_OW 52
// end ; end ; end ;
2104: LD_VAR 0 1
2108: RET
// export function PrepareStevensSquad ; var tmp ; begin
2109: LD_INT 0
2111: PPUSH
2112: PPUSH
// uc_side := 1 ;
2113: LD_ADDR_OWVAR 20
2117: PUSH
2118: LD_INT 1
2120: ST_TO_ADDR
// uc_nation := 1 ;
2121: LD_ADDR_OWVAR 21
2125: PUSH
2126: LD_INT 1
2128: ST_TO_ADDR
// tmp := [ ] ;
2129: LD_ADDR_VAR 0 2
2133: PUSH
2134: EMPTY
2135: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2136: LD_ADDR_EXP 38
2140: PUSH
2141: LD_STRING Stevens
2143: PPUSH
2144: LD_EXP 1
2148: NOT
2149: PPUSH
2150: LD_STRING 13f_
2152: PPUSH
2153: CALL 62975 0 3
2157: ST_TO_ADDR
// if not Stevens then
2158: LD_EXP 38
2162: NOT
2163: IFFALSE 2219
// begin hc_name = Baker Smith ;
2165: LD_ADDR_OWVAR 26
2169: PUSH
2170: LD_STRING Baker Smith
2172: ST_TO_ADDR
// hc_gallery =  ;
2173: LD_ADDR_OWVAR 33
2177: PUSH
2178: LD_STRING 
2180: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2181: LD_INT 1
2183: PPUSH
2184: LD_INT 10
2186: PPUSH
2187: CALL_OW 384
// Baker = CreateHuman ;
2191: LD_ADDR_EXP 52
2195: PUSH
2196: CALL_OW 44
2200: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2201: LD_ADDR_VAR 0 2
2205: PUSH
2206: LD_VAR 0 2
2210: PUSH
2211: LD_EXP 52
2215: ADD
2216: ST_TO_ADDR
// end else
2217: GO 2235
// tmp := tmp ^ Stevens ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_VAR 0 2
2228: PUSH
2229: LD_EXP 38
2233: ADD
2234: ST_TO_ADDR
// if not Lisa then
2235: LD_EXP 39
2239: NOT
2240: IFFALSE 2286
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2242: LD_ADDR_EXP 39
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_EXP 1
2254: NOT
2255: PPUSH
2256: LD_STRING 13f_
2258: PPUSH
2259: CALL 62975 0 3
2263: ST_TO_ADDR
// if Lisa then
2264: LD_EXP 39
2268: IFFALSE 2286
// tmp := tmp ^ Lisa ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 39
2284: ADD
2285: ST_TO_ADDR
// end ; if not Donaldson then
2286: LD_EXP 40
2290: NOT
2291: IFFALSE 2337
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2293: LD_ADDR_EXP 40
2297: PUSH
2298: LD_STRING Donaldson
2300: PPUSH
2301: LD_EXP 1
2305: NOT
2306: PPUSH
2307: LD_STRING 13f_
2309: PPUSH
2310: CALL 62975 0 3
2314: ST_TO_ADDR
// if Donaldson then
2315: LD_EXP 40
2319: IFFALSE 2337
// tmp := tmp ^ Donaldson ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_VAR 0 2
2330: PUSH
2331: LD_EXP 40
2335: ADD
2336: ST_TO_ADDR
// end ; if not Bobby then
2337: LD_EXP 41
2341: NOT
2342: IFFALSE 2388
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2344: LD_ADDR_EXP 41
2348: PUSH
2349: LD_STRING Bobby
2351: PPUSH
2352: LD_EXP 1
2356: NOT
2357: PPUSH
2358: LD_STRING 13f_
2360: PPUSH
2361: CALL 62975 0 3
2365: ST_TO_ADDR
// if Bobby then
2366: LD_EXP 41
2370: IFFALSE 2388
// tmp := tmp ^ Bobby ;
2372: LD_ADDR_VAR 0 2
2376: PUSH
2377: LD_VAR 0 2
2381: PUSH
2382: LD_EXP 41
2386: ADD
2387: ST_TO_ADDR
// end ; if not Cyrus then
2388: LD_EXP 42
2392: NOT
2393: IFFALSE 2439
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2395: LD_ADDR_EXP 42
2399: PUSH
2400: LD_STRING Cyrus
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13f_
2411: PPUSH
2412: CALL 62975 0 3
2416: ST_TO_ADDR
// if Cyrus then
2417: LD_EXP 42
2421: IFFALSE 2439
// tmp := tmp ^ Cyrus ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 42
2437: ADD
2438: ST_TO_ADDR
// end ; if not Brown then
2439: LD_EXP 44
2443: NOT
2444: IFFALSE 2490
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2446: LD_ADDR_EXP 44
2450: PUSH
2451: LD_STRING Brown
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13f_
2462: PPUSH
2463: CALL 62975 0 3
2467: ST_TO_ADDR
// if Brown then
2468: LD_EXP 44
2472: IFFALSE 2490
// tmp := tmp ^ Brown ;
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 2
2483: PUSH
2484: LD_EXP 44
2488: ADD
2489: ST_TO_ADDR
// end ; if not Gladstone then
2490: LD_EXP 45
2494: NOT
2495: IFFALSE 2541
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2497: LD_ADDR_EXP 45
2501: PUSH
2502: LD_STRING Gladstone
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13f_
2513: PPUSH
2514: CALL 62975 0 3
2518: ST_TO_ADDR
// if Gladstone then
2519: LD_EXP 45
2523: IFFALSE 2541
// tmp := tmp ^ Gladstone ;
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: LD_VAR 0 2
2534: PUSH
2535: LD_EXP 45
2539: ADD
2540: ST_TO_ADDR
// end ; if not Houten then
2541: LD_EXP 46
2545: NOT
2546: IFFALSE 2592
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2548: LD_ADDR_EXP 46
2552: PUSH
2553: LD_STRING Houten
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13f_
2564: PPUSH
2565: CALL 62975 0 3
2569: ST_TO_ADDR
// if Houten then
2570: LD_EXP 46
2574: IFFALSE 2592
// tmp := tmp ^ Houten ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_VAR 0 2
2585: PUSH
2586: LD_EXP 46
2590: ADD
2591: ST_TO_ADDR
// end ; if not Cornel then
2592: LD_EXP 47
2596: NOT
2597: IFFALSE 2643
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2599: LD_ADDR_EXP 47
2603: PUSH
2604: LD_STRING Cornel
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13f_
2615: PPUSH
2616: CALL 62975 0 3
2620: ST_TO_ADDR
// if Cornel then
2621: LD_EXP 47
2625: IFFALSE 2643
// tmp := tmp ^ Cornel ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: LD_EXP 47
2641: ADD
2642: ST_TO_ADDR
// end ; if not Gary then
2643: LD_EXP 48
2647: NOT
2648: IFFALSE 2694
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2650: LD_ADDR_EXP 48
2654: PUSH
2655: LD_STRING Gary
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13f_
2666: PPUSH
2667: CALL 62975 0 3
2671: ST_TO_ADDR
// if Gary then
2672: LD_EXP 48
2676: IFFALSE 2694
// tmp := tmp ^ Gary ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 48
2692: ADD
2693: ST_TO_ADDR
// end ; if not Frank then
2694: LD_EXP 49
2698: NOT
2699: IFFALSE 2745
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2701: LD_ADDR_EXP 49
2705: PUSH
2706: LD_STRING Frank
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13f_
2717: PPUSH
2718: CALL 62975 0 3
2722: ST_TO_ADDR
// if Frank then
2723: LD_EXP 49
2727: IFFALSE 2745
// tmp := tmp ^ Frank ;
2729: LD_ADDR_VAR 0 2
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: LD_EXP 49
2743: ADD
2744: ST_TO_ADDR
// end ; if not Kikuchi then
2745: LD_EXP 50
2749: NOT
2750: IFFALSE 2796
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2752: LD_ADDR_EXP 50
2756: PUSH
2757: LD_STRING Kikuchi
2759: PPUSH
2760: LD_EXP 1
2764: NOT
2765: PPUSH
2766: LD_STRING 13f_
2768: PPUSH
2769: CALL 62975 0 3
2773: ST_TO_ADDR
// if Kikuchi then
2774: LD_EXP 50
2778: IFFALSE 2796
// tmp := tmp ^ Kikuchi ;
2780: LD_ADDR_VAR 0 2
2784: PUSH
2785: LD_VAR 0 2
2789: PUSH
2790: LD_EXP 50
2794: ADD
2795: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2796: LD_ADDR_VAR 0 2
2800: PUSH
2801: LD_VAR 0 2
2805: PUSH
2806: LD_STRING 13_other_survivors
2808: PPUSH
2809: CALL_OW 31
2813: UNION
2814: ST_TO_ADDR
// result := tmp ;
2815: LD_ADDR_VAR 0 1
2819: PUSH
2820: LD_VAR 0 2
2824: ST_TO_ADDR
// end ; end_of_file
2825: LD_VAR 0 1
2829: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2830: LD_INT 0
2832: PPUSH
2833: PPUSH
2834: PPUSH
2835: PPUSH
2836: PPUSH
2837: PPUSH
2838: PPUSH
2839: PPUSH
2840: PPUSH
2841: PPUSH
// uc_side := 4 ;
2842: LD_ADDR_OWVAR 20
2846: PUSH
2847: LD_INT 4
2849: ST_TO_ADDR
// uc_nation := 1 ;
2850: LD_ADDR_OWVAR 21
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2858: LD_INT 387
2860: PPUSH
2861: CALL_OW 274
2865: PPUSH
2866: LD_INT 1
2868: PPUSH
2869: LD_INT 2500
2871: PPUSH
2872: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2876: LD_INT 387
2878: PPUSH
2879: CALL_OW 274
2883: PPUSH
2884: LD_INT 2
2886: PPUSH
2887: LD_INT 400
2889: PPUSH
2890: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2894: LD_INT 387
2896: PPUSH
2897: CALL_OW 274
2901: PPUSH
2902: LD_INT 3
2904: PPUSH
2905: LD_INT 10
2907: PPUSH
2908: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2912: LD_ADDR_EXP 55
2916: PUSH
2917: LD_STRING Powell
2919: PPUSH
2920: CALL_OW 25
2924: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2925: LD_EXP 55
2929: PPUSH
2930: LD_INT 57
2932: PPUSH
2933: LD_INT 94
2935: PPUSH
2936: LD_INT 0
2938: PPUSH
2939: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2943: LD_EXP 55
2947: PPUSH
2948: LD_INT 58
2950: PPUSH
2951: LD_INT 94
2953: PPUSH
2954: CALL_OW 118
// vip := [ ] ;
2958: LD_ADDR_EXP 56
2962: PUSH
2963: EMPTY
2964: ST_TO_ADDR
// tmp := [ ] ;
2965: LD_ADDR_VAR 0 6
2969: PUSH
2970: EMPTY
2971: ST_TO_ADDR
// if JMMGirl <> 2 then
2972: LD_EXP 7
2976: PUSH
2977: LD_INT 2
2979: NONEQUAL
2980: IFFALSE 3004
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2982: LD_ADDR_EXP 39
2986: PUSH
2987: LD_STRING Lisa
2989: PPUSH
2990: LD_EXP 1
2994: NOT
2995: PPUSH
2996: LD_STRING 13s_
2998: PPUSH
2999: CALL 62975 0 3
3003: ST_TO_ADDR
// if Lisa then
3004: LD_EXP 39
3008: IFFALSE 3026
// tmp := tmp ^ Lisa ;
3010: LD_ADDR_VAR 0 6
3014: PUSH
3015: LD_VAR 0 6
3019: PUSH
3020: LD_EXP 39
3024: ADD
3025: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3026: LD_ADDR_EXP 40
3030: PUSH
3031: LD_STRING Donaldson
3033: PPUSH
3034: LD_EXP 1
3038: NOT
3039: PPUSH
3040: LD_STRING 13s_
3042: PPUSH
3043: CALL 62975 0 3
3047: ST_TO_ADDR
// if Donaldson then
3048: LD_EXP 40
3052: IFFALSE 3070
// tmp := tmp ^ Donaldson ;
3054: LD_ADDR_VAR 0 6
3058: PUSH
3059: LD_VAR 0 6
3063: PUSH
3064: LD_EXP 40
3068: ADD
3069: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3070: LD_ADDR_EXP 41
3074: PUSH
3075: LD_STRING Bobby
3077: PPUSH
3078: LD_EXP 1
3082: NOT
3083: PPUSH
3084: LD_STRING 13s_
3086: PPUSH
3087: CALL 62975 0 3
3091: ST_TO_ADDR
// if Bobby then
3092: LD_EXP 41
3096: IFFALSE 3114
// tmp := tmp ^ Bobby ;
3098: LD_ADDR_VAR 0 6
3102: PUSH
3103: LD_VAR 0 6
3107: PUSH
3108: LD_EXP 41
3112: ADD
3113: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3114: LD_ADDR_EXP 42
3118: PUSH
3119: LD_STRING Cyrus
3121: PPUSH
3122: LD_EXP 1
3126: NOT
3127: PPUSH
3128: LD_STRING 13s_
3130: PPUSH
3131: CALL 62975 0 3
3135: ST_TO_ADDR
// if Cyrus then
3136: LD_EXP 42
3140: IFFALSE 3158
// tmp := tmp ^ Cyrus ;
3142: LD_ADDR_VAR 0 6
3146: PUSH
3147: LD_VAR 0 6
3151: PUSH
3152: LD_EXP 42
3156: ADD
3157: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3158: LD_ADDR_EXP 43
3162: PUSH
3163: LD_STRING Denis
3165: PPUSH
3166: LD_EXP 1
3170: NOT
3171: PPUSH
3172: LD_STRING 13s_
3174: PPUSH
3175: CALL 62975 0 3
3179: ST_TO_ADDR
// if not Denis then
3180: LD_EXP 43
3184: NOT
3185: IFFALSE 3209
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3187: LD_ADDR_EXP 43
3191: PUSH
3192: LD_STRING Denis
3194: PPUSH
3195: LD_EXP 1
3199: NOT
3200: PPUSH
3201: LD_STRING 13f_
3203: PPUSH
3204: CALL 62975 0 3
3208: ST_TO_ADDR
// if Denis then
3209: LD_EXP 43
3213: IFFALSE 3231
// tmp := tmp ^ Denis ;
3215: LD_ADDR_VAR 0 6
3219: PUSH
3220: LD_VAR 0 6
3224: PUSH
3225: LD_EXP 43
3229: ADD
3230: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3231: LD_ADDR_EXP 44
3235: PUSH
3236: LD_STRING Brown
3238: PPUSH
3239: LD_EXP 1
3243: NOT
3244: PPUSH
3245: LD_STRING 13s_
3247: PPUSH
3248: CALL 62975 0 3
3252: ST_TO_ADDR
// if Brown then
3253: LD_EXP 44
3257: IFFALSE 3275
// tmp := tmp ^ Brown ;
3259: LD_ADDR_VAR 0 6
3263: PUSH
3264: LD_VAR 0 6
3268: PUSH
3269: LD_EXP 44
3273: ADD
3274: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3275: LD_ADDR_EXP 45
3279: PUSH
3280: LD_STRING Gladstone
3282: PPUSH
3283: LD_EXP 1
3287: NOT
3288: PPUSH
3289: LD_STRING 13s_
3291: PPUSH
3292: CALL 62975 0 3
3296: ST_TO_ADDR
// if Gladstone then
3297: LD_EXP 45
3301: IFFALSE 3319
// tmp := tmp ^ Gladstone ;
3303: LD_ADDR_VAR 0 6
3307: PUSH
3308: LD_VAR 0 6
3312: PUSH
3313: LD_EXP 45
3317: ADD
3318: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3319: LD_ADDR_EXP 46
3323: PUSH
3324: LD_STRING Houten
3326: PPUSH
3327: LD_EXP 1
3331: NOT
3332: PPUSH
3333: LD_STRING 13s_
3335: PPUSH
3336: CALL 62975 0 3
3340: ST_TO_ADDR
// if Houten then
3341: LD_EXP 46
3345: IFFALSE 3363
// tmp := tmp ^ Houten ;
3347: LD_ADDR_VAR 0 6
3351: PUSH
3352: LD_VAR 0 6
3356: PUSH
3357: LD_EXP 46
3361: ADD
3362: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3363: LD_ADDR_EXP 47
3367: PUSH
3368: LD_STRING Cornel
3370: PPUSH
3371: LD_EXP 1
3375: NOT
3376: PPUSH
3377: LD_STRING 13s_
3379: PPUSH
3380: CALL 62975 0 3
3384: ST_TO_ADDR
// if Cornel then
3385: LD_EXP 47
3389: IFFALSE 3407
// tmp := tmp ^ Cornel ;
3391: LD_ADDR_VAR 0 6
3395: PUSH
3396: LD_VAR 0 6
3400: PUSH
3401: LD_EXP 47
3405: ADD
3406: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3407: LD_ADDR_EXP 48
3411: PUSH
3412: LD_STRING Gary
3414: PPUSH
3415: LD_EXP 1
3419: NOT
3420: PPUSH
3421: LD_STRING 13s_
3423: PPUSH
3424: CALL 62975 0 3
3428: ST_TO_ADDR
// if Gary then
3429: LD_EXP 48
3433: IFFALSE 3451
// tmp := tmp ^ Gary ;
3435: LD_ADDR_VAR 0 6
3439: PUSH
3440: LD_VAR 0 6
3444: PUSH
3445: LD_EXP 48
3449: ADD
3450: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3451: LD_ADDR_EXP 49
3455: PUSH
3456: LD_STRING Frank
3458: PPUSH
3459: LD_EXP 1
3463: NOT
3464: PPUSH
3465: LD_STRING 13s_
3467: PPUSH
3468: CALL 62975 0 3
3472: ST_TO_ADDR
// if Frank then
3473: LD_EXP 49
3477: IFFALSE 3495
// tmp := tmp ^ Frank ;
3479: LD_ADDR_VAR 0 6
3483: PUSH
3484: LD_VAR 0 6
3488: PUSH
3489: LD_EXP 49
3493: ADD
3494: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3495: LD_ADDR_EXP 50
3499: PUSH
3500: LD_STRING Kikuchi
3502: PPUSH
3503: LD_EXP 1
3507: NOT
3508: PPUSH
3509: LD_STRING 13s_
3511: PPUSH
3512: CALL 62975 0 3
3516: ST_TO_ADDR
// if Kikuchi then
3517: LD_EXP 50
3521: IFFALSE 3539
// tmp := tmp ^ Kikuchi ;
3523: LD_ADDR_VAR 0 6
3527: PUSH
3528: LD_VAR 0 6
3532: PUSH
3533: LD_EXP 50
3537: ADD
3538: ST_TO_ADDR
// vip := tmp ;
3539: LD_ADDR_EXP 56
3543: PUSH
3544: LD_VAR 0 6
3548: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3549: LD_ADDR_VAR 0 6
3553: PUSH
3554: LD_VAR 0 6
3558: PUSH
3559: LD_STRING 13s_others
3561: PPUSH
3562: CALL_OW 31
3566: UNION
3567: ST_TO_ADDR
// if tmp < 20 then
3568: LD_VAR 0 6
3572: PUSH
3573: LD_INT 20
3575: LESS
3576: IFFALSE 3643
// for i = 1 to 20 - tmp do
3578: LD_ADDR_VAR 0 2
3582: PUSH
3583: DOUBLE
3584: LD_INT 1
3586: DEC
3587: ST_TO_ADDR
3588: LD_INT 20
3590: PUSH
3591: LD_VAR 0 6
3595: MINUS
3596: PUSH
3597: FOR_TO
3598: IFFALSE 3641
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3600: LD_INT 1
3602: PPUSH
3603: LD_VAR 0 2
3607: PUSH
3608: LD_INT 4
3610: MOD
3611: PUSH
3612: LD_INT 1
3614: PLUS
3615: PPUSH
3616: LD_INT 5
3618: PPUSH
3619: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3623: LD_ADDR_VAR 0 6
3627: PUSH
3628: LD_VAR 0 6
3632: PUSH
3633: CALL_OW 44
3637: ADD
3638: ST_TO_ADDR
// end ;
3639: GO 3597
3641: POP
3642: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3643: LD_ADDR_VAR 0 7
3647: PUSH
3648: LD_INT 22
3650: PUSH
3651: LD_INT 4
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PUSH
3658: LD_INT 30
3660: PUSH
3661: LD_INT 0
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: PPUSH
3672: CALL_OW 69
3676: PUSH
3677: LD_INT 1
3679: ARRAY
3680: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 8
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 6
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 9
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 4
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 10
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 2
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// for i in tmp do
3795: LD_ADDR_VAR 0 2
3799: PUSH
3800: LD_VAR 0 6
3804: PUSH
3805: FOR_IN
3806: IFFALSE 3932
// begin cl := GetClass ( i ) ;
3808: LD_ADDR_VAR 0 5
3812: PUSH
3813: LD_VAR 0 2
3817: PPUSH
3818: CALL_OW 257
3822: ST_TO_ADDR
// if cl > 4 then
3823: LD_VAR 0 5
3827: PUSH
3828: LD_INT 4
3830: GREATER
3831: IFFALSE 3841
// cl := 1 ;
3833: LD_ADDR_VAR 0 5
3837: PUSH
3838: LD_INT 1
3840: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3841: LD_ADDR_VAR 0 3
3845: PUSH
3846: LD_VAR 0 9
3850: PUSH
3851: LD_VAR 0 7
3855: PUSH
3856: LD_VAR 0 10
3860: PUSH
3861: LD_VAR 0 8
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: PUSH
3872: LD_VAR 0 5
3876: ARRAY
3877: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3878: LD_VAR 0 3
3882: PPUSH
3883: CALL_OW 313
3887: PUSH
3888: LD_INT 5
3890: LESS
3891: IFFALSE 3909
// PlaceHumanInUnit ( i , b ) else
3893: LD_VAR 0 2
3897: PPUSH
3898: LD_VAR 0 3
3902: PPUSH
3903: CALL_OW 52
3907: GO 3930
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3909: LD_VAR 0 2
3913: PPUSH
3914: LD_INT 58
3916: PPUSH
3917: LD_INT 91
3919: PPUSH
3920: LD_INT 6
3922: PPUSH
3923: LD_INT 0
3925: PPUSH
3926: CALL_OW 50
// end ;
3930: GO 3805
3932: POP
3933: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3934: LD_INT 2
3936: PPUSH
3937: LD_INT 1
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 12
3945: PPUSH
3946: LD_INT 100
3948: PPUSH
3949: CALL 69586 0 5
// veh := CreateVehicle ;
3953: LD_ADDR_VAR 0 4
3957: PUSH
3958: CALL_OW 45
3962: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3963: LD_VAR 0 4
3967: PPUSH
3968: LD_INT 4
3970: PPUSH
3971: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3975: LD_VAR 0 4
3979: PPUSH
3980: LD_INT 49
3982: PPUSH
3983: LD_INT 88
3985: PPUSH
3986: LD_INT 0
3988: PPUSH
3989: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3993: LD_VAR 0 4
3997: PPUSH
3998: LD_INT 1
4000: PPUSH
4001: LD_INT 100
4003: PPUSH
4004: CALL_OW 290
// uc_side := 0 ;
4008: LD_ADDR_OWVAR 20
4012: PUSH
4013: LD_INT 0
4015: ST_TO_ADDR
// uc_nation := 0 ;
4016: LD_ADDR_OWVAR 21
4020: PUSH
4021: LD_INT 0
4023: ST_TO_ADDR
// for i = 1 to 4 do
4024: LD_ADDR_VAR 0 2
4028: PUSH
4029: DOUBLE
4030: LD_INT 1
4032: DEC
4033: ST_TO_ADDR
4034: LD_INT 4
4036: PUSH
4037: FOR_TO
4038: IFFALSE 4069
// begin InitHc ;
4040: CALL_OW 19
// hc_class := class_apeman ;
4044: LD_ADDR_OWVAR 28
4048: PUSH
4049: LD_INT 12
4051: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4052: CALL_OW 44
4056: PPUSH
4057: LD_INT 13
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 49
// end ;
4067: GO 4037
4069: POP
4070: POP
// end ; end_of_file
4071: LD_VAR 0 1
4075: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
// side := 8 ;
4083: LD_ADDR_VAR 0 3
4087: PUSH
4088: LD_INT 8
4090: ST_TO_ADDR
// uc_side := side ;
4091: LD_ADDR_OWVAR 20
4095: PUSH
4096: LD_VAR 0 3
4100: ST_TO_ADDR
// uc_nation := 2 ;
4101: LD_ADDR_OWVAR 21
4105: PUSH
4106: LD_INT 2
4108: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_INT 22
4116: PUSH
4117: LD_VAR 0 3
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 21
4128: PUSH
4129: LD_INT 3
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PPUSH
4140: CALL_OW 69
4144: PUSH
4145: FOR_IN
4146: IFFALSE 4162
// SetBLevel ( i , 10 ) ;
4148: LD_VAR 0 2
4152: PPUSH
4153: LD_INT 10
4155: PPUSH
4156: CALL_OW 241
4160: GO 4145
4162: POP
4163: POP
// if KurtStatus then
4164: LD_EXP 3
4168: IFFALSE 4191
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4170: LD_ADDR_EXP 57
4174: PUSH
4175: LD_STRING Kurt
4177: PPUSH
4178: LD_INT 0
4180: PPUSH
4181: LD_STRING 
4183: PPUSH
4184: CALL 62975 0 3
4188: ST_TO_ADDR
4189: GO 4213
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4191: LD_ADDR_EXP 57
4195: PUSH
4196: LD_STRING AltKurt
4198: PPUSH
4199: LD_EXP 1
4203: NOT
4204: PPUSH
4205: LD_STRING 
4207: PPUSH
4208: CALL 62975 0 3
4212: ST_TO_ADDR
// if not Kurt then
4213: LD_EXP 57
4217: NOT
4218: IFFALSE 4244
// begin InitHc ;
4220: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4224: LD_INT 1
4226: PPUSH
4227: LD_INT 10
4229: PPUSH
4230: CALL_OW 381
// Kurt := CreateHuman ;
4234: LD_ADDR_EXP 57
4238: PUSH
4239: CALL_OW 44
4243: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4244: LD_EXP 57
4248: PPUSH
4249: LD_INT 324
4251: PPUSH
4252: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4256: LD_ADDR_EXP 58
4260: PUSH
4261: LD_STRING Kozlov
4263: PPUSH
4264: LD_INT 0
4266: PPUSH
4267: LD_STRING 
4269: PPUSH
4270: CALL 62975 0 3
4274: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4275: LD_EXP 58
4279: PPUSH
4280: LD_INT 22
4282: PUSH
4283: LD_INT 8
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 23
4292: PUSH
4293: LD_INT 3
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: PUSH
4300: LD_INT 30
4302: PUSH
4303: LD_INT 8
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: LIST
4314: PPUSH
4315: CALL_OW 69
4319: PUSH
4320: LD_INT 1
4322: ARRAY
4323: PPUSH
4324: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4328: LD_EXP 58
4332: PPUSH
4333: LD_INT 3
4335: PPUSH
4336: LD_INT 10
4338: PPUSH
4339: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4343: LD_ADDR_VAR 0 5
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_VAR 0 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 30
4362: PUSH
4363: LD_INT 32
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 58
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: ST_TO_ADDR
// for i = 1 to 10 do
4386: LD_ADDR_VAR 0 2
4390: PUSH
4391: DOUBLE
4392: LD_INT 1
4394: DEC
4395: ST_TO_ADDR
4396: LD_INT 10
4398: PUSH
4399: FOR_TO
4400: IFFALSE 4472
// begin uc_nation := nation_nature ;
4402: LD_ADDR_OWVAR 21
4406: PUSH
4407: LD_INT 0
4409: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4410: LD_ADDR_OWVAR 28
4414: PUSH
4415: LD_INT 15
4417: ST_TO_ADDR
// hc_gallery :=  ;
4418: LD_ADDR_OWVAR 33
4422: PUSH
4423: LD_STRING 
4425: ST_TO_ADDR
// hc_name :=  ;
4426: LD_ADDR_OWVAR 26
4430: PUSH
4431: LD_STRING 
4433: ST_TO_ADDR
// un := CreateHuman ;
4434: LD_ADDR_VAR 0 4
4438: PUSH
4439: CALL_OW 44
4443: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4444: LD_VAR 0 4
4448: PPUSH
4449: LD_VAR 0 5
4453: PUSH
4454: LD_VAR 0 5
4458: PUSH
4459: LD_VAR 0 2
4463: MINUS
4464: ARRAY
4465: PPUSH
4466: CALL_OW 52
// end ;
4470: GO 4399
4472: POP
4473: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4474: LD_ADDR_VAR 0 5
4478: PUSH
4479: LD_STRING 12_kurt_squad
4481: PPUSH
4482: CALL_OW 31
4486: ST_TO_ADDR
// if tmp then
4487: LD_VAR 0 5
4491: IFFALSE 4525
// for i in tmp do
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_VAR 0 5
4502: PUSH
4503: FOR_IN
4504: IFFALSE 4523
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4506: LD_VAR 0 2
4510: PPUSH
4511: LD_INT 5
4513: PPUSH
4514: LD_INT 0
4516: PPUSH
4517: CALL_OW 49
4521: GO 4503
4523: POP
4524: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4525: LD_INT 324
4527: PPUSH
4528: LD_INT 5
4530: PPUSH
4531: LD_STRING 
4533: PPUSH
4534: LD_INT 8
4536: PUSH
4537: LD_INT 9
4539: PUSH
4540: LD_INT 10
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: LIST
4547: PUSH
4548: LD_OWVAR 67
4552: ARRAY
4553: PPUSH
4554: LD_INT 3000
4556: PUSH
4557: LD_INT 500
4559: PUSH
4560: LD_INT 150
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: LIST
4567: PPUSH
4568: LD_INT 16
4570: PUSH
4571: LD_INT 6
4573: PUSH
4574: LD_INT 6
4576: PUSH
4577: LD_INT 8
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL 72995 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4590: LD_ADDR_EXP 99
4594: PUSH
4595: LD_EXP 99
4599: PPUSH
4600: LD_INT 3
4602: PPUSH
4603: LD_INT 22
4605: PUSH
4606: LD_VAR 0 3
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PUSH
4615: LD_INT 23
4617: PUSH
4618: LD_INT 2
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PUSH
4625: LD_INT 3
4627: PUSH
4628: LD_INT 21
4630: PUSH
4631: LD_INT 2
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: PUSH
4638: EMPTY
4639: LIST
4640: LIST
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 69
4651: PUSH
4652: LD_EXP 57
4656: DIFF
4657: PPUSH
4658: CALL_OW 1
4662: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4663: LD_INT 1
4665: PPUSH
4666: LD_INT 7
4668: PPUSH
4669: CALL_OW 383
// Friend := CreateHuman ;
4673: LD_ADDR_EXP 59
4677: PUSH
4678: CALL_OW 44
4682: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4683: LD_INT 14
4685: PPUSH
4686: LD_INT 3
4688: PPUSH
4689: LD_INT 1
4691: PPUSH
4692: LD_INT 29
4694: PPUSH
4695: LD_INT 100
4697: PPUSH
4698: CALL 69586 0 5
// powellBomb := CreateVehicle ;
4702: LD_ADDR_EXP 60
4706: PUSH
4707: CALL_OW 45
4711: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4712: LD_EXP 60
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: LD_INT 51
4722: PPUSH
4723: LD_INT 0
4725: PPUSH
4726: CALL_OW 48
// end ;
4730: LD_VAR 0 1
4734: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4735: LD_INT 0
4737: PPUSH
4738: PPUSH
4739: PPUSH
// if IsLive ( kozlov_fac ) then
4740: LD_INT 332
4742: PPUSH
4743: CALL_OW 300
4747: IFFALSE 4751
// exit ;
4749: GO 5318
// ComExitBuilding ( Kozlov ) ;
4751: LD_EXP 58
4755: PPUSH
4756: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4760: LD_EXP 58
4764: PPUSH
4765: CALL_OW 257
4769: PUSH
4770: LD_INT 2
4772: NONEQUAL
4773: IFFALSE 4808
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4775: LD_EXP 58
4779: PPUSH
4780: LD_INT 324
4782: PPUSH
4783: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4787: LD_EXP 58
4791: PPUSH
4792: LD_INT 2
4794: PPUSH
4795: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4799: LD_EXP 58
4803: PPUSH
4804: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4808: LD_EXP 58
4812: PPUSH
4813: LD_INT 2
4815: PPUSH
4816: LD_INT 93
4818: PPUSH
4819: LD_INT 32
4821: PPUSH
4822: LD_INT 3
4824: PPUSH
4825: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4829: LD_INT 35
4831: PPUSH
4832: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4836: LD_INT 22
4838: PUSH
4839: LD_INT 8
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 30
4848: PUSH
4849: LD_INT 3
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: LD_INT 23
4858: PUSH
4859: LD_INT 3
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 57
4868: PUSH
4869: EMPTY
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: IFFALSE 4829
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4884: LD_ADDR_VAR 0 2
4888: PUSH
4889: LD_INT 22
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: LD_INT 30
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PUSH
4909: LD_INT 23
4911: PUSH
4912: LD_INT 3
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: LD_INT 57
4921: PUSH
4922: EMPTY
4923: LIST
4924: PUSH
4925: EMPTY
4926: LIST
4927: LIST
4928: LIST
4929: LIST
4930: PPUSH
4931: CALL_OW 69
4935: PUSH
4936: LD_INT 1
4938: ARRAY
4939: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4940: LD_INT 22
4942: PUSH
4943: LD_INT 8
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: LD_INT 23
4952: PUSH
4953: LD_INT 3
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PUSH
4960: LD_INT 30
4962: PUSH
4963: LD_INT 21
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PUSH
4970: EMPTY
4971: LIST
4972: LIST
4973: LIST
4974: PPUSH
4975: CALL_OW 69
4979: NOT
4980: IFFALSE 5058
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4982: LD_EXP 58
4986: PPUSH
4987: LD_INT 21
4989: PPUSH
4990: LD_INT 97
4992: PPUSH
4993: LD_INT 36
4995: PPUSH
4996: LD_INT 5
4998: PPUSH
4999: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5003: LD_INT 35
5005: PPUSH
5006: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5010: LD_INT 22
5012: PUSH
5013: LD_INT 8
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 23
5022: PUSH
5023: LD_INT 3
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: LD_INT 30
5032: PUSH
5033: LD_INT 21
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PUSH
5040: LD_INT 57
5042: PUSH
5043: EMPTY
5044: LIST
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 69
5056: IFFALSE 5003
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5058: LD_INT 22
5060: PUSH
5061: LD_INT 8
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 23
5070: PUSH
5071: LD_INT 3
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 30
5080: PUSH
5081: LD_INT 18
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: PPUSH
5093: CALL_OW 69
5097: NOT
5098: IFFALSE 5176
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5100: LD_EXP 58
5104: PPUSH
5105: LD_INT 18
5107: PPUSH
5108: LD_INT 89
5110: PPUSH
5111: LD_INT 32
5113: PPUSH
5114: LD_INT 1
5116: PPUSH
5117: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5121: LD_INT 35
5123: PPUSH
5124: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5128: LD_INT 22
5130: PUSH
5131: LD_INT 8
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_INT 23
5140: PUSH
5141: LD_INT 3
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: PUSH
5148: LD_INT 30
5150: PUSH
5151: LD_INT 18
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PUSH
5158: LD_INT 57
5160: PUSH
5161: EMPTY
5162: LIST
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: PPUSH
5170: CALL_OW 69
5174: IFFALSE 5121
// end ; lab := kozlov_lab ;
5176: LD_ADDR_VAR 0 3
5180: PUSH
5181: LD_INT 336
5183: ST_TO_ADDR
// if not lab then
5184: LD_VAR 0 3
5188: NOT
5189: IFFALSE 5193
// exit ;
5191: GO 5318
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5193: LD_EXP 58
5197: PPUSH
5198: LD_VAR 0 3
5202: PUSH
5203: LD_INT 1
5205: ARRAY
5206: PPUSH
5207: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5211: LD_EXP 58
5215: PPUSH
5216: LD_INT 4
5218: PPUSH
5219: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5223: LD_VAR 0 3
5227: PUSH
5228: LD_INT 1
5230: ARRAY
5231: PPUSH
5232: LD_INT 25
5234: PPUSH
5235: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5239: LD_INT 35
5241: PPUSH
5242: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5246: LD_INT 25
5248: PPUSH
5249: LD_INT 8
5251: PPUSH
5252: CALL_OW 321
5256: PUSH
5257: LD_INT 2
5259: EQUAL
5260: IFFALSE 5239
// ComExitBuilding ( Kozlov ) ;
5262: LD_EXP 58
5266: PPUSH
5267: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5271: LD_EXP 58
5275: PPUSH
5276: LD_VAR 0 2
5280: PPUSH
5281: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5285: LD_EXP 58
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5297: LD_VAR 0 2
5301: PPUSH
5302: LD_INT 23
5304: PPUSH
5305: LD_INT 3
5307: PPUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 48
5313: PPUSH
5314: CALL_OW 125
// end ;
5318: LD_VAR 0 1
5322: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5323: LD_EXP 22
5327: NOT
5328: PUSH
5329: LD_EXP 15
5333: PUSH
5334: LD_INT 6
5336: GREATEREQUAL
5337: AND
5338: IFFALSE 5419
5340: GO 5342
5342: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 3
5348: PPUSH
5349: CALL 57110 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 14
5358: PUSH
5359: LD_INT 1
5361: PUSH
5362: LD_INT 1
5364: PUSH
5365: LD_INT 28
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: PUSH
5374: LD_INT 14
5376: PUSH
5377: LD_INT 1
5379: PUSH
5380: LD_INT 1
5382: PUSH
5383: LD_INT 28
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: LIST
5390: LIST
5391: PUSH
5392: LD_INT 14
5394: PUSH
5395: LD_INT 1
5397: PUSH
5398: LD_INT 1
5400: PUSH
5401: LD_INT 28
5403: PUSH
5404: EMPTY
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: PUSH
5410: EMPTY
5411: LIST
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL 56973 0 2
// end ;
5419: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5420: LD_EXP 22
5424: NOT
5425: PUSH
5426: LD_EXP 15
5430: PUSH
5431: LD_INT 6
5433: GREATEREQUAL
5434: AND
5435: PUSH
5436: LD_INT 3
5438: PPUSH
5439: LD_INT 1
5441: PPUSH
5442: CALL 58328 0 2
5446: NOT
5447: AND
5448: IFFALSE 6288
5450: GO 5452
5452: DISABLE
5453: LD_INT 0
5455: PPUSH
5456: PPUSH
5457: PPUSH
// begin enable ;
5458: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5459: LD_INT 22
5461: PUSH
5462: LD_INT 8
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 23
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 3
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 69
5498: NOT
5499: IFFALSE 5503
// exit ;
5501: GO 6288
// if Prob ( 40 ) then
5503: LD_INT 40
5505: PPUSH
5506: CALL_OW 13
5510: IFFALSE 5637
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5512: LD_INT 3
5514: PPUSH
5515: LD_INT 14
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 2
5523: PUSH
5524: LD_INT 28
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_INT 14
5535: PUSH
5536: LD_INT 1
5538: PUSH
5539: LD_INT 2
5541: PUSH
5542: LD_INT 28
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: LIST
5549: LIST
5550: PUSH
5551: LD_INT 14
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 28
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 28
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: LD_INT 14
5589: PUSH
5590: LD_INT 1
5592: PUSH
5593: LD_INT 2
5595: PUSH
5596: LD_INT 28
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 14
5607: PUSH
5608: LD_INT 1
5610: PUSH
5611: LD_INT 2
5613: PUSH
5614: LD_INT 26
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: LIST
5621: LIST
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: PPUSH
5631: CALL 56973 0 2
// end else
5635: GO 5828
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5637: LD_INT 3
5639: PPUSH
5640: LD_INT 14
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 27
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: LD_INT 26
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: PUSH
5663: LD_OWVAR 67
5667: ARRAY
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 2
5683: PUSH
5684: LD_INT 27
5686: PUSH
5687: LD_INT 26
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_OWVAR 67
5702: ARRAY
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: LD_INT 26
5724: PUSH
5725: LD_INT 29
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: PUSH
5733: LD_OWVAR 67
5737: ARRAY
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_INT 13
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 26
5756: PUSH
5757: LD_INT 29
5759: PUSH
5760: LD_INT 29
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 13
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 29
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 14
5800: PUSH
5801: LD_INT 1
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PPUSH
5824: CALL 56973 0 2
// end ; repeat wait ( 0 0$1 ) ;
5828: LD_INT 35
5830: PPUSH
5831: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5835: LD_INT 3
5837: PPUSH
5838: LD_INT 1
5840: PPUSH
5841: CALL 58328 0 2
5845: PUSH
5846: LD_INT 6
5848: GREATEREQUAL
5849: IFFALSE 5828
// wait ( 0 0$30 ) ;
5851: LD_INT 1050
5853: PPUSH
5854: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5858: LD_ADDR_VAR 0 2
5862: PUSH
5863: LD_INT 3
5865: PPUSH
5866: LD_INT 1
5868: PPUSH
5869: CALL 58328 0 2
5873: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5874: LD_ADDR_EXP 118
5878: PUSH
5879: LD_EXP 118
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: LD_EXP 118
5891: PUSH
5892: LD_INT 3
5894: ARRAY
5895: PUSH
5896: LD_VAR 0 2
5900: DIFF
5901: PPUSH
5902: CALL_OW 1
5906: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5907: LD_ADDR_VAR 0 3
5911: PUSH
5912: LD_INT 0
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 12
5922: ST_TO_ADDR
// if target then
5923: LD_VAR 0 3
5927: IFFALSE 6055
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5929: LD_ADDR_VAR 0 2
5933: PUSH
5934: LD_VAR 0 2
5938: PPUSH
5939: LD_INT 24
5941: PUSH
5942: LD_INT 250
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: PPUSH
5949: CALL_OW 72
5953: ST_TO_ADDR
// for i in tmp do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_VAR 0 2
5963: PUSH
5964: FOR_IN
5965: IFFALSE 6005
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5967: LD_VAR 0 1
5971: PPUSH
5972: LD_INT 89
5974: PPUSH
5975: LD_INT 71
5977: PPUSH
5978: CALL_OW 297
5982: PUSH
5983: LD_INT 9
5985: GREATER
5986: IFFALSE 6003
// ComMoveXY ( i , 89 , 71 ) ;
5988: LD_VAR 0 1
5992: PPUSH
5993: LD_INT 89
5995: PPUSH
5996: LD_INT 71
5998: PPUSH
5999: CALL_OW 111
6003: GO 5964
6005: POP
6006: POP
// wait ( 0 0$1 ) ;
6007: LD_INT 35
6009: PPUSH
6010: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6014: LD_VAR 0 2
6018: PPUSH
6019: LD_INT 92
6021: PUSH
6022: LD_INT 89
6024: PUSH
6025: LD_INT 71
6027: PUSH
6028: LD_INT 9
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PPUSH
6037: CALL_OW 72
6041: PUSH
6042: LD_VAR 0 2
6046: PUSH
6047: LD_INT 1
6049: MINUS
6050: GREATEREQUAL
6051: IFFALSE 5929
// end else
6053: GO 6179
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6055: LD_ADDR_VAR 0 2
6059: PUSH
6060: LD_VAR 0 2
6064: PPUSH
6065: LD_INT 24
6067: PUSH
6068: LD_INT 250
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: ST_TO_ADDR
// for i in tmp do
6080: LD_ADDR_VAR 0 1
6084: PUSH
6085: LD_VAR 0 2
6089: PUSH
6090: FOR_IN
6091: IFFALSE 6131
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 125
6100: PPUSH
6101: LD_INT 129
6103: PPUSH
6104: CALL_OW 297
6108: PUSH
6109: LD_INT 9
6111: GREATER
6112: IFFALSE 6129
// ComMoveXY ( i , 125 , 129 ) ;
6114: LD_VAR 0 1
6118: PPUSH
6119: LD_INT 125
6121: PPUSH
6122: LD_INT 129
6124: PPUSH
6125: CALL_OW 111
6129: GO 6090
6131: POP
6132: POP
// wait ( 0 0$1 ) ;
6133: LD_INT 35
6135: PPUSH
6136: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6140: LD_VAR 0 2
6144: PPUSH
6145: LD_INT 92
6147: PUSH
6148: LD_INT 125
6150: PUSH
6151: LD_INT 129
6153: PUSH
6154: LD_INT 9
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 72
6167: PUSH
6168: LD_VAR 0 2
6172: PUSH
6173: LD_INT 1
6175: MINUS
6176: GREATEREQUAL
6177: IFFALSE 6055
// end ; repeat wait ( 0 0$1 ) ;
6179: LD_INT 35
6181: PPUSH
6182: CALL_OW 67
// for i in tmp do
6186: LD_ADDR_VAR 0 1
6190: PUSH
6191: LD_VAR 0 2
6195: PUSH
6196: FOR_IN
6197: IFFALSE 6279
// begin if GetLives ( i ) > 251 then
6199: LD_VAR 0 1
6203: PPUSH
6204: CALL_OW 256
6208: PUSH
6209: LD_INT 251
6211: GREATER
6212: IFFALSE 6250
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6214: LD_VAR 0 1
6218: PPUSH
6219: LD_INT 81
6221: PUSH
6222: LD_INT 8
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PPUSH
6229: CALL_OW 69
6233: PPUSH
6234: LD_VAR 0 1
6238: PPUSH
6239: CALL_OW 74
6243: PPUSH
6244: CALL_OW 115
6248: GO 6277
// if IsDead ( i ) then
6250: LD_VAR 0 1
6254: PPUSH
6255: CALL_OW 301
6259: IFFALSE 6277
// tmp := tmp diff i ;
6261: LD_ADDR_VAR 0 2
6265: PUSH
6266: LD_VAR 0 2
6270: PUSH
6271: LD_VAR 0 1
6275: DIFF
6276: ST_TO_ADDR
// end ;
6277: GO 6196
6279: POP
6280: POP
// until not tmp ;
6281: LD_VAR 0 2
6285: NOT
6286: IFFALSE 6179
// end ;
6288: PPOPN 3
6290: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6291: LD_EXP 22
6295: NOT
6296: PUSH
6297: LD_EXP 15
6301: PUSH
6302: LD_INT 6
6304: GREATEREQUAL
6305: AND
6306: PUSH
6307: LD_OWVAR 67
6311: PUSH
6312: LD_INT 1
6314: GREATER
6315: AND
6316: IFFALSE 6833
6318: GO 6320
6320: DISABLE
6321: LD_INT 0
6323: PPUSH
6324: PPUSH
6325: PPUSH
// begin enable ;
6326: ENABLE
// tmp := [ ] ;
6327: LD_ADDR_VAR 0 3
6331: PUSH
6332: EMPTY
6333: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6334: LD_ADDR_VAR 0 1
6338: PUSH
6339: DOUBLE
6340: LD_INT 1
6342: DEC
6343: ST_TO_ADDR
6344: LD_INT 4
6346: PUSH
6347: LD_INT 6
6349: PUSH
6350: LD_INT 7
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_OWVAR 67
6362: ARRAY
6363: PUSH
6364: FOR_TO
6365: IFFALSE 6525
// begin uc_side := 8 ;
6367: LD_ADDR_OWVAR 20
6371: PUSH
6372: LD_INT 8
6374: ST_TO_ADDR
// uc_nation := 2 ;
6375: LD_ADDR_OWVAR 21
6379: PUSH
6380: LD_INT 2
6382: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6383: LD_INT 13
6385: PUSH
6386: LD_INT 14
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: LD_INT 1
6395: PPUSH
6396: LD_INT 2
6398: PPUSH
6399: CALL_OW 12
6403: ARRAY
6404: PPUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 5
6410: PPUSH
6411: LD_INT 27
6413: PUSH
6414: LD_INT 28
6416: PUSH
6417: LD_INT 26
6419: PUSH
6420: LD_INT 25
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: PUSH
6429: LD_INT 1
6431: PPUSH
6432: LD_INT 4
6434: PPUSH
6435: CALL_OW 12
6439: ARRAY
6440: PPUSH
6441: LD_INT 88
6443: PPUSH
6444: CALL 69586 0 5
// un := CreateVehicle ;
6448: LD_ADDR_VAR 0 2
6452: PUSH
6453: CALL_OW 45
6457: ST_TO_ADDR
// tmp := tmp ^ un ;
6458: LD_ADDR_VAR 0 3
6462: PUSH
6463: LD_VAR 0 3
6467: PUSH
6468: LD_VAR 0 2
6472: ADD
6473: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6474: LD_VAR 0 2
6478: PPUSH
6479: LD_INT 3
6481: PPUSH
6482: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6486: LD_VAR 0 2
6490: PPUSH
6491: LD_INT 30
6493: PPUSH
6494: LD_INT 0
6496: PPUSH
6497: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6501: LD_VAR 0 2
6505: PPUSH
6506: LD_INT 16
6508: PPUSH
6509: LD_INT 11
6511: PPUSH
6512: CALL_OW 111
// wait ( 0 0$2 ) ;
6516: LD_INT 70
6518: PPUSH
6519: CALL_OW 67
// end ;
6523: GO 6364
6525: POP
6526: POP
// for i = 1 to Difficulty do
6527: LD_ADDR_VAR 0 1
6531: PUSH
6532: DOUBLE
6533: LD_INT 1
6535: DEC
6536: ST_TO_ADDR
6537: LD_OWVAR 67
6541: PUSH
6542: FOR_TO
6543: IFFALSE 6668
// begin uc_side := 8 ;
6545: LD_ADDR_OWVAR 20
6549: PUSH
6550: LD_INT 8
6552: ST_TO_ADDR
// uc_nation := 2 ;
6553: LD_ADDR_OWVAR 21
6557: PUSH
6558: LD_INT 2
6560: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6561: LD_INT 0
6563: PPUSH
6564: LD_INT 8
6566: PPUSH
6567: LD_INT 8
6569: PUSH
6570: LD_INT 8
6572: PUSH
6573: LD_INT 9
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PPUSH
6587: CALL_OW 380
// un := CreateHuman ;
6591: LD_ADDR_VAR 0 2
6595: PUSH
6596: CALL_OW 44
6600: ST_TO_ADDR
// tmp := tmp ^ un ;
6601: LD_ADDR_VAR 0 3
6605: PUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_VAR 0 2
6615: ADD
6616: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6617: LD_VAR 0 2
6621: PPUSH
6622: LD_INT 3
6624: PPUSH
6625: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6629: LD_VAR 0 2
6633: PPUSH
6634: LD_INT 30
6636: PPUSH
6637: LD_INT 0
6639: PPUSH
6640: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6644: LD_VAR 0 2
6648: PPUSH
6649: LD_INT 16
6651: PPUSH
6652: LD_INT 11
6654: PPUSH
6655: CALL_OW 111
// wait ( 0 0$2 ) ;
6659: LD_INT 70
6661: PPUSH
6662: CALL_OW 67
// end ;
6666: GO 6542
6668: POP
6669: POP
// repeat wait ( 0 0$1 ) ;
6670: LD_INT 35
6672: PPUSH
6673: CALL_OW 67
// for i in tmp do
6677: LD_ADDR_VAR 0 1
6681: PUSH
6682: LD_VAR 0 3
6686: PUSH
6687: FOR_IN
6688: IFFALSE 6824
// begin if GetLives ( i ) > 250 then
6690: LD_VAR 0 1
6694: PPUSH
6695: CALL_OW 256
6699: PUSH
6700: LD_INT 250
6702: GREATER
6703: IFFALSE 6795
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6705: LD_INT 81
6707: PUSH
6708: LD_INT 8
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PUSH
6715: LD_INT 91
6717: PUSH
6718: LD_VAR 0 1
6722: PUSH
6723: LD_INT 10
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 69
6739: NOT
6740: IFFALSE 6759
// ComAgressiveMove ( i , 67 , 110 ) else
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_INT 67
6749: PPUSH
6750: LD_INT 110
6752: PPUSH
6753: CALL_OW 114
6757: GO 6793
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_INT 81
6766: PUSH
6767: LD_INT 8
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PPUSH
6774: CALL_OW 69
6778: PPUSH
6779: LD_VAR 0 1
6783: PPUSH
6784: CALL_OW 74
6788: PPUSH
6789: CALL_OW 115
// end else
6793: GO 6822
// if IsDead ( i ) then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 301
6804: IFFALSE 6822
// tmp := tmp diff i ;
6806: LD_ADDR_VAR 0 3
6810: PUSH
6811: LD_VAR 0 3
6815: PUSH
6816: LD_VAR 0 1
6820: DIFF
6821: ST_TO_ADDR
// end ;
6822: GO 6687
6824: POP
6825: POP
// until not tmp ;
6826: LD_VAR 0 3
6830: NOT
6831: IFFALSE 6670
// end ; end_of_file
6833: PPOPN 3
6835: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6836: LD_INT 0
6838: PPUSH
6839: PPUSH
6840: PPUSH
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
6846: PPUSH
// side := 3 ;
6847: LD_ADDR_VAR 0 6
6851: PUSH
6852: LD_INT 3
6854: ST_TO_ADDR
// uc_side := side ;
6855: LD_ADDR_OWVAR 20
6859: PUSH
6860: LD_VAR 0 6
6864: ST_TO_ADDR
// uc_nation := 3 ;
6865: LD_ADDR_OWVAR 21
6869: PUSH
6870: LD_INT 3
6872: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: LD_INT 22
6880: PUSH
6881: LD_VAR 0 6
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 21
6892: PUSH
6893: LD_INT 3
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 69
6908: PUSH
6909: FOR_IN
6910: IFFALSE 6926
// SetBLevel ( i , 10 ) ;
6912: LD_VAR 0 2
6916: PPUSH
6917: LD_INT 10
6919: PPUSH
6920: CALL_OW 241
6924: GO 6909
6926: POP
6927: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6928: LD_ADDR_VAR 0 9
6932: PUSH
6933: LD_INT 22
6935: PUSH
6936: LD_VAR 0 6
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: LD_INT 30
6947: PUSH
6948: LD_INT 34
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: ST_TO_ADDR
// if teleport then
6964: LD_VAR 0 9
6968: IFFALSE 6989
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6970: LD_VAR 0 9
6974: PUSH
6975: LD_INT 1
6977: ARRAY
6978: PPUSH
6979: LD_INT 123
6981: PPUSH
6982: LD_INT 122
6984: PPUSH
6985: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6989: LD_ADDR_EXP 61
6993: PUSH
6994: LD_STRING Platonov
6996: PPUSH
6997: CALL_OW 25
7001: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7002: LD_ADDR_EXP 62
7006: PUSH
7007: LD_STRING Kovalyuk
7009: PPUSH
7010: CALL_OW 25
7014: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7015: LD_ADDR_EXP 64
7019: PUSH
7020: LD_STRING Yakotich
7022: PPUSH
7023: CALL_OW 25
7027: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7028: LD_ADDR_EXP 63
7032: PUSH
7033: LD_STRING Bystrov
7035: PPUSH
7036: CALL_OW 25
7040: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7041: LD_ADDR_EXP 65
7045: PUSH
7046: LD_STRING Gleb
7048: PPUSH
7049: CALL_OW 25
7053: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7054: LD_STRING 03_Cornel
7056: PPUSH
7057: CALL_OW 28
7061: IFFALSE 7109
// begin Bierezov := NewCharacter ( Mikhail ) ;
7063: LD_ADDR_EXP 66
7067: PUSH
7068: LD_STRING Mikhail
7070: PPUSH
7071: CALL_OW 25
7075: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7076: LD_EXP 66
7080: PPUSH
7081: LD_INT 197
7083: PPUSH
7084: LD_INT 111
7086: PPUSH
7087: LD_INT 9
7089: PPUSH
7090: LD_INT 0
7092: PPUSH
7093: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7097: LD_EXP 66
7101: PPUSH
7102: LD_INT 3
7104: PPUSH
7105: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7109: LD_EXP 61
7113: PPUSH
7114: LD_INT 126
7116: PPUSH
7117: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7121: LD_EXP 62
7125: PPUSH
7126: LD_INT 134
7128: PPUSH
7129: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7133: LD_EXP 64
7137: PPUSH
7138: LD_INT 197
7140: PPUSH
7141: LD_INT 111
7143: PPUSH
7144: LD_INT 9
7146: PPUSH
7147: LD_INT 0
7149: PPUSH
7150: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7154: LD_EXP 63
7158: PPUSH
7159: LD_INT 197
7161: PPUSH
7162: LD_INT 111
7164: PPUSH
7165: LD_INT 9
7167: PPUSH
7168: LD_INT 0
7170: PPUSH
7171: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7175: LD_EXP 65
7179: PPUSH
7180: LD_INT 197
7182: PPUSH
7183: LD_INT 111
7185: PPUSH
7186: LD_INT 9
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7196: LD_ADDR_VAR 0 5
7200: PUSH
7201: LD_INT 126
7203: PPUSH
7204: LD_INT 4
7206: PPUSH
7207: LD_STRING zhukov
7209: PPUSH
7210: LD_INT 9
7212: PUSH
7213: LD_INT 10
7215: PUSH
7216: LD_INT 10
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_OWVAR 67
7228: ARRAY
7229: PPUSH
7230: LD_INT 99999
7232: PUSH
7233: LD_INT 1000
7235: PUSH
7236: LD_INT 300
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 12
7246: PUSH
7247: LD_INT 8
7249: PUSH
7250: LD_INT 13
7252: PUSH
7253: LD_INT 8
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PPUSH
7262: CALL 72995 0 6
7266: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7267: LD_ADDR_VAR 0 4
7271: PUSH
7272: LD_INT 267
7274: PPUSH
7275: CALL_OW 274
7279: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7280: LD_VAR 0 4
7284: PPUSH
7285: LD_INT 1
7287: PPUSH
7288: LD_INT 5000
7290: PPUSH
7291: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7295: LD_VAR 0 4
7299: PPUSH
7300: LD_INT 2
7302: PPUSH
7303: LD_INT 200
7305: PPUSH
7306: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7310: LD_VAR 0 4
7314: PPUSH
7315: LD_INT 3
7317: PPUSH
7318: LD_INT 200
7320: PPUSH
7321: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7325: LD_ADDR_EXP 99
7329: PUSH
7330: LD_EXP 99
7334: PPUSH
7335: LD_INT 2
7337: PPUSH
7338: LD_VAR 0 5
7342: PUSH
7343: LD_INT 22
7345: PUSH
7346: LD_VAR 0 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 21
7360: PUSH
7361: LD_INT 2
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL_OW 69
7380: UNION
7381: PUSH
7382: LD_EXP 61
7386: DIFF
7387: PPUSH
7388: CALL_OW 1
7392: ST_TO_ADDR
// behemoths := [ ] ;
7393: LD_ADDR_EXP 69
7397: PUSH
7398: EMPTY
7399: ST_TO_ADDR
// behemothBuilders := [ ] ;
7400: LD_ADDR_EXP 70
7404: PUSH
7405: EMPTY
7406: ST_TO_ADDR
// if Kovalyuk then
7407: LD_EXP 62
7411: IFFALSE 7433
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7413: LD_ADDR_EXP 70
7417: PUSH
7418: LD_EXP 70
7422: PPUSH
7423: LD_EXP 62
7427: PPUSH
7428: CALL 105331 0 2
7432: ST_TO_ADDR
// j := 3 ;
7433: LD_ADDR_VAR 0 3
7437: PUSH
7438: LD_INT 3
7440: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7441: LD_ADDR_VAR 0 2
7445: PUSH
7446: LD_INT 22
7448: PUSH
7449: LD_INT 3
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 25
7458: PUSH
7459: LD_INT 3
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: LD_EXP 62
7479: DIFF
7480: PUSH
7481: FOR_IN
7482: IFFALSE 7532
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7484: LD_ADDR_EXP 70
7488: PUSH
7489: LD_EXP 70
7493: PPUSH
7494: LD_VAR 0 2
7498: PPUSH
7499: CALL 105331 0 2
7503: ST_TO_ADDR
// j := j - 1 ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_VAR 0 3
7513: PUSH
7514: LD_INT 1
7516: MINUS
7517: ST_TO_ADDR
// if j = 0 then
7518: LD_VAR 0 3
7522: PUSH
7523: LD_INT 0
7525: EQUAL
7526: IFFALSE 7530
// break ;
7528: GO 7532
// end ;
7530: GO 7481
7532: POP
7533: POP
// end ;
7534: LD_VAR 0 1
7538: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7539: LD_INT 0
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7546: LD_ADDR_VAR 0 4
7550: PUSH
7551: LD_INT 209
7553: PUSH
7554: LD_INT 149
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 219
7563: PUSH
7564: LD_INT 154
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 223
7573: PUSH
7574: LD_INT 149
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 232
7583: PUSH
7584: LD_INT 155
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: ST_TO_ADDR
// if not behemothBuilders then
7597: LD_EXP 70
7601: NOT
7602: IFFALSE 7606
// exit ;
7604: GO 7710
// j := 1 ;
7606: LD_ADDR_VAR 0 3
7610: PUSH
7611: LD_INT 1
7613: ST_TO_ADDR
// for i in behemothBuilders do
7614: LD_ADDR_VAR 0 2
7618: PUSH
7619: LD_EXP 70
7623: PUSH
7624: FOR_IN
7625: IFFALSE 7708
// begin if IsInUnit ( i ) then
7627: LD_VAR 0 2
7631: PPUSH
7632: CALL_OW 310
7636: IFFALSE 7647
// ComExitBuilding ( i ) ;
7638: LD_VAR 0 2
7642: PPUSH
7643: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7647: LD_VAR 0 2
7651: PPUSH
7652: LD_INT 37
7654: PPUSH
7655: LD_VAR 0 4
7659: PUSH
7660: LD_VAR 0 3
7664: ARRAY
7665: PUSH
7666: LD_INT 1
7668: ARRAY
7669: PPUSH
7670: LD_VAR 0 4
7674: PUSH
7675: LD_VAR 0 3
7679: ARRAY
7680: PUSH
7681: LD_INT 2
7683: ARRAY
7684: PPUSH
7685: LD_INT 0
7687: PPUSH
7688: CALL_OW 230
// j := j + 1 ;
7692: LD_ADDR_VAR 0 3
7696: PUSH
7697: LD_VAR 0 3
7701: PUSH
7702: LD_INT 1
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7624
7708: POP
7709: POP
// end ;
7710: LD_VAR 0 1
7714: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7715: LD_INT 24
7717: PPUSH
7718: LD_INT 30
7720: PUSH
7721: LD_INT 37
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PPUSH
7728: CALL_OW 70
7732: IFFALSE 7745
7734: GO 7736
7736: DISABLE
// behemothUnderConstruct := true ;
7737: LD_ADDR_EXP 26
7741: PUSH
7742: LD_INT 1
7744: ST_TO_ADDR
7745: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7746: LD_INT 3
7748: PPUSH
7749: CALL 105379 0 1
7753: PUSH
7754: LD_INT 22
7756: PUSH
7757: LD_INT 3
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 30
7766: PUSH
7767: LD_INT 37
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: PPUSH
7778: CALL_OW 69
7782: NOT
7783: AND
7784: IFFALSE 7970
7786: GO 7788
7788: DISABLE
7789: LD_INT 0
7791: PPUSH
7792: PPUSH
// begin enable ;
7793: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7794: LD_ADDR_VAR 0 2
7798: PUSH
7799: LD_INT 3
7801: PPUSH
7802: CALL 105379 0 1
7806: ST_TO_ADDR
// for i in tmp do
7807: LD_ADDR_VAR 0 1
7811: PUSH
7812: LD_VAR 0 2
7816: PUSH
7817: FOR_IN
7818: IFFALSE 7968
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7820: LD_VAR 0 1
7824: PPUSH
7825: LD_INT 9
7827: PPUSH
7828: CALL_OW 308
7832: PUSH
7833: LD_VAR 0 1
7837: PPUSH
7838: CALL_OW 110
7842: PUSH
7843: LD_INT 2
7845: EQUAL
7846: NOT
7847: AND
7848: IFFALSE 7862
// SetTag ( i , 2 ) ;
7850: LD_VAR 0 1
7854: PPUSH
7855: LD_INT 2
7857: PPUSH
7858: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7862: LD_INT 81
7864: PUSH
7865: LD_INT 3
7867: PUSH
7868: EMPTY
7869: LIST
7870: LIST
7871: PUSH
7872: LD_INT 91
7874: PUSH
7875: LD_VAR 0 1
7879: PUSH
7880: LD_INT 12
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: PUSH
7898: LD_VAR 0 1
7902: PPUSH
7903: CALL_OW 110
7907: PUSH
7908: LD_INT 2
7910: EQUAL
7911: NOT
7912: AND
7913: IFFALSE 7932
// ComAgressiveMove ( i , 64 , 93 ) else
7915: LD_VAR 0 1
7919: PPUSH
7920: LD_INT 64
7922: PPUSH
7923: LD_INT 93
7925: PPUSH
7926: CALL_OW 114
7930: GO 7966
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7932: LD_VAR 0 1
7936: PPUSH
7937: LD_INT 81
7939: PUSH
7940: LD_INT 3
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PPUSH
7947: CALL_OW 69
7951: PPUSH
7952: LD_VAR 0 1
7956: PPUSH
7957: CALL_OW 74
7961: PPUSH
7962: CALL_OW 115
// end ;
7966: GO 7817
7968: POP
7969: POP
// end ;
7970: PPOPN 2
7972: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7973: LD_INT 0
7975: PPUSH
7976: PPUSH
7977: PPUSH
// result := [ ] ;
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: EMPTY
7984: ST_TO_ADDR
// uc_side := 6 ;
7985: LD_ADDR_OWVAR 20
7989: PUSH
7990: LD_INT 6
7992: ST_TO_ADDR
// uc_nation := 3 ;
7993: LD_ADDR_OWVAR 21
7997: PUSH
7998: LD_INT 3
8000: ST_TO_ADDR
// case strength of 1 :
8001: LD_VAR 0 1
8005: PUSH
8006: LD_INT 1
8008: DOUBLE
8009: EQUAL
8010: IFTRUE 8014
8012: GO 8152
8014: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8015: LD_ADDR_VAR 0 3
8019: PUSH
8020: DOUBLE
8021: LD_INT 1
8023: DEC
8024: ST_TO_ADDR
8025: LD_INT 4
8027: PUSH
8028: LD_INT 5
8030: PUSH
8031: LD_INT 6
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: LIST
8038: PUSH
8039: LD_OWVAR 67
8043: ARRAY
8044: PUSH
8045: FOR_TO
8046: IFFALSE 8148
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8048: LD_INT 22
8050: PUSH
8051: LD_INT 24
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: PUSH
8058: LD_VAR 0 3
8062: PUSH
8063: LD_INT 2
8065: MOD
8066: PUSH
8067: LD_INT 1
8069: PLUS
8070: ARRAY
8071: PPUSH
8072: LD_INT 1
8074: PUSH
8075: LD_INT 3
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 1
8084: PPUSH
8085: LD_INT 2
8087: PPUSH
8088: CALL_OW 12
8092: ARRAY
8093: PPUSH
8094: LD_INT 3
8096: PPUSH
8097: LD_INT 43
8099: PUSH
8100: LD_INT 44
8102: PUSH
8103: LD_INT 45
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: LIST
8110: PUSH
8111: LD_INT 1
8113: PPUSH
8114: LD_INT 3
8116: PPUSH
8117: CALL_OW 12
8121: ARRAY
8122: PPUSH
8123: LD_INT 80
8125: PPUSH
8126: CALL 69586 0 5
// result := result union CreateVehicle ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_VAR 0 2
8139: PUSH
8140: CALL_OW 45
8144: UNION
8145: ST_TO_ADDR
// end ;
8146: GO 8045
8148: POP
8149: POP
// end ; 2 :
8150: GO 9096
8152: LD_INT 2
8154: DOUBLE
8155: EQUAL
8156: IFTRUE 8160
8158: GO 8316
8160: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8161: LD_ADDR_VAR 0 3
8165: PUSH
8166: DOUBLE
8167: LD_INT 1
8169: DEC
8170: ST_TO_ADDR
8171: LD_INT 6
8173: PUSH
8174: LD_INT 6
8176: PUSH
8177: LD_INT 7
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: LIST
8184: PUSH
8185: LD_OWVAR 67
8189: ARRAY
8190: PUSH
8191: FOR_TO
8192: IFFALSE 8312
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8194: LD_INT 22
8196: PUSH
8197: LD_INT 24
8199: PUSH
8200: LD_INT 24
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: LD_VAR 0 3
8212: PUSH
8213: LD_INT 3
8215: MOD
8216: PUSH
8217: LD_INT 1
8219: PLUS
8220: ARRAY
8221: PPUSH
8222: LD_INT 1
8224: PUSH
8225: LD_INT 3
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 1
8234: PPUSH
8235: LD_INT 2
8237: PPUSH
8238: CALL_OW 12
8242: ARRAY
8243: PPUSH
8244: LD_INT 3
8246: PPUSH
8247: LD_INT 43
8249: PUSH
8250: LD_INT 44
8252: PUSH
8253: LD_INT 45
8255: PUSH
8256: LD_INT 44
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: LD_INT 46
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: PUSH
8273: LD_VAR 0 3
8277: PUSH
8278: LD_INT 6
8280: MOD
8281: PUSH
8282: LD_INT 1
8284: PLUS
8285: ARRAY
8286: PPUSH
8287: LD_INT 80
8289: PPUSH
8290: CALL 69586 0 5
// result := result union CreateVehicle ;
8294: LD_ADDR_VAR 0 2
8298: PUSH
8299: LD_VAR 0 2
8303: PUSH
8304: CALL_OW 45
8308: UNION
8309: ST_TO_ADDR
// end ;
8310: GO 8191
8312: POP
8313: POP
// end ; 3 :
8314: GO 9096
8316: LD_INT 3
8318: DOUBLE
8319: EQUAL
8320: IFTRUE 8324
8322: GO 8480
8324: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8325: LD_ADDR_VAR 0 3
8329: PUSH
8330: DOUBLE
8331: LD_INT 1
8333: DEC
8334: ST_TO_ADDR
8335: LD_INT 6
8337: PUSH
8338: LD_INT 7
8340: PUSH
8341: LD_INT 8
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: LIST
8348: PUSH
8349: LD_OWVAR 67
8353: ARRAY
8354: PUSH
8355: FOR_TO
8356: IFFALSE 8476
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8358: LD_INT 22
8360: PUSH
8361: LD_INT 24
8363: PUSH
8364: LD_INT 24
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: LIST
8371: PUSH
8372: LD_VAR 0 3
8376: PUSH
8377: LD_INT 3
8379: MOD
8380: PUSH
8381: LD_INT 1
8383: PLUS
8384: ARRAY
8385: PPUSH
8386: LD_INT 1
8388: PUSH
8389: LD_INT 3
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 1
8398: PPUSH
8399: LD_INT 2
8401: PPUSH
8402: CALL_OW 12
8406: ARRAY
8407: PPUSH
8408: LD_INT 3
8410: PPUSH
8411: LD_INT 43
8413: PUSH
8414: LD_INT 47
8416: PUSH
8417: LD_INT 45
8419: PUSH
8420: LD_INT 45
8422: PUSH
8423: LD_INT 46
8425: PUSH
8426: LD_INT 46
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: LIST
8435: LIST
8436: PUSH
8437: LD_VAR 0 3
8441: PUSH
8442: LD_INT 6
8444: MOD
8445: PUSH
8446: LD_INT 1
8448: PLUS
8449: ARRAY
8450: PPUSH
8451: LD_INT 80
8453: PPUSH
8454: CALL 69586 0 5
// result := result union CreateVehicle ;
8458: LD_ADDR_VAR 0 2
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: CALL_OW 45
8472: UNION
8473: ST_TO_ADDR
// end ;
8474: GO 8355
8476: POP
8477: POP
// end ; 4 :
8478: GO 9096
8480: LD_INT 4
8482: DOUBLE
8483: EQUAL
8484: IFTRUE 8488
8486: GO 9095
8488: POP
// begin uc_nation := 3 ;
8489: LD_ADDR_OWVAR 21
8493: PUSH
8494: LD_INT 3
8496: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: DOUBLE
8503: LD_INT 1
8505: DEC
8506: ST_TO_ADDR
8507: LD_INT 7
8509: PUSH
8510: LD_INT 8
8512: PUSH
8513: LD_INT 9
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: LIST
8520: PUSH
8521: LD_OWVAR 67
8525: ARRAY
8526: PUSH
8527: FOR_TO
8528: IFFALSE 8648
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8530: LD_INT 22
8532: PUSH
8533: LD_INT 24
8535: PUSH
8536: LD_INT 24
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_VAR 0 3
8548: PUSH
8549: LD_INT 3
8551: MOD
8552: PUSH
8553: LD_INT 1
8555: PLUS
8556: ARRAY
8557: PPUSH
8558: LD_INT 1
8560: PUSH
8561: LD_INT 3
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 2
8573: PPUSH
8574: CALL_OW 12
8578: ARRAY
8579: PPUSH
8580: LD_INT 3
8582: PPUSH
8583: LD_INT 45
8585: PUSH
8586: LD_INT 47
8588: PUSH
8589: LD_INT 47
8591: PUSH
8592: LD_INT 45
8594: PUSH
8595: LD_INT 46
8597: PUSH
8598: LD_INT 46
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: PUSH
8609: LD_VAR 0 3
8613: PUSH
8614: LD_INT 6
8616: MOD
8617: PUSH
8618: LD_INT 1
8620: PLUS
8621: ARRAY
8622: PPUSH
8623: LD_INT 80
8625: PPUSH
8626: CALL 69586 0 5
// result := result union CreateVehicle ;
8630: LD_ADDR_VAR 0 2
8634: PUSH
8635: LD_VAR 0 2
8639: PUSH
8640: CALL_OW 45
8644: UNION
8645: ST_TO_ADDR
// end ;
8646: GO 8527
8648: POP
8649: POP
// if not KappaStatus then
8650: LD_EXP 2
8654: NOT
8655: IFFALSE 8890
// begin uc_nation := 1 ;
8657: LD_ADDR_OWVAR 21
8661: PUSH
8662: LD_INT 1
8664: ST_TO_ADDR
// for i = 1 to 3 do
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: DOUBLE
8671: LD_INT 1
8673: DEC
8674: ST_TO_ADDR
8675: LD_INT 3
8677: PUSH
8678: FOR_TO
8679: IFFALSE 8815
// begin j := rand ( 0 , 1 ) ;
8681: LD_ADDR_VAR 0 4
8685: PUSH
8686: LD_INT 0
8688: PPUSH
8689: LD_INT 1
8691: PPUSH
8692: CALL_OW 12
8696: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8697: LD_INT 3
8699: PUSH
8700: LD_INT 5
8702: PUSH
8703: LD_INT 5
8705: PUSH
8706: LD_INT 4
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: PUSH
8715: LD_VAR 0 4
8719: PUSH
8720: LD_INT 1
8722: PPUSH
8723: LD_INT 3
8725: PPUSH
8726: CALL_OW 12
8730: PLUS
8731: ARRAY
8732: PPUSH
8733: LD_INT 1
8735: PUSH
8736: LD_INT 3
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: PUSH
8743: LD_INT 1
8745: PPUSH
8746: LD_INT 2
8748: PPUSH
8749: CALL_OW 12
8753: ARRAY
8754: PPUSH
8755: LD_INT 3
8757: PPUSH
8758: LD_INT 9
8760: PUSH
8761: LD_INT 7
8763: PUSH
8764: LD_INT 6
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: LIST
8771: PUSH
8772: LD_VAR 0 4
8776: PUSH
8777: LD_INT 1
8779: PPUSH
8780: LD_INT 2
8782: PPUSH
8783: CALL_OW 12
8787: PLUS
8788: ARRAY
8789: PPUSH
8790: LD_INT 85
8792: PPUSH
8793: CALL 69586 0 5
// result := result union CreateVehicle ;
8797: LD_ADDR_VAR 0 2
8801: PUSH
8802: LD_VAR 0 2
8806: PUSH
8807: CALL_OW 45
8811: UNION
8812: ST_TO_ADDR
// end ;
8813: GO 8678
8815: POP
8816: POP
// if vsevolodFirstAttack then
8817: LD_EXP 24
8821: IFFALSE 8888
// begin vsevolodFirstAttack := false ;
8823: LD_ADDR_EXP 24
8827: PUSH
8828: LD_INT 0
8830: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8831: LD_INT 5
8833: PPUSH
8834: LD_INT 3
8836: PPUSH
8837: LD_INT 1
8839: PPUSH
8840: LD_INT 6
8842: PPUSH
8843: LD_INT 100
8845: PPUSH
8846: CALL 69586 0 5
// sewiVeh := CreateVehicle ;
8850: LD_ADDR_EXP 68
8854: PUSH
8855: CALL_OW 45
8859: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8860: LD_EXP 68
8864: PPUSH
8865: LD_INT 1
8867: PPUSH
8868: CALL_OW 242
// result := result union sewiVeh ;
8872: LD_ADDR_VAR 0 2
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: LD_EXP 68
8886: UNION
8887: ST_TO_ADDR
// end ; end else
8888: GO 9093
// if vsevolodFirstAttack then
8890: LD_EXP 24
8894: IFFALSE 9093
// begin vsevolodFirstAttack := false ;
8896: LD_ADDR_EXP 24
8900: PUSH
8901: LD_INT 0
8903: ST_TO_ADDR
// uc_nation := 3 ;
8904: LD_ADDR_OWVAR 21
8908: PUSH
8909: LD_INT 3
8911: ST_TO_ADDR
// for i = 1 to 3 do
8912: LD_ADDR_VAR 0 3
8916: PUSH
8917: DOUBLE
8918: LD_INT 1
8920: DEC
8921: ST_TO_ADDR
8922: LD_INT 3
8924: PUSH
8925: FOR_TO
8926: IFFALSE 9034
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8928: LD_INT 22
8930: PUSH
8931: LD_INT 24
8933: PUSH
8934: LD_INT 24
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: LIST
8941: PUSH
8942: LD_VAR 0 3
8946: PUSH
8947: LD_INT 3
8949: MOD
8950: PUSH
8951: LD_INT 1
8953: PLUS
8954: ARRAY
8955: PPUSH
8956: LD_INT 1
8958: PUSH
8959: LD_INT 3
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 2
8971: PPUSH
8972: CALL_OW 12
8976: ARRAY
8977: PPUSH
8978: LD_INT 3
8980: PPUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 47
8986: PUSH
8987: LD_INT 47
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_INT 3
9002: MOD
9003: PUSH
9004: LD_INT 1
9006: PLUS
9007: ARRAY
9008: PPUSH
9009: LD_INT 80
9011: PPUSH
9012: CALL 69586 0 5
// result := result union CreateVehicle ;
9016: LD_ADDR_VAR 0 2
9020: PUSH
9021: LD_VAR 0 2
9025: PUSH
9026: CALL_OW 45
9030: UNION
9031: ST_TO_ADDR
// end ;
9032: GO 8925
9034: POP
9035: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9036: LD_INT 24
9038: PPUSH
9039: LD_INT 3
9041: PPUSH
9042: LD_INT 1
9044: PPUSH
9045: LD_INT 47
9047: PPUSH
9048: LD_INT 100
9050: PPUSH
9051: CALL 69586 0 5
// sewiVeh := CreateVehicle ;
9055: LD_ADDR_EXP 68
9059: PUSH
9060: CALL_OW 45
9064: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9065: LD_EXP 68
9069: PPUSH
9070: LD_INT 1
9072: PPUSH
9073: CALL_OW 242
// result := result union sewiVeh ;
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_VAR 0 2
9086: PUSH
9087: LD_EXP 68
9091: UNION
9092: ST_TO_ADDR
// end ; end ; end ;
9093: GO 9096
9095: POP
// end ;
9096: LD_VAR 0 2
9100: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9101: LD_EXP 16
9105: IFFALSE 9853
9107: GO 9109
9109: DISABLE
9110: LD_INT 0
9112: PPUSH
9113: PPUSH
9114: PPUSH
9115: PPUSH
9116: PPUSH
9117: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9118: LD_ADDR_VAR 0 4
9122: PUSH
9123: LD_INT 11
9125: PUSH
9126: LD_INT 12
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9133: LD_ADDR_VAR 0 3
9137: PUSH
9138: LD_INT 8400
9140: PUSH
9141: LD_INT 7350
9143: PUSH
9144: LD_INT 6650
9146: PUSH
9147: EMPTY
9148: LIST
9149: LIST
9150: LIST
9151: PUSH
9152: LD_OWVAR 67
9156: ARRAY
9157: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9158: LD_ADDR_VAR 0 6
9162: PUSH
9163: LD_INT 70
9165: PUSH
9166: LD_INT 118
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: PUSH
9173: LD_INT 78
9175: PUSH
9176: LD_INT 31
9178: PUSH
9179: EMPTY
9180: LIST
9181: LIST
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: ST_TO_ADDR
// repeat if missionStage = 2 then
9187: LD_EXP 15
9191: PUSH
9192: LD_INT 2
9194: EQUAL
9195: IFFALSE 9206
// wait ( 1 1$30 ) else
9197: LD_INT 3150
9199: PPUSH
9200: CALL_OW 67
9204: GO 9215
// wait ( time ) ;
9206: LD_VAR 0 3
9210: PPUSH
9211: CALL_OW 67
// if missionStage = 6 then
9215: LD_EXP 15
9219: PUSH
9220: LD_INT 6
9222: EQUAL
9223: IFFALSE 9251
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9225: LD_INT 51
9227: PPUSH
9228: LD_INT 6
9230: PPUSH
9231: LD_INT 2
9233: PPUSH
9234: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9238: LD_INT 57
9240: PPUSH
9241: LD_INT 6
9243: PPUSH
9244: LD_INT 2
9246: PPUSH
9247: CALL_OW 322
// end ; if missionStage = 8 then
9251: LD_EXP 15
9255: PUSH
9256: LD_INT 8
9258: EQUAL
9259: IFFALSE 9287
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9261: LD_INT 52
9263: PPUSH
9264: LD_INT 6
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9274: LD_INT 58
9276: PPUSH
9277: LD_INT 6
9279: PPUSH
9280: LD_INT 2
9282: PPUSH
9283: CALL_OW 322
// end ; if missionStage = 10 then
9287: LD_EXP 15
9291: PUSH
9292: LD_INT 10
9294: EQUAL
9295: IFFALSE 9323
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9297: LD_INT 53
9299: PPUSH
9300: LD_INT 6
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9310: LD_INT 59
9312: PPUSH
9313: LD_INT 6
9315: PPUSH
9316: LD_INT 2
9318: PPUSH
9319: CALL_OW 322
// end ; if activeAttacks then
9323: LD_EXP 16
9327: IFFALSE 9847
// begin if missionStage = 2 then
9329: LD_EXP 15
9333: PUSH
9334: LD_INT 2
9336: EQUAL
9337: IFFALSE 9347
// strength := 1 ;
9339: LD_ADDR_VAR 0 5
9343: PUSH
9344: LD_INT 1
9346: ST_TO_ADDR
// if missionStage > 2 then
9347: LD_EXP 15
9351: PUSH
9352: LD_INT 2
9354: GREATER
9355: IFFALSE 9365
// strength := 2 ;
9357: LD_ADDR_VAR 0 5
9361: PUSH
9362: LD_INT 2
9364: ST_TO_ADDR
// if missionStage > 6 then
9365: LD_EXP 15
9369: PUSH
9370: LD_INT 6
9372: GREATER
9373: IFFALSE 9383
// strength := 3 ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_INT 3
9382: ST_TO_ADDR
// if missionStage > 10 then
9383: LD_EXP 15
9387: PUSH
9388: LD_INT 10
9390: GREATER
9391: IFFALSE 9401
// strength := 4 ;
9393: LD_ADDR_VAR 0 5
9397: PUSH
9398: LD_INT 4
9400: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9401: LD_ADDR_VAR 0 2
9405: PUSH
9406: LD_VAR 0 5
9410: PPUSH
9411: CALL 7973 0 1
9415: ST_TO_ADDR
// for i in tmp do
9416: LD_ADDR_VAR 0 1
9420: PUSH
9421: LD_VAR 0 2
9425: PUSH
9426: FOR_IN
9427: IFFALSE 9527
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9429: LD_VAR 0 1
9433: PPUSH
9434: LD_VAR 0 4
9438: PUSH
9439: LD_INT 1
9441: PPUSH
9442: LD_INT 2
9444: PPUSH
9445: CALL_OW 12
9449: ARRAY
9450: PPUSH
9451: LD_INT 0
9453: PPUSH
9454: CALL_OW 49
// if i = sewiVeh then
9458: LD_VAR 0 1
9462: PUSH
9463: LD_EXP 68
9467: EQUAL
9468: IFFALSE 9503
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9470: LD_ADDR_EXP 67
9474: PUSH
9475: LD_STRING Vsevolod
9477: PPUSH
9478: LD_INT 0
9480: PPUSH
9481: LD_STRING 
9483: PPUSH
9484: CALL 62975 0 3
9488: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9489: LD_EXP 67
9493: PPUSH
9494: LD_VAR 0 1
9498: PPUSH
9499: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_INT 111
9510: PPUSH
9511: LD_INT 197
9513: PPUSH
9514: CALL_OW 111
// wait ( 0 0$2 ) ;
9518: LD_INT 70
9520: PPUSH
9521: CALL_OW 67
// end ;
9525: GO 9426
9527: POP
9528: POP
// repeat wait ( 0 0$1 ) ;
9529: LD_INT 35
9531: PPUSH
9532: CALL_OW 67
// for i in tmp do
9536: LD_ADDR_VAR 0 1
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: FOR_IN
9547: IFFALSE 9828
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9549: LD_INT 81
9551: PUSH
9552: LD_INT 6
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: LD_INT 91
9561: PUSH
9562: LD_VAR 0 1
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PPUSH
9579: CALL_OW 69
9583: IFFALSE 9641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9585: LD_VAR 0 1
9589: PPUSH
9590: LD_INT 81
9592: PUSH
9593: LD_INT 6
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 92
9602: PUSH
9603: LD_VAR 0 1
9607: PUSH
9608: LD_INT 12
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: PPUSH
9620: CALL_OW 69
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 74
9634: PPUSH
9635: CALL_OW 115
9639: GO 9826
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9641: LD_INT 9
9643: PPUSH
9644: LD_INT 81
9646: PUSH
9647: LD_INT 6
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PPUSH
9654: CALL_OW 70
9658: IFFALSE 9792
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9660: LD_VAR 0 1
9664: PPUSH
9665: LD_VAR 0 6
9669: PUSH
9670: LD_INT 1
9672: ARRAY
9673: PUSH
9674: LD_INT 1
9676: ARRAY
9677: PPUSH
9678: LD_VAR 0 6
9682: PUSH
9683: LD_INT 1
9685: ARRAY
9686: PUSH
9687: LD_INT 2
9689: ARRAY
9690: PPUSH
9691: CALL_OW 297
9695: PUSH
9696: LD_INT 10
9698: GREATER
9699: PUSH
9700: LD_VAR 0 1
9704: PPUSH
9705: LD_INT 9
9707: PPUSH
9708: CALL_OW 308
9712: NOT
9713: AND
9714: IFFALSE 9753
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9716: LD_VAR 0 1
9720: PPUSH
9721: LD_VAR 0 6
9725: PUSH
9726: LD_INT 1
9728: ARRAY
9729: PUSH
9730: LD_INT 1
9732: ARRAY
9733: PPUSH
9734: LD_VAR 0 6
9738: PUSH
9739: LD_INT 1
9741: ARRAY
9742: PUSH
9743: LD_INT 2
9745: ARRAY
9746: PPUSH
9747: CALL_OW 114
9751: GO 9790
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9753: LD_VAR 0 1
9757: PPUSH
9758: LD_INT 9
9760: PPUSH
9761: LD_INT 81
9763: PUSH
9764: LD_INT 6
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 70
9775: PPUSH
9776: LD_VAR 0 1
9780: PPUSH
9781: CALL_OW 74
9785: PPUSH
9786: CALL_OW 115
// end else
9790: GO 9826
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9792: LD_VAR 0 1
9796: PPUSH
9797: LD_INT 81
9799: PUSH
9800: LD_INT 6
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PPUSH
9807: CALL_OW 69
9811: PPUSH
9812: LD_VAR 0 1
9816: PPUSH
9817: CALL_OW 74
9821: PPUSH
9822: CALL_OW 115
// end ;
9826: GO 9546
9828: POP
9829: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9830: LD_INT 22
9832: PUSH
9833: LD_INT 6
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PPUSH
9840: CALL_OW 69
9844: NOT
9845: IFFALSE 9529
// end ; until russianDestroyed ;
9847: LD_EXP 21
9851: IFFALSE 9187
// end ;
9853: PPOPN 6
9855: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9856: LD_EXP 21
9860: NOT
9861: PUSH
9862: LD_EXP 15
9866: PUSH
9867: LD_INT 6
9869: GREATEREQUAL
9870: AND
9871: PUSH
9872: LD_INT 2
9874: PPUSH
9875: LD_INT 1
9877: PPUSH
9878: CALL 58328 0 2
9882: NOT
9883: AND
9884: IFFALSE 10840
9886: GO 9888
9888: DISABLE
9889: LD_INT 0
9891: PPUSH
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin enable ;
9895: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9896: LD_INT 22
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 30
9908: PUSH
9909: LD_INT 3
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PPUSH
9920: CALL_OW 69
9924: NOT
9925: IFFALSE 9929
// exit ;
9927: GO 10840
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9929: LD_ADDR_VAR 0 4
9933: PUSH
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 34
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: ST_TO_ADDR
// if Prob ( 40 ) then
9963: LD_INT 40
9965: PPUSH
9966: CALL_OW 13
9970: IFFALSE 10097
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9972: LD_INT 2
9974: PPUSH
9975: LD_INT 22
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 49
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_INT 3
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 49
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 49
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 24
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 3
10037: PUSH
10038: LD_INT 46
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 24
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: LD_INT 46
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: PUSH
10065: LD_INT 24
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: LD_INT 46
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: PPUSH
10091: CALL 56973 0 2
// end else
10095: GO 10220
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10097: LD_INT 2
10099: PPUSH
10100: LD_INT 24
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 47
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 24
10120: PUSH
10121: LD_INT 3
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 47
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 24
10138: PUSH
10139: LD_INT 3
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 24
10156: PUSH
10157: LD_INT 3
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: LD_INT 46
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_INT 24
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: LD_INT 3
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: LD_INT 24
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 3
10198: PUSH
10199: LD_INT 46
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: PPUSH
10216: CALL 56973 0 2
// end ; if Difficulty > 1 then
10220: LD_OWVAR 67
10224: PUSH
10225: LD_INT 1
10227: GREATER
10228: IFFALSE 10258
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10230: LD_INT 2
10232: PPUSH
10233: LD_INT 24
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: LD_INT 47
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: EMPTY
10252: LIST
10253: PPUSH
10254: CALL 56973 0 2
// repeat wait ( 0 0$1 ) ;
10258: LD_INT 35
10260: PPUSH
10261: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10265: LD_INT 2
10267: PPUSH
10268: LD_INT 1
10270: PPUSH
10271: CALL 58328 0 2
10275: PUSH
10276: LD_INT 6
10278: PUSH
10279: LD_INT 7
10281: PUSH
10282: LD_INT 7
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: LIST
10289: PUSH
10290: LD_OWVAR 67
10294: ARRAY
10295: GREATEREQUAL
10296: IFFALSE 10258
// wait ( 0 0$30 ) ;
10298: LD_INT 1050
10300: PPUSH
10301: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10305: LD_ADDR_VAR 0 2
10309: PUSH
10310: LD_INT 2
10312: PPUSH
10313: LD_INT 1
10315: PPUSH
10316: CALL 58328 0 2
10320: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10321: LD_ADDR_EXP 118
10325: PUSH
10326: LD_EXP 118
10330: PPUSH
10331: LD_INT 2
10333: PPUSH
10334: LD_EXP 118
10338: PUSH
10339: LD_INT 2
10341: ARRAY
10342: PUSH
10343: LD_VAR 0 2
10347: DIFF
10348: PPUSH
10349: CALL_OW 1
10353: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10354: LD_ADDR_VAR 0 3
10358: PUSH
10359: LD_INT 0
10361: PPUSH
10362: LD_INT 1
10364: PPUSH
10365: CALL_OW 12
10369: ST_TO_ADDR
// if target then
10370: LD_VAR 0 3
10374: IFFALSE 10502
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10376: LD_ADDR_VAR 0 2
10380: PUSH
10381: LD_VAR 0 2
10385: PPUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 250
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: PPUSH
10396: CALL_OW 72
10400: ST_TO_ADDR
// for i in tmp do
10401: LD_ADDR_VAR 0 1
10405: PUSH
10406: LD_VAR 0 2
10410: PUSH
10411: FOR_IN
10412: IFFALSE 10452
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10414: LD_VAR 0 1
10418: PPUSH
10419: LD_INT 139
10421: PPUSH
10422: LD_INT 89
10424: PPUSH
10425: CALL_OW 297
10429: PUSH
10430: LD_INT 9
10432: GREATER
10433: IFFALSE 10450
// ComMoveXY ( i , 139 , 89 ) ;
10435: LD_VAR 0 1
10439: PPUSH
10440: LD_INT 139
10442: PPUSH
10443: LD_INT 89
10445: PPUSH
10446: CALL_OW 111
10450: GO 10411
10452: POP
10453: POP
// wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10461: LD_VAR 0 2
10465: PPUSH
10466: LD_INT 92
10468: PUSH
10469: LD_INT 139
10471: PUSH
10472: LD_INT 89
10474: PUSH
10475: LD_INT 9
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 72
10488: PUSH
10489: LD_VAR 0 2
10493: PUSH
10494: LD_INT 1
10496: MINUS
10497: GREATEREQUAL
10498: IFFALSE 10376
// end else
10500: GO 10644
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10502: LD_VAR 0 2
10506: PPUSH
10507: LD_VAR 0 4
10511: PUSH
10512: LD_INT 1
10514: ARRAY
10515: PPUSH
10516: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10520: LD_ADDR_VAR 0 2
10524: PUSH
10525: LD_VAR 0 2
10529: PPUSH
10530: LD_INT 24
10532: PUSH
10533: LD_INT 250
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: PPUSH
10540: CALL_OW 72
10544: ST_TO_ADDR
// for i in tmp do
10545: LD_ADDR_VAR 0 1
10549: PUSH
10550: LD_VAR 0 2
10554: PUSH
10555: FOR_IN
10556: IFFALSE 10596
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10558: LD_VAR 0 1
10562: PPUSH
10563: LD_INT 124
10565: PPUSH
10566: LD_INT 139
10568: PPUSH
10569: CALL_OW 297
10573: PUSH
10574: LD_INT 9
10576: GREATER
10577: IFFALSE 10594
// ComMoveXY ( i , 124 , 139 ) ;
10579: LD_VAR 0 1
10583: PPUSH
10584: LD_INT 124
10586: PPUSH
10587: LD_INT 139
10589: PPUSH
10590: CALL_OW 111
10594: GO 10555
10596: POP
10597: POP
// wait ( 0 0$1 ) ;
10598: LD_INT 35
10600: PPUSH
10601: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10605: LD_VAR 0 2
10609: PPUSH
10610: LD_INT 92
10612: PUSH
10613: LD_INT 124
10615: PUSH
10616: LD_INT 139
10618: PUSH
10619: LD_INT 9
10621: PUSH
10622: EMPTY
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: PPUSH
10628: CALL_OW 72
10632: PUSH
10633: LD_VAR 0 2
10637: PUSH
10638: LD_INT 1
10640: MINUS
10641: GREATEREQUAL
10642: IFFALSE 10520
// end ; repeat wait ( 0 0$1 ) ;
10644: LD_INT 35
10646: PPUSH
10647: CALL_OW 67
// for i in tmp do
10651: LD_ADDR_VAR 0 1
10655: PUSH
10656: LD_VAR 0 2
10660: PUSH
10661: FOR_IN
10662: IFFALSE 10831
// begin if GetLives ( i ) > 251 then
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 256
10673: PUSH
10674: LD_INT 251
10676: GREATER
10677: IFFALSE 10802
// begin if GetWeapon ( i ) = ru_time_lapser then
10679: LD_VAR 0 1
10683: PPUSH
10684: CALL_OW 264
10688: PUSH
10689: LD_INT 49
10691: EQUAL
10692: IFFALSE 10748
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10694: LD_VAR 0 1
10698: PPUSH
10699: LD_INT 2
10701: PUSH
10702: LD_INT 22
10704: PUSH
10705: LD_INT 1
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 22
10714: PUSH
10715: LD_INT 8
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: LIST
10726: PPUSH
10727: CALL_OW 69
10731: PPUSH
10732: LD_VAR 0 1
10736: PPUSH
10737: CALL_OW 74
10741: PPUSH
10742: CALL_OW 112
10746: GO 10800
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10748: LD_VAR 0 1
10752: PPUSH
10753: LD_INT 2
10755: PUSH
10756: LD_INT 22
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 8
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PPUSH
10786: LD_VAR 0 1
10790: PPUSH
10791: CALL_OW 74
10795: PPUSH
10796: CALL_OW 115
// end else
10800: GO 10829
// if IsDead ( i ) then
10802: LD_VAR 0 1
10806: PPUSH
10807: CALL_OW 301
10811: IFFALSE 10829
// tmp := tmp diff i ;
10813: LD_ADDR_VAR 0 2
10817: PUSH
10818: LD_VAR 0 2
10822: PUSH
10823: LD_VAR 0 1
10827: DIFF
10828: ST_TO_ADDR
// end ;
10829: GO 10661
10831: POP
10832: POP
// until not tmp ;
10833: LD_VAR 0 2
10837: NOT
10838: IFFALSE 10644
// end ; end_of_file
10840: PPOPN 4
10842: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10843: LD_INT 0
10845: PPUSH
10846: PPUSH
10847: PPUSH
10848: PPUSH
10849: PPUSH
10850: PPUSH
// side := 7 ;
10851: LD_ADDR_VAR 0 5
10855: PUSH
10856: LD_INT 7
10858: ST_TO_ADDR
// uc_side := side ;
10859: LD_ADDR_OWVAR 20
10863: PUSH
10864: LD_VAR 0 5
10868: ST_TO_ADDR
// uc_nation := 1 ;
10869: LD_ADDR_OWVAR 21
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10877: LD_ADDR_VAR 0 2
10881: PUSH
10882: LD_INT 22
10884: PUSH
10885: LD_VAR 0 5
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: LD_INT 21
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: PPUSH
10908: CALL_OW 69
10912: PUSH
10913: FOR_IN
10914: IFFALSE 10930
// SetBLevel ( i , 10 ) ;
10916: LD_VAR 0 2
10920: PPUSH
10921: LD_INT 10
10923: PPUSH
10924: CALL_OW 241
10928: GO 10913
10930: POP
10931: POP
// base := GetBase ( al_depot ) ;
10932: LD_ADDR_VAR 0 4
10936: PUSH
10937: LD_INT 2
10939: PPUSH
10940: CALL_OW 274
10944: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10945: LD_ADDR_VAR 0 6
10949: PUSH
10950: LD_INT 22
10952: PUSH
10953: LD_VAR 0 5
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: PUSH
10962: LD_INT 30
10964: PUSH
10965: LD_INT 34
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PPUSH
10976: CALL_OW 69
10980: ST_TO_ADDR
// if teleport then
10981: LD_VAR 0 6
10985: IFFALSE 11006
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10987: LD_VAR 0 6
10991: PUSH
10992: LD_INT 1
10994: ARRAY
10995: PPUSH
10996: LD_INT 262
10998: PPUSH
10999: LD_INT 119
11001: PPUSH
11002: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11006: LD_VAR 0 4
11010: PPUSH
11011: LD_INT 1
11013: PPUSH
11014: LD_INT 19500
11016: PPUSH
11017: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11021: LD_VAR 0 4
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: LD_INT 200
11031: PPUSH
11032: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11036: LD_VAR 0 4
11040: PPUSH
11041: LD_INT 3
11043: PPUSH
11044: LD_INT 650
11046: PPUSH
11047: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11051: LD_ADDR_EXP 71
11055: PUSH
11056: LD_STRING Roth
11058: PPUSH
11059: CALL_OW 25
11063: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11064: LD_ADDR_EXP 72
11068: PUSH
11069: LD_STRING Simms
11071: PPUSH
11072: LD_EXP 1
11076: NOT
11077: PPUSH
11078: LD_STRING 10c_
11080: PPUSH
11081: CALL 62975 0 3
11085: ST_TO_ADDR
// if not Simms then
11086: LD_EXP 72
11090: NOT
11091: IFFALSE 11121
// begin uc_nation := 1 ;
11093: LD_ADDR_OWVAR 21
11097: PUSH
11098: LD_INT 1
11100: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11101: LD_INT 2
11103: PPUSH
11104: LD_INT 10
11106: PPUSH
11107: CALL_OW 384
// Simms := CreateHuman ;
11111: LD_ADDR_EXP 72
11115: PUSH
11116: CALL_OW 44
11120: ST_TO_ADDR
// end ; uc_nation := 3 ;
11121: LD_ADDR_OWVAR 21
11125: PUSH
11126: LD_INT 3
11128: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11129: LD_ADDR_EXP 73
11133: PUSH
11134: LD_STRING Kirilenkova
11136: PPUSH
11137: CALL_OW 25
11141: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11142: LD_ADDR_EXP 87
11146: PUSH
11147: LD_STRING Oblukov
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Dolgov
11162: PPUSH
11163: CALL_OW 25
11167: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11168: LD_ADDR_EXP 75
11172: PUSH
11173: LD_STRING Petrosyan
11175: PPUSH
11176: CALL_OW 25
11180: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11181: LD_ADDR_EXP 86
11185: PUSH
11186: LD_STRING Scholtze
11188: PPUSH
11189: CALL_OW 25
11193: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11194: LD_ADDR_EXP 85
11198: PUSH
11199: LD_STRING Kapitsova
11201: PPUSH
11202: CALL_OW 25
11206: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11207: LD_ADDR_EXP 76
11211: PUSH
11212: LD_STRING Petrovova
11214: PPUSH
11215: CALL_OW 25
11219: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11220: LD_ADDR_EXP 77
11224: PUSH
11225: LD_STRING Kuzmov
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11233: LD_ADDR_EXP 84
11237: PUSH
11238: LD_STRING Karamazov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11246: LD_STRING 13_Lipshchin_1
11248: PPUSH
11249: LD_INT 0
11251: PPUSH
11252: CALL_OW 30
11256: IFFALSE 11271
// Lipshchin := NewCharacter ( Lipshchin ) ;
11258: LD_ADDR_EXP 78
11262: PUSH
11263: LD_STRING Lipshchin
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11271: LD_STRING 13_Titov_1
11273: PPUSH
11274: LD_INT 0
11276: PPUSH
11277: CALL_OW 30
11281: IFFALSE 11296
// Titov := NewCharacter ( Titov ) ;
11283: LD_ADDR_EXP 80
11287: PUSH
11288: LD_STRING Titov
11290: PPUSH
11291: CALL_OW 25
11295: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11296: LD_STRING 13_Gnyevko_1
11298: PPUSH
11299: LD_INT 0
11301: PPUSH
11302: CALL_OW 30
11306: IFFALSE 11321
// Gnyevko := NewCharacter ( Gnyevko ) ;
11308: LD_ADDR_EXP 79
11312: PUSH
11313: LD_STRING Gnyevko
11315: PPUSH
11316: CALL_OW 25
11320: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11321: LD_STRING 13_Xavier_1
11323: PPUSH
11324: LD_INT 0
11326: PPUSH
11327: CALL_OW 30
11331: IFFALSE 11346
// Xavier := NewCharacter ( Xavier2 ) ;
11333: LD_ADDR_EXP 81
11337: PUSH
11338: LD_STRING Xavier2
11340: PPUSH
11341: CALL_OW 25
11345: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11346: LD_STRING 13_Belkov_1
11348: PPUSH
11349: LD_INT 0
11351: PPUSH
11352: CALL_OW 30
11356: IFFALSE 11371
// Belkov := NewCharacter ( Belkov ) ;
11358: LD_ADDR_EXP 82
11362: PUSH
11363: LD_STRING Belkov
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// if not BurlakStatus then
11371: LD_EXP 9
11375: NOT
11376: IFFALSE 11391
// Burlak = NewCharacter ( Burlak ) ;
11378: LD_ADDR_EXP 83
11382: PUSH
11383: LD_STRING Burlak
11385: PPUSH
11386: CALL_OW 25
11390: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11391: LD_ADDR_VAR 0 3
11395: PUSH
11396: LD_EXP 71
11400: PUSH
11401: LD_EXP 73
11405: PUSH
11406: LD_EXP 87
11410: PUSH
11411: LD_EXP 74
11415: PUSH
11416: LD_EXP 75
11420: PUSH
11421: LD_EXP 86
11425: PUSH
11426: LD_EXP 85
11430: PUSH
11431: LD_EXP 76
11435: PUSH
11436: LD_EXP 77
11440: PUSH
11441: LD_EXP 84
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: ST_TO_ADDR
// if Simms then
11458: LD_EXP 72
11462: IFFALSE 11480
// tmp := tmp ^ Simms ;
11464: LD_ADDR_VAR 0 3
11468: PUSH
11469: LD_VAR 0 3
11473: PUSH
11474: LD_EXP 72
11478: ADD
11479: ST_TO_ADDR
// if Titov then
11480: LD_EXP 80
11484: IFFALSE 11502
// tmp := tmp ^ Titov ;
11486: LD_ADDR_VAR 0 3
11490: PUSH
11491: LD_VAR 0 3
11495: PUSH
11496: LD_EXP 80
11500: ADD
11501: ST_TO_ADDR
// if Lipshchin then
11502: LD_EXP 78
11506: IFFALSE 11524
// tmp := tmp ^ Lipshchin ;
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: LD_VAR 0 3
11517: PUSH
11518: LD_EXP 78
11522: ADD
11523: ST_TO_ADDR
// if Gnyevko then
11524: LD_EXP 79
11528: IFFALSE 11546
// tmp := tmp ^ Gnyevko ;
11530: LD_ADDR_VAR 0 3
11534: PUSH
11535: LD_VAR 0 3
11539: PUSH
11540: LD_EXP 79
11544: ADD
11545: ST_TO_ADDR
// if Xavier then
11546: LD_EXP 81
11550: IFFALSE 11568
// tmp := tmp ^ Xavier ;
11552: LD_ADDR_VAR 0 3
11556: PUSH
11557: LD_VAR 0 3
11561: PUSH
11562: LD_EXP 81
11566: ADD
11567: ST_TO_ADDR
// if Belkov then
11568: LD_EXP 82
11572: IFFALSE 11590
// tmp := tmp ^ Belkov ;
11574: LD_ADDR_VAR 0 3
11578: PUSH
11579: LD_VAR 0 3
11583: PUSH
11584: LD_EXP 82
11588: ADD
11589: ST_TO_ADDR
// if Burlak then
11590: LD_EXP 83
11594: IFFALSE 11612
// tmp := tmp ^ Burlak ;
11596: LD_ADDR_VAR 0 3
11600: PUSH
11601: LD_VAR 0 3
11605: PUSH
11606: LD_EXP 83
11610: ADD
11611: ST_TO_ADDR
// for i = 1 to 8 do
11612: LD_ADDR_VAR 0 2
11616: PUSH
11617: DOUBLE
11618: LD_INT 1
11620: DEC
11621: ST_TO_ADDR
11622: LD_INT 8
11624: PUSH
11625: FOR_TO
11626: IFFALSE 11692
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11628: LD_ADDR_OWVAR 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: LD_INT 3
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: PUSH
11643: LD_INT 1
11645: PPUSH
11646: LD_INT 2
11648: PPUSH
11649: CALL_OW 12
11653: ARRAY
11654: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11655: LD_INT 0
11657: PPUSH
11658: LD_VAR 0 2
11662: PUSH
11663: LD_INT 2
11665: DIV
11666: PPUSH
11667: LD_INT 10
11669: PPUSH
11670: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11674: LD_ADDR_VAR 0 3
11678: PUSH
11679: LD_VAR 0 3
11683: PUSH
11684: CALL_OW 44
11688: ADD
11689: ST_TO_ADDR
// end ;
11690: GO 11625
11692: POP
11693: POP
// for i in tmp do
11694: LD_ADDR_VAR 0 2
11698: PUSH
11699: LD_VAR 0 3
11703: PUSH
11704: FOR_IN
11705: IFFALSE 11730
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11707: LD_VAR 0 2
11711: PPUSH
11712: LD_INT 260
11714: PPUSH
11715: LD_INT 235
11717: PPUSH
11718: LD_INT 8
11720: PPUSH
11721: LD_INT 0
11723: PPUSH
11724: CALL_OW 50
11728: GO 11704
11730: POP
11731: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11732: LD_ADDR_EXP 99
11736: PUSH
11737: LD_EXP 99
11741: PPUSH
11742: LD_INT 1
11744: PPUSH
11745: LD_INT 22
11747: PUSH
11748: LD_VAR 0 5
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 3
11759: PUSH
11760: LD_INT 21
11762: PUSH
11763: LD_INT 2
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PPUSH
11778: CALL_OW 69
11782: PUSH
11783: LD_EXP 71
11787: PUSH
11788: LD_EXP 72
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: DIFF
11797: PPUSH
11798: CALL_OW 1
11802: ST_TO_ADDR
// uc_side := 0 ;
11803: LD_ADDR_OWVAR 20
11807: PUSH
11808: LD_INT 0
11810: ST_TO_ADDR
// uc_nation := 0 ;
11811: LD_ADDR_OWVAR 21
11815: PUSH
11816: LD_INT 0
11818: ST_TO_ADDR
// for i = 1 to 5 do
11819: LD_ADDR_VAR 0 2
11823: PUSH
11824: DOUBLE
11825: LD_INT 1
11827: DEC
11828: ST_TO_ADDR
11829: LD_INT 5
11831: PUSH
11832: FOR_TO
11833: IFFALSE 11870
// begin InitHc ;
11835: CALL_OW 19
// hc_class := class_apeman ;
11839: LD_ADDR_OWVAR 28
11843: PUSH
11844: LD_INT 12
11846: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11847: CALL_OW 44
11851: PPUSH
11852: LD_INT 299
11854: PPUSH
11855: LD_INT 229
11857: PPUSH
11858: LD_INT 10
11860: PPUSH
11861: LD_INT 0
11863: PPUSH
11864: CALL_OW 50
// end ;
11868: GO 11832
11870: POP
11871: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11872: LD_EXP 71
11876: PPUSH
11877: LD_INT 259
11879: PPUSH
11880: LD_INT 235
11882: PPUSH
11883: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11887: LD_EXP 71
11891: PPUSH
11892: LD_INT 262
11894: PPUSH
11895: LD_INT 235
11897: PPUSH
11898: CALL_OW 178
// if Simms then
11902: LD_EXP 72
11906: IFFALSE 11937
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11908: LD_EXP 72
11912: PPUSH
11913: LD_INT 262
11915: PPUSH
11916: LD_INT 235
11918: PPUSH
11919: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11923: LD_EXP 72
11927: PPUSH
11928: LD_EXP 71
11932: PPUSH
11933: CALL_OW 179
// end ; end ;
11937: LD_VAR 0 1
11941: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11942: LD_EXP 31
11946: PUSH
11947: LD_EXP 23
11951: NOT
11952: AND
11953: IFFALSE 12129
11955: GO 11957
11957: DISABLE
11958: LD_INT 0
11960: PPUSH
11961: PPUSH
11962: PPUSH
// begin enable ;
11963: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11964: LD_ADDR_VAR 0 2
11968: PUSH
11969: LD_INT 81
11971: PUSH
11972: LD_INT 7
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 2
11981: PUSH
11982: LD_INT 32
11984: PUSH
11985: LD_INT 3
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 30
11994: PUSH
11995: LD_INT 30
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: LD_INT 30
12004: PUSH
12005: LD_INT 28
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 34
12014: PUSH
12015: LD_INT 49
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: LD_INT 34
12024: PUSH
12025: LD_INT 10
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 34
12034: PUSH
12035: LD_INT 8
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: ST_TO_ADDR
// if not tmp then
12060: LD_VAR 0 2
12064: NOT
12065: IFFALSE 12069
// exit ;
12067: GO 12129
// target := tmp [ rand ( 1 , tmp ) ] ;
12069: LD_ADDR_VAR 0 3
12073: PUSH
12074: LD_VAR 0 2
12078: PUSH
12079: LD_INT 1
12081: PPUSH
12082: LD_VAR 0 2
12086: PPUSH
12087: CALL_OW 12
12091: ARRAY
12092: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12093: LD_VAR 0 3
12097: PPUSH
12098: CALL_OW 255
12102: PUSH
12103: LD_INT 1
12105: EQUAL
12106: IFFALSE 12117
// CenterNowOnUnits ( target ) ;
12108: LD_VAR 0 3
12112: PPUSH
12113: CALL_OW 87
// SetLives ( target , 0 ) ;
12117: LD_VAR 0 3
12121: PPUSH
12122: LD_INT 0
12124: PPUSH
12125: CALL_OW 234
// end ;
12129: PPOPN 3
12131: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12132: LD_EXP 23
12136: NOT
12137: PUSH
12138: LD_EXP 31
12142: AND
12143: IFFALSE 12665
12145: GO 12147
12147: DISABLE
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
// begin uc_side := 7 ;
12153: LD_ADDR_OWVAR 20
12157: PUSH
12158: LD_INT 7
12160: ST_TO_ADDR
// uc_nation := 1 ;
12161: LD_ADDR_OWVAR 21
12165: PUSH
12166: LD_INT 1
12168: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12169: LD_ADDR_VAR 0 3
12173: PUSH
12174: LD_INT 125
12176: PUSH
12177: LD_INT 163
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 185
12186: PUSH
12187: LD_INT 168
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 111
12196: PUSH
12197: LD_INT 97
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL 105423 0 1
12213: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12214: LD_ADDR_EXP 88
12218: PUSH
12219: EMPTY
12220: ST_TO_ADDR
// for i = 1 to Difficulty do
12221: LD_ADDR_VAR 0 1
12225: PUSH
12226: DOUBLE
12227: LD_INT 1
12229: DEC
12230: ST_TO_ADDR
12231: LD_OWVAR 67
12235: PUSH
12236: FOR_TO
12237: IFFALSE 12395
// begin InitHc ;
12239: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12243: LD_INT 0
12245: PPUSH
12246: LD_INT 8
12248: PPUSH
12249: CALL_OW 381
// un := CreateHuman ;
12253: LD_ADDR_VAR 0 2
12257: PUSH
12258: CALL_OW 44
12262: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12263: LD_VAR 0 2
12267: PPUSH
12268: LD_INT 258
12270: PPUSH
12271: LD_INT 267
12273: PPUSH
12274: LD_INT 4
12276: PPUSH
12277: LD_INT 0
12279: PPUSH
12280: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12284: LD_ADDR_EXP 88
12288: PUSH
12289: LD_EXP 88
12293: PUSH
12294: LD_VAR 0 2
12298: UNION
12299: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12300: LD_VAR 0 2
12304: PPUSH
12305: LD_VAR 0 3
12309: PUSH
12310: LD_VAR 0 1
12314: ARRAY
12315: PUSH
12316: LD_INT 1
12318: ARRAY
12319: PPUSH
12320: LD_VAR 0 3
12324: PUSH
12325: LD_VAR 0 1
12329: ARRAY
12330: PUSH
12331: LD_INT 2
12333: ARRAY
12334: PPUSH
12335: LD_INT 4
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12345: LD_VAR 0 2
12349: PPUSH
12350: LD_VAR 0 3
12354: PUSH
12355: LD_VAR 0 1
12359: ARRAY
12360: PUSH
12361: LD_INT 1
12363: ARRAY
12364: PPUSH
12365: LD_VAR 0 3
12369: PUSH
12370: LD_VAR 0 1
12374: ARRAY
12375: PUSH
12376: LD_INT 2
12378: ARRAY
12379: PPUSH
12380: CALL_OW 171
// AddComInvisible ( un ) ;
12384: LD_VAR 0 2
12388: PPUSH
12389: CALL_OW 212
// end ;
12393: GO 12236
12395: POP
12396: POP
// repeat wait ( 0 0$20 ) ;
12397: LD_INT 700
12399: PPUSH
12400: CALL_OW 67
// for i in allianceSpecialForce do
12404: LD_ADDR_VAR 0 1
12408: PUSH
12409: LD_EXP 88
12413: PUSH
12414: FOR_IN
12415: IFFALSE 12650
// begin if IsInvisible ( i ) then
12417: LD_VAR 0 1
12421: PPUSH
12422: CALL_OW 571
12426: IFFALSE 12619
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12428: LD_ADDR_VAR 0 3
12432: PUSH
12433: LD_INT 22
12435: PUSH
12436: LD_INT 1
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: LD_INT 50
12445: PUSH
12446: EMPTY
12447: LIST
12448: PUSH
12449: LD_INT 56
12451: PUSH
12452: EMPTY
12453: LIST
12454: PUSH
12455: LD_INT 91
12457: PUSH
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 25
12465: PUSH
12466: LD_INT 30
12468: PUSH
12469: LD_INT 35
12471: PUSH
12472: EMPTY
12473: LIST
12474: LIST
12475: LIST
12476: PUSH
12477: LD_OWVAR 67
12481: ARRAY
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 2
12490: PUSH
12491: LD_INT 25
12493: PUSH
12494: LD_INT 1
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 2
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 3
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 25
12523: PUSH
12524: LD_INT 4
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: LD_INT 25
12533: PUSH
12534: LD_INT 5
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 25
12543: PUSH
12544: LD_INT 8
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: ST_TO_ADDR
// if not tmp then
12572: LD_VAR 0 3
12576: NOT
12577: IFFALSE 12581
// continue ;
12579: GO 12414
// if Prob ( 30 * Difficulty ) then
12581: LD_INT 30
12583: PUSH
12584: LD_OWVAR 67
12588: MUL
12589: PPUSH
12590: CALL_OW 13
12594: IFFALSE 12619
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12596: LD_VAR 0 3
12600: PUSH
12601: LD_INT 1
12603: PPUSH
12604: LD_VAR 0 3
12608: PPUSH
12609: CALL_OW 12
12613: ARRAY
12614: PPUSH
12615: CALL 30083 0 1
// end ; if IsDead ( i ) then
12619: LD_VAR 0 1
12623: PPUSH
12624: CALL_OW 301
12628: IFFALSE 12648
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12630: LD_ADDR_EXP 88
12634: PUSH
12635: LD_EXP 88
12639: PUSH
12640: LD_VAR 0 1
12644: DIFF
12645: ST_TO_ADDR
// continue ;
12646: GO 12414
// end ; end ;
12648: GO 12414
12650: POP
12651: POP
// until allianceDestroyed or not allianceSpecialForce ;
12652: LD_EXP 23
12656: PUSH
12657: LD_EXP 88
12661: NOT
12662: OR
12663: IFFALSE 12397
// end ;
12665: PPOPN 3
12667: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12668: LD_EXP 23
12672: NOT
12673: PUSH
12674: LD_EXP 31
12678: AND
12679: PUSH
12680: LD_INT 1
12682: PPUSH
12683: LD_INT 1
12685: PPUSH
12686: CALL 58328 0 2
12690: NOT
12691: AND
12692: IFFALSE 13659
12694: GO 12696
12696: DISABLE
12697: LD_INT 0
12699: PPUSH
12700: PPUSH
12701: PPUSH
12702: PPUSH
// begin enable ;
12703: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12704: LD_INT 22
12706: PUSH
12707: LD_INT 7
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PUSH
12714: LD_INT 30
12716: PUSH
12717: LD_INT 3
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: PPUSH
12728: CALL_OW 69
12732: NOT
12733: IFFALSE 12737
// exit ;
12735: GO 13659
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12737: LD_ADDR_VAR 0 4
12741: PUSH
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 34
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: ST_TO_ADDR
// if Prob ( 40 ) then
12771: LD_INT 40
12773: PPUSH
12774: CALL_OW 13
12778: IFFALSE 12905
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12780: LD_INT 1
12782: PPUSH
12783: LD_INT 5
12785: PUSH
12786: LD_INT 3
12788: PUSH
12789: LD_INT 2
12791: PUSH
12792: LD_INT 6
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 5
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 2
12809: PUSH
12810: LD_INT 6
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 5
12821: PUSH
12822: LD_INT 3
12824: PUSH
12825: LD_INT 2
12827: PUSH
12828: LD_INT 6
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: LD_INT 24
12839: PUSH
12840: LD_INT 3
12842: PUSH
12843: LD_INT 3
12845: PUSH
12846: LD_INT 45
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 24
12857: PUSH
12858: LD_INT 3
12860: PUSH
12861: LD_INT 3
12863: PUSH
12864: LD_INT 47
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PUSH
12873: LD_INT 24
12875: PUSH
12876: LD_INT 3
12878: PUSH
12879: LD_INT 3
12881: PUSH
12882: LD_INT 45
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: PPUSH
12899: CALL 56973 0 2
// end else
12903: GO 13028
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12905: LD_INT 1
12907: PPUSH
12908: LD_INT 24
12910: PUSH
12911: LD_INT 3
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 47
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 24
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: LD_INT 3
12934: PUSH
12935: LD_INT 47
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 5
12946: PUSH
12947: LD_INT 3
12949: PUSH
12950: LD_INT 2
12952: PUSH
12953: LD_INT 9
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: PUSH
12962: LD_INT 5
12964: PUSH
12965: LD_INT 3
12967: PUSH
12968: LD_INT 2
12970: PUSH
12971: LD_INT 9
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 24
12982: PUSH
12983: LD_INT 1
12985: PUSH
12986: LD_INT 3
12988: PUSH
12989: LD_INT 45
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: PUSH
12998: LD_INT 24
13000: PUSH
13001: LD_INT 1
13003: PUSH
13004: LD_INT 3
13006: PUSH
13007: LD_INT 45
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: PPUSH
13024: CALL 56973 0 2
// end ; if Difficulty > 1 then
13028: LD_OWVAR 67
13032: PUSH
13033: LD_INT 1
13035: GREATER
13036: IFFALSE 13066
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13038: LD_INT 1
13040: PPUSH
13041: LD_INT 24
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 47
13052: PUSH
13053: EMPTY
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: PUSH
13059: EMPTY
13060: LIST
13061: PPUSH
13062: CALL 56973 0 2
// repeat wait ( 0 0$1 ) ;
13066: LD_INT 35
13068: PPUSH
13069: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13073: LD_INT 1
13075: PPUSH
13076: LD_INT 1
13078: PPUSH
13079: CALL 58328 0 2
13083: PUSH
13084: LD_INT 6
13086: PUSH
13087: LD_INT 7
13089: PUSH
13090: LD_INT 7
13092: PUSH
13093: EMPTY
13094: LIST
13095: LIST
13096: LIST
13097: PUSH
13098: LD_OWVAR 67
13102: ARRAY
13103: GREATEREQUAL
13104: IFFALSE 13066
// wait ( 0 0$40 ) ;
13106: LD_INT 1400
13108: PPUSH
13109: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13113: LD_ADDR_VAR 0 2
13117: PUSH
13118: LD_INT 1
13120: PPUSH
13121: LD_INT 1
13123: PPUSH
13124: CALL 58328 0 2
13128: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13129: LD_ADDR_EXP 118
13133: PUSH
13134: LD_EXP 118
13138: PPUSH
13139: LD_INT 1
13141: PPUSH
13142: LD_EXP 118
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PUSH
13151: LD_VAR 0 2
13155: DIFF
13156: PPUSH
13157: CALL_OW 1
13161: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13162: LD_ADDR_VAR 0 3
13166: PUSH
13167: LD_INT 0
13169: PPUSH
13170: LD_INT 1
13172: PPUSH
13173: CALL_OW 12
13177: ST_TO_ADDR
// if target then
13178: LD_VAR 0 3
13182: IFFALSE 13348
// begin for i in tmp do
13184: LD_ADDR_VAR 0 1
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: FOR_IN
13195: IFFALSE 13220
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13197: LD_VAR 0 1
13201: PPUSH
13202: LD_INT 179
13204: PPUSH
13205: LD_INT 209
13207: PPUSH
13208: LD_INT 8
13210: PPUSH
13211: LD_INT 1
13213: PPUSH
13214: CALL_OW 483
13218: GO 13194
13220: POP
13221: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13222: LD_ADDR_VAR 0 2
13226: PUSH
13227: LD_VAR 0 2
13231: PPUSH
13232: LD_INT 24
13234: PUSH
13235: LD_INT 250
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PPUSH
13242: CALL_OW 72
13246: ST_TO_ADDR
// for i in tmp do
13247: LD_ADDR_VAR 0 1
13251: PUSH
13252: LD_VAR 0 2
13256: PUSH
13257: FOR_IN
13258: IFFALSE 13298
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13260: LD_VAR 0 1
13264: PPUSH
13265: LD_INT 179
13267: PPUSH
13268: LD_INT 209
13270: PPUSH
13271: CALL_OW 297
13275: PUSH
13276: LD_INT 9
13278: GREATER
13279: IFFALSE 13296
// ComMoveXY ( i , 179 , 209 ) ;
13281: LD_VAR 0 1
13285: PPUSH
13286: LD_INT 179
13288: PPUSH
13289: LD_INT 209
13291: PPUSH
13292: CALL_OW 111
13296: GO 13257
13298: POP
13299: POP
// wait ( 0 0$1 ) ;
13300: LD_INT 35
13302: PPUSH
13303: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13307: LD_VAR 0 2
13311: PPUSH
13312: LD_INT 92
13314: PUSH
13315: LD_INT 179
13317: PUSH
13318: LD_INT 209
13320: PUSH
13321: LD_INT 9
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: PPUSH
13330: CALL_OW 72
13334: PUSH
13335: LD_VAR 0 2
13339: PUSH
13340: LD_INT 1
13342: MINUS
13343: GREATEREQUAL
13344: IFFALSE 13222
// end else
13346: GO 13510
// begin for i in tmp do
13348: LD_ADDR_VAR 0 1
13352: PUSH
13353: LD_VAR 0 2
13357: PUSH
13358: FOR_IN
13359: IFFALSE 13384
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13361: LD_VAR 0 1
13365: PPUSH
13366: LD_INT 285
13368: PPUSH
13369: LD_INT 163
13371: PPUSH
13372: LD_INT 8
13374: PPUSH
13375: LD_INT 1
13377: PPUSH
13378: CALL_OW 483
13382: GO 13358
13384: POP
13385: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_VAR 0 2
13395: PPUSH
13396: LD_INT 24
13398: PUSH
13399: LD_INT 250
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PPUSH
13406: CALL_OW 72
13410: ST_TO_ADDR
// for i in tmp do
13411: LD_ADDR_VAR 0 1
13415: PUSH
13416: LD_VAR 0 2
13420: PUSH
13421: FOR_IN
13422: IFFALSE 13462
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13424: LD_VAR 0 1
13428: PPUSH
13429: LD_INT 285
13431: PPUSH
13432: LD_INT 163
13434: PPUSH
13435: CALL_OW 297
13439: PUSH
13440: LD_INT 9
13442: GREATER
13443: IFFALSE 13460
// ComMoveXY ( i , 285 , 163 ) ;
13445: LD_VAR 0 1
13449: PPUSH
13450: LD_INT 285
13452: PPUSH
13453: LD_INT 163
13455: PPUSH
13456: CALL_OW 111
13460: GO 13421
13462: POP
13463: POP
// wait ( 0 0$1 ) ;
13464: LD_INT 35
13466: PPUSH
13467: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13471: LD_VAR 0 2
13475: PPUSH
13476: LD_INT 92
13478: PUSH
13479: LD_INT 285
13481: PUSH
13482: LD_INT 163
13484: PUSH
13485: LD_INT 9
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: LIST
13492: LIST
13493: PPUSH
13494: CALL_OW 72
13498: PUSH
13499: LD_VAR 0 2
13503: PUSH
13504: LD_INT 1
13506: MINUS
13507: GREATEREQUAL
13508: IFFALSE 13386
// end ; repeat wait ( 0 0$1 ) ;
13510: LD_INT 35
13512: PPUSH
13513: CALL_OW 67
// for i in tmp do
13517: LD_ADDR_VAR 0 1
13521: PUSH
13522: LD_VAR 0 2
13526: PUSH
13527: FOR_IN
13528: IFFALSE 13650
// if GetLives ( i ) > 251 then
13530: LD_VAR 0 1
13534: PPUSH
13535: CALL_OW 256
13539: PUSH
13540: LD_INT 251
13542: GREATER
13543: IFFALSE 13632
// begin if GetWeapon ( i ) = ru_time_lapser then
13545: LD_VAR 0 1
13549: PPUSH
13550: CALL_OW 264
13554: PUSH
13555: LD_INT 49
13557: EQUAL
13558: IFFALSE 13596
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13560: LD_VAR 0 1
13564: PPUSH
13565: LD_INT 81
13567: PUSH
13568: LD_INT 7
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: PPUSH
13580: LD_VAR 0 1
13584: PPUSH
13585: CALL_OW 74
13589: PPUSH
13590: CALL_OW 112
13594: GO 13630
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13596: LD_VAR 0 1
13600: PPUSH
13601: LD_INT 81
13603: PUSH
13604: LD_INT 7
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: PPUSH
13616: LD_VAR 0 1
13620: PPUSH
13621: CALL_OW 74
13625: PPUSH
13626: CALL_OW 115
// end else
13630: GO 13648
// tmp := tmp diff i ;
13632: LD_ADDR_VAR 0 2
13636: PUSH
13637: LD_VAR 0 2
13641: PUSH
13642: LD_VAR 0 1
13646: DIFF
13647: ST_TO_ADDR
13648: GO 13527
13650: POP
13651: POP
// until not tmp ;
13652: LD_VAR 0 2
13656: NOT
13657: IFFALSE 13510
// end ; end_of_file
13659: PPOPN 4
13661: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13662: LD_INT 0
13664: PPUSH
13665: PPUSH
13666: PPUSH
13667: PPUSH
// missionStage := 13 ;
13668: LD_ADDR_EXP 15
13672: PUSH
13673: LD_INT 13
13675: ST_TO_ADDR
// uc_side := 2 ;
13676: LD_ADDR_OWVAR 20
13680: PUSH
13681: LD_INT 2
13683: ST_TO_ADDR
// uc_nation := 2 ;
13684: LD_ADDR_OWVAR 21
13688: PUSH
13689: LD_INT 2
13691: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13692: LD_ADDR_EXP 89
13696: PUSH
13697: LD_STRING Omar
13699: PPUSH
13700: CALL_OW 25
13704: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13705: LD_EXP 89
13709: PPUSH
13710: LD_INT 4
13712: PPUSH
13713: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13717: LD_EXP 89
13721: PPUSH
13722: LD_INT 242
13724: PPUSH
13725: LD_INT 75
13727: PPUSH
13728: LD_INT 0
13730: PPUSH
13731: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13735: LD_ADDR_EXP 90
13739: PUSH
13740: LD_STRING Heike
13742: PPUSH
13743: CALL_OW 25
13747: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13748: LD_INT 14
13750: PPUSH
13751: LD_INT 3
13753: PPUSH
13754: LD_INT 1
13756: PPUSH
13757: LD_INT 27
13759: PPUSH
13760: LD_INT 100
13762: PPUSH
13763: CALL 69586 0 5
// veh := CreateVehicle ;
13767: LD_ADDR_VAR 0 3
13771: PUSH
13772: CALL_OW 45
13776: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13777: LD_VAR 0 3
13781: PPUSH
13782: LD_INT 1
13784: PPUSH
13785: CALL_OW 242
// SetDir ( veh , 4 ) ;
13789: LD_VAR 0 3
13793: PPUSH
13794: LD_INT 4
13796: PPUSH
13797: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13801: LD_VAR 0 3
13805: PPUSH
13806: LD_INT 241
13808: PPUSH
13809: LD_INT 72
13811: PPUSH
13812: LD_INT 0
13814: PPUSH
13815: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13819: LD_EXP 90
13823: PPUSH
13824: LD_VAR 0 3
13828: PPUSH
13829: CALL_OW 52
// if KhatamStatus then
13833: LD_EXP 8
13837: IFFALSE 13888
// begin Khatam := NewCharacter ( Khatam ) ;
13839: LD_ADDR_EXP 91
13843: PUSH
13844: LD_STRING Khatam
13846: PPUSH
13847: CALL_OW 25
13851: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13852: LD_EXP 91
13856: PPUSH
13857: LD_INT 245
13859: PPUSH
13860: LD_INT 78
13862: PPUSH
13863: LD_INT 3
13865: PPUSH
13866: LD_INT 0
13868: PPUSH
13869: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13873: LD_EXP 91
13877: PPUSH
13878: LD_INT 4
13880: PPUSH
13881: LD_INT 10
13883: PPUSH
13884: CALL_OW 237
// end ; for i = 1 to Difficulty do
13888: LD_ADDR_VAR 0 2
13892: PUSH
13893: DOUBLE
13894: LD_INT 1
13896: DEC
13897: ST_TO_ADDR
13898: LD_OWVAR 67
13902: PUSH
13903: FOR_TO
13904: IFFALSE 13970
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13906: LD_INT 0
13908: PPUSH
13909: LD_INT 7
13911: PUSH
13912: LD_OWVAR 67
13916: PLUS
13917: PPUSH
13918: CALL_OW 384
// un := CreateHuman ;
13922: LD_ADDR_VAR 0 4
13926: PUSH
13927: CALL_OW 44
13931: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13932: LD_VAR 0 4
13936: PPUSH
13937: LD_INT 28
13939: PUSH
13940: LD_INT 29
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PUSH
13947: LD_VAR 0 2
13951: PUSH
13952: LD_INT 2
13954: MOD
13955: PUSH
13956: LD_INT 1
13958: PLUS
13959: ARRAY
13960: PPUSH
13961: LD_INT 0
13963: PPUSH
13964: CALL_OW 49
// end ;
13968: GO 13903
13970: POP
13971: POP
// for i = 1 to 6 do
13972: LD_ADDR_VAR 0 2
13976: PUSH
13977: DOUBLE
13978: LD_INT 1
13980: DEC
13981: ST_TO_ADDR
13982: LD_INT 6
13984: PUSH
13985: FOR_TO
13986: IFFALSE 14031
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13988: LD_INT 0
13990: PPUSH
13991: LD_INT 7
13993: PUSH
13994: LD_OWVAR 67
13998: PLUS
13999: PPUSH
14000: CALL_OW 381
// un := CreateHuman ;
14004: LD_ADDR_VAR 0 4
14008: PUSH
14009: CALL_OW 44
14013: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14014: LD_VAR 0 4
14018: PPUSH
14019: LD_INT 28
14021: PPUSH
14022: LD_INT 0
14024: PPUSH
14025: CALL_OW 49
// end ;
14029: GO 13985
14031: POP
14032: POP
// for i = 1 to 3 do
14033: LD_ADDR_VAR 0 2
14037: PUSH
14038: DOUBLE
14039: LD_INT 1
14041: DEC
14042: ST_TO_ADDR
14043: LD_INT 3
14045: PUSH
14046: FOR_TO
14047: IFFALSE 14095
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14049: LD_INT 0
14051: PPUSH
14052: LD_INT 8
14054: PPUSH
14055: LD_INT 7
14057: PUSH
14058: LD_OWVAR 67
14062: PLUS
14063: PPUSH
14064: CALL_OW 380
// un := CreateHuman ;
14068: LD_ADDR_VAR 0 4
14072: PUSH
14073: CALL_OW 44
14077: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14078: LD_VAR 0 4
14082: PPUSH
14083: LD_INT 28
14085: PPUSH
14086: LD_INT 0
14088: PPUSH
14089: CALL_OW 49
// end ;
14093: GO 14046
14095: POP
14096: POP
// for i = 1 to 3 do
14097: LD_ADDR_VAR 0 2
14101: PUSH
14102: DOUBLE
14103: LD_INT 1
14105: DEC
14106: ST_TO_ADDR
14107: LD_INT 3
14109: PUSH
14110: FOR_TO
14111: IFFALSE 14201
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14113: LD_INT 14
14115: PPUSH
14116: LD_INT 2
14118: PPUSH
14119: LD_INT 1
14121: PPUSH
14122: LD_INT 28
14124: PPUSH
14125: LD_INT 80
14127: PPUSH
14128: CALL 69586 0 5
// veh := CreateVehicle ;
14132: LD_ADDR_VAR 0 3
14136: PUSH
14137: CALL_OW 45
14141: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14142: LD_VAR 0 3
14146: PPUSH
14147: LD_INT 3
14149: PPUSH
14150: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 29
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14169: LD_INT 0
14171: PPUSH
14172: LD_INT 7
14174: PUSH
14175: LD_OWVAR 67
14179: PLUS
14180: PPUSH
14181: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14185: CALL_OW 44
14189: PPUSH
14190: LD_VAR 0 3
14194: PPUSH
14195: CALL_OW 52
// end ;
14199: GO 14110
14201: POP
14202: POP
// for i = 1 to 5 + Difficulty do
14203: LD_ADDR_VAR 0 2
14207: PUSH
14208: DOUBLE
14209: LD_INT 1
14211: DEC
14212: ST_TO_ADDR
14213: LD_INT 5
14215: PUSH
14216: LD_OWVAR 67
14220: PLUS
14221: PUSH
14222: FOR_TO
14223: IFFALSE 14350
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14225: LD_INT 14
14227: PPUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 3
14233: PPUSH
14234: CALL_OW 12
14238: PPUSH
14239: LD_INT 1
14241: PPUSH
14242: LD_INT 28
14244: PUSH
14245: LD_INT 26
14247: PUSH
14248: LD_INT 27
14250: PUSH
14251: LD_INT 25
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: LIST
14258: LIST
14259: PUSH
14260: LD_VAR 0 2
14264: PUSH
14265: LD_INT 4
14267: MOD
14268: PUSH
14269: LD_INT 1
14271: PLUS
14272: ARRAY
14273: PPUSH
14274: LD_INT 80
14276: PPUSH
14277: CALL 69586 0 5
// veh := CreateVehicle ;
14281: LD_ADDR_VAR 0 3
14285: PUSH
14286: CALL_OW 45
14290: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14291: LD_VAR 0 3
14295: PPUSH
14296: LD_INT 4
14298: PPUSH
14299: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14303: LD_VAR 0 3
14307: PPUSH
14308: LD_INT 28
14310: PPUSH
14311: LD_INT 0
14313: PPUSH
14314: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14318: LD_INT 0
14320: PPUSH
14321: LD_INT 7
14323: PUSH
14324: LD_OWVAR 67
14328: PLUS
14329: PPUSH
14330: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14334: CALL_OW 44
14338: PPUSH
14339: LD_VAR 0 3
14343: PPUSH
14344: CALL_OW 52
// end ;
14348: GO 14222
14350: POP
14351: POP
// for i = 1 to 3 do
14352: LD_ADDR_VAR 0 2
14356: PUSH
14357: DOUBLE
14358: LD_INT 1
14360: DEC
14361: ST_TO_ADDR
14362: LD_INT 3
14364: PUSH
14365: FOR_TO
14366: IFFALSE 14426
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14368: LD_INT 14
14370: PPUSH
14371: LD_INT 3
14373: PPUSH
14374: LD_INT 5
14376: PPUSH
14377: LD_INT 29
14379: PPUSH
14380: LD_INT 80
14382: PPUSH
14383: CALL 69586 0 5
// veh := CreateVehicle ;
14387: LD_ADDR_VAR 0 3
14391: PUSH
14392: CALL_OW 45
14396: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14397: LD_VAR 0 3
14401: PPUSH
14402: LD_INT 4
14404: PPUSH
14405: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14409: LD_VAR 0 3
14413: PPUSH
14414: LD_INT 28
14416: PPUSH
14417: LD_INT 0
14419: PPUSH
14420: CALL_OW 49
// end ;
14424: GO 14365
14426: POP
14427: POP
// end ;
14428: LD_VAR 0 1
14432: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14433: LD_INT 22
14435: PUSH
14436: LD_INT 2
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PPUSH
14443: CALL_OW 69
14447: IFFALSE 14747
14449: GO 14451
14451: DISABLE
14452: LD_INT 0
14454: PPUSH
14455: PPUSH
14456: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14457: LD_ADDR_VAR 0 3
14461: PUSH
14462: LD_INT 22
14464: PUSH
14465: LD_INT 2
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: LD_INT 25
14474: PUSH
14475: LD_INT 4
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PPUSH
14486: CALL_OW 69
14490: PUSH
14491: LD_EXP 91
14495: DIFF
14496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14497: LD_ADDR_VAR 0 2
14501: PUSH
14502: LD_INT 22
14504: PUSH
14505: LD_INT 2
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PPUSH
14512: CALL_OW 69
14516: PUSH
14517: LD_EXP 91
14521: PUSH
14522: LD_VAR 0 3
14526: UNION
14527: DIFF
14528: ST_TO_ADDR
// if Khatam then
14529: LD_EXP 91
14533: IFFALSE 14550
// ComMoveXY ( Khatam , 211 , 92 ) ;
14535: LD_EXP 91
14539: PPUSH
14540: LD_INT 211
14542: PPUSH
14543: LD_INT 92
14545: PPUSH
14546: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14550: LD_INT 197
14552: PPUSH
14553: LD_INT 80
14555: PPUSH
14556: LD_INT 2
14558: PPUSH
14559: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14563: LD_INT 213
14565: PPUSH
14566: LD_INT 90
14568: PPUSH
14569: LD_INT 2
14571: PPUSH
14572: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14576: LD_INT 215
14578: PPUSH
14579: LD_INT 129
14581: PPUSH
14582: LD_INT 2
14584: PPUSH
14585: CALL_OW 441
// if sci then
14589: LD_VAR 0 3
14593: IFFALSE 14614
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14595: LD_VAR 0 3
14599: PUSH
14600: LD_INT 1
14602: ARRAY
14603: PPUSH
14604: LD_INT 197
14606: PPUSH
14607: LD_INT 80
14609: PPUSH
14610: CALL_OW 158
// if sci > 1 then
14614: LD_VAR 0 3
14618: PUSH
14619: LD_INT 1
14621: GREATER
14622: IFFALSE 14643
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14624: LD_VAR 0 3
14628: PUSH
14629: LD_INT 2
14631: ARRAY
14632: PPUSH
14633: LD_INT 213
14635: PPUSH
14636: LD_INT 90
14638: PPUSH
14639: CALL_OW 158
// if sci > 2 then
14643: LD_VAR 0 3
14647: PUSH
14648: LD_INT 2
14650: GREATER
14651: IFFALSE 14672
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14653: LD_VAR 0 3
14657: PUSH
14658: LD_INT 3
14660: ARRAY
14661: PPUSH
14662: LD_INT 215
14664: PPUSH
14665: LD_INT 129
14667: PPUSH
14668: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14672: LD_INT 35
14674: PPUSH
14675: CALL_OW 67
// for i in tmp do
14679: LD_ADDR_VAR 0 1
14683: PUSH
14684: LD_VAR 0 2
14688: PUSH
14689: FOR_IN
14690: IFFALSE 14728
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14692: LD_VAR 0 1
14696: PPUSH
14697: LD_INT 81
14699: PUSH
14700: LD_INT 2
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PPUSH
14707: CALL_OW 69
14711: PPUSH
14712: LD_VAR 0 1
14716: PPUSH
14717: CALL_OW 74
14721: PPUSH
14722: CALL_OW 115
14726: GO 14689
14728: POP
14729: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14730: LD_INT 22
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: PPUSH
14740: CALL_OW 69
14744: NOT
14745: IFFALSE 14672
// end ; end_of_file
14747: PPOPN 3
14749: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14750: LD_INT 0
14752: PPUSH
14753: PPUSH
14754: PPUSH
14755: PPUSH
14756: PPUSH
14757: PPUSH
14758: PPUSH
14759: PPUSH
14760: PPUSH
// Video ( true ) ;
14761: LD_INT 1
14763: PPUSH
14764: CALL 105303 0 1
// if debug then
14768: LD_EXP 1
14772: IFFALSE 14782
// dialogue_skipped := true ;
14774: LD_ADDR_OWVAR 59
14778: PUSH
14779: LD_INT 1
14781: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14782: LD_ADDR_VAR 0 5
14786: PUSH
14787: LD_INT 7
14789: PPUSH
14790: LD_INT 0
14792: PPUSH
14793: CALL_OW 517
14797: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14798: LD_ADDR_VAR 0 2
14802: PUSH
14803: DOUBLE
14804: LD_INT 1
14806: DEC
14807: ST_TO_ADDR
14808: LD_VAR 0 5
14812: PUSH
14813: LD_INT 1
14815: ARRAY
14816: PUSH
14817: FOR_TO
14818: IFFALSE 14863
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14820: LD_VAR 0 5
14824: PUSH
14825: LD_INT 1
14827: ARRAY
14828: PUSH
14829: LD_VAR 0 2
14833: ARRAY
14834: PPUSH
14835: LD_VAR 0 5
14839: PUSH
14840: LD_INT 2
14842: ARRAY
14843: PUSH
14844: LD_VAR 0 2
14848: ARRAY
14849: PPUSH
14850: LD_INT 1
14852: PPUSH
14853: LD_INT 15
14855: NEG
14856: PPUSH
14857: CALL 105217 0 4
14861: GO 14817
14863: POP
14864: POP
// CenterNowOnUnits ( Powell ) ;
14865: LD_EXP 55
14869: PPUSH
14870: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14874: LD_ADDR_VAR 0 5
14878: PUSH
14879: LD_EXP 53
14883: PUSH
14884: EMPTY
14885: LIST
14886: ST_TO_ADDR
// if GirlNewVeh then
14887: LD_EXP 54
14891: IFFALSE 14909
// tmp := tmp ^ GirlNewVeh ;
14893: LD_ADDR_VAR 0 5
14897: PUSH
14898: LD_VAR 0 5
14902: PUSH
14903: LD_EXP 54
14907: ADD
14908: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14909: LD_VAR 0 5
14913: PPUSH
14914: LD_INT 60
14916: PPUSH
14917: LD_INT 109
14919: PPUSH
14920: CALL_OW 111
// if KappaStatus then
14924: LD_EXP 2
14928: IFFALSE 14980
// begin Say ( JMM , D1nT-JMM-1 ) ;
14930: LD_EXP 36
14934: PPUSH
14935: LD_STRING D1nT-JMM-1
14937: PPUSH
14938: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14942: LD_EXP 55
14946: PPUSH
14947: LD_STRING D1T-Pow-1
14949: PPUSH
14950: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14954: LD_EXP 36
14958: PPUSH
14959: LD_STRING D1T-JMM-2
14961: PPUSH
14962: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14966: LD_EXP 55
14970: PPUSH
14971: LD_STRING D1T-Pow-2
14973: PPUSH
14974: CALL_OW 88
// end else
14978: GO 15186
// if JMMGirlStatus then
14980: LD_EXP 6
14984: IFFALSE 15129
// begin Say ( JMM , D1T-JMM-1 ) ;
14986: LD_EXP 36
14990: PPUSH
14991: LD_STRING D1T-JMM-1
14993: PPUSH
14994: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14998: LD_EXP 55
15002: PPUSH
15003: LD_STRING D1T-Pow-1
15005: PPUSH
15006: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15010: LD_EXP 36
15014: PPUSH
15015: LD_STRING D1T-JMM-3
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15022: LD_EXP 55
15026: PPUSH
15027: LD_STRING D1T-Pow-3
15029: PPUSH
15030: CALL_OW 88
// if JMMGirl then
15034: LD_EXP 7
15038: IFFALSE 15127
// begin case JMMGirl of 1 :
15040: LD_EXP 7
15044: PUSH
15045: LD_INT 1
15047: DOUBLE
15048: EQUAL
15049: IFTRUE 15053
15051: GO 15068
15053: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15054: LD_EXP 37
15058: PPUSH
15059: LD_STRING D1T-Joan-3
15061: PPUSH
15062: CALL_OW 88
15066: GO 15115
15068: LD_INT 2
15070: DOUBLE
15071: EQUAL
15072: IFTRUE 15076
15074: GO 15091
15076: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15077: LD_EXP 39
15081: PPUSH
15082: LD_STRING D1T-Lisa-3
15084: PPUSH
15085: CALL_OW 88
15089: GO 15115
15091: LD_INT 3
15093: DOUBLE
15094: EQUAL
15095: IFTRUE 15099
15097: GO 15114
15099: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15100: LD_EXP 51
15104: PPUSH
15105: LD_STRING D1T-Con-3
15107: PPUSH
15108: CALL_OW 88
15112: GO 15115
15114: POP
// Say ( Powell , D1T-Pow-4 ) ;
15115: LD_EXP 55
15119: PPUSH
15120: LD_STRING D1T-Pow-4
15122: PPUSH
15123: CALL_OW 88
// end ; end else
15127: GO 15186
// if not FastEnd then
15129: LD_EXP 11
15133: NOT
15134: IFFALSE 15162
// begin Say ( JMM , D1T-JMM-4 ) ;
15136: LD_EXP 36
15140: PPUSH
15141: LD_STRING D1T-JMM-4
15143: PPUSH
15144: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15148: LD_EXP 55
15152: PPUSH
15153: LD_STRING D1T-Pow-5
15155: PPUSH
15156: CALL_OW 88
// end else
15160: GO 15186
// begin Say ( JMM , D1nT-JMM-1 ) ;
15162: LD_EXP 36
15166: PPUSH
15167: LD_STRING D1nT-JMM-1
15169: PPUSH
15170: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15174: LD_EXP 55
15178: PPUSH
15179: LD_STRING D1nT-Pow-1
15181: PPUSH
15182: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15186: LD_INT 35
15188: PPUSH
15189: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15193: LD_EXP 53
15197: PPUSH
15198: CALL_OW 314
15202: NOT
15203: IFFALSE 15186
// ComExitVehicle ( JMM ) ;
15205: LD_EXP 36
15209: PPUSH
15210: CALL_OW 121
// wait ( 3 ) ;
15214: LD_INT 3
15216: PPUSH
15217: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15221: LD_EXP 36
15225: PPUSH
15226: LD_INT 60
15228: PPUSH
15229: LD_INT 94
15231: PPUSH
15232: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15236: LD_EXP 36
15240: PPUSH
15241: LD_EXP 55
15245: PPUSH
15246: CALL_OW 179
// if Joan then
15250: LD_EXP 37
15254: IFFALSE 15308
// begin ComExitVehicle ( Joan ) ;
15256: LD_EXP 37
15260: PPUSH
15261: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15265: LD_EXP 37
15269: PPUSH
15270: LD_INT 35
15272: PPUSH
15273: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15277: LD_EXP 37
15281: PPUSH
15282: LD_INT 65
15284: PPUSH
15285: LD_INT 104
15287: PPUSH
15288: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15292: LD_EXP 37
15296: PPUSH
15297: LD_EXP 36
15301: PPUSH
15302: CALL_OW 179
// end else
15306: GO 15442
// if Lisa and JMMGirl = 2 then
15308: LD_EXP 39
15312: PUSH
15313: LD_EXP 7
15317: PUSH
15318: LD_INT 2
15320: EQUAL
15321: AND
15322: IFFALSE 15376
// begin ComExitVehicle ( Lisa ) ;
15324: LD_EXP 39
15328: PPUSH
15329: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15333: LD_EXP 39
15337: PPUSH
15338: LD_INT 35
15340: PPUSH
15341: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15345: LD_EXP 39
15349: PPUSH
15350: LD_INT 65
15352: PPUSH
15353: LD_INT 104
15355: PPUSH
15356: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15360: LD_EXP 39
15364: PPUSH
15365: LD_EXP 36
15369: PPUSH
15370: CALL_OW 179
// end else
15374: GO 15442
// if Connie and JMMGirl = 3 then
15376: LD_EXP 51
15380: PUSH
15381: LD_EXP 7
15385: PUSH
15386: LD_INT 3
15388: EQUAL
15389: AND
15390: IFFALSE 15442
// begin ComExitVehicle ( Connie ) ;
15392: LD_EXP 51
15396: PPUSH
15397: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15401: LD_EXP 51
15405: PPUSH
15406: LD_INT 35
15408: PPUSH
15409: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15413: LD_EXP 51
15417: PPUSH
15418: LD_INT 65
15420: PPUSH
15421: LD_INT 104
15423: PPUSH
15424: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15428: LD_EXP 51
15432: PPUSH
15433: LD_EXP 36
15437: PPUSH
15438: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15442: LD_INT 35
15444: PPUSH
15445: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15449: LD_EXP 36
15453: PPUSH
15454: LD_EXP 55
15458: PPUSH
15459: CALL_OW 296
15463: PUSH
15464: LD_INT 6
15466: LESS
15467: IFFALSE 15442
// wait ( 0 0$0.5 ) ;
15469: LD_INT 18
15471: PPUSH
15472: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15476: LD_EXP 36
15480: PPUSH
15481: LD_STRING D1-JMM-1
15483: PPUSH
15484: CALL_OW 88
// async ;
15488: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15489: LD_EXP 55
15493: PPUSH
15494: LD_STRING D1-Pow-1
15496: PPUSH
15497: CALL_OW 88
// if not dialogue_skipped then
15501: LD_OWVAR 59
15505: NOT
15506: IFFALSE 15515
// wait ( 0 0$2 ) ;
15508: LD_INT 70
15510: PPUSH
15511: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15515: LD_INT 170
15517: PPUSH
15518: LD_INT 99
15520: PPUSH
15521: LD_INT 1
15523: PPUSH
15524: LD_INT 6
15526: NEG
15527: PPUSH
15528: CALL 105217 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15532: LD_INT 174
15534: PPUSH
15535: LD_INT 115
15537: PPUSH
15538: LD_INT 1
15540: PPUSH
15541: LD_INT 6
15543: NEG
15544: PPUSH
15545: CALL 105217 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15549: LD_INT 169
15551: PPUSH
15552: LD_INT 71
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 6
15560: NEG
15561: PPUSH
15562: CALL 105217 0 4
// if not dialogue_skipped then
15566: LD_OWVAR 59
15570: NOT
15571: IFFALSE 15590
// begin CenterOnXY ( 170 , 99 ) ;
15573: LD_INT 170
15575: PPUSH
15576: LD_INT 99
15578: PPUSH
15579: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15583: LD_INT 80
15585: PPUSH
15586: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15590: LD_INT 75
15592: PPUSH
15593: LD_INT 53
15595: PPUSH
15596: LD_INT 1
15598: PPUSH
15599: LD_INT 9
15601: NEG
15602: PPUSH
15603: CALL 105217 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15607: LD_INT 54
15609: PPUSH
15610: LD_INT 42
15612: PPUSH
15613: LD_INT 1
15615: PPUSH
15616: LD_INT 9
15618: NEG
15619: PPUSH
15620: CALL 105217 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15624: LD_INT 62
15626: PPUSH
15627: LD_INT 51
15629: PPUSH
15630: LD_INT 1
15632: PPUSH
15633: LD_INT 9
15635: NEG
15636: PPUSH
15637: CALL 105217 0 4
// if not dialogue_skipped then
15641: LD_OWVAR 59
15645: NOT
15646: IFFALSE 15665
// begin CenterOnXY ( 75 , 53 ) ;
15648: LD_INT 75
15650: PPUSH
15651: LD_INT 53
15653: PPUSH
15654: CALL_OW 84
// wait ( 0 0$4 ) ;
15658: LD_INT 140
15660: PPUSH
15661: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15665: LD_EXP 55
15669: PPUSH
15670: CALL_OW 87
// if not dialogue_skipped then
15674: LD_OWVAR 59
15678: NOT
15679: IFFALSE 15688
// wait ( 0 0$2 ) ;
15681: LD_INT 70
15683: PPUSH
15684: CALL_OW 67
// sync ;
15688: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15689: LD_EXP 36
15693: PPUSH
15694: LD_STRING D1-JMM-2
15696: PPUSH
15697: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15701: LD_EXP 55
15705: PPUSH
15706: LD_STRING D1-Pow-2
15708: PPUSH
15709: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15713: LD_EXP 36
15717: PPUSH
15718: LD_STRING D1-JMM-3
15720: PPUSH
15721: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15725: LD_EXP 55
15729: PPUSH
15730: LD_STRING D1-Pow-3
15732: PPUSH
15733: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15737: LD_EXP 36
15741: PPUSH
15742: LD_STRING D1-JMM-4
15744: PPUSH
15745: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15749: LD_EXP 55
15753: PPUSH
15754: LD_STRING D1-Pow-4
15756: PPUSH
15757: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15761: LD_EXP 36
15765: PPUSH
15766: LD_STRING D1-JMM-5
15768: PPUSH
15769: CALL_OW 88
// async ;
15773: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15774: LD_EXP 55
15778: PPUSH
15779: LD_STRING D1-Pow-5
15781: PPUSH
15782: CALL_OW 88
// if not dialogue_skipped then
15786: LD_OWVAR 59
15790: NOT
15791: IFFALSE 15800
// wait ( 0 0$3.6 ) ;
15793: LD_INT 126
15795: PPUSH
15796: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15800: LD_INT 134
15802: PPUSH
15803: LD_INT 210
15805: PPUSH
15806: LD_INT 1
15808: PPUSH
15809: LD_INT 11
15811: NEG
15812: PPUSH
15813: CALL 105217 0 4
// if not dialogue_skipped then
15817: LD_OWVAR 59
15821: NOT
15822: IFFALSE 15841
// begin CenterOnXY ( 134 , 210 ) ;
15824: LD_INT 134
15826: PPUSH
15827: LD_INT 210
15829: PPUSH
15830: CALL_OW 84
// wait ( 0 0$2 ) ;
15834: LD_INT 70
15836: PPUSH
15837: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15841: LD_INT 101
15843: PPUSH
15844: LD_INT 159
15846: PPUSH
15847: LD_INT 1
15849: PPUSH
15850: LD_INT 10
15852: NEG
15853: PPUSH
15854: CALL 105217 0 4
// if not dialogue_skipped then
15858: LD_OWVAR 59
15862: NOT
15863: IFFALSE 15882
// begin CenterOnXY ( 101 , 159 ) ;
15865: LD_INT 101
15867: PPUSH
15868: LD_INT 159
15870: PPUSH
15871: CALL_OW 84
// wait ( 0 0$2 ) ;
15875: LD_INT 70
15877: PPUSH
15878: CALL_OW 67
// end ; sync ;
15882: SYNC
// CenterNowOnUnits ( Powell ) ;
15883: LD_EXP 55
15887: PPUSH
15888: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15892: LD_ADDR_VAR 0 6
15896: PUSH
15897: LD_INT 1
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: LD_INT 3
15905: PUSH
15906: LD_INT 4
15908: PUSH
15909: LD_INT 5
15911: PUSH
15912: LD_INT 6
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: ST_TO_ADDR
// if not dialogue_skipped then
15923: LD_OWVAR 59
15927: NOT
15928: IFFALSE 16097
// begin game_speed := 4 ;
15930: LD_ADDR_OWVAR 65
15934: PUSH
15935: LD_INT 4
15937: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15938: LD_INT 210
15940: PPUSH
15941: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15945: LD_ADDR_VAR 0 7
15949: PUSH
15950: LD_STRING Q1
15952: PPUSH
15953: LD_VAR 0 6
15957: PPUSH
15958: CALL_OW 98
15962: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15963: LD_ADDR_VAR 0 7
15967: PUSH
15968: LD_STRING Q1
15970: PPUSH
15971: LD_VAR 0 6
15975: PPUSH
15976: CALL_OW 98
15980: ST_TO_ADDR
// options = options diff dec ;
15981: LD_ADDR_VAR 0 6
15985: PUSH
15986: LD_VAR 0 6
15990: PUSH
15991: LD_VAR 0 7
15995: DIFF
15996: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15997: LD_VAR 0 7
16001: PPUSH
16002: LD_VAR 0 6
16006: PPUSH
16007: CALL 17400 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16011: LD_VAR 0 7
16015: PUSH
16016: LD_INT 5
16018: PUSH
16019: LD_INT 6
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: IN
16026: PUSH
16027: LD_VAR 0 6
16031: PUSH
16032: LD_INT 2
16034: EQUAL
16035: OR
16036: IFFALSE 15963
// if not ( dec in [ 5 , 6 ] ) then
16038: LD_VAR 0 7
16042: PUSH
16043: LD_INT 5
16045: PUSH
16046: LD_INT 6
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: IN
16053: NOT
16054: IFFALSE 16097
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16056: LD_ADDR_VAR 0 7
16060: PUSH
16061: LD_STRING Q1a
16063: PPUSH
16064: LD_INT 1
16066: PUSH
16067: LD_INT 2
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: PPUSH
16074: CALL_OW 98
16078: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16079: LD_VAR 0 7
16083: PUSH
16084: LD_INT 4
16086: PLUS
16087: PPUSH
16088: LD_VAR 0 6
16092: PPUSH
16093: CALL 17400 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16097: LD_INT 81
16099: PPUSH
16100: LD_INT 127
16102: PPUSH
16103: CALL_OW 84
// amount := 5 ;
16107: LD_ADDR_VAR 0 8
16111: PUSH
16112: LD_INT 5
16114: ST_TO_ADDR
// macmilan_squad := [ ] ;
16115: LD_ADDR_VAR 0 9
16119: PUSH
16120: EMPTY
16121: ST_TO_ADDR
// if vip < amount then
16122: LD_EXP 56
16126: PUSH
16127: LD_VAR 0 8
16131: LESS
16132: IFFALSE 16176
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16134: LD_ADDR_VAR 0 5
16138: PUSH
16139: LD_EXP 56
16143: PUSH
16144: LD_INT 22
16146: PUSH
16147: LD_INT 4
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: LD_INT 21
16156: PUSH
16157: LD_INT 1
16159: PUSH
16160: EMPTY
16161: LIST
16162: LIST
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PPUSH
16168: CALL_OW 69
16172: UNION
16173: ST_TO_ADDR
16174: GO 16186
// tmp := vip ;
16176: LD_ADDR_VAR 0 5
16180: PUSH
16181: LD_EXP 56
16185: ST_TO_ADDR
// tmp := tmp diff Powell ;
16186: LD_ADDR_VAR 0 5
16190: PUSH
16191: LD_VAR 0 5
16195: PUSH
16196: LD_EXP 55
16200: DIFF
16201: ST_TO_ADDR
// if tmp < amount then
16202: LD_VAR 0 5
16206: PUSH
16207: LD_VAR 0 8
16211: LESS
16212: IFFALSE 16224
// amount := tmp ;
16214: LD_ADDR_VAR 0 8
16218: PUSH
16219: LD_VAR 0 5
16223: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16224: LD_VAR 0 5
16228: PUSH
16229: LD_INT 1
16231: ARRAY
16232: PPUSH
16233: CALL_OW 257
16237: PUSH
16238: LD_INT 2
16240: NONEQUAL
16241: IFFALSE 16303
// begin if IsInUnit ( tmp [ 1 ] ) then
16243: LD_VAR 0 5
16247: PUSH
16248: LD_INT 1
16250: ARRAY
16251: PPUSH
16252: CALL_OW 310
16256: IFFALSE 16271
// ComExitBuilding ( tmp [ 1 ] ) ;
16258: LD_VAR 0 5
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16271: LD_VAR 0 5
16275: PUSH
16276: LD_INT 1
16278: ARRAY
16279: PPUSH
16280: LD_INT 387
16282: PPUSH
16283: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16287: LD_VAR 0 5
16291: PUSH
16292: LD_INT 1
16294: ARRAY
16295: PPUSH
16296: LD_INT 2
16298: PPUSH
16299: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16303: LD_EXP 36
16307: PPUSH
16308: LD_INT 82
16310: PPUSH
16311: LD_INT 129
16313: PPUSH
16314: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16318: LD_EXP 36
16322: PPUSH
16323: LD_EXP 55
16327: PPUSH
16328: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16332: LD_INT 22
16334: PUSH
16335: LD_INT 1
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PPUSH
16342: CALL_OW 69
16346: PUSH
16347: LD_EXP 36
16351: DIFF
16352: PPUSH
16353: LD_INT 84
16355: PPUSH
16356: LD_INT 128
16358: PPUSH
16359: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16363: LD_INT 22
16365: PUSH
16366: LD_INT 1
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PPUSH
16373: CALL_OW 69
16377: PUSH
16378: LD_EXP 36
16382: DIFF
16383: PPUSH
16384: LD_EXP 36
16388: PPUSH
16389: CALL_OW 179
// for i = 1 to amount do
16393: LD_ADDR_VAR 0 2
16397: PUSH
16398: DOUBLE
16399: LD_INT 1
16401: DEC
16402: ST_TO_ADDR
16403: LD_VAR 0 8
16407: PUSH
16408: FOR_TO
16409: IFFALSE 16577
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16411: LD_ADDR_VAR 0 9
16415: PUSH
16416: LD_VAR 0 9
16420: PUSH
16421: LD_VAR 0 5
16425: PUSH
16426: LD_VAR 0 2
16430: ARRAY
16431: ADD
16432: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16433: LD_VAR 0 5
16437: PUSH
16438: LD_VAR 0 2
16442: ARRAY
16443: PPUSH
16444: CALL_OW 310
16448: IFFALSE 16465
// AddComExitBuilding ( tmp [ i ] ) ;
16450: LD_VAR 0 5
16454: PUSH
16455: LD_VAR 0 2
16459: ARRAY
16460: PPUSH
16461: CALL_OW 182
// if i = 2 and JMMNewVeh then
16465: LD_VAR 0 2
16469: PUSH
16470: LD_INT 2
16472: EQUAL
16473: PUSH
16474: LD_EXP 53
16478: AND
16479: IFFALSE 16537
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16481: LD_VAR 0 5
16485: PUSH
16486: LD_VAR 0 2
16490: ARRAY
16491: PPUSH
16492: LD_EXP 53
16496: PPUSH
16497: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16501: LD_VAR 0 5
16505: PUSH
16506: LD_VAR 0 2
16510: ARRAY
16511: PPUSH
16512: LD_INT 86
16514: PPUSH
16515: LD_INT 133
16517: PPUSH
16518: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16522: LD_VAR 0 5
16526: PUSH
16527: LD_VAR 0 2
16531: ARRAY
16532: PPUSH
16533: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16537: LD_VAR 0 5
16541: PUSH
16542: LD_VAR 0 2
16546: ARRAY
16547: PPUSH
16548: LD_INT 8
16550: PPUSH
16551: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16555: LD_VAR 0 5
16559: PUSH
16560: LD_VAR 0 2
16564: ARRAY
16565: PPUSH
16566: LD_EXP 36
16570: PPUSH
16571: CALL_OW 179
// end ;
16575: GO 16408
16577: POP
16578: POP
// if GirlNewVeh then
16579: LD_EXP 54
16583: IFFALSE 16597
// SetSide ( GirlNewVeh , 4 ) ;
16585: LD_EXP 54
16589: PPUSH
16590: LD_INT 4
16592: PPUSH
16593: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16597: LD_INT 35
16599: PPUSH
16600: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16604: LD_VAR 0 9
16608: PPUSH
16609: LD_INT 95
16611: PUSH
16612: LD_INT 9
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PPUSH
16619: CALL_OW 72
16623: PUSH
16624: LD_INT 0
16626: EQUAL
16627: PUSH
16628: LD_EXP 36
16632: PPUSH
16633: LD_INT 9
16635: PPUSH
16636: CALL_OW 308
16640: NOT
16641: AND
16642: IFFALSE 16597
// wait ( 0 0$2 ) ;
16644: LD_INT 70
16646: PPUSH
16647: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16651: LD_VAR 0 9
16655: PPUSH
16656: LD_INT 1
16658: PPUSH
16659: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16663: LD_INT 21
16665: PUSH
16666: LD_INT 2
16668: PUSH
16669: EMPTY
16670: LIST
16671: LIST
16672: PUSH
16673: LD_INT 92
16675: PUSH
16676: LD_INT 83
16678: PUSH
16679: LD_INT 130
16681: PUSH
16682: LD_INT 10
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL_OW 69
16699: PPUSH
16700: LD_INT 1
16702: PPUSH
16703: CALL_OW 235
// Video ( false ) ;
16707: LD_INT 0
16709: PPUSH
16710: CALL 105303 0 1
// ChangeMissionObjectives ( M1 ) ;
16714: LD_STRING M1
16716: PPUSH
16717: CALL_OW 337
// SaveForQuickRestart ;
16721: CALL_OW 22
// missionStart := true ;
16725: LD_ADDR_EXP 13
16729: PUSH
16730: LD_INT 1
16732: ST_TO_ADDR
// missionStage := 2 ;
16733: LD_ADDR_EXP 15
16737: PUSH
16738: LD_INT 2
16740: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16741: LD_INT 105
16743: PPUSH
16744: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16748: LD_ADDR_VAR 0 5
16752: PUSH
16753: LD_INT 22
16755: PUSH
16756: LD_INT 4
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PUSH
16763: LD_INT 21
16765: PUSH
16766: LD_INT 1
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PPUSH
16777: CALL_OW 69
16781: PUSH
16782: LD_EXP 55
16786: DIFF
16787: ST_TO_ADDR
// if not tmp then
16788: LD_VAR 0 5
16792: NOT
16793: IFFALSE 16808
// tmp := [ Powell ] ;
16795: LD_ADDR_VAR 0 5
16799: PUSH
16800: LD_EXP 55
16804: PUSH
16805: EMPTY
16806: LIST
16807: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16808: LD_ADDR_EXP 99
16812: PUSH
16813: LD_EXP 99
16817: PPUSH
16818: LD_INT 4
16820: PPUSH
16821: LD_INT 22
16823: PUSH
16824: LD_INT 4
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 23
16833: PUSH
16834: LD_INT 1
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: LD_INT 3
16843: PUSH
16844: LD_INT 21
16846: PUSH
16847: LD_INT 2
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL_OW 69
16867: PUSH
16868: LD_EXP 55
16872: DIFF
16873: PPUSH
16874: CALL_OW 1
16878: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16879: LD_ADDR_VAR 0 4
16883: PUSH
16884: LD_INT 22
16886: PUSH
16887: LD_INT 4
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 34
16896: PUSH
16897: LD_INT 12
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PPUSH
16908: CALL_OW 69
16912: PUSH
16913: LD_INT 1
16915: ARRAY
16916: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16917: LD_VAR 0 5
16921: PUSH
16922: LD_INT 1
16924: ARRAY
16925: PPUSH
16926: CALL_OW 310
16930: IFFALSE 16945
// ComExitBuilding ( tmp [ 1 ] ) ;
16932: LD_VAR 0 5
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: PPUSH
16941: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16945: LD_VAR 0 5
16949: PUSH
16950: LD_INT 1
16952: ARRAY
16953: PPUSH
16954: LD_VAR 0 4
16958: PPUSH
16959: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16963: LD_VAR 0 5
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PPUSH
16972: LD_INT 80
16974: PPUSH
16975: LD_INT 136
16977: PPUSH
16978: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16982: LD_VAR 0 5
16986: PUSH
16987: LD_INT 1
16989: ARRAY
16990: PPUSH
16991: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16995: LD_VAR 0 5
16999: PUSH
17000: LD_INT 1
17002: ARRAY
17003: PPUSH
17004: LD_INT 59
17006: PPUSH
17007: LD_INT 112
17009: PPUSH
17010: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17014: LD_VAR 0 5
17018: PUSH
17019: LD_INT 1
17021: ARRAY
17022: PPUSH
17023: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17027: LD_EXP 39
17031: PUSH
17032: LD_EXP 56
17036: IN
17037: PUSH
17038: LD_EXP 39
17042: PPUSH
17043: CALL_OW 255
17047: PUSH
17048: LD_INT 1
17050: EQUAL
17051: AND
17052: IFFALSE 17068
// Say ( Lisa , D3nW-Lisa-1 ) else
17054: LD_EXP 39
17058: PPUSH
17059: LD_STRING D3nW-Lisa-1
17061: PPUSH
17062: CALL_OW 88
17066: GO 17312
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17068: LD_EXP 42
17072: PUSH
17073: LD_EXP 56
17077: IN
17078: PUSH
17079: LD_EXP 42
17083: PPUSH
17084: CALL_OW 255
17088: PUSH
17089: LD_INT 1
17091: EQUAL
17092: AND
17093: IFFALSE 17109
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17095: LD_EXP 42
17099: PPUSH
17100: LD_STRING D3nW-Cyrus-1
17102: PPUSH
17103: CALL_OW 88
17107: GO 17312
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17109: LD_EXP 41
17113: PUSH
17114: LD_EXP 56
17118: IN
17119: PUSH
17120: LD_EXP 41
17124: PPUSH
17125: CALL_OW 255
17129: PUSH
17130: LD_INT 1
17132: EQUAL
17133: AND
17134: IFFALSE 17150
// Say ( Bobby , D3nW-Bobby-1 ) else
17136: LD_EXP 41
17140: PPUSH
17141: LD_STRING D3nW-Bobby-1
17143: PPUSH
17144: CALL_OW 88
17148: GO 17312
// if Gary in vip and GetSide ( Gary ) = 1 then
17150: LD_EXP 48
17154: PUSH
17155: LD_EXP 56
17159: IN
17160: PUSH
17161: LD_EXP 48
17165: PPUSH
17166: CALL_OW 255
17170: PUSH
17171: LD_INT 1
17173: EQUAL
17174: AND
17175: IFFALSE 17191
// Say ( Gary , D3nW-Gary-1 ) else
17177: LD_EXP 48
17181: PPUSH
17182: LD_STRING D3nW-Gary-1
17184: PPUSH
17185: CALL_OW 88
17189: GO 17312
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17191: LD_EXP 40
17195: PUSH
17196: LD_EXP 56
17200: IN
17201: PUSH
17202: LD_EXP 40
17206: PPUSH
17207: CALL_OW 255
17211: PUSH
17212: LD_INT 1
17214: EQUAL
17215: AND
17216: IFFALSE 17232
// Say ( Donaldson , D3nW-Don-1 ) else
17218: LD_EXP 40
17222: PPUSH
17223: LD_STRING D3nW-Don-1
17225: PPUSH
17226: CALL_OW 88
17230: GO 17312
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17232: LD_EXP 47
17236: PUSH
17237: LD_EXP 56
17241: IN
17242: PUSH
17243: LD_EXP 47
17247: PPUSH
17248: CALL_OW 255
17252: PUSH
17253: LD_INT 1
17255: EQUAL
17256: AND
17257: IFFALSE 17273
// Say ( Cornel , D3nW-Corn-1 ) else
17259: LD_EXP 47
17263: PPUSH
17264: LD_STRING D3nW-Corn-1
17266: PPUSH
17267: CALL_OW 88
17271: GO 17312
// if Frank in vip and GetSide ( Frank ) = 1 then
17273: LD_EXP 49
17277: PUSH
17278: LD_EXP 56
17282: IN
17283: PUSH
17284: LD_EXP 49
17288: PPUSH
17289: CALL_OW 255
17293: PUSH
17294: LD_INT 1
17296: EQUAL
17297: AND
17298: IFFALSE 17312
// Say ( Frank , D3nW-Frank-1 ) ;
17300: LD_EXP 49
17304: PPUSH
17305: LD_STRING D3nW-Frank-1
17307: PPUSH
17308: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17312: LD_EXP 36
17316: PPUSH
17317: LD_STRING D3nW-JMM-1
17319: PPUSH
17320: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17324: LD_EXP 36
17328: PPUSH
17329: LD_STRING D3nW-JMM-1a
17331: PPUSH
17332: CALL_OW 88
// t := 0 0$00 ;
17336: LD_ADDR_VAR 0 3
17340: PUSH
17341: LD_INT 0
17343: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17344: LD_INT 35
17346: PPUSH
17347: CALL_OW 67
// t := t + 0 0$1 ;
17351: LD_ADDR_VAR 0 3
17355: PUSH
17356: LD_VAR 0 3
17360: PUSH
17361: LD_INT 35
17363: PLUS
17364: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17365: LD_INT 59
17367: PPUSH
17368: LD_INT 112
17370: PPUSH
17371: CALL_OW 428
17375: PUSH
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 2100
17383: GREATER
17384: OR
17385: IFFALSE 17344
// activeAttacks := true ;
17387: LD_ADDR_EXP 16
17391: PUSH
17392: LD_INT 1
17394: ST_TO_ADDR
// end ;
17395: LD_VAR 0 1
17399: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17400: LD_INT 0
17402: PPUSH
// case question of 1 :
17403: LD_VAR 0 1
17407: PUSH
17408: LD_INT 1
17410: DOUBLE
17411: EQUAL
17412: IFTRUE 17416
17414: GO 17467
17416: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17417: LD_EXP 36
17421: PPUSH
17422: LD_STRING D2Mot-JMM-1
17424: PPUSH
17425: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17429: LD_EXP 55
17433: PPUSH
17434: LD_STRING D2Mot-Pow-1
17436: PPUSH
17437: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17441: LD_EXP 36
17445: PPUSH
17446: LD_STRING D2Mot-JMM-2
17448: PPUSH
17449: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17453: LD_EXP 55
17457: PPUSH
17458: LD_STRING D2Mot-Pow-2
17460: PPUSH
17461: CALL_OW 88
// end ; 2 :
17465: GO 17810
17467: LD_INT 2
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17551
17475: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17476: LD_EXP 36
17480: PPUSH
17481: LD_STRING D2Rus-JMM-1
17483: PPUSH
17484: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17488: LD_EXP 55
17492: PPUSH
17493: LD_STRING D2Rus-Pow-1
17495: PPUSH
17496: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Rus-JMM-2
17507: PPUSH
17508: CALL_OW 88
// if not ( 3 in list_of_q ) then
17512: LD_INT 3
17514: PUSH
17515: LD_VAR 0 2
17519: IN
17520: NOT
17521: IFFALSE 17537
// Say ( Powell , D2Rus-Pow-2 ) else
17523: LD_EXP 55
17527: PPUSH
17528: LD_STRING D2Rus-Pow-2
17530: PPUSH
17531: CALL_OW 88
17535: GO 17549
// Say ( Powell , D2Rus-Pow-2a ) ;
17537: LD_EXP 55
17541: PPUSH
17542: LD_STRING D2Rus-Pow-2a
17544: PPUSH
17545: CALL_OW 88
// end ; 3 :
17549: GO 17810
17551: LD_INT 3
17553: DOUBLE
17554: EQUAL
17555: IFTRUE 17559
17557: GO 17644
17559: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17560: LD_EXP 36
17564: PPUSH
17565: LD_STRING D2Leg-JMM-1
17567: PPUSH
17568: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17572: LD_EXP 55
17576: PPUSH
17577: LD_STRING D2Leg-Pow-1
17579: PPUSH
17580: CALL_OW 88
// if 2 in list_of_q then
17584: LD_INT 2
17586: PUSH
17587: LD_VAR 0 2
17591: IN
17592: IFFALSE 17618
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17594: LD_EXP 36
17598: PPUSH
17599: LD_STRING D2Leg-JMM-2
17601: PPUSH
17602: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17606: LD_EXP 55
17610: PPUSH
17611: LD_STRING D2Leg-Pow-2
17613: PPUSH
17614: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17618: LD_EXP 36
17622: PPUSH
17623: LD_STRING D2Leg-JMM-3
17625: PPUSH
17626: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17630: LD_EXP 55
17634: PPUSH
17635: LD_STRING D2Leg-Pow-3
17637: PPUSH
17638: CALL_OW 88
// end ; 4 :
17642: GO 17810
17644: LD_INT 4
17646: DOUBLE
17647: EQUAL
17648: IFTRUE 17652
17650: GO 17727
17652: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17653: LD_EXP 36
17657: PPUSH
17658: LD_STRING D2Ar-JMM-1
17660: PPUSH
17661: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17665: LD_EXP 55
17669: PPUSH
17670: LD_STRING D2Ar-Pow-1
17672: PPUSH
17673: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17677: LD_EXP 36
17681: PPUSH
17682: LD_STRING D2Ar-JMM-2
17684: PPUSH
17685: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17689: LD_EXP 55
17693: PPUSH
17694: LD_STRING D2Ar-Pow-2
17696: PPUSH
17697: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Ar-JMM-3
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Ar-Pow-3
17720: PPUSH
17721: CALL_OW 88
// end ; 5 :
17725: GO 17810
17727: LD_INT 5
17729: DOUBLE
17730: EQUAL
17731: IFTRUE 17735
17733: GO 17750
17735: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17736: LD_EXP 36
17740: PPUSH
17741: LD_STRING D2Conf-JMM-1
17743: PPUSH
17744: CALL_OW 88
17748: GO 17810
17750: LD_INT 6
17752: DOUBLE
17753: EQUAL
17754: IFTRUE 17758
17756: GO 17809
17758: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17759: LD_EXP 36
17763: PPUSH
17764: LD_STRING D2Com-JMM-1
17766: PPUSH
17767: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17771: LD_EXP 55
17775: PPUSH
17776: LD_STRING D2Com-Pow-1
17778: PPUSH
17779: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17783: LD_EXP 36
17787: PPUSH
17788: LD_STRING D2Com-JMM-2
17790: PPUSH
17791: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17795: LD_EXP 55
17799: PPUSH
17800: LD_STRING D2Com-Pow-2
17802: PPUSH
17803: CALL_OW 88
// end ; end ;
17807: GO 17810
17809: POP
// end ;
17810: LD_VAR 0 3
17814: RET
// every 0 0$5 trigger missionStart do var tmp ;
17815: LD_EXP 13
17819: IFFALSE 18102
17821: GO 17823
17823: DISABLE
17824: LD_INT 0
17826: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17827: LD_INT 35
17829: PPUSH
17830: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17834: LD_INT 14
17836: PPUSH
17837: LD_INT 22
17839: PUSH
17840: LD_INT 1
17842: PUSH
17843: EMPTY
17844: LIST
17845: LIST
17846: PPUSH
17847: CALL_OW 70
17851: PUSH
17852: LD_EXP 15
17856: PUSH
17857: LD_INT 2
17859: PUSH
17860: LD_INT 3
17862: PUSH
17863: LD_INT 4
17865: PUSH
17866: LD_INT 5
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: IN
17875: AND
17876: IFFALSE 18092
// begin powellAnger := powellAnger + 1 ;
17878: LD_ADDR_EXP 17
17882: PUSH
17883: LD_EXP 17
17887: PUSH
17888: LD_INT 1
17890: PLUS
17891: ST_TO_ADDR
// Video ( true ) ;
17892: LD_INT 1
17894: PPUSH
17895: CALL 105303 0 1
// CenterNowOnUnits ( tmp ) ;
17899: LD_VAR 0 1
17903: PPUSH
17904: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17908: LD_INT 14
17910: PPUSH
17911: LD_INT 22
17913: PUSH
17914: LD_INT 1
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PPUSH
17921: CALL_OW 70
17925: PPUSH
17926: LD_INT 86
17928: PPUSH
17929: LD_INT 133
17931: PPUSH
17932: CALL_OW 111
// async ;
17936: ASYNC
// case powellAnger of 1 :
17937: LD_EXP 17
17941: PUSH
17942: LD_INT 1
17944: DOUBLE
17945: EQUAL
17946: IFTRUE 17950
17948: GO 17965
17950: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17951: LD_EXP 55
17955: PPUSH
17956: LD_STRING DBack1-Pow-1
17958: PPUSH
17959: CALL_OW 88
17963: GO 18012
17965: LD_INT 2
17967: DOUBLE
17968: EQUAL
17969: IFTRUE 17973
17971: GO 17988
17973: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17974: LD_EXP 55
17978: PPUSH
17979: LD_STRING DBack2-Pow-1
17981: PPUSH
17982: CALL_OW 88
17986: GO 18012
17988: LD_INT 3
17990: DOUBLE
17991: EQUAL
17992: IFTRUE 17996
17994: GO 18011
17996: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17997: LD_EXP 55
18001: PPUSH
18002: LD_STRING DBack3-Pow-1
18004: PPUSH
18005: CALL_OW 88
18009: GO 18012
18011: POP
// sync ;
18012: SYNC
// repeat wait ( 0 0$1 ) ;
18013: LD_INT 35
18015: PPUSH
18016: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18020: LD_INT 14
18022: PPUSH
18023: LD_INT 22
18025: PUSH
18026: LD_INT 1
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PPUSH
18033: CALL_OW 70
18037: PPUSH
18038: LD_INT 86
18040: PPUSH
18041: LD_INT 133
18043: PPUSH
18044: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18048: LD_INT 14
18050: PPUSH
18051: LD_INT 22
18053: PUSH
18054: LD_INT 1
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PPUSH
18061: CALL_OW 70
18065: NOT
18066: IFFALSE 18013
// if powellAnger >= 3 then
18068: LD_EXP 17
18072: PUSH
18073: LD_INT 3
18075: GREATEREQUAL
18076: IFFALSE 18085
// YouLost ( Dismissed ) ;
18078: LD_STRING Dismissed
18080: PPUSH
18081: CALL_OW 104
// Video ( false ) ;
18085: LD_INT 0
18087: PPUSH
18088: CALL 105303 0 1
// end ; until missionStage > 5 ;
18092: LD_EXP 15
18096: PUSH
18097: LD_INT 5
18099: GREATER
18100: IFFALSE 17827
// end ;
18102: PPOPN 1
18104: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18105: LD_EXP 13
18109: PUSH
18110: LD_INT 22
18112: PUSH
18113: LD_INT 4
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: PUSH
18120: LD_INT 21
18122: PUSH
18123: LD_INT 2
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: PUSH
18130: EMPTY
18131: LIST
18132: LIST
18133: PPUSH
18134: CALL_OW 69
18138: PUSH
18139: LD_INT 4
18141: GREATEREQUAL
18142: AND
18143: PUSH
18144: LD_EXP 15
18148: PUSH
18149: LD_INT 2
18151: EQUAL
18152: AND
18153: IFFALSE 19976
18155: GO 18157
18157: DISABLE
18158: LD_INT 0
18160: PPUSH
18161: PPUSH
18162: PPUSH
18163: PPUSH
18164: PPUSH
18165: PPUSH
18166: PPUSH
18167: PPUSH
// begin missionStage := 3 ;
18168: LD_ADDR_EXP 15
18172: PUSH
18173: LD_INT 3
18175: ST_TO_ADDR
// retreat := false ;
18176: LD_ADDR_VAR 0 4
18180: PUSH
18181: LD_INT 0
18183: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18184: LD_ADDR_VAR 0 5
18188: PUSH
18189: LD_INT 22
18191: PUSH
18192: LD_INT 4
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: PUSH
18199: LD_INT 30
18201: PUSH
18202: LD_INT 4
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: PPUSH
18213: CALL_OW 69
18217: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18218: LD_ADDR_VAR 0 6
18222: PUSH
18223: LD_INT 22
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: LD_INT 30
18235: PUSH
18236: LD_INT 5
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PPUSH
18247: CALL_OW 69
18251: ST_TO_ADDR
// if not bar then
18252: LD_VAR 0 6
18256: NOT
18257: IFFALSE 18310
// begin repeat wait ( 0 0$1 ) ;
18259: LD_INT 35
18261: PPUSH
18262: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18266: LD_INT 22
18268: PUSH
18269: LD_INT 4
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: PUSH
18276: LD_INT 3
18278: PUSH
18279: LD_INT 57
18281: PUSH
18282: EMPTY
18283: LIST
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: PUSH
18289: LD_INT 30
18291: PUSH
18292: LD_INT 5
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: PUSH
18299: EMPTY
18300: LIST
18301: LIST
18302: LIST
18303: PPUSH
18304: CALL_OW 69
18308: IFFALSE 18259
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18310: LD_ADDR_VAR 0 6
18314: PUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 4
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PUSH
18325: LD_INT 30
18327: PUSH
18328: LD_INT 5
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PPUSH
18339: CALL_OW 69
18343: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18344: LD_INT 35
18346: PPUSH
18347: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18351: LD_EXP 118
18355: PUSH
18356: LD_INT 4
18358: ARRAY
18359: PUSH
18360: LD_INT 4
18362: GREATEREQUAL
18363: IFFALSE 18344
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18365: LD_ADDR_VAR 0 2
18369: PUSH
18370: LD_INT 22
18372: PUSH
18373: LD_INT 4
18375: PUSH
18376: EMPTY
18377: LIST
18378: LIST
18379: PUSH
18380: LD_INT 2
18382: PUSH
18383: LD_INT 25
18385: PUSH
18386: LD_INT 1
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: LD_INT 25
18395: PUSH
18396: LD_INT 2
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: PUSH
18403: LD_INT 25
18405: PUSH
18406: LD_INT 3
18408: PUSH
18409: EMPTY
18410: LIST
18411: LIST
18412: PUSH
18413: LD_INT 25
18415: PUSH
18416: LD_INT 4
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: PUSH
18423: LD_INT 25
18425: PUSH
18426: LD_INT 5
18428: PUSH
18429: EMPTY
18430: LIST
18431: LIST
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL_OW 69
18449: PUSH
18450: LD_EXP 55
18454: PUSH
18455: LD_EXP 56
18459: ADD
18460: DIFF
18461: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18462: LD_ADDR_VAR 0 3
18466: PUSH
18467: LD_VAR 0 2
18471: PPUSH
18472: LD_INT 26
18474: PUSH
18475: LD_INT 1
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: PPUSH
18482: CALL_OW 72
18486: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18487: LD_ADDR_VAR 0 2
18491: PUSH
18492: LD_VAR 0 2
18496: PUSH
18497: LD_VAR 0 3
18501: DIFF
18502: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18503: LD_ADDR_VAR 0 2
18507: PUSH
18508: LD_VAR 0 2
18512: PPUSH
18513: LD_INT 1
18515: PPUSH
18516: CALL 103956 0 2
18520: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18521: LD_ADDR_VAR 0 3
18525: PUSH
18526: LD_VAR 0 3
18530: PPUSH
18531: LD_INT 1
18533: PPUSH
18534: CALL 103956 0 2
18538: ST_TO_ADDR
// for i = 1 to 4 do
18539: LD_ADDR_VAR 0 1
18543: PUSH
18544: DOUBLE
18545: LD_INT 1
18547: DEC
18548: ST_TO_ADDR
18549: LD_INT 4
18551: PUSH
18552: FOR_TO
18553: IFFALSE 18719
// begin if tmp2 then
18555: LD_VAR 0 3
18559: IFFALSE 18640
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18561: LD_ADDR_EXP 18
18565: PUSH
18566: LD_EXP 18
18570: PPUSH
18571: LD_INT 1
18573: PPUSH
18574: LD_EXP 18
18578: PUSH
18579: LD_INT 1
18581: ARRAY
18582: PUSH
18583: LD_VAR 0 3
18587: PUSH
18588: LD_VAR 0 3
18592: ARRAY
18593: ADD
18594: PPUSH
18595: CALL_OW 1
18599: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18600: LD_VAR 0 3
18604: PUSH
18605: LD_VAR 0 3
18609: ARRAY
18610: PPUSH
18611: LD_INT 1
18613: PPUSH
18614: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18618: LD_ADDR_VAR 0 3
18622: PUSH
18623: LD_VAR 0 3
18627: PPUSH
18628: LD_VAR 0 3
18632: PPUSH
18633: CALL_OW 3
18637: ST_TO_ADDR
// end else
18638: GO 18717
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18640: LD_ADDR_EXP 18
18644: PUSH
18645: LD_EXP 18
18649: PPUSH
18650: LD_INT 1
18652: PPUSH
18653: LD_EXP 18
18657: PUSH
18658: LD_INT 1
18660: ARRAY
18661: PUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 2
18671: ARRAY
18672: ADD
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18679: LD_VAR 0 2
18683: PUSH
18684: LD_VAR 0 2
18688: ARRAY
18689: PPUSH
18690: LD_INT 1
18692: PPUSH
18693: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18697: LD_ADDR_VAR 0 2
18701: PUSH
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 2
18711: PPUSH
18712: CALL_OW 3
18716: ST_TO_ADDR
// end ; end ;
18717: GO 18552
18719: POP
18720: POP
// if tmp2 then
18721: LD_VAR 0 3
18725: IFFALSE 18743
// tmp := tmp union tmp2 ;
18727: LD_ADDR_VAR 0 2
18731: PUSH
18732: LD_VAR 0 2
18736: PUSH
18737: LD_VAR 0 3
18741: UNION
18742: ST_TO_ADDR
// for i = 1 to 4 do
18743: LD_ADDR_VAR 0 1
18747: PUSH
18748: DOUBLE
18749: LD_INT 1
18751: DEC
18752: ST_TO_ADDR
18753: LD_INT 4
18755: PUSH
18756: FOR_TO
18757: IFFALSE 18806
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18759: LD_ADDR_EXP 18
18763: PUSH
18764: LD_EXP 18
18768: PPUSH
18769: LD_INT 2
18771: PPUSH
18772: LD_EXP 18
18776: PUSH
18777: LD_INT 2
18779: ARRAY
18780: PUSH
18781: LD_VAR 0 2
18785: PUSH
18786: LD_VAR 0 2
18790: PUSH
18791: LD_VAR 0 1
18795: MINUS
18796: ARRAY
18797: ADD
18798: PPUSH
18799: CALL_OW 1
18803: ST_TO_ADDR
18804: GO 18756
18806: POP
18807: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18808: LD_ADDR_EXP 99
18812: PUSH
18813: LD_EXP 99
18817: PPUSH
18818: LD_INT 4
18820: PPUSH
18821: LD_EXP 99
18825: PUSH
18826: LD_INT 4
18828: ARRAY
18829: PUSH
18830: LD_EXP 18
18834: PUSH
18835: LD_INT 1
18837: ARRAY
18838: DIFF
18839: PPUSH
18840: CALL_OW 1
18844: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18845: LD_VAR 0 5
18849: PUSH
18850: LD_INT 1
18852: ARRAY
18853: PPUSH
18854: CALL_OW 313
18858: IFFALSE 18913
// begin for i in UnitsInside ( arm [ 1 ] ) do
18860: LD_ADDR_VAR 0 1
18864: PUSH
18865: LD_VAR 0 5
18869: PUSH
18870: LD_INT 1
18872: ARRAY
18873: PPUSH
18874: CALL_OW 313
18878: PUSH
18879: FOR_IN
18880: IFFALSE 18911
// begin ComExitBuilding ( i ) ;
18882: LD_VAR 0 1
18886: PPUSH
18887: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18891: LD_VAR 0 1
18895: PPUSH
18896: LD_VAR 0 6
18900: PUSH
18901: LD_INT 1
18903: ARRAY
18904: PPUSH
18905: CALL_OW 180
// end ;
18909: GO 18879
18911: POP
18912: POP
// end ; wait ( 0 0$3 ) ;
18913: LD_INT 105
18915: PPUSH
18916: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18920: LD_ADDR_VAR 0 1
18924: PUSH
18925: LD_EXP 18
18929: PUSH
18930: LD_INT 1
18932: ARRAY
18933: PUSH
18934: FOR_IN
18935: IFFALSE 19042
// begin if IsInUnit ( i ) then
18937: LD_VAR 0 1
18941: PPUSH
18942: CALL_OW 310
18946: IFFALSE 18957
// ComExitBuilding ( i ) ;
18948: LD_VAR 0 1
18952: PPUSH
18953: CALL_OW 122
// if GetClass ( i ) <> 1 then
18957: LD_VAR 0 1
18961: PPUSH
18962: CALL_OW 257
18966: PUSH
18967: LD_INT 1
18969: NONEQUAL
18970: IFFALSE 19011
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18972: LD_VAR 0 1
18976: PPUSH
18977: LD_VAR 0 5
18981: PUSH
18982: LD_INT 1
18984: ARRAY
18985: PPUSH
18986: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18990: LD_VAR 0 1
18994: PPUSH
18995: LD_INT 1
18997: PPUSH
18998: CALL_OW 183
// AddComExitBuilding ( i ) ;
19002: LD_VAR 0 1
19006: PPUSH
19007: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19011: LD_VAR 0 1
19015: PPUSH
19016: LD_INT 60
19018: PPUSH
19019: LD_INT 94
19021: PPUSH
19022: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19026: LD_VAR 0 1
19030: PPUSH
19031: LD_EXP 55
19035: PPUSH
19036: CALL_OW 179
// end ;
19040: GO 18934
19042: POP
19043: POP
// wait ( 0 0$15 ) ;
19044: LD_INT 525
19046: PPUSH
19047: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19051: LD_EXP 55
19055: PPUSH
19056: LD_STRING D4-Pow-1
19058: PPUSH
19059: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19063: LD_ADDR_VAR 0 2
19067: PUSH
19068: LD_EXP 18
19072: PUSH
19073: LD_INT 1
19075: ARRAY
19076: PPUSH
19077: LD_INT 26
19079: PUSH
19080: LD_INT 1
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PPUSH
19087: CALL_OW 72
19091: ST_TO_ADDR
// if tmp then
19092: LD_VAR 0 2
19096: IFFALSE 19114
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19098: LD_VAR 0 2
19102: PUSH
19103: LD_INT 1
19105: ARRAY
19106: PPUSH
19107: LD_STRING D4-Sol1-1
19109: PPUSH
19110: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19114: LD_EXP 55
19118: PPUSH
19119: LD_STRING D4-Pow-2
19121: PPUSH
19122: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: DOUBLE
19132: LD_INT 1
19134: DEC
19135: ST_TO_ADDR
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 1
19143: ARRAY
19144: PUSH
19145: FOR_TO
19146: IFFALSE 19239
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19148: LD_EXP 18
19152: PUSH
19153: LD_INT 1
19155: ARRAY
19156: PUSH
19157: LD_VAR 0 1
19161: ARRAY
19162: PPUSH
19163: LD_EXP 118
19167: PUSH
19168: LD_INT 4
19170: ARRAY
19171: PUSH
19172: LD_INT 1
19174: ARRAY
19175: PPUSH
19176: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19180: LD_ADDR_EXP 118
19184: PUSH
19185: LD_EXP 118
19189: PPUSH
19190: LD_INT 4
19192: PPUSH
19193: LD_EXP 118
19197: PUSH
19198: LD_INT 4
19200: ARRAY
19201: PPUSH
19202: LD_INT 1
19204: PPUSH
19205: CALL_OW 3
19209: PPUSH
19210: CALL_OW 1
19214: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19215: LD_INT 8
19217: PPUSH
19218: LD_EXP 18
19222: PUSH
19223: LD_INT 1
19225: ARRAY
19226: PUSH
19227: LD_VAR 0 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 471
// end ;
19237: GO 19145
19239: POP
19240: POP
// repeat wait ( 0 0$1 ) ;
19241: LD_INT 35
19243: PPUSH
19244: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19248: LD_EXP 18
19252: PUSH
19253: LD_INT 1
19255: ARRAY
19256: PPUSH
19257: LD_INT 55
19259: PUSH
19260: EMPTY
19261: LIST
19262: PPUSH
19263: CALL_OW 72
19267: PUSH
19268: LD_INT 4
19270: GREATEREQUAL
19271: IFFALSE 19241
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19273: LD_EXP 18
19277: PUSH
19278: LD_INT 1
19280: ARRAY
19281: PPUSH
19282: LD_INT 69
19284: PPUSH
19285: LD_INT 94
19287: PPUSH
19288: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19292: LD_EXP 18
19296: PUSH
19297: LD_INT 1
19299: ARRAY
19300: PPUSH
19301: LD_INT 82
19303: PPUSH
19304: LD_INT 83
19306: PPUSH
19307: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19311: LD_EXP 18
19315: PUSH
19316: LD_INT 1
19318: ARRAY
19319: PPUSH
19320: LD_INT 77
19322: PPUSH
19323: LD_INT 69
19325: PPUSH
19326: CALL_OW 174
// repeat wait ( 3 ) ;
19330: LD_INT 3
19332: PPUSH
19333: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19337: LD_ADDR_VAR 0 1
19341: PUSH
19342: LD_EXP 18
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: PUSH
19351: FOR_IN
19352: IFFALSE 19488
// begin if GetLives ( i ) < 990 then
19354: LD_VAR 0 1
19358: PPUSH
19359: CALL_OW 256
19363: PUSH
19364: LD_INT 990
19366: LESS
19367: IFFALSE 19381
// SetLives ( i , 1000 ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1000
19376: PPUSH
19377: CALL_OW 234
// if not IsInUnit ( i ) then
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 310
19390: NOT
19391: IFFALSE 19486
// begin if not HasTask ( i ) then
19393: LD_VAR 0 1
19397: PPUSH
19398: CALL_OW 314
19402: NOT
19403: IFFALSE 19420
// ComMoveXY ( i , 64 , 93 ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_INT 64
19412: PPUSH
19413: LD_INT 93
19415: PPUSH
19416: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19420: LD_VAR 0 4
19424: NOT
19425: PUSH
19426: LD_VAR 0 1
19430: PPUSH
19431: CALL_OW 258
19435: PUSH
19436: LD_INT 1
19438: EQUAL
19439: AND
19440: IFFALSE 19486
// begin retreat := true ;
19442: LD_ADDR_VAR 0 4
19446: PUSH
19447: LD_INT 1
19449: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19450: LD_VAR 0 1
19454: PPUSH
19455: LD_INT 2
19457: PPUSH
19458: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19462: LD_VAR 0 1
19466: PPUSH
19467: LD_STRING D4a-Sol1-1
19469: PPUSH
19470: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19474: LD_EXP 55
19478: PPUSH
19479: LD_STRING D4a-Pow-1
19481: PPUSH
19482: CALL_OW 88
// end ; end ; end ;
19486: GO 19351
19488: POP
19489: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19490: LD_EXP 18
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PPUSH
19499: LD_INT 95
19501: PUSH
19502: LD_INT 9
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: PUSH
19509: LD_INT 3
19511: PUSH
19512: LD_INT 55
19514: PUSH
19515: EMPTY
19516: LIST
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PUSH
19522: EMPTY
19523: LIST
19524: LIST
19525: PPUSH
19526: CALL_OW 72
19530: PUSH
19531: LD_INT 4
19533: GREATEREQUAL
19534: IFFALSE 19330
// for i in powellSquadAttack [ 1 ] do
19536: LD_ADDR_VAR 0 1
19540: PUSH
19541: LD_EXP 18
19545: PUSH
19546: LD_INT 1
19548: ARRAY
19549: PUSH
19550: FOR_IN
19551: IFFALSE 19687
// begin if GetTag ( i ) = 2 then
19553: LD_VAR 0 1
19557: PPUSH
19558: CALL_OW 110
19562: PUSH
19563: LD_INT 2
19565: EQUAL
19566: IFFALSE 19628
// begin ComMoveXY ( i , 60 , 94 ) ;
19568: LD_VAR 0 1
19572: PPUSH
19573: LD_INT 60
19575: PPUSH
19576: LD_INT 94
19578: PPUSH
19579: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19583: LD_VAR 0 1
19587: PPUSH
19588: LD_EXP 55
19592: PPUSH
19593: CALL_OW 179
// wait ( 0 0$3 ) ;
19597: LD_INT 105
19599: PPUSH
19600: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19604: LD_VAR 0 1
19608: PPUSH
19609: LD_STRING D4a-Sol1-2
19611: PPUSH
19612: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19616: LD_EXP 55
19620: PPUSH
19621: LD_STRING D4a-Pow-2
19623: PPUSH
19624: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_INT 0
19635: PPUSH
19636: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19640: LD_ADDR_EXP 99
19644: PUSH
19645: LD_EXP 99
19649: PPUSH
19650: LD_INT 4
19652: PPUSH
19653: LD_EXP 99
19657: PUSH
19658: LD_INT 4
19660: ARRAY
19661: PUSH
19662: LD_VAR 0 1
19666: UNION
19667: PPUSH
19668: CALL_OW 1
19672: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19673: LD_INT 8
19675: PPUSH
19676: LD_VAR 0 1
19680: PPUSH
19681: CALL_OW 472
// end ;
19685: GO 19550
19687: POP
19688: POP
// wait ( 4 4$00 ) ;
19689: LD_INT 8400
19691: PPUSH
19692: CALL_OW 67
// uc_side := 6 ;
19696: LD_ADDR_OWVAR 20
19700: PUSH
19701: LD_INT 6
19703: ST_TO_ADDR
// uc_nation := 3 ;
19704: LD_ADDR_OWVAR 21
19708: PUSH
19709: LD_INT 3
19711: ST_TO_ADDR
// ru := [ ] ;
19712: LD_ADDR_VAR 0 7
19716: PUSH
19717: EMPTY
19718: ST_TO_ADDR
// for i = 1 to 4 do
19719: LD_ADDR_VAR 0 1
19723: PUSH
19724: DOUBLE
19725: LD_INT 1
19727: DEC
19728: ST_TO_ADDR
19729: LD_INT 4
19731: PUSH
19732: FOR_TO
19733: IFFALSE 19834
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19735: LD_INT 22
19737: PPUSH
19738: LD_INT 1
19740: PPUSH
19741: LD_INT 3
19743: PPUSH
19744: LD_INT 43
19746: PUSH
19747: LD_INT 44
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PUSH
19754: LD_INT 1
19756: PPUSH
19757: LD_INT 2
19759: PPUSH
19760: CALL_OW 12
19764: ARRAY
19765: PPUSH
19766: LD_INT 89
19768: PPUSH
19769: CALL 69586 0 5
// un := CreateVehicle ;
19773: LD_ADDR_VAR 0 8
19777: PUSH
19778: CALL_OW 45
19782: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19783: LD_VAR 0 8
19787: PPUSH
19788: LD_INT 4
19790: PPUSH
19791: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19795: LD_VAR 0 8
19799: PPUSH
19800: LD_INT 136
19802: PPUSH
19803: LD_INT 90
19805: PPUSH
19806: LD_INT 8
19808: PPUSH
19809: LD_INT 0
19811: PPUSH
19812: CALL_OW 50
// ru := ru ^ un ;
19816: LD_ADDR_VAR 0 7
19820: PUSH
19821: LD_VAR 0 7
19825: PUSH
19826: LD_VAR 0 8
19830: ADD
19831: ST_TO_ADDR
// end ;
19832: GO 19732
19834: POP
19835: POP
// if ru then
19836: LD_VAR 0 7
19840: IFFALSE 19857
// ComAgressiveMove ( ru , 80 , 92 ) ;
19842: LD_VAR 0 7
19846: PPUSH
19847: LD_INT 80
19849: PPUSH
19850: LD_INT 92
19852: PPUSH
19853: CALL_OW 114
// wait ( 8 8$00 ) ;
19857: LD_INT 16800
19859: PPUSH
19860: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19864: LD_INT 4
19866: PPUSH
19867: LD_INT 3
19869: PUSH
19870: LD_INT 1
19872: PUSH
19873: LD_INT 1
19875: PUSH
19876: LD_INT 5
19878: PUSH
19879: EMPTY
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: PUSH
19885: LD_INT 4
19887: PUSH
19888: LD_INT 1
19890: PUSH
19891: LD_INT 1
19893: PUSH
19894: LD_INT 6
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: LIST
19901: LIST
19902: PUSH
19903: LD_INT 4
19905: PUSH
19906: LD_INT 1
19908: PUSH
19909: LD_INT 1
19911: PUSH
19912: LD_INT 7
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 3
19923: PUSH
19924: LD_INT 1
19926: PUSH
19927: LD_INT 1
19929: PUSH
19930: LD_INT 7
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: LIST
19937: LIST
19938: PUSH
19939: LD_INT 3
19941: PUSH
19942: LD_INT 1
19944: PUSH
19945: LD_INT 1
19947: PUSH
19948: LD_INT 5
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: PPUSH
19964: CALL 56925 0 2
// missionStage := 4 ;
19968: LD_ADDR_EXP 15
19972: PUSH
19973: LD_INT 4
19975: ST_TO_ADDR
// end ;
19976: PPOPN 8
19978: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19979: LD_EXP 15
19983: PUSH
19984: LD_INT 4
19986: EQUAL
19987: PUSH
19988: LD_INT 22
19990: PUSH
19991: LD_INT 4
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: PUSH
19998: LD_INT 21
20000: PUSH
20001: LD_INT 2
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: PUSH
20008: EMPTY
20009: LIST
20010: LIST
20011: PPUSH
20012: CALL_OW 69
20016: PUSH
20017: LD_INT 5
20019: GREATEREQUAL
20020: AND
20021: IFFALSE 24107
20023: GO 20025
20025: DISABLE
20026: LD_INT 0
20028: PPUSH
20029: PPUSH
20030: PPUSH
20031: PPUSH
20032: PPUSH
20033: PPUSH
20034: PPUSH
20035: PPUSH
20036: PPUSH
20037: PPUSH
20038: PPUSH
20039: PPUSH
20040: PPUSH
// begin missionStage := 5 ;
20041: LD_ADDR_EXP 15
20045: PUSH
20046: LD_INT 5
20048: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20049: LD_ADDR_VAR 0 10
20053: PUSH
20054: LD_INT 22
20056: PUSH
20057: LD_INT 4
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: PUSH
20064: LD_INT 2
20066: PUSH
20067: LD_INT 30
20069: PUSH
20070: LD_INT 4
20072: PUSH
20073: EMPTY
20074: LIST
20075: LIST
20076: PUSH
20077: LD_INT 30
20079: PUSH
20080: LD_INT 5
20082: PUSH
20083: EMPTY
20084: LIST
20085: LIST
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: LIST
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: PPUSH
20096: CALL_OW 69
20100: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20101: LD_ADDR_VAR 0 6
20105: PUSH
20106: LD_INT 22
20108: PUSH
20109: LD_INT 4
20111: PUSH
20112: EMPTY
20113: LIST
20114: LIST
20115: PUSH
20116: LD_INT 21
20118: PUSH
20119: LD_INT 1
20121: PUSH
20122: EMPTY
20123: LIST
20124: LIST
20125: PUSH
20126: LD_INT 3
20128: PUSH
20129: LD_INT 25
20131: PUSH
20132: LD_INT 16
20134: PUSH
20135: EMPTY
20136: LIST
20137: LIST
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: PUSH
20143: LD_INT 3
20145: PUSH
20146: LD_INT 25
20148: PUSH
20149: LD_INT 12
20151: PUSH
20152: EMPTY
20153: LIST
20154: LIST
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: PPUSH
20166: CALL_OW 69
20170: PUSH
20171: LD_EXP 55
20175: DIFF
20176: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20177: LD_ADDR_VAR 0 9
20181: PUSH
20182: LD_INT 22
20184: PUSH
20185: LD_INT 4
20187: PUSH
20188: EMPTY
20189: LIST
20190: LIST
20191: PUSH
20192: LD_INT 30
20194: PUSH
20195: LD_INT 3
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL_OW 69
20210: PUSH
20211: LD_INT 1
20213: ARRAY
20214: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20215: LD_INT 35
20217: PPUSH
20218: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20222: LD_EXP 118
20226: PUSH
20227: LD_INT 4
20229: ARRAY
20230: PUSH
20231: LD_INT 5
20233: GREATEREQUAL
20234: PUSH
20235: LD_EXP 118
20239: PUSH
20240: LD_INT 4
20242: ARRAY
20243: PPUSH
20244: LD_INT 58
20246: PUSH
20247: EMPTY
20248: LIST
20249: PPUSH
20250: CALL_OW 72
20254: PUSH
20255: LD_INT 5
20257: GREATEREQUAL
20258: AND
20259: IFFALSE 20215
// powellAllowRetreat := false ;
20261: LD_ADDR_EXP 19
20265: PUSH
20266: LD_INT 0
20268: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20269: LD_INT 700
20271: PPUSH
20272: CALL_OW 67
// activeAttacks := false ;
20276: LD_ADDR_EXP 16
20280: PUSH
20281: LD_INT 0
20283: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20284: LD_INT 35
20286: PPUSH
20287: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20291: LD_INT 22
20293: PUSH
20294: LD_INT 6
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PPUSH
20301: CALL_OW 69
20305: PUSH
20306: LD_INT 0
20308: EQUAL
20309: IFFALSE 20284
// tmp := mc_vehicles [ 4 ] ;
20311: LD_ADDR_VAR 0 3
20315: PUSH
20316: LD_EXP 118
20320: PUSH
20321: LD_INT 4
20323: ARRAY
20324: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20325: LD_ADDR_VAR 0 1
20329: PUSH
20330: DOUBLE
20331: LD_INT 1
20333: DEC
20334: ST_TO_ADDR
20335: LD_EXP 18
20339: PUSH
20340: FOR_TO
20341: IFFALSE 20602
// begin for j in powellSquadAttack [ i ] do
20343: LD_ADDR_VAR 0 2
20347: PUSH
20348: LD_EXP 18
20352: PUSH
20353: LD_VAR 0 1
20357: ARRAY
20358: PUSH
20359: FOR_IN
20360: IFFALSE 20598
// begin forces := forces diff j ;
20362: LD_ADDR_VAR 0 6
20366: PUSH
20367: LD_VAR 0 6
20371: PUSH
20372: LD_VAR 0 2
20376: DIFF
20377: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20378: LD_VAR 0 2
20382: PPUSH
20383: LD_INT 1
20385: PPUSH
20386: CALL_OW 109
// wait ( 0 0$2 ) ;
20390: LD_INT 70
20392: PPUSH
20393: CALL_OW 67
// if IsInUnit ( j ) then
20397: LD_VAR 0 2
20401: PPUSH
20402: CALL_OW 310
20406: IFFALSE 20417
// ComExitBuilding ( j ) ;
20408: LD_VAR 0 2
20412: PPUSH
20413: CALL_OW 122
// if GetClass ( j ) <> 1 then
20417: LD_VAR 0 2
20421: PPUSH
20422: CALL_OW 257
20426: PUSH
20427: LD_INT 1
20429: NONEQUAL
20430: IFFALSE 20510
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20432: LD_VAR 0 10
20436: PUSH
20437: LD_INT 1
20439: ARRAY
20440: PPUSH
20441: CALL_OW 313
20445: PUSH
20446: LD_INT 5
20448: GREATEREQUAL
20449: IFFALSE 20471
// AddComEnterUnit ( j , arm [ 2 ] ) else
20451: LD_VAR 0 2
20455: PPUSH
20456: LD_VAR 0 10
20460: PUSH
20461: LD_INT 2
20463: ARRAY
20464: PPUSH
20465: CALL_OW 180
20469: GO 20489
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20471: LD_VAR 0 2
20475: PPUSH
20476: LD_VAR 0 10
20480: PUSH
20481: LD_INT 1
20483: ARRAY
20484: PPUSH
20485: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20489: LD_VAR 0 2
20493: PPUSH
20494: LD_INT 1
20496: PPUSH
20497: CALL_OW 183
// AddComExitBuilding ( j ) ;
20501: LD_VAR 0 2
20505: PPUSH
20506: CALL_OW 182
// end ; if i = 2 then
20510: LD_VAR 0 1
20514: PUSH
20515: LD_INT 2
20517: EQUAL
20518: IFFALSE 20535
// AddComMoveXY ( j , 61 , 93 ) ;
20520: LD_VAR 0 2
20524: PPUSH
20525: LD_INT 61
20527: PPUSH
20528: LD_INT 93
20530: PPUSH
20531: CALL_OW 171
// if i = 1 then
20535: LD_VAR 0 1
20539: PUSH
20540: LD_INT 1
20542: EQUAL
20543: IFFALSE 20596
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20545: LD_VAR 0 2
20549: PPUSH
20550: LD_VAR 0 3
20554: PUSH
20555: LD_INT 1
20557: ARRAY
20558: PPUSH
20559: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20563: LD_ADDR_VAR 0 3
20567: PUSH
20568: LD_VAR 0 3
20572: PPUSH
20573: LD_INT 1
20575: PPUSH
20576: CALL_OW 3
20580: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20581: LD_VAR 0 2
20585: PPUSH
20586: LD_INT 69
20588: PPUSH
20589: LD_INT 94
20591: PPUSH
20592: CALL_OW 171
// end ; end ;
20596: GO 20359
20598: POP
20599: POP
// end ;
20600: GO 20340
20602: POP
20603: POP
// wait ( 0 0$55 ) ;
20604: LD_INT 1925
20606: PPUSH
20607: CALL_OW 67
// MC_Kill ( 4 ) ;
20611: LD_INT 4
20613: PPUSH
20614: CALL 33987 0 1
// tmp := UnitsInside ( fac ) ;
20618: LD_ADDR_VAR 0 3
20622: PUSH
20623: LD_VAR 0 9
20627: PPUSH
20628: CALL_OW 313
20632: ST_TO_ADDR
// if tmp then
20633: LD_VAR 0 3
20637: IFFALSE 20758
// for i in tmp do
20639: LD_ADDR_VAR 0 1
20643: PUSH
20644: LD_VAR 0 3
20648: PUSH
20649: FOR_IN
20650: IFFALSE 20756
// begin ComExitBuilding ( i ) ;
20652: LD_VAR 0 1
20656: PPUSH
20657: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20661: LD_VAR 0 10
20665: PUSH
20666: LD_INT 2
20668: ARRAY
20669: PPUSH
20670: CALL_OW 313
20674: PUSH
20675: LD_INT 6
20677: LESS
20678: IFFALSE 20700
// AddComEnterUnit ( i , arm [ 2 ] ) else
20680: LD_VAR 0 1
20684: PPUSH
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 2
20692: ARRAY
20693: PPUSH
20694: CALL_OW 180
20698: GO 20754
// if UnitsInside ( arm [ 1 ] ) < 6 then
20700: LD_VAR 0 10
20704: PUSH
20705: LD_INT 1
20707: ARRAY
20708: PPUSH
20709: CALL_OW 313
20713: PUSH
20714: LD_INT 6
20716: LESS
20717: IFFALSE 20739
// AddComEnterUnit ( i , arm [ 1 ] ) else
20719: LD_VAR 0 1
20723: PPUSH
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 180
20737: GO 20754
// AddComMoveXY ( i , 37 , 68 ) ;
20739: LD_VAR 0 1
20743: PPUSH
20744: LD_INT 37
20746: PPUSH
20747: LD_INT 68
20749: PPUSH
20750: CALL_OW 171
// end ;
20754: GO 20649
20756: POP
20757: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20758: LD_ADDR_VAR 0 11
20762: PUSH
20763: LD_VAR 0 6
20767: PPUSH
20768: LD_INT 26
20770: PUSH
20771: LD_INT 1
20773: PUSH
20774: EMPTY
20775: LIST
20776: LIST
20777: PPUSH
20778: CALL_OW 72
20782: PUSH
20783: LD_EXP 56
20787: DIFF
20788: ST_TO_ADDR
// if not speaker then
20789: LD_VAR 0 11
20793: NOT
20794: IFFALSE 20821
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20796: LD_ADDR_VAR 0 11
20800: PUSH
20801: LD_VAR 0 6
20805: PPUSH
20806: LD_INT 26
20808: PUSH
20809: LD_INT 1
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: PPUSH
20816: CALL_OW 72
20820: ST_TO_ADDR
// if speaker then
20821: LD_VAR 0 11
20825: IFFALSE 20841
// speaker := speaker [ 1 ] ;
20827: LD_ADDR_VAR 0 11
20831: PUSH
20832: LD_VAR 0 11
20836: PUSH
20837: LD_INT 1
20839: ARRAY
20840: ST_TO_ADDR
// Video ( true ) ;
20841: LD_INT 1
20843: PPUSH
20844: CALL 105303 0 1
// CenterNowOnUnits ( Powell ) ;
20848: LD_EXP 55
20852: PPUSH
20853: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20857: LD_ADDR_VAR 0 3
20861: PUSH
20862: LD_VAR 0 6
20866: PPUSH
20867: LD_INT 3
20869: PUSH
20870: LD_INT 25
20872: PUSH
20873: LD_INT 1
20875: PUSH
20876: EMPTY
20877: LIST
20878: LIST
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PPUSH
20884: CALL_OW 72
20888: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20889: LD_ADDR_VAR 0 12
20893: PUSH
20894: LD_INT 22
20896: PUSH
20897: LD_INT 4
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PUSH
20904: LD_INT 30
20906: PUSH
20907: LD_INT 32
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: PUSH
20914: LD_INT 58
20916: PUSH
20917: EMPTY
20918: LIST
20919: PUSH
20920: EMPTY
20921: LIST
20922: LIST
20923: LIST
20924: PPUSH
20925: CALL_OW 69
20929: ST_TO_ADDR
// for i = 1 to 6 do
20930: LD_ADDR_VAR 0 1
20934: PUSH
20935: DOUBLE
20936: LD_INT 1
20938: DEC
20939: ST_TO_ADDR
20940: LD_INT 6
20942: PUSH
20943: FOR_TO
20944: IFFALSE 21085
// begin if IsInUnit ( tmp [ i ] ) then
20946: LD_VAR 0 3
20950: PUSH
20951: LD_VAR 0 1
20955: ARRAY
20956: PPUSH
20957: CALL_OW 310
20961: IFFALSE 20978
// ComExitBuilding ( tmp [ i ] ) ;
20963: LD_VAR 0 3
20967: PUSH
20968: LD_VAR 0 1
20972: ARRAY
20973: PPUSH
20974: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20978: LD_VAR 0 3
20982: PUSH
20983: LD_VAR 0 1
20987: ARRAY
20988: PPUSH
20989: LD_VAR 0 10
20993: PUSH
20994: LD_INT 1
20996: ARRAY
20997: PPUSH
20998: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21002: LD_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: ARRAY
21012: PPUSH
21013: LD_INT 1
21015: PPUSH
21016: CALL_OW 183
// if emp_towers then
21020: LD_VAR 0 12
21024: IFFALSE 21083
// begin AddComExitBuilding ( tmp [ i ] ) ;
21026: LD_VAR 0 3
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: PPUSH
21037: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21041: LD_VAR 0 3
21045: PUSH
21046: LD_VAR 0 1
21050: ARRAY
21051: PPUSH
21052: LD_VAR 0 12
21056: PUSH
21057: LD_INT 1
21059: ARRAY
21060: PPUSH
21061: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21065: LD_ADDR_VAR 0 12
21069: PUSH
21070: LD_VAR 0 12
21074: PPUSH
21075: LD_INT 1
21077: PPUSH
21078: CALL_OW 3
21082: ST_TO_ADDR
// end ; end ;
21083: GO 20943
21085: POP
21086: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21087: LD_ADDR_VAR 0 3
21091: PUSH
21092: LD_EXP 18
21096: PUSH
21097: LD_INT 1
21099: ARRAY
21100: PUSH
21101: LD_EXP 18
21105: PUSH
21106: LD_INT 2
21108: ARRAY
21109: ADD
21110: PPUSH
21111: LD_INT 26
21113: PUSH
21114: LD_INT 1
21116: PUSH
21117: EMPTY
21118: LIST
21119: LIST
21120: PPUSH
21121: CALL_OW 72
21125: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21126: LD_ADDR_VAR 0 1
21130: PUSH
21131: LD_EXP 18
21135: PUSH
21136: LD_INT 2
21138: ARRAY
21139: PUSH
21140: FOR_IN
21141: IFFALSE 21159
// ComTurnUnit ( i , Powell ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_EXP 55
21152: PPUSH
21153: CALL_OW 119
21157: GO 21140
21159: POP
21160: POP
// Say ( Powell , D5-Pow-1 ) ;
21161: LD_EXP 55
21165: PPUSH
21166: LD_STRING D5-Pow-1
21168: PPUSH
21169: CALL_OW 88
// if tmp then
21173: LD_VAR 0 3
21177: IFFALSE 21195
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21179: LD_VAR 0 3
21183: PUSH
21184: LD_INT 1
21186: ARRAY
21187: PPUSH
21188: LD_STRING D5-Sol2-1
21190: PPUSH
21191: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21195: LD_EXP 55
21199: PPUSH
21200: LD_STRING D5-Pow-2
21202: PPUSH
21203: CALL_OW 88
// if tmp > 1 then
21207: LD_VAR 0 3
21211: PUSH
21212: LD_INT 1
21214: GREATER
21215: IFFALSE 21233
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21217: LD_VAR 0 3
21221: PUSH
21222: LD_INT 2
21224: ARRAY
21225: PPUSH
21226: LD_STRING D5-Sol2-2
21228: PPUSH
21229: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21233: LD_EXP 55
21237: PPUSH
21238: LD_STRING D5-Pow-3
21240: PPUSH
21241: CALL_OW 88
// wait ( 0 0$1 ) ;
21245: LD_INT 35
21247: PPUSH
21248: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21252: LD_ADDR_VAR 0 3
21256: PUSH
21257: LD_EXP 18
21261: PUSH
21262: LD_INT 1
21264: ARRAY
21265: PUSH
21266: LD_EXP 18
21270: PUSH
21271: LD_INT 2
21273: ARRAY
21274: UNION
21275: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21276: LD_VAR 0 3
21280: PPUSH
21281: LD_INT 80
21283: PPUSH
21284: LD_INT 67
21286: PPUSH
21287: CALL_OW 114
// wait ( 0 0$2 ) ;
21291: LD_INT 70
21293: PPUSH
21294: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21298: LD_INT 79
21300: PPUSH
21301: LD_INT 72
21303: PPUSH
21304: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21308: LD_INT 35
21310: PPUSH
21311: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21315: LD_VAR 0 3
21319: PPUSH
21320: LD_INT 3
21322: PUSH
21323: LD_INT 24
21325: PUSH
21326: LD_INT 1000
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: PPUSH
21337: CALL_OW 72
21341: IFFALSE 21308
// Say ( Powell , D5a-Pow-1 ) ;
21343: LD_EXP 55
21347: PPUSH
21348: LD_STRING D5a-Pow-1
21350: PPUSH
21351: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21355: LD_EXP 55
21359: PPUSH
21360: LD_STRING D5a-Pow-1a
21362: PPUSH
21363: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21367: LD_INT 10
21369: PPUSH
21370: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21374: LD_EXP 55
21378: PPUSH
21379: LD_STRING D5a-Pow-1b
21381: PPUSH
21382: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21386: LD_EXP 55
21390: PPUSH
21391: LD_STRING D5a-Pow-1c
21393: PPUSH
21394: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21398: LD_EXP 55
21402: PPUSH
21403: LD_STRING D5a-Pow-1d
21405: PPUSH
21406: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21410: LD_INT 35
21412: PPUSH
21413: CALL_OW 67
// if not HasTask ( tmp ) then
21417: LD_VAR 0 3
21421: PPUSH
21422: CALL_OW 314
21426: NOT
21427: IFFALSE 21444
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21429: LD_VAR 0 3
21433: PPUSH
21434: LD_INT 80
21436: PPUSH
21437: LD_INT 67
21439: PPUSH
21440: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21444: LD_VAR 0 3
21448: PPUSH
21449: LD_INT 24
21451: PUSH
21452: LD_INT 1
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: PPUSH
21459: CALL_OW 72
21463: NOT
21464: IFFALSE 21410
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_INT 22
21473: PUSH
21474: LD_INT 4
21476: PUSH
21477: EMPTY
21478: LIST
21479: LIST
21480: PUSH
21481: LD_INT 92
21483: PUSH
21484: LD_INT 60
21486: PUSH
21487: LD_INT 93
21489: PUSH
21490: LD_INT 10
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: PUSH
21499: LD_INT 3
21501: PUSH
21502: LD_INT 54
21504: PUSH
21505: EMPTY
21506: LIST
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: LIST
21516: PPUSH
21517: CALL_OW 69
21521: PUSH
21522: LD_EXP 55
21526: DIFF
21527: ST_TO_ADDR
// if tmp then
21528: LD_VAR 0 3
21532: IFFALSE 21566
// for i in tmp do
21534: LD_ADDR_VAR 0 1
21538: PUSH
21539: LD_VAR 0 3
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21564
// ComMoveXY ( i , 36 , 67 ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_INT 36
21554: PPUSH
21555: LD_INT 67
21557: PPUSH
21558: CALL_OW 111
21562: GO 21544
21564: POP
21565: POP
// wait ( 0 0$3 ) ;
21566: LD_INT 105
21568: PPUSH
21569: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21573: LD_VAR 0 11
21577: PPUSH
21578: LD_STRING D6-Sol3-1
21580: PPUSH
21581: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21585: LD_EXP 55
21589: PPUSH
21590: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21594: LD_EXP 55
21598: PPUSH
21599: LD_STRING D6-Pow-1
21601: PPUSH
21602: CALL_OW 88
// tmp := [ ] ;
21606: LD_ADDR_VAR 0 3
21610: PUSH
21611: EMPTY
21612: ST_TO_ADDR
// for i = 1 to 2 do
21613: LD_ADDR_VAR 0 1
21617: PUSH
21618: DOUBLE
21619: LD_INT 1
21621: DEC
21622: ST_TO_ADDR
21623: LD_INT 2
21625: PUSH
21626: FOR_TO
21627: IFFALSE 21734
// begin uc_side := 8 ;
21629: LD_ADDR_OWVAR 20
21633: PUSH
21634: LD_INT 8
21636: ST_TO_ADDR
// uc_nation := 2 ;
21637: LD_ADDR_OWVAR 21
21641: PUSH
21642: LD_INT 2
21644: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21645: LD_INT 14
21647: PPUSH
21648: LD_INT 3
21650: PPUSH
21651: LD_INT 2
21653: PPUSH
21654: LD_INT 29
21656: PPUSH
21657: LD_INT 100
21659: PPUSH
21660: CALL 69586 0 5
// veh := CreateVehicle ;
21664: LD_ADDR_VAR 0 13
21668: PUSH
21669: CALL_OW 45
21673: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21674: LD_VAR 0 13
21678: PPUSH
21679: LD_INT 4
21681: PPUSH
21682: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21686: LD_VAR 0 13
21690: PPUSH
21691: LD_INT 99
21693: PPUSH
21694: LD_INT 83
21696: PPUSH
21697: LD_INT 5
21699: PPUSH
21700: LD_INT 0
21702: PPUSH
21703: CALL_OW 50
// Connect ( veh ) ;
21707: LD_VAR 0 13
21711: PPUSH
21712: CALL 72641 0 1
// tmp := tmp ^ veh ;
21716: LD_ADDR_VAR 0 3
21720: PUSH
21721: LD_VAR 0 3
21725: PUSH
21726: LD_VAR 0 13
21730: ADD
21731: ST_TO_ADDR
// end ;
21732: GO 21626
21734: POP
21735: POP
// wait ( 0 0$1 ) ;
21736: LD_INT 35
21738: PPUSH
21739: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21743: LD_INT 99
21745: PPUSH
21746: LD_INT 83
21748: PPUSH
21749: LD_INT 1
21751: PPUSH
21752: LD_INT 10
21754: PPUSH
21755: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21759: LD_INT 99
21761: PPUSH
21762: LD_INT 83
21764: PPUSH
21765: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21769: LD_VAR 0 11
21773: PPUSH
21774: LD_STRING D6-Sol3-2
21776: PPUSH
21777: CALL_OW 88
// async ;
21781: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21782: LD_EXP 55
21786: PPUSH
21787: LD_STRING D6-Pow-2
21789: PPUSH
21790: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21794: LD_VAR 0 3
21798: PUSH
21799: LD_INT 1
21801: ARRAY
21802: PPUSH
21803: LD_VAR 0 9
21807: PPUSH
21808: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21812: LD_VAR 0 3
21816: PUSH
21817: LD_INT 2
21819: ARRAY
21820: PPUSH
21821: LD_INT 22
21823: PUSH
21824: LD_INT 4
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_INT 21
21833: PUSH
21834: LD_INT 3
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PPUSH
21845: CALL_OW 69
21849: PPUSH
21850: LD_VAR 0 3
21854: PUSH
21855: LD_INT 2
21857: ARRAY
21858: PPUSH
21859: CALL_OW 74
21863: PPUSH
21864: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21868: LD_EXP 55
21872: PPUSH
21873: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21877: LD_INT 99
21879: PPUSH
21880: LD_INT 83
21882: PPUSH
21883: LD_INT 1
21885: PPUSH
21886: CALL_OW 331
// repeat wait ( 4 ) ;
21890: LD_INT 4
21892: PPUSH
21893: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21897: LD_VAR 0 3
21901: PUSH
21902: LD_INT 1
21904: ARRAY
21905: PPUSH
21906: CALL_OW 256
21910: PUSH
21911: LD_INT 1000
21913: LESS
21914: IFFALSE 21932
// SetLives ( tmp [ 1 ] , 1000 ) ;
21916: LD_VAR 0 3
21920: PUSH
21921: LD_INT 1
21923: ARRAY
21924: PPUSH
21925: LD_INT 1000
21927: PPUSH
21928: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21932: LD_INT 22
21934: PUSH
21935: LD_INT 4
21937: PUSH
21938: EMPTY
21939: LIST
21940: LIST
21941: PUSH
21942: LD_INT 30
21944: PUSH
21945: LD_INT 3
21947: PUSH
21948: EMPTY
21949: LIST
21950: LIST
21951: PUSH
21952: EMPTY
21953: LIST
21954: LIST
21955: PPUSH
21956: CALL_OW 69
21960: PUSH
21961: LD_INT 0
21963: EQUAL
21964: IFFALSE 21890
// sync ;
21966: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21967: LD_EXP 55
21971: PPUSH
21972: LD_STRING D6a-Pow-1
21974: PPUSH
21975: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21979: LD_VAR 0 11
21983: PPUSH
21984: LD_STRING D6a-Sol3-1
21986: PPUSH
21987: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21991: LD_EXP 55
21995: PPUSH
21996: LD_STRING D6a-Pow-2
21998: PPUSH
21999: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22003: LD_VAR 0 11
22007: PPUSH
22008: LD_STRING D6a-Sol3-2
22010: PPUSH
22011: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22015: LD_EXP 55
22019: PPUSH
22020: LD_STRING D6a-Pow-3
22022: PPUSH
22023: CALL_OW 88
// powellCenterCameraMode := true ;
22027: LD_ADDR_EXP 20
22031: PUSH
22032: LD_INT 1
22034: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22035: LD_ADDR_VAR 0 1
22039: PUSH
22040: LD_INT 22
22042: PUSH
22043: LD_INT 8
22045: PUSH
22046: EMPTY
22047: LIST
22048: LIST
22049: PUSH
22050: LD_INT 25
22052: PUSH
22053: LD_INT 2
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: PUSH
22060: EMPTY
22061: LIST
22062: LIST
22063: PPUSH
22064: CALL_OW 69
22068: PUSH
22069: FOR_IN
22070: IFFALSE 22125
// begin SetTag ( i , 1 ) ;
22072: LD_VAR 0 1
22076: PPUSH
22077: LD_INT 1
22079: PPUSH
22080: CALL_OW 109
// ComExitBuilding ( i ) ;
22084: LD_VAR 0 1
22088: PPUSH
22089: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22093: LD_VAR 0 1
22097: PPUSH
22098: LD_INT 35
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_INT 53
22115: PPUSH
22116: LD_INT 4
22118: PPUSH
22119: CALL_OW 171
// end ;
22123: GO 22069
22125: POP
22126: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_INT 22
22134: PUSH
22135: LD_INT 4
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: PUSH
22142: LD_INT 21
22144: PUSH
22145: LD_INT 2
22147: PUSH
22148: EMPTY
22149: LIST
22150: LIST
22151: PUSH
22152: LD_INT 3
22154: PUSH
22155: LD_INT 34
22157: PUSH
22158: LD_INT 12
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: LIST
22173: PPUSH
22174: CALL_OW 69
22178: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22179: LD_EXP 55
22183: PPUSH
22184: LD_VAR 0 3
22188: PPUSH
22189: LD_EXP 55
22193: PPUSH
22194: CALL_OW 74
22198: PPUSH
22199: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22203: LD_EXP 55
22207: PPUSH
22208: LD_INT 100
22210: PPUSH
22211: LD_INT 88
22213: PPUSH
22214: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22218: LD_EXP 55
22222: PPUSH
22223: LD_INT 100
22225: PPUSH
22226: LD_INT 75
22228: PPUSH
22229: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22233: LD_EXP 55
22237: PPUSH
22238: LD_INT 88
22240: PPUSH
22241: LD_INT 53
22243: PPUSH
22244: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22248: LD_INT 8
22250: PPUSH
22251: LD_EXP 55
22255: PPUSH
22256: CALL_OW 471
// repeat wait ( 3 ) ;
22260: LD_INT 3
22262: PPUSH
22263: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22267: LD_INT 22
22269: PUSH
22270: LD_INT 4
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: PUSH
22277: LD_INT 92
22279: PUSH
22280: LD_INT 100
22282: PUSH
22283: LD_INT 75
22285: PUSH
22286: LD_INT 6
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: LIST
22293: LIST
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PPUSH
22299: CALL_OW 69
22303: IFFALSE 22260
// async ;
22305: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22306: LD_EXP 55
22310: PPUSH
22311: LD_STRING D6b-Pow-1
22313: PPUSH
22314: CALL_OW 88
// repeat wait ( 3 ) ;
22318: LD_INT 3
22320: PPUSH
22321: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22325: LD_EXP 55
22329: PPUSH
22330: CALL_OW 310
22334: PPUSH
22335: CALL_OW 256
22339: PUSH
22340: LD_INT 1000
22342: LESS
22343: IFFALSE 22362
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22345: LD_EXP 55
22349: PPUSH
22350: CALL_OW 310
22354: PPUSH
22355: LD_INT 1000
22357: PPUSH
22358: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22362: LD_EXP 55
22366: PPUSH
22367: CALL_OW 256
22371: PUSH
22372: LD_INT 1000
22374: LESS
22375: IFFALSE 22389
// SetLives ( Powell , 1000 ) ;
22377: LD_EXP 55
22381: PPUSH
22382: LD_INT 1000
22384: PPUSH
22385: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22389: LD_EXP 55
22393: PPUSH
22394: LD_EXP 60
22398: PPUSH
22399: CALL_OW 296
22403: PUSH
22404: LD_INT 5
22406: LESS
22407: PUSH
22408: LD_EXP 55
22412: PPUSH
22413: CALL_OW 310
22417: PPUSH
22418: LD_EXP 60
22422: PPUSH
22423: CALL_OW 296
22427: PUSH
22428: LD_INT 5
22430: LESS
22431: OR
22432: IFFALSE 22451
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22434: LD_EXP 55
22438: PPUSH
22439: CALL_OW 310
22443: PPUSH
22444: LD_INT 100
22446: PPUSH
22447: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22451: LD_EXP 55
22455: PPUSH
22456: CALL_OW 310
22460: NOT
22461: IFFALSE 22318
// game_speed := 4 ;
22463: LD_ADDR_OWVAR 65
22467: PUSH
22468: LD_INT 4
22470: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22471: LD_EXP 55
22475: PPUSH
22476: LD_STRING D6b-Pow-1a
22478: PPUSH
22479: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22483: LD_EXP 55
22487: PPUSH
22488: LD_EXP 60
22492: PPUSH
22493: CALL_OW 180
// sync ;
22497: SYNC
// repeat wait ( 0 0$1 ) ;
22498: LD_INT 35
22500: PPUSH
22501: CALL_OW 67
// until IsInUnit ( Powell ) ;
22505: LD_EXP 55
22509: PPUSH
22510: CALL_OW 310
22514: IFFALSE 22498
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22516: LD_INT 8
22518: PPUSH
22519: LD_EXP 55
22523: PPUSH
22524: CALL_OW 310
22528: PPUSH
22529: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22533: LD_EXP 55
22537: PPUSH
22538: LD_INT 91
22540: PPUSH
22541: LD_INT 44
22543: PPUSH
22544: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22548: LD_EXP 55
22552: PPUSH
22553: LD_INT 96
22555: PPUSH
22556: LD_INT 44
22558: PPUSH
22559: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22563: LD_EXP 55
22567: PPUSH
22568: LD_INT 96
22570: PPUSH
22571: LD_INT 41
22573: PPUSH
22574: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22578: LD_EXP 55
22582: PPUSH
22583: LD_INT 92
22585: PPUSH
22586: LD_INT 39
22588: PPUSH
22589: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22593: LD_EXP 55
22597: PPUSH
22598: LD_INT 88
22600: PPUSH
22601: LD_INT 41
22603: PPUSH
22604: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22608: LD_EXP 55
22612: PPUSH
22613: LD_INT 91
22615: PPUSH
22616: LD_INT 44
22618: PPUSH
22619: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22623: LD_EXP 55
22627: PPUSH
22628: LD_INT 96
22630: PPUSH
22631: LD_INT 44
22633: PPUSH
22634: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22638: LD_EXP 55
22642: PPUSH
22643: LD_INT 96
22645: PPUSH
22646: LD_INT 41
22648: PPUSH
22649: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22653: LD_EXP 55
22657: PPUSH
22658: LD_INT 92
22660: PPUSH
22661: LD_INT 39
22663: PPUSH
22664: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22668: LD_EXP 55
22672: PPUSH
22673: LD_INT 88
22675: PPUSH
22676: LD_INT 41
22678: PPUSH
22679: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22683: LD_EXP 55
22687: PPUSH
22688: LD_INT 91
22690: PPUSH
22691: LD_INT 44
22693: PPUSH
22694: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22698: LD_EXP 55
22702: PPUSH
22703: LD_INT 93
22705: PPUSH
22706: LD_INT 39
22708: PPUSH
22709: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22713: LD_EXP 55
22717: PPUSH
22718: LD_INT 93
22720: PPUSH
22721: LD_INT 36
22723: PPUSH
22724: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22728: LD_INT 122
22730: PPUSH
22731: CALL_OW 67
// game_speed := 4 ;
22735: LD_ADDR_OWVAR 65
22739: PUSH
22740: LD_INT 4
22742: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22743: LD_EXP 55
22747: PPUSH
22748: LD_STRING D6b-Pow-1b
22750: PPUSH
22751: CALL_OW 88
// tmp := [ ] ;
22755: LD_ADDR_VAR 0 3
22759: PUSH
22760: EMPTY
22761: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22762: LD_ADDR_VAR 0 5
22766: PUSH
22767: LD_INT 78
22769: PUSH
22770: LD_INT 47
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 106
22779: PUSH
22780: LD_INT 53
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22791: LD_ADDR_VAR 0 1
22795: PUSH
22796: LD_INT 22
22798: PUSH
22799: LD_INT 8
22801: PUSH
22802: EMPTY
22803: LIST
22804: LIST
22805: PUSH
22806: LD_INT 21
22808: PUSH
22809: LD_INT 3
22811: PUSH
22812: EMPTY
22813: LIST
22814: LIST
22815: PUSH
22816: LD_INT 92
22818: PUSH
22819: LD_INT 90
22821: PUSH
22822: LD_INT 52
22824: PUSH
22825: LD_INT 12
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: LIST
22838: PPUSH
22839: CALL_OW 69
22843: PUSH
22844: FOR_IN
22845: IFFALSE 22870
// tmp := tmp ^ UnitsInside ( i ) ;
22847: LD_ADDR_VAR 0 3
22851: PUSH
22852: LD_VAR 0 3
22856: PUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: CALL_OW 313
22866: ADD
22867: ST_TO_ADDR
22868: GO 22844
22870: POP
22871: POP
// for i in tmp do
22872: LD_ADDR_VAR 0 1
22876: PUSH
22877: LD_VAR 0 3
22881: PUSH
22882: FOR_IN
22883: IFFALSE 23045
// begin dist := 9999 ;
22885: LD_ADDR_VAR 0 8
22889: PUSH
22890: LD_INT 9999
22892: ST_TO_ADDR
// _xy := [ ] ;
22893: LD_ADDR_VAR 0 7
22897: PUSH
22898: EMPTY
22899: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22900: LD_VAR 0 1
22904: PPUSH
22905: LD_INT 1
22907: PPUSH
22908: CALL_OW 109
// ComExitBuilding ( i ) ;
22912: LD_VAR 0 1
22916: PPUSH
22917: CALL_OW 122
// for j in xy do
22921: LD_ADDR_VAR 0 2
22925: PUSH
22926: LD_VAR 0 5
22930: PUSH
22931: FOR_IN
22932: IFFALSE 23014
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22934: LD_VAR 0 1
22938: PPUSH
22939: LD_VAR 0 2
22943: PUSH
22944: LD_INT 1
22946: ARRAY
22947: PPUSH
22948: LD_VAR 0 2
22952: PUSH
22953: LD_INT 2
22955: ARRAY
22956: PPUSH
22957: CALL_OW 297
22961: PUSH
22962: LD_VAR 0 8
22966: LESS
22967: IFFALSE 23012
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22969: LD_ADDR_VAR 0 8
22973: PUSH
22974: LD_VAR 0 1
22978: PPUSH
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 1
22986: ARRAY
22987: PPUSH
22988: LD_VAR 0 2
22992: PUSH
22993: LD_INT 2
22995: ARRAY
22996: PPUSH
22997: CALL_OW 297
23001: ST_TO_ADDR
// _xy := j ;
23002: LD_ADDR_VAR 0 7
23006: PUSH
23007: LD_VAR 0 2
23011: ST_TO_ADDR
// end ;
23012: GO 22931
23014: POP
23015: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23016: LD_VAR 0 1
23020: PPUSH
23021: LD_VAR 0 7
23025: PUSH
23026: LD_INT 1
23028: ARRAY
23029: PPUSH
23030: LD_VAR 0 7
23034: PUSH
23035: LD_INT 2
23037: ARRAY
23038: PPUSH
23039: CALL_OW 171
// end ;
23043: GO 22882
23045: POP
23046: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23047: LD_ADDR_VAR 0 4
23051: PUSH
23052: LD_VAR 0 3
23056: PPUSH
23057: LD_INT 26
23059: PUSH
23060: LD_INT 1
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: LD_INT 25
23069: PUSH
23070: LD_INT 1
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PPUSH
23081: CALL_OW 72
23085: ST_TO_ADDR
// if tmp2 < 2 then
23086: LD_VAR 0 4
23090: PUSH
23091: LD_INT 2
23093: LESS
23094: IFFALSE 23163
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23096: LD_ADDR_VAR 0 4
23100: PUSH
23101: LD_INT 22
23103: PUSH
23104: LD_INT 8
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PUSH
23111: LD_INT 26
23113: PUSH
23114: LD_INT 1
23116: PUSH
23117: EMPTY
23118: LIST
23119: LIST
23120: PUSH
23121: LD_INT 3
23123: PUSH
23124: LD_INT 25
23126: PUSH
23127: LD_INT 15
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: LIST
23142: PPUSH
23143: CALL_OW 69
23147: PUSH
23148: LD_EXP 57
23152: PUSH
23153: LD_EXP 58
23157: PUSH
23158: EMPTY
23159: LIST
23160: LIST
23161: DIFF
23162: ST_TO_ADDR
// if tmp2 then
23163: LD_VAR 0 4
23167: IFFALSE 23185
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23169: LD_VAR 0 4
23173: PUSH
23174: LD_INT 1
23176: ARRAY
23177: PPUSH
23178: LD_STRING D6b-ArSol1-1
23180: PPUSH
23181: CALL_OW 88
// async ;
23185: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23186: LD_EXP 55
23190: PPUSH
23191: LD_STRING D6b-Pow-2
23193: PPUSH
23194: CALL_OW 88
// wait ( 0 0$1 ) ;
23198: LD_INT 35
23200: PPUSH
23201: CALL_OW 67
// if tmp2 > 1 then
23205: LD_VAR 0 4
23209: PUSH
23210: LD_INT 1
23212: GREATER
23213: IFFALSE 23231
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23215: LD_VAR 0 4
23219: PUSH
23220: LD_INT 2
23222: ARRAY
23223: PPUSH
23224: LD_STRING D6b-ArSol2-1
23226: PPUSH
23227: CALL_OW 88
// sync ;
23231: SYNC
// repeat wait ( 5 ) ;
23232: LD_INT 5
23234: PPUSH
23235: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23239: LD_INT 93
23241: PPUSH
23242: LD_INT 36
23244: PPUSH
23245: CALL_OW 428
23249: PPUSH
23250: CALL_OW 255
23254: PUSH
23255: LD_INT 4
23257: EQUAL
23258: IFFALSE 23232
// DialogueOn ;
23260: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23264: LD_INT 10
23266: PPUSH
23267: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23271: LD_EXP 55
23275: PPUSH
23276: LD_STRING D6b-Pow-2a
23278: PPUSH
23279: CALL_OW 88
// DialogueOff ;
23283: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23287: LD_EXP 55
23291: PPUSH
23292: CALL_OW 310
23296: PPUSH
23297: LD_INT 332
23299: PPUSH
23300: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23304: LD_INT 93
23306: PPUSH
23307: LD_INT 35
23309: PPUSH
23310: LD_INT 1
23312: PPUSH
23313: LD_INT 6
23315: NEG
23316: PPUSH
23317: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23321: LD_INT 35
23323: PPUSH
23324: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23328: LD_INT 332
23330: PPUSH
23331: CALL_OW 256
23335: PUSH
23336: LD_INT 1000
23338: LESS
23339: PUSH
23340: LD_INT 332
23342: PPUSH
23343: CALL_OW 300
23347: AND
23348: IFFALSE 23360
// SetLives ( kozlov_fac , 0 ) ;
23350: LD_INT 332
23352: PPUSH
23353: LD_INT 0
23355: PPUSH
23356: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23360: LD_INT 332
23362: PPUSH
23363: CALL_OW 301
23367: PUSH
23368: LD_EXP 55
23372: PPUSH
23373: CALL_OW 301
23377: OR
23378: IFFALSE 23321
// game_speed := 4 ;
23380: LD_ADDR_OWVAR 65
23384: PUSH
23385: LD_INT 4
23387: ST_TO_ADDR
// powellCenterCameraMode := false ;
23388: LD_ADDR_EXP 20
23392: PUSH
23393: LD_INT 0
23395: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23396: LD_ADDR_VAR 0 1
23400: PUSH
23401: LD_VAR 0 3
23405: PUSH
23406: LD_INT 22
23408: PUSH
23409: LD_INT 8
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: PUSH
23416: LD_INT 25
23418: PUSH
23419: LD_INT 2
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: PUSH
23426: EMPTY
23427: LIST
23428: LIST
23429: PPUSH
23430: CALL_OW 69
23434: UNION
23435: PUSH
23436: FOR_IN
23437: IFFALSE 23453
// SetTag ( i , 0 ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_INT 0
23446: PPUSH
23447: CALL_OW 109
23451: GO 23436
23453: POP
23454: POP
// wait ( 0 0$3 ) ;
23455: LD_INT 105
23457: PPUSH
23458: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23462: LD_INT 93
23464: PPUSH
23465: LD_INT 35
23467: PPUSH
23468: LD_INT 1
23470: PPUSH
23471: CALL_OW 331
// DialogueOn ;
23475: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23479: LD_VAR 0 11
23483: PPUSH
23484: LD_STRING D6c-Sol3-1
23486: PPUSH
23487: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23491: LD_INT 10
23493: PPUSH
23494: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23498: LD_EXP 36
23502: PPUSH
23503: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23507: LD_EXP 36
23511: PPUSH
23512: LD_STRING D6c-JMM-1
23514: PPUSH
23515: CALL_OW 88
// if Cyrus then
23519: LD_EXP 42
23523: IFFALSE 23537
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23525: LD_EXP 42
23529: PPUSH
23530: LD_STRING D6c-Cyrus-1
23532: PPUSH
23533: CALL_OW 88
// if Bobby then
23537: LD_EXP 41
23541: IFFALSE 23555
// Say ( Bobby , D6c-Bobby-1 ) ;
23543: LD_EXP 41
23547: PPUSH
23548: LD_STRING D6c-Bobby-1
23550: PPUSH
23551: CALL_OW 88
// if Cornel then
23555: LD_EXP 47
23559: IFFALSE 23573
// Say ( Cornel , D6c-Corn-1 ) ;
23561: LD_EXP 47
23565: PPUSH
23566: LD_STRING D6c-Corn-1
23568: PPUSH
23569: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23573: LD_ADDR_VAR 0 4
23577: PUSH
23578: LD_INT 2
23580: PUSH
23581: LD_INT 22
23583: PUSH
23584: LD_INT 1
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: LD_INT 22
23593: PUSH
23594: LD_INT 4
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: PUSH
23606: LD_INT 26
23608: PUSH
23609: LD_INT 1
23611: PUSH
23612: EMPTY
23613: LIST
23614: LIST
23615: PUSH
23616: LD_INT 3
23618: PUSH
23619: LD_INT 25
23621: PUSH
23622: LD_INT 16
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: PUSH
23629: LD_INT 25
23631: PUSH
23632: LD_INT 12
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: LIST
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: LIST
23648: PPUSH
23649: CALL_OW 69
23653: PUSH
23654: LD_VAR 0 11
23658: PUSH
23659: LD_EXP 36
23663: UNION
23664: PUSH
23665: LD_EXP 56
23669: UNION
23670: PUSH
23671: EMPTY
23672: LIST
23673: DIFF
23674: ST_TO_ADDR
// if tmp2 then
23675: LD_VAR 0 4
23679: IFFALSE 23697
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23681: LD_VAR 0 4
23685: PUSH
23686: LD_INT 1
23688: ARRAY
23689: PPUSH
23690: LD_STRING D6c-Sol1-1
23692: PPUSH
23693: CALL_OW 88
// if Lisa then
23697: LD_EXP 39
23701: IFFALSE 23715
// Say ( Lisa , D6c-Lisa-1 ) ;
23703: LD_EXP 39
23707: PPUSH
23708: LD_STRING D6c-Lisa-1
23710: PPUSH
23711: CALL_OW 88
// if Gary then
23715: LD_EXP 48
23719: IFFALSE 23733
// Say ( Gary , D6c-Gary-1 ) ;
23721: LD_EXP 48
23725: PPUSH
23726: LD_STRING D6c-Gary-1
23728: PPUSH
23729: CALL_OW 88
// if Donaldson then
23733: LD_EXP 40
23737: IFFALSE 23751
// Say ( Donaldson , D6c-Don-1 ) ;
23739: LD_EXP 40
23743: PPUSH
23744: LD_STRING D6c-Don-1
23746: PPUSH
23747: CALL_OW 88
// if tmp2 > 1 then
23751: LD_VAR 0 4
23755: PUSH
23756: LD_INT 1
23758: GREATER
23759: IFFALSE 23777
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23761: LD_VAR 0 4
23765: PUSH
23766: LD_INT 2
23768: ARRAY
23769: PPUSH
23770: LD_STRING D6c-Sol2-1
23772: PPUSH
23773: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23777: LD_VAR 0 11
23781: PPUSH
23782: LD_STRING D6c-Sol3-2
23784: PPUSH
23785: CALL_OW 88
// dwait ( 0 0$1 ) ;
23789: LD_INT 35
23791: PPUSH
23792: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23796: LD_EXP 36
23800: PPUSH
23801: LD_STRING D6c-JMM-2
23803: PPUSH
23804: CALL_OW 88
// DialogueOff ;
23808: CALL_OW 7
// Video ( false ) ;
23812: LD_INT 0
23814: PPUSH
23815: CALL 105303 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23819: LD_INT 22
23821: PUSH
23822: LD_INT 4
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PPUSH
23829: CALL_OW 69
23833: PPUSH
23834: LD_INT 1
23836: PPUSH
23837: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23841: LD_INT 4
23843: PPUSH
23844: LD_INT 4
23846: PPUSH
23847: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23851: LD_ADDR_VAR 0 1
23855: PUSH
23856: LD_INT 4
23858: PPUSH
23859: LD_INT 1
23861: PPUSH
23862: LD_INT 2
23864: PPUSH
23865: CALL 63038 0 3
23869: PUSH
23870: FOR_IN
23871: IFFALSE 23908
// if GetTech ( i , 1 ) <> state_researched then
23873: LD_VAR 0 1
23877: PPUSH
23878: LD_INT 1
23880: PPUSH
23881: CALL_OW 321
23885: PUSH
23886: LD_INT 2
23888: NONEQUAL
23889: IFFALSE 23906
// SetTech ( i , 1 , state_researched ) ;
23891: LD_VAR 0 1
23895: PPUSH
23896: LD_INT 1
23898: PPUSH
23899: LD_INT 2
23901: PPUSH
23902: CALL_OW 322
23906: GO 23870
23908: POP
23909: POP
// missionStage := 6 ;
23910: LD_ADDR_EXP 15
23914: PUSH
23915: LD_INT 6
23917: ST_TO_ADDR
// activeAttacks := true ;
23918: LD_ADDR_EXP 16
23922: PUSH
23923: LD_INT 1
23925: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23926: LD_STRING M2
23928: PPUSH
23929: CALL_OW 337
// SaveForQuickRestart ;
23933: CALL_OW 22
// wait ( 0 0$40 ) ;
23937: LD_INT 1400
23939: PPUSH
23940: CALL_OW 67
// DialogueOn ;
23944: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23948: LD_EXP 59
23952: PPUSH
23953: LD_STRING D7-Friend-1
23955: PPUSH
23956: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23960: LD_EXP 36
23964: PPUSH
23965: LD_STRING D7-JMM-1
23967: PPUSH
23968: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23972: LD_EXP 59
23976: PPUSH
23977: LD_STRING D7-Friend-2
23979: PPUSH
23980: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23984: LD_EXP 36
23988: PPUSH
23989: LD_STRING D7-JMM-2
23991: PPUSH
23992: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23996: LD_EXP 59
24000: PPUSH
24001: LD_STRING D7-Friend-3
24003: PPUSH
24004: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24008: LD_EXP 36
24012: PPUSH
24013: LD_STRING D7-JMM-3
24015: PPUSH
24016: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24020: LD_EXP 59
24024: PPUSH
24025: LD_STRING D7-Friend-4
24027: PPUSH
24028: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24032: LD_EXP 36
24036: PPUSH
24037: LD_STRING D7-JMM-4
24039: PPUSH
24040: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24044: LD_EXP 59
24048: PPUSH
24049: LD_STRING D7-Friend-5
24051: PPUSH
24052: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24056: LD_EXP 36
24060: PPUSH
24061: LD_STRING D7-JMM-5
24063: PPUSH
24064: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24068: LD_EXP 59
24072: PPUSH
24073: LD_STRING D7-Friend-6
24075: PPUSH
24076: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24080: LD_EXP 36
24084: PPUSH
24085: LD_STRING D7-JMM-6
24087: PPUSH
24088: CALL_OW 88
// DialogueOff ;
24092: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24096: LD_STRING Mlegion
24098: PPUSH
24099: CALL_OW 337
// RebuildKozlovFactory ;
24103: CALL 4735 0 0
// end ;
24107: PPOPN 13
24109: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24110: LD_EXP 20
24114: PUSH
24115: LD_EXP 55
24119: PPUSH
24120: CALL_OW 300
24124: AND
24125: IFFALSE 24167
24127: GO 24129
24129: DISABLE
// begin enable ;
24130: ENABLE
// if IsInUnit ( Powell ) then
24131: LD_EXP 55
24135: PPUSH
24136: CALL_OW 310
24140: IFFALSE 24158
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24142: LD_EXP 55
24146: PPUSH
24147: CALL_OW 310
24151: PPUSH
24152: CALL_OW 85
24156: GO 24167
// CenterOnUnits ( Powell ) ;
24158: LD_EXP 55
24162: PPUSH
24163: CALL_OW 85
// end ;
24167: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24168: LD_INT 22
24170: PUSH
24171: LD_INT 8
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: PUSH
24178: LD_INT 34
24180: PUSH
24181: LD_INT 48
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PPUSH
24192: CALL_OW 69
24196: IFFALSE 24459
24198: GO 24200
24200: DISABLE
24201: LD_INT 0
24203: PPUSH
24204: PPUSH
// begin if missionStage < 9 then
24205: LD_EXP 15
24209: PUSH
24210: LD_INT 9
24212: LESS
24213: IFFALSE 24223
// missionStage := 9 ;
24215: LD_ADDR_EXP 15
24219: PUSH
24220: LD_INT 9
24222: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24223: LD_ADDR_VAR 0 1
24227: PUSH
24228: LD_INT 22
24230: PUSH
24231: LD_INT 8
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: PUSH
24238: LD_INT 34
24240: PUSH
24241: LD_INT 48
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PUSH
24257: LD_INT 1
24259: ARRAY
24260: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24261: LD_INT 175
24263: PPUSH
24264: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24268: LD_EXP 12
24272: PUSH
24273: LD_EXP 3
24277: PUSH
24278: LD_INT 0
24280: PUSH
24281: LD_INT 2
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: IN
24288: OR
24289: IFFALSE 24312
// target := [ 68 , 108 , 1 ] else
24291: LD_ADDR_VAR 0 2
24295: PUSH
24296: LD_INT 68
24298: PUSH
24299: LD_INT 108
24301: PUSH
24302: LD_INT 1
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: LIST
24309: ST_TO_ADDR
24310: GO 24331
// target := [ 181 , 88 , 2 ] ;
24312: LD_ADDR_VAR 0 2
24316: PUSH
24317: LD_INT 181
24319: PUSH
24320: LD_INT 88
24322: PUSH
24323: LD_INT 2
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: LIST
24330: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24331: LD_VAR 0 1
24335: PPUSH
24336: LD_VAR 0 2
24340: PUSH
24341: LD_INT 1
24343: ARRAY
24344: PPUSH
24345: LD_VAR 0 2
24349: PUSH
24350: LD_INT 2
24352: ARRAY
24353: PPUSH
24354: CALL_OW 176
// if target [ 3 ] = 1 then
24358: LD_VAR 0 2
24362: PUSH
24363: LD_INT 3
24365: ARRAY
24366: PUSH
24367: LD_INT 1
24369: EQUAL
24370: IFFALSE 24386
// SayRadio ( Kurt , D12-Kurt-1 ) else
24372: LD_EXP 57
24376: PPUSH
24377: LD_STRING D12-Kurt-1
24379: PPUSH
24380: CALL_OW 94
24384: GO 24410
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24386: LD_EXP 57
24390: PPUSH
24391: LD_STRING D12a-Kurt-1
24393: PPUSH
24394: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24398: LD_EXP 71
24402: PPUSH
24403: LD_STRING D12a-Roth-1
24405: PPUSH
24406: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24410: LD_INT 350
24412: PPUSH
24413: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24417: LD_VAR 0 1
24421: PPUSH
24422: LD_INT 22
24424: PUSH
24425: LD_INT 8
24427: PUSH
24428: EMPTY
24429: LIST
24430: LIST
24431: PUSH
24432: LD_INT 30
24434: PUSH
24435: LD_INT 3
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: PUSH
24442: EMPTY
24443: LIST
24444: LIST
24445: PPUSH
24446: CALL_OW 69
24450: PUSH
24451: LD_INT 1
24453: ARRAY
24454: PPUSH
24455: CALL_OW 228
// end ;
24459: PPOPN 2
24461: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24462: LD_INT 22
24464: PUSH
24465: LD_INT 8
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: PUSH
24472: LD_INT 21
24474: PUSH
24475: LD_INT 1
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 23
24484: PUSH
24485: LD_INT 2
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: LIST
24496: PPUSH
24497: CALL_OW 69
24501: PUSH
24502: LD_INT 8
24504: PUSH
24505: LD_INT 7
24507: PUSH
24508: LD_INT 6
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: LIST
24515: PUSH
24516: LD_OWVAR 67
24520: ARRAY
24521: LESSEQUAL
24522: PUSH
24523: LD_INT 22
24525: PUSH
24526: LD_INT 8
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: PUSH
24533: LD_INT 34
24535: PUSH
24536: LD_INT 48
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: PPUSH
24547: CALL_OW 69
24551: NOT
24552: AND
24553: PUSH
24554: LD_EXP 57
24558: PPUSH
24559: CALL_OW 302
24563: AND
24564: IFFALSE 24881
24566: GO 24568
24568: DISABLE
// begin DialogueOn ;
24569: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24573: LD_EXP 36
24577: PPUSH
24578: LD_STRING D13-JMM-1
24580: PPUSH
24581: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24585: LD_EXP 57
24589: PPUSH
24590: LD_STRING D13-Kurt-1
24592: PPUSH
24593: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24597: LD_EXP 36
24601: PPUSH
24602: LD_STRING D13-JMM-2
24604: PPUSH
24605: CALL_OW 88
// if FakeInfo then
24609: LD_EXP 12
24613: IFFALSE 24633
// begin Say ( Kurt , D13-Kurt-2 ) ;
24615: LD_EXP 57
24619: PPUSH
24620: LD_STRING D13-Kurt-2
24622: PPUSH
24623: CALL_OW 88
// DialogueOff ;
24627: CALL_OW 7
// exit ;
24631: GO 24881
// end ; if not KurtStatus then
24633: LD_EXP 3
24637: NOT
24638: IFFALSE 24654
// Say ( Kurt , D13-Kurt-2b ) else
24640: LD_EXP 57
24644: PPUSH
24645: LD_STRING D13-Kurt-2b
24647: PPUSH
24648: CALL_OW 88
24652: GO 24666
// Say ( Kurt , D13-Kurt-2a ) ;
24654: LD_EXP 57
24658: PPUSH
24659: LD_STRING D13-Kurt-2a
24661: PPUSH
24662: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24666: LD_EXP 57
24670: PPUSH
24671: LD_STRING D13-Kurt-2a
24673: PPUSH
24674: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24678: LD_EXP 36
24682: PPUSH
24683: LD_STRING D13-JMM-3
24685: PPUSH
24686: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24690: LD_EXP 57
24694: PPUSH
24695: LD_STRING D13-Kurt-3
24697: PPUSH
24698: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24702: LD_EXP 36
24706: PPUSH
24707: LD_STRING D13-JMM-4
24709: PPUSH
24710: CALL_OW 88
// DialogueOff ;
24714: CALL_OW 7
// MC_Kill ( 3 ) ;
24718: LD_INT 3
24720: PPUSH
24721: CALL 33987 0 1
// KillUnit ( Kozlov ) ;
24725: LD_EXP 58
24729: PPUSH
24730: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24734: LD_INT 22
24736: PUSH
24737: LD_INT 8
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 21
24746: PUSH
24747: LD_INT 3
24749: PUSH
24750: EMPTY
24751: LIST
24752: LIST
24753: PUSH
24754: LD_INT 23
24756: PUSH
24757: LD_INT 3
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: LD_INT 30
24766: PUSH
24767: LD_INT 3
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: PPUSH
24780: CALL_OW 69
24784: PUSH
24785: LD_INT 1
24787: ARRAY
24788: PPUSH
24789: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24793: LD_INT 8
24795: PPUSH
24796: LD_INT 1
24798: PPUSH
24799: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24803: LD_INT 22
24805: PUSH
24806: LD_INT 8
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PPUSH
24813: CALL_OW 69
24817: PPUSH
24818: LD_INT 1
24820: PPUSH
24821: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24825: LD_INT 8
24827: PPUSH
24828: LD_INT 1
24830: PPUSH
24831: LD_INT 1
24833: PPUSH
24834: LD_INT 1
24836: PPUSH
24837: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24841: LD_EXP 59
24845: PPUSH
24846: LD_INT 37
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: LD_INT 0
24854: PPUSH
24855: CALL_OW 48
// wait ( 0 0$1 ) ;
24859: LD_INT 35
24861: PPUSH
24862: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24866: LD_EXP 59
24870: PPUSH
24871: LD_INT 60
24873: PPUSH
24874: LD_INT 95
24876: PPUSH
24877: CALL_OW 111
// end ;
24881: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24882: LD_INT 22
24884: PUSH
24885: LD_INT 8
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: PUSH
24892: LD_INT 21
24894: PUSH
24895: LD_INT 1
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PPUSH
24906: CALL_OW 69
24910: PUSH
24911: LD_INT 0
24913: EQUAL
24914: IFFALSE 24934
24916: GO 24918
24918: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24919: LD_STRING MlegionOut
24921: PPUSH
24922: CALL_OW 337
// legionDestroyed := true ;
24926: LD_ADDR_EXP 22
24930: PUSH
24931: LD_INT 1
24933: ST_TO_ADDR
// end ;
24934: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24935: LD_INT 1
24937: PPUSH
24938: LD_EXP 59
24942: PPUSH
24943: CALL_OW 292
24947: IFFALSE 25247
24949: GO 24951
24951: DISABLE
24952: LD_INT 0
24954: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24955: LD_EXP 59
24959: PPUSH
24960: CALL_OW 87
// DialogueOn ;
24964: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24968: LD_EXP 36
24972: PPUSH
24973: LD_STRING D14-JMM-1
24975: PPUSH
24976: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24980: LD_EXP 59
24984: PPUSH
24985: LD_STRING D14-Friend-1
24987: PPUSH
24988: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24992: LD_EXP 36
24996: PPUSH
24997: LD_STRING D14-JMM-2
24999: PPUSH
25000: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25004: LD_EXP 59
25008: PPUSH
25009: LD_STRING D14-Friend-2
25011: PPUSH
25012: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25016: LD_EXP 36
25020: PPUSH
25021: LD_STRING D14-JMM-3
25023: PPUSH
25024: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25028: LD_EXP 59
25032: PPUSH
25033: LD_STRING D14-Friend-3
25035: PPUSH
25036: CALL_OW 88
// DialogueOff ;
25040: CALL_OW 7
// dec = Query ( Q14 ) ;
25044: LD_ADDR_VAR 0 1
25048: PUSH
25049: LD_STRING Q14
25051: PPUSH
25052: CALL_OW 97
25056: ST_TO_ADDR
// if dec = 1 then
25057: LD_VAR 0 1
25061: PUSH
25062: LD_INT 1
25064: EQUAL
25065: IFFALSE 25099
// begin DialogueOn ;
25067: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25071: LD_EXP 36
25075: PPUSH
25076: LD_STRING D14a-JMM-1
25078: PPUSH
25079: CALL_OW 88
// DialogueOff ;
25083: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25087: LD_EXP 59
25091: PPUSH
25092: LD_INT 1
25094: PPUSH
25095: CALL_OW 235
// end ; if dec = 2 then
25099: LD_VAR 0 1
25103: PUSH
25104: LD_INT 2
25106: EQUAL
25107: IFFALSE 25153
// begin DialogueOn ;
25109: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25113: LD_EXP 36
25117: PPUSH
25118: LD_STRING D14b-JMM-1
25120: PPUSH
25121: CALL_OW 88
// DialogueOff ;
25125: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25129: LD_EXP 59
25133: PPUSH
25134: LD_INT 9
25136: PPUSH
25137: LD_INT 2
25139: PPUSH
25140: CALL_OW 111
// AddComHold ( Friend ) ;
25144: LD_EXP 59
25148: PPUSH
25149: CALL_OW 200
// end ; if dec = 3 then
25153: LD_VAR 0 1
25157: PUSH
25158: LD_INT 3
25160: EQUAL
25161: IFFALSE 25247
// begin DialogueOn ;
25163: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25167: LD_EXP 36
25171: PPUSH
25172: LD_STRING D14c-JMM-1
25174: PPUSH
25175: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25179: LD_EXP 59
25183: PPUSH
25184: LD_STRING D14c-Friend-1
25186: PPUSH
25187: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25191: LD_EXP 36
25195: PPUSH
25196: LD_STRING D14c-JMM-2
25198: PPUSH
25199: CALL_OW 88
// DialogueOff ;
25203: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25207: LD_INT 8
25209: PPUSH
25210: LD_INT 1
25212: PPUSH
25213: LD_INT 2
25215: PPUSH
25216: LD_INT 1
25218: PPUSH
25219: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25223: LD_EXP 59
25227: PPUSH
25228: LD_INT 9
25230: PPUSH
25231: LD_INT 2
25233: PPUSH
25234: CALL_OW 111
// AddComHold ( Friend ) ;
25238: LD_EXP 59
25242: PPUSH
25243: CALL_OW 200
// end ; end ;
25247: PPOPN 1
25249: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25250: LD_INT 9
25252: PPUSH
25253: LD_INT 2
25255: PPUSH
25256: CALL_OW 428
25260: PUSH
25261: LD_EXP 59
25265: EQUAL
25266: PUSH
25267: LD_EXP 59
25271: PPUSH
25272: CALL_OW 255
25276: PUSH
25277: LD_INT 8
25279: EQUAL
25280: AND
25281: IFFALSE 25295
25283: GO 25285
25285: DISABLE
// RemoveUnit ( Friend ) ;
25286: LD_EXP 59
25290: PPUSH
25291: CALL_OW 64
25295: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25296: LD_EXP 14
25300: PUSH
25301: LD_INT 31500
25303: GREATEREQUAL
25304: PUSH
25305: LD_EXP 7
25309: AND
25310: PUSH
25311: LD_EXP 2
25315: AND
25316: IFFALSE 25746
25318: GO 25320
25320: DISABLE
25321: LD_INT 0
25323: PPUSH
25324: PPUSH
25325: PPUSH
// begin missionStage := 7 ;
25326: LD_ADDR_EXP 15
25330: PUSH
25331: LD_INT 7
25333: ST_TO_ADDR
// uc_side = 1 ;
25334: LD_ADDR_OWVAR 20
25338: PUSH
25339: LD_INT 1
25341: ST_TO_ADDR
// uc_nation = 1 ;
25342: LD_ADDR_OWVAR 21
25346: PUSH
25347: LD_INT 1
25349: ST_TO_ADDR
// for i = 1 to 5 do
25350: LD_ADDR_VAR 0 1
25354: PUSH
25355: DOUBLE
25356: LD_INT 1
25358: DEC
25359: ST_TO_ADDR
25360: LD_INT 5
25362: PUSH
25363: FOR_TO
25364: IFFALSE 25460
// begin vc_engine = 3 ;
25366: LD_ADDR_OWVAR 39
25370: PUSH
25371: LD_INT 3
25373: ST_TO_ADDR
// vc_control = 3 ;
25374: LD_ADDR_OWVAR 38
25378: PUSH
25379: LD_INT 3
25381: ST_TO_ADDR
// vc_chassis = 3 ;
25382: LD_ADDR_OWVAR 37
25386: PUSH
25387: LD_INT 3
25389: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25390: LD_ADDR_OWVAR 40
25394: PUSH
25395: LD_INT 5
25397: PUSH
25398: LD_INT 9
25400: PUSH
25401: LD_INT 7
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 1
25411: PPUSH
25412: LD_INT 3
25414: PPUSH
25415: CALL_OW 12
25419: ARRAY
25420: ST_TO_ADDR
// veh = CreateVehicle ;
25421: LD_ADDR_VAR 0 2
25425: PUSH
25426: CALL_OW 45
25430: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25431: LD_VAR 0 2
25435: PPUSH
25436: LD_INT 1
25438: PPUSH
25439: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25443: LD_VAR 0 2
25447: PPUSH
25448: LD_INT 19
25450: PPUSH
25451: LD_INT 0
25453: PPUSH
25454: CALL_OW 49
// end ;
25458: GO 25363
25460: POP
25461: POP
// vc_engine = 3 ;
25462: LD_ADDR_OWVAR 39
25466: PUSH
25467: LD_INT 3
25469: ST_TO_ADDR
// vc_control = 1 ;
25470: LD_ADDR_OWVAR 38
25474: PUSH
25475: LD_INT 1
25477: ST_TO_ADDR
// vc_chassis = 3 ;
25478: LD_ADDR_OWVAR 37
25482: PUSH
25483: LD_INT 3
25485: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25486: LD_ADDR_OWVAR 40
25490: PUSH
25491: LD_INT 5
25493: PUSH
25494: LD_INT 9
25496: PUSH
25497: LD_INT 7
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 1
25507: PPUSH
25508: LD_INT 3
25510: PPUSH
25511: CALL_OW 12
25515: ARRAY
25516: ST_TO_ADDR
// vehG = CreateVehicle ;
25517: LD_ADDR_VAR 0 3
25521: PUSH
25522: CALL_OW 45
25526: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25527: LD_VAR 0 3
25531: PPUSH
25532: LD_INT 1
25534: PPUSH
25535: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25539: LD_VAR 0 3
25543: PPUSH
25544: LD_INT 19
25546: PPUSH
25547: LD_INT 0
25549: PPUSH
25550: CALL_OW 49
// if JMMGirl = 1 then
25554: LD_EXP 7
25558: PUSH
25559: LD_INT 1
25561: EQUAL
25562: IFFALSE 25618
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25564: LD_ADDR_EXP 37
25568: PUSH
25569: LD_STRING Joan
25571: PPUSH
25572: LD_INT 1
25574: PPUSH
25575: LD_STRING 14_
25577: PPUSH
25578: CALL 62975 0 3
25582: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25583: LD_EXP 37
25587: PPUSH
25588: LD_VAR 0 3
25592: PPUSH
25593: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25597: LD_VAR 0 3
25601: PPUSH
25602: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25606: LD_EXP 37
25610: PPUSH
25611: LD_STRING D10BW-Joan-1
25613: PPUSH
25614: CALL_OW 94
// end ; if JMMGirl = 2 then
25618: LD_EXP 7
25622: PUSH
25623: LD_INT 2
25625: EQUAL
25626: IFFALSE 25682
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25628: LD_ADDR_EXP 39
25632: PUSH
25633: LD_STRING Lisa
25635: PPUSH
25636: LD_INT 1
25638: PPUSH
25639: LD_STRING 14_
25641: PPUSH
25642: CALL 62975 0 3
25646: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25647: LD_EXP 39
25651: PPUSH
25652: LD_VAR 0 3
25656: PPUSH
25657: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25661: LD_VAR 0 3
25665: PPUSH
25666: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25670: LD_EXP 39
25674: PPUSH
25675: LD_STRING D10BW-Lisa-1
25677: PPUSH
25678: CALL_OW 94
// end ; if JMMGirl = 3 then
25682: LD_EXP 7
25686: PUSH
25687: LD_INT 3
25689: EQUAL
25690: IFFALSE 25746
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25692: LD_ADDR_EXP 51
25696: PUSH
25697: LD_STRING Connie
25699: PPUSH
25700: LD_INT 1
25702: PPUSH
25703: LD_STRING 14_
25705: PPUSH
25706: CALL 62975 0 3
25710: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25711: LD_EXP 51
25715: PPUSH
25716: LD_VAR 0 3
25720: PPUSH
25721: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25725: LD_VAR 0 3
25729: PPUSH
25730: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25734: LD_EXP 39
25738: PPUSH
25739: LD_STRING D10BW-Con-1
25741: PPUSH
25742: CALL_OW 94
// end ; end ;
25746: PPOPN 3
25748: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25749: LD_EXP 14
25753: PUSH
25754: LD_INT 94500
25756: GREATEREQUAL
25757: IFFALSE 26169
25759: GO 25761
25761: DISABLE
25762: LD_INT 0
25764: PPUSH
25765: PPUSH
25766: PPUSH
// begin tmp := PrepareStevensSquad ;
25767: LD_ADDR_VAR 0 3
25771: PUSH
25772: CALL 2109 0 0
25776: ST_TO_ADDR
// if not tmp then
25777: LD_VAR 0 3
25781: NOT
25782: IFFALSE 25786
// exit ;
25784: GO 26169
// uc_side := 1 ;
25786: LD_ADDR_OWVAR 20
25790: PUSH
25791: LD_INT 1
25793: ST_TO_ADDR
// uc_nation := 1 ;
25794: LD_ADDR_OWVAR 21
25798: PUSH
25799: LD_INT 1
25801: ST_TO_ADDR
// for i in tmp do
25802: LD_ADDR_VAR 0 1
25806: PUSH
25807: LD_VAR 0 3
25811: PUSH
25812: FOR_IN
25813: IFFALSE 25910
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25815: LD_INT 3
25817: PPUSH
25818: LD_INT 3
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: LD_INT 5
25826: PUSH
25827: LD_INT 9
25829: PUSH
25830: LD_INT 7
25832: PUSH
25833: EMPTY
25834: LIST
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 1
25840: PPUSH
25841: LD_INT 3
25843: PPUSH
25844: CALL_OW 12
25848: ARRAY
25849: PPUSH
25850: LD_INT 40
25852: PPUSH
25853: CALL 69586 0 5
// veh := CreateVehicle ;
25857: LD_ADDR_VAR 0 2
25861: PUSH
25862: CALL_OW 45
25866: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25867: LD_VAR 0 2
25871: PPUSH
25872: LD_INT 1
25874: PPUSH
25875: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25879: LD_VAR 0 2
25883: PPUSH
25884: LD_INT 19
25886: PPUSH
25887: LD_INT 0
25889: PPUSH
25890: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25894: LD_VAR 0 1
25898: PPUSH
25899: LD_VAR 0 2
25903: PPUSH
25904: CALL_OW 52
// end ;
25908: GO 25812
25910: POP
25911: POP
// missionStage := 8 ;
25912: LD_ADDR_EXP 15
25916: PUSH
25917: LD_INT 8
25919: ST_TO_ADDR
// DialogueOn ;
25920: CALL_OW 6
// if Stevens then
25924: LD_EXP 38
25928: IFFALSE 26042
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25930: LD_EXP 38
25934: PPUSH
25935: CALL_OW 310
25939: PPUSH
25940: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25944: LD_EXP 38
25948: PPUSH
25949: LD_STRING D8-Huck-1
25951: PPUSH
25952: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25956: LD_EXP 36
25960: PPUSH
25961: LD_STRING D8-JMM-1
25963: PPUSH
25964: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25968: LD_EXP 38
25972: PPUSH
25973: LD_STRING D8-Huck-2
25975: PPUSH
25976: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25980: LD_EXP 36
25984: PPUSH
25985: LD_STRING D8-JMM-2
25987: PPUSH
25988: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25992: LD_EXP 38
25996: PPUSH
25997: LD_STRING D8-Huck-3
25999: PPUSH
26000: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26004: LD_EXP 36
26008: PPUSH
26009: LD_STRING D8-JMM-3
26011: PPUSH
26012: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26016: LD_EXP 38
26020: PPUSH
26021: LD_STRING D8-Huck-4
26023: PPUSH
26024: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26028: LD_EXP 36
26032: PPUSH
26033: LD_STRING D8-JMM-4
26035: PPUSH
26036: CALL_OW 88
// end else
26040: GO 26152
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26042: LD_EXP 52
26046: PPUSH
26047: CALL_OW 310
26051: PPUSH
26052: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26056: LD_EXP 52
26060: PPUSH
26061: LD_STRING D8-Huck-1
26063: PPUSH
26064: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26068: LD_EXP 36
26072: PPUSH
26073: LD_STRING D8-JMM-1a
26075: PPUSH
26076: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26080: LD_EXP 52
26084: PPUSH
26085: LD_STRING D8-Huck-2
26087: PPUSH
26088: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26092: LD_EXP 36
26096: PPUSH
26097: LD_STRING D8-JMM-2
26099: PPUSH
26100: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26104: LD_EXP 52
26108: PPUSH
26109: LD_STRING D8-Huck-3
26111: PPUSH
26112: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26116: LD_EXP 36
26120: PPUSH
26121: LD_STRING D8-JMM-3
26123: PPUSH
26124: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26128: LD_EXP 52
26132: PPUSH
26133: LD_STRING D8-Huck-4
26135: PPUSH
26136: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26140: LD_EXP 36
26144: PPUSH
26145: LD_STRING D8-JMM-4
26147: PPUSH
26148: CALL_OW 88
// end ; DialogueOff ;
26152: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26156: LD_INT 25
26158: PPUSH
26159: LD_INT 1
26161: PPUSH
26162: LD_INT 1
26164: PPUSH
26165: CALL_OW 322
// end ;
26169: PPOPN 3
26171: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26172: LD_INT 1
26174: PPUSH
26175: LD_EXP 68
26179: PPUSH
26180: CALL_OW 292
26184: IFFALSE 26435
26186: GO 26188
26188: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26189: LD_EXP 68
26193: PPUSH
26194: CALL_OW 87
// DialogueOn ;
26198: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26202: LD_EXP 36
26206: PPUSH
26207: LD_STRING D10nB-JMM-1
26209: PPUSH
26210: CALL_OW 88
// if BurlakStatus = 1 then
26214: LD_EXP 9
26218: PUSH
26219: LD_INT 1
26221: EQUAL
26222: IFFALSE 26236
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26224: LD_EXP 67
26228: PPUSH
26229: LD_STRING D10nB-Vse-1a
26231: PPUSH
26232: CALL_OW 94
// end ; if BurlakStatus = 0 then
26236: LD_EXP 9
26240: PUSH
26241: LD_INT 0
26243: EQUAL
26244: IFFALSE 26258
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26246: LD_EXP 67
26250: PPUSH
26251: LD_STRING D10nB-Vse-1
26253: PPUSH
26254: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26258: LD_EXP 36
26262: PPUSH
26263: LD_STRING D10nB-JMM-2
26265: PPUSH
26266: CALL_OW 88
// if KappaStatus then
26270: LD_EXP 2
26274: IFFALSE 26288
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26276: LD_EXP 67
26280: PPUSH
26281: LD_STRING D10nB-Vse-5a
26283: PPUSH
26284: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26288: LD_EXP 2
26292: NOT
26293: PUSH
26294: LD_EXP 6
26298: PUSH
26299: LD_INT 0
26301: EQUAL
26302: AND
26303: IFFALSE 26431
// begin if JMMGirl = 1 then
26305: LD_EXP 7
26309: PUSH
26310: LD_INT 1
26312: EQUAL
26313: IFFALSE 26363
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26315: LD_EXP 67
26319: PPUSH
26320: LD_STRING D10nB-Vse-2
26322: PPUSH
26323: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26327: LD_EXP 36
26331: PPUSH
26332: LD_STRING D10nB-JMM-3
26334: PPUSH
26335: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26339: LD_EXP 67
26343: PPUSH
26344: LD_STRING D10nB-Vse-3
26346: PPUSH
26347: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26351: LD_EXP 36
26355: PPUSH
26356: LD_STRING D10nB-JMM-4
26358: PPUSH
26359: CALL_OW 88
// end ; if JMMGirl = 2 then
26363: LD_EXP 7
26367: PUSH
26368: LD_INT 2
26370: EQUAL
26371: IFFALSE 26397
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26373: LD_EXP 67
26377: PPUSH
26378: LD_STRING D10nB-Vse-4
26380: PPUSH
26381: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26385: LD_EXP 36
26389: PPUSH
26390: LD_STRING D10nB-JMM-5
26392: PPUSH
26393: CALL_OW 88
// end ; if JMMGirl = 3 then
26397: LD_EXP 7
26401: PUSH
26402: LD_INT 3
26404: EQUAL
26405: IFFALSE 26431
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26407: LD_EXP 67
26411: PPUSH
26412: LD_STRING D10nB-Vse-5
26414: PPUSH
26415: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26419: LD_EXP 36
26423: PPUSH
26424: LD_STRING D10nB-JMM-6
26426: PPUSH
26427: CALL_OW 88
// end ; end ; DialogueOff ;
26431: CALL_OW 7
// end ;
26435: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26436: LD_EXP 14
26440: PUSH
26441: LD_INT 115500
26443: GREATEREQUAL
26444: IFFALSE 26803
26446: GO 26448
26448: DISABLE
26449: LD_INT 0
26451: PPUSH
// begin missionStage := 10 ;
26452: LD_ADDR_EXP 15
26456: PUSH
26457: LD_INT 10
26459: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26460: LD_ADDR_VAR 0 1
26464: PUSH
26465: LD_INT 22
26467: PUSH
26468: LD_INT 1
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 26
26477: PUSH
26478: LD_INT 1
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 3
26487: PUSH
26488: LD_INT 25
26490: PUSH
26491: LD_INT 12
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 3
26504: PUSH
26505: LD_INT 25
26507: PUSH
26508: LD_INT 16
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: LIST
26523: LIST
26524: PPUSH
26525: CALL_OW 69
26529: PUSH
26530: LD_EXP 36
26534: PUSH
26535: LD_EXP 38
26539: PUSH
26540: LD_EXP 52
26544: PUSH
26545: LD_EXP 39
26549: PUSH
26550: LD_EXP 40
26554: PUSH
26555: LD_EXP 41
26559: PUSH
26560: LD_EXP 42
26564: PUSH
26565: LD_EXP 43
26569: PUSH
26570: LD_EXP 44
26574: PUSH
26575: LD_EXP 45
26579: PUSH
26580: LD_EXP 46
26584: PUSH
26585: LD_EXP 47
26589: PUSH
26590: LD_EXP 48
26594: PUSH
26595: LD_EXP 49
26599: PUSH
26600: LD_EXP 50
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: LIST
26618: LIST
26619: LIST
26620: LIST
26621: DIFF
26622: ST_TO_ADDR
// if not tmp and Brown then
26623: LD_VAR 0 1
26627: NOT
26628: PUSH
26629: LD_EXP 44
26633: AND
26634: IFFALSE 26649
// tmp := [ Brown ] ;
26636: LD_ADDR_VAR 0 1
26640: PUSH
26641: LD_EXP 44
26645: PUSH
26646: EMPTY
26647: LIST
26648: ST_TO_ADDR
// DialogueOn ;
26649: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26653: LD_VAR 0 1
26657: PUSH
26658: LD_INT 1
26660: ARRAY
26661: PPUSH
26662: LD_STRING D11-Sol1-1
26664: PPUSH
26665: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26669: LD_EXP 61
26673: PPUSH
26674: LD_STRING D11-Pla-1
26676: PPUSH
26677: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26681: LD_EXP 62
26685: PPUSH
26686: LD_STRING D11-Kov-1
26688: PPUSH
26689: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26693: LD_EXP 61
26697: PPUSH
26698: LD_STRING D11-Pla-2
26700: PPUSH
26701: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26705: LD_VAR 0 1
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: LD_STRING D11-Sol1-2
26716: PPUSH
26717: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26721: LD_EXP 36
26725: PPUSH
26726: LD_STRING D11-JMM-2
26728: PPUSH
26729: CALL_OW 88
// DialogueOff ;
26733: CALL_OW 7
// allowBehemothConstruct := true ;
26737: LD_ADDR_EXP 25
26741: PUSH
26742: LD_INT 1
26744: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26745: LD_STRING M4
26747: PPUSH
26748: CALL_OW 337
// BuildBehemoths ;
26752: CALL 7539 0 0
// repeat wait ( 15 15$00 ) ;
26756: LD_INT 31500
26758: PPUSH
26759: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26763: LD_EXP 27
26767: IFFALSE 26771
// break ;
26769: GO 26803
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26771: LD_INT 267
26773: PPUSH
26774: CALL_OW 274
26778: PPUSH
26779: LD_INT 1
26781: PPUSH
26782: CALL_OW 275
26786: PUSH
26787: LD_INT 1000
26789: GREATEREQUAL
26790: IFFALSE 26796
// BuildBehemoths ;
26792: CALL 7539 0 0
// until not behemothBuilders ;
26796: LD_EXP 70
26800: NOT
26801: IFFALSE 26756
// end ;
26803: PPOPN 1
26805: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26806: LD_EXP 70
26810: NOT
26811: PUSH
26812: LD_EXP 28
26816: NOT
26817: AND
26818: PUSH
26819: LD_EXP 25
26823: AND
26824: IFFALSE 26844
26826: GO 26828
26828: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26829: LD_STRING M4a
26831: PPUSH
26832: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26836: LD_ADDR_EXP 27
26840: PUSH
26841: LD_INT 1
26843: ST_TO_ADDR
// end ;
26844: END
// every 0 0$1 trigger behemothDone do
26845: LD_EXP 28
26849: IFFALSE 26861
26851: GO 26853
26853: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26854: LD_STRING M4b
26856: PPUSH
26857: CALL_OW 337
26861: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26862: LD_EXP 29
26866: NOT
26867: IFFALSE 27063
26869: GO 26871
26871: DISABLE
26872: LD_INT 0
26874: PPUSH
26875: PPUSH
// begin enable ;
26876: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26877: LD_ADDR_VAR 0 1
26881: PUSH
26882: LD_INT 3
26884: PPUSH
26885: CALL 105379 0 1
26889: ST_TO_ADDR
// if not tmp and not behemothDone then
26890: LD_VAR 0 1
26894: NOT
26895: PUSH
26896: LD_EXP 28
26900: NOT
26901: AND
26902: IFFALSE 26938
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26904: LD_ADDR_VAR 0 1
26908: PUSH
26909: LD_INT 22
26911: PUSH
26912: LD_INT 3
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: LD_INT 30
26921: PUSH
26922: LD_INT 37
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PPUSH
26933: CALL_OW 69
26937: ST_TO_ADDR
// if not tmp then
26938: LD_VAR 0 1
26942: NOT
26943: IFFALSE 26947
// exit ;
26945: GO 27063
// for i in tmp do
26947: LD_ADDR_VAR 0 2
26951: PUSH
26952: LD_VAR 0 1
26956: PUSH
26957: FOR_IN
26958: IFFALSE 27061
// if See ( 1 , i ) then
26960: LD_INT 1
26962: PPUSH
26963: LD_VAR 0 2
26967: PPUSH
26968: CALL_OW 292
26972: IFFALSE 27059
// begin if GetType ( i ) = unit_building then
26974: LD_VAR 0 2
26978: PPUSH
26979: CALL_OW 247
26983: PUSH
26984: LD_INT 3
26986: EQUAL
26987: IFFALSE 27025
// begin CenterNowOnUnits ( i ) ;
26989: LD_VAR 0 2
26993: PPUSH
26994: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26998: LD_EXP 36
27002: PPUSH
27003: LD_STRING D17a-JMM-1
27005: PPUSH
27006: CALL_OW 88
// seeBehemoth := true ;
27010: LD_ADDR_EXP 29
27014: PUSH
27015: LD_INT 1
27017: ST_TO_ADDR
// disable ;
27018: DISABLE
// exit ;
27019: POP
27020: POP
27021: GO 27063
// end else
27023: GO 27059
// begin CenterNowOnUnits ( i ) ;
27025: LD_VAR 0 2
27029: PPUSH
27030: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27034: LD_EXP 36
27038: PPUSH
27039: LD_STRING D17b-JMM-1
27041: PPUSH
27042: CALL_OW 88
// seeBehemoth := true ;
27046: LD_ADDR_EXP 29
27050: PUSH
27051: LD_INT 1
27053: ST_TO_ADDR
// disable ;
27054: DISABLE
// exit ;
27055: POP
27056: POP
27057: GO 27063
// end ; end ;
27059: GO 26957
27061: POP
27062: POP
// end ;
27063: PPOPN 2
27065: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27066: LD_EXP 14
27070: PUSH
27071: LD_INT 116550
27073: GREATEREQUAL
27074: IFFALSE 28250
27076: GO 27078
27078: DISABLE
27079: LD_INT 0
27081: PPUSH
27082: PPUSH
27083: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27084: LD_INT 2
27086: PPUSH
27087: LD_INT 23
27089: PUSH
27090: LD_INT 3
27092: PUSH
27093: LD_INT 3
27095: PUSH
27096: LD_INT 48
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: PUSH
27105: EMPTY
27106: LIST
27107: PPUSH
27108: CALL 56973 0 2
// repeat wait ( 0 0$1 ) ;
27112: LD_INT 35
27114: PPUSH
27115: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27119: LD_INT 22
27121: PUSH
27122: LD_INT 3
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 34
27131: PUSH
27132: LD_INT 48
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PPUSH
27143: CALL_OW 69
27147: IFFALSE 27112
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27149: LD_ADDR_VAR 0 1
27153: PUSH
27154: LD_INT 22
27156: PUSH
27157: LD_INT 3
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: LD_INT 34
27166: PUSH
27167: LD_INT 48
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: CALL_OW 69
27182: PUSH
27183: LD_INT 1
27185: ARRAY
27186: ST_TO_ADDR
// missionStage := 12 ;
27187: LD_ADDR_EXP 15
27191: PUSH
27192: LD_INT 12
27194: ST_TO_ADDR
// platonovHasBomb := true ;
27195: LD_ADDR_EXP 30
27199: PUSH
27200: LD_INT 1
27202: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27203: LD_VAR 0 1
27207: PPUSH
27208: LD_INT 181
27210: PPUSH
27211: LD_INT 86
27213: PPUSH
27214: CALL_OW 171
// AddComHold ( bomb ) ;
27218: LD_VAR 0 1
27222: PPUSH
27223: CALL_OW 200
// wait ( 0 0$10 ) ;
27227: LD_INT 350
27229: PPUSH
27230: CALL_OW 67
// DialogueOn ;
27234: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27238: LD_EXP 61
27242: PPUSH
27243: LD_STRING D15-Pla-1
27245: PPUSH
27246: CALL_OW 94
// dec = Query ( Q15a ) ;
27250: LD_ADDR_VAR 0 2
27254: PUSH
27255: LD_STRING Q15a
27257: PPUSH
27258: CALL_OW 97
27262: ST_TO_ADDR
// if dec = 1 then
27263: LD_VAR 0 2
27267: PUSH
27268: LD_INT 1
27270: EQUAL
27271: IFFALSE 27294
// begin Say ( JMM , D15a-JMM-1 ) ;
27273: LD_EXP 36
27277: PPUSH
27278: LD_STRING D15a-JMM-1
27280: PPUSH
27281: CALL_OW 88
// YouLost ( Surrender ) ;
27285: LD_STRING Surrender
27287: PPUSH
27288: CALL_OW 104
// exit ;
27292: GO 28250
// end ; if dec = 2 then
27294: LD_VAR 0 2
27298: PUSH
27299: LD_INT 2
27301: EQUAL
27302: IFFALSE 27371
// begin Say ( JMM , D15b-JMM-1 ) ;
27304: LD_EXP 36
27308: PPUSH
27309: LD_STRING D15b-JMM-1
27311: PPUSH
27312: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27316: LD_EXP 61
27320: PPUSH
27321: LD_STRING D15b-Pla-1
27323: PPUSH
27324: CALL_OW 94
// DialogueOff ;
27328: CALL_OW 7
// wait ( 3 3$00 ) ;
27332: LD_INT 6300
27334: PPUSH
27335: CALL_OW 67
// DialogueOn ;
27339: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27343: LD_EXP 36
27347: PPUSH
27348: LD_STRING D15d-JMM-1a
27350: PPUSH
27351: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27355: LD_EXP 61
27359: PPUSH
27360: LD_STRING D15d-Pla-1
27362: PPUSH
27363: CALL_OW 94
// DialogueOff ;
27367: CALL_OW 7
// end ; if dec = 3 then
27371: LD_VAR 0 2
27375: PUSH
27376: LD_INT 3
27378: EQUAL
27379: IFFALSE 27433
// begin Say ( JMM , D15c-JMM-1 ) ;
27381: LD_EXP 36
27385: PPUSH
27386: LD_STRING D15c-JMM-1
27388: PPUSH
27389: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27393: LD_EXP 61
27397: PPUSH
27398: LD_STRING D15c-Pla-1
27400: PPUSH
27401: CALL_OW 94
// DialogueOff ;
27405: CALL_OW 7
// wait ( 0 0$15 ) ;
27409: LD_INT 525
27411: PPUSH
27412: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27416: LD_VAR 0 1
27420: PPUSH
27421: LD_INT 60
27423: PPUSH
27424: LD_INT 95
27426: PPUSH
27427: CALL_OW 116
// exit ;
27431: GO 28250
// end ; if dec = 4 then
27433: LD_VAR 0 2
27437: PUSH
27438: LD_INT 4
27440: EQUAL
27441: IFFALSE 27471
// begin Say ( JMM , D15d-JMM-1 ) ;
27443: LD_EXP 36
27447: PPUSH
27448: LD_STRING D15d-JMM-1
27450: PPUSH
27451: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27455: LD_EXP 61
27459: PPUSH
27460: LD_STRING D15d-Pla-1
27462: PPUSH
27463: CALL_OW 94
// DialogueOff ;
27467: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27471: LD_EXP 59
27475: PPUSH
27476: CALL_OW 302
27480: PUSH
27481: LD_EXP 59
27485: PPUSH
27486: CALL_OW 255
27490: PUSH
27491: LD_INT 1
27493: EQUAL
27494: AND
27495: PUSH
27496: LD_INT 22
27498: PUSH
27499: LD_INT 1
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 34
27508: PUSH
27509: LD_INT 8
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PPUSH
27520: CALL_OW 69
27524: NOT
27525: AND
27526: IFFALSE 28151
// begin SetSide ( Friend , 8 ) ;
27528: LD_EXP 59
27532: PPUSH
27533: LD_INT 8
27535: PPUSH
27536: CALL_OW 235
// if IsInUnit ( Friend ) then
27540: LD_EXP 59
27544: PPUSH
27545: CALL_OW 310
27549: IFFALSE 27560
// ComExitBuilding ( Friend ) ;
27551: LD_EXP 59
27555: PPUSH
27556: CALL_OW 122
// if IsDriver ( Friend ) then
27560: LD_EXP 59
27564: PPUSH
27565: CALL 103056 0 1
27569: IFFALSE 27580
// ComExitVehicle ( Friend ) ;
27571: LD_EXP 59
27575: PPUSH
27576: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27580: LD_EXP 59
27584: PPUSH
27585: LD_INT 9
27587: PPUSH
27588: LD_INT 2
27590: PPUSH
27591: CALL_OW 171
// wait ( 0 0$05 ) ;
27595: LD_INT 175
27597: PPUSH
27598: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27602: LD_EXP 59
27606: PPUSH
27607: CALL_OW 87
// DialogueOn ;
27611: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27615: LD_EXP 36
27619: PPUSH
27620: LD_STRING D16-JMM-1
27622: PPUSH
27623: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27627: LD_EXP 59
27631: PPUSH
27632: LD_STRING D16-Friend-1
27634: PPUSH
27635: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27639: LD_EXP 36
27643: PPUSH
27644: LD_STRING D16-JMM-2
27646: PPUSH
27647: CALL_OW 88
// DialogueOff ;
27651: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27655: LD_EXP 59
27659: PPUSH
27660: LD_INT 1
27662: PPUSH
27663: CALL_OW 235
// ComHold ( Friend ) ;
27667: LD_EXP 59
27671: PPUSH
27672: CALL_OW 140
// wait ( 0 0$20 ) ;
27676: LD_INT 700
27678: PPUSH
27679: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27683: LD_EXP 59
27687: PPUSH
27688: LD_INT 9
27690: PPUSH
27691: LD_INT 2
27693: PPUSH
27694: CALL_OW 297
27698: PUSH
27699: LD_INT 30
27701: LESS
27702: IFFALSE 27771
// begin SetSide ( Friend , 8 ) ;
27704: LD_EXP 59
27708: PPUSH
27709: LD_INT 8
27711: PPUSH
27712: CALL_OW 235
// if IsInUnit ( Friend ) then
27716: LD_EXP 59
27720: PPUSH
27721: CALL_OW 310
27725: IFFALSE 27736
// ComExitBuilding ( Friend ) ;
27727: LD_EXP 59
27731: PPUSH
27732: CALL_OW 122
// if IsDriver ( Friend ) then
27736: LD_EXP 59
27740: PPUSH
27741: CALL 103056 0 1
27745: IFFALSE 27756
// ComExitVehicle ( Friend ) ;
27747: LD_EXP 59
27751: PPUSH
27752: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27756: LD_EXP 59
27760: PPUSH
27761: LD_INT 9
27763: PPUSH
27764: LD_INT 2
27766: PPUSH
27767: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27771: LD_INT 1050
27773: PPUSH
27774: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27778: LD_INT 22
27780: PUSH
27781: LD_INT 1
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 34
27790: PUSH
27791: LD_INT 8
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: PPUSH
27802: CALL_OW 69
27806: NOT
27807: IFFALSE 28129
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27809: LD_ADDR_VAR 0 3
27813: PUSH
27814: LD_INT 22
27816: PUSH
27817: LD_INT 1
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PUSH
27824: LD_INT 26
27826: PUSH
27827: LD_INT 1
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 3
27836: PUSH
27837: LD_INT 25
27839: PUSH
27840: LD_INT 12
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: LD_INT 25
27849: PUSH
27850: LD_INT 16
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: LIST
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL_OW 69
27871: PUSH
27872: LD_EXP 36
27876: PUSH
27877: LD_EXP 38
27881: PUSH
27882: LD_EXP 52
27886: PUSH
27887: LD_EXP 39
27891: PUSH
27892: LD_EXP 40
27896: PUSH
27897: LD_EXP 41
27901: PUSH
27902: LD_EXP 42
27906: PUSH
27907: LD_EXP 43
27911: PUSH
27912: LD_EXP 44
27916: PUSH
27917: LD_EXP 45
27921: PUSH
27922: LD_EXP 46
27926: PUSH
27927: LD_EXP 47
27931: PUSH
27932: LD_EXP 48
27936: PUSH
27937: LD_EXP 49
27941: PUSH
27942: LD_EXP 50
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: LIST
27951: LIST
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: LIST
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: DIFF
27964: ST_TO_ADDR
// DialogueOn ;
27965: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27969: LD_EXP 61
27973: PPUSH
27974: LD_STRING D16a-Pla-1
27976: PPUSH
27977: CALL_OW 94
// if Stevens then
27981: LD_EXP 38
27985: IFFALSE 28001
// Say ( Stevens , D16a-Huck-1 ) else
27987: LD_EXP 38
27991: PPUSH
27992: LD_STRING D16a-Huck-1
27994: PPUSH
27995: CALL_OW 88
27999: GO 28043
// if Baker then
28001: LD_EXP 52
28005: IFFALSE 28021
// Say ( Baker , D16a-Huck-1 ) else
28007: LD_EXP 52
28011: PPUSH
28012: LD_STRING D16a-Huck-1
28014: PPUSH
28015: CALL_OW 88
28019: GO 28043
// if tmp then
28021: LD_VAR 0 3
28025: IFFALSE 28043
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28027: LD_VAR 0 3
28031: PUSH
28032: LD_INT 1
28034: ARRAY
28035: PPUSH
28036: LD_STRING D16a-Sol1-1
28038: PPUSH
28039: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28043: LD_EXP 59
28047: PPUSH
28048: CALL_OW 255
28052: PUSH
28053: LD_INT 8
28055: EQUAL
28056: IFFALSE 28072
// Say ( JMM , D16a-JMM-1 ) else
28058: LD_EXP 36
28062: PPUSH
28063: LD_STRING D16a-JMM-1
28065: PPUSH
28066: CALL_OW 88
28070: GO 28108
// begin Say ( JMM , D16a-JMM-1a ) ;
28072: LD_EXP 36
28076: PPUSH
28077: LD_STRING D16a-JMM-1a
28079: PPUSH
28080: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28084: LD_EXP 59
28088: PPUSH
28089: LD_STRING D16a-Friend-1
28091: PPUSH
28092: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28096: LD_EXP 59
28100: PPUSH
28101: LD_INT 3
28103: PPUSH
28104: CALL_OW 235
// end ; DialogueOff ;
28108: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28112: LD_VAR 0 1
28116: PPUSH
28117: LD_INT 60
28119: PPUSH
28120: LD_INT 95
28122: PPUSH
28123: CALL_OW 116
// end else
28127: GO 28149
// begin DialogueOn ;
28129: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28133: LD_EXP 61
28137: PPUSH
28138: LD_STRING D16c-Pla-
28140: PPUSH
28141: CALL_OW 94
// DialogueOff ;
28145: CALL_OW 7
// end ; end else
28149: GO 28250
// begin wait ( 3 3$00 ) ;
28151: LD_INT 6300
28153: PPUSH
28154: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28158: LD_INT 22
28160: PUSH
28161: LD_INT 1
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 34
28170: PUSH
28171: LD_INT 8
28173: PUSH
28174: EMPTY
28175: LIST
28176: LIST
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PPUSH
28182: CALL_OW 69
28186: NOT
28187: IFFALSE 28230
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28189: LD_EXP 61
28193: PPUSH
28194: LD_STRING D16b-Pla-1
28196: PPUSH
28197: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28201: LD_EXP 36
28205: PPUSH
28206: LD_STRING D16b-JMM-
28208: PPUSH
28209: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28213: LD_VAR 0 1
28217: PPUSH
28218: LD_INT 60
28220: PPUSH
28221: LD_INT 95
28223: PPUSH
28224: CALL_OW 116
// end else
28228: GO 28250
// begin DialogueOn ;
28230: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28234: LD_EXP 61
28238: PPUSH
28239: LD_STRING D16c-Pla-
28241: PPUSH
28242: CALL_OW 94
// DialogueOff ;
28246: CALL_OW 7
// end ; end ; end ;
28250: PPOPN 3
28252: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28253: LD_EXP 14
28257: PUSH
28258: LD_INT 126000
28260: GREATEREQUAL
28261: PUSH
28262: LD_EXP 23
28266: NOT
28267: AND
28268: PUSH
28269: LD_EXP 71
28273: PPUSH
28274: CALL_OW 302
28278: AND
28279: IFFALSE 28637
28281: GO 28283
28283: DISABLE
28284: LD_INT 0
28286: PPUSH
// begin missionStage = 11 ;
28287: LD_ADDR_EXP 15
28291: PUSH
28292: LD_INT 11
28294: ST_TO_ADDR
// DialogueOn ;
28295: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28299: LD_EXP 71
28303: PPUSH
28304: LD_STRING D9-Roth-1
28306: PPUSH
28307: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28311: LD_EXP 36
28315: PPUSH
28316: LD_STRING D9-JMM-1
28318: PPUSH
28319: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28323: LD_EXP 71
28327: PPUSH
28328: LD_STRING D9-Roth-2
28330: PPUSH
28331: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28335: LD_EXP 71
28339: PPUSH
28340: LD_STRING D9-Roth-2a
28342: PPUSH
28343: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28347: LD_EXP 61
28351: PPUSH
28352: LD_STRING D9-Pla-2
28354: PPUSH
28355: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28359: LD_EXP 71
28363: PPUSH
28364: LD_STRING D9-Roth-3
28366: PPUSH
28367: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28371: LD_EXP 61
28375: PPUSH
28376: LD_STRING D9-Pla-3
28378: PPUSH
28379: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28383: LD_EXP 71
28387: PPUSH
28388: LD_STRING D9-Roth-4
28390: PPUSH
28391: CALL_OW 94
// dec = Query ( Q9 ) ;
28395: LD_ADDR_VAR 0 1
28399: PUSH
28400: LD_STRING Q9
28402: PPUSH
28403: CALL_OW 97
28407: ST_TO_ADDR
// if dec = 1 then
28408: LD_VAR 0 1
28412: PUSH
28413: LD_INT 1
28415: EQUAL
28416: IFFALSE 28430
// SayRadio ( Roth , D9a-Roth-1 ) ;
28418: LD_EXP 71
28422: PPUSH
28423: LD_STRING D9a-Roth-1
28425: PPUSH
28426: CALL_OW 94
// if dec = 2 then
28430: LD_VAR 0 1
28434: PUSH
28435: LD_INT 2
28437: EQUAL
28438: IFFALSE 28464
// begin Say ( JMM , D9b-JMM-1 ) ;
28440: LD_EXP 36
28444: PPUSH
28445: LD_STRING D9b-JMM-1
28447: PPUSH
28448: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28452: LD_EXP 71
28456: PPUSH
28457: LD_STRING D9b-Roth-1
28459: PPUSH
28460: CALL_OW 94
// end ; if dec = 3 then
28464: LD_VAR 0 1
28468: PUSH
28469: LD_INT 3
28471: EQUAL
28472: IFFALSE 28534
// begin Say ( JMM , D9c-JMM-1 ) ;
28474: LD_EXP 36
28478: PPUSH
28479: LD_STRING D9c-JMM-1
28481: PPUSH
28482: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28486: LD_EXP 71
28490: PPUSH
28491: LD_STRING D9c-Roth-1
28493: PPUSH
28494: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28498: LD_EXP 36
28502: PPUSH
28503: LD_STRING D9c-JMM-2
28505: PPUSH
28506: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28510: LD_EXP 71
28514: PPUSH
28515: LD_STRING D9c-Roth-2
28517: PPUSH
28518: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28522: LD_EXP 36
28526: PPUSH
28527: LD_STRING D9c-JMM-3
28529: PPUSH
28530: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28534: LD_EXP 71
28538: PPUSH
28539: LD_STRING D9c-Roth-3
28541: PPUSH
28542: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28546: LD_EXP 71
28550: PPUSH
28551: LD_STRING D9cont-Roth-1
28553: PPUSH
28554: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28558: LD_EXP 36
28562: PPUSH
28563: LD_STRING D9cont-JMM-1
28565: PPUSH
28566: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28570: LD_EXP 71
28574: PPUSH
28575: LD_STRING D9cont-Roth-2
28577: PPUSH
28578: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28582: LD_EXP 36
28586: PPUSH
28587: LD_STRING D9cont-JMM-2
28589: PPUSH
28590: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28594: LD_EXP 71
28598: PPUSH
28599: LD_STRING D9cont-Roth-3
28601: PPUSH
28602: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28606: LD_EXP 36
28610: PPUSH
28611: LD_STRING D9cont-JMM-3
28613: PPUSH
28614: CALL_OW 88
// DialogueOff ;
28618: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28622: LD_STRING M3
28624: PPUSH
28625: CALL_OW 337
// allianceActive := true ;
28629: LD_ADDR_EXP 31
28633: PUSH
28634: LD_INT 1
28636: ST_TO_ADDR
// end ;
28637: PPOPN 1
28639: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28640: LD_EXP 61
28644: PPUSH
28645: CALL_OW 301
28649: PUSH
28650: LD_EXP 64
28654: PPUSH
28655: CALL_OW 301
28659: AND
28660: PUSH
28661: LD_INT 22
28663: PUSH
28664: LD_INT 3
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 21
28673: PUSH
28674: LD_INT 1
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 50
28683: PUSH
28684: EMPTY
28685: LIST
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: LIST
28691: PPUSH
28692: CALL_OW 69
28696: PUSH
28697: LD_INT 7
28699: PUSH
28700: LD_INT 8
28702: PUSH
28703: LD_INT 9
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: LIST
28710: PUSH
28711: LD_OWVAR 67
28715: ARRAY
28716: LESS
28717: AND
28718: IFFALSE 29489
28720: GO 28722
28722: DISABLE
28723: LD_INT 0
28725: PPUSH
28726: PPUSH
28727: PPUSH
28728: PPUSH
// begin MC_Kill ( 1 ) ;
28729: LD_INT 1
28731: PPUSH
28732: CALL 33987 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28736: LD_INT 1
28738: PPUSH
28739: LD_INT 3
28741: PPUSH
28742: LD_INT 1
28744: PPUSH
28745: LD_INT 1
28747: PPUSH
28748: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28752: LD_ADDR_VAR 0 1
28756: PUSH
28757: LD_INT 22
28759: PUSH
28760: LD_INT 3
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: LD_INT 21
28769: PUSH
28770: LD_INT 1
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: PUSH
28777: LD_INT 24
28779: PUSH
28780: LD_INT 900
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: LIST
28791: PPUSH
28792: CALL_OW 69
28796: PUSH
28797: FOR_IN
28798: IFFALSE 28829
// if GetSex ( i ) = sex_male then
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 258
28809: PUSH
28810: LD_INT 1
28812: EQUAL
28813: IFFALSE 28827
// begin tmp = i ;
28815: LD_ADDR_VAR 0 2
28819: PUSH
28820: LD_VAR 0 1
28824: ST_TO_ADDR
// break ;
28825: GO 28829
// end ;
28827: GO 28797
28829: POP
28830: POP
// if tmp = 0 then
28831: LD_VAR 0 2
28835: PUSH
28836: LD_INT 0
28838: EQUAL
28839: IFFALSE 28893
// begin uc_side = 3 ;
28841: LD_ADDR_OWVAR 20
28845: PUSH
28846: LD_INT 3
28848: ST_TO_ADDR
// uc_nation = 3 ;
28849: LD_ADDR_OWVAR 21
28853: PUSH
28854: LD_INT 3
28856: ST_TO_ADDR
// hc_name =  ;
28857: LD_ADDR_OWVAR 26
28861: PUSH
28862: LD_STRING 
28864: ST_TO_ADDR
// hc_gallery =  ;
28865: LD_ADDR_OWVAR 33
28869: PUSH
28870: LD_STRING 
28872: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28873: LD_INT 1
28875: PPUSH
28876: LD_INT 10
28878: PPUSH
28879: CALL_OW 381
// tmp = CreateHuman ;
28883: LD_ADDR_VAR 0 2
28887: PUSH
28888: CALL_OW 44
28892: ST_TO_ADDR
// end ; DialogueOn ;
28893: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28897: LD_VAR 0 2
28901: PPUSH
28902: LD_STRING DSurrenderRussians-RSol1-1a
28904: PPUSH
28905: CALL_OW 88
// DialogueOff ;
28909: CALL_OW 7
// russianDestroyed := true ;
28913: LD_ADDR_EXP 21
28917: PUSH
28918: LD_INT 1
28920: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28921: LD_INT 22
28923: PUSH
28924: LD_INT 3
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 21
28933: PUSH
28934: LD_INT 1
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PPUSH
28945: CALL_OW 69
28949: PPUSH
28950: CALL_OW 122
// wait ( 0 0$1 ) ;
28954: LD_INT 35
28956: PPUSH
28957: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28961: LD_INT 22
28963: PUSH
28964: LD_INT 3
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 21
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PPUSH
28985: CALL_OW 69
28989: PPUSH
28990: LD_INT 25
28992: PPUSH
28993: CALL_OW 173
// wait ( 0 0$10 ) ;
28997: LD_INT 350
28999: PPUSH
29000: CALL_OW 67
// PrepareOmarInvasion ;
29004: CALL 13662 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29008: LD_ADDR_VAR 0 2
29012: PUSH
29013: LD_EXP 89
29017: PPUSH
29018: CALL_OW 250
29022: PUSH
29023: LD_EXP 89
29027: PPUSH
29028: CALL_OW 251
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29037: LD_VAR 0 2
29041: PUSH
29042: LD_INT 1
29044: ARRAY
29045: PPUSH
29046: LD_VAR 0 2
29050: PUSH
29051: LD_INT 2
29053: ARRAY
29054: PPUSH
29055: LD_INT 1
29057: PPUSH
29058: LD_INT 8
29060: NEG
29061: PPUSH
29062: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29066: LD_EXP 89
29070: PPUSH
29071: CALL_OW 87
// DialogueOn ;
29075: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29079: LD_EXP 36
29083: PPUSH
29084: LD_STRING D19-JMM-1
29086: PPUSH
29087: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29091: LD_ADDR_VAR 0 3
29095: PUSH
29096: LD_INT 22
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 26
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 25
29121: PUSH
29122: LD_INT 1
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 25
29131: PUSH
29132: LD_INT 2
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 25
29141: PUSH
29142: LD_INT 3
29144: PUSH
29145: EMPTY
29146: LIST
29147: LIST
29148: PUSH
29149: LD_INT 25
29151: PUSH
29152: LD_INT 4
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 25
29161: PUSH
29162: LD_INT 5
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 25
29171: PUSH
29172: LD_INT 8
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: LIST
29183: LIST
29184: LIST
29185: LIST
29186: LIST
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: LIST
29192: PPUSH
29193: CALL_OW 69
29197: PUSH
29198: LD_EXP 36
29202: PUSH
29203: LD_EXP 37
29207: PUSH
29208: LD_EXP 38
29212: PUSH
29213: LD_EXP 39
29217: PUSH
29218: LD_EXP 40
29222: PUSH
29223: LD_EXP 41
29227: PUSH
29228: LD_EXP 42
29232: PUSH
29233: LD_EXP 43
29237: PUSH
29238: LD_EXP 44
29242: PUSH
29243: LD_EXP 45
29247: PUSH
29248: LD_EXP 46
29252: PUSH
29253: LD_EXP 47
29257: PUSH
29258: LD_EXP 48
29262: PUSH
29263: LD_EXP 49
29267: PUSH
29268: LD_EXP 50
29272: PUSH
29273: LD_EXP 51
29277: PUSH
29278: LD_EXP 52
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: LIST
29294: LIST
29295: LIST
29296: LIST
29297: LIST
29298: LIST
29299: LIST
29300: LIST
29301: DIFF
29302: ST_TO_ADDR
// if tmp2 then
29303: LD_VAR 0 3
29307: IFFALSE 29325
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29309: LD_VAR 0 3
29313: PUSH
29314: LD_INT 1
29316: ARRAY
29317: PPUSH
29318: LD_STRING D19-Sol1-1
29320: PPUSH
29321: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29325: LD_EXP 36
29329: PPUSH
29330: LD_STRING D19-JMM-2
29332: PPUSH
29333: CALL_OW 88
// DialogueOff ;
29337: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29341: LD_VAR 0 2
29345: PUSH
29346: LD_INT 1
29348: ARRAY
29349: PPUSH
29350: LD_VAR 0 2
29354: PUSH
29355: LD_INT 2
29357: ARRAY
29358: PPUSH
29359: LD_INT 1
29361: PPUSH
29362: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29366: LD_STRING M5
29368: PPUSH
29369: CALL_OW 337
// omarOnMotherLode := false ;
29373: LD_ADDR_VAR 0 4
29377: PUSH
29378: LD_INT 0
29380: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29381: LD_INT 35
29383: PPUSH
29384: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29388: LD_EXP 89
29392: PPUSH
29393: LD_INT 215
29395: PPUSH
29396: LD_INT 100
29398: PPUSH
29399: CALL_OW 297
29403: PUSH
29404: LD_INT 10
29406: LESS
29407: PUSH
29408: LD_VAR 0 4
29412: NOT
29413: AND
29414: IFFALSE 29448
// begin omarOnMotherLode := true ;
29416: LD_ADDR_VAR 0 4
29420: PUSH
29421: LD_INT 1
29423: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29424: LD_EXP 36
29428: PPUSH
29429: LD_STRING D19b-JMM-1
29431: PPUSH
29432: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29436: LD_EXP 89
29440: PPUSH
29441: LD_STRING DOmarContam-Omar-1
29443: PPUSH
29444: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29448: LD_EXP 89
29452: PPUSH
29453: CALL_OW 301
29457: IFFALSE 29381
// Say ( JMM , D19a-JMM-1 ) ;
29459: LD_EXP 36
29463: PPUSH
29464: LD_STRING D19a-JMM-1
29466: PPUSH
29467: CALL_OW 88
// if Heike then
29471: LD_EXP 90
29475: IFFALSE 29489
// Say ( Heike , D19a-Hke-1 ) ;
29477: LD_EXP 90
29481: PPUSH
29482: LD_STRING D19a-Hke-1
29484: PPUSH
29485: CALL_OW 88
// end ;
29489: PPOPN 4
29491: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29492: LD_INT 22
29494: PUSH
29495: LD_INT 3
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 21
29504: PUSH
29505: LD_INT 1
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PPUSH
29516: CALL_OW 69
29520: PUSH
29521: LD_EXP 21
29525: AND
29526: IFFALSE 29594
29528: GO 29530
29530: DISABLE
29531: LD_INT 0
29533: PPUSH
29534: PPUSH
// begin enable ;
29535: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29536: LD_ADDR_VAR 0 2
29540: PUSH
29541: LD_INT 25
29543: PPUSH
29544: LD_INT 22
29546: PUSH
29547: LD_INT 3
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PPUSH
29554: CALL_OW 70
29558: ST_TO_ADDR
// if not tmp then
29559: LD_VAR 0 2
29563: NOT
29564: IFFALSE 29568
// exit ;
29566: GO 29594
// for i in tmp do
29568: LD_ADDR_VAR 0 1
29572: PUSH
29573: LD_VAR 0 2
29577: PUSH
29578: FOR_IN
29579: IFFALSE 29592
// RemoveUnit ( i ) ;
29581: LD_VAR 0 1
29585: PPUSH
29586: CALL_OW 64
29590: GO 29578
29592: POP
29593: POP
// end ;
29594: PPOPN 2
29596: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29597: LD_INT 22
29599: PUSH
29600: LD_INT 7
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 21
29609: PUSH
29610: LD_INT 1
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PPUSH
29621: CALL_OW 69
29625: PUSH
29626: LD_INT 6
29628: LESS
29629: IFFALSE 30080
29631: GO 29633
29633: DISABLE
29634: LD_INT 0
29636: PPUSH
29637: PPUSH
// begin MC_Kill ( 1 ) ;
29638: LD_INT 1
29640: PPUSH
29641: CALL 33987 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29645: LD_INT 7
29647: PPUSH
29648: LD_INT 1
29650: PPUSH
29651: LD_INT 1
29653: PPUSH
29654: LD_INT 1
29656: PPUSH
29657: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29661: LD_ADDR_VAR 0 1
29665: PUSH
29666: LD_INT 22
29668: PUSH
29669: LD_INT 7
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: PUSH
29676: LD_INT 26
29678: PUSH
29679: LD_INT 1
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: PPUSH
29690: CALL_OW 69
29694: PUSH
29695: LD_EXP 71
29699: DIFF
29700: ST_TO_ADDR
// if tmp then
29701: LD_VAR 0 1
29705: IFFALSE 29723
// tmp := tmp [ 1 ] else
29707: LD_ADDR_VAR 0 1
29711: PUSH
29712: LD_VAR 0 1
29716: PUSH
29717: LD_INT 1
29719: ARRAY
29720: ST_TO_ADDR
29721: GO 29759
// begin uc_side := 7 ;
29723: LD_ADDR_OWVAR 20
29727: PUSH
29728: LD_INT 7
29730: ST_TO_ADDR
// uc_nation := 1 ;
29731: LD_ADDR_OWVAR 21
29735: PUSH
29736: LD_INT 1
29738: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29739: LD_INT 1
29741: PPUSH
29742: LD_INT 8
29744: PPUSH
29745: CALL_OW 384
// tmp := CreateHuman ;
29749: LD_ADDR_VAR 0 1
29753: PUSH
29754: CALL_OW 44
29758: ST_TO_ADDR
// end ; DialogueOn ;
29759: CALL_OW 6
// if IsOK ( Roth ) then
29763: LD_EXP 71
29767: PPUSH
29768: CALL_OW 302
29772: IFFALSE 29786
// Say ( JMM , DAb-JMM-1 ) ;
29774: LD_EXP 36
29778: PPUSH
29779: LD_STRING DAb-JMM-1
29781: PPUSH
29782: CALL_OW 88
// if IsOK ( Roth ) then
29786: LD_EXP 71
29790: PPUSH
29791: CALL_OW 302
29795: IFFALSE 29819
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29797: LD_EXP 71
29801: PPUSH
29802: LD_STRING DSurrenderAlliance-Roth-1
29804: PPUSH
29805: CALL_OW 88
// RothCaptured := true ;
29809: LD_ADDR_EXP 33
29813: PUSH
29814: LD_INT 1
29816: ST_TO_ADDR
// end else
29817: GO 29831
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29819: LD_VAR 0 1
29823: PPUSH
29824: LD_STRING DSurrenderAlliance-Sci1-1
29826: PPUSH
29827: CALL_OW 88
// DialogueOff ;
29831: CALL_OW 7
// allianceDestroyed := true ;
29835: LD_ADDR_EXP 23
29839: PUSH
29840: LD_INT 1
29842: ST_TO_ADDR
// if trueAmericans then
29843: LD_EXP 35
29847: IFFALSE 29923
// begin if trueAmericans = 1 then
29849: LD_EXP 35
29853: PUSH
29854: LD_INT 1
29856: EQUAL
29857: IFFALSE 29873
// Say ( JMM , DAb-JMM-1a ) else
29859: LD_EXP 36
29863: PPUSH
29864: LD_STRING DAb-JMM-1a
29866: PPUSH
29867: CALL_OW 88
29871: GO 29885
// Say ( JMM , DAb-JMM-1b ) ;
29873: LD_EXP 36
29877: PPUSH
29878: LD_STRING DAb-JMM-1b
29880: PPUSH
29881: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29885: LD_EXP 35
29889: PPUSH
29890: CALL_OW 87
// for i in trueAmericans do
29894: LD_ADDR_VAR 0 2
29898: PUSH
29899: LD_EXP 35
29903: PUSH
29904: FOR_IN
29905: IFFALSE 29921
// SetSide ( i , 1 ) ;
29907: LD_VAR 0 2
29911: PPUSH
29912: LD_INT 1
29914: PPUSH
29915: CALL_OW 235
29919: GO 29904
29921: POP
29922: POP
// end ; repeat wait ( 0 0$1 ) ;
29923: LD_INT 35
29925: PPUSH
29926: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29930: LD_ADDR_VAR 0 2
29934: PUSH
29935: LD_INT 22
29937: PUSH
29938: LD_INT 7
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 21
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PPUSH
29959: CALL_OW 69
29963: PUSH
29964: FOR_IN
29965: IFFALSE 30047
// begin if IsInUnit ( i ) then
29967: LD_VAR 0 2
29971: PPUSH
29972: CALL_OW 310
29976: IFFALSE 29987
// ComExitBuilding ( i ) ;
29978: LD_VAR 0 2
29982: PPUSH
29983: CALL_OW 122
// if IsDriver ( i ) then
29987: LD_VAR 0 2
29991: PPUSH
29992: CALL 103056 0 1
29996: IFFALSE 30007
// ComExitVehicle ( i ) ;
29998: LD_VAR 0 2
30002: PPUSH
30003: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30007: LD_VAR 0 2
30011: PPUSH
30012: LD_INT 26
30014: PPUSH
30015: CALL_OW 308
30019: NOT
30020: IFFALSE 30036
// AddComMoveToArea ( i , allianceEscapeArea ) else
30022: LD_VAR 0 2
30026: PPUSH
30027: LD_INT 26
30029: PPUSH
30030: CALL_OW 173
30034: GO 30045
// RemoveUnit ( i ) ;
30036: LD_VAR 0 2
30040: PPUSH
30041: CALL_OW 64
// end ;
30045: GO 29964
30047: POP
30048: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30049: LD_INT 22
30051: PUSH
30052: LD_INT 7
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 21
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PPUSH
30073: CALL_OW 69
30077: NOT
30078: IFFALSE 29923
// end ;
30080: PPOPN 2
30082: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30083: LD_INT 0
30085: PPUSH
30086: PPUSH
// if not unit then
30087: LD_VAR 0 1
30091: NOT
30092: IFFALSE 30096
// exit ;
30094: GO 31594
// DoNotAttack ( 7 , unit ) ;
30096: LD_INT 7
30098: PPUSH
30099: LD_VAR 0 1
30103: PPUSH
30104: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30108: LD_VAR 0 1
30112: PPUSH
30113: LD_INT 260
30115: PPUSH
30116: LD_INT 235
30118: PPUSH
30119: LD_INT 3
30121: PPUSH
30122: LD_INT 1
30124: PPUSH
30125: CALL_OW 483
// SetSide ( unit , 4 ) ;
30129: LD_VAR 0 1
30133: PPUSH
30134: LD_INT 4
30136: PPUSH
30137: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30141: LD_ADDR_EXP 34
30145: PUSH
30146: LD_EXP 34
30150: PUSH
30151: LD_INT 1
30153: PLUS
30154: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30155: LD_INT 70
30157: PPUSH
30158: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30162: LD_INT 260
30164: PPUSH
30165: LD_INT 235
30167: PPUSH
30168: LD_INT 1
30170: PPUSH
30171: LD_INT 8
30173: NEG
30174: PPUSH
30175: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30179: LD_VAR 0 1
30183: PPUSH
30184: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30188: LD_VAR 0 1
30192: PPUSH
30193: LD_EXP 71
30197: PPUSH
30198: CALL_OW 119
// DialogueOn ;
30202: CALL_OW 6
// case unit of JMM :
30206: LD_VAR 0 1
30210: PUSH
30211: LD_EXP 36
30215: DOUBLE
30216: EQUAL
30217: IFTRUE 30221
30219: GO 30236
30221: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30222: LD_EXP 36
30226: PPUSH
30227: LD_STRING DA1-JMM-1
30229: PPUSH
30230: CALL_OW 91
30234: GO 30678
30236: LD_EXP 37
30240: DOUBLE
30241: EQUAL
30242: IFTRUE 30246
30244: GO 30261
30246: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30247: LD_EXP 37
30251: PPUSH
30252: LD_STRING DA1-Joan-1
30254: PPUSH
30255: CALL_OW 91
30259: GO 30678
30261: LD_EXP 39
30265: DOUBLE
30266: EQUAL
30267: IFTRUE 30271
30269: GO 30286
30271: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30272: LD_EXP 39
30276: PPUSH
30277: LD_STRING DA1-Lisa-1
30279: PPUSH
30280: CALL_OW 91
30284: GO 30678
30286: LD_EXP 40
30290: DOUBLE
30291: EQUAL
30292: IFTRUE 30296
30294: GO 30311
30296: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30297: LD_EXP 40
30301: PPUSH
30302: LD_STRING DA1-Don-1
30304: PPUSH
30305: CALL_OW 91
30309: GO 30678
30311: LD_EXP 47
30315: DOUBLE
30316: EQUAL
30317: IFTRUE 30321
30319: GO 30336
30321: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30322: LD_EXP 47
30326: PPUSH
30327: LD_STRING DA1-Corn-1
30329: PPUSH
30330: CALL_OW 91
30334: GO 30678
30336: LD_EXP 43
30340: DOUBLE
30341: EQUAL
30342: IFTRUE 30346
30344: GO 30361
30346: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30347: LD_EXP 43
30351: PPUSH
30352: LD_STRING DA1-Den-1
30354: PPUSH
30355: CALL_OW 91
30359: GO 30678
30361: LD_EXP 41
30365: DOUBLE
30366: EQUAL
30367: IFTRUE 30371
30369: GO 30386
30371: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30372: LD_EXP 41
30376: PPUSH
30377: LD_STRING DA1-Bobby-1
30379: PPUSH
30380: CALL_OW 91
30384: GO 30678
30386: LD_EXP 45
30390: DOUBLE
30391: EQUAL
30392: IFTRUE 30396
30394: GO 30411
30396: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30397: LD_EXP 45
30401: PPUSH
30402: LD_STRING DA1-Glad-1
30404: PPUSH
30405: CALL_OW 91
30409: GO 30678
30411: LD_EXP 42
30415: DOUBLE
30416: EQUAL
30417: IFTRUE 30421
30419: GO 30436
30421: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30422: LD_EXP 42
30426: PPUSH
30427: LD_STRING DA1-Cyrus-1
30429: PPUSH
30430: CALL_OW 91
30434: GO 30678
30436: LD_EXP 38
30440: DOUBLE
30441: EQUAL
30442: IFTRUE 30446
30444: GO 30461
30446: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30447: LD_EXP 38
30451: PPUSH
30452: LD_STRING DA1-Huck-1
30454: PPUSH
30455: CALL_OW 91
30459: GO 30678
30461: LD_EXP 52
30465: DOUBLE
30466: EQUAL
30467: IFTRUE 30471
30469: GO 30486
30471: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30472: LD_EXP 52
30476: PPUSH
30477: LD_STRING DA1-Huck-1
30479: PPUSH
30480: CALL_OW 91
30484: GO 30678
30486: LD_EXP 44
30490: DOUBLE
30491: EQUAL
30492: IFTRUE 30496
30494: GO 30511
30496: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30497: LD_EXP 44
30501: PPUSH
30502: LD_STRING DA1-Brown-1
30504: PPUSH
30505: CALL_OW 91
30509: GO 30678
30511: LD_EXP 48
30515: DOUBLE
30516: EQUAL
30517: IFTRUE 30521
30519: GO 30536
30521: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30522: LD_EXP 48
30526: PPUSH
30527: LD_STRING DA1-Gary-1
30529: PPUSH
30530: CALL_OW 91
30534: GO 30678
30536: LD_EXP 51
30540: DOUBLE
30541: EQUAL
30542: IFTRUE 30546
30544: GO 30561
30546: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30547: LD_EXP 51
30551: PPUSH
30552: LD_STRING DA1-Con-1
30554: PPUSH
30555: CALL_OW 91
30559: GO 30678
30561: LD_EXP 57
30565: DOUBLE
30566: EQUAL
30567: IFTRUE 30571
30569: GO 30586
30571: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30572: LD_EXP 57
30576: PPUSH
30577: LD_STRING DA1-Kurt-1
30579: PPUSH
30580: CALL_OW 91
30584: GO 30678
30586: LD_EXP 50
30590: DOUBLE
30591: EQUAL
30592: IFTRUE 30596
30594: GO 30611
30596: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30597: LD_EXP 50
30601: PPUSH
30602: LD_STRING DA1-Yam-1
30604: PPUSH
30605: CALL_OW 91
30609: GO 30678
30611: LD_EXP 49
30615: DOUBLE
30616: EQUAL
30617: IFTRUE 30621
30619: GO 30636
30621: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30622: LD_EXP 49
30626: PPUSH
30627: LD_STRING DA1-Frank-1
30629: PPUSH
30630: CALL_OW 91
30634: GO 30678
30636: POP
// begin if GetSex ( unit ) = sex_male then
30637: LD_VAR 0 1
30641: PPUSH
30642: CALL_OW 258
30646: PUSH
30647: LD_INT 1
30649: EQUAL
30650: IFFALSE 30666
// ForceSay ( unit , DA1-Sol1-1 ) else
30652: LD_VAR 0 1
30656: PPUSH
30657: LD_STRING DA1-Sol1-1
30659: PPUSH
30660: CALL_OW 91
30664: GO 30678
// ForceSay ( unit , DA1-FSol1-1 ) ;
30666: LD_VAR 0 1
30670: PPUSH
30671: LD_STRING DA1-FSol1-1
30673: PPUSH
30674: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30678: LD_EXP 71
30682: PPUSH
30683: LD_STRING DA-Roth-1
30685: PPUSH
30686: CALL_OW 88
// if capturedUnit = 1 then
30690: LD_EXP 34
30694: PUSH
30695: LD_INT 1
30697: EQUAL
30698: IFFALSE 30726
// begin Say ( Simms , DA-Sim-1 ) ;
30700: LD_EXP 72
30704: PPUSH
30705: LD_STRING DA-Sim-1
30707: PPUSH
30708: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30712: LD_EXP 71
30716: PPUSH
30717: LD_STRING DA-Roth-2
30719: PPUSH
30720: CALL_OW 88
// end else
30724: GO 30738
// Say ( Simms , DA-Sim-2 ) ;
30726: LD_EXP 72
30730: PPUSH
30731: LD_STRING DA-Sim-2
30733: PPUSH
30734: CALL_OW 88
// case unit of JMM :
30738: LD_VAR 0 1
30742: PUSH
30743: LD_EXP 36
30747: DOUBLE
30748: EQUAL
30749: IFTRUE 30753
30751: GO 30768
30753: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30754: LD_EXP 36
30758: PPUSH
30759: LD_STRING DA1-JMM-1a
30761: PPUSH
30762: CALL_OW 91
30766: GO 31275
30768: LD_EXP 37
30772: DOUBLE
30773: EQUAL
30774: IFTRUE 30778
30776: GO 30793
30778: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30779: LD_EXP 37
30783: PPUSH
30784: LD_STRING DA1-Joan-1a
30786: PPUSH
30787: CALL_OW 91
30791: GO 31275
30793: LD_EXP 39
30797: DOUBLE
30798: EQUAL
30799: IFTRUE 30803
30801: GO 30818
30803: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30804: LD_EXP 39
30808: PPUSH
30809: LD_STRING DA1-Lisa-1a
30811: PPUSH
30812: CALL_OW 91
30816: GO 31275
30818: LD_EXP 40
30822: DOUBLE
30823: EQUAL
30824: IFTRUE 30828
30826: GO 30843
30828: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30829: LD_EXP 40
30833: PPUSH
30834: LD_STRING DA1-Don-1a
30836: PPUSH
30837: CALL_OW 91
30841: GO 31275
30843: LD_EXP 47
30847: DOUBLE
30848: EQUAL
30849: IFTRUE 30853
30851: GO 30868
30853: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30854: LD_EXP 47
30858: PPUSH
30859: LD_STRING DA1-Corn-1a
30861: PPUSH
30862: CALL_OW 91
30866: GO 31275
30868: LD_EXP 43
30872: DOUBLE
30873: EQUAL
30874: IFTRUE 30878
30876: GO 30893
30878: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30879: LD_EXP 43
30883: PPUSH
30884: LD_STRING DA1-Den-1a
30886: PPUSH
30887: CALL_OW 91
30891: GO 31275
30893: LD_EXP 41
30897: DOUBLE
30898: EQUAL
30899: IFTRUE 30903
30901: GO 30918
30903: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30904: LD_EXP 41
30908: PPUSH
30909: LD_STRING DA1-Bobby-1a
30911: PPUSH
30912: CALL_OW 91
30916: GO 31275
30918: LD_EXP 45
30922: DOUBLE
30923: EQUAL
30924: IFTRUE 30928
30926: GO 30943
30928: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30929: LD_EXP 45
30933: PPUSH
30934: LD_STRING DA1-Glad-1a
30936: PPUSH
30937: CALL_OW 91
30941: GO 31275
30943: LD_EXP 42
30947: DOUBLE
30948: EQUAL
30949: IFTRUE 30953
30951: GO 30968
30953: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30954: LD_EXP 42
30958: PPUSH
30959: LD_STRING DA1-Cyrus-1a
30961: PPUSH
30962: CALL_OW 91
30966: GO 31275
30968: LD_EXP 38
30972: DOUBLE
30973: EQUAL
30974: IFTRUE 30978
30976: GO 30993
30978: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30979: LD_EXP 38
30983: PPUSH
30984: LD_STRING DA1-Huck-1a
30986: PPUSH
30987: CALL_OW 91
30991: GO 31275
30993: LD_EXP 52
30997: DOUBLE
30998: EQUAL
30999: IFTRUE 31003
31001: GO 31018
31003: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31004: LD_EXP 52
31008: PPUSH
31009: LD_STRING DA1-Huck-1a
31011: PPUSH
31012: CALL_OW 91
31016: GO 31275
31018: LD_EXP 44
31022: DOUBLE
31023: EQUAL
31024: IFTRUE 31028
31026: GO 31043
31028: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31029: LD_EXP 44
31033: PPUSH
31034: LD_STRING DA1-Brown-1a
31036: PPUSH
31037: CALL_OW 91
31041: GO 31275
31043: LD_EXP 48
31047: DOUBLE
31048: EQUAL
31049: IFTRUE 31053
31051: GO 31068
31053: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31054: LD_EXP 48
31058: PPUSH
31059: LD_STRING DA1-Gary-1a
31061: PPUSH
31062: CALL_OW 91
31066: GO 31275
31068: LD_EXP 51
31072: DOUBLE
31073: EQUAL
31074: IFTRUE 31078
31076: GO 31093
31078: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31079: LD_EXP 51
31083: PPUSH
31084: LD_STRING DA1-Con-1a
31086: PPUSH
31087: CALL_OW 91
31091: GO 31275
31093: LD_EXP 57
31097: DOUBLE
31098: EQUAL
31099: IFTRUE 31103
31101: GO 31118
31103: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31104: LD_EXP 57
31108: PPUSH
31109: LD_STRING DA1-Kurt-1a
31111: PPUSH
31112: CALL_OW 91
31116: GO 31275
31118: LD_EXP 50
31122: DOUBLE
31123: EQUAL
31124: IFTRUE 31128
31126: GO 31143
31128: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31129: LD_EXP 50
31133: PPUSH
31134: LD_STRING DA1-Yam-1a
31136: PPUSH
31137: CALL_OW 91
31141: GO 31275
31143: LD_EXP 49
31147: DOUBLE
31148: EQUAL
31149: IFTRUE 31153
31151: GO 31168
31153: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31154: LD_EXP 49
31158: PPUSH
31159: LD_STRING DA1-Frank-1a
31161: PPUSH
31162: CALL_OW 91
31166: GO 31275
31168: POP
// begin join := rand ( 0 , 1 ) ;
31169: LD_ADDR_VAR 0 3
31173: PUSH
31174: LD_INT 0
31176: PPUSH
31177: LD_INT 1
31179: PPUSH
31180: CALL_OW 12
31184: ST_TO_ADDR
// if join then
31185: LD_VAR 0 3
31189: IFFALSE 31234
// begin if GetSex ( unit ) = sex_male then
31191: LD_VAR 0 1
31195: PPUSH
31196: CALL_OW 258
31200: PUSH
31201: LD_INT 1
31203: EQUAL
31204: IFFALSE 31220
// ForceSay ( unit , DA1-Sol1-1b ) else
31206: LD_VAR 0 1
31210: PPUSH
31211: LD_STRING DA1-Sol1-1b
31213: PPUSH
31214: CALL_OW 91
31218: GO 31232
// ForceSay ( unit , DA1-FSol1-1b ) ;
31220: LD_VAR 0 1
31224: PPUSH
31225: LD_STRING DA1-FSol1-1b
31227: PPUSH
31228: CALL_OW 91
// end else
31232: GO 31275
// begin if GetSex ( unit ) = sex_male then
31234: LD_VAR 0 1
31238: PPUSH
31239: CALL_OW 258
31243: PUSH
31244: LD_INT 1
31246: EQUAL
31247: IFFALSE 31263
// ForceSay ( unit , DA1-Sol1-1a ) else
31249: LD_VAR 0 1
31253: PPUSH
31254: LD_STRING DA1-Sol1-1a
31256: PPUSH
31257: CALL_OW 91
31261: GO 31275
// ForceSay ( unit , DA1-FSol1-1a ) ;
31263: LD_VAR 0 1
31267: PPUSH
31268: LD_STRING DA1-FSol1-1a
31270: PPUSH
31271: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31275: LD_VAR 0 1
31279: PUSH
31280: LD_EXP 36
31284: EQUAL
31285: IFFALSE 31296
// begin YouLost ( JMMCaptured ) ;
31287: LD_STRING JMMCaptured
31289: PPUSH
31290: CALL_OW 104
// exit ;
31294: GO 31594
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31296: LD_VAR 0 1
31300: PUSH
31301: LD_EXP 40
31305: PUSH
31306: LD_EXP 43
31310: PUSH
31311: LD_EXP 41
31315: PUSH
31316: LD_EXP 38
31320: PUSH
31321: LD_EXP 52
31325: PUSH
31326: LD_EXP 44
31330: PUSH
31331: LD_EXP 50
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: IN
31345: PUSH
31346: LD_VAR 0 3
31350: OR
31351: IFFALSE 31450
// begin Say ( Roth , DA-Roth-3 ) ;
31353: LD_EXP 71
31357: PPUSH
31358: LD_STRING DA-Roth-3
31360: PPUSH
31361: CALL_OW 88
// SetSide ( unit , 7 ) ;
31365: LD_VAR 0 1
31369: PPUSH
31370: LD_INT 7
31372: PPUSH
31373: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31377: LD_ADDR_EXP 99
31381: PUSH
31382: LD_EXP 99
31386: PPUSH
31387: LD_INT 1
31389: PPUSH
31390: LD_EXP 99
31394: PUSH
31395: LD_INT 1
31397: ARRAY
31398: PUSH
31399: LD_VAR 0 1
31403: ADD
31404: PPUSH
31405: CALL_OW 1
31409: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31410: LD_INT 260
31412: PPUSH
31413: LD_INT 235
31415: PPUSH
31416: LD_INT 1
31418: PPUSH
31419: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31423: LD_VAR 0 1
31427: PPUSH
31428: LD_INT 1000
31430: PPUSH
31431: CALL_OW 234
// DialogueOff ;
31435: CALL_OW 7
// ComFree ( unit ) ;
31439: LD_VAR 0 1
31443: PPUSH
31444: CALL_OW 139
// end else
31448: GO 31531
// begin Say ( Roth , DA-Roth-3a ) ;
31450: LD_EXP 71
31454: PPUSH
31455: LD_STRING DA-Roth-3a
31457: PPUSH
31458: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31462: LD_ADDR_EXP 35
31466: PUSH
31467: LD_EXP 35
31471: PUSH
31472: LD_VAR 0 1
31476: ADD
31477: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31478: LD_INT 260
31480: PPUSH
31481: LD_INT 235
31483: PPUSH
31484: LD_INT 1
31486: PPUSH
31487: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31491: LD_VAR 0 1
31495: PPUSH
31496: LD_INT 1000
31498: PPUSH
31499: CALL_OW 234
// DialogueOff ;
31503: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31507: LD_VAR 0 1
31511: PPUSH
31512: LD_INT 272
31514: PPUSH
31515: LD_INT 254
31517: PPUSH
31518: CALL_OW 111
// AddComHold ( unit ) ;
31522: LD_VAR 0 1
31526: PPUSH
31527: CALL_OW 200
// end ; if capturedUnit = 1 then
31531: LD_EXP 34
31535: PUSH
31536: LD_INT 1
31538: EQUAL
31539: IFFALSE 31594
// begin DialogueOn ;
31541: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31545: LD_EXP 36
31549: PPUSH
31550: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31554: LD_EXP 36
31558: PPUSH
31559: LD_STRING DAa-JMM-1
31561: PPUSH
31562: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31566: LD_EXP 36
31570: PPUSH
31571: LD_STRING DAa-JMM-1a
31573: PPUSH
31574: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31578: LD_EXP 36
31582: PPUSH
31583: LD_STRING DAa-JMM-1b
31585: PPUSH
31586: CALL_OW 88
// DialogueOff ;
31590: CALL_OW 7
// end ; end ;
31594: LD_VAR 0 2
31598: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31599: LD_EXP 15
31603: PUSH
31604: LD_INT 13
31606: GREATEREQUAL
31607: PUSH
31608: LD_INT 22
31610: PUSH
31611: LD_INT 2
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 21
31620: PUSH
31621: LD_INT 1
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PPUSH
31632: CALL_OW 69
31636: PUSH
31637: LD_INT 0
31639: EQUAL
31640: AND
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 2
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 21
31654: PUSH
31655: LD_INT 2
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 50
31664: PUSH
31665: EMPTY
31666: LIST
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: LIST
31672: PPUSH
31673: CALL_OW 69
31677: PUSH
31678: LD_INT 0
31680: EQUAL
31681: AND
31682: PUSH
31683: LD_EXP 21
31687: AND
31688: PUSH
31689: LD_EXP 22
31693: AND
31694: PUSH
31695: LD_EXP 23
31699: AND
31700: IFFALSE 32181
31702: GO 31704
31704: DISABLE
// begin DialogueOn ;
31705: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31709: LD_EXP 36
31713: PPUSH
31714: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31718: LD_EXP 36
31722: PPUSH
31723: LD_STRING D20-JMM-1
31725: PPUSH
31726: CALL_OW 88
// if IsOK ( Joan ) then
31730: LD_EXP 37
31734: PPUSH
31735: CALL_OW 302
31739: IFFALSE 31753
// Say ( Joan , D20-Joan-1 ) ;
31741: LD_EXP 37
31745: PPUSH
31746: LD_STRING D20-Joan-1
31748: PPUSH
31749: CALL_OW 88
// if IsOk ( Lisa ) then
31753: LD_EXP 39
31757: PPUSH
31758: CALL_OW 302
31762: IFFALSE 31776
// Say ( Lisa , D20-Lisa-1 ) ;
31764: LD_EXP 39
31768: PPUSH
31769: LD_STRING D20-Lisa-1
31771: PPUSH
31772: CALL_OW 88
// if IsOk ( Donaldson ) then
31776: LD_EXP 40
31780: PPUSH
31781: CALL_OW 302
31785: IFFALSE 31799
// Say ( Donaldson , D20-Don-1 ) ;
31787: LD_EXP 40
31791: PPUSH
31792: LD_STRING D20-Don-1
31794: PPUSH
31795: CALL_OW 88
// if IsOK ( Cornel ) then
31799: LD_EXP 47
31803: PPUSH
31804: CALL_OW 302
31808: IFFALSE 31822
// Say ( Cornel , D20-Corn-1 ) ;
31810: LD_EXP 47
31814: PPUSH
31815: LD_STRING D20-Corn-1
31817: PPUSH
31818: CALL_OW 88
// if IsOk ( Denis ) then
31822: LD_EXP 43
31826: PPUSH
31827: CALL_OW 302
31831: IFFALSE 31845
// Say ( Denis , D20-Den-1 ) ;
31833: LD_EXP 43
31837: PPUSH
31838: LD_STRING D20-Den-1
31840: PPUSH
31841: CALL_OW 88
// if IsOk ( Bobby ) then
31845: LD_EXP 41
31849: PPUSH
31850: CALL_OW 302
31854: IFFALSE 31868
// Say ( Bobby , D20-Bobby-1 ) ;
31856: LD_EXP 41
31860: PPUSH
31861: LD_STRING D20-Bobby-1
31863: PPUSH
31864: CALL_OW 88
// if IsOk ( Gladstone ) then
31868: LD_EXP 45
31872: PPUSH
31873: CALL_OW 302
31877: IFFALSE 31891
// Say ( Gladstone , D20-Glad-1 ) ;
31879: LD_EXP 45
31883: PPUSH
31884: LD_STRING D20-Glad-1
31886: PPUSH
31887: CALL_OW 88
// if IsOk ( Cyrus ) then
31891: LD_EXP 42
31895: PPUSH
31896: CALL_OW 302
31900: IFFALSE 31914
// Say ( Cyrus , D20-Cyrus-1 ) ;
31902: LD_EXP 42
31906: PPUSH
31907: LD_STRING D20-Cyrus-1
31909: PPUSH
31910: CALL_OW 88
// if IsOk ( Stevens ) then
31914: LD_EXP 38
31918: PPUSH
31919: CALL_OW 302
31923: IFFALSE 31937
// Say ( Stevens , D20-Huck-1 ) ;
31925: LD_EXP 38
31929: PPUSH
31930: LD_STRING D20-Huck-1
31932: PPUSH
31933: CALL_OW 88
// if IsOk ( Brown ) then
31937: LD_EXP 44
31941: PPUSH
31942: CALL_OW 302
31946: IFFALSE 31960
// Say ( Brown , D20-Brown-1 ) ;
31948: LD_EXP 44
31952: PPUSH
31953: LD_STRING D20-Brown-1
31955: PPUSH
31956: CALL_OW 88
// if IsOk ( Gary ) then
31960: LD_EXP 48
31964: PPUSH
31965: CALL_OW 302
31969: IFFALSE 31983
// Say ( Gary , D20-Gary-1 ) ;
31971: LD_EXP 48
31975: PPUSH
31976: LD_STRING D20-Gary-1
31978: PPUSH
31979: CALL_OW 88
// if IsOk ( Connie ) then
31983: LD_EXP 51
31987: PPUSH
31988: CALL_OW 302
31992: IFFALSE 32006
// Say ( Connie , D20-Con-1 ) ;
31994: LD_EXP 51
31998: PPUSH
31999: LD_STRING D20-Con-1
32001: PPUSH
32002: CALL_OW 88
// if IsOk ( Kurt ) then
32006: LD_EXP 57
32010: PPUSH
32011: CALL_OW 302
32015: IFFALSE 32029
// Say ( Kurt , D20-Kurt-1 ) ;
32017: LD_EXP 57
32021: PPUSH
32022: LD_STRING D20-Kurt-1
32024: PPUSH
32025: CALL_OW 88
// if IsOk ( Kikuchi ) then
32029: LD_EXP 50
32033: PPUSH
32034: CALL_OW 302
32038: IFFALSE 32052
// Say ( Kikuchi , D20-Yam-1 ) ;
32040: LD_EXP 50
32044: PPUSH
32045: LD_STRING D20-Yam-1
32047: PPUSH
32048: CALL_OW 88
// if IsOk ( Frank ) then
32052: LD_EXP 49
32056: PPUSH
32057: CALL_OW 302
32061: IFFALSE 32075
// Say ( Frank , D20-Frank-1 ) ;
32063: LD_EXP 49
32067: PPUSH
32068: LD_STRING D20-Frank-1
32070: PPUSH
32071: CALL_OW 88
// DialogueOff ;
32075: CALL_OW 7
// if RothCaptured then
32079: LD_EXP 33
32083: IFFALSE 32097
// AddMedal ( Roth , 1 ) else
32085: LD_STRING Roth
32087: PPUSH
32088: LD_INT 1
32090: PPUSH
32091: CALL_OW 101
32095: GO 32108
// AddMedal ( Roth , - 1 ) ;
32097: LD_STRING Roth
32099: PPUSH
32100: LD_INT 1
32102: NEG
32103: PPUSH
32104: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32108: LD_EXP 27
32112: IFFALSE 32126
// AddMedal ( Project , 1 ) else
32114: LD_STRING Project
32116: PPUSH
32117: LD_INT 1
32119: PPUSH
32120: CALL_OW 101
32124: GO 32137
// AddMedal ( Project , - 1 ) ;
32126: LD_STRING Project
32128: PPUSH
32129: LD_INT 1
32131: NEG
32132: PPUSH
32133: CALL_OW 101
// if lostCounter = 0 then
32137: LD_EXP 32
32141: PUSH
32142: LD_INT 0
32144: EQUAL
32145: IFFALSE 32159
// AddMedal ( NoLosses , 1 ) else
32147: LD_STRING NoLosses
32149: PPUSH
32150: LD_INT 1
32152: PPUSH
32153: CALL_OW 101
32157: GO 32170
// AddMedal ( NoLosses , - 1 ) ;
32159: LD_STRING NoLosses
32161: PPUSH
32162: LD_INT 1
32164: NEG
32165: PPUSH
32166: CALL_OW 101
// GiveMedals ( MAIN ) ;
32170: LD_STRING MAIN
32172: PPUSH
32173: CALL_OW 102
// YouWin ;
32177: CALL_OW 103
// end ; end_of_file
32181: END
// export function CustomEvent ( event ) ; begin
32182: LD_INT 0
32184: PPUSH
// end ;
32185: LD_VAR 0 2
32189: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32190: LD_VAR 0 1
32194: PUSH
32195: LD_INT 1
32197: EQUAL
32198: PUSH
32199: LD_VAR 0 2
32203: PUSH
32204: LD_INT 4
32206: EQUAL
32207: AND
32208: PUSH
32209: LD_EXP 55
32213: PPUSH
32214: CALL_OW 300
32218: AND
32219: IFFALSE 32235
// begin wait ( 0 0$2 ) ;
32221: LD_INT 70
32223: PPUSH
32224: CALL_OW 67
// YouLost ( Dismissed ) ;
32228: LD_STRING Dismissed
32230: PPUSH
32231: CALL_OW 104
// end ; end ;
32235: PPOPN 2
32237: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32238: LD_VAR 0 2
32242: PPUSH
32243: LD_VAR 0 3
32247: PPUSH
32248: LD_INT 18
32250: PPUSH
32251: CALL_OW 309
32255: IFFALSE 32264
// YouLost ( Motherlode3 ) ;
32257: LD_STRING Motherlode3
32259: PPUSH
32260: CALL_OW 104
// end ;
32264: PPOPN 3
32266: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32267: LD_EXP 27
32271: NOT
32272: IFFALSE 32282
// behemothDone := true ;
32274: LD_ADDR_EXP 28
32278: PUSH
32279: LD_INT 1
32281: ST_TO_ADDR
// end ;
32282: PPOPN 1
32284: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32285: LD_VAR 0 1
32289: PPUSH
32290: CALL_OW 255
32294: PUSH
32295: LD_INT 1
32297: EQUAL
32298: PUSH
32299: LD_EXP 30
32303: AND
32304: PUSH
32305: LD_INT 22
32307: PUSH
32308: LD_INT 3
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 34
32317: PUSH
32318: LD_INT 48
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PPUSH
32329: CALL_OW 69
32333: AND
32334: PUSH
32335: LD_INT 22
32337: PUSH
32338: LD_INT 1
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 34
32347: PUSH
32348: LD_INT 8
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PPUSH
32359: CALL_OW 69
32363: NOT
32364: AND
32365: IFFALSE 32417
// begin wait ( 0 0$5 ) ;
32367: LD_INT 175
32369: PPUSH
32370: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32374: LD_INT 22
32376: PUSH
32377: LD_INT 3
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 34
32386: PUSH
32387: LD_INT 48
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PPUSH
32398: CALL_OW 69
32402: PUSH
32403: LD_INT 1
32405: ARRAY
32406: PPUSH
32407: LD_INT 60
32409: PPUSH
32410: LD_INT 95
32412: PPUSH
32413: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32417: LD_VAR 0 2
32421: PPUSH
32422: LD_VAR 0 3
32426: PPUSH
32427: LD_INT 18
32429: PPUSH
32430: CALL_OW 309
32434: IFFALSE 32494
// begin if GetSide ( unit ) = 1 then
32436: LD_VAR 0 1
32440: PPUSH
32441: CALL_OW 255
32445: PUSH
32446: LD_INT 1
32448: EQUAL
32449: IFFALSE 32465
// begin wait ( 0 0$6 ) ;
32451: LD_INT 210
32453: PPUSH
32454: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32458: LD_STRING Motherlode2
32460: PPUSH
32461: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32465: LD_VAR 0 1
32469: PPUSH
32470: CALL_OW 255
32474: PUSH
32475: LD_INT 8
32477: EQUAL
32478: IFFALSE 32494
// begin wait ( 0 0$6 ) ;
32480: LD_INT 210
32482: PPUSH
32483: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32487: LD_STRING Motherlode1
32489: PPUSH
32490: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32494: LD_VAR 0 1
32498: PPUSH
32499: CALL_OW 255
32503: PUSH
32504: LD_INT 3
32506: EQUAL
32507: IFFALSE 32528
// begin wait ( 0 0$5 ) ;
32509: LD_INT 175
32511: PPUSH
32512: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32516: LD_EXP 61
32520: PPUSH
32521: LD_STRING D18-Pla-1
32523: PPUSH
32524: CALL_OW 94
// end ; end ;
32528: PPOPN 3
32530: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32531: LD_VAR 0 1
32535: PUSH
32536: LD_EXP 70
32540: IN
32541: IFFALSE 32561
// begin behemothBuilders := behemothBuilders diff un ;
32543: LD_ADDR_EXP 70
32547: PUSH
32548: LD_EXP 70
32552: PUSH
32553: LD_VAR 0 1
32557: DIFF
32558: ST_TO_ADDR
// exit ;
32559: GO 32659
// end ; if un = JMM then
32561: LD_VAR 0 1
32565: PUSH
32566: LD_EXP 36
32570: EQUAL
32571: IFFALSE 32582
// begin YouLost ( JMM ) ;
32573: LD_STRING JMM
32575: PPUSH
32576: CALL_OW 104
// exit ;
32580: GO 32659
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32582: LD_VAR 0 1
32586: PUSH
32587: LD_INT 22
32589: PUSH
32590: LD_INT 1
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 3
32599: PUSH
32600: LD_INT 25
32602: PUSH
32603: LD_INT 16
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 25
32612: PUSH
32613: LD_INT 12
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: LIST
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PPUSH
32629: CALL_OW 69
32633: IN
32634: IFFALSE 32650
// lostCounter := lostCounter + 1 ;
32636: LD_ADDR_EXP 32
32640: PUSH
32641: LD_EXP 32
32645: PUSH
32646: LD_INT 1
32648: PLUS
32649: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32650: LD_VAR 0 1
32654: PPUSH
32655: CALL 60302 0 1
// end ;
32659: PPOPN 1
32661: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32662: LD_VAR 0 1
32666: PPUSH
32667: LD_VAR 0 2
32671: PPUSH
32672: CALL 62357 0 2
// end ;
32676: PPOPN 2
32678: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32679: LD_VAR 0 1
32683: PPUSH
32684: CALL 61425 0 1
// end ;
32688: PPOPN 1
32690: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32691: LD_VAR 0 1
32695: PUSH
32696: LD_INT 22
32698: PUSH
32699: LD_INT 8
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 30
32708: PUSH
32709: LD_INT 2
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 23
32718: PUSH
32719: LD_INT 3
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: IN
32736: IFFALSE 32763
// begin ComUpgrade ( building ) ;
32738: LD_VAR 0 1
32742: PPUSH
32743: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32747: LD_EXP 58
32751: PPUSH
32752: LD_VAR 0 1
32756: PPUSH
32757: CALL 72559 0 2
// exit ;
32761: GO 32772
// end ; MCE_BuildingComplete ( building ) ;
32763: LD_VAR 0 1
32767: PPUSH
32768: CALL 61666 0 1
// end ;
32772: PPOPN 1
32774: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32775: LD_VAR 0 1
32779: PPUSH
32780: LD_VAR 0 2
32784: PPUSH
32785: CALL 59998 0 2
// end ;
32789: PPOPN 2
32791: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32792: LD_VAR 0 1
32796: PPUSH
32797: LD_VAR 0 2
32801: PPUSH
32802: LD_VAR 0 3
32806: PPUSH
32807: LD_VAR 0 4
32811: PPUSH
32812: LD_VAR 0 5
32816: PPUSH
32817: CALL 59618 0 5
// end ;
32821: PPOPN 5
32823: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32824: LD_VAR 0 1
32828: PPUSH
32829: LD_VAR 0 2
32833: PPUSH
32834: CALL 59214 0 2
// end ;
32838: PPOPN 2
32840: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32841: LD_VAR 0 1
32845: PPUSH
32846: LD_VAR 0 2
32850: PPUSH
32851: LD_VAR 0 3
32855: PPUSH
32856: LD_VAR 0 4
32860: PPUSH
32861: CALL 59052 0 4
// end ;
32865: PPOPN 4
32867: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32868: LD_VAR 0 1
32872: PPUSH
32873: LD_VAR 0 2
32877: PPUSH
32878: LD_VAR 0 3
32882: PPUSH
32883: CALL 58827 0 3
// end ;
32887: PPOPN 3
32889: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32890: LD_VAR 0 1
32894: PPUSH
32895: LD_VAR 0 2
32899: PPUSH
32900: CALL 58712 0 2
// end ;
32904: PPOPN 2
32906: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32907: LD_VAR 0 1
32911: PPUSH
32912: LD_VAR 0 2
32916: PPUSH
32917: CALL 62618 0 2
// end ;
32921: PPOPN 2
32923: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32924: LD_VAR 0 1
32928: PPUSH
32929: CALL_OW 255
32933: PUSH
32934: LD_INT 4
32936: EQUAL
32937: PUSH
32938: LD_VAR 0 1
32942: PUSH
32943: LD_EXP 18
32947: PUSH
32948: LD_INT 1
32950: ARRAY
32951: IN
32952: AND
32953: PUSH
32954: LD_EXP 19
32958: AND
32959: IFFALSE 32978
// begin ComMoveXY ( driver , 61 , 93 ) ;
32961: LD_VAR 0 1
32965: PPUSH
32966: LD_INT 61
32968: PPUSH
32969: LD_INT 93
32971: PPUSH
32972: CALL_OW 111
// exit ;
32976: GO 33002
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32978: LD_VAR 0 1
32982: PPUSH
32983: LD_VAR 0 2
32987: PPUSH
32988: LD_VAR 0 3
32992: PPUSH
32993: LD_VAR 0 4
32997: PPUSH
32998: CALL 62834 0 4
// end ;
33002: PPOPN 4
33004: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33005: LD_VAR 0 1
33009: PPUSH
33010: LD_VAR 0 2
33014: PPUSH
33015: CALL 58521 0 2
// end ;
33019: PPOPN 2
33021: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33022: LD_VAR 0 1
33026: PPUSH
33027: CALL 105646 0 1
// end ; end_of_file
33031: PPOPN 1
33033: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33034: LD_EXP 15
33038: PUSH
33039: LD_INT 2
33041: EQUAL
33042: IFFALSE 33521
33044: GO 33046
33046: DISABLE
33047: LD_INT 0
33049: PPUSH
// begin time := 0 0$40 ;
33050: LD_ADDR_VAR 0 1
33054: PUSH
33055: LD_INT 1400
33057: ST_TO_ADDR
// repeat wait ( time ) ;
33058: LD_VAR 0 1
33062: PPUSH
33063: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33067: LD_INT 1
33069: PPUSH
33070: LD_INT 5
33072: PPUSH
33073: CALL_OW 12
33077: PPUSH
33078: LD_INT 106
33080: PPUSH
33081: LD_INT 150
33083: PPUSH
33084: LD_INT 19
33086: PPUSH
33087: LD_INT 1
33089: PPUSH
33090: CALL_OW 56
// time := time + 0 0$9 ;
33094: LD_ADDR_VAR 0 1
33098: PUSH
33099: LD_VAR 0 1
33103: PUSH
33104: LD_INT 315
33106: PLUS
33107: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33108: LD_INT 455
33110: PPUSH
33111: LD_INT 840
33113: PPUSH
33114: CALL_OW 12
33118: PPUSH
33119: CALL_OW 67
// if Prob ( 50 ) then
33123: LD_INT 50
33125: PPUSH
33126: CALL_OW 13
33130: IFFALSE 33159
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33132: LD_INT 1
33134: PPUSH
33135: LD_INT 5
33137: PPUSH
33138: CALL_OW 12
33142: PPUSH
33143: LD_INT 62
33145: PPUSH
33146: LD_INT 108
33148: PPUSH
33149: LD_INT 10
33151: PPUSH
33152: LD_INT 1
33154: PPUSH
33155: CALL_OW 56
// until missionStage > 4 ;
33159: LD_EXP 15
33163: PUSH
33164: LD_INT 4
33166: GREATER
33167: IFFALSE 33058
// repeat wait ( 0 0$1 ) ;
33169: LD_INT 35
33171: PPUSH
33172: CALL_OW 67
// until missionStage = 6 ;
33176: LD_EXP 15
33180: PUSH
33181: LD_INT 6
33183: EQUAL
33184: IFFALSE 33169
// time := 0 0$50 ;
33186: LD_ADDR_VAR 0 1
33190: PUSH
33191: LD_INT 1750
33193: ST_TO_ADDR
// repeat wait ( time ) ;
33194: LD_VAR 0 1
33198: PPUSH
33199: CALL_OW 67
// if Prob ( 50 ) then
33203: LD_INT 50
33205: PPUSH
33206: CALL_OW 13
33210: IFFALSE 33239
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33212: LD_INT 1
33214: PPUSH
33215: LD_INT 5
33217: PPUSH
33218: CALL_OW 12
33222: PPUSH
33223: LD_INT 106
33225: PPUSH
33226: LD_INT 89
33228: PPUSH
33229: LD_INT 45
33231: PPUSH
33232: LD_INT 1
33234: PPUSH
33235: CALL_OW 56
// time := time + 0 0$3 ;
33239: LD_ADDR_VAR 0 1
33243: PUSH
33244: LD_VAR 0 1
33248: PUSH
33249: LD_INT 105
33251: PLUS
33252: ST_TO_ADDR
// if Prob ( 30 ) then
33253: LD_INT 30
33255: PPUSH
33256: CALL_OW 13
33260: IFFALSE 33306
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33262: LD_INT 525
33264: PPUSH
33265: LD_INT 735
33267: PPUSH
33268: CALL_OW 12
33272: PPUSH
33273: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33277: LD_INT 1
33279: PPUSH
33280: LD_INT 5
33282: PPUSH
33283: CALL_OW 12
33287: PPUSH
33288: LD_INT 21
33290: PPUSH
33291: LD_INT 26
33293: PPUSH
33294: LD_INT 12
33296: PPUSH
33297: LD_INT 1
33299: PPUSH
33300: CALL_OW 56
// end else
33304: GO 33342
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33306: LD_INT 700
33308: PPUSH
33309: LD_INT 1225
33311: PPUSH
33312: CALL_OW 12
33316: PPUSH
33317: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33321: LD_INT 1
33323: PPUSH
33324: LD_INT 5
33326: PPUSH
33327: CALL_OW 12
33331: PPUSH
33332: LD_INT 16
33334: PPUSH
33335: LD_INT 1
33337: PPUSH
33338: CALL_OW 55
// end ; if Prob ( 50 ) then
33342: LD_INT 50
33344: PPUSH
33345: CALL_OW 13
33349: IFFALSE 33395
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33351: LD_INT 700
33353: PPUSH
33354: LD_INT 1050
33356: PPUSH
33357: CALL_OW 12
33361: PPUSH
33362: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33366: LD_INT 1
33368: PPUSH
33369: LD_INT 5
33371: PPUSH
33372: CALL_OW 12
33376: PPUSH
33377: LD_INT 181
33379: PPUSH
33380: LD_INT 218
33382: PPUSH
33383: LD_INT 16
33385: PPUSH
33386: LD_INT 1
33388: PPUSH
33389: CALL_OW 56
// end else
33393: GO 33431
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33395: LD_INT 350
33397: PPUSH
33398: LD_INT 525
33400: PPUSH
33401: CALL_OW 12
33405: PPUSH
33406: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33410: LD_INT 1
33412: PPUSH
33413: LD_INT 5
33415: PPUSH
33416: CALL_OW 12
33420: PPUSH
33421: LD_INT 15
33423: PPUSH
33424: LD_INT 1
33426: PPUSH
33427: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33431: LD_INT 45
33433: PUSH
33434: LD_INT 32
33436: PUSH
33437: LD_INT 25
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: LIST
33444: PUSH
33445: LD_OWVAR 67
33449: ARRAY
33450: PPUSH
33451: CALL_OW 13
33455: IFFALSE 33499
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33457: LD_INT 525
33459: PPUSH
33460: LD_INT 875
33462: PPUSH
33463: CALL_OW 12
33467: PPUSH
33468: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33472: LD_INT 1
33474: PPUSH
33475: LD_INT 5
33477: PPUSH
33478: CALL_OW 12
33482: PPUSH
33483: LD_INT 103
33485: PPUSH
33486: LD_INT 140
33488: PPUSH
33489: LD_INT 20
33491: PPUSH
33492: LD_INT 1
33494: PPUSH
33495: CALL_OW 56
// end ; if time > 2 2$20 then
33499: LD_VAR 0 1
33503: PUSH
33504: LD_INT 4900
33506: GREATER
33507: IFFALSE 33517
// time := 0 0$50 ;
33509: LD_ADDR_VAR 0 1
33513: PUSH
33514: LD_INT 1750
33516: ST_TO_ADDR
// until false ;
33517: LD_INT 0
33519: IFFALSE 33194
// end ; end_of_file
33521: PPOPN 1
33523: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33524: LD_EXP 13
33528: PUSH
33529: LD_EXP 15
33533: PUSH
33534: LD_INT 6
33536: GREATEREQUAL
33537: AND
33538: IFFALSE 33575
33540: GO 33542
33542: DISABLE
// begin enable ;
33543: ENABLE
// missionTime := missionTime + 0 0$1 ;
33544: LD_ADDR_EXP 14
33548: PUSH
33549: LD_EXP 14
33553: PUSH
33554: LD_INT 35
33556: PLUS
33557: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33558: LD_ADDR_OWVAR 47
33562: PUSH
33563: LD_STRING #Am15-1
33565: PUSH
33566: LD_EXP 14
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: ST_TO_ADDR
// end ; end_of_file
33575: END
// export function InitNature ; begin
33576: LD_INT 0
33578: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33579: LD_INT 3
33581: PPUSH
33582: LD_INT 3
33584: PPUSH
33585: LD_INT 2
33587: PPUSH
33588: LD_INT 1
33590: PPUSH
33591: LD_INT 1
33593: PPUSH
33594: LD_INT 0
33596: PPUSH
33597: LD_INT 0
33599: PPUSH
33600: LD_INT 20
33602: PPUSH
33603: LD_INT 0
33605: PPUSH
33606: CALL 97400 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33610: LD_INT 2
33612: PPUSH
33613: LD_INT 1
33615: PPUSH
33616: LD_INT 1
33618: PPUSH
33619: LD_INT 1
33621: PPUSH
33622: LD_INT 1
33624: PPUSH
33625: LD_INT 0
33627: PPUSH
33628: LD_INT 0
33630: PPUSH
33631: LD_INT 21
33633: PPUSH
33634: LD_INT 0
33636: PPUSH
33637: CALL 97400 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33641: LD_INT 4
33643: PPUSH
33644: LD_INT 1
33646: PPUSH
33647: LD_INT 2
33649: PPUSH
33650: LD_INT 4
33652: PPUSH
33653: LD_INT 2
33655: PPUSH
33656: LD_INT 1
33658: PPUSH
33659: LD_INT 0
33661: PPUSH
33662: LD_INT 22
33664: PPUSH
33665: LD_INT 0
33667: PPUSH
33668: CALL 97400 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33672: LD_INT 0
33674: PPUSH
33675: LD_INT 0
33677: PPUSH
33678: LD_INT 0
33680: PPUSH
33681: LD_INT 0
33683: PPUSH
33684: LD_INT 0
33686: PPUSH
33687: LD_INT 0
33689: PPUSH
33690: LD_INT 9
33692: PPUSH
33693: LD_INT 0
33695: PPUSH
33696: LD_INT 23
33698: PPUSH
33699: CALL 97400 0 9
// end ; end_of_file
33703: LD_VAR 0 1
33707: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33708: GO 33710
33710: DISABLE
// begin ru_radar := 98 ;
33711: LD_ADDR_EXP 92
33715: PUSH
33716: LD_INT 98
33718: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33719: LD_ADDR_EXP 93
33723: PUSH
33724: LD_INT 89
33726: ST_TO_ADDR
// us_hack := 99 ;
33727: LD_ADDR_EXP 94
33731: PUSH
33732: LD_INT 99
33734: ST_TO_ADDR
// us_artillery := 97 ;
33735: LD_ADDR_EXP 95
33739: PUSH
33740: LD_INT 97
33742: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33743: LD_ADDR_EXP 96
33747: PUSH
33748: LD_INT 91
33750: ST_TO_ADDR
// end ; end_of_file
33751: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33752: LD_INT 0
33754: PPUSH
33755: PPUSH
// skirmish := false ;
33756: LD_ADDR_EXP 97
33760: PUSH
33761: LD_INT 0
33763: ST_TO_ADDR
// debug_mc := false ;
33764: LD_ADDR_EXP 98
33768: PUSH
33769: LD_INT 0
33771: ST_TO_ADDR
// mc_bases := [ ] ;
33772: LD_ADDR_EXP 99
33776: PUSH
33777: EMPTY
33778: ST_TO_ADDR
// mc_sides := [ ] ;
33779: LD_ADDR_EXP 125
33783: PUSH
33784: EMPTY
33785: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33786: LD_ADDR_EXP 100
33790: PUSH
33791: EMPTY
33792: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33793: LD_ADDR_EXP 101
33797: PUSH
33798: EMPTY
33799: ST_TO_ADDR
// mc_need_heal := [ ] ;
33800: LD_ADDR_EXP 102
33804: PUSH
33805: EMPTY
33806: ST_TO_ADDR
// mc_healers := [ ] ;
33807: LD_ADDR_EXP 103
33811: PUSH
33812: EMPTY
33813: ST_TO_ADDR
// mc_build_list := [ ] ;
33814: LD_ADDR_EXP 104
33818: PUSH
33819: EMPTY
33820: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33821: LD_ADDR_EXP 131
33825: PUSH
33826: EMPTY
33827: ST_TO_ADDR
// mc_builders := [ ] ;
33828: LD_ADDR_EXP 105
33832: PUSH
33833: EMPTY
33834: ST_TO_ADDR
// mc_construct_list := [ ] ;
33835: LD_ADDR_EXP 106
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_turret_list := [ ] ;
33842: LD_ADDR_EXP 107
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33849: LD_ADDR_EXP 108
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_miners := [ ] ;
33856: LD_ADDR_EXP 113
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_mines := [ ] ;
33863: LD_ADDR_EXP 112
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_minefields := [ ] ;
33870: LD_ADDR_EXP 114
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_crates := [ ] ;
33877: LD_ADDR_EXP 115
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33884: LD_ADDR_EXP 116
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_crates_area := [ ] ;
33891: LD_ADDR_EXP 117
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_vehicles := [ ] ;
33898: LD_ADDR_EXP 118
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_attack := [ ] ;
33905: LD_ADDR_EXP 119
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// mc_produce := [ ] ;
33912: LD_ADDR_EXP 120
33916: PUSH
33917: EMPTY
33918: ST_TO_ADDR
// mc_defender := [ ] ;
33919: LD_ADDR_EXP 121
33923: PUSH
33924: EMPTY
33925: ST_TO_ADDR
// mc_parking := [ ] ;
33926: LD_ADDR_EXP 123
33930: PUSH
33931: EMPTY
33932: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33933: LD_ADDR_EXP 109
33937: PUSH
33938: EMPTY
33939: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33940: LD_ADDR_EXP 111
33944: PUSH
33945: EMPTY
33946: ST_TO_ADDR
// mc_scan := [ ] ;
33947: LD_ADDR_EXP 122
33951: PUSH
33952: EMPTY
33953: ST_TO_ADDR
// mc_scan_area := [ ] ;
33954: LD_ADDR_EXP 124
33958: PUSH
33959: EMPTY
33960: ST_TO_ADDR
// mc_tech := [ ] ;
33961: LD_ADDR_EXP 126
33965: PUSH
33966: EMPTY
33967: ST_TO_ADDR
// mc_class := [ ] ;
33968: LD_ADDR_EXP 140
33972: PUSH
33973: EMPTY
33974: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33975: LD_ADDR_EXP 141
33979: PUSH
33980: EMPTY
33981: ST_TO_ADDR
// end ;
33982: LD_VAR 0 1
33986: RET
// export function MC_Kill ( base ) ; begin
33987: LD_INT 0
33989: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33990: LD_ADDR_EXP 99
33994: PUSH
33995: LD_EXP 99
33999: PPUSH
34000: LD_VAR 0 1
34004: PPUSH
34005: EMPTY
34006: PPUSH
34007: CALL_OW 1
34011: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34012: LD_ADDR_EXP 100
34016: PUSH
34017: LD_EXP 100
34021: PPUSH
34022: LD_VAR 0 1
34026: PPUSH
34027: EMPTY
34028: PPUSH
34029: CALL_OW 1
34033: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34034: LD_ADDR_EXP 101
34038: PUSH
34039: LD_EXP 101
34043: PPUSH
34044: LD_VAR 0 1
34048: PPUSH
34049: EMPTY
34050: PPUSH
34051: CALL_OW 1
34055: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34056: LD_ADDR_EXP 102
34060: PUSH
34061: LD_EXP 102
34065: PPUSH
34066: LD_VAR 0 1
34070: PPUSH
34071: EMPTY
34072: PPUSH
34073: CALL_OW 1
34077: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34078: LD_ADDR_EXP 103
34082: PUSH
34083: LD_EXP 103
34087: PPUSH
34088: LD_VAR 0 1
34092: PPUSH
34093: EMPTY
34094: PPUSH
34095: CALL_OW 1
34099: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34100: LD_ADDR_EXP 104
34104: PUSH
34105: LD_EXP 104
34109: PPUSH
34110: LD_VAR 0 1
34114: PPUSH
34115: EMPTY
34116: PPUSH
34117: CALL_OW 1
34121: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34122: LD_ADDR_EXP 105
34126: PUSH
34127: LD_EXP 105
34131: PPUSH
34132: LD_VAR 0 1
34136: PPUSH
34137: EMPTY
34138: PPUSH
34139: CALL_OW 1
34143: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34144: LD_ADDR_EXP 106
34148: PUSH
34149: LD_EXP 106
34153: PPUSH
34154: LD_VAR 0 1
34158: PPUSH
34159: EMPTY
34160: PPUSH
34161: CALL_OW 1
34165: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34166: LD_ADDR_EXP 107
34170: PUSH
34171: LD_EXP 107
34175: PPUSH
34176: LD_VAR 0 1
34180: PPUSH
34181: EMPTY
34182: PPUSH
34183: CALL_OW 1
34187: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34188: LD_ADDR_EXP 108
34192: PUSH
34193: LD_EXP 108
34197: PPUSH
34198: LD_VAR 0 1
34202: PPUSH
34203: EMPTY
34204: PPUSH
34205: CALL_OW 1
34209: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34210: LD_ADDR_EXP 109
34214: PUSH
34215: LD_EXP 109
34219: PPUSH
34220: LD_VAR 0 1
34224: PPUSH
34225: EMPTY
34226: PPUSH
34227: CALL_OW 1
34231: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34232: LD_ADDR_EXP 110
34236: PUSH
34237: LD_EXP 110
34241: PPUSH
34242: LD_VAR 0 1
34246: PPUSH
34247: LD_INT 0
34249: PPUSH
34250: CALL_OW 1
34254: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34255: LD_ADDR_EXP 111
34259: PUSH
34260: LD_EXP 111
34264: PPUSH
34265: LD_VAR 0 1
34269: PPUSH
34270: EMPTY
34271: PPUSH
34272: CALL_OW 1
34276: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34277: LD_ADDR_EXP 112
34281: PUSH
34282: LD_EXP 112
34286: PPUSH
34287: LD_VAR 0 1
34291: PPUSH
34292: EMPTY
34293: PPUSH
34294: CALL_OW 1
34298: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34299: LD_ADDR_EXP 113
34303: PUSH
34304: LD_EXP 113
34308: PPUSH
34309: LD_VAR 0 1
34313: PPUSH
34314: EMPTY
34315: PPUSH
34316: CALL_OW 1
34320: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34321: LD_ADDR_EXP 114
34325: PUSH
34326: LD_EXP 114
34330: PPUSH
34331: LD_VAR 0 1
34335: PPUSH
34336: EMPTY
34337: PPUSH
34338: CALL_OW 1
34342: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34343: LD_ADDR_EXP 115
34347: PUSH
34348: LD_EXP 115
34352: PPUSH
34353: LD_VAR 0 1
34357: PPUSH
34358: EMPTY
34359: PPUSH
34360: CALL_OW 1
34364: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34365: LD_ADDR_EXP 116
34369: PUSH
34370: LD_EXP 116
34374: PPUSH
34375: LD_VAR 0 1
34379: PPUSH
34380: EMPTY
34381: PPUSH
34382: CALL_OW 1
34386: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34387: LD_ADDR_EXP 117
34391: PUSH
34392: LD_EXP 117
34396: PPUSH
34397: LD_VAR 0 1
34401: PPUSH
34402: EMPTY
34403: PPUSH
34404: CALL_OW 1
34408: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34409: LD_ADDR_EXP 118
34413: PUSH
34414: LD_EXP 118
34418: PPUSH
34419: LD_VAR 0 1
34423: PPUSH
34424: EMPTY
34425: PPUSH
34426: CALL_OW 1
34430: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34431: LD_ADDR_EXP 119
34435: PUSH
34436: LD_EXP 119
34440: PPUSH
34441: LD_VAR 0 1
34445: PPUSH
34446: EMPTY
34447: PPUSH
34448: CALL_OW 1
34452: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34453: LD_ADDR_EXP 120
34457: PUSH
34458: LD_EXP 120
34462: PPUSH
34463: LD_VAR 0 1
34467: PPUSH
34468: EMPTY
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34475: LD_ADDR_EXP 121
34479: PUSH
34480: LD_EXP 121
34484: PPUSH
34485: LD_VAR 0 1
34489: PPUSH
34490: EMPTY
34491: PPUSH
34492: CALL_OW 1
34496: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34497: LD_ADDR_EXP 122
34501: PUSH
34502: LD_EXP 122
34506: PPUSH
34507: LD_VAR 0 1
34511: PPUSH
34512: EMPTY
34513: PPUSH
34514: CALL_OW 1
34518: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34519: LD_ADDR_EXP 123
34523: PUSH
34524: LD_EXP 123
34528: PPUSH
34529: LD_VAR 0 1
34533: PPUSH
34534: EMPTY
34535: PPUSH
34536: CALL_OW 1
34540: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34541: LD_ADDR_EXP 124
34545: PUSH
34546: LD_EXP 124
34550: PPUSH
34551: LD_VAR 0 1
34555: PPUSH
34556: EMPTY
34557: PPUSH
34558: CALL_OW 1
34562: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34563: LD_ADDR_EXP 126
34567: PUSH
34568: LD_EXP 126
34572: PPUSH
34573: LD_VAR 0 1
34577: PPUSH
34578: EMPTY
34579: PPUSH
34580: CALL_OW 1
34584: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34585: LD_ADDR_EXP 128
34589: PUSH
34590: LD_EXP 128
34594: PPUSH
34595: LD_VAR 0 1
34599: PPUSH
34600: EMPTY
34601: PPUSH
34602: CALL_OW 1
34606: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34607: LD_ADDR_EXP 129
34611: PUSH
34612: LD_EXP 129
34616: PPUSH
34617: LD_VAR 0 1
34621: PPUSH
34622: EMPTY
34623: PPUSH
34624: CALL_OW 1
34628: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34629: LD_ADDR_EXP 130
34633: PUSH
34634: LD_EXP 130
34638: PPUSH
34639: LD_VAR 0 1
34643: PPUSH
34644: EMPTY
34645: PPUSH
34646: CALL_OW 1
34650: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34651: LD_ADDR_EXP 131
34655: PUSH
34656: LD_EXP 131
34660: PPUSH
34661: LD_VAR 0 1
34665: PPUSH
34666: EMPTY
34667: PPUSH
34668: CALL_OW 1
34672: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34673: LD_ADDR_EXP 132
34677: PUSH
34678: LD_EXP 132
34682: PPUSH
34683: LD_VAR 0 1
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL_OW 1
34694: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34695: LD_ADDR_EXP 133
34699: PUSH
34700: LD_EXP 133
34704: PPUSH
34705: LD_VAR 0 1
34709: PPUSH
34710: EMPTY
34711: PPUSH
34712: CALL_OW 1
34716: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34717: LD_ADDR_EXP 134
34721: PUSH
34722: LD_EXP 134
34726: PPUSH
34727: LD_VAR 0 1
34731: PPUSH
34732: EMPTY
34733: PPUSH
34734: CALL_OW 1
34738: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34739: LD_ADDR_EXP 135
34743: PUSH
34744: LD_EXP 135
34748: PPUSH
34749: LD_VAR 0 1
34753: PPUSH
34754: EMPTY
34755: PPUSH
34756: CALL_OW 1
34760: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34761: LD_ADDR_EXP 136
34765: PUSH
34766: LD_EXP 136
34770: PPUSH
34771: LD_VAR 0 1
34775: PPUSH
34776: EMPTY
34777: PPUSH
34778: CALL_OW 1
34782: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34783: LD_ADDR_EXP 137
34787: PUSH
34788: LD_EXP 137
34792: PPUSH
34793: LD_VAR 0 1
34797: PPUSH
34798: EMPTY
34799: PPUSH
34800: CALL_OW 1
34804: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34805: LD_ADDR_EXP 138
34809: PUSH
34810: LD_EXP 138
34814: PPUSH
34815: LD_VAR 0 1
34819: PPUSH
34820: EMPTY
34821: PPUSH
34822: CALL_OW 1
34826: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34827: LD_ADDR_EXP 139
34831: PUSH
34832: LD_EXP 139
34836: PPUSH
34837: LD_VAR 0 1
34841: PPUSH
34842: EMPTY
34843: PPUSH
34844: CALL_OW 1
34848: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34849: LD_ADDR_EXP 140
34853: PUSH
34854: LD_EXP 140
34858: PPUSH
34859: LD_VAR 0 1
34863: PPUSH
34864: EMPTY
34865: PPUSH
34866: CALL_OW 1
34870: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34871: LD_ADDR_EXP 141
34875: PUSH
34876: LD_EXP 141
34880: PPUSH
34881: LD_VAR 0 1
34885: PPUSH
34886: LD_INT 0
34888: PPUSH
34889: CALL_OW 1
34893: ST_TO_ADDR
// end ;
34894: LD_VAR 0 2
34898: RET
// export function MC_Add ( side , units ) ; var base ; begin
34899: LD_INT 0
34901: PPUSH
34902: PPUSH
// base := mc_bases + 1 ;
34903: LD_ADDR_VAR 0 4
34907: PUSH
34908: LD_EXP 99
34912: PUSH
34913: LD_INT 1
34915: PLUS
34916: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34917: LD_ADDR_EXP 125
34921: PUSH
34922: LD_EXP 125
34926: PPUSH
34927: LD_VAR 0 4
34931: PPUSH
34932: LD_VAR 0 1
34936: PPUSH
34937: CALL_OW 1
34941: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34942: LD_ADDR_EXP 99
34946: PUSH
34947: LD_EXP 99
34951: PPUSH
34952: LD_VAR 0 4
34956: PPUSH
34957: LD_VAR 0 2
34961: PPUSH
34962: CALL_OW 1
34966: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34967: LD_ADDR_EXP 100
34971: PUSH
34972: LD_EXP 100
34976: PPUSH
34977: LD_VAR 0 4
34981: PPUSH
34982: EMPTY
34983: PPUSH
34984: CALL_OW 1
34988: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34989: LD_ADDR_EXP 101
34993: PUSH
34994: LD_EXP 101
34998: PPUSH
34999: LD_VAR 0 4
35003: PPUSH
35004: EMPTY
35005: PPUSH
35006: CALL_OW 1
35010: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35011: LD_ADDR_EXP 102
35015: PUSH
35016: LD_EXP 102
35020: PPUSH
35021: LD_VAR 0 4
35025: PPUSH
35026: EMPTY
35027: PPUSH
35028: CALL_OW 1
35032: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35033: LD_ADDR_EXP 103
35037: PUSH
35038: LD_EXP 103
35042: PPUSH
35043: LD_VAR 0 4
35047: PPUSH
35048: EMPTY
35049: PPUSH
35050: CALL_OW 1
35054: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35055: LD_ADDR_EXP 104
35059: PUSH
35060: LD_EXP 104
35064: PPUSH
35065: LD_VAR 0 4
35069: PPUSH
35070: EMPTY
35071: PPUSH
35072: CALL_OW 1
35076: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35077: LD_ADDR_EXP 105
35081: PUSH
35082: LD_EXP 105
35086: PPUSH
35087: LD_VAR 0 4
35091: PPUSH
35092: EMPTY
35093: PPUSH
35094: CALL_OW 1
35098: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35099: LD_ADDR_EXP 106
35103: PUSH
35104: LD_EXP 106
35108: PPUSH
35109: LD_VAR 0 4
35113: PPUSH
35114: EMPTY
35115: PPUSH
35116: CALL_OW 1
35120: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35121: LD_ADDR_EXP 107
35125: PUSH
35126: LD_EXP 107
35130: PPUSH
35131: LD_VAR 0 4
35135: PPUSH
35136: EMPTY
35137: PPUSH
35138: CALL_OW 1
35142: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35143: LD_ADDR_EXP 108
35147: PUSH
35148: LD_EXP 108
35152: PPUSH
35153: LD_VAR 0 4
35157: PPUSH
35158: EMPTY
35159: PPUSH
35160: CALL_OW 1
35164: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35165: LD_ADDR_EXP 109
35169: PUSH
35170: LD_EXP 109
35174: PPUSH
35175: LD_VAR 0 4
35179: PPUSH
35180: EMPTY
35181: PPUSH
35182: CALL_OW 1
35186: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35187: LD_ADDR_EXP 110
35191: PUSH
35192: LD_EXP 110
35196: PPUSH
35197: LD_VAR 0 4
35201: PPUSH
35202: LD_INT 0
35204: PPUSH
35205: CALL_OW 1
35209: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35210: LD_ADDR_EXP 111
35214: PUSH
35215: LD_EXP 111
35219: PPUSH
35220: LD_VAR 0 4
35224: PPUSH
35225: EMPTY
35226: PPUSH
35227: CALL_OW 1
35231: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35232: LD_ADDR_EXP 112
35236: PUSH
35237: LD_EXP 112
35241: PPUSH
35242: LD_VAR 0 4
35246: PPUSH
35247: EMPTY
35248: PPUSH
35249: CALL_OW 1
35253: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35254: LD_ADDR_EXP 113
35258: PUSH
35259: LD_EXP 113
35263: PPUSH
35264: LD_VAR 0 4
35268: PPUSH
35269: EMPTY
35270: PPUSH
35271: CALL_OW 1
35275: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35276: LD_ADDR_EXP 114
35280: PUSH
35281: LD_EXP 114
35285: PPUSH
35286: LD_VAR 0 4
35290: PPUSH
35291: EMPTY
35292: PPUSH
35293: CALL_OW 1
35297: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35298: LD_ADDR_EXP 115
35302: PUSH
35303: LD_EXP 115
35307: PPUSH
35308: LD_VAR 0 4
35312: PPUSH
35313: EMPTY
35314: PPUSH
35315: CALL_OW 1
35319: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35320: LD_ADDR_EXP 116
35324: PUSH
35325: LD_EXP 116
35329: PPUSH
35330: LD_VAR 0 4
35334: PPUSH
35335: EMPTY
35336: PPUSH
35337: CALL_OW 1
35341: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35342: LD_ADDR_EXP 117
35346: PUSH
35347: LD_EXP 117
35351: PPUSH
35352: LD_VAR 0 4
35356: PPUSH
35357: EMPTY
35358: PPUSH
35359: CALL_OW 1
35363: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35364: LD_ADDR_EXP 118
35368: PUSH
35369: LD_EXP 118
35373: PPUSH
35374: LD_VAR 0 4
35378: PPUSH
35379: EMPTY
35380: PPUSH
35381: CALL_OW 1
35385: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35386: LD_ADDR_EXP 119
35390: PUSH
35391: LD_EXP 119
35395: PPUSH
35396: LD_VAR 0 4
35400: PPUSH
35401: EMPTY
35402: PPUSH
35403: CALL_OW 1
35407: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35408: LD_ADDR_EXP 120
35412: PUSH
35413: LD_EXP 120
35417: PPUSH
35418: LD_VAR 0 4
35422: PPUSH
35423: EMPTY
35424: PPUSH
35425: CALL_OW 1
35429: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35430: LD_ADDR_EXP 121
35434: PUSH
35435: LD_EXP 121
35439: PPUSH
35440: LD_VAR 0 4
35444: PPUSH
35445: EMPTY
35446: PPUSH
35447: CALL_OW 1
35451: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35452: LD_ADDR_EXP 122
35456: PUSH
35457: LD_EXP 122
35461: PPUSH
35462: LD_VAR 0 4
35466: PPUSH
35467: EMPTY
35468: PPUSH
35469: CALL_OW 1
35473: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35474: LD_ADDR_EXP 123
35478: PUSH
35479: LD_EXP 123
35483: PPUSH
35484: LD_VAR 0 4
35488: PPUSH
35489: EMPTY
35490: PPUSH
35491: CALL_OW 1
35495: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35496: LD_ADDR_EXP 124
35500: PUSH
35501: LD_EXP 124
35505: PPUSH
35506: LD_VAR 0 4
35510: PPUSH
35511: EMPTY
35512: PPUSH
35513: CALL_OW 1
35517: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35518: LD_ADDR_EXP 126
35522: PUSH
35523: LD_EXP 126
35527: PPUSH
35528: LD_VAR 0 4
35532: PPUSH
35533: EMPTY
35534: PPUSH
35535: CALL_OW 1
35539: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35540: LD_ADDR_EXP 128
35544: PUSH
35545: LD_EXP 128
35549: PPUSH
35550: LD_VAR 0 4
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35562: LD_ADDR_EXP 129
35566: PUSH
35567: LD_EXP 129
35571: PPUSH
35572: LD_VAR 0 4
35576: PPUSH
35577: EMPTY
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35584: LD_ADDR_EXP 130
35588: PUSH
35589: LD_EXP 130
35593: PPUSH
35594: LD_VAR 0 4
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35606: LD_ADDR_EXP 131
35610: PUSH
35611: LD_EXP 131
35615: PPUSH
35616: LD_VAR 0 4
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35628: LD_ADDR_EXP 132
35632: PUSH
35633: LD_EXP 132
35637: PPUSH
35638: LD_VAR 0 4
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35650: LD_ADDR_EXP 133
35654: PUSH
35655: LD_EXP 133
35659: PPUSH
35660: LD_VAR 0 4
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35672: LD_ADDR_EXP 134
35676: PUSH
35677: LD_EXP 134
35681: PPUSH
35682: LD_VAR 0 4
35686: PPUSH
35687: EMPTY
35688: PPUSH
35689: CALL_OW 1
35693: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35694: LD_ADDR_EXP 135
35698: PUSH
35699: LD_EXP 135
35703: PPUSH
35704: LD_VAR 0 4
35708: PPUSH
35709: EMPTY
35710: PPUSH
35711: CALL_OW 1
35715: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35716: LD_ADDR_EXP 136
35720: PUSH
35721: LD_EXP 136
35725: PPUSH
35726: LD_VAR 0 4
35730: PPUSH
35731: EMPTY
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35738: LD_ADDR_EXP 137
35742: PUSH
35743: LD_EXP 137
35747: PPUSH
35748: LD_VAR 0 4
35752: PPUSH
35753: EMPTY
35754: PPUSH
35755: CALL_OW 1
35759: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35760: LD_ADDR_EXP 138
35764: PUSH
35765: LD_EXP 138
35769: PPUSH
35770: LD_VAR 0 4
35774: PPUSH
35775: EMPTY
35776: PPUSH
35777: CALL_OW 1
35781: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35782: LD_ADDR_EXP 139
35786: PUSH
35787: LD_EXP 139
35791: PPUSH
35792: LD_VAR 0 4
35796: PPUSH
35797: EMPTY
35798: PPUSH
35799: CALL_OW 1
35803: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35804: LD_ADDR_EXP 140
35808: PUSH
35809: LD_EXP 140
35813: PPUSH
35814: LD_VAR 0 4
35818: PPUSH
35819: EMPTY
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35826: LD_ADDR_EXP 141
35830: PUSH
35831: LD_EXP 141
35835: PPUSH
35836: LD_VAR 0 4
35840: PPUSH
35841: LD_INT 0
35843: PPUSH
35844: CALL_OW 1
35848: ST_TO_ADDR
// result := base ;
35849: LD_ADDR_VAR 0 3
35853: PUSH
35854: LD_VAR 0 4
35858: ST_TO_ADDR
// end ;
35859: LD_VAR 0 3
35863: RET
// export function MC_Start ( ) ; var i ; begin
35864: LD_INT 0
35866: PPUSH
35867: PPUSH
// for i = 1 to mc_bases do
35868: LD_ADDR_VAR 0 2
35872: PUSH
35873: DOUBLE
35874: LD_INT 1
35876: DEC
35877: ST_TO_ADDR
35878: LD_EXP 99
35882: PUSH
35883: FOR_TO
35884: IFFALSE 36961
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35886: LD_ADDR_EXP 99
35890: PUSH
35891: LD_EXP 99
35895: PPUSH
35896: LD_VAR 0 2
35900: PPUSH
35901: LD_EXP 99
35905: PUSH
35906: LD_VAR 0 2
35910: ARRAY
35911: PUSH
35912: LD_INT 0
35914: DIFF
35915: PPUSH
35916: CALL_OW 1
35920: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35921: LD_ADDR_EXP 100
35925: PUSH
35926: LD_EXP 100
35930: PPUSH
35931: LD_VAR 0 2
35935: PPUSH
35936: EMPTY
35937: PPUSH
35938: CALL_OW 1
35942: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35943: LD_ADDR_EXP 101
35947: PUSH
35948: LD_EXP 101
35952: PPUSH
35953: LD_VAR 0 2
35957: PPUSH
35958: EMPTY
35959: PPUSH
35960: CALL_OW 1
35964: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35965: LD_ADDR_EXP 102
35969: PUSH
35970: LD_EXP 102
35974: PPUSH
35975: LD_VAR 0 2
35979: PPUSH
35980: EMPTY
35981: PPUSH
35982: CALL_OW 1
35986: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
35987: LD_ADDR_EXP 103
35991: PUSH
35992: LD_EXP 103
35996: PPUSH
35997: LD_VAR 0 2
36001: PPUSH
36002: EMPTY
36003: PUSH
36004: EMPTY
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PPUSH
36010: CALL_OW 1
36014: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36015: LD_ADDR_EXP 104
36019: PUSH
36020: LD_EXP 104
36024: PPUSH
36025: LD_VAR 0 2
36029: PPUSH
36030: EMPTY
36031: PPUSH
36032: CALL_OW 1
36036: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36037: LD_ADDR_EXP 131
36041: PUSH
36042: LD_EXP 131
36046: PPUSH
36047: LD_VAR 0 2
36051: PPUSH
36052: EMPTY
36053: PPUSH
36054: CALL_OW 1
36058: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36059: LD_ADDR_EXP 105
36063: PUSH
36064: LD_EXP 105
36068: PPUSH
36069: LD_VAR 0 2
36073: PPUSH
36074: EMPTY
36075: PPUSH
36076: CALL_OW 1
36080: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36081: LD_ADDR_EXP 106
36085: PUSH
36086: LD_EXP 106
36090: PPUSH
36091: LD_VAR 0 2
36095: PPUSH
36096: EMPTY
36097: PPUSH
36098: CALL_OW 1
36102: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36103: LD_ADDR_EXP 107
36107: PUSH
36108: LD_EXP 107
36112: PPUSH
36113: LD_VAR 0 2
36117: PPUSH
36118: LD_EXP 99
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: PPUSH
36129: LD_INT 2
36131: PUSH
36132: LD_INT 30
36134: PUSH
36135: LD_INT 32
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 30
36144: PUSH
36145: LD_INT 33
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: LIST
36156: PPUSH
36157: CALL_OW 72
36161: PPUSH
36162: CALL_OW 1
36166: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36167: LD_ADDR_EXP 108
36171: PUSH
36172: LD_EXP 108
36176: PPUSH
36177: LD_VAR 0 2
36181: PPUSH
36182: LD_EXP 99
36186: PUSH
36187: LD_VAR 0 2
36191: ARRAY
36192: PPUSH
36193: LD_INT 2
36195: PUSH
36196: LD_INT 30
36198: PUSH
36199: LD_INT 32
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 30
36208: PUSH
36209: LD_INT 31
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: LIST
36220: PUSH
36221: LD_INT 58
36223: PUSH
36224: EMPTY
36225: LIST
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PPUSH
36231: CALL_OW 72
36235: PPUSH
36236: CALL_OW 1
36240: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36241: LD_ADDR_EXP 109
36245: PUSH
36246: LD_EXP 109
36250: PPUSH
36251: LD_VAR 0 2
36255: PPUSH
36256: EMPTY
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36263: LD_ADDR_EXP 113
36267: PUSH
36268: LD_EXP 113
36272: PPUSH
36273: LD_VAR 0 2
36277: PPUSH
36278: EMPTY
36279: PPUSH
36280: CALL_OW 1
36284: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36285: LD_ADDR_EXP 112
36289: PUSH
36290: LD_EXP 112
36294: PPUSH
36295: LD_VAR 0 2
36299: PPUSH
36300: EMPTY
36301: PPUSH
36302: CALL_OW 1
36306: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36307: LD_ADDR_EXP 114
36311: PUSH
36312: LD_EXP 114
36316: PPUSH
36317: LD_VAR 0 2
36321: PPUSH
36322: EMPTY
36323: PPUSH
36324: CALL_OW 1
36328: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36329: LD_ADDR_EXP 115
36333: PUSH
36334: LD_EXP 115
36338: PPUSH
36339: LD_VAR 0 2
36343: PPUSH
36344: EMPTY
36345: PPUSH
36346: CALL_OW 1
36350: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36351: LD_ADDR_EXP 116
36355: PUSH
36356: LD_EXP 116
36360: PPUSH
36361: LD_VAR 0 2
36365: PPUSH
36366: EMPTY
36367: PPUSH
36368: CALL_OW 1
36372: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36373: LD_ADDR_EXP 117
36377: PUSH
36378: LD_EXP 117
36382: PPUSH
36383: LD_VAR 0 2
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL_OW 1
36394: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36395: LD_ADDR_EXP 118
36399: PUSH
36400: LD_EXP 118
36404: PPUSH
36405: LD_VAR 0 2
36409: PPUSH
36410: EMPTY
36411: PPUSH
36412: CALL_OW 1
36416: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36417: LD_ADDR_EXP 119
36421: PUSH
36422: LD_EXP 119
36426: PPUSH
36427: LD_VAR 0 2
36431: PPUSH
36432: EMPTY
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36439: LD_ADDR_EXP 120
36443: PUSH
36444: LD_EXP 120
36448: PPUSH
36449: LD_VAR 0 2
36453: PPUSH
36454: EMPTY
36455: PPUSH
36456: CALL_OW 1
36460: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36461: LD_ADDR_EXP 121
36465: PUSH
36466: LD_EXP 121
36470: PPUSH
36471: LD_VAR 0 2
36475: PPUSH
36476: EMPTY
36477: PPUSH
36478: CALL_OW 1
36482: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36483: LD_ADDR_EXP 110
36487: PUSH
36488: LD_EXP 110
36492: PPUSH
36493: LD_VAR 0 2
36497: PPUSH
36498: LD_INT 0
36500: PPUSH
36501: CALL_OW 1
36505: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36506: LD_ADDR_EXP 123
36510: PUSH
36511: LD_EXP 123
36515: PPUSH
36516: LD_VAR 0 2
36520: PPUSH
36521: LD_INT 0
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36529: LD_ADDR_EXP 111
36533: PUSH
36534: LD_EXP 111
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36551: LD_ADDR_EXP 122
36555: PUSH
36556: LD_EXP 122
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: LD_INT 0
36568: PPUSH
36569: CALL_OW 1
36573: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36574: LD_ADDR_EXP 124
36578: PUSH
36579: LD_EXP 124
36583: PPUSH
36584: LD_VAR 0 2
36588: PPUSH
36589: EMPTY
36590: PPUSH
36591: CALL_OW 1
36595: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36596: LD_ADDR_EXP 127
36600: PUSH
36601: LD_EXP 127
36605: PPUSH
36606: LD_VAR 0 2
36610: PPUSH
36611: LD_INT 0
36613: PPUSH
36614: CALL_OW 1
36618: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36619: LD_ADDR_EXP 128
36623: PUSH
36624: LD_EXP 128
36628: PPUSH
36629: LD_VAR 0 2
36633: PPUSH
36634: EMPTY
36635: PPUSH
36636: CALL_OW 1
36640: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36641: LD_ADDR_EXP 129
36645: PUSH
36646: LD_EXP 129
36650: PPUSH
36651: LD_VAR 0 2
36655: PPUSH
36656: EMPTY
36657: PPUSH
36658: CALL_OW 1
36662: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36663: LD_ADDR_EXP 130
36667: PUSH
36668: LD_EXP 130
36672: PPUSH
36673: LD_VAR 0 2
36677: PPUSH
36678: EMPTY
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36685: LD_ADDR_EXP 132
36689: PUSH
36690: LD_EXP 132
36694: PPUSH
36695: LD_VAR 0 2
36699: PPUSH
36700: LD_EXP 99
36704: PUSH
36705: LD_VAR 0 2
36709: ARRAY
36710: PPUSH
36711: LD_INT 2
36713: PUSH
36714: LD_INT 30
36716: PUSH
36717: LD_INT 6
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 30
36726: PUSH
36727: LD_INT 7
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 30
36736: PUSH
36737: LD_INT 8
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: PPUSH
36750: CALL_OW 72
36754: PPUSH
36755: CALL_OW 1
36759: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36760: LD_ADDR_EXP 133
36764: PUSH
36765: LD_EXP 133
36769: PPUSH
36770: LD_VAR 0 2
36774: PPUSH
36775: EMPTY
36776: PPUSH
36777: CALL_OW 1
36781: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36782: LD_ADDR_EXP 134
36786: PUSH
36787: LD_EXP 134
36791: PPUSH
36792: LD_VAR 0 2
36796: PPUSH
36797: EMPTY
36798: PPUSH
36799: CALL_OW 1
36803: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36804: LD_ADDR_EXP 135
36808: PUSH
36809: LD_EXP 135
36813: PPUSH
36814: LD_VAR 0 2
36818: PPUSH
36819: EMPTY
36820: PPUSH
36821: CALL_OW 1
36825: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36826: LD_ADDR_EXP 136
36830: PUSH
36831: LD_EXP 136
36835: PPUSH
36836: LD_VAR 0 2
36840: PPUSH
36841: EMPTY
36842: PPUSH
36843: CALL_OW 1
36847: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36848: LD_ADDR_EXP 137
36852: PUSH
36853: LD_EXP 137
36857: PPUSH
36858: LD_VAR 0 2
36862: PPUSH
36863: EMPTY
36864: PPUSH
36865: CALL_OW 1
36869: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36870: LD_ADDR_EXP 138
36874: PUSH
36875: LD_EXP 138
36879: PPUSH
36880: LD_VAR 0 2
36884: PPUSH
36885: EMPTY
36886: PPUSH
36887: CALL_OW 1
36891: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36892: LD_ADDR_EXP 139
36896: PUSH
36897: LD_EXP 139
36901: PPUSH
36902: LD_VAR 0 2
36906: PPUSH
36907: EMPTY
36908: PPUSH
36909: CALL_OW 1
36913: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36914: LD_ADDR_EXP 140
36918: PUSH
36919: LD_EXP 140
36923: PPUSH
36924: LD_VAR 0 2
36928: PPUSH
36929: EMPTY
36930: PPUSH
36931: CALL_OW 1
36935: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36936: LD_ADDR_EXP 141
36940: PUSH
36941: LD_EXP 141
36945: PPUSH
36946: LD_VAR 0 2
36950: PPUSH
36951: LD_INT 0
36953: PPUSH
36954: CALL_OW 1
36958: ST_TO_ADDR
// end ;
36959: GO 35883
36961: POP
36962: POP
// MC_InitSides ( ) ;
36963: CALL 37249 0 0
// MC_InitResearch ( ) ;
36967: CALL 36988 0 0
// CustomInitMacro ( ) ;
36971: CALL 444 0 0
// skirmish := true ;
36975: LD_ADDR_EXP 97
36979: PUSH
36980: LD_INT 1
36982: ST_TO_ADDR
// end ;
36983: LD_VAR 0 1
36987: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
36988: LD_INT 0
36990: PPUSH
36991: PPUSH
36992: PPUSH
36993: PPUSH
36994: PPUSH
36995: PPUSH
// if not mc_bases then
36996: LD_EXP 99
37000: NOT
37001: IFFALSE 37005
// exit ;
37003: GO 37244
// for i = 1 to 8 do
37005: LD_ADDR_VAR 0 2
37009: PUSH
37010: DOUBLE
37011: LD_INT 1
37013: DEC
37014: ST_TO_ADDR
37015: LD_INT 8
37017: PUSH
37018: FOR_TO
37019: IFFALSE 37045
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37021: LD_ADDR_EXP 126
37025: PUSH
37026: LD_EXP 126
37030: PPUSH
37031: LD_VAR 0 2
37035: PPUSH
37036: EMPTY
37037: PPUSH
37038: CALL_OW 1
37042: ST_TO_ADDR
37043: GO 37018
37045: POP
37046: POP
// tmp := [ ] ;
37047: LD_ADDR_VAR 0 5
37051: PUSH
37052: EMPTY
37053: ST_TO_ADDR
// for i = 1 to mc_sides do
37054: LD_ADDR_VAR 0 2
37058: PUSH
37059: DOUBLE
37060: LD_INT 1
37062: DEC
37063: ST_TO_ADDR
37064: LD_EXP 125
37068: PUSH
37069: FOR_TO
37070: IFFALSE 37128
// if not mc_sides [ i ] in tmp then
37072: LD_EXP 125
37076: PUSH
37077: LD_VAR 0 2
37081: ARRAY
37082: PUSH
37083: LD_VAR 0 5
37087: IN
37088: NOT
37089: IFFALSE 37126
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37091: LD_ADDR_VAR 0 5
37095: PUSH
37096: LD_VAR 0 5
37100: PPUSH
37101: LD_VAR 0 5
37105: PUSH
37106: LD_INT 1
37108: PLUS
37109: PPUSH
37110: LD_EXP 125
37114: PUSH
37115: LD_VAR 0 2
37119: ARRAY
37120: PPUSH
37121: CALL_OW 2
37125: ST_TO_ADDR
37126: GO 37069
37128: POP
37129: POP
// if not tmp then
37130: LD_VAR 0 5
37134: NOT
37135: IFFALSE 37139
// exit ;
37137: GO 37244
// for j in tmp do
37139: LD_ADDR_VAR 0 3
37143: PUSH
37144: LD_VAR 0 5
37148: PUSH
37149: FOR_IN
37150: IFFALSE 37242
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37152: LD_ADDR_VAR 0 6
37156: PUSH
37157: LD_INT 22
37159: PUSH
37160: LD_VAR 0 3
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PPUSH
37169: CALL_OW 69
37173: ST_TO_ADDR
// if not un then
37174: LD_VAR 0 6
37178: NOT
37179: IFFALSE 37183
// continue ;
37181: GO 37149
// nation := GetNation ( un [ 1 ] ) ;
37183: LD_ADDR_VAR 0 4
37187: PUSH
37188: LD_VAR 0 6
37192: PUSH
37193: LD_INT 1
37195: ARRAY
37196: PPUSH
37197: CALL_OW 248
37201: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37202: LD_ADDR_EXP 126
37206: PUSH
37207: LD_EXP 126
37211: PPUSH
37212: LD_VAR 0 3
37216: PPUSH
37217: LD_VAR 0 3
37221: PPUSH
37222: LD_VAR 0 4
37226: PPUSH
37227: LD_INT 1
37229: PPUSH
37230: CALL 63038 0 3
37234: PPUSH
37235: CALL_OW 1
37239: ST_TO_ADDR
// end ;
37240: GO 37149
37242: POP
37243: POP
// end ;
37244: LD_VAR 0 1
37248: RET
// export function MC_InitSides ( ) ; var i ; begin
37249: LD_INT 0
37251: PPUSH
37252: PPUSH
// if not mc_bases then
37253: LD_EXP 99
37257: NOT
37258: IFFALSE 37262
// exit ;
37260: GO 37336
// for i = 1 to mc_bases do
37262: LD_ADDR_VAR 0 2
37266: PUSH
37267: DOUBLE
37268: LD_INT 1
37270: DEC
37271: ST_TO_ADDR
37272: LD_EXP 99
37276: PUSH
37277: FOR_TO
37278: IFFALSE 37334
// if mc_bases [ i ] then
37280: LD_EXP 99
37284: PUSH
37285: LD_VAR 0 2
37289: ARRAY
37290: IFFALSE 37332
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37292: LD_ADDR_EXP 125
37296: PUSH
37297: LD_EXP 125
37301: PPUSH
37302: LD_VAR 0 2
37306: PPUSH
37307: LD_EXP 99
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PUSH
37318: LD_INT 1
37320: ARRAY
37321: PPUSH
37322: CALL_OW 255
37326: PPUSH
37327: CALL_OW 1
37331: ST_TO_ADDR
37332: GO 37277
37334: POP
37335: POP
// end ;
37336: LD_VAR 0 1
37340: RET
// every 0 0$01 trigger skirmish do
37341: LD_EXP 97
37345: IFFALSE 37499
37347: GO 37349
37349: DISABLE
// begin enable ;
37350: ENABLE
// MC_CheckBuildings ( ) ;
37351: CALL 41988 0 0
// MC_CheckPeopleLife ( ) ;
37355: CALL 42113 0 0
// RaiseSailEvent ( 100 ) ;
37359: LD_INT 100
37361: PPUSH
37362: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37366: LD_INT 103
37368: PPUSH
37369: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37373: LD_INT 104
37375: PPUSH
37376: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37380: LD_INT 105
37382: PPUSH
37383: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37387: LD_INT 106
37389: PPUSH
37390: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37394: LD_INT 107
37396: PPUSH
37397: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37401: LD_INT 108
37403: PPUSH
37404: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37408: LD_INT 109
37410: PPUSH
37411: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37415: LD_INT 110
37417: PPUSH
37418: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37422: LD_INT 111
37424: PPUSH
37425: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37429: LD_INT 112
37431: PPUSH
37432: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37436: LD_INT 113
37438: PPUSH
37439: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37443: LD_INT 120
37445: PPUSH
37446: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37450: LD_INT 121
37452: PPUSH
37453: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37457: LD_INT 122
37459: PPUSH
37460: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37464: LD_INT 123
37466: PPUSH
37467: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37471: LD_INT 124
37473: PPUSH
37474: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37478: LD_INT 125
37480: PPUSH
37481: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37485: LD_INT 126
37487: PPUSH
37488: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37492: LD_INT 200
37494: PPUSH
37495: CALL_OW 427
// end ;
37499: END
// on SailEvent ( event ) do begin if event < 100 then
37500: LD_VAR 0 1
37504: PUSH
37505: LD_INT 100
37507: LESS
37508: IFFALSE 37519
// CustomEvent ( event ) ;
37510: LD_VAR 0 1
37514: PPUSH
37515: CALL 32182 0 1
// if event = 100 then
37519: LD_VAR 0 1
37523: PUSH
37524: LD_INT 100
37526: EQUAL
37527: IFFALSE 37533
// MC_ClassManager ( ) ;
37529: CALL 37925 0 0
// if event = 101 then
37533: LD_VAR 0 1
37537: PUSH
37538: LD_INT 101
37540: EQUAL
37541: IFFALSE 37547
// MC_RepairBuildings ( ) ;
37543: CALL 42709 0 0
// if event = 102 then
37547: LD_VAR 0 1
37551: PUSH
37552: LD_INT 102
37554: EQUAL
37555: IFFALSE 37561
// MC_Heal ( ) ;
37557: CALL 43115 0 0
// if event = 103 then
37561: LD_VAR 0 1
37565: PUSH
37566: LD_INT 103
37568: EQUAL
37569: IFFALSE 37575
// MC_Build ( ) ;
37571: CALL 43537 0 0
// if event = 104 then
37575: LD_VAR 0 1
37579: PUSH
37580: LD_INT 104
37582: EQUAL
37583: IFFALSE 37589
// MC_TurretWeapon ( ) ;
37585: CALL 45150 0 0
// if event = 105 then
37589: LD_VAR 0 1
37593: PUSH
37594: LD_INT 105
37596: EQUAL
37597: IFFALSE 37603
// MC_BuildUpgrade ( ) ;
37599: CALL 44701 0 0
// if event = 106 then
37603: LD_VAR 0 1
37607: PUSH
37608: LD_INT 106
37610: EQUAL
37611: IFFALSE 37617
// MC_PlantMines ( ) ;
37613: CALL 45580 0 0
// if event = 107 then
37617: LD_VAR 0 1
37621: PUSH
37622: LD_INT 107
37624: EQUAL
37625: IFFALSE 37631
// MC_CollectCrates ( ) ;
37627: CALL 46614 0 0
// if event = 108 then
37631: LD_VAR 0 1
37635: PUSH
37636: LD_INT 108
37638: EQUAL
37639: IFFALSE 37645
// MC_LinkRemoteControl ( ) ;
37641: CALL 48371 0 0
// if event = 109 then
37645: LD_VAR 0 1
37649: PUSH
37650: LD_INT 109
37652: EQUAL
37653: IFFALSE 37659
// MC_ProduceVehicle ( ) ;
37655: CALL 48552 0 0
// if event = 110 then
37659: LD_VAR 0 1
37663: PUSH
37664: LD_INT 110
37666: EQUAL
37667: IFFALSE 37673
// MC_SendAttack ( ) ;
37669: CALL 49033 0 0
// if event = 111 then
37673: LD_VAR 0 1
37677: PUSH
37678: LD_INT 111
37680: EQUAL
37681: IFFALSE 37687
// MC_Defend ( ) ;
37683: CALL 49141 0 0
// if event = 112 then
37687: LD_VAR 0 1
37691: PUSH
37692: LD_INT 112
37694: EQUAL
37695: IFFALSE 37701
// MC_Research ( ) ;
37697: CALL 49746 0 0
// if event = 113 then
37701: LD_VAR 0 1
37705: PUSH
37706: LD_INT 113
37708: EQUAL
37709: IFFALSE 37715
// MC_MinesTrigger ( ) ;
37711: CALL 50860 0 0
// if event = 120 then
37715: LD_VAR 0 1
37719: PUSH
37720: LD_INT 120
37722: EQUAL
37723: IFFALSE 37729
// MC_RepairVehicle ( ) ;
37725: CALL 50959 0 0
// if event = 121 then
37729: LD_VAR 0 1
37733: PUSH
37734: LD_INT 121
37736: EQUAL
37737: IFFALSE 37743
// MC_TameApe ( ) ;
37739: CALL 51666 0 0
// if event = 122 then
37743: LD_VAR 0 1
37747: PUSH
37748: LD_INT 122
37750: EQUAL
37751: IFFALSE 37757
// MC_ChangeApeClass ( ) ;
37753: CALL 52495 0 0
// if event = 123 then
37757: LD_VAR 0 1
37761: PUSH
37762: LD_INT 123
37764: EQUAL
37765: IFFALSE 37771
// MC_Bazooka ( ) ;
37767: CALL 53145 0 0
// if event = 124 then
37771: LD_VAR 0 1
37775: PUSH
37776: LD_INT 124
37778: EQUAL
37779: IFFALSE 37785
// MC_TeleportExit ( ) ;
37781: CALL 53343 0 0
// if event = 125 then
37785: LD_VAR 0 1
37789: PUSH
37790: LD_INT 125
37792: EQUAL
37793: IFFALSE 37799
// MC_Deposits ( ) ;
37795: CALL 53990 0 0
// if event = 126 then
37799: LD_VAR 0 1
37803: PUSH
37804: LD_INT 126
37806: EQUAL
37807: IFFALSE 37813
// MC_RemoteDriver ( ) ;
37809: CALL 54615 0 0
// if event = 200 then
37813: LD_VAR 0 1
37817: PUSH
37818: LD_INT 200
37820: EQUAL
37821: IFFALSE 37827
// MC_Idle ( ) ;
37823: CALL 56348 0 0
// end ;
37827: PPOPN 1
37829: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37830: LD_INT 0
37832: PPUSH
37833: PPUSH
// if not mc_bases [ base ] or not tag then
37834: LD_EXP 99
37838: PUSH
37839: LD_VAR 0 1
37843: ARRAY
37844: NOT
37845: PUSH
37846: LD_VAR 0 2
37850: NOT
37851: OR
37852: IFFALSE 37856
// exit ;
37854: GO 37920
// for i in mc_bases [ base ] union mc_ape [ base ] do
37856: LD_ADDR_VAR 0 4
37860: PUSH
37861: LD_EXP 99
37865: PUSH
37866: LD_VAR 0 1
37870: ARRAY
37871: PUSH
37872: LD_EXP 128
37876: PUSH
37877: LD_VAR 0 1
37881: ARRAY
37882: UNION
37883: PUSH
37884: FOR_IN
37885: IFFALSE 37918
// if GetTag ( i ) = tag then
37887: LD_VAR 0 4
37891: PPUSH
37892: CALL_OW 110
37896: PUSH
37897: LD_VAR 0 2
37901: EQUAL
37902: IFFALSE 37916
// SetTag ( i , 0 ) ;
37904: LD_VAR 0 4
37908: PPUSH
37909: LD_INT 0
37911: PPUSH
37912: CALL_OW 109
37916: GO 37884
37918: POP
37919: POP
// end ;
37920: LD_VAR 0 3
37924: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37925: LD_INT 0
37927: PPUSH
37928: PPUSH
37929: PPUSH
37930: PPUSH
37931: PPUSH
37932: PPUSH
37933: PPUSH
37934: PPUSH
// if not mc_bases then
37935: LD_EXP 99
37939: NOT
37940: IFFALSE 37944
// exit ;
37942: GO 38402
// for i = 1 to mc_bases do
37944: LD_ADDR_VAR 0 2
37948: PUSH
37949: DOUBLE
37950: LD_INT 1
37952: DEC
37953: ST_TO_ADDR
37954: LD_EXP 99
37958: PUSH
37959: FOR_TO
37960: IFFALSE 38400
// begin tmp := MC_ClassCheckReq ( i ) ;
37962: LD_ADDR_VAR 0 4
37966: PUSH
37967: LD_VAR 0 2
37971: PPUSH
37972: CALL 38407 0 1
37976: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
37977: LD_ADDR_EXP 140
37981: PUSH
37982: LD_EXP 140
37986: PPUSH
37987: LD_VAR 0 2
37991: PPUSH
37992: LD_VAR 0 4
37996: PPUSH
37997: CALL_OW 1
38001: ST_TO_ADDR
// if not tmp then
38002: LD_VAR 0 4
38006: NOT
38007: IFFALSE 38011
// continue ;
38009: GO 37959
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38011: LD_ADDR_VAR 0 6
38015: PUSH
38016: LD_EXP 99
38020: PUSH
38021: LD_VAR 0 2
38025: ARRAY
38026: PPUSH
38027: LD_INT 2
38029: PUSH
38030: LD_INT 30
38032: PUSH
38033: LD_INT 4
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 30
38042: PUSH
38043: LD_INT 5
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: LIST
38054: PPUSH
38055: CALL_OW 72
38059: PUSH
38060: LD_EXP 99
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: PPUSH
38071: LD_INT 2
38073: PUSH
38074: LD_INT 30
38076: PUSH
38077: LD_INT 0
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 30
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: EMPTY
38095: LIST
38096: LIST
38097: LIST
38098: PPUSH
38099: CALL_OW 72
38103: PUSH
38104: LD_EXP 99
38108: PUSH
38109: LD_VAR 0 2
38113: ARRAY
38114: PPUSH
38115: LD_INT 30
38117: PUSH
38118: LD_INT 3
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PPUSH
38125: CALL_OW 72
38129: PUSH
38130: LD_EXP 99
38134: PUSH
38135: LD_VAR 0 2
38139: ARRAY
38140: PPUSH
38141: LD_INT 2
38143: PUSH
38144: LD_INT 30
38146: PUSH
38147: LD_INT 6
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 30
38156: PUSH
38157: LD_INT 7
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 30
38166: PUSH
38167: LD_INT 8
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: PPUSH
38180: CALL_OW 72
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: ST_TO_ADDR
// for j = 1 to 4 do
38191: LD_ADDR_VAR 0 3
38195: PUSH
38196: DOUBLE
38197: LD_INT 1
38199: DEC
38200: ST_TO_ADDR
38201: LD_INT 4
38203: PUSH
38204: FOR_TO
38205: IFFALSE 38396
// begin if not tmp [ j ] then
38207: LD_VAR 0 4
38211: PUSH
38212: LD_VAR 0 3
38216: ARRAY
38217: NOT
38218: IFFALSE 38222
// continue ;
38220: GO 38204
// for p in tmp [ j ] do
38222: LD_ADDR_VAR 0 5
38226: PUSH
38227: LD_VAR 0 4
38231: PUSH
38232: LD_VAR 0 3
38236: ARRAY
38237: PUSH
38238: FOR_IN
38239: IFFALSE 38392
// begin if not b [ j ] then
38241: LD_VAR 0 6
38245: PUSH
38246: LD_VAR 0 3
38250: ARRAY
38251: NOT
38252: IFFALSE 38256
// break ;
38254: GO 38392
// e := 0 ;
38256: LD_ADDR_VAR 0 7
38260: PUSH
38261: LD_INT 0
38263: ST_TO_ADDR
// for k in b [ j ] do
38264: LD_ADDR_VAR 0 8
38268: PUSH
38269: LD_VAR 0 6
38273: PUSH
38274: LD_VAR 0 3
38278: ARRAY
38279: PUSH
38280: FOR_IN
38281: IFFALSE 38308
// if IsNotFull ( k ) then
38283: LD_VAR 0 8
38287: PPUSH
38288: CALL 67035 0 1
38292: IFFALSE 38306
// begin e := k ;
38294: LD_ADDR_VAR 0 7
38298: PUSH
38299: LD_VAR 0 8
38303: ST_TO_ADDR
// break ;
38304: GO 38308
// end ;
38306: GO 38280
38308: POP
38309: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38310: LD_VAR 0 7
38314: PUSH
38315: LD_VAR 0 5
38319: PPUSH
38320: LD_VAR 0 7
38324: PPUSH
38325: CALL 104093 0 2
38329: NOT
38330: AND
38331: IFFALSE 38390
// begin if IsInUnit ( p ) then
38333: LD_VAR 0 5
38337: PPUSH
38338: CALL_OW 310
38342: IFFALSE 38353
// ComExitBuilding ( p ) ;
38344: LD_VAR 0 5
38348: PPUSH
38349: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38353: LD_VAR 0 5
38357: PPUSH
38358: LD_VAR 0 7
38362: PPUSH
38363: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38367: LD_VAR 0 5
38371: PPUSH
38372: LD_VAR 0 3
38376: PPUSH
38377: CALL_OW 183
// AddComExitBuilding ( p ) ;
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL_OW 182
// end ; end ;
38390: GO 38238
38392: POP
38393: POP
// end ;
38394: GO 38204
38396: POP
38397: POP
// end ;
38398: GO 37959
38400: POP
38401: POP
// end ;
38402: LD_VAR 0 1
38406: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38407: LD_INT 0
38409: PPUSH
38410: PPUSH
38411: PPUSH
38412: PPUSH
38413: PPUSH
38414: PPUSH
38415: PPUSH
38416: PPUSH
38417: PPUSH
38418: PPUSH
38419: PPUSH
38420: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38421: LD_VAR 0 1
38425: NOT
38426: PUSH
38427: LD_EXP 99
38431: PUSH
38432: LD_VAR 0 1
38436: ARRAY
38437: NOT
38438: OR
38439: PUSH
38440: LD_EXP 99
38444: PUSH
38445: LD_VAR 0 1
38449: ARRAY
38450: PPUSH
38451: LD_INT 2
38453: PUSH
38454: LD_INT 30
38456: PUSH
38457: LD_INT 0
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 30
38466: PUSH
38467: LD_INT 1
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: LIST
38478: PPUSH
38479: CALL_OW 72
38483: NOT
38484: OR
38485: IFFALSE 38489
// exit ;
38487: GO 41983
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38489: LD_ADDR_VAR 0 4
38493: PUSH
38494: LD_EXP 99
38498: PUSH
38499: LD_VAR 0 1
38503: ARRAY
38504: PPUSH
38505: LD_INT 2
38507: PUSH
38508: LD_INT 25
38510: PUSH
38511: LD_INT 1
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 25
38520: PUSH
38521: LD_INT 2
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 25
38530: PUSH
38531: LD_INT 3
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PUSH
38538: LD_INT 25
38540: PUSH
38541: LD_INT 4
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 25
38550: PUSH
38551: LD_INT 5
38553: PUSH
38554: EMPTY
38555: LIST
38556: LIST
38557: PUSH
38558: LD_INT 25
38560: PUSH
38561: LD_INT 8
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 25
38570: PUSH
38571: LD_INT 9
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: PPUSH
38588: CALL_OW 72
38592: ST_TO_ADDR
// for i in tmp do
38593: LD_ADDR_VAR 0 3
38597: PUSH
38598: LD_VAR 0 4
38602: PUSH
38603: FOR_IN
38604: IFFALSE 38635
// if GetTag ( i ) then
38606: LD_VAR 0 3
38610: PPUSH
38611: CALL_OW 110
38615: IFFALSE 38633
// tmp := tmp diff i ;
38617: LD_ADDR_VAR 0 4
38621: PUSH
38622: LD_VAR 0 4
38626: PUSH
38627: LD_VAR 0 3
38631: DIFF
38632: ST_TO_ADDR
38633: GO 38603
38635: POP
38636: POP
// if not tmp then
38637: LD_VAR 0 4
38641: NOT
38642: IFFALSE 38646
// exit ;
38644: GO 41983
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38646: LD_ADDR_VAR 0 5
38650: PUSH
38651: LD_EXP 99
38655: PUSH
38656: LD_VAR 0 1
38660: ARRAY
38661: PPUSH
38662: LD_INT 2
38664: PUSH
38665: LD_INT 25
38667: PUSH
38668: LD_INT 1
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 25
38677: PUSH
38678: LD_INT 5
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 25
38687: PUSH
38688: LD_INT 8
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 25
38697: PUSH
38698: LD_INT 9
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: LIST
38709: LIST
38710: LIST
38711: PPUSH
38712: CALL_OW 72
38716: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38717: LD_ADDR_VAR 0 6
38721: PUSH
38722: LD_EXP 99
38726: PUSH
38727: LD_VAR 0 1
38731: ARRAY
38732: PPUSH
38733: LD_INT 25
38735: PUSH
38736: LD_INT 2
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PPUSH
38743: CALL_OW 72
38747: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38748: LD_ADDR_VAR 0 7
38752: PUSH
38753: LD_EXP 99
38757: PUSH
38758: LD_VAR 0 1
38762: ARRAY
38763: PPUSH
38764: LD_INT 25
38766: PUSH
38767: LD_INT 3
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PPUSH
38774: CALL_OW 72
38778: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38779: LD_ADDR_VAR 0 8
38783: PUSH
38784: LD_EXP 99
38788: PUSH
38789: LD_VAR 0 1
38793: ARRAY
38794: PPUSH
38795: LD_INT 25
38797: PUSH
38798: LD_INT 4
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 24
38807: PUSH
38808: LD_INT 251
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PPUSH
38819: CALL_OW 72
38823: ST_TO_ADDR
// if mc_scan [ base ] then
38824: LD_EXP 122
38828: PUSH
38829: LD_VAR 0 1
38833: ARRAY
38834: IFFALSE 39295
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38836: LD_ADDR_EXP 141
38840: PUSH
38841: LD_EXP 141
38845: PPUSH
38846: LD_VAR 0 1
38850: PPUSH
38851: LD_INT 4
38853: PPUSH
38854: CALL_OW 1
38858: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38859: LD_ADDR_VAR 0 12
38863: PUSH
38864: LD_EXP 99
38868: PUSH
38869: LD_VAR 0 1
38873: ARRAY
38874: PPUSH
38875: LD_INT 2
38877: PUSH
38878: LD_INT 30
38880: PUSH
38881: LD_INT 4
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 30
38890: PUSH
38891: LD_INT 5
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: LIST
38902: PPUSH
38903: CALL_OW 72
38907: ST_TO_ADDR
// if not b then
38908: LD_VAR 0 12
38912: NOT
38913: IFFALSE 38917
// exit ;
38915: GO 41983
// p := [ ] ;
38917: LD_ADDR_VAR 0 11
38921: PUSH
38922: EMPTY
38923: ST_TO_ADDR
// if sci >= 2 then
38924: LD_VAR 0 8
38928: PUSH
38929: LD_INT 2
38931: GREATEREQUAL
38932: IFFALSE 38963
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38934: LD_ADDR_VAR 0 8
38938: PUSH
38939: LD_VAR 0 8
38943: PUSH
38944: LD_INT 1
38946: ARRAY
38947: PUSH
38948: LD_VAR 0 8
38952: PUSH
38953: LD_INT 2
38955: ARRAY
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: ST_TO_ADDR
38961: GO 39024
// if sci = 1 then
38963: LD_VAR 0 8
38967: PUSH
38968: LD_INT 1
38970: EQUAL
38971: IFFALSE 38992
// sci := [ sci [ 1 ] ] else
38973: LD_ADDR_VAR 0 8
38977: PUSH
38978: LD_VAR 0 8
38982: PUSH
38983: LD_INT 1
38985: ARRAY
38986: PUSH
38987: EMPTY
38988: LIST
38989: ST_TO_ADDR
38990: GO 39024
// if sci = 0 then
38992: LD_VAR 0 8
38996: PUSH
38997: LD_INT 0
38999: EQUAL
39000: IFFALSE 39024
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39002: LD_ADDR_VAR 0 11
39006: PUSH
39007: LD_VAR 0 4
39011: PPUSH
39012: LD_INT 4
39014: PPUSH
39015: CALL 103956 0 2
39019: PUSH
39020: LD_INT 1
39022: ARRAY
39023: ST_TO_ADDR
// if eng > 4 then
39024: LD_VAR 0 6
39028: PUSH
39029: LD_INT 4
39031: GREATER
39032: IFFALSE 39078
// for i = eng downto 4 do
39034: LD_ADDR_VAR 0 3
39038: PUSH
39039: DOUBLE
39040: LD_VAR 0 6
39044: INC
39045: ST_TO_ADDR
39046: LD_INT 4
39048: PUSH
39049: FOR_DOWNTO
39050: IFFALSE 39076
// eng := eng diff eng [ i ] ;
39052: LD_ADDR_VAR 0 6
39056: PUSH
39057: LD_VAR 0 6
39061: PUSH
39062: LD_VAR 0 6
39066: PUSH
39067: LD_VAR 0 3
39071: ARRAY
39072: DIFF
39073: ST_TO_ADDR
39074: GO 39049
39076: POP
39077: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39078: LD_ADDR_VAR 0 4
39082: PUSH
39083: LD_VAR 0 4
39087: PUSH
39088: LD_VAR 0 5
39092: PUSH
39093: LD_VAR 0 6
39097: UNION
39098: PUSH
39099: LD_VAR 0 7
39103: UNION
39104: PUSH
39105: LD_VAR 0 8
39109: UNION
39110: DIFF
39111: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39112: LD_ADDR_VAR 0 13
39116: PUSH
39117: LD_EXP 99
39121: PUSH
39122: LD_VAR 0 1
39126: ARRAY
39127: PPUSH
39128: LD_INT 2
39130: PUSH
39131: LD_INT 30
39133: PUSH
39134: LD_INT 32
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 30
39143: PUSH
39144: LD_INT 31
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: LIST
39155: PPUSH
39156: CALL_OW 72
39160: PUSH
39161: LD_EXP 99
39165: PUSH
39166: LD_VAR 0 1
39170: ARRAY
39171: PPUSH
39172: LD_INT 2
39174: PUSH
39175: LD_INT 30
39177: PUSH
39178: LD_INT 4
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 30
39187: PUSH
39188: LD_INT 5
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: LIST
39199: PPUSH
39200: CALL_OW 72
39204: PUSH
39205: LD_INT 6
39207: MUL
39208: PLUS
39209: ST_TO_ADDR
// if bcount < tmp then
39210: LD_VAR 0 13
39214: PUSH
39215: LD_VAR 0 4
39219: LESS
39220: IFFALSE 39266
// for i = tmp downto bcount do
39222: LD_ADDR_VAR 0 3
39226: PUSH
39227: DOUBLE
39228: LD_VAR 0 4
39232: INC
39233: ST_TO_ADDR
39234: LD_VAR 0 13
39238: PUSH
39239: FOR_DOWNTO
39240: IFFALSE 39264
// tmp := Delete ( tmp , tmp ) ;
39242: LD_ADDR_VAR 0 4
39246: PUSH
39247: LD_VAR 0 4
39251: PPUSH
39252: LD_VAR 0 4
39256: PPUSH
39257: CALL_OW 3
39261: ST_TO_ADDR
39262: GO 39239
39264: POP
39265: POP
// result := [ tmp , 0 , 0 , p ] ;
39266: LD_ADDR_VAR 0 2
39270: PUSH
39271: LD_VAR 0 4
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: LD_INT 0
39281: PUSH
39282: LD_VAR 0 11
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: ST_TO_ADDR
// exit ;
39293: GO 41983
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39295: LD_EXP 99
39299: PUSH
39300: LD_VAR 0 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 2
39308: PUSH
39309: LD_INT 30
39311: PUSH
39312: LD_INT 6
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 30
39321: PUSH
39322: LD_INT 7
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 30
39331: PUSH
39332: LD_INT 8
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: PPUSH
39345: CALL_OW 72
39349: NOT
39350: PUSH
39351: LD_EXP 99
39355: PUSH
39356: LD_VAR 0 1
39360: ARRAY
39361: PPUSH
39362: LD_INT 30
39364: PUSH
39365: LD_INT 3
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PPUSH
39372: CALL_OW 72
39376: NOT
39377: AND
39378: IFFALSE 39450
// begin if eng = tmp then
39380: LD_VAR 0 6
39384: PUSH
39385: LD_VAR 0 4
39389: EQUAL
39390: IFFALSE 39394
// exit ;
39392: GO 41983
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39394: LD_ADDR_EXP 141
39398: PUSH
39399: LD_EXP 141
39403: PPUSH
39404: LD_VAR 0 1
39408: PPUSH
39409: LD_INT 1
39411: PPUSH
39412: CALL_OW 1
39416: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39417: LD_ADDR_VAR 0 2
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: LD_VAR 0 4
39429: PUSH
39430: LD_VAR 0 6
39434: DIFF
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: ST_TO_ADDR
// exit ;
39448: GO 41983
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39450: LD_EXP 126
39454: PUSH
39455: LD_EXP 125
39459: PUSH
39460: LD_VAR 0 1
39464: ARRAY
39465: ARRAY
39466: PUSH
39467: LD_EXP 99
39471: PUSH
39472: LD_VAR 0 1
39476: ARRAY
39477: PPUSH
39478: LD_INT 2
39480: PUSH
39481: LD_INT 30
39483: PUSH
39484: LD_INT 6
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 30
39493: PUSH
39494: LD_INT 7
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 30
39503: PUSH
39504: LD_INT 8
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: PPUSH
39517: CALL_OW 72
39521: AND
39522: PUSH
39523: LD_EXP 99
39527: PUSH
39528: LD_VAR 0 1
39532: ARRAY
39533: PPUSH
39534: LD_INT 30
39536: PUSH
39537: LD_INT 3
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PPUSH
39544: CALL_OW 72
39548: NOT
39549: AND
39550: IFFALSE 39764
// begin if sci >= 6 then
39552: LD_VAR 0 8
39556: PUSH
39557: LD_INT 6
39559: GREATEREQUAL
39560: IFFALSE 39564
// exit ;
39562: GO 41983
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39564: LD_ADDR_EXP 141
39568: PUSH
39569: LD_EXP 141
39573: PPUSH
39574: LD_VAR 0 1
39578: PPUSH
39579: LD_INT 2
39581: PPUSH
39582: CALL_OW 1
39586: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39587: LD_ADDR_VAR 0 9
39591: PUSH
39592: LD_VAR 0 4
39596: PUSH
39597: LD_VAR 0 8
39601: DIFF
39602: PPUSH
39603: LD_INT 4
39605: PPUSH
39606: CALL 103956 0 2
39610: ST_TO_ADDR
// p := [ ] ;
39611: LD_ADDR_VAR 0 11
39615: PUSH
39616: EMPTY
39617: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39618: LD_VAR 0 8
39622: PUSH
39623: LD_INT 6
39625: LESS
39626: PUSH
39627: LD_VAR 0 9
39631: PUSH
39632: LD_INT 6
39634: GREATER
39635: AND
39636: IFFALSE 39717
// begin for i = 1 to 6 - sci do
39638: LD_ADDR_VAR 0 3
39642: PUSH
39643: DOUBLE
39644: LD_INT 1
39646: DEC
39647: ST_TO_ADDR
39648: LD_INT 6
39650: PUSH
39651: LD_VAR 0 8
39655: MINUS
39656: PUSH
39657: FOR_TO
39658: IFFALSE 39713
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39660: LD_ADDR_VAR 0 11
39664: PUSH
39665: LD_VAR 0 11
39669: PPUSH
39670: LD_VAR 0 11
39674: PUSH
39675: LD_INT 1
39677: PLUS
39678: PPUSH
39679: LD_VAR 0 9
39683: PUSH
39684: LD_INT 1
39686: ARRAY
39687: PPUSH
39688: CALL_OW 2
39692: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39693: LD_ADDR_VAR 0 9
39697: PUSH
39698: LD_VAR 0 9
39702: PPUSH
39703: LD_INT 1
39705: PPUSH
39706: CALL_OW 3
39710: ST_TO_ADDR
// end ;
39711: GO 39657
39713: POP
39714: POP
// end else
39715: GO 39737
// if sort then
39717: LD_VAR 0 9
39721: IFFALSE 39737
// p := sort [ 1 ] ;
39723: LD_ADDR_VAR 0 11
39727: PUSH
39728: LD_VAR 0 9
39732: PUSH
39733: LD_INT 1
39735: ARRAY
39736: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39737: LD_ADDR_VAR 0 2
39741: PUSH
39742: LD_INT 0
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: LD_INT 0
39750: PUSH
39751: LD_VAR 0 11
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: ST_TO_ADDR
// exit ;
39762: GO 41983
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39764: LD_EXP 126
39768: PUSH
39769: LD_EXP 125
39773: PUSH
39774: LD_VAR 0 1
39778: ARRAY
39779: ARRAY
39780: PUSH
39781: LD_EXP 99
39785: PUSH
39786: LD_VAR 0 1
39790: ARRAY
39791: PPUSH
39792: LD_INT 2
39794: PUSH
39795: LD_INT 30
39797: PUSH
39798: LD_INT 6
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 30
39807: PUSH
39808: LD_INT 7
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 30
39817: PUSH
39818: LD_INT 8
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: PPUSH
39831: CALL_OW 72
39835: AND
39836: PUSH
39837: LD_EXP 99
39841: PUSH
39842: LD_VAR 0 1
39846: ARRAY
39847: PPUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 3
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PPUSH
39858: CALL_OW 72
39862: AND
39863: IFFALSE 40597
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39865: LD_ADDR_EXP 141
39869: PUSH
39870: LD_EXP 141
39874: PPUSH
39875: LD_VAR 0 1
39879: PPUSH
39880: LD_INT 3
39882: PPUSH
39883: CALL_OW 1
39887: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39888: LD_ADDR_VAR 0 2
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 0
39898: PUSH
39899: LD_INT 0
39901: PUSH
39902: LD_INT 0
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: ST_TO_ADDR
// if not eng then
39911: LD_VAR 0 6
39915: NOT
39916: IFFALSE 39979
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39918: LD_ADDR_VAR 0 11
39922: PUSH
39923: LD_VAR 0 4
39927: PPUSH
39928: LD_INT 2
39930: PPUSH
39931: CALL 103956 0 2
39935: PUSH
39936: LD_INT 1
39938: ARRAY
39939: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39940: LD_ADDR_VAR 0 2
39944: PUSH
39945: LD_VAR 0 2
39949: PPUSH
39950: LD_INT 2
39952: PPUSH
39953: LD_VAR 0 11
39957: PPUSH
39958: CALL_OW 1
39962: ST_TO_ADDR
// tmp := tmp diff p ;
39963: LD_ADDR_VAR 0 4
39967: PUSH
39968: LD_VAR 0 4
39972: PUSH
39973: LD_VAR 0 11
39977: DIFF
39978: ST_TO_ADDR
// end ; if tmp and sci < 6 then
39979: LD_VAR 0 4
39983: PUSH
39984: LD_VAR 0 8
39988: PUSH
39989: LD_INT 6
39991: LESS
39992: AND
39993: IFFALSE 40181
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
39995: LD_ADDR_VAR 0 9
39999: PUSH
40000: LD_VAR 0 4
40004: PUSH
40005: LD_VAR 0 8
40009: PUSH
40010: LD_VAR 0 7
40014: UNION
40015: DIFF
40016: PPUSH
40017: LD_INT 4
40019: PPUSH
40020: CALL 103956 0 2
40024: ST_TO_ADDR
// p := [ ] ;
40025: LD_ADDR_VAR 0 11
40029: PUSH
40030: EMPTY
40031: ST_TO_ADDR
// if sort then
40032: LD_VAR 0 9
40036: IFFALSE 40152
// for i = 1 to 6 - sci do
40038: LD_ADDR_VAR 0 3
40042: PUSH
40043: DOUBLE
40044: LD_INT 1
40046: DEC
40047: ST_TO_ADDR
40048: LD_INT 6
40050: PUSH
40051: LD_VAR 0 8
40055: MINUS
40056: PUSH
40057: FOR_TO
40058: IFFALSE 40150
// begin if i = sort then
40060: LD_VAR 0 3
40064: PUSH
40065: LD_VAR 0 9
40069: EQUAL
40070: IFFALSE 40074
// break ;
40072: GO 40150
// if GetClass ( i ) = 4 then
40074: LD_VAR 0 3
40078: PPUSH
40079: CALL_OW 257
40083: PUSH
40084: LD_INT 4
40086: EQUAL
40087: IFFALSE 40091
// continue ;
40089: GO 40057
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40091: LD_ADDR_VAR 0 11
40095: PUSH
40096: LD_VAR 0 11
40100: PPUSH
40101: LD_VAR 0 11
40105: PUSH
40106: LD_INT 1
40108: PLUS
40109: PPUSH
40110: LD_VAR 0 9
40114: PUSH
40115: LD_VAR 0 3
40119: ARRAY
40120: PPUSH
40121: CALL_OW 2
40125: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40126: LD_ADDR_VAR 0 4
40130: PUSH
40131: LD_VAR 0 4
40135: PUSH
40136: LD_VAR 0 9
40140: PUSH
40141: LD_VAR 0 3
40145: ARRAY
40146: DIFF
40147: ST_TO_ADDR
// end ;
40148: GO 40057
40150: POP
40151: POP
// if p then
40152: LD_VAR 0 11
40156: IFFALSE 40181
// result := Replace ( result , 4 , p ) ;
40158: LD_ADDR_VAR 0 2
40162: PUSH
40163: LD_VAR 0 2
40167: PPUSH
40168: LD_INT 4
40170: PPUSH
40171: LD_VAR 0 11
40175: PPUSH
40176: CALL_OW 1
40180: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40181: LD_VAR 0 4
40185: PUSH
40186: LD_VAR 0 7
40190: PUSH
40191: LD_INT 6
40193: LESS
40194: AND
40195: IFFALSE 40383
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40197: LD_ADDR_VAR 0 9
40201: PUSH
40202: LD_VAR 0 4
40206: PUSH
40207: LD_VAR 0 8
40211: PUSH
40212: LD_VAR 0 7
40216: UNION
40217: DIFF
40218: PPUSH
40219: LD_INT 3
40221: PPUSH
40222: CALL 103956 0 2
40226: ST_TO_ADDR
// p := [ ] ;
40227: LD_ADDR_VAR 0 11
40231: PUSH
40232: EMPTY
40233: ST_TO_ADDR
// if sort then
40234: LD_VAR 0 9
40238: IFFALSE 40354
// for i = 1 to 6 - mech do
40240: LD_ADDR_VAR 0 3
40244: PUSH
40245: DOUBLE
40246: LD_INT 1
40248: DEC
40249: ST_TO_ADDR
40250: LD_INT 6
40252: PUSH
40253: LD_VAR 0 7
40257: MINUS
40258: PUSH
40259: FOR_TO
40260: IFFALSE 40352
// begin if i = sort then
40262: LD_VAR 0 3
40266: PUSH
40267: LD_VAR 0 9
40271: EQUAL
40272: IFFALSE 40276
// break ;
40274: GO 40352
// if GetClass ( i ) = 3 then
40276: LD_VAR 0 3
40280: PPUSH
40281: CALL_OW 257
40285: PUSH
40286: LD_INT 3
40288: EQUAL
40289: IFFALSE 40293
// continue ;
40291: GO 40259
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40293: LD_ADDR_VAR 0 11
40297: PUSH
40298: LD_VAR 0 11
40302: PPUSH
40303: LD_VAR 0 11
40307: PUSH
40308: LD_INT 1
40310: PLUS
40311: PPUSH
40312: LD_VAR 0 9
40316: PUSH
40317: LD_VAR 0 3
40321: ARRAY
40322: PPUSH
40323: CALL_OW 2
40327: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40328: LD_ADDR_VAR 0 4
40332: PUSH
40333: LD_VAR 0 4
40337: PUSH
40338: LD_VAR 0 9
40342: PUSH
40343: LD_VAR 0 3
40347: ARRAY
40348: DIFF
40349: ST_TO_ADDR
// end ;
40350: GO 40259
40352: POP
40353: POP
// if p then
40354: LD_VAR 0 11
40358: IFFALSE 40383
// result := Replace ( result , 3 , p ) ;
40360: LD_ADDR_VAR 0 2
40364: PUSH
40365: LD_VAR 0 2
40369: PPUSH
40370: LD_INT 3
40372: PPUSH
40373: LD_VAR 0 11
40377: PPUSH
40378: CALL_OW 1
40382: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40383: LD_VAR 0 4
40387: PUSH
40388: LD_INT 6
40390: GREATER
40391: PUSH
40392: LD_VAR 0 6
40396: PUSH
40397: LD_INT 6
40399: LESS
40400: AND
40401: IFFALSE 40595
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40403: LD_ADDR_VAR 0 9
40407: PUSH
40408: LD_VAR 0 4
40412: PUSH
40413: LD_VAR 0 8
40417: PUSH
40418: LD_VAR 0 7
40422: UNION
40423: PUSH
40424: LD_VAR 0 6
40428: UNION
40429: DIFF
40430: PPUSH
40431: LD_INT 2
40433: PPUSH
40434: CALL 103956 0 2
40438: ST_TO_ADDR
// p := [ ] ;
40439: LD_ADDR_VAR 0 11
40443: PUSH
40444: EMPTY
40445: ST_TO_ADDR
// if sort then
40446: LD_VAR 0 9
40450: IFFALSE 40566
// for i = 1 to 6 - eng do
40452: LD_ADDR_VAR 0 3
40456: PUSH
40457: DOUBLE
40458: LD_INT 1
40460: DEC
40461: ST_TO_ADDR
40462: LD_INT 6
40464: PUSH
40465: LD_VAR 0 6
40469: MINUS
40470: PUSH
40471: FOR_TO
40472: IFFALSE 40564
// begin if i = sort then
40474: LD_VAR 0 3
40478: PUSH
40479: LD_VAR 0 9
40483: EQUAL
40484: IFFALSE 40488
// break ;
40486: GO 40564
// if GetClass ( i ) = 2 then
40488: LD_VAR 0 3
40492: PPUSH
40493: CALL_OW 257
40497: PUSH
40498: LD_INT 2
40500: EQUAL
40501: IFFALSE 40505
// continue ;
40503: GO 40471
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40505: LD_ADDR_VAR 0 11
40509: PUSH
40510: LD_VAR 0 11
40514: PPUSH
40515: LD_VAR 0 11
40519: PUSH
40520: LD_INT 1
40522: PLUS
40523: PPUSH
40524: LD_VAR 0 9
40528: PUSH
40529: LD_VAR 0 3
40533: ARRAY
40534: PPUSH
40535: CALL_OW 2
40539: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40540: LD_ADDR_VAR 0 4
40544: PUSH
40545: LD_VAR 0 4
40549: PUSH
40550: LD_VAR 0 9
40554: PUSH
40555: LD_VAR 0 3
40559: ARRAY
40560: DIFF
40561: ST_TO_ADDR
// end ;
40562: GO 40471
40564: POP
40565: POP
// if p then
40566: LD_VAR 0 11
40570: IFFALSE 40595
// result := Replace ( result , 2 , p ) ;
40572: LD_ADDR_VAR 0 2
40576: PUSH
40577: LD_VAR 0 2
40581: PPUSH
40582: LD_INT 2
40584: PPUSH
40585: LD_VAR 0 11
40589: PPUSH
40590: CALL_OW 1
40594: ST_TO_ADDR
// end ; exit ;
40595: GO 41983
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40597: LD_EXP 126
40601: PUSH
40602: LD_EXP 125
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: ARRAY
40613: NOT
40614: PUSH
40615: LD_EXP 99
40619: PUSH
40620: LD_VAR 0 1
40624: ARRAY
40625: PPUSH
40626: LD_INT 30
40628: PUSH
40629: LD_INT 3
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PPUSH
40636: CALL_OW 72
40640: AND
40641: PUSH
40642: LD_EXP 104
40646: PUSH
40647: LD_VAR 0 1
40651: ARRAY
40652: AND
40653: IFFALSE 41261
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40655: LD_ADDR_EXP 141
40659: PUSH
40660: LD_EXP 141
40664: PPUSH
40665: LD_VAR 0 1
40669: PPUSH
40670: LD_INT 5
40672: PPUSH
40673: CALL_OW 1
40677: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40678: LD_ADDR_VAR 0 2
40682: PUSH
40683: LD_INT 0
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: ST_TO_ADDR
// if sci > 1 then
40701: LD_VAR 0 8
40705: PUSH
40706: LD_INT 1
40708: GREATER
40709: IFFALSE 40737
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40711: LD_ADDR_VAR 0 4
40715: PUSH
40716: LD_VAR 0 4
40720: PUSH
40721: LD_VAR 0 8
40725: PUSH
40726: LD_VAR 0 8
40730: PUSH
40731: LD_INT 1
40733: ARRAY
40734: DIFF
40735: DIFF
40736: ST_TO_ADDR
// if tmp and not sci then
40737: LD_VAR 0 4
40741: PUSH
40742: LD_VAR 0 8
40746: NOT
40747: AND
40748: IFFALSE 40817
// begin sort := SortBySkill ( tmp , 4 ) ;
40750: LD_ADDR_VAR 0 9
40754: PUSH
40755: LD_VAR 0 4
40759: PPUSH
40760: LD_INT 4
40762: PPUSH
40763: CALL 103956 0 2
40767: ST_TO_ADDR
// if sort then
40768: LD_VAR 0 9
40772: IFFALSE 40788
// p := sort [ 1 ] ;
40774: LD_ADDR_VAR 0 11
40778: PUSH
40779: LD_VAR 0 9
40783: PUSH
40784: LD_INT 1
40786: ARRAY
40787: ST_TO_ADDR
// if p then
40788: LD_VAR 0 11
40792: IFFALSE 40817
// result := Replace ( result , 4 , p ) ;
40794: LD_ADDR_VAR 0 2
40798: PUSH
40799: LD_VAR 0 2
40803: PPUSH
40804: LD_INT 4
40806: PPUSH
40807: LD_VAR 0 11
40811: PPUSH
40812: CALL_OW 1
40816: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40817: LD_ADDR_VAR 0 4
40821: PUSH
40822: LD_VAR 0 4
40826: PUSH
40827: LD_VAR 0 7
40831: DIFF
40832: ST_TO_ADDR
// if tmp and mech < 6 then
40833: LD_VAR 0 4
40837: PUSH
40838: LD_VAR 0 7
40842: PUSH
40843: LD_INT 6
40845: LESS
40846: AND
40847: IFFALSE 41035
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40849: LD_ADDR_VAR 0 9
40853: PUSH
40854: LD_VAR 0 4
40858: PUSH
40859: LD_VAR 0 8
40863: PUSH
40864: LD_VAR 0 7
40868: UNION
40869: DIFF
40870: PPUSH
40871: LD_INT 3
40873: PPUSH
40874: CALL 103956 0 2
40878: ST_TO_ADDR
// p := [ ] ;
40879: LD_ADDR_VAR 0 11
40883: PUSH
40884: EMPTY
40885: ST_TO_ADDR
// if sort then
40886: LD_VAR 0 9
40890: IFFALSE 41006
// for i = 1 to 6 - mech do
40892: LD_ADDR_VAR 0 3
40896: PUSH
40897: DOUBLE
40898: LD_INT 1
40900: DEC
40901: ST_TO_ADDR
40902: LD_INT 6
40904: PUSH
40905: LD_VAR 0 7
40909: MINUS
40910: PUSH
40911: FOR_TO
40912: IFFALSE 41004
// begin if i = sort then
40914: LD_VAR 0 3
40918: PUSH
40919: LD_VAR 0 9
40923: EQUAL
40924: IFFALSE 40928
// break ;
40926: GO 41004
// if GetClass ( i ) = 3 then
40928: LD_VAR 0 3
40932: PPUSH
40933: CALL_OW 257
40937: PUSH
40938: LD_INT 3
40940: EQUAL
40941: IFFALSE 40945
// continue ;
40943: GO 40911
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40945: LD_ADDR_VAR 0 11
40949: PUSH
40950: LD_VAR 0 11
40954: PPUSH
40955: LD_VAR 0 11
40959: PUSH
40960: LD_INT 1
40962: PLUS
40963: PPUSH
40964: LD_VAR 0 9
40968: PUSH
40969: LD_VAR 0 3
40973: ARRAY
40974: PPUSH
40975: CALL_OW 2
40979: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40980: LD_ADDR_VAR 0 4
40984: PUSH
40985: LD_VAR 0 4
40989: PUSH
40990: LD_VAR 0 9
40994: PUSH
40995: LD_VAR 0 3
40999: ARRAY
41000: DIFF
41001: ST_TO_ADDR
// end ;
41002: GO 40911
41004: POP
41005: POP
// if p then
41006: LD_VAR 0 11
41010: IFFALSE 41035
// result := Replace ( result , 3 , p ) ;
41012: LD_ADDR_VAR 0 2
41016: PUSH
41017: LD_VAR 0 2
41021: PPUSH
41022: LD_INT 3
41024: PPUSH
41025: LD_VAR 0 11
41029: PPUSH
41030: CALL_OW 1
41034: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41035: LD_ADDR_VAR 0 4
41039: PUSH
41040: LD_VAR 0 4
41044: PUSH
41045: LD_VAR 0 6
41049: DIFF
41050: ST_TO_ADDR
// if tmp and eng < 6 then
41051: LD_VAR 0 4
41055: PUSH
41056: LD_VAR 0 6
41060: PUSH
41061: LD_INT 6
41063: LESS
41064: AND
41065: IFFALSE 41259
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41067: LD_ADDR_VAR 0 9
41071: PUSH
41072: LD_VAR 0 4
41076: PUSH
41077: LD_VAR 0 8
41081: PUSH
41082: LD_VAR 0 7
41086: UNION
41087: PUSH
41088: LD_VAR 0 6
41092: UNION
41093: DIFF
41094: PPUSH
41095: LD_INT 2
41097: PPUSH
41098: CALL 103956 0 2
41102: ST_TO_ADDR
// p := [ ] ;
41103: LD_ADDR_VAR 0 11
41107: PUSH
41108: EMPTY
41109: ST_TO_ADDR
// if sort then
41110: LD_VAR 0 9
41114: IFFALSE 41230
// for i = 1 to 6 - eng do
41116: LD_ADDR_VAR 0 3
41120: PUSH
41121: DOUBLE
41122: LD_INT 1
41124: DEC
41125: ST_TO_ADDR
41126: LD_INT 6
41128: PUSH
41129: LD_VAR 0 6
41133: MINUS
41134: PUSH
41135: FOR_TO
41136: IFFALSE 41228
// begin if i = sort then
41138: LD_VAR 0 3
41142: PUSH
41143: LD_VAR 0 9
41147: EQUAL
41148: IFFALSE 41152
// break ;
41150: GO 41228
// if GetClass ( i ) = 2 then
41152: LD_VAR 0 3
41156: PPUSH
41157: CALL_OW 257
41161: PUSH
41162: LD_INT 2
41164: EQUAL
41165: IFFALSE 41169
// continue ;
41167: GO 41135
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41169: LD_ADDR_VAR 0 11
41173: PUSH
41174: LD_VAR 0 11
41178: PPUSH
41179: LD_VAR 0 11
41183: PUSH
41184: LD_INT 1
41186: PLUS
41187: PPUSH
41188: LD_VAR 0 9
41192: PUSH
41193: LD_VAR 0 3
41197: ARRAY
41198: PPUSH
41199: CALL_OW 2
41203: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41204: LD_ADDR_VAR 0 4
41208: PUSH
41209: LD_VAR 0 4
41213: PUSH
41214: LD_VAR 0 9
41218: PUSH
41219: LD_VAR 0 3
41223: ARRAY
41224: DIFF
41225: ST_TO_ADDR
// end ;
41226: GO 41135
41228: POP
41229: POP
// if p then
41230: LD_VAR 0 11
41234: IFFALSE 41259
// result := Replace ( result , 2 , p ) ;
41236: LD_ADDR_VAR 0 2
41240: PUSH
41241: LD_VAR 0 2
41245: PPUSH
41246: LD_INT 2
41248: PPUSH
41249: LD_VAR 0 11
41253: PPUSH
41254: CALL_OW 1
41258: ST_TO_ADDR
// end ; exit ;
41259: GO 41983
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41261: LD_EXP 126
41265: PUSH
41266: LD_EXP 125
41270: PUSH
41271: LD_VAR 0 1
41275: ARRAY
41276: ARRAY
41277: NOT
41278: PUSH
41279: LD_EXP 99
41283: PUSH
41284: LD_VAR 0 1
41288: ARRAY
41289: PPUSH
41290: LD_INT 30
41292: PUSH
41293: LD_INT 3
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PPUSH
41300: CALL_OW 72
41304: AND
41305: PUSH
41306: LD_EXP 104
41310: PUSH
41311: LD_VAR 0 1
41315: ARRAY
41316: NOT
41317: AND
41318: IFFALSE 41983
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41320: LD_ADDR_EXP 141
41324: PUSH
41325: LD_EXP 141
41329: PPUSH
41330: LD_VAR 0 1
41334: PPUSH
41335: LD_INT 6
41337: PPUSH
41338: CALL_OW 1
41342: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41343: LD_ADDR_VAR 0 2
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: LD_INT 0
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: LIST
41364: LIST
41365: ST_TO_ADDR
// if sci >= 1 then
41366: LD_VAR 0 8
41370: PUSH
41371: LD_INT 1
41373: GREATEREQUAL
41374: IFFALSE 41396
// tmp := tmp diff sci [ 1 ] ;
41376: LD_ADDR_VAR 0 4
41380: PUSH
41381: LD_VAR 0 4
41385: PUSH
41386: LD_VAR 0 8
41390: PUSH
41391: LD_INT 1
41393: ARRAY
41394: DIFF
41395: ST_TO_ADDR
// if tmp and not sci then
41396: LD_VAR 0 4
41400: PUSH
41401: LD_VAR 0 8
41405: NOT
41406: AND
41407: IFFALSE 41476
// begin sort := SortBySkill ( tmp , 4 ) ;
41409: LD_ADDR_VAR 0 9
41413: PUSH
41414: LD_VAR 0 4
41418: PPUSH
41419: LD_INT 4
41421: PPUSH
41422: CALL 103956 0 2
41426: ST_TO_ADDR
// if sort then
41427: LD_VAR 0 9
41431: IFFALSE 41447
// p := sort [ 1 ] ;
41433: LD_ADDR_VAR 0 11
41437: PUSH
41438: LD_VAR 0 9
41442: PUSH
41443: LD_INT 1
41445: ARRAY
41446: ST_TO_ADDR
// if p then
41447: LD_VAR 0 11
41451: IFFALSE 41476
// result := Replace ( result , 4 , p ) ;
41453: LD_ADDR_VAR 0 2
41457: PUSH
41458: LD_VAR 0 2
41462: PPUSH
41463: LD_INT 4
41465: PPUSH
41466: LD_VAR 0 11
41470: PPUSH
41471: CALL_OW 1
41475: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41476: LD_ADDR_VAR 0 4
41480: PUSH
41481: LD_VAR 0 4
41485: PUSH
41486: LD_VAR 0 7
41490: DIFF
41491: ST_TO_ADDR
// if tmp and mech < 6 then
41492: LD_VAR 0 4
41496: PUSH
41497: LD_VAR 0 7
41501: PUSH
41502: LD_INT 6
41504: LESS
41505: AND
41506: IFFALSE 41688
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41508: LD_ADDR_VAR 0 9
41512: PUSH
41513: LD_VAR 0 4
41517: PUSH
41518: LD_VAR 0 7
41522: DIFF
41523: PPUSH
41524: LD_INT 3
41526: PPUSH
41527: CALL 103956 0 2
41531: ST_TO_ADDR
// p := [ ] ;
41532: LD_ADDR_VAR 0 11
41536: PUSH
41537: EMPTY
41538: ST_TO_ADDR
// if sort then
41539: LD_VAR 0 9
41543: IFFALSE 41659
// for i = 1 to 6 - mech do
41545: LD_ADDR_VAR 0 3
41549: PUSH
41550: DOUBLE
41551: LD_INT 1
41553: DEC
41554: ST_TO_ADDR
41555: LD_INT 6
41557: PUSH
41558: LD_VAR 0 7
41562: MINUS
41563: PUSH
41564: FOR_TO
41565: IFFALSE 41657
// begin if i = sort then
41567: LD_VAR 0 3
41571: PUSH
41572: LD_VAR 0 9
41576: EQUAL
41577: IFFALSE 41581
// break ;
41579: GO 41657
// if GetClass ( i ) = 3 then
41581: LD_VAR 0 3
41585: PPUSH
41586: CALL_OW 257
41590: PUSH
41591: LD_INT 3
41593: EQUAL
41594: IFFALSE 41598
// continue ;
41596: GO 41564
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41598: LD_ADDR_VAR 0 11
41602: PUSH
41603: LD_VAR 0 11
41607: PPUSH
41608: LD_VAR 0 11
41612: PUSH
41613: LD_INT 1
41615: PLUS
41616: PPUSH
41617: LD_VAR 0 9
41621: PUSH
41622: LD_VAR 0 3
41626: ARRAY
41627: PPUSH
41628: CALL_OW 2
41632: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41633: LD_ADDR_VAR 0 4
41637: PUSH
41638: LD_VAR 0 4
41642: PUSH
41643: LD_VAR 0 9
41647: PUSH
41648: LD_VAR 0 3
41652: ARRAY
41653: DIFF
41654: ST_TO_ADDR
// end ;
41655: GO 41564
41657: POP
41658: POP
// if p then
41659: LD_VAR 0 11
41663: IFFALSE 41688
// result := Replace ( result , 3 , p ) ;
41665: LD_ADDR_VAR 0 2
41669: PUSH
41670: LD_VAR 0 2
41674: PPUSH
41675: LD_INT 3
41677: PPUSH
41678: LD_VAR 0 11
41682: PPUSH
41683: CALL_OW 1
41687: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41688: LD_ADDR_VAR 0 4
41692: PUSH
41693: LD_VAR 0 4
41697: PUSH
41698: LD_VAR 0 6
41702: DIFF
41703: ST_TO_ADDR
// if tmp and eng < 4 then
41704: LD_VAR 0 4
41708: PUSH
41709: LD_VAR 0 6
41713: PUSH
41714: LD_INT 4
41716: LESS
41717: AND
41718: IFFALSE 41908
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41720: LD_ADDR_VAR 0 9
41724: PUSH
41725: LD_VAR 0 4
41729: PUSH
41730: LD_VAR 0 7
41734: PUSH
41735: LD_VAR 0 6
41739: UNION
41740: DIFF
41741: PPUSH
41742: LD_INT 2
41744: PPUSH
41745: CALL 103956 0 2
41749: ST_TO_ADDR
// p := [ ] ;
41750: LD_ADDR_VAR 0 11
41754: PUSH
41755: EMPTY
41756: ST_TO_ADDR
// if sort then
41757: LD_VAR 0 9
41761: IFFALSE 41877
// for i = 1 to 4 - eng do
41763: LD_ADDR_VAR 0 3
41767: PUSH
41768: DOUBLE
41769: LD_INT 1
41771: DEC
41772: ST_TO_ADDR
41773: LD_INT 4
41775: PUSH
41776: LD_VAR 0 6
41780: MINUS
41781: PUSH
41782: FOR_TO
41783: IFFALSE 41875
// begin if i = sort then
41785: LD_VAR 0 3
41789: PUSH
41790: LD_VAR 0 9
41794: EQUAL
41795: IFFALSE 41799
// break ;
41797: GO 41875
// if GetClass ( i ) = 2 then
41799: LD_VAR 0 3
41803: PPUSH
41804: CALL_OW 257
41808: PUSH
41809: LD_INT 2
41811: EQUAL
41812: IFFALSE 41816
// continue ;
41814: GO 41782
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41816: LD_ADDR_VAR 0 11
41820: PUSH
41821: LD_VAR 0 11
41825: PPUSH
41826: LD_VAR 0 11
41830: PUSH
41831: LD_INT 1
41833: PLUS
41834: PPUSH
41835: LD_VAR 0 9
41839: PUSH
41840: LD_VAR 0 3
41844: ARRAY
41845: PPUSH
41846: CALL_OW 2
41850: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41851: LD_ADDR_VAR 0 4
41855: PUSH
41856: LD_VAR 0 4
41860: PUSH
41861: LD_VAR 0 9
41865: PUSH
41866: LD_VAR 0 3
41870: ARRAY
41871: DIFF
41872: ST_TO_ADDR
// end ;
41873: GO 41782
41875: POP
41876: POP
// if p then
41877: LD_VAR 0 11
41881: IFFALSE 41906
// result := Replace ( result , 2 , p ) ;
41883: LD_ADDR_VAR 0 2
41887: PUSH
41888: LD_VAR 0 2
41892: PPUSH
41893: LD_INT 2
41895: PPUSH
41896: LD_VAR 0 11
41900: PPUSH
41901: CALL_OW 1
41905: ST_TO_ADDR
// end else
41906: GO 41952
// for i = eng downto 5 do
41908: LD_ADDR_VAR 0 3
41912: PUSH
41913: DOUBLE
41914: LD_VAR 0 6
41918: INC
41919: ST_TO_ADDR
41920: LD_INT 5
41922: PUSH
41923: FOR_DOWNTO
41924: IFFALSE 41950
// tmp := tmp union eng [ i ] ;
41926: LD_ADDR_VAR 0 4
41930: PUSH
41931: LD_VAR 0 4
41935: PUSH
41936: LD_VAR 0 6
41940: PUSH
41941: LD_VAR 0 3
41945: ARRAY
41946: UNION
41947: ST_TO_ADDR
41948: GO 41923
41950: POP
41951: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41952: LD_ADDR_VAR 0 2
41956: PUSH
41957: LD_VAR 0 2
41961: PPUSH
41962: LD_INT 1
41964: PPUSH
41965: LD_VAR 0 4
41969: PUSH
41970: LD_VAR 0 5
41974: DIFF
41975: PPUSH
41976: CALL_OW 1
41980: ST_TO_ADDR
// exit ;
41981: GO 41983
// end ; end ;
41983: LD_VAR 0 2
41987: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
41988: LD_INT 0
41990: PPUSH
41991: PPUSH
41992: PPUSH
// if not mc_bases then
41993: LD_EXP 99
41997: NOT
41998: IFFALSE 42002
// exit ;
42000: GO 42108
// for i = 1 to mc_bases do
42002: LD_ADDR_VAR 0 2
42006: PUSH
42007: DOUBLE
42008: LD_INT 1
42010: DEC
42011: ST_TO_ADDR
42012: LD_EXP 99
42016: PUSH
42017: FOR_TO
42018: IFFALSE 42099
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42020: LD_ADDR_VAR 0 3
42024: PUSH
42025: LD_EXP 99
42029: PUSH
42030: LD_VAR 0 2
42034: ARRAY
42035: PPUSH
42036: LD_INT 21
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: LD_INT 3
42048: PUSH
42049: LD_INT 24
42051: PUSH
42052: LD_INT 1000
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PPUSH
42067: CALL_OW 72
42071: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42072: LD_ADDR_EXP 100
42076: PUSH
42077: LD_EXP 100
42081: PPUSH
42082: LD_VAR 0 2
42086: PPUSH
42087: LD_VAR 0 3
42091: PPUSH
42092: CALL_OW 1
42096: ST_TO_ADDR
// end ;
42097: GO 42017
42099: POP
42100: POP
// RaiseSailEvent ( 101 ) ;
42101: LD_INT 101
42103: PPUSH
42104: CALL_OW 427
// end ;
42108: LD_VAR 0 1
42112: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42113: LD_INT 0
42115: PPUSH
42116: PPUSH
42117: PPUSH
42118: PPUSH
42119: PPUSH
42120: PPUSH
42121: PPUSH
// if not mc_bases then
42122: LD_EXP 99
42126: NOT
42127: IFFALSE 42131
// exit ;
42129: GO 42704
// for i = 1 to mc_bases do
42131: LD_ADDR_VAR 0 2
42135: PUSH
42136: DOUBLE
42137: LD_INT 1
42139: DEC
42140: ST_TO_ADDR
42141: LD_EXP 99
42145: PUSH
42146: FOR_TO
42147: IFFALSE 42695
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42149: LD_ADDR_VAR 0 5
42153: PUSH
42154: LD_EXP 99
42158: PUSH
42159: LD_VAR 0 2
42163: ARRAY
42164: PUSH
42165: LD_EXP 128
42169: PUSH
42170: LD_VAR 0 2
42174: ARRAY
42175: UNION
42176: PPUSH
42177: LD_INT 21
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 3
42192: PUSH
42193: LD_INT 54
42195: PUSH
42196: EMPTY
42197: LIST
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 3
42205: PUSH
42206: LD_INT 24
42208: PUSH
42209: LD_INT 800
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: LIST
42224: PUSH
42225: EMPTY
42226: LIST
42227: LIST
42228: PPUSH
42229: CALL_OW 72
42233: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42234: LD_ADDR_VAR 0 6
42238: PUSH
42239: LD_EXP 99
42243: PUSH
42244: LD_VAR 0 2
42248: ARRAY
42249: PPUSH
42250: LD_INT 21
42252: PUSH
42253: LD_INT 1
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 1
42262: PUSH
42263: LD_INT 3
42265: PUSH
42266: LD_INT 54
42268: PUSH
42269: EMPTY
42270: LIST
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 3
42278: PUSH
42279: LD_INT 24
42281: PUSH
42282: LD_INT 250
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: LIST
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PPUSH
42302: CALL_OW 72
42306: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42307: LD_ADDR_VAR 0 7
42311: PUSH
42312: LD_VAR 0 5
42316: PUSH
42317: LD_VAR 0 6
42321: DIFF
42322: ST_TO_ADDR
// if not need_heal_1 then
42323: LD_VAR 0 6
42327: NOT
42328: IFFALSE 42361
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42330: LD_ADDR_EXP 102
42334: PUSH
42335: LD_EXP 102
42339: PPUSH
42340: LD_VAR 0 2
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PPUSH
42352: EMPTY
42353: PPUSH
42354: CALL 69708 0 3
42358: ST_TO_ADDR
42359: GO 42431
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42361: LD_ADDR_EXP 102
42365: PUSH
42366: LD_EXP 102
42370: PPUSH
42371: LD_VAR 0 2
42375: PUSH
42376: LD_INT 1
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PPUSH
42383: LD_EXP 102
42387: PUSH
42388: LD_VAR 0 2
42392: ARRAY
42393: PUSH
42394: LD_INT 1
42396: ARRAY
42397: PPUSH
42398: LD_INT 3
42400: PUSH
42401: LD_INT 24
42403: PUSH
42404: LD_INT 1000
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL_OW 72
42419: PUSH
42420: LD_VAR 0 6
42424: UNION
42425: PPUSH
42426: CALL 69708 0 3
42430: ST_TO_ADDR
// if not need_heal_2 then
42431: LD_VAR 0 7
42435: NOT
42436: IFFALSE 42469
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42438: LD_ADDR_EXP 102
42442: PUSH
42443: LD_EXP 102
42447: PPUSH
42448: LD_VAR 0 2
42452: PUSH
42453: LD_INT 2
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PPUSH
42460: EMPTY
42461: PPUSH
42462: CALL 69708 0 3
42466: ST_TO_ADDR
42467: GO 42501
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42469: LD_ADDR_EXP 102
42473: PUSH
42474: LD_EXP 102
42478: PPUSH
42479: LD_VAR 0 2
42483: PUSH
42484: LD_INT 2
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PPUSH
42491: LD_VAR 0 7
42495: PPUSH
42496: CALL 69708 0 3
42500: ST_TO_ADDR
// if need_heal_2 then
42501: LD_VAR 0 7
42505: IFFALSE 42677
// for j in need_heal_2 do
42507: LD_ADDR_VAR 0 3
42511: PUSH
42512: LD_VAR 0 7
42516: PUSH
42517: FOR_IN
42518: IFFALSE 42675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42520: LD_ADDR_VAR 0 5
42524: PUSH
42525: LD_EXP 99
42529: PUSH
42530: LD_VAR 0 2
42534: ARRAY
42535: PPUSH
42536: LD_INT 2
42538: PUSH
42539: LD_INT 30
42541: PUSH
42542: LD_INT 6
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 30
42551: PUSH
42552: LD_INT 7
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 30
42561: PUSH
42562: LD_INT 8
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 30
42571: PUSH
42572: LD_INT 0
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 30
42581: PUSH
42582: LD_INT 1
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 25
42591: PUSH
42592: LD_INT 4
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: PPUSH
42608: CALL_OW 72
42612: ST_TO_ADDR
// if tmp then
42613: LD_VAR 0 5
42617: IFFALSE 42673
// begin k := NearestUnitToUnit ( tmp , j ) ;
42619: LD_ADDR_VAR 0 4
42623: PUSH
42624: LD_VAR 0 5
42628: PPUSH
42629: LD_VAR 0 3
42633: PPUSH
42634: CALL_OW 74
42638: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42639: LD_VAR 0 3
42643: PPUSH
42644: LD_VAR 0 4
42648: PPUSH
42649: CALL_OW 296
42653: PUSH
42654: LD_INT 7
42656: GREATER
42657: IFFALSE 42673
// ComMoveUnit ( j , k ) ;
42659: LD_VAR 0 3
42663: PPUSH
42664: LD_VAR 0 4
42668: PPUSH
42669: CALL_OW 112
// end ; end ;
42673: GO 42517
42675: POP
42676: POP
// if not need_heal_1 and not need_heal_2 then
42677: LD_VAR 0 6
42681: NOT
42682: PUSH
42683: LD_VAR 0 7
42687: NOT
42688: AND
42689: IFFALSE 42693
// continue ;
42691: GO 42146
// end ;
42693: GO 42146
42695: POP
42696: POP
// RaiseSailEvent ( 102 ) ;
42697: LD_INT 102
42699: PPUSH
42700: CALL_OW 427
// end ;
42704: LD_VAR 0 1
42708: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
42709: LD_INT 0
42711: PPUSH
42712: PPUSH
42713: PPUSH
42714: PPUSH
42715: PPUSH
// if not mc_bases then
42716: LD_EXP 99
42720: NOT
42721: IFFALSE 42725
// exit ;
42723: GO 43110
// for i = 1 to mc_bases do
42725: LD_ADDR_VAR 0 2
42729: PUSH
42730: DOUBLE
42731: LD_INT 1
42733: DEC
42734: ST_TO_ADDR
42735: LD_EXP 99
42739: PUSH
42740: FOR_TO
42741: IFFALSE 43108
// begin if not mc_building_need_repair [ i ] then
42743: LD_EXP 100
42747: PUSH
42748: LD_VAR 0 2
42752: ARRAY
42753: NOT
42754: IFFALSE 42792
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42756: LD_ADDR_EXP 101
42760: PUSH
42761: LD_EXP 101
42765: PPUSH
42766: LD_VAR 0 2
42770: PPUSH
42771: EMPTY
42772: PPUSH
42773: CALL_OW 1
42777: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42778: LD_VAR 0 2
42782: PPUSH
42783: LD_INT 101
42785: PPUSH
42786: CALL 37830 0 2
// continue ;
42790: GO 42740
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42792: LD_ADDR_EXP 105
42796: PUSH
42797: LD_EXP 105
42801: PPUSH
42802: LD_VAR 0 2
42806: PPUSH
42807: EMPTY
42808: PPUSH
42809: CALL_OW 1
42813: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42814: LD_VAR 0 2
42818: PPUSH
42819: LD_INT 103
42821: PPUSH
42822: CALL 37830 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
42826: LD_ADDR_VAR 0 5
42830: PUSH
42831: LD_EXP 99
42835: PUSH
42836: LD_VAR 0 2
42840: ARRAY
42841: PUSH
42842: LD_EXP 128
42846: PUSH
42847: LD_VAR 0 2
42851: ARRAY
42852: UNION
42853: PPUSH
42854: LD_INT 2
42856: PUSH
42857: LD_INT 25
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 25
42869: PUSH
42870: LD_INT 16
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: LIST
42881: PUSH
42882: EMPTY
42883: LIST
42884: PPUSH
42885: CALL_OW 72
42889: ST_TO_ADDR
// if not tmp then
42890: LD_VAR 0 5
42894: NOT
42895: IFFALSE 42899
// continue ;
42897: GO 42740
// for j in tmp do
42899: LD_ADDR_VAR 0 3
42903: PUSH
42904: LD_VAR 0 5
42908: PUSH
42909: FOR_IN
42910: IFFALSE 43104
// begin if mc_need_heal [ i ] then
42912: LD_EXP 102
42916: PUSH
42917: LD_VAR 0 2
42921: ARRAY
42922: IFFALSE 42970
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
42924: LD_VAR 0 3
42928: PUSH
42929: LD_EXP 102
42933: PUSH
42934: LD_VAR 0 2
42938: ARRAY
42939: PUSH
42940: LD_INT 1
42942: ARRAY
42943: IN
42944: PUSH
42945: LD_VAR 0 3
42949: PUSH
42950: LD_EXP 102
42954: PUSH
42955: LD_VAR 0 2
42959: ARRAY
42960: PUSH
42961: LD_INT 2
42963: ARRAY
42964: IN
42965: OR
42966: IFFALSE 42970
// continue ;
42968: GO 42909
// if IsInUnit ( j ) then
42970: LD_VAR 0 3
42974: PPUSH
42975: CALL_OW 310
42979: IFFALSE 42990
// ComExitBuilding ( j ) ;
42981: LD_VAR 0 3
42985: PPUSH
42986: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
42990: LD_VAR 0 3
42994: PUSH
42995: LD_EXP 101
42999: PUSH
43000: LD_VAR 0 2
43004: ARRAY
43005: IN
43006: NOT
43007: IFFALSE 43065
// begin SetTag ( j , 101 ) ;
43009: LD_VAR 0 3
43013: PPUSH
43014: LD_INT 101
43016: PPUSH
43017: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43021: LD_ADDR_EXP 101
43025: PUSH
43026: LD_EXP 101
43030: PPUSH
43031: LD_VAR 0 2
43035: PUSH
43036: LD_EXP 101
43040: PUSH
43041: LD_VAR 0 2
43045: ARRAY
43046: PUSH
43047: LD_INT 1
43049: PLUS
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PPUSH
43055: LD_VAR 0 3
43059: PPUSH
43060: CALL 69708 0 3
43064: ST_TO_ADDR
// end ; wait ( 1 ) ;
43065: LD_INT 1
43067: PPUSH
43068: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43072: LD_VAR 0 3
43076: PPUSH
43077: LD_EXP 100
43081: PUSH
43082: LD_VAR 0 2
43086: ARRAY
43087: PPUSH
43088: LD_VAR 0 3
43092: PPUSH
43093: CALL_OW 74
43097: PPUSH
43098: CALL_OW 130
// end ;
43102: GO 42909
43104: POP
43105: POP
// end ;
43106: GO 42740
43108: POP
43109: POP
// end ;
43110: LD_VAR 0 1
43114: RET
// export function MC_Heal ; var i , j , tmp ; begin
43115: LD_INT 0
43117: PPUSH
43118: PPUSH
43119: PPUSH
43120: PPUSH
// if not mc_bases then
43121: LD_EXP 99
43125: NOT
43126: IFFALSE 43130
// exit ;
43128: GO 43532
// for i = 1 to mc_bases do
43130: LD_ADDR_VAR 0 2
43134: PUSH
43135: DOUBLE
43136: LD_INT 1
43138: DEC
43139: ST_TO_ADDR
43140: LD_EXP 99
43144: PUSH
43145: FOR_TO
43146: IFFALSE 43530
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43148: LD_EXP 102
43152: PUSH
43153: LD_VAR 0 2
43157: ARRAY
43158: PUSH
43159: LD_INT 1
43161: ARRAY
43162: NOT
43163: PUSH
43164: LD_EXP 102
43168: PUSH
43169: LD_VAR 0 2
43173: ARRAY
43174: PUSH
43175: LD_INT 2
43177: ARRAY
43178: NOT
43179: AND
43180: IFFALSE 43218
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43182: LD_ADDR_EXP 103
43186: PUSH
43187: LD_EXP 103
43191: PPUSH
43192: LD_VAR 0 2
43196: PPUSH
43197: EMPTY
43198: PPUSH
43199: CALL_OW 1
43203: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43204: LD_VAR 0 2
43208: PPUSH
43209: LD_INT 102
43211: PPUSH
43212: CALL 37830 0 2
// continue ;
43216: GO 43145
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43218: LD_ADDR_VAR 0 4
43222: PUSH
43223: LD_EXP 99
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 25
43236: PUSH
43237: LD_INT 4
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PPUSH
43244: CALL_OW 72
43248: ST_TO_ADDR
// if not tmp then
43249: LD_VAR 0 4
43253: NOT
43254: IFFALSE 43258
// continue ;
43256: GO 43145
// if mc_taming [ i ] then
43258: LD_EXP 130
43262: PUSH
43263: LD_VAR 0 2
43267: ARRAY
43268: IFFALSE 43292
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43270: LD_ADDR_EXP 130
43274: PUSH
43275: LD_EXP 130
43279: PPUSH
43280: LD_VAR 0 2
43284: PPUSH
43285: EMPTY
43286: PPUSH
43287: CALL_OW 1
43291: ST_TO_ADDR
// for j in tmp do
43292: LD_ADDR_VAR 0 3
43296: PUSH
43297: LD_VAR 0 4
43301: PUSH
43302: FOR_IN
43303: IFFALSE 43526
// begin if IsInUnit ( j ) then
43305: LD_VAR 0 3
43309: PPUSH
43310: CALL_OW 310
43314: IFFALSE 43325
// ComExitBuilding ( j ) ;
43316: LD_VAR 0 3
43320: PPUSH
43321: CALL_OW 122
// if not j in mc_healers [ i ] then
43325: LD_VAR 0 3
43329: PUSH
43330: LD_EXP 103
43334: PUSH
43335: LD_VAR 0 2
43339: ARRAY
43340: IN
43341: NOT
43342: IFFALSE 43388
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43344: LD_ADDR_EXP 103
43348: PUSH
43349: LD_EXP 103
43353: PPUSH
43354: LD_VAR 0 2
43358: PUSH
43359: LD_EXP 103
43363: PUSH
43364: LD_VAR 0 2
43368: ARRAY
43369: PUSH
43370: LD_INT 1
43372: PLUS
43373: PUSH
43374: EMPTY
43375: LIST
43376: LIST
43377: PPUSH
43378: LD_VAR 0 3
43382: PPUSH
43383: CALL 69708 0 3
43387: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43388: LD_VAR 0 3
43392: PPUSH
43393: CALL_OW 110
43397: PUSH
43398: LD_INT 102
43400: NONEQUAL
43401: IFFALSE 43415
// SetTag ( j , 102 ) ;
43403: LD_VAR 0 3
43407: PPUSH
43408: LD_INT 102
43410: PPUSH
43411: CALL_OW 109
// Wait ( 3 ) ;
43415: LD_INT 3
43417: PPUSH
43418: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43422: LD_EXP 102
43426: PUSH
43427: LD_VAR 0 2
43431: ARRAY
43432: PUSH
43433: LD_INT 1
43435: ARRAY
43436: IFFALSE 43468
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43438: LD_VAR 0 3
43442: PPUSH
43443: LD_EXP 102
43447: PUSH
43448: LD_VAR 0 2
43452: ARRAY
43453: PUSH
43454: LD_INT 1
43456: ARRAY
43457: PUSH
43458: LD_INT 1
43460: ARRAY
43461: PPUSH
43462: CALL_OW 128
43466: GO 43524
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43468: LD_VAR 0 3
43472: PPUSH
43473: CALL_OW 314
43477: NOT
43478: PUSH
43479: LD_EXP 102
43483: PUSH
43484: LD_VAR 0 2
43488: ARRAY
43489: PUSH
43490: LD_INT 2
43492: ARRAY
43493: AND
43494: IFFALSE 43524
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43496: LD_VAR 0 3
43500: PPUSH
43501: LD_EXP 102
43505: PUSH
43506: LD_VAR 0 2
43510: ARRAY
43511: PUSH
43512: LD_INT 2
43514: ARRAY
43515: PUSH
43516: LD_INT 1
43518: ARRAY
43519: PPUSH
43520: CALL_OW 128
// end ;
43524: GO 43302
43526: POP
43527: POP
// end ;
43528: GO 43145
43530: POP
43531: POP
// end ;
43532: LD_VAR 0 1
43536: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43537: LD_INT 0
43539: PPUSH
43540: PPUSH
43541: PPUSH
43542: PPUSH
43543: PPUSH
// if not mc_bases then
43544: LD_EXP 99
43548: NOT
43549: IFFALSE 43553
// exit ;
43551: GO 44696
// for i = 1 to mc_bases do
43553: LD_ADDR_VAR 0 2
43557: PUSH
43558: DOUBLE
43559: LD_INT 1
43561: DEC
43562: ST_TO_ADDR
43563: LD_EXP 99
43567: PUSH
43568: FOR_TO
43569: IFFALSE 44694
// begin if mc_scan [ i ] then
43571: LD_EXP 122
43575: PUSH
43576: LD_VAR 0 2
43580: ARRAY
43581: IFFALSE 43585
// continue ;
43583: GO 43568
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43585: LD_EXP 104
43589: PUSH
43590: LD_VAR 0 2
43594: ARRAY
43595: NOT
43596: PUSH
43597: LD_EXP 106
43601: PUSH
43602: LD_VAR 0 2
43606: ARRAY
43607: NOT
43608: AND
43609: PUSH
43610: LD_EXP 105
43614: PUSH
43615: LD_VAR 0 2
43619: ARRAY
43620: AND
43621: IFFALSE 43659
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43623: LD_ADDR_EXP 105
43627: PUSH
43628: LD_EXP 105
43632: PPUSH
43633: LD_VAR 0 2
43637: PPUSH
43638: EMPTY
43639: PPUSH
43640: CALL_OW 1
43644: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43645: LD_VAR 0 2
43649: PPUSH
43650: LD_INT 103
43652: PPUSH
43653: CALL 37830 0 2
// continue ;
43657: GO 43568
// end ; if mc_construct_list [ i ] then
43659: LD_EXP 106
43663: PUSH
43664: LD_VAR 0 2
43668: ARRAY
43669: IFFALSE 43889
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43671: LD_ADDR_VAR 0 4
43675: PUSH
43676: LD_EXP 99
43680: PUSH
43681: LD_VAR 0 2
43685: ARRAY
43686: PPUSH
43687: LD_INT 25
43689: PUSH
43690: LD_INT 2
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: PPUSH
43697: CALL_OW 72
43701: PUSH
43702: LD_EXP 101
43706: PUSH
43707: LD_VAR 0 2
43711: ARRAY
43712: DIFF
43713: ST_TO_ADDR
// if not tmp then
43714: LD_VAR 0 4
43718: NOT
43719: IFFALSE 43723
// continue ;
43721: GO 43568
// for j in tmp do
43723: LD_ADDR_VAR 0 3
43727: PUSH
43728: LD_VAR 0 4
43732: PUSH
43733: FOR_IN
43734: IFFALSE 43885
// begin if not mc_builders [ i ] then
43736: LD_EXP 105
43740: PUSH
43741: LD_VAR 0 2
43745: ARRAY
43746: NOT
43747: IFFALSE 43805
// begin SetTag ( j , 103 ) ;
43749: LD_VAR 0 3
43753: PPUSH
43754: LD_INT 103
43756: PPUSH
43757: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43761: LD_ADDR_EXP 105
43765: PUSH
43766: LD_EXP 105
43770: PPUSH
43771: LD_VAR 0 2
43775: PUSH
43776: LD_EXP 105
43780: PUSH
43781: LD_VAR 0 2
43785: ARRAY
43786: PUSH
43787: LD_INT 1
43789: PLUS
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PPUSH
43795: LD_VAR 0 3
43799: PPUSH
43800: CALL 69708 0 3
43804: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43805: LD_VAR 0 3
43809: PPUSH
43810: CALL_OW 310
43814: IFFALSE 43825
// ComExitBuilding ( j ) ;
43816: LD_VAR 0 3
43820: PPUSH
43821: CALL_OW 122
// wait ( 3 ) ;
43825: LD_INT 3
43827: PPUSH
43828: CALL_OW 67
// if not mc_construct_list [ i ] then
43832: LD_EXP 106
43836: PUSH
43837: LD_VAR 0 2
43841: ARRAY
43842: NOT
43843: IFFALSE 43847
// break ;
43845: GO 43885
// if not HasTask ( j ) then
43847: LD_VAR 0 3
43851: PPUSH
43852: CALL_OW 314
43856: NOT
43857: IFFALSE 43883
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
43859: LD_VAR 0 3
43863: PPUSH
43864: LD_EXP 106
43868: PUSH
43869: LD_VAR 0 2
43873: ARRAY
43874: PUSH
43875: LD_INT 1
43877: ARRAY
43878: PPUSH
43879: CALL 72559 0 2
// end ;
43883: GO 43733
43885: POP
43886: POP
// end else
43887: GO 44692
// if mc_build_list [ i ] then
43889: LD_EXP 104
43893: PUSH
43894: LD_VAR 0 2
43898: ARRAY
43899: IFFALSE 44692
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43901: LD_ADDR_VAR 0 5
43905: PUSH
43906: LD_EXP 99
43910: PUSH
43911: LD_VAR 0 2
43915: ARRAY
43916: PPUSH
43917: LD_INT 2
43919: PUSH
43920: LD_INT 30
43922: PUSH
43923: LD_INT 0
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 30
43932: PUSH
43933: LD_INT 1
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: LIST
43944: PPUSH
43945: CALL_OW 72
43949: ST_TO_ADDR
// if depot then
43950: LD_VAR 0 5
43954: IFFALSE 43972
// depot := depot [ 1 ] else
43956: LD_ADDR_VAR 0 5
43960: PUSH
43961: LD_VAR 0 5
43965: PUSH
43966: LD_INT 1
43968: ARRAY
43969: ST_TO_ADDR
43970: GO 43980
// depot := 0 ;
43972: LD_ADDR_VAR 0 5
43976: PUSH
43977: LD_INT 0
43979: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
43980: LD_EXP 104
43984: PUSH
43985: LD_VAR 0 2
43989: ARRAY
43990: PUSH
43991: LD_INT 1
43993: ARRAY
43994: PUSH
43995: LD_INT 1
43997: ARRAY
43998: PPUSH
43999: CALL 72389 0 1
44003: PUSH
44004: LD_EXP 99
44008: PUSH
44009: LD_VAR 0 2
44013: ARRAY
44014: PPUSH
44015: LD_INT 2
44017: PUSH
44018: LD_INT 30
44020: PUSH
44021: LD_INT 2
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 30
44030: PUSH
44031: LD_INT 3
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: LIST
44042: PPUSH
44043: CALL_OW 72
44047: NOT
44048: AND
44049: IFFALSE 44154
// begin for j = 1 to mc_build_list [ i ] do
44051: LD_ADDR_VAR 0 3
44055: PUSH
44056: DOUBLE
44057: LD_INT 1
44059: DEC
44060: ST_TO_ADDR
44061: LD_EXP 104
44065: PUSH
44066: LD_VAR 0 2
44070: ARRAY
44071: PUSH
44072: FOR_TO
44073: IFFALSE 44152
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44075: LD_EXP 104
44079: PUSH
44080: LD_VAR 0 2
44084: ARRAY
44085: PUSH
44086: LD_VAR 0 3
44090: ARRAY
44091: PUSH
44092: LD_INT 1
44094: ARRAY
44095: PUSH
44096: LD_INT 2
44098: EQUAL
44099: IFFALSE 44150
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44101: LD_ADDR_EXP 104
44105: PUSH
44106: LD_EXP 104
44110: PPUSH
44111: LD_VAR 0 2
44115: PPUSH
44116: LD_EXP 104
44120: PUSH
44121: LD_VAR 0 2
44125: ARRAY
44126: PPUSH
44127: LD_VAR 0 3
44131: PPUSH
44132: LD_INT 1
44134: PPUSH
44135: LD_INT 0
44137: PPUSH
44138: CALL 69126 0 4
44142: PPUSH
44143: CALL_OW 1
44147: ST_TO_ADDR
// break ;
44148: GO 44152
// end ;
44150: GO 44072
44152: POP
44153: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44154: LD_EXP 104
44158: PUSH
44159: LD_VAR 0 2
44163: ARRAY
44164: PUSH
44165: LD_INT 1
44167: ARRAY
44168: PUSH
44169: LD_INT 1
44171: ARRAY
44172: PUSH
44173: LD_INT 0
44175: EQUAL
44176: PUSH
44177: LD_VAR 0 5
44181: PUSH
44182: LD_VAR 0 5
44186: PPUSH
44187: LD_EXP 104
44191: PUSH
44192: LD_VAR 0 2
44196: ARRAY
44197: PUSH
44198: LD_INT 1
44200: ARRAY
44201: PUSH
44202: LD_INT 1
44204: ARRAY
44205: PPUSH
44206: LD_EXP 104
44210: PUSH
44211: LD_VAR 0 2
44215: ARRAY
44216: PUSH
44217: LD_INT 1
44219: ARRAY
44220: PUSH
44221: LD_INT 2
44223: ARRAY
44224: PPUSH
44225: LD_EXP 104
44229: PUSH
44230: LD_VAR 0 2
44234: ARRAY
44235: PUSH
44236: LD_INT 1
44238: ARRAY
44239: PUSH
44240: LD_INT 3
44242: ARRAY
44243: PPUSH
44244: LD_EXP 104
44248: PUSH
44249: LD_VAR 0 2
44253: ARRAY
44254: PUSH
44255: LD_INT 1
44257: ARRAY
44258: PUSH
44259: LD_INT 4
44261: ARRAY
44262: PPUSH
44263: CALL 77123 0 5
44267: AND
44268: OR
44269: IFFALSE 44550
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44271: LD_ADDR_VAR 0 4
44275: PUSH
44276: LD_EXP 99
44280: PUSH
44281: LD_VAR 0 2
44285: ARRAY
44286: PPUSH
44287: LD_INT 25
44289: PUSH
44290: LD_INT 2
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PPUSH
44297: CALL_OW 72
44301: PUSH
44302: LD_EXP 101
44306: PUSH
44307: LD_VAR 0 2
44311: ARRAY
44312: DIFF
44313: ST_TO_ADDR
// if not tmp then
44314: LD_VAR 0 4
44318: NOT
44319: IFFALSE 44323
// continue ;
44321: GO 43568
// for j in tmp do
44323: LD_ADDR_VAR 0 3
44327: PUSH
44328: LD_VAR 0 4
44332: PUSH
44333: FOR_IN
44334: IFFALSE 44546
// begin if not mc_builders [ i ] then
44336: LD_EXP 105
44340: PUSH
44341: LD_VAR 0 2
44345: ARRAY
44346: NOT
44347: IFFALSE 44405
// begin SetTag ( j , 103 ) ;
44349: LD_VAR 0 3
44353: PPUSH
44354: LD_INT 103
44356: PPUSH
44357: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44361: LD_ADDR_EXP 105
44365: PUSH
44366: LD_EXP 105
44370: PPUSH
44371: LD_VAR 0 2
44375: PUSH
44376: LD_EXP 105
44380: PUSH
44381: LD_VAR 0 2
44385: ARRAY
44386: PUSH
44387: LD_INT 1
44389: PLUS
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PPUSH
44395: LD_VAR 0 3
44399: PPUSH
44400: CALL 69708 0 3
44404: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44405: LD_VAR 0 3
44409: PPUSH
44410: CALL_OW 310
44414: IFFALSE 44425
// ComExitBuilding ( j ) ;
44416: LD_VAR 0 3
44420: PPUSH
44421: CALL_OW 122
// wait ( 3 ) ;
44425: LD_INT 3
44427: PPUSH
44428: CALL_OW 67
// if not mc_build_list [ i ] then
44432: LD_EXP 104
44436: PUSH
44437: LD_VAR 0 2
44441: ARRAY
44442: NOT
44443: IFFALSE 44447
// break ;
44445: GO 44546
// if not HasTask ( j ) then
44447: LD_VAR 0 3
44451: PPUSH
44452: CALL_OW 314
44456: NOT
44457: IFFALSE 44544
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44459: LD_VAR 0 3
44463: PPUSH
44464: LD_EXP 104
44468: PUSH
44469: LD_VAR 0 2
44473: ARRAY
44474: PUSH
44475: LD_INT 1
44477: ARRAY
44478: PUSH
44479: LD_INT 1
44481: ARRAY
44482: PPUSH
44483: LD_EXP 104
44487: PUSH
44488: LD_VAR 0 2
44492: ARRAY
44493: PUSH
44494: LD_INT 1
44496: ARRAY
44497: PUSH
44498: LD_INT 2
44500: ARRAY
44501: PPUSH
44502: LD_EXP 104
44506: PUSH
44507: LD_VAR 0 2
44511: ARRAY
44512: PUSH
44513: LD_INT 1
44515: ARRAY
44516: PUSH
44517: LD_INT 3
44519: ARRAY
44520: PPUSH
44521: LD_EXP 104
44525: PUSH
44526: LD_VAR 0 2
44530: ARRAY
44531: PUSH
44532: LD_INT 1
44534: ARRAY
44535: PUSH
44536: LD_INT 4
44538: ARRAY
44539: PPUSH
44540: CALL_OW 145
// end ;
44544: GO 44333
44546: POP
44547: POP
// end else
44548: GO 44692
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44550: LD_EXP 99
44554: PUSH
44555: LD_VAR 0 2
44559: ARRAY
44560: PPUSH
44561: LD_EXP 104
44565: PUSH
44566: LD_VAR 0 2
44570: ARRAY
44571: PUSH
44572: LD_INT 1
44574: ARRAY
44575: PUSH
44576: LD_INT 1
44578: ARRAY
44579: PPUSH
44580: LD_EXP 104
44584: PUSH
44585: LD_VAR 0 2
44589: ARRAY
44590: PUSH
44591: LD_INT 1
44593: ARRAY
44594: PUSH
44595: LD_INT 2
44597: ARRAY
44598: PPUSH
44599: LD_EXP 104
44603: PUSH
44604: LD_VAR 0 2
44608: ARRAY
44609: PUSH
44610: LD_INT 1
44612: ARRAY
44613: PUSH
44614: LD_INT 3
44616: ARRAY
44617: PPUSH
44618: LD_EXP 104
44622: PUSH
44623: LD_VAR 0 2
44627: ARRAY
44628: PUSH
44629: LD_INT 1
44631: ARRAY
44632: PUSH
44633: LD_INT 4
44635: ARRAY
44636: PPUSH
44637: CALL 76459 0 5
44641: NOT
44642: IFFALSE 44692
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
44644: LD_ADDR_EXP 104
44648: PUSH
44649: LD_EXP 104
44653: PPUSH
44654: LD_VAR 0 2
44658: PPUSH
44659: LD_EXP 104
44663: PUSH
44664: LD_VAR 0 2
44668: ARRAY
44669: PPUSH
44670: LD_INT 1
44672: PPUSH
44673: LD_INT 1
44675: NEG
44676: PPUSH
44677: LD_INT 0
44679: PPUSH
44680: CALL 69126 0 4
44684: PPUSH
44685: CALL_OW 1
44689: ST_TO_ADDR
// continue ;
44690: GO 43568
// end ; end ; end ;
44692: GO 43568
44694: POP
44695: POP
// end ;
44696: LD_VAR 0 1
44700: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
44701: LD_INT 0
44703: PPUSH
44704: PPUSH
44705: PPUSH
44706: PPUSH
44707: PPUSH
44708: PPUSH
// if not mc_bases then
44709: LD_EXP 99
44713: NOT
44714: IFFALSE 44718
// exit ;
44716: GO 45145
// for i = 1 to mc_bases do
44718: LD_ADDR_VAR 0 2
44722: PUSH
44723: DOUBLE
44724: LD_INT 1
44726: DEC
44727: ST_TO_ADDR
44728: LD_EXP 99
44732: PUSH
44733: FOR_TO
44734: IFFALSE 45143
// begin tmp := mc_build_upgrade [ i ] ;
44736: LD_ADDR_VAR 0 4
44740: PUSH
44741: LD_EXP 131
44745: PUSH
44746: LD_VAR 0 2
44750: ARRAY
44751: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
44752: LD_ADDR_VAR 0 6
44756: PUSH
44757: LD_EXP 132
44761: PUSH
44762: LD_VAR 0 2
44766: ARRAY
44767: PPUSH
44768: LD_INT 2
44770: PUSH
44771: LD_INT 30
44773: PUSH
44774: LD_INT 6
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 30
44783: PUSH
44784: LD_INT 7
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: LIST
44795: PPUSH
44796: CALL_OW 72
44800: ST_TO_ADDR
// if not tmp and not lab then
44801: LD_VAR 0 4
44805: NOT
44806: PUSH
44807: LD_VAR 0 6
44811: NOT
44812: AND
44813: IFFALSE 44817
// continue ;
44815: GO 44733
// if tmp then
44817: LD_VAR 0 4
44821: IFFALSE 44941
// for j in tmp do
44823: LD_ADDR_VAR 0 3
44827: PUSH
44828: LD_VAR 0 4
44832: PUSH
44833: FOR_IN
44834: IFFALSE 44939
// begin if UpgradeCost ( j ) then
44836: LD_VAR 0 3
44840: PPUSH
44841: CALL 76119 0 1
44845: IFFALSE 44937
// begin ComUpgrade ( j ) ;
44847: LD_VAR 0 3
44851: PPUSH
44852: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
44856: LD_ADDR_EXP 131
44860: PUSH
44861: LD_EXP 131
44865: PPUSH
44866: LD_VAR 0 2
44870: PPUSH
44871: LD_EXP 131
44875: PUSH
44876: LD_VAR 0 2
44880: ARRAY
44881: PUSH
44882: LD_VAR 0 3
44886: DIFF
44887: PPUSH
44888: CALL_OW 1
44892: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44893: LD_ADDR_EXP 106
44897: PUSH
44898: LD_EXP 106
44902: PPUSH
44903: LD_VAR 0 2
44907: PUSH
44908: LD_EXP 106
44912: PUSH
44913: LD_VAR 0 2
44917: ARRAY
44918: PUSH
44919: LD_INT 1
44921: PLUS
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PPUSH
44927: LD_VAR 0 3
44931: PPUSH
44932: CALL 69708 0 3
44936: ST_TO_ADDR
// end ; end ;
44937: GO 44833
44939: POP
44940: POP
// if not lab or not mc_lab_upgrade [ i ] then
44941: LD_VAR 0 6
44945: NOT
44946: PUSH
44947: LD_EXP 133
44951: PUSH
44952: LD_VAR 0 2
44956: ARRAY
44957: NOT
44958: OR
44959: IFFALSE 44963
// continue ;
44961: GO 44733
// for j in lab do
44963: LD_ADDR_VAR 0 3
44967: PUSH
44968: LD_VAR 0 6
44972: PUSH
44973: FOR_IN
44974: IFFALSE 45139
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
44976: LD_VAR 0 3
44980: PPUSH
44981: CALL_OW 266
44985: PUSH
44986: LD_INT 6
44988: PUSH
44989: LD_INT 7
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: IN
44996: PUSH
44997: LD_VAR 0 3
45001: PPUSH
45002: CALL_OW 461
45006: PUSH
45007: LD_INT 1
45009: NONEQUAL
45010: AND
45011: IFFALSE 45137
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45013: LD_VAR 0 3
45017: PPUSH
45018: LD_EXP 133
45022: PUSH
45023: LD_VAR 0 2
45027: ARRAY
45028: PUSH
45029: LD_INT 1
45031: ARRAY
45032: PPUSH
45033: CALL 76324 0 2
45037: IFFALSE 45137
// begin ComCancel ( j ) ;
45039: LD_VAR 0 3
45043: PPUSH
45044: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45048: LD_VAR 0 3
45052: PPUSH
45053: LD_EXP 133
45057: PUSH
45058: LD_VAR 0 2
45062: ARRAY
45063: PUSH
45064: LD_INT 1
45066: ARRAY
45067: PPUSH
45068: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45072: LD_VAR 0 3
45076: PUSH
45077: LD_EXP 106
45081: PUSH
45082: LD_VAR 0 2
45086: ARRAY
45087: IN
45088: NOT
45089: IFFALSE 45135
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45091: LD_ADDR_EXP 106
45095: PUSH
45096: LD_EXP 106
45100: PPUSH
45101: LD_VAR 0 2
45105: PUSH
45106: LD_EXP 106
45110: PUSH
45111: LD_VAR 0 2
45115: ARRAY
45116: PUSH
45117: LD_INT 1
45119: PLUS
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PPUSH
45125: LD_VAR 0 3
45129: PPUSH
45130: CALL 69708 0 3
45134: ST_TO_ADDR
// break ;
45135: GO 45139
// end ; end ; end ;
45137: GO 44973
45139: POP
45140: POP
// end ;
45141: GO 44733
45143: POP
45144: POP
// end ;
45145: LD_VAR 0 1
45149: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45150: LD_INT 0
45152: PPUSH
45153: PPUSH
45154: PPUSH
45155: PPUSH
45156: PPUSH
45157: PPUSH
45158: PPUSH
45159: PPUSH
45160: PPUSH
// if not mc_bases then
45161: LD_EXP 99
45165: NOT
45166: IFFALSE 45170
// exit ;
45168: GO 45575
// for i = 1 to mc_bases do
45170: LD_ADDR_VAR 0 2
45174: PUSH
45175: DOUBLE
45176: LD_INT 1
45178: DEC
45179: ST_TO_ADDR
45180: LD_EXP 99
45184: PUSH
45185: FOR_TO
45186: IFFALSE 45573
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45188: LD_EXP 107
45192: PUSH
45193: LD_VAR 0 2
45197: ARRAY
45198: NOT
45199: PUSH
45200: LD_EXP 99
45204: PUSH
45205: LD_VAR 0 2
45209: ARRAY
45210: PPUSH
45211: LD_INT 30
45213: PUSH
45214: LD_INT 3
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PPUSH
45221: CALL_OW 72
45225: NOT
45226: OR
45227: IFFALSE 45231
// continue ;
45229: GO 45185
// busy := false ;
45231: LD_ADDR_VAR 0 8
45235: PUSH
45236: LD_INT 0
45238: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45239: LD_ADDR_VAR 0 4
45243: PUSH
45244: LD_EXP 99
45248: PUSH
45249: LD_VAR 0 2
45253: ARRAY
45254: PPUSH
45255: LD_INT 30
45257: PUSH
45258: LD_INT 3
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PPUSH
45265: CALL_OW 72
45269: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45270: LD_ADDR_VAR 0 6
45274: PUSH
45275: LD_EXP 107
45279: PUSH
45280: LD_VAR 0 2
45284: ARRAY
45285: PPUSH
45286: LD_INT 2
45288: PUSH
45289: LD_INT 30
45291: PUSH
45292: LD_INT 32
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 30
45301: PUSH
45302: LD_INT 33
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: PPUSH
45314: CALL_OW 72
45318: ST_TO_ADDR
// if not t then
45319: LD_VAR 0 6
45323: NOT
45324: IFFALSE 45328
// continue ;
45326: GO 45185
// for j in tmp do
45328: LD_ADDR_VAR 0 3
45332: PUSH
45333: LD_VAR 0 4
45337: PUSH
45338: FOR_IN
45339: IFFALSE 45369
// if not BuildingStatus ( j ) = bs_idle then
45341: LD_VAR 0 3
45345: PPUSH
45346: CALL_OW 461
45350: PUSH
45351: LD_INT 2
45353: EQUAL
45354: NOT
45355: IFFALSE 45367
// begin busy := true ;
45357: LD_ADDR_VAR 0 8
45361: PUSH
45362: LD_INT 1
45364: ST_TO_ADDR
// break ;
45365: GO 45369
// end ;
45367: GO 45338
45369: POP
45370: POP
// if busy then
45371: LD_VAR 0 8
45375: IFFALSE 45379
// continue ;
45377: GO 45185
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45379: LD_ADDR_VAR 0 7
45383: PUSH
45384: LD_VAR 0 6
45388: PPUSH
45389: LD_INT 35
45391: PUSH
45392: LD_INT 0
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PPUSH
45399: CALL_OW 72
45403: ST_TO_ADDR
// if tw then
45404: LD_VAR 0 7
45408: IFFALSE 45485
// begin tw := tw [ 1 ] ;
45410: LD_ADDR_VAR 0 7
45414: PUSH
45415: LD_VAR 0 7
45419: PUSH
45420: LD_INT 1
45422: ARRAY
45423: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45424: LD_ADDR_VAR 0 9
45428: PUSH
45429: LD_VAR 0 7
45433: PPUSH
45434: LD_EXP 124
45438: PUSH
45439: LD_VAR 0 2
45443: ARRAY
45444: PPUSH
45445: CALL 74678 0 2
45449: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45450: LD_EXP 138
45454: PUSH
45455: LD_VAR 0 2
45459: ARRAY
45460: IFFALSE 45483
// if not weapon in mc_allowed_tower_weapons [ i ] then
45462: LD_VAR 0 9
45466: PUSH
45467: LD_EXP 138
45471: PUSH
45472: LD_VAR 0 2
45476: ARRAY
45477: IN
45478: NOT
45479: IFFALSE 45483
// continue ;
45481: GO 45185
// end else
45483: GO 45548
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45485: LD_ADDR_VAR 0 5
45489: PUSH
45490: LD_EXP 107
45494: PUSH
45495: LD_VAR 0 2
45499: ARRAY
45500: PPUSH
45501: LD_VAR 0 4
45505: PPUSH
45506: CALL 104879 0 2
45510: ST_TO_ADDR
// if not tmp2 then
45511: LD_VAR 0 5
45515: NOT
45516: IFFALSE 45520
// continue ;
45518: GO 45185
// tw := tmp2 [ 1 ] ;
45520: LD_ADDR_VAR 0 7
45524: PUSH
45525: LD_VAR 0 5
45529: PUSH
45530: LD_INT 1
45532: ARRAY
45533: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45534: LD_ADDR_VAR 0 9
45538: PUSH
45539: LD_VAR 0 5
45543: PUSH
45544: LD_INT 2
45546: ARRAY
45547: ST_TO_ADDR
// end ; if not weapon then
45548: LD_VAR 0 9
45552: NOT
45553: IFFALSE 45557
// continue ;
45555: GO 45185
// ComPlaceWeapon ( tw , weapon ) ;
45557: LD_VAR 0 7
45561: PPUSH
45562: LD_VAR 0 9
45566: PPUSH
45567: CALL_OW 148
// end ;
45571: GO 45185
45573: POP
45574: POP
// end ;
45575: LD_VAR 0 1
45579: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45580: LD_INT 0
45582: PPUSH
45583: PPUSH
45584: PPUSH
45585: PPUSH
45586: PPUSH
45587: PPUSH
// if not mc_bases then
45588: LD_EXP 99
45592: NOT
45593: IFFALSE 45597
// exit ;
45595: GO 46609
// for i = 1 to mc_bases do
45597: LD_ADDR_VAR 0 2
45601: PUSH
45602: DOUBLE
45603: LD_INT 1
45605: DEC
45606: ST_TO_ADDR
45607: LD_EXP 99
45611: PUSH
45612: FOR_TO
45613: IFFALSE 46607
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45615: LD_EXP 112
45619: PUSH
45620: LD_VAR 0 2
45624: ARRAY
45625: NOT
45626: PUSH
45627: LD_EXP 112
45631: PUSH
45632: LD_VAR 0 2
45636: ARRAY
45637: PUSH
45638: LD_EXP 113
45642: PUSH
45643: LD_VAR 0 2
45647: ARRAY
45648: EQUAL
45649: OR
45650: IFFALSE 45654
// continue ;
45652: GO 45612
// if mc_miners [ i ] then
45654: LD_EXP 113
45658: PUSH
45659: LD_VAR 0 2
45663: ARRAY
45664: IFFALSE 46294
// begin k := 1 ;
45666: LD_ADDR_VAR 0 4
45670: PUSH
45671: LD_INT 1
45673: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
45674: LD_ADDR_VAR 0 3
45678: PUSH
45679: DOUBLE
45680: LD_EXP 113
45684: PUSH
45685: LD_VAR 0 2
45689: ARRAY
45690: INC
45691: ST_TO_ADDR
45692: LD_INT 1
45694: PUSH
45695: FOR_DOWNTO
45696: IFFALSE 46292
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
45698: LD_EXP 113
45702: PUSH
45703: LD_VAR 0 2
45707: ARRAY
45708: PUSH
45709: LD_VAR 0 3
45713: ARRAY
45714: PPUSH
45715: CALL_OW 301
45719: PUSH
45720: LD_EXP 113
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: PUSH
45731: LD_VAR 0 3
45735: ARRAY
45736: PPUSH
45737: CALL_OW 257
45741: PUSH
45742: LD_INT 1
45744: NONEQUAL
45745: OR
45746: IFFALSE 45809
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
45748: LD_ADDR_VAR 0 5
45752: PUSH
45753: LD_EXP 113
45757: PUSH
45758: LD_VAR 0 2
45762: ARRAY
45763: PUSH
45764: LD_EXP 113
45768: PUSH
45769: LD_VAR 0 2
45773: ARRAY
45774: PUSH
45775: LD_VAR 0 3
45779: ARRAY
45780: DIFF
45781: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
45782: LD_ADDR_EXP 113
45786: PUSH
45787: LD_EXP 113
45791: PPUSH
45792: LD_VAR 0 2
45796: PPUSH
45797: LD_VAR 0 5
45801: PPUSH
45802: CALL_OW 1
45806: ST_TO_ADDR
// continue ;
45807: GO 45695
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
45809: LD_EXP 113
45813: PUSH
45814: LD_VAR 0 2
45818: ARRAY
45819: PUSH
45820: LD_VAR 0 3
45824: ARRAY
45825: PPUSH
45826: CALL 69644 0 1
45830: PUSH
45831: LD_EXP 113
45835: PUSH
45836: LD_VAR 0 2
45840: ARRAY
45841: PUSH
45842: LD_VAR 0 3
45846: ARRAY
45847: PPUSH
45848: CALL_OW 255
45852: PPUSH
45853: LD_EXP 112
45857: PUSH
45858: LD_VAR 0 2
45862: ARRAY
45863: PUSH
45864: LD_VAR 0 4
45868: ARRAY
45869: PUSH
45870: LD_INT 1
45872: ARRAY
45873: PPUSH
45874: LD_EXP 112
45878: PUSH
45879: LD_VAR 0 2
45883: ARRAY
45884: PUSH
45885: LD_VAR 0 4
45889: ARRAY
45890: PUSH
45891: LD_INT 2
45893: ARRAY
45894: PPUSH
45895: LD_INT 15
45897: PPUSH
45898: CALL 70604 0 4
45902: PUSH
45903: LD_INT 4
45905: ARRAY
45906: PUSH
45907: LD_EXP 113
45911: PUSH
45912: LD_VAR 0 2
45916: ARRAY
45917: PUSH
45918: LD_VAR 0 3
45922: ARRAY
45923: PPUSH
45924: LD_INT 10
45926: PPUSH
45927: CALL 72301 0 2
45931: PUSH
45932: LD_INT 4
45934: ARRAY
45935: OR
45936: AND
45937: IFFALSE 45960
// ComStop ( mc_miners [ i ] [ j ] ) ;
45939: LD_EXP 113
45943: PUSH
45944: LD_VAR 0 2
45948: ARRAY
45949: PUSH
45950: LD_VAR 0 3
45954: ARRAY
45955: PPUSH
45956: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
45960: LD_EXP 113
45964: PUSH
45965: LD_VAR 0 2
45969: ARRAY
45970: PUSH
45971: LD_VAR 0 3
45975: ARRAY
45976: PPUSH
45977: CALL_OW 257
45981: PUSH
45982: LD_INT 1
45984: EQUAL
45985: PUSH
45986: LD_EXP 113
45990: PUSH
45991: LD_VAR 0 2
45995: ARRAY
45996: PUSH
45997: LD_VAR 0 3
46001: ARRAY
46002: PPUSH
46003: CALL_OW 459
46007: NOT
46008: AND
46009: PUSH
46010: LD_EXP 113
46014: PUSH
46015: LD_VAR 0 2
46019: ARRAY
46020: PUSH
46021: LD_VAR 0 3
46025: ARRAY
46026: PPUSH
46027: CALL_OW 255
46031: PPUSH
46032: LD_EXP 112
46036: PUSH
46037: LD_VAR 0 2
46041: ARRAY
46042: PUSH
46043: LD_VAR 0 4
46047: ARRAY
46048: PUSH
46049: LD_INT 1
46051: ARRAY
46052: PPUSH
46053: LD_EXP 112
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_VAR 0 4
46068: ARRAY
46069: PUSH
46070: LD_INT 2
46072: ARRAY
46073: PPUSH
46074: LD_INT 15
46076: PPUSH
46077: CALL 70604 0 4
46081: PUSH
46082: LD_INT 4
46084: ARRAY
46085: PUSH
46086: LD_INT 0
46088: EQUAL
46089: AND
46090: PUSH
46091: LD_EXP 113
46095: PUSH
46096: LD_VAR 0 2
46100: ARRAY
46101: PUSH
46102: LD_VAR 0 3
46106: ARRAY
46107: PPUSH
46108: CALL_OW 314
46112: NOT
46113: AND
46114: IFFALSE 46290
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46116: LD_EXP 113
46120: PUSH
46121: LD_VAR 0 2
46125: ARRAY
46126: PUSH
46127: LD_VAR 0 3
46131: ARRAY
46132: PPUSH
46133: CALL_OW 310
46137: IFFALSE 46160
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46139: LD_EXP 113
46143: PUSH
46144: LD_VAR 0 2
46148: ARRAY
46149: PUSH
46150: LD_VAR 0 3
46154: ARRAY
46155: PPUSH
46156: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46160: LD_EXP 113
46164: PUSH
46165: LD_VAR 0 2
46169: ARRAY
46170: PUSH
46171: LD_VAR 0 3
46175: ARRAY
46176: PPUSH
46177: CALL_OW 314
46181: NOT
46182: IFFALSE 46250
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46184: LD_EXP 113
46188: PUSH
46189: LD_VAR 0 2
46193: ARRAY
46194: PUSH
46195: LD_VAR 0 3
46199: ARRAY
46200: PPUSH
46201: LD_EXP 112
46205: PUSH
46206: LD_VAR 0 2
46210: ARRAY
46211: PUSH
46212: LD_VAR 0 4
46216: ARRAY
46217: PUSH
46218: LD_INT 1
46220: ARRAY
46221: PPUSH
46222: LD_EXP 112
46226: PUSH
46227: LD_VAR 0 2
46231: ARRAY
46232: PUSH
46233: LD_VAR 0 4
46237: ARRAY
46238: PUSH
46239: LD_INT 2
46241: ARRAY
46242: PPUSH
46243: LD_INT 0
46245: PPUSH
46246: CALL_OW 193
// k := k + 1 ;
46250: LD_ADDR_VAR 0 4
46254: PUSH
46255: LD_VAR 0 4
46259: PUSH
46260: LD_INT 1
46262: PLUS
46263: ST_TO_ADDR
// if k > mc_mines [ i ] then
46264: LD_VAR 0 4
46268: PUSH
46269: LD_EXP 112
46273: PUSH
46274: LD_VAR 0 2
46278: ARRAY
46279: GREATER
46280: IFFALSE 46290
// k := 1 ;
46282: LD_ADDR_VAR 0 4
46286: PUSH
46287: LD_INT 1
46289: ST_TO_ADDR
// end ; end ;
46290: GO 45695
46292: POP
46293: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46294: LD_ADDR_VAR 0 5
46298: PUSH
46299: LD_EXP 99
46303: PUSH
46304: LD_VAR 0 2
46308: ARRAY
46309: PPUSH
46310: LD_INT 2
46312: PUSH
46313: LD_INT 30
46315: PUSH
46316: LD_INT 4
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 30
46325: PUSH
46326: LD_INT 5
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: LD_INT 30
46335: PUSH
46336: LD_INT 32
46338: PUSH
46339: EMPTY
46340: LIST
46341: LIST
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: PPUSH
46349: CALL_OW 72
46353: ST_TO_ADDR
// if not tmp then
46354: LD_VAR 0 5
46358: NOT
46359: IFFALSE 46363
// continue ;
46361: GO 45612
// list := [ ] ;
46363: LD_ADDR_VAR 0 6
46367: PUSH
46368: EMPTY
46369: ST_TO_ADDR
// for j in tmp do
46370: LD_ADDR_VAR 0 3
46374: PUSH
46375: LD_VAR 0 5
46379: PUSH
46380: FOR_IN
46381: IFFALSE 46450
// begin for k in UnitsInside ( j ) do
46383: LD_ADDR_VAR 0 4
46387: PUSH
46388: LD_VAR 0 3
46392: PPUSH
46393: CALL_OW 313
46397: PUSH
46398: FOR_IN
46399: IFFALSE 46446
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46401: LD_VAR 0 4
46405: PPUSH
46406: CALL_OW 257
46410: PUSH
46411: LD_INT 1
46413: EQUAL
46414: PUSH
46415: LD_VAR 0 4
46419: PPUSH
46420: CALL_OW 459
46424: NOT
46425: AND
46426: IFFALSE 46444
// list := list ^ k ;
46428: LD_ADDR_VAR 0 6
46432: PUSH
46433: LD_VAR 0 6
46437: PUSH
46438: LD_VAR 0 4
46442: ADD
46443: ST_TO_ADDR
46444: GO 46398
46446: POP
46447: POP
// end ;
46448: GO 46380
46450: POP
46451: POP
// list := list diff mc_miners [ i ] ;
46452: LD_ADDR_VAR 0 6
46456: PUSH
46457: LD_VAR 0 6
46461: PUSH
46462: LD_EXP 113
46466: PUSH
46467: LD_VAR 0 2
46471: ARRAY
46472: DIFF
46473: ST_TO_ADDR
// if not list then
46474: LD_VAR 0 6
46478: NOT
46479: IFFALSE 46483
// continue ;
46481: GO 45612
// k := mc_mines [ i ] - mc_miners [ i ] ;
46483: LD_ADDR_VAR 0 4
46487: PUSH
46488: LD_EXP 112
46492: PUSH
46493: LD_VAR 0 2
46497: ARRAY
46498: PUSH
46499: LD_EXP 113
46503: PUSH
46504: LD_VAR 0 2
46508: ARRAY
46509: MINUS
46510: ST_TO_ADDR
// if k > list then
46511: LD_VAR 0 4
46515: PUSH
46516: LD_VAR 0 6
46520: GREATER
46521: IFFALSE 46533
// k := list ;
46523: LD_ADDR_VAR 0 4
46527: PUSH
46528: LD_VAR 0 6
46532: ST_TO_ADDR
// for j = 1 to k do
46533: LD_ADDR_VAR 0 3
46537: PUSH
46538: DOUBLE
46539: LD_INT 1
46541: DEC
46542: ST_TO_ADDR
46543: LD_VAR 0 4
46547: PUSH
46548: FOR_TO
46549: IFFALSE 46603
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46551: LD_ADDR_EXP 113
46555: PUSH
46556: LD_EXP 113
46560: PPUSH
46561: LD_VAR 0 2
46565: PUSH
46566: LD_EXP 113
46570: PUSH
46571: LD_VAR 0 2
46575: ARRAY
46576: PUSH
46577: LD_INT 1
46579: PLUS
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PPUSH
46585: LD_VAR 0 6
46589: PUSH
46590: LD_VAR 0 3
46594: ARRAY
46595: PPUSH
46596: CALL 69708 0 3
46600: ST_TO_ADDR
46601: GO 46548
46603: POP
46604: POP
// end ;
46605: GO 45612
46607: POP
46608: POP
// end ;
46609: LD_VAR 0 1
46613: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46614: LD_INT 0
46616: PPUSH
46617: PPUSH
46618: PPUSH
46619: PPUSH
46620: PPUSH
46621: PPUSH
46622: PPUSH
46623: PPUSH
46624: PPUSH
46625: PPUSH
// if not mc_bases then
46626: LD_EXP 99
46630: NOT
46631: IFFALSE 46635
// exit ;
46633: GO 48366
// for i = 1 to mc_bases do
46635: LD_ADDR_VAR 0 2
46639: PUSH
46640: DOUBLE
46641: LD_INT 1
46643: DEC
46644: ST_TO_ADDR
46645: LD_EXP 99
46649: PUSH
46650: FOR_TO
46651: IFFALSE 48364
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
46653: LD_EXP 99
46657: PUSH
46658: LD_VAR 0 2
46662: ARRAY
46663: NOT
46664: PUSH
46665: LD_EXP 106
46669: PUSH
46670: LD_VAR 0 2
46674: ARRAY
46675: OR
46676: IFFALSE 46680
// continue ;
46678: GO 46650
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
46680: LD_EXP 115
46684: PUSH
46685: LD_VAR 0 2
46689: ARRAY
46690: NOT
46691: PUSH
46692: LD_EXP 116
46696: PUSH
46697: LD_VAR 0 2
46701: ARRAY
46702: AND
46703: IFFALSE 46741
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
46705: LD_ADDR_EXP 116
46709: PUSH
46710: LD_EXP 116
46714: PPUSH
46715: LD_VAR 0 2
46719: PPUSH
46720: EMPTY
46721: PPUSH
46722: CALL_OW 1
46726: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
46727: LD_VAR 0 2
46731: PPUSH
46732: LD_INT 107
46734: PPUSH
46735: CALL 37830 0 2
// continue ;
46739: GO 46650
// end ; target := [ ] ;
46741: LD_ADDR_VAR 0 6
46745: PUSH
46746: EMPTY
46747: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
46748: LD_ADDR_VAR 0 3
46752: PUSH
46753: DOUBLE
46754: LD_EXP 115
46758: PUSH
46759: LD_VAR 0 2
46763: ARRAY
46764: INC
46765: ST_TO_ADDR
46766: LD_INT 1
46768: PUSH
46769: FOR_DOWNTO
46770: IFFALSE 47030
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
46772: LD_EXP 115
46776: PUSH
46777: LD_VAR 0 2
46781: ARRAY
46782: PUSH
46783: LD_VAR 0 3
46787: ARRAY
46788: PUSH
46789: LD_INT 2
46791: ARRAY
46792: PPUSH
46793: LD_EXP 115
46797: PUSH
46798: LD_VAR 0 2
46802: ARRAY
46803: PUSH
46804: LD_VAR 0 3
46808: ARRAY
46809: PUSH
46810: LD_INT 3
46812: ARRAY
46813: PPUSH
46814: CALL_OW 488
46818: PUSH
46819: LD_EXP 115
46823: PUSH
46824: LD_VAR 0 2
46828: ARRAY
46829: PUSH
46830: LD_VAR 0 3
46834: ARRAY
46835: PUSH
46836: LD_INT 2
46838: ARRAY
46839: PPUSH
46840: LD_EXP 115
46844: PUSH
46845: LD_VAR 0 2
46849: ARRAY
46850: PUSH
46851: LD_VAR 0 3
46855: ARRAY
46856: PUSH
46857: LD_INT 3
46859: ARRAY
46860: PPUSH
46861: CALL_OW 284
46865: PUSH
46866: LD_INT 0
46868: EQUAL
46869: AND
46870: IFFALSE 46925
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
46872: LD_ADDR_VAR 0 5
46876: PUSH
46877: LD_EXP 115
46881: PUSH
46882: LD_VAR 0 2
46886: ARRAY
46887: PPUSH
46888: LD_VAR 0 3
46892: PPUSH
46893: CALL_OW 3
46897: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
46898: LD_ADDR_EXP 115
46902: PUSH
46903: LD_EXP 115
46907: PPUSH
46908: LD_VAR 0 2
46912: PPUSH
46913: LD_VAR 0 5
46917: PPUSH
46918: CALL_OW 1
46922: ST_TO_ADDR
// continue ;
46923: GO 46769
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
46925: LD_EXP 99
46929: PUSH
46930: LD_VAR 0 2
46934: ARRAY
46935: PUSH
46936: LD_INT 1
46938: ARRAY
46939: PPUSH
46940: CALL_OW 255
46944: PPUSH
46945: LD_EXP 115
46949: PUSH
46950: LD_VAR 0 2
46954: ARRAY
46955: PUSH
46956: LD_VAR 0 3
46960: ARRAY
46961: PUSH
46962: LD_INT 2
46964: ARRAY
46965: PPUSH
46966: LD_EXP 115
46970: PUSH
46971: LD_VAR 0 2
46975: ARRAY
46976: PUSH
46977: LD_VAR 0 3
46981: ARRAY
46982: PUSH
46983: LD_INT 3
46985: ARRAY
46986: PPUSH
46987: LD_INT 30
46989: PPUSH
46990: CALL 70604 0 4
46994: PUSH
46995: LD_INT 4
46997: ARRAY
46998: PUSH
46999: LD_INT 0
47001: EQUAL
47002: IFFALSE 47028
// begin target := mc_crates [ i ] [ j ] ;
47004: LD_ADDR_VAR 0 6
47008: PUSH
47009: LD_EXP 115
47013: PUSH
47014: LD_VAR 0 2
47018: ARRAY
47019: PUSH
47020: LD_VAR 0 3
47024: ARRAY
47025: ST_TO_ADDR
// break ;
47026: GO 47030
// end ; end ;
47028: GO 46769
47030: POP
47031: POP
// if not target then
47032: LD_VAR 0 6
47036: NOT
47037: IFFALSE 47041
// continue ;
47039: GO 46650
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47041: LD_ADDR_VAR 0 7
47045: PUSH
47046: LD_EXP 118
47050: PUSH
47051: LD_VAR 0 2
47055: ARRAY
47056: PPUSH
47057: LD_INT 2
47059: PUSH
47060: LD_INT 3
47062: PUSH
47063: LD_INT 58
47065: PUSH
47066: EMPTY
47067: LIST
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: LD_INT 61
47075: PUSH
47076: EMPTY
47077: LIST
47078: PUSH
47079: LD_INT 33
47081: PUSH
47082: LD_INT 5
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 33
47091: PUSH
47092: LD_INT 3
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: PUSH
47106: LD_INT 2
47108: PUSH
47109: LD_INT 34
47111: PUSH
47112: LD_INT 32
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: PUSH
47119: LD_INT 34
47121: PUSH
47122: LD_INT 51
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: PUSH
47129: LD_INT 34
47131: PUSH
47132: LD_INT 12
47134: PUSH
47135: EMPTY
47136: LIST
47137: LIST
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PPUSH
47149: CALL_OW 72
47153: ST_TO_ADDR
// if not cargo then
47154: LD_VAR 0 7
47158: NOT
47159: IFFALSE 47802
// begin if mc_crates_collector [ i ] < 5 then
47161: LD_EXP 116
47165: PUSH
47166: LD_VAR 0 2
47170: ARRAY
47171: PUSH
47172: LD_INT 5
47174: LESS
47175: IFFALSE 47541
// begin if mc_ape [ i ] then
47177: LD_EXP 128
47181: PUSH
47182: LD_VAR 0 2
47186: ARRAY
47187: IFFALSE 47234
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47189: LD_ADDR_VAR 0 5
47193: PUSH
47194: LD_EXP 128
47198: PUSH
47199: LD_VAR 0 2
47203: ARRAY
47204: PPUSH
47205: LD_INT 25
47207: PUSH
47208: LD_INT 16
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: LD_INT 24
47217: PUSH
47218: LD_INT 750
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PPUSH
47229: CALL_OW 72
47233: ST_TO_ADDR
// if not tmp then
47234: LD_VAR 0 5
47238: NOT
47239: IFFALSE 47286
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47241: LD_ADDR_VAR 0 5
47245: PUSH
47246: LD_EXP 99
47250: PUSH
47251: LD_VAR 0 2
47255: ARRAY
47256: PPUSH
47257: LD_INT 25
47259: PUSH
47260: LD_INT 2
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PUSH
47267: LD_INT 24
47269: PUSH
47270: LD_INT 750
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PPUSH
47281: CALL_OW 72
47285: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47286: LD_EXP 128
47290: PUSH
47291: LD_VAR 0 2
47295: ARRAY
47296: PUSH
47297: LD_EXP 99
47301: PUSH
47302: LD_VAR 0 2
47306: ARRAY
47307: PPUSH
47308: LD_INT 25
47310: PUSH
47311: LD_INT 2
47313: PUSH
47314: EMPTY
47315: LIST
47316: LIST
47317: PUSH
47318: LD_INT 24
47320: PUSH
47321: LD_INT 750
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: PPUSH
47332: CALL_OW 72
47336: AND
47337: PUSH
47338: LD_VAR 0 5
47342: PUSH
47343: LD_INT 5
47345: LESS
47346: AND
47347: IFFALSE 47429
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47349: LD_ADDR_VAR 0 3
47353: PUSH
47354: LD_EXP 99
47358: PUSH
47359: LD_VAR 0 2
47363: ARRAY
47364: PPUSH
47365: LD_INT 25
47367: PUSH
47368: LD_INT 2
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: LD_INT 24
47377: PUSH
47378: LD_INT 750
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PPUSH
47389: CALL_OW 72
47393: PUSH
47394: FOR_IN
47395: IFFALSE 47427
// begin tmp := tmp union j ;
47397: LD_ADDR_VAR 0 5
47401: PUSH
47402: LD_VAR 0 5
47406: PUSH
47407: LD_VAR 0 3
47411: UNION
47412: ST_TO_ADDR
// if tmp >= 5 then
47413: LD_VAR 0 5
47417: PUSH
47418: LD_INT 5
47420: GREATEREQUAL
47421: IFFALSE 47425
// break ;
47423: GO 47427
// end ;
47425: GO 47394
47427: POP
47428: POP
// end ; if not tmp then
47429: LD_VAR 0 5
47433: NOT
47434: IFFALSE 47438
// continue ;
47436: GO 46650
// for j in tmp do
47438: LD_ADDR_VAR 0 3
47442: PUSH
47443: LD_VAR 0 5
47447: PUSH
47448: FOR_IN
47449: IFFALSE 47539
// if not GetTag ( j ) then
47451: LD_VAR 0 3
47455: PPUSH
47456: CALL_OW 110
47460: NOT
47461: IFFALSE 47537
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47463: LD_ADDR_EXP 116
47467: PUSH
47468: LD_EXP 116
47472: PPUSH
47473: LD_VAR 0 2
47477: PUSH
47478: LD_EXP 116
47482: PUSH
47483: LD_VAR 0 2
47487: ARRAY
47488: PUSH
47489: LD_INT 1
47491: PLUS
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: PPUSH
47497: LD_VAR 0 3
47501: PPUSH
47502: CALL 69708 0 3
47506: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47507: LD_VAR 0 3
47511: PPUSH
47512: LD_INT 107
47514: PPUSH
47515: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47519: LD_EXP 116
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: PUSH
47530: LD_INT 5
47532: GREATEREQUAL
47533: IFFALSE 47537
// break ;
47535: GO 47539
// end ;
47537: GO 47448
47539: POP
47540: POP
// end ; if mc_crates_collector [ i ] and target then
47541: LD_EXP 116
47545: PUSH
47546: LD_VAR 0 2
47550: ARRAY
47551: PUSH
47552: LD_VAR 0 6
47556: AND
47557: IFFALSE 47800
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47559: LD_EXP 116
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: PUSH
47570: LD_VAR 0 6
47574: PUSH
47575: LD_INT 1
47577: ARRAY
47578: LESS
47579: IFFALSE 47599
// tmp := mc_crates_collector [ i ] else
47581: LD_ADDR_VAR 0 5
47585: PUSH
47586: LD_EXP 116
47590: PUSH
47591: LD_VAR 0 2
47595: ARRAY
47596: ST_TO_ADDR
47597: GO 47613
// tmp := target [ 1 ] ;
47599: LD_ADDR_VAR 0 5
47603: PUSH
47604: LD_VAR 0 6
47608: PUSH
47609: LD_INT 1
47611: ARRAY
47612: ST_TO_ADDR
// k := 0 ;
47613: LD_ADDR_VAR 0 4
47617: PUSH
47618: LD_INT 0
47620: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47621: LD_ADDR_VAR 0 3
47625: PUSH
47626: LD_EXP 116
47630: PUSH
47631: LD_VAR 0 2
47635: ARRAY
47636: PUSH
47637: FOR_IN
47638: IFFALSE 47798
// begin k := k + 1 ;
47640: LD_ADDR_VAR 0 4
47644: PUSH
47645: LD_VAR 0 4
47649: PUSH
47650: LD_INT 1
47652: PLUS
47653: ST_TO_ADDR
// if k > tmp then
47654: LD_VAR 0 4
47658: PUSH
47659: LD_VAR 0 5
47663: GREATER
47664: IFFALSE 47668
// break ;
47666: GO 47798
// if not GetClass ( j ) in [ 2 , 16 ] then
47668: LD_VAR 0 3
47672: PPUSH
47673: CALL_OW 257
47677: PUSH
47678: LD_INT 2
47680: PUSH
47681: LD_INT 16
47683: PUSH
47684: EMPTY
47685: LIST
47686: LIST
47687: IN
47688: NOT
47689: IFFALSE 47742
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
47691: LD_ADDR_EXP 116
47695: PUSH
47696: LD_EXP 116
47700: PPUSH
47701: LD_VAR 0 2
47705: PPUSH
47706: LD_EXP 116
47710: PUSH
47711: LD_VAR 0 2
47715: ARRAY
47716: PUSH
47717: LD_VAR 0 3
47721: DIFF
47722: PPUSH
47723: CALL_OW 1
47727: ST_TO_ADDR
// SetTag ( j , 0 ) ;
47728: LD_VAR 0 3
47732: PPUSH
47733: LD_INT 0
47735: PPUSH
47736: CALL_OW 109
// continue ;
47740: GO 47637
// end ; if IsInUnit ( j ) then
47742: LD_VAR 0 3
47746: PPUSH
47747: CALL_OW 310
47751: IFFALSE 47762
// ComExitBuilding ( j ) ;
47753: LD_VAR 0 3
47757: PPUSH
47758: CALL_OW 122
// wait ( 3 ) ;
47762: LD_INT 3
47764: PPUSH
47765: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47769: LD_VAR 0 3
47773: PPUSH
47774: LD_VAR 0 6
47778: PUSH
47779: LD_INT 2
47781: ARRAY
47782: PPUSH
47783: LD_VAR 0 6
47787: PUSH
47788: LD_INT 3
47790: ARRAY
47791: PPUSH
47792: CALL_OW 117
// end ;
47796: GO 47637
47798: POP
47799: POP
// end ; end else
47800: GO 48362
// begin for j in cargo do
47802: LD_ADDR_VAR 0 3
47806: PUSH
47807: LD_VAR 0 7
47811: PUSH
47812: FOR_IN
47813: IFFALSE 48360
// begin if GetTag ( j ) <> 0 then
47815: LD_VAR 0 3
47819: PPUSH
47820: CALL_OW 110
47824: PUSH
47825: LD_INT 0
47827: NONEQUAL
47828: IFFALSE 47832
// continue ;
47830: GO 47812
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
47832: LD_VAR 0 3
47836: PPUSH
47837: CALL_OW 256
47841: PUSH
47842: LD_INT 1000
47844: LESS
47845: PUSH
47846: LD_VAR 0 3
47850: PPUSH
47851: LD_EXP 123
47855: PUSH
47856: LD_VAR 0 2
47860: ARRAY
47861: PPUSH
47862: CALL_OW 308
47866: NOT
47867: AND
47868: IFFALSE 47890
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47870: LD_VAR 0 3
47874: PPUSH
47875: LD_EXP 123
47879: PUSH
47880: LD_VAR 0 2
47884: ARRAY
47885: PPUSH
47886: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
47890: LD_VAR 0 3
47894: PPUSH
47895: CALL_OW 256
47899: PUSH
47900: LD_INT 1000
47902: LESS
47903: PUSH
47904: LD_VAR 0 3
47908: PPUSH
47909: LD_EXP 123
47913: PUSH
47914: LD_VAR 0 2
47918: ARRAY
47919: PPUSH
47920: CALL_OW 308
47924: AND
47925: IFFALSE 47929
// continue ;
47927: GO 47812
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
47929: LD_VAR 0 3
47933: PPUSH
47934: CALL_OW 262
47938: PUSH
47939: LD_INT 2
47941: EQUAL
47942: PUSH
47943: LD_VAR 0 3
47947: PPUSH
47948: CALL_OW 261
47952: PUSH
47953: LD_INT 15
47955: LESS
47956: AND
47957: IFFALSE 47961
// continue ;
47959: GO 47812
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
47961: LD_VAR 0 3
47965: PPUSH
47966: CALL_OW 262
47970: PUSH
47971: LD_INT 1
47973: EQUAL
47974: PUSH
47975: LD_VAR 0 3
47979: PPUSH
47980: CALL_OW 261
47984: PUSH
47985: LD_INT 10
47987: LESS
47988: AND
47989: IFFALSE 48299
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47991: LD_ADDR_VAR 0 8
47995: PUSH
47996: LD_EXP 99
48000: PUSH
48001: LD_VAR 0 2
48005: ARRAY
48006: PPUSH
48007: LD_INT 2
48009: PUSH
48010: LD_INT 30
48012: PUSH
48013: LD_INT 0
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: LD_INT 30
48022: PUSH
48023: LD_INT 1
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: LIST
48034: PPUSH
48035: CALL_OW 72
48039: ST_TO_ADDR
// if not depot then
48040: LD_VAR 0 8
48044: NOT
48045: IFFALSE 48049
// continue ;
48047: GO 47812
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48049: LD_VAR 0 3
48053: PPUSH
48054: LD_VAR 0 8
48058: PPUSH
48059: LD_VAR 0 3
48063: PPUSH
48064: CALL_OW 74
48068: PPUSH
48069: CALL_OW 296
48073: PUSH
48074: LD_INT 6
48076: LESS
48077: IFFALSE 48093
// SetFuel ( j , 100 ) else
48079: LD_VAR 0 3
48083: PPUSH
48084: LD_INT 100
48086: PPUSH
48087: CALL_OW 240
48091: GO 48299
// if GetFuel ( j ) = 0 then
48093: LD_VAR 0 3
48097: PPUSH
48098: CALL_OW 261
48102: PUSH
48103: LD_INT 0
48105: EQUAL
48106: IFFALSE 48299
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48108: LD_ADDR_EXP 118
48112: PUSH
48113: LD_EXP 118
48117: PPUSH
48118: LD_VAR 0 2
48122: PPUSH
48123: LD_EXP 118
48127: PUSH
48128: LD_VAR 0 2
48132: ARRAY
48133: PUSH
48134: LD_VAR 0 3
48138: DIFF
48139: PPUSH
48140: CALL_OW 1
48144: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48145: LD_VAR 0 3
48149: PPUSH
48150: CALL_OW 263
48154: PUSH
48155: LD_INT 1
48157: EQUAL
48158: IFFALSE 48174
// ComExitVehicle ( IsInUnit ( j ) ) ;
48160: LD_VAR 0 3
48164: PPUSH
48165: CALL_OW 310
48169: PPUSH
48170: CALL_OW 121
// if GetControl ( j ) = control_remote then
48174: LD_VAR 0 3
48178: PPUSH
48179: CALL_OW 263
48183: PUSH
48184: LD_INT 2
48186: EQUAL
48187: IFFALSE 48198
// ComUnlink ( j ) ;
48189: LD_VAR 0 3
48193: PPUSH
48194: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
48198: LD_ADDR_VAR 0 9
48202: PUSH
48203: LD_VAR 0 2
48207: PPUSH
48208: LD_INT 3
48210: PPUSH
48211: CALL 57345 0 2
48215: ST_TO_ADDR
// if fac then
48216: LD_VAR 0 9
48220: IFFALSE 48297
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48222: LD_ADDR_VAR 0 10
48226: PUSH
48227: LD_VAR 0 9
48231: PPUSH
48232: LD_VAR 0 3
48236: PPUSH
48237: CALL_OW 265
48241: PPUSH
48242: LD_VAR 0 3
48246: PPUSH
48247: CALL_OW 262
48251: PPUSH
48252: LD_VAR 0 3
48256: PPUSH
48257: CALL_OW 263
48261: PPUSH
48262: LD_VAR 0 3
48266: PPUSH
48267: CALL_OW 264
48271: PPUSH
48272: CALL 67301 0 5
48276: ST_TO_ADDR
// if components then
48277: LD_VAR 0 10
48281: IFFALSE 48297
// MC_InsertProduceList ( i , components ) ;
48283: LD_VAR 0 2
48287: PPUSH
48288: LD_VAR 0 10
48292: PPUSH
48293: CALL 56973 0 2
// end ; continue ;
48297: GO 47812
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48299: LD_VAR 0 3
48303: PPUSH
48304: LD_INT 1
48306: PPUSH
48307: CALL_OW 289
48311: PUSH
48312: LD_INT 100
48314: LESS
48315: PUSH
48316: LD_VAR 0 3
48320: PPUSH
48321: CALL_OW 314
48325: NOT
48326: AND
48327: IFFALSE 48356
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48329: LD_VAR 0 3
48333: PPUSH
48334: LD_VAR 0 6
48338: PUSH
48339: LD_INT 2
48341: ARRAY
48342: PPUSH
48343: LD_VAR 0 6
48347: PUSH
48348: LD_INT 3
48350: ARRAY
48351: PPUSH
48352: CALL_OW 117
// break ;
48356: GO 48360
// end ;
48358: GO 47812
48360: POP
48361: POP
// end ; end ;
48362: GO 46650
48364: POP
48365: POP
// end ;
48366: LD_VAR 0 1
48370: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48371: LD_INT 0
48373: PPUSH
48374: PPUSH
48375: PPUSH
48376: PPUSH
// if not mc_bases then
48377: LD_EXP 99
48381: NOT
48382: IFFALSE 48386
// exit ;
48384: GO 48547
// for i = 1 to mc_bases do
48386: LD_ADDR_VAR 0 2
48390: PUSH
48391: DOUBLE
48392: LD_INT 1
48394: DEC
48395: ST_TO_ADDR
48396: LD_EXP 99
48400: PUSH
48401: FOR_TO
48402: IFFALSE 48545
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48404: LD_ADDR_VAR 0 4
48408: PUSH
48409: LD_EXP 118
48413: PUSH
48414: LD_VAR 0 2
48418: ARRAY
48419: PUSH
48420: LD_EXP 121
48424: PUSH
48425: LD_VAR 0 2
48429: ARRAY
48430: UNION
48431: PPUSH
48432: LD_INT 33
48434: PUSH
48435: LD_INT 2
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PPUSH
48442: CALL_OW 72
48446: ST_TO_ADDR
// if tmp then
48447: LD_VAR 0 4
48451: IFFALSE 48543
// for j in tmp do
48453: LD_ADDR_VAR 0 3
48457: PUSH
48458: LD_VAR 0 4
48462: PUSH
48463: FOR_IN
48464: IFFALSE 48541
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48466: LD_VAR 0 3
48470: PPUSH
48471: CALL_OW 312
48475: NOT
48476: PUSH
48477: LD_VAR 0 3
48481: PPUSH
48482: CALL_OW 256
48486: PUSH
48487: LD_INT 250
48489: GREATEREQUAL
48490: AND
48491: IFFALSE 48504
// Connect ( j ) else
48493: LD_VAR 0 3
48497: PPUSH
48498: CALL 72641 0 1
48502: GO 48539
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48504: LD_VAR 0 3
48508: PPUSH
48509: CALL_OW 256
48513: PUSH
48514: LD_INT 250
48516: LESS
48517: PUSH
48518: LD_VAR 0 3
48522: PPUSH
48523: CALL_OW 312
48527: AND
48528: IFFALSE 48539
// ComUnlink ( j ) ;
48530: LD_VAR 0 3
48534: PPUSH
48535: CALL_OW 136
48539: GO 48463
48541: POP
48542: POP
// end ;
48543: GO 48401
48545: POP
48546: POP
// end ;
48547: LD_VAR 0 1
48551: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48552: LD_INT 0
48554: PPUSH
48555: PPUSH
48556: PPUSH
48557: PPUSH
48558: PPUSH
// if not mc_bases then
48559: LD_EXP 99
48563: NOT
48564: IFFALSE 48568
// exit ;
48566: GO 49028
// for i = 1 to mc_bases do
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: DOUBLE
48574: LD_INT 1
48576: DEC
48577: ST_TO_ADDR
48578: LD_EXP 99
48582: PUSH
48583: FOR_TO
48584: IFFALSE 49026
// begin if not mc_produce [ i ] then
48586: LD_EXP 120
48590: PUSH
48591: LD_VAR 0 2
48595: ARRAY
48596: NOT
48597: IFFALSE 48601
// continue ;
48599: GO 48583
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48601: LD_ADDR_VAR 0 5
48605: PUSH
48606: LD_EXP 99
48610: PUSH
48611: LD_VAR 0 2
48615: ARRAY
48616: PPUSH
48617: LD_INT 30
48619: PUSH
48620: LD_INT 3
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: PPUSH
48627: CALL_OW 72
48631: ST_TO_ADDR
// if not fac then
48632: LD_VAR 0 5
48636: NOT
48637: IFFALSE 48641
// continue ;
48639: GO 48583
// for j in fac do
48641: LD_ADDR_VAR 0 3
48645: PUSH
48646: LD_VAR 0 5
48650: PUSH
48651: FOR_IN
48652: IFFALSE 49022
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
48654: LD_VAR 0 3
48658: PPUSH
48659: CALL_OW 461
48663: PUSH
48664: LD_INT 2
48666: NONEQUAL
48667: PUSH
48668: LD_VAR 0 3
48672: PPUSH
48673: LD_INT 15
48675: PPUSH
48676: CALL 72301 0 2
48680: PUSH
48681: LD_INT 4
48683: ARRAY
48684: OR
48685: PUSH
48686: LD_VAR 0 3
48690: PPUSH
48691: CALL_OW 313
48695: PUSH
48696: LD_INT 0
48698: EQUAL
48699: OR
48700: IFFALSE 48704
// continue ;
48702: GO 48651
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
48704: LD_VAR 0 3
48708: PPUSH
48709: LD_EXP 120
48713: PUSH
48714: LD_VAR 0 2
48718: ARRAY
48719: PUSH
48720: LD_INT 1
48722: ARRAY
48723: PUSH
48724: LD_INT 1
48726: ARRAY
48727: PPUSH
48728: LD_EXP 120
48732: PUSH
48733: LD_VAR 0 2
48737: ARRAY
48738: PUSH
48739: LD_INT 1
48741: ARRAY
48742: PUSH
48743: LD_INT 2
48745: ARRAY
48746: PPUSH
48747: LD_EXP 120
48751: PUSH
48752: LD_VAR 0 2
48756: ARRAY
48757: PUSH
48758: LD_INT 1
48760: ARRAY
48761: PUSH
48762: LD_INT 3
48764: ARRAY
48765: PPUSH
48766: LD_EXP 120
48770: PUSH
48771: LD_VAR 0 2
48775: ARRAY
48776: PUSH
48777: LD_INT 1
48779: ARRAY
48780: PUSH
48781: LD_INT 4
48783: ARRAY
48784: PPUSH
48785: CALL_OW 448
48789: PUSH
48790: LD_VAR 0 3
48794: PPUSH
48795: LD_EXP 120
48799: PUSH
48800: LD_VAR 0 2
48804: ARRAY
48805: PUSH
48806: LD_INT 1
48808: ARRAY
48809: PUSH
48810: LD_INT 1
48812: ARRAY
48813: PUSH
48814: LD_EXP 120
48818: PUSH
48819: LD_VAR 0 2
48823: ARRAY
48824: PUSH
48825: LD_INT 1
48827: ARRAY
48828: PUSH
48829: LD_INT 2
48831: ARRAY
48832: PUSH
48833: LD_EXP 120
48837: PUSH
48838: LD_VAR 0 2
48842: ARRAY
48843: PUSH
48844: LD_INT 1
48846: ARRAY
48847: PUSH
48848: LD_INT 3
48850: ARRAY
48851: PUSH
48852: LD_EXP 120
48856: PUSH
48857: LD_VAR 0 2
48861: ARRAY
48862: PUSH
48863: LD_INT 1
48865: ARRAY
48866: PUSH
48867: LD_INT 4
48869: ARRAY
48870: PUSH
48871: EMPTY
48872: LIST
48873: LIST
48874: LIST
48875: LIST
48876: PPUSH
48877: CALL 75972 0 2
48881: AND
48882: IFFALSE 49020
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
48884: LD_VAR 0 3
48888: PPUSH
48889: LD_EXP 120
48893: PUSH
48894: LD_VAR 0 2
48898: ARRAY
48899: PUSH
48900: LD_INT 1
48902: ARRAY
48903: PUSH
48904: LD_INT 1
48906: ARRAY
48907: PPUSH
48908: LD_EXP 120
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: PUSH
48919: LD_INT 1
48921: ARRAY
48922: PUSH
48923: LD_INT 2
48925: ARRAY
48926: PPUSH
48927: LD_EXP 120
48931: PUSH
48932: LD_VAR 0 2
48936: ARRAY
48937: PUSH
48938: LD_INT 1
48940: ARRAY
48941: PUSH
48942: LD_INT 3
48944: ARRAY
48945: PPUSH
48946: LD_EXP 120
48950: PUSH
48951: LD_VAR 0 2
48955: ARRAY
48956: PUSH
48957: LD_INT 1
48959: ARRAY
48960: PUSH
48961: LD_INT 4
48963: ARRAY
48964: PPUSH
48965: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
48969: LD_ADDR_VAR 0 4
48973: PUSH
48974: LD_EXP 120
48978: PUSH
48979: LD_VAR 0 2
48983: ARRAY
48984: PPUSH
48985: LD_INT 1
48987: PPUSH
48988: CALL_OW 3
48992: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48993: LD_ADDR_EXP 120
48997: PUSH
48998: LD_EXP 120
49002: PPUSH
49003: LD_VAR 0 2
49007: PPUSH
49008: LD_VAR 0 4
49012: PPUSH
49013: CALL_OW 1
49017: ST_TO_ADDR
// break ;
49018: GO 49022
// end ; end ;
49020: GO 48651
49022: POP
49023: POP
// end ;
49024: GO 48583
49026: POP
49027: POP
// end ;
49028: LD_VAR 0 1
49032: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49033: LD_INT 0
49035: PPUSH
49036: PPUSH
49037: PPUSH
// if not mc_bases then
49038: LD_EXP 99
49042: NOT
49043: IFFALSE 49047
// exit ;
49045: GO 49136
// for i = 1 to mc_bases do
49047: LD_ADDR_VAR 0 2
49051: PUSH
49052: DOUBLE
49053: LD_INT 1
49055: DEC
49056: ST_TO_ADDR
49057: LD_EXP 99
49061: PUSH
49062: FOR_TO
49063: IFFALSE 49134
// begin if mc_attack [ i ] then
49065: LD_EXP 119
49069: PUSH
49070: LD_VAR 0 2
49074: ARRAY
49075: IFFALSE 49132
// begin tmp := mc_attack [ i ] [ 1 ] ;
49077: LD_ADDR_VAR 0 3
49081: PUSH
49082: LD_EXP 119
49086: PUSH
49087: LD_VAR 0 2
49091: ARRAY
49092: PUSH
49093: LD_INT 1
49095: ARRAY
49096: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49097: LD_ADDR_EXP 119
49101: PUSH
49102: LD_EXP 119
49106: PPUSH
49107: LD_VAR 0 2
49111: PPUSH
49112: EMPTY
49113: PPUSH
49114: CALL_OW 1
49118: ST_TO_ADDR
// Attack ( tmp ) ;
49119: LD_VAR 0 3
49123: PPUSH
49124: CALL 98185 0 1
// exit ;
49128: POP
49129: POP
49130: GO 49136
// end ; end ;
49132: GO 49062
49134: POP
49135: POP
// end ;
49136: LD_VAR 0 1
49140: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49141: LD_INT 0
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
// if not mc_bases then
49150: LD_EXP 99
49154: NOT
49155: IFFALSE 49159
// exit ;
49157: GO 49741
// for i = 1 to mc_bases do
49159: LD_ADDR_VAR 0 2
49163: PUSH
49164: DOUBLE
49165: LD_INT 1
49167: DEC
49168: ST_TO_ADDR
49169: LD_EXP 99
49173: PUSH
49174: FOR_TO
49175: IFFALSE 49739
// begin if not mc_bases [ i ] then
49177: LD_EXP 99
49181: PUSH
49182: LD_VAR 0 2
49186: ARRAY
49187: NOT
49188: IFFALSE 49192
// continue ;
49190: GO 49174
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49192: LD_ADDR_VAR 0 7
49196: PUSH
49197: LD_EXP 99
49201: PUSH
49202: LD_VAR 0 2
49206: ARRAY
49207: PUSH
49208: LD_INT 1
49210: ARRAY
49211: PPUSH
49212: CALL 66605 0 1
49216: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49217: LD_ADDR_EXP 122
49221: PUSH
49222: LD_EXP 122
49226: PPUSH
49227: LD_VAR 0 2
49231: PPUSH
49232: LD_EXP 99
49236: PUSH
49237: LD_VAR 0 2
49241: ARRAY
49242: PUSH
49243: LD_INT 1
49245: ARRAY
49246: PPUSH
49247: CALL_OW 255
49251: PPUSH
49252: LD_EXP 124
49256: PUSH
49257: LD_VAR 0 2
49261: ARRAY
49262: PPUSH
49263: CALL 64602 0 2
49267: PPUSH
49268: CALL_OW 1
49272: ST_TO_ADDR
// if not mc_scan [ i ] then
49273: LD_EXP 122
49277: PUSH
49278: LD_VAR 0 2
49282: ARRAY
49283: NOT
49284: IFFALSE 49439
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49286: LD_ADDR_VAR 0 4
49290: PUSH
49291: LD_EXP 99
49295: PUSH
49296: LD_VAR 0 2
49300: ARRAY
49301: PPUSH
49302: LD_INT 2
49304: PUSH
49305: LD_INT 25
49307: PUSH
49308: LD_INT 5
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PUSH
49315: LD_INT 25
49317: PUSH
49318: LD_INT 8
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PUSH
49325: LD_INT 25
49327: PUSH
49328: LD_INT 9
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: PPUSH
49341: CALL_OW 72
49345: ST_TO_ADDR
// if not tmp then
49346: LD_VAR 0 4
49350: NOT
49351: IFFALSE 49355
// continue ;
49353: GO 49174
// for j in tmp do
49355: LD_ADDR_VAR 0 3
49359: PUSH
49360: LD_VAR 0 4
49364: PUSH
49365: FOR_IN
49366: IFFALSE 49437
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49368: LD_VAR 0 3
49372: PPUSH
49373: CALL_OW 310
49377: PPUSH
49378: CALL_OW 266
49382: PUSH
49383: LD_INT 5
49385: EQUAL
49386: PUSH
49387: LD_VAR 0 3
49391: PPUSH
49392: CALL_OW 257
49396: PUSH
49397: LD_INT 1
49399: EQUAL
49400: AND
49401: PUSH
49402: LD_VAR 0 3
49406: PPUSH
49407: CALL_OW 459
49411: NOT
49412: AND
49413: PUSH
49414: LD_VAR 0 7
49418: AND
49419: IFFALSE 49435
// ComChangeProfession ( j , class ) ;
49421: LD_VAR 0 3
49425: PPUSH
49426: LD_VAR 0 7
49430: PPUSH
49431: CALL_OW 123
49435: GO 49365
49437: POP
49438: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49439: LD_EXP 122
49443: PUSH
49444: LD_VAR 0 2
49448: ARRAY
49449: PUSH
49450: LD_EXP 121
49454: PUSH
49455: LD_VAR 0 2
49459: ARRAY
49460: NOT
49461: AND
49462: PUSH
49463: LD_EXP 99
49467: PUSH
49468: LD_VAR 0 2
49472: ARRAY
49473: PPUSH
49474: LD_INT 30
49476: PUSH
49477: LD_INT 32
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: PPUSH
49484: CALL_OW 72
49488: NOT
49489: AND
49490: PUSH
49491: LD_EXP 99
49495: PUSH
49496: LD_VAR 0 2
49500: ARRAY
49501: PPUSH
49502: LD_INT 2
49504: PUSH
49505: LD_INT 30
49507: PUSH
49508: LD_INT 4
49510: PUSH
49511: EMPTY
49512: LIST
49513: LIST
49514: PUSH
49515: LD_INT 30
49517: PUSH
49518: LD_INT 5
49520: PUSH
49521: EMPTY
49522: LIST
49523: LIST
49524: PUSH
49525: EMPTY
49526: LIST
49527: LIST
49528: LIST
49529: PPUSH
49530: CALL_OW 72
49534: NOT
49535: AND
49536: IFFALSE 49668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49538: LD_ADDR_VAR 0 4
49542: PUSH
49543: LD_EXP 99
49547: PUSH
49548: LD_VAR 0 2
49552: ARRAY
49553: PPUSH
49554: LD_INT 2
49556: PUSH
49557: LD_INT 25
49559: PUSH
49560: LD_INT 1
49562: PUSH
49563: EMPTY
49564: LIST
49565: LIST
49566: PUSH
49567: LD_INT 25
49569: PUSH
49570: LD_INT 5
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: PUSH
49577: LD_INT 25
49579: PUSH
49580: LD_INT 8
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: PUSH
49587: LD_INT 25
49589: PUSH
49590: LD_INT 9
49592: PUSH
49593: EMPTY
49594: LIST
49595: LIST
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: PPUSH
49604: CALL_OW 72
49608: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49609: LD_ADDR_VAR 0 4
49613: PUSH
49614: LD_VAR 0 4
49618: PUSH
49619: LD_VAR 0 4
49623: PPUSH
49624: LD_INT 18
49626: PPUSH
49627: CALL 102968 0 2
49631: DIFF
49632: ST_TO_ADDR
// if tmp then
49633: LD_VAR 0 4
49637: IFFALSE 49668
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
49639: LD_VAR 0 2
49643: PPUSH
49644: LD_VAR 0 4
49648: PPUSH
49649: LD_EXP 124
49653: PUSH
49654: LD_VAR 0 2
49658: ARRAY
49659: PPUSH
49660: CALL 64637 0 3
// exit ;
49664: POP
49665: POP
49666: GO 49741
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
49668: LD_EXP 122
49672: PUSH
49673: LD_VAR 0 2
49677: ARRAY
49678: PUSH
49679: LD_EXP 121
49683: PUSH
49684: LD_VAR 0 2
49688: ARRAY
49689: AND
49690: IFFALSE 49737
// begin tmp := mc_defender [ i ] ;
49692: LD_ADDR_VAR 0 4
49696: PUSH
49697: LD_EXP 121
49701: PUSH
49702: LD_VAR 0 2
49706: ARRAY
49707: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
49708: LD_VAR 0 2
49712: PPUSH
49713: LD_VAR 0 4
49717: PPUSH
49718: LD_EXP 122
49722: PUSH
49723: LD_VAR 0 2
49727: ARRAY
49728: PPUSH
49729: CALL 65135 0 3
// exit ;
49733: POP
49734: POP
49735: GO 49741
// end ; end ;
49737: GO 49174
49739: POP
49740: POP
// end ;
49741: LD_VAR 0 1
49745: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
49746: LD_INT 0
49748: PPUSH
49749: PPUSH
49750: PPUSH
49751: PPUSH
49752: PPUSH
49753: PPUSH
49754: PPUSH
49755: PPUSH
49756: PPUSH
49757: PPUSH
49758: PPUSH
// if not mc_bases then
49759: LD_EXP 99
49763: NOT
49764: IFFALSE 49768
// exit ;
49766: GO 50855
// for i = 1 to mc_bases do
49768: LD_ADDR_VAR 0 2
49772: PUSH
49773: DOUBLE
49774: LD_INT 1
49776: DEC
49777: ST_TO_ADDR
49778: LD_EXP 99
49782: PUSH
49783: FOR_TO
49784: IFFALSE 50853
// begin tmp := mc_lab [ i ] ;
49786: LD_ADDR_VAR 0 6
49790: PUSH
49791: LD_EXP 132
49795: PUSH
49796: LD_VAR 0 2
49800: ARRAY
49801: ST_TO_ADDR
// if not tmp then
49802: LD_VAR 0 6
49806: NOT
49807: IFFALSE 49811
// continue ;
49809: GO 49783
// idle_lab := 0 ;
49811: LD_ADDR_VAR 0 11
49815: PUSH
49816: LD_INT 0
49818: ST_TO_ADDR
// for j in tmp do
49819: LD_ADDR_VAR 0 3
49823: PUSH
49824: LD_VAR 0 6
49828: PUSH
49829: FOR_IN
49830: IFFALSE 50849
// begin researching := false ;
49832: LD_ADDR_VAR 0 10
49836: PUSH
49837: LD_INT 0
49839: ST_TO_ADDR
// side := GetSide ( j ) ;
49840: LD_ADDR_VAR 0 4
49844: PUSH
49845: LD_VAR 0 3
49849: PPUSH
49850: CALL_OW 255
49854: ST_TO_ADDR
// if not mc_tech [ side ] then
49855: LD_EXP 126
49859: PUSH
49860: LD_VAR 0 4
49864: ARRAY
49865: NOT
49866: IFFALSE 49870
// continue ;
49868: GO 49829
// if BuildingStatus ( j ) = bs_idle then
49870: LD_VAR 0 3
49874: PPUSH
49875: CALL_OW 461
49879: PUSH
49880: LD_INT 2
49882: EQUAL
49883: IFFALSE 50071
// begin if idle_lab and UnitsInside ( j ) < 6 then
49885: LD_VAR 0 11
49889: PUSH
49890: LD_VAR 0 3
49894: PPUSH
49895: CALL_OW 313
49899: PUSH
49900: LD_INT 6
49902: LESS
49903: AND
49904: IFFALSE 49975
// begin tmp2 := UnitsInside ( idle_lab ) ;
49906: LD_ADDR_VAR 0 9
49910: PUSH
49911: LD_VAR 0 11
49915: PPUSH
49916: CALL_OW 313
49920: ST_TO_ADDR
// if tmp2 then
49921: LD_VAR 0 9
49925: IFFALSE 49967
// for x in tmp2 do
49927: LD_ADDR_VAR 0 7
49931: PUSH
49932: LD_VAR 0 9
49936: PUSH
49937: FOR_IN
49938: IFFALSE 49965
// begin ComExitBuilding ( x ) ;
49940: LD_VAR 0 7
49944: PPUSH
49945: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49949: LD_VAR 0 7
49953: PPUSH
49954: LD_VAR 0 3
49958: PPUSH
49959: CALL_OW 180
// end ;
49963: GO 49937
49965: POP
49966: POP
// idle_lab := 0 ;
49967: LD_ADDR_VAR 0 11
49971: PUSH
49972: LD_INT 0
49974: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
49975: LD_ADDR_VAR 0 5
49979: PUSH
49980: LD_EXP 126
49984: PUSH
49985: LD_VAR 0 4
49989: ARRAY
49990: PUSH
49991: FOR_IN
49992: IFFALSE 50052
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
49994: LD_VAR 0 3
49998: PPUSH
49999: LD_VAR 0 5
50003: PPUSH
50004: CALL_OW 430
50008: PUSH
50009: LD_VAR 0 4
50013: PPUSH
50014: LD_VAR 0 5
50018: PPUSH
50019: CALL 63707 0 2
50023: AND
50024: IFFALSE 50050
// begin researching := true ;
50026: LD_ADDR_VAR 0 10
50030: PUSH
50031: LD_INT 1
50033: ST_TO_ADDR
// ComResearch ( j , t ) ;
50034: LD_VAR 0 3
50038: PPUSH
50039: LD_VAR 0 5
50043: PPUSH
50044: CALL_OW 124
// break ;
50048: GO 50052
// end ;
50050: GO 49991
50052: POP
50053: POP
// if not researching then
50054: LD_VAR 0 10
50058: NOT
50059: IFFALSE 50071
// idle_lab := j ;
50061: LD_ADDR_VAR 0 11
50065: PUSH
50066: LD_VAR 0 3
50070: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50071: LD_VAR 0 3
50075: PPUSH
50076: CALL_OW 461
50080: PUSH
50081: LD_INT 10
50083: EQUAL
50084: IFFALSE 50672
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50086: LD_EXP 128
50090: PUSH
50091: LD_VAR 0 2
50095: ARRAY
50096: NOT
50097: PUSH
50098: LD_EXP 129
50102: PUSH
50103: LD_VAR 0 2
50107: ARRAY
50108: NOT
50109: AND
50110: PUSH
50111: LD_EXP 126
50115: PUSH
50116: LD_VAR 0 4
50120: ARRAY
50121: PUSH
50122: LD_INT 1
50124: GREATER
50125: AND
50126: IFFALSE 50257
// begin ComCancel ( j ) ;
50128: LD_VAR 0 3
50132: PPUSH
50133: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50137: LD_ADDR_EXP 126
50141: PUSH
50142: LD_EXP 126
50146: PPUSH
50147: LD_VAR 0 4
50151: PPUSH
50152: LD_EXP 126
50156: PUSH
50157: LD_VAR 0 4
50161: ARRAY
50162: PPUSH
50163: LD_EXP 126
50167: PUSH
50168: LD_VAR 0 4
50172: ARRAY
50173: PUSH
50174: LD_INT 1
50176: MINUS
50177: PPUSH
50178: LD_EXP 126
50182: PUSH
50183: LD_VAR 0 4
50187: ARRAY
50188: PPUSH
50189: LD_INT 0
50191: PPUSH
50192: CALL 69126 0 4
50196: PPUSH
50197: CALL_OW 1
50201: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50202: LD_ADDR_EXP 126
50206: PUSH
50207: LD_EXP 126
50211: PPUSH
50212: LD_VAR 0 4
50216: PPUSH
50217: LD_EXP 126
50221: PUSH
50222: LD_VAR 0 4
50226: ARRAY
50227: PPUSH
50228: LD_EXP 126
50232: PUSH
50233: LD_VAR 0 4
50237: ARRAY
50238: PPUSH
50239: LD_INT 1
50241: PPUSH
50242: LD_INT 0
50244: PPUSH
50245: CALL 69126 0 4
50249: PPUSH
50250: CALL_OW 1
50254: ST_TO_ADDR
// continue ;
50255: GO 49829
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50257: LD_EXP 128
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_EXP 129
50272: PUSH
50273: LD_VAR 0 2
50277: ARRAY
50278: NOT
50279: AND
50280: IFFALSE 50407
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50282: LD_ADDR_EXP 129
50286: PUSH
50287: LD_EXP 129
50291: PPUSH
50292: LD_VAR 0 2
50296: PUSH
50297: LD_EXP 129
50301: PUSH
50302: LD_VAR 0 2
50306: ARRAY
50307: PUSH
50308: LD_INT 1
50310: PLUS
50311: PUSH
50312: EMPTY
50313: LIST
50314: LIST
50315: PPUSH
50316: LD_EXP 128
50320: PUSH
50321: LD_VAR 0 2
50325: ARRAY
50326: PUSH
50327: LD_INT 1
50329: ARRAY
50330: PPUSH
50331: CALL 69708 0 3
50335: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50336: LD_EXP 128
50340: PUSH
50341: LD_VAR 0 2
50345: ARRAY
50346: PUSH
50347: LD_INT 1
50349: ARRAY
50350: PPUSH
50351: LD_INT 112
50353: PPUSH
50354: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50358: LD_ADDR_VAR 0 9
50362: PUSH
50363: LD_EXP 128
50367: PUSH
50368: LD_VAR 0 2
50372: ARRAY
50373: PPUSH
50374: LD_INT 1
50376: PPUSH
50377: CALL_OW 3
50381: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50382: LD_ADDR_EXP 128
50386: PUSH
50387: LD_EXP 128
50391: PPUSH
50392: LD_VAR 0 2
50396: PPUSH
50397: LD_VAR 0 9
50401: PPUSH
50402: CALL_OW 1
50406: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50407: LD_EXP 128
50411: PUSH
50412: LD_VAR 0 2
50416: ARRAY
50417: PUSH
50418: LD_EXP 129
50422: PUSH
50423: LD_VAR 0 2
50427: ARRAY
50428: AND
50429: PUSH
50430: LD_EXP 129
50434: PUSH
50435: LD_VAR 0 2
50439: ARRAY
50440: PUSH
50441: LD_INT 1
50443: ARRAY
50444: PPUSH
50445: CALL_OW 310
50449: NOT
50450: AND
50451: PUSH
50452: LD_VAR 0 3
50456: PPUSH
50457: CALL_OW 313
50461: PUSH
50462: LD_INT 6
50464: EQUAL
50465: AND
50466: IFFALSE 50522
// begin tmp2 := UnitsInside ( j ) ;
50468: LD_ADDR_VAR 0 9
50472: PUSH
50473: LD_VAR 0 3
50477: PPUSH
50478: CALL_OW 313
50482: ST_TO_ADDR
// if tmp2 = 6 then
50483: LD_VAR 0 9
50487: PUSH
50488: LD_INT 6
50490: EQUAL
50491: IFFALSE 50522
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50493: LD_VAR 0 9
50497: PUSH
50498: LD_INT 1
50500: ARRAY
50501: PPUSH
50502: LD_INT 112
50504: PPUSH
50505: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50509: LD_VAR 0 9
50513: PUSH
50514: LD_INT 1
50516: ARRAY
50517: PPUSH
50518: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50522: LD_EXP 129
50526: PUSH
50527: LD_VAR 0 2
50531: ARRAY
50532: PUSH
50533: LD_EXP 129
50537: PUSH
50538: LD_VAR 0 2
50542: ARRAY
50543: PUSH
50544: LD_INT 1
50546: ARRAY
50547: PPUSH
50548: CALL_OW 314
50552: NOT
50553: AND
50554: PUSH
50555: LD_EXP 129
50559: PUSH
50560: LD_VAR 0 2
50564: ARRAY
50565: PUSH
50566: LD_INT 1
50568: ARRAY
50569: PPUSH
50570: CALL_OW 310
50574: NOT
50575: AND
50576: IFFALSE 50602
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50578: LD_EXP 129
50582: PUSH
50583: LD_VAR 0 2
50587: ARRAY
50588: PUSH
50589: LD_INT 1
50591: ARRAY
50592: PPUSH
50593: LD_VAR 0 3
50597: PPUSH
50598: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50602: LD_EXP 129
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PPUSH
50617: CALL_OW 310
50621: PUSH
50622: LD_EXP 129
50626: PUSH
50627: LD_VAR 0 2
50631: ARRAY
50632: PUSH
50633: LD_INT 1
50635: ARRAY
50636: PPUSH
50637: CALL_OW 310
50641: PPUSH
50642: CALL_OW 461
50646: PUSH
50647: LD_INT 3
50649: NONEQUAL
50650: AND
50651: IFFALSE 50672
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
50653: LD_EXP 129
50657: PUSH
50658: LD_VAR 0 2
50662: ARRAY
50663: PUSH
50664: LD_INT 1
50666: ARRAY
50667: PPUSH
50668: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
50672: LD_VAR 0 3
50676: PPUSH
50677: CALL_OW 461
50681: PUSH
50682: LD_INT 6
50684: EQUAL
50685: PUSH
50686: LD_VAR 0 6
50690: PUSH
50691: LD_INT 1
50693: GREATER
50694: AND
50695: IFFALSE 50847
// begin sci := [ ] ;
50697: LD_ADDR_VAR 0 8
50701: PUSH
50702: EMPTY
50703: ST_TO_ADDR
// for x in ( tmp diff j ) do
50704: LD_ADDR_VAR 0 7
50708: PUSH
50709: LD_VAR 0 6
50713: PUSH
50714: LD_VAR 0 3
50718: DIFF
50719: PUSH
50720: FOR_IN
50721: IFFALSE 50773
// begin if sci = 6 then
50723: LD_VAR 0 8
50727: PUSH
50728: LD_INT 6
50730: EQUAL
50731: IFFALSE 50735
// break ;
50733: GO 50773
// if BuildingStatus ( x ) = bs_idle then
50735: LD_VAR 0 7
50739: PPUSH
50740: CALL_OW 461
50744: PUSH
50745: LD_INT 2
50747: EQUAL
50748: IFFALSE 50771
// sci := sci ^ UnitsInside ( x ) ;
50750: LD_ADDR_VAR 0 8
50754: PUSH
50755: LD_VAR 0 8
50759: PUSH
50760: LD_VAR 0 7
50764: PPUSH
50765: CALL_OW 313
50769: ADD
50770: ST_TO_ADDR
// end ;
50771: GO 50720
50773: POP
50774: POP
// if not sci then
50775: LD_VAR 0 8
50779: NOT
50780: IFFALSE 50784
// continue ;
50782: GO 49829
// for x in sci do
50784: LD_ADDR_VAR 0 7
50788: PUSH
50789: LD_VAR 0 8
50793: PUSH
50794: FOR_IN
50795: IFFALSE 50845
// if IsInUnit ( x ) and not HasTask ( x ) then
50797: LD_VAR 0 7
50801: PPUSH
50802: CALL_OW 310
50806: PUSH
50807: LD_VAR 0 7
50811: PPUSH
50812: CALL_OW 314
50816: NOT
50817: AND
50818: IFFALSE 50843
// begin ComExitBuilding ( x ) ;
50820: LD_VAR 0 7
50824: PPUSH
50825: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50829: LD_VAR 0 7
50833: PPUSH
50834: LD_VAR 0 3
50838: PPUSH
50839: CALL_OW 180
// end ;
50843: GO 50794
50845: POP
50846: POP
// end ; end ;
50847: GO 49829
50849: POP
50850: POP
// end ;
50851: GO 49783
50853: POP
50854: POP
// end ;
50855: LD_VAR 0 1
50859: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
50860: LD_INT 0
50862: PPUSH
50863: PPUSH
// if not mc_bases then
50864: LD_EXP 99
50868: NOT
50869: IFFALSE 50873
// exit ;
50871: GO 50954
// for i = 1 to mc_bases do
50873: LD_ADDR_VAR 0 2
50877: PUSH
50878: DOUBLE
50879: LD_INT 1
50881: DEC
50882: ST_TO_ADDR
50883: LD_EXP 99
50887: PUSH
50888: FOR_TO
50889: IFFALSE 50952
// if mc_mines [ i ] and mc_miners [ i ] then
50891: LD_EXP 112
50895: PUSH
50896: LD_VAR 0 2
50900: ARRAY
50901: PUSH
50902: LD_EXP 113
50906: PUSH
50907: LD_VAR 0 2
50911: ARRAY
50912: AND
50913: IFFALSE 50950
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
50915: LD_EXP 113
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: PUSH
50926: LD_INT 1
50928: ARRAY
50929: PPUSH
50930: CALL_OW 255
50934: PPUSH
50935: LD_EXP 112
50939: PUSH
50940: LD_VAR 0 2
50944: ARRAY
50945: PPUSH
50946: CALL 66758 0 2
50950: GO 50888
50952: POP
50953: POP
// end ;
50954: LD_VAR 0 1
50958: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
50959: LD_INT 0
50961: PPUSH
50962: PPUSH
50963: PPUSH
50964: PPUSH
50965: PPUSH
50966: PPUSH
50967: PPUSH
50968: PPUSH
// if not mc_bases or not mc_parking then
50969: LD_EXP 99
50973: NOT
50974: PUSH
50975: LD_EXP 123
50979: NOT
50980: OR
50981: IFFALSE 50985
// exit ;
50983: GO 51661
// for i = 1 to mc_bases do
50985: LD_ADDR_VAR 0 2
50989: PUSH
50990: DOUBLE
50991: LD_INT 1
50993: DEC
50994: ST_TO_ADDR
50995: LD_EXP 99
50999: PUSH
51000: FOR_TO
51001: IFFALSE 51659
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51003: LD_EXP 99
51007: PUSH
51008: LD_VAR 0 2
51012: ARRAY
51013: NOT
51014: PUSH
51015: LD_EXP 123
51019: PUSH
51020: LD_VAR 0 2
51024: ARRAY
51025: NOT
51026: OR
51027: IFFALSE 51031
// continue ;
51029: GO 51000
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51031: LD_ADDR_VAR 0 5
51035: PUSH
51036: LD_EXP 99
51040: PUSH
51041: LD_VAR 0 2
51045: ARRAY
51046: PUSH
51047: LD_INT 1
51049: ARRAY
51050: PPUSH
51051: CALL_OW 255
51055: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51056: LD_ADDR_VAR 0 6
51060: PUSH
51061: LD_EXP 99
51065: PUSH
51066: LD_VAR 0 2
51070: ARRAY
51071: PPUSH
51072: LD_INT 30
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: EMPTY
51079: LIST
51080: LIST
51081: PPUSH
51082: CALL_OW 72
51086: ST_TO_ADDR
// if not fac then
51087: LD_VAR 0 6
51091: NOT
51092: IFFALSE 51143
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51094: LD_ADDR_VAR 0 6
51098: PUSH
51099: LD_EXP 99
51103: PUSH
51104: LD_VAR 0 2
51108: ARRAY
51109: PPUSH
51110: LD_INT 2
51112: PUSH
51113: LD_INT 30
51115: PUSH
51116: LD_INT 0
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: PUSH
51123: LD_INT 30
51125: PUSH
51126: LD_INT 1
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: PUSH
51133: EMPTY
51134: LIST
51135: LIST
51136: LIST
51137: PPUSH
51138: CALL_OW 72
51142: ST_TO_ADDR
// if not fac then
51143: LD_VAR 0 6
51147: NOT
51148: IFFALSE 51152
// continue ;
51150: GO 51000
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51152: LD_ADDR_VAR 0 7
51156: PUSH
51157: LD_EXP 123
51161: PUSH
51162: LD_VAR 0 2
51166: ARRAY
51167: PPUSH
51168: LD_INT 22
51170: PUSH
51171: LD_VAR 0 5
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: PUSH
51180: LD_INT 21
51182: PUSH
51183: LD_INT 2
51185: PUSH
51186: EMPTY
51187: LIST
51188: LIST
51189: PUSH
51190: LD_INT 3
51192: PUSH
51193: LD_INT 24
51195: PUSH
51196: LD_INT 1000
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: PUSH
51203: EMPTY
51204: LIST
51205: LIST
51206: PUSH
51207: EMPTY
51208: LIST
51209: LIST
51210: LIST
51211: PPUSH
51212: CALL_OW 70
51216: PUSH
51217: LD_INT 22
51219: PUSH
51220: LD_VAR 0 5
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: PUSH
51229: LD_INT 91
51231: PUSH
51232: LD_VAR 0 6
51236: PUSH
51237: LD_INT 1
51239: ARRAY
51240: PUSH
51241: LD_INT 25
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: LIST
51248: PUSH
51249: LD_INT 21
51251: PUSH
51252: LD_INT 2
51254: PUSH
51255: EMPTY
51256: LIST
51257: LIST
51258: PUSH
51259: LD_INT 3
51261: PUSH
51262: LD_INT 24
51264: PUSH
51265: LD_INT 1000
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: PUSH
51272: EMPTY
51273: LIST
51274: LIST
51275: PUSH
51276: EMPTY
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: PPUSH
51282: CALL_OW 69
51286: UNION
51287: ST_TO_ADDR
// if not vehs then
51288: LD_VAR 0 7
51292: NOT
51293: IFFALSE 51319
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51295: LD_ADDR_EXP 111
51299: PUSH
51300: LD_EXP 111
51304: PPUSH
51305: LD_VAR 0 2
51309: PPUSH
51310: EMPTY
51311: PPUSH
51312: CALL_OW 1
51316: ST_TO_ADDR
// continue ;
51317: GO 51000
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51319: LD_ADDR_VAR 0 8
51323: PUSH
51324: LD_EXP 99
51328: PUSH
51329: LD_VAR 0 2
51333: ARRAY
51334: PPUSH
51335: LD_INT 30
51337: PUSH
51338: LD_INT 3
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: PPUSH
51345: CALL_OW 72
51349: ST_TO_ADDR
// if tmp then
51350: LD_VAR 0 8
51354: IFFALSE 51457
// begin for j in tmp do
51356: LD_ADDR_VAR 0 3
51360: PUSH
51361: LD_VAR 0 8
51365: PUSH
51366: FOR_IN
51367: IFFALSE 51455
// for k in UnitsInside ( j ) do
51369: LD_ADDR_VAR 0 4
51373: PUSH
51374: LD_VAR 0 3
51378: PPUSH
51379: CALL_OW 313
51383: PUSH
51384: FOR_IN
51385: IFFALSE 51451
// if k then
51387: LD_VAR 0 4
51391: IFFALSE 51449
// if not k in mc_repair_vehicle [ i ] then
51393: LD_VAR 0 4
51397: PUSH
51398: LD_EXP 111
51402: PUSH
51403: LD_VAR 0 2
51407: ARRAY
51408: IN
51409: NOT
51410: IFFALSE 51449
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51412: LD_ADDR_EXP 111
51416: PUSH
51417: LD_EXP 111
51421: PPUSH
51422: LD_VAR 0 2
51426: PPUSH
51427: LD_EXP 111
51431: PUSH
51432: LD_VAR 0 2
51436: ARRAY
51437: PUSH
51438: LD_VAR 0 4
51442: UNION
51443: PPUSH
51444: CALL_OW 1
51448: ST_TO_ADDR
51449: GO 51384
51451: POP
51452: POP
51453: GO 51366
51455: POP
51456: POP
// end ; if not mc_repair_vehicle [ i ] then
51457: LD_EXP 111
51461: PUSH
51462: LD_VAR 0 2
51466: ARRAY
51467: NOT
51468: IFFALSE 51472
// continue ;
51470: GO 51000
// for j in mc_repair_vehicle [ i ] do
51472: LD_ADDR_VAR 0 3
51476: PUSH
51477: LD_EXP 111
51481: PUSH
51482: LD_VAR 0 2
51486: ARRAY
51487: PUSH
51488: FOR_IN
51489: IFFALSE 51655
// begin if GetClass ( j ) <> 3 then
51491: LD_VAR 0 3
51495: PPUSH
51496: CALL_OW 257
51500: PUSH
51501: LD_INT 3
51503: NONEQUAL
51504: IFFALSE 51545
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51506: LD_ADDR_EXP 111
51510: PUSH
51511: LD_EXP 111
51515: PPUSH
51516: LD_VAR 0 2
51520: PPUSH
51521: LD_EXP 111
51525: PUSH
51526: LD_VAR 0 2
51530: ARRAY
51531: PUSH
51532: LD_VAR 0 3
51536: DIFF
51537: PPUSH
51538: CALL_OW 1
51542: ST_TO_ADDR
// continue ;
51543: GO 51488
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51545: LD_VAR 0 3
51549: PPUSH
51550: CALL_OW 311
51554: NOT
51555: PUSH
51556: LD_VAR 0 3
51560: PUSH
51561: LD_EXP 102
51565: PUSH
51566: LD_VAR 0 2
51570: ARRAY
51571: PUSH
51572: LD_INT 1
51574: ARRAY
51575: IN
51576: NOT
51577: AND
51578: PUSH
51579: LD_VAR 0 3
51583: PUSH
51584: LD_EXP 102
51588: PUSH
51589: LD_VAR 0 2
51593: ARRAY
51594: PUSH
51595: LD_INT 2
51597: ARRAY
51598: IN
51599: NOT
51600: AND
51601: IFFALSE 51653
// begin if IsInUnit ( j ) then
51603: LD_VAR 0 3
51607: PPUSH
51608: CALL_OW 310
51612: IFFALSE 51623
// ComExitBuilding ( j ) ;
51614: LD_VAR 0 3
51618: PPUSH
51619: CALL_OW 122
// if not HasTask ( j ) then
51623: LD_VAR 0 3
51627: PPUSH
51628: CALL_OW 314
51632: NOT
51633: IFFALSE 51653
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
51635: LD_VAR 0 3
51639: PPUSH
51640: LD_VAR 0 7
51644: PUSH
51645: LD_INT 1
51647: ARRAY
51648: PPUSH
51649: CALL_OW 189
// end ; end ;
51653: GO 51488
51655: POP
51656: POP
// end ;
51657: GO 51000
51659: POP
51660: POP
// end ;
51661: LD_VAR 0 1
51665: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
51666: LD_INT 0
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
51674: PPUSH
51675: PPUSH
51676: PPUSH
51677: PPUSH
51678: PPUSH
// if not mc_bases then
51679: LD_EXP 99
51683: NOT
51684: IFFALSE 51688
// exit ;
51686: GO 52490
// for i = 1 to mc_bases do
51688: LD_ADDR_VAR 0 2
51692: PUSH
51693: DOUBLE
51694: LD_INT 1
51696: DEC
51697: ST_TO_ADDR
51698: LD_EXP 99
51702: PUSH
51703: FOR_TO
51704: IFFALSE 52488
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
51706: LD_EXP 127
51710: PUSH
51711: LD_VAR 0 2
51715: ARRAY
51716: NOT
51717: PUSH
51718: LD_EXP 102
51722: PUSH
51723: LD_VAR 0 2
51727: ARRAY
51728: PUSH
51729: LD_INT 1
51731: ARRAY
51732: OR
51733: PUSH
51734: LD_EXP 102
51738: PUSH
51739: LD_VAR 0 2
51743: ARRAY
51744: PUSH
51745: LD_INT 2
51747: ARRAY
51748: OR
51749: PUSH
51750: LD_EXP 125
51754: PUSH
51755: LD_VAR 0 2
51759: ARRAY
51760: PPUSH
51761: LD_INT 1
51763: PPUSH
51764: CALL_OW 325
51768: NOT
51769: OR
51770: PUSH
51771: LD_EXP 122
51775: PUSH
51776: LD_VAR 0 2
51780: ARRAY
51781: OR
51782: IFFALSE 51786
// continue ;
51784: GO 51703
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
51786: LD_ADDR_VAR 0 8
51790: PUSH
51791: LD_EXP 99
51795: PUSH
51796: LD_VAR 0 2
51800: ARRAY
51801: PPUSH
51802: LD_INT 25
51804: PUSH
51805: LD_INT 4
51807: PUSH
51808: EMPTY
51809: LIST
51810: LIST
51811: PUSH
51812: LD_INT 50
51814: PUSH
51815: EMPTY
51816: LIST
51817: PUSH
51818: LD_INT 3
51820: PUSH
51821: LD_INT 60
51823: PUSH
51824: EMPTY
51825: LIST
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: PUSH
51831: EMPTY
51832: LIST
51833: LIST
51834: LIST
51835: PPUSH
51836: CALL_OW 72
51840: PUSH
51841: LD_EXP 103
51845: PUSH
51846: LD_VAR 0 2
51850: ARRAY
51851: DIFF
51852: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51853: LD_ADDR_VAR 0 9
51857: PUSH
51858: LD_EXP 99
51862: PUSH
51863: LD_VAR 0 2
51867: ARRAY
51868: PPUSH
51869: LD_INT 2
51871: PUSH
51872: LD_INT 30
51874: PUSH
51875: LD_INT 0
51877: PUSH
51878: EMPTY
51879: LIST
51880: LIST
51881: PUSH
51882: LD_INT 30
51884: PUSH
51885: LD_INT 1
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: LIST
51896: PPUSH
51897: CALL_OW 72
51901: ST_TO_ADDR
// if not tmp or not dep then
51902: LD_VAR 0 8
51906: NOT
51907: PUSH
51908: LD_VAR 0 9
51912: NOT
51913: OR
51914: IFFALSE 51918
// continue ;
51916: GO 51703
// side := GetSide ( tmp [ 1 ] ) ;
51918: LD_ADDR_VAR 0 11
51922: PUSH
51923: LD_VAR 0 8
51927: PUSH
51928: LD_INT 1
51930: ARRAY
51931: PPUSH
51932: CALL_OW 255
51936: ST_TO_ADDR
// dep := dep [ 1 ] ;
51937: LD_ADDR_VAR 0 9
51941: PUSH
51942: LD_VAR 0 9
51946: PUSH
51947: LD_INT 1
51949: ARRAY
51950: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
51951: LD_ADDR_VAR 0 7
51955: PUSH
51956: LD_EXP 127
51960: PUSH
51961: LD_VAR 0 2
51965: ARRAY
51966: PPUSH
51967: LD_INT 22
51969: PUSH
51970: LD_INT 0
51972: PUSH
51973: EMPTY
51974: LIST
51975: LIST
51976: PUSH
51977: LD_INT 25
51979: PUSH
51980: LD_INT 12
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: PPUSH
51991: CALL_OW 70
51995: PUSH
51996: LD_INT 22
51998: PUSH
51999: LD_INT 0
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: PUSH
52006: LD_INT 25
52008: PUSH
52009: LD_INT 12
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: PUSH
52016: LD_INT 91
52018: PUSH
52019: LD_VAR 0 9
52023: PUSH
52024: LD_INT 20
52026: PUSH
52027: EMPTY
52028: LIST
52029: LIST
52030: LIST
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: LIST
52036: PPUSH
52037: CALL_OW 69
52041: UNION
52042: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52043: LD_ADDR_VAR 0 10
52047: PUSH
52048: LD_EXP 127
52052: PUSH
52053: LD_VAR 0 2
52057: ARRAY
52058: PPUSH
52059: LD_INT 81
52061: PUSH
52062: LD_VAR 0 11
52066: PUSH
52067: EMPTY
52068: LIST
52069: LIST
52070: PPUSH
52071: CALL_OW 70
52075: ST_TO_ADDR
// if not apes or danger_at_area then
52076: LD_VAR 0 7
52080: NOT
52081: PUSH
52082: LD_VAR 0 10
52086: OR
52087: IFFALSE 52137
// begin if mc_taming [ i ] then
52089: LD_EXP 130
52093: PUSH
52094: LD_VAR 0 2
52098: ARRAY
52099: IFFALSE 52135
// begin MC_Reset ( i , 121 ) ;
52101: LD_VAR 0 2
52105: PPUSH
52106: LD_INT 121
52108: PPUSH
52109: CALL 37830 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52113: LD_ADDR_EXP 130
52117: PUSH
52118: LD_EXP 130
52122: PPUSH
52123: LD_VAR 0 2
52127: PPUSH
52128: EMPTY
52129: PPUSH
52130: CALL_OW 1
52134: ST_TO_ADDR
// end ; continue ;
52135: GO 51703
// end ; for j in tmp do
52137: LD_ADDR_VAR 0 3
52141: PUSH
52142: LD_VAR 0 8
52146: PUSH
52147: FOR_IN
52148: IFFALSE 52484
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52150: LD_VAR 0 3
52154: PUSH
52155: LD_EXP 130
52159: PUSH
52160: LD_VAR 0 2
52164: ARRAY
52165: IN
52166: NOT
52167: PUSH
52168: LD_EXP 130
52172: PUSH
52173: LD_VAR 0 2
52177: ARRAY
52178: PUSH
52179: LD_INT 3
52181: LESS
52182: AND
52183: IFFALSE 52241
// begin SetTag ( j , 121 ) ;
52185: LD_VAR 0 3
52189: PPUSH
52190: LD_INT 121
52192: PPUSH
52193: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52197: LD_ADDR_EXP 130
52201: PUSH
52202: LD_EXP 130
52206: PPUSH
52207: LD_VAR 0 2
52211: PUSH
52212: LD_EXP 130
52216: PUSH
52217: LD_VAR 0 2
52221: ARRAY
52222: PUSH
52223: LD_INT 1
52225: PLUS
52226: PUSH
52227: EMPTY
52228: LIST
52229: LIST
52230: PPUSH
52231: LD_VAR 0 3
52235: PPUSH
52236: CALL 69708 0 3
52240: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52241: LD_VAR 0 3
52245: PUSH
52246: LD_EXP 130
52250: PUSH
52251: LD_VAR 0 2
52255: ARRAY
52256: IN
52257: IFFALSE 52482
// begin if GetClass ( j ) <> 4 then
52259: LD_VAR 0 3
52263: PPUSH
52264: CALL_OW 257
52268: PUSH
52269: LD_INT 4
52271: NONEQUAL
52272: IFFALSE 52325
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52274: LD_ADDR_EXP 130
52278: PUSH
52279: LD_EXP 130
52283: PPUSH
52284: LD_VAR 0 2
52288: PPUSH
52289: LD_EXP 130
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: PUSH
52300: LD_VAR 0 3
52304: DIFF
52305: PPUSH
52306: CALL_OW 1
52310: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52311: LD_VAR 0 3
52315: PPUSH
52316: LD_INT 0
52318: PPUSH
52319: CALL_OW 109
// continue ;
52323: GO 52147
// end ; if IsInUnit ( j ) then
52325: LD_VAR 0 3
52329: PPUSH
52330: CALL_OW 310
52334: IFFALSE 52345
// ComExitBuilding ( j ) ;
52336: LD_VAR 0 3
52340: PPUSH
52341: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52345: LD_ADDR_VAR 0 6
52349: PUSH
52350: LD_VAR 0 7
52354: PPUSH
52355: LD_VAR 0 3
52359: PPUSH
52360: CALL_OW 74
52364: ST_TO_ADDR
// if not ape then
52365: LD_VAR 0 6
52369: NOT
52370: IFFALSE 52374
// break ;
52372: GO 52484
// x := GetX ( ape ) ;
52374: LD_ADDR_VAR 0 4
52378: PUSH
52379: LD_VAR 0 6
52383: PPUSH
52384: CALL_OW 250
52388: ST_TO_ADDR
// y := GetY ( ape ) ;
52389: LD_ADDR_VAR 0 5
52393: PUSH
52394: LD_VAR 0 6
52398: PPUSH
52399: CALL_OW 251
52403: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52404: LD_VAR 0 4
52408: PPUSH
52409: LD_VAR 0 5
52413: PPUSH
52414: CALL_OW 488
52418: NOT
52419: PUSH
52420: LD_VAR 0 11
52424: PPUSH
52425: LD_VAR 0 4
52429: PPUSH
52430: LD_VAR 0 5
52434: PPUSH
52435: LD_INT 20
52437: PPUSH
52438: CALL 70604 0 4
52442: PUSH
52443: LD_INT 4
52445: ARRAY
52446: OR
52447: IFFALSE 52451
// break ;
52449: GO 52484
// if not HasTask ( j ) then
52451: LD_VAR 0 3
52455: PPUSH
52456: CALL_OW 314
52460: NOT
52461: IFFALSE 52482
// ComTameXY ( j , x , y ) ;
52463: LD_VAR 0 3
52467: PPUSH
52468: LD_VAR 0 4
52472: PPUSH
52473: LD_VAR 0 5
52477: PPUSH
52478: CALL_OW 131
// end ; end ;
52482: GO 52147
52484: POP
52485: POP
// end ;
52486: GO 51703
52488: POP
52489: POP
// end ;
52490: LD_VAR 0 1
52494: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52495: LD_INT 0
52497: PPUSH
52498: PPUSH
52499: PPUSH
52500: PPUSH
52501: PPUSH
52502: PPUSH
52503: PPUSH
52504: PPUSH
// if not mc_bases then
52505: LD_EXP 99
52509: NOT
52510: IFFALSE 52514
// exit ;
52512: GO 53140
// for i = 1 to mc_bases do
52514: LD_ADDR_VAR 0 2
52518: PUSH
52519: DOUBLE
52520: LD_INT 1
52522: DEC
52523: ST_TO_ADDR
52524: LD_EXP 99
52528: PUSH
52529: FOR_TO
52530: IFFALSE 53138
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52532: LD_EXP 128
52536: PUSH
52537: LD_VAR 0 2
52541: ARRAY
52542: NOT
52543: PUSH
52544: LD_EXP 128
52548: PUSH
52549: LD_VAR 0 2
52553: ARRAY
52554: PPUSH
52555: LD_INT 25
52557: PUSH
52558: LD_INT 12
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: PPUSH
52565: CALL_OW 72
52569: NOT
52570: OR
52571: IFFALSE 52575
// continue ;
52573: GO 52529
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52575: LD_ADDR_VAR 0 5
52579: PUSH
52580: LD_EXP 128
52584: PUSH
52585: LD_VAR 0 2
52589: ARRAY
52590: PUSH
52591: LD_INT 1
52593: ARRAY
52594: PPUSH
52595: CALL_OW 255
52599: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52600: LD_VAR 0 5
52604: PPUSH
52605: LD_INT 2
52607: PPUSH
52608: CALL_OW 325
52612: IFFALSE 52865
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52614: LD_ADDR_VAR 0 4
52618: PUSH
52619: LD_EXP 128
52623: PUSH
52624: LD_VAR 0 2
52628: ARRAY
52629: PPUSH
52630: LD_INT 25
52632: PUSH
52633: LD_INT 16
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: PPUSH
52640: CALL_OW 72
52644: ST_TO_ADDR
// if tmp < 6 then
52645: LD_VAR 0 4
52649: PUSH
52650: LD_INT 6
52652: LESS
52653: IFFALSE 52865
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52655: LD_ADDR_VAR 0 6
52659: PUSH
52660: LD_EXP 99
52664: PUSH
52665: LD_VAR 0 2
52669: ARRAY
52670: PPUSH
52671: LD_INT 2
52673: PUSH
52674: LD_INT 30
52676: PUSH
52677: LD_INT 0
52679: PUSH
52680: EMPTY
52681: LIST
52682: LIST
52683: PUSH
52684: LD_INT 30
52686: PUSH
52687: LD_INT 1
52689: PUSH
52690: EMPTY
52691: LIST
52692: LIST
52693: PUSH
52694: EMPTY
52695: LIST
52696: LIST
52697: LIST
52698: PPUSH
52699: CALL_OW 72
52703: ST_TO_ADDR
// if depot then
52704: LD_VAR 0 6
52708: IFFALSE 52865
// begin selected := 0 ;
52710: LD_ADDR_VAR 0 7
52714: PUSH
52715: LD_INT 0
52717: ST_TO_ADDR
// for j in depot do
52718: LD_ADDR_VAR 0 3
52722: PUSH
52723: LD_VAR 0 6
52727: PUSH
52728: FOR_IN
52729: IFFALSE 52760
// begin if UnitsInside ( j ) < 6 then
52731: LD_VAR 0 3
52735: PPUSH
52736: CALL_OW 313
52740: PUSH
52741: LD_INT 6
52743: LESS
52744: IFFALSE 52758
// begin selected := j ;
52746: LD_ADDR_VAR 0 7
52750: PUSH
52751: LD_VAR 0 3
52755: ST_TO_ADDR
// break ;
52756: GO 52760
// end ; end ;
52758: GO 52728
52760: POP
52761: POP
// if selected then
52762: LD_VAR 0 7
52766: IFFALSE 52865
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52768: LD_ADDR_VAR 0 3
52772: PUSH
52773: LD_EXP 128
52777: PUSH
52778: LD_VAR 0 2
52782: ARRAY
52783: PPUSH
52784: LD_INT 25
52786: PUSH
52787: LD_INT 12
52789: PUSH
52790: EMPTY
52791: LIST
52792: LIST
52793: PPUSH
52794: CALL_OW 72
52798: PUSH
52799: FOR_IN
52800: IFFALSE 52863
// if not HasTask ( j ) then
52802: LD_VAR 0 3
52806: PPUSH
52807: CALL_OW 314
52811: NOT
52812: IFFALSE 52861
// begin if not IsInUnit ( j ) then
52814: LD_VAR 0 3
52818: PPUSH
52819: CALL_OW 310
52823: NOT
52824: IFFALSE 52840
// ComEnterUnit ( j , selected ) ;
52826: LD_VAR 0 3
52830: PPUSH
52831: LD_VAR 0 7
52835: PPUSH
52836: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
52840: LD_VAR 0 3
52844: PPUSH
52845: LD_INT 16
52847: PPUSH
52848: CALL_OW 183
// AddComExitBuilding ( j ) ;
52852: LD_VAR 0 3
52856: PPUSH
52857: CALL_OW 182
// end ;
52861: GO 52799
52863: POP
52864: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
52865: LD_VAR 0 5
52869: PPUSH
52870: LD_INT 11
52872: PPUSH
52873: CALL_OW 325
52877: IFFALSE 53136
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52879: LD_ADDR_VAR 0 4
52883: PUSH
52884: LD_EXP 128
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PPUSH
52895: LD_INT 25
52897: PUSH
52898: LD_INT 16
52900: PUSH
52901: EMPTY
52902: LIST
52903: LIST
52904: PPUSH
52905: CALL_OW 72
52909: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
52910: LD_VAR 0 4
52914: PUSH
52915: LD_INT 6
52917: GREATEREQUAL
52918: PUSH
52919: LD_VAR 0 5
52923: PPUSH
52924: LD_INT 2
52926: PPUSH
52927: CALL_OW 325
52931: NOT
52932: OR
52933: IFFALSE 53136
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52935: LD_ADDR_VAR 0 8
52939: PUSH
52940: LD_EXP 99
52944: PUSH
52945: LD_VAR 0 2
52949: ARRAY
52950: PPUSH
52951: LD_INT 2
52953: PUSH
52954: LD_INT 30
52956: PUSH
52957: LD_INT 4
52959: PUSH
52960: EMPTY
52961: LIST
52962: LIST
52963: PUSH
52964: LD_INT 30
52966: PUSH
52967: LD_INT 5
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: LIST
52978: PPUSH
52979: CALL_OW 72
52983: ST_TO_ADDR
// if barracks then
52984: LD_VAR 0 8
52988: IFFALSE 53136
// begin selected := 0 ;
52990: LD_ADDR_VAR 0 7
52994: PUSH
52995: LD_INT 0
52997: ST_TO_ADDR
// for j in barracks do
52998: LD_ADDR_VAR 0 3
53002: PUSH
53003: LD_VAR 0 8
53007: PUSH
53008: FOR_IN
53009: IFFALSE 53040
// begin if UnitsInside ( j ) < 6 then
53011: LD_VAR 0 3
53015: PPUSH
53016: CALL_OW 313
53020: PUSH
53021: LD_INT 6
53023: LESS
53024: IFFALSE 53038
// begin selected := j ;
53026: LD_ADDR_VAR 0 7
53030: PUSH
53031: LD_VAR 0 3
53035: ST_TO_ADDR
// break ;
53036: GO 53040
// end ; end ;
53038: GO 53008
53040: POP
53041: POP
// if selected then
53042: LD_VAR 0 7
53046: IFFALSE 53136
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53048: LD_ADDR_VAR 0 3
53052: PUSH
53053: LD_EXP 128
53057: PUSH
53058: LD_VAR 0 2
53062: ARRAY
53063: PPUSH
53064: LD_INT 25
53066: PUSH
53067: LD_INT 12
53069: PUSH
53070: EMPTY
53071: LIST
53072: LIST
53073: PPUSH
53074: CALL_OW 72
53078: PUSH
53079: FOR_IN
53080: IFFALSE 53134
// if not IsInUnit ( j ) and not HasTask ( j ) then
53082: LD_VAR 0 3
53086: PPUSH
53087: CALL_OW 310
53091: NOT
53092: PUSH
53093: LD_VAR 0 3
53097: PPUSH
53098: CALL_OW 314
53102: NOT
53103: AND
53104: IFFALSE 53132
// begin ComEnterUnit ( j , selected ) ;
53106: LD_VAR 0 3
53110: PPUSH
53111: LD_VAR 0 7
53115: PPUSH
53116: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53120: LD_VAR 0 3
53124: PPUSH
53125: LD_INT 15
53127: PPUSH
53128: CALL_OW 183
// end ;
53132: GO 53079
53134: POP
53135: POP
// end ; end ; end ; end ; end ;
53136: GO 52529
53138: POP
53139: POP
// end ;
53140: LD_VAR 0 1
53144: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53145: LD_INT 0
53147: PPUSH
53148: PPUSH
53149: PPUSH
53150: PPUSH
// if not mc_bases then
53151: LD_EXP 99
53155: NOT
53156: IFFALSE 53160
// exit ;
53158: GO 53338
// for i = 1 to mc_bases do
53160: LD_ADDR_VAR 0 2
53164: PUSH
53165: DOUBLE
53166: LD_INT 1
53168: DEC
53169: ST_TO_ADDR
53170: LD_EXP 99
53174: PUSH
53175: FOR_TO
53176: IFFALSE 53336
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53178: LD_ADDR_VAR 0 4
53182: PUSH
53183: LD_EXP 99
53187: PUSH
53188: LD_VAR 0 2
53192: ARRAY
53193: PPUSH
53194: LD_INT 25
53196: PUSH
53197: LD_INT 9
53199: PUSH
53200: EMPTY
53201: LIST
53202: LIST
53203: PPUSH
53204: CALL_OW 72
53208: ST_TO_ADDR
// if not tmp then
53209: LD_VAR 0 4
53213: NOT
53214: IFFALSE 53218
// continue ;
53216: GO 53175
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53218: LD_EXP 125
53222: PUSH
53223: LD_VAR 0 2
53227: ARRAY
53228: PPUSH
53229: LD_INT 29
53231: PPUSH
53232: CALL_OW 325
53236: NOT
53237: PUSH
53238: LD_EXP 125
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: PPUSH
53249: LD_INT 28
53251: PPUSH
53252: CALL_OW 325
53256: NOT
53257: AND
53258: IFFALSE 53262
// continue ;
53260: GO 53175
// for j in tmp do
53262: LD_ADDR_VAR 0 3
53266: PUSH
53267: LD_VAR 0 4
53271: PUSH
53272: FOR_IN
53273: IFFALSE 53332
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53275: LD_VAR 0 3
53279: PUSH
53280: LD_EXP 102
53284: PUSH
53285: LD_VAR 0 2
53289: ARRAY
53290: PUSH
53291: LD_INT 1
53293: ARRAY
53294: IN
53295: NOT
53296: PUSH
53297: LD_VAR 0 3
53301: PUSH
53302: LD_EXP 102
53306: PUSH
53307: LD_VAR 0 2
53311: ARRAY
53312: PUSH
53313: LD_INT 2
53315: ARRAY
53316: IN
53317: NOT
53318: AND
53319: IFFALSE 53330
// ComSpaceTimeShoot ( j ) ;
53321: LD_VAR 0 3
53325: PPUSH
53326: CALL 63798 0 1
53330: GO 53272
53332: POP
53333: POP
// end ;
53334: GO 53175
53336: POP
53337: POP
// end ;
53338: LD_VAR 0 1
53342: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53343: LD_INT 0
53345: PPUSH
53346: PPUSH
53347: PPUSH
53348: PPUSH
53349: PPUSH
53350: PPUSH
53351: PPUSH
53352: PPUSH
53353: PPUSH
// if not mc_bases then
53354: LD_EXP 99
53358: NOT
53359: IFFALSE 53363
// exit ;
53361: GO 53985
// for i = 1 to mc_bases do
53363: LD_ADDR_VAR 0 2
53367: PUSH
53368: DOUBLE
53369: LD_INT 1
53371: DEC
53372: ST_TO_ADDR
53373: LD_EXP 99
53377: PUSH
53378: FOR_TO
53379: IFFALSE 53983
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53381: LD_EXP 134
53385: PUSH
53386: LD_VAR 0 2
53390: ARRAY
53391: NOT
53392: PUSH
53393: LD_INT 38
53395: PPUSH
53396: LD_EXP 125
53400: PUSH
53401: LD_VAR 0 2
53405: ARRAY
53406: PPUSH
53407: CALL_OW 321
53411: PUSH
53412: LD_INT 2
53414: NONEQUAL
53415: OR
53416: IFFALSE 53420
// continue ;
53418: GO 53378
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53420: LD_ADDR_VAR 0 8
53424: PUSH
53425: LD_EXP 99
53429: PUSH
53430: LD_VAR 0 2
53434: ARRAY
53435: PPUSH
53436: LD_INT 30
53438: PUSH
53439: LD_INT 34
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PPUSH
53446: CALL_OW 72
53450: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53451: LD_ADDR_VAR 0 9
53455: PUSH
53456: LD_EXP 99
53460: PUSH
53461: LD_VAR 0 2
53465: ARRAY
53466: PPUSH
53467: LD_INT 25
53469: PUSH
53470: LD_INT 4
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: PPUSH
53477: CALL_OW 72
53481: PPUSH
53482: LD_INT 0
53484: PPUSH
53485: CALL 102968 0 2
53489: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53490: LD_VAR 0 9
53494: NOT
53495: PUSH
53496: LD_VAR 0 8
53500: NOT
53501: OR
53502: PUSH
53503: LD_EXP 99
53507: PUSH
53508: LD_VAR 0 2
53512: ARRAY
53513: PPUSH
53514: LD_INT 124
53516: PPUSH
53517: CALL 102968 0 2
53521: OR
53522: IFFALSE 53526
// continue ;
53524: GO 53378
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53526: LD_EXP 135
53530: PUSH
53531: LD_VAR 0 2
53535: ARRAY
53536: PUSH
53537: LD_EXP 134
53541: PUSH
53542: LD_VAR 0 2
53546: ARRAY
53547: LESS
53548: PUSH
53549: LD_EXP 135
53553: PUSH
53554: LD_VAR 0 2
53558: ARRAY
53559: PUSH
53560: LD_VAR 0 8
53564: LESS
53565: AND
53566: IFFALSE 53981
// begin tmp := sci [ 1 ] ;
53568: LD_ADDR_VAR 0 7
53572: PUSH
53573: LD_VAR 0 9
53577: PUSH
53578: LD_INT 1
53580: ARRAY
53581: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53582: LD_VAR 0 7
53586: PPUSH
53587: LD_INT 124
53589: PPUSH
53590: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53594: LD_ADDR_VAR 0 3
53598: PUSH
53599: DOUBLE
53600: LD_EXP 134
53604: PUSH
53605: LD_VAR 0 2
53609: ARRAY
53610: INC
53611: ST_TO_ADDR
53612: LD_EXP 134
53616: PUSH
53617: LD_VAR 0 2
53621: ARRAY
53622: PUSH
53623: FOR_DOWNTO
53624: IFFALSE 53967
// begin if IsInUnit ( tmp ) then
53626: LD_VAR 0 7
53630: PPUSH
53631: CALL_OW 310
53635: IFFALSE 53646
// ComExitBuilding ( tmp ) ;
53637: LD_VAR 0 7
53641: PPUSH
53642: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
53646: LD_INT 35
53648: PPUSH
53649: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
53653: LD_VAR 0 7
53657: PPUSH
53658: CALL_OW 310
53662: NOT
53663: PUSH
53664: LD_VAR 0 7
53668: PPUSH
53669: CALL_OW 314
53673: NOT
53674: AND
53675: IFFALSE 53646
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
53677: LD_ADDR_VAR 0 6
53681: PUSH
53682: LD_VAR 0 7
53686: PPUSH
53687: CALL_OW 250
53691: PUSH
53692: LD_VAR 0 7
53696: PPUSH
53697: CALL_OW 251
53701: PUSH
53702: EMPTY
53703: LIST
53704: LIST
53705: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53706: LD_INT 35
53708: PPUSH
53709: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
53713: LD_ADDR_VAR 0 4
53717: PUSH
53718: LD_EXP 134
53722: PUSH
53723: LD_VAR 0 2
53727: ARRAY
53728: PUSH
53729: LD_VAR 0 3
53733: ARRAY
53734: PUSH
53735: LD_INT 1
53737: ARRAY
53738: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
53739: LD_ADDR_VAR 0 5
53743: PUSH
53744: LD_EXP 134
53748: PUSH
53749: LD_VAR 0 2
53753: ARRAY
53754: PUSH
53755: LD_VAR 0 3
53759: ARRAY
53760: PUSH
53761: LD_INT 2
53763: ARRAY
53764: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
53765: LD_VAR 0 7
53769: PPUSH
53770: LD_INT 10
53772: PPUSH
53773: CALL 72301 0 2
53777: PUSH
53778: LD_INT 4
53780: ARRAY
53781: IFFALSE 53819
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
53783: LD_VAR 0 7
53787: PPUSH
53788: LD_VAR 0 6
53792: PUSH
53793: LD_INT 1
53795: ARRAY
53796: PPUSH
53797: LD_VAR 0 6
53801: PUSH
53802: LD_INT 2
53804: ARRAY
53805: PPUSH
53806: CALL_OW 111
// wait ( 0 0$10 ) ;
53810: LD_INT 350
53812: PPUSH
53813: CALL_OW 67
// end else
53817: GO 53845
// begin ComMoveXY ( tmp , x , y ) ;
53819: LD_VAR 0 7
53823: PPUSH
53824: LD_VAR 0 4
53828: PPUSH
53829: LD_VAR 0 5
53833: PPUSH
53834: CALL_OW 111
// wait ( 0 0$3 ) ;
53838: LD_INT 105
53840: PPUSH
53841: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
53845: LD_VAR 0 7
53849: PPUSH
53850: LD_VAR 0 4
53854: PPUSH
53855: LD_VAR 0 5
53859: PPUSH
53860: CALL_OW 307
53864: IFFALSE 53706
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
53866: LD_VAR 0 7
53870: PPUSH
53871: LD_VAR 0 4
53875: PPUSH
53876: LD_VAR 0 5
53880: PPUSH
53881: LD_VAR 0 8
53885: PUSH
53886: LD_VAR 0 3
53890: ARRAY
53891: PPUSH
53892: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
53896: LD_INT 35
53898: PPUSH
53899: CALL_OW 67
// until not HasTask ( tmp ) ;
53903: LD_VAR 0 7
53907: PPUSH
53908: CALL_OW 314
53912: NOT
53913: IFFALSE 53896
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
53915: LD_ADDR_EXP 135
53919: PUSH
53920: LD_EXP 135
53924: PPUSH
53925: LD_VAR 0 2
53929: PUSH
53930: LD_EXP 135
53934: PUSH
53935: LD_VAR 0 2
53939: ARRAY
53940: PUSH
53941: LD_INT 1
53943: PLUS
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: PPUSH
53949: LD_VAR 0 8
53953: PUSH
53954: LD_VAR 0 3
53958: ARRAY
53959: PPUSH
53960: CALL 69708 0 3
53964: ST_TO_ADDR
// end ;
53965: GO 53623
53967: POP
53968: POP
// MC_Reset ( i , 124 ) ;
53969: LD_VAR 0 2
53973: PPUSH
53974: LD_INT 124
53976: PPUSH
53977: CALL 37830 0 2
// end ; end ;
53981: GO 53378
53983: POP
53984: POP
// end ;
53985: LD_VAR 0 1
53989: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53990: LD_INT 0
53992: PPUSH
53993: PPUSH
53994: PPUSH
// if not mc_bases then
53995: LD_EXP 99
53999: NOT
54000: IFFALSE 54004
// exit ;
54002: GO 54610
// for i = 1 to mc_bases do
54004: LD_ADDR_VAR 0 2
54008: PUSH
54009: DOUBLE
54010: LD_INT 1
54012: DEC
54013: ST_TO_ADDR
54014: LD_EXP 99
54018: PUSH
54019: FOR_TO
54020: IFFALSE 54608
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54022: LD_ADDR_VAR 0 3
54026: PUSH
54027: LD_EXP 99
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PPUSH
54038: LD_INT 25
54040: PUSH
54041: LD_INT 4
54043: PUSH
54044: EMPTY
54045: LIST
54046: LIST
54047: PPUSH
54048: CALL_OW 72
54052: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54053: LD_VAR 0 3
54057: NOT
54058: PUSH
54059: LD_EXP 136
54063: PUSH
54064: LD_VAR 0 2
54068: ARRAY
54069: NOT
54070: OR
54071: PUSH
54072: LD_EXP 99
54076: PUSH
54077: LD_VAR 0 2
54081: ARRAY
54082: PPUSH
54083: LD_INT 2
54085: PUSH
54086: LD_INT 30
54088: PUSH
54089: LD_INT 0
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: LD_INT 30
54098: PUSH
54099: LD_INT 1
54101: PUSH
54102: EMPTY
54103: LIST
54104: LIST
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: LIST
54110: PPUSH
54111: CALL_OW 72
54115: NOT
54116: OR
54117: IFFALSE 54167
// begin if mc_deposits_finder [ i ] then
54119: LD_EXP 137
54123: PUSH
54124: LD_VAR 0 2
54128: ARRAY
54129: IFFALSE 54165
// begin MC_Reset ( i , 125 ) ;
54131: LD_VAR 0 2
54135: PPUSH
54136: LD_INT 125
54138: PPUSH
54139: CALL 37830 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54143: LD_ADDR_EXP 137
54147: PUSH
54148: LD_EXP 137
54152: PPUSH
54153: LD_VAR 0 2
54157: PPUSH
54158: EMPTY
54159: PPUSH
54160: CALL_OW 1
54164: ST_TO_ADDR
// end ; continue ;
54165: GO 54019
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54167: LD_EXP 136
54171: PUSH
54172: LD_VAR 0 2
54176: ARRAY
54177: PUSH
54178: LD_INT 1
54180: ARRAY
54181: PUSH
54182: LD_INT 3
54184: ARRAY
54185: PUSH
54186: LD_INT 1
54188: EQUAL
54189: PUSH
54190: LD_INT 20
54192: PPUSH
54193: LD_EXP 125
54197: PUSH
54198: LD_VAR 0 2
54202: ARRAY
54203: PPUSH
54204: CALL_OW 321
54208: PUSH
54209: LD_INT 2
54211: NONEQUAL
54212: AND
54213: IFFALSE 54263
// begin if mc_deposits_finder [ i ] then
54215: LD_EXP 137
54219: PUSH
54220: LD_VAR 0 2
54224: ARRAY
54225: IFFALSE 54261
// begin MC_Reset ( i , 125 ) ;
54227: LD_VAR 0 2
54231: PPUSH
54232: LD_INT 125
54234: PPUSH
54235: CALL 37830 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54239: LD_ADDR_EXP 137
54243: PUSH
54244: LD_EXP 137
54248: PPUSH
54249: LD_VAR 0 2
54253: PPUSH
54254: EMPTY
54255: PPUSH
54256: CALL_OW 1
54260: ST_TO_ADDR
// end ; continue ;
54261: GO 54019
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54263: LD_EXP 136
54267: PUSH
54268: LD_VAR 0 2
54272: ARRAY
54273: PUSH
54274: LD_INT 1
54276: ARRAY
54277: PUSH
54278: LD_INT 1
54280: ARRAY
54281: PPUSH
54282: LD_EXP 136
54286: PUSH
54287: LD_VAR 0 2
54291: ARRAY
54292: PUSH
54293: LD_INT 1
54295: ARRAY
54296: PUSH
54297: LD_INT 2
54299: ARRAY
54300: PPUSH
54301: LD_EXP 125
54305: PUSH
54306: LD_VAR 0 2
54310: ARRAY
54311: PPUSH
54312: CALL_OW 440
54316: IFFALSE 54359
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54318: LD_ADDR_EXP 136
54322: PUSH
54323: LD_EXP 136
54327: PPUSH
54328: LD_VAR 0 2
54332: PPUSH
54333: LD_EXP 136
54337: PUSH
54338: LD_VAR 0 2
54342: ARRAY
54343: PPUSH
54344: LD_INT 1
54346: PPUSH
54347: CALL_OW 3
54351: PPUSH
54352: CALL_OW 1
54356: ST_TO_ADDR
54357: GO 54606
// begin if not mc_deposits_finder [ i ] then
54359: LD_EXP 137
54363: PUSH
54364: LD_VAR 0 2
54368: ARRAY
54369: NOT
54370: IFFALSE 54422
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54372: LD_ADDR_EXP 137
54376: PUSH
54377: LD_EXP 137
54381: PPUSH
54382: LD_VAR 0 2
54386: PPUSH
54387: LD_VAR 0 3
54391: PUSH
54392: LD_INT 1
54394: ARRAY
54395: PUSH
54396: EMPTY
54397: LIST
54398: PPUSH
54399: CALL_OW 1
54403: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54404: LD_VAR 0 3
54408: PUSH
54409: LD_INT 1
54411: ARRAY
54412: PPUSH
54413: LD_INT 125
54415: PPUSH
54416: CALL_OW 109
// end else
54420: GO 54606
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54422: LD_EXP 137
54426: PUSH
54427: LD_VAR 0 2
54431: ARRAY
54432: PUSH
54433: LD_INT 1
54435: ARRAY
54436: PPUSH
54437: CALL_OW 310
54441: IFFALSE 54464
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54443: LD_EXP 137
54447: PUSH
54448: LD_VAR 0 2
54452: ARRAY
54453: PUSH
54454: LD_INT 1
54456: ARRAY
54457: PPUSH
54458: CALL_OW 122
54462: GO 54606
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54464: LD_EXP 137
54468: PUSH
54469: LD_VAR 0 2
54473: ARRAY
54474: PUSH
54475: LD_INT 1
54477: ARRAY
54478: PPUSH
54479: CALL_OW 314
54483: NOT
54484: PUSH
54485: LD_EXP 137
54489: PUSH
54490: LD_VAR 0 2
54494: ARRAY
54495: PUSH
54496: LD_INT 1
54498: ARRAY
54499: PPUSH
54500: LD_EXP 136
54504: PUSH
54505: LD_VAR 0 2
54509: ARRAY
54510: PUSH
54511: LD_INT 1
54513: ARRAY
54514: PUSH
54515: LD_INT 1
54517: ARRAY
54518: PPUSH
54519: LD_EXP 136
54523: PUSH
54524: LD_VAR 0 2
54528: ARRAY
54529: PUSH
54530: LD_INT 1
54532: ARRAY
54533: PUSH
54534: LD_INT 2
54536: ARRAY
54537: PPUSH
54538: CALL_OW 297
54542: PUSH
54543: LD_INT 6
54545: GREATER
54546: AND
54547: IFFALSE 54606
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54549: LD_EXP 137
54553: PUSH
54554: LD_VAR 0 2
54558: ARRAY
54559: PUSH
54560: LD_INT 1
54562: ARRAY
54563: PPUSH
54564: LD_EXP 136
54568: PUSH
54569: LD_VAR 0 2
54573: ARRAY
54574: PUSH
54575: LD_INT 1
54577: ARRAY
54578: PUSH
54579: LD_INT 1
54581: ARRAY
54582: PPUSH
54583: LD_EXP 136
54587: PUSH
54588: LD_VAR 0 2
54592: ARRAY
54593: PUSH
54594: LD_INT 1
54596: ARRAY
54597: PUSH
54598: LD_INT 2
54600: ARRAY
54601: PPUSH
54602: CALL_OW 111
// end ; end ; end ;
54606: GO 54019
54608: POP
54609: POP
// end ;
54610: LD_VAR 0 1
54614: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
54615: LD_INT 0
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
54625: PPUSH
54626: PPUSH
54627: PPUSH
// if not mc_bases then
54628: LD_EXP 99
54632: NOT
54633: IFFALSE 54637
// exit ;
54635: GO 55361
// for i = 1 to mc_bases do
54637: LD_ADDR_VAR 0 2
54641: PUSH
54642: DOUBLE
54643: LD_INT 1
54645: DEC
54646: ST_TO_ADDR
54647: LD_EXP 99
54651: PUSH
54652: FOR_TO
54653: IFFALSE 55359
// begin if not mc_bases [ i ] then
54655: LD_EXP 99
54659: PUSH
54660: LD_VAR 0 2
54664: ARRAY
54665: NOT
54666: IFFALSE 54670
// continue ;
54668: GO 54652
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
54670: LD_ADDR_VAR 0 7
54674: PUSH
54675: LD_EXP 99
54679: PUSH
54680: LD_VAR 0 2
54684: ARRAY
54685: PUSH
54686: LD_INT 1
54688: ARRAY
54689: PPUSH
54690: CALL_OW 248
54694: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
54695: LD_VAR 0 7
54699: PUSH
54700: LD_INT 3
54702: EQUAL
54703: PUSH
54704: LD_EXP 118
54708: PUSH
54709: LD_VAR 0 2
54713: ARRAY
54714: PUSH
54715: LD_EXP 121
54719: PUSH
54720: LD_VAR 0 2
54724: ARRAY
54725: UNION
54726: PPUSH
54727: LD_INT 33
54729: PUSH
54730: LD_INT 2
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: PPUSH
54737: CALL_OW 72
54741: NOT
54742: OR
54743: IFFALSE 54747
// continue ;
54745: GO 54652
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
54747: LD_ADDR_VAR 0 9
54751: PUSH
54752: LD_EXP 99
54756: PUSH
54757: LD_VAR 0 2
54761: ARRAY
54762: PPUSH
54763: LD_INT 30
54765: PUSH
54766: LD_INT 36
54768: PUSH
54769: EMPTY
54770: LIST
54771: LIST
54772: PPUSH
54773: CALL_OW 72
54777: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
54778: LD_ADDR_VAR 0 10
54782: PUSH
54783: LD_EXP 118
54787: PUSH
54788: LD_VAR 0 2
54792: ARRAY
54793: PPUSH
54794: LD_INT 34
54796: PUSH
54797: LD_INT 31
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: PPUSH
54804: CALL_OW 72
54808: ST_TO_ADDR
// if not cts and not mcts then
54809: LD_VAR 0 9
54813: NOT
54814: PUSH
54815: LD_VAR 0 10
54819: NOT
54820: AND
54821: IFFALSE 54825
// continue ;
54823: GO 54652
// x := cts ;
54825: LD_ADDR_VAR 0 11
54829: PUSH
54830: LD_VAR 0 9
54834: ST_TO_ADDR
// if not x then
54835: LD_VAR 0 11
54839: NOT
54840: IFFALSE 54852
// x := mcts ;
54842: LD_ADDR_VAR 0 11
54846: PUSH
54847: LD_VAR 0 10
54851: ST_TO_ADDR
// if mc_remote_driver [ i ] then
54852: LD_EXP 139
54856: PUSH
54857: LD_VAR 0 2
54861: ARRAY
54862: IFFALSE 55131
// for j in mc_remote_driver [ i ] do
54864: LD_ADDR_VAR 0 3
54868: PUSH
54869: LD_EXP 139
54873: PUSH
54874: LD_VAR 0 2
54878: ARRAY
54879: PUSH
54880: FOR_IN
54881: IFFALSE 55129
// begin if GetClass ( j ) <> 3 then
54883: LD_VAR 0 3
54887: PPUSH
54888: CALL_OW 257
54892: PUSH
54893: LD_INT 3
54895: NONEQUAL
54896: IFFALSE 54949
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
54898: LD_ADDR_EXP 139
54902: PUSH
54903: LD_EXP 139
54907: PPUSH
54908: LD_VAR 0 2
54912: PPUSH
54913: LD_EXP 139
54917: PUSH
54918: LD_VAR 0 2
54922: ARRAY
54923: PUSH
54924: LD_VAR 0 3
54928: DIFF
54929: PPUSH
54930: CALL_OW 1
54934: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54935: LD_VAR 0 3
54939: PPUSH
54940: LD_INT 0
54942: PPUSH
54943: CALL_OW 109
// continue ;
54947: GO 54880
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
54949: LD_VAR 0 3
54953: PPUSH
54954: CALL_OW 310
54958: NOT
54959: PUSH
54960: LD_VAR 0 3
54964: PPUSH
54965: CALL_OW 310
54969: PPUSH
54970: CALL_OW 266
54974: PUSH
54975: LD_INT 36
54977: NONEQUAL
54978: PUSH
54979: LD_VAR 0 3
54983: PPUSH
54984: CALL 103056 0 1
54988: NOT
54989: AND
54990: OR
54991: IFFALSE 55127
// begin if IsInUnit ( j ) then
54993: LD_VAR 0 3
54997: PPUSH
54998: CALL_OW 310
55002: IFFALSE 55013
// ComExitBuilding ( j ) ;
55004: LD_VAR 0 3
55008: PPUSH
55009: CALL_OW 122
// ct := 0 ;
55013: LD_ADDR_VAR 0 8
55017: PUSH
55018: LD_INT 0
55020: ST_TO_ADDR
// for k in x do
55021: LD_ADDR_VAR 0 4
55025: PUSH
55026: LD_VAR 0 11
55030: PUSH
55031: FOR_IN
55032: IFFALSE 55105
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55034: LD_VAR 0 4
55038: PPUSH
55039: CALL_OW 264
55043: PUSH
55044: LD_INT 31
55046: EQUAL
55047: PUSH
55048: LD_VAR 0 4
55052: PPUSH
55053: CALL_OW 311
55057: NOT
55058: AND
55059: PUSH
55060: LD_VAR 0 4
55064: PPUSH
55065: CALL_OW 266
55069: PUSH
55070: LD_INT 36
55072: EQUAL
55073: PUSH
55074: LD_VAR 0 4
55078: PPUSH
55079: CALL_OW 313
55083: PUSH
55084: LD_INT 3
55086: LESS
55087: AND
55088: OR
55089: IFFALSE 55103
// begin ct := k ;
55091: LD_ADDR_VAR 0 8
55095: PUSH
55096: LD_VAR 0 4
55100: ST_TO_ADDR
// break ;
55101: GO 55105
// end ;
55103: GO 55031
55105: POP
55106: POP
// if ct then
55107: LD_VAR 0 8
55111: IFFALSE 55127
// ComEnterUnit ( j , ct ) ;
55113: LD_VAR 0 3
55117: PPUSH
55118: LD_VAR 0 8
55122: PPUSH
55123: CALL_OW 120
// end ; end ;
55127: GO 54880
55129: POP
55130: POP
// places := 0 ;
55131: LD_ADDR_VAR 0 5
55135: PUSH
55136: LD_INT 0
55138: ST_TO_ADDR
// for j = 1 to x do
55139: LD_ADDR_VAR 0 3
55143: PUSH
55144: DOUBLE
55145: LD_INT 1
55147: DEC
55148: ST_TO_ADDR
55149: LD_VAR 0 11
55153: PUSH
55154: FOR_TO
55155: IFFALSE 55210
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55157: LD_VAR 0 11
55161: PUSH
55162: LD_VAR 0 3
55166: ARRAY
55167: PPUSH
55168: CALL_OW 264
55172: PUSH
55173: LD_INT 31
55175: EQUAL
55176: IFFALSE 55194
// places := places + 1 else
55178: LD_ADDR_VAR 0 5
55182: PUSH
55183: LD_VAR 0 5
55187: PUSH
55188: LD_INT 1
55190: PLUS
55191: ST_TO_ADDR
55192: GO 55208
// places := places + 3 ;
55194: LD_ADDR_VAR 0 5
55198: PUSH
55199: LD_VAR 0 5
55203: PUSH
55204: LD_INT 3
55206: PLUS
55207: ST_TO_ADDR
55208: GO 55154
55210: POP
55211: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55212: LD_ADDR_VAR 0 6
55216: PUSH
55217: LD_EXP 99
55221: PUSH
55222: LD_VAR 0 2
55226: ARRAY
55227: PPUSH
55228: LD_INT 25
55230: PUSH
55231: LD_INT 3
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: PPUSH
55238: CALL_OW 72
55242: PUSH
55243: LD_EXP 139
55247: PUSH
55248: LD_VAR 0 2
55252: ARRAY
55253: DIFF
55254: PPUSH
55255: LD_INT 3
55257: PPUSH
55258: CALL 103956 0 2
55262: ST_TO_ADDR
// if not tmp then
55263: LD_VAR 0 6
55267: NOT
55268: IFFALSE 55272
// continue ;
55270: GO 54652
// places := places - mc_remote_driver [ i ] ;
55272: LD_ADDR_VAR 0 5
55276: PUSH
55277: LD_VAR 0 5
55281: PUSH
55282: LD_EXP 139
55286: PUSH
55287: LD_VAR 0 2
55291: ARRAY
55292: MINUS
55293: ST_TO_ADDR
// if places then
55294: LD_VAR 0 5
55298: IFFALSE 55357
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55300: LD_ADDR_EXP 139
55304: PUSH
55305: LD_EXP 139
55309: PPUSH
55310: LD_VAR 0 2
55314: PPUSH
55315: LD_EXP 139
55319: PUSH
55320: LD_VAR 0 2
55324: ARRAY
55325: PUSH
55326: LD_VAR 0 6
55330: PUSH
55331: LD_INT 1
55333: ARRAY
55334: UNION
55335: PPUSH
55336: CALL_OW 1
55340: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55341: LD_VAR 0 6
55345: PUSH
55346: LD_INT 1
55348: ARRAY
55349: PPUSH
55350: LD_INT 126
55352: PPUSH
55353: CALL_OW 109
// end ; end ;
55357: GO 54652
55359: POP
55360: POP
// end ;
55361: LD_VAR 0 1
55365: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55366: LD_INT 0
55368: PPUSH
55369: PPUSH
55370: PPUSH
55371: PPUSH
55372: PPUSH
55373: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55374: LD_VAR 0 1
55378: NOT
55379: PUSH
55380: LD_VAR 0 2
55384: NOT
55385: OR
55386: PUSH
55387: LD_VAR 0 3
55391: NOT
55392: OR
55393: PUSH
55394: LD_VAR 0 4
55398: PUSH
55399: LD_INT 1
55401: PUSH
55402: LD_INT 2
55404: PUSH
55405: LD_INT 3
55407: PUSH
55408: LD_INT 4
55410: PUSH
55411: LD_INT 5
55413: PUSH
55414: LD_INT 8
55416: PUSH
55417: LD_INT 9
55419: PUSH
55420: LD_INT 15
55422: PUSH
55423: LD_INT 16
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: LIST
55430: LIST
55431: LIST
55432: LIST
55433: LIST
55434: LIST
55435: LIST
55436: IN
55437: NOT
55438: OR
55439: IFFALSE 55443
// exit ;
55441: GO 56343
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55443: LD_ADDR_VAR 0 2
55447: PUSH
55448: LD_VAR 0 2
55452: PPUSH
55453: LD_INT 21
55455: PUSH
55456: LD_INT 3
55458: PUSH
55459: EMPTY
55460: LIST
55461: LIST
55462: PUSH
55463: LD_INT 24
55465: PUSH
55466: LD_INT 250
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: PPUSH
55477: CALL_OW 72
55481: ST_TO_ADDR
// case class of 1 , 15 :
55482: LD_VAR 0 4
55486: PUSH
55487: LD_INT 1
55489: DOUBLE
55490: EQUAL
55491: IFTRUE 55501
55493: LD_INT 15
55495: DOUBLE
55496: EQUAL
55497: IFTRUE 55501
55499: GO 55586
55501: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55502: LD_ADDR_VAR 0 8
55506: PUSH
55507: LD_VAR 0 2
55511: PPUSH
55512: LD_INT 2
55514: PUSH
55515: LD_INT 30
55517: PUSH
55518: LD_INT 32
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: LD_INT 30
55527: PUSH
55528: LD_INT 31
55530: PUSH
55531: EMPTY
55532: LIST
55533: LIST
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: PPUSH
55540: CALL_OW 72
55544: PUSH
55545: LD_VAR 0 2
55549: PPUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 30
55555: PUSH
55556: LD_INT 4
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: PUSH
55563: LD_INT 30
55565: PUSH
55566: LD_INT 5
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: LIST
55577: PPUSH
55578: CALL_OW 72
55582: ADD
55583: ST_TO_ADDR
55584: GO 55832
55586: LD_INT 2
55588: DOUBLE
55589: EQUAL
55590: IFTRUE 55600
55592: LD_INT 16
55594: DOUBLE
55595: EQUAL
55596: IFTRUE 55600
55598: GO 55646
55600: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55601: LD_ADDR_VAR 0 8
55605: PUSH
55606: LD_VAR 0 2
55610: PPUSH
55611: LD_INT 2
55613: PUSH
55614: LD_INT 30
55616: PUSH
55617: LD_INT 0
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PUSH
55624: LD_INT 30
55626: PUSH
55627: LD_INT 1
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: PPUSH
55639: CALL_OW 72
55643: ST_TO_ADDR
55644: GO 55832
55646: LD_INT 3
55648: DOUBLE
55649: EQUAL
55650: IFTRUE 55654
55652: GO 55700
55654: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
55655: LD_ADDR_VAR 0 8
55659: PUSH
55660: LD_VAR 0 2
55664: PPUSH
55665: LD_INT 2
55667: PUSH
55668: LD_INT 30
55670: PUSH
55671: LD_INT 2
55673: PUSH
55674: EMPTY
55675: LIST
55676: LIST
55677: PUSH
55678: LD_INT 30
55680: PUSH
55681: LD_INT 3
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: LIST
55692: PPUSH
55693: CALL_OW 72
55697: ST_TO_ADDR
55698: GO 55832
55700: LD_INT 4
55702: DOUBLE
55703: EQUAL
55704: IFTRUE 55708
55706: GO 55765
55708: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
55709: LD_ADDR_VAR 0 8
55713: PUSH
55714: LD_VAR 0 2
55718: PPUSH
55719: LD_INT 2
55721: PUSH
55722: LD_INT 30
55724: PUSH
55725: LD_INT 6
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: PUSH
55732: LD_INT 30
55734: PUSH
55735: LD_INT 7
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: PUSH
55742: LD_INT 30
55744: PUSH
55745: LD_INT 8
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: LIST
55756: LIST
55757: PPUSH
55758: CALL_OW 72
55762: ST_TO_ADDR
55763: GO 55832
55765: LD_INT 5
55767: DOUBLE
55768: EQUAL
55769: IFTRUE 55785
55771: LD_INT 8
55773: DOUBLE
55774: EQUAL
55775: IFTRUE 55785
55777: LD_INT 9
55779: DOUBLE
55780: EQUAL
55781: IFTRUE 55785
55783: GO 55831
55785: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
55786: LD_ADDR_VAR 0 8
55790: PUSH
55791: LD_VAR 0 2
55795: PPUSH
55796: LD_INT 2
55798: PUSH
55799: LD_INT 30
55801: PUSH
55802: LD_INT 4
55804: PUSH
55805: EMPTY
55806: LIST
55807: LIST
55808: PUSH
55809: LD_INT 30
55811: PUSH
55812: LD_INT 5
55814: PUSH
55815: EMPTY
55816: LIST
55817: LIST
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: PPUSH
55824: CALL_OW 72
55828: ST_TO_ADDR
55829: GO 55832
55831: POP
// if not tmp then
55832: LD_VAR 0 8
55836: NOT
55837: IFFALSE 55841
// exit ;
55839: GO 56343
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
55841: LD_VAR 0 4
55845: PUSH
55846: LD_INT 1
55848: PUSH
55849: LD_INT 15
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: IN
55856: PUSH
55857: LD_EXP 108
55861: PUSH
55862: LD_VAR 0 1
55866: ARRAY
55867: AND
55868: IFFALSE 56024
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
55870: LD_ADDR_VAR 0 9
55874: PUSH
55875: LD_EXP 108
55879: PUSH
55880: LD_VAR 0 1
55884: ARRAY
55885: PUSH
55886: LD_INT 1
55888: ARRAY
55889: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
55890: LD_VAR 0 9
55894: PUSH
55895: LD_EXP 109
55899: PUSH
55900: LD_VAR 0 1
55904: ARRAY
55905: IN
55906: NOT
55907: IFFALSE 56022
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
55909: LD_ADDR_EXP 109
55913: PUSH
55914: LD_EXP 109
55918: PPUSH
55919: LD_VAR 0 1
55923: PUSH
55924: LD_EXP 109
55928: PUSH
55929: LD_VAR 0 1
55933: ARRAY
55934: PUSH
55935: LD_INT 1
55937: PLUS
55938: PUSH
55939: EMPTY
55940: LIST
55941: LIST
55942: PPUSH
55943: LD_VAR 0 9
55947: PPUSH
55948: CALL 69708 0 3
55952: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
55953: LD_ADDR_EXP 108
55957: PUSH
55958: LD_EXP 108
55962: PPUSH
55963: LD_VAR 0 1
55967: PPUSH
55968: LD_EXP 108
55972: PUSH
55973: LD_VAR 0 1
55977: ARRAY
55978: PUSH
55979: LD_VAR 0 9
55983: DIFF
55984: PPUSH
55985: CALL_OW 1
55989: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55990: LD_VAR 0 3
55994: PPUSH
55995: LD_EXP 109
55999: PUSH
56000: LD_VAR 0 1
56004: ARRAY
56005: PUSH
56006: LD_EXP 109
56010: PUSH
56011: LD_VAR 0 1
56015: ARRAY
56016: ARRAY
56017: PPUSH
56018: CALL_OW 120
// end ; exit ;
56022: GO 56343
// end ; if tmp > 1 then
56024: LD_VAR 0 8
56028: PUSH
56029: LD_INT 1
56031: GREATER
56032: IFFALSE 56136
// for i = 2 to tmp do
56034: LD_ADDR_VAR 0 6
56038: PUSH
56039: DOUBLE
56040: LD_INT 2
56042: DEC
56043: ST_TO_ADDR
56044: LD_VAR 0 8
56048: PUSH
56049: FOR_TO
56050: IFFALSE 56134
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56052: LD_VAR 0 8
56056: PUSH
56057: LD_VAR 0 6
56061: ARRAY
56062: PPUSH
56063: CALL_OW 461
56067: PUSH
56068: LD_INT 6
56070: EQUAL
56071: IFFALSE 56132
// begin x := tmp [ i ] ;
56073: LD_ADDR_VAR 0 9
56077: PUSH
56078: LD_VAR 0 8
56082: PUSH
56083: LD_VAR 0 6
56087: ARRAY
56088: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56089: LD_ADDR_VAR 0 8
56093: PUSH
56094: LD_VAR 0 8
56098: PPUSH
56099: LD_VAR 0 6
56103: PPUSH
56104: CALL_OW 3
56108: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56109: LD_ADDR_VAR 0 8
56113: PUSH
56114: LD_VAR 0 8
56118: PPUSH
56119: LD_INT 1
56121: PPUSH
56122: LD_VAR 0 9
56126: PPUSH
56127: CALL_OW 2
56131: ST_TO_ADDR
// end ;
56132: GO 56049
56134: POP
56135: POP
// for i in tmp do
56136: LD_ADDR_VAR 0 6
56140: PUSH
56141: LD_VAR 0 8
56145: PUSH
56146: FOR_IN
56147: IFFALSE 56216
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56149: LD_VAR 0 6
56153: PPUSH
56154: CALL_OW 313
56158: PUSH
56159: LD_INT 6
56161: LESS
56162: PUSH
56163: LD_VAR 0 6
56167: PPUSH
56168: CALL_OW 266
56172: PUSH
56173: LD_INT 31
56175: PUSH
56176: LD_INT 32
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: IN
56183: NOT
56184: AND
56185: PUSH
56186: LD_VAR 0 6
56190: PPUSH
56191: CALL_OW 313
56195: PUSH
56196: LD_INT 0
56198: EQUAL
56199: OR
56200: IFFALSE 56214
// begin j := i ;
56202: LD_ADDR_VAR 0 7
56206: PUSH
56207: LD_VAR 0 6
56211: ST_TO_ADDR
// break ;
56212: GO 56216
// end ; end ;
56214: GO 56146
56216: POP
56217: POP
// if j then
56218: LD_VAR 0 7
56222: IFFALSE 56240
// ComEnterUnit ( unit , j ) else
56224: LD_VAR 0 3
56228: PPUSH
56229: LD_VAR 0 7
56233: PPUSH
56234: CALL_OW 120
56238: GO 56343
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56240: LD_ADDR_VAR 0 10
56244: PUSH
56245: LD_VAR 0 2
56249: PPUSH
56250: LD_INT 2
56252: PUSH
56253: LD_INT 30
56255: PUSH
56256: LD_INT 0
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PUSH
56263: LD_INT 30
56265: PUSH
56266: LD_INT 1
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: LIST
56277: PPUSH
56278: CALL_OW 72
56282: ST_TO_ADDR
// if depot then
56283: LD_VAR 0 10
56287: IFFALSE 56343
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56289: LD_ADDR_VAR 0 10
56293: PUSH
56294: LD_VAR 0 10
56298: PPUSH
56299: LD_VAR 0 3
56303: PPUSH
56304: CALL_OW 74
56308: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56309: LD_VAR 0 3
56313: PPUSH
56314: LD_VAR 0 10
56318: PPUSH
56319: CALL_OW 296
56323: PUSH
56324: LD_INT 10
56326: GREATER
56327: IFFALSE 56343
// ComStandNearbyBuilding ( unit , depot ) ;
56329: LD_VAR 0 3
56333: PPUSH
56334: LD_VAR 0 10
56338: PPUSH
56339: CALL 64415 0 2
// end ; end ; end ;
56343: LD_VAR 0 5
56347: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56348: LD_INT 0
56350: PPUSH
56351: PPUSH
56352: PPUSH
56353: PPUSH
// if not mc_bases then
56354: LD_EXP 99
56358: NOT
56359: IFFALSE 56363
// exit ;
56361: GO 56602
// for i = 1 to mc_bases do
56363: LD_ADDR_VAR 0 2
56367: PUSH
56368: DOUBLE
56369: LD_INT 1
56371: DEC
56372: ST_TO_ADDR
56373: LD_EXP 99
56377: PUSH
56378: FOR_TO
56379: IFFALSE 56600
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56381: LD_ADDR_VAR 0 4
56385: PUSH
56386: LD_EXP 99
56390: PUSH
56391: LD_VAR 0 2
56395: ARRAY
56396: PPUSH
56397: LD_INT 21
56399: PUSH
56400: LD_INT 1
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PPUSH
56407: CALL_OW 72
56411: PUSH
56412: LD_EXP 128
56416: PUSH
56417: LD_VAR 0 2
56421: ARRAY
56422: UNION
56423: ST_TO_ADDR
// if not tmp then
56424: LD_VAR 0 4
56428: NOT
56429: IFFALSE 56433
// continue ;
56431: GO 56378
// for j in tmp do
56433: LD_ADDR_VAR 0 3
56437: PUSH
56438: LD_VAR 0 4
56442: PUSH
56443: FOR_IN
56444: IFFALSE 56596
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56446: LD_VAR 0 3
56450: PPUSH
56451: CALL_OW 110
56455: NOT
56456: PUSH
56457: LD_VAR 0 3
56461: PPUSH
56462: CALL_OW 314
56466: NOT
56467: AND
56468: PUSH
56469: LD_VAR 0 3
56473: PPUSH
56474: CALL_OW 311
56478: NOT
56479: AND
56480: PUSH
56481: LD_VAR 0 3
56485: PPUSH
56486: CALL_OW 310
56490: NOT
56491: AND
56492: PUSH
56493: LD_VAR 0 3
56497: PUSH
56498: LD_EXP 102
56502: PUSH
56503: LD_VAR 0 2
56507: ARRAY
56508: PUSH
56509: LD_INT 1
56511: ARRAY
56512: IN
56513: NOT
56514: AND
56515: PUSH
56516: LD_VAR 0 3
56520: PUSH
56521: LD_EXP 102
56525: PUSH
56526: LD_VAR 0 2
56530: ARRAY
56531: PUSH
56532: LD_INT 2
56534: ARRAY
56535: IN
56536: NOT
56537: AND
56538: PUSH
56539: LD_VAR 0 3
56543: PUSH
56544: LD_EXP 111
56548: PUSH
56549: LD_VAR 0 2
56553: ARRAY
56554: IN
56555: NOT
56556: AND
56557: IFFALSE 56594
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56559: LD_VAR 0 2
56563: PPUSH
56564: LD_EXP 99
56568: PUSH
56569: LD_VAR 0 2
56573: ARRAY
56574: PPUSH
56575: LD_VAR 0 3
56579: PPUSH
56580: LD_VAR 0 3
56584: PPUSH
56585: CALL_OW 257
56589: PPUSH
56590: CALL 55366 0 4
// end ;
56594: GO 56443
56596: POP
56597: POP
// end ;
56598: GO 56378
56600: POP
56601: POP
// end ;
56602: LD_VAR 0 1
56606: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
56607: LD_INT 0
56609: PPUSH
56610: PPUSH
56611: PPUSH
56612: PPUSH
56613: PPUSH
56614: PPUSH
// if not mc_bases [ base ] then
56615: LD_EXP 99
56619: PUSH
56620: LD_VAR 0 1
56624: ARRAY
56625: NOT
56626: IFFALSE 56630
// exit ;
56628: GO 56812
// tmp := [ ] ;
56630: LD_ADDR_VAR 0 6
56634: PUSH
56635: EMPTY
56636: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
56637: LD_ADDR_VAR 0 7
56641: PUSH
56642: LD_VAR 0 3
56646: PPUSH
56647: LD_INT 0
56649: PPUSH
56650: CALL_OW 517
56654: ST_TO_ADDR
// if not list then
56655: LD_VAR 0 7
56659: NOT
56660: IFFALSE 56664
// exit ;
56662: GO 56812
// for i = 1 to amount do
56664: LD_ADDR_VAR 0 5
56668: PUSH
56669: DOUBLE
56670: LD_INT 1
56672: DEC
56673: ST_TO_ADDR
56674: LD_VAR 0 2
56678: PUSH
56679: FOR_TO
56680: IFFALSE 56760
// begin x := rand ( 1 , list [ 1 ] ) ;
56682: LD_ADDR_VAR 0 8
56686: PUSH
56687: LD_INT 1
56689: PPUSH
56690: LD_VAR 0 7
56694: PUSH
56695: LD_INT 1
56697: ARRAY
56698: PPUSH
56699: CALL_OW 12
56703: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
56704: LD_ADDR_VAR 0 6
56708: PUSH
56709: LD_VAR 0 6
56713: PPUSH
56714: LD_VAR 0 5
56718: PPUSH
56719: LD_VAR 0 7
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PUSH
56728: LD_VAR 0 8
56732: ARRAY
56733: PUSH
56734: LD_VAR 0 7
56738: PUSH
56739: LD_INT 2
56741: ARRAY
56742: PUSH
56743: LD_VAR 0 8
56747: ARRAY
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PPUSH
56753: CALL_OW 1
56757: ST_TO_ADDR
// end ;
56758: GO 56679
56760: POP
56761: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
56762: LD_ADDR_EXP 112
56766: PUSH
56767: LD_EXP 112
56771: PPUSH
56772: LD_VAR 0 1
56776: PPUSH
56777: LD_VAR 0 6
56781: PPUSH
56782: CALL_OW 1
56786: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
56787: LD_ADDR_EXP 114
56791: PUSH
56792: LD_EXP 114
56796: PPUSH
56797: LD_VAR 0 1
56801: PPUSH
56802: LD_VAR 0 3
56806: PPUSH
56807: CALL_OW 1
56811: ST_TO_ADDR
// end ;
56812: LD_VAR 0 4
56816: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
56817: LD_INT 0
56819: PPUSH
// if not mc_bases [ base ] then
56820: LD_EXP 99
56824: PUSH
56825: LD_VAR 0 1
56829: ARRAY
56830: NOT
56831: IFFALSE 56835
// exit ;
56833: GO 56860
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
56835: LD_ADDR_EXP 104
56839: PUSH
56840: LD_EXP 104
56844: PPUSH
56845: LD_VAR 0 1
56849: PPUSH
56850: LD_VAR 0 2
56854: PPUSH
56855: CALL_OW 1
56859: ST_TO_ADDR
// end ;
56860: LD_VAR 0 3
56864: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
56865: LD_INT 0
56867: PPUSH
// if not mc_bases [ base ] then
56868: LD_EXP 99
56872: PUSH
56873: LD_VAR 0 1
56877: ARRAY
56878: NOT
56879: IFFALSE 56883
// exit ;
56881: GO 56920
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
56883: LD_ADDR_EXP 104
56887: PUSH
56888: LD_EXP 104
56892: PPUSH
56893: LD_VAR 0 1
56897: PPUSH
56898: LD_EXP 104
56902: PUSH
56903: LD_VAR 0 1
56907: ARRAY
56908: PUSH
56909: LD_VAR 0 2
56913: UNION
56914: PPUSH
56915: CALL_OW 1
56919: ST_TO_ADDR
// end ;
56920: LD_VAR 0 3
56924: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
56925: LD_INT 0
56927: PPUSH
// if not mc_bases [ base ] then
56928: LD_EXP 99
56932: PUSH
56933: LD_VAR 0 1
56937: ARRAY
56938: NOT
56939: IFFALSE 56943
// exit ;
56941: GO 56968
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
56943: LD_ADDR_EXP 120
56947: PUSH
56948: LD_EXP 120
56952: PPUSH
56953: LD_VAR 0 1
56957: PPUSH
56958: LD_VAR 0 2
56962: PPUSH
56963: CALL_OW 1
56967: ST_TO_ADDR
// end ;
56968: LD_VAR 0 3
56972: RET
// export function MC_InsertProduceList ( base , components ) ; begin
56973: LD_INT 0
56975: PPUSH
// if not mc_bases [ base ] then
56976: LD_EXP 99
56980: PUSH
56981: LD_VAR 0 1
56985: ARRAY
56986: NOT
56987: IFFALSE 56991
// exit ;
56989: GO 57028
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56991: LD_ADDR_EXP 120
56995: PUSH
56996: LD_EXP 120
57000: PPUSH
57001: LD_VAR 0 1
57005: PPUSH
57006: LD_EXP 120
57010: PUSH
57011: LD_VAR 0 1
57015: ARRAY
57016: PUSH
57017: LD_VAR 0 2
57021: ADD
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// end ;
57028: LD_VAR 0 3
57032: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57033: LD_INT 0
57035: PPUSH
// if not mc_bases [ base ] then
57036: LD_EXP 99
57040: PUSH
57041: LD_VAR 0 1
57045: ARRAY
57046: NOT
57047: IFFALSE 57051
// exit ;
57049: GO 57105
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57051: LD_ADDR_EXP 121
57055: PUSH
57056: LD_EXP 121
57060: PPUSH
57061: LD_VAR 0 1
57065: PPUSH
57066: LD_VAR 0 2
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57076: LD_ADDR_EXP 110
57080: PUSH
57081: LD_EXP 110
57085: PPUSH
57086: LD_VAR 0 1
57090: PPUSH
57091: LD_VAR 0 2
57095: PUSH
57096: LD_INT 0
57098: PLUS
57099: PPUSH
57100: CALL_OW 1
57104: ST_TO_ADDR
// end ;
57105: LD_VAR 0 3
57109: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57110: LD_INT 0
57112: PPUSH
// if not mc_bases [ base ] then
57113: LD_EXP 99
57117: PUSH
57118: LD_VAR 0 1
57122: ARRAY
57123: NOT
57124: IFFALSE 57128
// exit ;
57126: GO 57153
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57128: LD_ADDR_EXP 110
57132: PUSH
57133: LD_EXP 110
57137: PPUSH
57138: LD_VAR 0 1
57142: PPUSH
57143: LD_VAR 0 2
57147: PPUSH
57148: CALL_OW 1
57152: ST_TO_ADDR
// end ;
57153: LD_VAR 0 3
57157: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57158: LD_INT 0
57160: PPUSH
57161: PPUSH
57162: PPUSH
57163: PPUSH
// if not mc_bases [ base ] then
57164: LD_EXP 99
57168: PUSH
57169: LD_VAR 0 1
57173: ARRAY
57174: NOT
57175: IFFALSE 57179
// exit ;
57177: GO 57244
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57179: LD_ADDR_EXP 119
57183: PUSH
57184: LD_EXP 119
57188: PPUSH
57189: LD_VAR 0 1
57193: PUSH
57194: LD_EXP 119
57198: PUSH
57199: LD_VAR 0 1
57203: ARRAY
57204: PUSH
57205: LD_INT 1
57207: PLUS
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PPUSH
57213: LD_VAR 0 1
57217: PUSH
57218: LD_VAR 0 2
57222: PUSH
57223: LD_VAR 0 3
57227: PUSH
57228: LD_VAR 0 4
57232: PUSH
57233: EMPTY
57234: LIST
57235: LIST
57236: LIST
57237: LIST
57238: PPUSH
57239: CALL 69708 0 3
57243: ST_TO_ADDR
// end ;
57244: LD_VAR 0 5
57248: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57249: LD_INT 0
57251: PPUSH
// if not mc_bases [ base ] then
57252: LD_EXP 99
57256: PUSH
57257: LD_VAR 0 1
57261: ARRAY
57262: NOT
57263: IFFALSE 57267
// exit ;
57265: GO 57292
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57267: LD_ADDR_EXP 136
57271: PUSH
57272: LD_EXP 136
57276: PPUSH
57277: LD_VAR 0 1
57281: PPUSH
57282: LD_VAR 0 2
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// end ;
57292: LD_VAR 0 3
57296: RET
// export function MC_GetMinesField ( base ) ; begin
57297: LD_INT 0
57299: PPUSH
// result := mc_mines [ base ] ;
57300: LD_ADDR_VAR 0 2
57304: PUSH
57305: LD_EXP 112
57309: PUSH
57310: LD_VAR 0 1
57314: ARRAY
57315: ST_TO_ADDR
// end ;
57316: LD_VAR 0 2
57320: RET
// export function MC_GetProduceList ( base ) ; begin
57321: LD_INT 0
57323: PPUSH
// result := mc_produce [ base ] ;
57324: LD_ADDR_VAR 0 2
57328: PUSH
57329: LD_EXP 120
57333: PUSH
57334: LD_VAR 0 1
57338: ARRAY
57339: ST_TO_ADDR
// end ;
57340: LD_VAR 0 2
57344: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57345: LD_INT 0
57347: PPUSH
57348: PPUSH
// if not mc_bases then
57349: LD_EXP 99
57353: NOT
57354: IFFALSE 57358
// exit ;
57356: GO 57423
// if mc_bases [ base ] then
57358: LD_EXP 99
57362: PUSH
57363: LD_VAR 0 1
57367: ARRAY
57368: IFFALSE 57423
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57370: LD_ADDR_VAR 0 3
57374: PUSH
57375: LD_EXP 99
57379: PUSH
57380: LD_VAR 0 1
57384: ARRAY
57385: PPUSH
57386: LD_INT 30
57388: PUSH
57389: LD_VAR 0 2
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: PPUSH
57398: CALL_OW 72
57402: ST_TO_ADDR
// if result then
57403: LD_VAR 0 3
57407: IFFALSE 57423
// result := result [ 1 ] ;
57409: LD_ADDR_VAR 0 3
57413: PUSH
57414: LD_VAR 0 3
57418: PUSH
57419: LD_INT 1
57421: ARRAY
57422: ST_TO_ADDR
// end ; end ;
57423: LD_VAR 0 3
57427: RET
// export function MC_SetTame ( base , area ) ; begin
57428: LD_INT 0
57430: PPUSH
// if not mc_bases or not base then
57431: LD_EXP 99
57435: NOT
57436: PUSH
57437: LD_VAR 0 1
57441: NOT
57442: OR
57443: IFFALSE 57447
// exit ;
57445: GO 57472
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57447: LD_ADDR_EXP 127
57451: PUSH
57452: LD_EXP 127
57456: PPUSH
57457: LD_VAR 0 1
57461: PPUSH
57462: LD_VAR 0 2
57466: PPUSH
57467: CALL_OW 1
57471: ST_TO_ADDR
// end ;
57472: LD_VAR 0 3
57476: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57477: LD_INT 0
57479: PPUSH
57480: PPUSH
// if not mc_bases or not base then
57481: LD_EXP 99
57485: NOT
57486: PUSH
57487: LD_VAR 0 1
57491: NOT
57492: OR
57493: IFFALSE 57497
// exit ;
57495: GO 57599
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57497: LD_ADDR_VAR 0 4
57501: PUSH
57502: LD_EXP 99
57506: PUSH
57507: LD_VAR 0 1
57511: ARRAY
57512: PPUSH
57513: LD_INT 30
57515: PUSH
57516: LD_VAR 0 2
57520: PUSH
57521: EMPTY
57522: LIST
57523: LIST
57524: PPUSH
57525: CALL_OW 72
57529: ST_TO_ADDR
// if not tmp then
57530: LD_VAR 0 4
57534: NOT
57535: IFFALSE 57539
// exit ;
57537: GO 57599
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57539: LD_ADDR_EXP 131
57543: PUSH
57544: LD_EXP 131
57548: PPUSH
57549: LD_VAR 0 1
57553: PPUSH
57554: LD_EXP 131
57558: PUSH
57559: LD_VAR 0 1
57563: ARRAY
57564: PPUSH
57565: LD_EXP 131
57569: PUSH
57570: LD_VAR 0 1
57574: ARRAY
57575: PUSH
57576: LD_INT 1
57578: PLUS
57579: PPUSH
57580: LD_VAR 0 4
57584: PUSH
57585: LD_INT 1
57587: ARRAY
57588: PPUSH
57589: CALL_OW 2
57593: PPUSH
57594: CALL_OW 1
57598: ST_TO_ADDR
// end ;
57599: LD_VAR 0 3
57603: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
57604: LD_INT 0
57606: PPUSH
57607: PPUSH
// if not mc_bases or not base or not kinds then
57608: LD_EXP 99
57612: NOT
57613: PUSH
57614: LD_VAR 0 1
57618: NOT
57619: OR
57620: PUSH
57621: LD_VAR 0 2
57625: NOT
57626: OR
57627: IFFALSE 57631
// exit ;
57629: GO 57692
// for i in kinds do
57631: LD_ADDR_VAR 0 4
57635: PUSH
57636: LD_VAR 0 2
57640: PUSH
57641: FOR_IN
57642: IFFALSE 57690
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
57644: LD_ADDR_EXP 133
57648: PUSH
57649: LD_EXP 133
57653: PPUSH
57654: LD_VAR 0 1
57658: PUSH
57659: LD_EXP 133
57663: PUSH
57664: LD_VAR 0 1
57668: ARRAY
57669: PUSH
57670: LD_INT 1
57672: PLUS
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PPUSH
57678: LD_VAR 0 4
57682: PPUSH
57683: CALL 69708 0 3
57687: ST_TO_ADDR
57688: GO 57641
57690: POP
57691: POP
// end ;
57692: LD_VAR 0 3
57696: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
57697: LD_INT 0
57699: PPUSH
// if not mc_bases or not base or not areas then
57700: LD_EXP 99
57704: NOT
57705: PUSH
57706: LD_VAR 0 1
57710: NOT
57711: OR
57712: PUSH
57713: LD_VAR 0 2
57717: NOT
57718: OR
57719: IFFALSE 57723
// exit ;
57721: GO 57748
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
57723: LD_ADDR_EXP 117
57727: PUSH
57728: LD_EXP 117
57732: PPUSH
57733: LD_VAR 0 1
57737: PPUSH
57738: LD_VAR 0 2
57742: PPUSH
57743: CALL_OW 1
57747: ST_TO_ADDR
// end ;
57748: LD_VAR 0 3
57752: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
57753: LD_INT 0
57755: PPUSH
// if not mc_bases or not base or not teleports_exit then
57756: LD_EXP 99
57760: NOT
57761: PUSH
57762: LD_VAR 0 1
57766: NOT
57767: OR
57768: PUSH
57769: LD_VAR 0 2
57773: NOT
57774: OR
57775: IFFALSE 57779
// exit ;
57777: GO 57804
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
57779: LD_ADDR_EXP 134
57783: PUSH
57784: LD_EXP 134
57788: PPUSH
57789: LD_VAR 0 1
57793: PPUSH
57794: LD_VAR 0 2
57798: PPUSH
57799: CALL_OW 1
57803: ST_TO_ADDR
// end ;
57804: LD_VAR 0 3
57808: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
57809: LD_INT 0
57811: PPUSH
57812: PPUSH
57813: PPUSH
// if not mc_bases or not base or not ext_list then
57814: LD_EXP 99
57818: NOT
57819: PUSH
57820: LD_VAR 0 1
57824: NOT
57825: OR
57826: PUSH
57827: LD_VAR 0 5
57831: NOT
57832: OR
57833: IFFALSE 57837
// exit ;
57835: GO 58010
// tmp := GetFacExtXYD ( x , y , d ) ;
57837: LD_ADDR_VAR 0 8
57841: PUSH
57842: LD_VAR 0 2
57846: PPUSH
57847: LD_VAR 0 3
57851: PPUSH
57852: LD_VAR 0 4
57856: PPUSH
57857: CALL 103086 0 3
57861: ST_TO_ADDR
// if not tmp then
57862: LD_VAR 0 8
57866: NOT
57867: IFFALSE 57871
// exit ;
57869: GO 58010
// for i in tmp do
57871: LD_ADDR_VAR 0 7
57875: PUSH
57876: LD_VAR 0 8
57880: PUSH
57881: FOR_IN
57882: IFFALSE 58008
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
57884: LD_ADDR_EXP 104
57888: PUSH
57889: LD_EXP 104
57893: PPUSH
57894: LD_VAR 0 1
57898: PPUSH
57899: LD_EXP 104
57903: PUSH
57904: LD_VAR 0 1
57908: ARRAY
57909: PPUSH
57910: LD_EXP 104
57914: PUSH
57915: LD_VAR 0 1
57919: ARRAY
57920: PUSH
57921: LD_INT 1
57923: PLUS
57924: PPUSH
57925: LD_VAR 0 5
57929: PUSH
57930: LD_INT 1
57932: ARRAY
57933: PUSH
57934: LD_VAR 0 7
57938: PUSH
57939: LD_INT 1
57941: ARRAY
57942: PUSH
57943: LD_VAR 0 7
57947: PUSH
57948: LD_INT 2
57950: ARRAY
57951: PUSH
57952: LD_VAR 0 7
57956: PUSH
57957: LD_INT 3
57959: ARRAY
57960: PUSH
57961: EMPTY
57962: LIST
57963: LIST
57964: LIST
57965: LIST
57966: PPUSH
57967: CALL_OW 2
57971: PPUSH
57972: CALL_OW 1
57976: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57977: LD_ADDR_VAR 0 5
57981: PUSH
57982: LD_VAR 0 5
57986: PPUSH
57987: LD_INT 1
57989: PPUSH
57990: CALL_OW 3
57994: ST_TO_ADDR
// if not ext_list then
57995: LD_VAR 0 5
57999: NOT
58000: IFFALSE 58006
// exit ;
58002: POP
58003: POP
58004: GO 58010
// end ;
58006: GO 57881
58008: POP
58009: POP
// end ;
58010: LD_VAR 0 6
58014: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58015: LD_INT 0
58017: PPUSH
// if not mc_bases or not base or not weapon_list then
58018: LD_EXP 99
58022: NOT
58023: PUSH
58024: LD_VAR 0 1
58028: NOT
58029: OR
58030: PUSH
58031: LD_VAR 0 2
58035: NOT
58036: OR
58037: IFFALSE 58041
// exit ;
58039: GO 58066
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58041: LD_ADDR_EXP 138
58045: PUSH
58046: LD_EXP 138
58050: PPUSH
58051: LD_VAR 0 1
58055: PPUSH
58056: LD_VAR 0 2
58060: PPUSH
58061: CALL_OW 1
58065: ST_TO_ADDR
// end ;
58066: LD_VAR 0 3
58070: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58071: LD_INT 0
58073: PPUSH
// if not mc_bases or not base or not tech_list then
58074: LD_EXP 99
58078: NOT
58079: PUSH
58080: LD_VAR 0 1
58084: NOT
58085: OR
58086: PUSH
58087: LD_VAR 0 2
58091: NOT
58092: OR
58093: IFFALSE 58097
// exit ;
58095: GO 58122
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58097: LD_ADDR_EXP 126
58101: PUSH
58102: LD_EXP 126
58106: PPUSH
58107: LD_VAR 0 1
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: CALL_OW 1
58121: ST_TO_ADDR
// end ;
58122: LD_VAR 0 3
58126: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58127: LD_INT 0
58129: PPUSH
// if not mc_bases or not parking_area or not base then
58130: LD_EXP 99
58134: NOT
58135: PUSH
58136: LD_VAR 0 2
58140: NOT
58141: OR
58142: PUSH
58143: LD_VAR 0 1
58147: NOT
58148: OR
58149: IFFALSE 58153
// exit ;
58151: GO 58178
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58153: LD_ADDR_EXP 123
58157: PUSH
58158: LD_EXP 123
58162: PPUSH
58163: LD_VAR 0 1
58167: PPUSH
58168: LD_VAR 0 2
58172: PPUSH
58173: CALL_OW 1
58177: ST_TO_ADDR
// end ;
58178: LD_VAR 0 3
58182: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58183: LD_INT 0
58185: PPUSH
// if not mc_bases or not base or not scan_area then
58186: LD_EXP 99
58190: NOT
58191: PUSH
58192: LD_VAR 0 1
58196: NOT
58197: OR
58198: PUSH
58199: LD_VAR 0 2
58203: NOT
58204: OR
58205: IFFALSE 58209
// exit ;
58207: GO 58234
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58209: LD_ADDR_EXP 124
58213: PUSH
58214: LD_EXP 124
58218: PPUSH
58219: LD_VAR 0 1
58223: PPUSH
58224: LD_VAR 0 2
58228: PPUSH
58229: CALL_OW 1
58233: ST_TO_ADDR
// end ;
58234: LD_VAR 0 3
58238: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58239: LD_INT 0
58241: PPUSH
58242: PPUSH
// if not mc_bases or not base then
58243: LD_EXP 99
58247: NOT
58248: PUSH
58249: LD_VAR 0 1
58253: NOT
58254: OR
58255: IFFALSE 58259
// exit ;
58257: GO 58323
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58259: LD_ADDR_VAR 0 3
58263: PUSH
58264: LD_INT 1
58266: PUSH
58267: LD_INT 2
58269: PUSH
58270: LD_INT 3
58272: PUSH
58273: LD_INT 4
58275: PUSH
58276: LD_INT 11
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: LIST
58284: LIST
58285: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58286: LD_ADDR_EXP 126
58290: PUSH
58291: LD_EXP 126
58295: PPUSH
58296: LD_VAR 0 1
58300: PPUSH
58301: LD_EXP 126
58305: PUSH
58306: LD_VAR 0 1
58310: ARRAY
58311: PUSH
58312: LD_VAR 0 3
58316: DIFF
58317: PPUSH
58318: CALL_OW 1
58322: ST_TO_ADDR
// end ;
58323: LD_VAR 0 2
58327: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58328: LD_INT 0
58330: PPUSH
// result := mc_vehicles [ base ] ;
58331: LD_ADDR_VAR 0 3
58335: PUSH
58336: LD_EXP 118
58340: PUSH
58341: LD_VAR 0 1
58345: ARRAY
58346: ST_TO_ADDR
// if onlyCombat then
58347: LD_VAR 0 2
58351: IFFALSE 58516
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58353: LD_ADDR_VAR 0 3
58357: PUSH
58358: LD_VAR 0 3
58362: PUSH
58363: LD_VAR 0 3
58367: PPUSH
58368: LD_INT 2
58370: PUSH
58371: LD_INT 34
58373: PUSH
58374: LD_INT 12
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 34
58383: PUSH
58384: LD_INT 51
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: LD_INT 34
58393: PUSH
58394: LD_EXP 93
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: PUSH
58403: LD_INT 34
58405: PUSH
58406: LD_INT 32
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: PUSH
58413: LD_INT 34
58415: PUSH
58416: LD_INT 13
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: PUSH
58423: LD_INT 34
58425: PUSH
58426: LD_INT 52
58428: PUSH
58429: EMPTY
58430: LIST
58431: LIST
58432: PUSH
58433: LD_INT 34
58435: PUSH
58436: LD_INT 14
58438: PUSH
58439: EMPTY
58440: LIST
58441: LIST
58442: PUSH
58443: LD_INT 34
58445: PUSH
58446: LD_INT 53
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PUSH
58453: LD_INT 34
58455: PUSH
58456: LD_EXP 92
58460: PUSH
58461: EMPTY
58462: LIST
58463: LIST
58464: PUSH
58465: LD_INT 34
58467: PUSH
58468: LD_INT 31
58470: PUSH
58471: EMPTY
58472: LIST
58473: LIST
58474: PUSH
58475: LD_INT 34
58477: PUSH
58478: LD_INT 48
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: PUSH
58485: LD_INT 34
58487: PUSH
58488: LD_INT 8
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PUSH
58495: EMPTY
58496: LIST
58497: LIST
58498: LIST
58499: LIST
58500: LIST
58501: LIST
58502: LIST
58503: LIST
58504: LIST
58505: LIST
58506: LIST
58507: LIST
58508: LIST
58509: PPUSH
58510: CALL_OW 72
58514: DIFF
58515: ST_TO_ADDR
// end ; end_of_file
58516: LD_VAR 0 3
58520: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58521: LD_INT 0
58523: PPUSH
58524: PPUSH
58525: PPUSH
// if not mc_bases or not skirmish then
58526: LD_EXP 99
58530: NOT
58531: PUSH
58532: LD_EXP 97
58536: NOT
58537: OR
58538: IFFALSE 58542
// exit ;
58540: GO 58707
// for i = 1 to mc_bases do
58542: LD_ADDR_VAR 0 4
58546: PUSH
58547: DOUBLE
58548: LD_INT 1
58550: DEC
58551: ST_TO_ADDR
58552: LD_EXP 99
58556: PUSH
58557: FOR_TO
58558: IFFALSE 58705
// begin if sci in mc_bases [ i ] then
58560: LD_VAR 0 2
58564: PUSH
58565: LD_EXP 99
58569: PUSH
58570: LD_VAR 0 4
58574: ARRAY
58575: IN
58576: IFFALSE 58703
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
58578: LD_ADDR_EXP 128
58582: PUSH
58583: LD_EXP 128
58587: PPUSH
58588: LD_VAR 0 4
58592: PUSH
58593: LD_EXP 128
58597: PUSH
58598: LD_VAR 0 4
58602: ARRAY
58603: PUSH
58604: LD_INT 1
58606: PLUS
58607: PUSH
58608: EMPTY
58609: LIST
58610: LIST
58611: PPUSH
58612: LD_VAR 0 1
58616: PPUSH
58617: CALL 69708 0 3
58621: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
58622: LD_ADDR_VAR 0 5
58626: PUSH
58627: LD_EXP 99
58631: PUSH
58632: LD_VAR 0 4
58636: ARRAY
58637: PPUSH
58638: LD_INT 2
58640: PUSH
58641: LD_INT 30
58643: PUSH
58644: LD_INT 0
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: PUSH
58651: LD_INT 30
58653: PUSH
58654: LD_INT 1
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: LIST
58665: PPUSH
58666: CALL_OW 72
58670: PPUSH
58671: LD_VAR 0 1
58675: PPUSH
58676: CALL_OW 74
58680: ST_TO_ADDR
// if tmp then
58681: LD_VAR 0 5
58685: IFFALSE 58701
// ComStandNearbyBuilding ( ape , tmp ) ;
58687: LD_VAR 0 1
58691: PPUSH
58692: LD_VAR 0 5
58696: PPUSH
58697: CALL 64415 0 2
// break ;
58701: GO 58705
// end ; end ;
58703: GO 58557
58705: POP
58706: POP
// end ;
58707: LD_VAR 0 3
58711: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
58712: LD_INT 0
58714: PPUSH
58715: PPUSH
58716: PPUSH
// if not mc_bases or not skirmish then
58717: LD_EXP 99
58721: NOT
58722: PUSH
58723: LD_EXP 97
58727: NOT
58728: OR
58729: IFFALSE 58733
// exit ;
58731: GO 58822
// for i = 1 to mc_bases do
58733: LD_ADDR_VAR 0 4
58737: PUSH
58738: DOUBLE
58739: LD_INT 1
58741: DEC
58742: ST_TO_ADDR
58743: LD_EXP 99
58747: PUSH
58748: FOR_TO
58749: IFFALSE 58820
// begin if building in mc_busy_turret_list [ i ] then
58751: LD_VAR 0 1
58755: PUSH
58756: LD_EXP 109
58760: PUSH
58761: LD_VAR 0 4
58765: ARRAY
58766: IN
58767: IFFALSE 58818
// begin tmp := mc_busy_turret_list [ i ] diff building ;
58769: LD_ADDR_VAR 0 5
58773: PUSH
58774: LD_EXP 109
58778: PUSH
58779: LD_VAR 0 4
58783: ARRAY
58784: PUSH
58785: LD_VAR 0 1
58789: DIFF
58790: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
58791: LD_ADDR_EXP 109
58795: PUSH
58796: LD_EXP 109
58800: PPUSH
58801: LD_VAR 0 4
58805: PPUSH
58806: LD_VAR 0 5
58810: PPUSH
58811: CALL_OW 1
58815: ST_TO_ADDR
// break ;
58816: GO 58820
// end ; end ;
58818: GO 58748
58820: POP
58821: POP
// end ;
58822: LD_VAR 0 3
58826: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
58827: LD_INT 0
58829: PPUSH
58830: PPUSH
58831: PPUSH
// if not mc_bases or not skirmish then
58832: LD_EXP 99
58836: NOT
58837: PUSH
58838: LD_EXP 97
58842: NOT
58843: OR
58844: IFFALSE 58848
// exit ;
58846: GO 59047
// for i = 1 to mc_bases do
58848: LD_ADDR_VAR 0 5
58852: PUSH
58853: DOUBLE
58854: LD_INT 1
58856: DEC
58857: ST_TO_ADDR
58858: LD_EXP 99
58862: PUSH
58863: FOR_TO
58864: IFFALSE 59045
// if building in mc_bases [ i ] then
58866: LD_VAR 0 1
58870: PUSH
58871: LD_EXP 99
58875: PUSH
58876: LD_VAR 0 5
58880: ARRAY
58881: IN
58882: IFFALSE 59043
// begin tmp := mc_bases [ i ] diff building ;
58884: LD_ADDR_VAR 0 6
58888: PUSH
58889: LD_EXP 99
58893: PUSH
58894: LD_VAR 0 5
58898: ARRAY
58899: PUSH
58900: LD_VAR 0 1
58904: DIFF
58905: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
58906: LD_ADDR_EXP 99
58910: PUSH
58911: LD_EXP 99
58915: PPUSH
58916: LD_VAR 0 5
58920: PPUSH
58921: LD_VAR 0 6
58925: PPUSH
58926: CALL_OW 1
58930: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
58931: LD_VAR 0 1
58935: PUSH
58936: LD_EXP 107
58940: PUSH
58941: LD_VAR 0 5
58945: ARRAY
58946: IN
58947: IFFALSE 58986
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
58949: LD_ADDR_EXP 107
58953: PUSH
58954: LD_EXP 107
58958: PPUSH
58959: LD_VAR 0 5
58963: PPUSH
58964: LD_EXP 107
58968: PUSH
58969: LD_VAR 0 5
58973: ARRAY
58974: PUSH
58975: LD_VAR 0 1
58979: DIFF
58980: PPUSH
58981: CALL_OW 1
58985: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58986: LD_VAR 0 1
58990: PUSH
58991: LD_EXP 108
58995: PUSH
58996: LD_VAR 0 5
59000: ARRAY
59001: IN
59002: IFFALSE 59041
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59004: LD_ADDR_EXP 108
59008: PUSH
59009: LD_EXP 108
59013: PPUSH
59014: LD_VAR 0 5
59018: PPUSH
59019: LD_EXP 108
59023: PUSH
59024: LD_VAR 0 5
59028: ARRAY
59029: PUSH
59030: LD_VAR 0 1
59034: DIFF
59035: PPUSH
59036: CALL_OW 1
59040: ST_TO_ADDR
// break ;
59041: GO 59045
// end ;
59043: GO 58863
59045: POP
59046: POP
// end ;
59047: LD_VAR 0 4
59051: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59052: LD_INT 0
59054: PPUSH
59055: PPUSH
59056: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59057: LD_EXP 99
59061: NOT
59062: PUSH
59063: LD_EXP 97
59067: NOT
59068: OR
59069: PUSH
59070: LD_VAR 0 3
59074: PUSH
59075: LD_EXP 125
59079: IN
59080: NOT
59081: OR
59082: IFFALSE 59086
// exit ;
59084: GO 59209
// for i = 1 to mc_vehicles do
59086: LD_ADDR_VAR 0 6
59090: PUSH
59091: DOUBLE
59092: LD_INT 1
59094: DEC
59095: ST_TO_ADDR
59096: LD_EXP 118
59100: PUSH
59101: FOR_TO
59102: IFFALSE 59207
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59104: LD_VAR 0 2
59108: PUSH
59109: LD_EXP 118
59113: PUSH
59114: LD_VAR 0 6
59118: ARRAY
59119: IN
59120: PUSH
59121: LD_VAR 0 1
59125: PUSH
59126: LD_EXP 118
59130: PUSH
59131: LD_VAR 0 6
59135: ARRAY
59136: IN
59137: OR
59138: IFFALSE 59205
// begin tmp := mc_vehicles [ i ] diff old ;
59140: LD_ADDR_VAR 0 7
59144: PUSH
59145: LD_EXP 118
59149: PUSH
59150: LD_VAR 0 6
59154: ARRAY
59155: PUSH
59156: LD_VAR 0 2
59160: DIFF
59161: ST_TO_ADDR
// tmp := tmp diff new ;
59162: LD_ADDR_VAR 0 7
59166: PUSH
59167: LD_VAR 0 7
59171: PUSH
59172: LD_VAR 0 1
59176: DIFF
59177: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59178: LD_ADDR_EXP 118
59182: PUSH
59183: LD_EXP 118
59187: PPUSH
59188: LD_VAR 0 6
59192: PPUSH
59193: LD_VAR 0 7
59197: PPUSH
59198: CALL_OW 1
59202: ST_TO_ADDR
// break ;
59203: GO 59207
// end ;
59205: GO 59101
59207: POP
59208: POP
// end ;
59209: LD_VAR 0 5
59213: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59214: LD_INT 0
59216: PPUSH
59217: PPUSH
59218: PPUSH
59219: PPUSH
// if not mc_bases or not skirmish then
59220: LD_EXP 99
59224: NOT
59225: PUSH
59226: LD_EXP 97
59230: NOT
59231: OR
59232: IFFALSE 59236
// exit ;
59234: GO 59613
// side := GetSide ( vehicle ) ;
59236: LD_ADDR_VAR 0 5
59240: PUSH
59241: LD_VAR 0 1
59245: PPUSH
59246: CALL_OW 255
59250: ST_TO_ADDR
// for i = 1 to mc_bases do
59251: LD_ADDR_VAR 0 4
59255: PUSH
59256: DOUBLE
59257: LD_INT 1
59259: DEC
59260: ST_TO_ADDR
59261: LD_EXP 99
59265: PUSH
59266: FOR_TO
59267: IFFALSE 59611
// begin if factory in mc_bases [ i ] then
59269: LD_VAR 0 2
59273: PUSH
59274: LD_EXP 99
59278: PUSH
59279: LD_VAR 0 4
59283: ARRAY
59284: IN
59285: IFFALSE 59609
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59287: LD_EXP 121
59291: PUSH
59292: LD_VAR 0 4
59296: ARRAY
59297: PUSH
59298: LD_EXP 110
59302: PUSH
59303: LD_VAR 0 4
59307: ARRAY
59308: LESS
59309: PUSH
59310: LD_VAR 0 1
59314: PPUSH
59315: CALL_OW 264
59319: PUSH
59320: LD_INT 31
59322: PUSH
59323: LD_INT 32
59325: PUSH
59326: LD_INT 51
59328: PUSH
59329: LD_EXP 93
59333: PUSH
59334: LD_INT 12
59336: PUSH
59337: LD_INT 30
59339: PUSH
59340: LD_EXP 92
59344: PUSH
59345: LD_INT 11
59347: PUSH
59348: LD_INT 53
59350: PUSH
59351: LD_INT 14
59353: PUSH
59354: LD_EXP 96
59358: PUSH
59359: LD_INT 29
59361: PUSH
59362: LD_EXP 94
59366: PUSH
59367: LD_INT 13
59369: PUSH
59370: LD_INT 52
59372: PUSH
59373: LD_INT 48
59375: PUSH
59376: LD_INT 8
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: LIST
59397: IN
59398: NOT
59399: AND
59400: IFFALSE 59448
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59402: LD_ADDR_EXP 121
59406: PUSH
59407: LD_EXP 121
59411: PPUSH
59412: LD_VAR 0 4
59416: PUSH
59417: LD_EXP 121
59421: PUSH
59422: LD_VAR 0 4
59426: ARRAY
59427: PUSH
59428: LD_INT 1
59430: PLUS
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: PPUSH
59436: LD_VAR 0 1
59440: PPUSH
59441: CALL 69708 0 3
59445: ST_TO_ADDR
59446: GO 59492
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59448: LD_ADDR_EXP 118
59452: PUSH
59453: LD_EXP 118
59457: PPUSH
59458: LD_VAR 0 4
59462: PUSH
59463: LD_EXP 118
59467: PUSH
59468: LD_VAR 0 4
59472: ARRAY
59473: PUSH
59474: LD_INT 1
59476: PLUS
59477: PUSH
59478: EMPTY
59479: LIST
59480: LIST
59481: PPUSH
59482: LD_VAR 0 1
59486: PPUSH
59487: CALL 69708 0 3
59491: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59492: LD_VAR 0 1
59496: PPUSH
59497: CALL_OW 263
59501: PUSH
59502: LD_INT 2
59504: EQUAL
59505: IFFALSE 59525
// begin repeat wait ( 0 0$1 ) ;
59507: LD_INT 35
59509: PPUSH
59510: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59514: LD_VAR 0 1
59518: PPUSH
59519: CALL_OW 312
59523: IFFALSE 59507
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59525: LD_VAR 0 1
59529: PPUSH
59530: LD_EXP 123
59534: PUSH
59535: LD_VAR 0 4
59539: ARRAY
59540: PPUSH
59541: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
59545: LD_VAR 0 1
59549: PPUSH
59550: CALL_OW 263
59554: PUSH
59555: LD_INT 1
59557: NONEQUAL
59558: IFFALSE 59562
// break ;
59560: GO 59611
// repeat wait ( 0 0$1 ) ;
59562: LD_INT 35
59564: PPUSH
59565: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
59569: LD_VAR 0 1
59573: PPUSH
59574: LD_EXP 123
59578: PUSH
59579: LD_VAR 0 4
59583: ARRAY
59584: PPUSH
59585: CALL_OW 308
59589: IFFALSE 59562
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
59591: LD_VAR 0 1
59595: PPUSH
59596: CALL_OW 311
59600: PPUSH
59601: CALL_OW 121
// exit ;
59605: POP
59606: POP
59607: GO 59613
// end ; end ;
59609: GO 59266
59611: POP
59612: POP
// end ;
59613: LD_VAR 0 3
59617: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
59618: LD_INT 0
59620: PPUSH
59621: PPUSH
59622: PPUSH
59623: PPUSH
// if not mc_bases or not skirmish then
59624: LD_EXP 99
59628: NOT
59629: PUSH
59630: LD_EXP 97
59634: NOT
59635: OR
59636: IFFALSE 59640
// exit ;
59638: GO 59993
// repeat wait ( 0 0$1 ) ;
59640: LD_INT 35
59642: PPUSH
59643: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
59647: LD_VAR 0 2
59651: PPUSH
59652: LD_VAR 0 3
59656: PPUSH
59657: CALL_OW 284
59661: IFFALSE 59640
// if GetResourceTypeXY ( x , y ) = mat_artefact then
59663: LD_VAR 0 2
59667: PPUSH
59668: LD_VAR 0 3
59672: PPUSH
59673: CALL_OW 283
59677: PUSH
59678: LD_INT 4
59680: EQUAL
59681: IFFALSE 59685
// exit ;
59683: GO 59993
// for i = 1 to mc_bases do
59685: LD_ADDR_VAR 0 7
59689: PUSH
59690: DOUBLE
59691: LD_INT 1
59693: DEC
59694: ST_TO_ADDR
59695: LD_EXP 99
59699: PUSH
59700: FOR_TO
59701: IFFALSE 59991
// begin if mc_crates_area [ i ] then
59703: LD_EXP 117
59707: PUSH
59708: LD_VAR 0 7
59712: ARRAY
59713: IFFALSE 59824
// for j in mc_crates_area [ i ] do
59715: LD_ADDR_VAR 0 8
59719: PUSH
59720: LD_EXP 117
59724: PUSH
59725: LD_VAR 0 7
59729: ARRAY
59730: PUSH
59731: FOR_IN
59732: IFFALSE 59822
// if InArea ( x , y , j ) then
59734: LD_VAR 0 2
59738: PPUSH
59739: LD_VAR 0 3
59743: PPUSH
59744: LD_VAR 0 8
59748: PPUSH
59749: CALL_OW 309
59753: IFFALSE 59820
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59755: LD_ADDR_EXP 115
59759: PUSH
59760: LD_EXP 115
59764: PPUSH
59765: LD_VAR 0 7
59769: PUSH
59770: LD_EXP 115
59774: PUSH
59775: LD_VAR 0 7
59779: ARRAY
59780: PUSH
59781: LD_INT 1
59783: PLUS
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: PPUSH
59789: LD_VAR 0 4
59793: PUSH
59794: LD_VAR 0 2
59798: PUSH
59799: LD_VAR 0 3
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: LIST
59808: PPUSH
59809: CALL 69708 0 3
59813: ST_TO_ADDR
// exit ;
59814: POP
59815: POP
59816: POP
59817: POP
59818: GO 59993
// end ;
59820: GO 59731
59822: POP
59823: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59824: LD_ADDR_VAR 0 9
59828: PUSH
59829: LD_EXP 99
59833: PUSH
59834: LD_VAR 0 7
59838: ARRAY
59839: PPUSH
59840: LD_INT 2
59842: PUSH
59843: LD_INT 30
59845: PUSH
59846: LD_INT 0
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 30
59855: PUSH
59856: LD_INT 1
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: PPUSH
59868: CALL_OW 72
59872: ST_TO_ADDR
// if not depot then
59873: LD_VAR 0 9
59877: NOT
59878: IFFALSE 59882
// continue ;
59880: GO 59700
// for j in depot do
59882: LD_ADDR_VAR 0 8
59886: PUSH
59887: LD_VAR 0 9
59891: PUSH
59892: FOR_IN
59893: IFFALSE 59987
// if GetDistUnitXY ( j , x , y ) < 30 then
59895: LD_VAR 0 8
59899: PPUSH
59900: LD_VAR 0 2
59904: PPUSH
59905: LD_VAR 0 3
59909: PPUSH
59910: CALL_OW 297
59914: PUSH
59915: LD_INT 30
59917: LESS
59918: IFFALSE 59985
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59920: LD_ADDR_EXP 115
59924: PUSH
59925: LD_EXP 115
59929: PPUSH
59930: LD_VAR 0 7
59934: PUSH
59935: LD_EXP 115
59939: PUSH
59940: LD_VAR 0 7
59944: ARRAY
59945: PUSH
59946: LD_INT 1
59948: PLUS
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: PPUSH
59954: LD_VAR 0 4
59958: PUSH
59959: LD_VAR 0 2
59963: PUSH
59964: LD_VAR 0 3
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: LIST
59973: PPUSH
59974: CALL 69708 0 3
59978: ST_TO_ADDR
// exit ;
59979: POP
59980: POP
59981: POP
59982: POP
59983: GO 59993
// end ;
59985: GO 59892
59987: POP
59988: POP
// end ;
59989: GO 59700
59991: POP
59992: POP
// end ;
59993: LD_VAR 0 6
59997: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59998: LD_INT 0
60000: PPUSH
60001: PPUSH
60002: PPUSH
60003: PPUSH
// if not mc_bases or not skirmish then
60004: LD_EXP 99
60008: NOT
60009: PUSH
60010: LD_EXP 97
60014: NOT
60015: OR
60016: IFFALSE 60020
// exit ;
60018: GO 60297
// side := GetSide ( lab ) ;
60020: LD_ADDR_VAR 0 4
60024: PUSH
60025: LD_VAR 0 2
60029: PPUSH
60030: CALL_OW 255
60034: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60035: LD_VAR 0 4
60039: PUSH
60040: LD_EXP 125
60044: IN
60045: NOT
60046: PUSH
60047: LD_EXP 126
60051: NOT
60052: OR
60053: PUSH
60054: LD_EXP 99
60058: NOT
60059: OR
60060: IFFALSE 60064
// exit ;
60062: GO 60297
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60064: LD_ADDR_EXP 126
60068: PUSH
60069: LD_EXP 126
60073: PPUSH
60074: LD_VAR 0 4
60078: PPUSH
60079: LD_EXP 126
60083: PUSH
60084: LD_VAR 0 4
60088: ARRAY
60089: PUSH
60090: LD_VAR 0 1
60094: DIFF
60095: PPUSH
60096: CALL_OW 1
60100: ST_TO_ADDR
// for i = 1 to mc_bases do
60101: LD_ADDR_VAR 0 5
60105: PUSH
60106: DOUBLE
60107: LD_INT 1
60109: DEC
60110: ST_TO_ADDR
60111: LD_EXP 99
60115: PUSH
60116: FOR_TO
60117: IFFALSE 60295
// begin if lab in mc_bases [ i ] then
60119: LD_VAR 0 2
60123: PUSH
60124: LD_EXP 99
60128: PUSH
60129: LD_VAR 0 5
60133: ARRAY
60134: IN
60135: IFFALSE 60293
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60137: LD_VAR 0 1
60141: PUSH
60142: LD_INT 11
60144: PUSH
60145: LD_INT 4
60147: PUSH
60148: LD_INT 3
60150: PUSH
60151: LD_INT 2
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: LIST
60158: LIST
60159: IN
60160: PUSH
60161: LD_EXP 129
60165: PUSH
60166: LD_VAR 0 5
60170: ARRAY
60171: AND
60172: IFFALSE 60293
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60174: LD_ADDR_VAR 0 6
60178: PUSH
60179: LD_EXP 129
60183: PUSH
60184: LD_VAR 0 5
60188: ARRAY
60189: PUSH
60190: LD_INT 1
60192: ARRAY
60193: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60194: LD_ADDR_EXP 129
60198: PUSH
60199: LD_EXP 129
60203: PPUSH
60204: LD_VAR 0 5
60208: PPUSH
60209: EMPTY
60210: PPUSH
60211: CALL_OW 1
60215: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60216: LD_VAR 0 6
60220: PPUSH
60221: LD_INT 0
60223: PPUSH
60224: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60228: LD_VAR 0 6
60232: PPUSH
60233: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60237: LD_ADDR_EXP 128
60241: PUSH
60242: LD_EXP 128
60246: PPUSH
60247: LD_VAR 0 5
60251: PPUSH
60252: LD_EXP 128
60256: PUSH
60257: LD_VAR 0 5
60261: ARRAY
60262: PPUSH
60263: LD_INT 1
60265: PPUSH
60266: LD_VAR 0 6
60270: PPUSH
60271: CALL_OW 2
60275: PPUSH
60276: CALL_OW 1
60280: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60281: LD_VAR 0 5
60285: PPUSH
60286: LD_INT 112
60288: PPUSH
60289: CALL 37830 0 2
// end ; end ; end ;
60293: GO 60116
60295: POP
60296: POP
// end ;
60297: LD_VAR 0 3
60301: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60302: LD_INT 0
60304: PPUSH
60305: PPUSH
60306: PPUSH
60307: PPUSH
60308: PPUSH
60309: PPUSH
60310: PPUSH
60311: PPUSH
// if not mc_bases or not skirmish then
60312: LD_EXP 99
60316: NOT
60317: PUSH
60318: LD_EXP 97
60322: NOT
60323: OR
60324: IFFALSE 60328
// exit ;
60326: GO 61420
// for i = 1 to mc_bases do
60328: LD_ADDR_VAR 0 3
60332: PUSH
60333: DOUBLE
60334: LD_INT 1
60336: DEC
60337: ST_TO_ADDR
60338: LD_EXP 99
60342: PUSH
60343: FOR_TO
60344: IFFALSE 61418
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60346: LD_VAR 0 1
60350: PUSH
60351: LD_EXP 99
60355: PUSH
60356: LD_VAR 0 3
60360: ARRAY
60361: IN
60362: PUSH
60363: LD_VAR 0 1
60367: PUSH
60368: LD_EXP 106
60372: PUSH
60373: LD_VAR 0 3
60377: ARRAY
60378: IN
60379: OR
60380: PUSH
60381: LD_VAR 0 1
60385: PUSH
60386: LD_EXP 121
60390: PUSH
60391: LD_VAR 0 3
60395: ARRAY
60396: IN
60397: OR
60398: PUSH
60399: LD_VAR 0 1
60403: PUSH
60404: LD_EXP 118
60408: PUSH
60409: LD_VAR 0 3
60413: ARRAY
60414: IN
60415: OR
60416: PUSH
60417: LD_VAR 0 1
60421: PUSH
60422: LD_EXP 128
60426: PUSH
60427: LD_VAR 0 3
60431: ARRAY
60432: IN
60433: OR
60434: PUSH
60435: LD_VAR 0 1
60439: PUSH
60440: LD_EXP 129
60444: PUSH
60445: LD_VAR 0 3
60449: ARRAY
60450: IN
60451: OR
60452: IFFALSE 61416
// begin if un in mc_ape [ i ] then
60454: LD_VAR 0 1
60458: PUSH
60459: LD_EXP 128
60463: PUSH
60464: LD_VAR 0 3
60468: ARRAY
60469: IN
60470: IFFALSE 60509
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60472: LD_ADDR_EXP 128
60476: PUSH
60477: LD_EXP 128
60481: PPUSH
60482: LD_VAR 0 3
60486: PPUSH
60487: LD_EXP 128
60491: PUSH
60492: LD_VAR 0 3
60496: ARRAY
60497: PUSH
60498: LD_VAR 0 1
60502: DIFF
60503: PPUSH
60504: CALL_OW 1
60508: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60509: LD_VAR 0 1
60513: PUSH
60514: LD_EXP 129
60518: PUSH
60519: LD_VAR 0 3
60523: ARRAY
60524: IN
60525: IFFALSE 60549
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60527: LD_ADDR_EXP 129
60531: PUSH
60532: LD_EXP 129
60536: PPUSH
60537: LD_VAR 0 3
60541: PPUSH
60542: EMPTY
60543: PPUSH
60544: CALL_OW 1
60548: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
60549: LD_VAR 0 1
60553: PPUSH
60554: CALL_OW 247
60558: PUSH
60559: LD_INT 2
60561: EQUAL
60562: PUSH
60563: LD_VAR 0 1
60567: PPUSH
60568: CALL_OW 110
60572: PUSH
60573: LD_INT 20
60575: EQUAL
60576: PUSH
60577: LD_VAR 0 1
60581: PUSH
60582: LD_EXP 121
60586: PUSH
60587: LD_VAR 0 3
60591: ARRAY
60592: IN
60593: OR
60594: AND
60595: IFFALSE 60756
// begin if un in mc_defender [ i ] then
60597: LD_VAR 0 1
60601: PUSH
60602: LD_EXP 121
60606: PUSH
60607: LD_VAR 0 3
60611: ARRAY
60612: IN
60613: IFFALSE 60652
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
60615: LD_ADDR_EXP 121
60619: PUSH
60620: LD_EXP 121
60624: PPUSH
60625: LD_VAR 0 3
60629: PPUSH
60630: LD_EXP 121
60634: PUSH
60635: LD_VAR 0 3
60639: ARRAY
60640: PUSH
60641: LD_VAR 0 1
60645: DIFF
60646: PPUSH
60647: CALL_OW 1
60651: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
60652: LD_ADDR_VAR 0 8
60656: PUSH
60657: LD_VAR 0 3
60661: PPUSH
60662: LD_INT 3
60664: PPUSH
60665: CALL 57345 0 2
60669: ST_TO_ADDR
// if fac then
60670: LD_VAR 0 8
60674: IFFALSE 60756
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
60676: LD_ADDR_VAR 0 9
60680: PUSH
60681: LD_VAR 0 8
60685: PPUSH
60686: LD_VAR 0 1
60690: PPUSH
60691: CALL_OW 265
60695: PPUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: CALL_OW 262
60705: PPUSH
60706: LD_VAR 0 1
60710: PPUSH
60711: CALL_OW 263
60715: PPUSH
60716: LD_VAR 0 1
60720: PPUSH
60721: CALL_OW 264
60725: PPUSH
60726: CALL 67301 0 5
60730: ST_TO_ADDR
// if components then
60731: LD_VAR 0 9
60735: IFFALSE 60754
// MC_InsertProduceList ( i , [ components ] ) ;
60737: LD_VAR 0 3
60741: PPUSH
60742: LD_VAR 0 9
60746: PUSH
60747: EMPTY
60748: LIST
60749: PPUSH
60750: CALL 56973 0 2
// break ;
60754: GO 61418
// end ; end ; if GetType ( un ) = unit_building then
60756: LD_VAR 0 1
60760: PPUSH
60761: CALL_OW 247
60765: PUSH
60766: LD_INT 3
60768: EQUAL
60769: IFFALSE 61084
// begin btype := GetBType ( un ) ;
60771: LD_ADDR_VAR 0 5
60775: PUSH
60776: LD_VAR 0 1
60780: PPUSH
60781: CALL_OW 266
60785: ST_TO_ADDR
// if btype = b_warehouse then
60786: LD_VAR 0 5
60790: PUSH
60791: LD_INT 1
60793: EQUAL
60794: IFFALSE 60812
// begin btype := b_depot ;
60796: LD_ADDR_VAR 0 5
60800: PUSH
60801: LD_INT 0
60803: ST_TO_ADDR
// pos := 1 ;
60804: LD_ADDR_VAR 0 6
60808: PUSH
60809: LD_INT 1
60811: ST_TO_ADDR
// end ; if btype = b_factory then
60812: LD_VAR 0 5
60816: PUSH
60817: LD_INT 3
60819: EQUAL
60820: IFFALSE 60838
// begin btype := b_workshop ;
60822: LD_ADDR_VAR 0 5
60826: PUSH
60827: LD_INT 2
60829: ST_TO_ADDR
// pos := 1 ;
60830: LD_ADDR_VAR 0 6
60834: PUSH
60835: LD_INT 1
60837: ST_TO_ADDR
// end ; if btype = b_barracks then
60838: LD_VAR 0 5
60842: PUSH
60843: LD_INT 5
60845: EQUAL
60846: IFFALSE 60856
// btype := b_armoury ;
60848: LD_ADDR_VAR 0 5
60852: PUSH
60853: LD_INT 4
60855: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
60856: LD_VAR 0 5
60860: PUSH
60861: LD_INT 7
60863: PUSH
60864: LD_INT 8
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: IN
60871: IFFALSE 60881
// btype := b_lab ;
60873: LD_ADDR_VAR 0 5
60877: PUSH
60878: LD_INT 6
60880: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
60881: LD_ADDR_EXP 104
60885: PUSH
60886: LD_EXP 104
60890: PPUSH
60891: LD_VAR 0 3
60895: PUSH
60896: LD_EXP 104
60900: PUSH
60901: LD_VAR 0 3
60905: ARRAY
60906: PUSH
60907: LD_INT 1
60909: PLUS
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PPUSH
60915: LD_VAR 0 5
60919: PUSH
60920: LD_VAR 0 1
60924: PPUSH
60925: CALL_OW 250
60929: PUSH
60930: LD_VAR 0 1
60934: PPUSH
60935: CALL_OW 251
60939: PUSH
60940: LD_VAR 0 1
60944: PPUSH
60945: CALL_OW 254
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: LIST
60954: LIST
60955: PPUSH
60956: CALL 69708 0 3
60960: ST_TO_ADDR
// if pos = 1 then
60961: LD_VAR 0 6
60965: PUSH
60966: LD_INT 1
60968: EQUAL
60969: IFFALSE 61084
// begin tmp := mc_build_list [ i ] ;
60971: LD_ADDR_VAR 0 7
60975: PUSH
60976: LD_EXP 104
60980: PUSH
60981: LD_VAR 0 3
60985: ARRAY
60986: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60987: LD_VAR 0 7
60991: PPUSH
60992: LD_INT 2
60994: PUSH
60995: LD_INT 30
60997: PUSH
60998: LD_INT 0
61000: PUSH
61001: EMPTY
61002: LIST
61003: LIST
61004: PUSH
61005: LD_INT 30
61007: PUSH
61008: LD_INT 1
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: PUSH
61015: EMPTY
61016: LIST
61017: LIST
61018: LIST
61019: PPUSH
61020: CALL_OW 72
61024: IFFALSE 61034
// pos := 2 ;
61026: LD_ADDR_VAR 0 6
61030: PUSH
61031: LD_INT 2
61033: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
61034: LD_ADDR_VAR 0 7
61038: PUSH
61039: LD_VAR 0 7
61043: PPUSH
61044: LD_VAR 0 6
61048: PPUSH
61049: LD_VAR 0 7
61053: PPUSH
61054: CALL 70034 0 3
61058: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61059: LD_ADDR_EXP 104
61063: PUSH
61064: LD_EXP 104
61068: PPUSH
61069: LD_VAR 0 3
61073: PPUSH
61074: LD_VAR 0 7
61078: PPUSH
61079: CALL_OW 1
61083: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61084: LD_VAR 0 1
61088: PUSH
61089: LD_EXP 99
61093: PUSH
61094: LD_VAR 0 3
61098: ARRAY
61099: IN
61100: IFFALSE 61139
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61102: LD_ADDR_EXP 99
61106: PUSH
61107: LD_EXP 99
61111: PPUSH
61112: LD_VAR 0 3
61116: PPUSH
61117: LD_EXP 99
61121: PUSH
61122: LD_VAR 0 3
61126: ARRAY
61127: PUSH
61128: LD_VAR 0 1
61132: DIFF
61133: PPUSH
61134: CALL_OW 1
61138: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61139: LD_VAR 0 1
61143: PUSH
61144: LD_EXP 106
61148: PUSH
61149: LD_VAR 0 3
61153: ARRAY
61154: IN
61155: IFFALSE 61194
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61157: LD_ADDR_EXP 106
61161: PUSH
61162: LD_EXP 106
61166: PPUSH
61167: LD_VAR 0 3
61171: PPUSH
61172: LD_EXP 106
61176: PUSH
61177: LD_VAR 0 3
61181: ARRAY
61182: PUSH
61183: LD_VAR 0 1
61187: DIFF
61188: PPUSH
61189: CALL_OW 1
61193: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61194: LD_VAR 0 1
61198: PUSH
61199: LD_EXP 118
61203: PUSH
61204: LD_VAR 0 3
61208: ARRAY
61209: IN
61210: IFFALSE 61249
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61212: LD_ADDR_EXP 118
61216: PUSH
61217: LD_EXP 118
61221: PPUSH
61222: LD_VAR 0 3
61226: PPUSH
61227: LD_EXP 118
61231: PUSH
61232: LD_VAR 0 3
61236: ARRAY
61237: PUSH
61238: LD_VAR 0 1
61242: DIFF
61243: PPUSH
61244: CALL_OW 1
61248: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61249: LD_VAR 0 1
61253: PUSH
61254: LD_EXP 121
61258: PUSH
61259: LD_VAR 0 3
61263: ARRAY
61264: IN
61265: IFFALSE 61304
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61267: LD_ADDR_EXP 121
61271: PUSH
61272: LD_EXP 121
61276: PPUSH
61277: LD_VAR 0 3
61281: PPUSH
61282: LD_EXP 121
61286: PUSH
61287: LD_VAR 0 3
61291: ARRAY
61292: PUSH
61293: LD_VAR 0 1
61297: DIFF
61298: PPUSH
61299: CALL_OW 1
61303: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61304: LD_VAR 0 1
61308: PUSH
61309: LD_EXP 108
61313: PUSH
61314: LD_VAR 0 3
61318: ARRAY
61319: IN
61320: IFFALSE 61359
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61322: LD_ADDR_EXP 108
61326: PUSH
61327: LD_EXP 108
61331: PPUSH
61332: LD_VAR 0 3
61336: PPUSH
61337: LD_EXP 108
61341: PUSH
61342: LD_VAR 0 3
61346: ARRAY
61347: PUSH
61348: LD_VAR 0 1
61352: DIFF
61353: PPUSH
61354: CALL_OW 1
61358: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61359: LD_VAR 0 1
61363: PUSH
61364: LD_EXP 107
61368: PUSH
61369: LD_VAR 0 3
61373: ARRAY
61374: IN
61375: IFFALSE 61414
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61377: LD_ADDR_EXP 107
61381: PUSH
61382: LD_EXP 107
61386: PPUSH
61387: LD_VAR 0 3
61391: PPUSH
61392: LD_EXP 107
61396: PUSH
61397: LD_VAR 0 3
61401: ARRAY
61402: PUSH
61403: LD_VAR 0 1
61407: DIFF
61408: PPUSH
61409: CALL_OW 1
61413: ST_TO_ADDR
// end ; break ;
61414: GO 61418
// end ;
61416: GO 60343
61418: POP
61419: POP
// end ;
61420: LD_VAR 0 2
61424: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61425: LD_INT 0
61427: PPUSH
61428: PPUSH
61429: PPUSH
// if not mc_bases or not skirmish then
61430: LD_EXP 99
61434: NOT
61435: PUSH
61436: LD_EXP 97
61440: NOT
61441: OR
61442: IFFALSE 61446
// exit ;
61444: GO 61661
// for i = 1 to mc_bases do
61446: LD_ADDR_VAR 0 3
61450: PUSH
61451: DOUBLE
61452: LD_INT 1
61454: DEC
61455: ST_TO_ADDR
61456: LD_EXP 99
61460: PUSH
61461: FOR_TO
61462: IFFALSE 61659
// begin if building in mc_construct_list [ i ] then
61464: LD_VAR 0 1
61468: PUSH
61469: LD_EXP 106
61473: PUSH
61474: LD_VAR 0 3
61478: ARRAY
61479: IN
61480: IFFALSE 61657
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61482: LD_ADDR_EXP 106
61486: PUSH
61487: LD_EXP 106
61491: PPUSH
61492: LD_VAR 0 3
61496: PPUSH
61497: LD_EXP 106
61501: PUSH
61502: LD_VAR 0 3
61506: ARRAY
61507: PUSH
61508: LD_VAR 0 1
61512: DIFF
61513: PPUSH
61514: CALL_OW 1
61518: ST_TO_ADDR
// if building in mc_lab [ i ] then
61519: LD_VAR 0 1
61523: PUSH
61524: LD_EXP 132
61528: PUSH
61529: LD_VAR 0 3
61533: ARRAY
61534: IN
61535: IFFALSE 61590
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
61537: LD_ADDR_EXP 133
61541: PUSH
61542: LD_EXP 133
61546: PPUSH
61547: LD_VAR 0 3
61551: PPUSH
61552: LD_EXP 133
61556: PUSH
61557: LD_VAR 0 3
61561: ARRAY
61562: PPUSH
61563: LD_INT 1
61565: PPUSH
61566: LD_EXP 133
61570: PUSH
61571: LD_VAR 0 3
61575: ARRAY
61576: PPUSH
61577: LD_INT 0
61579: PPUSH
61580: CALL 69126 0 4
61584: PPUSH
61585: CALL_OW 1
61589: ST_TO_ADDR
// if not building in mc_bases [ i ] then
61590: LD_VAR 0 1
61594: PUSH
61595: LD_EXP 99
61599: PUSH
61600: LD_VAR 0 3
61604: ARRAY
61605: IN
61606: NOT
61607: IFFALSE 61653
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61609: LD_ADDR_EXP 99
61613: PUSH
61614: LD_EXP 99
61618: PPUSH
61619: LD_VAR 0 3
61623: PUSH
61624: LD_EXP 99
61628: PUSH
61629: LD_VAR 0 3
61633: ARRAY
61634: PUSH
61635: LD_INT 1
61637: PLUS
61638: PUSH
61639: EMPTY
61640: LIST
61641: LIST
61642: PPUSH
61643: LD_VAR 0 1
61647: PPUSH
61648: CALL 69708 0 3
61652: ST_TO_ADDR
// exit ;
61653: POP
61654: POP
61655: GO 61661
// end ; end ;
61657: GO 61461
61659: POP
61660: POP
// end ;
61661: LD_VAR 0 2
61665: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
61666: LD_INT 0
61668: PPUSH
61669: PPUSH
61670: PPUSH
61671: PPUSH
61672: PPUSH
61673: PPUSH
61674: PPUSH
// if not mc_bases or not skirmish then
61675: LD_EXP 99
61679: NOT
61680: PUSH
61681: LD_EXP 97
61685: NOT
61686: OR
61687: IFFALSE 61691
// exit ;
61689: GO 62352
// for i = 1 to mc_bases do
61691: LD_ADDR_VAR 0 3
61695: PUSH
61696: DOUBLE
61697: LD_INT 1
61699: DEC
61700: ST_TO_ADDR
61701: LD_EXP 99
61705: PUSH
61706: FOR_TO
61707: IFFALSE 62350
// begin if building in mc_construct_list [ i ] then
61709: LD_VAR 0 1
61713: PUSH
61714: LD_EXP 106
61718: PUSH
61719: LD_VAR 0 3
61723: ARRAY
61724: IN
61725: IFFALSE 62348
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61727: LD_ADDR_EXP 106
61731: PUSH
61732: LD_EXP 106
61736: PPUSH
61737: LD_VAR 0 3
61741: PPUSH
61742: LD_EXP 106
61746: PUSH
61747: LD_VAR 0 3
61751: ARRAY
61752: PUSH
61753: LD_VAR 0 1
61757: DIFF
61758: PPUSH
61759: CALL_OW 1
61763: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61764: LD_ADDR_EXP 99
61768: PUSH
61769: LD_EXP 99
61773: PPUSH
61774: LD_VAR 0 3
61778: PUSH
61779: LD_EXP 99
61783: PUSH
61784: LD_VAR 0 3
61788: ARRAY
61789: PUSH
61790: LD_INT 1
61792: PLUS
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: PPUSH
61798: LD_VAR 0 1
61802: PPUSH
61803: CALL 69708 0 3
61807: ST_TO_ADDR
// btype := GetBType ( building ) ;
61808: LD_ADDR_VAR 0 5
61812: PUSH
61813: LD_VAR 0 1
61817: PPUSH
61818: CALL_OW 266
61822: ST_TO_ADDR
// side := GetSide ( building ) ;
61823: LD_ADDR_VAR 0 8
61827: PUSH
61828: LD_VAR 0 1
61832: PPUSH
61833: CALL_OW 255
61837: ST_TO_ADDR
// if btype = b_lab then
61838: LD_VAR 0 5
61842: PUSH
61843: LD_INT 6
61845: EQUAL
61846: IFFALSE 61896
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
61848: LD_ADDR_EXP 132
61852: PUSH
61853: LD_EXP 132
61857: PPUSH
61858: LD_VAR 0 3
61862: PUSH
61863: LD_EXP 132
61867: PUSH
61868: LD_VAR 0 3
61872: ARRAY
61873: PUSH
61874: LD_INT 1
61876: PLUS
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PPUSH
61882: LD_VAR 0 1
61886: PPUSH
61887: CALL 69708 0 3
61891: ST_TO_ADDR
// exit ;
61892: POP
61893: POP
61894: GO 62352
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
61896: LD_VAR 0 5
61900: PUSH
61901: LD_INT 0
61903: PUSH
61904: LD_INT 2
61906: PUSH
61907: LD_INT 4
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: LIST
61914: IN
61915: IFFALSE 62039
// begin if btype = b_armoury then
61917: LD_VAR 0 5
61921: PUSH
61922: LD_INT 4
61924: EQUAL
61925: IFFALSE 61935
// btype := b_barracks ;
61927: LD_ADDR_VAR 0 5
61931: PUSH
61932: LD_INT 5
61934: ST_TO_ADDR
// if btype = b_depot then
61935: LD_VAR 0 5
61939: PUSH
61940: LD_INT 0
61942: EQUAL
61943: IFFALSE 61953
// btype := b_warehouse ;
61945: LD_ADDR_VAR 0 5
61949: PUSH
61950: LD_INT 1
61952: ST_TO_ADDR
// if btype = b_workshop then
61953: LD_VAR 0 5
61957: PUSH
61958: LD_INT 2
61960: EQUAL
61961: IFFALSE 61971
// btype := b_factory ;
61963: LD_ADDR_VAR 0 5
61967: PUSH
61968: LD_INT 3
61970: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
61971: LD_VAR 0 5
61975: PPUSH
61976: LD_VAR 0 8
61980: PPUSH
61981: CALL_OW 323
61985: PUSH
61986: LD_INT 1
61988: EQUAL
61989: IFFALSE 62035
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
61991: LD_ADDR_EXP 131
61995: PUSH
61996: LD_EXP 131
62000: PPUSH
62001: LD_VAR 0 3
62005: PUSH
62006: LD_EXP 131
62010: PUSH
62011: LD_VAR 0 3
62015: ARRAY
62016: PUSH
62017: LD_INT 1
62019: PLUS
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: PPUSH
62025: LD_VAR 0 1
62029: PPUSH
62030: CALL 69708 0 3
62034: ST_TO_ADDR
// exit ;
62035: POP
62036: POP
62037: GO 62352
// end ; if btype in [ b_bunker , b_turret ] then
62039: LD_VAR 0 5
62043: PUSH
62044: LD_INT 32
62046: PUSH
62047: LD_INT 33
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: IN
62054: IFFALSE 62344
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62056: LD_ADDR_EXP 107
62060: PUSH
62061: LD_EXP 107
62065: PPUSH
62066: LD_VAR 0 3
62070: PUSH
62071: LD_EXP 107
62075: PUSH
62076: LD_VAR 0 3
62080: ARRAY
62081: PUSH
62082: LD_INT 1
62084: PLUS
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: PPUSH
62090: LD_VAR 0 1
62094: PPUSH
62095: CALL 69708 0 3
62099: ST_TO_ADDR
// if btype = b_bunker then
62100: LD_VAR 0 5
62104: PUSH
62105: LD_INT 32
62107: EQUAL
62108: IFFALSE 62344
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62110: LD_ADDR_EXP 108
62114: PUSH
62115: LD_EXP 108
62119: PPUSH
62120: LD_VAR 0 3
62124: PUSH
62125: LD_EXP 108
62129: PUSH
62130: LD_VAR 0 3
62134: ARRAY
62135: PUSH
62136: LD_INT 1
62138: PLUS
62139: PUSH
62140: EMPTY
62141: LIST
62142: LIST
62143: PPUSH
62144: LD_VAR 0 1
62148: PPUSH
62149: CALL 69708 0 3
62153: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62154: LD_ADDR_VAR 0 6
62158: PUSH
62159: LD_EXP 99
62163: PUSH
62164: LD_VAR 0 3
62168: ARRAY
62169: PPUSH
62170: LD_INT 25
62172: PUSH
62173: LD_INT 1
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: PUSH
62180: LD_INT 3
62182: PUSH
62183: LD_INT 54
62185: PUSH
62186: EMPTY
62187: LIST
62188: PUSH
62189: EMPTY
62190: LIST
62191: LIST
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PPUSH
62197: CALL_OW 72
62201: ST_TO_ADDR
// if tmp then
62202: LD_VAR 0 6
62206: IFFALSE 62212
// exit ;
62208: POP
62209: POP
62210: GO 62352
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62212: LD_ADDR_VAR 0 6
62216: PUSH
62217: LD_EXP 99
62221: PUSH
62222: LD_VAR 0 3
62226: ARRAY
62227: PPUSH
62228: LD_INT 2
62230: PUSH
62231: LD_INT 30
62233: PUSH
62234: LD_INT 4
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 30
62243: PUSH
62244: LD_INT 5
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: LIST
62255: PPUSH
62256: CALL_OW 72
62260: ST_TO_ADDR
// if not tmp then
62261: LD_VAR 0 6
62265: NOT
62266: IFFALSE 62272
// exit ;
62268: POP
62269: POP
62270: GO 62352
// for j in tmp do
62272: LD_ADDR_VAR 0 4
62276: PUSH
62277: LD_VAR 0 6
62281: PUSH
62282: FOR_IN
62283: IFFALSE 62342
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62285: LD_ADDR_VAR 0 7
62289: PUSH
62290: LD_VAR 0 4
62294: PPUSH
62295: CALL_OW 313
62299: PPUSH
62300: LD_INT 25
62302: PUSH
62303: LD_INT 1
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: PPUSH
62310: CALL_OW 72
62314: ST_TO_ADDR
// if units then
62315: LD_VAR 0 7
62319: IFFALSE 62340
// begin ComExitBuilding ( units [ 1 ] ) ;
62321: LD_VAR 0 7
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: PPUSH
62330: CALL_OW 122
// exit ;
62334: POP
62335: POP
62336: POP
62337: POP
62338: GO 62352
// end ; end ;
62340: GO 62282
62342: POP
62343: POP
// end ; end ; exit ;
62344: POP
62345: POP
62346: GO 62352
// end ; end ;
62348: GO 61706
62350: POP
62351: POP
// end ;
62352: LD_VAR 0 2
62356: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62357: LD_INT 0
62359: PPUSH
62360: PPUSH
62361: PPUSH
62362: PPUSH
62363: PPUSH
62364: PPUSH
62365: PPUSH
// if not mc_bases or not skirmish then
62366: LD_EXP 99
62370: NOT
62371: PUSH
62372: LD_EXP 97
62376: NOT
62377: OR
62378: IFFALSE 62382
// exit ;
62380: GO 62613
// btype := GetBType ( building ) ;
62382: LD_ADDR_VAR 0 6
62386: PUSH
62387: LD_VAR 0 1
62391: PPUSH
62392: CALL_OW 266
62396: ST_TO_ADDR
// x := GetX ( building ) ;
62397: LD_ADDR_VAR 0 7
62401: PUSH
62402: LD_VAR 0 1
62406: PPUSH
62407: CALL_OW 250
62411: ST_TO_ADDR
// y := GetY ( building ) ;
62412: LD_ADDR_VAR 0 8
62416: PUSH
62417: LD_VAR 0 1
62421: PPUSH
62422: CALL_OW 251
62426: ST_TO_ADDR
// d := GetDir ( building ) ;
62427: LD_ADDR_VAR 0 9
62431: PUSH
62432: LD_VAR 0 1
62436: PPUSH
62437: CALL_OW 254
62441: ST_TO_ADDR
// for i = 1 to mc_bases do
62442: LD_ADDR_VAR 0 4
62446: PUSH
62447: DOUBLE
62448: LD_INT 1
62450: DEC
62451: ST_TO_ADDR
62452: LD_EXP 99
62456: PUSH
62457: FOR_TO
62458: IFFALSE 62611
// begin if not mc_build_list [ i ] then
62460: LD_EXP 104
62464: PUSH
62465: LD_VAR 0 4
62469: ARRAY
62470: NOT
62471: IFFALSE 62475
// continue ;
62473: GO 62457
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62475: LD_VAR 0 6
62479: PUSH
62480: LD_VAR 0 7
62484: PUSH
62485: LD_VAR 0 8
62489: PUSH
62490: LD_VAR 0 9
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: LIST
62499: LIST
62500: PPUSH
62501: LD_EXP 104
62505: PUSH
62506: LD_VAR 0 4
62510: ARRAY
62511: PUSH
62512: LD_INT 1
62514: ARRAY
62515: PPUSH
62516: CALL 75877 0 2
62520: IFFALSE 62609
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
62522: LD_ADDR_EXP 104
62526: PUSH
62527: LD_EXP 104
62531: PPUSH
62532: LD_VAR 0 4
62536: PPUSH
62537: LD_EXP 104
62541: PUSH
62542: LD_VAR 0 4
62546: ARRAY
62547: PPUSH
62548: LD_INT 1
62550: PPUSH
62551: CALL_OW 3
62555: PPUSH
62556: CALL_OW 1
62560: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
62561: LD_ADDR_EXP 106
62565: PUSH
62566: LD_EXP 106
62570: PPUSH
62571: LD_VAR 0 4
62575: PUSH
62576: LD_EXP 106
62580: PUSH
62581: LD_VAR 0 4
62585: ARRAY
62586: PUSH
62587: LD_INT 1
62589: PLUS
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PPUSH
62595: LD_VAR 0 1
62599: PPUSH
62600: CALL 69708 0 3
62604: ST_TO_ADDR
// exit ;
62605: POP
62606: POP
62607: GO 62613
// end ; end ;
62609: GO 62457
62611: POP
62612: POP
// end ;
62613: LD_VAR 0 3
62617: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
62618: LD_INT 0
62620: PPUSH
62621: PPUSH
62622: PPUSH
// if not mc_bases or not skirmish then
62623: LD_EXP 99
62627: NOT
62628: PUSH
62629: LD_EXP 97
62633: NOT
62634: OR
62635: IFFALSE 62639
// exit ;
62637: GO 62829
// for i = 1 to mc_bases do
62639: LD_ADDR_VAR 0 4
62643: PUSH
62644: DOUBLE
62645: LD_INT 1
62647: DEC
62648: ST_TO_ADDR
62649: LD_EXP 99
62653: PUSH
62654: FOR_TO
62655: IFFALSE 62742
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
62657: LD_VAR 0 1
62661: PUSH
62662: LD_EXP 107
62666: PUSH
62667: LD_VAR 0 4
62671: ARRAY
62672: IN
62673: PUSH
62674: LD_VAR 0 1
62678: PUSH
62679: LD_EXP 108
62683: PUSH
62684: LD_VAR 0 4
62688: ARRAY
62689: IN
62690: NOT
62691: AND
62692: IFFALSE 62740
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62694: LD_ADDR_EXP 108
62698: PUSH
62699: LD_EXP 108
62703: PPUSH
62704: LD_VAR 0 4
62708: PUSH
62709: LD_EXP 108
62713: PUSH
62714: LD_VAR 0 4
62718: ARRAY
62719: PUSH
62720: LD_INT 1
62722: PLUS
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: PPUSH
62728: LD_VAR 0 1
62732: PPUSH
62733: CALL 69708 0 3
62737: ST_TO_ADDR
// break ;
62738: GO 62742
// end ; end ;
62740: GO 62654
62742: POP
62743: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
62744: LD_VAR 0 1
62748: PPUSH
62749: CALL_OW 257
62753: PUSH
62754: LD_EXP 125
62758: IN
62759: PUSH
62760: LD_VAR 0 1
62764: PPUSH
62765: CALL_OW 266
62769: PUSH
62770: LD_INT 5
62772: EQUAL
62773: AND
62774: PUSH
62775: LD_VAR 0 2
62779: PPUSH
62780: CALL_OW 110
62784: PUSH
62785: LD_INT 18
62787: NONEQUAL
62788: AND
62789: IFFALSE 62829
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
62791: LD_VAR 0 2
62795: PPUSH
62796: CALL_OW 257
62800: PUSH
62801: LD_INT 5
62803: PUSH
62804: LD_INT 8
62806: PUSH
62807: LD_INT 9
62809: PUSH
62810: EMPTY
62811: LIST
62812: LIST
62813: LIST
62814: IN
62815: IFFALSE 62829
// SetClass ( unit , 1 ) ;
62817: LD_VAR 0 2
62821: PPUSH
62822: LD_INT 1
62824: PPUSH
62825: CALL_OW 336
// end ;
62829: LD_VAR 0 3
62833: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
62834: LD_INT 0
62836: PPUSH
62837: PPUSH
// if not mc_bases or not skirmish then
62838: LD_EXP 99
62842: NOT
62843: PUSH
62844: LD_EXP 97
62848: NOT
62849: OR
62850: IFFALSE 62854
// exit ;
62852: GO 62970
// if GetLives ( abandoned_vehicle ) > 250 then
62854: LD_VAR 0 2
62858: PPUSH
62859: CALL_OW 256
62863: PUSH
62864: LD_INT 250
62866: GREATER
62867: IFFALSE 62871
// exit ;
62869: GO 62970
// for i = 1 to mc_bases do
62871: LD_ADDR_VAR 0 6
62875: PUSH
62876: DOUBLE
62877: LD_INT 1
62879: DEC
62880: ST_TO_ADDR
62881: LD_EXP 99
62885: PUSH
62886: FOR_TO
62887: IFFALSE 62968
// begin if driver in mc_bases [ i ] then
62889: LD_VAR 0 1
62893: PUSH
62894: LD_EXP 99
62898: PUSH
62899: LD_VAR 0 6
62903: ARRAY
62904: IN
62905: IFFALSE 62966
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
62907: LD_VAR 0 1
62911: PPUSH
62912: LD_EXP 99
62916: PUSH
62917: LD_VAR 0 6
62921: ARRAY
62922: PPUSH
62923: LD_INT 2
62925: PUSH
62926: LD_INT 30
62928: PUSH
62929: LD_INT 0
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 30
62938: PUSH
62939: LD_INT 1
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: LIST
62950: PPUSH
62951: CALL_OW 72
62955: PUSH
62956: LD_INT 1
62958: ARRAY
62959: PPUSH
62960: CALL_OW 112
// break ;
62964: GO 62968
// end ; end ;
62966: GO 62886
62968: POP
62969: POP
// end ; end_of_file
62970: LD_VAR 0 5
62974: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62975: LD_INT 0
62977: PPUSH
62978: PPUSH
// if exist_mode then
62979: LD_VAR 0 2
62983: IFFALSE 63008
// unit := CreateCharacter ( prefix & ident ) else
62985: LD_ADDR_VAR 0 5
62989: PUSH
62990: LD_VAR 0 3
62994: PUSH
62995: LD_VAR 0 1
62999: STR
63000: PPUSH
63001: CALL_OW 34
63005: ST_TO_ADDR
63006: GO 63023
// unit := NewCharacter ( ident ) ;
63008: LD_ADDR_VAR 0 5
63012: PUSH
63013: LD_VAR 0 1
63017: PPUSH
63018: CALL_OW 25
63022: ST_TO_ADDR
// result := unit ;
63023: LD_ADDR_VAR 0 4
63027: PUSH
63028: LD_VAR 0 5
63032: ST_TO_ADDR
// end ;
63033: LD_VAR 0 4
63037: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63038: LD_INT 0
63040: PPUSH
63041: PPUSH
// if not side or not nation then
63042: LD_VAR 0 1
63046: NOT
63047: PUSH
63048: LD_VAR 0 2
63052: NOT
63053: OR
63054: IFFALSE 63058
// exit ;
63056: GO 63702
// case nation of nation_american :
63058: LD_VAR 0 2
63062: PUSH
63063: LD_INT 1
63065: DOUBLE
63066: EQUAL
63067: IFTRUE 63071
63069: GO 63245
63071: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
63072: LD_ADDR_VAR 0 4
63076: PUSH
63077: LD_INT 35
63079: PUSH
63080: LD_INT 45
63082: PUSH
63083: LD_INT 46
63085: PUSH
63086: LD_INT 47
63088: PUSH
63089: LD_INT 1
63091: PUSH
63092: LD_INT 2
63094: PUSH
63095: LD_INT 6
63097: PUSH
63098: LD_INT 15
63100: PUSH
63101: LD_INT 16
63103: PUSH
63104: LD_INT 7
63106: PUSH
63107: LD_INT 12
63109: PUSH
63110: LD_INT 13
63112: PUSH
63113: LD_INT 10
63115: PUSH
63116: LD_INT 14
63118: PUSH
63119: LD_INT 20
63121: PUSH
63122: LD_INT 21
63124: PUSH
63125: LD_INT 22
63127: PUSH
63128: LD_INT 25
63130: PUSH
63131: LD_INT 32
63133: PUSH
63134: LD_INT 27
63136: PUSH
63137: LD_INT 36
63139: PUSH
63140: LD_INT 69
63142: PUSH
63143: LD_INT 39
63145: PUSH
63146: LD_INT 34
63148: PUSH
63149: LD_INT 40
63151: PUSH
63152: LD_INT 48
63154: PUSH
63155: LD_INT 49
63157: PUSH
63158: LD_INT 50
63160: PUSH
63161: LD_INT 51
63163: PUSH
63164: LD_INT 52
63166: PUSH
63167: LD_INT 53
63169: PUSH
63170: LD_INT 54
63172: PUSH
63173: LD_INT 55
63175: PUSH
63176: LD_INT 56
63178: PUSH
63179: LD_INT 57
63181: PUSH
63182: LD_INT 58
63184: PUSH
63185: LD_INT 59
63187: PUSH
63188: LD_INT 60
63190: PUSH
63191: LD_INT 61
63193: PUSH
63194: LD_INT 62
63196: PUSH
63197: LD_INT 80
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: ST_TO_ADDR
63243: GO 63626
63245: LD_INT 2
63247: DOUBLE
63248: EQUAL
63249: IFTRUE 63253
63251: GO 63435
63253: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
63254: LD_ADDR_VAR 0 4
63258: PUSH
63259: LD_INT 35
63261: PUSH
63262: LD_INT 45
63264: PUSH
63265: LD_INT 46
63267: PUSH
63268: LD_INT 47
63270: PUSH
63271: LD_INT 70
63273: PUSH
63274: LD_INT 1
63276: PUSH
63277: LD_INT 11
63279: PUSH
63280: LD_INT 3
63282: PUSH
63283: LD_INT 4
63285: PUSH
63286: LD_INT 5
63288: PUSH
63289: LD_INT 6
63291: PUSH
63292: LD_INT 15
63294: PUSH
63295: LD_INT 18
63297: PUSH
63298: LD_INT 7
63300: PUSH
63301: LD_INT 17
63303: PUSH
63304: LD_INT 8
63306: PUSH
63307: LD_INT 20
63309: PUSH
63310: LD_INT 21
63312: PUSH
63313: LD_INT 22
63315: PUSH
63316: LD_INT 72
63318: PUSH
63319: LD_INT 26
63321: PUSH
63322: LD_INT 69
63324: PUSH
63325: LD_INT 39
63327: PUSH
63328: LD_INT 40
63330: PUSH
63331: LD_INT 41
63333: PUSH
63334: LD_INT 42
63336: PUSH
63337: LD_INT 43
63339: PUSH
63340: LD_INT 48
63342: PUSH
63343: LD_INT 49
63345: PUSH
63346: LD_INT 50
63348: PUSH
63349: LD_INT 51
63351: PUSH
63352: LD_INT 52
63354: PUSH
63355: LD_INT 53
63357: PUSH
63358: LD_INT 54
63360: PUSH
63361: LD_INT 55
63363: PUSH
63364: LD_INT 56
63366: PUSH
63367: LD_INT 60
63369: PUSH
63370: LD_INT 61
63372: PUSH
63373: LD_INT 62
63375: PUSH
63376: LD_INT 66
63378: PUSH
63379: LD_INT 67
63381: PUSH
63382: LD_INT 68
63384: PUSH
63385: LD_INT 81
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: LIST
63395: LIST
63396: LIST
63397: LIST
63398: LIST
63399: LIST
63400: LIST
63401: LIST
63402: LIST
63403: LIST
63404: LIST
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: LIST
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: LIST
63431: LIST
63432: ST_TO_ADDR
63433: GO 63626
63435: LD_INT 3
63437: DOUBLE
63438: EQUAL
63439: IFTRUE 63443
63441: GO 63625
63443: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63444: LD_ADDR_VAR 0 4
63448: PUSH
63449: LD_INT 46
63451: PUSH
63452: LD_INT 47
63454: PUSH
63455: LD_INT 1
63457: PUSH
63458: LD_INT 2
63460: PUSH
63461: LD_INT 11
63463: PUSH
63464: LD_INT 9
63466: PUSH
63467: LD_INT 20
63469: PUSH
63470: LD_INT 19
63472: PUSH
63473: LD_INT 21
63475: PUSH
63476: LD_INT 24
63478: PUSH
63479: LD_INT 22
63481: PUSH
63482: LD_INT 25
63484: PUSH
63485: LD_INT 28
63487: PUSH
63488: LD_INT 29
63490: PUSH
63491: LD_INT 30
63493: PUSH
63494: LD_INT 31
63496: PUSH
63497: LD_INT 37
63499: PUSH
63500: LD_INT 38
63502: PUSH
63503: LD_INT 32
63505: PUSH
63506: LD_INT 27
63508: PUSH
63509: LD_INT 33
63511: PUSH
63512: LD_INT 69
63514: PUSH
63515: LD_INT 39
63517: PUSH
63518: LD_INT 34
63520: PUSH
63521: LD_INT 40
63523: PUSH
63524: LD_INT 71
63526: PUSH
63527: LD_INT 23
63529: PUSH
63530: LD_INT 44
63532: PUSH
63533: LD_INT 48
63535: PUSH
63536: LD_INT 49
63538: PUSH
63539: LD_INT 50
63541: PUSH
63542: LD_INT 51
63544: PUSH
63545: LD_INT 52
63547: PUSH
63548: LD_INT 53
63550: PUSH
63551: LD_INT 54
63553: PUSH
63554: LD_INT 55
63556: PUSH
63557: LD_INT 56
63559: PUSH
63560: LD_INT 57
63562: PUSH
63563: LD_INT 58
63565: PUSH
63566: LD_INT 59
63568: PUSH
63569: LD_INT 63
63571: PUSH
63572: LD_INT 64
63574: PUSH
63575: LD_INT 65
63577: PUSH
63578: EMPTY
63579: LIST
63580: LIST
63581: LIST
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: ST_TO_ADDR
63623: GO 63626
63625: POP
// if state > - 1 and state < 3 then
63626: LD_VAR 0 3
63630: PUSH
63631: LD_INT 1
63633: NEG
63634: GREATER
63635: PUSH
63636: LD_VAR 0 3
63640: PUSH
63641: LD_INT 3
63643: LESS
63644: AND
63645: IFFALSE 63702
// for i in result do
63647: LD_ADDR_VAR 0 5
63651: PUSH
63652: LD_VAR 0 4
63656: PUSH
63657: FOR_IN
63658: IFFALSE 63700
// if GetTech ( i , side ) <> state then
63660: LD_VAR 0 5
63664: PPUSH
63665: LD_VAR 0 1
63669: PPUSH
63670: CALL_OW 321
63674: PUSH
63675: LD_VAR 0 3
63679: NONEQUAL
63680: IFFALSE 63698
// result := result diff i ;
63682: LD_ADDR_VAR 0 4
63686: PUSH
63687: LD_VAR 0 4
63691: PUSH
63692: LD_VAR 0 5
63696: DIFF
63697: ST_TO_ADDR
63698: GO 63657
63700: POP
63701: POP
// end ;
63702: LD_VAR 0 4
63706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63707: LD_INT 0
63709: PPUSH
63710: PPUSH
63711: PPUSH
// result := true ;
63712: LD_ADDR_VAR 0 3
63716: PUSH
63717: LD_INT 1
63719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63720: LD_ADDR_VAR 0 5
63724: PUSH
63725: LD_VAR 0 2
63729: PPUSH
63730: CALL_OW 480
63734: ST_TO_ADDR
// if not tmp then
63735: LD_VAR 0 5
63739: NOT
63740: IFFALSE 63744
// exit ;
63742: GO 63793
// for i in tmp do
63744: LD_ADDR_VAR 0 4
63748: PUSH
63749: LD_VAR 0 5
63753: PUSH
63754: FOR_IN
63755: IFFALSE 63791
// if GetTech ( i , side ) <> state_researched then
63757: LD_VAR 0 4
63761: PPUSH
63762: LD_VAR 0 1
63766: PPUSH
63767: CALL_OW 321
63771: PUSH
63772: LD_INT 2
63774: NONEQUAL
63775: IFFALSE 63789
// begin result := false ;
63777: LD_ADDR_VAR 0 3
63781: PUSH
63782: LD_INT 0
63784: ST_TO_ADDR
// exit ;
63785: POP
63786: POP
63787: GO 63793
// end ;
63789: GO 63754
63791: POP
63792: POP
// end ;
63793: LD_VAR 0 3
63797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63798: LD_INT 0
63800: PPUSH
63801: PPUSH
63802: PPUSH
63803: PPUSH
63804: PPUSH
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
63811: PPUSH
63812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63813: LD_VAR 0 1
63817: NOT
63818: PUSH
63819: LD_VAR 0 1
63823: PPUSH
63824: CALL_OW 257
63828: PUSH
63829: LD_INT 9
63831: NONEQUAL
63832: OR
63833: IFFALSE 63837
// exit ;
63835: GO 64410
// side := GetSide ( unit ) ;
63837: LD_ADDR_VAR 0 9
63841: PUSH
63842: LD_VAR 0 1
63846: PPUSH
63847: CALL_OW 255
63851: ST_TO_ADDR
// tech_space := tech_spacanom ;
63852: LD_ADDR_VAR 0 12
63856: PUSH
63857: LD_INT 29
63859: ST_TO_ADDR
// tech_time := tech_taurad ;
63860: LD_ADDR_VAR 0 13
63864: PUSH
63865: LD_INT 28
63867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63868: LD_ADDR_VAR 0 11
63872: PUSH
63873: LD_VAR 0 1
63877: PPUSH
63878: CALL_OW 310
63882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63883: LD_VAR 0 11
63887: PPUSH
63888: CALL_OW 247
63892: PUSH
63893: LD_INT 2
63895: EQUAL
63896: IFFALSE 63900
// exit ;
63898: GO 64410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63900: LD_ADDR_VAR 0 8
63904: PUSH
63905: LD_INT 81
63907: PUSH
63908: LD_VAR 0 9
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 3
63919: PUSH
63920: LD_INT 21
63922: PUSH
63923: LD_INT 3
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: EMPTY
63931: LIST
63932: LIST
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PPUSH
63938: CALL_OW 69
63942: ST_TO_ADDR
// if not tmp then
63943: LD_VAR 0 8
63947: NOT
63948: IFFALSE 63952
// exit ;
63950: GO 64410
// if in_unit then
63952: LD_VAR 0 11
63956: IFFALSE 63980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63958: LD_ADDR_VAR 0 10
63962: PUSH
63963: LD_VAR 0 8
63967: PPUSH
63968: LD_VAR 0 11
63972: PPUSH
63973: CALL_OW 74
63977: ST_TO_ADDR
63978: GO 64000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63980: LD_ADDR_VAR 0 10
63984: PUSH
63985: LD_VAR 0 8
63989: PPUSH
63990: LD_VAR 0 1
63994: PPUSH
63995: CALL_OW 74
63999: ST_TO_ADDR
// if not enemy then
64000: LD_VAR 0 10
64004: NOT
64005: IFFALSE 64009
// exit ;
64007: GO 64410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64009: LD_VAR 0 11
64013: PUSH
64014: LD_VAR 0 11
64018: PPUSH
64019: LD_VAR 0 10
64023: PPUSH
64024: CALL_OW 296
64028: PUSH
64029: LD_INT 13
64031: GREATER
64032: AND
64033: PUSH
64034: LD_VAR 0 1
64038: PPUSH
64039: LD_VAR 0 10
64043: PPUSH
64044: CALL_OW 296
64048: PUSH
64049: LD_INT 12
64051: GREATER
64052: OR
64053: IFFALSE 64057
// exit ;
64055: GO 64410
// missile := [ 1 ] ;
64057: LD_ADDR_VAR 0 14
64061: PUSH
64062: LD_INT 1
64064: PUSH
64065: EMPTY
64066: LIST
64067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64068: LD_VAR 0 9
64072: PPUSH
64073: LD_VAR 0 12
64077: PPUSH
64078: CALL_OW 325
64082: IFFALSE 64111
// missile := Insert ( missile , missile + 1 , 2 ) ;
64084: LD_ADDR_VAR 0 14
64088: PUSH
64089: LD_VAR 0 14
64093: PPUSH
64094: LD_VAR 0 14
64098: PUSH
64099: LD_INT 1
64101: PLUS
64102: PPUSH
64103: LD_INT 2
64105: PPUSH
64106: CALL_OW 2
64110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64111: LD_VAR 0 9
64115: PPUSH
64116: LD_VAR 0 13
64120: PPUSH
64121: CALL_OW 325
64125: PUSH
64126: LD_VAR 0 10
64130: PPUSH
64131: CALL_OW 255
64135: PPUSH
64136: LD_VAR 0 13
64140: PPUSH
64141: CALL_OW 325
64145: NOT
64146: AND
64147: IFFALSE 64176
// missile := Insert ( missile , missile + 1 , 3 ) ;
64149: LD_ADDR_VAR 0 14
64153: PUSH
64154: LD_VAR 0 14
64158: PPUSH
64159: LD_VAR 0 14
64163: PUSH
64164: LD_INT 1
64166: PLUS
64167: PPUSH
64168: LD_INT 3
64170: PPUSH
64171: CALL_OW 2
64175: ST_TO_ADDR
// if missile < 2 then
64176: LD_VAR 0 14
64180: PUSH
64181: LD_INT 2
64183: LESS
64184: IFFALSE 64188
// exit ;
64186: GO 64410
// x := GetX ( enemy ) ;
64188: LD_ADDR_VAR 0 4
64192: PUSH
64193: LD_VAR 0 10
64197: PPUSH
64198: CALL_OW 250
64202: ST_TO_ADDR
// y := GetY ( enemy ) ;
64203: LD_ADDR_VAR 0 5
64207: PUSH
64208: LD_VAR 0 10
64212: PPUSH
64213: CALL_OW 251
64217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64218: LD_ADDR_VAR 0 6
64222: PUSH
64223: LD_VAR 0 4
64227: PUSH
64228: LD_INT 1
64230: NEG
64231: PPUSH
64232: LD_INT 1
64234: PPUSH
64235: CALL_OW 12
64239: PLUS
64240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64241: LD_ADDR_VAR 0 7
64245: PUSH
64246: LD_VAR 0 5
64250: PUSH
64251: LD_INT 1
64253: NEG
64254: PPUSH
64255: LD_INT 1
64257: PPUSH
64258: CALL_OW 12
64262: PLUS
64263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64264: LD_VAR 0 6
64268: PPUSH
64269: LD_VAR 0 7
64273: PPUSH
64274: CALL_OW 488
64278: NOT
64279: IFFALSE 64301
// begin _x := x ;
64281: LD_ADDR_VAR 0 6
64285: PUSH
64286: LD_VAR 0 4
64290: ST_TO_ADDR
// _y := y ;
64291: LD_ADDR_VAR 0 7
64295: PUSH
64296: LD_VAR 0 5
64300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64301: LD_ADDR_VAR 0 3
64305: PUSH
64306: LD_INT 1
64308: PPUSH
64309: LD_VAR 0 14
64313: PPUSH
64314: CALL_OW 12
64318: ST_TO_ADDR
// case i of 1 :
64319: LD_VAR 0 3
64323: PUSH
64324: LD_INT 1
64326: DOUBLE
64327: EQUAL
64328: IFTRUE 64332
64330: GO 64349
64332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64333: LD_VAR 0 1
64337: PPUSH
64338: LD_VAR 0 10
64342: PPUSH
64343: CALL_OW 115
64347: GO 64410
64349: LD_INT 2
64351: DOUBLE
64352: EQUAL
64353: IFTRUE 64357
64355: GO 64379
64357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64358: LD_VAR 0 1
64362: PPUSH
64363: LD_VAR 0 6
64367: PPUSH
64368: LD_VAR 0 7
64372: PPUSH
64373: CALL_OW 153
64377: GO 64410
64379: LD_INT 3
64381: DOUBLE
64382: EQUAL
64383: IFTRUE 64387
64385: GO 64409
64387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64388: LD_VAR 0 1
64392: PPUSH
64393: LD_VAR 0 6
64397: PPUSH
64398: LD_VAR 0 7
64402: PPUSH
64403: CALL_OW 154
64407: GO 64410
64409: POP
// end ;
64410: LD_VAR 0 2
64414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64415: LD_INT 0
64417: PPUSH
64418: PPUSH
64419: PPUSH
64420: PPUSH
64421: PPUSH
64422: PPUSH
// if not unit or not building then
64423: LD_VAR 0 1
64427: NOT
64428: PUSH
64429: LD_VAR 0 2
64433: NOT
64434: OR
64435: IFFALSE 64439
// exit ;
64437: GO 64597
// x := GetX ( building ) ;
64439: LD_ADDR_VAR 0 5
64443: PUSH
64444: LD_VAR 0 2
64448: PPUSH
64449: CALL_OW 250
64453: ST_TO_ADDR
// y := GetY ( building ) ;
64454: LD_ADDR_VAR 0 6
64458: PUSH
64459: LD_VAR 0 2
64463: PPUSH
64464: CALL_OW 251
64468: ST_TO_ADDR
// for i = 0 to 5 do
64469: LD_ADDR_VAR 0 4
64473: PUSH
64474: DOUBLE
64475: LD_INT 0
64477: DEC
64478: ST_TO_ADDR
64479: LD_INT 5
64481: PUSH
64482: FOR_TO
64483: IFFALSE 64595
// begin _x := ShiftX ( x , i , 3 ) ;
64485: LD_ADDR_VAR 0 7
64489: PUSH
64490: LD_VAR 0 5
64494: PPUSH
64495: LD_VAR 0 4
64499: PPUSH
64500: LD_INT 3
64502: PPUSH
64503: CALL_OW 272
64507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64508: LD_ADDR_VAR 0 8
64512: PUSH
64513: LD_VAR 0 6
64517: PPUSH
64518: LD_VAR 0 4
64522: PPUSH
64523: LD_INT 3
64525: PPUSH
64526: CALL_OW 273
64530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64531: LD_VAR 0 7
64535: PPUSH
64536: LD_VAR 0 8
64540: PPUSH
64541: CALL_OW 488
64545: NOT
64546: IFFALSE 64550
// continue ;
64548: GO 64482
// if HexInfo ( _x , _y ) = 0 then
64550: LD_VAR 0 7
64554: PPUSH
64555: LD_VAR 0 8
64559: PPUSH
64560: CALL_OW 428
64564: PUSH
64565: LD_INT 0
64567: EQUAL
64568: IFFALSE 64593
// begin ComMoveXY ( unit , _x , _y ) ;
64570: LD_VAR 0 1
64574: PPUSH
64575: LD_VAR 0 7
64579: PPUSH
64580: LD_VAR 0 8
64584: PPUSH
64585: CALL_OW 111
// exit ;
64589: POP
64590: POP
64591: GO 64597
// end ; end ;
64593: GO 64482
64595: POP
64596: POP
// end ;
64597: LD_VAR 0 3
64601: RET
// export function ScanBase ( side , base_area ) ; begin
64602: LD_INT 0
64604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64605: LD_ADDR_VAR 0 3
64609: PUSH
64610: LD_VAR 0 2
64614: PPUSH
64615: LD_INT 81
64617: PUSH
64618: LD_VAR 0 1
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PPUSH
64627: CALL_OW 70
64631: ST_TO_ADDR
// end ;
64632: LD_VAR 0 3
64636: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
64637: LD_INT 0
64639: PPUSH
64640: PPUSH
64641: PPUSH
64642: PPUSH
64643: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
64644: LD_VAR 0 1
64648: NOT
64649: PUSH
64650: LD_EXP 99
64654: PUSH
64655: LD_VAR 0 1
64659: ARRAY
64660: NOT
64661: OR
64662: PUSH
64663: LD_VAR 0 2
64667: NOT
64668: OR
64669: PUSH
64670: LD_VAR 0 3
64674: NOT
64675: OR
64676: IFFALSE 64680
// exit ;
64678: GO 65130
// side := mc_sides [ base ] ;
64680: LD_ADDR_VAR 0 6
64684: PUSH
64685: LD_EXP 125
64689: PUSH
64690: LD_VAR 0 1
64694: ARRAY
64695: ST_TO_ADDR
// if not side then
64696: LD_VAR 0 6
64700: NOT
64701: IFFALSE 64705
// exit ;
64703: GO 65130
// for i in solds do
64705: LD_ADDR_VAR 0 7
64709: PUSH
64710: LD_VAR 0 2
64714: PUSH
64715: FOR_IN
64716: IFFALSE 64777
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
64718: LD_VAR 0 7
64722: PPUSH
64723: CALL_OW 310
64727: PPUSH
64728: CALL_OW 266
64732: PUSH
64733: LD_INT 32
64735: PUSH
64736: LD_INT 31
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: IN
64743: IFFALSE 64763
// solds := solds diff i else
64745: LD_ADDR_VAR 0 2
64749: PUSH
64750: LD_VAR 0 2
64754: PUSH
64755: LD_VAR 0 7
64759: DIFF
64760: ST_TO_ADDR
64761: GO 64775
// SetTag ( i , 18 ) ;
64763: LD_VAR 0 7
64767: PPUSH
64768: LD_INT 18
64770: PPUSH
64771: CALL_OW 109
64775: GO 64715
64777: POP
64778: POP
// if not solds then
64779: LD_VAR 0 2
64783: NOT
64784: IFFALSE 64788
// exit ;
64786: GO 65130
// repeat wait ( 0 0$1 ) ;
64788: LD_INT 35
64790: PPUSH
64791: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
64795: LD_ADDR_VAR 0 5
64799: PUSH
64800: LD_VAR 0 6
64804: PPUSH
64805: LD_VAR 0 3
64809: PPUSH
64810: CALL 64602 0 2
64814: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
64815: LD_VAR 0 5
64819: NOT
64820: PUSH
64821: LD_VAR 0 5
64825: PUSH
64826: LD_INT 3
64828: GREATER
64829: OR
64830: PUSH
64831: LD_EXP 121
64835: PUSH
64836: LD_VAR 0 1
64840: ARRAY
64841: OR
64842: IFFALSE 64883
// begin for i in solds do
64844: LD_ADDR_VAR 0 7
64848: PUSH
64849: LD_VAR 0 2
64853: PUSH
64854: FOR_IN
64855: IFFALSE 64879
// if HasTask ( i ) then
64857: LD_VAR 0 7
64861: PPUSH
64862: CALL_OW 314
64866: IFFALSE 64877
// ComStop ( i ) ;
64868: LD_VAR 0 7
64872: PPUSH
64873: CALL_OW 141
64877: GO 64854
64879: POP
64880: POP
// break ;
64881: GO 65118
// end ; for i in solds do
64883: LD_ADDR_VAR 0 7
64887: PUSH
64888: LD_VAR 0 2
64892: PUSH
64893: FOR_IN
64894: IFFALSE 65110
// begin if IsInUnit ( i ) then
64896: LD_VAR 0 7
64900: PPUSH
64901: CALL_OW 310
64905: IFFALSE 64916
// ComExitBuilding ( i ) ;
64907: LD_VAR 0 7
64911: PPUSH
64912: CALL_OW 122
// if GetLives ( i ) > 333 then
64916: LD_VAR 0 7
64920: PPUSH
64921: CALL_OW 256
64925: PUSH
64926: LD_INT 333
64928: GREATER
64929: IFFALSE 64957
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
64931: LD_VAR 0 7
64935: PPUSH
64936: LD_VAR 0 5
64940: PPUSH
64941: LD_VAR 0 7
64945: PPUSH
64946: CALL_OW 74
64950: PPUSH
64951: CALL_OW 115
64955: GO 65108
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
64957: LD_ADDR_VAR 0 8
64961: PUSH
64962: LD_EXP 99
64966: PUSH
64967: LD_VAR 0 1
64971: ARRAY
64972: PPUSH
64973: LD_INT 2
64975: PUSH
64976: LD_INT 30
64978: PUSH
64979: LD_INT 0
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: LD_INT 30
64988: PUSH
64989: LD_INT 1
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 30
64998: PUSH
64999: LD_INT 6
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: PPUSH
65012: CALL_OW 72
65016: PPUSH
65017: LD_VAR 0 7
65021: PPUSH
65022: CALL_OW 74
65026: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
65027: LD_VAR 0 7
65031: PPUSH
65032: LD_VAR 0 8
65036: PPUSH
65037: CALL_OW 250
65041: PPUSH
65042: LD_INT 3
65044: PPUSH
65045: LD_INT 5
65047: PPUSH
65048: CALL_OW 272
65052: PPUSH
65053: LD_VAR 0 8
65057: PPUSH
65058: CALL_OW 251
65062: PPUSH
65063: LD_INT 3
65065: PPUSH
65066: LD_INT 5
65068: PPUSH
65069: CALL_OW 273
65073: PPUSH
65074: CALL_OW 111
// SetTag ( i , 0 ) ;
65078: LD_VAR 0 7
65082: PPUSH
65083: LD_INT 0
65085: PPUSH
65086: CALL_OW 109
// solds := solds diff i ;
65090: LD_ADDR_VAR 0 2
65094: PUSH
65095: LD_VAR 0 2
65099: PUSH
65100: LD_VAR 0 7
65104: DIFF
65105: ST_TO_ADDR
// continue ;
65106: GO 64893
// end ; end ;
65108: GO 64893
65110: POP
65111: POP
// until solds ;
65112: LD_VAR 0 2
65116: IFFALSE 64788
// MC_Reset ( base , 18 ) ;
65118: LD_VAR 0 1
65122: PPUSH
65123: LD_INT 18
65125: PPUSH
65126: CALL 37830 0 2
// end ;
65130: LD_VAR 0 4
65134: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65135: LD_INT 0
65137: PPUSH
65138: PPUSH
65139: PPUSH
65140: PPUSH
65141: PPUSH
65142: PPUSH
65143: PPUSH
65144: PPUSH
65145: PPUSH
65146: PPUSH
65147: PPUSH
65148: PPUSH
65149: PPUSH
65150: PPUSH
65151: PPUSH
65152: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65153: LD_ADDR_VAR 0 12
65157: PUSH
65158: LD_EXP 99
65162: PUSH
65163: LD_VAR 0 1
65167: ARRAY
65168: PPUSH
65169: LD_INT 25
65171: PUSH
65172: LD_INT 3
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: PPUSH
65179: CALL_OW 72
65183: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65184: LD_ADDR_VAR 0 8
65188: PUSH
65189: LD_EXP 99
65193: PUSH
65194: LD_VAR 0 1
65198: ARRAY
65199: PPUSH
65200: LD_INT 2
65202: PUSH
65203: LD_INT 25
65205: PUSH
65206: LD_INT 1
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 25
65215: PUSH
65216: LD_INT 5
65218: PUSH
65219: EMPTY
65220: LIST
65221: LIST
65222: PUSH
65223: LD_INT 25
65225: PUSH
65226: LD_INT 8
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 25
65235: PUSH
65236: LD_INT 9
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: PPUSH
65250: CALL_OW 72
65254: ST_TO_ADDR
// if not defenders and not solds then
65255: LD_VAR 0 2
65259: NOT
65260: PUSH
65261: LD_VAR 0 8
65265: NOT
65266: AND
65267: IFFALSE 65271
// exit ;
65269: GO 66600
// depot_under_attack := false ;
65271: LD_ADDR_VAR 0 16
65275: PUSH
65276: LD_INT 0
65278: ST_TO_ADDR
// sold_defenders := [ ] ;
65279: LD_ADDR_VAR 0 17
65283: PUSH
65284: EMPTY
65285: ST_TO_ADDR
// if mechs then
65286: LD_VAR 0 12
65290: IFFALSE 65419
// for i in defenders do
65292: LD_ADDR_VAR 0 5
65296: PUSH
65297: LD_VAR 0 2
65301: PUSH
65302: FOR_IN
65303: IFFALSE 65417
// begin SetTag ( i , 20 ) ;
65305: LD_VAR 0 5
65309: PPUSH
65310: LD_INT 20
65312: PPUSH
65313: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65317: LD_VAR 0 5
65321: PPUSH
65322: CALL_OW 263
65326: PUSH
65327: LD_INT 1
65329: EQUAL
65330: PUSH
65331: LD_VAR 0 5
65335: PPUSH
65336: CALL_OW 311
65340: NOT
65341: AND
65342: PUSH
65343: LD_VAR 0 12
65347: AND
65348: IFFALSE 65415
// begin un := mechs [ 1 ] ;
65350: LD_ADDR_VAR 0 10
65354: PUSH
65355: LD_VAR 0 12
65359: PUSH
65360: LD_INT 1
65362: ARRAY
65363: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65364: LD_VAR 0 10
65368: PPUSH
65369: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65373: LD_VAR 0 10
65377: PPUSH
65378: LD_VAR 0 5
65382: PPUSH
65383: CALL_OW 180
// SetTag ( un , 19 ) ;
65387: LD_VAR 0 10
65391: PPUSH
65392: LD_INT 19
65394: PPUSH
65395: CALL_OW 109
// mechs := mechs diff un ;
65399: LD_ADDR_VAR 0 12
65403: PUSH
65404: LD_VAR 0 12
65408: PUSH
65409: LD_VAR 0 10
65413: DIFF
65414: ST_TO_ADDR
// end ; end ;
65415: GO 65302
65417: POP
65418: POP
// if solds then
65419: LD_VAR 0 8
65423: IFFALSE 65482
// for i in solds do
65425: LD_ADDR_VAR 0 5
65429: PUSH
65430: LD_VAR 0 8
65434: PUSH
65435: FOR_IN
65436: IFFALSE 65480
// if not GetTag ( i ) then
65438: LD_VAR 0 5
65442: PPUSH
65443: CALL_OW 110
65447: NOT
65448: IFFALSE 65478
// begin defenders := defenders union i ;
65450: LD_ADDR_VAR 0 2
65454: PUSH
65455: LD_VAR 0 2
65459: PUSH
65460: LD_VAR 0 5
65464: UNION
65465: ST_TO_ADDR
// SetTag ( i , 18 ) ;
65466: LD_VAR 0 5
65470: PPUSH
65471: LD_INT 18
65473: PPUSH
65474: CALL_OW 109
// end ;
65478: GO 65435
65480: POP
65481: POP
// repeat wait ( 0 0$1 ) ;
65482: LD_INT 35
65484: PPUSH
65485: CALL_OW 67
// enemy := mc_scan [ base ] ;
65489: LD_ADDR_VAR 0 3
65493: PUSH
65494: LD_EXP 122
65498: PUSH
65499: LD_VAR 0 1
65503: ARRAY
65504: ST_TO_ADDR
// for i in defenders do
65505: LD_ADDR_VAR 0 5
65509: PUSH
65510: LD_VAR 0 2
65514: PUSH
65515: FOR_IN
65516: IFFALSE 66201
// begin e := NearestUnitToUnit ( enemy , i ) ;
65518: LD_ADDR_VAR 0 13
65522: PUSH
65523: LD_VAR 0 3
65527: PPUSH
65528: LD_VAR 0 5
65532: PPUSH
65533: CALL_OW 74
65537: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
65538: LD_ADDR_VAR 0 16
65542: PUSH
65543: LD_EXP 99
65547: PUSH
65548: LD_VAR 0 1
65552: ARRAY
65553: PPUSH
65554: LD_INT 2
65556: PUSH
65557: LD_INT 30
65559: PUSH
65560: LD_INT 0
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: LD_INT 30
65569: PUSH
65570: LD_INT 1
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: LIST
65581: PPUSH
65582: CALL_OW 72
65586: NOT
65587: PUSH
65588: LD_EXP 99
65592: PUSH
65593: LD_VAR 0 1
65597: ARRAY
65598: PPUSH
65599: LD_INT 2
65601: PUSH
65602: LD_INT 30
65604: PUSH
65605: LD_INT 0
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: PUSH
65612: LD_INT 30
65614: PUSH
65615: LD_INT 1
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: LIST
65626: PPUSH
65627: CALL_OW 72
65631: PPUSH
65632: CALL_OW 256
65636: PUSH
65637: LD_INT 600
65639: LESS
65640: OR
65641: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
65642: LD_VAR 0 5
65646: PPUSH
65647: CALL_OW 247
65651: PUSH
65652: LD_INT 2
65654: DOUBLE
65655: EQUAL
65656: IFTRUE 65660
65658: GO 65907
65660: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
65661: LD_VAR 0 5
65665: PPUSH
65666: CALL_OW 256
65670: PUSH
65671: LD_INT 650
65673: GREATER
65674: PUSH
65675: LD_VAR 0 5
65679: PPUSH
65680: LD_VAR 0 13
65684: PPUSH
65685: CALL_OW 296
65689: PUSH
65690: LD_INT 40
65692: LESS
65693: AND
65694: IFFALSE 65712
// ComAttackUnit ( i , e ) else
65696: LD_VAR 0 5
65700: PPUSH
65701: LD_VAR 0 13
65705: PPUSH
65706: CALL_OW 115
65710: GO 65790
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
65712: LD_VAR 0 5
65716: PPUSH
65717: LD_VAR 0 13
65721: PPUSH
65722: CALL_OW 296
65726: PUSH
65727: LD_INT 30
65729: GREATEREQUAL
65730: PUSH
65731: LD_VAR 0 5
65735: PPUSH
65736: CALL_OW 256
65740: PUSH
65741: LD_INT 650
65743: LESSEQUAL
65744: OR
65745: PUSH
65746: LD_VAR 0 5
65750: PPUSH
65751: LD_EXP 123
65755: PUSH
65756: LD_VAR 0 1
65760: ARRAY
65761: PPUSH
65762: CALL_OW 308
65766: NOT
65767: AND
65768: IFFALSE 65790
// ComMoveToArea ( i , mc_parking [ base ] ) ;
65770: LD_VAR 0 5
65774: PPUSH
65775: LD_EXP 123
65779: PUSH
65780: LD_VAR 0 1
65784: ARRAY
65785: PPUSH
65786: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
65790: LD_VAR 0 5
65794: PPUSH
65795: CALL_OW 256
65799: PUSH
65800: LD_INT 998
65802: LESS
65803: PUSH
65804: LD_VAR 0 5
65808: PPUSH
65809: CALL_OW 263
65813: PUSH
65814: LD_INT 1
65816: EQUAL
65817: AND
65818: PUSH
65819: LD_VAR 0 5
65823: PPUSH
65824: CALL_OW 311
65828: AND
65829: PUSH
65830: LD_VAR 0 5
65834: PPUSH
65835: LD_EXP 123
65839: PUSH
65840: LD_VAR 0 1
65844: ARRAY
65845: PPUSH
65846: CALL_OW 308
65850: AND
65851: IFFALSE 65905
// begin mech := IsDrivenBy ( i ) ;
65853: LD_ADDR_VAR 0 9
65857: PUSH
65858: LD_VAR 0 5
65862: PPUSH
65863: CALL_OW 311
65867: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
65868: LD_VAR 0 9
65872: PPUSH
65873: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
65877: LD_VAR 0 9
65881: PPUSH
65882: LD_VAR 0 5
65886: PPUSH
65887: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
65891: LD_VAR 0 9
65895: PPUSH
65896: LD_VAR 0 5
65900: PPUSH
65901: CALL_OW 180
// end ; end ; unit_human :
65905: GO 66172
65907: LD_INT 1
65909: DOUBLE
65910: EQUAL
65911: IFTRUE 65915
65913: GO 66171
65915: POP
// begin b := IsInUnit ( i ) ;
65916: LD_ADDR_VAR 0 18
65920: PUSH
65921: LD_VAR 0 5
65925: PPUSH
65926: CALL_OW 310
65930: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
65931: LD_ADDR_VAR 0 19
65935: PUSH
65936: LD_VAR 0 18
65940: NOT
65941: PUSH
65942: LD_VAR 0 18
65946: PPUSH
65947: CALL_OW 266
65951: PUSH
65952: LD_INT 32
65954: PUSH
65955: LD_INT 31
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: IN
65962: OR
65963: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
65964: LD_VAR 0 16
65968: PUSH
65969: LD_VAR 0 2
65973: PPUSH
65974: LD_INT 21
65976: PUSH
65977: LD_INT 2
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PPUSH
65984: CALL_OW 72
65988: PUSH
65989: LD_INT 1
65991: LESSEQUAL
65992: OR
65993: PUSH
65994: LD_VAR 0 19
65998: AND
65999: PUSH
66000: LD_VAR 0 5
66004: PUSH
66005: LD_VAR 0 17
66009: IN
66010: NOT
66011: AND
66012: IFFALSE 66105
// begin if b then
66014: LD_VAR 0 18
66018: IFFALSE 66067
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
66020: LD_VAR 0 18
66024: PPUSH
66025: LD_VAR 0 3
66029: PPUSH
66030: LD_VAR 0 18
66034: PPUSH
66035: CALL_OW 74
66039: PPUSH
66040: CALL_OW 296
66044: PUSH
66045: LD_INT 10
66047: LESS
66048: PUSH
66049: LD_VAR 0 18
66053: PPUSH
66054: CALL_OW 461
66058: PUSH
66059: LD_INT 7
66061: NONEQUAL
66062: AND
66063: IFFALSE 66067
// continue ;
66065: GO 65515
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66067: LD_ADDR_VAR 0 17
66071: PUSH
66072: LD_VAR 0 17
66076: PPUSH
66077: LD_VAR 0 17
66081: PUSH
66082: LD_INT 1
66084: PLUS
66085: PPUSH
66086: LD_VAR 0 5
66090: PPUSH
66091: CALL_OW 1
66095: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66096: LD_VAR 0 5
66100: PPUSH
66101: CALL_OW 122
// end ; if sold_defenders then
66105: LD_VAR 0 17
66109: IFFALSE 66169
// if i in sold_defenders then
66111: LD_VAR 0 5
66115: PUSH
66116: LD_VAR 0 17
66120: IN
66121: IFFALSE 66169
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66123: LD_VAR 0 5
66127: PPUSH
66128: CALL_OW 314
66132: NOT
66133: PUSH
66134: LD_VAR 0 5
66138: PPUSH
66139: LD_VAR 0 13
66143: PPUSH
66144: CALL_OW 296
66148: PUSH
66149: LD_INT 30
66151: LESS
66152: AND
66153: IFFALSE 66169
// ComAttackUnit ( i , e ) ;
66155: LD_VAR 0 5
66159: PPUSH
66160: LD_VAR 0 13
66164: PPUSH
66165: CALL_OW 115
// end ; end ; end ;
66169: GO 66172
66171: POP
// if IsDead ( i ) then
66172: LD_VAR 0 5
66176: PPUSH
66177: CALL_OW 301
66181: IFFALSE 66199
// defenders := defenders diff i ;
66183: LD_ADDR_VAR 0 2
66187: PUSH
66188: LD_VAR 0 2
66192: PUSH
66193: LD_VAR 0 5
66197: DIFF
66198: ST_TO_ADDR
// end ;
66199: GO 65515
66201: POP
66202: POP
// until not enemy or not defenders ;
66203: LD_VAR 0 3
66207: NOT
66208: PUSH
66209: LD_VAR 0 2
66213: NOT
66214: OR
66215: IFFALSE 65482
// MC_Reset ( base , 18 ) ;
66217: LD_VAR 0 1
66221: PPUSH
66222: LD_INT 18
66224: PPUSH
66225: CALL 37830 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66229: LD_ADDR_VAR 0 2
66233: PUSH
66234: LD_VAR 0 2
66238: PUSH
66239: LD_VAR 0 2
66243: PPUSH
66244: LD_INT 2
66246: PUSH
66247: LD_INT 25
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 25
66259: PUSH
66260: LD_INT 5
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: LD_INT 25
66269: PUSH
66270: LD_INT 8
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 25
66279: PUSH
66280: LD_INT 9
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: PPUSH
66294: CALL_OW 72
66298: DIFF
66299: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66300: LD_VAR 0 3
66304: NOT
66305: PUSH
66306: LD_VAR 0 2
66310: PPUSH
66311: LD_INT 21
66313: PUSH
66314: LD_INT 2
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PPUSH
66321: CALL_OW 72
66325: AND
66326: IFFALSE 66588
// begin tmp := FilterByTag ( defenders , 19 ) ;
66328: LD_ADDR_VAR 0 11
66332: PUSH
66333: LD_VAR 0 2
66337: PPUSH
66338: LD_INT 19
66340: PPUSH
66341: CALL 102968 0 2
66345: ST_TO_ADDR
// if tmp then
66346: LD_VAR 0 11
66350: IFFALSE 66420
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66352: LD_ADDR_VAR 0 11
66356: PUSH
66357: LD_VAR 0 11
66361: PPUSH
66362: LD_INT 25
66364: PUSH
66365: LD_INT 3
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PPUSH
66372: CALL_OW 72
66376: ST_TO_ADDR
// if tmp then
66377: LD_VAR 0 11
66381: IFFALSE 66420
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66383: LD_ADDR_EXP 111
66387: PUSH
66388: LD_EXP 111
66392: PPUSH
66393: LD_VAR 0 1
66397: PPUSH
66398: LD_EXP 111
66402: PUSH
66403: LD_VAR 0 1
66407: ARRAY
66408: PUSH
66409: LD_VAR 0 11
66413: UNION
66414: PPUSH
66415: CALL_OW 1
66419: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
66420: LD_VAR 0 1
66424: PPUSH
66425: LD_INT 19
66427: PPUSH
66428: CALL 37830 0 2
// repeat wait ( 0 0$1 ) ;
66432: LD_INT 35
66434: PPUSH
66435: CALL_OW 67
// for i in defenders do
66439: LD_ADDR_VAR 0 5
66443: PUSH
66444: LD_VAR 0 2
66448: PUSH
66449: FOR_IN
66450: IFFALSE 66539
// begin if not IsInArea ( i , mc_parking [ base ] ) then
66452: LD_VAR 0 5
66456: PPUSH
66457: LD_EXP 123
66461: PUSH
66462: LD_VAR 0 1
66466: ARRAY
66467: PPUSH
66468: CALL_OW 308
66472: NOT
66473: IFFALSE 66497
// ComMoveToArea ( i , mc_parking [ base ] ) else
66475: LD_VAR 0 5
66479: PPUSH
66480: LD_EXP 123
66484: PUSH
66485: LD_VAR 0 1
66489: ARRAY
66490: PPUSH
66491: CALL_OW 113
66495: GO 66537
// if GetControl ( i ) = control_manual then
66497: LD_VAR 0 5
66501: PPUSH
66502: CALL_OW 263
66506: PUSH
66507: LD_INT 1
66509: EQUAL
66510: IFFALSE 66537
// if IsDrivenBy ( i ) then
66512: LD_VAR 0 5
66516: PPUSH
66517: CALL_OW 311
66521: IFFALSE 66537
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
66523: LD_VAR 0 5
66527: PPUSH
66528: CALL_OW 311
66532: PPUSH
66533: CALL_OW 121
// end ;
66537: GO 66449
66539: POP
66540: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
66541: LD_VAR 0 2
66545: PPUSH
66546: LD_INT 95
66548: PUSH
66549: LD_EXP 123
66553: PUSH
66554: LD_VAR 0 1
66558: ARRAY
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PPUSH
66564: CALL_OW 72
66568: PUSH
66569: LD_VAR 0 2
66573: EQUAL
66574: PUSH
66575: LD_EXP 122
66579: PUSH
66580: LD_VAR 0 1
66584: ARRAY
66585: OR
66586: IFFALSE 66432
// end ; MC_Reset ( base , 20 ) ;
66588: LD_VAR 0 1
66592: PPUSH
66593: LD_INT 20
66595: PPUSH
66596: CALL 37830 0 2
// end ;
66600: LD_VAR 0 4
66604: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66605: LD_INT 0
66607: PPUSH
66608: PPUSH
66609: PPUSH
66610: PPUSH
// result := false ;
66611: LD_ADDR_VAR 0 2
66615: PUSH
66616: LD_INT 0
66618: ST_TO_ADDR
// side := GetSide ( unit ) ;
66619: LD_ADDR_VAR 0 3
66623: PUSH
66624: LD_VAR 0 1
66628: PPUSH
66629: CALL_OW 255
66633: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66634: LD_ADDR_VAR 0 4
66638: PUSH
66639: LD_VAR 0 1
66643: PPUSH
66644: CALL_OW 248
66648: ST_TO_ADDR
// case nat of 1 :
66649: LD_VAR 0 4
66653: PUSH
66654: LD_INT 1
66656: DOUBLE
66657: EQUAL
66658: IFTRUE 66662
66660: GO 66673
66662: POP
// tech := tech_lassight ; 2 :
66663: LD_ADDR_VAR 0 5
66667: PUSH
66668: LD_INT 12
66670: ST_TO_ADDR
66671: GO 66712
66673: LD_INT 2
66675: DOUBLE
66676: EQUAL
66677: IFTRUE 66681
66679: GO 66692
66681: POP
// tech := tech_mortar ; 3 :
66682: LD_ADDR_VAR 0 5
66686: PUSH
66687: LD_INT 41
66689: ST_TO_ADDR
66690: GO 66712
66692: LD_INT 3
66694: DOUBLE
66695: EQUAL
66696: IFTRUE 66700
66698: GO 66711
66700: POP
// tech := tech_bazooka ; end ;
66701: LD_ADDR_VAR 0 5
66705: PUSH
66706: LD_INT 44
66708: ST_TO_ADDR
66709: GO 66712
66711: POP
// if Researched ( side , tech ) then
66712: LD_VAR 0 3
66716: PPUSH
66717: LD_VAR 0 5
66721: PPUSH
66722: CALL_OW 325
66726: IFFALSE 66753
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66728: LD_ADDR_VAR 0 2
66732: PUSH
66733: LD_INT 5
66735: PUSH
66736: LD_INT 8
66738: PUSH
66739: LD_INT 9
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: LIST
66746: PUSH
66747: LD_VAR 0 4
66751: ARRAY
66752: ST_TO_ADDR
// end ;
66753: LD_VAR 0 2
66757: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66758: LD_INT 0
66760: PPUSH
66761: PPUSH
66762: PPUSH
// if not mines then
66763: LD_VAR 0 2
66767: NOT
66768: IFFALSE 66772
// exit ;
66770: GO 66916
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66772: LD_ADDR_VAR 0 5
66776: PUSH
66777: LD_INT 81
66779: PUSH
66780: LD_VAR 0 1
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 3
66791: PUSH
66792: LD_INT 21
66794: PUSH
66795: LD_INT 3
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PPUSH
66810: CALL_OW 69
66814: ST_TO_ADDR
// for i in mines do
66815: LD_ADDR_VAR 0 4
66819: PUSH
66820: LD_VAR 0 2
66824: PUSH
66825: FOR_IN
66826: IFFALSE 66914
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66828: LD_VAR 0 4
66832: PUSH
66833: LD_INT 1
66835: ARRAY
66836: PPUSH
66837: LD_VAR 0 4
66841: PUSH
66842: LD_INT 2
66844: ARRAY
66845: PPUSH
66846: CALL_OW 458
66850: NOT
66851: IFFALSE 66855
// continue ;
66853: GO 66825
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66855: LD_VAR 0 4
66859: PUSH
66860: LD_INT 1
66862: ARRAY
66863: PPUSH
66864: LD_VAR 0 4
66868: PUSH
66869: LD_INT 2
66871: ARRAY
66872: PPUSH
66873: CALL_OW 428
66877: PUSH
66878: LD_VAR 0 5
66882: IN
66883: IFFALSE 66912
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66885: LD_VAR 0 4
66889: PUSH
66890: LD_INT 1
66892: ARRAY
66893: PPUSH
66894: LD_VAR 0 4
66898: PUSH
66899: LD_INT 2
66901: ARRAY
66902: PPUSH
66903: LD_VAR 0 1
66907: PPUSH
66908: CALL_OW 456
// end ;
66912: GO 66825
66914: POP
66915: POP
// end ;
66916: LD_VAR 0 3
66920: RET
// export function Count ( array ) ; var i ; begin
66921: LD_INT 0
66923: PPUSH
66924: PPUSH
// result := 0 ;
66925: LD_ADDR_VAR 0 2
66929: PUSH
66930: LD_INT 0
66932: ST_TO_ADDR
// for i in array do
66933: LD_ADDR_VAR 0 3
66937: PUSH
66938: LD_VAR 0 1
66942: PUSH
66943: FOR_IN
66944: IFFALSE 66968
// if i then
66946: LD_VAR 0 3
66950: IFFALSE 66966
// result := result + 1 ;
66952: LD_ADDR_VAR 0 2
66956: PUSH
66957: LD_VAR 0 2
66961: PUSH
66962: LD_INT 1
66964: PLUS
66965: ST_TO_ADDR
66966: GO 66943
66968: POP
66969: POP
// end ;
66970: LD_VAR 0 2
66974: RET
// export function IsEmpty ( building ) ; begin
66975: LD_INT 0
66977: PPUSH
// if not building then
66978: LD_VAR 0 1
66982: NOT
66983: IFFALSE 66987
// exit ;
66985: GO 67030
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66987: LD_ADDR_VAR 0 2
66991: PUSH
66992: LD_VAR 0 1
66996: PUSH
66997: LD_INT 22
66999: PUSH
67000: LD_VAR 0 1
67004: PPUSH
67005: CALL_OW 255
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 58
67016: PUSH
67017: EMPTY
67018: LIST
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PPUSH
67024: CALL_OW 69
67028: IN
67029: ST_TO_ADDR
// end ;
67030: LD_VAR 0 2
67034: RET
// export function IsNotFull ( building ) ; begin
67035: LD_INT 0
67037: PPUSH
// if not building then
67038: LD_VAR 0 1
67042: NOT
67043: IFFALSE 67047
// exit ;
67045: GO 67066
// result := UnitsInside ( building ) < 6 ;
67047: LD_ADDR_VAR 0 2
67051: PUSH
67052: LD_VAR 0 1
67056: PPUSH
67057: CALL_OW 313
67061: PUSH
67062: LD_INT 6
67064: LESS
67065: ST_TO_ADDR
// end ;
67066: LD_VAR 0 2
67070: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67071: LD_INT 0
67073: PPUSH
67074: PPUSH
67075: PPUSH
67076: PPUSH
// tmp := [ ] ;
67077: LD_ADDR_VAR 0 3
67081: PUSH
67082: EMPTY
67083: ST_TO_ADDR
// list := [ ] ;
67084: LD_ADDR_VAR 0 5
67088: PUSH
67089: EMPTY
67090: ST_TO_ADDR
// for i = 16 to 25 do
67091: LD_ADDR_VAR 0 4
67095: PUSH
67096: DOUBLE
67097: LD_INT 16
67099: DEC
67100: ST_TO_ADDR
67101: LD_INT 25
67103: PUSH
67104: FOR_TO
67105: IFFALSE 67178
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67107: LD_ADDR_VAR 0 3
67111: PUSH
67112: LD_VAR 0 3
67116: PUSH
67117: LD_INT 22
67119: PUSH
67120: LD_VAR 0 1
67124: PPUSH
67125: CALL_OW 255
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 91
67136: PUSH
67137: LD_VAR 0 1
67141: PUSH
67142: LD_INT 6
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 30
67152: PUSH
67153: LD_VAR 0 4
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: LIST
67166: PUSH
67167: EMPTY
67168: LIST
67169: PPUSH
67170: CALL_OW 69
67174: ADD
67175: ST_TO_ADDR
67176: GO 67104
67178: POP
67179: POP
// for i = 1 to tmp do
67180: LD_ADDR_VAR 0 4
67184: PUSH
67185: DOUBLE
67186: LD_INT 1
67188: DEC
67189: ST_TO_ADDR
67190: LD_VAR 0 3
67194: PUSH
67195: FOR_TO
67196: IFFALSE 67284
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67198: LD_ADDR_VAR 0 5
67202: PUSH
67203: LD_VAR 0 5
67207: PUSH
67208: LD_VAR 0 3
67212: PUSH
67213: LD_VAR 0 4
67217: ARRAY
67218: PPUSH
67219: CALL_OW 266
67223: PUSH
67224: LD_VAR 0 3
67228: PUSH
67229: LD_VAR 0 4
67233: ARRAY
67234: PPUSH
67235: CALL_OW 250
67239: PUSH
67240: LD_VAR 0 3
67244: PUSH
67245: LD_VAR 0 4
67249: ARRAY
67250: PPUSH
67251: CALL_OW 251
67255: PUSH
67256: LD_VAR 0 3
67260: PUSH
67261: LD_VAR 0 4
67265: ARRAY
67266: PPUSH
67267: CALL_OW 254
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: PUSH
67278: EMPTY
67279: LIST
67280: ADD
67281: ST_TO_ADDR
67282: GO 67195
67284: POP
67285: POP
// result := list ;
67286: LD_ADDR_VAR 0 2
67290: PUSH
67291: LD_VAR 0 5
67295: ST_TO_ADDR
// end ;
67296: LD_VAR 0 2
67300: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67301: LD_INT 0
67303: PPUSH
67304: PPUSH
67305: PPUSH
67306: PPUSH
67307: PPUSH
67308: PPUSH
67309: PPUSH
// if not factory then
67310: LD_VAR 0 1
67314: NOT
67315: IFFALSE 67319
// exit ;
67317: GO 67851
// if control = control_apeman then
67319: LD_VAR 0 4
67323: PUSH
67324: LD_INT 5
67326: EQUAL
67327: IFFALSE 67436
// begin tmp := UnitsInside ( factory ) ;
67329: LD_ADDR_VAR 0 8
67333: PUSH
67334: LD_VAR 0 1
67338: PPUSH
67339: CALL_OW 313
67343: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67344: LD_VAR 0 8
67348: PPUSH
67349: LD_INT 25
67351: PUSH
67352: LD_INT 12
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PPUSH
67359: CALL_OW 72
67363: NOT
67364: IFFALSE 67374
// control := control_manual ;
67366: LD_ADDR_VAR 0 4
67370: PUSH
67371: LD_INT 1
67373: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67374: LD_ADDR_VAR 0 8
67378: PUSH
67379: LD_VAR 0 1
67383: PPUSH
67384: CALL 67071 0 1
67388: ST_TO_ADDR
// if tmp then
67389: LD_VAR 0 8
67393: IFFALSE 67436
// begin for i in tmp do
67395: LD_ADDR_VAR 0 7
67399: PUSH
67400: LD_VAR 0 8
67404: PUSH
67405: FOR_IN
67406: IFFALSE 67434
// if i [ 1 ] = b_ext_radio then
67408: LD_VAR 0 7
67412: PUSH
67413: LD_INT 1
67415: ARRAY
67416: PUSH
67417: LD_INT 22
67419: EQUAL
67420: IFFALSE 67432
// begin control := control_remote ;
67422: LD_ADDR_VAR 0 4
67426: PUSH
67427: LD_INT 2
67429: ST_TO_ADDR
// break ;
67430: GO 67434
// end ;
67432: GO 67405
67434: POP
67435: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67436: LD_VAR 0 1
67440: PPUSH
67441: LD_VAR 0 2
67445: PPUSH
67446: LD_VAR 0 3
67450: PPUSH
67451: LD_VAR 0 4
67455: PPUSH
67456: LD_VAR 0 5
67460: PPUSH
67461: CALL_OW 448
67465: IFFALSE 67500
// begin result := [ chassis , engine , control , weapon ] ;
67467: LD_ADDR_VAR 0 6
67471: PUSH
67472: LD_VAR 0 2
67476: PUSH
67477: LD_VAR 0 3
67481: PUSH
67482: LD_VAR 0 4
67486: PUSH
67487: LD_VAR 0 5
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: ST_TO_ADDR
// exit ;
67498: GO 67851
// end ; _chassis := AvailableChassisList ( factory ) ;
67500: LD_ADDR_VAR 0 9
67504: PUSH
67505: LD_VAR 0 1
67509: PPUSH
67510: CALL_OW 475
67514: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67515: LD_ADDR_VAR 0 11
67519: PUSH
67520: LD_VAR 0 1
67524: PPUSH
67525: CALL_OW 476
67529: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67530: LD_ADDR_VAR 0 12
67534: PUSH
67535: LD_VAR 0 1
67539: PPUSH
67540: CALL_OW 477
67544: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67545: LD_ADDR_VAR 0 10
67549: PUSH
67550: LD_VAR 0 1
67554: PPUSH
67555: CALL_OW 478
67559: ST_TO_ADDR
// if not chassis in _chassis then
67560: LD_VAR 0 2
67564: PUSH
67565: LD_VAR 0 9
67569: IN
67570: NOT
67571: IFFALSE 67597
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67573: LD_ADDR_VAR 0 2
67577: PUSH
67578: LD_VAR 0 9
67582: PUSH
67583: LD_INT 1
67585: PPUSH
67586: LD_VAR 0 9
67590: PPUSH
67591: CALL_OW 12
67595: ARRAY
67596: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67597: LD_VAR 0 2
67601: PPUSH
67602: LD_VAR 0 3
67606: PPUSH
67607: CALL 67856 0 2
67611: NOT
67612: IFFALSE 67671
// repeat engine := _engine [ 1 ] ;
67614: LD_ADDR_VAR 0 3
67618: PUSH
67619: LD_VAR 0 11
67623: PUSH
67624: LD_INT 1
67626: ARRAY
67627: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67628: LD_ADDR_VAR 0 11
67632: PUSH
67633: LD_VAR 0 11
67637: PPUSH
67638: LD_INT 1
67640: PPUSH
67641: CALL_OW 3
67645: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67646: LD_VAR 0 2
67650: PPUSH
67651: LD_VAR 0 3
67655: PPUSH
67656: CALL 67856 0 2
67660: PUSH
67661: LD_VAR 0 11
67665: PUSH
67666: EMPTY
67667: EQUAL
67668: OR
67669: IFFALSE 67614
// if not control in _control then
67671: LD_VAR 0 4
67675: PUSH
67676: LD_VAR 0 12
67680: IN
67681: NOT
67682: IFFALSE 67708
// control := _control [ rand ( 1 , _control ) ] ;
67684: LD_ADDR_VAR 0 4
67688: PUSH
67689: LD_VAR 0 12
67693: PUSH
67694: LD_INT 1
67696: PPUSH
67697: LD_VAR 0 12
67701: PPUSH
67702: CALL_OW 12
67706: ARRAY
67707: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67708: LD_VAR 0 2
67712: PPUSH
67713: LD_VAR 0 5
67717: PPUSH
67718: CALL 68076 0 2
67722: NOT
67723: IFFALSE 67782
// repeat weapon := _weapon [ 1 ] ;
67725: LD_ADDR_VAR 0 5
67729: PUSH
67730: LD_VAR 0 10
67734: PUSH
67735: LD_INT 1
67737: ARRAY
67738: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67739: LD_ADDR_VAR 0 10
67743: PUSH
67744: LD_VAR 0 10
67748: PPUSH
67749: LD_INT 1
67751: PPUSH
67752: CALL_OW 3
67756: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67757: LD_VAR 0 2
67761: PPUSH
67762: LD_VAR 0 5
67766: PPUSH
67767: CALL 68076 0 2
67771: PUSH
67772: LD_VAR 0 10
67776: PUSH
67777: EMPTY
67778: EQUAL
67779: OR
67780: IFFALSE 67725
// result := [ ] ;
67782: LD_ADDR_VAR 0 6
67786: PUSH
67787: EMPTY
67788: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67789: LD_VAR 0 1
67793: PPUSH
67794: LD_VAR 0 2
67798: PPUSH
67799: LD_VAR 0 3
67803: PPUSH
67804: LD_VAR 0 4
67808: PPUSH
67809: LD_VAR 0 5
67813: PPUSH
67814: CALL_OW 448
67818: IFFALSE 67851
// result := [ chassis , engine , control , weapon ] ;
67820: LD_ADDR_VAR 0 6
67824: PUSH
67825: LD_VAR 0 2
67829: PUSH
67830: LD_VAR 0 3
67834: PUSH
67835: LD_VAR 0 4
67839: PUSH
67840: LD_VAR 0 5
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// end ;
67851: LD_VAR 0 6
67855: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67856: LD_INT 0
67858: PPUSH
// if not chassis or not engine then
67859: LD_VAR 0 1
67863: NOT
67864: PUSH
67865: LD_VAR 0 2
67869: NOT
67870: OR
67871: IFFALSE 67875
// exit ;
67873: GO 68071
// case engine of engine_solar :
67875: LD_VAR 0 2
67879: PUSH
67880: LD_INT 2
67882: DOUBLE
67883: EQUAL
67884: IFTRUE 67888
67886: GO 67926
67888: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67889: LD_ADDR_VAR 0 3
67893: PUSH
67894: LD_INT 11
67896: PUSH
67897: LD_INT 12
67899: PUSH
67900: LD_INT 13
67902: PUSH
67903: LD_INT 14
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: LD_INT 2
67911: PUSH
67912: LD_INT 3
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: ST_TO_ADDR
67924: GO 68055
67926: LD_INT 1
67928: DOUBLE
67929: EQUAL
67930: IFTRUE 67934
67932: GO 67996
67934: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67935: LD_ADDR_VAR 0 3
67939: PUSH
67940: LD_INT 11
67942: PUSH
67943: LD_INT 12
67945: PUSH
67946: LD_INT 13
67948: PUSH
67949: LD_INT 14
67951: PUSH
67952: LD_INT 1
67954: PUSH
67955: LD_INT 2
67957: PUSH
67958: LD_INT 3
67960: PUSH
67961: LD_INT 4
67963: PUSH
67964: LD_INT 5
67966: PUSH
67967: LD_INT 21
67969: PUSH
67970: LD_INT 23
67972: PUSH
67973: LD_INT 22
67975: PUSH
67976: LD_INT 24
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: ST_TO_ADDR
67994: GO 68055
67996: LD_INT 3
67998: DOUBLE
67999: EQUAL
68000: IFTRUE 68004
68002: GO 68054
68004: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68005: LD_ADDR_VAR 0 3
68009: PUSH
68010: LD_INT 13
68012: PUSH
68013: LD_INT 14
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: LD_INT 3
68021: PUSH
68022: LD_INT 4
68024: PUSH
68025: LD_INT 5
68027: PUSH
68028: LD_INT 21
68030: PUSH
68031: LD_INT 22
68033: PUSH
68034: LD_INT 23
68036: PUSH
68037: LD_INT 24
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: ST_TO_ADDR
68052: GO 68055
68054: POP
// result := ( chassis in result ) ;
68055: LD_ADDR_VAR 0 3
68059: PUSH
68060: LD_VAR 0 1
68064: PUSH
68065: LD_VAR 0 3
68069: IN
68070: ST_TO_ADDR
// end ;
68071: LD_VAR 0 3
68075: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68076: LD_INT 0
68078: PPUSH
// if not chassis or not weapon then
68079: LD_VAR 0 1
68083: NOT
68084: PUSH
68085: LD_VAR 0 2
68089: NOT
68090: OR
68091: IFFALSE 68095
// exit ;
68093: GO 69121
// case weapon of us_machine_gun :
68095: LD_VAR 0 2
68099: PUSH
68100: LD_INT 2
68102: DOUBLE
68103: EQUAL
68104: IFTRUE 68108
68106: GO 68138
68108: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68109: LD_ADDR_VAR 0 3
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: LD_INT 2
68119: PUSH
68120: LD_INT 3
68122: PUSH
68123: LD_INT 4
68125: PUSH
68126: LD_INT 5
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: ST_TO_ADDR
68136: GO 69105
68138: LD_INT 3
68140: DOUBLE
68141: EQUAL
68142: IFTRUE 68146
68144: GO 68176
68146: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68147: LD_ADDR_VAR 0 3
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: LD_INT 2
68157: PUSH
68158: LD_INT 3
68160: PUSH
68161: LD_INT 4
68163: PUSH
68164: LD_INT 5
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: ST_TO_ADDR
68174: GO 69105
68176: LD_INT 11
68178: DOUBLE
68179: EQUAL
68180: IFTRUE 68184
68182: GO 68214
68184: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68185: LD_ADDR_VAR 0 3
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: LD_INT 2
68195: PUSH
68196: LD_INT 3
68198: PUSH
68199: LD_INT 4
68201: PUSH
68202: LD_INT 5
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: ST_TO_ADDR
68212: GO 69105
68214: LD_INT 4
68216: DOUBLE
68217: EQUAL
68218: IFTRUE 68222
68220: GO 68248
68222: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68223: LD_ADDR_VAR 0 3
68227: PUSH
68228: LD_INT 2
68230: PUSH
68231: LD_INT 3
68233: PUSH
68234: LD_INT 4
68236: PUSH
68237: LD_INT 5
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: ST_TO_ADDR
68246: GO 69105
68248: LD_INT 5
68250: DOUBLE
68251: EQUAL
68252: IFTRUE 68256
68254: GO 68282
68256: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68257: LD_ADDR_VAR 0 3
68261: PUSH
68262: LD_INT 2
68264: PUSH
68265: LD_INT 3
68267: PUSH
68268: LD_INT 4
68270: PUSH
68271: LD_INT 5
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: ST_TO_ADDR
68280: GO 69105
68282: LD_INT 9
68284: DOUBLE
68285: EQUAL
68286: IFTRUE 68290
68288: GO 68316
68290: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68291: LD_ADDR_VAR 0 3
68295: PUSH
68296: LD_INT 2
68298: PUSH
68299: LD_INT 3
68301: PUSH
68302: LD_INT 4
68304: PUSH
68305: LD_INT 5
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: ST_TO_ADDR
68314: GO 69105
68316: LD_INT 7
68318: DOUBLE
68319: EQUAL
68320: IFTRUE 68324
68322: GO 68350
68324: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68325: LD_ADDR_VAR 0 3
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: LD_INT 3
68335: PUSH
68336: LD_INT 4
68338: PUSH
68339: LD_INT 5
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: ST_TO_ADDR
68348: GO 69105
68350: LD_INT 12
68352: DOUBLE
68353: EQUAL
68354: IFTRUE 68358
68356: GO 68384
68358: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68359: LD_ADDR_VAR 0 3
68363: PUSH
68364: LD_INT 2
68366: PUSH
68367: LD_INT 3
68369: PUSH
68370: LD_INT 4
68372: PUSH
68373: LD_INT 5
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: ST_TO_ADDR
68382: GO 69105
68384: LD_INT 13
68386: DOUBLE
68387: EQUAL
68388: IFTRUE 68392
68390: GO 68418
68392: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68393: LD_ADDR_VAR 0 3
68397: PUSH
68398: LD_INT 2
68400: PUSH
68401: LD_INT 3
68403: PUSH
68404: LD_INT 4
68406: PUSH
68407: LD_INT 5
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: ST_TO_ADDR
68416: GO 69105
68418: LD_INT 14
68420: DOUBLE
68421: EQUAL
68422: IFTRUE 68426
68424: GO 68444
68426: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68427: LD_ADDR_VAR 0 3
68431: PUSH
68432: LD_INT 4
68434: PUSH
68435: LD_INT 5
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: ST_TO_ADDR
68442: GO 69105
68444: LD_INT 6
68446: DOUBLE
68447: EQUAL
68448: IFTRUE 68452
68450: GO 68470
68452: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68453: LD_ADDR_VAR 0 3
68457: PUSH
68458: LD_INT 4
68460: PUSH
68461: LD_INT 5
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: ST_TO_ADDR
68468: GO 69105
68470: LD_INT 10
68472: DOUBLE
68473: EQUAL
68474: IFTRUE 68478
68476: GO 68496
68478: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68479: LD_ADDR_VAR 0 3
68483: PUSH
68484: LD_INT 4
68486: PUSH
68487: LD_INT 5
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: ST_TO_ADDR
68494: GO 69105
68496: LD_INT 22
68498: DOUBLE
68499: EQUAL
68500: IFTRUE 68504
68502: GO 68530
68504: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68505: LD_ADDR_VAR 0 3
68509: PUSH
68510: LD_INT 11
68512: PUSH
68513: LD_INT 12
68515: PUSH
68516: LD_INT 13
68518: PUSH
68519: LD_INT 14
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: ST_TO_ADDR
68528: GO 69105
68530: LD_INT 23
68532: DOUBLE
68533: EQUAL
68534: IFTRUE 68538
68536: GO 68564
68538: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68539: LD_ADDR_VAR 0 3
68543: PUSH
68544: LD_INT 11
68546: PUSH
68547: LD_INT 12
68549: PUSH
68550: LD_INT 13
68552: PUSH
68553: LD_INT 14
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: ST_TO_ADDR
68562: GO 69105
68564: LD_INT 24
68566: DOUBLE
68567: EQUAL
68568: IFTRUE 68572
68570: GO 68598
68572: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68573: LD_ADDR_VAR 0 3
68577: PUSH
68578: LD_INT 11
68580: PUSH
68581: LD_INT 12
68583: PUSH
68584: LD_INT 13
68586: PUSH
68587: LD_INT 14
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: ST_TO_ADDR
68596: GO 69105
68598: LD_INT 30
68600: DOUBLE
68601: EQUAL
68602: IFTRUE 68606
68604: GO 68632
68606: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68607: LD_ADDR_VAR 0 3
68611: PUSH
68612: LD_INT 11
68614: PUSH
68615: LD_INT 12
68617: PUSH
68618: LD_INT 13
68620: PUSH
68621: LD_INT 14
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: ST_TO_ADDR
68630: GO 69105
68632: LD_INT 25
68634: DOUBLE
68635: EQUAL
68636: IFTRUE 68640
68638: GO 68658
68640: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68641: LD_ADDR_VAR 0 3
68645: PUSH
68646: LD_INT 13
68648: PUSH
68649: LD_INT 14
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: ST_TO_ADDR
68656: GO 69105
68658: LD_INT 27
68660: DOUBLE
68661: EQUAL
68662: IFTRUE 68666
68664: GO 68684
68666: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68667: LD_ADDR_VAR 0 3
68671: PUSH
68672: LD_INT 13
68674: PUSH
68675: LD_INT 14
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: ST_TO_ADDR
68682: GO 69105
68684: LD_INT 28
68686: DOUBLE
68687: EQUAL
68688: IFTRUE 68692
68690: GO 68710
68692: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68693: LD_ADDR_VAR 0 3
68697: PUSH
68698: LD_INT 13
68700: PUSH
68701: LD_INT 14
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: ST_TO_ADDR
68708: GO 69105
68710: LD_INT 29
68712: DOUBLE
68713: EQUAL
68714: IFTRUE 68718
68716: GO 68736
68718: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68719: LD_ADDR_VAR 0 3
68723: PUSH
68724: LD_INT 13
68726: PUSH
68727: LD_INT 14
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: ST_TO_ADDR
68734: GO 69105
68736: LD_INT 31
68738: DOUBLE
68739: EQUAL
68740: IFTRUE 68744
68742: GO 68762
68744: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68745: LD_ADDR_VAR 0 3
68749: PUSH
68750: LD_INT 13
68752: PUSH
68753: LD_INT 14
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: ST_TO_ADDR
68760: GO 69105
68762: LD_INT 26
68764: DOUBLE
68765: EQUAL
68766: IFTRUE 68770
68768: GO 68788
68770: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68771: LD_ADDR_VAR 0 3
68775: PUSH
68776: LD_INT 13
68778: PUSH
68779: LD_INT 14
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: ST_TO_ADDR
68786: GO 69105
68788: LD_INT 42
68790: DOUBLE
68791: EQUAL
68792: IFTRUE 68796
68794: GO 68822
68796: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68797: LD_ADDR_VAR 0 3
68801: PUSH
68802: LD_INT 21
68804: PUSH
68805: LD_INT 22
68807: PUSH
68808: LD_INT 23
68810: PUSH
68811: LD_INT 24
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: LIST
68818: LIST
68819: ST_TO_ADDR
68820: GO 69105
68822: LD_INT 43
68824: DOUBLE
68825: EQUAL
68826: IFTRUE 68830
68828: GO 68856
68830: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68831: LD_ADDR_VAR 0 3
68835: PUSH
68836: LD_INT 21
68838: PUSH
68839: LD_INT 22
68841: PUSH
68842: LD_INT 23
68844: PUSH
68845: LD_INT 24
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: ST_TO_ADDR
68854: GO 69105
68856: LD_INT 44
68858: DOUBLE
68859: EQUAL
68860: IFTRUE 68864
68862: GO 68890
68864: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68865: LD_ADDR_VAR 0 3
68869: PUSH
68870: LD_INT 21
68872: PUSH
68873: LD_INT 22
68875: PUSH
68876: LD_INT 23
68878: PUSH
68879: LD_INT 24
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: ST_TO_ADDR
68888: GO 69105
68890: LD_INT 45
68892: DOUBLE
68893: EQUAL
68894: IFTRUE 68898
68896: GO 68924
68898: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68899: LD_ADDR_VAR 0 3
68903: PUSH
68904: LD_INT 21
68906: PUSH
68907: LD_INT 22
68909: PUSH
68910: LD_INT 23
68912: PUSH
68913: LD_INT 24
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: ST_TO_ADDR
68922: GO 69105
68924: LD_INT 49
68926: DOUBLE
68927: EQUAL
68928: IFTRUE 68932
68930: GO 68958
68932: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68933: LD_ADDR_VAR 0 3
68937: PUSH
68938: LD_INT 21
68940: PUSH
68941: LD_INT 22
68943: PUSH
68944: LD_INT 23
68946: PUSH
68947: LD_INT 24
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: ST_TO_ADDR
68956: GO 69105
68958: LD_INT 51
68960: DOUBLE
68961: EQUAL
68962: IFTRUE 68966
68964: GO 68992
68966: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68967: LD_ADDR_VAR 0 3
68971: PUSH
68972: LD_INT 21
68974: PUSH
68975: LD_INT 22
68977: PUSH
68978: LD_INT 23
68980: PUSH
68981: LD_INT 24
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: ST_TO_ADDR
68990: GO 69105
68992: LD_INT 52
68994: DOUBLE
68995: EQUAL
68996: IFTRUE 69000
68998: GO 69026
69000: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69001: LD_ADDR_VAR 0 3
69005: PUSH
69006: LD_INT 21
69008: PUSH
69009: LD_INT 22
69011: PUSH
69012: LD_INT 23
69014: PUSH
69015: LD_INT 24
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: ST_TO_ADDR
69024: GO 69105
69026: LD_INT 53
69028: DOUBLE
69029: EQUAL
69030: IFTRUE 69034
69032: GO 69052
69034: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69035: LD_ADDR_VAR 0 3
69039: PUSH
69040: LD_INT 23
69042: PUSH
69043: LD_INT 24
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: ST_TO_ADDR
69050: GO 69105
69052: LD_INT 46
69054: DOUBLE
69055: EQUAL
69056: IFTRUE 69060
69058: GO 69078
69060: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69061: LD_ADDR_VAR 0 3
69065: PUSH
69066: LD_INT 23
69068: PUSH
69069: LD_INT 24
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: ST_TO_ADDR
69076: GO 69105
69078: LD_INT 47
69080: DOUBLE
69081: EQUAL
69082: IFTRUE 69086
69084: GO 69104
69086: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69087: LD_ADDR_VAR 0 3
69091: PUSH
69092: LD_INT 23
69094: PUSH
69095: LD_INT 24
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: ST_TO_ADDR
69102: GO 69105
69104: POP
// result := ( chassis in result ) ;
69105: LD_ADDR_VAR 0 3
69109: PUSH
69110: LD_VAR 0 1
69114: PUSH
69115: LD_VAR 0 3
69119: IN
69120: ST_TO_ADDR
// end ;
69121: LD_VAR 0 3
69125: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69126: LD_INT 0
69128: PPUSH
69129: PPUSH
69130: PPUSH
69131: PPUSH
69132: PPUSH
69133: PPUSH
69134: PPUSH
// result := array ;
69135: LD_ADDR_VAR 0 5
69139: PUSH
69140: LD_VAR 0 1
69144: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69145: LD_VAR 0 1
69149: NOT
69150: PUSH
69151: LD_VAR 0 2
69155: NOT
69156: OR
69157: PUSH
69158: LD_VAR 0 3
69162: NOT
69163: OR
69164: PUSH
69165: LD_VAR 0 2
69169: PUSH
69170: LD_VAR 0 1
69174: GREATER
69175: OR
69176: PUSH
69177: LD_VAR 0 3
69181: PUSH
69182: LD_VAR 0 1
69186: GREATER
69187: OR
69188: IFFALSE 69192
// exit ;
69190: GO 69488
// if direction then
69192: LD_VAR 0 4
69196: IFFALSE 69260
// begin d := 1 ;
69198: LD_ADDR_VAR 0 9
69202: PUSH
69203: LD_INT 1
69205: ST_TO_ADDR
// if i_from > i_to then
69206: LD_VAR 0 2
69210: PUSH
69211: LD_VAR 0 3
69215: GREATER
69216: IFFALSE 69242
// length := ( array - i_from ) + i_to else
69218: LD_ADDR_VAR 0 11
69222: PUSH
69223: LD_VAR 0 1
69227: PUSH
69228: LD_VAR 0 2
69232: MINUS
69233: PUSH
69234: LD_VAR 0 3
69238: PLUS
69239: ST_TO_ADDR
69240: GO 69258
// length := i_to - i_from ;
69242: LD_ADDR_VAR 0 11
69246: PUSH
69247: LD_VAR 0 3
69251: PUSH
69252: LD_VAR 0 2
69256: MINUS
69257: ST_TO_ADDR
// end else
69258: GO 69321
// begin d := - 1 ;
69260: LD_ADDR_VAR 0 9
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: ST_TO_ADDR
// if i_from > i_to then
69269: LD_VAR 0 2
69273: PUSH
69274: LD_VAR 0 3
69278: GREATER
69279: IFFALSE 69299
// length := i_from - i_to else
69281: LD_ADDR_VAR 0 11
69285: PUSH
69286: LD_VAR 0 2
69290: PUSH
69291: LD_VAR 0 3
69295: MINUS
69296: ST_TO_ADDR
69297: GO 69321
// length := ( array - i_to ) + i_from ;
69299: LD_ADDR_VAR 0 11
69303: PUSH
69304: LD_VAR 0 1
69308: PUSH
69309: LD_VAR 0 3
69313: MINUS
69314: PUSH
69315: LD_VAR 0 2
69319: PLUS
69320: ST_TO_ADDR
// end ; if not length then
69321: LD_VAR 0 11
69325: NOT
69326: IFFALSE 69330
// exit ;
69328: GO 69488
// tmp := array ;
69330: LD_ADDR_VAR 0 10
69334: PUSH
69335: LD_VAR 0 1
69339: ST_TO_ADDR
// for i = 1 to length do
69340: LD_ADDR_VAR 0 6
69344: PUSH
69345: DOUBLE
69346: LD_INT 1
69348: DEC
69349: ST_TO_ADDR
69350: LD_VAR 0 11
69354: PUSH
69355: FOR_TO
69356: IFFALSE 69476
// begin for j = 1 to array do
69358: LD_ADDR_VAR 0 7
69362: PUSH
69363: DOUBLE
69364: LD_INT 1
69366: DEC
69367: ST_TO_ADDR
69368: LD_VAR 0 1
69372: PUSH
69373: FOR_TO
69374: IFFALSE 69462
// begin k := j + d ;
69376: LD_ADDR_VAR 0 8
69380: PUSH
69381: LD_VAR 0 7
69385: PUSH
69386: LD_VAR 0 9
69390: PLUS
69391: ST_TO_ADDR
// if k > array then
69392: LD_VAR 0 8
69396: PUSH
69397: LD_VAR 0 1
69401: GREATER
69402: IFFALSE 69412
// k := 1 ;
69404: LD_ADDR_VAR 0 8
69408: PUSH
69409: LD_INT 1
69411: ST_TO_ADDR
// if not k then
69412: LD_VAR 0 8
69416: NOT
69417: IFFALSE 69429
// k := array ;
69419: LD_ADDR_VAR 0 8
69423: PUSH
69424: LD_VAR 0 1
69428: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69429: LD_ADDR_VAR 0 10
69433: PUSH
69434: LD_VAR 0 10
69438: PPUSH
69439: LD_VAR 0 8
69443: PPUSH
69444: LD_VAR 0 1
69448: PUSH
69449: LD_VAR 0 7
69453: ARRAY
69454: PPUSH
69455: CALL_OW 1
69459: ST_TO_ADDR
// end ;
69460: GO 69373
69462: POP
69463: POP
// array := tmp ;
69464: LD_ADDR_VAR 0 1
69468: PUSH
69469: LD_VAR 0 10
69473: ST_TO_ADDR
// end ;
69474: GO 69355
69476: POP
69477: POP
// result := array ;
69478: LD_ADDR_VAR 0 5
69482: PUSH
69483: LD_VAR 0 1
69487: ST_TO_ADDR
// end ;
69488: LD_VAR 0 5
69492: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69493: LD_INT 0
69495: PPUSH
69496: PPUSH
// result := 0 ;
69497: LD_ADDR_VAR 0 3
69501: PUSH
69502: LD_INT 0
69504: ST_TO_ADDR
// if not array or not value in array then
69505: LD_VAR 0 1
69509: NOT
69510: PUSH
69511: LD_VAR 0 2
69515: PUSH
69516: LD_VAR 0 1
69520: IN
69521: NOT
69522: OR
69523: IFFALSE 69527
// exit ;
69525: GO 69581
// for i = 1 to array do
69527: LD_ADDR_VAR 0 4
69531: PUSH
69532: DOUBLE
69533: LD_INT 1
69535: DEC
69536: ST_TO_ADDR
69537: LD_VAR 0 1
69541: PUSH
69542: FOR_TO
69543: IFFALSE 69579
// if value = array [ i ] then
69545: LD_VAR 0 2
69549: PUSH
69550: LD_VAR 0 1
69554: PUSH
69555: LD_VAR 0 4
69559: ARRAY
69560: EQUAL
69561: IFFALSE 69577
// begin result := i ;
69563: LD_ADDR_VAR 0 3
69567: PUSH
69568: LD_VAR 0 4
69572: ST_TO_ADDR
// exit ;
69573: POP
69574: POP
69575: GO 69581
// end ;
69577: GO 69542
69579: POP
69580: POP
// end ;
69581: LD_VAR 0 3
69585: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69586: LD_INT 0
69588: PPUSH
// vc_chassis := chassis ;
69589: LD_ADDR_OWVAR 37
69593: PUSH
69594: LD_VAR 0 1
69598: ST_TO_ADDR
// vc_engine := engine ;
69599: LD_ADDR_OWVAR 39
69603: PUSH
69604: LD_VAR 0 2
69608: ST_TO_ADDR
// vc_control := control ;
69609: LD_ADDR_OWVAR 38
69613: PUSH
69614: LD_VAR 0 3
69618: ST_TO_ADDR
// vc_weapon := weapon ;
69619: LD_ADDR_OWVAR 40
69623: PUSH
69624: LD_VAR 0 4
69628: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69629: LD_ADDR_OWVAR 41
69633: PUSH
69634: LD_VAR 0 5
69638: ST_TO_ADDR
// end ;
69639: LD_VAR 0 6
69643: RET
// export function WantPlant ( unit ) ; var task ; begin
69644: LD_INT 0
69646: PPUSH
69647: PPUSH
// result := false ;
69648: LD_ADDR_VAR 0 2
69652: PUSH
69653: LD_INT 0
69655: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69656: LD_ADDR_VAR 0 3
69660: PUSH
69661: LD_VAR 0 1
69665: PPUSH
69666: CALL_OW 437
69670: ST_TO_ADDR
// if task then
69671: LD_VAR 0 3
69675: IFFALSE 69703
// if task [ 1 ] [ 1 ] = p then
69677: LD_VAR 0 3
69681: PUSH
69682: LD_INT 1
69684: ARRAY
69685: PUSH
69686: LD_INT 1
69688: ARRAY
69689: PUSH
69690: LD_STRING p
69692: EQUAL
69693: IFFALSE 69703
// result := true ;
69695: LD_ADDR_VAR 0 2
69699: PUSH
69700: LD_INT 1
69702: ST_TO_ADDR
// end ;
69703: LD_VAR 0 2
69707: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69708: LD_INT 0
69710: PPUSH
69711: PPUSH
69712: PPUSH
69713: PPUSH
// if pos < 1 then
69714: LD_VAR 0 2
69718: PUSH
69719: LD_INT 1
69721: LESS
69722: IFFALSE 69726
// exit ;
69724: GO 70029
// if pos = 1 then
69726: LD_VAR 0 2
69730: PUSH
69731: LD_INT 1
69733: EQUAL
69734: IFFALSE 69767
// result := Replace ( arr , pos [ 1 ] , value ) else
69736: LD_ADDR_VAR 0 4
69740: PUSH
69741: LD_VAR 0 1
69745: PPUSH
69746: LD_VAR 0 2
69750: PUSH
69751: LD_INT 1
69753: ARRAY
69754: PPUSH
69755: LD_VAR 0 3
69759: PPUSH
69760: CALL_OW 1
69764: ST_TO_ADDR
69765: GO 70029
// begin tmp := arr ;
69767: LD_ADDR_VAR 0 6
69771: PUSH
69772: LD_VAR 0 1
69776: ST_TO_ADDR
// s_arr := [ tmp ] ;
69777: LD_ADDR_VAR 0 7
69781: PUSH
69782: LD_VAR 0 6
69786: PUSH
69787: EMPTY
69788: LIST
69789: ST_TO_ADDR
// for i = 1 to pos - 1 do
69790: LD_ADDR_VAR 0 5
69794: PUSH
69795: DOUBLE
69796: LD_INT 1
69798: DEC
69799: ST_TO_ADDR
69800: LD_VAR 0 2
69804: PUSH
69805: LD_INT 1
69807: MINUS
69808: PUSH
69809: FOR_TO
69810: IFFALSE 69855
// begin tmp := tmp [ pos [ i ] ] ;
69812: LD_ADDR_VAR 0 6
69816: PUSH
69817: LD_VAR 0 6
69821: PUSH
69822: LD_VAR 0 2
69826: PUSH
69827: LD_VAR 0 5
69831: ARRAY
69832: ARRAY
69833: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69834: LD_ADDR_VAR 0 7
69838: PUSH
69839: LD_VAR 0 7
69843: PUSH
69844: LD_VAR 0 6
69848: PUSH
69849: EMPTY
69850: LIST
69851: ADD
69852: ST_TO_ADDR
// end ;
69853: GO 69809
69855: POP
69856: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69857: LD_ADDR_VAR 0 6
69861: PUSH
69862: LD_VAR 0 6
69866: PPUSH
69867: LD_VAR 0 2
69871: PUSH
69872: LD_VAR 0 2
69876: ARRAY
69877: PPUSH
69878: LD_VAR 0 3
69882: PPUSH
69883: CALL_OW 1
69887: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69888: LD_ADDR_VAR 0 7
69892: PUSH
69893: LD_VAR 0 7
69897: PPUSH
69898: LD_VAR 0 7
69902: PPUSH
69903: LD_VAR 0 6
69907: PPUSH
69908: CALL_OW 1
69912: ST_TO_ADDR
// for i = s_arr downto 2 do
69913: LD_ADDR_VAR 0 5
69917: PUSH
69918: DOUBLE
69919: LD_VAR 0 7
69923: INC
69924: ST_TO_ADDR
69925: LD_INT 2
69927: PUSH
69928: FOR_DOWNTO
69929: IFFALSE 70013
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69931: LD_ADDR_VAR 0 6
69935: PUSH
69936: LD_VAR 0 7
69940: PUSH
69941: LD_VAR 0 5
69945: PUSH
69946: LD_INT 1
69948: MINUS
69949: ARRAY
69950: PPUSH
69951: LD_VAR 0 2
69955: PUSH
69956: LD_VAR 0 5
69960: PUSH
69961: LD_INT 1
69963: MINUS
69964: ARRAY
69965: PPUSH
69966: LD_VAR 0 7
69970: PUSH
69971: LD_VAR 0 5
69975: ARRAY
69976: PPUSH
69977: CALL_OW 1
69981: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69982: LD_ADDR_VAR 0 7
69986: PUSH
69987: LD_VAR 0 7
69991: PPUSH
69992: LD_VAR 0 5
69996: PUSH
69997: LD_INT 1
69999: MINUS
70000: PPUSH
70001: LD_VAR 0 6
70005: PPUSH
70006: CALL_OW 1
70010: ST_TO_ADDR
// end ;
70011: GO 69928
70013: POP
70014: POP
// result := s_arr [ 1 ] ;
70015: LD_ADDR_VAR 0 4
70019: PUSH
70020: LD_VAR 0 7
70024: PUSH
70025: LD_INT 1
70027: ARRAY
70028: ST_TO_ADDR
// end ; end ;
70029: LD_VAR 0 4
70033: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70034: LD_INT 0
70036: PPUSH
70037: PPUSH
// if not list then
70038: LD_VAR 0 1
70042: NOT
70043: IFFALSE 70047
// exit ;
70045: GO 70138
// i := list [ pos1 ] ;
70047: LD_ADDR_VAR 0 5
70051: PUSH
70052: LD_VAR 0 1
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: ST_TO_ADDR
// if not i then
70063: LD_VAR 0 5
70067: NOT
70068: IFFALSE 70072
// exit ;
70070: GO 70138
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70072: LD_ADDR_VAR 0 1
70076: PUSH
70077: LD_VAR 0 1
70081: PPUSH
70082: LD_VAR 0 2
70086: PPUSH
70087: LD_VAR 0 1
70091: PUSH
70092: LD_VAR 0 3
70096: ARRAY
70097: PPUSH
70098: CALL_OW 1
70102: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70103: LD_ADDR_VAR 0 1
70107: PUSH
70108: LD_VAR 0 1
70112: PPUSH
70113: LD_VAR 0 3
70117: PPUSH
70118: LD_VAR 0 5
70122: PPUSH
70123: CALL_OW 1
70127: ST_TO_ADDR
// result := list ;
70128: LD_ADDR_VAR 0 4
70132: PUSH
70133: LD_VAR 0 1
70137: ST_TO_ADDR
// end ;
70138: LD_VAR 0 4
70142: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70143: LD_INT 0
70145: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70146: LD_ADDR_VAR 0 5
70150: PUSH
70151: LD_VAR 0 1
70155: PPUSH
70156: CALL_OW 250
70160: PPUSH
70161: LD_VAR 0 1
70165: PPUSH
70166: CALL_OW 251
70170: PPUSH
70171: LD_VAR 0 2
70175: PPUSH
70176: LD_VAR 0 3
70180: PPUSH
70181: LD_VAR 0 4
70185: PPUSH
70186: CALL 70196 0 5
70190: ST_TO_ADDR
// end ;
70191: LD_VAR 0 5
70195: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70196: LD_INT 0
70198: PPUSH
70199: PPUSH
70200: PPUSH
70201: PPUSH
// if not list then
70202: LD_VAR 0 3
70206: NOT
70207: IFFALSE 70211
// exit ;
70209: GO 70599
// result := [ ] ;
70211: LD_ADDR_VAR 0 6
70215: PUSH
70216: EMPTY
70217: ST_TO_ADDR
// for i in list do
70218: LD_ADDR_VAR 0 7
70222: PUSH
70223: LD_VAR 0 3
70227: PUSH
70228: FOR_IN
70229: IFFALSE 70431
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70231: LD_ADDR_VAR 0 9
70235: PUSH
70236: LD_VAR 0 7
70240: PPUSH
70241: LD_VAR 0 1
70245: PPUSH
70246: LD_VAR 0 2
70250: PPUSH
70251: CALL_OW 297
70255: ST_TO_ADDR
// if not result then
70256: LD_VAR 0 6
70260: NOT
70261: IFFALSE 70287
// result := [ [ i , tmp ] ] else
70263: LD_ADDR_VAR 0 6
70267: PUSH
70268: LD_VAR 0 7
70272: PUSH
70273: LD_VAR 0 9
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: EMPTY
70283: LIST
70284: ST_TO_ADDR
70285: GO 70429
// begin if result [ result ] [ 2 ] < tmp then
70287: LD_VAR 0 6
70291: PUSH
70292: LD_VAR 0 6
70296: ARRAY
70297: PUSH
70298: LD_INT 2
70300: ARRAY
70301: PUSH
70302: LD_VAR 0 9
70306: LESS
70307: IFFALSE 70349
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70309: LD_ADDR_VAR 0 6
70313: PUSH
70314: LD_VAR 0 6
70318: PPUSH
70319: LD_VAR 0 6
70323: PUSH
70324: LD_INT 1
70326: PLUS
70327: PPUSH
70328: LD_VAR 0 7
70332: PUSH
70333: LD_VAR 0 9
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PPUSH
70342: CALL_OW 2
70346: ST_TO_ADDR
70347: GO 70429
// for j = 1 to result do
70349: LD_ADDR_VAR 0 8
70353: PUSH
70354: DOUBLE
70355: LD_INT 1
70357: DEC
70358: ST_TO_ADDR
70359: LD_VAR 0 6
70363: PUSH
70364: FOR_TO
70365: IFFALSE 70427
// begin if tmp < result [ j ] [ 2 ] then
70367: LD_VAR 0 9
70371: PUSH
70372: LD_VAR 0 6
70376: PUSH
70377: LD_VAR 0 8
70381: ARRAY
70382: PUSH
70383: LD_INT 2
70385: ARRAY
70386: LESS
70387: IFFALSE 70425
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70389: LD_ADDR_VAR 0 6
70393: PUSH
70394: LD_VAR 0 6
70398: PPUSH
70399: LD_VAR 0 8
70403: PPUSH
70404: LD_VAR 0 7
70408: PUSH
70409: LD_VAR 0 9
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PPUSH
70418: CALL_OW 2
70422: ST_TO_ADDR
// break ;
70423: GO 70427
// end ; end ;
70425: GO 70364
70427: POP
70428: POP
// end ; end ;
70429: GO 70228
70431: POP
70432: POP
// if result and not asc then
70433: LD_VAR 0 6
70437: PUSH
70438: LD_VAR 0 4
70442: NOT
70443: AND
70444: IFFALSE 70519
// begin tmp := result ;
70446: LD_ADDR_VAR 0 9
70450: PUSH
70451: LD_VAR 0 6
70455: ST_TO_ADDR
// for i = tmp downto 1 do
70456: LD_ADDR_VAR 0 7
70460: PUSH
70461: DOUBLE
70462: LD_VAR 0 9
70466: INC
70467: ST_TO_ADDR
70468: LD_INT 1
70470: PUSH
70471: FOR_DOWNTO
70472: IFFALSE 70517
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70474: LD_ADDR_VAR 0 6
70478: PUSH
70479: LD_VAR 0 6
70483: PPUSH
70484: LD_VAR 0 9
70488: PUSH
70489: LD_VAR 0 7
70493: MINUS
70494: PUSH
70495: LD_INT 1
70497: PLUS
70498: PPUSH
70499: LD_VAR 0 9
70503: PUSH
70504: LD_VAR 0 7
70508: ARRAY
70509: PPUSH
70510: CALL_OW 1
70514: ST_TO_ADDR
70515: GO 70471
70517: POP
70518: POP
// end ; tmp := [ ] ;
70519: LD_ADDR_VAR 0 9
70523: PUSH
70524: EMPTY
70525: ST_TO_ADDR
// if mode then
70526: LD_VAR 0 5
70530: IFFALSE 70599
// begin for i = 1 to result do
70532: LD_ADDR_VAR 0 7
70536: PUSH
70537: DOUBLE
70538: LD_INT 1
70540: DEC
70541: ST_TO_ADDR
70542: LD_VAR 0 6
70546: PUSH
70547: FOR_TO
70548: IFFALSE 70587
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70550: LD_ADDR_VAR 0 9
70554: PUSH
70555: LD_VAR 0 9
70559: PPUSH
70560: LD_VAR 0 7
70564: PPUSH
70565: LD_VAR 0 6
70569: PUSH
70570: LD_VAR 0 7
70574: ARRAY
70575: PUSH
70576: LD_INT 1
70578: ARRAY
70579: PPUSH
70580: CALL_OW 1
70584: ST_TO_ADDR
70585: GO 70547
70587: POP
70588: POP
// result := tmp ;
70589: LD_ADDR_VAR 0 6
70593: PUSH
70594: LD_VAR 0 9
70598: ST_TO_ADDR
// end ; end ;
70599: LD_VAR 0 6
70603: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70604: LD_INT 0
70606: PPUSH
70607: PPUSH
70608: PPUSH
70609: PPUSH
70610: PPUSH
70611: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70612: LD_ADDR_VAR 0 5
70616: PUSH
70617: LD_INT 0
70619: PUSH
70620: LD_INT 0
70622: PUSH
70623: LD_INT 0
70625: PUSH
70626: EMPTY
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: ST_TO_ADDR
// if not x or not y then
70634: LD_VAR 0 2
70638: NOT
70639: PUSH
70640: LD_VAR 0 3
70644: NOT
70645: OR
70646: IFFALSE 70650
// exit ;
70648: GO 72296
// if not range then
70650: LD_VAR 0 4
70654: NOT
70655: IFFALSE 70665
// range := 10 ;
70657: LD_ADDR_VAR 0 4
70661: PUSH
70662: LD_INT 10
70664: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70665: LD_ADDR_VAR 0 8
70669: PUSH
70670: LD_INT 81
70672: PUSH
70673: LD_VAR 0 1
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 92
70684: PUSH
70685: LD_VAR 0 2
70689: PUSH
70690: LD_VAR 0 3
70694: PUSH
70695: LD_VAR 0 4
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 3
70708: PUSH
70709: LD_INT 21
70711: PUSH
70712: LD_INT 3
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: LIST
70727: PPUSH
70728: CALL_OW 69
70732: ST_TO_ADDR
// if not tmp then
70733: LD_VAR 0 8
70737: NOT
70738: IFFALSE 70742
// exit ;
70740: GO 72296
// for i in tmp do
70742: LD_ADDR_VAR 0 6
70746: PUSH
70747: LD_VAR 0 8
70751: PUSH
70752: FOR_IN
70753: IFFALSE 72271
// begin points := [ 0 , 0 , 0 ] ;
70755: LD_ADDR_VAR 0 9
70759: PUSH
70760: LD_INT 0
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: LD_INT 0
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: LIST
70773: ST_TO_ADDR
// bpoints := 1 ;
70774: LD_ADDR_VAR 0 10
70778: PUSH
70779: LD_INT 1
70781: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70782: LD_VAR 0 6
70786: PPUSH
70787: CALL_OW 247
70791: PUSH
70792: LD_INT 1
70794: DOUBLE
70795: EQUAL
70796: IFTRUE 70800
70798: GO 71378
70800: POP
// begin if GetClass ( i ) = 1 then
70801: LD_VAR 0 6
70805: PPUSH
70806: CALL_OW 257
70810: PUSH
70811: LD_INT 1
70813: EQUAL
70814: IFFALSE 70835
// points := [ 10 , 5 , 3 ] ;
70816: LD_ADDR_VAR 0 9
70820: PUSH
70821: LD_INT 10
70823: PUSH
70824: LD_INT 5
70826: PUSH
70827: LD_INT 3
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: LIST
70834: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70835: LD_VAR 0 6
70839: PPUSH
70840: CALL_OW 257
70844: PUSH
70845: LD_INT 2
70847: PUSH
70848: LD_INT 3
70850: PUSH
70851: LD_INT 4
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: LIST
70858: IN
70859: IFFALSE 70880
// points := [ 3 , 2 , 1 ] ;
70861: LD_ADDR_VAR 0 9
70865: PUSH
70866: LD_INT 3
70868: PUSH
70869: LD_INT 2
70871: PUSH
70872: LD_INT 1
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: LIST
70879: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70880: LD_VAR 0 6
70884: PPUSH
70885: CALL_OW 257
70889: PUSH
70890: LD_INT 5
70892: EQUAL
70893: IFFALSE 70914
// points := [ 130 , 5 , 2 ] ;
70895: LD_ADDR_VAR 0 9
70899: PUSH
70900: LD_INT 130
70902: PUSH
70903: LD_INT 5
70905: PUSH
70906: LD_INT 2
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: LIST
70913: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70914: LD_VAR 0 6
70918: PPUSH
70919: CALL_OW 257
70923: PUSH
70924: LD_INT 8
70926: EQUAL
70927: IFFALSE 70948
// points := [ 35 , 35 , 30 ] ;
70929: LD_ADDR_VAR 0 9
70933: PUSH
70934: LD_INT 35
70936: PUSH
70937: LD_INT 35
70939: PUSH
70940: LD_INT 30
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: LIST
70947: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70948: LD_VAR 0 6
70952: PPUSH
70953: CALL_OW 257
70957: PUSH
70958: LD_INT 9
70960: EQUAL
70961: IFFALSE 70982
// points := [ 20 , 55 , 40 ] ;
70963: LD_ADDR_VAR 0 9
70967: PUSH
70968: LD_INT 20
70970: PUSH
70971: LD_INT 55
70973: PUSH
70974: LD_INT 40
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: LIST
70981: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70982: LD_VAR 0 6
70986: PPUSH
70987: CALL_OW 257
70991: PUSH
70992: LD_INT 12
70994: PUSH
70995: LD_INT 16
70997: PUSH
70998: EMPTY
70999: LIST
71000: LIST
71001: IN
71002: IFFALSE 71023
// points := [ 5 , 3 , 2 ] ;
71004: LD_ADDR_VAR 0 9
71008: PUSH
71009: LD_INT 5
71011: PUSH
71012: LD_INT 3
71014: PUSH
71015: LD_INT 2
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: LIST
71022: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71023: LD_VAR 0 6
71027: PPUSH
71028: CALL_OW 257
71032: PUSH
71033: LD_INT 17
71035: EQUAL
71036: IFFALSE 71057
// points := [ 100 , 50 , 75 ] ;
71038: LD_ADDR_VAR 0 9
71042: PUSH
71043: LD_INT 100
71045: PUSH
71046: LD_INT 50
71048: PUSH
71049: LD_INT 75
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: LIST
71056: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71057: LD_VAR 0 6
71061: PPUSH
71062: CALL_OW 257
71066: PUSH
71067: LD_INT 15
71069: EQUAL
71070: IFFALSE 71091
// points := [ 10 , 5 , 3 ] ;
71072: LD_ADDR_VAR 0 9
71076: PUSH
71077: LD_INT 10
71079: PUSH
71080: LD_INT 5
71082: PUSH
71083: LD_INT 3
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: LIST
71090: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71091: LD_VAR 0 6
71095: PPUSH
71096: CALL_OW 257
71100: PUSH
71101: LD_INT 14
71103: EQUAL
71104: IFFALSE 71125
// points := [ 10 , 0 , 0 ] ;
71106: LD_ADDR_VAR 0 9
71110: PUSH
71111: LD_INT 10
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: LD_INT 0
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: LIST
71124: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71125: LD_VAR 0 6
71129: PPUSH
71130: CALL_OW 257
71134: PUSH
71135: LD_INT 11
71137: EQUAL
71138: IFFALSE 71159
// points := [ 30 , 10 , 5 ] ;
71140: LD_ADDR_VAR 0 9
71144: PUSH
71145: LD_INT 30
71147: PUSH
71148: LD_INT 10
71150: PUSH
71151: LD_INT 5
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: LIST
71158: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71159: LD_VAR 0 1
71163: PPUSH
71164: LD_INT 5
71166: PPUSH
71167: CALL_OW 321
71171: PUSH
71172: LD_INT 2
71174: EQUAL
71175: IFFALSE 71192
// bpoints := bpoints * 1.8 ;
71177: LD_ADDR_VAR 0 10
71181: PUSH
71182: LD_VAR 0 10
71186: PUSH
71187: LD_REAL  1.80000000000000E+0000
71190: MUL
71191: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71192: LD_VAR 0 6
71196: PPUSH
71197: CALL_OW 257
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: LD_INT 3
71210: PUSH
71211: LD_INT 4
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: IN
71220: PUSH
71221: LD_VAR 0 1
71225: PPUSH
71226: LD_INT 51
71228: PPUSH
71229: CALL_OW 321
71233: PUSH
71234: LD_INT 2
71236: EQUAL
71237: AND
71238: IFFALSE 71255
// bpoints := bpoints * 1.2 ;
71240: LD_ADDR_VAR 0 10
71244: PUSH
71245: LD_VAR 0 10
71249: PUSH
71250: LD_REAL  1.20000000000000E+0000
71253: MUL
71254: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71255: LD_VAR 0 6
71259: PPUSH
71260: CALL_OW 257
71264: PUSH
71265: LD_INT 5
71267: PUSH
71268: LD_INT 7
71270: PUSH
71271: LD_INT 9
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: LIST
71278: IN
71279: PUSH
71280: LD_VAR 0 1
71284: PPUSH
71285: LD_INT 52
71287: PPUSH
71288: CALL_OW 321
71292: PUSH
71293: LD_INT 2
71295: EQUAL
71296: AND
71297: IFFALSE 71314
// bpoints := bpoints * 1.5 ;
71299: LD_ADDR_VAR 0 10
71303: PUSH
71304: LD_VAR 0 10
71308: PUSH
71309: LD_REAL  1.50000000000000E+0000
71312: MUL
71313: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71314: LD_VAR 0 1
71318: PPUSH
71319: LD_INT 66
71321: PPUSH
71322: CALL_OW 321
71326: PUSH
71327: LD_INT 2
71329: EQUAL
71330: IFFALSE 71347
// bpoints := bpoints * 1.1 ;
71332: LD_ADDR_VAR 0 10
71336: PUSH
71337: LD_VAR 0 10
71341: PUSH
71342: LD_REAL  1.10000000000000E+0000
71345: MUL
71346: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71347: LD_ADDR_VAR 0 10
71351: PUSH
71352: LD_VAR 0 10
71356: PUSH
71357: LD_VAR 0 6
71361: PPUSH
71362: LD_INT 1
71364: PPUSH
71365: CALL_OW 259
71369: PUSH
71370: LD_REAL  1.15000000000000E+0000
71373: MUL
71374: MUL
71375: ST_TO_ADDR
// end ; unit_vehicle :
71376: GO 72200
71378: LD_INT 2
71380: DOUBLE
71381: EQUAL
71382: IFTRUE 71386
71384: GO 72188
71386: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71387: LD_VAR 0 6
71391: PPUSH
71392: CALL_OW 264
71396: PUSH
71397: LD_INT 2
71399: PUSH
71400: LD_INT 42
71402: PUSH
71403: LD_INT 24
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: LIST
71410: IN
71411: IFFALSE 71432
// points := [ 25 , 5 , 3 ] ;
71413: LD_ADDR_VAR 0 9
71417: PUSH
71418: LD_INT 25
71420: PUSH
71421: LD_INT 5
71423: PUSH
71424: LD_INT 3
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: LIST
71431: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71432: LD_VAR 0 6
71436: PPUSH
71437: CALL_OW 264
71441: PUSH
71442: LD_INT 4
71444: PUSH
71445: LD_INT 43
71447: PUSH
71448: LD_INT 25
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: LIST
71455: IN
71456: IFFALSE 71477
// points := [ 40 , 15 , 5 ] ;
71458: LD_ADDR_VAR 0 9
71462: PUSH
71463: LD_INT 40
71465: PUSH
71466: LD_INT 15
71468: PUSH
71469: LD_INT 5
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: LIST
71476: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71477: LD_VAR 0 6
71481: PPUSH
71482: CALL_OW 264
71486: PUSH
71487: LD_INT 3
71489: PUSH
71490: LD_INT 23
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: IN
71497: IFFALSE 71518
// points := [ 7 , 25 , 8 ] ;
71499: LD_ADDR_VAR 0 9
71503: PUSH
71504: LD_INT 7
71506: PUSH
71507: LD_INT 25
71509: PUSH
71510: LD_INT 8
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: LIST
71517: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71518: LD_VAR 0 6
71522: PPUSH
71523: CALL_OW 264
71527: PUSH
71528: LD_INT 5
71530: PUSH
71531: LD_INT 27
71533: PUSH
71534: LD_INT 44
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: LIST
71541: IN
71542: IFFALSE 71563
// points := [ 14 , 50 , 16 ] ;
71544: LD_ADDR_VAR 0 9
71548: PUSH
71549: LD_INT 14
71551: PUSH
71552: LD_INT 50
71554: PUSH
71555: LD_INT 16
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: LIST
71562: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71563: LD_VAR 0 6
71567: PPUSH
71568: CALL_OW 264
71572: PUSH
71573: LD_INT 6
71575: PUSH
71576: LD_INT 46
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: IN
71583: IFFALSE 71604
// points := [ 32 , 120 , 70 ] ;
71585: LD_ADDR_VAR 0 9
71589: PUSH
71590: LD_INT 32
71592: PUSH
71593: LD_INT 120
71595: PUSH
71596: LD_INT 70
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: LIST
71603: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71604: LD_VAR 0 6
71608: PPUSH
71609: CALL_OW 264
71613: PUSH
71614: LD_INT 7
71616: PUSH
71617: LD_INT 28
71619: PUSH
71620: LD_INT 45
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: LIST
71627: IN
71628: IFFALSE 71649
// points := [ 35 , 20 , 45 ] ;
71630: LD_ADDR_VAR 0 9
71634: PUSH
71635: LD_INT 35
71637: PUSH
71638: LD_INT 20
71640: PUSH
71641: LD_INT 45
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: LIST
71648: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71649: LD_VAR 0 6
71653: PPUSH
71654: CALL_OW 264
71658: PUSH
71659: LD_INT 47
71661: PUSH
71662: EMPTY
71663: LIST
71664: IN
71665: IFFALSE 71686
// points := [ 67 , 45 , 75 ] ;
71667: LD_ADDR_VAR 0 9
71671: PUSH
71672: LD_INT 67
71674: PUSH
71675: LD_INT 45
71677: PUSH
71678: LD_INT 75
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: LIST
71685: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71686: LD_VAR 0 6
71690: PPUSH
71691: CALL_OW 264
71695: PUSH
71696: LD_INT 26
71698: PUSH
71699: EMPTY
71700: LIST
71701: IN
71702: IFFALSE 71723
// points := [ 120 , 30 , 80 ] ;
71704: LD_ADDR_VAR 0 9
71708: PUSH
71709: LD_INT 120
71711: PUSH
71712: LD_INT 30
71714: PUSH
71715: LD_INT 80
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: LIST
71722: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71723: LD_VAR 0 6
71727: PPUSH
71728: CALL_OW 264
71732: PUSH
71733: LD_INT 22
71735: PUSH
71736: EMPTY
71737: LIST
71738: IN
71739: IFFALSE 71760
// points := [ 40 , 1 , 1 ] ;
71741: LD_ADDR_VAR 0 9
71745: PUSH
71746: LD_INT 40
71748: PUSH
71749: LD_INT 1
71751: PUSH
71752: LD_INT 1
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: LIST
71759: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71760: LD_VAR 0 6
71764: PPUSH
71765: CALL_OW 264
71769: PUSH
71770: LD_INT 29
71772: PUSH
71773: EMPTY
71774: LIST
71775: IN
71776: IFFALSE 71797
// points := [ 70 , 200 , 400 ] ;
71778: LD_ADDR_VAR 0 9
71782: PUSH
71783: LD_INT 70
71785: PUSH
71786: LD_INT 200
71788: PUSH
71789: LD_INT 400
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: LIST
71796: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71797: LD_VAR 0 6
71801: PPUSH
71802: CALL_OW 264
71806: PUSH
71807: LD_INT 14
71809: PUSH
71810: LD_INT 53
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: IN
71817: IFFALSE 71838
// points := [ 40 , 10 , 20 ] ;
71819: LD_ADDR_VAR 0 9
71823: PUSH
71824: LD_INT 40
71826: PUSH
71827: LD_INT 10
71829: PUSH
71830: LD_INT 20
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: LIST
71837: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71838: LD_VAR 0 6
71842: PPUSH
71843: CALL_OW 264
71847: PUSH
71848: LD_INT 9
71850: PUSH
71851: EMPTY
71852: LIST
71853: IN
71854: IFFALSE 71875
// points := [ 5 , 70 , 20 ] ;
71856: LD_ADDR_VAR 0 9
71860: PUSH
71861: LD_INT 5
71863: PUSH
71864: LD_INT 70
71866: PUSH
71867: LD_INT 20
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: LIST
71874: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71875: LD_VAR 0 6
71879: PPUSH
71880: CALL_OW 264
71884: PUSH
71885: LD_INT 10
71887: PUSH
71888: EMPTY
71889: LIST
71890: IN
71891: IFFALSE 71912
// points := [ 35 , 110 , 70 ] ;
71893: LD_ADDR_VAR 0 9
71897: PUSH
71898: LD_INT 35
71900: PUSH
71901: LD_INT 110
71903: PUSH
71904: LD_INT 70
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: LIST
71911: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71912: LD_VAR 0 6
71916: PPUSH
71917: CALL_OW 265
71921: PUSH
71922: LD_INT 25
71924: EQUAL
71925: IFFALSE 71946
// points := [ 80 , 65 , 100 ] ;
71927: LD_ADDR_VAR 0 9
71931: PUSH
71932: LD_INT 80
71934: PUSH
71935: LD_INT 65
71937: PUSH
71938: LD_INT 100
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: LIST
71945: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71946: LD_VAR 0 6
71950: PPUSH
71951: CALL_OW 263
71955: PUSH
71956: LD_INT 1
71958: EQUAL
71959: IFFALSE 71994
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71961: LD_ADDR_VAR 0 10
71965: PUSH
71966: LD_VAR 0 10
71970: PUSH
71971: LD_VAR 0 6
71975: PPUSH
71976: CALL_OW 311
71980: PPUSH
71981: LD_INT 3
71983: PPUSH
71984: CALL_OW 259
71988: PUSH
71989: LD_INT 4
71991: MUL
71992: MUL
71993: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71994: LD_VAR 0 6
71998: PPUSH
71999: CALL_OW 263
72003: PUSH
72004: LD_INT 2
72006: EQUAL
72007: IFFALSE 72058
// begin j := IsControledBy ( i ) ;
72009: LD_ADDR_VAR 0 7
72013: PUSH
72014: LD_VAR 0 6
72018: PPUSH
72019: CALL_OW 312
72023: ST_TO_ADDR
// if j then
72024: LD_VAR 0 7
72028: IFFALSE 72058
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72030: LD_ADDR_VAR 0 10
72034: PUSH
72035: LD_VAR 0 10
72039: PUSH
72040: LD_VAR 0 7
72044: PPUSH
72045: LD_INT 3
72047: PPUSH
72048: CALL_OW 259
72052: PUSH
72053: LD_INT 3
72055: MUL
72056: MUL
72057: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72058: LD_VAR 0 6
72062: PPUSH
72063: CALL_OW 264
72067: PUSH
72068: LD_INT 5
72070: PUSH
72071: LD_INT 6
72073: PUSH
72074: LD_INT 46
72076: PUSH
72077: LD_INT 44
72079: PUSH
72080: LD_INT 47
72082: PUSH
72083: LD_INT 45
72085: PUSH
72086: LD_INT 28
72088: PUSH
72089: LD_INT 7
72091: PUSH
72092: LD_INT 27
72094: PUSH
72095: LD_INT 29
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: IN
72110: PUSH
72111: LD_VAR 0 1
72115: PPUSH
72116: LD_INT 52
72118: PPUSH
72119: CALL_OW 321
72123: PUSH
72124: LD_INT 2
72126: EQUAL
72127: AND
72128: IFFALSE 72145
// bpoints := bpoints * 1.2 ;
72130: LD_ADDR_VAR 0 10
72134: PUSH
72135: LD_VAR 0 10
72139: PUSH
72140: LD_REAL  1.20000000000000E+0000
72143: MUL
72144: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72145: LD_VAR 0 6
72149: PPUSH
72150: CALL_OW 264
72154: PUSH
72155: LD_INT 6
72157: PUSH
72158: LD_INT 46
72160: PUSH
72161: LD_INT 47
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: LIST
72168: IN
72169: IFFALSE 72186
// bpoints := bpoints * 1.2 ;
72171: LD_ADDR_VAR 0 10
72175: PUSH
72176: LD_VAR 0 10
72180: PUSH
72181: LD_REAL  1.20000000000000E+0000
72184: MUL
72185: ST_TO_ADDR
// end ; unit_building :
72186: GO 72200
72188: LD_INT 3
72190: DOUBLE
72191: EQUAL
72192: IFTRUE 72196
72194: GO 72199
72196: POP
// ; end ;
72197: GO 72200
72199: POP
// for j = 1 to 3 do
72200: LD_ADDR_VAR 0 7
72204: PUSH
72205: DOUBLE
72206: LD_INT 1
72208: DEC
72209: ST_TO_ADDR
72210: LD_INT 3
72212: PUSH
72213: FOR_TO
72214: IFFALSE 72267
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72216: LD_ADDR_VAR 0 5
72220: PUSH
72221: LD_VAR 0 5
72225: PPUSH
72226: LD_VAR 0 7
72230: PPUSH
72231: LD_VAR 0 5
72235: PUSH
72236: LD_VAR 0 7
72240: ARRAY
72241: PUSH
72242: LD_VAR 0 9
72246: PUSH
72247: LD_VAR 0 7
72251: ARRAY
72252: PUSH
72253: LD_VAR 0 10
72257: MUL
72258: PLUS
72259: PPUSH
72260: CALL_OW 1
72264: ST_TO_ADDR
72265: GO 72213
72267: POP
72268: POP
// end ;
72269: GO 70752
72271: POP
72272: POP
// result := Replace ( result , 4 , tmp ) ;
72273: LD_ADDR_VAR 0 5
72277: PUSH
72278: LD_VAR 0 5
72282: PPUSH
72283: LD_INT 4
72285: PPUSH
72286: LD_VAR 0 8
72290: PPUSH
72291: CALL_OW 1
72295: ST_TO_ADDR
// end ;
72296: LD_VAR 0 5
72300: RET
// export function DangerAtRange ( unit , range ) ; begin
72301: LD_INT 0
72303: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72304: LD_ADDR_VAR 0 3
72308: PUSH
72309: LD_VAR 0 1
72313: PPUSH
72314: CALL_OW 255
72318: PPUSH
72319: LD_VAR 0 1
72323: PPUSH
72324: CALL_OW 250
72328: PPUSH
72329: LD_VAR 0 1
72333: PPUSH
72334: CALL_OW 251
72338: PPUSH
72339: LD_VAR 0 2
72343: PPUSH
72344: CALL 70604 0 4
72348: ST_TO_ADDR
// end ;
72349: LD_VAR 0 3
72353: RET
// export function DangerInArea ( side , area ) ; begin
72354: LD_INT 0
72356: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72357: LD_ADDR_VAR 0 3
72361: PUSH
72362: LD_VAR 0 2
72366: PPUSH
72367: LD_INT 81
72369: PUSH
72370: LD_VAR 0 1
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PPUSH
72379: CALL_OW 70
72383: ST_TO_ADDR
// end ;
72384: LD_VAR 0 3
72388: RET
// export function IsExtension ( b ) ; begin
72389: LD_INT 0
72391: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72392: LD_ADDR_VAR 0 2
72396: PUSH
72397: LD_VAR 0 1
72401: PUSH
72402: LD_INT 23
72404: PUSH
72405: LD_INT 20
72407: PUSH
72408: LD_INT 22
72410: PUSH
72411: LD_INT 17
72413: PUSH
72414: LD_INT 24
72416: PUSH
72417: LD_INT 21
72419: PUSH
72420: LD_INT 19
72422: PUSH
72423: LD_INT 16
72425: PUSH
72426: LD_INT 25
72428: PUSH
72429: LD_INT 18
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: IN
72444: ST_TO_ADDR
// end ;
72445: LD_VAR 0 2
72449: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72450: LD_INT 0
72452: PPUSH
72453: PPUSH
72454: PPUSH
// result := [ ] ;
72455: LD_ADDR_VAR 0 3
72459: PUSH
72460: EMPTY
72461: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72462: LD_ADDR_VAR 0 4
72466: PUSH
72467: LD_VAR 0 2
72471: PPUSH
72472: LD_INT 21
72474: PUSH
72475: LD_INT 3
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PPUSH
72482: CALL_OW 70
72486: ST_TO_ADDR
// if not tmp then
72487: LD_VAR 0 4
72491: NOT
72492: IFFALSE 72496
// exit ;
72494: GO 72554
// for i in tmp do
72496: LD_ADDR_VAR 0 5
72500: PUSH
72501: LD_VAR 0 4
72505: PUSH
72506: FOR_IN
72507: IFFALSE 72542
// if GetBase ( i ) <> base then
72509: LD_VAR 0 5
72513: PPUSH
72514: CALL_OW 274
72518: PUSH
72519: LD_VAR 0 1
72523: NONEQUAL
72524: IFFALSE 72540
// ComLinkToBase ( base , i ) ;
72526: LD_VAR 0 1
72530: PPUSH
72531: LD_VAR 0 5
72535: PPUSH
72536: CALL_OW 169
72540: GO 72506
72542: POP
72543: POP
// result := tmp ;
72544: LD_ADDR_VAR 0 3
72548: PUSH
72549: LD_VAR 0 4
72553: ST_TO_ADDR
// end ;
72554: LD_VAR 0 3
72558: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72559: LD_INT 0
72561: PPUSH
72562: PPUSH
// if BuildingStatus ( b ) = bs_build then
72563: LD_VAR 0 2
72567: PPUSH
72568: CALL_OW 461
72572: PUSH
72573: LD_INT 1
72575: EQUAL
72576: IFFALSE 72636
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72578: LD_VAR 0 1
72582: PPUSH
72583: LD_STRING h
72585: PUSH
72586: LD_VAR 0 2
72590: PPUSH
72591: CALL_OW 250
72595: PUSH
72596: LD_VAR 0 2
72600: PPUSH
72601: CALL_OW 251
72605: PUSH
72606: LD_VAR 0 2
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: LD_INT 0
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: PUSH
72629: EMPTY
72630: LIST
72631: PPUSH
72632: CALL_OW 446
// end ;
72636: LD_VAR 0 3
72640: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72641: LD_INT 0
72643: PPUSH
72644: PPUSH
72645: PPUSH
72646: PPUSH
72647: PPUSH
72648: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72649: LD_VAR 0 1
72653: NOT
72654: PUSH
72655: LD_VAR 0 1
72659: PPUSH
72660: CALL_OW 263
72664: PUSH
72665: LD_INT 2
72667: EQUAL
72668: NOT
72669: OR
72670: IFFALSE 72674
// exit ;
72672: GO 72990
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72674: LD_ADDR_VAR 0 6
72678: PUSH
72679: LD_INT 22
72681: PUSH
72682: LD_VAR 0 1
72686: PPUSH
72687: CALL_OW 255
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 2
72698: PUSH
72699: LD_INT 30
72701: PUSH
72702: LD_INT 36
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 34
72711: PUSH
72712: LD_INT 31
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: LIST
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PPUSH
72728: CALL_OW 69
72732: ST_TO_ADDR
// if not tmp then
72733: LD_VAR 0 6
72737: NOT
72738: IFFALSE 72742
// exit ;
72740: GO 72990
// result := [ ] ;
72742: LD_ADDR_VAR 0 2
72746: PUSH
72747: EMPTY
72748: ST_TO_ADDR
// for i in tmp do
72749: LD_ADDR_VAR 0 3
72753: PUSH
72754: LD_VAR 0 6
72758: PUSH
72759: FOR_IN
72760: IFFALSE 72831
// begin t := UnitsInside ( i ) ;
72762: LD_ADDR_VAR 0 4
72766: PUSH
72767: LD_VAR 0 3
72771: PPUSH
72772: CALL_OW 313
72776: ST_TO_ADDR
// if t then
72777: LD_VAR 0 4
72781: IFFALSE 72829
// for j in t do
72783: LD_ADDR_VAR 0 7
72787: PUSH
72788: LD_VAR 0 4
72792: PUSH
72793: FOR_IN
72794: IFFALSE 72827
// result := Insert ( result , result + 1 , j ) ;
72796: LD_ADDR_VAR 0 2
72800: PUSH
72801: LD_VAR 0 2
72805: PPUSH
72806: LD_VAR 0 2
72810: PUSH
72811: LD_INT 1
72813: PLUS
72814: PPUSH
72815: LD_VAR 0 7
72819: PPUSH
72820: CALL_OW 2
72824: ST_TO_ADDR
72825: GO 72793
72827: POP
72828: POP
// end ;
72829: GO 72759
72831: POP
72832: POP
// if not result then
72833: LD_VAR 0 2
72837: NOT
72838: IFFALSE 72842
// exit ;
72840: GO 72990
// mech := result [ 1 ] ;
72842: LD_ADDR_VAR 0 5
72846: PUSH
72847: LD_VAR 0 2
72851: PUSH
72852: LD_INT 1
72854: ARRAY
72855: ST_TO_ADDR
// if result > 1 then
72856: LD_VAR 0 2
72860: PUSH
72861: LD_INT 1
72863: GREATER
72864: IFFALSE 72976
// for i = 2 to result do
72866: LD_ADDR_VAR 0 3
72870: PUSH
72871: DOUBLE
72872: LD_INT 2
72874: DEC
72875: ST_TO_ADDR
72876: LD_VAR 0 2
72880: PUSH
72881: FOR_TO
72882: IFFALSE 72974
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72884: LD_ADDR_VAR 0 4
72888: PUSH
72889: LD_VAR 0 2
72893: PUSH
72894: LD_VAR 0 3
72898: ARRAY
72899: PPUSH
72900: LD_INT 3
72902: PPUSH
72903: CALL_OW 259
72907: PUSH
72908: LD_VAR 0 2
72912: PUSH
72913: LD_VAR 0 3
72917: ARRAY
72918: PPUSH
72919: CALL_OW 432
72923: MINUS
72924: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72925: LD_VAR 0 4
72929: PUSH
72930: LD_VAR 0 5
72934: PPUSH
72935: LD_INT 3
72937: PPUSH
72938: CALL_OW 259
72942: PUSH
72943: LD_VAR 0 5
72947: PPUSH
72948: CALL_OW 432
72952: MINUS
72953: GREATEREQUAL
72954: IFFALSE 72972
// mech := result [ i ] ;
72956: LD_ADDR_VAR 0 5
72960: PUSH
72961: LD_VAR 0 2
72965: PUSH
72966: LD_VAR 0 3
72970: ARRAY
72971: ST_TO_ADDR
// end ;
72972: GO 72881
72974: POP
72975: POP
// ComLinkTo ( vehicle , mech ) ;
72976: LD_VAR 0 1
72980: PPUSH
72981: LD_VAR 0 5
72985: PPUSH
72986: CALL_OW 135
// end ;
72990: LD_VAR 0 2
72994: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72995: LD_INT 0
72997: PPUSH
72998: PPUSH
72999: PPUSH
73000: PPUSH
73001: PPUSH
73002: PPUSH
73003: PPUSH
73004: PPUSH
73005: PPUSH
73006: PPUSH
73007: PPUSH
73008: PPUSH
73009: PPUSH
// result := [ ] ;
73010: LD_ADDR_VAR 0 7
73014: PUSH
73015: EMPTY
73016: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73017: LD_VAR 0 1
73021: PPUSH
73022: CALL_OW 266
73026: PUSH
73027: LD_INT 0
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: IN
73037: NOT
73038: IFFALSE 73042
// exit ;
73040: GO 74673
// if name then
73042: LD_VAR 0 3
73046: IFFALSE 73062
// SetBName ( base_dep , name ) ;
73048: LD_VAR 0 1
73052: PPUSH
73053: LD_VAR 0 3
73057: PPUSH
73058: CALL_OW 500
// base := GetBase ( base_dep ) ;
73062: LD_ADDR_VAR 0 15
73066: PUSH
73067: LD_VAR 0 1
73071: PPUSH
73072: CALL_OW 274
73076: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73077: LD_ADDR_VAR 0 16
73081: PUSH
73082: LD_VAR 0 1
73086: PPUSH
73087: CALL_OW 255
73091: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73092: LD_ADDR_VAR 0 17
73096: PUSH
73097: LD_VAR 0 1
73101: PPUSH
73102: CALL_OW 248
73106: ST_TO_ADDR
// if sources then
73107: LD_VAR 0 5
73111: IFFALSE 73158
// for i = 1 to 3 do
73113: LD_ADDR_VAR 0 8
73117: PUSH
73118: DOUBLE
73119: LD_INT 1
73121: DEC
73122: ST_TO_ADDR
73123: LD_INT 3
73125: PUSH
73126: FOR_TO
73127: IFFALSE 73156
// AddResourceType ( base , i , sources [ i ] ) ;
73129: LD_VAR 0 15
73133: PPUSH
73134: LD_VAR 0 8
73138: PPUSH
73139: LD_VAR 0 5
73143: PUSH
73144: LD_VAR 0 8
73148: ARRAY
73149: PPUSH
73150: CALL_OW 276
73154: GO 73126
73156: POP
73157: POP
// buildings := GetBaseBuildings ( base , area ) ;
73158: LD_ADDR_VAR 0 18
73162: PUSH
73163: LD_VAR 0 15
73167: PPUSH
73168: LD_VAR 0 2
73172: PPUSH
73173: CALL 72450 0 2
73177: ST_TO_ADDR
// InitHc ;
73178: CALL_OW 19
// InitUc ;
73182: CALL_OW 18
// uc_side := side ;
73186: LD_ADDR_OWVAR 20
73190: PUSH
73191: LD_VAR 0 16
73195: ST_TO_ADDR
// uc_nation := nation ;
73196: LD_ADDR_OWVAR 21
73200: PUSH
73201: LD_VAR 0 17
73205: ST_TO_ADDR
// if buildings then
73206: LD_VAR 0 18
73210: IFFALSE 74532
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73212: LD_ADDR_VAR 0 19
73216: PUSH
73217: LD_VAR 0 18
73221: PPUSH
73222: LD_INT 2
73224: PUSH
73225: LD_INT 30
73227: PUSH
73228: LD_INT 29
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 30
73237: PUSH
73238: LD_INT 30
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: LIST
73249: PPUSH
73250: CALL_OW 72
73254: ST_TO_ADDR
// if tmp then
73255: LD_VAR 0 19
73259: IFFALSE 73307
// for i in tmp do
73261: LD_ADDR_VAR 0 8
73265: PUSH
73266: LD_VAR 0 19
73270: PUSH
73271: FOR_IN
73272: IFFALSE 73305
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73274: LD_VAR 0 8
73278: PPUSH
73279: CALL_OW 250
73283: PPUSH
73284: LD_VAR 0 8
73288: PPUSH
73289: CALL_OW 251
73293: PPUSH
73294: LD_VAR 0 16
73298: PPUSH
73299: CALL_OW 441
73303: GO 73271
73305: POP
73306: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73307: LD_VAR 0 18
73311: PPUSH
73312: LD_INT 2
73314: PUSH
73315: LD_INT 30
73317: PUSH
73318: LD_INT 32
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 30
73327: PUSH
73328: LD_INT 33
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: LIST
73339: PPUSH
73340: CALL_OW 72
73344: IFFALSE 73432
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73346: LD_ADDR_VAR 0 8
73350: PUSH
73351: LD_VAR 0 18
73355: PPUSH
73356: LD_INT 2
73358: PUSH
73359: LD_INT 30
73361: PUSH
73362: LD_INT 32
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 30
73371: PUSH
73372: LD_INT 33
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: LIST
73383: PPUSH
73384: CALL_OW 72
73388: PUSH
73389: FOR_IN
73390: IFFALSE 73430
// begin if not GetBWeapon ( i ) then
73392: LD_VAR 0 8
73396: PPUSH
73397: CALL_OW 269
73401: NOT
73402: IFFALSE 73428
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73404: LD_VAR 0 8
73408: PPUSH
73409: LD_VAR 0 8
73413: PPUSH
73414: LD_VAR 0 2
73418: PPUSH
73419: CALL 74678 0 2
73423: PPUSH
73424: CALL_OW 431
// end ;
73428: GO 73389
73430: POP
73431: POP
// end ; for i = 1 to personel do
73432: LD_ADDR_VAR 0 8
73436: PUSH
73437: DOUBLE
73438: LD_INT 1
73440: DEC
73441: ST_TO_ADDR
73442: LD_VAR 0 6
73446: PUSH
73447: FOR_TO
73448: IFFALSE 74512
// begin if i > 4 then
73450: LD_VAR 0 8
73454: PUSH
73455: LD_INT 4
73457: GREATER
73458: IFFALSE 73462
// break ;
73460: GO 74512
// case i of 1 :
73462: LD_VAR 0 8
73466: PUSH
73467: LD_INT 1
73469: DOUBLE
73470: EQUAL
73471: IFTRUE 73475
73473: GO 73555
73475: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73476: LD_ADDR_VAR 0 12
73480: PUSH
73481: LD_VAR 0 18
73485: PPUSH
73486: LD_INT 22
73488: PUSH
73489: LD_VAR 0 16
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 58
73500: PUSH
73501: EMPTY
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: PUSH
73507: LD_INT 30
73509: PUSH
73510: LD_INT 32
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 30
73519: PUSH
73520: LD_INT 4
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 30
73529: PUSH
73530: LD_INT 5
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: LIST
73547: PPUSH
73548: CALL_OW 72
73552: ST_TO_ADDR
73553: GO 73777
73555: LD_INT 2
73557: DOUBLE
73558: EQUAL
73559: IFTRUE 73563
73561: GO 73625
73563: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73564: LD_ADDR_VAR 0 12
73568: PUSH
73569: LD_VAR 0 18
73573: PPUSH
73574: LD_INT 22
73576: PUSH
73577: LD_VAR 0 16
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 2
73588: PUSH
73589: LD_INT 30
73591: PUSH
73592: LD_INT 0
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: PUSH
73599: LD_INT 30
73601: PUSH
73602: LD_INT 1
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: LIST
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PPUSH
73618: CALL_OW 72
73622: ST_TO_ADDR
73623: GO 73777
73625: LD_INT 3
73627: DOUBLE
73628: EQUAL
73629: IFTRUE 73633
73631: GO 73695
73633: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73634: LD_ADDR_VAR 0 12
73638: PUSH
73639: LD_VAR 0 18
73643: PPUSH
73644: LD_INT 22
73646: PUSH
73647: LD_VAR 0 16
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 2
73658: PUSH
73659: LD_INT 30
73661: PUSH
73662: LD_INT 2
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 30
73671: PUSH
73672: LD_INT 3
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: LIST
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PPUSH
73688: CALL_OW 72
73692: ST_TO_ADDR
73693: GO 73777
73695: LD_INT 4
73697: DOUBLE
73698: EQUAL
73699: IFTRUE 73703
73701: GO 73776
73703: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73704: LD_ADDR_VAR 0 12
73708: PUSH
73709: LD_VAR 0 18
73713: PPUSH
73714: LD_INT 22
73716: PUSH
73717: LD_VAR 0 16
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 2
73728: PUSH
73729: LD_INT 30
73731: PUSH
73732: LD_INT 6
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 30
73741: PUSH
73742: LD_INT 7
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 30
73751: PUSH
73752: LD_INT 8
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PPUSH
73769: CALL_OW 72
73773: ST_TO_ADDR
73774: GO 73777
73776: POP
// if i = 1 then
73777: LD_VAR 0 8
73781: PUSH
73782: LD_INT 1
73784: EQUAL
73785: IFFALSE 73896
// begin tmp := [ ] ;
73787: LD_ADDR_VAR 0 19
73791: PUSH
73792: EMPTY
73793: ST_TO_ADDR
// for j in f do
73794: LD_ADDR_VAR 0 9
73798: PUSH
73799: LD_VAR 0 12
73803: PUSH
73804: FOR_IN
73805: IFFALSE 73878
// if GetBType ( j ) = b_bunker then
73807: LD_VAR 0 9
73811: PPUSH
73812: CALL_OW 266
73816: PUSH
73817: LD_INT 32
73819: EQUAL
73820: IFFALSE 73847
// tmp := Insert ( tmp , 1 , j ) else
73822: LD_ADDR_VAR 0 19
73826: PUSH
73827: LD_VAR 0 19
73831: PPUSH
73832: LD_INT 1
73834: PPUSH
73835: LD_VAR 0 9
73839: PPUSH
73840: CALL_OW 2
73844: ST_TO_ADDR
73845: GO 73876
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73847: LD_ADDR_VAR 0 19
73851: PUSH
73852: LD_VAR 0 19
73856: PPUSH
73857: LD_VAR 0 19
73861: PUSH
73862: LD_INT 1
73864: PLUS
73865: PPUSH
73866: LD_VAR 0 9
73870: PPUSH
73871: CALL_OW 2
73875: ST_TO_ADDR
73876: GO 73804
73878: POP
73879: POP
// if tmp then
73880: LD_VAR 0 19
73884: IFFALSE 73896
// f := tmp ;
73886: LD_ADDR_VAR 0 12
73890: PUSH
73891: LD_VAR 0 19
73895: ST_TO_ADDR
// end ; x := personel [ i ] ;
73896: LD_ADDR_VAR 0 13
73900: PUSH
73901: LD_VAR 0 6
73905: PUSH
73906: LD_VAR 0 8
73910: ARRAY
73911: ST_TO_ADDR
// if x = - 1 then
73912: LD_VAR 0 13
73916: PUSH
73917: LD_INT 1
73919: NEG
73920: EQUAL
73921: IFFALSE 74130
// begin for j in f do
73923: LD_ADDR_VAR 0 9
73927: PUSH
73928: LD_VAR 0 12
73932: PUSH
73933: FOR_IN
73934: IFFALSE 74126
// repeat InitHc ;
73936: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73940: LD_VAR 0 9
73944: PPUSH
73945: CALL_OW 266
73949: PUSH
73950: LD_INT 5
73952: EQUAL
73953: IFFALSE 74023
// begin if UnitsInside ( j ) < 3 then
73955: LD_VAR 0 9
73959: PPUSH
73960: CALL_OW 313
73964: PUSH
73965: LD_INT 3
73967: LESS
73968: IFFALSE 74004
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73970: LD_INT 0
73972: PPUSH
73973: LD_INT 5
73975: PUSH
73976: LD_INT 8
73978: PUSH
73979: LD_INT 9
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: LIST
73986: PUSH
73987: LD_VAR 0 17
73991: ARRAY
73992: PPUSH
73993: LD_VAR 0 4
73997: PPUSH
73998: CALL_OW 380
74002: GO 74021
// PrepareHuman ( false , i , skill ) ;
74004: LD_INT 0
74006: PPUSH
74007: LD_VAR 0 8
74011: PPUSH
74012: LD_VAR 0 4
74016: PPUSH
74017: CALL_OW 380
// end else
74021: GO 74040
// PrepareHuman ( false , i , skill ) ;
74023: LD_INT 0
74025: PPUSH
74026: LD_VAR 0 8
74030: PPUSH
74031: LD_VAR 0 4
74035: PPUSH
74036: CALL_OW 380
// un := CreateHuman ;
74040: LD_ADDR_VAR 0 14
74044: PUSH
74045: CALL_OW 44
74049: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74050: LD_ADDR_VAR 0 7
74054: PUSH
74055: LD_VAR 0 7
74059: PPUSH
74060: LD_INT 1
74062: PPUSH
74063: LD_VAR 0 14
74067: PPUSH
74068: CALL_OW 2
74072: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74073: LD_VAR 0 14
74077: PPUSH
74078: LD_VAR 0 9
74082: PPUSH
74083: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74087: LD_VAR 0 9
74091: PPUSH
74092: CALL_OW 313
74096: PUSH
74097: LD_INT 6
74099: EQUAL
74100: PUSH
74101: LD_VAR 0 9
74105: PPUSH
74106: CALL_OW 266
74110: PUSH
74111: LD_INT 32
74113: PUSH
74114: LD_INT 31
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: IN
74121: OR
74122: IFFALSE 73936
74124: GO 73933
74126: POP
74127: POP
// end else
74128: GO 74510
// for j = 1 to x do
74130: LD_ADDR_VAR 0 9
74134: PUSH
74135: DOUBLE
74136: LD_INT 1
74138: DEC
74139: ST_TO_ADDR
74140: LD_VAR 0 13
74144: PUSH
74145: FOR_TO
74146: IFFALSE 74508
// begin InitHc ;
74148: CALL_OW 19
// if not f then
74152: LD_VAR 0 12
74156: NOT
74157: IFFALSE 74246
// begin PrepareHuman ( false , i , skill ) ;
74159: LD_INT 0
74161: PPUSH
74162: LD_VAR 0 8
74166: PPUSH
74167: LD_VAR 0 4
74171: PPUSH
74172: CALL_OW 380
// un := CreateHuman ;
74176: LD_ADDR_VAR 0 14
74180: PUSH
74181: CALL_OW 44
74185: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74186: LD_ADDR_VAR 0 7
74190: PUSH
74191: LD_VAR 0 7
74195: PPUSH
74196: LD_INT 1
74198: PPUSH
74199: LD_VAR 0 14
74203: PPUSH
74204: CALL_OW 2
74208: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74209: LD_VAR 0 14
74213: PPUSH
74214: LD_VAR 0 1
74218: PPUSH
74219: CALL_OW 250
74223: PPUSH
74224: LD_VAR 0 1
74228: PPUSH
74229: CALL_OW 251
74233: PPUSH
74234: LD_INT 10
74236: PPUSH
74237: LD_INT 0
74239: PPUSH
74240: CALL_OW 50
// continue ;
74244: GO 74145
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74246: LD_VAR 0 12
74250: PUSH
74251: LD_INT 1
74253: ARRAY
74254: PPUSH
74255: CALL_OW 313
74259: PUSH
74260: LD_VAR 0 12
74264: PUSH
74265: LD_INT 1
74267: ARRAY
74268: PPUSH
74269: CALL_OW 266
74273: PUSH
74274: LD_INT 32
74276: PUSH
74277: LD_INT 31
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: IN
74284: AND
74285: PUSH
74286: LD_VAR 0 12
74290: PUSH
74291: LD_INT 1
74293: ARRAY
74294: PPUSH
74295: CALL_OW 313
74299: PUSH
74300: LD_INT 6
74302: EQUAL
74303: OR
74304: IFFALSE 74324
// f := Delete ( f , 1 ) ;
74306: LD_ADDR_VAR 0 12
74310: PUSH
74311: LD_VAR 0 12
74315: PPUSH
74316: LD_INT 1
74318: PPUSH
74319: CALL_OW 3
74323: ST_TO_ADDR
// if not f then
74324: LD_VAR 0 12
74328: NOT
74329: IFFALSE 74347
// begin x := x + 2 ;
74331: LD_ADDR_VAR 0 13
74335: PUSH
74336: LD_VAR 0 13
74340: PUSH
74341: LD_INT 2
74343: PLUS
74344: ST_TO_ADDR
// continue ;
74345: GO 74145
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74347: LD_VAR 0 12
74351: PUSH
74352: LD_INT 1
74354: ARRAY
74355: PPUSH
74356: CALL_OW 266
74360: PUSH
74361: LD_INT 5
74363: EQUAL
74364: IFFALSE 74438
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74366: LD_VAR 0 12
74370: PUSH
74371: LD_INT 1
74373: ARRAY
74374: PPUSH
74375: CALL_OW 313
74379: PUSH
74380: LD_INT 3
74382: LESS
74383: IFFALSE 74419
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74385: LD_INT 0
74387: PPUSH
74388: LD_INT 5
74390: PUSH
74391: LD_INT 8
74393: PUSH
74394: LD_INT 9
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: LIST
74401: PUSH
74402: LD_VAR 0 17
74406: ARRAY
74407: PPUSH
74408: LD_VAR 0 4
74412: PPUSH
74413: CALL_OW 380
74417: GO 74436
// PrepareHuman ( false , i , skill ) ;
74419: LD_INT 0
74421: PPUSH
74422: LD_VAR 0 8
74426: PPUSH
74427: LD_VAR 0 4
74431: PPUSH
74432: CALL_OW 380
// end else
74436: GO 74455
// PrepareHuman ( false , i , skill ) ;
74438: LD_INT 0
74440: PPUSH
74441: LD_VAR 0 8
74445: PPUSH
74446: LD_VAR 0 4
74450: PPUSH
74451: CALL_OW 380
// un := CreateHuman ;
74455: LD_ADDR_VAR 0 14
74459: PUSH
74460: CALL_OW 44
74464: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74465: LD_ADDR_VAR 0 7
74469: PUSH
74470: LD_VAR 0 7
74474: PPUSH
74475: LD_INT 1
74477: PPUSH
74478: LD_VAR 0 14
74482: PPUSH
74483: CALL_OW 2
74487: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74488: LD_VAR 0 14
74492: PPUSH
74493: LD_VAR 0 12
74497: PUSH
74498: LD_INT 1
74500: ARRAY
74501: PPUSH
74502: CALL_OW 52
// end ;
74506: GO 74145
74508: POP
74509: POP
// end ;
74510: GO 73447
74512: POP
74513: POP
// result := result ^ buildings ;
74514: LD_ADDR_VAR 0 7
74518: PUSH
74519: LD_VAR 0 7
74523: PUSH
74524: LD_VAR 0 18
74528: ADD
74529: ST_TO_ADDR
// end else
74530: GO 74673
// begin for i = 1 to personel do
74532: LD_ADDR_VAR 0 8
74536: PUSH
74537: DOUBLE
74538: LD_INT 1
74540: DEC
74541: ST_TO_ADDR
74542: LD_VAR 0 6
74546: PUSH
74547: FOR_TO
74548: IFFALSE 74671
// begin if i > 4 then
74550: LD_VAR 0 8
74554: PUSH
74555: LD_INT 4
74557: GREATER
74558: IFFALSE 74562
// break ;
74560: GO 74671
// x := personel [ i ] ;
74562: LD_ADDR_VAR 0 13
74566: PUSH
74567: LD_VAR 0 6
74571: PUSH
74572: LD_VAR 0 8
74576: ARRAY
74577: ST_TO_ADDR
// if x = - 1 then
74578: LD_VAR 0 13
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: EQUAL
74587: IFFALSE 74591
// continue ;
74589: GO 74547
// PrepareHuman ( false , i , skill ) ;
74591: LD_INT 0
74593: PPUSH
74594: LD_VAR 0 8
74598: PPUSH
74599: LD_VAR 0 4
74603: PPUSH
74604: CALL_OW 380
// un := CreateHuman ;
74608: LD_ADDR_VAR 0 14
74612: PUSH
74613: CALL_OW 44
74617: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74618: LD_VAR 0 14
74622: PPUSH
74623: LD_VAR 0 1
74627: PPUSH
74628: CALL_OW 250
74632: PPUSH
74633: LD_VAR 0 1
74637: PPUSH
74638: CALL_OW 251
74642: PPUSH
74643: LD_INT 10
74645: PPUSH
74646: LD_INT 0
74648: PPUSH
74649: CALL_OW 50
// result := result ^ un ;
74653: LD_ADDR_VAR 0 7
74657: PUSH
74658: LD_VAR 0 7
74662: PUSH
74663: LD_VAR 0 14
74667: ADD
74668: ST_TO_ADDR
// end ;
74669: GO 74547
74671: POP
74672: POP
// end ; end ;
74673: LD_VAR 0 7
74677: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74678: LD_INT 0
74680: PPUSH
74681: PPUSH
74682: PPUSH
74683: PPUSH
74684: PPUSH
74685: PPUSH
74686: PPUSH
74687: PPUSH
74688: PPUSH
74689: PPUSH
74690: PPUSH
74691: PPUSH
74692: PPUSH
74693: PPUSH
74694: PPUSH
74695: PPUSH
// result := false ;
74696: LD_ADDR_VAR 0 3
74700: PUSH
74701: LD_INT 0
74703: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74704: LD_VAR 0 1
74708: NOT
74709: PUSH
74710: LD_VAR 0 1
74714: PPUSH
74715: CALL_OW 266
74719: PUSH
74720: LD_INT 32
74722: PUSH
74723: LD_INT 33
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: IN
74730: NOT
74731: OR
74732: IFFALSE 74736
// exit ;
74734: GO 75872
// nat := GetNation ( tower ) ;
74736: LD_ADDR_VAR 0 12
74740: PUSH
74741: LD_VAR 0 1
74745: PPUSH
74746: CALL_OW 248
74750: ST_TO_ADDR
// side := GetSide ( tower ) ;
74751: LD_ADDR_VAR 0 16
74755: PUSH
74756: LD_VAR 0 1
74760: PPUSH
74761: CALL_OW 255
74765: ST_TO_ADDR
// x := GetX ( tower ) ;
74766: LD_ADDR_VAR 0 10
74770: PUSH
74771: LD_VAR 0 1
74775: PPUSH
74776: CALL_OW 250
74780: ST_TO_ADDR
// y := GetY ( tower ) ;
74781: LD_ADDR_VAR 0 11
74785: PUSH
74786: LD_VAR 0 1
74790: PPUSH
74791: CALL_OW 251
74795: ST_TO_ADDR
// if not x or not y then
74796: LD_VAR 0 10
74800: NOT
74801: PUSH
74802: LD_VAR 0 11
74806: NOT
74807: OR
74808: IFFALSE 74812
// exit ;
74810: GO 75872
// weapon := 0 ;
74812: LD_ADDR_VAR 0 18
74816: PUSH
74817: LD_INT 0
74819: ST_TO_ADDR
// fac_list := [ ] ;
74820: LD_ADDR_VAR 0 17
74824: PUSH
74825: EMPTY
74826: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
74827: LD_ADDR_VAR 0 6
74831: PUSH
74832: LD_VAR 0 1
74836: PPUSH
74837: CALL_OW 274
74841: PPUSH
74842: LD_VAR 0 2
74846: PPUSH
74847: CALL 72450 0 2
74851: PPUSH
74852: LD_INT 30
74854: PUSH
74855: LD_INT 3
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PPUSH
74862: CALL_OW 72
74866: ST_TO_ADDR
// if not factories then
74867: LD_VAR 0 6
74871: NOT
74872: IFFALSE 74876
// exit ;
74874: GO 75872
// for i in factories do
74876: LD_ADDR_VAR 0 8
74880: PUSH
74881: LD_VAR 0 6
74885: PUSH
74886: FOR_IN
74887: IFFALSE 74912
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74889: LD_ADDR_VAR 0 17
74893: PUSH
74894: LD_VAR 0 17
74898: PUSH
74899: LD_VAR 0 8
74903: PPUSH
74904: CALL_OW 478
74908: UNION
74909: ST_TO_ADDR
74910: GO 74886
74912: POP
74913: POP
// if not fac_list then
74914: LD_VAR 0 17
74918: NOT
74919: IFFALSE 74923
// exit ;
74921: GO 75872
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74923: LD_ADDR_VAR 0 5
74927: PUSH
74928: LD_INT 4
74930: PUSH
74931: LD_INT 5
74933: PUSH
74934: LD_INT 9
74936: PUSH
74937: LD_INT 10
74939: PUSH
74940: LD_INT 6
74942: PUSH
74943: LD_INT 7
74945: PUSH
74946: LD_INT 11
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 27
74960: PUSH
74961: LD_INT 28
74963: PUSH
74964: LD_INT 26
74966: PUSH
74967: LD_INT 30
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 43
74978: PUSH
74979: LD_INT 44
74981: PUSH
74982: LD_INT 46
74984: PUSH
74985: LD_INT 45
74987: PUSH
74988: LD_INT 47
74990: PUSH
74991: LD_INT 49
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: LIST
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: LIST
75006: PUSH
75007: LD_VAR 0 12
75011: ARRAY
75012: ST_TO_ADDR
// for i in list do
75013: LD_ADDR_VAR 0 8
75017: PUSH
75018: LD_VAR 0 5
75022: PUSH
75023: FOR_IN
75024: IFFALSE 75057
// if not i in fac_list then
75026: LD_VAR 0 8
75030: PUSH
75031: LD_VAR 0 17
75035: IN
75036: NOT
75037: IFFALSE 75055
// list := list diff i ;
75039: LD_ADDR_VAR 0 5
75043: PUSH
75044: LD_VAR 0 5
75048: PUSH
75049: LD_VAR 0 8
75053: DIFF
75054: ST_TO_ADDR
75055: GO 75023
75057: POP
75058: POP
// if not list then
75059: LD_VAR 0 5
75063: NOT
75064: IFFALSE 75068
// exit ;
75066: GO 75872
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75068: LD_VAR 0 12
75072: PUSH
75073: LD_INT 3
75075: EQUAL
75076: PUSH
75077: LD_INT 49
75079: PUSH
75080: LD_VAR 0 5
75084: IN
75085: AND
75086: PUSH
75087: LD_INT 31
75089: PPUSH
75090: LD_VAR 0 16
75094: PPUSH
75095: CALL_OW 321
75099: PUSH
75100: LD_INT 2
75102: EQUAL
75103: AND
75104: IFFALSE 75164
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75106: LD_INT 22
75108: PUSH
75109: LD_VAR 0 16
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 35
75120: PUSH
75121: LD_INT 49
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 91
75130: PUSH
75131: LD_VAR 0 1
75135: PUSH
75136: LD_INT 10
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: LIST
75148: PPUSH
75149: CALL_OW 69
75153: NOT
75154: IFFALSE 75164
// weapon := ru_time_lapser ;
75156: LD_ADDR_VAR 0 18
75160: PUSH
75161: LD_INT 49
75163: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75164: LD_VAR 0 12
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: LD_INT 2
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: IN
75179: PUSH
75180: LD_INT 11
75182: PUSH
75183: LD_VAR 0 5
75187: IN
75188: PUSH
75189: LD_INT 30
75191: PUSH
75192: LD_VAR 0 5
75196: IN
75197: OR
75198: AND
75199: PUSH
75200: LD_INT 6
75202: PPUSH
75203: LD_VAR 0 16
75207: PPUSH
75208: CALL_OW 321
75212: PUSH
75213: LD_INT 2
75215: EQUAL
75216: AND
75217: IFFALSE 75382
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75219: LD_INT 22
75221: PUSH
75222: LD_VAR 0 16
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 2
75233: PUSH
75234: LD_INT 35
75236: PUSH
75237: LD_INT 11
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 35
75246: PUSH
75247: LD_INT 30
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 91
75261: PUSH
75262: LD_VAR 0 1
75266: PUSH
75267: LD_INT 18
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: LIST
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: LIST
75279: PPUSH
75280: CALL_OW 69
75284: NOT
75285: PUSH
75286: LD_INT 22
75288: PUSH
75289: LD_VAR 0 16
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 2
75300: PUSH
75301: LD_INT 30
75303: PUSH
75304: LD_INT 32
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 30
75313: PUSH
75314: LD_INT 33
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 91
75328: PUSH
75329: LD_VAR 0 1
75333: PUSH
75334: LD_INT 12
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: LIST
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: PPUSH
75350: CALL_OW 69
75354: PUSH
75355: LD_INT 2
75357: GREATER
75358: AND
75359: IFFALSE 75382
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75361: LD_ADDR_VAR 0 18
75365: PUSH
75366: LD_INT 11
75368: PUSH
75369: LD_INT 30
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_VAR 0 12
75380: ARRAY
75381: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75382: LD_VAR 0 18
75386: NOT
75387: PUSH
75388: LD_INT 40
75390: PPUSH
75391: LD_VAR 0 16
75395: PPUSH
75396: CALL_OW 321
75400: PUSH
75401: LD_INT 2
75403: EQUAL
75404: AND
75405: PUSH
75406: LD_INT 7
75408: PUSH
75409: LD_VAR 0 5
75413: IN
75414: PUSH
75415: LD_INT 28
75417: PUSH
75418: LD_VAR 0 5
75422: IN
75423: OR
75424: PUSH
75425: LD_INT 45
75427: PUSH
75428: LD_VAR 0 5
75432: IN
75433: OR
75434: AND
75435: IFFALSE 75689
// begin hex := GetHexInfo ( x , y ) ;
75437: LD_ADDR_VAR 0 4
75441: PUSH
75442: LD_VAR 0 10
75446: PPUSH
75447: LD_VAR 0 11
75451: PPUSH
75452: CALL_OW 546
75456: ST_TO_ADDR
// if hex [ 1 ] then
75457: LD_VAR 0 4
75461: PUSH
75462: LD_INT 1
75464: ARRAY
75465: IFFALSE 75469
// exit ;
75467: GO 75872
// height := hex [ 2 ] ;
75469: LD_ADDR_VAR 0 15
75473: PUSH
75474: LD_VAR 0 4
75478: PUSH
75479: LD_INT 2
75481: ARRAY
75482: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75483: LD_ADDR_VAR 0 14
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 2
75493: PUSH
75494: LD_INT 3
75496: PUSH
75497: LD_INT 5
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: ST_TO_ADDR
// for i in tmp do
75506: LD_ADDR_VAR 0 8
75510: PUSH
75511: LD_VAR 0 14
75515: PUSH
75516: FOR_IN
75517: IFFALSE 75687
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75519: LD_ADDR_VAR 0 9
75523: PUSH
75524: LD_VAR 0 10
75528: PPUSH
75529: LD_VAR 0 8
75533: PPUSH
75534: LD_INT 5
75536: PPUSH
75537: CALL_OW 272
75541: PUSH
75542: LD_VAR 0 11
75546: PPUSH
75547: LD_VAR 0 8
75551: PPUSH
75552: LD_INT 5
75554: PPUSH
75555: CALL_OW 273
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75564: LD_VAR 0 9
75568: PUSH
75569: LD_INT 1
75571: ARRAY
75572: PPUSH
75573: LD_VAR 0 9
75577: PUSH
75578: LD_INT 2
75580: ARRAY
75581: PPUSH
75582: CALL_OW 488
75586: IFFALSE 75685
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75588: LD_ADDR_VAR 0 4
75592: PUSH
75593: LD_VAR 0 9
75597: PUSH
75598: LD_INT 1
75600: ARRAY
75601: PPUSH
75602: LD_VAR 0 9
75606: PUSH
75607: LD_INT 2
75609: ARRAY
75610: PPUSH
75611: CALL_OW 546
75615: ST_TO_ADDR
// if hex [ 1 ] then
75616: LD_VAR 0 4
75620: PUSH
75621: LD_INT 1
75623: ARRAY
75624: IFFALSE 75628
// continue ;
75626: GO 75516
// h := hex [ 2 ] ;
75628: LD_ADDR_VAR 0 13
75632: PUSH
75633: LD_VAR 0 4
75637: PUSH
75638: LD_INT 2
75640: ARRAY
75641: ST_TO_ADDR
// if h + 7 < height then
75642: LD_VAR 0 13
75646: PUSH
75647: LD_INT 7
75649: PLUS
75650: PUSH
75651: LD_VAR 0 15
75655: LESS
75656: IFFALSE 75685
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75658: LD_ADDR_VAR 0 18
75662: PUSH
75663: LD_INT 7
75665: PUSH
75666: LD_INT 28
75668: PUSH
75669: LD_INT 45
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: LIST
75676: PUSH
75677: LD_VAR 0 12
75681: ARRAY
75682: ST_TO_ADDR
// break ;
75683: GO 75687
// end ; end ; end ;
75685: GO 75516
75687: POP
75688: POP
// end ; if not weapon then
75689: LD_VAR 0 18
75693: NOT
75694: IFFALSE 75754
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75696: LD_ADDR_VAR 0 5
75700: PUSH
75701: LD_VAR 0 5
75705: PUSH
75706: LD_INT 11
75708: PUSH
75709: LD_INT 30
75711: PUSH
75712: LD_INT 49
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: LIST
75719: DIFF
75720: ST_TO_ADDR
// if not list then
75721: LD_VAR 0 5
75725: NOT
75726: IFFALSE 75730
// exit ;
75728: GO 75872
// weapon := list [ rand ( 1 , list ) ] ;
75730: LD_ADDR_VAR 0 18
75734: PUSH
75735: LD_VAR 0 5
75739: PUSH
75740: LD_INT 1
75742: PPUSH
75743: LD_VAR 0 5
75747: PPUSH
75748: CALL_OW 12
75752: ARRAY
75753: ST_TO_ADDR
// end ; if weapon then
75754: LD_VAR 0 18
75758: IFFALSE 75872
// begin tmp := CostOfWeapon ( weapon ) ;
75760: LD_ADDR_VAR 0 14
75764: PUSH
75765: LD_VAR 0 18
75769: PPUSH
75770: CALL_OW 451
75774: ST_TO_ADDR
// j := GetBase ( tower ) ;
75775: LD_ADDR_VAR 0 9
75779: PUSH
75780: LD_VAR 0 1
75784: PPUSH
75785: CALL_OW 274
75789: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75790: LD_VAR 0 9
75794: PPUSH
75795: LD_INT 1
75797: PPUSH
75798: CALL_OW 275
75802: PUSH
75803: LD_VAR 0 14
75807: PUSH
75808: LD_INT 1
75810: ARRAY
75811: GREATEREQUAL
75812: PUSH
75813: LD_VAR 0 9
75817: PPUSH
75818: LD_INT 2
75820: PPUSH
75821: CALL_OW 275
75825: PUSH
75826: LD_VAR 0 14
75830: PUSH
75831: LD_INT 2
75833: ARRAY
75834: GREATEREQUAL
75835: AND
75836: PUSH
75837: LD_VAR 0 9
75841: PPUSH
75842: LD_INT 3
75844: PPUSH
75845: CALL_OW 275
75849: PUSH
75850: LD_VAR 0 14
75854: PUSH
75855: LD_INT 3
75857: ARRAY
75858: GREATEREQUAL
75859: AND
75860: IFFALSE 75872
// result := weapon ;
75862: LD_ADDR_VAR 0 3
75866: PUSH
75867: LD_VAR 0 18
75871: ST_TO_ADDR
// end ; end ;
75872: LD_VAR 0 3
75876: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75877: LD_INT 0
75879: PPUSH
75880: PPUSH
// result := true ;
75881: LD_ADDR_VAR 0 3
75885: PUSH
75886: LD_INT 1
75888: ST_TO_ADDR
// if array1 = array2 then
75889: LD_VAR 0 1
75893: PUSH
75894: LD_VAR 0 2
75898: EQUAL
75899: IFFALSE 75959
// begin for i = 1 to array1 do
75901: LD_ADDR_VAR 0 4
75905: PUSH
75906: DOUBLE
75907: LD_INT 1
75909: DEC
75910: ST_TO_ADDR
75911: LD_VAR 0 1
75915: PUSH
75916: FOR_TO
75917: IFFALSE 75955
// if array1 [ i ] <> array2 [ i ] then
75919: LD_VAR 0 1
75923: PUSH
75924: LD_VAR 0 4
75928: ARRAY
75929: PUSH
75930: LD_VAR 0 2
75934: PUSH
75935: LD_VAR 0 4
75939: ARRAY
75940: NONEQUAL
75941: IFFALSE 75953
// begin result := false ;
75943: LD_ADDR_VAR 0 3
75947: PUSH
75948: LD_INT 0
75950: ST_TO_ADDR
// break ;
75951: GO 75955
// end ;
75953: GO 75916
75955: POP
75956: POP
// end else
75957: GO 75967
// result := false ;
75959: LD_ADDR_VAR 0 3
75963: PUSH
75964: LD_INT 0
75966: ST_TO_ADDR
// end ;
75967: LD_VAR 0 3
75971: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75972: LD_INT 0
75974: PPUSH
75975: PPUSH
75976: PPUSH
// pom := GetBase ( fac ) ;
75977: LD_ADDR_VAR 0 5
75981: PUSH
75982: LD_VAR 0 1
75986: PPUSH
75987: CALL_OW 274
75991: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75992: LD_ADDR_VAR 0 4
75996: PUSH
75997: LD_VAR 0 2
76001: PUSH
76002: LD_INT 1
76004: ARRAY
76005: PPUSH
76006: LD_VAR 0 2
76010: PUSH
76011: LD_INT 2
76013: ARRAY
76014: PPUSH
76015: LD_VAR 0 2
76019: PUSH
76020: LD_INT 3
76022: ARRAY
76023: PPUSH
76024: LD_VAR 0 2
76028: PUSH
76029: LD_INT 4
76031: ARRAY
76032: PPUSH
76033: CALL_OW 449
76037: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76038: LD_ADDR_VAR 0 3
76042: PUSH
76043: LD_VAR 0 5
76047: PPUSH
76048: LD_INT 1
76050: PPUSH
76051: CALL_OW 275
76055: PUSH
76056: LD_VAR 0 4
76060: PUSH
76061: LD_INT 1
76063: ARRAY
76064: GREATEREQUAL
76065: PUSH
76066: LD_VAR 0 5
76070: PPUSH
76071: LD_INT 2
76073: PPUSH
76074: CALL_OW 275
76078: PUSH
76079: LD_VAR 0 4
76083: PUSH
76084: LD_INT 2
76086: ARRAY
76087: GREATEREQUAL
76088: AND
76089: PUSH
76090: LD_VAR 0 5
76094: PPUSH
76095: LD_INT 3
76097: PPUSH
76098: CALL_OW 275
76102: PUSH
76103: LD_VAR 0 4
76107: PUSH
76108: LD_INT 3
76110: ARRAY
76111: GREATEREQUAL
76112: AND
76113: ST_TO_ADDR
// end ;
76114: LD_VAR 0 3
76118: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76119: LD_INT 0
76121: PPUSH
76122: PPUSH
76123: PPUSH
76124: PPUSH
// pom := GetBase ( building ) ;
76125: LD_ADDR_VAR 0 3
76129: PUSH
76130: LD_VAR 0 1
76134: PPUSH
76135: CALL_OW 274
76139: ST_TO_ADDR
// if not pom then
76140: LD_VAR 0 3
76144: NOT
76145: IFFALSE 76149
// exit ;
76147: GO 76319
// btype := GetBType ( building ) ;
76149: LD_ADDR_VAR 0 5
76153: PUSH
76154: LD_VAR 0 1
76158: PPUSH
76159: CALL_OW 266
76163: ST_TO_ADDR
// if btype = b_armoury then
76164: LD_VAR 0 5
76168: PUSH
76169: LD_INT 4
76171: EQUAL
76172: IFFALSE 76182
// btype := b_barracks ;
76174: LD_ADDR_VAR 0 5
76178: PUSH
76179: LD_INT 5
76181: ST_TO_ADDR
// if btype = b_depot then
76182: LD_VAR 0 5
76186: PUSH
76187: LD_INT 0
76189: EQUAL
76190: IFFALSE 76200
// btype := b_warehouse ;
76192: LD_ADDR_VAR 0 5
76196: PUSH
76197: LD_INT 1
76199: ST_TO_ADDR
// if btype = b_workshop then
76200: LD_VAR 0 5
76204: PUSH
76205: LD_INT 2
76207: EQUAL
76208: IFFALSE 76218
// btype := b_factory ;
76210: LD_ADDR_VAR 0 5
76214: PUSH
76215: LD_INT 3
76217: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76218: LD_ADDR_VAR 0 4
76222: PUSH
76223: LD_VAR 0 5
76227: PPUSH
76228: LD_VAR 0 1
76232: PPUSH
76233: CALL_OW 248
76237: PPUSH
76238: CALL_OW 450
76242: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76243: LD_ADDR_VAR 0 2
76247: PUSH
76248: LD_VAR 0 3
76252: PPUSH
76253: LD_INT 1
76255: PPUSH
76256: CALL_OW 275
76260: PUSH
76261: LD_VAR 0 4
76265: PUSH
76266: LD_INT 1
76268: ARRAY
76269: GREATEREQUAL
76270: PUSH
76271: LD_VAR 0 3
76275: PPUSH
76276: LD_INT 2
76278: PPUSH
76279: CALL_OW 275
76283: PUSH
76284: LD_VAR 0 4
76288: PUSH
76289: LD_INT 2
76291: ARRAY
76292: GREATEREQUAL
76293: AND
76294: PUSH
76295: LD_VAR 0 3
76299: PPUSH
76300: LD_INT 3
76302: PPUSH
76303: CALL_OW 275
76307: PUSH
76308: LD_VAR 0 4
76312: PUSH
76313: LD_INT 3
76315: ARRAY
76316: GREATEREQUAL
76317: AND
76318: ST_TO_ADDR
// end ;
76319: LD_VAR 0 2
76323: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76324: LD_INT 0
76326: PPUSH
76327: PPUSH
76328: PPUSH
// pom := GetBase ( building ) ;
76329: LD_ADDR_VAR 0 4
76333: PUSH
76334: LD_VAR 0 1
76338: PPUSH
76339: CALL_OW 274
76343: ST_TO_ADDR
// if not pom then
76344: LD_VAR 0 4
76348: NOT
76349: IFFALSE 76353
// exit ;
76351: GO 76454
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76353: LD_ADDR_VAR 0 5
76357: PUSH
76358: LD_VAR 0 2
76362: PPUSH
76363: LD_VAR 0 1
76367: PPUSH
76368: CALL_OW 248
76372: PPUSH
76373: CALL_OW 450
76377: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76378: LD_ADDR_VAR 0 3
76382: PUSH
76383: LD_VAR 0 4
76387: PPUSH
76388: LD_INT 1
76390: PPUSH
76391: CALL_OW 275
76395: PUSH
76396: LD_VAR 0 5
76400: PUSH
76401: LD_INT 1
76403: ARRAY
76404: GREATEREQUAL
76405: PUSH
76406: LD_VAR 0 4
76410: PPUSH
76411: LD_INT 2
76413: PPUSH
76414: CALL_OW 275
76418: PUSH
76419: LD_VAR 0 5
76423: PUSH
76424: LD_INT 2
76426: ARRAY
76427: GREATEREQUAL
76428: AND
76429: PUSH
76430: LD_VAR 0 4
76434: PPUSH
76435: LD_INT 3
76437: PPUSH
76438: CALL_OW 275
76442: PUSH
76443: LD_VAR 0 5
76447: PUSH
76448: LD_INT 3
76450: ARRAY
76451: GREATEREQUAL
76452: AND
76453: ST_TO_ADDR
// end ;
76454: LD_VAR 0 3
76458: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76459: LD_INT 0
76461: PPUSH
76462: PPUSH
76463: PPUSH
76464: PPUSH
76465: PPUSH
76466: PPUSH
76467: PPUSH
76468: PPUSH
76469: PPUSH
76470: PPUSH
// result := false ;
76471: LD_ADDR_VAR 0 6
76475: PUSH
76476: LD_INT 0
76478: ST_TO_ADDR
// if not base or not btype or not x or not y then
76479: LD_VAR 0 1
76483: NOT
76484: PUSH
76485: LD_VAR 0 2
76489: NOT
76490: OR
76491: PUSH
76492: LD_VAR 0 3
76496: NOT
76497: OR
76498: PUSH
76499: LD_VAR 0 4
76503: NOT
76504: OR
76505: IFFALSE 76509
// exit ;
76507: GO 77118
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76509: LD_ADDR_VAR 0 12
76513: PUSH
76514: LD_VAR 0 2
76518: PPUSH
76519: LD_VAR 0 3
76523: PPUSH
76524: LD_VAR 0 4
76528: PPUSH
76529: LD_VAR 0 5
76533: PPUSH
76534: LD_VAR 0 1
76538: PUSH
76539: LD_INT 1
76541: ARRAY
76542: PPUSH
76543: CALL_OW 248
76547: PPUSH
76548: LD_INT 0
76550: PPUSH
76551: CALL 77955 0 6
76555: ST_TO_ADDR
// if not hexes then
76556: LD_VAR 0 12
76560: NOT
76561: IFFALSE 76565
// exit ;
76563: GO 77118
// for i = 1 to hexes do
76565: LD_ADDR_VAR 0 7
76569: PUSH
76570: DOUBLE
76571: LD_INT 1
76573: DEC
76574: ST_TO_ADDR
76575: LD_VAR 0 12
76579: PUSH
76580: FOR_TO
76581: IFFALSE 77116
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76583: LD_ADDR_VAR 0 11
76587: PUSH
76588: LD_VAR 0 12
76592: PUSH
76593: LD_VAR 0 7
76597: ARRAY
76598: PUSH
76599: LD_INT 1
76601: ARRAY
76602: PPUSH
76603: LD_VAR 0 12
76607: PUSH
76608: LD_VAR 0 7
76612: ARRAY
76613: PUSH
76614: LD_INT 2
76616: ARRAY
76617: PPUSH
76618: CALL_OW 428
76622: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76623: LD_VAR 0 12
76627: PUSH
76628: LD_VAR 0 7
76632: ARRAY
76633: PUSH
76634: LD_INT 1
76636: ARRAY
76637: PPUSH
76638: LD_VAR 0 12
76642: PUSH
76643: LD_VAR 0 7
76647: ARRAY
76648: PUSH
76649: LD_INT 2
76651: ARRAY
76652: PPUSH
76653: CALL_OW 351
76657: PUSH
76658: LD_VAR 0 12
76662: PUSH
76663: LD_VAR 0 7
76667: ARRAY
76668: PUSH
76669: LD_INT 1
76671: ARRAY
76672: PPUSH
76673: LD_VAR 0 12
76677: PUSH
76678: LD_VAR 0 7
76682: ARRAY
76683: PUSH
76684: LD_INT 2
76686: ARRAY
76687: PPUSH
76688: CALL_OW 488
76692: NOT
76693: OR
76694: PUSH
76695: LD_VAR 0 11
76699: PPUSH
76700: CALL_OW 247
76704: PUSH
76705: LD_INT 3
76707: EQUAL
76708: OR
76709: IFFALSE 76715
// exit ;
76711: POP
76712: POP
76713: GO 77118
// if not tmp or not tmp in base then
76715: LD_VAR 0 11
76719: NOT
76720: PUSH
76721: LD_VAR 0 11
76725: PUSH
76726: LD_VAR 0 1
76730: IN
76731: NOT
76732: OR
76733: IFFALSE 76737
// continue ;
76735: GO 76580
// result := true ;
76737: LD_ADDR_VAR 0 6
76741: PUSH
76742: LD_INT 1
76744: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76745: LD_ADDR_VAR 0 15
76749: PUSH
76750: LD_VAR 0 1
76754: PPUSH
76755: LD_INT 22
76757: PUSH
76758: LD_VAR 0 11
76762: PPUSH
76763: CALL_OW 255
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 2
76774: PUSH
76775: LD_INT 30
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 30
76787: PUSH
76788: LD_INT 1
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: LIST
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PPUSH
76804: CALL_OW 72
76808: ST_TO_ADDR
// if dep then
76809: LD_VAR 0 15
76813: IFFALSE 76949
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76815: LD_ADDR_VAR 0 14
76819: PUSH
76820: LD_VAR 0 15
76824: PUSH
76825: LD_INT 1
76827: ARRAY
76828: PPUSH
76829: CALL_OW 250
76833: PPUSH
76834: LD_VAR 0 15
76838: PUSH
76839: LD_INT 1
76841: ARRAY
76842: PPUSH
76843: CALL_OW 254
76847: PPUSH
76848: LD_INT 5
76850: PPUSH
76851: CALL_OW 272
76855: PUSH
76856: LD_VAR 0 15
76860: PUSH
76861: LD_INT 1
76863: ARRAY
76864: PPUSH
76865: CALL_OW 251
76869: PPUSH
76870: LD_VAR 0 15
76874: PUSH
76875: LD_INT 1
76877: ARRAY
76878: PPUSH
76879: CALL_OW 254
76883: PPUSH
76884: LD_INT 5
76886: PPUSH
76887: CALL_OW 273
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76896: LD_VAR 0 14
76900: PUSH
76901: LD_INT 1
76903: ARRAY
76904: PPUSH
76905: LD_VAR 0 14
76909: PUSH
76910: LD_INT 2
76912: ARRAY
76913: PPUSH
76914: CALL_OW 488
76918: IFFALSE 76949
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76920: LD_VAR 0 11
76924: PPUSH
76925: LD_VAR 0 14
76929: PUSH
76930: LD_INT 1
76932: ARRAY
76933: PPUSH
76934: LD_VAR 0 14
76938: PUSH
76939: LD_INT 2
76941: ARRAY
76942: PPUSH
76943: CALL_OW 111
// continue ;
76947: GO 76580
// end ; end ; r := GetDir ( tmp ) ;
76949: LD_ADDR_VAR 0 13
76953: PUSH
76954: LD_VAR 0 11
76958: PPUSH
76959: CALL_OW 254
76963: ST_TO_ADDR
// if r = 5 then
76964: LD_VAR 0 13
76968: PUSH
76969: LD_INT 5
76971: EQUAL
76972: IFFALSE 76982
// r := 0 ;
76974: LD_ADDR_VAR 0 13
76978: PUSH
76979: LD_INT 0
76981: ST_TO_ADDR
// for j = r to 5 do
76982: LD_ADDR_VAR 0 8
76986: PUSH
76987: DOUBLE
76988: LD_VAR 0 13
76992: DEC
76993: ST_TO_ADDR
76994: LD_INT 5
76996: PUSH
76997: FOR_TO
76998: IFFALSE 77112
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77000: LD_ADDR_VAR 0 9
77004: PUSH
77005: LD_VAR 0 11
77009: PPUSH
77010: CALL_OW 250
77014: PPUSH
77015: LD_VAR 0 8
77019: PPUSH
77020: LD_INT 2
77022: PPUSH
77023: CALL_OW 272
77027: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77028: LD_ADDR_VAR 0 10
77032: PUSH
77033: LD_VAR 0 11
77037: PPUSH
77038: CALL_OW 251
77042: PPUSH
77043: LD_VAR 0 8
77047: PPUSH
77048: LD_INT 2
77050: PPUSH
77051: CALL_OW 273
77055: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77056: LD_VAR 0 9
77060: PPUSH
77061: LD_VAR 0 10
77065: PPUSH
77066: CALL_OW 488
77070: PUSH
77071: LD_VAR 0 9
77075: PPUSH
77076: LD_VAR 0 10
77080: PPUSH
77081: CALL_OW 428
77085: NOT
77086: AND
77087: IFFALSE 77110
// begin ComMoveXY ( tmp , _x , _y ) ;
77089: LD_VAR 0 11
77093: PPUSH
77094: LD_VAR 0 9
77098: PPUSH
77099: LD_VAR 0 10
77103: PPUSH
77104: CALL_OW 111
// break ;
77108: GO 77112
// end ; end ;
77110: GO 76997
77112: POP
77113: POP
// end ;
77114: GO 76580
77116: POP
77117: POP
// end ;
77118: LD_VAR 0 6
77122: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77123: LD_INT 0
77125: PPUSH
77126: PPUSH
77127: PPUSH
77128: PPUSH
77129: PPUSH
77130: PPUSH
77131: PPUSH
77132: PPUSH
77133: PPUSH
77134: PPUSH
// result := false ;
77135: LD_ADDR_VAR 0 6
77139: PUSH
77140: LD_INT 0
77142: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77143: LD_VAR 0 1
77147: NOT
77148: PUSH
77149: LD_VAR 0 1
77153: PPUSH
77154: CALL_OW 266
77158: PUSH
77159: LD_INT 0
77161: PUSH
77162: LD_INT 1
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: IN
77169: NOT
77170: OR
77171: PUSH
77172: LD_VAR 0 2
77176: NOT
77177: OR
77178: PUSH
77179: LD_VAR 0 5
77183: PUSH
77184: LD_INT 0
77186: PUSH
77187: LD_INT 1
77189: PUSH
77190: LD_INT 2
77192: PUSH
77193: LD_INT 3
77195: PUSH
77196: LD_INT 4
77198: PUSH
77199: LD_INT 5
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: IN
77210: NOT
77211: OR
77212: PUSH
77213: LD_VAR 0 3
77217: PPUSH
77218: LD_VAR 0 4
77222: PPUSH
77223: CALL_OW 488
77227: NOT
77228: OR
77229: IFFALSE 77233
// exit ;
77231: GO 77950
// pom := GetBase ( depot ) ;
77233: LD_ADDR_VAR 0 10
77237: PUSH
77238: LD_VAR 0 1
77242: PPUSH
77243: CALL_OW 274
77247: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77248: LD_ADDR_VAR 0 11
77252: PUSH
77253: LD_VAR 0 2
77257: PPUSH
77258: LD_VAR 0 1
77262: PPUSH
77263: CALL_OW 248
77267: PPUSH
77268: CALL_OW 450
77272: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77273: LD_VAR 0 10
77277: PPUSH
77278: LD_INT 1
77280: PPUSH
77281: CALL_OW 275
77285: PUSH
77286: LD_VAR 0 11
77290: PUSH
77291: LD_INT 1
77293: ARRAY
77294: GREATEREQUAL
77295: PUSH
77296: LD_VAR 0 10
77300: PPUSH
77301: LD_INT 2
77303: PPUSH
77304: CALL_OW 275
77308: PUSH
77309: LD_VAR 0 11
77313: PUSH
77314: LD_INT 2
77316: ARRAY
77317: GREATEREQUAL
77318: AND
77319: PUSH
77320: LD_VAR 0 10
77324: PPUSH
77325: LD_INT 3
77327: PPUSH
77328: CALL_OW 275
77332: PUSH
77333: LD_VAR 0 11
77337: PUSH
77338: LD_INT 3
77340: ARRAY
77341: GREATEREQUAL
77342: AND
77343: NOT
77344: IFFALSE 77348
// exit ;
77346: GO 77950
// if GetBType ( depot ) = b_depot then
77348: LD_VAR 0 1
77352: PPUSH
77353: CALL_OW 266
77357: PUSH
77358: LD_INT 0
77360: EQUAL
77361: IFFALSE 77373
// dist := 28 else
77363: LD_ADDR_VAR 0 14
77367: PUSH
77368: LD_INT 28
77370: ST_TO_ADDR
77371: GO 77381
// dist := 36 ;
77373: LD_ADDR_VAR 0 14
77377: PUSH
77378: LD_INT 36
77380: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77381: LD_VAR 0 1
77385: PPUSH
77386: LD_VAR 0 3
77390: PPUSH
77391: LD_VAR 0 4
77395: PPUSH
77396: CALL_OW 297
77400: PUSH
77401: LD_VAR 0 14
77405: GREATER
77406: IFFALSE 77410
// exit ;
77408: GO 77950
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77410: LD_ADDR_VAR 0 12
77414: PUSH
77415: LD_VAR 0 2
77419: PPUSH
77420: LD_VAR 0 3
77424: PPUSH
77425: LD_VAR 0 4
77429: PPUSH
77430: LD_VAR 0 5
77434: PPUSH
77435: LD_VAR 0 1
77439: PPUSH
77440: CALL_OW 248
77444: PPUSH
77445: LD_INT 0
77447: PPUSH
77448: CALL 77955 0 6
77452: ST_TO_ADDR
// if not hexes then
77453: LD_VAR 0 12
77457: NOT
77458: IFFALSE 77462
// exit ;
77460: GO 77950
// hex := GetHexInfo ( x , y ) ;
77462: LD_ADDR_VAR 0 15
77466: PUSH
77467: LD_VAR 0 3
77471: PPUSH
77472: LD_VAR 0 4
77476: PPUSH
77477: CALL_OW 546
77481: ST_TO_ADDR
// if hex [ 1 ] then
77482: LD_VAR 0 15
77486: PUSH
77487: LD_INT 1
77489: ARRAY
77490: IFFALSE 77494
// exit ;
77492: GO 77950
// height := hex [ 2 ] ;
77494: LD_ADDR_VAR 0 13
77498: PUSH
77499: LD_VAR 0 15
77503: PUSH
77504: LD_INT 2
77506: ARRAY
77507: ST_TO_ADDR
// for i = 1 to hexes do
77508: LD_ADDR_VAR 0 7
77512: PUSH
77513: DOUBLE
77514: LD_INT 1
77516: DEC
77517: ST_TO_ADDR
77518: LD_VAR 0 12
77522: PUSH
77523: FOR_TO
77524: IFFALSE 77854
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77526: LD_VAR 0 12
77530: PUSH
77531: LD_VAR 0 7
77535: ARRAY
77536: PUSH
77537: LD_INT 1
77539: ARRAY
77540: PPUSH
77541: LD_VAR 0 12
77545: PUSH
77546: LD_VAR 0 7
77550: ARRAY
77551: PUSH
77552: LD_INT 2
77554: ARRAY
77555: PPUSH
77556: CALL_OW 488
77560: NOT
77561: PUSH
77562: LD_VAR 0 12
77566: PUSH
77567: LD_VAR 0 7
77571: ARRAY
77572: PUSH
77573: LD_INT 1
77575: ARRAY
77576: PPUSH
77577: LD_VAR 0 12
77581: PUSH
77582: LD_VAR 0 7
77586: ARRAY
77587: PUSH
77588: LD_INT 2
77590: ARRAY
77591: PPUSH
77592: CALL_OW 428
77596: PUSH
77597: LD_INT 0
77599: GREATER
77600: OR
77601: PUSH
77602: LD_VAR 0 12
77606: PUSH
77607: LD_VAR 0 7
77611: ARRAY
77612: PUSH
77613: LD_INT 1
77615: ARRAY
77616: PPUSH
77617: LD_VAR 0 12
77621: PUSH
77622: LD_VAR 0 7
77626: ARRAY
77627: PUSH
77628: LD_INT 2
77630: ARRAY
77631: PPUSH
77632: CALL_OW 351
77636: OR
77637: IFFALSE 77643
// exit ;
77639: POP
77640: POP
77641: GO 77950
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77643: LD_ADDR_VAR 0 8
77647: PUSH
77648: LD_VAR 0 12
77652: PUSH
77653: LD_VAR 0 7
77657: ARRAY
77658: PUSH
77659: LD_INT 1
77661: ARRAY
77662: PPUSH
77663: LD_VAR 0 12
77667: PUSH
77668: LD_VAR 0 7
77672: ARRAY
77673: PUSH
77674: LD_INT 2
77676: ARRAY
77677: PPUSH
77678: CALL_OW 546
77682: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77683: LD_VAR 0 8
77687: PUSH
77688: LD_INT 1
77690: ARRAY
77691: PUSH
77692: LD_VAR 0 8
77696: PUSH
77697: LD_INT 2
77699: ARRAY
77700: PUSH
77701: LD_VAR 0 13
77705: PUSH
77706: LD_INT 2
77708: PLUS
77709: GREATER
77710: OR
77711: PUSH
77712: LD_VAR 0 8
77716: PUSH
77717: LD_INT 2
77719: ARRAY
77720: PUSH
77721: LD_VAR 0 13
77725: PUSH
77726: LD_INT 2
77728: MINUS
77729: LESS
77730: OR
77731: PUSH
77732: LD_VAR 0 8
77736: PUSH
77737: LD_INT 3
77739: ARRAY
77740: PUSH
77741: LD_INT 0
77743: PUSH
77744: LD_INT 8
77746: PUSH
77747: LD_INT 9
77749: PUSH
77750: LD_INT 10
77752: PUSH
77753: LD_INT 11
77755: PUSH
77756: LD_INT 12
77758: PUSH
77759: LD_INT 13
77761: PUSH
77762: LD_INT 16
77764: PUSH
77765: LD_INT 17
77767: PUSH
77768: LD_INT 18
77770: PUSH
77771: LD_INT 19
77773: PUSH
77774: LD_INT 20
77776: PUSH
77777: LD_INT 21
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: LIST
77787: LIST
77788: LIST
77789: LIST
77790: LIST
77791: LIST
77792: LIST
77793: LIST
77794: IN
77795: NOT
77796: OR
77797: PUSH
77798: LD_VAR 0 8
77802: PUSH
77803: LD_INT 5
77805: ARRAY
77806: NOT
77807: OR
77808: PUSH
77809: LD_VAR 0 8
77813: PUSH
77814: LD_INT 6
77816: ARRAY
77817: PUSH
77818: LD_INT 1
77820: PUSH
77821: LD_INT 2
77823: PUSH
77824: LD_INT 7
77826: PUSH
77827: LD_INT 9
77829: PUSH
77830: LD_INT 10
77832: PUSH
77833: LD_INT 11
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: IN
77844: NOT
77845: OR
77846: IFFALSE 77852
// exit ;
77848: POP
77849: POP
77850: GO 77950
// end ;
77852: GO 77523
77854: POP
77855: POP
// side := GetSide ( depot ) ;
77856: LD_ADDR_VAR 0 9
77860: PUSH
77861: LD_VAR 0 1
77865: PPUSH
77866: CALL_OW 255
77870: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77871: LD_VAR 0 9
77875: PPUSH
77876: LD_VAR 0 3
77880: PPUSH
77881: LD_VAR 0 4
77885: PPUSH
77886: LD_INT 20
77888: PPUSH
77889: CALL 70604 0 4
77893: PUSH
77894: LD_INT 4
77896: ARRAY
77897: IFFALSE 77901
// exit ;
77899: GO 77950
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77901: LD_VAR 0 2
77905: PUSH
77906: LD_INT 29
77908: PUSH
77909: LD_INT 30
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: IN
77916: PUSH
77917: LD_VAR 0 3
77921: PPUSH
77922: LD_VAR 0 4
77926: PPUSH
77927: LD_VAR 0 9
77931: PPUSH
77932: CALL_OW 440
77936: NOT
77937: AND
77938: IFFALSE 77942
// exit ;
77940: GO 77950
// result := true ;
77942: LD_ADDR_VAR 0 6
77946: PUSH
77947: LD_INT 1
77949: ST_TO_ADDR
// end ;
77950: LD_VAR 0 6
77954: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
77955: LD_INT 0
77957: PPUSH
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
77962: PPUSH
77963: PPUSH
77964: PPUSH
77965: PPUSH
77966: PPUSH
77967: PPUSH
77968: PPUSH
77969: PPUSH
77970: PPUSH
77971: PPUSH
77972: PPUSH
77973: PPUSH
77974: PPUSH
77975: PPUSH
77976: PPUSH
77977: PPUSH
77978: PPUSH
77979: PPUSH
77980: PPUSH
77981: PPUSH
77982: PPUSH
77983: PPUSH
77984: PPUSH
77985: PPUSH
77986: PPUSH
77987: PPUSH
77988: PPUSH
77989: PPUSH
77990: PPUSH
77991: PPUSH
77992: PPUSH
77993: PPUSH
77994: PPUSH
77995: PPUSH
77996: PPUSH
77997: PPUSH
77998: PPUSH
77999: PPUSH
78000: PPUSH
78001: PPUSH
78002: PPUSH
78003: PPUSH
78004: PPUSH
78005: PPUSH
78006: PPUSH
78007: PPUSH
78008: PPUSH
78009: PPUSH
78010: PPUSH
78011: PPUSH
78012: PPUSH
78013: PPUSH
78014: PPUSH
// result = [ ] ;
78015: LD_ADDR_VAR 0 7
78019: PUSH
78020: EMPTY
78021: ST_TO_ADDR
// temp_list = [ ] ;
78022: LD_ADDR_VAR 0 9
78026: PUSH
78027: EMPTY
78028: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78029: LD_VAR 0 4
78033: PUSH
78034: LD_INT 0
78036: PUSH
78037: LD_INT 1
78039: PUSH
78040: LD_INT 2
78042: PUSH
78043: LD_INT 3
78045: PUSH
78046: LD_INT 4
78048: PUSH
78049: LD_INT 5
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: IN
78060: NOT
78061: PUSH
78062: LD_VAR 0 1
78066: PUSH
78067: LD_INT 0
78069: PUSH
78070: LD_INT 1
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: IN
78077: PUSH
78078: LD_VAR 0 5
78082: PUSH
78083: LD_INT 1
78085: PUSH
78086: LD_INT 2
78088: PUSH
78089: LD_INT 3
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: LIST
78096: IN
78097: NOT
78098: AND
78099: OR
78100: IFFALSE 78104
// exit ;
78102: GO 96495
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78104: LD_VAR 0 1
78108: PUSH
78109: LD_INT 6
78111: PUSH
78112: LD_INT 7
78114: PUSH
78115: LD_INT 8
78117: PUSH
78118: LD_INT 13
78120: PUSH
78121: LD_INT 12
78123: PUSH
78124: LD_INT 15
78126: PUSH
78127: LD_INT 11
78129: PUSH
78130: LD_INT 14
78132: PUSH
78133: LD_INT 10
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: IN
78147: IFFALSE 78157
// btype = b_lab ;
78149: LD_ADDR_VAR 0 1
78153: PUSH
78154: LD_INT 6
78156: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78157: LD_VAR 0 6
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 1
78167: PUSH
78168: LD_INT 2
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: LIST
78175: IN
78176: NOT
78177: PUSH
78178: LD_VAR 0 1
78182: PUSH
78183: LD_INT 0
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: LD_INT 3
78194: PUSH
78195: LD_INT 6
78197: PUSH
78198: LD_INT 36
78200: PUSH
78201: LD_INT 4
78203: PUSH
78204: LD_INT 5
78206: PUSH
78207: LD_INT 31
78209: PUSH
78210: LD_INT 32
78212: PUSH
78213: LD_INT 33
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: IN
78229: NOT
78230: PUSH
78231: LD_VAR 0 6
78235: PUSH
78236: LD_INT 1
78238: EQUAL
78239: AND
78240: OR
78241: PUSH
78242: LD_VAR 0 1
78246: PUSH
78247: LD_INT 2
78249: PUSH
78250: LD_INT 3
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: IN
78257: NOT
78258: PUSH
78259: LD_VAR 0 6
78263: PUSH
78264: LD_INT 2
78266: EQUAL
78267: AND
78268: OR
78269: IFFALSE 78279
// mode = 0 ;
78271: LD_ADDR_VAR 0 6
78275: PUSH
78276: LD_INT 0
78278: ST_TO_ADDR
// case mode of 0 :
78279: LD_VAR 0 6
78283: PUSH
78284: LD_INT 0
78286: DOUBLE
78287: EQUAL
78288: IFTRUE 78292
78290: GO 89745
78292: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78293: LD_ADDR_VAR 0 11
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 0
78310: PUSH
78311: LD_INT 1
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: PUSH
78322: LD_INT 0
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 1
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 0
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 1
78351: NEG
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 1
78362: NEG
78363: PUSH
78364: LD_INT 1
78366: NEG
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 1
78374: NEG
78375: PUSH
78376: LD_INT 2
78378: NEG
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 0
78386: PUSH
78387: LD_INT 2
78389: NEG
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 1
78397: PUSH
78398: LD_INT 1
78400: NEG
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 1
78408: PUSH
78409: LD_INT 2
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 0
78418: PUSH
78419: LD_INT 2
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 1
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: PUSH
78433: EMPTY
78434: LIST
78435: LIST
78436: PUSH
78437: LD_INT 1
78439: PUSH
78440: LD_INT 3
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: LD_INT 3
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PUSH
78457: LD_INT 1
78459: NEG
78460: PUSH
78461: LD_INT 2
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: LIST
78476: LIST
78477: LIST
78478: LIST
78479: LIST
78480: LIST
78481: LIST
78482: LIST
78483: LIST
78484: LIST
78485: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78486: LD_ADDR_VAR 0 12
78490: PUSH
78491: LD_INT 0
78493: PUSH
78494: LD_INT 0
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 0
78503: PUSH
78504: LD_INT 1
78506: NEG
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: LD_INT 0
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 1
78524: PUSH
78525: LD_INT 1
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 0
78534: PUSH
78535: LD_INT 1
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: NEG
78545: PUSH
78546: LD_INT 0
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: NEG
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 1
78567: PUSH
78568: LD_INT 1
78570: NEG
78571: PUSH
78572: EMPTY
78573: LIST
78574: LIST
78575: PUSH
78576: LD_INT 2
78578: PUSH
78579: LD_INT 0
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 2
78588: PUSH
78589: LD_INT 1
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: NEG
78599: PUSH
78600: LD_INT 1
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 2
78609: NEG
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 2
78620: NEG
78621: PUSH
78622: LD_INT 1
78624: NEG
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 2
78632: NEG
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: LD_INT 0
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 3
78654: NEG
78655: PUSH
78656: LD_INT 1
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78682: LD_ADDR_VAR 0 13
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: LD_INT 0
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 0
78699: PUSH
78700: LD_INT 1
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 1
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 1
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 0
78730: PUSH
78731: LD_INT 1
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 1
78740: NEG
78741: PUSH
78742: LD_INT 0
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 1
78751: NEG
78752: PUSH
78753: LD_INT 1
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: NEG
78764: PUSH
78765: LD_INT 2
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 2
78785: PUSH
78786: LD_INT 2
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 1
78795: PUSH
78796: LD_INT 2
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 2
78805: NEG
78806: PUSH
78807: LD_INT 1
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 2
78817: NEG
78818: PUSH
78819: LD_INT 2
78821: NEG
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 2
78829: NEG
78830: PUSH
78831: LD_INT 3
78833: NEG
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 3
78841: NEG
78842: PUSH
78843: LD_INT 2
78845: NEG
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 3
78853: NEG
78854: PUSH
78855: LD_INT 3
78857: NEG
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78881: LD_ADDR_VAR 0 14
78885: PUSH
78886: LD_INT 0
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 0
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 1
78909: PUSH
78910: LD_INT 0
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 1
78919: PUSH
78920: LD_INT 1
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 0
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 1
78939: NEG
78940: PUSH
78941: LD_INT 0
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 1
78950: NEG
78951: PUSH
78952: LD_INT 1
78954: NEG
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 1
78962: NEG
78963: PUSH
78964: LD_INT 2
78966: NEG
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 0
78974: PUSH
78975: LD_INT 2
78977: NEG
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 1
78985: PUSH
78986: LD_INT 1
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 1
78996: PUSH
78997: LD_INT 2
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 0
79006: PUSH
79007: LD_INT 2
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 1
79016: NEG
79017: PUSH
79018: LD_INT 1
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: LD_INT 3
79031: NEG
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: LD_INT 3
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 2
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79077: LD_ADDR_VAR 0 15
79081: PUSH
79082: LD_INT 0
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 1
79105: PUSH
79106: LD_INT 0
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 1
79115: PUSH
79116: LD_INT 1
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 0
79125: PUSH
79126: LD_INT 1
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 1
79135: NEG
79136: PUSH
79137: LD_INT 0
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 1
79146: NEG
79147: PUSH
79148: LD_INT 1
79150: NEG
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 1
79158: PUSH
79159: LD_INT 1
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 2
79179: PUSH
79180: LD_INT 1
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 1
79189: NEG
79190: PUSH
79191: LD_INT 1
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: LD_INT 0
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 2
79211: NEG
79212: PUSH
79213: LD_INT 1
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 2
79223: PUSH
79224: LD_INT 1
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 3
79234: PUSH
79235: LD_INT 0
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 3
79244: PUSH
79245: LD_INT 1
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79270: LD_ADDR_VAR 0 16
79274: PUSH
79275: LD_INT 0
79277: PUSH
79278: LD_INT 0
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 0
79287: PUSH
79288: LD_INT 1
79290: NEG
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 1
79298: PUSH
79299: LD_INT 0
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 1
79308: PUSH
79309: LD_INT 1
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 0
79318: PUSH
79319: LD_INT 1
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 1
79328: NEG
79329: PUSH
79330: LD_INT 0
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 1
79339: NEG
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: NEG
79352: PUSH
79353: LD_INT 2
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 2
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 2
79373: PUSH
79374: LD_INT 2
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: LD_INT 2
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 2
79393: NEG
79394: PUSH
79395: LD_INT 1
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 2
79405: NEG
79406: PUSH
79407: LD_INT 2
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 3
79417: PUSH
79418: LD_INT 2
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 3
79427: PUSH
79428: LD_INT 3
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 2
79437: PUSH
79438: LD_INT 3
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79463: LD_ADDR_VAR 0 17
79467: PUSH
79468: LD_INT 0
79470: PUSH
79471: LD_INT 0
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: LD_INT 1
79483: NEG
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 1
79491: PUSH
79492: LD_INT 0
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 1
79501: PUSH
79502: LD_INT 1
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 0
79511: PUSH
79512: LD_INT 1
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 1
79521: NEG
79522: PUSH
79523: LD_INT 0
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 1
79532: NEG
79533: PUSH
79534: LD_INT 1
79536: NEG
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 1
79544: NEG
79545: PUSH
79546: LD_INT 2
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: LD_INT 2
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 1
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 2
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: LD_INT 1
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 2
79598: PUSH
79599: LD_INT 2
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 1
79608: PUSH
79609: LD_INT 2
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 0
79618: PUSH
79619: LD_INT 2
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 1
79628: NEG
79629: PUSH
79630: LD_INT 1
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: LD_INT 0
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 2
79650: NEG
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 2
79662: NEG
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79693: LD_ADDR_VAR 0 18
79697: PUSH
79698: LD_INT 0
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 0
79710: PUSH
79711: LD_INT 1
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 1
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: LD_INT 1
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 0
79741: PUSH
79742: LD_INT 1
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 1
79751: NEG
79752: PUSH
79753: LD_INT 0
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 1
79762: NEG
79763: PUSH
79764: LD_INT 1
79766: NEG
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 1
79774: NEG
79775: PUSH
79776: LD_INT 2
79778: NEG
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 0
79786: PUSH
79787: LD_INT 2
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 1
79797: PUSH
79798: LD_INT 1
79800: NEG
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 2
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 2
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 2
79828: PUSH
79829: LD_INT 2
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 0
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: LD_INT 1
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 2
79869: NEG
79870: PUSH
79871: LD_INT 0
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 2
79880: NEG
79881: PUSH
79882: LD_INT 1
79884: NEG
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: NEG
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79923: LD_ADDR_VAR 0 19
79927: PUSH
79928: LD_INT 0
79930: PUSH
79931: LD_INT 0
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 1
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: LD_INT 0
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 1
79961: PUSH
79962: LD_INT 1
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: NEG
79982: PUSH
79983: LD_INT 0
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: NEG
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: LD_INT 2
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: LD_INT 1
80030: NEG
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 2
80038: PUSH
80039: LD_INT 0
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 2
80058: PUSH
80059: LD_INT 2
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 1
80068: PUSH
80069: LD_INT 2
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: LD_INT 0
80078: PUSH
80079: LD_INT 2
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 1
80088: NEG
80089: PUSH
80090: LD_INT 1
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 2
80099: NEG
80100: PUSH
80101: LD_INT 0
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 2
80110: NEG
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: NEG
80123: PUSH
80124: LD_INT 2
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80153: LD_ADDR_VAR 0 20
80157: PUSH
80158: LD_INT 0
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 0
80170: PUSH
80171: LD_INT 1
80173: NEG
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 1
80181: PUSH
80182: LD_INT 0
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 1
80191: PUSH
80192: LD_INT 1
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 0
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: NEG
80212: PUSH
80213: LD_INT 0
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: NEG
80223: PUSH
80224: LD_INT 1
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 1
80234: NEG
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 0
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: PUSH
80258: LD_INT 1
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 2
80268: PUSH
80269: LD_INT 0
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 2
80278: PUSH
80279: LD_INT 1
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 2
80288: PUSH
80289: LD_INT 2
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 1
80298: PUSH
80299: LD_INT 2
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 0
80308: PUSH
80309: LD_INT 2
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: LD_INT 1
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 2
80329: NEG
80330: PUSH
80331: LD_INT 0
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 2
80340: NEG
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: LD_INT 2
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80383: LD_ADDR_VAR 0 21
80387: PUSH
80388: LD_INT 0
80390: PUSH
80391: LD_INT 0
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: LD_INT 1
80403: NEG
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 1
80411: PUSH
80412: LD_INT 0
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 1
80421: PUSH
80422: LD_INT 1
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 0
80431: PUSH
80432: LD_INT 1
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: LD_INT 0
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: LD_INT 1
80456: NEG
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 1
80464: NEG
80465: PUSH
80466: LD_INT 2
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 0
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 1
80487: PUSH
80488: LD_INT 1
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 2
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 2
80508: PUSH
80509: LD_INT 1
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 2
80518: PUSH
80519: LD_INT 2
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 1
80528: PUSH
80529: LD_INT 2
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 0
80538: PUSH
80539: LD_INT 2
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 1
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 2
80559: NEG
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 2
80570: NEG
80571: PUSH
80572: LD_INT 1
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 2
80582: NEG
80583: PUSH
80584: LD_INT 2
80586: NEG
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80613: LD_ADDR_VAR 0 22
80617: PUSH
80618: LD_INT 0
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: LD_INT 1
80633: NEG
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: LD_INT 0
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 1
80651: PUSH
80652: LD_INT 1
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 1
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: NEG
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: NEG
80683: PUSH
80684: LD_INT 1
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: LD_INT 2
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 1
80717: PUSH
80718: LD_INT 1
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: PUSH
80739: LD_INT 1
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 2
80748: PUSH
80749: LD_INT 2
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 1
80758: PUSH
80759: LD_INT 2
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 2
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 2
80789: NEG
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 2
80800: NEG
80801: PUSH
80802: LD_INT 1
80804: NEG
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 2
80812: NEG
80813: PUSH
80814: LD_INT 2
80816: NEG
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80843: LD_ADDR_VAR 0 23
80847: PUSH
80848: LD_INT 0
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 0
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 1
80871: PUSH
80872: LD_INT 0
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 1
80881: PUSH
80882: LD_INT 1
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 0
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 1
80901: NEG
80902: PUSH
80903: LD_INT 0
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 1
80912: NEG
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 1
80924: NEG
80925: PUSH
80926: LD_INT 2
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 0
80936: PUSH
80937: LD_INT 2
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: LD_INT 1
80950: NEG
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 2
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 2
80968: PUSH
80969: LD_INT 1
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 2
80978: PUSH
80979: LD_INT 2
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 1
80988: PUSH
80989: LD_INT 2
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 0
80998: PUSH
80999: LD_INT 2
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 1
81008: NEG
81009: PUSH
81010: LD_INT 1
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 2
81019: NEG
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: NEG
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: NEG
81043: PUSH
81044: LD_INT 2
81046: NEG
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 2
81054: NEG
81055: PUSH
81056: LD_INT 3
81058: NEG
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 1
81066: NEG
81067: PUSH
81068: LD_INT 3
81070: NEG
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 1
81078: PUSH
81079: LD_INT 2
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 2
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81123: LD_ADDR_VAR 0 24
81127: PUSH
81128: LD_INT 0
81130: PUSH
81131: LD_INT 0
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 0
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 1
81151: PUSH
81152: LD_INT 0
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 0
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 1
81181: NEG
81182: PUSH
81183: LD_INT 0
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 1
81192: NEG
81193: PUSH
81194: LD_INT 1
81196: NEG
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: LD_INT 2
81208: NEG
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: LD_INT 2
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: PUSH
81228: LD_INT 1
81230: NEG
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 2
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 2
81248: PUSH
81249: LD_INT 1
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: PUSH
81259: LD_INT 2
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 1
81268: PUSH
81269: LD_INT 2
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 0
81278: PUSH
81279: LD_INT 2
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 1
81288: NEG
81289: PUSH
81290: LD_INT 1
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 2
81299: NEG
81300: PUSH
81301: LD_INT 0
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 2
81310: NEG
81311: PUSH
81312: LD_INT 1
81314: NEG
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 2
81322: NEG
81323: PUSH
81324: LD_INT 2
81326: NEG
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 1
81334: PUSH
81335: LD_INT 2
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 2
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 3
81356: PUSH
81357: LD_INT 1
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 3
81366: PUSH
81367: LD_INT 2
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81399: LD_ADDR_VAR 0 25
81403: PUSH
81404: LD_INT 0
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 0
81416: PUSH
81417: LD_INT 1
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: LD_INT 0
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 1
81437: PUSH
81438: LD_INT 1
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: LD_INT 0
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 1
81468: NEG
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 1
81480: NEG
81481: PUSH
81482: LD_INT 2
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 0
81492: PUSH
81493: LD_INT 2
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 2
81514: PUSH
81515: LD_INT 0
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 2
81524: PUSH
81525: LD_INT 1
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 2
81534: PUSH
81535: LD_INT 2
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: PUSH
81545: LD_INT 2
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 0
81554: PUSH
81555: LD_INT 2
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 2
81575: NEG
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 2
81586: NEG
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 2
81598: NEG
81599: PUSH
81600: LD_INT 2
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 3
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 3
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 2
81630: PUSH
81631: LD_INT 3
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: LD_INT 3
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: LIST
81672: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81673: LD_ADDR_VAR 0 26
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 0
81690: PUSH
81691: LD_INT 1
81693: NEG
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: LD_INT 0
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 1
81711: PUSH
81712: LD_INT 1
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 0
81721: PUSH
81722: LD_INT 1
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: LD_INT 0
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 1
81742: NEG
81743: PUSH
81744: LD_INT 1
81746: NEG
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 1
81754: NEG
81755: PUSH
81756: LD_INT 2
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 0
81766: PUSH
81767: LD_INT 2
81769: NEG
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 1
81777: PUSH
81778: LD_INT 1
81780: NEG
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 2
81788: PUSH
81789: LD_INT 0
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 2
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 2
81808: PUSH
81809: LD_INT 2
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 1
81818: PUSH
81819: LD_INT 2
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 0
81828: PUSH
81829: LD_INT 2
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 1
81838: NEG
81839: PUSH
81840: LD_INT 1
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 2
81849: NEG
81850: PUSH
81851: LD_INT 0
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: NEG
81861: PUSH
81862: LD_INT 1
81864: NEG
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 2
81872: NEG
81873: PUSH
81874: LD_INT 2
81876: NEG
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 2
81884: PUSH
81885: LD_INT 3
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: LD_INT 3
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 1
81904: NEG
81905: PUSH
81906: LD_INT 2
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 2
81915: NEG
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81949: LD_ADDR_VAR 0 27
81953: PUSH
81954: LD_INT 0
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 0
81966: PUSH
81967: LD_INT 1
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 1
81977: PUSH
81978: LD_INT 0
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 1
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 0
81997: PUSH
81998: LD_INT 1
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 1
82007: NEG
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 1
82018: NEG
82019: PUSH
82020: LD_INT 1
82022: NEG
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 1
82030: NEG
82031: PUSH
82032: LD_INT 2
82034: NEG
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: LD_INT 2
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: LD_INT 1
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 2
82064: PUSH
82065: LD_INT 0
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 2
82074: PUSH
82075: LD_INT 1
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 2
82084: PUSH
82085: LD_INT 2
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: LD_INT 2
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: LD_INT 2
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: LD_INT 1
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 2
82125: NEG
82126: PUSH
82127: LD_INT 0
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 2
82136: NEG
82137: PUSH
82138: LD_INT 1
82140: NEG
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PUSH
82150: LD_INT 2
82152: NEG
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: NEG
82161: PUSH
82162: LD_INT 2
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 3
82182: NEG
82183: PUSH
82184: LD_INT 1
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 3
82194: NEG
82195: PUSH
82196: LD_INT 2
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82229: LD_ADDR_VAR 0 28
82233: PUSH
82234: LD_INT 0
82236: PUSH
82237: LD_INT 0
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 1
82249: NEG
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: LD_INT 1
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: LD_INT 1
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 1
82287: NEG
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 1
82298: NEG
82299: PUSH
82300: LD_INT 1
82302: NEG
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 1
82310: NEG
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: LD_INT 2
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 1
82333: PUSH
82334: LD_INT 1
82336: NEG
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 2
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 2
82354: PUSH
82355: LD_INT 1
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: LD_INT 2
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: LD_INT 2
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: LD_INT 2
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 1
82394: NEG
82395: PUSH
82396: LD_INT 1
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 2
82405: NEG
82406: PUSH
82407: LD_INT 0
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 2
82416: NEG
82417: PUSH
82418: LD_INT 1
82420: NEG
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 2
82428: NEG
82429: PUSH
82430: LD_INT 2
82432: NEG
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 2
82440: NEG
82441: PUSH
82442: LD_INT 3
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: NEG
82453: PUSH
82454: LD_INT 3
82456: NEG
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 3
82464: NEG
82465: PUSH
82466: LD_INT 1
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 3
82476: NEG
82477: PUSH
82478: LD_INT 2
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82511: LD_ADDR_VAR 0 29
82515: PUSH
82516: LD_INT 0
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 0
82528: PUSH
82529: LD_INT 1
82531: NEG
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: LD_INT 0
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 1
82549: PUSH
82550: LD_INT 1
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: LD_INT 0
82559: PUSH
82560: LD_INT 1
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 1
82569: NEG
82570: PUSH
82571: LD_INT 0
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: LD_INT 1
82584: NEG
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 1
82592: NEG
82593: PUSH
82594: LD_INT 2
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 0
82604: PUSH
82605: LD_INT 2
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 1
82615: PUSH
82616: LD_INT 1
82618: NEG
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: LD_INT 2
82626: PUSH
82627: LD_INT 0
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 2
82636: PUSH
82637: LD_INT 1
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 1
82646: PUSH
82647: LD_INT 2
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: LD_INT 2
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 1
82666: NEG
82667: PUSH
82668: LD_INT 1
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 2
82677: NEG
82678: PUSH
82679: LD_INT 1
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: NEG
82690: PUSH
82691: LD_INT 2
82693: NEG
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 2
82701: NEG
82702: PUSH
82703: LD_INT 3
82705: NEG
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 3
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 1
82734: PUSH
82735: LD_INT 3
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 2
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 3
82755: NEG
82756: PUSH
82757: LD_INT 2
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82790: LD_ADDR_VAR 0 30
82794: PUSH
82795: LD_INT 0
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: LD_INT 0
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 1
82828: PUSH
82829: LD_INT 1
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: LD_INT 1
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 1
82848: NEG
82849: PUSH
82850: LD_INT 0
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 1
82859: NEG
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: NEG
82872: PUSH
82873: LD_INT 2
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 0
82883: PUSH
82884: LD_INT 2
82886: NEG
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 1
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 2
82905: PUSH
82906: LD_INT 0
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 2
82915: PUSH
82916: LD_INT 1
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 2
82925: PUSH
82926: LD_INT 2
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 1
82935: PUSH
82936: LD_INT 2
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 2
82956: NEG
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 2
82967: NEG
82968: PUSH
82969: LD_INT 1
82971: NEG
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 1
82979: NEG
82980: PUSH
82981: LD_INT 3
82983: NEG
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: PUSH
82992: LD_INT 2
82994: NEG
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 3
83002: PUSH
83003: LD_INT 2
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 2
83012: PUSH
83013: LD_INT 3
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 2
83022: NEG
83023: PUSH
83024: LD_INT 1
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 3
83033: NEG
83034: PUSH
83035: LD_INT 1
83037: NEG
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83068: LD_ADDR_VAR 0 31
83072: PUSH
83073: LD_INT 0
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 0
83085: PUSH
83086: LD_INT 1
83088: NEG
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: LD_INT 0
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 1
83106: PUSH
83107: LD_INT 1
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 0
83116: PUSH
83117: LD_INT 1
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 1
83126: NEG
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: LD_INT 1
83141: NEG
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 1
83149: NEG
83150: PUSH
83151: LD_INT 2
83153: NEG
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 1
83161: PUSH
83162: LD_INT 1
83164: NEG
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: PUSH
83170: LD_INT 2
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 2
83182: PUSH
83183: LD_INT 1
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 2
83192: PUSH
83193: LD_INT 2
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: LD_INT 2
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: LD_INT 2
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: NEG
83223: PUSH
83224: LD_INT 1
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 2
83233: NEG
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 2
83245: NEG
83246: PUSH
83247: LD_INT 2
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: NEG
83258: PUSH
83259: LD_INT 3
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 2
83269: PUSH
83270: LD_INT 1
83272: NEG
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 3
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 3
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 1
83300: NEG
83301: PUSH
83302: LD_INT 2
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 3
83311: NEG
83312: PUSH
83313: LD_INT 2
83315: NEG
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83346: LD_ADDR_VAR 0 32
83350: PUSH
83351: LD_INT 0
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: LD_INT 1
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 1
83374: PUSH
83375: LD_INT 0
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 1
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 0
83394: PUSH
83395: LD_INT 1
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 1
83404: NEG
83405: PUSH
83406: LD_INT 0
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 1
83415: NEG
83416: PUSH
83417: LD_INT 1
83419: NEG
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: NEG
83428: PUSH
83429: LD_INT 2
83431: NEG
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 0
83439: PUSH
83440: LD_INT 2
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 1
83450: PUSH
83451: LD_INT 1
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: PUSH
83462: LD_INT 1
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 2
83471: PUSH
83472: LD_INT 2
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 1
83481: PUSH
83482: LD_INT 2
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 0
83491: PUSH
83492: LD_INT 2
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: LD_INT 1
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 2
83512: NEG
83513: PUSH
83514: LD_INT 0
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: NEG
83524: PUSH
83525: LD_INT 1
83527: NEG
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 1
83535: NEG
83536: PUSH
83537: LD_INT 3
83539: NEG
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 1
83547: PUSH
83548: LD_INT 2
83550: NEG
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 3
83558: PUSH
83559: LD_INT 2
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 2
83568: PUSH
83569: LD_INT 3
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: NEG
83579: PUSH
83580: LD_INT 1
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: PUSH
83587: LD_INT 3
83589: NEG
83590: PUSH
83591: LD_INT 1
83593: NEG
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83624: LD_ADDR_VAR 0 33
83628: PUSH
83629: LD_INT 0
83631: PUSH
83632: LD_INT 0
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 0
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 1
83652: PUSH
83653: LD_INT 0
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 1
83662: PUSH
83663: LD_INT 1
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 0
83672: PUSH
83673: LD_INT 1
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: LD_INT 0
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 1
83693: NEG
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 1
83705: NEG
83706: PUSH
83707: LD_INT 2
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: LD_INT 1
83720: NEG
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: LD_INT 1
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 2
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 1
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 2
83779: NEG
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 2
83790: NEG
83791: PUSH
83792: LD_INT 1
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 2
83802: NEG
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 2
83814: NEG
83815: PUSH
83816: LD_INT 3
83818: NEG
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 2
83826: PUSH
83827: LD_INT 1
83829: NEG
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 3
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 1
83847: PUSH
83848: LD_INT 3
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: LD_INT 2
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 3
83868: NEG
83869: PUSH
83870: LD_INT 2
83872: NEG
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: LIST
83902: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83903: LD_ADDR_VAR 0 34
83907: PUSH
83908: LD_INT 0
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 0
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 1
83931: PUSH
83932: LD_INT 0
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: LD_INT 1
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 0
83951: PUSH
83952: LD_INT 1
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 1
83961: NEG
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 1
83972: NEG
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 1
83984: NEG
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 0
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 1
84007: PUSH
84008: LD_INT 1
84010: NEG
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 2
84018: PUSH
84019: LD_INT 1
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 2
84028: PUSH
84029: LD_INT 2
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: LD_INT 2
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 1
84048: NEG
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 2
84059: NEG
84060: PUSH
84061: LD_INT 0
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 2
84070: NEG
84071: PUSH
84072: LD_INT 1
84074: NEG
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 2
84082: NEG
84083: PUSH
84084: LD_INT 2
84086: NEG
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 1
84094: NEG
84095: PUSH
84096: LD_INT 3
84098: NEG
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: LD_INT 2
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 3
84117: PUSH
84118: LD_INT 2
84120: PUSH
84121: EMPTY
84122: LIST
84123: LIST
84124: PUSH
84125: LD_INT 2
84127: PUSH
84128: LD_INT 3
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 2
84137: NEG
84138: PUSH
84139: LD_INT 1
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 3
84148: NEG
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84183: LD_ADDR_VAR 0 35
84187: PUSH
84188: LD_INT 0
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 1
84221: PUSH
84222: LD_INT 1
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: LD_INT 0
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: NEG
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 2
84264: PUSH
84265: LD_INT 1
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 2
84274: NEG
84275: PUSH
84276: LD_INT 1
84278: NEG
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84295: LD_ADDR_VAR 0 36
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: LD_INT 0
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 0
84312: PUSH
84313: LD_INT 1
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: PUSH
84324: LD_INT 0
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: PUSH
84331: LD_INT 1
84333: PUSH
84334: LD_INT 1
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: LD_INT 1
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: LD_INT 0
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: NEG
84365: PUSH
84366: LD_INT 1
84368: NEG
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 1
84376: NEG
84377: PUSH
84378: LD_INT 2
84380: NEG
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84407: LD_ADDR_VAR 0 37
84411: PUSH
84412: LD_INT 0
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 0
84424: PUSH
84425: LD_INT 1
84427: NEG
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 1
84435: PUSH
84436: LD_INT 0
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 1
84445: PUSH
84446: LD_INT 1
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 0
84455: PUSH
84456: LD_INT 1
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 1
84465: NEG
84466: PUSH
84467: LD_INT 0
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 1
84476: NEG
84477: PUSH
84478: LD_INT 1
84480: NEG
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PUSH
84486: LD_INT 1
84488: PUSH
84489: LD_INT 1
84491: NEG
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 1
84499: NEG
84500: PUSH
84501: LD_INT 1
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84519: LD_ADDR_VAR 0 38
84523: PUSH
84524: LD_INT 0
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: LD_INT 1
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 1
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: LD_INT 1
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: LD_INT 0
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 1
84588: NEG
84589: PUSH
84590: LD_INT 1
84592: NEG
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 2
84600: PUSH
84601: LD_INT 1
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: LD_INT 2
84610: NEG
84611: PUSH
84612: LD_INT 1
84614: NEG
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: LIST
84629: LIST
84630: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84631: LD_ADDR_VAR 0 39
84635: PUSH
84636: LD_INT 0
84638: PUSH
84639: LD_INT 0
84641: PUSH
84642: EMPTY
84643: LIST
84644: LIST
84645: PUSH
84646: LD_INT 0
84648: PUSH
84649: LD_INT 1
84651: NEG
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 1
84659: PUSH
84660: LD_INT 0
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 1
84669: PUSH
84670: LD_INT 1
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: LD_INT 1
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: NEG
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: NEG
84701: PUSH
84702: LD_INT 1
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: NEG
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 1
84724: PUSH
84725: LD_INT 2
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84743: LD_ADDR_VAR 0 40
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 0
84760: PUSH
84761: LD_INT 1
84763: NEG
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 1
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: LD_INT 1
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 1
84801: NEG
84802: PUSH
84803: LD_INT 0
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 1
84812: NEG
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 1
84824: PUSH
84825: LD_INT 1
84827: NEG
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 1
84835: NEG
84836: PUSH
84837: LD_INT 1
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84855: LD_ADDR_VAR 0 41
84859: PUSH
84860: LD_INT 0
84862: PUSH
84863: LD_INT 0
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: LD_INT 0
84872: PUSH
84873: LD_INT 1
84875: NEG
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 1
84883: PUSH
84884: LD_INT 0
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: LD_INT 1
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: LD_INT 1
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 1
84913: NEG
84914: PUSH
84915: LD_INT 0
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 1
84924: NEG
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 1
84936: NEG
84937: PUSH
84938: LD_INT 2
84940: NEG
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 2
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 2
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 2
84979: PUSH
84980: LD_INT 2
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 2
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: NEG
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 2
85010: NEG
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 2
85021: NEG
85022: PUSH
85023: LD_INT 1
85025: NEG
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 2
85033: NEG
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 2
85045: NEG
85046: PUSH
85047: LD_INT 3
85049: NEG
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PUSH
85055: LD_INT 2
85057: PUSH
85058: LD_INT 1
85060: NEG
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 3
85068: PUSH
85069: LD_INT 0
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: PUSH
85076: LD_INT 3
85078: PUSH
85079: LD_INT 1
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 3
85088: PUSH
85089: LD_INT 2
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 3
85098: PUSH
85099: LD_INT 3
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 2
85108: PUSH
85109: LD_INT 3
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 2
85118: NEG
85119: PUSH
85120: LD_INT 1
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 3
85129: NEG
85130: PUSH
85131: LD_INT 0
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 3
85140: NEG
85141: PUSH
85142: LD_INT 1
85144: NEG
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 3
85152: NEG
85153: PUSH
85154: LD_INT 2
85156: NEG
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 3
85164: NEG
85165: PUSH
85166: LD_INT 3
85168: NEG
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85205: LD_ADDR_VAR 0 42
85209: PUSH
85210: LD_INT 0
85212: PUSH
85213: LD_INT 0
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 0
85222: PUSH
85223: LD_INT 1
85225: NEG
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: PUSH
85234: LD_INT 0
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: PUSH
85244: LD_INT 1
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 0
85253: PUSH
85254: LD_INT 1
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 1
85263: NEG
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 1
85274: NEG
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: LD_INT 2
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 0
85298: PUSH
85299: LD_INT 2
85301: NEG
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 1
85309: PUSH
85310: LD_INT 1
85312: NEG
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: PUSH
85318: LD_INT 2
85320: PUSH
85321: LD_INT 1
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 2
85330: PUSH
85331: LD_INT 2
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 1
85340: PUSH
85341: LD_INT 2
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: LD_INT 2
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: LD_INT 1
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 2
85371: NEG
85372: PUSH
85373: LD_INT 1
85375: NEG
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: NEG
85384: PUSH
85385: LD_INT 2
85387: NEG
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 2
85395: NEG
85396: PUSH
85397: LD_INT 3
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: LD_INT 3
85411: NEG
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 0
85419: PUSH
85420: LD_INT 3
85422: NEG
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 1
85430: PUSH
85431: LD_INT 2
85433: NEG
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 3
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 3
85451: PUSH
85452: LD_INT 3
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 2
85461: PUSH
85462: LD_INT 3
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: LD_INT 1
85471: PUSH
85472: LD_INT 3
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: PUSH
85479: LD_INT 0
85481: PUSH
85482: LD_INT 3
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PUSH
85489: LD_INT 1
85491: NEG
85492: PUSH
85493: LD_INT 2
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 3
85502: NEG
85503: PUSH
85504: LD_INT 2
85506: NEG
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 3
85514: NEG
85515: PUSH
85516: LD_INT 3
85518: NEG
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85555: LD_ADDR_VAR 0 43
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 1
85583: PUSH
85584: LD_INT 0
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 1
85593: PUSH
85594: LD_INT 1
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: LD_INT 1
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 1
85624: NEG
85625: PUSH
85626: LD_INT 1
85628: NEG
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: LD_INT 2
85640: NEG
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 2
85670: PUSH
85671: LD_INT 0
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 2
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: LD_INT 2
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: LD_INT 2
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: LD_INT 1
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 2
85721: NEG
85722: PUSH
85723: LD_INT 0
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: LD_INT 1
85736: NEG
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 1
85744: NEG
85745: PUSH
85746: LD_INT 3
85748: NEG
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 0
85756: PUSH
85757: LD_INT 3
85759: NEG
85760: PUSH
85761: EMPTY
85762: LIST
85763: LIST
85764: PUSH
85765: LD_INT 1
85767: PUSH
85768: LD_INT 2
85770: NEG
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 2
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 3
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 3
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 1
85809: PUSH
85810: LD_INT 3
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: LD_INT 0
85819: PUSH
85820: LD_INT 3
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 1
85829: NEG
85830: PUSH
85831: LD_INT 2
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 2
85840: NEG
85841: PUSH
85842: LD_INT 1
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 3
85851: NEG
85852: PUSH
85853: LD_INT 0
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 3
85862: NEG
85863: PUSH
85864: LD_INT 1
85866: NEG
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85903: LD_ADDR_VAR 0 44
85907: PUSH
85908: LD_INT 0
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 0
85920: PUSH
85921: LD_INT 1
85923: NEG
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PUSH
85929: LD_INT 1
85931: PUSH
85932: LD_INT 0
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 1
85941: PUSH
85942: LD_INT 1
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: LD_INT 1
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 1
85961: NEG
85962: PUSH
85963: LD_INT 0
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 1
85996: PUSH
85997: LD_INT 1
85999: NEG
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 2
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: LD_INT 1
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 2
86027: PUSH
86028: LD_INT 2
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 1
86037: PUSH
86038: LD_INT 2
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: LD_INT 1
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 2
86058: NEG
86059: PUSH
86060: LD_INT 0
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 2
86069: NEG
86070: PUSH
86071: LD_INT 1
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 2
86081: NEG
86082: PUSH
86083: LD_INT 2
86085: NEG
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_INT 2
86093: NEG
86094: PUSH
86095: LD_INT 3
86097: NEG
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 2
86105: PUSH
86106: LD_INT 1
86108: NEG
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: PUSH
86114: LD_INT 3
86116: PUSH
86117: LD_INT 0
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 3
86126: PUSH
86127: LD_INT 1
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PUSH
86134: LD_INT 3
86136: PUSH
86137: LD_INT 2
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 3
86146: PUSH
86147: LD_INT 3
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 2
86156: PUSH
86157: LD_INT 3
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 2
86166: NEG
86167: PUSH
86168: LD_INT 1
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 3
86177: NEG
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 3
86188: NEG
86189: PUSH
86190: LD_INT 1
86192: NEG
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 3
86200: NEG
86201: PUSH
86202: LD_INT 2
86204: NEG
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: LD_INT 3
86212: NEG
86213: PUSH
86214: LD_INT 3
86216: NEG
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86253: LD_ADDR_VAR 0 45
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 1
86273: NEG
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 1
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 1
86322: NEG
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: LD_INT 2
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 0
86346: PUSH
86347: LD_INT 2
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 1
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 2
86368: PUSH
86369: LD_INT 1
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 2
86378: PUSH
86379: LD_INT 2
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: LD_INT 2
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 0
86398: PUSH
86399: LD_INT 2
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 1
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 2
86419: NEG
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 2
86431: NEG
86432: PUSH
86433: LD_INT 2
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 2
86443: NEG
86444: PUSH
86445: LD_INT 3
86447: NEG
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: LD_INT 3
86459: NEG
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 0
86467: PUSH
86468: LD_INT 3
86470: NEG
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 1
86478: PUSH
86479: LD_INT 2
86481: NEG
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 3
86489: PUSH
86490: LD_INT 2
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 3
86499: PUSH
86500: LD_INT 3
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 2
86509: PUSH
86510: LD_INT 3
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 1
86519: PUSH
86520: LD_INT 3
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: PUSH
86527: LD_INT 0
86529: PUSH
86530: LD_INT 3
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 1
86539: NEG
86540: PUSH
86541: LD_INT 2
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 3
86550: NEG
86551: PUSH
86552: LD_INT 2
86554: NEG
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 3
86562: NEG
86563: PUSH
86564: LD_INT 3
86566: NEG
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86603: LD_ADDR_VAR 0 46
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: LD_INT 1
86623: NEG
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: LD_INT 0
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 1
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: LD_INT 1
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 1
86661: NEG
86662: PUSH
86663: LD_INT 0
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: NEG
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 1
86684: NEG
86685: PUSH
86686: LD_INT 2
86688: NEG
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 0
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 1
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 2
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 2
86728: PUSH
86729: LD_INT 1
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: LD_INT 2
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 0
86748: PUSH
86749: LD_INT 2
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 2
86780: NEG
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: LD_INT 1
86792: NEG
86793: PUSH
86794: LD_INT 3
86796: NEG
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: LD_INT 3
86807: NEG
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 1
86815: PUSH
86816: LD_INT 2
86818: NEG
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 2
86826: PUSH
86827: LD_INT 1
86829: NEG
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 3
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 3
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 1
86857: PUSH
86858: LD_INT 3
86860: PUSH
86861: EMPTY
86862: LIST
86863: LIST
86864: PUSH
86865: LD_INT 0
86867: PUSH
86868: LD_INT 3
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PUSH
86875: LD_INT 1
86877: NEG
86878: PUSH
86879: LD_INT 2
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: LD_INT 1
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 3
86899: NEG
86900: PUSH
86901: LD_INT 0
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 3
86910: NEG
86911: PUSH
86912: LD_INT 1
86914: NEG
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86951: LD_ADDR_VAR 0 47
86955: PUSH
86956: LD_INT 0
86958: PUSH
86959: LD_INT 0
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: LD_INT 1
86971: NEG
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 1
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 1
86989: PUSH
86990: LD_INT 1
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: LD_INT 1
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 1
87009: NEG
87010: PUSH
87011: LD_INT 0
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: PUSH
87018: LD_INT 1
87020: NEG
87021: PUSH
87022: LD_INT 1
87024: NEG
87025: PUSH
87026: EMPTY
87027: LIST
87028: LIST
87029: PUSH
87030: LD_INT 1
87032: NEG
87033: PUSH
87034: LD_INT 2
87036: NEG
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: LD_INT 0
87044: PUSH
87045: LD_INT 2
87047: NEG
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 2
87066: NEG
87067: PUSH
87068: LD_INT 1
87070: NEG
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 2
87078: NEG
87079: PUSH
87080: LD_INT 2
87082: NEG
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87102: LD_ADDR_VAR 0 48
87106: PUSH
87107: LD_INT 0
87109: PUSH
87110: LD_INT 0
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 0
87119: PUSH
87120: LD_INT 1
87122: NEG
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 1
87130: PUSH
87131: LD_INT 0
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 1
87140: PUSH
87141: LD_INT 1
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 0
87150: PUSH
87151: LD_INT 1
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 1
87160: NEG
87161: PUSH
87162: LD_INT 0
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 2
87187: NEG
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 0
87195: PUSH
87196: LD_INT 2
87198: NEG
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: PUSH
87207: LD_INT 1
87209: NEG
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 2
87217: PUSH
87218: LD_INT 0
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 2
87227: PUSH
87228: LD_INT 1
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87249: LD_ADDR_VAR 0 49
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: LD_INT 0
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 0
87266: PUSH
87267: LD_INT 1
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: PUSH
87278: LD_INT 0
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 1
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 0
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: LD_INT 0
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: NEG
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 1
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 2
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 2
87351: PUSH
87352: LD_INT 1
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 2
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 1
87371: PUSH
87372: LD_INT 2
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87393: LD_ADDR_VAR 0 50
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: LD_INT 1
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: LD_INT 0
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 2
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: LD_INT 2
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 2
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 0
87504: PUSH
87505: LD_INT 2
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: NEG
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87537: LD_ADDR_VAR 0 51
87541: PUSH
87542: LD_INT 0
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: LD_INT 1
87565: PUSH
87566: LD_INT 0
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 1
87575: PUSH
87576: LD_INT 1
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 0
87585: PUSH
87586: LD_INT 1
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 1
87595: NEG
87596: PUSH
87597: LD_INT 0
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 1
87606: NEG
87607: PUSH
87608: LD_INT 1
87610: NEG
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 1
87618: PUSH
87619: LD_INT 2
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 0
87628: PUSH
87629: LD_INT 2
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 1
87638: NEG
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 2
87649: NEG
87650: PUSH
87651: LD_INT 0
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 2
87660: NEG
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87684: LD_ADDR_VAR 0 52
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 1
87722: PUSH
87723: LD_INT 1
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: LD_INT 1
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 1
87742: NEG
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 1
87753: NEG
87754: PUSH
87755: LD_INT 1
87757: NEG
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: LD_INT 2
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 1
87777: NEG
87778: PUSH
87779: LD_INT 1
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 2
87788: NEG
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 2
87799: NEG
87800: PUSH
87801: LD_INT 1
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 2
87811: NEG
87812: PUSH
87813: LD_INT 2
87815: NEG
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87835: LD_ADDR_VAR 0 53
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: LD_INT 1
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: LD_INT 1
87908: NEG
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 1
87916: NEG
87917: PUSH
87918: LD_INT 2
87920: NEG
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 0
87928: PUSH
87929: LD_INT 2
87931: NEG
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 1
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 2
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 2
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 2
87970: PUSH
87971: LD_INT 2
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: LD_INT 2
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: NEG
88001: PUSH
88002: LD_INT 1
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 2
88011: NEG
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 2
88022: NEG
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 2
88034: NEG
88035: PUSH
88036: LD_INT 2
88038: NEG
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88065: LD_ADDR_VAR 0 54
88069: PUSH
88070: LD_INT 0
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: LD_INT 1
88085: NEG
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 1
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: LD_INT 1
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 0
88113: PUSH
88114: LD_INT 1
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 1
88123: NEG
88124: PUSH
88125: LD_INT 0
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: LD_INT 1
88134: NEG
88135: PUSH
88136: LD_INT 1
88138: NEG
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 1
88146: NEG
88147: PUSH
88148: LD_INT 2
88150: NEG
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 0
88158: PUSH
88159: LD_INT 2
88161: NEG
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 1
88169: PUSH
88170: LD_INT 1
88172: NEG
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 2
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 2
88190: PUSH
88191: LD_INT 1
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 2
88200: PUSH
88201: LD_INT 2
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 1
88210: PUSH
88211: LD_INT 2
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 2
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: LD_INT 1
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: NEG
88242: PUSH
88243: LD_INT 0
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 2
88252: NEG
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 2
88264: NEG
88265: PUSH
88266: LD_INT 2
88268: NEG
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88295: LD_ADDR_VAR 0 55
88299: PUSH
88300: LD_INT 0
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 0
88312: PUSH
88313: LD_INT 1
88315: NEG
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: LD_INT 1
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 1
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: NEG
88354: PUSH
88355: LD_INT 0
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: LD_INT 1
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 1
88376: NEG
88377: PUSH
88378: LD_INT 2
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 0
88388: PUSH
88389: LD_INT 2
88391: NEG
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: LD_INT 1
88402: NEG
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 2
88410: PUSH
88411: LD_INT 0
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 2
88420: PUSH
88421: LD_INT 1
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 2
88430: PUSH
88431: LD_INT 2
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 1
88440: PUSH
88441: LD_INT 2
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 0
88450: PUSH
88451: LD_INT 2
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 1
88460: NEG
88461: PUSH
88462: LD_INT 1
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 2
88471: NEG
88472: PUSH
88473: LD_INT 0
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 2
88482: NEG
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 2
88494: NEG
88495: PUSH
88496: LD_INT 2
88498: NEG
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88525: LD_ADDR_VAR 0 56
88529: PUSH
88530: LD_INT 0
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 0
88542: PUSH
88543: LD_INT 1
88545: NEG
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PUSH
88551: LD_INT 1
88553: PUSH
88554: LD_INT 0
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 1
88563: PUSH
88564: LD_INT 1
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 0
88573: PUSH
88574: LD_INT 1
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 1
88583: NEG
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 1
88594: NEG
88595: PUSH
88596: LD_INT 1
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 1
88606: NEG
88607: PUSH
88608: LD_INT 2
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 0
88618: PUSH
88619: LD_INT 2
88621: NEG
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 1
88629: PUSH
88630: LD_INT 1
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 2
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 2
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 2
88660: PUSH
88661: LD_INT 2
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 1
88670: PUSH
88671: LD_INT 2
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: LD_INT 2
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: NEG
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 2
88701: NEG
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 2
88724: NEG
88725: PUSH
88726: LD_INT 2
88728: NEG
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88755: LD_ADDR_VAR 0 57
88759: PUSH
88760: LD_INT 0
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: LD_INT 1
88775: NEG
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 1
88783: PUSH
88784: LD_INT 0
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 1
88793: PUSH
88794: LD_INT 1
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 0
88803: PUSH
88804: LD_INT 1
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 1
88813: NEG
88814: PUSH
88815: LD_INT 0
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: LD_INT 1
88828: NEG
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 1
88836: NEG
88837: PUSH
88838: LD_INT 2
88840: NEG
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 0
88848: PUSH
88849: LD_INT 2
88851: NEG
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 1
88859: PUSH
88860: LD_INT 1
88862: NEG
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 2
88870: PUSH
88871: LD_INT 0
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 2
88880: PUSH
88881: LD_INT 1
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 2
88890: PUSH
88891: LD_INT 2
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 1
88900: PUSH
88901: LD_INT 2
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 0
88910: PUSH
88911: LD_INT 2
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: LD_INT 1
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 2
88931: NEG
88932: PUSH
88933: LD_INT 0
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 2
88942: NEG
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 2
88954: NEG
88955: PUSH
88956: LD_INT 2
88958: NEG
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88985: LD_ADDR_VAR 0 58
88989: PUSH
88990: LD_INT 0
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 0
89002: PUSH
89003: LD_INT 1
89005: NEG
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 1
89013: PUSH
89014: LD_INT 0
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 1
89023: PUSH
89024: LD_INT 1
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 0
89033: PUSH
89034: LD_INT 1
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 1
89043: NEG
89044: PUSH
89045: LD_INT 0
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 1
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: LD_INT 2
89070: NEG
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 0
89078: PUSH
89079: LD_INT 2
89081: NEG
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 1
89089: PUSH
89090: LD_INT 1
89092: NEG
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 2
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 2
89110: PUSH
89111: LD_INT 1
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 2
89120: PUSH
89121: LD_INT 2
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: LD_INT 1
89130: PUSH
89131: LD_INT 2
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 0
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: LD_INT 1
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 2
89161: NEG
89162: PUSH
89163: LD_INT 0
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 2
89172: NEG
89173: PUSH
89174: LD_INT 1
89176: NEG
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 2
89184: NEG
89185: PUSH
89186: LD_INT 2
89188: NEG
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89215: LD_ADDR_VAR 0 59
89219: PUSH
89220: LD_INT 0
89222: PUSH
89223: LD_INT 0
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 0
89232: PUSH
89233: LD_INT 1
89235: NEG
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 1
89243: PUSH
89244: LD_INT 0
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 1
89253: PUSH
89254: LD_INT 1
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: LD_INT 1
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 1
89273: NEG
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: NEG
89285: PUSH
89286: LD_INT 1
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89303: LD_ADDR_VAR 0 60
89307: PUSH
89308: LD_INT 0
89310: PUSH
89311: LD_INT 0
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 0
89320: PUSH
89321: LD_INT 1
89323: NEG
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 1
89331: PUSH
89332: LD_INT 0
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 1
89341: PUSH
89342: LD_INT 1
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 0
89351: PUSH
89352: LD_INT 1
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: NEG
89362: PUSH
89363: LD_INT 0
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 1
89372: NEG
89373: PUSH
89374: LD_INT 1
89376: NEG
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89391: LD_ADDR_VAR 0 61
89395: PUSH
89396: LD_INT 0
89398: PUSH
89399: LD_INT 0
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 0
89408: PUSH
89409: LD_INT 1
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 1
89419: PUSH
89420: LD_INT 0
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: PUSH
89427: LD_INT 1
89429: PUSH
89430: LD_INT 1
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: LD_INT 1
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 1
89449: NEG
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 1
89460: NEG
89461: PUSH
89462: LD_INT 1
89464: NEG
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89479: LD_ADDR_VAR 0 62
89483: PUSH
89484: LD_INT 0
89486: PUSH
89487: LD_INT 0
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: LD_INT 1
89499: NEG
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 1
89507: PUSH
89508: LD_INT 0
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 1
89517: PUSH
89518: LD_INT 1
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: LD_INT 1
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: NEG
89538: PUSH
89539: LD_INT 0
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: LD_INT 1
89548: NEG
89549: PUSH
89550: LD_INT 1
89552: NEG
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89567: LD_ADDR_VAR 0 63
89571: PUSH
89572: LD_INT 0
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 0
89584: PUSH
89585: LD_INT 1
89587: NEG
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: LD_INT 0
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: LD_INT 1
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 0
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89655: LD_ADDR_VAR 0 64
89659: PUSH
89660: LD_INT 0
89662: PUSH
89663: LD_INT 0
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 0
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 1
89683: PUSH
89684: LD_INT 0
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 1
89693: PUSH
89694: LD_INT 1
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 0
89703: PUSH
89704: LD_INT 1
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 1
89713: NEG
89714: PUSH
89715: LD_INT 0
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 1
89724: NEG
89725: PUSH
89726: LD_INT 1
89728: NEG
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: ST_TO_ADDR
// end ; 1 :
89743: GO 95640
89745: LD_INT 1
89747: DOUBLE
89748: EQUAL
89749: IFTRUE 89753
89751: GO 92376
89753: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89754: LD_ADDR_VAR 0 11
89758: PUSH
89759: LD_INT 1
89761: NEG
89762: PUSH
89763: LD_INT 3
89765: NEG
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 0
89773: PUSH
89774: LD_INT 3
89776: NEG
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: LD_INT 2
89787: NEG
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: LIST
89797: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89798: LD_ADDR_VAR 0 12
89802: PUSH
89803: LD_INT 2
89805: PUSH
89806: LD_INT 1
89808: NEG
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: LD_INT 3
89816: PUSH
89817: LD_INT 0
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 3
89826: PUSH
89827: LD_INT 1
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: LIST
89838: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89839: LD_ADDR_VAR 0 13
89843: PUSH
89844: LD_INT 3
89846: PUSH
89847: LD_INT 2
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 3
89856: PUSH
89857: LD_INT 3
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 2
89866: PUSH
89867: LD_INT 3
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: LIST
89878: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89879: LD_ADDR_VAR 0 14
89883: PUSH
89884: LD_INT 1
89886: PUSH
89887: LD_INT 3
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 0
89896: PUSH
89897: LD_INT 3
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 1
89906: NEG
89907: PUSH
89908: LD_INT 2
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: LIST
89919: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89920: LD_ADDR_VAR 0 15
89924: PUSH
89925: LD_INT 2
89927: NEG
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 3
89938: NEG
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 3
89949: NEG
89950: PUSH
89951: LD_INT 1
89953: NEG
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: LIST
89963: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89964: LD_ADDR_VAR 0 16
89968: PUSH
89969: LD_INT 2
89971: NEG
89972: PUSH
89973: LD_INT 3
89975: NEG
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 3
89983: NEG
89984: PUSH
89985: LD_INT 2
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 3
89995: NEG
89996: PUSH
89997: LD_INT 3
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: LIST
90009: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90010: LD_ADDR_VAR 0 17
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: LD_INT 3
90021: NEG
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 3
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: PUSH
90041: LD_INT 2
90043: NEG
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: LIST
90053: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90054: LD_ADDR_VAR 0 18
90058: PUSH
90059: LD_INT 2
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 3
90072: PUSH
90073: LD_INT 0
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 3
90082: PUSH
90083: LD_INT 1
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: LIST
90094: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90095: LD_ADDR_VAR 0 19
90099: PUSH
90100: LD_INT 3
90102: PUSH
90103: LD_INT 2
90105: PUSH
90106: EMPTY
90107: LIST
90108: LIST
90109: PUSH
90110: LD_INT 3
90112: PUSH
90113: LD_INT 3
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 2
90122: PUSH
90123: LD_INT 3
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: EMPTY
90131: LIST
90132: LIST
90133: LIST
90134: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90135: LD_ADDR_VAR 0 20
90139: PUSH
90140: LD_INT 1
90142: PUSH
90143: LD_INT 3
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: LD_INT 3
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 1
90162: NEG
90163: PUSH
90164: LD_INT 2
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: LIST
90175: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90176: LD_ADDR_VAR 0 21
90180: PUSH
90181: LD_INT 2
90183: NEG
90184: PUSH
90185: LD_INT 1
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 3
90194: NEG
90195: PUSH
90196: LD_INT 0
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: LD_INT 3
90205: NEG
90206: PUSH
90207: LD_INT 1
90209: NEG
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: LIST
90219: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90220: LD_ADDR_VAR 0 22
90224: PUSH
90225: LD_INT 2
90227: NEG
90228: PUSH
90229: LD_INT 3
90231: NEG
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: LD_INT 3
90239: NEG
90240: PUSH
90241: LD_INT 2
90243: NEG
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PUSH
90249: LD_INT 3
90251: NEG
90252: PUSH
90253: LD_INT 3
90255: NEG
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: LIST
90265: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90266: LD_ADDR_VAR 0 23
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 3
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 1
90284: NEG
90285: PUSH
90286: LD_INT 4
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 1
90296: PUSH
90297: LD_INT 3
90299: NEG
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: LIST
90309: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90310: LD_ADDR_VAR 0 24
90314: PUSH
90315: LD_INT 3
90317: PUSH
90318: LD_INT 0
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_INT 3
90327: PUSH
90328: LD_INT 1
90330: NEG
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 4
90338: PUSH
90339: LD_INT 1
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: LIST
90350: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90351: LD_ADDR_VAR 0 25
90355: PUSH
90356: LD_INT 3
90358: PUSH
90359: LD_INT 3
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 4
90368: PUSH
90369: LD_INT 3
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 3
90378: PUSH
90379: LD_INT 4
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: LIST
90390: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90391: LD_ADDR_VAR 0 26
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: LD_INT 3
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: PUSH
90409: LD_INT 4
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 1
90418: NEG
90419: PUSH
90420: LD_INT 3
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: LIST
90431: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90432: LD_ADDR_VAR 0 27
90436: PUSH
90437: LD_INT 3
90439: NEG
90440: PUSH
90441: LD_INT 0
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 3
90450: NEG
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 4
90461: NEG
90462: PUSH
90463: LD_INT 1
90465: NEG
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: LIST
90475: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90476: LD_ADDR_VAR 0 28
90480: PUSH
90481: LD_INT 3
90483: NEG
90484: PUSH
90485: LD_INT 3
90487: NEG
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 3
90495: NEG
90496: PUSH
90497: LD_INT 4
90499: NEG
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 4
90507: NEG
90508: PUSH
90509: LD_INT 3
90511: NEG
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: LIST
90521: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90522: LD_ADDR_VAR 0 29
90526: PUSH
90527: LD_INT 1
90529: NEG
90530: PUSH
90531: LD_INT 3
90533: NEG
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 0
90541: PUSH
90542: LD_INT 3
90544: NEG
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: LD_INT 1
90552: PUSH
90553: LD_INT 2
90555: NEG
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: LD_INT 1
90563: NEG
90564: PUSH
90565: LD_INT 4
90567: NEG
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: LD_INT 4
90578: NEG
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: LD_INT 3
90589: NEG
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 1
90597: NEG
90598: PUSH
90599: LD_INT 5
90601: NEG
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 0
90609: PUSH
90610: LD_INT 5
90612: NEG
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 1
90620: PUSH
90621: LD_INT 4
90623: NEG
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 1
90631: NEG
90632: PUSH
90633: LD_INT 6
90635: NEG
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: LD_INT 6
90646: NEG
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 1
90654: PUSH
90655: LD_INT 5
90657: NEG
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90677: LD_ADDR_VAR 0 30
90681: PUSH
90682: LD_INT 2
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 3
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 3
90705: PUSH
90706: LD_INT 1
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 3
90715: PUSH
90716: LD_INT 1
90718: NEG
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 4
90726: PUSH
90727: LD_INT 0
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 4
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 4
90746: PUSH
90747: LD_INT 1
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 5
90757: PUSH
90758: LD_INT 0
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 5
90767: PUSH
90768: LD_INT 1
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: PUSH
90775: LD_INT 5
90777: PUSH
90778: LD_INT 1
90780: NEG
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 6
90788: PUSH
90789: LD_INT 0
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 6
90798: PUSH
90799: LD_INT 1
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90820: LD_ADDR_VAR 0 31
90824: PUSH
90825: LD_INT 3
90827: PUSH
90828: LD_INT 2
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 3
90837: PUSH
90838: LD_INT 3
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 2
90847: PUSH
90848: LD_INT 3
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 4
90857: PUSH
90858: LD_INT 3
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 4
90867: PUSH
90868: LD_INT 4
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 3
90877: PUSH
90878: LD_INT 4
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 5
90887: PUSH
90888: LD_INT 4
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 5
90897: PUSH
90898: LD_INT 5
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 4
90907: PUSH
90908: LD_INT 5
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 6
90917: PUSH
90918: LD_INT 5
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 6
90927: PUSH
90928: LD_INT 6
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 5
90937: PUSH
90938: LD_INT 6
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90959: LD_ADDR_VAR 0 32
90963: PUSH
90964: LD_INT 1
90966: PUSH
90967: LD_INT 3
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 0
90976: PUSH
90977: LD_INT 3
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 1
90986: NEG
90987: PUSH
90988: LD_INT 2
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 1
90997: PUSH
90998: LD_INT 4
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: LD_INT 4
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: PUSH
91019: LD_INT 3
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: LD_INT 5
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 0
91038: PUSH
91039: LD_INT 5
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 1
91048: NEG
91049: PUSH
91050: LD_INT 4
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 1
91059: PUSH
91060: LD_INT 6
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 0
91069: PUSH
91070: LD_INT 6
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 1
91079: NEG
91080: PUSH
91081: LD_INT 5
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91102: LD_ADDR_VAR 0 33
91106: PUSH
91107: LD_INT 2
91109: NEG
91110: PUSH
91111: LD_INT 1
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 3
91120: NEG
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 3
91131: NEG
91132: PUSH
91133: LD_INT 1
91135: NEG
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 3
91143: NEG
91144: PUSH
91145: LD_INT 1
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 4
91154: NEG
91155: PUSH
91156: LD_INT 0
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 4
91165: NEG
91166: PUSH
91167: LD_INT 1
91169: NEG
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 4
91177: NEG
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 5
91188: NEG
91189: PUSH
91190: LD_INT 0
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 5
91199: NEG
91200: PUSH
91201: LD_INT 1
91203: NEG
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 5
91211: NEG
91212: PUSH
91213: LD_INT 1
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 6
91222: NEG
91223: PUSH
91224: LD_INT 0
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 6
91233: NEG
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91257: LD_ADDR_VAR 0 34
91261: PUSH
91262: LD_INT 2
91264: NEG
91265: PUSH
91266: LD_INT 3
91268: NEG
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 3
91276: NEG
91277: PUSH
91278: LD_INT 2
91280: NEG
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 3
91288: NEG
91289: PUSH
91290: LD_INT 3
91292: NEG
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 3
91300: NEG
91301: PUSH
91302: LD_INT 4
91304: NEG
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 4
91312: NEG
91313: PUSH
91314: LD_INT 3
91316: NEG
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 4
91324: NEG
91325: PUSH
91326: LD_INT 4
91328: NEG
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: LD_INT 4
91336: NEG
91337: PUSH
91338: LD_INT 5
91340: NEG
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 5
91348: NEG
91349: PUSH
91350: LD_INT 4
91352: NEG
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 5
91360: NEG
91361: PUSH
91362: LD_INT 5
91364: NEG
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: LD_INT 5
91372: NEG
91373: PUSH
91374: LD_INT 6
91376: NEG
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: PUSH
91382: LD_INT 6
91384: NEG
91385: PUSH
91386: LD_INT 5
91388: NEG
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 6
91396: NEG
91397: PUSH
91398: LD_INT 6
91400: NEG
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91420: LD_ADDR_VAR 0 41
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: LD_INT 2
91430: NEG
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 1
91438: NEG
91439: PUSH
91440: LD_INT 3
91442: NEG
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 1
91450: PUSH
91451: LD_INT 2
91453: NEG
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: LIST
91463: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91464: LD_ADDR_VAR 0 42
91468: PUSH
91469: LD_INT 2
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 2
91481: PUSH
91482: LD_INT 1
91484: NEG
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 3
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: LIST
91504: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91505: LD_ADDR_VAR 0 43
91509: PUSH
91510: LD_INT 2
91512: PUSH
91513: LD_INT 2
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 3
91522: PUSH
91523: LD_INT 2
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 2
91532: PUSH
91533: LD_INT 3
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: LIST
91544: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91545: LD_ADDR_VAR 0 44
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: LD_INT 2
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 1
91562: PUSH
91563: LD_INT 3
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 1
91572: NEG
91573: PUSH
91574: LD_INT 2
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: LIST
91585: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91586: LD_ADDR_VAR 0 45
91590: PUSH
91591: LD_INT 2
91593: NEG
91594: PUSH
91595: LD_INT 0
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 2
91604: NEG
91605: PUSH
91606: LD_INT 1
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 3
91615: NEG
91616: PUSH
91617: LD_INT 1
91619: NEG
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: LIST
91629: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91630: LD_ADDR_VAR 0 46
91634: PUSH
91635: LD_INT 2
91637: NEG
91638: PUSH
91639: LD_INT 2
91641: NEG
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: LD_INT 2
91649: NEG
91650: PUSH
91651: LD_INT 3
91653: NEG
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 3
91661: NEG
91662: PUSH
91663: LD_INT 2
91665: NEG
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: LIST
91675: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91676: LD_ADDR_VAR 0 47
91680: PUSH
91681: LD_INT 2
91683: NEG
91684: PUSH
91685: LD_INT 3
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: LD_INT 3
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91709: LD_ADDR_VAR 0 48
91713: PUSH
91714: LD_INT 1
91716: PUSH
91717: LD_INT 2
91719: NEG
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 2
91727: PUSH
91728: LD_INT 1
91730: NEG
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91740: LD_ADDR_VAR 0 49
91744: PUSH
91745: LD_INT 3
91747: PUSH
91748: LD_INT 1
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 3
91757: PUSH
91758: LD_INT 2
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91769: LD_ADDR_VAR 0 50
91773: PUSH
91774: LD_INT 2
91776: PUSH
91777: LD_INT 3
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 1
91786: PUSH
91787: LD_INT 3
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: EMPTY
91795: LIST
91796: LIST
91797: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91798: LD_ADDR_VAR 0 51
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: LD_INT 2
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 2
91816: NEG
91817: PUSH
91818: LD_INT 1
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91829: LD_ADDR_VAR 0 52
91833: PUSH
91834: LD_INT 3
91836: NEG
91837: PUSH
91838: LD_INT 1
91840: NEG
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 3
91848: NEG
91849: PUSH
91850: LD_INT 2
91852: NEG
91853: PUSH
91854: EMPTY
91855: LIST
91856: LIST
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91862: LD_ADDR_VAR 0 53
91866: PUSH
91867: LD_INT 1
91869: NEG
91870: PUSH
91871: LD_INT 3
91873: NEG
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 0
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: LD_INT 2
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91906: LD_ADDR_VAR 0 54
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: LD_INT 1
91916: NEG
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 3
91924: PUSH
91925: LD_INT 0
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 3
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91947: LD_ADDR_VAR 0 55
91951: PUSH
91952: LD_INT 3
91954: PUSH
91955: LD_INT 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 3
91964: PUSH
91965: LD_INT 3
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 2
91974: PUSH
91975: LD_INT 3
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: LIST
91986: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91987: LD_ADDR_VAR 0 56
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: LD_INT 3
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 0
92004: PUSH
92005: LD_INT 3
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 1
92014: NEG
92015: PUSH
92016: LD_INT 2
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: LIST
92027: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92028: LD_ADDR_VAR 0 57
92032: PUSH
92033: LD_INT 2
92035: NEG
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: LD_INT 0
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: LD_INT 1
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92072: LD_ADDR_VAR 0 58
92076: PUSH
92077: LD_INT 2
92079: NEG
92080: PUSH
92081: LD_INT 3
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: LD_INT 2
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 3
92103: NEG
92104: PUSH
92105: LD_INT 3
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: LIST
92117: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92118: LD_ADDR_VAR 0 59
92122: PUSH
92123: LD_INT 1
92125: NEG
92126: PUSH
92127: LD_INT 2
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 0
92137: PUSH
92138: LD_INT 2
92140: NEG
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PUSH
92146: LD_INT 1
92148: PUSH
92149: LD_INT 1
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: LIST
92161: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92162: LD_ADDR_VAR 0 60
92166: PUSH
92167: LD_INT 1
92169: PUSH
92170: LD_INT 1
92172: NEG
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: LD_INT 2
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 2
92190: PUSH
92191: LD_INT 1
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: LIST
92202: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92203: LD_ADDR_VAR 0 61
92207: PUSH
92208: LD_INT 2
92210: PUSH
92211: LD_INT 1
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 2
92220: PUSH
92221: LD_INT 2
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 1
92230: PUSH
92231: LD_INT 2
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: LIST
92242: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92243: LD_ADDR_VAR 0 62
92247: PUSH
92248: LD_INT 1
92250: PUSH
92251: LD_INT 2
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 0
92260: PUSH
92261: LD_INT 2
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 1
92270: NEG
92271: PUSH
92272: LD_INT 1
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: LIST
92283: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92284: LD_ADDR_VAR 0 63
92288: PUSH
92289: LD_INT 1
92291: NEG
92292: PUSH
92293: LD_INT 1
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 2
92302: NEG
92303: PUSH
92304: LD_INT 0
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 2
92313: NEG
92314: PUSH
92315: LD_INT 1
92317: NEG
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: LIST
92327: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92328: LD_ADDR_VAR 0 64
92332: PUSH
92333: LD_INT 1
92335: NEG
92336: PUSH
92337: LD_INT 2
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 2
92347: NEG
92348: PUSH
92349: LD_INT 1
92351: NEG
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 2
92359: NEG
92360: PUSH
92361: LD_INT 2
92363: NEG
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: LIST
92373: ST_TO_ADDR
// end ; 2 :
92374: GO 95640
92376: LD_INT 2
92378: DOUBLE
92379: EQUAL
92380: IFTRUE 92384
92382: GO 95639
92384: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92385: LD_ADDR_VAR 0 29
92389: PUSH
92390: LD_INT 4
92392: PUSH
92393: LD_INT 0
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 4
92402: PUSH
92403: LD_INT 1
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 5
92413: PUSH
92414: LD_INT 0
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 5
92423: PUSH
92424: LD_INT 1
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 4
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 3
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 3
92453: PUSH
92454: LD_INT 1
92456: NEG
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 3
92464: PUSH
92465: LD_INT 2
92467: NEG
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 5
92475: PUSH
92476: LD_INT 2
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 3
92485: PUSH
92486: LD_INT 3
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 3
92495: PUSH
92496: LD_INT 2
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 4
92505: PUSH
92506: LD_INT 3
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 4
92515: PUSH
92516: LD_INT 4
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 3
92525: PUSH
92526: LD_INT 4
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 2
92535: PUSH
92536: LD_INT 3
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 2
92545: PUSH
92546: LD_INT 2
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 4
92555: PUSH
92556: LD_INT 2
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 2
92565: PUSH
92566: LD_INT 4
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 0
92575: PUSH
92576: LD_INT 4
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 0
92585: PUSH
92586: LD_INT 3
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 1
92595: PUSH
92596: LD_INT 4
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 1
92605: PUSH
92606: LD_INT 5
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 0
92615: PUSH
92616: LD_INT 5
92618: PUSH
92619: EMPTY
92620: LIST
92621: LIST
92622: PUSH
92623: LD_INT 1
92625: NEG
92626: PUSH
92627: LD_INT 4
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 1
92636: NEG
92637: PUSH
92638: LD_INT 3
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 2
92647: PUSH
92648: LD_INT 5
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 2
92657: NEG
92658: PUSH
92659: LD_INT 3
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 3
92668: NEG
92669: PUSH
92670: LD_INT 0
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 3
92679: NEG
92680: PUSH
92681: LD_INT 1
92683: NEG
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: PUSH
92689: LD_INT 2
92691: NEG
92692: PUSH
92693: LD_INT 0
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 2
92702: NEG
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 3
92713: NEG
92714: PUSH
92715: LD_INT 1
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 4
92724: NEG
92725: PUSH
92726: LD_INT 0
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 4
92735: NEG
92736: PUSH
92737: LD_INT 1
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 4
92747: NEG
92748: PUSH
92749: LD_INT 2
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 2
92759: NEG
92760: PUSH
92761: LD_INT 2
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 4
92770: NEG
92771: PUSH
92772: LD_INT 4
92774: NEG
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 4
92782: NEG
92783: PUSH
92784: LD_INT 5
92786: NEG
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 3
92794: NEG
92795: PUSH
92796: LD_INT 4
92798: NEG
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 3
92806: NEG
92807: PUSH
92808: LD_INT 3
92810: NEG
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 4
92818: NEG
92819: PUSH
92820: LD_INT 3
92822: NEG
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 5
92830: NEG
92831: PUSH
92832: LD_INT 4
92834: NEG
92835: PUSH
92836: EMPTY
92837: LIST
92838: LIST
92839: PUSH
92840: LD_INT 5
92842: NEG
92843: PUSH
92844: LD_INT 5
92846: NEG
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 3
92854: NEG
92855: PUSH
92856: LD_INT 5
92858: NEG
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: LD_INT 5
92866: NEG
92867: PUSH
92868: LD_INT 3
92870: NEG
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92923: LD_ADDR_VAR 0 30
92927: PUSH
92928: LD_INT 4
92930: PUSH
92931: LD_INT 4
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 4
92940: PUSH
92941: LD_INT 3
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 5
92950: PUSH
92951: LD_INT 4
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: PUSH
92958: LD_INT 5
92960: PUSH
92961: LD_INT 5
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 4
92970: PUSH
92971: LD_INT 5
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 3
92980: PUSH
92981: LD_INT 4
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 3
92990: PUSH
92991: LD_INT 3
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 5
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 3
93010: PUSH
93011: LD_INT 5
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: PUSH
93018: LD_INT 0
93020: PUSH
93021: LD_INT 3
93023: PUSH
93024: EMPTY
93025: LIST
93026: LIST
93027: PUSH
93028: LD_INT 0
93030: PUSH
93031: LD_INT 2
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: LD_INT 1
93040: PUSH
93041: LD_INT 3
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 1
93050: PUSH
93051: LD_INT 4
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 0
93060: PUSH
93061: LD_INT 4
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 1
93070: NEG
93071: PUSH
93072: LD_INT 3
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 1
93081: NEG
93082: PUSH
93083: LD_INT 2
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 2
93092: PUSH
93093: LD_INT 4
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 2
93102: NEG
93103: PUSH
93104: LD_INT 2
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 4
93113: NEG
93114: PUSH
93115: LD_INT 0
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 4
93124: NEG
93125: PUSH
93126: LD_INT 1
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 3
93136: NEG
93137: PUSH
93138: LD_INT 0
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: LD_INT 3
93147: NEG
93148: PUSH
93149: LD_INT 1
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 4
93158: NEG
93159: PUSH
93160: LD_INT 1
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 5
93169: NEG
93170: PUSH
93171: LD_INT 0
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 5
93180: NEG
93181: PUSH
93182: LD_INT 1
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 5
93192: NEG
93193: PUSH
93194: LD_INT 2
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 3
93204: NEG
93205: PUSH
93206: LD_INT 2
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 3
93215: NEG
93216: PUSH
93217: LD_INT 3
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: LD_INT 3
93227: NEG
93228: PUSH
93229: LD_INT 4
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 2
93239: NEG
93240: PUSH
93241: LD_INT 3
93243: NEG
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 2
93251: NEG
93252: PUSH
93253: LD_INT 2
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 3
93263: NEG
93264: PUSH
93265: LD_INT 2
93267: NEG
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 4
93275: NEG
93276: PUSH
93277: LD_INT 3
93279: NEG
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 4
93287: NEG
93288: PUSH
93289: LD_INT 4
93291: NEG
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 2
93299: NEG
93300: PUSH
93301: LD_INT 4
93303: NEG
93304: PUSH
93305: EMPTY
93306: LIST
93307: LIST
93308: PUSH
93309: LD_INT 4
93311: NEG
93312: PUSH
93313: LD_INT 2
93315: NEG
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 0
93323: PUSH
93324: LD_INT 4
93326: NEG
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 0
93334: PUSH
93335: LD_INT 5
93337: NEG
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: PUSH
93343: LD_INT 1
93345: PUSH
93346: LD_INT 4
93348: NEG
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: PUSH
93354: LD_INT 1
93356: PUSH
93357: LD_INT 3
93359: NEG
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: PUSH
93365: LD_INT 0
93367: PUSH
93368: LD_INT 3
93370: NEG
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: PUSH
93376: LD_INT 1
93378: NEG
93379: PUSH
93380: LD_INT 4
93382: NEG
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: LD_INT 5
93394: NEG
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 2
93402: PUSH
93403: LD_INT 3
93405: NEG
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 2
93413: NEG
93414: PUSH
93415: LD_INT 5
93417: NEG
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93470: LD_ADDR_VAR 0 31
93474: PUSH
93475: LD_INT 0
93477: PUSH
93478: LD_INT 4
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 0
93487: PUSH
93488: LD_INT 3
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 1
93497: PUSH
93498: LD_INT 4
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: LD_INT 5
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 0
93517: PUSH
93518: LD_INT 5
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 1
93527: NEG
93528: PUSH
93529: LD_INT 4
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 1
93538: NEG
93539: PUSH
93540: LD_INT 3
93542: PUSH
93543: EMPTY
93544: LIST
93545: LIST
93546: PUSH
93547: LD_INT 2
93549: PUSH
93550: LD_INT 5
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 2
93559: NEG
93560: PUSH
93561: LD_INT 3
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: LD_INT 0
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 3
93581: NEG
93582: PUSH
93583: LD_INT 1
93585: NEG
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 2
93593: NEG
93594: PUSH
93595: LD_INT 0
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 2
93604: NEG
93605: PUSH
93606: LD_INT 1
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: PUSH
93613: LD_INT 3
93615: NEG
93616: PUSH
93617: LD_INT 1
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 4
93626: NEG
93627: PUSH
93628: LD_INT 0
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 4
93637: NEG
93638: PUSH
93639: LD_INT 1
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 4
93649: NEG
93650: PUSH
93651: LD_INT 2
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 2
93661: NEG
93662: PUSH
93663: LD_INT 2
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 4
93672: NEG
93673: PUSH
93674: LD_INT 4
93676: NEG
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: LD_INT 4
93684: NEG
93685: PUSH
93686: LD_INT 5
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 3
93696: NEG
93697: PUSH
93698: LD_INT 4
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 3
93708: NEG
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 4
93720: NEG
93721: PUSH
93722: LD_INT 3
93724: NEG
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 5
93732: NEG
93733: PUSH
93734: LD_INT 4
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 5
93744: NEG
93745: PUSH
93746: LD_INT 5
93748: NEG
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 3
93756: NEG
93757: PUSH
93758: LD_INT 5
93760: NEG
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: PUSH
93766: LD_INT 5
93768: NEG
93769: PUSH
93770: LD_INT 3
93772: NEG
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: LD_INT 0
93780: PUSH
93781: LD_INT 3
93783: NEG
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: PUSH
93789: LD_INT 0
93791: PUSH
93792: LD_INT 4
93794: NEG
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 1
93802: PUSH
93803: LD_INT 3
93805: NEG
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: PUSH
93811: LD_INT 1
93813: PUSH
93814: LD_INT 2
93816: NEG
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 0
93824: PUSH
93825: LD_INT 2
93827: NEG
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 1
93835: NEG
93836: PUSH
93837: LD_INT 3
93839: NEG
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 1
93847: NEG
93848: PUSH
93849: LD_INT 4
93851: NEG
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 2
93859: PUSH
93860: LD_INT 2
93862: NEG
93863: PUSH
93864: EMPTY
93865: LIST
93866: LIST
93867: PUSH
93868: LD_INT 2
93870: NEG
93871: PUSH
93872: LD_INT 4
93874: NEG
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 4
93882: PUSH
93883: LD_INT 0
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: LD_INT 4
93892: PUSH
93893: LD_INT 1
93895: NEG
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 5
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: LD_INT 5
93913: PUSH
93914: LD_INT 1
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 4
93923: PUSH
93924: LD_INT 1
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 3
93933: PUSH
93934: LD_INT 0
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 3
93943: PUSH
93944: LD_INT 1
93946: NEG
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 3
93954: PUSH
93955: LD_INT 2
93957: NEG
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 5
93965: PUSH
93966: LD_INT 2
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94020: LD_ADDR_VAR 0 32
94024: PUSH
94025: LD_INT 4
94027: NEG
94028: PUSH
94029: LD_INT 0
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 4
94038: NEG
94039: PUSH
94040: LD_INT 1
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 3
94050: NEG
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 3
94061: NEG
94062: PUSH
94063: LD_INT 1
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 4
94072: NEG
94073: PUSH
94074: LD_INT 1
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 5
94083: NEG
94084: PUSH
94085: LD_INT 0
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 5
94094: NEG
94095: PUSH
94096: LD_INT 1
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 5
94106: NEG
94107: PUSH
94108: LD_INT 2
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 3
94118: NEG
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: PUSH
94127: LD_INT 3
94129: NEG
94130: PUSH
94131: LD_INT 3
94133: NEG
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 3
94141: NEG
94142: PUSH
94143: LD_INT 4
94145: NEG
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 2
94153: NEG
94154: PUSH
94155: LD_INT 3
94157: NEG
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: LD_INT 2
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 3
94177: NEG
94178: PUSH
94179: LD_INT 2
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 4
94189: NEG
94190: PUSH
94191: LD_INT 3
94193: NEG
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 4
94201: NEG
94202: PUSH
94203: LD_INT 4
94205: NEG
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PUSH
94211: LD_INT 2
94213: NEG
94214: PUSH
94215: LD_INT 4
94217: NEG
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 4
94225: NEG
94226: PUSH
94227: LD_INT 2
94229: NEG
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 0
94237: PUSH
94238: LD_INT 4
94240: NEG
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 0
94248: PUSH
94249: LD_INT 5
94251: NEG
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: PUSH
94257: LD_INT 1
94259: PUSH
94260: LD_INT 4
94262: NEG
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: PUSH
94268: LD_INT 1
94270: PUSH
94271: LD_INT 3
94273: NEG
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: LD_INT 0
94281: PUSH
94282: LD_INT 3
94284: NEG
94285: PUSH
94286: EMPTY
94287: LIST
94288: LIST
94289: PUSH
94290: LD_INT 1
94292: NEG
94293: PUSH
94294: LD_INT 4
94296: NEG
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 1
94304: NEG
94305: PUSH
94306: LD_INT 5
94308: NEG
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 2
94316: PUSH
94317: LD_INT 3
94319: NEG
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 2
94327: NEG
94328: PUSH
94329: LD_INT 5
94331: NEG
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 3
94339: PUSH
94340: LD_INT 0
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: LD_INT 3
94349: PUSH
94350: LD_INT 1
94352: NEG
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 4
94360: PUSH
94361: LD_INT 0
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 4
94370: PUSH
94371: LD_INT 1
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 3
94380: PUSH
94381: LD_INT 1
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 2
94390: PUSH
94391: LD_INT 0
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 2
94400: PUSH
94401: LD_INT 1
94403: NEG
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 2
94411: PUSH
94412: LD_INT 2
94414: NEG
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: PUSH
94420: LD_INT 4
94422: PUSH
94423: LD_INT 2
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 4
94432: PUSH
94433: LD_INT 4
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: LD_INT 4
94442: PUSH
94443: LD_INT 3
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: PUSH
94450: LD_INT 5
94452: PUSH
94453: LD_INT 4
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 5
94462: PUSH
94463: LD_INT 5
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 4
94472: PUSH
94473: LD_INT 5
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 3
94482: PUSH
94483: LD_INT 4
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 3
94492: PUSH
94493: LD_INT 3
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: LD_INT 5
94502: PUSH
94503: LD_INT 3
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 3
94512: PUSH
94513: LD_INT 5
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94567: LD_ADDR_VAR 0 33
94571: PUSH
94572: LD_INT 4
94574: NEG
94575: PUSH
94576: LD_INT 4
94578: NEG
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 4
94586: NEG
94587: PUSH
94588: LD_INT 5
94590: NEG
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 3
94598: NEG
94599: PUSH
94600: LD_INT 4
94602: NEG
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 3
94610: NEG
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 4
94622: NEG
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 5
94634: NEG
94635: PUSH
94636: LD_INT 4
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 5
94646: NEG
94647: PUSH
94648: LD_INT 5
94650: NEG
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 3
94658: NEG
94659: PUSH
94660: LD_INT 5
94662: NEG
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 5
94670: NEG
94671: PUSH
94672: LD_INT 3
94674: NEG
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: LD_INT 0
94682: PUSH
94683: LD_INT 3
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 0
94693: PUSH
94694: LD_INT 4
94696: NEG
94697: PUSH
94698: EMPTY
94699: LIST
94700: LIST
94701: PUSH
94702: LD_INT 1
94704: PUSH
94705: LD_INT 3
94707: NEG
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: PUSH
94713: LD_INT 1
94715: PUSH
94716: LD_INT 2
94718: NEG
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 0
94726: PUSH
94727: LD_INT 2
94729: NEG
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 1
94737: NEG
94738: PUSH
94739: LD_INT 3
94741: NEG
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 1
94749: NEG
94750: PUSH
94751: LD_INT 4
94753: NEG
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 2
94761: PUSH
94762: LD_INT 2
94764: NEG
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 2
94772: NEG
94773: PUSH
94774: LD_INT 4
94776: NEG
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 4
94784: PUSH
94785: LD_INT 0
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 4
94794: PUSH
94795: LD_INT 1
94797: NEG
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 5
94805: PUSH
94806: LD_INT 0
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: LD_INT 1
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 4
94825: PUSH
94826: LD_INT 1
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 3
94835: PUSH
94836: LD_INT 0
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: LD_INT 1
94848: NEG
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 3
94856: PUSH
94857: LD_INT 2
94859: NEG
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 5
94867: PUSH
94868: LD_INT 2
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 3
94877: PUSH
94878: LD_INT 3
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: LD_INT 2
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: LD_INT 3
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 4
94907: PUSH
94908: LD_INT 4
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 3
94917: PUSH
94918: LD_INT 4
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 2
94927: PUSH
94928: LD_INT 3
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 2
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 4
94947: PUSH
94948: LD_INT 2
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 2
94957: PUSH
94958: LD_INT 4
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 0
94967: PUSH
94968: LD_INT 4
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 0
94977: PUSH
94978: LD_INT 3
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 1
94987: PUSH
94988: LD_INT 4
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: PUSH
94995: LD_INT 1
94997: PUSH
94998: LD_INT 5
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 0
95007: PUSH
95008: LD_INT 5
95010: PUSH
95011: EMPTY
95012: LIST
95013: LIST
95014: PUSH
95015: LD_INT 1
95017: NEG
95018: PUSH
95019: LD_INT 4
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 1
95028: NEG
95029: PUSH
95030: LD_INT 3
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 2
95039: PUSH
95040: LD_INT 5
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: LD_INT 2
95049: NEG
95050: PUSH
95051: LD_INT 3
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95105: LD_ADDR_VAR 0 34
95109: PUSH
95110: LD_INT 0
95112: PUSH
95113: LD_INT 4
95115: NEG
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: PUSH
95121: LD_INT 0
95123: PUSH
95124: LD_INT 5
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 1
95134: PUSH
95135: LD_INT 4
95137: NEG
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 1
95145: PUSH
95146: LD_INT 3
95148: NEG
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PUSH
95154: LD_INT 0
95156: PUSH
95157: LD_INT 3
95159: NEG
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 1
95167: NEG
95168: PUSH
95169: LD_INT 4
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 1
95179: NEG
95180: PUSH
95181: LD_INT 5
95183: NEG
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 2
95191: PUSH
95192: LD_INT 3
95194: NEG
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: PUSH
95200: LD_INT 2
95202: NEG
95203: PUSH
95204: LD_INT 5
95206: NEG
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 3
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 3
95224: PUSH
95225: LD_INT 1
95227: NEG
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 4
95235: PUSH
95236: LD_INT 0
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 4
95245: PUSH
95246: LD_INT 1
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 3
95255: PUSH
95256: LD_INT 1
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 2
95265: PUSH
95266: LD_INT 0
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 2
95275: PUSH
95276: LD_INT 1
95278: NEG
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 2
95286: PUSH
95287: LD_INT 2
95289: NEG
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 4
95297: PUSH
95298: LD_INT 2
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 4
95307: PUSH
95308: LD_INT 4
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 4
95317: PUSH
95318: LD_INT 3
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 5
95327: PUSH
95328: LD_INT 4
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 5
95337: PUSH
95338: LD_INT 5
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 4
95347: PUSH
95348: LD_INT 5
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 3
95357: PUSH
95358: LD_INT 4
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 3
95367: PUSH
95368: LD_INT 3
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 5
95377: PUSH
95378: LD_INT 3
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 3
95387: PUSH
95388: LD_INT 5
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: LD_INT 3
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: PUSH
95405: LD_INT 0
95407: PUSH
95408: LD_INT 2
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: LD_INT 3
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 1
95427: PUSH
95428: LD_INT 4
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 0
95437: PUSH
95438: LD_INT 4
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: PUSH
95445: LD_INT 1
95447: NEG
95448: PUSH
95449: LD_INT 3
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 1
95458: NEG
95459: PUSH
95460: LD_INT 2
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 2
95469: PUSH
95470: LD_INT 4
95472: PUSH
95473: EMPTY
95474: LIST
95475: LIST
95476: PUSH
95477: LD_INT 2
95479: NEG
95480: PUSH
95481: LD_INT 2
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 4
95490: NEG
95491: PUSH
95492: LD_INT 0
95494: PUSH
95495: EMPTY
95496: LIST
95497: LIST
95498: PUSH
95499: LD_INT 4
95501: NEG
95502: PUSH
95503: LD_INT 1
95505: NEG
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 3
95513: NEG
95514: PUSH
95515: LD_INT 0
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 3
95524: NEG
95525: PUSH
95526: LD_INT 1
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 4
95535: NEG
95536: PUSH
95537: LD_INT 1
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 5
95546: NEG
95547: PUSH
95548: LD_INT 0
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 5
95557: NEG
95558: PUSH
95559: LD_INT 1
95561: NEG
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 5
95569: NEG
95570: PUSH
95571: LD_INT 2
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 3
95581: NEG
95582: PUSH
95583: LD_INT 2
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: ST_TO_ADDR
// end ; end ;
95637: GO 95640
95639: POP
// case btype of b_depot , b_warehouse :
95640: LD_VAR 0 1
95644: PUSH
95645: LD_INT 0
95647: DOUBLE
95648: EQUAL
95649: IFTRUE 95659
95651: LD_INT 1
95653: DOUBLE
95654: EQUAL
95655: IFTRUE 95659
95657: GO 95860
95659: POP
// case nation of nation_american :
95660: LD_VAR 0 5
95664: PUSH
95665: LD_INT 1
95667: DOUBLE
95668: EQUAL
95669: IFTRUE 95673
95671: GO 95729
95673: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95674: LD_ADDR_VAR 0 9
95678: PUSH
95679: LD_VAR 0 11
95683: PUSH
95684: LD_VAR 0 12
95688: PUSH
95689: LD_VAR 0 13
95693: PUSH
95694: LD_VAR 0 14
95698: PUSH
95699: LD_VAR 0 15
95703: PUSH
95704: LD_VAR 0 16
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: PUSH
95717: LD_VAR 0 4
95721: PUSH
95722: LD_INT 1
95724: PLUS
95725: ARRAY
95726: ST_TO_ADDR
95727: GO 95858
95729: LD_INT 2
95731: DOUBLE
95732: EQUAL
95733: IFTRUE 95737
95735: GO 95793
95737: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95738: LD_ADDR_VAR 0 9
95742: PUSH
95743: LD_VAR 0 17
95747: PUSH
95748: LD_VAR 0 18
95752: PUSH
95753: LD_VAR 0 19
95757: PUSH
95758: LD_VAR 0 20
95762: PUSH
95763: LD_VAR 0 21
95767: PUSH
95768: LD_VAR 0 22
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: PUSH
95781: LD_VAR 0 4
95785: PUSH
95786: LD_INT 1
95788: PLUS
95789: ARRAY
95790: ST_TO_ADDR
95791: GO 95858
95793: LD_INT 3
95795: DOUBLE
95796: EQUAL
95797: IFTRUE 95801
95799: GO 95857
95801: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95802: LD_ADDR_VAR 0 9
95806: PUSH
95807: LD_VAR 0 23
95811: PUSH
95812: LD_VAR 0 24
95816: PUSH
95817: LD_VAR 0 25
95821: PUSH
95822: LD_VAR 0 26
95826: PUSH
95827: LD_VAR 0 27
95831: PUSH
95832: LD_VAR 0 28
95836: PUSH
95837: EMPTY
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: PUSH
95845: LD_VAR 0 4
95849: PUSH
95850: LD_INT 1
95852: PLUS
95853: ARRAY
95854: ST_TO_ADDR
95855: GO 95858
95857: POP
95858: GO 96413
95860: LD_INT 2
95862: DOUBLE
95863: EQUAL
95864: IFTRUE 95874
95866: LD_INT 3
95868: DOUBLE
95869: EQUAL
95870: IFTRUE 95874
95872: GO 95930
95874: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95875: LD_ADDR_VAR 0 9
95879: PUSH
95880: LD_VAR 0 29
95884: PUSH
95885: LD_VAR 0 30
95889: PUSH
95890: LD_VAR 0 31
95894: PUSH
95895: LD_VAR 0 32
95899: PUSH
95900: LD_VAR 0 33
95904: PUSH
95905: LD_VAR 0 34
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: PUSH
95918: LD_VAR 0 4
95922: PUSH
95923: LD_INT 1
95925: PLUS
95926: ARRAY
95927: ST_TO_ADDR
95928: GO 96413
95930: LD_INT 16
95932: DOUBLE
95933: EQUAL
95934: IFTRUE 95992
95936: LD_INT 17
95938: DOUBLE
95939: EQUAL
95940: IFTRUE 95992
95942: LD_INT 18
95944: DOUBLE
95945: EQUAL
95946: IFTRUE 95992
95948: LD_INT 19
95950: DOUBLE
95951: EQUAL
95952: IFTRUE 95992
95954: LD_INT 22
95956: DOUBLE
95957: EQUAL
95958: IFTRUE 95992
95960: LD_INT 20
95962: DOUBLE
95963: EQUAL
95964: IFTRUE 95992
95966: LD_INT 21
95968: DOUBLE
95969: EQUAL
95970: IFTRUE 95992
95972: LD_INT 23
95974: DOUBLE
95975: EQUAL
95976: IFTRUE 95992
95978: LD_INT 24
95980: DOUBLE
95981: EQUAL
95982: IFTRUE 95992
95984: LD_INT 25
95986: DOUBLE
95987: EQUAL
95988: IFTRUE 95992
95990: GO 96048
95992: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95993: LD_ADDR_VAR 0 9
95997: PUSH
95998: LD_VAR 0 35
96002: PUSH
96003: LD_VAR 0 36
96007: PUSH
96008: LD_VAR 0 37
96012: PUSH
96013: LD_VAR 0 38
96017: PUSH
96018: LD_VAR 0 39
96022: PUSH
96023: LD_VAR 0 40
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: PUSH
96036: LD_VAR 0 4
96040: PUSH
96041: LD_INT 1
96043: PLUS
96044: ARRAY
96045: ST_TO_ADDR
96046: GO 96413
96048: LD_INT 6
96050: DOUBLE
96051: EQUAL
96052: IFTRUE 96104
96054: LD_INT 7
96056: DOUBLE
96057: EQUAL
96058: IFTRUE 96104
96060: LD_INT 8
96062: DOUBLE
96063: EQUAL
96064: IFTRUE 96104
96066: LD_INT 13
96068: DOUBLE
96069: EQUAL
96070: IFTRUE 96104
96072: LD_INT 12
96074: DOUBLE
96075: EQUAL
96076: IFTRUE 96104
96078: LD_INT 15
96080: DOUBLE
96081: EQUAL
96082: IFTRUE 96104
96084: LD_INT 11
96086: DOUBLE
96087: EQUAL
96088: IFTRUE 96104
96090: LD_INT 14
96092: DOUBLE
96093: EQUAL
96094: IFTRUE 96104
96096: LD_INT 10
96098: DOUBLE
96099: EQUAL
96100: IFTRUE 96104
96102: GO 96160
96104: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96105: LD_ADDR_VAR 0 9
96109: PUSH
96110: LD_VAR 0 41
96114: PUSH
96115: LD_VAR 0 42
96119: PUSH
96120: LD_VAR 0 43
96124: PUSH
96125: LD_VAR 0 44
96129: PUSH
96130: LD_VAR 0 45
96134: PUSH
96135: LD_VAR 0 46
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: PUSH
96148: LD_VAR 0 4
96152: PUSH
96153: LD_INT 1
96155: PLUS
96156: ARRAY
96157: ST_TO_ADDR
96158: GO 96413
96160: LD_INT 36
96162: DOUBLE
96163: EQUAL
96164: IFTRUE 96168
96166: GO 96224
96168: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96169: LD_ADDR_VAR 0 9
96173: PUSH
96174: LD_VAR 0 47
96178: PUSH
96179: LD_VAR 0 48
96183: PUSH
96184: LD_VAR 0 49
96188: PUSH
96189: LD_VAR 0 50
96193: PUSH
96194: LD_VAR 0 51
96198: PUSH
96199: LD_VAR 0 52
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: PUSH
96212: LD_VAR 0 4
96216: PUSH
96217: LD_INT 1
96219: PLUS
96220: ARRAY
96221: ST_TO_ADDR
96222: GO 96413
96224: LD_INT 4
96226: DOUBLE
96227: EQUAL
96228: IFTRUE 96250
96230: LD_INT 5
96232: DOUBLE
96233: EQUAL
96234: IFTRUE 96250
96236: LD_INT 34
96238: DOUBLE
96239: EQUAL
96240: IFTRUE 96250
96242: LD_INT 37
96244: DOUBLE
96245: EQUAL
96246: IFTRUE 96250
96248: GO 96306
96250: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96251: LD_ADDR_VAR 0 9
96255: PUSH
96256: LD_VAR 0 53
96260: PUSH
96261: LD_VAR 0 54
96265: PUSH
96266: LD_VAR 0 55
96270: PUSH
96271: LD_VAR 0 56
96275: PUSH
96276: LD_VAR 0 57
96280: PUSH
96281: LD_VAR 0 58
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: PUSH
96294: LD_VAR 0 4
96298: PUSH
96299: LD_INT 1
96301: PLUS
96302: ARRAY
96303: ST_TO_ADDR
96304: GO 96413
96306: LD_INT 31
96308: DOUBLE
96309: EQUAL
96310: IFTRUE 96356
96312: LD_INT 32
96314: DOUBLE
96315: EQUAL
96316: IFTRUE 96356
96318: LD_INT 33
96320: DOUBLE
96321: EQUAL
96322: IFTRUE 96356
96324: LD_INT 27
96326: DOUBLE
96327: EQUAL
96328: IFTRUE 96356
96330: LD_INT 26
96332: DOUBLE
96333: EQUAL
96334: IFTRUE 96356
96336: LD_INT 28
96338: DOUBLE
96339: EQUAL
96340: IFTRUE 96356
96342: LD_INT 29
96344: DOUBLE
96345: EQUAL
96346: IFTRUE 96356
96348: LD_INT 30
96350: DOUBLE
96351: EQUAL
96352: IFTRUE 96356
96354: GO 96412
96356: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96357: LD_ADDR_VAR 0 9
96361: PUSH
96362: LD_VAR 0 59
96366: PUSH
96367: LD_VAR 0 60
96371: PUSH
96372: LD_VAR 0 61
96376: PUSH
96377: LD_VAR 0 62
96381: PUSH
96382: LD_VAR 0 63
96386: PUSH
96387: LD_VAR 0 64
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: PUSH
96400: LD_VAR 0 4
96404: PUSH
96405: LD_INT 1
96407: PLUS
96408: ARRAY
96409: ST_TO_ADDR
96410: GO 96413
96412: POP
// temp_list2 = [ ] ;
96413: LD_ADDR_VAR 0 10
96417: PUSH
96418: EMPTY
96419: ST_TO_ADDR
// for i in temp_list do
96420: LD_ADDR_VAR 0 8
96424: PUSH
96425: LD_VAR 0 9
96429: PUSH
96430: FOR_IN
96431: IFFALSE 96483
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96433: LD_ADDR_VAR 0 10
96437: PUSH
96438: LD_VAR 0 10
96442: PUSH
96443: LD_VAR 0 8
96447: PUSH
96448: LD_INT 1
96450: ARRAY
96451: PUSH
96452: LD_VAR 0 2
96456: PLUS
96457: PUSH
96458: LD_VAR 0 8
96462: PUSH
96463: LD_INT 2
96465: ARRAY
96466: PUSH
96467: LD_VAR 0 3
96471: PLUS
96472: PUSH
96473: EMPTY
96474: LIST
96475: LIST
96476: PUSH
96477: EMPTY
96478: LIST
96479: ADD
96480: ST_TO_ADDR
96481: GO 96430
96483: POP
96484: POP
// result = temp_list2 ;
96485: LD_ADDR_VAR 0 7
96489: PUSH
96490: LD_VAR 0 10
96494: ST_TO_ADDR
// end ;
96495: LD_VAR 0 7
96499: RET
// export function EnemyInRange ( unit , dist ) ; begin
96500: LD_INT 0
96502: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96503: LD_ADDR_VAR 0 3
96507: PUSH
96508: LD_VAR 0 1
96512: PPUSH
96513: CALL_OW 255
96517: PPUSH
96518: LD_VAR 0 1
96522: PPUSH
96523: CALL_OW 250
96527: PPUSH
96528: LD_VAR 0 1
96532: PPUSH
96533: CALL_OW 251
96537: PPUSH
96538: LD_VAR 0 2
96542: PPUSH
96543: CALL 70604 0 4
96547: PUSH
96548: LD_INT 4
96550: ARRAY
96551: ST_TO_ADDR
// end ;
96552: LD_VAR 0 3
96556: RET
// export function PlayerSeeMe ( unit ) ; begin
96557: LD_INT 0
96559: PPUSH
// result := See ( your_side , unit ) ;
96560: LD_ADDR_VAR 0 2
96564: PUSH
96565: LD_OWVAR 2
96569: PPUSH
96570: LD_VAR 0 1
96574: PPUSH
96575: CALL_OW 292
96579: ST_TO_ADDR
// end ;
96580: LD_VAR 0 2
96584: RET
// export function ReverseDir ( unit ) ; begin
96585: LD_INT 0
96587: PPUSH
// if not unit then
96588: LD_VAR 0 1
96592: NOT
96593: IFFALSE 96597
// exit ;
96595: GO 96643
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
96597: LD_ADDR_VAR 0 2
96601: PUSH
96602: LD_INT 3
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 5
96610: PUSH
96611: LD_INT 0
96613: PUSH
96614: LD_INT 1
96616: PUSH
96617: LD_INT 2
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: PUSH
96628: LD_VAR 0 1
96632: PPUSH
96633: CALL_OW 254
96637: PUSH
96638: LD_INT 1
96640: PLUS
96641: ARRAY
96642: ST_TO_ADDR
// end ;
96643: LD_VAR 0 2
96647: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96648: LD_INT 0
96650: PPUSH
96651: PPUSH
96652: PPUSH
96653: PPUSH
96654: PPUSH
// if not hexes then
96655: LD_VAR 0 2
96659: NOT
96660: IFFALSE 96664
// exit ;
96662: GO 96812
// dist := 9999 ;
96664: LD_ADDR_VAR 0 5
96668: PUSH
96669: LD_INT 9999
96671: ST_TO_ADDR
// for i = 1 to hexes do
96672: LD_ADDR_VAR 0 4
96676: PUSH
96677: DOUBLE
96678: LD_INT 1
96680: DEC
96681: ST_TO_ADDR
96682: LD_VAR 0 2
96686: PUSH
96687: FOR_TO
96688: IFFALSE 96800
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96690: LD_VAR 0 1
96694: PPUSH
96695: LD_VAR 0 2
96699: PUSH
96700: LD_VAR 0 4
96704: ARRAY
96705: PUSH
96706: LD_INT 1
96708: ARRAY
96709: PPUSH
96710: LD_VAR 0 2
96714: PUSH
96715: LD_VAR 0 4
96719: ARRAY
96720: PUSH
96721: LD_INT 2
96723: ARRAY
96724: PPUSH
96725: CALL_OW 297
96729: PUSH
96730: LD_VAR 0 5
96734: LESS
96735: IFFALSE 96798
// begin hex := hexes [ i ] ;
96737: LD_ADDR_VAR 0 7
96741: PUSH
96742: LD_VAR 0 2
96746: PUSH
96747: LD_VAR 0 4
96751: ARRAY
96752: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96753: LD_ADDR_VAR 0 5
96757: PUSH
96758: LD_VAR 0 1
96762: PPUSH
96763: LD_VAR 0 2
96767: PUSH
96768: LD_VAR 0 4
96772: ARRAY
96773: PUSH
96774: LD_INT 1
96776: ARRAY
96777: PPUSH
96778: LD_VAR 0 2
96782: PUSH
96783: LD_VAR 0 4
96787: ARRAY
96788: PUSH
96789: LD_INT 2
96791: ARRAY
96792: PPUSH
96793: CALL_OW 297
96797: ST_TO_ADDR
// end ; end ;
96798: GO 96687
96800: POP
96801: POP
// result := hex ;
96802: LD_ADDR_VAR 0 3
96806: PUSH
96807: LD_VAR 0 7
96811: ST_TO_ADDR
// end ;
96812: LD_VAR 0 3
96816: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96817: LD_INT 0
96819: PPUSH
96820: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96821: LD_VAR 0 1
96825: NOT
96826: PUSH
96827: LD_VAR 0 1
96831: PUSH
96832: LD_INT 21
96834: PUSH
96835: LD_INT 2
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: PUSH
96842: LD_INT 23
96844: PUSH
96845: LD_INT 2
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PPUSH
96856: CALL_OW 69
96860: IN
96861: NOT
96862: OR
96863: IFFALSE 96867
// exit ;
96865: GO 96914
// for i = 1 to 3 do
96867: LD_ADDR_VAR 0 3
96871: PUSH
96872: DOUBLE
96873: LD_INT 1
96875: DEC
96876: ST_TO_ADDR
96877: LD_INT 3
96879: PUSH
96880: FOR_TO
96881: IFFALSE 96912
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96883: LD_VAR 0 1
96887: PPUSH
96888: CALL_OW 250
96892: PPUSH
96893: LD_VAR 0 1
96897: PPUSH
96898: CALL_OW 251
96902: PPUSH
96903: LD_INT 1
96905: PPUSH
96906: CALL_OW 453
96910: GO 96880
96912: POP
96913: POP
// end ;
96914: LD_VAR 0 2
96918: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96919: LD_INT 0
96921: PPUSH
96922: PPUSH
96923: PPUSH
96924: PPUSH
96925: PPUSH
96926: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96927: LD_VAR 0 1
96931: NOT
96932: PUSH
96933: LD_VAR 0 2
96937: NOT
96938: OR
96939: PUSH
96940: LD_VAR 0 1
96944: PPUSH
96945: CALL_OW 314
96949: OR
96950: IFFALSE 96954
// exit ;
96952: GO 97395
// x := GetX ( enemy_unit ) ;
96954: LD_ADDR_VAR 0 7
96958: PUSH
96959: LD_VAR 0 2
96963: PPUSH
96964: CALL_OW 250
96968: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96969: LD_ADDR_VAR 0 8
96973: PUSH
96974: LD_VAR 0 2
96978: PPUSH
96979: CALL_OW 251
96983: ST_TO_ADDR
// if not x or not y then
96984: LD_VAR 0 7
96988: NOT
96989: PUSH
96990: LD_VAR 0 8
96994: NOT
96995: OR
96996: IFFALSE 97000
// exit ;
96998: GO 97395
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97000: LD_ADDR_VAR 0 6
97004: PUSH
97005: LD_VAR 0 7
97009: PPUSH
97010: LD_INT 0
97012: PPUSH
97013: LD_INT 4
97015: PPUSH
97016: CALL_OW 272
97020: PUSH
97021: LD_VAR 0 8
97025: PPUSH
97026: LD_INT 0
97028: PPUSH
97029: LD_INT 4
97031: PPUSH
97032: CALL_OW 273
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_VAR 0 7
97045: PPUSH
97046: LD_INT 1
97048: PPUSH
97049: LD_INT 4
97051: PPUSH
97052: CALL_OW 272
97056: PUSH
97057: LD_VAR 0 8
97061: PPUSH
97062: LD_INT 1
97064: PPUSH
97065: LD_INT 4
97067: PPUSH
97068: CALL_OW 273
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: PUSH
97077: LD_VAR 0 7
97081: PPUSH
97082: LD_INT 2
97084: PPUSH
97085: LD_INT 4
97087: PPUSH
97088: CALL_OW 272
97092: PUSH
97093: LD_VAR 0 8
97097: PPUSH
97098: LD_INT 2
97100: PPUSH
97101: LD_INT 4
97103: PPUSH
97104: CALL_OW 273
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_VAR 0 7
97117: PPUSH
97118: LD_INT 3
97120: PPUSH
97121: LD_INT 4
97123: PPUSH
97124: CALL_OW 272
97128: PUSH
97129: LD_VAR 0 8
97133: PPUSH
97134: LD_INT 3
97136: PPUSH
97137: LD_INT 4
97139: PPUSH
97140: CALL_OW 273
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: LD_VAR 0 7
97153: PPUSH
97154: LD_INT 4
97156: PPUSH
97157: LD_INT 4
97159: PPUSH
97160: CALL_OW 272
97164: PUSH
97165: LD_VAR 0 8
97169: PPUSH
97170: LD_INT 4
97172: PPUSH
97173: LD_INT 4
97175: PPUSH
97176: CALL_OW 273
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_VAR 0 7
97189: PPUSH
97190: LD_INT 5
97192: PPUSH
97193: LD_INT 4
97195: PPUSH
97196: CALL_OW 272
97200: PUSH
97201: LD_VAR 0 8
97205: PPUSH
97206: LD_INT 5
97208: PPUSH
97209: LD_INT 4
97211: PPUSH
97212: CALL_OW 273
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: ST_TO_ADDR
// for i = tmp downto 1 do
97229: LD_ADDR_VAR 0 4
97233: PUSH
97234: DOUBLE
97235: LD_VAR 0 6
97239: INC
97240: ST_TO_ADDR
97241: LD_INT 1
97243: PUSH
97244: FOR_DOWNTO
97245: IFFALSE 97346
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97247: LD_VAR 0 6
97251: PUSH
97252: LD_VAR 0 4
97256: ARRAY
97257: PUSH
97258: LD_INT 1
97260: ARRAY
97261: PPUSH
97262: LD_VAR 0 6
97266: PUSH
97267: LD_VAR 0 4
97271: ARRAY
97272: PUSH
97273: LD_INT 2
97275: ARRAY
97276: PPUSH
97277: CALL_OW 488
97281: NOT
97282: PUSH
97283: LD_VAR 0 6
97287: PUSH
97288: LD_VAR 0 4
97292: ARRAY
97293: PUSH
97294: LD_INT 1
97296: ARRAY
97297: PPUSH
97298: LD_VAR 0 6
97302: PUSH
97303: LD_VAR 0 4
97307: ARRAY
97308: PUSH
97309: LD_INT 2
97311: ARRAY
97312: PPUSH
97313: CALL_OW 428
97317: PUSH
97318: LD_INT 0
97320: NONEQUAL
97321: OR
97322: IFFALSE 97344
// tmp := Delete ( tmp , i ) ;
97324: LD_ADDR_VAR 0 6
97328: PUSH
97329: LD_VAR 0 6
97333: PPUSH
97334: LD_VAR 0 4
97338: PPUSH
97339: CALL_OW 3
97343: ST_TO_ADDR
97344: GO 97244
97346: POP
97347: POP
// j := GetClosestHex ( unit , tmp ) ;
97348: LD_ADDR_VAR 0 5
97352: PUSH
97353: LD_VAR 0 1
97357: PPUSH
97358: LD_VAR 0 6
97362: PPUSH
97363: CALL 96648 0 2
97367: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97368: LD_VAR 0 1
97372: PPUSH
97373: LD_VAR 0 5
97377: PUSH
97378: LD_INT 1
97380: ARRAY
97381: PPUSH
97382: LD_VAR 0 5
97386: PUSH
97387: LD_INT 2
97389: ARRAY
97390: PPUSH
97391: CALL_OW 111
// end ;
97395: LD_VAR 0 3
97399: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97400: LD_INT 0
97402: PPUSH
97403: PPUSH
97404: PPUSH
// uc_side = 0 ;
97405: LD_ADDR_OWVAR 20
97409: PUSH
97410: LD_INT 0
97412: ST_TO_ADDR
// uc_nation = 0 ;
97413: LD_ADDR_OWVAR 21
97417: PUSH
97418: LD_INT 0
97420: ST_TO_ADDR
// InitHc ;
97421: CALL_OW 19
// InitVc ;
97425: CALL_OW 20
// if mastodonts then
97429: LD_VAR 0 6
97433: IFFALSE 97500
// for i = 1 to mastodonts do
97435: LD_ADDR_VAR 0 11
97439: PUSH
97440: DOUBLE
97441: LD_INT 1
97443: DEC
97444: ST_TO_ADDR
97445: LD_VAR 0 6
97449: PUSH
97450: FOR_TO
97451: IFFALSE 97498
// begin vc_chassis := 31 ;
97453: LD_ADDR_OWVAR 37
97457: PUSH
97458: LD_INT 31
97460: ST_TO_ADDR
// vc_control := control_rider ;
97461: LD_ADDR_OWVAR 38
97465: PUSH
97466: LD_INT 4
97468: ST_TO_ADDR
// animal := CreateVehicle ;
97469: LD_ADDR_VAR 0 12
97473: PUSH
97474: CALL_OW 45
97478: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97479: LD_VAR 0 12
97483: PPUSH
97484: LD_VAR 0 8
97488: PPUSH
97489: LD_INT 0
97491: PPUSH
97492: CALL 104245 0 3
// end ;
97496: GO 97450
97498: POP
97499: POP
// if horses then
97500: LD_VAR 0 5
97504: IFFALSE 97571
// for i = 1 to horses do
97506: LD_ADDR_VAR 0 11
97510: PUSH
97511: DOUBLE
97512: LD_INT 1
97514: DEC
97515: ST_TO_ADDR
97516: LD_VAR 0 5
97520: PUSH
97521: FOR_TO
97522: IFFALSE 97569
// begin hc_class := 21 ;
97524: LD_ADDR_OWVAR 28
97528: PUSH
97529: LD_INT 21
97531: ST_TO_ADDR
// hc_gallery :=  ;
97532: LD_ADDR_OWVAR 33
97536: PUSH
97537: LD_STRING 
97539: ST_TO_ADDR
// animal := CreateHuman ;
97540: LD_ADDR_VAR 0 12
97544: PUSH
97545: CALL_OW 44
97549: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97550: LD_VAR 0 12
97554: PPUSH
97555: LD_VAR 0 8
97559: PPUSH
97560: LD_INT 0
97562: PPUSH
97563: CALL 104245 0 3
// end ;
97567: GO 97521
97569: POP
97570: POP
// if birds then
97571: LD_VAR 0 1
97575: IFFALSE 97642
// for i = 1 to birds do
97577: LD_ADDR_VAR 0 11
97581: PUSH
97582: DOUBLE
97583: LD_INT 1
97585: DEC
97586: ST_TO_ADDR
97587: LD_VAR 0 1
97591: PUSH
97592: FOR_TO
97593: IFFALSE 97640
// begin hc_class = 18 ;
97595: LD_ADDR_OWVAR 28
97599: PUSH
97600: LD_INT 18
97602: ST_TO_ADDR
// hc_gallery =  ;
97603: LD_ADDR_OWVAR 33
97607: PUSH
97608: LD_STRING 
97610: ST_TO_ADDR
// animal := CreateHuman ;
97611: LD_ADDR_VAR 0 12
97615: PUSH
97616: CALL_OW 44
97620: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97621: LD_VAR 0 12
97625: PPUSH
97626: LD_VAR 0 8
97630: PPUSH
97631: LD_INT 0
97633: PPUSH
97634: CALL 104245 0 3
// end ;
97638: GO 97592
97640: POP
97641: POP
// if tigers then
97642: LD_VAR 0 2
97646: IFFALSE 97730
// for i = 1 to tigers do
97648: LD_ADDR_VAR 0 11
97652: PUSH
97653: DOUBLE
97654: LD_INT 1
97656: DEC
97657: ST_TO_ADDR
97658: LD_VAR 0 2
97662: PUSH
97663: FOR_TO
97664: IFFALSE 97728
// begin hc_class = class_tiger ;
97666: LD_ADDR_OWVAR 28
97670: PUSH
97671: LD_INT 14
97673: ST_TO_ADDR
// hc_gallery =  ;
97674: LD_ADDR_OWVAR 33
97678: PUSH
97679: LD_STRING 
97681: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97682: LD_ADDR_OWVAR 35
97686: PUSH
97687: LD_INT 7
97689: NEG
97690: PPUSH
97691: LD_INT 7
97693: PPUSH
97694: CALL_OW 12
97698: ST_TO_ADDR
// animal := CreateHuman ;
97699: LD_ADDR_VAR 0 12
97703: PUSH
97704: CALL_OW 44
97708: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97709: LD_VAR 0 12
97713: PPUSH
97714: LD_VAR 0 8
97718: PPUSH
97719: LD_INT 0
97721: PPUSH
97722: CALL 104245 0 3
// end ;
97726: GO 97663
97728: POP
97729: POP
// if apemans then
97730: LD_VAR 0 3
97734: IFFALSE 97857
// for i = 1 to apemans do
97736: LD_ADDR_VAR 0 11
97740: PUSH
97741: DOUBLE
97742: LD_INT 1
97744: DEC
97745: ST_TO_ADDR
97746: LD_VAR 0 3
97750: PUSH
97751: FOR_TO
97752: IFFALSE 97855
// begin hc_class = class_apeman ;
97754: LD_ADDR_OWVAR 28
97758: PUSH
97759: LD_INT 12
97761: ST_TO_ADDR
// hc_gallery =  ;
97762: LD_ADDR_OWVAR 33
97766: PUSH
97767: LD_STRING 
97769: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97770: LD_ADDR_OWVAR 35
97774: PUSH
97775: LD_INT 5
97777: NEG
97778: PPUSH
97779: LD_INT 5
97781: PPUSH
97782: CALL_OW 12
97786: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97787: LD_ADDR_OWVAR 31
97791: PUSH
97792: LD_INT 1
97794: PPUSH
97795: LD_INT 3
97797: PPUSH
97798: CALL_OW 12
97802: PUSH
97803: LD_INT 1
97805: PPUSH
97806: LD_INT 3
97808: PPUSH
97809: CALL_OW 12
97813: PUSH
97814: LD_INT 0
97816: PUSH
97817: LD_INT 0
97819: PUSH
97820: EMPTY
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: ST_TO_ADDR
// animal := CreateHuman ;
97826: LD_ADDR_VAR 0 12
97830: PUSH
97831: CALL_OW 44
97835: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97836: LD_VAR 0 12
97840: PPUSH
97841: LD_VAR 0 8
97845: PPUSH
97846: LD_INT 0
97848: PPUSH
97849: CALL 104245 0 3
// end ;
97853: GO 97751
97855: POP
97856: POP
// if enchidnas then
97857: LD_VAR 0 4
97861: IFFALSE 97928
// for i = 1 to enchidnas do
97863: LD_ADDR_VAR 0 11
97867: PUSH
97868: DOUBLE
97869: LD_INT 1
97871: DEC
97872: ST_TO_ADDR
97873: LD_VAR 0 4
97877: PUSH
97878: FOR_TO
97879: IFFALSE 97926
// begin hc_class = 13 ;
97881: LD_ADDR_OWVAR 28
97885: PUSH
97886: LD_INT 13
97888: ST_TO_ADDR
// hc_gallery =  ;
97889: LD_ADDR_OWVAR 33
97893: PUSH
97894: LD_STRING 
97896: ST_TO_ADDR
// animal := CreateHuman ;
97897: LD_ADDR_VAR 0 12
97901: PUSH
97902: CALL_OW 44
97906: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97907: LD_VAR 0 12
97911: PPUSH
97912: LD_VAR 0 8
97916: PPUSH
97917: LD_INT 0
97919: PPUSH
97920: CALL 104245 0 3
// end ;
97924: GO 97878
97926: POP
97927: POP
// if fishes then
97928: LD_VAR 0 7
97932: IFFALSE 97999
// for i = 1 to fishes do
97934: LD_ADDR_VAR 0 11
97938: PUSH
97939: DOUBLE
97940: LD_INT 1
97942: DEC
97943: ST_TO_ADDR
97944: LD_VAR 0 7
97948: PUSH
97949: FOR_TO
97950: IFFALSE 97997
// begin hc_class = 20 ;
97952: LD_ADDR_OWVAR 28
97956: PUSH
97957: LD_INT 20
97959: ST_TO_ADDR
// hc_gallery =  ;
97960: LD_ADDR_OWVAR 33
97964: PUSH
97965: LD_STRING 
97967: ST_TO_ADDR
// animal := CreateHuman ;
97968: LD_ADDR_VAR 0 12
97972: PUSH
97973: CALL_OW 44
97977: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97978: LD_VAR 0 12
97982: PPUSH
97983: LD_VAR 0 9
97987: PPUSH
97988: LD_INT 0
97990: PPUSH
97991: CALL 104245 0 3
// end ;
97995: GO 97949
97997: POP
97998: POP
// end ;
97999: LD_VAR 0 10
98003: RET
// export function WantHeal ( sci , unit ) ; begin
98004: LD_INT 0
98006: PPUSH
// if GetTaskList ( sci ) > 0 then
98007: LD_VAR 0 1
98011: PPUSH
98012: CALL_OW 437
98016: PUSH
98017: LD_INT 0
98019: GREATER
98020: IFFALSE 98090
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98022: LD_VAR 0 1
98026: PPUSH
98027: CALL_OW 437
98031: PUSH
98032: LD_INT 1
98034: ARRAY
98035: PUSH
98036: LD_INT 1
98038: ARRAY
98039: PUSH
98040: LD_STRING l
98042: EQUAL
98043: PUSH
98044: LD_VAR 0 1
98048: PPUSH
98049: CALL_OW 437
98053: PUSH
98054: LD_INT 1
98056: ARRAY
98057: PUSH
98058: LD_INT 4
98060: ARRAY
98061: PUSH
98062: LD_VAR 0 2
98066: EQUAL
98067: AND
98068: IFFALSE 98080
// result := true else
98070: LD_ADDR_VAR 0 3
98074: PUSH
98075: LD_INT 1
98077: ST_TO_ADDR
98078: GO 98088
// result := false ;
98080: LD_ADDR_VAR 0 3
98084: PUSH
98085: LD_INT 0
98087: ST_TO_ADDR
// end else
98088: GO 98098
// result := false ;
98090: LD_ADDR_VAR 0 3
98094: PUSH
98095: LD_INT 0
98097: ST_TO_ADDR
// end ;
98098: LD_VAR 0 3
98102: RET
// export function HealTarget ( sci ) ; begin
98103: LD_INT 0
98105: PPUSH
// if not sci then
98106: LD_VAR 0 1
98110: NOT
98111: IFFALSE 98115
// exit ;
98113: GO 98180
// result := 0 ;
98115: LD_ADDR_VAR 0 2
98119: PUSH
98120: LD_INT 0
98122: ST_TO_ADDR
// if GetTaskList ( sci ) then
98123: LD_VAR 0 1
98127: PPUSH
98128: CALL_OW 437
98132: IFFALSE 98180
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98134: LD_VAR 0 1
98138: PPUSH
98139: CALL_OW 437
98143: PUSH
98144: LD_INT 1
98146: ARRAY
98147: PUSH
98148: LD_INT 1
98150: ARRAY
98151: PUSH
98152: LD_STRING l
98154: EQUAL
98155: IFFALSE 98180
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98157: LD_ADDR_VAR 0 2
98161: PUSH
98162: LD_VAR 0 1
98166: PPUSH
98167: CALL_OW 437
98171: PUSH
98172: LD_INT 1
98174: ARRAY
98175: PUSH
98176: LD_INT 4
98178: ARRAY
98179: ST_TO_ADDR
// end ;
98180: LD_VAR 0 2
98184: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98185: LD_INT 0
98187: PPUSH
98188: PPUSH
98189: PPUSH
98190: PPUSH
98191: PPUSH
98192: PPUSH
98193: PPUSH
98194: PPUSH
98195: PPUSH
98196: PPUSH
98197: PPUSH
98198: PPUSH
98199: PPUSH
98200: PPUSH
98201: PPUSH
98202: PPUSH
98203: PPUSH
98204: PPUSH
98205: PPUSH
98206: PPUSH
98207: PPUSH
98208: PPUSH
98209: PPUSH
98210: PPUSH
98211: PPUSH
98212: PPUSH
98213: PPUSH
98214: PPUSH
98215: PPUSH
98216: PPUSH
98217: PPUSH
98218: PPUSH
98219: PPUSH
98220: PPUSH
// if not list then
98221: LD_VAR 0 1
98225: NOT
98226: IFFALSE 98230
// exit ;
98228: GO 102856
// base := list [ 1 ] ;
98230: LD_ADDR_VAR 0 3
98234: PUSH
98235: LD_VAR 0 1
98239: PUSH
98240: LD_INT 1
98242: ARRAY
98243: ST_TO_ADDR
// group := list [ 2 ] ;
98244: LD_ADDR_VAR 0 4
98248: PUSH
98249: LD_VAR 0 1
98253: PUSH
98254: LD_INT 2
98256: ARRAY
98257: ST_TO_ADDR
// path := list [ 3 ] ;
98258: LD_ADDR_VAR 0 5
98262: PUSH
98263: LD_VAR 0 1
98267: PUSH
98268: LD_INT 3
98270: ARRAY
98271: ST_TO_ADDR
// flags := list [ 4 ] ;
98272: LD_ADDR_VAR 0 6
98276: PUSH
98277: LD_VAR 0 1
98281: PUSH
98282: LD_INT 4
98284: ARRAY
98285: ST_TO_ADDR
// mined := [ ] ;
98286: LD_ADDR_VAR 0 27
98290: PUSH
98291: EMPTY
98292: ST_TO_ADDR
// bombed := [ ] ;
98293: LD_ADDR_VAR 0 28
98297: PUSH
98298: EMPTY
98299: ST_TO_ADDR
// healers := [ ] ;
98300: LD_ADDR_VAR 0 31
98304: PUSH
98305: EMPTY
98306: ST_TO_ADDR
// to_heal := [ ] ;
98307: LD_ADDR_VAR 0 30
98311: PUSH
98312: EMPTY
98313: ST_TO_ADDR
// repairs := [ ] ;
98314: LD_ADDR_VAR 0 33
98318: PUSH
98319: EMPTY
98320: ST_TO_ADDR
// to_repair := [ ] ;
98321: LD_ADDR_VAR 0 32
98325: PUSH
98326: EMPTY
98327: ST_TO_ADDR
// if not group or not path then
98328: LD_VAR 0 4
98332: NOT
98333: PUSH
98334: LD_VAR 0 5
98338: NOT
98339: OR
98340: IFFALSE 98344
// exit ;
98342: GO 102856
// side := GetSide ( group [ 1 ] ) ;
98344: LD_ADDR_VAR 0 35
98348: PUSH
98349: LD_VAR 0 4
98353: PUSH
98354: LD_INT 1
98356: ARRAY
98357: PPUSH
98358: CALL_OW 255
98362: ST_TO_ADDR
// if flags then
98363: LD_VAR 0 6
98367: IFFALSE 98511
// begin f_ignore_area := flags [ 1 ] ;
98369: LD_ADDR_VAR 0 17
98373: PUSH
98374: LD_VAR 0 6
98378: PUSH
98379: LD_INT 1
98381: ARRAY
98382: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98383: LD_ADDR_VAR 0 18
98387: PUSH
98388: LD_VAR 0 6
98392: PUSH
98393: LD_INT 2
98395: ARRAY
98396: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98397: LD_ADDR_VAR 0 19
98401: PUSH
98402: LD_VAR 0 6
98406: PUSH
98407: LD_INT 3
98409: ARRAY
98410: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98411: LD_ADDR_VAR 0 20
98415: PUSH
98416: LD_VAR 0 6
98420: PUSH
98421: LD_INT 4
98423: ARRAY
98424: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98425: LD_ADDR_VAR 0 21
98429: PUSH
98430: LD_VAR 0 6
98434: PUSH
98435: LD_INT 5
98437: ARRAY
98438: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98439: LD_ADDR_VAR 0 22
98443: PUSH
98444: LD_VAR 0 6
98448: PUSH
98449: LD_INT 6
98451: ARRAY
98452: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98453: LD_ADDR_VAR 0 23
98457: PUSH
98458: LD_VAR 0 6
98462: PUSH
98463: LD_INT 7
98465: ARRAY
98466: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98467: LD_ADDR_VAR 0 24
98471: PUSH
98472: LD_VAR 0 6
98476: PUSH
98477: LD_INT 8
98479: ARRAY
98480: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98481: LD_ADDR_VAR 0 25
98485: PUSH
98486: LD_VAR 0 6
98490: PUSH
98491: LD_INT 9
98493: ARRAY
98494: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98495: LD_ADDR_VAR 0 26
98499: PUSH
98500: LD_VAR 0 6
98504: PUSH
98505: LD_INT 10
98507: ARRAY
98508: ST_TO_ADDR
// end else
98509: GO 98591
// begin f_ignore_area := false ;
98511: LD_ADDR_VAR 0 17
98515: PUSH
98516: LD_INT 0
98518: ST_TO_ADDR
// f_capture := false ;
98519: LD_ADDR_VAR 0 18
98523: PUSH
98524: LD_INT 0
98526: ST_TO_ADDR
// f_ignore_civ := false ;
98527: LD_ADDR_VAR 0 19
98531: PUSH
98532: LD_INT 0
98534: ST_TO_ADDR
// f_murder := false ;
98535: LD_ADDR_VAR 0 20
98539: PUSH
98540: LD_INT 0
98542: ST_TO_ADDR
// f_mines := false ;
98543: LD_ADDR_VAR 0 21
98547: PUSH
98548: LD_INT 0
98550: ST_TO_ADDR
// f_repair := false ;
98551: LD_ADDR_VAR 0 22
98555: PUSH
98556: LD_INT 0
98558: ST_TO_ADDR
// f_heal := false ;
98559: LD_ADDR_VAR 0 23
98563: PUSH
98564: LD_INT 0
98566: ST_TO_ADDR
// f_spacetime := false ;
98567: LD_ADDR_VAR 0 24
98571: PUSH
98572: LD_INT 0
98574: ST_TO_ADDR
// f_attack_depot := false ;
98575: LD_ADDR_VAR 0 25
98579: PUSH
98580: LD_INT 0
98582: ST_TO_ADDR
// f_crawl := false ;
98583: LD_ADDR_VAR 0 26
98587: PUSH
98588: LD_INT 0
98590: ST_TO_ADDR
// end ; if f_heal then
98591: LD_VAR 0 23
98595: IFFALSE 98622
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98597: LD_ADDR_VAR 0 31
98601: PUSH
98602: LD_VAR 0 4
98606: PPUSH
98607: LD_INT 25
98609: PUSH
98610: LD_INT 4
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PPUSH
98617: CALL_OW 72
98621: ST_TO_ADDR
// if f_repair then
98622: LD_VAR 0 22
98626: IFFALSE 98653
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98628: LD_ADDR_VAR 0 33
98632: PUSH
98633: LD_VAR 0 4
98637: PPUSH
98638: LD_INT 25
98640: PUSH
98641: LD_INT 3
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PPUSH
98648: CALL_OW 72
98652: ST_TO_ADDR
// units_path := [ ] ;
98653: LD_ADDR_VAR 0 16
98657: PUSH
98658: EMPTY
98659: ST_TO_ADDR
// for i = 1 to group do
98660: LD_ADDR_VAR 0 7
98664: PUSH
98665: DOUBLE
98666: LD_INT 1
98668: DEC
98669: ST_TO_ADDR
98670: LD_VAR 0 4
98674: PUSH
98675: FOR_TO
98676: IFFALSE 98705
// units_path := Replace ( units_path , i , path ) ;
98678: LD_ADDR_VAR 0 16
98682: PUSH
98683: LD_VAR 0 16
98687: PPUSH
98688: LD_VAR 0 7
98692: PPUSH
98693: LD_VAR 0 5
98697: PPUSH
98698: CALL_OW 1
98702: ST_TO_ADDR
98703: GO 98675
98705: POP
98706: POP
// repeat for i = group downto 1 do
98707: LD_ADDR_VAR 0 7
98711: PUSH
98712: DOUBLE
98713: LD_VAR 0 4
98717: INC
98718: ST_TO_ADDR
98719: LD_INT 1
98721: PUSH
98722: FOR_DOWNTO
98723: IFFALSE 102819
// begin wait ( 5 ) ;
98725: LD_INT 5
98727: PPUSH
98728: CALL_OW 67
// tmp := [ ] ;
98732: LD_ADDR_VAR 0 14
98736: PUSH
98737: EMPTY
98738: ST_TO_ADDR
// attacking := false ;
98739: LD_ADDR_VAR 0 29
98743: PUSH
98744: LD_INT 0
98746: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98747: LD_VAR 0 4
98751: PUSH
98752: LD_VAR 0 7
98756: ARRAY
98757: PPUSH
98758: CALL_OW 301
98762: PUSH
98763: LD_VAR 0 4
98767: PUSH
98768: LD_VAR 0 7
98772: ARRAY
98773: NOT
98774: OR
98775: IFFALSE 98884
// begin if GetType ( group [ i ] ) = unit_human then
98777: LD_VAR 0 4
98781: PUSH
98782: LD_VAR 0 7
98786: ARRAY
98787: PPUSH
98788: CALL_OW 247
98792: PUSH
98793: LD_INT 1
98795: EQUAL
98796: IFFALSE 98842
// begin to_heal := to_heal diff group [ i ] ;
98798: LD_ADDR_VAR 0 30
98802: PUSH
98803: LD_VAR 0 30
98807: PUSH
98808: LD_VAR 0 4
98812: PUSH
98813: LD_VAR 0 7
98817: ARRAY
98818: DIFF
98819: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98820: LD_ADDR_VAR 0 31
98824: PUSH
98825: LD_VAR 0 31
98829: PUSH
98830: LD_VAR 0 4
98834: PUSH
98835: LD_VAR 0 7
98839: ARRAY
98840: DIFF
98841: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98842: LD_ADDR_VAR 0 4
98846: PUSH
98847: LD_VAR 0 4
98851: PPUSH
98852: LD_VAR 0 7
98856: PPUSH
98857: CALL_OW 3
98861: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98862: LD_ADDR_VAR 0 16
98866: PUSH
98867: LD_VAR 0 16
98871: PPUSH
98872: LD_VAR 0 7
98876: PPUSH
98877: CALL_OW 3
98881: ST_TO_ADDR
// continue ;
98882: GO 98722
// end ; if f_repair then
98884: LD_VAR 0 22
98888: IFFALSE 99377
// begin if GetType ( group [ i ] ) = unit_vehicle then
98890: LD_VAR 0 4
98894: PUSH
98895: LD_VAR 0 7
98899: ARRAY
98900: PPUSH
98901: CALL_OW 247
98905: PUSH
98906: LD_INT 2
98908: EQUAL
98909: IFFALSE 99099
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98911: LD_VAR 0 4
98915: PUSH
98916: LD_VAR 0 7
98920: ARRAY
98921: PPUSH
98922: CALL_OW 256
98926: PUSH
98927: LD_INT 700
98929: LESS
98930: PUSH
98931: LD_VAR 0 4
98935: PUSH
98936: LD_VAR 0 7
98940: ARRAY
98941: PUSH
98942: LD_VAR 0 32
98946: IN
98947: NOT
98948: AND
98949: IFFALSE 98973
// to_repair := to_repair union group [ i ] ;
98951: LD_ADDR_VAR 0 32
98955: PUSH
98956: LD_VAR 0 32
98960: PUSH
98961: LD_VAR 0 4
98965: PUSH
98966: LD_VAR 0 7
98970: ARRAY
98971: UNION
98972: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98973: LD_VAR 0 4
98977: PUSH
98978: LD_VAR 0 7
98982: ARRAY
98983: PPUSH
98984: CALL_OW 256
98988: PUSH
98989: LD_INT 1000
98991: EQUAL
98992: PUSH
98993: LD_VAR 0 4
98997: PUSH
98998: LD_VAR 0 7
99002: ARRAY
99003: PUSH
99004: LD_VAR 0 32
99008: IN
99009: AND
99010: IFFALSE 99034
// to_repair := to_repair diff group [ i ] ;
99012: LD_ADDR_VAR 0 32
99016: PUSH
99017: LD_VAR 0 32
99021: PUSH
99022: LD_VAR 0 4
99026: PUSH
99027: LD_VAR 0 7
99031: ARRAY
99032: DIFF
99033: ST_TO_ADDR
// if group [ i ] in to_repair then
99034: LD_VAR 0 4
99038: PUSH
99039: LD_VAR 0 7
99043: ARRAY
99044: PUSH
99045: LD_VAR 0 32
99049: IN
99050: IFFALSE 99097
// begin if not IsInArea ( group [ i ] , f_repair ) then
99052: LD_VAR 0 4
99056: PUSH
99057: LD_VAR 0 7
99061: ARRAY
99062: PPUSH
99063: LD_VAR 0 22
99067: PPUSH
99068: CALL_OW 308
99072: NOT
99073: IFFALSE 99095
// ComMoveToArea ( group [ i ] , f_repair ) ;
99075: LD_VAR 0 4
99079: PUSH
99080: LD_VAR 0 7
99084: ARRAY
99085: PPUSH
99086: LD_VAR 0 22
99090: PPUSH
99091: CALL_OW 113
// continue ;
99095: GO 98722
// end ; end else
99097: GO 99377
// if group [ i ] in repairs then
99099: LD_VAR 0 4
99103: PUSH
99104: LD_VAR 0 7
99108: ARRAY
99109: PUSH
99110: LD_VAR 0 33
99114: IN
99115: IFFALSE 99377
// begin if IsInUnit ( group [ i ] ) then
99117: LD_VAR 0 4
99121: PUSH
99122: LD_VAR 0 7
99126: ARRAY
99127: PPUSH
99128: CALL_OW 310
99132: IFFALSE 99200
// begin z := IsInUnit ( group [ i ] ) ;
99134: LD_ADDR_VAR 0 13
99138: PUSH
99139: LD_VAR 0 4
99143: PUSH
99144: LD_VAR 0 7
99148: ARRAY
99149: PPUSH
99150: CALL_OW 310
99154: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99155: LD_VAR 0 13
99159: PUSH
99160: LD_VAR 0 32
99164: IN
99165: PUSH
99166: LD_VAR 0 13
99170: PPUSH
99171: LD_VAR 0 22
99175: PPUSH
99176: CALL_OW 308
99180: AND
99181: IFFALSE 99198
// ComExitVehicle ( group [ i ] ) ;
99183: LD_VAR 0 4
99187: PUSH
99188: LD_VAR 0 7
99192: ARRAY
99193: PPUSH
99194: CALL_OW 121
// end else
99198: GO 99377
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99200: LD_ADDR_VAR 0 13
99204: PUSH
99205: LD_VAR 0 4
99209: PPUSH
99210: LD_INT 95
99212: PUSH
99213: LD_VAR 0 22
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 58
99224: PUSH
99225: EMPTY
99226: LIST
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: PPUSH
99232: CALL_OW 72
99236: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99237: LD_VAR 0 4
99241: PUSH
99242: LD_VAR 0 7
99246: ARRAY
99247: PPUSH
99248: CALL_OW 314
99252: NOT
99253: IFFALSE 99375
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99255: LD_ADDR_VAR 0 10
99259: PUSH
99260: LD_VAR 0 13
99264: PPUSH
99265: LD_VAR 0 4
99269: PUSH
99270: LD_VAR 0 7
99274: ARRAY
99275: PPUSH
99276: CALL_OW 74
99280: ST_TO_ADDR
// if not x then
99281: LD_VAR 0 10
99285: NOT
99286: IFFALSE 99290
// continue ;
99288: GO 98722
// if GetLives ( x ) < 1000 then
99290: LD_VAR 0 10
99294: PPUSH
99295: CALL_OW 256
99299: PUSH
99300: LD_INT 1000
99302: LESS
99303: IFFALSE 99327
// ComRepairVehicle ( group [ i ] , x ) else
99305: LD_VAR 0 4
99309: PUSH
99310: LD_VAR 0 7
99314: ARRAY
99315: PPUSH
99316: LD_VAR 0 10
99320: PPUSH
99321: CALL_OW 129
99325: GO 99375
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99327: LD_VAR 0 23
99331: PUSH
99332: LD_VAR 0 4
99336: PUSH
99337: LD_VAR 0 7
99341: ARRAY
99342: PPUSH
99343: CALL_OW 256
99347: PUSH
99348: LD_INT 1000
99350: LESS
99351: AND
99352: NOT
99353: IFFALSE 99375
// ComEnterUnit ( group [ i ] , x ) ;
99355: LD_VAR 0 4
99359: PUSH
99360: LD_VAR 0 7
99364: ARRAY
99365: PPUSH
99366: LD_VAR 0 10
99370: PPUSH
99371: CALL_OW 120
// end ; continue ;
99375: GO 98722
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99377: LD_VAR 0 23
99381: PUSH
99382: LD_VAR 0 4
99386: PUSH
99387: LD_VAR 0 7
99391: ARRAY
99392: PPUSH
99393: CALL_OW 247
99397: PUSH
99398: LD_INT 1
99400: EQUAL
99401: AND
99402: IFFALSE 99880
// begin if group [ i ] in healers then
99404: LD_VAR 0 4
99408: PUSH
99409: LD_VAR 0 7
99413: ARRAY
99414: PUSH
99415: LD_VAR 0 31
99419: IN
99420: IFFALSE 99693
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99422: LD_VAR 0 4
99426: PUSH
99427: LD_VAR 0 7
99431: ARRAY
99432: PPUSH
99433: LD_VAR 0 23
99437: PPUSH
99438: CALL_OW 308
99442: NOT
99443: PUSH
99444: LD_VAR 0 4
99448: PUSH
99449: LD_VAR 0 7
99453: ARRAY
99454: PPUSH
99455: CALL_OW 314
99459: NOT
99460: AND
99461: IFFALSE 99485
// ComMoveToArea ( group [ i ] , f_heal ) else
99463: LD_VAR 0 4
99467: PUSH
99468: LD_VAR 0 7
99472: ARRAY
99473: PPUSH
99474: LD_VAR 0 23
99478: PPUSH
99479: CALL_OW 113
99483: GO 99691
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99485: LD_VAR 0 4
99489: PUSH
99490: LD_VAR 0 7
99494: ARRAY
99495: PPUSH
99496: CALL 98103 0 1
99500: PPUSH
99501: CALL_OW 256
99505: PUSH
99506: LD_INT 1000
99508: EQUAL
99509: IFFALSE 99528
// ComStop ( group [ i ] ) else
99511: LD_VAR 0 4
99515: PUSH
99516: LD_VAR 0 7
99520: ARRAY
99521: PPUSH
99522: CALL_OW 141
99526: GO 99691
// if not HasTask ( group [ i ] ) and to_heal then
99528: LD_VAR 0 4
99532: PUSH
99533: LD_VAR 0 7
99537: ARRAY
99538: PPUSH
99539: CALL_OW 314
99543: NOT
99544: PUSH
99545: LD_VAR 0 30
99549: AND
99550: IFFALSE 99691
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99552: LD_ADDR_VAR 0 13
99556: PUSH
99557: LD_VAR 0 30
99561: PPUSH
99562: LD_INT 3
99564: PUSH
99565: LD_INT 54
99567: PUSH
99568: EMPTY
99569: LIST
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: PPUSH
99575: CALL_OW 72
99579: PPUSH
99580: LD_VAR 0 4
99584: PUSH
99585: LD_VAR 0 7
99589: ARRAY
99590: PPUSH
99591: CALL_OW 74
99595: ST_TO_ADDR
// if z then
99596: LD_VAR 0 13
99600: IFFALSE 99691
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99602: LD_INT 91
99604: PUSH
99605: LD_VAR 0 13
99609: PUSH
99610: LD_INT 10
99612: PUSH
99613: EMPTY
99614: LIST
99615: LIST
99616: LIST
99617: PUSH
99618: LD_INT 81
99620: PUSH
99621: LD_VAR 0 13
99625: PPUSH
99626: CALL_OW 255
99630: PUSH
99631: EMPTY
99632: LIST
99633: LIST
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: PPUSH
99639: CALL_OW 69
99643: PUSH
99644: LD_INT 0
99646: EQUAL
99647: IFFALSE 99671
// ComHeal ( group [ i ] , z ) else
99649: LD_VAR 0 4
99653: PUSH
99654: LD_VAR 0 7
99658: ARRAY
99659: PPUSH
99660: LD_VAR 0 13
99664: PPUSH
99665: CALL_OW 128
99669: GO 99691
// ComMoveToArea ( group [ i ] , f_heal ) ;
99671: LD_VAR 0 4
99675: PUSH
99676: LD_VAR 0 7
99680: ARRAY
99681: PPUSH
99682: LD_VAR 0 23
99686: PPUSH
99687: CALL_OW 113
// end ; continue ;
99691: GO 98722
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99693: LD_VAR 0 4
99697: PUSH
99698: LD_VAR 0 7
99702: ARRAY
99703: PPUSH
99704: CALL_OW 256
99708: PUSH
99709: LD_INT 700
99711: LESS
99712: PUSH
99713: LD_VAR 0 4
99717: PUSH
99718: LD_VAR 0 7
99722: ARRAY
99723: PUSH
99724: LD_VAR 0 30
99728: IN
99729: NOT
99730: AND
99731: IFFALSE 99755
// to_heal := to_heal union group [ i ] ;
99733: LD_ADDR_VAR 0 30
99737: PUSH
99738: LD_VAR 0 30
99742: PUSH
99743: LD_VAR 0 4
99747: PUSH
99748: LD_VAR 0 7
99752: ARRAY
99753: UNION
99754: ST_TO_ADDR
// if group [ i ] in to_heal then
99755: LD_VAR 0 4
99759: PUSH
99760: LD_VAR 0 7
99764: ARRAY
99765: PUSH
99766: LD_VAR 0 30
99770: IN
99771: IFFALSE 99880
// begin if GetLives ( group [ i ] ) = 1000 then
99773: LD_VAR 0 4
99777: PUSH
99778: LD_VAR 0 7
99782: ARRAY
99783: PPUSH
99784: CALL_OW 256
99788: PUSH
99789: LD_INT 1000
99791: EQUAL
99792: IFFALSE 99818
// to_heal := to_heal diff group [ i ] else
99794: LD_ADDR_VAR 0 30
99798: PUSH
99799: LD_VAR 0 30
99803: PUSH
99804: LD_VAR 0 4
99808: PUSH
99809: LD_VAR 0 7
99813: ARRAY
99814: DIFF
99815: ST_TO_ADDR
99816: GO 99880
// begin if not IsInArea ( group [ i ] , to_heal ) then
99818: LD_VAR 0 4
99822: PUSH
99823: LD_VAR 0 7
99827: ARRAY
99828: PPUSH
99829: LD_VAR 0 30
99833: PPUSH
99834: CALL_OW 308
99838: NOT
99839: IFFALSE 99863
// ComMoveToArea ( group [ i ] , f_heal ) else
99841: LD_VAR 0 4
99845: PUSH
99846: LD_VAR 0 7
99850: ARRAY
99851: PPUSH
99852: LD_VAR 0 23
99856: PPUSH
99857: CALL_OW 113
99861: GO 99878
// ComHold ( group [ i ] ) ;
99863: LD_VAR 0 4
99867: PUSH
99868: LD_VAR 0 7
99872: ARRAY
99873: PPUSH
99874: CALL_OW 140
// continue ;
99878: GO 98722
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99880: LD_VAR 0 4
99884: PUSH
99885: LD_VAR 0 7
99889: ARRAY
99890: PPUSH
99891: LD_INT 10
99893: PPUSH
99894: CALL 96500 0 2
99898: NOT
99899: PUSH
99900: LD_VAR 0 16
99904: PUSH
99905: LD_VAR 0 7
99909: ARRAY
99910: PUSH
99911: EMPTY
99912: EQUAL
99913: NOT
99914: AND
99915: IFFALSE 100181
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99917: LD_VAR 0 4
99921: PUSH
99922: LD_VAR 0 7
99926: ARRAY
99927: PPUSH
99928: CALL_OW 262
99932: PUSH
99933: LD_INT 1
99935: PUSH
99936: LD_INT 2
99938: PUSH
99939: EMPTY
99940: LIST
99941: LIST
99942: IN
99943: IFFALSE 99984
// if GetFuel ( group [ i ] ) < 10 then
99945: LD_VAR 0 4
99949: PUSH
99950: LD_VAR 0 7
99954: ARRAY
99955: PPUSH
99956: CALL_OW 261
99960: PUSH
99961: LD_INT 10
99963: LESS
99964: IFFALSE 99984
// SetFuel ( group [ i ] , 12 ) ;
99966: LD_VAR 0 4
99970: PUSH
99971: LD_VAR 0 7
99975: ARRAY
99976: PPUSH
99977: LD_INT 12
99979: PPUSH
99980: CALL_OW 240
// if units_path [ i ] then
99984: LD_VAR 0 16
99988: PUSH
99989: LD_VAR 0 7
99993: ARRAY
99994: IFFALSE 100179
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99996: LD_VAR 0 4
100000: PUSH
100001: LD_VAR 0 7
100005: ARRAY
100006: PPUSH
100007: LD_VAR 0 16
100011: PUSH
100012: LD_VAR 0 7
100016: ARRAY
100017: PUSH
100018: LD_INT 1
100020: ARRAY
100021: PUSH
100022: LD_INT 1
100024: ARRAY
100025: PPUSH
100026: LD_VAR 0 16
100030: PUSH
100031: LD_VAR 0 7
100035: ARRAY
100036: PUSH
100037: LD_INT 1
100039: ARRAY
100040: PUSH
100041: LD_INT 2
100043: ARRAY
100044: PPUSH
100045: CALL_OW 297
100049: PUSH
100050: LD_INT 6
100052: GREATER
100053: IFFALSE 100128
// begin if not HasTask ( group [ i ] ) then
100055: LD_VAR 0 4
100059: PUSH
100060: LD_VAR 0 7
100064: ARRAY
100065: PPUSH
100066: CALL_OW 314
100070: NOT
100071: IFFALSE 100126
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100073: LD_VAR 0 4
100077: PUSH
100078: LD_VAR 0 7
100082: ARRAY
100083: PPUSH
100084: LD_VAR 0 16
100088: PUSH
100089: LD_VAR 0 7
100093: ARRAY
100094: PUSH
100095: LD_INT 1
100097: ARRAY
100098: PUSH
100099: LD_INT 1
100101: ARRAY
100102: PPUSH
100103: LD_VAR 0 16
100107: PUSH
100108: LD_VAR 0 7
100112: ARRAY
100113: PUSH
100114: LD_INT 1
100116: ARRAY
100117: PUSH
100118: LD_INT 2
100120: ARRAY
100121: PPUSH
100122: CALL_OW 114
// end else
100126: GO 100179
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100128: LD_ADDR_VAR 0 15
100132: PUSH
100133: LD_VAR 0 16
100137: PUSH
100138: LD_VAR 0 7
100142: ARRAY
100143: PPUSH
100144: LD_INT 1
100146: PPUSH
100147: CALL_OW 3
100151: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100152: LD_ADDR_VAR 0 16
100156: PUSH
100157: LD_VAR 0 16
100161: PPUSH
100162: LD_VAR 0 7
100166: PPUSH
100167: LD_VAR 0 15
100171: PPUSH
100172: CALL_OW 1
100176: ST_TO_ADDR
// continue ;
100177: GO 98722
// end ; end ; end else
100179: GO 102817
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100181: LD_ADDR_VAR 0 14
100185: PUSH
100186: LD_INT 81
100188: PUSH
100189: LD_VAR 0 4
100193: PUSH
100194: LD_VAR 0 7
100198: ARRAY
100199: PPUSH
100200: CALL_OW 255
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: PPUSH
100209: CALL_OW 69
100213: ST_TO_ADDR
// if not tmp then
100214: LD_VAR 0 14
100218: NOT
100219: IFFALSE 100223
// continue ;
100221: GO 98722
// if f_ignore_area then
100223: LD_VAR 0 17
100227: IFFALSE 100315
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100229: LD_ADDR_VAR 0 15
100233: PUSH
100234: LD_VAR 0 14
100238: PPUSH
100239: LD_INT 3
100241: PUSH
100242: LD_INT 92
100244: PUSH
100245: LD_VAR 0 17
100249: PUSH
100250: LD_INT 1
100252: ARRAY
100253: PUSH
100254: LD_VAR 0 17
100258: PUSH
100259: LD_INT 2
100261: ARRAY
100262: PUSH
100263: LD_VAR 0 17
100267: PUSH
100268: LD_INT 3
100270: ARRAY
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: PPUSH
100282: CALL_OW 72
100286: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100287: LD_VAR 0 14
100291: PUSH
100292: LD_VAR 0 15
100296: DIFF
100297: IFFALSE 100315
// tmp := tmp diff tmp2 ;
100299: LD_ADDR_VAR 0 14
100303: PUSH
100304: LD_VAR 0 14
100308: PUSH
100309: LD_VAR 0 15
100313: DIFF
100314: ST_TO_ADDR
// end ; if not f_murder then
100315: LD_VAR 0 20
100319: NOT
100320: IFFALSE 100378
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100322: LD_ADDR_VAR 0 15
100326: PUSH
100327: LD_VAR 0 14
100331: PPUSH
100332: LD_INT 3
100334: PUSH
100335: LD_INT 50
100337: PUSH
100338: EMPTY
100339: LIST
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: PPUSH
100345: CALL_OW 72
100349: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100350: LD_VAR 0 14
100354: PUSH
100355: LD_VAR 0 15
100359: DIFF
100360: IFFALSE 100378
// tmp := tmp diff tmp2 ;
100362: LD_ADDR_VAR 0 14
100366: PUSH
100367: LD_VAR 0 14
100371: PUSH
100372: LD_VAR 0 15
100376: DIFF
100377: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100378: LD_ADDR_VAR 0 14
100382: PUSH
100383: LD_VAR 0 4
100387: PUSH
100388: LD_VAR 0 7
100392: ARRAY
100393: PPUSH
100394: LD_VAR 0 14
100398: PPUSH
100399: LD_INT 1
100401: PPUSH
100402: LD_INT 1
100404: PPUSH
100405: CALL 70143 0 4
100409: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100410: LD_VAR 0 4
100414: PUSH
100415: LD_VAR 0 7
100419: ARRAY
100420: PPUSH
100421: CALL_OW 257
100425: PUSH
100426: LD_INT 1
100428: EQUAL
100429: IFFALSE 100877
// begin if WantPlant ( group [ i ] ) then
100431: LD_VAR 0 4
100435: PUSH
100436: LD_VAR 0 7
100440: ARRAY
100441: PPUSH
100442: CALL 69644 0 1
100446: IFFALSE 100450
// continue ;
100448: GO 98722
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100450: LD_VAR 0 18
100454: PUSH
100455: LD_VAR 0 4
100459: PUSH
100460: LD_VAR 0 7
100464: ARRAY
100465: PPUSH
100466: CALL_OW 310
100470: NOT
100471: AND
100472: PUSH
100473: LD_VAR 0 14
100477: PUSH
100478: LD_INT 1
100480: ARRAY
100481: PUSH
100482: LD_VAR 0 14
100486: PPUSH
100487: LD_INT 21
100489: PUSH
100490: LD_INT 2
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: PUSH
100497: LD_INT 58
100499: PUSH
100500: EMPTY
100501: LIST
100502: PUSH
100503: EMPTY
100504: LIST
100505: LIST
100506: PPUSH
100507: CALL_OW 72
100511: IN
100512: AND
100513: IFFALSE 100549
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100515: LD_VAR 0 4
100519: PUSH
100520: LD_VAR 0 7
100524: ARRAY
100525: PPUSH
100526: LD_VAR 0 14
100530: PUSH
100531: LD_INT 1
100533: ARRAY
100534: PPUSH
100535: CALL_OW 120
// attacking := true ;
100539: LD_ADDR_VAR 0 29
100543: PUSH
100544: LD_INT 1
100546: ST_TO_ADDR
// continue ;
100547: GO 98722
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100549: LD_VAR 0 26
100553: PUSH
100554: LD_VAR 0 4
100558: PUSH
100559: LD_VAR 0 7
100563: ARRAY
100564: PPUSH
100565: CALL_OW 257
100569: PUSH
100570: LD_INT 1
100572: EQUAL
100573: AND
100574: PUSH
100575: LD_VAR 0 4
100579: PUSH
100580: LD_VAR 0 7
100584: ARRAY
100585: PPUSH
100586: CALL_OW 256
100590: PUSH
100591: LD_INT 800
100593: LESS
100594: AND
100595: PUSH
100596: LD_VAR 0 4
100600: PUSH
100601: LD_VAR 0 7
100605: ARRAY
100606: PPUSH
100607: CALL_OW 318
100611: NOT
100612: AND
100613: IFFALSE 100630
// ComCrawl ( group [ i ] ) ;
100615: LD_VAR 0 4
100619: PUSH
100620: LD_VAR 0 7
100624: ARRAY
100625: PPUSH
100626: CALL_OW 137
// if f_mines then
100630: LD_VAR 0 21
100634: IFFALSE 100877
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100636: LD_VAR 0 14
100640: PUSH
100641: LD_INT 1
100643: ARRAY
100644: PPUSH
100645: CALL_OW 247
100649: PUSH
100650: LD_INT 3
100652: EQUAL
100653: PUSH
100654: LD_VAR 0 14
100658: PUSH
100659: LD_INT 1
100661: ARRAY
100662: PUSH
100663: LD_VAR 0 27
100667: IN
100668: NOT
100669: AND
100670: IFFALSE 100877
// begin x := GetX ( tmp [ 1 ] ) ;
100672: LD_ADDR_VAR 0 10
100676: PUSH
100677: LD_VAR 0 14
100681: PUSH
100682: LD_INT 1
100684: ARRAY
100685: PPUSH
100686: CALL_OW 250
100690: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100691: LD_ADDR_VAR 0 11
100695: PUSH
100696: LD_VAR 0 14
100700: PUSH
100701: LD_INT 1
100703: ARRAY
100704: PPUSH
100705: CALL_OW 251
100709: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100710: LD_ADDR_VAR 0 12
100714: PUSH
100715: LD_VAR 0 4
100719: PUSH
100720: LD_VAR 0 7
100724: ARRAY
100725: PPUSH
100726: CALL 96585 0 1
100730: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100731: LD_VAR 0 4
100735: PUSH
100736: LD_VAR 0 7
100740: ARRAY
100741: PPUSH
100742: LD_VAR 0 10
100746: PPUSH
100747: LD_VAR 0 11
100751: PPUSH
100752: LD_VAR 0 14
100756: PUSH
100757: LD_INT 1
100759: ARRAY
100760: PPUSH
100761: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100765: LD_VAR 0 4
100769: PUSH
100770: LD_VAR 0 7
100774: ARRAY
100775: PPUSH
100776: LD_VAR 0 10
100780: PPUSH
100781: LD_VAR 0 12
100785: PPUSH
100786: LD_INT 7
100788: PPUSH
100789: CALL_OW 272
100793: PPUSH
100794: LD_VAR 0 11
100798: PPUSH
100799: LD_VAR 0 12
100803: PPUSH
100804: LD_INT 7
100806: PPUSH
100807: CALL_OW 273
100811: PPUSH
100812: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100816: LD_VAR 0 4
100820: PUSH
100821: LD_VAR 0 7
100825: ARRAY
100826: PPUSH
100827: LD_INT 71
100829: PPUSH
100830: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100834: LD_ADDR_VAR 0 27
100838: PUSH
100839: LD_VAR 0 27
100843: PPUSH
100844: LD_VAR 0 27
100848: PUSH
100849: LD_INT 1
100851: PLUS
100852: PPUSH
100853: LD_VAR 0 14
100857: PUSH
100858: LD_INT 1
100860: ARRAY
100861: PPUSH
100862: CALL_OW 1
100866: ST_TO_ADDR
// attacking := true ;
100867: LD_ADDR_VAR 0 29
100871: PUSH
100872: LD_INT 1
100874: ST_TO_ADDR
// continue ;
100875: GO 98722
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100877: LD_VAR 0 4
100881: PUSH
100882: LD_VAR 0 7
100886: ARRAY
100887: PPUSH
100888: CALL_OW 257
100892: PUSH
100893: LD_INT 17
100895: EQUAL
100896: PUSH
100897: LD_VAR 0 4
100901: PUSH
100902: LD_VAR 0 7
100906: ARRAY
100907: PPUSH
100908: CALL_OW 110
100912: PUSH
100913: LD_INT 71
100915: EQUAL
100916: NOT
100917: AND
100918: IFFALSE 101064
// begin attacking := false ;
100920: LD_ADDR_VAR 0 29
100924: PUSH
100925: LD_INT 0
100927: ST_TO_ADDR
// k := 5 ;
100928: LD_ADDR_VAR 0 9
100932: PUSH
100933: LD_INT 5
100935: ST_TO_ADDR
// if tmp < k then
100936: LD_VAR 0 14
100940: PUSH
100941: LD_VAR 0 9
100945: LESS
100946: IFFALSE 100958
// k := tmp ;
100948: LD_ADDR_VAR 0 9
100952: PUSH
100953: LD_VAR 0 14
100957: ST_TO_ADDR
// for j = 1 to k do
100958: LD_ADDR_VAR 0 8
100962: PUSH
100963: DOUBLE
100964: LD_INT 1
100966: DEC
100967: ST_TO_ADDR
100968: LD_VAR 0 9
100972: PUSH
100973: FOR_TO
100974: IFFALSE 101062
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100976: LD_VAR 0 14
100980: PUSH
100981: LD_VAR 0 8
100985: ARRAY
100986: PUSH
100987: LD_VAR 0 14
100991: PPUSH
100992: LD_INT 58
100994: PUSH
100995: EMPTY
100996: LIST
100997: PPUSH
100998: CALL_OW 72
101002: IN
101003: NOT
101004: IFFALSE 101060
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101006: LD_VAR 0 4
101010: PUSH
101011: LD_VAR 0 7
101015: ARRAY
101016: PPUSH
101017: LD_VAR 0 14
101021: PUSH
101022: LD_VAR 0 8
101026: ARRAY
101027: PPUSH
101028: CALL_OW 115
// attacking := true ;
101032: LD_ADDR_VAR 0 29
101036: PUSH
101037: LD_INT 1
101039: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101040: LD_VAR 0 4
101044: PUSH
101045: LD_VAR 0 7
101049: ARRAY
101050: PPUSH
101051: LD_INT 71
101053: PPUSH
101054: CALL_OW 109
// continue ;
101058: GO 100973
// end ; end ;
101060: GO 100973
101062: POP
101063: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101064: LD_VAR 0 4
101068: PUSH
101069: LD_VAR 0 7
101073: ARRAY
101074: PPUSH
101075: CALL_OW 257
101079: PUSH
101080: LD_INT 8
101082: EQUAL
101083: PUSH
101084: LD_VAR 0 4
101088: PUSH
101089: LD_VAR 0 7
101093: ARRAY
101094: PPUSH
101095: CALL_OW 264
101099: PUSH
101100: LD_INT 28
101102: PUSH
101103: LD_INT 45
101105: PUSH
101106: LD_INT 7
101108: PUSH
101109: LD_INT 47
101111: PUSH
101112: EMPTY
101113: LIST
101114: LIST
101115: LIST
101116: LIST
101117: IN
101118: OR
101119: IFFALSE 101349
// begin attacking := false ;
101121: LD_ADDR_VAR 0 29
101125: PUSH
101126: LD_INT 0
101128: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101129: LD_VAR 0 14
101133: PUSH
101134: LD_INT 1
101136: ARRAY
101137: PPUSH
101138: CALL_OW 266
101142: PUSH
101143: LD_INT 32
101145: PUSH
101146: LD_INT 31
101148: PUSH
101149: LD_INT 33
101151: PUSH
101152: LD_INT 4
101154: PUSH
101155: LD_INT 5
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: IN
101165: IFFALSE 101349
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101167: LD_ADDR_VAR 0 9
101171: PUSH
101172: LD_VAR 0 14
101176: PUSH
101177: LD_INT 1
101179: ARRAY
101180: PPUSH
101181: CALL_OW 266
101185: PPUSH
101186: LD_VAR 0 14
101190: PUSH
101191: LD_INT 1
101193: ARRAY
101194: PPUSH
101195: CALL_OW 250
101199: PPUSH
101200: LD_VAR 0 14
101204: PUSH
101205: LD_INT 1
101207: ARRAY
101208: PPUSH
101209: CALL_OW 251
101213: PPUSH
101214: LD_VAR 0 14
101218: PUSH
101219: LD_INT 1
101221: ARRAY
101222: PPUSH
101223: CALL_OW 254
101227: PPUSH
101228: LD_VAR 0 14
101232: PUSH
101233: LD_INT 1
101235: ARRAY
101236: PPUSH
101237: CALL_OW 248
101241: PPUSH
101242: LD_INT 0
101244: PPUSH
101245: CALL 77955 0 6
101249: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101250: LD_ADDR_VAR 0 8
101254: PUSH
101255: LD_VAR 0 4
101259: PUSH
101260: LD_VAR 0 7
101264: ARRAY
101265: PPUSH
101266: LD_VAR 0 9
101270: PPUSH
101271: CALL 96648 0 2
101275: ST_TO_ADDR
// if j then
101276: LD_VAR 0 8
101280: IFFALSE 101349
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101282: LD_VAR 0 8
101286: PUSH
101287: LD_INT 1
101289: ARRAY
101290: PPUSH
101291: LD_VAR 0 8
101295: PUSH
101296: LD_INT 2
101298: ARRAY
101299: PPUSH
101300: CALL_OW 488
101304: IFFALSE 101349
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101306: LD_VAR 0 4
101310: PUSH
101311: LD_VAR 0 7
101315: ARRAY
101316: PPUSH
101317: LD_VAR 0 8
101321: PUSH
101322: LD_INT 1
101324: ARRAY
101325: PPUSH
101326: LD_VAR 0 8
101330: PUSH
101331: LD_INT 2
101333: ARRAY
101334: PPUSH
101335: CALL_OW 116
// attacking := true ;
101339: LD_ADDR_VAR 0 29
101343: PUSH
101344: LD_INT 1
101346: ST_TO_ADDR
// continue ;
101347: GO 98722
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101349: LD_VAR 0 4
101353: PUSH
101354: LD_VAR 0 7
101358: ARRAY
101359: PPUSH
101360: CALL_OW 265
101364: PUSH
101365: LD_INT 11
101367: EQUAL
101368: IFFALSE 101646
// begin k := 10 ;
101370: LD_ADDR_VAR 0 9
101374: PUSH
101375: LD_INT 10
101377: ST_TO_ADDR
// x := 0 ;
101378: LD_ADDR_VAR 0 10
101382: PUSH
101383: LD_INT 0
101385: ST_TO_ADDR
// if tmp < k then
101386: LD_VAR 0 14
101390: PUSH
101391: LD_VAR 0 9
101395: LESS
101396: IFFALSE 101408
// k := tmp ;
101398: LD_ADDR_VAR 0 9
101402: PUSH
101403: LD_VAR 0 14
101407: ST_TO_ADDR
// for j = k downto 1 do
101408: LD_ADDR_VAR 0 8
101412: PUSH
101413: DOUBLE
101414: LD_VAR 0 9
101418: INC
101419: ST_TO_ADDR
101420: LD_INT 1
101422: PUSH
101423: FOR_DOWNTO
101424: IFFALSE 101499
// begin if GetType ( tmp [ j ] ) = unit_human then
101426: LD_VAR 0 14
101430: PUSH
101431: LD_VAR 0 8
101435: ARRAY
101436: PPUSH
101437: CALL_OW 247
101441: PUSH
101442: LD_INT 1
101444: EQUAL
101445: IFFALSE 101497
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101447: LD_VAR 0 4
101451: PUSH
101452: LD_VAR 0 7
101456: ARRAY
101457: PPUSH
101458: LD_VAR 0 14
101462: PUSH
101463: LD_VAR 0 8
101467: ARRAY
101468: PPUSH
101469: CALL 96919 0 2
// x := tmp [ j ] ;
101473: LD_ADDR_VAR 0 10
101477: PUSH
101478: LD_VAR 0 14
101482: PUSH
101483: LD_VAR 0 8
101487: ARRAY
101488: ST_TO_ADDR
// attacking := true ;
101489: LD_ADDR_VAR 0 29
101493: PUSH
101494: LD_INT 1
101496: ST_TO_ADDR
// end ; end ;
101497: GO 101423
101499: POP
101500: POP
// if not x then
101501: LD_VAR 0 10
101505: NOT
101506: IFFALSE 101646
// begin attacking := true ;
101508: LD_ADDR_VAR 0 29
101512: PUSH
101513: LD_INT 1
101515: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101516: LD_VAR 0 4
101520: PUSH
101521: LD_VAR 0 7
101525: ARRAY
101526: PPUSH
101527: CALL_OW 250
101531: PPUSH
101532: LD_VAR 0 4
101536: PUSH
101537: LD_VAR 0 7
101541: ARRAY
101542: PPUSH
101543: CALL_OW 251
101547: PPUSH
101548: CALL_OW 546
101552: PUSH
101553: LD_INT 2
101555: ARRAY
101556: PUSH
101557: LD_VAR 0 14
101561: PUSH
101562: LD_INT 1
101564: ARRAY
101565: PPUSH
101566: CALL_OW 250
101570: PPUSH
101571: LD_VAR 0 14
101575: PUSH
101576: LD_INT 1
101578: ARRAY
101579: PPUSH
101580: CALL_OW 251
101584: PPUSH
101585: CALL_OW 546
101589: PUSH
101590: LD_INT 2
101592: ARRAY
101593: EQUAL
101594: IFFALSE 101622
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101596: LD_VAR 0 4
101600: PUSH
101601: LD_VAR 0 7
101605: ARRAY
101606: PPUSH
101607: LD_VAR 0 14
101611: PUSH
101612: LD_INT 1
101614: ARRAY
101615: PPUSH
101616: CALL 96919 0 2
101620: GO 101646
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101622: LD_VAR 0 4
101626: PUSH
101627: LD_VAR 0 7
101631: ARRAY
101632: PPUSH
101633: LD_VAR 0 14
101637: PUSH
101638: LD_INT 1
101640: ARRAY
101641: PPUSH
101642: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101646: LD_VAR 0 4
101650: PUSH
101651: LD_VAR 0 7
101655: ARRAY
101656: PPUSH
101657: CALL_OW 264
101661: PUSH
101662: LD_INT 29
101664: EQUAL
101665: IFFALSE 102031
// begin if WantsToAttack ( group [ i ] ) in bombed then
101667: LD_VAR 0 4
101671: PUSH
101672: LD_VAR 0 7
101676: ARRAY
101677: PPUSH
101678: CALL_OW 319
101682: PUSH
101683: LD_VAR 0 28
101687: IN
101688: IFFALSE 101692
// continue ;
101690: GO 98722
// k := 8 ;
101692: LD_ADDR_VAR 0 9
101696: PUSH
101697: LD_INT 8
101699: ST_TO_ADDR
// x := 0 ;
101700: LD_ADDR_VAR 0 10
101704: PUSH
101705: LD_INT 0
101707: ST_TO_ADDR
// if tmp < k then
101708: LD_VAR 0 14
101712: PUSH
101713: LD_VAR 0 9
101717: LESS
101718: IFFALSE 101730
// k := tmp ;
101720: LD_ADDR_VAR 0 9
101724: PUSH
101725: LD_VAR 0 14
101729: ST_TO_ADDR
// for j = 1 to k do
101730: LD_ADDR_VAR 0 8
101734: PUSH
101735: DOUBLE
101736: LD_INT 1
101738: DEC
101739: ST_TO_ADDR
101740: LD_VAR 0 9
101744: PUSH
101745: FOR_TO
101746: IFFALSE 101878
// begin if GetType ( tmp [ j ] ) = unit_building then
101748: LD_VAR 0 14
101752: PUSH
101753: LD_VAR 0 8
101757: ARRAY
101758: PPUSH
101759: CALL_OW 247
101763: PUSH
101764: LD_INT 3
101766: EQUAL
101767: IFFALSE 101876
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101769: LD_VAR 0 14
101773: PUSH
101774: LD_VAR 0 8
101778: ARRAY
101779: PUSH
101780: LD_VAR 0 28
101784: IN
101785: NOT
101786: PUSH
101787: LD_VAR 0 14
101791: PUSH
101792: LD_VAR 0 8
101796: ARRAY
101797: PPUSH
101798: CALL_OW 313
101802: AND
101803: IFFALSE 101876
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101805: LD_VAR 0 4
101809: PUSH
101810: LD_VAR 0 7
101814: ARRAY
101815: PPUSH
101816: LD_VAR 0 14
101820: PUSH
101821: LD_VAR 0 8
101825: ARRAY
101826: PPUSH
101827: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101831: LD_ADDR_VAR 0 28
101835: PUSH
101836: LD_VAR 0 28
101840: PPUSH
101841: LD_VAR 0 28
101845: PUSH
101846: LD_INT 1
101848: PLUS
101849: PPUSH
101850: LD_VAR 0 14
101854: PUSH
101855: LD_VAR 0 8
101859: ARRAY
101860: PPUSH
101861: CALL_OW 1
101865: ST_TO_ADDR
// attacking := true ;
101866: LD_ADDR_VAR 0 29
101870: PUSH
101871: LD_INT 1
101873: ST_TO_ADDR
// break ;
101874: GO 101878
// end ; end ;
101876: GO 101745
101878: POP
101879: POP
// if not attacking and f_attack_depot then
101880: LD_VAR 0 29
101884: NOT
101885: PUSH
101886: LD_VAR 0 25
101890: AND
101891: IFFALSE 101986
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101893: LD_ADDR_VAR 0 13
101897: PUSH
101898: LD_VAR 0 14
101902: PPUSH
101903: LD_INT 2
101905: PUSH
101906: LD_INT 30
101908: PUSH
101909: LD_INT 0
101911: PUSH
101912: EMPTY
101913: LIST
101914: LIST
101915: PUSH
101916: LD_INT 30
101918: PUSH
101919: LD_INT 1
101921: PUSH
101922: EMPTY
101923: LIST
101924: LIST
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: LIST
101930: PPUSH
101931: CALL_OW 72
101935: ST_TO_ADDR
// if z then
101936: LD_VAR 0 13
101940: IFFALSE 101986
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101942: LD_VAR 0 4
101946: PUSH
101947: LD_VAR 0 7
101951: ARRAY
101952: PPUSH
101953: LD_VAR 0 13
101957: PPUSH
101958: LD_VAR 0 4
101962: PUSH
101963: LD_VAR 0 7
101967: ARRAY
101968: PPUSH
101969: CALL_OW 74
101973: PPUSH
101974: CALL_OW 115
// attacking := true ;
101978: LD_ADDR_VAR 0 29
101982: PUSH
101983: LD_INT 1
101985: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101986: LD_VAR 0 4
101990: PUSH
101991: LD_VAR 0 7
101995: ARRAY
101996: PPUSH
101997: CALL_OW 256
102001: PUSH
102002: LD_INT 500
102004: LESS
102005: IFFALSE 102031
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102007: LD_VAR 0 4
102011: PUSH
102012: LD_VAR 0 7
102016: ARRAY
102017: PPUSH
102018: LD_VAR 0 14
102022: PUSH
102023: LD_INT 1
102025: ARRAY
102026: PPUSH
102027: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102031: LD_VAR 0 4
102035: PUSH
102036: LD_VAR 0 7
102040: ARRAY
102041: PPUSH
102042: CALL_OW 264
102046: PUSH
102047: LD_INT 49
102049: EQUAL
102050: IFFALSE 102171
// begin if not HasTask ( group [ i ] ) then
102052: LD_VAR 0 4
102056: PUSH
102057: LD_VAR 0 7
102061: ARRAY
102062: PPUSH
102063: CALL_OW 314
102067: NOT
102068: IFFALSE 102171
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102070: LD_ADDR_VAR 0 9
102074: PUSH
102075: LD_INT 81
102077: PUSH
102078: LD_VAR 0 4
102082: PUSH
102083: LD_VAR 0 7
102087: ARRAY
102088: PPUSH
102089: CALL_OW 255
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PPUSH
102098: CALL_OW 69
102102: PPUSH
102103: LD_VAR 0 4
102107: PUSH
102108: LD_VAR 0 7
102112: ARRAY
102113: PPUSH
102114: CALL_OW 74
102118: ST_TO_ADDR
// if k then
102119: LD_VAR 0 9
102123: IFFALSE 102171
// if GetDistUnits ( group [ i ] , k ) > 10 then
102125: LD_VAR 0 4
102129: PUSH
102130: LD_VAR 0 7
102134: ARRAY
102135: PPUSH
102136: LD_VAR 0 9
102140: PPUSH
102141: CALL_OW 296
102145: PUSH
102146: LD_INT 10
102148: GREATER
102149: IFFALSE 102171
// ComMoveUnit ( group [ i ] , k ) ;
102151: LD_VAR 0 4
102155: PUSH
102156: LD_VAR 0 7
102160: ARRAY
102161: PPUSH
102162: LD_VAR 0 9
102166: PPUSH
102167: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102171: LD_VAR 0 4
102175: PUSH
102176: LD_VAR 0 7
102180: ARRAY
102181: PPUSH
102182: CALL_OW 256
102186: PUSH
102187: LD_INT 250
102189: LESS
102190: PUSH
102191: LD_VAR 0 4
102195: PUSH
102196: LD_VAR 0 7
102200: ARRAY
102201: PUSH
102202: LD_INT 21
102204: PUSH
102205: LD_INT 2
102207: PUSH
102208: EMPTY
102209: LIST
102210: LIST
102211: PUSH
102212: LD_INT 23
102214: PUSH
102215: LD_INT 2
102217: PUSH
102218: EMPTY
102219: LIST
102220: LIST
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: PPUSH
102226: CALL_OW 69
102230: IN
102231: AND
102232: IFFALSE 102357
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102234: LD_ADDR_VAR 0 9
102238: PUSH
102239: LD_OWVAR 3
102243: PUSH
102244: LD_VAR 0 4
102248: PUSH
102249: LD_VAR 0 7
102253: ARRAY
102254: DIFF
102255: PPUSH
102256: LD_VAR 0 4
102260: PUSH
102261: LD_VAR 0 7
102265: ARRAY
102266: PPUSH
102267: CALL_OW 74
102271: ST_TO_ADDR
// if not k then
102272: LD_VAR 0 9
102276: NOT
102277: IFFALSE 102281
// continue ;
102279: GO 98722
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102281: LD_VAR 0 9
102285: PUSH
102286: LD_INT 81
102288: PUSH
102289: LD_VAR 0 4
102293: PUSH
102294: LD_VAR 0 7
102298: ARRAY
102299: PPUSH
102300: CALL_OW 255
102304: PUSH
102305: EMPTY
102306: LIST
102307: LIST
102308: PPUSH
102309: CALL_OW 69
102313: IN
102314: PUSH
102315: LD_VAR 0 9
102319: PPUSH
102320: LD_VAR 0 4
102324: PUSH
102325: LD_VAR 0 7
102329: ARRAY
102330: PPUSH
102331: CALL_OW 296
102335: PUSH
102336: LD_INT 5
102338: LESS
102339: AND
102340: IFFALSE 102357
// ComAutodestruct ( group [ i ] ) ;
102342: LD_VAR 0 4
102346: PUSH
102347: LD_VAR 0 7
102351: ARRAY
102352: PPUSH
102353: CALL 96817 0 1
// end ; if f_attack_depot then
102357: LD_VAR 0 25
102361: IFFALSE 102473
// begin k := 6 ;
102363: LD_ADDR_VAR 0 9
102367: PUSH
102368: LD_INT 6
102370: ST_TO_ADDR
// if tmp < k then
102371: LD_VAR 0 14
102375: PUSH
102376: LD_VAR 0 9
102380: LESS
102381: IFFALSE 102393
// k := tmp ;
102383: LD_ADDR_VAR 0 9
102387: PUSH
102388: LD_VAR 0 14
102392: ST_TO_ADDR
// for j = 1 to k do
102393: LD_ADDR_VAR 0 8
102397: PUSH
102398: DOUBLE
102399: LD_INT 1
102401: DEC
102402: ST_TO_ADDR
102403: LD_VAR 0 9
102407: PUSH
102408: FOR_TO
102409: IFFALSE 102471
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102411: LD_VAR 0 8
102415: PPUSH
102416: CALL_OW 266
102420: PUSH
102421: LD_INT 0
102423: PUSH
102424: LD_INT 1
102426: PUSH
102427: EMPTY
102428: LIST
102429: LIST
102430: IN
102431: IFFALSE 102469
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102433: LD_VAR 0 4
102437: PUSH
102438: LD_VAR 0 7
102442: ARRAY
102443: PPUSH
102444: LD_VAR 0 14
102448: PUSH
102449: LD_VAR 0 8
102453: ARRAY
102454: PPUSH
102455: CALL_OW 115
// attacking := true ;
102459: LD_ADDR_VAR 0 29
102463: PUSH
102464: LD_INT 1
102466: ST_TO_ADDR
// break ;
102467: GO 102471
// end ;
102469: GO 102408
102471: POP
102472: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102473: LD_VAR 0 4
102477: PUSH
102478: LD_VAR 0 7
102482: ARRAY
102483: PPUSH
102484: CALL_OW 302
102488: PUSH
102489: LD_VAR 0 29
102493: NOT
102494: AND
102495: IFFALSE 102817
// begin if GetTag ( group [ i ] ) = 71 then
102497: LD_VAR 0 4
102501: PUSH
102502: LD_VAR 0 7
102506: ARRAY
102507: PPUSH
102508: CALL_OW 110
102512: PUSH
102513: LD_INT 71
102515: EQUAL
102516: IFFALSE 102557
// begin if HasTask ( group [ i ] ) then
102518: LD_VAR 0 4
102522: PUSH
102523: LD_VAR 0 7
102527: ARRAY
102528: PPUSH
102529: CALL_OW 314
102533: IFFALSE 102539
// continue else
102535: GO 98722
102537: GO 102557
// SetTag ( group [ i ] , 0 ) ;
102539: LD_VAR 0 4
102543: PUSH
102544: LD_VAR 0 7
102548: ARRAY
102549: PPUSH
102550: LD_INT 0
102552: PPUSH
102553: CALL_OW 109
// end ; k := 8 ;
102557: LD_ADDR_VAR 0 9
102561: PUSH
102562: LD_INT 8
102564: ST_TO_ADDR
// x := 0 ;
102565: LD_ADDR_VAR 0 10
102569: PUSH
102570: LD_INT 0
102572: ST_TO_ADDR
// if tmp < k then
102573: LD_VAR 0 14
102577: PUSH
102578: LD_VAR 0 9
102582: LESS
102583: IFFALSE 102595
// k := tmp ;
102585: LD_ADDR_VAR 0 9
102589: PUSH
102590: LD_VAR 0 14
102594: ST_TO_ADDR
// for j = 1 to k do
102595: LD_ADDR_VAR 0 8
102599: PUSH
102600: DOUBLE
102601: LD_INT 1
102603: DEC
102604: ST_TO_ADDR
102605: LD_VAR 0 9
102609: PUSH
102610: FOR_TO
102611: IFFALSE 102709
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102613: LD_VAR 0 14
102617: PUSH
102618: LD_VAR 0 8
102622: ARRAY
102623: PPUSH
102624: CALL_OW 247
102628: PUSH
102629: LD_INT 1
102631: EQUAL
102632: PUSH
102633: LD_VAR 0 14
102637: PUSH
102638: LD_VAR 0 8
102642: ARRAY
102643: PPUSH
102644: CALL_OW 256
102648: PUSH
102649: LD_INT 250
102651: LESS
102652: PUSH
102653: LD_VAR 0 20
102657: AND
102658: PUSH
102659: LD_VAR 0 20
102663: NOT
102664: PUSH
102665: LD_VAR 0 14
102669: PUSH
102670: LD_VAR 0 8
102674: ARRAY
102675: PPUSH
102676: CALL_OW 256
102680: PUSH
102681: LD_INT 250
102683: GREATEREQUAL
102684: AND
102685: OR
102686: AND
102687: IFFALSE 102707
// begin x := tmp [ j ] ;
102689: LD_ADDR_VAR 0 10
102693: PUSH
102694: LD_VAR 0 14
102698: PUSH
102699: LD_VAR 0 8
102703: ARRAY
102704: ST_TO_ADDR
// break ;
102705: GO 102709
// end ;
102707: GO 102610
102709: POP
102710: POP
// if x then
102711: LD_VAR 0 10
102715: IFFALSE 102739
// ComAttackUnit ( group [ i ] , x ) else
102717: LD_VAR 0 4
102721: PUSH
102722: LD_VAR 0 7
102726: ARRAY
102727: PPUSH
102728: LD_VAR 0 10
102732: PPUSH
102733: CALL_OW 115
102737: GO 102763
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102739: LD_VAR 0 4
102743: PUSH
102744: LD_VAR 0 7
102748: ARRAY
102749: PPUSH
102750: LD_VAR 0 14
102754: PUSH
102755: LD_INT 1
102757: ARRAY
102758: PPUSH
102759: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102763: LD_VAR 0 4
102767: PUSH
102768: LD_VAR 0 7
102772: ARRAY
102773: PPUSH
102774: CALL_OW 314
102778: NOT
102779: IFFALSE 102817
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102781: LD_VAR 0 4
102785: PUSH
102786: LD_VAR 0 7
102790: ARRAY
102791: PPUSH
102792: LD_VAR 0 14
102796: PPUSH
102797: LD_VAR 0 4
102801: PUSH
102802: LD_VAR 0 7
102806: ARRAY
102807: PPUSH
102808: CALL_OW 74
102812: PPUSH
102813: CALL_OW 115
// end ; end ; end ;
102817: GO 98722
102819: POP
102820: POP
// wait ( 0 0$1 ) ;
102821: LD_INT 35
102823: PPUSH
102824: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102828: LD_VAR 0 4
102832: PUSH
102833: EMPTY
102834: EQUAL
102835: PUSH
102836: LD_INT 81
102838: PUSH
102839: LD_VAR 0 35
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: PPUSH
102848: CALL_OW 69
102852: NOT
102853: OR
102854: IFFALSE 98707
// end ;
102856: LD_VAR 0 2
102860: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102861: LD_INT 0
102863: PPUSH
102864: PPUSH
102865: PPUSH
102866: PPUSH
// if not base_units then
102867: LD_VAR 0 1
102871: NOT
102872: IFFALSE 102876
// exit ;
102874: GO 102963
// result := false ;
102876: LD_ADDR_VAR 0 2
102880: PUSH
102881: LD_INT 0
102883: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102884: LD_ADDR_VAR 0 5
102888: PUSH
102889: LD_VAR 0 1
102893: PPUSH
102894: LD_INT 21
102896: PUSH
102897: LD_INT 3
102899: PUSH
102900: EMPTY
102901: LIST
102902: LIST
102903: PPUSH
102904: CALL_OW 72
102908: ST_TO_ADDR
// if not tmp then
102909: LD_VAR 0 5
102913: NOT
102914: IFFALSE 102918
// exit ;
102916: GO 102963
// for i in tmp do
102918: LD_ADDR_VAR 0 3
102922: PUSH
102923: LD_VAR 0 5
102927: PUSH
102928: FOR_IN
102929: IFFALSE 102961
// begin result := EnemyInRange ( i , 22 ) ;
102931: LD_ADDR_VAR 0 2
102935: PUSH
102936: LD_VAR 0 3
102940: PPUSH
102941: LD_INT 22
102943: PPUSH
102944: CALL 96500 0 2
102948: ST_TO_ADDR
// if result then
102949: LD_VAR 0 2
102953: IFFALSE 102959
// exit ;
102955: POP
102956: POP
102957: GO 102963
// end ;
102959: GO 102928
102961: POP
102962: POP
// end ;
102963: LD_VAR 0 2
102967: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
102968: LD_INT 0
102970: PPUSH
102971: PPUSH
// if not units then
102972: LD_VAR 0 1
102976: NOT
102977: IFFALSE 102981
// exit ;
102979: GO 103051
// result := [ ] ;
102981: LD_ADDR_VAR 0 3
102985: PUSH
102986: EMPTY
102987: ST_TO_ADDR
// for i in units do
102988: LD_ADDR_VAR 0 4
102992: PUSH
102993: LD_VAR 0 1
102997: PUSH
102998: FOR_IN
102999: IFFALSE 103049
// if GetTag ( i ) = tag then
103001: LD_VAR 0 4
103005: PPUSH
103006: CALL_OW 110
103010: PUSH
103011: LD_VAR 0 2
103015: EQUAL
103016: IFFALSE 103047
// result := Insert ( result , result + 1 , i ) ;
103018: LD_ADDR_VAR 0 3
103022: PUSH
103023: LD_VAR 0 3
103027: PPUSH
103028: LD_VAR 0 3
103032: PUSH
103033: LD_INT 1
103035: PLUS
103036: PPUSH
103037: LD_VAR 0 4
103041: PPUSH
103042: CALL_OW 2
103046: ST_TO_ADDR
103047: GO 102998
103049: POP
103050: POP
// end ;
103051: LD_VAR 0 3
103055: RET
// export function IsDriver ( un ) ; begin
103056: LD_INT 0
103058: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103059: LD_ADDR_VAR 0 2
103063: PUSH
103064: LD_VAR 0 1
103068: PUSH
103069: LD_INT 55
103071: PUSH
103072: EMPTY
103073: LIST
103074: PPUSH
103075: CALL_OW 69
103079: IN
103080: ST_TO_ADDR
// end ;
103081: LD_VAR 0 2
103085: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103086: LD_INT 0
103088: PPUSH
103089: PPUSH
// list := [ ] ;
103090: LD_ADDR_VAR 0 5
103094: PUSH
103095: EMPTY
103096: ST_TO_ADDR
// case d of 0 :
103097: LD_VAR 0 3
103101: PUSH
103102: LD_INT 0
103104: DOUBLE
103105: EQUAL
103106: IFTRUE 103110
103108: GO 103243
103110: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103111: LD_ADDR_VAR 0 5
103115: PUSH
103116: LD_VAR 0 1
103120: PUSH
103121: LD_INT 4
103123: MINUS
103124: PUSH
103125: LD_VAR 0 2
103129: PUSH
103130: LD_INT 4
103132: MINUS
103133: PUSH
103134: LD_INT 2
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: LIST
103141: PUSH
103142: LD_VAR 0 1
103146: PUSH
103147: LD_INT 3
103149: MINUS
103150: PUSH
103151: LD_VAR 0 2
103155: PUSH
103156: LD_INT 1
103158: PUSH
103159: EMPTY
103160: LIST
103161: LIST
103162: LIST
103163: PUSH
103164: LD_VAR 0 1
103168: PUSH
103169: LD_INT 4
103171: PLUS
103172: PUSH
103173: LD_VAR 0 2
103177: PUSH
103178: LD_INT 4
103180: PUSH
103181: EMPTY
103182: LIST
103183: LIST
103184: LIST
103185: PUSH
103186: LD_VAR 0 1
103190: PUSH
103191: LD_INT 3
103193: PLUS
103194: PUSH
103195: LD_VAR 0 2
103199: PUSH
103200: LD_INT 3
103202: PLUS
103203: PUSH
103204: LD_INT 5
103206: PUSH
103207: EMPTY
103208: LIST
103209: LIST
103210: LIST
103211: PUSH
103212: LD_VAR 0 1
103216: PUSH
103217: LD_VAR 0 2
103221: PUSH
103222: LD_INT 4
103224: PLUS
103225: PUSH
103226: LD_INT 0
103228: PUSH
103229: EMPTY
103230: LIST
103231: LIST
103232: LIST
103233: PUSH
103234: EMPTY
103235: LIST
103236: LIST
103237: LIST
103238: LIST
103239: LIST
103240: ST_TO_ADDR
// end ; 1 :
103241: GO 103941
103243: LD_INT 1
103245: DOUBLE
103246: EQUAL
103247: IFTRUE 103251
103249: GO 103384
103251: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103252: LD_ADDR_VAR 0 5
103256: PUSH
103257: LD_VAR 0 1
103261: PUSH
103262: LD_VAR 0 2
103266: PUSH
103267: LD_INT 4
103269: MINUS
103270: PUSH
103271: LD_INT 3
103273: PUSH
103274: EMPTY
103275: LIST
103276: LIST
103277: LIST
103278: PUSH
103279: LD_VAR 0 1
103283: PUSH
103284: LD_INT 3
103286: MINUS
103287: PUSH
103288: LD_VAR 0 2
103292: PUSH
103293: LD_INT 3
103295: MINUS
103296: PUSH
103297: LD_INT 2
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: LIST
103304: PUSH
103305: LD_VAR 0 1
103309: PUSH
103310: LD_INT 4
103312: MINUS
103313: PUSH
103314: LD_VAR 0 2
103318: PUSH
103319: LD_INT 1
103321: PUSH
103322: EMPTY
103323: LIST
103324: LIST
103325: LIST
103326: PUSH
103327: LD_VAR 0 1
103331: PUSH
103332: LD_VAR 0 2
103336: PUSH
103337: LD_INT 3
103339: PLUS
103340: PUSH
103341: LD_INT 0
103343: PUSH
103344: EMPTY
103345: LIST
103346: LIST
103347: LIST
103348: PUSH
103349: LD_VAR 0 1
103353: PUSH
103354: LD_INT 4
103356: PLUS
103357: PUSH
103358: LD_VAR 0 2
103362: PUSH
103363: LD_INT 4
103365: PLUS
103366: PUSH
103367: LD_INT 5
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: LIST
103374: PUSH
103375: EMPTY
103376: LIST
103377: LIST
103378: LIST
103379: LIST
103380: LIST
103381: ST_TO_ADDR
// end ; 2 :
103382: GO 103941
103384: LD_INT 2
103386: DOUBLE
103387: EQUAL
103388: IFTRUE 103392
103390: GO 103521
103392: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103393: LD_ADDR_VAR 0 5
103397: PUSH
103398: LD_VAR 0 1
103402: PUSH
103403: LD_VAR 0 2
103407: PUSH
103408: LD_INT 3
103410: MINUS
103411: PUSH
103412: LD_INT 3
103414: PUSH
103415: EMPTY
103416: LIST
103417: LIST
103418: LIST
103419: PUSH
103420: LD_VAR 0 1
103424: PUSH
103425: LD_INT 4
103427: PLUS
103428: PUSH
103429: LD_VAR 0 2
103433: PUSH
103434: LD_INT 4
103436: PUSH
103437: EMPTY
103438: LIST
103439: LIST
103440: LIST
103441: PUSH
103442: LD_VAR 0 1
103446: PUSH
103447: LD_VAR 0 2
103451: PUSH
103452: LD_INT 4
103454: PLUS
103455: PUSH
103456: LD_INT 0
103458: PUSH
103459: EMPTY
103460: LIST
103461: LIST
103462: LIST
103463: PUSH
103464: LD_VAR 0 1
103468: PUSH
103469: LD_INT 3
103471: MINUS
103472: PUSH
103473: LD_VAR 0 2
103477: PUSH
103478: LD_INT 1
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: LIST
103485: PUSH
103486: LD_VAR 0 1
103490: PUSH
103491: LD_INT 4
103493: MINUS
103494: PUSH
103495: LD_VAR 0 2
103499: PUSH
103500: LD_INT 4
103502: MINUS
103503: PUSH
103504: LD_INT 2
103506: PUSH
103507: EMPTY
103508: LIST
103509: LIST
103510: LIST
103511: PUSH
103512: EMPTY
103513: LIST
103514: LIST
103515: LIST
103516: LIST
103517: LIST
103518: ST_TO_ADDR
// end ; 3 :
103519: GO 103941
103521: LD_INT 3
103523: DOUBLE
103524: EQUAL
103525: IFTRUE 103529
103527: GO 103662
103529: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103530: LD_ADDR_VAR 0 5
103534: PUSH
103535: LD_VAR 0 1
103539: PUSH
103540: LD_INT 3
103542: PLUS
103543: PUSH
103544: LD_VAR 0 2
103548: PUSH
103549: LD_INT 4
103551: PUSH
103552: EMPTY
103553: LIST
103554: LIST
103555: LIST
103556: PUSH
103557: LD_VAR 0 1
103561: PUSH
103562: LD_INT 4
103564: PLUS
103565: PUSH
103566: LD_VAR 0 2
103570: PUSH
103571: LD_INT 4
103573: PLUS
103574: PUSH
103575: LD_INT 5
103577: PUSH
103578: EMPTY
103579: LIST
103580: LIST
103581: LIST
103582: PUSH
103583: LD_VAR 0 1
103587: PUSH
103588: LD_INT 4
103590: MINUS
103591: PUSH
103592: LD_VAR 0 2
103596: PUSH
103597: LD_INT 1
103599: PUSH
103600: EMPTY
103601: LIST
103602: LIST
103603: LIST
103604: PUSH
103605: LD_VAR 0 1
103609: PUSH
103610: LD_VAR 0 2
103614: PUSH
103615: LD_INT 4
103617: MINUS
103618: PUSH
103619: LD_INT 3
103621: PUSH
103622: EMPTY
103623: LIST
103624: LIST
103625: LIST
103626: PUSH
103627: LD_VAR 0 1
103631: PUSH
103632: LD_INT 3
103634: MINUS
103635: PUSH
103636: LD_VAR 0 2
103640: PUSH
103641: LD_INT 3
103643: MINUS
103644: PUSH
103645: LD_INT 2
103647: PUSH
103648: EMPTY
103649: LIST
103650: LIST
103651: LIST
103652: PUSH
103653: EMPTY
103654: LIST
103655: LIST
103656: LIST
103657: LIST
103658: LIST
103659: ST_TO_ADDR
// end ; 4 :
103660: GO 103941
103662: LD_INT 4
103664: DOUBLE
103665: EQUAL
103666: IFTRUE 103670
103668: GO 103803
103670: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103671: LD_ADDR_VAR 0 5
103675: PUSH
103676: LD_VAR 0 1
103680: PUSH
103681: LD_VAR 0 2
103685: PUSH
103686: LD_INT 4
103688: PLUS
103689: PUSH
103690: LD_INT 0
103692: PUSH
103693: EMPTY
103694: LIST
103695: LIST
103696: LIST
103697: PUSH
103698: LD_VAR 0 1
103702: PUSH
103703: LD_INT 3
103705: PLUS
103706: PUSH
103707: LD_VAR 0 2
103711: PUSH
103712: LD_INT 3
103714: PLUS
103715: PUSH
103716: LD_INT 5
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: LIST
103723: PUSH
103724: LD_VAR 0 1
103728: PUSH
103729: LD_INT 4
103731: PLUS
103732: PUSH
103733: LD_VAR 0 2
103737: PUSH
103738: LD_INT 4
103740: PUSH
103741: EMPTY
103742: LIST
103743: LIST
103744: LIST
103745: PUSH
103746: LD_VAR 0 1
103750: PUSH
103751: LD_VAR 0 2
103755: PUSH
103756: LD_INT 3
103758: MINUS
103759: PUSH
103760: LD_INT 3
103762: PUSH
103763: EMPTY
103764: LIST
103765: LIST
103766: LIST
103767: PUSH
103768: LD_VAR 0 1
103772: PUSH
103773: LD_INT 4
103775: MINUS
103776: PUSH
103777: LD_VAR 0 2
103781: PUSH
103782: LD_INT 4
103784: MINUS
103785: PUSH
103786: LD_INT 2
103788: PUSH
103789: EMPTY
103790: LIST
103791: LIST
103792: LIST
103793: PUSH
103794: EMPTY
103795: LIST
103796: LIST
103797: LIST
103798: LIST
103799: LIST
103800: ST_TO_ADDR
// end ; 5 :
103801: GO 103941
103803: LD_INT 5
103805: DOUBLE
103806: EQUAL
103807: IFTRUE 103811
103809: GO 103940
103811: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103812: LD_ADDR_VAR 0 5
103816: PUSH
103817: LD_VAR 0 1
103821: PUSH
103822: LD_INT 4
103824: MINUS
103825: PUSH
103826: LD_VAR 0 2
103830: PUSH
103831: LD_INT 1
103833: PUSH
103834: EMPTY
103835: LIST
103836: LIST
103837: LIST
103838: PUSH
103839: LD_VAR 0 1
103843: PUSH
103844: LD_VAR 0 2
103848: PUSH
103849: LD_INT 4
103851: MINUS
103852: PUSH
103853: LD_INT 3
103855: PUSH
103856: EMPTY
103857: LIST
103858: LIST
103859: LIST
103860: PUSH
103861: LD_VAR 0 1
103865: PUSH
103866: LD_INT 4
103868: PLUS
103869: PUSH
103870: LD_VAR 0 2
103874: PUSH
103875: LD_INT 4
103877: PLUS
103878: PUSH
103879: LD_INT 5
103881: PUSH
103882: EMPTY
103883: LIST
103884: LIST
103885: LIST
103886: PUSH
103887: LD_VAR 0 1
103891: PUSH
103892: LD_INT 3
103894: PLUS
103895: PUSH
103896: LD_VAR 0 2
103900: PUSH
103901: LD_INT 4
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: PUSH
103909: LD_VAR 0 1
103913: PUSH
103914: LD_VAR 0 2
103918: PUSH
103919: LD_INT 3
103921: PLUS
103922: PUSH
103923: LD_INT 0
103925: PUSH
103926: EMPTY
103927: LIST
103928: LIST
103929: LIST
103930: PUSH
103931: EMPTY
103932: LIST
103933: LIST
103934: LIST
103935: LIST
103936: LIST
103937: ST_TO_ADDR
// end ; end ;
103938: GO 103941
103940: POP
// result := list ;
103941: LD_ADDR_VAR 0 4
103945: PUSH
103946: LD_VAR 0 5
103950: ST_TO_ADDR
// end ;
103951: LD_VAR 0 4
103955: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103956: LD_INT 0
103958: PPUSH
103959: PPUSH
103960: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103961: LD_VAR 0 1
103965: NOT
103966: PUSH
103967: LD_VAR 0 2
103971: PUSH
103972: LD_INT 1
103974: PUSH
103975: LD_INT 2
103977: PUSH
103978: LD_INT 3
103980: PUSH
103981: LD_INT 4
103983: PUSH
103984: EMPTY
103985: LIST
103986: LIST
103987: LIST
103988: LIST
103989: IN
103990: NOT
103991: OR
103992: IFFALSE 103996
// exit ;
103994: GO 104088
// tmp := [ ] ;
103996: LD_ADDR_VAR 0 5
104000: PUSH
104001: EMPTY
104002: ST_TO_ADDR
// for i in units do
104003: LD_ADDR_VAR 0 4
104007: PUSH
104008: LD_VAR 0 1
104012: PUSH
104013: FOR_IN
104014: IFFALSE 104057
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
104016: LD_ADDR_VAR 0 5
104020: PUSH
104021: LD_VAR 0 5
104025: PPUSH
104026: LD_VAR 0 5
104030: PUSH
104031: LD_INT 1
104033: PLUS
104034: PPUSH
104035: LD_VAR 0 4
104039: PPUSH
104040: LD_VAR 0 2
104044: PPUSH
104045: CALL_OW 259
104049: PPUSH
104050: CALL_OW 2
104054: ST_TO_ADDR
104055: GO 104013
104057: POP
104058: POP
// if not tmp then
104059: LD_VAR 0 5
104063: NOT
104064: IFFALSE 104068
// exit ;
104066: GO 104088
// result := SortListByListDesc ( units , tmp ) ;
104068: LD_ADDR_VAR 0 3
104072: PUSH
104073: LD_VAR 0 1
104077: PPUSH
104078: LD_VAR 0 5
104082: PPUSH
104083: CALL_OW 77
104087: ST_TO_ADDR
// end ;
104088: LD_VAR 0 3
104092: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104093: LD_INT 0
104095: PPUSH
104096: PPUSH
104097: PPUSH
// x := GetX ( building ) ;
104098: LD_ADDR_VAR 0 4
104102: PUSH
104103: LD_VAR 0 2
104107: PPUSH
104108: CALL_OW 250
104112: ST_TO_ADDR
// y := GetY ( building ) ;
104113: LD_ADDR_VAR 0 5
104117: PUSH
104118: LD_VAR 0 2
104122: PPUSH
104123: CALL_OW 251
104127: ST_TO_ADDR
// if GetTaskList ( unit ) then
104128: LD_VAR 0 1
104132: PPUSH
104133: CALL_OW 437
104137: IFFALSE 104232
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104139: LD_STRING e
104141: PUSH
104142: LD_VAR 0 1
104146: PPUSH
104147: CALL_OW 437
104151: PUSH
104152: LD_INT 1
104154: ARRAY
104155: PUSH
104156: LD_INT 1
104158: ARRAY
104159: EQUAL
104160: PUSH
104161: LD_VAR 0 4
104165: PUSH
104166: LD_VAR 0 1
104170: PPUSH
104171: CALL_OW 437
104175: PUSH
104176: LD_INT 1
104178: ARRAY
104179: PUSH
104180: LD_INT 2
104182: ARRAY
104183: EQUAL
104184: AND
104185: PUSH
104186: LD_VAR 0 5
104190: PUSH
104191: LD_VAR 0 1
104195: PPUSH
104196: CALL_OW 437
104200: PUSH
104201: LD_INT 1
104203: ARRAY
104204: PUSH
104205: LD_INT 3
104207: ARRAY
104208: EQUAL
104209: AND
104210: IFFALSE 104222
// result := true else
104212: LD_ADDR_VAR 0 3
104216: PUSH
104217: LD_INT 1
104219: ST_TO_ADDR
104220: GO 104230
// result := false ;
104222: LD_ADDR_VAR 0 3
104226: PUSH
104227: LD_INT 0
104229: ST_TO_ADDR
// end else
104230: GO 104240
// result := false ;
104232: LD_ADDR_VAR 0 3
104236: PUSH
104237: LD_INT 0
104239: ST_TO_ADDR
// end ;
104240: LD_VAR 0 3
104244: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104245: LD_INT 0
104247: PPUSH
104248: PPUSH
104249: PPUSH
104250: PPUSH
// if not unit or not area then
104251: LD_VAR 0 1
104255: NOT
104256: PUSH
104257: LD_VAR 0 2
104261: NOT
104262: OR
104263: IFFALSE 104267
// exit ;
104265: GO 104431
// tmp := AreaToList ( area , i ) ;
104267: LD_ADDR_VAR 0 6
104271: PUSH
104272: LD_VAR 0 2
104276: PPUSH
104277: LD_VAR 0 5
104281: PPUSH
104282: CALL_OW 517
104286: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104287: LD_ADDR_VAR 0 5
104291: PUSH
104292: DOUBLE
104293: LD_INT 1
104295: DEC
104296: ST_TO_ADDR
104297: LD_VAR 0 6
104301: PUSH
104302: LD_INT 1
104304: ARRAY
104305: PUSH
104306: FOR_TO
104307: IFFALSE 104429
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104309: LD_ADDR_VAR 0 7
104313: PUSH
104314: LD_VAR 0 6
104318: PUSH
104319: LD_INT 1
104321: ARRAY
104322: PUSH
104323: LD_VAR 0 5
104327: ARRAY
104328: PUSH
104329: LD_VAR 0 6
104333: PUSH
104334: LD_INT 2
104336: ARRAY
104337: PUSH
104338: LD_VAR 0 5
104342: ARRAY
104343: PUSH
104344: EMPTY
104345: LIST
104346: LIST
104347: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104348: LD_VAR 0 7
104352: PUSH
104353: LD_INT 1
104355: ARRAY
104356: PPUSH
104357: LD_VAR 0 7
104361: PUSH
104362: LD_INT 2
104364: ARRAY
104365: PPUSH
104366: CALL_OW 428
104370: PUSH
104371: LD_INT 0
104373: EQUAL
104374: IFFALSE 104427
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104376: LD_VAR 0 1
104380: PPUSH
104381: LD_VAR 0 7
104385: PUSH
104386: LD_INT 1
104388: ARRAY
104389: PPUSH
104390: LD_VAR 0 7
104394: PUSH
104395: LD_INT 2
104397: ARRAY
104398: PPUSH
104399: LD_VAR 0 3
104403: PPUSH
104404: CALL_OW 48
// result := IsPlaced ( unit ) ;
104408: LD_ADDR_VAR 0 4
104412: PUSH
104413: LD_VAR 0 1
104417: PPUSH
104418: CALL_OW 305
104422: ST_TO_ADDR
// exit ;
104423: POP
104424: POP
104425: GO 104431
// end ; end ;
104427: GO 104306
104429: POP
104430: POP
// end ;
104431: LD_VAR 0 4
104435: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104436: LD_INT 0
104438: PPUSH
104439: PPUSH
104440: PPUSH
// if not side or side > 8 then
104441: LD_VAR 0 1
104445: NOT
104446: PUSH
104447: LD_VAR 0 1
104451: PUSH
104452: LD_INT 8
104454: GREATER
104455: OR
104456: IFFALSE 104460
// exit ;
104458: GO 104647
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104460: LD_ADDR_VAR 0 4
104464: PUSH
104465: LD_INT 22
104467: PUSH
104468: LD_VAR 0 1
104472: PUSH
104473: EMPTY
104474: LIST
104475: LIST
104476: PUSH
104477: LD_INT 21
104479: PUSH
104480: LD_INT 3
104482: PUSH
104483: EMPTY
104484: LIST
104485: LIST
104486: PUSH
104487: EMPTY
104488: LIST
104489: LIST
104490: PPUSH
104491: CALL_OW 69
104495: ST_TO_ADDR
// if not tmp then
104496: LD_VAR 0 4
104500: NOT
104501: IFFALSE 104505
// exit ;
104503: GO 104647
// enable_addtolog := true ;
104505: LD_ADDR_OWVAR 81
104509: PUSH
104510: LD_INT 1
104512: ST_TO_ADDR
// AddToLog ( [ ) ;
104513: LD_STRING [
104515: PPUSH
104516: CALL_OW 561
// for i in tmp do
104520: LD_ADDR_VAR 0 3
104524: PUSH
104525: LD_VAR 0 4
104529: PUSH
104530: FOR_IN
104531: IFFALSE 104638
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104533: LD_STRING [
104535: PUSH
104536: LD_VAR 0 3
104540: PPUSH
104541: CALL_OW 266
104545: STR
104546: PUSH
104547: LD_STRING , 
104549: STR
104550: PUSH
104551: LD_VAR 0 3
104555: PPUSH
104556: CALL_OW 250
104560: STR
104561: PUSH
104562: LD_STRING , 
104564: STR
104565: PUSH
104566: LD_VAR 0 3
104570: PPUSH
104571: CALL_OW 251
104575: STR
104576: PUSH
104577: LD_STRING , 
104579: STR
104580: PUSH
104581: LD_VAR 0 3
104585: PPUSH
104586: CALL_OW 254
104590: STR
104591: PUSH
104592: LD_STRING , 
104594: STR
104595: PUSH
104596: LD_VAR 0 3
104600: PPUSH
104601: LD_INT 1
104603: PPUSH
104604: CALL_OW 268
104608: STR
104609: PUSH
104610: LD_STRING , 
104612: STR
104613: PUSH
104614: LD_VAR 0 3
104618: PPUSH
104619: LD_INT 2
104621: PPUSH
104622: CALL_OW 268
104626: STR
104627: PUSH
104628: LD_STRING ],
104630: STR
104631: PPUSH
104632: CALL_OW 561
// end ;
104636: GO 104530
104638: POP
104639: POP
// AddToLog ( ]; ) ;
104640: LD_STRING ];
104642: PPUSH
104643: CALL_OW 561
// end ;
104647: LD_VAR 0 2
104651: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104652: LD_INT 0
104654: PPUSH
104655: PPUSH
104656: PPUSH
104657: PPUSH
104658: PPUSH
// if not area or not rate or not max then
104659: LD_VAR 0 1
104663: NOT
104664: PUSH
104665: LD_VAR 0 2
104669: NOT
104670: OR
104671: PUSH
104672: LD_VAR 0 4
104676: NOT
104677: OR
104678: IFFALSE 104682
// exit ;
104680: GO 104874
// while 1 do
104682: LD_INT 1
104684: IFFALSE 104874
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104686: LD_ADDR_VAR 0 9
104690: PUSH
104691: LD_VAR 0 1
104695: PPUSH
104696: LD_INT 1
104698: PPUSH
104699: CALL_OW 287
104703: PUSH
104704: LD_INT 10
104706: MUL
104707: ST_TO_ADDR
// r := rate / 10 ;
104708: LD_ADDR_VAR 0 7
104712: PUSH
104713: LD_VAR 0 2
104717: PUSH
104718: LD_INT 10
104720: DIVREAL
104721: ST_TO_ADDR
// time := 1 1$00 ;
104722: LD_ADDR_VAR 0 8
104726: PUSH
104727: LD_INT 2100
104729: ST_TO_ADDR
// if amount < min then
104730: LD_VAR 0 9
104734: PUSH
104735: LD_VAR 0 3
104739: LESS
104740: IFFALSE 104758
// r := r * 2 else
104742: LD_ADDR_VAR 0 7
104746: PUSH
104747: LD_VAR 0 7
104751: PUSH
104752: LD_INT 2
104754: MUL
104755: ST_TO_ADDR
104756: GO 104784
// if amount > max then
104758: LD_VAR 0 9
104762: PUSH
104763: LD_VAR 0 4
104767: GREATER
104768: IFFALSE 104784
// r := r / 2 ;
104770: LD_ADDR_VAR 0 7
104774: PUSH
104775: LD_VAR 0 7
104779: PUSH
104780: LD_INT 2
104782: DIVREAL
104783: ST_TO_ADDR
// time := time / r ;
104784: LD_ADDR_VAR 0 8
104788: PUSH
104789: LD_VAR 0 8
104793: PUSH
104794: LD_VAR 0 7
104798: DIVREAL
104799: ST_TO_ADDR
// if time < 0 then
104800: LD_VAR 0 8
104804: PUSH
104805: LD_INT 0
104807: LESS
104808: IFFALSE 104825
// time := time * - 1 ;
104810: LD_ADDR_VAR 0 8
104814: PUSH
104815: LD_VAR 0 8
104819: PUSH
104820: LD_INT 1
104822: NEG
104823: MUL
104824: ST_TO_ADDR
// wait ( time ) ;
104825: LD_VAR 0 8
104829: PPUSH
104830: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
104834: LD_INT 35
104836: PPUSH
104837: LD_INT 875
104839: PPUSH
104840: CALL_OW 12
104844: PPUSH
104845: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104849: LD_INT 1
104851: PPUSH
104852: LD_INT 5
104854: PPUSH
104855: CALL_OW 12
104859: PPUSH
104860: LD_VAR 0 1
104864: PPUSH
104865: LD_INT 1
104867: PPUSH
104868: CALL_OW 55
// end ;
104872: GO 104682
// end ;
104874: LD_VAR 0 5
104878: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104879: LD_INT 0
104881: PPUSH
104882: PPUSH
104883: PPUSH
104884: PPUSH
104885: PPUSH
104886: PPUSH
104887: PPUSH
104888: PPUSH
// if not turrets or not factories then
104889: LD_VAR 0 1
104893: NOT
104894: PUSH
104895: LD_VAR 0 2
104899: NOT
104900: OR
104901: IFFALSE 104905
// exit ;
104903: GO 105212
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104905: LD_ADDR_VAR 0 10
104909: PUSH
104910: LD_INT 5
104912: PUSH
104913: LD_INT 6
104915: PUSH
104916: EMPTY
104917: LIST
104918: LIST
104919: PUSH
104920: LD_INT 2
104922: PUSH
104923: LD_INT 4
104925: PUSH
104926: EMPTY
104927: LIST
104928: LIST
104929: PUSH
104930: LD_INT 3
104932: PUSH
104933: LD_INT 5
104935: PUSH
104936: EMPTY
104937: LIST
104938: LIST
104939: PUSH
104940: EMPTY
104941: LIST
104942: LIST
104943: LIST
104944: PUSH
104945: LD_INT 24
104947: PUSH
104948: LD_INT 25
104950: PUSH
104951: EMPTY
104952: LIST
104953: LIST
104954: PUSH
104955: LD_INT 23
104957: PUSH
104958: LD_INT 27
104960: PUSH
104961: EMPTY
104962: LIST
104963: LIST
104964: PUSH
104965: EMPTY
104966: LIST
104967: LIST
104968: PUSH
104969: LD_INT 42
104971: PUSH
104972: LD_INT 43
104974: PUSH
104975: EMPTY
104976: LIST
104977: LIST
104978: PUSH
104979: LD_INT 44
104981: PUSH
104982: LD_INT 46
104984: PUSH
104985: EMPTY
104986: LIST
104987: LIST
104988: PUSH
104989: LD_INT 45
104991: PUSH
104992: LD_INT 47
104994: PUSH
104995: EMPTY
104996: LIST
104997: LIST
104998: PUSH
104999: EMPTY
105000: LIST
105001: LIST
105002: LIST
105003: PUSH
105004: EMPTY
105005: LIST
105006: LIST
105007: LIST
105008: ST_TO_ADDR
// result := [ ] ;
105009: LD_ADDR_VAR 0 3
105013: PUSH
105014: EMPTY
105015: ST_TO_ADDR
// for i in turrets do
105016: LD_ADDR_VAR 0 4
105020: PUSH
105021: LD_VAR 0 1
105025: PUSH
105026: FOR_IN
105027: IFFALSE 105210
// begin nat := GetNation ( i ) ;
105029: LD_ADDR_VAR 0 7
105033: PUSH
105034: LD_VAR 0 4
105038: PPUSH
105039: CALL_OW 248
105043: ST_TO_ADDR
// weapon := 0 ;
105044: LD_ADDR_VAR 0 8
105048: PUSH
105049: LD_INT 0
105051: ST_TO_ADDR
// if not nat then
105052: LD_VAR 0 7
105056: NOT
105057: IFFALSE 105061
// continue ;
105059: GO 105026
// for j in list [ nat ] do
105061: LD_ADDR_VAR 0 5
105065: PUSH
105066: LD_VAR 0 10
105070: PUSH
105071: LD_VAR 0 7
105075: ARRAY
105076: PUSH
105077: FOR_IN
105078: IFFALSE 105119
// if GetBWeapon ( i ) = j [ 1 ] then
105080: LD_VAR 0 4
105084: PPUSH
105085: CALL_OW 269
105089: PUSH
105090: LD_VAR 0 5
105094: PUSH
105095: LD_INT 1
105097: ARRAY
105098: EQUAL
105099: IFFALSE 105117
// begin weapon := j [ 2 ] ;
105101: LD_ADDR_VAR 0 8
105105: PUSH
105106: LD_VAR 0 5
105110: PUSH
105111: LD_INT 2
105113: ARRAY
105114: ST_TO_ADDR
// break ;
105115: GO 105119
// end ;
105117: GO 105077
105119: POP
105120: POP
// if not weapon then
105121: LD_VAR 0 8
105125: NOT
105126: IFFALSE 105130
// continue ;
105128: GO 105026
// for k in factories do
105130: LD_ADDR_VAR 0 6
105134: PUSH
105135: LD_VAR 0 2
105139: PUSH
105140: FOR_IN
105141: IFFALSE 105206
// begin weapons := AvailableWeaponList ( k ) ;
105143: LD_ADDR_VAR 0 9
105147: PUSH
105148: LD_VAR 0 6
105152: PPUSH
105153: CALL_OW 478
105157: ST_TO_ADDR
// if not weapons then
105158: LD_VAR 0 9
105162: NOT
105163: IFFALSE 105167
// continue ;
105165: GO 105140
// if weapon in weapons then
105167: LD_VAR 0 8
105171: PUSH
105172: LD_VAR 0 9
105176: IN
105177: IFFALSE 105204
// begin result := [ i , weapon ] ;
105179: LD_ADDR_VAR 0 3
105183: PUSH
105184: LD_VAR 0 4
105188: PUSH
105189: LD_VAR 0 8
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: ST_TO_ADDR
// exit ;
105198: POP
105199: POP
105200: POP
105201: POP
105202: GO 105212
// end ; end ;
105204: GO 105140
105206: POP
105207: POP
// end ;
105208: GO 105026
105210: POP
105211: POP
// end ;
105212: LD_VAR 0 3
105216: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105217: LD_INT 0
105219: PPUSH
// if not side or side > 8 then
105220: LD_VAR 0 3
105224: NOT
105225: PUSH
105226: LD_VAR 0 3
105230: PUSH
105231: LD_INT 8
105233: GREATER
105234: OR
105235: IFFALSE 105239
// exit ;
105237: GO 105298
// if not range then
105239: LD_VAR 0 4
105243: NOT
105244: IFFALSE 105255
// range := - 12 ;
105246: LD_ADDR_VAR 0 4
105250: PUSH
105251: LD_INT 12
105253: NEG
105254: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105255: LD_VAR 0 1
105259: PPUSH
105260: LD_VAR 0 2
105264: PPUSH
105265: LD_VAR 0 3
105269: PPUSH
105270: LD_VAR 0 4
105274: PPUSH
105275: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105279: LD_VAR 0 1
105283: PPUSH
105284: LD_VAR 0 2
105288: PPUSH
105289: LD_VAR 0 3
105293: PPUSH
105294: CALL_OW 331
// end ;
105298: LD_VAR 0 5
105302: RET
// export function Video ( mode ) ; begin
105303: LD_INT 0
105305: PPUSH
// ingame_video = mode ;
105306: LD_ADDR_OWVAR 52
105310: PUSH
105311: LD_VAR 0 1
105315: ST_TO_ADDR
// interface_hidden = mode ;
105316: LD_ADDR_OWVAR 54
105320: PUSH
105321: LD_VAR 0 1
105325: ST_TO_ADDR
// end ;
105326: LD_VAR 0 2
105330: RET
// export function Join ( array , element ) ; begin
105331: LD_INT 0
105333: PPUSH
// result := array ^ element ;
105334: LD_ADDR_VAR 0 3
105338: PUSH
105339: LD_VAR 0 1
105343: PUSH
105344: LD_VAR 0 2
105348: ADD
105349: ST_TO_ADDR
// end ;
105350: LD_VAR 0 3
105354: RET
// export function JoinUnion ( array , element ) ; begin
105355: LD_INT 0
105357: PPUSH
// result := array union element ;
105358: LD_ADDR_VAR 0 3
105362: PUSH
105363: LD_VAR 0 1
105367: PUSH
105368: LD_VAR 0 2
105372: UNION
105373: ST_TO_ADDR
// end ;
105374: LD_VAR 0 3
105378: RET
// export function GetBehemoths ( side ) ; begin
105379: LD_INT 0
105381: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
105382: LD_ADDR_VAR 0 2
105386: PUSH
105387: LD_INT 22
105389: PUSH
105390: LD_VAR 0 1
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: PUSH
105399: LD_INT 31
105401: PUSH
105402: LD_INT 25
105404: PUSH
105405: EMPTY
105406: LIST
105407: LIST
105408: PUSH
105409: EMPTY
105410: LIST
105411: LIST
105412: PPUSH
105413: CALL_OW 69
105417: ST_TO_ADDR
// end ;
105418: LD_VAR 0 2
105422: RET
// export function Shuffle ( array ) ; var i , index ; begin
105423: LD_INT 0
105425: PPUSH
105426: PPUSH
105427: PPUSH
// result := [ ] ;
105428: LD_ADDR_VAR 0 2
105432: PUSH
105433: EMPTY
105434: ST_TO_ADDR
// if not array then
105435: LD_VAR 0 1
105439: NOT
105440: IFFALSE 105444
// exit ;
105442: GO 105543
// Randomize ;
105444: CALL_OW 10
// for i = array downto 1 do
105448: LD_ADDR_VAR 0 3
105452: PUSH
105453: DOUBLE
105454: LD_VAR 0 1
105458: INC
105459: ST_TO_ADDR
105460: LD_INT 1
105462: PUSH
105463: FOR_DOWNTO
105464: IFFALSE 105541
// begin index := rand ( 1 , array ) ;
105466: LD_ADDR_VAR 0 4
105470: PUSH
105471: LD_INT 1
105473: PPUSH
105474: LD_VAR 0 1
105478: PPUSH
105479: CALL_OW 12
105483: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105484: LD_ADDR_VAR 0 2
105488: PUSH
105489: LD_VAR 0 2
105493: PPUSH
105494: LD_VAR 0 2
105498: PUSH
105499: LD_INT 1
105501: PLUS
105502: PPUSH
105503: LD_VAR 0 1
105507: PUSH
105508: LD_VAR 0 4
105512: ARRAY
105513: PPUSH
105514: CALL_OW 2
105518: ST_TO_ADDR
// array := Delete ( array , index ) ;
105519: LD_ADDR_VAR 0 1
105523: PUSH
105524: LD_VAR 0 1
105528: PPUSH
105529: LD_VAR 0 4
105533: PPUSH
105534: CALL_OW 3
105538: ST_TO_ADDR
// end ;
105539: GO 105463
105541: POP
105542: POP
// end ; end_of_file end_of_file end_of_file
105543: LD_VAR 0 2
105547: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
105548: LD_INT 0
105550: PPUSH
105551: PPUSH
105552: PPUSH
105553: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105554: LD_VAR 0 1
105558: PPUSH
105559: CALL_OW 264
105563: PUSH
105564: LD_EXP 96
105568: EQUAL
105569: IFFALSE 105641
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105571: LD_INT 68
105573: PPUSH
105574: LD_VAR 0 1
105578: PPUSH
105579: CALL_OW 255
105583: PPUSH
105584: CALL_OW 321
105588: PUSH
105589: LD_INT 2
105591: EQUAL
105592: IFFALSE 105604
// eff := 70 else
105594: LD_ADDR_VAR 0 6
105598: PUSH
105599: LD_INT 70
105601: ST_TO_ADDR
105602: GO 105612
// eff := 30 ;
105604: LD_ADDR_VAR 0 6
105608: PUSH
105609: LD_INT 30
105611: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105612: LD_VAR 0 1
105616: PPUSH
105617: CALL_OW 250
105621: PPUSH
105622: LD_VAR 0 1
105626: PPUSH
105627: CALL_OW 251
105631: PPUSH
105632: LD_VAR 0 6
105636: PPUSH
105637: CALL_OW 495
// end ; end ;
105641: LD_VAR 0 4
105645: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
105646: LD_INT 0
105648: PPUSH
105649: PPUSH
105650: PPUSH
105651: PPUSH
105652: PPUSH
105653: PPUSH
// if cmd = 124 then
105654: LD_VAR 0 1
105658: PUSH
105659: LD_INT 124
105661: EQUAL
105662: IFFALSE 105868
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
105664: LD_ADDR_VAR 0 5
105668: PUSH
105669: LD_INT 2
105671: PUSH
105672: LD_INT 34
105674: PUSH
105675: LD_INT 53
105677: PUSH
105678: EMPTY
105679: LIST
105680: LIST
105681: PUSH
105682: LD_INT 34
105684: PUSH
105685: LD_INT 14
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: PUSH
105692: EMPTY
105693: LIST
105694: LIST
105695: LIST
105696: PPUSH
105697: CALL_OW 69
105701: ST_TO_ADDR
// if not tmp then
105702: LD_VAR 0 5
105706: NOT
105707: IFFALSE 105711
// exit ;
105709: GO 105868
// for i in tmp do
105711: LD_ADDR_VAR 0 3
105715: PUSH
105716: LD_VAR 0 5
105720: PUSH
105721: FOR_IN
105722: IFFALSE 105866
// begin taskList := GetTaskList ( i ) ;
105724: LD_ADDR_VAR 0 6
105728: PUSH
105729: LD_VAR 0 3
105733: PPUSH
105734: CALL_OW 437
105738: ST_TO_ADDR
// if not taskList then
105739: LD_VAR 0 6
105743: NOT
105744: IFFALSE 105748
// continue ;
105746: GO 105721
// for j = 1 to taskList do
105748: LD_ADDR_VAR 0 4
105752: PUSH
105753: DOUBLE
105754: LD_INT 1
105756: DEC
105757: ST_TO_ADDR
105758: LD_VAR 0 6
105762: PUSH
105763: FOR_TO
105764: IFFALSE 105862
// if taskList [ j ] [ 1 ] = | then
105766: LD_VAR 0 6
105770: PUSH
105771: LD_VAR 0 4
105775: ARRAY
105776: PUSH
105777: LD_INT 1
105779: ARRAY
105780: PUSH
105781: LD_STRING |
105783: EQUAL
105784: IFFALSE 105860
// begin _taskList := Delete ( taskList , 1 ) ;
105786: LD_ADDR_VAR 0 7
105790: PUSH
105791: LD_VAR 0 6
105795: PPUSH
105796: LD_INT 1
105798: PPUSH
105799: CALL_OW 3
105803: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
105804: LD_VAR 0 3
105808: PPUSH
105809: LD_VAR 0 7
105813: PPUSH
105814: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
105818: LD_VAR 0 3
105822: PPUSH
105823: LD_VAR 0 6
105827: PUSH
105828: LD_VAR 0 4
105832: ARRAY
105833: PUSH
105834: LD_INT 2
105836: ARRAY
105837: PPUSH
105838: LD_VAR 0 6
105842: PUSH
105843: LD_VAR 0 4
105847: ARRAY
105848: PUSH
105849: LD_INT 3
105851: ARRAY
105852: PPUSH
105853: LD_INT 8
105855: PPUSH
105856: CALL 105873 0 4
// end ;
105860: GO 105763
105862: POP
105863: POP
// end ;
105864: GO 105721
105866: POP
105867: POP
// end ; end ;
105868: LD_VAR 0 2
105872: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105873: LD_INT 0
105875: PPUSH
105876: PPUSH
105877: PPUSH
105878: PPUSH
105879: PPUSH
105880: PPUSH
105881: PPUSH
105882: PPUSH
105883: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
105884: LD_VAR 0 1
105888: NOT
105889: PUSH
105890: LD_VAR 0 2
105894: PPUSH
105895: LD_VAR 0 3
105899: PPUSH
105900: CALL_OW 488
105904: NOT
105905: OR
105906: PUSH
105907: LD_VAR 0 4
105911: NOT
105912: OR
105913: IFFALSE 105917
// exit ;
105915: GO 106257
// list := [ ] ;
105917: LD_ADDR_VAR 0 13
105921: PUSH
105922: EMPTY
105923: ST_TO_ADDR
// if x - r < 0 then
105924: LD_VAR 0 2
105928: PUSH
105929: LD_VAR 0 4
105933: MINUS
105934: PUSH
105935: LD_INT 0
105937: LESS
105938: IFFALSE 105950
// min_x := 0 else
105940: LD_ADDR_VAR 0 7
105944: PUSH
105945: LD_INT 0
105947: ST_TO_ADDR
105948: GO 105966
// min_x := x - r ;
105950: LD_ADDR_VAR 0 7
105954: PUSH
105955: LD_VAR 0 2
105959: PUSH
105960: LD_VAR 0 4
105964: MINUS
105965: ST_TO_ADDR
// if y - r < 0 then
105966: LD_VAR 0 3
105970: PUSH
105971: LD_VAR 0 4
105975: MINUS
105976: PUSH
105977: LD_INT 0
105979: LESS
105980: IFFALSE 105992
// min_y := 0 else
105982: LD_ADDR_VAR 0 8
105986: PUSH
105987: LD_INT 0
105989: ST_TO_ADDR
105990: GO 106008
// min_y := y - r ;
105992: LD_ADDR_VAR 0 8
105996: PUSH
105997: LD_VAR 0 3
106001: PUSH
106002: LD_VAR 0 4
106006: MINUS
106007: ST_TO_ADDR
// max_x := x + r ;
106008: LD_ADDR_VAR 0 9
106012: PUSH
106013: LD_VAR 0 2
106017: PUSH
106018: LD_VAR 0 4
106022: PLUS
106023: ST_TO_ADDR
// max_y := y + r ;
106024: LD_ADDR_VAR 0 10
106028: PUSH
106029: LD_VAR 0 3
106033: PUSH
106034: LD_VAR 0 4
106038: PLUS
106039: ST_TO_ADDR
// for _x = min_x to max_x do
106040: LD_ADDR_VAR 0 11
106044: PUSH
106045: DOUBLE
106046: LD_VAR 0 7
106050: DEC
106051: ST_TO_ADDR
106052: LD_VAR 0 9
106056: PUSH
106057: FOR_TO
106058: IFFALSE 106175
// for _y = min_y to max_y do
106060: LD_ADDR_VAR 0 12
106064: PUSH
106065: DOUBLE
106066: LD_VAR 0 8
106070: DEC
106071: ST_TO_ADDR
106072: LD_VAR 0 10
106076: PUSH
106077: FOR_TO
106078: IFFALSE 106171
// begin if not ValidHex ( _x , _y ) then
106080: LD_VAR 0 11
106084: PPUSH
106085: LD_VAR 0 12
106089: PPUSH
106090: CALL_OW 488
106094: NOT
106095: IFFALSE 106099
// continue ;
106097: GO 106077
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106099: LD_VAR 0 11
106103: PPUSH
106104: LD_VAR 0 12
106108: PPUSH
106109: CALL_OW 351
106113: PUSH
106114: LD_VAR 0 11
106118: PPUSH
106119: LD_VAR 0 12
106123: PPUSH
106124: CALL_OW 554
106128: AND
106129: IFFALSE 106169
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106131: LD_ADDR_VAR 0 13
106135: PUSH
106136: LD_VAR 0 13
106140: PPUSH
106141: LD_VAR 0 13
106145: PUSH
106146: LD_INT 1
106148: PLUS
106149: PPUSH
106150: LD_VAR 0 11
106154: PUSH
106155: LD_VAR 0 12
106159: PUSH
106160: EMPTY
106161: LIST
106162: LIST
106163: PPUSH
106164: CALL_OW 2
106168: ST_TO_ADDR
// end ;
106169: GO 106077
106171: POP
106172: POP
106173: GO 106057
106175: POP
106176: POP
// if not list then
106177: LD_VAR 0 13
106181: NOT
106182: IFFALSE 106186
// exit ;
106184: GO 106257
// for i in list do
106186: LD_ADDR_VAR 0 6
106190: PUSH
106191: LD_VAR 0 13
106195: PUSH
106196: FOR_IN
106197: IFFALSE 106255
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106199: LD_VAR 0 1
106203: PPUSH
106204: LD_STRING M
106206: PUSH
106207: LD_VAR 0 6
106211: PUSH
106212: LD_INT 1
106214: ARRAY
106215: PUSH
106216: LD_VAR 0 6
106220: PUSH
106221: LD_INT 2
106223: ARRAY
106224: PUSH
106225: LD_INT 0
106227: PUSH
106228: LD_INT 0
106230: PUSH
106231: LD_INT 0
106233: PUSH
106234: LD_INT 0
106236: PUSH
106237: EMPTY
106238: LIST
106239: LIST
106240: LIST
106241: LIST
106242: LIST
106243: LIST
106244: LIST
106245: PUSH
106246: EMPTY
106247: LIST
106248: PPUSH
106249: CALL_OW 447
106253: GO 106196
106255: POP
106256: POP
// end ;
106257: LD_VAR 0 5
106261: RET
