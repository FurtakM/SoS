// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38734 0 0
// InitNature ;
  19: CALL 38602 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12514 0 0
// PrepareRussian ;
  40: CALL 7396 0 0
// PrepareLegion ;
  44: CALL 4478 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17377 0 0
// MC_Start ( ) ;
  60: CALL 40914 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 125
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 126
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63710 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63803 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63153 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62968 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63710 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63803 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62968 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63153 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63583 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62631 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63710 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63803 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 130
 971: PUSH
 972: LD_EXP 130
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62968 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63710 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63803 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62860 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64121 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63292 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63583 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63583 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63915 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62968 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63534 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69442 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74282 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74282 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74282 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74282 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74282 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69442 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69442 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69442 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69442 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 69442 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 69442 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 69442 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 69442 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 69442 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 69442 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 69442 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 69442 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 69442 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 69442 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 69442 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// extraSquad := [ ] ;
3222: LD_ADDR_EXP 62
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// tmp := [ ] ;
3229: LD_ADDR_VAR 0 5
3233: PUSH
3234: EMPTY
3235: ST_TO_ADDR
// if JMMGirl <> 2 then
3236: LD_EXP 7
3240: PUSH
3241: LD_INT 2
3243: NONEQUAL
3244: IFFALSE 3268
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 43
3250: PUSH
3251: LD_STRING Lisa
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 69442 0 3
3267: ST_TO_ADDR
// if Lisa then
3268: LD_EXP 43
3272: IFFALSE 3290
// tmp := tmp ^ Lisa ;
3274: LD_ADDR_VAR 0 5
3278: PUSH
3279: LD_VAR 0 5
3283: PUSH
3284: LD_EXP 43
3288: ADD
3289: ST_TO_ADDR
// if JMMGirl < 3 then
3290: LD_EXP 7
3294: PUSH
3295: LD_INT 3
3297: LESS
3298: IFFALSE 3329
// begin Connie := NewCharacter ( Coonie ) ;
3300: LD_ADDR_EXP 55
3304: PUSH
3305: LD_STRING Coonie
3307: PPUSH
3308: CALL_OW 25
3312: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3313: LD_ADDR_VAR 0 5
3317: PUSH
3318: LD_VAR 0 5
3322: PUSH
3323: LD_EXP 55
3327: ADD
3328: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3329: LD_ADDR_EXP 44
3333: PUSH
3334: LD_STRING Donaldson
3336: PPUSH
3337: LD_EXP 1
3341: NOT
3342: PPUSH
3343: LD_STRING 13s_
3345: PPUSH
3346: CALL 69442 0 3
3350: ST_TO_ADDR
// if Donaldson then
3351: LD_EXP 44
3355: IFFALSE 3373
// tmp := tmp ^ Donaldson ;
3357: LD_ADDR_VAR 0 5
3361: PUSH
3362: LD_VAR 0 5
3366: PUSH
3367: LD_EXP 44
3371: ADD
3372: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3373: LD_ADDR_EXP 45
3377: PUSH
3378: LD_STRING Bobby
3380: PPUSH
3381: LD_EXP 1
3385: NOT
3386: PPUSH
3387: LD_STRING 13s_
3389: PPUSH
3390: CALL 69442 0 3
3394: ST_TO_ADDR
// if Bobby then
3395: LD_EXP 45
3399: IFFALSE 3417
// tmp := tmp ^ Bobby ;
3401: LD_ADDR_VAR 0 5
3405: PUSH
3406: LD_VAR 0 5
3410: PUSH
3411: LD_EXP 45
3415: ADD
3416: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3417: LD_ADDR_EXP 46
3421: PUSH
3422: LD_STRING Cyrus
3424: PPUSH
3425: LD_EXP 1
3429: NOT
3430: PPUSH
3431: LD_STRING 13s_
3433: PPUSH
3434: CALL 69442 0 3
3438: ST_TO_ADDR
// if Cyrus then
3439: LD_EXP 46
3443: IFFALSE 3461
// tmp := tmp ^ Cyrus ;
3445: LD_ADDR_VAR 0 5
3449: PUSH
3450: LD_VAR 0 5
3454: PUSH
3455: LD_EXP 46
3459: ADD
3460: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3461: LD_ADDR_EXP 47
3465: PUSH
3466: LD_STRING Denis
3468: PPUSH
3469: LD_EXP 1
3473: NOT
3474: PPUSH
3475: LD_STRING 13s_
3477: PPUSH
3478: CALL 69442 0 3
3482: ST_TO_ADDR
// if not Denis then
3483: LD_EXP 47
3487: NOT
3488: IFFALSE 3512
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3490: LD_ADDR_EXP 47
3494: PUSH
3495: LD_STRING Denis
3497: PPUSH
3498: LD_EXP 1
3502: NOT
3503: PPUSH
3504: LD_STRING 13f_
3506: PPUSH
3507: CALL 69442 0 3
3511: ST_TO_ADDR
// if Denis then
3512: LD_EXP 47
3516: IFFALSE 3534
// tmp := tmp ^ Denis ;
3518: LD_ADDR_VAR 0 5
3522: PUSH
3523: LD_VAR 0 5
3527: PUSH
3528: LD_EXP 47
3532: ADD
3533: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3534: LD_ADDR_EXP 48
3538: PUSH
3539: LD_STRING Brown
3541: PPUSH
3542: LD_EXP 1
3546: NOT
3547: PPUSH
3548: LD_STRING 13s_
3550: PPUSH
3551: CALL 69442 0 3
3555: ST_TO_ADDR
// if Brown then
3556: LD_EXP 48
3560: IFFALSE 3578
// tmp := tmp ^ Brown ;
3562: LD_ADDR_VAR 0 5
3566: PUSH
3567: LD_VAR 0 5
3571: PUSH
3572: LD_EXP 48
3576: ADD
3577: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3578: LD_ADDR_EXP 49
3582: PUSH
3583: LD_STRING Gladstone
3585: PPUSH
3586: LD_EXP 1
3590: NOT
3591: PPUSH
3592: LD_STRING 13s_
3594: PPUSH
3595: CALL 69442 0 3
3599: ST_TO_ADDR
// if Gladstone then
3600: LD_EXP 49
3604: IFFALSE 3622
// tmp := tmp ^ Gladstone ;
3606: LD_ADDR_VAR 0 5
3610: PUSH
3611: LD_VAR 0 5
3615: PUSH
3616: LD_EXP 49
3620: ADD
3621: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3622: LD_ADDR_EXP 50
3626: PUSH
3627: LD_STRING Houten
3629: PPUSH
3630: LD_EXP 1
3634: NOT
3635: PPUSH
3636: LD_STRING 13s_
3638: PPUSH
3639: CALL 69442 0 3
3643: ST_TO_ADDR
// if Houten then
3644: LD_EXP 50
3648: IFFALSE 3666
// tmp := tmp ^ Houten ;
3650: LD_ADDR_VAR 0 5
3654: PUSH
3655: LD_VAR 0 5
3659: PUSH
3660: LD_EXP 50
3664: ADD
3665: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3666: LD_ADDR_EXP 51
3670: PUSH
3671: LD_STRING Cornel
3673: PPUSH
3674: LD_EXP 1
3678: NOT
3679: PPUSH
3680: LD_STRING 13s_
3682: PPUSH
3683: CALL 69442 0 3
3687: ST_TO_ADDR
// if Cornel then
3688: LD_EXP 51
3692: IFFALSE 3710
// tmp := tmp ^ Cornel ;
3694: LD_ADDR_VAR 0 5
3698: PUSH
3699: LD_VAR 0 5
3703: PUSH
3704: LD_EXP 51
3708: ADD
3709: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3710: LD_ADDR_EXP 52
3714: PUSH
3715: LD_STRING Gary
3717: PPUSH
3718: LD_EXP 1
3722: NOT
3723: PPUSH
3724: LD_STRING 13s_
3726: PPUSH
3727: CALL 69442 0 3
3731: ST_TO_ADDR
// if Gary then
3732: LD_EXP 52
3736: IFFALSE 3754
// tmp := tmp ^ Gary ;
3738: LD_ADDR_VAR 0 5
3742: PUSH
3743: LD_VAR 0 5
3747: PUSH
3748: LD_EXP 52
3752: ADD
3753: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3754: LD_ADDR_EXP 53
3758: PUSH
3759: LD_STRING Frank
3761: PPUSH
3762: LD_EXP 1
3766: NOT
3767: PPUSH
3768: LD_STRING 13s_
3770: PPUSH
3771: CALL 69442 0 3
3775: ST_TO_ADDR
// if Frank then
3776: LD_EXP 53
3780: IFFALSE 3798
// tmp := tmp ^ Frank ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_VAR 0 5
3791: PUSH
3792: LD_EXP 53
3796: ADD
3797: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3798: LD_ADDR_EXP 54
3802: PUSH
3803: LD_STRING Kikuchi
3805: PPUSH
3806: LD_EXP 1
3810: NOT
3811: PPUSH
3812: LD_STRING 13s_
3814: PPUSH
3815: CALL 69442 0 3
3819: ST_TO_ADDR
// if Kikuchi then
3820: LD_EXP 54
3824: IFFALSE 3842
// tmp := tmp ^ Kikuchi ;
3826: LD_ADDR_VAR 0 5
3830: PUSH
3831: LD_VAR 0 5
3835: PUSH
3836: LD_EXP 54
3840: ADD
3841: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3842: LD_ADDR_EXP 57
3846: PUSH
3847: LD_STRING Mike
3849: PPUSH
3850: LD_EXP 1
3854: NOT
3855: PPUSH
3856: LD_STRING 10c_
3858: PPUSH
3859: CALL 69442 0 3
3863: ST_TO_ADDR
// if Mike then
3864: LD_EXP 57
3868: IFFALSE 3891
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3870: LD_EXP 57
3874: PPUSH
3875: LD_INT 61
3877: PPUSH
3878: LD_INT 89
3880: PPUSH
3881: LD_INT 8
3883: PPUSH
3884: LD_INT 0
3886: PPUSH
3887: CALL_OW 50
// vip := tmp ;
3891: LD_ADDR_EXP 61
3895: PUSH
3896: LD_VAR 0 5
3900: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3901: LD_ADDR_VAR 0 5
3905: PUSH
3906: LD_VAR 0 5
3910: PUSH
3911: LD_STRING 13s_others
3913: PPUSH
3914: CALL_OW 31
3918: UNION
3919: ST_TO_ADDR
// if tmp < 18 then
3920: LD_VAR 0 5
3924: PUSH
3925: LD_INT 18
3927: LESS
3928: IFFALSE 4033
// begin InitHC_All ( ) ;
3930: CALL_OW 584
// for i = 1 to 18 - tmp do
3934: LD_ADDR_VAR 0 2
3938: PUSH
3939: DOUBLE
3940: LD_INT 1
3942: DEC
3943: ST_TO_ADDR
3944: LD_INT 18
3946: PUSH
3947: LD_VAR 0 5
3951: MINUS
3952: PUSH
3953: FOR_TO
3954: IFFALSE 4031
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3956: LD_INT 1
3958: PPUSH
3959: LD_VAR 0 2
3963: PUSH
3964: LD_INT 4
3966: MOD
3967: PUSH
3968: LD_INT 1
3970: PLUS
3971: PPUSH
3972: LD_INT 4
3974: PPUSH
3975: CALL_OW 380
// un := CreateHuman ;
3979: LD_ADDR_VAR 0 10
3983: PUSH
3984: CALL_OW 44
3988: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3989: LD_ADDR_VAR 0 5
3993: PUSH
3994: LD_VAR 0 5
3998: PPUSH
3999: LD_VAR 0 10
4003: PPUSH
4004: CALL 107144 0 2
4008: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4009: LD_ADDR_EXP 62
4013: PUSH
4014: LD_EXP 62
4018: PPUSH
4019: LD_VAR 0 10
4023: PPUSH
4024: CALL 107144 0 2
4028: ST_TO_ADDR
// end ;
4029: GO 3953
4031: POP
4032: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4033: LD_ADDR_VAR 0 6
4037: PUSH
4038: LD_INT 53
4040: PPUSH
4041: LD_INT 94
4043: PPUSH
4044: CALL_OW 428
4048: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4049: LD_ADDR_VAR 0 7
4053: PUSH
4054: LD_INT 56
4056: PPUSH
4057: LD_INT 101
4059: PPUSH
4060: CALL_OW 428
4064: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4065: LD_ADDR_VAR 0 8
4069: PUSH
4070: LD_INT 67
4072: PPUSH
4073: LD_INT 101
4075: PPUSH
4076: CALL_OW 428
4080: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4081: LD_ADDR_VAR 0 9
4085: PUSH
4086: LD_INT 54
4088: PPUSH
4089: LD_INT 85
4091: PPUSH
4092: CALL_OW 428
4096: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4097: LD_ADDR_VAR 0 3
4101: PUSH
4102: LD_VAR 0 8
4106: PUSH
4107: LD_VAR 0 6
4111: PUSH
4112: LD_VAR 0 9
4116: PUSH
4117: LD_VAR 0 7
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: LIST
4126: LIST
4127: ST_TO_ADDR
// for i in tmp do
4128: LD_ADDR_VAR 0 2
4132: PUSH
4133: LD_VAR 0 5
4137: PUSH
4138: FOR_IN
4139: IFFALSE 4334
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4141: LD_VAR 0 3
4145: PUSH
4146: LD_INT 1
4148: ARRAY
4149: PPUSH
4150: CALL_OW 266
4154: PUSH
4155: LD_INT 4
4157: DOUBLE
4158: EQUAL
4159: IFTRUE 4163
4161: GO 4178
4163: POP
// SetClass ( i , class_soldier ) ; b_depot :
4164: LD_VAR 0 2
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 336
4176: GO 4248
4178: LD_INT 0
4180: DOUBLE
4181: EQUAL
4182: IFTRUE 4186
4184: GO 4201
4186: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4187: LD_VAR 0 2
4191: PPUSH
4192: LD_INT 2
4194: PPUSH
4195: CALL_OW 336
4199: GO 4248
4201: LD_INT 2
4203: DOUBLE
4204: EQUAL
4205: IFTRUE 4209
4207: GO 4224
4209: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4210: LD_VAR 0 2
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 336
4222: GO 4248
4224: LD_INT 6
4226: DOUBLE
4227: EQUAL
4228: IFTRUE 4232
4230: GO 4247
4232: POP
// SetClass ( i , class_scientistic ) ; end ;
4233: LD_VAR 0 2
4237: PPUSH
4238: LD_INT 4
4240: PPUSH
4241: CALL_OW 336
4245: GO 4248
4247: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4248: LD_VAR 0 3
4252: PUSH
4253: LD_INT 1
4255: ARRAY
4256: PPUSH
4257: CALL_OW 313
4261: PUSH
4262: LD_INT 6
4264: EQUAL
4265: IFFALSE 4285
// b := Delete ( b , 1 ) ;
4267: LD_ADDR_VAR 0 3
4271: PUSH
4272: LD_VAR 0 3
4276: PPUSH
4277: LD_INT 1
4279: PPUSH
4280: CALL_OW 3
4284: ST_TO_ADDR
// if b then
4285: LD_VAR 0 3
4289: IFFALSE 4311
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4291: LD_VAR 0 2
4295: PPUSH
4296: LD_VAR 0 3
4300: PUSH
4301: LD_INT 1
4303: ARRAY
4304: PPUSH
4305: CALL_OW 52
4309: GO 4332
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4311: LD_VAR 0 2
4315: PPUSH
4316: LD_INT 61
4318: PPUSH
4319: LD_INT 89
4321: PPUSH
4322: LD_INT 8
4324: PPUSH
4325: LD_INT 0
4327: PPUSH
4328: CALL_OW 50
// end ;
4332: GO 4138
4334: POP
4335: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4336: LD_INT 2
4338: PPUSH
4339: LD_INT 1
4341: PPUSH
4342: LD_INT 1
4344: PPUSH
4345: LD_INT 12
4347: PPUSH
4348: LD_INT 100
4350: PPUSH
4351: CALL 74282 0 5
// veh := CreateVehicle ;
4355: LD_ADDR_VAR 0 4
4359: PUSH
4360: CALL_OW 45
4364: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4365: LD_VAR 0 4
4369: PPUSH
4370: LD_INT 4
4372: PPUSH
4373: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4377: LD_VAR 0 4
4381: PPUSH
4382: LD_INT 49
4384: PPUSH
4385: LD_INT 88
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4395: LD_VAR 0 4
4399: PPUSH
4400: LD_INT 1
4402: PPUSH
4403: LD_INT 100
4405: PPUSH
4406: CALL_OW 290
// uc_side := 0 ;
4410: LD_ADDR_OWVAR 20
4414: PUSH
4415: LD_INT 0
4417: ST_TO_ADDR
// uc_nation := 0 ;
4418: LD_ADDR_OWVAR 21
4422: PUSH
4423: LD_INT 0
4425: ST_TO_ADDR
// for i := 1 to 3 do
4426: LD_ADDR_VAR 0 2
4430: PUSH
4431: DOUBLE
4432: LD_INT 1
4434: DEC
4435: ST_TO_ADDR
4436: LD_INT 3
4438: PUSH
4439: FOR_TO
4440: IFFALSE 4471
// begin InitHc ;
4442: CALL_OW 19
// hc_class := class_apeman ;
4446: LD_ADDR_OWVAR 28
4450: PUSH
4451: LD_INT 12
4453: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4454: CALL_OW 44
4458: PPUSH
4459: LD_INT 13
4461: PPUSH
4462: LD_INT 0
4464: PPUSH
4465: CALL_OW 49
// end ;
4469: GO 4439
4471: POP
4472: POP
// end ; end_of_file
4473: LD_VAR 0 1
4477: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
// side := 8 ;
4485: LD_ADDR_VAR 0 3
4489: PUSH
4490: LD_INT 8
4492: ST_TO_ADDR
// uc_side := side ;
4493: LD_ADDR_OWVAR 20
4497: PUSH
4498: LD_VAR 0 3
4502: ST_TO_ADDR
// uc_nation := 2 ;
4503: LD_ADDR_OWVAR 21
4507: PUSH
4508: LD_INT 2
4510: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4511: LD_ADDR_VAR 0 2
4515: PUSH
4516: LD_INT 22
4518: PUSH
4519: LD_VAR 0 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 3
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: PUSH
4547: FOR_IN
4548: IFFALSE 4564
// SetBLevel ( i , 10 ) ;
4550: LD_VAR 0 2
4554: PPUSH
4555: LD_INT 10
4557: PPUSH
4558: CALL_OW 241
4562: GO 4547
4564: POP
4565: POP
// if KurtStatus then
4566: LD_EXP 3
4570: IFFALSE 4593
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4572: LD_ADDR_EXP 63
4576: PUSH
4577: LD_STRING Kurt
4579: PPUSH
4580: LD_INT 0
4582: PPUSH
4583: LD_STRING 
4585: PPUSH
4586: CALL 69442 0 3
4590: ST_TO_ADDR
4591: GO 4615
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4593: LD_ADDR_EXP 63
4597: PUSH
4598: LD_STRING AltKurt
4600: PPUSH
4601: LD_EXP 1
4605: NOT
4606: PPUSH
4607: LD_STRING 
4609: PPUSH
4610: CALL 69442 0 3
4614: ST_TO_ADDR
// if not Kurt then
4615: LD_EXP 63
4619: NOT
4620: IFFALSE 4646
// begin InitHc ;
4622: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4626: LD_INT 1
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 381
// Kurt := CreateHuman ;
4636: LD_ADDR_EXP 63
4640: PUSH
4641: CALL_OW 44
4645: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4646: LD_EXP 63
4650: PPUSH
4651: LD_INT 324
4653: PPUSH
4654: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4658: LD_ADDR_EXP 64
4662: PUSH
4663: LD_STRING Kozlov
4665: PPUSH
4666: LD_INT 0
4668: PPUSH
4669: LD_STRING 
4671: PPUSH
4672: CALL 69442 0 3
4676: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4677: LD_EXP 64
4681: PPUSH
4682: LD_INT 22
4684: PUSH
4685: LD_INT 8
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 23
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 30
4704: PUSH
4705: LD_INT 8
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_INT 1
4724: ARRAY
4725: PPUSH
4726: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4730: LD_EXP 64
4734: PPUSH
4735: LD_INT 3
4737: PPUSH
4738: LD_INT 10
4740: PPUSH
4741: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4745: LD_EXP 64
4749: PPUSH
4750: LD_INT 4
4752: PPUSH
4753: LD_INT 10
4755: PPUSH
4756: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4760: LD_ADDR_VAR 0 5
4764: PUSH
4765: LD_INT 22
4767: PUSH
4768: LD_VAR 0 3
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: PUSH
4777: LD_INT 30
4779: PUSH
4780: LD_INT 32
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 58
4789: PUSH
4790: EMPTY
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: ST_TO_ADDR
// for i = 1 to 10 do
4803: LD_ADDR_VAR 0 2
4807: PUSH
4808: DOUBLE
4809: LD_INT 1
4811: DEC
4812: ST_TO_ADDR
4813: LD_INT 10
4815: PUSH
4816: FOR_TO
4817: IFFALSE 4889
// begin uc_nation := nation_nature ;
4819: LD_ADDR_OWVAR 21
4823: PUSH
4824: LD_INT 0
4826: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4827: LD_ADDR_OWVAR 28
4831: PUSH
4832: LD_INT 15
4834: ST_TO_ADDR
// hc_gallery :=  ;
4835: LD_ADDR_OWVAR 33
4839: PUSH
4840: LD_STRING 
4842: ST_TO_ADDR
// hc_name :=  ;
4843: LD_ADDR_OWVAR 26
4847: PUSH
4848: LD_STRING 
4850: ST_TO_ADDR
// un := CreateHuman ;
4851: LD_ADDR_VAR 0 4
4855: PUSH
4856: CALL_OW 44
4860: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4861: LD_VAR 0 4
4865: PPUSH
4866: LD_VAR 0 5
4870: PUSH
4871: LD_VAR 0 5
4875: PUSH
4876: LD_VAR 0 2
4880: MINUS
4881: ARRAY
4882: PPUSH
4883: CALL_OW 52
// end ;
4887: GO 4816
4889: POP
4890: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4891: LD_ADDR_VAR 0 5
4895: PUSH
4896: LD_STRING 12_kurt_squad
4898: PPUSH
4899: CALL_OW 31
4903: ST_TO_ADDR
// if tmp then
4904: LD_VAR 0 5
4908: IFFALSE 4942
// for i in tmp do
4910: LD_ADDR_VAR 0 2
4914: PUSH
4915: LD_VAR 0 5
4919: PUSH
4920: FOR_IN
4921: IFFALSE 4940
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4923: LD_VAR 0 2
4927: PPUSH
4928: LD_INT 5
4930: PPUSH
4931: LD_INT 0
4933: PPUSH
4934: CALL_OW 49
4938: GO 4920
4940: POP
4941: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4942: LD_INT 324
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: LD_STRING 
4950: PPUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: LD_INT 10
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PPUSH
4975: LD_INT 3000
4977: PUSH
4978: LD_INT 500
4980: PUSH
4981: LD_INT 150
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: LIST
4988: PPUSH
4989: LD_INT 16
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 6
4997: PUSH
4998: LD_INT 8
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL 78103 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5011: LD_ADDR_EXP 101
5015: PUSH
5016: LD_EXP 101
5020: PPUSH
5021: LD_INT 3
5023: PPUSH
5024: LD_INT 22
5026: PUSH
5027: LD_VAR 0 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 23
5038: PUSH
5039: LD_INT 2
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: LD_INT 21
5051: PUSH
5052: LD_INT 2
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: LIST
5067: PPUSH
5068: CALL_OW 69
5072: PUSH
5073: LD_EXP 63
5077: DIFF
5078: PPUSH
5079: CALL_OW 1
5083: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 7
5089: PPUSH
5090: CALL_OW 383
// hc_name := Ali Hadrach ;
5094: LD_ADDR_OWVAR 26
5098: PUSH
5099: LD_STRING Ali Hadrach
5101: ST_TO_ADDR
// hc_face_number := 31 ;
5102: LD_ADDR_OWVAR 34
5106: PUSH
5107: LD_INT 31
5109: ST_TO_ADDR
// Friend := CreateHuman ;
5110: LD_ADDR_EXP 65
5114: PUSH
5115: CALL_OW 44
5119: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5120: LD_INT 14
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: LD_INT 1
5128: PPUSH
5129: LD_INT 29
5131: PPUSH
5132: LD_INT 100
5134: PPUSH
5135: CALL 74282 0 5
// powellBomb := CreateVehicle ;
5139: LD_ADDR_EXP 66
5143: PUSH
5144: CALL_OW 45
5148: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5149: LD_EXP 66
5153: PPUSH
5154: LD_INT 90
5156: PPUSH
5157: LD_INT 51
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 48
// end ;
5167: LD_VAR 0 1
5171: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5172: LD_INT 0
5174: PPUSH
5175: PPUSH
5176: PPUSH
// if IsLive ( kozlov_fac ) then
5177: LD_INT 332
5179: PPUSH
5180: CALL_OW 300
5184: IFFALSE 5188
// exit ;
5186: GO 5755
// ComExitBuilding ( Kozlov ) ;
5188: LD_EXP 64
5192: PPUSH
5193: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5197: LD_EXP 64
5201: PPUSH
5202: CALL_OW 257
5206: PUSH
5207: LD_INT 2
5209: NONEQUAL
5210: IFFALSE 5245
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5212: LD_EXP 64
5216: PPUSH
5217: LD_INT 324
5219: PPUSH
5220: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5224: LD_EXP 64
5228: PPUSH
5229: LD_INT 2
5231: PPUSH
5232: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5236: LD_EXP 64
5240: PPUSH
5241: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5245: LD_EXP 64
5249: PPUSH
5250: LD_INT 2
5252: PPUSH
5253: LD_INT 93
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 3
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 30
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 23
5295: PUSH
5296: LD_INT 3
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5321: LD_ADDR_VAR 0 2
5325: PUSH
5326: LD_INT 22
5328: PUSH
5329: LD_INT 8
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: PUSH
5336: LD_INT 30
5338: PUSH
5339: LD_INT 3
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 23
5348: PUSH
5349: LD_INT 3
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: PUSH
5356: LD_INT 57
5358: PUSH
5359: EMPTY
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PPUSH
5368: CALL_OW 69
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5377: LD_INT 22
5379: PUSH
5380: LD_INT 8
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: PUSH
5387: LD_INT 23
5389: PUSH
5390: LD_INT 3
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 30
5399: PUSH
5400: LD_INT 21
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: LIST
5411: PPUSH
5412: CALL_OW 69
5416: NOT
5417: IFFALSE 5495
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5419: LD_EXP 64
5423: PPUSH
5424: LD_INT 21
5426: PPUSH
5427: LD_INT 97
5429: PPUSH
5430: LD_INT 36
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5440: LD_INT 35
5442: PPUSH
5443: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5447: LD_INT 22
5449: PUSH
5450: LD_INT 8
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PUSH
5457: LD_INT 23
5459: PUSH
5460: LD_INT 3
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PUSH
5467: LD_INT 30
5469: PUSH
5470: LD_INT 21
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 57
5479: PUSH
5480: EMPTY
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: PPUSH
5489: CALL_OW 69
5493: IFFALSE 5440
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5495: LD_INT 22
5497: PUSH
5498: LD_INT 8
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: PUSH
5505: LD_INT 23
5507: PUSH
5508: LD_INT 3
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PUSH
5515: LD_INT 30
5517: PUSH
5518: LD_INT 18
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL_OW 69
5534: NOT
5535: IFFALSE 5613
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5537: LD_EXP 64
5541: PPUSH
5542: LD_INT 18
5544: PPUSH
5545: LD_INT 89
5547: PPUSH
5548: LD_INT 32
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5558: LD_INT 35
5560: PPUSH
5561: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5565: LD_INT 22
5567: PUSH
5568: LD_INT 8
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 23
5577: PUSH
5578: LD_INT 3
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 30
5587: PUSH
5588: LD_INT 18
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 57
5597: PUSH
5598: EMPTY
5599: LIST
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: IFFALSE 5558
// end ; lab := kozlov_lab ;
5613: LD_ADDR_VAR 0 3
5617: PUSH
5618: LD_INT 336
5620: ST_TO_ADDR
// if not lab then
5621: LD_VAR 0 3
5625: NOT
5626: IFFALSE 5630
// exit ;
5628: GO 5755
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5630: LD_EXP 64
5634: PPUSH
5635: LD_VAR 0 3
5639: PUSH
5640: LD_INT 1
5642: ARRAY
5643: PPUSH
5644: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5648: LD_EXP 64
5652: PPUSH
5653: LD_INT 4
5655: PPUSH
5656: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5660: LD_VAR 0 3
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: LD_INT 25
5671: PPUSH
5672: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5676: LD_INT 35
5678: PPUSH
5679: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5683: LD_INT 25
5685: PPUSH
5686: LD_INT 8
5688: PPUSH
5689: CALL_OW 321
5693: PUSH
5694: LD_INT 2
5696: EQUAL
5697: IFFALSE 5676
// ComExitBuilding ( Kozlov ) ;
5699: LD_EXP 64
5703: PPUSH
5704: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5708: LD_EXP 64
5712: PPUSH
5713: LD_VAR 0 2
5717: PPUSH
5718: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5722: LD_EXP 64
5726: PPUSH
5727: LD_INT 3
5729: PPUSH
5730: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5734: LD_VAR 0 2
5738: PPUSH
5739: LD_INT 23
5741: PPUSH
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: LD_INT 48
5750: PPUSH
5751: CALL_OW 125
// end ;
5755: LD_VAR 0 1
5759: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5760: LD_EXP 22
5764: NOT
5765: PUSH
5766: LD_EXP 15
5770: PUSH
5771: LD_INT 6
5773: GREATEREQUAL
5774: AND
5775: IFFALSE 5856
5777: GO 5779
5779: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5780: LD_INT 3
5782: PPUSH
5783: LD_INT 3
5785: PPUSH
5786: CALL 63153 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 14
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 1
5801: PUSH
5802: LD_INT 28
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 14
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 1
5819: PUSH
5820: LD_INT 28
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 14
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 1
5837: PUSH
5838: LD_INT 28
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL 63016 0 2
// end ;
5856: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5857: LD_EXP 22
5861: NOT
5862: PUSH
5863: LD_EXP 15
5867: PUSH
5868: LD_INT 6
5870: GREATEREQUAL
5871: AND
5872: PUSH
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 64434 0 2
5883: NOT
5884: AND
5885: IFFALSE 6832
5887: GO 5889
5889: DISABLE
5890: LD_INT 0
5892: PPUSH
5893: PPUSH
5894: PPUSH
5895: PPUSH
// begin enable ;
5896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5897: LD_INT 22
5899: PUSH
5900: LD_INT 8
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 23
5909: PUSH
5910: LD_INT 2
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 30
5919: PUSH
5920: LD_INT 3
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 69
5936: NOT
5937: IFFALSE 5941
// exit ;
5939: GO 6832
// if Prob ( 40 ) then
5941: LD_INT 40
5943: PPUSH
5944: CALL_OW 13
5948: IFFALSE 6075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 14
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 28
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 28
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: LD_INT 14
5991: PUSH
5992: LD_INT 1
5994: PUSH
5995: LD_INT 2
5997: PUSH
5998: LD_INT 28
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_INT 14
6009: PUSH
6010: LD_INT 1
6012: PUSH
6013: LD_INT 2
6015: PUSH
6016: LD_INT 28
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PUSH
6025: LD_INT 14
6027: PUSH
6028: LD_INT 1
6030: PUSH
6031: LD_INT 2
6033: PUSH
6034: LD_INT 28
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 14
6045: PUSH
6046: LD_INT 1
6048: PUSH
6049: LD_INT 2
6051: PUSH
6052: LD_INT 26
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: LIST
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL 63016 0 2
// end else
6073: GO 6282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6075: LD_INT 3
6077: PPUSH
6078: LD_INT 14
6080: PUSH
6081: LD_INT 1
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 27
6089: PUSH
6090: LD_INT 26
6092: PUSH
6093: LD_INT 26
6095: PUSH
6096: LD_INT 28
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PUSH
6105: LD_OWVAR 67
6109: ARRAY
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 14
6119: PUSH
6120: LD_INT 1
6122: PUSH
6123: LD_INT 2
6125: PUSH
6126: LD_INT 27
6128: PUSH
6129: LD_INT 26
6131: PUSH
6132: LD_INT 26
6134: PUSH
6135: LD_INT 26
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PUSH
6144: LD_OWVAR 67
6148: ARRAY
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 14
6158: PUSH
6159: LD_INT 1
6161: PUSH
6162: LD_INT 2
6164: PUSH
6165: LD_INT 26
6167: PUSH
6168: LD_INT 26
6170: PUSH
6171: LD_INT 29
6173: PUSH
6174: LD_INT 29
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_OWVAR 67
6187: ARRAY
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: LIST
6194: PUSH
6195: LD_INT 13
6197: PUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: LD_INT 26
6206: PUSH
6207: LD_INT 29
6209: PUSH
6210: LD_INT 29
6212: PUSH
6213: LD_INT 29
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_OWVAR 67
6226: ARRAY
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 13
6236: PUSH
6237: LD_INT 1
6239: PUSH
6240: LD_INT 2
6242: PUSH
6243: LD_INT 29
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: PUSH
6252: LD_INT 14
6254: PUSH
6255: LD_INT 1
6257: PUSH
6258: LD_INT 2
6260: PUSH
6261: LD_INT 26
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: PPUSH
6278: CALL 63016 0 2
// end ; wait ( 2 2$00 ) ;
6282: LD_INT 4200
6284: PPUSH
6285: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6289: LD_ADDR_VAR 0 2
6293: PUSH
6294: LD_INT 22
6296: PUSH
6297: LD_INT 8
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 21
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 3
6316: PUSH
6317: LD_INT 34
6319: PUSH
6320: LD_INT 31
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: PUSH
6327: LD_INT 34
6329: PUSH
6330: LD_INT 32
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 34
6339: PUSH
6340: LD_INT 88
6342: PUSH
6343: EMPTY
6344: LIST
6345: LIST
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: PPUSH
6358: CALL_OW 69
6362: PUSH
6363: LD_EXP 123
6367: PUSH
6368: LD_INT 3
6370: ARRAY
6371: DIFF
6372: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6373: LD_ADDR_EXP 120
6377: PUSH
6378: LD_EXP 120
6382: PPUSH
6383: LD_INT 3
6385: PPUSH
6386: LD_EXP 120
6390: PUSH
6391: LD_INT 3
6393: ARRAY
6394: PUSH
6395: LD_VAR 0 2
6399: DIFF
6400: PPUSH
6401: CALL_OW 1
6405: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6406: LD_ADDR_VAR 0 3
6410: PUSH
6411: LD_INT 0
6413: PPUSH
6414: LD_INT 2
6416: PPUSH
6417: CALL_OW 12
6421: ST_TO_ADDR
// if target then
6422: LD_VAR 0 3
6426: IFFALSE 6588
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6428: LD_ADDR_VAR 0 2
6432: PUSH
6433: LD_VAR 0 2
6437: PPUSH
6438: LD_INT 24
6440: PUSH
6441: LD_INT 250
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 72
6452: ST_TO_ADDR
// if not tmp then
6453: LD_VAR 0 2
6457: NOT
6458: IFFALSE 6462
// break ;
6460: GO 6586
// for i in tmp do
6462: LD_ADDR_VAR 0 1
6466: PUSH
6467: LD_VAR 0 2
6471: PUSH
6472: FOR_IN
6473: IFFALSE 6513
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6475: LD_VAR 0 1
6479: PPUSH
6480: LD_INT 89
6482: PPUSH
6483: LD_INT 71
6485: PPUSH
6486: CALL_OW 297
6490: PUSH
6491: LD_INT 9
6493: GREATER
6494: IFFALSE 6511
// ComMoveXY ( i , 89 , 71 ) ;
6496: LD_VAR 0 1
6500: PPUSH
6501: LD_INT 89
6503: PPUSH
6504: LD_INT 71
6506: PPUSH
6507: CALL_OW 111
6511: GO 6472
6513: POP
6514: POP
// wait ( 0 0$1 ) ;
6515: LD_INT 35
6517: PPUSH
6518: CALL_OW 67
// p := Inc ( p ) ;
6522: LD_ADDR_VAR 0 4
6526: PUSH
6527: LD_VAR 0 4
6531: PPUSH
6532: CALL 108505 0 1
6536: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6537: LD_VAR 0 2
6541: PPUSH
6542: LD_INT 92
6544: PUSH
6545: LD_INT 89
6547: PUSH
6548: LD_INT 71
6550: PUSH
6551: LD_INT 9
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: PPUSH
6560: CALL_OW 72
6564: PUSH
6565: LD_VAR 0 2
6569: PUSH
6570: LD_INT 1
6572: MINUS
6573: GREATEREQUAL
6574: PUSH
6575: LD_VAR 0 4
6579: PUSH
6580: LD_INT 30
6582: GREATER
6583: OR
6584: IFFALSE 6428
// end else
6586: GO 6746
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6588: LD_ADDR_VAR 0 2
6592: PUSH
6593: LD_VAR 0 2
6597: PPUSH
6598: LD_INT 24
6600: PUSH
6601: LD_INT 250
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: ST_TO_ADDR
// if not tmp then
6613: LD_VAR 0 2
6617: NOT
6618: IFFALSE 6622
// break ;
6620: GO 6746
// for i in tmp do
6622: LD_ADDR_VAR 0 1
6626: PUSH
6627: LD_VAR 0 2
6631: PUSH
6632: FOR_IN
6633: IFFALSE 6673
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_INT 125
6642: PPUSH
6643: LD_INT 129
6645: PPUSH
6646: CALL_OW 297
6650: PUSH
6651: LD_INT 9
6653: GREATER
6654: IFFALSE 6671
// ComMoveXY ( i , 125 , 129 ) ;
6656: LD_VAR 0 1
6660: PPUSH
6661: LD_INT 125
6663: PPUSH
6664: LD_INT 129
6666: PPUSH
6667: CALL_OW 111
6671: GO 6632
6673: POP
6674: POP
// wait ( 0 0$1 ) ;
6675: LD_INT 35
6677: PPUSH
6678: CALL_OW 67
// p := Inc ( p ) ;
6682: LD_ADDR_VAR 0 4
6686: PUSH
6687: LD_VAR 0 4
6691: PPUSH
6692: CALL 108505 0 1
6696: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 92
6704: PUSH
6705: LD_INT 125
6707: PUSH
6708: LD_INT 129
6710: PUSH
6711: LD_INT 9
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PPUSH
6720: CALL_OW 72
6724: PUSH
6725: LD_VAR 0 2
6729: PUSH
6730: LD_INT 1
6732: MINUS
6733: GREATEREQUAL
6734: PUSH
6735: LD_VAR 0 4
6739: PUSH
6740: LD_INT 30
6742: GREATER
6743: OR
6744: IFFALSE 6588
// end ; repeat wait ( 0 0$1 ) ;
6746: LD_INT 35
6748: PPUSH
6749: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6753: LD_ADDR_VAR 0 2
6757: PUSH
6758: LD_VAR 0 2
6762: PPUSH
6763: LD_INT 50
6765: PUSH
6766: EMPTY
6767: LIST
6768: PPUSH
6769: CALL_OW 72
6773: ST_TO_ADDR
// for i in tmp do
6774: LD_ADDR_VAR 0 1
6778: PUSH
6779: LD_VAR 0 2
6783: PUSH
6784: FOR_IN
6785: IFFALSE 6823
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6787: LD_VAR 0 1
6791: PPUSH
6792: LD_INT 81
6794: PUSH
6795: LD_INT 8
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PPUSH
6802: CALL_OW 69
6806: PPUSH
6807: LD_VAR 0 1
6811: PPUSH
6812: CALL_OW 74
6816: PPUSH
6817: CALL_OW 115
6821: GO 6784
6823: POP
6824: POP
// until not tmp ;
6825: LD_VAR 0 2
6829: NOT
6830: IFFALSE 6746
// end ;
6832: PPOPN 4
6834: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6835: LD_EXP 22
6839: NOT
6840: PUSH
6841: LD_EXP 15
6845: PUSH
6846: LD_INT 6
6848: GREATEREQUAL
6849: AND
6850: PUSH
6851: LD_OWVAR 67
6855: PUSH
6856: LD_INT 1
6858: GREATER
6859: AND
6860: IFFALSE 7393
6862: GO 6864
6864: DISABLE
6865: LD_INT 0
6867: PPUSH
6868: PPUSH
6869: PPUSH
// begin enable ;
6870: ENABLE
// tmp := [ ] ;
6871: LD_ADDR_VAR 0 3
6875: PUSH
6876: EMPTY
6877: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6878: LD_ADDR_VAR 0 1
6882: PUSH
6883: DOUBLE
6884: LD_INT 1
6886: DEC
6887: ST_TO_ADDR
6888: LD_INT 4
6890: PUSH
6891: LD_INT 6
6893: PUSH
6894: LD_INT 7
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: PUSH
6906: LD_OWVAR 67
6910: ARRAY
6911: PUSH
6912: FOR_TO
6913: IFFALSE 7073
// begin uc_side := 8 ;
6915: LD_ADDR_OWVAR 20
6919: PUSH
6920: LD_INT 8
6922: ST_TO_ADDR
// uc_nation := 2 ;
6923: LD_ADDR_OWVAR 21
6927: PUSH
6928: LD_INT 2
6930: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6931: LD_INT 13
6933: PUSH
6934: LD_INT 14
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 2
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: PPUSH
6953: LD_INT 1
6955: PPUSH
6956: LD_INT 5
6958: PPUSH
6959: LD_INT 27
6961: PUSH
6962: LD_INT 28
6964: PUSH
6965: LD_INT 26
6967: PUSH
6968: LD_INT 25
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: PUSH
6977: LD_INT 1
6979: PPUSH
6980: LD_INT 4
6982: PPUSH
6983: CALL_OW 12
6987: ARRAY
6988: PPUSH
6989: LD_INT 88
6991: PPUSH
6992: CALL 74282 0 5
// un := CreateVehicle ;
6996: LD_ADDR_VAR 0 2
7000: PUSH
7001: CALL_OW 45
7005: ST_TO_ADDR
// tmp := tmp ^ un ;
7006: LD_ADDR_VAR 0 3
7010: PUSH
7011: LD_VAR 0 3
7015: PUSH
7016: LD_VAR 0 2
7020: ADD
7021: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7022: LD_VAR 0 2
7026: PPUSH
7027: LD_INT 3
7029: PPUSH
7030: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7034: LD_VAR 0 2
7038: PPUSH
7039: LD_INT 30
7041: PPUSH
7042: LD_INT 0
7044: PPUSH
7045: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7049: LD_VAR 0 2
7053: PPUSH
7054: LD_INT 16
7056: PPUSH
7057: LD_INT 11
7059: PPUSH
7060: CALL_OW 111
// wait ( 0 0$2 ) ;
7064: LD_INT 70
7066: PPUSH
7067: CALL_OW 67
// end ;
7071: GO 6912
7073: POP
7074: POP
// for i = 1 to Difficulty do
7075: LD_ADDR_VAR 0 1
7079: PUSH
7080: DOUBLE
7081: LD_INT 1
7083: DEC
7084: ST_TO_ADDR
7085: LD_OWVAR 67
7089: PUSH
7090: FOR_TO
7091: IFFALSE 7220
// begin uc_side := 8 ;
7093: LD_ADDR_OWVAR 20
7097: PUSH
7098: LD_INT 8
7100: ST_TO_ADDR
// uc_nation := 2 ;
7101: LD_ADDR_OWVAR 21
7105: PUSH
7106: LD_INT 2
7108: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7109: LD_INT 0
7111: PPUSH
7112: LD_INT 8
7114: PPUSH
7115: LD_INT 8
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: LD_INT 9
7123: PUSH
7124: LD_INT 10
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: PUSH
7133: LD_OWVAR 67
7137: ARRAY
7138: PPUSH
7139: CALL_OW 380
// un := CreateHuman ;
7143: LD_ADDR_VAR 0 2
7147: PUSH
7148: CALL_OW 44
7152: ST_TO_ADDR
// tmp := tmp ^ un ;
7153: LD_ADDR_VAR 0 3
7157: PUSH
7158: LD_VAR 0 3
7162: PUSH
7163: LD_VAR 0 2
7167: ADD
7168: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7181: LD_VAR 0 2
7185: PPUSH
7186: LD_INT 30
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7196: LD_VAR 0 2
7200: PPUSH
7201: LD_INT 16
7203: PPUSH
7204: LD_INT 11
7206: PPUSH
7207: CALL_OW 111
// wait ( 0 0$2 ) ;
7211: LD_INT 70
7213: PPUSH
7214: CALL_OW 67
// end ;
7218: GO 7090
7220: POP
7221: POP
// repeat wait ( 0 0$1 ) ;
7222: LD_INT 35
7224: PPUSH
7225: CALL_OW 67
// if legionDestroyed then
7229: LD_EXP 22
7233: IFFALSE 7237
// exit ;
7235: GO 7393
// for i in tmp do
7237: LD_ADDR_VAR 0 1
7241: PUSH
7242: LD_VAR 0 3
7246: PUSH
7247: FOR_IN
7248: IFFALSE 7384
// begin if GetLives ( i ) > 250 then
7250: LD_VAR 0 1
7254: PPUSH
7255: CALL_OW 256
7259: PUSH
7260: LD_INT 250
7262: GREATER
7263: IFFALSE 7355
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7265: LD_INT 81
7267: PUSH
7268: LD_INT 8
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: PUSH
7275: LD_INT 91
7277: PUSH
7278: LD_VAR 0 1
7282: PUSH
7283: LD_INT 10
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: LIST
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PPUSH
7295: CALL_OW 69
7299: NOT
7300: IFFALSE 7319
// ComAgressiveMove ( i , 67 , 110 ) else
7302: LD_VAR 0 1
7306: PPUSH
7307: LD_INT 67
7309: PPUSH
7310: LD_INT 110
7312: PPUSH
7313: CALL_OW 114
7317: GO 7353
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7319: LD_VAR 0 1
7323: PPUSH
7324: LD_INT 81
7326: PUSH
7327: LD_INT 8
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL_OW 69
7338: PPUSH
7339: LD_VAR 0 1
7343: PPUSH
7344: CALL_OW 74
7348: PPUSH
7349: CALL_OW 115
// end else
7353: GO 7382
// if IsDead ( i ) then
7355: LD_VAR 0 1
7359: PPUSH
7360: CALL_OW 301
7364: IFFALSE 7382
// tmp := tmp diff i ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: LD_VAR 0 3
7375: PUSH
7376: LD_VAR 0 1
7380: DIFF
7381: ST_TO_ADDR
// end ;
7382: GO 7247
7384: POP
7385: POP
// until not tmp ;
7386: LD_VAR 0 3
7390: NOT
7391: IFFALSE 7222
// end ; end_of_file
7393: PPOPN 3
7395: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7396: LD_INT 0
7398: PPUSH
7399: PPUSH
7400: PPUSH
7401: PPUSH
7402: PPUSH
7403: PPUSH
7404: PPUSH
7405: PPUSH
7406: PPUSH
7407: PPUSH
// side := 3 ;
7408: LD_ADDR_VAR 0 6
7412: PUSH
7413: LD_INT 3
7415: ST_TO_ADDR
// uc_side := side ;
7416: LD_ADDR_OWVAR 20
7420: PUSH
7421: LD_VAR 0 6
7425: ST_TO_ADDR
// uc_nation := 3 ;
7426: LD_ADDR_OWVAR 21
7430: PUSH
7431: LD_INT 3
7433: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7434: LD_ADDR_VAR 0 2
7438: PUSH
7439: LD_INT 22
7441: PUSH
7442: LD_VAR 0 6
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: LD_INT 21
7453: PUSH
7454: LD_INT 3
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL_OW 69
7469: PUSH
7470: FOR_IN
7471: IFFALSE 7487
// SetBLevel ( i , 10 ) ;
7473: LD_VAR 0 2
7477: PPUSH
7478: LD_INT 10
7480: PPUSH
7481: CALL_OW 241
7485: GO 7470
7487: POP
7488: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7489: LD_ADDR_VAR 0 10
7493: PUSH
7494: LD_INT 22
7496: PUSH
7497: LD_VAR 0 6
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 30
7508: PUSH
7509: LD_INT 34
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PPUSH
7520: CALL_OW 69
7524: ST_TO_ADDR
// if teleport then
7525: LD_VAR 0 10
7529: IFFALSE 7550
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7531: LD_VAR 0 10
7535: PUSH
7536: LD_INT 1
7538: ARRAY
7539: PPUSH
7540: LD_INT 123
7542: PPUSH
7543: LD_INT 122
7545: PPUSH
7546: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7550: LD_ADDR_EXP 67
7554: PUSH
7555: LD_STRING Platonov
7557: PPUSH
7558: CALL_OW 25
7562: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7563: LD_ADDR_EXP 68
7567: PUSH
7568: LD_STRING Kovalyuk
7570: PPUSH
7571: CALL_OW 25
7575: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7576: LD_ADDR_EXP 70
7580: PUSH
7581: LD_STRING Yakotich
7583: PPUSH
7584: LD_EXP 1
7588: NOT
7589: PPUSH
7590: LD_STRING 09_
7592: PPUSH
7593: CALL 69442 0 3
7597: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7598: LD_ADDR_EXP 69
7602: PUSH
7603: LD_STRING Bystrov
7605: PPUSH
7606: CALL_OW 25
7610: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7611: LD_ADDR_EXP 71
7615: PUSH
7616: LD_STRING Gleb
7618: PPUSH
7619: CALL_OW 25
7623: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7624: LD_STRING 03_Cornel
7626: PPUSH
7627: CALL_OW 28
7631: IFFALSE 7679
// begin Bierezov := NewCharacter ( Mikhail ) ;
7633: LD_ADDR_EXP 72
7637: PUSH
7638: LD_STRING Mikhail
7640: PPUSH
7641: CALL_OW 25
7645: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7646: LD_EXP 72
7650: PPUSH
7651: LD_INT 197
7653: PPUSH
7654: LD_INT 111
7656: PPUSH
7657: LD_INT 9
7659: PPUSH
7660: LD_INT 0
7662: PPUSH
7663: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7667: LD_EXP 72
7671: PPUSH
7672: LD_INT 3
7674: PPUSH
7675: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7679: LD_EXP 67
7683: PPUSH
7684: LD_INT 126
7686: PPUSH
7687: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7691: LD_EXP 68
7695: PPUSH
7696: LD_INT 134
7698: PPUSH
7699: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7703: LD_EXP 70
7707: PPUSH
7708: LD_INT 197
7710: PPUSH
7711: LD_INT 111
7713: PPUSH
7714: LD_INT 9
7716: PPUSH
7717: LD_INT 0
7719: PPUSH
7720: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7724: LD_EXP 69
7728: PPUSH
7729: LD_INT 197
7731: PPUSH
7732: LD_INT 111
7734: PPUSH
7735: LD_INT 9
7737: PPUSH
7738: LD_INT 0
7740: PPUSH
7741: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7745: LD_EXP 71
7749: PPUSH
7750: LD_INT 197
7752: PPUSH
7753: LD_INT 111
7755: PPUSH
7756: LD_INT 9
7758: PPUSH
7759: LD_INT 0
7761: PPUSH
7762: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7766: LD_ADDR_VAR 0 5
7770: PUSH
7771: LD_INT 126
7773: PPUSH
7774: LD_INT 4
7776: PPUSH
7777: LD_STRING zhukov
7779: PPUSH
7780: LD_INT 9
7782: PUSH
7783: LD_INT 10
7785: PUSH
7786: LD_INT 10
7788: PUSH
7789: LD_INT 10
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_OWVAR 67
7802: ARRAY
7803: PPUSH
7804: LD_INT 90000
7806: PUSH
7807: LD_INT 1000
7809: PUSH
7810: LD_INT 300
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: LIST
7817: PPUSH
7818: LD_INT 18
7820: PUSH
7821: LD_INT 8
7823: PUSH
7824: LD_INT 12
7826: PUSH
7827: LD_INT 6
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL 78103 0 6
7840: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7841: LD_ADDR_EXP 101
7845: PUSH
7846: LD_EXP 101
7850: PPUSH
7851: LD_INT 2
7853: PPUSH
7854: LD_VAR 0 5
7858: PUSH
7859: LD_EXP 70
7863: PUSH
7864: LD_EXP 69
7868: PUSH
7869: LD_EXP 71
7873: PUSH
7874: LD_EXP 72
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: UNION
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7891: LD_ADDR_VAR 0 4
7895: PUSH
7896: LD_INT 267
7898: PPUSH
7899: CALL_OW 274
7903: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7904: LD_VAR 0 4
7908: PPUSH
7909: LD_INT 1
7911: PPUSH
7912: LD_INT 5000
7914: PPUSH
7915: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7919: LD_VAR 0 4
7923: PPUSH
7924: LD_INT 2
7926: PPUSH
7927: LD_INT 200
7929: PPUSH
7930: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7934: LD_VAR 0 4
7938: PPUSH
7939: LD_INT 3
7941: PPUSH
7942: LD_INT 200
7944: PPUSH
7945: CALL_OW 277
// for i := 1 to 6 do
7949: LD_ADDR_VAR 0 2
7953: PUSH
7954: DOUBLE
7955: LD_INT 1
7957: DEC
7958: ST_TO_ADDR
7959: LD_INT 6
7961: PUSH
7962: FOR_TO
7963: IFFALSE 8046
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7965: LD_INT 0
7967: PPUSH
7968: LD_INT 8
7970: PUSH
7971: LD_INT 9
7973: PUSH
7974: LD_INT 10
7976: PUSH
7977: LD_INT 10
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: LIST
7984: LIST
7985: PUSH
7986: LD_OWVAR 67
7990: ARRAY
7991: PPUSH
7992: CALL_OW 381
// un := CreateHuman ;
7996: LD_ADDR_VAR 0 8
8000: PUSH
8001: CALL_OW 44
8005: ST_TO_ADDR
// if i mod 2 = 0 then
8006: LD_VAR 0 2
8010: PUSH
8011: LD_INT 2
8013: MOD
8014: PUSH
8015: LD_INT 0
8017: EQUAL
8018: IFFALSE 8032
// SetClass ( un , class_bazooker ) ;
8020: LD_VAR 0 8
8024: PPUSH
8025: LD_INT 9
8027: PPUSH
8028: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8032: LD_VAR 0 8
8036: PPUSH
8037: LD_INT 460
8039: PPUSH
8040: CALL_OW 52
// end ;
8044: GO 7962
8046: POP
8047: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8048: LD_INT 21
8050: PPUSH
8051: LD_INT 3
8053: PPUSH
8054: LD_INT 3
8056: PPUSH
8057: LD_INT 52
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 74282 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8067: CALL_OW 45
8071: PPUSH
8072: LD_INT 259
8074: PPUSH
8075: LD_INT 145
8077: PPUSH
8078: LD_INT 3
8080: PPUSH
8081: LD_INT 0
8083: PPUSH
8084: CALL 109284 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8088: CALL_OW 45
8092: PPUSH
8093: LD_INT 245
8095: PPUSH
8096: LD_INT 139
8098: PPUSH
8099: LD_INT 3
8101: PPUSH
8102: LD_INT 0
8104: PPUSH
8105: CALL 109284 0 5
// behemoths := [ ] ;
8109: LD_ADDR_EXP 75
8113: PUSH
8114: EMPTY
8115: ST_TO_ADDR
// behemothBuilders := [ ] ;
8116: LD_ADDR_EXP 76
8120: PUSH
8121: EMPTY
8122: ST_TO_ADDR
// if Kovalyuk then
8123: LD_EXP 68
8127: IFFALSE 8149
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8129: LD_ADDR_EXP 76
8133: PUSH
8134: LD_EXP 76
8138: PPUSH
8139: LD_EXP 68
8143: PPUSH
8144: CALL 107144 0 2
8148: ST_TO_ADDR
// j := 3 ;
8149: LD_ADDR_VAR 0 3
8153: PUSH
8154: LD_INT 3
8156: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8157: LD_ADDR_VAR 0 2
8161: PUSH
8162: LD_INT 22
8164: PUSH
8165: LD_INT 3
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 25
8174: PUSH
8175: LD_INT 3
8177: PUSH
8178: EMPTY
8179: LIST
8180: LIST
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 69
8190: PUSH
8191: LD_EXP 68
8195: DIFF
8196: PUSH
8197: FOR_IN
8198: IFFALSE 8248
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8200: LD_ADDR_EXP 76
8204: PUSH
8205: LD_EXP 76
8209: PPUSH
8210: LD_VAR 0 2
8214: PPUSH
8215: CALL 107144 0 2
8219: ST_TO_ADDR
// j := j - 1 ;
8220: LD_ADDR_VAR 0 3
8224: PUSH
8225: LD_VAR 0 3
8229: PUSH
8230: LD_INT 1
8232: MINUS
8233: ST_TO_ADDR
// if j = 0 then
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 0
8241: EQUAL
8242: IFFALSE 8246
// break ;
8244: GO 8248
// end ;
8246: GO 8197
8248: POP
8249: POP
// end ;
8250: LD_VAR 0 1
8254: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8255: LD_INT 0
8257: PPUSH
8258: PPUSH
8259: PPUSH
8260: PPUSH
8261: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8262: LD_ADDR_VAR 0 4
8266: PUSH
8267: LD_INT 209
8269: PUSH
8270: LD_INT 149
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: PUSH
8277: LD_INT 219
8279: PUSH
8280: LD_INT 154
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: PUSH
8287: LD_INT 223
8289: PUSH
8290: LD_INT 149
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PUSH
8297: LD_INT 232
8299: PUSH
8300: LD_INT 155
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: LIST
8311: LIST
8312: ST_TO_ADDR
// if not behemothBuilders then
8313: LD_EXP 76
8317: NOT
8318: IFFALSE 8322
// exit ;
8320: GO 8453
// j := 1 ;
8322: LD_ADDR_VAR 0 3
8326: PUSH
8327: LD_INT 1
8329: ST_TO_ADDR
// for i in behemothBuilders do
8330: LD_ADDR_VAR 0 2
8334: PUSH
8335: LD_EXP 76
8339: PUSH
8340: FOR_IN
8341: IFFALSE 8451
// begin if GetClass ( i ) <> class_mechanic then
8343: LD_VAR 0 2
8347: PPUSH
8348: CALL_OW 257
8352: PUSH
8353: LD_INT 3
8355: NONEQUAL
8356: IFFALSE 8370
// SetClass ( i , class_mechanic ) ;
8358: LD_VAR 0 2
8362: PPUSH
8363: LD_INT 3
8365: PPUSH
8366: CALL_OW 336
// if IsInUnit ( i ) then
8370: LD_VAR 0 2
8374: PPUSH
8375: CALL_OW 310
8379: IFFALSE 8390
// ComExitBuilding ( i ) ;
8381: LD_VAR 0 2
8385: PPUSH
8386: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8390: LD_VAR 0 2
8394: PPUSH
8395: LD_INT 37
8397: PPUSH
8398: LD_VAR 0 4
8402: PUSH
8403: LD_VAR 0 3
8407: ARRAY
8408: PUSH
8409: LD_INT 1
8411: ARRAY
8412: PPUSH
8413: LD_VAR 0 4
8417: PUSH
8418: LD_VAR 0 3
8422: ARRAY
8423: PUSH
8424: LD_INT 2
8426: ARRAY
8427: PPUSH
8428: LD_INT 0
8430: PPUSH
8431: CALL_OW 230
// j := j + 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_VAR 0 3
8444: PUSH
8445: LD_INT 1
8447: PLUS
8448: ST_TO_ADDR
// end ;
8449: GO 8340
8451: POP
8452: POP
// end ;
8453: LD_VAR 0 1
8457: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8458: LD_INT 24
8460: PPUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 37
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PPUSH
8471: CALL_OW 70
8475: IFFALSE 8488
8477: GO 8479
8479: DISABLE
// behemothUnderConstruct := true ;
8480: LD_ADDR_EXP 26
8484: PUSH
8485: LD_INT 1
8487: ST_TO_ADDR
8488: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8489: LD_INT 3
8491: PPUSH
8492: CALL 107205 0 1
8496: PUSH
8497: LD_INT 22
8499: PUSH
8500: LD_INT 3
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: LD_INT 30
8509: PUSH
8510: LD_INT 37
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PPUSH
8521: CALL_OW 69
8525: NOT
8526: AND
8527: IFFALSE 8713
8529: GO 8531
8531: DISABLE
8532: LD_INT 0
8534: PPUSH
8535: PPUSH
// begin enable ;
8536: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8537: LD_ADDR_VAR 0 2
8541: PUSH
8542: LD_INT 3
8544: PPUSH
8545: CALL 107205 0 1
8549: ST_TO_ADDR
// for i in tmp do
8550: LD_ADDR_VAR 0 1
8554: PUSH
8555: LD_VAR 0 2
8559: PUSH
8560: FOR_IN
8561: IFFALSE 8711
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8563: LD_VAR 0 1
8567: PPUSH
8568: LD_INT 9
8570: PPUSH
8571: CALL_OW 308
8575: PUSH
8576: LD_VAR 0 1
8580: PPUSH
8581: CALL_OW 110
8585: PUSH
8586: LD_INT 2
8588: EQUAL
8589: NOT
8590: AND
8591: IFFALSE 8605
// SetTag ( i , 2 ) ;
8593: LD_VAR 0 1
8597: PPUSH
8598: LD_INT 2
8600: PPUSH
8601: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8605: LD_INT 81
8607: PUSH
8608: LD_INT 3
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: PUSH
8615: LD_INT 91
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 12
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: NOT
8640: PUSH
8641: LD_VAR 0 1
8645: PPUSH
8646: CALL_OW 110
8650: PUSH
8651: LD_INT 2
8653: EQUAL
8654: NOT
8655: AND
8656: IFFALSE 8675
// ComAgressiveMove ( i , 64 , 93 ) else
8658: LD_VAR 0 1
8662: PPUSH
8663: LD_INT 64
8665: PPUSH
8666: LD_INT 93
8668: PPUSH
8669: CALL_OW 114
8673: GO 8709
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8675: LD_VAR 0 1
8679: PPUSH
8680: LD_INT 81
8682: PUSH
8683: LD_INT 3
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PPUSH
8690: CALL_OW 69
8694: PPUSH
8695: LD_VAR 0 1
8699: PPUSH
8700: CALL_OW 74
8704: PPUSH
8705: CALL_OW 115
// end ;
8709: GO 8560
8711: POP
8712: POP
// end ;
8713: PPOPN 2
8715: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8716: LD_INT 0
8718: PPUSH
8719: PPUSH
8720: PPUSH
// result := [ ] ;
8721: LD_ADDR_VAR 0 2
8725: PUSH
8726: EMPTY
8727: ST_TO_ADDR
// uc_side := 6 ;
8728: LD_ADDR_OWVAR 20
8732: PUSH
8733: LD_INT 6
8735: ST_TO_ADDR
// uc_nation := 3 ;
8736: LD_ADDR_OWVAR 21
8740: PUSH
8741: LD_INT 3
8743: ST_TO_ADDR
// case strength of 1 :
8744: LD_VAR 0 1
8748: PUSH
8749: LD_INT 1
8751: DOUBLE
8752: EQUAL
8753: IFTRUE 8757
8755: GO 8899
8757: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8758: LD_ADDR_VAR 0 3
8762: PUSH
8763: DOUBLE
8764: LD_INT 1
8766: DEC
8767: ST_TO_ADDR
8768: LD_INT 4
8770: PUSH
8771: LD_INT 5
8773: PUSH
8774: LD_INT 6
8776: PUSH
8777: LD_INT 7
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: PUSH
8786: LD_OWVAR 67
8790: ARRAY
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8895
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8795: LD_INT 22
8797: PUSH
8798: LD_INT 24
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_VAR 0 3
8809: PUSH
8810: LD_INT 2
8812: MOD
8813: PUSH
8814: LD_INT 1
8816: PLUS
8817: ARRAY
8818: PPUSH
8819: LD_INT 1
8821: PUSH
8822: LD_INT 3
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PUSH
8829: LD_INT 1
8831: PPUSH
8832: LD_INT 2
8834: PPUSH
8835: CALL_OW 12
8839: ARRAY
8840: PPUSH
8841: LD_INT 3
8843: PPUSH
8844: LD_INT 43
8846: PUSH
8847: LD_INT 44
8849: PUSH
8850: LD_INT 45
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 3
8863: PPUSH
8864: CALL_OW 12
8868: ARRAY
8869: PPUSH
8870: LD_INT 80
8872: PPUSH
8873: CALL 74282 0 5
// result := result union CreateVehicle ;
8877: LD_ADDR_VAR 0 2
8881: PUSH
8882: LD_VAR 0 2
8886: PUSH
8887: CALL_OW 45
8891: UNION
8892: ST_TO_ADDR
// end ;
8893: GO 8792
8895: POP
8896: POP
// end ; 2 :
8897: GO 9894
8899: LD_INT 2
8901: DOUBLE
8902: EQUAL
8903: IFTRUE 8907
8905: GO 9075
8907: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8908: LD_ADDR_VAR 0 3
8912: PUSH
8913: DOUBLE
8914: LD_INT 1
8916: DEC
8917: ST_TO_ADDR
8918: LD_INT 5
8920: PUSH
8921: LD_INT 6
8923: PUSH
8924: LD_INT 7
8926: PUSH
8927: LD_INT 8
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: LD_OWVAR 67
8940: ARRAY
8941: PUSH
8942: FOR_TO
8943: IFFALSE 9071
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8945: LD_INT 22
8947: PUSH
8948: LD_INT 24
8950: PUSH
8951: LD_INT 24
8953: PUSH
8954: EMPTY
8955: LIST
8956: LIST
8957: LIST
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 3
8966: MOD
8967: PUSH
8968: LD_INT 1
8970: PLUS
8971: ARRAY
8972: PPUSH
8973: LD_INT 1
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 1
8985: PPUSH
8986: LD_INT 2
8988: PPUSH
8989: CALL_OW 12
8993: ARRAY
8994: PPUSH
8995: LD_INT 3
8997: PPUSH
8998: LD_INT 43
9000: PUSH
9001: LD_INT 44
9003: PUSH
9004: LD_INT 45
9006: PUSH
9007: LD_INT 44
9009: PUSH
9010: LD_INT 46
9012: PUSH
9013: LD_INT 46
9015: PUSH
9016: LD_INT 49
9018: PUSH
9019: LD_INT 49
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: PUSH
9032: LD_VAR 0 3
9036: PUSH
9037: LD_INT 8
9039: MOD
9040: PUSH
9041: LD_INT 1
9043: PLUS
9044: ARRAY
9045: PPUSH
9046: LD_INT 80
9048: PPUSH
9049: CALL 74282 0 5
// result := result union CreateVehicle ;
9053: LD_ADDR_VAR 0 2
9057: PUSH
9058: LD_VAR 0 2
9062: PUSH
9063: CALL_OW 45
9067: UNION
9068: ST_TO_ADDR
// end ;
9069: GO 8942
9071: POP
9072: POP
// end ; 3 :
9073: GO 9894
9075: LD_INT 3
9077: DOUBLE
9078: EQUAL
9079: IFTRUE 9083
9081: GO 9255
9083: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9084: LD_ADDR_VAR 0 3
9088: PUSH
9089: DOUBLE
9090: LD_INT 1
9092: DEC
9093: ST_TO_ADDR
9094: LD_INT 6
9096: PUSH
9097: LD_INT 7
9099: PUSH
9100: LD_INT 8
9102: PUSH
9103: LD_INT 9
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: LIST
9110: LIST
9111: PUSH
9112: LD_OWVAR 67
9116: ARRAY
9117: PUSH
9118: FOR_TO
9119: IFFALSE 9251
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9121: LD_INT 22
9123: PUSH
9124: LD_INT 24
9126: PUSH
9127: LD_INT 24
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: LIST
9134: PUSH
9135: LD_VAR 0 3
9139: PUSH
9140: LD_INT 3
9142: MOD
9143: PUSH
9144: LD_INT 1
9146: PLUS
9147: ARRAY
9148: PPUSH
9149: LD_INT 1
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 2
9164: PPUSH
9165: CALL_OW 12
9169: ARRAY
9170: PPUSH
9171: LD_INT 3
9173: PPUSH
9174: LD_INT 43
9176: PUSH
9177: LD_INT 47
9179: PUSH
9180: LD_INT 45
9182: PUSH
9183: LD_INT 45
9185: PUSH
9186: LD_INT 46
9188: PUSH
9189: LD_INT 46
9191: PUSH
9192: LD_INT 49
9194: PUSH
9195: LD_INT 49
9197: PUSH
9198: LD_INT 49
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: PUSH
9212: LD_VAR 0 3
9216: PUSH
9217: LD_INT 9
9219: MOD
9220: PUSH
9221: LD_INT 1
9223: PLUS
9224: ARRAY
9225: PPUSH
9226: LD_INT 80
9228: PPUSH
9229: CALL 74282 0 5
// result := result union CreateVehicle ;
9233: LD_ADDR_VAR 0 2
9237: PUSH
9238: LD_VAR 0 2
9242: PUSH
9243: CALL_OW 45
9247: UNION
9248: ST_TO_ADDR
// end ;
9249: GO 9118
9251: POP
9252: POP
// end ; 4 :
9253: GO 9894
9255: LD_INT 4
9257: DOUBLE
9258: EQUAL
9259: IFTRUE 9263
9261: GO 9893
9263: POP
// begin uc_nation := 3 ;
9264: LD_ADDR_OWVAR 21
9268: PUSH
9269: LD_INT 3
9271: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9272: LD_ADDR_VAR 0 3
9276: PUSH
9277: DOUBLE
9278: LD_INT 1
9280: DEC
9281: ST_TO_ADDR
9282: LD_INT 6
9284: PUSH
9285: LD_INT 8
9287: PUSH
9288: LD_INT 9
9290: PUSH
9291: LD_INT 10
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: LIST
9298: LIST
9299: PUSH
9300: LD_OWVAR 67
9304: ARRAY
9305: PUSH
9306: FOR_TO
9307: IFFALSE 9439
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9309: LD_INT 22
9311: PUSH
9312: LD_INT 24
9314: PUSH
9315: LD_INT 24
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: PUSH
9323: LD_VAR 0 3
9327: PUSH
9328: LD_INT 3
9330: MOD
9331: PUSH
9332: LD_INT 1
9334: PLUS
9335: ARRAY
9336: PPUSH
9337: LD_INT 1
9339: PUSH
9340: LD_INT 3
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: PUSH
9347: LD_INT 1
9349: PPUSH
9350: LD_INT 2
9352: PPUSH
9353: CALL_OW 12
9357: ARRAY
9358: PPUSH
9359: LD_INT 3
9361: PPUSH
9362: LD_INT 45
9364: PUSH
9365: LD_INT 47
9367: PUSH
9368: LD_INT 47
9370: PUSH
9371: LD_INT 45
9373: PUSH
9374: LD_INT 46
9376: PUSH
9377: LD_INT 46
9379: PUSH
9380: LD_INT 49
9382: PUSH
9383: LD_INT 49
9385: PUSH
9386: LD_INT 49
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_VAR 0 3
9404: PUSH
9405: LD_INT 9
9407: MOD
9408: PUSH
9409: LD_INT 1
9411: PLUS
9412: ARRAY
9413: PPUSH
9414: LD_INT 80
9416: PPUSH
9417: CALL 74282 0 5
// result := result union CreateVehicle ;
9421: LD_ADDR_VAR 0 2
9425: PUSH
9426: LD_VAR 0 2
9430: PUSH
9431: CALL_OW 45
9435: UNION
9436: ST_TO_ADDR
// end ;
9437: GO 9306
9439: POP
9440: POP
// if not KappaStatus then
9441: LD_EXP 2
9445: NOT
9446: IFFALSE 9681
// begin uc_nation := 1 ;
9448: LD_ADDR_OWVAR 21
9452: PUSH
9453: LD_INT 1
9455: ST_TO_ADDR
// for i = 1 to 3 do
9456: LD_ADDR_VAR 0 3
9460: PUSH
9461: DOUBLE
9462: LD_INT 1
9464: DEC
9465: ST_TO_ADDR
9466: LD_INT 3
9468: PUSH
9469: FOR_TO
9470: IFFALSE 9606
// begin j := rand ( 0 , 1 ) ;
9472: LD_ADDR_VAR 0 4
9476: PUSH
9477: LD_INT 0
9479: PPUSH
9480: LD_INT 1
9482: PPUSH
9483: CALL_OW 12
9487: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9488: LD_INT 3
9490: PUSH
9491: LD_INT 5
9493: PUSH
9494: LD_INT 5
9496: PUSH
9497: LD_INT 4
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: PUSH
9506: LD_VAR 0 4
9510: PUSH
9511: LD_INT 1
9513: PPUSH
9514: LD_INT 3
9516: PPUSH
9517: CALL_OW 12
9521: PLUS
9522: ARRAY
9523: PPUSH
9524: LD_INT 1
9526: PUSH
9527: LD_INT 3
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 1
9536: PPUSH
9537: LD_INT 2
9539: PPUSH
9540: CALL_OW 12
9544: ARRAY
9545: PPUSH
9546: LD_INT 3
9548: PPUSH
9549: LD_INT 9
9551: PUSH
9552: LD_INT 7
9554: PUSH
9555: LD_INT 6
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: PUSH
9563: LD_VAR 0 4
9567: PUSH
9568: LD_INT 1
9570: PPUSH
9571: LD_INT 2
9573: PPUSH
9574: CALL_OW 12
9578: PLUS
9579: ARRAY
9580: PPUSH
9581: LD_INT 85
9583: PPUSH
9584: CALL 74282 0 5
// result := result union CreateVehicle ;
9588: LD_ADDR_VAR 0 2
9592: PUSH
9593: LD_VAR 0 2
9597: PUSH
9598: CALL_OW 45
9602: UNION
9603: ST_TO_ADDR
// end ;
9604: GO 9469
9606: POP
9607: POP
// if vsevolodFirstAttack then
9608: LD_EXP 24
9612: IFFALSE 9679
// begin vsevolodFirstAttack := false ;
9614: LD_ADDR_EXP 24
9618: PUSH
9619: LD_INT 0
9621: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9622: LD_INT 5
9624: PPUSH
9625: LD_INT 3
9627: PPUSH
9628: LD_INT 1
9630: PPUSH
9631: LD_INT 6
9633: PPUSH
9634: LD_INT 100
9636: PPUSH
9637: CALL 74282 0 5
// sewiVeh := CreateVehicle ;
9641: LD_ADDR_EXP 74
9645: PUSH
9646: CALL_OW 45
9650: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9651: LD_EXP 74
9655: PPUSH
9656: LD_INT 1
9658: PPUSH
9659: CALL_OW 242
// result := result union sewiVeh ;
9663: LD_ADDR_VAR 0 2
9667: PUSH
9668: LD_VAR 0 2
9672: PUSH
9673: LD_EXP 74
9677: UNION
9678: ST_TO_ADDR
// end ; end else
9679: GO 9891
// if vsevolodFirstAttack then
9681: LD_EXP 24
9685: IFFALSE 9891
// begin vsevolodFirstAttack := false ;
9687: LD_ADDR_EXP 24
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// uc_nation := 3 ;
9695: LD_ADDR_OWVAR 21
9699: PUSH
9700: LD_INT 3
9702: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9703: LD_ADDR_VAR 0 3
9707: PUSH
9708: DOUBLE
9709: LD_INT 1
9711: DEC
9712: ST_TO_ADDR
9713: LD_INT 2
9715: PUSH
9716: LD_OWVAR 67
9720: PLUS
9721: PUSH
9722: FOR_TO
9723: IFFALSE 9831
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9725: LD_INT 22
9727: PUSH
9728: LD_INT 24
9730: PUSH
9731: LD_INT 24
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: LIST
9738: PUSH
9739: LD_VAR 0 3
9743: PUSH
9744: LD_INT 3
9746: MOD
9747: PUSH
9748: LD_INT 1
9750: PLUS
9751: ARRAY
9752: PPUSH
9753: LD_INT 1
9755: PUSH
9756: LD_INT 3
9758: PUSH
9759: EMPTY
9760: LIST
9761: LIST
9762: PUSH
9763: LD_INT 1
9765: PPUSH
9766: LD_INT 2
9768: PPUSH
9769: CALL_OW 12
9773: ARRAY
9774: PPUSH
9775: LD_INT 1
9777: PPUSH
9778: LD_INT 45
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: LD_INT 47
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: LD_VAR 0 3
9796: PUSH
9797: LD_INT 3
9799: MOD
9800: PUSH
9801: LD_INT 1
9803: PLUS
9804: ARRAY
9805: PPUSH
9806: LD_INT 80
9808: PPUSH
9809: CALL 74282 0 5
// result := result union CreateVehicle ;
9813: LD_ADDR_VAR 0 2
9817: PUSH
9818: LD_VAR 0 2
9822: PUSH
9823: CALL_OW 45
9827: UNION
9828: ST_TO_ADDR
// end ;
9829: GO 9722
9831: POP
9832: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9833: LD_INT 24
9835: PPUSH
9836: LD_INT 3
9838: PPUSH
9839: LD_INT 1
9841: PPUSH
9842: LD_INT 47
9844: PPUSH
9845: LD_INT 100
9847: PPUSH
9848: CALL 74282 0 5
// sewiVeh := CreateVehicle ;
9852: LD_ADDR_EXP 74
9856: PUSH
9857: CALL_OW 45
9861: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9862: LD_EXP 74
9866: PPUSH
9867: LD_INT 6
9869: NEG
9870: PPUSH
9871: CALL_OW 242
// result := result union sewiVeh ;
9875: LD_ADDR_VAR 0 2
9879: PUSH
9880: LD_VAR 0 2
9884: PUSH
9885: LD_EXP 74
9889: UNION
9890: ST_TO_ADDR
// end ; end ; end ;
9891: GO 9894
9893: POP
// end ;
9894: LD_VAR 0 2
9898: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9899: LD_EXP 16
9903: IFFALSE 10644
9905: GO 9907
9907: DISABLE
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9916: LD_ADDR_VAR 0 4
9920: PUSH
9921: LD_INT 11
9923: PUSH
9924: LD_INT 12
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9931: LD_ADDR_VAR 0 3
9935: PUSH
9936: LD_INT 11550
9938: PUSH
9939: LD_INT 10150
9941: PUSH
9942: LD_INT 9800
9944: PUSH
9945: LD_INT 9450
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: PUSH
9954: LD_OWVAR 67
9958: ARRAY
9959: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9960: LD_ADDR_VAR 0 6
9964: PUSH
9965: LD_INT 70
9967: PUSH
9968: LD_INT 118
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: PUSH
9975: LD_INT 78
9977: PUSH
9978: LD_INT 31
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: ST_TO_ADDR
// repeat if missionStage = 2 then
9989: LD_EXP 15
9993: PUSH
9994: LD_INT 2
9996: EQUAL
9997: IFFALSE 10008
// wait ( 1 1$30 ) else
9999: LD_INT 3150
10001: PPUSH
10002: CALL_OW 67
10006: GO 10017
// wait ( time ) ;
10008: LD_VAR 0 3
10012: PPUSH
10013: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10017: LD_EXP 15
10021: PUSH
10022: LD_INT 6
10024: EQUAL
10025: PUSH
10026: LD_OWVAR 67
10030: PUSH
10031: LD_INT 2
10033: GREATER
10034: OR
10035: IFFALSE 10063
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10037: LD_INT 51
10039: PPUSH
10040: LD_INT 6
10042: PPUSH
10043: LD_INT 2
10045: PPUSH
10046: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10050: LD_INT 57
10052: PPUSH
10053: LD_INT 6
10055: PPUSH
10056: LD_INT 2
10058: PPUSH
10059: CALL_OW 322
// end ; if missionStage = 8 then
10063: LD_EXP 15
10067: PUSH
10068: LD_INT 8
10070: EQUAL
10071: IFFALSE 10099
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10073: LD_INT 52
10075: PPUSH
10076: LD_INT 6
10078: PPUSH
10079: LD_INT 2
10081: PPUSH
10082: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10086: LD_INT 58
10088: PPUSH
10089: LD_INT 6
10091: PPUSH
10092: LD_INT 2
10094: PPUSH
10095: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10099: LD_OWVAR 67
10103: PUSH
10104: LD_INT 4
10106: EQUAL
10107: PUSH
10108: LD_EXP 15
10112: PUSH
10113: LD_INT 10
10115: EQUAL
10116: OR
10117: IFFALSE 10145
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10119: LD_INT 53
10121: PPUSH
10122: LD_INT 6
10124: PPUSH
10125: LD_INT 2
10127: PPUSH
10128: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10132: LD_INT 59
10134: PPUSH
10135: LD_INT 6
10137: PPUSH
10138: LD_INT 2
10140: PPUSH
10141: CALL_OW 322
// end ; if activeAttacks then
10145: LD_EXP 16
10149: IFFALSE 10638
// begin if missionStage = 2 then
10151: LD_EXP 15
10155: PUSH
10156: LD_INT 2
10158: EQUAL
10159: IFFALSE 10169
// strength := 1 ;
10161: LD_ADDR_VAR 0 5
10165: PUSH
10166: LD_INT 1
10168: ST_TO_ADDR
// if missionStage > 2 then
10169: LD_EXP 15
10173: PUSH
10174: LD_INT 2
10176: GREATER
10177: IFFALSE 10187
// strength := 2 ;
10179: LD_ADDR_VAR 0 5
10183: PUSH
10184: LD_INT 2
10186: ST_TO_ADDR
// if missionStage > 6 then
10187: LD_EXP 15
10191: PUSH
10192: LD_INT 6
10194: GREATER
10195: IFFALSE 10205
// strength := 3 ;
10197: LD_ADDR_VAR 0 5
10201: PUSH
10202: LD_INT 3
10204: ST_TO_ADDR
// if missionStage > 10 then
10205: LD_EXP 15
10209: PUSH
10210: LD_INT 10
10212: GREATER
10213: IFFALSE 10223
// strength := 4 ;
10215: LD_ADDR_VAR 0 5
10219: PUSH
10220: LD_INT 4
10222: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10223: LD_ADDR_VAR 0 2
10227: PUSH
10228: LD_VAR 0 5
10232: PPUSH
10233: CALL 8716 0 1
10237: ST_TO_ADDR
// for i in tmp do
10238: LD_ADDR_VAR 0 1
10242: PUSH
10243: LD_VAR 0 2
10247: PUSH
10248: FOR_IN
10249: IFFALSE 10507
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10251: LD_VAR 0 1
10255: PPUSH
10256: LD_VAR 0 4
10260: PUSH
10261: LD_INT 1
10263: PPUSH
10264: LD_INT 2
10266: PPUSH
10267: CALL_OW 12
10271: ARRAY
10272: PPUSH
10273: LD_INT 0
10275: PPUSH
10276: CALL_OW 49
// if i = sewiVeh then
10280: LD_VAR 0 1
10284: PUSH
10285: LD_EXP 74
10289: EQUAL
10290: IFFALSE 10327
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10292: LD_ADDR_EXP 73
10296: PUSH
10297: LD_STRING Vsevolod
10299: PPUSH
10300: LD_INT 0
10302: PPUSH
10303: LD_STRING 
10305: PPUSH
10306: CALL 69442 0 3
10310: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10311: LD_EXP 73
10315: PPUSH
10316: LD_VAR 0 1
10320: PPUSH
10321: CALL_OW 52
// end else
10325: GO 10408
// if GetControl ( i ) = control_manual then
10327: LD_VAR 0 1
10331: PPUSH
10332: CALL_OW 263
10336: PUSH
10337: LD_INT 1
10339: EQUAL
10340: IFFALSE 10408
// begin uc_side := 6 ;
10342: LD_ADDR_OWVAR 20
10346: PUSH
10347: LD_INT 6
10349: ST_TO_ADDR
// uc_nation := 3 ;
10350: LD_ADDR_OWVAR 21
10354: PUSH
10355: LD_INT 3
10357: ST_TO_ADDR
// hc_gallery :=  ;
10358: LD_ADDR_OWVAR 33
10362: PUSH
10363: LD_STRING 
10365: ST_TO_ADDR
// hc_name :=  ;
10366: LD_ADDR_OWVAR 26
10370: PUSH
10371: LD_STRING 
10373: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10374: LD_INT 0
10376: PPUSH
10377: LD_INT 3
10379: PPUSH
10380: LD_INT 10
10382: PPUSH
10383: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10387: CALL_OW 44
10391: PPUSH
10392: LD_VAR 0 1
10396: PPUSH
10397: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10401: LD_INT 10
10403: PPUSH
10404: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10408: LD_INT 1
10410: PPUSH
10411: LD_INT 3
10413: PPUSH
10414: CALL_OW 12
10418: PUSH
10419: LD_INT 1
10421: DOUBLE
10422: EQUAL
10423: IFTRUE 10427
10425: GO 10445
10427: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10428: LD_VAR 0 1
10432: PPUSH
10433: LD_INT 111
10435: PPUSH
10436: LD_INT 197
10438: PPUSH
10439: CALL_OW 111
10443: GO 10498
10445: LD_INT 2
10447: DOUBLE
10448: EQUAL
10449: IFTRUE 10453
10451: GO 10471
10453: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10454: LD_VAR 0 1
10458: PPUSH
10459: LD_INT 91
10461: PPUSH
10462: LD_INT 165
10464: PPUSH
10465: CALL_OW 111
10469: GO 10498
10471: LD_INT 3
10473: DOUBLE
10474: EQUAL
10475: IFTRUE 10479
10477: GO 10497
10479: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10480: LD_VAR 0 1
10484: PPUSH
10485: LD_INT 137
10487: PPUSH
10488: LD_INT 157
10490: PPUSH
10491: CALL_OW 111
10495: GO 10498
10497: POP
// wait ( 0 0$2 ) ;
10498: LD_INT 70
10500: PPUSH
10501: CALL_OW 67
// end ;
10505: GO 10248
10507: POP
10508: POP
// repeat wait ( 0 0$1 ) ;
10509: LD_INT 35
10511: PPUSH
10512: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10516: LD_ADDR_VAR 0 1
10520: PUSH
10521: LD_VAR 0 2
10525: PPUSH
10526: LD_INT 50
10528: PUSH
10529: EMPTY
10530: LIST
10531: PPUSH
10532: CALL_OW 72
10536: PUSH
10537: FOR_IN
10538: IFFALSE 10597
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10540: LD_VAR 0 1
10544: PPUSH
10545: LD_INT 108
10547: PUSH
10548: LD_INT 153
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 105
10557: PUSH
10558: LD_INT 149
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: PUSH
10565: LD_INT 85
10567: PUSH
10568: LD_INT 131
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: LD_INT 64
10577: PUSH
10578: LD_INT 105
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: PPUSH
10591: CALL 109748 0 2
10595: GO 10537
10597: POP
10598: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10599: LD_VAR 0 2
10603: PPUSH
10604: LD_INT 3
10606: PUSH
10607: LD_INT 34
10609: PUSH
10610: LD_INT 49
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 50
10623: PUSH
10624: EMPTY
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: NOT
10636: IFFALSE 10509
// end ; until russianDestroyed ;
10638: LD_EXP 21
10642: IFFALSE 9989
// end ;
10644: PPOPN 6
10646: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10647: LD_EXP 21
10651: NOT
10652: PUSH
10653: LD_EXP 15
10657: PUSH
10658: LD_INT 6
10660: GREATEREQUAL
10661: AND
10662: IFFALSE 11682
10664: GO 10666
10666: DISABLE
10667: LD_INT 0
10669: PPUSH
10670: PPUSH
10671: PPUSH
10672: PPUSH
10673: PPUSH
// begin enable ;
10674: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10675: LD_INT 22
10677: PUSH
10678: LD_INT 3
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PUSH
10685: LD_INT 30
10687: PUSH
10688: LD_INT 3
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PPUSH
10699: CALL_OW 69
10703: NOT
10704: IFFALSE 10708
// exit ;
10706: GO 11682
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10708: LD_ADDR_VAR 0 4
10712: PUSH
10713: LD_INT 22
10715: PUSH
10716: LD_INT 3
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 30
10725: PUSH
10726: LD_INT 34
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: ST_TO_ADDR
// if Prob ( 40 ) then
10742: LD_INT 40
10744: PPUSH
10745: CALL_OW 13
10749: IFFALSE 10895
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10751: LD_INT 2
10753: PPUSH
10754: LD_INT 22
10756: PUSH
10757: LD_INT 3
10759: PUSH
10760: LD_INT 3
10762: PUSH
10763: LD_INT 49
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: LIST
10770: LIST
10771: PUSH
10772: LD_INT 22
10774: PUSH
10775: LD_INT 3
10777: PUSH
10778: LD_INT 3
10780: PUSH
10781: LD_INT 49
10783: PUSH
10784: EMPTY
10785: LIST
10786: LIST
10787: LIST
10788: LIST
10789: PUSH
10790: LD_INT 22
10792: PUSH
10793: LD_INT 3
10795: PUSH
10796: LD_INT 3
10798: PUSH
10799: LD_INT 49
10801: PUSH
10802: EMPTY
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: PUSH
10808: LD_INT 24
10810: PUSH
10811: LD_INT 3
10813: PUSH
10814: LD_INT 3
10816: PUSH
10817: LD_INT 46
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 24
10828: PUSH
10829: LD_INT 3
10831: PUSH
10832: LD_INT 3
10834: PUSH
10835: LD_INT 46
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: PUSH
10844: LD_INT 24
10846: PUSH
10847: LD_INT 3
10849: PUSH
10850: LD_INT 3
10852: PUSH
10853: LD_INT 46
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: PUSH
10862: LD_INT 24
10864: PUSH
10865: LD_INT 3
10867: PUSH
10868: LD_INT 3
10870: PUSH
10871: LD_INT 46
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PPUSH
10889: CALL 63016 0 2
// end else
10893: GO 11037
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10895: LD_INT 2
10897: PPUSH
10898: LD_INT 24
10900: PUSH
10901: LD_INT 3
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 47
10909: PUSH
10910: EMPTY
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: PUSH
10916: LD_INT 24
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 47
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: PUSH
10934: LD_INT 24
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 47
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: PUSH
10952: LD_INT 24
10954: PUSH
10955: LD_INT 3
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 46
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: PUSH
10970: LD_INT 24
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 46
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: LIST
10986: LIST
10987: PUSH
10988: LD_INT 24
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 46
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: PUSH
11006: LD_INT 24
11008: PUSH
11009: LD_INT 3
11011: PUSH
11012: LD_INT 3
11014: PUSH
11015: LD_INT 46
11017: PUSH
11018: EMPTY
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: PPUSH
11033: CALL 63016 0 2
// end ; wait ( 2 2$00 ) ;
11037: LD_INT 4200
11039: PPUSH
11040: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11044: LD_ADDR_VAR 0 2
11048: PUSH
11049: LD_INT 22
11051: PUSH
11052: LD_INT 3
11054: PUSH
11055: EMPTY
11056: LIST
11057: LIST
11058: PUSH
11059: LD_INT 21
11061: PUSH
11062: LD_INT 2
11064: PUSH
11065: EMPTY
11066: LIST
11067: LIST
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 34
11074: PUSH
11075: LD_INT 48
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: LD_INT 34
11084: PUSH
11085: LD_INT 51
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 34
11094: PUSH
11095: LD_INT 52
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: LIST
11112: PPUSH
11113: CALL_OW 69
11117: PUSH
11118: LD_EXP 123
11122: PUSH
11123: LD_INT 2
11125: ARRAY
11126: DIFF
11127: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11128: LD_ADDR_EXP 120
11132: PUSH
11133: LD_EXP 120
11137: PPUSH
11138: LD_INT 2
11140: PPUSH
11141: LD_EXP 120
11145: PUSH
11146: LD_INT 2
11148: ARRAY
11149: PUSH
11150: LD_VAR 0 2
11154: DIFF
11155: PPUSH
11156: CALL_OW 1
11160: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11161: LD_ADDR_VAR 0 3
11165: PUSH
11166: LD_INT 0
11168: PPUSH
11169: LD_INT 1
11171: PPUSH
11172: CALL_OW 12
11176: ST_TO_ADDR
// p := 0 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 0
11184: ST_TO_ADDR
// if target then
11185: LD_VAR 0 3
11189: IFFALSE 11342
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11191: LD_ADDR_VAR 0 2
11195: PUSH
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 24
11203: PUSH
11204: LD_INT 250
11206: PUSH
11207: EMPTY
11208: LIST
11209: LIST
11210: PPUSH
11211: CALL_OW 72
11215: ST_TO_ADDR
// for i in tmp do
11216: LD_ADDR_VAR 0 1
11220: PUSH
11221: LD_VAR 0 2
11225: PUSH
11226: FOR_IN
11227: IFFALSE 11267
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11229: LD_VAR 0 1
11233: PPUSH
11234: LD_INT 139
11236: PPUSH
11237: LD_INT 89
11239: PPUSH
11240: CALL_OW 297
11244: PUSH
11245: LD_INT 9
11247: GREATER
11248: IFFALSE 11265
// ComMoveXY ( i , 139 , 89 ) ;
11250: LD_VAR 0 1
11254: PPUSH
11255: LD_INT 139
11257: PPUSH
11258: LD_INT 89
11260: PPUSH
11261: CALL_OW 111
11265: GO 11226
11267: POP
11268: POP
// wait ( 0 0$1 ) ;
11269: LD_INT 35
11271: PPUSH
11272: CALL_OW 67
// p := Inc ( p ) ;
11276: LD_ADDR_VAR 0 5
11280: PUSH
11281: LD_VAR 0 5
11285: PPUSH
11286: CALL 108505 0 1
11290: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11291: LD_VAR 0 2
11295: PPUSH
11296: LD_INT 92
11298: PUSH
11299: LD_INT 139
11301: PUSH
11302: LD_INT 89
11304: PUSH
11305: LD_INT 9
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 72
11318: PUSH
11319: LD_VAR 0 2
11323: PUSH
11324: LD_INT 1
11326: MINUS
11327: GREATEREQUAL
11328: PUSH
11329: LD_VAR 0 5
11333: PUSH
11334: LD_INT 60
11336: GREATER
11337: OR
11338: IFFALSE 11191
// end else
11340: GO 11509
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11342: LD_VAR 0 2
11346: PPUSH
11347: LD_VAR 0 4
11351: PUSH
11352: LD_INT 1
11354: ARRAY
11355: PPUSH
11356: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11360: LD_ADDR_VAR 0 2
11364: PUSH
11365: LD_VAR 0 2
11369: PPUSH
11370: LD_INT 24
11372: PUSH
11373: LD_INT 250
11375: PUSH
11376: EMPTY
11377: LIST
11378: LIST
11379: PPUSH
11380: CALL_OW 72
11384: ST_TO_ADDR
// for i in tmp do
11385: LD_ADDR_VAR 0 1
11389: PUSH
11390: LD_VAR 0 2
11394: PUSH
11395: FOR_IN
11396: IFFALSE 11436
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11398: LD_VAR 0 1
11402: PPUSH
11403: LD_INT 124
11405: PPUSH
11406: LD_INT 139
11408: PPUSH
11409: CALL_OW 297
11413: PUSH
11414: LD_INT 9
11416: GREATER
11417: IFFALSE 11434
// ComMoveXY ( i , 124 , 139 ) ;
11419: LD_VAR 0 1
11423: PPUSH
11424: LD_INT 124
11426: PPUSH
11427: LD_INT 139
11429: PPUSH
11430: CALL_OW 111
11434: GO 11395
11436: POP
11437: POP
// wait ( 0 0$1 ) ;
11438: LD_INT 35
11440: PPUSH
11441: CALL_OW 67
// p := Inc ( p ) ;
11445: LD_ADDR_VAR 0 5
11449: PUSH
11450: LD_VAR 0 5
11454: PPUSH
11455: CALL 108505 0 1
11459: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11460: LD_VAR 0 2
11464: PPUSH
11465: LD_INT 92
11467: PUSH
11468: LD_INT 124
11470: PUSH
11471: LD_INT 139
11473: PUSH
11474: LD_INT 9
11476: PUSH
11477: EMPTY
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: PPUSH
11483: CALL_OW 72
11487: PUSH
11488: LD_VAR 0 2
11492: PUSH
11493: LD_INT 1
11495: MINUS
11496: GREATEREQUAL
11497: PUSH
11498: LD_VAR 0 5
11502: PUSH
11503: LD_INT 60
11505: GREATER
11506: OR
11507: IFFALSE 11360
// end ; repeat wait ( 0 0$1 ) ;
11509: LD_INT 35
11511: PPUSH
11512: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11516: LD_ADDR_VAR 0 2
11520: PUSH
11521: LD_VAR 0 2
11525: PPUSH
11526: LD_INT 50
11528: PUSH
11529: EMPTY
11530: LIST
11531: PPUSH
11532: CALL_OW 72
11536: ST_TO_ADDR
// for i in tmp do
11537: LD_ADDR_VAR 0 1
11541: PUSH
11542: LD_VAR 0 2
11546: PUSH
11547: FOR_IN
11548: IFFALSE 11673
// begin if GetWeapon ( i ) = ru_time_lapser then
11550: LD_VAR 0 1
11554: PPUSH
11555: CALL_OW 264
11559: PUSH
11560: LD_INT 49
11562: EQUAL
11563: IFFALSE 11619
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 2
11572: PUSH
11573: LD_INT 22
11575: PUSH
11576: LD_INT 1
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: PUSH
11583: LD_INT 22
11585: PUSH
11586: LD_INT 8
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: LIST
11597: PPUSH
11598: CALL_OW 69
11602: PPUSH
11603: LD_VAR 0 1
11607: PPUSH
11608: CALL_OW 74
11612: PPUSH
11613: CALL_OW 112
11617: GO 11671
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11619: LD_VAR 0 1
11623: PPUSH
11624: LD_INT 2
11626: PUSH
11627: LD_INT 22
11629: PUSH
11630: LD_INT 1
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: PUSH
11637: LD_INT 22
11639: PUSH
11640: LD_INT 8
11642: PUSH
11643: EMPTY
11644: LIST
11645: LIST
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: LIST
11651: PPUSH
11652: CALL_OW 69
11656: PPUSH
11657: LD_VAR 0 1
11661: PPUSH
11662: CALL_OW 74
11666: PPUSH
11667: CALL_OW 115
// end ;
11671: GO 11547
11673: POP
11674: POP
// until not tmp ;
11675: LD_VAR 0 2
11679: NOT
11680: IFFALSE 11509
// end ;
11682: PPOPN 5
11684: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11685: LD_EXP 15
11689: PUSH
11690: LD_INT 7
11692: GREATEREQUAL
11693: PUSH
11694: LD_OWVAR 67
11698: PUSH
11699: LD_INT 1
11701: GREATER
11702: AND
11703: IFFALSE 11995
11705: GO 11707
11707: DISABLE
11708: LD_INT 0
11710: PPUSH
11711: PPUSH
11712: PPUSH
// begin ruMobile := [ ] ;
11713: LD_ADDR_EXP 77
11717: PUSH
11718: EMPTY
11719: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11720: LD_ADDR_VAR 0 1
11724: PUSH
11725: DOUBLE
11726: LD_INT 1
11728: DEC
11729: ST_TO_ADDR
11730: LD_INT 4
11732: PUSH
11733: LD_INT 5
11735: PUSH
11736: LD_INT 6
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PUSH
11744: LD_OWVAR 67
11748: PUSH
11749: LD_INT 1
11751: MINUS
11752: ARRAY
11753: PUSH
11754: FOR_TO
11755: IFFALSE 11993
// begin uc_side := 3 ;
11757: LD_ADDR_OWVAR 20
11761: PUSH
11762: LD_INT 3
11764: ST_TO_ADDR
// uc_nation := 1 ;
11765: LD_ADDR_OWVAR 21
11769: PUSH
11770: LD_INT 1
11772: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11773: LD_INT 5
11775: PPUSH
11776: LD_INT 3
11778: PPUSH
11779: LD_INT 1
11781: PPUSH
11782: LD_INT 9
11784: PUSH
11785: LD_INT 7
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 1
11796: PUSH
11797: LD_INT 2
11799: MOD
11800: PUSH
11801: LD_INT 1
11803: PLUS
11804: ARRAY
11805: PPUSH
11806: LD_INT 100
11808: PPUSH
11809: CALL 74282 0 5
// veh := CreateVehicle ;
11813: LD_ADDR_VAR 0 2
11817: PUSH
11818: CALL_OW 45
11822: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11823: LD_VAR 0 2
11827: PPUSH
11828: LD_INT 3
11830: PPUSH
11831: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11835: LD_VAR 0 2
11839: PPUSH
11840: LD_INT 29
11842: PPUSH
11843: LD_INT 0
11845: PPUSH
11846: CALL_OW 49
// uc_nation := 3 ;
11850: LD_ADDR_OWVAR 21
11854: PUSH
11855: LD_INT 3
11857: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11858: LD_INT 0
11860: PPUSH
11861: LD_INT 10
11863: PPUSH
11864: CALL_OW 383
// un := CreateHuman ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: CALL_OW 44
11877: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11878: LD_VAR 0 3
11882: PPUSH
11883: LD_INT 105
11885: PPUSH
11886: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_INT 3
11897: PPUSH
11898: CALL_OW 259
11902: PUSH
11903: LD_INT 8
11905: PUSH
11906: LD_INT 9
11908: PUSH
11909: LD_INT 10
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: PUSH
11917: LD_OWVAR 67
11921: ARRAY
11922: LESS
11923: IFFALSE 11957
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11925: LD_VAR 0 3
11929: PPUSH
11930: LD_INT 3
11932: PPUSH
11933: LD_INT 8
11935: PUSH
11936: LD_INT 9
11938: PUSH
11939: LD_INT 10
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: PUSH
11947: LD_OWVAR 67
11951: ARRAY
11952: PPUSH
11953: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
11957: LD_VAR 0 3
11961: PPUSH
11962: LD_VAR 0 2
11966: PPUSH
11967: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11971: LD_ADDR_EXP 77
11975: PUSH
11976: LD_EXP 77
11980: PPUSH
11981: LD_VAR 0 2
11985: PPUSH
11986: CALL 107144 0 2
11990: ST_TO_ADDR
// end ;
11991: GO 11754
11993: POP
11994: POP
// end ;
11995: PPOPN 3
11997: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11998: LD_EXP 77
12002: IFFALSE 12511
12004: GO 12006
12006: DISABLE
12007: LD_INT 0
12009: PPUSH
12010: PPUSH
12011: PPUSH
// begin enable ;
12012: ENABLE
// if not ruMobile then
12013: LD_EXP 77
12017: NOT
12018: IFFALSE 12023
// begin disable ;
12020: DISABLE
// exit ;
12021: GO 12511
// end ; for i in ruMobile do
12023: LD_ADDR_VAR 0 1
12027: PUSH
12028: LD_EXP 77
12032: PUSH
12033: FOR_IN
12034: IFFALSE 12509
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12036: LD_VAR 0 1
12040: PPUSH
12041: CALL_OW 302
12045: NOT
12046: PUSH
12047: LD_VAR 0 1
12051: PPUSH
12052: CALL_OW 255
12056: PUSH
12057: LD_INT 3
12059: NONEQUAL
12060: OR
12061: IFFALSE 12081
// begin ruMobile := ruMobile diff i ;
12063: LD_ADDR_EXP 77
12067: PUSH
12068: LD_EXP 77
12072: PUSH
12073: LD_VAR 0 1
12077: DIFF
12078: ST_TO_ADDR
// continue ;
12079: GO 12033
// end ; if GetTag ( i ) = 300 then
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL_OW 110
12090: PUSH
12091: LD_INT 300
12093: EQUAL
12094: IFFALSE 12144
// begin ComMoveXY ( i , 160 , 81 ) ;
12096: LD_VAR 0 1
12100: PPUSH
12101: LD_INT 160
12103: PPUSH
12104: LD_INT 81
12106: PPUSH
12107: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12111: LD_VAR 0 1
12115: PPUSH
12116: LD_INT 160
12118: PPUSH
12119: LD_INT 81
12121: PPUSH
12122: CALL_OW 297
12126: PUSH
12127: LD_INT 8
12129: LESS
12130: IFFALSE 12144
// SetTag ( i , 301 ) ;
12132: LD_VAR 0 1
12136: PPUSH
12137: LD_INT 301
12139: PPUSH
12140: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12144: LD_VAR 0 1
12148: PPUSH
12149: CALL_OW 110
12153: PUSH
12154: LD_INT 301
12156: EQUAL
12157: IFFALSE 12200
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12159: LD_VAR 0 1
12163: PPUSH
12164: LD_INT 33
12166: PPUSH
12167: CALL_OW 308
12171: NOT
12172: IFFALSE 12188
// ComMoveToArea ( i , ruMobileParkingArea ) else
12174: LD_VAR 0 1
12178: PPUSH
12179: LD_INT 33
12181: PPUSH
12182: CALL_OW 113
12186: GO 12200
// SetTag ( i , 302 ) ;
12188: LD_VAR 0 1
12192: PPUSH
12193: LD_INT 302
12195: PPUSH
12196: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12200: LD_VAR 0 1
12204: PPUSH
12205: CALL_OW 110
12209: PUSH
12210: LD_INT 302
12212: EQUAL
12213: IFFALSE 12343
// begin if GetLives ( i ) < 1000 then
12215: LD_VAR 0 1
12219: PPUSH
12220: CALL_OW 256
12224: PUSH
12225: LD_INT 1000
12227: LESS
12228: IFFALSE 12320
// begin if not IsDrivenBy ( i ) then
12230: LD_VAR 0 1
12234: PPUSH
12235: CALL_OW 311
12239: NOT
12240: IFFALSE 12244
// continue ;
12242: GO 12033
// mech := IsDrivenBy ( i ) ;
12244: LD_ADDR_VAR 0 2
12248: PUSH
12249: LD_VAR 0 1
12253: PPUSH
12254: CALL_OW 311
12258: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12259: LD_VAR 0 2
12263: PPUSH
12264: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12268: LD_VAR 0 2
12272: PPUSH
12273: LD_VAR 0 1
12277: PPUSH
12278: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12282: LD_INT 35
12284: PPUSH
12285: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 256
12298: PUSH
12299: LD_INT 1000
12301: EQUAL
12302: IFFALSE 12282
// ComEnterUnit ( mech , i ) ;
12304: LD_VAR 0 2
12308: PPUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 120
// end else
12318: GO 12343
// if IsDrivenBy ( i ) then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 311
12329: IFFALSE 12343
// SetTag ( i , 0 ) ;
12331: LD_VAR 0 1
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12343: LD_VAR 0 1
12347: PPUSH
12348: CALL_OW 110
12352: PUSH
12353: LD_INT 300
12355: LESS
12356: IFFALSE 12507
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12358: LD_ADDR_VAR 0 3
12362: PUSH
12363: LD_INT 4
12365: PPUSH
12366: LD_INT 81
12368: PUSH
12369: LD_INT 3
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PPUSH
12376: CALL_OW 70
12380: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12381: LD_VAR 0 1
12385: PPUSH
12386: CALL_OW 256
12390: PUSH
12391: LD_INT 650
12393: LESS
12394: IFFALSE 12419
// begin ComStop ( i ) ;
12396: LD_VAR 0 1
12400: PPUSH
12401: CALL_OW 141
// SetTag ( i , 300 ) ;
12405: LD_VAR 0 1
12409: PPUSH
12410: LD_INT 300
12412: PPUSH
12413: CALL_OW 109
// continue ;
12417: GO 12033
// end ; if enemy then
12419: LD_VAR 0 3
12423: IFFALSE 12463
// begin if not HasTask ( i ) then
12425: LD_VAR 0 1
12429: PPUSH
12430: CALL_OW 314
12434: NOT
12435: IFFALSE 12461
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12437: LD_VAR 0 1
12441: PPUSH
12442: LD_VAR 0 3
12446: PPUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 74
12456: PPUSH
12457: CALL_OW 115
// end else
12461: GO 12507
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12463: LD_VAR 0 1
12467: PPUSH
12468: LD_INT 158
12470: PUSH
12471: LD_INT 61
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 98
12480: PUSH
12481: LD_INT 100
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 78
12490: PUSH
12491: LD_INT 93
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: PPUSH
12503: CALL 109748 0 2
// end ; end ;
12507: GO 12033
12509: POP
12510: POP
// end ; end_of_file
12511: PPOPN 3
12513: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12514: LD_INT 0
12516: PPUSH
12517: PPUSH
12518: PPUSH
12519: PPUSH
12520: PPUSH
12521: PPUSH
12522: PPUSH
// SetInvulnrability ( alien , true ) ;
12523: LD_INT 1
12525: PPUSH
12526: LD_INT 1
12528: PPUSH
12529: CALL_OW 607
// side := 7 ;
12533: LD_ADDR_VAR 0 5
12537: PUSH
12538: LD_INT 7
12540: ST_TO_ADDR
// uc_side := side ;
12541: LD_ADDR_OWVAR 20
12545: PUSH
12546: LD_VAR 0 5
12550: ST_TO_ADDR
// uc_nation := 1 ;
12551: LD_ADDR_OWVAR 21
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12559: LD_ADDR_VAR 0 2
12563: PUSH
12564: LD_INT 22
12566: PUSH
12567: LD_VAR 0 5
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: LD_INT 21
12578: PUSH
12579: LD_INT 3
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PPUSH
12590: CALL_OW 69
12594: PUSH
12595: FOR_IN
12596: IFFALSE 12612
// SetBLevel ( i , 10 ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: LD_INT 10
12605: PPUSH
12606: CALL_OW 241
12610: GO 12595
12612: POP
12613: POP
// base := GetBase ( al_depot ) ;
12614: LD_ADDR_VAR 0 4
12618: PUSH
12619: LD_INT 2
12621: PPUSH
12622: CALL_OW 274
12626: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12627: LD_ADDR_VAR 0 6
12631: PUSH
12632: LD_INT 22
12634: PUSH
12635: LD_VAR 0 5
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 30
12646: PUSH
12647: LD_INT 34
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if teleport then
12663: LD_VAR 0 6
12667: IFFALSE 12688
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12669: LD_VAR 0 6
12673: PUSH
12674: LD_INT 1
12676: ARRAY
12677: PPUSH
12678: LD_INT 262
12680: PPUSH
12681: LD_INT 119
12683: PPUSH
12684: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12688: LD_VAR 0 4
12692: PPUSH
12693: LD_INT 1
12695: PPUSH
12696: LD_INT 19500
12698: PPUSH
12699: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12703: LD_VAR 0 4
12707: PPUSH
12708: LD_INT 2
12710: PPUSH
12711: LD_INT 200
12713: PPUSH
12714: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12718: LD_VAR 0 4
12722: PPUSH
12723: LD_INT 3
12725: PPUSH
12726: LD_INT 650
12728: PPUSH
12729: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12733: LD_ADDR_EXP 78
12737: PUSH
12738: LD_STRING Roth
12740: PPUSH
12741: CALL_OW 25
12745: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12746: LD_ADDR_EXP 79
12750: PUSH
12751: LD_STRING Simms
12753: PPUSH
12754: LD_EXP 1
12758: NOT
12759: PPUSH
12760: LD_STRING 10c_
12762: PPUSH
12763: CALL 69442 0 3
12767: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12768: LD_EXP 79
12772: PPUSH
12773: LD_INT 4
12775: PPUSH
12776: CALL_OW 336
// if not Simms then
12780: LD_EXP 79
12784: NOT
12785: IFFALSE 12815
// begin uc_nation := 1 ;
12787: LD_ADDR_OWVAR 21
12791: PUSH
12792: LD_INT 1
12794: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12795: LD_INT 2
12797: PPUSH
12798: LD_INT 10
12800: PPUSH
12801: CALL_OW 384
// Simms := CreateHuman ;
12805: LD_ADDR_EXP 79
12809: PUSH
12810: CALL_OW 44
12814: ST_TO_ADDR
// end ; uc_nation := 3 ;
12815: LD_ADDR_OWVAR 21
12819: PUSH
12820: LD_INT 3
12822: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12823: LD_ADDR_EXP 80
12827: PUSH
12828: LD_STRING Kirilenkova
12830: PPUSH
12831: CALL_OW 25
12835: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12836: LD_ADDR_EXP 94
12840: PUSH
12841: LD_STRING Oblukov
12843: PPUSH
12844: CALL_OW 25
12848: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12849: LD_ADDR_EXP 81
12853: PUSH
12854: LD_STRING Dolgov
12856: PPUSH
12857: CALL_OW 25
12861: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12862: LD_ADDR_EXP 82
12866: PUSH
12867: LD_STRING Petrosyan
12869: PPUSH
12870: CALL_OW 25
12874: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12875: LD_ADDR_EXP 93
12879: PUSH
12880: LD_STRING Scholtze
12882: PPUSH
12883: CALL_OW 25
12887: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12888: LD_ADDR_EXP 92
12892: PUSH
12893: LD_STRING Kapitsova
12895: PPUSH
12896: CALL_OW 25
12900: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12901: LD_ADDR_EXP 83
12905: PUSH
12906: LD_STRING Petrovova
12908: PPUSH
12909: CALL_OW 25
12913: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12914: LD_ADDR_EXP 84
12918: PUSH
12919: LD_STRING Kuzmov
12921: PPUSH
12922: CALL_OW 25
12926: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12927: LD_ADDR_EXP 91
12931: PUSH
12932: LD_STRING Karamazov
12934: PPUSH
12935: CALL_OW 25
12939: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12940: LD_STRING 13_Lipshchin_1
12942: PPUSH
12943: LD_INT 0
12945: PPUSH
12946: CALL_OW 30
12950: IFFALSE 12965
// Lipshchin := NewCharacter ( Lipshchin ) ;
12952: LD_ADDR_EXP 85
12956: PUSH
12957: LD_STRING Lipshchin
12959: PPUSH
12960: CALL_OW 25
12964: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12965: LD_STRING 13_Titov_1
12967: PPUSH
12968: LD_INT 0
12970: PPUSH
12971: CALL_OW 30
12975: IFFALSE 12990
// Titov := NewCharacter ( Titov ) ;
12977: LD_ADDR_EXP 87
12981: PUSH
12982: LD_STRING Titov
12984: PPUSH
12985: CALL_OW 25
12989: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12990: LD_STRING 13_Gnyevko_1
12992: PPUSH
12993: LD_INT 0
12995: PPUSH
12996: CALL_OW 30
13000: IFFALSE 13015
// Gnyevko := NewCharacter ( Gnyevko ) ;
13002: LD_ADDR_EXP 86
13006: PUSH
13007: LD_STRING Gnyevko
13009: PPUSH
13010: CALL_OW 25
13014: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13015: LD_STRING 13_Xavier_1
13017: PPUSH
13018: LD_INT 0
13020: PPUSH
13021: CALL_OW 30
13025: IFFALSE 13040
// Xavier := NewCharacter ( Xavier2 ) ;
13027: LD_ADDR_EXP 88
13031: PUSH
13032: LD_STRING Xavier2
13034: PPUSH
13035: CALL_OW 25
13039: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13040: LD_STRING 13_Belkov_1
13042: PPUSH
13043: LD_INT 0
13045: PPUSH
13046: CALL_OW 30
13050: IFFALSE 13065
// Belkov := NewCharacter ( Belkov ) ;
13052: LD_ADDR_EXP 89
13056: PUSH
13057: LD_STRING Belkov
13059: PPUSH
13060: CALL_OW 25
13064: ST_TO_ADDR
// if not BurlakStatus then
13065: LD_EXP 9
13069: NOT
13070: IFFALSE 13085
// Burlak = NewCharacter ( Burlak ) ;
13072: LD_ADDR_EXP 90
13076: PUSH
13077: LD_STRING Burlak
13079: PPUSH
13080: CALL_OW 25
13084: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13085: LD_ADDR_VAR 0 3
13089: PUSH
13090: LD_EXP 78
13094: PUSH
13095: LD_EXP 80
13099: PUSH
13100: LD_EXP 94
13104: PUSH
13105: LD_EXP 81
13109: PUSH
13110: LD_EXP 82
13114: PUSH
13115: LD_EXP 93
13119: PUSH
13120: LD_EXP 92
13124: PUSH
13125: LD_EXP 83
13129: PUSH
13130: LD_EXP 84
13134: PUSH
13135: LD_EXP 91
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: ST_TO_ADDR
// if Simms then
13152: LD_EXP 79
13156: IFFALSE 13174
// tmp := tmp ^ Simms ;
13158: LD_ADDR_VAR 0 3
13162: PUSH
13163: LD_VAR 0 3
13167: PUSH
13168: LD_EXP 79
13172: ADD
13173: ST_TO_ADDR
// if Titov then
13174: LD_EXP 87
13178: IFFALSE 13196
// tmp := tmp ^ Titov ;
13180: LD_ADDR_VAR 0 3
13184: PUSH
13185: LD_VAR 0 3
13189: PUSH
13190: LD_EXP 87
13194: ADD
13195: ST_TO_ADDR
// if Lipshchin then
13196: LD_EXP 85
13200: IFFALSE 13218
// tmp := tmp ^ Lipshchin ;
13202: LD_ADDR_VAR 0 3
13206: PUSH
13207: LD_VAR 0 3
13211: PUSH
13212: LD_EXP 85
13216: ADD
13217: ST_TO_ADDR
// if Gnyevko then
13218: LD_EXP 86
13222: IFFALSE 13240
// tmp := tmp ^ Gnyevko ;
13224: LD_ADDR_VAR 0 3
13228: PUSH
13229: LD_VAR 0 3
13233: PUSH
13234: LD_EXP 86
13238: ADD
13239: ST_TO_ADDR
// if Xavier then
13240: LD_EXP 88
13244: IFFALSE 13262
// tmp := tmp ^ Xavier ;
13246: LD_ADDR_VAR 0 3
13250: PUSH
13251: LD_VAR 0 3
13255: PUSH
13256: LD_EXP 88
13260: ADD
13261: ST_TO_ADDR
// if Belkov then
13262: LD_EXP 89
13266: IFFALSE 13284
// tmp := tmp ^ Belkov ;
13268: LD_ADDR_VAR 0 3
13272: PUSH
13273: LD_VAR 0 3
13277: PUSH
13278: LD_EXP 89
13282: ADD
13283: ST_TO_ADDR
// if Burlak then
13284: LD_EXP 90
13288: IFFALSE 13306
// tmp := tmp ^ Burlak ;
13290: LD_ADDR_VAR 0 3
13294: PUSH
13295: LD_VAR 0 3
13299: PUSH
13300: LD_EXP 90
13304: ADD
13305: ST_TO_ADDR
// for i = 1 to 11 do
13306: LD_ADDR_VAR 0 2
13310: PUSH
13311: DOUBLE
13312: LD_INT 1
13314: DEC
13315: ST_TO_ADDR
13316: LD_INT 11
13318: PUSH
13319: FOR_TO
13320: IFFALSE 13388
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13322: LD_ADDR_OWVAR 21
13326: PUSH
13327: LD_INT 1
13329: PUSH
13330: LD_INT 3
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: PUSH
13337: LD_INT 1
13339: PPUSH
13340: LD_INT 2
13342: PPUSH
13343: CALL_OW 12
13347: ARRAY
13348: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13349: LD_INT 0
13351: PPUSH
13352: LD_INT 1
13354: PPUSH
13355: LD_INT 4
13357: PPUSH
13358: CALL_OW 12
13362: PPUSH
13363: LD_INT 10
13365: PPUSH
13366: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13370: LD_ADDR_VAR 0 3
13374: PUSH
13375: LD_VAR 0 3
13379: PUSH
13380: CALL_OW 44
13384: ADD
13385: ST_TO_ADDR
// end ;
13386: GO 13319
13388: POP
13389: POP
// for i in tmp do
13390: LD_ADDR_VAR 0 2
13394: PUSH
13395: LD_VAR 0 3
13399: PUSH
13400: FOR_IN
13401: IFFALSE 13426
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13403: LD_VAR 0 2
13407: PPUSH
13408: LD_INT 260
13410: PPUSH
13411: LD_INT 235
13413: PPUSH
13414: LD_INT 8
13416: PPUSH
13417: LD_INT 0
13419: PPUSH
13420: CALL_OW 50
13424: GO 13400
13426: POP
13427: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13428: LD_ADDR_EXP 101
13432: PUSH
13433: LD_EXP 101
13437: PPUSH
13438: LD_INT 1
13440: PPUSH
13441: LD_INT 22
13443: PUSH
13444: LD_VAR 0 5
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PUSH
13453: LD_INT 3
13455: PUSH
13456: LD_INT 21
13458: PUSH
13459: LD_INT 2
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PPUSH
13474: CALL_OW 69
13478: PUSH
13479: LD_EXP 78
13483: PUSH
13484: LD_EXP 79
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: DIFF
13493: PPUSH
13494: CALL_OW 1
13498: ST_TO_ADDR
// uc_side := 0 ;
13499: LD_ADDR_OWVAR 20
13503: PUSH
13504: LD_INT 0
13506: ST_TO_ADDR
// uc_nation := 0 ;
13507: LD_ADDR_OWVAR 21
13511: PUSH
13512: LD_INT 0
13514: ST_TO_ADDR
// for i = 1 to 5 do
13515: LD_ADDR_VAR 0 2
13519: PUSH
13520: DOUBLE
13521: LD_INT 1
13523: DEC
13524: ST_TO_ADDR
13525: LD_INT 5
13527: PUSH
13528: FOR_TO
13529: IFFALSE 13566
// begin InitHc ;
13531: CALL_OW 19
// hc_class := class_apeman ;
13535: LD_ADDR_OWVAR 28
13539: PUSH
13540: LD_INT 12
13542: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13543: CALL_OW 44
13547: PPUSH
13548: LD_INT 299
13550: PPUSH
13551: LD_INT 229
13553: PPUSH
13554: LD_INT 10
13556: PPUSH
13557: LD_INT 0
13559: PPUSH
13560: CALL_OW 50
// end ;
13564: GO 13528
13566: POP
13567: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13568: LD_EXP 78
13572: PPUSH
13573: LD_INT 259
13575: PPUSH
13576: LD_INT 235
13578: PPUSH
13579: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13583: LD_EXP 78
13587: PPUSH
13588: LD_INT 262
13590: PPUSH
13591: LD_INT 235
13593: PPUSH
13594: CALL_OW 178
// if Simms then
13598: LD_EXP 79
13602: IFFALSE 13633
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13604: LD_EXP 79
13608: PPUSH
13609: LD_INT 262
13611: PPUSH
13612: LD_INT 235
13614: PPUSH
13615: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13619: LD_EXP 79
13623: PPUSH
13624: LD_EXP 78
13628: PPUSH
13629: CALL_OW 179
// end ; uc_side := 7 ;
13633: LD_ADDR_OWVAR 20
13637: PUSH
13638: LD_INT 7
13640: ST_TO_ADDR
// uc_nation := 1 ;
13641: LD_ADDR_OWVAR 21
13645: PUSH
13646: LD_INT 1
13648: ST_TO_ADDR
// bc_type := b_control_tower ;
13649: LD_ADDR_OWVAR 42
13653: PUSH
13654: LD_INT 36
13656: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13657: LD_ADDR_VAR 0 7
13661: PUSH
13662: LD_INT 268
13664: PPUSH
13665: LD_INT 251
13667: PPUSH
13668: LD_INT 4
13670: PPUSH
13671: CALL_OW 47
13675: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13676: LD_INT 0
13678: PPUSH
13679: LD_INT 10
13681: PPUSH
13682: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13686: CALL_OW 44
13690: PPUSH
13691: LD_VAR 0 7
13695: PPUSH
13696: CALL_OW 52
// end ;
13700: LD_VAR 0 1
13704: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13705: LD_EXP 31
13709: PUSH
13710: LD_EXP 23
13714: NOT
13715: AND
13716: PUSH
13717: LD_INT 22
13719: PUSH
13720: LD_INT 7
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PUSH
13727: LD_INT 30
13729: PUSH
13730: LD_INT 8
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PPUSH
13741: CALL_OW 69
13745: AND
13746: IFFALSE 13974
13748: GO 13750
13750: DISABLE
13751: LD_INT 0
13753: PPUSH
13754: PPUSH
13755: PPUSH
// begin enable ;
13756: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13757: LD_ADDR_VAR 0 2
13761: PUSH
13762: LD_INT 81
13764: PUSH
13765: LD_INT 7
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PUSH
13772: LD_INT 2
13774: PUSH
13775: LD_INT 32
13777: PUSH
13778: LD_INT 3
13780: PUSH
13781: EMPTY
13782: LIST
13783: LIST
13784: PUSH
13785: LD_INT 30
13787: PUSH
13788: LD_INT 30
13790: PUSH
13791: EMPTY
13792: LIST
13793: LIST
13794: PUSH
13795: LD_INT 30
13797: PUSH
13798: LD_INT 28
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: PUSH
13805: LD_INT 34
13807: PUSH
13808: LD_INT 49
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PUSH
13815: LD_INT 34
13817: PUSH
13818: LD_INT 10
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: LD_INT 34
13827: PUSH
13828: LD_INT 8
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: PUSH
13844: EMPTY
13845: LIST
13846: LIST
13847: PPUSH
13848: CALL_OW 69
13852: ST_TO_ADDR
// if not tmp then
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13862
// exit ;
13860: GO 13974
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13862: LD_VAR 0 2
13866: PPUSH
13867: LD_INT 34
13869: PUSH
13870: LD_INT 8
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: PPUSH
13877: CALL_OW 72
13881: IFFALSE 13914
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13883: LD_ADDR_VAR 0 3
13887: PUSH
13888: LD_VAR 0 2
13892: PPUSH
13893: LD_INT 34
13895: PUSH
13896: LD_INT 8
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: PPUSH
13903: CALL_OW 72
13907: PUSH
13908: LD_INT 1
13910: ARRAY
13911: ST_TO_ADDR
13912: GO 13938
// target := tmp [ rand ( 1 , tmp ) ] ;
13914: LD_ADDR_VAR 0 3
13918: PUSH
13919: LD_VAR 0 2
13923: PUSH
13924: LD_INT 1
13926: PPUSH
13927: LD_VAR 0 2
13931: PPUSH
13932: CALL_OW 12
13936: ARRAY
13937: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13938: LD_VAR 0 3
13942: PPUSH
13943: CALL_OW 255
13947: PUSH
13948: LD_INT 1
13950: EQUAL
13951: IFFALSE 13962
// CenterNowOnUnits ( target ) ;
13953: LD_VAR 0 3
13957: PPUSH
13958: CALL_OW 87
// SetLives ( target , 0 ) ;
13962: LD_VAR 0 3
13966: PPUSH
13967: LD_INT 0
13969: PPUSH
13970: CALL_OW 234
// end ;
13974: PPOPN 3
13976: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13977: LD_EXP 23
13981: NOT
13982: PUSH
13983: LD_EXP 31
13987: AND
13988: IFFALSE 14504
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
13996: PPUSH
13997: PPUSH
// begin uc_side := 7 ;
13998: LD_ADDR_OWVAR 20
14002: PUSH
14003: LD_INT 7
14005: ST_TO_ADDR
// uc_nation := 1 ;
14006: LD_ADDR_OWVAR 21
14010: PUSH
14011: LD_INT 1
14013: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14014: LD_ADDR_VAR 0 3
14018: PUSH
14019: LD_INT 125
14021: PUSH
14022: LD_INT 163
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 185
14031: PUSH
14032: LD_INT 168
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 111
14041: PUSH
14042: LD_INT 97
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: LD_INT 94
14051: PUSH
14052: LD_INT 114
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: PPUSH
14065: CALL 107249 0 1
14069: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14070: LD_ADDR_EXP 95
14074: PUSH
14075: EMPTY
14076: ST_TO_ADDR
// for i = 1 to Difficulty do
14077: LD_ADDR_VAR 0 1
14081: PUSH
14082: DOUBLE
14083: LD_INT 1
14085: DEC
14086: ST_TO_ADDR
14087: LD_OWVAR 67
14091: PUSH
14092: FOR_TO
14093: IFFALSE 14251
// begin InitHc ;
14095: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14099: LD_INT 0
14101: PPUSH
14102: LD_INT 8
14104: PPUSH
14105: CALL_OW 381
// un := CreateHuman ;
14109: LD_ADDR_VAR 0 2
14113: PUSH
14114: CALL_OW 44
14118: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14119: LD_VAR 0 2
14123: PPUSH
14124: LD_INT 258
14126: PPUSH
14127: LD_INT 267
14129: PPUSH
14130: LD_INT 4
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14140: LD_ADDR_EXP 95
14144: PUSH
14145: LD_EXP 95
14149: PUSH
14150: LD_VAR 0 2
14154: UNION
14155: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_VAR 0 3
14165: PUSH
14166: LD_VAR 0 1
14170: ARRAY
14171: PUSH
14172: LD_INT 1
14174: ARRAY
14175: PPUSH
14176: LD_VAR 0 3
14180: PUSH
14181: LD_VAR 0 1
14185: ARRAY
14186: PUSH
14187: LD_INT 2
14189: ARRAY
14190: PPUSH
14191: LD_INT 4
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14201: LD_VAR 0 2
14205: PPUSH
14206: LD_VAR 0 3
14210: PUSH
14211: LD_VAR 0 1
14215: ARRAY
14216: PUSH
14217: LD_INT 1
14219: ARRAY
14220: PPUSH
14221: LD_VAR 0 3
14225: PUSH
14226: LD_VAR 0 1
14230: ARRAY
14231: PUSH
14232: LD_INT 2
14234: ARRAY
14235: PPUSH
14236: CALL_OW 171
// AddComInvisible ( un ) ;
14240: LD_VAR 0 2
14244: PPUSH
14245: CALL_OW 212
// end ;
14249: GO 14092
14251: POP
14252: POP
// repeat wait ( 0 0$45 ) ;
14253: LD_INT 1575
14255: PPUSH
14256: CALL_OW 67
// for i in allianceSpecialForce do
14260: LD_ADDR_VAR 0 1
14264: PUSH
14265: LD_EXP 95
14269: PUSH
14270: FOR_IN
14271: IFFALSE 14489
// begin if IsInvisible ( i ) then
14273: LD_VAR 0 1
14277: PPUSH
14278: CALL_OW 571
14282: IFFALSE 14458
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14284: LD_ADDR_VAR 0 3
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 1
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 50
14301: PUSH
14302: EMPTY
14303: LIST
14304: PUSH
14305: LD_INT 56
14307: PUSH
14308: EMPTY
14309: LIST
14310: PUSH
14311: LD_INT 91
14313: PUSH
14314: LD_VAR 0 1
14318: PUSH
14319: LD_INT 25
14321: PUSH
14322: EMPTY
14323: LIST
14324: LIST
14325: LIST
14326: PUSH
14327: LD_INT 2
14329: PUSH
14330: LD_INT 25
14332: PUSH
14333: LD_INT 1
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PUSH
14340: LD_INT 25
14342: PUSH
14343: LD_INT 2
14345: PUSH
14346: EMPTY
14347: LIST
14348: LIST
14349: PUSH
14350: LD_INT 25
14352: PUSH
14353: LD_INT 3
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 25
14362: PUSH
14363: LD_INT 4
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: PUSH
14370: LD_INT 25
14372: PUSH
14373: LD_INT 5
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: PUSH
14380: LD_INT 25
14382: PUSH
14383: LD_INT 8
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: PPUSH
14406: CALL_OW 69
14410: ST_TO_ADDR
// if not tmp then
14411: LD_VAR 0 3
14415: NOT
14416: IFFALSE 14420
// continue ;
14418: GO 14270
// if Prob ( 30 * Difficulty ) then
14420: LD_INT 30
14422: PUSH
14423: LD_OWVAR 67
14427: MUL
14428: PPUSH
14429: CALL_OW 13
14433: IFFALSE 14458
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14435: LD_VAR 0 3
14439: PUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_VAR 0 3
14447: PPUSH
14448: CALL_OW 12
14452: ARRAY
14453: PPUSH
14454: CALL 34540 0 1
// end ; if IsDead ( i ) then
14458: LD_VAR 0 1
14462: PPUSH
14463: CALL_OW 301
14467: IFFALSE 14487
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14469: LD_ADDR_EXP 95
14473: PUSH
14474: LD_EXP 95
14478: PUSH
14479: LD_VAR 0 1
14483: DIFF
14484: ST_TO_ADDR
// continue ;
14485: GO 14270
// end ; end ;
14487: GO 14270
14489: POP
14490: POP
// until allianceDestroyed or not allianceSpecialForce ;
14491: LD_EXP 23
14495: PUSH
14496: LD_EXP 95
14500: NOT
14501: OR
14502: IFFALSE 14253
// end ;
14504: PPOPN 3
14506: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14507: LD_EXP 31
14511: PUSH
14512: LD_INT 22
14514: PUSH
14515: LD_INT 1
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PUSH
14522: LD_INT 2
14524: PUSH
14525: LD_INT 35
14527: PUSH
14528: LD_INT 8
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: LD_INT 34
14537: PUSH
14538: LD_INT 8
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: LIST
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: PPUSH
14554: CALL_OW 69
14558: AND
14559: IFFALSE 14959
14561: GO 14563
14563: DISABLE
14564: LD_INT 0
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14570: LD_ADDR_VAR 0 1
14574: PUSH
14575: DOUBLE
14576: LD_INT 1
14578: DEC
14579: ST_TO_ADDR
14580: LD_INT 6
14582: PUSH
14583: LD_INT 8
14585: PUSH
14586: LD_INT 10
14588: PUSH
14589: LD_INT 12
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PUSH
14598: LD_OWVAR 67
14602: ARRAY
14603: PUSH
14604: FOR_TO
14605: IFFALSE 14797
// begin uc_side := 7 ;
14607: LD_ADDR_OWVAR 20
14611: PUSH
14612: LD_INT 7
14614: ST_TO_ADDR
// uc_nation := 1 ;
14615: LD_ADDR_OWVAR 21
14619: PUSH
14620: LD_INT 1
14622: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14623: LD_INT 5
14625: PPUSH
14626: LD_INT 3
14628: PPUSH
14629: LD_INT 2
14631: PUSH
14632: LD_INT 3
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PUSH
14639: LD_INT 1
14641: PPUSH
14642: LD_INT 2
14644: PPUSH
14645: CALL_OW 12
14649: ARRAY
14650: PPUSH
14651: LD_INT 6
14653: PUSH
14654: LD_INT 9
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: LD_INT 1
14663: PPUSH
14664: LD_INT 2
14666: PPUSH
14667: CALL_OW 12
14671: ARRAY
14672: PPUSH
14673: LD_INT 100
14675: PPUSH
14676: CALL 74282 0 5
// un := CreateVehicle ;
14680: LD_ADDR_VAR 0 2
14684: PUSH
14685: CALL_OW 45
14689: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14690: LD_VAR 0 2
14694: PPUSH
14695: LD_INT 4
14697: PPUSH
14698: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14702: LD_VAR 0 2
14706: PPUSH
14707: LD_INT 307
14709: PPUSH
14710: LD_INT 219
14712: PPUSH
14713: LD_INT 6
14715: PPUSH
14716: LD_INT 0
14718: PPUSH
14719: CALL_OW 50
// if GetControl ( un ) = control_remote then
14723: LD_VAR 0 2
14727: PPUSH
14728: CALL_OW 263
14732: PUSH
14733: LD_INT 2
14735: EQUAL
14736: IFFALSE 14747
// Connect ( un ) ;
14738: LD_VAR 0 2
14742: PPUSH
14743: CALL 77750 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14747: LD_VAR 0 2
14751: PPUSH
14752: LD_INT 124
14754: PPUSH
14755: LD_INT 92
14757: PPUSH
14758: LD_INT 12
14760: PPUSH
14761: LD_INT 1
14763: PPUSH
14764: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14768: LD_ADDR_VAR 0 3
14772: PUSH
14773: LD_VAR 0 3
14777: PPUSH
14778: LD_VAR 0 2
14782: PPUSH
14783: CALL 107144 0 2
14787: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14788: LD_INT 10
14790: PPUSH
14791: CALL_OW 67
// end ;
14795: GO 14604
14797: POP
14798: POP
// repeat wait ( 0 0$2 ) ;
14799: LD_INT 70
14801: PPUSH
14802: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14806: LD_ADDR_VAR 0 4
14810: PUSH
14811: LD_INT 22
14813: PUSH
14814: LD_INT 1
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: PUSH
14821: LD_INT 34
14823: PUSH
14824: LD_INT 8
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: PPUSH
14835: CALL_OW 69
14839: ST_TO_ADDR
// if not e then
14840: LD_VAR 0 4
14844: NOT
14845: IFFALSE 14881
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14847: LD_ADDR_VAR 0 4
14851: PUSH
14852: LD_INT 22
14854: PUSH
14855: LD_INT 1
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 21
14864: PUSH
14865: LD_INT 2
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 69
14880: ST_TO_ADDR
// for i in tmp do
14881: LD_ADDR_VAR 0 1
14885: PUSH
14886: LD_VAR 0 3
14890: PUSH
14891: FOR_IN
14892: IFFALSE 14950
// if not IsOK ( i ) then
14894: LD_VAR 0 1
14898: PPUSH
14899: CALL_OW 302
14903: NOT
14904: IFFALSE 14924
// tmp := tmp diff i else
14906: LD_ADDR_VAR 0 3
14910: PUSH
14911: LD_VAR 0 3
14915: PUSH
14916: LD_VAR 0 1
14920: DIFF
14921: ST_TO_ADDR
14922: GO 14948
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14924: LD_VAR 0 1
14928: PPUSH
14929: LD_VAR 0 4
14933: PPUSH
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 74
14943: PPUSH
14944: CALL_OW 115
14948: GO 14891
14950: POP
14951: POP
// until not tmp ;
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14799
// end ;
14959: PPOPN 4
14961: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
14962: LD_EXP 23
14966: NOT
14967: PUSH
14968: LD_EXP 31
14972: AND
14973: IFFALSE 16026
14975: GO 14977
14977: DISABLE
14978: LD_INT 0
14980: PPUSH
14981: PPUSH
14982: PPUSH
14983: PPUSH
14984: PPUSH
// begin enable ;
14985: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14986: LD_INT 22
14988: PUSH
14989: LD_INT 7
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 30
14998: PUSH
14999: LD_INT 3
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PPUSH
15010: CALL_OW 69
15014: NOT
15015: IFFALSE 15019
// exit ;
15017: GO 16026
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15019: LD_ADDR_VAR 0 4
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 7
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 30
15036: PUSH
15037: LD_INT 34
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PPUSH
15048: CALL_OW 69
15052: ST_TO_ADDR
// if Prob ( 40 ) then
15053: LD_INT 40
15055: PPUSH
15056: CALL_OW 13
15060: IFFALSE 15206
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15062: LD_INT 1
15064: PPUSH
15065: LD_INT 5
15067: PUSH
15068: LD_INT 3
15070: PUSH
15071: LD_INT 2
15073: PUSH
15074: LD_INT 6
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 5
15085: PUSH
15086: LD_INT 3
15088: PUSH
15089: LD_INT 2
15091: PUSH
15092: LD_INT 6
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: PUSH
15101: LD_INT 5
15103: PUSH
15104: LD_INT 3
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: LD_INT 6
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 5
15121: PUSH
15122: LD_INT 3
15124: PUSH
15125: LD_INT 2
15127: PUSH
15128: LD_INT 9
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: PUSH
15137: LD_INT 24
15139: PUSH
15140: LD_INT 3
15142: PUSH
15143: LD_INT 3
15145: PUSH
15146: LD_INT 45
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 24
15157: PUSH
15158: LD_INT 3
15160: PUSH
15161: LD_INT 3
15163: PUSH
15164: LD_INT 47
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: PUSH
15173: LD_INT 24
15175: PUSH
15176: LD_INT 3
15178: PUSH
15179: LD_INT 3
15181: PUSH
15182: LD_INT 45
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: LIST
15189: LIST
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL 63016 0 2
// end else
15204: GO 15348
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15206: LD_INT 1
15208: PPUSH
15209: LD_INT 24
15211: PUSH
15212: LD_INT 3
15214: PUSH
15215: LD_INT 3
15217: PUSH
15218: LD_INT 47
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: PUSH
15227: LD_INT 24
15229: PUSH
15230: LD_INT 3
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: LD_INT 47
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: PUSH
15245: LD_INT 5
15247: PUSH
15248: LD_INT 3
15250: PUSH
15251: LD_INT 2
15253: PUSH
15254: LD_INT 9
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: PUSH
15263: LD_INT 5
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 2
15271: PUSH
15272: LD_INT 9
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: LIST
15279: LIST
15280: PUSH
15281: LD_INT 5
15283: PUSH
15284: LD_INT 3
15286: PUSH
15287: LD_INT 2
15289: PUSH
15290: LD_INT 9
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: LIST
15297: LIST
15298: PUSH
15299: LD_INT 24
15301: PUSH
15302: LD_INT 1
15304: PUSH
15305: LD_INT 3
15307: PUSH
15308: LD_INT 45
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: PUSH
15317: LD_INT 24
15319: PUSH
15320: LD_INT 1
15322: PUSH
15323: LD_INT 3
15325: PUSH
15326: LD_INT 45
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: PPUSH
15344: CALL 63016 0 2
// end ; wait ( 2 2$00 ) ;
15348: LD_INT 4200
15350: PPUSH
15351: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15355: LD_ADDR_VAR 0 2
15359: PUSH
15360: LD_INT 22
15362: PUSH
15363: LD_INT 7
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: LD_INT 21
15372: PUSH
15373: LD_INT 2
15375: PUSH
15376: EMPTY
15377: LIST
15378: LIST
15379: PUSH
15380: LD_INT 3
15382: PUSH
15383: LD_INT 34
15385: PUSH
15386: LD_INT 13
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 34
15395: PUSH
15396: LD_INT 12
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: LD_INT 34
15405: PUSH
15406: LD_INT 51
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PUSH
15413: LD_INT 34
15415: PUSH
15416: LD_INT 52
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: LIST
15434: PPUSH
15435: CALL_OW 69
15439: PUSH
15440: LD_EXP 123
15444: PUSH
15445: LD_INT 1
15447: ARRAY
15448: DIFF
15449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15450: LD_ADDR_EXP 120
15454: PUSH
15455: LD_EXP 120
15459: PPUSH
15460: LD_INT 1
15462: PPUSH
15463: LD_EXP 120
15467: PUSH
15468: LD_INT 1
15470: ARRAY
15471: PUSH
15472: LD_VAR 0 2
15476: DIFF
15477: PPUSH
15478: CALL_OW 1
15482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15483: LD_ADDR_VAR 0 3
15487: PUSH
15488: LD_INT 0
15490: PPUSH
15491: LD_INT 1
15493: PPUSH
15494: CALL_OW 12
15498: ST_TO_ADDR
// p := 0 ;
15499: LD_ADDR_VAR 0 5
15503: PUSH
15504: LD_INT 0
15506: ST_TO_ADDR
// if target then
15507: LD_VAR 0 3
15511: IFFALSE 15702
// begin for i in tmp do
15513: LD_ADDR_VAR 0 1
15517: PUSH
15518: LD_VAR 0 2
15522: PUSH
15523: FOR_IN
15524: IFFALSE 15549
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15526: LD_VAR 0 1
15530: PPUSH
15531: LD_INT 179
15533: PPUSH
15534: LD_INT 209
15536: PPUSH
15537: LD_INT 8
15539: PPUSH
15540: LD_INT 1
15542: PPUSH
15543: CALL_OW 483
15547: GO 15523
15549: POP
15550: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15551: LD_ADDR_VAR 0 2
15555: PUSH
15556: LD_VAR 0 2
15560: PPUSH
15561: LD_INT 24
15563: PUSH
15564: LD_INT 250
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PPUSH
15571: CALL_OW 72
15575: ST_TO_ADDR
// for i in tmp do
15576: LD_ADDR_VAR 0 1
15580: PUSH
15581: LD_VAR 0 2
15585: PUSH
15586: FOR_IN
15587: IFFALSE 15627
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15589: LD_VAR 0 1
15593: PPUSH
15594: LD_INT 179
15596: PPUSH
15597: LD_INT 209
15599: PPUSH
15600: CALL_OW 297
15604: PUSH
15605: LD_INT 9
15607: GREATER
15608: IFFALSE 15625
// ComMoveXY ( i , 179 , 209 ) ;
15610: LD_VAR 0 1
15614: PPUSH
15615: LD_INT 179
15617: PPUSH
15618: LD_INT 209
15620: PPUSH
15621: CALL_OW 111
15625: GO 15586
15627: POP
15628: POP
// wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// p := Inc ( p ) ;
15636: LD_ADDR_VAR 0 5
15640: PUSH
15641: LD_VAR 0 5
15645: PPUSH
15646: CALL 108505 0 1
15650: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15651: LD_VAR 0 2
15655: PPUSH
15656: LD_INT 92
15658: PUSH
15659: LD_INT 179
15661: PUSH
15662: LD_INT 209
15664: PUSH
15665: LD_INT 9
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 72
15678: PUSH
15679: LD_VAR 0 2
15683: PUSH
15684: LD_INT 1
15686: MINUS
15687: GREATEREQUAL
15688: PUSH
15689: LD_VAR 0 5
15693: PUSH
15694: LD_INT 30
15696: GREATER
15697: OR
15698: IFFALSE 15551
// end else
15700: GO 15889
// begin for i in tmp do
15702: LD_ADDR_VAR 0 1
15706: PUSH
15707: LD_VAR 0 2
15711: PUSH
15712: FOR_IN
15713: IFFALSE 15738
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15715: LD_VAR 0 1
15719: PPUSH
15720: LD_INT 285
15722: PPUSH
15723: LD_INT 163
15725: PPUSH
15726: LD_INT 8
15728: PPUSH
15729: LD_INT 1
15731: PPUSH
15732: CALL_OW 483
15736: GO 15712
15738: POP
15739: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15740: LD_ADDR_VAR 0 2
15744: PUSH
15745: LD_VAR 0 2
15749: PPUSH
15750: LD_INT 24
15752: PUSH
15753: LD_INT 250
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PPUSH
15760: CALL_OW 72
15764: ST_TO_ADDR
// for i in tmp do
15765: LD_ADDR_VAR 0 1
15769: PUSH
15770: LD_VAR 0 2
15774: PUSH
15775: FOR_IN
15776: IFFALSE 15816
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15778: LD_VAR 0 1
15782: PPUSH
15783: LD_INT 285
15785: PPUSH
15786: LD_INT 163
15788: PPUSH
15789: CALL_OW 297
15793: PUSH
15794: LD_INT 9
15796: GREATER
15797: IFFALSE 15814
// ComMoveXY ( i , 285 , 163 ) ;
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 285
15806: PPUSH
15807: LD_INT 163
15809: PPUSH
15810: CALL_OW 111
15814: GO 15775
15816: POP
15817: POP
// wait ( 0 0$1 ) ;
15818: LD_INT 35
15820: PPUSH
15821: CALL_OW 67
// p := Inc ( p ) ;
15825: LD_ADDR_VAR 0 5
15829: PUSH
15830: LD_VAR 0 5
15834: PPUSH
15835: CALL 108505 0 1
15839: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15840: LD_VAR 0 2
15844: PPUSH
15845: LD_INT 92
15847: PUSH
15848: LD_INT 285
15850: PUSH
15851: LD_INT 163
15853: PUSH
15854: LD_INT 9
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: LIST
15861: LIST
15862: PPUSH
15863: CALL_OW 72
15867: PUSH
15868: LD_VAR 0 2
15872: PUSH
15873: LD_INT 1
15875: MINUS
15876: GREATEREQUAL
15877: PUSH
15878: LD_VAR 0 5
15882: PUSH
15883: LD_INT 30
15885: GREATER
15886: OR
15887: IFFALSE 15740
// end ; repeat wait ( 0 0$1 ) ;
15889: LD_INT 35
15891: PPUSH
15892: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_VAR 0 2
15905: PPUSH
15906: LD_INT 50
15908: PUSH
15909: EMPTY
15910: LIST
15911: PPUSH
15912: CALL_OW 72
15916: ST_TO_ADDR
// for i in tmp do
15917: LD_ADDR_VAR 0 1
15921: PUSH
15922: LD_VAR 0 2
15926: PUSH
15927: FOR_IN
15928: IFFALSE 16017
// if GetWeapon ( i ) = ru_time_lapser then
15930: LD_VAR 0 1
15934: PPUSH
15935: CALL_OW 264
15939: PUSH
15940: LD_INT 49
15942: EQUAL
15943: IFFALSE 15981
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15945: LD_VAR 0 1
15949: PPUSH
15950: LD_INT 81
15952: PUSH
15953: LD_INT 7
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PPUSH
15960: CALL_OW 69
15964: PPUSH
15965: LD_VAR 0 1
15969: PPUSH
15970: CALL_OW 74
15974: PPUSH
15975: CALL_OW 112
15979: GO 16015
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15981: LD_VAR 0 1
15985: PPUSH
15986: LD_INT 81
15988: PUSH
15989: LD_INT 7
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PPUSH
15996: CALL_OW 69
16000: PPUSH
16001: LD_VAR 0 1
16005: PPUSH
16006: CALL_OW 74
16010: PPUSH
16011: CALL_OW 115
16015: GO 15927
16017: POP
16018: POP
// until not tmp ;
16019: LD_VAR 0 2
16023: NOT
16024: IFFALSE 15889
// end ;
16026: PPOPN 5
16028: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16029: LD_EXP 31
16033: PUSH
16034: LD_EXP 78
16038: PPUSH
16039: CALL_OW 302
16043: AND
16044: PUSH
16045: LD_OWVAR 67
16049: PUSH
16050: LD_INT 2
16052: GREATER
16053: AND
16054: IFFALSE 16154
16056: GO 16058
16058: DISABLE
// begin enable ;
16059: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16060: LD_EXP 78
16064: PPUSH
16065: LD_INT 245
16067: PPUSH
16068: LD_INT 234
16070: PPUSH
16071: CALL_OW 297
16075: PUSH
16076: LD_INT 6
16078: GREATER
16079: IFFALSE 16098
// ComMoveXY ( Roth , 245 , 234 ) else
16081: LD_EXP 78
16085: PPUSH
16086: LD_INT 245
16088: PPUSH
16089: LD_INT 234
16091: PPUSH
16092: CALL_OW 111
16096: GO 16154
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16098: LD_EXP 78
16102: PPUSH
16103: LD_INT 259
16105: PUSH
16106: LD_INT 235
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: LD_INT 252
16115: PUSH
16116: LD_INT 209
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: PUSH
16123: LD_INT 275
16125: PUSH
16126: LD_INT 235
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: LIST
16137: PUSH
16138: LD_INT 1
16140: PPUSH
16141: LD_INT 3
16143: PPUSH
16144: CALL_OW 12
16148: ARRAY
16149: PPUSH
16150: CALL 111146 0 2
// end ; end_of_file
16154: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16155: LD_INT 0
16157: PPUSH
16158: PPUSH
16159: PPUSH
16160: PPUSH
// missionStage := 13 ;
16161: LD_ADDR_EXP 15
16165: PUSH
16166: LD_INT 13
16168: ST_TO_ADDR
// uc_side := 2 ;
16169: LD_ADDR_OWVAR 20
16173: PUSH
16174: LD_INT 2
16176: ST_TO_ADDR
// uc_nation := 2 ;
16177: LD_ADDR_OWVAR 21
16181: PUSH
16182: LD_INT 2
16184: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16185: LD_ADDR_EXP 96
16189: PUSH
16190: LD_STRING Omar
16192: PPUSH
16193: CALL_OW 25
16197: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16198: LD_EXP 96
16202: PPUSH
16203: LD_INT 4
16205: PPUSH
16206: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16210: LD_EXP 96
16214: PPUSH
16215: LD_INT 242
16217: PPUSH
16218: LD_INT 75
16220: PPUSH
16221: LD_INT 0
16223: PPUSH
16224: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16228: LD_ADDR_EXP 97
16232: PUSH
16233: LD_STRING Heike
16235: PPUSH
16236: CALL_OW 25
16240: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16241: LD_INT 14
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 1
16249: PPUSH
16250: LD_INT 27
16252: PPUSH
16253: LD_INT 100
16255: PPUSH
16256: CALL 74282 0 5
// veh := CreateVehicle ;
16260: LD_ADDR_VAR 0 3
16264: PUSH
16265: CALL_OW 45
16269: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16270: LD_VAR 0 3
16274: PPUSH
16275: LD_INT 2
16277: NEG
16278: PPUSH
16279: CALL_OW 242
// SetDir ( veh , 4 ) ;
16283: LD_VAR 0 3
16287: PPUSH
16288: LD_INT 4
16290: PPUSH
16291: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16295: LD_VAR 0 3
16299: PPUSH
16300: LD_INT 241
16302: PPUSH
16303: LD_INT 72
16305: PPUSH
16306: LD_INT 0
16308: PPUSH
16309: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16313: LD_EXP 97
16317: PPUSH
16318: LD_VAR 0 3
16322: PPUSH
16323: CALL_OW 52
// if KhatamStatus then
16327: LD_EXP 8
16331: IFFALSE 16394
// begin Khatam := NewCharacter ( Khatam ) ;
16333: LD_ADDR_EXP 98
16337: PUSH
16338: LD_STRING Khatam
16340: PPUSH
16341: CALL_OW 25
16345: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16346: LD_EXP 98
16350: PPUSH
16351: LD_INT 245
16353: PPUSH
16354: LD_INT 78
16356: PPUSH
16357: LD_INT 3
16359: PPUSH
16360: LD_INT 0
16362: PPUSH
16363: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16367: LD_EXP 98
16371: PPUSH
16372: LD_INT 4
16374: PPUSH
16375: LD_INT 10
16377: PPUSH
16378: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16382: LD_EXP 98
16386: PPUSH
16387: LD_INT 4
16389: PPUSH
16390: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: DOUBLE
16400: LD_INT 1
16402: DEC
16403: ST_TO_ADDR
16404: LD_INT 2
16406: PUSH
16407: LD_INT 2
16409: PUSH
16410: LD_INT 3
16412: PUSH
16413: LD_INT 3
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: PUSH
16422: LD_OWVAR 67
16426: ARRAY
16427: PUSH
16428: FOR_TO
16429: IFFALSE 16495
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16431: LD_INT 0
16433: PPUSH
16434: LD_INT 6
16436: PUSH
16437: LD_OWVAR 67
16441: PLUS
16442: PPUSH
16443: CALL_OW 384
// un := CreateHuman ;
16447: LD_ADDR_VAR 0 4
16451: PUSH
16452: CALL_OW 44
16456: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16457: LD_VAR 0 4
16461: PPUSH
16462: LD_INT 28
16464: PUSH
16465: LD_INT 29
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_INT 2
16479: MOD
16480: PUSH
16481: LD_INT 1
16483: PLUS
16484: ARRAY
16485: PPUSH
16486: LD_INT 0
16488: PPUSH
16489: CALL_OW 49
// end ;
16493: GO 16428
16495: POP
16496: POP
// for i = 1 to 6 do
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: DOUBLE
16503: LD_INT 1
16505: DEC
16506: ST_TO_ADDR
16507: LD_INT 6
16509: PUSH
16510: FOR_TO
16511: IFFALSE 16556
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16513: LD_INT 0
16515: PPUSH
16516: LD_INT 6
16518: PUSH
16519: LD_OWVAR 67
16523: PLUS
16524: PPUSH
16525: CALL_OW 381
// un := CreateHuman ;
16529: LD_ADDR_VAR 0 4
16533: PUSH
16534: CALL_OW 44
16538: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16539: LD_VAR 0 4
16543: PPUSH
16544: LD_INT 32
16546: PPUSH
16547: LD_INT 0
16549: PPUSH
16550: CALL_OW 49
// end ;
16554: GO 16510
16556: POP
16557: POP
// for i = 1 to 3 do
16558: LD_ADDR_VAR 0 2
16562: PUSH
16563: DOUBLE
16564: LD_INT 1
16566: DEC
16567: ST_TO_ADDR
16568: LD_INT 3
16570: PUSH
16571: FOR_TO
16572: IFFALSE 16620
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16574: LD_INT 0
16576: PPUSH
16577: LD_INT 8
16579: PPUSH
16580: LD_INT 6
16582: PUSH
16583: LD_OWVAR 67
16587: PLUS
16588: PPUSH
16589: CALL_OW 380
// un := CreateHuman ;
16593: LD_ADDR_VAR 0 4
16597: PUSH
16598: CALL_OW 44
16602: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16603: LD_VAR 0 4
16607: PPUSH
16608: LD_INT 32
16610: PPUSH
16611: LD_INT 0
16613: PPUSH
16614: CALL_OW 49
// end ;
16618: GO 16571
16620: POP
16621: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16622: LD_ADDR_VAR 0 2
16626: PUSH
16627: DOUBLE
16628: LD_INT 1
16630: DEC
16631: ST_TO_ADDR
16632: LD_INT 2
16634: PUSH
16635: LD_INT 3
16637: PUSH
16638: LD_INT 4
16640: PUSH
16641: LD_INT 4
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: LIST
16648: LIST
16649: PUSH
16650: LD_OWVAR 67
16654: ARRAY
16655: PUSH
16656: FOR_TO
16657: IFFALSE 16747
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16659: LD_INT 14
16661: PPUSH
16662: LD_INT 2
16664: PPUSH
16665: LD_INT 1
16667: PPUSH
16668: LD_INT 28
16670: PPUSH
16671: LD_INT 80
16673: PPUSH
16674: CALL 74282 0 5
// veh := CreateVehicle ;
16678: LD_ADDR_VAR 0 3
16682: PUSH
16683: CALL_OW 45
16687: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16688: LD_VAR 0 3
16692: PPUSH
16693: LD_INT 3
16695: PPUSH
16696: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16700: LD_VAR 0 3
16704: PPUSH
16705: LD_INT 29
16707: PPUSH
16708: LD_INT 0
16710: PPUSH
16711: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16715: LD_INT 0
16717: PPUSH
16718: LD_INT 6
16720: PUSH
16721: LD_OWVAR 67
16725: PLUS
16726: PPUSH
16727: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16731: CALL_OW 44
16735: PPUSH
16736: LD_VAR 0 3
16740: PPUSH
16741: CALL_OW 52
// end ;
16745: GO 16656
16747: POP
16748: POP
// for i = 1 to 5 + Difficulty do
16749: LD_ADDR_VAR 0 2
16753: PUSH
16754: DOUBLE
16755: LD_INT 1
16757: DEC
16758: ST_TO_ADDR
16759: LD_INT 5
16761: PUSH
16762: LD_OWVAR 67
16766: PLUS
16767: PUSH
16768: FOR_TO
16769: IFFALSE 16896
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16771: LD_INT 14
16773: PPUSH
16774: LD_INT 1
16776: PPUSH
16777: LD_INT 3
16779: PPUSH
16780: CALL_OW 12
16784: PPUSH
16785: LD_INT 1
16787: PPUSH
16788: LD_INT 28
16790: PUSH
16791: LD_INT 26
16793: PUSH
16794: LD_INT 27
16796: PUSH
16797: LD_INT 25
16799: PUSH
16800: EMPTY
16801: LIST
16802: LIST
16803: LIST
16804: LIST
16805: PUSH
16806: LD_VAR 0 2
16810: PUSH
16811: LD_INT 4
16813: MOD
16814: PUSH
16815: LD_INT 1
16817: PLUS
16818: ARRAY
16819: PPUSH
16820: LD_INT 80
16822: PPUSH
16823: CALL 74282 0 5
// veh := CreateVehicle ;
16827: LD_ADDR_VAR 0 3
16831: PUSH
16832: CALL_OW 45
16836: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16837: LD_VAR 0 3
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16849: LD_VAR 0 3
16853: PPUSH
16854: LD_INT 28
16856: PPUSH
16857: LD_INT 0
16859: PPUSH
16860: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16864: LD_INT 0
16866: PPUSH
16867: LD_INT 6
16869: PUSH
16870: LD_OWVAR 67
16874: PLUS
16875: PPUSH
16876: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16880: CALL_OW 44
16884: PPUSH
16885: LD_VAR 0 3
16889: PPUSH
16890: CALL_OW 52
// end ;
16894: GO 16768
16896: POP
16897: POP
// for i = 1 to Difficulty do
16898: LD_ADDR_VAR 0 2
16902: PUSH
16903: DOUBLE
16904: LD_INT 1
16906: DEC
16907: ST_TO_ADDR
16908: LD_OWVAR 67
16912: PUSH
16913: FOR_TO
16914: IFFALSE 16974
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16916: LD_INT 14
16918: PPUSH
16919: LD_INT 3
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: LD_INT 29
16927: PPUSH
16928: LD_INT 80
16930: PPUSH
16931: CALL 74282 0 5
// veh := CreateVehicle ;
16935: LD_ADDR_VAR 0 3
16939: PUSH
16940: CALL_OW 45
16944: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16945: LD_VAR 0 3
16949: PPUSH
16950: LD_INT 4
16952: PPUSH
16953: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16957: LD_VAR 0 3
16961: PPUSH
16962: LD_INT 28
16964: PPUSH
16965: LD_INT 0
16967: PPUSH
16968: CALL_OW 49
// end ;
16972: GO 16913
16974: POP
16975: POP
// end ;
16976: LD_VAR 0 1
16980: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16981: LD_INT 22
16983: PUSH
16984: LD_INT 2
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: PPUSH
16991: CALL_OW 69
16995: IFFALSE 17374
16997: GO 16999
16999: DISABLE
17000: LD_INT 0
17002: PPUSH
17003: PPUSH
17004: PPUSH
17005: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17006: LD_ADDR_VAR 0 3
17010: PUSH
17011: LD_INT 22
17013: PUSH
17014: LD_INT 2
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 25
17023: PUSH
17024: LD_INT 4
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PPUSH
17035: CALL_OW 69
17039: PUSH
17040: LD_EXP 98
17044: DIFF
17045: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17046: LD_ADDR_VAR 0 2
17050: PUSH
17051: LD_INT 22
17053: PUSH
17054: LD_INT 2
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: PPUSH
17061: CALL_OW 69
17065: PUSH
17066: LD_EXP 98
17070: PUSH
17071: LD_VAR 0 3
17075: UNION
17076: DIFF
17077: ST_TO_ADDR
// if Khatam then
17078: LD_EXP 98
17082: IFFALSE 17099
// ComMoveXY ( Khatam , 211 , 92 ) ;
17084: LD_EXP 98
17088: PPUSH
17089: LD_INT 211
17091: PPUSH
17092: LD_INT 92
17094: PPUSH
17095: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17099: LD_INT 197
17101: PPUSH
17102: LD_INT 80
17104: PPUSH
17105: LD_INT 2
17107: PPUSH
17108: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17112: LD_INT 213
17114: PPUSH
17115: LD_INT 90
17117: PPUSH
17118: LD_INT 2
17120: PPUSH
17121: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17125: LD_INT 215
17127: PPUSH
17128: LD_INT 129
17130: PPUSH
17131: LD_INT 2
17133: PPUSH
17134: CALL_OW 441
// if sci then
17138: LD_VAR 0 3
17142: IFFALSE 17163
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17144: LD_VAR 0 3
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: LD_INT 197
17155: PPUSH
17156: LD_INT 80
17158: PPUSH
17159: CALL_OW 158
// if sci > 1 then
17163: LD_VAR 0 3
17167: PUSH
17168: LD_INT 1
17170: GREATER
17171: IFFALSE 17192
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17173: LD_VAR 0 3
17177: PUSH
17178: LD_INT 2
17180: ARRAY
17181: PPUSH
17182: LD_INT 213
17184: PPUSH
17185: LD_INT 90
17187: PPUSH
17188: CALL_OW 158
// if sci > 2 then
17192: LD_VAR 0 3
17196: PUSH
17197: LD_INT 2
17199: GREATER
17200: IFFALSE 17221
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17202: LD_VAR 0 3
17206: PUSH
17207: LD_INT 3
17209: ARRAY
17210: PPUSH
17211: LD_INT 215
17213: PPUSH
17214: LD_INT 129
17216: PPUSH
17217: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17221: LD_VAR 0 2
17225: PPUSH
17226: LD_INT 195
17228: PPUSH
17229: LD_INT 102
17231: PPUSH
17232: CALL_OW 114
// wait ( 0 0$5 ) ;
17236: LD_INT 175
17238: PPUSH
17239: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17243: LD_INT 70
17245: PPUSH
17246: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17250: LD_ADDR_VAR 0 4
17254: PUSH
17255: LD_INT 92
17257: PUSH
17258: LD_INT 195
17260: PUSH
17261: LD_INT 102
17263: PUSH
17264: LD_INT 36
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: LIST
17272: PUSH
17273: LD_INT 22
17275: PUSH
17276: LD_INT 1
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: PPUSH
17287: CALL_OW 69
17291: ST_TO_ADDR
// for i in tmp do
17292: LD_ADDR_VAR 0 1
17296: PUSH
17297: LD_VAR 0 2
17301: PUSH
17302: FOR_IN
17303: IFFALSE 17354
// if enemy then
17305: LD_VAR 0 4
17309: IFFALSE 17337
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17311: LD_VAR 0 1
17315: PPUSH
17316: LD_VAR 0 4
17320: PPUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 74
17330: PPUSH
17331: CALL_OW 115
17335: GO 17352
// ComAgressiveMove ( i , 195 , 102 ) ;
17337: LD_VAR 0 1
17341: PPUSH
17342: LD_INT 195
17344: PPUSH
17345: LD_INT 102
17347: PPUSH
17348: CALL_OW 114
17352: GO 17302
17354: POP
17355: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17356: LD_VAR 0 2
17360: PPUSH
17361: LD_INT 50
17363: PUSH
17364: EMPTY
17365: LIST
17366: PPUSH
17367: CALL_OW 72
17371: NOT
17372: IFFALSE 17243
// end ; end_of_file
17374: PPOPN 4
17376: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17377: LD_INT 0
17379: PPUSH
17380: PPUSH
17381: PPUSH
17382: PPUSH
17383: PPUSH
17384: PPUSH
17385: PPUSH
17386: PPUSH
17387: PPUSH
// Video ( true ) ;
17388: LD_INT 1
17390: PPUSH
17391: CALL 107116 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17395: LD_ADDR_VAR 0 5
17399: PUSH
17400: LD_INT 7
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: CALL_OW 517
17410: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17411: LD_ADDR_VAR 0 2
17415: PUSH
17416: DOUBLE
17417: LD_INT 1
17419: DEC
17420: ST_TO_ADDR
17421: LD_VAR 0 5
17425: PUSH
17426: LD_INT 1
17428: ARRAY
17429: PUSH
17430: FOR_TO
17431: IFFALSE 17476
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17433: LD_VAR 0 5
17437: PUSH
17438: LD_INT 1
17440: ARRAY
17441: PUSH
17442: LD_VAR 0 2
17446: ARRAY
17447: PPUSH
17448: LD_VAR 0 5
17452: PUSH
17453: LD_INT 2
17455: ARRAY
17456: PUSH
17457: LD_VAR 0 2
17461: ARRAY
17462: PPUSH
17463: LD_INT 1
17465: PPUSH
17466: LD_INT 15
17468: NEG
17469: PPUSH
17470: CALL 107030 0 4
17474: GO 17430
17476: POP
17477: POP
// CenterNowOnUnits ( Powell ) ;
17478: LD_EXP 60
17482: PPUSH
17483: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17487: LD_ADDR_VAR 0 5
17491: PUSH
17492: LD_EXP 58
17496: PUSH
17497: EMPTY
17498: LIST
17499: ST_TO_ADDR
// if GirlNewVeh then
17500: LD_EXP 59
17504: IFFALSE 17522
// tmp := tmp ^ GirlNewVeh ;
17506: LD_ADDR_VAR 0 5
17510: PUSH
17511: LD_VAR 0 5
17515: PUSH
17516: LD_EXP 59
17520: ADD
17521: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17522: LD_VAR 0 5
17526: PPUSH
17527: LD_INT 60
17529: PPUSH
17530: LD_INT 109
17532: PPUSH
17533: CALL_OW 111
// if KappaStatus then
17537: LD_EXP 2
17541: IFFALSE 17593
// begin Say ( JMM , D1nT-JMM-1 ) ;
17543: LD_EXP 40
17547: PPUSH
17548: LD_STRING D1nT-JMM-1
17550: PPUSH
17551: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17555: LD_EXP 60
17559: PPUSH
17560: LD_STRING D1T-Pow-1
17562: PPUSH
17563: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17567: LD_EXP 40
17571: PPUSH
17572: LD_STRING D1T-JMM-2
17574: PPUSH
17575: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17579: LD_EXP 60
17583: PPUSH
17584: LD_STRING D1T-Pow-2
17586: PPUSH
17587: CALL_OW 88
// end else
17591: GO 17799
// if JMMGirlStatus then
17593: LD_EXP 6
17597: IFFALSE 17742
// begin Say ( JMM , D1T-JMM-1 ) ;
17599: LD_EXP 40
17603: PPUSH
17604: LD_STRING D1T-JMM-1
17606: PPUSH
17607: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17611: LD_EXP 60
17615: PPUSH
17616: LD_STRING D1T-Pow-1
17618: PPUSH
17619: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17623: LD_EXP 40
17627: PPUSH
17628: LD_STRING D1T-JMM-3
17630: PPUSH
17631: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17635: LD_EXP 60
17639: PPUSH
17640: LD_STRING D1T-Pow-3
17642: PPUSH
17643: CALL_OW 88
// if JMMGirl then
17647: LD_EXP 7
17651: IFFALSE 17740
// begin case JMMGirl of 1 :
17653: LD_EXP 7
17657: PUSH
17658: LD_INT 1
17660: DOUBLE
17661: EQUAL
17662: IFTRUE 17666
17664: GO 17681
17666: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17667: LD_EXP 41
17671: PPUSH
17672: LD_STRING D1T-Joan-3
17674: PPUSH
17675: CALL_OW 88
17679: GO 17728
17681: LD_INT 2
17683: DOUBLE
17684: EQUAL
17685: IFTRUE 17689
17687: GO 17704
17689: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17690: LD_EXP 43
17694: PPUSH
17695: LD_STRING D1T-Lisa-3
17697: PPUSH
17698: CALL_OW 88
17702: GO 17728
17704: LD_INT 3
17706: DOUBLE
17707: EQUAL
17708: IFTRUE 17712
17710: GO 17727
17712: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D1T-Con-3
17720: PPUSH
17721: CALL_OW 88
17725: GO 17728
17727: POP
// Say ( Powell , D1T-Pow-4 ) ;
17728: LD_EXP 60
17732: PPUSH
17733: LD_STRING D1T-Pow-4
17735: PPUSH
17736: CALL_OW 88
// end ; end else
17740: GO 17799
// if not FastEnd then
17742: LD_EXP 11
17746: NOT
17747: IFFALSE 17775
// begin Say ( JMM , D1T-JMM-4 ) ;
17749: LD_EXP 40
17753: PPUSH
17754: LD_STRING D1T-JMM-4
17756: PPUSH
17757: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17761: LD_EXP 60
17765: PPUSH
17766: LD_STRING D1T-Pow-5
17768: PPUSH
17769: CALL_OW 88
// end else
17773: GO 17799
// begin Say ( JMM , D1nT-JMM-1 ) ;
17775: LD_EXP 40
17779: PPUSH
17780: LD_STRING D1nT-JMM-1
17782: PPUSH
17783: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17787: LD_EXP 60
17791: PPUSH
17792: LD_STRING D1nT-Pow-1
17794: PPUSH
17795: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17799: LD_INT 3
17801: PPUSH
17802: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17806: LD_EXP 58
17810: PPUSH
17811: CALL_OW 314
17815: NOT
17816: IFFALSE 17799
// ComExitVehicle ( JMM ) ;
17818: LD_EXP 40
17822: PPUSH
17823: CALL_OW 121
// repeat wait ( 3 ) ;
17827: LD_INT 3
17829: PPUSH
17830: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17834: LD_EXP 40
17838: PPUSH
17839: CALL_OW 310
17843: NOT
17844: IFFALSE 17827
// ComMoveXY ( JMM , 60 , 94 ) ;
17846: LD_EXP 40
17850: PPUSH
17851: LD_INT 60
17853: PPUSH
17854: LD_INT 94
17856: PPUSH
17857: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17861: LD_EXP 40
17865: PPUSH
17866: LD_EXP 60
17870: PPUSH
17871: CALL_OW 179
// if Joan then
17875: LD_EXP 41
17879: IFFALSE 17933
// begin ComExitVehicle ( Joan ) ;
17881: LD_EXP 41
17885: PPUSH
17886: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17890: LD_EXP 41
17894: PPUSH
17895: LD_INT 35
17897: PPUSH
17898: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17902: LD_EXP 41
17906: PPUSH
17907: LD_INT 65
17909: PPUSH
17910: LD_INT 104
17912: PPUSH
17913: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17917: LD_EXP 41
17921: PPUSH
17922: LD_EXP 40
17926: PPUSH
17927: CALL_OW 179
// end else
17931: GO 18067
// if Lisa and JMMGirl = 2 then
17933: LD_EXP 43
17937: PUSH
17938: LD_EXP 7
17942: PUSH
17943: LD_INT 2
17945: EQUAL
17946: AND
17947: IFFALSE 18001
// begin ComExitVehicle ( Lisa ) ;
17949: LD_EXP 43
17953: PPUSH
17954: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17958: LD_EXP 43
17962: PPUSH
17963: LD_INT 35
17965: PPUSH
17966: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17970: LD_EXP 43
17974: PPUSH
17975: LD_INT 65
17977: PPUSH
17978: LD_INT 104
17980: PPUSH
17981: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17985: LD_EXP 43
17989: PPUSH
17990: LD_EXP 40
17994: PPUSH
17995: CALL_OW 179
// end else
17999: GO 18067
// if Connie and JMMGirl = 3 then
18001: LD_EXP 55
18005: PUSH
18006: LD_EXP 7
18010: PUSH
18011: LD_INT 3
18013: EQUAL
18014: AND
18015: IFFALSE 18067
// begin ComExitVehicle ( Connie ) ;
18017: LD_EXP 55
18021: PPUSH
18022: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18026: LD_EXP 55
18030: PPUSH
18031: LD_INT 35
18033: PPUSH
18034: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18038: LD_EXP 55
18042: PPUSH
18043: LD_INT 65
18045: PPUSH
18046: LD_INT 104
18048: PPUSH
18049: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18053: LD_EXP 55
18057: PPUSH
18058: LD_EXP 40
18062: PPUSH
18063: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18067: LD_INT 35
18069: PPUSH
18070: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 60
18083: PPUSH
18084: CALL_OW 296
18088: PUSH
18089: LD_INT 8
18091: LESS
18092: IFFALSE 18067
// wait ( 0 0$0.5 ) ;
18094: LD_INT 18
18096: PPUSH
18097: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18101: LD_EXP 40
18105: PPUSH
18106: LD_STRING D1-JMM-1
18108: PPUSH
18109: CALL_OW 88
// async ;
18113: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18114: LD_EXP 60
18118: PPUSH
18119: LD_STRING D1-Pow-1
18121: PPUSH
18122: CALL_OW 88
// if not dialogue_skipped then
18126: LD_OWVAR 59
18130: NOT
18131: IFFALSE 18140
// wait ( 0 0$2 ) ;
18133: LD_INT 70
18135: PPUSH
18136: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18140: LD_INT 170
18142: PPUSH
18143: LD_INT 99
18145: PPUSH
18146: LD_INT 1
18148: PPUSH
18149: LD_INT 6
18151: NEG
18152: PPUSH
18153: CALL 107030 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18157: LD_INT 174
18159: PPUSH
18160: LD_INT 115
18162: PPUSH
18163: LD_INT 1
18165: PPUSH
18166: LD_INT 6
18168: NEG
18169: PPUSH
18170: CALL 107030 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18174: LD_INT 169
18176: PPUSH
18177: LD_INT 71
18179: PPUSH
18180: LD_INT 1
18182: PPUSH
18183: LD_INT 6
18185: NEG
18186: PPUSH
18187: CALL 107030 0 4
// if not dialogue_skipped then
18191: LD_OWVAR 59
18195: NOT
18196: IFFALSE 18215
// begin CenterOnXY ( 170 , 99 ) ;
18198: LD_INT 170
18200: PPUSH
18201: LD_INT 99
18203: PPUSH
18204: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18208: LD_INT 80
18210: PPUSH
18211: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18215: LD_INT 75
18217: PPUSH
18218: LD_INT 53
18220: PPUSH
18221: LD_INT 1
18223: PPUSH
18224: LD_INT 9
18226: NEG
18227: PPUSH
18228: CALL 107030 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18232: LD_INT 54
18234: PPUSH
18235: LD_INT 42
18237: PPUSH
18238: LD_INT 1
18240: PPUSH
18241: LD_INT 9
18243: NEG
18244: PPUSH
18245: CALL 107030 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18249: LD_INT 62
18251: PPUSH
18252: LD_INT 51
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_INT 9
18260: NEG
18261: PPUSH
18262: CALL 107030 0 4
// if not dialogue_skipped then
18266: LD_OWVAR 59
18270: NOT
18271: IFFALSE 18290
// begin CenterOnXY ( 75 , 53 ) ;
18273: LD_INT 75
18275: PPUSH
18276: LD_INT 53
18278: PPUSH
18279: CALL_OW 84
// wait ( 0 0$4 ) ;
18283: LD_INT 140
18285: PPUSH
18286: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18290: LD_EXP 60
18294: PPUSH
18295: CALL_OW 87
// if not dialogue_skipped then
18299: LD_OWVAR 59
18303: NOT
18304: IFFALSE 18313
// wait ( 0 0$2 ) ;
18306: LD_INT 70
18308: PPUSH
18309: CALL_OW 67
// sync ;
18313: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-2
18321: PPUSH
18322: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18326: LD_EXP 60
18330: PPUSH
18331: LD_STRING D1-Pow-2
18333: PPUSH
18334: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18338: LD_EXP 40
18342: PPUSH
18343: LD_STRING D1-JMM-3
18345: PPUSH
18346: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18350: LD_EXP 60
18354: PPUSH
18355: LD_STRING D1-Pow-3
18357: PPUSH
18358: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18362: LD_EXP 40
18366: PPUSH
18367: LD_STRING D1-JMM-4
18369: PPUSH
18370: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18374: LD_EXP 60
18378: PPUSH
18379: LD_STRING D1-Pow-4
18381: PPUSH
18382: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18386: LD_EXP 40
18390: PPUSH
18391: LD_STRING D1-JMM-5
18393: PPUSH
18394: CALL_OW 88
// async ;
18398: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18399: LD_EXP 60
18403: PPUSH
18404: LD_STRING D1-Pow-5
18406: PPUSH
18407: CALL_OW 88
// if not dialogue_skipped then
18411: LD_OWVAR 59
18415: NOT
18416: IFFALSE 18425
// wait ( 0 0$3.6 ) ;
18418: LD_INT 126
18420: PPUSH
18421: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18425: LD_INT 134
18427: PPUSH
18428: LD_INT 210
18430: PPUSH
18431: LD_INT 1
18433: PPUSH
18434: LD_INT 11
18436: NEG
18437: PPUSH
18438: CALL 107030 0 4
// if not dialogue_skipped then
18442: LD_OWVAR 59
18446: NOT
18447: IFFALSE 18466
// begin CenterOnXY ( 134 , 210 ) ;
18449: LD_INT 134
18451: PPUSH
18452: LD_INT 210
18454: PPUSH
18455: CALL_OW 84
// wait ( 0 0$2 ) ;
18459: LD_INT 70
18461: PPUSH
18462: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18466: LD_INT 101
18468: PPUSH
18469: LD_INT 159
18471: PPUSH
18472: LD_INT 1
18474: PPUSH
18475: LD_INT 10
18477: NEG
18478: PPUSH
18479: CALL 107030 0 4
// if not dialogue_skipped then
18483: LD_OWVAR 59
18487: NOT
18488: IFFALSE 18507
// begin CenterOnXY ( 101 , 159 ) ;
18490: LD_INT 101
18492: PPUSH
18493: LD_INT 159
18495: PPUSH
18496: CALL_OW 84
// wait ( 0 0$2 ) ;
18500: LD_INT 70
18502: PPUSH
18503: CALL_OW 67
// end ; sync ;
18507: SYNC
// CenterNowOnUnits ( Powell ) ;
18508: LD_EXP 60
18512: PPUSH
18513: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: LD_INT 1
18524: PUSH
18525: LD_INT 2
18527: PUSH
18528: LD_INT 3
18530: PUSH
18531: LD_INT 4
18533: PUSH
18534: LD_INT 5
18536: PUSH
18537: LD_INT 6
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: ST_TO_ADDR
// if not dialogue_skipped then
18548: LD_OWVAR 59
18552: NOT
18553: IFFALSE 18722
// begin game_speed := 4 ;
18555: LD_ADDR_OWVAR 65
18559: PUSH
18560: LD_INT 4
18562: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18563: LD_INT 210
18565: PPUSH
18566: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18570: LD_ADDR_VAR 0 7
18574: PUSH
18575: LD_STRING Q1
18577: PPUSH
18578: LD_VAR 0 6
18582: PPUSH
18583: CALL_OW 98
18587: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18588: LD_ADDR_VAR 0 7
18592: PUSH
18593: LD_STRING Q1
18595: PPUSH
18596: LD_VAR 0 6
18600: PPUSH
18601: CALL_OW 98
18605: ST_TO_ADDR
// options := options diff dec ;
18606: LD_ADDR_VAR 0 6
18610: PUSH
18611: LD_VAR 0 6
18615: PUSH
18616: LD_VAR 0 7
18620: DIFF
18621: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18622: LD_VAR 0 7
18626: PPUSH
18627: LD_VAR 0 6
18631: PPUSH
18632: CALL 20286 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18636: LD_VAR 0 7
18640: PUSH
18641: LD_INT 5
18643: PUSH
18644: LD_INT 6
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: IN
18651: PUSH
18652: LD_VAR 0 6
18656: PUSH
18657: LD_INT 2
18659: EQUAL
18660: OR
18661: IFFALSE 18588
// if not ( dec in [ 5 , 6 ] ) then
18663: LD_VAR 0 7
18667: PUSH
18668: LD_INT 5
18670: PUSH
18671: LD_INT 6
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: IN
18678: NOT
18679: IFFALSE 18722
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18681: LD_ADDR_VAR 0 7
18685: PUSH
18686: LD_STRING Q1a
18688: PPUSH
18689: LD_INT 1
18691: PUSH
18692: LD_INT 2
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PPUSH
18699: CALL_OW 98
18703: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18704: LD_VAR 0 7
18708: PUSH
18709: LD_INT 4
18711: PLUS
18712: PPUSH
18713: LD_VAR 0 6
18717: PPUSH
18718: CALL 20286 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18722: LD_INT 81
18724: PPUSH
18725: LD_INT 127
18727: PPUSH
18728: CALL_OW 84
// amount := 8 ;
18732: LD_ADDR_VAR 0 8
18736: PUSH
18737: LD_INT 8
18739: ST_TO_ADDR
// macmilan_squad := [ ] ;
18740: LD_ADDR_VAR 0 9
18744: PUSH
18745: EMPTY
18746: ST_TO_ADDR
// if vip < amount then
18747: LD_EXP 61
18751: PUSH
18752: LD_VAR 0 8
18756: LESS
18757: IFFALSE 18801
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18759: LD_ADDR_VAR 0 5
18763: PUSH
18764: LD_EXP 61
18768: PUSH
18769: LD_INT 22
18771: PUSH
18772: LD_INT 4
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: PUSH
18779: LD_INT 21
18781: PUSH
18782: LD_INT 1
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PPUSH
18793: CALL_OW 69
18797: UNION
18798: ST_TO_ADDR
18799: GO 18811
// tmp := vip ;
18801: LD_ADDR_VAR 0 5
18805: PUSH
18806: LD_EXP 61
18810: ST_TO_ADDR
// tmp := tmp diff Powell ;
18811: LD_ADDR_VAR 0 5
18815: PUSH
18816: LD_VAR 0 5
18820: PUSH
18821: LD_EXP 60
18825: DIFF
18826: ST_TO_ADDR
// if tmp < amount then
18827: LD_VAR 0 5
18831: PUSH
18832: LD_VAR 0 8
18836: LESS
18837: IFFALSE 18849
// amount := tmp ;
18839: LD_ADDR_VAR 0 8
18843: PUSH
18844: LD_VAR 0 5
18848: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18849: LD_VAR 0 5
18853: PUSH
18854: LD_INT 1
18856: ARRAY
18857: PPUSH
18858: CALL_OW 257
18862: PUSH
18863: LD_INT 2
18865: NONEQUAL
18866: IFFALSE 18964
// begin if IsInUnit ( tmp [ 1 ] ) then
18868: LD_VAR 0 5
18872: PUSH
18873: LD_INT 1
18875: ARRAY
18876: PPUSH
18877: CALL_OW 310
18881: IFFALSE 18896
// ComExitBuilding ( tmp [ 1 ] ) ;
18883: LD_VAR 0 5
18887: PUSH
18888: LD_INT 1
18890: ARRAY
18891: PPUSH
18892: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18896: LD_INT 387
18898: PPUSH
18899: CALL_OW 313
18903: PUSH
18904: LD_INT 6
18906: EQUAL
18907: IFFALSE 18932
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18909: LD_INT 387
18911: PPUSH
18912: CALL_OW 313
18916: PUSH
18917: LD_INT 1
18919: ARRAY
18920: PPUSH
18921: CALL_OW 122
// wait ( 3 ) ;
18925: LD_INT 3
18927: PPUSH
18928: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18932: LD_VAR 0 5
18936: PUSH
18937: LD_INT 1
18939: ARRAY
18940: PPUSH
18941: LD_INT 387
18943: PPUSH
18944: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18948: LD_VAR 0 5
18952: PUSH
18953: LD_INT 1
18955: ARRAY
18956: PPUSH
18957: LD_INT 2
18959: PPUSH
18960: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18964: LD_EXP 40
18968: PPUSH
18969: LD_INT 82
18971: PPUSH
18972: LD_INT 129
18974: PPUSH
18975: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_EXP 60
18988: PPUSH
18989: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18993: LD_INT 22
18995: PUSH
18996: LD_INT 1
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: PPUSH
19003: CALL_OW 69
19007: PUSH
19008: LD_EXP 40
19012: DIFF
19013: PPUSH
19014: LD_INT 84
19016: PPUSH
19017: LD_INT 128
19019: PPUSH
19020: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19024: LD_INT 22
19026: PUSH
19027: LD_INT 1
19029: PUSH
19030: EMPTY
19031: LIST
19032: LIST
19033: PPUSH
19034: CALL_OW 69
19038: PUSH
19039: LD_EXP 40
19043: DIFF
19044: PPUSH
19045: LD_EXP 40
19049: PPUSH
19050: CALL_OW 179
// for i = 1 to amount do
19054: LD_ADDR_VAR 0 2
19058: PUSH
19059: DOUBLE
19060: LD_INT 1
19062: DEC
19063: ST_TO_ADDR
19064: LD_VAR 0 8
19068: PUSH
19069: FOR_TO
19070: IFFALSE 19238
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19072: LD_ADDR_VAR 0 9
19076: PUSH
19077: LD_VAR 0 9
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: LD_VAR 0 2
19091: ARRAY
19092: ADD
19093: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19094: LD_VAR 0 5
19098: PUSH
19099: LD_VAR 0 2
19103: ARRAY
19104: PPUSH
19105: CALL_OW 310
19109: IFFALSE 19126
// AddComExitBuilding ( tmp [ i ] ) ;
19111: LD_VAR 0 5
19115: PUSH
19116: LD_VAR 0 2
19120: ARRAY
19121: PPUSH
19122: CALL_OW 182
// if i = 2 and JMMNewVeh then
19126: LD_VAR 0 2
19130: PUSH
19131: LD_INT 2
19133: EQUAL
19134: PUSH
19135: LD_EXP 58
19139: AND
19140: IFFALSE 19198
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19142: LD_VAR 0 5
19146: PUSH
19147: LD_VAR 0 2
19151: ARRAY
19152: PPUSH
19153: LD_EXP 58
19157: PPUSH
19158: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19162: LD_VAR 0 5
19166: PUSH
19167: LD_VAR 0 2
19171: ARRAY
19172: PPUSH
19173: LD_INT 86
19175: PPUSH
19176: LD_INT 133
19178: PPUSH
19179: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19183: LD_VAR 0 5
19187: PUSH
19188: LD_VAR 0 2
19192: ARRAY
19193: PPUSH
19194: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19198: LD_VAR 0 5
19202: PUSH
19203: LD_VAR 0 2
19207: ARRAY
19208: PPUSH
19209: LD_INT 8
19211: PPUSH
19212: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19216: LD_VAR 0 5
19220: PUSH
19221: LD_VAR 0 2
19225: ARRAY
19226: PPUSH
19227: LD_EXP 40
19231: PPUSH
19232: CALL_OW 179
// end ;
19236: GO 19069
19238: POP
19239: POP
// if GirlNewVeh then
19240: LD_EXP 59
19244: IFFALSE 19258
// SetSide ( GirlNewVeh , 4 ) ;
19246: LD_EXP 59
19250: PPUSH
19251: LD_INT 4
19253: PPUSH
19254: CALL_OW 235
// if Mike then
19258: LD_EXP 57
19262: IFFALSE 19299
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19264: LD_ADDR_VAR 0 9
19268: PUSH
19269: LD_VAR 0 9
19273: PPUSH
19274: LD_EXP 57
19278: PPUSH
19279: CALL 107144 0 2
19283: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19284: LD_EXP 57
19288: PPUSH
19289: LD_INT 86
19291: PPUSH
19292: LD_INT 133
19294: PPUSH
19295: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19299: LD_INT 35
19301: PPUSH
19302: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19306: LD_VAR 0 9
19310: PPUSH
19311: LD_INT 95
19313: PUSH
19314: LD_INT 9
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PPUSH
19321: CALL_OW 72
19325: PUSH
19326: LD_INT 0
19328: EQUAL
19329: PUSH
19330: LD_EXP 40
19334: PPUSH
19335: LD_INT 9
19337: PPUSH
19338: CALL_OW 308
19342: NOT
19343: AND
19344: IFFALSE 19299
// wait ( 0 0$2 ) ;
19346: LD_INT 70
19348: PPUSH
19349: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19353: LD_VAR 0 9
19357: PPUSH
19358: LD_INT 1
19360: PPUSH
19361: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19365: LD_INT 21
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PUSH
19375: LD_INT 92
19377: PUSH
19378: LD_INT 83
19380: PUSH
19381: LD_INT 130
19383: PUSH
19384: LD_INT 10
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: PPUSH
19397: CALL_OW 69
19401: PPUSH
19402: LD_INT 1
19404: PPUSH
19405: CALL_OW 235
// tick := 0 ;
19409: LD_ADDR_OWVAR 1
19413: PUSH
19414: LD_INT 0
19416: ST_TO_ADDR
// Video ( false ) ;
19417: LD_INT 0
19419: PPUSH
19420: CALL 107116 0 1
// ChangeMissionObjectives ( M1 ) ;
19424: LD_STRING M1
19426: PPUSH
19427: CALL_OW 337
// SaveForQuickRestart ;
19431: CALL_OW 22
// missionStart := true ;
19435: LD_ADDR_EXP 13
19439: PUSH
19440: LD_INT 1
19442: ST_TO_ADDR
// missionStage := 2 ;
19443: LD_ADDR_EXP 15
19447: PUSH
19448: LD_INT 2
19450: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19451: LD_INT 35
19453: PPUSH
19454: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19458: LD_ADDR_VAR 0 5
19462: PUSH
19463: LD_INT 22
19465: PUSH
19466: LD_INT 4
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: PUSH
19473: LD_INT 21
19475: PUSH
19476: LD_INT 1
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PPUSH
19487: CALL_OW 69
19491: PUSH
19492: LD_EXP 60
19496: DIFF
19497: ST_TO_ADDR
// if not tmp then
19498: LD_VAR 0 5
19502: NOT
19503: IFFALSE 19518
// tmp := [ Powell ] ;
19505: LD_ADDR_VAR 0 5
19509: PUSH
19510: LD_EXP 60
19514: PUSH
19515: EMPTY
19516: LIST
19517: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19518: LD_ADDR_VAR 0 4
19522: PUSH
19523: LD_INT 22
19525: PUSH
19526: LD_INT 4
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 34
19535: PUSH
19536: LD_INT 12
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: PPUSH
19547: CALL_OW 69
19551: PUSH
19552: LD_INT 1
19554: ARRAY
19555: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19556: LD_VAR 0 5
19560: PUSH
19561: LD_INT 1
19563: ARRAY
19564: PPUSH
19565: CALL_OW 310
19569: IFFALSE 19584
// ComExitBuilding ( tmp [ 1 ] ) ;
19571: LD_VAR 0 5
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19584: LD_VAR 0 5
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: LD_VAR 0 4
19597: PPUSH
19598: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19602: LD_VAR 0 5
19606: PUSH
19607: LD_INT 1
19609: ARRAY
19610: PPUSH
19611: LD_INT 80
19613: PPUSH
19614: LD_INT 136
19616: PPUSH
19617: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19621: LD_VAR 0 5
19625: PUSH
19626: LD_INT 1
19628: ARRAY
19629: PPUSH
19630: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19634: LD_VAR 0 5
19638: PUSH
19639: LD_INT 1
19641: ARRAY
19642: PPUSH
19643: LD_INT 59
19645: PPUSH
19646: LD_INT 112
19648: PPUSH
19649: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19653: LD_VAR 0 5
19657: PUSH
19658: LD_INT 1
19660: ARRAY
19661: PPUSH
19662: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19666: LD_EXP 41
19670: PUSH
19671: LD_EXP 41
19675: PPUSH
19676: CALL_OW 255
19680: PUSH
19681: LD_INT 1
19683: EQUAL
19684: AND
19685: IFFALSE 19711
// begin Say ( Joan , D3W-Joan-1 ) ;
19687: LD_EXP 41
19691: PPUSH
19692: LD_STRING D3W-Joan-1
19694: PPUSH
19695: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19699: LD_EXP 40
19703: PPUSH
19704: LD_STRING D3W-JMM-1
19706: PPUSH
19707: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19711: LD_EXP 43
19715: PUSH
19716: LD_EXP 43
19720: PPUSH
19721: CALL_OW 255
19725: PUSH
19726: LD_INT 1
19728: EQUAL
19729: AND
19730: PUSH
19731: LD_EXP 43
19735: PUSH
19736: LD_EXP 61
19740: IN
19741: NOT
19742: AND
19743: IFFALSE 19769
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19745: LD_EXP 43
19749: PPUSH
19750: LD_STRING D3W-Lisa-1
19752: PPUSH
19753: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19757: LD_EXP 40
19761: PPUSH
19762: LD_STRING D3W-JMM-1
19764: PPUSH
19765: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19769: LD_EXP 55
19773: PUSH
19774: LD_EXP 55
19778: PPUSH
19779: CALL_OW 255
19783: PUSH
19784: LD_INT 1
19786: EQUAL
19787: AND
19788: IFFALSE 19814
// begin Say ( Connie , D3W-Con-1 ) ;
19790: LD_EXP 55
19794: PPUSH
19795: LD_STRING D3W-Con-1
19797: PPUSH
19798: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19802: LD_EXP 40
19806: PPUSH
19807: LD_STRING D3W-JMM-1
19809: PPUSH
19810: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19814: LD_INT 18
19816: PPUSH
19817: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19821: LD_EXP 43
19825: PUSH
19826: LD_EXP 61
19830: IN
19831: PUSH
19832: LD_EXP 43
19836: PPUSH
19837: CALL_OW 255
19841: PUSH
19842: LD_INT 1
19844: EQUAL
19845: AND
19846: IFFALSE 19862
// Say ( Lisa , D3nW-Lisa-1 ) else
19848: LD_EXP 43
19852: PPUSH
19853: LD_STRING D3nW-Lisa-1
19855: PPUSH
19856: CALL_OW 88
19860: GO 20106
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19862: LD_EXP 46
19866: PUSH
19867: LD_EXP 61
19871: IN
19872: PUSH
19873: LD_EXP 46
19877: PPUSH
19878: CALL_OW 255
19882: PUSH
19883: LD_INT 1
19885: EQUAL
19886: AND
19887: IFFALSE 19903
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19889: LD_EXP 46
19893: PPUSH
19894: LD_STRING D3nW-Cyrus-1
19896: PPUSH
19897: CALL_OW 88
19901: GO 20106
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19903: LD_EXP 45
19907: PUSH
19908: LD_EXP 61
19912: IN
19913: PUSH
19914: LD_EXP 45
19918: PPUSH
19919: CALL_OW 255
19923: PUSH
19924: LD_INT 1
19926: EQUAL
19927: AND
19928: IFFALSE 19944
// Say ( Bobby , D3nW-Bobby-1 ) else
19930: LD_EXP 45
19934: PPUSH
19935: LD_STRING D3nW-Bobby-1
19937: PPUSH
19938: CALL_OW 88
19942: GO 20106
// if Gary in vip and GetSide ( Gary ) = 1 then
19944: LD_EXP 52
19948: PUSH
19949: LD_EXP 61
19953: IN
19954: PUSH
19955: LD_EXP 52
19959: PPUSH
19960: CALL_OW 255
19964: PUSH
19965: LD_INT 1
19967: EQUAL
19968: AND
19969: IFFALSE 19985
// Say ( Gary , D3nW-Gary-1 ) else
19971: LD_EXP 52
19975: PPUSH
19976: LD_STRING D3nW-Gary-1
19978: PPUSH
19979: CALL_OW 88
19983: GO 20106
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19985: LD_EXP 44
19989: PUSH
19990: LD_EXP 61
19994: IN
19995: PUSH
19996: LD_EXP 44
20000: PPUSH
20001: CALL_OW 255
20005: PUSH
20006: LD_INT 1
20008: EQUAL
20009: AND
20010: IFFALSE 20026
// Say ( Donaldson , D3nW-Don-1 ) else
20012: LD_EXP 44
20016: PPUSH
20017: LD_STRING D3nW-Don-1
20019: PPUSH
20020: CALL_OW 88
20024: GO 20106
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20026: LD_EXP 51
20030: PUSH
20031: LD_EXP 61
20035: IN
20036: PUSH
20037: LD_EXP 51
20041: PPUSH
20042: CALL_OW 255
20046: PUSH
20047: LD_INT 1
20049: EQUAL
20050: AND
20051: IFFALSE 20067
// Say ( Cornel , D3nW-Corn-1 ) else
20053: LD_EXP 51
20057: PPUSH
20058: LD_STRING D3nW-Corn-1
20060: PPUSH
20061: CALL_OW 88
20065: GO 20106
// if Frank in vip and GetSide ( Frank ) = 1 then
20067: LD_EXP 53
20071: PUSH
20072: LD_EXP 61
20076: IN
20077: PUSH
20078: LD_EXP 53
20082: PPUSH
20083: CALL_OW 255
20087: PUSH
20088: LD_INT 1
20090: EQUAL
20091: AND
20092: IFFALSE 20106
// Say ( Frank , D3nW-Frank-1 ) ;
20094: LD_EXP 53
20098: PPUSH
20099: LD_STRING D3nW-Frank-1
20101: PPUSH
20102: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20106: LD_EXP 61
20110: PPUSH
20111: LD_INT 22
20113: PUSH
20114: LD_INT 1
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PPUSH
20121: CALL_OW 72
20125: IFFALSE 20151
// begin Say ( JMM , D3nW-JMM-1 ) ;
20127: LD_EXP 40
20131: PPUSH
20132: LD_STRING D3nW-JMM-1
20134: PPUSH
20135: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20139: LD_EXP 40
20143: PPUSH
20144: LD_STRING D3nW-JMM-1a
20146: PPUSH
20147: CALL_OW 88
// end ; t := 0 0$00 ;
20151: LD_ADDR_VAR 0 3
20155: PUSH
20156: LD_INT 0
20158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20159: LD_INT 35
20161: PPUSH
20162: CALL_OW 67
// t := t + 0 0$1 ;
20166: LD_ADDR_VAR 0 3
20170: PUSH
20171: LD_VAR 0 3
20175: PUSH
20176: LD_INT 35
20178: PLUS
20179: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20180: LD_INT 59
20182: PPUSH
20183: LD_INT 112
20185: PPUSH
20186: CALL_OW 428
20190: PUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 2100
20198: GREATER
20199: OR
20200: IFFALSE 20159
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20202: LD_ADDR_EXP 101
20206: PUSH
20207: LD_EXP 101
20211: PPUSH
20212: LD_INT 4
20214: PPUSH
20215: LD_INT 22
20217: PUSH
20218: LD_INT 4
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 23
20227: PUSH
20228: LD_INT 1
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 3
20237: PUSH
20238: LD_INT 21
20240: PUSH
20241: LD_INT 2
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: EMPTY
20253: LIST
20254: LIST
20255: LIST
20256: PPUSH
20257: CALL_OW 69
20261: PUSH
20262: LD_EXP 60
20266: DIFF
20267: PPUSH
20268: CALL_OW 1
20272: ST_TO_ADDR
// activeAttacks := true ;
20273: LD_ADDR_EXP 16
20277: PUSH
20278: LD_INT 1
20280: ST_TO_ADDR
// end ;
20281: LD_VAR 0 1
20285: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20286: LD_INT 0
20288: PPUSH
// case question of 1 :
20289: LD_VAR 0 1
20293: PUSH
20294: LD_INT 1
20296: DOUBLE
20297: EQUAL
20298: IFTRUE 20302
20300: GO 20353
20302: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20303: LD_EXP 40
20307: PPUSH
20308: LD_STRING D2Mot-JMM-1
20310: PPUSH
20311: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20315: LD_EXP 60
20319: PPUSH
20320: LD_STRING D2Mot-Pow-1
20322: PPUSH
20323: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20327: LD_EXP 40
20331: PPUSH
20332: LD_STRING D2Mot-JMM-2
20334: PPUSH
20335: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20339: LD_EXP 60
20343: PPUSH
20344: LD_STRING D2Mot-Pow-2
20346: PPUSH
20347: CALL_OW 88
// end ; 2 :
20351: GO 20704
20353: LD_INT 2
20355: DOUBLE
20356: EQUAL
20357: IFTRUE 20361
20359: GO 20437
20361: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20362: LD_EXP 40
20366: PPUSH
20367: LD_STRING D2Rus-JMM-1
20369: PPUSH
20370: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20374: LD_EXP 60
20378: PPUSH
20379: LD_STRING D2Rus-Pow-1
20381: PPUSH
20382: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20386: LD_EXP 40
20390: PPUSH
20391: LD_STRING D2Rus-JMM-2
20393: PPUSH
20394: CALL_OW 88
// if not ( 3 in list_of_q ) then
20398: LD_INT 3
20400: PUSH
20401: LD_VAR 0 2
20405: IN
20406: NOT
20407: IFFALSE 20423
// Say ( Powell , D2Rus-Pow-2 ) else
20409: LD_EXP 60
20413: PPUSH
20414: LD_STRING D2Rus-Pow-2
20416: PPUSH
20417: CALL_OW 88
20421: GO 20435
// Say ( Powell , D2Rus-Pow-2a ) ;
20423: LD_EXP 60
20427: PPUSH
20428: LD_STRING D2Rus-Pow-2a
20430: PPUSH
20431: CALL_OW 88
// end ; 3 :
20435: GO 20704
20437: LD_INT 3
20439: DOUBLE
20440: EQUAL
20441: IFTRUE 20445
20443: GO 20530
20445: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20446: LD_EXP 40
20450: PPUSH
20451: LD_STRING D2Leg-JMM-1
20453: PPUSH
20454: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20458: LD_EXP 60
20462: PPUSH
20463: LD_STRING D2Leg-Pow-1
20465: PPUSH
20466: CALL_OW 88
// if 2 in list_of_q then
20470: LD_INT 2
20472: PUSH
20473: LD_VAR 0 2
20477: IN
20478: IFFALSE 20504
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20480: LD_EXP 40
20484: PPUSH
20485: LD_STRING D2Leg-JMM-2
20487: PPUSH
20488: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20492: LD_EXP 60
20496: PPUSH
20497: LD_STRING D2Leg-Pow-2
20499: PPUSH
20500: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20504: LD_EXP 40
20508: PPUSH
20509: LD_STRING D2Leg-JMM-3
20511: PPUSH
20512: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20516: LD_EXP 60
20520: PPUSH
20521: LD_STRING D2Leg-Pow-3
20523: PPUSH
20524: CALL_OW 88
// end ; 4 :
20528: GO 20704
20530: LD_INT 4
20532: DOUBLE
20533: EQUAL
20534: IFTRUE 20538
20536: GO 20613
20538: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20539: LD_EXP 40
20543: PPUSH
20544: LD_STRING D2Ar-JMM-1
20546: PPUSH
20547: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20551: LD_EXP 60
20555: PPUSH
20556: LD_STRING D2Ar-Pow-1
20558: PPUSH
20559: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20563: LD_EXP 40
20567: PPUSH
20568: LD_STRING D2Ar-JMM-2
20570: PPUSH
20571: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20575: LD_EXP 60
20579: PPUSH
20580: LD_STRING D2Ar-Pow-2
20582: PPUSH
20583: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20587: LD_EXP 40
20591: PPUSH
20592: LD_STRING D2Ar-JMM-3
20594: PPUSH
20595: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20599: LD_EXP 60
20603: PPUSH
20604: LD_STRING D2Ar-Pow-3
20606: PPUSH
20607: CALL_OW 88
// end ; 5 :
20611: GO 20704
20613: LD_INT 5
20615: DOUBLE
20616: EQUAL
20617: IFTRUE 20621
20619: GO 20636
20621: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20622: LD_EXP 40
20626: PPUSH
20627: LD_STRING D2Conf-JMM-1
20629: PPUSH
20630: CALL_OW 88
20634: GO 20704
20636: LD_INT 6
20638: DOUBLE
20639: EQUAL
20640: IFTRUE 20644
20642: GO 20703
20644: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20645: LD_EXP 40
20649: PPUSH
20650: LD_STRING D2Com-JMM-1
20652: PPUSH
20653: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20657: LD_EXP 60
20661: PPUSH
20662: LD_STRING D2Com-Pow-1
20664: PPUSH
20665: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20669: LD_EXP 40
20673: PPUSH
20674: LD_STRING D2Com-JMM-2
20676: PPUSH
20677: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20681: LD_EXP 60
20685: PPUSH
20686: LD_STRING D2Com-Pow-2
20688: PPUSH
20689: CALL_OW 88
// powellAngerQuery := true ;
20693: LD_ADDR_EXP 36
20697: PUSH
20698: LD_INT 1
20700: ST_TO_ADDR
// end ; end ;
20701: GO 20704
20703: POP
// end ;
20704: LD_VAR 0 3
20708: RET
// every 0 0$5 trigger missionStart do var tmp ;
20709: LD_EXP 13
20713: IFFALSE 21038
20715: GO 20717
20717: DISABLE
20718: LD_INT 0
20720: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20721: LD_INT 35
20723: PPUSH
20724: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20728: LD_INT 14
20730: PPUSH
20731: LD_INT 22
20733: PUSH
20734: LD_INT 1
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: LD_INT 3
20743: PUSH
20744: LD_INT 21
20746: PUSH
20747: LD_INT 3
20749: PUSH
20750: EMPTY
20751: LIST
20752: LIST
20753: PUSH
20754: EMPTY
20755: LIST
20756: LIST
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: PPUSH
20762: CALL_OW 70
20766: PUSH
20767: LD_EXP 15
20771: PUSH
20772: LD_INT 2
20774: PUSH
20775: LD_INT 3
20777: PUSH
20778: LD_INT 4
20780: PUSH
20781: LD_INT 5
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: IN
20790: AND
20791: IFFALSE 21028
// begin powellAnger := powellAnger + 1 ;
20793: LD_ADDR_EXP 17
20797: PUSH
20798: LD_EXP 17
20802: PUSH
20803: LD_INT 1
20805: PLUS
20806: ST_TO_ADDR
// Video ( true ) ;
20807: LD_INT 1
20809: PPUSH
20810: CALL 107116 0 1
// CenterNowOnUnits ( tmp ) ;
20814: LD_VAR 0 1
20818: PPUSH
20819: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20823: LD_INT 14
20825: PPUSH
20826: LD_INT 22
20828: PUSH
20829: LD_INT 1
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 70
20840: PPUSH
20841: LD_INT 86
20843: PPUSH
20844: LD_INT 133
20846: PPUSH
20847: CALL_OW 111
// async ;
20851: ASYNC
// case powellAnger of 1 :
20852: LD_EXP 17
20856: PUSH
20857: LD_INT 1
20859: DOUBLE
20860: EQUAL
20861: IFTRUE 20865
20863: GO 20880
20865: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20866: LD_EXP 60
20870: PPUSH
20871: LD_STRING DBack1-Pow-1
20873: PPUSH
20874: CALL_OW 88
20878: GO 20927
20880: LD_INT 2
20882: DOUBLE
20883: EQUAL
20884: IFTRUE 20888
20886: GO 20903
20888: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20889: LD_EXP 60
20893: PPUSH
20894: LD_STRING DBack2-Pow-1
20896: PPUSH
20897: CALL_OW 88
20901: GO 20927
20903: LD_INT 3
20905: DOUBLE
20906: EQUAL
20907: IFTRUE 20911
20909: GO 20926
20911: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20912: LD_EXP 60
20916: PPUSH
20917: LD_STRING DBack3-Pow-1
20919: PPUSH
20920: CALL_OW 88
20924: GO 20927
20926: POP
// sync ;
20927: SYNC
// repeat wait ( 0 0$1 ) ;
20928: LD_INT 35
20930: PPUSH
20931: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20935: LD_INT 14
20937: PPUSH
20938: LD_INT 22
20940: PUSH
20941: LD_INT 1
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PPUSH
20948: CALL_OW 70
20952: PPUSH
20953: LD_INT 86
20955: PPUSH
20956: LD_INT 133
20958: PPUSH
20959: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20963: LD_INT 14
20965: PPUSH
20966: LD_INT 22
20968: PUSH
20969: LD_INT 1
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 3
20978: PUSH
20979: LD_INT 21
20981: PUSH
20982: LD_INT 3
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL_OW 70
21001: NOT
21002: IFFALSE 20928
// if powellAnger >= 3 then
21004: LD_EXP 17
21008: PUSH
21009: LD_INT 3
21011: GREATEREQUAL
21012: IFFALSE 21021
// YouLost ( Dismissed ) ;
21014: LD_STRING Dismissed
21016: PPUSH
21017: CALL_OW 104
// Video ( false ) ;
21021: LD_INT 0
21023: PPUSH
21024: CALL 107116 0 1
// end ; until missionStage > 5 ;
21028: LD_EXP 15
21032: PUSH
21033: LD_INT 5
21035: GREATER
21036: IFFALSE 20721
// end ;
21038: PPOPN 1
21040: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21041: LD_EXP 13
21045: PUSH
21046: LD_INT 22
21048: PUSH
21049: LD_INT 4
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: PUSH
21056: LD_INT 21
21058: PUSH
21059: LD_INT 2
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 69
21074: PUSH
21075: LD_INT 4
21077: GREATEREQUAL
21078: AND
21079: PUSH
21080: LD_EXP 15
21084: PUSH
21085: LD_INT 2
21087: EQUAL
21088: AND
21089: IFFALSE 23339
21091: GO 21093
21093: DISABLE
21094: LD_INT 0
21096: PPUSH
21097: PPUSH
21098: PPUSH
21099: PPUSH
21100: PPUSH
21101: PPUSH
21102: PPUSH
21103: PPUSH
21104: PPUSH
21105: PPUSH
21106: PPUSH
// begin missionStage := 3 ;
21107: LD_ADDR_EXP 15
21111: PUSH
21112: LD_INT 3
21114: ST_TO_ADDR
// retreat := false ;
21115: LD_ADDR_VAR 0 4
21119: PUSH
21120: LD_INT 0
21122: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21123: LD_ADDR_VAR 0 5
21127: PUSH
21128: LD_INT 22
21130: PUSH
21131: LD_INT 4
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PUSH
21138: LD_INT 30
21140: PUSH
21141: LD_INT 4
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PPUSH
21152: CALL_OW 69
21156: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21157: LD_ADDR_VAR 0 6
21161: PUSH
21162: LD_INT 22
21164: PUSH
21165: LD_INT 4
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 30
21174: PUSH
21175: LD_INT 5
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: PPUSH
21186: CALL_OW 69
21190: ST_TO_ADDR
// if not bar then
21191: LD_VAR 0 6
21195: NOT
21196: IFFALSE 21249
// begin repeat wait ( 0 0$1 ) ;
21198: LD_INT 35
21200: PPUSH
21201: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21205: LD_INT 22
21207: PUSH
21208: LD_INT 4
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: LD_INT 3
21217: PUSH
21218: LD_INT 57
21220: PUSH
21221: EMPTY
21222: LIST
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: PUSH
21228: LD_INT 30
21230: PUSH
21231: LD_INT 5
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: PPUSH
21243: CALL_OW 69
21247: IFFALSE 21198
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21249: LD_ADDR_VAR 0 6
21253: PUSH
21254: LD_INT 22
21256: PUSH
21257: LD_INT 4
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: PUSH
21264: LD_INT 30
21266: PUSH
21267: LD_INT 5
21269: PUSH
21270: EMPTY
21271: LIST
21272: LIST
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PPUSH
21278: CALL_OW 69
21282: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21283: LD_INT 35
21285: PPUSH
21286: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21290: LD_EXP 120
21294: PUSH
21295: LD_INT 4
21297: ARRAY
21298: PUSH
21299: LD_INT 4
21301: GREATEREQUAL
21302: IFFALSE 21283
// tmp := [ ] ;
21304: LD_ADDR_VAR 0 2
21308: PUSH
21309: EMPTY
21310: ST_TO_ADDR
// tmp2 := [ ] ;
21311: LD_ADDR_VAR 0 3
21315: PUSH
21316: EMPTY
21317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21318: LD_ADDR_VAR 0 1
21322: PUSH
21323: LD_INT 22
21325: PUSH
21326: LD_INT 4
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: LD_INT 2
21335: PUSH
21336: LD_INT 25
21338: PUSH
21339: LD_INT 1
21341: PUSH
21342: EMPTY
21343: LIST
21344: LIST
21345: PUSH
21346: LD_INT 25
21348: PUSH
21349: LD_INT 2
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: LD_INT 25
21358: PUSH
21359: LD_INT 3
21361: PUSH
21362: EMPTY
21363: LIST
21364: LIST
21365: PUSH
21366: LD_INT 25
21368: PUSH
21369: LD_INT 4
21371: PUSH
21372: EMPTY
21373: LIST
21374: LIST
21375: PUSH
21376: LD_INT 25
21378: PUSH
21379: LD_INT 5
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: PPUSH
21398: CALL_OW 69
21402: PUSH
21403: LD_EXP 60
21407: PUSH
21408: LD_EXP 61
21412: UNION
21413: DIFF
21414: PUSH
21415: FOR_IN
21416: IFFALSE 21478
// if not i in extraSquad then
21418: LD_VAR 0 1
21422: PUSH
21423: LD_EXP 62
21427: IN
21428: NOT
21429: IFFALSE 21453
// tmp := Join ( tmp , i ) else
21431: LD_ADDR_VAR 0 2
21435: PUSH
21436: LD_VAR 0 2
21440: PPUSH
21441: LD_VAR 0 1
21445: PPUSH
21446: CALL 107144 0 2
21450: ST_TO_ADDR
21451: GO 21476
// tmp := Insert ( tmp , 1 , i ) ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_VAR 0 2
21462: PPUSH
21463: LD_INT 1
21465: PPUSH
21466: LD_VAR 0 1
21470: PPUSH
21471: CALL_OW 2
21475: ST_TO_ADDR
21476: GO 21415
21478: POP
21479: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21480: LD_ADDR_VAR 0 1
21484: PUSH
21485: LD_VAR 0 2
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: PUSH
21505: FOR_IN
21506: IFFALSE 21557
// begin p := Inc ( p ) ;
21508: LD_ADDR_VAR 0 11
21512: PUSH
21513: LD_VAR 0 11
21517: PPUSH
21518: CALL 108505 0 1
21522: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21523: LD_ADDR_VAR 0 3
21527: PUSH
21528: LD_VAR 0 3
21532: PPUSH
21533: LD_VAR 0 1
21537: PPUSH
21538: CALL 107144 0 2
21542: ST_TO_ADDR
// if p = 4 then
21543: LD_VAR 0 11
21547: PUSH
21548: LD_INT 4
21550: EQUAL
21551: IFFALSE 21555
// break ;
21553: GO 21557
// end ;
21555: GO 21505
21557: POP
21558: POP
// tmp := tmp diff tmp2 ;
21559: LD_ADDR_VAR 0 2
21563: PUSH
21564: LD_VAR 0 2
21568: PUSH
21569: LD_VAR 0 3
21573: DIFF
21574: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21575: LD_ADDR_VAR 0 2
21579: PUSH
21580: LD_VAR 0 2
21584: PPUSH
21585: LD_INT 3
21587: PPUSH
21588: CALL 105648 0 2
21592: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21593: LD_ADDR_VAR 0 3
21597: PUSH
21598: LD_VAR 0 3
21602: PPUSH
21603: LD_INT 3
21605: PPUSH
21606: CALL 105648 0 2
21610: ST_TO_ADDR
// for i := 1 to 4 do
21611: LD_ADDR_VAR 0 1
21615: PUSH
21616: DOUBLE
21617: LD_INT 1
21619: DEC
21620: ST_TO_ADDR
21621: LD_INT 4
21623: PUSH
21624: FOR_TO
21625: IFFALSE 21778
// begin if tmp2 then
21627: LD_VAR 0 3
21631: IFFALSE 21699
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21633: LD_ADDR_EXP 18
21637: PUSH
21638: LD_EXP 18
21642: PPUSH
21643: LD_INT 1
21645: PPUSH
21646: LD_EXP 18
21650: PUSH
21651: LD_INT 1
21653: ARRAY
21654: PUSH
21655: LD_VAR 0 3
21659: PUSH
21660: LD_VAR 0 3
21664: ARRAY
21665: ADD
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21672: LD_VAR 0 3
21676: PUSH
21677: LD_VAR 0 3
21681: ARRAY
21682: PPUSH
21683: LD_INT 1
21685: PPUSH
21686: CALL_OW 109
// tmp2 := [ ] ;
21690: LD_ADDR_VAR 0 3
21694: PUSH
21695: EMPTY
21696: ST_TO_ADDR
// end else
21697: GO 21776
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21699: LD_ADDR_EXP 18
21703: PUSH
21704: LD_EXP 18
21708: PPUSH
21709: LD_INT 1
21711: PPUSH
21712: LD_EXP 18
21716: PUSH
21717: LD_INT 1
21719: ARRAY
21720: PUSH
21721: LD_VAR 0 2
21725: PUSH
21726: LD_VAR 0 2
21730: ARRAY
21731: ADD
21732: PPUSH
21733: CALL_OW 1
21737: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21738: LD_VAR 0 2
21742: PUSH
21743: LD_VAR 0 2
21747: ARRAY
21748: PPUSH
21749: LD_INT 1
21751: PPUSH
21752: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21756: LD_ADDR_VAR 0 2
21760: PUSH
21761: LD_VAR 0 2
21765: PPUSH
21766: LD_VAR 0 2
21770: PPUSH
21771: CALL_OW 3
21775: ST_TO_ADDR
// end ; end ;
21776: GO 21624
21778: POP
21779: POP
// if tmp2 then
21780: LD_VAR 0 3
21784: IFFALSE 21802
// tmp := tmp union tmp2 ;
21786: LD_ADDR_VAR 0 2
21790: PUSH
21791: LD_VAR 0 2
21795: PUSH
21796: LD_VAR 0 3
21800: UNION
21801: ST_TO_ADDR
// for i := 1 to 4 do
21802: LD_ADDR_VAR 0 1
21806: PUSH
21807: DOUBLE
21808: LD_INT 1
21810: DEC
21811: ST_TO_ADDR
21812: LD_INT 4
21814: PUSH
21815: FOR_TO
21816: IFFALSE 21865
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21818: LD_ADDR_EXP 18
21822: PUSH
21823: LD_EXP 18
21827: PPUSH
21828: LD_INT 2
21830: PPUSH
21831: LD_EXP 18
21835: PUSH
21836: LD_INT 2
21838: ARRAY
21839: PUSH
21840: LD_VAR 0 2
21844: PUSH
21845: LD_VAR 0 2
21849: PUSH
21850: LD_VAR 0 1
21854: MINUS
21855: ARRAY
21856: ADD
21857: PPUSH
21858: CALL_OW 1
21862: ST_TO_ADDR
21863: GO 21815
21865: POP
21866: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21867: LD_ADDR_EXP 101
21871: PUSH
21872: LD_EXP 101
21876: PPUSH
21877: LD_INT 4
21879: PPUSH
21880: LD_EXP 101
21884: PUSH
21885: LD_INT 4
21887: ARRAY
21888: PUSH
21889: LD_EXP 18
21893: PUSH
21894: LD_INT 1
21896: ARRAY
21897: DIFF
21898: PPUSH
21899: CALL_OW 1
21903: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21904: LD_VAR 0 5
21908: PUSH
21909: LD_INT 1
21911: ARRAY
21912: PPUSH
21913: CALL_OW 313
21917: IFFALSE 21972
// begin for i in UnitsInside ( arm [ 1 ] ) do
21919: LD_ADDR_VAR 0 1
21923: PUSH
21924: LD_VAR 0 5
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 313
21937: PUSH
21938: FOR_IN
21939: IFFALSE 21970
// begin ComExitBuilding ( i ) ;
21941: LD_VAR 0 1
21945: PPUSH
21946: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21950: LD_VAR 0 1
21954: PPUSH
21955: LD_VAR 0 6
21959: PUSH
21960: LD_INT 1
21962: ARRAY
21963: PPUSH
21964: CALL_OW 180
// end ;
21968: GO 21938
21970: POP
21971: POP
// end ; wait ( 0 0$3 ) ;
21972: LD_INT 105
21974: PPUSH
21975: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21979: LD_ADDR_VAR 0 1
21983: PUSH
21984: LD_EXP 18
21988: PUSH
21989: LD_INT 1
21991: ARRAY
21992: PUSH
21993: FOR_IN
21994: IFFALSE 22101
// begin if IsInUnit ( i ) then
21996: LD_VAR 0 1
22000: PPUSH
22001: CALL_OW 310
22005: IFFALSE 22016
// ComExitBuilding ( i ) ;
22007: LD_VAR 0 1
22011: PPUSH
22012: CALL_OW 122
// if GetClass ( i ) <> 1 then
22016: LD_VAR 0 1
22020: PPUSH
22021: CALL_OW 257
22025: PUSH
22026: LD_INT 1
22028: NONEQUAL
22029: IFFALSE 22070
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_VAR 0 5
22040: PUSH
22041: LD_INT 1
22043: ARRAY
22044: PPUSH
22045: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22049: LD_VAR 0 1
22053: PPUSH
22054: LD_INT 1
22056: PPUSH
22057: CALL_OW 183
// AddComExitBuilding ( i ) ;
22061: LD_VAR 0 1
22065: PPUSH
22066: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22070: LD_VAR 0 1
22074: PPUSH
22075: LD_INT 60
22077: PPUSH
22078: LD_INT 94
22080: PPUSH
22081: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22085: LD_VAR 0 1
22089: PPUSH
22090: LD_EXP 60
22094: PPUSH
22095: CALL_OW 179
// end ;
22099: GO 21993
22101: POP
22102: POP
// wait ( 0 0$45 ) ;
22103: LD_INT 1575
22105: PPUSH
22106: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22110: LD_EXP 60
22114: PPUSH
22115: LD_STRING D4-Pow-1
22117: PPUSH
22118: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22122: LD_ADDR_VAR 0 2
22126: PUSH
22127: LD_EXP 18
22131: PUSH
22132: LD_INT 1
22134: ARRAY
22135: PPUSH
22136: LD_INT 26
22138: PUSH
22139: LD_INT 1
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PPUSH
22146: CALL_OW 72
22150: ST_TO_ADDR
// if tmp then
22151: LD_VAR 0 2
22155: IFFALSE 22173
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22157: LD_VAR 0 2
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PPUSH
22166: LD_STRING D4-Sol1-1
22168: PPUSH
22169: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22173: LD_EXP 60
22177: PPUSH
22178: LD_STRING D4-Pow-2
22180: PPUSH
22181: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22185: LD_ADDR_VAR 0 1
22189: PUSH
22190: DOUBLE
22191: LD_INT 1
22193: DEC
22194: ST_TO_ADDR
22195: LD_EXP 18
22199: PUSH
22200: LD_INT 1
22202: ARRAY
22203: PUSH
22204: FOR_TO
22205: IFFALSE 22298
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22207: LD_EXP 18
22211: PUSH
22212: LD_INT 1
22214: ARRAY
22215: PUSH
22216: LD_VAR 0 1
22220: ARRAY
22221: PPUSH
22222: LD_EXP 120
22226: PUSH
22227: LD_INT 4
22229: ARRAY
22230: PUSH
22231: LD_INT 1
22233: ARRAY
22234: PPUSH
22235: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22239: LD_ADDR_EXP 120
22243: PUSH
22244: LD_EXP 120
22248: PPUSH
22249: LD_INT 4
22251: PPUSH
22252: LD_EXP 120
22256: PUSH
22257: LD_INT 4
22259: ARRAY
22260: PPUSH
22261: LD_INT 1
22263: PPUSH
22264: CALL_OW 3
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22274: LD_INT 8
22276: PPUSH
22277: LD_EXP 18
22281: PUSH
22282: LD_INT 1
22284: ARRAY
22285: PUSH
22286: LD_VAR 0 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 471
// end ;
22296: GO 22204
22298: POP
22299: POP
// repeat wait ( 0 0$1 ) ;
22300: LD_INT 35
22302: PPUSH
22303: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22307: LD_EXP 18
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PPUSH
22316: LD_INT 55
22318: PUSH
22319: EMPTY
22320: LIST
22321: PPUSH
22322: CALL_OW 72
22326: PUSH
22327: LD_INT 4
22329: GREATEREQUAL
22330: IFFALSE 22300
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22332: LD_EXP 18
22336: PUSH
22337: LD_INT 1
22339: ARRAY
22340: PPUSH
22341: LD_INT 69
22343: PPUSH
22344: LD_INT 94
22346: PPUSH
22347: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22351: LD_EXP 18
22355: PUSH
22356: LD_INT 1
22358: ARRAY
22359: PPUSH
22360: LD_INT 82
22362: PPUSH
22363: LD_INT 83
22365: PPUSH
22366: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22370: LD_EXP 18
22374: PUSH
22375: LD_INT 1
22377: ARRAY
22378: PPUSH
22379: LD_INT 77
22381: PPUSH
22382: LD_INT 69
22384: PPUSH
22385: CALL_OW 174
// repeat wait ( 3 ) ;
22389: LD_INT 3
22391: PPUSH
22392: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22396: LD_ADDR_VAR 0 1
22400: PUSH
22401: LD_EXP 18
22405: PUSH
22406: LD_INT 1
22408: ARRAY
22409: PUSH
22410: FOR_IN
22411: IFFALSE 22547
// begin if GetLives ( i ) < 990 then
22413: LD_VAR 0 1
22417: PPUSH
22418: CALL_OW 256
22422: PUSH
22423: LD_INT 990
22425: LESS
22426: IFFALSE 22440
// SetLives ( i , 1000 ) ;
22428: LD_VAR 0 1
22432: PPUSH
22433: LD_INT 1000
22435: PPUSH
22436: CALL_OW 234
// if not IsInUnit ( i ) then
22440: LD_VAR 0 1
22444: PPUSH
22445: CALL_OW 310
22449: NOT
22450: IFFALSE 22545
// begin if not HasTask ( i ) then
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 314
22461: NOT
22462: IFFALSE 22479
// ComMoveXY ( i , 64 , 93 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 64
22471: PPUSH
22472: LD_INT 93
22474: PPUSH
22475: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22479: LD_VAR 0 4
22483: NOT
22484: PUSH
22485: LD_VAR 0 1
22489: PPUSH
22490: CALL_OW 258
22494: PUSH
22495: LD_INT 1
22497: EQUAL
22498: AND
22499: IFFALSE 22545
// begin retreat := true ;
22501: LD_ADDR_VAR 0 4
22505: PUSH
22506: LD_INT 1
22508: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22509: LD_VAR 0 1
22513: PPUSH
22514: LD_INT 2
22516: PPUSH
22517: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22521: LD_VAR 0 1
22525: PPUSH
22526: LD_STRING D4a-Sol1-1
22528: PPUSH
22529: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22533: LD_EXP 60
22537: PPUSH
22538: LD_STRING D4a-Pow-1
22540: PPUSH
22541: CALL_OW 88
// end ; end ; end ;
22545: GO 22410
22547: POP
22548: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22549: LD_EXP 18
22553: PUSH
22554: LD_INT 1
22556: ARRAY
22557: PPUSH
22558: LD_INT 95
22560: PUSH
22561: LD_INT 9
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: PUSH
22568: LD_INT 3
22570: PUSH
22571: LD_INT 55
22573: PUSH
22574: EMPTY
22575: LIST
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 72
22589: PUSH
22590: LD_INT 4
22592: GREATEREQUAL
22593: IFFALSE 22389
// for i in powellSquadAttack [ 1 ] do
22595: LD_ADDR_VAR 0 1
22599: PUSH
22600: LD_EXP 18
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: PUSH
22609: FOR_IN
22610: IFFALSE 22746
// begin if GetTag ( i ) = 2 then
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 110
22621: PUSH
22622: LD_INT 2
22624: EQUAL
22625: IFFALSE 22687
// begin ComMoveXY ( i , 60 , 94 ) ;
22627: LD_VAR 0 1
22631: PPUSH
22632: LD_INT 60
22634: PPUSH
22635: LD_INT 94
22637: PPUSH
22638: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22642: LD_VAR 0 1
22646: PPUSH
22647: LD_EXP 60
22651: PPUSH
22652: CALL_OW 179
// wait ( 0 0$3 ) ;
22656: LD_INT 105
22658: PPUSH
22659: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22663: LD_VAR 0 1
22667: PPUSH
22668: LD_STRING D4a-Sol1-2
22670: PPUSH
22671: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22675: LD_EXP 60
22679: PPUSH
22680: LD_STRING D4a-Pow-2
22682: PPUSH
22683: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22687: LD_VAR 0 1
22691: PPUSH
22692: LD_INT 0
22694: PPUSH
22695: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22699: LD_ADDR_EXP 101
22703: PUSH
22704: LD_EXP 101
22708: PPUSH
22709: LD_INT 4
22711: PPUSH
22712: LD_EXP 101
22716: PUSH
22717: LD_INT 4
22719: ARRAY
22720: PUSH
22721: LD_VAR 0 1
22725: UNION
22726: PPUSH
22727: CALL_OW 1
22731: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22732: LD_INT 8
22734: PPUSH
22735: LD_VAR 0 1
22739: PPUSH
22740: CALL_OW 472
// end ;
22744: GO 22609
22746: POP
22747: POP
// wait ( 2 2$00 ) ;
22748: LD_INT 4200
22750: PPUSH
22751: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22755: LD_ADDR_VAR 0 9
22759: PUSH
22760: LD_INT 22
22762: PUSH
22763: LD_INT 4
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: LD_INT 30
22772: PUSH
22773: LD_INT 32
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 58
22782: PUSH
22783: EMPTY
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: PPUSH
22791: CALL_OW 69
22795: ST_TO_ADDR
// if tmp then
22796: LD_VAR 0 2
22800: IFFALSE 23040
// begin for i := 1 to tmp do
22802: LD_ADDR_VAR 0 1
22806: PUSH
22807: DOUBLE
22808: LD_INT 1
22810: DEC
22811: ST_TO_ADDR
22812: LD_VAR 0 2
22816: PUSH
22817: FOR_TO
22818: IFFALSE 23031
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22820: LD_ADDR_EXP 101
22824: PUSH
22825: LD_EXP 101
22829: PPUSH
22830: LD_INT 4
22832: PPUSH
22833: LD_EXP 101
22837: PUSH
22838: LD_INT 4
22840: ARRAY
22841: PUSH
22842: LD_VAR 0 2
22846: PUSH
22847: LD_VAR 0 1
22851: ARRAY
22852: DIFF
22853: PPUSH
22854: CALL_OW 1
22858: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22859: LD_ADDR_VAR 0 10
22863: PUSH
22864: LD_VAR 0 2
22868: PUSH
22869: LD_VAR 0 1
22873: ARRAY
22874: PPUSH
22875: CALL_OW 310
22879: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22880: LD_VAR 0 10
22884: PUSH
22885: LD_VAR 0 10
22889: PPUSH
22890: CALL_OW 266
22894: PUSH
22895: LD_INT 32
22897: EQUAL
22898: AND
22899: IFFALSE 22903
// continue ;
22901: GO 22817
// if t then
22903: LD_VAR 0 10
22907: IFFALSE 22924
// ComExitBuilding ( tmp [ i ] ) ;
22909: LD_VAR 0 2
22913: PUSH
22914: LD_VAR 0 1
22918: ARRAY
22919: PPUSH
22920: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22924: LD_VAR 0 2
22928: PUSH
22929: LD_VAR 0 1
22933: ARRAY
22934: PPUSH
22935: LD_VAR 0 5
22939: PUSH
22940: LD_INT 1
22942: ARRAY
22943: PPUSH
22944: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22948: LD_VAR 0 2
22952: PUSH
22953: LD_VAR 0 1
22957: ARRAY
22958: PPUSH
22959: LD_INT 1
22961: PPUSH
22962: CALL_OW 183
// if emptyTowers then
22966: LD_VAR 0 9
22970: IFFALSE 23029
// begin AddComExitBuilding ( tmp [ i ] ) ;
22972: LD_VAR 0 2
22976: PUSH
22977: LD_VAR 0 1
22981: ARRAY
22982: PPUSH
22983: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22987: LD_VAR 0 2
22991: PUSH
22992: LD_VAR 0 1
22996: ARRAY
22997: PPUSH
22998: LD_VAR 0 9
23002: PUSH
23003: LD_INT 1
23005: ARRAY
23006: PPUSH
23007: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23011: LD_ADDR_VAR 0 9
23015: PUSH
23016: LD_VAR 0 9
23020: PPUSH
23021: LD_INT 1
23023: PPUSH
23024: CALL_OW 3
23028: ST_TO_ADDR
// end ; end ;
23029: GO 22817
23031: POP
23032: POP
// wait ( 0 0$30 ) ;
23033: LD_INT 1050
23035: PPUSH
23036: CALL_OW 67
// end ; uc_side := 6 ;
23040: LD_ADDR_OWVAR 20
23044: PUSH
23045: LD_INT 6
23047: ST_TO_ADDR
// uc_nation := 3 ;
23048: LD_ADDR_OWVAR 21
23052: PUSH
23053: LD_INT 3
23055: ST_TO_ADDR
// ru := [ ] ;
23056: LD_ADDR_VAR 0 7
23060: PUSH
23061: EMPTY
23062: ST_TO_ADDR
// for i = 1 to 5 do
23063: LD_ADDR_VAR 0 1
23067: PUSH
23068: DOUBLE
23069: LD_INT 1
23071: DEC
23072: ST_TO_ADDR
23073: LD_INT 5
23075: PUSH
23076: FOR_TO
23077: IFFALSE 23197
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23079: LD_INT 22
23081: PUSH
23082: LD_INT 23
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 1
23091: PPUSH
23092: LD_INT 2
23094: PPUSH
23095: CALL_OW 12
23099: ARRAY
23100: PPUSH
23101: LD_INT 1
23103: PPUSH
23104: LD_INT 3
23106: PPUSH
23107: LD_INT 43
23109: PUSH
23110: LD_INT 44
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: PUSH
23117: LD_INT 1
23119: PPUSH
23120: LD_INT 2
23122: PPUSH
23123: CALL_OW 12
23127: ARRAY
23128: PPUSH
23129: LD_INT 89
23131: PPUSH
23132: CALL 74282 0 5
// un := CreateVehicle ;
23136: LD_ADDR_VAR 0 8
23140: PUSH
23141: CALL_OW 45
23145: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23146: LD_VAR 0 8
23150: PPUSH
23151: LD_INT 4
23153: PPUSH
23154: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23158: LD_VAR 0 8
23162: PPUSH
23163: LD_INT 136
23165: PPUSH
23166: LD_INT 90
23168: PPUSH
23169: LD_INT 8
23171: PPUSH
23172: LD_INT 0
23174: PPUSH
23175: CALL_OW 50
// ru := ru ^ un ;
23179: LD_ADDR_VAR 0 7
23183: PUSH
23184: LD_VAR 0 7
23188: PUSH
23189: LD_VAR 0 8
23193: ADD
23194: ST_TO_ADDR
// end ;
23195: GO 23076
23197: POP
23198: POP
// if ru then
23199: LD_VAR 0 7
23203: IFFALSE 23220
// ComAgressiveMove ( ru , 57 , 94 ) ;
23205: LD_VAR 0 7
23209: PPUSH
23210: LD_INT 57
23212: PPUSH
23213: LD_INT 94
23215: PPUSH
23216: CALL_OW 114
// wait ( 3 3$00 ) ;
23220: LD_INT 6300
23222: PPUSH
23223: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23227: LD_INT 4
23229: PPUSH
23230: LD_INT 3
23232: PUSH
23233: LD_INT 1
23235: PUSH
23236: LD_INT 1
23238: PUSH
23239: LD_INT 5
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 4
23250: PUSH
23251: LD_INT 1
23253: PUSH
23254: LD_INT 1
23256: PUSH
23257: LD_INT 6
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: PUSH
23266: LD_INT 4
23268: PUSH
23269: LD_INT 1
23271: PUSH
23272: LD_INT 1
23274: PUSH
23275: LD_INT 7
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: LIST
23282: LIST
23283: PUSH
23284: LD_INT 3
23286: PUSH
23287: LD_INT 1
23289: PUSH
23290: LD_INT 1
23292: PUSH
23293: LD_INT 7
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: PUSH
23302: LD_INT 3
23304: PUSH
23305: LD_INT 1
23307: PUSH
23308: LD_INT 1
23310: PUSH
23311: LD_INT 5
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: PPUSH
23327: CALL 62968 0 2
// missionStage := 4 ;
23331: LD_ADDR_EXP 15
23335: PUSH
23336: LD_INT 4
23338: ST_TO_ADDR
// end ;
23339: PPOPN 11
23341: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23342: LD_EXP 15
23346: PUSH
23347: LD_INT 4
23349: EQUAL
23350: PUSH
23351: LD_INT 22
23353: PUSH
23354: LD_INT 4
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 21
23363: PUSH
23364: LD_INT 2
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PPUSH
23375: CALL_OW 69
23379: PUSH
23380: LD_INT 5
23382: GREATEREQUAL
23383: AND
23384: IFFALSE 27651
23386: GO 23388
23388: DISABLE
23389: LD_INT 0
23391: PPUSH
23392: PPUSH
23393: PPUSH
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
// begin wait ( 0 0$10 ) ;
23404: LD_INT 350
23406: PPUSH
23407: CALL_OW 67
// missionStage := 5 ;
23411: LD_ADDR_EXP 15
23415: PUSH
23416: LD_INT 5
23418: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23419: LD_ADDR_VAR 0 10
23423: PUSH
23424: LD_INT 22
23426: PUSH
23427: LD_INT 4
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 5
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: PPUSH
23466: CALL_OW 69
23470: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23471: LD_ADDR_VAR 0 6
23475: PUSH
23476: LD_INT 22
23478: PUSH
23479: LD_INT 4
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: PUSH
23486: LD_INT 21
23488: PUSH
23489: LD_INT 1
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PUSH
23496: LD_INT 3
23498: PUSH
23499: LD_INT 25
23501: PUSH
23502: LD_INT 16
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: PUSH
23513: LD_INT 3
23515: PUSH
23516: LD_INT 25
23518: PUSH
23519: LD_INT 12
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: PUSH
23526: EMPTY
23527: LIST
23528: LIST
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: LIST
23534: LIST
23535: PPUSH
23536: CALL_OW 69
23540: PUSH
23541: LD_EXP 60
23545: DIFF
23546: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23547: LD_ADDR_VAR 0 9
23551: PUSH
23552: LD_INT 22
23554: PUSH
23555: LD_INT 4
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 30
23564: PUSH
23565: LD_INT 3
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: PPUSH
23576: CALL_OW 69
23580: PUSH
23581: LD_INT 1
23583: ARRAY
23584: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23585: LD_INT 350
23587: PPUSH
23588: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23592: LD_EXP 120
23596: PUSH
23597: LD_INT 4
23599: ARRAY
23600: PUSH
23601: LD_INT 5
23603: LESS
23604: PUSH
23605: LD_VAR 0 9
23609: PPUSH
23610: CALL_OW 461
23614: PUSH
23615: LD_INT 2
23617: EQUAL
23618: AND
23619: IFFALSE 23649
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23621: LD_INT 4
23623: PPUSH
23624: LD_INT 3
23626: PUSH
23627: LD_INT 1
23629: PUSH
23630: LD_INT 1
23632: PUSH
23633: LD_INT 5
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: PUSH
23642: EMPTY
23643: LIST
23644: PPUSH
23645: CALL 63016 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23649: LD_EXP 120
23653: PUSH
23654: LD_INT 4
23656: ARRAY
23657: PUSH
23658: LD_INT 5
23660: GREATEREQUAL
23661: PUSH
23662: LD_EXP 120
23666: PUSH
23667: LD_INT 4
23669: ARRAY
23670: PPUSH
23671: LD_INT 58
23673: PUSH
23674: EMPTY
23675: LIST
23676: PPUSH
23677: CALL_OW 72
23681: PUSH
23682: LD_INT 5
23684: GREATEREQUAL
23685: AND
23686: IFFALSE 23585
// powellAllowRetreat := false ;
23688: LD_ADDR_EXP 19
23692: PUSH
23693: LD_INT 0
23695: ST_TO_ADDR
// activeAttacks := false ;
23696: LD_ADDR_EXP 16
23700: PUSH
23701: LD_INT 0
23703: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23711: LD_INT 22
23713: PUSH
23714: LD_INT 6
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: PPUSH
23721: CALL_OW 69
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: IFFALSE 23704
// tmp := mc_vehicles [ 4 ] ;
23731: LD_ADDR_VAR 0 3
23735: PUSH
23736: LD_EXP 120
23740: PUSH
23741: LD_INT 4
23743: ARRAY
23744: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23745: LD_ADDR_VAR 0 1
23749: PUSH
23750: DOUBLE
23751: LD_INT 1
23753: DEC
23754: ST_TO_ADDR
23755: LD_EXP 18
23759: PUSH
23760: FOR_TO
23761: IFFALSE 24022
// begin for j in powellSquadAttack [ i ] do
23763: LD_ADDR_VAR 0 2
23767: PUSH
23768: LD_EXP 18
23772: PUSH
23773: LD_VAR 0 1
23777: ARRAY
23778: PUSH
23779: FOR_IN
23780: IFFALSE 24018
// begin forces := forces diff j ;
23782: LD_ADDR_VAR 0 6
23786: PUSH
23787: LD_VAR 0 6
23791: PUSH
23792: LD_VAR 0 2
23796: DIFF
23797: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_INT 1
23805: PPUSH
23806: CALL_OW 109
// wait ( 0 0$2 ) ;
23810: LD_INT 70
23812: PPUSH
23813: CALL_OW 67
// if IsInUnit ( j ) then
23817: LD_VAR 0 2
23821: PPUSH
23822: CALL_OW 310
23826: IFFALSE 23837
// ComExitBuilding ( j ) ;
23828: LD_VAR 0 2
23832: PPUSH
23833: CALL_OW 122
// if GetClass ( j ) <> 1 then
23837: LD_VAR 0 2
23841: PPUSH
23842: CALL_OW 257
23846: PUSH
23847: LD_INT 1
23849: NONEQUAL
23850: IFFALSE 23930
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23852: LD_VAR 0 10
23856: PUSH
23857: LD_INT 1
23859: ARRAY
23860: PPUSH
23861: CALL_OW 313
23865: PUSH
23866: LD_INT 5
23868: GREATEREQUAL
23869: IFFALSE 23891
// AddComEnterUnit ( j , arm [ 2 ] ) else
23871: LD_VAR 0 2
23875: PPUSH
23876: LD_VAR 0 10
23880: PUSH
23881: LD_INT 2
23883: ARRAY
23884: PPUSH
23885: CALL_OW 180
23889: GO 23909
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23891: LD_VAR 0 2
23895: PPUSH
23896: LD_VAR 0 10
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23909: LD_VAR 0 2
23913: PPUSH
23914: LD_INT 1
23916: PPUSH
23917: CALL_OW 183
// AddComExitBuilding ( j ) ;
23921: LD_VAR 0 2
23925: PPUSH
23926: CALL_OW 182
// end ; if i = 2 then
23930: LD_VAR 0 1
23934: PUSH
23935: LD_INT 2
23937: EQUAL
23938: IFFALSE 23955
// AddComMoveXY ( j , 61 , 93 ) ;
23940: LD_VAR 0 2
23944: PPUSH
23945: LD_INT 61
23947: PPUSH
23948: LD_INT 93
23950: PPUSH
23951: CALL_OW 171
// if i = 1 then
23955: LD_VAR 0 1
23959: PUSH
23960: LD_INT 1
23962: EQUAL
23963: IFFALSE 24016
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23965: LD_VAR 0 2
23969: PPUSH
23970: LD_VAR 0 3
23974: PUSH
23975: LD_INT 1
23977: ARRAY
23978: PPUSH
23979: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23983: LD_ADDR_VAR 0 3
23987: PUSH
23988: LD_VAR 0 3
23992: PPUSH
23993: LD_INT 1
23995: PPUSH
23996: CALL_OW 3
24000: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24001: LD_VAR 0 2
24005: PPUSH
24006: LD_INT 69
24008: PPUSH
24009: LD_INT 94
24011: PPUSH
24012: CALL_OW 171
// end ; end ;
24016: GO 23779
24018: POP
24019: POP
// end ;
24020: GO 23760
24022: POP
24023: POP
// wait ( 0 0$30 ) ;
24024: LD_INT 1050
24026: PPUSH
24027: CALL_OW 67
// MC_Kill ( 4 ) ;
24031: LD_INT 4
24033: PPUSH
24034: CALL 38991 0 1
// tmp := UnitsInside ( fac ) ;
24038: LD_ADDR_VAR 0 3
24042: PUSH
24043: LD_VAR 0 9
24047: PPUSH
24048: CALL_OW 313
24052: ST_TO_ADDR
// if tmp then
24053: LD_VAR 0 3
24057: IFFALSE 24178
// for i in tmp do
24059: LD_ADDR_VAR 0 1
24063: PUSH
24064: LD_VAR 0 3
24068: PUSH
24069: FOR_IN
24070: IFFALSE 24176
// begin ComExitBuilding ( i ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24081: LD_VAR 0 10
24085: PUSH
24086: LD_INT 2
24088: ARRAY
24089: PPUSH
24090: CALL_OW 313
24094: PUSH
24095: LD_INT 6
24097: LESS
24098: IFFALSE 24120
// AddComEnterUnit ( i , arm [ 2 ] ) else
24100: LD_VAR 0 1
24104: PPUSH
24105: LD_VAR 0 10
24109: PUSH
24110: LD_INT 2
24112: ARRAY
24113: PPUSH
24114: CALL_OW 180
24118: GO 24174
// if UnitsInside ( arm [ 1 ] ) < 6 then
24120: LD_VAR 0 10
24124: PUSH
24125: LD_INT 1
24127: ARRAY
24128: PPUSH
24129: CALL_OW 313
24133: PUSH
24134: LD_INT 6
24136: LESS
24137: IFFALSE 24159
// AddComEnterUnit ( i , arm [ 1 ] ) else
24139: LD_VAR 0 1
24143: PPUSH
24144: LD_VAR 0 10
24148: PUSH
24149: LD_INT 1
24151: ARRAY
24152: PPUSH
24153: CALL_OW 180
24157: GO 24174
// AddComMoveXY ( i , 37 , 68 ) ;
24159: LD_VAR 0 1
24163: PPUSH
24164: LD_INT 37
24166: PPUSH
24167: LD_INT 68
24169: PPUSH
24170: CALL_OW 171
// end ;
24174: GO 24069
24176: POP
24177: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24178: LD_ADDR_VAR 0 11
24182: PUSH
24183: LD_VAR 0 6
24187: PPUSH
24188: LD_INT 26
24190: PUSH
24191: LD_INT 1
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PPUSH
24198: CALL_OW 72
24202: PUSH
24203: LD_EXP 61
24207: DIFF
24208: ST_TO_ADDR
// if not speaker then
24209: LD_VAR 0 11
24213: NOT
24214: IFFALSE 24241
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24216: LD_ADDR_VAR 0 11
24220: PUSH
24221: LD_VAR 0 6
24225: PPUSH
24226: LD_INT 26
24228: PUSH
24229: LD_INT 1
24231: PUSH
24232: EMPTY
24233: LIST
24234: LIST
24235: PPUSH
24236: CALL_OW 72
24240: ST_TO_ADDR
// if speaker then
24241: LD_VAR 0 11
24245: IFFALSE 24261
// speaker := speaker [ 1 ] ;
24247: LD_ADDR_VAR 0 11
24251: PUSH
24252: LD_VAR 0 11
24256: PUSH
24257: LD_INT 1
24259: ARRAY
24260: ST_TO_ADDR
// Video ( true ) ;
24261: LD_INT 1
24263: PPUSH
24264: CALL 107116 0 1
// CenterNowOnUnits ( Powell ) ;
24268: LD_EXP 60
24272: PPUSH
24273: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24277: LD_ADDR_VAR 0 3
24281: PUSH
24282: LD_VAR 0 6
24286: PPUSH
24287: LD_INT 3
24289: PUSH
24290: LD_INT 25
24292: PUSH
24293: LD_INT 1
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PPUSH
24304: CALL_OW 72
24308: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24309: LD_ADDR_VAR 0 12
24313: PUSH
24314: LD_INT 22
24316: PUSH
24317: LD_INT 4
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PUSH
24324: LD_INT 30
24326: PUSH
24327: LD_INT 32
24329: PUSH
24330: EMPTY
24331: LIST
24332: LIST
24333: PUSH
24334: LD_INT 58
24336: PUSH
24337: EMPTY
24338: LIST
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: PPUSH
24345: CALL_OW 69
24349: ST_TO_ADDR
// for i := 1 to 4 do
24350: LD_ADDR_VAR 0 1
24354: PUSH
24355: DOUBLE
24356: LD_INT 1
24358: DEC
24359: ST_TO_ADDR
24360: LD_INT 4
24362: PUSH
24363: FOR_TO
24364: IFFALSE 24510
// begin if IsInUnit ( tmp [ i ] ) then
24366: LD_VAR 0 3
24370: PUSH
24371: LD_VAR 0 1
24375: ARRAY
24376: PPUSH
24377: CALL_OW 310
24381: IFFALSE 24398
// ComExitBuilding ( tmp [ i ] ) ;
24383: LD_VAR 0 3
24387: PUSH
24388: LD_VAR 0 1
24392: ARRAY
24393: PPUSH
24394: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24398: LD_VAR 0 3
24402: PUSH
24403: LD_VAR 0 1
24407: ARRAY
24408: PPUSH
24409: LD_VAR 0 10
24413: PUSH
24414: LD_INT 1
24416: ARRAY
24417: PPUSH
24418: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24422: LD_VAR 0 3
24426: PUSH
24427: LD_VAR 0 1
24431: ARRAY
24432: PPUSH
24433: LD_INT 1
24435: PPUSH
24436: CALL_OW 183
// if Count ( emp_towers ) then
24440: LD_VAR 0 12
24444: PPUSH
24445: CALL 71544 0 1
24449: IFFALSE 24508
// begin AddComExitBuilding ( tmp [ i ] ) ;
24451: LD_VAR 0 3
24455: PUSH
24456: LD_VAR 0 1
24460: ARRAY
24461: PPUSH
24462: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24466: LD_VAR 0 3
24470: PUSH
24471: LD_VAR 0 1
24475: ARRAY
24476: PPUSH
24477: LD_VAR 0 12
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24490: LD_ADDR_VAR 0 12
24494: PUSH
24495: LD_VAR 0 12
24499: PPUSH
24500: LD_INT 1
24502: PPUSH
24503: CALL_OW 3
24507: ST_TO_ADDR
// end ; end ;
24508: GO 24363
24510: POP
24511: POP
// wait ( 0 0$5 ) ;
24512: LD_INT 175
24514: PPUSH
24515: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24519: LD_VAR 0 3
24523: PPUSH
24524: LD_INT 3
24526: PUSH
24527: LD_INT 54
24529: PUSH
24530: EMPTY
24531: LIST
24532: PUSH
24533: EMPTY
24534: LIST
24535: LIST
24536: PPUSH
24537: CALL_OW 72
24541: IFFALSE 24561
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24543: LD_VAR 0 3
24547: PPUSH
24548: LD_VAR 0 10
24552: PUSH
24553: LD_INT 1
24555: ARRAY
24556: PPUSH
24557: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24561: LD_ADDR_VAR 0 3
24565: PUSH
24566: LD_EXP 18
24570: PUSH
24571: LD_INT 1
24573: ARRAY
24574: PUSH
24575: LD_EXP 18
24579: PUSH
24580: LD_INT 2
24582: ARRAY
24583: ADD
24584: PPUSH
24585: LD_INT 26
24587: PUSH
24588: LD_INT 1
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: PPUSH
24595: CALL_OW 72
24599: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24600: LD_ADDR_VAR 0 1
24604: PUSH
24605: LD_EXP 18
24609: PUSH
24610: LD_INT 2
24612: ARRAY
24613: PUSH
24614: FOR_IN
24615: IFFALSE 24633
// ComTurnUnit ( i , Powell ) ;
24617: LD_VAR 0 1
24621: PPUSH
24622: LD_EXP 60
24626: PPUSH
24627: CALL_OW 119
24631: GO 24614
24633: POP
24634: POP
// Say ( Powell , D5-Pow-1 ) ;
24635: LD_EXP 60
24639: PPUSH
24640: LD_STRING D5-Pow-1
24642: PPUSH
24643: CALL_OW 88
// if tmp then
24647: LD_VAR 0 3
24651: IFFALSE 24669
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24653: LD_VAR 0 3
24657: PUSH
24658: LD_INT 1
24660: ARRAY
24661: PPUSH
24662: LD_STRING D5-Sol2-1
24664: PPUSH
24665: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24669: LD_EXP 60
24673: PPUSH
24674: LD_STRING D5-Pow-2
24676: PPUSH
24677: CALL_OW 88
// if tmp > 1 then
24681: LD_VAR 0 3
24685: PUSH
24686: LD_INT 1
24688: GREATER
24689: IFFALSE 24707
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24691: LD_VAR 0 3
24695: PUSH
24696: LD_INT 2
24698: ARRAY
24699: PPUSH
24700: LD_STRING D5-Sol2-2
24702: PPUSH
24703: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24707: LD_EXP 60
24711: PPUSH
24712: LD_STRING D5-Pow-3
24714: PPUSH
24715: CALL_OW 88
// wait ( 0 0$1 ) ;
24719: LD_INT 35
24721: PPUSH
24722: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24726: LD_ADDR_VAR 0 3
24730: PUSH
24731: LD_EXP 18
24735: PUSH
24736: LD_INT 1
24738: ARRAY
24739: PUSH
24740: LD_EXP 18
24744: PUSH
24745: LD_INT 2
24747: ARRAY
24748: UNION
24749: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24750: LD_VAR 0 3
24754: PPUSH
24755: LD_INT 80
24757: PPUSH
24758: LD_INT 67
24760: PPUSH
24761: CALL_OW 114
// wait ( 0 0$2 ) ;
24765: LD_INT 70
24767: PPUSH
24768: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24772: LD_INT 79
24774: PPUSH
24775: LD_INT 72
24777: PPUSH
24778: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24782: LD_INT 70
24784: PPUSH
24785: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24789: LD_VAR 0 3
24793: PPUSH
24794: LD_INT 3
24796: PUSH
24797: LD_INT 24
24799: PUSH
24800: LD_INT 1000
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: EMPTY
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 72
24815: IFFALSE 24782
// Say ( Powell , D5a-Pow-1 ) ;
24817: LD_EXP 60
24821: PPUSH
24822: LD_STRING D5a-Pow-1
24824: PPUSH
24825: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24829: LD_EXP 60
24833: PPUSH
24834: LD_STRING D5a-Pow-1a
24836: PPUSH
24837: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24841: LD_INT 24
24843: PPUSH
24844: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24848: LD_EXP 60
24852: PPUSH
24853: LD_STRING D5a-Pow-1b
24855: PPUSH
24856: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24860: LD_INT 10
24862: PPUSH
24863: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24867: LD_EXP 60
24871: PPUSH
24872: LD_STRING D5a-Pow-1c
24874: PPUSH
24875: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24879: LD_VAR 0 3
24883: PPUSH
24884: LD_INT 68
24886: PPUSH
24887: LD_INT 63
24889: PPUSH
24890: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24894: LD_INT 18
24896: PPUSH
24897: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24901: LD_EXP 60
24905: PPUSH
24906: LD_STRING D5a-Pow-1d
24908: PPUSH
24909: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24913: LD_INT 35
24915: PPUSH
24916: CALL_OW 67
// if not HasTask ( tmp ) then
24920: LD_VAR 0 3
24924: PPUSH
24925: CALL_OW 314
24929: NOT
24930: IFFALSE 24947
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24932: LD_VAR 0 3
24936: PPUSH
24937: LD_INT 68
24939: PPUSH
24940: LD_INT 63
24942: PPUSH
24943: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24947: LD_VAR 0 3
24951: PPUSH
24952: LD_INT 24
24954: PUSH
24955: LD_INT 1
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PPUSH
24962: CALL_OW 72
24966: NOT
24967: IFFALSE 24913
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_INT 22
24976: PUSH
24977: LD_INT 4
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: PUSH
24984: LD_INT 92
24986: PUSH
24987: LD_INT 60
24989: PUSH
24990: LD_INT 93
24992: PUSH
24993: LD_INT 10
24995: PUSH
24996: EMPTY
24997: LIST
24998: LIST
24999: LIST
25000: LIST
25001: PUSH
25002: LD_INT 3
25004: PUSH
25005: LD_INT 54
25007: PUSH
25008: EMPTY
25009: LIST
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: LIST
25019: PPUSH
25020: CALL_OW 69
25024: PUSH
25025: LD_EXP 60
25029: DIFF
25030: ST_TO_ADDR
// if tmp then
25031: LD_VAR 0 3
25035: IFFALSE 25069
// for i in tmp do
25037: LD_ADDR_VAR 0 1
25041: PUSH
25042: LD_VAR 0 3
25046: PUSH
25047: FOR_IN
25048: IFFALSE 25067
// ComMoveXY ( i , 36 , 67 ) ;
25050: LD_VAR 0 1
25054: PPUSH
25055: LD_INT 36
25057: PPUSH
25058: LD_INT 67
25060: PPUSH
25061: CALL_OW 111
25065: GO 25047
25067: POP
25068: POP
// wait ( 0 0$3 ) ;
25069: LD_INT 105
25071: PPUSH
25072: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25076: LD_VAR 0 11
25080: PPUSH
25081: LD_STRING D6-Sol3-1
25083: PPUSH
25084: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25088: LD_EXP 60
25092: PPUSH
25093: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25097: LD_EXP 60
25101: PPUSH
25102: LD_STRING D6-Pow-1
25104: PPUSH
25105: CALL_OW 88
// tmp := [ ] ;
25109: LD_ADDR_VAR 0 3
25113: PUSH
25114: EMPTY
25115: ST_TO_ADDR
// for i = 1 to 2 do
25116: LD_ADDR_VAR 0 1
25120: PUSH
25121: DOUBLE
25122: LD_INT 1
25124: DEC
25125: ST_TO_ADDR
25126: LD_INT 2
25128: PUSH
25129: FOR_TO
25130: IFFALSE 25244
// begin uc_side := 8 ;
25132: LD_ADDR_OWVAR 20
25136: PUSH
25137: LD_INT 8
25139: ST_TO_ADDR
// uc_nation := 2 ;
25140: LD_ADDR_OWVAR 21
25144: PUSH
25145: LD_INT 2
25147: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25148: LD_INT 14
25150: PPUSH
25151: LD_INT 3
25153: PPUSH
25154: LD_INT 2
25156: PPUSH
25157: LD_INT 29
25159: PPUSH
25160: LD_INT 100
25162: PPUSH
25163: CALL 74282 0 5
// veh := CreateVehicle ;
25167: LD_ADDR_VAR 0 13
25171: PUSH
25172: CALL_OW 45
25176: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25177: LD_VAR 0 13
25181: PPUSH
25182: LD_INT 4
25184: PPUSH
25185: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25189: LD_VAR 0 13
25193: PPUSH
25194: LD_INT 99
25196: PPUSH
25197: LD_INT 83
25199: PPUSH
25200: LD_INT 3
25202: PPUSH
25203: LD_INT 0
25205: PPUSH
25206: CALL_OW 50
// wait ( 3 ) ;
25210: LD_INT 3
25212: PPUSH
25213: CALL_OW 67
// Connect ( veh ) ;
25217: LD_VAR 0 13
25221: PPUSH
25222: CALL 77750 0 1
// tmp := tmp ^ veh ;
25226: LD_ADDR_VAR 0 3
25230: PUSH
25231: LD_VAR 0 3
25235: PUSH
25236: LD_VAR 0 13
25240: ADD
25241: ST_TO_ADDR
// end ;
25242: GO 25129
25244: POP
25245: POP
// wait ( 0 0$1 ) ;
25246: LD_INT 35
25248: PPUSH
25249: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25253: LD_INT 99
25255: PPUSH
25256: LD_INT 83
25258: PPUSH
25259: LD_INT 1
25261: PPUSH
25262: LD_INT 10
25264: PPUSH
25265: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25269: LD_INT 99
25271: PPUSH
25272: LD_INT 83
25274: PPUSH
25275: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25279: LD_VAR 0 11
25283: PPUSH
25284: LD_STRING D6-Sol3-2
25286: PPUSH
25287: CALL_OW 88
// async ;
25291: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25292: LD_EXP 60
25296: PPUSH
25297: LD_STRING D6-Pow-2
25299: PPUSH
25300: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25304: LD_VAR 0 3
25308: PUSH
25309: LD_INT 1
25311: ARRAY
25312: PPUSH
25313: LD_VAR 0 9
25317: PPUSH
25318: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25322: LD_VAR 0 3
25326: PUSH
25327: LD_INT 2
25329: ARRAY
25330: PPUSH
25331: LD_INT 22
25333: PUSH
25334: LD_INT 4
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 21
25343: PUSH
25344: LD_INT 3
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PPUSH
25355: CALL_OW 69
25359: PPUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 2
25367: ARRAY
25368: PPUSH
25369: CALL_OW 74
25373: PPUSH
25374: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25378: LD_EXP 60
25382: PPUSH
25383: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25387: LD_INT 99
25389: PPUSH
25390: LD_INT 83
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 331
// repeat wait ( 4 ) ;
25400: LD_INT 4
25402: PPUSH
25403: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25407: LD_VAR 0 3
25411: PUSH
25412: LD_INT 1
25414: ARRAY
25415: PPUSH
25416: CALL_OW 256
25420: PUSH
25421: LD_INT 1000
25423: LESS
25424: IFFALSE 25442
// SetLives ( tmp [ 1 ] , 1000 ) ;
25426: LD_VAR 0 3
25430: PUSH
25431: LD_INT 1
25433: ARRAY
25434: PPUSH
25435: LD_INT 1000
25437: PPUSH
25438: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25442: LD_INT 22
25444: PUSH
25445: LD_INT 4
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: PUSH
25452: LD_INT 30
25454: PUSH
25455: LD_INT 3
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: PUSH
25462: EMPTY
25463: LIST
25464: LIST
25465: PPUSH
25466: CALL_OW 69
25470: PUSH
25471: LD_INT 0
25473: EQUAL
25474: IFFALSE 25400
// skirmish := false ;
25476: LD_ADDR_EXP 99
25480: PUSH
25481: LD_INT 0
25483: ST_TO_ADDR
// sync ;
25484: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25485: LD_EXP 60
25489: PPUSH
25490: LD_STRING D6a-Pow-1
25492: PPUSH
25493: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25497: LD_VAR 0 11
25501: PPUSH
25502: LD_STRING D6a-Sol3-1
25504: PPUSH
25505: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25509: LD_EXP 60
25513: PPUSH
25514: LD_STRING D6a-Pow-2
25516: PPUSH
25517: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25521: LD_VAR 0 11
25525: PPUSH
25526: LD_STRING D6a-Sol3-2
25528: PPUSH
25529: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25533: LD_EXP 60
25537: PPUSH
25538: LD_STRING D6a-Pow-3
25540: PPUSH
25541: CALL_OW 88
// powellCenterCameraMode := true ;
25545: LD_ADDR_EXP 20
25549: PUSH
25550: LD_INT 1
25552: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25553: LD_ADDR_VAR 0 1
25557: PUSH
25558: LD_INT 22
25560: PUSH
25561: LD_INT 8
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 25
25570: PUSH
25571: LD_INT 2
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PPUSH
25582: CALL_OW 69
25586: PUSH
25587: FOR_IN
25588: IFFALSE 25643
// begin SetTag ( i , 1 ) ;
25590: LD_VAR 0 1
25594: PPUSH
25595: LD_INT 1
25597: PPUSH
25598: CALL_OW 109
// ComExitBuilding ( i ) ;
25602: LD_VAR 0 1
25606: PPUSH
25607: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25611: LD_VAR 0 1
25615: PPUSH
25616: LD_INT 35
25618: PPUSH
25619: LD_INT 6
25621: PPUSH
25622: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25626: LD_VAR 0 1
25630: PPUSH
25631: LD_INT 53
25633: PPUSH
25634: LD_INT 4
25636: PPUSH
25637: CALL_OW 171
// end ;
25641: GO 25587
25643: POP
25644: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25645: LD_ADDR_VAR 0 3
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_INT 4
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: LD_INT 21
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 3
25672: PUSH
25673: LD_INT 34
25675: PUSH
25676: LD_INT 12
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: EMPTY
25688: LIST
25689: LIST
25690: LIST
25691: PPUSH
25692: CALL_OW 69
25696: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25697: LD_EXP 60
25701: PPUSH
25702: LD_VAR 0 3
25706: PPUSH
25707: LD_EXP 60
25711: PPUSH
25712: CALL_OW 74
25716: PPUSH
25717: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25721: LD_EXP 60
25725: PPUSH
25726: LD_INT 100
25728: PPUSH
25729: LD_INT 88
25731: PPUSH
25732: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25736: LD_EXP 60
25740: PPUSH
25741: LD_INT 100
25743: PPUSH
25744: LD_INT 75
25746: PPUSH
25747: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25751: LD_EXP 60
25755: PPUSH
25756: LD_INT 88
25758: PPUSH
25759: LD_INT 53
25761: PPUSH
25762: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25766: LD_INT 8
25768: PPUSH
25769: LD_EXP 60
25773: PPUSH
25774: CALL_OW 471
// repeat wait ( 3 ) ;
25778: LD_INT 3
25780: PPUSH
25781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25785: LD_INT 22
25787: PUSH
25788: LD_INT 4
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: LD_INT 92
25797: PUSH
25798: LD_INT 100
25800: PUSH
25801: LD_INT 75
25803: PUSH
25804: LD_INT 6
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: LIST
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PPUSH
25817: CALL_OW 69
25821: IFFALSE 25778
// async ;
25823: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25824: LD_EXP 60
25828: PPUSH
25829: LD_STRING D6b-Pow-1
25831: PPUSH
25832: CALL_OW 88
// repeat wait ( 3 ) ;
25836: LD_INT 3
25838: PPUSH
25839: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25843: LD_EXP 60
25847: PPUSH
25848: CALL_OW 310
25852: PPUSH
25853: CALL_OW 256
25857: PUSH
25858: LD_INT 1000
25860: LESS
25861: IFFALSE 25880
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25863: LD_EXP 60
25867: PPUSH
25868: CALL_OW 310
25872: PPUSH
25873: LD_INT 1000
25875: PPUSH
25876: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25880: LD_EXP 60
25884: PPUSH
25885: CALL_OW 256
25889: PUSH
25890: LD_INT 1000
25892: LESS
25893: IFFALSE 25907
// SetLives ( Powell , 1000 ) ;
25895: LD_EXP 60
25899: PPUSH
25900: LD_INT 1000
25902: PPUSH
25903: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25907: LD_EXP 60
25911: PPUSH
25912: LD_EXP 66
25916: PPUSH
25917: CALL_OW 296
25921: PUSH
25922: LD_INT 5
25924: LESS
25925: PUSH
25926: LD_EXP 60
25930: PPUSH
25931: CALL_OW 310
25935: PPUSH
25936: LD_EXP 66
25940: PPUSH
25941: CALL_OW 296
25945: PUSH
25946: LD_INT 5
25948: LESS
25949: OR
25950: IFFALSE 25969
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25952: LD_EXP 60
25956: PPUSH
25957: CALL_OW 310
25961: PPUSH
25962: LD_INT 100
25964: PPUSH
25965: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25969: LD_EXP 60
25973: PPUSH
25974: CALL_OW 310
25978: NOT
25979: IFFALSE 25836
// DoNotAttack ( 8 , powellBomb ) ;
25981: LD_INT 8
25983: PPUSH
25984: LD_EXP 66
25988: PPUSH
25989: CALL_OW 471
// game_speed := 4 ;
25993: LD_ADDR_OWVAR 65
25997: PUSH
25998: LD_INT 4
26000: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26001: LD_EXP 60
26005: PPUSH
26006: LD_STRING D6b-Pow-1a
26008: PPUSH
26009: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26013: LD_EXP 60
26017: PPUSH
26018: LD_EXP 66
26022: PPUSH
26023: CALL_OW 180
// sync ;
26027: SYNC
// repeat wait ( 0 0$1 ) ;
26028: LD_INT 35
26030: PPUSH
26031: CALL_OW 67
// until IsInUnit ( Powell ) ;
26035: LD_EXP 60
26039: PPUSH
26040: CALL_OW 310
26044: IFFALSE 26028
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26046: LD_INT 8
26048: PPUSH
26049: LD_EXP 60
26053: PPUSH
26054: CALL_OW 310
26058: PPUSH
26059: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26063: LD_EXP 60
26067: PPUSH
26068: LD_INT 91
26070: PPUSH
26071: LD_INT 44
26073: PPUSH
26074: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26078: LD_EXP 60
26082: PPUSH
26083: LD_INT 96
26085: PPUSH
26086: LD_INT 44
26088: PPUSH
26089: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26093: LD_EXP 60
26097: PPUSH
26098: LD_INT 96
26100: PPUSH
26101: LD_INT 41
26103: PPUSH
26104: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26108: LD_EXP 60
26112: PPUSH
26113: LD_INT 92
26115: PPUSH
26116: LD_INT 39
26118: PPUSH
26119: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26123: LD_EXP 60
26127: PPUSH
26128: LD_INT 88
26130: PPUSH
26131: LD_INT 41
26133: PPUSH
26134: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26138: LD_EXP 60
26142: PPUSH
26143: LD_INT 91
26145: PPUSH
26146: LD_INT 44
26148: PPUSH
26149: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26153: LD_EXP 60
26157: PPUSH
26158: LD_INT 96
26160: PPUSH
26161: LD_INT 44
26163: PPUSH
26164: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26168: LD_EXP 60
26172: PPUSH
26173: LD_INT 96
26175: PPUSH
26176: LD_INT 41
26178: PPUSH
26179: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26183: LD_EXP 60
26187: PPUSH
26188: LD_INT 92
26190: PPUSH
26191: LD_INT 39
26193: PPUSH
26194: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26198: LD_EXP 60
26202: PPUSH
26203: LD_INT 88
26205: PPUSH
26206: LD_INT 41
26208: PPUSH
26209: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26213: LD_EXP 60
26217: PPUSH
26218: LD_INT 91
26220: PPUSH
26221: LD_INT 44
26223: PPUSH
26224: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26228: LD_EXP 60
26232: PPUSH
26233: LD_INT 93
26235: PPUSH
26236: LD_INT 39
26238: PPUSH
26239: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26243: LD_EXP 60
26247: PPUSH
26248: LD_INT 93
26250: PPUSH
26251: LD_INT 36
26253: PPUSH
26254: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26258: LD_INT 122
26260: PPUSH
26261: CALL_OW 67
// game_speed := 4 ;
26265: LD_ADDR_OWVAR 65
26269: PUSH
26270: LD_INT 4
26272: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26273: LD_EXP 60
26277: PPUSH
26278: LD_STRING D6b-Pow-1b
26280: PPUSH
26281: CALL_OW 88
// tmp := [ ] ;
26285: LD_ADDR_VAR 0 3
26289: PUSH
26290: EMPTY
26291: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26292: LD_ADDR_VAR 0 5
26296: PUSH
26297: LD_INT 78
26299: PUSH
26300: LD_INT 47
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: LD_INT 106
26309: PUSH
26310: LD_INT 53
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26321: LD_ADDR_VAR 0 1
26325: PUSH
26326: LD_INT 22
26328: PUSH
26329: LD_INT 8
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 21
26338: PUSH
26339: LD_INT 3
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: LD_INT 92
26348: PUSH
26349: LD_INT 90
26351: PUSH
26352: LD_INT 52
26354: PUSH
26355: LD_INT 12
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: LIST
26368: PPUSH
26369: CALL_OW 69
26373: PUSH
26374: FOR_IN
26375: IFFALSE 26400
// tmp := tmp ^ UnitsInside ( i ) ;
26377: LD_ADDR_VAR 0 3
26381: PUSH
26382: LD_VAR 0 3
26386: PUSH
26387: LD_VAR 0 1
26391: PPUSH
26392: CALL_OW 313
26396: ADD
26397: ST_TO_ADDR
26398: GO 26374
26400: POP
26401: POP
// for i in tmp do
26402: LD_ADDR_VAR 0 1
26406: PUSH
26407: LD_VAR 0 3
26411: PUSH
26412: FOR_IN
26413: IFFALSE 26575
// begin dist := 9999 ;
26415: LD_ADDR_VAR 0 8
26419: PUSH
26420: LD_INT 9999
26422: ST_TO_ADDR
// _xy := [ ] ;
26423: LD_ADDR_VAR 0 7
26427: PUSH
26428: EMPTY
26429: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26430: LD_VAR 0 1
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: CALL_OW 109
// ComExitBuilding ( i ) ;
26442: LD_VAR 0 1
26446: PPUSH
26447: CALL_OW 122
// for j in xy do
26451: LD_ADDR_VAR 0 2
26455: PUSH
26456: LD_VAR 0 5
26460: PUSH
26461: FOR_IN
26462: IFFALSE 26544
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26464: LD_VAR 0 1
26468: PPUSH
26469: LD_VAR 0 2
26473: PUSH
26474: LD_INT 1
26476: ARRAY
26477: PPUSH
26478: LD_VAR 0 2
26482: PUSH
26483: LD_INT 2
26485: ARRAY
26486: PPUSH
26487: CALL_OW 297
26491: PUSH
26492: LD_VAR 0 8
26496: LESS
26497: IFFALSE 26542
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26499: LD_ADDR_VAR 0 8
26503: PUSH
26504: LD_VAR 0 1
26508: PPUSH
26509: LD_VAR 0 2
26513: PUSH
26514: LD_INT 1
26516: ARRAY
26517: PPUSH
26518: LD_VAR 0 2
26522: PUSH
26523: LD_INT 2
26525: ARRAY
26526: PPUSH
26527: CALL_OW 297
26531: ST_TO_ADDR
// _xy := j ;
26532: LD_ADDR_VAR 0 7
26536: PUSH
26537: LD_VAR 0 2
26541: ST_TO_ADDR
// end ;
26542: GO 26461
26544: POP
26545: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26546: LD_VAR 0 1
26550: PPUSH
26551: LD_VAR 0 7
26555: PUSH
26556: LD_INT 1
26558: ARRAY
26559: PPUSH
26560: LD_VAR 0 7
26564: PUSH
26565: LD_INT 2
26567: ARRAY
26568: PPUSH
26569: CALL_OW 171
// end ;
26573: GO 26412
26575: POP
26576: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26577: LD_ADDR_VAR 0 4
26581: PUSH
26582: LD_VAR 0 3
26586: PPUSH
26587: LD_INT 26
26589: PUSH
26590: LD_INT 1
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PUSH
26597: LD_INT 25
26599: PUSH
26600: LD_INT 1
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PPUSH
26611: CALL_OW 72
26615: ST_TO_ADDR
// if tmp2 < 2 then
26616: LD_VAR 0 4
26620: PUSH
26621: LD_INT 2
26623: LESS
26624: IFFALSE 26693
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: LD_INT 22
26633: PUSH
26634: LD_INT 8
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 26
26643: PUSH
26644: LD_INT 1
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 3
26653: PUSH
26654: LD_INT 25
26656: PUSH
26657: LD_INT 15
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: EMPTY
26669: LIST
26670: LIST
26671: LIST
26672: PPUSH
26673: CALL_OW 69
26677: PUSH
26678: LD_EXP 63
26682: PUSH
26683: LD_EXP 64
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: DIFF
26692: ST_TO_ADDR
// if tmp2 then
26693: LD_VAR 0 4
26697: IFFALSE 26715
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26699: LD_VAR 0 4
26703: PUSH
26704: LD_INT 1
26706: ARRAY
26707: PPUSH
26708: LD_STRING D6b-ArSol1-1
26710: PPUSH
26711: CALL_OW 88
// async ;
26715: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26716: LD_EXP 60
26720: PPUSH
26721: LD_STRING D6b-Pow-2
26723: PPUSH
26724: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26728: LD_INT 18
26730: PPUSH
26731: CALL_OW 67
// if tmp2 > 1 then
26735: LD_VAR 0 4
26739: PUSH
26740: LD_INT 1
26742: GREATER
26743: IFFALSE 26761
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26745: LD_VAR 0 4
26749: PUSH
26750: LD_INT 2
26752: ARRAY
26753: PPUSH
26754: LD_STRING D6b-ArSol2-1
26756: PPUSH
26757: CALL_OW 88
// sync ;
26761: SYNC
// repeat wait ( 5 ) ;
26762: LD_INT 5
26764: PPUSH
26765: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26769: LD_INT 93
26771: PPUSH
26772: LD_INT 36
26774: PPUSH
26775: CALL_OW 428
26779: PPUSH
26780: CALL_OW 255
26784: PUSH
26785: LD_INT 4
26787: EQUAL
26788: IFFALSE 26762
// DialogueOn ;
26790: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26794: LD_INT 10
26796: PPUSH
26797: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26801: LD_EXP 60
26805: PPUSH
26806: LD_STRING D6b-Pow-2a
26808: PPUSH
26809: CALL_OW 88
// DialogueOff ;
26813: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26817: LD_EXP 60
26821: PPUSH
26822: CALL_OW 310
26826: PPUSH
26827: LD_INT 332
26829: PPUSH
26830: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26834: LD_INT 93
26836: PPUSH
26837: LD_INT 35
26839: PPUSH
26840: LD_INT 1
26842: PPUSH
26843: LD_INT 6
26845: NEG
26846: PPUSH
26847: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26851: LD_INT 35
26853: PPUSH
26854: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26858: LD_INT 332
26860: PPUSH
26861: CALL_OW 256
26865: PUSH
26866: LD_INT 1000
26868: LESS
26869: PUSH
26870: LD_INT 332
26872: PPUSH
26873: CALL_OW 300
26877: AND
26878: IFFALSE 26890
// SetLives ( kozlov_fac , 0 ) ;
26880: LD_INT 332
26882: PPUSH
26883: LD_INT 0
26885: PPUSH
26886: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26890: LD_INT 332
26892: PPUSH
26893: CALL_OW 301
26897: PUSH
26898: LD_EXP 60
26902: PPUSH
26903: CALL_OW 301
26907: OR
26908: IFFALSE 26851
// game_speed := 4 ;
26910: LD_ADDR_OWVAR 65
26914: PUSH
26915: LD_INT 4
26917: ST_TO_ADDR
// powellCenterCameraMode := false ;
26918: LD_ADDR_EXP 20
26922: PUSH
26923: LD_INT 0
26925: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26926: LD_ADDR_VAR 0 1
26930: PUSH
26931: LD_VAR 0 3
26935: PUSH
26936: LD_INT 22
26938: PUSH
26939: LD_INT 8
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 25
26948: PUSH
26949: LD_INT 2
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PPUSH
26960: CALL_OW 69
26964: UNION
26965: PUSH
26966: FOR_IN
26967: IFFALSE 26983
// SetTag ( i , 0 ) ;
26969: LD_VAR 0 1
26973: PPUSH
26974: LD_INT 0
26976: PPUSH
26977: CALL_OW 109
26981: GO 26966
26983: POP
26984: POP
// wait ( 0 0$3 ) ;
26985: LD_INT 105
26987: PPUSH
26988: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26992: LD_INT 93
26994: PPUSH
26995: LD_INT 35
26997: PPUSH
26998: LD_INT 1
27000: PPUSH
27001: CALL_OW 331
// DialogueOn ;
27005: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27009: LD_VAR 0 11
27013: PPUSH
27014: LD_STRING D6c-Sol3-1
27016: PPUSH
27017: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27021: LD_INT 10
27023: PPUSH
27024: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27028: LD_EXP 40
27032: PPUSH
27033: LD_STRING D6c-JMM-1
27035: PPUSH
27036: CALL_OW 88
// if Cyrus then
27040: LD_EXP 46
27044: IFFALSE 27058
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27046: LD_EXP 46
27050: PPUSH
27051: LD_STRING D6c-Cyrus-1
27053: PPUSH
27054: CALL_OW 88
// if Bobby then
27058: LD_EXP 45
27062: IFFALSE 27076
// Say ( Bobby , D6c-Bobby-1 ) ;
27064: LD_EXP 45
27068: PPUSH
27069: LD_STRING D6c-Bobby-1
27071: PPUSH
27072: CALL_OW 88
// if Cornel then
27076: LD_EXP 51
27080: IFFALSE 27094
// Say ( Cornel , D6c-Corn-1 ) ;
27082: LD_EXP 51
27086: PPUSH
27087: LD_STRING D6c-Corn-1
27089: PPUSH
27090: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27094: LD_ADDR_VAR 0 4
27098: PUSH
27099: LD_INT 2
27101: PUSH
27102: LD_INT 22
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 22
27114: PUSH
27115: LD_INT 4
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 26
27129: PUSH
27130: LD_INT 1
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: LD_INT 23
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: LIST
27151: PPUSH
27152: CALL_OW 69
27156: PUSH
27157: LD_VAR 0 11
27161: PUSH
27162: LD_EXP 40
27166: UNION
27167: PUSH
27168: LD_EXP 61
27172: UNION
27173: DIFF
27174: ST_TO_ADDR
// if tmp2 then
27175: LD_VAR 0 4
27179: IFFALSE 27197
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27181: LD_VAR 0 4
27185: PUSH
27186: LD_INT 1
27188: ARRAY
27189: PPUSH
27190: LD_STRING D6c-Sol1-1
27192: PPUSH
27193: CALL_OW 88
// if Lisa then
27197: LD_EXP 43
27201: IFFALSE 27215
// Say ( Lisa , D6c-Lisa-1 ) ;
27203: LD_EXP 43
27207: PPUSH
27208: LD_STRING D6c-Lisa-1
27210: PPUSH
27211: CALL_OW 88
// if Gary then
27215: LD_EXP 52
27219: IFFALSE 27233
// Say ( Gary , D6c-Gary-1 ) ;
27221: LD_EXP 52
27225: PPUSH
27226: LD_STRING D6c-Gary-1
27228: PPUSH
27229: CALL_OW 88
// if Donaldson then
27233: LD_EXP 44
27237: IFFALSE 27251
// Say ( Donaldson , D6c-Don-1 ) ;
27239: LD_EXP 44
27243: PPUSH
27244: LD_STRING D6c-Don-1
27246: PPUSH
27247: CALL_OW 88
// if tmp2 > 1 then
27251: LD_VAR 0 4
27255: PUSH
27256: LD_INT 1
27258: GREATER
27259: IFFALSE 27277
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27261: LD_VAR 0 4
27265: PUSH
27266: LD_INT 2
27268: ARRAY
27269: PPUSH
27270: LD_STRING D6c-Sol2-1
27272: PPUSH
27273: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27277: LD_VAR 0 11
27281: PPUSH
27282: LD_STRING D6c-Sol3-2
27284: PPUSH
27285: CALL_OW 88
// if IsInUnit ( JMM ) then
27289: LD_EXP 40
27293: PPUSH
27294: CALL_OW 310
27298: IFFALSE 27316
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27300: LD_EXP 40
27304: PPUSH
27305: CALL_OW 310
27309: PPUSH
27310: CALL_OW 87
27314: GO 27325
// CenterNowOnUnits ( JMM ) ;
27316: LD_EXP 40
27320: PPUSH
27321: CALL_OW 87
// dwait ( 0 0$2 ) ;
27325: LD_INT 70
27327: PPUSH
27328: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27332: LD_EXP 40
27336: PPUSH
27337: LD_STRING D6c-JMM-2
27339: PPUSH
27340: CALL_OW 88
// DialogueOff ;
27344: CALL_OW 7
// Video ( false ) ;
27348: LD_INT 0
27350: PPUSH
27351: CALL 107116 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27355: LD_INT 22
27357: PUSH
27358: LD_INT 4
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: PPUSH
27365: CALL_OW 69
27369: PPUSH
27370: LD_INT 1
27372: PPUSH
27373: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27377: LD_INT 4
27379: PPUSH
27380: LD_INT 4
27382: PPUSH
27383: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27387: LD_ADDR_VAR 0 1
27391: PUSH
27392: LD_INT 4
27394: PPUSH
27395: LD_INT 1
27397: PPUSH
27398: LD_INT 2
27400: PPUSH
27401: CALL 69505 0 3
27405: PUSH
27406: FOR_IN
27407: IFFALSE 27444
// if GetTech ( i , 1 ) <> state_researched then
27409: LD_VAR 0 1
27413: PPUSH
27414: LD_INT 1
27416: PPUSH
27417: CALL_OW 321
27421: PUSH
27422: LD_INT 2
27424: NONEQUAL
27425: IFFALSE 27442
// SetTech ( i , 1 , state_researched ) ;
27427: LD_VAR 0 1
27431: PPUSH
27432: LD_INT 1
27434: PPUSH
27435: LD_INT 2
27437: PPUSH
27438: CALL_OW 322
27442: GO 27406
27444: POP
27445: POP
// missionStage := 6 ;
27446: LD_ADDR_EXP 15
27450: PUSH
27451: LD_INT 6
27453: ST_TO_ADDR
// activeAttacks := true ;
27454: LD_ADDR_EXP 16
27458: PUSH
27459: LD_INT 1
27461: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27462: LD_STRING M2
27464: PPUSH
27465: CALL_OW 337
// SaveForQuickRestart ;
27469: CALL_OW 22
// wait ( 0 0$40 ) ;
27473: LD_INT 1400
27475: PPUSH
27476: CALL_OW 67
// DialogueOn ;
27480: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27484: LD_EXP 65
27488: PPUSH
27489: LD_STRING D7-Friend-1
27491: PPUSH
27492: CALL 111063 0 2
// Say ( JMM , D7-JMM-1 ) ;
27496: LD_EXP 40
27500: PPUSH
27501: LD_STRING D7-JMM-1
27503: PPUSH
27504: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27508: LD_EXP 65
27512: PPUSH
27513: LD_STRING D7-Friend-2
27515: PPUSH
27516: CALL 111063 0 2
// Say ( JMM , D7-JMM-2 ) ;
27520: LD_EXP 40
27524: PPUSH
27525: LD_STRING D7-JMM-2
27527: PPUSH
27528: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27532: LD_EXP 65
27536: PPUSH
27537: LD_STRING D7-Friend-3
27539: PPUSH
27540: CALL 111063 0 2
// Say ( JMM , D7-JMM-3 ) ;
27544: LD_EXP 40
27548: PPUSH
27549: LD_STRING D7-JMM-3
27551: PPUSH
27552: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27556: LD_EXP 65
27560: PPUSH
27561: LD_STRING D7-Friend-4
27563: PPUSH
27564: CALL 111063 0 2
// Say ( JMM , D7-JMM-4 ) ;
27568: LD_EXP 40
27572: PPUSH
27573: LD_STRING D7-JMM-4
27575: PPUSH
27576: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27580: LD_EXP 65
27584: PPUSH
27585: LD_STRING D7-Friend-5
27587: PPUSH
27588: CALL 111063 0 2
// Say ( JMM , D7-JMM-5 ) ;
27592: LD_EXP 40
27596: PPUSH
27597: LD_STRING D7-JMM-5
27599: PPUSH
27600: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27604: LD_EXP 65
27608: PPUSH
27609: LD_STRING D7-Friend-6
27611: PPUSH
27612: CALL 111063 0 2
// Say ( JMM , D7-JMM-6 ) ;
27616: LD_EXP 40
27620: PPUSH
27621: LD_STRING D7-JMM-6
27623: PPUSH
27624: CALL_OW 88
// DialogueOff ;
27628: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27632: LD_STRING Mlegion
27634: PPUSH
27635: CALL_OW 337
// skirmish := true ;
27639: LD_ADDR_EXP 99
27643: PUSH
27644: LD_INT 1
27646: ST_TO_ADDR
// RebuildKozlovFactory ;
27647: CALL 5172 0 0
// end ;
27651: PPOPN 13
27653: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27654: LD_EXP 20
27658: PUSH
27659: LD_EXP 60
27663: PPUSH
27664: CALL_OW 300
27668: AND
27669: IFFALSE 27711
27671: GO 27673
27673: DISABLE
// begin enable ;
27674: ENABLE
// if IsInUnit ( Powell ) then
27675: LD_EXP 60
27679: PPUSH
27680: CALL_OW 310
27684: IFFALSE 27702
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27686: LD_EXP 60
27690: PPUSH
27691: CALL_OW 310
27695: PPUSH
27696: CALL_OW 85
27700: GO 27711
// CenterOnUnits ( Powell ) ;
27702: LD_EXP 60
27706: PPUSH
27707: CALL_OW 85
// end ;
27711: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27712: LD_INT 22
27714: PUSH
27715: LD_INT 8
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 34
27724: PUSH
27725: LD_INT 48
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PPUSH
27736: CALL_OW 69
27740: IFFALSE 28014
27742: GO 27744
27744: DISABLE
27745: LD_INT 0
27747: PPUSH
27748: PPUSH
// begin if missionStage < 9 then
27749: LD_EXP 15
27753: PUSH
27754: LD_INT 9
27756: LESS
27757: IFFALSE 27767
// missionStage := 9 ;
27759: LD_ADDR_EXP 15
27763: PUSH
27764: LD_INT 9
27766: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27767: LD_ADDR_VAR 0 1
27771: PUSH
27772: LD_INT 22
27774: PUSH
27775: LD_INT 8
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 34
27784: PUSH
27785: LD_INT 48
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PPUSH
27796: CALL_OW 69
27800: PUSH
27801: LD_INT 1
27803: ARRAY
27804: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27805: LD_INT 175
27807: PPUSH
27808: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27812: LD_EXP 12
27816: PUSH
27817: LD_EXP 3
27821: PUSH
27822: LD_INT 0
27824: PUSH
27825: LD_INT 2
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: IN
27832: OR
27833: IFFALSE 27856
// target := [ 68 , 108 , 1 ] else
27835: LD_ADDR_VAR 0 2
27839: PUSH
27840: LD_INT 68
27842: PUSH
27843: LD_INT 108
27845: PUSH
27846: LD_INT 1
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: LIST
27853: ST_TO_ADDR
27854: GO 27875
// target := [ 181 , 88 , 2 ] ;
27856: LD_ADDR_VAR 0 2
27860: PUSH
27861: LD_INT 181
27863: PUSH
27864: LD_INT 88
27866: PUSH
27867: LD_INT 2
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: LIST
27874: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27875: LD_VAR 0 1
27879: PPUSH
27880: LD_VAR 0 2
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: PPUSH
27889: LD_VAR 0 2
27893: PUSH
27894: LD_INT 2
27896: ARRAY
27897: PPUSH
27898: CALL_OW 176
// if target [ 3 ] = 1 then
27902: LD_VAR 0 2
27906: PUSH
27907: LD_INT 3
27909: ARRAY
27910: PUSH
27911: LD_INT 1
27913: EQUAL
27914: IFFALSE 27930
// SayRadio ( Kurt , D12-Kurt-1 ) else
27916: LD_EXP 63
27920: PPUSH
27921: LD_STRING D12-Kurt-1
27923: PPUSH
27924: CALL_OW 94
27928: GO 27954
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27930: LD_EXP 63
27934: PPUSH
27935: LD_STRING D12a-Kurt-1
27937: PPUSH
27938: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27942: LD_EXP 78
27946: PPUSH
27947: LD_STRING D12a-Roth-1
27949: PPUSH
27950: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27954: LD_INT 350
27956: PPUSH
27957: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27961: LD_VAR 0 1
27965: PPUSH
27966: LD_INT 22
27968: PUSH
27969: LD_INT 8
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 23
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 30
27988: PUSH
27989: LD_INT 3
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: LIST
28000: PPUSH
28001: CALL_OW 69
28005: PUSH
28006: LD_INT 1
28008: ARRAY
28009: PPUSH
28010: CALL_OW 228
// end ;
28014: PPOPN 2
28016: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28017: LD_EXP 63
28021: PPUSH
28022: CALL_OW 256
28026: PUSH
28027: LD_INT 999
28029: LESS
28030: PUSH
28031: LD_INT 22
28033: PUSH
28034: LD_INT 8
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 21
28043: PUSH
28044: LD_INT 1
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 23
28053: PUSH
28054: LD_INT 2
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: PPUSH
28066: CALL_OW 69
28070: PUSH
28071: LD_INT 9
28073: PUSH
28074: LD_INT 8
28076: PUSH
28077: LD_INT 7
28079: PUSH
28080: LD_INT 6
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: LIST
28087: LIST
28088: PUSH
28089: LD_OWVAR 67
28093: ARRAY
28094: LESSEQUAL
28095: OR
28096: PUSH
28097: LD_INT 22
28099: PUSH
28100: LD_INT 8
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 34
28109: PUSH
28110: LD_INT 48
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PPUSH
28121: CALL_OW 69
28125: NOT
28126: AND
28127: PUSH
28128: LD_EXP 63
28132: PPUSH
28133: CALL_OW 302
28137: AND
28138: PUSH
28139: LD_INT 5
28141: PPUSH
28142: LD_INT 22
28144: PUSH
28145: LD_INT 1
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PPUSH
28152: CALL_OW 70
28156: AND
28157: IFFALSE 28919
28159: GO 28161
28161: DISABLE
28162: LD_INT 0
28164: PPUSH
28165: PPUSH
28166: PPUSH
// begin legionDestroyed := true ;
28167: LD_ADDR_EXP 22
28171: PUSH
28172: LD_INT 1
28174: ST_TO_ADDR
// DialogueOn ;
28175: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28179: LD_EXP 40
28183: PPUSH
28184: LD_STRING D13-JMM-1
28186: PPUSH
28187: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28191: LD_EXP 63
28195: PPUSH
28196: LD_STRING D13-Kurt-1
28198: PPUSH
28199: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28203: LD_EXP 40
28207: PPUSH
28208: LD_STRING D13-JMM-2
28210: PPUSH
28211: CALL_OW 88
// if FakeInfo then
28215: LD_EXP 12
28219: IFFALSE 28239
// begin Say ( Kurt , D13-Kurt-2 ) ;
28221: LD_EXP 63
28225: PPUSH
28226: LD_STRING D13-Kurt-2
28228: PPUSH
28229: CALL_OW 88
// DialogueOff ;
28233: CALL_OW 7
// exit ;
28237: GO 28919
// end ; if not KurtStatus then
28239: LD_EXP 3
28243: NOT
28244: IFFALSE 28260
// Say ( Kurt , D13-Kurt-2b ) else
28246: LD_EXP 63
28250: PPUSH
28251: LD_STRING D13-Kurt-2b
28253: PPUSH
28254: CALL_OW 88
28258: GO 28272
// Say ( Kurt , D13-Kurt-2a ) ;
28260: LD_EXP 63
28264: PPUSH
28265: LD_STRING D13-Kurt-2a
28267: PPUSH
28268: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28272: LD_EXP 40
28276: PPUSH
28277: LD_STRING D13-JMM-3
28279: PPUSH
28280: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28284: LD_EXP 63
28288: PPUSH
28289: LD_STRING D13-Kurt-3
28291: PPUSH
28292: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28296: LD_EXP 40
28300: PPUSH
28301: LD_STRING D13-JMM-4
28303: PPUSH
28304: CALL_OW 88
// DialogueOff ;
28308: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28312: LD_STRING MlegionOut
28314: PPUSH
28315: CALL_OW 337
// MC_Kill ( 3 ) ;
28319: LD_INT 3
28321: PPUSH
28322: CALL 38991 0 1
// KillUnit ( Kozlov ) ;
28326: LD_EXP 64
28330: PPUSH
28331: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28335: LD_ADDR_VAR 0 1
28339: PUSH
28340: LD_INT 22
28342: PUSH
28343: LD_INT 8
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 23
28352: PUSH
28353: LD_INT 3
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 3
28362: PUSH
28363: LD_INT 21
28365: PUSH
28366: LD_INT 33
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: LIST
28381: PPUSH
28382: CALL_OW 69
28386: PUSH
28387: FOR_IN
28388: IFFALSE 28401
// KillUnit ( i ) ;
28390: LD_VAR 0 1
28394: PPUSH
28395: CALL_OW 66
28399: GO 28387
28401: POP
28402: POP
// ChangeSideFog ( 8 , 1 ) ;
28403: LD_INT 8
28405: PPUSH
28406: LD_INT 1
28408: PPUSH
28409: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28413: LD_ADDR_VAR 0 2
28417: PUSH
28418: LD_INT 22
28420: PUSH
28421: LD_INT 8
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 21
28430: PUSH
28431: LD_INT 1
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PPUSH
28442: CALL_OW 69
28446: PUSH
28447: LD_EXP 64
28451: PUSH
28452: LD_EXP 63
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: DIFF
28461: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28462: LD_VAR 0 2
28466: PUSH
28467: LD_INT 6
28469: PUSH
28470: LD_INT 5
28472: PUSH
28473: LD_INT 4
28475: PUSH
28476: LD_INT 3
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: PUSH
28485: LD_OWVAR 67
28489: ARRAY
28490: GREATEREQUAL
28491: IFFALSE 28643
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28493: LD_ADDR_VAR 0 3
28497: PUSH
28498: LD_INT 6
28500: PUSH
28501: LD_INT 5
28503: PUSH
28504: LD_INT 4
28506: PUSH
28507: LD_INT 3
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: LIST
28514: LIST
28515: PUSH
28516: LD_OWVAR 67
28520: ARRAY
28521: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28522: LD_ADDR_VAR 0 1
28526: PUSH
28527: DOUBLE
28528: LD_VAR 0 2
28532: PUSH
28533: LD_VAR 0 3
28537: PUSH
28538: LD_INT 1
28540: PLUS
28541: MINUS
28542: INC
28543: ST_TO_ADDR
28544: LD_INT 1
28546: PUSH
28547: FOR_DOWNTO
28548: IFFALSE 28639
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28550: LD_ADDR_EXP 38
28554: PUSH
28555: LD_EXP 38
28559: PUSH
28560: LD_VAR 0 2
28564: PUSH
28565: LD_VAR 0 1
28569: ARRAY
28570: ADD
28571: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28572: LD_VAR 0 2
28576: PUSH
28577: LD_VAR 0 1
28581: ARRAY
28582: PPUSH
28583: CALL_OW 310
28587: IFFALSE 28604
// ComExit ( tmp [ i ] ) ;
28589: LD_VAR 0 2
28593: PUSH
28594: LD_VAR 0 1
28598: ARRAY
28599: PPUSH
28600: CALL 107542 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28604: LD_VAR 0 2
28608: PUSH
28609: LD_VAR 0 1
28613: ARRAY
28614: PPUSH
28615: LD_INT 34
28617: PUSH
28618: LD_INT 0
28620: PPUSH
28621: LD_INT 6
28623: PPUSH
28624: CALL_OW 12
28628: PLUS
28629: PPUSH
28630: LD_INT 1
28632: PPUSH
28633: CALL_OW 171
// end ;
28637: GO 28547
28639: POP
28640: POP
// end else
28641: GO 28653
// x := tmp ;
28643: LD_ADDR_VAR 0 3
28647: PUSH
28648: LD_VAR 0 2
28652: ST_TO_ADDR
// for i := tmp downto tmp - x do
28653: LD_ADDR_VAR 0 1
28657: PUSH
28658: DOUBLE
28659: LD_VAR 0 2
28663: INC
28664: ST_TO_ADDR
28665: LD_VAR 0 2
28669: PUSH
28670: LD_VAR 0 3
28674: MINUS
28675: PUSH
28676: FOR_DOWNTO
28677: IFFALSE 28749
// begin if IsInUnit ( tmp [ i ] ) then
28679: LD_VAR 0 2
28683: PUSH
28684: LD_VAR 0 1
28688: ARRAY
28689: PPUSH
28690: CALL_OW 310
28694: IFFALSE 28711
// ComExit ( tmp [ i ] ) ;
28696: LD_VAR 0 2
28700: PUSH
28701: LD_VAR 0 1
28705: ARRAY
28706: PPUSH
28707: CALL 107542 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28711: LD_VAR 0 2
28715: PUSH
28716: LD_VAR 0 1
28720: ARRAY
28721: PPUSH
28722: LD_INT 1
28724: PPUSH
28725: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28729: LD_VAR 0 2
28733: PUSH
28734: LD_VAR 0 1
28738: ARRAY
28739: PPUSH
28740: LD_INT 1000
28742: PPUSH
28743: CALL_OW 234
// end ;
28747: GO 28676
28749: POP
28750: POP
// wait ( 0 0$0.3 ) ;
28751: LD_INT 10
28753: PPUSH
28754: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28758: LD_ADDR_VAR 0 1
28762: PUSH
28763: LD_INT 22
28765: PUSH
28766: LD_INT 8
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 21
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PPUSH
28787: CALL_OW 69
28791: PUSH
28792: FOR_IN
28793: IFFALSE 28806
// KillUnit ( i ) ;
28795: LD_VAR 0 1
28799: PPUSH
28800: CALL_OW 66
28804: GO 28792
28806: POP
28807: POP
// SetSide ( Kurt , 1 ) ;
28808: LD_EXP 63
28812: PPUSH
28813: LD_INT 1
28815: PPUSH
28816: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28820: LD_INT 22
28822: PUSH
28823: LD_INT 8
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 21
28832: PUSH
28833: LD_INT 3
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PPUSH
28844: CALL_OW 69
28848: PPUSH
28849: LD_INT 1
28851: PPUSH
28852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28856: LD_INT 8
28858: PPUSH
28859: LD_INT 1
28861: PPUSH
28862: LD_INT 1
28864: PPUSH
28865: LD_INT 1
28867: PPUSH
28868: CALL_OW 80
// wait ( 1 1$20 ) ;
28872: LD_INT 2800
28874: PPUSH
28875: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28879: LD_EXP 65
28883: PPUSH
28884: LD_INT 37
28886: PPUSH
28887: LD_INT 1
28889: PPUSH
28890: LD_INT 0
28892: PPUSH
28893: CALL_OW 48
// wait ( 0 0$1 ) ;
28897: LD_INT 35
28899: PPUSH
28900: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28904: LD_EXP 65
28908: PPUSH
28909: LD_INT 60
28911: PPUSH
28912: LD_INT 95
28914: PPUSH
28915: CALL_OW 111
// end ;
28919: PPOPN 3
28921: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28922: LD_EXP 22
28926: NOT
28927: PUSH
28928: LD_INT 22
28930: PUSH
28931: LD_INT 8
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 21
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PPUSH
28952: CALL_OW 69
28956: PUSH
28957: LD_INT 0
28959: EQUAL
28960: AND
28961: IFFALSE 28981
28963: GO 28965
28965: DISABLE
// begin legionDestroyed := true ;
28966: LD_ADDR_EXP 22
28970: PUSH
28971: LD_INT 1
28973: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28974: LD_STRING MlegionOut
28976: PPUSH
28977: CALL_OW 337
// end ;
28981: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28982: LD_EXP 38
28986: IFFALSE 29061
28988: GO 28990
28990: DISABLE
28991: LD_INT 0
28993: PPUSH
// begin enable ;
28994: ENABLE
// for i in legionEscapeUnits do
28995: LD_ADDR_VAR 0 1
28999: PUSH
29000: LD_EXP 38
29004: PUSH
29005: FOR_IN
29006: IFFALSE 29059
// begin if IsInArea ( i , legionEscapeArea ) then
29008: LD_VAR 0 1
29012: PPUSH
29013: LD_INT 31
29015: PPUSH
29016: CALL_OW 308
29020: IFFALSE 29033
// RemoveUnit ( i ) else
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 64
29031: GO 29057
// if not HasTask ( i ) then
29033: LD_VAR 0 1
29037: PPUSH
29038: CALL_OW 314
29042: NOT
29043: IFFALSE 29057
// ComMoveToArea ( i , legionEscapeArea ) ;
29045: LD_VAR 0 1
29049: PPUSH
29050: LD_INT 31
29052: PPUSH
29053: CALL_OW 113
// end ;
29057: GO 29005
29059: POP
29060: POP
// end ;
29061: PPOPN 1
29063: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29064: LD_INT 1
29066: PPUSH
29067: LD_EXP 65
29071: PPUSH
29072: CALL_OW 292
29076: IFFALSE 29374
29078: GO 29080
29080: DISABLE
29081: LD_INT 0
29083: PPUSH
// begin wait ( 0 0$2 ) ;
29084: LD_INT 70
29086: PPUSH
29087: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29091: LD_EXP 65
29095: PPUSH
29096: CALL_OW 87
// DialogueOn ;
29100: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29104: LD_EXP 40
29108: PPUSH
29109: LD_STRING D14-JMM-1
29111: PPUSH
29112: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29116: LD_EXP 65
29120: PPUSH
29121: LD_STRING D14-Friend-1
29123: PPUSH
29124: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29128: LD_EXP 40
29132: PPUSH
29133: LD_STRING D14-JMM-2
29135: PPUSH
29136: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29140: LD_EXP 65
29144: PPUSH
29145: LD_STRING D14-Friend-2
29147: PPUSH
29148: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29152: LD_EXP 40
29156: PPUSH
29157: LD_STRING D14-JMM-3
29159: PPUSH
29160: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29164: LD_EXP 65
29168: PPUSH
29169: LD_STRING D14-Friend-3
29171: PPUSH
29172: CALL_OW 88
// DialogueOff ;
29176: CALL_OW 7
// dec := Query ( Q14 ) ;
29180: LD_ADDR_VAR 0 1
29184: PUSH
29185: LD_STRING Q14
29187: PPUSH
29188: CALL_OW 97
29192: ST_TO_ADDR
// if dec = 1 then
29193: LD_VAR 0 1
29197: PUSH
29198: LD_INT 1
29200: EQUAL
29201: IFFALSE 29235
// begin DialogueOn ;
29203: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29207: LD_EXP 40
29211: PPUSH
29212: LD_STRING D14a-JMM-1
29214: PPUSH
29215: CALL_OW 88
// DialogueOff ;
29219: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29223: LD_EXP 65
29227: PPUSH
29228: LD_INT 1
29230: PPUSH
29231: CALL_OW 235
// end ; if dec = 2 then
29235: LD_VAR 0 1
29239: PUSH
29240: LD_INT 2
29242: EQUAL
29243: IFFALSE 29296
// begin DialogueOn ;
29245: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29249: LD_EXP 40
29253: PPUSH
29254: LD_STRING D14b-JMM-1
29256: PPUSH
29257: CALL_OW 88
// DialogueOff ;
29261: CALL_OW 7
// wait ( 0 0$1 ) ;
29265: LD_INT 35
29267: PPUSH
29268: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29272: LD_EXP 65
29276: PPUSH
29277: LD_INT 9
29279: PPUSH
29280: LD_INT 2
29282: PPUSH
29283: CALL_OW 111
// AddComHold ( Friend ) ;
29287: LD_EXP 65
29291: PPUSH
29292: CALL_OW 200
// end ; if dec = 3 then
29296: LD_VAR 0 1
29300: PUSH
29301: LD_INT 3
29303: EQUAL
29304: IFFALSE 29374
// begin DialogueOn ;
29306: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29310: LD_EXP 40
29314: PPUSH
29315: LD_STRING D14c-JMM-1
29317: PPUSH
29318: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29322: LD_EXP 65
29326: PPUSH
29327: LD_STRING D14c-Friend-1
29329: PPUSH
29330: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29334: LD_EXP 40
29338: PPUSH
29339: LD_STRING D14c-JMM-2
29341: PPUSH
29342: CALL_OW 88
// DialogueOff ;
29346: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29350: LD_EXP 65
29354: PPUSH
29355: LD_INT 9
29357: PPUSH
29358: LD_INT 2
29360: PPUSH
29361: CALL_OW 111
// AddComHold ( Friend ) ;
29365: LD_EXP 65
29369: PPUSH
29370: CALL_OW 200
// end ; end ;
29374: PPOPN 1
29376: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29377: LD_INT 9
29379: PPUSH
29380: LD_INT 2
29382: PPUSH
29383: CALL_OW 428
29387: PUSH
29388: LD_EXP 65
29392: EQUAL
29393: PUSH
29394: LD_EXP 65
29398: PPUSH
29399: CALL_OW 255
29403: PUSH
29404: LD_INT 8
29406: EQUAL
29407: AND
29408: IFFALSE 29422
29410: GO 29412
29412: DISABLE
// RemoveUnit ( Friend ) ;
29413: LD_EXP 65
29417: PPUSH
29418: CALL_OW 64
29422: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29423: LD_EXP 14
29427: PUSH
29428: LD_INT 31500
29430: GREATEREQUAL
29431: PUSH
29432: LD_EXP 7
29436: AND
29437: PUSH
29438: LD_EXP 2
29442: AND
29443: IFFALSE 29889
29445: GO 29447
29447: DISABLE
29448: LD_INT 0
29450: PPUSH
29451: PPUSH
29452: PPUSH
// begin missionStage := 7 ;
29453: LD_ADDR_EXP 15
29457: PUSH
29458: LD_INT 7
29460: ST_TO_ADDR
// for i := 1 to 5 do
29461: LD_ADDR_VAR 0 1
29465: PUSH
29466: DOUBLE
29467: LD_INT 1
29469: DEC
29470: ST_TO_ADDR
29471: LD_INT 5
29473: PUSH
29474: FOR_TO
29475: IFFALSE 29587
// begin uc_side = 1 ;
29477: LD_ADDR_OWVAR 20
29481: PUSH
29482: LD_INT 1
29484: ST_TO_ADDR
// uc_nation = 1 ;
29485: LD_ADDR_OWVAR 21
29489: PUSH
29490: LD_INT 1
29492: ST_TO_ADDR
// vc_engine = 3 ;
29493: LD_ADDR_OWVAR 39
29497: PUSH
29498: LD_INT 3
29500: ST_TO_ADDR
// vc_control = 3 ;
29501: LD_ADDR_OWVAR 38
29505: PUSH
29506: LD_INT 3
29508: ST_TO_ADDR
// vc_chassis = 3 ;
29509: LD_ADDR_OWVAR 37
29513: PUSH
29514: LD_INT 3
29516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29517: LD_ADDR_OWVAR 40
29521: PUSH
29522: LD_INT 5
29524: PUSH
29525: LD_INT 9
29527: PUSH
29528: LD_INT 7
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: LIST
29535: PUSH
29536: LD_INT 1
29538: PPUSH
29539: LD_INT 3
29541: PPUSH
29542: CALL_OW 12
29546: ARRAY
29547: ST_TO_ADDR
// veh = CreateVehicle ;
29548: LD_ADDR_VAR 0 2
29552: PUSH
29553: CALL_OW 45
29557: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29558: LD_VAR 0 2
29562: PPUSH
29563: LD_INT 1
29565: PPUSH
29566: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29570: LD_VAR 0 2
29574: PPUSH
29575: LD_INT 19
29577: PPUSH
29578: LD_INT 0
29580: PPUSH
29581: CALL_OW 49
// end ;
29585: GO 29474
29587: POP
29588: POP
// uc_side = 1 ;
29589: LD_ADDR_OWVAR 20
29593: PUSH
29594: LD_INT 1
29596: ST_TO_ADDR
// uc_nation = 1 ;
29597: LD_ADDR_OWVAR 21
29601: PUSH
29602: LD_INT 1
29604: ST_TO_ADDR
// vc_engine = 3 ;
29605: LD_ADDR_OWVAR 39
29609: PUSH
29610: LD_INT 3
29612: ST_TO_ADDR
// vc_control = 1 ;
29613: LD_ADDR_OWVAR 38
29617: PUSH
29618: LD_INT 1
29620: ST_TO_ADDR
// vc_chassis = 3 ;
29621: LD_ADDR_OWVAR 37
29625: PUSH
29626: LD_INT 3
29628: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29629: LD_ADDR_OWVAR 40
29633: PUSH
29634: LD_INT 5
29636: PUSH
29637: LD_INT 9
29639: PUSH
29640: LD_INT 7
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 1
29650: PPUSH
29651: LD_INT 3
29653: PPUSH
29654: CALL_OW 12
29658: ARRAY
29659: ST_TO_ADDR
// vehG = CreateVehicle ;
29660: LD_ADDR_VAR 0 3
29664: PUSH
29665: CALL_OW 45
29669: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29670: LD_VAR 0 3
29674: PPUSH
29675: LD_INT 1
29677: PPUSH
29678: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29682: LD_VAR 0 3
29686: PPUSH
29687: LD_INT 19
29689: PPUSH
29690: LD_INT 0
29692: PPUSH
29693: CALL_OW 49
// if JMMGirl = 1 then
29697: LD_EXP 7
29701: PUSH
29702: LD_INT 1
29704: EQUAL
29705: IFFALSE 29761
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29707: LD_ADDR_EXP 41
29711: PUSH
29712: LD_STRING Joan
29714: PPUSH
29715: LD_INT 1
29717: PPUSH
29718: LD_STRING 14_
29720: PPUSH
29721: CALL 69442 0 3
29725: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29726: LD_EXP 41
29730: PPUSH
29731: LD_VAR 0 3
29735: PPUSH
29736: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29740: LD_VAR 0 3
29744: PPUSH
29745: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29749: LD_EXP 41
29753: PPUSH
29754: LD_STRING D10BW-Joan-1
29756: PPUSH
29757: CALL_OW 94
// end ; if JMMGirl = 2 then
29761: LD_EXP 7
29765: PUSH
29766: LD_INT 2
29768: EQUAL
29769: IFFALSE 29825
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29771: LD_ADDR_EXP 43
29775: PUSH
29776: LD_STRING Lisa
29778: PPUSH
29779: LD_INT 1
29781: PPUSH
29782: LD_STRING 14_
29784: PPUSH
29785: CALL 69442 0 3
29789: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29790: LD_EXP 43
29794: PPUSH
29795: LD_VAR 0 3
29799: PPUSH
29800: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29804: LD_VAR 0 3
29808: PPUSH
29809: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29813: LD_EXP 43
29817: PPUSH
29818: LD_STRING D10BW-Lisa-1
29820: PPUSH
29821: CALL_OW 94
// end ; if JMMGirl = 3 then
29825: LD_EXP 7
29829: PUSH
29830: LD_INT 3
29832: EQUAL
29833: IFFALSE 29889
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29835: LD_ADDR_EXP 55
29839: PUSH
29840: LD_STRING Connie
29842: PPUSH
29843: LD_INT 1
29845: PPUSH
29846: LD_STRING 14_
29848: PPUSH
29849: CALL 69442 0 3
29853: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29854: LD_EXP 55
29858: PPUSH
29859: LD_VAR 0 3
29863: PPUSH
29864: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29868: LD_VAR 0 3
29872: PPUSH
29873: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29877: LD_EXP 55
29881: PPUSH
29882: LD_STRING D10BW-Con-1
29884: PPUSH
29885: CALL_OW 94
// end ; end ;
29889: PPOPN 3
29891: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29892: LD_EXP 14
29896: PUSH
29897: LD_INT 94500
29899: GREATEREQUAL
29900: IFFALSE 30312
29902: GO 29904
29904: DISABLE
29905: LD_INT 0
29907: PPUSH
29908: PPUSH
29909: PPUSH
// begin tmp := PrepareStevensSquad ;
29910: LD_ADDR_VAR 0 3
29914: PUSH
29915: CALL 2323 0 0
29919: ST_TO_ADDR
// if not tmp then
29920: LD_VAR 0 3
29924: NOT
29925: IFFALSE 29929
// exit ;
29927: GO 30312
// uc_side := 1 ;
29929: LD_ADDR_OWVAR 20
29933: PUSH
29934: LD_INT 1
29936: ST_TO_ADDR
// uc_nation := 1 ;
29937: LD_ADDR_OWVAR 21
29941: PUSH
29942: LD_INT 1
29944: ST_TO_ADDR
// for i in tmp do
29945: LD_ADDR_VAR 0 1
29949: PUSH
29950: LD_VAR 0 3
29954: PUSH
29955: FOR_IN
29956: IFFALSE 30053
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29958: LD_INT 3
29960: PPUSH
29961: LD_INT 3
29963: PPUSH
29964: LD_INT 1
29966: PPUSH
29967: LD_INT 5
29969: PUSH
29970: LD_INT 9
29972: PUSH
29973: LD_INT 7
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 1
29983: PPUSH
29984: LD_INT 3
29986: PPUSH
29987: CALL_OW 12
29991: ARRAY
29992: PPUSH
29993: LD_INT 40
29995: PPUSH
29996: CALL 74282 0 5
// veh := CreateVehicle ;
30000: LD_ADDR_VAR 0 2
30004: PUSH
30005: CALL_OW 45
30009: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30010: LD_VAR 0 2
30014: PPUSH
30015: LD_INT 1
30017: PPUSH
30018: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30022: LD_VAR 0 2
30026: PPUSH
30027: LD_INT 19
30029: PPUSH
30030: LD_INT 0
30032: PPUSH
30033: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30037: LD_VAR 0 1
30041: PPUSH
30042: LD_VAR 0 2
30046: PPUSH
30047: CALL_OW 52
// end ;
30051: GO 29955
30053: POP
30054: POP
// missionStage := 8 ;
30055: LD_ADDR_EXP 15
30059: PUSH
30060: LD_INT 8
30062: ST_TO_ADDR
// DialogueOn ;
30063: CALL_OW 6
// if Stevens then
30067: LD_EXP 42
30071: IFFALSE 30185
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30073: LD_EXP 42
30077: PPUSH
30078: CALL_OW 310
30082: PPUSH
30083: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30087: LD_EXP 42
30091: PPUSH
30092: LD_STRING D8-Huck-1
30094: PPUSH
30095: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30099: LD_EXP 40
30103: PPUSH
30104: LD_STRING D8-JMM-1
30106: PPUSH
30107: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30111: LD_EXP 42
30115: PPUSH
30116: LD_STRING D8-Huck-2
30118: PPUSH
30119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30123: LD_EXP 40
30127: PPUSH
30128: LD_STRING D8-JMM-2
30130: PPUSH
30131: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30135: LD_EXP 42
30139: PPUSH
30140: LD_STRING D8-Huck-3
30142: PPUSH
30143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30147: LD_EXP 40
30151: PPUSH
30152: LD_STRING D8-JMM-3
30154: PPUSH
30155: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30159: LD_EXP 42
30163: PPUSH
30164: LD_STRING D8-Huck-4
30166: PPUSH
30167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30171: LD_EXP 40
30175: PPUSH
30176: LD_STRING D8-JMM-4
30178: PPUSH
30179: CALL_OW 88
// end else
30183: GO 30295
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30185: LD_EXP 56
30189: PPUSH
30190: CALL_OW 310
30194: PPUSH
30195: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30199: LD_EXP 56
30203: PPUSH
30204: LD_STRING D8-Huck-1
30206: PPUSH
30207: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30211: LD_EXP 40
30215: PPUSH
30216: LD_STRING D8-JMM-1a
30218: PPUSH
30219: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30223: LD_EXP 56
30227: PPUSH
30228: LD_STRING D8-Huck-2
30230: PPUSH
30231: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30235: LD_EXP 40
30239: PPUSH
30240: LD_STRING D8-JMM-2
30242: PPUSH
30243: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30247: LD_EXP 56
30251: PPUSH
30252: LD_STRING D8-Huck-3
30254: PPUSH
30255: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30259: LD_EXP 40
30263: PPUSH
30264: LD_STRING D8-JMM-3
30266: PPUSH
30267: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30271: LD_EXP 56
30275: PPUSH
30276: LD_STRING D8-Huck-4
30278: PPUSH
30279: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30283: LD_EXP 40
30287: PPUSH
30288: LD_STRING D8-JMM-4
30290: PPUSH
30291: CALL_OW 88
// end ; DialogueOff ;
30295: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30299: LD_INT 25
30301: PPUSH
30302: LD_INT 1
30304: PPUSH
30305: LD_INT 1
30307: PPUSH
30308: CALL_OW 322
// end ;
30312: PPOPN 3
30314: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30315: LD_EXP 74
30319: PPUSH
30320: CALL_OW 302
30324: PUSH
30325: LD_INT 1
30327: PPUSH
30328: LD_EXP 74
30332: PPUSH
30333: CALL_OW 292
30337: AND
30338: IFFALSE 30589
30340: GO 30342
30342: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30343: LD_EXP 74
30347: PPUSH
30348: CALL_OW 87
// DialogueOn ;
30352: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30356: LD_EXP 40
30360: PPUSH
30361: LD_STRING D10nB-JMM-1
30363: PPUSH
30364: CALL_OW 88
// if BurlakStatus = 1 then
30368: LD_EXP 9
30372: PUSH
30373: LD_INT 1
30375: EQUAL
30376: IFFALSE 30390
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30378: LD_EXP 73
30382: PPUSH
30383: LD_STRING D10nB-Vse-1a
30385: PPUSH
30386: CALL_OW 94
// end ; if BurlakStatus = 0 then
30390: LD_EXP 9
30394: PUSH
30395: LD_INT 0
30397: EQUAL
30398: IFFALSE 30412
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30400: LD_EXP 73
30404: PPUSH
30405: LD_STRING D10nB-Vse-1
30407: PPUSH
30408: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30412: LD_EXP 40
30416: PPUSH
30417: LD_STRING D10nB-JMM-2
30419: PPUSH
30420: CALL_OW 88
// if KappaStatus then
30424: LD_EXP 2
30428: IFFALSE 30442
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30430: LD_EXP 73
30434: PPUSH
30435: LD_STRING D10nB-Vse-5a
30437: PPUSH
30438: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30442: LD_EXP 2
30446: NOT
30447: PUSH
30448: LD_EXP 6
30452: PUSH
30453: LD_INT 0
30455: EQUAL
30456: AND
30457: IFFALSE 30585
// begin if JMMGirl = 1 then
30459: LD_EXP 7
30463: PUSH
30464: LD_INT 1
30466: EQUAL
30467: IFFALSE 30517
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30469: LD_EXP 73
30473: PPUSH
30474: LD_STRING D10nB-Vse-2
30476: PPUSH
30477: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30481: LD_EXP 40
30485: PPUSH
30486: LD_STRING D10nB-JMM-3
30488: PPUSH
30489: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30493: LD_EXP 73
30497: PPUSH
30498: LD_STRING D10nB-Vse-3
30500: PPUSH
30501: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30505: LD_EXP 40
30509: PPUSH
30510: LD_STRING D10nB-JMM-4
30512: PPUSH
30513: CALL_OW 88
// end ; if JMMGirl = 2 then
30517: LD_EXP 7
30521: PUSH
30522: LD_INT 2
30524: EQUAL
30525: IFFALSE 30551
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30527: LD_EXP 73
30531: PPUSH
30532: LD_STRING D10nB-Vse-4
30534: PPUSH
30535: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30539: LD_EXP 40
30543: PPUSH
30544: LD_STRING D10nB-JMM-5
30546: PPUSH
30547: CALL_OW 88
// end ; if JMMGirl = 3 then
30551: LD_EXP 7
30555: PUSH
30556: LD_INT 3
30558: EQUAL
30559: IFFALSE 30585
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30561: LD_EXP 73
30565: PPUSH
30566: LD_STRING D10nB-Vse-5
30568: PPUSH
30569: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30573: LD_EXP 40
30577: PPUSH
30578: LD_STRING D10nB-JMM-6
30580: PPUSH
30581: CALL_OW 88
// end ; end ; DialogueOff ;
30585: CALL_OW 7
// end ;
30589: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30590: LD_EXP 14
30594: PUSH
30595: LD_INT 115500
30597: GREATEREQUAL
30598: PUSH
30599: LD_EXP 68
30603: PPUSH
30604: CALL_OW 302
30608: AND
30609: PUSH
30610: LD_INT 267
30612: PPUSH
30613: CALL_OW 302
30617: AND
30618: IFFALSE 30994
30620: GO 30622
30622: DISABLE
30623: LD_INT 0
30625: PPUSH
// begin missionStage := 10 ;
30626: LD_ADDR_EXP 15
30630: PUSH
30631: LD_INT 10
30633: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_INT 22
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 23
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 26
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 3
30671: PUSH
30672: LD_INT 25
30674: PUSH
30675: LD_INT 12
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: LD_INT 25
30691: PUSH
30692: LD_INT 16
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: PPUSH
30710: CALL_OW 69
30714: PUSH
30715: LD_EXP 40
30719: PUSH
30720: LD_EXP 63
30724: PUSH
30725: LD_EXP 42
30729: PUSH
30730: LD_EXP 56
30734: PUSH
30735: LD_EXP 43
30739: PUSH
30740: LD_EXP 44
30744: PUSH
30745: LD_EXP 45
30749: PUSH
30750: LD_EXP 46
30754: PUSH
30755: LD_EXP 47
30759: PUSH
30760: LD_EXP 48
30764: PUSH
30765: LD_EXP 49
30769: PUSH
30770: LD_EXP 50
30774: PUSH
30775: LD_EXP 51
30779: PUSH
30780: LD_EXP 52
30784: PUSH
30785: LD_EXP 53
30789: PUSH
30790: LD_EXP 54
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: DIFF
30813: ST_TO_ADDR
// if not tmp and Brown then
30814: LD_VAR 0 1
30818: NOT
30819: PUSH
30820: LD_EXP 48
30824: AND
30825: IFFALSE 30840
// tmp := [ Brown ] ;
30827: LD_ADDR_VAR 0 1
30831: PUSH
30832: LD_EXP 48
30836: PUSH
30837: EMPTY
30838: LIST
30839: ST_TO_ADDR
// DialogueOn ;
30840: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30844: LD_VAR 0 1
30848: PUSH
30849: LD_INT 1
30851: ARRAY
30852: PPUSH
30853: LD_STRING D11-Sol1-1
30855: PPUSH
30856: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30860: LD_EXP 67
30864: PPUSH
30865: LD_STRING D11-Pla-1
30867: PPUSH
30868: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30872: LD_EXP 68
30876: PPUSH
30877: LD_STRING D11-Kov-1
30879: PPUSH
30880: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30884: LD_EXP 67
30888: PPUSH
30889: LD_STRING D11-Pla-2
30891: PPUSH
30892: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30896: LD_VAR 0 1
30900: PUSH
30901: LD_INT 1
30903: ARRAY
30904: PPUSH
30905: LD_STRING D11-Sol1-2
30907: PPUSH
30908: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30912: LD_EXP 40
30916: PPUSH
30917: LD_STRING D11-JMM-2
30919: PPUSH
30920: CALL_OW 88
// DialogueOff ;
30924: CALL_OW 7
// allowBehemothConstruct := true ;
30928: LD_ADDR_EXP 25
30932: PUSH
30933: LD_INT 1
30935: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30936: LD_STRING M4
30938: PPUSH
30939: CALL_OW 337
// BuildBehemoths ;
30943: CALL 8255 0 0
// repeat wait ( 15 15$00 ) ;
30947: LD_INT 31500
30949: PPUSH
30950: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30954: LD_EXP 27
30958: IFFALSE 30962
// break ;
30960: GO 30994
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30962: LD_INT 267
30964: PPUSH
30965: CALL_OW 274
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 275
30977: PUSH
30978: LD_INT 1000
30980: GREATEREQUAL
30981: IFFALSE 30987
// BuildBehemoths ;
30983: CALL 8255 0 0
// until not behemothBuilders ;
30987: LD_EXP 76
30991: NOT
30992: IFFALSE 30947
// end ;
30994: PPOPN 1
30996: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30997: LD_EXP 76
31001: NOT
31002: PUSH
31003: LD_EXP 28
31007: NOT
31008: AND
31009: PUSH
31010: LD_EXP 25
31014: AND
31015: IFFALSE 31035
31017: GO 31019
31019: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31020: LD_STRING M4a
31022: PPUSH
31023: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31027: LD_ADDR_EXP 27
31031: PUSH
31032: LD_INT 1
31034: ST_TO_ADDR
// end ;
31035: END
// every 0 0$1 trigger behemothDone do
31036: LD_EXP 28
31040: IFFALSE 31052
31042: GO 31044
31044: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31045: LD_STRING M4b
31047: PPUSH
31048: CALL_OW 337
31052: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31053: LD_EXP 29
31057: NOT
31058: IFFALSE 31254
31060: GO 31062
31062: DISABLE
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
// begin enable ;
31067: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31068: LD_ADDR_VAR 0 1
31072: PUSH
31073: LD_INT 3
31075: PPUSH
31076: CALL 107205 0 1
31080: ST_TO_ADDR
// if not tmp and not behemothDone then
31081: LD_VAR 0 1
31085: NOT
31086: PUSH
31087: LD_EXP 28
31091: NOT
31092: AND
31093: IFFALSE 31129
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31095: LD_ADDR_VAR 0 1
31099: PUSH
31100: LD_INT 22
31102: PUSH
31103: LD_INT 3
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 30
31112: PUSH
31113: LD_INT 37
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PPUSH
31124: CALL_OW 69
31128: ST_TO_ADDR
// if not tmp then
31129: LD_VAR 0 1
31133: NOT
31134: IFFALSE 31138
// exit ;
31136: GO 31254
// for i in tmp do
31138: LD_ADDR_VAR 0 2
31142: PUSH
31143: LD_VAR 0 1
31147: PUSH
31148: FOR_IN
31149: IFFALSE 31252
// if See ( 1 , i ) then
31151: LD_INT 1
31153: PPUSH
31154: LD_VAR 0 2
31158: PPUSH
31159: CALL_OW 292
31163: IFFALSE 31250
// begin if GetType ( i ) = unit_building then
31165: LD_VAR 0 2
31169: PPUSH
31170: CALL_OW 247
31174: PUSH
31175: LD_INT 3
31177: EQUAL
31178: IFFALSE 31216
// begin disable ;
31180: DISABLE
// CenterNowOnUnits ( i ) ;
31181: LD_VAR 0 2
31185: PPUSH
31186: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31190: LD_EXP 40
31194: PPUSH
31195: LD_STRING D17a-JMM-1
31197: PPUSH
31198: CALL_OW 88
// seeBehemoth := true ;
31202: LD_ADDR_EXP 29
31206: PUSH
31207: LD_INT 1
31209: ST_TO_ADDR
// exit ;
31210: POP
31211: POP
31212: GO 31254
// end else
31214: GO 31250
// begin disable ;
31216: DISABLE
// CenterNowOnUnits ( i ) ;
31217: LD_VAR 0 2
31221: PPUSH
31222: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31226: LD_EXP 40
31230: PPUSH
31231: LD_STRING D17b-JMM-1
31233: PPUSH
31234: CALL_OW 88
// seeBehemoth := true ;
31238: LD_ADDR_EXP 29
31242: PUSH
31243: LD_INT 1
31245: ST_TO_ADDR
// exit ;
31246: POP
31247: POP
31248: GO 31254
// end ; end ;
31250: GO 31148
31252: POP
31253: POP
// end ;
31254: PPOPN 2
31256: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31257: LD_EXP 14
31261: PUSH
31262: LD_INT 123200
31264: GREATEREQUAL
31265: IFFALSE 32465
31267: GO 31269
31269: DISABLE
31270: LD_INT 0
31272: PPUSH
31273: PPUSH
31274: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31275: LD_INT 2
31277: PPUSH
31278: LD_INT 23
31280: PUSH
31281: LD_INT 3
31283: PUSH
31284: LD_INT 3
31286: PUSH
31287: LD_INT 48
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: PUSH
31296: EMPTY
31297: LIST
31298: PPUSH
31299: CALL 63016 0 2
// repeat wait ( 0 0$1 ) ;
31303: LD_INT 35
31305: PPUSH
31306: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31310: LD_INT 22
31312: PUSH
31313: LD_INT 3
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 34
31322: PUSH
31323: LD_INT 48
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PPUSH
31334: CALL_OW 69
31338: IFFALSE 31303
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31340: LD_ADDR_VAR 0 1
31344: PUSH
31345: LD_INT 22
31347: PUSH
31348: LD_INT 3
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 34
31357: PUSH
31358: LD_INT 48
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PPUSH
31369: CALL_OW 69
31373: PUSH
31374: LD_INT 1
31376: ARRAY
31377: ST_TO_ADDR
// missionStage := 12 ;
31378: LD_ADDR_EXP 15
31382: PUSH
31383: LD_INT 12
31385: ST_TO_ADDR
// platonovHasBomb := true ;
31386: LD_ADDR_EXP 30
31390: PUSH
31391: LD_INT 1
31393: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31394: LD_VAR 0 1
31398: PPUSH
31399: LD_INT 181
31401: PPUSH
31402: LD_INT 86
31404: PPUSH
31405: CALL_OW 171
// AddComHold ( bomb ) ;
31409: LD_VAR 0 1
31413: PPUSH
31414: CALL_OW 200
// wait ( 0 0$10 ) ;
31418: LD_INT 350
31420: PPUSH
31421: CALL_OW 67
// DialogueOn ;
31425: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31429: LD_EXP 67
31433: PPUSH
31434: LD_STRING D15-Pla-1
31436: PPUSH
31437: CALL_OW 94
// dec := Query ( Q15a ) ;
31441: LD_ADDR_VAR 0 2
31445: PUSH
31446: LD_STRING Q15a
31448: PPUSH
31449: CALL_OW 97
31453: ST_TO_ADDR
// if dec = 1 then
31454: LD_VAR 0 2
31458: PUSH
31459: LD_INT 1
31461: EQUAL
31462: IFFALSE 31485
// begin Say ( JMM , D15a-JMM-1 ) ;
31464: LD_EXP 40
31468: PPUSH
31469: LD_STRING D15a-JMM-1
31471: PPUSH
31472: CALL_OW 88
// YouLost ( Surrender ) ;
31476: LD_STRING Surrender
31478: PPUSH
31479: CALL_OW 104
// exit ;
31483: GO 32465
// end ; if dec = 2 then
31485: LD_VAR 0 2
31489: PUSH
31490: LD_INT 2
31492: EQUAL
31493: IFFALSE 31562
// begin Say ( JMM , D15b-JMM-1 ) ;
31495: LD_EXP 40
31499: PPUSH
31500: LD_STRING D15b-JMM-1
31502: PPUSH
31503: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31507: LD_EXP 67
31511: PPUSH
31512: LD_STRING D15b-Pla-1
31514: PPUSH
31515: CALL_OW 94
// DialogueOff ;
31519: CALL_OW 7
// wait ( 3 3$00 ) ;
31523: LD_INT 6300
31525: PPUSH
31526: CALL_OW 67
// DialogueOn ;
31530: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31534: LD_EXP 40
31538: PPUSH
31539: LD_STRING D15d-JMM-1a
31541: PPUSH
31542: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31546: LD_EXP 67
31550: PPUSH
31551: LD_STRING D15d-Pla-1
31553: PPUSH
31554: CALL_OW 94
// DialogueOff ;
31558: CALL_OW 7
// end ; if dec = 3 then
31562: LD_VAR 0 2
31566: PUSH
31567: LD_INT 3
31569: EQUAL
31570: IFFALSE 31624
// begin Say ( JMM , D15c-JMM-1 ) ;
31572: LD_EXP 40
31576: PPUSH
31577: LD_STRING D15c-JMM-1
31579: PPUSH
31580: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31584: LD_EXP 67
31588: PPUSH
31589: LD_STRING D15c-Pla-1
31591: PPUSH
31592: CALL_OW 94
// DialogueOff ;
31596: CALL_OW 7
// wait ( 0 0$15 ) ;
31600: LD_INT 525
31602: PPUSH
31603: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31607: LD_VAR 0 1
31611: PPUSH
31612: LD_INT 60
31614: PPUSH
31615: LD_INT 95
31617: PPUSH
31618: CALL_OW 116
// exit ;
31622: GO 32465
// end ; if dec = 4 then
31624: LD_VAR 0 2
31628: PUSH
31629: LD_INT 4
31631: EQUAL
31632: IFFALSE 31662
// begin Say ( JMM , D15d-JMM-1 ) ;
31634: LD_EXP 40
31638: PPUSH
31639: LD_STRING D15d-JMM-1
31641: PPUSH
31642: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31646: LD_EXP 67
31650: PPUSH
31651: LD_STRING D15d-Pla-1
31653: PPUSH
31654: CALL_OW 94
// DialogueOff ;
31658: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31662: LD_EXP 65
31666: PPUSH
31667: CALL_OW 302
31671: PUSH
31672: LD_EXP 65
31676: PPUSH
31677: CALL_OW 255
31681: PUSH
31682: LD_INT 1
31684: EQUAL
31685: AND
31686: PUSH
31687: LD_INT 22
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 34
31699: PUSH
31700: LD_INT 8
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PPUSH
31711: CALL_OW 69
31715: NOT
31716: AND
31717: IFFALSE 32366
// begin SetSide ( Friend , 8 ) ;
31719: LD_EXP 65
31723: PPUSH
31724: LD_INT 8
31726: PPUSH
31727: CALL_OW 235
// if IsInUnit ( Friend ) then
31731: LD_EXP 65
31735: PPUSH
31736: CALL_OW 310
31740: IFFALSE 31751
// ComExitBuilding ( Friend ) ;
31742: LD_EXP 65
31746: PPUSH
31747: CALL_OW 122
// if IsDriver ( Friend ) then
31751: LD_EXP 65
31755: PPUSH
31756: CALL 104748 0 1
31760: IFFALSE 31771
// ComExitVehicle ( Friend ) ;
31762: LD_EXP 65
31766: PPUSH
31767: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31771: LD_EXP 65
31775: PPUSH
31776: LD_INT 9
31778: PPUSH
31779: LD_INT 2
31781: PPUSH
31782: CALL_OW 171
// wait ( 0 0$05 ) ;
31786: LD_INT 175
31788: PPUSH
31789: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31793: LD_EXP 65
31797: PPUSH
31798: CALL_OW 87
// DialogueOn ;
31802: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31806: LD_EXP 40
31810: PPUSH
31811: LD_STRING D16-JMM-1
31813: PPUSH
31814: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31818: LD_EXP 65
31822: PPUSH
31823: LD_STRING D16-Friend-1
31825: PPUSH
31826: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31830: LD_EXP 40
31834: PPUSH
31835: LD_STRING D16-JMM-2
31837: PPUSH
31838: CALL_OW 88
// DialogueOff ;
31842: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31846: LD_EXP 65
31850: PPUSH
31851: LD_INT 1
31853: PPUSH
31854: CALL_OW 235
// ComHold ( Friend ) ;
31858: LD_EXP 65
31862: PPUSH
31863: CALL_OW 140
// wait ( 0 0$20 ) ;
31867: LD_INT 700
31869: PPUSH
31870: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31874: LD_EXP 65
31878: PPUSH
31879: LD_INT 9
31881: PPUSH
31882: LD_INT 2
31884: PPUSH
31885: CALL_OW 297
31889: PUSH
31890: LD_INT 30
31892: LESS
31893: IFFALSE 31962
// begin SetSide ( Friend , 8 ) ;
31895: LD_EXP 65
31899: PPUSH
31900: LD_INT 8
31902: PPUSH
31903: CALL_OW 235
// if IsInUnit ( Friend ) then
31907: LD_EXP 65
31911: PPUSH
31912: CALL_OW 310
31916: IFFALSE 31927
// ComExitBuilding ( Friend ) ;
31918: LD_EXP 65
31922: PPUSH
31923: CALL_OW 122
// if IsDriver ( Friend ) then
31927: LD_EXP 65
31931: PPUSH
31932: CALL 104748 0 1
31936: IFFALSE 31947
// ComExitVehicle ( Friend ) ;
31938: LD_EXP 65
31942: PPUSH
31943: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31947: LD_EXP 65
31951: PPUSH
31952: LD_INT 9
31954: PPUSH
31955: LD_INT 2
31957: PPUSH
31958: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31962: LD_INT 1050
31964: PPUSH
31965: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31969: LD_INT 22
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 34
31981: PUSH
31982: LD_INT 8
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PPUSH
31993: CALL_OW 69
31997: NOT
31998: IFFALSE 32344
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32000: LD_ADDR_VAR 0 3
32004: PUSH
32005: LD_INT 22
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 26
32017: PUSH
32018: LD_INT 1
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 3
32027: PUSH
32028: LD_INT 25
32030: PUSH
32031: LD_INT 12
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 25
32040: PUSH
32041: LD_INT 16
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: LIST
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: LIST
32057: PPUSH
32058: CALL_OW 69
32062: PUSH
32063: LD_EXP 40
32067: PUSH
32068: LD_EXP 42
32072: PUSH
32073: LD_EXP 56
32077: PUSH
32078: LD_EXP 43
32082: PUSH
32083: LD_EXP 44
32087: PUSH
32088: LD_EXP 45
32092: PUSH
32093: LD_EXP 46
32097: PUSH
32098: LD_EXP 47
32102: PUSH
32103: LD_EXP 48
32107: PUSH
32108: LD_EXP 49
32112: PUSH
32113: LD_EXP 50
32117: PUSH
32118: LD_EXP 51
32122: PUSH
32123: LD_EXP 52
32127: PUSH
32128: LD_EXP 53
32132: PUSH
32133: LD_EXP 54
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: DIFF
32155: ST_TO_ADDR
// DialogueOn ;
32156: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32160: LD_EXP 67
32164: PPUSH
32165: LD_STRING D16a-Pla-1
32167: PPUSH
32168: CALL_OW 94
// if Stevens then
32172: LD_EXP 42
32176: IFFALSE 32192
// Say ( Stevens , D16a-Huck-1 ) else
32178: LD_EXP 42
32182: PPUSH
32183: LD_STRING D16a-Huck-1
32185: PPUSH
32186: CALL_OW 88
32190: GO 32234
// if Baker then
32192: LD_EXP 56
32196: IFFALSE 32212
// Say ( Baker , D16a-Huck-1 ) else
32198: LD_EXP 56
32202: PPUSH
32203: LD_STRING D16a-Huck-1
32205: PPUSH
32206: CALL_OW 88
32210: GO 32234
// if tmp then
32212: LD_VAR 0 3
32216: IFFALSE 32234
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32218: LD_VAR 0 3
32222: PUSH
32223: LD_INT 1
32225: ARRAY
32226: PPUSH
32227: LD_STRING D16a-Sol1-1
32229: PPUSH
32230: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32234: LD_EXP 65
32238: PPUSH
32239: CALL_OW 255
32243: PUSH
32244: LD_INT 8
32246: EQUAL
32247: IFFALSE 32263
// Say ( JMM , D16a-JMM-1 ) else
32249: LD_EXP 40
32253: PPUSH
32254: LD_STRING D16a-JMM-1
32256: PPUSH
32257: CALL_OW 88
32261: GO 32323
// begin Say ( JMM , D16a-JMM-1a ) ;
32263: LD_EXP 40
32267: PPUSH
32268: LD_STRING D16a-JMM-1a
32270: PPUSH
32271: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32275: LD_EXP 65
32279: PPUSH
32280: LD_STRING D16a-Friend-1
32282: PPUSH
32283: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32287: LD_EXP 65
32291: PPUSH
32292: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32296: LD_EXP 65
32300: PPUSH
32301: LD_INT 191
32303: PPUSH
32304: LD_INT 103
32306: PPUSH
32307: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32311: LD_EXP 65
32315: PPUSH
32316: LD_INT 3
32318: PPUSH
32319: CALL_OW 235
// end ; DialogueOff ;
32323: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32327: LD_VAR 0 1
32331: PPUSH
32332: LD_INT 60
32334: PPUSH
32335: LD_INT 95
32337: PPUSH
32338: CALL_OW 116
// end else
32342: GO 32364
// begin DialogueOn ;
32344: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32348: LD_EXP 67
32352: PPUSH
32353: LD_STRING D16c-Pla-1
32355: PPUSH
32356: CALL_OW 94
// DialogueOff ;
32360: CALL_OW 7
// end ; end else
32364: GO 32465
// begin wait ( 3 3$00 ) ;
32366: LD_INT 6300
32368: PPUSH
32369: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32373: LD_INT 22
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 34
32385: PUSH
32386: LD_INT 8
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PPUSH
32397: CALL_OW 69
32401: NOT
32402: IFFALSE 32445
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32404: LD_EXP 67
32408: PPUSH
32409: LD_STRING D16b-Pla-1
32411: PPUSH
32412: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32416: LD_EXP 40
32420: PPUSH
32421: LD_STRING D16b-JMM-1
32423: PPUSH
32424: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32428: LD_VAR 0 1
32432: PPUSH
32433: LD_INT 60
32435: PPUSH
32436: LD_INT 95
32438: PPUSH
32439: CALL_OW 116
// end else
32443: GO 32465
// begin DialogueOn ;
32445: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32449: LD_EXP 67
32453: PPUSH
32454: LD_STRING D16c-Pla-1
32456: PPUSH
32457: CALL_OW 94
// DialogueOff ;
32461: CALL_OW 7
// end ; end ; end ;
32465: PPOPN 3
32467: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32468: LD_INT 25
32470: PPUSH
32471: LD_INT 1
32473: PPUSH
32474: CALL_OW 321
32478: PUSH
32479: LD_INT 2
32481: EQUAL
32482: PUSH
32483: LD_EXP 14
32487: PUSH
32488: LD_INT 126000
32490: GREATEREQUAL
32491: OR
32492: PUSH
32493: LD_EXP 23
32497: NOT
32498: AND
32499: PUSH
32500: LD_EXP 78
32504: PPUSH
32505: CALL_OW 302
32509: AND
32510: IFFALSE 32868
32512: GO 32514
32514: DISABLE
32515: LD_INT 0
32517: PPUSH
// begin missionStage := 11 ;
32518: LD_ADDR_EXP 15
32522: PUSH
32523: LD_INT 11
32525: ST_TO_ADDR
// DialogueOn ;
32526: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32530: LD_EXP 78
32534: PPUSH
32535: LD_STRING D9-Roth-1
32537: PPUSH
32538: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32542: LD_EXP 40
32546: PPUSH
32547: LD_STRING D9-JMM-1
32549: PPUSH
32550: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32554: LD_EXP 78
32558: PPUSH
32559: LD_STRING D9-Roth-2
32561: PPUSH
32562: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32566: LD_EXP 78
32570: PPUSH
32571: LD_STRING D9-Roth-2a
32573: PPUSH
32574: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32578: LD_EXP 67
32582: PPUSH
32583: LD_STRING D9-Pla-2
32585: PPUSH
32586: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32590: LD_EXP 78
32594: PPUSH
32595: LD_STRING D9-Roth-3
32597: PPUSH
32598: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32602: LD_EXP 67
32606: PPUSH
32607: LD_STRING D9-Pla-3
32609: PPUSH
32610: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32614: LD_EXP 78
32618: PPUSH
32619: LD_STRING D9-Roth-4
32621: PPUSH
32622: CALL_OW 94
// dec := Query ( Q9 ) ;
32626: LD_ADDR_VAR 0 1
32630: PUSH
32631: LD_STRING Q9
32633: PPUSH
32634: CALL_OW 97
32638: ST_TO_ADDR
// if dec = 1 then
32639: LD_VAR 0 1
32643: PUSH
32644: LD_INT 1
32646: EQUAL
32647: IFFALSE 32661
// SayRadio ( Roth , D9a-Roth-1 ) ;
32649: LD_EXP 78
32653: PPUSH
32654: LD_STRING D9a-Roth-1
32656: PPUSH
32657: CALL_OW 94
// if dec = 2 then
32661: LD_VAR 0 1
32665: PUSH
32666: LD_INT 2
32668: EQUAL
32669: IFFALSE 32695
// begin Say ( JMM , D9b-JMM-1 ) ;
32671: LD_EXP 40
32675: PPUSH
32676: LD_STRING D9b-JMM-1
32678: PPUSH
32679: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32683: LD_EXP 78
32687: PPUSH
32688: LD_STRING D9b-Roth-1
32690: PPUSH
32691: CALL_OW 94
// end ; if dec = 3 then
32695: LD_VAR 0 1
32699: PUSH
32700: LD_INT 3
32702: EQUAL
32703: IFFALSE 32765
// begin Say ( JMM , D9c-JMM-1 ) ;
32705: LD_EXP 40
32709: PPUSH
32710: LD_STRING D9c-JMM-1
32712: PPUSH
32713: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32717: LD_EXP 78
32721: PPUSH
32722: LD_STRING D9c-Roth-1
32724: PPUSH
32725: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32729: LD_EXP 40
32733: PPUSH
32734: LD_STRING D9c-JMM-2
32736: PPUSH
32737: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32741: LD_EXP 78
32745: PPUSH
32746: LD_STRING D9c-Roth-2
32748: PPUSH
32749: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32753: LD_EXP 40
32757: PPUSH
32758: LD_STRING D9c-JMM-3
32760: PPUSH
32761: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32765: LD_EXP 78
32769: PPUSH
32770: LD_STRING D9c-Roth-3
32772: PPUSH
32773: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32777: LD_EXP 78
32781: PPUSH
32782: LD_STRING D9cont-Roth-1
32784: PPUSH
32785: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32789: LD_EXP 40
32793: PPUSH
32794: LD_STRING D9cont-JMM-1
32796: PPUSH
32797: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32801: LD_EXP 78
32805: PPUSH
32806: LD_STRING D9cont-Roth-2
32808: PPUSH
32809: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32813: LD_EXP 40
32817: PPUSH
32818: LD_STRING D9cont-JMM-2
32820: PPUSH
32821: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32825: LD_EXP 78
32829: PPUSH
32830: LD_STRING D9cont-Roth-3
32832: PPUSH
32833: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32837: LD_EXP 40
32841: PPUSH
32842: LD_STRING D9cont-JMM-3
32844: PPUSH
32845: CALL_OW 88
// DialogueOff ;
32849: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32853: LD_STRING M3
32855: PPUSH
32856: CALL_OW 337
// allianceActive := true ;
32860: LD_ADDR_EXP 31
32864: PUSH
32865: LD_INT 1
32867: ST_TO_ADDR
// end ;
32868: PPOPN 1
32870: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32871: LD_INT 1
32873: PPUSH
32874: LD_INT 126
32876: PPUSH
32877: CALL_OW 292
32881: PUSH
32882: LD_EXP 67
32886: PPUSH
32887: CALL_OW 310
32891: AND
32892: IFFALSE 33045
32894: GO 32896
32896: DISABLE
32897: LD_INT 0
32899: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32900: LD_EXP 67
32904: PPUSH
32905: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32909: LD_ADDR_VAR 0 1
32913: PUSH
32914: LD_INT 4
32916: PPUSH
32917: LD_INT 22
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PPUSH
32927: CALL_OW 70
32931: PPUSH
32932: LD_EXP 67
32936: PPUSH
32937: CALL_OW 74
32941: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32942: LD_EXP 67
32946: PPUSH
32947: LD_VAR 0 1
32951: PUSH
32952: LD_INT 1
32954: ARRAY
32955: PPUSH
32956: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32960: LD_EXP 67
32964: PPUSH
32965: LD_STRING D18-Pla-1
32967: PPUSH
32968: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
32972: LD_INT 22
32974: PUSH
32975: LD_INT 3
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 34
32984: PUSH
32985: LD_INT 48
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PPUSH
32996: CALL_OW 69
33000: IFFALSE 33045
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33002: LD_INT 22
33004: PUSH
33005: LD_INT 3
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 34
33014: PUSH
33015: LD_INT 48
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PPUSH
33026: CALL_OW 69
33030: PUSH
33031: LD_INT 1
33033: ARRAY
33034: PPUSH
33035: LD_INT 111
33037: PPUSH
33038: LD_INT 97
33040: PPUSH
33041: CALL_OW 116
// end ;
33045: PPOPN 1
33047: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33048: LD_EXP 67
33052: PPUSH
33053: CALL_OW 301
33057: PUSH
33058: LD_EXP 70
33062: PPUSH
33063: CALL_OW 301
33067: AND
33068: PUSH
33069: LD_INT 22
33071: PUSH
33072: LD_INT 3
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 21
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 50
33091: PUSH
33092: EMPTY
33093: LIST
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: LIST
33099: PPUSH
33100: CALL_OW 69
33104: PUSH
33105: LD_INT 7
33107: PUSH
33108: LD_INT 8
33110: PUSH
33111: LD_INT 9
33113: PUSH
33114: LD_INT 10
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: PUSH
33123: LD_OWVAR 67
33127: ARRAY
33128: LESS
33129: AND
33130: IFFALSE 33929
33132: GO 33134
33134: DISABLE
33135: LD_INT 0
33137: PPUSH
33138: PPUSH
33139: PPUSH
33140: PPUSH
// begin MC_Kill ( 2 ) ;
33141: LD_INT 2
33143: PPUSH
33144: CALL 38991 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33148: LD_INT 1
33150: PPUSH
33151: LD_INT 3
33153: PPUSH
33154: LD_INT 1
33156: PPUSH
33157: LD_INT 1
33159: PPUSH
33160: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33164: LD_ADDR_VAR 0 2
33168: PUSH
33169: LD_INT 22
33171: PUSH
33172: LD_INT 3
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 21
33181: PUSH
33182: LD_INT 1
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 50
33191: PUSH
33192: EMPTY
33193: LIST
33194: PUSH
33195: LD_INT 26
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: PPUSH
33211: CALL_OW 69
33215: ST_TO_ADDR
// if not tmp then
33216: LD_VAR 0 2
33220: NOT
33221: IFFALSE 33277
// begin uc_side = 3 ;
33223: LD_ADDR_OWVAR 20
33227: PUSH
33228: LD_INT 3
33230: ST_TO_ADDR
// uc_nation = 3 ;
33231: LD_ADDR_OWVAR 21
33235: PUSH
33236: LD_INT 3
33238: ST_TO_ADDR
// hc_name =  ;
33239: LD_ADDR_OWVAR 26
33243: PUSH
33244: LD_STRING 
33246: ST_TO_ADDR
// hc_gallery =  ;
33247: LD_ADDR_OWVAR 33
33251: PUSH
33252: LD_STRING 
33254: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33255: LD_INT 1
33257: PPUSH
33258: LD_INT 10
33260: PPUSH
33261: CALL_OW 381
// tmp = CreateHuman ;
33265: LD_ADDR_VAR 0 2
33269: PUSH
33270: CALL_OW 44
33274: ST_TO_ADDR
// end else
33275: GO 33291
// tmp := tmp [ 1 ] ;
33277: LD_ADDR_VAR 0 2
33281: PUSH
33282: LD_VAR 0 2
33286: PUSH
33287: LD_INT 1
33289: ARRAY
33290: ST_TO_ADDR
// DialogueOn ;
33291: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33295: LD_VAR 0 2
33299: PPUSH
33300: LD_STRING DSurrenderRussians-RSol1-1a
33302: PPUSH
33303: CALL_OW 94
// DialogueOff ;
33307: CALL_OW 7
// russianDestroyed := true ;
33311: LD_ADDR_EXP 21
33315: PUSH
33316: LD_INT 1
33318: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33319: LD_ADDR_VAR 0 1
33323: PUSH
33324: LD_INT 22
33326: PUSH
33327: LD_INT 6
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PPUSH
33334: CALL_OW 69
33338: PUSH
33339: FOR_IN
33340: IFFALSE 33353
// KillUnit ( i ) ;
33342: LD_VAR 0 1
33346: PPUSH
33347: CALL_OW 66
33351: GO 33339
33353: POP
33354: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33355: LD_INT 22
33357: PUSH
33358: LD_INT 3
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 21
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PPUSH
33379: CALL_OW 69
33383: PPUSH
33384: CALL_OW 122
// wait ( 0 0$1 ) ;
33388: LD_INT 35
33390: PPUSH
33391: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33395: LD_INT 22
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 21
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PPUSH
33419: CALL_OW 69
33423: PPUSH
33424: LD_INT 25
33426: PPUSH
33427: CALL_OW 173
// wait ( 0 0$35 ) ;
33431: LD_INT 1225
33433: PPUSH
33434: CALL_OW 67
// PrepareOmarInvasion ;
33438: CALL 16155 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33442: LD_ADDR_VAR 0 2
33446: PUSH
33447: LD_EXP 96
33451: PPUSH
33452: CALL_OW 250
33456: PUSH
33457: LD_EXP 96
33461: PPUSH
33462: CALL_OW 251
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33471: LD_VAR 0 2
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: PPUSH
33480: LD_VAR 0 2
33484: PUSH
33485: LD_INT 2
33487: ARRAY
33488: PPUSH
33489: LD_INT 1
33491: PPUSH
33492: LD_INT 8
33494: NEG
33495: PPUSH
33496: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33500: LD_EXP 96
33504: PPUSH
33505: CALL_OW 87
// DialogueOn ;
33509: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33513: LD_EXP 40
33517: PPUSH
33518: LD_STRING D19-JMM-1
33520: PPUSH
33521: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33525: LD_ADDR_VAR 0 3
33529: PUSH
33530: LD_INT 22
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 26
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 2
33552: PUSH
33553: LD_INT 25
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 25
33565: PUSH
33566: LD_INT 2
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 25
33575: PUSH
33576: LD_INT 3
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 25
33585: PUSH
33586: LD_INT 4
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 25
33595: PUSH
33596: LD_INT 5
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 25
33605: PUSH
33606: LD_INT 8
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: LIST
33626: PPUSH
33627: CALL_OW 69
33631: PUSH
33632: LD_EXP 40
33636: PUSH
33637: LD_EXP 41
33641: PUSH
33642: LD_EXP 63
33646: PUSH
33647: LD_EXP 42
33651: PUSH
33652: LD_EXP 43
33656: PUSH
33657: LD_EXP 44
33661: PUSH
33662: LD_EXP 45
33666: PUSH
33667: LD_EXP 46
33671: PUSH
33672: LD_EXP 47
33676: PUSH
33677: LD_EXP 48
33681: PUSH
33682: LD_EXP 49
33686: PUSH
33687: LD_EXP 50
33691: PUSH
33692: LD_EXP 51
33696: PUSH
33697: LD_EXP 52
33701: PUSH
33702: LD_EXP 53
33706: PUSH
33707: LD_EXP 54
33711: PUSH
33712: LD_EXP 55
33716: PUSH
33717: LD_EXP 56
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: DIFF
33742: ST_TO_ADDR
// if tmp2 then
33743: LD_VAR 0 3
33747: IFFALSE 33765
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33749: LD_VAR 0 3
33753: PUSH
33754: LD_INT 1
33756: ARRAY
33757: PPUSH
33758: LD_STRING D19-Sol1-1
33760: PPUSH
33761: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33765: LD_EXP 40
33769: PPUSH
33770: LD_STRING D19-JMM-2
33772: PPUSH
33773: CALL_OW 88
// DialogueOff ;
33777: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33781: LD_VAR 0 2
33785: PUSH
33786: LD_INT 1
33788: ARRAY
33789: PPUSH
33790: LD_VAR 0 2
33794: PUSH
33795: LD_INT 2
33797: ARRAY
33798: PPUSH
33799: LD_INT 1
33801: PPUSH
33802: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33806: LD_STRING M5
33808: PPUSH
33809: CALL_OW 337
// omarOnMotherLode := false ;
33813: LD_ADDR_VAR 0 4
33817: PUSH
33818: LD_INT 0
33820: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33821: LD_INT 35
33823: PPUSH
33824: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33828: LD_EXP 96
33832: PPUSH
33833: LD_INT 215
33835: PPUSH
33836: LD_INT 100
33838: PPUSH
33839: CALL_OW 297
33843: PUSH
33844: LD_INT 10
33846: LESS
33847: PUSH
33848: LD_VAR 0 4
33852: NOT
33853: AND
33854: IFFALSE 33888
// begin omarOnMotherLode := true ;
33856: LD_ADDR_VAR 0 4
33860: PUSH
33861: LD_INT 1
33863: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33864: LD_EXP 40
33868: PPUSH
33869: LD_STRING D19b-JMM-1
33871: PPUSH
33872: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33876: LD_EXP 96
33880: PPUSH
33881: LD_STRING DOmarContam-Omar-1
33883: PPUSH
33884: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33888: LD_EXP 96
33892: PPUSH
33893: CALL_OW 301
33897: IFFALSE 33821
// Say ( JMM , D19a-JMM-1 ) ;
33899: LD_EXP 40
33903: PPUSH
33904: LD_STRING D19a-JMM-1
33906: PPUSH
33907: CALL_OW 88
// if Heike then
33911: LD_EXP 97
33915: IFFALSE 33929
// Say ( Heike , D19a-Hke-1 ) ;
33917: LD_EXP 97
33921: PPUSH
33922: LD_STRING D19a-Hke-1
33924: PPUSH
33925: CALL_OW 88
// end ;
33929: PPOPN 4
33931: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33932: LD_INT 22
33934: PUSH
33935: LD_INT 3
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 21
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PPUSH
33956: CALL_OW 69
33960: PUSH
33961: LD_EXP 21
33965: AND
33966: IFFALSE 34034
33968: GO 33970
33970: DISABLE
33971: LD_INT 0
33973: PPUSH
33974: PPUSH
// begin enable ;
33975: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33976: LD_ADDR_VAR 0 2
33980: PUSH
33981: LD_INT 25
33983: PPUSH
33984: LD_INT 22
33986: PUSH
33987: LD_INT 3
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PPUSH
33994: CALL_OW 70
33998: ST_TO_ADDR
// if not tmp then
33999: LD_VAR 0 2
34003: NOT
34004: IFFALSE 34008
// exit ;
34006: GO 34034
// for i in tmp do
34008: LD_ADDR_VAR 0 1
34012: PUSH
34013: LD_VAR 0 2
34017: PUSH
34018: FOR_IN
34019: IFFALSE 34032
// RemoveUnit ( i ) ;
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL_OW 64
34030: GO 34018
34032: POP
34033: POP
// end ;
34034: PPOPN 2
34036: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34037: LD_INT 22
34039: PUSH
34040: LD_INT 7
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 21
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PPUSH
34061: CALL_OW 69
34065: PUSH
34066: LD_INT 6
34068: LESS
34069: IFFALSE 34537
34071: GO 34073
34073: DISABLE
34074: LD_INT 0
34076: PPUSH
34077: PPUSH
// begin MC_Kill ( 1 ) ;
34078: LD_INT 1
34080: PPUSH
34081: CALL 38991 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34085: LD_INT 7
34087: PPUSH
34088: LD_INT 1
34090: PPUSH
34091: LD_INT 1
34093: PPUSH
34094: LD_INT 1
34096: PPUSH
34097: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34101: LD_ADDR_VAR 0 1
34105: PUSH
34106: LD_INT 22
34108: PUSH
34109: LD_INT 7
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 26
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PPUSH
34130: CALL_OW 69
34134: PUSH
34135: LD_EXP 78
34139: DIFF
34140: ST_TO_ADDR
// if tmp then
34141: LD_VAR 0 1
34145: IFFALSE 34163
// tmp := tmp [ 1 ] else
34147: LD_ADDR_VAR 0 1
34151: PUSH
34152: LD_VAR 0 1
34156: PUSH
34157: LD_INT 1
34159: ARRAY
34160: ST_TO_ADDR
34161: GO 34199
// begin uc_side := 7 ;
34163: LD_ADDR_OWVAR 20
34167: PUSH
34168: LD_INT 7
34170: ST_TO_ADDR
// uc_nation := 1 ;
34171: LD_ADDR_OWVAR 21
34175: PUSH
34176: LD_INT 1
34178: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34179: LD_INT 1
34181: PPUSH
34182: LD_INT 8
34184: PPUSH
34185: CALL_OW 384
// tmp := CreateHuman ;
34189: LD_ADDR_VAR 0 1
34193: PUSH
34194: CALL_OW 44
34198: ST_TO_ADDR
// end ; DialogueOn ;
34199: CALL_OW 6
// if IsOK ( Roth ) then
34203: LD_EXP 78
34207: PPUSH
34208: CALL_OW 302
34212: IFFALSE 34226
// Say ( JMM , DAb-JMM-1 ) ;
34214: LD_EXP 40
34218: PPUSH
34219: LD_STRING DAb-JMM-1
34221: PPUSH
34222: CALL_OW 88
// if IsOK ( Roth ) then
34226: LD_EXP 78
34230: PPUSH
34231: CALL_OW 302
34235: IFFALSE 34259
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34237: LD_EXP 78
34241: PPUSH
34242: LD_STRING DSurrenderAlliance-Roth-1
34244: PPUSH
34245: CALL_OW 88
// RothCaptured := true ;
34249: LD_ADDR_EXP 33
34253: PUSH
34254: LD_INT 1
34256: ST_TO_ADDR
// end else
34257: GO 34271
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: LD_STRING DSurrenderAlliance-Sci1-1
34266: PPUSH
34267: CALL_OW 88
// DialogueOff ;
34271: CALL_OW 7
// allianceDestroyed := true ;
34275: LD_ADDR_EXP 23
34279: PUSH
34280: LD_INT 1
34282: ST_TO_ADDR
// if capturedUnit = 0 then
34283: LD_EXP 34
34287: PUSH
34288: LD_INT 0
34290: EQUAL
34291: IFFALSE 34300
// SetAchievement ( ACH_ALLIANCE ) ;
34293: LD_STRING ACH_ALLIANCE
34295: PPUSH
34296: CALL_OW 543
// if trueAmericans then
34300: LD_EXP 35
34304: IFFALSE 34380
// begin if trueAmericans = 1 then
34306: LD_EXP 35
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34330
// Say ( JMM , DAb-JMM-1a ) else
34316: LD_EXP 40
34320: PPUSH
34321: LD_STRING DAb-JMM-1a
34323: PPUSH
34324: CALL_OW 88
34328: GO 34342
// Say ( JMM , DAb-JMM-1b ) ;
34330: LD_EXP 40
34334: PPUSH
34335: LD_STRING DAb-JMM-1b
34337: PPUSH
34338: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34342: LD_EXP 35
34346: PPUSH
34347: CALL_OW 87
// for i in trueAmericans do
34351: LD_ADDR_VAR 0 2
34355: PUSH
34356: LD_EXP 35
34360: PUSH
34361: FOR_IN
34362: IFFALSE 34378
// SetSide ( i , 1 ) ;
34364: LD_VAR 0 2
34368: PPUSH
34369: LD_INT 1
34371: PPUSH
34372: CALL_OW 235
34376: GO 34361
34378: POP
34379: POP
// end ; repeat wait ( 0 0$1 ) ;
34380: LD_INT 35
34382: PPUSH
34383: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34387: LD_ADDR_VAR 0 2
34391: PUSH
34392: LD_INT 22
34394: PUSH
34395: LD_INT 7
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 21
34404: PUSH
34405: LD_INT 1
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PPUSH
34416: CALL_OW 69
34420: PUSH
34421: FOR_IN
34422: IFFALSE 34504
// begin if IsInUnit ( i ) then
34424: LD_VAR 0 2
34428: PPUSH
34429: CALL_OW 310
34433: IFFALSE 34444
// ComExitBuilding ( i ) ;
34435: LD_VAR 0 2
34439: PPUSH
34440: CALL_OW 122
// if IsDriver ( i ) then
34444: LD_VAR 0 2
34448: PPUSH
34449: CALL 104748 0 1
34453: IFFALSE 34464
// ComExitVehicle ( i ) ;
34455: LD_VAR 0 2
34459: PPUSH
34460: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34464: LD_VAR 0 2
34468: PPUSH
34469: LD_INT 26
34471: PPUSH
34472: CALL_OW 308
34476: NOT
34477: IFFALSE 34493
// AddComMoveToArea ( i , allianceEscapeArea ) else
34479: LD_VAR 0 2
34483: PPUSH
34484: LD_INT 26
34486: PPUSH
34487: CALL_OW 173
34491: GO 34502
// RemoveUnit ( i ) ;
34493: LD_VAR 0 2
34497: PPUSH
34498: CALL_OW 64
// end ;
34502: GO 34421
34504: POP
34505: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34506: LD_INT 22
34508: PUSH
34509: LD_INT 7
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 21
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PPUSH
34530: CALL_OW 69
34534: NOT
34535: IFFALSE 34380
// end ;
34537: PPOPN 2
34539: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34540: LD_INT 0
34542: PPUSH
34543: PPUSH
// if not unit then
34544: LD_VAR 0 1
34548: NOT
34549: IFFALSE 34553
// exit ;
34551: GO 36061
// DoNotAttack ( 7 , unit ) ;
34553: LD_INT 7
34555: PPUSH
34556: LD_VAR 0 1
34560: PPUSH
34561: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34565: LD_VAR 0 1
34569: PPUSH
34570: LD_INT 260
34572: PPUSH
34573: LD_INT 235
34575: PPUSH
34576: LD_INT 3
34578: PPUSH
34579: LD_INT 1
34581: PPUSH
34582: CALL_OW 483
// SetSide ( unit , 4 ) ;
34586: LD_VAR 0 1
34590: PPUSH
34591: LD_INT 4
34593: PPUSH
34594: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34598: LD_ADDR_EXP 34
34602: PUSH
34603: LD_EXP 34
34607: PUSH
34608: LD_INT 1
34610: PLUS
34611: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34612: LD_INT 70
34614: PPUSH
34615: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34619: LD_INT 260
34621: PPUSH
34622: LD_INT 235
34624: PPUSH
34625: LD_INT 1
34627: PPUSH
34628: LD_INT 8
34630: NEG
34631: PPUSH
34632: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34636: LD_VAR 0 1
34640: PPUSH
34641: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34645: LD_VAR 0 1
34649: PPUSH
34650: LD_EXP 78
34654: PPUSH
34655: CALL_OW 119
// DialogueOn ;
34659: CALL_OW 6
// case unit of JMM :
34663: LD_VAR 0 1
34667: PUSH
34668: LD_EXP 40
34672: DOUBLE
34673: EQUAL
34674: IFTRUE 34678
34676: GO 34693
34678: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34679: LD_EXP 40
34683: PPUSH
34684: LD_STRING DA1-JMM-1
34686: PPUSH
34687: CALL_OW 91
34691: GO 35135
34693: LD_EXP 41
34697: DOUBLE
34698: EQUAL
34699: IFTRUE 34703
34701: GO 34718
34703: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34704: LD_EXP 41
34708: PPUSH
34709: LD_STRING DA1-Joan-1
34711: PPUSH
34712: CALL_OW 91
34716: GO 35135
34718: LD_EXP 43
34722: DOUBLE
34723: EQUAL
34724: IFTRUE 34728
34726: GO 34743
34728: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34729: LD_EXP 43
34733: PPUSH
34734: LD_STRING DA1-Lisa-1
34736: PPUSH
34737: CALL_OW 91
34741: GO 35135
34743: LD_EXP 44
34747: DOUBLE
34748: EQUAL
34749: IFTRUE 34753
34751: GO 34768
34753: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34754: LD_EXP 44
34758: PPUSH
34759: LD_STRING DA1-Don-1
34761: PPUSH
34762: CALL_OW 91
34766: GO 35135
34768: LD_EXP 51
34772: DOUBLE
34773: EQUAL
34774: IFTRUE 34778
34776: GO 34793
34778: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34779: LD_EXP 51
34783: PPUSH
34784: LD_STRING DA1-Corn-1
34786: PPUSH
34787: CALL_OW 91
34791: GO 35135
34793: LD_EXP 47
34797: DOUBLE
34798: EQUAL
34799: IFTRUE 34803
34801: GO 34818
34803: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34804: LD_EXP 47
34808: PPUSH
34809: LD_STRING DA1-Den-1
34811: PPUSH
34812: CALL_OW 91
34816: GO 35135
34818: LD_EXP 45
34822: DOUBLE
34823: EQUAL
34824: IFTRUE 34828
34826: GO 34843
34828: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34829: LD_EXP 45
34833: PPUSH
34834: LD_STRING DA1-Bobby-1
34836: PPUSH
34837: CALL_OW 91
34841: GO 35135
34843: LD_EXP 49
34847: DOUBLE
34848: EQUAL
34849: IFTRUE 34853
34851: GO 34868
34853: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34854: LD_EXP 49
34858: PPUSH
34859: LD_STRING DA1-Glad-1
34861: PPUSH
34862: CALL_OW 91
34866: GO 35135
34868: LD_EXP 46
34872: DOUBLE
34873: EQUAL
34874: IFTRUE 34878
34876: GO 34893
34878: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34879: LD_EXP 46
34883: PPUSH
34884: LD_STRING DA1-Cyrus-1
34886: PPUSH
34887: CALL_OW 91
34891: GO 35135
34893: LD_EXP 42
34897: DOUBLE
34898: EQUAL
34899: IFTRUE 34903
34901: GO 34918
34903: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34904: LD_EXP 42
34908: PPUSH
34909: LD_STRING DA1-Huck-1
34911: PPUSH
34912: CALL_OW 91
34916: GO 35135
34918: LD_EXP 56
34922: DOUBLE
34923: EQUAL
34924: IFTRUE 34928
34926: GO 34943
34928: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34929: LD_EXP 56
34933: PPUSH
34934: LD_STRING DA1-Huck-1
34936: PPUSH
34937: CALL_OW 91
34941: GO 35135
34943: LD_EXP 48
34947: DOUBLE
34948: EQUAL
34949: IFTRUE 34953
34951: GO 34968
34953: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34954: LD_EXP 48
34958: PPUSH
34959: LD_STRING DA1-Brown-1
34961: PPUSH
34962: CALL_OW 91
34966: GO 35135
34968: LD_EXP 52
34972: DOUBLE
34973: EQUAL
34974: IFTRUE 34978
34976: GO 34993
34978: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34979: LD_EXP 52
34983: PPUSH
34984: LD_STRING DA1-Gary-1
34986: PPUSH
34987: CALL_OW 91
34991: GO 35135
34993: LD_EXP 55
34997: DOUBLE
34998: EQUAL
34999: IFTRUE 35003
35001: GO 35018
35003: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35004: LD_EXP 55
35008: PPUSH
35009: LD_STRING DA1-Con-1
35011: PPUSH
35012: CALL_OW 91
35016: GO 35135
35018: LD_EXP 63
35022: DOUBLE
35023: EQUAL
35024: IFTRUE 35028
35026: GO 35043
35028: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35029: LD_EXP 63
35033: PPUSH
35034: LD_STRING DA1-Kurt-1
35036: PPUSH
35037: CALL_OW 91
35041: GO 35135
35043: LD_EXP 54
35047: DOUBLE
35048: EQUAL
35049: IFTRUE 35053
35051: GO 35068
35053: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35054: LD_EXP 54
35058: PPUSH
35059: LD_STRING DA1-Yam-1
35061: PPUSH
35062: CALL_OW 91
35066: GO 35135
35068: LD_EXP 53
35072: DOUBLE
35073: EQUAL
35074: IFTRUE 35078
35076: GO 35093
35078: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35079: LD_EXP 53
35083: PPUSH
35084: LD_STRING DA1-Frank-1
35086: PPUSH
35087: CALL_OW 91
35091: GO 35135
35093: POP
// begin if GetSex ( unit ) = sex_male then
35094: LD_VAR 0 1
35098: PPUSH
35099: CALL_OW 258
35103: PUSH
35104: LD_INT 1
35106: EQUAL
35107: IFFALSE 35123
// ForceSay ( unit , DA1-Sol1-1 ) else
35109: LD_VAR 0 1
35113: PPUSH
35114: LD_STRING DA1-Sol1-1
35116: PPUSH
35117: CALL_OW 91
35121: GO 35135
// ForceSay ( unit , DA1-FSol1-1 ) ;
35123: LD_VAR 0 1
35127: PPUSH
35128: LD_STRING DA1-FSol1-1
35130: PPUSH
35131: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35135: LD_EXP 78
35139: PPUSH
35140: LD_STRING DA-Roth-1
35142: PPUSH
35143: CALL_OW 88
// if capturedUnit = 1 then
35147: LD_EXP 34
35151: PUSH
35152: LD_INT 1
35154: EQUAL
35155: IFFALSE 35183
// begin Say ( Simms , DA-Sim-1 ) ;
35157: LD_EXP 79
35161: PPUSH
35162: LD_STRING DA-Sim-1
35164: PPUSH
35165: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35169: LD_EXP 78
35173: PPUSH
35174: LD_STRING DA-Roth-2
35176: PPUSH
35177: CALL_OW 88
// end else
35181: GO 35195
// Say ( Simms , DA-Sim-2 ) ;
35183: LD_EXP 79
35187: PPUSH
35188: LD_STRING DA-Sim-2
35190: PPUSH
35191: CALL_OW 88
// case unit of JMM :
35195: LD_VAR 0 1
35199: PUSH
35200: LD_EXP 40
35204: DOUBLE
35205: EQUAL
35206: IFTRUE 35210
35208: GO 35225
35210: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35211: LD_EXP 40
35215: PPUSH
35216: LD_STRING DA1-JMM-1a
35218: PPUSH
35219: CALL_OW 91
35223: GO 35742
35225: LD_EXP 41
35229: DOUBLE
35230: EQUAL
35231: IFTRUE 35235
35233: GO 35250
35235: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35236: LD_EXP 41
35240: PPUSH
35241: LD_STRING DA1-Joan-1a
35243: PPUSH
35244: CALL_OW 91
35248: GO 35742
35250: LD_EXP 43
35254: DOUBLE
35255: EQUAL
35256: IFTRUE 35260
35258: GO 35275
35260: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35261: LD_EXP 43
35265: PPUSH
35266: LD_STRING DA1-Lisa-1a
35268: PPUSH
35269: CALL_OW 91
35273: GO 35742
35275: LD_EXP 44
35279: DOUBLE
35280: EQUAL
35281: IFTRUE 35285
35283: GO 35300
35285: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35286: LD_EXP 44
35290: PPUSH
35291: LD_STRING DA1-Don-1a
35293: PPUSH
35294: CALL_OW 91
35298: GO 35742
35300: LD_EXP 51
35304: DOUBLE
35305: EQUAL
35306: IFTRUE 35310
35308: GO 35325
35310: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35311: LD_EXP 51
35315: PPUSH
35316: LD_STRING DA1-Corn-1a
35318: PPUSH
35319: CALL_OW 91
35323: GO 35742
35325: LD_EXP 47
35329: DOUBLE
35330: EQUAL
35331: IFTRUE 35335
35333: GO 35350
35335: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35336: LD_EXP 47
35340: PPUSH
35341: LD_STRING DA1-Den-1a
35343: PPUSH
35344: CALL_OW 91
35348: GO 35742
35350: LD_EXP 45
35354: DOUBLE
35355: EQUAL
35356: IFTRUE 35360
35358: GO 35375
35360: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35361: LD_EXP 45
35365: PPUSH
35366: LD_STRING DA1-Bobby-1a
35368: PPUSH
35369: CALL_OW 91
35373: GO 35742
35375: LD_EXP 49
35379: DOUBLE
35380: EQUAL
35381: IFTRUE 35385
35383: GO 35400
35385: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35386: LD_EXP 49
35390: PPUSH
35391: LD_STRING DA1-Glad-1a
35393: PPUSH
35394: CALL_OW 91
35398: GO 35742
35400: LD_EXP 46
35404: DOUBLE
35405: EQUAL
35406: IFTRUE 35410
35408: GO 35425
35410: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35411: LD_EXP 46
35415: PPUSH
35416: LD_STRING DA1-Cyrus-1a
35418: PPUSH
35419: CALL_OW 91
35423: GO 35742
35425: LD_EXP 42
35429: DOUBLE
35430: EQUAL
35431: IFTRUE 35435
35433: GO 35450
35435: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35436: LD_EXP 42
35440: PPUSH
35441: LD_STRING DA1-Huck-1a
35443: PPUSH
35444: CALL_OW 91
35448: GO 35742
35450: LD_EXP 56
35454: DOUBLE
35455: EQUAL
35456: IFTRUE 35460
35458: GO 35475
35460: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35461: LD_EXP 56
35465: PPUSH
35466: LD_STRING DA1-Huck-1a
35468: PPUSH
35469: CALL_OW 91
35473: GO 35742
35475: LD_EXP 48
35479: DOUBLE
35480: EQUAL
35481: IFTRUE 35485
35483: GO 35500
35485: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35486: LD_EXP 48
35490: PPUSH
35491: LD_STRING DA1-Brown-1a
35493: PPUSH
35494: CALL_OW 91
35498: GO 35742
35500: LD_EXP 52
35504: DOUBLE
35505: EQUAL
35506: IFTRUE 35510
35508: GO 35525
35510: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35511: LD_EXP 52
35515: PPUSH
35516: LD_STRING DA1-Gary-1a
35518: PPUSH
35519: CALL_OW 91
35523: GO 35742
35525: LD_EXP 55
35529: DOUBLE
35530: EQUAL
35531: IFTRUE 35535
35533: GO 35560
35535: POP
// if JMMGirl = 3 then
35536: LD_EXP 7
35540: PUSH
35541: LD_INT 3
35543: EQUAL
35544: IFFALSE 35558
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35546: LD_EXP 55
35550: PPUSH
35551: LD_STRING DA1-Con-1a
35553: PPUSH
35554: CALL_OW 91
35558: GO 35742
35560: LD_EXP 63
35564: DOUBLE
35565: EQUAL
35566: IFTRUE 35570
35568: GO 35585
35570: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35571: LD_EXP 63
35575: PPUSH
35576: LD_STRING DA1-Kurt-1a
35578: PPUSH
35579: CALL_OW 91
35583: GO 35742
35585: LD_EXP 54
35589: DOUBLE
35590: EQUAL
35591: IFTRUE 35595
35593: GO 35610
35595: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35596: LD_EXP 54
35600: PPUSH
35601: LD_STRING DA1-Yam-1a
35603: PPUSH
35604: CALL_OW 91
35608: GO 35742
35610: LD_EXP 53
35614: DOUBLE
35615: EQUAL
35616: IFTRUE 35620
35618: GO 35635
35620: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35621: LD_EXP 53
35625: PPUSH
35626: LD_STRING DA1-Frank-1a
35628: PPUSH
35629: CALL_OW 91
35633: GO 35742
35635: POP
// begin join := rand ( 0 , 1 ) ;
35636: LD_ADDR_VAR 0 3
35640: PUSH
35641: LD_INT 0
35643: PPUSH
35644: LD_INT 1
35646: PPUSH
35647: CALL_OW 12
35651: ST_TO_ADDR
// if join then
35652: LD_VAR 0 3
35656: IFFALSE 35701
// begin if GetSex ( unit ) = sex_male then
35658: LD_VAR 0 1
35662: PPUSH
35663: CALL_OW 258
35667: PUSH
35668: LD_INT 1
35670: EQUAL
35671: IFFALSE 35687
// ForceSay ( unit , DA1-Sol1-1b ) else
35673: LD_VAR 0 1
35677: PPUSH
35678: LD_STRING DA1-Sol1-1b
35680: PPUSH
35681: CALL_OW 91
35685: GO 35699
// ForceSay ( unit , DA1-FSol1-1b ) ;
35687: LD_VAR 0 1
35691: PPUSH
35692: LD_STRING DA1-FSol1-1b
35694: PPUSH
35695: CALL_OW 91
// end else
35699: GO 35742
// begin if GetSex ( unit ) = sex_male then
35701: LD_VAR 0 1
35705: PPUSH
35706: CALL_OW 258
35710: PUSH
35711: LD_INT 1
35713: EQUAL
35714: IFFALSE 35730
// ForceSay ( unit , DA1-Sol1-1a ) else
35716: LD_VAR 0 1
35720: PPUSH
35721: LD_STRING DA1-Sol1-1a
35723: PPUSH
35724: CALL_OW 91
35728: GO 35742
// ForceSay ( unit , DA1-FSol1-1a ) ;
35730: LD_VAR 0 1
35734: PPUSH
35735: LD_STRING DA1-FSol1-1a
35737: PPUSH
35738: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35742: LD_VAR 0 1
35746: PUSH
35747: LD_EXP 40
35751: EQUAL
35752: IFFALSE 35763
// begin YouLost ( JMMCaptured ) ;
35754: LD_STRING JMMCaptured
35756: PPUSH
35757: CALL_OW 104
// exit ;
35761: GO 36061
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35763: LD_VAR 0 1
35767: PUSH
35768: LD_EXP 44
35772: PUSH
35773: LD_EXP 47
35777: PUSH
35778: LD_EXP 45
35782: PUSH
35783: LD_EXP 42
35787: PUSH
35788: LD_EXP 56
35792: PUSH
35793: LD_EXP 48
35797: PUSH
35798: LD_EXP 54
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: IN
35812: PUSH
35813: LD_VAR 0 3
35817: OR
35818: IFFALSE 35917
// begin Say ( Roth , DA-Roth-3 ) ;
35820: LD_EXP 78
35824: PPUSH
35825: LD_STRING DA-Roth-3
35827: PPUSH
35828: CALL_OW 88
// SetSide ( unit , 7 ) ;
35832: LD_VAR 0 1
35836: PPUSH
35837: LD_INT 7
35839: PPUSH
35840: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35844: LD_ADDR_EXP 101
35848: PUSH
35849: LD_EXP 101
35853: PPUSH
35854: LD_INT 1
35856: PPUSH
35857: LD_EXP 101
35861: PUSH
35862: LD_INT 1
35864: ARRAY
35865: PUSH
35866: LD_VAR 0 1
35870: ADD
35871: PPUSH
35872: CALL_OW 1
35876: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35877: LD_INT 260
35879: PPUSH
35880: LD_INT 235
35882: PPUSH
35883: LD_INT 1
35885: PPUSH
35886: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35890: LD_VAR 0 1
35894: PPUSH
35895: LD_INT 1000
35897: PPUSH
35898: CALL_OW 234
// DialogueOff ;
35902: CALL_OW 7
// ComFree ( unit ) ;
35906: LD_VAR 0 1
35910: PPUSH
35911: CALL_OW 139
// end else
35915: GO 35998
// begin Say ( Roth , DA-Roth-3a ) ;
35917: LD_EXP 78
35921: PPUSH
35922: LD_STRING DA-Roth-3a
35924: PPUSH
35925: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35929: LD_ADDR_EXP 35
35933: PUSH
35934: LD_EXP 35
35938: PUSH
35939: LD_VAR 0 1
35943: ADD
35944: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35945: LD_INT 260
35947: PPUSH
35948: LD_INT 235
35950: PPUSH
35951: LD_INT 1
35953: PPUSH
35954: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35958: LD_VAR 0 1
35962: PPUSH
35963: LD_INT 1000
35965: PPUSH
35966: CALL_OW 234
// DialogueOff ;
35970: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35974: LD_VAR 0 1
35978: PPUSH
35979: LD_INT 272
35981: PPUSH
35982: LD_INT 254
35984: PPUSH
35985: CALL_OW 111
// AddComHold ( unit ) ;
35989: LD_VAR 0 1
35993: PPUSH
35994: CALL_OW 200
// end ; if capturedUnit = 1 then
35998: LD_EXP 34
36002: PUSH
36003: LD_INT 1
36005: EQUAL
36006: IFFALSE 36061
// begin DialogueOn ;
36008: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36012: LD_EXP 40
36016: PPUSH
36017: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36021: LD_EXP 40
36025: PPUSH
36026: LD_STRING DAa-JMM-1
36028: PPUSH
36029: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36033: LD_EXP 40
36037: PPUSH
36038: LD_STRING DAa-JMM-1a
36040: PPUSH
36041: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36045: LD_EXP 40
36049: PPUSH
36050: LD_STRING DAa-JMM-1b
36052: PPUSH
36053: CALL_OW 88
// DialogueOff ;
36057: CALL_OW 7
// end ; end ;
36061: LD_VAR 0 2
36065: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36066: LD_EXP 15
36070: PUSH
36071: LD_INT 13
36073: GREATEREQUAL
36074: PUSH
36075: LD_INT 22
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 21
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PPUSH
36099: CALL_OW 69
36103: PUSH
36104: LD_INT 0
36106: EQUAL
36107: AND
36108: PUSH
36109: LD_INT 22
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 33
36121: PUSH
36122: LD_INT 5
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 21
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 50
36141: PUSH
36142: EMPTY
36143: LIST
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: PPUSH
36151: CALL_OW 69
36155: PUSH
36156: LD_INT 0
36158: EQUAL
36159: AND
36160: PUSH
36161: LD_EXP 21
36165: AND
36166: PUSH
36167: LD_EXP 22
36171: AND
36172: PUSH
36173: LD_EXP 23
36177: AND
36178: IFFALSE 36945
36180: GO 36182
36182: DISABLE
36183: LD_INT 0
36185: PPUSH
36186: PPUSH
36187: PPUSH
// begin wait ( 0 0$05 ) ;
36188: LD_INT 175
36190: PPUSH
36191: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) = 1 then
36195: LD_INT 22
36197: PUSH
36198: LD_INT 1
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 21
36207: PUSH
36208: LD_INT 1
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 23
36217: PUSH
36218: LD_INT 1
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 50
36227: PUSH
36228: EMPTY
36229: LIST
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: PPUSH
36237: CALL_OW 69
36241: PPUSH
36242: CALL 71544 0 1
36246: PUSH
36247: LD_INT 1
36249: EQUAL
36250: IFFALSE 36259
// YouLost ( LostVictory ) ;
36252: LD_STRING LostVictory
36254: PPUSH
36255: CALL_OW 104
// m1 := false ;
36259: LD_ADDR_VAR 0 1
36263: PUSH
36264: LD_INT 0
36266: ST_TO_ADDR
// m2 := false ;
36267: LD_ADDR_VAR 0 2
36271: PUSH
36272: LD_INT 0
36274: ST_TO_ADDR
// m3 := false ;
36275: LD_ADDR_VAR 0 3
36279: PUSH
36280: LD_INT 0
36282: ST_TO_ADDR
// if not bombExploded then
36283: LD_EXP 37
36287: NOT
36288: IFFALSE 36297
// SetAchievement ( ACH_SIBROCKET ) ;
36290: LD_STRING ACH_SIBROCKET
36292: PPUSH
36293: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36297: LD_EXP 65
36301: PPUSH
36302: CALL_OW 255
36306: PUSH
36307: LD_INT 1
36309: EQUAL
36310: PUSH
36311: LD_EXP 65
36315: PPUSH
36316: CALL_OW 302
36320: AND
36321: IFFALSE 36337
// begin wait ( 3 ) ;
36323: LD_INT 3
36325: PPUSH
36326: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36330: LD_STRING ACH_OPO
36332: PPUSH
36333: CALL_OW 543
// end ; if tick <= 120 120$00 then
36337: LD_OWVAR 1
36341: PUSH
36342: LD_INT 252000
36344: LESSEQUAL
36345: IFFALSE 36361
// begin wait ( 3 ) ;
36347: LD_INT 3
36349: PPUSH
36350: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36354: LD_STRING ACH_ASPEED_15
36356: PPUSH
36357: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36361: LD_EXP 40
36365: PPUSH
36366: CALL_OW 87
// music_class := 5 ;
36370: LD_ADDR_OWVAR 72
36374: PUSH
36375: LD_INT 5
36377: ST_TO_ADDR
// music_nat := 5 ;
36378: LD_ADDR_OWVAR 71
36382: PUSH
36383: LD_INT 5
36385: ST_TO_ADDR
// DialogueOn ;
36386: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36390: LD_EXP 40
36394: PPUSH
36395: LD_STRING D20-JMM-1
36397: PPUSH
36398: CALL_OW 88
// if IsOK ( Joan ) then
36402: LD_EXP 41
36406: PPUSH
36407: CALL_OW 302
36411: IFFALSE 36425
// Say ( Joan , D20-Joan-1 ) ;
36413: LD_EXP 41
36417: PPUSH
36418: LD_STRING D20-Joan-1
36420: PPUSH
36421: CALL_OW 88
// if IsOk ( Lisa ) then
36425: LD_EXP 43
36429: PPUSH
36430: CALL_OW 302
36434: IFFALSE 36448
// Say ( Lisa , D20-Lisa-1 ) ;
36436: LD_EXP 43
36440: PPUSH
36441: LD_STRING D20-Lisa-1
36443: PPUSH
36444: CALL_OW 88
// if IsOk ( Donaldson ) then
36448: LD_EXP 44
36452: PPUSH
36453: CALL_OW 302
36457: IFFALSE 36471
// Say ( Donaldson , D20-Don-1 ) ;
36459: LD_EXP 44
36463: PPUSH
36464: LD_STRING D20-Don-1
36466: PPUSH
36467: CALL_OW 88
// if IsOK ( Cornel ) then
36471: LD_EXP 51
36475: PPUSH
36476: CALL_OW 302
36480: IFFALSE 36494
// Say ( Cornel , D20-Corn-1 ) ;
36482: LD_EXP 51
36486: PPUSH
36487: LD_STRING D20-Corn-1
36489: PPUSH
36490: CALL_OW 88
// if IsOk ( Denis ) then
36494: LD_EXP 47
36498: PPUSH
36499: CALL_OW 302
36503: IFFALSE 36517
// Say ( Denis , D20-Den-1 ) ;
36505: LD_EXP 47
36509: PPUSH
36510: LD_STRING D20-Den-1
36512: PPUSH
36513: CALL_OW 88
// if IsOk ( Bobby ) then
36517: LD_EXP 45
36521: PPUSH
36522: CALL_OW 302
36526: IFFALSE 36540
// Say ( Bobby , D20-Bobby-1 ) ;
36528: LD_EXP 45
36532: PPUSH
36533: LD_STRING D20-Bobby-1
36535: PPUSH
36536: CALL_OW 88
// if IsOk ( Gladstone ) then
36540: LD_EXP 49
36544: PPUSH
36545: CALL_OW 302
36549: IFFALSE 36563
// Say ( Gladstone , D20-Glad-1 ) ;
36551: LD_EXP 49
36555: PPUSH
36556: LD_STRING D20-Glad-1
36558: PPUSH
36559: CALL_OW 88
// if IsOk ( Cyrus ) then
36563: LD_EXP 46
36567: PPUSH
36568: CALL_OW 302
36572: IFFALSE 36586
// Say ( Cyrus , D20-Cyrus-1 ) ;
36574: LD_EXP 46
36578: PPUSH
36579: LD_STRING D20-Cyrus-1
36581: PPUSH
36582: CALL_OW 88
// if IsOk ( Stevens ) then
36586: LD_EXP 42
36590: PPUSH
36591: CALL_OW 302
36595: IFFALSE 36609
// Say ( Stevens , D20-Huck-1 ) ;
36597: LD_EXP 42
36601: PPUSH
36602: LD_STRING D20-Huck-1
36604: PPUSH
36605: CALL_OW 88
// if IsOk ( Brown ) then
36609: LD_EXP 48
36613: PPUSH
36614: CALL_OW 302
36618: IFFALSE 36632
// Say ( Brown , D20-Brown-1 ) ;
36620: LD_EXP 48
36624: PPUSH
36625: LD_STRING D20-Brown-1
36627: PPUSH
36628: CALL_OW 88
// if IsOk ( Gary ) then
36632: LD_EXP 52
36636: PPUSH
36637: CALL_OW 302
36641: IFFALSE 36655
// Say ( Gary , D20-Gary-1 ) ;
36643: LD_EXP 52
36647: PPUSH
36648: LD_STRING D20-Gary-1
36650: PPUSH
36651: CALL_OW 88
// if IsOk ( Connie ) then
36655: LD_EXP 55
36659: PPUSH
36660: CALL_OW 302
36664: IFFALSE 36678
// Say ( Connie , D20-Con-1 ) ;
36666: LD_EXP 55
36670: PPUSH
36671: LD_STRING D20-Con-1
36673: PPUSH
36674: CALL_OW 88
// if IsOk ( Kurt ) then
36678: LD_EXP 63
36682: PPUSH
36683: CALL_OW 302
36687: IFFALSE 36701
// Say ( Kurt , D20-Kurt-1 ) ;
36689: LD_EXP 63
36693: PPUSH
36694: LD_STRING D20-Kurt-1
36696: PPUSH
36697: CALL_OW 88
// if IsOk ( Kikuchi ) then
36701: LD_EXP 54
36705: PPUSH
36706: CALL_OW 302
36710: IFFALSE 36724
// Say ( Kikuchi , D20-Yam-1 ) ;
36712: LD_EXP 54
36716: PPUSH
36717: LD_STRING D20-Yam-1
36719: PPUSH
36720: CALL_OW 88
// if IsOk ( Frank ) then
36724: LD_EXP 53
36728: PPUSH
36729: CALL_OW 302
36733: IFFALSE 36747
// Say ( Frank , D20-Frank-1 ) ;
36735: LD_EXP 53
36739: PPUSH
36740: LD_STRING D20-Frank-1
36742: PPUSH
36743: CALL_OW 88
// DialogueOff ;
36747: CALL_OW 7
// if RothCaptured then
36751: LD_EXP 33
36755: IFFALSE 36777
// begin m1 := true ;
36757: LD_ADDR_VAR 0 1
36761: PUSH
36762: LD_INT 1
36764: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36765: LD_STRING Roth
36767: PPUSH
36768: LD_INT 1
36770: PPUSH
36771: CALL_OW 101
// end else
36775: GO 36788
// AddMedal ( Roth , - 1 ) ;
36777: LD_STRING Roth
36779: PPUSH
36780: LD_INT 1
36782: NEG
36783: PPUSH
36784: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36788: LD_EXP 25
36792: NOT
36793: PUSH
36794: LD_EXP 27
36798: OR
36799: PUSH
36800: LD_EXP 28
36804: NOT
36805: OR
36806: IFFALSE 36828
// begin m2 := true ;
36808: LD_ADDR_VAR 0 2
36812: PUSH
36813: LD_INT 1
36815: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36816: LD_STRING Project
36818: PPUSH
36819: LD_INT 1
36821: PPUSH
36822: CALL_OW 101
// end else
36826: GO 36839
// AddMedal ( Project , - 1 ) ;
36828: LD_STRING Project
36830: PPUSH
36831: LD_INT 1
36833: NEG
36834: PPUSH
36835: CALL_OW 101
// if lostCounter = 0 then
36839: LD_EXP 32
36843: PUSH
36844: LD_INT 0
36846: EQUAL
36847: IFFALSE 36869
// begin m3 := true ;
36849: LD_ADDR_VAR 0 3
36853: PUSH
36854: LD_INT 1
36856: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36857: LD_STRING NoLosses
36859: PPUSH
36860: LD_INT 1
36862: PPUSH
36863: CALL_OW 101
// end else
36867: GO 36880
// AddMedal ( NoLosses , - 1 ) ;
36869: LD_STRING NoLosses
36871: PPUSH
36872: LD_INT 1
36874: NEG
36875: PPUSH
36876: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36880: LD_VAR 0 1
36884: PUSH
36885: LD_VAR 0 2
36889: AND
36890: PUSH
36891: LD_VAR 0 3
36895: AND
36896: PUSH
36897: LD_OWVAR 67
36901: PUSH
36902: LD_INT 3
36904: GREATEREQUAL
36905: AND
36906: IFFALSE 36918
// SetAchievementEX ( ACH_AMER , 15 ) ;
36908: LD_STRING ACH_AMER
36910: PPUSH
36911: LD_INT 15
36913: PPUSH
36914: CALL_OW 564
// GiveMedals ( MAIN ) ;
36918: LD_STRING MAIN
36920: PPUSH
36921: CALL_OW 102
// music_class := 4 ;
36925: LD_ADDR_OWVAR 72
36929: PUSH
36930: LD_INT 4
36932: ST_TO_ADDR
// music_nat := 1 ;
36933: LD_ADDR_OWVAR 71
36937: PUSH
36938: LD_INT 1
36940: ST_TO_ADDR
// YouWin ;
36941: CALL_OW 103
// end ; end_of_file
36945: PPOPN 3
36947: END
// export function CustomEvent ( event ) ; begin
36948: LD_INT 0
36950: PPUSH
// end ;
36951: LD_VAR 0 2
36955: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36956: LD_VAR 0 1
36960: PUSH
36961: LD_INT 1
36963: EQUAL
36964: PUSH
36965: LD_VAR 0 2
36969: PUSH
36970: LD_INT 4
36972: EQUAL
36973: AND
36974: PUSH
36975: LD_EXP 60
36979: PPUSH
36980: CALL_OW 300
36984: AND
36985: IFFALSE 37001
// begin wait ( 0 0$2 ) ;
36987: LD_INT 70
36989: PPUSH
36990: CALL_OW 67
// YouLost ( Dismissed ) ;
36994: LD_STRING Dismissed
36996: PPUSH
36997: CALL_OW 104
// end ; end ;
37001: PPOPN 2
37003: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37004: LD_VAR 0 2
37008: PPUSH
37009: LD_VAR 0 3
37013: PPUSH
37014: LD_INT 18
37016: PPUSH
37017: CALL_OW 309
37021: IFFALSE 37030
// YouLost ( Motherlode3 ) ;
37023: LD_STRING Motherlode3
37025: PPUSH
37026: CALL_OW 104
// end ;
37030: PPOPN 3
37032: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37033: LD_EXP 27
37037: NOT
37038: IFFALSE 37048
// behemothDone := true ;
37040: LD_ADDR_EXP 28
37044: PUSH
37045: LD_INT 1
37047: ST_TO_ADDR
// end ;
37048: PPOPN 1
37050: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37051: LD_VAR 0 1
37055: PPUSH
37056: CALL_OW 255
37060: PUSH
37061: LD_INT 1
37063: EQUAL
37064: IFFALSE 37074
// bombExploded := true ;
37066: LD_ADDR_EXP 37
37070: PUSH
37071: LD_INT 1
37073: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37074: LD_VAR 0 1
37078: PPUSH
37079: CALL_OW 255
37083: PUSH
37084: LD_INT 3
37086: EQUAL
37087: IFFALSE 37117
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37089: LD_INT 2
37091: PPUSH
37092: LD_INT 23
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: LD_INT 3
37100: PUSH
37101: LD_INT 48
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: LIST
37108: LIST
37109: PUSH
37110: EMPTY
37111: LIST
37112: PPUSH
37113: CALL 63016 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37117: LD_VAR 0 1
37121: PPUSH
37122: CALL_OW 255
37126: PUSH
37127: LD_INT 1
37129: EQUAL
37130: PUSH
37131: LD_EXP 65
37135: PPUSH
37136: CALL_OW 255
37140: PUSH
37141: LD_INT 1
37143: EQUAL
37144: AND
37145: PUSH
37146: LD_EXP 65
37150: PPUSH
37151: CALL_OW 302
37155: AND
37156: PUSH
37157: LD_EXP 30
37161: AND
37162: PUSH
37163: LD_INT 22
37165: PUSH
37166: LD_INT 3
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 34
37175: PUSH
37176: LD_INT 48
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PPUSH
37187: CALL_OW 69
37191: AND
37192: PUSH
37193: LD_INT 22
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 34
37205: PUSH
37206: LD_INT 8
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PPUSH
37217: CALL_OW 69
37221: NOT
37222: AND
37223: IFFALSE 37275
// begin wait ( 0 0$5 ) ;
37225: LD_INT 175
37227: PPUSH
37228: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37232: LD_INT 22
37234: PUSH
37235: LD_INT 3
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 34
37244: PUSH
37245: LD_INT 48
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PPUSH
37256: CALL_OW 69
37260: PUSH
37261: LD_INT 1
37263: ARRAY
37264: PPUSH
37265: LD_INT 60
37267: PPUSH
37268: LD_INT 95
37270: PPUSH
37271: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37275: LD_VAR 0 2
37279: PPUSH
37280: LD_VAR 0 3
37284: PPUSH
37285: LD_INT 18
37287: PPUSH
37288: CALL_OW 309
37292: PUSH
37293: LD_VAR 0 2
37297: PPUSH
37298: LD_VAR 0 3
37302: PPUSH
37303: LD_INT 18
37305: PPUSH
37306: CALL 110953 0 3
37310: OR
37311: IFFALSE 37358
// begin if GetSide ( unit ) = 1 then
37313: LD_VAR 0 1
37317: PPUSH
37318: CALL_OW 255
37322: PUSH
37323: LD_INT 1
37325: EQUAL
37326: IFFALSE 37344
// begin wait ( 0 0$6 ) ;
37328: LD_INT 210
37330: PPUSH
37331: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37335: LD_STRING Motherlode2
37337: PPUSH
37338: CALL_OW 104
// end else
37342: GO 37358
// begin wait ( 0 0$6 ) ;
37344: LD_INT 210
37346: PPUSH
37347: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37351: LD_STRING Motherlode1
37353: PPUSH
37354: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37358: LD_VAR 0 1
37362: PPUSH
37363: CALL_OW 255
37367: PUSH
37368: LD_INT 3
37370: EQUAL
37371: IFFALSE 37392
// begin wait ( 0 0$5 ) ;
37373: LD_INT 175
37375: PPUSH
37376: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37380: LD_EXP 67
37384: PPUSH
37385: LD_STRING D18-Pla-1
37387: PPUSH
37388: CALL_OW 94
// end ; end ;
37392: PPOPN 3
37394: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37395: LD_VAR 0 1
37399: PPUSH
37400: CALL 127476 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37404: LD_VAR 0 1
37408: PUSH
37409: LD_INT 22
37411: PUSH
37412: LD_INT 1
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 21
37421: PUSH
37422: LD_INT 1
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 23
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: LIST
37443: PPUSH
37444: CALL_OW 69
37448: IN
37449: IFFALSE 37465
// lostCounter := lostCounter + 1 ;
37451: LD_ADDR_EXP 32
37455: PUSH
37456: LD_EXP 32
37460: PUSH
37461: LD_INT 1
37463: PLUS
37464: ST_TO_ADDR
// if un in behemothBuilders then
37465: LD_VAR 0 1
37469: PUSH
37470: LD_EXP 76
37474: IN
37475: IFFALSE 37495
// begin behemothBuilders := behemothBuilders diff un ;
37477: LD_ADDR_EXP 76
37481: PUSH
37482: LD_EXP 76
37486: PUSH
37487: LD_VAR 0 1
37491: DIFF
37492: ST_TO_ADDR
// exit ;
37493: GO 37525
// end ; if un = JMM then
37495: LD_VAR 0 1
37499: PUSH
37500: LD_EXP 40
37504: EQUAL
37505: IFFALSE 37516
// begin YouLost ( JMM ) ;
37507: LD_STRING JMM
37509: PPUSH
37510: CALL_OW 104
// exit ;
37514: GO 37525
// end ; MCE_UnitDestroyed ( un ) ;
37516: LD_VAR 0 1
37520: PPUSH
37521: CALL 66458 0 1
// end ;
37525: PPOPN 1
37527: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37528: LD_VAR 0 1
37532: PPUSH
37533: LD_VAR 0 2
37537: PPUSH
37538: CALL 68790 0 2
// end ;
37542: PPOPN 2
37544: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37545: LD_VAR 0 1
37549: PPUSH
37550: CALL 67858 0 1
// end ;
37554: PPOPN 1
37556: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37557: LD_VAR 0 1
37561: PUSH
37562: LD_INT 22
37564: PUSH
37565: LD_INT 8
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 30
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 23
37584: PUSH
37585: LD_INT 3
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: LIST
37596: PPUSH
37597: CALL_OW 69
37601: IN
37602: IFFALSE 37629
// begin ComUpgrade ( building ) ;
37604: LD_VAR 0 1
37608: PPUSH
37609: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37613: LD_EXP 64
37617: PPUSH
37618: LD_VAR 0 1
37622: PPUSH
37623: CALL 77642 0 2
// exit ;
37627: GO 37638
// end ; MCE_BuildingComplete ( building ) ;
37629: LD_VAR 0 1
37633: PPUSH
37634: CALL 68099 0 1
// end ;
37638: PPOPN 1
37640: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37641: LD_VAR 0 1
37645: PPUSH
37646: LD_VAR 0 2
37650: PPUSH
37651: CALL 66154 0 2
// end ;
37655: PPOPN 2
37657: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37658: LD_VAR 0 1
37662: PPUSH
37663: LD_VAR 0 2
37667: PPUSH
37668: LD_VAR 0 3
37672: PPUSH
37673: LD_VAR 0 4
37677: PPUSH
37678: LD_VAR 0 5
37682: PPUSH
37683: CALL 65774 0 5
// end ;
37687: PPOPN 5
37689: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37690: LD_VAR 0 1
37694: PPUSH
37695: CALL_OW 255
37699: PUSH
37700: LD_INT 1
37702: EQUAL
37703: IFFALSE 37720
// amConstructCounter := Inc ( amConstructCounter ) ;
37705: LD_ADDR_EXP 39
37709: PUSH
37710: LD_EXP 39
37714: PPUSH
37715: CALL 108505 0 1
37719: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37720: LD_VAR 0 1
37724: PPUSH
37725: LD_VAR 0 2
37729: PPUSH
37730: CALL 127596 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37734: LD_VAR 0 1
37738: PPUSH
37739: LD_VAR 0 2
37743: PPUSH
37744: CALL 65327 0 2
// end ;
37748: PPOPN 2
37750: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37751: LD_VAR 0 1
37755: PPUSH
37756: LD_VAR 0 2
37760: PPUSH
37761: LD_VAR 0 3
37765: PPUSH
37766: LD_VAR 0 4
37770: PPUSH
37771: CALL 65165 0 4
// end ;
37775: PPOPN 4
37777: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37778: LD_VAR 0 1
37782: PPUSH
37783: LD_VAR 0 2
37787: PPUSH
37788: LD_VAR 0 3
37792: PPUSH
37793: CALL 64940 0 3
// end ;
37797: PPOPN 3
37799: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37800: LD_VAR 0 1
37804: PPUSH
37805: LD_VAR 0 2
37809: PPUSH
37810: CALL 64825 0 2
// end ;
37814: PPOPN 2
37816: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37817: LD_VAR 0 1
37821: PPUSH
37822: LD_VAR 0 2
37826: PPUSH
37827: CALL 69085 0 2
// end ;
37831: PPOPN 2
37833: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37834: LD_VAR 0 1
37838: PUSH
37839: LD_INT 460
37841: EQUAL
37842: IFFALSE 37864
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37844: LD_VAR 0 2
37848: PPUSH
37849: LD_INT 227
37851: PPUSH
37852: LD_INT 136
37854: PPUSH
37855: CALL_OW 428
37859: PPUSH
37860: CALL_OW 120
// end ;
37864: PPOPN 2
37866: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37867: LD_VAR 0 1
37871: PPUSH
37872: CALL_OW 255
37876: PUSH
37877: LD_INT 4
37879: EQUAL
37880: PUSH
37881: LD_VAR 0 1
37885: PUSH
37886: LD_EXP 18
37890: PUSH
37891: LD_INT 1
37893: ARRAY
37894: IN
37895: AND
37896: PUSH
37897: LD_EXP 19
37901: AND
37902: IFFALSE 37921
// begin ComMoveXY ( driver , 61 , 93 ) ;
37904: LD_VAR 0 1
37908: PPUSH
37909: LD_INT 61
37911: PPUSH
37912: LD_INT 93
37914: PPUSH
37915: CALL_OW 111
// exit ;
37919: GO 37990
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
37921: LD_VAR 0 1
37925: PPUSH
37926: CALL_OW 255
37930: PUSH
37931: LD_INT 3
37933: EQUAL
37934: PUSH
37935: LD_VAR 0 1
37939: PPUSH
37940: CALL_OW 110
37944: PUSH
37945: LD_INT 105
37947: EQUAL
37948: AND
37949: IFFALSE 37966
// begin ComMoveXY ( driver , 187 , 92 ) ;
37951: LD_VAR 0 1
37955: PPUSH
37956: LD_INT 187
37958: PPUSH
37959: LD_INT 92
37961: PPUSH
37962: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37966: LD_VAR 0 1
37970: PPUSH
37971: LD_VAR 0 2
37975: PPUSH
37976: LD_VAR 0 3
37980: PPUSH
37981: LD_VAR 0 4
37985: PPUSH
37986: CALL 69301 0 4
// end ;
37990: PPOPN 4
37992: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37993: LD_VAR 0 1
37997: PPUSH
37998: LD_VAR 0 2
38002: PPUSH
38003: CALL 64634 0 2
// end ;
38007: PPOPN 2
38009: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38010: LD_VAR 0 1
38014: PPUSH
38015: CALL 127580 0 1
// end ; end_of_file
38019: PPOPN 1
38021: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38022: LD_EXP 15
38026: PUSH
38027: LD_INT 2
38029: EQUAL
38030: IFFALSE 38547
38032: GO 38034
38034: DISABLE
38035: LD_INT 0
38037: PPUSH
38038: PPUSH
// begin time := 0 0$35 ;
38039: LD_ADDR_VAR 0 2
38043: PUSH
38044: LD_INT 1225
38046: ST_TO_ADDR
// repeat wait ( time ) ;
38047: LD_VAR 0 2
38051: PPUSH
38052: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38056: LD_INT 1
38058: PPUSH
38059: LD_INT 5
38061: PPUSH
38062: CALL_OW 12
38066: PPUSH
38067: LD_INT 106
38069: PPUSH
38070: LD_INT 150
38072: PPUSH
38073: LD_INT 19
38075: PPUSH
38076: LD_INT 1
38078: PPUSH
38079: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38083: LD_INT 455
38085: PPUSH
38086: LD_INT 770
38088: PPUSH
38089: CALL_OW 12
38093: PPUSH
38094: CALL_OW 67
// if Prob ( 50 ) then
38098: LD_INT 50
38100: PPUSH
38101: CALL_OW 13
38105: IFFALSE 38134
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38107: LD_INT 1
38109: PPUSH
38110: LD_INT 5
38112: PPUSH
38113: CALL_OW 12
38117: PPUSH
38118: LD_INT 62
38120: PPUSH
38121: LD_INT 108
38123: PPUSH
38124: LD_INT 10
38126: PPUSH
38127: LD_INT 1
38129: PPUSH
38130: CALL_OW 56
// until missionStage > 4 ;
38134: LD_EXP 15
38138: PUSH
38139: LD_INT 4
38141: GREATER
38142: IFFALSE 38047
// repeat wait ( 0 0$1 ) ;
38144: LD_INT 35
38146: PPUSH
38147: CALL_OW 67
// until missionStage = 6 ;
38151: LD_EXP 15
38155: PUSH
38156: LD_INT 6
38158: EQUAL
38159: IFFALSE 38144
// time := 0 0$20 ;
38161: LD_ADDR_VAR 0 2
38165: PUSH
38166: LD_INT 700
38168: ST_TO_ADDR
// repeat wait ( time ) ;
38169: LD_VAR 0 2
38173: PPUSH
38174: CALL_OW 67
// if Prob ( 90 ) then
38178: LD_INT 90
38180: PPUSH
38181: CALL_OW 13
38185: IFFALSE 38228
// begin time := time + 0 0$2 ;
38187: LD_ADDR_VAR 0 2
38191: PUSH
38192: LD_VAR 0 2
38196: PUSH
38197: LD_INT 70
38199: PLUS
38200: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38201: LD_INT 1
38203: PPUSH
38204: LD_INT 5
38206: PPUSH
38207: CALL_OW 12
38211: PPUSH
38212: LD_INT 106
38214: PPUSH
38215: LD_INT 89
38217: PPUSH
38218: LD_INT 45
38220: PPUSH
38221: LD_INT 1
38223: PPUSH
38224: CALL_OW 56
// end ; if Prob ( 45 ) then
38228: LD_INT 45
38230: PPUSH
38231: CALL_OW 13
38235: IFFALSE 38291
// begin for i := 1 to 4 do
38237: LD_ADDR_VAR 0 1
38241: PUSH
38242: DOUBLE
38243: LD_INT 1
38245: DEC
38246: ST_TO_ADDR
38247: LD_INT 4
38249: PUSH
38250: FOR_TO
38251: IFFALSE 38289
// begin wait ( 0 0$5 ) ;
38253: LD_INT 175
38255: PPUSH
38256: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38260: LD_INT 1
38262: PPUSH
38263: LD_INT 5
38265: PPUSH
38266: CALL_OW 12
38270: PPUSH
38271: LD_INT 113
38273: PPUSH
38274: LD_INT 117
38276: PPUSH
38277: LD_INT 25
38279: PPUSH
38280: LD_INT 1
38282: PPUSH
38283: CALL_OW 56
// end ;
38287: GO 38250
38289: POP
38290: POP
// end ; if Prob ( 40 ) then
38291: LD_INT 40
38293: PPUSH
38294: CALL_OW 13
38298: IFFALSE 38344
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38300: LD_INT 385
38302: PPUSH
38303: LD_INT 945
38305: PPUSH
38306: CALL_OW 12
38310: PPUSH
38311: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38315: LD_INT 1
38317: PPUSH
38318: LD_INT 5
38320: PPUSH
38321: CALL_OW 12
38325: PPUSH
38326: LD_INT 21
38328: PPUSH
38329: LD_INT 26
38331: PPUSH
38332: LD_INT 12
38334: PPUSH
38335: LD_INT 1
38337: PPUSH
38338: CALL_OW 56
// end else
38342: GO 38380
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38344: LD_INT 700
38346: PPUSH
38347: LD_INT 1225
38349: PPUSH
38350: CALL_OW 12
38354: PPUSH
38355: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38359: LD_INT 1
38361: PPUSH
38362: LD_INT 5
38364: PPUSH
38365: CALL_OW 12
38369: PPUSH
38370: LD_INT 16
38372: PPUSH
38373: LD_INT 1
38375: PPUSH
38376: CALL_OW 55
// end ; if Prob ( 50 ) then
38380: LD_INT 50
38382: PPUSH
38383: CALL_OW 13
38387: IFFALSE 38433
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38389: LD_INT 700
38391: PPUSH
38392: LD_INT 1050
38394: PPUSH
38395: CALL_OW 12
38399: PPUSH
38400: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38404: LD_INT 1
38406: PPUSH
38407: LD_INT 5
38409: PPUSH
38410: CALL_OW 12
38414: PPUSH
38415: LD_INT 168
38417: PPUSH
38418: LD_INT 168
38420: PPUSH
38421: LD_INT 16
38423: PPUSH
38424: LD_INT 1
38426: PPUSH
38427: CALL_OW 56
// end else
38431: GO 38469
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38433: LD_INT 350
38435: PPUSH
38436: LD_INT 525
38438: PPUSH
38439: CALL_OW 12
38443: PPUSH
38444: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38448: LD_INT 1
38450: PPUSH
38451: LD_INT 5
38453: PPUSH
38454: CALL_OW 12
38458: PPUSH
38459: LD_INT 15
38461: PPUSH
38462: LD_INT 1
38464: PPUSH
38465: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38469: LD_INT 175
38471: PPUSH
38472: LD_INT 315
38474: PPUSH
38475: CALL_OW 12
38479: PPUSH
38480: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38484: LD_INT 1
38486: PPUSH
38487: LD_INT 5
38489: PPUSH
38490: CALL_OW 12
38494: PPUSH
38495: LD_INT 103
38497: PPUSH
38498: LD_INT 140
38500: PPUSH
38501: LD_INT 20
38503: PPUSH
38504: LD_INT 1
38506: PPUSH
38507: CALL_OW 56
// time := time + 0 0$2 ;
38511: LD_ADDR_VAR 0 2
38515: PUSH
38516: LD_VAR 0 2
38520: PUSH
38521: LD_INT 70
38523: PLUS
38524: ST_TO_ADDR
// if time > 1 1$20 then
38525: LD_VAR 0 2
38529: PUSH
38530: LD_INT 2800
38532: GREATER
38533: IFFALSE 38543
// time := 0 0$30 ;
38535: LD_ADDR_VAR 0 2
38539: PUSH
38540: LD_INT 1050
38542: ST_TO_ADDR
// until false ;
38543: LD_INT 0
38545: IFFALSE 38169
// end ; end_of_file
38547: PPOPN 2
38549: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38550: LD_EXP 13
38554: PUSH
38555: LD_EXP 15
38559: PUSH
38560: LD_INT 6
38562: GREATEREQUAL
38563: AND
38564: IFFALSE 38601
38566: GO 38568
38568: DISABLE
// begin enable ;
38569: ENABLE
// missionTime := missionTime + 0 0$1 ;
38570: LD_ADDR_EXP 14
38574: PUSH
38575: LD_EXP 14
38579: PUSH
38580: LD_INT 35
38582: PLUS
38583: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38584: LD_ADDR_OWVAR 47
38588: PUSH
38589: LD_STRING #Am15-1
38591: PUSH
38592: LD_EXP 14
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: ST_TO_ADDR
// end ; end_of_file
38601: END
// export function InitNature ; begin
38602: LD_INT 0
38604: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38605: LD_INT 3
38607: PPUSH
38608: LD_INT 3
38610: PPUSH
38611: LD_INT 2
38613: PPUSH
38614: LD_INT 1
38616: PPUSH
38617: LD_INT 1
38619: PPUSH
38620: LD_INT 0
38622: PPUSH
38623: LD_INT 0
38625: PPUSH
38626: LD_INT 20
38628: PPUSH
38629: LD_INT 0
38631: PPUSH
38632: CALL 103821 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38636: LD_INT 2
38638: PPUSH
38639: LD_INT 1
38641: PPUSH
38642: LD_INT 1
38644: PPUSH
38645: LD_INT 1
38647: PPUSH
38648: LD_INT 1
38650: PPUSH
38651: LD_INT 0
38653: PPUSH
38654: LD_INT 0
38656: PPUSH
38657: LD_INT 21
38659: PPUSH
38660: LD_INT 0
38662: PPUSH
38663: CALL 103821 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38667: LD_INT 4
38669: PPUSH
38670: LD_INT 1
38672: PPUSH
38673: LD_INT 2
38675: PPUSH
38676: LD_INT 4
38678: PPUSH
38679: LD_INT 2
38681: PPUSH
38682: LD_INT 1
38684: PPUSH
38685: LD_INT 0
38687: PPUSH
38688: LD_INT 22
38690: PPUSH
38691: LD_INT 0
38693: PPUSH
38694: CALL 103821 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38698: LD_INT 0
38700: PPUSH
38701: LD_INT 0
38703: PPUSH
38704: LD_INT 0
38706: PPUSH
38707: LD_INT 0
38709: PPUSH
38710: LD_INT 0
38712: PPUSH
38713: LD_INT 0
38715: PPUSH
38716: LD_INT 9
38718: PPUSH
38719: LD_INT 0
38721: PPUSH
38722: LD_INT 23
38724: PPUSH
38725: CALL 103821 0 9
// end ; end_of_file
38729: LD_VAR 0 1
38733: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38734: LD_INT 0
38736: PPUSH
38737: PPUSH
// skirmish := false ;
38738: LD_ADDR_EXP 99
38742: PUSH
38743: LD_INT 0
38745: ST_TO_ADDR
// debug_mc := false ;
38746: LD_ADDR_EXP 100
38750: PUSH
38751: LD_INT 0
38753: ST_TO_ADDR
// mc_bases := [ ] ;
38754: LD_ADDR_EXP 101
38758: PUSH
38759: EMPTY
38760: ST_TO_ADDR
// mc_sides := [ ] ;
38761: LD_ADDR_EXP 127
38765: PUSH
38766: EMPTY
38767: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38768: LD_ADDR_EXP 102
38772: PUSH
38773: EMPTY
38774: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38775: LD_ADDR_EXP 103
38779: PUSH
38780: EMPTY
38781: ST_TO_ADDR
// mc_need_heal := [ ] ;
38782: LD_ADDR_EXP 104
38786: PUSH
38787: EMPTY
38788: ST_TO_ADDR
// mc_healers := [ ] ;
38789: LD_ADDR_EXP 105
38793: PUSH
38794: EMPTY
38795: ST_TO_ADDR
// mc_build_list := [ ] ;
38796: LD_ADDR_EXP 106
38800: PUSH
38801: EMPTY
38802: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38803: LD_ADDR_EXP 133
38807: PUSH
38808: EMPTY
38809: ST_TO_ADDR
// mc_builders := [ ] ;
38810: LD_ADDR_EXP 107
38814: PUSH
38815: EMPTY
38816: ST_TO_ADDR
// mc_construct_list := [ ] ;
38817: LD_ADDR_EXP 108
38821: PUSH
38822: EMPTY
38823: ST_TO_ADDR
// mc_turret_list := [ ] ;
38824: LD_ADDR_EXP 109
38828: PUSH
38829: EMPTY
38830: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38831: LD_ADDR_EXP 110
38835: PUSH
38836: EMPTY
38837: ST_TO_ADDR
// mc_miners := [ ] ;
38838: LD_ADDR_EXP 115
38842: PUSH
38843: EMPTY
38844: ST_TO_ADDR
// mc_mines := [ ] ;
38845: LD_ADDR_EXP 114
38849: PUSH
38850: EMPTY
38851: ST_TO_ADDR
// mc_minefields := [ ] ;
38852: LD_ADDR_EXP 116
38856: PUSH
38857: EMPTY
38858: ST_TO_ADDR
// mc_crates := [ ] ;
38859: LD_ADDR_EXP 117
38863: PUSH
38864: EMPTY
38865: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38866: LD_ADDR_EXP 118
38870: PUSH
38871: EMPTY
38872: ST_TO_ADDR
// mc_crates_area := [ ] ;
38873: LD_ADDR_EXP 119
38877: PUSH
38878: EMPTY
38879: ST_TO_ADDR
// mc_vehicles := [ ] ;
38880: LD_ADDR_EXP 120
38884: PUSH
38885: EMPTY
38886: ST_TO_ADDR
// mc_attack := [ ] ;
38887: LD_ADDR_EXP 121
38891: PUSH
38892: EMPTY
38893: ST_TO_ADDR
// mc_produce := [ ] ;
38894: LD_ADDR_EXP 122
38898: PUSH
38899: EMPTY
38900: ST_TO_ADDR
// mc_defender := [ ] ;
38901: LD_ADDR_EXP 123
38905: PUSH
38906: EMPTY
38907: ST_TO_ADDR
// mc_parking := [ ] ;
38908: LD_ADDR_EXP 125
38912: PUSH
38913: EMPTY
38914: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38915: LD_ADDR_EXP 111
38919: PUSH
38920: EMPTY
38921: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38922: LD_ADDR_EXP 113
38926: PUSH
38927: EMPTY
38928: ST_TO_ADDR
// mc_scan := [ ] ;
38929: LD_ADDR_EXP 124
38933: PUSH
38934: EMPTY
38935: ST_TO_ADDR
// mc_scan_area := [ ] ;
38936: LD_ADDR_EXP 126
38940: PUSH
38941: EMPTY
38942: ST_TO_ADDR
// mc_tech := [ ] ;
38943: LD_ADDR_EXP 128
38947: PUSH
38948: EMPTY
38949: ST_TO_ADDR
// mc_class := [ ] ;
38950: LD_ADDR_EXP 142
38954: PUSH
38955: EMPTY
38956: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38957: LD_ADDR_EXP 143
38961: PUSH
38962: EMPTY
38963: ST_TO_ADDR
// mc_is_defending := [ ] ;
38964: LD_ADDR_EXP 144
38968: PUSH
38969: EMPTY
38970: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38971: LD_ADDR_EXP 135
38975: PUSH
38976: EMPTY
38977: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38978: LD_ADDR_EXP 145
38982: PUSH
38983: LD_INT 0
38985: ST_TO_ADDR
// end ;
38986: LD_VAR 0 1
38990: RET
// export function MC_Kill ( base ) ; begin
38991: LD_INT 0
38993: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38994: LD_ADDR_EXP 101
38998: PUSH
38999: LD_EXP 101
39003: PPUSH
39004: LD_VAR 0 1
39008: PPUSH
39009: EMPTY
39010: PPUSH
39011: CALL_OW 1
39015: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39016: LD_ADDR_EXP 102
39020: PUSH
39021: LD_EXP 102
39025: PPUSH
39026: LD_VAR 0 1
39030: PPUSH
39031: EMPTY
39032: PPUSH
39033: CALL_OW 1
39037: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39038: LD_ADDR_EXP 103
39042: PUSH
39043: LD_EXP 103
39047: PPUSH
39048: LD_VAR 0 1
39052: PPUSH
39053: EMPTY
39054: PPUSH
39055: CALL_OW 1
39059: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39060: LD_ADDR_EXP 104
39064: PUSH
39065: LD_EXP 104
39069: PPUSH
39070: LD_VAR 0 1
39074: PPUSH
39075: EMPTY
39076: PPUSH
39077: CALL_OW 1
39081: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39082: LD_ADDR_EXP 105
39086: PUSH
39087: LD_EXP 105
39091: PPUSH
39092: LD_VAR 0 1
39096: PPUSH
39097: EMPTY
39098: PPUSH
39099: CALL_OW 1
39103: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39104: LD_ADDR_EXP 106
39108: PUSH
39109: LD_EXP 106
39113: PPUSH
39114: LD_VAR 0 1
39118: PPUSH
39119: EMPTY
39120: PPUSH
39121: CALL_OW 1
39125: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39126: LD_ADDR_EXP 107
39130: PUSH
39131: LD_EXP 107
39135: PPUSH
39136: LD_VAR 0 1
39140: PPUSH
39141: EMPTY
39142: PPUSH
39143: CALL_OW 1
39147: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39148: LD_ADDR_EXP 108
39152: PUSH
39153: LD_EXP 108
39157: PPUSH
39158: LD_VAR 0 1
39162: PPUSH
39163: EMPTY
39164: PPUSH
39165: CALL_OW 1
39169: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39170: LD_ADDR_EXP 109
39174: PUSH
39175: LD_EXP 109
39179: PPUSH
39180: LD_VAR 0 1
39184: PPUSH
39185: EMPTY
39186: PPUSH
39187: CALL_OW 1
39191: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39192: LD_ADDR_EXP 110
39196: PUSH
39197: LD_EXP 110
39201: PPUSH
39202: LD_VAR 0 1
39206: PPUSH
39207: EMPTY
39208: PPUSH
39209: CALL_OW 1
39213: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39214: LD_ADDR_EXP 111
39218: PUSH
39219: LD_EXP 111
39223: PPUSH
39224: LD_VAR 0 1
39228: PPUSH
39229: EMPTY
39230: PPUSH
39231: CALL_OW 1
39235: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39236: LD_ADDR_EXP 112
39240: PUSH
39241: LD_EXP 112
39245: PPUSH
39246: LD_VAR 0 1
39250: PPUSH
39251: LD_INT 0
39253: PPUSH
39254: CALL_OW 1
39258: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39259: LD_ADDR_EXP 113
39263: PUSH
39264: LD_EXP 113
39268: PPUSH
39269: LD_VAR 0 1
39273: PPUSH
39274: EMPTY
39275: PPUSH
39276: CALL_OW 1
39280: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39281: LD_ADDR_EXP 114
39285: PUSH
39286: LD_EXP 114
39290: PPUSH
39291: LD_VAR 0 1
39295: PPUSH
39296: EMPTY
39297: PPUSH
39298: CALL_OW 1
39302: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39303: LD_ADDR_EXP 115
39307: PUSH
39308: LD_EXP 115
39312: PPUSH
39313: LD_VAR 0 1
39317: PPUSH
39318: EMPTY
39319: PPUSH
39320: CALL_OW 1
39324: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39325: LD_ADDR_EXP 116
39329: PUSH
39330: LD_EXP 116
39334: PPUSH
39335: LD_VAR 0 1
39339: PPUSH
39340: EMPTY
39341: PPUSH
39342: CALL_OW 1
39346: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39347: LD_ADDR_EXP 117
39351: PUSH
39352: LD_EXP 117
39356: PPUSH
39357: LD_VAR 0 1
39361: PPUSH
39362: EMPTY
39363: PPUSH
39364: CALL_OW 1
39368: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39369: LD_ADDR_EXP 118
39373: PUSH
39374: LD_EXP 118
39378: PPUSH
39379: LD_VAR 0 1
39383: PPUSH
39384: EMPTY
39385: PPUSH
39386: CALL_OW 1
39390: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39391: LD_ADDR_EXP 119
39395: PUSH
39396: LD_EXP 119
39400: PPUSH
39401: LD_VAR 0 1
39405: PPUSH
39406: EMPTY
39407: PPUSH
39408: CALL_OW 1
39412: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39413: LD_ADDR_EXP 120
39417: PUSH
39418: LD_EXP 120
39422: PPUSH
39423: LD_VAR 0 1
39427: PPUSH
39428: EMPTY
39429: PPUSH
39430: CALL_OW 1
39434: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39435: LD_ADDR_EXP 121
39439: PUSH
39440: LD_EXP 121
39444: PPUSH
39445: LD_VAR 0 1
39449: PPUSH
39450: EMPTY
39451: PPUSH
39452: CALL_OW 1
39456: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39457: LD_ADDR_EXP 122
39461: PUSH
39462: LD_EXP 122
39466: PPUSH
39467: LD_VAR 0 1
39471: PPUSH
39472: EMPTY
39473: PPUSH
39474: CALL_OW 1
39478: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39479: LD_ADDR_EXP 123
39483: PUSH
39484: LD_EXP 123
39488: PPUSH
39489: LD_VAR 0 1
39493: PPUSH
39494: EMPTY
39495: PPUSH
39496: CALL_OW 1
39500: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39501: LD_ADDR_EXP 124
39505: PUSH
39506: LD_EXP 124
39510: PPUSH
39511: LD_VAR 0 1
39515: PPUSH
39516: EMPTY
39517: PPUSH
39518: CALL_OW 1
39522: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39523: LD_ADDR_EXP 125
39527: PUSH
39528: LD_EXP 125
39532: PPUSH
39533: LD_VAR 0 1
39537: PPUSH
39538: EMPTY
39539: PPUSH
39540: CALL_OW 1
39544: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39545: LD_ADDR_EXP 126
39549: PUSH
39550: LD_EXP 126
39554: PPUSH
39555: LD_VAR 0 1
39559: PPUSH
39560: EMPTY
39561: PPUSH
39562: CALL_OW 1
39566: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39567: LD_ADDR_EXP 128
39571: PUSH
39572: LD_EXP 128
39576: PPUSH
39577: LD_VAR 0 1
39581: PPUSH
39582: EMPTY
39583: PPUSH
39584: CALL_OW 1
39588: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39589: LD_ADDR_EXP 130
39593: PUSH
39594: LD_EXP 130
39598: PPUSH
39599: LD_VAR 0 1
39603: PPUSH
39604: EMPTY
39605: PPUSH
39606: CALL_OW 1
39610: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39611: LD_ADDR_EXP 131
39615: PUSH
39616: LD_EXP 131
39620: PPUSH
39621: LD_VAR 0 1
39625: PPUSH
39626: EMPTY
39627: PPUSH
39628: CALL_OW 1
39632: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39633: LD_ADDR_EXP 132
39637: PUSH
39638: LD_EXP 132
39642: PPUSH
39643: LD_VAR 0 1
39647: PPUSH
39648: EMPTY
39649: PPUSH
39650: CALL_OW 1
39654: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39655: LD_ADDR_EXP 133
39659: PUSH
39660: LD_EXP 133
39664: PPUSH
39665: LD_VAR 0 1
39669: PPUSH
39670: EMPTY
39671: PPUSH
39672: CALL_OW 1
39676: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39677: LD_ADDR_EXP 134
39681: PUSH
39682: LD_EXP 134
39686: PPUSH
39687: LD_VAR 0 1
39691: PPUSH
39692: EMPTY
39693: PPUSH
39694: CALL_OW 1
39698: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39699: LD_ADDR_EXP 135
39703: PUSH
39704: LD_EXP 135
39708: PPUSH
39709: LD_VAR 0 1
39713: PPUSH
39714: EMPTY
39715: PPUSH
39716: CALL_OW 1
39720: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39721: LD_ADDR_EXP 136
39725: PUSH
39726: LD_EXP 136
39730: PPUSH
39731: LD_VAR 0 1
39735: PPUSH
39736: EMPTY
39737: PPUSH
39738: CALL_OW 1
39742: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39743: LD_ADDR_EXP 137
39747: PUSH
39748: LD_EXP 137
39752: PPUSH
39753: LD_VAR 0 1
39757: PPUSH
39758: EMPTY
39759: PPUSH
39760: CALL_OW 1
39764: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39765: LD_ADDR_EXP 138
39769: PUSH
39770: LD_EXP 138
39774: PPUSH
39775: LD_VAR 0 1
39779: PPUSH
39780: EMPTY
39781: PPUSH
39782: CALL_OW 1
39786: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39787: LD_ADDR_EXP 139
39791: PUSH
39792: LD_EXP 139
39796: PPUSH
39797: LD_VAR 0 1
39801: PPUSH
39802: EMPTY
39803: PPUSH
39804: CALL_OW 1
39808: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39809: LD_ADDR_EXP 140
39813: PUSH
39814: LD_EXP 140
39818: PPUSH
39819: LD_VAR 0 1
39823: PPUSH
39824: EMPTY
39825: PPUSH
39826: CALL_OW 1
39830: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39831: LD_ADDR_EXP 141
39835: PUSH
39836: LD_EXP 141
39840: PPUSH
39841: LD_VAR 0 1
39845: PPUSH
39846: EMPTY
39847: PPUSH
39848: CALL_OW 1
39852: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39853: LD_ADDR_EXP 142
39857: PUSH
39858: LD_EXP 142
39862: PPUSH
39863: LD_VAR 0 1
39867: PPUSH
39868: EMPTY
39869: PPUSH
39870: CALL_OW 1
39874: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39875: LD_ADDR_EXP 143
39879: PUSH
39880: LD_EXP 143
39884: PPUSH
39885: LD_VAR 0 1
39889: PPUSH
39890: LD_INT 0
39892: PPUSH
39893: CALL_OW 1
39897: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39898: LD_ADDR_EXP 144
39902: PUSH
39903: LD_EXP 144
39907: PPUSH
39908: LD_VAR 0 1
39912: PPUSH
39913: LD_INT 0
39915: PPUSH
39916: CALL_OW 1
39920: ST_TO_ADDR
// end ;
39921: LD_VAR 0 2
39925: RET
// export function MC_Add ( side , units ) ; var base ; begin
39926: LD_INT 0
39928: PPUSH
39929: PPUSH
// base := mc_bases + 1 ;
39930: LD_ADDR_VAR 0 4
39934: PUSH
39935: LD_EXP 101
39939: PUSH
39940: LD_INT 1
39942: PLUS
39943: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39944: LD_ADDR_EXP 127
39948: PUSH
39949: LD_EXP 127
39953: PPUSH
39954: LD_VAR 0 4
39958: PPUSH
39959: LD_VAR 0 1
39963: PPUSH
39964: CALL_OW 1
39968: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39969: LD_ADDR_EXP 101
39973: PUSH
39974: LD_EXP 101
39978: PPUSH
39979: LD_VAR 0 4
39983: PPUSH
39984: LD_VAR 0 2
39988: PPUSH
39989: CALL_OW 1
39993: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39994: LD_ADDR_EXP 102
39998: PUSH
39999: LD_EXP 102
40003: PPUSH
40004: LD_VAR 0 4
40008: PPUSH
40009: EMPTY
40010: PPUSH
40011: CALL_OW 1
40015: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40016: LD_ADDR_EXP 103
40020: PUSH
40021: LD_EXP 103
40025: PPUSH
40026: LD_VAR 0 4
40030: PPUSH
40031: EMPTY
40032: PPUSH
40033: CALL_OW 1
40037: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40038: LD_ADDR_EXP 104
40042: PUSH
40043: LD_EXP 104
40047: PPUSH
40048: LD_VAR 0 4
40052: PPUSH
40053: EMPTY
40054: PPUSH
40055: CALL_OW 1
40059: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40060: LD_ADDR_EXP 105
40064: PUSH
40065: LD_EXP 105
40069: PPUSH
40070: LD_VAR 0 4
40074: PPUSH
40075: EMPTY
40076: PPUSH
40077: CALL_OW 1
40081: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40082: LD_ADDR_EXP 106
40086: PUSH
40087: LD_EXP 106
40091: PPUSH
40092: LD_VAR 0 4
40096: PPUSH
40097: EMPTY
40098: PPUSH
40099: CALL_OW 1
40103: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40104: LD_ADDR_EXP 107
40108: PUSH
40109: LD_EXP 107
40113: PPUSH
40114: LD_VAR 0 4
40118: PPUSH
40119: EMPTY
40120: PPUSH
40121: CALL_OW 1
40125: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40126: LD_ADDR_EXP 108
40130: PUSH
40131: LD_EXP 108
40135: PPUSH
40136: LD_VAR 0 4
40140: PPUSH
40141: EMPTY
40142: PPUSH
40143: CALL_OW 1
40147: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40148: LD_ADDR_EXP 109
40152: PUSH
40153: LD_EXP 109
40157: PPUSH
40158: LD_VAR 0 4
40162: PPUSH
40163: EMPTY
40164: PPUSH
40165: CALL_OW 1
40169: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40170: LD_ADDR_EXP 110
40174: PUSH
40175: LD_EXP 110
40179: PPUSH
40180: LD_VAR 0 4
40184: PPUSH
40185: EMPTY
40186: PPUSH
40187: CALL_OW 1
40191: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40192: LD_ADDR_EXP 111
40196: PUSH
40197: LD_EXP 111
40201: PPUSH
40202: LD_VAR 0 4
40206: PPUSH
40207: EMPTY
40208: PPUSH
40209: CALL_OW 1
40213: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40214: LD_ADDR_EXP 112
40218: PUSH
40219: LD_EXP 112
40223: PPUSH
40224: LD_VAR 0 4
40228: PPUSH
40229: LD_INT 0
40231: PPUSH
40232: CALL_OW 1
40236: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40237: LD_ADDR_EXP 113
40241: PUSH
40242: LD_EXP 113
40246: PPUSH
40247: LD_VAR 0 4
40251: PPUSH
40252: EMPTY
40253: PPUSH
40254: CALL_OW 1
40258: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40259: LD_ADDR_EXP 114
40263: PUSH
40264: LD_EXP 114
40268: PPUSH
40269: LD_VAR 0 4
40273: PPUSH
40274: EMPTY
40275: PPUSH
40276: CALL_OW 1
40280: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40281: LD_ADDR_EXP 115
40285: PUSH
40286: LD_EXP 115
40290: PPUSH
40291: LD_VAR 0 4
40295: PPUSH
40296: EMPTY
40297: PPUSH
40298: CALL_OW 1
40302: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40303: LD_ADDR_EXP 116
40307: PUSH
40308: LD_EXP 116
40312: PPUSH
40313: LD_VAR 0 4
40317: PPUSH
40318: EMPTY
40319: PPUSH
40320: CALL_OW 1
40324: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40325: LD_ADDR_EXP 117
40329: PUSH
40330: LD_EXP 117
40334: PPUSH
40335: LD_VAR 0 4
40339: PPUSH
40340: EMPTY
40341: PPUSH
40342: CALL_OW 1
40346: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40347: LD_ADDR_EXP 118
40351: PUSH
40352: LD_EXP 118
40356: PPUSH
40357: LD_VAR 0 4
40361: PPUSH
40362: EMPTY
40363: PPUSH
40364: CALL_OW 1
40368: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40369: LD_ADDR_EXP 119
40373: PUSH
40374: LD_EXP 119
40378: PPUSH
40379: LD_VAR 0 4
40383: PPUSH
40384: EMPTY
40385: PPUSH
40386: CALL_OW 1
40390: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40391: LD_ADDR_EXP 120
40395: PUSH
40396: LD_EXP 120
40400: PPUSH
40401: LD_VAR 0 4
40405: PPUSH
40406: EMPTY
40407: PPUSH
40408: CALL_OW 1
40412: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40413: LD_ADDR_EXP 121
40417: PUSH
40418: LD_EXP 121
40422: PPUSH
40423: LD_VAR 0 4
40427: PPUSH
40428: EMPTY
40429: PPUSH
40430: CALL_OW 1
40434: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40435: LD_ADDR_EXP 122
40439: PUSH
40440: LD_EXP 122
40444: PPUSH
40445: LD_VAR 0 4
40449: PPUSH
40450: EMPTY
40451: PPUSH
40452: CALL_OW 1
40456: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40457: LD_ADDR_EXP 123
40461: PUSH
40462: LD_EXP 123
40466: PPUSH
40467: LD_VAR 0 4
40471: PPUSH
40472: EMPTY
40473: PPUSH
40474: CALL_OW 1
40478: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40479: LD_ADDR_EXP 124
40483: PUSH
40484: LD_EXP 124
40488: PPUSH
40489: LD_VAR 0 4
40493: PPUSH
40494: EMPTY
40495: PPUSH
40496: CALL_OW 1
40500: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40501: LD_ADDR_EXP 125
40505: PUSH
40506: LD_EXP 125
40510: PPUSH
40511: LD_VAR 0 4
40515: PPUSH
40516: EMPTY
40517: PPUSH
40518: CALL_OW 1
40522: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40523: LD_ADDR_EXP 126
40527: PUSH
40528: LD_EXP 126
40532: PPUSH
40533: LD_VAR 0 4
40537: PPUSH
40538: EMPTY
40539: PPUSH
40540: CALL_OW 1
40544: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40545: LD_ADDR_EXP 128
40549: PUSH
40550: LD_EXP 128
40554: PPUSH
40555: LD_VAR 0 4
40559: PPUSH
40560: EMPTY
40561: PPUSH
40562: CALL_OW 1
40566: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40567: LD_ADDR_EXP 130
40571: PUSH
40572: LD_EXP 130
40576: PPUSH
40577: LD_VAR 0 4
40581: PPUSH
40582: EMPTY
40583: PPUSH
40584: CALL_OW 1
40588: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40589: LD_ADDR_EXP 131
40593: PUSH
40594: LD_EXP 131
40598: PPUSH
40599: LD_VAR 0 4
40603: PPUSH
40604: EMPTY
40605: PPUSH
40606: CALL_OW 1
40610: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40611: LD_ADDR_EXP 132
40615: PUSH
40616: LD_EXP 132
40620: PPUSH
40621: LD_VAR 0 4
40625: PPUSH
40626: EMPTY
40627: PPUSH
40628: CALL_OW 1
40632: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40633: LD_ADDR_EXP 133
40637: PUSH
40638: LD_EXP 133
40642: PPUSH
40643: LD_VAR 0 4
40647: PPUSH
40648: EMPTY
40649: PPUSH
40650: CALL_OW 1
40654: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40655: LD_ADDR_EXP 134
40659: PUSH
40660: LD_EXP 134
40664: PPUSH
40665: LD_VAR 0 4
40669: PPUSH
40670: EMPTY
40671: PPUSH
40672: CALL_OW 1
40676: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40677: LD_ADDR_EXP 135
40681: PUSH
40682: LD_EXP 135
40686: PPUSH
40687: LD_VAR 0 4
40691: PPUSH
40692: EMPTY
40693: PPUSH
40694: CALL_OW 1
40698: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40699: LD_ADDR_EXP 136
40703: PUSH
40704: LD_EXP 136
40708: PPUSH
40709: LD_VAR 0 4
40713: PPUSH
40714: EMPTY
40715: PPUSH
40716: CALL_OW 1
40720: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40721: LD_ADDR_EXP 137
40725: PUSH
40726: LD_EXP 137
40730: PPUSH
40731: LD_VAR 0 4
40735: PPUSH
40736: EMPTY
40737: PPUSH
40738: CALL_OW 1
40742: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40743: LD_ADDR_EXP 138
40747: PUSH
40748: LD_EXP 138
40752: PPUSH
40753: LD_VAR 0 4
40757: PPUSH
40758: EMPTY
40759: PPUSH
40760: CALL_OW 1
40764: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40765: LD_ADDR_EXP 139
40769: PUSH
40770: LD_EXP 139
40774: PPUSH
40775: LD_VAR 0 4
40779: PPUSH
40780: EMPTY
40781: PPUSH
40782: CALL_OW 1
40786: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40787: LD_ADDR_EXP 140
40791: PUSH
40792: LD_EXP 140
40796: PPUSH
40797: LD_VAR 0 4
40801: PPUSH
40802: EMPTY
40803: PPUSH
40804: CALL_OW 1
40808: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40809: LD_ADDR_EXP 141
40813: PUSH
40814: LD_EXP 141
40818: PPUSH
40819: LD_VAR 0 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL_OW 1
40830: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40831: LD_ADDR_EXP 142
40835: PUSH
40836: LD_EXP 142
40840: PPUSH
40841: LD_VAR 0 4
40845: PPUSH
40846: EMPTY
40847: PPUSH
40848: CALL_OW 1
40852: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40853: LD_ADDR_EXP 143
40857: PUSH
40858: LD_EXP 143
40862: PPUSH
40863: LD_VAR 0 4
40867: PPUSH
40868: LD_INT 0
40870: PPUSH
40871: CALL_OW 1
40875: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40876: LD_ADDR_EXP 144
40880: PUSH
40881: LD_EXP 144
40885: PPUSH
40886: LD_VAR 0 4
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 1
40898: ST_TO_ADDR
// result := base ;
40899: LD_ADDR_VAR 0 3
40903: PUSH
40904: LD_VAR 0 4
40908: ST_TO_ADDR
// end ;
40909: LD_VAR 0 3
40913: RET
// export function MC_Start ( ) ; var i ; begin
40914: LD_INT 0
40916: PPUSH
40917: PPUSH
// for i = 1 to mc_bases do
40918: LD_ADDR_VAR 0 2
40922: PUSH
40923: DOUBLE
40924: LD_INT 1
40926: DEC
40927: ST_TO_ADDR
40928: LD_EXP 101
40932: PUSH
40933: FOR_TO
40934: IFFALSE 42034
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40936: LD_ADDR_EXP 101
40940: PUSH
40941: LD_EXP 101
40945: PPUSH
40946: LD_VAR 0 2
40950: PPUSH
40951: LD_EXP 101
40955: PUSH
40956: LD_VAR 0 2
40960: ARRAY
40961: PUSH
40962: LD_INT 0
40964: DIFF
40965: PPUSH
40966: CALL_OW 1
40970: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40971: LD_ADDR_EXP 102
40975: PUSH
40976: LD_EXP 102
40980: PPUSH
40981: LD_VAR 0 2
40985: PPUSH
40986: EMPTY
40987: PPUSH
40988: CALL_OW 1
40992: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40993: LD_ADDR_EXP 103
40997: PUSH
40998: LD_EXP 103
41002: PPUSH
41003: LD_VAR 0 2
41007: PPUSH
41008: EMPTY
41009: PPUSH
41010: CALL_OW 1
41014: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41015: LD_ADDR_EXP 104
41019: PUSH
41020: LD_EXP 104
41024: PPUSH
41025: LD_VAR 0 2
41029: PPUSH
41030: EMPTY
41031: PPUSH
41032: CALL_OW 1
41036: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41037: LD_ADDR_EXP 105
41041: PUSH
41042: LD_EXP 105
41046: PPUSH
41047: LD_VAR 0 2
41051: PPUSH
41052: EMPTY
41053: PUSH
41054: EMPTY
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PPUSH
41060: CALL_OW 1
41064: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41065: LD_ADDR_EXP 106
41069: PUSH
41070: LD_EXP 106
41074: PPUSH
41075: LD_VAR 0 2
41079: PPUSH
41080: EMPTY
41081: PPUSH
41082: CALL_OW 1
41086: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41087: LD_ADDR_EXP 133
41091: PUSH
41092: LD_EXP 133
41096: PPUSH
41097: LD_VAR 0 2
41101: PPUSH
41102: EMPTY
41103: PPUSH
41104: CALL_OW 1
41108: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41109: LD_ADDR_EXP 107
41113: PUSH
41114: LD_EXP 107
41118: PPUSH
41119: LD_VAR 0 2
41123: PPUSH
41124: EMPTY
41125: PPUSH
41126: CALL_OW 1
41130: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41131: LD_ADDR_EXP 108
41135: PUSH
41136: LD_EXP 108
41140: PPUSH
41141: LD_VAR 0 2
41145: PPUSH
41146: EMPTY
41147: PPUSH
41148: CALL_OW 1
41152: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41153: LD_ADDR_EXP 109
41157: PUSH
41158: LD_EXP 109
41162: PPUSH
41163: LD_VAR 0 2
41167: PPUSH
41168: LD_EXP 101
41172: PUSH
41173: LD_VAR 0 2
41177: ARRAY
41178: PPUSH
41179: LD_INT 2
41181: PUSH
41182: LD_INT 30
41184: PUSH
41185: LD_INT 32
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 30
41194: PUSH
41195: LD_INT 33
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: LIST
41206: PPUSH
41207: CALL_OW 72
41211: PPUSH
41212: CALL_OW 1
41216: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41217: LD_ADDR_EXP 110
41221: PUSH
41222: LD_EXP 110
41226: PPUSH
41227: LD_VAR 0 2
41231: PPUSH
41232: LD_EXP 101
41236: PUSH
41237: LD_VAR 0 2
41241: ARRAY
41242: PPUSH
41243: LD_INT 2
41245: PUSH
41246: LD_INT 30
41248: PUSH
41249: LD_INT 32
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 30
41258: PUSH
41259: LD_INT 31
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 58
41273: PUSH
41274: EMPTY
41275: LIST
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PPUSH
41281: CALL_OW 72
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41291: LD_ADDR_EXP 111
41295: PUSH
41296: LD_EXP 111
41300: PPUSH
41301: LD_VAR 0 2
41305: PPUSH
41306: EMPTY
41307: PPUSH
41308: CALL_OW 1
41312: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41313: LD_ADDR_EXP 115
41317: PUSH
41318: LD_EXP 115
41322: PPUSH
41323: LD_VAR 0 2
41327: PPUSH
41328: EMPTY
41329: PPUSH
41330: CALL_OW 1
41334: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41335: LD_ADDR_EXP 114
41339: PUSH
41340: LD_EXP 114
41344: PPUSH
41345: LD_VAR 0 2
41349: PPUSH
41350: EMPTY
41351: PPUSH
41352: CALL_OW 1
41356: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41357: LD_ADDR_EXP 116
41361: PUSH
41362: LD_EXP 116
41366: PPUSH
41367: LD_VAR 0 2
41371: PPUSH
41372: EMPTY
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41379: LD_ADDR_EXP 117
41383: PUSH
41384: LD_EXP 117
41388: PPUSH
41389: LD_VAR 0 2
41393: PPUSH
41394: EMPTY
41395: PPUSH
41396: CALL_OW 1
41400: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41401: LD_ADDR_EXP 118
41405: PUSH
41406: LD_EXP 118
41410: PPUSH
41411: LD_VAR 0 2
41415: PPUSH
41416: EMPTY
41417: PPUSH
41418: CALL_OW 1
41422: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41423: LD_ADDR_EXP 119
41427: PUSH
41428: LD_EXP 119
41432: PPUSH
41433: LD_VAR 0 2
41437: PPUSH
41438: EMPTY
41439: PPUSH
41440: CALL_OW 1
41444: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41445: LD_ADDR_EXP 120
41449: PUSH
41450: LD_EXP 120
41454: PPUSH
41455: LD_VAR 0 2
41459: PPUSH
41460: EMPTY
41461: PPUSH
41462: CALL_OW 1
41466: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41467: LD_ADDR_EXP 121
41471: PUSH
41472: LD_EXP 121
41476: PPUSH
41477: LD_VAR 0 2
41481: PPUSH
41482: EMPTY
41483: PPUSH
41484: CALL_OW 1
41488: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41489: LD_ADDR_EXP 122
41493: PUSH
41494: LD_EXP 122
41498: PPUSH
41499: LD_VAR 0 2
41503: PPUSH
41504: EMPTY
41505: PPUSH
41506: CALL_OW 1
41510: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41511: LD_ADDR_EXP 123
41515: PUSH
41516: LD_EXP 123
41520: PPUSH
41521: LD_VAR 0 2
41525: PPUSH
41526: EMPTY
41527: PPUSH
41528: CALL_OW 1
41532: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41533: LD_ADDR_EXP 112
41537: PUSH
41538: LD_EXP 112
41542: PPUSH
41543: LD_VAR 0 2
41547: PPUSH
41548: LD_INT 0
41550: PPUSH
41551: CALL_OW 1
41555: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41556: LD_ADDR_EXP 125
41560: PUSH
41561: LD_EXP 125
41565: PPUSH
41566: LD_VAR 0 2
41570: PPUSH
41571: LD_INT 0
41573: PPUSH
41574: CALL_OW 1
41578: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41579: LD_ADDR_EXP 113
41583: PUSH
41584: LD_EXP 113
41588: PPUSH
41589: LD_VAR 0 2
41593: PPUSH
41594: EMPTY
41595: PPUSH
41596: CALL_OW 1
41600: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41601: LD_ADDR_EXP 124
41605: PUSH
41606: LD_EXP 124
41610: PPUSH
41611: LD_VAR 0 2
41615: PPUSH
41616: LD_INT 0
41618: PPUSH
41619: CALL_OW 1
41623: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41624: LD_ADDR_EXP 126
41628: PUSH
41629: LD_EXP 126
41633: PPUSH
41634: LD_VAR 0 2
41638: PPUSH
41639: EMPTY
41640: PPUSH
41641: CALL_OW 1
41645: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41646: LD_ADDR_EXP 129
41650: PUSH
41651: LD_EXP 129
41655: PPUSH
41656: LD_VAR 0 2
41660: PPUSH
41661: LD_INT 0
41663: PPUSH
41664: CALL_OW 1
41668: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41669: LD_ADDR_EXP 130
41673: PUSH
41674: LD_EXP 130
41678: PPUSH
41679: LD_VAR 0 2
41683: PPUSH
41684: EMPTY
41685: PPUSH
41686: CALL_OW 1
41690: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41691: LD_ADDR_EXP 131
41695: PUSH
41696: LD_EXP 131
41700: PPUSH
41701: LD_VAR 0 2
41705: PPUSH
41706: EMPTY
41707: PPUSH
41708: CALL_OW 1
41712: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41713: LD_ADDR_EXP 132
41717: PUSH
41718: LD_EXP 132
41722: PPUSH
41723: LD_VAR 0 2
41727: PPUSH
41728: EMPTY
41729: PPUSH
41730: CALL_OW 1
41734: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41735: LD_ADDR_EXP 134
41739: PUSH
41740: LD_EXP 134
41744: PPUSH
41745: LD_VAR 0 2
41749: PPUSH
41750: LD_EXP 101
41754: PUSH
41755: LD_VAR 0 2
41759: ARRAY
41760: PPUSH
41761: LD_INT 2
41763: PUSH
41764: LD_INT 30
41766: PUSH
41767: LD_INT 6
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 30
41776: PUSH
41777: LD_INT 7
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 30
41786: PUSH
41787: LD_INT 8
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: PPUSH
41800: CALL_OW 72
41804: PPUSH
41805: CALL_OW 1
41809: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41810: LD_ADDR_EXP 135
41814: PUSH
41815: LD_EXP 135
41819: PPUSH
41820: LD_VAR 0 2
41824: PPUSH
41825: EMPTY
41826: PPUSH
41827: CALL_OW 1
41831: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41832: LD_ADDR_EXP 136
41836: PUSH
41837: LD_EXP 136
41841: PPUSH
41842: LD_VAR 0 2
41846: PPUSH
41847: EMPTY
41848: PPUSH
41849: CALL_OW 1
41853: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41854: LD_ADDR_EXP 137
41858: PUSH
41859: LD_EXP 137
41863: PPUSH
41864: LD_VAR 0 2
41868: PPUSH
41869: EMPTY
41870: PPUSH
41871: CALL_OW 1
41875: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41876: LD_ADDR_EXP 138
41880: PUSH
41881: LD_EXP 138
41885: PPUSH
41886: LD_VAR 0 2
41890: PPUSH
41891: EMPTY
41892: PPUSH
41893: CALL_OW 1
41897: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41898: LD_ADDR_EXP 139
41902: PUSH
41903: LD_EXP 139
41907: PPUSH
41908: LD_VAR 0 2
41912: PPUSH
41913: EMPTY
41914: PPUSH
41915: CALL_OW 1
41919: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41920: LD_ADDR_EXP 140
41924: PUSH
41925: LD_EXP 140
41929: PPUSH
41930: LD_VAR 0 2
41934: PPUSH
41935: EMPTY
41936: PPUSH
41937: CALL_OW 1
41941: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41942: LD_ADDR_EXP 141
41946: PUSH
41947: LD_EXP 141
41951: PPUSH
41952: LD_VAR 0 2
41956: PPUSH
41957: EMPTY
41958: PPUSH
41959: CALL_OW 1
41963: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41964: LD_ADDR_EXP 142
41968: PUSH
41969: LD_EXP 142
41973: PPUSH
41974: LD_VAR 0 2
41978: PPUSH
41979: EMPTY
41980: PPUSH
41981: CALL_OW 1
41985: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41986: LD_ADDR_EXP 143
41990: PUSH
41991: LD_EXP 143
41995: PPUSH
41996: LD_VAR 0 2
42000: PPUSH
42001: LD_INT 0
42003: PPUSH
42004: CALL_OW 1
42008: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42009: LD_ADDR_EXP 144
42013: PUSH
42014: LD_EXP 144
42018: PPUSH
42019: LD_VAR 0 2
42023: PPUSH
42024: LD_INT 0
42026: PPUSH
42027: CALL_OW 1
42031: ST_TO_ADDR
// end ;
42032: GO 40933
42034: POP
42035: POP
// MC_InitSides ( ) ;
42036: CALL 42322 0 0
// MC_InitResearch ( ) ;
42040: CALL 42061 0 0
// CustomInitMacro ( ) ;
42044: CALL 475 0 0
// skirmish := true ;
42048: LD_ADDR_EXP 99
42052: PUSH
42053: LD_INT 1
42055: ST_TO_ADDR
// end ;
42056: LD_VAR 0 1
42060: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42061: LD_INT 0
42063: PPUSH
42064: PPUSH
42065: PPUSH
42066: PPUSH
42067: PPUSH
42068: PPUSH
// if not mc_bases then
42069: LD_EXP 101
42073: NOT
42074: IFFALSE 42078
// exit ;
42076: GO 42317
// for i = 1 to 8 do
42078: LD_ADDR_VAR 0 2
42082: PUSH
42083: DOUBLE
42084: LD_INT 1
42086: DEC
42087: ST_TO_ADDR
42088: LD_INT 8
42090: PUSH
42091: FOR_TO
42092: IFFALSE 42118
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42094: LD_ADDR_EXP 128
42098: PUSH
42099: LD_EXP 128
42103: PPUSH
42104: LD_VAR 0 2
42108: PPUSH
42109: EMPTY
42110: PPUSH
42111: CALL_OW 1
42115: ST_TO_ADDR
42116: GO 42091
42118: POP
42119: POP
// tmp := [ ] ;
42120: LD_ADDR_VAR 0 5
42124: PUSH
42125: EMPTY
42126: ST_TO_ADDR
// for i = 1 to mc_sides do
42127: LD_ADDR_VAR 0 2
42131: PUSH
42132: DOUBLE
42133: LD_INT 1
42135: DEC
42136: ST_TO_ADDR
42137: LD_EXP 127
42141: PUSH
42142: FOR_TO
42143: IFFALSE 42201
// if not mc_sides [ i ] in tmp then
42145: LD_EXP 127
42149: PUSH
42150: LD_VAR 0 2
42154: ARRAY
42155: PUSH
42156: LD_VAR 0 5
42160: IN
42161: NOT
42162: IFFALSE 42199
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42164: LD_ADDR_VAR 0 5
42168: PUSH
42169: LD_VAR 0 5
42173: PPUSH
42174: LD_VAR 0 5
42178: PUSH
42179: LD_INT 1
42181: PLUS
42182: PPUSH
42183: LD_EXP 127
42187: PUSH
42188: LD_VAR 0 2
42192: ARRAY
42193: PPUSH
42194: CALL_OW 2
42198: ST_TO_ADDR
42199: GO 42142
42201: POP
42202: POP
// if not tmp then
42203: LD_VAR 0 5
42207: NOT
42208: IFFALSE 42212
// exit ;
42210: GO 42317
// for j in tmp do
42212: LD_ADDR_VAR 0 3
42216: PUSH
42217: LD_VAR 0 5
42221: PUSH
42222: FOR_IN
42223: IFFALSE 42315
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42225: LD_ADDR_VAR 0 6
42229: PUSH
42230: LD_INT 22
42232: PUSH
42233: LD_VAR 0 3
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PPUSH
42242: CALL_OW 69
42246: ST_TO_ADDR
// if not un then
42247: LD_VAR 0 6
42251: NOT
42252: IFFALSE 42256
// continue ;
42254: GO 42222
// nation := GetNation ( un [ 1 ] ) ;
42256: LD_ADDR_VAR 0 4
42260: PUSH
42261: LD_VAR 0 6
42265: PUSH
42266: LD_INT 1
42268: ARRAY
42269: PPUSH
42270: CALL_OW 248
42274: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42275: LD_ADDR_EXP 128
42279: PUSH
42280: LD_EXP 128
42284: PPUSH
42285: LD_VAR 0 3
42289: PPUSH
42290: LD_VAR 0 3
42294: PPUSH
42295: LD_VAR 0 4
42299: PPUSH
42300: LD_INT 1
42302: PPUSH
42303: CALL 69505 0 3
42307: PPUSH
42308: CALL_OW 1
42312: ST_TO_ADDR
// end ;
42313: GO 42222
42315: POP
42316: POP
// end ;
42317: LD_VAR 0 1
42321: RET
// export function MC_InitSides ( ) ; var i ; begin
42322: LD_INT 0
42324: PPUSH
42325: PPUSH
// if not mc_bases then
42326: LD_EXP 101
42330: NOT
42331: IFFALSE 42335
// exit ;
42333: GO 42409
// for i = 1 to mc_bases do
42335: LD_ADDR_VAR 0 2
42339: PUSH
42340: DOUBLE
42341: LD_INT 1
42343: DEC
42344: ST_TO_ADDR
42345: LD_EXP 101
42349: PUSH
42350: FOR_TO
42351: IFFALSE 42407
// if mc_bases [ i ] then
42353: LD_EXP 101
42357: PUSH
42358: LD_VAR 0 2
42362: ARRAY
42363: IFFALSE 42405
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42365: LD_ADDR_EXP 127
42369: PUSH
42370: LD_EXP 127
42374: PPUSH
42375: LD_VAR 0 2
42379: PPUSH
42380: LD_EXP 101
42384: PUSH
42385: LD_VAR 0 2
42389: ARRAY
42390: PUSH
42391: LD_INT 1
42393: ARRAY
42394: PPUSH
42395: CALL_OW 255
42399: PPUSH
42400: CALL_OW 1
42404: ST_TO_ADDR
42405: GO 42350
42407: POP
42408: POP
// end ;
42409: LD_VAR 0 1
42413: RET
// every 0 0$03 trigger skirmish do
42414: LD_EXP 99
42418: IFFALSE 42572
42420: GO 42422
42422: DISABLE
// begin enable ;
42423: ENABLE
// MC_CheckBuildings ( ) ;
42424: CALL 47084 0 0
// MC_CheckPeopleLife ( ) ;
42428: CALL 47245 0 0
// RaiseSailEvent ( 100 ) ;
42432: LD_INT 100
42434: PPUSH
42435: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42439: LD_INT 103
42441: PPUSH
42442: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42446: LD_INT 104
42448: PPUSH
42449: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42453: LD_INT 105
42455: PPUSH
42456: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42460: LD_INT 106
42462: PPUSH
42463: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42467: LD_INT 107
42469: PPUSH
42470: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42474: LD_INT 108
42476: PPUSH
42477: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42481: LD_INT 109
42483: PPUSH
42484: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42488: LD_INT 110
42490: PPUSH
42491: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42495: LD_INT 111
42497: PPUSH
42498: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42502: LD_INT 112
42504: PPUSH
42505: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42509: LD_INT 113
42511: PPUSH
42512: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42516: LD_INT 120
42518: PPUSH
42519: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42523: LD_INT 121
42525: PPUSH
42526: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42530: LD_INT 122
42532: PPUSH
42533: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42537: LD_INT 123
42539: PPUSH
42540: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42544: LD_INT 124
42546: PPUSH
42547: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42551: LD_INT 125
42553: PPUSH
42554: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42558: LD_INT 126
42560: PPUSH
42561: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42565: LD_INT 200
42567: PPUSH
42568: CALL_OW 427
// end ;
42572: END
// on SailEvent ( event ) do begin if event < 100 then
42573: LD_VAR 0 1
42577: PUSH
42578: LD_INT 100
42580: LESS
42581: IFFALSE 42592
// CustomEvent ( event ) ;
42583: LD_VAR 0 1
42587: PPUSH
42588: CALL 36948 0 1
// if event = 100 then
42592: LD_VAR 0 1
42596: PUSH
42597: LD_INT 100
42599: EQUAL
42600: IFFALSE 42606
// MC_ClassManager ( ) ;
42602: CALL 42998 0 0
// if event = 101 then
42606: LD_VAR 0 1
42610: PUSH
42611: LD_INT 101
42613: EQUAL
42614: IFFALSE 42620
// MC_RepairBuildings ( ) ;
42616: CALL 47830 0 0
// if event = 102 then
42620: LD_VAR 0 1
42624: PUSH
42625: LD_INT 102
42627: EQUAL
42628: IFFALSE 42634
// MC_Heal ( ) ;
42630: CALL 48765 0 0
// if event = 103 then
42634: LD_VAR 0 1
42638: PUSH
42639: LD_INT 103
42641: EQUAL
42642: IFFALSE 42648
// MC_Build ( ) ;
42644: CALL 49187 0 0
// if event = 104 then
42648: LD_VAR 0 1
42652: PUSH
42653: LD_INT 104
42655: EQUAL
42656: IFFALSE 42662
// MC_TurretWeapon ( ) ;
42658: CALL 50821 0 0
// if event = 105 then
42662: LD_VAR 0 1
42666: PUSH
42667: LD_INT 105
42669: EQUAL
42670: IFFALSE 42676
// MC_BuildUpgrade ( ) ;
42672: CALL 50372 0 0
// if event = 106 then
42676: LD_VAR 0 1
42680: PUSH
42681: LD_INT 106
42683: EQUAL
42684: IFFALSE 42690
// MC_PlantMines ( ) ;
42686: CALL 51251 0 0
// if event = 107 then
42690: LD_VAR 0 1
42694: PUSH
42695: LD_INT 107
42697: EQUAL
42698: IFFALSE 42704
// MC_CollectCrates ( ) ;
42700: CALL 52049 0 0
// if event = 108 then
42704: LD_VAR 0 1
42708: PUSH
42709: LD_INT 108
42711: EQUAL
42712: IFFALSE 42718
// MC_LinkRemoteControl ( ) ;
42714: CALL 53899 0 0
// if event = 109 then
42718: LD_VAR 0 1
42722: PUSH
42723: LD_INT 109
42725: EQUAL
42726: IFFALSE 42732
// MC_ProduceVehicle ( ) ;
42728: CALL 54080 0 0
// if event = 110 then
42732: LD_VAR 0 1
42736: PUSH
42737: LD_INT 110
42739: EQUAL
42740: IFFALSE 42746
// MC_SendAttack ( ) ;
42742: CALL 54546 0 0
// if event = 111 then
42746: LD_VAR 0 1
42750: PUSH
42751: LD_INT 111
42753: EQUAL
42754: IFFALSE 42760
// MC_Defend ( ) ;
42756: CALL 54654 0 0
// if event = 112 then
42760: LD_VAR 0 1
42764: PUSH
42765: LD_INT 112
42767: EQUAL
42768: IFFALSE 42774
// MC_Research ( ) ;
42770: CALL 55534 0 0
// if event = 113 then
42774: LD_VAR 0 1
42778: PUSH
42779: LD_INT 113
42781: EQUAL
42782: IFFALSE 42788
// MC_MinesTrigger ( ) ;
42784: CALL 56648 0 0
// if event = 120 then
42788: LD_VAR 0 1
42792: PUSH
42793: LD_INT 120
42795: EQUAL
42796: IFFALSE 42802
// MC_RepairVehicle ( ) ;
42798: CALL 56747 0 0
// if event = 121 then
42802: LD_VAR 0 1
42806: PUSH
42807: LD_INT 121
42809: EQUAL
42810: IFFALSE 42816
// MC_TameApe ( ) ;
42812: CALL 57516 0 0
// if event = 122 then
42816: LD_VAR 0 1
42820: PUSH
42821: LD_INT 122
42823: EQUAL
42824: IFFALSE 42830
// MC_ChangeApeClass ( ) ;
42826: CALL 58345 0 0
// if event = 123 then
42830: LD_VAR 0 1
42834: PUSH
42835: LD_INT 123
42837: EQUAL
42838: IFFALSE 42844
// MC_Bazooka ( ) ;
42840: CALL 58995 0 0
// if event = 124 then
42844: LD_VAR 0 1
42848: PUSH
42849: LD_INT 124
42851: EQUAL
42852: IFFALSE 42858
// MC_TeleportExit ( ) ;
42854: CALL 59193 0 0
// if event = 125 then
42858: LD_VAR 0 1
42862: PUSH
42863: LD_INT 125
42865: EQUAL
42866: IFFALSE 42872
// MC_Deposits ( ) ;
42868: CALL 59840 0 0
// if event = 126 then
42872: LD_VAR 0 1
42876: PUSH
42877: LD_INT 126
42879: EQUAL
42880: IFFALSE 42886
// MC_RemoteDriver ( ) ;
42882: CALL 60465 0 0
// if event = 200 then
42886: LD_VAR 0 1
42890: PUSH
42891: LD_INT 200
42893: EQUAL
42894: IFFALSE 42900
// MC_Idle ( ) ;
42896: CALL 62372 0 0
// end ;
42900: PPOPN 1
42902: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42903: LD_INT 0
42905: PPUSH
42906: PPUSH
// if not mc_bases [ base ] or not tag then
42907: LD_EXP 101
42911: PUSH
42912: LD_VAR 0 1
42916: ARRAY
42917: NOT
42918: PUSH
42919: LD_VAR 0 2
42923: NOT
42924: OR
42925: IFFALSE 42929
// exit ;
42927: GO 42993
// for i in mc_bases [ base ] union mc_ape [ base ] do
42929: LD_ADDR_VAR 0 4
42933: PUSH
42934: LD_EXP 101
42938: PUSH
42939: LD_VAR 0 1
42943: ARRAY
42944: PUSH
42945: LD_EXP 130
42949: PUSH
42950: LD_VAR 0 1
42954: ARRAY
42955: UNION
42956: PUSH
42957: FOR_IN
42958: IFFALSE 42991
// if GetTag ( i ) = tag then
42960: LD_VAR 0 4
42964: PPUSH
42965: CALL_OW 110
42969: PUSH
42970: LD_VAR 0 2
42974: EQUAL
42975: IFFALSE 42989
// SetTag ( i , 0 ) ;
42977: LD_VAR 0 4
42981: PPUSH
42982: LD_INT 0
42984: PPUSH
42985: CALL_OW 109
42989: GO 42957
42991: POP
42992: POP
// end ;
42993: LD_VAR 0 3
42997: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
42998: LD_INT 0
43000: PPUSH
43001: PPUSH
43002: PPUSH
43003: PPUSH
43004: PPUSH
43005: PPUSH
43006: PPUSH
43007: PPUSH
// if not mc_bases then
43008: LD_EXP 101
43012: NOT
43013: IFFALSE 43017
// exit ;
43015: GO 43466
// for i = 1 to mc_bases do
43017: LD_ADDR_VAR 0 2
43021: PUSH
43022: DOUBLE
43023: LD_INT 1
43025: DEC
43026: ST_TO_ADDR
43027: LD_EXP 101
43031: PUSH
43032: FOR_TO
43033: IFFALSE 43464
// begin tmp := MC_ClassCheckReq ( i ) ;
43035: LD_ADDR_VAR 0 4
43039: PUSH
43040: LD_VAR 0 2
43044: PPUSH
43045: CALL 43471 0 1
43049: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43050: LD_ADDR_EXP 142
43054: PUSH
43055: LD_EXP 142
43059: PPUSH
43060: LD_VAR 0 2
43064: PPUSH
43065: LD_VAR 0 4
43069: PPUSH
43070: CALL_OW 1
43074: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43075: LD_ADDR_VAR 0 6
43079: PUSH
43080: LD_EXP 101
43084: PUSH
43085: LD_VAR 0 2
43089: ARRAY
43090: PPUSH
43091: LD_INT 2
43093: PUSH
43094: LD_INT 30
43096: PUSH
43097: LD_INT 4
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 30
43106: PUSH
43107: LD_INT 5
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: LIST
43118: PPUSH
43119: CALL_OW 72
43123: PUSH
43124: LD_EXP 101
43128: PUSH
43129: LD_VAR 0 2
43133: ARRAY
43134: PPUSH
43135: LD_INT 2
43137: PUSH
43138: LD_INT 30
43140: PUSH
43141: LD_INT 0
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: LD_INT 30
43150: PUSH
43151: LD_INT 1
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: LIST
43162: PPUSH
43163: CALL_OW 72
43167: PUSH
43168: LD_EXP 101
43172: PUSH
43173: LD_VAR 0 2
43177: ARRAY
43178: PPUSH
43179: LD_INT 30
43181: PUSH
43182: LD_INT 3
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PPUSH
43189: CALL_OW 72
43193: PUSH
43194: LD_EXP 101
43198: PUSH
43199: LD_VAR 0 2
43203: ARRAY
43204: PPUSH
43205: LD_INT 2
43207: PUSH
43208: LD_INT 30
43210: PUSH
43211: LD_INT 6
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 30
43220: PUSH
43221: LD_INT 7
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 30
43230: PUSH
43231: LD_INT 8
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: LIST
43242: LIST
43243: PPUSH
43244: CALL_OW 72
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: LIST
43253: LIST
43254: ST_TO_ADDR
// for j := 1 to 4 do
43255: LD_ADDR_VAR 0 3
43259: PUSH
43260: DOUBLE
43261: LD_INT 1
43263: DEC
43264: ST_TO_ADDR
43265: LD_INT 4
43267: PUSH
43268: FOR_TO
43269: IFFALSE 43460
// begin if not tmp [ j ] then
43271: LD_VAR 0 4
43275: PUSH
43276: LD_VAR 0 3
43280: ARRAY
43281: NOT
43282: IFFALSE 43286
// continue ;
43284: GO 43268
// for p in tmp [ j ] do
43286: LD_ADDR_VAR 0 5
43290: PUSH
43291: LD_VAR 0 4
43295: PUSH
43296: LD_VAR 0 3
43300: ARRAY
43301: PUSH
43302: FOR_IN
43303: IFFALSE 43456
// begin if not b [ j ] then
43305: LD_VAR 0 6
43309: PUSH
43310: LD_VAR 0 3
43314: ARRAY
43315: NOT
43316: IFFALSE 43320
// break ;
43318: GO 43456
// e := 0 ;
43320: LD_ADDR_VAR 0 7
43324: PUSH
43325: LD_INT 0
43327: ST_TO_ADDR
// for k in b [ j ] do
43328: LD_ADDR_VAR 0 8
43332: PUSH
43333: LD_VAR 0 6
43337: PUSH
43338: LD_VAR 0 3
43342: ARRAY
43343: PUSH
43344: FOR_IN
43345: IFFALSE 43372
// if IsNotFull ( k ) then
43347: LD_VAR 0 8
43351: PPUSH
43352: CALL 71626 0 1
43356: IFFALSE 43370
// begin e := k ;
43358: LD_ADDR_VAR 0 7
43362: PUSH
43363: LD_VAR 0 8
43367: ST_TO_ADDR
// break ;
43368: GO 43372
// end ;
43370: GO 43344
43372: POP
43373: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43374: LD_VAR 0 7
43378: PUSH
43379: LD_VAR 0 5
43383: PPUSH
43384: LD_VAR 0 7
43388: PPUSH
43389: CALL 105776 0 2
43393: NOT
43394: AND
43395: IFFALSE 43454
// begin if IsInUnit ( p ) then
43397: LD_VAR 0 5
43401: PPUSH
43402: CALL_OW 310
43406: IFFALSE 43417
// ComExitBuilding ( p ) ;
43408: LD_VAR 0 5
43412: PPUSH
43413: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43417: LD_VAR 0 5
43421: PPUSH
43422: LD_VAR 0 7
43426: PPUSH
43427: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43431: LD_VAR 0 5
43435: PPUSH
43436: LD_VAR 0 3
43440: PPUSH
43441: CALL_OW 183
// AddComExitBuilding ( p ) ;
43445: LD_VAR 0 5
43449: PPUSH
43450: CALL_OW 182
// end ; end ;
43454: GO 43302
43456: POP
43457: POP
// end ;
43458: GO 43268
43460: POP
43461: POP
// end ;
43462: GO 43032
43464: POP
43465: POP
// end ;
43466: LD_VAR 0 1
43470: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43471: LD_INT 0
43473: PPUSH
43474: PPUSH
43475: PPUSH
43476: PPUSH
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
43481: PPUSH
43482: PPUSH
43483: PPUSH
43484: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43485: LD_ADDR_VAR 0 2
43489: PUSH
43490: LD_INT 0
43492: PUSH
43493: LD_INT 0
43495: PUSH
43496: LD_INT 0
43498: PUSH
43499: LD_INT 0
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: LIST
43506: LIST
43507: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43508: LD_VAR 0 1
43512: NOT
43513: PUSH
43514: LD_EXP 101
43518: PUSH
43519: LD_VAR 0 1
43523: ARRAY
43524: NOT
43525: OR
43526: PUSH
43527: LD_EXP 101
43531: PUSH
43532: LD_VAR 0 1
43536: ARRAY
43537: PPUSH
43538: LD_INT 2
43540: PUSH
43541: LD_INT 30
43543: PUSH
43544: LD_INT 0
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 30
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: LIST
43565: PPUSH
43566: CALL_OW 72
43570: NOT
43571: OR
43572: IFFALSE 43576
// exit ;
43574: GO 47079
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43576: LD_ADDR_VAR 0 4
43580: PUSH
43581: LD_EXP 101
43585: PUSH
43586: LD_VAR 0 1
43590: ARRAY
43591: PPUSH
43592: LD_INT 2
43594: PUSH
43595: LD_INT 25
43597: PUSH
43598: LD_INT 1
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 25
43607: PUSH
43608: LD_INT 2
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: LD_INT 25
43617: PUSH
43618: LD_INT 3
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 25
43627: PUSH
43628: LD_INT 4
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 25
43637: PUSH
43638: LD_INT 5
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: LD_INT 25
43647: PUSH
43648: LD_INT 8
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 25
43657: PUSH
43658: LD_INT 9
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: PPUSH
43675: CALL_OW 72
43679: ST_TO_ADDR
// if not tmp then
43680: LD_VAR 0 4
43684: NOT
43685: IFFALSE 43689
// exit ;
43687: GO 47079
// for i in tmp do
43689: LD_ADDR_VAR 0 3
43693: PUSH
43694: LD_VAR 0 4
43698: PUSH
43699: FOR_IN
43700: IFFALSE 43731
// if GetTag ( i ) then
43702: LD_VAR 0 3
43706: PPUSH
43707: CALL_OW 110
43711: IFFALSE 43729
// tmp := tmp diff i ;
43713: LD_ADDR_VAR 0 4
43717: PUSH
43718: LD_VAR 0 4
43722: PUSH
43723: LD_VAR 0 3
43727: DIFF
43728: ST_TO_ADDR
43729: GO 43699
43731: POP
43732: POP
// if not tmp then
43733: LD_VAR 0 4
43737: NOT
43738: IFFALSE 43742
// exit ;
43740: GO 47079
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43742: LD_ADDR_VAR 0 5
43746: PUSH
43747: LD_EXP 101
43751: PUSH
43752: LD_VAR 0 1
43756: ARRAY
43757: PPUSH
43758: LD_INT 2
43760: PUSH
43761: LD_INT 25
43763: PUSH
43764: LD_INT 1
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 25
43773: PUSH
43774: LD_INT 5
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 25
43783: PUSH
43784: LD_INT 8
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 25
43793: PUSH
43794: LD_INT 9
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: PPUSH
43808: CALL_OW 72
43812: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43813: LD_ADDR_VAR 0 6
43817: PUSH
43818: LD_EXP 101
43822: PUSH
43823: LD_VAR 0 1
43827: ARRAY
43828: PPUSH
43829: LD_INT 25
43831: PUSH
43832: LD_INT 2
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PPUSH
43839: CALL_OW 72
43843: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43844: LD_ADDR_VAR 0 7
43848: PUSH
43849: LD_EXP 101
43853: PUSH
43854: LD_VAR 0 1
43858: ARRAY
43859: PPUSH
43860: LD_INT 25
43862: PUSH
43863: LD_INT 3
43865: PUSH
43866: EMPTY
43867: LIST
43868: LIST
43869: PPUSH
43870: CALL_OW 72
43874: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43875: LD_ADDR_VAR 0 8
43879: PUSH
43880: LD_EXP 101
43884: PUSH
43885: LD_VAR 0 1
43889: ARRAY
43890: PPUSH
43891: LD_INT 25
43893: PUSH
43894: LD_INT 4
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 24
43903: PUSH
43904: LD_INT 251
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PPUSH
43915: CALL_OW 72
43919: ST_TO_ADDR
// if mc_is_defending [ base ] then
43920: LD_EXP 144
43924: PUSH
43925: LD_VAR 0 1
43929: ARRAY
43930: IFFALSE 44391
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43932: LD_ADDR_EXP 143
43936: PUSH
43937: LD_EXP 143
43941: PPUSH
43942: LD_VAR 0 1
43946: PPUSH
43947: LD_INT 4
43949: PPUSH
43950: CALL_OW 1
43954: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43955: LD_ADDR_VAR 0 12
43959: PUSH
43960: LD_EXP 101
43964: PUSH
43965: LD_VAR 0 1
43969: ARRAY
43970: PPUSH
43971: LD_INT 2
43973: PUSH
43974: LD_INT 30
43976: PUSH
43977: LD_INT 4
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 30
43986: PUSH
43987: LD_INT 5
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: LIST
43998: PPUSH
43999: CALL_OW 72
44003: ST_TO_ADDR
// if not b then
44004: LD_VAR 0 12
44008: NOT
44009: IFFALSE 44013
// exit ;
44011: GO 47079
// p := [ ] ;
44013: LD_ADDR_VAR 0 11
44017: PUSH
44018: EMPTY
44019: ST_TO_ADDR
// if sci >= 2 then
44020: LD_VAR 0 8
44024: PUSH
44025: LD_INT 2
44027: GREATEREQUAL
44028: IFFALSE 44059
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44030: LD_ADDR_VAR 0 8
44034: PUSH
44035: LD_VAR 0 8
44039: PUSH
44040: LD_INT 1
44042: ARRAY
44043: PUSH
44044: LD_VAR 0 8
44048: PUSH
44049: LD_INT 2
44051: ARRAY
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: ST_TO_ADDR
44057: GO 44120
// if sci = 1 then
44059: LD_VAR 0 8
44063: PUSH
44064: LD_INT 1
44066: EQUAL
44067: IFFALSE 44088
// sci := [ sci [ 1 ] ] else
44069: LD_ADDR_VAR 0 8
44073: PUSH
44074: LD_VAR 0 8
44078: PUSH
44079: LD_INT 1
44081: ARRAY
44082: PUSH
44083: EMPTY
44084: LIST
44085: ST_TO_ADDR
44086: GO 44120
// if sci = 0 then
44088: LD_VAR 0 8
44092: PUSH
44093: LD_INT 0
44095: EQUAL
44096: IFFALSE 44120
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44098: LD_ADDR_VAR 0 11
44102: PUSH
44103: LD_VAR 0 4
44107: PPUSH
44108: LD_INT 4
44110: PPUSH
44111: CALL 105648 0 2
44115: PUSH
44116: LD_INT 1
44118: ARRAY
44119: ST_TO_ADDR
// if eng > 4 then
44120: LD_VAR 0 6
44124: PUSH
44125: LD_INT 4
44127: GREATER
44128: IFFALSE 44174
// for i = eng downto 4 do
44130: LD_ADDR_VAR 0 3
44134: PUSH
44135: DOUBLE
44136: LD_VAR 0 6
44140: INC
44141: ST_TO_ADDR
44142: LD_INT 4
44144: PUSH
44145: FOR_DOWNTO
44146: IFFALSE 44172
// eng := eng diff eng [ i ] ;
44148: LD_ADDR_VAR 0 6
44152: PUSH
44153: LD_VAR 0 6
44157: PUSH
44158: LD_VAR 0 6
44162: PUSH
44163: LD_VAR 0 3
44167: ARRAY
44168: DIFF
44169: ST_TO_ADDR
44170: GO 44145
44172: POP
44173: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44174: LD_ADDR_VAR 0 4
44178: PUSH
44179: LD_VAR 0 4
44183: PUSH
44184: LD_VAR 0 5
44188: PUSH
44189: LD_VAR 0 6
44193: UNION
44194: PUSH
44195: LD_VAR 0 7
44199: UNION
44200: PUSH
44201: LD_VAR 0 8
44205: UNION
44206: DIFF
44207: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44208: LD_ADDR_VAR 0 13
44212: PUSH
44213: LD_EXP 101
44217: PUSH
44218: LD_VAR 0 1
44222: ARRAY
44223: PPUSH
44224: LD_INT 2
44226: PUSH
44227: LD_INT 30
44229: PUSH
44230: LD_INT 32
44232: PUSH
44233: EMPTY
44234: LIST
44235: LIST
44236: PUSH
44237: LD_INT 30
44239: PUSH
44240: LD_INT 31
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: PPUSH
44252: CALL_OW 72
44256: PUSH
44257: LD_EXP 101
44261: PUSH
44262: LD_VAR 0 1
44266: ARRAY
44267: PPUSH
44268: LD_INT 2
44270: PUSH
44271: LD_INT 30
44273: PUSH
44274: LD_INT 4
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 30
44283: PUSH
44284: LD_INT 5
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: LIST
44295: PPUSH
44296: CALL_OW 72
44300: PUSH
44301: LD_INT 6
44303: MUL
44304: PLUS
44305: ST_TO_ADDR
// if bcount < tmp then
44306: LD_VAR 0 13
44310: PUSH
44311: LD_VAR 0 4
44315: LESS
44316: IFFALSE 44362
// for i = tmp downto bcount do
44318: LD_ADDR_VAR 0 3
44322: PUSH
44323: DOUBLE
44324: LD_VAR 0 4
44328: INC
44329: ST_TO_ADDR
44330: LD_VAR 0 13
44334: PUSH
44335: FOR_DOWNTO
44336: IFFALSE 44360
// tmp := Delete ( tmp , tmp ) ;
44338: LD_ADDR_VAR 0 4
44342: PUSH
44343: LD_VAR 0 4
44347: PPUSH
44348: LD_VAR 0 4
44352: PPUSH
44353: CALL_OW 3
44357: ST_TO_ADDR
44358: GO 44335
44360: POP
44361: POP
// result := [ tmp , 0 , 0 , p ] ;
44362: LD_ADDR_VAR 0 2
44366: PUSH
44367: LD_VAR 0 4
44371: PUSH
44372: LD_INT 0
44374: PUSH
44375: LD_INT 0
44377: PUSH
44378: LD_VAR 0 11
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: ST_TO_ADDR
// exit ;
44389: GO 47079
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44391: LD_EXP 101
44395: PUSH
44396: LD_VAR 0 1
44400: ARRAY
44401: PPUSH
44402: LD_INT 2
44404: PUSH
44405: LD_INT 30
44407: PUSH
44408: LD_INT 6
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 30
44417: PUSH
44418: LD_INT 7
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 30
44427: PUSH
44428: LD_INT 8
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: PPUSH
44441: CALL_OW 72
44445: NOT
44446: PUSH
44447: LD_EXP 101
44451: PUSH
44452: LD_VAR 0 1
44456: ARRAY
44457: PPUSH
44458: LD_INT 30
44460: PUSH
44461: LD_INT 3
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PPUSH
44468: CALL_OW 72
44472: NOT
44473: AND
44474: IFFALSE 44546
// begin if eng = tmp then
44476: LD_VAR 0 6
44480: PUSH
44481: LD_VAR 0 4
44485: EQUAL
44486: IFFALSE 44490
// exit ;
44488: GO 47079
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44490: LD_ADDR_EXP 143
44494: PUSH
44495: LD_EXP 143
44499: PPUSH
44500: LD_VAR 0 1
44504: PPUSH
44505: LD_INT 1
44507: PPUSH
44508: CALL_OW 1
44512: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44513: LD_ADDR_VAR 0 2
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_VAR 0 4
44525: PUSH
44526: LD_VAR 0 6
44530: DIFF
44531: PUSH
44532: LD_INT 0
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: ST_TO_ADDR
// exit ;
44544: GO 47079
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44546: LD_EXP 128
44550: PUSH
44551: LD_EXP 127
44555: PUSH
44556: LD_VAR 0 1
44560: ARRAY
44561: ARRAY
44562: PUSH
44563: LD_EXP 101
44567: PUSH
44568: LD_VAR 0 1
44572: ARRAY
44573: PPUSH
44574: LD_INT 2
44576: PUSH
44577: LD_INT 30
44579: PUSH
44580: LD_INT 6
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: PUSH
44587: LD_INT 30
44589: PUSH
44590: LD_INT 7
44592: PUSH
44593: EMPTY
44594: LIST
44595: LIST
44596: PUSH
44597: LD_INT 30
44599: PUSH
44600: LD_INT 8
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: PPUSH
44613: CALL_OW 72
44617: AND
44618: PUSH
44619: LD_EXP 101
44623: PUSH
44624: LD_VAR 0 1
44628: ARRAY
44629: PPUSH
44630: LD_INT 30
44632: PUSH
44633: LD_INT 3
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PPUSH
44640: CALL_OW 72
44644: NOT
44645: AND
44646: IFFALSE 44860
// begin if sci >= 6 then
44648: LD_VAR 0 8
44652: PUSH
44653: LD_INT 6
44655: GREATEREQUAL
44656: IFFALSE 44660
// exit ;
44658: GO 47079
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44660: LD_ADDR_EXP 143
44664: PUSH
44665: LD_EXP 143
44669: PPUSH
44670: LD_VAR 0 1
44674: PPUSH
44675: LD_INT 2
44677: PPUSH
44678: CALL_OW 1
44682: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44683: LD_ADDR_VAR 0 9
44687: PUSH
44688: LD_VAR 0 4
44692: PUSH
44693: LD_VAR 0 8
44697: DIFF
44698: PPUSH
44699: LD_INT 4
44701: PPUSH
44702: CALL 105648 0 2
44706: ST_TO_ADDR
// p := [ ] ;
44707: LD_ADDR_VAR 0 11
44711: PUSH
44712: EMPTY
44713: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44714: LD_VAR 0 8
44718: PUSH
44719: LD_INT 6
44721: LESS
44722: PUSH
44723: LD_VAR 0 9
44727: PUSH
44728: LD_INT 6
44730: GREATER
44731: AND
44732: IFFALSE 44813
// begin for i = 1 to 6 - sci do
44734: LD_ADDR_VAR 0 3
44738: PUSH
44739: DOUBLE
44740: LD_INT 1
44742: DEC
44743: ST_TO_ADDR
44744: LD_INT 6
44746: PUSH
44747: LD_VAR 0 8
44751: MINUS
44752: PUSH
44753: FOR_TO
44754: IFFALSE 44809
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44756: LD_ADDR_VAR 0 11
44760: PUSH
44761: LD_VAR 0 11
44765: PPUSH
44766: LD_VAR 0 11
44770: PUSH
44771: LD_INT 1
44773: PLUS
44774: PPUSH
44775: LD_VAR 0 9
44779: PUSH
44780: LD_INT 1
44782: ARRAY
44783: PPUSH
44784: CALL_OW 2
44788: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44789: LD_ADDR_VAR 0 9
44793: PUSH
44794: LD_VAR 0 9
44798: PPUSH
44799: LD_INT 1
44801: PPUSH
44802: CALL_OW 3
44806: ST_TO_ADDR
// end ;
44807: GO 44753
44809: POP
44810: POP
// end else
44811: GO 44833
// if sort then
44813: LD_VAR 0 9
44817: IFFALSE 44833
// p := sort [ 1 ] ;
44819: LD_ADDR_VAR 0 11
44823: PUSH
44824: LD_VAR 0 9
44828: PUSH
44829: LD_INT 1
44831: ARRAY
44832: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44833: LD_ADDR_VAR 0 2
44837: PUSH
44838: LD_INT 0
44840: PUSH
44841: LD_INT 0
44843: PUSH
44844: LD_INT 0
44846: PUSH
44847: LD_VAR 0 11
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: LIST
44856: LIST
44857: ST_TO_ADDR
// exit ;
44858: GO 47079
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44860: LD_EXP 128
44864: PUSH
44865: LD_EXP 127
44869: PUSH
44870: LD_VAR 0 1
44874: ARRAY
44875: ARRAY
44876: PUSH
44877: LD_EXP 101
44881: PUSH
44882: LD_VAR 0 1
44886: ARRAY
44887: PPUSH
44888: LD_INT 2
44890: PUSH
44891: LD_INT 30
44893: PUSH
44894: LD_INT 6
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 30
44903: PUSH
44904: LD_INT 7
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 30
44913: PUSH
44914: LD_INT 8
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: PPUSH
44927: CALL_OW 72
44931: AND
44932: PUSH
44933: LD_EXP 101
44937: PUSH
44938: LD_VAR 0 1
44942: ARRAY
44943: PPUSH
44944: LD_INT 30
44946: PUSH
44947: LD_INT 3
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PPUSH
44954: CALL_OW 72
44958: AND
44959: IFFALSE 45693
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44961: LD_ADDR_EXP 143
44965: PUSH
44966: LD_EXP 143
44970: PPUSH
44971: LD_VAR 0 1
44975: PPUSH
44976: LD_INT 3
44978: PPUSH
44979: CALL_OW 1
44983: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44984: LD_ADDR_VAR 0 2
44988: PUSH
44989: LD_INT 0
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: LD_INT 0
44997: PUSH
44998: LD_INT 0
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: ST_TO_ADDR
// if not eng then
45007: LD_VAR 0 6
45011: NOT
45012: IFFALSE 45075
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45014: LD_ADDR_VAR 0 11
45018: PUSH
45019: LD_VAR 0 4
45023: PPUSH
45024: LD_INT 2
45026: PPUSH
45027: CALL 105648 0 2
45031: PUSH
45032: LD_INT 1
45034: ARRAY
45035: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45036: LD_ADDR_VAR 0 2
45040: PUSH
45041: LD_VAR 0 2
45045: PPUSH
45046: LD_INT 2
45048: PPUSH
45049: LD_VAR 0 11
45053: PPUSH
45054: CALL_OW 1
45058: ST_TO_ADDR
// tmp := tmp diff p ;
45059: LD_ADDR_VAR 0 4
45063: PUSH
45064: LD_VAR 0 4
45068: PUSH
45069: LD_VAR 0 11
45073: DIFF
45074: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45075: LD_VAR 0 4
45079: PUSH
45080: LD_VAR 0 8
45084: PUSH
45085: LD_INT 6
45087: LESS
45088: AND
45089: IFFALSE 45277
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45091: LD_ADDR_VAR 0 9
45095: PUSH
45096: LD_VAR 0 4
45100: PUSH
45101: LD_VAR 0 8
45105: PUSH
45106: LD_VAR 0 7
45110: UNION
45111: DIFF
45112: PPUSH
45113: LD_INT 4
45115: PPUSH
45116: CALL 105648 0 2
45120: ST_TO_ADDR
// p := [ ] ;
45121: LD_ADDR_VAR 0 11
45125: PUSH
45126: EMPTY
45127: ST_TO_ADDR
// if sort then
45128: LD_VAR 0 9
45132: IFFALSE 45248
// for i = 1 to 6 - sci do
45134: LD_ADDR_VAR 0 3
45138: PUSH
45139: DOUBLE
45140: LD_INT 1
45142: DEC
45143: ST_TO_ADDR
45144: LD_INT 6
45146: PUSH
45147: LD_VAR 0 8
45151: MINUS
45152: PUSH
45153: FOR_TO
45154: IFFALSE 45246
// begin if i = sort then
45156: LD_VAR 0 3
45160: PUSH
45161: LD_VAR 0 9
45165: EQUAL
45166: IFFALSE 45170
// break ;
45168: GO 45246
// if GetClass ( i ) = 4 then
45170: LD_VAR 0 3
45174: PPUSH
45175: CALL_OW 257
45179: PUSH
45180: LD_INT 4
45182: EQUAL
45183: IFFALSE 45187
// continue ;
45185: GO 45153
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45187: LD_ADDR_VAR 0 11
45191: PUSH
45192: LD_VAR 0 11
45196: PPUSH
45197: LD_VAR 0 11
45201: PUSH
45202: LD_INT 1
45204: PLUS
45205: PPUSH
45206: LD_VAR 0 9
45210: PUSH
45211: LD_VAR 0 3
45215: ARRAY
45216: PPUSH
45217: CALL_OW 2
45221: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45222: LD_ADDR_VAR 0 4
45226: PUSH
45227: LD_VAR 0 4
45231: PUSH
45232: LD_VAR 0 9
45236: PUSH
45237: LD_VAR 0 3
45241: ARRAY
45242: DIFF
45243: ST_TO_ADDR
// end ;
45244: GO 45153
45246: POP
45247: POP
// if p then
45248: LD_VAR 0 11
45252: IFFALSE 45277
// result := Replace ( result , 4 , p ) ;
45254: LD_ADDR_VAR 0 2
45258: PUSH
45259: LD_VAR 0 2
45263: PPUSH
45264: LD_INT 4
45266: PPUSH
45267: LD_VAR 0 11
45271: PPUSH
45272: CALL_OW 1
45276: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45277: LD_VAR 0 4
45281: PUSH
45282: LD_VAR 0 7
45286: PUSH
45287: LD_INT 6
45289: LESS
45290: AND
45291: IFFALSE 45479
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45293: LD_ADDR_VAR 0 9
45297: PUSH
45298: LD_VAR 0 4
45302: PUSH
45303: LD_VAR 0 8
45307: PUSH
45308: LD_VAR 0 7
45312: UNION
45313: DIFF
45314: PPUSH
45315: LD_INT 3
45317: PPUSH
45318: CALL 105648 0 2
45322: ST_TO_ADDR
// p := [ ] ;
45323: LD_ADDR_VAR 0 11
45327: PUSH
45328: EMPTY
45329: ST_TO_ADDR
// if sort then
45330: LD_VAR 0 9
45334: IFFALSE 45450
// for i = 1 to 6 - mech do
45336: LD_ADDR_VAR 0 3
45340: PUSH
45341: DOUBLE
45342: LD_INT 1
45344: DEC
45345: ST_TO_ADDR
45346: LD_INT 6
45348: PUSH
45349: LD_VAR 0 7
45353: MINUS
45354: PUSH
45355: FOR_TO
45356: IFFALSE 45448
// begin if i = sort then
45358: LD_VAR 0 3
45362: PUSH
45363: LD_VAR 0 9
45367: EQUAL
45368: IFFALSE 45372
// break ;
45370: GO 45448
// if GetClass ( i ) = 3 then
45372: LD_VAR 0 3
45376: PPUSH
45377: CALL_OW 257
45381: PUSH
45382: LD_INT 3
45384: EQUAL
45385: IFFALSE 45389
// continue ;
45387: GO 45355
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45389: LD_ADDR_VAR 0 11
45393: PUSH
45394: LD_VAR 0 11
45398: PPUSH
45399: LD_VAR 0 11
45403: PUSH
45404: LD_INT 1
45406: PLUS
45407: PPUSH
45408: LD_VAR 0 9
45412: PUSH
45413: LD_VAR 0 3
45417: ARRAY
45418: PPUSH
45419: CALL_OW 2
45423: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45424: LD_ADDR_VAR 0 4
45428: PUSH
45429: LD_VAR 0 4
45433: PUSH
45434: LD_VAR 0 9
45438: PUSH
45439: LD_VAR 0 3
45443: ARRAY
45444: DIFF
45445: ST_TO_ADDR
// end ;
45446: GO 45355
45448: POP
45449: POP
// if p then
45450: LD_VAR 0 11
45454: IFFALSE 45479
// result := Replace ( result , 3 , p ) ;
45456: LD_ADDR_VAR 0 2
45460: PUSH
45461: LD_VAR 0 2
45465: PPUSH
45466: LD_INT 3
45468: PPUSH
45469: LD_VAR 0 11
45473: PPUSH
45474: CALL_OW 1
45478: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45479: LD_VAR 0 4
45483: PUSH
45484: LD_INT 6
45486: GREATER
45487: PUSH
45488: LD_VAR 0 6
45492: PUSH
45493: LD_INT 6
45495: LESS
45496: AND
45497: IFFALSE 45691
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45499: LD_ADDR_VAR 0 9
45503: PUSH
45504: LD_VAR 0 4
45508: PUSH
45509: LD_VAR 0 8
45513: PUSH
45514: LD_VAR 0 7
45518: UNION
45519: PUSH
45520: LD_VAR 0 6
45524: UNION
45525: DIFF
45526: PPUSH
45527: LD_INT 2
45529: PPUSH
45530: CALL 105648 0 2
45534: ST_TO_ADDR
// p := [ ] ;
45535: LD_ADDR_VAR 0 11
45539: PUSH
45540: EMPTY
45541: ST_TO_ADDR
// if sort then
45542: LD_VAR 0 9
45546: IFFALSE 45662
// for i = 1 to 6 - eng do
45548: LD_ADDR_VAR 0 3
45552: PUSH
45553: DOUBLE
45554: LD_INT 1
45556: DEC
45557: ST_TO_ADDR
45558: LD_INT 6
45560: PUSH
45561: LD_VAR 0 6
45565: MINUS
45566: PUSH
45567: FOR_TO
45568: IFFALSE 45660
// begin if i = sort then
45570: LD_VAR 0 3
45574: PUSH
45575: LD_VAR 0 9
45579: EQUAL
45580: IFFALSE 45584
// break ;
45582: GO 45660
// if GetClass ( i ) = 2 then
45584: LD_VAR 0 3
45588: PPUSH
45589: CALL_OW 257
45593: PUSH
45594: LD_INT 2
45596: EQUAL
45597: IFFALSE 45601
// continue ;
45599: GO 45567
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45601: LD_ADDR_VAR 0 11
45605: PUSH
45606: LD_VAR 0 11
45610: PPUSH
45611: LD_VAR 0 11
45615: PUSH
45616: LD_INT 1
45618: PLUS
45619: PPUSH
45620: LD_VAR 0 9
45624: PUSH
45625: LD_VAR 0 3
45629: ARRAY
45630: PPUSH
45631: CALL_OW 2
45635: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45636: LD_ADDR_VAR 0 4
45640: PUSH
45641: LD_VAR 0 4
45645: PUSH
45646: LD_VAR 0 9
45650: PUSH
45651: LD_VAR 0 3
45655: ARRAY
45656: DIFF
45657: ST_TO_ADDR
// end ;
45658: GO 45567
45660: POP
45661: POP
// if p then
45662: LD_VAR 0 11
45666: IFFALSE 45691
// result := Replace ( result , 2 , p ) ;
45668: LD_ADDR_VAR 0 2
45672: PUSH
45673: LD_VAR 0 2
45677: PPUSH
45678: LD_INT 2
45680: PPUSH
45681: LD_VAR 0 11
45685: PPUSH
45686: CALL_OW 1
45690: ST_TO_ADDR
// end ; exit ;
45691: GO 47079
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45693: LD_EXP 128
45697: PUSH
45698: LD_EXP 127
45702: PUSH
45703: LD_VAR 0 1
45707: ARRAY
45708: ARRAY
45709: NOT
45710: PUSH
45711: LD_EXP 101
45715: PUSH
45716: LD_VAR 0 1
45720: ARRAY
45721: PPUSH
45722: LD_INT 30
45724: PUSH
45725: LD_INT 3
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PPUSH
45732: CALL_OW 72
45736: AND
45737: PUSH
45738: LD_EXP 106
45742: PUSH
45743: LD_VAR 0 1
45747: ARRAY
45748: AND
45749: IFFALSE 46357
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45751: LD_ADDR_EXP 143
45755: PUSH
45756: LD_EXP 143
45760: PPUSH
45761: LD_VAR 0 1
45765: PPUSH
45766: LD_INT 5
45768: PPUSH
45769: CALL_OW 1
45773: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45774: LD_ADDR_VAR 0 2
45778: PUSH
45779: LD_INT 0
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: LD_INT 0
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: ST_TO_ADDR
// if sci > 1 then
45797: LD_VAR 0 8
45801: PUSH
45802: LD_INT 1
45804: GREATER
45805: IFFALSE 45833
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45807: LD_ADDR_VAR 0 4
45811: PUSH
45812: LD_VAR 0 4
45816: PUSH
45817: LD_VAR 0 8
45821: PUSH
45822: LD_VAR 0 8
45826: PUSH
45827: LD_INT 1
45829: ARRAY
45830: DIFF
45831: DIFF
45832: ST_TO_ADDR
// if tmp and not sci then
45833: LD_VAR 0 4
45837: PUSH
45838: LD_VAR 0 8
45842: NOT
45843: AND
45844: IFFALSE 45913
// begin sort := SortBySkill ( tmp , 4 ) ;
45846: LD_ADDR_VAR 0 9
45850: PUSH
45851: LD_VAR 0 4
45855: PPUSH
45856: LD_INT 4
45858: PPUSH
45859: CALL 105648 0 2
45863: ST_TO_ADDR
// if sort then
45864: LD_VAR 0 9
45868: IFFALSE 45884
// p := sort [ 1 ] ;
45870: LD_ADDR_VAR 0 11
45874: PUSH
45875: LD_VAR 0 9
45879: PUSH
45880: LD_INT 1
45882: ARRAY
45883: ST_TO_ADDR
// if p then
45884: LD_VAR 0 11
45888: IFFALSE 45913
// result := Replace ( result , 4 , p ) ;
45890: LD_ADDR_VAR 0 2
45894: PUSH
45895: LD_VAR 0 2
45899: PPUSH
45900: LD_INT 4
45902: PPUSH
45903: LD_VAR 0 11
45907: PPUSH
45908: CALL_OW 1
45912: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45913: LD_ADDR_VAR 0 4
45917: PUSH
45918: LD_VAR 0 4
45922: PUSH
45923: LD_VAR 0 7
45927: DIFF
45928: ST_TO_ADDR
// if tmp and mech < 6 then
45929: LD_VAR 0 4
45933: PUSH
45934: LD_VAR 0 7
45938: PUSH
45939: LD_INT 6
45941: LESS
45942: AND
45943: IFFALSE 46131
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45945: LD_ADDR_VAR 0 9
45949: PUSH
45950: LD_VAR 0 4
45954: PUSH
45955: LD_VAR 0 8
45959: PUSH
45960: LD_VAR 0 7
45964: UNION
45965: DIFF
45966: PPUSH
45967: LD_INT 3
45969: PPUSH
45970: CALL 105648 0 2
45974: ST_TO_ADDR
// p := [ ] ;
45975: LD_ADDR_VAR 0 11
45979: PUSH
45980: EMPTY
45981: ST_TO_ADDR
// if sort then
45982: LD_VAR 0 9
45986: IFFALSE 46102
// for i = 1 to 6 - mech do
45988: LD_ADDR_VAR 0 3
45992: PUSH
45993: DOUBLE
45994: LD_INT 1
45996: DEC
45997: ST_TO_ADDR
45998: LD_INT 6
46000: PUSH
46001: LD_VAR 0 7
46005: MINUS
46006: PUSH
46007: FOR_TO
46008: IFFALSE 46100
// begin if i = sort then
46010: LD_VAR 0 3
46014: PUSH
46015: LD_VAR 0 9
46019: EQUAL
46020: IFFALSE 46024
// break ;
46022: GO 46100
// if GetClass ( i ) = 3 then
46024: LD_VAR 0 3
46028: PPUSH
46029: CALL_OW 257
46033: PUSH
46034: LD_INT 3
46036: EQUAL
46037: IFFALSE 46041
// continue ;
46039: GO 46007
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46041: LD_ADDR_VAR 0 11
46045: PUSH
46046: LD_VAR 0 11
46050: PPUSH
46051: LD_VAR 0 11
46055: PUSH
46056: LD_INT 1
46058: PLUS
46059: PPUSH
46060: LD_VAR 0 9
46064: PUSH
46065: LD_VAR 0 3
46069: ARRAY
46070: PPUSH
46071: CALL_OW 2
46075: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46076: LD_ADDR_VAR 0 4
46080: PUSH
46081: LD_VAR 0 4
46085: PUSH
46086: LD_VAR 0 9
46090: PUSH
46091: LD_VAR 0 3
46095: ARRAY
46096: DIFF
46097: ST_TO_ADDR
// end ;
46098: GO 46007
46100: POP
46101: POP
// if p then
46102: LD_VAR 0 11
46106: IFFALSE 46131
// result := Replace ( result , 3 , p ) ;
46108: LD_ADDR_VAR 0 2
46112: PUSH
46113: LD_VAR 0 2
46117: PPUSH
46118: LD_INT 3
46120: PPUSH
46121: LD_VAR 0 11
46125: PPUSH
46126: CALL_OW 1
46130: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46131: LD_ADDR_VAR 0 4
46135: PUSH
46136: LD_VAR 0 4
46140: PUSH
46141: LD_VAR 0 6
46145: DIFF
46146: ST_TO_ADDR
// if tmp and eng < 6 then
46147: LD_VAR 0 4
46151: PUSH
46152: LD_VAR 0 6
46156: PUSH
46157: LD_INT 6
46159: LESS
46160: AND
46161: IFFALSE 46355
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46163: LD_ADDR_VAR 0 9
46167: PUSH
46168: LD_VAR 0 4
46172: PUSH
46173: LD_VAR 0 8
46177: PUSH
46178: LD_VAR 0 7
46182: UNION
46183: PUSH
46184: LD_VAR 0 6
46188: UNION
46189: DIFF
46190: PPUSH
46191: LD_INT 2
46193: PPUSH
46194: CALL 105648 0 2
46198: ST_TO_ADDR
// p := [ ] ;
46199: LD_ADDR_VAR 0 11
46203: PUSH
46204: EMPTY
46205: ST_TO_ADDR
// if sort then
46206: LD_VAR 0 9
46210: IFFALSE 46326
// for i = 1 to 6 - eng do
46212: LD_ADDR_VAR 0 3
46216: PUSH
46217: DOUBLE
46218: LD_INT 1
46220: DEC
46221: ST_TO_ADDR
46222: LD_INT 6
46224: PUSH
46225: LD_VAR 0 6
46229: MINUS
46230: PUSH
46231: FOR_TO
46232: IFFALSE 46324
// begin if i = sort then
46234: LD_VAR 0 3
46238: PUSH
46239: LD_VAR 0 9
46243: EQUAL
46244: IFFALSE 46248
// break ;
46246: GO 46324
// if GetClass ( i ) = 2 then
46248: LD_VAR 0 3
46252: PPUSH
46253: CALL_OW 257
46257: PUSH
46258: LD_INT 2
46260: EQUAL
46261: IFFALSE 46265
// continue ;
46263: GO 46231
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46265: LD_ADDR_VAR 0 11
46269: PUSH
46270: LD_VAR 0 11
46274: PPUSH
46275: LD_VAR 0 11
46279: PUSH
46280: LD_INT 1
46282: PLUS
46283: PPUSH
46284: LD_VAR 0 9
46288: PUSH
46289: LD_VAR 0 3
46293: ARRAY
46294: PPUSH
46295: CALL_OW 2
46299: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46300: LD_ADDR_VAR 0 4
46304: PUSH
46305: LD_VAR 0 4
46309: PUSH
46310: LD_VAR 0 9
46314: PUSH
46315: LD_VAR 0 3
46319: ARRAY
46320: DIFF
46321: ST_TO_ADDR
// end ;
46322: GO 46231
46324: POP
46325: POP
// if p then
46326: LD_VAR 0 11
46330: IFFALSE 46355
// result := Replace ( result , 2 , p ) ;
46332: LD_ADDR_VAR 0 2
46336: PUSH
46337: LD_VAR 0 2
46341: PPUSH
46342: LD_INT 2
46344: PPUSH
46345: LD_VAR 0 11
46349: PPUSH
46350: CALL_OW 1
46354: ST_TO_ADDR
// end ; exit ;
46355: GO 47079
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46357: LD_EXP 128
46361: PUSH
46362: LD_EXP 127
46366: PUSH
46367: LD_VAR 0 1
46371: ARRAY
46372: ARRAY
46373: NOT
46374: PUSH
46375: LD_EXP 101
46379: PUSH
46380: LD_VAR 0 1
46384: ARRAY
46385: PPUSH
46386: LD_INT 30
46388: PUSH
46389: LD_INT 3
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PPUSH
46396: CALL_OW 72
46400: AND
46401: PUSH
46402: LD_EXP 106
46406: PUSH
46407: LD_VAR 0 1
46411: ARRAY
46412: NOT
46413: AND
46414: IFFALSE 47079
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46416: LD_ADDR_EXP 143
46420: PUSH
46421: LD_EXP 143
46425: PPUSH
46426: LD_VAR 0 1
46430: PPUSH
46431: LD_INT 6
46433: PPUSH
46434: CALL_OW 1
46438: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46439: LD_ADDR_VAR 0 2
46443: PUSH
46444: LD_INT 0
46446: PUSH
46447: LD_INT 0
46449: PUSH
46450: LD_INT 0
46452: PUSH
46453: LD_INT 0
46455: PUSH
46456: EMPTY
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: ST_TO_ADDR
// if sci >= 1 then
46462: LD_VAR 0 8
46466: PUSH
46467: LD_INT 1
46469: GREATEREQUAL
46470: IFFALSE 46492
// tmp := tmp diff sci [ 1 ] ;
46472: LD_ADDR_VAR 0 4
46476: PUSH
46477: LD_VAR 0 4
46481: PUSH
46482: LD_VAR 0 8
46486: PUSH
46487: LD_INT 1
46489: ARRAY
46490: DIFF
46491: ST_TO_ADDR
// if tmp and not sci then
46492: LD_VAR 0 4
46496: PUSH
46497: LD_VAR 0 8
46501: NOT
46502: AND
46503: IFFALSE 46572
// begin sort := SortBySkill ( tmp , 4 ) ;
46505: LD_ADDR_VAR 0 9
46509: PUSH
46510: LD_VAR 0 4
46514: PPUSH
46515: LD_INT 4
46517: PPUSH
46518: CALL 105648 0 2
46522: ST_TO_ADDR
// if sort then
46523: LD_VAR 0 9
46527: IFFALSE 46543
// p := sort [ 1 ] ;
46529: LD_ADDR_VAR 0 11
46533: PUSH
46534: LD_VAR 0 9
46538: PUSH
46539: LD_INT 1
46541: ARRAY
46542: ST_TO_ADDR
// if p then
46543: LD_VAR 0 11
46547: IFFALSE 46572
// result := Replace ( result , 4 , p ) ;
46549: LD_ADDR_VAR 0 2
46553: PUSH
46554: LD_VAR 0 2
46558: PPUSH
46559: LD_INT 4
46561: PPUSH
46562: LD_VAR 0 11
46566: PPUSH
46567: CALL_OW 1
46571: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46572: LD_ADDR_VAR 0 4
46576: PUSH
46577: LD_VAR 0 4
46581: PUSH
46582: LD_VAR 0 7
46586: DIFF
46587: ST_TO_ADDR
// if tmp and mech < 6 then
46588: LD_VAR 0 4
46592: PUSH
46593: LD_VAR 0 7
46597: PUSH
46598: LD_INT 6
46600: LESS
46601: AND
46602: IFFALSE 46784
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46604: LD_ADDR_VAR 0 9
46608: PUSH
46609: LD_VAR 0 4
46613: PUSH
46614: LD_VAR 0 7
46618: DIFF
46619: PPUSH
46620: LD_INT 3
46622: PPUSH
46623: CALL 105648 0 2
46627: ST_TO_ADDR
// p := [ ] ;
46628: LD_ADDR_VAR 0 11
46632: PUSH
46633: EMPTY
46634: ST_TO_ADDR
// if sort then
46635: LD_VAR 0 9
46639: IFFALSE 46755
// for i = 1 to 6 - mech do
46641: LD_ADDR_VAR 0 3
46645: PUSH
46646: DOUBLE
46647: LD_INT 1
46649: DEC
46650: ST_TO_ADDR
46651: LD_INT 6
46653: PUSH
46654: LD_VAR 0 7
46658: MINUS
46659: PUSH
46660: FOR_TO
46661: IFFALSE 46753
// begin if i = sort then
46663: LD_VAR 0 3
46667: PUSH
46668: LD_VAR 0 9
46672: EQUAL
46673: IFFALSE 46677
// break ;
46675: GO 46753
// if GetClass ( i ) = 3 then
46677: LD_VAR 0 3
46681: PPUSH
46682: CALL_OW 257
46686: PUSH
46687: LD_INT 3
46689: EQUAL
46690: IFFALSE 46694
// continue ;
46692: GO 46660
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46694: LD_ADDR_VAR 0 11
46698: PUSH
46699: LD_VAR 0 11
46703: PPUSH
46704: LD_VAR 0 11
46708: PUSH
46709: LD_INT 1
46711: PLUS
46712: PPUSH
46713: LD_VAR 0 9
46717: PUSH
46718: LD_VAR 0 3
46722: ARRAY
46723: PPUSH
46724: CALL_OW 2
46728: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46729: LD_ADDR_VAR 0 4
46733: PUSH
46734: LD_VAR 0 4
46738: PUSH
46739: LD_VAR 0 9
46743: PUSH
46744: LD_VAR 0 3
46748: ARRAY
46749: DIFF
46750: ST_TO_ADDR
// end ;
46751: GO 46660
46753: POP
46754: POP
// if p then
46755: LD_VAR 0 11
46759: IFFALSE 46784
// result := Replace ( result , 3 , p ) ;
46761: LD_ADDR_VAR 0 2
46765: PUSH
46766: LD_VAR 0 2
46770: PPUSH
46771: LD_INT 3
46773: PPUSH
46774: LD_VAR 0 11
46778: PPUSH
46779: CALL_OW 1
46783: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46784: LD_ADDR_VAR 0 4
46788: PUSH
46789: LD_VAR 0 4
46793: PUSH
46794: LD_VAR 0 6
46798: DIFF
46799: ST_TO_ADDR
// if tmp and eng < 4 then
46800: LD_VAR 0 4
46804: PUSH
46805: LD_VAR 0 6
46809: PUSH
46810: LD_INT 4
46812: LESS
46813: AND
46814: IFFALSE 47004
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46816: LD_ADDR_VAR 0 9
46820: PUSH
46821: LD_VAR 0 4
46825: PUSH
46826: LD_VAR 0 7
46830: PUSH
46831: LD_VAR 0 6
46835: UNION
46836: DIFF
46837: PPUSH
46838: LD_INT 2
46840: PPUSH
46841: CALL 105648 0 2
46845: ST_TO_ADDR
// p := [ ] ;
46846: LD_ADDR_VAR 0 11
46850: PUSH
46851: EMPTY
46852: ST_TO_ADDR
// if sort then
46853: LD_VAR 0 9
46857: IFFALSE 46973
// for i = 1 to 4 - eng do
46859: LD_ADDR_VAR 0 3
46863: PUSH
46864: DOUBLE
46865: LD_INT 1
46867: DEC
46868: ST_TO_ADDR
46869: LD_INT 4
46871: PUSH
46872: LD_VAR 0 6
46876: MINUS
46877: PUSH
46878: FOR_TO
46879: IFFALSE 46971
// begin if i = sort then
46881: LD_VAR 0 3
46885: PUSH
46886: LD_VAR 0 9
46890: EQUAL
46891: IFFALSE 46895
// break ;
46893: GO 46971
// if GetClass ( i ) = 2 then
46895: LD_VAR 0 3
46899: PPUSH
46900: CALL_OW 257
46904: PUSH
46905: LD_INT 2
46907: EQUAL
46908: IFFALSE 46912
// continue ;
46910: GO 46878
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46912: LD_ADDR_VAR 0 11
46916: PUSH
46917: LD_VAR 0 11
46921: PPUSH
46922: LD_VAR 0 11
46926: PUSH
46927: LD_INT 1
46929: PLUS
46930: PPUSH
46931: LD_VAR 0 9
46935: PUSH
46936: LD_VAR 0 3
46940: ARRAY
46941: PPUSH
46942: CALL_OW 2
46946: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46947: LD_ADDR_VAR 0 4
46951: PUSH
46952: LD_VAR 0 4
46956: PUSH
46957: LD_VAR 0 9
46961: PUSH
46962: LD_VAR 0 3
46966: ARRAY
46967: DIFF
46968: ST_TO_ADDR
// end ;
46969: GO 46878
46971: POP
46972: POP
// if p then
46973: LD_VAR 0 11
46977: IFFALSE 47002
// result := Replace ( result , 2 , p ) ;
46979: LD_ADDR_VAR 0 2
46983: PUSH
46984: LD_VAR 0 2
46988: PPUSH
46989: LD_INT 2
46991: PPUSH
46992: LD_VAR 0 11
46996: PPUSH
46997: CALL_OW 1
47001: ST_TO_ADDR
// end else
47002: GO 47048
// for i = eng downto 5 do
47004: LD_ADDR_VAR 0 3
47008: PUSH
47009: DOUBLE
47010: LD_VAR 0 6
47014: INC
47015: ST_TO_ADDR
47016: LD_INT 5
47018: PUSH
47019: FOR_DOWNTO
47020: IFFALSE 47046
// tmp := tmp union eng [ i ] ;
47022: LD_ADDR_VAR 0 4
47026: PUSH
47027: LD_VAR 0 4
47031: PUSH
47032: LD_VAR 0 6
47036: PUSH
47037: LD_VAR 0 3
47041: ARRAY
47042: UNION
47043: ST_TO_ADDR
47044: GO 47019
47046: POP
47047: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47048: LD_ADDR_VAR 0 2
47052: PUSH
47053: LD_VAR 0 2
47057: PPUSH
47058: LD_INT 1
47060: PPUSH
47061: LD_VAR 0 4
47065: PUSH
47066: LD_VAR 0 5
47070: DIFF
47071: PPUSH
47072: CALL_OW 1
47076: ST_TO_ADDR
// exit ;
47077: GO 47079
// end ; end ;
47079: LD_VAR 0 2
47083: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47084: LD_INT 0
47086: PPUSH
47087: PPUSH
47088: PPUSH
// if not mc_bases then
47089: LD_EXP 101
47093: NOT
47094: IFFALSE 47098
// exit ;
47096: GO 47240
// for i = 1 to mc_bases do
47098: LD_ADDR_VAR 0 2
47102: PUSH
47103: DOUBLE
47104: LD_INT 1
47106: DEC
47107: ST_TO_ADDR
47108: LD_EXP 101
47112: PUSH
47113: FOR_TO
47114: IFFALSE 47231
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47116: LD_ADDR_VAR 0 3
47120: PUSH
47121: LD_EXP 101
47125: PUSH
47126: LD_VAR 0 2
47130: ARRAY
47131: PPUSH
47132: LD_INT 21
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: LD_INT 2
47147: PUSH
47148: LD_INT 30
47150: PUSH
47151: LD_INT 29
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PUSH
47158: LD_INT 30
47160: PUSH
47161: LD_INT 30
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: LIST
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 3
47179: PUSH
47180: LD_INT 24
47182: PUSH
47183: LD_INT 1000
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: LIST
47198: PPUSH
47199: CALL_OW 72
47203: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47204: LD_ADDR_EXP 102
47208: PUSH
47209: LD_EXP 102
47213: PPUSH
47214: LD_VAR 0 2
47218: PPUSH
47219: LD_VAR 0 3
47223: PPUSH
47224: CALL_OW 1
47228: ST_TO_ADDR
// end ;
47229: GO 47113
47231: POP
47232: POP
// RaiseSailEvent ( 101 ) ;
47233: LD_INT 101
47235: PPUSH
47236: CALL_OW 427
// end ;
47240: LD_VAR 0 1
47244: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47245: LD_INT 0
47247: PPUSH
47248: PPUSH
47249: PPUSH
47250: PPUSH
47251: PPUSH
47252: PPUSH
47253: PPUSH
// if not mc_bases then
47254: LD_EXP 101
47258: NOT
47259: IFFALSE 47263
// exit ;
47261: GO 47825
// for i = 1 to mc_bases do
47263: LD_ADDR_VAR 0 2
47267: PUSH
47268: DOUBLE
47269: LD_INT 1
47271: DEC
47272: ST_TO_ADDR
47273: LD_EXP 101
47277: PUSH
47278: FOR_TO
47279: IFFALSE 47816
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47281: LD_ADDR_VAR 0 5
47285: PUSH
47286: LD_EXP 101
47290: PUSH
47291: LD_VAR 0 2
47295: ARRAY
47296: PUSH
47297: LD_EXP 130
47301: PUSH
47302: LD_VAR 0 2
47306: ARRAY
47307: UNION
47308: PPUSH
47309: LD_INT 21
47311: PUSH
47312: LD_INT 1
47314: PUSH
47315: EMPTY
47316: LIST
47317: LIST
47318: PUSH
47319: LD_INT 1
47321: PUSH
47322: LD_INT 3
47324: PUSH
47325: LD_INT 54
47327: PUSH
47328: EMPTY
47329: LIST
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 3
47337: PUSH
47338: LD_INT 24
47340: PUSH
47341: LD_INT 1000
47343: PUSH
47344: EMPTY
47345: LIST
47346: LIST
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: LIST
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PPUSH
47361: CALL_OW 72
47365: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47366: LD_ADDR_VAR 0 6
47370: PUSH
47371: LD_EXP 101
47375: PUSH
47376: LD_VAR 0 2
47380: ARRAY
47381: PPUSH
47382: LD_INT 21
47384: PUSH
47385: LD_INT 1
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 1
47394: PUSH
47395: LD_INT 3
47397: PUSH
47398: LD_INT 54
47400: PUSH
47401: EMPTY
47402: LIST
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 3
47410: PUSH
47411: LD_INT 24
47413: PUSH
47414: LD_INT 250
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: LIST
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PPUSH
47434: CALL_OW 72
47438: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_VAR 0 5
47448: PUSH
47449: LD_VAR 0 6
47453: DIFF
47454: ST_TO_ADDR
// if not need_heal_1 then
47455: LD_VAR 0 6
47459: NOT
47460: IFFALSE 47493
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47462: LD_ADDR_EXP 104
47466: PUSH
47467: LD_EXP 104
47471: PPUSH
47472: LD_VAR 0 2
47476: PUSH
47477: LD_INT 1
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: PPUSH
47484: EMPTY
47485: PPUSH
47486: CALL 74404 0 3
47490: ST_TO_ADDR
47491: GO 47563
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47493: LD_ADDR_EXP 104
47497: PUSH
47498: LD_EXP 104
47502: PPUSH
47503: LD_VAR 0 2
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PPUSH
47515: LD_EXP 104
47519: PUSH
47520: LD_VAR 0 2
47524: ARRAY
47525: PUSH
47526: LD_INT 1
47528: ARRAY
47529: PPUSH
47530: LD_INT 3
47532: PUSH
47533: LD_INT 24
47535: PUSH
47536: LD_INT 1000
47538: PUSH
47539: EMPTY
47540: LIST
47541: LIST
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PPUSH
47547: CALL_OW 72
47551: PUSH
47552: LD_VAR 0 6
47556: UNION
47557: PPUSH
47558: CALL 74404 0 3
47562: ST_TO_ADDR
// if not need_heal_2 then
47563: LD_VAR 0 7
47567: NOT
47568: IFFALSE 47601
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47570: LD_ADDR_EXP 104
47574: PUSH
47575: LD_EXP 104
47579: PPUSH
47580: LD_VAR 0 2
47584: PUSH
47585: LD_INT 2
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PPUSH
47592: EMPTY
47593: PPUSH
47594: CALL 74404 0 3
47598: ST_TO_ADDR
47599: GO 47633
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47601: LD_ADDR_EXP 104
47605: PUSH
47606: LD_EXP 104
47610: PPUSH
47611: LD_VAR 0 2
47615: PUSH
47616: LD_INT 2
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PPUSH
47623: LD_VAR 0 7
47627: PPUSH
47628: CALL 74404 0 3
47632: ST_TO_ADDR
// if need_heal_2 then
47633: LD_VAR 0 7
47637: IFFALSE 47798
// for j in need_heal_2 do
47639: LD_ADDR_VAR 0 3
47643: PUSH
47644: LD_VAR 0 7
47648: PUSH
47649: FOR_IN
47650: IFFALSE 47796
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47652: LD_ADDR_VAR 0 5
47656: PUSH
47657: LD_EXP 101
47661: PUSH
47662: LD_VAR 0 2
47666: ARRAY
47667: PPUSH
47668: LD_INT 2
47670: PUSH
47671: LD_INT 30
47673: PUSH
47674: LD_INT 6
47676: PUSH
47677: EMPTY
47678: LIST
47679: LIST
47680: PUSH
47681: LD_INT 30
47683: PUSH
47684: LD_INT 7
47686: PUSH
47687: EMPTY
47688: LIST
47689: LIST
47690: PUSH
47691: LD_INT 30
47693: PUSH
47694: LD_INT 8
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: PUSH
47701: LD_INT 30
47703: PUSH
47704: LD_INT 0
47706: PUSH
47707: EMPTY
47708: LIST
47709: LIST
47710: PUSH
47711: LD_INT 30
47713: PUSH
47714: LD_INT 1
47716: PUSH
47717: EMPTY
47718: LIST
47719: LIST
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: PPUSH
47729: CALL_OW 72
47733: ST_TO_ADDR
// if tmp then
47734: LD_VAR 0 5
47738: IFFALSE 47794
// begin k := NearestUnitToUnit ( tmp , j ) ;
47740: LD_ADDR_VAR 0 4
47744: PUSH
47745: LD_VAR 0 5
47749: PPUSH
47750: LD_VAR 0 3
47754: PPUSH
47755: CALL_OW 74
47759: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47760: LD_VAR 0 3
47764: PPUSH
47765: LD_VAR 0 4
47769: PPUSH
47770: CALL_OW 296
47774: PUSH
47775: LD_INT 5
47777: GREATER
47778: IFFALSE 47794
// ComMoveToNearbyEntrance ( j , k ) ;
47780: LD_VAR 0 3
47784: PPUSH
47785: LD_VAR 0 4
47789: PPUSH
47790: CALL 108021 0 2
// end ; end ;
47794: GO 47649
47796: POP
47797: POP
// if not need_heal_1 and not need_heal_2 then
47798: LD_VAR 0 6
47802: NOT
47803: PUSH
47804: LD_VAR 0 7
47808: NOT
47809: AND
47810: IFFALSE 47814
// continue ;
47812: GO 47278
// end ;
47814: GO 47278
47816: POP
47817: POP
// RaiseSailEvent ( 102 ) ;
47818: LD_INT 102
47820: PPUSH
47821: CALL_OW 427
// end ;
47825: LD_VAR 0 1
47829: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47830: LD_INT 0
47832: PPUSH
47833: PPUSH
47834: PPUSH
47835: PPUSH
47836: PPUSH
47837: PPUSH
47838: PPUSH
47839: PPUSH
// if not mc_bases then
47840: LD_EXP 101
47844: NOT
47845: IFFALSE 47849
// exit ;
47847: GO 48760
// for i = 1 to mc_bases do
47849: LD_ADDR_VAR 0 2
47853: PUSH
47854: DOUBLE
47855: LD_INT 1
47857: DEC
47858: ST_TO_ADDR
47859: LD_EXP 101
47863: PUSH
47864: FOR_TO
47865: IFFALSE 48758
// begin if not mc_building_need_repair [ i ] then
47867: LD_EXP 102
47871: PUSH
47872: LD_VAR 0 2
47876: ARRAY
47877: NOT
47878: IFFALSE 48063
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47880: LD_ADDR_VAR 0 6
47884: PUSH
47885: LD_EXP 120
47889: PUSH
47890: LD_VAR 0 2
47894: ARRAY
47895: PPUSH
47896: LD_INT 3
47898: PUSH
47899: LD_INT 24
47901: PUSH
47902: LD_INT 1000
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 2
47915: PUSH
47916: LD_INT 34
47918: PUSH
47919: LD_INT 13
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 34
47928: PUSH
47929: LD_INT 52
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 34
47938: PUSH
47939: LD_INT 88
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PPUSH
47956: CALL_OW 72
47960: ST_TO_ADDR
// if cranes then
47961: LD_VAR 0 6
47965: IFFALSE 48027
// for j in cranes do
47967: LD_ADDR_VAR 0 3
47971: PUSH
47972: LD_VAR 0 6
47976: PUSH
47977: FOR_IN
47978: IFFALSE 48025
// if not IsInArea ( j , mc_parking [ i ] ) then
47980: LD_VAR 0 3
47984: PPUSH
47985: LD_EXP 125
47989: PUSH
47990: LD_VAR 0 2
47994: ARRAY
47995: PPUSH
47996: CALL_OW 308
48000: NOT
48001: IFFALSE 48023
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48003: LD_VAR 0 3
48007: PPUSH
48008: LD_EXP 125
48012: PUSH
48013: LD_VAR 0 2
48017: ARRAY
48018: PPUSH
48019: CALL_OW 113
48023: GO 47977
48025: POP
48026: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48027: LD_ADDR_EXP 103
48031: PUSH
48032: LD_EXP 103
48036: PPUSH
48037: LD_VAR 0 2
48041: PPUSH
48042: EMPTY
48043: PPUSH
48044: CALL_OW 1
48048: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48049: LD_VAR 0 2
48053: PPUSH
48054: LD_INT 101
48056: PPUSH
48057: CALL 42903 0 2
// continue ;
48061: GO 47864
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48063: LD_ADDR_EXP 107
48067: PUSH
48068: LD_EXP 107
48072: PPUSH
48073: LD_VAR 0 2
48077: PPUSH
48078: EMPTY
48079: PPUSH
48080: CALL_OW 1
48084: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48085: LD_VAR 0 2
48089: PPUSH
48090: LD_INT 103
48092: PPUSH
48093: CALL 42903 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48097: LD_ADDR_VAR 0 5
48101: PUSH
48102: LD_EXP 101
48106: PUSH
48107: LD_VAR 0 2
48111: ARRAY
48112: PUSH
48113: LD_EXP 130
48117: PUSH
48118: LD_VAR 0 2
48122: ARRAY
48123: UNION
48124: PPUSH
48125: LD_INT 2
48127: PUSH
48128: LD_INT 25
48130: PUSH
48131: LD_INT 2
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: PUSH
48138: LD_INT 25
48140: PUSH
48141: LD_INT 16
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: EMPTY
48149: LIST
48150: LIST
48151: LIST
48152: PUSH
48153: EMPTY
48154: LIST
48155: PPUSH
48156: CALL_OW 72
48160: ST_TO_ADDR
// if mc_need_heal [ i ] then
48161: LD_EXP 104
48165: PUSH
48166: LD_VAR 0 2
48170: ARRAY
48171: IFFALSE 48215
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48173: LD_ADDR_VAR 0 5
48177: PUSH
48178: LD_VAR 0 5
48182: PUSH
48183: LD_EXP 104
48187: PUSH
48188: LD_VAR 0 2
48192: ARRAY
48193: PUSH
48194: LD_INT 1
48196: ARRAY
48197: PUSH
48198: LD_EXP 104
48202: PUSH
48203: LD_VAR 0 2
48207: ARRAY
48208: PUSH
48209: LD_INT 2
48211: ARRAY
48212: UNION
48213: DIFF
48214: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48215: LD_ADDR_VAR 0 6
48219: PUSH
48220: LD_EXP 120
48224: PUSH
48225: LD_VAR 0 2
48229: ARRAY
48230: PPUSH
48231: LD_INT 2
48233: PUSH
48234: LD_INT 34
48236: PUSH
48237: LD_INT 13
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: PUSH
48244: LD_INT 34
48246: PUSH
48247: LD_INT 52
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 34
48256: PUSH
48257: LD_INT 88
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: PPUSH
48270: CALL_OW 72
48274: ST_TO_ADDR
// if cranes then
48275: LD_VAR 0 6
48279: IFFALSE 48447
// begin for j in cranes do
48281: LD_ADDR_VAR 0 3
48285: PUSH
48286: LD_VAR 0 6
48290: PUSH
48291: FOR_IN
48292: IFFALSE 48445
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48294: LD_VAR 0 3
48298: PPUSH
48299: CALL_OW 256
48303: PUSH
48304: LD_INT 1000
48306: EQUAL
48307: PUSH
48308: LD_VAR 0 3
48312: PPUSH
48313: CALL_OW 314
48317: NOT
48318: AND
48319: IFFALSE 48385
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48321: LD_ADDR_VAR 0 8
48325: PUSH
48326: LD_EXP 102
48330: PUSH
48331: LD_VAR 0 2
48335: ARRAY
48336: PPUSH
48337: LD_VAR 0 3
48341: PPUSH
48342: CALL_OW 74
48346: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48347: LD_VAR 0 8
48351: PPUSH
48352: LD_INT 16
48354: PPUSH
48355: CALL 77369 0 2
48359: PUSH
48360: LD_INT 4
48362: ARRAY
48363: PUSH
48364: LD_INT 10
48366: LESS
48367: IFFALSE 48383
// ComRepairBuilding ( j , to_repair ) ;
48369: LD_VAR 0 3
48373: PPUSH
48374: LD_VAR 0 8
48378: PPUSH
48379: CALL_OW 130
// end else
48383: GO 48443
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48385: LD_VAR 0 3
48389: PPUSH
48390: CALL_OW 256
48394: PUSH
48395: LD_INT 500
48397: LESS
48398: PUSH
48399: LD_VAR 0 3
48403: PPUSH
48404: LD_EXP 125
48408: PUSH
48409: LD_VAR 0 2
48413: ARRAY
48414: PPUSH
48415: CALL_OW 308
48419: NOT
48420: AND
48421: IFFALSE 48443
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48423: LD_VAR 0 3
48427: PPUSH
48428: LD_EXP 125
48432: PUSH
48433: LD_VAR 0 2
48437: ARRAY
48438: PPUSH
48439: CALL_OW 113
// end ;
48443: GO 48291
48445: POP
48446: POP
// end ; if tmp > 3 then
48447: LD_VAR 0 5
48451: PUSH
48452: LD_INT 3
48454: GREATER
48455: IFFALSE 48475
// tmp := ShrinkArray ( tmp , 4 ) ;
48457: LD_ADDR_VAR 0 5
48461: PUSH
48462: LD_VAR 0 5
48466: PPUSH
48467: LD_INT 4
48469: PPUSH
48470: CALL 107459 0 2
48474: ST_TO_ADDR
// if not tmp then
48475: LD_VAR 0 5
48479: NOT
48480: IFFALSE 48484
// continue ;
48482: GO 47864
// for j in tmp do
48484: LD_ADDR_VAR 0 3
48488: PUSH
48489: LD_VAR 0 5
48493: PUSH
48494: FOR_IN
48495: IFFALSE 48754
// begin if IsInUnit ( j ) then
48497: LD_VAR 0 3
48501: PPUSH
48502: CALL_OW 310
48506: IFFALSE 48517
// ComExitBuilding ( j ) ;
48508: LD_VAR 0 3
48512: PPUSH
48513: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48517: LD_VAR 0 3
48521: PUSH
48522: LD_EXP 103
48526: PUSH
48527: LD_VAR 0 2
48531: ARRAY
48532: IN
48533: NOT
48534: IFFALSE 48592
// begin SetTag ( j , 101 ) ;
48536: LD_VAR 0 3
48540: PPUSH
48541: LD_INT 101
48543: PPUSH
48544: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48548: LD_ADDR_EXP 103
48552: PUSH
48553: LD_EXP 103
48557: PPUSH
48558: LD_VAR 0 2
48562: PUSH
48563: LD_EXP 103
48567: PUSH
48568: LD_VAR 0 2
48572: ARRAY
48573: PUSH
48574: LD_INT 1
48576: PLUS
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: PPUSH
48582: LD_VAR 0 3
48586: PPUSH
48587: CALL 74404 0 3
48591: ST_TO_ADDR
// end ; wait ( 1 ) ;
48592: LD_INT 1
48594: PPUSH
48595: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48599: LD_ADDR_VAR 0 7
48603: PUSH
48604: LD_EXP 102
48608: PUSH
48609: LD_VAR 0 2
48613: ARRAY
48614: ST_TO_ADDR
// if mc_scan [ i ] then
48615: LD_EXP 124
48619: PUSH
48620: LD_VAR 0 2
48624: ARRAY
48625: IFFALSE 48687
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48627: LD_ADDR_VAR 0 7
48631: PUSH
48632: LD_EXP 102
48636: PUSH
48637: LD_VAR 0 2
48641: ARRAY
48642: PPUSH
48643: LD_INT 3
48645: PUSH
48646: LD_INT 30
48648: PUSH
48649: LD_INT 32
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: PUSH
48656: LD_INT 30
48658: PUSH
48659: LD_INT 33
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PUSH
48666: LD_INT 30
48668: PUSH
48669: LD_INT 31
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: EMPTY
48677: LIST
48678: LIST
48679: LIST
48680: LIST
48681: PPUSH
48682: CALL_OW 72
48686: ST_TO_ADDR
// if not to_repair_tmp then
48687: LD_VAR 0 7
48691: NOT
48692: IFFALSE 48696
// continue ;
48694: GO 48494
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48696: LD_ADDR_VAR 0 8
48700: PUSH
48701: LD_VAR 0 7
48705: PPUSH
48706: LD_VAR 0 3
48710: PPUSH
48711: CALL_OW 74
48715: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48716: LD_VAR 0 8
48720: PPUSH
48721: LD_INT 16
48723: PPUSH
48724: CALL 77369 0 2
48728: PUSH
48729: LD_INT 4
48731: ARRAY
48732: PUSH
48733: LD_INT 14
48735: LESS
48736: IFFALSE 48752
// ComRepairBuilding ( j , to_repair ) ;
48738: LD_VAR 0 3
48742: PPUSH
48743: LD_VAR 0 8
48747: PPUSH
48748: CALL_OW 130
// end ;
48752: GO 48494
48754: POP
48755: POP
// end ;
48756: GO 47864
48758: POP
48759: POP
// end ;
48760: LD_VAR 0 1
48764: RET
// export function MC_Heal ; var i , j , tmp ; begin
48765: LD_INT 0
48767: PPUSH
48768: PPUSH
48769: PPUSH
48770: PPUSH
// if not mc_bases then
48771: LD_EXP 101
48775: NOT
48776: IFFALSE 48780
// exit ;
48778: GO 49182
// for i = 1 to mc_bases do
48780: LD_ADDR_VAR 0 2
48784: PUSH
48785: DOUBLE
48786: LD_INT 1
48788: DEC
48789: ST_TO_ADDR
48790: LD_EXP 101
48794: PUSH
48795: FOR_TO
48796: IFFALSE 49180
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48798: LD_EXP 104
48802: PUSH
48803: LD_VAR 0 2
48807: ARRAY
48808: PUSH
48809: LD_INT 1
48811: ARRAY
48812: NOT
48813: PUSH
48814: LD_EXP 104
48818: PUSH
48819: LD_VAR 0 2
48823: ARRAY
48824: PUSH
48825: LD_INT 2
48827: ARRAY
48828: NOT
48829: AND
48830: IFFALSE 48868
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48832: LD_ADDR_EXP 105
48836: PUSH
48837: LD_EXP 105
48841: PPUSH
48842: LD_VAR 0 2
48846: PPUSH
48847: EMPTY
48848: PPUSH
48849: CALL_OW 1
48853: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48854: LD_VAR 0 2
48858: PPUSH
48859: LD_INT 102
48861: PPUSH
48862: CALL 42903 0 2
// continue ;
48866: GO 48795
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48868: LD_ADDR_VAR 0 4
48872: PUSH
48873: LD_EXP 101
48877: PUSH
48878: LD_VAR 0 2
48882: ARRAY
48883: PPUSH
48884: LD_INT 25
48886: PUSH
48887: LD_INT 4
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: PPUSH
48894: CALL_OW 72
48898: ST_TO_ADDR
// if not tmp then
48899: LD_VAR 0 4
48903: NOT
48904: IFFALSE 48908
// continue ;
48906: GO 48795
// if mc_taming [ i ] then
48908: LD_EXP 132
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: IFFALSE 48942
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48920: LD_ADDR_EXP 132
48924: PUSH
48925: LD_EXP 132
48929: PPUSH
48930: LD_VAR 0 2
48934: PPUSH
48935: EMPTY
48936: PPUSH
48937: CALL_OW 1
48941: ST_TO_ADDR
// for j in tmp do
48942: LD_ADDR_VAR 0 3
48946: PUSH
48947: LD_VAR 0 4
48951: PUSH
48952: FOR_IN
48953: IFFALSE 49176
// begin if IsInUnit ( j ) then
48955: LD_VAR 0 3
48959: PPUSH
48960: CALL_OW 310
48964: IFFALSE 48975
// ComExitBuilding ( j ) ;
48966: LD_VAR 0 3
48970: PPUSH
48971: CALL_OW 122
// if not j in mc_healers [ i ] then
48975: LD_VAR 0 3
48979: PUSH
48980: LD_EXP 105
48984: PUSH
48985: LD_VAR 0 2
48989: ARRAY
48990: IN
48991: NOT
48992: IFFALSE 49038
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48994: LD_ADDR_EXP 105
48998: PUSH
48999: LD_EXP 105
49003: PPUSH
49004: LD_VAR 0 2
49008: PUSH
49009: LD_EXP 105
49013: PUSH
49014: LD_VAR 0 2
49018: ARRAY
49019: PUSH
49020: LD_INT 1
49022: PLUS
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PPUSH
49028: LD_VAR 0 3
49032: PPUSH
49033: CALL 74404 0 3
49037: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49038: LD_VAR 0 3
49042: PPUSH
49043: CALL_OW 110
49047: PUSH
49048: LD_INT 102
49050: NONEQUAL
49051: IFFALSE 49065
// SetTag ( j , 102 ) ;
49053: LD_VAR 0 3
49057: PPUSH
49058: LD_INT 102
49060: PPUSH
49061: CALL_OW 109
// Wait ( 3 ) ;
49065: LD_INT 3
49067: PPUSH
49068: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49072: LD_EXP 104
49076: PUSH
49077: LD_VAR 0 2
49081: ARRAY
49082: PUSH
49083: LD_INT 1
49085: ARRAY
49086: IFFALSE 49118
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49088: LD_VAR 0 3
49092: PPUSH
49093: LD_EXP 104
49097: PUSH
49098: LD_VAR 0 2
49102: ARRAY
49103: PUSH
49104: LD_INT 1
49106: ARRAY
49107: PUSH
49108: LD_INT 1
49110: ARRAY
49111: PPUSH
49112: CALL_OW 128
49116: GO 49174
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49118: LD_VAR 0 3
49122: PPUSH
49123: CALL_OW 314
49127: NOT
49128: PUSH
49129: LD_EXP 104
49133: PUSH
49134: LD_VAR 0 2
49138: ARRAY
49139: PUSH
49140: LD_INT 2
49142: ARRAY
49143: AND
49144: IFFALSE 49174
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49146: LD_VAR 0 3
49150: PPUSH
49151: LD_EXP 104
49155: PUSH
49156: LD_VAR 0 2
49160: ARRAY
49161: PUSH
49162: LD_INT 2
49164: ARRAY
49165: PUSH
49166: LD_INT 1
49168: ARRAY
49169: PPUSH
49170: CALL_OW 128
// end ;
49174: GO 48952
49176: POP
49177: POP
// end ;
49178: GO 48795
49180: POP
49181: POP
// end ;
49182: LD_VAR 0 1
49186: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49187: LD_INT 0
49189: PPUSH
49190: PPUSH
49191: PPUSH
49192: PPUSH
49193: PPUSH
49194: PPUSH
// if not mc_bases then
49195: LD_EXP 101
49199: NOT
49200: IFFALSE 49204
// exit ;
49202: GO 50367
// for i = 1 to mc_bases do
49204: LD_ADDR_VAR 0 2
49208: PUSH
49209: DOUBLE
49210: LD_INT 1
49212: DEC
49213: ST_TO_ADDR
49214: LD_EXP 101
49218: PUSH
49219: FOR_TO
49220: IFFALSE 50365
// begin if mc_scan [ i ] then
49222: LD_EXP 124
49226: PUSH
49227: LD_VAR 0 2
49231: ARRAY
49232: IFFALSE 49236
// continue ;
49234: GO 49219
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49236: LD_EXP 106
49240: PUSH
49241: LD_VAR 0 2
49245: ARRAY
49246: NOT
49247: PUSH
49248: LD_EXP 108
49252: PUSH
49253: LD_VAR 0 2
49257: ARRAY
49258: NOT
49259: AND
49260: PUSH
49261: LD_EXP 107
49265: PUSH
49266: LD_VAR 0 2
49270: ARRAY
49271: AND
49272: IFFALSE 49310
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49274: LD_ADDR_EXP 107
49278: PUSH
49279: LD_EXP 107
49283: PPUSH
49284: LD_VAR 0 2
49288: PPUSH
49289: EMPTY
49290: PPUSH
49291: CALL_OW 1
49295: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49296: LD_VAR 0 2
49300: PPUSH
49301: LD_INT 103
49303: PPUSH
49304: CALL 42903 0 2
// continue ;
49308: GO 49219
// end ; if mc_construct_list [ i ] then
49310: LD_EXP 108
49314: PUSH
49315: LD_VAR 0 2
49319: ARRAY
49320: IFFALSE 49540
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49322: LD_ADDR_VAR 0 5
49326: PUSH
49327: LD_EXP 101
49331: PUSH
49332: LD_VAR 0 2
49336: ARRAY
49337: PPUSH
49338: LD_INT 25
49340: PUSH
49341: LD_INT 2
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PPUSH
49348: CALL_OW 72
49352: PUSH
49353: LD_EXP 103
49357: PUSH
49358: LD_VAR 0 2
49362: ARRAY
49363: DIFF
49364: ST_TO_ADDR
// if not tmp then
49365: LD_VAR 0 5
49369: NOT
49370: IFFALSE 49374
// continue ;
49372: GO 49219
// for j in tmp do
49374: LD_ADDR_VAR 0 3
49378: PUSH
49379: LD_VAR 0 5
49383: PUSH
49384: FOR_IN
49385: IFFALSE 49536
// begin if not mc_builders [ i ] then
49387: LD_EXP 107
49391: PUSH
49392: LD_VAR 0 2
49396: ARRAY
49397: NOT
49398: IFFALSE 49456
// begin SetTag ( j , 103 ) ;
49400: LD_VAR 0 3
49404: PPUSH
49405: LD_INT 103
49407: PPUSH
49408: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49412: LD_ADDR_EXP 107
49416: PUSH
49417: LD_EXP 107
49421: PPUSH
49422: LD_VAR 0 2
49426: PUSH
49427: LD_EXP 107
49431: PUSH
49432: LD_VAR 0 2
49436: ARRAY
49437: PUSH
49438: LD_INT 1
49440: PLUS
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: PPUSH
49446: LD_VAR 0 3
49450: PPUSH
49451: CALL 74404 0 3
49455: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49456: LD_VAR 0 3
49460: PPUSH
49461: CALL_OW 310
49465: IFFALSE 49476
// ComExitBuilding ( j ) ;
49467: LD_VAR 0 3
49471: PPUSH
49472: CALL_OW 122
// wait ( 3 ) ;
49476: LD_INT 3
49478: PPUSH
49479: CALL_OW 67
// if not mc_construct_list [ i ] then
49483: LD_EXP 108
49487: PUSH
49488: LD_VAR 0 2
49492: ARRAY
49493: NOT
49494: IFFALSE 49498
// break ;
49496: GO 49536
// if not HasTask ( j ) then
49498: LD_VAR 0 3
49502: PPUSH
49503: CALL_OW 314
49507: NOT
49508: IFFALSE 49534
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49510: LD_VAR 0 3
49514: PPUSH
49515: LD_EXP 108
49519: PUSH
49520: LD_VAR 0 2
49524: ARRAY
49525: PUSH
49526: LD_INT 1
49528: ARRAY
49529: PPUSH
49530: CALL 77642 0 2
// end ;
49534: GO 49384
49536: POP
49537: POP
// end else
49538: GO 50363
// if mc_build_list [ i ] then
49540: LD_EXP 106
49544: PUSH
49545: LD_VAR 0 2
49549: ARRAY
49550: IFFALSE 50363
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49552: LD_EXP 106
49556: PUSH
49557: LD_VAR 0 2
49561: ARRAY
49562: PUSH
49563: LD_INT 1
49565: ARRAY
49566: PUSH
49567: LD_INT 1
49569: ARRAY
49570: PPUSH
49571: CALL 77466 0 1
49575: PUSH
49576: LD_EXP 101
49580: PUSH
49581: LD_VAR 0 2
49585: ARRAY
49586: PPUSH
49587: LD_INT 2
49589: PUSH
49590: LD_INT 30
49592: PUSH
49593: LD_INT 2
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: PUSH
49600: LD_INT 30
49602: PUSH
49603: LD_INT 3
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: EMPTY
49611: LIST
49612: LIST
49613: LIST
49614: PPUSH
49615: CALL_OW 72
49619: NOT
49620: AND
49621: IFFALSE 49726
// begin for j = 1 to mc_build_list [ i ] do
49623: LD_ADDR_VAR 0 3
49627: PUSH
49628: DOUBLE
49629: LD_INT 1
49631: DEC
49632: ST_TO_ADDR
49633: LD_EXP 106
49637: PUSH
49638: LD_VAR 0 2
49642: ARRAY
49643: PUSH
49644: FOR_TO
49645: IFFALSE 49724
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49647: LD_EXP 106
49651: PUSH
49652: LD_VAR 0 2
49656: ARRAY
49657: PUSH
49658: LD_VAR 0 3
49662: ARRAY
49663: PUSH
49664: LD_INT 1
49666: ARRAY
49667: PUSH
49668: LD_INT 2
49670: EQUAL
49671: IFFALSE 49722
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49673: LD_ADDR_EXP 106
49677: PUSH
49678: LD_EXP 106
49682: PPUSH
49683: LD_VAR 0 2
49687: PPUSH
49688: LD_EXP 106
49692: PUSH
49693: LD_VAR 0 2
49697: ARRAY
49698: PPUSH
49699: LD_VAR 0 3
49703: PPUSH
49704: LD_INT 1
49706: PPUSH
49707: LD_INT 0
49709: PPUSH
49710: CALL 73822 0 4
49714: PPUSH
49715: CALL_OW 1
49719: ST_TO_ADDR
// break ;
49720: GO 49724
// end ;
49722: GO 49644
49724: POP
49725: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49726: LD_ADDR_VAR 0 6
49730: PUSH
49731: LD_EXP 101
49735: PUSH
49736: LD_VAR 0 2
49740: ARRAY
49741: PPUSH
49742: LD_INT 2
49744: PUSH
49745: LD_INT 30
49747: PUSH
49748: LD_INT 0
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: LD_INT 30
49757: PUSH
49758: LD_INT 1
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: LIST
49769: PPUSH
49770: CALL_OW 72
49774: ST_TO_ADDR
// for k := 1 to depot do
49775: LD_ADDR_VAR 0 4
49779: PUSH
49780: DOUBLE
49781: LD_INT 1
49783: DEC
49784: ST_TO_ADDR
49785: LD_VAR 0 6
49789: PUSH
49790: FOR_TO
49791: IFFALSE 50361
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49793: LD_EXP 106
49797: PUSH
49798: LD_VAR 0 2
49802: ARRAY
49803: PUSH
49804: LD_INT 1
49806: ARRAY
49807: PUSH
49808: LD_INT 1
49810: ARRAY
49811: PUSH
49812: LD_INT 0
49814: EQUAL
49815: PUSH
49816: LD_VAR 0 6
49820: PUSH
49821: LD_VAR 0 4
49825: ARRAY
49826: PPUSH
49827: LD_EXP 106
49831: PUSH
49832: LD_VAR 0 2
49836: ARRAY
49837: PUSH
49838: LD_INT 1
49840: ARRAY
49841: PUSH
49842: LD_INT 1
49844: ARRAY
49845: PPUSH
49846: LD_EXP 106
49850: PUSH
49851: LD_VAR 0 2
49855: ARRAY
49856: PUSH
49857: LD_INT 1
49859: ARRAY
49860: PUSH
49861: LD_INT 2
49863: ARRAY
49864: PPUSH
49865: LD_EXP 106
49869: PUSH
49870: LD_VAR 0 2
49874: ARRAY
49875: PUSH
49876: LD_INT 1
49878: ARRAY
49879: PUSH
49880: LD_INT 3
49882: ARRAY
49883: PPUSH
49884: LD_EXP 106
49888: PUSH
49889: LD_VAR 0 2
49893: ARRAY
49894: PUSH
49895: LD_INT 1
49897: ARRAY
49898: PUSH
49899: LD_INT 4
49901: ARRAY
49902: PPUSH
49903: CALL 82878 0 5
49907: OR
49908: IFFALSE 50189
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49910: LD_ADDR_VAR 0 5
49914: PUSH
49915: LD_EXP 101
49919: PUSH
49920: LD_VAR 0 2
49924: ARRAY
49925: PPUSH
49926: LD_INT 25
49928: PUSH
49929: LD_INT 2
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PPUSH
49936: CALL_OW 72
49940: PUSH
49941: LD_EXP 103
49945: PUSH
49946: LD_VAR 0 2
49950: ARRAY
49951: DIFF
49952: ST_TO_ADDR
// if not tmp then
49953: LD_VAR 0 5
49957: NOT
49958: IFFALSE 49962
// continue ;
49960: GO 49790
// for j in tmp do
49962: LD_ADDR_VAR 0 3
49966: PUSH
49967: LD_VAR 0 5
49971: PUSH
49972: FOR_IN
49973: IFFALSE 50185
// begin if not mc_builders [ i ] then
49975: LD_EXP 107
49979: PUSH
49980: LD_VAR 0 2
49984: ARRAY
49985: NOT
49986: IFFALSE 50044
// begin SetTag ( j , 103 ) ;
49988: LD_VAR 0 3
49992: PPUSH
49993: LD_INT 103
49995: PPUSH
49996: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50000: LD_ADDR_EXP 107
50004: PUSH
50005: LD_EXP 107
50009: PPUSH
50010: LD_VAR 0 2
50014: PUSH
50015: LD_EXP 107
50019: PUSH
50020: LD_VAR 0 2
50024: ARRAY
50025: PUSH
50026: LD_INT 1
50028: PLUS
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PPUSH
50034: LD_VAR 0 3
50038: PPUSH
50039: CALL 74404 0 3
50043: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50044: LD_VAR 0 3
50048: PPUSH
50049: CALL_OW 310
50053: IFFALSE 50064
// ComExitBuilding ( j ) ;
50055: LD_VAR 0 3
50059: PPUSH
50060: CALL_OW 122
// wait ( 3 ) ;
50064: LD_INT 3
50066: PPUSH
50067: CALL_OW 67
// if not mc_build_list [ i ] then
50071: LD_EXP 106
50075: PUSH
50076: LD_VAR 0 2
50080: ARRAY
50081: NOT
50082: IFFALSE 50086
// break ;
50084: GO 50185
// if not HasTask ( j ) then
50086: LD_VAR 0 3
50090: PPUSH
50091: CALL_OW 314
50095: NOT
50096: IFFALSE 50183
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50098: LD_VAR 0 3
50102: PPUSH
50103: LD_EXP 106
50107: PUSH
50108: LD_VAR 0 2
50112: ARRAY
50113: PUSH
50114: LD_INT 1
50116: ARRAY
50117: PUSH
50118: LD_INT 1
50120: ARRAY
50121: PPUSH
50122: LD_EXP 106
50126: PUSH
50127: LD_VAR 0 2
50131: ARRAY
50132: PUSH
50133: LD_INT 1
50135: ARRAY
50136: PUSH
50137: LD_INT 2
50139: ARRAY
50140: PPUSH
50141: LD_EXP 106
50145: PUSH
50146: LD_VAR 0 2
50150: ARRAY
50151: PUSH
50152: LD_INT 1
50154: ARRAY
50155: PUSH
50156: LD_INT 3
50158: ARRAY
50159: PPUSH
50160: LD_EXP 106
50164: PUSH
50165: LD_VAR 0 2
50169: ARRAY
50170: PUSH
50171: LD_INT 1
50173: ARRAY
50174: PUSH
50175: LD_INT 4
50177: ARRAY
50178: PPUSH
50179: CALL_OW 145
// end ;
50183: GO 49972
50185: POP
50186: POP
// end else
50187: GO 50359
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50189: LD_EXP 101
50193: PUSH
50194: LD_VAR 0 2
50198: ARRAY
50199: PPUSH
50200: LD_EXP 106
50204: PUSH
50205: LD_VAR 0 2
50209: ARRAY
50210: PUSH
50211: LD_INT 1
50213: ARRAY
50214: PUSH
50215: LD_INT 1
50217: ARRAY
50218: PPUSH
50219: LD_EXP 106
50223: PUSH
50224: LD_VAR 0 2
50228: ARRAY
50229: PUSH
50230: LD_INT 1
50232: ARRAY
50233: PUSH
50234: LD_INT 2
50236: ARRAY
50237: PPUSH
50238: LD_EXP 106
50242: PUSH
50243: LD_VAR 0 2
50247: ARRAY
50248: PUSH
50249: LD_INT 1
50251: ARRAY
50252: PUSH
50253: LD_INT 3
50255: ARRAY
50256: PPUSH
50257: LD_EXP 106
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: ARRAY
50271: PUSH
50272: LD_INT 4
50274: ARRAY
50275: PPUSH
50276: LD_EXP 101
50280: PUSH
50281: LD_VAR 0 2
50285: ARRAY
50286: PPUSH
50287: LD_INT 21
50289: PUSH
50290: LD_INT 3
50292: PUSH
50293: EMPTY
50294: LIST
50295: LIST
50296: PPUSH
50297: CALL_OW 72
50301: PPUSH
50302: EMPTY
50303: PPUSH
50304: CALL 81632 0 7
50308: NOT
50309: IFFALSE 50359
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50311: LD_ADDR_EXP 106
50315: PUSH
50316: LD_EXP 106
50320: PPUSH
50321: LD_VAR 0 2
50325: PPUSH
50326: LD_EXP 106
50330: PUSH
50331: LD_VAR 0 2
50335: ARRAY
50336: PPUSH
50337: LD_INT 1
50339: PPUSH
50340: LD_INT 1
50342: NEG
50343: PPUSH
50344: LD_INT 0
50346: PPUSH
50347: CALL 73822 0 4
50351: PPUSH
50352: CALL_OW 1
50356: ST_TO_ADDR
// continue ;
50357: GO 49790
// end ; end ;
50359: GO 49790
50361: POP
50362: POP
// end ; end ;
50363: GO 49219
50365: POP
50366: POP
// end ;
50367: LD_VAR 0 1
50371: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50372: LD_INT 0
50374: PPUSH
50375: PPUSH
50376: PPUSH
50377: PPUSH
50378: PPUSH
50379: PPUSH
// if not mc_bases then
50380: LD_EXP 101
50384: NOT
50385: IFFALSE 50389
// exit ;
50387: GO 50816
// for i = 1 to mc_bases do
50389: LD_ADDR_VAR 0 2
50393: PUSH
50394: DOUBLE
50395: LD_INT 1
50397: DEC
50398: ST_TO_ADDR
50399: LD_EXP 101
50403: PUSH
50404: FOR_TO
50405: IFFALSE 50814
// begin tmp := mc_build_upgrade [ i ] ;
50407: LD_ADDR_VAR 0 4
50411: PUSH
50412: LD_EXP 133
50416: PUSH
50417: LD_VAR 0 2
50421: ARRAY
50422: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50423: LD_ADDR_VAR 0 6
50427: PUSH
50428: LD_EXP 134
50432: PUSH
50433: LD_VAR 0 2
50437: ARRAY
50438: PPUSH
50439: LD_INT 2
50441: PUSH
50442: LD_INT 30
50444: PUSH
50445: LD_INT 6
50447: PUSH
50448: EMPTY
50449: LIST
50450: LIST
50451: PUSH
50452: LD_INT 30
50454: PUSH
50455: LD_INT 7
50457: PUSH
50458: EMPTY
50459: LIST
50460: LIST
50461: PUSH
50462: EMPTY
50463: LIST
50464: LIST
50465: LIST
50466: PPUSH
50467: CALL_OW 72
50471: ST_TO_ADDR
// if not tmp and not lab then
50472: LD_VAR 0 4
50476: NOT
50477: PUSH
50478: LD_VAR 0 6
50482: NOT
50483: AND
50484: IFFALSE 50488
// continue ;
50486: GO 50404
// if tmp then
50488: LD_VAR 0 4
50492: IFFALSE 50612
// for j in tmp do
50494: LD_ADDR_VAR 0 3
50498: PUSH
50499: LD_VAR 0 4
50503: PUSH
50504: FOR_IN
50505: IFFALSE 50610
// begin if UpgradeCost ( j ) then
50507: LD_VAR 0 3
50511: PPUSH
50512: CALL 81292 0 1
50516: IFFALSE 50608
// begin ComUpgrade ( j ) ;
50518: LD_VAR 0 3
50522: PPUSH
50523: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50527: LD_ADDR_EXP 133
50531: PUSH
50532: LD_EXP 133
50536: PPUSH
50537: LD_VAR 0 2
50541: PPUSH
50542: LD_EXP 133
50546: PUSH
50547: LD_VAR 0 2
50551: ARRAY
50552: PUSH
50553: LD_VAR 0 3
50557: DIFF
50558: PPUSH
50559: CALL_OW 1
50563: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50564: LD_ADDR_EXP 108
50568: PUSH
50569: LD_EXP 108
50573: PPUSH
50574: LD_VAR 0 2
50578: PUSH
50579: LD_EXP 108
50583: PUSH
50584: LD_VAR 0 2
50588: ARRAY
50589: PUSH
50590: LD_INT 1
50592: PLUS
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PPUSH
50598: LD_VAR 0 3
50602: PPUSH
50603: CALL 74404 0 3
50607: ST_TO_ADDR
// end ; end ;
50608: GO 50504
50610: POP
50611: POP
// if not lab or not mc_lab_upgrade [ i ] then
50612: LD_VAR 0 6
50616: NOT
50617: PUSH
50618: LD_EXP 135
50622: PUSH
50623: LD_VAR 0 2
50627: ARRAY
50628: NOT
50629: OR
50630: IFFALSE 50634
// continue ;
50632: GO 50404
// for j in lab do
50634: LD_ADDR_VAR 0 3
50638: PUSH
50639: LD_VAR 0 6
50643: PUSH
50644: FOR_IN
50645: IFFALSE 50810
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50647: LD_VAR 0 3
50651: PPUSH
50652: CALL_OW 266
50656: PUSH
50657: LD_INT 6
50659: PUSH
50660: LD_INT 7
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: IN
50667: PUSH
50668: LD_VAR 0 3
50672: PPUSH
50673: CALL_OW 461
50677: PUSH
50678: LD_INT 1
50680: NONEQUAL
50681: AND
50682: IFFALSE 50808
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50684: LD_VAR 0 3
50688: PPUSH
50689: LD_EXP 135
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PUSH
50700: LD_INT 1
50702: ARRAY
50703: PPUSH
50704: CALL 81497 0 2
50708: IFFALSE 50808
// begin ComCancel ( j ) ;
50710: LD_VAR 0 3
50714: PPUSH
50715: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50719: LD_VAR 0 3
50723: PPUSH
50724: LD_EXP 135
50728: PUSH
50729: LD_VAR 0 2
50733: ARRAY
50734: PUSH
50735: LD_INT 1
50737: ARRAY
50738: PPUSH
50739: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50743: LD_VAR 0 3
50747: PUSH
50748: LD_EXP 108
50752: PUSH
50753: LD_VAR 0 2
50757: ARRAY
50758: IN
50759: NOT
50760: IFFALSE 50806
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50762: LD_ADDR_EXP 108
50766: PUSH
50767: LD_EXP 108
50771: PPUSH
50772: LD_VAR 0 2
50776: PUSH
50777: LD_EXP 108
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PUSH
50788: LD_INT 1
50790: PLUS
50791: PUSH
50792: EMPTY
50793: LIST
50794: LIST
50795: PPUSH
50796: LD_VAR 0 3
50800: PPUSH
50801: CALL 74404 0 3
50805: ST_TO_ADDR
// break ;
50806: GO 50810
// end ; end ; end ;
50808: GO 50644
50810: POP
50811: POP
// end ;
50812: GO 50404
50814: POP
50815: POP
// end ;
50816: LD_VAR 0 1
50820: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50821: LD_INT 0
50823: PPUSH
50824: PPUSH
50825: PPUSH
50826: PPUSH
50827: PPUSH
50828: PPUSH
50829: PPUSH
50830: PPUSH
50831: PPUSH
// if not mc_bases then
50832: LD_EXP 101
50836: NOT
50837: IFFALSE 50841
// exit ;
50839: GO 51246
// for i = 1 to mc_bases do
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: DOUBLE
50847: LD_INT 1
50849: DEC
50850: ST_TO_ADDR
50851: LD_EXP 101
50855: PUSH
50856: FOR_TO
50857: IFFALSE 51244
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50859: LD_EXP 109
50863: PUSH
50864: LD_VAR 0 2
50868: ARRAY
50869: NOT
50870: PUSH
50871: LD_EXP 101
50875: PUSH
50876: LD_VAR 0 2
50880: ARRAY
50881: PPUSH
50882: LD_INT 30
50884: PUSH
50885: LD_INT 3
50887: PUSH
50888: EMPTY
50889: LIST
50890: LIST
50891: PPUSH
50892: CALL_OW 72
50896: NOT
50897: OR
50898: IFFALSE 50902
// continue ;
50900: GO 50856
// busy := false ;
50902: LD_ADDR_VAR 0 8
50906: PUSH
50907: LD_INT 0
50909: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50910: LD_ADDR_VAR 0 4
50914: PUSH
50915: LD_EXP 101
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: PPUSH
50926: LD_INT 30
50928: PUSH
50929: LD_INT 3
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PPUSH
50936: CALL_OW 72
50940: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50941: LD_ADDR_VAR 0 6
50945: PUSH
50946: LD_EXP 109
50950: PUSH
50951: LD_VAR 0 2
50955: ARRAY
50956: PPUSH
50957: LD_INT 2
50959: PUSH
50960: LD_INT 30
50962: PUSH
50963: LD_INT 32
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 30
50972: PUSH
50973: LD_INT 33
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: LIST
50984: PPUSH
50985: CALL_OW 72
50989: ST_TO_ADDR
// if not t then
50990: LD_VAR 0 6
50994: NOT
50995: IFFALSE 50999
// continue ;
50997: GO 50856
// for j in tmp do
50999: LD_ADDR_VAR 0 3
51003: PUSH
51004: LD_VAR 0 4
51008: PUSH
51009: FOR_IN
51010: IFFALSE 51040
// if not BuildingStatus ( j ) = bs_idle then
51012: LD_VAR 0 3
51016: PPUSH
51017: CALL_OW 461
51021: PUSH
51022: LD_INT 2
51024: EQUAL
51025: NOT
51026: IFFALSE 51038
// begin busy := true ;
51028: LD_ADDR_VAR 0 8
51032: PUSH
51033: LD_INT 1
51035: ST_TO_ADDR
// break ;
51036: GO 51040
// end ;
51038: GO 51009
51040: POP
51041: POP
// if busy then
51042: LD_VAR 0 8
51046: IFFALSE 51050
// continue ;
51048: GO 50856
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51050: LD_ADDR_VAR 0 7
51054: PUSH
51055: LD_VAR 0 6
51059: PPUSH
51060: LD_INT 35
51062: PUSH
51063: LD_INT 0
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PPUSH
51070: CALL_OW 72
51074: ST_TO_ADDR
// if tw then
51075: LD_VAR 0 7
51079: IFFALSE 51156
// begin tw := tw [ 1 ] ;
51081: LD_ADDR_VAR 0 7
51085: PUSH
51086: LD_VAR 0 7
51090: PUSH
51091: LD_INT 1
51093: ARRAY
51094: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51095: LD_ADDR_VAR 0 9
51099: PUSH
51100: LD_VAR 0 7
51104: PPUSH
51105: LD_EXP 126
51109: PUSH
51110: LD_VAR 0 2
51114: ARRAY
51115: PPUSH
51116: CALL 79789 0 2
51120: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51121: LD_EXP 140
51125: PUSH
51126: LD_VAR 0 2
51130: ARRAY
51131: IFFALSE 51154
// if not weapon in mc_allowed_tower_weapons [ i ] then
51133: LD_VAR 0 9
51137: PUSH
51138: LD_EXP 140
51142: PUSH
51143: LD_VAR 0 2
51147: ARRAY
51148: IN
51149: NOT
51150: IFFALSE 51154
// continue ;
51152: GO 50856
// end else
51154: GO 51219
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51156: LD_ADDR_VAR 0 5
51160: PUSH
51161: LD_EXP 109
51165: PUSH
51166: LD_VAR 0 2
51170: ARRAY
51171: PPUSH
51172: LD_VAR 0 4
51176: PPUSH
51177: CALL 106692 0 2
51181: ST_TO_ADDR
// if not tmp2 then
51182: LD_VAR 0 5
51186: NOT
51187: IFFALSE 51191
// continue ;
51189: GO 50856
// tw := tmp2 [ 1 ] ;
51191: LD_ADDR_VAR 0 7
51195: PUSH
51196: LD_VAR 0 5
51200: PUSH
51201: LD_INT 1
51203: ARRAY
51204: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51205: LD_ADDR_VAR 0 9
51209: PUSH
51210: LD_VAR 0 5
51214: PUSH
51215: LD_INT 2
51217: ARRAY
51218: ST_TO_ADDR
// end ; if not weapon then
51219: LD_VAR 0 9
51223: NOT
51224: IFFALSE 51228
// continue ;
51226: GO 50856
// ComPlaceWeapon ( tw , weapon ) ;
51228: LD_VAR 0 7
51232: PPUSH
51233: LD_VAR 0 9
51237: PPUSH
51238: CALL_OW 148
// end ;
51242: GO 50856
51244: POP
51245: POP
// end ;
51246: LD_VAR 0 1
51250: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51251: LD_INT 0
51253: PPUSH
51254: PPUSH
51255: PPUSH
51256: PPUSH
51257: PPUSH
51258: PPUSH
51259: PPUSH
// if not mc_bases then
51260: LD_EXP 101
51264: NOT
51265: IFFALSE 51269
// exit ;
51267: GO 52044
// for i = 1 to mc_bases do
51269: LD_ADDR_VAR 0 2
51273: PUSH
51274: DOUBLE
51275: LD_INT 1
51277: DEC
51278: ST_TO_ADDR
51279: LD_EXP 101
51283: PUSH
51284: FOR_TO
51285: IFFALSE 52042
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51287: LD_EXP 114
51291: PUSH
51292: LD_VAR 0 2
51296: ARRAY
51297: NOT
51298: PUSH
51299: LD_EXP 114
51303: PUSH
51304: LD_VAR 0 2
51308: ARRAY
51309: PUSH
51310: LD_EXP 115
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: EQUAL
51321: OR
51322: PUSH
51323: LD_EXP 124
51327: PUSH
51328: LD_VAR 0 2
51332: ARRAY
51333: OR
51334: IFFALSE 51338
// continue ;
51336: GO 51284
// if mc_miners [ i ] then
51338: LD_EXP 115
51342: PUSH
51343: LD_VAR 0 2
51347: ARRAY
51348: IFFALSE 51729
// begin for j = mc_miners [ i ] downto 1 do
51350: LD_ADDR_VAR 0 3
51354: PUSH
51355: DOUBLE
51356: LD_EXP 115
51360: PUSH
51361: LD_VAR 0 2
51365: ARRAY
51366: INC
51367: ST_TO_ADDR
51368: LD_INT 1
51370: PUSH
51371: FOR_DOWNTO
51372: IFFALSE 51727
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51374: LD_EXP 115
51378: PUSH
51379: LD_VAR 0 2
51383: ARRAY
51384: PUSH
51385: LD_VAR 0 3
51389: ARRAY
51390: PPUSH
51391: CALL_OW 301
51395: PUSH
51396: LD_EXP 115
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PUSH
51407: LD_VAR 0 3
51411: ARRAY
51412: PPUSH
51413: CALL_OW 257
51417: PUSH
51418: LD_INT 1
51420: NONEQUAL
51421: OR
51422: IFFALSE 51485
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51424: LD_ADDR_VAR 0 5
51428: PUSH
51429: LD_EXP 115
51433: PUSH
51434: LD_VAR 0 2
51438: ARRAY
51439: PUSH
51440: LD_EXP 115
51444: PUSH
51445: LD_VAR 0 2
51449: ARRAY
51450: PUSH
51451: LD_VAR 0 3
51455: ARRAY
51456: DIFF
51457: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51458: LD_ADDR_EXP 115
51462: PUSH
51463: LD_EXP 115
51467: PPUSH
51468: LD_VAR 0 2
51472: PPUSH
51473: LD_VAR 0 5
51477: PPUSH
51478: CALL_OW 1
51482: ST_TO_ADDR
// continue ;
51483: GO 51371
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51485: LD_EXP 115
51489: PUSH
51490: LD_VAR 0 2
51494: ARRAY
51495: PUSH
51496: LD_VAR 0 3
51500: ARRAY
51501: PPUSH
51502: CALL_OW 257
51506: PUSH
51507: LD_INT 1
51509: EQUAL
51510: PUSH
51511: LD_EXP 115
51515: PUSH
51516: LD_VAR 0 2
51520: ARRAY
51521: PUSH
51522: LD_VAR 0 3
51526: ARRAY
51527: PPUSH
51528: CALL_OW 459
51532: NOT
51533: AND
51534: PUSH
51535: LD_EXP 115
51539: PUSH
51540: LD_VAR 0 2
51544: ARRAY
51545: PUSH
51546: LD_VAR 0 3
51550: ARRAY
51551: PPUSH
51552: CALL_OW 314
51556: NOT
51557: AND
51558: IFFALSE 51725
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51560: LD_EXP 115
51564: PUSH
51565: LD_VAR 0 2
51569: ARRAY
51570: PUSH
51571: LD_VAR 0 3
51575: ARRAY
51576: PPUSH
51577: CALL_OW 310
51581: IFFALSE 51604
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51583: LD_EXP 115
51587: PUSH
51588: LD_VAR 0 2
51592: ARRAY
51593: PUSH
51594: LD_VAR 0 3
51598: ARRAY
51599: PPUSH
51600: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51604: LD_EXP 115
51608: PUSH
51609: LD_VAR 0 2
51613: ARRAY
51614: PUSH
51615: LD_VAR 0 3
51619: ARRAY
51620: PPUSH
51621: CALL_OW 314
51625: NOT
51626: IFFALSE 51725
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51628: LD_ADDR_VAR 0 7
51632: PUSH
51633: LD_VAR 0 3
51637: PUSH
51638: LD_EXP 114
51642: PUSH
51643: LD_VAR 0 2
51647: ARRAY
51648: PPUSH
51649: CALL 71544 0 1
51653: MOD
51654: PUSH
51655: LD_INT 1
51657: PLUS
51658: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51659: LD_EXP 115
51663: PUSH
51664: LD_VAR 0 2
51668: ARRAY
51669: PUSH
51670: LD_VAR 0 3
51674: ARRAY
51675: PPUSH
51676: LD_EXP 114
51680: PUSH
51681: LD_VAR 0 2
51685: ARRAY
51686: PUSH
51687: LD_VAR 0 7
51691: ARRAY
51692: PUSH
51693: LD_INT 1
51695: ARRAY
51696: PPUSH
51697: LD_EXP 114
51701: PUSH
51702: LD_VAR 0 2
51706: ARRAY
51707: PUSH
51708: LD_VAR 0 7
51712: ARRAY
51713: PUSH
51714: LD_INT 2
51716: ARRAY
51717: PPUSH
51718: LD_INT 0
51720: PPUSH
51721: CALL_OW 193
// end ; end ; end ;
51725: GO 51371
51727: POP
51728: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51729: LD_ADDR_VAR 0 5
51733: PUSH
51734: LD_EXP 101
51738: PUSH
51739: LD_VAR 0 2
51743: ARRAY
51744: PPUSH
51745: LD_INT 2
51747: PUSH
51748: LD_INT 30
51750: PUSH
51751: LD_INT 4
51753: PUSH
51754: EMPTY
51755: LIST
51756: LIST
51757: PUSH
51758: LD_INT 30
51760: PUSH
51761: LD_INT 5
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: LD_INT 30
51770: PUSH
51771: LD_INT 32
51773: PUSH
51774: EMPTY
51775: LIST
51776: LIST
51777: PUSH
51778: EMPTY
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: PPUSH
51784: CALL_OW 72
51788: ST_TO_ADDR
// if not tmp then
51789: LD_VAR 0 5
51793: NOT
51794: IFFALSE 51798
// continue ;
51796: GO 51284
// list := [ ] ;
51798: LD_ADDR_VAR 0 6
51802: PUSH
51803: EMPTY
51804: ST_TO_ADDR
// for j in tmp do
51805: LD_ADDR_VAR 0 3
51809: PUSH
51810: LD_VAR 0 5
51814: PUSH
51815: FOR_IN
51816: IFFALSE 51885
// begin for k in UnitsInside ( j ) do
51818: LD_ADDR_VAR 0 4
51822: PUSH
51823: LD_VAR 0 3
51827: PPUSH
51828: CALL_OW 313
51832: PUSH
51833: FOR_IN
51834: IFFALSE 51881
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51836: LD_VAR 0 4
51840: PPUSH
51841: CALL_OW 257
51845: PUSH
51846: LD_INT 1
51848: EQUAL
51849: PUSH
51850: LD_VAR 0 4
51854: PPUSH
51855: CALL_OW 459
51859: NOT
51860: AND
51861: IFFALSE 51879
// list := list ^ k ;
51863: LD_ADDR_VAR 0 6
51867: PUSH
51868: LD_VAR 0 6
51872: PUSH
51873: LD_VAR 0 4
51877: ADD
51878: ST_TO_ADDR
51879: GO 51833
51881: POP
51882: POP
// end ;
51883: GO 51815
51885: POP
51886: POP
// list := list diff mc_miners [ i ] ;
51887: LD_ADDR_VAR 0 6
51891: PUSH
51892: LD_VAR 0 6
51896: PUSH
51897: LD_EXP 115
51901: PUSH
51902: LD_VAR 0 2
51906: ARRAY
51907: DIFF
51908: ST_TO_ADDR
// if not list then
51909: LD_VAR 0 6
51913: NOT
51914: IFFALSE 51918
// continue ;
51916: GO 51284
// k := mc_mines [ i ] - mc_miners [ i ] ;
51918: LD_ADDR_VAR 0 4
51922: PUSH
51923: LD_EXP 114
51927: PUSH
51928: LD_VAR 0 2
51932: ARRAY
51933: PUSH
51934: LD_EXP 115
51938: PUSH
51939: LD_VAR 0 2
51943: ARRAY
51944: MINUS
51945: ST_TO_ADDR
// if k > list then
51946: LD_VAR 0 4
51950: PUSH
51951: LD_VAR 0 6
51955: GREATER
51956: IFFALSE 51968
// k := list ;
51958: LD_ADDR_VAR 0 4
51962: PUSH
51963: LD_VAR 0 6
51967: ST_TO_ADDR
// for j = 1 to k do
51968: LD_ADDR_VAR 0 3
51972: PUSH
51973: DOUBLE
51974: LD_INT 1
51976: DEC
51977: ST_TO_ADDR
51978: LD_VAR 0 4
51982: PUSH
51983: FOR_TO
51984: IFFALSE 52038
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51986: LD_ADDR_EXP 115
51990: PUSH
51991: LD_EXP 115
51995: PPUSH
51996: LD_VAR 0 2
52000: PUSH
52001: LD_EXP 115
52005: PUSH
52006: LD_VAR 0 2
52010: ARRAY
52011: PUSH
52012: LD_INT 1
52014: PLUS
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: PPUSH
52020: LD_VAR 0 6
52024: PUSH
52025: LD_VAR 0 3
52029: ARRAY
52030: PPUSH
52031: CALL 74404 0 3
52035: ST_TO_ADDR
52036: GO 51983
52038: POP
52039: POP
// end ;
52040: GO 51284
52042: POP
52043: POP
// end ;
52044: LD_VAR 0 1
52048: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52049: LD_INT 0
52051: PPUSH
52052: PPUSH
52053: PPUSH
52054: PPUSH
52055: PPUSH
52056: PPUSH
52057: PPUSH
52058: PPUSH
52059: PPUSH
52060: PPUSH
52061: PPUSH
// if not mc_bases then
52062: LD_EXP 101
52066: NOT
52067: IFFALSE 52071
// exit ;
52069: GO 53894
// for i = 1 to mc_bases do
52071: LD_ADDR_VAR 0 2
52075: PUSH
52076: DOUBLE
52077: LD_INT 1
52079: DEC
52080: ST_TO_ADDR
52081: LD_EXP 101
52085: PUSH
52086: FOR_TO
52087: IFFALSE 53892
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52089: LD_EXP 101
52093: PUSH
52094: LD_VAR 0 2
52098: ARRAY
52099: NOT
52100: PUSH
52101: LD_EXP 108
52105: PUSH
52106: LD_VAR 0 2
52110: ARRAY
52111: OR
52112: IFFALSE 52116
// continue ;
52114: GO 52086
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52116: LD_EXP 117
52120: PUSH
52121: LD_VAR 0 2
52125: ARRAY
52126: NOT
52127: PUSH
52128: LD_EXP 118
52132: PUSH
52133: LD_VAR 0 2
52137: ARRAY
52138: AND
52139: IFFALSE 52177
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52141: LD_ADDR_EXP 118
52145: PUSH
52146: LD_EXP 118
52150: PPUSH
52151: LD_VAR 0 2
52155: PPUSH
52156: EMPTY
52157: PPUSH
52158: CALL_OW 1
52162: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52163: LD_VAR 0 2
52167: PPUSH
52168: LD_INT 107
52170: PPUSH
52171: CALL 42903 0 2
// continue ;
52175: GO 52086
// end ; target := [ ] ;
52177: LD_ADDR_VAR 0 7
52181: PUSH
52182: EMPTY
52183: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52184: LD_ADDR_VAR 0 6
52188: PUSH
52189: LD_EXP 101
52193: PUSH
52194: LD_VAR 0 2
52198: ARRAY
52199: PUSH
52200: LD_INT 1
52202: ARRAY
52203: PPUSH
52204: CALL_OW 255
52208: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52209: LD_ADDR_VAR 0 9
52213: PUSH
52214: LD_EXP 101
52218: PUSH
52219: LD_VAR 0 2
52223: ARRAY
52224: PPUSH
52225: LD_INT 2
52227: PUSH
52228: LD_INT 30
52230: PUSH
52231: LD_INT 0
52233: PUSH
52234: EMPTY
52235: LIST
52236: LIST
52237: PUSH
52238: LD_INT 30
52240: PUSH
52241: LD_INT 1
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: LIST
52252: PPUSH
52253: CALL_OW 72
52257: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52258: LD_ADDR_VAR 0 3
52262: PUSH
52263: DOUBLE
52264: LD_EXP 117
52268: PUSH
52269: LD_VAR 0 2
52273: ARRAY
52274: INC
52275: ST_TO_ADDR
52276: LD_INT 1
52278: PUSH
52279: FOR_DOWNTO
52280: IFFALSE 52525
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52282: LD_EXP 117
52286: PUSH
52287: LD_VAR 0 2
52291: ARRAY
52292: PUSH
52293: LD_VAR 0 3
52297: ARRAY
52298: PUSH
52299: LD_INT 2
52301: ARRAY
52302: PPUSH
52303: LD_EXP 117
52307: PUSH
52308: LD_VAR 0 2
52312: ARRAY
52313: PUSH
52314: LD_VAR 0 3
52318: ARRAY
52319: PUSH
52320: LD_INT 3
52322: ARRAY
52323: PPUSH
52324: CALL_OW 488
52328: PUSH
52329: LD_EXP 117
52333: PUSH
52334: LD_VAR 0 2
52338: ARRAY
52339: PUSH
52340: LD_VAR 0 3
52344: ARRAY
52345: PUSH
52346: LD_INT 2
52348: ARRAY
52349: PPUSH
52350: LD_EXP 117
52354: PUSH
52355: LD_VAR 0 2
52359: ARRAY
52360: PUSH
52361: LD_VAR 0 3
52365: ARRAY
52366: PUSH
52367: LD_INT 3
52369: ARRAY
52370: PPUSH
52371: CALL_OW 284
52375: PUSH
52376: LD_INT 0
52378: EQUAL
52379: AND
52380: IFFALSE 52435
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52382: LD_ADDR_VAR 0 5
52386: PUSH
52387: LD_EXP 117
52391: PUSH
52392: LD_VAR 0 2
52396: ARRAY
52397: PPUSH
52398: LD_VAR 0 3
52402: PPUSH
52403: CALL_OW 3
52407: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52408: LD_ADDR_EXP 117
52412: PUSH
52413: LD_EXP 117
52417: PPUSH
52418: LD_VAR 0 2
52422: PPUSH
52423: LD_VAR 0 5
52427: PPUSH
52428: CALL_OW 1
52432: ST_TO_ADDR
// continue ;
52433: GO 52279
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52435: LD_VAR 0 6
52439: PPUSH
52440: LD_EXP 117
52444: PUSH
52445: LD_VAR 0 2
52449: ARRAY
52450: PUSH
52451: LD_VAR 0 3
52455: ARRAY
52456: PUSH
52457: LD_INT 2
52459: ARRAY
52460: PPUSH
52461: LD_EXP 117
52465: PUSH
52466: LD_VAR 0 2
52470: ARRAY
52471: PUSH
52472: LD_VAR 0 3
52476: ARRAY
52477: PUSH
52478: LD_INT 3
52480: ARRAY
52481: PPUSH
52482: LD_INT 30
52484: PPUSH
52485: CALL 75668 0 4
52489: PUSH
52490: LD_INT 4
52492: ARRAY
52493: PUSH
52494: LD_INT 0
52496: EQUAL
52497: IFFALSE 52523
// begin target := mc_crates [ i ] [ j ] ;
52499: LD_ADDR_VAR 0 7
52503: PUSH
52504: LD_EXP 117
52508: PUSH
52509: LD_VAR 0 2
52513: ARRAY
52514: PUSH
52515: LD_VAR 0 3
52519: ARRAY
52520: ST_TO_ADDR
// break ;
52521: GO 52525
// end ; end ;
52523: GO 52279
52525: POP
52526: POP
// if not target then
52527: LD_VAR 0 7
52531: NOT
52532: IFFALSE 52536
// continue ;
52534: GO 52086
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52536: LD_ADDR_VAR 0 8
52540: PUSH
52541: LD_EXP 120
52545: PUSH
52546: LD_VAR 0 2
52550: ARRAY
52551: PPUSH
52552: LD_INT 2
52554: PUSH
52555: LD_INT 3
52557: PUSH
52558: LD_INT 58
52560: PUSH
52561: EMPTY
52562: LIST
52563: PUSH
52564: EMPTY
52565: LIST
52566: LIST
52567: PUSH
52568: LD_INT 61
52570: PUSH
52571: EMPTY
52572: LIST
52573: PUSH
52574: LD_INT 33
52576: PUSH
52577: LD_INT 5
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: LD_INT 33
52586: PUSH
52587: LD_INT 3
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: LIST
52600: PUSH
52601: LD_INT 2
52603: PUSH
52604: LD_INT 34
52606: PUSH
52607: LD_INT 32
52609: PUSH
52610: EMPTY
52611: LIST
52612: LIST
52613: PUSH
52614: LD_INT 34
52616: PUSH
52617: LD_INT 51
52619: PUSH
52620: EMPTY
52621: LIST
52622: LIST
52623: PUSH
52624: LD_INT 34
52626: PUSH
52627: LD_INT 12
52629: PUSH
52630: EMPTY
52631: LIST
52632: LIST
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: LIST
52638: LIST
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: PPUSH
52644: CALL_OW 72
52648: ST_TO_ADDR
// if not cargo then
52649: LD_VAR 0 8
52653: NOT
52654: IFFALSE 53360
// begin if mc_crates_collector [ i ] < 5 then
52656: LD_EXP 118
52660: PUSH
52661: LD_VAR 0 2
52665: ARRAY
52666: PUSH
52667: LD_INT 5
52669: LESS
52670: IFFALSE 53036
// begin if mc_ape [ i ] then
52672: LD_EXP 130
52676: PUSH
52677: LD_VAR 0 2
52681: ARRAY
52682: IFFALSE 52729
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52684: LD_ADDR_VAR 0 5
52688: PUSH
52689: LD_EXP 130
52693: PUSH
52694: LD_VAR 0 2
52698: ARRAY
52699: PPUSH
52700: LD_INT 25
52702: PUSH
52703: LD_INT 16
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: PUSH
52710: LD_INT 24
52712: PUSH
52713: LD_INT 750
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: PUSH
52720: EMPTY
52721: LIST
52722: LIST
52723: PPUSH
52724: CALL_OW 72
52728: ST_TO_ADDR
// if not tmp then
52729: LD_VAR 0 5
52733: NOT
52734: IFFALSE 52781
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52736: LD_ADDR_VAR 0 5
52740: PUSH
52741: LD_EXP 101
52745: PUSH
52746: LD_VAR 0 2
52750: ARRAY
52751: PPUSH
52752: LD_INT 25
52754: PUSH
52755: LD_INT 2
52757: PUSH
52758: EMPTY
52759: LIST
52760: LIST
52761: PUSH
52762: LD_INT 24
52764: PUSH
52765: LD_INT 750
52767: PUSH
52768: EMPTY
52769: LIST
52770: LIST
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: PPUSH
52776: CALL_OW 72
52780: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52781: LD_EXP 130
52785: PUSH
52786: LD_VAR 0 2
52790: ARRAY
52791: PUSH
52792: LD_EXP 101
52796: PUSH
52797: LD_VAR 0 2
52801: ARRAY
52802: PPUSH
52803: LD_INT 25
52805: PUSH
52806: LD_INT 2
52808: PUSH
52809: EMPTY
52810: LIST
52811: LIST
52812: PUSH
52813: LD_INT 24
52815: PUSH
52816: LD_INT 750
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PPUSH
52827: CALL_OW 72
52831: AND
52832: PUSH
52833: LD_VAR 0 5
52837: PUSH
52838: LD_INT 5
52840: LESS
52841: AND
52842: IFFALSE 52924
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52844: LD_ADDR_VAR 0 3
52848: PUSH
52849: LD_EXP 101
52853: PUSH
52854: LD_VAR 0 2
52858: ARRAY
52859: PPUSH
52860: LD_INT 25
52862: PUSH
52863: LD_INT 2
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PUSH
52870: LD_INT 24
52872: PUSH
52873: LD_INT 750
52875: PUSH
52876: EMPTY
52877: LIST
52878: LIST
52879: PUSH
52880: EMPTY
52881: LIST
52882: LIST
52883: PPUSH
52884: CALL_OW 72
52888: PUSH
52889: FOR_IN
52890: IFFALSE 52922
// begin tmp := tmp union j ;
52892: LD_ADDR_VAR 0 5
52896: PUSH
52897: LD_VAR 0 5
52901: PUSH
52902: LD_VAR 0 3
52906: UNION
52907: ST_TO_ADDR
// if tmp >= 5 then
52908: LD_VAR 0 5
52912: PUSH
52913: LD_INT 5
52915: GREATEREQUAL
52916: IFFALSE 52920
// break ;
52918: GO 52922
// end ;
52920: GO 52889
52922: POP
52923: POP
// end ; if not tmp then
52924: LD_VAR 0 5
52928: NOT
52929: IFFALSE 52933
// continue ;
52931: GO 52086
// for j in tmp do
52933: LD_ADDR_VAR 0 3
52937: PUSH
52938: LD_VAR 0 5
52942: PUSH
52943: FOR_IN
52944: IFFALSE 53034
// if not GetTag ( j ) then
52946: LD_VAR 0 3
52950: PPUSH
52951: CALL_OW 110
52955: NOT
52956: IFFALSE 53032
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52958: LD_ADDR_EXP 118
52962: PUSH
52963: LD_EXP 118
52967: PPUSH
52968: LD_VAR 0 2
52972: PUSH
52973: LD_EXP 118
52977: PUSH
52978: LD_VAR 0 2
52982: ARRAY
52983: PUSH
52984: LD_INT 1
52986: PLUS
52987: PUSH
52988: EMPTY
52989: LIST
52990: LIST
52991: PPUSH
52992: LD_VAR 0 3
52996: PPUSH
52997: CALL 74404 0 3
53001: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53002: LD_VAR 0 3
53006: PPUSH
53007: LD_INT 107
53009: PPUSH
53010: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53014: LD_EXP 118
53018: PUSH
53019: LD_VAR 0 2
53023: ARRAY
53024: PUSH
53025: LD_INT 5
53027: GREATEREQUAL
53028: IFFALSE 53032
// break ;
53030: GO 53034
// end ;
53032: GO 52943
53034: POP
53035: POP
// end ; if mc_crates_collector [ i ] and target then
53036: LD_EXP 118
53040: PUSH
53041: LD_VAR 0 2
53045: ARRAY
53046: PUSH
53047: LD_VAR 0 7
53051: AND
53052: IFFALSE 53358
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53054: LD_EXP 118
53058: PUSH
53059: LD_VAR 0 2
53063: ARRAY
53064: PUSH
53065: LD_VAR 0 7
53069: PUSH
53070: LD_INT 1
53072: ARRAY
53073: LESS
53074: IFFALSE 53094
// tmp := mc_crates_collector [ i ] else
53076: LD_ADDR_VAR 0 5
53080: PUSH
53081: LD_EXP 118
53085: PUSH
53086: LD_VAR 0 2
53090: ARRAY
53091: ST_TO_ADDR
53092: GO 53108
// tmp := target [ 1 ] ;
53094: LD_ADDR_VAR 0 5
53098: PUSH
53099: LD_VAR 0 7
53103: PUSH
53104: LD_INT 1
53106: ARRAY
53107: ST_TO_ADDR
// k := 0 ;
53108: LD_ADDR_VAR 0 4
53112: PUSH
53113: LD_INT 0
53115: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53116: LD_ADDR_VAR 0 3
53120: PUSH
53121: LD_EXP 118
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PUSH
53132: FOR_IN
53133: IFFALSE 53356
// begin k := k + 1 ;
53135: LD_ADDR_VAR 0 4
53139: PUSH
53140: LD_VAR 0 4
53144: PUSH
53145: LD_INT 1
53147: PLUS
53148: ST_TO_ADDR
// if k > tmp then
53149: LD_VAR 0 4
53153: PUSH
53154: LD_VAR 0 5
53158: GREATER
53159: IFFALSE 53163
// break ;
53161: GO 53356
// if not GetClass ( j ) in [ 2 , 16 ] then
53163: LD_VAR 0 3
53167: PPUSH
53168: CALL_OW 257
53172: PUSH
53173: LD_INT 2
53175: PUSH
53176: LD_INT 16
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: IN
53183: NOT
53184: IFFALSE 53237
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53186: LD_ADDR_EXP 118
53190: PUSH
53191: LD_EXP 118
53195: PPUSH
53196: LD_VAR 0 2
53200: PPUSH
53201: LD_EXP 118
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: PUSH
53212: LD_VAR 0 3
53216: DIFF
53217: PPUSH
53218: CALL_OW 1
53222: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53223: LD_VAR 0 3
53227: PPUSH
53228: LD_INT 0
53230: PPUSH
53231: CALL_OW 109
// continue ;
53235: GO 53132
// end ; if IsInUnit ( j ) then
53237: LD_VAR 0 3
53241: PPUSH
53242: CALL_OW 310
53246: IFFALSE 53257
// ComExitBuilding ( j ) ;
53248: LD_VAR 0 3
53252: PPUSH
53253: CALL_OW 122
// wait ( 3 ) ;
53257: LD_INT 3
53259: PPUSH
53260: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53264: LD_VAR 0 3
53268: PPUSH
53269: CALL_OW 314
53273: PUSH
53274: LD_VAR 0 6
53278: PPUSH
53279: LD_VAR 0 7
53283: PUSH
53284: LD_INT 2
53286: ARRAY
53287: PPUSH
53288: LD_VAR 0 7
53292: PUSH
53293: LD_INT 3
53295: ARRAY
53296: PPUSH
53297: LD_INT 30
53299: PPUSH
53300: CALL 75668 0 4
53304: PUSH
53305: LD_INT 4
53307: ARRAY
53308: AND
53309: IFFALSE 53327
// ComStandNearbyBuilding ( j , depot ) else
53311: LD_VAR 0 3
53315: PPUSH
53316: LD_VAR 0 9
53320: PPUSH
53321: CALL 71006 0 2
53325: GO 53354
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53327: LD_VAR 0 3
53331: PPUSH
53332: LD_VAR 0 7
53336: PUSH
53337: LD_INT 2
53339: ARRAY
53340: PPUSH
53341: LD_VAR 0 7
53345: PUSH
53346: LD_INT 3
53348: ARRAY
53349: PPUSH
53350: CALL_OW 117
// end ;
53354: GO 53132
53356: POP
53357: POP
// end ; end else
53358: GO 53890
// begin for j in cargo do
53360: LD_ADDR_VAR 0 3
53364: PUSH
53365: LD_VAR 0 8
53369: PUSH
53370: FOR_IN
53371: IFFALSE 53888
// begin if GetTag ( j ) <> 0 then
53373: LD_VAR 0 3
53377: PPUSH
53378: CALL_OW 110
53382: PUSH
53383: LD_INT 0
53385: NONEQUAL
53386: IFFALSE 53390
// continue ;
53388: GO 53370
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53390: LD_VAR 0 3
53394: PPUSH
53395: CALL_OW 256
53399: PUSH
53400: LD_INT 1000
53402: LESS
53403: PUSH
53404: LD_VAR 0 3
53408: PPUSH
53409: LD_EXP 125
53413: PUSH
53414: LD_VAR 0 2
53418: ARRAY
53419: PPUSH
53420: CALL_OW 308
53424: NOT
53425: AND
53426: IFFALSE 53448
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53428: LD_VAR 0 3
53432: PPUSH
53433: LD_EXP 125
53437: PUSH
53438: LD_VAR 0 2
53442: ARRAY
53443: PPUSH
53444: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53448: LD_VAR 0 3
53452: PPUSH
53453: CALL_OW 256
53457: PUSH
53458: LD_INT 1000
53460: LESS
53461: PUSH
53462: LD_VAR 0 3
53466: PPUSH
53467: LD_EXP 125
53471: PUSH
53472: LD_VAR 0 2
53476: ARRAY
53477: PPUSH
53478: CALL_OW 308
53482: AND
53483: IFFALSE 53487
// continue ;
53485: GO 53370
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53487: LD_VAR 0 3
53491: PPUSH
53492: CALL_OW 262
53496: PUSH
53497: LD_INT 2
53499: EQUAL
53500: PUSH
53501: LD_VAR 0 3
53505: PPUSH
53506: CALL_OW 261
53510: PUSH
53511: LD_INT 15
53513: LESS
53514: AND
53515: IFFALSE 53519
// continue ;
53517: GO 53370
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53519: LD_VAR 0 3
53523: PPUSH
53524: CALL_OW 262
53528: PUSH
53529: LD_INT 1
53531: EQUAL
53532: PUSH
53533: LD_VAR 0 3
53537: PPUSH
53538: CALL_OW 261
53542: PUSH
53543: LD_INT 10
53545: LESS
53546: AND
53547: IFFALSE 53827
// begin if not depot then
53549: LD_VAR 0 9
53553: NOT
53554: IFFALSE 53558
// continue ;
53556: GO 53370
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53558: LD_VAR 0 3
53562: PPUSH
53563: LD_VAR 0 9
53567: PPUSH
53568: LD_VAR 0 3
53572: PPUSH
53573: CALL_OW 74
53577: PPUSH
53578: CALL_OW 296
53582: PUSH
53583: LD_INT 6
53585: LESS
53586: IFFALSE 53602
// SetFuel ( j , 100 ) else
53588: LD_VAR 0 3
53592: PPUSH
53593: LD_INT 100
53595: PPUSH
53596: CALL_OW 240
53600: GO 53827
// if GetFuel ( j ) = 0 then
53602: LD_VAR 0 3
53606: PPUSH
53607: CALL_OW 261
53611: PUSH
53612: LD_INT 0
53614: EQUAL
53615: IFFALSE 53827
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53617: LD_ADDR_EXP 120
53621: PUSH
53622: LD_EXP 120
53626: PPUSH
53627: LD_VAR 0 2
53631: PPUSH
53632: LD_EXP 120
53636: PUSH
53637: LD_VAR 0 2
53641: ARRAY
53642: PUSH
53643: LD_VAR 0 3
53647: DIFF
53648: PPUSH
53649: CALL_OW 1
53653: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53654: LD_VAR 0 3
53658: PPUSH
53659: CALL_OW 263
53663: PUSH
53664: LD_INT 1
53666: EQUAL
53667: IFFALSE 53683
// ComExitVehicle ( IsInUnit ( j ) ) ;
53669: LD_VAR 0 3
53673: PPUSH
53674: CALL_OW 310
53678: PPUSH
53679: CALL_OW 121
// if GetControl ( j ) = control_remote then
53683: LD_VAR 0 3
53687: PPUSH
53688: CALL_OW 263
53692: PUSH
53693: LD_INT 2
53695: EQUAL
53696: IFFALSE 53707
// ComUnlink ( j ) ;
53698: LD_VAR 0 3
53702: PPUSH
53703: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53707: LD_ADDR_VAR 0 10
53711: PUSH
53712: LD_VAR 0 2
53716: PPUSH
53717: LD_INT 3
53719: PPUSH
53720: CALL 63471 0 2
53724: ST_TO_ADDR
// if fac then
53725: LD_VAR 0 10
53729: IFFALSE 53825
// begin for k in fac do
53731: LD_ADDR_VAR 0 4
53735: PUSH
53736: LD_VAR 0 10
53740: PUSH
53741: FOR_IN
53742: IFFALSE 53823
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53744: LD_ADDR_VAR 0 11
53748: PUSH
53749: LD_VAR 0 10
53753: PPUSH
53754: LD_VAR 0 3
53758: PPUSH
53759: CALL_OW 265
53763: PPUSH
53764: LD_VAR 0 3
53768: PPUSH
53769: CALL_OW 262
53773: PPUSH
53774: LD_VAR 0 3
53778: PPUSH
53779: CALL_OW 263
53783: PPUSH
53784: LD_VAR 0 3
53788: PPUSH
53789: CALL_OW 264
53793: PPUSH
53794: CALL 71902 0 5
53798: ST_TO_ADDR
// if components then
53799: LD_VAR 0 11
53803: IFFALSE 53821
// begin MC_InsertProduceList ( i , components ) ;
53805: LD_VAR 0 2
53809: PPUSH
53810: LD_VAR 0 11
53814: PPUSH
53815: CALL 63016 0 2
// break ;
53819: GO 53823
// end ; end ;
53821: GO 53741
53823: POP
53824: POP
// end ; continue ;
53825: GO 53370
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53827: LD_VAR 0 3
53831: PPUSH
53832: LD_INT 1
53834: PPUSH
53835: CALL_OW 289
53839: PUSH
53840: LD_INT 100
53842: LESS
53843: PUSH
53844: LD_VAR 0 3
53848: PPUSH
53849: CALL_OW 314
53853: NOT
53854: AND
53855: IFFALSE 53884
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53857: LD_VAR 0 3
53861: PPUSH
53862: LD_VAR 0 7
53866: PUSH
53867: LD_INT 2
53869: ARRAY
53870: PPUSH
53871: LD_VAR 0 7
53875: PUSH
53876: LD_INT 3
53878: ARRAY
53879: PPUSH
53880: CALL_OW 117
// break ;
53884: GO 53888
// end ;
53886: GO 53370
53888: POP
53889: POP
// end ; end ;
53890: GO 52086
53892: POP
53893: POP
// end ;
53894: LD_VAR 0 1
53898: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53899: LD_INT 0
53901: PPUSH
53902: PPUSH
53903: PPUSH
53904: PPUSH
// if not mc_bases then
53905: LD_EXP 101
53909: NOT
53910: IFFALSE 53914
// exit ;
53912: GO 54075
// for i = 1 to mc_bases do
53914: LD_ADDR_VAR 0 2
53918: PUSH
53919: DOUBLE
53920: LD_INT 1
53922: DEC
53923: ST_TO_ADDR
53924: LD_EXP 101
53928: PUSH
53929: FOR_TO
53930: IFFALSE 54073
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53932: LD_ADDR_VAR 0 4
53936: PUSH
53937: LD_EXP 120
53941: PUSH
53942: LD_VAR 0 2
53946: ARRAY
53947: PUSH
53948: LD_EXP 123
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: UNION
53959: PPUSH
53960: LD_INT 33
53962: PUSH
53963: LD_INT 2
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: PPUSH
53970: CALL_OW 72
53974: ST_TO_ADDR
// if tmp then
53975: LD_VAR 0 4
53979: IFFALSE 54071
// for j in tmp do
53981: LD_ADDR_VAR 0 3
53985: PUSH
53986: LD_VAR 0 4
53990: PUSH
53991: FOR_IN
53992: IFFALSE 54069
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53994: LD_VAR 0 3
53998: PPUSH
53999: CALL_OW 312
54003: NOT
54004: PUSH
54005: LD_VAR 0 3
54009: PPUSH
54010: CALL_OW 256
54014: PUSH
54015: LD_INT 250
54017: GREATEREQUAL
54018: AND
54019: IFFALSE 54032
// Connect ( j ) else
54021: LD_VAR 0 3
54025: PPUSH
54026: CALL 77750 0 1
54030: GO 54067
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54032: LD_VAR 0 3
54036: PPUSH
54037: CALL_OW 256
54041: PUSH
54042: LD_INT 250
54044: LESS
54045: PUSH
54046: LD_VAR 0 3
54050: PPUSH
54051: CALL_OW 312
54055: AND
54056: IFFALSE 54067
// ComUnlink ( j ) ;
54058: LD_VAR 0 3
54062: PPUSH
54063: CALL_OW 136
54067: GO 53991
54069: POP
54070: POP
// end ;
54071: GO 53929
54073: POP
54074: POP
// end ;
54075: LD_VAR 0 1
54079: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54080: LD_INT 0
54082: PPUSH
54083: PPUSH
54084: PPUSH
54085: PPUSH
54086: PPUSH
// if not mc_bases then
54087: LD_EXP 101
54091: NOT
54092: IFFALSE 54096
// exit ;
54094: GO 54541
// for i = 1 to mc_bases do
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: DOUBLE
54102: LD_INT 1
54104: DEC
54105: ST_TO_ADDR
54106: LD_EXP 101
54110: PUSH
54111: FOR_TO
54112: IFFALSE 54539
// begin if not mc_produce [ i ] then
54114: LD_EXP 122
54118: PUSH
54119: LD_VAR 0 2
54123: ARRAY
54124: NOT
54125: IFFALSE 54129
// continue ;
54127: GO 54111
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54129: LD_ADDR_VAR 0 5
54133: PUSH
54134: LD_EXP 101
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PPUSH
54145: LD_INT 30
54147: PUSH
54148: LD_INT 3
54150: PUSH
54151: EMPTY
54152: LIST
54153: LIST
54154: PPUSH
54155: CALL_OW 72
54159: ST_TO_ADDR
// if not fac then
54160: LD_VAR 0 5
54164: NOT
54165: IFFALSE 54169
// continue ;
54167: GO 54111
// for j in fac do
54169: LD_ADDR_VAR 0 3
54173: PUSH
54174: LD_VAR 0 5
54178: PUSH
54179: FOR_IN
54180: IFFALSE 54535
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54182: LD_VAR 0 3
54186: PPUSH
54187: CALL_OW 461
54191: PUSH
54192: LD_INT 2
54194: NONEQUAL
54195: PUSH
54196: LD_VAR 0 3
54200: PPUSH
54201: LD_INT 15
54203: PPUSH
54204: CALL 77369 0 2
54208: PUSH
54209: LD_INT 4
54211: ARRAY
54212: OR
54213: IFFALSE 54217
// continue ;
54215: GO 54179
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54217: LD_VAR 0 3
54221: PPUSH
54222: LD_EXP 122
54226: PUSH
54227: LD_VAR 0 2
54231: ARRAY
54232: PUSH
54233: LD_INT 1
54235: ARRAY
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: PPUSH
54241: LD_EXP 122
54245: PUSH
54246: LD_VAR 0 2
54250: ARRAY
54251: PUSH
54252: LD_INT 1
54254: ARRAY
54255: PUSH
54256: LD_INT 2
54258: ARRAY
54259: PPUSH
54260: LD_EXP 122
54264: PUSH
54265: LD_VAR 0 2
54269: ARRAY
54270: PUSH
54271: LD_INT 1
54273: ARRAY
54274: PUSH
54275: LD_INT 3
54277: ARRAY
54278: PPUSH
54279: LD_EXP 122
54283: PUSH
54284: LD_VAR 0 2
54288: ARRAY
54289: PUSH
54290: LD_INT 1
54292: ARRAY
54293: PUSH
54294: LD_INT 4
54296: ARRAY
54297: PPUSH
54298: CALL_OW 448
54302: PUSH
54303: LD_VAR 0 3
54307: PPUSH
54308: LD_EXP 122
54312: PUSH
54313: LD_VAR 0 2
54317: ARRAY
54318: PUSH
54319: LD_INT 1
54321: ARRAY
54322: PUSH
54323: LD_INT 1
54325: ARRAY
54326: PUSH
54327: LD_EXP 122
54331: PUSH
54332: LD_VAR 0 2
54336: ARRAY
54337: PUSH
54338: LD_INT 1
54340: ARRAY
54341: PUSH
54342: LD_INT 2
54344: ARRAY
54345: PUSH
54346: LD_EXP 122
54350: PUSH
54351: LD_VAR 0 2
54355: ARRAY
54356: PUSH
54357: LD_INT 1
54359: ARRAY
54360: PUSH
54361: LD_INT 3
54363: ARRAY
54364: PUSH
54365: LD_EXP 122
54369: PUSH
54370: LD_VAR 0 2
54374: ARRAY
54375: PUSH
54376: LD_INT 1
54378: ARRAY
54379: PUSH
54380: LD_INT 4
54382: ARRAY
54383: PUSH
54384: EMPTY
54385: LIST
54386: LIST
54387: LIST
54388: LIST
54389: PPUSH
54390: CALL 81145 0 2
54394: AND
54395: IFFALSE 54533
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54397: LD_VAR 0 3
54401: PPUSH
54402: LD_EXP 122
54406: PUSH
54407: LD_VAR 0 2
54411: ARRAY
54412: PUSH
54413: LD_INT 1
54415: ARRAY
54416: PUSH
54417: LD_INT 1
54419: ARRAY
54420: PPUSH
54421: LD_EXP 122
54425: PUSH
54426: LD_VAR 0 2
54430: ARRAY
54431: PUSH
54432: LD_INT 1
54434: ARRAY
54435: PUSH
54436: LD_INT 2
54438: ARRAY
54439: PPUSH
54440: LD_EXP 122
54444: PUSH
54445: LD_VAR 0 2
54449: ARRAY
54450: PUSH
54451: LD_INT 1
54453: ARRAY
54454: PUSH
54455: LD_INT 3
54457: ARRAY
54458: PPUSH
54459: LD_EXP 122
54463: PUSH
54464: LD_VAR 0 2
54468: ARRAY
54469: PUSH
54470: LD_INT 1
54472: ARRAY
54473: PUSH
54474: LD_INT 4
54476: ARRAY
54477: PPUSH
54478: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54482: LD_ADDR_VAR 0 4
54486: PUSH
54487: LD_EXP 122
54491: PUSH
54492: LD_VAR 0 2
54496: ARRAY
54497: PPUSH
54498: LD_INT 1
54500: PPUSH
54501: CALL_OW 3
54505: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54506: LD_ADDR_EXP 122
54510: PUSH
54511: LD_EXP 122
54515: PPUSH
54516: LD_VAR 0 2
54520: PPUSH
54521: LD_VAR 0 4
54525: PPUSH
54526: CALL_OW 1
54530: ST_TO_ADDR
// break ;
54531: GO 54535
// end ; end ;
54533: GO 54179
54535: POP
54536: POP
// end ;
54537: GO 54111
54539: POP
54540: POP
// end ;
54541: LD_VAR 0 1
54545: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54546: LD_INT 0
54548: PPUSH
54549: PPUSH
54550: PPUSH
// if not mc_bases then
54551: LD_EXP 101
54555: NOT
54556: IFFALSE 54560
// exit ;
54558: GO 54649
// for i = 1 to mc_bases do
54560: LD_ADDR_VAR 0 2
54564: PUSH
54565: DOUBLE
54566: LD_INT 1
54568: DEC
54569: ST_TO_ADDR
54570: LD_EXP 101
54574: PUSH
54575: FOR_TO
54576: IFFALSE 54647
// begin if mc_attack [ i ] then
54578: LD_EXP 121
54582: PUSH
54583: LD_VAR 0 2
54587: ARRAY
54588: IFFALSE 54645
// begin tmp := mc_attack [ i ] [ 1 ] ;
54590: LD_ADDR_VAR 0 3
54594: PUSH
54595: LD_EXP 121
54599: PUSH
54600: LD_VAR 0 2
54604: ARRAY
54605: PUSH
54606: LD_INT 1
54608: ARRAY
54609: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54610: LD_ADDR_EXP 121
54614: PUSH
54615: LD_EXP 121
54619: PPUSH
54620: LD_VAR 0 2
54624: PPUSH
54625: EMPTY
54626: PPUSH
54627: CALL_OW 1
54631: ST_TO_ADDR
// Attack ( tmp ) ;
54632: LD_VAR 0 3
54636: PPUSH
54637: CALL 132370 0 1
// exit ;
54641: POP
54642: POP
54643: GO 54649
// end ; end ;
54645: GO 54575
54647: POP
54648: POP
// end ;
54649: LD_VAR 0 1
54653: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54654: LD_INT 0
54656: PPUSH
54657: PPUSH
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
54662: PPUSH
// if not mc_bases then
54663: LD_EXP 101
54667: NOT
54668: IFFALSE 54672
// exit ;
54670: GO 55529
// for i = 1 to mc_bases do
54672: LD_ADDR_VAR 0 2
54676: PUSH
54677: DOUBLE
54678: LD_INT 1
54680: DEC
54681: ST_TO_ADDR
54682: LD_EXP 101
54686: PUSH
54687: FOR_TO
54688: IFFALSE 55527
// begin if not mc_bases [ i ] then
54690: LD_EXP 101
54694: PUSH
54695: LD_VAR 0 2
54699: ARRAY
54700: NOT
54701: IFFALSE 54705
// continue ;
54703: GO 54687
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54705: LD_ADDR_VAR 0 7
54709: PUSH
54710: LD_EXP 101
54714: PUSH
54715: LD_VAR 0 2
54719: ARRAY
54720: PUSH
54721: LD_INT 1
54723: ARRAY
54724: PPUSH
54725: CALL 71228 0 1
54729: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54730: LD_ADDR_EXP 124
54734: PUSH
54735: LD_EXP 124
54739: PPUSH
54740: LD_VAR 0 2
54744: PPUSH
54745: LD_EXP 101
54749: PUSH
54750: LD_VAR 0 2
54754: ARRAY
54755: PUSH
54756: LD_INT 1
54758: ARRAY
54759: PPUSH
54760: CALL_OW 255
54764: PPUSH
54765: LD_EXP 126
54769: PUSH
54770: LD_VAR 0 2
54774: ARRAY
54775: PPUSH
54776: CALL 71193 0 2
54780: PPUSH
54781: CALL_OW 1
54785: ST_TO_ADDR
// if not mc_scan [ i ] then
54786: LD_EXP 124
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: NOT
54797: IFFALSE 54975
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54799: LD_ADDR_EXP 144
54803: PUSH
54804: LD_EXP 144
54808: PPUSH
54809: LD_VAR 0 2
54813: PPUSH
54814: LD_INT 0
54816: PPUSH
54817: CALL_OW 1
54821: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54822: LD_ADDR_VAR 0 4
54826: PUSH
54827: LD_EXP 101
54831: PUSH
54832: LD_VAR 0 2
54836: ARRAY
54837: PPUSH
54838: LD_INT 2
54840: PUSH
54841: LD_INT 25
54843: PUSH
54844: LD_INT 5
54846: PUSH
54847: EMPTY
54848: LIST
54849: LIST
54850: PUSH
54851: LD_INT 25
54853: PUSH
54854: LD_INT 8
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: PUSH
54861: LD_INT 25
54863: PUSH
54864: LD_INT 9
54866: PUSH
54867: EMPTY
54868: LIST
54869: LIST
54870: PUSH
54871: EMPTY
54872: LIST
54873: LIST
54874: LIST
54875: LIST
54876: PPUSH
54877: CALL_OW 72
54881: ST_TO_ADDR
// if not tmp then
54882: LD_VAR 0 4
54886: NOT
54887: IFFALSE 54891
// continue ;
54889: GO 54687
// for j in tmp do
54891: LD_ADDR_VAR 0 3
54895: PUSH
54896: LD_VAR 0 4
54900: PUSH
54901: FOR_IN
54902: IFFALSE 54973
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54904: LD_VAR 0 3
54908: PPUSH
54909: CALL_OW 310
54913: PPUSH
54914: CALL_OW 266
54918: PUSH
54919: LD_INT 5
54921: EQUAL
54922: PUSH
54923: LD_VAR 0 3
54927: PPUSH
54928: CALL_OW 257
54932: PUSH
54933: LD_INT 1
54935: EQUAL
54936: AND
54937: PUSH
54938: LD_VAR 0 3
54942: PPUSH
54943: CALL_OW 459
54947: NOT
54948: AND
54949: PUSH
54950: LD_VAR 0 7
54954: AND
54955: IFFALSE 54971
// ComChangeProfession ( j , class ) ;
54957: LD_VAR 0 3
54961: PPUSH
54962: LD_VAR 0 7
54966: PPUSH
54967: CALL_OW 123
54971: GO 54901
54973: POP
54974: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54975: LD_EXP 124
54979: PUSH
54980: LD_VAR 0 2
54984: ARRAY
54985: PUSH
54986: LD_EXP 144
54990: PUSH
54991: LD_VAR 0 2
54995: ARRAY
54996: NOT
54997: AND
54998: PUSH
54999: LD_EXP 123
55003: PUSH
55004: LD_VAR 0 2
55008: ARRAY
55009: NOT
55010: AND
55011: PUSH
55012: LD_EXP 101
55016: PUSH
55017: LD_VAR 0 2
55021: ARRAY
55022: PPUSH
55023: LD_INT 50
55025: PUSH
55026: EMPTY
55027: LIST
55028: PUSH
55029: LD_INT 2
55031: PUSH
55032: LD_INT 30
55034: PUSH
55035: LD_INT 32
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: PUSH
55042: LD_INT 30
55044: PUSH
55045: LD_INT 33
55047: PUSH
55048: EMPTY
55049: LIST
55050: LIST
55051: PUSH
55052: LD_INT 30
55054: PUSH
55055: LD_INT 4
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: PUSH
55062: LD_INT 30
55064: PUSH
55065: LD_INT 5
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: LIST
55076: LIST
55077: LIST
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: PPUSH
55083: CALL_OW 72
55087: PUSH
55088: LD_INT 4
55090: LESS
55091: PUSH
55092: LD_EXP 101
55096: PUSH
55097: LD_VAR 0 2
55101: ARRAY
55102: PPUSH
55103: LD_INT 3
55105: PUSH
55106: LD_INT 24
55108: PUSH
55109: LD_INT 1000
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: LD_INT 2
55122: PUSH
55123: LD_INT 30
55125: PUSH
55126: LD_INT 0
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PUSH
55133: LD_INT 30
55135: PUSH
55136: LD_INT 1
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: LIST
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: PPUSH
55152: CALL_OW 72
55156: OR
55157: AND
55158: IFFALSE 55409
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55160: LD_ADDR_EXP 144
55164: PUSH
55165: LD_EXP 144
55169: PPUSH
55170: LD_VAR 0 2
55174: PPUSH
55175: LD_INT 1
55177: PPUSH
55178: CALL_OW 1
55182: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55183: LD_ADDR_VAR 0 4
55187: PUSH
55188: LD_EXP 101
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PPUSH
55199: LD_INT 2
55201: PUSH
55202: LD_INT 25
55204: PUSH
55205: LD_INT 1
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: PUSH
55212: LD_INT 25
55214: PUSH
55215: LD_INT 5
55217: PUSH
55218: EMPTY
55219: LIST
55220: LIST
55221: PUSH
55222: LD_INT 25
55224: PUSH
55225: LD_INT 8
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: PUSH
55232: LD_INT 25
55234: PUSH
55235: LD_INT 9
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: LIST
55246: LIST
55247: LIST
55248: PPUSH
55249: CALL_OW 72
55253: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55254: LD_ADDR_VAR 0 4
55258: PUSH
55259: LD_VAR 0 4
55263: PUSH
55264: LD_VAR 0 4
55268: PPUSH
55269: LD_INT 18
55271: PPUSH
55272: CALL 104713 0 2
55276: DIFF
55277: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55278: LD_VAR 0 4
55282: NOT
55283: PUSH
55284: LD_EXP 101
55288: PUSH
55289: LD_VAR 0 2
55293: ARRAY
55294: PPUSH
55295: LD_INT 2
55297: PUSH
55298: LD_INT 30
55300: PUSH
55301: LD_INT 4
55303: PUSH
55304: EMPTY
55305: LIST
55306: LIST
55307: PUSH
55308: LD_INT 30
55310: PUSH
55311: LD_INT 5
55313: PUSH
55314: EMPTY
55315: LIST
55316: LIST
55317: PUSH
55318: EMPTY
55319: LIST
55320: LIST
55321: LIST
55322: PPUSH
55323: CALL_OW 72
55327: NOT
55328: AND
55329: IFFALSE 55391
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55331: LD_ADDR_VAR 0 4
55335: PUSH
55336: LD_EXP 101
55340: PUSH
55341: LD_VAR 0 2
55345: ARRAY
55346: PPUSH
55347: LD_INT 2
55349: PUSH
55350: LD_INT 25
55352: PUSH
55353: LD_INT 2
55355: PUSH
55356: EMPTY
55357: LIST
55358: LIST
55359: PUSH
55360: LD_INT 25
55362: PUSH
55363: LD_INT 3
55365: PUSH
55366: EMPTY
55367: LIST
55368: LIST
55369: PUSH
55370: LD_INT 25
55372: PUSH
55373: LD_INT 4
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: PUSH
55380: EMPTY
55381: LIST
55382: LIST
55383: LIST
55384: LIST
55385: PPUSH
55386: CALL_OW 72
55390: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55391: LD_VAR 0 2
55395: PPUSH
55396: LD_VAR 0 4
55400: PPUSH
55401: CALL 137079 0 2
// exit ;
55405: POP
55406: POP
55407: GO 55529
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55409: LD_EXP 124
55413: PUSH
55414: LD_VAR 0 2
55418: ARRAY
55419: PUSH
55420: LD_EXP 144
55424: PUSH
55425: LD_VAR 0 2
55429: ARRAY
55430: NOT
55431: AND
55432: PUSH
55433: LD_EXP 123
55437: PUSH
55438: LD_VAR 0 2
55442: ARRAY
55443: AND
55444: IFFALSE 55525
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55446: LD_ADDR_EXP 144
55450: PUSH
55451: LD_EXP 144
55455: PPUSH
55456: LD_VAR 0 2
55460: PPUSH
55461: LD_INT 1
55463: PPUSH
55464: CALL_OW 1
55468: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55469: LD_ADDR_VAR 0 4
55473: PUSH
55474: LD_EXP 123
55478: PUSH
55479: LD_VAR 0 2
55483: ARRAY
55484: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55485: LD_ADDR_EXP 123
55489: PUSH
55490: LD_EXP 123
55494: PPUSH
55495: LD_VAR 0 2
55499: PPUSH
55500: EMPTY
55501: PPUSH
55502: CALL_OW 1
55506: ST_TO_ADDR
// Defend ( i , tmp ) ;
55507: LD_VAR 0 2
55511: PPUSH
55512: LD_VAR 0 4
55516: PPUSH
55517: CALL 137675 0 2
// exit ;
55521: POP
55522: POP
55523: GO 55529
// end ; end ;
55525: GO 54687
55527: POP
55528: POP
// end ;
55529: LD_VAR 0 1
55533: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55534: LD_INT 0
55536: PPUSH
55537: PPUSH
55538: PPUSH
55539: PPUSH
55540: PPUSH
55541: PPUSH
55542: PPUSH
55543: PPUSH
55544: PPUSH
55545: PPUSH
55546: PPUSH
// if not mc_bases then
55547: LD_EXP 101
55551: NOT
55552: IFFALSE 55556
// exit ;
55554: GO 56643
// for i = 1 to mc_bases do
55556: LD_ADDR_VAR 0 2
55560: PUSH
55561: DOUBLE
55562: LD_INT 1
55564: DEC
55565: ST_TO_ADDR
55566: LD_EXP 101
55570: PUSH
55571: FOR_TO
55572: IFFALSE 56641
// begin tmp := mc_lab [ i ] ;
55574: LD_ADDR_VAR 0 6
55578: PUSH
55579: LD_EXP 134
55583: PUSH
55584: LD_VAR 0 2
55588: ARRAY
55589: ST_TO_ADDR
// if not tmp then
55590: LD_VAR 0 6
55594: NOT
55595: IFFALSE 55599
// continue ;
55597: GO 55571
// idle_lab := 0 ;
55599: LD_ADDR_VAR 0 11
55603: PUSH
55604: LD_INT 0
55606: ST_TO_ADDR
// for j in tmp do
55607: LD_ADDR_VAR 0 3
55611: PUSH
55612: LD_VAR 0 6
55616: PUSH
55617: FOR_IN
55618: IFFALSE 56637
// begin researching := false ;
55620: LD_ADDR_VAR 0 10
55624: PUSH
55625: LD_INT 0
55627: ST_TO_ADDR
// side := GetSide ( j ) ;
55628: LD_ADDR_VAR 0 4
55632: PUSH
55633: LD_VAR 0 3
55637: PPUSH
55638: CALL_OW 255
55642: ST_TO_ADDR
// if not mc_tech [ side ] then
55643: LD_EXP 128
55647: PUSH
55648: LD_VAR 0 4
55652: ARRAY
55653: NOT
55654: IFFALSE 55658
// continue ;
55656: GO 55617
// if BuildingStatus ( j ) = bs_idle then
55658: LD_VAR 0 3
55662: PPUSH
55663: CALL_OW 461
55667: PUSH
55668: LD_INT 2
55670: EQUAL
55671: IFFALSE 55859
// begin if idle_lab and UnitsInside ( j ) < 6 then
55673: LD_VAR 0 11
55677: PUSH
55678: LD_VAR 0 3
55682: PPUSH
55683: CALL_OW 313
55687: PUSH
55688: LD_INT 6
55690: LESS
55691: AND
55692: IFFALSE 55763
// begin tmp2 := UnitsInside ( idle_lab ) ;
55694: LD_ADDR_VAR 0 9
55698: PUSH
55699: LD_VAR 0 11
55703: PPUSH
55704: CALL_OW 313
55708: ST_TO_ADDR
// if tmp2 then
55709: LD_VAR 0 9
55713: IFFALSE 55755
// for x in tmp2 do
55715: LD_ADDR_VAR 0 7
55719: PUSH
55720: LD_VAR 0 9
55724: PUSH
55725: FOR_IN
55726: IFFALSE 55753
// begin ComExitBuilding ( x ) ;
55728: LD_VAR 0 7
55732: PPUSH
55733: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55737: LD_VAR 0 7
55741: PPUSH
55742: LD_VAR 0 3
55746: PPUSH
55747: CALL_OW 180
// end ;
55751: GO 55725
55753: POP
55754: POP
// idle_lab := 0 ;
55755: LD_ADDR_VAR 0 11
55759: PUSH
55760: LD_INT 0
55762: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55763: LD_ADDR_VAR 0 5
55767: PUSH
55768: LD_EXP 128
55772: PUSH
55773: LD_VAR 0 4
55777: ARRAY
55778: PUSH
55779: FOR_IN
55780: IFFALSE 55840
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55782: LD_VAR 0 3
55786: PPUSH
55787: LD_VAR 0 5
55791: PPUSH
55792: CALL_OW 430
55796: PUSH
55797: LD_VAR 0 4
55801: PPUSH
55802: LD_VAR 0 5
55806: PPUSH
55807: CALL 70298 0 2
55811: AND
55812: IFFALSE 55838
// begin researching := true ;
55814: LD_ADDR_VAR 0 10
55818: PUSH
55819: LD_INT 1
55821: ST_TO_ADDR
// ComResearch ( j , t ) ;
55822: LD_VAR 0 3
55826: PPUSH
55827: LD_VAR 0 5
55831: PPUSH
55832: CALL_OW 124
// break ;
55836: GO 55840
// end ;
55838: GO 55779
55840: POP
55841: POP
// if not researching then
55842: LD_VAR 0 10
55846: NOT
55847: IFFALSE 55859
// idle_lab := j ;
55849: LD_ADDR_VAR 0 11
55853: PUSH
55854: LD_VAR 0 3
55858: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55859: LD_VAR 0 3
55863: PPUSH
55864: CALL_OW 461
55868: PUSH
55869: LD_INT 10
55871: EQUAL
55872: IFFALSE 56460
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55874: LD_EXP 130
55878: PUSH
55879: LD_VAR 0 2
55883: ARRAY
55884: NOT
55885: PUSH
55886: LD_EXP 131
55890: PUSH
55891: LD_VAR 0 2
55895: ARRAY
55896: NOT
55897: AND
55898: PUSH
55899: LD_EXP 128
55903: PUSH
55904: LD_VAR 0 4
55908: ARRAY
55909: PUSH
55910: LD_INT 1
55912: GREATER
55913: AND
55914: IFFALSE 56045
// begin ComCancel ( j ) ;
55916: LD_VAR 0 3
55920: PPUSH
55921: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55925: LD_ADDR_EXP 128
55929: PUSH
55930: LD_EXP 128
55934: PPUSH
55935: LD_VAR 0 4
55939: PPUSH
55940: LD_EXP 128
55944: PUSH
55945: LD_VAR 0 4
55949: ARRAY
55950: PPUSH
55951: LD_EXP 128
55955: PUSH
55956: LD_VAR 0 4
55960: ARRAY
55961: PUSH
55962: LD_INT 1
55964: MINUS
55965: PPUSH
55966: LD_EXP 128
55970: PUSH
55971: LD_VAR 0 4
55975: ARRAY
55976: PPUSH
55977: LD_INT 0
55979: PPUSH
55980: CALL 73822 0 4
55984: PPUSH
55985: CALL_OW 1
55989: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55990: LD_ADDR_EXP 128
55994: PUSH
55995: LD_EXP 128
55999: PPUSH
56000: LD_VAR 0 4
56004: PPUSH
56005: LD_EXP 128
56009: PUSH
56010: LD_VAR 0 4
56014: ARRAY
56015: PPUSH
56016: LD_EXP 128
56020: PUSH
56021: LD_VAR 0 4
56025: ARRAY
56026: PPUSH
56027: LD_INT 1
56029: PPUSH
56030: LD_INT 0
56032: PPUSH
56033: CALL 73822 0 4
56037: PPUSH
56038: CALL_OW 1
56042: ST_TO_ADDR
// continue ;
56043: GO 55617
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56045: LD_EXP 130
56049: PUSH
56050: LD_VAR 0 2
56054: ARRAY
56055: PUSH
56056: LD_EXP 131
56060: PUSH
56061: LD_VAR 0 2
56065: ARRAY
56066: NOT
56067: AND
56068: IFFALSE 56195
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56070: LD_ADDR_EXP 131
56074: PUSH
56075: LD_EXP 131
56079: PPUSH
56080: LD_VAR 0 2
56084: PUSH
56085: LD_EXP 131
56089: PUSH
56090: LD_VAR 0 2
56094: ARRAY
56095: PUSH
56096: LD_INT 1
56098: PLUS
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: PPUSH
56104: LD_EXP 130
56108: PUSH
56109: LD_VAR 0 2
56113: ARRAY
56114: PUSH
56115: LD_INT 1
56117: ARRAY
56118: PPUSH
56119: CALL 74404 0 3
56123: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56124: LD_EXP 130
56128: PUSH
56129: LD_VAR 0 2
56133: ARRAY
56134: PUSH
56135: LD_INT 1
56137: ARRAY
56138: PPUSH
56139: LD_INT 112
56141: PPUSH
56142: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56146: LD_ADDR_VAR 0 9
56150: PUSH
56151: LD_EXP 130
56155: PUSH
56156: LD_VAR 0 2
56160: ARRAY
56161: PPUSH
56162: LD_INT 1
56164: PPUSH
56165: CALL_OW 3
56169: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56170: LD_ADDR_EXP 130
56174: PUSH
56175: LD_EXP 130
56179: PPUSH
56180: LD_VAR 0 2
56184: PPUSH
56185: LD_VAR 0 9
56189: PPUSH
56190: CALL_OW 1
56194: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56195: LD_EXP 130
56199: PUSH
56200: LD_VAR 0 2
56204: ARRAY
56205: PUSH
56206: LD_EXP 131
56210: PUSH
56211: LD_VAR 0 2
56215: ARRAY
56216: AND
56217: PUSH
56218: LD_EXP 131
56222: PUSH
56223: LD_VAR 0 2
56227: ARRAY
56228: PUSH
56229: LD_INT 1
56231: ARRAY
56232: PPUSH
56233: CALL_OW 310
56237: NOT
56238: AND
56239: PUSH
56240: LD_VAR 0 3
56244: PPUSH
56245: CALL_OW 313
56249: PUSH
56250: LD_INT 6
56252: EQUAL
56253: AND
56254: IFFALSE 56310
// begin tmp2 := UnitsInside ( j ) ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_VAR 0 3
56265: PPUSH
56266: CALL_OW 313
56270: ST_TO_ADDR
// if tmp2 = 6 then
56271: LD_VAR 0 9
56275: PUSH
56276: LD_INT 6
56278: EQUAL
56279: IFFALSE 56310
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56281: LD_VAR 0 9
56285: PUSH
56286: LD_INT 1
56288: ARRAY
56289: PPUSH
56290: LD_INT 112
56292: PPUSH
56293: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56297: LD_VAR 0 9
56301: PUSH
56302: LD_INT 1
56304: ARRAY
56305: PPUSH
56306: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56310: LD_EXP 131
56314: PUSH
56315: LD_VAR 0 2
56319: ARRAY
56320: PUSH
56321: LD_EXP 131
56325: PUSH
56326: LD_VAR 0 2
56330: ARRAY
56331: PUSH
56332: LD_INT 1
56334: ARRAY
56335: PPUSH
56336: CALL_OW 314
56340: NOT
56341: AND
56342: PUSH
56343: LD_EXP 131
56347: PUSH
56348: LD_VAR 0 2
56352: ARRAY
56353: PUSH
56354: LD_INT 1
56356: ARRAY
56357: PPUSH
56358: CALL_OW 310
56362: NOT
56363: AND
56364: IFFALSE 56390
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56366: LD_EXP 131
56370: PUSH
56371: LD_VAR 0 2
56375: ARRAY
56376: PUSH
56377: LD_INT 1
56379: ARRAY
56380: PPUSH
56381: LD_VAR 0 3
56385: PPUSH
56386: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56390: LD_EXP 131
56394: PUSH
56395: LD_VAR 0 2
56399: ARRAY
56400: PUSH
56401: LD_INT 1
56403: ARRAY
56404: PPUSH
56405: CALL_OW 310
56409: PUSH
56410: LD_EXP 131
56414: PUSH
56415: LD_VAR 0 2
56419: ARRAY
56420: PUSH
56421: LD_INT 1
56423: ARRAY
56424: PPUSH
56425: CALL_OW 310
56429: PPUSH
56430: CALL_OW 461
56434: PUSH
56435: LD_INT 3
56437: NONEQUAL
56438: AND
56439: IFFALSE 56460
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56441: LD_EXP 131
56445: PUSH
56446: LD_VAR 0 2
56450: ARRAY
56451: PUSH
56452: LD_INT 1
56454: ARRAY
56455: PPUSH
56456: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56460: LD_VAR 0 3
56464: PPUSH
56465: CALL_OW 461
56469: PUSH
56470: LD_INT 6
56472: EQUAL
56473: PUSH
56474: LD_VAR 0 6
56478: PUSH
56479: LD_INT 1
56481: GREATER
56482: AND
56483: IFFALSE 56635
// begin sci := [ ] ;
56485: LD_ADDR_VAR 0 8
56489: PUSH
56490: EMPTY
56491: ST_TO_ADDR
// for x in ( tmp diff j ) do
56492: LD_ADDR_VAR 0 7
56496: PUSH
56497: LD_VAR 0 6
56501: PUSH
56502: LD_VAR 0 3
56506: DIFF
56507: PUSH
56508: FOR_IN
56509: IFFALSE 56561
// begin if sci = 6 then
56511: LD_VAR 0 8
56515: PUSH
56516: LD_INT 6
56518: EQUAL
56519: IFFALSE 56523
// break ;
56521: GO 56561
// if BuildingStatus ( x ) = bs_idle then
56523: LD_VAR 0 7
56527: PPUSH
56528: CALL_OW 461
56532: PUSH
56533: LD_INT 2
56535: EQUAL
56536: IFFALSE 56559
// sci := sci ^ UnitsInside ( x ) ;
56538: LD_ADDR_VAR 0 8
56542: PUSH
56543: LD_VAR 0 8
56547: PUSH
56548: LD_VAR 0 7
56552: PPUSH
56553: CALL_OW 313
56557: ADD
56558: ST_TO_ADDR
// end ;
56559: GO 56508
56561: POP
56562: POP
// if not sci then
56563: LD_VAR 0 8
56567: NOT
56568: IFFALSE 56572
// continue ;
56570: GO 55617
// for x in sci do
56572: LD_ADDR_VAR 0 7
56576: PUSH
56577: LD_VAR 0 8
56581: PUSH
56582: FOR_IN
56583: IFFALSE 56633
// if IsInUnit ( x ) and not HasTask ( x ) then
56585: LD_VAR 0 7
56589: PPUSH
56590: CALL_OW 310
56594: PUSH
56595: LD_VAR 0 7
56599: PPUSH
56600: CALL_OW 314
56604: NOT
56605: AND
56606: IFFALSE 56631
// begin ComExitBuilding ( x ) ;
56608: LD_VAR 0 7
56612: PPUSH
56613: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56617: LD_VAR 0 7
56621: PPUSH
56622: LD_VAR 0 3
56626: PPUSH
56627: CALL_OW 180
// end ;
56631: GO 56582
56633: POP
56634: POP
// end ; end ;
56635: GO 55617
56637: POP
56638: POP
// end ;
56639: GO 55571
56641: POP
56642: POP
// end ;
56643: LD_VAR 0 1
56647: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56648: LD_INT 0
56650: PPUSH
56651: PPUSH
// if not mc_bases then
56652: LD_EXP 101
56656: NOT
56657: IFFALSE 56661
// exit ;
56659: GO 56742
// for i = 1 to mc_bases do
56661: LD_ADDR_VAR 0 2
56665: PUSH
56666: DOUBLE
56667: LD_INT 1
56669: DEC
56670: ST_TO_ADDR
56671: LD_EXP 101
56675: PUSH
56676: FOR_TO
56677: IFFALSE 56740
// if mc_mines [ i ] and mc_miners [ i ] then
56679: LD_EXP 114
56683: PUSH
56684: LD_VAR 0 2
56688: ARRAY
56689: PUSH
56690: LD_EXP 115
56694: PUSH
56695: LD_VAR 0 2
56699: ARRAY
56700: AND
56701: IFFALSE 56738
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56703: LD_EXP 115
56707: PUSH
56708: LD_VAR 0 2
56712: ARRAY
56713: PUSH
56714: LD_INT 1
56716: ARRAY
56717: PPUSH
56718: CALL_OW 255
56722: PPUSH
56723: LD_EXP 114
56727: PUSH
56728: LD_VAR 0 2
56732: ARRAY
56733: PPUSH
56734: CALL 71381 0 2
56738: GO 56676
56740: POP
56741: POP
// end ;
56742: LD_VAR 0 1
56746: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56747: LD_INT 0
56749: PPUSH
56750: PPUSH
56751: PPUSH
56752: PPUSH
56753: PPUSH
56754: PPUSH
56755: PPUSH
56756: PPUSH
// if not mc_bases or not mc_parking then
56757: LD_EXP 101
56761: NOT
56762: PUSH
56763: LD_EXP 125
56767: NOT
56768: OR
56769: IFFALSE 56773
// exit ;
56771: GO 57511
// for i = 1 to mc_bases do
56773: LD_ADDR_VAR 0 2
56777: PUSH
56778: DOUBLE
56779: LD_INT 1
56781: DEC
56782: ST_TO_ADDR
56783: LD_EXP 101
56787: PUSH
56788: FOR_TO
56789: IFFALSE 57509
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56791: LD_EXP 101
56795: PUSH
56796: LD_VAR 0 2
56800: ARRAY
56801: NOT
56802: PUSH
56803: LD_EXP 125
56807: PUSH
56808: LD_VAR 0 2
56812: ARRAY
56813: NOT
56814: OR
56815: IFFALSE 56819
// continue ;
56817: GO 56788
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56819: LD_ADDR_VAR 0 5
56823: PUSH
56824: LD_EXP 101
56828: PUSH
56829: LD_VAR 0 2
56833: ARRAY
56834: PUSH
56835: LD_INT 1
56837: ARRAY
56838: PPUSH
56839: CALL_OW 255
56843: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56844: LD_ADDR_VAR 0 6
56848: PUSH
56849: LD_EXP 101
56853: PUSH
56854: LD_VAR 0 2
56858: ARRAY
56859: PPUSH
56860: LD_INT 30
56862: PUSH
56863: LD_INT 3
56865: PUSH
56866: EMPTY
56867: LIST
56868: LIST
56869: PPUSH
56870: CALL_OW 72
56874: ST_TO_ADDR
// if not fac then
56875: LD_VAR 0 6
56879: NOT
56880: IFFALSE 56931
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56882: LD_ADDR_VAR 0 6
56886: PUSH
56887: LD_EXP 101
56891: PUSH
56892: LD_VAR 0 2
56896: ARRAY
56897: PPUSH
56898: LD_INT 2
56900: PUSH
56901: LD_INT 30
56903: PUSH
56904: LD_INT 0
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: PUSH
56911: LD_INT 30
56913: PUSH
56914: LD_INT 1
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: PUSH
56921: EMPTY
56922: LIST
56923: LIST
56924: LIST
56925: PPUSH
56926: CALL_OW 72
56930: ST_TO_ADDR
// if not fac then
56931: LD_VAR 0 6
56935: NOT
56936: IFFALSE 56940
// continue ;
56938: GO 56788
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56940: LD_ADDR_VAR 0 7
56944: PUSH
56945: LD_EXP 125
56949: PUSH
56950: LD_VAR 0 2
56954: ARRAY
56955: PPUSH
56956: LD_INT 22
56958: PUSH
56959: LD_VAR 0 5
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: PUSH
56968: LD_INT 21
56970: PUSH
56971: LD_INT 2
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: PUSH
56978: LD_INT 3
56980: PUSH
56981: LD_INT 60
56983: PUSH
56984: EMPTY
56985: LIST
56986: PUSH
56987: EMPTY
56988: LIST
56989: LIST
56990: PUSH
56991: LD_INT 3
56993: PUSH
56994: LD_INT 24
56996: PUSH
56997: LD_INT 1000
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: PUSH
57004: EMPTY
57005: LIST
57006: LIST
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: LIST
57012: LIST
57013: PPUSH
57014: CALL_OW 70
57018: ST_TO_ADDR
// for j in fac do
57019: LD_ADDR_VAR 0 3
57023: PUSH
57024: LD_VAR 0 6
57028: PUSH
57029: FOR_IN
57030: IFFALSE 57125
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57032: LD_ADDR_VAR 0 7
57036: PUSH
57037: LD_VAR 0 7
57041: PUSH
57042: LD_INT 22
57044: PUSH
57045: LD_VAR 0 5
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PUSH
57054: LD_INT 91
57056: PUSH
57057: LD_VAR 0 3
57061: PUSH
57062: LD_INT 15
57064: PUSH
57065: EMPTY
57066: LIST
57067: LIST
57068: LIST
57069: PUSH
57070: LD_INT 21
57072: PUSH
57073: LD_INT 2
57075: PUSH
57076: EMPTY
57077: LIST
57078: LIST
57079: PUSH
57080: LD_INT 3
57082: PUSH
57083: LD_INT 60
57085: PUSH
57086: EMPTY
57087: LIST
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: PUSH
57093: LD_INT 3
57095: PUSH
57096: LD_INT 24
57098: PUSH
57099: LD_INT 1000
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: PUSH
57110: EMPTY
57111: LIST
57112: LIST
57113: LIST
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 69
57121: UNION
57122: ST_TO_ADDR
57123: GO 57029
57125: POP
57126: POP
// if not vehs then
57127: LD_VAR 0 7
57131: NOT
57132: IFFALSE 57158
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57134: LD_ADDR_EXP 113
57138: PUSH
57139: LD_EXP 113
57143: PPUSH
57144: LD_VAR 0 2
57148: PPUSH
57149: EMPTY
57150: PPUSH
57151: CALL_OW 1
57155: ST_TO_ADDR
// continue ;
57156: GO 56788
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57158: LD_ADDR_VAR 0 8
57162: PUSH
57163: LD_EXP 101
57167: PUSH
57168: LD_VAR 0 2
57172: ARRAY
57173: PPUSH
57174: LD_INT 30
57176: PUSH
57177: LD_INT 3
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PPUSH
57184: CALL_OW 72
57188: ST_TO_ADDR
// if tmp then
57189: LD_VAR 0 8
57193: IFFALSE 57296
// begin for j in tmp do
57195: LD_ADDR_VAR 0 3
57199: PUSH
57200: LD_VAR 0 8
57204: PUSH
57205: FOR_IN
57206: IFFALSE 57294
// for k in UnitsInside ( j ) do
57208: LD_ADDR_VAR 0 4
57212: PUSH
57213: LD_VAR 0 3
57217: PPUSH
57218: CALL_OW 313
57222: PUSH
57223: FOR_IN
57224: IFFALSE 57290
// if k then
57226: LD_VAR 0 4
57230: IFFALSE 57288
// if not k in mc_repair_vehicle [ i ] then
57232: LD_VAR 0 4
57236: PUSH
57237: LD_EXP 113
57241: PUSH
57242: LD_VAR 0 2
57246: ARRAY
57247: IN
57248: NOT
57249: IFFALSE 57288
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57251: LD_ADDR_EXP 113
57255: PUSH
57256: LD_EXP 113
57260: PPUSH
57261: LD_VAR 0 2
57265: PPUSH
57266: LD_EXP 113
57270: PUSH
57271: LD_VAR 0 2
57275: ARRAY
57276: PUSH
57277: LD_VAR 0 4
57281: UNION
57282: PPUSH
57283: CALL_OW 1
57287: ST_TO_ADDR
57288: GO 57223
57290: POP
57291: POP
57292: GO 57205
57294: POP
57295: POP
// end ; if not mc_repair_vehicle [ i ] then
57296: LD_EXP 113
57300: PUSH
57301: LD_VAR 0 2
57305: ARRAY
57306: NOT
57307: IFFALSE 57311
// continue ;
57309: GO 56788
// for j in mc_repair_vehicle [ i ] do
57311: LD_ADDR_VAR 0 3
57315: PUSH
57316: LD_EXP 113
57320: PUSH
57321: LD_VAR 0 2
57325: ARRAY
57326: PUSH
57327: FOR_IN
57328: IFFALSE 57505
// begin if GetClass ( j ) <> 3 then
57330: LD_VAR 0 3
57334: PPUSH
57335: CALL_OW 257
57339: PUSH
57340: LD_INT 3
57342: NONEQUAL
57343: IFFALSE 57384
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57345: LD_ADDR_EXP 113
57349: PUSH
57350: LD_EXP 113
57354: PPUSH
57355: LD_VAR 0 2
57359: PPUSH
57360: LD_EXP 113
57364: PUSH
57365: LD_VAR 0 2
57369: ARRAY
57370: PUSH
57371: LD_VAR 0 3
57375: DIFF
57376: PPUSH
57377: CALL_OW 1
57381: ST_TO_ADDR
// continue ;
57382: GO 57327
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57384: LD_VAR 0 3
57388: PPUSH
57389: CALL_OW 311
57393: NOT
57394: PUSH
57395: LD_VAR 0 3
57399: PUSH
57400: LD_EXP 104
57404: PUSH
57405: LD_VAR 0 2
57409: ARRAY
57410: PUSH
57411: LD_INT 1
57413: ARRAY
57414: IN
57415: NOT
57416: AND
57417: PUSH
57418: LD_VAR 0 3
57422: PUSH
57423: LD_EXP 104
57427: PUSH
57428: LD_VAR 0 2
57432: ARRAY
57433: PUSH
57434: LD_INT 2
57436: ARRAY
57437: IN
57438: NOT
57439: AND
57440: IFFALSE 57503
// begin if IsInUnit ( j ) then
57442: LD_VAR 0 3
57446: PPUSH
57447: CALL_OW 310
57451: IFFALSE 57464
// ComExitBuilding ( j ) else
57453: LD_VAR 0 3
57457: PPUSH
57458: CALL_OW 122
57462: GO 57503
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57464: LD_VAR 0 3
57468: PPUSH
57469: LD_VAR 0 7
57473: PUSH
57474: LD_INT 1
57476: ARRAY
57477: PPUSH
57478: CALL 109209 0 2
57482: NOT
57483: IFFALSE 57503
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57485: LD_VAR 0 3
57489: PPUSH
57490: LD_VAR 0 7
57494: PUSH
57495: LD_INT 1
57497: ARRAY
57498: PPUSH
57499: CALL_OW 129
// end ; end ;
57503: GO 57327
57505: POP
57506: POP
// end ;
57507: GO 56788
57509: POP
57510: POP
// end ;
57511: LD_VAR 0 1
57515: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57516: LD_INT 0
57518: PPUSH
57519: PPUSH
57520: PPUSH
57521: PPUSH
57522: PPUSH
57523: PPUSH
57524: PPUSH
57525: PPUSH
57526: PPUSH
57527: PPUSH
57528: PPUSH
// if not mc_bases then
57529: LD_EXP 101
57533: NOT
57534: IFFALSE 57538
// exit ;
57536: GO 58340
// for i = 1 to mc_bases do
57538: LD_ADDR_VAR 0 2
57542: PUSH
57543: DOUBLE
57544: LD_INT 1
57546: DEC
57547: ST_TO_ADDR
57548: LD_EXP 101
57552: PUSH
57553: FOR_TO
57554: IFFALSE 58338
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57556: LD_EXP 129
57560: PUSH
57561: LD_VAR 0 2
57565: ARRAY
57566: NOT
57567: PUSH
57568: LD_EXP 104
57572: PUSH
57573: LD_VAR 0 2
57577: ARRAY
57578: PUSH
57579: LD_INT 1
57581: ARRAY
57582: OR
57583: PUSH
57584: LD_EXP 104
57588: PUSH
57589: LD_VAR 0 2
57593: ARRAY
57594: PUSH
57595: LD_INT 2
57597: ARRAY
57598: OR
57599: PUSH
57600: LD_EXP 127
57604: PUSH
57605: LD_VAR 0 2
57609: ARRAY
57610: PPUSH
57611: LD_INT 1
57613: PPUSH
57614: CALL_OW 325
57618: NOT
57619: OR
57620: PUSH
57621: LD_EXP 124
57625: PUSH
57626: LD_VAR 0 2
57630: ARRAY
57631: OR
57632: IFFALSE 57636
// continue ;
57634: GO 57553
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57636: LD_ADDR_VAR 0 8
57640: PUSH
57641: LD_EXP 101
57645: PUSH
57646: LD_VAR 0 2
57650: ARRAY
57651: PPUSH
57652: LD_INT 25
57654: PUSH
57655: LD_INT 4
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: PUSH
57662: LD_INT 50
57664: PUSH
57665: EMPTY
57666: LIST
57667: PUSH
57668: LD_INT 3
57670: PUSH
57671: LD_INT 60
57673: PUSH
57674: EMPTY
57675: LIST
57676: PUSH
57677: EMPTY
57678: LIST
57679: LIST
57680: PUSH
57681: EMPTY
57682: LIST
57683: LIST
57684: LIST
57685: PPUSH
57686: CALL_OW 72
57690: PUSH
57691: LD_EXP 105
57695: PUSH
57696: LD_VAR 0 2
57700: ARRAY
57701: DIFF
57702: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57703: LD_ADDR_VAR 0 9
57707: PUSH
57708: LD_EXP 101
57712: PUSH
57713: LD_VAR 0 2
57717: ARRAY
57718: PPUSH
57719: LD_INT 2
57721: PUSH
57722: LD_INT 30
57724: PUSH
57725: LD_INT 0
57727: PUSH
57728: EMPTY
57729: LIST
57730: LIST
57731: PUSH
57732: LD_INT 30
57734: PUSH
57735: LD_INT 1
57737: PUSH
57738: EMPTY
57739: LIST
57740: LIST
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: LIST
57746: PPUSH
57747: CALL_OW 72
57751: ST_TO_ADDR
// if not tmp or not dep then
57752: LD_VAR 0 8
57756: NOT
57757: PUSH
57758: LD_VAR 0 9
57762: NOT
57763: OR
57764: IFFALSE 57768
// continue ;
57766: GO 57553
// side := GetSide ( tmp [ 1 ] ) ;
57768: LD_ADDR_VAR 0 11
57772: PUSH
57773: LD_VAR 0 8
57777: PUSH
57778: LD_INT 1
57780: ARRAY
57781: PPUSH
57782: CALL_OW 255
57786: ST_TO_ADDR
// dep := dep [ 1 ] ;
57787: LD_ADDR_VAR 0 9
57791: PUSH
57792: LD_VAR 0 9
57796: PUSH
57797: LD_INT 1
57799: ARRAY
57800: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57801: LD_ADDR_VAR 0 7
57805: PUSH
57806: LD_EXP 129
57810: PUSH
57811: LD_VAR 0 2
57815: ARRAY
57816: PPUSH
57817: LD_INT 22
57819: PUSH
57820: LD_INT 0
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PUSH
57827: LD_INT 25
57829: PUSH
57830: LD_INT 12
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: PUSH
57837: EMPTY
57838: LIST
57839: LIST
57840: PPUSH
57841: CALL_OW 70
57845: PUSH
57846: LD_INT 22
57848: PUSH
57849: LD_INT 0
57851: PUSH
57852: EMPTY
57853: LIST
57854: LIST
57855: PUSH
57856: LD_INT 25
57858: PUSH
57859: LD_INT 12
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: PUSH
57866: LD_INT 91
57868: PUSH
57869: LD_VAR 0 9
57873: PUSH
57874: LD_INT 20
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: LIST
57881: PUSH
57882: EMPTY
57883: LIST
57884: LIST
57885: LIST
57886: PPUSH
57887: CALL_OW 69
57891: UNION
57892: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57893: LD_ADDR_VAR 0 10
57897: PUSH
57898: LD_EXP 129
57902: PUSH
57903: LD_VAR 0 2
57907: ARRAY
57908: PPUSH
57909: LD_INT 81
57911: PUSH
57912: LD_VAR 0 11
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PPUSH
57921: CALL_OW 70
57925: ST_TO_ADDR
// if not apes or danger_at_area then
57926: LD_VAR 0 7
57930: NOT
57931: PUSH
57932: LD_VAR 0 10
57936: OR
57937: IFFALSE 57987
// begin if mc_taming [ i ] then
57939: LD_EXP 132
57943: PUSH
57944: LD_VAR 0 2
57948: ARRAY
57949: IFFALSE 57985
// begin MC_Reset ( i , 121 ) ;
57951: LD_VAR 0 2
57955: PPUSH
57956: LD_INT 121
57958: PPUSH
57959: CALL 42903 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57963: LD_ADDR_EXP 132
57967: PUSH
57968: LD_EXP 132
57972: PPUSH
57973: LD_VAR 0 2
57977: PPUSH
57978: EMPTY
57979: PPUSH
57980: CALL_OW 1
57984: ST_TO_ADDR
// end ; continue ;
57985: GO 57553
// end ; for j in tmp do
57987: LD_ADDR_VAR 0 3
57991: PUSH
57992: LD_VAR 0 8
57996: PUSH
57997: FOR_IN
57998: IFFALSE 58334
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58000: LD_VAR 0 3
58004: PUSH
58005: LD_EXP 132
58009: PUSH
58010: LD_VAR 0 2
58014: ARRAY
58015: IN
58016: NOT
58017: PUSH
58018: LD_EXP 132
58022: PUSH
58023: LD_VAR 0 2
58027: ARRAY
58028: PUSH
58029: LD_INT 3
58031: LESS
58032: AND
58033: IFFALSE 58091
// begin SetTag ( j , 121 ) ;
58035: LD_VAR 0 3
58039: PPUSH
58040: LD_INT 121
58042: PPUSH
58043: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58047: LD_ADDR_EXP 132
58051: PUSH
58052: LD_EXP 132
58056: PPUSH
58057: LD_VAR 0 2
58061: PUSH
58062: LD_EXP 132
58066: PUSH
58067: LD_VAR 0 2
58071: ARRAY
58072: PUSH
58073: LD_INT 1
58075: PLUS
58076: PUSH
58077: EMPTY
58078: LIST
58079: LIST
58080: PPUSH
58081: LD_VAR 0 3
58085: PPUSH
58086: CALL 74404 0 3
58090: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58091: LD_VAR 0 3
58095: PUSH
58096: LD_EXP 132
58100: PUSH
58101: LD_VAR 0 2
58105: ARRAY
58106: IN
58107: IFFALSE 58332
// begin if GetClass ( j ) <> 4 then
58109: LD_VAR 0 3
58113: PPUSH
58114: CALL_OW 257
58118: PUSH
58119: LD_INT 4
58121: NONEQUAL
58122: IFFALSE 58175
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58124: LD_ADDR_EXP 132
58128: PUSH
58129: LD_EXP 132
58133: PPUSH
58134: LD_VAR 0 2
58138: PPUSH
58139: LD_EXP 132
58143: PUSH
58144: LD_VAR 0 2
58148: ARRAY
58149: PUSH
58150: LD_VAR 0 3
58154: DIFF
58155: PPUSH
58156: CALL_OW 1
58160: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58161: LD_VAR 0 3
58165: PPUSH
58166: LD_INT 0
58168: PPUSH
58169: CALL_OW 109
// continue ;
58173: GO 57997
// end ; if IsInUnit ( j ) then
58175: LD_VAR 0 3
58179: PPUSH
58180: CALL_OW 310
58184: IFFALSE 58195
// ComExitBuilding ( j ) ;
58186: LD_VAR 0 3
58190: PPUSH
58191: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58195: LD_ADDR_VAR 0 6
58199: PUSH
58200: LD_VAR 0 7
58204: PPUSH
58205: LD_VAR 0 3
58209: PPUSH
58210: CALL_OW 74
58214: ST_TO_ADDR
// if not ape then
58215: LD_VAR 0 6
58219: NOT
58220: IFFALSE 58224
// break ;
58222: GO 58334
// x := GetX ( ape ) ;
58224: LD_ADDR_VAR 0 4
58228: PUSH
58229: LD_VAR 0 6
58233: PPUSH
58234: CALL_OW 250
58238: ST_TO_ADDR
// y := GetY ( ape ) ;
58239: LD_ADDR_VAR 0 5
58243: PUSH
58244: LD_VAR 0 6
58248: PPUSH
58249: CALL_OW 251
58253: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58254: LD_VAR 0 4
58258: PPUSH
58259: LD_VAR 0 5
58263: PPUSH
58264: CALL_OW 488
58268: NOT
58269: PUSH
58270: LD_VAR 0 11
58274: PPUSH
58275: LD_VAR 0 4
58279: PPUSH
58280: LD_VAR 0 5
58284: PPUSH
58285: LD_INT 20
58287: PPUSH
58288: CALL 75668 0 4
58292: PUSH
58293: LD_INT 4
58295: ARRAY
58296: OR
58297: IFFALSE 58301
// break ;
58299: GO 58334
// if not HasTask ( j ) then
58301: LD_VAR 0 3
58305: PPUSH
58306: CALL_OW 314
58310: NOT
58311: IFFALSE 58332
// ComTameXY ( j , x , y ) ;
58313: LD_VAR 0 3
58317: PPUSH
58318: LD_VAR 0 4
58322: PPUSH
58323: LD_VAR 0 5
58327: PPUSH
58328: CALL_OW 131
// end ; end ;
58332: GO 57997
58334: POP
58335: POP
// end ;
58336: GO 57553
58338: POP
58339: POP
// end ;
58340: LD_VAR 0 1
58344: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58345: LD_INT 0
58347: PPUSH
58348: PPUSH
58349: PPUSH
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
58354: PPUSH
// if not mc_bases then
58355: LD_EXP 101
58359: NOT
58360: IFFALSE 58364
// exit ;
58362: GO 58990
// for i = 1 to mc_bases do
58364: LD_ADDR_VAR 0 2
58368: PUSH
58369: DOUBLE
58370: LD_INT 1
58372: DEC
58373: ST_TO_ADDR
58374: LD_EXP 101
58378: PUSH
58379: FOR_TO
58380: IFFALSE 58988
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58382: LD_EXP 130
58386: PUSH
58387: LD_VAR 0 2
58391: ARRAY
58392: NOT
58393: PUSH
58394: LD_EXP 130
58398: PUSH
58399: LD_VAR 0 2
58403: ARRAY
58404: PPUSH
58405: LD_INT 25
58407: PUSH
58408: LD_INT 12
58410: PUSH
58411: EMPTY
58412: LIST
58413: LIST
58414: PPUSH
58415: CALL_OW 72
58419: NOT
58420: OR
58421: IFFALSE 58425
// continue ;
58423: GO 58379
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58425: LD_ADDR_VAR 0 5
58429: PUSH
58430: LD_EXP 130
58434: PUSH
58435: LD_VAR 0 2
58439: ARRAY
58440: PUSH
58441: LD_INT 1
58443: ARRAY
58444: PPUSH
58445: CALL_OW 255
58449: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58450: LD_VAR 0 5
58454: PPUSH
58455: LD_INT 2
58457: PPUSH
58458: CALL_OW 325
58462: IFFALSE 58715
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58464: LD_ADDR_VAR 0 4
58468: PUSH
58469: LD_EXP 130
58473: PUSH
58474: LD_VAR 0 2
58478: ARRAY
58479: PPUSH
58480: LD_INT 25
58482: PUSH
58483: LD_INT 16
58485: PUSH
58486: EMPTY
58487: LIST
58488: LIST
58489: PPUSH
58490: CALL_OW 72
58494: ST_TO_ADDR
// if tmp < 6 then
58495: LD_VAR 0 4
58499: PUSH
58500: LD_INT 6
58502: LESS
58503: IFFALSE 58715
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58505: LD_ADDR_VAR 0 6
58509: PUSH
58510: LD_EXP 101
58514: PUSH
58515: LD_VAR 0 2
58519: ARRAY
58520: PPUSH
58521: LD_INT 2
58523: PUSH
58524: LD_INT 30
58526: PUSH
58527: LD_INT 0
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: PUSH
58534: LD_INT 30
58536: PUSH
58537: LD_INT 1
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: LIST
58548: PPUSH
58549: CALL_OW 72
58553: ST_TO_ADDR
// if depot then
58554: LD_VAR 0 6
58558: IFFALSE 58715
// begin selected := 0 ;
58560: LD_ADDR_VAR 0 7
58564: PUSH
58565: LD_INT 0
58567: ST_TO_ADDR
// for j in depot do
58568: LD_ADDR_VAR 0 3
58572: PUSH
58573: LD_VAR 0 6
58577: PUSH
58578: FOR_IN
58579: IFFALSE 58610
// begin if UnitsInside ( j ) < 6 then
58581: LD_VAR 0 3
58585: PPUSH
58586: CALL_OW 313
58590: PUSH
58591: LD_INT 6
58593: LESS
58594: IFFALSE 58608
// begin selected := j ;
58596: LD_ADDR_VAR 0 7
58600: PUSH
58601: LD_VAR 0 3
58605: ST_TO_ADDR
// break ;
58606: GO 58610
// end ; end ;
58608: GO 58578
58610: POP
58611: POP
// if selected then
58612: LD_VAR 0 7
58616: IFFALSE 58715
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58618: LD_ADDR_VAR 0 3
58622: PUSH
58623: LD_EXP 130
58627: PUSH
58628: LD_VAR 0 2
58632: ARRAY
58633: PPUSH
58634: LD_INT 25
58636: PUSH
58637: LD_INT 12
58639: PUSH
58640: EMPTY
58641: LIST
58642: LIST
58643: PPUSH
58644: CALL_OW 72
58648: PUSH
58649: FOR_IN
58650: IFFALSE 58713
// if not HasTask ( j ) then
58652: LD_VAR 0 3
58656: PPUSH
58657: CALL_OW 314
58661: NOT
58662: IFFALSE 58711
// begin if not IsInUnit ( j ) then
58664: LD_VAR 0 3
58668: PPUSH
58669: CALL_OW 310
58673: NOT
58674: IFFALSE 58690
// ComEnterUnit ( j , selected ) ;
58676: LD_VAR 0 3
58680: PPUSH
58681: LD_VAR 0 7
58685: PPUSH
58686: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58690: LD_VAR 0 3
58694: PPUSH
58695: LD_INT 16
58697: PPUSH
58698: CALL_OW 183
// AddComExitBuilding ( j ) ;
58702: LD_VAR 0 3
58706: PPUSH
58707: CALL_OW 182
// end ;
58711: GO 58649
58713: POP
58714: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58715: LD_VAR 0 5
58719: PPUSH
58720: LD_INT 11
58722: PPUSH
58723: CALL_OW 325
58727: IFFALSE 58986
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58729: LD_ADDR_VAR 0 4
58733: PUSH
58734: LD_EXP 130
58738: PUSH
58739: LD_VAR 0 2
58743: ARRAY
58744: PPUSH
58745: LD_INT 25
58747: PUSH
58748: LD_INT 16
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PPUSH
58755: CALL_OW 72
58759: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58760: LD_VAR 0 4
58764: PUSH
58765: LD_INT 6
58767: GREATEREQUAL
58768: PUSH
58769: LD_VAR 0 5
58773: PPUSH
58774: LD_INT 2
58776: PPUSH
58777: CALL_OW 325
58781: NOT
58782: OR
58783: IFFALSE 58986
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58785: LD_ADDR_VAR 0 8
58789: PUSH
58790: LD_EXP 101
58794: PUSH
58795: LD_VAR 0 2
58799: ARRAY
58800: PPUSH
58801: LD_INT 2
58803: PUSH
58804: LD_INT 30
58806: PUSH
58807: LD_INT 4
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: PUSH
58814: LD_INT 30
58816: PUSH
58817: LD_INT 5
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: PUSH
58824: EMPTY
58825: LIST
58826: LIST
58827: LIST
58828: PPUSH
58829: CALL_OW 72
58833: ST_TO_ADDR
// if barracks then
58834: LD_VAR 0 8
58838: IFFALSE 58986
// begin selected := 0 ;
58840: LD_ADDR_VAR 0 7
58844: PUSH
58845: LD_INT 0
58847: ST_TO_ADDR
// for j in barracks do
58848: LD_ADDR_VAR 0 3
58852: PUSH
58853: LD_VAR 0 8
58857: PUSH
58858: FOR_IN
58859: IFFALSE 58890
// begin if UnitsInside ( j ) < 6 then
58861: LD_VAR 0 3
58865: PPUSH
58866: CALL_OW 313
58870: PUSH
58871: LD_INT 6
58873: LESS
58874: IFFALSE 58888
// begin selected := j ;
58876: LD_ADDR_VAR 0 7
58880: PUSH
58881: LD_VAR 0 3
58885: ST_TO_ADDR
// break ;
58886: GO 58890
// end ; end ;
58888: GO 58858
58890: POP
58891: POP
// if selected then
58892: LD_VAR 0 7
58896: IFFALSE 58986
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58898: LD_ADDR_VAR 0 3
58902: PUSH
58903: LD_EXP 130
58907: PUSH
58908: LD_VAR 0 2
58912: ARRAY
58913: PPUSH
58914: LD_INT 25
58916: PUSH
58917: LD_INT 12
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: PPUSH
58924: CALL_OW 72
58928: PUSH
58929: FOR_IN
58930: IFFALSE 58984
// if not IsInUnit ( j ) and not HasTask ( j ) then
58932: LD_VAR 0 3
58936: PPUSH
58937: CALL_OW 310
58941: NOT
58942: PUSH
58943: LD_VAR 0 3
58947: PPUSH
58948: CALL_OW 314
58952: NOT
58953: AND
58954: IFFALSE 58982
// begin ComEnterUnit ( j , selected ) ;
58956: LD_VAR 0 3
58960: PPUSH
58961: LD_VAR 0 7
58965: PPUSH
58966: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58970: LD_VAR 0 3
58974: PPUSH
58975: LD_INT 15
58977: PPUSH
58978: CALL_OW 183
// end ;
58982: GO 58929
58984: POP
58985: POP
// end ; end ; end ; end ; end ;
58986: GO 58379
58988: POP
58989: POP
// end ;
58990: LD_VAR 0 1
58994: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58995: LD_INT 0
58997: PPUSH
58998: PPUSH
58999: PPUSH
59000: PPUSH
// if not mc_bases then
59001: LD_EXP 101
59005: NOT
59006: IFFALSE 59010
// exit ;
59008: GO 59188
// for i = 1 to mc_bases do
59010: LD_ADDR_VAR 0 2
59014: PUSH
59015: DOUBLE
59016: LD_INT 1
59018: DEC
59019: ST_TO_ADDR
59020: LD_EXP 101
59024: PUSH
59025: FOR_TO
59026: IFFALSE 59186
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59028: LD_ADDR_VAR 0 4
59032: PUSH
59033: LD_EXP 101
59037: PUSH
59038: LD_VAR 0 2
59042: ARRAY
59043: PPUSH
59044: LD_INT 25
59046: PUSH
59047: LD_INT 9
59049: PUSH
59050: EMPTY
59051: LIST
59052: LIST
59053: PPUSH
59054: CALL_OW 72
59058: ST_TO_ADDR
// if not tmp then
59059: LD_VAR 0 4
59063: NOT
59064: IFFALSE 59068
// continue ;
59066: GO 59025
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59068: LD_EXP 127
59072: PUSH
59073: LD_VAR 0 2
59077: ARRAY
59078: PPUSH
59079: LD_INT 29
59081: PPUSH
59082: CALL_OW 325
59086: NOT
59087: PUSH
59088: LD_EXP 127
59092: PUSH
59093: LD_VAR 0 2
59097: ARRAY
59098: PPUSH
59099: LD_INT 28
59101: PPUSH
59102: CALL_OW 325
59106: NOT
59107: AND
59108: IFFALSE 59112
// continue ;
59110: GO 59025
// for j in tmp do
59112: LD_ADDR_VAR 0 3
59116: PUSH
59117: LD_VAR 0 4
59121: PUSH
59122: FOR_IN
59123: IFFALSE 59182
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59125: LD_VAR 0 3
59129: PUSH
59130: LD_EXP 104
59134: PUSH
59135: LD_VAR 0 2
59139: ARRAY
59140: PUSH
59141: LD_INT 1
59143: ARRAY
59144: IN
59145: NOT
59146: PUSH
59147: LD_VAR 0 3
59151: PUSH
59152: LD_EXP 104
59156: PUSH
59157: LD_VAR 0 2
59161: ARRAY
59162: PUSH
59163: LD_INT 2
59165: ARRAY
59166: IN
59167: NOT
59168: AND
59169: IFFALSE 59180
// ComSpaceTimeShoot ( j ) ;
59171: LD_VAR 0 3
59175: PPUSH
59176: CALL 70389 0 1
59180: GO 59122
59182: POP
59183: POP
// end ;
59184: GO 59025
59186: POP
59187: POP
// end ;
59188: LD_VAR 0 1
59192: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59193: LD_INT 0
59195: PPUSH
59196: PPUSH
59197: PPUSH
59198: PPUSH
59199: PPUSH
59200: PPUSH
59201: PPUSH
59202: PPUSH
59203: PPUSH
// if not mc_bases then
59204: LD_EXP 101
59208: NOT
59209: IFFALSE 59213
// exit ;
59211: GO 59835
// for i = 1 to mc_bases do
59213: LD_ADDR_VAR 0 2
59217: PUSH
59218: DOUBLE
59219: LD_INT 1
59221: DEC
59222: ST_TO_ADDR
59223: LD_EXP 101
59227: PUSH
59228: FOR_TO
59229: IFFALSE 59833
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59231: LD_EXP 136
59235: PUSH
59236: LD_VAR 0 2
59240: ARRAY
59241: NOT
59242: PUSH
59243: LD_INT 38
59245: PPUSH
59246: LD_EXP 127
59250: PUSH
59251: LD_VAR 0 2
59255: ARRAY
59256: PPUSH
59257: CALL_OW 321
59261: PUSH
59262: LD_INT 2
59264: NONEQUAL
59265: OR
59266: IFFALSE 59270
// continue ;
59268: GO 59228
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59270: LD_ADDR_VAR 0 8
59274: PUSH
59275: LD_EXP 101
59279: PUSH
59280: LD_VAR 0 2
59284: ARRAY
59285: PPUSH
59286: LD_INT 30
59288: PUSH
59289: LD_INT 34
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: PPUSH
59296: CALL_OW 72
59300: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59301: LD_ADDR_VAR 0 9
59305: PUSH
59306: LD_EXP 101
59310: PUSH
59311: LD_VAR 0 2
59315: ARRAY
59316: PPUSH
59317: LD_INT 25
59319: PUSH
59320: LD_INT 4
59322: PUSH
59323: EMPTY
59324: LIST
59325: LIST
59326: PPUSH
59327: CALL_OW 72
59331: PPUSH
59332: LD_INT 0
59334: PPUSH
59335: CALL 104713 0 2
59339: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59340: LD_VAR 0 9
59344: NOT
59345: PUSH
59346: LD_VAR 0 8
59350: NOT
59351: OR
59352: PUSH
59353: LD_EXP 101
59357: PUSH
59358: LD_VAR 0 2
59362: ARRAY
59363: PPUSH
59364: LD_INT 124
59366: PPUSH
59367: CALL 104713 0 2
59371: OR
59372: IFFALSE 59376
// continue ;
59374: GO 59228
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59376: LD_EXP 137
59380: PUSH
59381: LD_VAR 0 2
59385: ARRAY
59386: PUSH
59387: LD_EXP 136
59391: PUSH
59392: LD_VAR 0 2
59396: ARRAY
59397: LESS
59398: PUSH
59399: LD_EXP 137
59403: PUSH
59404: LD_VAR 0 2
59408: ARRAY
59409: PUSH
59410: LD_VAR 0 8
59414: LESS
59415: AND
59416: IFFALSE 59831
// begin tmp := sci [ 1 ] ;
59418: LD_ADDR_VAR 0 7
59422: PUSH
59423: LD_VAR 0 9
59427: PUSH
59428: LD_INT 1
59430: ARRAY
59431: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59432: LD_VAR 0 7
59436: PPUSH
59437: LD_INT 124
59439: PPUSH
59440: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59444: LD_ADDR_VAR 0 3
59448: PUSH
59449: DOUBLE
59450: LD_EXP 136
59454: PUSH
59455: LD_VAR 0 2
59459: ARRAY
59460: INC
59461: ST_TO_ADDR
59462: LD_EXP 136
59466: PUSH
59467: LD_VAR 0 2
59471: ARRAY
59472: PUSH
59473: FOR_DOWNTO
59474: IFFALSE 59817
// begin if IsInUnit ( tmp ) then
59476: LD_VAR 0 7
59480: PPUSH
59481: CALL_OW 310
59485: IFFALSE 59496
// ComExitBuilding ( tmp ) ;
59487: LD_VAR 0 7
59491: PPUSH
59492: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59496: LD_INT 35
59498: PPUSH
59499: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59503: LD_VAR 0 7
59507: PPUSH
59508: CALL_OW 310
59512: NOT
59513: PUSH
59514: LD_VAR 0 7
59518: PPUSH
59519: CALL_OW 314
59523: NOT
59524: AND
59525: IFFALSE 59496
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59527: LD_ADDR_VAR 0 6
59531: PUSH
59532: LD_VAR 0 7
59536: PPUSH
59537: CALL_OW 250
59541: PUSH
59542: LD_VAR 0 7
59546: PPUSH
59547: CALL_OW 251
59551: PUSH
59552: EMPTY
59553: LIST
59554: LIST
59555: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59556: LD_INT 35
59558: PPUSH
59559: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59563: LD_ADDR_VAR 0 4
59567: PUSH
59568: LD_EXP 136
59572: PUSH
59573: LD_VAR 0 2
59577: ARRAY
59578: PUSH
59579: LD_VAR 0 3
59583: ARRAY
59584: PUSH
59585: LD_INT 1
59587: ARRAY
59588: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59589: LD_ADDR_VAR 0 5
59593: PUSH
59594: LD_EXP 136
59598: PUSH
59599: LD_VAR 0 2
59603: ARRAY
59604: PUSH
59605: LD_VAR 0 3
59609: ARRAY
59610: PUSH
59611: LD_INT 2
59613: ARRAY
59614: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59615: LD_VAR 0 7
59619: PPUSH
59620: LD_INT 10
59622: PPUSH
59623: CALL 77369 0 2
59627: PUSH
59628: LD_INT 4
59630: ARRAY
59631: IFFALSE 59669
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59633: LD_VAR 0 7
59637: PPUSH
59638: LD_VAR 0 6
59642: PUSH
59643: LD_INT 1
59645: ARRAY
59646: PPUSH
59647: LD_VAR 0 6
59651: PUSH
59652: LD_INT 2
59654: ARRAY
59655: PPUSH
59656: CALL_OW 111
// wait ( 0 0$10 ) ;
59660: LD_INT 350
59662: PPUSH
59663: CALL_OW 67
// end else
59667: GO 59695
// begin ComMoveXY ( tmp , x , y ) ;
59669: LD_VAR 0 7
59673: PPUSH
59674: LD_VAR 0 4
59678: PPUSH
59679: LD_VAR 0 5
59683: PPUSH
59684: CALL_OW 111
// wait ( 0 0$3 ) ;
59688: LD_INT 105
59690: PPUSH
59691: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59695: LD_VAR 0 7
59699: PPUSH
59700: LD_VAR 0 4
59704: PPUSH
59705: LD_VAR 0 5
59709: PPUSH
59710: CALL_OW 307
59714: IFFALSE 59556
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59716: LD_VAR 0 7
59720: PPUSH
59721: LD_VAR 0 4
59725: PPUSH
59726: LD_VAR 0 5
59730: PPUSH
59731: LD_VAR 0 8
59735: PUSH
59736: LD_VAR 0 3
59740: ARRAY
59741: PPUSH
59742: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59746: LD_INT 35
59748: PPUSH
59749: CALL_OW 67
// until not HasTask ( tmp ) ;
59753: LD_VAR 0 7
59757: PPUSH
59758: CALL_OW 314
59762: NOT
59763: IFFALSE 59746
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59765: LD_ADDR_EXP 137
59769: PUSH
59770: LD_EXP 137
59774: PPUSH
59775: LD_VAR 0 2
59779: PUSH
59780: LD_EXP 137
59784: PUSH
59785: LD_VAR 0 2
59789: ARRAY
59790: PUSH
59791: LD_INT 1
59793: PLUS
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PPUSH
59799: LD_VAR 0 8
59803: PUSH
59804: LD_VAR 0 3
59808: ARRAY
59809: PPUSH
59810: CALL 74404 0 3
59814: ST_TO_ADDR
// end ;
59815: GO 59473
59817: POP
59818: POP
// MC_Reset ( i , 124 ) ;
59819: LD_VAR 0 2
59823: PPUSH
59824: LD_INT 124
59826: PPUSH
59827: CALL 42903 0 2
// end ; end ;
59831: GO 59228
59833: POP
59834: POP
// end ;
59835: LD_VAR 0 1
59839: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59840: LD_INT 0
59842: PPUSH
59843: PPUSH
59844: PPUSH
// if not mc_bases then
59845: LD_EXP 101
59849: NOT
59850: IFFALSE 59854
// exit ;
59852: GO 60460
// for i = 1 to mc_bases do
59854: LD_ADDR_VAR 0 2
59858: PUSH
59859: DOUBLE
59860: LD_INT 1
59862: DEC
59863: ST_TO_ADDR
59864: LD_EXP 101
59868: PUSH
59869: FOR_TO
59870: IFFALSE 60458
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59872: LD_ADDR_VAR 0 3
59876: PUSH
59877: LD_EXP 101
59881: PUSH
59882: LD_VAR 0 2
59886: ARRAY
59887: PPUSH
59888: LD_INT 25
59890: PUSH
59891: LD_INT 4
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 72
59902: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59903: LD_VAR 0 3
59907: NOT
59908: PUSH
59909: LD_EXP 138
59913: PUSH
59914: LD_VAR 0 2
59918: ARRAY
59919: NOT
59920: OR
59921: PUSH
59922: LD_EXP 101
59926: PUSH
59927: LD_VAR 0 2
59931: ARRAY
59932: PPUSH
59933: LD_INT 2
59935: PUSH
59936: LD_INT 30
59938: PUSH
59939: LD_INT 0
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: PUSH
59946: LD_INT 30
59948: PUSH
59949: LD_INT 1
59951: PUSH
59952: EMPTY
59953: LIST
59954: LIST
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: LIST
59960: PPUSH
59961: CALL_OW 72
59965: NOT
59966: OR
59967: IFFALSE 60017
// begin if mc_deposits_finder [ i ] then
59969: LD_EXP 139
59973: PUSH
59974: LD_VAR 0 2
59978: ARRAY
59979: IFFALSE 60015
// begin MC_Reset ( i , 125 ) ;
59981: LD_VAR 0 2
59985: PPUSH
59986: LD_INT 125
59988: PPUSH
59989: CALL 42903 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59993: LD_ADDR_EXP 139
59997: PUSH
59998: LD_EXP 139
60002: PPUSH
60003: LD_VAR 0 2
60007: PPUSH
60008: EMPTY
60009: PPUSH
60010: CALL_OW 1
60014: ST_TO_ADDR
// end ; continue ;
60015: GO 59869
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60017: LD_EXP 138
60021: PUSH
60022: LD_VAR 0 2
60026: ARRAY
60027: PUSH
60028: LD_INT 1
60030: ARRAY
60031: PUSH
60032: LD_INT 3
60034: ARRAY
60035: PUSH
60036: LD_INT 1
60038: EQUAL
60039: PUSH
60040: LD_INT 20
60042: PPUSH
60043: LD_EXP 127
60047: PUSH
60048: LD_VAR 0 2
60052: ARRAY
60053: PPUSH
60054: CALL_OW 321
60058: PUSH
60059: LD_INT 2
60061: NONEQUAL
60062: AND
60063: IFFALSE 60113
// begin if mc_deposits_finder [ i ] then
60065: LD_EXP 139
60069: PUSH
60070: LD_VAR 0 2
60074: ARRAY
60075: IFFALSE 60111
// begin MC_Reset ( i , 125 ) ;
60077: LD_VAR 0 2
60081: PPUSH
60082: LD_INT 125
60084: PPUSH
60085: CALL 42903 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60089: LD_ADDR_EXP 139
60093: PUSH
60094: LD_EXP 139
60098: PPUSH
60099: LD_VAR 0 2
60103: PPUSH
60104: EMPTY
60105: PPUSH
60106: CALL_OW 1
60110: ST_TO_ADDR
// end ; continue ;
60111: GO 59869
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60113: LD_EXP 138
60117: PUSH
60118: LD_VAR 0 2
60122: ARRAY
60123: PUSH
60124: LD_INT 1
60126: ARRAY
60127: PUSH
60128: LD_INT 1
60130: ARRAY
60131: PPUSH
60132: LD_EXP 138
60136: PUSH
60137: LD_VAR 0 2
60141: ARRAY
60142: PUSH
60143: LD_INT 1
60145: ARRAY
60146: PUSH
60147: LD_INT 2
60149: ARRAY
60150: PPUSH
60151: LD_EXP 127
60155: PUSH
60156: LD_VAR 0 2
60160: ARRAY
60161: PPUSH
60162: CALL_OW 440
60166: IFFALSE 60209
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60168: LD_ADDR_EXP 138
60172: PUSH
60173: LD_EXP 138
60177: PPUSH
60178: LD_VAR 0 2
60182: PPUSH
60183: LD_EXP 138
60187: PUSH
60188: LD_VAR 0 2
60192: ARRAY
60193: PPUSH
60194: LD_INT 1
60196: PPUSH
60197: CALL_OW 3
60201: PPUSH
60202: CALL_OW 1
60206: ST_TO_ADDR
60207: GO 60456
// begin if not mc_deposits_finder [ i ] then
60209: LD_EXP 139
60213: PUSH
60214: LD_VAR 0 2
60218: ARRAY
60219: NOT
60220: IFFALSE 60272
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60222: LD_ADDR_EXP 139
60226: PUSH
60227: LD_EXP 139
60231: PPUSH
60232: LD_VAR 0 2
60236: PPUSH
60237: LD_VAR 0 3
60241: PUSH
60242: LD_INT 1
60244: ARRAY
60245: PUSH
60246: EMPTY
60247: LIST
60248: PPUSH
60249: CALL_OW 1
60253: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60254: LD_VAR 0 3
60258: PUSH
60259: LD_INT 1
60261: ARRAY
60262: PPUSH
60263: LD_INT 125
60265: PPUSH
60266: CALL_OW 109
// end else
60270: GO 60456
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60272: LD_EXP 139
60276: PUSH
60277: LD_VAR 0 2
60281: ARRAY
60282: PUSH
60283: LD_INT 1
60285: ARRAY
60286: PPUSH
60287: CALL_OW 310
60291: IFFALSE 60314
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60293: LD_EXP 139
60297: PUSH
60298: LD_VAR 0 2
60302: ARRAY
60303: PUSH
60304: LD_INT 1
60306: ARRAY
60307: PPUSH
60308: CALL_OW 122
60312: GO 60456
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60314: LD_EXP 139
60318: PUSH
60319: LD_VAR 0 2
60323: ARRAY
60324: PUSH
60325: LD_INT 1
60327: ARRAY
60328: PPUSH
60329: CALL_OW 314
60333: NOT
60334: PUSH
60335: LD_EXP 139
60339: PUSH
60340: LD_VAR 0 2
60344: ARRAY
60345: PUSH
60346: LD_INT 1
60348: ARRAY
60349: PPUSH
60350: LD_EXP 138
60354: PUSH
60355: LD_VAR 0 2
60359: ARRAY
60360: PUSH
60361: LD_INT 1
60363: ARRAY
60364: PUSH
60365: LD_INT 1
60367: ARRAY
60368: PPUSH
60369: LD_EXP 138
60373: PUSH
60374: LD_VAR 0 2
60378: ARRAY
60379: PUSH
60380: LD_INT 1
60382: ARRAY
60383: PUSH
60384: LD_INT 2
60386: ARRAY
60387: PPUSH
60388: CALL_OW 297
60392: PUSH
60393: LD_INT 6
60395: GREATER
60396: AND
60397: IFFALSE 60456
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60399: LD_EXP 139
60403: PUSH
60404: LD_VAR 0 2
60408: ARRAY
60409: PUSH
60410: LD_INT 1
60412: ARRAY
60413: PPUSH
60414: LD_EXP 138
60418: PUSH
60419: LD_VAR 0 2
60423: ARRAY
60424: PUSH
60425: LD_INT 1
60427: ARRAY
60428: PUSH
60429: LD_INT 1
60431: ARRAY
60432: PPUSH
60433: LD_EXP 138
60437: PUSH
60438: LD_VAR 0 2
60442: ARRAY
60443: PUSH
60444: LD_INT 1
60446: ARRAY
60447: PUSH
60448: LD_INT 2
60450: ARRAY
60451: PPUSH
60452: CALL_OW 111
// end ; end ; end ;
60456: GO 59869
60458: POP
60459: POP
// end ;
60460: LD_VAR 0 1
60464: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60465: LD_INT 0
60467: PPUSH
60468: PPUSH
60469: PPUSH
60470: PPUSH
60471: PPUSH
60472: PPUSH
60473: PPUSH
60474: PPUSH
60475: PPUSH
60476: PPUSH
60477: PPUSH
// if not mc_bases then
60478: LD_EXP 101
60482: NOT
60483: IFFALSE 60487
// exit ;
60485: GO 61427
// for i = 1 to mc_bases do
60487: LD_ADDR_VAR 0 2
60491: PUSH
60492: DOUBLE
60493: LD_INT 1
60495: DEC
60496: ST_TO_ADDR
60497: LD_EXP 101
60501: PUSH
60502: FOR_TO
60503: IFFALSE 61425
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60505: LD_EXP 101
60509: PUSH
60510: LD_VAR 0 2
60514: ARRAY
60515: NOT
60516: PUSH
60517: LD_EXP 124
60521: PUSH
60522: LD_VAR 0 2
60526: ARRAY
60527: OR
60528: IFFALSE 60532
// continue ;
60530: GO 60502
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60532: LD_ADDR_VAR 0 7
60536: PUSH
60537: LD_EXP 101
60541: PUSH
60542: LD_VAR 0 2
60546: ARRAY
60547: PUSH
60548: LD_INT 1
60550: ARRAY
60551: PPUSH
60552: CALL_OW 248
60556: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60557: LD_VAR 0 7
60561: PUSH
60562: LD_INT 3
60564: EQUAL
60565: PUSH
60566: LD_EXP 120
60570: PUSH
60571: LD_VAR 0 2
60575: ARRAY
60576: PUSH
60577: LD_EXP 123
60581: PUSH
60582: LD_VAR 0 2
60586: ARRAY
60587: UNION
60588: PPUSH
60589: LD_INT 33
60591: PUSH
60592: LD_INT 2
60594: PUSH
60595: EMPTY
60596: LIST
60597: LIST
60598: PPUSH
60599: CALL_OW 72
60603: NOT
60604: OR
60605: IFFALSE 60609
// continue ;
60607: GO 60502
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60609: LD_ADDR_VAR 0 9
60613: PUSH
60614: LD_EXP 101
60618: PUSH
60619: LD_VAR 0 2
60623: ARRAY
60624: PPUSH
60625: LD_INT 30
60627: PUSH
60628: LD_INT 36
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PPUSH
60635: CALL_OW 72
60639: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60640: LD_ADDR_VAR 0 10
60644: PUSH
60645: LD_EXP 120
60649: PUSH
60650: LD_VAR 0 2
60654: ARRAY
60655: PPUSH
60656: LD_INT 34
60658: PUSH
60659: LD_INT 31
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: PPUSH
60666: CALL_OW 72
60670: ST_TO_ADDR
// if not cts and not mcts then
60671: LD_VAR 0 9
60675: NOT
60676: PUSH
60677: LD_VAR 0 10
60681: NOT
60682: AND
60683: IFFALSE 60687
// continue ;
60685: GO 60502
// x := cts ;
60687: LD_ADDR_VAR 0 11
60691: PUSH
60692: LD_VAR 0 9
60696: ST_TO_ADDR
// if not x then
60697: LD_VAR 0 11
60701: NOT
60702: IFFALSE 60714
// x := mcts ;
60704: LD_ADDR_VAR 0 11
60708: PUSH
60709: LD_VAR 0 10
60713: ST_TO_ADDR
// if not x then
60714: LD_VAR 0 11
60718: NOT
60719: IFFALSE 60723
// continue ;
60721: GO 60502
// if mc_remote_driver [ i ] then
60723: LD_EXP 141
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: IFFALSE 61120
// for j in mc_remote_driver [ i ] do
60735: LD_ADDR_VAR 0 3
60739: PUSH
60740: LD_EXP 141
60744: PUSH
60745: LD_VAR 0 2
60749: ARRAY
60750: PUSH
60751: FOR_IN
60752: IFFALSE 61118
// begin if GetClass ( j ) <> 3 then
60754: LD_VAR 0 3
60758: PPUSH
60759: CALL_OW 257
60763: PUSH
60764: LD_INT 3
60766: NONEQUAL
60767: IFFALSE 60820
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60769: LD_ADDR_EXP 141
60773: PUSH
60774: LD_EXP 141
60778: PPUSH
60779: LD_VAR 0 2
60783: PPUSH
60784: LD_EXP 141
60788: PUSH
60789: LD_VAR 0 2
60793: ARRAY
60794: PUSH
60795: LD_VAR 0 3
60799: DIFF
60800: PPUSH
60801: CALL_OW 1
60805: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60806: LD_VAR 0 3
60810: PPUSH
60811: LD_INT 0
60813: PPUSH
60814: CALL_OW 109
// continue ;
60818: GO 60751
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60820: LD_EXP 120
60824: PUSH
60825: LD_VAR 0 2
60829: ARRAY
60830: PPUSH
60831: LD_INT 34
60833: PUSH
60834: LD_INT 31
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: PUSH
60841: LD_INT 58
60843: PUSH
60844: EMPTY
60845: LIST
60846: PUSH
60847: EMPTY
60848: LIST
60849: LIST
60850: PPUSH
60851: CALL_OW 72
60855: PUSH
60856: LD_VAR 0 3
60860: PPUSH
60861: CALL 104748 0 1
60865: NOT
60866: AND
60867: IFFALSE 60938
// begin if IsInUnit ( j ) then
60869: LD_VAR 0 3
60873: PPUSH
60874: CALL_OW 310
60878: IFFALSE 60889
// ComExitBuilding ( j ) ;
60880: LD_VAR 0 3
60884: PPUSH
60885: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60889: LD_VAR 0 3
60893: PPUSH
60894: LD_EXP 120
60898: PUSH
60899: LD_VAR 0 2
60903: ARRAY
60904: PPUSH
60905: LD_INT 34
60907: PUSH
60908: LD_INT 31
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 58
60917: PUSH
60918: EMPTY
60919: LIST
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PPUSH
60925: CALL_OW 72
60929: PUSH
60930: LD_INT 1
60932: ARRAY
60933: PPUSH
60934: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60938: LD_VAR 0 3
60942: PPUSH
60943: CALL_OW 310
60947: NOT
60948: PUSH
60949: LD_VAR 0 3
60953: PPUSH
60954: CALL_OW 310
60958: PPUSH
60959: CALL_OW 266
60963: PUSH
60964: LD_INT 36
60966: NONEQUAL
60967: PUSH
60968: LD_VAR 0 3
60972: PPUSH
60973: CALL 104748 0 1
60977: NOT
60978: AND
60979: OR
60980: IFFALSE 61116
// begin if IsInUnit ( j ) then
60982: LD_VAR 0 3
60986: PPUSH
60987: CALL_OW 310
60991: IFFALSE 61002
// ComExitBuilding ( j ) ;
60993: LD_VAR 0 3
60997: PPUSH
60998: CALL_OW 122
// ct := 0 ;
61002: LD_ADDR_VAR 0 8
61006: PUSH
61007: LD_INT 0
61009: ST_TO_ADDR
// for k in x do
61010: LD_ADDR_VAR 0 4
61014: PUSH
61015: LD_VAR 0 11
61019: PUSH
61020: FOR_IN
61021: IFFALSE 61094
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61023: LD_VAR 0 4
61027: PPUSH
61028: CALL_OW 264
61032: PUSH
61033: LD_INT 31
61035: EQUAL
61036: PUSH
61037: LD_VAR 0 4
61041: PPUSH
61042: CALL_OW 311
61046: NOT
61047: AND
61048: PUSH
61049: LD_VAR 0 4
61053: PPUSH
61054: CALL_OW 266
61058: PUSH
61059: LD_INT 36
61061: EQUAL
61062: PUSH
61063: LD_VAR 0 4
61067: PPUSH
61068: CALL_OW 313
61072: PUSH
61073: LD_INT 3
61075: LESS
61076: AND
61077: OR
61078: IFFALSE 61092
// begin ct := k ;
61080: LD_ADDR_VAR 0 8
61084: PUSH
61085: LD_VAR 0 4
61089: ST_TO_ADDR
// break ;
61090: GO 61094
// end ;
61092: GO 61020
61094: POP
61095: POP
// if ct then
61096: LD_VAR 0 8
61100: IFFALSE 61116
// ComEnterUnit ( j , ct ) ;
61102: LD_VAR 0 3
61106: PPUSH
61107: LD_VAR 0 8
61111: PPUSH
61112: CALL_OW 120
// end ; end ;
61116: GO 60751
61118: POP
61119: POP
// places := 0 ;
61120: LD_ADDR_VAR 0 5
61124: PUSH
61125: LD_INT 0
61127: ST_TO_ADDR
// for j = 1 to x do
61128: LD_ADDR_VAR 0 3
61132: PUSH
61133: DOUBLE
61134: LD_INT 1
61136: DEC
61137: ST_TO_ADDR
61138: LD_VAR 0 11
61142: PUSH
61143: FOR_TO
61144: IFFALSE 61220
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61146: LD_VAR 0 11
61150: PUSH
61151: LD_VAR 0 3
61155: ARRAY
61156: PPUSH
61157: CALL_OW 264
61161: PUSH
61162: LD_INT 31
61164: EQUAL
61165: IFFALSE 61183
// places := places + 1 else
61167: LD_ADDR_VAR 0 5
61171: PUSH
61172: LD_VAR 0 5
61176: PUSH
61177: LD_INT 1
61179: PLUS
61180: ST_TO_ADDR
61181: GO 61218
// if GetBType ( x [ j ] ) = b_control_tower then
61183: LD_VAR 0 11
61187: PUSH
61188: LD_VAR 0 3
61192: ARRAY
61193: PPUSH
61194: CALL_OW 266
61198: PUSH
61199: LD_INT 36
61201: EQUAL
61202: IFFALSE 61218
// places := places + 3 ;
61204: LD_ADDR_VAR 0 5
61208: PUSH
61209: LD_VAR 0 5
61213: PUSH
61214: LD_INT 3
61216: PLUS
61217: ST_TO_ADDR
61218: GO 61143
61220: POP
61221: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61222: LD_VAR 0 5
61226: PUSH
61227: LD_INT 0
61229: EQUAL
61230: PUSH
61231: LD_VAR 0 5
61235: PUSH
61236: LD_EXP 141
61240: PUSH
61241: LD_VAR 0 2
61245: ARRAY
61246: LESSEQUAL
61247: OR
61248: IFFALSE 61252
// continue ;
61250: GO 60502
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61252: LD_ADDR_VAR 0 6
61256: PUSH
61257: LD_EXP 101
61261: PUSH
61262: LD_VAR 0 2
61266: ARRAY
61267: PPUSH
61268: LD_INT 25
61270: PUSH
61271: LD_INT 3
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PPUSH
61278: CALL_OW 72
61282: PUSH
61283: LD_EXP 141
61287: PUSH
61288: LD_VAR 0 2
61292: ARRAY
61293: DIFF
61294: PPUSH
61295: LD_INT 3
61297: PPUSH
61298: CALL 105648 0 2
61302: ST_TO_ADDR
// for j in tmp do
61303: LD_ADDR_VAR 0 3
61307: PUSH
61308: LD_VAR 0 6
61312: PUSH
61313: FOR_IN
61314: IFFALSE 61349
// if GetTag ( j ) > 0 then
61316: LD_VAR 0 3
61320: PPUSH
61321: CALL_OW 110
61325: PUSH
61326: LD_INT 0
61328: GREATER
61329: IFFALSE 61347
// tmp := tmp diff j ;
61331: LD_ADDR_VAR 0 6
61335: PUSH
61336: LD_VAR 0 6
61340: PUSH
61341: LD_VAR 0 3
61345: DIFF
61346: ST_TO_ADDR
61347: GO 61313
61349: POP
61350: POP
// if not tmp then
61351: LD_VAR 0 6
61355: NOT
61356: IFFALSE 61360
// continue ;
61358: GO 60502
// if places then
61360: LD_VAR 0 5
61364: IFFALSE 61423
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61366: LD_ADDR_EXP 141
61370: PUSH
61371: LD_EXP 141
61375: PPUSH
61376: LD_VAR 0 2
61380: PPUSH
61381: LD_EXP 141
61385: PUSH
61386: LD_VAR 0 2
61390: ARRAY
61391: PUSH
61392: LD_VAR 0 6
61396: PUSH
61397: LD_INT 1
61399: ARRAY
61400: UNION
61401: PPUSH
61402: CALL_OW 1
61406: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61407: LD_VAR 0 6
61411: PUSH
61412: LD_INT 1
61414: ARRAY
61415: PPUSH
61416: LD_INT 126
61418: PPUSH
61419: CALL_OW 109
// end ; end ;
61423: GO 60502
61425: POP
61426: POP
// end ;
61427: LD_VAR 0 1
61431: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61432: LD_INT 0
61434: PPUSH
61435: PPUSH
61436: PPUSH
61437: PPUSH
61438: PPUSH
61439: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61440: LD_VAR 0 1
61444: NOT
61445: PUSH
61446: LD_VAR 0 2
61450: NOT
61451: OR
61452: PUSH
61453: LD_VAR 0 3
61457: NOT
61458: OR
61459: PUSH
61460: LD_VAR 0 4
61464: PUSH
61465: LD_INT 1
61467: PUSH
61468: LD_INT 2
61470: PUSH
61471: LD_INT 3
61473: PUSH
61474: LD_INT 4
61476: PUSH
61477: LD_INT 5
61479: PUSH
61480: LD_INT 8
61482: PUSH
61483: LD_INT 9
61485: PUSH
61486: LD_INT 15
61488: PUSH
61489: LD_INT 16
61491: PUSH
61492: EMPTY
61493: LIST
61494: LIST
61495: LIST
61496: LIST
61497: LIST
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: IN
61503: NOT
61504: OR
61505: IFFALSE 61509
// exit ;
61507: GO 62367
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61509: LD_ADDR_VAR 0 2
61513: PUSH
61514: LD_VAR 0 2
61518: PPUSH
61519: LD_INT 21
61521: PUSH
61522: LD_INT 3
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: PUSH
61529: LD_INT 24
61531: PUSH
61532: LD_INT 250
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: PUSH
61539: EMPTY
61540: LIST
61541: LIST
61542: PPUSH
61543: CALL_OW 72
61547: ST_TO_ADDR
// case class of 1 , 15 :
61548: LD_VAR 0 4
61552: PUSH
61553: LD_INT 1
61555: DOUBLE
61556: EQUAL
61557: IFTRUE 61567
61559: LD_INT 15
61561: DOUBLE
61562: EQUAL
61563: IFTRUE 61567
61565: GO 61652
61567: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61568: LD_ADDR_VAR 0 8
61572: PUSH
61573: LD_VAR 0 2
61577: PPUSH
61578: LD_INT 2
61580: PUSH
61581: LD_INT 30
61583: PUSH
61584: LD_INT 32
61586: PUSH
61587: EMPTY
61588: LIST
61589: LIST
61590: PUSH
61591: LD_INT 30
61593: PUSH
61594: LD_INT 31
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PUSH
61601: EMPTY
61602: LIST
61603: LIST
61604: LIST
61605: PPUSH
61606: CALL_OW 72
61610: PUSH
61611: LD_VAR 0 2
61615: PPUSH
61616: LD_INT 2
61618: PUSH
61619: LD_INT 30
61621: PUSH
61622: LD_INT 4
61624: PUSH
61625: EMPTY
61626: LIST
61627: LIST
61628: PUSH
61629: LD_INT 30
61631: PUSH
61632: LD_INT 5
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: PUSH
61639: EMPTY
61640: LIST
61641: LIST
61642: LIST
61643: PPUSH
61644: CALL_OW 72
61648: ADD
61649: ST_TO_ADDR
61650: GO 61898
61652: LD_INT 2
61654: DOUBLE
61655: EQUAL
61656: IFTRUE 61666
61658: LD_INT 16
61660: DOUBLE
61661: EQUAL
61662: IFTRUE 61666
61664: GO 61712
61666: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61667: LD_ADDR_VAR 0 8
61671: PUSH
61672: LD_VAR 0 2
61676: PPUSH
61677: LD_INT 2
61679: PUSH
61680: LD_INT 30
61682: PUSH
61683: LD_INT 0
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: PUSH
61690: LD_INT 30
61692: PUSH
61693: LD_INT 1
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: LIST
61704: PPUSH
61705: CALL_OW 72
61709: ST_TO_ADDR
61710: GO 61898
61712: LD_INT 3
61714: DOUBLE
61715: EQUAL
61716: IFTRUE 61720
61718: GO 61766
61720: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61721: LD_ADDR_VAR 0 8
61725: PUSH
61726: LD_VAR 0 2
61730: PPUSH
61731: LD_INT 2
61733: PUSH
61734: LD_INT 30
61736: PUSH
61737: LD_INT 2
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PUSH
61744: LD_INT 30
61746: PUSH
61747: LD_INT 3
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: LIST
61758: PPUSH
61759: CALL_OW 72
61763: ST_TO_ADDR
61764: GO 61898
61766: LD_INT 4
61768: DOUBLE
61769: EQUAL
61770: IFTRUE 61774
61772: GO 61831
61774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61775: LD_ADDR_VAR 0 8
61779: PUSH
61780: LD_VAR 0 2
61784: PPUSH
61785: LD_INT 2
61787: PUSH
61788: LD_INT 30
61790: PUSH
61791: LD_INT 6
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: PUSH
61798: LD_INT 30
61800: PUSH
61801: LD_INT 7
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PUSH
61808: LD_INT 30
61810: PUSH
61811: LD_INT 8
61813: PUSH
61814: EMPTY
61815: LIST
61816: LIST
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: PPUSH
61824: CALL_OW 72
61828: ST_TO_ADDR
61829: GO 61898
61831: LD_INT 5
61833: DOUBLE
61834: EQUAL
61835: IFTRUE 61851
61837: LD_INT 8
61839: DOUBLE
61840: EQUAL
61841: IFTRUE 61851
61843: LD_INT 9
61845: DOUBLE
61846: EQUAL
61847: IFTRUE 61851
61849: GO 61897
61851: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61852: LD_ADDR_VAR 0 8
61856: PUSH
61857: LD_VAR 0 2
61861: PPUSH
61862: LD_INT 2
61864: PUSH
61865: LD_INT 30
61867: PUSH
61868: LD_INT 4
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: LD_INT 30
61877: PUSH
61878: LD_INT 5
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: LIST
61889: PPUSH
61890: CALL_OW 72
61894: ST_TO_ADDR
61895: GO 61898
61897: POP
// if not tmp then
61898: LD_VAR 0 8
61902: NOT
61903: IFFALSE 61907
// exit ;
61905: GO 62367
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61907: LD_VAR 0 4
61911: PUSH
61912: LD_INT 1
61914: PUSH
61915: LD_INT 15
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: IN
61922: PUSH
61923: LD_EXP 110
61927: PUSH
61928: LD_VAR 0 1
61932: ARRAY
61933: AND
61934: IFFALSE 62090
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61936: LD_ADDR_VAR 0 9
61940: PUSH
61941: LD_EXP 110
61945: PUSH
61946: LD_VAR 0 1
61950: ARRAY
61951: PUSH
61952: LD_INT 1
61954: ARRAY
61955: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61956: LD_VAR 0 9
61960: PUSH
61961: LD_EXP 111
61965: PUSH
61966: LD_VAR 0 1
61970: ARRAY
61971: IN
61972: NOT
61973: IFFALSE 62088
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61975: LD_ADDR_EXP 111
61979: PUSH
61980: LD_EXP 111
61984: PPUSH
61985: LD_VAR 0 1
61989: PUSH
61990: LD_EXP 111
61994: PUSH
61995: LD_VAR 0 1
61999: ARRAY
62000: PUSH
62001: LD_INT 1
62003: PLUS
62004: PUSH
62005: EMPTY
62006: LIST
62007: LIST
62008: PPUSH
62009: LD_VAR 0 9
62013: PPUSH
62014: CALL 74404 0 3
62018: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62019: LD_ADDR_EXP 110
62023: PUSH
62024: LD_EXP 110
62028: PPUSH
62029: LD_VAR 0 1
62033: PPUSH
62034: LD_EXP 110
62038: PUSH
62039: LD_VAR 0 1
62043: ARRAY
62044: PUSH
62045: LD_VAR 0 9
62049: DIFF
62050: PPUSH
62051: CALL_OW 1
62055: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62056: LD_VAR 0 3
62060: PPUSH
62061: LD_EXP 111
62065: PUSH
62066: LD_VAR 0 1
62070: ARRAY
62071: PUSH
62072: LD_EXP 111
62076: PUSH
62077: LD_VAR 0 1
62081: ARRAY
62082: ARRAY
62083: PPUSH
62084: CALL_OW 120
// end ; exit ;
62088: GO 62367
// end ; if tmp > 1 then
62090: LD_VAR 0 8
62094: PUSH
62095: LD_INT 1
62097: GREATER
62098: IFFALSE 62202
// for i = 2 to tmp do
62100: LD_ADDR_VAR 0 6
62104: PUSH
62105: DOUBLE
62106: LD_INT 2
62108: DEC
62109: ST_TO_ADDR
62110: LD_VAR 0 8
62114: PUSH
62115: FOR_TO
62116: IFFALSE 62200
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62118: LD_VAR 0 8
62122: PUSH
62123: LD_VAR 0 6
62127: ARRAY
62128: PPUSH
62129: CALL_OW 461
62133: PUSH
62134: LD_INT 6
62136: EQUAL
62137: IFFALSE 62198
// begin x := tmp [ i ] ;
62139: LD_ADDR_VAR 0 9
62143: PUSH
62144: LD_VAR 0 8
62148: PUSH
62149: LD_VAR 0 6
62153: ARRAY
62154: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62155: LD_ADDR_VAR 0 8
62159: PUSH
62160: LD_VAR 0 8
62164: PPUSH
62165: LD_VAR 0 6
62169: PPUSH
62170: CALL_OW 3
62174: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62175: LD_ADDR_VAR 0 8
62179: PUSH
62180: LD_VAR 0 8
62184: PPUSH
62185: LD_INT 1
62187: PPUSH
62188: LD_VAR 0 9
62192: PPUSH
62193: CALL_OW 2
62197: ST_TO_ADDR
// end ;
62198: GO 62115
62200: POP
62201: POP
// for i in tmp do
62202: LD_ADDR_VAR 0 6
62206: PUSH
62207: LD_VAR 0 8
62211: PUSH
62212: FOR_IN
62213: IFFALSE 62240
// begin if IsNotFull ( i ) then
62215: LD_VAR 0 6
62219: PPUSH
62220: CALL 71626 0 1
62224: IFFALSE 62238
// begin j := i ;
62226: LD_ADDR_VAR 0 7
62230: PUSH
62231: LD_VAR 0 6
62235: ST_TO_ADDR
// break ;
62236: GO 62240
// end ; end ;
62238: GO 62212
62240: POP
62241: POP
// if j then
62242: LD_VAR 0 7
62246: IFFALSE 62264
// ComEnterUnit ( unit , j ) else
62248: LD_VAR 0 3
62252: PPUSH
62253: LD_VAR 0 7
62257: PPUSH
62258: CALL_OW 120
62262: GO 62367
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62264: LD_ADDR_VAR 0 10
62268: PUSH
62269: LD_VAR 0 2
62273: PPUSH
62274: LD_INT 2
62276: PUSH
62277: LD_INT 30
62279: PUSH
62280: LD_INT 0
62282: PUSH
62283: EMPTY
62284: LIST
62285: LIST
62286: PUSH
62287: LD_INT 30
62289: PUSH
62290: LD_INT 1
62292: PUSH
62293: EMPTY
62294: LIST
62295: LIST
62296: PUSH
62297: EMPTY
62298: LIST
62299: LIST
62300: LIST
62301: PPUSH
62302: CALL_OW 72
62306: ST_TO_ADDR
// if depot then
62307: LD_VAR 0 10
62311: IFFALSE 62367
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62313: LD_ADDR_VAR 0 10
62317: PUSH
62318: LD_VAR 0 10
62322: PPUSH
62323: LD_VAR 0 3
62327: PPUSH
62328: CALL_OW 74
62332: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62333: LD_VAR 0 3
62337: PPUSH
62338: LD_VAR 0 10
62342: PPUSH
62343: CALL_OW 296
62347: PUSH
62348: LD_INT 10
62350: GREATER
62351: IFFALSE 62367
// ComStandNearbyBuilding ( unit , depot ) ;
62353: LD_VAR 0 3
62357: PPUSH
62358: LD_VAR 0 10
62362: PPUSH
62363: CALL 71006 0 2
// end ; end ; end ;
62367: LD_VAR 0 5
62371: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62372: LD_INT 0
62374: PPUSH
62375: PPUSH
62376: PPUSH
62377: PPUSH
// if not mc_bases then
62378: LD_EXP 101
62382: NOT
62383: IFFALSE 62387
// exit ;
62385: GO 62626
// for i = 1 to mc_bases do
62387: LD_ADDR_VAR 0 2
62391: PUSH
62392: DOUBLE
62393: LD_INT 1
62395: DEC
62396: ST_TO_ADDR
62397: LD_EXP 101
62401: PUSH
62402: FOR_TO
62403: IFFALSE 62624
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62405: LD_ADDR_VAR 0 4
62409: PUSH
62410: LD_EXP 101
62414: PUSH
62415: LD_VAR 0 2
62419: ARRAY
62420: PPUSH
62421: LD_INT 21
62423: PUSH
62424: LD_INT 1
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PPUSH
62431: CALL_OW 72
62435: PUSH
62436: LD_EXP 130
62440: PUSH
62441: LD_VAR 0 2
62445: ARRAY
62446: UNION
62447: ST_TO_ADDR
// if not tmp then
62448: LD_VAR 0 4
62452: NOT
62453: IFFALSE 62457
// continue ;
62455: GO 62402
// for j in tmp do
62457: LD_ADDR_VAR 0 3
62461: PUSH
62462: LD_VAR 0 4
62466: PUSH
62467: FOR_IN
62468: IFFALSE 62620
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62470: LD_VAR 0 3
62474: PPUSH
62475: CALL_OW 110
62479: NOT
62480: PUSH
62481: LD_VAR 0 3
62485: PPUSH
62486: CALL_OW 314
62490: NOT
62491: AND
62492: PUSH
62493: LD_VAR 0 3
62497: PPUSH
62498: CALL_OW 311
62502: NOT
62503: AND
62504: PUSH
62505: LD_VAR 0 3
62509: PPUSH
62510: CALL_OW 310
62514: NOT
62515: AND
62516: PUSH
62517: LD_VAR 0 3
62521: PUSH
62522: LD_EXP 104
62526: PUSH
62527: LD_VAR 0 2
62531: ARRAY
62532: PUSH
62533: LD_INT 1
62535: ARRAY
62536: IN
62537: NOT
62538: AND
62539: PUSH
62540: LD_VAR 0 3
62544: PUSH
62545: LD_EXP 104
62549: PUSH
62550: LD_VAR 0 2
62554: ARRAY
62555: PUSH
62556: LD_INT 2
62558: ARRAY
62559: IN
62560: NOT
62561: AND
62562: PUSH
62563: LD_VAR 0 3
62567: PUSH
62568: LD_EXP 113
62572: PUSH
62573: LD_VAR 0 2
62577: ARRAY
62578: IN
62579: NOT
62580: AND
62581: IFFALSE 62618
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62583: LD_VAR 0 2
62587: PPUSH
62588: LD_EXP 101
62592: PUSH
62593: LD_VAR 0 2
62597: ARRAY
62598: PPUSH
62599: LD_VAR 0 3
62603: PPUSH
62604: LD_VAR 0 3
62608: PPUSH
62609: CALL_OW 257
62613: PPUSH
62614: CALL 61432 0 4
// end ;
62618: GO 62467
62620: POP
62621: POP
// end ;
62622: GO 62402
62624: POP
62625: POP
// end ;
62626: LD_VAR 0 1
62630: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62631: LD_INT 0
62633: PPUSH
62634: PPUSH
62635: PPUSH
62636: PPUSH
62637: PPUSH
62638: PPUSH
// if not mc_bases [ base ] then
62639: LD_EXP 101
62643: PUSH
62644: LD_VAR 0 1
62648: ARRAY
62649: NOT
62650: IFFALSE 62654
// exit ;
62652: GO 62855
// tmp := [ ] ;
62654: LD_ADDR_VAR 0 6
62658: PUSH
62659: EMPTY
62660: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62661: LD_ADDR_VAR 0 7
62665: PUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_INT 0
62673: PPUSH
62674: CALL_OW 517
62678: ST_TO_ADDR
// if not list then
62679: LD_VAR 0 7
62683: NOT
62684: IFFALSE 62688
// exit ;
62686: GO 62855
// c := Count ( list [ 1 ] ) ;
62688: LD_ADDR_VAR 0 9
62692: PUSH
62693: LD_VAR 0 7
62697: PUSH
62698: LD_INT 1
62700: ARRAY
62701: PPUSH
62702: CALL 71544 0 1
62706: ST_TO_ADDR
// if amount > c then
62707: LD_VAR 0 2
62711: PUSH
62712: LD_VAR 0 9
62716: GREATER
62717: IFFALSE 62729
// amount := c ;
62719: LD_ADDR_VAR 0 2
62723: PUSH
62724: LD_VAR 0 9
62728: ST_TO_ADDR
// for i := 1 to amount do
62729: LD_ADDR_VAR 0 5
62733: PUSH
62734: DOUBLE
62735: LD_INT 1
62737: DEC
62738: ST_TO_ADDR
62739: LD_VAR 0 2
62743: PUSH
62744: FOR_TO
62745: IFFALSE 62803
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62747: LD_ADDR_VAR 0 6
62751: PUSH
62752: LD_VAR 0 6
62756: PPUSH
62757: LD_VAR 0 5
62761: PPUSH
62762: LD_VAR 0 7
62766: PUSH
62767: LD_INT 1
62769: ARRAY
62770: PUSH
62771: LD_VAR 0 5
62775: ARRAY
62776: PUSH
62777: LD_VAR 0 7
62781: PUSH
62782: LD_INT 2
62784: ARRAY
62785: PUSH
62786: LD_VAR 0 5
62790: ARRAY
62791: PUSH
62792: EMPTY
62793: LIST
62794: LIST
62795: PPUSH
62796: CALL_OW 1
62800: ST_TO_ADDR
62801: GO 62744
62803: POP
62804: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62805: LD_ADDR_EXP 114
62809: PUSH
62810: LD_EXP 114
62814: PPUSH
62815: LD_VAR 0 1
62819: PPUSH
62820: LD_VAR 0 6
62824: PPUSH
62825: CALL_OW 1
62829: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62830: LD_ADDR_EXP 116
62834: PUSH
62835: LD_EXP 116
62839: PPUSH
62840: LD_VAR 0 1
62844: PPUSH
62845: LD_VAR 0 3
62849: PPUSH
62850: CALL_OW 1
62854: ST_TO_ADDR
// end ;
62855: LD_VAR 0 4
62859: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62860: LD_INT 0
62862: PPUSH
// if not mc_bases [ base ] then
62863: LD_EXP 101
62867: PUSH
62868: LD_VAR 0 1
62872: ARRAY
62873: NOT
62874: IFFALSE 62878
// exit ;
62876: GO 62903
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62878: LD_ADDR_EXP 106
62882: PUSH
62883: LD_EXP 106
62887: PPUSH
62888: LD_VAR 0 1
62892: PPUSH
62893: LD_VAR 0 2
62897: PPUSH
62898: CALL_OW 1
62902: ST_TO_ADDR
// end ;
62903: LD_VAR 0 3
62907: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62908: LD_INT 0
62910: PPUSH
// if not mc_bases [ base ] then
62911: LD_EXP 101
62915: PUSH
62916: LD_VAR 0 1
62920: ARRAY
62921: NOT
62922: IFFALSE 62926
// exit ;
62924: GO 62963
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62926: LD_ADDR_EXP 106
62930: PUSH
62931: LD_EXP 106
62935: PPUSH
62936: LD_VAR 0 1
62940: PPUSH
62941: LD_EXP 106
62945: PUSH
62946: LD_VAR 0 1
62950: ARRAY
62951: PUSH
62952: LD_VAR 0 2
62956: UNION
62957: PPUSH
62958: CALL_OW 1
62962: ST_TO_ADDR
// end ;
62963: LD_VAR 0 3
62967: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62968: LD_INT 0
62970: PPUSH
// if not mc_bases [ base ] then
62971: LD_EXP 101
62975: PUSH
62976: LD_VAR 0 1
62980: ARRAY
62981: NOT
62982: IFFALSE 62986
// exit ;
62984: GO 63011
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62986: LD_ADDR_EXP 122
62990: PUSH
62991: LD_EXP 122
62995: PPUSH
62996: LD_VAR 0 1
63000: PPUSH
63001: LD_VAR 0 2
63005: PPUSH
63006: CALL_OW 1
63010: ST_TO_ADDR
// end ;
63011: LD_VAR 0 3
63015: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63016: LD_INT 0
63018: PPUSH
// if not mc_bases [ base ] then
63019: LD_EXP 101
63023: PUSH
63024: LD_VAR 0 1
63028: ARRAY
63029: NOT
63030: IFFALSE 63034
// exit ;
63032: GO 63071
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63034: LD_ADDR_EXP 122
63038: PUSH
63039: LD_EXP 122
63043: PPUSH
63044: LD_VAR 0 1
63048: PPUSH
63049: LD_EXP 122
63053: PUSH
63054: LD_VAR 0 1
63058: ARRAY
63059: PUSH
63060: LD_VAR 0 2
63064: ADD
63065: PPUSH
63066: CALL_OW 1
63070: ST_TO_ADDR
// end ;
63071: LD_VAR 0 3
63075: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63076: LD_INT 0
63078: PPUSH
// if not mc_bases [ base ] then
63079: LD_EXP 101
63083: PUSH
63084: LD_VAR 0 1
63088: ARRAY
63089: NOT
63090: IFFALSE 63094
// exit ;
63092: GO 63148
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63094: LD_ADDR_EXP 123
63098: PUSH
63099: LD_EXP 123
63103: PPUSH
63104: LD_VAR 0 1
63108: PPUSH
63109: LD_VAR 0 2
63113: PPUSH
63114: CALL_OW 1
63118: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63119: LD_ADDR_EXP 112
63123: PUSH
63124: LD_EXP 112
63128: PPUSH
63129: LD_VAR 0 1
63133: PPUSH
63134: LD_VAR 0 2
63138: PUSH
63139: LD_INT 0
63141: PLUS
63142: PPUSH
63143: CALL_OW 1
63147: ST_TO_ADDR
// end ;
63148: LD_VAR 0 3
63152: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63153: LD_INT 0
63155: PPUSH
// if not mc_bases [ base ] then
63156: LD_EXP 101
63160: PUSH
63161: LD_VAR 0 1
63165: ARRAY
63166: NOT
63167: IFFALSE 63171
// exit ;
63169: GO 63196
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63171: LD_ADDR_EXP 112
63175: PUSH
63176: LD_EXP 112
63180: PPUSH
63181: LD_VAR 0 1
63185: PPUSH
63186: LD_VAR 0 2
63190: PPUSH
63191: CALL_OW 1
63195: ST_TO_ADDR
// end ;
63196: LD_VAR 0 3
63200: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63201: LD_INT 0
63203: PPUSH
63204: PPUSH
63205: PPUSH
63206: PPUSH
// if not mc_bases [ base ] then
63207: LD_EXP 101
63211: PUSH
63212: LD_VAR 0 1
63216: ARRAY
63217: NOT
63218: IFFALSE 63222
// exit ;
63220: GO 63287
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63222: LD_ADDR_EXP 121
63226: PUSH
63227: LD_EXP 121
63231: PPUSH
63232: LD_VAR 0 1
63236: PUSH
63237: LD_EXP 121
63241: PUSH
63242: LD_VAR 0 1
63246: ARRAY
63247: PUSH
63248: LD_INT 1
63250: PLUS
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: PPUSH
63256: LD_VAR 0 1
63260: PUSH
63261: LD_VAR 0 2
63265: PUSH
63266: LD_VAR 0 3
63270: PUSH
63271: LD_VAR 0 4
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: LIST
63280: LIST
63281: PPUSH
63282: CALL 74404 0 3
63286: ST_TO_ADDR
// end ;
63287: LD_VAR 0 5
63291: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63292: LD_INT 0
63294: PPUSH
// if not mc_bases [ base ] then
63295: LD_EXP 101
63299: PUSH
63300: LD_VAR 0 1
63304: ARRAY
63305: NOT
63306: IFFALSE 63310
// exit ;
63308: GO 63335
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63310: LD_ADDR_EXP 138
63314: PUSH
63315: LD_EXP 138
63319: PPUSH
63320: LD_VAR 0 1
63324: PPUSH
63325: LD_VAR 0 2
63329: PPUSH
63330: CALL_OW 1
63334: ST_TO_ADDR
// end ;
63335: LD_VAR 0 3
63339: RET
// export function MC_GetMinesField ( base ) ; begin
63340: LD_INT 0
63342: PPUSH
// result := mc_mines [ base ] ;
63343: LD_ADDR_VAR 0 2
63347: PUSH
63348: LD_EXP 114
63352: PUSH
63353: LD_VAR 0 1
63357: ARRAY
63358: ST_TO_ADDR
// end ;
63359: LD_VAR 0 2
63363: RET
// export function MC_GetProduceList ( base ) ; begin
63364: LD_INT 0
63366: PPUSH
// result := mc_produce [ base ] ;
63367: LD_ADDR_VAR 0 2
63371: PUSH
63372: LD_EXP 122
63376: PUSH
63377: LD_VAR 0 1
63381: ARRAY
63382: ST_TO_ADDR
// end ;
63383: LD_VAR 0 2
63387: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63388: LD_INT 0
63390: PPUSH
63391: PPUSH
// if not mc_bases then
63392: LD_EXP 101
63396: NOT
63397: IFFALSE 63401
// exit ;
63399: GO 63466
// if mc_bases [ base ] then
63401: LD_EXP 101
63405: PUSH
63406: LD_VAR 0 1
63410: ARRAY
63411: IFFALSE 63466
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63413: LD_ADDR_VAR 0 3
63417: PUSH
63418: LD_EXP 101
63422: PUSH
63423: LD_VAR 0 1
63427: ARRAY
63428: PPUSH
63429: LD_INT 30
63431: PUSH
63432: LD_VAR 0 2
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PPUSH
63441: CALL_OW 72
63445: ST_TO_ADDR
// if result then
63446: LD_VAR 0 3
63450: IFFALSE 63466
// result := result [ 1 ] ;
63452: LD_ADDR_VAR 0 3
63456: PUSH
63457: LD_VAR 0 3
63461: PUSH
63462: LD_INT 1
63464: ARRAY
63465: ST_TO_ADDR
// end ; end ;
63466: LD_VAR 0 3
63470: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63471: LD_INT 0
63473: PPUSH
63474: PPUSH
// if not mc_bases then
63475: LD_EXP 101
63479: NOT
63480: IFFALSE 63484
// exit ;
63482: GO 63529
// if mc_bases [ base ] then
63484: LD_EXP 101
63488: PUSH
63489: LD_VAR 0 1
63493: ARRAY
63494: IFFALSE 63529
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63496: LD_ADDR_VAR 0 3
63500: PUSH
63501: LD_EXP 101
63505: PUSH
63506: LD_VAR 0 1
63510: ARRAY
63511: PPUSH
63512: LD_INT 30
63514: PUSH
63515: LD_VAR 0 2
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PPUSH
63524: CALL_OW 72
63528: ST_TO_ADDR
// end ;
63529: LD_VAR 0 3
63533: RET
// export function MC_SetTame ( base , area ) ; begin
63534: LD_INT 0
63536: PPUSH
// if not mc_bases or not base then
63537: LD_EXP 101
63541: NOT
63542: PUSH
63543: LD_VAR 0 1
63547: NOT
63548: OR
63549: IFFALSE 63553
// exit ;
63551: GO 63578
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63553: LD_ADDR_EXP 129
63557: PUSH
63558: LD_EXP 129
63562: PPUSH
63563: LD_VAR 0 1
63567: PPUSH
63568: LD_VAR 0 2
63572: PPUSH
63573: CALL_OW 1
63577: ST_TO_ADDR
// end ;
63578: LD_VAR 0 3
63582: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63583: LD_INT 0
63585: PPUSH
63586: PPUSH
// if not mc_bases or not base then
63587: LD_EXP 101
63591: NOT
63592: PUSH
63593: LD_VAR 0 1
63597: NOT
63598: OR
63599: IFFALSE 63603
// exit ;
63601: GO 63705
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63603: LD_ADDR_VAR 0 4
63607: PUSH
63608: LD_EXP 101
63612: PUSH
63613: LD_VAR 0 1
63617: ARRAY
63618: PPUSH
63619: LD_INT 30
63621: PUSH
63622: LD_VAR 0 2
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PPUSH
63631: CALL_OW 72
63635: ST_TO_ADDR
// if not tmp then
63636: LD_VAR 0 4
63640: NOT
63641: IFFALSE 63645
// exit ;
63643: GO 63705
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63645: LD_ADDR_EXP 133
63649: PUSH
63650: LD_EXP 133
63654: PPUSH
63655: LD_VAR 0 1
63659: PPUSH
63660: LD_EXP 133
63664: PUSH
63665: LD_VAR 0 1
63669: ARRAY
63670: PPUSH
63671: LD_EXP 133
63675: PUSH
63676: LD_VAR 0 1
63680: ARRAY
63681: PUSH
63682: LD_INT 1
63684: PLUS
63685: PPUSH
63686: LD_VAR 0 4
63690: PUSH
63691: LD_INT 1
63693: ARRAY
63694: PPUSH
63695: CALL_OW 2
63699: PPUSH
63700: CALL_OW 1
63704: ST_TO_ADDR
// end ;
63705: LD_VAR 0 3
63709: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63710: LD_INT 0
63712: PPUSH
63713: PPUSH
// if not mc_bases or not base or not kinds then
63714: LD_EXP 101
63718: NOT
63719: PUSH
63720: LD_VAR 0 1
63724: NOT
63725: OR
63726: PUSH
63727: LD_VAR 0 2
63731: NOT
63732: OR
63733: IFFALSE 63737
// exit ;
63735: GO 63798
// for i in kinds do
63737: LD_ADDR_VAR 0 4
63741: PUSH
63742: LD_VAR 0 2
63746: PUSH
63747: FOR_IN
63748: IFFALSE 63796
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63750: LD_ADDR_EXP 135
63754: PUSH
63755: LD_EXP 135
63759: PPUSH
63760: LD_VAR 0 1
63764: PUSH
63765: LD_EXP 135
63769: PUSH
63770: LD_VAR 0 1
63774: ARRAY
63775: PUSH
63776: LD_INT 1
63778: PLUS
63779: PUSH
63780: EMPTY
63781: LIST
63782: LIST
63783: PPUSH
63784: LD_VAR 0 4
63788: PPUSH
63789: CALL 74404 0 3
63793: ST_TO_ADDR
63794: GO 63747
63796: POP
63797: POP
// end ;
63798: LD_VAR 0 3
63802: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63803: LD_INT 0
63805: PPUSH
// if not mc_bases or not base or not areas then
63806: LD_EXP 101
63810: NOT
63811: PUSH
63812: LD_VAR 0 1
63816: NOT
63817: OR
63818: PUSH
63819: LD_VAR 0 2
63823: NOT
63824: OR
63825: IFFALSE 63829
// exit ;
63827: GO 63854
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63829: LD_ADDR_EXP 119
63833: PUSH
63834: LD_EXP 119
63838: PPUSH
63839: LD_VAR 0 1
63843: PPUSH
63844: LD_VAR 0 2
63848: PPUSH
63849: CALL_OW 1
63853: ST_TO_ADDR
// end ;
63854: LD_VAR 0 3
63858: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63859: LD_INT 0
63861: PPUSH
// if not mc_bases or not base or not teleports_exit then
63862: LD_EXP 101
63866: NOT
63867: PUSH
63868: LD_VAR 0 1
63872: NOT
63873: OR
63874: PUSH
63875: LD_VAR 0 2
63879: NOT
63880: OR
63881: IFFALSE 63885
// exit ;
63883: GO 63910
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63885: LD_ADDR_EXP 136
63889: PUSH
63890: LD_EXP 136
63894: PPUSH
63895: LD_VAR 0 1
63899: PPUSH
63900: LD_VAR 0 2
63904: PPUSH
63905: CALL_OW 1
63909: ST_TO_ADDR
// end ;
63910: LD_VAR 0 3
63914: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63915: LD_INT 0
63917: PPUSH
63918: PPUSH
63919: PPUSH
// if not mc_bases or not base or not ext_list then
63920: LD_EXP 101
63924: NOT
63925: PUSH
63926: LD_VAR 0 1
63930: NOT
63931: OR
63932: PUSH
63933: LD_VAR 0 5
63937: NOT
63938: OR
63939: IFFALSE 63943
// exit ;
63941: GO 64116
// tmp := GetFacExtXYD ( x , y , d ) ;
63943: LD_ADDR_VAR 0 8
63947: PUSH
63948: LD_VAR 0 2
63952: PPUSH
63953: LD_VAR 0 3
63957: PPUSH
63958: LD_VAR 0 4
63962: PPUSH
63963: CALL 104778 0 3
63967: ST_TO_ADDR
// if not tmp then
63968: LD_VAR 0 8
63972: NOT
63973: IFFALSE 63977
// exit ;
63975: GO 64116
// for i in tmp do
63977: LD_ADDR_VAR 0 7
63981: PUSH
63982: LD_VAR 0 8
63986: PUSH
63987: FOR_IN
63988: IFFALSE 64114
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63990: LD_ADDR_EXP 106
63994: PUSH
63995: LD_EXP 106
63999: PPUSH
64000: LD_VAR 0 1
64004: PPUSH
64005: LD_EXP 106
64009: PUSH
64010: LD_VAR 0 1
64014: ARRAY
64015: PPUSH
64016: LD_EXP 106
64020: PUSH
64021: LD_VAR 0 1
64025: ARRAY
64026: PUSH
64027: LD_INT 1
64029: PLUS
64030: PPUSH
64031: LD_VAR 0 5
64035: PUSH
64036: LD_INT 1
64038: ARRAY
64039: PUSH
64040: LD_VAR 0 7
64044: PUSH
64045: LD_INT 1
64047: ARRAY
64048: PUSH
64049: LD_VAR 0 7
64053: PUSH
64054: LD_INT 2
64056: ARRAY
64057: PUSH
64058: LD_VAR 0 7
64062: PUSH
64063: LD_INT 3
64065: ARRAY
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: PPUSH
64073: CALL_OW 2
64077: PPUSH
64078: CALL_OW 1
64082: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64083: LD_ADDR_VAR 0 5
64087: PUSH
64088: LD_VAR 0 5
64092: PPUSH
64093: LD_INT 1
64095: PPUSH
64096: CALL_OW 3
64100: ST_TO_ADDR
// if not ext_list then
64101: LD_VAR 0 5
64105: NOT
64106: IFFALSE 64112
// exit ;
64108: POP
64109: POP
64110: GO 64116
// end ;
64112: GO 63987
64114: POP
64115: POP
// end ;
64116: LD_VAR 0 6
64120: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64121: LD_INT 0
64123: PPUSH
// if not mc_bases or not base or not weapon_list then
64124: LD_EXP 101
64128: NOT
64129: PUSH
64130: LD_VAR 0 1
64134: NOT
64135: OR
64136: PUSH
64137: LD_VAR 0 2
64141: NOT
64142: OR
64143: IFFALSE 64147
// exit ;
64145: GO 64172
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64147: LD_ADDR_EXP 140
64151: PUSH
64152: LD_EXP 140
64156: PPUSH
64157: LD_VAR 0 1
64161: PPUSH
64162: LD_VAR 0 2
64166: PPUSH
64167: CALL_OW 1
64171: ST_TO_ADDR
// end ;
64172: LD_VAR 0 3
64176: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64177: LD_INT 0
64179: PPUSH
// if not mc_bases or not base or not tech_list then
64180: LD_EXP 101
64184: NOT
64185: PUSH
64186: LD_VAR 0 1
64190: NOT
64191: OR
64192: PUSH
64193: LD_VAR 0 2
64197: NOT
64198: OR
64199: IFFALSE 64203
// exit ;
64201: GO 64228
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64203: LD_ADDR_EXP 128
64207: PUSH
64208: LD_EXP 128
64212: PPUSH
64213: LD_VAR 0 1
64217: PPUSH
64218: LD_VAR 0 2
64222: PPUSH
64223: CALL_OW 1
64227: ST_TO_ADDR
// end ;
64228: LD_VAR 0 3
64232: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64233: LD_INT 0
64235: PPUSH
// if not mc_bases or not parking_area or not base then
64236: LD_EXP 101
64240: NOT
64241: PUSH
64242: LD_VAR 0 2
64246: NOT
64247: OR
64248: PUSH
64249: LD_VAR 0 1
64253: NOT
64254: OR
64255: IFFALSE 64259
// exit ;
64257: GO 64284
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64259: LD_ADDR_EXP 125
64263: PUSH
64264: LD_EXP 125
64268: PPUSH
64269: LD_VAR 0 1
64273: PPUSH
64274: LD_VAR 0 2
64278: PPUSH
64279: CALL_OW 1
64283: ST_TO_ADDR
// end ;
64284: LD_VAR 0 3
64288: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64289: LD_INT 0
64291: PPUSH
// if not mc_bases or not base or not scan_area then
64292: LD_EXP 101
64296: NOT
64297: PUSH
64298: LD_VAR 0 1
64302: NOT
64303: OR
64304: PUSH
64305: LD_VAR 0 2
64309: NOT
64310: OR
64311: IFFALSE 64315
// exit ;
64313: GO 64340
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64315: LD_ADDR_EXP 126
64319: PUSH
64320: LD_EXP 126
64324: PPUSH
64325: LD_VAR 0 1
64329: PPUSH
64330: LD_VAR 0 2
64334: PPUSH
64335: CALL_OW 1
64339: ST_TO_ADDR
// end ;
64340: LD_VAR 0 3
64344: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64345: LD_INT 0
64347: PPUSH
64348: PPUSH
// if not mc_bases or not base then
64349: LD_EXP 101
64353: NOT
64354: PUSH
64355: LD_VAR 0 1
64359: NOT
64360: OR
64361: IFFALSE 64365
// exit ;
64363: GO 64429
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64365: LD_ADDR_VAR 0 3
64369: PUSH
64370: LD_INT 1
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: LD_INT 3
64378: PUSH
64379: LD_INT 4
64381: PUSH
64382: LD_INT 11
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: LIST
64389: LIST
64390: LIST
64391: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64392: LD_ADDR_EXP 128
64396: PUSH
64397: LD_EXP 128
64401: PPUSH
64402: LD_VAR 0 1
64406: PPUSH
64407: LD_EXP 128
64411: PUSH
64412: LD_VAR 0 1
64416: ARRAY
64417: PUSH
64418: LD_VAR 0 3
64422: DIFF
64423: PPUSH
64424: CALL_OW 1
64428: ST_TO_ADDR
// end ;
64429: LD_VAR 0 2
64433: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64434: LD_INT 0
64436: PPUSH
// result := mc_vehicles [ base ] ;
64437: LD_ADDR_VAR 0 3
64441: PUSH
64442: LD_EXP 120
64446: PUSH
64447: LD_VAR 0 1
64451: ARRAY
64452: ST_TO_ADDR
// if onlyCombat then
64453: LD_VAR 0 2
64457: IFFALSE 64629
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64459: LD_ADDR_VAR 0 3
64463: PUSH
64464: LD_VAR 0 3
64468: PUSH
64469: LD_VAR 0 3
64473: PPUSH
64474: LD_INT 2
64476: PUSH
64477: LD_INT 34
64479: PUSH
64480: LD_INT 12
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: LD_INT 34
64489: PUSH
64490: LD_INT 51
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 34
64499: PUSH
64500: LD_INT 89
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 34
64509: PUSH
64510: LD_INT 32
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 34
64519: PUSH
64520: LD_INT 13
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 34
64529: PUSH
64530: LD_INT 52
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 34
64539: PUSH
64540: LD_INT 88
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: LD_INT 34
64549: PUSH
64550: LD_INT 14
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: PUSH
64557: LD_INT 34
64559: PUSH
64560: LD_INT 53
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 34
64569: PUSH
64570: LD_INT 98
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: PUSH
64577: LD_INT 34
64579: PUSH
64580: LD_INT 31
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PUSH
64587: LD_INT 34
64589: PUSH
64590: LD_INT 48
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 34
64599: PUSH
64600: LD_INT 8
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: PPUSH
64623: CALL_OW 72
64627: DIFF
64628: ST_TO_ADDR
// end ; end_of_file
64629: LD_VAR 0 3
64633: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64634: LD_INT 0
64636: PPUSH
64637: PPUSH
64638: PPUSH
// if not mc_bases or not skirmish then
64639: LD_EXP 101
64643: NOT
64644: PUSH
64645: LD_EXP 99
64649: NOT
64650: OR
64651: IFFALSE 64655
// exit ;
64653: GO 64820
// for i = 1 to mc_bases do
64655: LD_ADDR_VAR 0 4
64659: PUSH
64660: DOUBLE
64661: LD_INT 1
64663: DEC
64664: ST_TO_ADDR
64665: LD_EXP 101
64669: PUSH
64670: FOR_TO
64671: IFFALSE 64818
// begin if sci in mc_bases [ i ] then
64673: LD_VAR 0 2
64677: PUSH
64678: LD_EXP 101
64682: PUSH
64683: LD_VAR 0 4
64687: ARRAY
64688: IN
64689: IFFALSE 64816
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64691: LD_ADDR_EXP 130
64695: PUSH
64696: LD_EXP 130
64700: PPUSH
64701: LD_VAR 0 4
64705: PUSH
64706: LD_EXP 130
64710: PUSH
64711: LD_VAR 0 4
64715: ARRAY
64716: PUSH
64717: LD_INT 1
64719: PLUS
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PPUSH
64725: LD_VAR 0 1
64729: PPUSH
64730: CALL 74404 0 3
64734: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64735: LD_ADDR_VAR 0 5
64739: PUSH
64740: LD_EXP 101
64744: PUSH
64745: LD_VAR 0 4
64749: ARRAY
64750: PPUSH
64751: LD_INT 2
64753: PUSH
64754: LD_INT 30
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 30
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: LIST
64778: PPUSH
64779: CALL_OW 72
64783: PPUSH
64784: LD_VAR 0 1
64788: PPUSH
64789: CALL_OW 74
64793: ST_TO_ADDR
// if tmp then
64794: LD_VAR 0 5
64798: IFFALSE 64814
// ComStandNearbyBuilding ( ape , tmp ) ;
64800: LD_VAR 0 1
64804: PPUSH
64805: LD_VAR 0 5
64809: PPUSH
64810: CALL 71006 0 2
// break ;
64814: GO 64818
// end ; end ;
64816: GO 64670
64818: POP
64819: POP
// end ;
64820: LD_VAR 0 3
64824: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64825: LD_INT 0
64827: PPUSH
64828: PPUSH
64829: PPUSH
// if not mc_bases or not skirmish then
64830: LD_EXP 101
64834: NOT
64835: PUSH
64836: LD_EXP 99
64840: NOT
64841: OR
64842: IFFALSE 64846
// exit ;
64844: GO 64935
// for i = 1 to mc_bases do
64846: LD_ADDR_VAR 0 4
64850: PUSH
64851: DOUBLE
64852: LD_INT 1
64854: DEC
64855: ST_TO_ADDR
64856: LD_EXP 101
64860: PUSH
64861: FOR_TO
64862: IFFALSE 64933
// begin if building in mc_busy_turret_list [ i ] then
64864: LD_VAR 0 1
64868: PUSH
64869: LD_EXP 111
64873: PUSH
64874: LD_VAR 0 4
64878: ARRAY
64879: IN
64880: IFFALSE 64931
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64882: LD_ADDR_VAR 0 5
64886: PUSH
64887: LD_EXP 111
64891: PUSH
64892: LD_VAR 0 4
64896: ARRAY
64897: PUSH
64898: LD_VAR 0 1
64902: DIFF
64903: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64904: LD_ADDR_EXP 111
64908: PUSH
64909: LD_EXP 111
64913: PPUSH
64914: LD_VAR 0 4
64918: PPUSH
64919: LD_VAR 0 5
64923: PPUSH
64924: CALL_OW 1
64928: ST_TO_ADDR
// break ;
64929: GO 64933
// end ; end ;
64931: GO 64861
64933: POP
64934: POP
// end ;
64935: LD_VAR 0 3
64939: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64940: LD_INT 0
64942: PPUSH
64943: PPUSH
64944: PPUSH
// if not mc_bases or not skirmish then
64945: LD_EXP 101
64949: NOT
64950: PUSH
64951: LD_EXP 99
64955: NOT
64956: OR
64957: IFFALSE 64961
// exit ;
64959: GO 65160
// for i = 1 to mc_bases do
64961: LD_ADDR_VAR 0 5
64965: PUSH
64966: DOUBLE
64967: LD_INT 1
64969: DEC
64970: ST_TO_ADDR
64971: LD_EXP 101
64975: PUSH
64976: FOR_TO
64977: IFFALSE 65158
// if building in mc_bases [ i ] then
64979: LD_VAR 0 1
64983: PUSH
64984: LD_EXP 101
64988: PUSH
64989: LD_VAR 0 5
64993: ARRAY
64994: IN
64995: IFFALSE 65156
// begin tmp := mc_bases [ i ] diff building ;
64997: LD_ADDR_VAR 0 6
65001: PUSH
65002: LD_EXP 101
65006: PUSH
65007: LD_VAR 0 5
65011: ARRAY
65012: PUSH
65013: LD_VAR 0 1
65017: DIFF
65018: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65019: LD_ADDR_EXP 101
65023: PUSH
65024: LD_EXP 101
65028: PPUSH
65029: LD_VAR 0 5
65033: PPUSH
65034: LD_VAR 0 6
65038: PPUSH
65039: CALL_OW 1
65043: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65044: LD_VAR 0 1
65048: PUSH
65049: LD_EXP 109
65053: PUSH
65054: LD_VAR 0 5
65058: ARRAY
65059: IN
65060: IFFALSE 65099
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65062: LD_ADDR_EXP 109
65066: PUSH
65067: LD_EXP 109
65071: PPUSH
65072: LD_VAR 0 5
65076: PPUSH
65077: LD_EXP 109
65081: PUSH
65082: LD_VAR 0 5
65086: ARRAY
65087: PUSH
65088: LD_VAR 0 1
65092: DIFF
65093: PPUSH
65094: CALL_OW 1
65098: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65099: LD_VAR 0 1
65103: PUSH
65104: LD_EXP 110
65108: PUSH
65109: LD_VAR 0 5
65113: ARRAY
65114: IN
65115: IFFALSE 65154
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65117: LD_ADDR_EXP 110
65121: PUSH
65122: LD_EXP 110
65126: PPUSH
65127: LD_VAR 0 5
65131: PPUSH
65132: LD_EXP 110
65136: PUSH
65137: LD_VAR 0 5
65141: ARRAY
65142: PUSH
65143: LD_VAR 0 1
65147: DIFF
65148: PPUSH
65149: CALL_OW 1
65153: ST_TO_ADDR
// break ;
65154: GO 65158
// end ;
65156: GO 64976
65158: POP
65159: POP
// end ;
65160: LD_VAR 0 4
65164: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65165: LD_INT 0
65167: PPUSH
65168: PPUSH
65169: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65170: LD_EXP 101
65174: NOT
65175: PUSH
65176: LD_EXP 99
65180: NOT
65181: OR
65182: PUSH
65183: LD_VAR 0 3
65187: PUSH
65188: LD_EXP 127
65192: IN
65193: NOT
65194: OR
65195: IFFALSE 65199
// exit ;
65197: GO 65322
// for i = 1 to mc_vehicles do
65199: LD_ADDR_VAR 0 6
65203: PUSH
65204: DOUBLE
65205: LD_INT 1
65207: DEC
65208: ST_TO_ADDR
65209: LD_EXP 120
65213: PUSH
65214: FOR_TO
65215: IFFALSE 65320
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65217: LD_VAR 0 2
65221: PUSH
65222: LD_EXP 120
65226: PUSH
65227: LD_VAR 0 6
65231: ARRAY
65232: IN
65233: PUSH
65234: LD_VAR 0 1
65238: PUSH
65239: LD_EXP 120
65243: PUSH
65244: LD_VAR 0 6
65248: ARRAY
65249: IN
65250: OR
65251: IFFALSE 65318
// begin tmp := mc_vehicles [ i ] diff old ;
65253: LD_ADDR_VAR 0 7
65257: PUSH
65258: LD_EXP 120
65262: PUSH
65263: LD_VAR 0 6
65267: ARRAY
65268: PUSH
65269: LD_VAR 0 2
65273: DIFF
65274: ST_TO_ADDR
// tmp := tmp diff new ;
65275: LD_ADDR_VAR 0 7
65279: PUSH
65280: LD_VAR 0 7
65284: PUSH
65285: LD_VAR 0 1
65289: DIFF
65290: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65291: LD_ADDR_EXP 120
65295: PUSH
65296: LD_EXP 120
65300: PPUSH
65301: LD_VAR 0 6
65305: PPUSH
65306: LD_VAR 0 7
65310: PPUSH
65311: CALL_OW 1
65315: ST_TO_ADDR
// break ;
65316: GO 65320
// end ;
65318: GO 65214
65320: POP
65321: POP
// end ;
65322: LD_VAR 0 5
65326: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65327: LD_INT 0
65329: PPUSH
65330: PPUSH
65331: PPUSH
65332: PPUSH
// if not mc_bases or not skirmish then
65333: LD_EXP 101
65337: NOT
65338: PUSH
65339: LD_EXP 99
65343: NOT
65344: OR
65345: IFFALSE 65349
// exit ;
65347: GO 65769
// repeat wait ( 0 0$1 ) ;
65349: LD_INT 35
65351: PPUSH
65352: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65356: LD_EXP 145
65360: NOT
65361: IFFALSE 65349
// mc_block_vehicle_constructed_thread := true ;
65363: LD_ADDR_EXP 145
65367: PUSH
65368: LD_INT 1
65370: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65371: LD_ADDR_VAR 0 5
65375: PUSH
65376: LD_VAR 0 1
65380: PPUSH
65381: CALL_OW 255
65385: ST_TO_ADDR
// for i = 1 to mc_bases do
65386: LD_ADDR_VAR 0 4
65390: PUSH
65391: DOUBLE
65392: LD_INT 1
65394: DEC
65395: ST_TO_ADDR
65396: LD_EXP 101
65400: PUSH
65401: FOR_TO
65402: IFFALSE 65759
// begin if factory in mc_bases [ i ] then
65404: LD_VAR 0 2
65408: PUSH
65409: LD_EXP 101
65413: PUSH
65414: LD_VAR 0 4
65418: ARRAY
65419: IN
65420: IFFALSE 65757
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65422: LD_EXP 123
65426: PUSH
65427: LD_VAR 0 4
65431: ARRAY
65432: PUSH
65433: LD_EXP 112
65437: PUSH
65438: LD_VAR 0 4
65442: ARRAY
65443: LESS
65444: PUSH
65445: LD_VAR 0 1
65449: PPUSH
65450: CALL_OW 264
65454: PUSH
65455: LD_INT 31
65457: PUSH
65458: LD_INT 32
65460: PUSH
65461: LD_INT 51
65463: PUSH
65464: LD_INT 89
65466: PUSH
65467: LD_INT 12
65469: PUSH
65470: LD_INT 30
65472: PUSH
65473: LD_INT 98
65475: PUSH
65476: LD_INT 11
65478: PUSH
65479: LD_INT 53
65481: PUSH
65482: LD_INT 14
65484: PUSH
65485: LD_INT 91
65487: PUSH
65488: LD_INT 29
65490: PUSH
65491: LD_INT 99
65493: PUSH
65494: LD_INT 13
65496: PUSH
65497: LD_INT 52
65499: PUSH
65500: LD_INT 88
65502: PUSH
65503: LD_INT 48
65505: PUSH
65506: LD_INT 8
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: IN
65529: NOT
65530: AND
65531: IFFALSE 65579
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65533: LD_ADDR_EXP 123
65537: PUSH
65538: LD_EXP 123
65542: PPUSH
65543: LD_VAR 0 4
65547: PUSH
65548: LD_EXP 123
65552: PUSH
65553: LD_VAR 0 4
65557: ARRAY
65558: PUSH
65559: LD_INT 1
65561: PLUS
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PPUSH
65567: LD_VAR 0 1
65571: PPUSH
65572: CALL 74404 0 3
65576: ST_TO_ADDR
65577: GO 65623
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65579: LD_ADDR_EXP 120
65583: PUSH
65584: LD_EXP 120
65588: PPUSH
65589: LD_VAR 0 4
65593: PUSH
65594: LD_EXP 120
65598: PUSH
65599: LD_VAR 0 4
65603: ARRAY
65604: PUSH
65605: LD_INT 1
65607: PLUS
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PPUSH
65613: LD_VAR 0 1
65617: PPUSH
65618: CALL 74404 0 3
65622: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65623: LD_ADDR_EXP 145
65627: PUSH
65628: LD_INT 0
65630: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65631: LD_VAR 0 1
65635: PPUSH
65636: CALL_OW 263
65640: PUSH
65641: LD_INT 2
65643: EQUAL
65644: IFFALSE 65673
// begin repeat wait ( 0 0$3 ) ;
65646: LD_INT 105
65648: PPUSH
65649: CALL_OW 67
// Connect ( vehicle ) ;
65653: LD_VAR 0 1
65657: PPUSH
65658: CALL 77750 0 1
// until IsControledBy ( vehicle ) ;
65662: LD_VAR 0 1
65666: PPUSH
65667: CALL_OW 312
65671: IFFALSE 65646
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65673: LD_VAR 0 1
65677: PPUSH
65678: LD_EXP 125
65682: PUSH
65683: LD_VAR 0 4
65687: ARRAY
65688: PPUSH
65689: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65693: LD_VAR 0 1
65697: PPUSH
65698: CALL_OW 263
65702: PUSH
65703: LD_INT 1
65705: NONEQUAL
65706: IFFALSE 65710
// break ;
65708: GO 65759
// repeat wait ( 0 0$1 ) ;
65710: LD_INT 35
65712: PPUSH
65713: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65717: LD_VAR 0 1
65721: PPUSH
65722: LD_EXP 125
65726: PUSH
65727: LD_VAR 0 4
65731: ARRAY
65732: PPUSH
65733: CALL_OW 308
65737: IFFALSE 65710
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65739: LD_VAR 0 1
65743: PPUSH
65744: CALL_OW 311
65748: PPUSH
65749: CALL_OW 121
// exit ;
65753: POP
65754: POP
65755: GO 65769
// end ; end ;
65757: GO 65401
65759: POP
65760: POP
// mc_block_vehicle_constructed_thread := false ;
65761: LD_ADDR_EXP 145
65765: PUSH
65766: LD_INT 0
65768: ST_TO_ADDR
// end ;
65769: LD_VAR 0 3
65773: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65774: LD_INT 0
65776: PPUSH
65777: PPUSH
65778: PPUSH
65779: PPUSH
// if not mc_bases or not skirmish then
65780: LD_EXP 101
65784: NOT
65785: PUSH
65786: LD_EXP 99
65790: NOT
65791: OR
65792: IFFALSE 65796
// exit ;
65794: GO 66149
// repeat wait ( 0 0$1 ) ;
65796: LD_INT 35
65798: PPUSH
65799: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65803: LD_VAR 0 2
65807: PPUSH
65808: LD_VAR 0 3
65812: PPUSH
65813: CALL_OW 284
65817: IFFALSE 65796
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65819: LD_VAR 0 2
65823: PPUSH
65824: LD_VAR 0 3
65828: PPUSH
65829: CALL_OW 283
65833: PUSH
65834: LD_INT 4
65836: EQUAL
65837: IFFALSE 65841
// exit ;
65839: GO 66149
// for i = 1 to mc_bases do
65841: LD_ADDR_VAR 0 7
65845: PUSH
65846: DOUBLE
65847: LD_INT 1
65849: DEC
65850: ST_TO_ADDR
65851: LD_EXP 101
65855: PUSH
65856: FOR_TO
65857: IFFALSE 66147
// begin if mc_crates_area [ i ] then
65859: LD_EXP 119
65863: PUSH
65864: LD_VAR 0 7
65868: ARRAY
65869: IFFALSE 65980
// for j in mc_crates_area [ i ] do
65871: LD_ADDR_VAR 0 8
65875: PUSH
65876: LD_EXP 119
65880: PUSH
65881: LD_VAR 0 7
65885: ARRAY
65886: PUSH
65887: FOR_IN
65888: IFFALSE 65978
// if InArea ( x , y , j ) then
65890: LD_VAR 0 2
65894: PPUSH
65895: LD_VAR 0 3
65899: PPUSH
65900: LD_VAR 0 8
65904: PPUSH
65905: CALL_OW 309
65909: IFFALSE 65976
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65911: LD_ADDR_EXP 117
65915: PUSH
65916: LD_EXP 117
65920: PPUSH
65921: LD_VAR 0 7
65925: PUSH
65926: LD_EXP 117
65930: PUSH
65931: LD_VAR 0 7
65935: ARRAY
65936: PUSH
65937: LD_INT 1
65939: PLUS
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PPUSH
65945: LD_VAR 0 4
65949: PUSH
65950: LD_VAR 0 2
65954: PUSH
65955: LD_VAR 0 3
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: LIST
65964: PPUSH
65965: CALL 74404 0 3
65969: ST_TO_ADDR
// exit ;
65970: POP
65971: POP
65972: POP
65973: POP
65974: GO 66149
// end ;
65976: GO 65887
65978: POP
65979: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65980: LD_ADDR_VAR 0 9
65984: PUSH
65985: LD_EXP 101
65989: PUSH
65990: LD_VAR 0 7
65994: ARRAY
65995: PPUSH
65996: LD_INT 2
65998: PUSH
65999: LD_INT 30
66001: PUSH
66002: LD_INT 0
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 30
66011: PUSH
66012: LD_INT 1
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: LIST
66023: PPUSH
66024: CALL_OW 72
66028: ST_TO_ADDR
// if not depot then
66029: LD_VAR 0 9
66033: NOT
66034: IFFALSE 66038
// continue ;
66036: GO 65856
// for j in depot do
66038: LD_ADDR_VAR 0 8
66042: PUSH
66043: LD_VAR 0 9
66047: PUSH
66048: FOR_IN
66049: IFFALSE 66143
// if GetDistUnitXY ( j , x , y ) < 30 then
66051: LD_VAR 0 8
66055: PPUSH
66056: LD_VAR 0 2
66060: PPUSH
66061: LD_VAR 0 3
66065: PPUSH
66066: CALL_OW 297
66070: PUSH
66071: LD_INT 30
66073: LESS
66074: IFFALSE 66141
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66076: LD_ADDR_EXP 117
66080: PUSH
66081: LD_EXP 117
66085: PPUSH
66086: LD_VAR 0 7
66090: PUSH
66091: LD_EXP 117
66095: PUSH
66096: LD_VAR 0 7
66100: ARRAY
66101: PUSH
66102: LD_INT 1
66104: PLUS
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PPUSH
66110: LD_VAR 0 4
66114: PUSH
66115: LD_VAR 0 2
66119: PUSH
66120: LD_VAR 0 3
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: LIST
66129: PPUSH
66130: CALL 74404 0 3
66134: ST_TO_ADDR
// exit ;
66135: POP
66136: POP
66137: POP
66138: POP
66139: GO 66149
// end ;
66141: GO 66048
66143: POP
66144: POP
// end ;
66145: GO 65856
66147: POP
66148: POP
// end ;
66149: LD_VAR 0 6
66153: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66154: LD_INT 0
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
// if not mc_bases or not skirmish then
66160: LD_EXP 101
66164: NOT
66165: PUSH
66166: LD_EXP 99
66170: NOT
66171: OR
66172: IFFALSE 66176
// exit ;
66174: GO 66453
// side := GetSide ( lab ) ;
66176: LD_ADDR_VAR 0 4
66180: PUSH
66181: LD_VAR 0 2
66185: PPUSH
66186: CALL_OW 255
66190: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66191: LD_VAR 0 4
66195: PUSH
66196: LD_EXP 127
66200: IN
66201: NOT
66202: PUSH
66203: LD_EXP 128
66207: NOT
66208: OR
66209: PUSH
66210: LD_EXP 101
66214: NOT
66215: OR
66216: IFFALSE 66220
// exit ;
66218: GO 66453
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66220: LD_ADDR_EXP 128
66224: PUSH
66225: LD_EXP 128
66229: PPUSH
66230: LD_VAR 0 4
66234: PPUSH
66235: LD_EXP 128
66239: PUSH
66240: LD_VAR 0 4
66244: ARRAY
66245: PUSH
66246: LD_VAR 0 1
66250: DIFF
66251: PPUSH
66252: CALL_OW 1
66256: ST_TO_ADDR
// for i = 1 to mc_bases do
66257: LD_ADDR_VAR 0 5
66261: PUSH
66262: DOUBLE
66263: LD_INT 1
66265: DEC
66266: ST_TO_ADDR
66267: LD_EXP 101
66271: PUSH
66272: FOR_TO
66273: IFFALSE 66451
// begin if lab in mc_bases [ i ] then
66275: LD_VAR 0 2
66279: PUSH
66280: LD_EXP 101
66284: PUSH
66285: LD_VAR 0 5
66289: ARRAY
66290: IN
66291: IFFALSE 66449
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66293: LD_VAR 0 1
66297: PUSH
66298: LD_INT 11
66300: PUSH
66301: LD_INT 4
66303: PUSH
66304: LD_INT 3
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: IN
66316: PUSH
66317: LD_EXP 131
66321: PUSH
66322: LD_VAR 0 5
66326: ARRAY
66327: AND
66328: IFFALSE 66449
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66330: LD_ADDR_VAR 0 6
66334: PUSH
66335: LD_EXP 131
66339: PUSH
66340: LD_VAR 0 5
66344: ARRAY
66345: PUSH
66346: LD_INT 1
66348: ARRAY
66349: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66350: LD_ADDR_EXP 131
66354: PUSH
66355: LD_EXP 131
66359: PPUSH
66360: LD_VAR 0 5
66364: PPUSH
66365: EMPTY
66366: PPUSH
66367: CALL_OW 1
66371: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66372: LD_VAR 0 6
66376: PPUSH
66377: LD_INT 0
66379: PPUSH
66380: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66384: LD_VAR 0 6
66388: PPUSH
66389: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66393: LD_ADDR_EXP 130
66397: PUSH
66398: LD_EXP 130
66402: PPUSH
66403: LD_VAR 0 5
66407: PPUSH
66408: LD_EXP 130
66412: PUSH
66413: LD_VAR 0 5
66417: ARRAY
66418: PPUSH
66419: LD_INT 1
66421: PPUSH
66422: LD_VAR 0 6
66426: PPUSH
66427: CALL_OW 2
66431: PPUSH
66432: CALL_OW 1
66436: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66437: LD_VAR 0 5
66441: PPUSH
66442: LD_INT 112
66444: PPUSH
66445: CALL 42903 0 2
// end ; end ; end ;
66449: GO 66272
66451: POP
66452: POP
// end ;
66453: LD_VAR 0 3
66457: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66458: LD_INT 0
66460: PPUSH
66461: PPUSH
66462: PPUSH
66463: PPUSH
66464: PPUSH
66465: PPUSH
66466: PPUSH
66467: PPUSH
// if not mc_bases or not skirmish then
66468: LD_EXP 101
66472: NOT
66473: PUSH
66474: LD_EXP 99
66478: NOT
66479: OR
66480: IFFALSE 66484
// exit ;
66482: GO 67853
// for i = 1 to mc_bases do
66484: LD_ADDR_VAR 0 3
66488: PUSH
66489: DOUBLE
66490: LD_INT 1
66492: DEC
66493: ST_TO_ADDR
66494: LD_EXP 101
66498: PUSH
66499: FOR_TO
66500: IFFALSE 67851
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66502: LD_VAR 0 1
66506: PUSH
66507: LD_EXP 101
66511: PUSH
66512: LD_VAR 0 3
66516: ARRAY
66517: IN
66518: PUSH
66519: LD_VAR 0 1
66523: PUSH
66524: LD_EXP 108
66528: PUSH
66529: LD_VAR 0 3
66533: ARRAY
66534: IN
66535: OR
66536: PUSH
66537: LD_VAR 0 1
66541: PUSH
66542: LD_EXP 123
66546: PUSH
66547: LD_VAR 0 3
66551: ARRAY
66552: IN
66553: OR
66554: PUSH
66555: LD_VAR 0 1
66559: PUSH
66560: LD_EXP 120
66564: PUSH
66565: LD_VAR 0 3
66569: ARRAY
66570: IN
66571: OR
66572: PUSH
66573: LD_VAR 0 1
66577: PUSH
66578: LD_EXP 130
66582: PUSH
66583: LD_VAR 0 3
66587: ARRAY
66588: IN
66589: OR
66590: PUSH
66591: LD_VAR 0 1
66595: PUSH
66596: LD_EXP 131
66600: PUSH
66601: LD_VAR 0 3
66605: ARRAY
66606: IN
66607: OR
66608: IFFALSE 67849
// begin if un in mc_ape [ i ] then
66610: LD_VAR 0 1
66614: PUSH
66615: LD_EXP 130
66619: PUSH
66620: LD_VAR 0 3
66624: ARRAY
66625: IN
66626: IFFALSE 66665
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66628: LD_ADDR_EXP 130
66632: PUSH
66633: LD_EXP 130
66637: PPUSH
66638: LD_VAR 0 3
66642: PPUSH
66643: LD_EXP 130
66647: PUSH
66648: LD_VAR 0 3
66652: ARRAY
66653: PUSH
66654: LD_VAR 0 1
66658: DIFF
66659: PPUSH
66660: CALL_OW 1
66664: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66665: LD_VAR 0 1
66669: PUSH
66670: LD_EXP 131
66674: PUSH
66675: LD_VAR 0 3
66679: ARRAY
66680: IN
66681: IFFALSE 66705
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66683: LD_ADDR_EXP 131
66687: PUSH
66688: LD_EXP 131
66692: PPUSH
66693: LD_VAR 0 3
66697: PPUSH
66698: EMPTY
66699: PPUSH
66700: CALL_OW 1
66704: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66705: LD_VAR 0 1
66709: PPUSH
66710: CALL_OW 247
66714: PUSH
66715: LD_INT 2
66717: EQUAL
66718: PUSH
66719: LD_VAR 0 1
66723: PPUSH
66724: CALL_OW 110
66728: PUSH
66729: LD_INT 20
66731: EQUAL
66732: PUSH
66733: LD_VAR 0 1
66737: PUSH
66738: LD_EXP 123
66742: PUSH
66743: LD_VAR 0 3
66747: ARRAY
66748: IN
66749: OR
66750: PUSH
66751: LD_VAR 0 1
66755: PPUSH
66756: CALL_OW 264
66760: PUSH
66761: LD_INT 12
66763: PUSH
66764: LD_INT 51
66766: PUSH
66767: LD_INT 89
66769: PUSH
66770: LD_INT 32
66772: PUSH
66773: LD_INT 13
66775: PUSH
66776: LD_INT 52
66778: PUSH
66779: LD_INT 31
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: IN
66791: OR
66792: AND
66793: IFFALSE 67101
// begin if un in mc_defender [ i ] then
66795: LD_VAR 0 1
66799: PUSH
66800: LD_EXP 123
66804: PUSH
66805: LD_VAR 0 3
66809: ARRAY
66810: IN
66811: IFFALSE 66850
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66813: LD_ADDR_EXP 123
66817: PUSH
66818: LD_EXP 123
66822: PPUSH
66823: LD_VAR 0 3
66827: PPUSH
66828: LD_EXP 123
66832: PUSH
66833: LD_VAR 0 3
66837: ARRAY
66838: PUSH
66839: LD_VAR 0 1
66843: DIFF
66844: PPUSH
66845: CALL_OW 1
66849: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66850: LD_ADDR_VAR 0 8
66854: PUSH
66855: LD_VAR 0 3
66859: PPUSH
66860: LD_INT 3
66862: PPUSH
66863: CALL 63471 0 2
66867: ST_TO_ADDR
// if fac then
66868: LD_VAR 0 8
66872: IFFALSE 67101
// begin for j in fac do
66874: LD_ADDR_VAR 0 4
66878: PUSH
66879: LD_VAR 0 8
66883: PUSH
66884: FOR_IN
66885: IFFALSE 67099
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66887: LD_ADDR_VAR 0 9
66891: PUSH
66892: LD_VAR 0 8
66896: PPUSH
66897: LD_VAR 0 1
66901: PPUSH
66902: CALL_OW 265
66906: PPUSH
66907: LD_VAR 0 1
66911: PPUSH
66912: CALL_OW 262
66916: PPUSH
66917: LD_VAR 0 1
66921: PPUSH
66922: CALL_OW 263
66926: PPUSH
66927: LD_VAR 0 1
66931: PPUSH
66932: CALL_OW 264
66936: PPUSH
66937: CALL 71902 0 5
66941: ST_TO_ADDR
// if components then
66942: LD_VAR 0 9
66946: IFFALSE 67097
// begin if GetWeapon ( un ) = ar_control_tower then
66948: LD_VAR 0 1
66952: PPUSH
66953: CALL_OW 264
66957: PUSH
66958: LD_INT 31
66960: EQUAL
66961: IFFALSE 67078
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66963: LD_VAR 0 1
66967: PPUSH
66968: CALL_OW 311
66972: PPUSH
66973: LD_INT 0
66975: PPUSH
66976: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66980: LD_ADDR_EXP 141
66984: PUSH
66985: LD_EXP 141
66989: PPUSH
66990: LD_VAR 0 3
66994: PPUSH
66995: LD_EXP 141
66999: PUSH
67000: LD_VAR 0 3
67004: ARRAY
67005: PUSH
67006: LD_VAR 0 1
67010: PPUSH
67011: CALL_OW 311
67015: DIFF
67016: PPUSH
67017: CALL_OW 1
67021: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67022: LD_ADDR_VAR 0 7
67026: PUSH
67027: LD_EXP 122
67031: PUSH
67032: LD_VAR 0 3
67036: ARRAY
67037: PPUSH
67038: LD_INT 1
67040: PPUSH
67041: LD_VAR 0 9
67045: PPUSH
67046: CALL_OW 2
67050: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67051: LD_ADDR_EXP 122
67055: PUSH
67056: LD_EXP 122
67060: PPUSH
67061: LD_VAR 0 3
67065: PPUSH
67066: LD_VAR 0 7
67070: PPUSH
67071: CALL_OW 1
67075: ST_TO_ADDR
// end else
67076: GO 67095
// MC_InsertProduceList ( i , [ components ] ) ;
67078: LD_VAR 0 3
67082: PPUSH
67083: LD_VAR 0 9
67087: PUSH
67088: EMPTY
67089: LIST
67090: PPUSH
67091: CALL 63016 0 2
// break ;
67095: GO 67099
// end ; end ;
67097: GO 66884
67099: POP
67100: POP
// end ; end ; if GetType ( un ) = unit_building then
67101: LD_VAR 0 1
67105: PPUSH
67106: CALL_OW 247
67110: PUSH
67111: LD_INT 3
67113: EQUAL
67114: IFFALSE 67517
// begin btype := GetBType ( un ) ;
67116: LD_ADDR_VAR 0 5
67120: PUSH
67121: LD_VAR 0 1
67125: PPUSH
67126: CALL_OW 266
67130: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67131: LD_VAR 0 5
67135: PUSH
67136: LD_INT 29
67138: PUSH
67139: LD_INT 30
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: IN
67146: IFFALSE 67219
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67148: LD_VAR 0 1
67152: PPUSH
67153: CALL_OW 250
67157: PPUSH
67158: LD_VAR 0 1
67162: PPUSH
67163: CALL_OW 251
67167: PPUSH
67168: LD_VAR 0 1
67172: PPUSH
67173: CALL_OW 255
67177: PPUSH
67178: CALL_OW 440
67182: NOT
67183: IFFALSE 67219
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67185: LD_VAR 0 1
67189: PPUSH
67190: CALL_OW 250
67194: PPUSH
67195: LD_VAR 0 1
67199: PPUSH
67200: CALL_OW 251
67204: PPUSH
67205: LD_VAR 0 1
67209: PPUSH
67210: CALL_OW 255
67214: PPUSH
67215: CALL_OW 441
// end ; if btype = b_warehouse then
67219: LD_VAR 0 5
67223: PUSH
67224: LD_INT 1
67226: EQUAL
67227: IFFALSE 67245
// begin btype := b_depot ;
67229: LD_ADDR_VAR 0 5
67233: PUSH
67234: LD_INT 0
67236: ST_TO_ADDR
// pos := 1 ;
67237: LD_ADDR_VAR 0 6
67241: PUSH
67242: LD_INT 1
67244: ST_TO_ADDR
// end ; if btype = b_factory then
67245: LD_VAR 0 5
67249: PUSH
67250: LD_INT 3
67252: EQUAL
67253: IFFALSE 67271
// begin btype := b_workshop ;
67255: LD_ADDR_VAR 0 5
67259: PUSH
67260: LD_INT 2
67262: ST_TO_ADDR
// pos := 1 ;
67263: LD_ADDR_VAR 0 6
67267: PUSH
67268: LD_INT 1
67270: ST_TO_ADDR
// end ; if btype = b_barracks then
67271: LD_VAR 0 5
67275: PUSH
67276: LD_INT 5
67278: EQUAL
67279: IFFALSE 67289
// btype := b_armoury ;
67281: LD_ADDR_VAR 0 5
67285: PUSH
67286: LD_INT 4
67288: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67289: LD_VAR 0 5
67293: PUSH
67294: LD_INT 7
67296: PUSH
67297: LD_INT 8
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: IN
67304: IFFALSE 67314
// btype := b_lab ;
67306: LD_ADDR_VAR 0 5
67310: PUSH
67311: LD_INT 6
67313: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67314: LD_ADDR_EXP 106
67318: PUSH
67319: LD_EXP 106
67323: PPUSH
67324: LD_VAR 0 3
67328: PUSH
67329: LD_EXP 106
67333: PUSH
67334: LD_VAR 0 3
67338: ARRAY
67339: PUSH
67340: LD_INT 1
67342: PLUS
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PPUSH
67348: LD_VAR 0 5
67352: PUSH
67353: LD_VAR 0 1
67357: PPUSH
67358: CALL_OW 250
67362: PUSH
67363: LD_VAR 0 1
67367: PPUSH
67368: CALL_OW 251
67372: PUSH
67373: LD_VAR 0 1
67377: PPUSH
67378: CALL_OW 254
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: PPUSH
67389: CALL 74404 0 3
67393: ST_TO_ADDR
// if pos = 1 then
67394: LD_VAR 0 6
67398: PUSH
67399: LD_INT 1
67401: EQUAL
67402: IFFALSE 67517
// begin tmp := mc_build_list [ i ] ;
67404: LD_ADDR_VAR 0 7
67408: PUSH
67409: LD_EXP 106
67413: PUSH
67414: LD_VAR 0 3
67418: ARRAY
67419: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67420: LD_VAR 0 7
67424: PPUSH
67425: LD_INT 2
67427: PUSH
67428: LD_INT 30
67430: PUSH
67431: LD_INT 0
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 30
67440: PUSH
67441: LD_INT 1
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: LIST
67452: PPUSH
67453: CALL_OW 72
67457: IFFALSE 67467
// pos := 2 ;
67459: LD_ADDR_VAR 0 6
67463: PUSH
67464: LD_INT 2
67466: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67467: LD_ADDR_VAR 0 7
67471: PUSH
67472: LD_VAR 0 7
67476: PPUSH
67477: LD_VAR 0 6
67481: PPUSH
67482: LD_VAR 0 7
67486: PPUSH
67487: CALL 74730 0 3
67491: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67492: LD_ADDR_EXP 106
67496: PUSH
67497: LD_EXP 106
67501: PPUSH
67502: LD_VAR 0 3
67506: PPUSH
67507: LD_VAR 0 7
67511: PPUSH
67512: CALL_OW 1
67516: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67517: LD_VAR 0 1
67521: PUSH
67522: LD_EXP 101
67526: PUSH
67527: LD_VAR 0 3
67531: ARRAY
67532: IN
67533: IFFALSE 67572
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67535: LD_ADDR_EXP 101
67539: PUSH
67540: LD_EXP 101
67544: PPUSH
67545: LD_VAR 0 3
67549: PPUSH
67550: LD_EXP 101
67554: PUSH
67555: LD_VAR 0 3
67559: ARRAY
67560: PUSH
67561: LD_VAR 0 1
67565: DIFF
67566: PPUSH
67567: CALL_OW 1
67571: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67572: LD_VAR 0 1
67576: PUSH
67577: LD_EXP 108
67581: PUSH
67582: LD_VAR 0 3
67586: ARRAY
67587: IN
67588: IFFALSE 67627
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67590: LD_ADDR_EXP 108
67594: PUSH
67595: LD_EXP 108
67599: PPUSH
67600: LD_VAR 0 3
67604: PPUSH
67605: LD_EXP 108
67609: PUSH
67610: LD_VAR 0 3
67614: ARRAY
67615: PUSH
67616: LD_VAR 0 1
67620: DIFF
67621: PPUSH
67622: CALL_OW 1
67626: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67627: LD_VAR 0 1
67631: PUSH
67632: LD_EXP 120
67636: PUSH
67637: LD_VAR 0 3
67641: ARRAY
67642: IN
67643: IFFALSE 67682
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67645: LD_ADDR_EXP 120
67649: PUSH
67650: LD_EXP 120
67654: PPUSH
67655: LD_VAR 0 3
67659: PPUSH
67660: LD_EXP 120
67664: PUSH
67665: LD_VAR 0 3
67669: ARRAY
67670: PUSH
67671: LD_VAR 0 1
67675: DIFF
67676: PPUSH
67677: CALL_OW 1
67681: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67682: LD_VAR 0 1
67686: PUSH
67687: LD_EXP 123
67691: PUSH
67692: LD_VAR 0 3
67696: ARRAY
67697: IN
67698: IFFALSE 67737
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67700: LD_ADDR_EXP 123
67704: PUSH
67705: LD_EXP 123
67709: PPUSH
67710: LD_VAR 0 3
67714: PPUSH
67715: LD_EXP 123
67719: PUSH
67720: LD_VAR 0 3
67724: ARRAY
67725: PUSH
67726: LD_VAR 0 1
67730: DIFF
67731: PPUSH
67732: CALL_OW 1
67736: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67737: LD_VAR 0 1
67741: PUSH
67742: LD_EXP 110
67746: PUSH
67747: LD_VAR 0 3
67751: ARRAY
67752: IN
67753: IFFALSE 67792
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67755: LD_ADDR_EXP 110
67759: PUSH
67760: LD_EXP 110
67764: PPUSH
67765: LD_VAR 0 3
67769: PPUSH
67770: LD_EXP 110
67774: PUSH
67775: LD_VAR 0 3
67779: ARRAY
67780: PUSH
67781: LD_VAR 0 1
67785: DIFF
67786: PPUSH
67787: CALL_OW 1
67791: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67792: LD_VAR 0 1
67796: PUSH
67797: LD_EXP 109
67801: PUSH
67802: LD_VAR 0 3
67806: ARRAY
67807: IN
67808: IFFALSE 67847
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67810: LD_ADDR_EXP 109
67814: PUSH
67815: LD_EXP 109
67819: PPUSH
67820: LD_VAR 0 3
67824: PPUSH
67825: LD_EXP 109
67829: PUSH
67830: LD_VAR 0 3
67834: ARRAY
67835: PUSH
67836: LD_VAR 0 1
67840: DIFF
67841: PPUSH
67842: CALL_OW 1
67846: ST_TO_ADDR
// end ; break ;
67847: GO 67851
// end ;
67849: GO 66499
67851: POP
67852: POP
// end ;
67853: LD_VAR 0 2
67857: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67858: LD_INT 0
67860: PPUSH
67861: PPUSH
67862: PPUSH
// if not mc_bases or not skirmish then
67863: LD_EXP 101
67867: NOT
67868: PUSH
67869: LD_EXP 99
67873: NOT
67874: OR
67875: IFFALSE 67879
// exit ;
67877: GO 68094
// for i = 1 to mc_bases do
67879: LD_ADDR_VAR 0 3
67883: PUSH
67884: DOUBLE
67885: LD_INT 1
67887: DEC
67888: ST_TO_ADDR
67889: LD_EXP 101
67893: PUSH
67894: FOR_TO
67895: IFFALSE 68092
// begin if building in mc_construct_list [ i ] then
67897: LD_VAR 0 1
67901: PUSH
67902: LD_EXP 108
67906: PUSH
67907: LD_VAR 0 3
67911: ARRAY
67912: IN
67913: IFFALSE 68090
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67915: LD_ADDR_EXP 108
67919: PUSH
67920: LD_EXP 108
67924: PPUSH
67925: LD_VAR 0 3
67929: PPUSH
67930: LD_EXP 108
67934: PUSH
67935: LD_VAR 0 3
67939: ARRAY
67940: PUSH
67941: LD_VAR 0 1
67945: DIFF
67946: PPUSH
67947: CALL_OW 1
67951: ST_TO_ADDR
// if building in mc_lab [ i ] then
67952: LD_VAR 0 1
67956: PUSH
67957: LD_EXP 134
67961: PUSH
67962: LD_VAR 0 3
67966: ARRAY
67967: IN
67968: IFFALSE 68023
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67970: LD_ADDR_EXP 135
67974: PUSH
67975: LD_EXP 135
67979: PPUSH
67980: LD_VAR 0 3
67984: PPUSH
67985: LD_EXP 135
67989: PUSH
67990: LD_VAR 0 3
67994: ARRAY
67995: PPUSH
67996: LD_INT 1
67998: PPUSH
67999: LD_EXP 135
68003: PUSH
68004: LD_VAR 0 3
68008: ARRAY
68009: PPUSH
68010: LD_INT 0
68012: PPUSH
68013: CALL 73822 0 4
68017: PPUSH
68018: CALL_OW 1
68022: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68023: LD_VAR 0 1
68027: PUSH
68028: LD_EXP 101
68032: PUSH
68033: LD_VAR 0 3
68037: ARRAY
68038: IN
68039: NOT
68040: IFFALSE 68086
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68042: LD_ADDR_EXP 101
68046: PUSH
68047: LD_EXP 101
68051: PPUSH
68052: LD_VAR 0 3
68056: PUSH
68057: LD_EXP 101
68061: PUSH
68062: LD_VAR 0 3
68066: ARRAY
68067: PUSH
68068: LD_INT 1
68070: PLUS
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PPUSH
68076: LD_VAR 0 1
68080: PPUSH
68081: CALL 74404 0 3
68085: ST_TO_ADDR
// exit ;
68086: POP
68087: POP
68088: GO 68094
// end ; end ;
68090: GO 67894
68092: POP
68093: POP
// end ;
68094: LD_VAR 0 2
68098: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68099: LD_INT 0
68101: PPUSH
68102: PPUSH
68103: PPUSH
68104: PPUSH
68105: PPUSH
68106: PPUSH
68107: PPUSH
// if not mc_bases or not skirmish then
68108: LD_EXP 101
68112: NOT
68113: PUSH
68114: LD_EXP 99
68118: NOT
68119: OR
68120: IFFALSE 68124
// exit ;
68122: GO 68785
// for i = 1 to mc_bases do
68124: LD_ADDR_VAR 0 3
68128: PUSH
68129: DOUBLE
68130: LD_INT 1
68132: DEC
68133: ST_TO_ADDR
68134: LD_EXP 101
68138: PUSH
68139: FOR_TO
68140: IFFALSE 68783
// begin if building in mc_construct_list [ i ] then
68142: LD_VAR 0 1
68146: PUSH
68147: LD_EXP 108
68151: PUSH
68152: LD_VAR 0 3
68156: ARRAY
68157: IN
68158: IFFALSE 68781
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68160: LD_ADDR_EXP 108
68164: PUSH
68165: LD_EXP 108
68169: PPUSH
68170: LD_VAR 0 3
68174: PPUSH
68175: LD_EXP 108
68179: PUSH
68180: LD_VAR 0 3
68184: ARRAY
68185: PUSH
68186: LD_VAR 0 1
68190: DIFF
68191: PPUSH
68192: CALL_OW 1
68196: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68197: LD_ADDR_EXP 101
68201: PUSH
68202: LD_EXP 101
68206: PPUSH
68207: LD_VAR 0 3
68211: PUSH
68212: LD_EXP 101
68216: PUSH
68217: LD_VAR 0 3
68221: ARRAY
68222: PUSH
68223: LD_INT 1
68225: PLUS
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PPUSH
68231: LD_VAR 0 1
68235: PPUSH
68236: CALL 74404 0 3
68240: ST_TO_ADDR
// btype := GetBType ( building ) ;
68241: LD_ADDR_VAR 0 5
68245: PUSH
68246: LD_VAR 0 1
68250: PPUSH
68251: CALL_OW 266
68255: ST_TO_ADDR
// side := GetSide ( building ) ;
68256: LD_ADDR_VAR 0 8
68260: PUSH
68261: LD_VAR 0 1
68265: PPUSH
68266: CALL_OW 255
68270: ST_TO_ADDR
// if btype = b_lab then
68271: LD_VAR 0 5
68275: PUSH
68276: LD_INT 6
68278: EQUAL
68279: IFFALSE 68329
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68281: LD_ADDR_EXP 134
68285: PUSH
68286: LD_EXP 134
68290: PPUSH
68291: LD_VAR 0 3
68295: PUSH
68296: LD_EXP 134
68300: PUSH
68301: LD_VAR 0 3
68305: ARRAY
68306: PUSH
68307: LD_INT 1
68309: PLUS
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PPUSH
68315: LD_VAR 0 1
68319: PPUSH
68320: CALL 74404 0 3
68324: ST_TO_ADDR
// exit ;
68325: POP
68326: POP
68327: GO 68785
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68329: LD_VAR 0 5
68333: PUSH
68334: LD_INT 0
68336: PUSH
68337: LD_INT 2
68339: PUSH
68340: LD_INT 4
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: LIST
68347: IN
68348: IFFALSE 68472
// begin if btype = b_armoury then
68350: LD_VAR 0 5
68354: PUSH
68355: LD_INT 4
68357: EQUAL
68358: IFFALSE 68368
// btype := b_barracks ;
68360: LD_ADDR_VAR 0 5
68364: PUSH
68365: LD_INT 5
68367: ST_TO_ADDR
// if btype = b_depot then
68368: LD_VAR 0 5
68372: PUSH
68373: LD_INT 0
68375: EQUAL
68376: IFFALSE 68386
// btype := b_warehouse ;
68378: LD_ADDR_VAR 0 5
68382: PUSH
68383: LD_INT 1
68385: ST_TO_ADDR
// if btype = b_workshop then
68386: LD_VAR 0 5
68390: PUSH
68391: LD_INT 2
68393: EQUAL
68394: IFFALSE 68404
// btype := b_factory ;
68396: LD_ADDR_VAR 0 5
68400: PUSH
68401: LD_INT 3
68403: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68404: LD_VAR 0 5
68408: PPUSH
68409: LD_VAR 0 8
68413: PPUSH
68414: CALL_OW 323
68418: PUSH
68419: LD_INT 1
68421: EQUAL
68422: IFFALSE 68468
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68424: LD_ADDR_EXP 133
68428: PUSH
68429: LD_EXP 133
68433: PPUSH
68434: LD_VAR 0 3
68438: PUSH
68439: LD_EXP 133
68443: PUSH
68444: LD_VAR 0 3
68448: ARRAY
68449: PUSH
68450: LD_INT 1
68452: PLUS
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PPUSH
68458: LD_VAR 0 1
68462: PPUSH
68463: CALL 74404 0 3
68467: ST_TO_ADDR
// exit ;
68468: POP
68469: POP
68470: GO 68785
// end ; if btype in [ b_bunker , b_turret ] then
68472: LD_VAR 0 5
68476: PUSH
68477: LD_INT 32
68479: PUSH
68480: LD_INT 33
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: IN
68487: IFFALSE 68777
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68489: LD_ADDR_EXP 109
68493: PUSH
68494: LD_EXP 109
68498: PPUSH
68499: LD_VAR 0 3
68503: PUSH
68504: LD_EXP 109
68508: PUSH
68509: LD_VAR 0 3
68513: ARRAY
68514: PUSH
68515: LD_INT 1
68517: PLUS
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PPUSH
68523: LD_VAR 0 1
68527: PPUSH
68528: CALL 74404 0 3
68532: ST_TO_ADDR
// if btype = b_bunker then
68533: LD_VAR 0 5
68537: PUSH
68538: LD_INT 32
68540: EQUAL
68541: IFFALSE 68777
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68543: LD_ADDR_EXP 110
68547: PUSH
68548: LD_EXP 110
68552: PPUSH
68553: LD_VAR 0 3
68557: PUSH
68558: LD_EXP 110
68562: PUSH
68563: LD_VAR 0 3
68567: ARRAY
68568: PUSH
68569: LD_INT 1
68571: PLUS
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PPUSH
68577: LD_VAR 0 1
68581: PPUSH
68582: CALL 74404 0 3
68586: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68587: LD_ADDR_VAR 0 6
68591: PUSH
68592: LD_EXP 101
68596: PUSH
68597: LD_VAR 0 3
68601: ARRAY
68602: PPUSH
68603: LD_INT 25
68605: PUSH
68606: LD_INT 1
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 3
68615: PUSH
68616: LD_INT 54
68618: PUSH
68619: EMPTY
68620: LIST
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PPUSH
68630: CALL_OW 72
68634: ST_TO_ADDR
// if tmp then
68635: LD_VAR 0 6
68639: IFFALSE 68645
// exit ;
68641: POP
68642: POP
68643: GO 68785
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68645: LD_ADDR_VAR 0 6
68649: PUSH
68650: LD_EXP 101
68654: PUSH
68655: LD_VAR 0 3
68659: ARRAY
68660: PPUSH
68661: LD_INT 2
68663: PUSH
68664: LD_INT 30
68666: PUSH
68667: LD_INT 4
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 30
68676: PUSH
68677: LD_INT 5
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: LIST
68688: PPUSH
68689: CALL_OW 72
68693: ST_TO_ADDR
// if not tmp then
68694: LD_VAR 0 6
68698: NOT
68699: IFFALSE 68705
// exit ;
68701: POP
68702: POP
68703: GO 68785
// for j in tmp do
68705: LD_ADDR_VAR 0 4
68709: PUSH
68710: LD_VAR 0 6
68714: PUSH
68715: FOR_IN
68716: IFFALSE 68775
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68718: LD_ADDR_VAR 0 7
68722: PUSH
68723: LD_VAR 0 4
68727: PPUSH
68728: CALL_OW 313
68732: PPUSH
68733: LD_INT 25
68735: PUSH
68736: LD_INT 1
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PPUSH
68743: CALL_OW 72
68747: ST_TO_ADDR
// if units then
68748: LD_VAR 0 7
68752: IFFALSE 68773
// begin ComExitBuilding ( units [ 1 ] ) ;
68754: LD_VAR 0 7
68758: PUSH
68759: LD_INT 1
68761: ARRAY
68762: PPUSH
68763: CALL_OW 122
// exit ;
68767: POP
68768: POP
68769: POP
68770: POP
68771: GO 68785
// end ; end ;
68773: GO 68715
68775: POP
68776: POP
// end ; end ; exit ;
68777: POP
68778: POP
68779: GO 68785
// end ; end ;
68781: GO 68139
68783: POP
68784: POP
// end ;
68785: LD_VAR 0 2
68789: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68790: LD_INT 0
68792: PPUSH
68793: PPUSH
68794: PPUSH
68795: PPUSH
68796: PPUSH
68797: PPUSH
68798: PPUSH
// if not mc_bases or not skirmish then
68799: LD_EXP 101
68803: NOT
68804: PUSH
68805: LD_EXP 99
68809: NOT
68810: OR
68811: IFFALSE 68815
// exit ;
68813: GO 69080
// btype := GetBType ( building ) ;
68815: LD_ADDR_VAR 0 6
68819: PUSH
68820: LD_VAR 0 1
68824: PPUSH
68825: CALL_OW 266
68829: ST_TO_ADDR
// x := GetX ( building ) ;
68830: LD_ADDR_VAR 0 7
68834: PUSH
68835: LD_VAR 0 1
68839: PPUSH
68840: CALL_OW 250
68844: ST_TO_ADDR
// y := GetY ( building ) ;
68845: LD_ADDR_VAR 0 8
68849: PUSH
68850: LD_VAR 0 1
68854: PPUSH
68855: CALL_OW 251
68859: ST_TO_ADDR
// d := GetDir ( building ) ;
68860: LD_ADDR_VAR 0 9
68864: PUSH
68865: LD_VAR 0 1
68869: PPUSH
68870: CALL_OW 254
68874: ST_TO_ADDR
// for i = 1 to mc_bases do
68875: LD_ADDR_VAR 0 4
68879: PUSH
68880: DOUBLE
68881: LD_INT 1
68883: DEC
68884: ST_TO_ADDR
68885: LD_EXP 101
68889: PUSH
68890: FOR_TO
68891: IFFALSE 69078
// begin if not mc_build_list [ i ] then
68893: LD_EXP 106
68897: PUSH
68898: LD_VAR 0 4
68902: ARRAY
68903: NOT
68904: IFFALSE 68908
// continue ;
68906: GO 68890
// for j := 1 to mc_build_list [ i ] do
68908: LD_ADDR_VAR 0 5
68912: PUSH
68913: DOUBLE
68914: LD_INT 1
68916: DEC
68917: ST_TO_ADDR
68918: LD_EXP 106
68922: PUSH
68923: LD_VAR 0 4
68927: ARRAY
68928: PUSH
68929: FOR_TO
68930: IFFALSE 69074
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68932: LD_VAR 0 6
68936: PUSH
68937: LD_VAR 0 7
68941: PUSH
68942: LD_VAR 0 8
68946: PUSH
68947: LD_VAR 0 9
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: PPUSH
68958: LD_EXP 106
68962: PUSH
68963: LD_VAR 0 4
68967: ARRAY
68968: PUSH
68969: LD_VAR 0 5
68973: ARRAY
68974: PPUSH
68975: CALL 80961 0 2
68979: IFFALSE 69072
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68981: LD_ADDR_EXP 106
68985: PUSH
68986: LD_EXP 106
68990: PPUSH
68991: LD_VAR 0 4
68995: PPUSH
68996: LD_EXP 106
69000: PUSH
69001: LD_VAR 0 4
69005: ARRAY
69006: PPUSH
69007: LD_VAR 0 5
69011: PPUSH
69012: CALL_OW 3
69016: PPUSH
69017: CALL_OW 1
69021: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69022: LD_ADDR_EXP 108
69026: PUSH
69027: LD_EXP 108
69031: PPUSH
69032: LD_VAR 0 4
69036: PUSH
69037: LD_EXP 108
69041: PUSH
69042: LD_VAR 0 4
69046: ARRAY
69047: PUSH
69048: LD_INT 1
69050: PLUS
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PPUSH
69056: LD_VAR 0 1
69060: PPUSH
69061: CALL 74404 0 3
69065: ST_TO_ADDR
// exit ;
69066: POP
69067: POP
69068: POP
69069: POP
69070: GO 69080
// end ;
69072: GO 68929
69074: POP
69075: POP
// end ;
69076: GO 68890
69078: POP
69079: POP
// end ;
69080: LD_VAR 0 3
69084: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69085: LD_INT 0
69087: PPUSH
69088: PPUSH
69089: PPUSH
// if not mc_bases or not skirmish then
69090: LD_EXP 101
69094: NOT
69095: PUSH
69096: LD_EXP 99
69100: NOT
69101: OR
69102: IFFALSE 69106
// exit ;
69104: GO 69296
// for i = 1 to mc_bases do
69106: LD_ADDR_VAR 0 4
69110: PUSH
69111: DOUBLE
69112: LD_INT 1
69114: DEC
69115: ST_TO_ADDR
69116: LD_EXP 101
69120: PUSH
69121: FOR_TO
69122: IFFALSE 69209
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69124: LD_VAR 0 1
69128: PUSH
69129: LD_EXP 109
69133: PUSH
69134: LD_VAR 0 4
69138: ARRAY
69139: IN
69140: PUSH
69141: LD_VAR 0 1
69145: PUSH
69146: LD_EXP 110
69150: PUSH
69151: LD_VAR 0 4
69155: ARRAY
69156: IN
69157: NOT
69158: AND
69159: IFFALSE 69207
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69161: LD_ADDR_EXP 110
69165: PUSH
69166: LD_EXP 110
69170: PPUSH
69171: LD_VAR 0 4
69175: PUSH
69176: LD_EXP 110
69180: PUSH
69181: LD_VAR 0 4
69185: ARRAY
69186: PUSH
69187: LD_INT 1
69189: PLUS
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: PPUSH
69195: LD_VAR 0 1
69199: PPUSH
69200: CALL 74404 0 3
69204: ST_TO_ADDR
// break ;
69205: GO 69209
// end ; end ;
69207: GO 69121
69209: POP
69210: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69211: LD_VAR 0 1
69215: PPUSH
69216: CALL_OW 257
69220: PUSH
69221: LD_EXP 127
69225: IN
69226: PUSH
69227: LD_VAR 0 1
69231: PPUSH
69232: CALL_OW 266
69236: PUSH
69237: LD_INT 5
69239: EQUAL
69240: AND
69241: PUSH
69242: LD_VAR 0 2
69246: PPUSH
69247: CALL_OW 110
69251: PUSH
69252: LD_INT 18
69254: NONEQUAL
69255: AND
69256: IFFALSE 69296
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69258: LD_VAR 0 2
69262: PPUSH
69263: CALL_OW 257
69267: PUSH
69268: LD_INT 5
69270: PUSH
69271: LD_INT 8
69273: PUSH
69274: LD_INT 9
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: LIST
69281: IN
69282: IFFALSE 69296
// SetClass ( unit , 1 ) ;
69284: LD_VAR 0 2
69288: PPUSH
69289: LD_INT 1
69291: PPUSH
69292: CALL_OW 336
// end ;
69296: LD_VAR 0 3
69300: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69301: LD_INT 0
69303: PPUSH
69304: PPUSH
// if not mc_bases or not skirmish then
69305: LD_EXP 101
69309: NOT
69310: PUSH
69311: LD_EXP 99
69315: NOT
69316: OR
69317: IFFALSE 69321
// exit ;
69319: GO 69437
// if GetLives ( abandoned_vehicle ) > 250 then
69321: LD_VAR 0 2
69325: PPUSH
69326: CALL_OW 256
69330: PUSH
69331: LD_INT 250
69333: GREATER
69334: IFFALSE 69338
// exit ;
69336: GO 69437
// for i = 1 to mc_bases do
69338: LD_ADDR_VAR 0 6
69342: PUSH
69343: DOUBLE
69344: LD_INT 1
69346: DEC
69347: ST_TO_ADDR
69348: LD_EXP 101
69352: PUSH
69353: FOR_TO
69354: IFFALSE 69435
// begin if driver in mc_bases [ i ] then
69356: LD_VAR 0 1
69360: PUSH
69361: LD_EXP 101
69365: PUSH
69366: LD_VAR 0 6
69370: ARRAY
69371: IN
69372: IFFALSE 69433
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69374: LD_VAR 0 1
69378: PPUSH
69379: LD_EXP 101
69383: PUSH
69384: LD_VAR 0 6
69388: ARRAY
69389: PPUSH
69390: LD_INT 2
69392: PUSH
69393: LD_INT 30
69395: PUSH
69396: LD_INT 0
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 30
69405: PUSH
69406: LD_INT 1
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: LIST
69417: PPUSH
69418: CALL_OW 72
69422: PUSH
69423: LD_INT 1
69425: ARRAY
69426: PPUSH
69427: CALL 108021 0 2
// break ;
69431: GO 69435
// end ; end ;
69433: GO 69353
69435: POP
69436: POP
// end ; end_of_file
69437: LD_VAR 0 5
69441: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69442: LD_INT 0
69444: PPUSH
69445: PPUSH
// if exist_mode then
69446: LD_VAR 0 2
69450: IFFALSE 69475
// unit := CreateCharacter ( prefix & ident ) else
69452: LD_ADDR_VAR 0 5
69456: PUSH
69457: LD_VAR 0 3
69461: PUSH
69462: LD_VAR 0 1
69466: STR
69467: PPUSH
69468: CALL_OW 34
69472: ST_TO_ADDR
69473: GO 69490
// unit := NewCharacter ( ident ) ;
69475: LD_ADDR_VAR 0 5
69479: PUSH
69480: LD_VAR 0 1
69484: PPUSH
69485: CALL_OW 25
69489: ST_TO_ADDR
// result := unit ;
69490: LD_ADDR_VAR 0 4
69494: PUSH
69495: LD_VAR 0 5
69499: ST_TO_ADDR
// end ;
69500: LD_VAR 0 4
69504: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69505: LD_INT 0
69507: PPUSH
69508: PPUSH
// if not side or not nation then
69509: LD_VAR 0 1
69513: NOT
69514: PUSH
69515: LD_VAR 0 2
69519: NOT
69520: OR
69521: IFFALSE 69525
// exit ;
69523: GO 70293
// case nation of nation_american :
69525: LD_VAR 0 2
69529: PUSH
69530: LD_INT 1
69532: DOUBLE
69533: EQUAL
69534: IFTRUE 69538
69536: GO 69752
69538: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69539: LD_ADDR_VAR 0 4
69543: PUSH
69544: LD_INT 35
69546: PUSH
69547: LD_INT 45
69549: PUSH
69550: LD_INT 46
69552: PUSH
69553: LD_INT 47
69555: PUSH
69556: LD_INT 82
69558: PUSH
69559: LD_INT 83
69561: PUSH
69562: LD_INT 84
69564: PUSH
69565: LD_INT 85
69567: PUSH
69568: LD_INT 86
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: LD_INT 2
69576: PUSH
69577: LD_INT 6
69579: PUSH
69580: LD_INT 15
69582: PUSH
69583: LD_INT 16
69585: PUSH
69586: LD_INT 7
69588: PUSH
69589: LD_INT 12
69591: PUSH
69592: LD_INT 13
69594: PUSH
69595: LD_INT 10
69597: PUSH
69598: LD_INT 14
69600: PUSH
69601: LD_INT 20
69603: PUSH
69604: LD_INT 21
69606: PUSH
69607: LD_INT 22
69609: PUSH
69610: LD_INT 25
69612: PUSH
69613: LD_INT 32
69615: PUSH
69616: LD_INT 27
69618: PUSH
69619: LD_INT 36
69621: PUSH
69622: LD_INT 69
69624: PUSH
69625: LD_INT 39
69627: PUSH
69628: LD_INT 34
69630: PUSH
69631: LD_INT 40
69633: PUSH
69634: LD_INT 48
69636: PUSH
69637: LD_INT 49
69639: PUSH
69640: LD_INT 50
69642: PUSH
69643: LD_INT 51
69645: PUSH
69646: LD_INT 52
69648: PUSH
69649: LD_INT 53
69651: PUSH
69652: LD_INT 54
69654: PUSH
69655: LD_INT 55
69657: PUSH
69658: LD_INT 56
69660: PUSH
69661: LD_INT 57
69663: PUSH
69664: LD_INT 58
69666: PUSH
69667: LD_INT 59
69669: PUSH
69670: LD_INT 60
69672: PUSH
69673: LD_INT 61
69675: PUSH
69676: LD_INT 62
69678: PUSH
69679: LD_INT 80
69681: PUSH
69682: LD_INT 82
69684: PUSH
69685: LD_INT 83
69687: PUSH
69688: LD_INT 84
69690: PUSH
69691: LD_INT 85
69693: PUSH
69694: LD_INT 86
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: ST_TO_ADDR
69750: GO 70217
69752: LD_INT 2
69754: DOUBLE
69755: EQUAL
69756: IFTRUE 69760
69758: GO 69986
69760: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69761: LD_ADDR_VAR 0 4
69765: PUSH
69766: LD_INT 35
69768: PUSH
69769: LD_INT 45
69771: PUSH
69772: LD_INT 46
69774: PUSH
69775: LD_INT 47
69777: PUSH
69778: LD_INT 82
69780: PUSH
69781: LD_INT 83
69783: PUSH
69784: LD_INT 84
69786: PUSH
69787: LD_INT 85
69789: PUSH
69790: LD_INT 87
69792: PUSH
69793: LD_INT 70
69795: PUSH
69796: LD_INT 1
69798: PUSH
69799: LD_INT 11
69801: PUSH
69802: LD_INT 3
69804: PUSH
69805: LD_INT 4
69807: PUSH
69808: LD_INT 5
69810: PUSH
69811: LD_INT 6
69813: PUSH
69814: LD_INT 15
69816: PUSH
69817: LD_INT 18
69819: PUSH
69820: LD_INT 7
69822: PUSH
69823: LD_INT 17
69825: PUSH
69826: LD_INT 8
69828: PUSH
69829: LD_INT 20
69831: PUSH
69832: LD_INT 21
69834: PUSH
69835: LD_INT 22
69837: PUSH
69838: LD_INT 72
69840: PUSH
69841: LD_INT 26
69843: PUSH
69844: LD_INT 69
69846: PUSH
69847: LD_INT 39
69849: PUSH
69850: LD_INT 40
69852: PUSH
69853: LD_INT 41
69855: PUSH
69856: LD_INT 42
69858: PUSH
69859: LD_INT 43
69861: PUSH
69862: LD_INT 48
69864: PUSH
69865: LD_INT 49
69867: PUSH
69868: LD_INT 50
69870: PUSH
69871: LD_INT 51
69873: PUSH
69874: LD_INT 52
69876: PUSH
69877: LD_INT 53
69879: PUSH
69880: LD_INT 54
69882: PUSH
69883: LD_INT 55
69885: PUSH
69886: LD_INT 56
69888: PUSH
69889: LD_INT 60
69891: PUSH
69892: LD_INT 61
69894: PUSH
69895: LD_INT 62
69897: PUSH
69898: LD_INT 66
69900: PUSH
69901: LD_INT 67
69903: PUSH
69904: LD_INT 68
69906: PUSH
69907: LD_INT 81
69909: PUSH
69910: LD_INT 82
69912: PUSH
69913: LD_INT 83
69915: PUSH
69916: LD_INT 84
69918: PUSH
69919: LD_INT 85
69921: PUSH
69922: LD_INT 87
69924: PUSH
69925: LD_INT 88
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: ST_TO_ADDR
69984: GO 70217
69986: LD_INT 3
69988: DOUBLE
69989: EQUAL
69990: IFTRUE 69994
69992: GO 70216
69994: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69995: LD_ADDR_VAR 0 4
69999: PUSH
70000: LD_INT 46
70002: PUSH
70003: LD_INT 47
70005: PUSH
70006: LD_INT 1
70008: PUSH
70009: LD_INT 2
70011: PUSH
70012: LD_INT 82
70014: PUSH
70015: LD_INT 83
70017: PUSH
70018: LD_INT 84
70020: PUSH
70021: LD_INT 85
70023: PUSH
70024: LD_INT 86
70026: PUSH
70027: LD_INT 11
70029: PUSH
70030: LD_INT 9
70032: PUSH
70033: LD_INT 20
70035: PUSH
70036: LD_INT 19
70038: PUSH
70039: LD_INT 21
70041: PUSH
70042: LD_INT 24
70044: PUSH
70045: LD_INT 22
70047: PUSH
70048: LD_INT 25
70050: PUSH
70051: LD_INT 28
70053: PUSH
70054: LD_INT 29
70056: PUSH
70057: LD_INT 30
70059: PUSH
70060: LD_INT 31
70062: PUSH
70063: LD_INT 37
70065: PUSH
70066: LD_INT 38
70068: PUSH
70069: LD_INT 32
70071: PUSH
70072: LD_INT 27
70074: PUSH
70075: LD_INT 33
70077: PUSH
70078: LD_INT 69
70080: PUSH
70081: LD_INT 39
70083: PUSH
70084: LD_INT 34
70086: PUSH
70087: LD_INT 40
70089: PUSH
70090: LD_INT 71
70092: PUSH
70093: LD_INT 23
70095: PUSH
70096: LD_INT 44
70098: PUSH
70099: LD_INT 48
70101: PUSH
70102: LD_INT 49
70104: PUSH
70105: LD_INT 50
70107: PUSH
70108: LD_INT 51
70110: PUSH
70111: LD_INT 52
70113: PUSH
70114: LD_INT 53
70116: PUSH
70117: LD_INT 54
70119: PUSH
70120: LD_INT 55
70122: PUSH
70123: LD_INT 56
70125: PUSH
70126: LD_INT 57
70128: PUSH
70129: LD_INT 58
70131: PUSH
70132: LD_INT 59
70134: PUSH
70135: LD_INT 63
70137: PUSH
70138: LD_INT 64
70140: PUSH
70141: LD_INT 65
70143: PUSH
70144: LD_INT 82
70146: PUSH
70147: LD_INT 83
70149: PUSH
70150: LD_INT 84
70152: PUSH
70153: LD_INT 85
70155: PUSH
70156: LD_INT 86
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: ST_TO_ADDR
70214: GO 70217
70216: POP
// if state > - 1 and state < 3 then
70217: LD_VAR 0 3
70221: PUSH
70222: LD_INT 1
70224: NEG
70225: GREATER
70226: PUSH
70227: LD_VAR 0 3
70231: PUSH
70232: LD_INT 3
70234: LESS
70235: AND
70236: IFFALSE 70293
// for i in result do
70238: LD_ADDR_VAR 0 5
70242: PUSH
70243: LD_VAR 0 4
70247: PUSH
70248: FOR_IN
70249: IFFALSE 70291
// if GetTech ( i , side ) <> state then
70251: LD_VAR 0 5
70255: PPUSH
70256: LD_VAR 0 1
70260: PPUSH
70261: CALL_OW 321
70265: PUSH
70266: LD_VAR 0 3
70270: NONEQUAL
70271: IFFALSE 70289
// result := result diff i ;
70273: LD_ADDR_VAR 0 4
70277: PUSH
70278: LD_VAR 0 4
70282: PUSH
70283: LD_VAR 0 5
70287: DIFF
70288: ST_TO_ADDR
70289: GO 70248
70291: POP
70292: POP
// end ;
70293: LD_VAR 0 4
70297: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70298: LD_INT 0
70300: PPUSH
70301: PPUSH
70302: PPUSH
// result := true ;
70303: LD_ADDR_VAR 0 3
70307: PUSH
70308: LD_INT 1
70310: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70311: LD_ADDR_VAR 0 5
70315: PUSH
70316: LD_VAR 0 2
70320: PPUSH
70321: CALL_OW 480
70325: ST_TO_ADDR
// if not tmp then
70326: LD_VAR 0 5
70330: NOT
70331: IFFALSE 70335
// exit ;
70333: GO 70384
// for i in tmp do
70335: LD_ADDR_VAR 0 4
70339: PUSH
70340: LD_VAR 0 5
70344: PUSH
70345: FOR_IN
70346: IFFALSE 70382
// if GetTech ( i , side ) <> state_researched then
70348: LD_VAR 0 4
70352: PPUSH
70353: LD_VAR 0 1
70357: PPUSH
70358: CALL_OW 321
70362: PUSH
70363: LD_INT 2
70365: NONEQUAL
70366: IFFALSE 70380
// begin result := false ;
70368: LD_ADDR_VAR 0 3
70372: PUSH
70373: LD_INT 0
70375: ST_TO_ADDR
// exit ;
70376: POP
70377: POP
70378: GO 70384
// end ;
70380: GO 70345
70382: POP
70383: POP
// end ;
70384: LD_VAR 0 3
70388: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70389: LD_INT 0
70391: PPUSH
70392: PPUSH
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
70397: PPUSH
70398: PPUSH
70399: PPUSH
70400: PPUSH
70401: PPUSH
70402: PPUSH
70403: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70404: LD_VAR 0 1
70408: NOT
70409: PUSH
70410: LD_VAR 0 1
70414: PPUSH
70415: CALL_OW 257
70419: PUSH
70420: LD_INT 9
70422: NONEQUAL
70423: OR
70424: IFFALSE 70428
// exit ;
70426: GO 71001
// side := GetSide ( unit ) ;
70428: LD_ADDR_VAR 0 9
70432: PUSH
70433: LD_VAR 0 1
70437: PPUSH
70438: CALL_OW 255
70442: ST_TO_ADDR
// tech_space := tech_spacanom ;
70443: LD_ADDR_VAR 0 12
70447: PUSH
70448: LD_INT 29
70450: ST_TO_ADDR
// tech_time := tech_taurad ;
70451: LD_ADDR_VAR 0 13
70455: PUSH
70456: LD_INT 28
70458: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70459: LD_ADDR_VAR 0 11
70463: PUSH
70464: LD_VAR 0 1
70468: PPUSH
70469: CALL_OW 310
70473: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70474: LD_VAR 0 11
70478: PPUSH
70479: CALL_OW 247
70483: PUSH
70484: LD_INT 2
70486: EQUAL
70487: IFFALSE 70491
// exit ;
70489: GO 71001
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70491: LD_ADDR_VAR 0 8
70495: PUSH
70496: LD_INT 81
70498: PUSH
70499: LD_VAR 0 9
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 3
70510: PUSH
70511: LD_INT 21
70513: PUSH
70514: LD_INT 3
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PPUSH
70529: CALL_OW 69
70533: ST_TO_ADDR
// if not tmp then
70534: LD_VAR 0 8
70538: NOT
70539: IFFALSE 70543
// exit ;
70541: GO 71001
// if in_unit then
70543: LD_VAR 0 11
70547: IFFALSE 70571
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70549: LD_ADDR_VAR 0 10
70553: PUSH
70554: LD_VAR 0 8
70558: PPUSH
70559: LD_VAR 0 11
70563: PPUSH
70564: CALL_OW 74
70568: ST_TO_ADDR
70569: GO 70591
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70571: LD_ADDR_VAR 0 10
70575: PUSH
70576: LD_VAR 0 8
70580: PPUSH
70581: LD_VAR 0 1
70585: PPUSH
70586: CALL_OW 74
70590: ST_TO_ADDR
// if not enemy then
70591: LD_VAR 0 10
70595: NOT
70596: IFFALSE 70600
// exit ;
70598: GO 71001
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70600: LD_VAR 0 11
70604: PUSH
70605: LD_VAR 0 11
70609: PPUSH
70610: LD_VAR 0 10
70614: PPUSH
70615: CALL_OW 296
70619: PUSH
70620: LD_INT 13
70622: GREATER
70623: AND
70624: PUSH
70625: LD_VAR 0 1
70629: PPUSH
70630: LD_VAR 0 10
70634: PPUSH
70635: CALL_OW 296
70639: PUSH
70640: LD_INT 12
70642: GREATER
70643: OR
70644: IFFALSE 70648
// exit ;
70646: GO 71001
// missile := [ 1 ] ;
70648: LD_ADDR_VAR 0 14
70652: PUSH
70653: LD_INT 1
70655: PUSH
70656: EMPTY
70657: LIST
70658: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70659: LD_VAR 0 9
70663: PPUSH
70664: LD_VAR 0 12
70668: PPUSH
70669: CALL_OW 325
70673: IFFALSE 70702
// missile := Replace ( missile , missile + 1 , 2 ) ;
70675: LD_ADDR_VAR 0 14
70679: PUSH
70680: LD_VAR 0 14
70684: PPUSH
70685: LD_VAR 0 14
70689: PUSH
70690: LD_INT 1
70692: PLUS
70693: PPUSH
70694: LD_INT 2
70696: PPUSH
70697: CALL_OW 1
70701: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70702: LD_VAR 0 9
70706: PPUSH
70707: LD_VAR 0 13
70711: PPUSH
70712: CALL_OW 325
70716: PUSH
70717: LD_VAR 0 10
70721: PPUSH
70722: CALL_OW 255
70726: PPUSH
70727: LD_VAR 0 13
70731: PPUSH
70732: CALL_OW 325
70736: NOT
70737: AND
70738: IFFALSE 70767
// missile := Replace ( missile , missile + 1 , 3 ) ;
70740: LD_ADDR_VAR 0 14
70744: PUSH
70745: LD_VAR 0 14
70749: PPUSH
70750: LD_VAR 0 14
70754: PUSH
70755: LD_INT 1
70757: PLUS
70758: PPUSH
70759: LD_INT 3
70761: PPUSH
70762: CALL_OW 1
70766: ST_TO_ADDR
// if missile < 2 then
70767: LD_VAR 0 14
70771: PUSH
70772: LD_INT 2
70774: LESS
70775: IFFALSE 70779
// exit ;
70777: GO 71001
// x := GetX ( enemy ) ;
70779: LD_ADDR_VAR 0 4
70783: PUSH
70784: LD_VAR 0 10
70788: PPUSH
70789: CALL_OW 250
70793: ST_TO_ADDR
// y := GetY ( enemy ) ;
70794: LD_ADDR_VAR 0 5
70798: PUSH
70799: LD_VAR 0 10
70803: PPUSH
70804: CALL_OW 251
70808: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70809: LD_ADDR_VAR 0 6
70813: PUSH
70814: LD_VAR 0 4
70818: PUSH
70819: LD_INT 1
70821: NEG
70822: PPUSH
70823: LD_INT 1
70825: PPUSH
70826: CALL_OW 12
70830: PLUS
70831: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70832: LD_ADDR_VAR 0 7
70836: PUSH
70837: LD_VAR 0 5
70841: PUSH
70842: LD_INT 1
70844: NEG
70845: PPUSH
70846: LD_INT 1
70848: PPUSH
70849: CALL_OW 12
70853: PLUS
70854: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70855: LD_VAR 0 6
70859: PPUSH
70860: LD_VAR 0 7
70864: PPUSH
70865: CALL_OW 488
70869: NOT
70870: IFFALSE 70892
// begin _x := x ;
70872: LD_ADDR_VAR 0 6
70876: PUSH
70877: LD_VAR 0 4
70881: ST_TO_ADDR
// _y := y ;
70882: LD_ADDR_VAR 0 7
70886: PUSH
70887: LD_VAR 0 5
70891: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70892: LD_ADDR_VAR 0 3
70896: PUSH
70897: LD_INT 1
70899: PPUSH
70900: LD_VAR 0 14
70904: PPUSH
70905: CALL_OW 12
70909: ST_TO_ADDR
// case i of 1 :
70910: LD_VAR 0 3
70914: PUSH
70915: LD_INT 1
70917: DOUBLE
70918: EQUAL
70919: IFTRUE 70923
70921: GO 70940
70923: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70924: LD_VAR 0 1
70928: PPUSH
70929: LD_VAR 0 10
70933: PPUSH
70934: CALL_OW 115
70938: GO 71001
70940: LD_INT 2
70942: DOUBLE
70943: EQUAL
70944: IFTRUE 70948
70946: GO 70970
70948: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70949: LD_VAR 0 1
70953: PPUSH
70954: LD_VAR 0 6
70958: PPUSH
70959: LD_VAR 0 7
70963: PPUSH
70964: CALL_OW 153
70968: GO 71001
70970: LD_INT 3
70972: DOUBLE
70973: EQUAL
70974: IFTRUE 70978
70976: GO 71000
70978: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70979: LD_VAR 0 1
70983: PPUSH
70984: LD_VAR 0 6
70988: PPUSH
70989: LD_VAR 0 7
70993: PPUSH
70994: CALL_OW 154
70998: GO 71001
71000: POP
// end ;
71001: LD_VAR 0 2
71005: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71006: LD_INT 0
71008: PPUSH
71009: PPUSH
71010: PPUSH
71011: PPUSH
71012: PPUSH
71013: PPUSH
// if not unit or not building then
71014: LD_VAR 0 1
71018: NOT
71019: PUSH
71020: LD_VAR 0 2
71024: NOT
71025: OR
71026: IFFALSE 71030
// exit ;
71028: GO 71188
// x := GetX ( building ) ;
71030: LD_ADDR_VAR 0 5
71034: PUSH
71035: LD_VAR 0 2
71039: PPUSH
71040: CALL_OW 250
71044: ST_TO_ADDR
// y := GetY ( building ) ;
71045: LD_ADDR_VAR 0 6
71049: PUSH
71050: LD_VAR 0 2
71054: PPUSH
71055: CALL_OW 251
71059: ST_TO_ADDR
// for i = 0 to 5 do
71060: LD_ADDR_VAR 0 4
71064: PUSH
71065: DOUBLE
71066: LD_INT 0
71068: DEC
71069: ST_TO_ADDR
71070: LD_INT 5
71072: PUSH
71073: FOR_TO
71074: IFFALSE 71186
// begin _x := ShiftX ( x , i , 3 ) ;
71076: LD_ADDR_VAR 0 7
71080: PUSH
71081: LD_VAR 0 5
71085: PPUSH
71086: LD_VAR 0 4
71090: PPUSH
71091: LD_INT 3
71093: PPUSH
71094: CALL_OW 272
71098: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71099: LD_ADDR_VAR 0 8
71103: PUSH
71104: LD_VAR 0 6
71108: PPUSH
71109: LD_VAR 0 4
71113: PPUSH
71114: LD_INT 3
71116: PPUSH
71117: CALL_OW 273
71121: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71122: LD_VAR 0 7
71126: PPUSH
71127: LD_VAR 0 8
71131: PPUSH
71132: CALL_OW 488
71136: NOT
71137: IFFALSE 71141
// continue ;
71139: GO 71073
// if HexInfo ( _x , _y ) = 0 then
71141: LD_VAR 0 7
71145: PPUSH
71146: LD_VAR 0 8
71150: PPUSH
71151: CALL_OW 428
71155: PUSH
71156: LD_INT 0
71158: EQUAL
71159: IFFALSE 71184
// begin ComMoveXY ( unit , _x , _y ) ;
71161: LD_VAR 0 1
71165: PPUSH
71166: LD_VAR 0 7
71170: PPUSH
71171: LD_VAR 0 8
71175: PPUSH
71176: CALL_OW 111
// exit ;
71180: POP
71181: POP
71182: GO 71188
// end ; end ;
71184: GO 71073
71186: POP
71187: POP
// end ;
71188: LD_VAR 0 3
71192: RET
// export function ScanBase ( side , base_area ) ; begin
71193: LD_INT 0
71195: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71196: LD_ADDR_VAR 0 3
71200: PUSH
71201: LD_VAR 0 2
71205: PPUSH
71206: LD_INT 81
71208: PUSH
71209: LD_VAR 0 1
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PPUSH
71218: CALL_OW 70
71222: ST_TO_ADDR
// end ;
71223: LD_VAR 0 3
71227: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71228: LD_INT 0
71230: PPUSH
71231: PPUSH
71232: PPUSH
71233: PPUSH
// result := false ;
71234: LD_ADDR_VAR 0 2
71238: PUSH
71239: LD_INT 0
71241: ST_TO_ADDR
// side := GetSide ( unit ) ;
71242: LD_ADDR_VAR 0 3
71246: PUSH
71247: LD_VAR 0 1
71251: PPUSH
71252: CALL_OW 255
71256: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71257: LD_ADDR_VAR 0 4
71261: PUSH
71262: LD_VAR 0 1
71266: PPUSH
71267: CALL_OW 248
71271: ST_TO_ADDR
// case nat of 1 :
71272: LD_VAR 0 4
71276: PUSH
71277: LD_INT 1
71279: DOUBLE
71280: EQUAL
71281: IFTRUE 71285
71283: GO 71296
71285: POP
// tech := tech_lassight ; 2 :
71286: LD_ADDR_VAR 0 5
71290: PUSH
71291: LD_INT 12
71293: ST_TO_ADDR
71294: GO 71335
71296: LD_INT 2
71298: DOUBLE
71299: EQUAL
71300: IFTRUE 71304
71302: GO 71315
71304: POP
// tech := tech_mortar ; 3 :
71305: LD_ADDR_VAR 0 5
71309: PUSH
71310: LD_INT 41
71312: ST_TO_ADDR
71313: GO 71335
71315: LD_INT 3
71317: DOUBLE
71318: EQUAL
71319: IFTRUE 71323
71321: GO 71334
71323: POP
// tech := tech_bazooka ; end ;
71324: LD_ADDR_VAR 0 5
71328: PUSH
71329: LD_INT 44
71331: ST_TO_ADDR
71332: GO 71335
71334: POP
// if Researched ( side , tech ) then
71335: LD_VAR 0 3
71339: PPUSH
71340: LD_VAR 0 5
71344: PPUSH
71345: CALL_OW 325
71349: IFFALSE 71376
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71351: LD_ADDR_VAR 0 2
71355: PUSH
71356: LD_INT 5
71358: PUSH
71359: LD_INT 8
71361: PUSH
71362: LD_INT 9
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: LIST
71369: PUSH
71370: LD_VAR 0 4
71374: ARRAY
71375: ST_TO_ADDR
// end ;
71376: LD_VAR 0 2
71380: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71381: LD_INT 0
71383: PPUSH
71384: PPUSH
71385: PPUSH
// if not mines then
71386: LD_VAR 0 2
71390: NOT
71391: IFFALSE 71395
// exit ;
71393: GO 71539
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71395: LD_ADDR_VAR 0 5
71399: PUSH
71400: LD_INT 81
71402: PUSH
71403: LD_VAR 0 1
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 3
71414: PUSH
71415: LD_INT 21
71417: PUSH
71418: LD_INT 3
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PPUSH
71433: CALL_OW 69
71437: ST_TO_ADDR
// for i in mines do
71438: LD_ADDR_VAR 0 4
71442: PUSH
71443: LD_VAR 0 2
71447: PUSH
71448: FOR_IN
71449: IFFALSE 71537
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71451: LD_VAR 0 4
71455: PUSH
71456: LD_INT 1
71458: ARRAY
71459: PPUSH
71460: LD_VAR 0 4
71464: PUSH
71465: LD_INT 2
71467: ARRAY
71468: PPUSH
71469: CALL_OW 458
71473: NOT
71474: IFFALSE 71478
// continue ;
71476: GO 71448
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71478: LD_VAR 0 4
71482: PUSH
71483: LD_INT 1
71485: ARRAY
71486: PPUSH
71487: LD_VAR 0 4
71491: PUSH
71492: LD_INT 2
71494: ARRAY
71495: PPUSH
71496: CALL_OW 428
71500: PUSH
71501: LD_VAR 0 5
71505: IN
71506: IFFALSE 71535
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71508: LD_VAR 0 4
71512: PUSH
71513: LD_INT 1
71515: ARRAY
71516: PPUSH
71517: LD_VAR 0 4
71521: PUSH
71522: LD_INT 2
71524: ARRAY
71525: PPUSH
71526: LD_VAR 0 1
71530: PPUSH
71531: CALL_OW 456
// end ;
71535: GO 71448
71537: POP
71538: POP
// end ;
71539: LD_VAR 0 3
71543: RET
// export function Count ( array ) ; begin
71544: LD_INT 0
71546: PPUSH
// result := array + 0 ;
71547: LD_ADDR_VAR 0 2
71551: PUSH
71552: LD_VAR 0 1
71556: PUSH
71557: LD_INT 0
71559: PLUS
71560: ST_TO_ADDR
// end ;
71561: LD_VAR 0 2
71565: RET
// export function IsEmpty ( building ) ; begin
71566: LD_INT 0
71568: PPUSH
// if not building then
71569: LD_VAR 0 1
71573: NOT
71574: IFFALSE 71578
// exit ;
71576: GO 71621
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71578: LD_ADDR_VAR 0 2
71582: PUSH
71583: LD_VAR 0 1
71587: PUSH
71588: LD_INT 22
71590: PUSH
71591: LD_VAR 0 1
71595: PPUSH
71596: CALL_OW 255
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 58
71607: PUSH
71608: EMPTY
71609: LIST
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PPUSH
71615: CALL_OW 69
71619: IN
71620: ST_TO_ADDR
// end ;
71621: LD_VAR 0 2
71625: RET
// export function IsNotFull ( building ) ; var places ; begin
71626: LD_INT 0
71628: PPUSH
71629: PPUSH
// if not building then
71630: LD_VAR 0 1
71634: NOT
71635: IFFALSE 71639
// exit ;
71637: GO 71667
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71639: LD_ADDR_VAR 0 2
71643: PUSH
71644: LD_VAR 0 1
71648: PPUSH
71649: LD_INT 3
71651: PUSH
71652: LD_INT 62
71654: PUSH
71655: EMPTY
71656: LIST
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PPUSH
71662: CALL_OW 72
71666: ST_TO_ADDR
// end ;
71667: LD_VAR 0 2
71671: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71672: LD_INT 0
71674: PPUSH
71675: PPUSH
71676: PPUSH
71677: PPUSH
// tmp := [ ] ;
71678: LD_ADDR_VAR 0 3
71682: PUSH
71683: EMPTY
71684: ST_TO_ADDR
// list := [ ] ;
71685: LD_ADDR_VAR 0 5
71689: PUSH
71690: EMPTY
71691: ST_TO_ADDR
// for i = 16 to 25 do
71692: LD_ADDR_VAR 0 4
71696: PUSH
71697: DOUBLE
71698: LD_INT 16
71700: DEC
71701: ST_TO_ADDR
71702: LD_INT 25
71704: PUSH
71705: FOR_TO
71706: IFFALSE 71779
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71708: LD_ADDR_VAR 0 3
71712: PUSH
71713: LD_VAR 0 3
71717: PUSH
71718: LD_INT 22
71720: PUSH
71721: LD_VAR 0 1
71725: PPUSH
71726: CALL_OW 255
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 91
71737: PUSH
71738: LD_VAR 0 1
71742: PUSH
71743: LD_INT 6
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 30
71753: PUSH
71754: LD_VAR 0 4
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: LIST
71767: PUSH
71768: EMPTY
71769: LIST
71770: PPUSH
71771: CALL_OW 69
71775: ADD
71776: ST_TO_ADDR
71777: GO 71705
71779: POP
71780: POP
// for i = 1 to tmp do
71781: LD_ADDR_VAR 0 4
71785: PUSH
71786: DOUBLE
71787: LD_INT 1
71789: DEC
71790: ST_TO_ADDR
71791: LD_VAR 0 3
71795: PUSH
71796: FOR_TO
71797: IFFALSE 71885
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71799: LD_ADDR_VAR 0 5
71803: PUSH
71804: LD_VAR 0 5
71808: PUSH
71809: LD_VAR 0 3
71813: PUSH
71814: LD_VAR 0 4
71818: ARRAY
71819: PPUSH
71820: CALL_OW 266
71824: PUSH
71825: LD_VAR 0 3
71829: PUSH
71830: LD_VAR 0 4
71834: ARRAY
71835: PPUSH
71836: CALL_OW 250
71840: PUSH
71841: LD_VAR 0 3
71845: PUSH
71846: LD_VAR 0 4
71850: ARRAY
71851: PPUSH
71852: CALL_OW 251
71856: PUSH
71857: LD_VAR 0 3
71861: PUSH
71862: LD_VAR 0 4
71866: ARRAY
71867: PPUSH
71868: CALL_OW 254
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: PUSH
71879: EMPTY
71880: LIST
71881: ADD
71882: ST_TO_ADDR
71883: GO 71796
71885: POP
71886: POP
// result := list ;
71887: LD_ADDR_VAR 0 2
71891: PUSH
71892: LD_VAR 0 5
71896: ST_TO_ADDR
// end ;
71897: LD_VAR 0 2
71901: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71902: LD_INT 0
71904: PPUSH
71905: PPUSH
71906: PPUSH
71907: PPUSH
71908: PPUSH
71909: PPUSH
71910: PPUSH
// if not factory then
71911: LD_VAR 0 1
71915: NOT
71916: IFFALSE 71920
// exit ;
71918: GO 72513
// if control = control_apeman then
71920: LD_VAR 0 4
71924: PUSH
71925: LD_INT 5
71927: EQUAL
71928: IFFALSE 72037
// begin tmp := UnitsInside ( factory ) ;
71930: LD_ADDR_VAR 0 8
71934: PUSH
71935: LD_VAR 0 1
71939: PPUSH
71940: CALL_OW 313
71944: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71945: LD_VAR 0 8
71949: PPUSH
71950: LD_INT 25
71952: PUSH
71953: LD_INT 12
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PPUSH
71960: CALL_OW 72
71964: NOT
71965: IFFALSE 71975
// control := control_manual ;
71967: LD_ADDR_VAR 0 4
71971: PUSH
71972: LD_INT 1
71974: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71975: LD_ADDR_VAR 0 8
71979: PUSH
71980: LD_VAR 0 1
71984: PPUSH
71985: CALL 71672 0 1
71989: ST_TO_ADDR
// if tmp then
71990: LD_VAR 0 8
71994: IFFALSE 72037
// begin for i in tmp do
71996: LD_ADDR_VAR 0 7
72000: PUSH
72001: LD_VAR 0 8
72005: PUSH
72006: FOR_IN
72007: IFFALSE 72035
// if i [ 1 ] = b_ext_radio then
72009: LD_VAR 0 7
72013: PUSH
72014: LD_INT 1
72016: ARRAY
72017: PUSH
72018: LD_INT 22
72020: EQUAL
72021: IFFALSE 72033
// begin control := control_remote ;
72023: LD_ADDR_VAR 0 4
72027: PUSH
72028: LD_INT 2
72030: ST_TO_ADDR
// break ;
72031: GO 72035
// end ;
72033: GO 72006
72035: POP
72036: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72037: LD_VAR 0 1
72041: PPUSH
72042: LD_VAR 0 2
72046: PPUSH
72047: LD_VAR 0 3
72051: PPUSH
72052: LD_VAR 0 4
72056: PPUSH
72057: LD_VAR 0 5
72061: PPUSH
72062: CALL_OW 448
72066: IFFALSE 72101
// begin result := [ chassis , engine , control , weapon ] ;
72068: LD_ADDR_VAR 0 6
72072: PUSH
72073: LD_VAR 0 2
72077: PUSH
72078: LD_VAR 0 3
72082: PUSH
72083: LD_VAR 0 4
72087: PUSH
72088: LD_VAR 0 5
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: ST_TO_ADDR
// exit ;
72099: GO 72513
// end ; _chassis := AvailableChassisList ( factory ) ;
72101: LD_ADDR_VAR 0 9
72105: PUSH
72106: LD_VAR 0 1
72110: PPUSH
72111: CALL_OW 475
72115: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72116: LD_ADDR_VAR 0 11
72120: PUSH
72121: LD_VAR 0 1
72125: PPUSH
72126: CALL_OW 476
72130: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72131: LD_ADDR_VAR 0 12
72135: PUSH
72136: LD_VAR 0 1
72140: PPUSH
72141: CALL_OW 477
72145: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72146: LD_ADDR_VAR 0 10
72150: PUSH
72151: LD_VAR 0 1
72155: PPUSH
72156: CALL_OW 478
72160: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72161: LD_VAR 0 9
72165: NOT
72166: PUSH
72167: LD_VAR 0 11
72171: NOT
72172: OR
72173: PUSH
72174: LD_VAR 0 12
72178: NOT
72179: OR
72180: PUSH
72181: LD_VAR 0 10
72185: NOT
72186: OR
72187: IFFALSE 72222
// begin result := [ chassis , engine , control , weapon ] ;
72189: LD_ADDR_VAR 0 6
72193: PUSH
72194: LD_VAR 0 2
72198: PUSH
72199: LD_VAR 0 3
72203: PUSH
72204: LD_VAR 0 4
72208: PUSH
72209: LD_VAR 0 5
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: ST_TO_ADDR
// exit ;
72220: GO 72513
// end ; if not chassis in _chassis then
72222: LD_VAR 0 2
72226: PUSH
72227: LD_VAR 0 9
72231: IN
72232: NOT
72233: IFFALSE 72259
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72235: LD_ADDR_VAR 0 2
72239: PUSH
72240: LD_VAR 0 9
72244: PUSH
72245: LD_INT 1
72247: PPUSH
72248: LD_VAR 0 9
72252: PPUSH
72253: CALL_OW 12
72257: ARRAY
72258: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72259: LD_VAR 0 2
72263: PPUSH
72264: LD_VAR 0 3
72268: PPUSH
72269: CALL 72518 0 2
72273: NOT
72274: IFFALSE 72333
// repeat engine := _engine [ 1 ] ;
72276: LD_ADDR_VAR 0 3
72280: PUSH
72281: LD_VAR 0 11
72285: PUSH
72286: LD_INT 1
72288: ARRAY
72289: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72290: LD_ADDR_VAR 0 11
72294: PUSH
72295: LD_VAR 0 11
72299: PPUSH
72300: LD_INT 1
72302: PPUSH
72303: CALL_OW 3
72307: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72308: LD_VAR 0 2
72312: PPUSH
72313: LD_VAR 0 3
72317: PPUSH
72318: CALL 72518 0 2
72322: PUSH
72323: LD_VAR 0 11
72327: PUSH
72328: EMPTY
72329: EQUAL
72330: OR
72331: IFFALSE 72276
// if not control in _control then
72333: LD_VAR 0 4
72337: PUSH
72338: LD_VAR 0 12
72342: IN
72343: NOT
72344: IFFALSE 72370
// control := _control [ rand ( 1 , _control ) ] ;
72346: LD_ADDR_VAR 0 4
72350: PUSH
72351: LD_VAR 0 12
72355: PUSH
72356: LD_INT 1
72358: PPUSH
72359: LD_VAR 0 12
72363: PPUSH
72364: CALL_OW 12
72368: ARRAY
72369: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72370: LD_VAR 0 2
72374: PPUSH
72375: LD_VAR 0 5
72379: PPUSH
72380: CALL 72738 0 2
72384: NOT
72385: IFFALSE 72444
// repeat weapon := _weapon [ 1 ] ;
72387: LD_ADDR_VAR 0 5
72391: PUSH
72392: LD_VAR 0 10
72396: PUSH
72397: LD_INT 1
72399: ARRAY
72400: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72401: LD_ADDR_VAR 0 10
72405: PUSH
72406: LD_VAR 0 10
72410: PPUSH
72411: LD_INT 1
72413: PPUSH
72414: CALL_OW 3
72418: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72419: LD_VAR 0 2
72423: PPUSH
72424: LD_VAR 0 5
72428: PPUSH
72429: CALL 72738 0 2
72433: PUSH
72434: LD_VAR 0 10
72438: PUSH
72439: EMPTY
72440: EQUAL
72441: OR
72442: IFFALSE 72387
// result := [ ] ;
72444: LD_ADDR_VAR 0 6
72448: PUSH
72449: EMPTY
72450: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72451: LD_VAR 0 1
72455: PPUSH
72456: LD_VAR 0 2
72460: PPUSH
72461: LD_VAR 0 3
72465: PPUSH
72466: LD_VAR 0 4
72470: PPUSH
72471: LD_VAR 0 5
72475: PPUSH
72476: CALL_OW 448
72480: IFFALSE 72513
// result := [ chassis , engine , control , weapon ] ;
72482: LD_ADDR_VAR 0 6
72486: PUSH
72487: LD_VAR 0 2
72491: PUSH
72492: LD_VAR 0 3
72496: PUSH
72497: LD_VAR 0 4
72501: PUSH
72502: LD_VAR 0 5
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: ST_TO_ADDR
// end ;
72513: LD_VAR 0 6
72517: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72518: LD_INT 0
72520: PPUSH
// if not chassis or not engine then
72521: LD_VAR 0 1
72525: NOT
72526: PUSH
72527: LD_VAR 0 2
72531: NOT
72532: OR
72533: IFFALSE 72537
// exit ;
72535: GO 72733
// case engine of engine_solar :
72537: LD_VAR 0 2
72541: PUSH
72542: LD_INT 2
72544: DOUBLE
72545: EQUAL
72546: IFTRUE 72550
72548: GO 72588
72550: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72551: LD_ADDR_VAR 0 3
72555: PUSH
72556: LD_INT 11
72558: PUSH
72559: LD_INT 12
72561: PUSH
72562: LD_INT 13
72564: PUSH
72565: LD_INT 14
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: LD_INT 2
72573: PUSH
72574: LD_INT 3
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: ST_TO_ADDR
72586: GO 72717
72588: LD_INT 1
72590: DOUBLE
72591: EQUAL
72592: IFTRUE 72596
72594: GO 72658
72596: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72597: LD_ADDR_VAR 0 3
72601: PUSH
72602: LD_INT 11
72604: PUSH
72605: LD_INT 12
72607: PUSH
72608: LD_INT 13
72610: PUSH
72611: LD_INT 14
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: LD_INT 2
72619: PUSH
72620: LD_INT 3
72622: PUSH
72623: LD_INT 4
72625: PUSH
72626: LD_INT 5
72628: PUSH
72629: LD_INT 21
72631: PUSH
72632: LD_INT 23
72634: PUSH
72635: LD_INT 22
72637: PUSH
72638: LD_INT 24
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: ST_TO_ADDR
72656: GO 72717
72658: LD_INT 3
72660: DOUBLE
72661: EQUAL
72662: IFTRUE 72666
72664: GO 72716
72666: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72667: LD_ADDR_VAR 0 3
72671: PUSH
72672: LD_INT 13
72674: PUSH
72675: LD_INT 14
72677: PUSH
72678: LD_INT 2
72680: PUSH
72681: LD_INT 3
72683: PUSH
72684: LD_INT 4
72686: PUSH
72687: LD_INT 5
72689: PUSH
72690: LD_INT 21
72692: PUSH
72693: LD_INT 22
72695: PUSH
72696: LD_INT 23
72698: PUSH
72699: LD_INT 24
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: ST_TO_ADDR
72714: GO 72717
72716: POP
// result := ( chassis in result ) ;
72717: LD_ADDR_VAR 0 3
72721: PUSH
72722: LD_VAR 0 1
72726: PUSH
72727: LD_VAR 0 3
72731: IN
72732: ST_TO_ADDR
// end ;
72733: LD_VAR 0 3
72737: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72738: LD_INT 0
72740: PPUSH
// if not chassis or not weapon then
72741: LD_VAR 0 1
72745: NOT
72746: PUSH
72747: LD_VAR 0 2
72751: NOT
72752: OR
72753: IFFALSE 72757
// exit ;
72755: GO 73817
// case weapon of us_machine_gun :
72757: LD_VAR 0 2
72761: PUSH
72762: LD_INT 2
72764: DOUBLE
72765: EQUAL
72766: IFTRUE 72770
72768: GO 72800
72770: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72771: LD_ADDR_VAR 0 3
72775: PUSH
72776: LD_INT 1
72778: PUSH
72779: LD_INT 2
72781: PUSH
72782: LD_INT 3
72784: PUSH
72785: LD_INT 4
72787: PUSH
72788: LD_INT 5
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: ST_TO_ADDR
72798: GO 73801
72800: LD_INT 3
72802: DOUBLE
72803: EQUAL
72804: IFTRUE 72808
72806: GO 72838
72808: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72809: LD_ADDR_VAR 0 3
72813: PUSH
72814: LD_INT 1
72816: PUSH
72817: LD_INT 2
72819: PUSH
72820: LD_INT 3
72822: PUSH
72823: LD_INT 4
72825: PUSH
72826: LD_INT 5
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: ST_TO_ADDR
72836: GO 73801
72838: LD_INT 11
72840: DOUBLE
72841: EQUAL
72842: IFTRUE 72846
72844: GO 72876
72846: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72847: LD_ADDR_VAR 0 3
72851: PUSH
72852: LD_INT 1
72854: PUSH
72855: LD_INT 2
72857: PUSH
72858: LD_INT 3
72860: PUSH
72861: LD_INT 4
72863: PUSH
72864: LD_INT 5
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: ST_TO_ADDR
72874: GO 73801
72876: LD_INT 4
72878: DOUBLE
72879: EQUAL
72880: IFTRUE 72884
72882: GO 72910
72884: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72885: LD_ADDR_VAR 0 3
72889: PUSH
72890: LD_INT 2
72892: PUSH
72893: LD_INT 3
72895: PUSH
72896: LD_INT 4
72898: PUSH
72899: LD_INT 5
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: ST_TO_ADDR
72908: GO 73801
72910: LD_INT 5
72912: DOUBLE
72913: EQUAL
72914: IFTRUE 72918
72916: GO 72944
72918: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72919: LD_ADDR_VAR 0 3
72923: PUSH
72924: LD_INT 2
72926: PUSH
72927: LD_INT 3
72929: PUSH
72930: LD_INT 4
72932: PUSH
72933: LD_INT 5
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: ST_TO_ADDR
72942: GO 73801
72944: LD_INT 9
72946: DOUBLE
72947: EQUAL
72948: IFTRUE 72952
72950: GO 72978
72952: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72953: LD_ADDR_VAR 0 3
72957: PUSH
72958: LD_INT 2
72960: PUSH
72961: LD_INT 3
72963: PUSH
72964: LD_INT 4
72966: PUSH
72967: LD_INT 5
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: ST_TO_ADDR
72976: GO 73801
72978: LD_INT 7
72980: DOUBLE
72981: EQUAL
72982: IFTRUE 72986
72984: GO 73012
72986: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72987: LD_ADDR_VAR 0 3
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: LD_INT 3
72997: PUSH
72998: LD_INT 4
73000: PUSH
73001: LD_INT 5
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: ST_TO_ADDR
73010: GO 73801
73012: LD_INT 12
73014: DOUBLE
73015: EQUAL
73016: IFTRUE 73020
73018: GO 73046
73020: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73021: LD_ADDR_VAR 0 3
73025: PUSH
73026: LD_INT 2
73028: PUSH
73029: LD_INT 3
73031: PUSH
73032: LD_INT 4
73034: PUSH
73035: LD_INT 5
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: ST_TO_ADDR
73044: GO 73801
73046: LD_INT 13
73048: DOUBLE
73049: EQUAL
73050: IFTRUE 73054
73052: GO 73080
73054: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73055: LD_ADDR_VAR 0 3
73059: PUSH
73060: LD_INT 2
73062: PUSH
73063: LD_INT 3
73065: PUSH
73066: LD_INT 4
73068: PUSH
73069: LD_INT 5
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: ST_TO_ADDR
73078: GO 73801
73080: LD_INT 14
73082: DOUBLE
73083: EQUAL
73084: IFTRUE 73088
73086: GO 73106
73088: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73089: LD_ADDR_VAR 0 3
73093: PUSH
73094: LD_INT 4
73096: PUSH
73097: LD_INT 5
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: ST_TO_ADDR
73104: GO 73801
73106: LD_INT 6
73108: DOUBLE
73109: EQUAL
73110: IFTRUE 73114
73112: GO 73132
73114: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73115: LD_ADDR_VAR 0 3
73119: PUSH
73120: LD_INT 4
73122: PUSH
73123: LD_INT 5
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: ST_TO_ADDR
73130: GO 73801
73132: LD_INT 10
73134: DOUBLE
73135: EQUAL
73136: IFTRUE 73140
73138: GO 73158
73140: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73141: LD_ADDR_VAR 0 3
73145: PUSH
73146: LD_INT 4
73148: PUSH
73149: LD_INT 5
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: ST_TO_ADDR
73156: GO 73801
73158: LD_INT 22
73160: DOUBLE
73161: EQUAL
73162: IFTRUE 73166
73164: GO 73192
73166: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73167: LD_ADDR_VAR 0 3
73171: PUSH
73172: LD_INT 11
73174: PUSH
73175: LD_INT 12
73177: PUSH
73178: LD_INT 13
73180: PUSH
73181: LD_INT 14
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: LIST
73188: LIST
73189: ST_TO_ADDR
73190: GO 73801
73192: LD_INT 23
73194: DOUBLE
73195: EQUAL
73196: IFTRUE 73200
73198: GO 73226
73200: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73201: LD_ADDR_VAR 0 3
73205: PUSH
73206: LD_INT 11
73208: PUSH
73209: LD_INT 12
73211: PUSH
73212: LD_INT 13
73214: PUSH
73215: LD_INT 14
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: ST_TO_ADDR
73224: GO 73801
73226: LD_INT 24
73228: DOUBLE
73229: EQUAL
73230: IFTRUE 73234
73232: GO 73260
73234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73235: LD_ADDR_VAR 0 3
73239: PUSH
73240: LD_INT 11
73242: PUSH
73243: LD_INT 12
73245: PUSH
73246: LD_INT 13
73248: PUSH
73249: LD_INT 14
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: LIST
73256: LIST
73257: ST_TO_ADDR
73258: GO 73801
73260: LD_INT 30
73262: DOUBLE
73263: EQUAL
73264: IFTRUE 73268
73266: GO 73294
73268: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73269: LD_ADDR_VAR 0 3
73273: PUSH
73274: LD_INT 11
73276: PUSH
73277: LD_INT 12
73279: PUSH
73280: LD_INT 13
73282: PUSH
73283: LD_INT 14
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: ST_TO_ADDR
73292: GO 73801
73294: LD_INT 25
73296: DOUBLE
73297: EQUAL
73298: IFTRUE 73302
73300: GO 73320
73302: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73303: LD_ADDR_VAR 0 3
73307: PUSH
73308: LD_INT 13
73310: PUSH
73311: LD_INT 14
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: ST_TO_ADDR
73318: GO 73801
73320: LD_INT 27
73322: DOUBLE
73323: EQUAL
73324: IFTRUE 73328
73326: GO 73346
73328: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73329: LD_ADDR_VAR 0 3
73333: PUSH
73334: LD_INT 13
73336: PUSH
73337: LD_INT 14
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: ST_TO_ADDR
73344: GO 73801
73346: LD_INT 92
73348: DOUBLE
73349: EQUAL
73350: IFTRUE 73354
73352: GO 73380
73354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73355: LD_ADDR_VAR 0 3
73359: PUSH
73360: LD_INT 11
73362: PUSH
73363: LD_INT 12
73365: PUSH
73366: LD_INT 13
73368: PUSH
73369: LD_INT 14
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: ST_TO_ADDR
73378: GO 73801
73380: LD_INT 28
73382: DOUBLE
73383: EQUAL
73384: IFTRUE 73388
73386: GO 73406
73388: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73389: LD_ADDR_VAR 0 3
73393: PUSH
73394: LD_INT 13
73396: PUSH
73397: LD_INT 14
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: ST_TO_ADDR
73404: GO 73801
73406: LD_INT 29
73408: DOUBLE
73409: EQUAL
73410: IFTRUE 73414
73412: GO 73432
73414: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73415: LD_ADDR_VAR 0 3
73419: PUSH
73420: LD_INT 13
73422: PUSH
73423: LD_INT 14
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: ST_TO_ADDR
73430: GO 73801
73432: LD_INT 31
73434: DOUBLE
73435: EQUAL
73436: IFTRUE 73440
73438: GO 73458
73440: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73441: LD_ADDR_VAR 0 3
73445: PUSH
73446: LD_INT 13
73448: PUSH
73449: LD_INT 14
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: ST_TO_ADDR
73456: GO 73801
73458: LD_INT 26
73460: DOUBLE
73461: EQUAL
73462: IFTRUE 73466
73464: GO 73484
73466: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73467: LD_ADDR_VAR 0 3
73471: PUSH
73472: LD_INT 13
73474: PUSH
73475: LD_INT 14
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: ST_TO_ADDR
73482: GO 73801
73484: LD_INT 42
73486: DOUBLE
73487: EQUAL
73488: IFTRUE 73492
73490: GO 73518
73492: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73493: LD_ADDR_VAR 0 3
73497: PUSH
73498: LD_INT 21
73500: PUSH
73501: LD_INT 22
73503: PUSH
73504: LD_INT 23
73506: PUSH
73507: LD_INT 24
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: ST_TO_ADDR
73516: GO 73801
73518: LD_INT 43
73520: DOUBLE
73521: EQUAL
73522: IFTRUE 73526
73524: GO 73552
73526: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73527: LD_ADDR_VAR 0 3
73531: PUSH
73532: LD_INT 21
73534: PUSH
73535: LD_INT 22
73537: PUSH
73538: LD_INT 23
73540: PUSH
73541: LD_INT 24
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: ST_TO_ADDR
73550: GO 73801
73552: LD_INT 44
73554: DOUBLE
73555: EQUAL
73556: IFTRUE 73560
73558: GO 73586
73560: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73561: LD_ADDR_VAR 0 3
73565: PUSH
73566: LD_INT 21
73568: PUSH
73569: LD_INT 22
73571: PUSH
73572: LD_INT 23
73574: PUSH
73575: LD_INT 24
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: ST_TO_ADDR
73584: GO 73801
73586: LD_INT 45
73588: DOUBLE
73589: EQUAL
73590: IFTRUE 73594
73592: GO 73620
73594: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73595: LD_ADDR_VAR 0 3
73599: PUSH
73600: LD_INT 21
73602: PUSH
73603: LD_INT 22
73605: PUSH
73606: LD_INT 23
73608: PUSH
73609: LD_INT 24
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: ST_TO_ADDR
73618: GO 73801
73620: LD_INT 49
73622: DOUBLE
73623: EQUAL
73624: IFTRUE 73628
73626: GO 73654
73628: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73629: LD_ADDR_VAR 0 3
73633: PUSH
73634: LD_INT 21
73636: PUSH
73637: LD_INT 22
73639: PUSH
73640: LD_INT 23
73642: PUSH
73643: LD_INT 24
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: ST_TO_ADDR
73652: GO 73801
73654: LD_INT 51
73656: DOUBLE
73657: EQUAL
73658: IFTRUE 73662
73660: GO 73688
73662: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73663: LD_ADDR_VAR 0 3
73667: PUSH
73668: LD_INT 21
73670: PUSH
73671: LD_INT 22
73673: PUSH
73674: LD_INT 23
73676: PUSH
73677: LD_INT 24
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: LIST
73684: LIST
73685: ST_TO_ADDR
73686: GO 73801
73688: LD_INT 52
73690: DOUBLE
73691: EQUAL
73692: IFTRUE 73696
73694: GO 73722
73696: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73697: LD_ADDR_VAR 0 3
73701: PUSH
73702: LD_INT 21
73704: PUSH
73705: LD_INT 22
73707: PUSH
73708: LD_INT 23
73710: PUSH
73711: LD_INT 24
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: ST_TO_ADDR
73720: GO 73801
73722: LD_INT 53
73724: DOUBLE
73725: EQUAL
73726: IFTRUE 73730
73728: GO 73748
73730: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73731: LD_ADDR_VAR 0 3
73735: PUSH
73736: LD_INT 23
73738: PUSH
73739: LD_INT 24
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: ST_TO_ADDR
73746: GO 73801
73748: LD_INT 46
73750: DOUBLE
73751: EQUAL
73752: IFTRUE 73756
73754: GO 73774
73756: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73757: LD_ADDR_VAR 0 3
73761: PUSH
73762: LD_INT 23
73764: PUSH
73765: LD_INT 24
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: ST_TO_ADDR
73772: GO 73801
73774: LD_INT 47
73776: DOUBLE
73777: EQUAL
73778: IFTRUE 73782
73780: GO 73800
73782: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73783: LD_ADDR_VAR 0 3
73787: PUSH
73788: LD_INT 23
73790: PUSH
73791: LD_INT 24
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: ST_TO_ADDR
73798: GO 73801
73800: POP
// result := ( chassis in result ) ;
73801: LD_ADDR_VAR 0 3
73805: PUSH
73806: LD_VAR 0 1
73810: PUSH
73811: LD_VAR 0 3
73815: IN
73816: ST_TO_ADDR
// end ;
73817: LD_VAR 0 3
73821: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73822: LD_INT 0
73824: PPUSH
73825: PPUSH
73826: PPUSH
73827: PPUSH
73828: PPUSH
73829: PPUSH
73830: PPUSH
// result := array ;
73831: LD_ADDR_VAR 0 5
73835: PUSH
73836: LD_VAR 0 1
73840: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73841: LD_VAR 0 1
73845: NOT
73846: PUSH
73847: LD_VAR 0 2
73851: NOT
73852: OR
73853: PUSH
73854: LD_VAR 0 3
73858: NOT
73859: OR
73860: PUSH
73861: LD_VAR 0 2
73865: PUSH
73866: LD_VAR 0 1
73870: GREATER
73871: OR
73872: PUSH
73873: LD_VAR 0 3
73877: PUSH
73878: LD_VAR 0 1
73882: GREATER
73883: OR
73884: IFFALSE 73888
// exit ;
73886: GO 74184
// if direction then
73888: LD_VAR 0 4
73892: IFFALSE 73956
// begin d := 1 ;
73894: LD_ADDR_VAR 0 9
73898: PUSH
73899: LD_INT 1
73901: ST_TO_ADDR
// if i_from > i_to then
73902: LD_VAR 0 2
73906: PUSH
73907: LD_VAR 0 3
73911: GREATER
73912: IFFALSE 73938
// length := ( array - i_from ) + i_to else
73914: LD_ADDR_VAR 0 11
73918: PUSH
73919: LD_VAR 0 1
73923: PUSH
73924: LD_VAR 0 2
73928: MINUS
73929: PUSH
73930: LD_VAR 0 3
73934: PLUS
73935: ST_TO_ADDR
73936: GO 73954
// length := i_to - i_from ;
73938: LD_ADDR_VAR 0 11
73942: PUSH
73943: LD_VAR 0 3
73947: PUSH
73948: LD_VAR 0 2
73952: MINUS
73953: ST_TO_ADDR
// end else
73954: GO 74017
// begin d := - 1 ;
73956: LD_ADDR_VAR 0 9
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: ST_TO_ADDR
// if i_from > i_to then
73965: LD_VAR 0 2
73969: PUSH
73970: LD_VAR 0 3
73974: GREATER
73975: IFFALSE 73995
// length := i_from - i_to else
73977: LD_ADDR_VAR 0 11
73981: PUSH
73982: LD_VAR 0 2
73986: PUSH
73987: LD_VAR 0 3
73991: MINUS
73992: ST_TO_ADDR
73993: GO 74017
// length := ( array - i_to ) + i_from ;
73995: LD_ADDR_VAR 0 11
73999: PUSH
74000: LD_VAR 0 1
74004: PUSH
74005: LD_VAR 0 3
74009: MINUS
74010: PUSH
74011: LD_VAR 0 2
74015: PLUS
74016: ST_TO_ADDR
// end ; if not length then
74017: LD_VAR 0 11
74021: NOT
74022: IFFALSE 74026
// exit ;
74024: GO 74184
// tmp := array ;
74026: LD_ADDR_VAR 0 10
74030: PUSH
74031: LD_VAR 0 1
74035: ST_TO_ADDR
// for i = 1 to length do
74036: LD_ADDR_VAR 0 6
74040: PUSH
74041: DOUBLE
74042: LD_INT 1
74044: DEC
74045: ST_TO_ADDR
74046: LD_VAR 0 11
74050: PUSH
74051: FOR_TO
74052: IFFALSE 74172
// begin for j = 1 to array do
74054: LD_ADDR_VAR 0 7
74058: PUSH
74059: DOUBLE
74060: LD_INT 1
74062: DEC
74063: ST_TO_ADDR
74064: LD_VAR 0 1
74068: PUSH
74069: FOR_TO
74070: IFFALSE 74158
// begin k := j + d ;
74072: LD_ADDR_VAR 0 8
74076: PUSH
74077: LD_VAR 0 7
74081: PUSH
74082: LD_VAR 0 9
74086: PLUS
74087: ST_TO_ADDR
// if k > array then
74088: LD_VAR 0 8
74092: PUSH
74093: LD_VAR 0 1
74097: GREATER
74098: IFFALSE 74108
// k := 1 ;
74100: LD_ADDR_VAR 0 8
74104: PUSH
74105: LD_INT 1
74107: ST_TO_ADDR
// if not k then
74108: LD_VAR 0 8
74112: NOT
74113: IFFALSE 74125
// k := array ;
74115: LD_ADDR_VAR 0 8
74119: PUSH
74120: LD_VAR 0 1
74124: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74125: LD_ADDR_VAR 0 10
74129: PUSH
74130: LD_VAR 0 10
74134: PPUSH
74135: LD_VAR 0 8
74139: PPUSH
74140: LD_VAR 0 1
74144: PUSH
74145: LD_VAR 0 7
74149: ARRAY
74150: PPUSH
74151: CALL_OW 1
74155: ST_TO_ADDR
// end ;
74156: GO 74069
74158: POP
74159: POP
// array := tmp ;
74160: LD_ADDR_VAR 0 1
74164: PUSH
74165: LD_VAR 0 10
74169: ST_TO_ADDR
// end ;
74170: GO 74051
74172: POP
74173: POP
// result := array ;
74174: LD_ADDR_VAR 0 5
74178: PUSH
74179: LD_VAR 0 1
74183: ST_TO_ADDR
// end ;
74184: LD_VAR 0 5
74188: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74189: LD_INT 0
74191: PPUSH
74192: PPUSH
// result := 0 ;
74193: LD_ADDR_VAR 0 3
74197: PUSH
74198: LD_INT 0
74200: ST_TO_ADDR
// if not array or not value in array then
74201: LD_VAR 0 1
74205: NOT
74206: PUSH
74207: LD_VAR 0 2
74211: PUSH
74212: LD_VAR 0 1
74216: IN
74217: NOT
74218: OR
74219: IFFALSE 74223
// exit ;
74221: GO 74277
// for i = 1 to array do
74223: LD_ADDR_VAR 0 4
74227: PUSH
74228: DOUBLE
74229: LD_INT 1
74231: DEC
74232: ST_TO_ADDR
74233: LD_VAR 0 1
74237: PUSH
74238: FOR_TO
74239: IFFALSE 74275
// if value = array [ i ] then
74241: LD_VAR 0 2
74245: PUSH
74246: LD_VAR 0 1
74250: PUSH
74251: LD_VAR 0 4
74255: ARRAY
74256: EQUAL
74257: IFFALSE 74273
// begin result := i ;
74259: LD_ADDR_VAR 0 3
74263: PUSH
74264: LD_VAR 0 4
74268: ST_TO_ADDR
// exit ;
74269: POP
74270: POP
74271: GO 74277
// end ;
74273: GO 74238
74275: POP
74276: POP
// end ;
74277: LD_VAR 0 3
74281: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74282: LD_INT 0
74284: PPUSH
// vc_chassis := chassis ;
74285: LD_ADDR_OWVAR 37
74289: PUSH
74290: LD_VAR 0 1
74294: ST_TO_ADDR
// vc_engine := engine ;
74295: LD_ADDR_OWVAR 39
74299: PUSH
74300: LD_VAR 0 2
74304: ST_TO_ADDR
// vc_control := control ;
74305: LD_ADDR_OWVAR 38
74309: PUSH
74310: LD_VAR 0 3
74314: ST_TO_ADDR
// vc_weapon := weapon ;
74315: LD_ADDR_OWVAR 40
74319: PUSH
74320: LD_VAR 0 4
74324: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74325: LD_ADDR_OWVAR 41
74329: PUSH
74330: LD_VAR 0 5
74334: ST_TO_ADDR
// end ;
74335: LD_VAR 0 6
74339: RET
// export function WantPlant ( unit ) ; var task ; begin
74340: LD_INT 0
74342: PPUSH
74343: PPUSH
// result := false ;
74344: LD_ADDR_VAR 0 2
74348: PUSH
74349: LD_INT 0
74351: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74352: LD_ADDR_VAR 0 3
74356: PUSH
74357: LD_VAR 0 1
74361: PPUSH
74362: CALL_OW 437
74366: ST_TO_ADDR
// if task then
74367: LD_VAR 0 3
74371: IFFALSE 74399
// if task [ 1 ] [ 1 ] = p then
74373: LD_VAR 0 3
74377: PUSH
74378: LD_INT 1
74380: ARRAY
74381: PUSH
74382: LD_INT 1
74384: ARRAY
74385: PUSH
74386: LD_STRING p
74388: EQUAL
74389: IFFALSE 74399
// result := true ;
74391: LD_ADDR_VAR 0 2
74395: PUSH
74396: LD_INT 1
74398: ST_TO_ADDR
// end ;
74399: LD_VAR 0 2
74403: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74404: LD_INT 0
74406: PPUSH
74407: PPUSH
74408: PPUSH
74409: PPUSH
// if pos < 1 then
74410: LD_VAR 0 2
74414: PUSH
74415: LD_INT 1
74417: LESS
74418: IFFALSE 74422
// exit ;
74420: GO 74725
// if pos = 1 then
74422: LD_VAR 0 2
74426: PUSH
74427: LD_INT 1
74429: EQUAL
74430: IFFALSE 74463
// result := Replace ( arr , pos [ 1 ] , value ) else
74432: LD_ADDR_VAR 0 4
74436: PUSH
74437: LD_VAR 0 1
74441: PPUSH
74442: LD_VAR 0 2
74446: PUSH
74447: LD_INT 1
74449: ARRAY
74450: PPUSH
74451: LD_VAR 0 3
74455: PPUSH
74456: CALL_OW 1
74460: ST_TO_ADDR
74461: GO 74725
// begin tmp := arr ;
74463: LD_ADDR_VAR 0 6
74467: PUSH
74468: LD_VAR 0 1
74472: ST_TO_ADDR
// s_arr := [ tmp ] ;
74473: LD_ADDR_VAR 0 7
74477: PUSH
74478: LD_VAR 0 6
74482: PUSH
74483: EMPTY
74484: LIST
74485: ST_TO_ADDR
// for i = 1 to pos - 1 do
74486: LD_ADDR_VAR 0 5
74490: PUSH
74491: DOUBLE
74492: LD_INT 1
74494: DEC
74495: ST_TO_ADDR
74496: LD_VAR 0 2
74500: PUSH
74501: LD_INT 1
74503: MINUS
74504: PUSH
74505: FOR_TO
74506: IFFALSE 74551
// begin tmp := tmp [ pos [ i ] ] ;
74508: LD_ADDR_VAR 0 6
74512: PUSH
74513: LD_VAR 0 6
74517: PUSH
74518: LD_VAR 0 2
74522: PUSH
74523: LD_VAR 0 5
74527: ARRAY
74528: ARRAY
74529: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74530: LD_ADDR_VAR 0 7
74534: PUSH
74535: LD_VAR 0 7
74539: PUSH
74540: LD_VAR 0 6
74544: PUSH
74545: EMPTY
74546: LIST
74547: ADD
74548: ST_TO_ADDR
// end ;
74549: GO 74505
74551: POP
74552: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74553: LD_ADDR_VAR 0 6
74557: PUSH
74558: LD_VAR 0 6
74562: PPUSH
74563: LD_VAR 0 2
74567: PUSH
74568: LD_VAR 0 2
74572: ARRAY
74573: PPUSH
74574: LD_VAR 0 3
74578: PPUSH
74579: CALL_OW 1
74583: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74584: LD_ADDR_VAR 0 7
74588: PUSH
74589: LD_VAR 0 7
74593: PPUSH
74594: LD_VAR 0 7
74598: PPUSH
74599: LD_VAR 0 6
74603: PPUSH
74604: CALL_OW 1
74608: ST_TO_ADDR
// for i = s_arr downto 2 do
74609: LD_ADDR_VAR 0 5
74613: PUSH
74614: DOUBLE
74615: LD_VAR 0 7
74619: INC
74620: ST_TO_ADDR
74621: LD_INT 2
74623: PUSH
74624: FOR_DOWNTO
74625: IFFALSE 74709
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74627: LD_ADDR_VAR 0 6
74631: PUSH
74632: LD_VAR 0 7
74636: PUSH
74637: LD_VAR 0 5
74641: PUSH
74642: LD_INT 1
74644: MINUS
74645: ARRAY
74646: PPUSH
74647: LD_VAR 0 2
74651: PUSH
74652: LD_VAR 0 5
74656: PUSH
74657: LD_INT 1
74659: MINUS
74660: ARRAY
74661: PPUSH
74662: LD_VAR 0 7
74666: PUSH
74667: LD_VAR 0 5
74671: ARRAY
74672: PPUSH
74673: CALL_OW 1
74677: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74678: LD_ADDR_VAR 0 7
74682: PUSH
74683: LD_VAR 0 7
74687: PPUSH
74688: LD_VAR 0 5
74692: PUSH
74693: LD_INT 1
74695: MINUS
74696: PPUSH
74697: LD_VAR 0 6
74701: PPUSH
74702: CALL_OW 1
74706: ST_TO_ADDR
// end ;
74707: GO 74624
74709: POP
74710: POP
// result := s_arr [ 1 ] ;
74711: LD_ADDR_VAR 0 4
74715: PUSH
74716: LD_VAR 0 7
74720: PUSH
74721: LD_INT 1
74723: ARRAY
74724: ST_TO_ADDR
// end ; end ;
74725: LD_VAR 0 4
74729: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74730: LD_INT 0
74732: PPUSH
74733: PPUSH
// if not list then
74734: LD_VAR 0 1
74738: NOT
74739: IFFALSE 74743
// exit ;
74741: GO 74834
// i := list [ pos1 ] ;
74743: LD_ADDR_VAR 0 5
74747: PUSH
74748: LD_VAR 0 1
74752: PUSH
74753: LD_VAR 0 2
74757: ARRAY
74758: ST_TO_ADDR
// if not i then
74759: LD_VAR 0 5
74763: NOT
74764: IFFALSE 74768
// exit ;
74766: GO 74834
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74768: LD_ADDR_VAR 0 1
74772: PUSH
74773: LD_VAR 0 1
74777: PPUSH
74778: LD_VAR 0 2
74782: PPUSH
74783: LD_VAR 0 1
74787: PUSH
74788: LD_VAR 0 3
74792: ARRAY
74793: PPUSH
74794: CALL_OW 1
74798: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74799: LD_ADDR_VAR 0 1
74803: PUSH
74804: LD_VAR 0 1
74808: PPUSH
74809: LD_VAR 0 3
74813: PPUSH
74814: LD_VAR 0 5
74818: PPUSH
74819: CALL_OW 1
74823: ST_TO_ADDR
// result := list ;
74824: LD_ADDR_VAR 0 4
74828: PUSH
74829: LD_VAR 0 1
74833: ST_TO_ADDR
// end ;
74834: LD_VAR 0 4
74838: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74839: LD_INT 0
74841: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74842: LD_ADDR_VAR 0 5
74846: PUSH
74847: LD_VAR 0 1
74851: PPUSH
74852: CALL_OW 250
74856: PPUSH
74857: LD_VAR 0 1
74861: PPUSH
74862: CALL_OW 251
74866: PPUSH
74867: LD_VAR 0 2
74871: PPUSH
74872: LD_VAR 0 3
74876: PPUSH
74877: LD_VAR 0 4
74881: PPUSH
74882: CALL 75260 0 5
74886: ST_TO_ADDR
// end ;
74887: LD_VAR 0 5
74891: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
74892: LD_INT 0
74894: PPUSH
74895: PPUSH
74896: PPUSH
74897: PPUSH
// if not list or not unit then
74898: LD_VAR 0 2
74902: NOT
74903: PUSH
74904: LD_VAR 0 1
74908: NOT
74909: OR
74910: IFFALSE 74914
// exit ;
74912: GO 75255
// result := [ ] ;
74914: LD_ADDR_VAR 0 5
74918: PUSH
74919: EMPTY
74920: ST_TO_ADDR
// for i in list do
74921: LD_ADDR_VAR 0 6
74925: PUSH
74926: LD_VAR 0 2
74930: PUSH
74931: FOR_IN
74932: IFFALSE 75150
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
74934: LD_ADDR_VAR 0 8
74938: PUSH
74939: LD_VAR 0 1
74943: PPUSH
74944: LD_VAR 0 6
74948: PUSH
74949: LD_INT 1
74951: ARRAY
74952: PPUSH
74953: LD_VAR 0 6
74957: PUSH
74958: LD_INT 2
74960: ARRAY
74961: PPUSH
74962: CALL_OW 297
74966: ST_TO_ADDR
// if not Count ( result ) then
74967: LD_VAR 0 5
74971: PPUSH
74972: CALL 71544 0 1
74976: NOT
74977: IFFALSE 75010
// begin result := Join ( result , [ i , tmp ] ) ;
74979: LD_ADDR_VAR 0 5
74983: PUSH
74984: LD_VAR 0 5
74988: PPUSH
74989: LD_VAR 0 6
74993: PUSH
74994: LD_VAR 0 8
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PPUSH
75003: CALL 107144 0 2
75007: ST_TO_ADDR
// continue ;
75008: GO 74931
// end ; if result [ result ] [ 2 ] <= tmp then
75010: LD_VAR 0 5
75014: PUSH
75015: LD_VAR 0 5
75019: ARRAY
75020: PUSH
75021: LD_INT 2
75023: ARRAY
75024: PUSH
75025: LD_VAR 0 8
75029: LESSEQUAL
75030: IFFALSE 75063
// result := Join ( result , [ i , tmp ] ) else
75032: LD_ADDR_VAR 0 5
75036: PUSH
75037: LD_VAR 0 5
75041: PPUSH
75042: LD_VAR 0 6
75046: PUSH
75047: LD_VAR 0 8
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: PPUSH
75056: CALL 107144 0 2
75060: ST_TO_ADDR
75061: GO 75148
// begin for j := 1 to Count ( result ) do
75063: LD_ADDR_VAR 0 7
75067: PUSH
75068: DOUBLE
75069: LD_INT 1
75071: DEC
75072: ST_TO_ADDR
75073: LD_VAR 0 5
75077: PPUSH
75078: CALL 71544 0 1
75082: PUSH
75083: FOR_TO
75084: IFFALSE 75146
// begin if tmp < result [ j ] [ 2 ] then
75086: LD_VAR 0 8
75090: PUSH
75091: LD_VAR 0 5
75095: PUSH
75096: LD_VAR 0 7
75100: ARRAY
75101: PUSH
75102: LD_INT 2
75104: ARRAY
75105: LESS
75106: IFFALSE 75144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75108: LD_ADDR_VAR 0 5
75112: PUSH
75113: LD_VAR 0 5
75117: PPUSH
75118: LD_VAR 0 7
75122: PPUSH
75123: LD_VAR 0 6
75127: PUSH
75128: LD_VAR 0 8
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PPUSH
75137: CALL_OW 2
75141: ST_TO_ADDR
// break ;
75142: GO 75146
// end ; end ;
75144: GO 75083
75146: POP
75147: POP
// end ; end ;
75148: GO 74931
75150: POP
75151: POP
// if result and not asc then
75152: LD_VAR 0 5
75156: PUSH
75157: LD_VAR 0 3
75161: NOT
75162: AND
75163: IFFALSE 75180
// result := ReverseArray ( result ) ;
75165: LD_ADDR_VAR 0 5
75169: PUSH
75170: LD_VAR 0 5
75174: PPUSH
75175: CALL 102420 0 1
75179: ST_TO_ADDR
// tmp := [ ] ;
75180: LD_ADDR_VAR 0 8
75184: PUSH
75185: EMPTY
75186: ST_TO_ADDR
// if mode then
75187: LD_VAR 0 4
75191: IFFALSE 75255
// begin for i := 1 to result do
75193: LD_ADDR_VAR 0 6
75197: PUSH
75198: DOUBLE
75199: LD_INT 1
75201: DEC
75202: ST_TO_ADDR
75203: LD_VAR 0 5
75207: PUSH
75208: FOR_TO
75209: IFFALSE 75243
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75211: LD_ADDR_VAR 0 8
75215: PUSH
75216: LD_VAR 0 8
75220: PPUSH
75221: LD_VAR 0 5
75225: PUSH
75226: LD_VAR 0 6
75230: ARRAY
75231: PUSH
75232: LD_INT 1
75234: ARRAY
75235: PPUSH
75236: CALL 107144 0 2
75240: ST_TO_ADDR
75241: GO 75208
75243: POP
75244: POP
// result := tmp ;
75245: LD_ADDR_VAR 0 5
75249: PUSH
75250: LD_VAR 0 8
75254: ST_TO_ADDR
// end ; end ;
75255: LD_VAR 0 5
75259: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75260: LD_INT 0
75262: PPUSH
75263: PPUSH
75264: PPUSH
75265: PPUSH
// if not list then
75266: LD_VAR 0 3
75270: NOT
75271: IFFALSE 75275
// exit ;
75273: GO 75663
// result := [ ] ;
75275: LD_ADDR_VAR 0 6
75279: PUSH
75280: EMPTY
75281: ST_TO_ADDR
// for i in list do
75282: LD_ADDR_VAR 0 7
75286: PUSH
75287: LD_VAR 0 3
75291: PUSH
75292: FOR_IN
75293: IFFALSE 75495
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75295: LD_ADDR_VAR 0 9
75299: PUSH
75300: LD_VAR 0 7
75304: PPUSH
75305: LD_VAR 0 1
75309: PPUSH
75310: LD_VAR 0 2
75314: PPUSH
75315: CALL_OW 297
75319: ST_TO_ADDR
// if not result then
75320: LD_VAR 0 6
75324: NOT
75325: IFFALSE 75351
// result := [ [ i , tmp ] ] else
75327: LD_ADDR_VAR 0 6
75331: PUSH
75332: LD_VAR 0 7
75336: PUSH
75337: LD_VAR 0 9
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: EMPTY
75347: LIST
75348: ST_TO_ADDR
75349: GO 75493
// begin if result [ result ] [ 2 ] < tmp then
75351: LD_VAR 0 6
75355: PUSH
75356: LD_VAR 0 6
75360: ARRAY
75361: PUSH
75362: LD_INT 2
75364: ARRAY
75365: PUSH
75366: LD_VAR 0 9
75370: LESS
75371: IFFALSE 75413
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75373: LD_ADDR_VAR 0 6
75377: PUSH
75378: LD_VAR 0 6
75382: PPUSH
75383: LD_VAR 0 6
75387: PUSH
75388: LD_INT 1
75390: PLUS
75391: PPUSH
75392: LD_VAR 0 7
75396: PUSH
75397: LD_VAR 0 9
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PPUSH
75406: CALL_OW 2
75410: ST_TO_ADDR
75411: GO 75493
// for j = 1 to result do
75413: LD_ADDR_VAR 0 8
75417: PUSH
75418: DOUBLE
75419: LD_INT 1
75421: DEC
75422: ST_TO_ADDR
75423: LD_VAR 0 6
75427: PUSH
75428: FOR_TO
75429: IFFALSE 75491
// begin if tmp < result [ j ] [ 2 ] then
75431: LD_VAR 0 9
75435: PUSH
75436: LD_VAR 0 6
75440: PUSH
75441: LD_VAR 0 8
75445: ARRAY
75446: PUSH
75447: LD_INT 2
75449: ARRAY
75450: LESS
75451: IFFALSE 75489
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75453: LD_ADDR_VAR 0 6
75457: PUSH
75458: LD_VAR 0 6
75462: PPUSH
75463: LD_VAR 0 8
75467: PPUSH
75468: LD_VAR 0 7
75472: PUSH
75473: LD_VAR 0 9
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PPUSH
75482: CALL_OW 2
75486: ST_TO_ADDR
// break ;
75487: GO 75491
// end ; end ;
75489: GO 75428
75491: POP
75492: POP
// end ; end ;
75493: GO 75292
75495: POP
75496: POP
// if result and not asc then
75497: LD_VAR 0 6
75501: PUSH
75502: LD_VAR 0 4
75506: NOT
75507: AND
75508: IFFALSE 75583
// begin tmp := result ;
75510: LD_ADDR_VAR 0 9
75514: PUSH
75515: LD_VAR 0 6
75519: ST_TO_ADDR
// for i = tmp downto 1 do
75520: LD_ADDR_VAR 0 7
75524: PUSH
75525: DOUBLE
75526: LD_VAR 0 9
75530: INC
75531: ST_TO_ADDR
75532: LD_INT 1
75534: PUSH
75535: FOR_DOWNTO
75536: IFFALSE 75581
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75538: LD_ADDR_VAR 0 6
75542: PUSH
75543: LD_VAR 0 6
75547: PPUSH
75548: LD_VAR 0 9
75552: PUSH
75553: LD_VAR 0 7
75557: MINUS
75558: PUSH
75559: LD_INT 1
75561: PLUS
75562: PPUSH
75563: LD_VAR 0 9
75567: PUSH
75568: LD_VAR 0 7
75572: ARRAY
75573: PPUSH
75574: CALL_OW 1
75578: ST_TO_ADDR
75579: GO 75535
75581: POP
75582: POP
// end ; tmp := [ ] ;
75583: LD_ADDR_VAR 0 9
75587: PUSH
75588: EMPTY
75589: ST_TO_ADDR
// if mode then
75590: LD_VAR 0 5
75594: IFFALSE 75663
// begin for i = 1 to result do
75596: LD_ADDR_VAR 0 7
75600: PUSH
75601: DOUBLE
75602: LD_INT 1
75604: DEC
75605: ST_TO_ADDR
75606: LD_VAR 0 6
75610: PUSH
75611: FOR_TO
75612: IFFALSE 75651
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75614: LD_ADDR_VAR 0 9
75618: PUSH
75619: LD_VAR 0 9
75623: PPUSH
75624: LD_VAR 0 7
75628: PPUSH
75629: LD_VAR 0 6
75633: PUSH
75634: LD_VAR 0 7
75638: ARRAY
75639: PUSH
75640: LD_INT 1
75642: ARRAY
75643: PPUSH
75644: CALL_OW 1
75648: ST_TO_ADDR
75649: GO 75611
75651: POP
75652: POP
// result := tmp ;
75653: LD_ADDR_VAR 0 6
75657: PUSH
75658: LD_VAR 0 9
75662: ST_TO_ADDR
// end ; end ;
75663: LD_VAR 0 6
75667: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75668: LD_INT 0
75670: PPUSH
75671: PPUSH
75672: PPUSH
75673: PPUSH
75674: PPUSH
75675: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75676: LD_ADDR_VAR 0 5
75680: PUSH
75681: LD_INT 0
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: LD_INT 0
75689: PUSH
75690: EMPTY
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: ST_TO_ADDR
// if not x or not y then
75698: LD_VAR 0 2
75702: NOT
75703: PUSH
75704: LD_VAR 0 3
75708: NOT
75709: OR
75710: IFFALSE 75714
// exit ;
75712: GO 77364
// if not range then
75714: LD_VAR 0 4
75718: NOT
75719: IFFALSE 75729
// range := 10 ;
75721: LD_ADDR_VAR 0 4
75725: PUSH
75726: LD_INT 10
75728: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75729: LD_ADDR_VAR 0 8
75733: PUSH
75734: LD_INT 81
75736: PUSH
75737: LD_VAR 0 1
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 92
75748: PUSH
75749: LD_VAR 0 2
75753: PUSH
75754: LD_VAR 0 3
75758: PUSH
75759: LD_VAR 0 4
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 3
75772: PUSH
75773: LD_INT 21
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: LIST
75791: PPUSH
75792: CALL_OW 69
75796: ST_TO_ADDR
// if not tmp then
75797: LD_VAR 0 8
75801: NOT
75802: IFFALSE 75806
// exit ;
75804: GO 77364
// for i in tmp do
75806: LD_ADDR_VAR 0 6
75810: PUSH
75811: LD_VAR 0 8
75815: PUSH
75816: FOR_IN
75817: IFFALSE 77339
// begin points := [ 0 , 0 , 0 ] ;
75819: LD_ADDR_VAR 0 9
75823: PUSH
75824: LD_INT 0
75826: PUSH
75827: LD_INT 0
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: LIST
75837: ST_TO_ADDR
// bpoints := 1 ;
75838: LD_ADDR_VAR 0 10
75842: PUSH
75843: LD_INT 1
75845: ST_TO_ADDR
// case GetType ( i ) of unit_human :
75846: LD_VAR 0 6
75850: PPUSH
75851: CALL_OW 247
75855: PUSH
75856: LD_INT 1
75858: DOUBLE
75859: EQUAL
75860: IFTRUE 75864
75862: GO 76442
75864: POP
// begin if GetClass ( i ) = 1 then
75865: LD_VAR 0 6
75869: PPUSH
75870: CALL_OW 257
75874: PUSH
75875: LD_INT 1
75877: EQUAL
75878: IFFALSE 75899
// points := [ 10 , 5 , 3 ] ;
75880: LD_ADDR_VAR 0 9
75884: PUSH
75885: LD_INT 10
75887: PUSH
75888: LD_INT 5
75890: PUSH
75891: LD_INT 3
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: LIST
75898: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
75899: LD_VAR 0 6
75903: PPUSH
75904: CALL_OW 257
75908: PUSH
75909: LD_INT 2
75911: PUSH
75912: LD_INT 3
75914: PUSH
75915: LD_INT 4
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: LIST
75922: IN
75923: IFFALSE 75944
// points := [ 3 , 2 , 1 ] ;
75925: LD_ADDR_VAR 0 9
75929: PUSH
75930: LD_INT 3
75932: PUSH
75933: LD_INT 2
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: LIST
75943: ST_TO_ADDR
// if GetClass ( i ) = 5 then
75944: LD_VAR 0 6
75948: PPUSH
75949: CALL_OW 257
75953: PUSH
75954: LD_INT 5
75956: EQUAL
75957: IFFALSE 75978
// points := [ 130 , 5 , 2 ] ;
75959: LD_ADDR_VAR 0 9
75963: PUSH
75964: LD_INT 130
75966: PUSH
75967: LD_INT 5
75969: PUSH
75970: LD_INT 2
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: LIST
75977: ST_TO_ADDR
// if GetClass ( i ) = 8 then
75978: LD_VAR 0 6
75982: PPUSH
75983: CALL_OW 257
75987: PUSH
75988: LD_INT 8
75990: EQUAL
75991: IFFALSE 76012
// points := [ 35 , 35 , 30 ] ;
75993: LD_ADDR_VAR 0 9
75997: PUSH
75998: LD_INT 35
76000: PUSH
76001: LD_INT 35
76003: PUSH
76004: LD_INT 30
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: LIST
76011: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76012: LD_VAR 0 6
76016: PPUSH
76017: CALL_OW 257
76021: PUSH
76022: LD_INT 9
76024: EQUAL
76025: IFFALSE 76046
// points := [ 20 , 55 , 40 ] ;
76027: LD_ADDR_VAR 0 9
76031: PUSH
76032: LD_INT 20
76034: PUSH
76035: LD_INT 55
76037: PUSH
76038: LD_INT 40
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: LIST
76045: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76046: LD_VAR 0 6
76050: PPUSH
76051: CALL_OW 257
76055: PUSH
76056: LD_INT 12
76058: PUSH
76059: LD_INT 16
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: IN
76066: IFFALSE 76087
// points := [ 5 , 3 , 2 ] ;
76068: LD_ADDR_VAR 0 9
76072: PUSH
76073: LD_INT 5
76075: PUSH
76076: LD_INT 3
76078: PUSH
76079: LD_INT 2
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: LIST
76086: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76087: LD_VAR 0 6
76091: PPUSH
76092: CALL_OW 257
76096: PUSH
76097: LD_INT 17
76099: EQUAL
76100: IFFALSE 76121
// points := [ 100 , 50 , 75 ] ;
76102: LD_ADDR_VAR 0 9
76106: PUSH
76107: LD_INT 100
76109: PUSH
76110: LD_INT 50
76112: PUSH
76113: LD_INT 75
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: LIST
76120: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76121: LD_VAR 0 6
76125: PPUSH
76126: CALL_OW 257
76130: PUSH
76131: LD_INT 15
76133: EQUAL
76134: IFFALSE 76155
// points := [ 10 , 5 , 3 ] ;
76136: LD_ADDR_VAR 0 9
76140: PUSH
76141: LD_INT 10
76143: PUSH
76144: LD_INT 5
76146: PUSH
76147: LD_INT 3
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: LIST
76154: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76155: LD_VAR 0 6
76159: PPUSH
76160: CALL_OW 257
76164: PUSH
76165: LD_INT 14
76167: EQUAL
76168: IFFALSE 76189
// points := [ 10 , 0 , 0 ] ;
76170: LD_ADDR_VAR 0 9
76174: PUSH
76175: LD_INT 10
76177: PUSH
76178: LD_INT 0
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: LIST
76188: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76189: LD_VAR 0 6
76193: PPUSH
76194: CALL_OW 257
76198: PUSH
76199: LD_INT 11
76201: EQUAL
76202: IFFALSE 76223
// points := [ 30 , 10 , 5 ] ;
76204: LD_ADDR_VAR 0 9
76208: PUSH
76209: LD_INT 30
76211: PUSH
76212: LD_INT 10
76214: PUSH
76215: LD_INT 5
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: LIST
76222: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76223: LD_VAR 0 1
76227: PPUSH
76228: LD_INT 5
76230: PPUSH
76231: CALL_OW 321
76235: PUSH
76236: LD_INT 2
76238: EQUAL
76239: IFFALSE 76256
// bpoints := bpoints * 1.8 ;
76241: LD_ADDR_VAR 0 10
76245: PUSH
76246: LD_VAR 0 10
76250: PUSH
76251: LD_REAL  1.80000000000000E+0000
76254: MUL
76255: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76256: LD_VAR 0 6
76260: PPUSH
76261: CALL_OW 257
76265: PUSH
76266: LD_INT 1
76268: PUSH
76269: LD_INT 2
76271: PUSH
76272: LD_INT 3
76274: PUSH
76275: LD_INT 4
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: IN
76284: PUSH
76285: LD_VAR 0 1
76289: PPUSH
76290: LD_INT 51
76292: PPUSH
76293: CALL_OW 321
76297: PUSH
76298: LD_INT 2
76300: EQUAL
76301: AND
76302: IFFALSE 76319
// bpoints := bpoints * 1.2 ;
76304: LD_ADDR_VAR 0 10
76308: PUSH
76309: LD_VAR 0 10
76313: PUSH
76314: LD_REAL  1.20000000000000E+0000
76317: MUL
76318: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76319: LD_VAR 0 6
76323: PPUSH
76324: CALL_OW 257
76328: PUSH
76329: LD_INT 5
76331: PUSH
76332: LD_INT 7
76334: PUSH
76335: LD_INT 9
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: LIST
76342: IN
76343: PUSH
76344: LD_VAR 0 1
76348: PPUSH
76349: LD_INT 52
76351: PPUSH
76352: CALL_OW 321
76356: PUSH
76357: LD_INT 2
76359: EQUAL
76360: AND
76361: IFFALSE 76378
// bpoints := bpoints * 1.5 ;
76363: LD_ADDR_VAR 0 10
76367: PUSH
76368: LD_VAR 0 10
76372: PUSH
76373: LD_REAL  1.50000000000000E+0000
76376: MUL
76377: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76378: LD_VAR 0 1
76382: PPUSH
76383: LD_INT 66
76385: PPUSH
76386: CALL_OW 321
76390: PUSH
76391: LD_INT 2
76393: EQUAL
76394: IFFALSE 76411
// bpoints := bpoints * 1.1 ;
76396: LD_ADDR_VAR 0 10
76400: PUSH
76401: LD_VAR 0 10
76405: PUSH
76406: LD_REAL  1.10000000000000E+0000
76409: MUL
76410: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76411: LD_ADDR_VAR 0 10
76415: PUSH
76416: LD_VAR 0 10
76420: PUSH
76421: LD_VAR 0 6
76425: PPUSH
76426: LD_INT 1
76428: PPUSH
76429: CALL_OW 259
76433: PUSH
76434: LD_REAL  1.15000000000000E+0000
76437: MUL
76438: MUL
76439: ST_TO_ADDR
// end ; unit_vehicle :
76440: GO 77268
76442: LD_INT 2
76444: DOUBLE
76445: EQUAL
76446: IFTRUE 76450
76448: GO 77256
76450: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76451: LD_VAR 0 6
76455: PPUSH
76456: CALL_OW 264
76460: PUSH
76461: LD_INT 2
76463: PUSH
76464: LD_INT 42
76466: PUSH
76467: LD_INT 24
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: LIST
76474: IN
76475: IFFALSE 76496
// points := [ 25 , 5 , 3 ] ;
76477: LD_ADDR_VAR 0 9
76481: PUSH
76482: LD_INT 25
76484: PUSH
76485: LD_INT 5
76487: PUSH
76488: LD_INT 3
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: LIST
76495: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76496: LD_VAR 0 6
76500: PPUSH
76501: CALL_OW 264
76505: PUSH
76506: LD_INT 4
76508: PUSH
76509: LD_INT 43
76511: PUSH
76512: LD_INT 25
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: LIST
76519: IN
76520: IFFALSE 76541
// points := [ 40 , 15 , 5 ] ;
76522: LD_ADDR_VAR 0 9
76526: PUSH
76527: LD_INT 40
76529: PUSH
76530: LD_INT 15
76532: PUSH
76533: LD_INT 5
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: LIST
76540: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76541: LD_VAR 0 6
76545: PPUSH
76546: CALL_OW 264
76550: PUSH
76551: LD_INT 3
76553: PUSH
76554: LD_INT 23
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: IN
76561: IFFALSE 76582
// points := [ 7 , 25 , 8 ] ;
76563: LD_ADDR_VAR 0 9
76567: PUSH
76568: LD_INT 7
76570: PUSH
76571: LD_INT 25
76573: PUSH
76574: LD_INT 8
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: LIST
76581: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76582: LD_VAR 0 6
76586: PPUSH
76587: CALL_OW 264
76591: PUSH
76592: LD_INT 5
76594: PUSH
76595: LD_INT 27
76597: PUSH
76598: LD_INT 44
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: LIST
76605: IN
76606: IFFALSE 76627
// points := [ 14 , 50 , 16 ] ;
76608: LD_ADDR_VAR 0 9
76612: PUSH
76613: LD_INT 14
76615: PUSH
76616: LD_INT 50
76618: PUSH
76619: LD_INT 16
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: LIST
76626: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76627: LD_VAR 0 6
76631: PPUSH
76632: CALL_OW 264
76636: PUSH
76637: LD_INT 6
76639: PUSH
76640: LD_INT 46
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: IN
76647: IFFALSE 76668
// points := [ 32 , 120 , 70 ] ;
76649: LD_ADDR_VAR 0 9
76653: PUSH
76654: LD_INT 32
76656: PUSH
76657: LD_INT 120
76659: PUSH
76660: LD_INT 70
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: LIST
76667: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76668: LD_VAR 0 6
76672: PPUSH
76673: CALL_OW 264
76677: PUSH
76678: LD_INT 7
76680: PUSH
76681: LD_INT 28
76683: PUSH
76684: LD_INT 45
76686: PUSH
76687: LD_INT 92
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: IN
76696: IFFALSE 76717
// points := [ 35 , 20 , 45 ] ;
76698: LD_ADDR_VAR 0 9
76702: PUSH
76703: LD_INT 35
76705: PUSH
76706: LD_INT 20
76708: PUSH
76709: LD_INT 45
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: LIST
76716: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76717: LD_VAR 0 6
76721: PPUSH
76722: CALL_OW 264
76726: PUSH
76727: LD_INT 47
76729: PUSH
76730: EMPTY
76731: LIST
76732: IN
76733: IFFALSE 76754
// points := [ 67 , 45 , 75 ] ;
76735: LD_ADDR_VAR 0 9
76739: PUSH
76740: LD_INT 67
76742: PUSH
76743: LD_INT 45
76745: PUSH
76746: LD_INT 75
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: LIST
76753: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76754: LD_VAR 0 6
76758: PPUSH
76759: CALL_OW 264
76763: PUSH
76764: LD_INT 26
76766: PUSH
76767: EMPTY
76768: LIST
76769: IN
76770: IFFALSE 76791
// points := [ 120 , 30 , 80 ] ;
76772: LD_ADDR_VAR 0 9
76776: PUSH
76777: LD_INT 120
76779: PUSH
76780: LD_INT 30
76782: PUSH
76783: LD_INT 80
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: LIST
76790: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
76791: LD_VAR 0 6
76795: PPUSH
76796: CALL_OW 264
76800: PUSH
76801: LD_INT 22
76803: PUSH
76804: EMPTY
76805: LIST
76806: IN
76807: IFFALSE 76828
// points := [ 40 , 1 , 1 ] ;
76809: LD_ADDR_VAR 0 9
76813: PUSH
76814: LD_INT 40
76816: PUSH
76817: LD_INT 1
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: LIST
76827: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
76828: LD_VAR 0 6
76832: PPUSH
76833: CALL_OW 264
76837: PUSH
76838: LD_INT 29
76840: PUSH
76841: EMPTY
76842: LIST
76843: IN
76844: IFFALSE 76865
// points := [ 70 , 200 , 400 ] ;
76846: LD_ADDR_VAR 0 9
76850: PUSH
76851: LD_INT 70
76853: PUSH
76854: LD_INT 200
76856: PUSH
76857: LD_INT 400
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: LIST
76864: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
76865: LD_VAR 0 6
76869: PPUSH
76870: CALL_OW 264
76874: PUSH
76875: LD_INT 14
76877: PUSH
76878: LD_INT 53
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: IN
76885: IFFALSE 76906
// points := [ 40 , 10 , 20 ] ;
76887: LD_ADDR_VAR 0 9
76891: PUSH
76892: LD_INT 40
76894: PUSH
76895: LD_INT 10
76897: PUSH
76898: LD_INT 20
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: LIST
76905: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
76906: LD_VAR 0 6
76910: PPUSH
76911: CALL_OW 264
76915: PUSH
76916: LD_INT 9
76918: PUSH
76919: EMPTY
76920: LIST
76921: IN
76922: IFFALSE 76943
// points := [ 5 , 70 , 20 ] ;
76924: LD_ADDR_VAR 0 9
76928: PUSH
76929: LD_INT 5
76931: PUSH
76932: LD_INT 70
76934: PUSH
76935: LD_INT 20
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
76943: LD_VAR 0 6
76947: PPUSH
76948: CALL_OW 264
76952: PUSH
76953: LD_INT 10
76955: PUSH
76956: EMPTY
76957: LIST
76958: IN
76959: IFFALSE 76980
// points := [ 35 , 110 , 70 ] ;
76961: LD_ADDR_VAR 0 9
76965: PUSH
76966: LD_INT 35
76968: PUSH
76969: LD_INT 110
76971: PUSH
76972: LD_INT 70
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: LIST
76979: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
76980: LD_VAR 0 6
76984: PPUSH
76985: CALL_OW 265
76989: PUSH
76990: LD_INT 25
76992: EQUAL
76993: IFFALSE 77014
// points := [ 80 , 65 , 100 ] ;
76995: LD_ADDR_VAR 0 9
76999: PUSH
77000: LD_INT 80
77002: PUSH
77003: LD_INT 65
77005: PUSH
77006: LD_INT 100
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: LIST
77013: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77014: LD_VAR 0 6
77018: PPUSH
77019: CALL_OW 263
77023: PUSH
77024: LD_INT 1
77026: EQUAL
77027: IFFALSE 77062
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77029: LD_ADDR_VAR 0 10
77033: PUSH
77034: LD_VAR 0 10
77038: PUSH
77039: LD_VAR 0 6
77043: PPUSH
77044: CALL_OW 311
77048: PPUSH
77049: LD_INT 3
77051: PPUSH
77052: CALL_OW 259
77056: PUSH
77057: LD_INT 4
77059: MUL
77060: MUL
77061: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77062: LD_VAR 0 6
77066: PPUSH
77067: CALL_OW 263
77071: PUSH
77072: LD_INT 2
77074: EQUAL
77075: IFFALSE 77126
// begin j := IsControledBy ( i ) ;
77077: LD_ADDR_VAR 0 7
77081: PUSH
77082: LD_VAR 0 6
77086: PPUSH
77087: CALL_OW 312
77091: ST_TO_ADDR
// if j then
77092: LD_VAR 0 7
77096: IFFALSE 77126
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77098: LD_ADDR_VAR 0 10
77102: PUSH
77103: LD_VAR 0 10
77107: PUSH
77108: LD_VAR 0 7
77112: PPUSH
77113: LD_INT 3
77115: PPUSH
77116: CALL_OW 259
77120: PUSH
77121: LD_INT 3
77123: MUL
77124: MUL
77125: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77126: LD_VAR 0 6
77130: PPUSH
77131: CALL_OW 264
77135: PUSH
77136: LD_INT 5
77138: PUSH
77139: LD_INT 6
77141: PUSH
77142: LD_INT 46
77144: PUSH
77145: LD_INT 44
77147: PUSH
77148: LD_INT 47
77150: PUSH
77151: LD_INT 45
77153: PUSH
77154: LD_INT 28
77156: PUSH
77157: LD_INT 7
77159: PUSH
77160: LD_INT 27
77162: PUSH
77163: LD_INT 29
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: IN
77178: PUSH
77179: LD_VAR 0 1
77183: PPUSH
77184: LD_INT 52
77186: PPUSH
77187: CALL_OW 321
77191: PUSH
77192: LD_INT 2
77194: EQUAL
77195: AND
77196: IFFALSE 77213
// bpoints := bpoints * 1.2 ;
77198: LD_ADDR_VAR 0 10
77202: PUSH
77203: LD_VAR 0 10
77207: PUSH
77208: LD_REAL  1.20000000000000E+0000
77211: MUL
77212: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77213: LD_VAR 0 6
77217: PPUSH
77218: CALL_OW 264
77222: PUSH
77223: LD_INT 6
77225: PUSH
77226: LD_INT 46
77228: PUSH
77229: LD_INT 47
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: LIST
77236: IN
77237: IFFALSE 77254
// bpoints := bpoints * 1.2 ;
77239: LD_ADDR_VAR 0 10
77243: PUSH
77244: LD_VAR 0 10
77248: PUSH
77249: LD_REAL  1.20000000000000E+0000
77252: MUL
77253: ST_TO_ADDR
// end ; unit_building :
77254: GO 77268
77256: LD_INT 3
77258: DOUBLE
77259: EQUAL
77260: IFTRUE 77264
77262: GO 77267
77264: POP
// ; end ;
77265: GO 77268
77267: POP
// for j = 1 to 3 do
77268: LD_ADDR_VAR 0 7
77272: PUSH
77273: DOUBLE
77274: LD_INT 1
77276: DEC
77277: ST_TO_ADDR
77278: LD_INT 3
77280: PUSH
77281: FOR_TO
77282: IFFALSE 77335
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77284: LD_ADDR_VAR 0 5
77288: PUSH
77289: LD_VAR 0 5
77293: PPUSH
77294: LD_VAR 0 7
77298: PPUSH
77299: LD_VAR 0 5
77303: PUSH
77304: LD_VAR 0 7
77308: ARRAY
77309: PUSH
77310: LD_VAR 0 9
77314: PUSH
77315: LD_VAR 0 7
77319: ARRAY
77320: PUSH
77321: LD_VAR 0 10
77325: MUL
77326: PLUS
77327: PPUSH
77328: CALL_OW 1
77332: ST_TO_ADDR
77333: GO 77281
77335: POP
77336: POP
// end ;
77337: GO 75816
77339: POP
77340: POP
// result := Replace ( result , 4 , tmp ) ;
77341: LD_ADDR_VAR 0 5
77345: PUSH
77346: LD_VAR 0 5
77350: PPUSH
77351: LD_INT 4
77353: PPUSH
77354: LD_VAR 0 8
77358: PPUSH
77359: CALL_OW 1
77363: ST_TO_ADDR
// end ;
77364: LD_VAR 0 5
77368: RET
// export function DangerAtRange ( unit , range ) ; begin
77369: LD_INT 0
77371: PPUSH
// if not unit then
77372: LD_VAR 0 1
77376: NOT
77377: IFFALSE 77381
// exit ;
77379: GO 77426
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77381: LD_ADDR_VAR 0 3
77385: PUSH
77386: LD_VAR 0 1
77390: PPUSH
77391: CALL_OW 255
77395: PPUSH
77396: LD_VAR 0 1
77400: PPUSH
77401: CALL_OW 250
77405: PPUSH
77406: LD_VAR 0 1
77410: PPUSH
77411: CALL_OW 251
77415: PPUSH
77416: LD_VAR 0 2
77420: PPUSH
77421: CALL 75668 0 4
77425: ST_TO_ADDR
// end ;
77426: LD_VAR 0 3
77430: RET
// export function DangerInArea ( side , area ) ; begin
77431: LD_INT 0
77433: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77434: LD_ADDR_VAR 0 3
77438: PUSH
77439: LD_VAR 0 2
77443: PPUSH
77444: LD_INT 81
77446: PUSH
77447: LD_VAR 0 1
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PPUSH
77456: CALL_OW 70
77460: ST_TO_ADDR
// end ;
77461: LD_VAR 0 3
77465: RET
// export function IsExtension ( b ) ; begin
77466: LD_INT 0
77468: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77469: LD_ADDR_VAR 0 2
77473: PUSH
77474: LD_VAR 0 1
77478: PUSH
77479: LD_INT 23
77481: PUSH
77482: LD_INT 20
77484: PUSH
77485: LD_INT 22
77487: PUSH
77488: LD_INT 17
77490: PUSH
77491: LD_INT 24
77493: PUSH
77494: LD_INT 21
77496: PUSH
77497: LD_INT 19
77499: PUSH
77500: LD_INT 16
77502: PUSH
77503: LD_INT 25
77505: PUSH
77506: LD_INT 18
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: IN
77521: ST_TO_ADDR
// end ;
77522: LD_VAR 0 2
77526: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77527: LD_INT 0
77529: PPUSH
77530: PPUSH
77531: PPUSH
// result := [ ] ;
77532: LD_ADDR_VAR 0 4
77536: PUSH
77537: EMPTY
77538: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77539: LD_ADDR_VAR 0 5
77543: PUSH
77544: LD_VAR 0 2
77548: PPUSH
77549: LD_INT 21
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PPUSH
77559: CALL_OW 70
77563: ST_TO_ADDR
// if not tmp then
77564: LD_VAR 0 5
77568: NOT
77569: IFFALSE 77573
// exit ;
77571: GO 77637
// if checkLink then
77573: LD_VAR 0 3
77577: IFFALSE 77627
// begin for i in tmp do
77579: LD_ADDR_VAR 0 6
77583: PUSH
77584: LD_VAR 0 5
77588: PUSH
77589: FOR_IN
77590: IFFALSE 77625
// if GetBase ( i ) <> base then
77592: LD_VAR 0 6
77596: PPUSH
77597: CALL_OW 274
77601: PUSH
77602: LD_VAR 0 1
77606: NONEQUAL
77607: IFFALSE 77623
// ComLinkToBase ( base , i ) ;
77609: LD_VAR 0 1
77613: PPUSH
77614: LD_VAR 0 6
77618: PPUSH
77619: CALL_OW 169
77623: GO 77589
77625: POP
77626: POP
// end ; result := tmp ;
77627: LD_ADDR_VAR 0 4
77631: PUSH
77632: LD_VAR 0 5
77636: ST_TO_ADDR
// end ;
77637: LD_VAR 0 4
77641: RET
// export function ComComplete ( units , b ) ; var i ; begin
77642: LD_INT 0
77644: PPUSH
77645: PPUSH
// if not units then
77646: LD_VAR 0 1
77650: NOT
77651: IFFALSE 77655
// exit ;
77653: GO 77745
// for i in units do
77655: LD_ADDR_VAR 0 4
77659: PUSH
77660: LD_VAR 0 1
77664: PUSH
77665: FOR_IN
77666: IFFALSE 77743
// if BuildingStatus ( b ) = bs_build then
77668: LD_VAR 0 2
77672: PPUSH
77673: CALL_OW 461
77677: PUSH
77678: LD_INT 1
77680: EQUAL
77681: IFFALSE 77741
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77683: LD_VAR 0 4
77687: PPUSH
77688: LD_STRING h
77690: PUSH
77691: LD_VAR 0 2
77695: PPUSH
77696: CALL_OW 250
77700: PUSH
77701: LD_VAR 0 2
77705: PPUSH
77706: CALL_OW 251
77710: PUSH
77711: LD_VAR 0 2
77715: PUSH
77716: LD_INT 0
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: LD_INT 0
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: PUSH
77734: EMPTY
77735: LIST
77736: PPUSH
77737: CALL_OW 446
77741: GO 77665
77743: POP
77744: POP
// end ;
77745: LD_VAR 0 3
77749: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77750: LD_INT 0
77752: PPUSH
77753: PPUSH
77754: PPUSH
77755: PPUSH
77756: PPUSH
77757: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77758: LD_VAR 0 1
77762: NOT
77763: PUSH
77764: LD_VAR 0 1
77768: PPUSH
77769: CALL_OW 263
77773: PUSH
77774: LD_INT 2
77776: NONEQUAL
77777: OR
77778: IFFALSE 77782
// exit ;
77780: GO 78098
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
77782: LD_ADDR_VAR 0 6
77786: PUSH
77787: LD_INT 22
77789: PUSH
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 255
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 2
77806: PUSH
77807: LD_INT 30
77809: PUSH
77810: LD_INT 36
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 34
77819: PUSH
77820: LD_INT 31
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: LIST
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PPUSH
77836: CALL_OW 69
77840: ST_TO_ADDR
// if not tmp then
77841: LD_VAR 0 6
77845: NOT
77846: IFFALSE 77850
// exit ;
77848: GO 78098
// result := [ ] ;
77850: LD_ADDR_VAR 0 2
77854: PUSH
77855: EMPTY
77856: ST_TO_ADDR
// for i in tmp do
77857: LD_ADDR_VAR 0 3
77861: PUSH
77862: LD_VAR 0 6
77866: PUSH
77867: FOR_IN
77868: IFFALSE 77939
// begin t := UnitsInside ( i ) ;
77870: LD_ADDR_VAR 0 4
77874: PUSH
77875: LD_VAR 0 3
77879: PPUSH
77880: CALL_OW 313
77884: ST_TO_ADDR
// if t then
77885: LD_VAR 0 4
77889: IFFALSE 77937
// for j in t do
77891: LD_ADDR_VAR 0 7
77895: PUSH
77896: LD_VAR 0 4
77900: PUSH
77901: FOR_IN
77902: IFFALSE 77935
// result := Replace ( result , result + 1 , j ) ;
77904: LD_ADDR_VAR 0 2
77908: PUSH
77909: LD_VAR 0 2
77913: PPUSH
77914: LD_VAR 0 2
77918: PUSH
77919: LD_INT 1
77921: PLUS
77922: PPUSH
77923: LD_VAR 0 7
77927: PPUSH
77928: CALL_OW 1
77932: ST_TO_ADDR
77933: GO 77901
77935: POP
77936: POP
// end ;
77937: GO 77867
77939: POP
77940: POP
// if not result then
77941: LD_VAR 0 2
77945: NOT
77946: IFFALSE 77950
// exit ;
77948: GO 78098
// mech := result [ 1 ] ;
77950: LD_ADDR_VAR 0 5
77954: PUSH
77955: LD_VAR 0 2
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: ST_TO_ADDR
// if result > 1 then
77964: LD_VAR 0 2
77968: PUSH
77969: LD_INT 1
77971: GREATER
77972: IFFALSE 78084
// begin for i = 2 to result do
77974: LD_ADDR_VAR 0 3
77978: PUSH
77979: DOUBLE
77980: LD_INT 2
77982: DEC
77983: ST_TO_ADDR
77984: LD_VAR 0 2
77988: PUSH
77989: FOR_TO
77990: IFFALSE 78082
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
77992: LD_ADDR_VAR 0 4
77996: PUSH
77997: LD_VAR 0 2
78001: PUSH
78002: LD_VAR 0 3
78006: ARRAY
78007: PPUSH
78008: LD_INT 3
78010: PPUSH
78011: CALL_OW 259
78015: PUSH
78016: LD_VAR 0 2
78020: PUSH
78021: LD_VAR 0 3
78025: ARRAY
78026: PPUSH
78027: CALL_OW 432
78031: MINUS
78032: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78033: LD_VAR 0 4
78037: PUSH
78038: LD_VAR 0 5
78042: PPUSH
78043: LD_INT 3
78045: PPUSH
78046: CALL_OW 259
78050: PUSH
78051: LD_VAR 0 5
78055: PPUSH
78056: CALL_OW 432
78060: MINUS
78061: GREATEREQUAL
78062: IFFALSE 78080
// mech := result [ i ] ;
78064: LD_ADDR_VAR 0 5
78068: PUSH
78069: LD_VAR 0 2
78073: PUSH
78074: LD_VAR 0 3
78078: ARRAY
78079: ST_TO_ADDR
// end ;
78080: GO 77989
78082: POP
78083: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78084: LD_VAR 0 1
78088: PPUSH
78089: LD_VAR 0 5
78093: PPUSH
78094: CALL_OW 135
// end ;
78098: LD_VAR 0 2
78102: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78103: LD_INT 0
78105: PPUSH
78106: PPUSH
78107: PPUSH
78108: PPUSH
78109: PPUSH
78110: PPUSH
78111: PPUSH
78112: PPUSH
78113: PPUSH
78114: PPUSH
78115: PPUSH
78116: PPUSH
78117: PPUSH
// result := [ ] ;
78118: LD_ADDR_VAR 0 7
78122: PUSH
78123: EMPTY
78124: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78125: LD_VAR 0 1
78129: PPUSH
78130: CALL_OW 266
78134: PUSH
78135: LD_INT 0
78137: PUSH
78138: LD_INT 1
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: IN
78145: NOT
78146: IFFALSE 78150
// exit ;
78148: GO 79784
// if name then
78150: LD_VAR 0 3
78154: IFFALSE 78170
// SetBName ( base_dep , name ) ;
78156: LD_VAR 0 1
78160: PPUSH
78161: LD_VAR 0 3
78165: PPUSH
78166: CALL_OW 500
// base := GetBase ( base_dep ) ;
78170: LD_ADDR_VAR 0 15
78174: PUSH
78175: LD_VAR 0 1
78179: PPUSH
78180: CALL_OW 274
78184: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78185: LD_ADDR_VAR 0 16
78189: PUSH
78190: LD_VAR 0 1
78194: PPUSH
78195: CALL_OW 255
78199: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78200: LD_ADDR_VAR 0 17
78204: PUSH
78205: LD_VAR 0 1
78209: PPUSH
78210: CALL_OW 248
78214: ST_TO_ADDR
// if sources then
78215: LD_VAR 0 5
78219: IFFALSE 78266
// for i = 1 to 3 do
78221: LD_ADDR_VAR 0 8
78225: PUSH
78226: DOUBLE
78227: LD_INT 1
78229: DEC
78230: ST_TO_ADDR
78231: LD_INT 3
78233: PUSH
78234: FOR_TO
78235: IFFALSE 78264
// AddResourceType ( base , i , sources [ i ] ) ;
78237: LD_VAR 0 15
78241: PPUSH
78242: LD_VAR 0 8
78246: PPUSH
78247: LD_VAR 0 5
78251: PUSH
78252: LD_VAR 0 8
78256: ARRAY
78257: PPUSH
78258: CALL_OW 276
78262: GO 78234
78264: POP
78265: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78266: LD_ADDR_VAR 0 18
78270: PUSH
78271: LD_VAR 0 15
78275: PPUSH
78276: LD_VAR 0 2
78280: PPUSH
78281: LD_INT 1
78283: PPUSH
78284: CALL 77527 0 3
78288: ST_TO_ADDR
// InitHc ;
78289: CALL_OW 19
// InitUc ;
78293: CALL_OW 18
// uc_side := side ;
78297: LD_ADDR_OWVAR 20
78301: PUSH
78302: LD_VAR 0 16
78306: ST_TO_ADDR
// uc_nation := nation ;
78307: LD_ADDR_OWVAR 21
78311: PUSH
78312: LD_VAR 0 17
78316: ST_TO_ADDR
// if buildings then
78317: LD_VAR 0 18
78321: IFFALSE 79643
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78323: LD_ADDR_VAR 0 19
78327: PUSH
78328: LD_VAR 0 18
78332: PPUSH
78333: LD_INT 2
78335: PUSH
78336: LD_INT 30
78338: PUSH
78339: LD_INT 29
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: LD_INT 30
78348: PUSH
78349: LD_INT 30
78351: PUSH
78352: EMPTY
78353: LIST
78354: LIST
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: LIST
78360: PPUSH
78361: CALL_OW 72
78365: ST_TO_ADDR
// if tmp then
78366: LD_VAR 0 19
78370: IFFALSE 78418
// for i in tmp do
78372: LD_ADDR_VAR 0 8
78376: PUSH
78377: LD_VAR 0 19
78381: PUSH
78382: FOR_IN
78383: IFFALSE 78416
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78385: LD_VAR 0 8
78389: PPUSH
78390: CALL_OW 250
78394: PPUSH
78395: LD_VAR 0 8
78399: PPUSH
78400: CALL_OW 251
78404: PPUSH
78405: LD_VAR 0 16
78409: PPUSH
78410: CALL_OW 441
78414: GO 78382
78416: POP
78417: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78418: LD_VAR 0 18
78422: PPUSH
78423: LD_INT 2
78425: PUSH
78426: LD_INT 30
78428: PUSH
78429: LD_INT 32
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 30
78438: PUSH
78439: LD_INT 33
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: LIST
78450: PPUSH
78451: CALL_OW 72
78455: IFFALSE 78543
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78457: LD_ADDR_VAR 0 8
78461: PUSH
78462: LD_VAR 0 18
78466: PPUSH
78467: LD_INT 2
78469: PUSH
78470: LD_INT 30
78472: PUSH
78473: LD_INT 32
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 30
78482: PUSH
78483: LD_INT 33
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: LIST
78494: PPUSH
78495: CALL_OW 72
78499: PUSH
78500: FOR_IN
78501: IFFALSE 78541
// begin if not GetBWeapon ( i ) then
78503: LD_VAR 0 8
78507: PPUSH
78508: CALL_OW 269
78512: NOT
78513: IFFALSE 78539
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78515: LD_VAR 0 8
78519: PPUSH
78520: LD_VAR 0 8
78524: PPUSH
78525: LD_VAR 0 2
78529: PPUSH
78530: CALL 79789 0 2
78534: PPUSH
78535: CALL_OW 431
// end ;
78539: GO 78500
78541: POP
78542: POP
// end ; for i = 1 to personel do
78543: LD_ADDR_VAR 0 8
78547: PUSH
78548: DOUBLE
78549: LD_INT 1
78551: DEC
78552: ST_TO_ADDR
78553: LD_VAR 0 6
78557: PUSH
78558: FOR_TO
78559: IFFALSE 79623
// begin if i > 4 then
78561: LD_VAR 0 8
78565: PUSH
78566: LD_INT 4
78568: GREATER
78569: IFFALSE 78573
// break ;
78571: GO 79623
// case i of 1 :
78573: LD_VAR 0 8
78577: PUSH
78578: LD_INT 1
78580: DOUBLE
78581: EQUAL
78582: IFTRUE 78586
78584: GO 78666
78586: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78587: LD_ADDR_VAR 0 12
78591: PUSH
78592: LD_VAR 0 18
78596: PPUSH
78597: LD_INT 22
78599: PUSH
78600: LD_VAR 0 16
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 58
78611: PUSH
78612: EMPTY
78613: LIST
78614: PUSH
78615: LD_INT 2
78617: PUSH
78618: LD_INT 30
78620: PUSH
78621: LD_INT 32
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 30
78630: PUSH
78631: LD_INT 4
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 30
78640: PUSH
78641: LD_INT 5
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: LIST
78652: LIST
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: LIST
78658: PPUSH
78659: CALL_OW 72
78663: ST_TO_ADDR
78664: GO 78888
78666: LD_INT 2
78668: DOUBLE
78669: EQUAL
78670: IFTRUE 78674
78672: GO 78736
78674: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78675: LD_ADDR_VAR 0 12
78679: PUSH
78680: LD_VAR 0 18
78684: PPUSH
78685: LD_INT 22
78687: PUSH
78688: LD_VAR 0 16
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 2
78699: PUSH
78700: LD_INT 30
78702: PUSH
78703: LD_INT 0
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 30
78712: PUSH
78713: LD_INT 1
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: LIST
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PPUSH
78729: CALL_OW 72
78733: ST_TO_ADDR
78734: GO 78888
78736: LD_INT 3
78738: DOUBLE
78739: EQUAL
78740: IFTRUE 78744
78742: GO 78806
78744: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78745: LD_ADDR_VAR 0 12
78749: PUSH
78750: LD_VAR 0 18
78754: PPUSH
78755: LD_INT 22
78757: PUSH
78758: LD_VAR 0 16
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 2
78769: PUSH
78770: LD_INT 30
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 30
78782: PUSH
78783: LD_INT 3
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: LIST
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PPUSH
78799: CALL_OW 72
78803: ST_TO_ADDR
78804: GO 78888
78806: LD_INT 4
78808: DOUBLE
78809: EQUAL
78810: IFTRUE 78814
78812: GO 78887
78814: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
78815: LD_ADDR_VAR 0 12
78819: PUSH
78820: LD_VAR 0 18
78824: PPUSH
78825: LD_INT 22
78827: PUSH
78828: LD_VAR 0 16
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 2
78839: PUSH
78840: LD_INT 30
78842: PUSH
78843: LD_INT 6
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 30
78852: PUSH
78853: LD_INT 7
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 30
78862: PUSH
78863: LD_INT 8
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PPUSH
78880: CALL_OW 72
78884: ST_TO_ADDR
78885: GO 78888
78887: POP
// if i = 1 then
78888: LD_VAR 0 8
78892: PUSH
78893: LD_INT 1
78895: EQUAL
78896: IFFALSE 79007
// begin tmp := [ ] ;
78898: LD_ADDR_VAR 0 19
78902: PUSH
78903: EMPTY
78904: ST_TO_ADDR
// for j in f do
78905: LD_ADDR_VAR 0 9
78909: PUSH
78910: LD_VAR 0 12
78914: PUSH
78915: FOR_IN
78916: IFFALSE 78989
// if GetBType ( j ) = b_bunker then
78918: LD_VAR 0 9
78922: PPUSH
78923: CALL_OW 266
78927: PUSH
78928: LD_INT 32
78930: EQUAL
78931: IFFALSE 78958
// tmp := Insert ( tmp , 1 , j ) else
78933: LD_ADDR_VAR 0 19
78937: PUSH
78938: LD_VAR 0 19
78942: PPUSH
78943: LD_INT 1
78945: PPUSH
78946: LD_VAR 0 9
78950: PPUSH
78951: CALL_OW 2
78955: ST_TO_ADDR
78956: GO 78987
// tmp := Insert ( tmp , tmp + 1 , j ) ;
78958: LD_ADDR_VAR 0 19
78962: PUSH
78963: LD_VAR 0 19
78967: PPUSH
78968: LD_VAR 0 19
78972: PUSH
78973: LD_INT 1
78975: PLUS
78976: PPUSH
78977: LD_VAR 0 9
78981: PPUSH
78982: CALL_OW 2
78986: ST_TO_ADDR
78987: GO 78915
78989: POP
78990: POP
// if tmp then
78991: LD_VAR 0 19
78995: IFFALSE 79007
// f := tmp ;
78997: LD_ADDR_VAR 0 12
79001: PUSH
79002: LD_VAR 0 19
79006: ST_TO_ADDR
// end ; x := personel [ i ] ;
79007: LD_ADDR_VAR 0 13
79011: PUSH
79012: LD_VAR 0 6
79016: PUSH
79017: LD_VAR 0 8
79021: ARRAY
79022: ST_TO_ADDR
// if x = - 1 then
79023: LD_VAR 0 13
79027: PUSH
79028: LD_INT 1
79030: NEG
79031: EQUAL
79032: IFFALSE 79241
// begin for j in f do
79034: LD_ADDR_VAR 0 9
79038: PUSH
79039: LD_VAR 0 12
79043: PUSH
79044: FOR_IN
79045: IFFALSE 79237
// repeat InitHc ;
79047: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79051: LD_VAR 0 9
79055: PPUSH
79056: CALL_OW 266
79060: PUSH
79061: LD_INT 5
79063: EQUAL
79064: IFFALSE 79134
// begin if UnitsInside ( j ) < 3 then
79066: LD_VAR 0 9
79070: PPUSH
79071: CALL_OW 313
79075: PUSH
79076: LD_INT 3
79078: LESS
79079: IFFALSE 79115
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79081: LD_INT 0
79083: PPUSH
79084: LD_INT 5
79086: PUSH
79087: LD_INT 8
79089: PUSH
79090: LD_INT 9
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: LIST
79097: PUSH
79098: LD_VAR 0 17
79102: ARRAY
79103: PPUSH
79104: LD_VAR 0 4
79108: PPUSH
79109: CALL_OW 380
79113: GO 79132
// PrepareHuman ( false , i , skill ) ;
79115: LD_INT 0
79117: PPUSH
79118: LD_VAR 0 8
79122: PPUSH
79123: LD_VAR 0 4
79127: PPUSH
79128: CALL_OW 380
// end else
79132: GO 79151
// PrepareHuman ( false , i , skill ) ;
79134: LD_INT 0
79136: PPUSH
79137: LD_VAR 0 8
79141: PPUSH
79142: LD_VAR 0 4
79146: PPUSH
79147: CALL_OW 380
// un := CreateHuman ;
79151: LD_ADDR_VAR 0 14
79155: PUSH
79156: CALL_OW 44
79160: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79161: LD_ADDR_VAR 0 7
79165: PUSH
79166: LD_VAR 0 7
79170: PPUSH
79171: LD_INT 1
79173: PPUSH
79174: LD_VAR 0 14
79178: PPUSH
79179: CALL_OW 2
79183: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79184: LD_VAR 0 14
79188: PPUSH
79189: LD_VAR 0 9
79193: PPUSH
79194: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79198: LD_VAR 0 9
79202: PPUSH
79203: CALL_OW 313
79207: PUSH
79208: LD_INT 6
79210: EQUAL
79211: PUSH
79212: LD_VAR 0 9
79216: PPUSH
79217: CALL_OW 266
79221: PUSH
79222: LD_INT 32
79224: PUSH
79225: LD_INT 31
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: IN
79232: OR
79233: IFFALSE 79047
79235: GO 79044
79237: POP
79238: POP
// end else
79239: GO 79621
// for j = 1 to x do
79241: LD_ADDR_VAR 0 9
79245: PUSH
79246: DOUBLE
79247: LD_INT 1
79249: DEC
79250: ST_TO_ADDR
79251: LD_VAR 0 13
79255: PUSH
79256: FOR_TO
79257: IFFALSE 79619
// begin InitHc ;
79259: CALL_OW 19
// if not f then
79263: LD_VAR 0 12
79267: NOT
79268: IFFALSE 79357
// begin PrepareHuman ( false , i , skill ) ;
79270: LD_INT 0
79272: PPUSH
79273: LD_VAR 0 8
79277: PPUSH
79278: LD_VAR 0 4
79282: PPUSH
79283: CALL_OW 380
// un := CreateHuman ;
79287: LD_ADDR_VAR 0 14
79291: PUSH
79292: CALL_OW 44
79296: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79297: LD_ADDR_VAR 0 7
79301: PUSH
79302: LD_VAR 0 7
79306: PPUSH
79307: LD_INT 1
79309: PPUSH
79310: LD_VAR 0 14
79314: PPUSH
79315: CALL_OW 2
79319: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79320: LD_VAR 0 14
79324: PPUSH
79325: LD_VAR 0 1
79329: PPUSH
79330: CALL_OW 250
79334: PPUSH
79335: LD_VAR 0 1
79339: PPUSH
79340: CALL_OW 251
79344: PPUSH
79345: LD_INT 10
79347: PPUSH
79348: LD_INT 0
79350: PPUSH
79351: CALL_OW 50
// continue ;
79355: GO 79256
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79357: LD_VAR 0 12
79361: PUSH
79362: LD_INT 1
79364: ARRAY
79365: PPUSH
79366: CALL_OW 313
79370: PUSH
79371: LD_VAR 0 12
79375: PUSH
79376: LD_INT 1
79378: ARRAY
79379: PPUSH
79380: CALL_OW 266
79384: PUSH
79385: LD_INT 32
79387: PUSH
79388: LD_INT 31
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: IN
79395: AND
79396: PUSH
79397: LD_VAR 0 12
79401: PUSH
79402: LD_INT 1
79404: ARRAY
79405: PPUSH
79406: CALL_OW 313
79410: PUSH
79411: LD_INT 6
79413: EQUAL
79414: OR
79415: IFFALSE 79435
// f := Delete ( f , 1 ) ;
79417: LD_ADDR_VAR 0 12
79421: PUSH
79422: LD_VAR 0 12
79426: PPUSH
79427: LD_INT 1
79429: PPUSH
79430: CALL_OW 3
79434: ST_TO_ADDR
// if not f then
79435: LD_VAR 0 12
79439: NOT
79440: IFFALSE 79458
// begin x := x + 2 ;
79442: LD_ADDR_VAR 0 13
79446: PUSH
79447: LD_VAR 0 13
79451: PUSH
79452: LD_INT 2
79454: PLUS
79455: ST_TO_ADDR
// continue ;
79456: GO 79256
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79458: LD_VAR 0 12
79462: PUSH
79463: LD_INT 1
79465: ARRAY
79466: PPUSH
79467: CALL_OW 266
79471: PUSH
79472: LD_INT 5
79474: EQUAL
79475: IFFALSE 79549
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79477: LD_VAR 0 12
79481: PUSH
79482: LD_INT 1
79484: ARRAY
79485: PPUSH
79486: CALL_OW 313
79490: PUSH
79491: LD_INT 3
79493: LESS
79494: IFFALSE 79530
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79496: LD_INT 0
79498: PPUSH
79499: LD_INT 5
79501: PUSH
79502: LD_INT 8
79504: PUSH
79505: LD_INT 9
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: LIST
79512: PUSH
79513: LD_VAR 0 17
79517: ARRAY
79518: PPUSH
79519: LD_VAR 0 4
79523: PPUSH
79524: CALL_OW 380
79528: GO 79547
// PrepareHuman ( false , i , skill ) ;
79530: LD_INT 0
79532: PPUSH
79533: LD_VAR 0 8
79537: PPUSH
79538: LD_VAR 0 4
79542: PPUSH
79543: CALL_OW 380
// end else
79547: GO 79566
// PrepareHuman ( false , i , skill ) ;
79549: LD_INT 0
79551: PPUSH
79552: LD_VAR 0 8
79556: PPUSH
79557: LD_VAR 0 4
79561: PPUSH
79562: CALL_OW 380
// un := CreateHuman ;
79566: LD_ADDR_VAR 0 14
79570: PUSH
79571: CALL_OW 44
79575: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79576: LD_ADDR_VAR 0 7
79580: PUSH
79581: LD_VAR 0 7
79585: PPUSH
79586: LD_INT 1
79588: PPUSH
79589: LD_VAR 0 14
79593: PPUSH
79594: CALL_OW 2
79598: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79599: LD_VAR 0 14
79603: PPUSH
79604: LD_VAR 0 12
79608: PUSH
79609: LD_INT 1
79611: ARRAY
79612: PPUSH
79613: CALL_OW 52
// end ;
79617: GO 79256
79619: POP
79620: POP
// end ;
79621: GO 78558
79623: POP
79624: POP
// result := result ^ buildings ;
79625: LD_ADDR_VAR 0 7
79629: PUSH
79630: LD_VAR 0 7
79634: PUSH
79635: LD_VAR 0 18
79639: ADD
79640: ST_TO_ADDR
// end else
79641: GO 79784
// begin for i = 1 to personel do
79643: LD_ADDR_VAR 0 8
79647: PUSH
79648: DOUBLE
79649: LD_INT 1
79651: DEC
79652: ST_TO_ADDR
79653: LD_VAR 0 6
79657: PUSH
79658: FOR_TO
79659: IFFALSE 79782
// begin if i > 4 then
79661: LD_VAR 0 8
79665: PUSH
79666: LD_INT 4
79668: GREATER
79669: IFFALSE 79673
// break ;
79671: GO 79782
// x := personel [ i ] ;
79673: LD_ADDR_VAR 0 13
79677: PUSH
79678: LD_VAR 0 6
79682: PUSH
79683: LD_VAR 0 8
79687: ARRAY
79688: ST_TO_ADDR
// if x = - 1 then
79689: LD_VAR 0 13
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: EQUAL
79698: IFFALSE 79702
// continue ;
79700: GO 79658
// PrepareHuman ( false , i , skill ) ;
79702: LD_INT 0
79704: PPUSH
79705: LD_VAR 0 8
79709: PPUSH
79710: LD_VAR 0 4
79714: PPUSH
79715: CALL_OW 380
// un := CreateHuman ;
79719: LD_ADDR_VAR 0 14
79723: PUSH
79724: CALL_OW 44
79728: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79729: LD_VAR 0 14
79733: PPUSH
79734: LD_VAR 0 1
79738: PPUSH
79739: CALL_OW 250
79743: PPUSH
79744: LD_VAR 0 1
79748: PPUSH
79749: CALL_OW 251
79753: PPUSH
79754: LD_INT 10
79756: PPUSH
79757: LD_INT 0
79759: PPUSH
79760: CALL_OW 50
// result := result ^ un ;
79764: LD_ADDR_VAR 0 7
79768: PUSH
79769: LD_VAR 0 7
79773: PUSH
79774: LD_VAR 0 14
79778: ADD
79779: ST_TO_ADDR
// end ;
79780: GO 79658
79782: POP
79783: POP
// end ; end ;
79784: LD_VAR 0 7
79788: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
79789: LD_INT 0
79791: PPUSH
79792: PPUSH
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
79805: PPUSH
79806: PPUSH
// result := false ;
79807: LD_ADDR_VAR 0 3
79811: PUSH
79812: LD_INT 0
79814: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
79815: LD_VAR 0 1
79819: NOT
79820: PUSH
79821: LD_VAR 0 1
79825: PPUSH
79826: CALL_OW 266
79830: PUSH
79831: LD_INT 32
79833: PUSH
79834: LD_INT 33
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: IN
79841: NOT
79842: OR
79843: IFFALSE 79847
// exit ;
79845: GO 80956
// nat := GetNation ( tower ) ;
79847: LD_ADDR_VAR 0 12
79851: PUSH
79852: LD_VAR 0 1
79856: PPUSH
79857: CALL_OW 248
79861: ST_TO_ADDR
// side := GetSide ( tower ) ;
79862: LD_ADDR_VAR 0 16
79866: PUSH
79867: LD_VAR 0 1
79871: PPUSH
79872: CALL_OW 255
79876: ST_TO_ADDR
// x := GetX ( tower ) ;
79877: LD_ADDR_VAR 0 10
79881: PUSH
79882: LD_VAR 0 1
79886: PPUSH
79887: CALL_OW 250
79891: ST_TO_ADDR
// y := GetY ( tower ) ;
79892: LD_ADDR_VAR 0 11
79896: PUSH
79897: LD_VAR 0 1
79901: PPUSH
79902: CALL_OW 251
79906: ST_TO_ADDR
// if not x or not y then
79907: LD_VAR 0 10
79911: NOT
79912: PUSH
79913: LD_VAR 0 11
79917: NOT
79918: OR
79919: IFFALSE 79923
// exit ;
79921: GO 80956
// weapon := 0 ;
79923: LD_ADDR_VAR 0 18
79927: PUSH
79928: LD_INT 0
79930: ST_TO_ADDR
// fac_list := [ ] ;
79931: LD_ADDR_VAR 0 17
79935: PUSH
79936: EMPTY
79937: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
79938: LD_ADDR_VAR 0 6
79942: PUSH
79943: LD_VAR 0 1
79947: PPUSH
79948: CALL_OW 274
79952: PPUSH
79953: LD_VAR 0 2
79957: PPUSH
79958: LD_INT 0
79960: PPUSH
79961: CALL 77527 0 3
79965: PPUSH
79966: LD_INT 30
79968: PUSH
79969: LD_INT 3
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PPUSH
79976: CALL_OW 72
79980: ST_TO_ADDR
// if not factories then
79981: LD_VAR 0 6
79985: NOT
79986: IFFALSE 79990
// exit ;
79988: GO 80956
// for i in factories do
79990: LD_ADDR_VAR 0 8
79994: PUSH
79995: LD_VAR 0 6
79999: PUSH
80000: FOR_IN
80001: IFFALSE 80026
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80003: LD_ADDR_VAR 0 17
80007: PUSH
80008: LD_VAR 0 17
80012: PUSH
80013: LD_VAR 0 8
80017: PPUSH
80018: CALL_OW 478
80022: UNION
80023: ST_TO_ADDR
80024: GO 80000
80026: POP
80027: POP
// if not fac_list then
80028: LD_VAR 0 17
80032: NOT
80033: IFFALSE 80037
// exit ;
80035: GO 80956
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80037: LD_ADDR_VAR 0 5
80041: PUSH
80042: LD_INT 4
80044: PUSH
80045: LD_INT 5
80047: PUSH
80048: LD_INT 9
80050: PUSH
80051: LD_INT 10
80053: PUSH
80054: LD_INT 6
80056: PUSH
80057: LD_INT 7
80059: PUSH
80060: LD_INT 11
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 27
80074: PUSH
80075: LD_INT 28
80077: PUSH
80078: LD_INT 26
80080: PUSH
80081: LD_INT 30
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 43
80092: PUSH
80093: LD_INT 44
80095: PUSH
80096: LD_INT 46
80098: PUSH
80099: LD_INT 45
80101: PUSH
80102: LD_INT 47
80104: PUSH
80105: LD_INT 49
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: LIST
80120: PUSH
80121: LD_VAR 0 12
80125: ARRAY
80126: ST_TO_ADDR
// list := list isect fac_list ;
80127: LD_ADDR_VAR 0 5
80131: PUSH
80132: LD_VAR 0 5
80136: PUSH
80137: LD_VAR 0 17
80141: ISECT
80142: ST_TO_ADDR
// if not list then
80143: LD_VAR 0 5
80147: NOT
80148: IFFALSE 80152
// exit ;
80150: GO 80956
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80152: LD_VAR 0 12
80156: PUSH
80157: LD_INT 3
80159: EQUAL
80160: PUSH
80161: LD_INT 49
80163: PUSH
80164: LD_VAR 0 5
80168: IN
80169: AND
80170: PUSH
80171: LD_INT 31
80173: PPUSH
80174: LD_VAR 0 16
80178: PPUSH
80179: CALL_OW 321
80183: PUSH
80184: LD_INT 2
80186: EQUAL
80187: AND
80188: IFFALSE 80248
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80190: LD_INT 22
80192: PUSH
80193: LD_VAR 0 16
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 35
80204: PUSH
80205: LD_INT 49
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 91
80214: PUSH
80215: LD_VAR 0 1
80219: PUSH
80220: LD_INT 10
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: LIST
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: LIST
80232: PPUSH
80233: CALL_OW 69
80237: NOT
80238: IFFALSE 80248
// weapon := ru_time_lapser ;
80240: LD_ADDR_VAR 0 18
80244: PUSH
80245: LD_INT 49
80247: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80248: LD_VAR 0 12
80252: PUSH
80253: LD_INT 1
80255: PUSH
80256: LD_INT 2
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: IN
80263: PUSH
80264: LD_INT 11
80266: PUSH
80267: LD_VAR 0 5
80271: IN
80272: PUSH
80273: LD_INT 30
80275: PUSH
80276: LD_VAR 0 5
80280: IN
80281: OR
80282: AND
80283: PUSH
80284: LD_INT 6
80286: PPUSH
80287: LD_VAR 0 16
80291: PPUSH
80292: CALL_OW 321
80296: PUSH
80297: LD_INT 2
80299: EQUAL
80300: AND
80301: IFFALSE 80466
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80303: LD_INT 22
80305: PUSH
80306: LD_VAR 0 16
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 2
80317: PUSH
80318: LD_INT 35
80320: PUSH
80321: LD_INT 11
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 35
80330: PUSH
80331: LD_INT 30
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 91
80345: PUSH
80346: LD_VAR 0 1
80350: PUSH
80351: LD_INT 18
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: LIST
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: LIST
80363: PPUSH
80364: CALL_OW 69
80368: NOT
80369: PUSH
80370: LD_INT 22
80372: PUSH
80373: LD_VAR 0 16
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 2
80384: PUSH
80385: LD_INT 30
80387: PUSH
80388: LD_INT 32
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 30
80397: PUSH
80398: LD_INT 33
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 91
80412: PUSH
80413: LD_VAR 0 1
80417: PUSH
80418: LD_INT 12
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: LIST
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: LIST
80430: PUSH
80431: EMPTY
80432: LIST
80433: PPUSH
80434: CALL_OW 69
80438: PUSH
80439: LD_INT 2
80441: GREATER
80442: AND
80443: IFFALSE 80466
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80445: LD_ADDR_VAR 0 18
80449: PUSH
80450: LD_INT 11
80452: PUSH
80453: LD_INT 30
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_VAR 0 12
80464: ARRAY
80465: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80466: LD_VAR 0 18
80470: NOT
80471: PUSH
80472: LD_INT 40
80474: PPUSH
80475: LD_VAR 0 16
80479: PPUSH
80480: CALL_OW 321
80484: PUSH
80485: LD_INT 2
80487: EQUAL
80488: AND
80489: PUSH
80490: LD_INT 7
80492: PUSH
80493: LD_VAR 0 5
80497: IN
80498: PUSH
80499: LD_INT 28
80501: PUSH
80502: LD_VAR 0 5
80506: IN
80507: OR
80508: PUSH
80509: LD_INT 45
80511: PUSH
80512: LD_VAR 0 5
80516: IN
80517: OR
80518: AND
80519: IFFALSE 80773
// begin hex := GetHexInfo ( x , y ) ;
80521: LD_ADDR_VAR 0 4
80525: PUSH
80526: LD_VAR 0 10
80530: PPUSH
80531: LD_VAR 0 11
80535: PPUSH
80536: CALL_OW 546
80540: ST_TO_ADDR
// if hex [ 1 ] then
80541: LD_VAR 0 4
80545: PUSH
80546: LD_INT 1
80548: ARRAY
80549: IFFALSE 80553
// exit ;
80551: GO 80956
// height := hex [ 2 ] ;
80553: LD_ADDR_VAR 0 15
80557: PUSH
80558: LD_VAR 0 4
80562: PUSH
80563: LD_INT 2
80565: ARRAY
80566: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80567: LD_ADDR_VAR 0 14
80571: PUSH
80572: LD_INT 0
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: LD_INT 3
80580: PUSH
80581: LD_INT 5
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: ST_TO_ADDR
// for i in tmp do
80590: LD_ADDR_VAR 0 8
80594: PUSH
80595: LD_VAR 0 14
80599: PUSH
80600: FOR_IN
80601: IFFALSE 80771
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80603: LD_ADDR_VAR 0 9
80607: PUSH
80608: LD_VAR 0 10
80612: PPUSH
80613: LD_VAR 0 8
80617: PPUSH
80618: LD_INT 5
80620: PPUSH
80621: CALL_OW 272
80625: PUSH
80626: LD_VAR 0 11
80630: PPUSH
80631: LD_VAR 0 8
80635: PPUSH
80636: LD_INT 5
80638: PPUSH
80639: CALL_OW 273
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80648: LD_VAR 0 9
80652: PUSH
80653: LD_INT 1
80655: ARRAY
80656: PPUSH
80657: LD_VAR 0 9
80661: PUSH
80662: LD_INT 2
80664: ARRAY
80665: PPUSH
80666: CALL_OW 488
80670: IFFALSE 80769
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80672: LD_ADDR_VAR 0 4
80676: PUSH
80677: LD_VAR 0 9
80681: PUSH
80682: LD_INT 1
80684: ARRAY
80685: PPUSH
80686: LD_VAR 0 9
80690: PUSH
80691: LD_INT 2
80693: ARRAY
80694: PPUSH
80695: CALL_OW 546
80699: ST_TO_ADDR
// if hex [ 1 ] then
80700: LD_VAR 0 4
80704: PUSH
80705: LD_INT 1
80707: ARRAY
80708: IFFALSE 80712
// continue ;
80710: GO 80600
// h := hex [ 2 ] ;
80712: LD_ADDR_VAR 0 13
80716: PUSH
80717: LD_VAR 0 4
80721: PUSH
80722: LD_INT 2
80724: ARRAY
80725: ST_TO_ADDR
// if h + 7 < height then
80726: LD_VAR 0 13
80730: PUSH
80731: LD_INT 7
80733: PLUS
80734: PUSH
80735: LD_VAR 0 15
80739: LESS
80740: IFFALSE 80769
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80742: LD_ADDR_VAR 0 18
80746: PUSH
80747: LD_INT 7
80749: PUSH
80750: LD_INT 28
80752: PUSH
80753: LD_INT 45
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: LIST
80760: PUSH
80761: LD_VAR 0 12
80765: ARRAY
80766: ST_TO_ADDR
// break ;
80767: GO 80771
// end ; end ; end ;
80769: GO 80600
80771: POP
80772: POP
// end ; if not weapon then
80773: LD_VAR 0 18
80777: NOT
80778: IFFALSE 80838
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
80780: LD_ADDR_VAR 0 5
80784: PUSH
80785: LD_VAR 0 5
80789: PUSH
80790: LD_INT 11
80792: PUSH
80793: LD_INT 30
80795: PUSH
80796: LD_INT 49
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: LIST
80803: DIFF
80804: ST_TO_ADDR
// if not list then
80805: LD_VAR 0 5
80809: NOT
80810: IFFALSE 80814
// exit ;
80812: GO 80956
// weapon := list [ rand ( 1 , list ) ] ;
80814: LD_ADDR_VAR 0 18
80818: PUSH
80819: LD_VAR 0 5
80823: PUSH
80824: LD_INT 1
80826: PPUSH
80827: LD_VAR 0 5
80831: PPUSH
80832: CALL_OW 12
80836: ARRAY
80837: ST_TO_ADDR
// end ; if weapon then
80838: LD_VAR 0 18
80842: IFFALSE 80956
// begin tmp := CostOfWeapon ( weapon ) ;
80844: LD_ADDR_VAR 0 14
80848: PUSH
80849: LD_VAR 0 18
80853: PPUSH
80854: CALL_OW 451
80858: ST_TO_ADDR
// j := GetBase ( tower ) ;
80859: LD_ADDR_VAR 0 9
80863: PUSH
80864: LD_VAR 0 1
80868: PPUSH
80869: CALL_OW 274
80873: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
80874: LD_VAR 0 9
80878: PPUSH
80879: LD_INT 1
80881: PPUSH
80882: CALL_OW 275
80886: PUSH
80887: LD_VAR 0 14
80891: PUSH
80892: LD_INT 1
80894: ARRAY
80895: GREATEREQUAL
80896: PUSH
80897: LD_VAR 0 9
80901: PPUSH
80902: LD_INT 2
80904: PPUSH
80905: CALL_OW 275
80909: PUSH
80910: LD_VAR 0 14
80914: PUSH
80915: LD_INT 2
80917: ARRAY
80918: GREATEREQUAL
80919: AND
80920: PUSH
80921: LD_VAR 0 9
80925: PPUSH
80926: LD_INT 3
80928: PPUSH
80929: CALL_OW 275
80933: PUSH
80934: LD_VAR 0 14
80938: PUSH
80939: LD_INT 3
80941: ARRAY
80942: GREATEREQUAL
80943: AND
80944: IFFALSE 80956
// result := weapon ;
80946: LD_ADDR_VAR 0 3
80950: PUSH
80951: LD_VAR 0 18
80955: ST_TO_ADDR
// end ; end ;
80956: LD_VAR 0 3
80960: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
80961: LD_INT 0
80963: PPUSH
80964: PPUSH
// result := true ;
80965: LD_ADDR_VAR 0 3
80969: PUSH
80970: LD_INT 1
80972: ST_TO_ADDR
// if array1 = array2 then
80973: LD_VAR 0 1
80977: PUSH
80978: LD_VAR 0 2
80982: EQUAL
80983: IFFALSE 81043
// begin for i = 1 to array1 do
80985: LD_ADDR_VAR 0 4
80989: PUSH
80990: DOUBLE
80991: LD_INT 1
80993: DEC
80994: ST_TO_ADDR
80995: LD_VAR 0 1
80999: PUSH
81000: FOR_TO
81001: IFFALSE 81039
// if array1 [ i ] <> array2 [ i ] then
81003: LD_VAR 0 1
81007: PUSH
81008: LD_VAR 0 4
81012: ARRAY
81013: PUSH
81014: LD_VAR 0 2
81018: PUSH
81019: LD_VAR 0 4
81023: ARRAY
81024: NONEQUAL
81025: IFFALSE 81037
// begin result := false ;
81027: LD_ADDR_VAR 0 3
81031: PUSH
81032: LD_INT 0
81034: ST_TO_ADDR
// break ;
81035: GO 81039
// end ;
81037: GO 81000
81039: POP
81040: POP
// end else
81041: GO 81051
// result := false ;
81043: LD_ADDR_VAR 0 3
81047: PUSH
81048: LD_INT 0
81050: ST_TO_ADDR
// end ;
81051: LD_VAR 0 3
81055: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81056: LD_INT 0
81058: PPUSH
81059: PPUSH
// if not array1 or not array2 then
81060: LD_VAR 0 1
81064: NOT
81065: PUSH
81066: LD_VAR 0 2
81070: NOT
81071: OR
81072: IFFALSE 81076
// exit ;
81074: GO 81140
// result := true ;
81076: LD_ADDR_VAR 0 3
81080: PUSH
81081: LD_INT 1
81083: ST_TO_ADDR
// for i = 1 to array1 do
81084: LD_ADDR_VAR 0 4
81088: PUSH
81089: DOUBLE
81090: LD_INT 1
81092: DEC
81093: ST_TO_ADDR
81094: LD_VAR 0 1
81098: PUSH
81099: FOR_TO
81100: IFFALSE 81138
// if array1 [ i ] <> array2 [ i ] then
81102: LD_VAR 0 1
81106: PUSH
81107: LD_VAR 0 4
81111: ARRAY
81112: PUSH
81113: LD_VAR 0 2
81117: PUSH
81118: LD_VAR 0 4
81122: ARRAY
81123: NONEQUAL
81124: IFFALSE 81136
// begin result := false ;
81126: LD_ADDR_VAR 0 3
81130: PUSH
81131: LD_INT 0
81133: ST_TO_ADDR
// break ;
81134: GO 81138
// end ;
81136: GO 81099
81138: POP
81139: POP
// end ;
81140: LD_VAR 0 3
81144: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81145: LD_INT 0
81147: PPUSH
81148: PPUSH
81149: PPUSH
// pom := GetBase ( fac ) ;
81150: LD_ADDR_VAR 0 5
81154: PUSH
81155: LD_VAR 0 1
81159: PPUSH
81160: CALL_OW 274
81164: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81165: LD_ADDR_VAR 0 4
81169: PUSH
81170: LD_VAR 0 2
81174: PUSH
81175: LD_INT 1
81177: ARRAY
81178: PPUSH
81179: LD_VAR 0 2
81183: PUSH
81184: LD_INT 2
81186: ARRAY
81187: PPUSH
81188: LD_VAR 0 2
81192: PUSH
81193: LD_INT 3
81195: ARRAY
81196: PPUSH
81197: LD_VAR 0 2
81201: PUSH
81202: LD_INT 4
81204: ARRAY
81205: PPUSH
81206: CALL_OW 449
81210: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81211: LD_ADDR_VAR 0 3
81215: PUSH
81216: LD_VAR 0 5
81220: PPUSH
81221: LD_INT 1
81223: PPUSH
81224: CALL_OW 275
81228: PUSH
81229: LD_VAR 0 4
81233: PUSH
81234: LD_INT 1
81236: ARRAY
81237: GREATEREQUAL
81238: PUSH
81239: LD_VAR 0 5
81243: PPUSH
81244: LD_INT 2
81246: PPUSH
81247: CALL_OW 275
81251: PUSH
81252: LD_VAR 0 4
81256: PUSH
81257: LD_INT 2
81259: ARRAY
81260: GREATEREQUAL
81261: AND
81262: PUSH
81263: LD_VAR 0 5
81267: PPUSH
81268: LD_INT 3
81270: PPUSH
81271: CALL_OW 275
81275: PUSH
81276: LD_VAR 0 4
81280: PUSH
81281: LD_INT 3
81283: ARRAY
81284: GREATEREQUAL
81285: AND
81286: ST_TO_ADDR
// end ;
81287: LD_VAR 0 3
81291: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81292: LD_INT 0
81294: PPUSH
81295: PPUSH
81296: PPUSH
81297: PPUSH
// pom := GetBase ( building ) ;
81298: LD_ADDR_VAR 0 3
81302: PUSH
81303: LD_VAR 0 1
81307: PPUSH
81308: CALL_OW 274
81312: ST_TO_ADDR
// if not pom then
81313: LD_VAR 0 3
81317: NOT
81318: IFFALSE 81322
// exit ;
81320: GO 81492
// btype := GetBType ( building ) ;
81322: LD_ADDR_VAR 0 5
81326: PUSH
81327: LD_VAR 0 1
81331: PPUSH
81332: CALL_OW 266
81336: ST_TO_ADDR
// if btype = b_armoury then
81337: LD_VAR 0 5
81341: PUSH
81342: LD_INT 4
81344: EQUAL
81345: IFFALSE 81355
// btype := b_barracks ;
81347: LD_ADDR_VAR 0 5
81351: PUSH
81352: LD_INT 5
81354: ST_TO_ADDR
// if btype = b_depot then
81355: LD_VAR 0 5
81359: PUSH
81360: LD_INT 0
81362: EQUAL
81363: IFFALSE 81373
// btype := b_warehouse ;
81365: LD_ADDR_VAR 0 5
81369: PUSH
81370: LD_INT 1
81372: ST_TO_ADDR
// if btype = b_workshop then
81373: LD_VAR 0 5
81377: PUSH
81378: LD_INT 2
81380: EQUAL
81381: IFFALSE 81391
// btype := b_factory ;
81383: LD_ADDR_VAR 0 5
81387: PUSH
81388: LD_INT 3
81390: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81391: LD_ADDR_VAR 0 4
81395: PUSH
81396: LD_VAR 0 5
81400: PPUSH
81401: LD_VAR 0 1
81405: PPUSH
81406: CALL_OW 248
81410: PPUSH
81411: CALL_OW 450
81415: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81416: LD_ADDR_VAR 0 2
81420: PUSH
81421: LD_VAR 0 3
81425: PPUSH
81426: LD_INT 1
81428: PPUSH
81429: CALL_OW 275
81433: PUSH
81434: LD_VAR 0 4
81438: PUSH
81439: LD_INT 1
81441: ARRAY
81442: GREATEREQUAL
81443: PUSH
81444: LD_VAR 0 3
81448: PPUSH
81449: LD_INT 2
81451: PPUSH
81452: CALL_OW 275
81456: PUSH
81457: LD_VAR 0 4
81461: PUSH
81462: LD_INT 2
81464: ARRAY
81465: GREATEREQUAL
81466: AND
81467: PUSH
81468: LD_VAR 0 3
81472: PPUSH
81473: LD_INT 3
81475: PPUSH
81476: CALL_OW 275
81480: PUSH
81481: LD_VAR 0 4
81485: PUSH
81486: LD_INT 3
81488: ARRAY
81489: GREATEREQUAL
81490: AND
81491: ST_TO_ADDR
// end ;
81492: LD_VAR 0 2
81496: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81497: LD_INT 0
81499: PPUSH
81500: PPUSH
81501: PPUSH
// pom := GetBase ( building ) ;
81502: LD_ADDR_VAR 0 4
81506: PUSH
81507: LD_VAR 0 1
81511: PPUSH
81512: CALL_OW 274
81516: ST_TO_ADDR
// if not pom then
81517: LD_VAR 0 4
81521: NOT
81522: IFFALSE 81526
// exit ;
81524: GO 81627
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81526: LD_ADDR_VAR 0 5
81530: PUSH
81531: LD_VAR 0 2
81535: PPUSH
81536: LD_VAR 0 1
81540: PPUSH
81541: CALL_OW 248
81545: PPUSH
81546: CALL_OW 450
81550: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81551: LD_ADDR_VAR 0 3
81555: PUSH
81556: LD_VAR 0 4
81560: PPUSH
81561: LD_INT 1
81563: PPUSH
81564: CALL_OW 275
81568: PUSH
81569: LD_VAR 0 5
81573: PUSH
81574: LD_INT 1
81576: ARRAY
81577: GREATEREQUAL
81578: PUSH
81579: LD_VAR 0 4
81583: PPUSH
81584: LD_INT 2
81586: PPUSH
81587: CALL_OW 275
81591: PUSH
81592: LD_VAR 0 5
81596: PUSH
81597: LD_INT 2
81599: ARRAY
81600: GREATEREQUAL
81601: AND
81602: PUSH
81603: LD_VAR 0 4
81607: PPUSH
81608: LD_INT 3
81610: PPUSH
81611: CALL_OW 275
81615: PUSH
81616: LD_VAR 0 5
81620: PUSH
81621: LD_INT 3
81623: ARRAY
81624: GREATEREQUAL
81625: AND
81626: ST_TO_ADDR
// end ;
81627: LD_VAR 0 3
81631: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81632: LD_INT 0
81634: PPUSH
81635: PPUSH
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
// result := false ;
81645: LD_ADDR_VAR 0 8
81649: PUSH
81650: LD_INT 0
81652: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81653: LD_VAR 0 5
81657: NOT
81658: PUSH
81659: LD_VAR 0 1
81663: NOT
81664: OR
81665: PUSH
81666: LD_VAR 0 2
81670: NOT
81671: OR
81672: PUSH
81673: LD_VAR 0 3
81677: NOT
81678: OR
81679: IFFALSE 81683
// exit ;
81681: GO 82497
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81683: LD_ADDR_VAR 0 14
81687: PUSH
81688: LD_VAR 0 1
81692: PPUSH
81693: LD_VAR 0 2
81697: PPUSH
81698: LD_VAR 0 3
81702: PPUSH
81703: LD_VAR 0 4
81707: PPUSH
81708: LD_VAR 0 5
81712: PUSH
81713: LD_INT 1
81715: ARRAY
81716: PPUSH
81717: CALL_OW 248
81721: PPUSH
81722: LD_INT 0
81724: PPUSH
81725: CALL 83750 0 6
81729: ST_TO_ADDR
// if not hexes then
81730: LD_VAR 0 14
81734: NOT
81735: IFFALSE 81739
// exit ;
81737: GO 82497
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81739: LD_ADDR_VAR 0 17
81743: PUSH
81744: LD_VAR 0 5
81748: PPUSH
81749: LD_INT 22
81751: PUSH
81752: LD_VAR 0 13
81756: PPUSH
81757: CALL_OW 255
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 2
81768: PUSH
81769: LD_INT 30
81771: PUSH
81772: LD_INT 0
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 30
81781: PUSH
81782: LD_INT 1
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: LIST
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PPUSH
81798: CALL_OW 72
81802: ST_TO_ADDR
// for i = 1 to hexes do
81803: LD_ADDR_VAR 0 9
81807: PUSH
81808: DOUBLE
81809: LD_INT 1
81811: DEC
81812: ST_TO_ADDR
81813: LD_VAR 0 14
81817: PUSH
81818: FOR_TO
81819: IFFALSE 82495
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81821: LD_ADDR_VAR 0 13
81825: PUSH
81826: LD_VAR 0 14
81830: PUSH
81831: LD_VAR 0 9
81835: ARRAY
81836: PUSH
81837: LD_INT 1
81839: ARRAY
81840: PPUSH
81841: LD_VAR 0 14
81845: PUSH
81846: LD_VAR 0 9
81850: ARRAY
81851: PUSH
81852: LD_INT 2
81854: ARRAY
81855: PPUSH
81856: CALL_OW 428
81860: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
81861: LD_VAR 0 14
81865: PUSH
81866: LD_VAR 0 9
81870: ARRAY
81871: PUSH
81872: LD_INT 1
81874: ARRAY
81875: PPUSH
81876: LD_VAR 0 14
81880: PUSH
81881: LD_VAR 0 9
81885: ARRAY
81886: PUSH
81887: LD_INT 2
81889: ARRAY
81890: PPUSH
81891: CALL_OW 351
81895: PUSH
81896: LD_VAR 0 14
81900: PUSH
81901: LD_VAR 0 9
81905: ARRAY
81906: PUSH
81907: LD_INT 1
81909: ARRAY
81910: PPUSH
81911: LD_VAR 0 14
81915: PUSH
81916: LD_VAR 0 9
81920: ARRAY
81921: PUSH
81922: LD_INT 2
81924: ARRAY
81925: PPUSH
81926: CALL_OW 488
81930: NOT
81931: OR
81932: PUSH
81933: LD_VAR 0 13
81937: PPUSH
81938: CALL_OW 247
81942: PUSH
81943: LD_INT 3
81945: EQUAL
81946: OR
81947: IFFALSE 81953
// exit ;
81949: POP
81950: POP
81951: GO 82497
// if not tmp then
81953: LD_VAR 0 13
81957: NOT
81958: IFFALSE 81962
// continue ;
81960: GO 81818
// result := true ;
81962: LD_ADDR_VAR 0 8
81966: PUSH
81967: LD_INT 1
81969: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
81970: LD_VAR 0 6
81974: PUSH
81975: LD_VAR 0 13
81979: PPUSH
81980: CALL_OW 247
81984: PUSH
81985: LD_INT 2
81987: EQUAL
81988: AND
81989: PUSH
81990: LD_VAR 0 13
81994: PPUSH
81995: CALL_OW 263
81999: PUSH
82000: LD_INT 1
82002: EQUAL
82003: AND
82004: IFFALSE 82168
// begin if IsDrivenBy ( tmp ) then
82006: LD_VAR 0 13
82010: PPUSH
82011: CALL_OW 311
82015: IFFALSE 82019
// continue ;
82017: GO 81818
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82019: LD_VAR 0 6
82023: PPUSH
82024: LD_INT 3
82026: PUSH
82027: LD_INT 60
82029: PUSH
82030: EMPTY
82031: LIST
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 3
82039: PUSH
82040: LD_INT 55
82042: PUSH
82043: EMPTY
82044: LIST
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PPUSH
82054: CALL_OW 72
82058: IFFALSE 82166
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82060: LD_ADDR_VAR 0 18
82064: PUSH
82065: LD_VAR 0 6
82069: PPUSH
82070: LD_INT 3
82072: PUSH
82073: LD_INT 60
82075: PUSH
82076: EMPTY
82077: LIST
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 3
82085: PUSH
82086: LD_INT 55
82088: PUSH
82089: EMPTY
82090: LIST
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PPUSH
82100: CALL_OW 72
82104: PUSH
82105: LD_INT 1
82107: ARRAY
82108: ST_TO_ADDR
// if IsInUnit ( driver ) then
82109: LD_VAR 0 18
82113: PPUSH
82114: CALL_OW 310
82118: IFFALSE 82129
// ComExit ( driver ) ;
82120: LD_VAR 0 18
82124: PPUSH
82125: CALL 107542 0 1
// AddComEnterUnit ( driver , tmp ) ;
82129: LD_VAR 0 18
82133: PPUSH
82134: LD_VAR 0 13
82138: PPUSH
82139: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82143: LD_VAR 0 18
82147: PPUSH
82148: LD_VAR 0 7
82152: PPUSH
82153: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82157: LD_VAR 0 18
82161: PPUSH
82162: CALL_OW 181
// end ; continue ;
82166: GO 81818
// end ; if not cleaners or not tmp in cleaners then
82168: LD_VAR 0 6
82172: NOT
82173: PUSH
82174: LD_VAR 0 13
82178: PUSH
82179: LD_VAR 0 6
82183: IN
82184: NOT
82185: OR
82186: IFFALSE 82493
// begin if dep then
82188: LD_VAR 0 17
82192: IFFALSE 82328
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82194: LD_ADDR_VAR 0 16
82198: PUSH
82199: LD_VAR 0 17
82203: PUSH
82204: LD_INT 1
82206: ARRAY
82207: PPUSH
82208: CALL_OW 250
82212: PPUSH
82213: LD_VAR 0 17
82217: PUSH
82218: LD_INT 1
82220: ARRAY
82221: PPUSH
82222: CALL_OW 254
82226: PPUSH
82227: LD_INT 5
82229: PPUSH
82230: CALL_OW 272
82234: PUSH
82235: LD_VAR 0 17
82239: PUSH
82240: LD_INT 1
82242: ARRAY
82243: PPUSH
82244: CALL_OW 251
82248: PPUSH
82249: LD_VAR 0 17
82253: PUSH
82254: LD_INT 1
82256: ARRAY
82257: PPUSH
82258: CALL_OW 254
82262: PPUSH
82263: LD_INT 5
82265: PPUSH
82266: CALL_OW 273
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82275: LD_VAR 0 16
82279: PUSH
82280: LD_INT 1
82282: ARRAY
82283: PPUSH
82284: LD_VAR 0 16
82288: PUSH
82289: LD_INT 2
82291: ARRAY
82292: PPUSH
82293: CALL_OW 488
82297: IFFALSE 82328
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82299: LD_VAR 0 13
82303: PPUSH
82304: LD_VAR 0 16
82308: PUSH
82309: LD_INT 1
82311: ARRAY
82312: PPUSH
82313: LD_VAR 0 16
82317: PUSH
82318: LD_INT 2
82320: ARRAY
82321: PPUSH
82322: CALL_OW 111
// continue ;
82326: GO 81818
// end ; end ; r := GetDir ( tmp ) ;
82328: LD_ADDR_VAR 0 15
82332: PUSH
82333: LD_VAR 0 13
82337: PPUSH
82338: CALL_OW 254
82342: ST_TO_ADDR
// if r = 5 then
82343: LD_VAR 0 15
82347: PUSH
82348: LD_INT 5
82350: EQUAL
82351: IFFALSE 82361
// r := 0 ;
82353: LD_ADDR_VAR 0 15
82357: PUSH
82358: LD_INT 0
82360: ST_TO_ADDR
// for j = r to 5 do
82361: LD_ADDR_VAR 0 10
82365: PUSH
82366: DOUBLE
82367: LD_VAR 0 15
82371: DEC
82372: ST_TO_ADDR
82373: LD_INT 5
82375: PUSH
82376: FOR_TO
82377: IFFALSE 82491
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82379: LD_ADDR_VAR 0 11
82383: PUSH
82384: LD_VAR 0 13
82388: PPUSH
82389: CALL_OW 250
82393: PPUSH
82394: LD_VAR 0 10
82398: PPUSH
82399: LD_INT 2
82401: PPUSH
82402: CALL_OW 272
82406: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82407: LD_ADDR_VAR 0 12
82411: PUSH
82412: LD_VAR 0 13
82416: PPUSH
82417: CALL_OW 251
82421: PPUSH
82422: LD_VAR 0 10
82426: PPUSH
82427: LD_INT 2
82429: PPUSH
82430: CALL_OW 273
82434: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82435: LD_VAR 0 11
82439: PPUSH
82440: LD_VAR 0 12
82444: PPUSH
82445: CALL_OW 488
82449: PUSH
82450: LD_VAR 0 11
82454: PPUSH
82455: LD_VAR 0 12
82459: PPUSH
82460: CALL_OW 428
82464: NOT
82465: AND
82466: IFFALSE 82489
// begin ComMoveXY ( tmp , _x , _y ) ;
82468: LD_VAR 0 13
82472: PPUSH
82473: LD_VAR 0 11
82477: PPUSH
82478: LD_VAR 0 12
82482: PPUSH
82483: CALL_OW 111
// break ;
82487: GO 82491
// end ; end ;
82489: GO 82376
82491: POP
82492: POP
// end ; end ;
82493: GO 81818
82495: POP
82496: POP
// end ;
82497: LD_VAR 0 8
82501: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82502: LD_INT 0
82504: PPUSH
// result := true ;
82505: LD_ADDR_VAR 0 3
82509: PUSH
82510: LD_INT 1
82512: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82513: LD_VAR 0 2
82517: PUSH
82518: LD_INT 24
82520: DOUBLE
82521: EQUAL
82522: IFTRUE 82532
82524: LD_INT 33
82526: DOUBLE
82527: EQUAL
82528: IFTRUE 82532
82530: GO 82557
82532: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82533: LD_ADDR_VAR 0 3
82537: PUSH
82538: LD_INT 32
82540: PPUSH
82541: LD_VAR 0 1
82545: PPUSH
82546: CALL_OW 321
82550: PUSH
82551: LD_INT 2
82553: EQUAL
82554: ST_TO_ADDR
82555: GO 82873
82557: LD_INT 20
82559: DOUBLE
82560: EQUAL
82561: IFTRUE 82565
82563: GO 82590
82565: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82566: LD_ADDR_VAR 0 3
82570: PUSH
82571: LD_INT 6
82573: PPUSH
82574: LD_VAR 0 1
82578: PPUSH
82579: CALL_OW 321
82583: PUSH
82584: LD_INT 2
82586: EQUAL
82587: ST_TO_ADDR
82588: GO 82873
82590: LD_INT 22
82592: DOUBLE
82593: EQUAL
82594: IFTRUE 82604
82596: LD_INT 36
82598: DOUBLE
82599: EQUAL
82600: IFTRUE 82604
82602: GO 82629
82604: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82605: LD_ADDR_VAR 0 3
82609: PUSH
82610: LD_INT 15
82612: PPUSH
82613: LD_VAR 0 1
82617: PPUSH
82618: CALL_OW 321
82622: PUSH
82623: LD_INT 2
82625: EQUAL
82626: ST_TO_ADDR
82627: GO 82873
82629: LD_INT 30
82631: DOUBLE
82632: EQUAL
82633: IFTRUE 82637
82635: GO 82662
82637: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82638: LD_ADDR_VAR 0 3
82642: PUSH
82643: LD_INT 20
82645: PPUSH
82646: LD_VAR 0 1
82650: PPUSH
82651: CALL_OW 321
82655: PUSH
82656: LD_INT 2
82658: EQUAL
82659: ST_TO_ADDR
82660: GO 82873
82662: LD_INT 28
82664: DOUBLE
82665: EQUAL
82666: IFTRUE 82676
82668: LD_INT 21
82670: DOUBLE
82671: EQUAL
82672: IFTRUE 82676
82674: GO 82701
82676: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82677: LD_ADDR_VAR 0 3
82681: PUSH
82682: LD_INT 21
82684: PPUSH
82685: LD_VAR 0 1
82689: PPUSH
82690: CALL_OW 321
82694: PUSH
82695: LD_INT 2
82697: EQUAL
82698: ST_TO_ADDR
82699: GO 82873
82701: LD_INT 16
82703: DOUBLE
82704: EQUAL
82705: IFTRUE 82709
82707: GO 82734
82709: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82710: LD_ADDR_VAR 0 3
82714: PUSH
82715: LD_INT 84
82717: PPUSH
82718: LD_VAR 0 1
82722: PPUSH
82723: CALL_OW 321
82727: PUSH
82728: LD_INT 2
82730: EQUAL
82731: ST_TO_ADDR
82732: GO 82873
82734: LD_INT 19
82736: DOUBLE
82737: EQUAL
82738: IFTRUE 82748
82740: LD_INT 23
82742: DOUBLE
82743: EQUAL
82744: IFTRUE 82748
82746: GO 82773
82748: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82749: LD_ADDR_VAR 0 3
82753: PUSH
82754: LD_INT 83
82756: PPUSH
82757: LD_VAR 0 1
82761: PPUSH
82762: CALL_OW 321
82766: PUSH
82767: LD_INT 2
82769: EQUAL
82770: ST_TO_ADDR
82771: GO 82873
82773: LD_INT 17
82775: DOUBLE
82776: EQUAL
82777: IFTRUE 82781
82779: GO 82806
82781: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
82782: LD_ADDR_VAR 0 3
82786: PUSH
82787: LD_INT 39
82789: PPUSH
82790: LD_VAR 0 1
82794: PPUSH
82795: CALL_OW 321
82799: PUSH
82800: LD_INT 2
82802: EQUAL
82803: ST_TO_ADDR
82804: GO 82873
82806: LD_INT 18
82808: DOUBLE
82809: EQUAL
82810: IFTRUE 82814
82812: GO 82839
82814: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
82815: LD_ADDR_VAR 0 3
82819: PUSH
82820: LD_INT 40
82822: PPUSH
82823: LD_VAR 0 1
82827: PPUSH
82828: CALL_OW 321
82832: PUSH
82833: LD_INT 2
82835: EQUAL
82836: ST_TO_ADDR
82837: GO 82873
82839: LD_INT 27
82841: DOUBLE
82842: EQUAL
82843: IFTRUE 82847
82845: GO 82872
82847: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
82848: LD_ADDR_VAR 0 3
82852: PUSH
82853: LD_INT 35
82855: PPUSH
82856: LD_VAR 0 1
82860: PPUSH
82861: CALL_OW 321
82865: PUSH
82866: LD_INT 2
82868: EQUAL
82869: ST_TO_ADDR
82870: GO 82873
82872: POP
// end ;
82873: LD_VAR 0 3
82877: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
82878: LD_INT 0
82880: PPUSH
82881: PPUSH
82882: PPUSH
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
82887: PPUSH
82888: PPUSH
82889: PPUSH
82890: PPUSH
// result := false ;
82891: LD_ADDR_VAR 0 6
82895: PUSH
82896: LD_INT 0
82898: ST_TO_ADDR
// if btype = b_depot then
82899: LD_VAR 0 2
82903: PUSH
82904: LD_INT 0
82906: EQUAL
82907: IFFALSE 82919
// begin result := true ;
82909: LD_ADDR_VAR 0 6
82913: PUSH
82914: LD_INT 1
82916: ST_TO_ADDR
// exit ;
82917: GO 83745
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
82919: LD_VAR 0 1
82923: NOT
82924: PUSH
82925: LD_VAR 0 1
82929: PPUSH
82930: CALL_OW 266
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: LD_INT 1
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: IN
82945: NOT
82946: OR
82947: PUSH
82948: LD_VAR 0 2
82952: NOT
82953: OR
82954: PUSH
82955: LD_VAR 0 5
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 2
82968: PUSH
82969: LD_INT 3
82971: PUSH
82972: LD_INT 4
82974: PUSH
82975: LD_INT 5
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: IN
82986: NOT
82987: OR
82988: PUSH
82989: LD_VAR 0 3
82993: PPUSH
82994: LD_VAR 0 4
82998: PPUSH
82999: CALL_OW 488
83003: NOT
83004: OR
83005: IFFALSE 83009
// exit ;
83007: GO 83745
// side := GetSide ( depot ) ;
83009: LD_ADDR_VAR 0 9
83013: PUSH
83014: LD_VAR 0 1
83018: PPUSH
83019: CALL_OW 255
83023: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83024: LD_VAR 0 9
83028: PPUSH
83029: LD_VAR 0 2
83033: PPUSH
83034: CALL 82502 0 2
83038: NOT
83039: IFFALSE 83043
// exit ;
83041: GO 83745
// pom := GetBase ( depot ) ;
83043: LD_ADDR_VAR 0 10
83047: PUSH
83048: LD_VAR 0 1
83052: PPUSH
83053: CALL_OW 274
83057: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83058: LD_ADDR_VAR 0 11
83062: PUSH
83063: LD_VAR 0 2
83067: PPUSH
83068: LD_VAR 0 1
83072: PPUSH
83073: CALL_OW 248
83077: PPUSH
83078: CALL_OW 450
83082: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83083: LD_VAR 0 10
83087: PPUSH
83088: LD_INT 1
83090: PPUSH
83091: CALL_OW 275
83095: PUSH
83096: LD_VAR 0 11
83100: PUSH
83101: LD_INT 1
83103: ARRAY
83104: GREATEREQUAL
83105: PUSH
83106: LD_VAR 0 10
83110: PPUSH
83111: LD_INT 2
83113: PPUSH
83114: CALL_OW 275
83118: PUSH
83119: LD_VAR 0 11
83123: PUSH
83124: LD_INT 2
83126: ARRAY
83127: GREATEREQUAL
83128: AND
83129: PUSH
83130: LD_VAR 0 10
83134: PPUSH
83135: LD_INT 3
83137: PPUSH
83138: CALL_OW 275
83142: PUSH
83143: LD_VAR 0 11
83147: PUSH
83148: LD_INT 3
83150: ARRAY
83151: GREATEREQUAL
83152: AND
83153: NOT
83154: IFFALSE 83158
// exit ;
83156: GO 83745
// if GetBType ( depot ) = b_depot then
83158: LD_VAR 0 1
83162: PPUSH
83163: CALL_OW 266
83167: PUSH
83168: LD_INT 0
83170: EQUAL
83171: IFFALSE 83183
// dist := 28 else
83173: LD_ADDR_VAR 0 14
83177: PUSH
83178: LD_INT 28
83180: ST_TO_ADDR
83181: GO 83191
// dist := 36 ;
83183: LD_ADDR_VAR 0 14
83187: PUSH
83188: LD_INT 36
83190: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83191: LD_VAR 0 1
83195: PPUSH
83196: LD_VAR 0 3
83200: PPUSH
83201: LD_VAR 0 4
83205: PPUSH
83206: CALL_OW 297
83210: PUSH
83211: LD_VAR 0 14
83215: GREATER
83216: IFFALSE 83220
// exit ;
83218: GO 83745
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83220: LD_ADDR_VAR 0 12
83224: PUSH
83225: LD_VAR 0 2
83229: PPUSH
83230: LD_VAR 0 3
83234: PPUSH
83235: LD_VAR 0 4
83239: PPUSH
83240: LD_VAR 0 5
83244: PPUSH
83245: LD_VAR 0 1
83249: PPUSH
83250: CALL_OW 248
83254: PPUSH
83255: LD_INT 0
83257: PPUSH
83258: CALL 83750 0 6
83262: ST_TO_ADDR
// if not hexes then
83263: LD_VAR 0 12
83267: NOT
83268: IFFALSE 83272
// exit ;
83270: GO 83745
// hex := GetHexInfo ( x , y ) ;
83272: LD_ADDR_VAR 0 15
83276: PUSH
83277: LD_VAR 0 3
83281: PPUSH
83282: LD_VAR 0 4
83286: PPUSH
83287: CALL_OW 546
83291: ST_TO_ADDR
// if hex [ 1 ] then
83292: LD_VAR 0 15
83296: PUSH
83297: LD_INT 1
83299: ARRAY
83300: IFFALSE 83304
// exit ;
83302: GO 83745
// height := hex [ 2 ] ;
83304: LD_ADDR_VAR 0 13
83308: PUSH
83309: LD_VAR 0 15
83313: PUSH
83314: LD_INT 2
83316: ARRAY
83317: ST_TO_ADDR
// for i = 1 to hexes do
83318: LD_ADDR_VAR 0 7
83322: PUSH
83323: DOUBLE
83324: LD_INT 1
83326: DEC
83327: ST_TO_ADDR
83328: LD_VAR 0 12
83332: PUSH
83333: FOR_TO
83334: IFFALSE 83664
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83336: LD_VAR 0 12
83340: PUSH
83341: LD_VAR 0 7
83345: ARRAY
83346: PUSH
83347: LD_INT 1
83349: ARRAY
83350: PPUSH
83351: LD_VAR 0 12
83355: PUSH
83356: LD_VAR 0 7
83360: ARRAY
83361: PUSH
83362: LD_INT 2
83364: ARRAY
83365: PPUSH
83366: CALL_OW 488
83370: NOT
83371: PUSH
83372: LD_VAR 0 12
83376: PUSH
83377: LD_VAR 0 7
83381: ARRAY
83382: PUSH
83383: LD_INT 1
83385: ARRAY
83386: PPUSH
83387: LD_VAR 0 12
83391: PUSH
83392: LD_VAR 0 7
83396: ARRAY
83397: PUSH
83398: LD_INT 2
83400: ARRAY
83401: PPUSH
83402: CALL_OW 428
83406: PUSH
83407: LD_INT 0
83409: GREATER
83410: OR
83411: PUSH
83412: LD_VAR 0 12
83416: PUSH
83417: LD_VAR 0 7
83421: ARRAY
83422: PUSH
83423: LD_INT 1
83425: ARRAY
83426: PPUSH
83427: LD_VAR 0 12
83431: PUSH
83432: LD_VAR 0 7
83436: ARRAY
83437: PUSH
83438: LD_INT 2
83440: ARRAY
83441: PPUSH
83442: CALL_OW 351
83446: OR
83447: IFFALSE 83453
// exit ;
83449: POP
83450: POP
83451: GO 83745
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83453: LD_ADDR_VAR 0 8
83457: PUSH
83458: LD_VAR 0 12
83462: PUSH
83463: LD_VAR 0 7
83467: ARRAY
83468: PUSH
83469: LD_INT 1
83471: ARRAY
83472: PPUSH
83473: LD_VAR 0 12
83477: PUSH
83478: LD_VAR 0 7
83482: ARRAY
83483: PUSH
83484: LD_INT 2
83486: ARRAY
83487: PPUSH
83488: CALL_OW 546
83492: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83493: LD_VAR 0 8
83497: PUSH
83498: LD_INT 1
83500: ARRAY
83501: PUSH
83502: LD_VAR 0 8
83506: PUSH
83507: LD_INT 2
83509: ARRAY
83510: PUSH
83511: LD_VAR 0 13
83515: PUSH
83516: LD_INT 2
83518: PLUS
83519: GREATER
83520: OR
83521: PUSH
83522: LD_VAR 0 8
83526: PUSH
83527: LD_INT 2
83529: ARRAY
83530: PUSH
83531: LD_VAR 0 13
83535: PUSH
83536: LD_INT 2
83538: MINUS
83539: LESS
83540: OR
83541: PUSH
83542: LD_VAR 0 8
83546: PUSH
83547: LD_INT 3
83549: ARRAY
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 8
83556: PUSH
83557: LD_INT 9
83559: PUSH
83560: LD_INT 10
83562: PUSH
83563: LD_INT 11
83565: PUSH
83566: LD_INT 12
83568: PUSH
83569: LD_INT 13
83571: PUSH
83572: LD_INT 16
83574: PUSH
83575: LD_INT 17
83577: PUSH
83578: LD_INT 18
83580: PUSH
83581: LD_INT 19
83583: PUSH
83584: LD_INT 20
83586: PUSH
83587: LD_INT 21
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: IN
83605: NOT
83606: OR
83607: PUSH
83608: LD_VAR 0 8
83612: PUSH
83613: LD_INT 5
83615: ARRAY
83616: NOT
83617: OR
83618: PUSH
83619: LD_VAR 0 8
83623: PUSH
83624: LD_INT 6
83626: ARRAY
83627: PUSH
83628: LD_INT 1
83630: PUSH
83631: LD_INT 2
83633: PUSH
83634: LD_INT 7
83636: PUSH
83637: LD_INT 9
83639: PUSH
83640: LD_INT 10
83642: PUSH
83643: LD_INT 11
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: IN
83654: NOT
83655: OR
83656: IFFALSE 83662
// exit ;
83658: POP
83659: POP
83660: GO 83745
// end ;
83662: GO 83333
83664: POP
83665: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83666: LD_VAR 0 9
83670: PPUSH
83671: LD_VAR 0 3
83675: PPUSH
83676: LD_VAR 0 4
83680: PPUSH
83681: LD_INT 20
83683: PPUSH
83684: CALL 75668 0 4
83688: PUSH
83689: LD_INT 4
83691: ARRAY
83692: IFFALSE 83696
// exit ;
83694: GO 83745
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83696: LD_VAR 0 2
83700: PUSH
83701: LD_INT 29
83703: PUSH
83704: LD_INT 30
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: IN
83711: PUSH
83712: LD_VAR 0 3
83716: PPUSH
83717: LD_VAR 0 4
83721: PPUSH
83722: LD_VAR 0 9
83726: PPUSH
83727: CALL_OW 440
83731: NOT
83732: AND
83733: IFFALSE 83737
// exit ;
83735: GO 83745
// result := true ;
83737: LD_ADDR_VAR 0 6
83741: PUSH
83742: LD_INT 1
83744: ST_TO_ADDR
// end ;
83745: LD_VAR 0 6
83749: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83750: LD_INT 0
83752: PPUSH
83753: PPUSH
83754: PPUSH
83755: PPUSH
83756: PPUSH
83757: PPUSH
83758: PPUSH
83759: PPUSH
83760: PPUSH
83761: PPUSH
83762: PPUSH
83763: PPUSH
83764: PPUSH
83765: PPUSH
83766: PPUSH
83767: PPUSH
83768: PPUSH
83769: PPUSH
83770: PPUSH
83771: PPUSH
83772: PPUSH
83773: PPUSH
83774: PPUSH
83775: PPUSH
83776: PPUSH
83777: PPUSH
83778: PPUSH
83779: PPUSH
83780: PPUSH
83781: PPUSH
83782: PPUSH
83783: PPUSH
83784: PPUSH
83785: PPUSH
83786: PPUSH
83787: PPUSH
83788: PPUSH
83789: PPUSH
83790: PPUSH
83791: PPUSH
83792: PPUSH
83793: PPUSH
83794: PPUSH
83795: PPUSH
83796: PPUSH
83797: PPUSH
83798: PPUSH
83799: PPUSH
83800: PPUSH
83801: PPUSH
83802: PPUSH
83803: PPUSH
83804: PPUSH
83805: PPUSH
83806: PPUSH
83807: PPUSH
83808: PPUSH
83809: PPUSH
// result = [ ] ;
83810: LD_ADDR_VAR 0 7
83814: PUSH
83815: EMPTY
83816: ST_TO_ADDR
// temp_list = [ ] ;
83817: LD_ADDR_VAR 0 9
83821: PUSH
83822: EMPTY
83823: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
83824: LD_VAR 0 4
83828: PUSH
83829: LD_INT 0
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: LD_INT 2
83837: PUSH
83838: LD_INT 3
83840: PUSH
83841: LD_INT 4
83843: PUSH
83844: LD_INT 5
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: IN
83855: NOT
83856: PUSH
83857: LD_VAR 0 1
83861: PUSH
83862: LD_INT 0
83864: PUSH
83865: LD_INT 1
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: IN
83872: PUSH
83873: LD_VAR 0 5
83877: PUSH
83878: LD_INT 1
83880: PUSH
83881: LD_INT 2
83883: PUSH
83884: LD_INT 3
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: LIST
83891: IN
83892: NOT
83893: AND
83894: OR
83895: IFFALSE 83899
// exit ;
83897: GO 102290
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
83899: LD_VAR 0 1
83903: PUSH
83904: LD_INT 6
83906: PUSH
83907: LD_INT 7
83909: PUSH
83910: LD_INT 8
83912: PUSH
83913: LD_INT 13
83915: PUSH
83916: LD_INT 12
83918: PUSH
83919: LD_INT 15
83921: PUSH
83922: LD_INT 11
83924: PUSH
83925: LD_INT 14
83927: PUSH
83928: LD_INT 10
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: IN
83942: IFFALSE 83952
// btype = b_lab ;
83944: LD_ADDR_VAR 0 1
83948: PUSH
83949: LD_INT 6
83951: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
83952: LD_VAR 0 6
83956: PUSH
83957: LD_INT 0
83959: PUSH
83960: LD_INT 1
83962: PUSH
83963: LD_INT 2
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: LIST
83970: IN
83971: NOT
83972: PUSH
83973: LD_VAR 0 1
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: LD_INT 1
83983: PUSH
83984: LD_INT 2
83986: PUSH
83987: LD_INT 3
83989: PUSH
83990: LD_INT 6
83992: PUSH
83993: LD_INT 36
83995: PUSH
83996: LD_INT 4
83998: PUSH
83999: LD_INT 5
84001: PUSH
84002: LD_INT 31
84004: PUSH
84005: LD_INT 32
84007: PUSH
84008: LD_INT 33
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: IN
84024: NOT
84025: PUSH
84026: LD_VAR 0 6
84030: PUSH
84031: LD_INT 1
84033: EQUAL
84034: AND
84035: OR
84036: PUSH
84037: LD_VAR 0 1
84041: PUSH
84042: LD_INT 2
84044: PUSH
84045: LD_INT 3
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: IN
84052: NOT
84053: PUSH
84054: LD_VAR 0 6
84058: PUSH
84059: LD_INT 2
84061: EQUAL
84062: AND
84063: OR
84064: IFFALSE 84074
// mode = 0 ;
84066: LD_ADDR_VAR 0 6
84070: PUSH
84071: LD_INT 0
84073: ST_TO_ADDR
// case mode of 0 :
84074: LD_VAR 0 6
84078: PUSH
84079: LD_INT 0
84081: DOUBLE
84082: EQUAL
84083: IFTRUE 84087
84085: GO 95540
84087: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84088: LD_ADDR_VAR 0 11
84092: PUSH
84093: LD_INT 0
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 0
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 1
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 1
84126: PUSH
84127: LD_INT 1
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 0
84136: PUSH
84137: LD_INT 1
84139: PUSH
84140: EMPTY
84141: LIST
84142: LIST
84143: PUSH
84144: LD_INT 1
84146: NEG
84147: PUSH
84148: LD_INT 0
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 1
84157: NEG
84158: PUSH
84159: LD_INT 1
84161: NEG
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: LD_INT 2
84173: NEG
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 0
84181: PUSH
84182: LD_INT 2
84184: NEG
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 1
84192: PUSH
84193: LD_INT 1
84195: NEG
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 1
84203: PUSH
84204: LD_INT 2
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PUSH
84211: LD_INT 0
84213: PUSH
84214: LD_INT 2
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 1
84223: NEG
84224: PUSH
84225: LD_INT 1
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: LD_INT 3
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 0
84244: PUSH
84245: LD_INT 3
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 1
84254: NEG
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84281: LD_ADDR_VAR 0 12
84285: PUSH
84286: LD_INT 0
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: LD_INT 1
84301: NEG
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 1
84309: PUSH
84310: LD_INT 0
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 1
84319: PUSH
84320: LD_INT 1
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 0
84329: PUSH
84330: LD_INT 1
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 1
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 2
84373: PUSH
84374: LD_INT 0
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 2
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 1
84393: NEG
84394: PUSH
84395: LD_INT 1
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 2
84404: NEG
84405: PUSH
84406: LD_INT 0
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: NEG
84416: PUSH
84417: LD_INT 1
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 2
84427: NEG
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 3
84438: NEG
84439: PUSH
84440: LD_INT 0
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 3
84449: NEG
84450: PUSH
84451: LD_INT 1
84453: NEG
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84477: LD_ADDR_VAR 0 13
84481: PUSH
84482: LD_INT 0
84484: PUSH
84485: LD_INT 0
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 0
84494: PUSH
84495: LD_INT 1
84497: NEG
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 1
84505: PUSH
84506: LD_INT 0
84508: PUSH
84509: EMPTY
84510: LIST
84511: LIST
84512: PUSH
84513: LD_INT 1
84515: PUSH
84516: LD_INT 1
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 0
84525: PUSH
84526: LD_INT 1
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 1
84535: NEG
84536: PUSH
84537: LD_INT 0
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 1
84546: NEG
84547: PUSH
84548: LD_INT 1
84550: NEG
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 1
84558: NEG
84559: PUSH
84560: LD_INT 2
84562: NEG
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 2
84570: PUSH
84571: LD_INT 1
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 2
84580: PUSH
84581: LD_INT 2
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 2
84600: NEG
84601: PUSH
84602: LD_INT 1
84604: NEG
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 2
84612: NEG
84613: PUSH
84614: LD_INT 2
84616: NEG
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 2
84624: NEG
84625: PUSH
84626: LD_INT 3
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 3
84636: NEG
84637: PUSH
84638: LD_INT 2
84640: NEG
84641: PUSH
84642: EMPTY
84643: LIST
84644: LIST
84645: PUSH
84646: LD_INT 3
84648: NEG
84649: PUSH
84650: LD_INT 3
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84676: LD_ADDR_VAR 0 14
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: LD_INT 0
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: LD_INT 1
84696: NEG
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: LD_INT 0
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 1
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 0
84724: PUSH
84725: LD_INT 1
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: LD_INT 1
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: LD_INT 2
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 0
84769: PUSH
84770: LD_INT 2
84772: NEG
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: PUSH
84792: LD_INT 2
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 0
84801: PUSH
84802: LD_INT 2
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: NEG
84812: PUSH
84813: LD_INT 1
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: NEG
84823: PUSH
84824: LD_INT 3
84826: NEG
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 0
84834: PUSH
84835: LD_INT 3
84837: NEG
84838: PUSH
84839: EMPTY
84840: LIST
84841: LIST
84842: PUSH
84843: LD_INT 1
84845: PUSH
84846: LD_INT 2
84848: NEG
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
84872: LD_ADDR_VAR 0 15
84876: PUSH
84877: LD_INT 0
84879: PUSH
84880: LD_INT 0
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: LD_INT 1
84892: NEG
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: LD_INT 1
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: LD_INT 0
84920: PUSH
84921: LD_INT 1
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: NEG
84931: PUSH
84932: LD_INT 0
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 1
84945: NEG
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 1
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 0
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 1
84984: NEG
84985: PUSH
84986: LD_INT 1
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: LD_INT 2
84995: NEG
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 2
85006: NEG
85007: PUSH
85008: LD_INT 1
85010: NEG
85011: PUSH
85012: EMPTY
85013: LIST
85014: LIST
85015: PUSH
85016: LD_INT 2
85018: PUSH
85019: LD_INT 1
85021: NEG
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 3
85029: PUSH
85030: LD_INT 0
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 3
85039: PUSH
85040: LD_INT 1
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85065: LD_ADDR_VAR 0 16
85069: PUSH
85070: LD_INT 0
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 0
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: PUSH
85094: LD_INT 0
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: LD_INT 0
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 1
85134: NEG
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: LD_INT 2
85150: NEG
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 2
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 2
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: LD_INT 2
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 2
85188: NEG
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 2
85200: NEG
85201: PUSH
85202: LD_INT 2
85204: NEG
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 3
85212: PUSH
85213: LD_INT 2
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 3
85222: PUSH
85223: LD_INT 3
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 2
85232: PUSH
85233: LD_INT 3
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85258: LD_ADDR_VAR 0 17
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 0
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: PUSH
85287: LD_INT 0
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 1
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: LD_INT 1
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: LD_INT 0
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 1
85327: NEG
85328: PUSH
85329: LD_INT 1
85331: NEG
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: LD_INT 1
85339: NEG
85340: PUSH
85341: LD_INT 2
85343: NEG
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 0
85351: PUSH
85352: LD_INT 2
85354: NEG
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: PUSH
85363: LD_INT 1
85365: NEG
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 2
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: PUSH
85384: LD_INT 1
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 2
85393: PUSH
85394: LD_INT 2
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: LD_INT 2
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 0
85413: PUSH
85414: LD_INT 2
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 1
85423: NEG
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 2
85434: NEG
85435: PUSH
85436: LD_INT 0
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 2
85445: NEG
85446: PUSH
85447: LD_INT 1
85449: NEG
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 2
85457: NEG
85458: PUSH
85459: LD_INT 2
85461: NEG
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85488: LD_ADDR_VAR 0 18
85492: PUSH
85493: LD_INT 0
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: LD_INT 1
85508: NEG
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 1
85516: PUSH
85517: LD_INT 0
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: LD_INT 1
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: LD_INT 1
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 1
85546: NEG
85547: PUSH
85548: LD_INT 0
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: LD_INT 1
85561: NEG
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 1
85569: NEG
85570: PUSH
85571: LD_INT 2
85573: NEG
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 0
85581: PUSH
85582: LD_INT 2
85584: NEG
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 2
85603: PUSH
85604: LD_INT 0
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 2
85613: PUSH
85614: LD_INT 1
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 2
85623: PUSH
85624: LD_INT 2
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 1
85633: PUSH
85634: LD_INT 2
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PUSH
85641: LD_INT 0
85643: PUSH
85644: LD_INT 2
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 1
85653: NEG
85654: PUSH
85655: LD_INT 1
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 2
85664: NEG
85665: PUSH
85666: LD_INT 0
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 2
85675: NEG
85676: PUSH
85677: LD_INT 1
85679: NEG
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 2
85687: NEG
85688: PUSH
85689: LD_INT 2
85691: NEG
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85718: LD_ADDR_VAR 0 19
85722: PUSH
85723: LD_INT 0
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 0
85735: PUSH
85736: LD_INT 1
85738: NEG
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 1
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 1
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: LD_INT 1
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: NEG
85777: PUSH
85778: LD_INT 0
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 1
85787: NEG
85788: PUSH
85789: LD_INT 1
85791: NEG
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 1
85799: NEG
85800: PUSH
85801: LD_INT 2
85803: NEG
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 2
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: PUSH
85823: LD_INT 1
85825: NEG
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 2
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 2
85843: PUSH
85844: LD_INT 1
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: LD_INT 2
85853: PUSH
85854: LD_INT 2
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: PUSH
85864: LD_INT 2
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 0
85873: PUSH
85874: LD_INT 2
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 1
85883: NEG
85884: PUSH
85885: LD_INT 1
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: LD_INT 2
85894: NEG
85895: PUSH
85896: LD_INT 0
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: PUSH
85903: LD_INT 2
85905: NEG
85906: PUSH
85907: LD_INT 1
85909: NEG
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: LD_INT 2
85921: NEG
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85948: LD_ADDR_VAR 0 20
85952: PUSH
85953: LD_INT 0
85955: PUSH
85956: LD_INT 0
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 0
85965: PUSH
85966: LD_INT 1
85968: NEG
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 1
85976: PUSH
85977: LD_INT 0
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: LD_INT 1
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 0
85996: PUSH
85997: LD_INT 1
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 1
86006: NEG
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: LD_INT 1
86021: NEG
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 1
86029: NEG
86030: PUSH
86031: LD_INT 2
86033: NEG
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 0
86041: PUSH
86042: LD_INT 2
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: PUSH
86053: LD_INT 1
86055: NEG
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 2
86063: PUSH
86064: LD_INT 0
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 2
86073: PUSH
86074: LD_INT 1
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 2
86083: PUSH
86084: LD_INT 2
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_INT 1
86093: PUSH
86094: LD_INT 2
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 0
86103: PUSH
86104: LD_INT 2
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 1
86113: NEG
86114: PUSH
86115: LD_INT 1
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 2
86124: NEG
86125: PUSH
86126: LD_INT 0
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 2
86135: NEG
86136: PUSH
86137: LD_INT 1
86139: NEG
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: LD_INT 2
86151: NEG
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86178: LD_ADDR_VAR 0 21
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 0
86195: PUSH
86196: LD_INT 1
86198: NEG
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 1
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 1
86285: NEG
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: LD_INT 0
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: LD_INT 1
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 2
86313: PUSH
86314: LD_INT 2
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 1
86323: PUSH
86324: LD_INT 2
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 0
86333: PUSH
86334: LD_INT 2
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 1
86343: NEG
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 2
86354: NEG
86355: PUSH
86356: LD_INT 0
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 2
86365: NEG
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 2
86377: NEG
86378: PUSH
86379: LD_INT 2
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86408: LD_ADDR_VAR 0 22
86412: PUSH
86413: LD_INT 0
86415: PUSH
86416: LD_INT 0
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 0
86425: PUSH
86426: LD_INT 1
86428: NEG
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 1
86436: PUSH
86437: LD_INT 0
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: LD_INT 1
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 1
86466: NEG
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: LD_INT 1
86481: NEG
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 2
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 2
86523: PUSH
86524: LD_INT 0
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 2
86533: PUSH
86534: LD_INT 1
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 2
86543: PUSH
86544: LD_INT 2
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 1
86553: PUSH
86554: LD_INT 2
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 1
86573: NEG
86574: PUSH
86575: LD_INT 1
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 2
86584: NEG
86585: PUSH
86586: LD_INT 0
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 2
86595: NEG
86596: PUSH
86597: LD_INT 1
86599: NEG
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 2
86607: NEG
86608: PUSH
86609: LD_INT 2
86611: NEG
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86638: LD_ADDR_VAR 0 23
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: LD_INT 0
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: LD_INT 0
86655: PUSH
86656: LD_INT 1
86658: NEG
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 1
86666: PUSH
86667: LD_INT 0
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 1
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 0
86686: PUSH
86687: LD_INT 1
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 1
86696: NEG
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 1
86707: NEG
86708: PUSH
86709: LD_INT 1
86711: NEG
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 1
86719: NEG
86720: PUSH
86721: LD_INT 2
86723: NEG
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 0
86731: PUSH
86732: LD_INT 2
86734: NEG
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: PUSH
86743: LD_INT 1
86745: NEG
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 2
86753: PUSH
86754: LD_INT 0
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 2
86763: PUSH
86764: LD_INT 1
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: PUSH
86774: LD_INT 2
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 2
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 0
86793: PUSH
86794: LD_INT 2
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 1
86803: NEG
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 2
86814: NEG
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 2
86825: NEG
86826: PUSH
86827: LD_INT 1
86829: NEG
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 2
86837: NEG
86838: PUSH
86839: LD_INT 2
86841: NEG
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 2
86849: NEG
86850: PUSH
86851: LD_INT 3
86853: NEG
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 3
86865: NEG
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 1
86873: PUSH
86874: LD_INT 2
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: PUSH
86885: LD_INT 1
86887: NEG
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
86918: LD_ADDR_VAR 0 24
86922: PUSH
86923: LD_INT 0
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 0
86935: PUSH
86936: LD_INT 1
86938: NEG
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 1
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: LD_INT 1
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 0
86966: PUSH
86967: LD_INT 1
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 1
86976: NEG
86977: PUSH
86978: LD_INT 0
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: LD_INT 1
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 1
86999: NEG
87000: PUSH
87001: LD_INT 2
87003: NEG
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 0
87011: PUSH
87012: LD_INT 2
87014: NEG
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 1
87022: PUSH
87023: LD_INT 1
87025: NEG
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 2
87033: PUSH
87034: LD_INT 0
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 2
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 2
87053: PUSH
87054: LD_INT 2
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: PUSH
87061: LD_INT 1
87063: PUSH
87064: LD_INT 2
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 0
87073: PUSH
87074: LD_INT 2
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 1
87083: NEG
87084: PUSH
87085: LD_INT 1
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 2
87094: NEG
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 2
87105: NEG
87106: PUSH
87107: LD_INT 1
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 2
87117: NEG
87118: PUSH
87119: LD_INT 2
87121: NEG
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_INT 1
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 2
87140: PUSH
87141: LD_INT 1
87143: NEG
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PUSH
87149: LD_INT 3
87151: PUSH
87152: LD_INT 1
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 3
87161: PUSH
87162: LD_INT 2
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87194: LD_ADDR_VAR 0 25
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: LD_INT 0
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 0
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 0
87242: PUSH
87243: LD_INT 1
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 1
87252: NEG
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 1
87263: NEG
87264: PUSH
87265: LD_INT 1
87267: NEG
87268: PUSH
87269: EMPTY
87270: LIST
87271: LIST
87272: PUSH
87273: LD_INT 1
87275: NEG
87276: PUSH
87277: LD_INT 2
87279: NEG
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: LD_INT 2
87290: NEG
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: LD_INT 1
87301: NEG
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 2
87309: PUSH
87310: LD_INT 0
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 2
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 2
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 1
87339: PUSH
87340: LD_INT 2
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: LD_INT 2
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 2
87370: NEG
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: LD_INT 2
87381: NEG
87382: PUSH
87383: LD_INT 1
87385: NEG
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 2
87393: NEG
87394: PUSH
87395: LD_INT 2
87397: NEG
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 3
87405: PUSH
87406: LD_INT 1
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 3
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 2
87425: PUSH
87426: LD_INT 3
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 1
87435: PUSH
87436: LD_INT 3
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87468: LD_ADDR_VAR 0 26
87472: PUSH
87473: LD_INT 0
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 0
87485: PUSH
87486: LD_INT 1
87488: NEG
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 1
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 0
87516: PUSH
87517: LD_INT 1
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 1
87526: NEG
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: LD_INT 1
87541: NEG
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 1
87549: NEG
87550: PUSH
87551: LD_INT 2
87553: NEG
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 2
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 1
87575: NEG
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 2
87583: PUSH
87584: LD_INT 0
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 2
87593: PUSH
87594: LD_INT 1
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: LD_INT 2
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 1
87613: PUSH
87614: LD_INT 2
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: LD_INT 2
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 1
87633: NEG
87634: PUSH
87635: LD_INT 1
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 2
87644: NEG
87645: PUSH
87646: LD_INT 0
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: LD_INT 1
87659: NEG
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: LD_INT 2
87667: NEG
87668: PUSH
87669: LD_INT 2
87671: NEG
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 2
87679: PUSH
87680: LD_INT 3
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 1
87689: PUSH
87690: LD_INT 3
87692: PUSH
87693: EMPTY
87694: LIST
87695: LIST
87696: PUSH
87697: LD_INT 1
87699: NEG
87700: PUSH
87701: LD_INT 2
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 2
87710: NEG
87711: PUSH
87712: LD_INT 1
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87744: LD_ADDR_VAR 0 27
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 1
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: LD_INT 1
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: LD_INT 1
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: LD_INT 2
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 0
87837: PUSH
87838: LD_INT 2
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 2
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 2
87879: PUSH
87880: LD_INT 2
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: LD_INT 2
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: NEG
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 2
87931: NEG
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 2
87943: NEG
87944: PUSH
87945: LD_INT 2
87947: NEG
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: PUSH
87953: LD_INT 1
87955: NEG
87956: PUSH
87957: LD_INT 2
87959: PUSH
87960: EMPTY
87961: LIST
87962: LIST
87963: PUSH
87964: LD_INT 2
87966: NEG
87967: PUSH
87968: LD_INT 1
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 3
87977: NEG
87978: PUSH
87979: LD_INT 1
87981: NEG
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 3
87989: NEG
87990: PUSH
87991: LD_INT 2
87993: NEG
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88024: LD_ADDR_VAR 0 28
88028: PUSH
88029: LD_INT 0
88031: PUSH
88032: LD_INT 0
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: LD_INT 1
88044: NEG
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: LD_INT 1
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 0
88072: PUSH
88073: LD_INT 1
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 1
88082: NEG
88083: PUSH
88084: LD_INT 0
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 1
88093: NEG
88094: PUSH
88095: LD_INT 1
88097: NEG
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 1
88105: NEG
88106: PUSH
88107: LD_INT 2
88109: NEG
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 0
88117: PUSH
88118: LD_INT 2
88120: NEG
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 1
88128: PUSH
88129: LD_INT 1
88131: NEG
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 2
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 2
88149: PUSH
88150: LD_INT 1
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 2
88159: PUSH
88160: LD_INT 2
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 1
88169: PUSH
88170: LD_INT 2
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 2
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: LD_INT 1
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 2
88200: NEG
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 2
88211: NEG
88212: PUSH
88213: LD_INT 1
88215: NEG
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: LD_INT 2
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 2
88235: NEG
88236: PUSH
88237: LD_INT 3
88239: NEG
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 1
88247: NEG
88248: PUSH
88249: LD_INT 3
88251: NEG
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 3
88259: NEG
88260: PUSH
88261: LD_INT 1
88263: NEG
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 3
88271: NEG
88272: PUSH
88273: LD_INT 2
88275: NEG
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88306: LD_ADDR_VAR 0 29
88310: PUSH
88311: LD_INT 0
88313: PUSH
88314: LD_INT 0
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: LD_INT 0
88323: PUSH
88324: LD_INT 1
88326: NEG
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 1
88344: PUSH
88345: LD_INT 1
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: LD_INT 1
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 1
88375: NEG
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 1
88387: NEG
88388: PUSH
88389: LD_INT 2
88391: NEG
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 0
88399: PUSH
88400: LD_INT 2
88402: NEG
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 1
88410: PUSH
88411: LD_INT 1
88413: NEG
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 2
88421: PUSH
88422: LD_INT 0
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 2
88431: PUSH
88432: LD_INT 1
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 1
88441: PUSH
88442: LD_INT 2
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 0
88451: PUSH
88452: LD_INT 2
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 1
88461: NEG
88462: PUSH
88463: LD_INT 1
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 2
88472: NEG
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 2
88484: NEG
88485: PUSH
88486: LD_INT 2
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 2
88496: NEG
88497: PUSH
88498: LD_INT 3
88500: NEG
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 2
88508: PUSH
88509: LD_INT 1
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 3
88519: PUSH
88520: LD_INT 1
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: LD_INT 1
88529: PUSH
88530: LD_INT 3
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 3
88550: NEG
88551: PUSH
88552: LD_INT 2
88554: NEG
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88585: LD_ADDR_VAR 0 30
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: LD_INT 0
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 0
88602: PUSH
88603: LD_INT 1
88605: NEG
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 1
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 1
88623: PUSH
88624: LD_INT 1
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 0
88633: PUSH
88634: LD_INT 1
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 1
88643: NEG
88644: PUSH
88645: LD_INT 0
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 1
88654: NEG
88655: PUSH
88656: LD_INT 1
88658: NEG
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: LD_INT 2
88670: NEG
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 0
88678: PUSH
88679: LD_INT 2
88681: NEG
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 1
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 2
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 2
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: LD_INT 2
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 1
88730: PUSH
88731: LD_INT 2
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 1
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 2
88751: NEG
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 2
88762: NEG
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 1
88774: NEG
88775: PUSH
88776: LD_INT 3
88778: NEG
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: LD_INT 2
88789: NEG
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 3
88797: PUSH
88798: LD_INT 2
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 2
88807: PUSH
88808: LD_INT 3
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 2
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 3
88828: NEG
88829: PUSH
88830: LD_INT 1
88832: NEG
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88863: LD_ADDR_VAR 0 31
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: LD_INT 0
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 0
88880: PUSH
88881: LD_INT 1
88883: NEG
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 1
88891: PUSH
88892: LD_INT 0
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 1
88901: PUSH
88902: LD_INT 1
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 0
88911: PUSH
88912: LD_INT 1
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 1
88921: NEG
88922: PUSH
88923: LD_INT 0
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 1
88932: NEG
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: NEG
88945: PUSH
88946: LD_INT 2
88948: NEG
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 1
88956: PUSH
88957: LD_INT 1
88959: NEG
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 2
88967: PUSH
88968: LD_INT 0
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: LD_INT 2
88977: PUSH
88978: LD_INT 1
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: LD_INT 2
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 1
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: LD_INT 1
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 2
89028: NEG
89029: PUSH
89030: LD_INT 1
89032: NEG
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 2
89040: NEG
89041: PUSH
89042: LD_INT 2
89044: NEG
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 2
89052: NEG
89053: PUSH
89054: LD_INT 3
89056: NEG
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: PUSH
89062: LD_INT 2
89064: PUSH
89065: LD_INT 1
89067: NEG
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 3
89075: PUSH
89076: LD_INT 1
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 1
89085: PUSH
89086: LD_INT 3
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: LD_INT 1
89095: NEG
89096: PUSH
89097: LD_INT 2
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: PUSH
89104: LD_INT 3
89106: NEG
89107: PUSH
89108: LD_INT 2
89110: NEG
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89141: LD_ADDR_VAR 0 32
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 0
89158: PUSH
89159: LD_INT 1
89161: NEG
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 1
89169: PUSH
89170: LD_INT 0
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 1
89179: PUSH
89180: LD_INT 1
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 0
89189: PUSH
89190: LD_INT 1
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 1
89199: NEG
89200: PUSH
89201: LD_INT 0
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 1
89210: NEG
89211: PUSH
89212: LD_INT 1
89214: NEG
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 1
89222: NEG
89223: PUSH
89224: LD_INT 2
89226: NEG
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 0
89234: PUSH
89235: LD_INT 2
89237: NEG
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 1
89245: PUSH
89246: LD_INT 1
89248: NEG
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 2
89256: PUSH
89257: LD_INT 1
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 2
89266: PUSH
89267: LD_INT 2
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 1
89276: PUSH
89277: LD_INT 2
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 0
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 1
89296: NEG
89297: PUSH
89298: LD_INT 1
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 2
89307: NEG
89308: PUSH
89309: LD_INT 0
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 2
89318: NEG
89319: PUSH
89320: LD_INT 1
89322: NEG
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 1
89330: NEG
89331: PUSH
89332: LD_INT 3
89334: NEG
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 2
89345: NEG
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 3
89353: PUSH
89354: LD_INT 2
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 2
89363: PUSH
89364: LD_INT 3
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 3
89384: NEG
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89419: LD_ADDR_VAR 0 33
89423: PUSH
89424: LD_INT 0
89426: PUSH
89427: LD_INT 0
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 0
89436: PUSH
89437: LD_INT 1
89439: NEG
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 1
89447: PUSH
89448: LD_INT 0
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 1
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: LD_INT 1
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 1
89488: NEG
89489: PUSH
89490: LD_INT 1
89492: NEG
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: LD_INT 2
89504: NEG
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: PUSH
89524: LD_INT 0
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 2
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 0
89553: PUSH
89554: LD_INT 2
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 1
89563: NEG
89564: PUSH
89565: LD_INT 1
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 2
89574: NEG
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 2
89585: NEG
89586: PUSH
89587: LD_INT 1
89589: NEG
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PUSH
89595: LD_INT 2
89597: NEG
89598: PUSH
89599: LD_INT 2
89601: NEG
89602: PUSH
89603: EMPTY
89604: LIST
89605: LIST
89606: PUSH
89607: LD_INT 2
89609: NEG
89610: PUSH
89611: LD_INT 3
89613: NEG
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 2
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 3
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 1
89642: PUSH
89643: LD_INT 3
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 1
89652: NEG
89653: PUSH
89654: LD_INT 2
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 3
89663: NEG
89664: PUSH
89665: LD_INT 2
89667: NEG
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89698: LD_ADDR_VAR 0 34
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: LD_INT 0
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: LD_INT 1
89718: NEG
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: LD_INT 1
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: LD_INT 1
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 1
89756: NEG
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: LD_INT 2
89783: NEG
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: LD_INT 2
89794: NEG
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: PUSH
89814: LD_INT 1
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 2
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 1
89833: PUSH
89834: LD_INT 2
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: NEG
89844: PUSH
89845: LD_INT 1
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 2
89854: NEG
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 2
89865: NEG
89866: PUSH
89867: LD_INT 1
89869: NEG
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 2
89877: NEG
89878: PUSH
89879: LD_INT 2
89881: NEG
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: LD_INT 3
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: PUSH
89902: LD_INT 2
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 3
89912: PUSH
89913: LD_INT 2
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: PUSH
89920: LD_INT 2
89922: PUSH
89923: LD_INT 3
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 2
89932: NEG
89933: PUSH
89934: LD_INT 1
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 3
89943: NEG
89944: PUSH
89945: LD_INT 1
89947: NEG
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89978: LD_ADDR_VAR 0 35
89982: PUSH
89983: LD_INT 0
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 0
89995: PUSH
89996: LD_INT 1
89998: NEG
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 1
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: LD_INT 1
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: LD_INT 1
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: LD_INT 0
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: LD_INT 1
90051: NEG
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 2
90059: PUSH
90060: LD_INT 1
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 2
90069: NEG
90070: PUSH
90071: LD_INT 1
90073: NEG
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90090: LD_ADDR_VAR 0 36
90094: PUSH
90095: LD_INT 0
90097: PUSH
90098: LD_INT 0
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: LD_INT 1
90110: NEG
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 1
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 1
90128: PUSH
90129: LD_INT 1
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 0
90138: PUSH
90139: LD_INT 1
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 1
90148: NEG
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 1
90159: NEG
90160: PUSH
90161: LD_INT 1
90163: NEG
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 1
90171: NEG
90172: PUSH
90173: LD_INT 2
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: LD_INT 2
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: EMPTY
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90202: LD_ADDR_VAR 0 37
90206: PUSH
90207: LD_INT 0
90209: PUSH
90210: LD_INT 0
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 0
90219: PUSH
90220: LD_INT 1
90222: NEG
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: LD_INT 0
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 1
90240: PUSH
90241: LD_INT 1
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 0
90250: PUSH
90251: LD_INT 1
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 1
90260: NEG
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 1
90271: NEG
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 1
90283: PUSH
90284: LD_INT 1
90286: NEG
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 1
90294: NEG
90295: PUSH
90296: LD_INT 1
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90314: LD_ADDR_VAR 0 38
90318: PUSH
90319: LD_INT 0
90321: PUSH
90322: LD_INT 0
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 0
90331: PUSH
90332: LD_INT 1
90334: NEG
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: LD_INT 0
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 1
90352: PUSH
90353: LD_INT 1
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PUSH
90360: LD_INT 0
90362: PUSH
90363: LD_INT 1
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: LD_INT 1
90372: NEG
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 1
90383: NEG
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 2
90395: PUSH
90396: LD_INT 1
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 2
90405: NEG
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90426: LD_ADDR_VAR 0 39
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 0
90443: PUSH
90444: LD_INT 1
90446: NEG
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 1
90464: PUSH
90465: LD_INT 1
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 1
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: LD_INT 0
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: LD_INT 1
90499: NEG
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: LD_INT 2
90511: NEG
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 1
90519: PUSH
90520: LD_INT 2
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90538: LD_ADDR_VAR 0 40
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: LD_INT 1
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: LD_INT 0
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 1
90576: PUSH
90577: LD_INT 1
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 0
90586: PUSH
90587: LD_INT 1
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 1
90596: NEG
90597: PUSH
90598: LD_INT 0
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 1
90607: NEG
90608: PUSH
90609: LD_INT 1
90611: NEG
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 1
90619: PUSH
90620: LD_INT 1
90622: NEG
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 1
90630: NEG
90631: PUSH
90632: LD_INT 1
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90650: LD_ADDR_VAR 0 41
90654: PUSH
90655: LD_INT 0
90657: PUSH
90658: LD_INT 0
90660: PUSH
90661: EMPTY
90662: LIST
90663: LIST
90664: PUSH
90665: LD_INT 0
90667: PUSH
90668: LD_INT 1
90670: NEG
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 1
90678: PUSH
90679: LD_INT 0
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 1
90688: PUSH
90689: LD_INT 1
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: LD_INT 1
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 1
90708: NEG
90709: PUSH
90710: LD_INT 0
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 1
90719: NEG
90720: PUSH
90721: LD_INT 1
90723: NEG
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 1
90731: NEG
90732: PUSH
90733: LD_INT 2
90735: NEG
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: PUSH
90744: LD_INT 1
90746: NEG
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 2
90754: PUSH
90755: LD_INT 0
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: LD_INT 1
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: LD_INT 2
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 1
90784: PUSH
90785: LD_INT 2
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: NEG
90795: PUSH
90796: LD_INT 1
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 2
90816: NEG
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 2
90828: NEG
90829: PUSH
90830: LD_INT 2
90832: NEG
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 2
90840: NEG
90841: PUSH
90842: LD_INT 3
90844: NEG
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 2
90852: PUSH
90853: LD_INT 1
90855: NEG
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 3
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 3
90873: PUSH
90874: LD_INT 1
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 3
90883: PUSH
90884: LD_INT 2
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 3
90893: PUSH
90894: LD_INT 3
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 2
90903: PUSH
90904: LD_INT 3
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 2
90913: NEG
90914: PUSH
90915: LD_INT 1
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 3
90924: NEG
90925: PUSH
90926: LD_INT 0
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 3
90935: NEG
90936: PUSH
90937: LD_INT 1
90939: NEG
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 3
90947: NEG
90948: PUSH
90949: LD_INT 2
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 3
90959: NEG
90960: PUSH
90961: LD_INT 3
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91000: LD_ADDR_VAR 0 42
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 0
91017: PUSH
91018: LD_INT 1
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: LD_INT 0
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: LD_INT 1
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 0
91048: PUSH
91049: LD_INT 1
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 1
91058: NEG
91059: PUSH
91060: LD_INT 0
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 1
91069: NEG
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 1
91081: NEG
91082: PUSH
91083: LD_INT 2
91085: NEG
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: LD_INT 2
91096: NEG
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 1
91104: PUSH
91105: LD_INT 1
91107: NEG
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 2
91115: PUSH
91116: LD_INT 1
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 2
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: LD_INT 2
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 0
91145: PUSH
91146: LD_INT 2
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: NEG
91156: PUSH
91157: LD_INT 1
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: LD_INT 2
91166: NEG
91167: PUSH
91168: LD_INT 1
91170: NEG
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 2
91178: NEG
91179: PUSH
91180: LD_INT 2
91182: NEG
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: LD_INT 2
91190: NEG
91191: PUSH
91192: LD_INT 3
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: NEG
91203: PUSH
91204: LD_INT 3
91206: NEG
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: LD_INT 2
91228: NEG
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 3
91236: PUSH
91237: LD_INT 2
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: LD_INT 3
91246: PUSH
91247: LD_INT 3
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: LD_INT 2
91256: PUSH
91257: LD_INT 3
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 1
91266: PUSH
91267: LD_INT 3
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: LD_INT 3
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 1
91286: NEG
91287: PUSH
91288: LD_INT 2
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 3
91297: NEG
91298: PUSH
91299: LD_INT 2
91301: NEG
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 3
91309: NEG
91310: PUSH
91311: LD_INT 3
91313: NEG
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91350: LD_ADDR_VAR 0 43
91354: PUSH
91355: LD_INT 0
91357: PUSH
91358: LD_INT 0
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 0
91367: PUSH
91368: LD_INT 1
91370: NEG
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: LD_INT 1
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 0
91398: PUSH
91399: LD_INT 1
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 1
91408: NEG
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: NEG
91420: PUSH
91421: LD_INT 1
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 1
91431: NEG
91432: PUSH
91433: LD_INT 2
91435: NEG
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 0
91443: PUSH
91444: LD_INT 2
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 1
91454: PUSH
91455: LD_INT 1
91457: NEG
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: PUSH
91463: LD_INT 2
91465: PUSH
91466: LD_INT 0
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: PUSH
91473: LD_INT 2
91475: PUSH
91476: LD_INT 1
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 1
91485: PUSH
91486: LD_INT 2
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 0
91495: PUSH
91496: LD_INT 2
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 1
91505: NEG
91506: PUSH
91507: LD_INT 1
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 2
91516: NEG
91517: PUSH
91518: LD_INT 0
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 2
91527: NEG
91528: PUSH
91529: LD_INT 1
91531: NEG
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 1
91539: NEG
91540: PUSH
91541: LD_INT 3
91543: NEG
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: LD_INT 0
91551: PUSH
91552: LD_INT 3
91554: NEG
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 1
91562: PUSH
91563: LD_INT 2
91565: NEG
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 2
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 3
91584: PUSH
91585: LD_INT 0
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 3
91594: PUSH
91595: LD_INT 1
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 1
91604: PUSH
91605: LD_INT 3
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 0
91614: PUSH
91615: LD_INT 3
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 2
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 2
91635: NEG
91636: PUSH
91637: LD_INT 1
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 3
91646: NEG
91647: PUSH
91648: LD_INT 0
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 3
91657: NEG
91658: PUSH
91659: LD_INT 1
91661: NEG
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91698: LD_ADDR_VAR 0 44
91702: PUSH
91703: LD_INT 0
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 0
91715: PUSH
91716: LD_INT 1
91718: NEG
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 1
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 1
91736: PUSH
91737: LD_INT 1
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 0
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 1
91756: NEG
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: LD_INT 2
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 1
91791: PUSH
91792: LD_INT 1
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 2
91802: PUSH
91803: LD_INT 0
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 2
91812: PUSH
91813: LD_INT 1
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 2
91822: PUSH
91823: LD_INT 2
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 1
91832: PUSH
91833: LD_INT 2
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 1
91842: NEG
91843: PUSH
91844: LD_INT 1
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 2
91853: NEG
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 2
91864: NEG
91865: PUSH
91866: LD_INT 1
91868: NEG
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: PUSH
91874: LD_INT 2
91876: NEG
91877: PUSH
91878: LD_INT 2
91880: NEG
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 2
91888: NEG
91889: PUSH
91890: LD_INT 3
91892: NEG
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 2
91900: PUSH
91901: LD_INT 1
91903: NEG
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 3
91911: PUSH
91912: LD_INT 0
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 3
91921: PUSH
91922: LD_INT 1
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 3
91931: PUSH
91932: LD_INT 2
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 3
91941: PUSH
91942: LD_INT 3
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 2
91951: PUSH
91952: LD_INT 3
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: PUSH
91959: LD_INT 2
91961: NEG
91962: PUSH
91963: LD_INT 1
91965: PUSH
91966: EMPTY
91967: LIST
91968: LIST
91969: PUSH
91970: LD_INT 3
91972: NEG
91973: PUSH
91974: LD_INT 0
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: NEG
91984: PUSH
91985: LD_INT 1
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 3
91995: NEG
91996: PUSH
91997: LD_INT 2
91999: NEG
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 3
92007: NEG
92008: PUSH
92009: LD_INT 3
92011: NEG
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92048: LD_ADDR_VAR 0 45
92052: PUSH
92053: LD_INT 0
92055: PUSH
92056: LD_INT 0
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 0
92065: PUSH
92066: LD_INT 1
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 1
92076: PUSH
92077: LD_INT 0
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 1
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 0
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 1
92106: NEG
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 1
92117: NEG
92118: PUSH
92119: LD_INT 1
92121: NEG
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 1
92129: NEG
92130: PUSH
92131: LD_INT 2
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 0
92141: PUSH
92142: LD_INT 2
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 1
92152: PUSH
92153: LD_INT 1
92155: NEG
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 2
92163: PUSH
92164: LD_INT 1
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: LD_INT 2
92173: PUSH
92174: LD_INT 2
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 1
92183: PUSH
92184: LD_INT 2
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 0
92193: PUSH
92194: LD_INT 2
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 1
92203: NEG
92204: PUSH
92205: LD_INT 1
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 2
92214: NEG
92215: PUSH
92216: LD_INT 1
92218: NEG
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 2
92226: NEG
92227: PUSH
92228: LD_INT 2
92230: NEG
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 2
92238: NEG
92239: PUSH
92240: LD_INT 3
92242: NEG
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: LD_INT 1
92250: NEG
92251: PUSH
92252: LD_INT 3
92254: NEG
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: PUSH
92260: LD_INT 0
92262: PUSH
92263: LD_INT 3
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 1
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 3
92284: PUSH
92285: LD_INT 2
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 3
92294: PUSH
92295: LD_INT 3
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 2
92304: PUSH
92305: LD_INT 3
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 1
92314: PUSH
92315: LD_INT 3
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: LD_INT 3
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 1
92334: NEG
92335: PUSH
92336: LD_INT 2
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: LD_INT 3
92345: NEG
92346: PUSH
92347: LD_INT 2
92349: NEG
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 3
92357: NEG
92358: PUSH
92359: LD_INT 3
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92398: LD_ADDR_VAR 0 46
92402: PUSH
92403: LD_INT 0
92405: PUSH
92406: LD_INT 0
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: LD_INT 0
92415: PUSH
92416: LD_INT 1
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 1
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 1
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 1
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: NEG
92457: PUSH
92458: LD_INT 0
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 1
92467: NEG
92468: PUSH
92469: LD_INT 1
92471: NEG
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 1
92479: NEG
92480: PUSH
92481: LD_INT 2
92483: NEG
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 0
92491: PUSH
92492: LD_INT 2
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 1
92502: PUSH
92503: LD_INT 1
92505: NEG
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 2
92513: PUSH
92514: LD_INT 0
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 2
92523: PUSH
92524: LD_INT 1
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 1
92533: PUSH
92534: LD_INT 2
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PUSH
92541: LD_INT 0
92543: PUSH
92544: LD_INT 2
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 1
92553: NEG
92554: PUSH
92555: LD_INT 1
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 2
92564: NEG
92565: PUSH
92566: LD_INT 0
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 2
92575: NEG
92576: PUSH
92577: LD_INT 1
92579: NEG
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 1
92587: NEG
92588: PUSH
92589: LD_INT 3
92591: NEG
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 0
92599: PUSH
92600: LD_INT 3
92602: NEG
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: LD_INT 2
92613: NEG
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 2
92621: PUSH
92622: LD_INT 1
92624: NEG
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 3
92632: PUSH
92633: LD_INT 0
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 3
92642: PUSH
92643: LD_INT 1
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 1
92652: PUSH
92653: LD_INT 3
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: LD_INT 3
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 1
92672: NEG
92673: PUSH
92674: LD_INT 2
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 2
92683: NEG
92684: PUSH
92685: LD_INT 1
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 3
92694: NEG
92695: PUSH
92696: LD_INT 0
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 3
92705: NEG
92706: PUSH
92707: LD_INT 1
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92746: LD_ADDR_VAR 0 47
92750: PUSH
92751: LD_INT 0
92753: PUSH
92754: LD_INT 0
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 0
92763: PUSH
92764: LD_INT 1
92766: NEG
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: LD_INT 1
92774: PUSH
92775: LD_INT 0
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: LD_INT 1
92784: PUSH
92785: LD_INT 1
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 0
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 1
92804: NEG
92805: PUSH
92806: LD_INT 0
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 1
92815: NEG
92816: PUSH
92817: LD_INT 1
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 1
92827: NEG
92828: PUSH
92829: LD_INT 2
92831: NEG
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: LD_INT 2
92842: NEG
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 1
92850: PUSH
92851: LD_INT 1
92853: NEG
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 2
92861: NEG
92862: PUSH
92863: LD_INT 1
92865: NEG
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 2
92873: NEG
92874: PUSH
92875: LD_INT 2
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92897: LD_ADDR_VAR 0 48
92901: PUSH
92902: LD_INT 0
92904: PUSH
92905: LD_INT 0
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: LD_INT 0
92914: PUSH
92915: LD_INT 1
92917: NEG
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 1
92925: PUSH
92926: LD_INT 0
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 1
92935: PUSH
92936: LD_INT 1
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 0
92945: PUSH
92946: LD_INT 1
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 1
92955: NEG
92956: PUSH
92957: LD_INT 0
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 1
92966: NEG
92967: PUSH
92968: LD_INT 1
92970: NEG
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 1
92978: NEG
92979: PUSH
92980: LD_INT 2
92982: NEG
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 0
92990: PUSH
92991: LD_INT 2
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 1
93001: PUSH
93002: LD_INT 1
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 2
93012: PUSH
93013: LD_INT 0
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 2
93022: PUSH
93023: LD_INT 1
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93044: LD_ADDR_VAR 0 49
93048: PUSH
93049: LD_INT 0
93051: PUSH
93052: LD_INT 0
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 0
93061: PUSH
93062: LD_INT 1
93064: NEG
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: LD_INT 1
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 1
93082: PUSH
93083: LD_INT 1
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_INT 1
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 1
93102: NEG
93103: PUSH
93104: LD_INT 0
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 1
93113: NEG
93114: PUSH
93115: LD_INT 1
93117: NEG
93118: PUSH
93119: EMPTY
93120: LIST
93121: LIST
93122: PUSH
93123: LD_INT 1
93125: PUSH
93126: LD_INT 1
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 2
93136: PUSH
93137: LD_INT 0
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 2
93146: PUSH
93147: LD_INT 1
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 2
93156: PUSH
93157: LD_INT 2
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: LD_INT 2
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93188: LD_ADDR_VAR 0 50
93192: PUSH
93193: LD_INT 0
93195: PUSH
93196: LD_INT 0
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: PUSH
93203: LD_INT 0
93205: PUSH
93206: LD_INT 1
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 1
93216: PUSH
93217: LD_INT 0
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 1
93226: PUSH
93227: LD_INT 1
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 0
93236: PUSH
93237: LD_INT 1
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 1
93246: NEG
93247: PUSH
93248: LD_INT 0
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 1
93257: NEG
93258: PUSH
93259: LD_INT 1
93261: NEG
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: LD_INT 2
93269: PUSH
93270: LD_INT 1
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: LD_INT 2
93279: PUSH
93280: LD_INT 2
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PUSH
93287: LD_INT 1
93289: PUSH
93290: LD_INT 2
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 0
93299: PUSH
93300: LD_INT 2
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 1
93309: NEG
93310: PUSH
93311: LD_INT 1
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93332: LD_ADDR_VAR 0 51
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 0
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 0
93349: PUSH
93350: LD_INT 1
93352: NEG
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 1
93360: PUSH
93361: LD_INT 0
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 1
93370: PUSH
93371: LD_INT 1
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: LD_INT 1
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 1
93401: NEG
93402: PUSH
93403: LD_INT 1
93405: NEG
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 1
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 1
93433: NEG
93434: PUSH
93435: LD_INT 1
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 2
93444: NEG
93445: PUSH
93446: LD_INT 0
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 2
93455: NEG
93456: PUSH
93457: LD_INT 1
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93479: LD_ADDR_VAR 0 52
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: LD_INT 0
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: LD_INT 0
93496: PUSH
93497: LD_INT 1
93499: NEG
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: LD_INT 0
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 1
93517: PUSH
93518: LD_INT 1
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 0
93527: PUSH
93528: LD_INT 1
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: LD_INT 0
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 1
93548: NEG
93549: PUSH
93550: LD_INT 1
93552: NEG
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: LD_INT 1
93560: NEG
93561: PUSH
93562: LD_INT 2
93564: NEG
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 1
93572: NEG
93573: PUSH
93574: LD_INT 1
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 2
93583: NEG
93584: PUSH
93585: LD_INT 0
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: LD_INT 1
93598: NEG
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 2
93606: NEG
93607: PUSH
93608: LD_INT 2
93610: NEG
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93630: LD_ADDR_VAR 0 53
93634: PUSH
93635: LD_INT 0
93637: PUSH
93638: LD_INT 0
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 0
93647: PUSH
93648: LD_INT 1
93650: NEG
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: PUSH
93656: LD_INT 1
93658: PUSH
93659: LD_INT 0
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: PUSH
93666: LD_INT 1
93668: PUSH
93669: LD_INT 1
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: LD_INT 0
93678: PUSH
93679: LD_INT 1
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 1
93688: NEG
93689: PUSH
93690: LD_INT 0
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 1
93699: NEG
93700: PUSH
93701: LD_INT 1
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 1
93711: NEG
93712: PUSH
93713: LD_INT 2
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 0
93723: PUSH
93724: LD_INT 2
93726: NEG
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 1
93734: PUSH
93735: LD_INT 1
93737: NEG
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 2
93745: PUSH
93746: LD_INT 0
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 2
93755: PUSH
93756: LD_INT 1
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 2
93765: PUSH
93766: LD_INT 2
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 1
93775: PUSH
93776: LD_INT 2
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 0
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 1
93795: NEG
93796: PUSH
93797: LD_INT 1
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 2
93806: NEG
93807: PUSH
93808: LD_INT 0
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 2
93817: NEG
93818: PUSH
93819: LD_INT 1
93821: NEG
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 2
93829: NEG
93830: PUSH
93831: LD_INT 2
93833: NEG
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93860: LD_ADDR_VAR 0 54
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: LD_INT 0
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 0
93877: PUSH
93878: LD_INT 1
93880: NEG
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: LD_INT 1
93888: PUSH
93889: LD_INT 0
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 1
93898: PUSH
93899: LD_INT 1
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: PUSH
93906: LD_INT 0
93908: PUSH
93909: LD_INT 1
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 1
93918: NEG
93919: PUSH
93920: LD_INT 0
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 1
93929: NEG
93930: PUSH
93931: LD_INT 1
93933: NEG
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PUSH
93939: LD_INT 1
93941: NEG
93942: PUSH
93943: LD_INT 2
93945: NEG
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 0
93953: PUSH
93954: LD_INT 2
93956: NEG
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 1
93964: PUSH
93965: LD_INT 1
93967: NEG
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 2
93975: PUSH
93976: LD_INT 0
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 2
93985: PUSH
93986: LD_INT 1
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: LD_INT 2
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 1
94005: PUSH
94006: LD_INT 2
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 0
94015: PUSH
94016: LD_INT 2
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 1
94025: NEG
94026: PUSH
94027: LD_INT 1
94029: PUSH
94030: EMPTY
94031: LIST
94032: LIST
94033: PUSH
94034: LD_INT 2
94036: NEG
94037: PUSH
94038: LD_INT 0
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 2
94047: NEG
94048: PUSH
94049: LD_INT 1
94051: NEG
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 2
94059: NEG
94060: PUSH
94061: LD_INT 2
94063: NEG
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94090: LD_ADDR_VAR 0 55
94094: PUSH
94095: LD_INT 0
94097: PUSH
94098: LD_INT 0
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: LD_INT 0
94107: PUSH
94108: LD_INT 1
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 1
94118: PUSH
94119: LD_INT 0
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 1
94128: PUSH
94129: LD_INT 1
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 0
94138: PUSH
94139: LD_INT 1
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 1
94148: NEG
94149: PUSH
94150: LD_INT 0
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 1
94159: NEG
94160: PUSH
94161: LD_INT 1
94163: NEG
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 1
94171: NEG
94172: PUSH
94173: LD_INT 2
94175: NEG
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 0
94183: PUSH
94184: LD_INT 2
94186: NEG
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 1
94194: PUSH
94195: LD_INT 1
94197: NEG
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 2
94205: PUSH
94206: LD_INT 0
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 2
94215: PUSH
94216: LD_INT 1
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 2
94225: PUSH
94226: LD_INT 2
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 1
94235: PUSH
94236: LD_INT 2
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 0
94245: PUSH
94246: LD_INT 2
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 1
94255: NEG
94256: PUSH
94257: LD_INT 1
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 2
94266: NEG
94267: PUSH
94268: LD_INT 0
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 2
94277: NEG
94278: PUSH
94279: LD_INT 1
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 2
94289: NEG
94290: PUSH
94291: LD_INT 2
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94320: LD_ADDR_VAR 0 56
94324: PUSH
94325: LD_INT 0
94327: PUSH
94328: LD_INT 0
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 0
94337: PUSH
94338: LD_INT 1
94340: NEG
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 1
94348: PUSH
94349: LD_INT 0
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 1
94358: PUSH
94359: LD_INT 1
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 0
94368: PUSH
94369: LD_INT 1
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 1
94378: NEG
94379: PUSH
94380: LD_INT 0
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: PUSH
94387: LD_INT 1
94389: NEG
94390: PUSH
94391: LD_INT 1
94393: NEG
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: PUSH
94399: LD_INT 1
94401: NEG
94402: PUSH
94403: LD_INT 2
94405: NEG
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 0
94413: PUSH
94414: LD_INT 2
94416: NEG
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 1
94424: PUSH
94425: LD_INT 1
94427: NEG
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 2
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 2
94445: PUSH
94446: LD_INT 1
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 2
94455: PUSH
94456: LD_INT 2
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 1
94465: PUSH
94466: LD_INT 2
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 0
94475: PUSH
94476: LD_INT 2
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 1
94485: NEG
94486: PUSH
94487: LD_INT 1
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 2
94496: NEG
94497: PUSH
94498: LD_INT 0
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 2
94507: NEG
94508: PUSH
94509: LD_INT 1
94511: NEG
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 2
94519: NEG
94520: PUSH
94521: LD_INT 2
94523: NEG
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94550: LD_ADDR_VAR 0 57
94554: PUSH
94555: LD_INT 0
94557: PUSH
94558: LD_INT 0
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 0
94567: PUSH
94568: LD_INT 1
94570: NEG
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 1
94578: PUSH
94579: LD_INT 0
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: LD_INT 1
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 0
94598: PUSH
94599: LD_INT 1
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 1
94608: NEG
94609: PUSH
94610: LD_INT 0
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 1
94619: NEG
94620: PUSH
94621: LD_INT 1
94623: NEG
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 1
94631: NEG
94632: PUSH
94633: LD_INT 2
94635: NEG
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 0
94643: PUSH
94644: LD_INT 2
94646: NEG
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 1
94654: PUSH
94655: LD_INT 1
94657: NEG
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 2
94665: PUSH
94666: LD_INT 0
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: LD_INT 2
94675: PUSH
94676: LD_INT 1
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 2
94685: PUSH
94686: LD_INT 2
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 1
94695: PUSH
94696: LD_INT 2
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 0
94705: PUSH
94706: LD_INT 2
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: PUSH
94713: LD_INT 1
94715: NEG
94716: PUSH
94717: LD_INT 1
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 2
94726: NEG
94727: PUSH
94728: LD_INT 0
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 2
94737: NEG
94738: PUSH
94739: LD_INT 1
94741: NEG
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 2
94749: NEG
94750: PUSH
94751: LD_INT 2
94753: NEG
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94780: LD_ADDR_VAR 0 58
94784: PUSH
94785: LD_INT 0
94787: PUSH
94788: LD_INT 0
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: LD_INT 0
94797: PUSH
94798: LD_INT 1
94800: NEG
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: LD_INT 1
94808: PUSH
94809: LD_INT 0
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 1
94818: PUSH
94819: LD_INT 1
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 0
94828: PUSH
94829: LD_INT 1
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 1
94838: NEG
94839: PUSH
94840: LD_INT 0
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 1
94849: NEG
94850: PUSH
94851: LD_INT 1
94853: NEG
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 1
94861: NEG
94862: PUSH
94863: LD_INT 2
94865: NEG
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 0
94873: PUSH
94874: LD_INT 2
94876: NEG
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 1
94884: PUSH
94885: LD_INT 1
94887: NEG
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 2
94895: PUSH
94896: LD_INT 0
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: LD_INT 2
94905: PUSH
94906: LD_INT 1
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 2
94915: PUSH
94916: LD_INT 2
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: LD_INT 1
94925: PUSH
94926: LD_INT 2
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: PUSH
94933: LD_INT 0
94935: PUSH
94936: LD_INT 2
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: PUSH
94943: LD_INT 1
94945: NEG
94946: PUSH
94947: LD_INT 1
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PUSH
94954: LD_INT 2
94956: NEG
94957: PUSH
94958: LD_INT 0
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 2
94967: NEG
94968: PUSH
94969: LD_INT 1
94971: NEG
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 2
94979: NEG
94980: PUSH
94981: LD_INT 2
94983: NEG
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95010: LD_ADDR_VAR 0 59
95014: PUSH
95015: LD_INT 0
95017: PUSH
95018: LD_INT 0
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 0
95027: PUSH
95028: LD_INT 1
95030: NEG
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 1
95038: PUSH
95039: LD_INT 0
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 1
95048: PUSH
95049: LD_INT 1
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 0
95058: PUSH
95059: LD_INT 1
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: PUSH
95066: LD_INT 1
95068: NEG
95069: PUSH
95070: LD_INT 0
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 1
95079: NEG
95080: PUSH
95081: LD_INT 1
95083: NEG
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95098: LD_ADDR_VAR 0 60
95102: PUSH
95103: LD_INT 0
95105: PUSH
95106: LD_INT 0
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 0
95115: PUSH
95116: LD_INT 1
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 1
95126: PUSH
95127: LD_INT 0
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 1
95136: PUSH
95137: LD_INT 1
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 0
95146: PUSH
95147: LD_INT 1
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PUSH
95154: LD_INT 1
95156: NEG
95157: PUSH
95158: LD_INT 0
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 1
95167: NEG
95168: PUSH
95169: LD_INT 1
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95186: LD_ADDR_VAR 0 61
95190: PUSH
95191: LD_INT 0
95193: PUSH
95194: LD_INT 0
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 0
95203: PUSH
95204: LD_INT 1
95206: NEG
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 1
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 1
95224: PUSH
95225: LD_INT 1
95227: PUSH
95228: EMPTY
95229: LIST
95230: LIST
95231: PUSH
95232: LD_INT 0
95234: PUSH
95235: LD_INT 1
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: PUSH
95242: LD_INT 1
95244: NEG
95245: PUSH
95246: LD_INT 0
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 1
95255: NEG
95256: PUSH
95257: LD_INT 1
95259: NEG
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95274: LD_ADDR_VAR 0 62
95278: PUSH
95279: LD_INT 0
95281: PUSH
95282: LD_INT 0
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 0
95291: PUSH
95292: LD_INT 1
95294: NEG
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 1
95302: PUSH
95303: LD_INT 0
95305: PUSH
95306: EMPTY
95307: LIST
95308: LIST
95309: PUSH
95310: LD_INT 1
95312: PUSH
95313: LD_INT 1
95315: PUSH
95316: EMPTY
95317: LIST
95318: LIST
95319: PUSH
95320: LD_INT 0
95322: PUSH
95323: LD_INT 1
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: PUSH
95330: LD_INT 1
95332: NEG
95333: PUSH
95334: LD_INT 0
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: PUSH
95341: LD_INT 1
95343: NEG
95344: PUSH
95345: LD_INT 1
95347: NEG
95348: PUSH
95349: EMPTY
95350: LIST
95351: LIST
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95362: LD_ADDR_VAR 0 63
95366: PUSH
95367: LD_INT 0
95369: PUSH
95370: LD_INT 0
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 0
95379: PUSH
95380: LD_INT 1
95382: NEG
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 1
95390: PUSH
95391: LD_INT 0
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: LD_INT 1
95400: PUSH
95401: LD_INT 1
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 0
95410: PUSH
95411: LD_INT 1
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 1
95420: NEG
95421: PUSH
95422: LD_INT 0
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 1
95431: NEG
95432: PUSH
95433: LD_INT 1
95435: NEG
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95450: LD_ADDR_VAR 0 64
95454: PUSH
95455: LD_INT 0
95457: PUSH
95458: LD_INT 0
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 0
95467: PUSH
95468: LD_INT 1
95470: NEG
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 1
95478: PUSH
95479: LD_INT 0
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 1
95488: PUSH
95489: LD_INT 1
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 0
95498: PUSH
95499: LD_INT 1
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: PUSH
95506: LD_INT 1
95508: NEG
95509: PUSH
95510: LD_INT 0
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: PUSH
95517: LD_INT 1
95519: NEG
95520: PUSH
95521: LD_INT 1
95523: NEG
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: ST_TO_ADDR
// end ; 1 :
95538: GO 101435
95540: LD_INT 1
95542: DOUBLE
95543: EQUAL
95544: IFTRUE 95548
95546: GO 98171
95548: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95549: LD_ADDR_VAR 0 11
95553: PUSH
95554: LD_INT 1
95556: NEG
95557: PUSH
95558: LD_INT 3
95560: NEG
95561: PUSH
95562: EMPTY
95563: LIST
95564: LIST
95565: PUSH
95566: LD_INT 0
95568: PUSH
95569: LD_INT 3
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 1
95579: PUSH
95580: LD_INT 2
95582: NEG
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: LIST
95592: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95593: LD_ADDR_VAR 0 12
95597: PUSH
95598: LD_INT 2
95600: PUSH
95601: LD_INT 1
95603: NEG
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 3
95611: PUSH
95612: LD_INT 0
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 3
95621: PUSH
95622: LD_INT 1
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: LIST
95633: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95634: LD_ADDR_VAR 0 13
95638: PUSH
95639: LD_INT 3
95641: PUSH
95642: LD_INT 2
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 3
95651: PUSH
95652: LD_INT 3
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: PUSH
95659: LD_INT 2
95661: PUSH
95662: LD_INT 3
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: LIST
95673: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95674: LD_ADDR_VAR 0 14
95678: PUSH
95679: LD_INT 1
95681: PUSH
95682: LD_INT 3
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 0
95691: PUSH
95692: LD_INT 3
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 1
95701: NEG
95702: PUSH
95703: LD_INT 2
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: LIST
95714: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95715: LD_ADDR_VAR 0 15
95719: PUSH
95720: LD_INT 2
95722: NEG
95723: PUSH
95724: LD_INT 1
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 3
95733: NEG
95734: PUSH
95735: LD_INT 0
95737: PUSH
95738: EMPTY
95739: LIST
95740: LIST
95741: PUSH
95742: LD_INT 3
95744: NEG
95745: PUSH
95746: LD_INT 1
95748: NEG
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: LIST
95758: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95759: LD_ADDR_VAR 0 16
95763: PUSH
95764: LD_INT 2
95766: NEG
95767: PUSH
95768: LD_INT 3
95770: NEG
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: PUSH
95776: LD_INT 3
95778: NEG
95779: PUSH
95780: LD_INT 2
95782: NEG
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 3
95790: NEG
95791: PUSH
95792: LD_INT 3
95794: NEG
95795: PUSH
95796: EMPTY
95797: LIST
95798: LIST
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: LIST
95804: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95805: LD_ADDR_VAR 0 17
95809: PUSH
95810: LD_INT 1
95812: NEG
95813: PUSH
95814: LD_INT 3
95816: NEG
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: LD_INT 3
95827: NEG
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 1
95835: PUSH
95836: LD_INT 2
95838: NEG
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: LIST
95848: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95849: LD_ADDR_VAR 0 18
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 1
95859: NEG
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 3
95867: PUSH
95868: LD_INT 0
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: PUSH
95878: LD_INT 1
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: LIST
95889: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95890: LD_ADDR_VAR 0 19
95894: PUSH
95895: LD_INT 3
95897: PUSH
95898: LD_INT 2
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 3
95907: PUSH
95908: LD_INT 3
95910: PUSH
95911: EMPTY
95912: LIST
95913: LIST
95914: PUSH
95915: LD_INT 2
95917: PUSH
95918: LD_INT 3
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: LIST
95929: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95930: LD_ADDR_VAR 0 20
95934: PUSH
95935: LD_INT 1
95937: PUSH
95938: LD_INT 3
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: PUSH
95945: LD_INT 0
95947: PUSH
95948: LD_INT 3
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 1
95957: NEG
95958: PUSH
95959: LD_INT 2
95961: PUSH
95962: EMPTY
95963: LIST
95964: LIST
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: LIST
95970: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95971: LD_ADDR_VAR 0 21
95975: PUSH
95976: LD_INT 2
95978: NEG
95979: PUSH
95980: LD_INT 1
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 3
95989: NEG
95990: PUSH
95991: LD_INT 0
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 3
96000: NEG
96001: PUSH
96002: LD_INT 1
96004: NEG
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: LIST
96014: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96015: LD_ADDR_VAR 0 22
96019: PUSH
96020: LD_INT 2
96022: NEG
96023: PUSH
96024: LD_INT 3
96026: NEG
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: LD_INT 3
96034: NEG
96035: PUSH
96036: LD_INT 2
96038: NEG
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: PUSH
96044: LD_INT 3
96046: NEG
96047: PUSH
96048: LD_INT 3
96050: NEG
96051: PUSH
96052: EMPTY
96053: LIST
96054: LIST
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: LIST
96060: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96061: LD_ADDR_VAR 0 23
96065: PUSH
96066: LD_INT 0
96068: PUSH
96069: LD_INT 3
96071: NEG
96072: PUSH
96073: EMPTY
96074: LIST
96075: LIST
96076: PUSH
96077: LD_INT 1
96079: NEG
96080: PUSH
96081: LD_INT 4
96083: NEG
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 1
96091: PUSH
96092: LD_INT 3
96094: NEG
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: LIST
96104: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96105: LD_ADDR_VAR 0 24
96109: PUSH
96110: LD_INT 3
96112: PUSH
96113: LD_INT 0
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 3
96122: PUSH
96123: LD_INT 1
96125: NEG
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: PUSH
96131: LD_INT 4
96133: PUSH
96134: LD_INT 1
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: LIST
96145: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96146: LD_ADDR_VAR 0 25
96150: PUSH
96151: LD_INT 3
96153: PUSH
96154: LD_INT 3
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 4
96163: PUSH
96164: LD_INT 3
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 3
96173: PUSH
96174: LD_INT 4
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: LIST
96185: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96186: LD_ADDR_VAR 0 26
96190: PUSH
96191: LD_INT 0
96193: PUSH
96194: LD_INT 3
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 1
96203: PUSH
96204: LD_INT 4
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 1
96213: NEG
96214: PUSH
96215: LD_INT 3
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: LIST
96226: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96227: LD_ADDR_VAR 0 27
96231: PUSH
96232: LD_INT 3
96234: NEG
96235: PUSH
96236: LD_INT 0
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: PUSH
96243: LD_INT 3
96245: NEG
96246: PUSH
96247: LD_INT 1
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: PUSH
96254: LD_INT 4
96256: NEG
96257: PUSH
96258: LD_INT 1
96260: NEG
96261: PUSH
96262: EMPTY
96263: LIST
96264: LIST
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: LIST
96270: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96271: LD_ADDR_VAR 0 28
96275: PUSH
96276: LD_INT 3
96278: NEG
96279: PUSH
96280: LD_INT 3
96282: NEG
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PUSH
96288: LD_INT 3
96290: NEG
96291: PUSH
96292: LD_INT 4
96294: NEG
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: PUSH
96300: LD_INT 4
96302: NEG
96303: PUSH
96304: LD_INT 3
96306: NEG
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: LIST
96316: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96317: LD_ADDR_VAR 0 29
96321: PUSH
96322: LD_INT 1
96324: NEG
96325: PUSH
96326: LD_INT 3
96328: NEG
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 0
96336: PUSH
96337: LD_INT 3
96339: NEG
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: PUSH
96345: LD_INT 1
96347: PUSH
96348: LD_INT 2
96350: NEG
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 1
96358: NEG
96359: PUSH
96360: LD_INT 4
96362: NEG
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: LD_INT 0
96370: PUSH
96371: LD_INT 4
96373: NEG
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: LD_INT 1
96381: PUSH
96382: LD_INT 3
96384: NEG
96385: PUSH
96386: EMPTY
96387: LIST
96388: LIST
96389: PUSH
96390: LD_INT 1
96392: NEG
96393: PUSH
96394: LD_INT 5
96396: NEG
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 0
96404: PUSH
96405: LD_INT 5
96407: NEG
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 1
96415: PUSH
96416: LD_INT 4
96418: NEG
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 1
96426: NEG
96427: PUSH
96428: LD_INT 6
96430: NEG
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: LD_INT 0
96438: PUSH
96439: LD_INT 6
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 1
96449: PUSH
96450: LD_INT 5
96452: NEG
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96472: LD_ADDR_VAR 0 30
96476: PUSH
96477: LD_INT 2
96479: PUSH
96480: LD_INT 1
96482: NEG
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: LD_INT 3
96490: PUSH
96491: LD_INT 0
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 3
96500: PUSH
96501: LD_INT 1
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: PUSH
96508: LD_INT 3
96510: PUSH
96511: LD_INT 1
96513: NEG
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 4
96521: PUSH
96522: LD_INT 0
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 4
96531: PUSH
96532: LD_INT 1
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 4
96541: PUSH
96542: LD_INT 1
96544: NEG
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 5
96552: PUSH
96553: LD_INT 0
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 5
96562: PUSH
96563: LD_INT 1
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 5
96572: PUSH
96573: LD_INT 1
96575: NEG
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 6
96583: PUSH
96584: LD_INT 0
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 6
96593: PUSH
96594: LD_INT 1
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96615: LD_ADDR_VAR 0 31
96619: PUSH
96620: LD_INT 3
96622: PUSH
96623: LD_INT 2
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 3
96632: PUSH
96633: LD_INT 3
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 2
96642: PUSH
96643: LD_INT 3
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: LD_INT 4
96652: PUSH
96653: LD_INT 3
96655: PUSH
96656: EMPTY
96657: LIST
96658: LIST
96659: PUSH
96660: LD_INT 4
96662: PUSH
96663: LD_INT 4
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 3
96672: PUSH
96673: LD_INT 4
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 5
96682: PUSH
96683: LD_INT 4
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 5
96692: PUSH
96693: LD_INT 5
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 4
96702: PUSH
96703: LD_INT 5
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PUSH
96710: LD_INT 6
96712: PUSH
96713: LD_INT 5
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 6
96722: PUSH
96723: LD_INT 6
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 5
96732: PUSH
96733: LD_INT 6
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96754: LD_ADDR_VAR 0 32
96758: PUSH
96759: LD_INT 1
96761: PUSH
96762: LD_INT 3
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 0
96771: PUSH
96772: LD_INT 3
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PUSH
96779: LD_INT 1
96781: NEG
96782: PUSH
96783: LD_INT 2
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PUSH
96790: LD_INT 1
96792: PUSH
96793: LD_INT 4
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: PUSH
96800: LD_INT 0
96802: PUSH
96803: LD_INT 4
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: PUSH
96810: LD_INT 1
96812: NEG
96813: PUSH
96814: LD_INT 3
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 1
96823: PUSH
96824: LD_INT 5
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 0
96833: PUSH
96834: LD_INT 5
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 1
96843: NEG
96844: PUSH
96845: LD_INT 4
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 1
96854: PUSH
96855: LD_INT 6
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 0
96864: PUSH
96865: LD_INT 6
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: PUSH
96872: LD_INT 1
96874: NEG
96875: PUSH
96876: LD_INT 5
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
96897: LD_ADDR_VAR 0 33
96901: PUSH
96902: LD_INT 2
96904: NEG
96905: PUSH
96906: LD_INT 1
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 3
96915: NEG
96916: PUSH
96917: LD_INT 0
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 3
96926: NEG
96927: PUSH
96928: LD_INT 1
96930: NEG
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 3
96938: NEG
96939: PUSH
96940: LD_INT 1
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: LD_INT 4
96949: NEG
96950: PUSH
96951: LD_INT 0
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 4
96960: NEG
96961: PUSH
96962: LD_INT 1
96964: NEG
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_INT 4
96972: NEG
96973: PUSH
96974: LD_INT 1
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 5
96983: NEG
96984: PUSH
96985: LD_INT 0
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 5
96994: NEG
96995: PUSH
96996: LD_INT 1
96998: NEG
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 5
97006: NEG
97007: PUSH
97008: LD_INT 1
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 6
97017: NEG
97018: PUSH
97019: LD_INT 0
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 6
97028: NEG
97029: PUSH
97030: LD_INT 1
97032: NEG
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: EMPTY
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97052: LD_ADDR_VAR 0 34
97056: PUSH
97057: LD_INT 2
97059: NEG
97060: PUSH
97061: LD_INT 3
97063: NEG
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 3
97071: NEG
97072: PUSH
97073: LD_INT 2
97075: NEG
97076: PUSH
97077: EMPTY
97078: LIST
97079: LIST
97080: PUSH
97081: LD_INT 3
97083: NEG
97084: PUSH
97085: LD_INT 3
97087: NEG
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PUSH
97093: LD_INT 3
97095: NEG
97096: PUSH
97097: LD_INT 4
97099: NEG
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 4
97107: NEG
97108: PUSH
97109: LD_INT 3
97111: NEG
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 4
97119: NEG
97120: PUSH
97121: LD_INT 4
97123: NEG
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 4
97131: NEG
97132: PUSH
97133: LD_INT 5
97135: NEG
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 5
97143: NEG
97144: PUSH
97145: LD_INT 4
97147: NEG
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: PUSH
97153: LD_INT 5
97155: NEG
97156: PUSH
97157: LD_INT 5
97159: NEG
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 5
97167: NEG
97168: PUSH
97169: LD_INT 6
97171: NEG
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_INT 6
97179: NEG
97180: PUSH
97181: LD_INT 5
97183: NEG
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PUSH
97189: LD_INT 6
97191: NEG
97192: PUSH
97193: LD_INT 6
97195: NEG
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97215: LD_ADDR_VAR 0 41
97219: PUSH
97220: LD_INT 0
97222: PUSH
97223: LD_INT 2
97225: NEG
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: PUSH
97231: LD_INT 1
97233: NEG
97234: PUSH
97235: LD_INT 3
97237: NEG
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 1
97245: PUSH
97246: LD_INT 2
97248: NEG
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: LIST
97258: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97259: LD_ADDR_VAR 0 42
97263: PUSH
97264: LD_INT 2
97266: PUSH
97267: LD_INT 0
97269: PUSH
97270: EMPTY
97271: LIST
97272: LIST
97273: PUSH
97274: LD_INT 2
97276: PUSH
97277: LD_INT 1
97279: NEG
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 3
97287: PUSH
97288: LD_INT 1
97290: PUSH
97291: EMPTY
97292: LIST
97293: LIST
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: LIST
97299: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97300: LD_ADDR_VAR 0 43
97304: PUSH
97305: LD_INT 2
97307: PUSH
97308: LD_INT 2
97310: PUSH
97311: EMPTY
97312: LIST
97313: LIST
97314: PUSH
97315: LD_INT 3
97317: PUSH
97318: LD_INT 2
97320: PUSH
97321: EMPTY
97322: LIST
97323: LIST
97324: PUSH
97325: LD_INT 2
97327: PUSH
97328: LD_INT 3
97330: PUSH
97331: EMPTY
97332: LIST
97333: LIST
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: LIST
97339: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97340: LD_ADDR_VAR 0 44
97344: PUSH
97345: LD_INT 0
97347: PUSH
97348: LD_INT 2
97350: PUSH
97351: EMPTY
97352: LIST
97353: LIST
97354: PUSH
97355: LD_INT 1
97357: PUSH
97358: LD_INT 3
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 1
97367: NEG
97368: PUSH
97369: LD_INT 2
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: LIST
97380: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97381: LD_ADDR_VAR 0 45
97385: PUSH
97386: LD_INT 2
97388: NEG
97389: PUSH
97390: LD_INT 0
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 2
97399: NEG
97400: PUSH
97401: LD_INT 1
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 3
97410: NEG
97411: PUSH
97412: LD_INT 1
97414: NEG
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: LIST
97424: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97425: LD_ADDR_VAR 0 46
97429: PUSH
97430: LD_INT 2
97432: NEG
97433: PUSH
97434: LD_INT 2
97436: NEG
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 2
97444: NEG
97445: PUSH
97446: LD_INT 3
97448: NEG
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PUSH
97454: LD_INT 3
97456: NEG
97457: PUSH
97458: LD_INT 2
97460: NEG
97461: PUSH
97462: EMPTY
97463: LIST
97464: LIST
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: LIST
97470: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97471: LD_ADDR_VAR 0 47
97475: PUSH
97476: LD_INT 2
97478: NEG
97479: PUSH
97480: LD_INT 3
97482: NEG
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 1
97490: NEG
97491: PUSH
97492: LD_INT 3
97494: NEG
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97504: LD_ADDR_VAR 0 48
97508: PUSH
97509: LD_INT 1
97511: PUSH
97512: LD_INT 2
97514: NEG
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 2
97522: PUSH
97523: LD_INT 1
97525: NEG
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97535: LD_ADDR_VAR 0 49
97539: PUSH
97540: LD_INT 3
97542: PUSH
97543: LD_INT 1
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 3
97552: PUSH
97553: LD_INT 2
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97564: LD_ADDR_VAR 0 50
97568: PUSH
97569: LD_INT 2
97571: PUSH
97572: LD_INT 3
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: LD_INT 1
97581: PUSH
97582: LD_INT 3
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97593: LD_ADDR_VAR 0 51
97597: PUSH
97598: LD_INT 1
97600: NEG
97601: PUSH
97602: LD_INT 2
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: LD_INT 2
97611: NEG
97612: PUSH
97613: LD_INT 1
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97624: LD_ADDR_VAR 0 52
97628: PUSH
97629: LD_INT 3
97631: NEG
97632: PUSH
97633: LD_INT 1
97635: NEG
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 3
97643: NEG
97644: PUSH
97645: LD_INT 2
97647: NEG
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97657: LD_ADDR_VAR 0 53
97661: PUSH
97662: LD_INT 1
97664: NEG
97665: PUSH
97666: LD_INT 3
97668: NEG
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: PUSH
97674: LD_INT 0
97676: PUSH
97677: LD_INT 3
97679: NEG
97680: PUSH
97681: EMPTY
97682: LIST
97683: LIST
97684: PUSH
97685: LD_INT 1
97687: PUSH
97688: LD_INT 2
97690: NEG
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: LIST
97700: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97701: LD_ADDR_VAR 0 54
97705: PUSH
97706: LD_INT 2
97708: PUSH
97709: LD_INT 1
97711: NEG
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: PUSH
97717: LD_INT 3
97719: PUSH
97720: LD_INT 0
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: PUSH
97727: LD_INT 3
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: LIST
97741: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97742: LD_ADDR_VAR 0 55
97746: PUSH
97747: LD_INT 3
97749: PUSH
97750: LD_INT 2
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: PUSH
97757: LD_INT 3
97759: PUSH
97760: LD_INT 3
97762: PUSH
97763: EMPTY
97764: LIST
97765: LIST
97766: PUSH
97767: LD_INT 2
97769: PUSH
97770: LD_INT 3
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: PUSH
97777: EMPTY
97778: LIST
97779: LIST
97780: LIST
97781: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97782: LD_ADDR_VAR 0 56
97786: PUSH
97787: LD_INT 1
97789: PUSH
97790: LD_INT 3
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 0
97799: PUSH
97800: LD_INT 3
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: LD_INT 1
97809: NEG
97810: PUSH
97811: LD_INT 2
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: LIST
97822: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97823: LD_ADDR_VAR 0 57
97827: PUSH
97828: LD_INT 2
97830: NEG
97831: PUSH
97832: LD_INT 1
97834: PUSH
97835: EMPTY
97836: LIST
97837: LIST
97838: PUSH
97839: LD_INT 3
97841: NEG
97842: PUSH
97843: LD_INT 0
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: PUSH
97850: LD_INT 3
97852: NEG
97853: PUSH
97854: LD_INT 1
97856: NEG
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: LIST
97866: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97867: LD_ADDR_VAR 0 58
97871: PUSH
97872: LD_INT 2
97874: NEG
97875: PUSH
97876: LD_INT 3
97878: NEG
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: PUSH
97884: LD_INT 3
97886: NEG
97887: PUSH
97888: LD_INT 2
97890: NEG
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: LD_INT 3
97898: NEG
97899: PUSH
97900: LD_INT 3
97902: NEG
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: LIST
97912: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
97913: LD_ADDR_VAR 0 59
97917: PUSH
97918: LD_INT 1
97920: NEG
97921: PUSH
97922: LD_INT 2
97924: NEG
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 0
97932: PUSH
97933: LD_INT 2
97935: NEG
97936: PUSH
97937: EMPTY
97938: LIST
97939: LIST
97940: PUSH
97941: LD_INT 1
97943: PUSH
97944: LD_INT 1
97946: NEG
97947: PUSH
97948: EMPTY
97949: LIST
97950: LIST
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: LIST
97956: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
97957: LD_ADDR_VAR 0 60
97961: PUSH
97962: LD_INT 1
97964: PUSH
97965: LD_INT 1
97967: NEG
97968: PUSH
97969: EMPTY
97970: LIST
97971: LIST
97972: PUSH
97973: LD_INT 2
97975: PUSH
97976: LD_INT 0
97978: PUSH
97979: EMPTY
97980: LIST
97981: LIST
97982: PUSH
97983: LD_INT 2
97985: PUSH
97986: LD_INT 1
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: EMPTY
97994: LIST
97995: LIST
97996: LIST
97997: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
97998: LD_ADDR_VAR 0 61
98002: PUSH
98003: LD_INT 2
98005: PUSH
98006: LD_INT 1
98008: PUSH
98009: EMPTY
98010: LIST
98011: LIST
98012: PUSH
98013: LD_INT 2
98015: PUSH
98016: LD_INT 2
98018: PUSH
98019: EMPTY
98020: LIST
98021: LIST
98022: PUSH
98023: LD_INT 1
98025: PUSH
98026: LD_INT 2
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: LIST
98037: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98038: LD_ADDR_VAR 0 62
98042: PUSH
98043: LD_INT 1
98045: PUSH
98046: LD_INT 2
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: LD_INT 0
98055: PUSH
98056: LD_INT 2
98058: PUSH
98059: EMPTY
98060: LIST
98061: LIST
98062: PUSH
98063: LD_INT 1
98065: NEG
98066: PUSH
98067: LD_INT 1
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: EMPTY
98075: LIST
98076: LIST
98077: LIST
98078: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98079: LD_ADDR_VAR 0 63
98083: PUSH
98084: LD_INT 1
98086: NEG
98087: PUSH
98088: LD_INT 1
98090: PUSH
98091: EMPTY
98092: LIST
98093: LIST
98094: PUSH
98095: LD_INT 2
98097: NEG
98098: PUSH
98099: LD_INT 0
98101: PUSH
98102: EMPTY
98103: LIST
98104: LIST
98105: PUSH
98106: LD_INT 2
98108: NEG
98109: PUSH
98110: LD_INT 1
98112: NEG
98113: PUSH
98114: EMPTY
98115: LIST
98116: LIST
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: LIST
98122: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98123: LD_ADDR_VAR 0 64
98127: PUSH
98128: LD_INT 1
98130: NEG
98131: PUSH
98132: LD_INT 2
98134: NEG
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 2
98142: NEG
98143: PUSH
98144: LD_INT 1
98146: NEG
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: PUSH
98152: LD_INT 2
98154: NEG
98155: PUSH
98156: LD_INT 2
98158: NEG
98159: PUSH
98160: EMPTY
98161: LIST
98162: LIST
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: LIST
98168: ST_TO_ADDR
// end ; 2 :
98169: GO 101435
98171: LD_INT 2
98173: DOUBLE
98174: EQUAL
98175: IFTRUE 98179
98177: GO 101434
98179: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98180: LD_ADDR_VAR 0 29
98184: PUSH
98185: LD_INT 4
98187: PUSH
98188: LD_INT 0
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 4
98197: PUSH
98198: LD_INT 1
98200: NEG
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: LD_INT 5
98208: PUSH
98209: LD_INT 0
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: LD_INT 5
98218: PUSH
98219: LD_INT 1
98221: PUSH
98222: EMPTY
98223: LIST
98224: LIST
98225: PUSH
98226: LD_INT 4
98228: PUSH
98229: LD_INT 1
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PUSH
98236: LD_INT 3
98238: PUSH
98239: LD_INT 0
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: LD_INT 3
98248: PUSH
98249: LD_INT 1
98251: NEG
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: PUSH
98257: LD_INT 3
98259: PUSH
98260: LD_INT 2
98262: NEG
98263: PUSH
98264: EMPTY
98265: LIST
98266: LIST
98267: PUSH
98268: LD_INT 5
98270: PUSH
98271: LD_INT 2
98273: PUSH
98274: EMPTY
98275: LIST
98276: LIST
98277: PUSH
98278: LD_INT 3
98280: PUSH
98281: LD_INT 3
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: PUSH
98288: LD_INT 3
98290: PUSH
98291: LD_INT 2
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: PUSH
98298: LD_INT 4
98300: PUSH
98301: LD_INT 3
98303: PUSH
98304: EMPTY
98305: LIST
98306: LIST
98307: PUSH
98308: LD_INT 4
98310: PUSH
98311: LD_INT 4
98313: PUSH
98314: EMPTY
98315: LIST
98316: LIST
98317: PUSH
98318: LD_INT 3
98320: PUSH
98321: LD_INT 4
98323: PUSH
98324: EMPTY
98325: LIST
98326: LIST
98327: PUSH
98328: LD_INT 2
98330: PUSH
98331: LD_INT 3
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: PUSH
98338: LD_INT 2
98340: PUSH
98341: LD_INT 2
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: LD_INT 4
98350: PUSH
98351: LD_INT 2
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: PUSH
98358: LD_INT 2
98360: PUSH
98361: LD_INT 4
98363: PUSH
98364: EMPTY
98365: LIST
98366: LIST
98367: PUSH
98368: LD_INT 0
98370: PUSH
98371: LD_INT 4
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: PUSH
98378: LD_INT 0
98380: PUSH
98381: LD_INT 3
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: PUSH
98388: LD_INT 1
98390: PUSH
98391: LD_INT 4
98393: PUSH
98394: EMPTY
98395: LIST
98396: LIST
98397: PUSH
98398: LD_INT 1
98400: PUSH
98401: LD_INT 5
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: PUSH
98408: LD_INT 0
98410: PUSH
98411: LD_INT 5
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: LD_INT 1
98420: NEG
98421: PUSH
98422: LD_INT 4
98424: PUSH
98425: EMPTY
98426: LIST
98427: LIST
98428: PUSH
98429: LD_INT 1
98431: NEG
98432: PUSH
98433: LD_INT 3
98435: PUSH
98436: EMPTY
98437: LIST
98438: LIST
98439: PUSH
98440: LD_INT 2
98442: PUSH
98443: LD_INT 5
98445: PUSH
98446: EMPTY
98447: LIST
98448: LIST
98449: PUSH
98450: LD_INT 2
98452: NEG
98453: PUSH
98454: LD_INT 3
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PUSH
98461: LD_INT 3
98463: NEG
98464: PUSH
98465: LD_INT 0
98467: PUSH
98468: EMPTY
98469: LIST
98470: LIST
98471: PUSH
98472: LD_INT 3
98474: NEG
98475: PUSH
98476: LD_INT 1
98478: NEG
98479: PUSH
98480: EMPTY
98481: LIST
98482: LIST
98483: PUSH
98484: LD_INT 2
98486: NEG
98487: PUSH
98488: LD_INT 0
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PUSH
98495: LD_INT 2
98497: NEG
98498: PUSH
98499: LD_INT 1
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PUSH
98506: LD_INT 3
98508: NEG
98509: PUSH
98510: LD_INT 1
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 4
98519: NEG
98520: PUSH
98521: LD_INT 0
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: PUSH
98528: LD_INT 4
98530: NEG
98531: PUSH
98532: LD_INT 1
98534: NEG
98535: PUSH
98536: EMPTY
98537: LIST
98538: LIST
98539: PUSH
98540: LD_INT 4
98542: NEG
98543: PUSH
98544: LD_INT 2
98546: NEG
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: PUSH
98552: LD_INT 2
98554: NEG
98555: PUSH
98556: LD_INT 2
98558: PUSH
98559: EMPTY
98560: LIST
98561: LIST
98562: PUSH
98563: LD_INT 4
98565: NEG
98566: PUSH
98567: LD_INT 4
98569: NEG
98570: PUSH
98571: EMPTY
98572: LIST
98573: LIST
98574: PUSH
98575: LD_INT 4
98577: NEG
98578: PUSH
98579: LD_INT 5
98581: NEG
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: LD_INT 3
98589: NEG
98590: PUSH
98591: LD_INT 4
98593: NEG
98594: PUSH
98595: EMPTY
98596: LIST
98597: LIST
98598: PUSH
98599: LD_INT 3
98601: NEG
98602: PUSH
98603: LD_INT 3
98605: NEG
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: PUSH
98611: LD_INT 4
98613: NEG
98614: PUSH
98615: LD_INT 3
98617: NEG
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: PUSH
98623: LD_INT 5
98625: NEG
98626: PUSH
98627: LD_INT 4
98629: NEG
98630: PUSH
98631: EMPTY
98632: LIST
98633: LIST
98634: PUSH
98635: LD_INT 5
98637: NEG
98638: PUSH
98639: LD_INT 5
98641: NEG
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PUSH
98647: LD_INT 3
98649: NEG
98650: PUSH
98651: LD_INT 5
98653: NEG
98654: PUSH
98655: EMPTY
98656: LIST
98657: LIST
98658: PUSH
98659: LD_INT 5
98661: NEG
98662: PUSH
98663: LD_INT 3
98665: NEG
98666: PUSH
98667: EMPTY
98668: LIST
98669: LIST
98670: PUSH
98671: EMPTY
98672: LIST
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: LIST
98685: LIST
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98718: LD_ADDR_VAR 0 30
98722: PUSH
98723: LD_INT 4
98725: PUSH
98726: LD_INT 4
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: LD_INT 4
98735: PUSH
98736: LD_INT 3
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: LD_INT 5
98745: PUSH
98746: LD_INT 4
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: PUSH
98753: LD_INT 5
98755: PUSH
98756: LD_INT 5
98758: PUSH
98759: EMPTY
98760: LIST
98761: LIST
98762: PUSH
98763: LD_INT 4
98765: PUSH
98766: LD_INT 5
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PUSH
98773: LD_INT 3
98775: PUSH
98776: LD_INT 4
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: PUSH
98783: LD_INT 3
98785: PUSH
98786: LD_INT 3
98788: PUSH
98789: EMPTY
98790: LIST
98791: LIST
98792: PUSH
98793: LD_INT 5
98795: PUSH
98796: LD_INT 3
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 3
98805: PUSH
98806: LD_INT 5
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: LD_INT 0
98815: PUSH
98816: LD_INT 3
98818: PUSH
98819: EMPTY
98820: LIST
98821: LIST
98822: PUSH
98823: LD_INT 0
98825: PUSH
98826: LD_INT 2
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: PUSH
98833: LD_INT 1
98835: PUSH
98836: LD_INT 3
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: PUSH
98843: LD_INT 1
98845: PUSH
98846: LD_INT 4
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: LD_INT 0
98855: PUSH
98856: LD_INT 4
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 1
98865: NEG
98866: PUSH
98867: LD_INT 3
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PUSH
98874: LD_INT 1
98876: NEG
98877: PUSH
98878: LD_INT 2
98880: PUSH
98881: EMPTY
98882: LIST
98883: LIST
98884: PUSH
98885: LD_INT 2
98887: PUSH
98888: LD_INT 4
98890: PUSH
98891: EMPTY
98892: LIST
98893: LIST
98894: PUSH
98895: LD_INT 2
98897: NEG
98898: PUSH
98899: LD_INT 2
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: LD_INT 4
98908: NEG
98909: PUSH
98910: LD_INT 0
98912: PUSH
98913: EMPTY
98914: LIST
98915: LIST
98916: PUSH
98917: LD_INT 4
98919: NEG
98920: PUSH
98921: LD_INT 1
98923: NEG
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: PUSH
98929: LD_INT 3
98931: NEG
98932: PUSH
98933: LD_INT 0
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: PUSH
98940: LD_INT 3
98942: NEG
98943: PUSH
98944: LD_INT 1
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: PUSH
98951: LD_INT 4
98953: NEG
98954: PUSH
98955: LD_INT 1
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 5
98964: NEG
98965: PUSH
98966: LD_INT 0
98968: PUSH
98969: EMPTY
98970: LIST
98971: LIST
98972: PUSH
98973: LD_INT 5
98975: NEG
98976: PUSH
98977: LD_INT 1
98979: NEG
98980: PUSH
98981: EMPTY
98982: LIST
98983: LIST
98984: PUSH
98985: LD_INT 5
98987: NEG
98988: PUSH
98989: LD_INT 2
98991: NEG
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PUSH
98997: LD_INT 3
98999: NEG
99000: PUSH
99001: LD_INT 2
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: LD_INT 3
99010: NEG
99011: PUSH
99012: LD_INT 3
99014: NEG
99015: PUSH
99016: EMPTY
99017: LIST
99018: LIST
99019: PUSH
99020: LD_INT 3
99022: NEG
99023: PUSH
99024: LD_INT 4
99026: NEG
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: PUSH
99032: LD_INT 2
99034: NEG
99035: PUSH
99036: LD_INT 3
99038: NEG
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PUSH
99044: LD_INT 2
99046: NEG
99047: PUSH
99048: LD_INT 2
99050: NEG
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 3
99058: NEG
99059: PUSH
99060: LD_INT 2
99062: NEG
99063: PUSH
99064: EMPTY
99065: LIST
99066: LIST
99067: PUSH
99068: LD_INT 4
99070: NEG
99071: PUSH
99072: LD_INT 3
99074: NEG
99075: PUSH
99076: EMPTY
99077: LIST
99078: LIST
99079: PUSH
99080: LD_INT 4
99082: NEG
99083: PUSH
99084: LD_INT 4
99086: NEG
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PUSH
99092: LD_INT 2
99094: NEG
99095: PUSH
99096: LD_INT 4
99098: NEG
99099: PUSH
99100: EMPTY
99101: LIST
99102: LIST
99103: PUSH
99104: LD_INT 4
99106: NEG
99107: PUSH
99108: LD_INT 2
99110: NEG
99111: PUSH
99112: EMPTY
99113: LIST
99114: LIST
99115: PUSH
99116: LD_INT 0
99118: PUSH
99119: LD_INT 4
99121: NEG
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PUSH
99127: LD_INT 0
99129: PUSH
99130: LD_INT 5
99132: NEG
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 1
99140: PUSH
99141: LD_INT 4
99143: NEG
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 1
99151: PUSH
99152: LD_INT 3
99154: NEG
99155: PUSH
99156: EMPTY
99157: LIST
99158: LIST
99159: PUSH
99160: LD_INT 0
99162: PUSH
99163: LD_INT 3
99165: NEG
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PUSH
99171: LD_INT 1
99173: NEG
99174: PUSH
99175: LD_INT 4
99177: NEG
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PUSH
99183: LD_INT 1
99185: NEG
99186: PUSH
99187: LD_INT 5
99189: NEG
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 2
99197: PUSH
99198: LD_INT 3
99200: NEG
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: PUSH
99206: LD_INT 2
99208: NEG
99209: PUSH
99210: LD_INT 5
99212: NEG
99213: PUSH
99214: EMPTY
99215: LIST
99216: LIST
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99265: LD_ADDR_VAR 0 31
99269: PUSH
99270: LD_INT 0
99272: PUSH
99273: LD_INT 4
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 0
99282: PUSH
99283: LD_INT 3
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: PUSH
99290: LD_INT 1
99292: PUSH
99293: LD_INT 4
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: PUSH
99300: LD_INT 1
99302: PUSH
99303: LD_INT 5
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: PUSH
99310: LD_INT 0
99312: PUSH
99313: LD_INT 5
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 1
99322: NEG
99323: PUSH
99324: LD_INT 4
99326: PUSH
99327: EMPTY
99328: LIST
99329: LIST
99330: PUSH
99331: LD_INT 1
99333: NEG
99334: PUSH
99335: LD_INT 3
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PUSH
99342: LD_INT 2
99344: PUSH
99345: LD_INT 5
99347: PUSH
99348: EMPTY
99349: LIST
99350: LIST
99351: PUSH
99352: LD_INT 2
99354: NEG
99355: PUSH
99356: LD_INT 3
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: LD_INT 3
99365: NEG
99366: PUSH
99367: LD_INT 0
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: PUSH
99374: LD_INT 3
99376: NEG
99377: PUSH
99378: LD_INT 1
99380: NEG
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: PUSH
99386: LD_INT 2
99388: NEG
99389: PUSH
99390: LD_INT 0
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: PUSH
99397: LD_INT 2
99399: NEG
99400: PUSH
99401: LD_INT 1
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PUSH
99408: LD_INT 3
99410: NEG
99411: PUSH
99412: LD_INT 1
99414: PUSH
99415: EMPTY
99416: LIST
99417: LIST
99418: PUSH
99419: LD_INT 4
99421: NEG
99422: PUSH
99423: LD_INT 0
99425: PUSH
99426: EMPTY
99427: LIST
99428: LIST
99429: PUSH
99430: LD_INT 4
99432: NEG
99433: PUSH
99434: LD_INT 1
99436: NEG
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: PUSH
99442: LD_INT 4
99444: NEG
99445: PUSH
99446: LD_INT 2
99448: NEG
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: PUSH
99454: LD_INT 2
99456: NEG
99457: PUSH
99458: LD_INT 2
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PUSH
99465: LD_INT 4
99467: NEG
99468: PUSH
99469: LD_INT 4
99471: NEG
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PUSH
99477: LD_INT 4
99479: NEG
99480: PUSH
99481: LD_INT 5
99483: NEG
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: PUSH
99489: LD_INT 3
99491: NEG
99492: PUSH
99493: LD_INT 4
99495: NEG
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: LD_INT 3
99503: NEG
99504: PUSH
99505: LD_INT 3
99507: NEG
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PUSH
99513: LD_INT 4
99515: NEG
99516: PUSH
99517: LD_INT 3
99519: NEG
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: PUSH
99525: LD_INT 5
99527: NEG
99528: PUSH
99529: LD_INT 4
99531: NEG
99532: PUSH
99533: EMPTY
99534: LIST
99535: LIST
99536: PUSH
99537: LD_INT 5
99539: NEG
99540: PUSH
99541: LD_INT 5
99543: NEG
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: LD_INT 3
99551: NEG
99552: PUSH
99553: LD_INT 5
99555: NEG
99556: PUSH
99557: EMPTY
99558: LIST
99559: LIST
99560: PUSH
99561: LD_INT 5
99563: NEG
99564: PUSH
99565: LD_INT 3
99567: NEG
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: PUSH
99573: LD_INT 0
99575: PUSH
99576: LD_INT 3
99578: NEG
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: PUSH
99584: LD_INT 0
99586: PUSH
99587: LD_INT 4
99589: NEG
99590: PUSH
99591: EMPTY
99592: LIST
99593: LIST
99594: PUSH
99595: LD_INT 1
99597: PUSH
99598: LD_INT 3
99600: NEG
99601: PUSH
99602: EMPTY
99603: LIST
99604: LIST
99605: PUSH
99606: LD_INT 1
99608: PUSH
99609: LD_INT 2
99611: NEG
99612: PUSH
99613: EMPTY
99614: LIST
99615: LIST
99616: PUSH
99617: LD_INT 0
99619: PUSH
99620: LD_INT 2
99622: NEG
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: LD_INT 1
99630: NEG
99631: PUSH
99632: LD_INT 3
99634: NEG
99635: PUSH
99636: EMPTY
99637: LIST
99638: LIST
99639: PUSH
99640: LD_INT 1
99642: NEG
99643: PUSH
99644: LD_INT 4
99646: NEG
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: PUSH
99652: LD_INT 2
99654: PUSH
99655: LD_INT 2
99657: NEG
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: PUSH
99663: LD_INT 2
99665: NEG
99666: PUSH
99667: LD_INT 4
99669: NEG
99670: PUSH
99671: EMPTY
99672: LIST
99673: LIST
99674: PUSH
99675: LD_INT 4
99677: PUSH
99678: LD_INT 0
99680: PUSH
99681: EMPTY
99682: LIST
99683: LIST
99684: PUSH
99685: LD_INT 4
99687: PUSH
99688: LD_INT 1
99690: NEG
99691: PUSH
99692: EMPTY
99693: LIST
99694: LIST
99695: PUSH
99696: LD_INT 5
99698: PUSH
99699: LD_INT 0
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PUSH
99706: LD_INT 5
99708: PUSH
99709: LD_INT 1
99711: PUSH
99712: EMPTY
99713: LIST
99714: LIST
99715: PUSH
99716: LD_INT 4
99718: PUSH
99719: LD_INT 1
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: PUSH
99726: LD_INT 3
99728: PUSH
99729: LD_INT 0
99731: PUSH
99732: EMPTY
99733: LIST
99734: LIST
99735: PUSH
99736: LD_INT 3
99738: PUSH
99739: LD_INT 1
99741: NEG
99742: PUSH
99743: EMPTY
99744: LIST
99745: LIST
99746: PUSH
99747: LD_INT 3
99749: PUSH
99750: LD_INT 2
99752: NEG
99753: PUSH
99754: EMPTY
99755: LIST
99756: LIST
99757: PUSH
99758: LD_INT 5
99760: PUSH
99761: LD_INT 2
99763: PUSH
99764: EMPTY
99765: LIST
99766: LIST
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: LIST
99775: LIST
99776: LIST
99777: LIST
99778: LIST
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
99815: LD_ADDR_VAR 0 32
99819: PUSH
99820: LD_INT 4
99822: NEG
99823: PUSH
99824: LD_INT 0
99826: PUSH
99827: EMPTY
99828: LIST
99829: LIST
99830: PUSH
99831: LD_INT 4
99833: NEG
99834: PUSH
99835: LD_INT 1
99837: NEG
99838: PUSH
99839: EMPTY
99840: LIST
99841: LIST
99842: PUSH
99843: LD_INT 3
99845: NEG
99846: PUSH
99847: LD_INT 0
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: PUSH
99854: LD_INT 3
99856: NEG
99857: PUSH
99858: LD_INT 1
99860: PUSH
99861: EMPTY
99862: LIST
99863: LIST
99864: PUSH
99865: LD_INT 4
99867: NEG
99868: PUSH
99869: LD_INT 1
99871: PUSH
99872: EMPTY
99873: LIST
99874: LIST
99875: PUSH
99876: LD_INT 5
99878: NEG
99879: PUSH
99880: LD_INT 0
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: PUSH
99887: LD_INT 5
99889: NEG
99890: PUSH
99891: LD_INT 1
99893: NEG
99894: PUSH
99895: EMPTY
99896: LIST
99897: LIST
99898: PUSH
99899: LD_INT 5
99901: NEG
99902: PUSH
99903: LD_INT 2
99905: NEG
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PUSH
99911: LD_INT 3
99913: NEG
99914: PUSH
99915: LD_INT 2
99917: PUSH
99918: EMPTY
99919: LIST
99920: LIST
99921: PUSH
99922: LD_INT 3
99924: NEG
99925: PUSH
99926: LD_INT 3
99928: NEG
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PUSH
99934: LD_INT 3
99936: NEG
99937: PUSH
99938: LD_INT 4
99940: NEG
99941: PUSH
99942: EMPTY
99943: LIST
99944: LIST
99945: PUSH
99946: LD_INT 2
99948: NEG
99949: PUSH
99950: LD_INT 3
99952: NEG
99953: PUSH
99954: EMPTY
99955: LIST
99956: LIST
99957: PUSH
99958: LD_INT 2
99960: NEG
99961: PUSH
99962: LD_INT 2
99964: NEG
99965: PUSH
99966: EMPTY
99967: LIST
99968: LIST
99969: PUSH
99970: LD_INT 3
99972: NEG
99973: PUSH
99974: LD_INT 2
99976: NEG
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: PUSH
99982: LD_INT 4
99984: NEG
99985: PUSH
99986: LD_INT 3
99988: NEG
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 4
99996: NEG
99997: PUSH
99998: LD_INT 4
100000: NEG
100001: PUSH
100002: EMPTY
100003: LIST
100004: LIST
100005: PUSH
100006: LD_INT 2
100008: NEG
100009: PUSH
100010: LD_INT 4
100012: NEG
100013: PUSH
100014: EMPTY
100015: LIST
100016: LIST
100017: PUSH
100018: LD_INT 4
100020: NEG
100021: PUSH
100022: LD_INT 2
100024: NEG
100025: PUSH
100026: EMPTY
100027: LIST
100028: LIST
100029: PUSH
100030: LD_INT 0
100032: PUSH
100033: LD_INT 4
100035: NEG
100036: PUSH
100037: EMPTY
100038: LIST
100039: LIST
100040: PUSH
100041: LD_INT 0
100043: PUSH
100044: LD_INT 5
100046: NEG
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: PUSH
100052: LD_INT 1
100054: PUSH
100055: LD_INT 4
100057: NEG
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: PUSH
100063: LD_INT 1
100065: PUSH
100066: LD_INT 3
100068: NEG
100069: PUSH
100070: EMPTY
100071: LIST
100072: LIST
100073: PUSH
100074: LD_INT 0
100076: PUSH
100077: LD_INT 3
100079: NEG
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: PUSH
100085: LD_INT 1
100087: NEG
100088: PUSH
100089: LD_INT 4
100091: NEG
100092: PUSH
100093: EMPTY
100094: LIST
100095: LIST
100096: PUSH
100097: LD_INT 1
100099: NEG
100100: PUSH
100101: LD_INT 5
100103: NEG
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: PUSH
100109: LD_INT 2
100111: PUSH
100112: LD_INT 3
100114: NEG
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PUSH
100120: LD_INT 2
100122: NEG
100123: PUSH
100124: LD_INT 5
100126: NEG
100127: PUSH
100128: EMPTY
100129: LIST
100130: LIST
100131: PUSH
100132: LD_INT 3
100134: PUSH
100135: LD_INT 0
100137: PUSH
100138: EMPTY
100139: LIST
100140: LIST
100141: PUSH
100142: LD_INT 3
100144: PUSH
100145: LD_INT 1
100147: NEG
100148: PUSH
100149: EMPTY
100150: LIST
100151: LIST
100152: PUSH
100153: LD_INT 4
100155: PUSH
100156: LD_INT 0
100158: PUSH
100159: EMPTY
100160: LIST
100161: LIST
100162: PUSH
100163: LD_INT 4
100165: PUSH
100166: LD_INT 1
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: PUSH
100173: LD_INT 3
100175: PUSH
100176: LD_INT 1
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: PUSH
100183: LD_INT 2
100185: PUSH
100186: LD_INT 0
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 2
100195: PUSH
100196: LD_INT 1
100198: NEG
100199: PUSH
100200: EMPTY
100201: LIST
100202: LIST
100203: PUSH
100204: LD_INT 2
100206: PUSH
100207: LD_INT 2
100209: NEG
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: PUSH
100215: LD_INT 4
100217: PUSH
100218: LD_INT 2
100220: PUSH
100221: EMPTY
100222: LIST
100223: LIST
100224: PUSH
100225: LD_INT 4
100227: PUSH
100228: LD_INT 4
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: PUSH
100235: LD_INT 4
100237: PUSH
100238: LD_INT 3
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PUSH
100245: LD_INT 5
100247: PUSH
100248: LD_INT 4
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: PUSH
100255: LD_INT 5
100257: PUSH
100258: LD_INT 5
100260: PUSH
100261: EMPTY
100262: LIST
100263: LIST
100264: PUSH
100265: LD_INT 4
100267: PUSH
100268: LD_INT 5
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PUSH
100275: LD_INT 3
100277: PUSH
100278: LD_INT 4
100280: PUSH
100281: EMPTY
100282: LIST
100283: LIST
100284: PUSH
100285: LD_INT 3
100287: PUSH
100288: LD_INT 3
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PUSH
100295: LD_INT 5
100297: PUSH
100298: LD_INT 3
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 3
100307: PUSH
100308: LD_INT 5
100310: PUSH
100311: EMPTY
100312: LIST
100313: LIST
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: LIST
100319: LIST
100320: LIST
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: LIST
100337: LIST
100338: LIST
100339: LIST
100340: LIST
100341: LIST
100342: LIST
100343: LIST
100344: LIST
100345: LIST
100346: LIST
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100362: LD_ADDR_VAR 0 33
100366: PUSH
100367: LD_INT 4
100369: NEG
100370: PUSH
100371: LD_INT 4
100373: NEG
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: PUSH
100379: LD_INT 4
100381: NEG
100382: PUSH
100383: LD_INT 5
100385: NEG
100386: PUSH
100387: EMPTY
100388: LIST
100389: LIST
100390: PUSH
100391: LD_INT 3
100393: NEG
100394: PUSH
100395: LD_INT 4
100397: NEG
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: PUSH
100403: LD_INT 3
100405: NEG
100406: PUSH
100407: LD_INT 3
100409: NEG
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: PUSH
100415: LD_INT 4
100417: NEG
100418: PUSH
100419: LD_INT 3
100421: NEG
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: LD_INT 5
100429: NEG
100430: PUSH
100431: LD_INT 4
100433: NEG
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 5
100441: NEG
100442: PUSH
100443: LD_INT 5
100445: NEG
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PUSH
100451: LD_INT 3
100453: NEG
100454: PUSH
100455: LD_INT 5
100457: NEG
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: PUSH
100463: LD_INT 5
100465: NEG
100466: PUSH
100467: LD_INT 3
100469: NEG
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: PUSH
100475: LD_INT 0
100477: PUSH
100478: LD_INT 3
100480: NEG
100481: PUSH
100482: EMPTY
100483: LIST
100484: LIST
100485: PUSH
100486: LD_INT 0
100488: PUSH
100489: LD_INT 4
100491: NEG
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: PUSH
100497: LD_INT 1
100499: PUSH
100500: LD_INT 3
100502: NEG
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PUSH
100508: LD_INT 1
100510: PUSH
100511: LD_INT 2
100513: NEG
100514: PUSH
100515: EMPTY
100516: LIST
100517: LIST
100518: PUSH
100519: LD_INT 0
100521: PUSH
100522: LD_INT 2
100524: NEG
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PUSH
100530: LD_INT 1
100532: NEG
100533: PUSH
100534: LD_INT 3
100536: NEG
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 1
100544: NEG
100545: PUSH
100546: LD_INT 4
100548: NEG
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: LD_INT 2
100556: PUSH
100557: LD_INT 2
100559: NEG
100560: PUSH
100561: EMPTY
100562: LIST
100563: LIST
100564: PUSH
100565: LD_INT 2
100567: NEG
100568: PUSH
100569: LD_INT 4
100571: NEG
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: PUSH
100577: LD_INT 4
100579: PUSH
100580: LD_INT 0
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PUSH
100587: LD_INT 4
100589: PUSH
100590: LD_INT 1
100592: NEG
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: LD_INT 5
100600: PUSH
100601: LD_INT 0
100603: PUSH
100604: EMPTY
100605: LIST
100606: LIST
100607: PUSH
100608: LD_INT 5
100610: PUSH
100611: LD_INT 1
100613: PUSH
100614: EMPTY
100615: LIST
100616: LIST
100617: PUSH
100618: LD_INT 4
100620: PUSH
100621: LD_INT 1
100623: PUSH
100624: EMPTY
100625: LIST
100626: LIST
100627: PUSH
100628: LD_INT 3
100630: PUSH
100631: LD_INT 0
100633: PUSH
100634: EMPTY
100635: LIST
100636: LIST
100637: PUSH
100638: LD_INT 3
100640: PUSH
100641: LD_INT 1
100643: NEG
100644: PUSH
100645: EMPTY
100646: LIST
100647: LIST
100648: PUSH
100649: LD_INT 3
100651: PUSH
100652: LD_INT 2
100654: NEG
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PUSH
100660: LD_INT 5
100662: PUSH
100663: LD_INT 2
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: PUSH
100670: LD_INT 3
100672: PUSH
100673: LD_INT 3
100675: PUSH
100676: EMPTY
100677: LIST
100678: LIST
100679: PUSH
100680: LD_INT 3
100682: PUSH
100683: LD_INT 2
100685: PUSH
100686: EMPTY
100687: LIST
100688: LIST
100689: PUSH
100690: LD_INT 4
100692: PUSH
100693: LD_INT 3
100695: PUSH
100696: EMPTY
100697: LIST
100698: LIST
100699: PUSH
100700: LD_INT 4
100702: PUSH
100703: LD_INT 4
100705: PUSH
100706: EMPTY
100707: LIST
100708: LIST
100709: PUSH
100710: LD_INT 3
100712: PUSH
100713: LD_INT 4
100715: PUSH
100716: EMPTY
100717: LIST
100718: LIST
100719: PUSH
100720: LD_INT 2
100722: PUSH
100723: LD_INT 3
100725: PUSH
100726: EMPTY
100727: LIST
100728: LIST
100729: PUSH
100730: LD_INT 2
100732: PUSH
100733: LD_INT 2
100735: PUSH
100736: EMPTY
100737: LIST
100738: LIST
100739: PUSH
100740: LD_INT 4
100742: PUSH
100743: LD_INT 2
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 2
100752: PUSH
100753: LD_INT 4
100755: PUSH
100756: EMPTY
100757: LIST
100758: LIST
100759: PUSH
100760: LD_INT 0
100762: PUSH
100763: LD_INT 4
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: LD_INT 0
100772: PUSH
100773: LD_INT 3
100775: PUSH
100776: EMPTY
100777: LIST
100778: LIST
100779: PUSH
100780: LD_INT 1
100782: PUSH
100783: LD_INT 4
100785: PUSH
100786: EMPTY
100787: LIST
100788: LIST
100789: PUSH
100790: LD_INT 1
100792: PUSH
100793: LD_INT 5
100795: PUSH
100796: EMPTY
100797: LIST
100798: LIST
100799: PUSH
100800: LD_INT 0
100802: PUSH
100803: LD_INT 5
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: PUSH
100810: LD_INT 1
100812: NEG
100813: PUSH
100814: LD_INT 4
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PUSH
100821: LD_INT 1
100823: NEG
100824: PUSH
100825: LD_INT 3
100827: PUSH
100828: EMPTY
100829: LIST
100830: LIST
100831: PUSH
100832: LD_INT 2
100834: PUSH
100835: LD_INT 5
100837: PUSH
100838: EMPTY
100839: LIST
100840: LIST
100841: PUSH
100842: LD_INT 2
100844: NEG
100845: PUSH
100846: LD_INT 3
100848: PUSH
100849: EMPTY
100850: LIST
100851: LIST
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: LIST
100857: LIST
100858: LIST
100859: LIST
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: LIST
100876: LIST
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
100900: LD_ADDR_VAR 0 34
100904: PUSH
100905: LD_INT 0
100907: PUSH
100908: LD_INT 4
100910: NEG
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PUSH
100916: LD_INT 0
100918: PUSH
100919: LD_INT 5
100921: NEG
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PUSH
100927: LD_INT 1
100929: PUSH
100930: LD_INT 4
100932: NEG
100933: PUSH
100934: EMPTY
100935: LIST
100936: LIST
100937: PUSH
100938: LD_INT 1
100940: PUSH
100941: LD_INT 3
100943: NEG
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: PUSH
100949: LD_INT 0
100951: PUSH
100952: LD_INT 3
100954: NEG
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: PUSH
100960: LD_INT 1
100962: NEG
100963: PUSH
100964: LD_INT 4
100966: NEG
100967: PUSH
100968: EMPTY
100969: LIST
100970: LIST
100971: PUSH
100972: LD_INT 1
100974: NEG
100975: PUSH
100976: LD_INT 5
100978: NEG
100979: PUSH
100980: EMPTY
100981: LIST
100982: LIST
100983: PUSH
100984: LD_INT 2
100986: PUSH
100987: LD_INT 3
100989: NEG
100990: PUSH
100991: EMPTY
100992: LIST
100993: LIST
100994: PUSH
100995: LD_INT 2
100997: NEG
100998: PUSH
100999: LD_INT 5
101001: NEG
101002: PUSH
101003: EMPTY
101004: LIST
101005: LIST
101006: PUSH
101007: LD_INT 3
101009: PUSH
101010: LD_INT 0
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PUSH
101017: LD_INT 3
101019: PUSH
101020: LD_INT 1
101022: NEG
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: LD_INT 4
101030: PUSH
101031: LD_INT 0
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: PUSH
101038: LD_INT 4
101040: PUSH
101041: LD_INT 1
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: PUSH
101048: LD_INT 3
101050: PUSH
101051: LD_INT 1
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: PUSH
101058: LD_INT 2
101060: PUSH
101061: LD_INT 0
101063: PUSH
101064: EMPTY
101065: LIST
101066: LIST
101067: PUSH
101068: LD_INT 2
101070: PUSH
101071: LD_INT 1
101073: NEG
101074: PUSH
101075: EMPTY
101076: LIST
101077: LIST
101078: PUSH
101079: LD_INT 2
101081: PUSH
101082: LD_INT 2
101084: NEG
101085: PUSH
101086: EMPTY
101087: LIST
101088: LIST
101089: PUSH
101090: LD_INT 4
101092: PUSH
101093: LD_INT 2
101095: PUSH
101096: EMPTY
101097: LIST
101098: LIST
101099: PUSH
101100: LD_INT 4
101102: PUSH
101103: LD_INT 4
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: PUSH
101110: LD_INT 4
101112: PUSH
101113: LD_INT 3
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PUSH
101120: LD_INT 5
101122: PUSH
101123: LD_INT 4
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PUSH
101130: LD_INT 5
101132: PUSH
101133: LD_INT 5
101135: PUSH
101136: EMPTY
101137: LIST
101138: LIST
101139: PUSH
101140: LD_INT 4
101142: PUSH
101143: LD_INT 5
101145: PUSH
101146: EMPTY
101147: LIST
101148: LIST
101149: PUSH
101150: LD_INT 3
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PUSH
101160: LD_INT 3
101162: PUSH
101163: LD_INT 3
101165: PUSH
101166: EMPTY
101167: LIST
101168: LIST
101169: PUSH
101170: LD_INT 5
101172: PUSH
101173: LD_INT 3
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: PUSH
101180: LD_INT 3
101182: PUSH
101183: LD_INT 5
101185: PUSH
101186: EMPTY
101187: LIST
101188: LIST
101189: PUSH
101190: LD_INT 0
101192: PUSH
101193: LD_INT 3
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: PUSH
101200: LD_INT 0
101202: PUSH
101203: LD_INT 2
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: PUSH
101210: LD_INT 1
101212: PUSH
101213: LD_INT 3
101215: PUSH
101216: EMPTY
101217: LIST
101218: LIST
101219: PUSH
101220: LD_INT 1
101222: PUSH
101223: LD_INT 4
101225: PUSH
101226: EMPTY
101227: LIST
101228: LIST
101229: PUSH
101230: LD_INT 0
101232: PUSH
101233: LD_INT 4
101235: PUSH
101236: EMPTY
101237: LIST
101238: LIST
101239: PUSH
101240: LD_INT 1
101242: NEG
101243: PUSH
101244: LD_INT 3
101246: PUSH
101247: EMPTY
101248: LIST
101249: LIST
101250: PUSH
101251: LD_INT 1
101253: NEG
101254: PUSH
101255: LD_INT 2
101257: PUSH
101258: EMPTY
101259: LIST
101260: LIST
101261: PUSH
101262: LD_INT 2
101264: PUSH
101265: LD_INT 4
101267: PUSH
101268: EMPTY
101269: LIST
101270: LIST
101271: PUSH
101272: LD_INT 2
101274: NEG
101275: PUSH
101276: LD_INT 2
101278: PUSH
101279: EMPTY
101280: LIST
101281: LIST
101282: PUSH
101283: LD_INT 4
101285: NEG
101286: PUSH
101287: LD_INT 0
101289: PUSH
101290: EMPTY
101291: LIST
101292: LIST
101293: PUSH
101294: LD_INT 4
101296: NEG
101297: PUSH
101298: LD_INT 1
101300: NEG
101301: PUSH
101302: EMPTY
101303: LIST
101304: LIST
101305: PUSH
101306: LD_INT 3
101308: NEG
101309: PUSH
101310: LD_INT 0
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: PUSH
101317: LD_INT 3
101319: NEG
101320: PUSH
101321: LD_INT 1
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PUSH
101328: LD_INT 4
101330: NEG
101331: PUSH
101332: LD_INT 1
101334: PUSH
101335: EMPTY
101336: LIST
101337: LIST
101338: PUSH
101339: LD_INT 5
101341: NEG
101342: PUSH
101343: LD_INT 0
101345: PUSH
101346: EMPTY
101347: LIST
101348: LIST
101349: PUSH
101350: LD_INT 5
101352: NEG
101353: PUSH
101354: LD_INT 1
101356: NEG
101357: PUSH
101358: EMPTY
101359: LIST
101360: LIST
101361: PUSH
101362: LD_INT 5
101364: NEG
101365: PUSH
101366: LD_INT 2
101368: NEG
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: PUSH
101374: LD_INT 3
101376: NEG
101377: PUSH
101378: LD_INT 2
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PUSH
101385: EMPTY
101386: LIST
101387: LIST
101388: LIST
101389: LIST
101390: LIST
101391: LIST
101392: LIST
101393: LIST
101394: LIST
101395: LIST
101396: LIST
101397: LIST
101398: LIST
101399: LIST
101400: LIST
101401: LIST
101402: LIST
101403: LIST
101404: LIST
101405: LIST
101406: LIST
101407: LIST
101408: LIST
101409: LIST
101410: LIST
101411: LIST
101412: LIST
101413: LIST
101414: LIST
101415: LIST
101416: LIST
101417: LIST
101418: LIST
101419: LIST
101420: LIST
101421: LIST
101422: LIST
101423: LIST
101424: LIST
101425: LIST
101426: LIST
101427: LIST
101428: LIST
101429: LIST
101430: LIST
101431: ST_TO_ADDR
// end ; end ;
101432: GO 101435
101434: POP
// case btype of b_depot , b_warehouse :
101435: LD_VAR 0 1
101439: PUSH
101440: LD_INT 0
101442: DOUBLE
101443: EQUAL
101444: IFTRUE 101454
101446: LD_INT 1
101448: DOUBLE
101449: EQUAL
101450: IFTRUE 101454
101452: GO 101655
101454: POP
// case nation of nation_american :
101455: LD_VAR 0 5
101459: PUSH
101460: LD_INT 1
101462: DOUBLE
101463: EQUAL
101464: IFTRUE 101468
101466: GO 101524
101468: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101469: LD_ADDR_VAR 0 9
101473: PUSH
101474: LD_VAR 0 11
101478: PUSH
101479: LD_VAR 0 12
101483: PUSH
101484: LD_VAR 0 13
101488: PUSH
101489: LD_VAR 0 14
101493: PUSH
101494: LD_VAR 0 15
101498: PUSH
101499: LD_VAR 0 16
101503: PUSH
101504: EMPTY
101505: LIST
101506: LIST
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: PUSH
101512: LD_VAR 0 4
101516: PUSH
101517: LD_INT 1
101519: PLUS
101520: ARRAY
101521: ST_TO_ADDR
101522: GO 101653
101524: LD_INT 2
101526: DOUBLE
101527: EQUAL
101528: IFTRUE 101532
101530: GO 101588
101532: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101533: LD_ADDR_VAR 0 9
101537: PUSH
101538: LD_VAR 0 17
101542: PUSH
101543: LD_VAR 0 18
101547: PUSH
101548: LD_VAR 0 19
101552: PUSH
101553: LD_VAR 0 20
101557: PUSH
101558: LD_VAR 0 21
101562: PUSH
101563: LD_VAR 0 22
101567: PUSH
101568: EMPTY
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: PUSH
101576: LD_VAR 0 4
101580: PUSH
101581: LD_INT 1
101583: PLUS
101584: ARRAY
101585: ST_TO_ADDR
101586: GO 101653
101588: LD_INT 3
101590: DOUBLE
101591: EQUAL
101592: IFTRUE 101596
101594: GO 101652
101596: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101597: LD_ADDR_VAR 0 9
101601: PUSH
101602: LD_VAR 0 23
101606: PUSH
101607: LD_VAR 0 24
101611: PUSH
101612: LD_VAR 0 25
101616: PUSH
101617: LD_VAR 0 26
101621: PUSH
101622: LD_VAR 0 27
101626: PUSH
101627: LD_VAR 0 28
101631: PUSH
101632: EMPTY
101633: LIST
101634: LIST
101635: LIST
101636: LIST
101637: LIST
101638: LIST
101639: PUSH
101640: LD_VAR 0 4
101644: PUSH
101645: LD_INT 1
101647: PLUS
101648: ARRAY
101649: ST_TO_ADDR
101650: GO 101653
101652: POP
101653: GO 102208
101655: LD_INT 2
101657: DOUBLE
101658: EQUAL
101659: IFTRUE 101669
101661: LD_INT 3
101663: DOUBLE
101664: EQUAL
101665: IFTRUE 101669
101667: GO 101725
101669: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101670: LD_ADDR_VAR 0 9
101674: PUSH
101675: LD_VAR 0 29
101679: PUSH
101680: LD_VAR 0 30
101684: PUSH
101685: LD_VAR 0 31
101689: PUSH
101690: LD_VAR 0 32
101694: PUSH
101695: LD_VAR 0 33
101699: PUSH
101700: LD_VAR 0 34
101704: PUSH
101705: EMPTY
101706: LIST
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: PUSH
101713: LD_VAR 0 4
101717: PUSH
101718: LD_INT 1
101720: PLUS
101721: ARRAY
101722: ST_TO_ADDR
101723: GO 102208
101725: LD_INT 16
101727: DOUBLE
101728: EQUAL
101729: IFTRUE 101787
101731: LD_INT 17
101733: DOUBLE
101734: EQUAL
101735: IFTRUE 101787
101737: LD_INT 18
101739: DOUBLE
101740: EQUAL
101741: IFTRUE 101787
101743: LD_INT 19
101745: DOUBLE
101746: EQUAL
101747: IFTRUE 101787
101749: LD_INT 22
101751: DOUBLE
101752: EQUAL
101753: IFTRUE 101787
101755: LD_INT 20
101757: DOUBLE
101758: EQUAL
101759: IFTRUE 101787
101761: LD_INT 21
101763: DOUBLE
101764: EQUAL
101765: IFTRUE 101787
101767: LD_INT 23
101769: DOUBLE
101770: EQUAL
101771: IFTRUE 101787
101773: LD_INT 24
101775: DOUBLE
101776: EQUAL
101777: IFTRUE 101787
101779: LD_INT 25
101781: DOUBLE
101782: EQUAL
101783: IFTRUE 101787
101785: GO 101843
101787: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
101788: LD_ADDR_VAR 0 9
101792: PUSH
101793: LD_VAR 0 35
101797: PUSH
101798: LD_VAR 0 36
101802: PUSH
101803: LD_VAR 0 37
101807: PUSH
101808: LD_VAR 0 38
101812: PUSH
101813: LD_VAR 0 39
101817: PUSH
101818: LD_VAR 0 40
101822: PUSH
101823: EMPTY
101824: LIST
101825: LIST
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: PUSH
101831: LD_VAR 0 4
101835: PUSH
101836: LD_INT 1
101838: PLUS
101839: ARRAY
101840: ST_TO_ADDR
101841: GO 102208
101843: LD_INT 6
101845: DOUBLE
101846: EQUAL
101847: IFTRUE 101899
101849: LD_INT 7
101851: DOUBLE
101852: EQUAL
101853: IFTRUE 101899
101855: LD_INT 8
101857: DOUBLE
101858: EQUAL
101859: IFTRUE 101899
101861: LD_INT 13
101863: DOUBLE
101864: EQUAL
101865: IFTRUE 101899
101867: LD_INT 12
101869: DOUBLE
101870: EQUAL
101871: IFTRUE 101899
101873: LD_INT 15
101875: DOUBLE
101876: EQUAL
101877: IFTRUE 101899
101879: LD_INT 11
101881: DOUBLE
101882: EQUAL
101883: IFTRUE 101899
101885: LD_INT 14
101887: DOUBLE
101888: EQUAL
101889: IFTRUE 101899
101891: LD_INT 10
101893: DOUBLE
101894: EQUAL
101895: IFTRUE 101899
101897: GO 101955
101899: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
101900: LD_ADDR_VAR 0 9
101904: PUSH
101905: LD_VAR 0 41
101909: PUSH
101910: LD_VAR 0 42
101914: PUSH
101915: LD_VAR 0 43
101919: PUSH
101920: LD_VAR 0 44
101924: PUSH
101925: LD_VAR 0 45
101929: PUSH
101930: LD_VAR 0 46
101934: PUSH
101935: EMPTY
101936: LIST
101937: LIST
101938: LIST
101939: LIST
101940: LIST
101941: LIST
101942: PUSH
101943: LD_VAR 0 4
101947: PUSH
101948: LD_INT 1
101950: PLUS
101951: ARRAY
101952: ST_TO_ADDR
101953: GO 102208
101955: LD_INT 36
101957: DOUBLE
101958: EQUAL
101959: IFTRUE 101963
101961: GO 102019
101963: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
101964: LD_ADDR_VAR 0 9
101968: PUSH
101969: LD_VAR 0 47
101973: PUSH
101974: LD_VAR 0 48
101978: PUSH
101979: LD_VAR 0 49
101983: PUSH
101984: LD_VAR 0 50
101988: PUSH
101989: LD_VAR 0 51
101993: PUSH
101994: LD_VAR 0 52
101998: PUSH
101999: EMPTY
102000: LIST
102001: LIST
102002: LIST
102003: LIST
102004: LIST
102005: LIST
102006: PUSH
102007: LD_VAR 0 4
102011: PUSH
102012: LD_INT 1
102014: PLUS
102015: ARRAY
102016: ST_TO_ADDR
102017: GO 102208
102019: LD_INT 4
102021: DOUBLE
102022: EQUAL
102023: IFTRUE 102045
102025: LD_INT 5
102027: DOUBLE
102028: EQUAL
102029: IFTRUE 102045
102031: LD_INT 34
102033: DOUBLE
102034: EQUAL
102035: IFTRUE 102045
102037: LD_INT 37
102039: DOUBLE
102040: EQUAL
102041: IFTRUE 102045
102043: GO 102101
102045: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102046: LD_ADDR_VAR 0 9
102050: PUSH
102051: LD_VAR 0 53
102055: PUSH
102056: LD_VAR 0 54
102060: PUSH
102061: LD_VAR 0 55
102065: PUSH
102066: LD_VAR 0 56
102070: PUSH
102071: LD_VAR 0 57
102075: PUSH
102076: LD_VAR 0 58
102080: PUSH
102081: EMPTY
102082: LIST
102083: LIST
102084: LIST
102085: LIST
102086: LIST
102087: LIST
102088: PUSH
102089: LD_VAR 0 4
102093: PUSH
102094: LD_INT 1
102096: PLUS
102097: ARRAY
102098: ST_TO_ADDR
102099: GO 102208
102101: LD_INT 31
102103: DOUBLE
102104: EQUAL
102105: IFTRUE 102151
102107: LD_INT 32
102109: DOUBLE
102110: EQUAL
102111: IFTRUE 102151
102113: LD_INT 33
102115: DOUBLE
102116: EQUAL
102117: IFTRUE 102151
102119: LD_INT 27
102121: DOUBLE
102122: EQUAL
102123: IFTRUE 102151
102125: LD_INT 26
102127: DOUBLE
102128: EQUAL
102129: IFTRUE 102151
102131: LD_INT 28
102133: DOUBLE
102134: EQUAL
102135: IFTRUE 102151
102137: LD_INT 29
102139: DOUBLE
102140: EQUAL
102141: IFTRUE 102151
102143: LD_INT 30
102145: DOUBLE
102146: EQUAL
102147: IFTRUE 102151
102149: GO 102207
102151: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102152: LD_ADDR_VAR 0 9
102156: PUSH
102157: LD_VAR 0 59
102161: PUSH
102162: LD_VAR 0 60
102166: PUSH
102167: LD_VAR 0 61
102171: PUSH
102172: LD_VAR 0 62
102176: PUSH
102177: LD_VAR 0 63
102181: PUSH
102182: LD_VAR 0 64
102186: PUSH
102187: EMPTY
102188: LIST
102189: LIST
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: PUSH
102195: LD_VAR 0 4
102199: PUSH
102200: LD_INT 1
102202: PLUS
102203: ARRAY
102204: ST_TO_ADDR
102205: GO 102208
102207: POP
// temp_list2 = [ ] ;
102208: LD_ADDR_VAR 0 10
102212: PUSH
102213: EMPTY
102214: ST_TO_ADDR
// for i in temp_list do
102215: LD_ADDR_VAR 0 8
102219: PUSH
102220: LD_VAR 0 9
102224: PUSH
102225: FOR_IN
102226: IFFALSE 102278
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102228: LD_ADDR_VAR 0 10
102232: PUSH
102233: LD_VAR 0 10
102237: PUSH
102238: LD_VAR 0 8
102242: PUSH
102243: LD_INT 1
102245: ARRAY
102246: PUSH
102247: LD_VAR 0 2
102251: PLUS
102252: PUSH
102253: LD_VAR 0 8
102257: PUSH
102258: LD_INT 2
102260: ARRAY
102261: PUSH
102262: LD_VAR 0 3
102266: PLUS
102267: PUSH
102268: EMPTY
102269: LIST
102270: LIST
102271: PUSH
102272: EMPTY
102273: LIST
102274: ADD
102275: ST_TO_ADDR
102276: GO 102225
102278: POP
102279: POP
// result = temp_list2 ;
102280: LD_ADDR_VAR 0 7
102284: PUSH
102285: LD_VAR 0 10
102289: ST_TO_ADDR
// end ;
102290: LD_VAR 0 7
102294: RET
// export function EnemyInRange ( unit , dist ) ; begin
102295: LD_INT 0
102297: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102298: LD_ADDR_VAR 0 3
102302: PUSH
102303: LD_VAR 0 1
102307: PPUSH
102308: CALL_OW 255
102312: PPUSH
102313: LD_VAR 0 1
102317: PPUSH
102318: CALL_OW 250
102322: PPUSH
102323: LD_VAR 0 1
102327: PPUSH
102328: CALL_OW 251
102332: PPUSH
102333: LD_VAR 0 2
102337: PPUSH
102338: CALL 75668 0 4
102342: PUSH
102343: LD_INT 4
102345: ARRAY
102346: ST_TO_ADDR
// end ;
102347: LD_VAR 0 3
102351: RET
// export function PlayerSeeMe ( unit ) ; begin
102352: LD_INT 0
102354: PPUSH
// result := See ( your_side , unit ) ;
102355: LD_ADDR_VAR 0 2
102359: PUSH
102360: LD_OWVAR 2
102364: PPUSH
102365: LD_VAR 0 1
102369: PPUSH
102370: CALL_OW 292
102374: ST_TO_ADDR
// end ;
102375: LD_VAR 0 2
102379: RET
// export function ReverseDir ( unit ) ; begin
102380: LD_INT 0
102382: PPUSH
// if not unit then
102383: LD_VAR 0 1
102387: NOT
102388: IFFALSE 102392
// exit ;
102390: GO 102415
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102392: LD_ADDR_VAR 0 2
102396: PUSH
102397: LD_VAR 0 1
102401: PPUSH
102402: CALL_OW 254
102406: PUSH
102407: LD_INT 3
102409: PLUS
102410: PUSH
102411: LD_INT 6
102413: MOD
102414: ST_TO_ADDR
// end ;
102415: LD_VAR 0 2
102419: RET
// export function ReverseArray ( array ) ; var i ; begin
102420: LD_INT 0
102422: PPUSH
102423: PPUSH
// if not array then
102424: LD_VAR 0 1
102428: NOT
102429: IFFALSE 102433
// exit ;
102431: GO 102488
// result := [ ] ;
102433: LD_ADDR_VAR 0 2
102437: PUSH
102438: EMPTY
102439: ST_TO_ADDR
// for i := array downto 1 do
102440: LD_ADDR_VAR 0 3
102444: PUSH
102445: DOUBLE
102446: LD_VAR 0 1
102450: INC
102451: ST_TO_ADDR
102452: LD_INT 1
102454: PUSH
102455: FOR_DOWNTO
102456: IFFALSE 102486
// result := Join ( result , array [ i ] ) ;
102458: LD_ADDR_VAR 0 2
102462: PUSH
102463: LD_VAR 0 2
102467: PPUSH
102468: LD_VAR 0 1
102472: PUSH
102473: LD_VAR 0 3
102477: ARRAY
102478: PPUSH
102479: CALL 107144 0 2
102483: ST_TO_ADDR
102484: GO 102455
102486: POP
102487: POP
// end ;
102488: LD_VAR 0 2
102492: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102493: LD_INT 0
102495: PPUSH
102496: PPUSH
102497: PPUSH
102498: PPUSH
102499: PPUSH
102500: PPUSH
// if not unit or not hexes then
102501: LD_VAR 0 1
102505: NOT
102506: PUSH
102507: LD_VAR 0 2
102511: NOT
102512: OR
102513: IFFALSE 102517
// exit ;
102515: GO 102640
// dist := 9999 ;
102517: LD_ADDR_VAR 0 5
102521: PUSH
102522: LD_INT 9999
102524: ST_TO_ADDR
// for i = 1 to hexes do
102525: LD_ADDR_VAR 0 4
102529: PUSH
102530: DOUBLE
102531: LD_INT 1
102533: DEC
102534: ST_TO_ADDR
102535: LD_VAR 0 2
102539: PUSH
102540: FOR_TO
102541: IFFALSE 102628
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102543: LD_ADDR_VAR 0 6
102547: PUSH
102548: LD_VAR 0 1
102552: PPUSH
102553: LD_VAR 0 2
102557: PUSH
102558: LD_VAR 0 4
102562: ARRAY
102563: PUSH
102564: LD_INT 1
102566: ARRAY
102567: PPUSH
102568: LD_VAR 0 2
102572: PUSH
102573: LD_VAR 0 4
102577: ARRAY
102578: PUSH
102579: LD_INT 2
102581: ARRAY
102582: PPUSH
102583: CALL_OW 297
102587: ST_TO_ADDR
// if tdist < dist then
102588: LD_VAR 0 6
102592: PUSH
102593: LD_VAR 0 5
102597: LESS
102598: IFFALSE 102626
// begin hex := hexes [ i ] ;
102600: LD_ADDR_VAR 0 8
102604: PUSH
102605: LD_VAR 0 2
102609: PUSH
102610: LD_VAR 0 4
102614: ARRAY
102615: ST_TO_ADDR
// dist := tdist ;
102616: LD_ADDR_VAR 0 5
102620: PUSH
102621: LD_VAR 0 6
102625: ST_TO_ADDR
// end ; end ;
102626: GO 102540
102628: POP
102629: POP
// result := hex ;
102630: LD_ADDR_VAR 0 3
102634: PUSH
102635: LD_VAR 0 8
102639: ST_TO_ADDR
// end ;
102640: LD_VAR 0 3
102644: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102645: LD_INT 0
102647: PPUSH
102648: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102649: LD_VAR 0 1
102653: NOT
102654: PUSH
102655: LD_VAR 0 1
102659: PUSH
102660: LD_INT 21
102662: PUSH
102663: LD_INT 2
102665: PUSH
102666: EMPTY
102667: LIST
102668: LIST
102669: PUSH
102670: LD_INT 23
102672: PUSH
102673: LD_INT 2
102675: PUSH
102676: EMPTY
102677: LIST
102678: LIST
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: PPUSH
102684: CALL_OW 69
102688: IN
102689: NOT
102690: OR
102691: IFFALSE 102695
// exit ;
102693: GO 102742
// for i = 1 to 3 do
102695: LD_ADDR_VAR 0 3
102699: PUSH
102700: DOUBLE
102701: LD_INT 1
102703: DEC
102704: ST_TO_ADDR
102705: LD_INT 3
102707: PUSH
102708: FOR_TO
102709: IFFALSE 102740
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102711: LD_VAR 0 1
102715: PPUSH
102716: CALL_OW 250
102720: PPUSH
102721: LD_VAR 0 1
102725: PPUSH
102726: CALL_OW 251
102730: PPUSH
102731: LD_INT 1
102733: PPUSH
102734: CALL_OW 453
102738: GO 102708
102740: POP
102741: POP
// end ;
102742: LD_VAR 0 2
102746: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102747: LD_INT 0
102749: PPUSH
102750: PPUSH
102751: PPUSH
102752: PPUSH
102753: PPUSH
102754: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
102755: LD_VAR 0 1
102759: NOT
102760: PUSH
102761: LD_VAR 0 2
102765: NOT
102766: OR
102767: PUSH
102768: LD_VAR 0 1
102772: PPUSH
102773: CALL_OW 314
102777: OR
102778: IFFALSE 102782
// exit ;
102780: GO 103249
// if GetLives ( i ) < 250 then
102782: LD_VAR 0 4
102786: PPUSH
102787: CALL_OW 256
102791: PUSH
102792: LD_INT 250
102794: LESS
102795: IFFALSE 102808
// begin ComAutodestruct ( i ) ;
102797: LD_VAR 0 4
102801: PPUSH
102802: CALL 102645 0 1
// exit ;
102806: GO 103249
// end ; x := GetX ( enemy_unit ) ;
102808: LD_ADDR_VAR 0 7
102812: PUSH
102813: LD_VAR 0 2
102817: PPUSH
102818: CALL_OW 250
102822: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
102823: LD_ADDR_VAR 0 8
102827: PUSH
102828: LD_VAR 0 2
102832: PPUSH
102833: CALL_OW 251
102837: ST_TO_ADDR
// if not x or not y then
102838: LD_VAR 0 7
102842: NOT
102843: PUSH
102844: LD_VAR 0 8
102848: NOT
102849: OR
102850: IFFALSE 102854
// exit ;
102852: GO 103249
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
102854: LD_ADDR_VAR 0 6
102858: PUSH
102859: LD_VAR 0 7
102863: PPUSH
102864: LD_INT 0
102866: PPUSH
102867: LD_INT 4
102869: PPUSH
102870: CALL_OW 272
102874: PUSH
102875: LD_VAR 0 8
102879: PPUSH
102880: LD_INT 0
102882: PPUSH
102883: LD_INT 4
102885: PPUSH
102886: CALL_OW 273
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: PUSH
102895: LD_VAR 0 7
102899: PPUSH
102900: LD_INT 1
102902: PPUSH
102903: LD_INT 4
102905: PPUSH
102906: CALL_OW 272
102910: PUSH
102911: LD_VAR 0 8
102915: PPUSH
102916: LD_INT 1
102918: PPUSH
102919: LD_INT 4
102921: PPUSH
102922: CALL_OW 273
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: PUSH
102931: LD_VAR 0 7
102935: PPUSH
102936: LD_INT 2
102938: PPUSH
102939: LD_INT 4
102941: PPUSH
102942: CALL_OW 272
102946: PUSH
102947: LD_VAR 0 8
102951: PPUSH
102952: LD_INT 2
102954: PPUSH
102955: LD_INT 4
102957: PPUSH
102958: CALL_OW 273
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: PUSH
102967: LD_VAR 0 7
102971: PPUSH
102972: LD_INT 3
102974: PPUSH
102975: LD_INT 4
102977: PPUSH
102978: CALL_OW 272
102982: PUSH
102983: LD_VAR 0 8
102987: PPUSH
102988: LD_INT 3
102990: PPUSH
102991: LD_INT 4
102993: PPUSH
102994: CALL_OW 273
102998: PUSH
102999: EMPTY
103000: LIST
103001: LIST
103002: PUSH
103003: LD_VAR 0 7
103007: PPUSH
103008: LD_INT 4
103010: PPUSH
103011: LD_INT 4
103013: PPUSH
103014: CALL_OW 272
103018: PUSH
103019: LD_VAR 0 8
103023: PPUSH
103024: LD_INT 4
103026: PPUSH
103027: LD_INT 4
103029: PPUSH
103030: CALL_OW 273
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: PUSH
103039: LD_VAR 0 7
103043: PPUSH
103044: LD_INT 5
103046: PPUSH
103047: LD_INT 4
103049: PPUSH
103050: CALL_OW 272
103054: PUSH
103055: LD_VAR 0 8
103059: PPUSH
103060: LD_INT 5
103062: PPUSH
103063: LD_INT 4
103065: PPUSH
103066: CALL_OW 273
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: PUSH
103075: EMPTY
103076: LIST
103077: LIST
103078: LIST
103079: LIST
103080: LIST
103081: LIST
103082: ST_TO_ADDR
// for i = tmp downto 1 do
103083: LD_ADDR_VAR 0 4
103087: PUSH
103088: DOUBLE
103089: LD_VAR 0 6
103093: INC
103094: ST_TO_ADDR
103095: LD_INT 1
103097: PUSH
103098: FOR_DOWNTO
103099: IFFALSE 103200
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103101: LD_VAR 0 6
103105: PUSH
103106: LD_VAR 0 4
103110: ARRAY
103111: PUSH
103112: LD_INT 1
103114: ARRAY
103115: PPUSH
103116: LD_VAR 0 6
103120: PUSH
103121: LD_VAR 0 4
103125: ARRAY
103126: PUSH
103127: LD_INT 2
103129: ARRAY
103130: PPUSH
103131: CALL_OW 488
103135: NOT
103136: PUSH
103137: LD_VAR 0 6
103141: PUSH
103142: LD_VAR 0 4
103146: ARRAY
103147: PUSH
103148: LD_INT 1
103150: ARRAY
103151: PPUSH
103152: LD_VAR 0 6
103156: PUSH
103157: LD_VAR 0 4
103161: ARRAY
103162: PUSH
103163: LD_INT 2
103165: ARRAY
103166: PPUSH
103167: CALL_OW 428
103171: PUSH
103172: LD_INT 0
103174: NONEQUAL
103175: OR
103176: IFFALSE 103198
// tmp := Delete ( tmp , i ) ;
103178: LD_ADDR_VAR 0 6
103182: PUSH
103183: LD_VAR 0 6
103187: PPUSH
103188: LD_VAR 0 4
103192: PPUSH
103193: CALL_OW 3
103197: ST_TO_ADDR
103198: GO 103098
103200: POP
103201: POP
// j := GetClosestHex ( unit , tmp ) ;
103202: LD_ADDR_VAR 0 5
103206: PUSH
103207: LD_VAR 0 1
103211: PPUSH
103212: LD_VAR 0 6
103216: PPUSH
103217: CALL 102493 0 2
103221: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103222: LD_VAR 0 1
103226: PPUSH
103227: LD_VAR 0 5
103231: PUSH
103232: LD_INT 1
103234: ARRAY
103235: PPUSH
103236: LD_VAR 0 5
103240: PUSH
103241: LD_INT 2
103243: ARRAY
103244: PPUSH
103245: CALL_OW 111
// end ;
103249: LD_VAR 0 3
103253: RET
// export function PrepareApemanSoldier ( ) ; begin
103254: LD_INT 0
103256: PPUSH
// uc_nation := 0 ;
103257: LD_ADDR_OWVAR 21
103261: PUSH
103262: LD_INT 0
103264: ST_TO_ADDR
// hc_sex := sex_male ;
103265: LD_ADDR_OWVAR 27
103269: PUSH
103270: LD_INT 1
103272: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103273: LD_ADDR_OWVAR 28
103277: PUSH
103278: LD_INT 15
103280: ST_TO_ADDR
// hc_gallery :=  ;
103281: LD_ADDR_OWVAR 33
103285: PUSH
103286: LD_STRING 
103288: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103289: LD_ADDR_OWVAR 31
103293: PUSH
103294: LD_INT 0
103296: PPUSH
103297: LD_INT 3
103299: PPUSH
103300: CALL_OW 12
103304: PUSH
103305: LD_INT 0
103307: PPUSH
103308: LD_INT 3
103310: PPUSH
103311: CALL_OW 12
103315: PUSH
103316: LD_INT 0
103318: PUSH
103319: LD_INT 0
103321: PUSH
103322: EMPTY
103323: LIST
103324: LIST
103325: LIST
103326: LIST
103327: ST_TO_ADDR
// end ;
103328: LD_VAR 0 1
103332: RET
// export function PrepareApemanEngineer ( ) ; begin
103333: LD_INT 0
103335: PPUSH
// uc_nation := 0 ;
103336: LD_ADDR_OWVAR 21
103340: PUSH
103341: LD_INT 0
103343: ST_TO_ADDR
// hc_sex := sex_male ;
103344: LD_ADDR_OWVAR 27
103348: PUSH
103349: LD_INT 1
103351: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103352: LD_ADDR_OWVAR 28
103356: PUSH
103357: LD_INT 16
103359: ST_TO_ADDR
// hc_gallery :=  ;
103360: LD_ADDR_OWVAR 33
103364: PUSH
103365: LD_STRING 
103367: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103368: LD_ADDR_OWVAR 31
103372: PUSH
103373: LD_INT 0
103375: PPUSH
103376: LD_INT 3
103378: PPUSH
103379: CALL_OW 12
103383: PUSH
103384: LD_INT 0
103386: PPUSH
103387: LD_INT 3
103389: PPUSH
103390: CALL_OW 12
103394: PUSH
103395: LD_INT 0
103397: PUSH
103398: LD_INT 0
103400: PUSH
103401: EMPTY
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: ST_TO_ADDR
// end ;
103407: LD_VAR 0 1
103411: RET
// export function PrepareApeman ( agressivity ) ; begin
103412: LD_INT 0
103414: PPUSH
// uc_side := 0 ;
103415: LD_ADDR_OWVAR 20
103419: PUSH
103420: LD_INT 0
103422: ST_TO_ADDR
// uc_nation := 0 ;
103423: LD_ADDR_OWVAR 21
103427: PUSH
103428: LD_INT 0
103430: ST_TO_ADDR
// hc_sex := sex_male ;
103431: LD_ADDR_OWVAR 27
103435: PUSH
103436: LD_INT 1
103438: ST_TO_ADDR
// hc_class := class_apeman ;
103439: LD_ADDR_OWVAR 28
103443: PUSH
103444: LD_INT 12
103446: ST_TO_ADDR
// hc_gallery :=  ;
103447: LD_ADDR_OWVAR 33
103451: PUSH
103452: LD_STRING 
103454: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103455: LD_ADDR_OWVAR 35
103459: PUSH
103460: LD_VAR 0 1
103464: NEG
103465: PPUSH
103466: LD_VAR 0 1
103470: PPUSH
103471: CALL_OW 12
103475: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103476: LD_ADDR_OWVAR 31
103480: PUSH
103481: LD_INT 0
103483: PPUSH
103484: LD_INT 3
103486: PPUSH
103487: CALL_OW 12
103491: PUSH
103492: LD_INT 0
103494: PPUSH
103495: LD_INT 3
103497: PPUSH
103498: CALL_OW 12
103502: PUSH
103503: LD_INT 0
103505: PUSH
103506: LD_INT 0
103508: PUSH
103509: EMPTY
103510: LIST
103511: LIST
103512: LIST
103513: LIST
103514: ST_TO_ADDR
// end ;
103515: LD_VAR 0 2
103519: RET
// export function PrepareTiger ( agressivity ) ; begin
103520: LD_INT 0
103522: PPUSH
// uc_side := 0 ;
103523: LD_ADDR_OWVAR 20
103527: PUSH
103528: LD_INT 0
103530: ST_TO_ADDR
// uc_nation := 0 ;
103531: LD_ADDR_OWVAR 21
103535: PUSH
103536: LD_INT 0
103538: ST_TO_ADDR
// hc_class := class_tiger ;
103539: LD_ADDR_OWVAR 28
103543: PUSH
103544: LD_INT 14
103546: ST_TO_ADDR
// hc_gallery :=  ;
103547: LD_ADDR_OWVAR 33
103551: PUSH
103552: LD_STRING 
103554: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103555: LD_ADDR_OWVAR 35
103559: PUSH
103560: LD_VAR 0 1
103564: NEG
103565: PPUSH
103566: LD_VAR 0 1
103570: PPUSH
103571: CALL_OW 12
103575: ST_TO_ADDR
// end ;
103576: LD_VAR 0 2
103580: RET
// export function PrepareEnchidna ( ) ; begin
103581: LD_INT 0
103583: PPUSH
// uc_side := 0 ;
103584: LD_ADDR_OWVAR 20
103588: PUSH
103589: LD_INT 0
103591: ST_TO_ADDR
// uc_nation := 0 ;
103592: LD_ADDR_OWVAR 21
103596: PUSH
103597: LD_INT 0
103599: ST_TO_ADDR
// hc_class := class_baggie ;
103600: LD_ADDR_OWVAR 28
103604: PUSH
103605: LD_INT 13
103607: ST_TO_ADDR
// hc_gallery :=  ;
103608: LD_ADDR_OWVAR 33
103612: PUSH
103613: LD_STRING 
103615: ST_TO_ADDR
// end ;
103616: LD_VAR 0 1
103620: RET
// export function PrepareFrog ( ) ; begin
103621: LD_INT 0
103623: PPUSH
// uc_side := 0 ;
103624: LD_ADDR_OWVAR 20
103628: PUSH
103629: LD_INT 0
103631: ST_TO_ADDR
// uc_nation := 0 ;
103632: LD_ADDR_OWVAR 21
103636: PUSH
103637: LD_INT 0
103639: ST_TO_ADDR
// hc_class := class_frog ;
103640: LD_ADDR_OWVAR 28
103644: PUSH
103645: LD_INT 19
103647: ST_TO_ADDR
// hc_gallery :=  ;
103648: LD_ADDR_OWVAR 33
103652: PUSH
103653: LD_STRING 
103655: ST_TO_ADDR
// end ;
103656: LD_VAR 0 1
103660: RET
// export function PrepareFish ( ) ; begin
103661: LD_INT 0
103663: PPUSH
// uc_side := 0 ;
103664: LD_ADDR_OWVAR 20
103668: PUSH
103669: LD_INT 0
103671: ST_TO_ADDR
// uc_nation := 0 ;
103672: LD_ADDR_OWVAR 21
103676: PUSH
103677: LD_INT 0
103679: ST_TO_ADDR
// hc_class := class_fish ;
103680: LD_ADDR_OWVAR 28
103684: PUSH
103685: LD_INT 20
103687: ST_TO_ADDR
// hc_gallery :=  ;
103688: LD_ADDR_OWVAR 33
103692: PUSH
103693: LD_STRING 
103695: ST_TO_ADDR
// end ;
103696: LD_VAR 0 1
103700: RET
// export function PrepareBird ( ) ; begin
103701: LD_INT 0
103703: PPUSH
// uc_side := 0 ;
103704: LD_ADDR_OWVAR 20
103708: PUSH
103709: LD_INT 0
103711: ST_TO_ADDR
// uc_nation := 0 ;
103712: LD_ADDR_OWVAR 21
103716: PUSH
103717: LD_INT 0
103719: ST_TO_ADDR
// hc_class := class_phororhacos ;
103720: LD_ADDR_OWVAR 28
103724: PUSH
103725: LD_INT 18
103727: ST_TO_ADDR
// hc_gallery :=  ;
103728: LD_ADDR_OWVAR 33
103732: PUSH
103733: LD_STRING 
103735: ST_TO_ADDR
// end ;
103736: LD_VAR 0 1
103740: RET
// export function PrepareHorse ( ) ; begin
103741: LD_INT 0
103743: PPUSH
// uc_side := 0 ;
103744: LD_ADDR_OWVAR 20
103748: PUSH
103749: LD_INT 0
103751: ST_TO_ADDR
// uc_nation := 0 ;
103752: LD_ADDR_OWVAR 21
103756: PUSH
103757: LD_INT 0
103759: ST_TO_ADDR
// hc_class := class_horse ;
103760: LD_ADDR_OWVAR 28
103764: PUSH
103765: LD_INT 21
103767: ST_TO_ADDR
// hc_gallery :=  ;
103768: LD_ADDR_OWVAR 33
103772: PUSH
103773: LD_STRING 
103775: ST_TO_ADDR
// end ;
103776: LD_VAR 0 1
103780: RET
// export function PrepareMastodont ( ) ; begin
103781: LD_INT 0
103783: PPUSH
// uc_side := 0 ;
103784: LD_ADDR_OWVAR 20
103788: PUSH
103789: LD_INT 0
103791: ST_TO_ADDR
// uc_nation := 0 ;
103792: LD_ADDR_OWVAR 21
103796: PUSH
103797: LD_INT 0
103799: ST_TO_ADDR
// vc_chassis := class_mastodont ;
103800: LD_ADDR_OWVAR 37
103804: PUSH
103805: LD_INT 31
103807: ST_TO_ADDR
// vc_control := control_rider ;
103808: LD_ADDR_OWVAR 38
103812: PUSH
103813: LD_INT 4
103815: ST_TO_ADDR
// end ;
103816: LD_VAR 0 1
103820: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
103821: LD_INT 0
103823: PPUSH
103824: PPUSH
103825: PPUSH
// uc_side = 0 ;
103826: LD_ADDR_OWVAR 20
103830: PUSH
103831: LD_INT 0
103833: ST_TO_ADDR
// uc_nation = 0 ;
103834: LD_ADDR_OWVAR 21
103838: PUSH
103839: LD_INT 0
103841: ST_TO_ADDR
// InitHc_All ( ) ;
103842: CALL_OW 584
// InitVc ;
103846: CALL_OW 20
// if mastodonts then
103850: LD_VAR 0 6
103854: IFFALSE 103921
// for i = 1 to mastodonts do
103856: LD_ADDR_VAR 0 11
103860: PUSH
103861: DOUBLE
103862: LD_INT 1
103864: DEC
103865: ST_TO_ADDR
103866: LD_VAR 0 6
103870: PUSH
103871: FOR_TO
103872: IFFALSE 103919
// begin vc_chassis := 31 ;
103874: LD_ADDR_OWVAR 37
103878: PUSH
103879: LD_INT 31
103881: ST_TO_ADDR
// vc_control := control_rider ;
103882: LD_ADDR_OWVAR 38
103886: PUSH
103887: LD_INT 4
103889: ST_TO_ADDR
// animal := CreateVehicle ;
103890: LD_ADDR_VAR 0 12
103894: PUSH
103895: CALL_OW 45
103899: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103900: LD_VAR 0 12
103904: PPUSH
103905: LD_VAR 0 8
103909: PPUSH
103910: LD_INT 0
103912: PPUSH
103913: CALL 106049 0 3
// end ;
103917: GO 103871
103919: POP
103920: POP
// if horses then
103921: LD_VAR 0 5
103925: IFFALSE 103992
// for i = 1 to horses do
103927: LD_ADDR_VAR 0 11
103931: PUSH
103932: DOUBLE
103933: LD_INT 1
103935: DEC
103936: ST_TO_ADDR
103937: LD_VAR 0 5
103941: PUSH
103942: FOR_TO
103943: IFFALSE 103990
// begin hc_class := 21 ;
103945: LD_ADDR_OWVAR 28
103949: PUSH
103950: LD_INT 21
103952: ST_TO_ADDR
// hc_gallery :=  ;
103953: LD_ADDR_OWVAR 33
103957: PUSH
103958: LD_STRING 
103960: ST_TO_ADDR
// animal := CreateHuman ;
103961: LD_ADDR_VAR 0 12
103965: PUSH
103966: CALL_OW 44
103970: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103971: LD_VAR 0 12
103975: PPUSH
103976: LD_VAR 0 8
103980: PPUSH
103981: LD_INT 0
103983: PPUSH
103984: CALL 106049 0 3
// end ;
103988: GO 103942
103990: POP
103991: POP
// if birds then
103992: LD_VAR 0 1
103996: IFFALSE 104063
// for i = 1 to birds do
103998: LD_ADDR_VAR 0 11
104002: PUSH
104003: DOUBLE
104004: LD_INT 1
104006: DEC
104007: ST_TO_ADDR
104008: LD_VAR 0 1
104012: PUSH
104013: FOR_TO
104014: IFFALSE 104061
// begin hc_class := 18 ;
104016: LD_ADDR_OWVAR 28
104020: PUSH
104021: LD_INT 18
104023: ST_TO_ADDR
// hc_gallery =  ;
104024: LD_ADDR_OWVAR 33
104028: PUSH
104029: LD_STRING 
104031: ST_TO_ADDR
// animal := CreateHuman ;
104032: LD_ADDR_VAR 0 12
104036: PUSH
104037: CALL_OW 44
104041: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104042: LD_VAR 0 12
104046: PPUSH
104047: LD_VAR 0 8
104051: PPUSH
104052: LD_INT 0
104054: PPUSH
104055: CALL 106049 0 3
// end ;
104059: GO 104013
104061: POP
104062: POP
// if tigers then
104063: LD_VAR 0 2
104067: IFFALSE 104151
// for i = 1 to tigers do
104069: LD_ADDR_VAR 0 11
104073: PUSH
104074: DOUBLE
104075: LD_INT 1
104077: DEC
104078: ST_TO_ADDR
104079: LD_VAR 0 2
104083: PUSH
104084: FOR_TO
104085: IFFALSE 104149
// begin hc_class = class_tiger ;
104087: LD_ADDR_OWVAR 28
104091: PUSH
104092: LD_INT 14
104094: ST_TO_ADDR
// hc_gallery =  ;
104095: LD_ADDR_OWVAR 33
104099: PUSH
104100: LD_STRING 
104102: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104103: LD_ADDR_OWVAR 35
104107: PUSH
104108: LD_INT 7
104110: NEG
104111: PPUSH
104112: LD_INT 7
104114: PPUSH
104115: CALL_OW 12
104119: ST_TO_ADDR
// animal := CreateHuman ;
104120: LD_ADDR_VAR 0 12
104124: PUSH
104125: CALL_OW 44
104129: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104130: LD_VAR 0 12
104134: PPUSH
104135: LD_VAR 0 8
104139: PPUSH
104140: LD_INT 0
104142: PPUSH
104143: CALL 106049 0 3
// end ;
104147: GO 104084
104149: POP
104150: POP
// if apemans then
104151: LD_VAR 0 3
104155: IFFALSE 104278
// for i = 1 to apemans do
104157: LD_ADDR_VAR 0 11
104161: PUSH
104162: DOUBLE
104163: LD_INT 1
104165: DEC
104166: ST_TO_ADDR
104167: LD_VAR 0 3
104171: PUSH
104172: FOR_TO
104173: IFFALSE 104276
// begin hc_class = class_apeman ;
104175: LD_ADDR_OWVAR 28
104179: PUSH
104180: LD_INT 12
104182: ST_TO_ADDR
// hc_gallery =  ;
104183: LD_ADDR_OWVAR 33
104187: PUSH
104188: LD_STRING 
104190: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104191: LD_ADDR_OWVAR 35
104195: PUSH
104196: LD_INT 2
104198: NEG
104199: PPUSH
104200: LD_INT 2
104202: PPUSH
104203: CALL_OW 12
104207: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104208: LD_ADDR_OWVAR 31
104212: PUSH
104213: LD_INT 1
104215: PPUSH
104216: LD_INT 3
104218: PPUSH
104219: CALL_OW 12
104223: PUSH
104224: LD_INT 1
104226: PPUSH
104227: LD_INT 3
104229: PPUSH
104230: CALL_OW 12
104234: PUSH
104235: LD_INT 0
104237: PUSH
104238: LD_INT 0
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: ST_TO_ADDR
// animal := CreateHuman ;
104247: LD_ADDR_VAR 0 12
104251: PUSH
104252: CALL_OW 44
104256: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104257: LD_VAR 0 12
104261: PPUSH
104262: LD_VAR 0 8
104266: PPUSH
104267: LD_INT 0
104269: PPUSH
104270: CALL 106049 0 3
// end ;
104274: GO 104172
104276: POP
104277: POP
// if enchidnas then
104278: LD_VAR 0 4
104282: IFFALSE 104349
// for i = 1 to enchidnas do
104284: LD_ADDR_VAR 0 11
104288: PUSH
104289: DOUBLE
104290: LD_INT 1
104292: DEC
104293: ST_TO_ADDR
104294: LD_VAR 0 4
104298: PUSH
104299: FOR_TO
104300: IFFALSE 104347
// begin hc_class = 13 ;
104302: LD_ADDR_OWVAR 28
104306: PUSH
104307: LD_INT 13
104309: ST_TO_ADDR
// hc_gallery =  ;
104310: LD_ADDR_OWVAR 33
104314: PUSH
104315: LD_STRING 
104317: ST_TO_ADDR
// animal := CreateHuman ;
104318: LD_ADDR_VAR 0 12
104322: PUSH
104323: CALL_OW 44
104327: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104328: LD_VAR 0 12
104332: PPUSH
104333: LD_VAR 0 8
104337: PPUSH
104338: LD_INT 0
104340: PPUSH
104341: CALL 106049 0 3
// end ;
104345: GO 104299
104347: POP
104348: POP
// if fishes then
104349: LD_VAR 0 7
104353: IFFALSE 104420
// for i = 1 to fishes do
104355: LD_ADDR_VAR 0 11
104359: PUSH
104360: DOUBLE
104361: LD_INT 1
104363: DEC
104364: ST_TO_ADDR
104365: LD_VAR 0 7
104369: PUSH
104370: FOR_TO
104371: IFFALSE 104418
// begin hc_class = 20 ;
104373: LD_ADDR_OWVAR 28
104377: PUSH
104378: LD_INT 20
104380: ST_TO_ADDR
// hc_gallery =  ;
104381: LD_ADDR_OWVAR 33
104385: PUSH
104386: LD_STRING 
104388: ST_TO_ADDR
// animal := CreateHuman ;
104389: LD_ADDR_VAR 0 12
104393: PUSH
104394: CALL_OW 44
104398: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104399: LD_VAR 0 12
104403: PPUSH
104404: LD_VAR 0 9
104408: PPUSH
104409: LD_INT 0
104411: PPUSH
104412: CALL 106049 0 3
// end ;
104416: GO 104370
104418: POP
104419: POP
// end ;
104420: LD_VAR 0 10
104424: RET
// export function WantHeal ( sci , unit ) ; begin
104425: LD_INT 0
104427: PPUSH
// if GetTaskList ( sci ) > 0 then
104428: LD_VAR 0 1
104432: PPUSH
104433: CALL_OW 437
104437: PUSH
104438: LD_INT 0
104440: GREATER
104441: IFFALSE 104511
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104443: LD_VAR 0 1
104447: PPUSH
104448: CALL_OW 437
104452: PUSH
104453: LD_INT 1
104455: ARRAY
104456: PUSH
104457: LD_INT 1
104459: ARRAY
104460: PUSH
104461: LD_STRING l
104463: EQUAL
104464: PUSH
104465: LD_VAR 0 1
104469: PPUSH
104470: CALL_OW 437
104474: PUSH
104475: LD_INT 1
104477: ARRAY
104478: PUSH
104479: LD_INT 4
104481: ARRAY
104482: PUSH
104483: LD_VAR 0 2
104487: EQUAL
104488: AND
104489: IFFALSE 104501
// result := true else
104491: LD_ADDR_VAR 0 3
104495: PUSH
104496: LD_INT 1
104498: ST_TO_ADDR
104499: GO 104509
// result := false ;
104501: LD_ADDR_VAR 0 3
104505: PUSH
104506: LD_INT 0
104508: ST_TO_ADDR
// end else
104509: GO 104519
// result := false ;
104511: LD_ADDR_VAR 0 3
104515: PUSH
104516: LD_INT 0
104518: ST_TO_ADDR
// end ;
104519: LD_VAR 0 3
104523: RET
// export function HealTarget ( sci ) ; begin
104524: LD_INT 0
104526: PPUSH
// if not sci then
104527: LD_VAR 0 1
104531: NOT
104532: IFFALSE 104536
// exit ;
104534: GO 104601
// result := 0 ;
104536: LD_ADDR_VAR 0 2
104540: PUSH
104541: LD_INT 0
104543: ST_TO_ADDR
// if GetTaskList ( sci ) then
104544: LD_VAR 0 1
104548: PPUSH
104549: CALL_OW 437
104553: IFFALSE 104601
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104555: LD_VAR 0 1
104559: PPUSH
104560: CALL_OW 437
104564: PUSH
104565: LD_INT 1
104567: ARRAY
104568: PUSH
104569: LD_INT 1
104571: ARRAY
104572: PUSH
104573: LD_STRING l
104575: EQUAL
104576: IFFALSE 104601
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104578: LD_ADDR_VAR 0 2
104582: PUSH
104583: LD_VAR 0 1
104587: PPUSH
104588: CALL_OW 437
104592: PUSH
104593: LD_INT 1
104595: ARRAY
104596: PUSH
104597: LD_INT 4
104599: ARRAY
104600: ST_TO_ADDR
// end ;
104601: LD_VAR 0 2
104605: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104606: LD_INT 0
104608: PPUSH
104609: PPUSH
104610: PPUSH
104611: PPUSH
// if not base_units then
104612: LD_VAR 0 1
104616: NOT
104617: IFFALSE 104621
// exit ;
104619: GO 104708
// result := false ;
104621: LD_ADDR_VAR 0 2
104625: PUSH
104626: LD_INT 0
104628: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104629: LD_ADDR_VAR 0 5
104633: PUSH
104634: LD_VAR 0 1
104638: PPUSH
104639: LD_INT 21
104641: PUSH
104642: LD_INT 3
104644: PUSH
104645: EMPTY
104646: LIST
104647: LIST
104648: PPUSH
104649: CALL_OW 72
104653: ST_TO_ADDR
// if not tmp then
104654: LD_VAR 0 5
104658: NOT
104659: IFFALSE 104663
// exit ;
104661: GO 104708
// for i in tmp do
104663: LD_ADDR_VAR 0 3
104667: PUSH
104668: LD_VAR 0 5
104672: PUSH
104673: FOR_IN
104674: IFFALSE 104706
// begin result := EnemyInRange ( i , 22 ) ;
104676: LD_ADDR_VAR 0 2
104680: PUSH
104681: LD_VAR 0 3
104685: PPUSH
104686: LD_INT 22
104688: PPUSH
104689: CALL 102295 0 2
104693: ST_TO_ADDR
// if result then
104694: LD_VAR 0 2
104698: IFFALSE 104704
// exit ;
104700: POP
104701: POP
104702: GO 104708
// end ;
104704: GO 104673
104706: POP
104707: POP
// end ;
104708: LD_VAR 0 2
104712: RET
// export function FilterByTag ( units , tag ) ; begin
104713: LD_INT 0
104715: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104716: LD_ADDR_VAR 0 3
104720: PUSH
104721: LD_VAR 0 1
104725: PPUSH
104726: LD_INT 120
104728: PUSH
104729: LD_VAR 0 2
104733: PUSH
104734: EMPTY
104735: LIST
104736: LIST
104737: PPUSH
104738: CALL_OW 72
104742: ST_TO_ADDR
// end ;
104743: LD_VAR 0 3
104747: RET
// export function IsDriver ( un ) ; begin
104748: LD_INT 0
104750: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104751: LD_ADDR_VAR 0 2
104755: PUSH
104756: LD_VAR 0 1
104760: PUSH
104761: LD_INT 55
104763: PUSH
104764: EMPTY
104765: LIST
104766: PPUSH
104767: CALL_OW 69
104771: IN
104772: ST_TO_ADDR
// end ;
104773: LD_VAR 0 2
104777: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104778: LD_INT 0
104780: PPUSH
104781: PPUSH
// list := [ ] ;
104782: LD_ADDR_VAR 0 5
104786: PUSH
104787: EMPTY
104788: ST_TO_ADDR
// case d of 0 :
104789: LD_VAR 0 3
104793: PUSH
104794: LD_INT 0
104796: DOUBLE
104797: EQUAL
104798: IFTRUE 104802
104800: GO 104935
104802: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104803: LD_ADDR_VAR 0 5
104807: PUSH
104808: LD_VAR 0 1
104812: PUSH
104813: LD_INT 4
104815: MINUS
104816: PUSH
104817: LD_VAR 0 2
104821: PUSH
104822: LD_INT 4
104824: MINUS
104825: PUSH
104826: LD_INT 2
104828: PUSH
104829: EMPTY
104830: LIST
104831: LIST
104832: LIST
104833: PUSH
104834: LD_VAR 0 1
104838: PUSH
104839: LD_INT 3
104841: MINUS
104842: PUSH
104843: LD_VAR 0 2
104847: PUSH
104848: LD_INT 1
104850: PUSH
104851: EMPTY
104852: LIST
104853: LIST
104854: LIST
104855: PUSH
104856: LD_VAR 0 1
104860: PUSH
104861: LD_INT 4
104863: PLUS
104864: PUSH
104865: LD_VAR 0 2
104869: PUSH
104870: LD_INT 4
104872: PUSH
104873: EMPTY
104874: LIST
104875: LIST
104876: LIST
104877: PUSH
104878: LD_VAR 0 1
104882: PUSH
104883: LD_INT 3
104885: PLUS
104886: PUSH
104887: LD_VAR 0 2
104891: PUSH
104892: LD_INT 3
104894: PLUS
104895: PUSH
104896: LD_INT 5
104898: PUSH
104899: EMPTY
104900: LIST
104901: LIST
104902: LIST
104903: PUSH
104904: LD_VAR 0 1
104908: PUSH
104909: LD_VAR 0 2
104913: PUSH
104914: LD_INT 4
104916: PLUS
104917: PUSH
104918: LD_INT 0
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: LIST
104925: PUSH
104926: EMPTY
104927: LIST
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: ST_TO_ADDR
// end ; 1 :
104933: GO 105633
104935: LD_INT 1
104937: DOUBLE
104938: EQUAL
104939: IFTRUE 104943
104941: GO 105076
104943: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104944: LD_ADDR_VAR 0 5
104948: PUSH
104949: LD_VAR 0 1
104953: PUSH
104954: LD_VAR 0 2
104958: PUSH
104959: LD_INT 4
104961: MINUS
104962: PUSH
104963: LD_INT 3
104965: PUSH
104966: EMPTY
104967: LIST
104968: LIST
104969: LIST
104970: PUSH
104971: LD_VAR 0 1
104975: PUSH
104976: LD_INT 3
104978: MINUS
104979: PUSH
104980: LD_VAR 0 2
104984: PUSH
104985: LD_INT 3
104987: MINUS
104988: PUSH
104989: LD_INT 2
104991: PUSH
104992: EMPTY
104993: LIST
104994: LIST
104995: LIST
104996: PUSH
104997: LD_VAR 0 1
105001: PUSH
105002: LD_INT 4
105004: MINUS
105005: PUSH
105006: LD_VAR 0 2
105010: PUSH
105011: LD_INT 1
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: LIST
105018: PUSH
105019: LD_VAR 0 1
105023: PUSH
105024: LD_VAR 0 2
105028: PUSH
105029: LD_INT 3
105031: PLUS
105032: PUSH
105033: LD_INT 0
105035: PUSH
105036: EMPTY
105037: LIST
105038: LIST
105039: LIST
105040: PUSH
105041: LD_VAR 0 1
105045: PUSH
105046: LD_INT 4
105048: PLUS
105049: PUSH
105050: LD_VAR 0 2
105054: PUSH
105055: LD_INT 4
105057: PLUS
105058: PUSH
105059: LD_INT 5
105061: PUSH
105062: EMPTY
105063: LIST
105064: LIST
105065: LIST
105066: PUSH
105067: EMPTY
105068: LIST
105069: LIST
105070: LIST
105071: LIST
105072: LIST
105073: ST_TO_ADDR
// end ; 2 :
105074: GO 105633
105076: LD_INT 2
105078: DOUBLE
105079: EQUAL
105080: IFTRUE 105084
105082: GO 105213
105084: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105085: LD_ADDR_VAR 0 5
105089: PUSH
105090: LD_VAR 0 1
105094: PUSH
105095: LD_VAR 0 2
105099: PUSH
105100: LD_INT 3
105102: MINUS
105103: PUSH
105104: LD_INT 3
105106: PUSH
105107: EMPTY
105108: LIST
105109: LIST
105110: LIST
105111: PUSH
105112: LD_VAR 0 1
105116: PUSH
105117: LD_INT 4
105119: PLUS
105120: PUSH
105121: LD_VAR 0 2
105125: PUSH
105126: LD_INT 4
105128: PUSH
105129: EMPTY
105130: LIST
105131: LIST
105132: LIST
105133: PUSH
105134: LD_VAR 0 1
105138: PUSH
105139: LD_VAR 0 2
105143: PUSH
105144: LD_INT 4
105146: PLUS
105147: PUSH
105148: LD_INT 0
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: LIST
105155: PUSH
105156: LD_VAR 0 1
105160: PUSH
105161: LD_INT 3
105163: MINUS
105164: PUSH
105165: LD_VAR 0 2
105169: PUSH
105170: LD_INT 1
105172: PUSH
105173: EMPTY
105174: LIST
105175: LIST
105176: LIST
105177: PUSH
105178: LD_VAR 0 1
105182: PUSH
105183: LD_INT 4
105185: MINUS
105186: PUSH
105187: LD_VAR 0 2
105191: PUSH
105192: LD_INT 4
105194: MINUS
105195: PUSH
105196: LD_INT 2
105198: PUSH
105199: EMPTY
105200: LIST
105201: LIST
105202: LIST
105203: PUSH
105204: EMPTY
105205: LIST
105206: LIST
105207: LIST
105208: LIST
105209: LIST
105210: ST_TO_ADDR
// end ; 3 :
105211: GO 105633
105213: LD_INT 3
105215: DOUBLE
105216: EQUAL
105217: IFTRUE 105221
105219: GO 105354
105221: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105222: LD_ADDR_VAR 0 5
105226: PUSH
105227: LD_VAR 0 1
105231: PUSH
105232: LD_INT 3
105234: PLUS
105235: PUSH
105236: LD_VAR 0 2
105240: PUSH
105241: LD_INT 4
105243: PUSH
105244: EMPTY
105245: LIST
105246: LIST
105247: LIST
105248: PUSH
105249: LD_VAR 0 1
105253: PUSH
105254: LD_INT 4
105256: PLUS
105257: PUSH
105258: LD_VAR 0 2
105262: PUSH
105263: LD_INT 4
105265: PLUS
105266: PUSH
105267: LD_INT 5
105269: PUSH
105270: EMPTY
105271: LIST
105272: LIST
105273: LIST
105274: PUSH
105275: LD_VAR 0 1
105279: PUSH
105280: LD_INT 4
105282: MINUS
105283: PUSH
105284: LD_VAR 0 2
105288: PUSH
105289: LD_INT 1
105291: PUSH
105292: EMPTY
105293: LIST
105294: LIST
105295: LIST
105296: PUSH
105297: LD_VAR 0 1
105301: PUSH
105302: LD_VAR 0 2
105306: PUSH
105307: LD_INT 4
105309: MINUS
105310: PUSH
105311: LD_INT 3
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: LIST
105318: PUSH
105319: LD_VAR 0 1
105323: PUSH
105324: LD_INT 3
105326: MINUS
105327: PUSH
105328: LD_VAR 0 2
105332: PUSH
105333: LD_INT 3
105335: MINUS
105336: PUSH
105337: LD_INT 2
105339: PUSH
105340: EMPTY
105341: LIST
105342: LIST
105343: LIST
105344: PUSH
105345: EMPTY
105346: LIST
105347: LIST
105348: LIST
105349: LIST
105350: LIST
105351: ST_TO_ADDR
// end ; 4 :
105352: GO 105633
105354: LD_INT 4
105356: DOUBLE
105357: EQUAL
105358: IFTRUE 105362
105360: GO 105495
105362: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105363: LD_ADDR_VAR 0 5
105367: PUSH
105368: LD_VAR 0 1
105372: PUSH
105373: LD_VAR 0 2
105377: PUSH
105378: LD_INT 4
105380: PLUS
105381: PUSH
105382: LD_INT 0
105384: PUSH
105385: EMPTY
105386: LIST
105387: LIST
105388: LIST
105389: PUSH
105390: LD_VAR 0 1
105394: PUSH
105395: LD_INT 3
105397: PLUS
105398: PUSH
105399: LD_VAR 0 2
105403: PUSH
105404: LD_INT 3
105406: PLUS
105407: PUSH
105408: LD_INT 5
105410: PUSH
105411: EMPTY
105412: LIST
105413: LIST
105414: LIST
105415: PUSH
105416: LD_VAR 0 1
105420: PUSH
105421: LD_INT 4
105423: PLUS
105424: PUSH
105425: LD_VAR 0 2
105429: PUSH
105430: LD_INT 4
105432: PUSH
105433: EMPTY
105434: LIST
105435: LIST
105436: LIST
105437: PUSH
105438: LD_VAR 0 1
105442: PUSH
105443: LD_VAR 0 2
105447: PUSH
105448: LD_INT 3
105450: MINUS
105451: PUSH
105452: LD_INT 3
105454: PUSH
105455: EMPTY
105456: LIST
105457: LIST
105458: LIST
105459: PUSH
105460: LD_VAR 0 1
105464: PUSH
105465: LD_INT 4
105467: MINUS
105468: PUSH
105469: LD_VAR 0 2
105473: PUSH
105474: LD_INT 4
105476: MINUS
105477: PUSH
105478: LD_INT 2
105480: PUSH
105481: EMPTY
105482: LIST
105483: LIST
105484: LIST
105485: PUSH
105486: EMPTY
105487: LIST
105488: LIST
105489: LIST
105490: LIST
105491: LIST
105492: ST_TO_ADDR
// end ; 5 :
105493: GO 105633
105495: LD_INT 5
105497: DOUBLE
105498: EQUAL
105499: IFTRUE 105503
105501: GO 105632
105503: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105504: LD_ADDR_VAR 0 5
105508: PUSH
105509: LD_VAR 0 1
105513: PUSH
105514: LD_INT 4
105516: MINUS
105517: PUSH
105518: LD_VAR 0 2
105522: PUSH
105523: LD_INT 1
105525: PUSH
105526: EMPTY
105527: LIST
105528: LIST
105529: LIST
105530: PUSH
105531: LD_VAR 0 1
105535: PUSH
105536: LD_VAR 0 2
105540: PUSH
105541: LD_INT 4
105543: MINUS
105544: PUSH
105545: LD_INT 3
105547: PUSH
105548: EMPTY
105549: LIST
105550: LIST
105551: LIST
105552: PUSH
105553: LD_VAR 0 1
105557: PUSH
105558: LD_INT 4
105560: PLUS
105561: PUSH
105562: LD_VAR 0 2
105566: PUSH
105567: LD_INT 4
105569: PLUS
105570: PUSH
105571: LD_INT 5
105573: PUSH
105574: EMPTY
105575: LIST
105576: LIST
105577: LIST
105578: PUSH
105579: LD_VAR 0 1
105583: PUSH
105584: LD_INT 3
105586: PLUS
105587: PUSH
105588: LD_VAR 0 2
105592: PUSH
105593: LD_INT 4
105595: PUSH
105596: EMPTY
105597: LIST
105598: LIST
105599: LIST
105600: PUSH
105601: LD_VAR 0 1
105605: PUSH
105606: LD_VAR 0 2
105610: PUSH
105611: LD_INT 3
105613: PLUS
105614: PUSH
105615: LD_INT 0
105617: PUSH
105618: EMPTY
105619: LIST
105620: LIST
105621: LIST
105622: PUSH
105623: EMPTY
105624: LIST
105625: LIST
105626: LIST
105627: LIST
105628: LIST
105629: ST_TO_ADDR
// end ; end ;
105630: GO 105633
105632: POP
// result := list ;
105633: LD_ADDR_VAR 0 4
105637: PUSH
105638: LD_VAR 0 5
105642: ST_TO_ADDR
// end ;
105643: LD_VAR 0 4
105647: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105648: LD_INT 0
105650: PPUSH
105651: PPUSH
105652: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105653: LD_VAR 0 1
105657: NOT
105658: PUSH
105659: LD_VAR 0 2
105663: PUSH
105664: LD_INT 1
105666: PUSH
105667: LD_INT 2
105669: PUSH
105670: LD_INT 3
105672: PUSH
105673: LD_INT 4
105675: PUSH
105676: EMPTY
105677: LIST
105678: LIST
105679: LIST
105680: LIST
105681: IN
105682: NOT
105683: OR
105684: IFFALSE 105688
// exit ;
105686: GO 105771
// tmp := [ ] ;
105688: LD_ADDR_VAR 0 5
105692: PUSH
105693: EMPTY
105694: ST_TO_ADDR
// for i in units do
105695: LD_ADDR_VAR 0 4
105699: PUSH
105700: LD_VAR 0 1
105704: PUSH
105705: FOR_IN
105706: IFFALSE 105740
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105708: LD_ADDR_VAR 0 5
105712: PUSH
105713: LD_VAR 0 5
105717: PPUSH
105718: LD_VAR 0 4
105722: PPUSH
105723: LD_VAR 0 2
105727: PPUSH
105728: CALL_OW 259
105732: PPUSH
105733: CALL 107144 0 2
105737: ST_TO_ADDR
105738: GO 105705
105740: POP
105741: POP
// if not tmp then
105742: LD_VAR 0 5
105746: NOT
105747: IFFALSE 105751
// exit ;
105749: GO 105771
// result := SortListByListDesc ( units , tmp ) ;
105751: LD_ADDR_VAR 0 3
105755: PUSH
105756: LD_VAR 0 1
105760: PPUSH
105761: LD_VAR 0 5
105765: PPUSH
105766: CALL_OW 77
105770: ST_TO_ADDR
// end ;
105771: LD_VAR 0 3
105775: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105776: LD_INT 0
105778: PPUSH
105779: PPUSH
105780: PPUSH
// result := false ;
105781: LD_ADDR_VAR 0 3
105785: PUSH
105786: LD_INT 0
105788: ST_TO_ADDR
// if not building then
105789: LD_VAR 0 2
105793: NOT
105794: IFFALSE 105798
// exit ;
105796: GO 105936
// x := GetX ( building ) ;
105798: LD_ADDR_VAR 0 4
105802: PUSH
105803: LD_VAR 0 2
105807: PPUSH
105808: CALL_OW 250
105812: ST_TO_ADDR
// y := GetY ( building ) ;
105813: LD_ADDR_VAR 0 5
105817: PUSH
105818: LD_VAR 0 2
105822: PPUSH
105823: CALL_OW 251
105827: ST_TO_ADDR
// if not x or not y then
105828: LD_VAR 0 4
105832: NOT
105833: PUSH
105834: LD_VAR 0 5
105838: NOT
105839: OR
105840: IFFALSE 105844
// exit ;
105842: GO 105936
// if GetTaskList ( unit ) then
105844: LD_VAR 0 1
105848: PPUSH
105849: CALL_OW 437
105853: IFFALSE 105936
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105855: LD_STRING e
105857: PUSH
105858: LD_VAR 0 1
105862: PPUSH
105863: CALL_OW 437
105867: PUSH
105868: LD_INT 1
105870: ARRAY
105871: PUSH
105872: LD_INT 1
105874: ARRAY
105875: EQUAL
105876: PUSH
105877: LD_VAR 0 4
105881: PUSH
105882: LD_VAR 0 1
105886: PPUSH
105887: CALL_OW 437
105891: PUSH
105892: LD_INT 1
105894: ARRAY
105895: PUSH
105896: LD_INT 2
105898: ARRAY
105899: EQUAL
105900: AND
105901: PUSH
105902: LD_VAR 0 5
105906: PUSH
105907: LD_VAR 0 1
105911: PPUSH
105912: CALL_OW 437
105916: PUSH
105917: LD_INT 1
105919: ARRAY
105920: PUSH
105921: LD_INT 3
105923: ARRAY
105924: EQUAL
105925: AND
105926: IFFALSE 105936
// result := true end ;
105928: LD_ADDR_VAR 0 3
105932: PUSH
105933: LD_INT 1
105935: ST_TO_ADDR
// end ;
105936: LD_VAR 0 3
105940: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
105941: LD_INT 0
105943: PPUSH
// result := false ;
105944: LD_ADDR_VAR 0 4
105948: PUSH
105949: LD_INT 0
105951: ST_TO_ADDR
// if GetTaskList ( unit ) then
105952: LD_VAR 0 1
105956: PPUSH
105957: CALL_OW 437
105961: IFFALSE 106044
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105963: LD_STRING M
105965: PUSH
105966: LD_VAR 0 1
105970: PPUSH
105971: CALL_OW 437
105975: PUSH
105976: LD_INT 1
105978: ARRAY
105979: PUSH
105980: LD_INT 1
105982: ARRAY
105983: EQUAL
105984: PUSH
105985: LD_VAR 0 2
105989: PUSH
105990: LD_VAR 0 1
105994: PPUSH
105995: CALL_OW 437
105999: PUSH
106000: LD_INT 1
106002: ARRAY
106003: PUSH
106004: LD_INT 2
106006: ARRAY
106007: EQUAL
106008: AND
106009: PUSH
106010: LD_VAR 0 3
106014: PUSH
106015: LD_VAR 0 1
106019: PPUSH
106020: CALL_OW 437
106024: PUSH
106025: LD_INT 1
106027: ARRAY
106028: PUSH
106029: LD_INT 3
106031: ARRAY
106032: EQUAL
106033: AND
106034: IFFALSE 106044
// result := true ;
106036: LD_ADDR_VAR 0 4
106040: PUSH
106041: LD_INT 1
106043: ST_TO_ADDR
// end ; end ;
106044: LD_VAR 0 4
106048: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106049: LD_INT 0
106051: PPUSH
106052: PPUSH
106053: PPUSH
106054: PPUSH
// if not unit or not area then
106055: LD_VAR 0 1
106059: NOT
106060: PUSH
106061: LD_VAR 0 2
106065: NOT
106066: OR
106067: IFFALSE 106071
// exit ;
106069: GO 106247
// tmp := AreaToList ( area , i ) ;
106071: LD_ADDR_VAR 0 6
106075: PUSH
106076: LD_VAR 0 2
106080: PPUSH
106081: LD_VAR 0 5
106085: PPUSH
106086: CALL_OW 517
106090: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106091: LD_ADDR_VAR 0 5
106095: PUSH
106096: DOUBLE
106097: LD_INT 1
106099: DEC
106100: ST_TO_ADDR
106101: LD_VAR 0 6
106105: PUSH
106106: LD_INT 1
106108: ARRAY
106109: PUSH
106110: FOR_TO
106111: IFFALSE 106245
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106113: LD_ADDR_VAR 0 7
106117: PUSH
106118: LD_VAR 0 6
106122: PUSH
106123: LD_INT 1
106125: ARRAY
106126: PUSH
106127: LD_VAR 0 5
106131: ARRAY
106132: PUSH
106133: LD_VAR 0 6
106137: PUSH
106138: LD_INT 2
106140: ARRAY
106141: PUSH
106142: LD_VAR 0 5
106146: ARRAY
106147: PUSH
106148: EMPTY
106149: LIST
106150: LIST
106151: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106152: LD_INT 92
106154: PUSH
106155: LD_VAR 0 7
106159: PUSH
106160: LD_INT 1
106162: ARRAY
106163: PUSH
106164: LD_VAR 0 7
106168: PUSH
106169: LD_INT 2
106171: ARRAY
106172: PUSH
106173: LD_INT 2
106175: PUSH
106176: EMPTY
106177: LIST
106178: LIST
106179: LIST
106180: LIST
106181: PPUSH
106182: CALL_OW 69
106186: PUSH
106187: LD_INT 0
106189: EQUAL
106190: IFFALSE 106243
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106192: LD_VAR 0 1
106196: PPUSH
106197: LD_VAR 0 7
106201: PUSH
106202: LD_INT 1
106204: ARRAY
106205: PPUSH
106206: LD_VAR 0 7
106210: PUSH
106211: LD_INT 2
106213: ARRAY
106214: PPUSH
106215: LD_VAR 0 3
106219: PPUSH
106220: CALL_OW 48
// result := IsPlaced ( unit ) ;
106224: LD_ADDR_VAR 0 4
106228: PUSH
106229: LD_VAR 0 1
106233: PPUSH
106234: CALL_OW 305
106238: ST_TO_ADDR
// exit ;
106239: POP
106240: POP
106241: GO 106247
// end ; end ;
106243: GO 106110
106245: POP
106246: POP
// end ;
106247: LD_VAR 0 4
106251: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106252: LD_INT 0
106254: PPUSH
106255: PPUSH
106256: PPUSH
// if not side or side > 8 then
106257: LD_VAR 0 1
106261: NOT
106262: PUSH
106263: LD_VAR 0 1
106267: PUSH
106268: LD_INT 8
106270: GREATER
106271: OR
106272: IFFALSE 106276
// exit ;
106274: GO 106463
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106276: LD_ADDR_VAR 0 4
106280: PUSH
106281: LD_INT 22
106283: PUSH
106284: LD_VAR 0 1
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: PUSH
106293: LD_INT 21
106295: PUSH
106296: LD_INT 3
106298: PUSH
106299: EMPTY
106300: LIST
106301: LIST
106302: PUSH
106303: EMPTY
106304: LIST
106305: LIST
106306: PPUSH
106307: CALL_OW 69
106311: ST_TO_ADDR
// if not tmp then
106312: LD_VAR 0 4
106316: NOT
106317: IFFALSE 106321
// exit ;
106319: GO 106463
// enable_addtolog := true ;
106321: LD_ADDR_OWVAR 81
106325: PUSH
106326: LD_INT 1
106328: ST_TO_ADDR
// AddToLog ( [ ) ;
106329: LD_STRING [
106331: PPUSH
106332: CALL_OW 561
// for i in tmp do
106336: LD_ADDR_VAR 0 3
106340: PUSH
106341: LD_VAR 0 4
106345: PUSH
106346: FOR_IN
106347: IFFALSE 106454
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106349: LD_STRING [
106351: PUSH
106352: LD_VAR 0 3
106356: PPUSH
106357: CALL_OW 266
106361: STR
106362: PUSH
106363: LD_STRING , 
106365: STR
106366: PUSH
106367: LD_VAR 0 3
106371: PPUSH
106372: CALL_OW 250
106376: STR
106377: PUSH
106378: LD_STRING , 
106380: STR
106381: PUSH
106382: LD_VAR 0 3
106386: PPUSH
106387: CALL_OW 251
106391: STR
106392: PUSH
106393: LD_STRING , 
106395: STR
106396: PUSH
106397: LD_VAR 0 3
106401: PPUSH
106402: CALL_OW 254
106406: STR
106407: PUSH
106408: LD_STRING , 
106410: STR
106411: PUSH
106412: LD_VAR 0 3
106416: PPUSH
106417: LD_INT 1
106419: PPUSH
106420: CALL_OW 268
106424: STR
106425: PUSH
106426: LD_STRING , 
106428: STR
106429: PUSH
106430: LD_VAR 0 3
106434: PPUSH
106435: LD_INT 2
106437: PPUSH
106438: CALL_OW 268
106442: STR
106443: PUSH
106444: LD_STRING ],
106446: STR
106447: PPUSH
106448: CALL_OW 561
// end ;
106452: GO 106346
106454: POP
106455: POP
// AddToLog ( ]; ) ;
106456: LD_STRING ];
106458: PPUSH
106459: CALL_OW 561
// end ;
106463: LD_VAR 0 2
106467: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106468: LD_INT 0
106470: PPUSH
106471: PPUSH
106472: PPUSH
106473: PPUSH
106474: PPUSH
// if not area or not rate or not max then
106475: LD_VAR 0 1
106479: NOT
106480: PUSH
106481: LD_VAR 0 2
106485: NOT
106486: OR
106487: PUSH
106488: LD_VAR 0 4
106492: NOT
106493: OR
106494: IFFALSE 106498
// exit ;
106496: GO 106687
// while 1 do
106498: LD_INT 1
106500: IFFALSE 106687
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106502: LD_ADDR_VAR 0 9
106506: PUSH
106507: LD_VAR 0 1
106511: PPUSH
106512: LD_INT 1
106514: PPUSH
106515: CALL_OW 287
106519: PUSH
106520: LD_INT 10
106522: MUL
106523: ST_TO_ADDR
// r := rate / 10 ;
106524: LD_ADDR_VAR 0 7
106528: PUSH
106529: LD_VAR 0 2
106533: PUSH
106534: LD_INT 10
106536: DIVREAL
106537: ST_TO_ADDR
// time := 1 1$00 ;
106538: LD_ADDR_VAR 0 8
106542: PUSH
106543: LD_INT 2100
106545: ST_TO_ADDR
// if amount < min then
106546: LD_VAR 0 9
106550: PUSH
106551: LD_VAR 0 3
106555: LESS
106556: IFFALSE 106574
// r := r * 2 else
106558: LD_ADDR_VAR 0 7
106562: PUSH
106563: LD_VAR 0 7
106567: PUSH
106568: LD_INT 2
106570: MUL
106571: ST_TO_ADDR
106572: GO 106600
// if amount > max then
106574: LD_VAR 0 9
106578: PUSH
106579: LD_VAR 0 4
106583: GREATER
106584: IFFALSE 106600
// r := r / 2 ;
106586: LD_ADDR_VAR 0 7
106590: PUSH
106591: LD_VAR 0 7
106595: PUSH
106596: LD_INT 2
106598: DIVREAL
106599: ST_TO_ADDR
// time := time / r ;
106600: LD_ADDR_VAR 0 8
106604: PUSH
106605: LD_VAR 0 8
106609: PUSH
106610: LD_VAR 0 7
106614: DIVREAL
106615: ST_TO_ADDR
// if time < 0 then
106616: LD_VAR 0 8
106620: PUSH
106621: LD_INT 0
106623: LESS
106624: IFFALSE 106641
// time := time * - 1 ;
106626: LD_ADDR_VAR 0 8
106630: PUSH
106631: LD_VAR 0 8
106635: PUSH
106636: LD_INT 1
106638: NEG
106639: MUL
106640: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106641: LD_VAR 0 8
106645: PUSH
106646: LD_INT 35
106648: PPUSH
106649: LD_INT 875
106651: PPUSH
106652: CALL_OW 12
106656: PLUS
106657: PPUSH
106658: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106662: LD_INT 1
106664: PPUSH
106665: LD_INT 5
106667: PPUSH
106668: CALL_OW 12
106672: PPUSH
106673: LD_VAR 0 1
106677: PPUSH
106678: LD_INT 1
106680: PPUSH
106681: CALL_OW 55
// end ;
106685: GO 106498
// end ;
106687: LD_VAR 0 5
106691: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106692: LD_INT 0
106694: PPUSH
106695: PPUSH
106696: PPUSH
106697: PPUSH
106698: PPUSH
106699: PPUSH
106700: PPUSH
106701: PPUSH
// if not turrets or not factories then
106702: LD_VAR 0 1
106706: NOT
106707: PUSH
106708: LD_VAR 0 2
106712: NOT
106713: OR
106714: IFFALSE 106718
// exit ;
106716: GO 107025
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106718: LD_ADDR_VAR 0 10
106722: PUSH
106723: LD_INT 5
106725: PUSH
106726: LD_INT 6
106728: PUSH
106729: EMPTY
106730: LIST
106731: LIST
106732: PUSH
106733: LD_INT 2
106735: PUSH
106736: LD_INT 4
106738: PUSH
106739: EMPTY
106740: LIST
106741: LIST
106742: PUSH
106743: LD_INT 3
106745: PUSH
106746: LD_INT 5
106748: PUSH
106749: EMPTY
106750: LIST
106751: LIST
106752: PUSH
106753: EMPTY
106754: LIST
106755: LIST
106756: LIST
106757: PUSH
106758: LD_INT 24
106760: PUSH
106761: LD_INT 25
106763: PUSH
106764: EMPTY
106765: LIST
106766: LIST
106767: PUSH
106768: LD_INT 23
106770: PUSH
106771: LD_INT 27
106773: PUSH
106774: EMPTY
106775: LIST
106776: LIST
106777: PUSH
106778: EMPTY
106779: LIST
106780: LIST
106781: PUSH
106782: LD_INT 42
106784: PUSH
106785: LD_INT 43
106787: PUSH
106788: EMPTY
106789: LIST
106790: LIST
106791: PUSH
106792: LD_INT 44
106794: PUSH
106795: LD_INT 46
106797: PUSH
106798: EMPTY
106799: LIST
106800: LIST
106801: PUSH
106802: LD_INT 45
106804: PUSH
106805: LD_INT 47
106807: PUSH
106808: EMPTY
106809: LIST
106810: LIST
106811: PUSH
106812: EMPTY
106813: LIST
106814: LIST
106815: LIST
106816: PUSH
106817: EMPTY
106818: LIST
106819: LIST
106820: LIST
106821: ST_TO_ADDR
// result := [ ] ;
106822: LD_ADDR_VAR 0 3
106826: PUSH
106827: EMPTY
106828: ST_TO_ADDR
// for i in turrets do
106829: LD_ADDR_VAR 0 4
106833: PUSH
106834: LD_VAR 0 1
106838: PUSH
106839: FOR_IN
106840: IFFALSE 107023
// begin nat := GetNation ( i ) ;
106842: LD_ADDR_VAR 0 7
106846: PUSH
106847: LD_VAR 0 4
106851: PPUSH
106852: CALL_OW 248
106856: ST_TO_ADDR
// weapon := 0 ;
106857: LD_ADDR_VAR 0 8
106861: PUSH
106862: LD_INT 0
106864: ST_TO_ADDR
// if not nat then
106865: LD_VAR 0 7
106869: NOT
106870: IFFALSE 106874
// continue ;
106872: GO 106839
// for j in list [ nat ] do
106874: LD_ADDR_VAR 0 5
106878: PUSH
106879: LD_VAR 0 10
106883: PUSH
106884: LD_VAR 0 7
106888: ARRAY
106889: PUSH
106890: FOR_IN
106891: IFFALSE 106932
// if GetBWeapon ( i ) = j [ 1 ] then
106893: LD_VAR 0 4
106897: PPUSH
106898: CALL_OW 269
106902: PUSH
106903: LD_VAR 0 5
106907: PUSH
106908: LD_INT 1
106910: ARRAY
106911: EQUAL
106912: IFFALSE 106930
// begin weapon := j [ 2 ] ;
106914: LD_ADDR_VAR 0 8
106918: PUSH
106919: LD_VAR 0 5
106923: PUSH
106924: LD_INT 2
106926: ARRAY
106927: ST_TO_ADDR
// break ;
106928: GO 106932
// end ;
106930: GO 106890
106932: POP
106933: POP
// if not weapon then
106934: LD_VAR 0 8
106938: NOT
106939: IFFALSE 106943
// continue ;
106941: GO 106839
// for k in factories do
106943: LD_ADDR_VAR 0 6
106947: PUSH
106948: LD_VAR 0 2
106952: PUSH
106953: FOR_IN
106954: IFFALSE 107019
// begin weapons := AvailableWeaponList ( k ) ;
106956: LD_ADDR_VAR 0 9
106960: PUSH
106961: LD_VAR 0 6
106965: PPUSH
106966: CALL_OW 478
106970: ST_TO_ADDR
// if not weapons then
106971: LD_VAR 0 9
106975: NOT
106976: IFFALSE 106980
// continue ;
106978: GO 106953
// if weapon in weapons then
106980: LD_VAR 0 8
106984: PUSH
106985: LD_VAR 0 9
106989: IN
106990: IFFALSE 107017
// begin result := [ i , weapon ] ;
106992: LD_ADDR_VAR 0 3
106996: PUSH
106997: LD_VAR 0 4
107001: PUSH
107002: LD_VAR 0 8
107006: PUSH
107007: EMPTY
107008: LIST
107009: LIST
107010: ST_TO_ADDR
// exit ;
107011: POP
107012: POP
107013: POP
107014: POP
107015: GO 107025
// end ; end ;
107017: GO 106953
107019: POP
107020: POP
// end ;
107021: GO 106839
107023: POP
107024: POP
// end ;
107025: LD_VAR 0 3
107029: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107030: LD_INT 0
107032: PPUSH
// if not side or side > 8 then
107033: LD_VAR 0 3
107037: NOT
107038: PUSH
107039: LD_VAR 0 3
107043: PUSH
107044: LD_INT 8
107046: GREATER
107047: OR
107048: IFFALSE 107052
// exit ;
107050: GO 107111
// if not range then
107052: LD_VAR 0 4
107056: NOT
107057: IFFALSE 107068
// range := - 12 ;
107059: LD_ADDR_VAR 0 4
107063: PUSH
107064: LD_INT 12
107066: NEG
107067: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107068: LD_VAR 0 1
107072: PPUSH
107073: LD_VAR 0 2
107077: PPUSH
107078: LD_VAR 0 3
107082: PPUSH
107083: LD_VAR 0 4
107087: PPUSH
107088: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107092: LD_VAR 0 1
107096: PPUSH
107097: LD_VAR 0 2
107101: PPUSH
107102: LD_VAR 0 3
107106: PPUSH
107107: CALL_OW 331
// end ;
107111: LD_VAR 0 5
107115: RET
// export function Video ( mode ) ; begin
107116: LD_INT 0
107118: PPUSH
// ingame_video = mode ;
107119: LD_ADDR_OWVAR 52
107123: PUSH
107124: LD_VAR 0 1
107128: ST_TO_ADDR
// interface_hidden = mode ;
107129: LD_ADDR_OWVAR 54
107133: PUSH
107134: LD_VAR 0 1
107138: ST_TO_ADDR
// end ;
107139: LD_VAR 0 2
107143: RET
// export function Join ( array , element ) ; begin
107144: LD_INT 0
107146: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107147: LD_ADDR_VAR 0 3
107151: PUSH
107152: LD_VAR 0 1
107156: PPUSH
107157: LD_VAR 0 1
107161: PUSH
107162: LD_INT 1
107164: PLUS
107165: PPUSH
107166: LD_VAR 0 2
107170: PPUSH
107171: CALL_OW 1
107175: ST_TO_ADDR
// end ;
107176: LD_VAR 0 3
107180: RET
// export function JoinUnion ( array , element ) ; begin
107181: LD_INT 0
107183: PPUSH
// result := array union element ;
107184: LD_ADDR_VAR 0 3
107188: PUSH
107189: LD_VAR 0 1
107193: PUSH
107194: LD_VAR 0 2
107198: UNION
107199: ST_TO_ADDR
// end ;
107200: LD_VAR 0 3
107204: RET
// export function GetBehemoths ( side ) ; begin
107205: LD_INT 0
107207: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107208: LD_ADDR_VAR 0 2
107212: PUSH
107213: LD_INT 22
107215: PUSH
107216: LD_VAR 0 1
107220: PUSH
107221: EMPTY
107222: LIST
107223: LIST
107224: PUSH
107225: LD_INT 31
107227: PUSH
107228: LD_INT 25
107230: PUSH
107231: EMPTY
107232: LIST
107233: LIST
107234: PUSH
107235: EMPTY
107236: LIST
107237: LIST
107238: PPUSH
107239: CALL_OW 69
107243: ST_TO_ADDR
// end ;
107244: LD_VAR 0 2
107248: RET
// export function Shuffle ( array ) ; var i , index ; begin
107249: LD_INT 0
107251: PPUSH
107252: PPUSH
107253: PPUSH
// result := [ ] ;
107254: LD_ADDR_VAR 0 2
107258: PUSH
107259: EMPTY
107260: ST_TO_ADDR
// if not array then
107261: LD_VAR 0 1
107265: NOT
107266: IFFALSE 107270
// exit ;
107268: GO 107369
// Randomize ;
107270: CALL_OW 10
// for i = array downto 1 do
107274: LD_ADDR_VAR 0 3
107278: PUSH
107279: DOUBLE
107280: LD_VAR 0 1
107284: INC
107285: ST_TO_ADDR
107286: LD_INT 1
107288: PUSH
107289: FOR_DOWNTO
107290: IFFALSE 107367
// begin index := rand ( 1 , array ) ;
107292: LD_ADDR_VAR 0 4
107296: PUSH
107297: LD_INT 1
107299: PPUSH
107300: LD_VAR 0 1
107304: PPUSH
107305: CALL_OW 12
107309: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107310: LD_ADDR_VAR 0 2
107314: PUSH
107315: LD_VAR 0 2
107319: PPUSH
107320: LD_VAR 0 2
107324: PUSH
107325: LD_INT 1
107327: PLUS
107328: PPUSH
107329: LD_VAR 0 1
107333: PUSH
107334: LD_VAR 0 4
107338: ARRAY
107339: PPUSH
107340: CALL_OW 2
107344: ST_TO_ADDR
// array := Delete ( array , index ) ;
107345: LD_ADDR_VAR 0 1
107349: PUSH
107350: LD_VAR 0 1
107354: PPUSH
107355: LD_VAR 0 4
107359: PPUSH
107360: CALL_OW 3
107364: ST_TO_ADDR
// end ;
107365: GO 107289
107367: POP
107368: POP
// end ;
107369: LD_VAR 0 2
107373: RET
// export function GetBaseMaterials ( base ) ; begin
107374: LD_INT 0
107376: PPUSH
// result := [ 0 , 0 , 0 ] ;
107377: LD_ADDR_VAR 0 2
107381: PUSH
107382: LD_INT 0
107384: PUSH
107385: LD_INT 0
107387: PUSH
107388: LD_INT 0
107390: PUSH
107391: EMPTY
107392: LIST
107393: LIST
107394: LIST
107395: ST_TO_ADDR
// if not base then
107396: LD_VAR 0 1
107400: NOT
107401: IFFALSE 107405
// exit ;
107403: GO 107454
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107405: LD_ADDR_VAR 0 2
107409: PUSH
107410: LD_VAR 0 1
107414: PPUSH
107415: LD_INT 1
107417: PPUSH
107418: CALL_OW 275
107422: PUSH
107423: LD_VAR 0 1
107427: PPUSH
107428: LD_INT 2
107430: PPUSH
107431: CALL_OW 275
107435: PUSH
107436: LD_VAR 0 1
107440: PPUSH
107441: LD_INT 3
107443: PPUSH
107444: CALL_OW 275
107448: PUSH
107449: EMPTY
107450: LIST
107451: LIST
107452: LIST
107453: ST_TO_ADDR
// end ;
107454: LD_VAR 0 2
107458: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107459: LD_INT 0
107461: PPUSH
107462: PPUSH
// result := array ;
107463: LD_ADDR_VAR 0 3
107467: PUSH
107468: LD_VAR 0 1
107472: ST_TO_ADDR
// if size >= result then
107473: LD_VAR 0 2
107477: PUSH
107478: LD_VAR 0 3
107482: GREATEREQUAL
107483: IFFALSE 107487
// exit ;
107485: GO 107537
// if size then
107487: LD_VAR 0 2
107491: IFFALSE 107537
// for i := array downto size do
107493: LD_ADDR_VAR 0 4
107497: PUSH
107498: DOUBLE
107499: LD_VAR 0 1
107503: INC
107504: ST_TO_ADDR
107505: LD_VAR 0 2
107509: PUSH
107510: FOR_DOWNTO
107511: IFFALSE 107535
// result := Delete ( result , result ) ;
107513: LD_ADDR_VAR 0 3
107517: PUSH
107518: LD_VAR 0 3
107522: PPUSH
107523: LD_VAR 0 3
107527: PPUSH
107528: CALL_OW 3
107532: ST_TO_ADDR
107533: GO 107510
107535: POP
107536: POP
// end ;
107537: LD_VAR 0 3
107541: RET
// export function ComExit ( unit ) ; var tmp ; begin
107542: LD_INT 0
107544: PPUSH
107545: PPUSH
// if not IsInUnit ( unit ) then
107546: LD_VAR 0 1
107550: PPUSH
107551: CALL_OW 310
107555: NOT
107556: IFFALSE 107560
// exit ;
107558: GO 107620
// tmp := IsInUnit ( unit ) ;
107560: LD_ADDR_VAR 0 3
107564: PUSH
107565: LD_VAR 0 1
107569: PPUSH
107570: CALL_OW 310
107574: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107575: LD_VAR 0 3
107579: PPUSH
107580: CALL_OW 247
107584: PUSH
107585: LD_INT 2
107587: EQUAL
107588: IFFALSE 107601
// ComExitVehicle ( unit ) else
107590: LD_VAR 0 1
107594: PPUSH
107595: CALL_OW 121
107599: GO 107610
// ComExitBuilding ( unit ) ;
107601: LD_VAR 0 1
107605: PPUSH
107606: CALL_OW 122
// result := tmp ;
107610: LD_ADDR_VAR 0 2
107614: PUSH
107615: LD_VAR 0 3
107619: ST_TO_ADDR
// end ;
107620: LD_VAR 0 2
107624: RET
// export function ComExitAll ( units ) ; var i ; begin
107625: LD_INT 0
107627: PPUSH
107628: PPUSH
// if not units then
107629: LD_VAR 0 1
107633: NOT
107634: IFFALSE 107638
// exit ;
107636: GO 107664
// for i in units do
107638: LD_ADDR_VAR 0 3
107642: PUSH
107643: LD_VAR 0 1
107647: PUSH
107648: FOR_IN
107649: IFFALSE 107662
// ComExit ( i ) ;
107651: LD_VAR 0 3
107655: PPUSH
107656: CALL 107542 0 1
107660: GO 107648
107662: POP
107663: POP
// end ;
107664: LD_VAR 0 2
107668: RET
// export function ResetHc ; begin
107669: LD_INT 0
107671: PPUSH
// InitHc ;
107672: CALL_OW 19
// hc_importance := 0 ;
107676: LD_ADDR_OWVAR 32
107680: PUSH
107681: LD_INT 0
107683: ST_TO_ADDR
// end ;
107684: LD_VAR 0 1
107688: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107689: LD_INT 0
107691: PPUSH
107692: PPUSH
107693: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107694: LD_ADDR_VAR 0 6
107698: PUSH
107699: LD_VAR 0 1
107703: PUSH
107704: LD_VAR 0 3
107708: PLUS
107709: PUSH
107710: LD_INT 2
107712: DIV
107713: ST_TO_ADDR
// if _x < 0 then
107714: LD_VAR 0 6
107718: PUSH
107719: LD_INT 0
107721: LESS
107722: IFFALSE 107739
// _x := _x * - 1 ;
107724: LD_ADDR_VAR 0 6
107728: PUSH
107729: LD_VAR 0 6
107733: PUSH
107734: LD_INT 1
107736: NEG
107737: MUL
107738: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107739: LD_ADDR_VAR 0 7
107743: PUSH
107744: LD_VAR 0 2
107748: PUSH
107749: LD_VAR 0 4
107753: PLUS
107754: PUSH
107755: LD_INT 2
107757: DIV
107758: ST_TO_ADDR
// if _y < 0 then
107759: LD_VAR 0 7
107763: PUSH
107764: LD_INT 0
107766: LESS
107767: IFFALSE 107784
// _y := _y * - 1 ;
107769: LD_ADDR_VAR 0 7
107773: PUSH
107774: LD_VAR 0 7
107778: PUSH
107779: LD_INT 1
107781: NEG
107782: MUL
107783: ST_TO_ADDR
// result := [ _x , _y ] ;
107784: LD_ADDR_VAR 0 5
107788: PUSH
107789: LD_VAR 0 6
107793: PUSH
107794: LD_VAR 0 7
107798: PUSH
107799: EMPTY
107800: LIST
107801: LIST
107802: ST_TO_ADDR
// end ;
107803: LD_VAR 0 5
107807: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
107808: LD_INT 0
107810: PPUSH
107811: PPUSH
107812: PPUSH
107813: PPUSH
// task := GetTaskList ( unit ) ;
107814: LD_ADDR_VAR 0 7
107818: PUSH
107819: LD_VAR 0 1
107823: PPUSH
107824: CALL_OW 437
107828: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
107829: LD_VAR 0 7
107833: NOT
107834: PUSH
107835: LD_VAR 0 1
107839: PPUSH
107840: LD_VAR 0 2
107844: PPUSH
107845: CALL_OW 308
107849: NOT
107850: AND
107851: IFFALSE 107855
// exit ;
107853: GO 107973
// if IsInArea ( unit , area ) then
107855: LD_VAR 0 1
107859: PPUSH
107860: LD_VAR 0 2
107864: PPUSH
107865: CALL_OW 308
107869: IFFALSE 107887
// begin ComMoveToArea ( unit , goAway ) ;
107871: LD_VAR 0 1
107875: PPUSH
107876: LD_VAR 0 3
107880: PPUSH
107881: CALL_OW 113
// exit ;
107885: GO 107973
// end ; if task [ 1 ] [ 1 ] <> M then
107887: LD_VAR 0 7
107891: PUSH
107892: LD_INT 1
107894: ARRAY
107895: PUSH
107896: LD_INT 1
107898: ARRAY
107899: PUSH
107900: LD_STRING M
107902: NONEQUAL
107903: IFFALSE 107907
// exit ;
107905: GO 107973
// x := task [ 1 ] [ 2 ] ;
107907: LD_ADDR_VAR 0 5
107911: PUSH
107912: LD_VAR 0 7
107916: PUSH
107917: LD_INT 1
107919: ARRAY
107920: PUSH
107921: LD_INT 2
107923: ARRAY
107924: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
107925: LD_ADDR_VAR 0 6
107929: PUSH
107930: LD_VAR 0 7
107934: PUSH
107935: LD_INT 1
107937: ARRAY
107938: PUSH
107939: LD_INT 3
107941: ARRAY
107942: ST_TO_ADDR
// if InArea ( x , y , area ) then
107943: LD_VAR 0 5
107947: PPUSH
107948: LD_VAR 0 6
107952: PPUSH
107953: LD_VAR 0 2
107957: PPUSH
107958: CALL_OW 309
107962: IFFALSE 107973
// ComStop ( unit ) ;
107964: LD_VAR 0 1
107968: PPUSH
107969: CALL_OW 141
// end ;
107973: LD_VAR 0 4
107977: RET
// export function Abs ( value ) ; begin
107978: LD_INT 0
107980: PPUSH
// result := value ;
107981: LD_ADDR_VAR 0 2
107985: PUSH
107986: LD_VAR 0 1
107990: ST_TO_ADDR
// if value < 0 then
107991: LD_VAR 0 1
107995: PUSH
107996: LD_INT 0
107998: LESS
107999: IFFALSE 108016
// result := value * - 1 ;
108001: LD_ADDR_VAR 0 2
108005: PUSH
108006: LD_VAR 0 1
108010: PUSH
108011: LD_INT 1
108013: NEG
108014: MUL
108015: ST_TO_ADDR
// end ;
108016: LD_VAR 0 2
108020: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108021: LD_INT 0
108023: PPUSH
108024: PPUSH
108025: PPUSH
108026: PPUSH
108027: PPUSH
108028: PPUSH
108029: PPUSH
108030: PPUSH
// if not unit or not building then
108031: LD_VAR 0 1
108035: NOT
108036: PUSH
108037: LD_VAR 0 2
108041: NOT
108042: OR
108043: IFFALSE 108047
// exit ;
108045: GO 108273
// x := GetX ( building ) ;
108047: LD_ADDR_VAR 0 4
108051: PUSH
108052: LD_VAR 0 2
108056: PPUSH
108057: CALL_OW 250
108061: ST_TO_ADDR
// y := GetY ( building ) ;
108062: LD_ADDR_VAR 0 6
108066: PUSH
108067: LD_VAR 0 2
108071: PPUSH
108072: CALL_OW 251
108076: ST_TO_ADDR
// d := GetDir ( building ) ;
108077: LD_ADDR_VAR 0 8
108081: PUSH
108082: LD_VAR 0 2
108086: PPUSH
108087: CALL_OW 254
108091: ST_TO_ADDR
// r := 4 ;
108092: LD_ADDR_VAR 0 9
108096: PUSH
108097: LD_INT 4
108099: ST_TO_ADDR
// for i := 1 to 5 do
108100: LD_ADDR_VAR 0 10
108104: PUSH
108105: DOUBLE
108106: LD_INT 1
108108: DEC
108109: ST_TO_ADDR
108110: LD_INT 5
108112: PUSH
108113: FOR_TO
108114: IFFALSE 108271
// begin _x := ShiftX ( x , d , r + i ) ;
108116: LD_ADDR_VAR 0 5
108120: PUSH
108121: LD_VAR 0 4
108125: PPUSH
108126: LD_VAR 0 8
108130: PPUSH
108131: LD_VAR 0 9
108135: PUSH
108136: LD_VAR 0 10
108140: PLUS
108141: PPUSH
108142: CALL_OW 272
108146: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108147: LD_ADDR_VAR 0 7
108151: PUSH
108152: LD_VAR 0 6
108156: PPUSH
108157: LD_VAR 0 8
108161: PPUSH
108162: LD_VAR 0 9
108166: PUSH
108167: LD_VAR 0 10
108171: PLUS
108172: PPUSH
108173: CALL_OW 273
108177: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108178: LD_VAR 0 5
108182: PPUSH
108183: LD_VAR 0 7
108187: PPUSH
108188: CALL_OW 488
108192: PUSH
108193: LD_VAR 0 5
108197: PPUSH
108198: LD_VAR 0 7
108202: PPUSH
108203: CALL_OW 428
108207: PPUSH
108208: CALL_OW 247
108212: PUSH
108213: LD_INT 3
108215: PUSH
108216: LD_INT 2
108218: PUSH
108219: EMPTY
108220: LIST
108221: LIST
108222: IN
108223: NOT
108224: AND
108225: IFFALSE 108269
// begin ComMoveXY ( unit , _x , _y ) ;
108227: LD_VAR 0 1
108231: PPUSH
108232: LD_VAR 0 5
108236: PPUSH
108237: LD_VAR 0 7
108241: PPUSH
108242: CALL_OW 111
// result := [ _x , _y ] ;
108246: LD_ADDR_VAR 0 3
108250: PUSH
108251: LD_VAR 0 5
108255: PUSH
108256: LD_VAR 0 7
108260: PUSH
108261: EMPTY
108262: LIST
108263: LIST
108264: ST_TO_ADDR
// exit ;
108265: POP
108266: POP
108267: GO 108273
// end ; end ;
108269: GO 108113
108271: POP
108272: POP
// end ;
108273: LD_VAR 0 3
108277: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108278: LD_INT 0
108280: PPUSH
108281: PPUSH
108282: PPUSH
// result := 0 ;
108283: LD_ADDR_VAR 0 3
108287: PUSH
108288: LD_INT 0
108290: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108291: LD_VAR 0 1
108295: PUSH
108296: LD_INT 0
108298: LESS
108299: PUSH
108300: LD_VAR 0 1
108304: PUSH
108305: LD_INT 8
108307: GREATER
108308: OR
108309: PUSH
108310: LD_VAR 0 2
108314: PUSH
108315: LD_INT 0
108317: LESS
108318: OR
108319: PUSH
108320: LD_VAR 0 2
108324: PUSH
108325: LD_INT 8
108327: GREATER
108328: OR
108329: IFFALSE 108333
// exit ;
108331: GO 108408
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108333: LD_ADDR_VAR 0 4
108337: PUSH
108338: LD_INT 22
108340: PUSH
108341: LD_VAR 0 2
108345: PUSH
108346: EMPTY
108347: LIST
108348: LIST
108349: PPUSH
108350: CALL_OW 69
108354: PUSH
108355: FOR_IN
108356: IFFALSE 108406
// begin un := UnitShoot ( i ) ;
108358: LD_ADDR_VAR 0 5
108362: PUSH
108363: LD_VAR 0 4
108367: PPUSH
108368: CALL_OW 504
108372: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108373: LD_VAR 0 5
108377: PPUSH
108378: CALL_OW 255
108382: PUSH
108383: LD_VAR 0 1
108387: EQUAL
108388: IFFALSE 108404
// begin result := un ;
108390: LD_ADDR_VAR 0 3
108394: PUSH
108395: LD_VAR 0 5
108399: ST_TO_ADDR
// exit ;
108400: POP
108401: POP
108402: GO 108408
// end ; end ;
108404: GO 108355
108406: POP
108407: POP
// end ;
108408: LD_VAR 0 3
108412: RET
// export function GetCargoBay ( units ) ; begin
108413: LD_INT 0
108415: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108416: LD_ADDR_VAR 0 2
108420: PUSH
108421: LD_VAR 0 1
108425: PPUSH
108426: LD_INT 2
108428: PUSH
108429: LD_INT 34
108431: PUSH
108432: LD_INT 12
108434: PUSH
108435: EMPTY
108436: LIST
108437: LIST
108438: PUSH
108439: LD_INT 34
108441: PUSH
108442: LD_INT 51
108444: PUSH
108445: EMPTY
108446: LIST
108447: LIST
108448: PUSH
108449: LD_INT 34
108451: PUSH
108452: LD_INT 32
108454: PUSH
108455: EMPTY
108456: LIST
108457: LIST
108458: PUSH
108459: LD_INT 34
108461: PUSH
108462: LD_INT 89
108464: PUSH
108465: EMPTY
108466: LIST
108467: LIST
108468: PUSH
108469: EMPTY
108470: LIST
108471: LIST
108472: LIST
108473: LIST
108474: LIST
108475: PPUSH
108476: CALL_OW 72
108480: ST_TO_ADDR
// end ;
108481: LD_VAR 0 2
108485: RET
// export function Negate ( value ) ; begin
108486: LD_INT 0
108488: PPUSH
// result := not value ;
108489: LD_ADDR_VAR 0 2
108493: PUSH
108494: LD_VAR 0 1
108498: NOT
108499: ST_TO_ADDR
// end ;
108500: LD_VAR 0 2
108504: RET
// export function Inc ( value ) ; begin
108505: LD_INT 0
108507: PPUSH
// result := value + 1 ;
108508: LD_ADDR_VAR 0 2
108512: PUSH
108513: LD_VAR 0 1
108517: PUSH
108518: LD_INT 1
108520: PLUS
108521: ST_TO_ADDR
// end ;
108522: LD_VAR 0 2
108526: RET
// export function Dec ( value ) ; begin
108527: LD_INT 0
108529: PPUSH
// result := value - 1 ;
108530: LD_ADDR_VAR 0 2
108534: PUSH
108535: LD_VAR 0 1
108539: PUSH
108540: LD_INT 1
108542: MINUS
108543: ST_TO_ADDR
// end ;
108544: LD_VAR 0 2
108548: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108549: LD_INT 0
108551: PPUSH
108552: PPUSH
108553: PPUSH
108554: PPUSH
108555: PPUSH
108556: PPUSH
108557: PPUSH
108558: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108559: LD_VAR 0 1
108563: PPUSH
108564: LD_VAR 0 2
108568: PPUSH
108569: CALL_OW 488
108573: NOT
108574: PUSH
108575: LD_VAR 0 3
108579: PPUSH
108580: LD_VAR 0 4
108584: PPUSH
108585: CALL_OW 488
108589: NOT
108590: OR
108591: IFFALSE 108604
// begin result := - 1 ;
108593: LD_ADDR_VAR 0 5
108597: PUSH
108598: LD_INT 1
108600: NEG
108601: ST_TO_ADDR
// exit ;
108602: GO 108839
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108604: LD_ADDR_VAR 0 12
108608: PUSH
108609: LD_VAR 0 1
108613: PPUSH
108614: LD_VAR 0 2
108618: PPUSH
108619: LD_VAR 0 3
108623: PPUSH
108624: LD_VAR 0 4
108628: PPUSH
108629: CALL 107689 0 4
108633: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108634: LD_ADDR_VAR 0 11
108638: PUSH
108639: LD_VAR 0 1
108643: PPUSH
108644: LD_VAR 0 2
108648: PPUSH
108649: LD_VAR 0 12
108653: PUSH
108654: LD_INT 1
108656: ARRAY
108657: PPUSH
108658: LD_VAR 0 12
108662: PUSH
108663: LD_INT 2
108665: ARRAY
108666: PPUSH
108667: CALL_OW 298
108671: ST_TO_ADDR
// distance := 9999 ;
108672: LD_ADDR_VAR 0 10
108676: PUSH
108677: LD_INT 9999
108679: ST_TO_ADDR
// for i := 0 to 5 do
108680: LD_ADDR_VAR 0 6
108684: PUSH
108685: DOUBLE
108686: LD_INT 0
108688: DEC
108689: ST_TO_ADDR
108690: LD_INT 5
108692: PUSH
108693: FOR_TO
108694: IFFALSE 108837
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108696: LD_ADDR_VAR 0 7
108700: PUSH
108701: LD_VAR 0 1
108705: PPUSH
108706: LD_VAR 0 6
108710: PPUSH
108711: LD_VAR 0 11
108715: PPUSH
108716: CALL_OW 272
108720: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108721: LD_ADDR_VAR 0 8
108725: PUSH
108726: LD_VAR 0 2
108730: PPUSH
108731: LD_VAR 0 6
108735: PPUSH
108736: LD_VAR 0 11
108740: PPUSH
108741: CALL_OW 273
108745: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108746: LD_VAR 0 7
108750: PPUSH
108751: LD_VAR 0 8
108755: PPUSH
108756: CALL_OW 488
108760: NOT
108761: IFFALSE 108765
// continue ;
108763: GO 108693
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108765: LD_ADDR_VAR 0 9
108769: PUSH
108770: LD_VAR 0 12
108774: PUSH
108775: LD_INT 1
108777: ARRAY
108778: PPUSH
108779: LD_VAR 0 12
108783: PUSH
108784: LD_INT 2
108786: ARRAY
108787: PPUSH
108788: LD_VAR 0 7
108792: PPUSH
108793: LD_VAR 0 8
108797: PPUSH
108798: CALL_OW 298
108802: ST_TO_ADDR
// if tmp < distance then
108803: LD_VAR 0 9
108807: PUSH
108808: LD_VAR 0 10
108812: LESS
108813: IFFALSE 108835
// begin result := i ;
108815: LD_ADDR_VAR 0 5
108819: PUSH
108820: LD_VAR 0 6
108824: ST_TO_ADDR
// distance := tmp ;
108825: LD_ADDR_VAR 0 10
108829: PUSH
108830: LD_VAR 0 9
108834: ST_TO_ADDR
// end ; end ;
108835: GO 108693
108837: POP
108838: POP
// end ;
108839: LD_VAR 0 5
108843: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108844: LD_INT 0
108846: PPUSH
108847: PPUSH
// if not driver or not IsInUnit ( driver ) then
108848: LD_VAR 0 1
108852: NOT
108853: PUSH
108854: LD_VAR 0 1
108858: PPUSH
108859: CALL_OW 310
108863: NOT
108864: OR
108865: IFFALSE 108869
// exit ;
108867: GO 108959
// vehicle := IsInUnit ( driver ) ;
108869: LD_ADDR_VAR 0 3
108873: PUSH
108874: LD_VAR 0 1
108878: PPUSH
108879: CALL_OW 310
108883: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108884: LD_VAR 0 1
108888: PPUSH
108889: LD_STRING \
108891: PUSH
108892: LD_INT 0
108894: PUSH
108895: LD_INT 0
108897: PUSH
108898: LD_INT 0
108900: PUSH
108901: LD_INT 0
108903: PUSH
108904: LD_INT 0
108906: PUSH
108907: LD_INT 0
108909: PUSH
108910: EMPTY
108911: LIST
108912: LIST
108913: LIST
108914: LIST
108915: LIST
108916: LIST
108917: LIST
108918: PUSH
108919: LD_STRING E
108921: PUSH
108922: LD_INT 0
108924: PUSH
108925: LD_INT 0
108927: PUSH
108928: LD_VAR 0 3
108932: PUSH
108933: LD_INT 0
108935: PUSH
108936: LD_INT 0
108938: PUSH
108939: LD_INT 0
108941: PUSH
108942: EMPTY
108943: LIST
108944: LIST
108945: LIST
108946: LIST
108947: LIST
108948: LIST
108949: LIST
108950: PUSH
108951: EMPTY
108952: LIST
108953: LIST
108954: PPUSH
108955: CALL_OW 446
// end ;
108959: LD_VAR 0 2
108963: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108964: LD_INT 0
108966: PPUSH
108967: PPUSH
// if not driver or not IsInUnit ( driver ) then
108968: LD_VAR 0 1
108972: NOT
108973: PUSH
108974: LD_VAR 0 1
108978: PPUSH
108979: CALL_OW 310
108983: NOT
108984: OR
108985: IFFALSE 108989
// exit ;
108987: GO 109079
// vehicle := IsInUnit ( driver ) ;
108989: LD_ADDR_VAR 0 3
108993: PUSH
108994: LD_VAR 0 1
108998: PPUSH
108999: CALL_OW 310
109003: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109004: LD_VAR 0 1
109008: PPUSH
109009: LD_STRING \
109011: PUSH
109012: LD_INT 0
109014: PUSH
109015: LD_INT 0
109017: PUSH
109018: LD_INT 0
109020: PUSH
109021: LD_INT 0
109023: PUSH
109024: LD_INT 0
109026: PUSH
109027: LD_INT 0
109029: PUSH
109030: EMPTY
109031: LIST
109032: LIST
109033: LIST
109034: LIST
109035: LIST
109036: LIST
109037: LIST
109038: PUSH
109039: LD_STRING E
109041: PUSH
109042: LD_INT 0
109044: PUSH
109045: LD_INT 0
109047: PUSH
109048: LD_VAR 0 3
109052: PUSH
109053: LD_INT 0
109055: PUSH
109056: LD_INT 0
109058: PUSH
109059: LD_INT 0
109061: PUSH
109062: EMPTY
109063: LIST
109064: LIST
109065: LIST
109066: LIST
109067: LIST
109068: LIST
109069: LIST
109070: PUSH
109071: EMPTY
109072: LIST
109073: LIST
109074: PPUSH
109075: CALL_OW 447
// end ;
109079: LD_VAR 0 2
109083: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109084: LD_INT 0
109086: PPUSH
109087: PPUSH
109088: PPUSH
// tmp := [ ] ;
109089: LD_ADDR_VAR 0 5
109093: PUSH
109094: EMPTY
109095: ST_TO_ADDR
// for i in units do
109096: LD_ADDR_VAR 0 4
109100: PUSH
109101: LD_VAR 0 1
109105: PUSH
109106: FOR_IN
109107: IFFALSE 109145
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109109: LD_ADDR_VAR 0 5
109113: PUSH
109114: LD_VAR 0 5
109118: PPUSH
109119: LD_VAR 0 5
109123: PUSH
109124: LD_INT 1
109126: PLUS
109127: PPUSH
109128: LD_VAR 0 4
109132: PPUSH
109133: CALL_OW 256
109137: PPUSH
109138: CALL_OW 2
109142: ST_TO_ADDR
109143: GO 109106
109145: POP
109146: POP
// if not tmp then
109147: LD_VAR 0 5
109151: NOT
109152: IFFALSE 109156
// exit ;
109154: GO 109204
// if asc then
109156: LD_VAR 0 2
109160: IFFALSE 109184
// result := SortListByListAsc ( units , tmp ) else
109162: LD_ADDR_VAR 0 3
109166: PUSH
109167: LD_VAR 0 1
109171: PPUSH
109172: LD_VAR 0 5
109176: PPUSH
109177: CALL_OW 76
109181: ST_TO_ADDR
109182: GO 109204
// result := SortListByListDesc ( units , tmp ) ;
109184: LD_ADDR_VAR 0 3
109188: PUSH
109189: LD_VAR 0 1
109193: PPUSH
109194: LD_VAR 0 5
109198: PPUSH
109199: CALL_OW 77
109203: ST_TO_ADDR
// end ;
109204: LD_VAR 0 3
109208: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109209: LD_INT 0
109211: PPUSH
109212: PPUSH
// task := GetTaskList ( mech ) ;
109213: LD_ADDR_VAR 0 4
109217: PUSH
109218: LD_VAR 0 1
109222: PPUSH
109223: CALL_OW 437
109227: ST_TO_ADDR
// if not task then
109228: LD_VAR 0 4
109232: NOT
109233: IFFALSE 109237
// exit ;
109235: GO 109279
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109237: LD_ADDR_VAR 0 3
109241: PUSH
109242: LD_VAR 0 4
109246: PUSH
109247: LD_INT 1
109249: ARRAY
109250: PUSH
109251: LD_INT 1
109253: ARRAY
109254: PUSH
109255: LD_STRING r
109257: EQUAL
109258: PUSH
109259: LD_VAR 0 4
109263: PUSH
109264: LD_INT 1
109266: ARRAY
109267: PUSH
109268: LD_INT 4
109270: ARRAY
109271: PUSH
109272: LD_VAR 0 2
109276: EQUAL
109277: AND
109278: ST_TO_ADDR
// end ;
109279: LD_VAR 0 3
109283: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109284: LD_INT 0
109286: PPUSH
// SetDir ( unit , d ) ;
109287: LD_VAR 0 1
109291: PPUSH
109292: LD_VAR 0 4
109296: PPUSH
109297: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109301: LD_VAR 0 1
109305: PPUSH
109306: LD_VAR 0 2
109310: PPUSH
109311: LD_VAR 0 3
109315: PPUSH
109316: LD_VAR 0 5
109320: PPUSH
109321: CALL_OW 48
// end ;
109325: LD_VAR 0 6
109329: RET
// export function ToNaturalNumber ( number ) ; begin
109330: LD_INT 0
109332: PPUSH
// result := number div 1 ;
109333: LD_ADDR_VAR 0 2
109337: PUSH
109338: LD_VAR 0 1
109342: PUSH
109343: LD_INT 1
109345: DIV
109346: ST_TO_ADDR
// if number < 0 then
109347: LD_VAR 0 1
109351: PUSH
109352: LD_INT 0
109354: LESS
109355: IFFALSE 109365
// result := 0 ;
109357: LD_ADDR_VAR 0 2
109361: PUSH
109362: LD_INT 0
109364: ST_TO_ADDR
// end ;
109365: LD_VAR 0 2
109369: RET
// export function SortByClass ( units , class ) ; var un ; begin
109370: LD_INT 0
109372: PPUSH
109373: PPUSH
// if not units or not class then
109374: LD_VAR 0 1
109378: NOT
109379: PUSH
109380: LD_VAR 0 2
109384: NOT
109385: OR
109386: IFFALSE 109390
// exit ;
109388: GO 109485
// result := [ ] ;
109390: LD_ADDR_VAR 0 3
109394: PUSH
109395: EMPTY
109396: ST_TO_ADDR
// for un in units do
109397: LD_ADDR_VAR 0 4
109401: PUSH
109402: LD_VAR 0 1
109406: PUSH
109407: FOR_IN
109408: IFFALSE 109483
// if GetClass ( un ) = class then
109410: LD_VAR 0 4
109414: PPUSH
109415: CALL_OW 257
109419: PUSH
109420: LD_VAR 0 2
109424: EQUAL
109425: IFFALSE 109452
// result := Insert ( result , 1 , un ) else
109427: LD_ADDR_VAR 0 3
109431: PUSH
109432: LD_VAR 0 3
109436: PPUSH
109437: LD_INT 1
109439: PPUSH
109440: LD_VAR 0 4
109444: PPUSH
109445: CALL_OW 2
109449: ST_TO_ADDR
109450: GO 109481
// result := Replace ( result , result + 1 , un ) ;
109452: LD_ADDR_VAR 0 3
109456: PUSH
109457: LD_VAR 0 3
109461: PPUSH
109462: LD_VAR 0 3
109466: PUSH
109467: LD_INT 1
109469: PLUS
109470: PPUSH
109471: LD_VAR 0 4
109475: PPUSH
109476: CALL_OW 1
109480: ST_TO_ADDR
109481: GO 109407
109483: POP
109484: POP
// end ;
109485: LD_VAR 0 3
109489: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109490: LD_INT 0
109492: PPUSH
109493: PPUSH
109494: PPUSH
109495: PPUSH
109496: PPUSH
109497: PPUSH
109498: PPUSH
// result := [ ] ;
109499: LD_ADDR_VAR 0 4
109503: PUSH
109504: EMPTY
109505: ST_TO_ADDR
// if x - r < 0 then
109506: LD_VAR 0 1
109510: PUSH
109511: LD_VAR 0 3
109515: MINUS
109516: PUSH
109517: LD_INT 0
109519: LESS
109520: IFFALSE 109532
// min_x := 0 else
109522: LD_ADDR_VAR 0 8
109526: PUSH
109527: LD_INT 0
109529: ST_TO_ADDR
109530: GO 109548
// min_x := x - r ;
109532: LD_ADDR_VAR 0 8
109536: PUSH
109537: LD_VAR 0 1
109541: PUSH
109542: LD_VAR 0 3
109546: MINUS
109547: ST_TO_ADDR
// if y - r < 0 then
109548: LD_VAR 0 2
109552: PUSH
109553: LD_VAR 0 3
109557: MINUS
109558: PUSH
109559: LD_INT 0
109561: LESS
109562: IFFALSE 109574
// min_y := 0 else
109564: LD_ADDR_VAR 0 7
109568: PUSH
109569: LD_INT 0
109571: ST_TO_ADDR
109572: GO 109590
// min_y := y - r ;
109574: LD_ADDR_VAR 0 7
109578: PUSH
109579: LD_VAR 0 2
109583: PUSH
109584: LD_VAR 0 3
109588: MINUS
109589: ST_TO_ADDR
// max_x := x + r ;
109590: LD_ADDR_VAR 0 9
109594: PUSH
109595: LD_VAR 0 1
109599: PUSH
109600: LD_VAR 0 3
109604: PLUS
109605: ST_TO_ADDR
// max_y := y + r ;
109606: LD_ADDR_VAR 0 10
109610: PUSH
109611: LD_VAR 0 2
109615: PUSH
109616: LD_VAR 0 3
109620: PLUS
109621: ST_TO_ADDR
// for _x = min_x to max_x do
109622: LD_ADDR_VAR 0 5
109626: PUSH
109627: DOUBLE
109628: LD_VAR 0 8
109632: DEC
109633: ST_TO_ADDR
109634: LD_VAR 0 9
109638: PUSH
109639: FOR_TO
109640: IFFALSE 109741
// for _y = min_y to max_y do
109642: LD_ADDR_VAR 0 6
109646: PUSH
109647: DOUBLE
109648: LD_VAR 0 7
109652: DEC
109653: ST_TO_ADDR
109654: LD_VAR 0 10
109658: PUSH
109659: FOR_TO
109660: IFFALSE 109737
// begin if not ValidHex ( _x , _y ) then
109662: LD_VAR 0 5
109666: PPUSH
109667: LD_VAR 0 6
109671: PPUSH
109672: CALL_OW 488
109676: NOT
109677: IFFALSE 109681
// continue ;
109679: GO 109659
// if GetResourceTypeXY ( _x , _y ) then
109681: LD_VAR 0 5
109685: PPUSH
109686: LD_VAR 0 6
109690: PPUSH
109691: CALL_OW 283
109695: IFFALSE 109735
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109697: LD_ADDR_VAR 0 4
109701: PUSH
109702: LD_VAR 0 4
109706: PPUSH
109707: LD_VAR 0 4
109711: PUSH
109712: LD_INT 1
109714: PLUS
109715: PPUSH
109716: LD_VAR 0 5
109720: PUSH
109721: LD_VAR 0 6
109725: PUSH
109726: EMPTY
109727: LIST
109728: LIST
109729: PPUSH
109730: CALL_OW 1
109734: ST_TO_ADDR
// end ;
109735: GO 109659
109737: POP
109738: POP
109739: GO 109639
109741: POP
109742: POP
// end ;
109743: LD_VAR 0 4
109747: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109748: LD_INT 0
109750: PPUSH
109751: PPUSH
109752: PPUSH
109753: PPUSH
109754: PPUSH
109755: PPUSH
109756: PPUSH
109757: PPUSH
// if not units then
109758: LD_VAR 0 1
109762: NOT
109763: IFFALSE 109767
// exit ;
109765: GO 110291
// result := UnitFilter ( units , [ f_ok ] ) ;
109767: LD_ADDR_VAR 0 3
109771: PUSH
109772: LD_VAR 0 1
109776: PPUSH
109777: LD_INT 50
109779: PUSH
109780: EMPTY
109781: LIST
109782: PPUSH
109783: CALL_OW 72
109787: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
109788: LD_ADDR_VAR 0 8
109792: PUSH
109793: LD_VAR 0 1
109797: PUSH
109798: LD_INT 1
109800: ARRAY
109801: PPUSH
109802: CALL_OW 255
109806: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
109807: LD_ADDR_VAR 0 10
109811: PUSH
109812: LD_INT 29
109814: PUSH
109815: LD_INT 91
109817: PUSH
109818: LD_INT 49
109820: PUSH
109821: EMPTY
109822: LIST
109823: LIST
109824: LIST
109825: ST_TO_ADDR
// if not result then
109826: LD_VAR 0 3
109830: NOT
109831: IFFALSE 109835
// exit ;
109833: GO 110291
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
109835: LD_ADDR_VAR 0 5
109839: PUSH
109840: LD_INT 81
109842: PUSH
109843: LD_VAR 0 8
109847: PUSH
109848: EMPTY
109849: LIST
109850: LIST
109851: PPUSH
109852: CALL_OW 69
109856: ST_TO_ADDR
// for i in result do
109857: LD_ADDR_VAR 0 4
109861: PUSH
109862: LD_VAR 0 3
109866: PUSH
109867: FOR_IN
109868: IFFALSE 110289
// begin tag := GetTag ( i ) + 1 ;
109870: LD_ADDR_VAR 0 9
109874: PUSH
109875: LD_VAR 0 4
109879: PPUSH
109880: CALL_OW 110
109884: PUSH
109885: LD_INT 1
109887: PLUS
109888: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
109889: LD_ADDR_VAR 0 7
109893: PUSH
109894: LD_VAR 0 4
109898: PPUSH
109899: CALL_OW 250
109903: PPUSH
109904: LD_VAR 0 4
109908: PPUSH
109909: CALL_OW 251
109913: PPUSH
109914: LD_INT 6
109916: PPUSH
109917: CALL 109490 0 3
109921: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
109922: LD_VAR 0 4
109926: PPUSH
109927: CALL_OW 247
109931: PUSH
109932: LD_INT 2
109934: EQUAL
109935: PUSH
109936: LD_VAR 0 7
109940: AND
109941: PUSH
109942: LD_VAR 0 4
109946: PPUSH
109947: CALL_OW 264
109951: PUSH
109952: LD_VAR 0 10
109956: IN
109957: NOT
109958: AND
109959: IFFALSE 109998
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
109961: LD_VAR 0 4
109965: PPUSH
109966: LD_VAR 0 7
109970: PUSH
109971: LD_INT 1
109973: ARRAY
109974: PUSH
109975: LD_INT 1
109977: ARRAY
109978: PPUSH
109979: LD_VAR 0 7
109983: PUSH
109984: LD_INT 1
109986: ARRAY
109987: PUSH
109988: LD_INT 2
109990: ARRAY
109991: PPUSH
109992: CALL_OW 116
109996: GO 110287
// if path > tag then
109998: LD_VAR 0 2
110002: PUSH
110003: LD_VAR 0 9
110007: GREATER
110008: IFFALSE 110216
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110010: LD_ADDR_VAR 0 6
110014: PUSH
110015: LD_VAR 0 5
110019: PPUSH
110020: LD_INT 91
110022: PUSH
110023: LD_VAR 0 4
110027: PUSH
110028: LD_INT 8
110030: PUSH
110031: EMPTY
110032: LIST
110033: LIST
110034: LIST
110035: PPUSH
110036: CALL_OW 72
110040: ST_TO_ADDR
// if nearEnemy then
110041: LD_VAR 0 6
110045: IFFALSE 110114
// begin if GetWeapon ( i ) = ru_time_lapser then
110047: LD_VAR 0 4
110051: PPUSH
110052: CALL_OW 264
110056: PUSH
110057: LD_INT 49
110059: EQUAL
110060: IFFALSE 110088
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110062: LD_VAR 0 4
110066: PPUSH
110067: LD_VAR 0 6
110071: PPUSH
110072: LD_VAR 0 4
110076: PPUSH
110077: CALL_OW 74
110081: PPUSH
110082: CALL_OW 112
110086: GO 110112
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110088: LD_VAR 0 4
110092: PPUSH
110093: LD_VAR 0 6
110097: PPUSH
110098: LD_VAR 0 4
110102: PPUSH
110103: CALL_OW 74
110107: PPUSH
110108: CALL 111216 0 2
// end else
110112: GO 110214
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110114: LD_VAR 0 4
110118: PPUSH
110119: LD_VAR 0 2
110123: PUSH
110124: LD_VAR 0 9
110128: ARRAY
110129: PUSH
110130: LD_INT 1
110132: ARRAY
110133: PPUSH
110134: LD_VAR 0 2
110138: PUSH
110139: LD_VAR 0 9
110143: ARRAY
110144: PUSH
110145: LD_INT 2
110147: ARRAY
110148: PPUSH
110149: CALL_OW 297
110153: PUSH
110154: LD_INT 6
110156: GREATER
110157: IFFALSE 110200
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110159: LD_VAR 0 4
110163: PPUSH
110164: LD_VAR 0 2
110168: PUSH
110169: LD_VAR 0 9
110173: ARRAY
110174: PUSH
110175: LD_INT 1
110177: ARRAY
110178: PPUSH
110179: LD_VAR 0 2
110183: PUSH
110184: LD_VAR 0 9
110188: ARRAY
110189: PUSH
110190: LD_INT 2
110192: ARRAY
110193: PPUSH
110194: CALL_OW 114
110198: GO 110214
// SetTag ( i , tag ) ;
110200: LD_VAR 0 4
110204: PPUSH
110205: LD_VAR 0 9
110209: PPUSH
110210: CALL_OW 109
// end else
110214: GO 110287
// if enemy then
110216: LD_VAR 0 5
110220: IFFALSE 110287
// begin if GetWeapon ( i ) = ru_time_lapser then
110222: LD_VAR 0 4
110226: PPUSH
110227: CALL_OW 264
110231: PUSH
110232: LD_INT 49
110234: EQUAL
110235: IFFALSE 110263
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110237: LD_VAR 0 4
110241: PPUSH
110242: LD_VAR 0 5
110246: PPUSH
110247: LD_VAR 0 4
110251: PPUSH
110252: CALL_OW 74
110256: PPUSH
110257: CALL_OW 112
110261: GO 110287
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110263: LD_VAR 0 4
110267: PPUSH
110268: LD_VAR 0 5
110272: PPUSH
110273: LD_VAR 0 4
110277: PPUSH
110278: CALL_OW 74
110282: PPUSH
110283: CALL 111216 0 2
// end ; end ;
110287: GO 109867
110289: POP
110290: POP
// end ;
110291: LD_VAR 0 3
110295: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110296: LD_INT 0
110298: PPUSH
110299: PPUSH
110300: PPUSH
// if not unit or IsInUnit ( unit ) then
110301: LD_VAR 0 1
110305: NOT
110306: PUSH
110307: LD_VAR 0 1
110311: PPUSH
110312: CALL_OW 310
110316: OR
110317: IFFALSE 110321
// exit ;
110319: GO 110412
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110321: LD_ADDR_VAR 0 4
110325: PUSH
110326: LD_VAR 0 1
110330: PPUSH
110331: CALL_OW 250
110335: PPUSH
110336: LD_VAR 0 2
110340: PPUSH
110341: LD_INT 1
110343: PPUSH
110344: CALL_OW 272
110348: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110349: LD_ADDR_VAR 0 5
110353: PUSH
110354: LD_VAR 0 1
110358: PPUSH
110359: CALL_OW 251
110363: PPUSH
110364: LD_VAR 0 2
110368: PPUSH
110369: LD_INT 1
110371: PPUSH
110372: CALL_OW 273
110376: ST_TO_ADDR
// if ValidHex ( x , y ) then
110377: LD_VAR 0 4
110381: PPUSH
110382: LD_VAR 0 5
110386: PPUSH
110387: CALL_OW 488
110391: IFFALSE 110412
// ComTurnXY ( unit , x , y ) ;
110393: LD_VAR 0 1
110397: PPUSH
110398: LD_VAR 0 4
110402: PPUSH
110403: LD_VAR 0 5
110407: PPUSH
110408: CALL_OW 118
// end ;
110412: LD_VAR 0 3
110416: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110417: LD_INT 0
110419: PPUSH
110420: PPUSH
// result := false ;
110421: LD_ADDR_VAR 0 3
110425: PUSH
110426: LD_INT 0
110428: ST_TO_ADDR
// if not units then
110429: LD_VAR 0 2
110433: NOT
110434: IFFALSE 110438
// exit ;
110436: GO 110483
// for i in units do
110438: LD_ADDR_VAR 0 4
110442: PUSH
110443: LD_VAR 0 2
110447: PUSH
110448: FOR_IN
110449: IFFALSE 110481
// if See ( side , i ) then
110451: LD_VAR 0 1
110455: PPUSH
110456: LD_VAR 0 4
110460: PPUSH
110461: CALL_OW 292
110465: IFFALSE 110479
// begin result := true ;
110467: LD_ADDR_VAR 0 3
110471: PUSH
110472: LD_INT 1
110474: ST_TO_ADDR
// exit ;
110475: POP
110476: POP
110477: GO 110483
// end ;
110479: GO 110448
110481: POP
110482: POP
// end ;
110483: LD_VAR 0 3
110487: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110488: LD_INT 0
110490: PPUSH
110491: PPUSH
110492: PPUSH
110493: PPUSH
// if not unit or not points then
110494: LD_VAR 0 1
110498: NOT
110499: PUSH
110500: LD_VAR 0 2
110504: NOT
110505: OR
110506: IFFALSE 110510
// exit ;
110508: GO 110600
// dist := 99999 ;
110510: LD_ADDR_VAR 0 5
110514: PUSH
110515: LD_INT 99999
110517: ST_TO_ADDR
// for i in points do
110518: LD_ADDR_VAR 0 4
110522: PUSH
110523: LD_VAR 0 2
110527: PUSH
110528: FOR_IN
110529: IFFALSE 110598
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110531: LD_ADDR_VAR 0 6
110535: PUSH
110536: LD_VAR 0 1
110540: PPUSH
110541: LD_VAR 0 4
110545: PUSH
110546: LD_INT 1
110548: ARRAY
110549: PPUSH
110550: LD_VAR 0 4
110554: PUSH
110555: LD_INT 2
110557: ARRAY
110558: PPUSH
110559: CALL_OW 297
110563: ST_TO_ADDR
// if tmpDist < dist then
110564: LD_VAR 0 6
110568: PUSH
110569: LD_VAR 0 5
110573: LESS
110574: IFFALSE 110596
// begin result := i ;
110576: LD_ADDR_VAR 0 3
110580: PUSH
110581: LD_VAR 0 4
110585: ST_TO_ADDR
// dist := tmpDist ;
110586: LD_ADDR_VAR 0 5
110590: PUSH
110591: LD_VAR 0 6
110595: ST_TO_ADDR
// end ; end ;
110596: GO 110528
110598: POP
110599: POP
// end ;
110600: LD_VAR 0 3
110604: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110605: LD_INT 0
110607: PPUSH
// uc_side := side ;
110608: LD_ADDR_OWVAR 20
110612: PUSH
110613: LD_VAR 0 1
110617: ST_TO_ADDR
// uc_nation := 3 ;
110618: LD_ADDR_OWVAR 21
110622: PUSH
110623: LD_INT 3
110625: ST_TO_ADDR
// vc_chassis := 25 ;
110626: LD_ADDR_OWVAR 37
110630: PUSH
110631: LD_INT 25
110633: ST_TO_ADDR
// vc_engine := engine_siberite ;
110634: LD_ADDR_OWVAR 39
110638: PUSH
110639: LD_INT 3
110641: ST_TO_ADDR
// vc_control := control_computer ;
110642: LD_ADDR_OWVAR 38
110646: PUSH
110647: LD_INT 3
110649: ST_TO_ADDR
// vc_weapon := 59 ;
110650: LD_ADDR_OWVAR 40
110654: PUSH
110655: LD_INT 59
110657: ST_TO_ADDR
// result := CreateVehicle ;
110658: LD_ADDR_VAR 0 5
110662: PUSH
110663: CALL_OW 45
110667: ST_TO_ADDR
// SetDir ( result , d ) ;
110668: LD_VAR 0 5
110672: PPUSH
110673: LD_VAR 0 4
110677: PPUSH
110678: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110682: LD_VAR 0 5
110686: PPUSH
110687: LD_VAR 0 2
110691: PPUSH
110692: LD_VAR 0 3
110696: PPUSH
110697: LD_INT 0
110699: PPUSH
110700: CALL_OW 48
// end ;
110704: LD_VAR 0 5
110708: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110709: LD_INT 0
110711: PPUSH
110712: PPUSH
110713: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110714: LD_ADDR_VAR 0 2
110718: PUSH
110719: LD_INT 0
110721: PUSH
110722: LD_INT 0
110724: PUSH
110725: LD_INT 0
110727: PUSH
110728: LD_INT 0
110730: PUSH
110731: EMPTY
110732: LIST
110733: LIST
110734: LIST
110735: LIST
110736: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110737: LD_VAR 0 1
110741: NOT
110742: PUSH
110743: LD_VAR 0 1
110747: PPUSH
110748: CALL_OW 264
110752: PUSH
110753: LD_INT 12
110755: PUSH
110756: LD_INT 51
110758: PUSH
110759: LD_INT 32
110761: PUSH
110762: LD_INT 89
110764: PUSH
110765: EMPTY
110766: LIST
110767: LIST
110768: LIST
110769: LIST
110770: IN
110771: NOT
110772: OR
110773: IFFALSE 110777
// exit ;
110775: GO 110875
// for i := 1 to 3 do
110777: LD_ADDR_VAR 0 3
110781: PUSH
110782: DOUBLE
110783: LD_INT 1
110785: DEC
110786: ST_TO_ADDR
110787: LD_INT 3
110789: PUSH
110790: FOR_TO
110791: IFFALSE 110873
// begin tmp := GetCargo ( cargo , i ) ;
110793: LD_ADDR_VAR 0 4
110797: PUSH
110798: LD_VAR 0 1
110802: PPUSH
110803: LD_VAR 0 3
110807: PPUSH
110808: CALL_OW 289
110812: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
110813: LD_ADDR_VAR 0 2
110817: PUSH
110818: LD_VAR 0 2
110822: PPUSH
110823: LD_VAR 0 3
110827: PPUSH
110828: LD_VAR 0 4
110832: PPUSH
110833: CALL_OW 1
110837: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
110838: LD_ADDR_VAR 0 2
110842: PUSH
110843: LD_VAR 0 2
110847: PPUSH
110848: LD_INT 4
110850: PPUSH
110851: LD_VAR 0 2
110855: PUSH
110856: LD_INT 4
110858: ARRAY
110859: PUSH
110860: LD_VAR 0 4
110864: PLUS
110865: PPUSH
110866: CALL_OW 1
110870: ST_TO_ADDR
// end ;
110871: GO 110790
110873: POP
110874: POP
// end ;
110875: LD_VAR 0 2
110879: RET
// export function Length ( array ) ; begin
110880: LD_INT 0
110882: PPUSH
// result := array + 0 ;
110883: LD_ADDR_VAR 0 2
110887: PUSH
110888: LD_VAR 0 1
110892: PUSH
110893: LD_INT 0
110895: PLUS
110896: ST_TO_ADDR
// end ;
110897: LD_VAR 0 2
110901: RET
// export function PrepareArray ( array ) ; begin
110902: LD_INT 0
110904: PPUSH
// result := array diff 0 ;
110905: LD_ADDR_VAR 0 2
110909: PUSH
110910: LD_VAR 0 1
110914: PUSH
110915: LD_INT 0
110917: DIFF
110918: ST_TO_ADDR
// if not result [ 1 ] then
110919: LD_VAR 0 2
110923: PUSH
110924: LD_INT 1
110926: ARRAY
110927: NOT
110928: IFFALSE 110948
// result := Delete ( result , 1 ) ;
110930: LD_ADDR_VAR 0 2
110934: PUSH
110935: LD_VAR 0 2
110939: PPUSH
110940: LD_INT 1
110942: PPUSH
110943: CALL_OW 3
110947: ST_TO_ADDR
// end ;
110948: LD_VAR 0 2
110952: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
110953: LD_INT 0
110955: PPUSH
110956: PPUSH
110957: PPUSH
110958: PPUSH
// sibRocketRange := 25 ;
110959: LD_ADDR_VAR 0 6
110963: PUSH
110964: LD_INT 25
110966: ST_TO_ADDR
// result := false ;
110967: LD_ADDR_VAR 0 4
110971: PUSH
110972: LD_INT 0
110974: ST_TO_ADDR
// for i := 0 to 5 do
110975: LD_ADDR_VAR 0 5
110979: PUSH
110980: DOUBLE
110981: LD_INT 0
110983: DEC
110984: ST_TO_ADDR
110985: LD_INT 5
110987: PUSH
110988: FOR_TO
110989: IFFALSE 111056
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
110991: LD_VAR 0 1
110995: PPUSH
110996: LD_VAR 0 5
111000: PPUSH
111001: LD_VAR 0 6
111005: PPUSH
111006: CALL_OW 272
111010: PPUSH
111011: LD_VAR 0 2
111015: PPUSH
111016: LD_VAR 0 5
111020: PPUSH
111021: LD_VAR 0 6
111025: PPUSH
111026: CALL_OW 273
111030: PPUSH
111031: LD_VAR 0 3
111035: PPUSH
111036: CALL_OW 309
111040: IFFALSE 111054
// begin result := true ;
111042: LD_ADDR_VAR 0 4
111046: PUSH
111047: LD_INT 1
111049: ST_TO_ADDR
// exit ;
111050: POP
111051: POP
111052: GO 111058
// end ;
111054: GO 110988
111056: POP
111057: POP
// end ;
111058: LD_VAR 0 4
111062: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111063: LD_INT 0
111065: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111066: LD_VAR 0 1
111070: PPUSH
111071: LD_VAR 0 2
111075: PPUSH
111076: LD_INT 0
111078: PPUSH
111079: LD_INT 0
111081: PPUSH
111082: LD_INT 1
111084: PPUSH
111085: LD_INT 0
111087: PPUSH
111088: CALL_OW 587
// end ;
111092: LD_VAR 0 3
111096: RET
// export function CenterOnNow ( unit ) ; begin
111097: LD_INT 0
111099: PPUSH
// result := IsInUnit ( unit ) ;
111100: LD_ADDR_VAR 0 2
111104: PUSH
111105: LD_VAR 0 1
111109: PPUSH
111110: CALL_OW 310
111114: ST_TO_ADDR
// if not result then
111115: LD_VAR 0 2
111119: NOT
111120: IFFALSE 111132
// result := unit ;
111122: LD_ADDR_VAR 0 2
111126: PUSH
111127: LD_VAR 0 1
111131: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111132: LD_VAR 0 1
111136: PPUSH
111137: CALL_OW 87
// end ;
111141: LD_VAR 0 2
111145: RET
// export function ComMoveHex ( unit , hex ) ; begin
111146: LD_INT 0
111148: PPUSH
// if not hex then
111149: LD_VAR 0 2
111153: NOT
111154: IFFALSE 111158
// exit ;
111156: GO 111211
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111158: LD_VAR 0 2
111162: PUSH
111163: LD_INT 1
111165: ARRAY
111166: PPUSH
111167: LD_VAR 0 2
111171: PUSH
111172: LD_INT 2
111174: ARRAY
111175: PPUSH
111176: CALL_OW 428
111180: IFFALSE 111184
// exit ;
111182: GO 111211
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111184: LD_VAR 0 1
111188: PPUSH
111189: LD_VAR 0 2
111193: PUSH
111194: LD_INT 1
111196: ARRAY
111197: PPUSH
111198: LD_VAR 0 2
111202: PUSH
111203: LD_INT 2
111205: ARRAY
111206: PPUSH
111207: CALL_OW 111
// end ;
111211: LD_VAR 0 3
111215: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111216: LD_INT 0
111218: PPUSH
111219: PPUSH
111220: PPUSH
// if not unit or not enemy then
111221: LD_VAR 0 1
111225: NOT
111226: PUSH
111227: LD_VAR 0 2
111231: NOT
111232: OR
111233: IFFALSE 111237
// exit ;
111235: GO 111361
// x := GetX ( enemy ) ;
111237: LD_ADDR_VAR 0 4
111241: PUSH
111242: LD_VAR 0 2
111246: PPUSH
111247: CALL_OW 250
111251: ST_TO_ADDR
// y := GetY ( enemy ) ;
111252: LD_ADDR_VAR 0 5
111256: PUSH
111257: LD_VAR 0 2
111261: PPUSH
111262: CALL_OW 251
111266: ST_TO_ADDR
// if ValidHex ( x , y ) then
111267: LD_VAR 0 4
111271: PPUSH
111272: LD_VAR 0 5
111276: PPUSH
111277: CALL_OW 488
111281: IFFALSE 111361
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
111283: LD_VAR 0 2
111287: PPUSH
111288: CALL_OW 247
111292: PUSH
111293: LD_INT 3
111295: PUSH
111296: LD_INT 2
111298: PUSH
111299: EMPTY
111300: LIST
111301: LIST
111302: IN
111303: PUSH
111304: LD_VAR 0 1
111308: PPUSH
111309: CALL_OW 255
111313: PPUSH
111314: LD_VAR 0 2
111318: PPUSH
111319: CALL_OW 292
111323: AND
111324: IFFALSE 111342
// ComAttackUnit ( unit , enemy ) else
111326: LD_VAR 0 1
111330: PPUSH
111331: LD_VAR 0 2
111335: PPUSH
111336: CALL_OW 115
111340: GO 111361
// ComAgressiveMove ( unit , x , y ) ;
111342: LD_VAR 0 1
111346: PPUSH
111347: LD_VAR 0 4
111351: PPUSH
111352: LD_VAR 0 5
111356: PPUSH
111357: CALL_OW 114
// end ;
111361: LD_VAR 0 3
111365: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111366: LD_INT 0
111368: PPUSH
111369: PPUSH
111370: PPUSH
// list := AreaToList ( area , 0 ) ;
111371: LD_ADDR_VAR 0 5
111375: PUSH
111376: LD_VAR 0 1
111380: PPUSH
111381: LD_INT 0
111383: PPUSH
111384: CALL_OW 517
111388: ST_TO_ADDR
// if not list then
111389: LD_VAR 0 5
111393: NOT
111394: IFFALSE 111398
// exit ;
111396: GO 111528
// if all then
111398: LD_VAR 0 2
111402: IFFALSE 111490
// begin for i := 1 to list [ 1 ] do
111404: LD_ADDR_VAR 0 4
111408: PUSH
111409: DOUBLE
111410: LD_INT 1
111412: DEC
111413: ST_TO_ADDR
111414: LD_VAR 0 5
111418: PUSH
111419: LD_INT 1
111421: ARRAY
111422: PUSH
111423: FOR_TO
111424: IFFALSE 111486
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111426: LD_ADDR_VAR 0 3
111430: PUSH
111431: LD_VAR 0 3
111435: PPUSH
111436: LD_VAR 0 3
111440: PUSH
111441: LD_INT 1
111443: PLUS
111444: PPUSH
111445: LD_VAR 0 5
111449: PUSH
111450: LD_INT 1
111452: ARRAY
111453: PUSH
111454: LD_VAR 0 4
111458: ARRAY
111459: PUSH
111460: LD_VAR 0 5
111464: PUSH
111465: LD_INT 2
111467: ARRAY
111468: PUSH
111469: LD_VAR 0 4
111473: ARRAY
111474: PUSH
111475: EMPTY
111476: LIST
111477: LIST
111478: PPUSH
111479: CALL_OW 1
111483: ST_TO_ADDR
111484: GO 111423
111486: POP
111487: POP
// exit ;
111488: GO 111528
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111490: LD_ADDR_VAR 0 3
111494: PUSH
111495: LD_VAR 0 5
111499: PUSH
111500: LD_INT 1
111502: ARRAY
111503: PUSH
111504: LD_INT 1
111506: ARRAY
111507: PUSH
111508: LD_VAR 0 5
111512: PUSH
111513: LD_INT 2
111515: ARRAY
111516: PUSH
111517: LD_INT 1
111519: ARRAY
111520: PUSH
111521: EMPTY
111522: LIST
111523: LIST
111524: PUSH
111525: EMPTY
111526: LIST
111527: ST_TO_ADDR
// end ;
111528: LD_VAR 0 3
111532: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111533: LD_INT 0
111535: PPUSH
111536: PPUSH
// list := AreaToList ( area , 0 ) ;
111537: LD_ADDR_VAR 0 4
111541: PUSH
111542: LD_VAR 0 1
111546: PPUSH
111547: LD_INT 0
111549: PPUSH
111550: CALL_OW 517
111554: ST_TO_ADDR
// if not list then
111555: LD_VAR 0 4
111559: NOT
111560: IFFALSE 111564
// exit ;
111562: GO 111605
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111564: LD_ADDR_VAR 0 3
111568: PUSH
111569: LD_VAR 0 4
111573: PUSH
111574: LD_INT 1
111576: ARRAY
111577: PUSH
111578: LD_INT 1
111580: ARRAY
111581: PUSH
111582: LD_VAR 0 4
111586: PUSH
111587: LD_INT 2
111589: ARRAY
111590: PUSH
111591: LD_INT 1
111593: ARRAY
111594: PUSH
111595: LD_VAR 0 2
111599: PUSH
111600: EMPTY
111601: LIST
111602: LIST
111603: LIST
111604: ST_TO_ADDR
// end ;
111605: LD_VAR 0 3
111609: RET
// export function First ( array ) ; begin
111610: LD_INT 0
111612: PPUSH
// if not array then
111613: LD_VAR 0 1
111617: NOT
111618: IFFALSE 111622
// exit ;
111620: GO 111636
// result := array [ 1 ] ;
111622: LD_ADDR_VAR 0 2
111626: PUSH
111627: LD_VAR 0 1
111631: PUSH
111632: LD_INT 1
111634: ARRAY
111635: ST_TO_ADDR
// end ;
111636: LD_VAR 0 2
111640: RET
// export function Last ( array ) ; begin
111641: LD_INT 0
111643: PPUSH
// if not array then
111644: LD_VAR 0 1
111648: NOT
111649: IFFALSE 111653
// exit ;
111651: GO 111669
// result := array [ array ] ;
111653: LD_ADDR_VAR 0 2
111657: PUSH
111658: LD_VAR 0 1
111662: PUSH
111663: LD_VAR 0 1
111667: ARRAY
111668: ST_TO_ADDR
// end ; end_of_file end_of_file
111669: LD_VAR 0 2
111673: RET
// export globalGameSaveCounter ; every 0 0$1 do
111674: GO 111676
111676: DISABLE
// begin enable ;
111677: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
111678: LD_STRING updateTimer(
111680: PUSH
111681: LD_OWVAR 1
111685: STR
111686: PUSH
111687: LD_STRING );
111689: STR
111690: PPUSH
111691: CALL_OW 559
// end ;
111695: END
// every 0 0$1 do
111696: GO 111698
111698: DISABLE
// begin globalGameSaveCounter := 0 ;
111699: LD_ADDR_EXP 146
111703: PUSH
111704: LD_INT 0
111706: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
111707: LD_STRING setGameSaveCounter(0)
111709: PPUSH
111710: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
111714: LD_STRING initStreamRollete();
111716: PPUSH
111717: CALL_OW 559
// InitStreamMode ;
111721: CALL 113047 0 0
// DefineStreamItems ( false ) ;
111725: LD_INT 0
111727: PPUSH
111728: CALL 113511 0 1
// end ;
111732: END
// export function SOS_MapStart ( ) ; begin
111733: LD_INT 0
111735: PPUSH
// if streamModeActive then
111736: LD_EXP 147
111740: IFFALSE 111749
// DefineStreamItems ( true ) ;
111742: LD_INT 1
111744: PPUSH
111745: CALL 113511 0 1
// UpdateLuaVariables ( ) ;
111749: CALL 111766 0 0
// UpdateFactoryWaypoints ( ) ;
111753: CALL 126380 0 0
// UpdateWarehouseGatheringPoints ( ) ;
111757: CALL 126637 0 0
// end ;
111761: LD_VAR 0 1
111765: RET
// function UpdateLuaVariables ( ) ; begin
111766: LD_INT 0
111768: PPUSH
// if globalGameSaveCounter then
111769: LD_EXP 146
111773: IFFALSE 111807
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
111775: LD_ADDR_EXP 146
111779: PUSH
111780: LD_EXP 146
111784: PPUSH
111785: CALL 108505 0 1
111789: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
111790: LD_STRING setGameSaveCounter(
111792: PUSH
111793: LD_EXP 146
111797: STR
111798: PUSH
111799: LD_STRING )
111801: STR
111802: PPUSH
111803: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
111807: LD_STRING setGameDifficulty(
111809: PUSH
111810: LD_OWVAR 67
111814: STR
111815: PUSH
111816: LD_STRING )
111818: STR
111819: PPUSH
111820: CALL_OW 559
// end ;
111824: LD_VAR 0 1
111828: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
111829: LD_INT 0
111831: PPUSH
// if p2 = stream_mode then
111832: LD_VAR 0 2
111836: PUSH
111837: LD_INT 100
111839: EQUAL
111840: IFFALSE 112843
// begin if not StreamModeActive then
111842: LD_EXP 147
111846: NOT
111847: IFFALSE 111857
// StreamModeActive := true ;
111849: LD_ADDR_EXP 147
111853: PUSH
111854: LD_INT 1
111856: ST_TO_ADDR
// if p3 = 0 then
111857: LD_VAR 0 3
111861: PUSH
111862: LD_INT 0
111864: EQUAL
111865: IFFALSE 111871
// InitStreamMode ;
111867: CALL 113047 0 0
// if p3 = 1 then
111871: LD_VAR 0 3
111875: PUSH
111876: LD_INT 1
111878: EQUAL
111879: IFFALSE 111889
// sRocket := true ;
111881: LD_ADDR_EXP 152
111885: PUSH
111886: LD_INT 1
111888: ST_TO_ADDR
// if p3 = 2 then
111889: LD_VAR 0 3
111893: PUSH
111894: LD_INT 2
111896: EQUAL
111897: IFFALSE 111907
// sSpeed := true ;
111899: LD_ADDR_EXP 151
111903: PUSH
111904: LD_INT 1
111906: ST_TO_ADDR
// if p3 = 3 then
111907: LD_VAR 0 3
111911: PUSH
111912: LD_INT 3
111914: EQUAL
111915: IFFALSE 111925
// sEngine := true ;
111917: LD_ADDR_EXP 153
111921: PUSH
111922: LD_INT 1
111924: ST_TO_ADDR
// if p3 = 4 then
111925: LD_VAR 0 3
111929: PUSH
111930: LD_INT 4
111932: EQUAL
111933: IFFALSE 111943
// sSpec := true ;
111935: LD_ADDR_EXP 150
111939: PUSH
111940: LD_INT 1
111942: ST_TO_ADDR
// if p3 = 5 then
111943: LD_VAR 0 3
111947: PUSH
111948: LD_INT 5
111950: EQUAL
111951: IFFALSE 111961
// sLevel := true ;
111953: LD_ADDR_EXP 154
111957: PUSH
111958: LD_INT 1
111960: ST_TO_ADDR
// if p3 = 6 then
111961: LD_VAR 0 3
111965: PUSH
111966: LD_INT 6
111968: EQUAL
111969: IFFALSE 111979
// sArmoury := true ;
111971: LD_ADDR_EXP 155
111975: PUSH
111976: LD_INT 1
111978: ST_TO_ADDR
// if p3 = 7 then
111979: LD_VAR 0 3
111983: PUSH
111984: LD_INT 7
111986: EQUAL
111987: IFFALSE 111997
// sRadar := true ;
111989: LD_ADDR_EXP 156
111993: PUSH
111994: LD_INT 1
111996: ST_TO_ADDR
// if p3 = 8 then
111997: LD_VAR 0 3
112001: PUSH
112002: LD_INT 8
112004: EQUAL
112005: IFFALSE 112015
// sBunker := true ;
112007: LD_ADDR_EXP 157
112011: PUSH
112012: LD_INT 1
112014: ST_TO_ADDR
// if p3 = 9 then
112015: LD_VAR 0 3
112019: PUSH
112020: LD_INT 9
112022: EQUAL
112023: IFFALSE 112033
// sHack := true ;
112025: LD_ADDR_EXP 158
112029: PUSH
112030: LD_INT 1
112032: ST_TO_ADDR
// if p3 = 10 then
112033: LD_VAR 0 3
112037: PUSH
112038: LD_INT 10
112040: EQUAL
112041: IFFALSE 112051
// sFire := true ;
112043: LD_ADDR_EXP 159
112047: PUSH
112048: LD_INT 1
112050: ST_TO_ADDR
// if p3 = 11 then
112051: LD_VAR 0 3
112055: PUSH
112056: LD_INT 11
112058: EQUAL
112059: IFFALSE 112069
// sRefresh := true ;
112061: LD_ADDR_EXP 160
112065: PUSH
112066: LD_INT 1
112068: ST_TO_ADDR
// if p3 = 12 then
112069: LD_VAR 0 3
112073: PUSH
112074: LD_INT 12
112076: EQUAL
112077: IFFALSE 112087
// sExp := true ;
112079: LD_ADDR_EXP 161
112083: PUSH
112084: LD_INT 1
112086: ST_TO_ADDR
// if p3 = 13 then
112087: LD_VAR 0 3
112091: PUSH
112092: LD_INT 13
112094: EQUAL
112095: IFFALSE 112105
// sDepot := true ;
112097: LD_ADDR_EXP 162
112101: PUSH
112102: LD_INT 1
112104: ST_TO_ADDR
// if p3 = 14 then
112105: LD_VAR 0 3
112109: PUSH
112110: LD_INT 14
112112: EQUAL
112113: IFFALSE 112123
// sFlag := true ;
112115: LD_ADDR_EXP 163
112119: PUSH
112120: LD_INT 1
112122: ST_TO_ADDR
// if p3 = 15 then
112123: LD_VAR 0 3
112127: PUSH
112128: LD_INT 15
112130: EQUAL
112131: IFFALSE 112141
// sKamikadze := true ;
112133: LD_ADDR_EXP 171
112137: PUSH
112138: LD_INT 1
112140: ST_TO_ADDR
// if p3 = 16 then
112141: LD_VAR 0 3
112145: PUSH
112146: LD_INT 16
112148: EQUAL
112149: IFFALSE 112159
// sTroll := true ;
112151: LD_ADDR_EXP 172
112155: PUSH
112156: LD_INT 1
112158: ST_TO_ADDR
// if p3 = 17 then
112159: LD_VAR 0 3
112163: PUSH
112164: LD_INT 17
112166: EQUAL
112167: IFFALSE 112177
// sSlow := true ;
112169: LD_ADDR_EXP 173
112173: PUSH
112174: LD_INT 1
112176: ST_TO_ADDR
// if p3 = 18 then
112177: LD_VAR 0 3
112181: PUSH
112182: LD_INT 18
112184: EQUAL
112185: IFFALSE 112195
// sLack := true ;
112187: LD_ADDR_EXP 174
112191: PUSH
112192: LD_INT 1
112194: ST_TO_ADDR
// if p3 = 19 then
112195: LD_VAR 0 3
112199: PUSH
112200: LD_INT 19
112202: EQUAL
112203: IFFALSE 112213
// sTank := true ;
112205: LD_ADDR_EXP 176
112209: PUSH
112210: LD_INT 1
112212: ST_TO_ADDR
// if p3 = 20 then
112213: LD_VAR 0 3
112217: PUSH
112218: LD_INT 20
112220: EQUAL
112221: IFFALSE 112231
// sRemote := true ;
112223: LD_ADDR_EXP 177
112227: PUSH
112228: LD_INT 1
112230: ST_TO_ADDR
// if p3 = 21 then
112231: LD_VAR 0 3
112235: PUSH
112236: LD_INT 21
112238: EQUAL
112239: IFFALSE 112249
// sPowell := true ;
112241: LD_ADDR_EXP 178
112245: PUSH
112246: LD_INT 1
112248: ST_TO_ADDR
// if p3 = 22 then
112249: LD_VAR 0 3
112253: PUSH
112254: LD_INT 22
112256: EQUAL
112257: IFFALSE 112267
// sTeleport := true ;
112259: LD_ADDR_EXP 181
112263: PUSH
112264: LD_INT 1
112266: ST_TO_ADDR
// if p3 = 23 then
112267: LD_VAR 0 3
112271: PUSH
112272: LD_INT 23
112274: EQUAL
112275: IFFALSE 112285
// sOilTower := true ;
112277: LD_ADDR_EXP 183
112281: PUSH
112282: LD_INT 1
112284: ST_TO_ADDR
// if p3 = 24 then
112285: LD_VAR 0 3
112289: PUSH
112290: LD_INT 24
112292: EQUAL
112293: IFFALSE 112303
// sShovel := true ;
112295: LD_ADDR_EXP 184
112299: PUSH
112300: LD_INT 1
112302: ST_TO_ADDR
// if p3 = 25 then
112303: LD_VAR 0 3
112307: PUSH
112308: LD_INT 25
112310: EQUAL
112311: IFFALSE 112321
// sSheik := true ;
112313: LD_ADDR_EXP 185
112317: PUSH
112318: LD_INT 1
112320: ST_TO_ADDR
// if p3 = 26 then
112321: LD_VAR 0 3
112325: PUSH
112326: LD_INT 26
112328: EQUAL
112329: IFFALSE 112339
// sEarthquake := true ;
112331: LD_ADDR_EXP 187
112335: PUSH
112336: LD_INT 1
112338: ST_TO_ADDR
// if p3 = 27 then
112339: LD_VAR 0 3
112343: PUSH
112344: LD_INT 27
112346: EQUAL
112347: IFFALSE 112357
// sAI := true ;
112349: LD_ADDR_EXP 188
112353: PUSH
112354: LD_INT 1
112356: ST_TO_ADDR
// if p3 = 28 then
112357: LD_VAR 0 3
112361: PUSH
112362: LD_INT 28
112364: EQUAL
112365: IFFALSE 112375
// sCargo := true ;
112367: LD_ADDR_EXP 191
112371: PUSH
112372: LD_INT 1
112374: ST_TO_ADDR
// if p3 = 29 then
112375: LD_VAR 0 3
112379: PUSH
112380: LD_INT 29
112382: EQUAL
112383: IFFALSE 112393
// sDLaser := true ;
112385: LD_ADDR_EXP 192
112389: PUSH
112390: LD_INT 1
112392: ST_TO_ADDR
// if p3 = 30 then
112393: LD_VAR 0 3
112397: PUSH
112398: LD_INT 30
112400: EQUAL
112401: IFFALSE 112411
// sExchange := true ;
112403: LD_ADDR_EXP 193
112407: PUSH
112408: LD_INT 1
112410: ST_TO_ADDR
// if p3 = 31 then
112411: LD_VAR 0 3
112415: PUSH
112416: LD_INT 31
112418: EQUAL
112419: IFFALSE 112429
// sFac := true ;
112421: LD_ADDR_EXP 194
112425: PUSH
112426: LD_INT 1
112428: ST_TO_ADDR
// if p3 = 32 then
112429: LD_VAR 0 3
112433: PUSH
112434: LD_INT 32
112436: EQUAL
112437: IFFALSE 112447
// sPower := true ;
112439: LD_ADDR_EXP 195
112443: PUSH
112444: LD_INT 1
112446: ST_TO_ADDR
// if p3 = 33 then
112447: LD_VAR 0 3
112451: PUSH
112452: LD_INT 33
112454: EQUAL
112455: IFFALSE 112465
// sRandom := true ;
112457: LD_ADDR_EXP 196
112461: PUSH
112462: LD_INT 1
112464: ST_TO_ADDR
// if p3 = 34 then
112465: LD_VAR 0 3
112469: PUSH
112470: LD_INT 34
112472: EQUAL
112473: IFFALSE 112483
// sShield := true ;
112475: LD_ADDR_EXP 197
112479: PUSH
112480: LD_INT 1
112482: ST_TO_ADDR
// if p3 = 35 then
112483: LD_VAR 0 3
112487: PUSH
112488: LD_INT 35
112490: EQUAL
112491: IFFALSE 112501
// sTime := true ;
112493: LD_ADDR_EXP 198
112497: PUSH
112498: LD_INT 1
112500: ST_TO_ADDR
// if p3 = 36 then
112501: LD_VAR 0 3
112505: PUSH
112506: LD_INT 36
112508: EQUAL
112509: IFFALSE 112519
// sTools := true ;
112511: LD_ADDR_EXP 199
112515: PUSH
112516: LD_INT 1
112518: ST_TO_ADDR
// if p3 = 101 then
112519: LD_VAR 0 3
112523: PUSH
112524: LD_INT 101
112526: EQUAL
112527: IFFALSE 112537
// sSold := true ;
112529: LD_ADDR_EXP 164
112533: PUSH
112534: LD_INT 1
112536: ST_TO_ADDR
// if p3 = 102 then
112537: LD_VAR 0 3
112541: PUSH
112542: LD_INT 102
112544: EQUAL
112545: IFFALSE 112555
// sDiff := true ;
112547: LD_ADDR_EXP 165
112551: PUSH
112552: LD_INT 1
112554: ST_TO_ADDR
// if p3 = 103 then
112555: LD_VAR 0 3
112559: PUSH
112560: LD_INT 103
112562: EQUAL
112563: IFFALSE 112573
// sFog := true ;
112565: LD_ADDR_EXP 168
112569: PUSH
112570: LD_INT 1
112572: ST_TO_ADDR
// if p3 = 104 then
112573: LD_VAR 0 3
112577: PUSH
112578: LD_INT 104
112580: EQUAL
112581: IFFALSE 112591
// sReset := true ;
112583: LD_ADDR_EXP 169
112587: PUSH
112588: LD_INT 1
112590: ST_TO_ADDR
// if p3 = 105 then
112591: LD_VAR 0 3
112595: PUSH
112596: LD_INT 105
112598: EQUAL
112599: IFFALSE 112609
// sSun := true ;
112601: LD_ADDR_EXP 170
112605: PUSH
112606: LD_INT 1
112608: ST_TO_ADDR
// if p3 = 106 then
112609: LD_VAR 0 3
112613: PUSH
112614: LD_INT 106
112616: EQUAL
112617: IFFALSE 112627
// sTiger := true ;
112619: LD_ADDR_EXP 166
112623: PUSH
112624: LD_INT 1
112626: ST_TO_ADDR
// if p3 = 107 then
112627: LD_VAR 0 3
112631: PUSH
112632: LD_INT 107
112634: EQUAL
112635: IFFALSE 112645
// sBomb := true ;
112637: LD_ADDR_EXP 167
112641: PUSH
112642: LD_INT 1
112644: ST_TO_ADDR
// if p3 = 108 then
112645: LD_VAR 0 3
112649: PUSH
112650: LD_INT 108
112652: EQUAL
112653: IFFALSE 112663
// sWound := true ;
112655: LD_ADDR_EXP 175
112659: PUSH
112660: LD_INT 1
112662: ST_TO_ADDR
// if p3 = 109 then
112663: LD_VAR 0 3
112667: PUSH
112668: LD_INT 109
112670: EQUAL
112671: IFFALSE 112681
// sBetray := true ;
112673: LD_ADDR_EXP 179
112677: PUSH
112678: LD_INT 1
112680: ST_TO_ADDR
// if p3 = 110 then
112681: LD_VAR 0 3
112685: PUSH
112686: LD_INT 110
112688: EQUAL
112689: IFFALSE 112699
// sContamin := true ;
112691: LD_ADDR_EXP 180
112695: PUSH
112696: LD_INT 1
112698: ST_TO_ADDR
// if p3 = 111 then
112699: LD_VAR 0 3
112703: PUSH
112704: LD_INT 111
112706: EQUAL
112707: IFFALSE 112717
// sOil := true ;
112709: LD_ADDR_EXP 182
112713: PUSH
112714: LD_INT 1
112716: ST_TO_ADDR
// if p3 = 112 then
112717: LD_VAR 0 3
112721: PUSH
112722: LD_INT 112
112724: EQUAL
112725: IFFALSE 112735
// sStu := true ;
112727: LD_ADDR_EXP 186
112731: PUSH
112732: LD_INT 1
112734: ST_TO_ADDR
// if p3 = 113 then
112735: LD_VAR 0 3
112739: PUSH
112740: LD_INT 113
112742: EQUAL
112743: IFFALSE 112753
// sBazooka := true ;
112745: LD_ADDR_EXP 189
112749: PUSH
112750: LD_INT 1
112752: ST_TO_ADDR
// if p3 = 114 then
112753: LD_VAR 0 3
112757: PUSH
112758: LD_INT 114
112760: EQUAL
112761: IFFALSE 112771
// sMortar := true ;
112763: LD_ADDR_EXP 190
112767: PUSH
112768: LD_INT 1
112770: ST_TO_ADDR
// if p3 = 115 then
112771: LD_VAR 0 3
112775: PUSH
112776: LD_INT 115
112778: EQUAL
112779: IFFALSE 112789
// sRanger := true ;
112781: LD_ADDR_EXP 200
112785: PUSH
112786: LD_INT 1
112788: ST_TO_ADDR
// if p3 = 116 then
112789: LD_VAR 0 3
112793: PUSH
112794: LD_INT 116
112796: EQUAL
112797: IFFALSE 112807
// sComputer := true ;
112799: LD_ADDR_EXP 201
112803: PUSH
112804: LD_INT 1
112806: ST_TO_ADDR
// if p3 = 117 then
112807: LD_VAR 0 3
112811: PUSH
112812: LD_INT 117
112814: EQUAL
112815: IFFALSE 112825
// s30 := true ;
112817: LD_ADDR_EXP 202
112821: PUSH
112822: LD_INT 1
112824: ST_TO_ADDR
// if p3 = 118 then
112825: LD_VAR 0 3
112829: PUSH
112830: LD_INT 118
112832: EQUAL
112833: IFFALSE 112843
// s60 := true ;
112835: LD_ADDR_EXP 203
112839: PUSH
112840: LD_INT 1
112842: ST_TO_ADDR
// end ; if p2 = hack_mode then
112843: LD_VAR 0 2
112847: PUSH
112848: LD_INT 101
112850: EQUAL
112851: IFFALSE 112979
// begin case p3 of 1 :
112853: LD_VAR 0 3
112857: PUSH
112858: LD_INT 1
112860: DOUBLE
112861: EQUAL
112862: IFTRUE 112866
112864: GO 112873
112866: POP
// hHackUnlimitedResources ; 2 :
112867: CALL 125126 0 0
112871: GO 112979
112873: LD_INT 2
112875: DOUBLE
112876: EQUAL
112877: IFTRUE 112881
112879: GO 112888
112881: POP
// hHackSetLevel10 ; 3 :
112882: CALL 125259 0 0
112886: GO 112979
112888: LD_INT 3
112890: DOUBLE
112891: EQUAL
112892: IFTRUE 112896
112894: GO 112903
112896: POP
// hHackSetLevel10YourUnits ; 4 :
112897: CALL 125344 0 0
112901: GO 112979
112903: LD_INT 4
112905: DOUBLE
112906: EQUAL
112907: IFTRUE 112911
112909: GO 112918
112911: POP
// hHackInvincible ; 5 :
112912: CALL 125792 0 0
112916: GO 112979
112918: LD_INT 5
112920: DOUBLE
112921: EQUAL
112922: IFTRUE 112926
112924: GO 112933
112926: POP
// hHackInvisible ; 6 :
112927: CALL 125903 0 0
112931: GO 112979
112933: LD_INT 6
112935: DOUBLE
112936: EQUAL
112937: IFTRUE 112941
112939: GO 112948
112941: POP
// hHackChangeYourSide ; 7 :
112942: CALL 125960 0 0
112946: GO 112979
112948: LD_INT 7
112950: DOUBLE
112951: EQUAL
112952: IFTRUE 112956
112954: GO 112963
112956: POP
// hHackChangeUnitSide ; 8 :
112957: CALL 126002 0 0
112961: GO 112979
112963: LD_INT 8
112965: DOUBLE
112966: EQUAL
112967: IFTRUE 112971
112969: GO 112978
112971: POP
// hHackFog ; end ;
112972: CALL 126103 0 0
112976: GO 112979
112978: POP
// end ; if p2 = game_save_mode then
112979: LD_VAR 0 2
112983: PUSH
112984: LD_INT 102
112986: EQUAL
112987: IFFALSE 113042
// begin if p3 = 1 then
112989: LD_VAR 0 3
112993: PUSH
112994: LD_INT 1
112996: EQUAL
112997: IFFALSE 113009
// globalGameSaveCounter := p4 ;
112999: LD_ADDR_EXP 146
113003: PUSH
113004: LD_VAR 0 4
113008: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113009: LD_VAR 0 3
113013: PUSH
113014: LD_INT 2
113016: EQUAL
113017: PUSH
113018: LD_EXP 146
113022: AND
113023: IFFALSE 113042
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113025: LD_STRING setGameSaveCounter(
113027: PUSH
113028: LD_EXP 146
113032: STR
113033: PUSH
113034: LD_STRING )
113036: STR
113037: PPUSH
113038: CALL_OW 559
// end ; end ;
113042: LD_VAR 0 7
113046: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113047: LD_INT 0
113049: PPUSH
// streamModeActive := false ;
113050: LD_ADDR_EXP 147
113054: PUSH
113055: LD_INT 0
113057: ST_TO_ADDR
// normalCounter := 36 ;
113058: LD_ADDR_EXP 148
113062: PUSH
113063: LD_INT 36
113065: ST_TO_ADDR
// hardcoreCounter := 18 ;
113066: LD_ADDR_EXP 149
113070: PUSH
113071: LD_INT 18
113073: ST_TO_ADDR
// sRocket := false ;
113074: LD_ADDR_EXP 152
113078: PUSH
113079: LD_INT 0
113081: ST_TO_ADDR
// sSpeed := false ;
113082: LD_ADDR_EXP 151
113086: PUSH
113087: LD_INT 0
113089: ST_TO_ADDR
// sEngine := false ;
113090: LD_ADDR_EXP 153
113094: PUSH
113095: LD_INT 0
113097: ST_TO_ADDR
// sSpec := false ;
113098: LD_ADDR_EXP 150
113102: PUSH
113103: LD_INT 0
113105: ST_TO_ADDR
// sLevel := false ;
113106: LD_ADDR_EXP 154
113110: PUSH
113111: LD_INT 0
113113: ST_TO_ADDR
// sArmoury := false ;
113114: LD_ADDR_EXP 155
113118: PUSH
113119: LD_INT 0
113121: ST_TO_ADDR
// sRadar := false ;
113122: LD_ADDR_EXP 156
113126: PUSH
113127: LD_INT 0
113129: ST_TO_ADDR
// sBunker := false ;
113130: LD_ADDR_EXP 157
113134: PUSH
113135: LD_INT 0
113137: ST_TO_ADDR
// sHack := false ;
113138: LD_ADDR_EXP 158
113142: PUSH
113143: LD_INT 0
113145: ST_TO_ADDR
// sFire := false ;
113146: LD_ADDR_EXP 159
113150: PUSH
113151: LD_INT 0
113153: ST_TO_ADDR
// sRefresh := false ;
113154: LD_ADDR_EXP 160
113158: PUSH
113159: LD_INT 0
113161: ST_TO_ADDR
// sExp := false ;
113162: LD_ADDR_EXP 161
113166: PUSH
113167: LD_INT 0
113169: ST_TO_ADDR
// sDepot := false ;
113170: LD_ADDR_EXP 162
113174: PUSH
113175: LD_INT 0
113177: ST_TO_ADDR
// sFlag := false ;
113178: LD_ADDR_EXP 163
113182: PUSH
113183: LD_INT 0
113185: ST_TO_ADDR
// sKamikadze := false ;
113186: LD_ADDR_EXP 171
113190: PUSH
113191: LD_INT 0
113193: ST_TO_ADDR
// sTroll := false ;
113194: LD_ADDR_EXP 172
113198: PUSH
113199: LD_INT 0
113201: ST_TO_ADDR
// sSlow := false ;
113202: LD_ADDR_EXP 173
113206: PUSH
113207: LD_INT 0
113209: ST_TO_ADDR
// sLack := false ;
113210: LD_ADDR_EXP 174
113214: PUSH
113215: LD_INT 0
113217: ST_TO_ADDR
// sTank := false ;
113218: LD_ADDR_EXP 176
113222: PUSH
113223: LD_INT 0
113225: ST_TO_ADDR
// sRemote := false ;
113226: LD_ADDR_EXP 177
113230: PUSH
113231: LD_INT 0
113233: ST_TO_ADDR
// sPowell := false ;
113234: LD_ADDR_EXP 178
113238: PUSH
113239: LD_INT 0
113241: ST_TO_ADDR
// sTeleport := false ;
113242: LD_ADDR_EXP 181
113246: PUSH
113247: LD_INT 0
113249: ST_TO_ADDR
// sOilTower := false ;
113250: LD_ADDR_EXP 183
113254: PUSH
113255: LD_INT 0
113257: ST_TO_ADDR
// sShovel := false ;
113258: LD_ADDR_EXP 184
113262: PUSH
113263: LD_INT 0
113265: ST_TO_ADDR
// sSheik := false ;
113266: LD_ADDR_EXP 185
113270: PUSH
113271: LD_INT 0
113273: ST_TO_ADDR
// sEarthquake := false ;
113274: LD_ADDR_EXP 187
113278: PUSH
113279: LD_INT 0
113281: ST_TO_ADDR
// sAI := false ;
113282: LD_ADDR_EXP 188
113286: PUSH
113287: LD_INT 0
113289: ST_TO_ADDR
// sCargo := false ;
113290: LD_ADDR_EXP 191
113294: PUSH
113295: LD_INT 0
113297: ST_TO_ADDR
// sDLaser := false ;
113298: LD_ADDR_EXP 192
113302: PUSH
113303: LD_INT 0
113305: ST_TO_ADDR
// sExchange := false ;
113306: LD_ADDR_EXP 193
113310: PUSH
113311: LD_INT 0
113313: ST_TO_ADDR
// sFac := false ;
113314: LD_ADDR_EXP 194
113318: PUSH
113319: LD_INT 0
113321: ST_TO_ADDR
// sPower := false ;
113322: LD_ADDR_EXP 195
113326: PUSH
113327: LD_INT 0
113329: ST_TO_ADDR
// sRandom := false ;
113330: LD_ADDR_EXP 196
113334: PUSH
113335: LD_INT 0
113337: ST_TO_ADDR
// sShield := false ;
113338: LD_ADDR_EXP 197
113342: PUSH
113343: LD_INT 0
113345: ST_TO_ADDR
// sTime := false ;
113346: LD_ADDR_EXP 198
113350: PUSH
113351: LD_INT 0
113353: ST_TO_ADDR
// sTools := false ;
113354: LD_ADDR_EXP 199
113358: PUSH
113359: LD_INT 0
113361: ST_TO_ADDR
// sSold := false ;
113362: LD_ADDR_EXP 164
113366: PUSH
113367: LD_INT 0
113369: ST_TO_ADDR
// sDiff := false ;
113370: LD_ADDR_EXP 165
113374: PUSH
113375: LD_INT 0
113377: ST_TO_ADDR
// sFog := false ;
113378: LD_ADDR_EXP 168
113382: PUSH
113383: LD_INT 0
113385: ST_TO_ADDR
// sReset := false ;
113386: LD_ADDR_EXP 169
113390: PUSH
113391: LD_INT 0
113393: ST_TO_ADDR
// sSun := false ;
113394: LD_ADDR_EXP 170
113398: PUSH
113399: LD_INT 0
113401: ST_TO_ADDR
// sTiger := false ;
113402: LD_ADDR_EXP 166
113406: PUSH
113407: LD_INT 0
113409: ST_TO_ADDR
// sBomb := false ;
113410: LD_ADDR_EXP 167
113414: PUSH
113415: LD_INT 0
113417: ST_TO_ADDR
// sWound := false ;
113418: LD_ADDR_EXP 175
113422: PUSH
113423: LD_INT 0
113425: ST_TO_ADDR
// sBetray := false ;
113426: LD_ADDR_EXP 179
113430: PUSH
113431: LD_INT 0
113433: ST_TO_ADDR
// sContamin := false ;
113434: LD_ADDR_EXP 180
113438: PUSH
113439: LD_INT 0
113441: ST_TO_ADDR
// sOil := false ;
113442: LD_ADDR_EXP 182
113446: PUSH
113447: LD_INT 0
113449: ST_TO_ADDR
// sStu := false ;
113450: LD_ADDR_EXP 186
113454: PUSH
113455: LD_INT 0
113457: ST_TO_ADDR
// sBazooka := false ;
113458: LD_ADDR_EXP 189
113462: PUSH
113463: LD_INT 0
113465: ST_TO_ADDR
// sMortar := false ;
113466: LD_ADDR_EXP 190
113470: PUSH
113471: LD_INT 0
113473: ST_TO_ADDR
// sRanger := false ;
113474: LD_ADDR_EXP 200
113478: PUSH
113479: LD_INT 0
113481: ST_TO_ADDR
// sComputer := false ;
113482: LD_ADDR_EXP 201
113486: PUSH
113487: LD_INT 0
113489: ST_TO_ADDR
// s30 := false ;
113490: LD_ADDR_EXP 202
113494: PUSH
113495: LD_INT 0
113497: ST_TO_ADDR
// s60 := false ;
113498: LD_ADDR_EXP 203
113502: PUSH
113503: LD_INT 0
113505: ST_TO_ADDR
// end ;
113506: LD_VAR 0 1
113510: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
113511: LD_INT 0
113513: PPUSH
113514: PPUSH
113515: PPUSH
113516: PPUSH
113517: PPUSH
113518: PPUSH
113519: PPUSH
// result := [ ] ;
113520: LD_ADDR_VAR 0 2
113524: PUSH
113525: EMPTY
113526: ST_TO_ADDR
// if campaign_id = 1 then
113527: LD_OWVAR 69
113531: PUSH
113532: LD_INT 1
113534: EQUAL
113535: IFFALSE 116701
// begin case mission_number of 1 :
113537: LD_OWVAR 70
113541: PUSH
113542: LD_INT 1
113544: DOUBLE
113545: EQUAL
113546: IFTRUE 113550
113548: GO 113626
113550: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
113551: LD_ADDR_VAR 0 2
113555: PUSH
113556: LD_INT 2
113558: PUSH
113559: LD_INT 4
113561: PUSH
113562: LD_INT 11
113564: PUSH
113565: LD_INT 12
113567: PUSH
113568: LD_INT 15
113570: PUSH
113571: LD_INT 16
113573: PUSH
113574: LD_INT 22
113576: PUSH
113577: LD_INT 23
113579: PUSH
113580: LD_INT 26
113582: PUSH
113583: EMPTY
113584: LIST
113585: LIST
113586: LIST
113587: LIST
113588: LIST
113589: LIST
113590: LIST
113591: LIST
113592: LIST
113593: PUSH
113594: LD_INT 101
113596: PUSH
113597: LD_INT 102
113599: PUSH
113600: LD_INT 106
113602: PUSH
113603: LD_INT 116
113605: PUSH
113606: LD_INT 117
113608: PUSH
113609: LD_INT 118
113611: PUSH
113612: EMPTY
113613: LIST
113614: LIST
113615: LIST
113616: LIST
113617: LIST
113618: LIST
113619: PUSH
113620: EMPTY
113621: LIST
113622: LIST
113623: ST_TO_ADDR
113624: GO 116699
113626: LD_INT 2
113628: DOUBLE
113629: EQUAL
113630: IFTRUE 113634
113632: GO 113718
113634: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
113635: LD_ADDR_VAR 0 2
113639: PUSH
113640: LD_INT 2
113642: PUSH
113643: LD_INT 4
113645: PUSH
113646: LD_INT 11
113648: PUSH
113649: LD_INT 12
113651: PUSH
113652: LD_INT 15
113654: PUSH
113655: LD_INT 16
113657: PUSH
113658: LD_INT 22
113660: PUSH
113661: LD_INT 23
113663: PUSH
113664: LD_INT 26
113666: PUSH
113667: EMPTY
113668: LIST
113669: LIST
113670: LIST
113671: LIST
113672: LIST
113673: LIST
113674: LIST
113675: LIST
113676: LIST
113677: PUSH
113678: LD_INT 101
113680: PUSH
113681: LD_INT 102
113683: PUSH
113684: LD_INT 105
113686: PUSH
113687: LD_INT 106
113689: PUSH
113690: LD_INT 108
113692: PUSH
113693: LD_INT 116
113695: PUSH
113696: LD_INT 117
113698: PUSH
113699: LD_INT 118
113701: PUSH
113702: EMPTY
113703: LIST
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: PUSH
113712: EMPTY
113713: LIST
113714: LIST
113715: ST_TO_ADDR
113716: GO 116699
113718: LD_INT 3
113720: DOUBLE
113721: EQUAL
113722: IFTRUE 113726
113724: GO 113814
113726: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
113727: LD_ADDR_VAR 0 2
113731: PUSH
113732: LD_INT 2
113734: PUSH
113735: LD_INT 4
113737: PUSH
113738: LD_INT 5
113740: PUSH
113741: LD_INT 11
113743: PUSH
113744: LD_INT 12
113746: PUSH
113747: LD_INT 15
113749: PUSH
113750: LD_INT 16
113752: PUSH
113753: LD_INT 22
113755: PUSH
113756: LD_INT 26
113758: PUSH
113759: LD_INT 36
113761: PUSH
113762: EMPTY
113763: LIST
113764: LIST
113765: LIST
113766: LIST
113767: LIST
113768: LIST
113769: LIST
113770: LIST
113771: LIST
113772: LIST
113773: PUSH
113774: LD_INT 101
113776: PUSH
113777: LD_INT 102
113779: PUSH
113780: LD_INT 105
113782: PUSH
113783: LD_INT 106
113785: PUSH
113786: LD_INT 108
113788: PUSH
113789: LD_INT 116
113791: PUSH
113792: LD_INT 117
113794: PUSH
113795: LD_INT 118
113797: PUSH
113798: EMPTY
113799: LIST
113800: LIST
113801: LIST
113802: LIST
113803: LIST
113804: LIST
113805: LIST
113806: LIST
113807: PUSH
113808: EMPTY
113809: LIST
113810: LIST
113811: ST_TO_ADDR
113812: GO 116699
113814: LD_INT 4
113816: DOUBLE
113817: EQUAL
113818: IFTRUE 113822
113820: GO 113918
113822: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
113823: LD_ADDR_VAR 0 2
113827: PUSH
113828: LD_INT 2
113830: PUSH
113831: LD_INT 4
113833: PUSH
113834: LD_INT 5
113836: PUSH
113837: LD_INT 8
113839: PUSH
113840: LD_INT 11
113842: PUSH
113843: LD_INT 12
113845: PUSH
113846: LD_INT 15
113848: PUSH
113849: LD_INT 16
113851: PUSH
113852: LD_INT 22
113854: PUSH
113855: LD_INT 23
113857: PUSH
113858: LD_INT 26
113860: PUSH
113861: LD_INT 36
113863: PUSH
113864: EMPTY
113865: LIST
113866: LIST
113867: LIST
113868: LIST
113869: LIST
113870: LIST
113871: LIST
113872: LIST
113873: LIST
113874: LIST
113875: LIST
113876: LIST
113877: PUSH
113878: LD_INT 101
113880: PUSH
113881: LD_INT 102
113883: PUSH
113884: LD_INT 105
113886: PUSH
113887: LD_INT 106
113889: PUSH
113890: LD_INT 108
113892: PUSH
113893: LD_INT 116
113895: PUSH
113896: LD_INT 117
113898: PUSH
113899: LD_INT 118
113901: PUSH
113902: EMPTY
113903: LIST
113904: LIST
113905: LIST
113906: LIST
113907: LIST
113908: LIST
113909: LIST
113910: LIST
113911: PUSH
113912: EMPTY
113913: LIST
113914: LIST
113915: ST_TO_ADDR
113916: GO 116699
113918: LD_INT 5
113920: DOUBLE
113921: EQUAL
113922: IFTRUE 113926
113924: GO 114038
113926: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
113927: LD_ADDR_VAR 0 2
113931: PUSH
113932: LD_INT 2
113934: PUSH
113935: LD_INT 4
113937: PUSH
113938: LD_INT 5
113940: PUSH
113941: LD_INT 6
113943: PUSH
113944: LD_INT 8
113946: PUSH
113947: LD_INT 11
113949: PUSH
113950: LD_INT 12
113952: PUSH
113953: LD_INT 15
113955: PUSH
113956: LD_INT 16
113958: PUSH
113959: LD_INT 22
113961: PUSH
113962: LD_INT 23
113964: PUSH
113965: LD_INT 25
113967: PUSH
113968: LD_INT 26
113970: PUSH
113971: LD_INT 36
113973: PUSH
113974: EMPTY
113975: LIST
113976: LIST
113977: LIST
113978: LIST
113979: LIST
113980: LIST
113981: LIST
113982: LIST
113983: LIST
113984: LIST
113985: LIST
113986: LIST
113987: LIST
113988: LIST
113989: PUSH
113990: LD_INT 101
113992: PUSH
113993: LD_INT 102
113995: PUSH
113996: LD_INT 105
113998: PUSH
113999: LD_INT 106
114001: PUSH
114002: LD_INT 108
114004: PUSH
114005: LD_INT 109
114007: PUSH
114008: LD_INT 112
114010: PUSH
114011: LD_INT 116
114013: PUSH
114014: LD_INT 117
114016: PUSH
114017: LD_INT 118
114019: PUSH
114020: EMPTY
114021: LIST
114022: LIST
114023: LIST
114024: LIST
114025: LIST
114026: LIST
114027: LIST
114028: LIST
114029: LIST
114030: LIST
114031: PUSH
114032: EMPTY
114033: LIST
114034: LIST
114035: ST_TO_ADDR
114036: GO 116699
114038: LD_INT 6
114040: DOUBLE
114041: EQUAL
114042: IFTRUE 114046
114044: GO 114178
114046: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114047: LD_ADDR_VAR 0 2
114051: PUSH
114052: LD_INT 2
114054: PUSH
114055: LD_INT 4
114057: PUSH
114058: LD_INT 5
114060: PUSH
114061: LD_INT 6
114063: PUSH
114064: LD_INT 8
114066: PUSH
114067: LD_INT 11
114069: PUSH
114070: LD_INT 12
114072: PUSH
114073: LD_INT 15
114075: PUSH
114076: LD_INT 16
114078: PUSH
114079: LD_INT 20
114081: PUSH
114082: LD_INT 21
114084: PUSH
114085: LD_INT 22
114087: PUSH
114088: LD_INT 23
114090: PUSH
114091: LD_INT 25
114093: PUSH
114094: LD_INT 26
114096: PUSH
114097: LD_INT 30
114099: PUSH
114100: LD_INT 31
114102: PUSH
114103: LD_INT 32
114105: PUSH
114106: LD_INT 36
114108: PUSH
114109: EMPTY
114110: LIST
114111: LIST
114112: LIST
114113: LIST
114114: LIST
114115: LIST
114116: LIST
114117: LIST
114118: LIST
114119: LIST
114120: LIST
114121: LIST
114122: LIST
114123: LIST
114124: LIST
114125: LIST
114126: LIST
114127: LIST
114128: LIST
114129: PUSH
114130: LD_INT 101
114132: PUSH
114133: LD_INT 102
114135: PUSH
114136: LD_INT 105
114138: PUSH
114139: LD_INT 106
114141: PUSH
114142: LD_INT 108
114144: PUSH
114145: LD_INT 109
114147: PUSH
114148: LD_INT 112
114150: PUSH
114151: LD_INT 116
114153: PUSH
114154: LD_INT 117
114156: PUSH
114157: LD_INT 118
114159: PUSH
114160: EMPTY
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: LIST
114170: LIST
114171: PUSH
114172: EMPTY
114173: LIST
114174: LIST
114175: ST_TO_ADDR
114176: GO 116699
114178: LD_INT 7
114180: DOUBLE
114181: EQUAL
114182: IFTRUE 114186
114184: GO 114298
114186: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
114187: LD_ADDR_VAR 0 2
114191: PUSH
114192: LD_INT 2
114194: PUSH
114195: LD_INT 4
114197: PUSH
114198: LD_INT 5
114200: PUSH
114201: LD_INT 7
114203: PUSH
114204: LD_INT 11
114206: PUSH
114207: LD_INT 12
114209: PUSH
114210: LD_INT 15
114212: PUSH
114213: LD_INT 16
114215: PUSH
114216: LD_INT 20
114218: PUSH
114219: LD_INT 21
114221: PUSH
114222: LD_INT 22
114224: PUSH
114225: LD_INT 23
114227: PUSH
114228: LD_INT 25
114230: PUSH
114231: LD_INT 26
114233: PUSH
114234: EMPTY
114235: LIST
114236: LIST
114237: LIST
114238: LIST
114239: LIST
114240: LIST
114241: LIST
114242: LIST
114243: LIST
114244: LIST
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: PUSH
114250: LD_INT 101
114252: PUSH
114253: LD_INT 102
114255: PUSH
114256: LD_INT 103
114258: PUSH
114259: LD_INT 105
114261: PUSH
114262: LD_INT 106
114264: PUSH
114265: LD_INT 108
114267: PUSH
114268: LD_INT 112
114270: PUSH
114271: LD_INT 116
114273: PUSH
114274: LD_INT 117
114276: PUSH
114277: LD_INT 118
114279: PUSH
114280: EMPTY
114281: LIST
114282: LIST
114283: LIST
114284: LIST
114285: LIST
114286: LIST
114287: LIST
114288: LIST
114289: LIST
114290: LIST
114291: PUSH
114292: EMPTY
114293: LIST
114294: LIST
114295: ST_TO_ADDR
114296: GO 116699
114298: LD_INT 8
114300: DOUBLE
114301: EQUAL
114302: IFTRUE 114306
114304: GO 114446
114306: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
114307: LD_ADDR_VAR 0 2
114311: PUSH
114312: LD_INT 2
114314: PUSH
114315: LD_INT 4
114317: PUSH
114318: LD_INT 5
114320: PUSH
114321: LD_INT 6
114323: PUSH
114324: LD_INT 7
114326: PUSH
114327: LD_INT 8
114329: PUSH
114330: LD_INT 11
114332: PUSH
114333: LD_INT 12
114335: PUSH
114336: LD_INT 15
114338: PUSH
114339: LD_INT 16
114341: PUSH
114342: LD_INT 20
114344: PUSH
114345: LD_INT 21
114347: PUSH
114348: LD_INT 22
114350: PUSH
114351: LD_INT 23
114353: PUSH
114354: LD_INT 25
114356: PUSH
114357: LD_INT 26
114359: PUSH
114360: LD_INT 30
114362: PUSH
114363: LD_INT 31
114365: PUSH
114366: LD_INT 32
114368: PUSH
114369: LD_INT 36
114371: PUSH
114372: EMPTY
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: LIST
114378: LIST
114379: LIST
114380: LIST
114381: LIST
114382: LIST
114383: LIST
114384: LIST
114385: LIST
114386: LIST
114387: LIST
114388: LIST
114389: LIST
114390: LIST
114391: LIST
114392: LIST
114393: PUSH
114394: LD_INT 101
114396: PUSH
114397: LD_INT 102
114399: PUSH
114400: LD_INT 103
114402: PUSH
114403: LD_INT 105
114405: PUSH
114406: LD_INT 106
114408: PUSH
114409: LD_INT 108
114411: PUSH
114412: LD_INT 109
114414: PUSH
114415: LD_INT 112
114417: PUSH
114418: LD_INT 116
114420: PUSH
114421: LD_INT 117
114423: PUSH
114424: LD_INT 118
114426: PUSH
114427: EMPTY
114428: LIST
114429: LIST
114430: LIST
114431: LIST
114432: LIST
114433: LIST
114434: LIST
114435: LIST
114436: LIST
114437: LIST
114438: LIST
114439: PUSH
114440: EMPTY
114441: LIST
114442: LIST
114443: ST_TO_ADDR
114444: GO 116699
114446: LD_INT 9
114448: DOUBLE
114449: EQUAL
114450: IFTRUE 114454
114452: GO 114602
114454: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
114455: LD_ADDR_VAR 0 2
114459: PUSH
114460: LD_INT 2
114462: PUSH
114463: LD_INT 4
114465: PUSH
114466: LD_INT 5
114468: PUSH
114469: LD_INT 6
114471: PUSH
114472: LD_INT 7
114474: PUSH
114475: LD_INT 8
114477: PUSH
114478: LD_INT 11
114480: PUSH
114481: LD_INT 12
114483: PUSH
114484: LD_INT 15
114486: PUSH
114487: LD_INT 16
114489: PUSH
114490: LD_INT 20
114492: PUSH
114493: LD_INT 21
114495: PUSH
114496: LD_INT 22
114498: PUSH
114499: LD_INT 23
114501: PUSH
114502: LD_INT 25
114504: PUSH
114505: LD_INT 26
114507: PUSH
114508: LD_INT 28
114510: PUSH
114511: LD_INT 30
114513: PUSH
114514: LD_INT 31
114516: PUSH
114517: LD_INT 32
114519: PUSH
114520: LD_INT 36
114522: PUSH
114523: EMPTY
114524: LIST
114525: LIST
114526: LIST
114527: LIST
114528: LIST
114529: LIST
114530: LIST
114531: LIST
114532: LIST
114533: LIST
114534: LIST
114535: LIST
114536: LIST
114537: LIST
114538: LIST
114539: LIST
114540: LIST
114541: LIST
114542: LIST
114543: LIST
114544: LIST
114545: PUSH
114546: LD_INT 101
114548: PUSH
114549: LD_INT 102
114551: PUSH
114552: LD_INT 103
114554: PUSH
114555: LD_INT 105
114557: PUSH
114558: LD_INT 106
114560: PUSH
114561: LD_INT 108
114563: PUSH
114564: LD_INT 109
114566: PUSH
114567: LD_INT 112
114569: PUSH
114570: LD_INT 114
114572: PUSH
114573: LD_INT 116
114575: PUSH
114576: LD_INT 117
114578: PUSH
114579: LD_INT 118
114581: PUSH
114582: EMPTY
114583: LIST
114584: LIST
114585: LIST
114586: LIST
114587: LIST
114588: LIST
114589: LIST
114590: LIST
114591: LIST
114592: LIST
114593: LIST
114594: LIST
114595: PUSH
114596: EMPTY
114597: LIST
114598: LIST
114599: ST_TO_ADDR
114600: GO 116699
114602: LD_INT 10
114604: DOUBLE
114605: EQUAL
114606: IFTRUE 114610
114608: GO 114806
114610: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
114611: LD_ADDR_VAR 0 2
114615: PUSH
114616: LD_INT 2
114618: PUSH
114619: LD_INT 4
114621: PUSH
114622: LD_INT 5
114624: PUSH
114625: LD_INT 6
114627: PUSH
114628: LD_INT 7
114630: PUSH
114631: LD_INT 8
114633: PUSH
114634: LD_INT 9
114636: PUSH
114637: LD_INT 10
114639: PUSH
114640: LD_INT 11
114642: PUSH
114643: LD_INT 12
114645: PUSH
114646: LD_INT 13
114648: PUSH
114649: LD_INT 14
114651: PUSH
114652: LD_INT 15
114654: PUSH
114655: LD_INT 16
114657: PUSH
114658: LD_INT 17
114660: PUSH
114661: LD_INT 18
114663: PUSH
114664: LD_INT 19
114666: PUSH
114667: LD_INT 20
114669: PUSH
114670: LD_INT 21
114672: PUSH
114673: LD_INT 22
114675: PUSH
114676: LD_INT 23
114678: PUSH
114679: LD_INT 24
114681: PUSH
114682: LD_INT 25
114684: PUSH
114685: LD_INT 26
114687: PUSH
114688: LD_INT 28
114690: PUSH
114691: LD_INT 30
114693: PUSH
114694: LD_INT 31
114696: PUSH
114697: LD_INT 32
114699: PUSH
114700: LD_INT 36
114702: PUSH
114703: EMPTY
114704: LIST
114705: LIST
114706: LIST
114707: LIST
114708: LIST
114709: LIST
114710: LIST
114711: LIST
114712: LIST
114713: LIST
114714: LIST
114715: LIST
114716: LIST
114717: LIST
114718: LIST
114719: LIST
114720: LIST
114721: LIST
114722: LIST
114723: LIST
114724: LIST
114725: LIST
114726: LIST
114727: LIST
114728: LIST
114729: LIST
114730: LIST
114731: LIST
114732: LIST
114733: PUSH
114734: LD_INT 101
114736: PUSH
114737: LD_INT 102
114739: PUSH
114740: LD_INT 103
114742: PUSH
114743: LD_INT 104
114745: PUSH
114746: LD_INT 105
114748: PUSH
114749: LD_INT 106
114751: PUSH
114752: LD_INT 107
114754: PUSH
114755: LD_INT 108
114757: PUSH
114758: LD_INT 109
114760: PUSH
114761: LD_INT 110
114763: PUSH
114764: LD_INT 111
114766: PUSH
114767: LD_INT 112
114769: PUSH
114770: LD_INT 114
114772: PUSH
114773: LD_INT 116
114775: PUSH
114776: LD_INT 117
114778: PUSH
114779: LD_INT 118
114781: PUSH
114782: EMPTY
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: LIST
114789: LIST
114790: LIST
114791: LIST
114792: LIST
114793: LIST
114794: LIST
114795: LIST
114796: LIST
114797: LIST
114798: LIST
114799: PUSH
114800: EMPTY
114801: LIST
114802: LIST
114803: ST_TO_ADDR
114804: GO 116699
114806: LD_INT 11
114808: DOUBLE
114809: EQUAL
114810: IFTRUE 114814
114812: GO 115018
114814: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
114815: LD_ADDR_VAR 0 2
114819: PUSH
114820: LD_INT 2
114822: PUSH
114823: LD_INT 3
114825: PUSH
114826: LD_INT 4
114828: PUSH
114829: LD_INT 5
114831: PUSH
114832: LD_INT 6
114834: PUSH
114835: LD_INT 7
114837: PUSH
114838: LD_INT 8
114840: PUSH
114841: LD_INT 9
114843: PUSH
114844: LD_INT 10
114846: PUSH
114847: LD_INT 11
114849: PUSH
114850: LD_INT 12
114852: PUSH
114853: LD_INT 13
114855: PUSH
114856: LD_INT 14
114858: PUSH
114859: LD_INT 15
114861: PUSH
114862: LD_INT 16
114864: PUSH
114865: LD_INT 17
114867: PUSH
114868: LD_INT 18
114870: PUSH
114871: LD_INT 19
114873: PUSH
114874: LD_INT 20
114876: PUSH
114877: LD_INT 21
114879: PUSH
114880: LD_INT 22
114882: PUSH
114883: LD_INT 23
114885: PUSH
114886: LD_INT 24
114888: PUSH
114889: LD_INT 25
114891: PUSH
114892: LD_INT 26
114894: PUSH
114895: LD_INT 28
114897: PUSH
114898: LD_INT 30
114900: PUSH
114901: LD_INT 31
114903: PUSH
114904: LD_INT 32
114906: PUSH
114907: LD_INT 34
114909: PUSH
114910: LD_INT 36
114912: PUSH
114913: EMPTY
114914: LIST
114915: LIST
114916: LIST
114917: LIST
114918: LIST
114919: LIST
114920: LIST
114921: LIST
114922: LIST
114923: LIST
114924: LIST
114925: LIST
114926: LIST
114927: LIST
114928: LIST
114929: LIST
114930: LIST
114931: LIST
114932: LIST
114933: LIST
114934: LIST
114935: LIST
114936: LIST
114937: LIST
114938: LIST
114939: LIST
114940: LIST
114941: LIST
114942: LIST
114943: LIST
114944: LIST
114945: PUSH
114946: LD_INT 101
114948: PUSH
114949: LD_INT 102
114951: PUSH
114952: LD_INT 103
114954: PUSH
114955: LD_INT 104
114957: PUSH
114958: LD_INT 105
114960: PUSH
114961: LD_INT 106
114963: PUSH
114964: LD_INT 107
114966: PUSH
114967: LD_INT 108
114969: PUSH
114970: LD_INT 109
114972: PUSH
114973: LD_INT 110
114975: PUSH
114976: LD_INT 111
114978: PUSH
114979: LD_INT 112
114981: PUSH
114982: LD_INT 114
114984: PUSH
114985: LD_INT 116
114987: PUSH
114988: LD_INT 117
114990: PUSH
114991: LD_INT 118
114993: PUSH
114994: EMPTY
114995: LIST
114996: LIST
114997: LIST
114998: LIST
114999: LIST
115000: LIST
115001: LIST
115002: LIST
115003: LIST
115004: LIST
115005: LIST
115006: LIST
115007: LIST
115008: LIST
115009: LIST
115010: LIST
115011: PUSH
115012: EMPTY
115013: LIST
115014: LIST
115015: ST_TO_ADDR
115016: GO 116699
115018: LD_INT 12
115020: DOUBLE
115021: EQUAL
115022: IFTRUE 115026
115024: GO 115246
115026: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115027: LD_ADDR_VAR 0 2
115031: PUSH
115032: LD_INT 1
115034: PUSH
115035: LD_INT 2
115037: PUSH
115038: LD_INT 3
115040: PUSH
115041: LD_INT 4
115043: PUSH
115044: LD_INT 5
115046: PUSH
115047: LD_INT 6
115049: PUSH
115050: LD_INT 7
115052: PUSH
115053: LD_INT 8
115055: PUSH
115056: LD_INT 9
115058: PUSH
115059: LD_INT 10
115061: PUSH
115062: LD_INT 11
115064: PUSH
115065: LD_INT 12
115067: PUSH
115068: LD_INT 13
115070: PUSH
115071: LD_INT 14
115073: PUSH
115074: LD_INT 15
115076: PUSH
115077: LD_INT 16
115079: PUSH
115080: LD_INT 17
115082: PUSH
115083: LD_INT 18
115085: PUSH
115086: LD_INT 19
115088: PUSH
115089: LD_INT 20
115091: PUSH
115092: LD_INT 21
115094: PUSH
115095: LD_INT 22
115097: PUSH
115098: LD_INT 23
115100: PUSH
115101: LD_INT 24
115103: PUSH
115104: LD_INT 25
115106: PUSH
115107: LD_INT 26
115109: PUSH
115110: LD_INT 27
115112: PUSH
115113: LD_INT 28
115115: PUSH
115116: LD_INT 30
115118: PUSH
115119: LD_INT 31
115121: PUSH
115122: LD_INT 32
115124: PUSH
115125: LD_INT 33
115127: PUSH
115128: LD_INT 34
115130: PUSH
115131: LD_INT 36
115133: PUSH
115134: EMPTY
115135: LIST
115136: LIST
115137: LIST
115138: LIST
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: LIST
115144: LIST
115145: LIST
115146: LIST
115147: LIST
115148: LIST
115149: LIST
115150: LIST
115151: LIST
115152: LIST
115153: LIST
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: PUSH
115170: LD_INT 101
115172: PUSH
115173: LD_INT 102
115175: PUSH
115176: LD_INT 103
115178: PUSH
115179: LD_INT 104
115181: PUSH
115182: LD_INT 105
115184: PUSH
115185: LD_INT 106
115187: PUSH
115188: LD_INT 107
115190: PUSH
115191: LD_INT 108
115193: PUSH
115194: LD_INT 109
115196: PUSH
115197: LD_INT 110
115199: PUSH
115200: LD_INT 111
115202: PUSH
115203: LD_INT 112
115205: PUSH
115206: LD_INT 113
115208: PUSH
115209: LD_INT 114
115211: PUSH
115212: LD_INT 116
115214: PUSH
115215: LD_INT 117
115217: PUSH
115218: LD_INT 118
115220: PUSH
115221: EMPTY
115222: LIST
115223: LIST
115224: LIST
115225: LIST
115226: LIST
115227: LIST
115228: LIST
115229: LIST
115230: LIST
115231: LIST
115232: LIST
115233: LIST
115234: LIST
115235: LIST
115236: LIST
115237: LIST
115238: LIST
115239: PUSH
115240: EMPTY
115241: LIST
115242: LIST
115243: ST_TO_ADDR
115244: GO 116699
115246: LD_INT 13
115248: DOUBLE
115249: EQUAL
115250: IFTRUE 115254
115252: GO 115462
115254: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
115255: LD_ADDR_VAR 0 2
115259: PUSH
115260: LD_INT 1
115262: PUSH
115263: LD_INT 2
115265: PUSH
115266: LD_INT 3
115268: PUSH
115269: LD_INT 4
115271: PUSH
115272: LD_INT 5
115274: PUSH
115275: LD_INT 8
115277: PUSH
115278: LD_INT 9
115280: PUSH
115281: LD_INT 10
115283: PUSH
115284: LD_INT 11
115286: PUSH
115287: LD_INT 12
115289: PUSH
115290: LD_INT 14
115292: PUSH
115293: LD_INT 15
115295: PUSH
115296: LD_INT 16
115298: PUSH
115299: LD_INT 17
115301: PUSH
115302: LD_INT 18
115304: PUSH
115305: LD_INT 19
115307: PUSH
115308: LD_INT 20
115310: PUSH
115311: LD_INT 21
115313: PUSH
115314: LD_INT 22
115316: PUSH
115317: LD_INT 23
115319: PUSH
115320: LD_INT 24
115322: PUSH
115323: LD_INT 25
115325: PUSH
115326: LD_INT 26
115328: PUSH
115329: LD_INT 27
115331: PUSH
115332: LD_INT 28
115334: PUSH
115335: LD_INT 30
115337: PUSH
115338: LD_INT 31
115340: PUSH
115341: LD_INT 32
115343: PUSH
115344: LD_INT 33
115346: PUSH
115347: LD_INT 34
115349: PUSH
115350: LD_INT 36
115352: PUSH
115353: EMPTY
115354: LIST
115355: LIST
115356: LIST
115357: LIST
115358: LIST
115359: LIST
115360: LIST
115361: LIST
115362: LIST
115363: LIST
115364: LIST
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: LIST
115372: LIST
115373: LIST
115374: LIST
115375: LIST
115376: LIST
115377: LIST
115378: LIST
115379: LIST
115380: LIST
115381: LIST
115382: LIST
115383: LIST
115384: LIST
115385: PUSH
115386: LD_INT 101
115388: PUSH
115389: LD_INT 102
115391: PUSH
115392: LD_INT 103
115394: PUSH
115395: LD_INT 104
115397: PUSH
115398: LD_INT 105
115400: PUSH
115401: LD_INT 106
115403: PUSH
115404: LD_INT 107
115406: PUSH
115407: LD_INT 108
115409: PUSH
115410: LD_INT 109
115412: PUSH
115413: LD_INT 110
115415: PUSH
115416: LD_INT 111
115418: PUSH
115419: LD_INT 112
115421: PUSH
115422: LD_INT 113
115424: PUSH
115425: LD_INT 114
115427: PUSH
115428: LD_INT 116
115430: PUSH
115431: LD_INT 117
115433: PUSH
115434: LD_INT 118
115436: PUSH
115437: EMPTY
115438: LIST
115439: LIST
115440: LIST
115441: LIST
115442: LIST
115443: LIST
115444: LIST
115445: LIST
115446: LIST
115447: LIST
115448: LIST
115449: LIST
115450: LIST
115451: LIST
115452: LIST
115453: LIST
115454: LIST
115455: PUSH
115456: EMPTY
115457: LIST
115458: LIST
115459: ST_TO_ADDR
115460: GO 116699
115462: LD_INT 14
115464: DOUBLE
115465: EQUAL
115466: IFTRUE 115470
115468: GO 115694
115470: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
115471: LD_ADDR_VAR 0 2
115475: PUSH
115476: LD_INT 1
115478: PUSH
115479: LD_INT 2
115481: PUSH
115482: LD_INT 3
115484: PUSH
115485: LD_INT 4
115487: PUSH
115488: LD_INT 5
115490: PUSH
115491: LD_INT 6
115493: PUSH
115494: LD_INT 7
115496: PUSH
115497: LD_INT 8
115499: PUSH
115500: LD_INT 9
115502: PUSH
115503: LD_INT 10
115505: PUSH
115506: LD_INT 11
115508: PUSH
115509: LD_INT 12
115511: PUSH
115512: LD_INT 13
115514: PUSH
115515: LD_INT 14
115517: PUSH
115518: LD_INT 15
115520: PUSH
115521: LD_INT 16
115523: PUSH
115524: LD_INT 17
115526: PUSH
115527: LD_INT 18
115529: PUSH
115530: LD_INT 19
115532: PUSH
115533: LD_INT 20
115535: PUSH
115536: LD_INT 21
115538: PUSH
115539: LD_INT 22
115541: PUSH
115542: LD_INT 23
115544: PUSH
115545: LD_INT 24
115547: PUSH
115548: LD_INT 25
115550: PUSH
115551: LD_INT 26
115553: PUSH
115554: LD_INT 27
115556: PUSH
115557: LD_INT 28
115559: PUSH
115560: LD_INT 29
115562: PUSH
115563: LD_INT 30
115565: PUSH
115566: LD_INT 31
115568: PUSH
115569: LD_INT 32
115571: PUSH
115572: LD_INT 33
115574: PUSH
115575: LD_INT 34
115577: PUSH
115578: LD_INT 36
115580: PUSH
115581: EMPTY
115582: LIST
115583: LIST
115584: LIST
115585: LIST
115586: LIST
115587: LIST
115588: LIST
115589: LIST
115590: LIST
115591: LIST
115592: LIST
115593: LIST
115594: LIST
115595: LIST
115596: LIST
115597: LIST
115598: LIST
115599: LIST
115600: LIST
115601: LIST
115602: LIST
115603: LIST
115604: LIST
115605: LIST
115606: LIST
115607: LIST
115608: LIST
115609: LIST
115610: LIST
115611: LIST
115612: LIST
115613: LIST
115614: LIST
115615: LIST
115616: LIST
115617: PUSH
115618: LD_INT 101
115620: PUSH
115621: LD_INT 102
115623: PUSH
115624: LD_INT 103
115626: PUSH
115627: LD_INT 104
115629: PUSH
115630: LD_INT 105
115632: PUSH
115633: LD_INT 106
115635: PUSH
115636: LD_INT 107
115638: PUSH
115639: LD_INT 108
115641: PUSH
115642: LD_INT 109
115644: PUSH
115645: LD_INT 110
115647: PUSH
115648: LD_INT 111
115650: PUSH
115651: LD_INT 112
115653: PUSH
115654: LD_INT 113
115656: PUSH
115657: LD_INT 114
115659: PUSH
115660: LD_INT 116
115662: PUSH
115663: LD_INT 117
115665: PUSH
115666: LD_INT 118
115668: PUSH
115669: EMPTY
115670: LIST
115671: LIST
115672: LIST
115673: LIST
115674: LIST
115675: LIST
115676: LIST
115677: LIST
115678: LIST
115679: LIST
115680: LIST
115681: LIST
115682: LIST
115683: LIST
115684: LIST
115685: LIST
115686: LIST
115687: PUSH
115688: EMPTY
115689: LIST
115690: LIST
115691: ST_TO_ADDR
115692: GO 116699
115694: LD_INT 15
115696: DOUBLE
115697: EQUAL
115698: IFTRUE 115702
115700: GO 115926
115702: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
115703: LD_ADDR_VAR 0 2
115707: PUSH
115708: LD_INT 1
115710: PUSH
115711: LD_INT 2
115713: PUSH
115714: LD_INT 3
115716: PUSH
115717: LD_INT 4
115719: PUSH
115720: LD_INT 5
115722: PUSH
115723: LD_INT 6
115725: PUSH
115726: LD_INT 7
115728: PUSH
115729: LD_INT 8
115731: PUSH
115732: LD_INT 9
115734: PUSH
115735: LD_INT 10
115737: PUSH
115738: LD_INT 11
115740: PUSH
115741: LD_INT 12
115743: PUSH
115744: LD_INT 13
115746: PUSH
115747: LD_INT 14
115749: PUSH
115750: LD_INT 15
115752: PUSH
115753: LD_INT 16
115755: PUSH
115756: LD_INT 17
115758: PUSH
115759: LD_INT 18
115761: PUSH
115762: LD_INT 19
115764: PUSH
115765: LD_INT 20
115767: PUSH
115768: LD_INT 21
115770: PUSH
115771: LD_INT 22
115773: PUSH
115774: LD_INT 23
115776: PUSH
115777: LD_INT 24
115779: PUSH
115780: LD_INT 25
115782: PUSH
115783: LD_INT 26
115785: PUSH
115786: LD_INT 27
115788: PUSH
115789: LD_INT 28
115791: PUSH
115792: LD_INT 29
115794: PUSH
115795: LD_INT 30
115797: PUSH
115798: LD_INT 31
115800: PUSH
115801: LD_INT 32
115803: PUSH
115804: LD_INT 33
115806: PUSH
115807: LD_INT 34
115809: PUSH
115810: LD_INT 36
115812: PUSH
115813: EMPTY
115814: LIST
115815: LIST
115816: LIST
115817: LIST
115818: LIST
115819: LIST
115820: LIST
115821: LIST
115822: LIST
115823: LIST
115824: LIST
115825: LIST
115826: LIST
115827: LIST
115828: LIST
115829: LIST
115830: LIST
115831: LIST
115832: LIST
115833: LIST
115834: LIST
115835: LIST
115836: LIST
115837: LIST
115838: LIST
115839: LIST
115840: LIST
115841: LIST
115842: LIST
115843: LIST
115844: LIST
115845: LIST
115846: LIST
115847: LIST
115848: LIST
115849: PUSH
115850: LD_INT 101
115852: PUSH
115853: LD_INT 102
115855: PUSH
115856: LD_INT 103
115858: PUSH
115859: LD_INT 104
115861: PUSH
115862: LD_INT 105
115864: PUSH
115865: LD_INT 106
115867: PUSH
115868: LD_INT 107
115870: PUSH
115871: LD_INT 108
115873: PUSH
115874: LD_INT 109
115876: PUSH
115877: LD_INT 110
115879: PUSH
115880: LD_INT 111
115882: PUSH
115883: LD_INT 112
115885: PUSH
115886: LD_INT 113
115888: PUSH
115889: LD_INT 114
115891: PUSH
115892: LD_INT 116
115894: PUSH
115895: LD_INT 117
115897: PUSH
115898: LD_INT 118
115900: PUSH
115901: EMPTY
115902: LIST
115903: LIST
115904: LIST
115905: LIST
115906: LIST
115907: LIST
115908: LIST
115909: LIST
115910: LIST
115911: LIST
115912: LIST
115913: LIST
115914: LIST
115915: LIST
115916: LIST
115917: LIST
115918: LIST
115919: PUSH
115920: EMPTY
115921: LIST
115922: LIST
115923: ST_TO_ADDR
115924: GO 116699
115926: LD_INT 16
115928: DOUBLE
115929: EQUAL
115930: IFTRUE 115934
115932: GO 116070
115934: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
115935: LD_ADDR_VAR 0 2
115939: PUSH
115940: LD_INT 2
115942: PUSH
115943: LD_INT 4
115945: PUSH
115946: LD_INT 5
115948: PUSH
115949: LD_INT 7
115951: PUSH
115952: LD_INT 11
115954: PUSH
115955: LD_INT 12
115957: PUSH
115958: LD_INT 15
115960: PUSH
115961: LD_INT 16
115963: PUSH
115964: LD_INT 20
115966: PUSH
115967: LD_INT 21
115969: PUSH
115970: LD_INT 22
115972: PUSH
115973: LD_INT 23
115975: PUSH
115976: LD_INT 25
115978: PUSH
115979: LD_INT 26
115981: PUSH
115982: LD_INT 30
115984: PUSH
115985: LD_INT 31
115987: PUSH
115988: LD_INT 32
115990: PUSH
115991: LD_INT 33
115993: PUSH
115994: LD_INT 34
115996: PUSH
115997: EMPTY
115998: LIST
115999: LIST
116000: LIST
116001: LIST
116002: LIST
116003: LIST
116004: LIST
116005: LIST
116006: LIST
116007: LIST
116008: LIST
116009: LIST
116010: LIST
116011: LIST
116012: LIST
116013: LIST
116014: LIST
116015: LIST
116016: LIST
116017: PUSH
116018: LD_INT 101
116020: PUSH
116021: LD_INT 102
116023: PUSH
116024: LD_INT 103
116026: PUSH
116027: LD_INT 106
116029: PUSH
116030: LD_INT 108
116032: PUSH
116033: LD_INT 112
116035: PUSH
116036: LD_INT 113
116038: PUSH
116039: LD_INT 114
116041: PUSH
116042: LD_INT 116
116044: PUSH
116045: LD_INT 117
116047: PUSH
116048: LD_INT 118
116050: PUSH
116051: EMPTY
116052: LIST
116053: LIST
116054: LIST
116055: LIST
116056: LIST
116057: LIST
116058: LIST
116059: LIST
116060: LIST
116061: LIST
116062: LIST
116063: PUSH
116064: EMPTY
116065: LIST
116066: LIST
116067: ST_TO_ADDR
116068: GO 116699
116070: LD_INT 17
116072: DOUBLE
116073: EQUAL
116074: IFTRUE 116078
116076: GO 116302
116078: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116079: LD_ADDR_VAR 0 2
116083: PUSH
116084: LD_INT 1
116086: PUSH
116087: LD_INT 2
116089: PUSH
116090: LD_INT 3
116092: PUSH
116093: LD_INT 4
116095: PUSH
116096: LD_INT 5
116098: PUSH
116099: LD_INT 6
116101: PUSH
116102: LD_INT 7
116104: PUSH
116105: LD_INT 8
116107: PUSH
116108: LD_INT 9
116110: PUSH
116111: LD_INT 10
116113: PUSH
116114: LD_INT 11
116116: PUSH
116117: LD_INT 12
116119: PUSH
116120: LD_INT 13
116122: PUSH
116123: LD_INT 14
116125: PUSH
116126: LD_INT 15
116128: PUSH
116129: LD_INT 16
116131: PUSH
116132: LD_INT 17
116134: PUSH
116135: LD_INT 18
116137: PUSH
116138: LD_INT 19
116140: PUSH
116141: LD_INT 20
116143: PUSH
116144: LD_INT 21
116146: PUSH
116147: LD_INT 22
116149: PUSH
116150: LD_INT 23
116152: PUSH
116153: LD_INT 24
116155: PUSH
116156: LD_INT 25
116158: PUSH
116159: LD_INT 26
116161: PUSH
116162: LD_INT 27
116164: PUSH
116165: LD_INT 28
116167: PUSH
116168: LD_INT 29
116170: PUSH
116171: LD_INT 30
116173: PUSH
116174: LD_INT 31
116176: PUSH
116177: LD_INT 32
116179: PUSH
116180: LD_INT 33
116182: PUSH
116183: LD_INT 34
116185: PUSH
116186: LD_INT 36
116188: PUSH
116189: EMPTY
116190: LIST
116191: LIST
116192: LIST
116193: LIST
116194: LIST
116195: LIST
116196: LIST
116197: LIST
116198: LIST
116199: LIST
116200: LIST
116201: LIST
116202: LIST
116203: LIST
116204: LIST
116205: LIST
116206: LIST
116207: LIST
116208: LIST
116209: LIST
116210: LIST
116211: LIST
116212: LIST
116213: LIST
116214: LIST
116215: LIST
116216: LIST
116217: LIST
116218: LIST
116219: LIST
116220: LIST
116221: LIST
116222: LIST
116223: LIST
116224: LIST
116225: PUSH
116226: LD_INT 101
116228: PUSH
116229: LD_INT 102
116231: PUSH
116232: LD_INT 103
116234: PUSH
116235: LD_INT 104
116237: PUSH
116238: LD_INT 105
116240: PUSH
116241: LD_INT 106
116243: PUSH
116244: LD_INT 107
116246: PUSH
116247: LD_INT 108
116249: PUSH
116250: LD_INT 109
116252: PUSH
116253: LD_INT 110
116255: PUSH
116256: LD_INT 111
116258: PUSH
116259: LD_INT 112
116261: PUSH
116262: LD_INT 113
116264: PUSH
116265: LD_INT 114
116267: PUSH
116268: LD_INT 116
116270: PUSH
116271: LD_INT 117
116273: PUSH
116274: LD_INT 118
116276: PUSH
116277: EMPTY
116278: LIST
116279: LIST
116280: LIST
116281: LIST
116282: LIST
116283: LIST
116284: LIST
116285: LIST
116286: LIST
116287: LIST
116288: LIST
116289: LIST
116290: LIST
116291: LIST
116292: LIST
116293: LIST
116294: LIST
116295: PUSH
116296: EMPTY
116297: LIST
116298: LIST
116299: ST_TO_ADDR
116300: GO 116699
116302: LD_INT 18
116304: DOUBLE
116305: EQUAL
116306: IFTRUE 116310
116308: GO 116458
116310: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
116311: LD_ADDR_VAR 0 2
116315: PUSH
116316: LD_INT 2
116318: PUSH
116319: LD_INT 4
116321: PUSH
116322: LD_INT 5
116324: PUSH
116325: LD_INT 7
116327: PUSH
116328: LD_INT 11
116330: PUSH
116331: LD_INT 12
116333: PUSH
116334: LD_INT 15
116336: PUSH
116337: LD_INT 16
116339: PUSH
116340: LD_INT 20
116342: PUSH
116343: LD_INT 21
116345: PUSH
116346: LD_INT 22
116348: PUSH
116349: LD_INT 23
116351: PUSH
116352: LD_INT 25
116354: PUSH
116355: LD_INT 26
116357: PUSH
116358: LD_INT 30
116360: PUSH
116361: LD_INT 31
116363: PUSH
116364: LD_INT 32
116366: PUSH
116367: LD_INT 33
116369: PUSH
116370: LD_INT 34
116372: PUSH
116373: LD_INT 35
116375: PUSH
116376: LD_INT 36
116378: PUSH
116379: EMPTY
116380: LIST
116381: LIST
116382: LIST
116383: LIST
116384: LIST
116385: LIST
116386: LIST
116387: LIST
116388: LIST
116389: LIST
116390: LIST
116391: LIST
116392: LIST
116393: LIST
116394: LIST
116395: LIST
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: PUSH
116402: LD_INT 101
116404: PUSH
116405: LD_INT 102
116407: PUSH
116408: LD_INT 103
116410: PUSH
116411: LD_INT 106
116413: PUSH
116414: LD_INT 108
116416: PUSH
116417: LD_INT 112
116419: PUSH
116420: LD_INT 113
116422: PUSH
116423: LD_INT 114
116425: PUSH
116426: LD_INT 115
116428: PUSH
116429: LD_INT 116
116431: PUSH
116432: LD_INT 117
116434: PUSH
116435: LD_INT 118
116437: PUSH
116438: EMPTY
116439: LIST
116440: LIST
116441: LIST
116442: LIST
116443: LIST
116444: LIST
116445: LIST
116446: LIST
116447: LIST
116448: LIST
116449: LIST
116450: LIST
116451: PUSH
116452: EMPTY
116453: LIST
116454: LIST
116455: ST_TO_ADDR
116456: GO 116699
116458: LD_INT 19
116460: DOUBLE
116461: EQUAL
116462: IFTRUE 116466
116464: GO 116698
116466: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
116467: LD_ADDR_VAR 0 2
116471: PUSH
116472: LD_INT 1
116474: PUSH
116475: LD_INT 2
116477: PUSH
116478: LD_INT 3
116480: PUSH
116481: LD_INT 4
116483: PUSH
116484: LD_INT 5
116486: PUSH
116487: LD_INT 6
116489: PUSH
116490: LD_INT 7
116492: PUSH
116493: LD_INT 8
116495: PUSH
116496: LD_INT 9
116498: PUSH
116499: LD_INT 10
116501: PUSH
116502: LD_INT 11
116504: PUSH
116505: LD_INT 12
116507: PUSH
116508: LD_INT 13
116510: PUSH
116511: LD_INT 14
116513: PUSH
116514: LD_INT 15
116516: PUSH
116517: LD_INT 16
116519: PUSH
116520: LD_INT 17
116522: PUSH
116523: LD_INT 18
116525: PUSH
116526: LD_INT 19
116528: PUSH
116529: LD_INT 20
116531: PUSH
116532: LD_INT 21
116534: PUSH
116535: LD_INT 22
116537: PUSH
116538: LD_INT 23
116540: PUSH
116541: LD_INT 24
116543: PUSH
116544: LD_INT 25
116546: PUSH
116547: LD_INT 26
116549: PUSH
116550: LD_INT 27
116552: PUSH
116553: LD_INT 28
116555: PUSH
116556: LD_INT 29
116558: PUSH
116559: LD_INT 30
116561: PUSH
116562: LD_INT 31
116564: PUSH
116565: LD_INT 32
116567: PUSH
116568: LD_INT 33
116570: PUSH
116571: LD_INT 34
116573: PUSH
116574: LD_INT 35
116576: PUSH
116577: LD_INT 36
116579: PUSH
116580: EMPTY
116581: LIST
116582: LIST
116583: LIST
116584: LIST
116585: LIST
116586: LIST
116587: LIST
116588: LIST
116589: LIST
116590: LIST
116591: LIST
116592: LIST
116593: LIST
116594: LIST
116595: LIST
116596: LIST
116597: LIST
116598: LIST
116599: LIST
116600: LIST
116601: LIST
116602: LIST
116603: LIST
116604: LIST
116605: LIST
116606: LIST
116607: LIST
116608: LIST
116609: LIST
116610: LIST
116611: LIST
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: PUSH
116618: LD_INT 101
116620: PUSH
116621: LD_INT 102
116623: PUSH
116624: LD_INT 103
116626: PUSH
116627: LD_INT 104
116629: PUSH
116630: LD_INT 105
116632: PUSH
116633: LD_INT 106
116635: PUSH
116636: LD_INT 107
116638: PUSH
116639: LD_INT 108
116641: PUSH
116642: LD_INT 109
116644: PUSH
116645: LD_INT 110
116647: PUSH
116648: LD_INT 111
116650: PUSH
116651: LD_INT 112
116653: PUSH
116654: LD_INT 113
116656: PUSH
116657: LD_INT 114
116659: PUSH
116660: LD_INT 115
116662: PUSH
116663: LD_INT 116
116665: PUSH
116666: LD_INT 117
116668: PUSH
116669: LD_INT 118
116671: PUSH
116672: EMPTY
116673: LIST
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: LIST
116679: LIST
116680: LIST
116681: LIST
116682: LIST
116683: LIST
116684: LIST
116685: LIST
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: PUSH
116692: EMPTY
116693: LIST
116694: LIST
116695: ST_TO_ADDR
116696: GO 116699
116698: POP
// end else
116699: GO 116930
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
116701: LD_ADDR_VAR 0 2
116705: PUSH
116706: LD_INT 1
116708: PUSH
116709: LD_INT 2
116711: PUSH
116712: LD_INT 3
116714: PUSH
116715: LD_INT 4
116717: PUSH
116718: LD_INT 5
116720: PUSH
116721: LD_INT 6
116723: PUSH
116724: LD_INT 7
116726: PUSH
116727: LD_INT 8
116729: PUSH
116730: LD_INT 9
116732: PUSH
116733: LD_INT 10
116735: PUSH
116736: LD_INT 11
116738: PUSH
116739: LD_INT 12
116741: PUSH
116742: LD_INT 13
116744: PUSH
116745: LD_INT 14
116747: PUSH
116748: LD_INT 15
116750: PUSH
116751: LD_INT 16
116753: PUSH
116754: LD_INT 17
116756: PUSH
116757: LD_INT 18
116759: PUSH
116760: LD_INT 19
116762: PUSH
116763: LD_INT 20
116765: PUSH
116766: LD_INT 21
116768: PUSH
116769: LD_INT 22
116771: PUSH
116772: LD_INT 23
116774: PUSH
116775: LD_INT 24
116777: PUSH
116778: LD_INT 25
116780: PUSH
116781: LD_INT 26
116783: PUSH
116784: LD_INT 27
116786: PUSH
116787: LD_INT 28
116789: PUSH
116790: LD_INT 29
116792: PUSH
116793: LD_INT 30
116795: PUSH
116796: LD_INT 31
116798: PUSH
116799: LD_INT 32
116801: PUSH
116802: LD_INT 33
116804: PUSH
116805: LD_INT 34
116807: PUSH
116808: LD_INT 35
116810: PUSH
116811: LD_INT 36
116813: PUSH
116814: EMPTY
116815: LIST
116816: LIST
116817: LIST
116818: LIST
116819: LIST
116820: LIST
116821: LIST
116822: LIST
116823: LIST
116824: LIST
116825: LIST
116826: LIST
116827: LIST
116828: LIST
116829: LIST
116830: LIST
116831: LIST
116832: LIST
116833: LIST
116834: LIST
116835: LIST
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: LIST
116847: LIST
116848: LIST
116849: LIST
116850: LIST
116851: PUSH
116852: LD_INT 101
116854: PUSH
116855: LD_INT 102
116857: PUSH
116858: LD_INT 103
116860: PUSH
116861: LD_INT 104
116863: PUSH
116864: LD_INT 105
116866: PUSH
116867: LD_INT 106
116869: PUSH
116870: LD_INT 107
116872: PUSH
116873: LD_INT 108
116875: PUSH
116876: LD_INT 109
116878: PUSH
116879: LD_INT 110
116881: PUSH
116882: LD_INT 111
116884: PUSH
116885: LD_INT 112
116887: PUSH
116888: LD_INT 113
116890: PUSH
116891: LD_INT 114
116893: PUSH
116894: LD_INT 115
116896: PUSH
116897: LD_INT 116
116899: PUSH
116900: LD_INT 117
116902: PUSH
116903: LD_INT 118
116905: PUSH
116906: EMPTY
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: LIST
116912: LIST
116913: LIST
116914: LIST
116915: LIST
116916: LIST
116917: LIST
116918: LIST
116919: LIST
116920: LIST
116921: LIST
116922: LIST
116923: LIST
116924: LIST
116925: PUSH
116926: EMPTY
116927: LIST
116928: LIST
116929: ST_TO_ADDR
// if result then
116930: LD_VAR 0 2
116934: IFFALSE 117720
// begin normal :=  ;
116936: LD_ADDR_VAR 0 5
116940: PUSH
116941: LD_STRING 
116943: ST_TO_ADDR
// hardcore :=  ;
116944: LD_ADDR_VAR 0 6
116948: PUSH
116949: LD_STRING 
116951: ST_TO_ADDR
// active :=  ;
116952: LD_ADDR_VAR 0 7
116956: PUSH
116957: LD_STRING 
116959: ST_TO_ADDR
// for i = 1 to normalCounter do
116960: LD_ADDR_VAR 0 8
116964: PUSH
116965: DOUBLE
116966: LD_INT 1
116968: DEC
116969: ST_TO_ADDR
116970: LD_EXP 148
116974: PUSH
116975: FOR_TO
116976: IFFALSE 117077
// begin tmp := 0 ;
116978: LD_ADDR_VAR 0 3
116982: PUSH
116983: LD_STRING 0
116985: ST_TO_ADDR
// if result [ 1 ] then
116986: LD_VAR 0 2
116990: PUSH
116991: LD_INT 1
116993: ARRAY
116994: IFFALSE 117059
// if result [ 1 ] [ 1 ] = i then
116996: LD_VAR 0 2
117000: PUSH
117001: LD_INT 1
117003: ARRAY
117004: PUSH
117005: LD_INT 1
117007: ARRAY
117008: PUSH
117009: LD_VAR 0 8
117013: EQUAL
117014: IFFALSE 117059
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117016: LD_ADDR_VAR 0 2
117020: PUSH
117021: LD_VAR 0 2
117025: PPUSH
117026: LD_INT 1
117028: PPUSH
117029: LD_VAR 0 2
117033: PUSH
117034: LD_INT 1
117036: ARRAY
117037: PPUSH
117038: LD_INT 1
117040: PPUSH
117041: CALL_OW 3
117045: PPUSH
117046: CALL_OW 1
117050: ST_TO_ADDR
// tmp := 1 ;
117051: LD_ADDR_VAR 0 3
117055: PUSH
117056: LD_STRING 1
117058: ST_TO_ADDR
// end ; normal := normal & tmp ;
117059: LD_ADDR_VAR 0 5
117063: PUSH
117064: LD_VAR 0 5
117068: PUSH
117069: LD_VAR 0 3
117073: STR
117074: ST_TO_ADDR
// end ;
117075: GO 116975
117077: POP
117078: POP
// for i = 1 to hardcoreCounter do
117079: LD_ADDR_VAR 0 8
117083: PUSH
117084: DOUBLE
117085: LD_INT 1
117087: DEC
117088: ST_TO_ADDR
117089: LD_EXP 149
117093: PUSH
117094: FOR_TO
117095: IFFALSE 117200
// begin tmp := 0 ;
117097: LD_ADDR_VAR 0 3
117101: PUSH
117102: LD_STRING 0
117104: ST_TO_ADDR
// if result [ 2 ] then
117105: LD_VAR 0 2
117109: PUSH
117110: LD_INT 2
117112: ARRAY
117113: IFFALSE 117182
// if result [ 2 ] [ 1 ] = 100 + i then
117115: LD_VAR 0 2
117119: PUSH
117120: LD_INT 2
117122: ARRAY
117123: PUSH
117124: LD_INT 1
117126: ARRAY
117127: PUSH
117128: LD_INT 100
117130: PUSH
117131: LD_VAR 0 8
117135: PLUS
117136: EQUAL
117137: IFFALSE 117182
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117139: LD_ADDR_VAR 0 2
117143: PUSH
117144: LD_VAR 0 2
117148: PPUSH
117149: LD_INT 2
117151: PPUSH
117152: LD_VAR 0 2
117156: PUSH
117157: LD_INT 2
117159: ARRAY
117160: PPUSH
117161: LD_INT 1
117163: PPUSH
117164: CALL_OW 3
117168: PPUSH
117169: CALL_OW 1
117173: ST_TO_ADDR
// tmp := 1 ;
117174: LD_ADDR_VAR 0 3
117178: PUSH
117179: LD_STRING 1
117181: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
117182: LD_ADDR_VAR 0 6
117186: PUSH
117187: LD_VAR 0 6
117191: PUSH
117192: LD_VAR 0 3
117196: STR
117197: ST_TO_ADDR
// end ;
117198: GO 117094
117200: POP
117201: POP
// if isGameLoad then
117202: LD_VAR 0 1
117206: IFFALSE 117681
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
117208: LD_ADDR_VAR 0 4
117212: PUSH
117213: LD_EXP 152
117217: PUSH
117218: LD_EXP 151
117222: PUSH
117223: LD_EXP 153
117227: PUSH
117228: LD_EXP 150
117232: PUSH
117233: LD_EXP 154
117237: PUSH
117238: LD_EXP 155
117242: PUSH
117243: LD_EXP 156
117247: PUSH
117248: LD_EXP 157
117252: PUSH
117253: LD_EXP 158
117257: PUSH
117258: LD_EXP 159
117262: PUSH
117263: LD_EXP 160
117267: PUSH
117268: LD_EXP 161
117272: PUSH
117273: LD_EXP 162
117277: PUSH
117278: LD_EXP 163
117282: PUSH
117283: LD_EXP 171
117287: PUSH
117288: LD_EXP 172
117292: PUSH
117293: LD_EXP 173
117297: PUSH
117298: LD_EXP 174
117302: PUSH
117303: LD_EXP 176
117307: PUSH
117308: LD_EXP 177
117312: PUSH
117313: LD_EXP 178
117317: PUSH
117318: LD_EXP 181
117322: PUSH
117323: LD_EXP 183
117327: PUSH
117328: LD_EXP 184
117332: PUSH
117333: LD_EXP 185
117337: PUSH
117338: LD_EXP 187
117342: PUSH
117343: LD_EXP 188
117347: PUSH
117348: LD_EXP 191
117352: PUSH
117353: LD_EXP 192
117357: PUSH
117358: LD_EXP 193
117362: PUSH
117363: LD_EXP 194
117367: PUSH
117368: LD_EXP 195
117372: PUSH
117373: LD_EXP 196
117377: PUSH
117378: LD_EXP 197
117382: PUSH
117383: LD_EXP 198
117387: PUSH
117388: LD_EXP 199
117392: PUSH
117393: LD_EXP 164
117397: PUSH
117398: LD_EXP 165
117402: PUSH
117403: LD_EXP 168
117407: PUSH
117408: LD_EXP 169
117412: PUSH
117413: LD_EXP 170
117417: PUSH
117418: LD_EXP 166
117422: PUSH
117423: LD_EXP 167
117427: PUSH
117428: LD_EXP 175
117432: PUSH
117433: LD_EXP 179
117437: PUSH
117438: LD_EXP 180
117442: PUSH
117443: LD_EXP 182
117447: PUSH
117448: LD_EXP 186
117452: PUSH
117453: LD_EXP 189
117457: PUSH
117458: LD_EXP 190
117462: PUSH
117463: LD_EXP 200
117467: PUSH
117468: LD_EXP 201
117472: PUSH
117473: LD_EXP 202
117477: PUSH
117478: LD_EXP 203
117482: PUSH
117483: EMPTY
117484: LIST
117485: LIST
117486: LIST
117487: LIST
117488: LIST
117489: LIST
117490: LIST
117491: LIST
117492: LIST
117493: LIST
117494: LIST
117495: LIST
117496: LIST
117497: LIST
117498: LIST
117499: LIST
117500: LIST
117501: LIST
117502: LIST
117503: LIST
117504: LIST
117505: LIST
117506: LIST
117507: LIST
117508: LIST
117509: LIST
117510: LIST
117511: LIST
117512: LIST
117513: LIST
117514: LIST
117515: LIST
117516: LIST
117517: LIST
117518: LIST
117519: LIST
117520: LIST
117521: LIST
117522: LIST
117523: LIST
117524: LIST
117525: LIST
117526: LIST
117527: LIST
117528: LIST
117529: LIST
117530: LIST
117531: LIST
117532: LIST
117533: LIST
117534: LIST
117535: LIST
117536: LIST
117537: LIST
117538: ST_TO_ADDR
// tmp :=  ;
117539: LD_ADDR_VAR 0 3
117543: PUSH
117544: LD_STRING 
117546: ST_TO_ADDR
// for i = 1 to normalCounter do
117547: LD_ADDR_VAR 0 8
117551: PUSH
117552: DOUBLE
117553: LD_INT 1
117555: DEC
117556: ST_TO_ADDR
117557: LD_EXP 148
117561: PUSH
117562: FOR_TO
117563: IFFALSE 117599
// begin if flags [ i ] then
117565: LD_VAR 0 4
117569: PUSH
117570: LD_VAR 0 8
117574: ARRAY
117575: IFFALSE 117597
// tmp := tmp & i & ; ;
117577: LD_ADDR_VAR 0 3
117581: PUSH
117582: LD_VAR 0 3
117586: PUSH
117587: LD_VAR 0 8
117591: STR
117592: PUSH
117593: LD_STRING ;
117595: STR
117596: ST_TO_ADDR
// end ;
117597: GO 117562
117599: POP
117600: POP
// for i = 1 to hardcoreCounter do
117601: LD_ADDR_VAR 0 8
117605: PUSH
117606: DOUBLE
117607: LD_INT 1
117609: DEC
117610: ST_TO_ADDR
117611: LD_EXP 149
117615: PUSH
117616: FOR_TO
117617: IFFALSE 117663
// begin if flags [ normalCounter + i ] then
117619: LD_VAR 0 4
117623: PUSH
117624: LD_EXP 148
117628: PUSH
117629: LD_VAR 0 8
117633: PLUS
117634: ARRAY
117635: IFFALSE 117661
// tmp := tmp & ( 100 + i ) & ; ;
117637: LD_ADDR_VAR 0 3
117641: PUSH
117642: LD_VAR 0 3
117646: PUSH
117647: LD_INT 100
117649: PUSH
117650: LD_VAR 0 8
117654: PLUS
117655: STR
117656: PUSH
117657: LD_STRING ;
117659: STR
117660: ST_TO_ADDR
// end ;
117661: GO 117616
117663: POP
117664: POP
// if tmp then
117665: LD_VAR 0 3
117669: IFFALSE 117681
// active := tmp ;
117671: LD_ADDR_VAR 0 7
117675: PUSH
117676: LD_VAR 0 3
117680: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
117681: LD_STRING getStreamItemsFromMission("
117683: PUSH
117684: LD_VAR 0 5
117688: STR
117689: PUSH
117690: LD_STRING ","
117692: STR
117693: PUSH
117694: LD_VAR 0 6
117698: STR
117699: PUSH
117700: LD_STRING ","
117702: STR
117703: PUSH
117704: LD_VAR 0 7
117708: STR
117709: PUSH
117710: LD_STRING ")
117712: STR
117713: PPUSH
117714: CALL_OW 559
// end else
117718: GO 117727
// ToLua ( getStreamItemsFromMission("","","") ) ;
117720: LD_STRING getStreamItemsFromMission("","","")
117722: PPUSH
117723: CALL_OW 559
// end ;
117727: LD_VAR 0 2
117731: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
117732: LD_EXP 147
117736: PUSH
117737: LD_EXP 152
117741: AND
117742: IFFALSE 117866
117744: GO 117746
117746: DISABLE
117747: LD_INT 0
117749: PPUSH
117750: PPUSH
// begin enable ;
117751: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
117752: LD_ADDR_VAR 0 2
117756: PUSH
117757: LD_INT 22
117759: PUSH
117760: LD_OWVAR 2
117764: PUSH
117765: EMPTY
117766: LIST
117767: LIST
117768: PUSH
117769: LD_INT 2
117771: PUSH
117772: LD_INT 34
117774: PUSH
117775: LD_INT 7
117777: PUSH
117778: EMPTY
117779: LIST
117780: LIST
117781: PUSH
117782: LD_INT 34
117784: PUSH
117785: LD_INT 45
117787: PUSH
117788: EMPTY
117789: LIST
117790: LIST
117791: PUSH
117792: LD_INT 34
117794: PUSH
117795: LD_INT 28
117797: PUSH
117798: EMPTY
117799: LIST
117800: LIST
117801: PUSH
117802: LD_INT 34
117804: PUSH
117805: LD_INT 47
117807: PUSH
117808: EMPTY
117809: LIST
117810: LIST
117811: PUSH
117812: EMPTY
117813: LIST
117814: LIST
117815: LIST
117816: LIST
117817: LIST
117818: PUSH
117819: EMPTY
117820: LIST
117821: LIST
117822: PPUSH
117823: CALL_OW 69
117827: ST_TO_ADDR
// if not tmp then
117828: LD_VAR 0 2
117832: NOT
117833: IFFALSE 117837
// exit ;
117835: GO 117866
// for i in tmp do
117837: LD_ADDR_VAR 0 1
117841: PUSH
117842: LD_VAR 0 2
117846: PUSH
117847: FOR_IN
117848: IFFALSE 117864
// begin SetLives ( i , 0 ) ;
117850: LD_VAR 0 1
117854: PPUSH
117855: LD_INT 0
117857: PPUSH
117858: CALL_OW 234
// end ;
117862: GO 117847
117864: POP
117865: POP
// end ;
117866: PPOPN 2
117868: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
117869: LD_EXP 147
117873: PUSH
117874: LD_EXP 153
117878: AND
117879: IFFALSE 117963
117881: GO 117883
117883: DISABLE
117884: LD_INT 0
117886: PPUSH
117887: PPUSH
// begin enable ;
117888: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
117889: LD_ADDR_VAR 0 2
117893: PUSH
117894: LD_INT 22
117896: PUSH
117897: LD_OWVAR 2
117901: PUSH
117902: EMPTY
117903: LIST
117904: LIST
117905: PUSH
117906: LD_INT 32
117908: PUSH
117909: LD_INT 3
117911: PUSH
117912: EMPTY
117913: LIST
117914: LIST
117915: PUSH
117916: EMPTY
117917: LIST
117918: LIST
117919: PPUSH
117920: CALL_OW 69
117924: ST_TO_ADDR
// if not tmp then
117925: LD_VAR 0 2
117929: NOT
117930: IFFALSE 117934
// exit ;
117932: GO 117963
// for i in tmp do
117934: LD_ADDR_VAR 0 1
117938: PUSH
117939: LD_VAR 0 2
117943: PUSH
117944: FOR_IN
117945: IFFALSE 117961
// begin SetLives ( i , 0 ) ;
117947: LD_VAR 0 1
117951: PPUSH
117952: LD_INT 0
117954: PPUSH
117955: CALL_OW 234
// end ;
117959: GO 117944
117961: POP
117962: POP
// end ;
117963: PPOPN 2
117965: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
117966: LD_EXP 147
117970: PUSH
117971: LD_EXP 150
117975: AND
117976: IFFALSE 118069
117978: GO 117980
117980: DISABLE
117981: LD_INT 0
117983: PPUSH
// begin enable ;
117984: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
117985: LD_ADDR_VAR 0 1
117989: PUSH
117990: LD_INT 22
117992: PUSH
117993: LD_OWVAR 2
117997: PUSH
117998: EMPTY
117999: LIST
118000: LIST
118001: PUSH
118002: LD_INT 2
118004: PUSH
118005: LD_INT 25
118007: PUSH
118008: LD_INT 5
118010: PUSH
118011: EMPTY
118012: LIST
118013: LIST
118014: PUSH
118015: LD_INT 25
118017: PUSH
118018: LD_INT 9
118020: PUSH
118021: EMPTY
118022: LIST
118023: LIST
118024: PUSH
118025: LD_INT 25
118027: PUSH
118028: LD_INT 8
118030: PUSH
118031: EMPTY
118032: LIST
118033: LIST
118034: PUSH
118035: EMPTY
118036: LIST
118037: LIST
118038: LIST
118039: LIST
118040: PUSH
118041: EMPTY
118042: LIST
118043: LIST
118044: PPUSH
118045: CALL_OW 69
118049: PUSH
118050: FOR_IN
118051: IFFALSE 118067
// begin SetClass ( i , 1 ) ;
118053: LD_VAR 0 1
118057: PPUSH
118058: LD_INT 1
118060: PPUSH
118061: CALL_OW 336
// end ;
118065: GO 118050
118067: POP
118068: POP
// end ;
118069: PPOPN 1
118071: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118072: LD_EXP 147
118076: PUSH
118077: LD_EXP 151
118081: AND
118082: PUSH
118083: LD_OWVAR 65
118087: PUSH
118088: LD_INT 7
118090: LESS
118091: AND
118092: IFFALSE 118106
118094: GO 118096
118096: DISABLE
// begin enable ;
118097: ENABLE
// game_speed := 7 ;
118098: LD_ADDR_OWVAR 65
118102: PUSH
118103: LD_INT 7
118105: ST_TO_ADDR
// end ;
118106: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118107: LD_EXP 147
118111: PUSH
118112: LD_EXP 154
118116: AND
118117: IFFALSE 118319
118119: GO 118121
118121: DISABLE
118122: LD_INT 0
118124: PPUSH
118125: PPUSH
118126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118127: LD_ADDR_VAR 0 3
118131: PUSH
118132: LD_INT 81
118134: PUSH
118135: LD_OWVAR 2
118139: PUSH
118140: EMPTY
118141: LIST
118142: LIST
118143: PUSH
118144: LD_INT 21
118146: PUSH
118147: LD_INT 1
118149: PUSH
118150: EMPTY
118151: LIST
118152: LIST
118153: PUSH
118154: EMPTY
118155: LIST
118156: LIST
118157: PPUSH
118158: CALL_OW 69
118162: ST_TO_ADDR
// if not tmp then
118163: LD_VAR 0 3
118167: NOT
118168: IFFALSE 118172
// exit ;
118170: GO 118319
// if tmp > 5 then
118172: LD_VAR 0 3
118176: PUSH
118177: LD_INT 5
118179: GREATER
118180: IFFALSE 118192
// k := 5 else
118182: LD_ADDR_VAR 0 2
118186: PUSH
118187: LD_INT 5
118189: ST_TO_ADDR
118190: GO 118202
// k := tmp ;
118192: LD_ADDR_VAR 0 2
118196: PUSH
118197: LD_VAR 0 3
118201: ST_TO_ADDR
// for i := 1 to k do
118202: LD_ADDR_VAR 0 1
118206: PUSH
118207: DOUBLE
118208: LD_INT 1
118210: DEC
118211: ST_TO_ADDR
118212: LD_VAR 0 2
118216: PUSH
118217: FOR_TO
118218: IFFALSE 118317
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
118220: LD_VAR 0 3
118224: PUSH
118225: LD_VAR 0 1
118229: ARRAY
118230: PPUSH
118231: LD_VAR 0 1
118235: PUSH
118236: LD_INT 4
118238: MOD
118239: PUSH
118240: LD_INT 1
118242: PLUS
118243: PPUSH
118244: CALL_OW 259
118248: PUSH
118249: LD_INT 10
118251: LESS
118252: IFFALSE 118315
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
118254: LD_VAR 0 3
118258: PUSH
118259: LD_VAR 0 1
118263: ARRAY
118264: PPUSH
118265: LD_VAR 0 1
118269: PUSH
118270: LD_INT 4
118272: MOD
118273: PUSH
118274: LD_INT 1
118276: PLUS
118277: PPUSH
118278: LD_VAR 0 3
118282: PUSH
118283: LD_VAR 0 1
118287: ARRAY
118288: PPUSH
118289: LD_VAR 0 1
118293: PUSH
118294: LD_INT 4
118296: MOD
118297: PUSH
118298: LD_INT 1
118300: PLUS
118301: PPUSH
118302: CALL_OW 259
118306: PUSH
118307: LD_INT 1
118309: PLUS
118310: PPUSH
118311: CALL_OW 237
118315: GO 118217
118317: POP
118318: POP
// end ;
118319: PPOPN 3
118321: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
118322: LD_EXP 147
118326: PUSH
118327: LD_EXP 155
118331: AND
118332: IFFALSE 118352
118334: GO 118336
118336: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
118337: LD_INT 4
118339: PPUSH
118340: LD_OWVAR 2
118344: PPUSH
118345: LD_INT 0
118347: PPUSH
118348: CALL_OW 324
118352: END
// every 0 0$1 trigger StreamModeActive and sShovel do
118353: LD_EXP 147
118357: PUSH
118358: LD_EXP 184
118362: AND
118363: IFFALSE 118383
118365: GO 118367
118367: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
118368: LD_INT 19
118370: PPUSH
118371: LD_OWVAR 2
118375: PPUSH
118376: LD_INT 0
118378: PPUSH
118379: CALL_OW 324
118383: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
118384: LD_EXP 147
118388: PUSH
118389: LD_EXP 156
118393: AND
118394: IFFALSE 118496
118396: GO 118398
118398: DISABLE
118399: LD_INT 0
118401: PPUSH
118402: PPUSH
// begin enable ;
118403: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
118404: LD_ADDR_VAR 0 2
118408: PUSH
118409: LD_INT 22
118411: PUSH
118412: LD_OWVAR 2
118416: PUSH
118417: EMPTY
118418: LIST
118419: LIST
118420: PUSH
118421: LD_INT 2
118423: PUSH
118424: LD_INT 34
118426: PUSH
118427: LD_INT 11
118429: PUSH
118430: EMPTY
118431: LIST
118432: LIST
118433: PUSH
118434: LD_INT 34
118436: PUSH
118437: LD_INT 30
118439: PUSH
118440: EMPTY
118441: LIST
118442: LIST
118443: PUSH
118444: EMPTY
118445: LIST
118446: LIST
118447: LIST
118448: PUSH
118449: EMPTY
118450: LIST
118451: LIST
118452: PPUSH
118453: CALL_OW 69
118457: ST_TO_ADDR
// if not tmp then
118458: LD_VAR 0 2
118462: NOT
118463: IFFALSE 118467
// exit ;
118465: GO 118496
// for i in tmp do
118467: LD_ADDR_VAR 0 1
118471: PUSH
118472: LD_VAR 0 2
118476: PUSH
118477: FOR_IN
118478: IFFALSE 118494
// begin SetLives ( i , 0 ) ;
118480: LD_VAR 0 1
118484: PPUSH
118485: LD_INT 0
118487: PPUSH
118488: CALL_OW 234
// end ;
118492: GO 118477
118494: POP
118495: POP
// end ;
118496: PPOPN 2
118498: END
// every 0 0$1 trigger StreamModeActive and sBunker do
118499: LD_EXP 147
118503: PUSH
118504: LD_EXP 157
118508: AND
118509: IFFALSE 118529
118511: GO 118513
118513: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
118514: LD_INT 32
118516: PPUSH
118517: LD_OWVAR 2
118521: PPUSH
118522: LD_INT 0
118524: PPUSH
118525: CALL_OW 324
118529: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
118530: LD_EXP 147
118534: PUSH
118535: LD_EXP 158
118539: AND
118540: IFFALSE 118721
118542: GO 118544
118544: DISABLE
118545: LD_INT 0
118547: PPUSH
118548: PPUSH
118549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
118550: LD_ADDR_VAR 0 2
118554: PUSH
118555: LD_INT 22
118557: PUSH
118558: LD_OWVAR 2
118562: PUSH
118563: EMPTY
118564: LIST
118565: LIST
118566: PUSH
118567: LD_INT 33
118569: PUSH
118570: LD_INT 3
118572: PUSH
118573: EMPTY
118574: LIST
118575: LIST
118576: PUSH
118577: EMPTY
118578: LIST
118579: LIST
118580: PPUSH
118581: CALL_OW 69
118585: ST_TO_ADDR
// if not tmp then
118586: LD_VAR 0 2
118590: NOT
118591: IFFALSE 118595
// exit ;
118593: GO 118721
// side := 0 ;
118595: LD_ADDR_VAR 0 3
118599: PUSH
118600: LD_INT 0
118602: ST_TO_ADDR
// for i := 1 to 8 do
118603: LD_ADDR_VAR 0 1
118607: PUSH
118608: DOUBLE
118609: LD_INT 1
118611: DEC
118612: ST_TO_ADDR
118613: LD_INT 8
118615: PUSH
118616: FOR_TO
118617: IFFALSE 118665
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
118619: LD_OWVAR 2
118623: PUSH
118624: LD_VAR 0 1
118628: NONEQUAL
118629: PUSH
118630: LD_OWVAR 2
118634: PPUSH
118635: LD_VAR 0 1
118639: PPUSH
118640: CALL_OW 81
118644: PUSH
118645: LD_INT 2
118647: EQUAL
118648: AND
118649: IFFALSE 118663
// begin side := i ;
118651: LD_ADDR_VAR 0 3
118655: PUSH
118656: LD_VAR 0 1
118660: ST_TO_ADDR
// break ;
118661: GO 118665
// end ;
118663: GO 118616
118665: POP
118666: POP
// if not side then
118667: LD_VAR 0 3
118671: NOT
118672: IFFALSE 118676
// exit ;
118674: GO 118721
// for i := 1 to tmp do
118676: LD_ADDR_VAR 0 1
118680: PUSH
118681: DOUBLE
118682: LD_INT 1
118684: DEC
118685: ST_TO_ADDR
118686: LD_VAR 0 2
118690: PUSH
118691: FOR_TO
118692: IFFALSE 118719
// if Prob ( 60 ) then
118694: LD_INT 60
118696: PPUSH
118697: CALL_OW 13
118701: IFFALSE 118717
// SetSide ( i , side ) ;
118703: LD_VAR 0 1
118707: PPUSH
118708: LD_VAR 0 3
118712: PPUSH
118713: CALL_OW 235
118717: GO 118691
118719: POP
118720: POP
// end ;
118721: PPOPN 3
118723: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
118724: LD_EXP 147
118728: PUSH
118729: LD_EXP 160
118733: AND
118734: IFFALSE 118853
118736: GO 118738
118738: DISABLE
118739: LD_INT 0
118741: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
118742: LD_ADDR_VAR 0 1
118746: PUSH
118747: LD_INT 22
118749: PUSH
118750: LD_OWVAR 2
118754: PUSH
118755: EMPTY
118756: LIST
118757: LIST
118758: PUSH
118759: LD_INT 21
118761: PUSH
118762: LD_INT 1
118764: PUSH
118765: EMPTY
118766: LIST
118767: LIST
118768: PUSH
118769: LD_INT 3
118771: PUSH
118772: LD_INT 23
118774: PUSH
118775: LD_INT 0
118777: PUSH
118778: EMPTY
118779: LIST
118780: LIST
118781: PUSH
118782: EMPTY
118783: LIST
118784: LIST
118785: PUSH
118786: EMPTY
118787: LIST
118788: LIST
118789: LIST
118790: PPUSH
118791: CALL_OW 69
118795: PUSH
118796: FOR_IN
118797: IFFALSE 118851
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
118799: LD_VAR 0 1
118803: PPUSH
118804: CALL_OW 257
118808: PUSH
118809: LD_INT 1
118811: PUSH
118812: LD_INT 2
118814: PUSH
118815: LD_INT 3
118817: PUSH
118818: LD_INT 4
118820: PUSH
118821: EMPTY
118822: LIST
118823: LIST
118824: LIST
118825: LIST
118826: IN
118827: IFFALSE 118849
// SetClass ( un , rand ( 1 , 4 ) ) ;
118829: LD_VAR 0 1
118833: PPUSH
118834: LD_INT 1
118836: PPUSH
118837: LD_INT 4
118839: PPUSH
118840: CALL_OW 12
118844: PPUSH
118845: CALL_OW 336
118849: GO 118796
118851: POP
118852: POP
// end ;
118853: PPOPN 1
118855: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
118856: LD_EXP 147
118860: PUSH
118861: LD_EXP 159
118865: AND
118866: IFFALSE 118945
118868: GO 118870
118870: DISABLE
118871: LD_INT 0
118873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
118874: LD_ADDR_VAR 0 1
118878: PUSH
118879: LD_INT 22
118881: PUSH
118882: LD_OWVAR 2
118886: PUSH
118887: EMPTY
118888: LIST
118889: LIST
118890: PUSH
118891: LD_INT 21
118893: PUSH
118894: LD_INT 3
118896: PUSH
118897: EMPTY
118898: LIST
118899: LIST
118900: PUSH
118901: EMPTY
118902: LIST
118903: LIST
118904: PPUSH
118905: CALL_OW 69
118909: ST_TO_ADDR
// if not tmp then
118910: LD_VAR 0 1
118914: NOT
118915: IFFALSE 118919
// exit ;
118917: GO 118945
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
118919: LD_VAR 0 1
118923: PUSH
118924: LD_INT 1
118926: PPUSH
118927: LD_VAR 0 1
118931: PPUSH
118932: CALL_OW 12
118936: ARRAY
118937: PPUSH
118938: LD_INT 100
118940: PPUSH
118941: CALL_OW 234
// end ;
118945: PPOPN 1
118947: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
118948: LD_EXP 147
118952: PUSH
118953: LD_EXP 161
118957: AND
118958: IFFALSE 119056
118960: GO 118962
118962: DISABLE
118963: LD_INT 0
118965: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118966: LD_ADDR_VAR 0 1
118970: PUSH
118971: LD_INT 22
118973: PUSH
118974: LD_OWVAR 2
118978: PUSH
118979: EMPTY
118980: LIST
118981: LIST
118982: PUSH
118983: LD_INT 21
118985: PUSH
118986: LD_INT 1
118988: PUSH
118989: EMPTY
118990: LIST
118991: LIST
118992: PUSH
118993: EMPTY
118994: LIST
118995: LIST
118996: PPUSH
118997: CALL_OW 69
119001: ST_TO_ADDR
// if not tmp then
119002: LD_VAR 0 1
119006: NOT
119007: IFFALSE 119011
// exit ;
119009: GO 119056
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119011: LD_VAR 0 1
119015: PUSH
119016: LD_INT 1
119018: PPUSH
119019: LD_VAR 0 1
119023: PPUSH
119024: CALL_OW 12
119028: ARRAY
119029: PPUSH
119030: LD_INT 1
119032: PPUSH
119033: LD_INT 4
119035: PPUSH
119036: CALL_OW 12
119040: PPUSH
119041: LD_INT 3000
119043: PPUSH
119044: LD_INT 9000
119046: PPUSH
119047: CALL_OW 12
119051: PPUSH
119052: CALL_OW 492
// end ;
119056: PPOPN 1
119058: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119059: LD_EXP 147
119063: PUSH
119064: LD_EXP 162
119068: AND
119069: IFFALSE 119089
119071: GO 119073
119073: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119074: LD_INT 1
119076: PPUSH
119077: LD_OWVAR 2
119081: PPUSH
119082: LD_INT 0
119084: PPUSH
119085: CALL_OW 324
119089: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119090: LD_EXP 147
119094: PUSH
119095: LD_EXP 163
119099: AND
119100: IFFALSE 119183
119102: GO 119104
119104: DISABLE
119105: LD_INT 0
119107: PPUSH
119108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119109: LD_ADDR_VAR 0 2
119113: PUSH
119114: LD_INT 22
119116: PUSH
119117: LD_OWVAR 2
119121: PUSH
119122: EMPTY
119123: LIST
119124: LIST
119125: PUSH
119126: LD_INT 21
119128: PUSH
119129: LD_INT 3
119131: PUSH
119132: EMPTY
119133: LIST
119134: LIST
119135: PUSH
119136: EMPTY
119137: LIST
119138: LIST
119139: PPUSH
119140: CALL_OW 69
119144: ST_TO_ADDR
// if not tmp then
119145: LD_VAR 0 2
119149: NOT
119150: IFFALSE 119154
// exit ;
119152: GO 119183
// for i in tmp do
119154: LD_ADDR_VAR 0 1
119158: PUSH
119159: LD_VAR 0 2
119163: PUSH
119164: FOR_IN
119165: IFFALSE 119181
// SetBLevel ( i , 10 ) ;
119167: LD_VAR 0 1
119171: PPUSH
119172: LD_INT 10
119174: PPUSH
119175: CALL_OW 241
119179: GO 119164
119181: POP
119182: POP
// end ;
119183: PPOPN 2
119185: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
119186: LD_EXP 147
119190: PUSH
119191: LD_EXP 164
119195: AND
119196: IFFALSE 119307
119198: GO 119200
119200: DISABLE
119201: LD_INT 0
119203: PPUSH
119204: PPUSH
119205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119206: LD_ADDR_VAR 0 3
119210: PUSH
119211: LD_INT 22
119213: PUSH
119214: LD_OWVAR 2
119218: PUSH
119219: EMPTY
119220: LIST
119221: LIST
119222: PUSH
119223: LD_INT 25
119225: PUSH
119226: LD_INT 1
119228: PUSH
119229: EMPTY
119230: LIST
119231: LIST
119232: PUSH
119233: EMPTY
119234: LIST
119235: LIST
119236: PPUSH
119237: CALL_OW 69
119241: ST_TO_ADDR
// if not tmp then
119242: LD_VAR 0 3
119246: NOT
119247: IFFALSE 119251
// exit ;
119249: GO 119307
// un := tmp [ rand ( 1 , tmp ) ] ;
119251: LD_ADDR_VAR 0 2
119255: PUSH
119256: LD_VAR 0 3
119260: PUSH
119261: LD_INT 1
119263: PPUSH
119264: LD_VAR 0 3
119268: PPUSH
119269: CALL_OW 12
119273: ARRAY
119274: ST_TO_ADDR
// if Crawls ( un ) then
119275: LD_VAR 0 2
119279: PPUSH
119280: CALL_OW 318
119284: IFFALSE 119295
// ComWalk ( un ) ;
119286: LD_VAR 0 2
119290: PPUSH
119291: CALL_OW 138
// SetClass ( un , class_sniper ) ;
119295: LD_VAR 0 2
119299: PPUSH
119300: LD_INT 5
119302: PPUSH
119303: CALL_OW 336
// end ;
119307: PPOPN 3
119309: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
119310: LD_EXP 147
119314: PUSH
119315: LD_EXP 165
119319: AND
119320: PUSH
119321: LD_OWVAR 67
119325: PUSH
119326: LD_INT 4
119328: LESS
119329: AND
119330: IFFALSE 119349
119332: GO 119334
119334: DISABLE
// begin Difficulty := Difficulty + 1 ;
119335: LD_ADDR_OWVAR 67
119339: PUSH
119340: LD_OWVAR 67
119344: PUSH
119345: LD_INT 1
119347: PLUS
119348: ST_TO_ADDR
// end ;
119349: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
119350: LD_EXP 147
119354: PUSH
119355: LD_EXP 166
119359: AND
119360: IFFALSE 119463
119362: GO 119364
119364: DISABLE
119365: LD_INT 0
119367: PPUSH
// begin for i := 1 to 5 do
119368: LD_ADDR_VAR 0 1
119372: PUSH
119373: DOUBLE
119374: LD_INT 1
119376: DEC
119377: ST_TO_ADDR
119378: LD_INT 5
119380: PUSH
119381: FOR_TO
119382: IFFALSE 119461
// begin uc_nation := nation_nature ;
119384: LD_ADDR_OWVAR 21
119388: PUSH
119389: LD_INT 0
119391: ST_TO_ADDR
// uc_side := 0 ;
119392: LD_ADDR_OWVAR 20
119396: PUSH
119397: LD_INT 0
119399: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
119400: LD_ADDR_OWVAR 29
119404: PUSH
119405: LD_INT 12
119407: PUSH
119408: LD_INT 12
119410: PUSH
119411: EMPTY
119412: LIST
119413: LIST
119414: ST_TO_ADDR
// hc_agressivity := 20 ;
119415: LD_ADDR_OWVAR 35
119419: PUSH
119420: LD_INT 20
119422: ST_TO_ADDR
// hc_class := class_tiger ;
119423: LD_ADDR_OWVAR 28
119427: PUSH
119428: LD_INT 14
119430: ST_TO_ADDR
// hc_gallery :=  ;
119431: LD_ADDR_OWVAR 33
119435: PUSH
119436: LD_STRING 
119438: ST_TO_ADDR
// hc_name :=  ;
119439: LD_ADDR_OWVAR 26
119443: PUSH
119444: LD_STRING 
119446: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
119447: CALL_OW 44
119451: PPUSH
119452: LD_INT 0
119454: PPUSH
119455: CALL_OW 51
// end ;
119459: GO 119381
119461: POP
119462: POP
// end ;
119463: PPOPN 1
119465: END
// every 0 0$1 trigger StreamModeActive and sBomb do
119466: LD_EXP 147
119470: PUSH
119471: LD_EXP 167
119475: AND
119476: IFFALSE 119485
119478: GO 119480
119480: DISABLE
// StreamSibBomb ;
119481: CALL 119486 0 0
119485: END
// export function StreamSibBomb ; var i , x , y ; begin
119486: LD_INT 0
119488: PPUSH
119489: PPUSH
119490: PPUSH
119491: PPUSH
// result := false ;
119492: LD_ADDR_VAR 0 1
119496: PUSH
119497: LD_INT 0
119499: ST_TO_ADDR
// for i := 1 to 16 do
119500: LD_ADDR_VAR 0 2
119504: PUSH
119505: DOUBLE
119506: LD_INT 1
119508: DEC
119509: ST_TO_ADDR
119510: LD_INT 16
119512: PUSH
119513: FOR_TO
119514: IFFALSE 119713
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
119516: LD_ADDR_VAR 0 3
119520: PUSH
119521: LD_INT 10
119523: PUSH
119524: LD_INT 20
119526: PUSH
119527: LD_INT 30
119529: PUSH
119530: LD_INT 40
119532: PUSH
119533: LD_INT 50
119535: PUSH
119536: LD_INT 60
119538: PUSH
119539: LD_INT 70
119541: PUSH
119542: LD_INT 80
119544: PUSH
119545: LD_INT 90
119547: PUSH
119548: LD_INT 100
119550: PUSH
119551: LD_INT 110
119553: PUSH
119554: LD_INT 120
119556: PUSH
119557: LD_INT 130
119559: PUSH
119560: LD_INT 140
119562: PUSH
119563: LD_INT 150
119565: PUSH
119566: EMPTY
119567: LIST
119568: LIST
119569: LIST
119570: LIST
119571: LIST
119572: LIST
119573: LIST
119574: LIST
119575: LIST
119576: LIST
119577: LIST
119578: LIST
119579: LIST
119580: LIST
119581: LIST
119582: PUSH
119583: LD_INT 1
119585: PPUSH
119586: LD_INT 15
119588: PPUSH
119589: CALL_OW 12
119593: ARRAY
119594: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
119595: LD_ADDR_VAR 0 4
119599: PUSH
119600: LD_INT 10
119602: PUSH
119603: LD_INT 20
119605: PUSH
119606: LD_INT 30
119608: PUSH
119609: LD_INT 40
119611: PUSH
119612: LD_INT 50
119614: PUSH
119615: LD_INT 60
119617: PUSH
119618: LD_INT 70
119620: PUSH
119621: LD_INT 80
119623: PUSH
119624: LD_INT 90
119626: PUSH
119627: LD_INT 100
119629: PUSH
119630: LD_INT 110
119632: PUSH
119633: LD_INT 120
119635: PUSH
119636: LD_INT 130
119638: PUSH
119639: LD_INT 140
119641: PUSH
119642: LD_INT 150
119644: PUSH
119645: EMPTY
119646: LIST
119647: LIST
119648: LIST
119649: LIST
119650: LIST
119651: LIST
119652: LIST
119653: LIST
119654: LIST
119655: LIST
119656: LIST
119657: LIST
119658: LIST
119659: LIST
119660: LIST
119661: PUSH
119662: LD_INT 1
119664: PPUSH
119665: LD_INT 15
119667: PPUSH
119668: CALL_OW 12
119672: ARRAY
119673: ST_TO_ADDR
// if ValidHex ( x , y ) then
119674: LD_VAR 0 3
119678: PPUSH
119679: LD_VAR 0 4
119683: PPUSH
119684: CALL_OW 488
119688: IFFALSE 119711
// begin result := [ x , y ] ;
119690: LD_ADDR_VAR 0 1
119694: PUSH
119695: LD_VAR 0 3
119699: PUSH
119700: LD_VAR 0 4
119704: PUSH
119705: EMPTY
119706: LIST
119707: LIST
119708: ST_TO_ADDR
// break ;
119709: GO 119713
// end ; end ;
119711: GO 119513
119713: POP
119714: POP
// if result then
119715: LD_VAR 0 1
119719: IFFALSE 119779
// begin ToLua ( playSibBomb() ) ;
119721: LD_STRING playSibBomb()
119723: PPUSH
119724: CALL_OW 559
// wait ( 0 0$14 ) ;
119728: LD_INT 490
119730: PPUSH
119731: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
119735: LD_VAR 0 1
119739: PUSH
119740: LD_INT 1
119742: ARRAY
119743: PPUSH
119744: LD_VAR 0 1
119748: PUSH
119749: LD_INT 2
119751: ARRAY
119752: PPUSH
119753: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
119757: LD_VAR 0 1
119761: PUSH
119762: LD_INT 1
119764: ARRAY
119765: PPUSH
119766: LD_VAR 0 1
119770: PUSH
119771: LD_INT 2
119773: ARRAY
119774: PPUSH
119775: CALL_OW 429
// end ; end ;
119779: LD_VAR 0 1
119783: RET
// every 0 0$1 trigger StreamModeActive and sReset do
119784: LD_EXP 147
119788: PUSH
119789: LD_EXP 169
119793: AND
119794: IFFALSE 119806
119796: GO 119798
119798: DISABLE
// YouLost (  ) ;
119799: LD_STRING 
119801: PPUSH
119802: CALL_OW 104
119806: END
// every 0 0$1 trigger StreamModeActive and sFog do
119807: LD_EXP 147
119811: PUSH
119812: LD_EXP 168
119816: AND
119817: IFFALSE 119831
119819: GO 119821
119821: DISABLE
// FogOff ( your_side ) ;
119822: LD_OWVAR 2
119826: PPUSH
119827: CALL_OW 344
119831: END
// every 0 0$1 trigger StreamModeActive and sSun do
119832: LD_EXP 147
119836: PUSH
119837: LD_EXP 170
119841: AND
119842: IFFALSE 119870
119844: GO 119846
119846: DISABLE
// begin solar_recharge_percent := 0 ;
119847: LD_ADDR_OWVAR 79
119851: PUSH
119852: LD_INT 0
119854: ST_TO_ADDR
// wait ( 5 5$00 ) ;
119855: LD_INT 10500
119857: PPUSH
119858: CALL_OW 67
// solar_recharge_percent := 100 ;
119862: LD_ADDR_OWVAR 79
119866: PUSH
119867: LD_INT 100
119869: ST_TO_ADDR
// end ;
119870: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
119871: LD_EXP 147
119875: PUSH
119876: LD_EXP 171
119880: AND
119881: IFFALSE 120120
119883: GO 119885
119885: DISABLE
119886: LD_INT 0
119888: PPUSH
119889: PPUSH
119890: PPUSH
// begin tmp := [ ] ;
119891: LD_ADDR_VAR 0 3
119895: PUSH
119896: EMPTY
119897: ST_TO_ADDR
// for i := 1 to 6 do
119898: LD_ADDR_VAR 0 1
119902: PUSH
119903: DOUBLE
119904: LD_INT 1
119906: DEC
119907: ST_TO_ADDR
119908: LD_INT 6
119910: PUSH
119911: FOR_TO
119912: IFFALSE 120017
// begin uc_nation := nation_nature ;
119914: LD_ADDR_OWVAR 21
119918: PUSH
119919: LD_INT 0
119921: ST_TO_ADDR
// uc_side := 0 ;
119922: LD_ADDR_OWVAR 20
119926: PUSH
119927: LD_INT 0
119929: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
119930: LD_ADDR_OWVAR 29
119934: PUSH
119935: LD_INT 12
119937: PUSH
119938: LD_INT 12
119940: PUSH
119941: EMPTY
119942: LIST
119943: LIST
119944: ST_TO_ADDR
// hc_agressivity := 20 ;
119945: LD_ADDR_OWVAR 35
119949: PUSH
119950: LD_INT 20
119952: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
119953: LD_ADDR_OWVAR 28
119957: PUSH
119958: LD_INT 17
119960: ST_TO_ADDR
// hc_gallery :=  ;
119961: LD_ADDR_OWVAR 33
119965: PUSH
119966: LD_STRING 
119968: ST_TO_ADDR
// hc_name :=  ;
119969: LD_ADDR_OWVAR 26
119973: PUSH
119974: LD_STRING 
119976: ST_TO_ADDR
// un := CreateHuman ;
119977: LD_ADDR_VAR 0 2
119981: PUSH
119982: CALL_OW 44
119986: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
119987: LD_VAR 0 2
119991: PPUSH
119992: LD_INT 1
119994: PPUSH
119995: CALL_OW 51
// tmp := tmp ^ un ;
119999: LD_ADDR_VAR 0 3
120003: PUSH
120004: LD_VAR 0 3
120008: PUSH
120009: LD_VAR 0 2
120013: ADD
120014: ST_TO_ADDR
// end ;
120015: GO 119911
120017: POP
120018: POP
// repeat wait ( 0 0$1 ) ;
120019: LD_INT 35
120021: PPUSH
120022: CALL_OW 67
// for un in tmp do
120026: LD_ADDR_VAR 0 2
120030: PUSH
120031: LD_VAR 0 3
120035: PUSH
120036: FOR_IN
120037: IFFALSE 120111
// begin if IsDead ( un ) then
120039: LD_VAR 0 2
120043: PPUSH
120044: CALL_OW 301
120048: IFFALSE 120068
// begin tmp := tmp diff un ;
120050: LD_ADDR_VAR 0 3
120054: PUSH
120055: LD_VAR 0 3
120059: PUSH
120060: LD_VAR 0 2
120064: DIFF
120065: ST_TO_ADDR
// continue ;
120066: GO 120036
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120068: LD_VAR 0 2
120072: PPUSH
120073: LD_INT 3
120075: PUSH
120076: LD_INT 22
120078: PUSH
120079: LD_INT 0
120081: PUSH
120082: EMPTY
120083: LIST
120084: LIST
120085: PUSH
120086: EMPTY
120087: LIST
120088: LIST
120089: PPUSH
120090: CALL_OW 69
120094: PPUSH
120095: LD_VAR 0 2
120099: PPUSH
120100: CALL_OW 74
120104: PPUSH
120105: CALL_OW 115
// end ;
120109: GO 120036
120111: POP
120112: POP
// until not tmp ;
120113: LD_VAR 0 3
120117: NOT
120118: IFFALSE 120019
// end ;
120120: PPOPN 3
120122: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120123: LD_EXP 147
120127: PUSH
120128: LD_EXP 172
120132: AND
120133: IFFALSE 120187
120135: GO 120137
120137: DISABLE
// begin ToLua ( displayTroll(); ) ;
120138: LD_STRING displayTroll();
120140: PPUSH
120141: CALL_OW 559
// wait ( 3 3$00 ) ;
120145: LD_INT 6300
120147: PPUSH
120148: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120152: LD_STRING hideTroll();
120154: PPUSH
120155: CALL_OW 559
// wait ( 1 1$00 ) ;
120159: LD_INT 2100
120161: PPUSH
120162: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120166: LD_STRING displayTroll();
120168: PPUSH
120169: CALL_OW 559
// wait ( 1 1$00 ) ;
120173: LD_INT 2100
120175: PPUSH
120176: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120180: LD_STRING hideTroll();
120182: PPUSH
120183: CALL_OW 559
// end ;
120187: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
120188: LD_EXP 147
120192: PUSH
120193: LD_EXP 173
120197: AND
120198: IFFALSE 120261
120200: GO 120202
120202: DISABLE
120203: LD_INT 0
120205: PPUSH
// begin p := 0 ;
120206: LD_ADDR_VAR 0 1
120210: PUSH
120211: LD_INT 0
120213: ST_TO_ADDR
// repeat game_speed := 1 ;
120214: LD_ADDR_OWVAR 65
120218: PUSH
120219: LD_INT 1
120221: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120222: LD_INT 35
120224: PPUSH
120225: CALL_OW 67
// p := p + 1 ;
120229: LD_ADDR_VAR 0 1
120233: PUSH
120234: LD_VAR 0 1
120238: PUSH
120239: LD_INT 1
120241: PLUS
120242: ST_TO_ADDR
// until p >= 60 ;
120243: LD_VAR 0 1
120247: PUSH
120248: LD_INT 60
120250: GREATEREQUAL
120251: IFFALSE 120214
// game_speed := 4 ;
120253: LD_ADDR_OWVAR 65
120257: PUSH
120258: LD_INT 4
120260: ST_TO_ADDR
// end ;
120261: PPOPN 1
120263: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
120264: LD_EXP 147
120268: PUSH
120269: LD_EXP 174
120273: AND
120274: IFFALSE 120420
120276: GO 120278
120278: DISABLE
120279: LD_INT 0
120281: PPUSH
120282: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120283: LD_ADDR_VAR 0 1
120287: PUSH
120288: LD_INT 22
120290: PUSH
120291: LD_OWVAR 2
120295: PUSH
120296: EMPTY
120297: LIST
120298: LIST
120299: PUSH
120300: LD_INT 2
120302: PUSH
120303: LD_INT 30
120305: PUSH
120306: LD_INT 0
120308: PUSH
120309: EMPTY
120310: LIST
120311: LIST
120312: PUSH
120313: LD_INT 30
120315: PUSH
120316: LD_INT 1
120318: PUSH
120319: EMPTY
120320: LIST
120321: LIST
120322: PUSH
120323: EMPTY
120324: LIST
120325: LIST
120326: LIST
120327: PUSH
120328: EMPTY
120329: LIST
120330: LIST
120331: PPUSH
120332: CALL_OW 69
120336: ST_TO_ADDR
// if not depot then
120337: LD_VAR 0 1
120341: NOT
120342: IFFALSE 120346
// exit ;
120344: GO 120420
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
120346: LD_ADDR_VAR 0 2
120350: PUSH
120351: LD_VAR 0 1
120355: PUSH
120356: LD_INT 1
120358: PPUSH
120359: LD_VAR 0 1
120363: PPUSH
120364: CALL_OW 12
120368: ARRAY
120369: PPUSH
120370: CALL_OW 274
120374: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
120375: LD_VAR 0 2
120379: PPUSH
120380: LD_INT 1
120382: PPUSH
120383: LD_INT 0
120385: PPUSH
120386: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
120390: LD_VAR 0 2
120394: PPUSH
120395: LD_INT 2
120397: PPUSH
120398: LD_INT 0
120400: PPUSH
120401: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
120405: LD_VAR 0 2
120409: PPUSH
120410: LD_INT 3
120412: PPUSH
120413: LD_INT 0
120415: PPUSH
120416: CALL_OW 277
// end ;
120420: PPOPN 2
120422: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
120423: LD_EXP 147
120427: PUSH
120428: LD_EXP 175
120432: AND
120433: IFFALSE 120530
120435: GO 120437
120437: DISABLE
120438: LD_INT 0
120440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120441: LD_ADDR_VAR 0 1
120445: PUSH
120446: LD_INT 22
120448: PUSH
120449: LD_OWVAR 2
120453: PUSH
120454: EMPTY
120455: LIST
120456: LIST
120457: PUSH
120458: LD_INT 21
120460: PUSH
120461: LD_INT 1
120463: PUSH
120464: EMPTY
120465: LIST
120466: LIST
120467: PUSH
120468: LD_INT 3
120470: PUSH
120471: LD_INT 23
120473: PUSH
120474: LD_INT 0
120476: PUSH
120477: EMPTY
120478: LIST
120479: LIST
120480: PUSH
120481: EMPTY
120482: LIST
120483: LIST
120484: PUSH
120485: EMPTY
120486: LIST
120487: LIST
120488: LIST
120489: PPUSH
120490: CALL_OW 69
120494: ST_TO_ADDR
// if not tmp then
120495: LD_VAR 0 1
120499: NOT
120500: IFFALSE 120504
// exit ;
120502: GO 120530
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
120504: LD_VAR 0 1
120508: PUSH
120509: LD_INT 1
120511: PPUSH
120512: LD_VAR 0 1
120516: PPUSH
120517: CALL_OW 12
120521: ARRAY
120522: PPUSH
120523: LD_INT 200
120525: PPUSH
120526: CALL_OW 234
// end ;
120530: PPOPN 1
120532: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
120533: LD_EXP 147
120537: PUSH
120538: LD_EXP 176
120542: AND
120543: IFFALSE 120622
120545: GO 120547
120547: DISABLE
120548: LD_INT 0
120550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
120551: LD_ADDR_VAR 0 1
120555: PUSH
120556: LD_INT 22
120558: PUSH
120559: LD_OWVAR 2
120563: PUSH
120564: EMPTY
120565: LIST
120566: LIST
120567: PUSH
120568: LD_INT 21
120570: PUSH
120571: LD_INT 2
120573: PUSH
120574: EMPTY
120575: LIST
120576: LIST
120577: PUSH
120578: EMPTY
120579: LIST
120580: LIST
120581: PPUSH
120582: CALL_OW 69
120586: ST_TO_ADDR
// if not tmp then
120587: LD_VAR 0 1
120591: NOT
120592: IFFALSE 120596
// exit ;
120594: GO 120622
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
120596: LD_VAR 0 1
120600: PUSH
120601: LD_INT 1
120603: PPUSH
120604: LD_VAR 0 1
120608: PPUSH
120609: CALL_OW 12
120613: ARRAY
120614: PPUSH
120615: LD_INT 60
120617: PPUSH
120618: CALL_OW 234
// end ;
120622: PPOPN 1
120624: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
120625: LD_EXP 147
120629: PUSH
120630: LD_EXP 177
120634: AND
120635: IFFALSE 120734
120637: GO 120639
120639: DISABLE
120640: LD_INT 0
120642: PPUSH
120643: PPUSH
// begin enable ;
120644: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
120645: LD_ADDR_VAR 0 1
120649: PUSH
120650: LD_INT 22
120652: PUSH
120653: LD_OWVAR 2
120657: PUSH
120658: EMPTY
120659: LIST
120660: LIST
120661: PUSH
120662: LD_INT 61
120664: PUSH
120665: EMPTY
120666: LIST
120667: PUSH
120668: LD_INT 33
120670: PUSH
120671: LD_INT 2
120673: PUSH
120674: EMPTY
120675: LIST
120676: LIST
120677: PUSH
120678: EMPTY
120679: LIST
120680: LIST
120681: LIST
120682: PPUSH
120683: CALL_OW 69
120687: ST_TO_ADDR
// if not tmp then
120688: LD_VAR 0 1
120692: NOT
120693: IFFALSE 120697
// exit ;
120695: GO 120734
// for i in tmp do
120697: LD_ADDR_VAR 0 2
120701: PUSH
120702: LD_VAR 0 1
120706: PUSH
120707: FOR_IN
120708: IFFALSE 120732
// if IsControledBy ( i ) then
120710: LD_VAR 0 2
120714: PPUSH
120715: CALL_OW 312
120719: IFFALSE 120730
// ComUnlink ( i ) ;
120721: LD_VAR 0 2
120725: PPUSH
120726: CALL_OW 136
120730: GO 120707
120732: POP
120733: POP
// end ;
120734: PPOPN 2
120736: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
120737: LD_EXP 147
120741: PUSH
120742: LD_EXP 178
120746: AND
120747: IFFALSE 120887
120749: GO 120751
120751: DISABLE
120752: LD_INT 0
120754: PPUSH
120755: PPUSH
// begin ToLua ( displayPowell(); ) ;
120756: LD_STRING displayPowell();
120758: PPUSH
120759: CALL_OW 559
// uc_side := 0 ;
120763: LD_ADDR_OWVAR 20
120767: PUSH
120768: LD_INT 0
120770: ST_TO_ADDR
// uc_nation := 2 ;
120771: LD_ADDR_OWVAR 21
120775: PUSH
120776: LD_INT 2
120778: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
120779: LD_ADDR_OWVAR 37
120783: PUSH
120784: LD_INT 14
120786: ST_TO_ADDR
// vc_engine := engine_siberite ;
120787: LD_ADDR_OWVAR 39
120791: PUSH
120792: LD_INT 3
120794: ST_TO_ADDR
// vc_control := control_apeman ;
120795: LD_ADDR_OWVAR 38
120799: PUSH
120800: LD_INT 5
120802: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
120803: LD_ADDR_OWVAR 40
120807: PUSH
120808: LD_INT 29
120810: ST_TO_ADDR
// un := CreateVehicle ;
120811: LD_ADDR_VAR 0 2
120815: PUSH
120816: CALL_OW 45
120820: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120821: LD_VAR 0 2
120825: PPUSH
120826: LD_INT 1
120828: PPUSH
120829: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
120833: LD_INT 35
120835: PPUSH
120836: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
120840: LD_VAR 0 2
120844: PPUSH
120845: LD_INT 22
120847: PUSH
120848: LD_OWVAR 2
120852: PUSH
120853: EMPTY
120854: LIST
120855: LIST
120856: PPUSH
120857: CALL_OW 69
120861: PPUSH
120862: LD_VAR 0 2
120866: PPUSH
120867: CALL_OW 74
120871: PPUSH
120872: CALL_OW 115
// until IsDead ( un ) ;
120876: LD_VAR 0 2
120880: PPUSH
120881: CALL_OW 301
120885: IFFALSE 120833
// end ;
120887: PPOPN 2
120889: END
// every 0 0$1 trigger StreamModeActive and sStu do
120890: LD_EXP 147
120894: PUSH
120895: LD_EXP 186
120899: AND
120900: IFFALSE 120916
120902: GO 120904
120904: DISABLE
// begin ToLua ( displayStucuk(); ) ;
120905: LD_STRING displayStucuk();
120907: PPUSH
120908: CALL_OW 559
// ResetFog ;
120912: CALL_OW 335
// end ;
120916: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
120917: LD_EXP 147
120921: PUSH
120922: LD_EXP 179
120926: AND
120927: IFFALSE 121068
120929: GO 120931
120931: DISABLE
120932: LD_INT 0
120934: PPUSH
120935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120936: LD_ADDR_VAR 0 2
120940: PUSH
120941: LD_INT 22
120943: PUSH
120944: LD_OWVAR 2
120948: PUSH
120949: EMPTY
120950: LIST
120951: LIST
120952: PUSH
120953: LD_INT 21
120955: PUSH
120956: LD_INT 1
120958: PUSH
120959: EMPTY
120960: LIST
120961: LIST
120962: PUSH
120963: EMPTY
120964: LIST
120965: LIST
120966: PPUSH
120967: CALL_OW 69
120971: ST_TO_ADDR
// if not tmp then
120972: LD_VAR 0 2
120976: NOT
120977: IFFALSE 120981
// exit ;
120979: GO 121068
// un := tmp [ rand ( 1 , tmp ) ] ;
120981: LD_ADDR_VAR 0 1
120985: PUSH
120986: LD_VAR 0 2
120990: PUSH
120991: LD_INT 1
120993: PPUSH
120994: LD_VAR 0 2
120998: PPUSH
120999: CALL_OW 12
121003: ARRAY
121004: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121005: LD_VAR 0 1
121009: PPUSH
121010: LD_INT 0
121012: PPUSH
121013: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121017: LD_VAR 0 1
121021: PPUSH
121022: LD_OWVAR 3
121026: PUSH
121027: LD_VAR 0 1
121031: DIFF
121032: PPUSH
121033: LD_VAR 0 1
121037: PPUSH
121038: CALL_OW 74
121042: PPUSH
121043: CALL_OW 115
// wait ( 0 0$20 ) ;
121047: LD_INT 700
121049: PPUSH
121050: CALL_OW 67
// SetSide ( un , your_side ) ;
121054: LD_VAR 0 1
121058: PPUSH
121059: LD_OWVAR 2
121063: PPUSH
121064: CALL_OW 235
// end ;
121068: PPOPN 2
121070: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121071: LD_EXP 147
121075: PUSH
121076: LD_EXP 180
121080: AND
121081: IFFALSE 121187
121083: GO 121085
121085: DISABLE
121086: LD_INT 0
121088: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121089: LD_ADDR_VAR 0 1
121093: PUSH
121094: LD_INT 22
121096: PUSH
121097: LD_OWVAR 2
121101: PUSH
121102: EMPTY
121103: LIST
121104: LIST
121105: PUSH
121106: LD_INT 2
121108: PUSH
121109: LD_INT 30
121111: PUSH
121112: LD_INT 0
121114: PUSH
121115: EMPTY
121116: LIST
121117: LIST
121118: PUSH
121119: LD_INT 30
121121: PUSH
121122: LD_INT 1
121124: PUSH
121125: EMPTY
121126: LIST
121127: LIST
121128: PUSH
121129: EMPTY
121130: LIST
121131: LIST
121132: LIST
121133: PUSH
121134: EMPTY
121135: LIST
121136: LIST
121137: PPUSH
121138: CALL_OW 69
121142: ST_TO_ADDR
// if not depot then
121143: LD_VAR 0 1
121147: NOT
121148: IFFALSE 121152
// exit ;
121150: GO 121187
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121152: LD_VAR 0 1
121156: PUSH
121157: LD_INT 1
121159: ARRAY
121160: PPUSH
121161: CALL_OW 250
121165: PPUSH
121166: LD_VAR 0 1
121170: PUSH
121171: LD_INT 1
121173: ARRAY
121174: PPUSH
121175: CALL_OW 251
121179: PPUSH
121180: LD_INT 70
121182: PPUSH
121183: CALL_OW 495
// end ;
121187: PPOPN 1
121189: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
121190: LD_EXP 147
121194: PUSH
121195: LD_EXP 181
121199: AND
121200: IFFALSE 121411
121202: GO 121204
121204: DISABLE
121205: LD_INT 0
121207: PPUSH
121208: PPUSH
121209: PPUSH
121210: PPUSH
121211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121212: LD_ADDR_VAR 0 5
121216: PUSH
121217: LD_INT 22
121219: PUSH
121220: LD_OWVAR 2
121224: PUSH
121225: EMPTY
121226: LIST
121227: LIST
121228: PUSH
121229: LD_INT 21
121231: PUSH
121232: LD_INT 1
121234: PUSH
121235: EMPTY
121236: LIST
121237: LIST
121238: PUSH
121239: EMPTY
121240: LIST
121241: LIST
121242: PPUSH
121243: CALL_OW 69
121247: ST_TO_ADDR
// if not tmp then
121248: LD_VAR 0 5
121252: NOT
121253: IFFALSE 121257
// exit ;
121255: GO 121411
// for i in tmp do
121257: LD_ADDR_VAR 0 1
121261: PUSH
121262: LD_VAR 0 5
121266: PUSH
121267: FOR_IN
121268: IFFALSE 121409
// begin d := rand ( 0 , 5 ) ;
121270: LD_ADDR_VAR 0 4
121274: PUSH
121275: LD_INT 0
121277: PPUSH
121278: LD_INT 5
121280: PPUSH
121281: CALL_OW 12
121285: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
121286: LD_ADDR_VAR 0 2
121290: PUSH
121291: LD_VAR 0 1
121295: PPUSH
121296: CALL_OW 250
121300: PPUSH
121301: LD_VAR 0 4
121305: PPUSH
121306: LD_INT 3
121308: PPUSH
121309: LD_INT 12
121311: PPUSH
121312: CALL_OW 12
121316: PPUSH
121317: CALL_OW 272
121321: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
121322: LD_ADDR_VAR 0 3
121326: PUSH
121327: LD_VAR 0 1
121331: PPUSH
121332: CALL_OW 251
121336: PPUSH
121337: LD_VAR 0 4
121341: PPUSH
121342: LD_INT 3
121344: PPUSH
121345: LD_INT 12
121347: PPUSH
121348: CALL_OW 12
121352: PPUSH
121353: CALL_OW 273
121357: ST_TO_ADDR
// if ValidHex ( x , y ) then
121358: LD_VAR 0 2
121362: PPUSH
121363: LD_VAR 0 3
121367: PPUSH
121368: CALL_OW 488
121372: IFFALSE 121407
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
121374: LD_VAR 0 1
121378: PPUSH
121379: LD_VAR 0 2
121383: PPUSH
121384: LD_VAR 0 3
121388: PPUSH
121389: LD_INT 3
121391: PPUSH
121392: LD_INT 6
121394: PPUSH
121395: CALL_OW 12
121399: PPUSH
121400: LD_INT 1
121402: PPUSH
121403: CALL_OW 483
// end ;
121407: GO 121267
121409: POP
121410: POP
// end ;
121411: PPOPN 5
121413: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
121414: LD_EXP 147
121418: PUSH
121419: LD_EXP 182
121423: AND
121424: IFFALSE 121518
121426: GO 121428
121428: DISABLE
121429: LD_INT 0
121431: PPUSH
121432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
121433: LD_ADDR_VAR 0 2
121437: PUSH
121438: LD_INT 22
121440: PUSH
121441: LD_OWVAR 2
121445: PUSH
121446: EMPTY
121447: LIST
121448: LIST
121449: PUSH
121450: LD_INT 32
121452: PUSH
121453: LD_INT 1
121455: PUSH
121456: EMPTY
121457: LIST
121458: LIST
121459: PUSH
121460: LD_INT 21
121462: PUSH
121463: LD_INT 2
121465: PUSH
121466: EMPTY
121467: LIST
121468: LIST
121469: PUSH
121470: EMPTY
121471: LIST
121472: LIST
121473: LIST
121474: PPUSH
121475: CALL_OW 69
121479: ST_TO_ADDR
// if not tmp then
121480: LD_VAR 0 2
121484: NOT
121485: IFFALSE 121489
// exit ;
121487: GO 121518
// for i in tmp do
121489: LD_ADDR_VAR 0 1
121493: PUSH
121494: LD_VAR 0 2
121498: PUSH
121499: FOR_IN
121500: IFFALSE 121516
// SetFuel ( i , 0 ) ;
121502: LD_VAR 0 1
121506: PPUSH
121507: LD_INT 0
121509: PPUSH
121510: CALL_OW 240
121514: GO 121499
121516: POP
121517: POP
// end ;
121518: PPOPN 2
121520: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
121521: LD_EXP 147
121525: PUSH
121526: LD_EXP 183
121530: AND
121531: IFFALSE 121597
121533: GO 121535
121535: DISABLE
121536: LD_INT 0
121538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
121539: LD_ADDR_VAR 0 1
121543: PUSH
121544: LD_INT 22
121546: PUSH
121547: LD_OWVAR 2
121551: PUSH
121552: EMPTY
121553: LIST
121554: LIST
121555: PUSH
121556: LD_INT 30
121558: PUSH
121559: LD_INT 29
121561: PUSH
121562: EMPTY
121563: LIST
121564: LIST
121565: PUSH
121566: EMPTY
121567: LIST
121568: LIST
121569: PPUSH
121570: CALL_OW 69
121574: ST_TO_ADDR
// if not tmp then
121575: LD_VAR 0 1
121579: NOT
121580: IFFALSE 121584
// exit ;
121582: GO 121597
// DestroyUnit ( tmp [ 1 ] ) ;
121584: LD_VAR 0 1
121588: PUSH
121589: LD_INT 1
121591: ARRAY
121592: PPUSH
121593: CALL_OW 65
// end ;
121597: PPOPN 1
121599: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
121600: LD_EXP 147
121604: PUSH
121605: LD_EXP 185
121609: AND
121610: IFFALSE 121739
121612: GO 121614
121614: DISABLE
121615: LD_INT 0
121617: PPUSH
// begin uc_side := 0 ;
121618: LD_ADDR_OWVAR 20
121622: PUSH
121623: LD_INT 0
121625: ST_TO_ADDR
// uc_nation := nation_arabian ;
121626: LD_ADDR_OWVAR 21
121630: PUSH
121631: LD_INT 2
121633: ST_TO_ADDR
// hc_gallery :=  ;
121634: LD_ADDR_OWVAR 33
121638: PUSH
121639: LD_STRING 
121641: ST_TO_ADDR
// hc_name :=  ;
121642: LD_ADDR_OWVAR 26
121646: PUSH
121647: LD_STRING 
121649: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
121650: LD_INT 1
121652: PPUSH
121653: LD_INT 11
121655: PPUSH
121656: LD_INT 10
121658: PPUSH
121659: CALL_OW 380
// un := CreateHuman ;
121663: LD_ADDR_VAR 0 1
121667: PUSH
121668: CALL_OW 44
121672: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121673: LD_VAR 0 1
121677: PPUSH
121678: LD_INT 1
121680: PPUSH
121681: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121685: LD_INT 35
121687: PPUSH
121688: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121692: LD_VAR 0 1
121696: PPUSH
121697: LD_INT 22
121699: PUSH
121700: LD_OWVAR 2
121704: PUSH
121705: EMPTY
121706: LIST
121707: LIST
121708: PPUSH
121709: CALL_OW 69
121713: PPUSH
121714: LD_VAR 0 1
121718: PPUSH
121719: CALL_OW 74
121723: PPUSH
121724: CALL_OW 115
// until IsDead ( un ) ;
121728: LD_VAR 0 1
121732: PPUSH
121733: CALL_OW 301
121737: IFFALSE 121685
// end ;
121739: PPOPN 1
121741: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
121742: LD_EXP 147
121746: PUSH
121747: LD_EXP 187
121751: AND
121752: IFFALSE 121764
121754: GO 121756
121756: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
121757: LD_STRING earthquake(getX(game), 0, 32)
121759: PPUSH
121760: CALL_OW 559
121764: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
121765: LD_EXP 147
121769: PUSH
121770: LD_EXP 188
121774: AND
121775: IFFALSE 121866
121777: GO 121779
121779: DISABLE
121780: LD_INT 0
121782: PPUSH
// begin enable ;
121783: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
121784: LD_ADDR_VAR 0 1
121788: PUSH
121789: LD_INT 22
121791: PUSH
121792: LD_OWVAR 2
121796: PUSH
121797: EMPTY
121798: LIST
121799: LIST
121800: PUSH
121801: LD_INT 21
121803: PUSH
121804: LD_INT 2
121806: PUSH
121807: EMPTY
121808: LIST
121809: LIST
121810: PUSH
121811: LD_INT 33
121813: PUSH
121814: LD_INT 3
121816: PUSH
121817: EMPTY
121818: LIST
121819: LIST
121820: PUSH
121821: EMPTY
121822: LIST
121823: LIST
121824: LIST
121825: PPUSH
121826: CALL_OW 69
121830: ST_TO_ADDR
// if not tmp then
121831: LD_VAR 0 1
121835: NOT
121836: IFFALSE 121840
// exit ;
121838: GO 121866
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
121840: LD_VAR 0 1
121844: PUSH
121845: LD_INT 1
121847: PPUSH
121848: LD_VAR 0 1
121852: PPUSH
121853: CALL_OW 12
121857: ARRAY
121858: PPUSH
121859: LD_INT 1
121861: PPUSH
121862: CALL_OW 234
// end ;
121866: PPOPN 1
121868: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
121869: LD_EXP 147
121873: PUSH
121874: LD_EXP 189
121878: AND
121879: IFFALSE 122020
121881: GO 121883
121883: DISABLE
121884: LD_INT 0
121886: PPUSH
121887: PPUSH
121888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121889: LD_ADDR_VAR 0 3
121893: PUSH
121894: LD_INT 22
121896: PUSH
121897: LD_OWVAR 2
121901: PUSH
121902: EMPTY
121903: LIST
121904: LIST
121905: PUSH
121906: LD_INT 25
121908: PUSH
121909: LD_INT 1
121911: PUSH
121912: EMPTY
121913: LIST
121914: LIST
121915: PUSH
121916: EMPTY
121917: LIST
121918: LIST
121919: PPUSH
121920: CALL_OW 69
121924: ST_TO_ADDR
// if not tmp then
121925: LD_VAR 0 3
121929: NOT
121930: IFFALSE 121934
// exit ;
121932: GO 122020
// un := tmp [ rand ( 1 , tmp ) ] ;
121934: LD_ADDR_VAR 0 2
121938: PUSH
121939: LD_VAR 0 3
121943: PUSH
121944: LD_INT 1
121946: PPUSH
121947: LD_VAR 0 3
121951: PPUSH
121952: CALL_OW 12
121956: ARRAY
121957: ST_TO_ADDR
// if Crawls ( un ) then
121958: LD_VAR 0 2
121962: PPUSH
121963: CALL_OW 318
121967: IFFALSE 121978
// ComWalk ( un ) ;
121969: LD_VAR 0 2
121973: PPUSH
121974: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
121978: LD_VAR 0 2
121982: PPUSH
121983: LD_INT 9
121985: PPUSH
121986: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
121990: LD_INT 28
121992: PPUSH
121993: LD_OWVAR 2
121997: PPUSH
121998: LD_INT 2
122000: PPUSH
122001: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122005: LD_INT 29
122007: PPUSH
122008: LD_OWVAR 2
122012: PPUSH
122013: LD_INT 2
122015: PPUSH
122016: CALL_OW 322
// end ;
122020: PPOPN 3
122022: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122023: LD_EXP 147
122027: PUSH
122028: LD_EXP 190
122032: AND
122033: IFFALSE 122144
122035: GO 122037
122037: DISABLE
122038: LD_INT 0
122040: PPUSH
122041: PPUSH
122042: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122043: LD_ADDR_VAR 0 3
122047: PUSH
122048: LD_INT 22
122050: PUSH
122051: LD_OWVAR 2
122055: PUSH
122056: EMPTY
122057: LIST
122058: LIST
122059: PUSH
122060: LD_INT 25
122062: PUSH
122063: LD_INT 1
122065: PUSH
122066: EMPTY
122067: LIST
122068: LIST
122069: PUSH
122070: EMPTY
122071: LIST
122072: LIST
122073: PPUSH
122074: CALL_OW 69
122078: ST_TO_ADDR
// if not tmp then
122079: LD_VAR 0 3
122083: NOT
122084: IFFALSE 122088
// exit ;
122086: GO 122144
// un := tmp [ rand ( 1 , tmp ) ] ;
122088: LD_ADDR_VAR 0 2
122092: PUSH
122093: LD_VAR 0 3
122097: PUSH
122098: LD_INT 1
122100: PPUSH
122101: LD_VAR 0 3
122105: PPUSH
122106: CALL_OW 12
122110: ARRAY
122111: ST_TO_ADDR
// if Crawls ( un ) then
122112: LD_VAR 0 2
122116: PPUSH
122117: CALL_OW 318
122121: IFFALSE 122132
// ComWalk ( un ) ;
122123: LD_VAR 0 2
122127: PPUSH
122128: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122132: LD_VAR 0 2
122136: PPUSH
122137: LD_INT 8
122139: PPUSH
122140: CALL_OW 336
// end ;
122144: PPOPN 3
122146: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122147: LD_EXP 147
122151: PUSH
122152: LD_EXP 191
122156: AND
122157: IFFALSE 122301
122159: GO 122161
122161: DISABLE
122162: LD_INT 0
122164: PPUSH
122165: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122166: LD_ADDR_VAR 0 2
122170: PUSH
122171: LD_INT 22
122173: PUSH
122174: LD_OWVAR 2
122178: PUSH
122179: EMPTY
122180: LIST
122181: LIST
122182: PUSH
122183: LD_INT 21
122185: PUSH
122186: LD_INT 2
122188: PUSH
122189: EMPTY
122190: LIST
122191: LIST
122192: PUSH
122193: LD_INT 2
122195: PUSH
122196: LD_INT 34
122198: PUSH
122199: LD_INT 12
122201: PUSH
122202: EMPTY
122203: LIST
122204: LIST
122205: PUSH
122206: LD_INT 34
122208: PUSH
122209: LD_INT 51
122211: PUSH
122212: EMPTY
122213: LIST
122214: LIST
122215: PUSH
122216: LD_INT 34
122218: PUSH
122219: LD_INT 32
122221: PUSH
122222: EMPTY
122223: LIST
122224: LIST
122225: PUSH
122226: EMPTY
122227: LIST
122228: LIST
122229: LIST
122230: LIST
122231: PUSH
122232: EMPTY
122233: LIST
122234: LIST
122235: LIST
122236: PPUSH
122237: CALL_OW 69
122241: ST_TO_ADDR
// if not tmp then
122242: LD_VAR 0 2
122246: NOT
122247: IFFALSE 122251
// exit ;
122249: GO 122301
// for i in tmp do
122251: LD_ADDR_VAR 0 1
122255: PUSH
122256: LD_VAR 0 2
122260: PUSH
122261: FOR_IN
122262: IFFALSE 122299
// if GetCargo ( i , mat_artifact ) = 0 then
122264: LD_VAR 0 1
122268: PPUSH
122269: LD_INT 4
122271: PPUSH
122272: CALL_OW 289
122276: PUSH
122277: LD_INT 0
122279: EQUAL
122280: IFFALSE 122297
// SetCargo ( i , mat_siberit , 100 ) ;
122282: LD_VAR 0 1
122286: PPUSH
122287: LD_INT 3
122289: PPUSH
122290: LD_INT 100
122292: PPUSH
122293: CALL_OW 290
122297: GO 122261
122299: POP
122300: POP
// end ;
122301: PPOPN 2
122303: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
122304: LD_EXP 147
122308: PUSH
122309: LD_EXP 192
122313: AND
122314: IFFALSE 122497
122316: GO 122318
122318: DISABLE
122319: LD_INT 0
122321: PPUSH
122322: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122323: LD_ADDR_VAR 0 2
122327: PUSH
122328: LD_INT 22
122330: PUSH
122331: LD_OWVAR 2
122335: PUSH
122336: EMPTY
122337: LIST
122338: LIST
122339: PPUSH
122340: CALL_OW 69
122344: ST_TO_ADDR
// if not tmp then
122345: LD_VAR 0 2
122349: NOT
122350: IFFALSE 122354
// exit ;
122352: GO 122497
// for i := 1 to 2 do
122354: LD_ADDR_VAR 0 1
122358: PUSH
122359: DOUBLE
122360: LD_INT 1
122362: DEC
122363: ST_TO_ADDR
122364: LD_INT 2
122366: PUSH
122367: FOR_TO
122368: IFFALSE 122495
// begin uc_side := your_side ;
122370: LD_ADDR_OWVAR 20
122374: PUSH
122375: LD_OWVAR 2
122379: ST_TO_ADDR
// uc_nation := nation_american ;
122380: LD_ADDR_OWVAR 21
122384: PUSH
122385: LD_INT 1
122387: ST_TO_ADDR
// vc_chassis := us_morphling ;
122388: LD_ADDR_OWVAR 37
122392: PUSH
122393: LD_INT 5
122395: ST_TO_ADDR
// vc_engine := engine_siberite ;
122396: LD_ADDR_OWVAR 39
122400: PUSH
122401: LD_INT 3
122403: ST_TO_ADDR
// vc_control := control_computer ;
122404: LD_ADDR_OWVAR 38
122408: PUSH
122409: LD_INT 3
122411: ST_TO_ADDR
// vc_weapon := us_double_laser ;
122412: LD_ADDR_OWVAR 40
122416: PUSH
122417: LD_INT 10
122419: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
122420: LD_VAR 0 2
122424: PUSH
122425: LD_INT 1
122427: ARRAY
122428: PPUSH
122429: CALL_OW 310
122433: NOT
122434: IFFALSE 122481
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
122436: CALL_OW 45
122440: PPUSH
122441: LD_VAR 0 2
122445: PUSH
122446: LD_INT 1
122448: ARRAY
122449: PPUSH
122450: CALL_OW 250
122454: PPUSH
122455: LD_VAR 0 2
122459: PUSH
122460: LD_INT 1
122462: ARRAY
122463: PPUSH
122464: CALL_OW 251
122468: PPUSH
122469: LD_INT 12
122471: PPUSH
122472: LD_INT 1
122474: PPUSH
122475: CALL_OW 50
122479: GO 122493
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
122481: CALL_OW 45
122485: PPUSH
122486: LD_INT 1
122488: PPUSH
122489: CALL_OW 51
// end ;
122493: GO 122367
122495: POP
122496: POP
// end ;
122497: PPOPN 2
122499: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
122500: LD_EXP 147
122504: PUSH
122505: LD_EXP 193
122509: AND
122510: IFFALSE 122732
122512: GO 122514
122514: DISABLE
122515: LD_INT 0
122517: PPUSH
122518: PPUSH
122519: PPUSH
122520: PPUSH
122521: PPUSH
122522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
122523: LD_ADDR_VAR 0 6
122527: PUSH
122528: LD_INT 22
122530: PUSH
122531: LD_OWVAR 2
122535: PUSH
122536: EMPTY
122537: LIST
122538: LIST
122539: PUSH
122540: LD_INT 21
122542: PUSH
122543: LD_INT 1
122545: PUSH
122546: EMPTY
122547: LIST
122548: LIST
122549: PUSH
122550: LD_INT 3
122552: PUSH
122553: LD_INT 23
122555: PUSH
122556: LD_INT 0
122558: PUSH
122559: EMPTY
122560: LIST
122561: LIST
122562: PUSH
122563: EMPTY
122564: LIST
122565: LIST
122566: PUSH
122567: EMPTY
122568: LIST
122569: LIST
122570: LIST
122571: PPUSH
122572: CALL_OW 69
122576: ST_TO_ADDR
// if not tmp then
122577: LD_VAR 0 6
122581: NOT
122582: IFFALSE 122586
// exit ;
122584: GO 122732
// s1 := rand ( 1 , 4 ) ;
122586: LD_ADDR_VAR 0 2
122590: PUSH
122591: LD_INT 1
122593: PPUSH
122594: LD_INT 4
122596: PPUSH
122597: CALL_OW 12
122601: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
122602: LD_ADDR_VAR 0 4
122606: PUSH
122607: LD_VAR 0 6
122611: PUSH
122612: LD_INT 1
122614: ARRAY
122615: PPUSH
122616: LD_VAR 0 2
122620: PPUSH
122621: CALL_OW 259
122625: ST_TO_ADDR
// if s1 = 1 then
122626: LD_VAR 0 2
122630: PUSH
122631: LD_INT 1
122633: EQUAL
122634: IFFALSE 122654
// s2 := rand ( 2 , 4 ) else
122636: LD_ADDR_VAR 0 3
122640: PUSH
122641: LD_INT 2
122643: PPUSH
122644: LD_INT 4
122646: PPUSH
122647: CALL_OW 12
122651: ST_TO_ADDR
122652: GO 122662
// s2 := 1 ;
122654: LD_ADDR_VAR 0 3
122658: PUSH
122659: LD_INT 1
122661: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
122662: LD_ADDR_VAR 0 5
122666: PUSH
122667: LD_VAR 0 6
122671: PUSH
122672: LD_INT 1
122674: ARRAY
122675: PPUSH
122676: LD_VAR 0 3
122680: PPUSH
122681: CALL_OW 259
122685: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
122686: LD_VAR 0 6
122690: PUSH
122691: LD_INT 1
122693: ARRAY
122694: PPUSH
122695: LD_VAR 0 2
122699: PPUSH
122700: LD_VAR 0 5
122704: PPUSH
122705: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
122709: LD_VAR 0 6
122713: PUSH
122714: LD_INT 1
122716: ARRAY
122717: PPUSH
122718: LD_VAR 0 3
122722: PPUSH
122723: LD_VAR 0 4
122727: PPUSH
122728: CALL_OW 237
// end ;
122732: PPOPN 6
122734: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
122735: LD_EXP 147
122739: PUSH
122740: LD_EXP 194
122744: AND
122745: IFFALSE 122824
122747: GO 122749
122749: DISABLE
122750: LD_INT 0
122752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
122753: LD_ADDR_VAR 0 1
122757: PUSH
122758: LD_INT 22
122760: PUSH
122761: LD_OWVAR 2
122765: PUSH
122766: EMPTY
122767: LIST
122768: LIST
122769: PUSH
122770: LD_INT 30
122772: PUSH
122773: LD_INT 3
122775: PUSH
122776: EMPTY
122777: LIST
122778: LIST
122779: PUSH
122780: EMPTY
122781: LIST
122782: LIST
122783: PPUSH
122784: CALL_OW 69
122788: ST_TO_ADDR
// if not tmp then
122789: LD_VAR 0 1
122793: NOT
122794: IFFALSE 122798
// exit ;
122796: GO 122824
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122798: LD_VAR 0 1
122802: PUSH
122803: LD_INT 1
122805: PPUSH
122806: LD_VAR 0 1
122810: PPUSH
122811: CALL_OW 12
122815: ARRAY
122816: PPUSH
122817: LD_INT 1
122819: PPUSH
122820: CALL_OW 234
// end ;
122824: PPOPN 1
122826: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
122827: LD_EXP 147
122831: PUSH
122832: LD_EXP 195
122836: AND
122837: IFFALSE 122949
122839: GO 122841
122841: DISABLE
122842: LD_INT 0
122844: PPUSH
122845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
122846: LD_ADDR_VAR 0 2
122850: PUSH
122851: LD_INT 22
122853: PUSH
122854: LD_OWVAR 2
122858: PUSH
122859: EMPTY
122860: LIST
122861: LIST
122862: PUSH
122863: LD_INT 2
122865: PUSH
122866: LD_INT 30
122868: PUSH
122869: LD_INT 27
122871: PUSH
122872: EMPTY
122873: LIST
122874: LIST
122875: PUSH
122876: LD_INT 30
122878: PUSH
122879: LD_INT 26
122881: PUSH
122882: EMPTY
122883: LIST
122884: LIST
122885: PUSH
122886: LD_INT 30
122888: PUSH
122889: LD_INT 28
122891: PUSH
122892: EMPTY
122893: LIST
122894: LIST
122895: PUSH
122896: EMPTY
122897: LIST
122898: LIST
122899: LIST
122900: LIST
122901: PUSH
122902: EMPTY
122903: LIST
122904: LIST
122905: PPUSH
122906: CALL_OW 69
122910: ST_TO_ADDR
// if not tmp then
122911: LD_VAR 0 2
122915: NOT
122916: IFFALSE 122920
// exit ;
122918: GO 122949
// for i in tmp do
122920: LD_ADDR_VAR 0 1
122924: PUSH
122925: LD_VAR 0 2
122929: PUSH
122930: FOR_IN
122931: IFFALSE 122947
// SetLives ( i , 1 ) ;
122933: LD_VAR 0 1
122937: PPUSH
122938: LD_INT 1
122940: PPUSH
122941: CALL_OW 234
122945: GO 122930
122947: POP
122948: POP
// end ;
122949: PPOPN 2
122951: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
122952: LD_EXP 147
122956: PUSH
122957: LD_EXP 196
122961: AND
122962: IFFALSE 123249
122964: GO 122966
122966: DISABLE
122967: LD_INT 0
122969: PPUSH
122970: PPUSH
122971: PPUSH
// begin i := rand ( 1 , 7 ) ;
122972: LD_ADDR_VAR 0 1
122976: PUSH
122977: LD_INT 1
122979: PPUSH
122980: LD_INT 7
122982: PPUSH
122983: CALL_OW 12
122987: ST_TO_ADDR
// case i of 1 :
122988: LD_VAR 0 1
122992: PUSH
122993: LD_INT 1
122995: DOUBLE
122996: EQUAL
122997: IFTRUE 123001
122999: GO 123011
123001: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123002: LD_STRING earthquake(getX(game), 0, 32)
123004: PPUSH
123005: CALL_OW 559
123009: GO 123249
123011: LD_INT 2
123013: DOUBLE
123014: EQUAL
123015: IFTRUE 123019
123017: GO 123033
123019: POP
// begin ToLua ( displayStucuk(); ) ;
123020: LD_STRING displayStucuk();
123022: PPUSH
123023: CALL_OW 559
// ResetFog ;
123027: CALL_OW 335
// end ; 3 :
123031: GO 123249
123033: LD_INT 3
123035: DOUBLE
123036: EQUAL
123037: IFTRUE 123041
123039: GO 123145
123041: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123042: LD_ADDR_VAR 0 2
123046: PUSH
123047: LD_INT 22
123049: PUSH
123050: LD_OWVAR 2
123054: PUSH
123055: EMPTY
123056: LIST
123057: LIST
123058: PUSH
123059: LD_INT 25
123061: PUSH
123062: LD_INT 1
123064: PUSH
123065: EMPTY
123066: LIST
123067: LIST
123068: PUSH
123069: EMPTY
123070: LIST
123071: LIST
123072: PPUSH
123073: CALL_OW 69
123077: ST_TO_ADDR
// if not tmp then
123078: LD_VAR 0 2
123082: NOT
123083: IFFALSE 123087
// exit ;
123085: GO 123249
// un := tmp [ rand ( 1 , tmp ) ] ;
123087: LD_ADDR_VAR 0 3
123091: PUSH
123092: LD_VAR 0 2
123096: PUSH
123097: LD_INT 1
123099: PPUSH
123100: LD_VAR 0 2
123104: PPUSH
123105: CALL_OW 12
123109: ARRAY
123110: ST_TO_ADDR
// if Crawls ( un ) then
123111: LD_VAR 0 3
123115: PPUSH
123116: CALL_OW 318
123120: IFFALSE 123131
// ComWalk ( un ) ;
123122: LD_VAR 0 3
123126: PPUSH
123127: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123131: LD_VAR 0 3
123135: PPUSH
123136: LD_INT 8
123138: PPUSH
123139: CALL_OW 336
// end ; 4 :
123143: GO 123249
123145: LD_INT 4
123147: DOUBLE
123148: EQUAL
123149: IFTRUE 123153
123151: GO 123227
123153: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123154: LD_ADDR_VAR 0 2
123158: PUSH
123159: LD_INT 22
123161: PUSH
123162: LD_OWVAR 2
123166: PUSH
123167: EMPTY
123168: LIST
123169: LIST
123170: PUSH
123171: LD_INT 30
123173: PUSH
123174: LD_INT 29
123176: PUSH
123177: EMPTY
123178: LIST
123179: LIST
123180: PUSH
123181: EMPTY
123182: LIST
123183: LIST
123184: PPUSH
123185: CALL_OW 69
123189: ST_TO_ADDR
// if not tmp then
123190: LD_VAR 0 2
123194: NOT
123195: IFFALSE 123199
// exit ;
123197: GO 123249
// CenterNowOnUnits ( tmp [ 1 ] ) ;
123199: LD_VAR 0 2
123203: PUSH
123204: LD_INT 1
123206: ARRAY
123207: PPUSH
123208: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
123212: LD_VAR 0 2
123216: PUSH
123217: LD_INT 1
123219: ARRAY
123220: PPUSH
123221: CALL_OW 65
// end ; 5 .. 7 :
123225: GO 123249
123227: LD_INT 5
123229: DOUBLE
123230: GREATEREQUAL
123231: IFFALSE 123239
123233: LD_INT 7
123235: DOUBLE
123236: LESSEQUAL
123237: IFTRUE 123241
123239: GO 123248
123241: POP
// StreamSibBomb ; end ;
123242: CALL 119486 0 0
123246: GO 123249
123248: POP
// end ;
123249: PPOPN 3
123251: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
123252: LD_EXP 147
123256: PUSH
123257: LD_EXP 197
123261: AND
123262: IFFALSE 123418
123264: GO 123266
123266: DISABLE
123267: LD_INT 0
123269: PPUSH
123270: PPUSH
123271: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
123272: LD_ADDR_VAR 0 2
123276: PUSH
123277: LD_INT 81
123279: PUSH
123280: LD_OWVAR 2
123284: PUSH
123285: EMPTY
123286: LIST
123287: LIST
123288: PUSH
123289: LD_INT 2
123291: PUSH
123292: LD_INT 21
123294: PUSH
123295: LD_INT 1
123297: PUSH
123298: EMPTY
123299: LIST
123300: LIST
123301: PUSH
123302: LD_INT 21
123304: PUSH
123305: LD_INT 2
123307: PUSH
123308: EMPTY
123309: LIST
123310: LIST
123311: PUSH
123312: EMPTY
123313: LIST
123314: LIST
123315: LIST
123316: PUSH
123317: EMPTY
123318: LIST
123319: LIST
123320: PPUSH
123321: CALL_OW 69
123325: ST_TO_ADDR
// if not tmp then
123326: LD_VAR 0 2
123330: NOT
123331: IFFALSE 123335
// exit ;
123333: GO 123418
// p := 0 ;
123335: LD_ADDR_VAR 0 3
123339: PUSH
123340: LD_INT 0
123342: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
123343: LD_INT 35
123345: PPUSH
123346: CALL_OW 67
// p := p + 1 ;
123350: LD_ADDR_VAR 0 3
123354: PUSH
123355: LD_VAR 0 3
123359: PUSH
123360: LD_INT 1
123362: PLUS
123363: ST_TO_ADDR
// for i in tmp do
123364: LD_ADDR_VAR 0 1
123368: PUSH
123369: LD_VAR 0 2
123373: PUSH
123374: FOR_IN
123375: IFFALSE 123406
// if GetLives ( i ) < 1000 then
123377: LD_VAR 0 1
123381: PPUSH
123382: CALL_OW 256
123386: PUSH
123387: LD_INT 1000
123389: LESS
123390: IFFALSE 123404
// SetLives ( i , 1000 ) ;
123392: LD_VAR 0 1
123396: PPUSH
123397: LD_INT 1000
123399: PPUSH
123400: CALL_OW 234
123404: GO 123374
123406: POP
123407: POP
// until p > 20 ;
123408: LD_VAR 0 3
123412: PUSH
123413: LD_INT 20
123415: GREATER
123416: IFFALSE 123343
// end ;
123418: PPOPN 3
123420: END
// every 0 0$1 trigger StreamModeActive and sTime do
123421: LD_EXP 147
123425: PUSH
123426: LD_EXP 198
123430: AND
123431: IFFALSE 123466
123433: GO 123435
123435: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
123436: LD_INT 28
123438: PPUSH
123439: LD_OWVAR 2
123443: PPUSH
123444: LD_INT 2
123446: PPUSH
123447: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
123451: LD_INT 30
123453: PPUSH
123454: LD_OWVAR 2
123458: PPUSH
123459: LD_INT 2
123461: PPUSH
123462: CALL_OW 322
// end ;
123466: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
123467: LD_EXP 147
123471: PUSH
123472: LD_EXP 199
123476: AND
123477: IFFALSE 123598
123479: GO 123481
123481: DISABLE
123482: LD_INT 0
123484: PPUSH
123485: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123486: LD_ADDR_VAR 0 2
123490: PUSH
123491: LD_INT 22
123493: PUSH
123494: LD_OWVAR 2
123498: PUSH
123499: EMPTY
123500: LIST
123501: LIST
123502: PUSH
123503: LD_INT 21
123505: PUSH
123506: LD_INT 1
123508: PUSH
123509: EMPTY
123510: LIST
123511: LIST
123512: PUSH
123513: LD_INT 3
123515: PUSH
123516: LD_INT 23
123518: PUSH
123519: LD_INT 0
123521: PUSH
123522: EMPTY
123523: LIST
123524: LIST
123525: PUSH
123526: EMPTY
123527: LIST
123528: LIST
123529: PUSH
123530: EMPTY
123531: LIST
123532: LIST
123533: LIST
123534: PPUSH
123535: CALL_OW 69
123539: ST_TO_ADDR
// if not tmp then
123540: LD_VAR 0 2
123544: NOT
123545: IFFALSE 123549
// exit ;
123547: GO 123598
// for i in tmp do
123549: LD_ADDR_VAR 0 1
123553: PUSH
123554: LD_VAR 0 2
123558: PUSH
123559: FOR_IN
123560: IFFALSE 123596
// begin if Crawls ( i ) then
123562: LD_VAR 0 1
123566: PPUSH
123567: CALL_OW 318
123571: IFFALSE 123582
// ComWalk ( i ) ;
123573: LD_VAR 0 1
123577: PPUSH
123578: CALL_OW 138
// SetClass ( i , 2 ) ;
123582: LD_VAR 0 1
123586: PPUSH
123587: LD_INT 2
123589: PPUSH
123590: CALL_OW 336
// end ;
123594: GO 123559
123596: POP
123597: POP
// end ;
123598: PPOPN 2
123600: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
123601: LD_EXP 147
123605: PUSH
123606: LD_EXP 200
123610: AND
123611: IFFALSE 123899
123613: GO 123615
123615: DISABLE
123616: LD_INT 0
123618: PPUSH
123619: PPUSH
123620: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
123621: LD_OWVAR 2
123625: PPUSH
123626: LD_INT 9
123628: PPUSH
123629: LD_INT 1
123631: PPUSH
123632: LD_INT 1
123634: PPUSH
123635: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
123639: LD_INT 9
123641: PPUSH
123642: LD_OWVAR 2
123646: PPUSH
123647: CALL_OW 343
// uc_side := 9 ;
123651: LD_ADDR_OWVAR 20
123655: PUSH
123656: LD_INT 9
123658: ST_TO_ADDR
// uc_nation := 2 ;
123659: LD_ADDR_OWVAR 21
123663: PUSH
123664: LD_INT 2
123666: ST_TO_ADDR
// hc_name := Dark Warrior ;
123667: LD_ADDR_OWVAR 26
123671: PUSH
123672: LD_STRING Dark Warrior
123674: ST_TO_ADDR
// hc_gallery :=  ;
123675: LD_ADDR_OWVAR 33
123679: PUSH
123680: LD_STRING 
123682: ST_TO_ADDR
// hc_noskilllimit := true ;
123683: LD_ADDR_OWVAR 76
123687: PUSH
123688: LD_INT 1
123690: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
123691: LD_ADDR_OWVAR 31
123695: PUSH
123696: LD_INT 30
123698: PUSH
123699: LD_INT 30
123701: PUSH
123702: LD_INT 30
123704: PUSH
123705: LD_INT 30
123707: PUSH
123708: EMPTY
123709: LIST
123710: LIST
123711: LIST
123712: LIST
123713: ST_TO_ADDR
// un := CreateHuman ;
123714: LD_ADDR_VAR 0 3
123718: PUSH
123719: CALL_OW 44
123723: ST_TO_ADDR
// hc_noskilllimit := false ;
123724: LD_ADDR_OWVAR 76
123728: PUSH
123729: LD_INT 0
123731: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123732: LD_VAR 0 3
123736: PPUSH
123737: LD_INT 1
123739: PPUSH
123740: CALL_OW 51
// ToLua ( playRanger() ) ;
123744: LD_STRING playRanger()
123746: PPUSH
123747: CALL_OW 559
// p := 0 ;
123751: LD_ADDR_VAR 0 2
123755: PUSH
123756: LD_INT 0
123758: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
123759: LD_INT 35
123761: PPUSH
123762: CALL_OW 67
// p := p + 1 ;
123766: LD_ADDR_VAR 0 2
123770: PUSH
123771: LD_VAR 0 2
123775: PUSH
123776: LD_INT 1
123778: PLUS
123779: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
123780: LD_VAR 0 3
123784: PPUSH
123785: CALL_OW 256
123789: PUSH
123790: LD_INT 1000
123792: LESS
123793: IFFALSE 123807
// SetLives ( un , 1000 ) ;
123795: LD_VAR 0 3
123799: PPUSH
123800: LD_INT 1000
123802: PPUSH
123803: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
123807: LD_VAR 0 3
123811: PPUSH
123812: LD_INT 81
123814: PUSH
123815: LD_OWVAR 2
123819: PUSH
123820: EMPTY
123821: LIST
123822: LIST
123823: PUSH
123824: LD_INT 91
123826: PUSH
123827: LD_VAR 0 3
123831: PUSH
123832: LD_INT 30
123834: PUSH
123835: EMPTY
123836: LIST
123837: LIST
123838: LIST
123839: PUSH
123840: EMPTY
123841: LIST
123842: LIST
123843: PPUSH
123844: CALL_OW 69
123848: PPUSH
123849: LD_VAR 0 3
123853: PPUSH
123854: CALL_OW 74
123858: PPUSH
123859: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
123863: LD_VAR 0 2
123867: PUSH
123868: LD_INT 80
123870: GREATER
123871: PUSH
123872: LD_VAR 0 3
123876: PPUSH
123877: CALL_OW 301
123881: OR
123882: IFFALSE 123759
// if un then
123884: LD_VAR 0 3
123888: IFFALSE 123899
// RemoveUnit ( un ) ;
123890: LD_VAR 0 3
123894: PPUSH
123895: CALL_OW 64
// end ;
123899: PPOPN 3
123901: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
123902: LD_EXP 201
123906: IFFALSE 124022
123908: GO 123910
123910: DISABLE
123911: LD_INT 0
123913: PPUSH
123914: PPUSH
123915: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
123916: LD_ADDR_VAR 0 2
123920: PUSH
123921: LD_INT 81
123923: PUSH
123924: LD_OWVAR 2
123928: PUSH
123929: EMPTY
123930: LIST
123931: LIST
123932: PUSH
123933: LD_INT 21
123935: PUSH
123936: LD_INT 1
123938: PUSH
123939: EMPTY
123940: LIST
123941: LIST
123942: PUSH
123943: EMPTY
123944: LIST
123945: LIST
123946: PPUSH
123947: CALL_OW 69
123951: ST_TO_ADDR
// ToLua ( playComputer() ) ;
123952: LD_STRING playComputer()
123954: PPUSH
123955: CALL_OW 559
// if not tmp then
123959: LD_VAR 0 2
123963: NOT
123964: IFFALSE 123968
// exit ;
123966: GO 124022
// for i in tmp do
123968: LD_ADDR_VAR 0 1
123972: PUSH
123973: LD_VAR 0 2
123977: PUSH
123978: FOR_IN
123979: IFFALSE 124020
// for j := 1 to 4 do
123981: LD_ADDR_VAR 0 3
123985: PUSH
123986: DOUBLE
123987: LD_INT 1
123989: DEC
123990: ST_TO_ADDR
123991: LD_INT 4
123993: PUSH
123994: FOR_TO
123995: IFFALSE 124016
// SetSkill ( i , j , 10 ) ;
123997: LD_VAR 0 1
124001: PPUSH
124002: LD_VAR 0 3
124006: PPUSH
124007: LD_INT 10
124009: PPUSH
124010: CALL_OW 237
124014: GO 123994
124016: POP
124017: POP
124018: GO 123978
124020: POP
124021: POP
// end ;
124022: PPOPN 3
124024: END
// every 0 0$1 trigger s30 do var i , tmp ;
124025: LD_EXP 202
124029: IFFALSE 124098
124031: GO 124033
124033: DISABLE
124034: LD_INT 0
124036: PPUSH
124037: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124038: LD_ADDR_VAR 0 2
124042: PUSH
124043: LD_INT 22
124045: PUSH
124046: LD_OWVAR 2
124050: PUSH
124051: EMPTY
124052: LIST
124053: LIST
124054: PPUSH
124055: CALL_OW 69
124059: ST_TO_ADDR
// if not tmp then
124060: LD_VAR 0 2
124064: NOT
124065: IFFALSE 124069
// exit ;
124067: GO 124098
// for i in tmp do
124069: LD_ADDR_VAR 0 1
124073: PUSH
124074: LD_VAR 0 2
124078: PUSH
124079: FOR_IN
124080: IFFALSE 124096
// SetLives ( i , 300 ) ;
124082: LD_VAR 0 1
124086: PPUSH
124087: LD_INT 300
124089: PPUSH
124090: CALL_OW 234
124094: GO 124079
124096: POP
124097: POP
// end ;
124098: PPOPN 2
124100: END
// every 0 0$1 trigger s60 do var i , tmp ;
124101: LD_EXP 203
124105: IFFALSE 124174
124107: GO 124109
124109: DISABLE
124110: LD_INT 0
124112: PPUSH
124113: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124114: LD_ADDR_VAR 0 2
124118: PUSH
124119: LD_INT 22
124121: PUSH
124122: LD_OWVAR 2
124126: PUSH
124127: EMPTY
124128: LIST
124129: LIST
124130: PPUSH
124131: CALL_OW 69
124135: ST_TO_ADDR
// if not tmp then
124136: LD_VAR 0 2
124140: NOT
124141: IFFALSE 124145
// exit ;
124143: GO 124174
// for i in tmp do
124145: LD_ADDR_VAR 0 1
124149: PUSH
124150: LD_VAR 0 2
124154: PUSH
124155: FOR_IN
124156: IFFALSE 124172
// SetLives ( i , 600 ) ;
124158: LD_VAR 0 1
124162: PPUSH
124163: LD_INT 600
124165: PPUSH
124166: CALL_OW 234
124170: GO 124155
124172: POP
124173: POP
// end ;
124174: PPOPN 2
124176: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
124177: LD_INT 0
124179: PPUSH
// case cmd of 301 :
124180: LD_VAR 0 1
124184: PUSH
124185: LD_INT 301
124187: DOUBLE
124188: EQUAL
124189: IFTRUE 124193
124191: GO 124225
124193: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
124194: LD_VAR 0 6
124198: PPUSH
124199: LD_VAR 0 7
124203: PPUSH
124204: LD_VAR 0 8
124208: PPUSH
124209: LD_VAR 0 4
124213: PPUSH
124214: LD_VAR 0 5
124218: PPUSH
124219: CALL 125434 0 5
124223: GO 124346
124225: LD_INT 302
124227: DOUBLE
124228: EQUAL
124229: IFTRUE 124233
124231: GO 124270
124233: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
124234: LD_VAR 0 6
124238: PPUSH
124239: LD_VAR 0 7
124243: PPUSH
124244: LD_VAR 0 8
124248: PPUSH
124249: LD_VAR 0 9
124253: PPUSH
124254: LD_VAR 0 4
124258: PPUSH
124259: LD_VAR 0 5
124263: PPUSH
124264: CALL 125525 0 6
124268: GO 124346
124270: LD_INT 303
124272: DOUBLE
124273: EQUAL
124274: IFTRUE 124278
124276: GO 124315
124278: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
124279: LD_VAR 0 6
124283: PPUSH
124284: LD_VAR 0 7
124288: PPUSH
124289: LD_VAR 0 8
124293: PPUSH
124294: LD_VAR 0 9
124298: PPUSH
124299: LD_VAR 0 4
124303: PPUSH
124304: LD_VAR 0 5
124308: PPUSH
124309: CALL 124351 0 6
124313: GO 124346
124315: LD_INT 304
124317: DOUBLE
124318: EQUAL
124319: IFTRUE 124323
124321: GO 124345
124323: POP
// hHackTeleport ( unit , x , y ) ; end ;
124324: LD_VAR 0 2
124328: PPUSH
124329: LD_VAR 0 4
124333: PPUSH
124334: LD_VAR 0 5
124338: PPUSH
124339: CALL 126118 0 3
124343: GO 124346
124345: POP
// end ;
124346: LD_VAR 0 12
124350: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
124351: LD_INT 0
124353: PPUSH
124354: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
124355: LD_VAR 0 1
124359: PUSH
124360: LD_INT 1
124362: LESS
124363: PUSH
124364: LD_VAR 0 1
124368: PUSH
124369: LD_INT 3
124371: GREATER
124372: OR
124373: PUSH
124374: LD_VAR 0 5
124378: PPUSH
124379: LD_VAR 0 6
124383: PPUSH
124384: CALL_OW 428
124388: OR
124389: IFFALSE 124393
// exit ;
124391: GO 125121
// uc_side := your_side ;
124393: LD_ADDR_OWVAR 20
124397: PUSH
124398: LD_OWVAR 2
124402: ST_TO_ADDR
// uc_nation := nation ;
124403: LD_ADDR_OWVAR 21
124407: PUSH
124408: LD_VAR 0 1
124412: ST_TO_ADDR
// bc_level = 1 ;
124413: LD_ADDR_OWVAR 43
124417: PUSH
124418: LD_INT 1
124420: ST_TO_ADDR
// case btype of 1 :
124421: LD_VAR 0 2
124425: PUSH
124426: LD_INT 1
124428: DOUBLE
124429: EQUAL
124430: IFTRUE 124434
124432: GO 124445
124434: POP
// bc_type := b_depot ; 2 :
124435: LD_ADDR_OWVAR 42
124439: PUSH
124440: LD_INT 0
124442: ST_TO_ADDR
124443: GO 125065
124445: LD_INT 2
124447: DOUBLE
124448: EQUAL
124449: IFTRUE 124453
124451: GO 124464
124453: POP
// bc_type := b_warehouse ; 3 :
124454: LD_ADDR_OWVAR 42
124458: PUSH
124459: LD_INT 1
124461: ST_TO_ADDR
124462: GO 125065
124464: LD_INT 3
124466: DOUBLE
124467: EQUAL
124468: IFTRUE 124472
124470: GO 124483
124472: POP
// bc_type := b_lab ; 4 .. 9 :
124473: LD_ADDR_OWVAR 42
124477: PUSH
124478: LD_INT 6
124480: ST_TO_ADDR
124481: GO 125065
124483: LD_INT 4
124485: DOUBLE
124486: GREATEREQUAL
124487: IFFALSE 124495
124489: LD_INT 9
124491: DOUBLE
124492: LESSEQUAL
124493: IFTRUE 124497
124495: GO 124557
124497: POP
// begin bc_type := b_lab_half ;
124498: LD_ADDR_OWVAR 42
124502: PUSH
124503: LD_INT 7
124505: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
124506: LD_ADDR_OWVAR 44
124510: PUSH
124511: LD_INT 10
124513: PUSH
124514: LD_INT 11
124516: PUSH
124517: LD_INT 12
124519: PUSH
124520: LD_INT 15
124522: PUSH
124523: LD_INT 14
124525: PUSH
124526: LD_INT 13
124528: PUSH
124529: EMPTY
124530: LIST
124531: LIST
124532: LIST
124533: LIST
124534: LIST
124535: LIST
124536: PUSH
124537: LD_VAR 0 2
124541: PUSH
124542: LD_INT 3
124544: MINUS
124545: ARRAY
124546: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
124547: LD_ADDR_OWVAR 45
124551: PUSH
124552: LD_INT 9
124554: ST_TO_ADDR
// end ; 10 .. 13 :
124555: GO 125065
124557: LD_INT 10
124559: DOUBLE
124560: GREATEREQUAL
124561: IFFALSE 124569
124563: LD_INT 13
124565: DOUBLE
124566: LESSEQUAL
124567: IFTRUE 124571
124569: GO 124648
124571: POP
// begin bc_type := b_lab_full ;
124572: LD_ADDR_OWVAR 42
124576: PUSH
124577: LD_INT 8
124579: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
124580: LD_ADDR_OWVAR 44
124584: PUSH
124585: LD_INT 10
124587: PUSH
124588: LD_INT 12
124590: PUSH
124591: LD_INT 14
124593: PUSH
124594: LD_INT 13
124596: PUSH
124597: EMPTY
124598: LIST
124599: LIST
124600: LIST
124601: LIST
124602: PUSH
124603: LD_VAR 0 2
124607: PUSH
124608: LD_INT 9
124610: MINUS
124611: ARRAY
124612: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
124613: LD_ADDR_OWVAR 45
124617: PUSH
124618: LD_INT 11
124620: PUSH
124621: LD_INT 15
124623: PUSH
124624: LD_INT 12
124626: PUSH
124627: LD_INT 15
124629: PUSH
124630: EMPTY
124631: LIST
124632: LIST
124633: LIST
124634: LIST
124635: PUSH
124636: LD_VAR 0 2
124640: PUSH
124641: LD_INT 9
124643: MINUS
124644: ARRAY
124645: ST_TO_ADDR
// end ; 14 :
124646: GO 125065
124648: LD_INT 14
124650: DOUBLE
124651: EQUAL
124652: IFTRUE 124656
124654: GO 124667
124656: POP
// bc_type := b_workshop ; 15 :
124657: LD_ADDR_OWVAR 42
124661: PUSH
124662: LD_INT 2
124664: ST_TO_ADDR
124665: GO 125065
124667: LD_INT 15
124669: DOUBLE
124670: EQUAL
124671: IFTRUE 124675
124673: GO 124686
124675: POP
// bc_type := b_factory ; 16 :
124676: LD_ADDR_OWVAR 42
124680: PUSH
124681: LD_INT 3
124683: ST_TO_ADDR
124684: GO 125065
124686: LD_INT 16
124688: DOUBLE
124689: EQUAL
124690: IFTRUE 124694
124692: GO 124705
124694: POP
// bc_type := b_ext_gun ; 17 :
124695: LD_ADDR_OWVAR 42
124699: PUSH
124700: LD_INT 17
124702: ST_TO_ADDR
124703: GO 125065
124705: LD_INT 17
124707: DOUBLE
124708: EQUAL
124709: IFTRUE 124713
124711: GO 124741
124713: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
124714: LD_ADDR_OWVAR 42
124718: PUSH
124719: LD_INT 19
124721: PUSH
124722: LD_INT 23
124724: PUSH
124725: LD_INT 19
124727: PUSH
124728: EMPTY
124729: LIST
124730: LIST
124731: LIST
124732: PUSH
124733: LD_VAR 0 1
124737: ARRAY
124738: ST_TO_ADDR
124739: GO 125065
124741: LD_INT 18
124743: DOUBLE
124744: EQUAL
124745: IFTRUE 124749
124747: GO 124760
124749: POP
// bc_type := b_ext_radar ; 19 :
124750: LD_ADDR_OWVAR 42
124754: PUSH
124755: LD_INT 20
124757: ST_TO_ADDR
124758: GO 125065
124760: LD_INT 19
124762: DOUBLE
124763: EQUAL
124764: IFTRUE 124768
124766: GO 124779
124768: POP
// bc_type := b_ext_radio ; 20 :
124769: LD_ADDR_OWVAR 42
124773: PUSH
124774: LD_INT 22
124776: ST_TO_ADDR
124777: GO 125065
124779: LD_INT 20
124781: DOUBLE
124782: EQUAL
124783: IFTRUE 124787
124785: GO 124798
124787: POP
// bc_type := b_ext_siberium ; 21 :
124788: LD_ADDR_OWVAR 42
124792: PUSH
124793: LD_INT 21
124795: ST_TO_ADDR
124796: GO 125065
124798: LD_INT 21
124800: DOUBLE
124801: EQUAL
124802: IFTRUE 124806
124804: GO 124817
124806: POP
// bc_type := b_ext_computer ; 22 :
124807: LD_ADDR_OWVAR 42
124811: PUSH
124812: LD_INT 24
124814: ST_TO_ADDR
124815: GO 125065
124817: LD_INT 22
124819: DOUBLE
124820: EQUAL
124821: IFTRUE 124825
124823: GO 124836
124825: POP
// bc_type := b_ext_track ; 23 :
124826: LD_ADDR_OWVAR 42
124830: PUSH
124831: LD_INT 16
124833: ST_TO_ADDR
124834: GO 125065
124836: LD_INT 23
124838: DOUBLE
124839: EQUAL
124840: IFTRUE 124844
124842: GO 124855
124844: POP
// bc_type := b_ext_laser ; 24 :
124845: LD_ADDR_OWVAR 42
124849: PUSH
124850: LD_INT 25
124852: ST_TO_ADDR
124853: GO 125065
124855: LD_INT 24
124857: DOUBLE
124858: EQUAL
124859: IFTRUE 124863
124861: GO 124874
124863: POP
// bc_type := b_control_tower ; 25 :
124864: LD_ADDR_OWVAR 42
124868: PUSH
124869: LD_INT 36
124871: ST_TO_ADDR
124872: GO 125065
124874: LD_INT 25
124876: DOUBLE
124877: EQUAL
124878: IFTRUE 124882
124880: GO 124893
124882: POP
// bc_type := b_breastwork ; 26 :
124883: LD_ADDR_OWVAR 42
124887: PUSH
124888: LD_INT 31
124890: ST_TO_ADDR
124891: GO 125065
124893: LD_INT 26
124895: DOUBLE
124896: EQUAL
124897: IFTRUE 124901
124899: GO 124912
124901: POP
// bc_type := b_bunker ; 27 :
124902: LD_ADDR_OWVAR 42
124906: PUSH
124907: LD_INT 32
124909: ST_TO_ADDR
124910: GO 125065
124912: LD_INT 27
124914: DOUBLE
124915: EQUAL
124916: IFTRUE 124920
124918: GO 124931
124920: POP
// bc_type := b_turret ; 28 :
124921: LD_ADDR_OWVAR 42
124925: PUSH
124926: LD_INT 33
124928: ST_TO_ADDR
124929: GO 125065
124931: LD_INT 28
124933: DOUBLE
124934: EQUAL
124935: IFTRUE 124939
124937: GO 124950
124939: POP
// bc_type := b_armoury ; 29 :
124940: LD_ADDR_OWVAR 42
124944: PUSH
124945: LD_INT 4
124947: ST_TO_ADDR
124948: GO 125065
124950: LD_INT 29
124952: DOUBLE
124953: EQUAL
124954: IFTRUE 124958
124956: GO 124969
124958: POP
// bc_type := b_barracks ; 30 :
124959: LD_ADDR_OWVAR 42
124963: PUSH
124964: LD_INT 5
124966: ST_TO_ADDR
124967: GO 125065
124969: LD_INT 30
124971: DOUBLE
124972: EQUAL
124973: IFTRUE 124977
124975: GO 124988
124977: POP
// bc_type := b_solar_power ; 31 :
124978: LD_ADDR_OWVAR 42
124982: PUSH
124983: LD_INT 27
124985: ST_TO_ADDR
124986: GO 125065
124988: LD_INT 31
124990: DOUBLE
124991: EQUAL
124992: IFTRUE 124996
124994: GO 125007
124996: POP
// bc_type := b_oil_power ; 32 :
124997: LD_ADDR_OWVAR 42
125001: PUSH
125002: LD_INT 26
125004: ST_TO_ADDR
125005: GO 125065
125007: LD_INT 32
125009: DOUBLE
125010: EQUAL
125011: IFTRUE 125015
125013: GO 125026
125015: POP
// bc_type := b_siberite_power ; 33 :
125016: LD_ADDR_OWVAR 42
125020: PUSH
125021: LD_INT 28
125023: ST_TO_ADDR
125024: GO 125065
125026: LD_INT 33
125028: DOUBLE
125029: EQUAL
125030: IFTRUE 125034
125032: GO 125045
125034: POP
// bc_type := b_oil_mine ; 34 :
125035: LD_ADDR_OWVAR 42
125039: PUSH
125040: LD_INT 29
125042: ST_TO_ADDR
125043: GO 125065
125045: LD_INT 34
125047: DOUBLE
125048: EQUAL
125049: IFTRUE 125053
125051: GO 125064
125053: POP
// bc_type := b_siberite_mine ; end ;
125054: LD_ADDR_OWVAR 42
125058: PUSH
125059: LD_INT 30
125061: ST_TO_ADDR
125062: GO 125065
125064: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125065: LD_ADDR_VAR 0 8
125069: PUSH
125070: LD_VAR 0 5
125074: PPUSH
125075: LD_VAR 0 6
125079: PPUSH
125080: LD_VAR 0 3
125084: PPUSH
125085: CALL_OW 47
125089: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125090: LD_OWVAR 42
125094: PUSH
125095: LD_INT 32
125097: PUSH
125098: LD_INT 33
125100: PUSH
125101: EMPTY
125102: LIST
125103: LIST
125104: IN
125105: IFFALSE 125121
// PlaceWeaponTurret ( b , weapon ) ;
125107: LD_VAR 0 8
125111: PPUSH
125112: LD_VAR 0 4
125116: PPUSH
125117: CALL_OW 431
// end ;
125121: LD_VAR 0 7
125125: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125126: LD_INT 0
125128: PPUSH
125129: PPUSH
125130: PPUSH
125131: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125132: LD_ADDR_VAR 0 4
125136: PUSH
125137: LD_INT 22
125139: PUSH
125140: LD_OWVAR 2
125144: PUSH
125145: EMPTY
125146: LIST
125147: LIST
125148: PUSH
125149: LD_INT 2
125151: PUSH
125152: LD_INT 30
125154: PUSH
125155: LD_INT 0
125157: PUSH
125158: EMPTY
125159: LIST
125160: LIST
125161: PUSH
125162: LD_INT 30
125164: PUSH
125165: LD_INT 1
125167: PUSH
125168: EMPTY
125169: LIST
125170: LIST
125171: PUSH
125172: EMPTY
125173: LIST
125174: LIST
125175: LIST
125176: PUSH
125177: EMPTY
125178: LIST
125179: LIST
125180: PPUSH
125181: CALL_OW 69
125185: ST_TO_ADDR
// if not tmp then
125186: LD_VAR 0 4
125190: NOT
125191: IFFALSE 125195
// exit ;
125193: GO 125254
// for i in tmp do
125195: LD_ADDR_VAR 0 2
125199: PUSH
125200: LD_VAR 0 4
125204: PUSH
125205: FOR_IN
125206: IFFALSE 125252
// for j = 1 to 3 do
125208: LD_ADDR_VAR 0 3
125212: PUSH
125213: DOUBLE
125214: LD_INT 1
125216: DEC
125217: ST_TO_ADDR
125218: LD_INT 3
125220: PUSH
125221: FOR_TO
125222: IFFALSE 125248
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
125224: LD_VAR 0 2
125228: PPUSH
125229: CALL_OW 274
125233: PPUSH
125234: LD_VAR 0 3
125238: PPUSH
125239: LD_INT 99999
125241: PPUSH
125242: CALL_OW 277
125246: GO 125221
125248: POP
125249: POP
125250: GO 125205
125252: POP
125253: POP
// end ;
125254: LD_VAR 0 1
125258: RET
// export function hHackSetLevel10 ; var i , j ; begin
125259: LD_INT 0
125261: PPUSH
125262: PPUSH
125263: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125264: LD_ADDR_VAR 0 2
125268: PUSH
125269: LD_INT 21
125271: PUSH
125272: LD_INT 1
125274: PUSH
125275: EMPTY
125276: LIST
125277: LIST
125278: PPUSH
125279: CALL_OW 69
125283: PUSH
125284: FOR_IN
125285: IFFALSE 125337
// if IsSelected ( i ) then
125287: LD_VAR 0 2
125291: PPUSH
125292: CALL_OW 306
125296: IFFALSE 125335
// begin for j := 1 to 4 do
125298: LD_ADDR_VAR 0 3
125302: PUSH
125303: DOUBLE
125304: LD_INT 1
125306: DEC
125307: ST_TO_ADDR
125308: LD_INT 4
125310: PUSH
125311: FOR_TO
125312: IFFALSE 125333
// SetSkill ( i , j , 10 ) ;
125314: LD_VAR 0 2
125318: PPUSH
125319: LD_VAR 0 3
125323: PPUSH
125324: LD_INT 10
125326: PPUSH
125327: CALL_OW 237
125331: GO 125311
125333: POP
125334: POP
// end ;
125335: GO 125284
125337: POP
125338: POP
// end ;
125339: LD_VAR 0 1
125343: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
125344: LD_INT 0
125346: PPUSH
125347: PPUSH
125348: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
125349: LD_ADDR_VAR 0 2
125353: PUSH
125354: LD_INT 22
125356: PUSH
125357: LD_OWVAR 2
125361: PUSH
125362: EMPTY
125363: LIST
125364: LIST
125365: PUSH
125366: LD_INT 21
125368: PUSH
125369: LD_INT 1
125371: PUSH
125372: EMPTY
125373: LIST
125374: LIST
125375: PUSH
125376: EMPTY
125377: LIST
125378: LIST
125379: PPUSH
125380: CALL_OW 69
125384: PUSH
125385: FOR_IN
125386: IFFALSE 125427
// begin for j := 1 to 4 do
125388: LD_ADDR_VAR 0 3
125392: PUSH
125393: DOUBLE
125394: LD_INT 1
125396: DEC
125397: ST_TO_ADDR
125398: LD_INT 4
125400: PUSH
125401: FOR_TO
125402: IFFALSE 125423
// SetSkill ( i , j , 10 ) ;
125404: LD_VAR 0 2
125408: PPUSH
125409: LD_VAR 0 3
125413: PPUSH
125414: LD_INT 10
125416: PPUSH
125417: CALL_OW 237
125421: GO 125401
125423: POP
125424: POP
// end ;
125425: GO 125385
125427: POP
125428: POP
// end ;
125429: LD_VAR 0 1
125433: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
125434: LD_INT 0
125436: PPUSH
// uc_side := your_side ;
125437: LD_ADDR_OWVAR 20
125441: PUSH
125442: LD_OWVAR 2
125446: ST_TO_ADDR
// uc_nation := nation ;
125447: LD_ADDR_OWVAR 21
125451: PUSH
125452: LD_VAR 0 1
125456: ST_TO_ADDR
// InitHc ;
125457: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
125461: LD_INT 0
125463: PPUSH
125464: LD_VAR 0 2
125468: PPUSH
125469: LD_VAR 0 3
125473: PPUSH
125474: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
125478: LD_VAR 0 4
125482: PPUSH
125483: LD_VAR 0 5
125487: PPUSH
125488: CALL_OW 428
125492: PUSH
125493: LD_INT 0
125495: EQUAL
125496: IFFALSE 125520
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
125498: CALL_OW 44
125502: PPUSH
125503: LD_VAR 0 4
125507: PPUSH
125508: LD_VAR 0 5
125512: PPUSH
125513: LD_INT 1
125515: PPUSH
125516: CALL_OW 48
// end ;
125520: LD_VAR 0 6
125524: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
125525: LD_INT 0
125527: PPUSH
125528: PPUSH
// uc_side := your_side ;
125529: LD_ADDR_OWVAR 20
125533: PUSH
125534: LD_OWVAR 2
125538: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
125539: LD_VAR 0 1
125543: PUSH
125544: LD_INT 1
125546: PUSH
125547: LD_INT 2
125549: PUSH
125550: LD_INT 3
125552: PUSH
125553: LD_INT 4
125555: PUSH
125556: LD_INT 5
125558: PUSH
125559: EMPTY
125560: LIST
125561: LIST
125562: LIST
125563: LIST
125564: LIST
125565: IN
125566: IFFALSE 125578
// uc_nation := nation_american else
125568: LD_ADDR_OWVAR 21
125572: PUSH
125573: LD_INT 1
125575: ST_TO_ADDR
125576: GO 125621
// if chassis in [ 11 , 12 , 13 , 14 ] then
125578: LD_VAR 0 1
125582: PUSH
125583: LD_INT 11
125585: PUSH
125586: LD_INT 12
125588: PUSH
125589: LD_INT 13
125591: PUSH
125592: LD_INT 14
125594: PUSH
125595: EMPTY
125596: LIST
125597: LIST
125598: LIST
125599: LIST
125600: IN
125601: IFFALSE 125613
// uc_nation := nation_arabian else
125603: LD_ADDR_OWVAR 21
125607: PUSH
125608: LD_INT 2
125610: ST_TO_ADDR
125611: GO 125621
// uc_nation := nation_russian ;
125613: LD_ADDR_OWVAR 21
125617: PUSH
125618: LD_INT 3
125620: ST_TO_ADDR
// vc_chassis := chassis ;
125621: LD_ADDR_OWVAR 37
125625: PUSH
125626: LD_VAR 0 1
125630: ST_TO_ADDR
// vc_engine := engine ;
125631: LD_ADDR_OWVAR 39
125635: PUSH
125636: LD_VAR 0 2
125640: ST_TO_ADDR
// vc_control := control ;
125641: LD_ADDR_OWVAR 38
125645: PUSH
125646: LD_VAR 0 3
125650: ST_TO_ADDR
// vc_weapon := weapon ;
125651: LD_ADDR_OWVAR 40
125655: PUSH
125656: LD_VAR 0 4
125660: ST_TO_ADDR
// un := CreateVehicle ;
125661: LD_ADDR_VAR 0 8
125665: PUSH
125666: CALL_OW 45
125670: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
125671: LD_VAR 0 8
125675: PPUSH
125676: LD_INT 0
125678: PPUSH
125679: LD_INT 5
125681: PPUSH
125682: CALL_OW 12
125686: PPUSH
125687: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
125691: LD_VAR 0 8
125695: PPUSH
125696: LD_VAR 0 5
125700: PPUSH
125701: LD_VAR 0 6
125705: PPUSH
125706: LD_INT 1
125708: PPUSH
125709: CALL_OW 48
// end ;
125713: LD_VAR 0 7
125717: RET
// export hInvincible ; every 1 do
125718: GO 125720
125720: DISABLE
// hInvincible := [ ] ;
125721: LD_ADDR_EXP 204
125725: PUSH
125726: EMPTY
125727: ST_TO_ADDR
125728: END
// every 10 do var i ;
125729: GO 125731
125731: DISABLE
125732: LD_INT 0
125734: PPUSH
// begin enable ;
125735: ENABLE
// if not hInvincible then
125736: LD_EXP 204
125740: NOT
125741: IFFALSE 125745
// exit ;
125743: GO 125789
// for i in hInvincible do
125745: LD_ADDR_VAR 0 1
125749: PUSH
125750: LD_EXP 204
125754: PUSH
125755: FOR_IN
125756: IFFALSE 125787
// if GetLives ( i ) < 1000 then
125758: LD_VAR 0 1
125762: PPUSH
125763: CALL_OW 256
125767: PUSH
125768: LD_INT 1000
125770: LESS
125771: IFFALSE 125785
// SetLives ( i , 1000 ) ;
125773: LD_VAR 0 1
125777: PPUSH
125778: LD_INT 1000
125780: PPUSH
125781: CALL_OW 234
125785: GO 125755
125787: POP
125788: POP
// end ;
125789: PPOPN 1
125791: END
// export function hHackInvincible ; var i ; begin
125792: LD_INT 0
125794: PPUSH
125795: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
125796: LD_ADDR_VAR 0 2
125800: PUSH
125801: LD_INT 2
125803: PUSH
125804: LD_INT 21
125806: PUSH
125807: LD_INT 1
125809: PUSH
125810: EMPTY
125811: LIST
125812: LIST
125813: PUSH
125814: LD_INT 21
125816: PUSH
125817: LD_INT 2
125819: PUSH
125820: EMPTY
125821: LIST
125822: LIST
125823: PUSH
125824: EMPTY
125825: LIST
125826: LIST
125827: LIST
125828: PPUSH
125829: CALL_OW 69
125833: PUSH
125834: FOR_IN
125835: IFFALSE 125896
// if IsSelected ( i ) then
125837: LD_VAR 0 2
125841: PPUSH
125842: CALL_OW 306
125846: IFFALSE 125894
// begin if i in hInvincible then
125848: LD_VAR 0 2
125852: PUSH
125853: LD_EXP 204
125857: IN
125858: IFFALSE 125878
// hInvincible := hInvincible diff i else
125860: LD_ADDR_EXP 204
125864: PUSH
125865: LD_EXP 204
125869: PUSH
125870: LD_VAR 0 2
125874: DIFF
125875: ST_TO_ADDR
125876: GO 125894
// hInvincible := hInvincible union i ;
125878: LD_ADDR_EXP 204
125882: PUSH
125883: LD_EXP 204
125887: PUSH
125888: LD_VAR 0 2
125892: UNION
125893: ST_TO_ADDR
// end ;
125894: GO 125834
125896: POP
125897: POP
// end ;
125898: LD_VAR 0 1
125902: RET
// export function hHackInvisible ; var i , j ; begin
125903: LD_INT 0
125905: PPUSH
125906: PPUSH
125907: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125908: LD_ADDR_VAR 0 2
125912: PUSH
125913: LD_INT 21
125915: PUSH
125916: LD_INT 1
125918: PUSH
125919: EMPTY
125920: LIST
125921: LIST
125922: PPUSH
125923: CALL_OW 69
125927: PUSH
125928: FOR_IN
125929: IFFALSE 125953
// if IsSelected ( i ) then
125931: LD_VAR 0 2
125935: PPUSH
125936: CALL_OW 306
125940: IFFALSE 125951
// ComForceInvisible ( i ) ;
125942: LD_VAR 0 2
125946: PPUSH
125947: CALL_OW 496
125951: GO 125928
125953: POP
125954: POP
// end ;
125955: LD_VAR 0 1
125959: RET
// export function hHackChangeYourSide ; begin
125960: LD_INT 0
125962: PPUSH
// if your_side = 8 then
125963: LD_OWVAR 2
125967: PUSH
125968: LD_INT 8
125970: EQUAL
125971: IFFALSE 125983
// your_side := 0 else
125973: LD_ADDR_OWVAR 2
125977: PUSH
125978: LD_INT 0
125980: ST_TO_ADDR
125981: GO 125997
// your_side := your_side + 1 ;
125983: LD_ADDR_OWVAR 2
125987: PUSH
125988: LD_OWVAR 2
125992: PUSH
125993: LD_INT 1
125995: PLUS
125996: ST_TO_ADDR
// end ;
125997: LD_VAR 0 1
126001: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126002: LD_INT 0
126004: PPUSH
126005: PPUSH
126006: PPUSH
// for i in all_units do
126007: LD_ADDR_VAR 0 2
126011: PUSH
126012: LD_OWVAR 3
126016: PUSH
126017: FOR_IN
126018: IFFALSE 126096
// if IsSelected ( i ) then
126020: LD_VAR 0 2
126024: PPUSH
126025: CALL_OW 306
126029: IFFALSE 126094
// begin j := GetSide ( i ) ;
126031: LD_ADDR_VAR 0 3
126035: PUSH
126036: LD_VAR 0 2
126040: PPUSH
126041: CALL_OW 255
126045: ST_TO_ADDR
// if j = 8 then
126046: LD_VAR 0 3
126050: PUSH
126051: LD_INT 8
126053: EQUAL
126054: IFFALSE 126066
// j := 0 else
126056: LD_ADDR_VAR 0 3
126060: PUSH
126061: LD_INT 0
126063: ST_TO_ADDR
126064: GO 126080
// j := j + 1 ;
126066: LD_ADDR_VAR 0 3
126070: PUSH
126071: LD_VAR 0 3
126075: PUSH
126076: LD_INT 1
126078: PLUS
126079: ST_TO_ADDR
// SetSide ( i , j ) ;
126080: LD_VAR 0 2
126084: PPUSH
126085: LD_VAR 0 3
126089: PPUSH
126090: CALL_OW 235
// end ;
126094: GO 126017
126096: POP
126097: POP
// end ;
126098: LD_VAR 0 1
126102: RET
// export function hHackFog ; begin
126103: LD_INT 0
126105: PPUSH
// FogOff ( true ) ;
126106: LD_INT 1
126108: PPUSH
126109: CALL_OW 344
// end ;
126113: LD_VAR 0 1
126117: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126118: LD_INT 0
126120: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126121: LD_VAR 0 1
126125: PPUSH
126126: LD_VAR 0 2
126130: PPUSH
126131: LD_VAR 0 3
126135: PPUSH
126136: LD_INT 1
126138: PPUSH
126139: LD_INT 1
126141: PPUSH
126142: CALL_OW 483
// CenterOnXY ( x , y ) ;
126146: LD_VAR 0 2
126150: PPUSH
126151: LD_VAR 0 3
126155: PPUSH
126156: CALL_OW 84
// end ;
126160: LD_VAR 0 4
126164: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126165: LD_INT 0
126167: PPUSH
126168: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
126169: LD_VAR 0 1
126173: NOT
126174: PUSH
126175: LD_VAR 0 2
126179: PPUSH
126180: LD_VAR 0 3
126184: PPUSH
126185: CALL_OW 488
126189: NOT
126190: OR
126191: PUSH
126192: LD_VAR 0 1
126196: PPUSH
126197: CALL_OW 266
126201: PUSH
126202: LD_INT 3
126204: NONEQUAL
126205: PUSH
126206: LD_VAR 0 1
126210: PPUSH
126211: CALL_OW 247
126215: PUSH
126216: LD_INT 1
126218: EQUAL
126219: NOT
126220: AND
126221: OR
126222: IFFALSE 126226
// exit ;
126224: GO 126375
// if GetType ( factory ) = unit_human then
126226: LD_VAR 0 1
126230: PPUSH
126231: CALL_OW 247
126235: PUSH
126236: LD_INT 1
126238: EQUAL
126239: IFFALSE 126256
// factory := IsInUnit ( factory ) ;
126241: LD_ADDR_VAR 0 1
126245: PUSH
126246: LD_VAR 0 1
126250: PPUSH
126251: CALL_OW 310
126255: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
126256: LD_VAR 0 1
126260: PPUSH
126261: CALL_OW 266
126265: PUSH
126266: LD_INT 3
126268: NONEQUAL
126269: IFFALSE 126273
// exit ;
126271: GO 126375
// if HexInfo ( x , y ) = factory then
126273: LD_VAR 0 2
126277: PPUSH
126278: LD_VAR 0 3
126282: PPUSH
126283: CALL_OW 428
126287: PUSH
126288: LD_VAR 0 1
126292: EQUAL
126293: IFFALSE 126320
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
126295: LD_ADDR_EXP 205
126299: PUSH
126300: LD_EXP 205
126304: PPUSH
126305: LD_VAR 0 1
126309: PPUSH
126310: LD_INT 0
126312: PPUSH
126313: CALL_OW 1
126317: ST_TO_ADDR
126318: GO 126371
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
126320: LD_ADDR_EXP 205
126324: PUSH
126325: LD_EXP 205
126329: PPUSH
126330: LD_VAR 0 1
126334: PPUSH
126335: LD_VAR 0 1
126339: PPUSH
126340: CALL_OW 255
126344: PUSH
126345: LD_VAR 0 1
126349: PUSH
126350: LD_VAR 0 2
126354: PUSH
126355: LD_VAR 0 3
126359: PUSH
126360: EMPTY
126361: LIST
126362: LIST
126363: LIST
126364: LIST
126365: PPUSH
126366: CALL_OW 1
126370: ST_TO_ADDR
// UpdateFactoryWaypoints ;
126371: CALL 126380 0 0
// end ;
126375: LD_VAR 0 4
126379: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
126380: LD_INT 0
126382: PPUSH
126383: PPUSH
126384: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
126385: LD_STRING resetFactoryWaypoint();
126387: PPUSH
126388: CALL_OW 559
// if factoryWaypoints then
126392: LD_EXP 205
126396: IFFALSE 126522
// begin list := PrepareArray ( factoryWaypoints ) ;
126398: LD_ADDR_VAR 0 3
126402: PUSH
126403: LD_EXP 205
126407: PPUSH
126408: CALL 110902 0 1
126412: ST_TO_ADDR
// for i := 1 to list do
126413: LD_ADDR_VAR 0 2
126417: PUSH
126418: DOUBLE
126419: LD_INT 1
126421: DEC
126422: ST_TO_ADDR
126423: LD_VAR 0 3
126427: PUSH
126428: FOR_TO
126429: IFFALSE 126520
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
126431: LD_STRING setFactoryWaypointXY(
126433: PUSH
126434: LD_VAR 0 3
126438: PUSH
126439: LD_VAR 0 2
126443: ARRAY
126444: PUSH
126445: LD_INT 1
126447: ARRAY
126448: STR
126449: PUSH
126450: LD_STRING ,
126452: STR
126453: PUSH
126454: LD_VAR 0 3
126458: PUSH
126459: LD_VAR 0 2
126463: ARRAY
126464: PUSH
126465: LD_INT 2
126467: ARRAY
126468: STR
126469: PUSH
126470: LD_STRING ,
126472: STR
126473: PUSH
126474: LD_VAR 0 3
126478: PUSH
126479: LD_VAR 0 2
126483: ARRAY
126484: PUSH
126485: LD_INT 3
126487: ARRAY
126488: STR
126489: PUSH
126490: LD_STRING ,
126492: STR
126493: PUSH
126494: LD_VAR 0 3
126498: PUSH
126499: LD_VAR 0 2
126503: ARRAY
126504: PUSH
126505: LD_INT 4
126507: ARRAY
126508: STR
126509: PUSH
126510: LD_STRING )
126512: STR
126513: PPUSH
126514: CALL_OW 559
126518: GO 126428
126520: POP
126521: POP
// end ; end ;
126522: LD_VAR 0 1
126526: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
126527: LD_INT 0
126529: PPUSH
// if HexInfo ( x , y ) = warehouse then
126530: LD_VAR 0 2
126534: PPUSH
126535: LD_VAR 0 3
126539: PPUSH
126540: CALL_OW 428
126544: PUSH
126545: LD_VAR 0 1
126549: EQUAL
126550: IFFALSE 126577
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
126552: LD_ADDR_EXP 206
126556: PUSH
126557: LD_EXP 206
126561: PPUSH
126562: LD_VAR 0 1
126566: PPUSH
126567: LD_INT 0
126569: PPUSH
126570: CALL_OW 1
126574: ST_TO_ADDR
126575: GO 126628
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
126577: LD_ADDR_EXP 206
126581: PUSH
126582: LD_EXP 206
126586: PPUSH
126587: LD_VAR 0 1
126591: PPUSH
126592: LD_VAR 0 1
126596: PPUSH
126597: CALL_OW 255
126601: PUSH
126602: LD_VAR 0 1
126606: PUSH
126607: LD_VAR 0 2
126611: PUSH
126612: LD_VAR 0 3
126616: PUSH
126617: EMPTY
126618: LIST
126619: LIST
126620: LIST
126621: LIST
126622: PPUSH
126623: CALL_OW 1
126627: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
126628: CALL 126637 0 0
// end ;
126632: LD_VAR 0 4
126636: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
126637: LD_INT 0
126639: PPUSH
126640: PPUSH
126641: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
126642: LD_STRING resetWarehouseGatheringPoints();
126644: PPUSH
126645: CALL_OW 559
// if warehouseGatheringPoints then
126649: LD_EXP 206
126653: IFFALSE 126779
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
126655: LD_ADDR_VAR 0 3
126659: PUSH
126660: LD_EXP 206
126664: PPUSH
126665: CALL 110902 0 1
126669: ST_TO_ADDR
// for i := 1 to list do
126670: LD_ADDR_VAR 0 2
126674: PUSH
126675: DOUBLE
126676: LD_INT 1
126678: DEC
126679: ST_TO_ADDR
126680: LD_VAR 0 3
126684: PUSH
126685: FOR_TO
126686: IFFALSE 126777
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
126688: LD_STRING setWarehouseGatheringPointXY(
126690: PUSH
126691: LD_VAR 0 3
126695: PUSH
126696: LD_VAR 0 2
126700: ARRAY
126701: PUSH
126702: LD_INT 1
126704: ARRAY
126705: STR
126706: PUSH
126707: LD_STRING ,
126709: STR
126710: PUSH
126711: LD_VAR 0 3
126715: PUSH
126716: LD_VAR 0 2
126720: ARRAY
126721: PUSH
126722: LD_INT 2
126724: ARRAY
126725: STR
126726: PUSH
126727: LD_STRING ,
126729: STR
126730: PUSH
126731: LD_VAR 0 3
126735: PUSH
126736: LD_VAR 0 2
126740: ARRAY
126741: PUSH
126742: LD_INT 3
126744: ARRAY
126745: STR
126746: PUSH
126747: LD_STRING ,
126749: STR
126750: PUSH
126751: LD_VAR 0 3
126755: PUSH
126756: LD_VAR 0 2
126760: ARRAY
126761: PUSH
126762: LD_INT 4
126764: ARRAY
126765: STR
126766: PUSH
126767: LD_STRING )
126769: STR
126770: PPUSH
126771: CALL_OW 559
126775: GO 126685
126777: POP
126778: POP
// end ; end ;
126779: LD_VAR 0 1
126783: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
126784: LD_EXP 206
126788: IFFALSE 127473
126790: GO 126792
126792: DISABLE
126793: LD_INT 0
126795: PPUSH
126796: PPUSH
126797: PPUSH
126798: PPUSH
126799: PPUSH
126800: PPUSH
126801: PPUSH
126802: PPUSH
126803: PPUSH
// begin enable ;
126804: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
126805: LD_ADDR_VAR 0 3
126809: PUSH
126810: LD_EXP 206
126814: PPUSH
126815: CALL 110902 0 1
126819: ST_TO_ADDR
// if not list then
126820: LD_VAR 0 3
126824: NOT
126825: IFFALSE 126829
// exit ;
126827: GO 127473
// for i := 1 to list do
126829: LD_ADDR_VAR 0 1
126833: PUSH
126834: DOUBLE
126835: LD_INT 1
126837: DEC
126838: ST_TO_ADDR
126839: LD_VAR 0 3
126843: PUSH
126844: FOR_TO
126845: IFFALSE 127471
// begin depot := list [ i ] [ 2 ] ;
126847: LD_ADDR_VAR 0 8
126851: PUSH
126852: LD_VAR 0 3
126856: PUSH
126857: LD_VAR 0 1
126861: ARRAY
126862: PUSH
126863: LD_INT 2
126865: ARRAY
126866: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
126867: LD_ADDR_VAR 0 5
126871: PUSH
126872: LD_VAR 0 3
126876: PUSH
126877: LD_VAR 0 1
126881: ARRAY
126882: PUSH
126883: LD_INT 1
126885: ARRAY
126886: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
126887: LD_VAR 0 8
126891: PPUSH
126892: CALL_OW 301
126896: PUSH
126897: LD_VAR 0 5
126901: PUSH
126902: LD_VAR 0 8
126906: PPUSH
126907: CALL_OW 255
126911: NONEQUAL
126912: OR
126913: IFFALSE 126942
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
126915: LD_ADDR_EXP 206
126919: PUSH
126920: LD_EXP 206
126924: PPUSH
126925: LD_VAR 0 8
126929: PPUSH
126930: LD_INT 0
126932: PPUSH
126933: CALL_OW 1
126937: ST_TO_ADDR
// exit ;
126938: POP
126939: POP
126940: GO 127473
// end ; x := list [ i ] [ 3 ] ;
126942: LD_ADDR_VAR 0 6
126946: PUSH
126947: LD_VAR 0 3
126951: PUSH
126952: LD_VAR 0 1
126956: ARRAY
126957: PUSH
126958: LD_INT 3
126960: ARRAY
126961: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
126962: LD_ADDR_VAR 0 7
126966: PUSH
126967: LD_VAR 0 3
126971: PUSH
126972: LD_VAR 0 1
126976: ARRAY
126977: PUSH
126978: LD_INT 4
126980: ARRAY
126981: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
126982: LD_ADDR_VAR 0 9
126986: PUSH
126987: LD_VAR 0 6
126991: PPUSH
126992: LD_VAR 0 7
126996: PPUSH
126997: LD_INT 16
126999: PPUSH
127000: CALL 109490 0 3
127004: ST_TO_ADDR
// if not cratesNearbyPoint then
127005: LD_VAR 0 9
127009: NOT
127010: IFFALSE 127016
// exit ;
127012: POP
127013: POP
127014: GO 127473
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127016: LD_ADDR_VAR 0 4
127020: PUSH
127021: LD_INT 22
127023: PUSH
127024: LD_VAR 0 5
127028: PUSH
127029: EMPTY
127030: LIST
127031: LIST
127032: PUSH
127033: LD_INT 3
127035: PUSH
127036: LD_INT 60
127038: PUSH
127039: EMPTY
127040: LIST
127041: PUSH
127042: EMPTY
127043: LIST
127044: LIST
127045: PUSH
127046: LD_INT 91
127048: PUSH
127049: LD_VAR 0 8
127053: PUSH
127054: LD_INT 6
127056: PUSH
127057: EMPTY
127058: LIST
127059: LIST
127060: LIST
127061: PUSH
127062: LD_INT 2
127064: PUSH
127065: LD_INT 25
127067: PUSH
127068: LD_INT 2
127070: PUSH
127071: EMPTY
127072: LIST
127073: LIST
127074: PUSH
127075: LD_INT 25
127077: PUSH
127078: LD_INT 16
127080: PUSH
127081: EMPTY
127082: LIST
127083: LIST
127084: PUSH
127085: EMPTY
127086: LIST
127087: LIST
127088: LIST
127089: PUSH
127090: EMPTY
127091: LIST
127092: LIST
127093: LIST
127094: LIST
127095: PPUSH
127096: CALL_OW 69
127100: PUSH
127101: LD_VAR 0 8
127105: PPUSH
127106: CALL_OW 313
127110: PPUSH
127111: LD_INT 3
127113: PUSH
127114: LD_INT 60
127116: PUSH
127117: EMPTY
127118: LIST
127119: PUSH
127120: EMPTY
127121: LIST
127122: LIST
127123: PUSH
127124: LD_INT 2
127126: PUSH
127127: LD_INT 25
127129: PUSH
127130: LD_INT 2
127132: PUSH
127133: EMPTY
127134: LIST
127135: LIST
127136: PUSH
127137: LD_INT 25
127139: PUSH
127140: LD_INT 16
127142: PUSH
127143: EMPTY
127144: LIST
127145: LIST
127146: PUSH
127147: EMPTY
127148: LIST
127149: LIST
127150: LIST
127151: PUSH
127152: EMPTY
127153: LIST
127154: LIST
127155: PPUSH
127156: CALL_OW 72
127160: UNION
127161: ST_TO_ADDR
// if tmp then
127162: LD_VAR 0 4
127166: IFFALSE 127246
// begin tmp := ShrinkArray ( tmp , 3 ) ;
127168: LD_ADDR_VAR 0 4
127172: PUSH
127173: LD_VAR 0 4
127177: PPUSH
127178: LD_INT 3
127180: PPUSH
127181: CALL 107459 0 2
127185: ST_TO_ADDR
// for j in tmp do
127186: LD_ADDR_VAR 0 2
127190: PUSH
127191: LD_VAR 0 4
127195: PUSH
127196: FOR_IN
127197: IFFALSE 127240
// begin if IsInUnit ( j ) then
127199: LD_VAR 0 2
127203: PPUSH
127204: CALL_OW 310
127208: IFFALSE 127219
// ComExit ( j ) ;
127210: LD_VAR 0 2
127214: PPUSH
127215: CALL 107542 0 1
// AddComCollect ( j , x , y ) ;
127219: LD_VAR 0 2
127223: PPUSH
127224: LD_VAR 0 6
127228: PPUSH
127229: LD_VAR 0 7
127233: PPUSH
127234: CALL_OW 177
// end ;
127238: GO 127196
127240: POP
127241: POP
// exit ;
127242: POP
127243: POP
127244: GO 127473
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
127246: LD_ADDR_VAR 0 4
127250: PUSH
127251: LD_INT 22
127253: PUSH
127254: LD_VAR 0 5
127258: PUSH
127259: EMPTY
127260: LIST
127261: LIST
127262: PUSH
127263: LD_INT 91
127265: PUSH
127266: LD_VAR 0 8
127270: PUSH
127271: LD_INT 8
127273: PUSH
127274: EMPTY
127275: LIST
127276: LIST
127277: LIST
127278: PUSH
127279: LD_INT 2
127281: PUSH
127282: LD_INT 34
127284: PUSH
127285: LD_INT 12
127287: PUSH
127288: EMPTY
127289: LIST
127290: LIST
127291: PUSH
127292: LD_INT 34
127294: PUSH
127295: LD_INT 51
127297: PUSH
127298: EMPTY
127299: LIST
127300: LIST
127301: PUSH
127302: LD_INT 34
127304: PUSH
127305: LD_INT 32
127307: PUSH
127308: EMPTY
127309: LIST
127310: LIST
127311: PUSH
127312: LD_INT 34
127314: PUSH
127315: LD_INT 89
127317: PUSH
127318: EMPTY
127319: LIST
127320: LIST
127321: PUSH
127322: EMPTY
127323: LIST
127324: LIST
127325: LIST
127326: LIST
127327: LIST
127328: PUSH
127329: EMPTY
127330: LIST
127331: LIST
127332: LIST
127333: PPUSH
127334: CALL_OW 69
127338: ST_TO_ADDR
// if tmp then
127339: LD_VAR 0 4
127343: IFFALSE 127469
// begin for j in tmp do
127345: LD_ADDR_VAR 0 2
127349: PUSH
127350: LD_VAR 0 4
127354: PUSH
127355: FOR_IN
127356: IFFALSE 127467
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
127358: LD_VAR 0 2
127362: PPUSH
127363: CALL_OW 262
127367: PUSH
127368: LD_INT 3
127370: EQUAL
127371: PUSH
127372: LD_VAR 0 2
127376: PPUSH
127377: CALL_OW 261
127381: PUSH
127382: LD_INT 20
127384: GREATER
127385: OR
127386: PUSH
127387: LD_VAR 0 2
127391: PPUSH
127392: CALL_OW 314
127396: NOT
127397: AND
127398: PUSH
127399: LD_VAR 0 2
127403: PPUSH
127404: CALL_OW 263
127408: PUSH
127409: LD_INT 1
127411: NONEQUAL
127412: PUSH
127413: LD_VAR 0 2
127417: PPUSH
127418: CALL_OW 311
127422: OR
127423: AND
127424: IFFALSE 127465
// begin ComCollect ( j , x , y ) ;
127426: LD_VAR 0 2
127430: PPUSH
127431: LD_VAR 0 6
127435: PPUSH
127436: LD_VAR 0 7
127440: PPUSH
127441: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
127445: LD_VAR 0 2
127449: PPUSH
127450: LD_VAR 0 8
127454: PPUSH
127455: CALL_OW 172
// exit ;
127459: POP
127460: POP
127461: POP
127462: POP
127463: GO 127473
// end ;
127465: GO 127355
127467: POP
127468: POP
// end ; end ;
127469: GO 126844
127471: POP
127472: POP
// end ; end_of_file
127473: PPOPN 9
127475: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
127476: LD_INT 0
127478: PPUSH
127479: PPUSH
127480: PPUSH
127481: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
127482: LD_VAR 0 1
127486: PPUSH
127487: CALL_OW 264
127491: PUSH
127492: LD_INT 91
127494: EQUAL
127495: IFFALSE 127567
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
127497: LD_INT 68
127499: PPUSH
127500: LD_VAR 0 1
127504: PPUSH
127505: CALL_OW 255
127509: PPUSH
127510: CALL_OW 321
127514: PUSH
127515: LD_INT 2
127517: EQUAL
127518: IFFALSE 127530
// eff := 70 else
127520: LD_ADDR_VAR 0 4
127524: PUSH
127525: LD_INT 70
127527: ST_TO_ADDR
127528: GO 127538
// eff := 30 ;
127530: LD_ADDR_VAR 0 4
127534: PUSH
127535: LD_INT 30
127537: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
127538: LD_VAR 0 1
127542: PPUSH
127543: CALL_OW 250
127547: PPUSH
127548: LD_VAR 0 1
127552: PPUSH
127553: CALL_OW 251
127557: PPUSH
127558: LD_VAR 0 4
127562: PPUSH
127563: CALL_OW 495
// end ; end ;
127567: LD_VAR 0 2
127571: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
127572: LD_INT 0
127574: PPUSH
// end ;
127575: LD_VAR 0 4
127579: RET
// export function SOS_Command ( cmd ) ; begin
127580: LD_INT 0
127582: PPUSH
// end ;
127583: LD_VAR 0 2
127587: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
127588: LD_INT 0
127590: PPUSH
// end ;
127591: LD_VAR 0 6
127595: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
127596: LD_INT 0
127598: PPUSH
127599: PPUSH
// if not vehicle or not factory then
127600: LD_VAR 0 1
127604: NOT
127605: PUSH
127606: LD_VAR 0 2
127610: NOT
127611: OR
127612: IFFALSE 127616
// exit ;
127614: GO 127847
// if factoryWaypoints >= factory then
127616: LD_EXP 205
127620: PUSH
127621: LD_VAR 0 2
127625: GREATEREQUAL
127626: IFFALSE 127847
// if factoryWaypoints [ factory ] then
127628: LD_EXP 205
127632: PUSH
127633: LD_VAR 0 2
127637: ARRAY
127638: IFFALSE 127847
// begin if GetControl ( vehicle ) = control_manual then
127640: LD_VAR 0 1
127644: PPUSH
127645: CALL_OW 263
127649: PUSH
127650: LD_INT 1
127652: EQUAL
127653: IFFALSE 127734
// begin driver := IsDrivenBy ( vehicle ) ;
127655: LD_ADDR_VAR 0 4
127659: PUSH
127660: LD_VAR 0 1
127664: PPUSH
127665: CALL_OW 311
127669: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
127670: LD_VAR 0 4
127674: PPUSH
127675: LD_EXP 205
127679: PUSH
127680: LD_VAR 0 2
127684: ARRAY
127685: PUSH
127686: LD_INT 3
127688: ARRAY
127689: PPUSH
127690: LD_EXP 205
127694: PUSH
127695: LD_VAR 0 2
127699: ARRAY
127700: PUSH
127701: LD_INT 4
127703: ARRAY
127704: PPUSH
127705: CALL_OW 171
// AddComExitVehicle ( driver ) ;
127709: LD_VAR 0 4
127713: PPUSH
127714: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
127718: LD_VAR 0 4
127722: PPUSH
127723: LD_VAR 0 2
127727: PPUSH
127728: CALL_OW 180
// end else
127732: GO 127847
// if GetControl ( vehicle ) = control_remote then
127734: LD_VAR 0 1
127738: PPUSH
127739: CALL_OW 263
127743: PUSH
127744: LD_INT 2
127746: EQUAL
127747: IFFALSE 127808
// begin wait ( 0 0$2 ) ;
127749: LD_INT 70
127751: PPUSH
127752: CALL_OW 67
// if Connect ( vehicle ) then
127756: LD_VAR 0 1
127760: PPUSH
127761: CALL 77750 0 1
127765: IFFALSE 127806
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
127767: LD_VAR 0 1
127771: PPUSH
127772: LD_EXP 205
127776: PUSH
127777: LD_VAR 0 2
127781: ARRAY
127782: PUSH
127783: LD_INT 3
127785: ARRAY
127786: PPUSH
127787: LD_EXP 205
127791: PUSH
127792: LD_VAR 0 2
127796: ARRAY
127797: PUSH
127798: LD_INT 4
127800: ARRAY
127801: PPUSH
127802: CALL_OW 171
// end else
127806: GO 127847
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
127808: LD_VAR 0 1
127812: PPUSH
127813: LD_EXP 205
127817: PUSH
127818: LD_VAR 0 2
127822: ARRAY
127823: PUSH
127824: LD_INT 3
127826: ARRAY
127827: PPUSH
127828: LD_EXP 205
127832: PUSH
127833: LD_VAR 0 2
127837: ARRAY
127838: PUSH
127839: LD_INT 4
127841: ARRAY
127842: PPUSH
127843: CALL_OW 171
// end ; end ;
127847: LD_VAR 0 3
127851: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
127852: LD_INT 0
127854: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
127855: LD_VAR 0 1
127859: PUSH
127860: LD_INT 250
127862: EQUAL
127863: PUSH
127864: LD_VAR 0 2
127868: PPUSH
127869: CALL_OW 264
127873: PUSH
127874: LD_INT 81
127876: EQUAL
127877: AND
127878: IFFALSE 127899
// MinerPlaceMine ( unit , x , y ) ;
127880: LD_VAR 0 2
127884: PPUSH
127885: LD_VAR 0 4
127889: PPUSH
127890: LD_VAR 0 5
127894: PPUSH
127895: CALL 130889 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
127899: LD_VAR 0 1
127903: PUSH
127904: LD_INT 251
127906: EQUAL
127907: PUSH
127908: LD_VAR 0 2
127912: PPUSH
127913: CALL_OW 264
127917: PUSH
127918: LD_INT 81
127920: EQUAL
127921: AND
127922: IFFALSE 127943
// MinerDetonateMine ( unit , x , y ) ;
127924: LD_VAR 0 2
127928: PPUSH
127929: LD_VAR 0 4
127933: PPUSH
127934: LD_VAR 0 5
127938: PPUSH
127939: CALL 131164 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
127943: LD_VAR 0 1
127947: PUSH
127948: LD_INT 252
127950: EQUAL
127951: PUSH
127952: LD_VAR 0 2
127956: PPUSH
127957: CALL_OW 264
127961: PUSH
127962: LD_INT 81
127964: EQUAL
127965: AND
127966: IFFALSE 127987
// MinerCreateMinefield ( unit , x , y ) ;
127968: LD_VAR 0 2
127972: PPUSH
127973: LD_VAR 0 4
127977: PPUSH
127978: LD_VAR 0 5
127982: PPUSH
127983: CALL 131581 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
127987: LD_VAR 0 1
127991: PUSH
127992: LD_INT 253
127994: EQUAL
127995: PUSH
127996: LD_VAR 0 2
128000: PPUSH
128001: CALL_OW 257
128005: PUSH
128006: LD_INT 5
128008: EQUAL
128009: AND
128010: IFFALSE 128031
// ComBinocular ( unit , x , y ) ;
128012: LD_VAR 0 2
128016: PPUSH
128017: LD_VAR 0 4
128021: PPUSH
128022: LD_VAR 0 5
128026: PPUSH
128027: CALL 131950 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128031: LD_VAR 0 1
128035: PUSH
128036: LD_INT 254
128038: EQUAL
128039: PUSH
128040: LD_VAR 0 2
128044: PPUSH
128045: CALL_OW 264
128049: PUSH
128050: LD_INT 99
128052: EQUAL
128053: AND
128054: PUSH
128055: LD_VAR 0 3
128059: PPUSH
128060: CALL_OW 263
128064: PUSH
128065: LD_INT 3
128067: EQUAL
128068: AND
128069: IFFALSE 128085
// HackDestroyVehicle ( unit , selectedUnit ) ;
128071: LD_VAR 0 2
128075: PPUSH
128076: LD_VAR 0 3
128080: PPUSH
128081: CALL 130253 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128085: LD_VAR 0 1
128089: PUSH
128090: LD_INT 255
128092: EQUAL
128093: PUSH
128094: LD_VAR 0 2
128098: PPUSH
128099: CALL_OW 264
128103: PUSH
128104: LD_INT 14
128106: PUSH
128107: LD_INT 53
128109: PUSH
128110: EMPTY
128111: LIST
128112: LIST
128113: IN
128114: AND
128115: PUSH
128116: LD_VAR 0 4
128120: PPUSH
128121: LD_VAR 0 5
128125: PPUSH
128126: CALL_OW 488
128130: AND
128131: IFFALSE 128155
// CutTreeXYR ( unit , x , y , 12 ) ;
128133: LD_VAR 0 2
128137: PPUSH
128138: LD_VAR 0 4
128142: PPUSH
128143: LD_VAR 0 5
128147: PPUSH
128148: LD_INT 12
128150: PPUSH
128151: CALL 128250 0 4
// if cmd = 256 then
128155: LD_VAR 0 1
128159: PUSH
128160: LD_INT 256
128162: EQUAL
128163: IFFALSE 128184
// SetFactoryWaypoint ( unit , x , y ) ;
128165: LD_VAR 0 2
128169: PPUSH
128170: LD_VAR 0 4
128174: PPUSH
128175: LD_VAR 0 5
128179: PPUSH
128180: CALL 126165 0 3
// if cmd = 257 then
128184: LD_VAR 0 1
128188: PUSH
128189: LD_INT 257
128191: EQUAL
128192: IFFALSE 128213
// SetWarehouseGatheringPoint ( unit , x , y ) ;
128194: LD_VAR 0 2
128198: PPUSH
128199: LD_VAR 0 4
128203: PPUSH
128204: LD_VAR 0 5
128208: PPUSH
128209: CALL 126527 0 3
// if cmd = 258 then
128213: LD_VAR 0 1
128217: PUSH
128218: LD_INT 258
128220: EQUAL
128221: IFFALSE 128245
// BurnTreeXYR ( unit , x , y , 8 ) ;
128223: LD_VAR 0 2
128227: PPUSH
128228: LD_VAR 0 4
128232: PPUSH
128233: LD_VAR 0 5
128237: PPUSH
128238: LD_INT 8
128240: PPUSH
128241: CALL 128644 0 4
// end ;
128245: LD_VAR 0 6
128249: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
128250: LD_INT 0
128252: PPUSH
128253: PPUSH
128254: PPUSH
128255: PPUSH
128256: PPUSH
128257: PPUSH
128258: PPUSH
128259: PPUSH
128260: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
128261: LD_VAR 0 1
128265: PPUSH
128266: CALL_OW 302
128270: NOT
128271: PUSH
128272: LD_VAR 0 2
128276: PPUSH
128277: LD_VAR 0 3
128281: PPUSH
128282: CALL_OW 488
128286: NOT
128287: OR
128288: PUSH
128289: LD_VAR 0 4
128293: NOT
128294: OR
128295: IFFALSE 128299
// exit ;
128297: GO 128639
// list := [ ] ;
128299: LD_ADDR_VAR 0 13
128303: PUSH
128304: EMPTY
128305: ST_TO_ADDR
// if x - r < 0 then
128306: LD_VAR 0 2
128310: PUSH
128311: LD_VAR 0 4
128315: MINUS
128316: PUSH
128317: LD_INT 0
128319: LESS
128320: IFFALSE 128332
// min_x := 0 else
128322: LD_ADDR_VAR 0 7
128326: PUSH
128327: LD_INT 0
128329: ST_TO_ADDR
128330: GO 128348
// min_x := x - r ;
128332: LD_ADDR_VAR 0 7
128336: PUSH
128337: LD_VAR 0 2
128341: PUSH
128342: LD_VAR 0 4
128346: MINUS
128347: ST_TO_ADDR
// if y - r < 0 then
128348: LD_VAR 0 3
128352: PUSH
128353: LD_VAR 0 4
128357: MINUS
128358: PUSH
128359: LD_INT 0
128361: LESS
128362: IFFALSE 128374
// min_y := 0 else
128364: LD_ADDR_VAR 0 8
128368: PUSH
128369: LD_INT 0
128371: ST_TO_ADDR
128372: GO 128390
// min_y := y - r ;
128374: LD_ADDR_VAR 0 8
128378: PUSH
128379: LD_VAR 0 3
128383: PUSH
128384: LD_VAR 0 4
128388: MINUS
128389: ST_TO_ADDR
// max_x := x + r ;
128390: LD_ADDR_VAR 0 9
128394: PUSH
128395: LD_VAR 0 2
128399: PUSH
128400: LD_VAR 0 4
128404: PLUS
128405: ST_TO_ADDR
// max_y := y + r ;
128406: LD_ADDR_VAR 0 10
128410: PUSH
128411: LD_VAR 0 3
128415: PUSH
128416: LD_VAR 0 4
128420: PLUS
128421: ST_TO_ADDR
// for _x = min_x to max_x do
128422: LD_ADDR_VAR 0 11
128426: PUSH
128427: DOUBLE
128428: LD_VAR 0 7
128432: DEC
128433: ST_TO_ADDR
128434: LD_VAR 0 9
128438: PUSH
128439: FOR_TO
128440: IFFALSE 128557
// for _y = min_y to max_y do
128442: LD_ADDR_VAR 0 12
128446: PUSH
128447: DOUBLE
128448: LD_VAR 0 8
128452: DEC
128453: ST_TO_ADDR
128454: LD_VAR 0 10
128458: PUSH
128459: FOR_TO
128460: IFFALSE 128553
// begin if not ValidHex ( _x , _y ) then
128462: LD_VAR 0 11
128466: PPUSH
128467: LD_VAR 0 12
128471: PPUSH
128472: CALL_OW 488
128476: NOT
128477: IFFALSE 128481
// continue ;
128479: GO 128459
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
128481: LD_VAR 0 11
128485: PPUSH
128486: LD_VAR 0 12
128490: PPUSH
128491: CALL_OW 351
128495: PUSH
128496: LD_VAR 0 11
128500: PPUSH
128501: LD_VAR 0 12
128505: PPUSH
128506: CALL_OW 554
128510: AND
128511: IFFALSE 128551
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
128513: LD_ADDR_VAR 0 13
128517: PUSH
128518: LD_VAR 0 13
128522: PPUSH
128523: LD_VAR 0 13
128527: PUSH
128528: LD_INT 1
128530: PLUS
128531: PPUSH
128532: LD_VAR 0 11
128536: PUSH
128537: LD_VAR 0 12
128541: PUSH
128542: EMPTY
128543: LIST
128544: LIST
128545: PPUSH
128546: CALL_OW 2
128550: ST_TO_ADDR
// end ;
128551: GO 128459
128553: POP
128554: POP
128555: GO 128439
128557: POP
128558: POP
// if not list then
128559: LD_VAR 0 13
128563: NOT
128564: IFFALSE 128568
// exit ;
128566: GO 128639
// for i in list do
128568: LD_ADDR_VAR 0 6
128572: PUSH
128573: LD_VAR 0 13
128577: PUSH
128578: FOR_IN
128579: IFFALSE 128637
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
128581: LD_VAR 0 1
128585: PPUSH
128586: LD_STRING M
128588: PUSH
128589: LD_VAR 0 6
128593: PUSH
128594: LD_INT 1
128596: ARRAY
128597: PUSH
128598: LD_VAR 0 6
128602: PUSH
128603: LD_INT 2
128605: ARRAY
128606: PUSH
128607: LD_INT 0
128609: PUSH
128610: LD_INT 0
128612: PUSH
128613: LD_INT 0
128615: PUSH
128616: LD_INT 0
128618: PUSH
128619: EMPTY
128620: LIST
128621: LIST
128622: LIST
128623: LIST
128624: LIST
128625: LIST
128626: LIST
128627: PUSH
128628: EMPTY
128629: LIST
128630: PPUSH
128631: CALL_OW 447
128635: GO 128578
128637: POP
128638: POP
// end ;
128639: LD_VAR 0 5
128643: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
128644: LD_INT 0
128646: PPUSH
128647: PPUSH
128648: PPUSH
128649: PPUSH
128650: PPUSH
128651: PPUSH
128652: PPUSH
128653: PPUSH
128654: PPUSH
128655: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
128656: LD_VAR 0 1
128660: PPUSH
128661: CALL_OW 302
128665: NOT
128666: PUSH
128667: LD_VAR 0 2
128671: PPUSH
128672: LD_VAR 0 3
128676: PPUSH
128677: CALL_OW 488
128681: NOT
128682: OR
128683: PUSH
128684: LD_VAR 0 4
128688: NOT
128689: OR
128690: IFFALSE 128694
// exit ;
128692: GO 129207
// list := [ ] ;
128694: LD_ADDR_VAR 0 13
128698: PUSH
128699: EMPTY
128700: ST_TO_ADDR
// if x - r < 0 then
128701: LD_VAR 0 2
128705: PUSH
128706: LD_VAR 0 4
128710: MINUS
128711: PUSH
128712: LD_INT 0
128714: LESS
128715: IFFALSE 128727
// min_x := 0 else
128717: LD_ADDR_VAR 0 7
128721: PUSH
128722: LD_INT 0
128724: ST_TO_ADDR
128725: GO 128743
// min_x := x - r ;
128727: LD_ADDR_VAR 0 7
128731: PUSH
128732: LD_VAR 0 2
128736: PUSH
128737: LD_VAR 0 4
128741: MINUS
128742: ST_TO_ADDR
// if y - r < 0 then
128743: LD_VAR 0 3
128747: PUSH
128748: LD_VAR 0 4
128752: MINUS
128753: PUSH
128754: LD_INT 0
128756: LESS
128757: IFFALSE 128769
// min_y := 0 else
128759: LD_ADDR_VAR 0 8
128763: PUSH
128764: LD_INT 0
128766: ST_TO_ADDR
128767: GO 128785
// min_y := y - r ;
128769: LD_ADDR_VAR 0 8
128773: PUSH
128774: LD_VAR 0 3
128778: PUSH
128779: LD_VAR 0 4
128783: MINUS
128784: ST_TO_ADDR
// max_x := x + r ;
128785: LD_ADDR_VAR 0 9
128789: PUSH
128790: LD_VAR 0 2
128794: PUSH
128795: LD_VAR 0 4
128799: PLUS
128800: ST_TO_ADDR
// max_y := y + r ;
128801: LD_ADDR_VAR 0 10
128805: PUSH
128806: LD_VAR 0 3
128810: PUSH
128811: LD_VAR 0 4
128815: PLUS
128816: ST_TO_ADDR
// for _x = min_x to max_x do
128817: LD_ADDR_VAR 0 11
128821: PUSH
128822: DOUBLE
128823: LD_VAR 0 7
128827: DEC
128828: ST_TO_ADDR
128829: LD_VAR 0 9
128833: PUSH
128834: FOR_TO
128835: IFFALSE 128952
// for _y = min_y to max_y do
128837: LD_ADDR_VAR 0 12
128841: PUSH
128842: DOUBLE
128843: LD_VAR 0 8
128847: DEC
128848: ST_TO_ADDR
128849: LD_VAR 0 10
128853: PUSH
128854: FOR_TO
128855: IFFALSE 128948
// begin if not ValidHex ( _x , _y ) then
128857: LD_VAR 0 11
128861: PPUSH
128862: LD_VAR 0 12
128866: PPUSH
128867: CALL_OW 488
128871: NOT
128872: IFFALSE 128876
// continue ;
128874: GO 128854
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
128876: LD_VAR 0 11
128880: PPUSH
128881: LD_VAR 0 12
128885: PPUSH
128886: CALL_OW 351
128890: PUSH
128891: LD_VAR 0 11
128895: PPUSH
128896: LD_VAR 0 12
128900: PPUSH
128901: CALL_OW 554
128905: AND
128906: IFFALSE 128946
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
128908: LD_ADDR_VAR 0 13
128912: PUSH
128913: LD_VAR 0 13
128917: PPUSH
128918: LD_VAR 0 13
128922: PUSH
128923: LD_INT 1
128925: PLUS
128926: PPUSH
128927: LD_VAR 0 11
128931: PUSH
128932: LD_VAR 0 12
128936: PUSH
128937: EMPTY
128938: LIST
128939: LIST
128940: PPUSH
128941: CALL_OW 2
128945: ST_TO_ADDR
// end ;
128946: GO 128854
128948: POP
128949: POP
128950: GO 128834
128952: POP
128953: POP
// if not list then
128954: LD_VAR 0 13
128958: NOT
128959: IFFALSE 128963
// exit ;
128961: GO 129207
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
128963: LD_ADDR_VAR 0 13
128967: PUSH
128968: LD_VAR 0 1
128972: PPUSH
128973: LD_VAR 0 13
128977: PPUSH
128978: LD_INT 1
128980: PPUSH
128981: LD_INT 1
128983: PPUSH
128984: CALL 74892 0 4
128988: ST_TO_ADDR
// ComStop ( flame ) ;
128989: LD_VAR 0 1
128993: PPUSH
128994: CALL_OW 141
// for i in list do
128998: LD_ADDR_VAR 0 6
129002: PUSH
129003: LD_VAR 0 13
129007: PUSH
129008: FOR_IN
129009: IFFALSE 129040
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129011: LD_VAR 0 1
129015: PPUSH
129016: LD_VAR 0 6
129020: PUSH
129021: LD_INT 1
129023: ARRAY
129024: PPUSH
129025: LD_VAR 0 6
129029: PUSH
129030: LD_INT 2
129032: ARRAY
129033: PPUSH
129034: CALL_OW 176
129038: GO 129008
129040: POP
129041: POP
// repeat wait ( 0 0$1 ) ;
129042: LD_INT 35
129044: PPUSH
129045: CALL_OW 67
// task := GetTaskList ( flame ) ;
129049: LD_ADDR_VAR 0 14
129053: PUSH
129054: LD_VAR 0 1
129058: PPUSH
129059: CALL_OW 437
129063: ST_TO_ADDR
// if not task then
129064: LD_VAR 0 14
129068: NOT
129069: IFFALSE 129073
// exit ;
129071: GO 129207
// if task [ 1 ] [ 1 ] <> | then
129073: LD_VAR 0 14
129077: PUSH
129078: LD_INT 1
129080: ARRAY
129081: PUSH
129082: LD_INT 1
129084: ARRAY
129085: PUSH
129086: LD_STRING |
129088: NONEQUAL
129089: IFFALSE 129093
// exit ;
129091: GO 129207
// _x := task [ 1 ] [ 2 ] ;
129093: LD_ADDR_VAR 0 11
129097: PUSH
129098: LD_VAR 0 14
129102: PUSH
129103: LD_INT 1
129105: ARRAY
129106: PUSH
129107: LD_INT 2
129109: ARRAY
129110: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129111: LD_ADDR_VAR 0 12
129115: PUSH
129116: LD_VAR 0 14
129120: PUSH
129121: LD_INT 1
129123: ARRAY
129124: PUSH
129125: LD_INT 3
129127: ARRAY
129128: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129129: LD_VAR 0 11
129133: PPUSH
129134: LD_VAR 0 12
129138: PPUSH
129139: CALL_OW 351
129143: NOT
129144: PUSH
129145: LD_VAR 0 11
129149: PPUSH
129150: LD_VAR 0 12
129154: PPUSH
129155: CALL_OW 554
129159: NOT
129160: OR
129161: IFFALSE 129195
// begin task := Delete ( task , 1 ) ;
129163: LD_ADDR_VAR 0 14
129167: PUSH
129168: LD_VAR 0 14
129172: PPUSH
129173: LD_INT 1
129175: PPUSH
129176: CALL_OW 3
129180: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
129181: LD_VAR 0 1
129185: PPUSH
129186: LD_VAR 0 14
129190: PPUSH
129191: CALL_OW 446
// end ; until not HasTask ( flame ) ;
129195: LD_VAR 0 1
129199: PPUSH
129200: CALL_OW 314
129204: NOT
129205: IFFALSE 129042
// end ;
129207: LD_VAR 0 5
129211: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
129212: LD_EXP 208
129216: NOT
129217: IFFALSE 129267
129219: GO 129221
129221: DISABLE
// begin initHack := true ;
129222: LD_ADDR_EXP 208
129226: PUSH
129227: LD_INT 1
129229: ST_TO_ADDR
// hackTanks := [ ] ;
129230: LD_ADDR_EXP 209
129234: PUSH
129235: EMPTY
129236: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
129237: LD_ADDR_EXP 210
129241: PUSH
129242: EMPTY
129243: ST_TO_ADDR
// hackLimit := 3 ;
129244: LD_ADDR_EXP 211
129248: PUSH
129249: LD_INT 3
129251: ST_TO_ADDR
// hackDist := 12 ;
129252: LD_ADDR_EXP 212
129256: PUSH
129257: LD_INT 12
129259: ST_TO_ADDR
// hackCounter := [ ] ;
129260: LD_ADDR_EXP 213
129264: PUSH
129265: EMPTY
129266: ST_TO_ADDR
// end ;
129267: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
129268: LD_EXP 208
129272: PUSH
129273: LD_INT 34
129275: PUSH
129276: LD_INT 99
129278: PUSH
129279: EMPTY
129280: LIST
129281: LIST
129282: PPUSH
129283: CALL_OW 69
129287: AND
129288: IFFALSE 129541
129290: GO 129292
129292: DISABLE
129293: LD_INT 0
129295: PPUSH
129296: PPUSH
// begin enable ;
129297: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
129298: LD_ADDR_VAR 0 1
129302: PUSH
129303: LD_INT 34
129305: PUSH
129306: LD_INT 99
129308: PUSH
129309: EMPTY
129310: LIST
129311: LIST
129312: PPUSH
129313: CALL_OW 69
129317: PUSH
129318: FOR_IN
129319: IFFALSE 129539
// begin if not i in hackTanks then
129321: LD_VAR 0 1
129325: PUSH
129326: LD_EXP 209
129330: IN
129331: NOT
129332: IFFALSE 129415
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
129334: LD_ADDR_EXP 209
129338: PUSH
129339: LD_EXP 209
129343: PPUSH
129344: LD_EXP 209
129348: PUSH
129349: LD_INT 1
129351: PLUS
129352: PPUSH
129353: LD_VAR 0 1
129357: PPUSH
129358: CALL_OW 1
129362: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
129363: LD_ADDR_EXP 210
129367: PUSH
129368: LD_EXP 210
129372: PPUSH
129373: LD_EXP 210
129377: PUSH
129378: LD_INT 1
129380: PLUS
129381: PPUSH
129382: EMPTY
129383: PPUSH
129384: CALL_OW 1
129388: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
129389: LD_ADDR_EXP 213
129393: PUSH
129394: LD_EXP 213
129398: PPUSH
129399: LD_EXP 213
129403: PUSH
129404: LD_INT 1
129406: PLUS
129407: PPUSH
129408: EMPTY
129409: PPUSH
129410: CALL_OW 1
129414: ST_TO_ADDR
// end ; if not IsOk ( i ) then
129415: LD_VAR 0 1
129419: PPUSH
129420: CALL_OW 302
129424: NOT
129425: IFFALSE 129438
// begin HackUnlinkAll ( i ) ;
129427: LD_VAR 0 1
129431: PPUSH
129432: CALL 129544 0 1
// continue ;
129436: GO 129318
// end ; HackCheckCapturedStatus ( i ) ;
129438: LD_VAR 0 1
129442: PPUSH
129443: CALL 129987 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
129447: LD_ADDR_VAR 0 2
129451: PUSH
129452: LD_INT 81
129454: PUSH
129455: LD_VAR 0 1
129459: PPUSH
129460: CALL_OW 255
129464: PUSH
129465: EMPTY
129466: LIST
129467: LIST
129468: PUSH
129469: LD_INT 33
129471: PUSH
129472: LD_INT 3
129474: PUSH
129475: EMPTY
129476: LIST
129477: LIST
129478: PUSH
129479: LD_INT 91
129481: PUSH
129482: LD_VAR 0 1
129486: PUSH
129487: LD_EXP 212
129491: PUSH
129492: EMPTY
129493: LIST
129494: LIST
129495: LIST
129496: PUSH
129497: LD_INT 50
129499: PUSH
129500: EMPTY
129501: LIST
129502: PUSH
129503: EMPTY
129504: LIST
129505: LIST
129506: LIST
129507: LIST
129508: PPUSH
129509: CALL_OW 69
129513: ST_TO_ADDR
// if not tmp then
129514: LD_VAR 0 2
129518: NOT
129519: IFFALSE 129523
// continue ;
129521: GO 129318
// HackLink ( i , tmp ) ;
129523: LD_VAR 0 1
129527: PPUSH
129528: LD_VAR 0 2
129532: PPUSH
129533: CALL 129680 0 2
// end ;
129537: GO 129318
129539: POP
129540: POP
// end ;
129541: PPOPN 2
129543: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
129544: LD_INT 0
129546: PPUSH
129547: PPUSH
129548: PPUSH
// if not hack in hackTanks then
129549: LD_VAR 0 1
129553: PUSH
129554: LD_EXP 209
129558: IN
129559: NOT
129560: IFFALSE 129564
// exit ;
129562: GO 129675
// index := GetElementIndex ( hackTanks , hack ) ;
129564: LD_ADDR_VAR 0 4
129568: PUSH
129569: LD_EXP 209
129573: PPUSH
129574: LD_VAR 0 1
129578: PPUSH
129579: CALL 74189 0 2
129583: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
129584: LD_EXP 210
129588: PUSH
129589: LD_VAR 0 4
129593: ARRAY
129594: IFFALSE 129675
// begin for i in hackTanksCaptured [ index ] do
129596: LD_ADDR_VAR 0 3
129600: PUSH
129601: LD_EXP 210
129605: PUSH
129606: LD_VAR 0 4
129610: ARRAY
129611: PUSH
129612: FOR_IN
129613: IFFALSE 129639
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
129615: LD_VAR 0 3
129619: PUSH
129620: LD_INT 1
129622: ARRAY
129623: PPUSH
129624: LD_VAR 0 3
129628: PUSH
129629: LD_INT 2
129631: ARRAY
129632: PPUSH
129633: CALL_OW 235
129637: GO 129612
129639: POP
129640: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
129641: LD_ADDR_EXP 210
129645: PUSH
129646: LD_EXP 210
129650: PPUSH
129651: LD_VAR 0 4
129655: PPUSH
129656: EMPTY
129657: PPUSH
129658: CALL_OW 1
129662: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
129663: LD_VAR 0 1
129667: PPUSH
129668: LD_INT 0
129670: PPUSH
129671: CALL_OW 505
// end ; end ;
129675: LD_VAR 0 2
129679: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
129680: LD_INT 0
129682: PPUSH
129683: PPUSH
129684: PPUSH
// if not hack in hackTanks or not vehicles then
129685: LD_VAR 0 1
129689: PUSH
129690: LD_EXP 209
129694: IN
129695: NOT
129696: PUSH
129697: LD_VAR 0 2
129701: NOT
129702: OR
129703: IFFALSE 129707
// exit ;
129705: GO 129982
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
129707: LD_ADDR_VAR 0 2
129711: PUSH
129712: LD_VAR 0 1
129716: PPUSH
129717: LD_VAR 0 2
129721: PPUSH
129722: LD_INT 1
129724: PPUSH
129725: LD_INT 1
129727: PPUSH
129728: CALL 74839 0 4
129732: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
129733: LD_ADDR_VAR 0 5
129737: PUSH
129738: LD_EXP 209
129742: PPUSH
129743: LD_VAR 0 1
129747: PPUSH
129748: CALL 74189 0 2
129752: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
129753: LD_EXP 210
129757: PUSH
129758: LD_VAR 0 5
129762: ARRAY
129763: PUSH
129764: LD_EXP 211
129768: LESS
129769: IFFALSE 129958
// begin for i := 1 to vehicles do
129771: LD_ADDR_VAR 0 4
129775: PUSH
129776: DOUBLE
129777: LD_INT 1
129779: DEC
129780: ST_TO_ADDR
129781: LD_VAR 0 2
129785: PUSH
129786: FOR_TO
129787: IFFALSE 129956
// begin if hackTanksCaptured [ index ] = hackLimit then
129789: LD_EXP 210
129793: PUSH
129794: LD_VAR 0 5
129798: ARRAY
129799: PUSH
129800: LD_EXP 211
129804: EQUAL
129805: IFFALSE 129809
// break ;
129807: GO 129956
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
129809: LD_ADDR_EXP 213
129813: PUSH
129814: LD_EXP 213
129818: PPUSH
129819: LD_VAR 0 5
129823: PPUSH
129824: LD_EXP 213
129828: PUSH
129829: LD_VAR 0 5
129833: ARRAY
129834: PUSH
129835: LD_INT 1
129837: PLUS
129838: PPUSH
129839: CALL_OW 1
129843: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
129844: LD_ADDR_EXP 210
129848: PUSH
129849: LD_EXP 210
129853: PPUSH
129854: LD_VAR 0 5
129858: PUSH
129859: LD_EXP 210
129863: PUSH
129864: LD_VAR 0 5
129868: ARRAY
129869: PUSH
129870: LD_INT 1
129872: PLUS
129873: PUSH
129874: EMPTY
129875: LIST
129876: LIST
129877: PPUSH
129878: LD_VAR 0 2
129882: PUSH
129883: LD_VAR 0 4
129887: ARRAY
129888: PUSH
129889: LD_VAR 0 2
129893: PUSH
129894: LD_VAR 0 4
129898: ARRAY
129899: PPUSH
129900: CALL_OW 255
129904: PUSH
129905: EMPTY
129906: LIST
129907: LIST
129908: PPUSH
129909: CALL 74404 0 3
129913: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
129914: LD_VAR 0 2
129918: PUSH
129919: LD_VAR 0 4
129923: ARRAY
129924: PPUSH
129925: LD_VAR 0 1
129929: PPUSH
129930: CALL_OW 255
129934: PPUSH
129935: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
129939: LD_VAR 0 2
129943: PUSH
129944: LD_VAR 0 4
129948: ARRAY
129949: PPUSH
129950: CALL_OW 141
// end ;
129954: GO 129786
129956: POP
129957: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
129958: LD_VAR 0 1
129962: PPUSH
129963: LD_EXP 210
129967: PUSH
129968: LD_VAR 0 5
129972: ARRAY
129973: PUSH
129974: LD_INT 0
129976: PLUS
129977: PPUSH
129978: CALL_OW 505
// end ;
129982: LD_VAR 0 3
129986: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
129987: LD_INT 0
129989: PPUSH
129990: PPUSH
129991: PPUSH
129992: PPUSH
// if not hack in hackTanks then
129993: LD_VAR 0 1
129997: PUSH
129998: LD_EXP 209
130002: IN
130003: NOT
130004: IFFALSE 130008
// exit ;
130006: GO 130248
// index := GetElementIndex ( hackTanks , hack ) ;
130008: LD_ADDR_VAR 0 4
130012: PUSH
130013: LD_EXP 209
130017: PPUSH
130018: LD_VAR 0 1
130022: PPUSH
130023: CALL 74189 0 2
130027: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130028: LD_ADDR_VAR 0 3
130032: PUSH
130033: DOUBLE
130034: LD_EXP 210
130038: PUSH
130039: LD_VAR 0 4
130043: ARRAY
130044: INC
130045: ST_TO_ADDR
130046: LD_INT 1
130048: PUSH
130049: FOR_DOWNTO
130050: IFFALSE 130222
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130052: LD_ADDR_VAR 0 5
130056: PUSH
130057: LD_EXP 210
130061: PUSH
130062: LD_VAR 0 4
130066: ARRAY
130067: PUSH
130068: LD_VAR 0 3
130072: ARRAY
130073: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130074: LD_VAR 0 5
130078: PUSH
130079: LD_INT 1
130081: ARRAY
130082: PPUSH
130083: CALL_OW 302
130087: NOT
130088: PUSH
130089: LD_VAR 0 5
130093: PUSH
130094: LD_INT 1
130096: ARRAY
130097: PPUSH
130098: CALL_OW 255
130102: PUSH
130103: LD_VAR 0 1
130107: PPUSH
130108: CALL_OW 255
130112: NONEQUAL
130113: OR
130114: IFFALSE 130220
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130116: LD_VAR 0 5
130120: PUSH
130121: LD_INT 1
130123: ARRAY
130124: PPUSH
130125: CALL_OW 305
130129: PUSH
130130: LD_VAR 0 5
130134: PUSH
130135: LD_INT 1
130137: ARRAY
130138: PPUSH
130139: CALL_OW 255
130143: PUSH
130144: LD_VAR 0 1
130148: PPUSH
130149: CALL_OW 255
130153: EQUAL
130154: AND
130155: IFFALSE 130179
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130157: LD_VAR 0 5
130161: PUSH
130162: LD_INT 1
130164: ARRAY
130165: PPUSH
130166: LD_VAR 0 5
130170: PUSH
130171: LD_INT 2
130173: ARRAY
130174: PPUSH
130175: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
130179: LD_ADDR_EXP 210
130183: PUSH
130184: LD_EXP 210
130188: PPUSH
130189: LD_VAR 0 4
130193: PPUSH
130194: LD_EXP 210
130198: PUSH
130199: LD_VAR 0 4
130203: ARRAY
130204: PPUSH
130205: LD_VAR 0 3
130209: PPUSH
130210: CALL_OW 3
130214: PPUSH
130215: CALL_OW 1
130219: ST_TO_ADDR
// end ; end ;
130220: GO 130049
130222: POP
130223: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130224: LD_VAR 0 1
130228: PPUSH
130229: LD_EXP 210
130233: PUSH
130234: LD_VAR 0 4
130238: ARRAY
130239: PUSH
130240: LD_INT 0
130242: PLUS
130243: PPUSH
130244: CALL_OW 505
// end ;
130248: LD_VAR 0 2
130252: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
130253: LD_INT 0
130255: PPUSH
130256: PPUSH
130257: PPUSH
130258: PPUSH
// if not hack in hackTanks then
130259: LD_VAR 0 1
130263: PUSH
130264: LD_EXP 209
130268: IN
130269: NOT
130270: IFFALSE 130274
// exit ;
130272: GO 130359
// index := GetElementIndex ( hackTanks , hack ) ;
130274: LD_ADDR_VAR 0 5
130278: PUSH
130279: LD_EXP 209
130283: PPUSH
130284: LD_VAR 0 1
130288: PPUSH
130289: CALL 74189 0 2
130293: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
130294: LD_ADDR_VAR 0 4
130298: PUSH
130299: DOUBLE
130300: LD_INT 1
130302: DEC
130303: ST_TO_ADDR
130304: LD_EXP 210
130308: PUSH
130309: LD_VAR 0 5
130313: ARRAY
130314: PUSH
130315: FOR_TO
130316: IFFALSE 130357
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
130318: LD_EXP 210
130322: PUSH
130323: LD_VAR 0 5
130327: ARRAY
130328: PUSH
130329: LD_VAR 0 4
130333: ARRAY
130334: PUSH
130335: LD_INT 1
130337: ARRAY
130338: PUSH
130339: LD_VAR 0 2
130343: EQUAL
130344: IFFALSE 130355
// KillUnit ( vehicle ) ;
130346: LD_VAR 0 2
130350: PPUSH
130351: CALL_OW 66
130355: GO 130315
130357: POP
130358: POP
// end ;
130359: LD_VAR 0 3
130363: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
130364: LD_EXP 214
130368: NOT
130369: IFFALSE 130404
130371: GO 130373
130373: DISABLE
// begin initMiner := true ;
130374: LD_ADDR_EXP 214
130378: PUSH
130379: LD_INT 1
130381: ST_TO_ADDR
// minersList := [ ] ;
130382: LD_ADDR_EXP 215
130386: PUSH
130387: EMPTY
130388: ST_TO_ADDR
// minerMinesList := [ ] ;
130389: LD_ADDR_EXP 216
130393: PUSH
130394: EMPTY
130395: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
130396: LD_ADDR_EXP 217
130400: PUSH
130401: LD_INT 5
130403: ST_TO_ADDR
// end ;
130404: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
130405: LD_EXP 214
130409: PUSH
130410: LD_INT 34
130412: PUSH
130413: LD_INT 81
130415: PUSH
130416: EMPTY
130417: LIST
130418: LIST
130419: PPUSH
130420: CALL_OW 69
130424: AND
130425: IFFALSE 130886
130427: GO 130429
130429: DISABLE
130430: LD_INT 0
130432: PPUSH
130433: PPUSH
130434: PPUSH
130435: PPUSH
// begin enable ;
130436: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
130437: LD_ADDR_VAR 0 1
130441: PUSH
130442: LD_INT 34
130444: PUSH
130445: LD_INT 81
130447: PUSH
130448: EMPTY
130449: LIST
130450: LIST
130451: PPUSH
130452: CALL_OW 69
130456: PUSH
130457: FOR_IN
130458: IFFALSE 130530
// begin if not i in minersList then
130460: LD_VAR 0 1
130464: PUSH
130465: LD_EXP 215
130469: IN
130470: NOT
130471: IFFALSE 130528
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
130473: LD_ADDR_EXP 215
130477: PUSH
130478: LD_EXP 215
130482: PPUSH
130483: LD_EXP 215
130487: PUSH
130488: LD_INT 1
130490: PLUS
130491: PPUSH
130492: LD_VAR 0 1
130496: PPUSH
130497: CALL_OW 1
130501: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
130502: LD_ADDR_EXP 216
130506: PUSH
130507: LD_EXP 216
130511: PPUSH
130512: LD_EXP 216
130516: PUSH
130517: LD_INT 1
130519: PLUS
130520: PPUSH
130521: EMPTY
130522: PPUSH
130523: CALL_OW 1
130527: ST_TO_ADDR
// end end ;
130528: GO 130457
130530: POP
130531: POP
// for i := minerMinesList downto 1 do
130532: LD_ADDR_VAR 0 1
130536: PUSH
130537: DOUBLE
130538: LD_EXP 216
130542: INC
130543: ST_TO_ADDR
130544: LD_INT 1
130546: PUSH
130547: FOR_DOWNTO
130548: IFFALSE 130884
// begin if IsLive ( minersList [ i ] ) then
130550: LD_EXP 215
130554: PUSH
130555: LD_VAR 0 1
130559: ARRAY
130560: PPUSH
130561: CALL_OW 300
130565: IFFALSE 130593
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
130567: LD_EXP 215
130571: PUSH
130572: LD_VAR 0 1
130576: ARRAY
130577: PPUSH
130578: LD_EXP 216
130582: PUSH
130583: LD_VAR 0 1
130587: ARRAY
130588: PPUSH
130589: CALL_OW 505
// if not minerMinesList [ i ] then
130593: LD_EXP 216
130597: PUSH
130598: LD_VAR 0 1
130602: ARRAY
130603: NOT
130604: IFFALSE 130608
// continue ;
130606: GO 130547
// for j := minerMinesList [ i ] downto 1 do
130608: LD_ADDR_VAR 0 2
130612: PUSH
130613: DOUBLE
130614: LD_EXP 216
130618: PUSH
130619: LD_VAR 0 1
130623: ARRAY
130624: INC
130625: ST_TO_ADDR
130626: LD_INT 1
130628: PUSH
130629: FOR_DOWNTO
130630: IFFALSE 130880
// begin side := GetSide ( minersList [ i ] ) ;
130632: LD_ADDR_VAR 0 3
130636: PUSH
130637: LD_EXP 215
130641: PUSH
130642: LD_VAR 0 1
130646: ARRAY
130647: PPUSH
130648: CALL_OW 255
130652: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
130653: LD_ADDR_VAR 0 4
130657: PUSH
130658: LD_EXP 216
130662: PUSH
130663: LD_VAR 0 1
130667: ARRAY
130668: PUSH
130669: LD_VAR 0 2
130673: ARRAY
130674: PUSH
130675: LD_INT 1
130677: ARRAY
130678: PPUSH
130679: LD_EXP 216
130683: PUSH
130684: LD_VAR 0 1
130688: ARRAY
130689: PUSH
130690: LD_VAR 0 2
130694: ARRAY
130695: PUSH
130696: LD_INT 2
130698: ARRAY
130699: PPUSH
130700: CALL_OW 428
130704: ST_TO_ADDR
// if not tmp then
130705: LD_VAR 0 4
130709: NOT
130710: IFFALSE 130714
// continue ;
130712: GO 130629
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
130714: LD_VAR 0 4
130718: PUSH
130719: LD_INT 81
130721: PUSH
130722: LD_VAR 0 3
130726: PUSH
130727: EMPTY
130728: LIST
130729: LIST
130730: PPUSH
130731: CALL_OW 69
130735: IN
130736: PUSH
130737: LD_EXP 216
130741: PUSH
130742: LD_VAR 0 1
130746: ARRAY
130747: PUSH
130748: LD_VAR 0 2
130752: ARRAY
130753: PUSH
130754: LD_INT 1
130756: ARRAY
130757: PPUSH
130758: LD_EXP 216
130762: PUSH
130763: LD_VAR 0 1
130767: ARRAY
130768: PUSH
130769: LD_VAR 0 2
130773: ARRAY
130774: PUSH
130775: LD_INT 2
130777: ARRAY
130778: PPUSH
130779: CALL_OW 458
130783: AND
130784: IFFALSE 130878
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
130786: LD_EXP 216
130790: PUSH
130791: LD_VAR 0 1
130795: ARRAY
130796: PUSH
130797: LD_VAR 0 2
130801: ARRAY
130802: PUSH
130803: LD_INT 1
130805: ARRAY
130806: PPUSH
130807: LD_EXP 216
130811: PUSH
130812: LD_VAR 0 1
130816: ARRAY
130817: PUSH
130818: LD_VAR 0 2
130822: ARRAY
130823: PUSH
130824: LD_INT 2
130826: ARRAY
130827: PPUSH
130828: LD_VAR 0 3
130832: PPUSH
130833: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
130837: LD_ADDR_EXP 216
130841: PUSH
130842: LD_EXP 216
130846: PPUSH
130847: LD_VAR 0 1
130851: PPUSH
130852: LD_EXP 216
130856: PUSH
130857: LD_VAR 0 1
130861: ARRAY
130862: PPUSH
130863: LD_VAR 0 2
130867: PPUSH
130868: CALL_OW 3
130872: PPUSH
130873: CALL_OW 1
130877: ST_TO_ADDR
// end ; end ;
130878: GO 130629
130880: POP
130881: POP
// end ;
130882: GO 130547
130884: POP
130885: POP
// end ;
130886: PPOPN 4
130888: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
130889: LD_INT 0
130891: PPUSH
130892: PPUSH
// result := false ;
130893: LD_ADDR_VAR 0 4
130897: PUSH
130898: LD_INT 0
130900: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
130901: LD_VAR 0 1
130905: PPUSH
130906: CALL_OW 264
130910: PUSH
130911: LD_INT 81
130913: EQUAL
130914: NOT
130915: IFFALSE 130919
// exit ;
130917: GO 131159
// index := GetElementIndex ( minersList , unit ) ;
130919: LD_ADDR_VAR 0 5
130923: PUSH
130924: LD_EXP 215
130928: PPUSH
130929: LD_VAR 0 1
130933: PPUSH
130934: CALL 74189 0 2
130938: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
130939: LD_EXP 216
130943: PUSH
130944: LD_VAR 0 5
130948: ARRAY
130949: PUSH
130950: LD_EXP 217
130954: GREATEREQUAL
130955: IFFALSE 130959
// exit ;
130957: GO 131159
// ComMoveXY ( unit , x , y ) ;
130959: LD_VAR 0 1
130963: PPUSH
130964: LD_VAR 0 2
130968: PPUSH
130969: LD_VAR 0 3
130973: PPUSH
130974: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
130978: LD_INT 35
130980: PPUSH
130981: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
130985: LD_VAR 0 1
130989: PPUSH
130990: LD_VAR 0 2
130994: PPUSH
130995: LD_VAR 0 3
130999: PPUSH
131000: CALL 105941 0 3
131004: NOT
131005: PUSH
131006: LD_VAR 0 1
131010: PPUSH
131011: CALL_OW 314
131015: AND
131016: IFFALSE 131020
// exit ;
131018: GO 131159
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131020: LD_VAR 0 2
131024: PPUSH
131025: LD_VAR 0 3
131029: PPUSH
131030: CALL_OW 428
131034: PUSH
131035: LD_VAR 0 1
131039: EQUAL
131040: PUSH
131041: LD_VAR 0 1
131045: PPUSH
131046: CALL_OW 314
131050: NOT
131051: AND
131052: IFFALSE 130978
// PlaySoundXY ( x , y , PlantMine ) ;
131054: LD_VAR 0 2
131058: PPUSH
131059: LD_VAR 0 3
131063: PPUSH
131064: LD_STRING PlantMine
131066: PPUSH
131067: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131071: LD_VAR 0 2
131075: PPUSH
131076: LD_VAR 0 3
131080: PPUSH
131081: LD_VAR 0 1
131085: PPUSH
131086: CALL_OW 255
131090: PPUSH
131091: LD_INT 0
131093: PPUSH
131094: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131098: LD_ADDR_EXP 216
131102: PUSH
131103: LD_EXP 216
131107: PPUSH
131108: LD_VAR 0 5
131112: PUSH
131113: LD_EXP 216
131117: PUSH
131118: LD_VAR 0 5
131122: ARRAY
131123: PUSH
131124: LD_INT 1
131126: PLUS
131127: PUSH
131128: EMPTY
131129: LIST
131130: LIST
131131: PPUSH
131132: LD_VAR 0 2
131136: PUSH
131137: LD_VAR 0 3
131141: PUSH
131142: EMPTY
131143: LIST
131144: LIST
131145: PPUSH
131146: CALL 74404 0 3
131150: ST_TO_ADDR
// result := true ;
131151: LD_ADDR_VAR 0 4
131155: PUSH
131156: LD_INT 1
131158: ST_TO_ADDR
// end ;
131159: LD_VAR 0 4
131163: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131164: LD_INT 0
131166: PPUSH
131167: PPUSH
131168: PPUSH
// if not unit in minersList then
131169: LD_VAR 0 1
131173: PUSH
131174: LD_EXP 215
131178: IN
131179: NOT
131180: IFFALSE 131184
// exit ;
131182: GO 131576
// index := GetElementIndex ( minersList , unit ) ;
131184: LD_ADDR_VAR 0 6
131188: PUSH
131189: LD_EXP 215
131193: PPUSH
131194: LD_VAR 0 1
131198: PPUSH
131199: CALL 74189 0 2
131203: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
131204: LD_ADDR_VAR 0 5
131208: PUSH
131209: DOUBLE
131210: LD_EXP 216
131214: PUSH
131215: LD_VAR 0 6
131219: ARRAY
131220: INC
131221: ST_TO_ADDR
131222: LD_INT 1
131224: PUSH
131225: FOR_DOWNTO
131226: IFFALSE 131387
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
131228: LD_EXP 216
131232: PUSH
131233: LD_VAR 0 6
131237: ARRAY
131238: PUSH
131239: LD_VAR 0 5
131243: ARRAY
131244: PUSH
131245: LD_INT 1
131247: ARRAY
131248: PUSH
131249: LD_VAR 0 2
131253: EQUAL
131254: PUSH
131255: LD_EXP 216
131259: PUSH
131260: LD_VAR 0 6
131264: ARRAY
131265: PUSH
131266: LD_VAR 0 5
131270: ARRAY
131271: PUSH
131272: LD_INT 2
131274: ARRAY
131275: PUSH
131276: LD_VAR 0 3
131280: EQUAL
131281: AND
131282: IFFALSE 131385
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131284: LD_EXP 216
131288: PUSH
131289: LD_VAR 0 6
131293: ARRAY
131294: PUSH
131295: LD_VAR 0 5
131299: ARRAY
131300: PUSH
131301: LD_INT 1
131303: ARRAY
131304: PPUSH
131305: LD_EXP 216
131309: PUSH
131310: LD_VAR 0 6
131314: ARRAY
131315: PUSH
131316: LD_VAR 0 5
131320: ARRAY
131321: PUSH
131322: LD_INT 2
131324: ARRAY
131325: PPUSH
131326: LD_VAR 0 1
131330: PPUSH
131331: CALL_OW 255
131335: PPUSH
131336: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
131340: LD_ADDR_EXP 216
131344: PUSH
131345: LD_EXP 216
131349: PPUSH
131350: LD_VAR 0 6
131354: PPUSH
131355: LD_EXP 216
131359: PUSH
131360: LD_VAR 0 6
131364: ARRAY
131365: PPUSH
131366: LD_VAR 0 5
131370: PPUSH
131371: CALL_OW 3
131375: PPUSH
131376: CALL_OW 1
131380: ST_TO_ADDR
// exit ;
131381: POP
131382: POP
131383: GO 131576
// end ; end ;
131385: GO 131225
131387: POP
131388: POP
// for i := minerMinesList [ index ] downto 1 do
131389: LD_ADDR_VAR 0 5
131393: PUSH
131394: DOUBLE
131395: LD_EXP 216
131399: PUSH
131400: LD_VAR 0 6
131404: ARRAY
131405: INC
131406: ST_TO_ADDR
131407: LD_INT 1
131409: PUSH
131410: FOR_DOWNTO
131411: IFFALSE 131574
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
131413: LD_EXP 216
131417: PUSH
131418: LD_VAR 0 6
131422: ARRAY
131423: PUSH
131424: LD_VAR 0 5
131428: ARRAY
131429: PUSH
131430: LD_INT 1
131432: ARRAY
131433: PPUSH
131434: LD_EXP 216
131438: PUSH
131439: LD_VAR 0 6
131443: ARRAY
131444: PUSH
131445: LD_VAR 0 5
131449: ARRAY
131450: PUSH
131451: LD_INT 2
131453: ARRAY
131454: PPUSH
131455: LD_VAR 0 2
131459: PPUSH
131460: LD_VAR 0 3
131464: PPUSH
131465: CALL_OW 298
131469: PUSH
131470: LD_INT 6
131472: LESS
131473: IFFALSE 131572
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131475: LD_EXP 216
131479: PUSH
131480: LD_VAR 0 6
131484: ARRAY
131485: PUSH
131486: LD_VAR 0 5
131490: ARRAY
131491: PUSH
131492: LD_INT 1
131494: ARRAY
131495: PPUSH
131496: LD_EXP 216
131500: PUSH
131501: LD_VAR 0 6
131505: ARRAY
131506: PUSH
131507: LD_VAR 0 5
131511: ARRAY
131512: PUSH
131513: LD_INT 2
131515: ARRAY
131516: PPUSH
131517: LD_VAR 0 1
131521: PPUSH
131522: CALL_OW 255
131526: PPUSH
131527: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
131531: LD_ADDR_EXP 216
131535: PUSH
131536: LD_EXP 216
131540: PPUSH
131541: LD_VAR 0 6
131545: PPUSH
131546: LD_EXP 216
131550: PUSH
131551: LD_VAR 0 6
131555: ARRAY
131556: PPUSH
131557: LD_VAR 0 5
131561: PPUSH
131562: CALL_OW 3
131566: PPUSH
131567: CALL_OW 1
131571: ST_TO_ADDR
// end ; end ;
131572: GO 131410
131574: POP
131575: POP
// end ;
131576: LD_VAR 0 4
131580: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
131581: LD_INT 0
131583: PPUSH
131584: PPUSH
131585: PPUSH
131586: PPUSH
131587: PPUSH
131588: PPUSH
131589: PPUSH
131590: PPUSH
131591: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
131592: LD_VAR 0 1
131596: PPUSH
131597: CALL_OW 264
131601: PUSH
131602: LD_INT 81
131604: EQUAL
131605: NOT
131606: PUSH
131607: LD_VAR 0 1
131611: PUSH
131612: LD_EXP 215
131616: IN
131617: NOT
131618: OR
131619: IFFALSE 131623
// exit ;
131621: GO 131945
// index := GetElementIndex ( minersList , unit ) ;
131623: LD_ADDR_VAR 0 6
131627: PUSH
131628: LD_EXP 215
131632: PPUSH
131633: LD_VAR 0 1
131637: PPUSH
131638: CALL 74189 0 2
131642: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
131643: LD_ADDR_VAR 0 8
131647: PUSH
131648: LD_EXP 217
131652: PUSH
131653: LD_EXP 216
131657: PUSH
131658: LD_VAR 0 6
131662: ARRAY
131663: MINUS
131664: ST_TO_ADDR
// if not minesFreeAmount then
131665: LD_VAR 0 8
131669: NOT
131670: IFFALSE 131674
// exit ;
131672: GO 131945
// tmp := [ ] ;
131674: LD_ADDR_VAR 0 7
131678: PUSH
131679: EMPTY
131680: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
131681: LD_ADDR_VAR 0 5
131685: PUSH
131686: DOUBLE
131687: LD_INT 1
131689: DEC
131690: ST_TO_ADDR
131691: LD_VAR 0 8
131695: PUSH
131696: FOR_TO
131697: IFFALSE 131892
// begin _d := rand ( 0 , 5 ) ;
131699: LD_ADDR_VAR 0 11
131703: PUSH
131704: LD_INT 0
131706: PPUSH
131707: LD_INT 5
131709: PPUSH
131710: CALL_OW 12
131714: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
131715: LD_ADDR_VAR 0 12
131719: PUSH
131720: LD_INT 2
131722: PPUSH
131723: LD_INT 6
131725: PPUSH
131726: CALL_OW 12
131730: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
131731: LD_ADDR_VAR 0 9
131735: PUSH
131736: LD_VAR 0 2
131740: PPUSH
131741: LD_VAR 0 11
131745: PPUSH
131746: LD_VAR 0 12
131750: PPUSH
131751: CALL_OW 272
131755: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
131756: LD_ADDR_VAR 0 10
131760: PUSH
131761: LD_VAR 0 3
131765: PPUSH
131766: LD_VAR 0 11
131770: PPUSH
131771: LD_VAR 0 12
131775: PPUSH
131776: CALL_OW 273
131780: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
131781: LD_VAR 0 9
131785: PPUSH
131786: LD_VAR 0 10
131790: PPUSH
131791: CALL_OW 488
131795: PUSH
131796: LD_VAR 0 9
131800: PUSH
131801: LD_VAR 0 10
131805: PUSH
131806: EMPTY
131807: LIST
131808: LIST
131809: PUSH
131810: LD_VAR 0 7
131814: IN
131815: NOT
131816: AND
131817: PUSH
131818: LD_VAR 0 9
131822: PPUSH
131823: LD_VAR 0 10
131827: PPUSH
131828: CALL_OW 458
131832: NOT
131833: AND
131834: IFFALSE 131876
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
131836: LD_ADDR_VAR 0 7
131840: PUSH
131841: LD_VAR 0 7
131845: PPUSH
131846: LD_VAR 0 7
131850: PUSH
131851: LD_INT 1
131853: PLUS
131854: PPUSH
131855: LD_VAR 0 9
131859: PUSH
131860: LD_VAR 0 10
131864: PUSH
131865: EMPTY
131866: LIST
131867: LIST
131868: PPUSH
131869: CALL_OW 1
131873: ST_TO_ADDR
131874: GO 131890
// i := i - 1 ;
131876: LD_ADDR_VAR 0 5
131880: PUSH
131881: LD_VAR 0 5
131885: PUSH
131886: LD_INT 1
131888: MINUS
131889: ST_TO_ADDR
// end ;
131890: GO 131696
131892: POP
131893: POP
// for i in tmp do
131894: LD_ADDR_VAR 0 5
131898: PUSH
131899: LD_VAR 0 7
131903: PUSH
131904: FOR_IN
131905: IFFALSE 131943
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
131907: LD_VAR 0 1
131911: PPUSH
131912: LD_VAR 0 5
131916: PUSH
131917: LD_INT 1
131919: ARRAY
131920: PPUSH
131921: LD_VAR 0 5
131925: PUSH
131926: LD_INT 2
131928: ARRAY
131929: PPUSH
131930: CALL 130889 0 3
131934: NOT
131935: IFFALSE 131941
// exit ;
131937: POP
131938: POP
131939: GO 131945
131941: GO 131904
131943: POP
131944: POP
// end ;
131945: LD_VAR 0 4
131949: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
131950: LD_INT 0
131952: PPUSH
131953: PPUSH
131954: PPUSH
131955: PPUSH
131956: PPUSH
131957: PPUSH
131958: PPUSH
// if not GetClass ( unit ) = class_sniper then
131959: LD_VAR 0 1
131963: PPUSH
131964: CALL_OW 257
131968: PUSH
131969: LD_INT 5
131971: EQUAL
131972: NOT
131973: IFFALSE 131977
// exit ;
131975: GO 132365
// dist := 8 ;
131977: LD_ADDR_VAR 0 5
131981: PUSH
131982: LD_INT 8
131984: ST_TO_ADDR
// viewRange := 12 ;
131985: LD_ADDR_VAR 0 7
131989: PUSH
131990: LD_INT 12
131992: ST_TO_ADDR
// side := GetSide ( unit ) ;
131993: LD_ADDR_VAR 0 6
131997: PUSH
131998: LD_VAR 0 1
132002: PPUSH
132003: CALL_OW 255
132007: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132008: LD_INT 61
132010: PPUSH
132011: LD_VAR 0 6
132015: PPUSH
132016: CALL_OW 321
132020: PUSH
132021: LD_INT 2
132023: EQUAL
132024: IFFALSE 132034
// viewRange := 16 ;
132026: LD_ADDR_VAR 0 7
132030: PUSH
132031: LD_INT 16
132033: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132034: LD_VAR 0 1
132038: PPUSH
132039: LD_VAR 0 2
132043: PPUSH
132044: LD_VAR 0 3
132048: PPUSH
132049: CALL_OW 297
132053: PUSH
132054: LD_VAR 0 5
132058: GREATER
132059: IFFALSE 132138
// begin ComMoveXY ( unit , x , y ) ;
132061: LD_VAR 0 1
132065: PPUSH
132066: LD_VAR 0 2
132070: PPUSH
132071: LD_VAR 0 3
132075: PPUSH
132076: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132080: LD_INT 35
132082: PPUSH
132083: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132087: LD_VAR 0 1
132091: PPUSH
132092: LD_VAR 0 2
132096: PPUSH
132097: LD_VAR 0 3
132101: PPUSH
132102: CALL 105941 0 3
132106: NOT
132107: IFFALSE 132111
// exit ;
132109: GO 132365
// until GetDistUnitXY ( unit , x , y ) < dist ;
132111: LD_VAR 0 1
132115: PPUSH
132116: LD_VAR 0 2
132120: PPUSH
132121: LD_VAR 0 3
132125: PPUSH
132126: CALL_OW 297
132130: PUSH
132131: LD_VAR 0 5
132135: LESS
132136: IFFALSE 132080
// end ; ComTurnXY ( unit , x , y ) ;
132138: LD_VAR 0 1
132142: PPUSH
132143: LD_VAR 0 2
132147: PPUSH
132148: LD_VAR 0 3
132152: PPUSH
132153: CALL_OW 118
// wait ( 5 ) ;
132157: LD_INT 5
132159: PPUSH
132160: CALL_OW 67
// _d := GetDir ( unit ) ;
132164: LD_ADDR_VAR 0 10
132168: PUSH
132169: LD_VAR 0 1
132173: PPUSH
132174: CALL_OW 254
132178: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
132179: LD_ADDR_VAR 0 8
132183: PUSH
132184: LD_VAR 0 1
132188: PPUSH
132189: CALL_OW 250
132193: PPUSH
132194: LD_VAR 0 10
132198: PPUSH
132199: LD_VAR 0 5
132203: PPUSH
132204: CALL_OW 272
132208: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
132209: LD_ADDR_VAR 0 9
132213: PUSH
132214: LD_VAR 0 1
132218: PPUSH
132219: CALL_OW 251
132223: PPUSH
132224: LD_VAR 0 10
132228: PPUSH
132229: LD_VAR 0 5
132233: PPUSH
132234: CALL_OW 273
132238: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
132239: LD_VAR 0 8
132243: PPUSH
132244: LD_VAR 0 9
132248: PPUSH
132249: CALL_OW 488
132253: NOT
132254: IFFALSE 132258
// exit ;
132256: GO 132365
// ComAnimCustom ( unit , 1 ) ;
132258: LD_VAR 0 1
132262: PPUSH
132263: LD_INT 1
132265: PPUSH
132266: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
132270: LD_VAR 0 8
132274: PPUSH
132275: LD_VAR 0 9
132279: PPUSH
132280: LD_VAR 0 6
132284: PPUSH
132285: LD_VAR 0 7
132289: PPUSH
132290: CALL_OW 330
// repeat wait ( 1 ) ;
132294: LD_INT 1
132296: PPUSH
132297: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
132301: LD_VAR 0 1
132305: PPUSH
132306: CALL_OW 316
132310: PUSH
132311: LD_VAR 0 1
132315: PPUSH
132316: CALL_OW 314
132320: OR
132321: PUSH
132322: LD_VAR 0 1
132326: PPUSH
132327: CALL_OW 302
132331: NOT
132332: OR
132333: PUSH
132334: LD_VAR 0 1
132338: PPUSH
132339: CALL_OW 301
132343: OR
132344: IFFALSE 132294
// RemoveSeeing ( _x , _y , side ) ;
132346: LD_VAR 0 8
132350: PPUSH
132351: LD_VAR 0 9
132355: PPUSH
132356: LD_VAR 0 6
132360: PPUSH
132361: CALL_OW 331
// end ; end_of_file
132365: LD_VAR 0 4
132369: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
132370: LD_INT 0
132372: PPUSH
132373: PPUSH
132374: PPUSH
132375: PPUSH
132376: PPUSH
132377: PPUSH
132378: PPUSH
132379: PPUSH
132380: PPUSH
132381: PPUSH
132382: PPUSH
132383: PPUSH
132384: PPUSH
132385: PPUSH
132386: PPUSH
132387: PPUSH
132388: PPUSH
132389: PPUSH
132390: PPUSH
132391: PPUSH
132392: PPUSH
132393: PPUSH
132394: PPUSH
132395: PPUSH
132396: PPUSH
132397: PPUSH
132398: PPUSH
132399: PPUSH
132400: PPUSH
132401: PPUSH
132402: PPUSH
132403: PPUSH
132404: PPUSH
132405: PPUSH
// if not list then
132406: LD_VAR 0 1
132410: NOT
132411: IFFALSE 132415
// exit ;
132413: GO 137074
// base := list [ 1 ] ;
132415: LD_ADDR_VAR 0 3
132419: PUSH
132420: LD_VAR 0 1
132424: PUSH
132425: LD_INT 1
132427: ARRAY
132428: ST_TO_ADDR
// group := list [ 2 ] ;
132429: LD_ADDR_VAR 0 4
132433: PUSH
132434: LD_VAR 0 1
132438: PUSH
132439: LD_INT 2
132441: ARRAY
132442: ST_TO_ADDR
// path := list [ 3 ] ;
132443: LD_ADDR_VAR 0 5
132447: PUSH
132448: LD_VAR 0 1
132452: PUSH
132453: LD_INT 3
132455: ARRAY
132456: ST_TO_ADDR
// flags := list [ 4 ] ;
132457: LD_ADDR_VAR 0 6
132461: PUSH
132462: LD_VAR 0 1
132466: PUSH
132467: LD_INT 4
132469: ARRAY
132470: ST_TO_ADDR
// mined := [ ] ;
132471: LD_ADDR_VAR 0 27
132475: PUSH
132476: EMPTY
132477: ST_TO_ADDR
// bombed := [ ] ;
132478: LD_ADDR_VAR 0 28
132482: PUSH
132483: EMPTY
132484: ST_TO_ADDR
// healers := [ ] ;
132485: LD_ADDR_VAR 0 31
132489: PUSH
132490: EMPTY
132491: ST_TO_ADDR
// to_heal := [ ] ;
132492: LD_ADDR_VAR 0 30
132496: PUSH
132497: EMPTY
132498: ST_TO_ADDR
// repairs := [ ] ;
132499: LD_ADDR_VAR 0 33
132503: PUSH
132504: EMPTY
132505: ST_TO_ADDR
// to_repair := [ ] ;
132506: LD_ADDR_VAR 0 32
132510: PUSH
132511: EMPTY
132512: ST_TO_ADDR
// if not group or not path then
132513: LD_VAR 0 4
132517: NOT
132518: PUSH
132519: LD_VAR 0 5
132523: NOT
132524: OR
132525: IFFALSE 132529
// exit ;
132527: GO 137074
// side := GetSide ( group [ 1 ] ) ;
132529: LD_ADDR_VAR 0 35
132533: PUSH
132534: LD_VAR 0 4
132538: PUSH
132539: LD_INT 1
132541: ARRAY
132542: PPUSH
132543: CALL_OW 255
132547: ST_TO_ADDR
// if flags then
132548: LD_VAR 0 6
132552: IFFALSE 132696
// begin f_ignore_area := flags [ 1 ] ;
132554: LD_ADDR_VAR 0 17
132558: PUSH
132559: LD_VAR 0 6
132563: PUSH
132564: LD_INT 1
132566: ARRAY
132567: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
132568: LD_ADDR_VAR 0 18
132572: PUSH
132573: LD_VAR 0 6
132577: PUSH
132578: LD_INT 2
132580: ARRAY
132581: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
132582: LD_ADDR_VAR 0 19
132586: PUSH
132587: LD_VAR 0 6
132591: PUSH
132592: LD_INT 3
132594: ARRAY
132595: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
132596: LD_ADDR_VAR 0 20
132600: PUSH
132601: LD_VAR 0 6
132605: PUSH
132606: LD_INT 4
132608: ARRAY
132609: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
132610: LD_ADDR_VAR 0 21
132614: PUSH
132615: LD_VAR 0 6
132619: PUSH
132620: LD_INT 5
132622: ARRAY
132623: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
132624: LD_ADDR_VAR 0 22
132628: PUSH
132629: LD_VAR 0 6
132633: PUSH
132634: LD_INT 6
132636: ARRAY
132637: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
132638: LD_ADDR_VAR 0 23
132642: PUSH
132643: LD_VAR 0 6
132647: PUSH
132648: LD_INT 7
132650: ARRAY
132651: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
132652: LD_ADDR_VAR 0 24
132656: PUSH
132657: LD_VAR 0 6
132661: PUSH
132662: LD_INT 8
132664: ARRAY
132665: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
132666: LD_ADDR_VAR 0 25
132670: PUSH
132671: LD_VAR 0 6
132675: PUSH
132676: LD_INT 9
132678: ARRAY
132679: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
132680: LD_ADDR_VAR 0 26
132684: PUSH
132685: LD_VAR 0 6
132689: PUSH
132690: LD_INT 10
132692: ARRAY
132693: ST_TO_ADDR
// end else
132694: GO 132776
// begin f_ignore_area := false ;
132696: LD_ADDR_VAR 0 17
132700: PUSH
132701: LD_INT 0
132703: ST_TO_ADDR
// f_capture := false ;
132704: LD_ADDR_VAR 0 18
132708: PUSH
132709: LD_INT 0
132711: ST_TO_ADDR
// f_ignore_civ := false ;
132712: LD_ADDR_VAR 0 19
132716: PUSH
132717: LD_INT 0
132719: ST_TO_ADDR
// f_murder := false ;
132720: LD_ADDR_VAR 0 20
132724: PUSH
132725: LD_INT 0
132727: ST_TO_ADDR
// f_mines := false ;
132728: LD_ADDR_VAR 0 21
132732: PUSH
132733: LD_INT 0
132735: ST_TO_ADDR
// f_repair := false ;
132736: LD_ADDR_VAR 0 22
132740: PUSH
132741: LD_INT 0
132743: ST_TO_ADDR
// f_heal := false ;
132744: LD_ADDR_VAR 0 23
132748: PUSH
132749: LD_INT 0
132751: ST_TO_ADDR
// f_spacetime := false ;
132752: LD_ADDR_VAR 0 24
132756: PUSH
132757: LD_INT 0
132759: ST_TO_ADDR
// f_attack_depot := false ;
132760: LD_ADDR_VAR 0 25
132764: PUSH
132765: LD_INT 0
132767: ST_TO_ADDR
// f_crawl := false ;
132768: LD_ADDR_VAR 0 26
132772: PUSH
132773: LD_INT 0
132775: ST_TO_ADDR
// end ; if f_heal then
132776: LD_VAR 0 23
132780: IFFALSE 132807
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
132782: LD_ADDR_VAR 0 31
132786: PUSH
132787: LD_VAR 0 4
132791: PPUSH
132792: LD_INT 25
132794: PUSH
132795: LD_INT 4
132797: PUSH
132798: EMPTY
132799: LIST
132800: LIST
132801: PPUSH
132802: CALL_OW 72
132806: ST_TO_ADDR
// if f_repair then
132807: LD_VAR 0 22
132811: IFFALSE 132838
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
132813: LD_ADDR_VAR 0 33
132817: PUSH
132818: LD_VAR 0 4
132822: PPUSH
132823: LD_INT 25
132825: PUSH
132826: LD_INT 3
132828: PUSH
132829: EMPTY
132830: LIST
132831: LIST
132832: PPUSH
132833: CALL_OW 72
132837: ST_TO_ADDR
// units_path := [ ] ;
132838: LD_ADDR_VAR 0 16
132842: PUSH
132843: EMPTY
132844: ST_TO_ADDR
// for i = 1 to group do
132845: LD_ADDR_VAR 0 7
132849: PUSH
132850: DOUBLE
132851: LD_INT 1
132853: DEC
132854: ST_TO_ADDR
132855: LD_VAR 0 4
132859: PUSH
132860: FOR_TO
132861: IFFALSE 132890
// units_path := Replace ( units_path , i , path ) ;
132863: LD_ADDR_VAR 0 16
132867: PUSH
132868: LD_VAR 0 16
132872: PPUSH
132873: LD_VAR 0 7
132877: PPUSH
132878: LD_VAR 0 5
132882: PPUSH
132883: CALL_OW 1
132887: ST_TO_ADDR
132888: GO 132860
132890: POP
132891: POP
// repeat for i = group downto 1 do
132892: LD_ADDR_VAR 0 7
132896: PUSH
132897: DOUBLE
132898: LD_VAR 0 4
132902: INC
132903: ST_TO_ADDR
132904: LD_INT 1
132906: PUSH
132907: FOR_DOWNTO
132908: IFFALSE 137030
// begin wait ( 5 ) ;
132910: LD_INT 5
132912: PPUSH
132913: CALL_OW 67
// tmp := [ ] ;
132917: LD_ADDR_VAR 0 14
132921: PUSH
132922: EMPTY
132923: ST_TO_ADDR
// attacking := false ;
132924: LD_ADDR_VAR 0 29
132928: PUSH
132929: LD_INT 0
132931: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
132932: LD_VAR 0 4
132936: PUSH
132937: LD_VAR 0 7
132941: ARRAY
132942: PPUSH
132943: CALL_OW 301
132947: PUSH
132948: LD_VAR 0 4
132952: PUSH
132953: LD_VAR 0 7
132957: ARRAY
132958: NOT
132959: OR
132960: IFFALSE 133069
// begin if GetType ( group [ i ] ) = unit_human then
132962: LD_VAR 0 4
132966: PUSH
132967: LD_VAR 0 7
132971: ARRAY
132972: PPUSH
132973: CALL_OW 247
132977: PUSH
132978: LD_INT 1
132980: EQUAL
132981: IFFALSE 133027
// begin to_heal := to_heal diff group [ i ] ;
132983: LD_ADDR_VAR 0 30
132987: PUSH
132988: LD_VAR 0 30
132992: PUSH
132993: LD_VAR 0 4
132997: PUSH
132998: LD_VAR 0 7
133002: ARRAY
133003: DIFF
133004: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133005: LD_ADDR_VAR 0 31
133009: PUSH
133010: LD_VAR 0 31
133014: PUSH
133015: LD_VAR 0 4
133019: PUSH
133020: LD_VAR 0 7
133024: ARRAY
133025: DIFF
133026: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133027: LD_ADDR_VAR 0 4
133031: PUSH
133032: LD_VAR 0 4
133036: PPUSH
133037: LD_VAR 0 7
133041: PPUSH
133042: CALL_OW 3
133046: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133047: LD_ADDR_VAR 0 16
133051: PUSH
133052: LD_VAR 0 16
133056: PPUSH
133057: LD_VAR 0 7
133061: PPUSH
133062: CALL_OW 3
133066: ST_TO_ADDR
// continue ;
133067: GO 132907
// end ; if f_repair then
133069: LD_VAR 0 22
133073: IFFALSE 133562
// begin if GetType ( group [ i ] ) = unit_vehicle then
133075: LD_VAR 0 4
133079: PUSH
133080: LD_VAR 0 7
133084: ARRAY
133085: PPUSH
133086: CALL_OW 247
133090: PUSH
133091: LD_INT 2
133093: EQUAL
133094: IFFALSE 133284
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133096: LD_VAR 0 4
133100: PUSH
133101: LD_VAR 0 7
133105: ARRAY
133106: PPUSH
133107: CALL_OW 256
133111: PUSH
133112: LD_INT 700
133114: LESS
133115: PUSH
133116: LD_VAR 0 4
133120: PUSH
133121: LD_VAR 0 7
133125: ARRAY
133126: PUSH
133127: LD_VAR 0 32
133131: IN
133132: NOT
133133: AND
133134: IFFALSE 133158
// to_repair := to_repair union group [ i ] ;
133136: LD_ADDR_VAR 0 32
133140: PUSH
133141: LD_VAR 0 32
133145: PUSH
133146: LD_VAR 0 4
133150: PUSH
133151: LD_VAR 0 7
133155: ARRAY
133156: UNION
133157: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133158: LD_VAR 0 4
133162: PUSH
133163: LD_VAR 0 7
133167: ARRAY
133168: PPUSH
133169: CALL_OW 256
133173: PUSH
133174: LD_INT 1000
133176: EQUAL
133177: PUSH
133178: LD_VAR 0 4
133182: PUSH
133183: LD_VAR 0 7
133187: ARRAY
133188: PUSH
133189: LD_VAR 0 32
133193: IN
133194: AND
133195: IFFALSE 133219
// to_repair := to_repair diff group [ i ] ;
133197: LD_ADDR_VAR 0 32
133201: PUSH
133202: LD_VAR 0 32
133206: PUSH
133207: LD_VAR 0 4
133211: PUSH
133212: LD_VAR 0 7
133216: ARRAY
133217: DIFF
133218: ST_TO_ADDR
// if group [ i ] in to_repair then
133219: LD_VAR 0 4
133223: PUSH
133224: LD_VAR 0 7
133228: ARRAY
133229: PUSH
133230: LD_VAR 0 32
133234: IN
133235: IFFALSE 133282
// begin if not IsInArea ( group [ i ] , f_repair ) then
133237: LD_VAR 0 4
133241: PUSH
133242: LD_VAR 0 7
133246: ARRAY
133247: PPUSH
133248: LD_VAR 0 22
133252: PPUSH
133253: CALL_OW 308
133257: NOT
133258: IFFALSE 133280
// ComMoveToArea ( group [ i ] , f_repair ) ;
133260: LD_VAR 0 4
133264: PUSH
133265: LD_VAR 0 7
133269: ARRAY
133270: PPUSH
133271: LD_VAR 0 22
133275: PPUSH
133276: CALL_OW 113
// continue ;
133280: GO 132907
// end ; end else
133282: GO 133562
// if group [ i ] in repairs then
133284: LD_VAR 0 4
133288: PUSH
133289: LD_VAR 0 7
133293: ARRAY
133294: PUSH
133295: LD_VAR 0 33
133299: IN
133300: IFFALSE 133562
// begin if IsInUnit ( group [ i ] ) then
133302: LD_VAR 0 4
133306: PUSH
133307: LD_VAR 0 7
133311: ARRAY
133312: PPUSH
133313: CALL_OW 310
133317: IFFALSE 133385
// begin z := IsInUnit ( group [ i ] ) ;
133319: LD_ADDR_VAR 0 13
133323: PUSH
133324: LD_VAR 0 4
133328: PUSH
133329: LD_VAR 0 7
133333: ARRAY
133334: PPUSH
133335: CALL_OW 310
133339: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
133340: LD_VAR 0 13
133344: PUSH
133345: LD_VAR 0 32
133349: IN
133350: PUSH
133351: LD_VAR 0 13
133355: PPUSH
133356: LD_VAR 0 22
133360: PPUSH
133361: CALL_OW 308
133365: AND
133366: IFFALSE 133383
// ComExitVehicle ( group [ i ] ) ;
133368: LD_VAR 0 4
133372: PUSH
133373: LD_VAR 0 7
133377: ARRAY
133378: PPUSH
133379: CALL_OW 121
// end else
133383: GO 133562
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
133385: LD_ADDR_VAR 0 13
133389: PUSH
133390: LD_VAR 0 4
133394: PPUSH
133395: LD_INT 95
133397: PUSH
133398: LD_VAR 0 22
133402: PUSH
133403: EMPTY
133404: LIST
133405: LIST
133406: PUSH
133407: LD_INT 58
133409: PUSH
133410: EMPTY
133411: LIST
133412: PUSH
133413: EMPTY
133414: LIST
133415: LIST
133416: PPUSH
133417: CALL_OW 72
133421: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
133422: LD_VAR 0 4
133426: PUSH
133427: LD_VAR 0 7
133431: ARRAY
133432: PPUSH
133433: CALL_OW 314
133437: NOT
133438: IFFALSE 133560
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
133440: LD_ADDR_VAR 0 10
133444: PUSH
133445: LD_VAR 0 13
133449: PPUSH
133450: LD_VAR 0 4
133454: PUSH
133455: LD_VAR 0 7
133459: ARRAY
133460: PPUSH
133461: CALL_OW 74
133465: ST_TO_ADDR
// if not x then
133466: LD_VAR 0 10
133470: NOT
133471: IFFALSE 133475
// continue ;
133473: GO 132907
// if GetLives ( x ) < 1000 then
133475: LD_VAR 0 10
133479: PPUSH
133480: CALL_OW 256
133484: PUSH
133485: LD_INT 1000
133487: LESS
133488: IFFALSE 133512
// ComRepairVehicle ( group [ i ] , x ) else
133490: LD_VAR 0 4
133494: PUSH
133495: LD_VAR 0 7
133499: ARRAY
133500: PPUSH
133501: LD_VAR 0 10
133505: PPUSH
133506: CALL_OW 129
133510: GO 133560
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
133512: LD_VAR 0 23
133516: PUSH
133517: LD_VAR 0 4
133521: PUSH
133522: LD_VAR 0 7
133526: ARRAY
133527: PPUSH
133528: CALL_OW 256
133532: PUSH
133533: LD_INT 1000
133535: LESS
133536: AND
133537: NOT
133538: IFFALSE 133560
// ComEnterUnit ( group [ i ] , x ) ;
133540: LD_VAR 0 4
133544: PUSH
133545: LD_VAR 0 7
133549: ARRAY
133550: PPUSH
133551: LD_VAR 0 10
133555: PPUSH
133556: CALL_OW 120
// end ; continue ;
133560: GO 132907
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
133562: LD_VAR 0 23
133566: PUSH
133567: LD_VAR 0 4
133571: PUSH
133572: LD_VAR 0 7
133576: ARRAY
133577: PPUSH
133578: CALL_OW 247
133582: PUSH
133583: LD_INT 1
133585: EQUAL
133586: AND
133587: IFFALSE 134065
// begin if group [ i ] in healers then
133589: LD_VAR 0 4
133593: PUSH
133594: LD_VAR 0 7
133598: ARRAY
133599: PUSH
133600: LD_VAR 0 31
133604: IN
133605: IFFALSE 133878
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
133607: LD_VAR 0 4
133611: PUSH
133612: LD_VAR 0 7
133616: ARRAY
133617: PPUSH
133618: LD_VAR 0 23
133622: PPUSH
133623: CALL_OW 308
133627: NOT
133628: PUSH
133629: LD_VAR 0 4
133633: PUSH
133634: LD_VAR 0 7
133638: ARRAY
133639: PPUSH
133640: CALL_OW 314
133644: NOT
133645: AND
133646: IFFALSE 133670
// ComMoveToArea ( group [ i ] , f_heal ) else
133648: LD_VAR 0 4
133652: PUSH
133653: LD_VAR 0 7
133657: ARRAY
133658: PPUSH
133659: LD_VAR 0 23
133663: PPUSH
133664: CALL_OW 113
133668: GO 133876
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
133670: LD_VAR 0 4
133674: PUSH
133675: LD_VAR 0 7
133679: ARRAY
133680: PPUSH
133681: CALL 104524 0 1
133685: PPUSH
133686: CALL_OW 256
133690: PUSH
133691: LD_INT 1000
133693: EQUAL
133694: IFFALSE 133713
// ComStop ( group [ i ] ) else
133696: LD_VAR 0 4
133700: PUSH
133701: LD_VAR 0 7
133705: ARRAY
133706: PPUSH
133707: CALL_OW 141
133711: GO 133876
// if not HasTask ( group [ i ] ) and to_heal then
133713: LD_VAR 0 4
133717: PUSH
133718: LD_VAR 0 7
133722: ARRAY
133723: PPUSH
133724: CALL_OW 314
133728: NOT
133729: PUSH
133730: LD_VAR 0 30
133734: AND
133735: IFFALSE 133876
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
133737: LD_ADDR_VAR 0 13
133741: PUSH
133742: LD_VAR 0 30
133746: PPUSH
133747: LD_INT 3
133749: PUSH
133750: LD_INT 54
133752: PUSH
133753: EMPTY
133754: LIST
133755: PUSH
133756: EMPTY
133757: LIST
133758: LIST
133759: PPUSH
133760: CALL_OW 72
133764: PPUSH
133765: LD_VAR 0 4
133769: PUSH
133770: LD_VAR 0 7
133774: ARRAY
133775: PPUSH
133776: CALL_OW 74
133780: ST_TO_ADDR
// if z then
133781: LD_VAR 0 13
133785: IFFALSE 133876
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
133787: LD_INT 91
133789: PUSH
133790: LD_VAR 0 13
133794: PUSH
133795: LD_INT 10
133797: PUSH
133798: EMPTY
133799: LIST
133800: LIST
133801: LIST
133802: PUSH
133803: LD_INT 81
133805: PUSH
133806: LD_VAR 0 13
133810: PPUSH
133811: CALL_OW 255
133815: PUSH
133816: EMPTY
133817: LIST
133818: LIST
133819: PUSH
133820: EMPTY
133821: LIST
133822: LIST
133823: PPUSH
133824: CALL_OW 69
133828: PUSH
133829: LD_INT 0
133831: EQUAL
133832: IFFALSE 133856
// ComHeal ( group [ i ] , z ) else
133834: LD_VAR 0 4
133838: PUSH
133839: LD_VAR 0 7
133843: ARRAY
133844: PPUSH
133845: LD_VAR 0 13
133849: PPUSH
133850: CALL_OW 128
133854: GO 133876
// ComMoveToArea ( group [ i ] , f_heal ) ;
133856: LD_VAR 0 4
133860: PUSH
133861: LD_VAR 0 7
133865: ARRAY
133866: PPUSH
133867: LD_VAR 0 23
133871: PPUSH
133872: CALL_OW 113
// end ; continue ;
133876: GO 132907
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
133878: LD_VAR 0 4
133882: PUSH
133883: LD_VAR 0 7
133887: ARRAY
133888: PPUSH
133889: CALL_OW 256
133893: PUSH
133894: LD_INT 700
133896: LESS
133897: PUSH
133898: LD_VAR 0 4
133902: PUSH
133903: LD_VAR 0 7
133907: ARRAY
133908: PUSH
133909: LD_VAR 0 30
133913: IN
133914: NOT
133915: AND
133916: IFFALSE 133940
// to_heal := to_heal union group [ i ] ;
133918: LD_ADDR_VAR 0 30
133922: PUSH
133923: LD_VAR 0 30
133927: PUSH
133928: LD_VAR 0 4
133932: PUSH
133933: LD_VAR 0 7
133937: ARRAY
133938: UNION
133939: ST_TO_ADDR
// if group [ i ] in to_heal then
133940: LD_VAR 0 4
133944: PUSH
133945: LD_VAR 0 7
133949: ARRAY
133950: PUSH
133951: LD_VAR 0 30
133955: IN
133956: IFFALSE 134065
// begin if GetLives ( group [ i ] ) = 1000 then
133958: LD_VAR 0 4
133962: PUSH
133963: LD_VAR 0 7
133967: ARRAY
133968: PPUSH
133969: CALL_OW 256
133973: PUSH
133974: LD_INT 1000
133976: EQUAL
133977: IFFALSE 134003
// to_heal := to_heal diff group [ i ] else
133979: LD_ADDR_VAR 0 30
133983: PUSH
133984: LD_VAR 0 30
133988: PUSH
133989: LD_VAR 0 4
133993: PUSH
133994: LD_VAR 0 7
133998: ARRAY
133999: DIFF
134000: ST_TO_ADDR
134001: GO 134065
// begin if not IsInArea ( group [ i ] , to_heal ) then
134003: LD_VAR 0 4
134007: PUSH
134008: LD_VAR 0 7
134012: ARRAY
134013: PPUSH
134014: LD_VAR 0 30
134018: PPUSH
134019: CALL_OW 308
134023: NOT
134024: IFFALSE 134048
// ComMoveToArea ( group [ i ] , f_heal ) else
134026: LD_VAR 0 4
134030: PUSH
134031: LD_VAR 0 7
134035: ARRAY
134036: PPUSH
134037: LD_VAR 0 23
134041: PPUSH
134042: CALL_OW 113
134046: GO 134063
// ComHold ( group [ i ] ) ;
134048: LD_VAR 0 4
134052: PUSH
134053: LD_VAR 0 7
134057: ARRAY
134058: PPUSH
134059: CALL_OW 140
// continue ;
134063: GO 132907
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134065: LD_VAR 0 4
134069: PUSH
134070: LD_VAR 0 7
134074: ARRAY
134075: PPUSH
134076: LD_INT 10
134078: PPUSH
134079: CALL 102295 0 2
134083: NOT
134084: PUSH
134085: LD_VAR 0 16
134089: PUSH
134090: LD_VAR 0 7
134094: ARRAY
134095: PUSH
134096: EMPTY
134097: EQUAL
134098: NOT
134099: AND
134100: IFFALSE 134366
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134102: LD_VAR 0 4
134106: PUSH
134107: LD_VAR 0 7
134111: ARRAY
134112: PPUSH
134113: CALL_OW 262
134117: PUSH
134118: LD_INT 1
134120: PUSH
134121: LD_INT 2
134123: PUSH
134124: EMPTY
134125: LIST
134126: LIST
134127: IN
134128: IFFALSE 134169
// if GetFuel ( group [ i ] ) < 10 then
134130: LD_VAR 0 4
134134: PUSH
134135: LD_VAR 0 7
134139: ARRAY
134140: PPUSH
134141: CALL_OW 261
134145: PUSH
134146: LD_INT 10
134148: LESS
134149: IFFALSE 134169
// SetFuel ( group [ i ] , 12 ) ;
134151: LD_VAR 0 4
134155: PUSH
134156: LD_VAR 0 7
134160: ARRAY
134161: PPUSH
134162: LD_INT 12
134164: PPUSH
134165: CALL_OW 240
// if units_path [ i ] then
134169: LD_VAR 0 16
134173: PUSH
134174: LD_VAR 0 7
134178: ARRAY
134179: IFFALSE 134364
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
134181: LD_VAR 0 4
134185: PUSH
134186: LD_VAR 0 7
134190: ARRAY
134191: PPUSH
134192: LD_VAR 0 16
134196: PUSH
134197: LD_VAR 0 7
134201: ARRAY
134202: PUSH
134203: LD_INT 1
134205: ARRAY
134206: PUSH
134207: LD_INT 1
134209: ARRAY
134210: PPUSH
134211: LD_VAR 0 16
134215: PUSH
134216: LD_VAR 0 7
134220: ARRAY
134221: PUSH
134222: LD_INT 1
134224: ARRAY
134225: PUSH
134226: LD_INT 2
134228: ARRAY
134229: PPUSH
134230: CALL_OW 297
134234: PUSH
134235: LD_INT 6
134237: GREATER
134238: IFFALSE 134313
// begin if not HasTask ( group [ i ] ) then
134240: LD_VAR 0 4
134244: PUSH
134245: LD_VAR 0 7
134249: ARRAY
134250: PPUSH
134251: CALL_OW 314
134255: NOT
134256: IFFALSE 134311
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
134258: LD_VAR 0 4
134262: PUSH
134263: LD_VAR 0 7
134267: ARRAY
134268: PPUSH
134269: LD_VAR 0 16
134273: PUSH
134274: LD_VAR 0 7
134278: ARRAY
134279: PUSH
134280: LD_INT 1
134282: ARRAY
134283: PUSH
134284: LD_INT 1
134286: ARRAY
134287: PPUSH
134288: LD_VAR 0 16
134292: PUSH
134293: LD_VAR 0 7
134297: ARRAY
134298: PUSH
134299: LD_INT 1
134301: ARRAY
134302: PUSH
134303: LD_INT 2
134305: ARRAY
134306: PPUSH
134307: CALL_OW 114
// end else
134311: GO 134364
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
134313: LD_ADDR_VAR 0 15
134317: PUSH
134318: LD_VAR 0 16
134322: PUSH
134323: LD_VAR 0 7
134327: ARRAY
134328: PPUSH
134329: LD_INT 1
134331: PPUSH
134332: CALL_OW 3
134336: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
134337: LD_ADDR_VAR 0 16
134341: PUSH
134342: LD_VAR 0 16
134346: PPUSH
134347: LD_VAR 0 7
134351: PPUSH
134352: LD_VAR 0 15
134356: PPUSH
134357: CALL_OW 1
134361: ST_TO_ADDR
// continue ;
134362: GO 132907
// end ; end ; end else
134364: GO 137028
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
134366: LD_ADDR_VAR 0 14
134370: PUSH
134371: LD_INT 81
134373: PUSH
134374: LD_VAR 0 4
134378: PUSH
134379: LD_VAR 0 7
134383: ARRAY
134384: PPUSH
134385: CALL_OW 255
134389: PUSH
134390: EMPTY
134391: LIST
134392: LIST
134393: PPUSH
134394: CALL_OW 69
134398: ST_TO_ADDR
// if not tmp then
134399: LD_VAR 0 14
134403: NOT
134404: IFFALSE 134408
// continue ;
134406: GO 132907
// if f_ignore_area then
134408: LD_VAR 0 17
134412: IFFALSE 134500
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
134414: LD_ADDR_VAR 0 15
134418: PUSH
134419: LD_VAR 0 14
134423: PPUSH
134424: LD_INT 3
134426: PUSH
134427: LD_INT 92
134429: PUSH
134430: LD_VAR 0 17
134434: PUSH
134435: LD_INT 1
134437: ARRAY
134438: PUSH
134439: LD_VAR 0 17
134443: PUSH
134444: LD_INT 2
134446: ARRAY
134447: PUSH
134448: LD_VAR 0 17
134452: PUSH
134453: LD_INT 3
134455: ARRAY
134456: PUSH
134457: EMPTY
134458: LIST
134459: LIST
134460: LIST
134461: LIST
134462: PUSH
134463: EMPTY
134464: LIST
134465: LIST
134466: PPUSH
134467: CALL_OW 72
134471: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
134472: LD_VAR 0 14
134476: PUSH
134477: LD_VAR 0 15
134481: DIFF
134482: IFFALSE 134500
// tmp := tmp diff tmp2 ;
134484: LD_ADDR_VAR 0 14
134488: PUSH
134489: LD_VAR 0 14
134493: PUSH
134494: LD_VAR 0 15
134498: DIFF
134499: ST_TO_ADDR
// end ; if not f_murder then
134500: LD_VAR 0 20
134504: NOT
134505: IFFALSE 134563
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
134507: LD_ADDR_VAR 0 15
134511: PUSH
134512: LD_VAR 0 14
134516: PPUSH
134517: LD_INT 3
134519: PUSH
134520: LD_INT 50
134522: PUSH
134523: EMPTY
134524: LIST
134525: PUSH
134526: EMPTY
134527: LIST
134528: LIST
134529: PPUSH
134530: CALL_OW 72
134534: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
134535: LD_VAR 0 14
134539: PUSH
134540: LD_VAR 0 15
134544: DIFF
134545: IFFALSE 134563
// tmp := tmp diff tmp2 ;
134547: LD_ADDR_VAR 0 14
134551: PUSH
134552: LD_VAR 0 14
134556: PUSH
134557: LD_VAR 0 15
134561: DIFF
134562: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
134563: LD_ADDR_VAR 0 14
134567: PUSH
134568: LD_VAR 0 4
134572: PUSH
134573: LD_VAR 0 7
134577: ARRAY
134578: PPUSH
134579: LD_VAR 0 14
134583: PPUSH
134584: LD_INT 1
134586: PPUSH
134587: LD_INT 1
134589: PPUSH
134590: CALL 74839 0 4
134594: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
134595: LD_VAR 0 4
134599: PUSH
134600: LD_VAR 0 7
134604: ARRAY
134605: PPUSH
134606: CALL_OW 257
134610: PUSH
134611: LD_INT 1
134613: EQUAL
134614: IFFALSE 135062
// begin if WantPlant ( group [ i ] ) then
134616: LD_VAR 0 4
134620: PUSH
134621: LD_VAR 0 7
134625: ARRAY
134626: PPUSH
134627: CALL 74340 0 1
134631: IFFALSE 134635
// continue ;
134633: GO 132907
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
134635: LD_VAR 0 18
134639: PUSH
134640: LD_VAR 0 4
134644: PUSH
134645: LD_VAR 0 7
134649: ARRAY
134650: PPUSH
134651: CALL_OW 310
134655: NOT
134656: AND
134657: PUSH
134658: LD_VAR 0 14
134662: PUSH
134663: LD_INT 1
134665: ARRAY
134666: PUSH
134667: LD_VAR 0 14
134671: PPUSH
134672: LD_INT 21
134674: PUSH
134675: LD_INT 2
134677: PUSH
134678: EMPTY
134679: LIST
134680: LIST
134681: PUSH
134682: LD_INT 58
134684: PUSH
134685: EMPTY
134686: LIST
134687: PUSH
134688: EMPTY
134689: LIST
134690: LIST
134691: PPUSH
134692: CALL_OW 72
134696: IN
134697: AND
134698: IFFALSE 134734
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
134700: LD_VAR 0 4
134704: PUSH
134705: LD_VAR 0 7
134709: ARRAY
134710: PPUSH
134711: LD_VAR 0 14
134715: PUSH
134716: LD_INT 1
134718: ARRAY
134719: PPUSH
134720: CALL_OW 120
// attacking := true ;
134724: LD_ADDR_VAR 0 29
134728: PUSH
134729: LD_INT 1
134731: ST_TO_ADDR
// continue ;
134732: GO 132907
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
134734: LD_VAR 0 26
134738: PUSH
134739: LD_VAR 0 4
134743: PUSH
134744: LD_VAR 0 7
134748: ARRAY
134749: PPUSH
134750: CALL_OW 257
134754: PUSH
134755: LD_INT 1
134757: EQUAL
134758: AND
134759: PUSH
134760: LD_VAR 0 4
134764: PUSH
134765: LD_VAR 0 7
134769: ARRAY
134770: PPUSH
134771: CALL_OW 256
134775: PUSH
134776: LD_INT 800
134778: LESS
134779: AND
134780: PUSH
134781: LD_VAR 0 4
134785: PUSH
134786: LD_VAR 0 7
134790: ARRAY
134791: PPUSH
134792: CALL_OW 318
134796: NOT
134797: AND
134798: IFFALSE 134815
// ComCrawl ( group [ i ] ) ;
134800: LD_VAR 0 4
134804: PUSH
134805: LD_VAR 0 7
134809: ARRAY
134810: PPUSH
134811: CALL_OW 137
// if f_mines then
134815: LD_VAR 0 21
134819: IFFALSE 135062
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
134821: LD_VAR 0 14
134825: PUSH
134826: LD_INT 1
134828: ARRAY
134829: PPUSH
134830: CALL_OW 247
134834: PUSH
134835: LD_INT 3
134837: EQUAL
134838: PUSH
134839: LD_VAR 0 14
134843: PUSH
134844: LD_INT 1
134846: ARRAY
134847: PUSH
134848: LD_VAR 0 27
134852: IN
134853: NOT
134854: AND
134855: IFFALSE 135062
// begin x := GetX ( tmp [ 1 ] ) ;
134857: LD_ADDR_VAR 0 10
134861: PUSH
134862: LD_VAR 0 14
134866: PUSH
134867: LD_INT 1
134869: ARRAY
134870: PPUSH
134871: CALL_OW 250
134875: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
134876: LD_ADDR_VAR 0 11
134880: PUSH
134881: LD_VAR 0 14
134885: PUSH
134886: LD_INT 1
134888: ARRAY
134889: PPUSH
134890: CALL_OW 251
134894: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
134895: LD_ADDR_VAR 0 12
134899: PUSH
134900: LD_VAR 0 4
134904: PUSH
134905: LD_VAR 0 7
134909: ARRAY
134910: PPUSH
134911: CALL 102380 0 1
134915: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
134916: LD_VAR 0 4
134920: PUSH
134921: LD_VAR 0 7
134925: ARRAY
134926: PPUSH
134927: LD_VAR 0 10
134931: PPUSH
134932: LD_VAR 0 11
134936: PPUSH
134937: LD_VAR 0 14
134941: PUSH
134942: LD_INT 1
134944: ARRAY
134945: PPUSH
134946: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
134950: LD_VAR 0 4
134954: PUSH
134955: LD_VAR 0 7
134959: ARRAY
134960: PPUSH
134961: LD_VAR 0 10
134965: PPUSH
134966: LD_VAR 0 12
134970: PPUSH
134971: LD_INT 7
134973: PPUSH
134974: CALL_OW 272
134978: PPUSH
134979: LD_VAR 0 11
134983: PPUSH
134984: LD_VAR 0 12
134988: PPUSH
134989: LD_INT 7
134991: PPUSH
134992: CALL_OW 273
134996: PPUSH
134997: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135001: LD_VAR 0 4
135005: PUSH
135006: LD_VAR 0 7
135010: ARRAY
135011: PPUSH
135012: LD_INT 71
135014: PPUSH
135015: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135019: LD_ADDR_VAR 0 27
135023: PUSH
135024: LD_VAR 0 27
135028: PPUSH
135029: LD_VAR 0 27
135033: PUSH
135034: LD_INT 1
135036: PLUS
135037: PPUSH
135038: LD_VAR 0 14
135042: PUSH
135043: LD_INT 1
135045: ARRAY
135046: PPUSH
135047: CALL_OW 1
135051: ST_TO_ADDR
// attacking := true ;
135052: LD_ADDR_VAR 0 29
135056: PUSH
135057: LD_INT 1
135059: ST_TO_ADDR
// continue ;
135060: GO 132907
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135062: LD_VAR 0 4
135066: PUSH
135067: LD_VAR 0 7
135071: ARRAY
135072: PPUSH
135073: CALL_OW 257
135077: PUSH
135078: LD_INT 17
135080: EQUAL
135081: PUSH
135082: LD_VAR 0 4
135086: PUSH
135087: LD_VAR 0 7
135091: ARRAY
135092: PPUSH
135093: CALL_OW 110
135097: PUSH
135098: LD_INT 71
135100: EQUAL
135101: NOT
135102: AND
135103: IFFALSE 135249
// begin attacking := false ;
135105: LD_ADDR_VAR 0 29
135109: PUSH
135110: LD_INT 0
135112: ST_TO_ADDR
// k := 5 ;
135113: LD_ADDR_VAR 0 9
135117: PUSH
135118: LD_INT 5
135120: ST_TO_ADDR
// if tmp < k then
135121: LD_VAR 0 14
135125: PUSH
135126: LD_VAR 0 9
135130: LESS
135131: IFFALSE 135143
// k := tmp ;
135133: LD_ADDR_VAR 0 9
135137: PUSH
135138: LD_VAR 0 14
135142: ST_TO_ADDR
// for j = 1 to k do
135143: LD_ADDR_VAR 0 8
135147: PUSH
135148: DOUBLE
135149: LD_INT 1
135151: DEC
135152: ST_TO_ADDR
135153: LD_VAR 0 9
135157: PUSH
135158: FOR_TO
135159: IFFALSE 135247
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135161: LD_VAR 0 14
135165: PUSH
135166: LD_VAR 0 8
135170: ARRAY
135171: PUSH
135172: LD_VAR 0 14
135176: PPUSH
135177: LD_INT 58
135179: PUSH
135180: EMPTY
135181: LIST
135182: PPUSH
135183: CALL_OW 72
135187: IN
135188: NOT
135189: IFFALSE 135245
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135191: LD_VAR 0 4
135195: PUSH
135196: LD_VAR 0 7
135200: ARRAY
135201: PPUSH
135202: LD_VAR 0 14
135206: PUSH
135207: LD_VAR 0 8
135211: ARRAY
135212: PPUSH
135213: CALL_OW 115
// attacking := true ;
135217: LD_ADDR_VAR 0 29
135221: PUSH
135222: LD_INT 1
135224: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
135225: LD_VAR 0 4
135229: PUSH
135230: LD_VAR 0 7
135234: ARRAY
135235: PPUSH
135236: LD_INT 71
135238: PPUSH
135239: CALL_OW 109
// continue ;
135243: GO 135158
// end ; end ;
135245: GO 135158
135247: POP
135248: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
135249: LD_VAR 0 4
135253: PUSH
135254: LD_VAR 0 7
135258: ARRAY
135259: PPUSH
135260: CALL_OW 257
135264: PUSH
135265: LD_INT 8
135267: EQUAL
135268: PUSH
135269: LD_VAR 0 4
135273: PUSH
135274: LD_VAR 0 7
135278: ARRAY
135279: PPUSH
135280: CALL_OW 264
135284: PUSH
135285: LD_INT 28
135287: PUSH
135288: LD_INT 45
135290: PUSH
135291: LD_INT 7
135293: PUSH
135294: LD_INT 47
135296: PUSH
135297: EMPTY
135298: LIST
135299: LIST
135300: LIST
135301: LIST
135302: IN
135303: OR
135304: IFFALSE 135560
// begin attacking := false ;
135306: LD_ADDR_VAR 0 29
135310: PUSH
135311: LD_INT 0
135313: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
135314: LD_VAR 0 14
135318: PUSH
135319: LD_INT 1
135321: ARRAY
135322: PPUSH
135323: CALL_OW 266
135327: PUSH
135328: LD_INT 32
135330: PUSH
135331: LD_INT 31
135333: PUSH
135334: LD_INT 33
135336: PUSH
135337: LD_INT 4
135339: PUSH
135340: LD_INT 5
135342: PUSH
135343: EMPTY
135344: LIST
135345: LIST
135346: LIST
135347: LIST
135348: LIST
135349: IN
135350: IFFALSE 135536
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
135352: LD_ADDR_VAR 0 9
135356: PUSH
135357: LD_VAR 0 14
135361: PUSH
135362: LD_INT 1
135364: ARRAY
135365: PPUSH
135366: CALL_OW 266
135370: PPUSH
135371: LD_VAR 0 14
135375: PUSH
135376: LD_INT 1
135378: ARRAY
135379: PPUSH
135380: CALL_OW 250
135384: PPUSH
135385: LD_VAR 0 14
135389: PUSH
135390: LD_INT 1
135392: ARRAY
135393: PPUSH
135394: CALL_OW 251
135398: PPUSH
135399: LD_VAR 0 14
135403: PUSH
135404: LD_INT 1
135406: ARRAY
135407: PPUSH
135408: CALL_OW 254
135412: PPUSH
135413: LD_VAR 0 14
135417: PUSH
135418: LD_INT 1
135420: ARRAY
135421: PPUSH
135422: CALL_OW 248
135426: PPUSH
135427: LD_INT 0
135429: PPUSH
135430: CALL 83750 0 6
135434: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
135435: LD_ADDR_VAR 0 8
135439: PUSH
135440: LD_VAR 0 4
135444: PUSH
135445: LD_VAR 0 7
135449: ARRAY
135450: PPUSH
135451: LD_VAR 0 9
135455: PPUSH
135456: CALL 102493 0 2
135460: ST_TO_ADDR
// if j then
135461: LD_VAR 0 8
135465: IFFALSE 135534
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
135467: LD_VAR 0 8
135471: PUSH
135472: LD_INT 1
135474: ARRAY
135475: PPUSH
135476: LD_VAR 0 8
135480: PUSH
135481: LD_INT 2
135483: ARRAY
135484: PPUSH
135485: CALL_OW 488
135489: IFFALSE 135534
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
135491: LD_VAR 0 4
135495: PUSH
135496: LD_VAR 0 7
135500: ARRAY
135501: PPUSH
135502: LD_VAR 0 8
135506: PUSH
135507: LD_INT 1
135509: ARRAY
135510: PPUSH
135511: LD_VAR 0 8
135515: PUSH
135516: LD_INT 2
135518: ARRAY
135519: PPUSH
135520: CALL_OW 116
// attacking := true ;
135524: LD_ADDR_VAR 0 29
135528: PUSH
135529: LD_INT 1
135531: ST_TO_ADDR
// continue ;
135532: GO 132907
// end ; end else
135534: GO 135560
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
135536: LD_VAR 0 4
135540: PUSH
135541: LD_VAR 0 7
135545: ARRAY
135546: PPUSH
135547: LD_VAR 0 14
135551: PUSH
135552: LD_INT 1
135554: ARRAY
135555: PPUSH
135556: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
135560: LD_VAR 0 4
135564: PUSH
135565: LD_VAR 0 7
135569: ARRAY
135570: PPUSH
135571: CALL_OW 265
135575: PUSH
135576: LD_INT 11
135578: EQUAL
135579: IFFALSE 135857
// begin k := 10 ;
135581: LD_ADDR_VAR 0 9
135585: PUSH
135586: LD_INT 10
135588: ST_TO_ADDR
// x := 0 ;
135589: LD_ADDR_VAR 0 10
135593: PUSH
135594: LD_INT 0
135596: ST_TO_ADDR
// if tmp < k then
135597: LD_VAR 0 14
135601: PUSH
135602: LD_VAR 0 9
135606: LESS
135607: IFFALSE 135619
// k := tmp ;
135609: LD_ADDR_VAR 0 9
135613: PUSH
135614: LD_VAR 0 14
135618: ST_TO_ADDR
// for j = k downto 1 do
135619: LD_ADDR_VAR 0 8
135623: PUSH
135624: DOUBLE
135625: LD_VAR 0 9
135629: INC
135630: ST_TO_ADDR
135631: LD_INT 1
135633: PUSH
135634: FOR_DOWNTO
135635: IFFALSE 135710
// begin if GetType ( tmp [ j ] ) = unit_human then
135637: LD_VAR 0 14
135641: PUSH
135642: LD_VAR 0 8
135646: ARRAY
135647: PPUSH
135648: CALL_OW 247
135652: PUSH
135653: LD_INT 1
135655: EQUAL
135656: IFFALSE 135708
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
135658: LD_VAR 0 4
135662: PUSH
135663: LD_VAR 0 7
135667: ARRAY
135668: PPUSH
135669: LD_VAR 0 14
135673: PUSH
135674: LD_VAR 0 8
135678: ARRAY
135679: PPUSH
135680: CALL 102747 0 2
// x := tmp [ j ] ;
135684: LD_ADDR_VAR 0 10
135688: PUSH
135689: LD_VAR 0 14
135693: PUSH
135694: LD_VAR 0 8
135698: ARRAY
135699: ST_TO_ADDR
// attacking := true ;
135700: LD_ADDR_VAR 0 29
135704: PUSH
135705: LD_INT 1
135707: ST_TO_ADDR
// end ; end ;
135708: GO 135634
135710: POP
135711: POP
// if not x then
135712: LD_VAR 0 10
135716: NOT
135717: IFFALSE 135857
// begin attacking := true ;
135719: LD_ADDR_VAR 0 29
135723: PUSH
135724: LD_INT 1
135726: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
135727: LD_VAR 0 4
135731: PUSH
135732: LD_VAR 0 7
135736: ARRAY
135737: PPUSH
135738: CALL_OW 250
135742: PPUSH
135743: LD_VAR 0 4
135747: PUSH
135748: LD_VAR 0 7
135752: ARRAY
135753: PPUSH
135754: CALL_OW 251
135758: PPUSH
135759: CALL_OW 546
135763: PUSH
135764: LD_INT 2
135766: ARRAY
135767: PUSH
135768: LD_VAR 0 14
135772: PUSH
135773: LD_INT 1
135775: ARRAY
135776: PPUSH
135777: CALL_OW 250
135781: PPUSH
135782: LD_VAR 0 14
135786: PUSH
135787: LD_INT 1
135789: ARRAY
135790: PPUSH
135791: CALL_OW 251
135795: PPUSH
135796: CALL_OW 546
135800: PUSH
135801: LD_INT 2
135803: ARRAY
135804: EQUAL
135805: IFFALSE 135833
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
135807: LD_VAR 0 4
135811: PUSH
135812: LD_VAR 0 7
135816: ARRAY
135817: PPUSH
135818: LD_VAR 0 14
135822: PUSH
135823: LD_INT 1
135825: ARRAY
135826: PPUSH
135827: CALL 102747 0 2
135831: GO 135857
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
135833: LD_VAR 0 4
135837: PUSH
135838: LD_VAR 0 7
135842: ARRAY
135843: PPUSH
135844: LD_VAR 0 14
135848: PUSH
135849: LD_INT 1
135851: ARRAY
135852: PPUSH
135853: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
135857: LD_VAR 0 4
135861: PUSH
135862: LD_VAR 0 7
135866: ARRAY
135867: PPUSH
135868: CALL_OW 264
135872: PUSH
135873: LD_INT 29
135875: EQUAL
135876: IFFALSE 136242
// begin if WantsToAttack ( group [ i ] ) in bombed then
135878: LD_VAR 0 4
135882: PUSH
135883: LD_VAR 0 7
135887: ARRAY
135888: PPUSH
135889: CALL_OW 319
135893: PUSH
135894: LD_VAR 0 28
135898: IN
135899: IFFALSE 135903
// continue ;
135901: GO 132907
// k := 8 ;
135903: LD_ADDR_VAR 0 9
135907: PUSH
135908: LD_INT 8
135910: ST_TO_ADDR
// x := 0 ;
135911: LD_ADDR_VAR 0 10
135915: PUSH
135916: LD_INT 0
135918: ST_TO_ADDR
// if tmp < k then
135919: LD_VAR 0 14
135923: PUSH
135924: LD_VAR 0 9
135928: LESS
135929: IFFALSE 135941
// k := tmp ;
135931: LD_ADDR_VAR 0 9
135935: PUSH
135936: LD_VAR 0 14
135940: ST_TO_ADDR
// for j = 1 to k do
135941: LD_ADDR_VAR 0 8
135945: PUSH
135946: DOUBLE
135947: LD_INT 1
135949: DEC
135950: ST_TO_ADDR
135951: LD_VAR 0 9
135955: PUSH
135956: FOR_TO
135957: IFFALSE 136089
// begin if GetType ( tmp [ j ] ) = unit_building then
135959: LD_VAR 0 14
135963: PUSH
135964: LD_VAR 0 8
135968: ARRAY
135969: PPUSH
135970: CALL_OW 247
135974: PUSH
135975: LD_INT 3
135977: EQUAL
135978: IFFALSE 136087
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
135980: LD_VAR 0 14
135984: PUSH
135985: LD_VAR 0 8
135989: ARRAY
135990: PUSH
135991: LD_VAR 0 28
135995: IN
135996: NOT
135997: PUSH
135998: LD_VAR 0 14
136002: PUSH
136003: LD_VAR 0 8
136007: ARRAY
136008: PPUSH
136009: CALL_OW 313
136013: AND
136014: IFFALSE 136087
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136016: LD_VAR 0 4
136020: PUSH
136021: LD_VAR 0 7
136025: ARRAY
136026: PPUSH
136027: LD_VAR 0 14
136031: PUSH
136032: LD_VAR 0 8
136036: ARRAY
136037: PPUSH
136038: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136042: LD_ADDR_VAR 0 28
136046: PUSH
136047: LD_VAR 0 28
136051: PPUSH
136052: LD_VAR 0 28
136056: PUSH
136057: LD_INT 1
136059: PLUS
136060: PPUSH
136061: LD_VAR 0 14
136065: PUSH
136066: LD_VAR 0 8
136070: ARRAY
136071: PPUSH
136072: CALL_OW 1
136076: ST_TO_ADDR
// attacking := true ;
136077: LD_ADDR_VAR 0 29
136081: PUSH
136082: LD_INT 1
136084: ST_TO_ADDR
// break ;
136085: GO 136089
// end ; end ;
136087: GO 135956
136089: POP
136090: POP
// if not attacking and f_attack_depot then
136091: LD_VAR 0 29
136095: NOT
136096: PUSH
136097: LD_VAR 0 25
136101: AND
136102: IFFALSE 136197
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136104: LD_ADDR_VAR 0 13
136108: PUSH
136109: LD_VAR 0 14
136113: PPUSH
136114: LD_INT 2
136116: PUSH
136117: LD_INT 30
136119: PUSH
136120: LD_INT 0
136122: PUSH
136123: EMPTY
136124: LIST
136125: LIST
136126: PUSH
136127: LD_INT 30
136129: PUSH
136130: LD_INT 1
136132: PUSH
136133: EMPTY
136134: LIST
136135: LIST
136136: PUSH
136137: EMPTY
136138: LIST
136139: LIST
136140: LIST
136141: PPUSH
136142: CALL_OW 72
136146: ST_TO_ADDR
// if z then
136147: LD_VAR 0 13
136151: IFFALSE 136197
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136153: LD_VAR 0 4
136157: PUSH
136158: LD_VAR 0 7
136162: ARRAY
136163: PPUSH
136164: LD_VAR 0 13
136168: PPUSH
136169: LD_VAR 0 4
136173: PUSH
136174: LD_VAR 0 7
136178: ARRAY
136179: PPUSH
136180: CALL_OW 74
136184: PPUSH
136185: CALL_OW 115
// attacking := true ;
136189: LD_ADDR_VAR 0 29
136193: PUSH
136194: LD_INT 1
136196: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
136197: LD_VAR 0 4
136201: PUSH
136202: LD_VAR 0 7
136206: ARRAY
136207: PPUSH
136208: CALL_OW 256
136212: PUSH
136213: LD_INT 500
136215: LESS
136216: IFFALSE 136242
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136218: LD_VAR 0 4
136222: PUSH
136223: LD_VAR 0 7
136227: ARRAY
136228: PPUSH
136229: LD_VAR 0 14
136233: PUSH
136234: LD_INT 1
136236: ARRAY
136237: PPUSH
136238: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
136242: LD_VAR 0 4
136246: PUSH
136247: LD_VAR 0 7
136251: ARRAY
136252: PPUSH
136253: CALL_OW 264
136257: PUSH
136258: LD_INT 49
136260: EQUAL
136261: IFFALSE 136382
// begin if not HasTask ( group [ i ] ) then
136263: LD_VAR 0 4
136267: PUSH
136268: LD_VAR 0 7
136272: ARRAY
136273: PPUSH
136274: CALL_OW 314
136278: NOT
136279: IFFALSE 136382
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
136281: LD_ADDR_VAR 0 9
136285: PUSH
136286: LD_INT 81
136288: PUSH
136289: LD_VAR 0 4
136293: PUSH
136294: LD_VAR 0 7
136298: ARRAY
136299: PPUSH
136300: CALL_OW 255
136304: PUSH
136305: EMPTY
136306: LIST
136307: LIST
136308: PPUSH
136309: CALL_OW 69
136313: PPUSH
136314: LD_VAR 0 4
136318: PUSH
136319: LD_VAR 0 7
136323: ARRAY
136324: PPUSH
136325: CALL_OW 74
136329: ST_TO_ADDR
// if k then
136330: LD_VAR 0 9
136334: IFFALSE 136382
// if GetDistUnits ( group [ i ] , k ) > 10 then
136336: LD_VAR 0 4
136340: PUSH
136341: LD_VAR 0 7
136345: ARRAY
136346: PPUSH
136347: LD_VAR 0 9
136351: PPUSH
136352: CALL_OW 296
136356: PUSH
136357: LD_INT 10
136359: GREATER
136360: IFFALSE 136382
// ComMoveUnit ( group [ i ] , k ) ;
136362: LD_VAR 0 4
136366: PUSH
136367: LD_VAR 0 7
136371: ARRAY
136372: PPUSH
136373: LD_VAR 0 9
136377: PPUSH
136378: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
136382: LD_VAR 0 4
136386: PUSH
136387: LD_VAR 0 7
136391: ARRAY
136392: PPUSH
136393: CALL_OW 256
136397: PUSH
136398: LD_INT 250
136400: LESS
136401: PUSH
136402: LD_VAR 0 4
136406: PUSH
136407: LD_VAR 0 7
136411: ARRAY
136412: PUSH
136413: LD_INT 21
136415: PUSH
136416: LD_INT 2
136418: PUSH
136419: EMPTY
136420: LIST
136421: LIST
136422: PUSH
136423: LD_INT 23
136425: PUSH
136426: LD_INT 2
136428: PUSH
136429: EMPTY
136430: LIST
136431: LIST
136432: PUSH
136433: EMPTY
136434: LIST
136435: LIST
136436: PPUSH
136437: CALL_OW 69
136441: IN
136442: AND
136443: IFFALSE 136568
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
136445: LD_ADDR_VAR 0 9
136449: PUSH
136450: LD_OWVAR 3
136454: PUSH
136455: LD_VAR 0 4
136459: PUSH
136460: LD_VAR 0 7
136464: ARRAY
136465: DIFF
136466: PPUSH
136467: LD_VAR 0 4
136471: PUSH
136472: LD_VAR 0 7
136476: ARRAY
136477: PPUSH
136478: CALL_OW 74
136482: ST_TO_ADDR
// if not k then
136483: LD_VAR 0 9
136487: NOT
136488: IFFALSE 136492
// continue ;
136490: GO 132907
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
136492: LD_VAR 0 9
136496: PUSH
136497: LD_INT 81
136499: PUSH
136500: LD_VAR 0 4
136504: PUSH
136505: LD_VAR 0 7
136509: ARRAY
136510: PPUSH
136511: CALL_OW 255
136515: PUSH
136516: EMPTY
136517: LIST
136518: LIST
136519: PPUSH
136520: CALL_OW 69
136524: IN
136525: PUSH
136526: LD_VAR 0 9
136530: PPUSH
136531: LD_VAR 0 4
136535: PUSH
136536: LD_VAR 0 7
136540: ARRAY
136541: PPUSH
136542: CALL_OW 296
136546: PUSH
136547: LD_INT 5
136549: LESS
136550: AND
136551: IFFALSE 136568
// ComAutodestruct ( group [ i ] ) ;
136553: LD_VAR 0 4
136557: PUSH
136558: LD_VAR 0 7
136562: ARRAY
136563: PPUSH
136564: CALL 102645 0 1
// end ; if f_attack_depot then
136568: LD_VAR 0 25
136572: IFFALSE 136684
// begin k := 6 ;
136574: LD_ADDR_VAR 0 9
136578: PUSH
136579: LD_INT 6
136581: ST_TO_ADDR
// if tmp < k then
136582: LD_VAR 0 14
136586: PUSH
136587: LD_VAR 0 9
136591: LESS
136592: IFFALSE 136604
// k := tmp ;
136594: LD_ADDR_VAR 0 9
136598: PUSH
136599: LD_VAR 0 14
136603: ST_TO_ADDR
// for j = 1 to k do
136604: LD_ADDR_VAR 0 8
136608: PUSH
136609: DOUBLE
136610: LD_INT 1
136612: DEC
136613: ST_TO_ADDR
136614: LD_VAR 0 9
136618: PUSH
136619: FOR_TO
136620: IFFALSE 136682
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
136622: LD_VAR 0 8
136626: PPUSH
136627: CALL_OW 266
136631: PUSH
136632: LD_INT 0
136634: PUSH
136635: LD_INT 1
136637: PUSH
136638: EMPTY
136639: LIST
136640: LIST
136641: IN
136642: IFFALSE 136680
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136644: LD_VAR 0 4
136648: PUSH
136649: LD_VAR 0 7
136653: ARRAY
136654: PPUSH
136655: LD_VAR 0 14
136659: PUSH
136660: LD_VAR 0 8
136664: ARRAY
136665: PPUSH
136666: CALL_OW 115
// attacking := true ;
136670: LD_ADDR_VAR 0 29
136674: PUSH
136675: LD_INT 1
136677: ST_TO_ADDR
// break ;
136678: GO 136682
// end ;
136680: GO 136619
136682: POP
136683: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
136684: LD_VAR 0 4
136688: PUSH
136689: LD_VAR 0 7
136693: ARRAY
136694: PPUSH
136695: CALL_OW 302
136699: PUSH
136700: LD_VAR 0 29
136704: NOT
136705: AND
136706: IFFALSE 137028
// begin if GetTag ( group [ i ] ) = 71 then
136708: LD_VAR 0 4
136712: PUSH
136713: LD_VAR 0 7
136717: ARRAY
136718: PPUSH
136719: CALL_OW 110
136723: PUSH
136724: LD_INT 71
136726: EQUAL
136727: IFFALSE 136768
// begin if HasTask ( group [ i ] ) then
136729: LD_VAR 0 4
136733: PUSH
136734: LD_VAR 0 7
136738: ARRAY
136739: PPUSH
136740: CALL_OW 314
136744: IFFALSE 136750
// continue else
136746: GO 132907
136748: GO 136768
// SetTag ( group [ i ] , 0 ) ;
136750: LD_VAR 0 4
136754: PUSH
136755: LD_VAR 0 7
136759: ARRAY
136760: PPUSH
136761: LD_INT 0
136763: PPUSH
136764: CALL_OW 109
// end ; k := 8 ;
136768: LD_ADDR_VAR 0 9
136772: PUSH
136773: LD_INT 8
136775: ST_TO_ADDR
// x := 0 ;
136776: LD_ADDR_VAR 0 10
136780: PUSH
136781: LD_INT 0
136783: ST_TO_ADDR
// if tmp < k then
136784: LD_VAR 0 14
136788: PUSH
136789: LD_VAR 0 9
136793: LESS
136794: IFFALSE 136806
// k := tmp ;
136796: LD_ADDR_VAR 0 9
136800: PUSH
136801: LD_VAR 0 14
136805: ST_TO_ADDR
// for j = 1 to k do
136806: LD_ADDR_VAR 0 8
136810: PUSH
136811: DOUBLE
136812: LD_INT 1
136814: DEC
136815: ST_TO_ADDR
136816: LD_VAR 0 9
136820: PUSH
136821: FOR_TO
136822: IFFALSE 136920
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
136824: LD_VAR 0 14
136828: PUSH
136829: LD_VAR 0 8
136833: ARRAY
136834: PPUSH
136835: CALL_OW 247
136839: PUSH
136840: LD_INT 1
136842: EQUAL
136843: PUSH
136844: LD_VAR 0 14
136848: PUSH
136849: LD_VAR 0 8
136853: ARRAY
136854: PPUSH
136855: CALL_OW 256
136859: PUSH
136860: LD_INT 250
136862: LESS
136863: PUSH
136864: LD_VAR 0 20
136868: AND
136869: PUSH
136870: LD_VAR 0 20
136874: NOT
136875: PUSH
136876: LD_VAR 0 14
136880: PUSH
136881: LD_VAR 0 8
136885: ARRAY
136886: PPUSH
136887: CALL_OW 256
136891: PUSH
136892: LD_INT 250
136894: GREATEREQUAL
136895: AND
136896: OR
136897: AND
136898: IFFALSE 136918
// begin x := tmp [ j ] ;
136900: LD_ADDR_VAR 0 10
136904: PUSH
136905: LD_VAR 0 14
136909: PUSH
136910: LD_VAR 0 8
136914: ARRAY
136915: ST_TO_ADDR
// break ;
136916: GO 136920
// end ;
136918: GO 136821
136920: POP
136921: POP
// if x then
136922: LD_VAR 0 10
136926: IFFALSE 136950
// ComAttackUnit ( group [ i ] , x ) else
136928: LD_VAR 0 4
136932: PUSH
136933: LD_VAR 0 7
136937: ARRAY
136938: PPUSH
136939: LD_VAR 0 10
136943: PPUSH
136944: CALL_OW 115
136948: GO 136974
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136950: LD_VAR 0 4
136954: PUSH
136955: LD_VAR 0 7
136959: ARRAY
136960: PPUSH
136961: LD_VAR 0 14
136965: PUSH
136966: LD_INT 1
136968: ARRAY
136969: PPUSH
136970: CALL_OW 115
// if not HasTask ( group [ i ] ) then
136974: LD_VAR 0 4
136978: PUSH
136979: LD_VAR 0 7
136983: ARRAY
136984: PPUSH
136985: CALL_OW 314
136989: NOT
136990: IFFALSE 137028
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
136992: LD_VAR 0 4
136996: PUSH
136997: LD_VAR 0 7
137001: ARRAY
137002: PPUSH
137003: LD_VAR 0 14
137007: PPUSH
137008: LD_VAR 0 4
137012: PUSH
137013: LD_VAR 0 7
137017: ARRAY
137018: PPUSH
137019: CALL_OW 74
137023: PPUSH
137024: CALL_OW 115
// end ; end ; end ;
137028: GO 132907
137030: POP
137031: POP
// wait ( 0 0$2 ) ;
137032: LD_INT 70
137034: PPUSH
137035: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137039: LD_VAR 0 4
137043: NOT
137044: PUSH
137045: LD_VAR 0 4
137049: PUSH
137050: EMPTY
137051: EQUAL
137052: OR
137053: PUSH
137054: LD_INT 81
137056: PUSH
137057: LD_VAR 0 35
137061: PUSH
137062: EMPTY
137063: LIST
137064: LIST
137065: PPUSH
137066: CALL_OW 69
137070: NOT
137071: OR
137072: IFFALSE 132892
// end ;
137074: LD_VAR 0 2
137078: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137079: LD_INT 0
137081: PPUSH
137082: PPUSH
137083: PPUSH
137084: PPUSH
137085: PPUSH
137086: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137087: LD_VAR 0 1
137091: NOT
137092: PUSH
137093: LD_EXP 101
137097: PUSH
137098: LD_VAR 0 1
137102: ARRAY
137103: NOT
137104: OR
137105: PUSH
137106: LD_VAR 0 2
137110: NOT
137111: OR
137112: IFFALSE 137116
// exit ;
137114: GO 137670
// side := mc_sides [ base ] ;
137116: LD_ADDR_VAR 0 6
137120: PUSH
137121: LD_EXP 127
137125: PUSH
137126: LD_VAR 0 1
137130: ARRAY
137131: ST_TO_ADDR
// if not side then
137132: LD_VAR 0 6
137136: NOT
137137: IFFALSE 137141
// exit ;
137139: GO 137670
// for i in solds do
137141: LD_ADDR_VAR 0 7
137145: PUSH
137146: LD_VAR 0 2
137150: PUSH
137151: FOR_IN
137152: IFFALSE 137213
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137154: LD_VAR 0 7
137158: PPUSH
137159: CALL_OW 310
137163: PPUSH
137164: CALL_OW 266
137168: PUSH
137169: LD_INT 32
137171: PUSH
137172: LD_INT 31
137174: PUSH
137175: EMPTY
137176: LIST
137177: LIST
137178: IN
137179: IFFALSE 137199
// solds := solds diff i else
137181: LD_ADDR_VAR 0 2
137185: PUSH
137186: LD_VAR 0 2
137190: PUSH
137191: LD_VAR 0 7
137195: DIFF
137196: ST_TO_ADDR
137197: GO 137211
// SetTag ( i , 18 ) ;
137199: LD_VAR 0 7
137203: PPUSH
137204: LD_INT 18
137206: PPUSH
137207: CALL_OW 109
137211: GO 137151
137213: POP
137214: POP
// if not solds then
137215: LD_VAR 0 2
137219: NOT
137220: IFFALSE 137224
// exit ;
137222: GO 137670
// repeat wait ( 0 0$2 ) ;
137224: LD_INT 70
137226: PPUSH
137227: CALL_OW 67
// enemy := mc_scan [ base ] ;
137231: LD_ADDR_VAR 0 4
137235: PUSH
137236: LD_EXP 124
137240: PUSH
137241: LD_VAR 0 1
137245: ARRAY
137246: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137247: LD_EXP 101
137251: PUSH
137252: LD_VAR 0 1
137256: ARRAY
137257: NOT
137258: PUSH
137259: LD_EXP 101
137263: PUSH
137264: LD_VAR 0 1
137268: ARRAY
137269: PUSH
137270: EMPTY
137271: EQUAL
137272: OR
137273: IFFALSE 137310
// begin for i in solds do
137275: LD_ADDR_VAR 0 7
137279: PUSH
137280: LD_VAR 0 2
137284: PUSH
137285: FOR_IN
137286: IFFALSE 137299
// ComStop ( i ) ;
137288: LD_VAR 0 7
137292: PPUSH
137293: CALL_OW 141
137297: GO 137285
137299: POP
137300: POP
// solds := [ ] ;
137301: LD_ADDR_VAR 0 2
137305: PUSH
137306: EMPTY
137307: ST_TO_ADDR
// exit ;
137308: GO 137670
// end ; for i in solds do
137310: LD_ADDR_VAR 0 7
137314: PUSH
137315: LD_VAR 0 2
137319: PUSH
137320: FOR_IN
137321: IFFALSE 137642
// begin if IsInUnit ( i ) then
137323: LD_VAR 0 7
137327: PPUSH
137328: CALL_OW 310
137332: IFFALSE 137343
// ComExitBuilding ( i ) ;
137334: LD_VAR 0 7
137338: PPUSH
137339: CALL_OW 122
// if GetLives ( i ) > 500 then
137343: LD_VAR 0 7
137347: PPUSH
137348: CALL_OW 256
137352: PUSH
137353: LD_INT 500
137355: GREATER
137356: IFFALSE 137409
// begin e := NearestUnitToUnit ( enemy , i ) ;
137358: LD_ADDR_VAR 0 5
137362: PUSH
137363: LD_VAR 0 4
137367: PPUSH
137368: LD_VAR 0 7
137372: PPUSH
137373: CALL_OW 74
137377: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
137378: LD_VAR 0 7
137382: PPUSH
137383: LD_VAR 0 5
137387: PPUSH
137388: CALL_OW 250
137392: PPUSH
137393: LD_VAR 0 5
137397: PPUSH
137398: CALL_OW 251
137402: PPUSH
137403: CALL_OW 114
// end else
137407: GO 137640
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
137409: LD_VAR 0 7
137413: PPUSH
137414: LD_EXP 101
137418: PUSH
137419: LD_VAR 0 1
137423: ARRAY
137424: PPUSH
137425: LD_INT 2
137427: PUSH
137428: LD_INT 30
137430: PUSH
137431: LD_INT 0
137433: PUSH
137434: EMPTY
137435: LIST
137436: LIST
137437: PUSH
137438: LD_INT 30
137440: PUSH
137441: LD_INT 1
137443: PUSH
137444: EMPTY
137445: LIST
137446: LIST
137447: PUSH
137448: LD_INT 30
137450: PUSH
137451: LD_INT 6
137453: PUSH
137454: EMPTY
137455: LIST
137456: LIST
137457: PUSH
137458: EMPTY
137459: LIST
137460: LIST
137461: LIST
137462: LIST
137463: PPUSH
137464: CALL_OW 72
137468: PPUSH
137469: LD_VAR 0 7
137473: PPUSH
137474: CALL_OW 74
137478: PPUSH
137479: CALL_OW 296
137483: PUSH
137484: LD_INT 10
137486: GREATER
137487: IFFALSE 137640
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
137489: LD_ADDR_VAR 0 8
137493: PUSH
137494: LD_EXP 101
137498: PUSH
137499: LD_VAR 0 1
137503: ARRAY
137504: PPUSH
137505: LD_INT 2
137507: PUSH
137508: LD_INT 30
137510: PUSH
137511: LD_INT 0
137513: PUSH
137514: EMPTY
137515: LIST
137516: LIST
137517: PUSH
137518: LD_INT 30
137520: PUSH
137521: LD_INT 1
137523: PUSH
137524: EMPTY
137525: LIST
137526: LIST
137527: PUSH
137528: LD_INT 30
137530: PUSH
137531: LD_INT 6
137533: PUSH
137534: EMPTY
137535: LIST
137536: LIST
137537: PUSH
137538: EMPTY
137539: LIST
137540: LIST
137541: LIST
137542: LIST
137543: PPUSH
137544: CALL_OW 72
137548: PPUSH
137549: LD_VAR 0 7
137553: PPUSH
137554: CALL_OW 74
137558: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
137559: LD_VAR 0 7
137563: PPUSH
137564: LD_VAR 0 8
137568: PPUSH
137569: CALL_OW 250
137573: PPUSH
137574: LD_INT 3
137576: PPUSH
137577: LD_INT 5
137579: PPUSH
137580: CALL_OW 272
137584: PPUSH
137585: LD_VAR 0 8
137589: PPUSH
137590: CALL_OW 251
137594: PPUSH
137595: LD_INT 3
137597: PPUSH
137598: LD_INT 5
137600: PPUSH
137601: CALL_OW 273
137605: PPUSH
137606: CALL_OW 111
// SetTag ( i , 0 ) ;
137610: LD_VAR 0 7
137614: PPUSH
137615: LD_INT 0
137617: PPUSH
137618: CALL_OW 109
// solds := solds diff i ;
137622: LD_ADDR_VAR 0 2
137626: PUSH
137627: LD_VAR 0 2
137631: PUSH
137632: LD_VAR 0 7
137636: DIFF
137637: ST_TO_ADDR
// continue ;
137638: GO 137320
// end ; end ;
137640: GO 137320
137642: POP
137643: POP
// until not solds or not enemy ;
137644: LD_VAR 0 2
137648: NOT
137649: PUSH
137650: LD_VAR 0 4
137654: NOT
137655: OR
137656: IFFALSE 137224
// MC_Reset ( base , 18 ) ;
137658: LD_VAR 0 1
137662: PPUSH
137663: LD_INT 18
137665: PPUSH
137666: CALL 42903 0 2
// end ;
137670: LD_VAR 0 3
137674: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
137675: LD_INT 0
137677: PPUSH
137678: PPUSH
137679: PPUSH
137680: PPUSH
137681: PPUSH
137682: PPUSH
137683: PPUSH
137684: PPUSH
137685: PPUSH
137686: PPUSH
137687: PPUSH
137688: PPUSH
137689: PPUSH
137690: PPUSH
137691: PPUSH
137692: PPUSH
137693: PPUSH
137694: PPUSH
137695: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
137696: LD_ADDR_VAR 0 12
137700: PUSH
137701: LD_EXP 101
137705: PUSH
137706: LD_VAR 0 1
137710: ARRAY
137711: PPUSH
137712: LD_INT 25
137714: PUSH
137715: LD_INT 3
137717: PUSH
137718: EMPTY
137719: LIST
137720: LIST
137721: PPUSH
137722: CALL_OW 72
137726: ST_TO_ADDR
// if mc_remote_driver [ base ] then
137727: LD_EXP 141
137731: PUSH
137732: LD_VAR 0 1
137736: ARRAY
137737: IFFALSE 137761
// mechs := mechs diff mc_remote_driver [ base ] ;
137739: LD_ADDR_VAR 0 12
137743: PUSH
137744: LD_VAR 0 12
137748: PUSH
137749: LD_EXP 141
137753: PUSH
137754: LD_VAR 0 1
137758: ARRAY
137759: DIFF
137760: ST_TO_ADDR
// for i in mechs do
137761: LD_ADDR_VAR 0 4
137765: PUSH
137766: LD_VAR 0 12
137770: PUSH
137771: FOR_IN
137772: IFFALSE 137807
// if GetTag ( i ) > 0 then
137774: LD_VAR 0 4
137778: PPUSH
137779: CALL_OW 110
137783: PUSH
137784: LD_INT 0
137786: GREATER
137787: IFFALSE 137805
// mechs := mechs diff i ;
137789: LD_ADDR_VAR 0 12
137793: PUSH
137794: LD_VAR 0 12
137798: PUSH
137799: LD_VAR 0 4
137803: DIFF
137804: ST_TO_ADDR
137805: GO 137771
137807: POP
137808: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
137809: LD_ADDR_VAR 0 8
137813: PUSH
137814: LD_EXP 101
137818: PUSH
137819: LD_VAR 0 1
137823: ARRAY
137824: PPUSH
137825: LD_INT 2
137827: PUSH
137828: LD_INT 25
137830: PUSH
137831: LD_INT 1
137833: PUSH
137834: EMPTY
137835: LIST
137836: LIST
137837: PUSH
137838: LD_INT 25
137840: PUSH
137841: LD_INT 5
137843: PUSH
137844: EMPTY
137845: LIST
137846: LIST
137847: PUSH
137848: LD_INT 25
137850: PUSH
137851: LD_INT 8
137853: PUSH
137854: EMPTY
137855: LIST
137856: LIST
137857: PUSH
137858: LD_INT 25
137860: PUSH
137861: LD_INT 9
137863: PUSH
137864: EMPTY
137865: LIST
137866: LIST
137867: PUSH
137868: EMPTY
137869: LIST
137870: LIST
137871: LIST
137872: LIST
137873: LIST
137874: PPUSH
137875: CALL_OW 72
137879: ST_TO_ADDR
// if not defenders and not solds then
137880: LD_VAR 0 2
137884: NOT
137885: PUSH
137886: LD_VAR 0 8
137890: NOT
137891: AND
137892: IFFALSE 137896
// exit ;
137894: GO 139666
// depot_under_attack := false ;
137896: LD_ADDR_VAR 0 16
137900: PUSH
137901: LD_INT 0
137903: ST_TO_ADDR
// sold_defenders := [ ] ;
137904: LD_ADDR_VAR 0 17
137908: PUSH
137909: EMPTY
137910: ST_TO_ADDR
// if mechs then
137911: LD_VAR 0 12
137915: IFFALSE 138068
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
137917: LD_ADDR_VAR 0 4
137921: PUSH
137922: LD_VAR 0 2
137926: PPUSH
137927: LD_INT 21
137929: PUSH
137930: LD_INT 2
137932: PUSH
137933: EMPTY
137934: LIST
137935: LIST
137936: PPUSH
137937: CALL_OW 72
137941: PUSH
137942: FOR_IN
137943: IFFALSE 138066
// begin if GetTag ( i ) <> 20 then
137945: LD_VAR 0 4
137949: PPUSH
137950: CALL_OW 110
137954: PUSH
137955: LD_INT 20
137957: NONEQUAL
137958: IFFALSE 137972
// SetTag ( i , 20 ) ;
137960: LD_VAR 0 4
137964: PPUSH
137965: LD_INT 20
137967: PPUSH
137968: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
137972: LD_VAR 0 4
137976: PPUSH
137977: CALL_OW 263
137981: PUSH
137982: LD_INT 1
137984: EQUAL
137985: PUSH
137986: LD_VAR 0 4
137990: PPUSH
137991: CALL_OW 311
137995: NOT
137996: AND
137997: IFFALSE 138064
// begin un := mechs [ 1 ] ;
137999: LD_ADDR_VAR 0 10
138003: PUSH
138004: LD_VAR 0 12
138008: PUSH
138009: LD_INT 1
138011: ARRAY
138012: ST_TO_ADDR
// ComExit ( un ) ;
138013: LD_VAR 0 10
138017: PPUSH
138018: CALL 107542 0 1
// AddComEnterUnit ( un , i ) ;
138022: LD_VAR 0 10
138026: PPUSH
138027: LD_VAR 0 4
138031: PPUSH
138032: CALL_OW 180
// SetTag ( un , 19 ) ;
138036: LD_VAR 0 10
138040: PPUSH
138041: LD_INT 19
138043: PPUSH
138044: CALL_OW 109
// mechs := mechs diff un ;
138048: LD_ADDR_VAR 0 12
138052: PUSH
138053: LD_VAR 0 12
138057: PUSH
138058: LD_VAR 0 10
138062: DIFF
138063: ST_TO_ADDR
// end ; end ;
138064: GO 137942
138066: POP
138067: POP
// if solds then
138068: LD_VAR 0 8
138072: IFFALSE 138131
// for i in solds do
138074: LD_ADDR_VAR 0 4
138078: PUSH
138079: LD_VAR 0 8
138083: PUSH
138084: FOR_IN
138085: IFFALSE 138129
// if not GetTag ( i ) then
138087: LD_VAR 0 4
138091: PPUSH
138092: CALL_OW 110
138096: NOT
138097: IFFALSE 138127
// begin defenders := defenders union i ;
138099: LD_ADDR_VAR 0 2
138103: PUSH
138104: LD_VAR 0 2
138108: PUSH
138109: LD_VAR 0 4
138113: UNION
138114: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138115: LD_VAR 0 4
138119: PPUSH
138120: LD_INT 18
138122: PPUSH
138123: CALL_OW 109
// end ;
138127: GO 138084
138129: POP
138130: POP
// repeat wait ( 0 0$2 ) ;
138131: LD_INT 70
138133: PPUSH
138134: CALL_OW 67
// enemy := mc_scan [ base ] ;
138138: LD_ADDR_VAR 0 21
138142: PUSH
138143: LD_EXP 124
138147: PUSH
138148: LD_VAR 0 1
138152: ARRAY
138153: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138154: LD_EXP 101
138158: PUSH
138159: LD_VAR 0 1
138163: ARRAY
138164: NOT
138165: PUSH
138166: LD_EXP 101
138170: PUSH
138171: LD_VAR 0 1
138175: ARRAY
138176: PUSH
138177: EMPTY
138178: EQUAL
138179: OR
138180: IFFALSE 138217
// begin for i in defenders do
138182: LD_ADDR_VAR 0 4
138186: PUSH
138187: LD_VAR 0 2
138191: PUSH
138192: FOR_IN
138193: IFFALSE 138206
// ComStop ( i ) ;
138195: LD_VAR 0 4
138199: PPUSH
138200: CALL_OW 141
138204: GO 138192
138206: POP
138207: POP
// defenders := [ ] ;
138208: LD_ADDR_VAR 0 2
138212: PUSH
138213: EMPTY
138214: ST_TO_ADDR
// exit ;
138215: GO 139666
// end ; for i in defenders do
138217: LD_ADDR_VAR 0 4
138221: PUSH
138222: LD_VAR 0 2
138226: PUSH
138227: FOR_IN
138228: IFFALSE 139126
// begin e := NearestUnitToUnit ( enemy , i ) ;
138230: LD_ADDR_VAR 0 13
138234: PUSH
138235: LD_VAR 0 21
138239: PPUSH
138240: LD_VAR 0 4
138244: PPUSH
138245: CALL_OW 74
138249: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138250: LD_ADDR_VAR 0 7
138254: PUSH
138255: LD_EXP 101
138259: PUSH
138260: LD_VAR 0 1
138264: ARRAY
138265: PPUSH
138266: LD_INT 2
138268: PUSH
138269: LD_INT 30
138271: PUSH
138272: LD_INT 0
138274: PUSH
138275: EMPTY
138276: LIST
138277: LIST
138278: PUSH
138279: LD_INT 30
138281: PUSH
138282: LD_INT 1
138284: PUSH
138285: EMPTY
138286: LIST
138287: LIST
138288: PUSH
138289: EMPTY
138290: LIST
138291: LIST
138292: LIST
138293: PPUSH
138294: CALL_OW 72
138298: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
138299: LD_ADDR_VAR 0 16
138303: PUSH
138304: LD_VAR 0 7
138308: NOT
138309: PUSH
138310: LD_VAR 0 7
138314: PPUSH
138315: LD_INT 3
138317: PUSH
138318: LD_INT 24
138320: PUSH
138321: LD_INT 600
138323: PUSH
138324: EMPTY
138325: LIST
138326: LIST
138327: PUSH
138328: EMPTY
138329: LIST
138330: LIST
138331: PPUSH
138332: CALL_OW 72
138336: OR
138337: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
138338: LD_VAR 0 4
138342: PPUSH
138343: CALL_OW 247
138347: PUSH
138348: LD_INT 2
138350: DOUBLE
138351: EQUAL
138352: IFTRUE 138356
138354: GO 138752
138356: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
138357: LD_VAR 0 4
138361: PPUSH
138362: CALL_OW 256
138366: PUSH
138367: LD_INT 1000
138369: EQUAL
138370: PUSH
138371: LD_VAR 0 4
138375: PPUSH
138376: LD_VAR 0 13
138380: PPUSH
138381: CALL_OW 296
138385: PUSH
138386: LD_INT 40
138388: LESS
138389: PUSH
138390: LD_VAR 0 13
138394: PPUSH
138395: LD_EXP 126
138399: PUSH
138400: LD_VAR 0 1
138404: ARRAY
138405: PPUSH
138406: CALL_OW 308
138410: OR
138411: AND
138412: IFFALSE 138534
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
138414: LD_VAR 0 4
138418: PPUSH
138419: CALL_OW 262
138423: PUSH
138424: LD_INT 1
138426: EQUAL
138427: PUSH
138428: LD_VAR 0 4
138432: PPUSH
138433: CALL_OW 261
138437: PUSH
138438: LD_INT 30
138440: LESS
138441: AND
138442: PUSH
138443: LD_VAR 0 7
138447: AND
138448: IFFALSE 138518
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
138450: LD_VAR 0 4
138454: PPUSH
138455: LD_VAR 0 7
138459: PPUSH
138460: LD_VAR 0 4
138464: PPUSH
138465: CALL_OW 74
138469: PPUSH
138470: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
138474: LD_VAR 0 4
138478: PPUSH
138479: LD_VAR 0 7
138483: PPUSH
138484: LD_VAR 0 4
138488: PPUSH
138489: CALL_OW 74
138493: PPUSH
138494: CALL_OW 296
138498: PUSH
138499: LD_INT 6
138501: LESS
138502: IFFALSE 138516
// SetFuel ( i , 100 ) ;
138504: LD_VAR 0 4
138508: PPUSH
138509: LD_INT 100
138511: PPUSH
138512: CALL_OW 240
// end else
138516: GO 138532
// ComAttackUnit ( i , e ) ;
138518: LD_VAR 0 4
138522: PPUSH
138523: LD_VAR 0 13
138527: PPUSH
138528: CALL_OW 115
// end else
138532: GO 138635
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
138534: LD_VAR 0 13
138538: PPUSH
138539: LD_EXP 126
138543: PUSH
138544: LD_VAR 0 1
138548: ARRAY
138549: PPUSH
138550: CALL_OW 308
138554: NOT
138555: PUSH
138556: LD_VAR 0 4
138560: PPUSH
138561: LD_VAR 0 13
138565: PPUSH
138566: CALL_OW 296
138570: PUSH
138571: LD_INT 40
138573: GREATEREQUAL
138574: AND
138575: PUSH
138576: LD_VAR 0 4
138580: PPUSH
138581: CALL_OW 256
138585: PUSH
138586: LD_INT 650
138588: LESSEQUAL
138589: OR
138590: PUSH
138591: LD_VAR 0 4
138595: PPUSH
138596: LD_EXP 125
138600: PUSH
138601: LD_VAR 0 1
138605: ARRAY
138606: PPUSH
138607: CALL_OW 308
138611: NOT
138612: AND
138613: IFFALSE 138635
// ComMoveToArea ( i , mc_parking [ base ] ) ;
138615: LD_VAR 0 4
138619: PPUSH
138620: LD_EXP 125
138624: PUSH
138625: LD_VAR 0 1
138629: ARRAY
138630: PPUSH
138631: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
138635: LD_VAR 0 4
138639: PPUSH
138640: CALL_OW 256
138644: PUSH
138645: LD_INT 1000
138647: LESS
138648: PUSH
138649: LD_VAR 0 4
138653: PPUSH
138654: CALL_OW 263
138658: PUSH
138659: LD_INT 1
138661: EQUAL
138662: AND
138663: PUSH
138664: LD_VAR 0 4
138668: PPUSH
138669: CALL_OW 311
138673: AND
138674: PUSH
138675: LD_VAR 0 4
138679: PPUSH
138680: LD_EXP 125
138684: PUSH
138685: LD_VAR 0 1
138689: ARRAY
138690: PPUSH
138691: CALL_OW 308
138695: AND
138696: IFFALSE 138750
// begin mech := IsDrivenBy ( i ) ;
138698: LD_ADDR_VAR 0 9
138702: PUSH
138703: LD_VAR 0 4
138707: PPUSH
138708: CALL_OW 311
138712: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
138713: LD_VAR 0 9
138717: PPUSH
138718: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
138722: LD_VAR 0 9
138726: PPUSH
138727: LD_VAR 0 4
138731: PPUSH
138732: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
138736: LD_VAR 0 9
138740: PPUSH
138741: LD_VAR 0 4
138745: PPUSH
138746: CALL_OW 180
// end ; end ; unit_human :
138750: GO 139097
138752: LD_INT 1
138754: DOUBLE
138755: EQUAL
138756: IFTRUE 138760
138758: GO 139096
138760: POP
// begin b := IsInUnit ( i ) ;
138761: LD_ADDR_VAR 0 18
138765: PUSH
138766: LD_VAR 0 4
138770: PPUSH
138771: CALL_OW 310
138775: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
138776: LD_ADDR_VAR 0 19
138780: PUSH
138781: LD_VAR 0 18
138785: NOT
138786: PUSH
138787: LD_VAR 0 18
138791: PPUSH
138792: CALL_OW 266
138796: PUSH
138797: LD_INT 32
138799: PUSH
138800: LD_INT 31
138802: PUSH
138803: EMPTY
138804: LIST
138805: LIST
138806: IN
138807: OR
138808: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
138809: LD_VAR 0 18
138813: PPUSH
138814: CALL_OW 266
138818: PUSH
138819: LD_INT 5
138821: EQUAL
138822: PUSH
138823: LD_VAR 0 4
138827: PPUSH
138828: CALL_OW 257
138832: PUSH
138833: LD_INT 1
138835: PUSH
138836: LD_INT 2
138838: PUSH
138839: LD_INT 3
138841: PUSH
138842: LD_INT 4
138844: PUSH
138845: EMPTY
138846: LIST
138847: LIST
138848: LIST
138849: LIST
138850: IN
138851: AND
138852: IFFALSE 138889
// begin class := AllowSpecClass ( i ) ;
138854: LD_ADDR_VAR 0 20
138858: PUSH
138859: LD_VAR 0 4
138863: PPUSH
138864: CALL 71228 0 1
138868: ST_TO_ADDR
// if class then
138869: LD_VAR 0 20
138873: IFFALSE 138889
// ComChangeProfession ( i , class ) ;
138875: LD_VAR 0 4
138879: PPUSH
138880: LD_VAR 0 20
138884: PPUSH
138885: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
138889: LD_VAR 0 16
138893: PUSH
138894: LD_VAR 0 2
138898: PPUSH
138899: LD_INT 21
138901: PUSH
138902: LD_INT 2
138904: PUSH
138905: EMPTY
138906: LIST
138907: LIST
138908: PPUSH
138909: CALL_OW 72
138913: PUSH
138914: LD_INT 1
138916: LESSEQUAL
138917: OR
138918: PUSH
138919: LD_VAR 0 19
138923: AND
138924: PUSH
138925: LD_VAR 0 4
138929: PUSH
138930: LD_VAR 0 17
138934: IN
138935: NOT
138936: AND
138937: IFFALSE 139030
// begin if b then
138939: LD_VAR 0 18
138943: IFFALSE 138992
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
138945: LD_VAR 0 18
138949: PPUSH
138950: LD_VAR 0 21
138954: PPUSH
138955: LD_VAR 0 18
138959: PPUSH
138960: CALL_OW 74
138964: PPUSH
138965: CALL_OW 296
138969: PUSH
138970: LD_INT 10
138972: LESS
138973: PUSH
138974: LD_VAR 0 18
138978: PPUSH
138979: CALL_OW 461
138983: PUSH
138984: LD_INT 7
138986: NONEQUAL
138987: AND
138988: IFFALSE 138992
// continue ;
138990: GO 138227
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
138992: LD_ADDR_VAR 0 17
138996: PUSH
138997: LD_VAR 0 17
139001: PPUSH
139002: LD_VAR 0 17
139006: PUSH
139007: LD_INT 1
139009: PLUS
139010: PPUSH
139011: LD_VAR 0 4
139015: PPUSH
139016: CALL_OW 1
139020: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139021: LD_VAR 0 4
139025: PPUSH
139026: CALL_OW 122
// end ; if sold_defenders then
139030: LD_VAR 0 17
139034: IFFALSE 139094
// if i in sold_defenders then
139036: LD_VAR 0 4
139040: PUSH
139041: LD_VAR 0 17
139045: IN
139046: IFFALSE 139094
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139048: LD_VAR 0 4
139052: PPUSH
139053: CALL_OW 314
139057: NOT
139058: PUSH
139059: LD_VAR 0 4
139063: PPUSH
139064: LD_VAR 0 13
139068: PPUSH
139069: CALL_OW 296
139073: PUSH
139074: LD_INT 30
139076: LESS
139077: AND
139078: IFFALSE 139094
// ComAttackUnit ( i , e ) ;
139080: LD_VAR 0 4
139084: PPUSH
139085: LD_VAR 0 13
139089: PPUSH
139090: CALL_OW 115
// end ; end ; end ;
139094: GO 139097
139096: POP
// if IsDead ( i ) then
139097: LD_VAR 0 4
139101: PPUSH
139102: CALL_OW 301
139106: IFFALSE 139124
// defenders := defenders diff i ;
139108: LD_ADDR_VAR 0 2
139112: PUSH
139113: LD_VAR 0 2
139117: PUSH
139118: LD_VAR 0 4
139122: DIFF
139123: ST_TO_ADDR
// end ;
139124: GO 138227
139126: POP
139127: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139128: LD_VAR 0 21
139132: NOT
139133: PUSH
139134: LD_VAR 0 2
139138: NOT
139139: OR
139140: PUSH
139141: LD_EXP 101
139145: PUSH
139146: LD_VAR 0 1
139150: ARRAY
139151: NOT
139152: OR
139153: IFFALSE 138131
// MC_Reset ( base , 18 ) ;
139155: LD_VAR 0 1
139159: PPUSH
139160: LD_INT 18
139162: PPUSH
139163: CALL 42903 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139167: LD_ADDR_VAR 0 2
139171: PUSH
139172: LD_VAR 0 2
139176: PUSH
139177: LD_VAR 0 2
139181: PPUSH
139182: LD_INT 2
139184: PUSH
139185: LD_INT 25
139187: PUSH
139188: LD_INT 1
139190: PUSH
139191: EMPTY
139192: LIST
139193: LIST
139194: PUSH
139195: LD_INT 25
139197: PUSH
139198: LD_INT 5
139200: PUSH
139201: EMPTY
139202: LIST
139203: LIST
139204: PUSH
139205: LD_INT 25
139207: PUSH
139208: LD_INT 8
139210: PUSH
139211: EMPTY
139212: LIST
139213: LIST
139214: PUSH
139215: LD_INT 25
139217: PUSH
139218: LD_INT 9
139220: PUSH
139221: EMPTY
139222: LIST
139223: LIST
139224: PUSH
139225: EMPTY
139226: LIST
139227: LIST
139228: LIST
139229: LIST
139230: LIST
139231: PPUSH
139232: CALL_OW 72
139236: DIFF
139237: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
139238: LD_VAR 0 21
139242: NOT
139243: PUSH
139244: LD_VAR 0 2
139248: PPUSH
139249: LD_INT 21
139251: PUSH
139252: LD_INT 2
139254: PUSH
139255: EMPTY
139256: LIST
139257: LIST
139258: PPUSH
139259: CALL_OW 72
139263: AND
139264: IFFALSE 139602
// begin tmp := FilterByTag ( defenders , 19 ) ;
139266: LD_ADDR_VAR 0 11
139270: PUSH
139271: LD_VAR 0 2
139275: PPUSH
139276: LD_INT 19
139278: PPUSH
139279: CALL 104713 0 2
139283: ST_TO_ADDR
// if tmp then
139284: LD_VAR 0 11
139288: IFFALSE 139358
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
139290: LD_ADDR_VAR 0 11
139294: PUSH
139295: LD_VAR 0 11
139299: PPUSH
139300: LD_INT 25
139302: PUSH
139303: LD_INT 3
139305: PUSH
139306: EMPTY
139307: LIST
139308: LIST
139309: PPUSH
139310: CALL_OW 72
139314: ST_TO_ADDR
// if tmp then
139315: LD_VAR 0 11
139319: IFFALSE 139358
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
139321: LD_ADDR_EXP 113
139325: PUSH
139326: LD_EXP 113
139330: PPUSH
139331: LD_VAR 0 1
139335: PPUSH
139336: LD_EXP 113
139340: PUSH
139341: LD_VAR 0 1
139345: ARRAY
139346: PUSH
139347: LD_VAR 0 11
139351: UNION
139352: PPUSH
139353: CALL_OW 1
139357: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
139358: LD_VAR 0 1
139362: PPUSH
139363: LD_INT 19
139365: PPUSH
139366: CALL 42903 0 2
// repeat wait ( 0 0$1 ) ;
139370: LD_INT 35
139372: PPUSH
139373: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139377: LD_EXP 101
139381: PUSH
139382: LD_VAR 0 1
139386: ARRAY
139387: NOT
139388: PUSH
139389: LD_EXP 101
139393: PUSH
139394: LD_VAR 0 1
139398: ARRAY
139399: PUSH
139400: EMPTY
139401: EQUAL
139402: OR
139403: IFFALSE 139440
// begin for i in defenders do
139405: LD_ADDR_VAR 0 4
139409: PUSH
139410: LD_VAR 0 2
139414: PUSH
139415: FOR_IN
139416: IFFALSE 139429
// ComStop ( i ) ;
139418: LD_VAR 0 4
139422: PPUSH
139423: CALL_OW 141
139427: GO 139415
139429: POP
139430: POP
// defenders := [ ] ;
139431: LD_ADDR_VAR 0 2
139435: PUSH
139436: EMPTY
139437: ST_TO_ADDR
// exit ;
139438: GO 139666
// end ; for i in defenders do
139440: LD_ADDR_VAR 0 4
139444: PUSH
139445: LD_VAR 0 2
139449: PUSH
139450: FOR_IN
139451: IFFALSE 139540
// begin if not IsInArea ( i , mc_parking [ base ] ) then
139453: LD_VAR 0 4
139457: PPUSH
139458: LD_EXP 125
139462: PUSH
139463: LD_VAR 0 1
139467: ARRAY
139468: PPUSH
139469: CALL_OW 308
139473: NOT
139474: IFFALSE 139498
// ComMoveToArea ( i , mc_parking [ base ] ) else
139476: LD_VAR 0 4
139480: PPUSH
139481: LD_EXP 125
139485: PUSH
139486: LD_VAR 0 1
139490: ARRAY
139491: PPUSH
139492: CALL_OW 113
139496: GO 139538
// if GetControl ( i ) = control_manual then
139498: LD_VAR 0 4
139502: PPUSH
139503: CALL_OW 263
139507: PUSH
139508: LD_INT 1
139510: EQUAL
139511: IFFALSE 139538
// if IsDrivenBy ( i ) then
139513: LD_VAR 0 4
139517: PPUSH
139518: CALL_OW 311
139522: IFFALSE 139538
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
139524: LD_VAR 0 4
139528: PPUSH
139529: CALL_OW 311
139533: PPUSH
139534: CALL_OW 121
// end ;
139538: GO 139450
139540: POP
139541: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
139542: LD_VAR 0 2
139546: PPUSH
139547: LD_INT 95
139549: PUSH
139550: LD_EXP 125
139554: PUSH
139555: LD_VAR 0 1
139559: ARRAY
139560: PUSH
139561: EMPTY
139562: LIST
139563: LIST
139564: PPUSH
139565: CALL_OW 72
139569: PUSH
139570: LD_VAR 0 2
139574: EQUAL
139575: PUSH
139576: LD_EXP 124
139580: PUSH
139581: LD_VAR 0 1
139585: ARRAY
139586: OR
139587: PUSH
139588: LD_EXP 101
139592: PUSH
139593: LD_VAR 0 1
139597: ARRAY
139598: NOT
139599: OR
139600: IFFALSE 139370
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
139602: LD_ADDR_EXP 123
139606: PUSH
139607: LD_EXP 123
139611: PPUSH
139612: LD_VAR 0 1
139616: PPUSH
139617: LD_VAR 0 2
139621: PPUSH
139622: LD_INT 21
139624: PUSH
139625: LD_INT 2
139627: PUSH
139628: EMPTY
139629: LIST
139630: LIST
139631: PPUSH
139632: CALL_OW 72
139636: PPUSH
139637: CALL_OW 1
139641: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
139642: LD_VAR 0 1
139646: PPUSH
139647: LD_INT 19
139649: PPUSH
139650: CALL 42903 0 2
// MC_Reset ( base , 20 ) ;
139654: LD_VAR 0 1
139658: PPUSH
139659: LD_INT 20
139661: PPUSH
139662: CALL 42903 0 2
// end ; end_of_file
139666: LD_VAR 0 3
139670: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
139671: LD_VAR 0 1
139675: PUSH
139676: LD_INT 200
139678: DOUBLE
139679: GREATEREQUAL
139680: IFFALSE 139688
139682: LD_INT 299
139684: DOUBLE
139685: LESSEQUAL
139686: IFTRUE 139690
139688: GO 139722
139690: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
139691: LD_VAR 0 1
139695: PPUSH
139696: LD_VAR 0 2
139700: PPUSH
139701: LD_VAR 0 3
139705: PPUSH
139706: LD_VAR 0 4
139710: PPUSH
139711: LD_VAR 0 5
139715: PPUSH
139716: CALL 127852 0 5
139720: GO 139799
139722: LD_INT 300
139724: DOUBLE
139725: GREATEREQUAL
139726: IFFALSE 139734
139728: LD_INT 399
139730: DOUBLE
139731: LESSEQUAL
139732: IFTRUE 139736
139734: GO 139798
139736: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
139737: LD_VAR 0 1
139741: PPUSH
139742: LD_VAR 0 2
139746: PPUSH
139747: LD_VAR 0 3
139751: PPUSH
139752: LD_VAR 0 4
139756: PPUSH
139757: LD_VAR 0 5
139761: PPUSH
139762: LD_VAR 0 6
139766: PPUSH
139767: LD_VAR 0 7
139771: PPUSH
139772: LD_VAR 0 8
139776: PPUSH
139777: LD_VAR 0 9
139781: PPUSH
139782: LD_VAR 0 10
139786: PPUSH
139787: LD_VAR 0 11
139791: PPUSH
139792: CALL 124177 0 11
139796: GO 139799
139798: POP
// end ;
139799: PPOPN 11
139801: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
139802: LD_VAR 0 1
139806: PPUSH
139807: LD_VAR 0 2
139811: PPUSH
139812: LD_VAR 0 3
139816: PPUSH
139817: LD_VAR 0 4
139821: PPUSH
139822: LD_VAR 0 5
139826: PPUSH
139827: CALL 127588 0 5
// end ; end_of_file
139831: PPOPN 5
139833: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
139834: LD_VAR 0 1
139838: PPUSH
139839: LD_VAR 0 2
139843: PPUSH
139844: LD_VAR 0 3
139848: PPUSH
139849: LD_VAR 0 4
139853: PPUSH
139854: LD_VAR 0 5
139858: PPUSH
139859: LD_VAR 0 6
139863: PPUSH
139864: CALL 111829 0 6
// end ;
139868: PPOPN 6
139870: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
139871: LD_INT 0
139873: PPUSH
// begin if not units then
139874: LD_VAR 0 1
139878: NOT
139879: IFFALSE 139883
// exit ;
139881: GO 139883
// end ;
139883: PPOPN 7
139885: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
139886: CALL 111733 0 0
// end ;
139890: PPOPN 1
139892: END
