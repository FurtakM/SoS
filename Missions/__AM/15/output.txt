// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35067 0 0
// InitMacro ;
  19: CALL 35235 0 0
// InitNature ;
  23: CALL 34935 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11161 0 0
// PrepareRussian ;
  44: CALL 7017 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15063 0 0
// MC_Start ( ) ;
  64: CALL 37400 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60002 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60095 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59445 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59260 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60002 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60095 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59260 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59445 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59875 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 58942 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60002 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60095 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 145
 963: PUSH
 964: LD_EXP 145
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59260 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60002 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60095 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59152 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60413 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59584 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 59875 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 59875 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60207 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59260 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 59826 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65714 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70578 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70578 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70578 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70578 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70578 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65714 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65714 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65714 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65714 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65714 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65714 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65714 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65714 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65714 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65714 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65714 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65714 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65714 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65714 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65714 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65714 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65714 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65714 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65714 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65714 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65714 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65714 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65714 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65714 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65714 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65714 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65714 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65714 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70578 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65714 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65714 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65714 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74024 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 116
4751: PUSH
4752: LD_EXP 116
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70578 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59445 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59308 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60726 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59308 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59308 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60726 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60726 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 135
6051: PUSH
6052: LD_EXP 135
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 135
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7014
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70578 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// for i in tmp do
6858: LD_ADDR_VAR 0 1
6862: PUSH
6863: LD_VAR 0 3
6867: PUSH
6868: FOR_IN
6869: IFFALSE 7005
// begin if GetLives ( i ) > 250 then
6871: LD_VAR 0 1
6875: PPUSH
6876: CALL_OW 256
6880: PUSH
6881: LD_INT 250
6883: GREATER
6884: IFFALSE 6976
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6886: LD_INT 81
6888: PUSH
6889: LD_INT 8
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 91
6898: PUSH
6899: LD_VAR 0 1
6903: PUSH
6904: LD_INT 10
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: NOT
6921: IFFALSE 6940
// ComAgressiveMove ( i , 67 , 110 ) else
6923: LD_VAR 0 1
6927: PPUSH
6928: LD_INT 67
6930: PPUSH
6931: LD_INT 110
6933: PPUSH
6934: CALL_OW 114
6938: GO 6974
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6940: LD_VAR 0 1
6944: PPUSH
6945: LD_INT 81
6947: PUSH
6948: LD_INT 8
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 69
6959: PPUSH
6960: LD_VAR 0 1
6964: PPUSH
6965: CALL_OW 74
6969: PPUSH
6970: CALL_OW 115
// end else
6974: GO 7003
// if IsDead ( i ) then
6976: LD_VAR 0 1
6980: PPUSH
6981: CALL_OW 301
6985: IFFALSE 7003
// tmp := tmp diff i ;
6987: LD_ADDR_VAR 0 3
6991: PUSH
6992: LD_VAR 0 3
6996: PUSH
6997: LD_VAR 0 1
7001: DIFF
7002: ST_TO_ADDR
// end ;
7003: GO 6868
7005: POP
7006: POP
// until not tmp ;
7007: LD_VAR 0 3
7011: NOT
7012: IFFALSE 6851
// end ; end_of_file
7014: PPOPN 3
7016: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7017: LD_INT 0
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
// side := 3 ;
7028: LD_ADDR_VAR 0 6
7032: PUSH
7033: LD_INT 3
7035: ST_TO_ADDR
// uc_side := side ;
7036: LD_ADDR_OWVAR 20
7040: PUSH
7041: LD_VAR 0 6
7045: ST_TO_ADDR
// uc_nation := 3 ;
7046: LD_ADDR_OWVAR 21
7050: PUSH
7051: LD_INT 3
7053: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7054: LD_ADDR_VAR 0 2
7058: PUSH
7059: LD_INT 22
7061: PUSH
7062: LD_VAR 0 6
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 21
7073: PUSH
7074: LD_INT 3
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PPUSH
7085: CALL_OW 69
7089: PUSH
7090: FOR_IN
7091: IFFALSE 7107
// SetBLevel ( i , 10 ) ;
7093: LD_VAR 0 2
7097: PPUSH
7098: LD_INT 10
7100: PPUSH
7101: CALL_OW 241
7105: GO 7090
7107: POP
7108: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7109: LD_ADDR_VAR 0 9
7113: PUSH
7114: LD_INT 22
7116: PUSH
7117: LD_VAR 0 6
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PUSH
7126: LD_INT 30
7128: PUSH
7129: LD_INT 34
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PPUSH
7140: CALL_OW 69
7144: ST_TO_ADDR
// if teleport then
7145: LD_VAR 0 9
7149: IFFALSE 7170
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7151: LD_VAR 0 9
7155: PUSH
7156: LD_INT 1
7158: ARRAY
7159: PPUSH
7160: LD_INT 123
7162: PPUSH
7163: LD_INT 122
7165: PPUSH
7166: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7170: LD_ADDR_EXP 64
7174: PUSH
7175: LD_STRING Platonov
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7183: LD_ADDR_EXP 65
7187: PUSH
7188: LD_STRING Kovalyuk
7190: PPUSH
7191: CALL_OW 25
7195: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7196: LD_ADDR_EXP 67
7200: PUSH
7201: LD_STRING Yakotich
7203: PPUSH
7204: LD_EXP 1
7208: NOT
7209: PPUSH
7210: LD_STRING 09_
7212: PPUSH
7213: CALL 65714 0 3
7217: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7218: LD_ADDR_EXP 66
7222: PUSH
7223: LD_STRING Bystrov
7225: PPUSH
7226: CALL_OW 25
7230: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7231: LD_ADDR_EXP 68
7235: PUSH
7236: LD_STRING Gleb
7238: PPUSH
7239: CALL_OW 25
7243: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7244: LD_STRING 03_Cornel
7246: PPUSH
7247: CALL_OW 28
7251: IFFALSE 7299
// begin Bierezov := NewCharacter ( Mikhail ) ;
7253: LD_ADDR_EXP 69
7257: PUSH
7258: LD_STRING Mikhail
7260: PPUSH
7261: CALL_OW 25
7265: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7266: LD_EXP 69
7270: PPUSH
7271: LD_INT 197
7273: PPUSH
7274: LD_INT 111
7276: PPUSH
7277: LD_INT 9
7279: PPUSH
7280: LD_INT 0
7282: PPUSH
7283: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7287: LD_EXP 69
7291: PPUSH
7292: LD_INT 3
7294: PPUSH
7295: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7299: LD_EXP 64
7303: PPUSH
7304: LD_INT 126
7306: PPUSH
7307: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7311: LD_EXP 65
7315: PPUSH
7316: LD_INT 134
7318: PPUSH
7319: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7323: LD_EXP 67
7327: PPUSH
7328: LD_INT 197
7330: PPUSH
7331: LD_INT 111
7333: PPUSH
7334: LD_INT 9
7336: PPUSH
7337: LD_INT 0
7339: PPUSH
7340: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7344: LD_EXP 66
7348: PPUSH
7349: LD_INT 197
7351: PPUSH
7352: LD_INT 111
7354: PPUSH
7355: LD_INT 9
7357: PPUSH
7358: LD_INT 0
7360: PPUSH
7361: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7365: LD_EXP 68
7369: PPUSH
7370: LD_INT 197
7372: PPUSH
7373: LD_INT 111
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: LD_INT 0
7381: PPUSH
7382: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7386: LD_ADDR_VAR 0 5
7390: PUSH
7391: LD_INT 126
7393: PPUSH
7394: LD_INT 4
7396: PPUSH
7397: LD_STRING zhukov
7399: PPUSH
7400: LD_INT 9
7402: PUSH
7403: LD_INT 10
7405: PUSH
7406: LD_INT 10
7408: PUSH
7409: LD_INT 10
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: PUSH
7418: LD_OWVAR 67
7422: ARRAY
7423: PPUSH
7424: LD_INT 90000
7426: PUSH
7427: LD_INT 1000
7429: PUSH
7430: LD_INT 300
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PPUSH
7438: LD_INT 18
7440: PUSH
7441: LD_INT 8
7443: PUSH
7444: LD_INT 13
7446: PUSH
7447: LD_INT 8
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: LIST
7454: LIST
7455: PPUSH
7456: CALL 74024 0 6
7460: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7461: LD_ADDR_VAR 0 4
7465: PUSH
7466: LD_INT 267
7468: PPUSH
7469: CALL_OW 274
7473: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7474: LD_VAR 0 4
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: LD_INT 5000
7484: PPUSH
7485: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7489: LD_VAR 0 4
7493: PPUSH
7494: LD_INT 2
7496: PPUSH
7497: LD_INT 200
7499: PPUSH
7500: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7504: LD_VAR 0 4
7508: PPUSH
7509: LD_INT 3
7511: PPUSH
7512: LD_INT 200
7514: PPUSH
7515: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7519: LD_ADDR_EXP 116
7523: PUSH
7524: LD_EXP 116
7528: PPUSH
7529: LD_INT 2
7531: PPUSH
7532: LD_VAR 0 5
7536: PUSH
7537: LD_INT 22
7539: PUSH
7540: LD_VAR 0 6
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 3
7551: PUSH
7552: LD_INT 21
7554: PUSH
7555: LD_INT 2
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 69
7574: UNION
7575: PUSH
7576: LD_EXP 64
7580: DIFF
7581: PPUSH
7582: CALL_OW 1
7586: ST_TO_ADDR
// behemoths := [ ] ;
7587: LD_ADDR_EXP 72
7591: PUSH
7592: EMPTY
7593: ST_TO_ADDR
// behemothBuilders := [ ] ;
7594: LD_ADDR_EXP 73
7598: PUSH
7599: EMPTY
7600: ST_TO_ADDR
// if Kovalyuk then
7601: LD_EXP 65
7605: IFFALSE 7627
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7607: LD_ADDR_EXP 73
7611: PUSH
7612: LD_EXP 73
7616: PPUSH
7617: LD_EXP 65
7621: PPUSH
7622: CALL 102451 0 2
7626: ST_TO_ADDR
// j := 3 ;
7627: LD_ADDR_VAR 0 3
7631: PUSH
7632: LD_INT 3
7634: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7635: LD_ADDR_VAR 0 2
7639: PUSH
7640: LD_INT 22
7642: PUSH
7643: LD_INT 3
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 25
7652: PUSH
7653: LD_INT 3
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PPUSH
7664: CALL_OW 69
7668: PUSH
7669: LD_EXP 65
7673: DIFF
7674: PUSH
7675: FOR_IN
7676: IFFALSE 7726
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7678: LD_ADDR_EXP 73
7682: PUSH
7683: LD_EXP 73
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL 102451 0 2
7697: ST_TO_ADDR
// j := j - 1 ;
7698: LD_ADDR_VAR 0 3
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: LD_INT 1
7710: MINUS
7711: ST_TO_ADDR
// if j = 0 then
7712: LD_VAR 0 3
7716: PUSH
7717: LD_INT 0
7719: EQUAL
7720: IFFALSE 7724
// break ;
7722: GO 7726
// end ;
7724: GO 7675
7726: POP
7727: POP
// end ;
7728: LD_VAR 0 1
7732: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7733: LD_INT 0
7735: PPUSH
7736: PPUSH
7737: PPUSH
7738: PPUSH
7739: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7740: LD_ADDR_VAR 0 4
7744: PUSH
7745: LD_INT 209
7747: PUSH
7748: LD_INT 149
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PUSH
7755: LD_INT 219
7757: PUSH
7758: LD_INT 154
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 223
7767: PUSH
7768: LD_INT 149
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 232
7777: PUSH
7778: LD_INT 155
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: LIST
7789: LIST
7790: ST_TO_ADDR
// if not behemothBuilders then
7791: LD_EXP 73
7795: NOT
7796: IFFALSE 7800
// exit ;
7798: GO 7904
// j := 1 ;
7800: LD_ADDR_VAR 0 3
7804: PUSH
7805: LD_INT 1
7807: ST_TO_ADDR
// for i in behemothBuilders do
7808: LD_ADDR_VAR 0 2
7812: PUSH
7813: LD_EXP 73
7817: PUSH
7818: FOR_IN
7819: IFFALSE 7902
// begin if IsInUnit ( i ) then
7821: LD_VAR 0 2
7825: PPUSH
7826: CALL_OW 310
7830: IFFALSE 7841
// ComExitBuilding ( i ) ;
7832: LD_VAR 0 2
7836: PPUSH
7837: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7841: LD_VAR 0 2
7845: PPUSH
7846: LD_INT 37
7848: PPUSH
7849: LD_VAR 0 4
7853: PUSH
7854: LD_VAR 0 3
7858: ARRAY
7859: PUSH
7860: LD_INT 1
7862: ARRAY
7863: PPUSH
7864: LD_VAR 0 4
7868: PUSH
7869: LD_VAR 0 3
7873: ARRAY
7874: PUSH
7875: LD_INT 2
7877: ARRAY
7878: PPUSH
7879: LD_INT 0
7881: PPUSH
7882: CALL_OW 230
// j := j + 1 ;
7886: LD_ADDR_VAR 0 3
7890: PUSH
7891: LD_VAR 0 3
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// end ;
7900: GO 7818
7902: POP
7903: POP
// end ;
7904: LD_VAR 0 1
7908: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7909: LD_INT 24
7911: PPUSH
7912: LD_INT 30
7914: PUSH
7915: LD_INT 37
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PPUSH
7922: CALL_OW 70
7926: IFFALSE 7939
7928: GO 7930
7930: DISABLE
// behemothUnderConstruct := true ;
7931: LD_ADDR_EXP 26
7935: PUSH
7936: LD_INT 1
7938: ST_TO_ADDR
7939: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7940: LD_INT 3
7942: PPUSH
7943: CALL 102512 0 1
7947: PUSH
7948: LD_INT 22
7950: PUSH
7951: LD_INT 3
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: PUSH
7958: LD_INT 30
7960: PUSH
7961: LD_INT 37
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: PUSH
7968: EMPTY
7969: LIST
7970: LIST
7971: PPUSH
7972: CALL_OW 69
7976: NOT
7977: AND
7978: IFFALSE 8164
7980: GO 7982
7982: DISABLE
7983: LD_INT 0
7985: PPUSH
7986: PPUSH
// begin enable ;
7987: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7988: LD_ADDR_VAR 0 2
7992: PUSH
7993: LD_INT 3
7995: PPUSH
7996: CALL 102512 0 1
8000: ST_TO_ADDR
// for i in tmp do
8001: LD_ADDR_VAR 0 1
8005: PUSH
8006: LD_VAR 0 2
8010: PUSH
8011: FOR_IN
8012: IFFALSE 8162
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8014: LD_VAR 0 1
8018: PPUSH
8019: LD_INT 9
8021: PPUSH
8022: CALL_OW 308
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8056
// SetTag ( i , 2 ) ;
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 2
8051: PPUSH
8052: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8056: LD_INT 81
8058: PUSH
8059: LD_INT 3
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PUSH
8066: LD_INT 91
8068: PUSH
8069: LD_VAR 0 1
8073: PUSH
8074: LD_INT 12
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PPUSH
8086: CALL_OW 69
8090: NOT
8091: PUSH
8092: LD_VAR 0 1
8096: PPUSH
8097: CALL_OW 110
8101: PUSH
8102: LD_INT 2
8104: EQUAL
8105: NOT
8106: AND
8107: IFFALSE 8126
// ComAgressiveMove ( i , 64 , 93 ) else
8109: LD_VAR 0 1
8113: PPUSH
8114: LD_INT 64
8116: PPUSH
8117: LD_INT 93
8119: PPUSH
8120: CALL_OW 114
8124: GO 8160
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_INT 81
8133: PUSH
8134: LD_INT 3
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PPUSH
8141: CALL_OW 69
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL_OW 74
8155: PPUSH
8156: CALL_OW 115
// end ;
8160: GO 8011
8162: POP
8163: POP
// end ;
8164: PPOPN 2
8166: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8167: LD_INT 0
8169: PPUSH
8170: PPUSH
8171: PPUSH
// result := [ ] ;
8172: LD_ADDR_VAR 0 2
8176: PUSH
8177: EMPTY
8178: ST_TO_ADDR
// uc_side := 6 ;
8179: LD_ADDR_OWVAR 20
8183: PUSH
8184: LD_INT 6
8186: ST_TO_ADDR
// uc_nation := 3 ;
8187: LD_ADDR_OWVAR 21
8191: PUSH
8192: LD_INT 3
8194: ST_TO_ADDR
// case strength of 1 :
8195: LD_VAR 0 1
8199: PUSH
8200: LD_INT 1
8202: DOUBLE
8203: EQUAL
8204: IFTRUE 8208
8206: GO 8350
8208: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8209: LD_ADDR_VAR 0 3
8213: PUSH
8214: DOUBLE
8215: LD_INT 1
8217: DEC
8218: ST_TO_ADDR
8219: LD_INT 4
8221: PUSH
8222: LD_INT 5
8224: PUSH
8225: LD_INT 6
8227: PUSH
8228: LD_INT 7
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: PUSH
8237: LD_OWVAR 67
8241: ARRAY
8242: PUSH
8243: FOR_TO
8244: IFFALSE 8346
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8246: LD_INT 22
8248: PUSH
8249: LD_INT 24
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PUSH
8256: LD_VAR 0 3
8260: PUSH
8261: LD_INT 2
8263: MOD
8264: PUSH
8265: LD_INT 1
8267: PLUS
8268: ARRAY
8269: PPUSH
8270: LD_INT 1
8272: PUSH
8273: LD_INT 3
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: LD_INT 1
8282: PPUSH
8283: LD_INT 2
8285: PPUSH
8286: CALL_OW 12
8290: ARRAY
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 43
8297: PUSH
8298: LD_INT 44
8300: PUSH
8301: LD_INT 45
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: LIST
8308: PUSH
8309: LD_INT 1
8311: PPUSH
8312: LD_INT 3
8314: PPUSH
8315: CALL_OW 12
8319: ARRAY
8320: PPUSH
8321: LD_INT 80
8323: PPUSH
8324: CALL 70578 0 5
// result := result union CreateVehicle ;
8328: LD_ADDR_VAR 0 2
8332: PUSH
8333: LD_VAR 0 2
8337: PUSH
8338: CALL_OW 45
8342: UNION
8343: ST_TO_ADDR
// end ;
8344: GO 8243
8346: POP
8347: POP
// end ; 2 :
8348: GO 9313
8350: LD_INT 2
8352: DOUBLE
8353: EQUAL
8354: IFTRUE 8358
8356: GO 8518
8358: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8359: LD_ADDR_VAR 0 3
8363: PUSH
8364: DOUBLE
8365: LD_INT 1
8367: DEC
8368: ST_TO_ADDR
8369: LD_INT 5
8371: PUSH
8372: LD_INT 6
8374: PUSH
8375: LD_INT 7
8377: PUSH
8378: LD_INT 8
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 44
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 44
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 70578 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 3 :
8516: GO 9313
8518: LD_INT 3
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 8686
8526: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8527: LD_ADDR_VAR 0 3
8531: PUSH
8532: DOUBLE
8533: LD_INT 1
8535: DEC
8536: ST_TO_ADDR
8537: LD_INT 5
8539: PUSH
8540: LD_INT 7
8542: PUSH
8543: LD_INT 8
8545: PUSH
8546: LD_INT 9
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: PUSH
8555: LD_OWVAR 67
8559: ARRAY
8560: PUSH
8561: FOR_TO
8562: IFFALSE 8682
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8564: LD_INT 22
8566: PUSH
8567: LD_INT 24
8569: PUSH
8570: LD_INT 24
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: LIST
8577: PUSH
8578: LD_VAR 0 3
8582: PUSH
8583: LD_INT 3
8585: MOD
8586: PUSH
8587: LD_INT 1
8589: PLUS
8590: ARRAY
8591: PPUSH
8592: LD_INT 1
8594: PUSH
8595: LD_INT 3
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PUSH
8602: LD_INT 1
8604: PPUSH
8605: LD_INT 2
8607: PPUSH
8608: CALL_OW 12
8612: ARRAY
8613: PPUSH
8614: LD_INT 3
8616: PPUSH
8617: LD_INT 43
8619: PUSH
8620: LD_INT 47
8622: PUSH
8623: LD_INT 45
8625: PUSH
8626: LD_INT 45
8628: PUSH
8629: LD_INT 46
8631: PUSH
8632: LD_INT 46
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: PUSH
8643: LD_VAR 0 3
8647: PUSH
8648: LD_INT 6
8650: MOD
8651: PUSH
8652: LD_INT 1
8654: PLUS
8655: ARRAY
8656: PPUSH
8657: LD_INT 80
8659: PPUSH
8660: CALL 70578 0 5
// result := result union CreateVehicle ;
8664: LD_ADDR_VAR 0 2
8668: PUSH
8669: LD_VAR 0 2
8673: PUSH
8674: CALL_OW 45
8678: UNION
8679: ST_TO_ADDR
// end ;
8680: GO 8561
8682: POP
8683: POP
// end ; 4 :
8684: GO 9313
8686: LD_INT 4
8688: DOUBLE
8689: EQUAL
8690: IFTRUE 8694
8692: GO 9312
8694: POP
// begin uc_nation := 3 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 3
8702: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 6
8715: PUSH
8716: LD_INT 8
8718: PUSH
8719: LD_INT 9
8721: PUSH
8722: LD_INT 10
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: LIST
8729: LIST
8730: PUSH
8731: LD_OWVAR 67
8735: ARRAY
8736: PUSH
8737: FOR_TO
8738: IFFALSE 8858
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8740: LD_INT 22
8742: PUSH
8743: LD_INT 24
8745: PUSH
8746: LD_INT 24
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_VAR 0 3
8758: PUSH
8759: LD_INT 3
8761: MOD
8762: PUSH
8763: LD_INT 1
8765: PLUS
8766: ARRAY
8767: PPUSH
8768: LD_INT 1
8770: PUSH
8771: LD_INT 3
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: PUSH
8778: LD_INT 1
8780: PPUSH
8781: LD_INT 2
8783: PPUSH
8784: CALL_OW 12
8788: ARRAY
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: LD_INT 45
8795: PUSH
8796: LD_INT 47
8798: PUSH
8799: LD_INT 47
8801: PUSH
8802: LD_INT 45
8804: PUSH
8805: LD_INT 46
8807: PUSH
8808: LD_INT 46
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: PUSH
8819: LD_VAR 0 3
8823: PUSH
8824: LD_INT 6
8826: MOD
8827: PUSH
8828: LD_INT 1
8830: PLUS
8831: ARRAY
8832: PPUSH
8833: LD_INT 80
8835: PPUSH
8836: CALL 70578 0 5
// result := result union CreateVehicle ;
8840: LD_ADDR_VAR 0 2
8844: PUSH
8845: LD_VAR 0 2
8849: PUSH
8850: CALL_OW 45
8854: UNION
8855: ST_TO_ADDR
// end ;
8856: GO 8737
8858: POP
8859: POP
// if not KappaStatus then
8860: LD_EXP 2
8864: NOT
8865: IFFALSE 9100
// begin uc_nation := 1 ;
8867: LD_ADDR_OWVAR 21
8871: PUSH
8872: LD_INT 1
8874: ST_TO_ADDR
// for i = 1 to 3 do
8875: LD_ADDR_VAR 0 3
8879: PUSH
8880: DOUBLE
8881: LD_INT 1
8883: DEC
8884: ST_TO_ADDR
8885: LD_INT 3
8887: PUSH
8888: FOR_TO
8889: IFFALSE 9025
// begin j := rand ( 0 , 1 ) ;
8891: LD_ADDR_VAR 0 4
8895: PUSH
8896: LD_INT 0
8898: PPUSH
8899: LD_INT 1
8901: PPUSH
8902: CALL_OW 12
8906: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8907: LD_INT 3
8909: PUSH
8910: LD_INT 5
8912: PUSH
8913: LD_INT 5
8915: PUSH
8916: LD_INT 4
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_VAR 0 4
8929: PUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 3
8935: PPUSH
8936: CALL_OW 12
8940: PLUS
8941: ARRAY
8942: PPUSH
8943: LD_INT 1
8945: PUSH
8946: LD_INT 3
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 1
8955: PPUSH
8956: LD_INT 2
8958: PPUSH
8959: CALL_OW 12
8963: ARRAY
8964: PPUSH
8965: LD_INT 3
8967: PPUSH
8968: LD_INT 9
8970: PUSH
8971: LD_INT 7
8973: PUSH
8974: LD_INT 6
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: LIST
8981: PUSH
8982: LD_VAR 0 4
8986: PUSH
8987: LD_INT 1
8989: PPUSH
8990: LD_INT 2
8992: PPUSH
8993: CALL_OW 12
8997: PLUS
8998: ARRAY
8999: PPUSH
9000: LD_INT 85
9002: PPUSH
9003: CALL 70578 0 5
// result := result union CreateVehicle ;
9007: LD_ADDR_VAR 0 2
9011: PUSH
9012: LD_VAR 0 2
9016: PUSH
9017: CALL_OW 45
9021: UNION
9022: ST_TO_ADDR
// end ;
9023: GO 8888
9025: POP
9026: POP
// if vsevolodFirstAttack then
9027: LD_EXP 24
9031: IFFALSE 9098
// begin vsevolodFirstAttack := false ;
9033: LD_ADDR_EXP 24
9037: PUSH
9038: LD_INT 0
9040: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9041: LD_INT 5
9043: PPUSH
9044: LD_INT 3
9046: PPUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 6
9052: PPUSH
9053: LD_INT 100
9055: PPUSH
9056: CALL 70578 0 5
// sewiVeh := CreateVehicle ;
9060: LD_ADDR_EXP 71
9064: PUSH
9065: CALL_OW 45
9069: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9070: LD_EXP 71
9074: PPUSH
9075: LD_INT 1
9077: PPUSH
9078: CALL_OW 242
// result := result union sewiVeh ;
9082: LD_ADDR_VAR 0 2
9086: PUSH
9087: LD_VAR 0 2
9091: PUSH
9092: LD_EXP 71
9096: UNION
9097: ST_TO_ADDR
// end ; end else
9098: GO 9310
// if vsevolodFirstAttack then
9100: LD_EXP 24
9104: IFFALSE 9310
// begin vsevolodFirstAttack := false ;
9106: LD_ADDR_EXP 24
9110: PUSH
9111: LD_INT 0
9113: ST_TO_ADDR
// uc_nation := 3 ;
9114: LD_ADDR_OWVAR 21
9118: PUSH
9119: LD_INT 3
9121: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9122: LD_ADDR_VAR 0 3
9126: PUSH
9127: DOUBLE
9128: LD_INT 1
9130: DEC
9131: ST_TO_ADDR
9132: LD_INT 2
9134: PUSH
9135: LD_OWVAR 67
9139: PLUS
9140: PUSH
9141: FOR_TO
9142: IFFALSE 9250
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9144: LD_INT 22
9146: PUSH
9147: LD_INT 24
9149: PUSH
9150: LD_INT 24
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: LIST
9157: PUSH
9158: LD_VAR 0 3
9162: PUSH
9163: LD_INT 3
9165: MOD
9166: PUSH
9167: LD_INT 1
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 1
9196: PPUSH
9197: LD_INT 45
9199: PUSH
9200: LD_INT 47
9202: PUSH
9203: LD_INT 47
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 3
9215: PUSH
9216: LD_INT 3
9218: MOD
9219: PUSH
9220: LD_INT 1
9222: PLUS
9223: ARRAY
9224: PPUSH
9225: LD_INT 80
9227: PPUSH
9228: CALL 70578 0 5
// result := result union CreateVehicle ;
9232: LD_ADDR_VAR 0 2
9236: PUSH
9237: LD_VAR 0 2
9241: PUSH
9242: CALL_OW 45
9246: UNION
9247: ST_TO_ADDR
// end ;
9248: GO 9141
9250: POP
9251: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9252: LD_INT 24
9254: PPUSH
9255: LD_INT 3
9257: PPUSH
9258: LD_INT 1
9260: PPUSH
9261: LD_INT 47
9263: PPUSH
9264: LD_INT 100
9266: PPUSH
9267: CALL 70578 0 5
// sewiVeh := CreateVehicle ;
9271: LD_ADDR_EXP 71
9275: PUSH
9276: CALL_OW 45
9280: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9281: LD_EXP 71
9285: PPUSH
9286: LD_INT 6
9288: NEG
9289: PPUSH
9290: CALL_OW 242
// result := result union sewiVeh ;
9294: LD_ADDR_VAR 0 2
9298: PUSH
9299: LD_VAR 0 2
9303: PUSH
9304: LD_EXP 71
9308: UNION
9309: ST_TO_ADDR
// end ; end ; end ;
9310: GO 9313
9312: POP
// end ;
9313: LD_VAR 0 2
9317: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9318: LD_EXP 16
9322: IFFALSE 10167
9324: GO 9326
9326: DISABLE
9327: LD_INT 0
9329: PPUSH
9330: PPUSH
9331: PPUSH
9332: PPUSH
9333: PPUSH
9334: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9335: LD_ADDR_VAR 0 4
9339: PUSH
9340: LD_INT 11
9342: PUSH
9343: LD_INT 12
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9350: LD_ADDR_VAR 0 3
9354: PUSH
9355: LD_INT 11550
9357: PUSH
9358: LD_INT 10150
9360: PUSH
9361: LD_INT 9800
9363: PUSH
9364: LD_INT 9450
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: LIST
9371: LIST
9372: PUSH
9373: LD_OWVAR 67
9377: ARRAY
9378: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9379: LD_ADDR_VAR 0 6
9383: PUSH
9384: LD_INT 70
9386: PUSH
9387: LD_INT 118
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: PUSH
9394: LD_INT 78
9396: PUSH
9397: LD_INT 31
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: ST_TO_ADDR
// repeat if missionStage = 2 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 2
9415: EQUAL
9416: IFFALSE 9427
// wait ( 1 1$30 ) else
9418: LD_INT 3150
9420: PPUSH
9421: CALL_OW 67
9425: GO 9436
// wait ( time ) ;
9427: LD_VAR 0 3
9431: PPUSH
9432: CALL_OW 67
// if missionStage = 6 then
9436: LD_EXP 15
9440: PUSH
9441: LD_INT 6
9443: EQUAL
9444: IFFALSE 9472
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9446: LD_INT 51
9448: PPUSH
9449: LD_INT 6
9451: PPUSH
9452: LD_INT 2
9454: PPUSH
9455: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9459: LD_INT 57
9461: PPUSH
9462: LD_INT 6
9464: PPUSH
9465: LD_INT 2
9467: PPUSH
9468: CALL_OW 322
// end ; if missionStage = 8 then
9472: LD_EXP 15
9476: PUSH
9477: LD_INT 8
9479: EQUAL
9480: IFFALSE 9508
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9482: LD_INT 52
9484: PPUSH
9485: LD_INT 6
9487: PPUSH
9488: LD_INT 2
9490: PPUSH
9491: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9495: LD_INT 58
9497: PPUSH
9498: LD_INT 6
9500: PPUSH
9501: LD_INT 2
9503: PPUSH
9504: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9508: LD_EXP 15
9512: PUSH
9513: LD_INT 10
9515: EQUAL
9516: PUSH
9517: LD_OWVAR 67
9521: PUSH
9522: LD_INT 1
9524: GREATER
9525: AND
9526: IFFALSE 9554
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9528: LD_INT 53
9530: PPUSH
9531: LD_INT 6
9533: PPUSH
9534: LD_INT 2
9536: PPUSH
9537: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9541: LD_INT 59
9543: PPUSH
9544: LD_INT 6
9546: PPUSH
9547: LD_INT 2
9549: PPUSH
9550: CALL_OW 322
// end ; if activeAttacks then
9554: LD_EXP 16
9558: IFFALSE 10161
// begin if missionStage = 2 then
9560: LD_EXP 15
9564: PUSH
9565: LD_INT 2
9567: EQUAL
9568: IFFALSE 9578
// strength := 1 ;
9570: LD_ADDR_VAR 0 5
9574: PUSH
9575: LD_INT 1
9577: ST_TO_ADDR
// if missionStage > 2 then
9578: LD_EXP 15
9582: PUSH
9583: LD_INT 2
9585: GREATER
9586: IFFALSE 9596
// strength := 2 ;
9588: LD_ADDR_VAR 0 5
9592: PUSH
9593: LD_INT 2
9595: ST_TO_ADDR
// if missionStage > 6 then
9596: LD_EXP 15
9600: PUSH
9601: LD_INT 6
9603: GREATER
9604: IFFALSE 9614
// strength := 3 ;
9606: LD_ADDR_VAR 0 5
9610: PUSH
9611: LD_INT 3
9613: ST_TO_ADDR
// if missionStage > 10 then
9614: LD_EXP 15
9618: PUSH
9619: LD_INT 10
9621: GREATER
9622: IFFALSE 9632
// strength := 4 ;
9624: LD_ADDR_VAR 0 5
9628: PUSH
9629: LD_INT 4
9631: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9632: LD_ADDR_VAR 0 2
9636: PUSH
9637: LD_VAR 0 5
9641: PPUSH
9642: CALL 8167 0 1
9646: ST_TO_ADDR
// for i in tmp do
9647: LD_ADDR_VAR 0 1
9651: PUSH
9652: LD_VAR 0 2
9656: PUSH
9657: FOR_IN
9658: IFFALSE 9841
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9660: LD_VAR 0 1
9664: PPUSH
9665: LD_VAR 0 4
9669: PUSH
9670: LD_INT 1
9672: PPUSH
9673: LD_INT 2
9675: PPUSH
9676: CALL_OW 12
9680: ARRAY
9681: PPUSH
9682: LD_INT 0
9684: PPUSH
9685: CALL_OW 49
// if i = sewiVeh then
9689: LD_VAR 0 1
9693: PUSH
9694: LD_EXP 71
9698: EQUAL
9699: IFFALSE 9736
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9701: LD_ADDR_EXP 70
9705: PUSH
9706: LD_STRING Vsevolod
9708: PPUSH
9709: LD_INT 0
9711: PPUSH
9712: LD_STRING 
9714: PPUSH
9715: CALL 65714 0 3
9719: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9720: LD_EXP 70
9724: PPUSH
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 52
// end else
9734: GO 9817
// if GetControl ( i ) = control_manual then
9736: LD_VAR 0 1
9740: PPUSH
9741: CALL_OW 263
9745: PUSH
9746: LD_INT 1
9748: EQUAL
9749: IFFALSE 9817
// begin uc_side := 6 ;
9751: LD_ADDR_OWVAR 20
9755: PUSH
9756: LD_INT 6
9758: ST_TO_ADDR
// uc_nation := 3 ;
9759: LD_ADDR_OWVAR 21
9763: PUSH
9764: LD_INT 3
9766: ST_TO_ADDR
// hc_gallery :=  ;
9767: LD_ADDR_OWVAR 33
9771: PUSH
9772: LD_STRING 
9774: ST_TO_ADDR
// hc_name :=  ;
9775: LD_ADDR_OWVAR 26
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9783: LD_INT 0
9785: PPUSH
9786: LD_INT 3
9788: PPUSH
9789: LD_INT 10
9791: PPUSH
9792: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9796: CALL_OW 44
9800: PPUSH
9801: LD_VAR 0 1
9805: PPUSH
9806: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9810: LD_INT 10
9812: PPUSH
9813: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9817: LD_VAR 0 1
9821: PPUSH
9822: LD_INT 111
9824: PPUSH
9825: LD_INT 197
9827: PPUSH
9828: CALL_OW 111
// wait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 67
// end ;
9839: GO 9657
9841: POP
9842: POP
// repeat wait ( 0 0$1 ) ;
9843: LD_INT 35
9845: PPUSH
9846: CALL_OW 67
// for i in tmp do
9850: LD_ADDR_VAR 0 1
9854: PUSH
9855: LD_VAR 0 2
9859: PUSH
9860: FOR_IN
9861: IFFALSE 10142
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9863: LD_INT 81
9865: PUSH
9866: LD_INT 6
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 91
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_INT 12
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: LIST
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PPUSH
9893: CALL_OW 69
9897: IFFALSE 9955
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_INT 81
9906: PUSH
9907: LD_INT 6
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 91
9916: PUSH
9917: LD_VAR 0 1
9921: PUSH
9922: LD_INT 12
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: LIST
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PPUSH
9934: CALL_OW 69
9938: PPUSH
9939: LD_VAR 0 1
9943: PPUSH
9944: CALL_OW 74
9948: PPUSH
9949: CALL_OW 115
9953: GO 10140
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9955: LD_INT 9
9957: PPUSH
9958: LD_INT 81
9960: PUSH
9961: LD_INT 6
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 70
9972: IFFALSE 10106
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_VAR 0 6
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PUSH
9988: LD_INT 1
9990: ARRAY
9991: PPUSH
9992: LD_VAR 0 6
9996: PUSH
9997: LD_INT 1
9999: ARRAY
10000: PUSH
10001: LD_INT 2
10003: ARRAY
10004: PPUSH
10005: CALL_OW 297
10009: PUSH
10010: LD_INT 10
10012: GREATER
10013: PUSH
10014: LD_VAR 0 1
10018: PPUSH
10019: LD_INT 9
10021: PPUSH
10022: CALL_OW 308
10026: NOT
10027: AND
10028: IFFALSE 10067
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10030: LD_VAR 0 1
10034: PPUSH
10035: LD_VAR 0 6
10039: PUSH
10040: LD_INT 1
10042: ARRAY
10043: PUSH
10044: LD_INT 1
10046: ARRAY
10047: PPUSH
10048: LD_VAR 0 6
10052: PUSH
10053: LD_INT 1
10055: ARRAY
10056: PUSH
10057: LD_INT 2
10059: ARRAY
10060: PPUSH
10061: CALL_OW 114
10065: GO 10104
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10067: LD_VAR 0 1
10071: PPUSH
10072: LD_INT 9
10074: PPUSH
10075: LD_INT 81
10077: PUSH
10078: LD_INT 6
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: PPUSH
10085: CALL_OW 70
10089: PPUSH
10090: LD_VAR 0 1
10094: PPUSH
10095: CALL_OW 74
10099: PPUSH
10100: CALL_OW 115
// end else
10104: GO 10140
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10106: LD_VAR 0 1
10110: PPUSH
10111: LD_INT 81
10113: PUSH
10114: LD_INT 6
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 69
10125: PPUSH
10126: LD_VAR 0 1
10130: PPUSH
10131: CALL_OW 74
10135: PPUSH
10136: CALL_OW 115
// end ;
10140: GO 9860
10142: POP
10143: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10144: LD_INT 22
10146: PUSH
10147: LD_INT 6
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PPUSH
10154: CALL_OW 69
10158: NOT
10159: IFFALSE 9843
// end ; until russianDestroyed ;
10161: LD_EXP 21
10165: IFFALSE 9408
// end ;
10167: PPOPN 6
10169: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10170: LD_EXP 21
10174: NOT
10175: PUSH
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 6
10183: GREATEREQUAL
10184: AND
10185: PUSH
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 1
10191: PPUSH
10192: CALL 60726 0 2
10196: NOT
10197: AND
10198: IFFALSE 11158
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
10207: PPUSH
10208: PPUSH
// begin enable ;
10209: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10210: LD_INT 22
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 30
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: PPUSH
10234: CALL_OW 69
10238: NOT
10239: IFFALSE 10243
// exit ;
10241: GO 11158
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10243: LD_ADDR_VAR 0 4
10247: PUSH
10248: LD_INT 22
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 30
10260: PUSH
10261: LD_INT 34
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PPUSH
10272: CALL_OW 69
10276: ST_TO_ADDR
// if Prob ( 40 ) then
10277: LD_INT 40
10279: PPUSH
10280: CALL_OW 13
10284: IFFALSE 10411
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10286: LD_INT 2
10288: PPUSH
10289: LD_INT 22
10291: PUSH
10292: LD_INT 3
10294: PUSH
10295: LD_INT 3
10297: PUSH
10298: LD_INT 49
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 22
10309: PUSH
10310: LD_INT 3
10312: PUSH
10313: LD_INT 3
10315: PUSH
10316: LD_INT 49
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: PUSH
10325: LD_INT 22
10327: PUSH
10328: LD_INT 3
10330: PUSH
10331: LD_INT 3
10333: PUSH
10334: LD_INT 49
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: PUSH
10343: LD_INT 24
10345: PUSH
10346: LD_INT 3
10348: PUSH
10349: LD_INT 3
10351: PUSH
10352: LD_INT 46
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PUSH
10361: LD_INT 24
10363: PUSH
10364: LD_INT 3
10366: PUSH
10367: LD_INT 3
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: PUSH
10379: LD_INT 24
10381: PUSH
10382: LD_INT 3
10384: PUSH
10385: LD_INT 3
10387: PUSH
10388: LD_INT 46
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL 59308 0 2
// end else
10409: GO 10534
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10411: LD_INT 2
10413: PPUSH
10414: LD_INT 24
10416: PUSH
10417: LD_INT 3
10419: PUSH
10420: LD_INT 3
10422: PUSH
10423: LD_INT 47
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: PUSH
10432: LD_INT 24
10434: PUSH
10435: LD_INT 3
10437: PUSH
10438: LD_INT 3
10440: PUSH
10441: LD_INT 47
10443: PUSH
10444: EMPTY
10445: LIST
10446: LIST
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 24
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 3
10458: PUSH
10459: LD_INT 47
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: PUSH
10468: LD_INT 24
10470: PUSH
10471: LD_INT 3
10473: PUSH
10474: LD_INT 3
10476: PUSH
10477: LD_INT 46
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 24
10488: PUSH
10489: LD_INT 3
10491: PUSH
10492: LD_INT 3
10494: PUSH
10495: LD_INT 46
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 24
10506: PUSH
10507: LD_INT 3
10509: PUSH
10510: LD_INT 3
10512: PUSH
10513: LD_INT 46
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PPUSH
10530: CALL 59308 0 2
// end ; if Difficulty > 1 then
10534: LD_OWVAR 67
10538: PUSH
10539: LD_INT 1
10541: GREATER
10542: IFFALSE 10572
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10544: LD_INT 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 3
10552: PUSH
10553: LD_INT 3
10555: PUSH
10556: LD_INT 47
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: PUSH
10565: EMPTY
10566: LIST
10567: PPUSH
10568: CALL 59308 0 2
// repeat wait ( 0 0$1 ) ;
10572: LD_INT 35
10574: PPUSH
10575: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10579: LD_INT 2
10581: PPUSH
10582: LD_INT 1
10584: PPUSH
10585: CALL 60726 0 2
10589: PUSH
10590: LD_INT 6
10592: PUSH
10593: LD_INT 7
10595: PUSH
10596: LD_INT 7
10598: PUSH
10599: LD_INT 7
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: PUSH
10608: LD_OWVAR 67
10612: ARRAY
10613: GREATEREQUAL
10614: IFFALSE 10572
// wait ( 0 0$30 ) ;
10616: LD_INT 1050
10618: PPUSH
10619: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10623: LD_ADDR_VAR 0 2
10627: PUSH
10628: LD_INT 2
10630: PPUSH
10631: LD_INT 1
10633: PPUSH
10634: CALL 60726 0 2
10638: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10639: LD_ADDR_EXP 135
10643: PUSH
10644: LD_EXP 135
10648: PPUSH
10649: LD_INT 2
10651: PPUSH
10652: LD_EXP 135
10656: PUSH
10657: LD_INT 2
10659: ARRAY
10660: PUSH
10661: LD_VAR 0 2
10665: DIFF
10666: PPUSH
10667: CALL_OW 1
10671: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10672: LD_ADDR_VAR 0 3
10676: PUSH
10677: LD_INT 0
10679: PPUSH
10680: LD_INT 1
10682: PPUSH
10683: CALL_OW 12
10687: ST_TO_ADDR
// if target then
10688: LD_VAR 0 3
10692: IFFALSE 10820
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10694: LD_ADDR_VAR 0 2
10698: PUSH
10699: LD_VAR 0 2
10703: PPUSH
10704: LD_INT 24
10706: PUSH
10707: LD_INT 250
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL_OW 72
10718: ST_TO_ADDR
// for i in tmp do
10719: LD_ADDR_VAR 0 1
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: FOR_IN
10730: IFFALSE 10770
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 139
10739: PPUSH
10740: LD_INT 89
10742: PPUSH
10743: CALL_OW 297
10747: PUSH
10748: LD_INT 9
10750: GREATER
10751: IFFALSE 10768
// ComMoveXY ( i , 139 , 89 ) ;
10753: LD_VAR 0 1
10757: PPUSH
10758: LD_INT 139
10760: PPUSH
10761: LD_INT 89
10763: PPUSH
10764: CALL_OW 111
10768: GO 10729
10770: POP
10771: POP
// wait ( 0 0$1 ) ;
10772: LD_INT 35
10774: PPUSH
10775: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 92
10786: PUSH
10787: LD_INT 139
10789: PUSH
10790: LD_INT 89
10792: PUSH
10793: LD_INT 9
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PPUSH
10802: CALL_OW 72
10806: PUSH
10807: LD_VAR 0 2
10811: PUSH
10812: LD_INT 1
10814: MINUS
10815: GREATEREQUAL
10816: IFFALSE 10694
// end else
10818: GO 10962
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10820: LD_VAR 0 2
10824: PPUSH
10825: LD_VAR 0 4
10829: PUSH
10830: LD_INT 1
10832: ARRAY
10833: PPUSH
10834: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10838: LD_ADDR_VAR 0 2
10842: PUSH
10843: LD_VAR 0 2
10847: PPUSH
10848: LD_INT 24
10850: PUSH
10851: LD_INT 250
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: PPUSH
10858: CALL_OW 72
10862: ST_TO_ADDR
// for i in tmp do
10863: LD_ADDR_VAR 0 1
10867: PUSH
10868: LD_VAR 0 2
10872: PUSH
10873: FOR_IN
10874: IFFALSE 10914
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10876: LD_VAR 0 1
10880: PPUSH
10881: LD_INT 124
10883: PPUSH
10884: LD_INT 139
10886: PPUSH
10887: CALL_OW 297
10891: PUSH
10892: LD_INT 9
10894: GREATER
10895: IFFALSE 10912
// ComMoveXY ( i , 124 , 139 ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_INT 124
10904: PPUSH
10905: LD_INT 139
10907: PPUSH
10908: CALL_OW 111
10912: GO 10873
10914: POP
10915: POP
// wait ( 0 0$1 ) ;
10916: LD_INT 35
10918: PPUSH
10919: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10923: LD_VAR 0 2
10927: PPUSH
10928: LD_INT 92
10930: PUSH
10931: LD_INT 124
10933: PUSH
10934: LD_INT 139
10936: PUSH
10937: LD_INT 9
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 72
10950: PUSH
10951: LD_VAR 0 2
10955: PUSH
10956: LD_INT 1
10958: MINUS
10959: GREATEREQUAL
10960: IFFALSE 10838
// end ; repeat wait ( 0 0$1 ) ;
10962: LD_INT 35
10964: PPUSH
10965: CALL_OW 67
// for i in tmp do
10969: LD_ADDR_VAR 0 1
10973: PUSH
10974: LD_VAR 0 2
10978: PUSH
10979: FOR_IN
10980: IFFALSE 11149
// begin if GetLives ( i ) > 251 then
10982: LD_VAR 0 1
10986: PPUSH
10987: CALL_OW 256
10991: PUSH
10992: LD_INT 251
10994: GREATER
10995: IFFALSE 11120
// begin if GetWeapon ( i ) = ru_time_lapser then
10997: LD_VAR 0 1
11001: PPUSH
11002: CALL_OW 264
11006: PUSH
11007: LD_INT 49
11009: EQUAL
11010: IFFALSE 11066
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11012: LD_VAR 0 1
11016: PPUSH
11017: LD_INT 2
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: LD_INT 22
11032: PUSH
11033: LD_INT 8
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: LIST
11044: PPUSH
11045: CALL_OW 69
11049: PPUSH
11050: LD_VAR 0 1
11054: PPUSH
11055: CALL_OW 74
11059: PPUSH
11060: CALL_OW 112
11064: GO 11118
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11066: LD_VAR 0 1
11070: PPUSH
11071: LD_INT 2
11073: PUSH
11074: LD_INT 22
11076: PUSH
11077: LD_INT 1
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 22
11086: PUSH
11087: LD_INT 8
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: EMPTY
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: PPUSH
11104: LD_VAR 0 1
11108: PPUSH
11109: CALL_OW 74
11113: PPUSH
11114: CALL_OW 115
// end else
11118: GO 11147
// if IsDead ( i ) then
11120: LD_VAR 0 1
11124: PPUSH
11125: CALL_OW 301
11129: IFFALSE 11147
// tmp := tmp diff i ;
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_VAR 0 2
11140: PUSH
11141: LD_VAR 0 1
11145: DIFF
11146: ST_TO_ADDR
// end ;
11147: GO 10979
11149: POP
11150: POP
// until not tmp ;
11151: LD_VAR 0 2
11155: NOT
11156: IFFALSE 10962
// end ; end_of_file
11158: PPOPN 4
11160: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11161: LD_INT 0
11163: PPUSH
11164: PPUSH
11165: PPUSH
11166: PPUSH
11167: PPUSH
11168: PPUSH
// side := 7 ;
11169: LD_ADDR_VAR 0 5
11173: PUSH
11174: LD_INT 7
11176: ST_TO_ADDR
// uc_side := side ;
11177: LD_ADDR_OWVAR 20
11181: PUSH
11182: LD_VAR 0 5
11186: ST_TO_ADDR
// uc_nation := 1 ;
11187: LD_ADDR_OWVAR 21
11191: PUSH
11192: LD_INT 1
11194: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11195: LD_ADDR_VAR 0 2
11199: PUSH
11200: LD_INT 22
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: LD_INT 21
11214: PUSH
11215: LD_INT 3
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PPUSH
11226: CALL_OW 69
11230: PUSH
11231: FOR_IN
11232: IFFALSE 11248
// SetBLevel ( i , 10 ) ;
11234: LD_VAR 0 2
11238: PPUSH
11239: LD_INT 10
11241: PPUSH
11242: CALL_OW 241
11246: GO 11231
11248: POP
11249: POP
// base := GetBase ( al_depot ) ;
11250: LD_ADDR_VAR 0 4
11254: PUSH
11255: LD_INT 2
11257: PPUSH
11258: CALL_OW 274
11262: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11263: LD_ADDR_VAR 0 6
11267: PUSH
11268: LD_INT 22
11270: PUSH
11271: LD_VAR 0 5
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 30
11282: PUSH
11283: LD_INT 34
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PPUSH
11294: CALL_OW 69
11298: ST_TO_ADDR
// if teleport then
11299: LD_VAR 0 6
11303: IFFALSE 11324
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11305: LD_VAR 0 6
11309: PUSH
11310: LD_INT 1
11312: ARRAY
11313: PPUSH
11314: LD_INT 262
11316: PPUSH
11317: LD_INT 119
11319: PPUSH
11320: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11324: LD_VAR 0 4
11328: PPUSH
11329: LD_INT 1
11331: PPUSH
11332: LD_INT 19500
11334: PPUSH
11335: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11339: LD_VAR 0 4
11343: PPUSH
11344: LD_INT 2
11346: PPUSH
11347: LD_INT 200
11349: PPUSH
11350: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11354: LD_VAR 0 4
11358: PPUSH
11359: LD_INT 3
11361: PPUSH
11362: LD_INT 650
11364: PPUSH
11365: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11369: LD_ADDR_EXP 74
11373: PUSH
11374: LD_STRING Roth
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11382: LD_ADDR_EXP 75
11386: PUSH
11387: LD_STRING Simms
11389: PPUSH
11390: LD_EXP 1
11394: NOT
11395: PPUSH
11396: LD_STRING 10c_
11398: PPUSH
11399: CALL 65714 0 3
11403: ST_TO_ADDR
// if not Simms then
11404: LD_EXP 75
11408: NOT
11409: IFFALSE 11439
// begin uc_nation := 1 ;
11411: LD_ADDR_OWVAR 21
11415: PUSH
11416: LD_INT 1
11418: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11419: LD_INT 2
11421: PPUSH
11422: LD_INT 10
11424: PPUSH
11425: CALL_OW 384
// Simms := CreateHuman ;
11429: LD_ADDR_EXP 75
11433: PUSH
11434: CALL_OW 44
11438: ST_TO_ADDR
// end ; uc_nation := 3 ;
11439: LD_ADDR_OWVAR 21
11443: PUSH
11444: LD_INT 3
11446: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11447: LD_ADDR_EXP 76
11451: PUSH
11452: LD_STRING Kirilenkova
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11460: LD_ADDR_EXP 90
11464: PUSH
11465: LD_STRING Oblukov
11467: PPUSH
11468: CALL_OW 25
11472: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11473: LD_ADDR_EXP 77
11477: PUSH
11478: LD_STRING Dolgov
11480: PPUSH
11481: CALL_OW 25
11485: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11486: LD_ADDR_EXP 78
11490: PUSH
11491: LD_STRING Petrosyan
11493: PPUSH
11494: CALL_OW 25
11498: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11499: LD_ADDR_EXP 89
11503: PUSH
11504: LD_STRING Scholtze
11506: PPUSH
11507: CALL_OW 25
11511: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11512: LD_ADDR_EXP 88
11516: PUSH
11517: LD_STRING Kapitsova
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11525: LD_ADDR_EXP 79
11529: PUSH
11530: LD_STRING Petrovova
11532: PPUSH
11533: CALL_OW 25
11537: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11538: LD_ADDR_EXP 80
11542: PUSH
11543: LD_STRING Kuzmov
11545: PPUSH
11546: CALL_OW 25
11550: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11551: LD_ADDR_EXP 87
11555: PUSH
11556: LD_STRING Karamazov
11558: PPUSH
11559: CALL_OW 25
11563: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11564: LD_STRING 13_Lipshchin_1
11566: PPUSH
11567: LD_INT 0
11569: PPUSH
11570: CALL_OW 30
11574: IFFALSE 11589
// Lipshchin := NewCharacter ( Lipshchin ) ;
11576: LD_ADDR_EXP 81
11580: PUSH
11581: LD_STRING Lipshchin
11583: PPUSH
11584: CALL_OW 25
11588: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11589: LD_STRING 13_Titov_1
11591: PPUSH
11592: LD_INT 0
11594: PPUSH
11595: CALL_OW 30
11599: IFFALSE 11614
// Titov := NewCharacter ( Titov ) ;
11601: LD_ADDR_EXP 83
11605: PUSH
11606: LD_STRING Titov
11608: PPUSH
11609: CALL_OW 25
11613: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11614: LD_STRING 13_Gnyevko_1
11616: PPUSH
11617: LD_INT 0
11619: PPUSH
11620: CALL_OW 30
11624: IFFALSE 11639
// Gnyevko := NewCharacter ( Gnyevko ) ;
11626: LD_ADDR_EXP 82
11630: PUSH
11631: LD_STRING Gnyevko
11633: PPUSH
11634: CALL_OW 25
11638: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11639: LD_STRING 13_Xavier_1
11641: PPUSH
11642: LD_INT 0
11644: PPUSH
11645: CALL_OW 30
11649: IFFALSE 11664
// Xavier := NewCharacter ( Xavier2 ) ;
11651: LD_ADDR_EXP 84
11655: PUSH
11656: LD_STRING Xavier2
11658: PPUSH
11659: CALL_OW 25
11663: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11664: LD_STRING 13_Belkov_1
11666: PPUSH
11667: LD_INT 0
11669: PPUSH
11670: CALL_OW 30
11674: IFFALSE 11689
// Belkov := NewCharacter ( Belkov ) ;
11676: LD_ADDR_EXP 85
11680: PUSH
11681: LD_STRING Belkov
11683: PPUSH
11684: CALL_OW 25
11688: ST_TO_ADDR
// if not BurlakStatus then
11689: LD_EXP 9
11693: NOT
11694: IFFALSE 11709
// Burlak = NewCharacter ( Burlak ) ;
11696: LD_ADDR_EXP 86
11700: PUSH
11701: LD_STRING Burlak
11703: PPUSH
11704: CALL_OW 25
11708: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11709: LD_ADDR_VAR 0 3
11713: PUSH
11714: LD_EXP 74
11718: PUSH
11719: LD_EXP 76
11723: PUSH
11724: LD_EXP 90
11728: PUSH
11729: LD_EXP 77
11733: PUSH
11734: LD_EXP 78
11738: PUSH
11739: LD_EXP 89
11743: PUSH
11744: LD_EXP 88
11748: PUSH
11749: LD_EXP 79
11753: PUSH
11754: LD_EXP 80
11758: PUSH
11759: LD_EXP 87
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
// if Simms then
11776: LD_EXP 75
11780: IFFALSE 11798
// tmp := tmp ^ Simms ;
11782: LD_ADDR_VAR 0 3
11786: PUSH
11787: LD_VAR 0 3
11791: PUSH
11792: LD_EXP 75
11796: ADD
11797: ST_TO_ADDR
// if Titov then
11798: LD_EXP 83
11802: IFFALSE 11820
// tmp := tmp ^ Titov ;
11804: LD_ADDR_VAR 0 3
11808: PUSH
11809: LD_VAR 0 3
11813: PUSH
11814: LD_EXP 83
11818: ADD
11819: ST_TO_ADDR
// if Lipshchin then
11820: LD_EXP 81
11824: IFFALSE 11842
// tmp := tmp ^ Lipshchin ;
11826: LD_ADDR_VAR 0 3
11830: PUSH
11831: LD_VAR 0 3
11835: PUSH
11836: LD_EXP 81
11840: ADD
11841: ST_TO_ADDR
// if Gnyevko then
11842: LD_EXP 82
11846: IFFALSE 11864
// tmp := tmp ^ Gnyevko ;
11848: LD_ADDR_VAR 0 3
11852: PUSH
11853: LD_VAR 0 3
11857: PUSH
11858: LD_EXP 82
11862: ADD
11863: ST_TO_ADDR
// if Xavier then
11864: LD_EXP 84
11868: IFFALSE 11886
// tmp := tmp ^ Xavier ;
11870: LD_ADDR_VAR 0 3
11874: PUSH
11875: LD_VAR 0 3
11879: PUSH
11880: LD_EXP 84
11884: ADD
11885: ST_TO_ADDR
// if Belkov then
11886: LD_EXP 85
11890: IFFALSE 11908
// tmp := tmp ^ Belkov ;
11892: LD_ADDR_VAR 0 3
11896: PUSH
11897: LD_VAR 0 3
11901: PUSH
11902: LD_EXP 85
11906: ADD
11907: ST_TO_ADDR
// if Burlak then
11908: LD_EXP 86
11912: IFFALSE 11930
// tmp := tmp ^ Burlak ;
11914: LD_ADDR_VAR 0 3
11918: PUSH
11919: LD_VAR 0 3
11923: PUSH
11924: LD_EXP 86
11928: ADD
11929: ST_TO_ADDR
// for i = 1 to 11 do
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: DOUBLE
11936: LD_INT 1
11938: DEC
11939: ST_TO_ADDR
11940: LD_INT 11
11942: PUSH
11943: FOR_TO
11944: IFFALSE 12010
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11946: LD_ADDR_OWVAR 21
11950: PUSH
11951: LD_INT 1
11953: PUSH
11954: LD_INT 3
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 1
11963: PPUSH
11964: LD_INT 2
11966: PPUSH
11967: CALL_OW 12
11971: ARRAY
11972: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11973: LD_INT 0
11975: PPUSH
11976: LD_VAR 0 2
11980: PUSH
11981: LD_INT 2
11983: DIV
11984: PPUSH
11985: LD_INT 10
11987: PPUSH
11988: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11992: LD_ADDR_VAR 0 3
11996: PUSH
11997: LD_VAR 0 3
12001: PUSH
12002: CALL_OW 44
12006: ADD
12007: ST_TO_ADDR
// end ;
12008: GO 11943
12010: POP
12011: POP
// for i in tmp do
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_VAR 0 3
12021: PUSH
12022: FOR_IN
12023: IFFALSE 12048
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12025: LD_VAR 0 2
12029: PPUSH
12030: LD_INT 260
12032: PPUSH
12033: LD_INT 235
12035: PPUSH
12036: LD_INT 8
12038: PPUSH
12039: LD_INT 0
12041: PPUSH
12042: CALL_OW 50
12046: GO 12022
12048: POP
12049: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12050: LD_ADDR_EXP 116
12054: PUSH
12055: LD_EXP 116
12059: PPUSH
12060: LD_INT 1
12062: PPUSH
12063: LD_INT 22
12065: PUSH
12066: LD_VAR 0 5
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 3
12077: PUSH
12078: LD_INT 21
12080: PUSH
12081: LD_INT 2
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PPUSH
12096: CALL_OW 69
12100: PUSH
12101: LD_EXP 74
12105: PUSH
12106: LD_EXP 75
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: DIFF
12115: PPUSH
12116: CALL_OW 1
12120: ST_TO_ADDR
// uc_side := 0 ;
12121: LD_ADDR_OWVAR 20
12125: PUSH
12126: LD_INT 0
12128: ST_TO_ADDR
// uc_nation := 0 ;
12129: LD_ADDR_OWVAR 21
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// for i = 1 to 5 do
12137: LD_ADDR_VAR 0 2
12141: PUSH
12142: DOUBLE
12143: LD_INT 1
12145: DEC
12146: ST_TO_ADDR
12147: LD_INT 5
12149: PUSH
12150: FOR_TO
12151: IFFALSE 12188
// begin InitHc ;
12153: CALL_OW 19
// hc_class := class_apeman ;
12157: LD_ADDR_OWVAR 28
12161: PUSH
12162: LD_INT 12
12164: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12165: CALL_OW 44
12169: PPUSH
12170: LD_INT 299
12172: PPUSH
12173: LD_INT 229
12175: PPUSH
12176: LD_INT 10
12178: PPUSH
12179: LD_INT 0
12181: PPUSH
12182: CALL_OW 50
// end ;
12186: GO 12150
12188: POP
12189: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12190: LD_EXP 74
12194: PPUSH
12195: LD_INT 259
12197: PPUSH
12198: LD_INT 235
12200: PPUSH
12201: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12205: LD_EXP 74
12209: PPUSH
12210: LD_INT 262
12212: PPUSH
12213: LD_INT 235
12215: PPUSH
12216: CALL_OW 178
// if Simms then
12220: LD_EXP 75
12224: IFFALSE 12255
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12226: LD_EXP 75
12230: PPUSH
12231: LD_INT 262
12233: PPUSH
12234: LD_INT 235
12236: PPUSH
12237: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12241: LD_EXP 75
12245: PPUSH
12246: LD_EXP 74
12250: PPUSH
12251: CALL_OW 179
// end ; end ;
12255: LD_VAR 0 1
12259: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12260: LD_EXP 31
12264: PUSH
12265: LD_EXP 23
12269: NOT
12270: AND
12271: IFFALSE 12447
12273: GO 12275
12275: DISABLE
12276: LD_INT 0
12278: PPUSH
12279: PPUSH
12280: PPUSH
// begin enable ;
12281: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12282: LD_ADDR_VAR 0 2
12286: PUSH
12287: LD_INT 81
12289: PUSH
12290: LD_INT 7
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: LD_INT 2
12299: PUSH
12300: LD_INT 32
12302: PUSH
12303: LD_INT 3
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: PUSH
12310: LD_INT 30
12312: PUSH
12313: LD_INT 30
12315: PUSH
12316: EMPTY
12317: LIST
12318: LIST
12319: PUSH
12320: LD_INT 30
12322: PUSH
12323: LD_INT 28
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 34
12332: PUSH
12333: LD_INT 49
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 34
12342: PUSH
12343: LD_INT 10
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 34
12352: PUSH
12353: LD_INT 8
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: LIST
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 69
12377: ST_TO_ADDR
// if not tmp then
12378: LD_VAR 0 2
12382: NOT
12383: IFFALSE 12387
// exit ;
12385: GO 12447
// target := tmp [ rand ( 1 , tmp ) ] ;
12387: LD_ADDR_VAR 0 3
12391: PUSH
12392: LD_VAR 0 2
12396: PUSH
12397: LD_INT 1
12399: PPUSH
12400: LD_VAR 0 2
12404: PPUSH
12405: CALL_OW 12
12409: ARRAY
12410: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12411: LD_VAR 0 3
12415: PPUSH
12416: CALL_OW 255
12420: PUSH
12421: LD_INT 1
12423: EQUAL
12424: IFFALSE 12435
// CenterNowOnUnits ( target ) ;
12426: LD_VAR 0 3
12430: PPUSH
12431: CALL_OW 87
// SetLives ( target , 0 ) ;
12435: LD_VAR 0 3
12439: PPUSH
12440: LD_INT 0
12442: PPUSH
12443: CALL_OW 234
// end ;
12447: PPOPN 3
12449: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12450: LD_EXP 23
12454: NOT
12455: PUSH
12456: LD_EXP 31
12460: AND
12461: IFFALSE 12987
12463: GO 12465
12465: DISABLE
12466: LD_INT 0
12468: PPUSH
12469: PPUSH
12470: PPUSH
// begin uc_side := 7 ;
12471: LD_ADDR_OWVAR 20
12475: PUSH
12476: LD_INT 7
12478: ST_TO_ADDR
// uc_nation := 1 ;
12479: LD_ADDR_OWVAR 21
12483: PUSH
12484: LD_INT 1
12486: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12487: LD_ADDR_VAR 0 3
12491: PUSH
12492: LD_INT 125
12494: PUSH
12495: LD_INT 163
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PUSH
12502: LD_INT 185
12504: PUSH
12505: LD_INT 168
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 111
12514: PUSH
12515: LD_INT 97
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL 102556 0 1
12531: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12532: LD_ADDR_EXP 91
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// for i = 1 to Difficulty do
12539: LD_ADDR_VAR 0 1
12543: PUSH
12544: DOUBLE
12545: LD_INT 1
12547: DEC
12548: ST_TO_ADDR
12549: LD_OWVAR 67
12553: PUSH
12554: FOR_TO
12555: IFFALSE 12713
// begin InitHc ;
12557: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12561: LD_INT 0
12563: PPUSH
12564: LD_INT 8
12566: PPUSH
12567: CALL_OW 381
// un := CreateHuman ;
12571: LD_ADDR_VAR 0 2
12575: PUSH
12576: CALL_OW 44
12580: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12581: LD_VAR 0 2
12585: PPUSH
12586: LD_INT 258
12588: PPUSH
12589: LD_INT 267
12591: PPUSH
12592: LD_INT 4
12594: PPUSH
12595: LD_INT 0
12597: PPUSH
12598: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12602: LD_ADDR_EXP 91
12606: PUSH
12607: LD_EXP 91
12611: PUSH
12612: LD_VAR 0 2
12616: UNION
12617: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12618: LD_VAR 0 2
12622: PPUSH
12623: LD_VAR 0 3
12627: PUSH
12628: LD_VAR 0 1
12632: ARRAY
12633: PUSH
12634: LD_INT 1
12636: ARRAY
12637: PPUSH
12638: LD_VAR 0 3
12642: PUSH
12643: LD_VAR 0 1
12647: ARRAY
12648: PUSH
12649: LD_INT 2
12651: ARRAY
12652: PPUSH
12653: LD_INT 4
12655: PPUSH
12656: LD_INT 1
12658: PPUSH
12659: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12663: LD_VAR 0 2
12667: PPUSH
12668: LD_VAR 0 3
12672: PUSH
12673: LD_VAR 0 1
12677: ARRAY
12678: PUSH
12679: LD_INT 1
12681: ARRAY
12682: PPUSH
12683: LD_VAR 0 3
12687: PUSH
12688: LD_VAR 0 1
12692: ARRAY
12693: PUSH
12694: LD_INT 2
12696: ARRAY
12697: PPUSH
12698: CALL_OW 171
// AddComInvisible ( un ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 212
// end ;
12711: GO 12554
12713: POP
12714: POP
// repeat wait ( 0 0$20 ) ;
12715: LD_INT 700
12717: PPUSH
12718: CALL_OW 67
// for i in allianceSpecialForce do
12722: LD_ADDR_VAR 0 1
12726: PUSH
12727: LD_EXP 91
12731: PUSH
12732: FOR_IN
12733: IFFALSE 12972
// begin if IsInvisible ( i ) then
12735: LD_VAR 0 1
12739: PPUSH
12740: CALL_OW 571
12744: IFFALSE 12941
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12746: LD_ADDR_VAR 0 3
12750: PUSH
12751: LD_INT 22
12753: PUSH
12754: LD_INT 1
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: PUSH
12761: LD_INT 50
12763: PUSH
12764: EMPTY
12765: LIST
12766: PUSH
12767: LD_INT 56
12769: PUSH
12770: EMPTY
12771: LIST
12772: PUSH
12773: LD_INT 91
12775: PUSH
12776: LD_VAR 0 1
12780: PUSH
12781: LD_INT 25
12783: PUSH
12784: LD_INT 30
12786: PUSH
12787: LD_INT 35
12789: PUSH
12790: LD_INT 40
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: PUSH
12799: LD_OWVAR 67
12803: ARRAY
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: LD_INT 25
12815: PUSH
12816: LD_INT 1
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: LD_INT 25
12825: PUSH
12826: LD_INT 2
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PUSH
12833: LD_INT 25
12835: PUSH
12836: LD_INT 3
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 25
12845: PUSH
12846: LD_INT 4
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 25
12855: PUSH
12856: LD_INT 5
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: LD_INT 25
12865: PUSH
12866: LD_INT 8
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: PPUSH
12889: CALL_OW 69
12893: ST_TO_ADDR
// if not tmp then
12894: LD_VAR 0 3
12898: NOT
12899: IFFALSE 12903
// continue ;
12901: GO 12732
// if Prob ( 30 * Difficulty ) then
12903: LD_INT 30
12905: PUSH
12906: LD_OWVAR 67
12910: MUL
12911: PPUSH
12912: CALL_OW 13
12916: IFFALSE 12941
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12918: LD_VAR 0 3
12922: PUSH
12923: LD_INT 1
12925: PPUSH
12926: LD_VAR 0 3
12930: PPUSH
12931: CALL_OW 12
12935: ARRAY
12936: PPUSH
12937: CALL 31254 0 1
// end ; if IsDead ( i ) then
12941: LD_VAR 0 1
12945: PPUSH
12946: CALL_OW 301
12950: IFFALSE 12970
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12952: LD_ADDR_EXP 91
12956: PUSH
12957: LD_EXP 91
12961: PUSH
12962: LD_VAR 0 1
12966: DIFF
12967: ST_TO_ADDR
// continue ;
12968: GO 12732
// end ; end ;
12970: GO 12732
12972: POP
12973: POP
// until allianceDestroyed or not allianceSpecialForce ;
12974: LD_EXP 23
12978: PUSH
12979: LD_EXP 91
12983: NOT
12984: OR
12985: IFFALSE 12715
// end ;
12987: PPOPN 3
12989: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12990: LD_EXP 23
12994: NOT
12995: PUSH
12996: LD_EXP 31
13000: AND
13001: IFFALSE 13972
13003: GO 13005
13005: DISABLE
13006: LD_INT 0
13008: PPUSH
13009: PPUSH
13010: PPUSH
13011: PPUSH
// begin enable ;
13012: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13013: LD_INT 22
13015: PUSH
13016: LD_INT 7
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 30
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: EMPTY
13034: LIST
13035: LIST
13036: PPUSH
13037: CALL_OW 69
13041: NOT
13042: IFFALSE 13046
// exit ;
13044: GO 13972
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13046: LD_ADDR_VAR 0 4
13050: PUSH
13051: LD_INT 22
13053: PUSH
13054: LD_INT 7
13056: PUSH
13057: EMPTY
13058: LIST
13059: LIST
13060: PUSH
13061: LD_INT 30
13063: PUSH
13064: LD_INT 34
13066: PUSH
13067: EMPTY
13068: LIST
13069: LIST
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: ST_TO_ADDR
// if Prob ( 40 ) then
13080: LD_INT 40
13082: PPUSH
13083: CALL_OW 13
13087: IFFALSE 13214
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13089: LD_INT 1
13091: PPUSH
13092: LD_INT 5
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 2
13100: PUSH
13101: LD_INT 6
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: PUSH
13110: LD_INT 5
13112: PUSH
13113: LD_INT 3
13115: PUSH
13116: LD_INT 2
13118: PUSH
13119: LD_INT 6
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 5
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: LD_INT 2
13136: PUSH
13137: LD_INT 6
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: PUSH
13146: LD_INT 24
13148: PUSH
13149: LD_INT 3
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 45
13157: PUSH
13158: EMPTY
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 24
13166: PUSH
13167: LD_INT 3
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 47
13175: PUSH
13176: EMPTY
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: PUSH
13182: LD_INT 24
13184: PUSH
13185: LD_INT 3
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 45
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PPUSH
13208: CALL 59308 0 2
// end else
13212: GO 13337
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13214: LD_INT 1
13216: PPUSH
13217: LD_INT 24
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 3
13225: PUSH
13226: LD_INT 47
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 24
13237: PUSH
13238: LD_INT 3
13240: PUSH
13241: LD_INT 3
13243: PUSH
13244: LD_INT 47
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: LD_INT 3
13258: PUSH
13259: LD_INT 2
13261: PUSH
13262: LD_INT 9
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 3
13276: PUSH
13277: LD_INT 2
13279: PUSH
13280: LD_INT 9
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 24
13291: PUSH
13292: LD_INT 1
13294: PUSH
13295: LD_INT 3
13297: PUSH
13298: LD_INT 45
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 24
13309: PUSH
13310: LD_INT 1
13312: PUSH
13313: LD_INT 3
13315: PUSH
13316: LD_INT 45
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: LIST
13323: LIST
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL 59308 0 2
// end ; if Difficulty > 1 then
13337: LD_OWVAR 67
13341: PUSH
13342: LD_INT 1
13344: GREATER
13345: IFFALSE 13375
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13347: LD_INT 1
13349: PPUSH
13350: LD_INT 24
13352: PUSH
13353: LD_INT 3
13355: PUSH
13356: LD_INT 3
13358: PUSH
13359: LD_INT 47
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PUSH
13368: EMPTY
13369: LIST
13370: PPUSH
13371: CALL 59308 0 2
// repeat wait ( 0 0$1 ) ;
13375: LD_INT 35
13377: PPUSH
13378: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13382: LD_INT 1
13384: PPUSH
13385: LD_INT 1
13387: PPUSH
13388: CALL 60726 0 2
13392: PUSH
13393: LD_INT 6
13395: PUSH
13396: LD_INT 7
13398: PUSH
13399: LD_INT 7
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: PUSH
13411: LD_OWVAR 67
13415: ARRAY
13416: GREATEREQUAL
13417: IFFALSE 13375
// wait ( 0 0$40 ) ;
13419: LD_INT 1400
13421: PPUSH
13422: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13426: LD_ADDR_VAR 0 2
13430: PUSH
13431: LD_INT 1
13433: PPUSH
13434: LD_INT 1
13436: PPUSH
13437: CALL 60726 0 2
13441: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13442: LD_ADDR_EXP 135
13446: PUSH
13447: LD_EXP 135
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: LD_EXP 135
13459: PUSH
13460: LD_INT 1
13462: ARRAY
13463: PUSH
13464: LD_VAR 0 2
13468: DIFF
13469: PPUSH
13470: CALL_OW 1
13474: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13475: LD_ADDR_VAR 0 3
13479: PUSH
13480: LD_INT 0
13482: PPUSH
13483: LD_INT 1
13485: PPUSH
13486: CALL_OW 12
13490: ST_TO_ADDR
// if target then
13491: LD_VAR 0 3
13495: IFFALSE 13661
// begin for i in tmp do
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: FOR_IN
13508: IFFALSE 13533
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13510: LD_VAR 0 1
13514: PPUSH
13515: LD_INT 179
13517: PPUSH
13518: LD_INT 209
13520: PPUSH
13521: LD_INT 8
13523: PPUSH
13524: LD_INT 1
13526: PPUSH
13527: CALL_OW 483
13531: GO 13507
13533: POP
13534: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13535: LD_ADDR_VAR 0 2
13539: PUSH
13540: LD_VAR 0 2
13544: PPUSH
13545: LD_INT 24
13547: PUSH
13548: LD_INT 250
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 72
13559: ST_TO_ADDR
// for i in tmp do
13560: LD_ADDR_VAR 0 1
13564: PUSH
13565: LD_VAR 0 2
13569: PUSH
13570: FOR_IN
13571: IFFALSE 13611
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13573: LD_VAR 0 1
13577: PPUSH
13578: LD_INT 179
13580: PPUSH
13581: LD_INT 209
13583: PPUSH
13584: CALL_OW 297
13588: PUSH
13589: LD_INT 9
13591: GREATER
13592: IFFALSE 13609
// ComMoveXY ( i , 179 , 209 ) ;
13594: LD_VAR 0 1
13598: PPUSH
13599: LD_INT 179
13601: PPUSH
13602: LD_INT 209
13604: PPUSH
13605: CALL_OW 111
13609: GO 13570
13611: POP
13612: POP
// wait ( 0 0$1 ) ;
13613: LD_INT 35
13615: PPUSH
13616: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13620: LD_VAR 0 2
13624: PPUSH
13625: LD_INT 92
13627: PUSH
13628: LD_INT 179
13630: PUSH
13631: LD_INT 209
13633: PUSH
13634: LD_INT 9
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: PPUSH
13643: CALL_OW 72
13647: PUSH
13648: LD_VAR 0 2
13652: PUSH
13653: LD_INT 1
13655: MINUS
13656: GREATEREQUAL
13657: IFFALSE 13535
// end else
13659: GO 13823
// begin for i in tmp do
13661: LD_ADDR_VAR 0 1
13665: PUSH
13666: LD_VAR 0 2
13670: PUSH
13671: FOR_IN
13672: IFFALSE 13697
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13674: LD_VAR 0 1
13678: PPUSH
13679: LD_INT 285
13681: PPUSH
13682: LD_INT 163
13684: PPUSH
13685: LD_INT 8
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 483
13695: GO 13671
13697: POP
13698: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13699: LD_ADDR_VAR 0 2
13703: PUSH
13704: LD_VAR 0 2
13708: PPUSH
13709: LD_INT 24
13711: PUSH
13712: LD_INT 250
13714: PUSH
13715: EMPTY
13716: LIST
13717: LIST
13718: PPUSH
13719: CALL_OW 72
13723: ST_TO_ADDR
// for i in tmp do
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_VAR 0 2
13733: PUSH
13734: FOR_IN
13735: IFFALSE 13775
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13737: LD_VAR 0 1
13741: PPUSH
13742: LD_INT 285
13744: PPUSH
13745: LD_INT 163
13747: PPUSH
13748: CALL_OW 297
13752: PUSH
13753: LD_INT 9
13755: GREATER
13756: IFFALSE 13773
// ComMoveXY ( i , 285 , 163 ) ;
13758: LD_VAR 0 1
13762: PPUSH
13763: LD_INT 285
13765: PPUSH
13766: LD_INT 163
13768: PPUSH
13769: CALL_OW 111
13773: GO 13734
13775: POP
13776: POP
// wait ( 0 0$1 ) ;
13777: LD_INT 35
13779: PPUSH
13780: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13784: LD_VAR 0 2
13788: PPUSH
13789: LD_INT 92
13791: PUSH
13792: LD_INT 285
13794: PUSH
13795: LD_INT 163
13797: PUSH
13798: LD_INT 9
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: PPUSH
13807: CALL_OW 72
13811: PUSH
13812: LD_VAR 0 2
13816: PUSH
13817: LD_INT 1
13819: MINUS
13820: GREATEREQUAL
13821: IFFALSE 13699
// end ; repeat wait ( 0 0$1 ) ;
13823: LD_INT 35
13825: PPUSH
13826: CALL_OW 67
// for i in tmp do
13830: LD_ADDR_VAR 0 1
13834: PUSH
13835: LD_VAR 0 2
13839: PUSH
13840: FOR_IN
13841: IFFALSE 13963
// if GetLives ( i ) > 251 then
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 256
13852: PUSH
13853: LD_INT 251
13855: GREATER
13856: IFFALSE 13945
// begin if GetWeapon ( i ) = ru_time_lapser then
13858: LD_VAR 0 1
13862: PPUSH
13863: CALL_OW 264
13867: PUSH
13868: LD_INT 49
13870: EQUAL
13871: IFFALSE 13909
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_INT 81
13880: PUSH
13881: LD_INT 7
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 69
13892: PPUSH
13893: LD_VAR 0 1
13897: PPUSH
13898: CALL_OW 74
13902: PPUSH
13903: CALL_OW 112
13907: GO 13943
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13909: LD_VAR 0 1
13913: PPUSH
13914: LD_INT 81
13916: PUSH
13917: LD_INT 7
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PPUSH
13924: CALL_OW 69
13928: PPUSH
13929: LD_VAR 0 1
13933: PPUSH
13934: CALL_OW 74
13938: PPUSH
13939: CALL_OW 115
// end else
13943: GO 13961
// tmp := tmp diff i ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_VAR 0 2
13954: PUSH
13955: LD_VAR 0 1
13959: DIFF
13960: ST_TO_ADDR
13961: GO 13840
13963: POP
13964: POP
// until not tmp ;
13965: LD_VAR 0 2
13969: NOT
13970: IFFALSE 13823
// end ; end_of_file
13972: PPOPN 4
13974: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13975: LD_INT 0
13977: PPUSH
13978: PPUSH
13979: PPUSH
13980: PPUSH
// missionStage := 13 ;
13981: LD_ADDR_EXP 15
13985: PUSH
13986: LD_INT 13
13988: ST_TO_ADDR
// uc_side := 2 ;
13989: LD_ADDR_OWVAR 20
13993: PUSH
13994: LD_INT 2
13996: ST_TO_ADDR
// uc_nation := 2 ;
13997: LD_ADDR_OWVAR 21
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14005: LD_ADDR_EXP 92
14009: PUSH
14010: LD_STRING Omar
14012: PPUSH
14013: CALL_OW 25
14017: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14018: LD_EXP 92
14022: PPUSH
14023: LD_INT 4
14025: PPUSH
14026: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14030: LD_EXP 92
14034: PPUSH
14035: LD_INT 242
14037: PPUSH
14038: LD_INT 75
14040: PPUSH
14041: LD_INT 0
14043: PPUSH
14044: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14048: LD_ADDR_EXP 93
14052: PUSH
14053: LD_STRING Heike
14055: PPUSH
14056: CALL_OW 25
14060: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14061: LD_INT 14
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 1
14069: PPUSH
14070: LD_INT 27
14072: PPUSH
14073: LD_INT 100
14075: PPUSH
14076: CALL 70578 0 5
// veh := CreateVehicle ;
14080: LD_ADDR_VAR 0 3
14084: PUSH
14085: CALL_OW 45
14089: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14090: LD_VAR 0 3
14094: PPUSH
14095: LD_INT 1
14097: PPUSH
14098: CALL_OW 242
// SetDir ( veh , 4 ) ;
14102: LD_VAR 0 3
14106: PPUSH
14107: LD_INT 4
14109: PPUSH
14110: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14114: LD_VAR 0 3
14118: PPUSH
14119: LD_INT 241
14121: PPUSH
14122: LD_INT 72
14124: PPUSH
14125: LD_INT 0
14127: PPUSH
14128: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14132: LD_EXP 93
14136: PPUSH
14137: LD_VAR 0 3
14141: PPUSH
14142: CALL_OW 52
// if KhatamStatus then
14146: LD_EXP 8
14150: IFFALSE 14201
// begin Khatam := NewCharacter ( Khatam ) ;
14152: LD_ADDR_EXP 94
14156: PUSH
14157: LD_STRING Khatam
14159: PPUSH
14160: CALL_OW 25
14164: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14165: LD_EXP 94
14169: PPUSH
14170: LD_INT 245
14172: PPUSH
14173: LD_INT 78
14175: PPUSH
14176: LD_INT 3
14178: PPUSH
14179: LD_INT 0
14181: PPUSH
14182: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14186: LD_EXP 94
14190: PPUSH
14191: LD_INT 4
14193: PPUSH
14194: LD_INT 10
14196: PPUSH
14197: CALL_OW 237
// end ; for i = 1 to Difficulty do
14201: LD_ADDR_VAR 0 2
14205: PUSH
14206: DOUBLE
14207: LD_INT 1
14209: DEC
14210: ST_TO_ADDR
14211: LD_OWVAR 67
14215: PUSH
14216: FOR_TO
14217: IFFALSE 14283
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14219: LD_INT 0
14221: PPUSH
14222: LD_INT 7
14224: PUSH
14225: LD_OWVAR 67
14229: PLUS
14230: PPUSH
14231: CALL_OW 384
// un := CreateHuman ;
14235: LD_ADDR_VAR 0 4
14239: PUSH
14240: CALL_OW 44
14244: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14245: LD_VAR 0 4
14249: PPUSH
14250: LD_INT 28
14252: PUSH
14253: LD_INT 29
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: PUSH
14260: LD_VAR 0 2
14264: PUSH
14265: LD_INT 2
14267: MOD
14268: PUSH
14269: LD_INT 1
14271: PLUS
14272: ARRAY
14273: PPUSH
14274: LD_INT 0
14276: PPUSH
14277: CALL_OW 49
// end ;
14281: GO 14216
14283: POP
14284: POP
// for i = 1 to 6 do
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: DOUBLE
14291: LD_INT 1
14293: DEC
14294: ST_TO_ADDR
14295: LD_INT 6
14297: PUSH
14298: FOR_TO
14299: IFFALSE 14344
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14301: LD_INT 0
14303: PPUSH
14304: LD_INT 7
14306: PUSH
14307: LD_OWVAR 67
14311: PLUS
14312: PPUSH
14313: CALL_OW 381
// un := CreateHuman ;
14317: LD_ADDR_VAR 0 4
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14327: LD_VAR 0 4
14331: PPUSH
14332: LD_INT 28
14334: PPUSH
14335: LD_INT 0
14337: PPUSH
14338: CALL_OW 49
// end ;
14342: GO 14298
14344: POP
14345: POP
// for i = 1 to 3 do
14346: LD_ADDR_VAR 0 2
14350: PUSH
14351: DOUBLE
14352: LD_INT 1
14354: DEC
14355: ST_TO_ADDR
14356: LD_INT 3
14358: PUSH
14359: FOR_TO
14360: IFFALSE 14408
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14362: LD_INT 0
14364: PPUSH
14365: LD_INT 8
14367: PPUSH
14368: LD_INT 7
14370: PUSH
14371: LD_OWVAR 67
14375: PLUS
14376: PPUSH
14377: CALL_OW 380
// un := CreateHuman ;
14381: LD_ADDR_VAR 0 4
14385: PUSH
14386: CALL_OW 44
14390: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14391: LD_VAR 0 4
14395: PPUSH
14396: LD_INT 28
14398: PPUSH
14399: LD_INT 0
14401: PPUSH
14402: CALL_OW 49
// end ;
14406: GO 14359
14408: POP
14409: POP
// for i = 1 to 3 do
14410: LD_ADDR_VAR 0 2
14414: PUSH
14415: DOUBLE
14416: LD_INT 1
14418: DEC
14419: ST_TO_ADDR
14420: LD_INT 3
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14514
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 2
14431: PPUSH
14432: LD_INT 1
14434: PPUSH
14435: LD_INT 28
14437: PPUSH
14438: LD_INT 80
14440: PPUSH
14441: CALL 70578 0 5
// veh := CreateVehicle ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: CALL_OW 45
14454: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14455: LD_VAR 0 3
14459: PPUSH
14460: LD_INT 3
14462: PPUSH
14463: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14467: LD_VAR 0 3
14471: PPUSH
14472: LD_INT 29
14474: PPUSH
14475: LD_INT 0
14477: PPUSH
14478: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14482: LD_INT 0
14484: PPUSH
14485: LD_INT 7
14487: PUSH
14488: LD_OWVAR 67
14492: PLUS
14493: PPUSH
14494: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14498: CALL_OW 44
14502: PPUSH
14503: LD_VAR 0 3
14507: PPUSH
14508: CALL_OW 52
// end ;
14512: GO 14423
14514: POP
14515: POP
// for i = 1 to 5 + Difficulty do
14516: LD_ADDR_VAR 0 2
14520: PUSH
14521: DOUBLE
14522: LD_INT 1
14524: DEC
14525: ST_TO_ADDR
14526: LD_INT 5
14528: PUSH
14529: LD_OWVAR 67
14533: PLUS
14534: PUSH
14535: FOR_TO
14536: IFFALSE 14663
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14538: LD_INT 14
14540: PPUSH
14541: LD_INT 1
14543: PPUSH
14544: LD_INT 3
14546: PPUSH
14547: CALL_OW 12
14551: PPUSH
14552: LD_INT 1
14554: PPUSH
14555: LD_INT 28
14557: PUSH
14558: LD_INT 26
14560: PUSH
14561: LD_INT 27
14563: PUSH
14564: LD_INT 25
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: PUSH
14573: LD_VAR 0 2
14577: PUSH
14578: LD_INT 4
14580: MOD
14581: PUSH
14582: LD_INT 1
14584: PLUS
14585: ARRAY
14586: PPUSH
14587: LD_INT 80
14589: PPUSH
14590: CALL 70578 0 5
// veh := CreateVehicle ;
14594: LD_ADDR_VAR 0 3
14598: PUSH
14599: CALL_OW 45
14603: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14604: LD_VAR 0 3
14608: PPUSH
14609: LD_INT 4
14611: PPUSH
14612: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14616: LD_VAR 0 3
14620: PPUSH
14621: LD_INT 28
14623: PPUSH
14624: LD_INT 0
14626: PPUSH
14627: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14631: LD_INT 0
14633: PPUSH
14634: LD_INT 7
14636: PUSH
14637: LD_OWVAR 67
14641: PLUS
14642: PPUSH
14643: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14647: CALL_OW 44
14651: PPUSH
14652: LD_VAR 0 3
14656: PPUSH
14657: CALL_OW 52
// end ;
14661: GO 14535
14663: POP
14664: POP
// for i = 1 to 3 do
14665: LD_ADDR_VAR 0 2
14669: PUSH
14670: DOUBLE
14671: LD_INT 1
14673: DEC
14674: ST_TO_ADDR
14675: LD_INT 3
14677: PUSH
14678: FOR_TO
14679: IFFALSE 14739
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14681: LD_INT 14
14683: PPUSH
14684: LD_INT 3
14686: PPUSH
14687: LD_INT 5
14689: PPUSH
14690: LD_INT 29
14692: PPUSH
14693: LD_INT 80
14695: PPUSH
14696: CALL 70578 0 5
// veh := CreateVehicle ;
14700: LD_ADDR_VAR 0 3
14704: PUSH
14705: CALL_OW 45
14709: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14710: LD_VAR 0 3
14714: PPUSH
14715: LD_INT 4
14717: PPUSH
14718: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14722: LD_VAR 0 3
14726: PPUSH
14727: LD_INT 28
14729: PPUSH
14730: LD_INT 0
14732: PPUSH
14733: CALL_OW 49
// end ;
14737: GO 14678
14739: POP
14740: POP
// end ;
14741: LD_VAR 0 1
14745: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14746: LD_INT 22
14748: PUSH
14749: LD_INT 2
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: IFFALSE 15060
14762: GO 14764
14764: DISABLE
14765: LD_INT 0
14767: PPUSH
14768: PPUSH
14769: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14770: LD_ADDR_VAR 0 3
14774: PUSH
14775: LD_INT 22
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: LD_INT 25
14787: PUSH
14788: LD_INT 4
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: PPUSH
14799: CALL_OW 69
14803: PUSH
14804: LD_EXP 94
14808: DIFF
14809: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14810: LD_ADDR_VAR 0 2
14814: PUSH
14815: LD_INT 22
14817: PUSH
14818: LD_INT 2
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PPUSH
14825: CALL_OW 69
14829: PUSH
14830: LD_EXP 94
14834: PUSH
14835: LD_VAR 0 3
14839: UNION
14840: DIFF
14841: ST_TO_ADDR
// if Khatam then
14842: LD_EXP 94
14846: IFFALSE 14863
// ComMoveXY ( Khatam , 211 , 92 ) ;
14848: LD_EXP 94
14852: PPUSH
14853: LD_INT 211
14855: PPUSH
14856: LD_INT 92
14858: PPUSH
14859: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14863: LD_INT 197
14865: PPUSH
14866: LD_INT 80
14868: PPUSH
14869: LD_INT 2
14871: PPUSH
14872: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14876: LD_INT 213
14878: PPUSH
14879: LD_INT 90
14881: PPUSH
14882: LD_INT 2
14884: PPUSH
14885: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14889: LD_INT 215
14891: PPUSH
14892: LD_INT 129
14894: PPUSH
14895: LD_INT 2
14897: PPUSH
14898: CALL_OW 441
// if sci then
14902: LD_VAR 0 3
14906: IFFALSE 14927
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14908: LD_VAR 0 3
14912: PUSH
14913: LD_INT 1
14915: ARRAY
14916: PPUSH
14917: LD_INT 197
14919: PPUSH
14920: LD_INT 80
14922: PPUSH
14923: CALL_OW 158
// if sci > 1 then
14927: LD_VAR 0 3
14931: PUSH
14932: LD_INT 1
14934: GREATER
14935: IFFALSE 14956
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14937: LD_VAR 0 3
14941: PUSH
14942: LD_INT 2
14944: ARRAY
14945: PPUSH
14946: LD_INT 213
14948: PPUSH
14949: LD_INT 90
14951: PPUSH
14952: CALL_OW 158
// if sci > 2 then
14956: LD_VAR 0 3
14960: PUSH
14961: LD_INT 2
14963: GREATER
14964: IFFALSE 14985
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14966: LD_VAR 0 3
14970: PUSH
14971: LD_INT 3
14973: ARRAY
14974: PPUSH
14975: LD_INT 215
14977: PPUSH
14978: LD_INT 129
14980: PPUSH
14981: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14985: LD_INT 35
14987: PPUSH
14988: CALL_OW 67
// for i in tmp do
14992: LD_ADDR_VAR 0 1
14996: PUSH
14997: LD_VAR 0 2
15001: PUSH
15002: FOR_IN
15003: IFFALSE 15041
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 81
15012: PUSH
15013: LD_INT 2
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: PPUSH
15020: CALL_OW 69
15024: PPUSH
15025: LD_VAR 0 1
15029: PPUSH
15030: CALL_OW 74
15034: PPUSH
15035: CALL_OW 115
15039: GO 15002
15041: POP
15042: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15043: LD_INT 22
15045: PUSH
15046: LD_INT 2
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PPUSH
15053: CALL_OW 69
15057: NOT
15058: IFFALSE 14985
// end ; end_of_file
15060: PPOPN 3
15062: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15063: LD_INT 0
15065: PPUSH
15066: PPUSH
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
15072: PPUSH
15073: PPUSH
// Video ( true ) ;
15074: LD_INT 1
15076: PPUSH
15077: CALL 102423 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15081: LD_ADDR_VAR 0 5
15085: PUSH
15086: LD_INT 7
15088: PPUSH
15089: LD_INT 0
15091: PPUSH
15092: CALL_OW 517
15096: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15097: LD_ADDR_VAR 0 2
15101: PUSH
15102: DOUBLE
15103: LD_INT 1
15105: DEC
15106: ST_TO_ADDR
15107: LD_VAR 0 5
15111: PUSH
15112: LD_INT 1
15114: ARRAY
15115: PUSH
15116: FOR_TO
15117: IFFALSE 15162
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15119: LD_VAR 0 5
15123: PUSH
15124: LD_INT 1
15126: ARRAY
15127: PUSH
15128: LD_VAR 0 2
15132: ARRAY
15133: PPUSH
15134: LD_VAR 0 5
15138: PUSH
15139: LD_INT 2
15141: ARRAY
15142: PUSH
15143: LD_VAR 0 2
15147: ARRAY
15148: PPUSH
15149: LD_INT 1
15151: PPUSH
15152: LD_INT 15
15154: NEG
15155: PPUSH
15156: CALL 102337 0 4
15160: GO 15116
15162: POP
15163: POP
// CenterNowOnUnits ( Powell ) ;
15164: LD_EXP 58
15168: PPUSH
15169: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15173: LD_ADDR_VAR 0 5
15177: PUSH
15178: LD_EXP 56
15182: PUSH
15183: EMPTY
15184: LIST
15185: ST_TO_ADDR
// if GirlNewVeh then
15186: LD_EXP 57
15190: IFFALSE 15208
// tmp := tmp ^ GirlNewVeh ;
15192: LD_ADDR_VAR 0 5
15196: PUSH
15197: LD_VAR 0 5
15201: PUSH
15202: LD_EXP 57
15206: ADD
15207: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15208: LD_VAR 0 5
15212: PPUSH
15213: LD_INT 60
15215: PPUSH
15216: LD_INT 109
15218: PPUSH
15219: CALL_OW 111
// if KappaStatus then
15223: LD_EXP 2
15227: IFFALSE 15279
// begin Say ( JMM , D1nT-JMM-1 ) ;
15229: LD_EXP 39
15233: PPUSH
15234: LD_STRING D1nT-JMM-1
15236: PPUSH
15237: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15241: LD_EXP 58
15245: PPUSH
15246: LD_STRING D1T-Pow-1
15248: PPUSH
15249: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15253: LD_EXP 39
15257: PPUSH
15258: LD_STRING D1T-JMM-2
15260: PPUSH
15261: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15265: LD_EXP 58
15269: PPUSH
15270: LD_STRING D1T-Pow-2
15272: PPUSH
15273: CALL_OW 88
// end else
15277: GO 15485
// if JMMGirlStatus then
15279: LD_EXP 6
15283: IFFALSE 15428
// begin Say ( JMM , D1T-JMM-1 ) ;
15285: LD_EXP 39
15289: PPUSH
15290: LD_STRING D1T-JMM-1
15292: PPUSH
15293: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15297: LD_EXP 58
15301: PPUSH
15302: LD_STRING D1T-Pow-1
15304: PPUSH
15305: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15309: LD_EXP 39
15313: PPUSH
15314: LD_STRING D1T-JMM-3
15316: PPUSH
15317: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15321: LD_EXP 58
15325: PPUSH
15326: LD_STRING D1T-Pow-3
15328: PPUSH
15329: CALL_OW 88
// if JMMGirl then
15333: LD_EXP 7
15337: IFFALSE 15426
// begin case JMMGirl of 1 :
15339: LD_EXP 7
15343: PUSH
15344: LD_INT 1
15346: DOUBLE
15347: EQUAL
15348: IFTRUE 15352
15350: GO 15367
15352: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15353: LD_EXP 40
15357: PPUSH
15358: LD_STRING D1T-Joan-3
15360: PPUSH
15361: CALL_OW 88
15365: GO 15414
15367: LD_INT 2
15369: DOUBLE
15370: EQUAL
15371: IFTRUE 15375
15373: GO 15390
15375: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15376: LD_EXP 42
15380: PPUSH
15381: LD_STRING D1T-Lisa-3
15383: PPUSH
15384: CALL_OW 88
15388: GO 15414
15390: LD_INT 3
15392: DOUBLE
15393: EQUAL
15394: IFTRUE 15398
15396: GO 15413
15398: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15399: LD_EXP 54
15403: PPUSH
15404: LD_STRING D1T-Con-3
15406: PPUSH
15407: CALL_OW 88
15411: GO 15414
15413: POP
// Say ( Powell , D1T-Pow-4 ) ;
15414: LD_EXP 58
15418: PPUSH
15419: LD_STRING D1T-Pow-4
15421: PPUSH
15422: CALL_OW 88
// end ; end else
15426: GO 15485
// if not FastEnd then
15428: LD_EXP 11
15432: NOT
15433: IFFALSE 15461
// begin Say ( JMM , D1T-JMM-4 ) ;
15435: LD_EXP 39
15439: PPUSH
15440: LD_STRING D1T-JMM-4
15442: PPUSH
15443: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15447: LD_EXP 58
15451: PPUSH
15452: LD_STRING D1T-Pow-5
15454: PPUSH
15455: CALL_OW 88
// end else
15459: GO 15485
// begin Say ( JMM , D1nT-JMM-1 ) ;
15461: LD_EXP 39
15465: PPUSH
15466: LD_STRING D1nT-JMM-1
15468: PPUSH
15469: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15473: LD_EXP 58
15477: PPUSH
15478: LD_STRING D1nT-Pow-1
15480: PPUSH
15481: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15485: LD_INT 35
15487: PPUSH
15488: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15492: LD_EXP 56
15496: PPUSH
15497: CALL_OW 314
15501: NOT
15502: IFFALSE 15485
// ComExitVehicle ( JMM ) ;
15504: LD_EXP 39
15508: PPUSH
15509: CALL_OW 121
// wait ( 3 ) ;
15513: LD_INT 3
15515: PPUSH
15516: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15520: LD_EXP 39
15524: PPUSH
15525: LD_INT 60
15527: PPUSH
15528: LD_INT 94
15530: PPUSH
15531: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15535: LD_EXP 39
15539: PPUSH
15540: LD_EXP 58
15544: PPUSH
15545: CALL_OW 179
// if Joan then
15549: LD_EXP 40
15553: IFFALSE 15607
// begin ComExitVehicle ( Joan ) ;
15555: LD_EXP 40
15559: PPUSH
15560: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15564: LD_EXP 40
15568: PPUSH
15569: LD_INT 35
15571: PPUSH
15572: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15576: LD_EXP 40
15580: PPUSH
15581: LD_INT 65
15583: PPUSH
15584: LD_INT 104
15586: PPUSH
15587: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15591: LD_EXP 40
15595: PPUSH
15596: LD_EXP 39
15600: PPUSH
15601: CALL_OW 179
// end else
15605: GO 15741
// if Lisa and JMMGirl = 2 then
15607: LD_EXP 42
15611: PUSH
15612: LD_EXP 7
15616: PUSH
15617: LD_INT 2
15619: EQUAL
15620: AND
15621: IFFALSE 15675
// begin ComExitVehicle ( Lisa ) ;
15623: LD_EXP 42
15627: PPUSH
15628: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15632: LD_EXP 42
15636: PPUSH
15637: LD_INT 35
15639: PPUSH
15640: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15644: LD_EXP 42
15648: PPUSH
15649: LD_INT 65
15651: PPUSH
15652: LD_INT 104
15654: PPUSH
15655: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15659: LD_EXP 42
15663: PPUSH
15664: LD_EXP 39
15668: PPUSH
15669: CALL_OW 179
// end else
15673: GO 15741
// if Connie and JMMGirl = 3 then
15675: LD_EXP 54
15679: PUSH
15680: LD_EXP 7
15684: PUSH
15685: LD_INT 3
15687: EQUAL
15688: AND
15689: IFFALSE 15741
// begin ComExitVehicle ( Connie ) ;
15691: LD_EXP 54
15695: PPUSH
15696: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15700: LD_EXP 54
15704: PPUSH
15705: LD_INT 35
15707: PPUSH
15708: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15712: LD_EXP 54
15716: PPUSH
15717: LD_INT 65
15719: PPUSH
15720: LD_INT 104
15722: PPUSH
15723: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15727: LD_EXP 54
15731: PPUSH
15732: LD_EXP 39
15736: PPUSH
15737: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15741: LD_INT 35
15743: PPUSH
15744: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15748: LD_EXP 39
15752: PPUSH
15753: LD_EXP 58
15757: PPUSH
15758: CALL_OW 296
15762: PUSH
15763: LD_INT 6
15765: LESS
15766: IFFALSE 15741
// wait ( 0 0$0.5 ) ;
15768: LD_INT 18
15770: PPUSH
15771: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15775: LD_EXP 39
15779: PPUSH
15780: LD_STRING D1-JMM-1
15782: PPUSH
15783: CALL_OW 88
// async ;
15787: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15788: LD_EXP 58
15792: PPUSH
15793: LD_STRING D1-Pow-1
15795: PPUSH
15796: CALL_OW 88
// if not dialogue_skipped then
15800: LD_OWVAR 59
15804: NOT
15805: IFFALSE 15814
// wait ( 0 0$2 ) ;
15807: LD_INT 70
15809: PPUSH
15810: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15814: LD_INT 170
15816: PPUSH
15817: LD_INT 99
15819: PPUSH
15820: LD_INT 1
15822: PPUSH
15823: LD_INT 6
15825: NEG
15826: PPUSH
15827: CALL 102337 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15831: LD_INT 174
15833: PPUSH
15834: LD_INT 115
15836: PPUSH
15837: LD_INT 1
15839: PPUSH
15840: LD_INT 6
15842: NEG
15843: PPUSH
15844: CALL 102337 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15848: LD_INT 169
15850: PPUSH
15851: LD_INT 71
15853: PPUSH
15854: LD_INT 1
15856: PPUSH
15857: LD_INT 6
15859: NEG
15860: PPUSH
15861: CALL 102337 0 4
// if not dialogue_skipped then
15865: LD_OWVAR 59
15869: NOT
15870: IFFALSE 15889
// begin CenterOnXY ( 170 , 99 ) ;
15872: LD_INT 170
15874: PPUSH
15875: LD_INT 99
15877: PPUSH
15878: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15882: LD_INT 80
15884: PPUSH
15885: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15889: LD_INT 75
15891: PPUSH
15892: LD_INT 53
15894: PPUSH
15895: LD_INT 1
15897: PPUSH
15898: LD_INT 9
15900: NEG
15901: PPUSH
15902: CALL 102337 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15906: LD_INT 54
15908: PPUSH
15909: LD_INT 42
15911: PPUSH
15912: LD_INT 1
15914: PPUSH
15915: LD_INT 9
15917: NEG
15918: PPUSH
15919: CALL 102337 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15923: LD_INT 62
15925: PPUSH
15926: LD_INT 51
15928: PPUSH
15929: LD_INT 1
15931: PPUSH
15932: LD_INT 9
15934: NEG
15935: PPUSH
15936: CALL 102337 0 4
// if not dialogue_skipped then
15940: LD_OWVAR 59
15944: NOT
15945: IFFALSE 15964
// begin CenterOnXY ( 75 , 53 ) ;
15947: LD_INT 75
15949: PPUSH
15950: LD_INT 53
15952: PPUSH
15953: CALL_OW 84
// wait ( 0 0$4 ) ;
15957: LD_INT 140
15959: PPUSH
15960: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15964: LD_EXP 58
15968: PPUSH
15969: CALL_OW 87
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$2 ) ;
15980: LD_INT 70
15982: PPUSH
15983: CALL_OW 67
// sync ;
15987: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-2
15995: PPUSH
15996: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16000: LD_EXP 58
16004: PPUSH
16005: LD_STRING D1-Pow-2
16007: PPUSH
16008: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16012: LD_EXP 39
16016: PPUSH
16017: LD_STRING D1-JMM-3
16019: PPUSH
16020: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16024: LD_EXP 58
16028: PPUSH
16029: LD_STRING D1-Pow-3
16031: PPUSH
16032: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16036: LD_EXP 39
16040: PPUSH
16041: LD_STRING D1-JMM-4
16043: PPUSH
16044: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16048: LD_EXP 58
16052: PPUSH
16053: LD_STRING D1-Pow-4
16055: PPUSH
16056: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16060: LD_EXP 39
16064: PPUSH
16065: LD_STRING D1-JMM-5
16067: PPUSH
16068: CALL_OW 88
// async ;
16072: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16073: LD_EXP 58
16077: PPUSH
16078: LD_STRING D1-Pow-5
16080: PPUSH
16081: CALL_OW 88
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16099
// wait ( 0 0$3.6 ) ;
16092: LD_INT 126
16094: PPUSH
16095: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16099: LD_INT 134
16101: PPUSH
16102: LD_INT 210
16104: PPUSH
16105: LD_INT 1
16107: PPUSH
16108: LD_INT 11
16110: NEG
16111: PPUSH
16112: CALL 102337 0 4
// if not dialogue_skipped then
16116: LD_OWVAR 59
16120: NOT
16121: IFFALSE 16140
// begin CenterOnXY ( 134 , 210 ) ;
16123: LD_INT 134
16125: PPUSH
16126: LD_INT 210
16128: PPUSH
16129: CALL_OW 84
// wait ( 0 0$2 ) ;
16133: LD_INT 70
16135: PPUSH
16136: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16140: LD_INT 101
16142: PPUSH
16143: LD_INT 159
16145: PPUSH
16146: LD_INT 1
16148: PPUSH
16149: LD_INT 10
16151: NEG
16152: PPUSH
16153: CALL 102337 0 4
// if not dialogue_skipped then
16157: LD_OWVAR 59
16161: NOT
16162: IFFALSE 16181
// begin CenterOnXY ( 101 , 159 ) ;
16164: LD_INT 101
16166: PPUSH
16167: LD_INT 159
16169: PPUSH
16170: CALL_OW 84
// wait ( 0 0$2 ) ;
16174: LD_INT 70
16176: PPUSH
16177: CALL_OW 67
// end ; sync ;
16181: SYNC
// CenterNowOnUnits ( Powell ) ;
16182: LD_EXP 58
16186: PPUSH
16187: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16191: LD_ADDR_VAR 0 6
16195: PUSH
16196: LD_INT 1
16198: PUSH
16199: LD_INT 2
16201: PUSH
16202: LD_INT 3
16204: PUSH
16205: LD_INT 4
16207: PUSH
16208: LD_INT 5
16210: PUSH
16211: LD_INT 6
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: ST_TO_ADDR
// if not dialogue_skipped then
16222: LD_OWVAR 59
16226: NOT
16227: IFFALSE 16396
// begin game_speed := 4 ;
16229: LD_ADDR_OWVAR 65
16233: PUSH
16234: LD_INT 4
16236: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16237: LD_INT 210
16239: PPUSH
16240: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16244: LD_ADDR_VAR 0 7
16248: PUSH
16249: LD_STRING Q1
16251: PPUSH
16252: LD_VAR 0 6
16256: PPUSH
16257: CALL_OW 98
16261: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16262: LD_ADDR_VAR 0 7
16266: PUSH
16267: LD_STRING Q1
16269: PPUSH
16270: LD_VAR 0 6
16274: PPUSH
16275: CALL_OW 98
16279: ST_TO_ADDR
// options = options diff dec ;
16280: LD_ADDR_VAR 0 6
16284: PUSH
16285: LD_VAR 0 6
16289: PUSH
16290: LD_VAR 0 7
16294: DIFF
16295: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16296: LD_VAR 0 7
16300: PPUSH
16301: LD_VAR 0 6
16305: PPUSH
16306: CALL 17868 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16310: LD_VAR 0 7
16314: PUSH
16315: LD_INT 5
16317: PUSH
16318: LD_INT 6
16320: PUSH
16321: EMPTY
16322: LIST
16323: LIST
16324: IN
16325: PUSH
16326: LD_VAR 0 6
16330: PUSH
16331: LD_INT 2
16333: EQUAL
16334: OR
16335: IFFALSE 16262
// if not ( dec in [ 5 , 6 ] ) then
16337: LD_VAR 0 7
16341: PUSH
16342: LD_INT 5
16344: PUSH
16345: LD_INT 6
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: IN
16352: NOT
16353: IFFALSE 16396
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16355: LD_ADDR_VAR 0 7
16359: PUSH
16360: LD_STRING Q1a
16362: PPUSH
16363: LD_INT 1
16365: PUSH
16366: LD_INT 2
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PPUSH
16373: CALL_OW 98
16377: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16378: LD_VAR 0 7
16382: PUSH
16383: LD_INT 4
16385: PLUS
16386: PPUSH
16387: LD_VAR 0 6
16391: PPUSH
16392: CALL 17868 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16396: LD_INT 81
16398: PPUSH
16399: LD_INT 127
16401: PPUSH
16402: CALL_OW 84
// amount := 5 ;
16406: LD_ADDR_VAR 0 8
16410: PUSH
16411: LD_INT 5
16413: ST_TO_ADDR
// macmilan_squad := [ ] ;
16414: LD_ADDR_VAR 0 9
16418: PUSH
16419: EMPTY
16420: ST_TO_ADDR
// if vip < amount then
16421: LD_EXP 59
16425: PUSH
16426: LD_VAR 0 8
16430: LESS
16431: IFFALSE 16475
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16433: LD_ADDR_VAR 0 5
16437: PUSH
16438: LD_EXP 59
16442: PUSH
16443: LD_INT 22
16445: PUSH
16446: LD_INT 4
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: LD_INT 21
16455: PUSH
16456: LD_INT 1
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PPUSH
16467: CALL_OW 69
16471: UNION
16472: ST_TO_ADDR
16473: GO 16485
// tmp := vip ;
16475: LD_ADDR_VAR 0 5
16479: PUSH
16480: LD_EXP 59
16484: ST_TO_ADDR
// tmp := tmp diff Powell ;
16485: LD_ADDR_VAR 0 5
16489: PUSH
16490: LD_VAR 0 5
16494: PUSH
16495: LD_EXP 58
16499: DIFF
16500: ST_TO_ADDR
// if tmp < amount then
16501: LD_VAR 0 5
16505: PUSH
16506: LD_VAR 0 8
16510: LESS
16511: IFFALSE 16523
// amount := tmp ;
16513: LD_ADDR_VAR 0 8
16517: PUSH
16518: LD_VAR 0 5
16522: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16523: LD_VAR 0 5
16527: PUSH
16528: LD_INT 1
16530: ARRAY
16531: PPUSH
16532: CALL_OW 257
16536: PUSH
16537: LD_INT 2
16539: NONEQUAL
16540: IFFALSE 16602
// begin if IsInUnit ( tmp [ 1 ] ) then
16542: LD_VAR 0 5
16546: PUSH
16547: LD_INT 1
16549: ARRAY
16550: PPUSH
16551: CALL_OW 310
16555: IFFALSE 16570
// ComExitBuilding ( tmp [ 1 ] ) ;
16557: LD_VAR 0 5
16561: PUSH
16562: LD_INT 1
16564: ARRAY
16565: PPUSH
16566: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16570: LD_VAR 0 5
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: PPUSH
16579: LD_INT 387
16581: PPUSH
16582: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16586: LD_VAR 0 5
16590: PUSH
16591: LD_INT 1
16593: ARRAY
16594: PPUSH
16595: LD_INT 2
16597: PPUSH
16598: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16602: LD_EXP 39
16606: PPUSH
16607: LD_INT 82
16609: PPUSH
16610: LD_INT 129
16612: PPUSH
16613: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16617: LD_EXP 39
16621: PPUSH
16622: LD_EXP 58
16626: PPUSH
16627: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16631: LD_INT 22
16633: PUSH
16634: LD_INT 1
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PPUSH
16641: CALL_OW 69
16645: PUSH
16646: LD_EXP 39
16650: DIFF
16651: PPUSH
16652: LD_INT 84
16654: PPUSH
16655: LD_INT 128
16657: PPUSH
16658: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16662: LD_INT 22
16664: PUSH
16665: LD_INT 1
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PPUSH
16672: CALL_OW 69
16676: PUSH
16677: LD_EXP 39
16681: DIFF
16682: PPUSH
16683: LD_EXP 39
16687: PPUSH
16688: CALL_OW 179
// for i = 1 to amount do
16692: LD_ADDR_VAR 0 2
16696: PUSH
16697: DOUBLE
16698: LD_INT 1
16700: DEC
16701: ST_TO_ADDR
16702: LD_VAR 0 8
16706: PUSH
16707: FOR_TO
16708: IFFALSE 16876
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16710: LD_ADDR_VAR 0 9
16714: PUSH
16715: LD_VAR 0 9
16719: PUSH
16720: LD_VAR 0 5
16724: PUSH
16725: LD_VAR 0 2
16729: ARRAY
16730: ADD
16731: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16732: LD_VAR 0 5
16736: PUSH
16737: LD_VAR 0 2
16741: ARRAY
16742: PPUSH
16743: CALL_OW 310
16747: IFFALSE 16764
// AddComExitBuilding ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 182
// if i = 2 and JMMNewVeh then
16764: LD_VAR 0 2
16768: PUSH
16769: LD_INT 2
16771: EQUAL
16772: PUSH
16773: LD_EXP 56
16777: AND
16778: IFFALSE 16836
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16780: LD_VAR 0 5
16784: PUSH
16785: LD_VAR 0 2
16789: ARRAY
16790: PPUSH
16791: LD_EXP 56
16795: PPUSH
16796: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16800: LD_VAR 0 5
16804: PUSH
16805: LD_VAR 0 2
16809: ARRAY
16810: PPUSH
16811: LD_INT 86
16813: PPUSH
16814: LD_INT 133
16816: PPUSH
16817: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16821: LD_VAR 0 5
16825: PUSH
16826: LD_VAR 0 2
16830: ARRAY
16831: PPUSH
16832: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16836: LD_VAR 0 5
16840: PUSH
16841: LD_VAR 0 2
16845: ARRAY
16846: PPUSH
16847: LD_INT 8
16849: PPUSH
16850: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16854: LD_VAR 0 5
16858: PUSH
16859: LD_VAR 0 2
16863: ARRAY
16864: PPUSH
16865: LD_EXP 39
16869: PPUSH
16870: CALL_OW 179
// end ;
16874: GO 16707
16876: POP
16877: POP
// if GirlNewVeh then
16878: LD_EXP 57
16882: IFFALSE 16896
// SetSide ( GirlNewVeh , 4 ) ;
16884: LD_EXP 57
16888: PPUSH
16889: LD_INT 4
16891: PPUSH
16892: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16896: LD_INT 35
16898: PPUSH
16899: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16903: LD_VAR 0 9
16907: PPUSH
16908: LD_INT 95
16910: PUSH
16911: LD_INT 9
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PPUSH
16918: CALL_OW 72
16922: PUSH
16923: LD_INT 0
16925: EQUAL
16926: PUSH
16927: LD_EXP 39
16931: PPUSH
16932: LD_INT 9
16934: PPUSH
16935: CALL_OW 308
16939: NOT
16940: AND
16941: IFFALSE 16896
// wait ( 0 0$2 ) ;
16943: LD_INT 70
16945: PPUSH
16946: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16950: LD_VAR 0 9
16954: PPUSH
16955: LD_INT 1
16957: PPUSH
16958: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16962: LD_INT 21
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PUSH
16972: LD_INT 92
16974: PUSH
16975: LD_INT 83
16977: PUSH
16978: LD_INT 130
16980: PUSH
16981: LD_INT 10
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PPUSH
16994: CALL_OW 69
16998: PPUSH
16999: LD_INT 1
17001: PPUSH
17002: CALL_OW 235
// Video ( false ) ;
17006: LD_INT 0
17008: PPUSH
17009: CALL 102423 0 1
// ChangeMissionObjectives ( M1 ) ;
17013: LD_STRING M1
17015: PPUSH
17016: CALL_OW 337
// SaveForQuickRestart ;
17020: CALL_OW 22
// missionStart := true ;
17024: LD_ADDR_EXP 13
17028: PUSH
17029: LD_INT 1
17031: ST_TO_ADDR
// missionStage := 2 ;
17032: LD_ADDR_EXP 15
17036: PUSH
17037: LD_INT 2
17039: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17040: LD_INT 105
17042: PPUSH
17043: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17047: LD_ADDR_VAR 0 5
17051: PUSH
17052: LD_INT 22
17054: PUSH
17055: LD_INT 4
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: LD_INT 21
17064: PUSH
17065: LD_INT 1
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PPUSH
17076: CALL_OW 69
17080: PUSH
17081: LD_EXP 58
17085: DIFF
17086: ST_TO_ADDR
// if not tmp then
17087: LD_VAR 0 5
17091: NOT
17092: IFFALSE 17107
// tmp := [ Powell ] ;
17094: LD_ADDR_VAR 0 5
17098: PUSH
17099: LD_EXP 58
17103: PUSH
17104: EMPTY
17105: LIST
17106: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17107: LD_ADDR_EXP 116
17111: PUSH
17112: LD_EXP 116
17116: PPUSH
17117: LD_INT 4
17119: PPUSH
17120: LD_INT 22
17122: PUSH
17123: LD_INT 4
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: LD_INT 23
17132: PUSH
17133: LD_INT 1
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: PUSH
17140: LD_INT 3
17142: PUSH
17143: LD_INT 21
17145: PUSH
17146: LD_INT 2
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: PPUSH
17162: CALL_OW 69
17166: PUSH
17167: LD_EXP 58
17171: DIFF
17172: PPUSH
17173: CALL_OW 1
17177: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17178: LD_ADDR_VAR 0 4
17182: PUSH
17183: LD_INT 22
17185: PUSH
17186: LD_INT 4
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PUSH
17193: LD_INT 34
17195: PUSH
17196: LD_INT 12
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PPUSH
17207: CALL_OW 69
17211: PUSH
17212: LD_INT 1
17214: ARRAY
17215: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 310
17229: IFFALSE 17244
// ComExitBuilding ( tmp [ 1 ] ) ;
17231: LD_VAR 0 5
17235: PUSH
17236: LD_INT 1
17238: ARRAY
17239: PPUSH
17240: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17244: LD_VAR 0 5
17248: PUSH
17249: LD_INT 1
17251: ARRAY
17252: PPUSH
17253: LD_VAR 0 4
17257: PPUSH
17258: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17262: LD_VAR 0 5
17266: PUSH
17267: LD_INT 1
17269: ARRAY
17270: PPUSH
17271: LD_INT 80
17273: PPUSH
17274: LD_INT 136
17276: PPUSH
17277: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17281: LD_VAR 0 5
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17294: LD_VAR 0 5
17298: PUSH
17299: LD_INT 1
17301: ARRAY
17302: PPUSH
17303: LD_INT 59
17305: PPUSH
17306: LD_INT 112
17308: PPUSH
17309: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17313: LD_VAR 0 5
17317: PUSH
17318: LD_INT 1
17320: ARRAY
17321: PPUSH
17322: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17326: LD_EXP 40
17330: PUSH
17331: LD_EXP 40
17335: PPUSH
17336: CALL_OW 255
17340: PUSH
17341: LD_INT 1
17343: EQUAL
17344: AND
17345: IFFALSE 17371
// begin Say ( Joan , D3W-Joan-1 ) ;
17347: LD_EXP 40
17351: PPUSH
17352: LD_STRING D3W-Joan-1
17354: PPUSH
17355: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17359: LD_EXP 39
17363: PPUSH
17364: LD_STRING D3W-JMM-1
17366: PPUSH
17367: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17371: LD_EXP 42
17375: PUSH
17376: LD_EXP 42
17380: PPUSH
17381: CALL_OW 255
17385: PUSH
17386: LD_INT 1
17388: EQUAL
17389: AND
17390: PUSH
17391: LD_EXP 42
17395: PUSH
17396: LD_EXP 59
17400: IN
17401: NOT
17402: AND
17403: IFFALSE 17429
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17405: LD_EXP 42
17409: PPUSH
17410: LD_STRING D3W-Lisa-1
17412: PPUSH
17413: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17417: LD_EXP 39
17421: PPUSH
17422: LD_STRING D3W-JMM-1
17424: PPUSH
17425: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17429: LD_EXP 54
17433: PUSH
17434: LD_EXP 54
17438: PPUSH
17439: CALL_OW 255
17443: PUSH
17444: LD_INT 1
17446: EQUAL
17447: AND
17448: IFFALSE 17474
// begin Say ( Connie , D3W-Con-1 ) ;
17450: LD_EXP 54
17454: PPUSH
17455: LD_STRING D3W-Con-1
17457: PPUSH
17458: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17462: LD_EXP 39
17466: PPUSH
17467: LD_STRING D3W-JMM-1
17469: PPUSH
17470: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17474: LD_EXP 42
17478: PUSH
17479: LD_EXP 59
17483: IN
17484: PUSH
17485: LD_EXP 42
17489: PPUSH
17490: CALL_OW 255
17494: PUSH
17495: LD_INT 1
17497: EQUAL
17498: AND
17499: IFFALSE 17515
// Say ( Lisa , D3nW-Lisa-1 ) else
17501: LD_EXP 42
17505: PPUSH
17506: LD_STRING D3nW-Lisa-1
17508: PPUSH
17509: CALL_OW 88
17513: GO 17759
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17515: LD_EXP 45
17519: PUSH
17520: LD_EXP 59
17524: IN
17525: PUSH
17526: LD_EXP 45
17530: PPUSH
17531: CALL_OW 255
17535: PUSH
17536: LD_INT 1
17538: EQUAL
17539: AND
17540: IFFALSE 17556
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17542: LD_EXP 45
17546: PPUSH
17547: LD_STRING D3nW-Cyrus-1
17549: PPUSH
17550: CALL_OW 88
17554: GO 17759
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17556: LD_EXP 44
17560: PUSH
17561: LD_EXP 59
17565: IN
17566: PUSH
17567: LD_EXP 44
17571: PPUSH
17572: CALL_OW 255
17576: PUSH
17577: LD_INT 1
17579: EQUAL
17580: AND
17581: IFFALSE 17597
// Say ( Bobby , D3nW-Bobby-1 ) else
17583: LD_EXP 44
17587: PPUSH
17588: LD_STRING D3nW-Bobby-1
17590: PPUSH
17591: CALL_OW 88
17595: GO 17759
// if Gary in vip and GetSide ( Gary ) = 1 then
17597: LD_EXP 51
17601: PUSH
17602: LD_EXP 59
17606: IN
17607: PUSH
17608: LD_EXP 51
17612: PPUSH
17613: CALL_OW 255
17617: PUSH
17618: LD_INT 1
17620: EQUAL
17621: AND
17622: IFFALSE 17638
// Say ( Gary , D3nW-Gary-1 ) else
17624: LD_EXP 51
17628: PPUSH
17629: LD_STRING D3nW-Gary-1
17631: PPUSH
17632: CALL_OW 88
17636: GO 17759
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17638: LD_EXP 43
17642: PUSH
17643: LD_EXP 59
17647: IN
17648: PUSH
17649: LD_EXP 43
17653: PPUSH
17654: CALL_OW 255
17658: PUSH
17659: LD_INT 1
17661: EQUAL
17662: AND
17663: IFFALSE 17679
// Say ( Donaldson , D3nW-Don-1 ) else
17665: LD_EXP 43
17669: PPUSH
17670: LD_STRING D3nW-Don-1
17672: PPUSH
17673: CALL_OW 88
17677: GO 17759
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17679: LD_EXP 50
17683: PUSH
17684: LD_EXP 59
17688: IN
17689: PUSH
17690: LD_EXP 50
17694: PPUSH
17695: CALL_OW 255
17699: PUSH
17700: LD_INT 1
17702: EQUAL
17703: AND
17704: IFFALSE 17720
// Say ( Cornel , D3nW-Corn-1 ) else
17706: LD_EXP 50
17710: PPUSH
17711: LD_STRING D3nW-Corn-1
17713: PPUSH
17714: CALL_OW 88
17718: GO 17759
// if Frank in vip and GetSide ( Frank ) = 1 then
17720: LD_EXP 52
17724: PUSH
17725: LD_EXP 59
17729: IN
17730: PUSH
17731: LD_EXP 52
17735: PPUSH
17736: CALL_OW 255
17740: PUSH
17741: LD_INT 1
17743: EQUAL
17744: AND
17745: IFFALSE 17759
// Say ( Frank , D3nW-Frank-1 ) ;
17747: LD_EXP 52
17751: PPUSH
17752: LD_STRING D3nW-Frank-1
17754: PPUSH
17755: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17759: LD_EXP 59
17763: PPUSH
17764: LD_INT 22
17766: PUSH
17767: LD_INT 1
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 72
17778: IFFALSE 17804
// begin Say ( JMM , D3nW-JMM-1 ) ;
17780: LD_EXP 39
17784: PPUSH
17785: LD_STRING D3nW-JMM-1
17787: PPUSH
17788: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17792: LD_EXP 39
17796: PPUSH
17797: LD_STRING D3nW-JMM-1a
17799: PPUSH
17800: CALL_OW 88
// end ; t := 0 0$00 ;
17804: LD_ADDR_VAR 0 3
17808: PUSH
17809: LD_INT 0
17811: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17812: LD_INT 35
17814: PPUSH
17815: CALL_OW 67
// t := t + 0 0$1 ;
17819: LD_ADDR_VAR 0 3
17823: PUSH
17824: LD_VAR 0 3
17828: PUSH
17829: LD_INT 35
17831: PLUS
17832: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17833: LD_INT 59
17835: PPUSH
17836: LD_INT 112
17838: PPUSH
17839: CALL_OW 428
17843: PUSH
17844: LD_VAR 0 3
17848: PUSH
17849: LD_INT 2100
17851: GREATER
17852: OR
17853: IFFALSE 17812
// activeAttacks := true ;
17855: LD_ADDR_EXP 16
17859: PUSH
17860: LD_INT 1
17862: ST_TO_ADDR
// end ;
17863: LD_VAR 0 1
17867: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17868: LD_INT 0
17870: PPUSH
// case question of 1 :
17871: LD_VAR 0 1
17875: PUSH
17876: LD_INT 1
17878: DOUBLE
17879: EQUAL
17880: IFTRUE 17884
17882: GO 17935
17884: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17885: LD_EXP 39
17889: PPUSH
17890: LD_STRING D2Mot-JMM-1
17892: PPUSH
17893: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17897: LD_EXP 58
17901: PPUSH
17902: LD_STRING D2Mot-Pow-1
17904: PPUSH
17905: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17909: LD_EXP 39
17913: PPUSH
17914: LD_STRING D2Mot-JMM-2
17916: PPUSH
17917: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17921: LD_EXP 58
17925: PPUSH
17926: LD_STRING D2Mot-Pow-2
17928: PPUSH
17929: CALL_OW 88
// end ; 2 :
17933: GO 18286
17935: LD_INT 2
17937: DOUBLE
17938: EQUAL
17939: IFTRUE 17943
17941: GO 18019
17943: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17944: LD_EXP 39
17948: PPUSH
17949: LD_STRING D2Rus-JMM-1
17951: PPUSH
17952: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17956: LD_EXP 58
17960: PPUSH
17961: LD_STRING D2Rus-Pow-1
17963: PPUSH
17964: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17968: LD_EXP 39
17972: PPUSH
17973: LD_STRING D2Rus-JMM-2
17975: PPUSH
17976: CALL_OW 88
// if not ( 3 in list_of_q ) then
17980: LD_INT 3
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: NOT
17989: IFFALSE 18005
// Say ( Powell , D2Rus-Pow-2 ) else
17991: LD_EXP 58
17995: PPUSH
17996: LD_STRING D2Rus-Pow-2
17998: PPUSH
17999: CALL_OW 88
18003: GO 18017
// Say ( Powell , D2Rus-Pow-2a ) ;
18005: LD_EXP 58
18009: PPUSH
18010: LD_STRING D2Rus-Pow-2a
18012: PPUSH
18013: CALL_OW 88
// end ; 3 :
18017: GO 18286
18019: LD_INT 3
18021: DOUBLE
18022: EQUAL
18023: IFTRUE 18027
18025: GO 18112
18027: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18028: LD_EXP 39
18032: PPUSH
18033: LD_STRING D2Leg-JMM-1
18035: PPUSH
18036: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18040: LD_EXP 58
18044: PPUSH
18045: LD_STRING D2Leg-Pow-1
18047: PPUSH
18048: CALL_OW 88
// if 2 in list_of_q then
18052: LD_INT 2
18054: PUSH
18055: LD_VAR 0 2
18059: IN
18060: IFFALSE 18086
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18062: LD_EXP 39
18066: PPUSH
18067: LD_STRING D2Leg-JMM-2
18069: PPUSH
18070: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18074: LD_EXP 58
18078: PPUSH
18079: LD_STRING D2Leg-Pow-2
18081: PPUSH
18082: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18086: LD_EXP 39
18090: PPUSH
18091: LD_STRING D2Leg-JMM-3
18093: PPUSH
18094: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18098: LD_EXP 58
18102: PPUSH
18103: LD_STRING D2Leg-Pow-3
18105: PPUSH
18106: CALL_OW 88
// end ; 4 :
18110: GO 18286
18112: LD_INT 4
18114: DOUBLE
18115: EQUAL
18116: IFTRUE 18120
18118: GO 18195
18120: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18121: LD_EXP 39
18125: PPUSH
18126: LD_STRING D2Ar-JMM-1
18128: PPUSH
18129: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18133: LD_EXP 58
18137: PPUSH
18138: LD_STRING D2Ar-Pow-1
18140: PPUSH
18141: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18145: LD_EXP 39
18149: PPUSH
18150: LD_STRING D2Ar-JMM-2
18152: PPUSH
18153: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18157: LD_EXP 58
18161: PPUSH
18162: LD_STRING D2Ar-Pow-2
18164: PPUSH
18165: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18169: LD_EXP 39
18173: PPUSH
18174: LD_STRING D2Ar-JMM-3
18176: PPUSH
18177: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18181: LD_EXP 58
18185: PPUSH
18186: LD_STRING D2Ar-Pow-3
18188: PPUSH
18189: CALL_OW 88
// end ; 5 :
18193: GO 18286
18195: LD_INT 5
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18218
18203: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18204: LD_EXP 39
18208: PPUSH
18209: LD_STRING D2Conf-JMM-1
18211: PPUSH
18212: CALL_OW 88
18216: GO 18286
18218: LD_INT 6
18220: DOUBLE
18221: EQUAL
18222: IFTRUE 18226
18224: GO 18285
18226: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18227: LD_EXP 39
18231: PPUSH
18232: LD_STRING D2Com-JMM-1
18234: PPUSH
18235: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18239: LD_EXP 58
18243: PPUSH
18244: LD_STRING D2Com-Pow-1
18246: PPUSH
18247: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18251: LD_EXP 39
18255: PPUSH
18256: LD_STRING D2Com-JMM-2
18258: PPUSH
18259: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18263: LD_EXP 58
18267: PPUSH
18268: LD_STRING D2Com-Pow-2
18270: PPUSH
18271: CALL_OW 88
// powellAngerQuery := true ;
18275: LD_ADDR_EXP 36
18279: PUSH
18280: LD_INT 1
18282: ST_TO_ADDR
// end ; end ;
18283: GO 18286
18285: POP
// end ;
18286: LD_VAR 0 3
18290: RET
// every 0 0$5 trigger missionStart do var tmp ;
18291: LD_EXP 13
18295: IFFALSE 18578
18297: GO 18299
18299: DISABLE
18300: LD_INT 0
18302: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18303: LD_INT 35
18305: PPUSH
18306: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18310: LD_INT 14
18312: PPUSH
18313: LD_INT 22
18315: PUSH
18316: LD_INT 1
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PPUSH
18323: CALL_OW 70
18327: PUSH
18328: LD_EXP 15
18332: PUSH
18333: LD_INT 2
18335: PUSH
18336: LD_INT 3
18338: PUSH
18339: LD_INT 4
18341: PUSH
18342: LD_INT 5
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: IN
18351: AND
18352: IFFALSE 18568
// begin powellAnger := powellAnger + 1 ;
18354: LD_ADDR_EXP 17
18358: PUSH
18359: LD_EXP 17
18363: PUSH
18364: LD_INT 1
18366: PLUS
18367: ST_TO_ADDR
// Video ( true ) ;
18368: LD_INT 1
18370: PPUSH
18371: CALL 102423 0 1
// CenterNowOnUnits ( tmp ) ;
18375: LD_VAR 0 1
18379: PPUSH
18380: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// async ;
18412: ASYNC
// case powellAnger of 1 :
18413: LD_EXP 17
18417: PUSH
18418: LD_INT 1
18420: DOUBLE
18421: EQUAL
18422: IFTRUE 18426
18424: GO 18441
18426: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18427: LD_EXP 58
18431: PPUSH
18432: LD_STRING DBack1-Pow-1
18434: PPUSH
18435: CALL_OW 88
18439: GO 18488
18441: LD_INT 2
18443: DOUBLE
18444: EQUAL
18445: IFTRUE 18449
18447: GO 18464
18449: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18450: LD_EXP 58
18454: PPUSH
18455: LD_STRING DBack2-Pow-1
18457: PPUSH
18458: CALL_OW 88
18462: GO 18488
18464: LD_INT 3
18466: DOUBLE
18467: EQUAL
18468: IFTRUE 18472
18470: GO 18487
18472: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18473: LD_EXP 58
18477: PPUSH
18478: LD_STRING DBack3-Pow-1
18480: PPUSH
18481: CALL_OW 88
18485: GO 18488
18487: POP
// sync ;
18488: SYNC
// repeat wait ( 0 0$1 ) ;
18489: LD_INT 35
18491: PPUSH
18492: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18496: LD_INT 14
18498: PPUSH
18499: LD_INT 22
18501: PUSH
18502: LD_INT 1
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PPUSH
18509: CALL_OW 70
18513: PPUSH
18514: LD_INT 86
18516: PPUSH
18517: LD_INT 133
18519: PPUSH
18520: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18524: LD_INT 14
18526: PPUSH
18527: LD_INT 22
18529: PUSH
18530: LD_INT 1
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: PPUSH
18537: CALL_OW 70
18541: NOT
18542: IFFALSE 18489
// if powellAnger >= 3 then
18544: LD_EXP 17
18548: PUSH
18549: LD_INT 3
18551: GREATEREQUAL
18552: IFFALSE 18561
// YouLost ( Dismissed ) ;
18554: LD_STRING Dismissed
18556: PPUSH
18557: CALL_OW 104
// Video ( false ) ;
18561: LD_INT 0
18563: PPUSH
18564: CALL 102423 0 1
// end ; until missionStage > 5 ;
18568: LD_EXP 15
18572: PUSH
18573: LD_INT 5
18575: GREATER
18576: IFFALSE 18303
// end ;
18578: PPOPN 1
18580: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18581: LD_EXP 13
18585: PUSH
18586: LD_INT 22
18588: PUSH
18589: LD_INT 4
18591: PUSH
18592: EMPTY
18593: LIST
18594: LIST
18595: PUSH
18596: LD_INT 21
18598: PUSH
18599: LD_INT 2
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: PPUSH
18610: CALL_OW 69
18614: PUSH
18615: LD_INT 4
18617: GREATEREQUAL
18618: AND
18619: PUSH
18620: LD_EXP 15
18624: PUSH
18625: LD_INT 2
18627: EQUAL
18628: AND
18629: IFFALSE 20452
18631: GO 18633
18633: DISABLE
18634: LD_INT 0
18636: PPUSH
18637: PPUSH
18638: PPUSH
18639: PPUSH
18640: PPUSH
18641: PPUSH
18642: PPUSH
18643: PPUSH
// begin missionStage := 3 ;
18644: LD_ADDR_EXP 15
18648: PUSH
18649: LD_INT 3
18651: ST_TO_ADDR
// retreat := false ;
18652: LD_ADDR_VAR 0 4
18656: PUSH
18657: LD_INT 0
18659: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18660: LD_ADDR_VAR 0 5
18664: PUSH
18665: LD_INT 22
18667: PUSH
18668: LD_INT 4
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: LD_INT 30
18677: PUSH
18678: LD_INT 4
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PPUSH
18689: CALL_OW 69
18693: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18694: LD_ADDR_VAR 0 6
18698: PUSH
18699: LD_INT 22
18701: PUSH
18702: LD_INT 4
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 30
18711: PUSH
18712: LD_INT 5
18714: PUSH
18715: EMPTY
18716: LIST
18717: LIST
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL_OW 69
18727: ST_TO_ADDR
// if not bar then
18728: LD_VAR 0 6
18732: NOT
18733: IFFALSE 18786
// begin repeat wait ( 0 0$1 ) ;
18735: LD_INT 35
18737: PPUSH
18738: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18742: LD_INT 22
18744: PUSH
18745: LD_INT 4
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: PUSH
18752: LD_INT 3
18754: PUSH
18755: LD_INT 57
18757: PUSH
18758: EMPTY
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: LD_INT 30
18767: PUSH
18768: LD_INT 5
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: LIST
18779: PPUSH
18780: CALL_OW 69
18784: IFFALSE 18735
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18786: LD_ADDR_VAR 0 6
18790: PUSH
18791: LD_INT 22
18793: PUSH
18794: LD_INT 4
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PUSH
18801: LD_INT 30
18803: PUSH
18804: LD_INT 5
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: PPUSH
18815: CALL_OW 69
18819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18820: LD_INT 35
18822: PPUSH
18823: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18827: LD_EXP 135
18831: PUSH
18832: LD_INT 4
18834: ARRAY
18835: PUSH
18836: LD_INT 4
18838: GREATEREQUAL
18839: IFFALSE 18820
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18841: LD_ADDR_VAR 0 2
18845: PUSH
18846: LD_INT 22
18848: PUSH
18849: LD_INT 4
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: PUSH
18856: LD_INT 2
18858: PUSH
18859: LD_INT 25
18861: PUSH
18862: LD_INT 1
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 25
18871: PUSH
18872: LD_INT 2
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: PUSH
18879: LD_INT 25
18881: PUSH
18882: LD_INT 3
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: PUSH
18889: LD_INT 25
18891: PUSH
18892: LD_INT 4
18894: PUSH
18895: EMPTY
18896: LIST
18897: LIST
18898: PUSH
18899: LD_INT 25
18901: PUSH
18902: LD_INT 5
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: PUSH
18909: EMPTY
18910: LIST
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PPUSH
18921: CALL_OW 69
18925: PUSH
18926: LD_EXP 58
18930: PUSH
18931: LD_EXP 59
18935: ADD
18936: DIFF
18937: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18938: LD_ADDR_VAR 0 3
18942: PUSH
18943: LD_VAR 0 2
18947: PPUSH
18948: LD_INT 26
18950: PUSH
18951: LD_INT 1
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PPUSH
18958: CALL_OW 72
18962: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18963: LD_ADDR_VAR 0 2
18967: PUSH
18968: LD_VAR 0 2
18972: PUSH
18973: LD_VAR 0 3
18977: DIFF
18978: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18979: LD_ADDR_VAR 0 2
18983: PUSH
18984: LD_VAR 0 2
18988: PPUSH
18989: LD_INT 1
18991: PPUSH
18992: CALL 100957 0 2
18996: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_INT 1
19009: PPUSH
19010: CALL 100957 0 2
19014: ST_TO_ADDR
// for i = 1 to 4 do
19015: LD_ADDR_VAR 0 1
19019: PUSH
19020: DOUBLE
19021: LD_INT 1
19023: DEC
19024: ST_TO_ADDR
19025: LD_INT 4
19027: PUSH
19028: FOR_TO
19029: IFFALSE 19195
// begin if tmp2 then
19031: LD_VAR 0 3
19035: IFFALSE 19116
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19037: LD_ADDR_EXP 18
19041: PUSH
19042: LD_EXP 18
19046: PPUSH
19047: LD_INT 1
19049: PPUSH
19050: LD_EXP 18
19054: PUSH
19055: LD_INT 1
19057: ARRAY
19058: PUSH
19059: LD_VAR 0 3
19063: PUSH
19064: LD_VAR 0 3
19068: ARRAY
19069: ADD
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19076: LD_VAR 0 3
19080: PUSH
19081: LD_VAR 0 3
19085: ARRAY
19086: PPUSH
19087: LD_INT 1
19089: PPUSH
19090: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19094: LD_ADDR_VAR 0 3
19098: PUSH
19099: LD_VAR 0 3
19103: PPUSH
19104: LD_VAR 0 3
19108: PPUSH
19109: CALL_OW 3
19113: ST_TO_ADDR
// end else
19114: GO 19193
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19116: LD_ADDR_EXP 18
19120: PUSH
19121: LD_EXP 18
19125: PPUSH
19126: LD_INT 1
19128: PPUSH
19129: LD_EXP 18
19133: PUSH
19134: LD_INT 1
19136: ARRAY
19137: PUSH
19138: LD_VAR 0 2
19142: PUSH
19143: LD_VAR 0 2
19147: ARRAY
19148: ADD
19149: PPUSH
19150: CALL_OW 1
19154: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19155: LD_VAR 0 2
19159: PUSH
19160: LD_VAR 0 2
19164: ARRAY
19165: PPUSH
19166: LD_INT 1
19168: PPUSH
19169: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19173: LD_ADDR_VAR 0 2
19177: PUSH
19178: LD_VAR 0 2
19182: PPUSH
19183: LD_VAR 0 2
19187: PPUSH
19188: CALL_OW 3
19192: ST_TO_ADDR
// end ; end ;
19193: GO 19028
19195: POP
19196: POP
// if tmp2 then
19197: LD_VAR 0 3
19201: IFFALSE 19219
// tmp := tmp union tmp2 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: UNION
19218: ST_TO_ADDR
// for i = 1 to 4 do
19219: LD_ADDR_VAR 0 1
19223: PUSH
19224: DOUBLE
19225: LD_INT 1
19227: DEC
19228: ST_TO_ADDR
19229: LD_INT 4
19231: PUSH
19232: FOR_TO
19233: IFFALSE 19282
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19235: LD_ADDR_EXP 18
19239: PUSH
19240: LD_EXP 18
19244: PPUSH
19245: LD_INT 2
19247: PPUSH
19248: LD_EXP 18
19252: PUSH
19253: LD_INT 2
19255: ARRAY
19256: PUSH
19257: LD_VAR 0 2
19261: PUSH
19262: LD_VAR 0 2
19266: PUSH
19267: LD_VAR 0 1
19271: MINUS
19272: ARRAY
19273: ADD
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
19280: GO 19232
19282: POP
19283: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19284: LD_ADDR_EXP 116
19288: PUSH
19289: LD_EXP 116
19293: PPUSH
19294: LD_INT 4
19296: PPUSH
19297: LD_EXP 116
19301: PUSH
19302: LD_INT 4
19304: ARRAY
19305: PUSH
19306: LD_EXP 18
19310: PUSH
19311: LD_INT 1
19313: ARRAY
19314: DIFF
19315: PPUSH
19316: CALL_OW 1
19320: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19321: LD_VAR 0 5
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: PPUSH
19330: CALL_OW 313
19334: IFFALSE 19389
// begin for i in UnitsInside ( arm [ 1 ] ) do
19336: LD_ADDR_VAR 0 1
19340: PUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 313
19354: PUSH
19355: FOR_IN
19356: IFFALSE 19387
// begin ComExitBuilding ( i ) ;
19358: LD_VAR 0 1
19362: PPUSH
19363: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 6
19376: PUSH
19377: LD_INT 1
19379: ARRAY
19380: PPUSH
19381: CALL_OW 180
// end ;
19385: GO 19355
19387: POP
19388: POP
// end ; wait ( 0 0$3 ) ;
19389: LD_INT 105
19391: PPUSH
19392: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19396: LD_ADDR_VAR 0 1
19400: PUSH
19401: LD_EXP 18
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PUSH
19410: FOR_IN
19411: IFFALSE 19518
// begin if IsInUnit ( i ) then
19413: LD_VAR 0 1
19417: PPUSH
19418: CALL_OW 310
19422: IFFALSE 19433
// ComExitBuilding ( i ) ;
19424: LD_VAR 0 1
19428: PPUSH
19429: CALL_OW 122
// if GetClass ( i ) <> 1 then
19433: LD_VAR 0 1
19437: PPUSH
19438: CALL_OW 257
19442: PUSH
19443: LD_INT 1
19445: NONEQUAL
19446: IFFALSE 19487
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19448: LD_VAR 0 1
19452: PPUSH
19453: LD_VAR 0 5
19457: PUSH
19458: LD_INT 1
19460: ARRAY
19461: PPUSH
19462: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19466: LD_VAR 0 1
19470: PPUSH
19471: LD_INT 1
19473: PPUSH
19474: CALL_OW 183
// AddComExitBuilding ( i ) ;
19478: LD_VAR 0 1
19482: PPUSH
19483: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19487: LD_VAR 0 1
19491: PPUSH
19492: LD_INT 60
19494: PPUSH
19495: LD_INT 94
19497: PPUSH
19498: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19502: LD_VAR 0 1
19506: PPUSH
19507: LD_EXP 58
19511: PPUSH
19512: CALL_OW 179
// end ;
19516: GO 19410
19518: POP
19519: POP
// wait ( 0 0$15 ) ;
19520: LD_INT 525
19522: PPUSH
19523: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19527: LD_EXP 58
19531: PPUSH
19532: LD_STRING D4-Pow-1
19534: PPUSH
19535: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19539: LD_ADDR_VAR 0 2
19543: PUSH
19544: LD_EXP 18
19548: PUSH
19549: LD_INT 1
19551: ARRAY
19552: PPUSH
19553: LD_INT 26
19555: PUSH
19556: LD_INT 1
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PPUSH
19563: CALL_OW 72
19567: ST_TO_ADDR
// if tmp then
19568: LD_VAR 0 2
19572: IFFALSE 19590
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19574: LD_VAR 0 2
19578: PUSH
19579: LD_INT 1
19581: ARRAY
19582: PPUSH
19583: LD_STRING D4-Sol1-1
19585: PPUSH
19586: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19590: LD_EXP 58
19594: PPUSH
19595: LD_STRING D4-Pow-2
19597: PPUSH
19598: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: DOUBLE
19608: LD_INT 1
19610: DEC
19611: ST_TO_ADDR
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PUSH
19621: FOR_TO
19622: IFFALSE 19715
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19624: LD_EXP 18
19628: PUSH
19629: LD_INT 1
19631: ARRAY
19632: PUSH
19633: LD_VAR 0 1
19637: ARRAY
19638: PPUSH
19639: LD_EXP 135
19643: PUSH
19644: LD_INT 4
19646: ARRAY
19647: PUSH
19648: LD_INT 1
19650: ARRAY
19651: PPUSH
19652: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19656: LD_ADDR_EXP 135
19660: PUSH
19661: LD_EXP 135
19665: PPUSH
19666: LD_INT 4
19668: PPUSH
19669: LD_EXP 135
19673: PUSH
19674: LD_INT 4
19676: ARRAY
19677: PPUSH
19678: LD_INT 1
19680: PPUSH
19681: CALL_OW 3
19685: PPUSH
19686: CALL_OW 1
19690: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19691: LD_INT 8
19693: PPUSH
19694: LD_EXP 18
19698: PUSH
19699: LD_INT 1
19701: ARRAY
19702: PUSH
19703: LD_VAR 0 1
19707: ARRAY
19708: PPUSH
19709: CALL_OW 471
// end ;
19713: GO 19621
19715: POP
19716: POP
// repeat wait ( 0 0$1 ) ;
19717: LD_INT 35
19719: PPUSH
19720: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19724: LD_EXP 18
19728: PUSH
19729: LD_INT 1
19731: ARRAY
19732: PPUSH
19733: LD_INT 55
19735: PUSH
19736: EMPTY
19737: LIST
19738: PPUSH
19739: CALL_OW 72
19743: PUSH
19744: LD_INT 4
19746: GREATEREQUAL
19747: IFFALSE 19717
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19749: LD_EXP 18
19753: PUSH
19754: LD_INT 1
19756: ARRAY
19757: PPUSH
19758: LD_INT 69
19760: PPUSH
19761: LD_INT 94
19763: PPUSH
19764: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19768: LD_EXP 18
19772: PUSH
19773: LD_INT 1
19775: ARRAY
19776: PPUSH
19777: LD_INT 82
19779: PPUSH
19780: LD_INT 83
19782: PPUSH
19783: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19787: LD_EXP 18
19791: PUSH
19792: LD_INT 1
19794: ARRAY
19795: PPUSH
19796: LD_INT 77
19798: PPUSH
19799: LD_INT 69
19801: PPUSH
19802: CALL_OW 174
// repeat wait ( 3 ) ;
19806: LD_INT 3
19808: PPUSH
19809: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19813: LD_ADDR_VAR 0 1
19817: PUSH
19818: LD_EXP 18
19822: PUSH
19823: LD_INT 1
19825: ARRAY
19826: PUSH
19827: FOR_IN
19828: IFFALSE 19964
// begin if GetLives ( i ) < 990 then
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 256
19839: PUSH
19840: LD_INT 990
19842: LESS
19843: IFFALSE 19857
// SetLives ( i , 1000 ) ;
19845: LD_VAR 0 1
19849: PPUSH
19850: LD_INT 1000
19852: PPUSH
19853: CALL_OW 234
// if not IsInUnit ( i ) then
19857: LD_VAR 0 1
19861: PPUSH
19862: CALL_OW 310
19866: NOT
19867: IFFALSE 19962
// begin if not HasTask ( i ) then
19869: LD_VAR 0 1
19873: PPUSH
19874: CALL_OW 314
19878: NOT
19879: IFFALSE 19896
// ComMoveXY ( i , 64 , 93 ) ;
19881: LD_VAR 0 1
19885: PPUSH
19886: LD_INT 64
19888: PPUSH
19889: LD_INT 93
19891: PPUSH
19892: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19896: LD_VAR 0 4
19900: NOT
19901: PUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: CALL_OW 258
19911: PUSH
19912: LD_INT 1
19914: EQUAL
19915: AND
19916: IFFALSE 19962
// begin retreat := true ;
19918: LD_ADDR_VAR 0 4
19922: PUSH
19923: LD_INT 1
19925: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19926: LD_VAR 0 1
19930: PPUSH
19931: LD_INT 2
19933: PPUSH
19934: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19938: LD_VAR 0 1
19942: PPUSH
19943: LD_STRING D4a-Sol1-1
19945: PPUSH
19946: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19950: LD_EXP 58
19954: PPUSH
19955: LD_STRING D4a-Pow-1
19957: PPUSH
19958: CALL_OW 88
// end ; end ; end ;
19962: GO 19827
19964: POP
19965: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19966: LD_EXP 18
19970: PUSH
19971: LD_INT 1
19973: ARRAY
19974: PPUSH
19975: LD_INT 95
19977: PUSH
19978: LD_INT 9
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: PUSH
19985: LD_INT 3
19987: PUSH
19988: LD_INT 55
19990: PUSH
19991: EMPTY
19992: LIST
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: PPUSH
20002: CALL_OW 72
20006: PUSH
20007: LD_INT 4
20009: GREATEREQUAL
20010: IFFALSE 19806
// for i in powellSquadAttack [ 1 ] do
20012: LD_ADDR_VAR 0 1
20016: PUSH
20017: LD_EXP 18
20021: PUSH
20022: LD_INT 1
20024: ARRAY
20025: PUSH
20026: FOR_IN
20027: IFFALSE 20163
// begin if GetTag ( i ) = 2 then
20029: LD_VAR 0 1
20033: PPUSH
20034: CALL_OW 110
20038: PUSH
20039: LD_INT 2
20041: EQUAL
20042: IFFALSE 20104
// begin ComMoveXY ( i , 60 , 94 ) ;
20044: LD_VAR 0 1
20048: PPUSH
20049: LD_INT 60
20051: PPUSH
20052: LD_INT 94
20054: PPUSH
20055: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20059: LD_VAR 0 1
20063: PPUSH
20064: LD_EXP 58
20068: PPUSH
20069: CALL_OW 179
// wait ( 0 0$3 ) ;
20073: LD_INT 105
20075: PPUSH
20076: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20080: LD_VAR 0 1
20084: PPUSH
20085: LD_STRING D4a-Sol1-2
20087: PPUSH
20088: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20092: LD_EXP 58
20096: PPUSH
20097: LD_STRING D4a-Pow-2
20099: PPUSH
20100: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20104: LD_VAR 0 1
20108: PPUSH
20109: LD_INT 0
20111: PPUSH
20112: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20116: LD_ADDR_EXP 116
20120: PUSH
20121: LD_EXP 116
20125: PPUSH
20126: LD_INT 4
20128: PPUSH
20129: LD_EXP 116
20133: PUSH
20134: LD_INT 4
20136: ARRAY
20137: PUSH
20138: LD_VAR 0 1
20142: UNION
20143: PPUSH
20144: CALL_OW 1
20148: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20149: LD_INT 8
20151: PPUSH
20152: LD_VAR 0 1
20156: PPUSH
20157: CALL_OW 472
// end ;
20161: GO 20026
20163: POP
20164: POP
// wait ( 4 4$00 ) ;
20165: LD_INT 8400
20167: PPUSH
20168: CALL_OW 67
// uc_side := 6 ;
20172: LD_ADDR_OWVAR 20
20176: PUSH
20177: LD_INT 6
20179: ST_TO_ADDR
// uc_nation := 3 ;
20180: LD_ADDR_OWVAR 21
20184: PUSH
20185: LD_INT 3
20187: ST_TO_ADDR
// ru := [ ] ;
20188: LD_ADDR_VAR 0 7
20192: PUSH
20193: EMPTY
20194: ST_TO_ADDR
// for i = 1 to 4 do
20195: LD_ADDR_VAR 0 1
20199: PUSH
20200: DOUBLE
20201: LD_INT 1
20203: DEC
20204: ST_TO_ADDR
20205: LD_INT 4
20207: PUSH
20208: FOR_TO
20209: IFFALSE 20310
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20211: LD_INT 22
20213: PPUSH
20214: LD_INT 1
20216: PPUSH
20217: LD_INT 3
20219: PPUSH
20220: LD_INT 43
20222: PUSH
20223: LD_INT 44
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PUSH
20230: LD_INT 1
20232: PPUSH
20233: LD_INT 2
20235: PPUSH
20236: CALL_OW 12
20240: ARRAY
20241: PPUSH
20242: LD_INT 89
20244: PPUSH
20245: CALL 70578 0 5
// un := CreateVehicle ;
20249: LD_ADDR_VAR 0 8
20253: PUSH
20254: CALL_OW 45
20258: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20259: LD_VAR 0 8
20263: PPUSH
20264: LD_INT 4
20266: PPUSH
20267: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20271: LD_VAR 0 8
20275: PPUSH
20276: LD_INT 136
20278: PPUSH
20279: LD_INT 90
20281: PPUSH
20282: LD_INT 8
20284: PPUSH
20285: LD_INT 0
20287: PPUSH
20288: CALL_OW 50
// ru := ru ^ un ;
20292: LD_ADDR_VAR 0 7
20296: PUSH
20297: LD_VAR 0 7
20301: PUSH
20302: LD_VAR 0 8
20306: ADD
20307: ST_TO_ADDR
// end ;
20308: GO 20208
20310: POP
20311: POP
// if ru then
20312: LD_VAR 0 7
20316: IFFALSE 20333
// ComAgressiveMove ( ru , 80 , 92 ) ;
20318: LD_VAR 0 7
20322: PPUSH
20323: LD_INT 80
20325: PPUSH
20326: LD_INT 92
20328: PPUSH
20329: CALL_OW 114
// wait ( 8 8$00 ) ;
20333: LD_INT 16800
20335: PPUSH
20336: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20340: LD_INT 4
20342: PPUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: LD_INT 4
20363: PUSH
20364: LD_INT 1
20366: PUSH
20367: LD_INT 1
20369: PUSH
20370: LD_INT 6
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 4
20381: PUSH
20382: LD_INT 1
20384: PUSH
20385: LD_INT 1
20387: PUSH
20388: LD_INT 7
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 3
20399: PUSH
20400: LD_INT 1
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 7
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: PUSH
20415: LD_INT 3
20417: PUSH
20418: LD_INT 1
20420: PUSH
20421: LD_INT 1
20423: PUSH
20424: LD_INT 5
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL 59260 0 2
// missionStage := 4 ;
20444: LD_ADDR_EXP 15
20448: PUSH
20449: LD_INT 4
20451: ST_TO_ADDR
// end ;
20452: PPOPN 8
20454: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20455: LD_EXP 15
20459: PUSH
20460: LD_INT 4
20462: EQUAL
20463: PUSH
20464: LD_INT 22
20466: PUSH
20467: LD_INT 4
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: PUSH
20474: LD_INT 21
20476: PUSH
20477: LD_INT 2
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: PPUSH
20488: CALL_OW 69
20492: PUSH
20493: LD_INT 5
20495: GREATEREQUAL
20496: AND
20497: IFFALSE 24602
20499: GO 20501
20501: DISABLE
20502: LD_INT 0
20504: PPUSH
20505: PPUSH
20506: PPUSH
20507: PPUSH
20508: PPUSH
20509: PPUSH
20510: PPUSH
20511: PPUSH
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
// begin missionStage := 5 ;
20517: LD_ADDR_EXP 15
20521: PUSH
20522: LD_INT 5
20524: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20525: LD_ADDR_VAR 0 10
20529: PUSH
20530: LD_INT 22
20532: PUSH
20533: LD_INT 4
20535: PUSH
20536: EMPTY
20537: LIST
20538: LIST
20539: PUSH
20540: LD_INT 2
20542: PUSH
20543: LD_INT 30
20545: PUSH
20546: LD_INT 4
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 30
20555: PUSH
20556: LD_INT 5
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: PPUSH
20572: CALL_OW 69
20576: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20577: LD_ADDR_VAR 0 6
20581: PUSH
20582: LD_INT 22
20584: PUSH
20585: LD_INT 4
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: PUSH
20592: LD_INT 21
20594: PUSH
20595: LD_INT 1
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: PUSH
20602: LD_INT 3
20604: PUSH
20605: LD_INT 25
20607: PUSH
20608: LD_INT 16
20610: PUSH
20611: EMPTY
20612: LIST
20613: LIST
20614: PUSH
20615: EMPTY
20616: LIST
20617: LIST
20618: PUSH
20619: LD_INT 3
20621: PUSH
20622: LD_INT 25
20624: PUSH
20625: LD_INT 12
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: PPUSH
20642: CALL_OW 69
20646: PUSH
20647: LD_EXP 58
20651: DIFF
20652: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20653: LD_ADDR_VAR 0 9
20657: PUSH
20658: LD_INT 22
20660: PUSH
20661: LD_INT 4
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: PUSH
20668: LD_INT 30
20670: PUSH
20671: LD_INT 3
20673: PUSH
20674: EMPTY
20675: LIST
20676: LIST
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: PPUSH
20682: CALL_OW 69
20686: PUSH
20687: LD_INT 1
20689: ARRAY
20690: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20691: LD_INT 35
20693: PPUSH
20694: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20698: LD_EXP 135
20702: PUSH
20703: LD_INT 4
20705: ARRAY
20706: PUSH
20707: LD_INT 5
20709: GREATEREQUAL
20710: PUSH
20711: LD_EXP 135
20715: PUSH
20716: LD_INT 4
20718: ARRAY
20719: PPUSH
20720: LD_INT 58
20722: PUSH
20723: EMPTY
20724: LIST
20725: PPUSH
20726: CALL_OW 72
20730: PUSH
20731: LD_INT 5
20733: GREATEREQUAL
20734: AND
20735: IFFALSE 20691
// powellAllowRetreat := false ;
20737: LD_ADDR_EXP 19
20741: PUSH
20742: LD_INT 0
20744: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20745: LD_INT 700
20747: PPUSH
20748: CALL_OW 67
// activeAttacks := false ;
20752: LD_ADDR_EXP 16
20756: PUSH
20757: LD_INT 0
20759: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20760: LD_INT 35
20762: PPUSH
20763: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20767: LD_INT 22
20769: PUSH
20770: LD_INT 6
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PPUSH
20777: CALL_OW 69
20781: PUSH
20782: LD_INT 0
20784: EQUAL
20785: IFFALSE 20760
// tmp := mc_vehicles [ 4 ] ;
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: LD_EXP 135
20796: PUSH
20797: LD_INT 4
20799: ARRAY
20800: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20801: LD_ADDR_VAR 0 1
20805: PUSH
20806: DOUBLE
20807: LD_INT 1
20809: DEC
20810: ST_TO_ADDR
20811: LD_EXP 18
20815: PUSH
20816: FOR_TO
20817: IFFALSE 21078
// begin for j in powellSquadAttack [ i ] do
20819: LD_ADDR_VAR 0 2
20823: PUSH
20824: LD_EXP 18
20828: PUSH
20829: LD_VAR 0 1
20833: ARRAY
20834: PUSH
20835: FOR_IN
20836: IFFALSE 21074
// begin forces := forces diff j ;
20838: LD_ADDR_VAR 0 6
20842: PUSH
20843: LD_VAR 0 6
20847: PUSH
20848: LD_VAR 0 2
20852: DIFF
20853: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20854: LD_VAR 0 2
20858: PPUSH
20859: LD_INT 1
20861: PPUSH
20862: CALL_OW 109
// wait ( 0 0$2 ) ;
20866: LD_INT 70
20868: PPUSH
20869: CALL_OW 67
// if IsInUnit ( j ) then
20873: LD_VAR 0 2
20877: PPUSH
20878: CALL_OW 310
20882: IFFALSE 20893
// ComExitBuilding ( j ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: CALL_OW 122
// if GetClass ( j ) <> 1 then
20893: LD_VAR 0 2
20897: PPUSH
20898: CALL_OW 257
20902: PUSH
20903: LD_INT 1
20905: NONEQUAL
20906: IFFALSE 20986
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20908: LD_VAR 0 10
20912: PUSH
20913: LD_INT 1
20915: ARRAY
20916: PPUSH
20917: CALL_OW 313
20921: PUSH
20922: LD_INT 5
20924: GREATEREQUAL
20925: IFFALSE 20947
// AddComEnterUnit ( j , arm [ 2 ] ) else
20927: LD_VAR 0 2
20931: PPUSH
20932: LD_VAR 0 10
20936: PUSH
20937: LD_INT 2
20939: ARRAY
20940: PPUSH
20941: CALL_OW 180
20945: GO 20965
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20947: LD_VAR 0 2
20951: PPUSH
20952: LD_VAR 0 10
20956: PUSH
20957: LD_INT 1
20959: ARRAY
20960: PPUSH
20961: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20965: LD_VAR 0 2
20969: PPUSH
20970: LD_INT 1
20972: PPUSH
20973: CALL_OW 183
// AddComExitBuilding ( j ) ;
20977: LD_VAR 0 2
20981: PPUSH
20982: CALL_OW 182
// end ; if i = 2 then
20986: LD_VAR 0 1
20990: PUSH
20991: LD_INT 2
20993: EQUAL
20994: IFFALSE 21011
// AddComMoveXY ( j , 61 , 93 ) ;
20996: LD_VAR 0 2
21000: PPUSH
21001: LD_INT 61
21003: PPUSH
21004: LD_INT 93
21006: PPUSH
21007: CALL_OW 171
// if i = 1 then
21011: LD_VAR 0 1
21015: PUSH
21016: LD_INT 1
21018: EQUAL
21019: IFFALSE 21072
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21021: LD_VAR 0 2
21025: PPUSH
21026: LD_VAR 0 3
21030: PUSH
21031: LD_INT 1
21033: ARRAY
21034: PPUSH
21035: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21039: LD_ADDR_VAR 0 3
21043: PUSH
21044: LD_VAR 0 3
21048: PPUSH
21049: LD_INT 1
21051: PPUSH
21052: CALL_OW 3
21056: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21057: LD_VAR 0 2
21061: PPUSH
21062: LD_INT 69
21064: PPUSH
21065: LD_INT 94
21067: PPUSH
21068: CALL_OW 171
// end ; end ;
21072: GO 20835
21074: POP
21075: POP
// end ;
21076: GO 20816
21078: POP
21079: POP
// wait ( 0 0$55 ) ;
21080: LD_INT 1925
21082: PPUSH
21083: CALL_OW 67
// MC_Kill ( 4 ) ;
21087: LD_INT 4
21089: PPUSH
21090: CALL 35477 0 1
// tmp := UnitsInside ( fac ) ;
21094: LD_ADDR_VAR 0 3
21098: PUSH
21099: LD_VAR 0 9
21103: PPUSH
21104: CALL_OW 313
21108: ST_TO_ADDR
// if tmp then
21109: LD_VAR 0 3
21113: IFFALSE 21234
// for i in tmp do
21115: LD_ADDR_VAR 0 1
21119: PUSH
21120: LD_VAR 0 3
21124: PUSH
21125: FOR_IN
21126: IFFALSE 21232
// begin ComExitBuilding ( i ) ;
21128: LD_VAR 0 1
21132: PPUSH
21133: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21137: LD_VAR 0 10
21141: PUSH
21142: LD_INT 2
21144: ARRAY
21145: PPUSH
21146: CALL_OW 313
21150: PUSH
21151: LD_INT 6
21153: LESS
21154: IFFALSE 21176
// AddComEnterUnit ( i , arm [ 2 ] ) else
21156: LD_VAR 0 1
21160: PPUSH
21161: LD_VAR 0 10
21165: PUSH
21166: LD_INT 2
21168: ARRAY
21169: PPUSH
21170: CALL_OW 180
21174: GO 21230
// if UnitsInside ( arm [ 1 ] ) < 6 then
21176: LD_VAR 0 10
21180: PUSH
21181: LD_INT 1
21183: ARRAY
21184: PPUSH
21185: CALL_OW 313
21189: PUSH
21190: LD_INT 6
21192: LESS
21193: IFFALSE 21215
// AddComEnterUnit ( i , arm [ 1 ] ) else
21195: LD_VAR 0 1
21199: PPUSH
21200: LD_VAR 0 10
21204: PUSH
21205: LD_INT 1
21207: ARRAY
21208: PPUSH
21209: CALL_OW 180
21213: GO 21230
// AddComMoveXY ( i , 37 , 68 ) ;
21215: LD_VAR 0 1
21219: PPUSH
21220: LD_INT 37
21222: PPUSH
21223: LD_INT 68
21225: PPUSH
21226: CALL_OW 171
// end ;
21230: GO 21125
21232: POP
21233: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21234: LD_ADDR_VAR 0 11
21238: PUSH
21239: LD_VAR 0 6
21243: PPUSH
21244: LD_INT 26
21246: PUSH
21247: LD_INT 1
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PPUSH
21254: CALL_OW 72
21258: PUSH
21259: LD_EXP 59
21263: DIFF
21264: ST_TO_ADDR
// if not speaker then
21265: LD_VAR 0 11
21269: NOT
21270: IFFALSE 21297
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21272: LD_ADDR_VAR 0 11
21276: PUSH
21277: LD_VAR 0 6
21281: PPUSH
21282: LD_INT 26
21284: PUSH
21285: LD_INT 1
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: PPUSH
21292: CALL_OW 72
21296: ST_TO_ADDR
// if speaker then
21297: LD_VAR 0 11
21301: IFFALSE 21317
// speaker := speaker [ 1 ] ;
21303: LD_ADDR_VAR 0 11
21307: PUSH
21308: LD_VAR 0 11
21312: PUSH
21313: LD_INT 1
21315: ARRAY
21316: ST_TO_ADDR
// Video ( true ) ;
21317: LD_INT 1
21319: PPUSH
21320: CALL 102423 0 1
// CenterNowOnUnits ( Powell ) ;
21324: LD_EXP 58
21328: PPUSH
21329: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21333: LD_ADDR_VAR 0 3
21337: PUSH
21338: LD_VAR 0 6
21342: PPUSH
21343: LD_INT 3
21345: PUSH
21346: LD_INT 25
21348: PUSH
21349: LD_INT 1
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PPUSH
21360: CALL_OW 72
21364: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21365: LD_ADDR_VAR 0 12
21369: PUSH
21370: LD_INT 22
21372: PUSH
21373: LD_INT 4
21375: PUSH
21376: EMPTY
21377: LIST
21378: LIST
21379: PUSH
21380: LD_INT 30
21382: PUSH
21383: LD_INT 32
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: PUSH
21390: LD_INT 58
21392: PUSH
21393: EMPTY
21394: LIST
21395: PUSH
21396: EMPTY
21397: LIST
21398: LIST
21399: LIST
21400: PPUSH
21401: CALL_OW 69
21405: ST_TO_ADDR
// for i = 1 to 6 do
21406: LD_ADDR_VAR 0 1
21410: PUSH
21411: DOUBLE
21412: LD_INT 1
21414: DEC
21415: ST_TO_ADDR
21416: LD_INT 6
21418: PUSH
21419: FOR_TO
21420: IFFALSE 21561
// begin if IsInUnit ( tmp [ i ] ) then
21422: LD_VAR 0 3
21426: PUSH
21427: LD_VAR 0 1
21431: ARRAY
21432: PPUSH
21433: CALL_OW 310
21437: IFFALSE 21454
// ComExitBuilding ( tmp [ i ] ) ;
21439: LD_VAR 0 3
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21454: LD_VAR 0 3
21458: PUSH
21459: LD_VAR 0 1
21463: ARRAY
21464: PPUSH
21465: LD_VAR 0 10
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: PPUSH
21474: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21478: LD_VAR 0 3
21482: PUSH
21483: LD_VAR 0 1
21487: ARRAY
21488: PPUSH
21489: LD_INT 1
21491: PPUSH
21492: CALL_OW 183
// if emp_towers then
21496: LD_VAR 0 12
21500: IFFALSE 21559
// begin AddComExitBuilding ( tmp [ i ] ) ;
21502: LD_VAR 0 3
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21517: LD_VAR 0 3
21521: PUSH
21522: LD_VAR 0 1
21526: ARRAY
21527: PPUSH
21528: LD_VAR 0 12
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PPUSH
21537: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21541: LD_ADDR_VAR 0 12
21545: PUSH
21546: LD_VAR 0 12
21550: PPUSH
21551: LD_INT 1
21553: PPUSH
21554: CALL_OW 3
21558: ST_TO_ADDR
// end ; end ;
21559: GO 21419
21561: POP
21562: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21563: LD_ADDR_VAR 0 3
21567: PUSH
21568: LD_EXP 18
21572: PUSH
21573: LD_INT 1
21575: ARRAY
21576: PUSH
21577: LD_EXP 18
21581: PUSH
21582: LD_INT 2
21584: ARRAY
21585: ADD
21586: PPUSH
21587: LD_INT 26
21589: PUSH
21590: LD_INT 1
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: PPUSH
21597: CALL_OW 72
21601: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21602: LD_ADDR_VAR 0 1
21606: PUSH
21607: LD_EXP 18
21611: PUSH
21612: LD_INT 2
21614: ARRAY
21615: PUSH
21616: FOR_IN
21617: IFFALSE 21635
// ComTurnUnit ( i , Powell ) ;
21619: LD_VAR 0 1
21623: PPUSH
21624: LD_EXP 58
21628: PPUSH
21629: CALL_OW 119
21633: GO 21616
21635: POP
21636: POP
// Say ( Powell , D5-Pow-1 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-1
21644: PPUSH
21645: CALL_OW 88
// if tmp then
21649: LD_VAR 0 3
21653: IFFALSE 21671
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21655: LD_VAR 0 3
21659: PUSH
21660: LD_INT 1
21662: ARRAY
21663: PPUSH
21664: LD_STRING D5-Sol2-1
21666: PPUSH
21667: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21671: LD_EXP 58
21675: PPUSH
21676: LD_STRING D5-Pow-2
21678: PPUSH
21679: CALL_OW 88
// if tmp > 1 then
21683: LD_VAR 0 3
21687: PUSH
21688: LD_INT 1
21690: GREATER
21691: IFFALSE 21709
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21693: LD_VAR 0 3
21697: PUSH
21698: LD_INT 2
21700: ARRAY
21701: PPUSH
21702: LD_STRING D5-Sol2-2
21704: PPUSH
21705: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21709: LD_EXP 58
21713: PPUSH
21714: LD_STRING D5-Pow-3
21716: PPUSH
21717: CALL_OW 88
// wait ( 0 0$1 ) ;
21721: LD_INT 35
21723: PPUSH
21724: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21728: LD_ADDR_VAR 0 3
21732: PUSH
21733: LD_EXP 18
21737: PUSH
21738: LD_INT 1
21740: ARRAY
21741: PUSH
21742: LD_EXP 18
21746: PUSH
21747: LD_INT 2
21749: ARRAY
21750: UNION
21751: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21752: LD_VAR 0 3
21756: PPUSH
21757: LD_INT 80
21759: PPUSH
21760: LD_INT 67
21762: PPUSH
21763: CALL_OW 114
// wait ( 0 0$2 ) ;
21767: LD_INT 70
21769: PPUSH
21770: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21774: LD_INT 79
21776: PPUSH
21777: LD_INT 72
21779: PPUSH
21780: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21784: LD_INT 35
21786: PPUSH
21787: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21791: LD_VAR 0 3
21795: PPUSH
21796: LD_INT 3
21798: PUSH
21799: LD_INT 24
21801: PUSH
21802: LD_INT 1000
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: PPUSH
21813: CALL_OW 72
21817: IFFALSE 21784
// Say ( Powell , D5a-Pow-1 ) ;
21819: LD_EXP 58
21823: PPUSH
21824: LD_STRING D5a-Pow-1
21826: PPUSH
21827: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21831: LD_EXP 58
21835: PPUSH
21836: LD_STRING D5a-Pow-1a
21838: PPUSH
21839: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21843: LD_INT 10
21845: PPUSH
21846: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21850: LD_EXP 58
21854: PPUSH
21855: LD_STRING D5a-Pow-1b
21857: PPUSH
21858: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21862: LD_EXP 58
21866: PPUSH
21867: LD_STRING D5a-Pow-1c
21869: PPUSH
21870: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21874: LD_EXP 58
21878: PPUSH
21879: LD_STRING D5a-Pow-1d
21881: PPUSH
21882: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21886: LD_INT 35
21888: PPUSH
21889: CALL_OW 67
// if not HasTask ( tmp ) then
21893: LD_VAR 0 3
21897: PPUSH
21898: CALL_OW 314
21902: NOT
21903: IFFALSE 21920
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21905: LD_VAR 0 3
21909: PPUSH
21910: LD_INT 80
21912: PPUSH
21913: LD_INT 67
21915: PPUSH
21916: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21920: LD_VAR 0 3
21924: PPUSH
21925: LD_INT 24
21927: PUSH
21928: LD_INT 1
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PPUSH
21935: CALL_OW 72
21939: NOT
21940: IFFALSE 21886
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21942: LD_ADDR_VAR 0 3
21946: PUSH
21947: LD_INT 22
21949: PUSH
21950: LD_INT 4
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: PUSH
21957: LD_INT 92
21959: PUSH
21960: LD_INT 60
21962: PUSH
21963: LD_INT 93
21965: PUSH
21966: LD_INT 10
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: PUSH
21975: LD_INT 3
21977: PUSH
21978: LD_INT 54
21980: PUSH
21981: EMPTY
21982: LIST
21983: PUSH
21984: EMPTY
21985: LIST
21986: LIST
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: LIST
21992: PPUSH
21993: CALL_OW 69
21997: PUSH
21998: LD_EXP 58
22002: DIFF
22003: ST_TO_ADDR
// if tmp then
22004: LD_VAR 0 3
22008: IFFALSE 22042
// for i in tmp do
22010: LD_ADDR_VAR 0 1
22014: PUSH
22015: LD_VAR 0 3
22019: PUSH
22020: FOR_IN
22021: IFFALSE 22040
// ComMoveXY ( i , 36 , 67 ) ;
22023: LD_VAR 0 1
22027: PPUSH
22028: LD_INT 36
22030: PPUSH
22031: LD_INT 67
22033: PPUSH
22034: CALL_OW 111
22038: GO 22020
22040: POP
22041: POP
// wait ( 0 0$3 ) ;
22042: LD_INT 105
22044: PPUSH
22045: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22049: LD_VAR 0 11
22053: PPUSH
22054: LD_STRING D6-Sol3-1
22056: PPUSH
22057: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22061: LD_EXP 58
22065: PPUSH
22066: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22070: LD_EXP 58
22074: PPUSH
22075: LD_STRING D6-Pow-1
22077: PPUSH
22078: CALL_OW 88
// tmp := [ ] ;
22082: LD_ADDR_VAR 0 3
22086: PUSH
22087: EMPTY
22088: ST_TO_ADDR
// for i = 1 to 2 do
22089: LD_ADDR_VAR 0 1
22093: PUSH
22094: DOUBLE
22095: LD_INT 1
22097: DEC
22098: ST_TO_ADDR
22099: LD_INT 2
22101: PUSH
22102: FOR_TO
22103: IFFALSE 22217
// begin uc_side := 8 ;
22105: LD_ADDR_OWVAR 20
22109: PUSH
22110: LD_INT 8
22112: ST_TO_ADDR
// uc_nation := 2 ;
22113: LD_ADDR_OWVAR 21
22117: PUSH
22118: LD_INT 2
22120: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22121: LD_INT 14
22123: PPUSH
22124: LD_INT 3
22126: PPUSH
22127: LD_INT 2
22129: PPUSH
22130: LD_INT 29
22132: PPUSH
22133: LD_INT 100
22135: PPUSH
22136: CALL 70578 0 5
// veh := CreateVehicle ;
22140: LD_ADDR_VAR 0 13
22144: PUSH
22145: CALL_OW 45
22149: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22150: LD_VAR 0 13
22154: PPUSH
22155: LD_INT 4
22157: PPUSH
22158: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22162: LD_VAR 0 13
22166: PPUSH
22167: LD_INT 99
22169: PPUSH
22170: LD_INT 83
22172: PPUSH
22173: LD_INT 6
22175: PPUSH
22176: LD_INT 0
22178: PPUSH
22179: CALL_OW 50
// wait ( 3 ) ;
22183: LD_INT 3
22185: PPUSH
22186: CALL_OW 67
// Connect ( veh ) ;
22190: LD_VAR 0 13
22194: PPUSH
22195: CALL 73671 0 1
// tmp := tmp ^ veh ;
22199: LD_ADDR_VAR 0 3
22203: PUSH
22204: LD_VAR 0 3
22208: PUSH
22209: LD_VAR 0 13
22213: ADD
22214: ST_TO_ADDR
// end ;
22215: GO 22102
22217: POP
22218: POP
// wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22226: LD_INT 99
22228: PPUSH
22229: LD_INT 83
22231: PPUSH
22232: LD_INT 1
22234: PPUSH
22235: LD_INT 10
22237: PPUSH
22238: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22242: LD_INT 99
22244: PPUSH
22245: LD_INT 83
22247: PPUSH
22248: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_STRING D6-Sol3-2
22259: PPUSH
22260: CALL_OW 88
// async ;
22264: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22265: LD_EXP 58
22269: PPUSH
22270: LD_STRING D6-Pow-2
22272: PPUSH
22273: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22277: LD_VAR 0 3
22281: PUSH
22282: LD_INT 1
22284: ARRAY
22285: PPUSH
22286: LD_VAR 0 9
22290: PPUSH
22291: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22295: LD_VAR 0 3
22299: PUSH
22300: LD_INT 2
22302: ARRAY
22303: PPUSH
22304: LD_INT 22
22306: PUSH
22307: LD_INT 4
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 21
22316: PUSH
22317: LD_INT 3
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PPUSH
22328: CALL_OW 69
22332: PPUSH
22333: LD_VAR 0 3
22337: PUSH
22338: LD_INT 2
22340: ARRAY
22341: PPUSH
22342: CALL_OW 74
22346: PPUSH
22347: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22351: LD_EXP 58
22355: PPUSH
22356: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22360: LD_INT 99
22362: PPUSH
22363: LD_INT 83
22365: PPUSH
22366: LD_INT 1
22368: PPUSH
22369: CALL_OW 331
// repeat wait ( 4 ) ;
22373: LD_INT 4
22375: PPUSH
22376: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22380: LD_VAR 0 3
22384: PUSH
22385: LD_INT 1
22387: ARRAY
22388: PPUSH
22389: CALL_OW 256
22393: PUSH
22394: LD_INT 1000
22396: LESS
22397: IFFALSE 22415
// SetLives ( tmp [ 1 ] , 1000 ) ;
22399: LD_VAR 0 3
22403: PUSH
22404: LD_INT 1
22406: ARRAY
22407: PPUSH
22408: LD_INT 1000
22410: PPUSH
22411: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22415: LD_INT 22
22417: PUSH
22418: LD_INT 4
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: LD_INT 30
22427: PUSH
22428: LD_INT 3
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PPUSH
22439: CALL_OW 69
22443: PUSH
22444: LD_INT 0
22446: EQUAL
22447: IFFALSE 22373
// sync ;
22449: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22450: LD_EXP 58
22454: PPUSH
22455: LD_STRING D6a-Pow-1
22457: PPUSH
22458: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22462: LD_VAR 0 11
22466: PPUSH
22467: LD_STRING D6a-Sol3-1
22469: PPUSH
22470: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22474: LD_EXP 58
22478: PPUSH
22479: LD_STRING D6a-Pow-2
22481: PPUSH
22482: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22486: LD_VAR 0 11
22490: PPUSH
22491: LD_STRING D6a-Sol3-2
22493: PPUSH
22494: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22498: LD_EXP 58
22502: PPUSH
22503: LD_STRING D6a-Pow-3
22505: PPUSH
22506: CALL_OW 88
// powellCenterCameraMode := true ;
22510: LD_ADDR_EXP 20
22514: PUSH
22515: LD_INT 1
22517: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22518: LD_ADDR_VAR 0 1
22522: PUSH
22523: LD_INT 22
22525: PUSH
22526: LD_INT 8
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: PUSH
22533: LD_INT 25
22535: PUSH
22536: LD_INT 2
22538: PUSH
22539: EMPTY
22540: LIST
22541: LIST
22542: PUSH
22543: EMPTY
22544: LIST
22545: LIST
22546: PPUSH
22547: CALL_OW 69
22551: PUSH
22552: FOR_IN
22553: IFFALSE 22608
// begin SetTag ( i , 1 ) ;
22555: LD_VAR 0 1
22559: PPUSH
22560: LD_INT 1
22562: PPUSH
22563: CALL_OW 109
// ComExitBuilding ( i ) ;
22567: LD_VAR 0 1
22571: PPUSH
22572: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22576: LD_VAR 0 1
22580: PPUSH
22581: LD_INT 35
22583: PPUSH
22584: LD_INT 6
22586: PPUSH
22587: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22591: LD_VAR 0 1
22595: PPUSH
22596: LD_INT 53
22598: PPUSH
22599: LD_INT 4
22601: PPUSH
22602: CALL_OW 171
// end ;
22606: GO 22552
22608: POP
22609: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22610: LD_ADDR_VAR 0 3
22614: PUSH
22615: LD_INT 22
22617: PUSH
22618: LD_INT 4
22620: PUSH
22621: EMPTY
22622: LIST
22623: LIST
22624: PUSH
22625: LD_INT 21
22627: PUSH
22628: LD_INT 2
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: PUSH
22635: LD_INT 3
22637: PUSH
22638: LD_INT 34
22640: PUSH
22641: LD_INT 12
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: EMPTY
22649: LIST
22650: LIST
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: LIST
22656: PPUSH
22657: CALL_OW 69
22661: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22662: LD_EXP 58
22666: PPUSH
22667: LD_VAR 0 3
22671: PPUSH
22672: LD_EXP 58
22676: PPUSH
22677: CALL_OW 74
22681: PPUSH
22682: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22686: LD_EXP 58
22690: PPUSH
22691: LD_INT 100
22693: PPUSH
22694: LD_INT 88
22696: PPUSH
22697: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22701: LD_EXP 58
22705: PPUSH
22706: LD_INT 100
22708: PPUSH
22709: LD_INT 75
22711: PPUSH
22712: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: LD_INT 88
22723: PPUSH
22724: LD_INT 53
22726: PPUSH
22727: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22731: LD_INT 8
22733: PPUSH
22734: LD_EXP 58
22738: PPUSH
22739: CALL_OW 471
// repeat wait ( 3 ) ;
22743: LD_INT 3
22745: PPUSH
22746: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22750: LD_INT 22
22752: PUSH
22753: LD_INT 4
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PUSH
22760: LD_INT 92
22762: PUSH
22763: LD_INT 100
22765: PUSH
22766: LD_INT 75
22768: PUSH
22769: LD_INT 6
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: PUSH
22778: EMPTY
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 69
22786: IFFALSE 22743
// async ;
22788: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22789: LD_EXP 58
22793: PPUSH
22794: LD_STRING D6b-Pow-1
22796: PPUSH
22797: CALL_OW 88
// repeat wait ( 3 ) ;
22801: LD_INT 3
22803: PPUSH
22804: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22808: LD_EXP 58
22812: PPUSH
22813: CALL_OW 310
22817: PPUSH
22818: CALL_OW 256
22822: PUSH
22823: LD_INT 1000
22825: LESS
22826: IFFALSE 22845
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22828: LD_EXP 58
22832: PPUSH
22833: CALL_OW 310
22837: PPUSH
22838: LD_INT 1000
22840: PPUSH
22841: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 256
22854: PUSH
22855: LD_INT 1000
22857: LESS
22858: IFFALSE 22872
// SetLives ( Powell , 1000 ) ;
22860: LD_EXP 58
22864: PPUSH
22865: LD_INT 1000
22867: PPUSH
22868: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22872: LD_EXP 58
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 296
22886: PUSH
22887: LD_INT 5
22889: LESS
22890: PUSH
22891: LD_EXP 58
22895: PPUSH
22896: CALL_OW 310
22900: PPUSH
22901: LD_EXP 63
22905: PPUSH
22906: CALL_OW 296
22910: PUSH
22911: LD_INT 5
22913: LESS
22914: OR
22915: IFFALSE 22934
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: LD_INT 100
22929: PPUSH
22930: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22934: LD_EXP 58
22938: PPUSH
22939: CALL_OW 310
22943: NOT
22944: IFFALSE 22801
// DoNotAttack ( 8 , powellBomb ) ;
22946: LD_INT 8
22948: PPUSH
22949: LD_EXP 63
22953: PPUSH
22954: CALL_OW 471
// game_speed := 4 ;
22958: LD_ADDR_OWVAR 65
22962: PUSH
22963: LD_INT 4
22965: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22966: LD_EXP 58
22970: PPUSH
22971: LD_STRING D6b-Pow-1a
22973: PPUSH
22974: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22978: LD_EXP 58
22982: PPUSH
22983: LD_EXP 63
22987: PPUSH
22988: CALL_OW 180
// sync ;
22992: SYNC
// repeat wait ( 0 0$1 ) ;
22993: LD_INT 35
22995: PPUSH
22996: CALL_OW 67
// until IsInUnit ( Powell ) ;
23000: LD_EXP 58
23004: PPUSH
23005: CALL_OW 310
23009: IFFALSE 22993
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23011: LD_INT 8
23013: PPUSH
23014: LD_EXP 58
23018: PPUSH
23019: CALL_OW 310
23023: PPUSH
23024: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23028: LD_EXP 58
23032: PPUSH
23033: LD_INT 91
23035: PPUSH
23036: LD_INT 44
23038: PPUSH
23039: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23043: LD_EXP 58
23047: PPUSH
23048: LD_INT 96
23050: PPUSH
23051: LD_INT 44
23053: PPUSH
23054: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23058: LD_EXP 58
23062: PPUSH
23063: LD_INT 96
23065: PPUSH
23066: LD_INT 41
23068: PPUSH
23069: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23073: LD_EXP 58
23077: PPUSH
23078: LD_INT 92
23080: PPUSH
23081: LD_INT 39
23083: PPUSH
23084: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23088: LD_EXP 58
23092: PPUSH
23093: LD_INT 88
23095: PPUSH
23096: LD_INT 41
23098: PPUSH
23099: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23103: LD_EXP 58
23107: PPUSH
23108: LD_INT 91
23110: PPUSH
23111: LD_INT 44
23113: PPUSH
23114: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23118: LD_EXP 58
23122: PPUSH
23123: LD_INT 96
23125: PPUSH
23126: LD_INT 44
23128: PPUSH
23129: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23133: LD_EXP 58
23137: PPUSH
23138: LD_INT 96
23140: PPUSH
23141: LD_INT 41
23143: PPUSH
23144: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23148: LD_EXP 58
23152: PPUSH
23153: LD_INT 92
23155: PPUSH
23156: LD_INT 39
23158: PPUSH
23159: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23163: LD_EXP 58
23167: PPUSH
23168: LD_INT 88
23170: PPUSH
23171: LD_INT 41
23173: PPUSH
23174: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23178: LD_EXP 58
23182: PPUSH
23183: LD_INT 91
23185: PPUSH
23186: LD_INT 44
23188: PPUSH
23189: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23193: LD_EXP 58
23197: PPUSH
23198: LD_INT 93
23200: PPUSH
23201: LD_INT 39
23203: PPUSH
23204: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23208: LD_EXP 58
23212: PPUSH
23213: LD_INT 93
23215: PPUSH
23216: LD_INT 36
23218: PPUSH
23219: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23223: LD_INT 122
23225: PPUSH
23226: CALL_OW 67
// game_speed := 4 ;
23230: LD_ADDR_OWVAR 65
23234: PUSH
23235: LD_INT 4
23237: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23238: LD_EXP 58
23242: PPUSH
23243: LD_STRING D6b-Pow-1b
23245: PPUSH
23246: CALL_OW 88
// tmp := [ ] ;
23250: LD_ADDR_VAR 0 3
23254: PUSH
23255: EMPTY
23256: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23257: LD_ADDR_VAR 0 5
23261: PUSH
23262: LD_INT 78
23264: PUSH
23265: LD_INT 47
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: LD_INT 106
23274: PUSH
23275: LD_INT 53
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: PUSH
23282: EMPTY
23283: LIST
23284: LIST
23285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23286: LD_ADDR_VAR 0 1
23290: PUSH
23291: LD_INT 22
23293: PUSH
23294: LD_INT 8
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: PUSH
23301: LD_INT 21
23303: PUSH
23304: LD_INT 3
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PUSH
23311: LD_INT 92
23313: PUSH
23314: LD_INT 90
23316: PUSH
23317: LD_INT 52
23319: PUSH
23320: LD_INT 12
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 69
23338: PUSH
23339: FOR_IN
23340: IFFALSE 23365
// tmp := tmp ^ UnitsInside ( i ) ;
23342: LD_ADDR_VAR 0 3
23346: PUSH
23347: LD_VAR 0 3
23351: PUSH
23352: LD_VAR 0 1
23356: PPUSH
23357: CALL_OW 313
23361: ADD
23362: ST_TO_ADDR
23363: GO 23339
23365: POP
23366: POP
// for i in tmp do
23367: LD_ADDR_VAR 0 1
23371: PUSH
23372: LD_VAR 0 3
23376: PUSH
23377: FOR_IN
23378: IFFALSE 23540
// begin dist := 9999 ;
23380: LD_ADDR_VAR 0 8
23384: PUSH
23385: LD_INT 9999
23387: ST_TO_ADDR
// _xy := [ ] ;
23388: LD_ADDR_VAR 0 7
23392: PUSH
23393: EMPTY
23394: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23395: LD_VAR 0 1
23399: PPUSH
23400: LD_INT 1
23402: PPUSH
23403: CALL_OW 109
// ComExitBuilding ( i ) ;
23407: LD_VAR 0 1
23411: PPUSH
23412: CALL_OW 122
// for j in xy do
23416: LD_ADDR_VAR 0 2
23420: PUSH
23421: LD_VAR 0 5
23425: PUSH
23426: FOR_IN
23427: IFFALSE 23509
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23429: LD_VAR 0 1
23433: PPUSH
23434: LD_VAR 0 2
23438: PUSH
23439: LD_INT 1
23441: ARRAY
23442: PPUSH
23443: LD_VAR 0 2
23447: PUSH
23448: LD_INT 2
23450: ARRAY
23451: PPUSH
23452: CALL_OW 297
23456: PUSH
23457: LD_VAR 0 8
23461: LESS
23462: IFFALSE 23507
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23464: LD_ADDR_VAR 0 8
23468: PUSH
23469: LD_VAR 0 1
23473: PPUSH
23474: LD_VAR 0 2
23478: PUSH
23479: LD_INT 1
23481: ARRAY
23482: PPUSH
23483: LD_VAR 0 2
23487: PUSH
23488: LD_INT 2
23490: ARRAY
23491: PPUSH
23492: CALL_OW 297
23496: ST_TO_ADDR
// _xy := j ;
23497: LD_ADDR_VAR 0 7
23501: PUSH
23502: LD_VAR 0 2
23506: ST_TO_ADDR
// end ;
23507: GO 23426
23509: POP
23510: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: LD_VAR 0 7
23520: PUSH
23521: LD_INT 1
23523: ARRAY
23524: PPUSH
23525: LD_VAR 0 7
23529: PUSH
23530: LD_INT 2
23532: ARRAY
23533: PPUSH
23534: CALL_OW 171
// end ;
23538: GO 23377
23540: POP
23541: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23542: LD_ADDR_VAR 0 4
23546: PUSH
23547: LD_VAR 0 3
23551: PPUSH
23552: LD_INT 26
23554: PUSH
23555: LD_INT 1
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 25
23564: PUSH
23565: LD_INT 1
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: PPUSH
23576: CALL_OW 72
23580: ST_TO_ADDR
// if tmp2 < 2 then
23581: LD_VAR 0 4
23585: PUSH
23586: LD_INT 2
23588: LESS
23589: IFFALSE 23658
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23591: LD_ADDR_VAR 0 4
23595: PUSH
23596: LD_INT 22
23598: PUSH
23599: LD_INT 8
23601: PUSH
23602: EMPTY
23603: LIST
23604: LIST
23605: PUSH
23606: LD_INT 26
23608: PUSH
23609: LD_INT 1
23611: PUSH
23612: EMPTY
23613: LIST
23614: LIST
23615: PUSH
23616: LD_INT 3
23618: PUSH
23619: LD_INT 25
23621: PUSH
23622: LD_INT 15
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: PUSH
23629: EMPTY
23630: LIST
23631: LIST
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: LIST
23637: PPUSH
23638: CALL_OW 69
23642: PUSH
23643: LD_EXP 60
23647: PUSH
23648: LD_EXP 61
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: DIFF
23657: ST_TO_ADDR
// if tmp2 then
23658: LD_VAR 0 4
23662: IFFALSE 23680
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23664: LD_VAR 0 4
23668: PUSH
23669: LD_INT 1
23671: ARRAY
23672: PPUSH
23673: LD_STRING D6b-ArSol1-1
23675: PPUSH
23676: CALL_OW 88
// async ;
23680: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23681: LD_EXP 58
23685: PPUSH
23686: LD_STRING D6b-Pow-2
23688: PPUSH
23689: CALL_OW 88
// wait ( 0 0$1 ) ;
23693: LD_INT 35
23695: PPUSH
23696: CALL_OW 67
// if tmp2 > 1 then
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 1
23707: GREATER
23708: IFFALSE 23726
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23710: LD_VAR 0 4
23714: PUSH
23715: LD_INT 2
23717: ARRAY
23718: PPUSH
23719: LD_STRING D6b-ArSol2-1
23721: PPUSH
23722: CALL_OW 88
// sync ;
23726: SYNC
// repeat wait ( 5 ) ;
23727: LD_INT 5
23729: PPUSH
23730: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23734: LD_INT 93
23736: PPUSH
23737: LD_INT 36
23739: PPUSH
23740: CALL_OW 428
23744: PPUSH
23745: CALL_OW 255
23749: PUSH
23750: LD_INT 4
23752: EQUAL
23753: IFFALSE 23727
// DialogueOn ;
23755: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23759: LD_INT 10
23761: PPUSH
23762: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23766: LD_EXP 58
23770: PPUSH
23771: LD_STRING D6b-Pow-2a
23773: PPUSH
23774: CALL_OW 88
// DialogueOff ;
23778: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23782: LD_EXP 58
23786: PPUSH
23787: CALL_OW 310
23791: PPUSH
23792: LD_INT 332
23794: PPUSH
23795: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23799: LD_INT 93
23801: PPUSH
23802: LD_INT 35
23804: PPUSH
23805: LD_INT 1
23807: PPUSH
23808: LD_INT 6
23810: NEG
23811: PPUSH
23812: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23816: LD_INT 35
23818: PPUSH
23819: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23823: LD_INT 332
23825: PPUSH
23826: CALL_OW 256
23830: PUSH
23831: LD_INT 1000
23833: LESS
23834: PUSH
23835: LD_INT 332
23837: PPUSH
23838: CALL_OW 300
23842: AND
23843: IFFALSE 23855
// SetLives ( kozlov_fac , 0 ) ;
23845: LD_INT 332
23847: PPUSH
23848: LD_INT 0
23850: PPUSH
23851: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23855: LD_INT 332
23857: PPUSH
23858: CALL_OW 301
23862: PUSH
23863: LD_EXP 58
23867: PPUSH
23868: CALL_OW 301
23872: OR
23873: IFFALSE 23816
// game_speed := 4 ;
23875: LD_ADDR_OWVAR 65
23879: PUSH
23880: LD_INT 4
23882: ST_TO_ADDR
// powellCenterCameraMode := false ;
23883: LD_ADDR_EXP 20
23887: PUSH
23888: LD_INT 0
23890: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23891: LD_ADDR_VAR 0 1
23895: PUSH
23896: LD_VAR 0 3
23900: PUSH
23901: LD_INT 22
23903: PUSH
23904: LD_INT 8
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 25
23913: PUSH
23914: LD_INT 2
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: PPUSH
23925: CALL_OW 69
23929: UNION
23930: PUSH
23931: FOR_IN
23932: IFFALSE 23948
// SetTag ( i , 0 ) ;
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_INT 0
23941: PPUSH
23942: CALL_OW 109
23946: GO 23931
23948: POP
23949: POP
// wait ( 0 0$3 ) ;
23950: LD_INT 105
23952: PPUSH
23953: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23957: LD_INT 93
23959: PPUSH
23960: LD_INT 35
23962: PPUSH
23963: LD_INT 1
23965: PPUSH
23966: CALL_OW 331
// DialogueOn ;
23970: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23974: LD_VAR 0 11
23978: PPUSH
23979: LD_STRING D6c-Sol3-1
23981: PPUSH
23982: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23986: LD_INT 10
23988: PPUSH
23989: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23993: LD_EXP 39
23997: PPUSH
23998: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24002: LD_EXP 39
24006: PPUSH
24007: LD_STRING D6c-JMM-1
24009: PPUSH
24010: CALL_OW 88
// if Cyrus then
24014: LD_EXP 45
24018: IFFALSE 24032
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24020: LD_EXP 45
24024: PPUSH
24025: LD_STRING D6c-Cyrus-1
24027: PPUSH
24028: CALL_OW 88
// if Bobby then
24032: LD_EXP 44
24036: IFFALSE 24050
// Say ( Bobby , D6c-Bobby-1 ) ;
24038: LD_EXP 44
24042: PPUSH
24043: LD_STRING D6c-Bobby-1
24045: PPUSH
24046: CALL_OW 88
// if Cornel then
24050: LD_EXP 50
24054: IFFALSE 24068
// Say ( Cornel , D6c-Corn-1 ) ;
24056: LD_EXP 50
24060: PPUSH
24061: LD_STRING D6c-Corn-1
24063: PPUSH
24064: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24068: LD_ADDR_VAR 0 4
24072: PUSH
24073: LD_INT 2
24075: PUSH
24076: LD_INT 22
24078: PUSH
24079: LD_INT 1
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: LD_INT 22
24088: PUSH
24089: LD_INT 4
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: LIST
24100: PUSH
24101: LD_INT 26
24103: PUSH
24104: LD_INT 1
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: LD_INT 3
24113: PUSH
24114: LD_INT 25
24116: PUSH
24117: LD_INT 16
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 25
24126: PUSH
24127: LD_INT 12
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: LIST
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: LIST
24143: PPUSH
24144: CALL_OW 69
24148: PUSH
24149: LD_VAR 0 11
24153: PUSH
24154: LD_EXP 39
24158: UNION
24159: PUSH
24160: LD_EXP 59
24164: UNION
24165: PUSH
24166: EMPTY
24167: LIST
24168: DIFF
24169: ST_TO_ADDR
// if tmp2 then
24170: LD_VAR 0 4
24174: IFFALSE 24192
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24176: LD_VAR 0 4
24180: PUSH
24181: LD_INT 1
24183: ARRAY
24184: PPUSH
24185: LD_STRING D6c-Sol1-1
24187: PPUSH
24188: CALL_OW 88
// if Lisa then
24192: LD_EXP 42
24196: IFFALSE 24210
// Say ( Lisa , D6c-Lisa-1 ) ;
24198: LD_EXP 42
24202: PPUSH
24203: LD_STRING D6c-Lisa-1
24205: PPUSH
24206: CALL_OW 88
// if Gary then
24210: LD_EXP 51
24214: IFFALSE 24228
// Say ( Gary , D6c-Gary-1 ) ;
24216: LD_EXP 51
24220: PPUSH
24221: LD_STRING D6c-Gary-1
24223: PPUSH
24224: CALL_OW 88
// if Donaldson then
24228: LD_EXP 43
24232: IFFALSE 24246
// Say ( Donaldson , D6c-Don-1 ) ;
24234: LD_EXP 43
24238: PPUSH
24239: LD_STRING D6c-Don-1
24241: PPUSH
24242: CALL_OW 88
// if tmp2 > 1 then
24246: LD_VAR 0 4
24250: PUSH
24251: LD_INT 1
24253: GREATER
24254: IFFALSE 24272
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24256: LD_VAR 0 4
24260: PUSH
24261: LD_INT 2
24263: ARRAY
24264: PPUSH
24265: LD_STRING D6c-Sol2-1
24267: PPUSH
24268: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24272: LD_VAR 0 11
24276: PPUSH
24277: LD_STRING D6c-Sol3-2
24279: PPUSH
24280: CALL_OW 88
// dwait ( 0 0$1 ) ;
24284: LD_INT 35
24286: PPUSH
24287: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24291: LD_EXP 39
24295: PPUSH
24296: LD_STRING D6c-JMM-2
24298: PPUSH
24299: CALL_OW 88
// DialogueOff ;
24303: CALL_OW 7
// Video ( false ) ;
24307: LD_INT 0
24309: PPUSH
24310: CALL 102423 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24314: LD_INT 22
24316: PUSH
24317: LD_INT 4
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PPUSH
24324: CALL_OW 69
24328: PPUSH
24329: LD_INT 1
24331: PPUSH
24332: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24336: LD_INT 4
24338: PPUSH
24339: LD_INT 4
24341: PPUSH
24342: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24346: LD_ADDR_VAR 0 1
24350: PUSH
24351: LD_INT 4
24353: PPUSH
24354: LD_INT 1
24356: PPUSH
24357: LD_INT 2
24359: PPUSH
24360: CALL 65777 0 3
24364: PUSH
24365: FOR_IN
24366: IFFALSE 24403
// if GetTech ( i , 1 ) <> state_researched then
24368: LD_VAR 0 1
24372: PPUSH
24373: LD_INT 1
24375: PPUSH
24376: CALL_OW 321
24380: PUSH
24381: LD_INT 2
24383: NONEQUAL
24384: IFFALSE 24401
// SetTech ( i , 1 , state_researched ) ;
24386: LD_VAR 0 1
24390: PPUSH
24391: LD_INT 1
24393: PPUSH
24394: LD_INT 2
24396: PPUSH
24397: CALL_OW 322
24401: GO 24365
24403: POP
24404: POP
// missionStage := 6 ;
24405: LD_ADDR_EXP 15
24409: PUSH
24410: LD_INT 6
24412: ST_TO_ADDR
// activeAttacks := true ;
24413: LD_ADDR_EXP 16
24417: PUSH
24418: LD_INT 1
24420: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24421: LD_STRING M2
24423: PPUSH
24424: CALL_OW 337
// SaveForQuickRestart ;
24428: CALL_OW 22
// wait ( 0 0$40 ) ;
24432: LD_INT 1400
24434: PPUSH
24435: CALL_OW 67
// DialogueOn ;
24439: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-1
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-1
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-2
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-2
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-3
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-3
24510: PPUSH
24511: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24515: LD_EXP 62
24519: PPUSH
24520: LD_STRING D7-Friend-4
24522: PPUSH
24523: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24527: LD_EXP 39
24531: PPUSH
24532: LD_STRING D7-JMM-4
24534: PPUSH
24535: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24539: LD_EXP 62
24543: PPUSH
24544: LD_STRING D7-Friend-5
24546: PPUSH
24547: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24551: LD_EXP 39
24555: PPUSH
24556: LD_STRING D7-JMM-5
24558: PPUSH
24559: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24563: LD_EXP 62
24567: PPUSH
24568: LD_STRING D7-Friend-6
24570: PPUSH
24571: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24575: LD_EXP 39
24579: PPUSH
24580: LD_STRING D7-JMM-6
24582: PPUSH
24583: CALL_OW 88
// DialogueOff ;
24587: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24591: LD_STRING Mlegion
24593: PPUSH
24594: CALL_OW 337
// RebuildKozlovFactory ;
24598: CALL 4892 0 0
// end ;
24602: PPOPN 13
24604: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24605: LD_EXP 20
24609: PUSH
24610: LD_EXP 58
24614: PPUSH
24615: CALL_OW 300
24619: AND
24620: IFFALSE 24662
24622: GO 24624
24624: DISABLE
// begin enable ;
24625: ENABLE
// if IsInUnit ( Powell ) then
24626: LD_EXP 58
24630: PPUSH
24631: CALL_OW 310
24635: IFFALSE 24653
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24637: LD_EXP 58
24641: PPUSH
24642: CALL_OW 310
24646: PPUSH
24647: CALL_OW 85
24651: GO 24662
// CenterOnUnits ( Powell ) ;
24653: LD_EXP 58
24657: PPUSH
24658: CALL_OW 85
// end ;
24662: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24663: LD_INT 22
24665: PUSH
24666: LD_INT 8
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: PUSH
24673: LD_INT 34
24675: PUSH
24676: LD_INT 48
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PPUSH
24687: CALL_OW 69
24691: IFFALSE 24965
24693: GO 24695
24695: DISABLE
24696: LD_INT 0
24698: PPUSH
24699: PPUSH
// begin if missionStage < 9 then
24700: LD_EXP 15
24704: PUSH
24705: LD_INT 9
24707: LESS
24708: IFFALSE 24718
// missionStage := 9 ;
24710: LD_ADDR_EXP 15
24714: PUSH
24715: LD_INT 9
24717: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24718: LD_ADDR_VAR 0 1
24722: PUSH
24723: LD_INT 22
24725: PUSH
24726: LD_INT 8
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 34
24735: PUSH
24736: LD_INT 48
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PUSH
24743: EMPTY
24744: LIST
24745: LIST
24746: PPUSH
24747: CALL_OW 69
24751: PUSH
24752: LD_INT 1
24754: ARRAY
24755: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24756: LD_INT 175
24758: PPUSH
24759: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24763: LD_EXP 12
24767: PUSH
24768: LD_EXP 3
24772: PUSH
24773: LD_INT 0
24775: PUSH
24776: LD_INT 2
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: IN
24783: OR
24784: IFFALSE 24807
// target := [ 68 , 108 , 1 ] else
24786: LD_ADDR_VAR 0 2
24790: PUSH
24791: LD_INT 68
24793: PUSH
24794: LD_INT 108
24796: PUSH
24797: LD_INT 1
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: ST_TO_ADDR
24805: GO 24826
// target := [ 181 , 88 , 2 ] ;
24807: LD_ADDR_VAR 0 2
24811: PUSH
24812: LD_INT 181
24814: PUSH
24815: LD_INT 88
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: LIST
24825: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24826: LD_VAR 0 1
24830: PPUSH
24831: LD_VAR 0 2
24835: PUSH
24836: LD_INT 1
24838: ARRAY
24839: PPUSH
24840: LD_VAR 0 2
24844: PUSH
24845: LD_INT 2
24847: ARRAY
24848: PPUSH
24849: CALL_OW 176
// if target [ 3 ] = 1 then
24853: LD_VAR 0 2
24857: PUSH
24858: LD_INT 3
24860: ARRAY
24861: PUSH
24862: LD_INT 1
24864: EQUAL
24865: IFFALSE 24881
// SayRadio ( Kurt , D12-Kurt-1 ) else
24867: LD_EXP 60
24871: PPUSH
24872: LD_STRING D12-Kurt-1
24874: PPUSH
24875: CALL_OW 94
24879: GO 24905
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24881: LD_EXP 60
24885: PPUSH
24886: LD_STRING D12a-Kurt-1
24888: PPUSH
24889: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24893: LD_EXP 74
24897: PPUSH
24898: LD_STRING D12a-Roth-1
24900: PPUSH
24901: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24905: LD_INT 350
24907: PPUSH
24908: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24912: LD_VAR 0 1
24916: PPUSH
24917: LD_INT 22
24919: PUSH
24920: LD_INT 8
24922: PUSH
24923: EMPTY
24924: LIST
24925: LIST
24926: PUSH
24927: LD_INT 23
24929: PUSH
24930: LD_INT 2
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: LD_INT 30
24939: PUSH
24940: LD_INT 3
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: LIST
24951: PPUSH
24952: CALL_OW 69
24956: PUSH
24957: LD_INT 1
24959: ARRAY
24960: PPUSH
24961: CALL_OW 228
// end ;
24965: PPOPN 2
24967: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24968: LD_EXP 60
24972: PPUSH
24973: CALL_OW 256
24977: PUSH
24978: LD_INT 999
24980: LESS
24981: PUSH
24982: LD_INT 22
24984: PUSH
24985: LD_INT 8
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: LD_INT 21
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PUSH
25002: LD_INT 23
25004: PUSH
25005: LD_INT 2
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: LIST
25016: PPUSH
25017: CALL_OW 69
25021: PUSH
25022: LD_INT 9
25024: PUSH
25025: LD_INT 8
25027: PUSH
25028: LD_INT 7
25030: PUSH
25031: LD_INT 6
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: PUSH
25040: LD_OWVAR 67
25044: ARRAY
25045: LESSEQUAL
25046: OR
25047: PUSH
25048: LD_INT 22
25050: PUSH
25051: LD_INT 8
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 34
25060: PUSH
25061: LD_INT 48
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 69
25076: NOT
25077: AND
25078: PUSH
25079: LD_EXP 60
25083: PPUSH
25084: CALL_OW 302
25088: AND
25089: PUSH
25090: LD_INT 5
25092: PPUSH
25093: LD_INT 22
25095: PUSH
25096: LD_INT 1
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PPUSH
25103: CALL_OW 70
25107: AND
25108: IFFALSE 25821
25110: GO 25112
25112: DISABLE
25113: LD_INT 0
25115: PPUSH
25116: PPUSH
25117: PPUSH
// begin DialogueOn ;
25118: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25122: LD_EXP 39
25126: PPUSH
25127: LD_STRING D13-JMM-1
25129: PPUSH
25130: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25134: LD_EXP 60
25138: PPUSH
25139: LD_STRING D13-Kurt-1
25141: PPUSH
25142: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25146: LD_EXP 39
25150: PPUSH
25151: LD_STRING D13-JMM-2
25153: PPUSH
25154: CALL_OW 88
// if FakeInfo then
25158: LD_EXP 12
25162: IFFALSE 25182
// begin Say ( Kurt , D13-Kurt-2 ) ;
25164: LD_EXP 60
25168: PPUSH
25169: LD_STRING D13-Kurt-2
25171: PPUSH
25172: CALL_OW 88
// DialogueOff ;
25176: CALL_OW 7
// exit ;
25180: GO 25821
// end ; if not KurtStatus then
25182: LD_EXP 3
25186: NOT
25187: IFFALSE 25203
// Say ( Kurt , D13-Kurt-2b ) else
25189: LD_EXP 60
25193: PPUSH
25194: LD_STRING D13-Kurt-2b
25196: PPUSH
25197: CALL_OW 88
25201: GO 25215
// Say ( Kurt , D13-Kurt-2a ) ;
25203: LD_EXP 60
25207: PPUSH
25208: LD_STRING D13-Kurt-2a
25210: PPUSH
25211: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25215: LD_EXP 39
25219: PPUSH
25220: LD_STRING D13-JMM-3
25222: PPUSH
25223: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25227: LD_EXP 60
25231: PPUSH
25232: LD_STRING D13-Kurt-3
25234: PPUSH
25235: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25239: LD_EXP 39
25243: PPUSH
25244: LD_STRING D13-JMM-4
25246: PPUSH
25247: CALL_OW 88
// DialogueOff ;
25251: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25255: LD_STRING MlegionOut
25257: PPUSH
25258: CALL_OW 337
// legionDestroyed := true ;
25262: LD_ADDR_EXP 22
25266: PUSH
25267: LD_INT 1
25269: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25270: LD_INT 3
25272: PPUSH
25273: CALL 35477 0 1
// KillUnit ( Kozlov ) ;
25277: LD_EXP 61
25281: PPUSH
25282: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25286: LD_ADDR_VAR 0 1
25290: PUSH
25291: LD_INT 22
25293: PUSH
25294: LD_INT 8
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: PUSH
25301: LD_INT 23
25303: PUSH
25304: LD_INT 3
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PUSH
25311: LD_INT 3
25313: PUSH
25314: LD_INT 21
25316: PUSH
25317: LD_INT 33
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: PPUSH
25333: CALL_OW 69
25337: PUSH
25338: FOR_IN
25339: IFFALSE 25352
// KillUnit ( i ) ;
25341: LD_VAR 0 1
25345: PPUSH
25346: CALL_OW 66
25350: GO 25338
25352: POP
25353: POP
// ChangeSideFog ( 8 , 1 ) ;
25354: LD_INT 8
25356: PPUSH
25357: LD_INT 1
25359: PPUSH
25360: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25364: LD_ADDR_VAR 0 2
25368: PUSH
25369: LD_INT 22
25371: PUSH
25372: LD_INT 8
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 21
25381: PUSH
25382: LD_INT 1
25384: PUSH
25385: EMPTY
25386: LIST
25387: LIST
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PPUSH
25393: CALL_OW 69
25397: PUSH
25398: LD_EXP 61
25402: PUSH
25403: LD_EXP 60
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: DIFF
25412: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25413: LD_VAR 0 2
25417: PUSH
25418: LD_INT 6
25420: PUSH
25421: LD_INT 5
25423: PUSH
25424: LD_INT 4
25426: PUSH
25427: LD_INT 3
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: PUSH
25436: LD_OWVAR 67
25440: ARRAY
25441: GREATEREQUAL
25442: IFFALSE 25620
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25444: LD_ADDR_VAR 0 3
25448: PUSH
25449: LD_INT 6
25451: PUSH
25452: LD_INT 5
25454: PUSH
25455: LD_INT 4
25457: PUSH
25458: LD_INT 3
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: PUSH
25467: LD_OWVAR 67
25471: ARRAY
25472: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25473: LD_ADDR_VAR 0 1
25477: PUSH
25478: DOUBLE
25479: LD_VAR 0 2
25483: PUSH
25484: LD_VAR 0 3
25488: PUSH
25489: LD_INT 1
25491: PLUS
25492: MINUS
25493: INC
25494: ST_TO_ADDR
25495: LD_INT 1
25497: PUSH
25498: FOR_DOWNTO
25499: IFFALSE 25616
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25501: LD_ADDR_EXP 38
25505: PUSH
25506: LD_EXP 38
25510: PUSH
25511: LD_VAR 0 2
25515: PUSH
25516: LD_VAR 0 1
25520: ARRAY
25521: ADD
25522: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25523: LD_VAR 0 2
25527: PUSH
25528: LD_VAR 0 1
25532: ARRAY
25533: PPUSH
25534: CALL_OW 310
25538: IFFALSE 25555
// ComExitBuilding ( tmp [ i ] ) ;
25540: LD_VAR 0 2
25544: PUSH
25545: LD_VAR 0 1
25549: ARRAY
25550: PPUSH
25551: CALL_OW 122
// if IsInUnit ( i ) then
25555: LD_VAR 0 1
25559: PPUSH
25560: CALL_OW 310
25564: IFFALSE 25581
// ComExitVehicle ( tmp [ i ] ) ;
25566: LD_VAR 0 2
25570: PUSH
25571: LD_VAR 0 1
25575: ARRAY
25576: PPUSH
25577: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25581: LD_VAR 0 2
25585: PUSH
25586: LD_VAR 0 1
25590: ARRAY
25591: PPUSH
25592: LD_INT 34
25594: PUSH
25595: LD_INT 0
25597: PPUSH
25598: LD_INT 6
25600: PPUSH
25601: CALL_OW 12
25605: PLUS
25606: PPUSH
25607: LD_INT 1
25609: PPUSH
25610: CALL_OW 171
// end ;
25614: GO 25498
25616: POP
25617: POP
// end else
25618: GO 25630
// x := tmp ;
25620: LD_ADDR_VAR 0 3
25624: PUSH
25625: LD_VAR 0 2
25629: ST_TO_ADDR
// for i := tmp downto tmp - x do
25630: LD_ADDR_VAR 0 1
25634: PUSH
25635: DOUBLE
25636: LD_VAR 0 2
25640: INC
25641: ST_TO_ADDR
25642: LD_VAR 0 2
25646: PUSH
25647: LD_VAR 0 3
25651: MINUS
25652: PUSH
25653: FOR_DOWNTO
25654: IFFALSE 25708
// begin if IsInUnit ( tmp [ i ] ) then
25656: LD_VAR 0 2
25660: PUSH
25661: LD_VAR 0 1
25665: ARRAY
25666: PPUSH
25667: CALL_OW 310
25671: IFFALSE 25688
// ComExitVehicle ( tmp [ i ] ) ;
25673: LD_VAR 0 2
25677: PUSH
25678: LD_VAR 0 1
25682: ARRAY
25683: PPUSH
25684: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25688: LD_VAR 0 2
25692: PUSH
25693: LD_VAR 0 1
25697: ARRAY
25698: PPUSH
25699: LD_INT 1
25701: PPUSH
25702: CALL_OW 235
// end ;
25706: GO 25653
25708: POP
25709: POP
// SetSide ( Kurt , 1 ) ;
25710: LD_EXP 60
25714: PPUSH
25715: LD_INT 1
25717: PPUSH
25718: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25722: LD_INT 22
25724: PUSH
25725: LD_INT 8
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 21
25734: PUSH
25735: LD_INT 3
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: PPUSH
25746: CALL_OW 69
25750: PPUSH
25751: LD_INT 1
25753: PPUSH
25754: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25758: LD_INT 8
25760: PPUSH
25761: LD_INT 1
25763: PPUSH
25764: LD_INT 1
25766: PPUSH
25767: LD_INT 1
25769: PPUSH
25770: CALL_OW 80
// wait ( 1 1$20 ) ;
25774: LD_INT 2800
25776: PPUSH
25777: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25781: LD_EXP 62
25785: PPUSH
25786: LD_INT 37
25788: PPUSH
25789: LD_INT 1
25791: PPUSH
25792: LD_INT 0
25794: PPUSH
25795: CALL_OW 48
// wait ( 0 0$1 ) ;
25799: LD_INT 35
25801: PPUSH
25802: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25806: LD_EXP 62
25810: PPUSH
25811: LD_INT 60
25813: PPUSH
25814: LD_INT 95
25816: PPUSH
25817: CALL_OW 111
// end ;
25821: PPOPN 3
25823: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25824: LD_EXP 22
25828: NOT
25829: PUSH
25830: LD_INT 22
25832: PUSH
25833: LD_INT 8
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 21
25842: PUSH
25843: LD_INT 1
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PPUSH
25854: CALL_OW 69
25858: PUSH
25859: LD_INT 0
25861: EQUAL
25862: AND
25863: IFFALSE 25883
25865: GO 25867
25867: DISABLE
// begin legionDestroyed := true ;
25868: LD_ADDR_EXP 22
25872: PUSH
25873: LD_INT 1
25875: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25876: LD_STRING MlegionOut
25878: PPUSH
25879: CALL_OW 337
// end ;
25883: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25884: LD_EXP 38
25888: IFFALSE 25963
25890: GO 25892
25892: DISABLE
25893: LD_INT 0
25895: PPUSH
// begin enable ;
25896: ENABLE
// for i in legionEscapeUnits do
25897: LD_ADDR_VAR 0 1
25901: PUSH
25902: LD_EXP 38
25906: PUSH
25907: FOR_IN
25908: IFFALSE 25961
// begin if IsInArea ( i , legionEscapeArea ) then
25910: LD_VAR 0 1
25914: PPUSH
25915: LD_INT 31
25917: PPUSH
25918: CALL_OW 308
25922: IFFALSE 25935
// RemoveUnit ( i ) else
25924: LD_VAR 0 1
25928: PPUSH
25929: CALL_OW 64
25933: GO 25959
// if not HasTask ( i ) then
25935: LD_VAR 0 1
25939: PPUSH
25940: CALL_OW 314
25944: NOT
25945: IFFALSE 25959
// ComMoveToArea ( i , legionEscapeArea ) ;
25947: LD_VAR 0 1
25951: PPUSH
25952: LD_INT 31
25954: PPUSH
25955: CALL_OW 113
// end ;
25959: GO 25907
25961: POP
25962: POP
// end ;
25963: PPOPN 1
25965: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25966: LD_INT 1
25968: PPUSH
25969: LD_EXP 62
25973: PPUSH
25974: CALL_OW 292
25978: IFFALSE 26276
25980: GO 25982
25982: DISABLE
25983: LD_INT 0
25985: PPUSH
// begin wait ( 0 0$2 ) ;
25986: LD_INT 70
25988: PPUSH
25989: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25993: LD_EXP 62
25997: PPUSH
25998: CALL_OW 87
// DialogueOn ;
26002: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26006: LD_EXP 39
26010: PPUSH
26011: LD_STRING D14-JMM-1
26013: PPUSH
26014: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26018: LD_EXP 62
26022: PPUSH
26023: LD_STRING D14-Friend-1
26025: PPUSH
26026: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26030: LD_EXP 39
26034: PPUSH
26035: LD_STRING D14-JMM-2
26037: PPUSH
26038: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26042: LD_EXP 62
26046: PPUSH
26047: LD_STRING D14-Friend-2
26049: PPUSH
26050: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26054: LD_EXP 39
26058: PPUSH
26059: LD_STRING D14-JMM-3
26061: PPUSH
26062: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26066: LD_EXP 62
26070: PPUSH
26071: LD_STRING D14-Friend-3
26073: PPUSH
26074: CALL_OW 88
// DialogueOff ;
26078: CALL_OW 7
// dec = Query ( Q14 ) ;
26082: LD_ADDR_VAR 0 1
26086: PUSH
26087: LD_STRING Q14
26089: PPUSH
26090: CALL_OW 97
26094: ST_TO_ADDR
// if dec = 1 then
26095: LD_VAR 0 1
26099: PUSH
26100: LD_INT 1
26102: EQUAL
26103: IFFALSE 26137
// begin DialogueOn ;
26105: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26109: LD_EXP 39
26113: PPUSH
26114: LD_STRING D14a-JMM-1
26116: PPUSH
26117: CALL_OW 88
// DialogueOff ;
26121: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26125: LD_EXP 62
26129: PPUSH
26130: LD_INT 1
26132: PPUSH
26133: CALL_OW 235
// end ; if dec = 2 then
26137: LD_VAR 0 1
26141: PUSH
26142: LD_INT 2
26144: EQUAL
26145: IFFALSE 26198
// begin DialogueOn ;
26147: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26151: LD_EXP 39
26155: PPUSH
26156: LD_STRING D14b-JMM-1
26158: PPUSH
26159: CALL_OW 88
// DialogueOff ;
26163: CALL_OW 7
// wait ( 0 0$1 ) ;
26167: LD_INT 35
26169: PPUSH
26170: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26174: LD_EXP 62
26178: PPUSH
26179: LD_INT 9
26181: PPUSH
26182: LD_INT 2
26184: PPUSH
26185: CALL_OW 111
// AddComHold ( Friend ) ;
26189: LD_EXP 62
26193: PPUSH
26194: CALL_OW 200
// end ; if dec = 3 then
26198: LD_VAR 0 1
26202: PUSH
26203: LD_INT 3
26205: EQUAL
26206: IFFALSE 26276
// begin DialogueOn ;
26208: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26212: LD_EXP 39
26216: PPUSH
26217: LD_STRING D14c-JMM-1
26219: PPUSH
26220: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26224: LD_EXP 62
26228: PPUSH
26229: LD_STRING D14c-Friend-1
26231: PPUSH
26232: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26236: LD_EXP 39
26240: PPUSH
26241: LD_STRING D14c-JMM-2
26243: PPUSH
26244: CALL_OW 88
// DialogueOff ;
26248: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26252: LD_EXP 62
26256: PPUSH
26257: LD_INT 9
26259: PPUSH
26260: LD_INT 2
26262: PPUSH
26263: CALL_OW 111
// AddComHold ( Friend ) ;
26267: LD_EXP 62
26271: PPUSH
26272: CALL_OW 200
// end ; end ;
26276: PPOPN 1
26278: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26279: LD_INT 9
26281: PPUSH
26282: LD_INT 2
26284: PPUSH
26285: CALL_OW 428
26289: PUSH
26290: LD_EXP 62
26294: EQUAL
26295: PUSH
26296: LD_EXP 62
26300: PPUSH
26301: CALL_OW 255
26305: PUSH
26306: LD_INT 8
26308: EQUAL
26309: AND
26310: IFFALSE 26324
26312: GO 26314
26314: DISABLE
// RemoveUnit ( Friend ) ;
26315: LD_EXP 62
26319: PPUSH
26320: CALL_OW 64
26324: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26325: LD_EXP 14
26329: PUSH
26330: LD_INT 31500
26332: GREATEREQUAL
26333: PUSH
26334: LD_EXP 7
26338: AND
26339: PUSH
26340: LD_EXP 2
26344: AND
26345: IFFALSE 26775
26347: GO 26349
26349: DISABLE
26350: LD_INT 0
26352: PPUSH
26353: PPUSH
26354: PPUSH
// begin missionStage := 7 ;
26355: LD_ADDR_EXP 15
26359: PUSH
26360: LD_INT 7
26362: ST_TO_ADDR
// uc_side = 1 ;
26363: LD_ADDR_OWVAR 20
26367: PUSH
26368: LD_INT 1
26370: ST_TO_ADDR
// uc_nation = 1 ;
26371: LD_ADDR_OWVAR 21
26375: PUSH
26376: LD_INT 1
26378: ST_TO_ADDR
// for i = 1 to 5 do
26379: LD_ADDR_VAR 0 1
26383: PUSH
26384: DOUBLE
26385: LD_INT 1
26387: DEC
26388: ST_TO_ADDR
26389: LD_INT 5
26391: PUSH
26392: FOR_TO
26393: IFFALSE 26489
// begin vc_engine = 3 ;
26395: LD_ADDR_OWVAR 39
26399: PUSH
26400: LD_INT 3
26402: ST_TO_ADDR
// vc_control = 3 ;
26403: LD_ADDR_OWVAR 38
26407: PUSH
26408: LD_INT 3
26410: ST_TO_ADDR
// vc_chassis = 3 ;
26411: LD_ADDR_OWVAR 37
26415: PUSH
26416: LD_INT 3
26418: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26419: LD_ADDR_OWVAR 40
26423: PUSH
26424: LD_INT 5
26426: PUSH
26427: LD_INT 9
26429: PUSH
26430: LD_INT 7
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: LIST
26437: PUSH
26438: LD_INT 1
26440: PPUSH
26441: LD_INT 3
26443: PPUSH
26444: CALL_OW 12
26448: ARRAY
26449: ST_TO_ADDR
// veh = CreateVehicle ;
26450: LD_ADDR_VAR 0 2
26454: PUSH
26455: CALL_OW 45
26459: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26460: LD_VAR 0 2
26464: PPUSH
26465: LD_INT 1
26467: PPUSH
26468: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26472: LD_VAR 0 2
26476: PPUSH
26477: LD_INT 19
26479: PPUSH
26480: LD_INT 0
26482: PPUSH
26483: CALL_OW 49
// end ;
26487: GO 26392
26489: POP
26490: POP
// vc_engine = 3 ;
26491: LD_ADDR_OWVAR 39
26495: PUSH
26496: LD_INT 3
26498: ST_TO_ADDR
// vc_control = 1 ;
26499: LD_ADDR_OWVAR 38
26503: PUSH
26504: LD_INT 1
26506: ST_TO_ADDR
// vc_chassis = 3 ;
26507: LD_ADDR_OWVAR 37
26511: PUSH
26512: LD_INT 3
26514: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26515: LD_ADDR_OWVAR 40
26519: PUSH
26520: LD_INT 5
26522: PUSH
26523: LD_INT 9
26525: PUSH
26526: LD_INT 7
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: LIST
26533: PUSH
26534: LD_INT 1
26536: PPUSH
26537: LD_INT 3
26539: PPUSH
26540: CALL_OW 12
26544: ARRAY
26545: ST_TO_ADDR
// vehG = CreateVehicle ;
26546: LD_ADDR_VAR 0 3
26550: PUSH
26551: CALL_OW 45
26555: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26556: LD_VAR 0 3
26560: PPUSH
26561: LD_INT 1
26563: PPUSH
26564: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26568: LD_VAR 0 3
26572: PPUSH
26573: LD_INT 19
26575: PPUSH
26576: LD_INT 0
26578: PPUSH
26579: CALL_OW 49
// if JMMGirl = 1 then
26583: LD_EXP 7
26587: PUSH
26588: LD_INT 1
26590: EQUAL
26591: IFFALSE 26647
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26593: LD_ADDR_EXP 40
26597: PUSH
26598: LD_STRING Joan
26600: PPUSH
26601: LD_INT 1
26603: PPUSH
26604: LD_STRING 14_
26606: PPUSH
26607: CALL 65714 0 3
26611: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26612: LD_EXP 40
26616: PPUSH
26617: LD_VAR 0 3
26621: PPUSH
26622: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26626: LD_VAR 0 3
26630: PPUSH
26631: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26635: LD_EXP 40
26639: PPUSH
26640: LD_STRING D10BW-Joan-1
26642: PPUSH
26643: CALL_OW 94
// end ; if JMMGirl = 2 then
26647: LD_EXP 7
26651: PUSH
26652: LD_INT 2
26654: EQUAL
26655: IFFALSE 26711
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26657: LD_ADDR_EXP 42
26661: PUSH
26662: LD_STRING Lisa
26664: PPUSH
26665: LD_INT 1
26667: PPUSH
26668: LD_STRING 14_
26670: PPUSH
26671: CALL 65714 0 3
26675: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26676: LD_EXP 42
26680: PPUSH
26681: LD_VAR 0 3
26685: PPUSH
26686: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26690: LD_VAR 0 3
26694: PPUSH
26695: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26699: LD_EXP 42
26703: PPUSH
26704: LD_STRING D10BW-Lisa-1
26706: PPUSH
26707: CALL_OW 94
// end ; if JMMGirl = 3 then
26711: LD_EXP 7
26715: PUSH
26716: LD_INT 3
26718: EQUAL
26719: IFFALSE 26775
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26721: LD_ADDR_EXP 54
26725: PUSH
26726: LD_STRING Connie
26728: PPUSH
26729: LD_INT 1
26731: PPUSH
26732: LD_STRING 14_
26734: PPUSH
26735: CALL 65714 0 3
26739: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26740: LD_EXP 54
26744: PPUSH
26745: LD_VAR 0 3
26749: PPUSH
26750: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26754: LD_VAR 0 3
26758: PPUSH
26759: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26763: LD_EXP 54
26767: PPUSH
26768: LD_STRING D10BW-Con-1
26770: PPUSH
26771: CALL_OW 94
// end ; end ;
26775: PPOPN 3
26777: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26778: LD_EXP 14
26782: PUSH
26783: LD_INT 94500
26785: GREATEREQUAL
26786: IFFALSE 27198
26788: GO 26790
26790: DISABLE
26791: LD_INT 0
26793: PPUSH
26794: PPUSH
26795: PPUSH
// begin tmp := PrepareStevensSquad ;
26796: LD_ADDR_VAR 0 3
26800: PUSH
26801: CALL 2226 0 0
26805: ST_TO_ADDR
// if not tmp then
26806: LD_VAR 0 3
26810: NOT
26811: IFFALSE 26815
// exit ;
26813: GO 27198
// uc_side := 1 ;
26815: LD_ADDR_OWVAR 20
26819: PUSH
26820: LD_INT 1
26822: ST_TO_ADDR
// uc_nation := 1 ;
26823: LD_ADDR_OWVAR 21
26827: PUSH
26828: LD_INT 1
26830: ST_TO_ADDR
// for i in tmp do
26831: LD_ADDR_VAR 0 1
26835: PUSH
26836: LD_VAR 0 3
26840: PUSH
26841: FOR_IN
26842: IFFALSE 26939
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26844: LD_INT 3
26846: PPUSH
26847: LD_INT 3
26849: PPUSH
26850: LD_INT 1
26852: PPUSH
26853: LD_INT 5
26855: PUSH
26856: LD_INT 9
26858: PUSH
26859: LD_INT 7
26861: PUSH
26862: EMPTY
26863: LIST
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 1
26869: PPUSH
26870: LD_INT 3
26872: PPUSH
26873: CALL_OW 12
26877: ARRAY
26878: PPUSH
26879: LD_INT 40
26881: PPUSH
26882: CALL 70578 0 5
// veh := CreateVehicle ;
26886: LD_ADDR_VAR 0 2
26890: PUSH
26891: CALL_OW 45
26895: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26896: LD_VAR 0 2
26900: PPUSH
26901: LD_INT 1
26903: PPUSH
26904: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26908: LD_VAR 0 2
26912: PPUSH
26913: LD_INT 19
26915: PPUSH
26916: LD_INT 0
26918: PPUSH
26919: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26923: LD_VAR 0 1
26927: PPUSH
26928: LD_VAR 0 2
26932: PPUSH
26933: CALL_OW 52
// end ;
26937: GO 26841
26939: POP
26940: POP
// missionStage := 8 ;
26941: LD_ADDR_EXP 15
26945: PUSH
26946: LD_INT 8
26948: ST_TO_ADDR
// DialogueOn ;
26949: CALL_OW 6
// if Stevens then
26953: LD_EXP 41
26957: IFFALSE 27071
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26959: LD_EXP 41
26963: PPUSH
26964: CALL_OW 310
26968: PPUSH
26969: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26973: LD_EXP 41
26977: PPUSH
26978: LD_STRING D8-Huck-1
26980: PPUSH
26981: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26985: LD_EXP 39
26989: PPUSH
26990: LD_STRING D8-JMM-1
26992: PPUSH
26993: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26997: LD_EXP 41
27001: PPUSH
27002: LD_STRING D8-Huck-2
27004: PPUSH
27005: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27009: LD_EXP 39
27013: PPUSH
27014: LD_STRING D8-JMM-2
27016: PPUSH
27017: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27021: LD_EXP 41
27025: PPUSH
27026: LD_STRING D8-Huck-3
27028: PPUSH
27029: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27033: LD_EXP 39
27037: PPUSH
27038: LD_STRING D8-JMM-3
27040: PPUSH
27041: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27045: LD_EXP 41
27049: PPUSH
27050: LD_STRING D8-Huck-4
27052: PPUSH
27053: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27057: LD_EXP 39
27061: PPUSH
27062: LD_STRING D8-JMM-4
27064: PPUSH
27065: CALL_OW 88
// end else
27069: GO 27181
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27071: LD_EXP 55
27075: PPUSH
27076: CALL_OW 310
27080: PPUSH
27081: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27085: LD_EXP 55
27089: PPUSH
27090: LD_STRING D8-Huck-1
27092: PPUSH
27093: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27097: LD_EXP 39
27101: PPUSH
27102: LD_STRING D8-JMM-1a
27104: PPUSH
27105: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27109: LD_EXP 55
27113: PPUSH
27114: LD_STRING D8-Huck-2
27116: PPUSH
27117: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27121: LD_EXP 39
27125: PPUSH
27126: LD_STRING D8-JMM-2
27128: PPUSH
27129: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27133: LD_EXP 55
27137: PPUSH
27138: LD_STRING D8-Huck-3
27140: PPUSH
27141: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27145: LD_EXP 39
27149: PPUSH
27150: LD_STRING D8-JMM-3
27152: PPUSH
27153: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27157: LD_EXP 55
27161: PPUSH
27162: LD_STRING D8-Huck-4
27164: PPUSH
27165: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27169: LD_EXP 39
27173: PPUSH
27174: LD_STRING D8-JMM-4
27176: PPUSH
27177: CALL_OW 88
// end ; DialogueOff ;
27181: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27185: LD_INT 25
27187: PPUSH
27188: LD_INT 1
27190: PPUSH
27191: LD_INT 1
27193: PPUSH
27194: CALL_OW 322
// end ;
27198: PPOPN 3
27200: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27201: LD_INT 1
27203: PPUSH
27204: LD_EXP 71
27208: PPUSH
27209: CALL_OW 292
27213: IFFALSE 27464
27215: GO 27217
27217: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27218: LD_EXP 71
27222: PPUSH
27223: CALL_OW 87
// DialogueOn ;
27227: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27231: LD_EXP 39
27235: PPUSH
27236: LD_STRING D10nB-JMM-1
27238: PPUSH
27239: CALL_OW 88
// if BurlakStatus = 1 then
27243: LD_EXP 9
27247: PUSH
27248: LD_INT 1
27250: EQUAL
27251: IFFALSE 27265
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27253: LD_EXP 70
27257: PPUSH
27258: LD_STRING D10nB-Vse-1a
27260: PPUSH
27261: CALL_OW 94
// end ; if BurlakStatus = 0 then
27265: LD_EXP 9
27269: PUSH
27270: LD_INT 0
27272: EQUAL
27273: IFFALSE 27287
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27275: LD_EXP 70
27279: PPUSH
27280: LD_STRING D10nB-Vse-1
27282: PPUSH
27283: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27287: LD_EXP 39
27291: PPUSH
27292: LD_STRING D10nB-JMM-2
27294: PPUSH
27295: CALL_OW 88
// if KappaStatus then
27299: LD_EXP 2
27303: IFFALSE 27317
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27305: LD_EXP 70
27309: PPUSH
27310: LD_STRING D10nB-Vse-5a
27312: PPUSH
27313: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27317: LD_EXP 2
27321: NOT
27322: PUSH
27323: LD_EXP 6
27327: PUSH
27328: LD_INT 0
27330: EQUAL
27331: AND
27332: IFFALSE 27460
// begin if JMMGirl = 1 then
27334: LD_EXP 7
27338: PUSH
27339: LD_INT 1
27341: EQUAL
27342: IFFALSE 27392
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27344: LD_EXP 70
27348: PPUSH
27349: LD_STRING D10nB-Vse-2
27351: PPUSH
27352: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27356: LD_EXP 39
27360: PPUSH
27361: LD_STRING D10nB-JMM-3
27363: PPUSH
27364: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27368: LD_EXP 70
27372: PPUSH
27373: LD_STRING D10nB-Vse-3
27375: PPUSH
27376: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27380: LD_EXP 39
27384: PPUSH
27385: LD_STRING D10nB-JMM-4
27387: PPUSH
27388: CALL_OW 88
// end ; if JMMGirl = 2 then
27392: LD_EXP 7
27396: PUSH
27397: LD_INT 2
27399: EQUAL
27400: IFFALSE 27426
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27402: LD_EXP 70
27406: PPUSH
27407: LD_STRING D10nB-Vse-4
27409: PPUSH
27410: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27414: LD_EXP 39
27418: PPUSH
27419: LD_STRING D10nB-JMM-5
27421: PPUSH
27422: CALL_OW 88
// end ; if JMMGirl = 3 then
27426: LD_EXP 7
27430: PUSH
27431: LD_INT 3
27433: EQUAL
27434: IFFALSE 27460
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27436: LD_EXP 70
27440: PPUSH
27441: LD_STRING D10nB-Vse-5
27443: PPUSH
27444: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27448: LD_EXP 39
27452: PPUSH
27453: LD_STRING D10nB-JMM-6
27455: PPUSH
27456: CALL_OW 88
// end ; end ; DialogueOff ;
27460: CALL_OW 7
// end ;
27464: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27465: LD_EXP 14
27469: PUSH
27470: LD_INT 115500
27472: GREATEREQUAL
27473: IFFALSE 27849
27475: GO 27477
27477: DISABLE
27478: LD_INT 0
27480: PPUSH
// begin missionStage := 10 ;
27481: LD_ADDR_EXP 15
27485: PUSH
27486: LD_INT 10
27488: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27489: LD_ADDR_VAR 0 1
27493: PUSH
27494: LD_INT 22
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 23
27506: PUSH
27507: LD_INT 1
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 26
27516: PUSH
27517: LD_INT 1
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 3
27526: PUSH
27527: LD_INT 25
27529: PUSH
27530: LD_INT 12
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: EMPTY
27538: LIST
27539: LIST
27540: PUSH
27541: LD_INT 3
27543: PUSH
27544: LD_INT 25
27546: PUSH
27547: LD_INT 16
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: LIST
27564: PPUSH
27565: CALL_OW 69
27569: PUSH
27570: LD_EXP 39
27574: PUSH
27575: LD_EXP 60
27579: PUSH
27580: LD_EXP 41
27584: PUSH
27585: LD_EXP 55
27589: PUSH
27590: LD_EXP 42
27594: PUSH
27595: LD_EXP 43
27599: PUSH
27600: LD_EXP 44
27604: PUSH
27605: LD_EXP 45
27609: PUSH
27610: LD_EXP 46
27614: PUSH
27615: LD_EXP 47
27619: PUSH
27620: LD_EXP 48
27624: PUSH
27625: LD_EXP 49
27629: PUSH
27630: LD_EXP 50
27634: PUSH
27635: LD_EXP 51
27639: PUSH
27640: LD_EXP 52
27644: PUSH
27645: LD_EXP 53
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: LIST
27659: LIST
27660: LIST
27661: LIST
27662: LIST
27663: LIST
27664: LIST
27665: LIST
27666: LIST
27667: DIFF
27668: ST_TO_ADDR
// if not tmp and Brown then
27669: LD_VAR 0 1
27673: NOT
27674: PUSH
27675: LD_EXP 47
27679: AND
27680: IFFALSE 27695
// tmp := [ Brown ] ;
27682: LD_ADDR_VAR 0 1
27686: PUSH
27687: LD_EXP 47
27691: PUSH
27692: EMPTY
27693: LIST
27694: ST_TO_ADDR
// DialogueOn ;
27695: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27699: LD_VAR 0 1
27703: PUSH
27704: LD_INT 1
27706: ARRAY
27707: PPUSH
27708: LD_STRING D11-Sol1-1
27710: PPUSH
27711: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27715: LD_EXP 64
27719: PPUSH
27720: LD_STRING D11-Pla-1
27722: PPUSH
27723: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27727: LD_EXP 65
27731: PPUSH
27732: LD_STRING D11-Kov-1
27734: PPUSH
27735: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27739: LD_EXP 64
27743: PPUSH
27744: LD_STRING D11-Pla-2
27746: PPUSH
27747: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27751: LD_VAR 0 1
27755: PUSH
27756: LD_INT 1
27758: ARRAY
27759: PPUSH
27760: LD_STRING D11-Sol1-2
27762: PPUSH
27763: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27767: LD_EXP 39
27771: PPUSH
27772: LD_STRING D11-JMM-2
27774: PPUSH
27775: CALL_OW 88
// DialogueOff ;
27779: CALL_OW 7
// allowBehemothConstruct := true ;
27783: LD_ADDR_EXP 25
27787: PUSH
27788: LD_INT 1
27790: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27791: LD_STRING M4
27793: PPUSH
27794: CALL_OW 337
// BuildBehemoths ;
27798: CALL 7733 0 0
// repeat wait ( 15 15$00 ) ;
27802: LD_INT 31500
27804: PPUSH
27805: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27809: LD_EXP 27
27813: IFFALSE 27817
// break ;
27815: GO 27849
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27817: LD_INT 267
27819: PPUSH
27820: CALL_OW 274
27824: PPUSH
27825: LD_INT 1
27827: PPUSH
27828: CALL_OW 275
27832: PUSH
27833: LD_INT 1000
27835: GREATEREQUAL
27836: IFFALSE 27842
// BuildBehemoths ;
27838: CALL 7733 0 0
// until not behemothBuilders ;
27842: LD_EXP 73
27846: NOT
27847: IFFALSE 27802
// end ;
27849: PPOPN 1
27851: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27852: LD_EXP 73
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: PUSH
27865: LD_EXP 25
27869: AND
27870: IFFALSE 27890
27872: GO 27874
27874: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27875: LD_STRING M4a
27877: PPUSH
27878: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27882: LD_ADDR_EXP 27
27886: PUSH
27887: LD_INT 1
27889: ST_TO_ADDR
// end ;
27890: END
// every 0 0$1 trigger behemothDone do
27891: LD_EXP 28
27895: IFFALSE 27907
27897: GO 27899
27899: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27900: LD_STRING M4b
27902: PPUSH
27903: CALL_OW 337
27907: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27908: LD_EXP 29
27912: NOT
27913: IFFALSE 28109
27915: GO 27917
27917: DISABLE
27918: LD_INT 0
27920: PPUSH
27921: PPUSH
// begin enable ;
27922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27923: LD_ADDR_VAR 0 1
27927: PUSH
27928: LD_INT 3
27930: PPUSH
27931: CALL 102512 0 1
27935: ST_TO_ADDR
// if not tmp and not behemothDone then
27936: LD_VAR 0 1
27940: NOT
27941: PUSH
27942: LD_EXP 28
27946: NOT
27947: AND
27948: IFFALSE 27984
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27950: LD_ADDR_VAR 0 1
27954: PUSH
27955: LD_INT 22
27957: PUSH
27958: LD_INT 3
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 30
27967: PUSH
27968: LD_INT 37
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PPUSH
27979: CALL_OW 69
27983: ST_TO_ADDR
// if not tmp then
27984: LD_VAR 0 1
27988: NOT
27989: IFFALSE 27993
// exit ;
27991: GO 28109
// for i in tmp do
27993: LD_ADDR_VAR 0 2
27997: PUSH
27998: LD_VAR 0 1
28002: PUSH
28003: FOR_IN
28004: IFFALSE 28107
// if See ( 1 , i ) then
28006: LD_INT 1
28008: PPUSH
28009: LD_VAR 0 2
28013: PPUSH
28014: CALL_OW 292
28018: IFFALSE 28105
// begin if GetType ( i ) = unit_building then
28020: LD_VAR 0 2
28024: PPUSH
28025: CALL_OW 247
28029: PUSH
28030: LD_INT 3
28032: EQUAL
28033: IFFALSE 28071
// begin CenterNowOnUnits ( i ) ;
28035: LD_VAR 0 2
28039: PPUSH
28040: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28044: LD_EXP 39
28048: PPUSH
28049: LD_STRING D17a-JMM-1
28051: PPUSH
28052: CALL_OW 88
// seeBehemoth := true ;
28056: LD_ADDR_EXP 29
28060: PUSH
28061: LD_INT 1
28063: ST_TO_ADDR
// disable ;
28064: DISABLE
// exit ;
28065: POP
28066: POP
28067: GO 28109
// end else
28069: GO 28105
// begin CenterNowOnUnits ( i ) ;
28071: LD_VAR 0 2
28075: PPUSH
28076: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28080: LD_EXP 39
28084: PPUSH
28085: LD_STRING D17b-JMM-1
28087: PPUSH
28088: CALL_OW 88
// seeBehemoth := true ;
28092: LD_ADDR_EXP 29
28096: PUSH
28097: LD_INT 1
28099: ST_TO_ADDR
// disable ;
28100: DISABLE
// exit ;
28101: POP
28102: POP
28103: GO 28109
// end ; end ;
28105: GO 28003
28107: POP
28108: POP
// end ;
28109: PPOPN 2
28111: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28112: LD_EXP 14
28116: PUSH
28117: LD_INT 123200
28119: GREATEREQUAL
28120: IFFALSE 29296
28122: GO 28124
28124: DISABLE
28125: LD_INT 0
28127: PPUSH
28128: PPUSH
28129: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28130: LD_INT 2
28132: PPUSH
28133: LD_INT 23
28135: PUSH
28136: LD_INT 3
28138: PUSH
28139: LD_INT 3
28141: PUSH
28142: LD_INT 48
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: LIST
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: PPUSH
28154: CALL 59308 0 2
// repeat wait ( 0 0$1 ) ;
28158: LD_INT 35
28160: PPUSH
28161: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28165: LD_INT 22
28167: PUSH
28168: LD_INT 3
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 34
28177: PUSH
28178: LD_INT 48
28180: PUSH
28181: EMPTY
28182: LIST
28183: LIST
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PPUSH
28189: CALL_OW 69
28193: IFFALSE 28158
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28195: LD_ADDR_VAR 0 1
28199: PUSH
28200: LD_INT 22
28202: PUSH
28203: LD_INT 3
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 34
28212: PUSH
28213: LD_INT 48
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PPUSH
28224: CALL_OW 69
28228: PUSH
28229: LD_INT 1
28231: ARRAY
28232: ST_TO_ADDR
// missionStage := 12 ;
28233: LD_ADDR_EXP 15
28237: PUSH
28238: LD_INT 12
28240: ST_TO_ADDR
// platonovHasBomb := true ;
28241: LD_ADDR_EXP 30
28245: PUSH
28246: LD_INT 1
28248: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28249: LD_VAR 0 1
28253: PPUSH
28254: LD_INT 181
28256: PPUSH
28257: LD_INT 86
28259: PPUSH
28260: CALL_OW 171
// AddComHold ( bomb ) ;
28264: LD_VAR 0 1
28268: PPUSH
28269: CALL_OW 200
// wait ( 0 0$10 ) ;
28273: LD_INT 350
28275: PPUSH
28276: CALL_OW 67
// DialogueOn ;
28280: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28284: LD_EXP 64
28288: PPUSH
28289: LD_STRING D15-Pla-1
28291: PPUSH
28292: CALL_OW 94
// dec = Query ( Q15a ) ;
28296: LD_ADDR_VAR 0 2
28300: PUSH
28301: LD_STRING Q15a
28303: PPUSH
28304: CALL_OW 97
28308: ST_TO_ADDR
// if dec = 1 then
28309: LD_VAR 0 2
28313: PUSH
28314: LD_INT 1
28316: EQUAL
28317: IFFALSE 28340
// begin Say ( JMM , D15a-JMM-1 ) ;
28319: LD_EXP 39
28323: PPUSH
28324: LD_STRING D15a-JMM-1
28326: PPUSH
28327: CALL_OW 88
// YouLost ( Surrender ) ;
28331: LD_STRING Surrender
28333: PPUSH
28334: CALL_OW 104
// exit ;
28338: GO 29296
// end ; if dec = 2 then
28340: LD_VAR 0 2
28344: PUSH
28345: LD_INT 2
28347: EQUAL
28348: IFFALSE 28417
// begin Say ( JMM , D15b-JMM-1 ) ;
28350: LD_EXP 39
28354: PPUSH
28355: LD_STRING D15b-JMM-1
28357: PPUSH
28358: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28362: LD_EXP 64
28366: PPUSH
28367: LD_STRING D15b-Pla-1
28369: PPUSH
28370: CALL_OW 94
// DialogueOff ;
28374: CALL_OW 7
// wait ( 3 3$00 ) ;
28378: LD_INT 6300
28380: PPUSH
28381: CALL_OW 67
// DialogueOn ;
28385: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28389: LD_EXP 39
28393: PPUSH
28394: LD_STRING D15d-JMM-1a
28396: PPUSH
28397: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28401: LD_EXP 64
28405: PPUSH
28406: LD_STRING D15d-Pla-1
28408: PPUSH
28409: CALL_OW 94
// DialogueOff ;
28413: CALL_OW 7
// end ; if dec = 3 then
28417: LD_VAR 0 2
28421: PUSH
28422: LD_INT 3
28424: EQUAL
28425: IFFALSE 28479
// begin Say ( JMM , D15c-JMM-1 ) ;
28427: LD_EXP 39
28431: PPUSH
28432: LD_STRING D15c-JMM-1
28434: PPUSH
28435: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28439: LD_EXP 64
28443: PPUSH
28444: LD_STRING D15c-Pla-1
28446: PPUSH
28447: CALL_OW 94
// DialogueOff ;
28451: CALL_OW 7
// wait ( 0 0$15 ) ;
28455: LD_INT 525
28457: PPUSH
28458: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28462: LD_VAR 0 1
28466: PPUSH
28467: LD_INT 60
28469: PPUSH
28470: LD_INT 95
28472: PPUSH
28473: CALL_OW 116
// exit ;
28477: GO 29296
// end ; if dec = 4 then
28479: LD_VAR 0 2
28483: PUSH
28484: LD_INT 4
28486: EQUAL
28487: IFFALSE 28517
// begin Say ( JMM , D15d-JMM-1 ) ;
28489: LD_EXP 39
28493: PPUSH
28494: LD_STRING D15d-JMM-1
28496: PPUSH
28497: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28501: LD_EXP 64
28505: PPUSH
28506: LD_STRING D15d-Pla-1
28508: PPUSH
28509: CALL_OW 94
// DialogueOff ;
28513: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28517: LD_EXP 62
28521: PPUSH
28522: CALL_OW 302
28526: PUSH
28527: LD_EXP 62
28531: PPUSH
28532: CALL_OW 255
28536: PUSH
28537: LD_INT 1
28539: EQUAL
28540: AND
28541: PUSH
28542: LD_INT 22
28544: PUSH
28545: LD_INT 1
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 34
28554: PUSH
28555: LD_INT 8
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PPUSH
28566: CALL_OW 69
28570: NOT
28571: AND
28572: IFFALSE 29197
// begin SetSide ( Friend , 8 ) ;
28574: LD_EXP 62
28578: PPUSH
28579: LD_INT 8
28581: PPUSH
28582: CALL_OW 235
// if IsInUnit ( Friend ) then
28586: LD_EXP 62
28590: PPUSH
28591: CALL_OW 310
28595: IFFALSE 28606
// ComExitBuilding ( Friend ) ;
28597: LD_EXP 62
28601: PPUSH
28602: CALL_OW 122
// if IsDriver ( Friend ) then
28606: LD_EXP 62
28610: PPUSH
28611: CALL 100057 0 1
28615: IFFALSE 28626
// ComExitVehicle ( Friend ) ;
28617: LD_EXP 62
28621: PPUSH
28622: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28626: LD_EXP 62
28630: PPUSH
28631: LD_INT 9
28633: PPUSH
28634: LD_INT 2
28636: PPUSH
28637: CALL_OW 171
// wait ( 0 0$05 ) ;
28641: LD_INT 175
28643: PPUSH
28644: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28648: LD_EXP 62
28652: PPUSH
28653: CALL_OW 87
// DialogueOn ;
28657: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28661: LD_EXP 39
28665: PPUSH
28666: LD_STRING D16-JMM-1
28668: PPUSH
28669: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28673: LD_EXP 62
28677: PPUSH
28678: LD_STRING D16-Friend-1
28680: PPUSH
28681: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28685: LD_EXP 39
28689: PPUSH
28690: LD_STRING D16-JMM-2
28692: PPUSH
28693: CALL_OW 88
// DialogueOff ;
28697: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28701: LD_EXP 62
28705: PPUSH
28706: LD_INT 1
28708: PPUSH
28709: CALL_OW 235
// ComHold ( Friend ) ;
28713: LD_EXP 62
28717: PPUSH
28718: CALL_OW 140
// wait ( 0 0$20 ) ;
28722: LD_INT 700
28724: PPUSH
28725: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28729: LD_EXP 62
28733: PPUSH
28734: LD_INT 9
28736: PPUSH
28737: LD_INT 2
28739: PPUSH
28740: CALL_OW 297
28744: PUSH
28745: LD_INT 30
28747: LESS
28748: IFFALSE 28817
// begin SetSide ( Friend , 8 ) ;
28750: LD_EXP 62
28754: PPUSH
28755: LD_INT 8
28757: PPUSH
28758: CALL_OW 235
// if IsInUnit ( Friend ) then
28762: LD_EXP 62
28766: PPUSH
28767: CALL_OW 310
28771: IFFALSE 28782
// ComExitBuilding ( Friend ) ;
28773: LD_EXP 62
28777: PPUSH
28778: CALL_OW 122
// if IsDriver ( Friend ) then
28782: LD_EXP 62
28786: PPUSH
28787: CALL 100057 0 1
28791: IFFALSE 28802
// ComExitVehicle ( Friend ) ;
28793: LD_EXP 62
28797: PPUSH
28798: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28802: LD_EXP 62
28806: PPUSH
28807: LD_INT 9
28809: PPUSH
28810: LD_INT 2
28812: PPUSH
28813: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28817: LD_INT 1050
28819: PPUSH
28820: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28824: LD_INT 22
28826: PUSH
28827: LD_INT 1
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 34
28836: PUSH
28837: LD_INT 8
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PPUSH
28848: CALL_OW 69
28852: NOT
28853: IFFALSE 29175
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28855: LD_ADDR_VAR 0 3
28859: PUSH
28860: LD_INT 22
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: LD_INT 26
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 3
28882: PUSH
28883: LD_INT 25
28885: PUSH
28886: LD_INT 12
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 25
28895: PUSH
28896: LD_INT 16
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: LIST
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: LIST
28912: PPUSH
28913: CALL_OW 69
28917: PUSH
28918: LD_EXP 39
28922: PUSH
28923: LD_EXP 41
28927: PUSH
28928: LD_EXP 55
28932: PUSH
28933: LD_EXP 42
28937: PUSH
28938: LD_EXP 43
28942: PUSH
28943: LD_EXP 44
28947: PUSH
28948: LD_EXP 45
28952: PUSH
28953: LD_EXP 46
28957: PUSH
28958: LD_EXP 47
28962: PUSH
28963: LD_EXP 48
28967: PUSH
28968: LD_EXP 49
28972: PUSH
28973: LD_EXP 50
28977: PUSH
28978: LD_EXP 51
28982: PUSH
28983: LD_EXP 52
28987: PUSH
28988: LD_EXP 53
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: DIFF
29010: ST_TO_ADDR
// DialogueOn ;
29011: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29015: LD_EXP 64
29019: PPUSH
29020: LD_STRING D16a-Pla-1
29022: PPUSH
29023: CALL_OW 94
// if Stevens then
29027: LD_EXP 41
29031: IFFALSE 29047
// Say ( Stevens , D16a-Huck-1 ) else
29033: LD_EXP 41
29037: PPUSH
29038: LD_STRING D16a-Huck-1
29040: PPUSH
29041: CALL_OW 88
29045: GO 29089
// if Baker then
29047: LD_EXP 55
29051: IFFALSE 29067
// Say ( Baker , D16a-Huck-1 ) else
29053: LD_EXP 55
29057: PPUSH
29058: LD_STRING D16a-Huck-1
29060: PPUSH
29061: CALL_OW 88
29065: GO 29089
// if tmp then
29067: LD_VAR 0 3
29071: IFFALSE 29089
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29073: LD_VAR 0 3
29077: PUSH
29078: LD_INT 1
29080: ARRAY
29081: PPUSH
29082: LD_STRING D16a-Sol1-1
29084: PPUSH
29085: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29089: LD_EXP 62
29093: PPUSH
29094: CALL_OW 255
29098: PUSH
29099: LD_INT 8
29101: EQUAL
29102: IFFALSE 29118
// Say ( JMM , D16a-JMM-1 ) else
29104: LD_EXP 39
29108: PPUSH
29109: LD_STRING D16a-JMM-1
29111: PPUSH
29112: CALL_OW 88
29116: GO 29154
// begin Say ( JMM , D16a-JMM-1a ) ;
29118: LD_EXP 39
29122: PPUSH
29123: LD_STRING D16a-JMM-1a
29125: PPUSH
29126: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29130: LD_EXP 62
29134: PPUSH
29135: LD_STRING D16a-Friend-1
29137: PPUSH
29138: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29142: LD_EXP 62
29146: PPUSH
29147: LD_INT 3
29149: PPUSH
29150: CALL_OW 235
// end ; DialogueOff ;
29154: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29158: LD_VAR 0 1
29162: PPUSH
29163: LD_INT 60
29165: PPUSH
29166: LD_INT 95
29168: PPUSH
29169: CALL_OW 116
// end else
29173: GO 29195
// begin DialogueOn ;
29175: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29179: LD_EXP 64
29183: PPUSH
29184: LD_STRING D16c-Pla-
29186: PPUSH
29187: CALL_OW 94
// DialogueOff ;
29191: CALL_OW 7
// end ; end else
29195: GO 29296
// begin wait ( 3 3$00 ) ;
29197: LD_INT 6300
29199: PPUSH
29200: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29204: LD_INT 22
29206: PUSH
29207: LD_INT 1
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 34
29216: PUSH
29217: LD_INT 8
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PPUSH
29228: CALL_OW 69
29232: NOT
29233: IFFALSE 29276
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29235: LD_EXP 64
29239: PPUSH
29240: LD_STRING D16b-Pla-1
29242: PPUSH
29243: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29247: LD_EXP 39
29251: PPUSH
29252: LD_STRING D16b-JMM-
29254: PPUSH
29255: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29259: LD_VAR 0 1
29263: PPUSH
29264: LD_INT 60
29266: PPUSH
29267: LD_INT 95
29269: PPUSH
29270: CALL_OW 116
// end else
29274: GO 29296
// begin DialogueOn ;
29276: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29280: LD_EXP 64
29284: PPUSH
29285: LD_STRING D16c-Pla-
29287: PPUSH
29288: CALL_OW 94
// DialogueOff ;
29292: CALL_OW 7
// end ; end ; end ;
29296: PPOPN 3
29298: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29299: LD_EXP 14
29303: PUSH
29304: LD_INT 126000
29306: GREATEREQUAL
29307: PUSH
29308: LD_EXP 23
29312: NOT
29313: AND
29314: PUSH
29315: LD_EXP 74
29319: PPUSH
29320: CALL_OW 302
29324: AND
29325: IFFALSE 29683
29327: GO 29329
29329: DISABLE
29330: LD_INT 0
29332: PPUSH
// begin missionStage = 11 ;
29333: LD_ADDR_EXP 15
29337: PUSH
29338: LD_INT 11
29340: ST_TO_ADDR
// DialogueOn ;
29341: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-1
29352: PPUSH
29353: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29357: LD_EXP 39
29361: PPUSH
29362: LD_STRING D9-JMM-1
29364: PPUSH
29365: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29369: LD_EXP 74
29373: PPUSH
29374: LD_STRING D9-Roth-2
29376: PPUSH
29377: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29381: LD_EXP 74
29385: PPUSH
29386: LD_STRING D9-Roth-2a
29388: PPUSH
29389: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29393: LD_EXP 64
29397: PPUSH
29398: LD_STRING D9-Pla-2
29400: PPUSH
29401: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29405: LD_EXP 74
29409: PPUSH
29410: LD_STRING D9-Roth-3
29412: PPUSH
29413: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29417: LD_EXP 64
29421: PPUSH
29422: LD_STRING D9-Pla-3
29424: PPUSH
29425: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29429: LD_EXP 74
29433: PPUSH
29434: LD_STRING D9-Roth-4
29436: PPUSH
29437: CALL_OW 94
// dec = Query ( Q9 ) ;
29441: LD_ADDR_VAR 0 1
29445: PUSH
29446: LD_STRING Q9
29448: PPUSH
29449: CALL_OW 97
29453: ST_TO_ADDR
// if dec = 1 then
29454: LD_VAR 0 1
29458: PUSH
29459: LD_INT 1
29461: EQUAL
29462: IFFALSE 29476
// SayRadio ( Roth , D9a-Roth-1 ) ;
29464: LD_EXP 74
29468: PPUSH
29469: LD_STRING D9a-Roth-1
29471: PPUSH
29472: CALL_OW 94
// if dec = 2 then
29476: LD_VAR 0 1
29480: PUSH
29481: LD_INT 2
29483: EQUAL
29484: IFFALSE 29510
// begin Say ( JMM , D9b-JMM-1 ) ;
29486: LD_EXP 39
29490: PPUSH
29491: LD_STRING D9b-JMM-1
29493: PPUSH
29494: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29498: LD_EXP 74
29502: PPUSH
29503: LD_STRING D9b-Roth-1
29505: PPUSH
29506: CALL_OW 94
// end ; if dec = 3 then
29510: LD_VAR 0 1
29514: PUSH
29515: LD_INT 3
29517: EQUAL
29518: IFFALSE 29580
// begin Say ( JMM , D9c-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9c-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9c-Roth-1
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9c-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9c-Roth-2
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9c-JMM-3
29575: PPUSH
29576: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29580: LD_EXP 74
29584: PPUSH
29585: LD_STRING D9c-Roth-3
29587: PPUSH
29588: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29592: LD_EXP 74
29596: PPUSH
29597: LD_STRING D9cont-Roth-1
29599: PPUSH
29600: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29604: LD_EXP 39
29608: PPUSH
29609: LD_STRING D9cont-JMM-1
29611: PPUSH
29612: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29616: LD_EXP 74
29620: PPUSH
29621: LD_STRING D9cont-Roth-2
29623: PPUSH
29624: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29628: LD_EXP 39
29632: PPUSH
29633: LD_STRING D9cont-JMM-2
29635: PPUSH
29636: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29640: LD_EXP 74
29644: PPUSH
29645: LD_STRING D9cont-Roth-3
29647: PPUSH
29648: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29652: LD_EXP 39
29656: PPUSH
29657: LD_STRING D9cont-JMM-3
29659: PPUSH
29660: CALL_OW 88
// DialogueOff ;
29664: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29668: LD_STRING M3
29670: PPUSH
29671: CALL_OW 337
// allianceActive := true ;
29675: LD_ADDR_EXP 31
29679: PUSH
29680: LD_INT 1
29682: ST_TO_ADDR
// end ;
29683: PPOPN 1
29685: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29686: LD_INT 1
29688: PPUSH
29689: LD_INT 126
29691: PPUSH
29692: CALL_OW 292
29696: PUSH
29697: LD_EXP 64
29701: PPUSH
29702: CALL_OW 310
29706: AND
29707: IFFALSE 29787
29709: GO 29711
29711: DISABLE
29712: LD_INT 0
29714: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29715: LD_EXP 64
29719: PPUSH
29720: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29724: LD_ADDR_VAR 0 1
29728: PUSH
29729: LD_INT 4
29731: PPUSH
29732: LD_INT 22
29734: PUSH
29735: LD_INT 1
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PPUSH
29742: CALL_OW 70
29746: PPUSH
29747: LD_EXP 64
29751: PPUSH
29752: CALL_OW 74
29756: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29757: LD_EXP 64
29761: PPUSH
29762: LD_VAR 0 1
29766: PUSH
29767: LD_INT 1
29769: ARRAY
29770: PPUSH
29771: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29775: LD_EXP 64
29779: PPUSH
29780: LD_STRING D18-Pla-1
29782: PPUSH
29783: CALL_OW 88
// end ;
29787: PPOPN 1
29789: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29790: LD_EXP 64
29794: PPUSH
29795: CALL_OW 301
29799: PUSH
29800: LD_EXP 67
29804: PPUSH
29805: CALL_OW 301
29809: AND
29810: PUSH
29811: LD_INT 22
29813: PUSH
29814: LD_INT 3
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 21
29823: PUSH
29824: LD_INT 1
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 50
29833: PUSH
29834: EMPTY
29835: LIST
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: LIST
29841: PPUSH
29842: CALL_OW 69
29846: PUSH
29847: LD_INT 7
29849: PUSH
29850: LD_INT 8
29852: PUSH
29853: LD_INT 9
29855: PUSH
29856: LD_INT 10
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: LIST
29863: LIST
29864: PUSH
29865: LD_OWVAR 67
29869: ARRAY
29870: LESS
29871: AND
29872: IFFALSE 30643
29874: GO 29876
29876: DISABLE
29877: LD_INT 0
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
// begin MC_Kill ( 2 ) ;
29883: LD_INT 2
29885: PPUSH
29886: CALL 35477 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29890: LD_INT 1
29892: PPUSH
29893: LD_INT 3
29895: PPUSH
29896: LD_INT 1
29898: PPUSH
29899: LD_INT 1
29901: PPUSH
29902: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29906: LD_ADDR_VAR 0 1
29910: PUSH
29911: LD_INT 22
29913: PUSH
29914: LD_INT 3
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 21
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 24
29933: PUSH
29934: LD_INT 900
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: LIST
29945: PPUSH
29946: CALL_OW 69
29950: PUSH
29951: FOR_IN
29952: IFFALSE 29983
// if GetSex ( i ) = sex_male then
29954: LD_VAR 0 1
29958: PPUSH
29959: CALL_OW 258
29963: PUSH
29964: LD_INT 1
29966: EQUAL
29967: IFFALSE 29981
// begin tmp = i ;
29969: LD_ADDR_VAR 0 2
29973: PUSH
29974: LD_VAR 0 1
29978: ST_TO_ADDR
// break ;
29979: GO 29983
// end ;
29981: GO 29951
29983: POP
29984: POP
// if tmp = 0 then
29985: LD_VAR 0 2
29989: PUSH
29990: LD_INT 0
29992: EQUAL
29993: IFFALSE 30047
// begin uc_side = 3 ;
29995: LD_ADDR_OWVAR 20
29999: PUSH
30000: LD_INT 3
30002: ST_TO_ADDR
// uc_nation = 3 ;
30003: LD_ADDR_OWVAR 21
30007: PUSH
30008: LD_INT 3
30010: ST_TO_ADDR
// hc_name =  ;
30011: LD_ADDR_OWVAR 26
30015: PUSH
30016: LD_STRING 
30018: ST_TO_ADDR
// hc_gallery =  ;
30019: LD_ADDR_OWVAR 33
30023: PUSH
30024: LD_STRING 
30026: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30027: LD_INT 1
30029: PPUSH
30030: LD_INT 10
30032: PPUSH
30033: CALL_OW 381
// tmp = CreateHuman ;
30037: LD_ADDR_VAR 0 2
30041: PUSH
30042: CALL_OW 44
30046: ST_TO_ADDR
// end ; DialogueOn ;
30047: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30051: LD_VAR 0 2
30055: PPUSH
30056: LD_STRING DSurrenderRussians-RSol1-1a
30058: PPUSH
30059: CALL_OW 94
// DialogueOff ;
30063: CALL_OW 7
// russianDestroyed := true ;
30067: LD_ADDR_EXP 21
30071: PUSH
30072: LD_INT 1
30074: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30075: LD_INT 22
30077: PUSH
30078: LD_INT 3
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 21
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PPUSH
30099: CALL_OW 69
30103: PPUSH
30104: CALL_OW 122
// wait ( 0 0$1 ) ;
30108: LD_INT 35
30110: PPUSH
30111: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30115: LD_INT 22
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 21
30127: PUSH
30128: LD_INT 1
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PPUSH
30139: CALL_OW 69
30143: PPUSH
30144: LD_INT 25
30146: PPUSH
30147: CALL_OW 173
// wait ( 0 0$10 ) ;
30151: LD_INT 350
30153: PPUSH
30154: CALL_OW 67
// PrepareOmarInvasion ;
30158: CALL 13975 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30162: LD_ADDR_VAR 0 2
30166: PUSH
30167: LD_EXP 92
30171: PPUSH
30172: CALL_OW 250
30176: PUSH
30177: LD_EXP 92
30181: PPUSH
30182: CALL_OW 251
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30191: LD_VAR 0 2
30195: PUSH
30196: LD_INT 1
30198: ARRAY
30199: PPUSH
30200: LD_VAR 0 2
30204: PUSH
30205: LD_INT 2
30207: ARRAY
30208: PPUSH
30209: LD_INT 1
30211: PPUSH
30212: LD_INT 8
30214: NEG
30215: PPUSH
30216: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30220: LD_EXP 92
30224: PPUSH
30225: CALL_OW 87
// DialogueOn ;
30229: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30233: LD_EXP 39
30237: PPUSH
30238: LD_STRING D19-JMM-1
30240: PPUSH
30241: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30245: LD_ADDR_VAR 0 3
30249: PUSH
30250: LD_INT 22
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 26
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 2
30272: PUSH
30273: LD_INT 25
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 25
30285: PUSH
30286: LD_INT 2
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 25
30295: PUSH
30296: LD_INT 3
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 25
30305: PUSH
30306: LD_INT 4
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 25
30315: PUSH
30316: LD_INT 5
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 25
30325: PUSH
30326: LD_INT 8
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: LIST
30346: PPUSH
30347: CALL_OW 69
30351: PUSH
30352: LD_EXP 39
30356: PUSH
30357: LD_EXP 40
30361: PUSH
30362: LD_EXP 41
30366: PUSH
30367: LD_EXP 42
30371: PUSH
30372: LD_EXP 43
30376: PUSH
30377: LD_EXP 44
30381: PUSH
30382: LD_EXP 45
30386: PUSH
30387: LD_EXP 46
30391: PUSH
30392: LD_EXP 47
30396: PUSH
30397: LD_EXP 48
30401: PUSH
30402: LD_EXP 49
30406: PUSH
30407: LD_EXP 50
30411: PUSH
30412: LD_EXP 51
30416: PUSH
30417: LD_EXP 52
30421: PUSH
30422: LD_EXP 53
30426: PUSH
30427: LD_EXP 54
30431: PUSH
30432: LD_EXP 55
30436: PUSH
30437: EMPTY
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: DIFF
30456: ST_TO_ADDR
// if tmp2 then
30457: LD_VAR 0 3
30461: IFFALSE 30479
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30463: LD_VAR 0 3
30467: PUSH
30468: LD_INT 1
30470: ARRAY
30471: PPUSH
30472: LD_STRING D19-Sol1-1
30474: PPUSH
30475: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30479: LD_EXP 39
30483: PPUSH
30484: LD_STRING D19-JMM-2
30486: PPUSH
30487: CALL_OW 88
// DialogueOff ;
30491: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30495: LD_VAR 0 2
30499: PUSH
30500: LD_INT 1
30502: ARRAY
30503: PPUSH
30504: LD_VAR 0 2
30508: PUSH
30509: LD_INT 2
30511: ARRAY
30512: PPUSH
30513: LD_INT 1
30515: PPUSH
30516: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30520: LD_STRING M5
30522: PPUSH
30523: CALL_OW 337
// omarOnMotherLode := false ;
30527: LD_ADDR_VAR 0 4
30531: PUSH
30532: LD_INT 0
30534: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30535: LD_INT 35
30537: PPUSH
30538: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30542: LD_EXP 92
30546: PPUSH
30547: LD_INT 215
30549: PPUSH
30550: LD_INT 100
30552: PPUSH
30553: CALL_OW 297
30557: PUSH
30558: LD_INT 10
30560: LESS
30561: PUSH
30562: LD_VAR 0 4
30566: NOT
30567: AND
30568: IFFALSE 30602
// begin omarOnMotherLode := true ;
30570: LD_ADDR_VAR 0 4
30574: PUSH
30575: LD_INT 1
30577: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30578: LD_EXP 39
30582: PPUSH
30583: LD_STRING D19b-JMM-1
30585: PPUSH
30586: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30590: LD_EXP 92
30594: PPUSH
30595: LD_STRING DOmarContam-Omar-1
30597: PPUSH
30598: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30602: LD_EXP 92
30606: PPUSH
30607: CALL_OW 301
30611: IFFALSE 30535
// Say ( JMM , D19a-JMM-1 ) ;
30613: LD_EXP 39
30617: PPUSH
30618: LD_STRING D19a-JMM-1
30620: PPUSH
30621: CALL_OW 88
// if Heike then
30625: LD_EXP 93
30629: IFFALSE 30643
// Say ( Heike , D19a-Hke-1 ) ;
30631: LD_EXP 93
30635: PPUSH
30636: LD_STRING D19a-Hke-1
30638: PPUSH
30639: CALL_OW 88
// end ;
30643: PPOPN 4
30645: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30646: LD_INT 22
30648: PUSH
30649: LD_INT 3
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 21
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PPUSH
30670: CALL_OW 69
30674: PUSH
30675: LD_EXP 21
30679: AND
30680: IFFALSE 30748
30682: GO 30684
30684: DISABLE
30685: LD_INT 0
30687: PPUSH
30688: PPUSH
// begin enable ;
30689: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30690: LD_ADDR_VAR 0 2
30694: PUSH
30695: LD_INT 25
30697: PPUSH
30698: LD_INT 22
30700: PUSH
30701: LD_INT 3
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PPUSH
30708: CALL_OW 70
30712: ST_TO_ADDR
// if not tmp then
30713: LD_VAR 0 2
30717: NOT
30718: IFFALSE 30722
// exit ;
30720: GO 30748
// for i in tmp do
30722: LD_ADDR_VAR 0 1
30726: PUSH
30727: LD_VAR 0 2
30731: PUSH
30732: FOR_IN
30733: IFFALSE 30746
// RemoveUnit ( i ) ;
30735: LD_VAR 0 1
30739: PPUSH
30740: CALL_OW 64
30744: GO 30732
30746: POP
30747: POP
// end ;
30748: PPOPN 2
30750: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30751: LD_INT 22
30753: PUSH
30754: LD_INT 7
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 21
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PPUSH
30775: CALL_OW 69
30779: PUSH
30780: LD_INT 6
30782: LESS
30783: IFFALSE 31251
30785: GO 30787
30787: DISABLE
30788: LD_INT 0
30790: PPUSH
30791: PPUSH
// begin MC_Kill ( 1 ) ;
30792: LD_INT 1
30794: PPUSH
30795: CALL 35477 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30799: LD_INT 7
30801: PPUSH
30802: LD_INT 1
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 1
30810: PPUSH
30811: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: LD_INT 22
30822: PUSH
30823: LD_INT 7
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 26
30832: PUSH
30833: LD_INT 1
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PPUSH
30844: CALL_OW 69
30848: PUSH
30849: LD_EXP 74
30853: DIFF
30854: ST_TO_ADDR
// if tmp then
30855: LD_VAR 0 1
30859: IFFALSE 30877
// tmp := tmp [ 1 ] else
30861: LD_ADDR_VAR 0 1
30865: PUSH
30866: LD_VAR 0 1
30870: PUSH
30871: LD_INT 1
30873: ARRAY
30874: ST_TO_ADDR
30875: GO 30913
// begin uc_side := 7 ;
30877: LD_ADDR_OWVAR 20
30881: PUSH
30882: LD_INT 7
30884: ST_TO_ADDR
// uc_nation := 1 ;
30885: LD_ADDR_OWVAR 21
30889: PUSH
30890: LD_INT 1
30892: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30893: LD_INT 1
30895: PPUSH
30896: LD_INT 8
30898: PPUSH
30899: CALL_OW 384
// tmp := CreateHuman ;
30903: LD_ADDR_VAR 0 1
30907: PUSH
30908: CALL_OW 44
30912: ST_TO_ADDR
// end ; DialogueOn ;
30913: CALL_OW 6
// if IsOK ( Roth ) then
30917: LD_EXP 74
30921: PPUSH
30922: CALL_OW 302
30926: IFFALSE 30940
// Say ( JMM , DAb-JMM-1 ) ;
30928: LD_EXP 39
30932: PPUSH
30933: LD_STRING DAb-JMM-1
30935: PPUSH
30936: CALL_OW 88
// if IsOK ( Roth ) then
30940: LD_EXP 74
30944: PPUSH
30945: CALL_OW 302
30949: IFFALSE 30973
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30951: LD_EXP 74
30955: PPUSH
30956: LD_STRING DSurrenderAlliance-Roth-1
30958: PPUSH
30959: CALL_OW 88
// RothCaptured := true ;
30963: LD_ADDR_EXP 33
30967: PUSH
30968: LD_INT 1
30970: ST_TO_ADDR
// end else
30971: GO 30985
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30973: LD_VAR 0 1
30977: PPUSH
30978: LD_STRING DSurrenderAlliance-Sci1-1
30980: PPUSH
30981: CALL_OW 88
// DialogueOff ;
30985: CALL_OW 7
// allianceDestroyed := true ;
30989: LD_ADDR_EXP 23
30993: PUSH
30994: LD_INT 1
30996: ST_TO_ADDR
// if capturedUnit = 0 then
30997: LD_EXP 34
31001: PUSH
31002: LD_INT 0
31004: EQUAL
31005: IFFALSE 31014
// SetAchievement ( ACH_ALLIANCE ) ;
31007: LD_STRING ACH_ALLIANCE
31009: PPUSH
31010: CALL_OW 543
// if trueAmericans then
31014: LD_EXP 35
31018: IFFALSE 31094
// begin if trueAmericans = 1 then
31020: LD_EXP 35
31024: PUSH
31025: LD_INT 1
31027: EQUAL
31028: IFFALSE 31044
// Say ( JMM , DAb-JMM-1a ) else
31030: LD_EXP 39
31034: PPUSH
31035: LD_STRING DAb-JMM-1a
31037: PPUSH
31038: CALL_OW 88
31042: GO 31056
// Say ( JMM , DAb-JMM-1b ) ;
31044: LD_EXP 39
31048: PPUSH
31049: LD_STRING DAb-JMM-1b
31051: PPUSH
31052: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31056: LD_EXP 35
31060: PPUSH
31061: CALL_OW 87
// for i in trueAmericans do
31065: LD_ADDR_VAR 0 2
31069: PUSH
31070: LD_EXP 35
31074: PUSH
31075: FOR_IN
31076: IFFALSE 31092
// SetSide ( i , 1 ) ;
31078: LD_VAR 0 2
31082: PPUSH
31083: LD_INT 1
31085: PPUSH
31086: CALL_OW 235
31090: GO 31075
31092: POP
31093: POP
// end ; repeat wait ( 0 0$1 ) ;
31094: LD_INT 35
31096: PPUSH
31097: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31101: LD_ADDR_VAR 0 2
31105: PUSH
31106: LD_INT 22
31108: PUSH
31109: LD_INT 7
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 21
31118: PUSH
31119: LD_INT 1
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PPUSH
31130: CALL_OW 69
31134: PUSH
31135: FOR_IN
31136: IFFALSE 31218
// begin if IsInUnit ( i ) then
31138: LD_VAR 0 2
31142: PPUSH
31143: CALL_OW 310
31147: IFFALSE 31158
// ComExitBuilding ( i ) ;
31149: LD_VAR 0 2
31153: PPUSH
31154: CALL_OW 122
// if IsDriver ( i ) then
31158: LD_VAR 0 2
31162: PPUSH
31163: CALL 100057 0 1
31167: IFFALSE 31178
// ComExitVehicle ( i ) ;
31169: LD_VAR 0 2
31173: PPUSH
31174: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31178: LD_VAR 0 2
31182: PPUSH
31183: LD_INT 26
31185: PPUSH
31186: CALL_OW 308
31190: NOT
31191: IFFALSE 31207
// AddComMoveToArea ( i , allianceEscapeArea ) else
31193: LD_VAR 0 2
31197: PPUSH
31198: LD_INT 26
31200: PPUSH
31201: CALL_OW 173
31205: GO 31216
// RemoveUnit ( i ) ;
31207: LD_VAR 0 2
31211: PPUSH
31212: CALL_OW 64
// end ;
31216: GO 31135
31218: POP
31219: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31220: LD_INT 22
31222: PUSH
31223: LD_INT 7
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 21
31232: PUSH
31233: LD_INT 1
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: EMPTY
31241: LIST
31242: LIST
31243: PPUSH
31244: CALL_OW 69
31248: NOT
31249: IFFALSE 31094
// end ;
31251: PPOPN 2
31253: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31254: LD_INT 0
31256: PPUSH
31257: PPUSH
// if not unit then
31258: LD_VAR 0 1
31262: NOT
31263: IFFALSE 31267
// exit ;
31265: GO 32765
// DoNotAttack ( 7 , unit ) ;
31267: LD_INT 7
31269: PPUSH
31270: LD_VAR 0 1
31274: PPUSH
31275: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31279: LD_VAR 0 1
31283: PPUSH
31284: LD_INT 260
31286: PPUSH
31287: LD_INT 235
31289: PPUSH
31290: LD_INT 3
31292: PPUSH
31293: LD_INT 1
31295: PPUSH
31296: CALL_OW 483
// SetSide ( unit , 4 ) ;
31300: LD_VAR 0 1
31304: PPUSH
31305: LD_INT 4
31307: PPUSH
31308: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31312: LD_ADDR_EXP 34
31316: PUSH
31317: LD_EXP 34
31321: PUSH
31322: LD_INT 1
31324: PLUS
31325: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31326: LD_INT 70
31328: PPUSH
31329: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31333: LD_INT 260
31335: PPUSH
31336: LD_INT 235
31338: PPUSH
31339: LD_INT 1
31341: PPUSH
31342: LD_INT 8
31344: NEG
31345: PPUSH
31346: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31350: LD_VAR 0 1
31354: PPUSH
31355: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31359: LD_VAR 0 1
31363: PPUSH
31364: LD_EXP 74
31368: PPUSH
31369: CALL_OW 119
// DialogueOn ;
31373: CALL_OW 6
// case unit of JMM :
31377: LD_VAR 0 1
31381: PUSH
31382: LD_EXP 39
31386: DOUBLE
31387: EQUAL
31388: IFTRUE 31392
31390: GO 31407
31392: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31393: LD_EXP 39
31397: PPUSH
31398: LD_STRING DA1-JMM-1
31400: PPUSH
31401: CALL_OW 91
31405: GO 31849
31407: LD_EXP 40
31411: DOUBLE
31412: EQUAL
31413: IFTRUE 31417
31415: GO 31432
31417: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31418: LD_EXP 40
31422: PPUSH
31423: LD_STRING DA1-Joan-1
31425: PPUSH
31426: CALL_OW 91
31430: GO 31849
31432: LD_EXP 42
31436: DOUBLE
31437: EQUAL
31438: IFTRUE 31442
31440: GO 31457
31442: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31443: LD_EXP 42
31447: PPUSH
31448: LD_STRING DA1-Lisa-1
31450: PPUSH
31451: CALL_OW 91
31455: GO 31849
31457: LD_EXP 43
31461: DOUBLE
31462: EQUAL
31463: IFTRUE 31467
31465: GO 31482
31467: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31468: LD_EXP 43
31472: PPUSH
31473: LD_STRING DA1-Don-1
31475: PPUSH
31476: CALL_OW 91
31480: GO 31849
31482: LD_EXP 50
31486: DOUBLE
31487: EQUAL
31488: IFTRUE 31492
31490: GO 31507
31492: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31493: LD_EXP 50
31497: PPUSH
31498: LD_STRING DA1-Corn-1
31500: PPUSH
31501: CALL_OW 91
31505: GO 31849
31507: LD_EXP 46
31511: DOUBLE
31512: EQUAL
31513: IFTRUE 31517
31515: GO 31532
31517: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31518: LD_EXP 46
31522: PPUSH
31523: LD_STRING DA1-Den-1
31525: PPUSH
31526: CALL_OW 91
31530: GO 31849
31532: LD_EXP 44
31536: DOUBLE
31537: EQUAL
31538: IFTRUE 31542
31540: GO 31557
31542: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31543: LD_EXP 44
31547: PPUSH
31548: LD_STRING DA1-Bobby-1
31550: PPUSH
31551: CALL_OW 91
31555: GO 31849
31557: LD_EXP 48
31561: DOUBLE
31562: EQUAL
31563: IFTRUE 31567
31565: GO 31582
31567: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31568: LD_EXP 48
31572: PPUSH
31573: LD_STRING DA1-Glad-1
31575: PPUSH
31576: CALL_OW 91
31580: GO 31849
31582: LD_EXP 45
31586: DOUBLE
31587: EQUAL
31588: IFTRUE 31592
31590: GO 31607
31592: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31593: LD_EXP 45
31597: PPUSH
31598: LD_STRING DA1-Cyrus-1
31600: PPUSH
31601: CALL_OW 91
31605: GO 31849
31607: LD_EXP 41
31611: DOUBLE
31612: EQUAL
31613: IFTRUE 31617
31615: GO 31632
31617: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31618: LD_EXP 41
31622: PPUSH
31623: LD_STRING DA1-Huck-1
31625: PPUSH
31626: CALL_OW 91
31630: GO 31849
31632: LD_EXP 55
31636: DOUBLE
31637: EQUAL
31638: IFTRUE 31642
31640: GO 31657
31642: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31643: LD_EXP 55
31647: PPUSH
31648: LD_STRING DA1-Huck-1
31650: PPUSH
31651: CALL_OW 91
31655: GO 31849
31657: LD_EXP 47
31661: DOUBLE
31662: EQUAL
31663: IFTRUE 31667
31665: GO 31682
31667: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31668: LD_EXP 47
31672: PPUSH
31673: LD_STRING DA1-Brown-1
31675: PPUSH
31676: CALL_OW 91
31680: GO 31849
31682: LD_EXP 51
31686: DOUBLE
31687: EQUAL
31688: IFTRUE 31692
31690: GO 31707
31692: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31693: LD_EXP 51
31697: PPUSH
31698: LD_STRING DA1-Gary-1
31700: PPUSH
31701: CALL_OW 91
31705: GO 31849
31707: LD_EXP 54
31711: DOUBLE
31712: EQUAL
31713: IFTRUE 31717
31715: GO 31732
31717: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31718: LD_EXP 54
31722: PPUSH
31723: LD_STRING DA1-Con-1
31725: PPUSH
31726: CALL_OW 91
31730: GO 31849
31732: LD_EXP 60
31736: DOUBLE
31737: EQUAL
31738: IFTRUE 31742
31740: GO 31757
31742: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31743: LD_EXP 60
31747: PPUSH
31748: LD_STRING DA1-Kurt-1
31750: PPUSH
31751: CALL_OW 91
31755: GO 31849
31757: LD_EXP 53
31761: DOUBLE
31762: EQUAL
31763: IFTRUE 31767
31765: GO 31782
31767: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31768: LD_EXP 53
31772: PPUSH
31773: LD_STRING DA1-Yam-1
31775: PPUSH
31776: CALL_OW 91
31780: GO 31849
31782: LD_EXP 52
31786: DOUBLE
31787: EQUAL
31788: IFTRUE 31792
31790: GO 31807
31792: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31793: LD_EXP 52
31797: PPUSH
31798: LD_STRING DA1-Frank-1
31800: PPUSH
31801: CALL_OW 91
31805: GO 31849
31807: POP
// begin if GetSex ( unit ) = sex_male then
31808: LD_VAR 0 1
31812: PPUSH
31813: CALL_OW 258
31817: PUSH
31818: LD_INT 1
31820: EQUAL
31821: IFFALSE 31837
// ForceSay ( unit , DA1-Sol1-1 ) else
31823: LD_VAR 0 1
31827: PPUSH
31828: LD_STRING DA1-Sol1-1
31830: PPUSH
31831: CALL_OW 91
31835: GO 31849
// ForceSay ( unit , DA1-FSol1-1 ) ;
31837: LD_VAR 0 1
31841: PPUSH
31842: LD_STRING DA1-FSol1-1
31844: PPUSH
31845: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31849: LD_EXP 74
31853: PPUSH
31854: LD_STRING DA-Roth-1
31856: PPUSH
31857: CALL_OW 88
// if capturedUnit = 1 then
31861: LD_EXP 34
31865: PUSH
31866: LD_INT 1
31868: EQUAL
31869: IFFALSE 31897
// begin Say ( Simms , DA-Sim-1 ) ;
31871: LD_EXP 75
31875: PPUSH
31876: LD_STRING DA-Sim-1
31878: PPUSH
31879: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31883: LD_EXP 74
31887: PPUSH
31888: LD_STRING DA-Roth-2
31890: PPUSH
31891: CALL_OW 88
// end else
31895: GO 31909
// Say ( Simms , DA-Sim-2 ) ;
31897: LD_EXP 75
31901: PPUSH
31902: LD_STRING DA-Sim-2
31904: PPUSH
31905: CALL_OW 88
// case unit of JMM :
31909: LD_VAR 0 1
31913: PUSH
31914: LD_EXP 39
31918: DOUBLE
31919: EQUAL
31920: IFTRUE 31924
31922: GO 31939
31924: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31925: LD_EXP 39
31929: PPUSH
31930: LD_STRING DA1-JMM-1a
31932: PPUSH
31933: CALL_OW 91
31937: GO 32446
31939: LD_EXP 40
31943: DOUBLE
31944: EQUAL
31945: IFTRUE 31949
31947: GO 31964
31949: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31950: LD_EXP 40
31954: PPUSH
31955: LD_STRING DA1-Joan-1a
31957: PPUSH
31958: CALL_OW 91
31962: GO 32446
31964: LD_EXP 42
31968: DOUBLE
31969: EQUAL
31970: IFTRUE 31974
31972: GO 31989
31974: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31975: LD_EXP 42
31979: PPUSH
31980: LD_STRING DA1-Lisa-1a
31982: PPUSH
31983: CALL_OW 91
31987: GO 32446
31989: LD_EXP 43
31993: DOUBLE
31994: EQUAL
31995: IFTRUE 31999
31997: GO 32014
31999: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32000: LD_EXP 43
32004: PPUSH
32005: LD_STRING DA1-Don-1a
32007: PPUSH
32008: CALL_OW 91
32012: GO 32446
32014: LD_EXP 50
32018: DOUBLE
32019: EQUAL
32020: IFTRUE 32024
32022: GO 32039
32024: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32025: LD_EXP 50
32029: PPUSH
32030: LD_STRING DA1-Corn-1a
32032: PPUSH
32033: CALL_OW 91
32037: GO 32446
32039: LD_EXP 46
32043: DOUBLE
32044: EQUAL
32045: IFTRUE 32049
32047: GO 32064
32049: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32050: LD_EXP 46
32054: PPUSH
32055: LD_STRING DA1-Den-1a
32057: PPUSH
32058: CALL_OW 91
32062: GO 32446
32064: LD_EXP 44
32068: DOUBLE
32069: EQUAL
32070: IFTRUE 32074
32072: GO 32089
32074: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32075: LD_EXP 44
32079: PPUSH
32080: LD_STRING DA1-Bobby-1a
32082: PPUSH
32083: CALL_OW 91
32087: GO 32446
32089: LD_EXP 48
32093: DOUBLE
32094: EQUAL
32095: IFTRUE 32099
32097: GO 32114
32099: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32100: LD_EXP 48
32104: PPUSH
32105: LD_STRING DA1-Glad-1a
32107: PPUSH
32108: CALL_OW 91
32112: GO 32446
32114: LD_EXP 45
32118: DOUBLE
32119: EQUAL
32120: IFTRUE 32124
32122: GO 32139
32124: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32125: LD_EXP 45
32129: PPUSH
32130: LD_STRING DA1-Cyrus-1a
32132: PPUSH
32133: CALL_OW 91
32137: GO 32446
32139: LD_EXP 41
32143: DOUBLE
32144: EQUAL
32145: IFTRUE 32149
32147: GO 32164
32149: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32150: LD_EXP 41
32154: PPUSH
32155: LD_STRING DA1-Huck-1a
32157: PPUSH
32158: CALL_OW 91
32162: GO 32446
32164: LD_EXP 55
32168: DOUBLE
32169: EQUAL
32170: IFTRUE 32174
32172: GO 32189
32174: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32175: LD_EXP 55
32179: PPUSH
32180: LD_STRING DA1-Huck-1a
32182: PPUSH
32183: CALL_OW 91
32187: GO 32446
32189: LD_EXP 47
32193: DOUBLE
32194: EQUAL
32195: IFTRUE 32199
32197: GO 32214
32199: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32200: LD_EXP 47
32204: PPUSH
32205: LD_STRING DA1-Brown-1a
32207: PPUSH
32208: CALL_OW 91
32212: GO 32446
32214: LD_EXP 51
32218: DOUBLE
32219: EQUAL
32220: IFTRUE 32224
32222: GO 32239
32224: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32225: LD_EXP 51
32229: PPUSH
32230: LD_STRING DA1-Gary-1a
32232: PPUSH
32233: CALL_OW 91
32237: GO 32446
32239: LD_EXP 54
32243: DOUBLE
32244: EQUAL
32245: IFTRUE 32249
32247: GO 32264
32249: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32250: LD_EXP 54
32254: PPUSH
32255: LD_STRING DA1-Con-1a
32257: PPUSH
32258: CALL_OW 91
32262: GO 32446
32264: LD_EXP 60
32268: DOUBLE
32269: EQUAL
32270: IFTRUE 32274
32272: GO 32289
32274: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32275: LD_EXP 60
32279: PPUSH
32280: LD_STRING DA1-Kurt-1a
32282: PPUSH
32283: CALL_OW 91
32287: GO 32446
32289: LD_EXP 53
32293: DOUBLE
32294: EQUAL
32295: IFTRUE 32299
32297: GO 32314
32299: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32300: LD_EXP 53
32304: PPUSH
32305: LD_STRING DA1-Yam-1a
32307: PPUSH
32308: CALL_OW 91
32312: GO 32446
32314: LD_EXP 52
32318: DOUBLE
32319: EQUAL
32320: IFTRUE 32324
32322: GO 32339
32324: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32325: LD_EXP 52
32329: PPUSH
32330: LD_STRING DA1-Frank-1a
32332: PPUSH
32333: CALL_OW 91
32337: GO 32446
32339: POP
// begin join := rand ( 0 , 1 ) ;
32340: LD_ADDR_VAR 0 3
32344: PUSH
32345: LD_INT 0
32347: PPUSH
32348: LD_INT 1
32350: PPUSH
32351: CALL_OW 12
32355: ST_TO_ADDR
// if join then
32356: LD_VAR 0 3
32360: IFFALSE 32405
// begin if GetSex ( unit ) = sex_male then
32362: LD_VAR 0 1
32366: PPUSH
32367: CALL_OW 258
32371: PUSH
32372: LD_INT 1
32374: EQUAL
32375: IFFALSE 32391
// ForceSay ( unit , DA1-Sol1-1b ) else
32377: LD_VAR 0 1
32381: PPUSH
32382: LD_STRING DA1-Sol1-1b
32384: PPUSH
32385: CALL_OW 91
32389: GO 32403
// ForceSay ( unit , DA1-FSol1-1b ) ;
32391: LD_VAR 0 1
32395: PPUSH
32396: LD_STRING DA1-FSol1-1b
32398: PPUSH
32399: CALL_OW 91
// end else
32403: GO 32446
// begin if GetSex ( unit ) = sex_male then
32405: LD_VAR 0 1
32409: PPUSH
32410: CALL_OW 258
32414: PUSH
32415: LD_INT 1
32417: EQUAL
32418: IFFALSE 32434
// ForceSay ( unit , DA1-Sol1-1a ) else
32420: LD_VAR 0 1
32424: PPUSH
32425: LD_STRING DA1-Sol1-1a
32427: PPUSH
32428: CALL_OW 91
32432: GO 32446
// ForceSay ( unit , DA1-FSol1-1a ) ;
32434: LD_VAR 0 1
32438: PPUSH
32439: LD_STRING DA1-FSol1-1a
32441: PPUSH
32442: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32446: LD_VAR 0 1
32450: PUSH
32451: LD_EXP 39
32455: EQUAL
32456: IFFALSE 32467
// begin YouLost ( JMMCaptured ) ;
32458: LD_STRING JMMCaptured
32460: PPUSH
32461: CALL_OW 104
// exit ;
32465: GO 32765
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32467: LD_VAR 0 1
32471: PUSH
32472: LD_EXP 43
32476: PUSH
32477: LD_EXP 46
32481: PUSH
32482: LD_EXP 44
32486: PUSH
32487: LD_EXP 41
32491: PUSH
32492: LD_EXP 55
32496: PUSH
32497: LD_EXP 47
32501: PUSH
32502: LD_EXP 53
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: IN
32516: PUSH
32517: LD_VAR 0 3
32521: OR
32522: IFFALSE 32621
// begin Say ( Roth , DA-Roth-3 ) ;
32524: LD_EXP 74
32528: PPUSH
32529: LD_STRING DA-Roth-3
32531: PPUSH
32532: CALL_OW 88
// SetSide ( unit , 7 ) ;
32536: LD_VAR 0 1
32540: PPUSH
32541: LD_INT 7
32543: PPUSH
32544: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32548: LD_ADDR_EXP 116
32552: PUSH
32553: LD_EXP 116
32557: PPUSH
32558: LD_INT 1
32560: PPUSH
32561: LD_EXP 116
32565: PUSH
32566: LD_INT 1
32568: ARRAY
32569: PUSH
32570: LD_VAR 0 1
32574: ADD
32575: PPUSH
32576: CALL_OW 1
32580: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32581: LD_INT 260
32583: PPUSH
32584: LD_INT 235
32586: PPUSH
32587: LD_INT 1
32589: PPUSH
32590: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32594: LD_VAR 0 1
32598: PPUSH
32599: LD_INT 1000
32601: PPUSH
32602: CALL_OW 234
// DialogueOff ;
32606: CALL_OW 7
// ComFree ( unit ) ;
32610: LD_VAR 0 1
32614: PPUSH
32615: CALL_OW 139
// end else
32619: GO 32702
// begin Say ( Roth , DA-Roth-3a ) ;
32621: LD_EXP 74
32625: PPUSH
32626: LD_STRING DA-Roth-3a
32628: PPUSH
32629: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32633: LD_ADDR_EXP 35
32637: PUSH
32638: LD_EXP 35
32642: PUSH
32643: LD_VAR 0 1
32647: ADD
32648: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32649: LD_INT 260
32651: PPUSH
32652: LD_INT 235
32654: PPUSH
32655: LD_INT 1
32657: PPUSH
32658: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32662: LD_VAR 0 1
32666: PPUSH
32667: LD_INT 1000
32669: PPUSH
32670: CALL_OW 234
// DialogueOff ;
32674: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32678: LD_VAR 0 1
32682: PPUSH
32683: LD_INT 272
32685: PPUSH
32686: LD_INT 254
32688: PPUSH
32689: CALL_OW 111
// AddComHold ( unit ) ;
32693: LD_VAR 0 1
32697: PPUSH
32698: CALL_OW 200
// end ; if capturedUnit = 1 then
32702: LD_EXP 34
32706: PUSH
32707: LD_INT 1
32709: EQUAL
32710: IFFALSE 32765
// begin DialogueOn ;
32712: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32716: LD_EXP 39
32720: PPUSH
32721: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32725: LD_EXP 39
32729: PPUSH
32730: LD_STRING DAa-JMM-1
32732: PPUSH
32733: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32737: LD_EXP 39
32741: PPUSH
32742: LD_STRING DAa-JMM-1a
32744: PPUSH
32745: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32749: LD_EXP 39
32753: PPUSH
32754: LD_STRING DAa-JMM-1b
32756: PPUSH
32757: CALL_OW 88
// DialogueOff ;
32761: CALL_OW 7
// end ; end ;
32765: LD_VAR 0 2
32769: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32770: LD_EXP 15
32774: PUSH
32775: LD_INT 13
32777: GREATEREQUAL
32778: PUSH
32779: LD_INT 22
32781: PUSH
32782: LD_INT 2
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 21
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PPUSH
32803: CALL_OW 69
32807: PUSH
32808: LD_INT 0
32810: EQUAL
32811: AND
32812: PUSH
32813: LD_INT 22
32815: PUSH
32816: LD_INT 2
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 33
32825: PUSH
32826: LD_INT 5
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 21
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 50
32845: PUSH
32846: EMPTY
32847: LIST
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: LIST
32853: LIST
32854: PPUSH
32855: CALL_OW 69
32859: PUSH
32860: LD_INT 0
32862: EQUAL
32863: AND
32864: PUSH
32865: LD_EXP 21
32869: AND
32870: PUSH
32871: LD_EXP 22
32875: AND
32876: PUSH
32877: LD_EXP 23
32881: AND
32882: IFFALSE 33531
32884: GO 32886
32886: DISABLE
32887: LD_INT 0
32889: PPUSH
32890: PPUSH
32891: PPUSH
// begin m1 := false ;
32892: LD_ADDR_VAR 0 1
32896: PUSH
32897: LD_INT 0
32899: ST_TO_ADDR
// m2 := false ;
32900: LD_ADDR_VAR 0 2
32904: PUSH
32905: LD_INT 0
32907: ST_TO_ADDR
// m3 := false ;
32908: LD_ADDR_VAR 0 3
32912: PUSH
32913: LD_INT 0
32915: ST_TO_ADDR
// if not bombExploded then
32916: LD_EXP 37
32920: NOT
32921: IFFALSE 32930
// SetAchievement ( ACH_SIBROCKET ) ;
32923: LD_STRING ACH_SIBROCKET
32925: PPUSH
32926: CALL_OW 543
// if tick <= 120 120$00 then
32930: LD_OWVAR 1
32934: PUSH
32935: LD_INT 252000
32937: LESSEQUAL
32938: IFFALSE 32954
// begin wait ( 3 ) ;
32940: LD_INT 3
32942: PPUSH
32943: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32947: LD_STRING ACH_ASPEED_15
32949: PPUSH
32950: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32954: LD_EXP 39
32958: PPUSH
32959: CALL_OW 87
// music_class := 5 ;
32963: LD_ADDR_OWVAR 72
32967: PUSH
32968: LD_INT 5
32970: ST_TO_ADDR
// music_nat := 5 ;
32971: LD_ADDR_OWVAR 71
32975: PUSH
32976: LD_INT 5
32978: ST_TO_ADDR
// DialogueOn ;
32979: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32983: LD_EXP 39
32987: PPUSH
32988: LD_STRING D20-JMM-1
32990: PPUSH
32991: CALL_OW 88
// if IsOK ( Joan ) then
32995: LD_EXP 40
32999: PPUSH
33000: CALL_OW 302
33004: IFFALSE 33018
// Say ( Joan , D20-Joan-1 ) ;
33006: LD_EXP 40
33010: PPUSH
33011: LD_STRING D20-Joan-1
33013: PPUSH
33014: CALL_OW 88
// if IsOk ( Lisa ) then
33018: LD_EXP 42
33022: PPUSH
33023: CALL_OW 302
33027: IFFALSE 33041
// Say ( Lisa , D20-Lisa-1 ) ;
33029: LD_EXP 42
33033: PPUSH
33034: LD_STRING D20-Lisa-1
33036: PPUSH
33037: CALL_OW 88
// if IsOk ( Donaldson ) then
33041: LD_EXP 43
33045: PPUSH
33046: CALL_OW 302
33050: IFFALSE 33064
// Say ( Donaldson , D20-Don-1 ) ;
33052: LD_EXP 43
33056: PPUSH
33057: LD_STRING D20-Don-1
33059: PPUSH
33060: CALL_OW 88
// if IsOK ( Cornel ) then
33064: LD_EXP 50
33068: PPUSH
33069: CALL_OW 302
33073: IFFALSE 33087
// Say ( Cornel , D20-Corn-1 ) ;
33075: LD_EXP 50
33079: PPUSH
33080: LD_STRING D20-Corn-1
33082: PPUSH
33083: CALL_OW 88
// if IsOk ( Denis ) then
33087: LD_EXP 46
33091: PPUSH
33092: CALL_OW 302
33096: IFFALSE 33110
// Say ( Denis , D20-Den-1 ) ;
33098: LD_EXP 46
33102: PPUSH
33103: LD_STRING D20-Den-1
33105: PPUSH
33106: CALL_OW 88
// if IsOk ( Bobby ) then
33110: LD_EXP 44
33114: PPUSH
33115: CALL_OW 302
33119: IFFALSE 33133
// Say ( Bobby , D20-Bobby-1 ) ;
33121: LD_EXP 44
33125: PPUSH
33126: LD_STRING D20-Bobby-1
33128: PPUSH
33129: CALL_OW 88
// if IsOk ( Gladstone ) then
33133: LD_EXP 48
33137: PPUSH
33138: CALL_OW 302
33142: IFFALSE 33156
// Say ( Gladstone , D20-Glad-1 ) ;
33144: LD_EXP 48
33148: PPUSH
33149: LD_STRING D20-Glad-1
33151: PPUSH
33152: CALL_OW 88
// if IsOk ( Cyrus ) then
33156: LD_EXP 45
33160: PPUSH
33161: CALL_OW 302
33165: IFFALSE 33179
// Say ( Cyrus , D20-Cyrus-1 ) ;
33167: LD_EXP 45
33171: PPUSH
33172: LD_STRING D20-Cyrus-1
33174: PPUSH
33175: CALL_OW 88
// if IsOk ( Stevens ) then
33179: LD_EXP 41
33183: PPUSH
33184: CALL_OW 302
33188: IFFALSE 33202
// Say ( Stevens , D20-Huck-1 ) ;
33190: LD_EXP 41
33194: PPUSH
33195: LD_STRING D20-Huck-1
33197: PPUSH
33198: CALL_OW 88
// if IsOk ( Brown ) then
33202: LD_EXP 47
33206: PPUSH
33207: CALL_OW 302
33211: IFFALSE 33225
// Say ( Brown , D20-Brown-1 ) ;
33213: LD_EXP 47
33217: PPUSH
33218: LD_STRING D20-Brown-1
33220: PPUSH
33221: CALL_OW 88
// if IsOk ( Gary ) then
33225: LD_EXP 51
33229: PPUSH
33230: CALL_OW 302
33234: IFFALSE 33248
// Say ( Gary , D20-Gary-1 ) ;
33236: LD_EXP 51
33240: PPUSH
33241: LD_STRING D20-Gary-1
33243: PPUSH
33244: CALL_OW 88
// if IsOk ( Connie ) then
33248: LD_EXP 54
33252: PPUSH
33253: CALL_OW 302
33257: IFFALSE 33271
// Say ( Connie , D20-Con-1 ) ;
33259: LD_EXP 54
33263: PPUSH
33264: LD_STRING D20-Con-1
33266: PPUSH
33267: CALL_OW 88
// if IsOk ( Kurt ) then
33271: LD_EXP 60
33275: PPUSH
33276: CALL_OW 302
33280: IFFALSE 33294
// Say ( Kurt , D20-Kurt-1 ) ;
33282: LD_EXP 60
33286: PPUSH
33287: LD_STRING D20-Kurt-1
33289: PPUSH
33290: CALL_OW 88
// if IsOk ( Kikuchi ) then
33294: LD_EXP 53
33298: PPUSH
33299: CALL_OW 302
33303: IFFALSE 33317
// Say ( Kikuchi , D20-Yam-1 ) ;
33305: LD_EXP 53
33309: PPUSH
33310: LD_STRING D20-Yam-1
33312: PPUSH
33313: CALL_OW 88
// if IsOk ( Frank ) then
33317: LD_EXP 52
33321: PPUSH
33322: CALL_OW 302
33326: IFFALSE 33340
// Say ( Frank , D20-Frank-1 ) ;
33328: LD_EXP 52
33332: PPUSH
33333: LD_STRING D20-Frank-1
33335: PPUSH
33336: CALL_OW 88
// DialogueOff ;
33340: CALL_OW 7
// if RothCaptured then
33344: LD_EXP 33
33348: IFFALSE 33370
// begin m1 := true ;
33350: LD_ADDR_VAR 0 1
33354: PUSH
33355: LD_INT 1
33357: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33358: LD_STRING Roth
33360: PPUSH
33361: LD_INT 1
33363: PPUSH
33364: CALL_OW 101
// end else
33368: GO 33381
// AddMedal ( Roth , - 1 ) ;
33370: LD_STRING Roth
33372: PPUSH
33373: LD_INT 1
33375: NEG
33376: PPUSH
33377: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33381: LD_EXP 25
33385: NOT
33386: PUSH
33387: LD_EXP 27
33391: OR
33392: IFFALSE 33414
// begin m2 := true ;
33394: LD_ADDR_VAR 0 2
33398: PUSH
33399: LD_INT 1
33401: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33402: LD_STRING Project
33404: PPUSH
33405: LD_INT 1
33407: PPUSH
33408: CALL_OW 101
// end else
33412: GO 33425
// AddMedal ( Project , - 1 ) ;
33414: LD_STRING Project
33416: PPUSH
33417: LD_INT 1
33419: NEG
33420: PPUSH
33421: CALL_OW 101
// if lostCounter = 0 then
33425: LD_EXP 32
33429: PUSH
33430: LD_INT 0
33432: EQUAL
33433: IFFALSE 33455
// begin m3 := true ;
33435: LD_ADDR_VAR 0 3
33439: PUSH
33440: LD_INT 1
33442: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33443: LD_STRING NoLosses
33445: PPUSH
33446: LD_INT 1
33448: PPUSH
33449: CALL_OW 101
// end else
33453: GO 33466
// AddMedal ( NoLosses , - 1 ) ;
33455: LD_STRING NoLosses
33457: PPUSH
33458: LD_INT 1
33460: NEG
33461: PPUSH
33462: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33466: LD_VAR 0 1
33470: PUSH
33471: LD_VAR 0 2
33475: AND
33476: PUSH
33477: LD_VAR 0 3
33481: AND
33482: PUSH
33483: LD_OWVAR 67
33487: PUSH
33488: LD_INT 3
33490: GREATEREQUAL
33491: AND
33492: IFFALSE 33504
// SetAchievementEX ( ACH_AMER , 15 ) ;
33494: LD_STRING ACH_AMER
33496: PPUSH
33497: LD_INT 15
33499: PPUSH
33500: CALL_OW 564
// GiveMedals ( MAIN ) ;
33504: LD_STRING MAIN
33506: PPUSH
33507: CALL_OW 102
// music_class := 4 ;
33511: LD_ADDR_OWVAR 72
33515: PUSH
33516: LD_INT 4
33518: ST_TO_ADDR
// music_nat := 1 ;
33519: LD_ADDR_OWVAR 71
33523: PUSH
33524: LD_INT 1
33526: ST_TO_ADDR
// YouWin ;
33527: CALL_OW 103
// end ; end_of_file
33531: PPOPN 3
33533: END
// export function CustomEvent ( event ) ; begin
33534: LD_INT 0
33536: PPUSH
// end ;
33537: LD_VAR 0 2
33541: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33542: LD_VAR 0 1
33546: PUSH
33547: LD_INT 1
33549: EQUAL
33550: PUSH
33551: LD_VAR 0 2
33555: PUSH
33556: LD_INT 4
33558: EQUAL
33559: AND
33560: PUSH
33561: LD_EXP 58
33565: PPUSH
33566: CALL_OW 300
33570: AND
33571: IFFALSE 33587
// begin wait ( 0 0$2 ) ;
33573: LD_INT 70
33575: PPUSH
33576: CALL_OW 67
// YouLost ( Dismissed ) ;
33580: LD_STRING Dismissed
33582: PPUSH
33583: CALL_OW 104
// end ; end ;
33587: PPOPN 2
33589: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33590: LD_VAR 0 2
33594: PPUSH
33595: LD_VAR 0 3
33599: PPUSH
33600: LD_INT 18
33602: PPUSH
33603: CALL_OW 309
33607: IFFALSE 33616
// YouLost ( Motherlode3 ) ;
33609: LD_STRING Motherlode3
33611: PPUSH
33612: CALL_OW 104
// end ;
33616: PPOPN 3
33618: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33619: LD_EXP 27
33623: NOT
33624: IFFALSE 33634
// behemothDone := true ;
33626: LD_ADDR_EXP 28
33630: PUSH
33631: LD_INT 1
33633: ST_TO_ADDR
// end ;
33634: PPOPN 1
33636: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33637: LD_VAR 0 1
33641: PPUSH
33642: CALL_OW 255
33646: PUSH
33647: LD_INT 1
33649: EQUAL
33650: IFFALSE 33660
// bombExploded := true ;
33652: LD_ADDR_EXP 37
33656: PUSH
33657: LD_INT 1
33659: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33660: LD_VAR 0 1
33664: PPUSH
33665: CALL_OW 255
33669: PUSH
33670: LD_INT 1
33672: EQUAL
33673: PUSH
33674: LD_EXP 30
33678: AND
33679: PUSH
33680: LD_INT 22
33682: PUSH
33683: LD_INT 3
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 34
33692: PUSH
33693: LD_INT 48
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 69
33708: AND
33709: PUSH
33710: LD_INT 22
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 34
33722: PUSH
33723: LD_INT 8
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PPUSH
33734: CALL_OW 69
33738: NOT
33739: AND
33740: IFFALSE 33792
// begin wait ( 0 0$5 ) ;
33742: LD_INT 175
33744: PPUSH
33745: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33749: LD_INT 22
33751: PUSH
33752: LD_INT 3
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 34
33761: PUSH
33762: LD_INT 48
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PPUSH
33773: CALL_OW 69
33777: PUSH
33778: LD_INT 1
33780: ARRAY
33781: PPUSH
33782: LD_INT 60
33784: PPUSH
33785: LD_INT 95
33787: PPUSH
33788: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33792: LD_VAR 0 2
33796: PPUSH
33797: LD_VAR 0 3
33801: PPUSH
33802: LD_INT 18
33804: PPUSH
33805: CALL_OW 309
33809: IFFALSE 33856
// begin if GetSide ( unit ) = 1 then
33811: LD_VAR 0 1
33815: PPUSH
33816: CALL_OW 255
33820: PUSH
33821: LD_INT 1
33823: EQUAL
33824: IFFALSE 33842
// begin wait ( 0 0$6 ) ;
33826: LD_INT 210
33828: PPUSH
33829: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33833: LD_STRING Motherlode2
33835: PPUSH
33836: CALL_OW 104
// end else
33840: GO 33856
// begin wait ( 0 0$6 ) ;
33842: LD_INT 210
33844: PPUSH
33845: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33849: LD_STRING Motherlode1
33851: PPUSH
33852: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33856: LD_VAR 0 1
33860: PPUSH
33861: CALL_OW 255
33865: PUSH
33866: LD_INT 3
33868: EQUAL
33869: IFFALSE 33890
// begin wait ( 0 0$5 ) ;
33871: LD_INT 175
33873: PPUSH
33874: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33878: LD_EXP 64
33882: PPUSH
33883: LD_STRING D18-Pla-1
33885: PPUSH
33886: CALL_OW 94
// end ; end ;
33890: PPOPN 3
33892: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33893: LD_VAR 0 1
33897: PUSH
33898: LD_INT 22
33900: PUSH
33901: LD_INT 1
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 21
33910: PUSH
33911: LD_INT 1
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 23
33920: PUSH
33921: LD_INT 1
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: LIST
33932: PPUSH
33933: CALL_OW 69
33937: IN
33938: IFFALSE 33954
// lostCounter := lostCounter + 1 ;
33940: LD_ADDR_EXP 32
33944: PUSH
33945: LD_EXP 32
33949: PUSH
33950: LD_INT 1
33952: PLUS
33953: ST_TO_ADDR
// if un in behemothBuilders then
33954: LD_VAR 0 1
33958: PUSH
33959: LD_EXP 73
33963: IN
33964: IFFALSE 33984
// begin behemothBuilders := behemothBuilders diff un ;
33966: LD_ADDR_EXP 73
33970: PUSH
33971: LD_EXP 73
33975: PUSH
33976: LD_VAR 0 1
33980: DIFF
33981: ST_TO_ADDR
// exit ;
33982: GO 34014
// end ; if un = JMM then
33984: LD_VAR 0 1
33988: PUSH
33989: LD_EXP 39
33993: EQUAL
33994: IFFALSE 34005
// begin YouLost ( JMM ) ;
33996: LD_STRING JMM
33998: PPUSH
33999: CALL_OW 104
// exit ;
34003: GO 34014
// end ; MCE_UnitDestroyed ( un ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: CALL 62728 0 1
// end ;
34014: PPOPN 1
34016: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34017: LD_VAR 0 1
34021: PPUSH
34022: LD_VAR 0 2
34026: PPUSH
34027: CALL 65062 0 2
// end ;
34031: PPOPN 2
34033: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34034: LD_VAR 0 1
34038: PPUSH
34039: CALL 64130 0 1
// end ;
34043: PPOPN 1
34045: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34046: LD_VAR 0 1
34050: PUSH
34051: LD_INT 22
34053: PUSH
34054: LD_INT 8
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 30
34063: PUSH
34064: LD_INT 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 23
34073: PUSH
34074: LD_INT 3
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: LIST
34085: PPUSH
34086: CALL_OW 69
34090: IN
34091: IFFALSE 34118
// begin ComUpgrade ( building ) ;
34093: LD_VAR 0 1
34097: PPUSH
34098: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34102: LD_EXP 61
34106: PPUSH
34107: LD_VAR 0 1
34111: PPUSH
34112: CALL 73563 0 2
// exit ;
34116: GO 34127
// end ; MCE_BuildingComplete ( building ) ;
34118: LD_VAR 0 1
34122: PPUSH
34123: CALL 64371 0 1
// end ;
34127: PPOPN 1
34129: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: CALL 62424 0 2
// end ;
34144: PPOPN 2
34146: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34147: LD_VAR 0 1
34151: PPUSH
34152: LD_VAR 0 2
34156: PPUSH
34157: LD_VAR 0 3
34161: PPUSH
34162: LD_VAR 0 4
34166: PPUSH
34167: LD_VAR 0 5
34171: PPUSH
34172: CALL 62044 0 5
// end ;
34176: PPOPN 5
34178: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34179: LD_VAR 0 1
34183: PPUSH
34184: LD_VAR 0 2
34188: PPUSH
34189: CALL 61625 0 2
// end ;
34193: PPOPN 2
34195: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34196: LD_VAR 0 1
34200: PPUSH
34201: LD_VAR 0 2
34205: PPUSH
34206: LD_VAR 0 3
34210: PPUSH
34211: LD_VAR 0 4
34215: PPUSH
34216: CALL 61463 0 4
// end ;
34220: PPOPN 4
34222: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34223: LD_VAR 0 1
34227: PPUSH
34228: LD_VAR 0 2
34232: PPUSH
34233: LD_VAR 0 3
34237: PPUSH
34238: CALL 61238 0 3
// end ;
34242: PPOPN 3
34244: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34245: LD_VAR 0 1
34249: PPUSH
34250: LD_VAR 0 2
34254: PPUSH
34255: CALL 61123 0 2
// end ;
34259: PPOPN 2
34261: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34262: LD_VAR 0 1
34266: PPUSH
34267: LD_VAR 0 2
34271: PPUSH
34272: CALL 65357 0 2
// end ;
34276: PPOPN 2
34278: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34279: LD_VAR 0 1
34283: PPUSH
34284: CALL_OW 255
34288: PUSH
34289: LD_INT 4
34291: EQUAL
34292: PUSH
34293: LD_VAR 0 1
34297: PUSH
34298: LD_EXP 18
34302: PUSH
34303: LD_INT 1
34305: ARRAY
34306: IN
34307: AND
34308: PUSH
34309: LD_EXP 19
34313: AND
34314: IFFALSE 34333
// begin ComMoveXY ( driver , 61 , 93 ) ;
34316: LD_VAR 0 1
34320: PPUSH
34321: LD_INT 61
34323: PPUSH
34324: LD_INT 93
34326: PPUSH
34327: CALL_OW 111
// exit ;
34331: GO 34357
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34333: LD_VAR 0 1
34337: PPUSH
34338: LD_VAR 0 2
34342: PPUSH
34343: LD_VAR 0 3
34347: PPUSH
34348: LD_VAR 0 4
34352: PPUSH
34353: CALL 65573 0 4
// end ;
34357: PPOPN 4
34359: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34360: LD_VAR 0 1
34364: PPUSH
34365: LD_VAR 0 2
34369: PPUSH
34370: CALL 60932 0 2
// end ;
34374: PPOPN 2
34376: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34377: LD_VAR 0 1
34381: PPUSH
34382: CALL 118547 0 1
// end ; end_of_file
34386: PPOPN 1
34388: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34389: LD_EXP 15
34393: PUSH
34394: LD_INT 2
34396: EQUAL
34397: IFFALSE 34880
34399: GO 34401
34401: DISABLE
34402: LD_INT 0
34404: PPUSH
// begin time := 0 0$40 ;
34405: LD_ADDR_VAR 0 1
34409: PUSH
34410: LD_INT 1400
34412: ST_TO_ADDR
// repeat wait ( time ) ;
34413: LD_VAR 0 1
34417: PPUSH
34418: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34422: LD_INT 1
34424: PPUSH
34425: LD_INT 5
34427: PPUSH
34428: CALL_OW 12
34432: PPUSH
34433: LD_INT 106
34435: PPUSH
34436: LD_INT 150
34438: PPUSH
34439: LD_INT 19
34441: PPUSH
34442: LD_INT 1
34444: PPUSH
34445: CALL_OW 56
// time := time + 0 0$9 ;
34449: LD_ADDR_VAR 0 1
34453: PUSH
34454: LD_VAR 0 1
34458: PUSH
34459: LD_INT 315
34461: PLUS
34462: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34463: LD_INT 455
34465: PPUSH
34466: LD_INT 840
34468: PPUSH
34469: CALL_OW 12
34473: PPUSH
34474: CALL_OW 67
// if Prob ( 50 ) then
34478: LD_INT 50
34480: PPUSH
34481: CALL_OW 13
34485: IFFALSE 34514
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34487: LD_INT 1
34489: PPUSH
34490: LD_INT 5
34492: PPUSH
34493: CALL_OW 12
34497: PPUSH
34498: LD_INT 62
34500: PPUSH
34501: LD_INT 108
34503: PPUSH
34504: LD_INT 10
34506: PPUSH
34507: LD_INT 1
34509: PPUSH
34510: CALL_OW 56
// until missionStage > 4 ;
34514: LD_EXP 15
34518: PUSH
34519: LD_INT 4
34521: GREATER
34522: IFFALSE 34413
// repeat wait ( 0 0$1 ) ;
34524: LD_INT 35
34526: PPUSH
34527: CALL_OW 67
// until missionStage = 6 ;
34531: LD_EXP 15
34535: PUSH
34536: LD_INT 6
34538: EQUAL
34539: IFFALSE 34524
// time := 0 0$50 ;
34541: LD_ADDR_VAR 0 1
34545: PUSH
34546: LD_INT 1750
34548: ST_TO_ADDR
// repeat wait ( time ) ;
34549: LD_VAR 0 1
34553: PPUSH
34554: CALL_OW 67
// if Prob ( 50 ) then
34558: LD_INT 50
34560: PPUSH
34561: CALL_OW 13
34565: IFFALSE 34594
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34567: LD_INT 1
34569: PPUSH
34570: LD_INT 5
34572: PPUSH
34573: CALL_OW 12
34577: PPUSH
34578: LD_INT 106
34580: PPUSH
34581: LD_INT 89
34583: PPUSH
34584: LD_INT 45
34586: PPUSH
34587: LD_INT 1
34589: PPUSH
34590: CALL_OW 56
// time := time + 0 0$2 ;
34594: LD_ADDR_VAR 0 1
34598: PUSH
34599: LD_VAR 0 1
34603: PUSH
34604: LD_INT 70
34606: PLUS
34607: ST_TO_ADDR
// if Prob ( 30 ) then
34608: LD_INT 30
34610: PPUSH
34611: CALL_OW 13
34615: IFFALSE 34661
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34617: LD_INT 385
34619: PPUSH
34620: LD_INT 945
34622: PPUSH
34623: CALL_OW 12
34627: PPUSH
34628: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34632: LD_INT 1
34634: PPUSH
34635: LD_INT 5
34637: PPUSH
34638: CALL_OW 12
34642: PPUSH
34643: LD_INT 21
34645: PPUSH
34646: LD_INT 26
34648: PPUSH
34649: LD_INT 12
34651: PPUSH
34652: LD_INT 1
34654: PPUSH
34655: CALL_OW 56
// end else
34659: GO 34697
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34661: LD_INT 700
34663: PPUSH
34664: LD_INT 1225
34666: PPUSH
34667: CALL_OW 12
34671: PPUSH
34672: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34676: LD_INT 1
34678: PPUSH
34679: LD_INT 5
34681: PPUSH
34682: CALL_OW 12
34686: PPUSH
34687: LD_INT 16
34689: PPUSH
34690: LD_INT 1
34692: PPUSH
34693: CALL_OW 55
// end ; if Prob ( 50 ) then
34697: LD_INT 50
34699: PPUSH
34700: CALL_OW 13
34704: IFFALSE 34750
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34706: LD_INT 700
34708: PPUSH
34709: LD_INT 1050
34711: PPUSH
34712: CALL_OW 12
34716: PPUSH
34717: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34721: LD_INT 1
34723: PPUSH
34724: LD_INT 5
34726: PPUSH
34727: CALL_OW 12
34731: PPUSH
34732: LD_INT 181
34734: PPUSH
34735: LD_INT 218
34737: PPUSH
34738: LD_INT 16
34740: PPUSH
34741: LD_INT 1
34743: PPUSH
34744: CALL_OW 56
// end else
34748: GO 34786
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34750: LD_INT 350
34752: PPUSH
34753: LD_INT 525
34755: PPUSH
34756: CALL_OW 12
34760: PPUSH
34761: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34765: LD_INT 1
34767: PPUSH
34768: LD_INT 5
34770: PPUSH
34771: CALL_OW 12
34775: PPUSH
34776: LD_INT 15
34778: PPUSH
34779: LD_INT 1
34781: PPUSH
34782: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34786: LD_INT 45
34788: PUSH
34789: LD_INT 32
34791: PUSH
34792: LD_INT 25
34794: PUSH
34795: LD_INT 22
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: PUSH
34804: LD_OWVAR 67
34808: ARRAY
34809: PPUSH
34810: CALL_OW 13
34814: IFFALSE 34858
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34816: LD_INT 175
34818: PPUSH
34819: LD_INT 315
34821: PPUSH
34822: CALL_OW 12
34826: PPUSH
34827: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34831: LD_INT 1
34833: PPUSH
34834: LD_INT 5
34836: PPUSH
34837: CALL_OW 12
34841: PPUSH
34842: LD_INT 103
34844: PPUSH
34845: LD_INT 140
34847: PPUSH
34848: LD_INT 20
34850: PPUSH
34851: LD_INT 1
34853: PPUSH
34854: CALL_OW 56
// end ; if time > 1 1$20 then
34858: LD_VAR 0 1
34862: PUSH
34863: LD_INT 2800
34865: GREATER
34866: IFFALSE 34876
// time := 0 0$30 ;
34868: LD_ADDR_VAR 0 1
34872: PUSH
34873: LD_INT 1050
34875: ST_TO_ADDR
// until false ;
34876: LD_INT 0
34878: IFFALSE 34549
// end ; end_of_file
34880: PPOPN 1
34882: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34883: LD_EXP 13
34887: PUSH
34888: LD_EXP 15
34892: PUSH
34893: LD_INT 6
34895: GREATEREQUAL
34896: AND
34897: IFFALSE 34934
34899: GO 34901
34901: DISABLE
// begin enable ;
34902: ENABLE
// missionTime := missionTime + 0 0$1 ;
34903: LD_ADDR_EXP 14
34907: PUSH
34908: LD_EXP 14
34912: PUSH
34913: LD_INT 35
34915: PLUS
34916: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34917: LD_ADDR_OWVAR 47
34921: PUSH
34922: LD_STRING #Am15-1
34924: PUSH
34925: LD_EXP 14
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: ST_TO_ADDR
// end ; end_of_file
34934: END
// export function InitNature ; begin
34935: LD_INT 0
34937: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34938: LD_INT 3
34940: PPUSH
34941: LD_INT 3
34943: PPUSH
34944: LD_INT 2
34946: PPUSH
34947: LD_INT 1
34949: PPUSH
34950: LD_INT 1
34952: PPUSH
34953: LD_INT 0
34955: PPUSH
34956: LD_INT 0
34958: PPUSH
34959: LD_INT 20
34961: PPUSH
34962: LD_INT 0
34964: PPUSH
34965: CALL 99077 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34969: LD_INT 2
34971: PPUSH
34972: LD_INT 1
34974: PPUSH
34975: LD_INT 1
34977: PPUSH
34978: LD_INT 1
34980: PPUSH
34981: LD_INT 1
34983: PPUSH
34984: LD_INT 0
34986: PPUSH
34987: LD_INT 0
34989: PPUSH
34990: LD_INT 21
34992: PPUSH
34993: LD_INT 0
34995: PPUSH
34996: CALL 99077 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35000: LD_INT 4
35002: PPUSH
35003: LD_INT 1
35005: PPUSH
35006: LD_INT 2
35008: PPUSH
35009: LD_INT 4
35011: PPUSH
35012: LD_INT 2
35014: PPUSH
35015: LD_INT 1
35017: PPUSH
35018: LD_INT 0
35020: PPUSH
35021: LD_INT 22
35023: PPUSH
35024: LD_INT 0
35026: PPUSH
35027: CALL 99077 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35031: LD_INT 0
35033: PPUSH
35034: LD_INT 0
35036: PPUSH
35037: LD_INT 0
35039: PPUSH
35040: LD_INT 0
35042: PPUSH
35043: LD_INT 0
35045: PPUSH
35046: LD_INT 0
35048: PPUSH
35049: LD_INT 9
35051: PPUSH
35052: LD_INT 0
35054: PPUSH
35055: LD_INT 23
35057: PPUSH
35058: CALL 99077 0 9
// end ; end_of_file
35062: LD_VAR 0 1
35066: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
35067: LD_INT 0
35069: PPUSH
// ar_miner := 81 ;
35070: LD_ADDR_EXP 102
35074: PUSH
35075: LD_INT 81
35077: ST_TO_ADDR
// ar_crane := 88 ;
35078: LD_ADDR_EXP 101
35082: PUSH
35083: LD_INT 88
35085: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35086: LD_ADDR_EXP 96
35090: PUSH
35091: LD_INT 89
35093: ST_TO_ADDR
// us_hack := 99 ;
35094: LD_ADDR_EXP 97
35098: PUSH
35099: LD_INT 99
35101: ST_TO_ADDR
// us_artillery := 97 ;
35102: LD_ADDR_EXP 98
35106: PUSH
35107: LD_INT 97
35109: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35110: LD_ADDR_EXP 99
35114: PUSH
35115: LD_INT 91
35117: ST_TO_ADDR
// ar_mortar := 92 ;
35118: LD_ADDR_EXP 100
35122: PUSH
35123: LD_INT 92
35125: ST_TO_ADDR
// ru_radar := 98 ;
35126: LD_ADDR_EXP 95
35130: PUSH
35131: LD_INT 98
35133: ST_TO_ADDR
// tech_Artillery := 80 ;
35134: LD_ADDR_EXP 103
35138: PUSH
35139: LD_INT 80
35141: ST_TO_ADDR
// tech_RadMat := 81 ;
35142: LD_ADDR_EXP 104
35146: PUSH
35147: LD_INT 81
35149: ST_TO_ADDR
// tech_BasicTools := 82 ;
35150: LD_ADDR_EXP 105
35154: PUSH
35155: LD_INT 82
35157: ST_TO_ADDR
// tech_Cargo := 83 ;
35158: LD_ADDR_EXP 106
35162: PUSH
35163: LD_INT 83
35165: ST_TO_ADDR
// tech_Track := 84 ;
35166: LD_ADDR_EXP 107
35170: PUSH
35171: LD_INT 84
35173: ST_TO_ADDR
// tech_Crane := 85 ;
35174: LD_ADDR_EXP 108
35178: PUSH
35179: LD_INT 85
35181: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35182: LD_ADDR_EXP 109
35186: PUSH
35187: LD_INT 86
35189: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35190: LD_ADDR_EXP 110
35194: PUSH
35195: LD_INT 87
35197: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35198: LD_ADDR_EXP 111
35202: PUSH
35203: LD_INT 88
35205: ST_TO_ADDR
// class_mastodont := 31 ;
35206: LD_ADDR_EXP 112
35210: PUSH
35211: LD_INT 31
35213: ST_TO_ADDR
// class_horse := 21 ;
35214: LD_ADDR_EXP 113
35218: PUSH
35219: LD_INT 21
35221: ST_TO_ADDR
// end ;
35222: LD_VAR 0 1
35226: RET
// every 1 do
35227: GO 35229
35229: DISABLE
// InitGlobalVariables ; end_of_file
35230: CALL 35067 0 0
35234: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35235: LD_INT 0
35237: PPUSH
35238: PPUSH
// skirmish := false ;
35239: LD_ADDR_EXP 114
35243: PUSH
35244: LD_INT 0
35246: ST_TO_ADDR
// debug_mc := false ;
35247: LD_ADDR_EXP 115
35251: PUSH
35252: LD_INT 0
35254: ST_TO_ADDR
// mc_bases := [ ] ;
35255: LD_ADDR_EXP 116
35259: PUSH
35260: EMPTY
35261: ST_TO_ADDR
// mc_sides := [ ] ;
35262: LD_ADDR_EXP 142
35266: PUSH
35267: EMPTY
35268: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35269: LD_ADDR_EXP 117
35273: PUSH
35274: EMPTY
35275: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35276: LD_ADDR_EXP 118
35280: PUSH
35281: EMPTY
35282: ST_TO_ADDR
// mc_need_heal := [ ] ;
35283: LD_ADDR_EXP 119
35287: PUSH
35288: EMPTY
35289: ST_TO_ADDR
// mc_healers := [ ] ;
35290: LD_ADDR_EXP 120
35294: PUSH
35295: EMPTY
35296: ST_TO_ADDR
// mc_build_list := [ ] ;
35297: LD_ADDR_EXP 121
35301: PUSH
35302: EMPTY
35303: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35304: LD_ADDR_EXP 148
35308: PUSH
35309: EMPTY
35310: ST_TO_ADDR
// mc_builders := [ ] ;
35311: LD_ADDR_EXP 122
35315: PUSH
35316: EMPTY
35317: ST_TO_ADDR
// mc_construct_list := [ ] ;
35318: LD_ADDR_EXP 123
35322: PUSH
35323: EMPTY
35324: ST_TO_ADDR
// mc_turret_list := [ ] ;
35325: LD_ADDR_EXP 124
35329: PUSH
35330: EMPTY
35331: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35332: LD_ADDR_EXP 125
35336: PUSH
35337: EMPTY
35338: ST_TO_ADDR
// mc_miners := [ ] ;
35339: LD_ADDR_EXP 130
35343: PUSH
35344: EMPTY
35345: ST_TO_ADDR
// mc_mines := [ ] ;
35346: LD_ADDR_EXP 129
35350: PUSH
35351: EMPTY
35352: ST_TO_ADDR
// mc_minefields := [ ] ;
35353: LD_ADDR_EXP 131
35357: PUSH
35358: EMPTY
35359: ST_TO_ADDR
// mc_crates := [ ] ;
35360: LD_ADDR_EXP 132
35364: PUSH
35365: EMPTY
35366: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35367: LD_ADDR_EXP 133
35371: PUSH
35372: EMPTY
35373: ST_TO_ADDR
// mc_crates_area := [ ] ;
35374: LD_ADDR_EXP 134
35378: PUSH
35379: EMPTY
35380: ST_TO_ADDR
// mc_vehicles := [ ] ;
35381: LD_ADDR_EXP 135
35385: PUSH
35386: EMPTY
35387: ST_TO_ADDR
// mc_attack := [ ] ;
35388: LD_ADDR_EXP 136
35392: PUSH
35393: EMPTY
35394: ST_TO_ADDR
// mc_produce := [ ] ;
35395: LD_ADDR_EXP 137
35399: PUSH
35400: EMPTY
35401: ST_TO_ADDR
// mc_defender := [ ] ;
35402: LD_ADDR_EXP 138
35406: PUSH
35407: EMPTY
35408: ST_TO_ADDR
// mc_parking := [ ] ;
35409: LD_ADDR_EXP 140
35413: PUSH
35414: EMPTY
35415: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35416: LD_ADDR_EXP 126
35420: PUSH
35421: EMPTY
35422: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35423: LD_ADDR_EXP 128
35427: PUSH
35428: EMPTY
35429: ST_TO_ADDR
// mc_scan := [ ] ;
35430: LD_ADDR_EXP 139
35434: PUSH
35435: EMPTY
35436: ST_TO_ADDR
// mc_scan_area := [ ] ;
35437: LD_ADDR_EXP 141
35441: PUSH
35442: EMPTY
35443: ST_TO_ADDR
// mc_tech := [ ] ;
35444: LD_ADDR_EXP 143
35448: PUSH
35449: EMPTY
35450: ST_TO_ADDR
// mc_class := [ ] ;
35451: LD_ADDR_EXP 157
35455: PUSH
35456: EMPTY
35457: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35458: LD_ADDR_EXP 158
35462: PUSH
35463: EMPTY
35464: ST_TO_ADDR
// mc_is_defending := [ ] ;
35465: LD_ADDR_EXP 159
35469: PUSH
35470: EMPTY
35471: ST_TO_ADDR
// end ;
35472: LD_VAR 0 1
35476: RET
// export function MC_Kill ( base ) ; begin
35477: LD_INT 0
35479: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35480: LD_ADDR_EXP 116
35484: PUSH
35485: LD_EXP 116
35489: PPUSH
35490: LD_VAR 0 1
35494: PPUSH
35495: EMPTY
35496: PPUSH
35497: CALL_OW 1
35501: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35502: LD_ADDR_EXP 117
35506: PUSH
35507: LD_EXP 117
35511: PPUSH
35512: LD_VAR 0 1
35516: PPUSH
35517: EMPTY
35518: PPUSH
35519: CALL_OW 1
35523: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35524: LD_ADDR_EXP 118
35528: PUSH
35529: LD_EXP 118
35533: PPUSH
35534: LD_VAR 0 1
35538: PPUSH
35539: EMPTY
35540: PPUSH
35541: CALL_OW 1
35545: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35546: LD_ADDR_EXP 119
35550: PUSH
35551: LD_EXP 119
35555: PPUSH
35556: LD_VAR 0 1
35560: PPUSH
35561: EMPTY
35562: PPUSH
35563: CALL_OW 1
35567: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35568: LD_ADDR_EXP 120
35572: PUSH
35573: LD_EXP 120
35577: PPUSH
35578: LD_VAR 0 1
35582: PPUSH
35583: EMPTY
35584: PPUSH
35585: CALL_OW 1
35589: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35590: LD_ADDR_EXP 121
35594: PUSH
35595: LD_EXP 121
35599: PPUSH
35600: LD_VAR 0 1
35604: PPUSH
35605: EMPTY
35606: PPUSH
35607: CALL_OW 1
35611: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35612: LD_ADDR_EXP 122
35616: PUSH
35617: LD_EXP 122
35621: PPUSH
35622: LD_VAR 0 1
35626: PPUSH
35627: EMPTY
35628: PPUSH
35629: CALL_OW 1
35633: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35634: LD_ADDR_EXP 123
35638: PUSH
35639: LD_EXP 123
35643: PPUSH
35644: LD_VAR 0 1
35648: PPUSH
35649: EMPTY
35650: PPUSH
35651: CALL_OW 1
35655: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35656: LD_ADDR_EXP 124
35660: PUSH
35661: LD_EXP 124
35665: PPUSH
35666: LD_VAR 0 1
35670: PPUSH
35671: EMPTY
35672: PPUSH
35673: CALL_OW 1
35677: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35678: LD_ADDR_EXP 125
35682: PUSH
35683: LD_EXP 125
35687: PPUSH
35688: LD_VAR 0 1
35692: PPUSH
35693: EMPTY
35694: PPUSH
35695: CALL_OW 1
35699: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35700: LD_ADDR_EXP 126
35704: PUSH
35705: LD_EXP 126
35709: PPUSH
35710: LD_VAR 0 1
35714: PPUSH
35715: EMPTY
35716: PPUSH
35717: CALL_OW 1
35721: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35722: LD_ADDR_EXP 127
35726: PUSH
35727: LD_EXP 127
35731: PPUSH
35732: LD_VAR 0 1
35736: PPUSH
35737: LD_INT 0
35739: PPUSH
35740: CALL_OW 1
35744: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35745: LD_ADDR_EXP 128
35749: PUSH
35750: LD_EXP 128
35754: PPUSH
35755: LD_VAR 0 1
35759: PPUSH
35760: EMPTY
35761: PPUSH
35762: CALL_OW 1
35766: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35767: LD_ADDR_EXP 129
35771: PUSH
35772: LD_EXP 129
35776: PPUSH
35777: LD_VAR 0 1
35781: PPUSH
35782: EMPTY
35783: PPUSH
35784: CALL_OW 1
35788: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35789: LD_ADDR_EXP 130
35793: PUSH
35794: LD_EXP 130
35798: PPUSH
35799: LD_VAR 0 1
35803: PPUSH
35804: EMPTY
35805: PPUSH
35806: CALL_OW 1
35810: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35811: LD_ADDR_EXP 131
35815: PUSH
35816: LD_EXP 131
35820: PPUSH
35821: LD_VAR 0 1
35825: PPUSH
35826: EMPTY
35827: PPUSH
35828: CALL_OW 1
35832: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35833: LD_ADDR_EXP 132
35837: PUSH
35838: LD_EXP 132
35842: PPUSH
35843: LD_VAR 0 1
35847: PPUSH
35848: EMPTY
35849: PPUSH
35850: CALL_OW 1
35854: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35855: LD_ADDR_EXP 133
35859: PUSH
35860: LD_EXP 133
35864: PPUSH
35865: LD_VAR 0 1
35869: PPUSH
35870: EMPTY
35871: PPUSH
35872: CALL_OW 1
35876: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35877: LD_ADDR_EXP 134
35881: PUSH
35882: LD_EXP 134
35886: PPUSH
35887: LD_VAR 0 1
35891: PPUSH
35892: EMPTY
35893: PPUSH
35894: CALL_OW 1
35898: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35899: LD_ADDR_EXP 135
35903: PUSH
35904: LD_EXP 135
35908: PPUSH
35909: LD_VAR 0 1
35913: PPUSH
35914: EMPTY
35915: PPUSH
35916: CALL_OW 1
35920: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35921: LD_ADDR_EXP 136
35925: PUSH
35926: LD_EXP 136
35930: PPUSH
35931: LD_VAR 0 1
35935: PPUSH
35936: EMPTY
35937: PPUSH
35938: CALL_OW 1
35942: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35943: LD_ADDR_EXP 137
35947: PUSH
35948: LD_EXP 137
35952: PPUSH
35953: LD_VAR 0 1
35957: PPUSH
35958: EMPTY
35959: PPUSH
35960: CALL_OW 1
35964: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35965: LD_ADDR_EXP 138
35969: PUSH
35970: LD_EXP 138
35974: PPUSH
35975: LD_VAR 0 1
35979: PPUSH
35980: EMPTY
35981: PPUSH
35982: CALL_OW 1
35986: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35987: LD_ADDR_EXP 139
35991: PUSH
35992: LD_EXP 139
35996: PPUSH
35997: LD_VAR 0 1
36001: PPUSH
36002: EMPTY
36003: PPUSH
36004: CALL_OW 1
36008: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36009: LD_ADDR_EXP 140
36013: PUSH
36014: LD_EXP 140
36018: PPUSH
36019: LD_VAR 0 1
36023: PPUSH
36024: EMPTY
36025: PPUSH
36026: CALL_OW 1
36030: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36031: LD_ADDR_EXP 141
36035: PUSH
36036: LD_EXP 141
36040: PPUSH
36041: LD_VAR 0 1
36045: PPUSH
36046: EMPTY
36047: PPUSH
36048: CALL_OW 1
36052: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36053: LD_ADDR_EXP 143
36057: PUSH
36058: LD_EXP 143
36062: PPUSH
36063: LD_VAR 0 1
36067: PPUSH
36068: EMPTY
36069: PPUSH
36070: CALL_OW 1
36074: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36075: LD_ADDR_EXP 145
36079: PUSH
36080: LD_EXP 145
36084: PPUSH
36085: LD_VAR 0 1
36089: PPUSH
36090: EMPTY
36091: PPUSH
36092: CALL_OW 1
36096: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36097: LD_ADDR_EXP 146
36101: PUSH
36102: LD_EXP 146
36106: PPUSH
36107: LD_VAR 0 1
36111: PPUSH
36112: EMPTY
36113: PPUSH
36114: CALL_OW 1
36118: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36119: LD_ADDR_EXP 147
36123: PUSH
36124: LD_EXP 147
36128: PPUSH
36129: LD_VAR 0 1
36133: PPUSH
36134: EMPTY
36135: PPUSH
36136: CALL_OW 1
36140: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36141: LD_ADDR_EXP 148
36145: PUSH
36146: LD_EXP 148
36150: PPUSH
36151: LD_VAR 0 1
36155: PPUSH
36156: EMPTY
36157: PPUSH
36158: CALL_OW 1
36162: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36163: LD_ADDR_EXP 149
36167: PUSH
36168: LD_EXP 149
36172: PPUSH
36173: LD_VAR 0 1
36177: PPUSH
36178: EMPTY
36179: PPUSH
36180: CALL_OW 1
36184: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36185: LD_ADDR_EXP 150
36189: PUSH
36190: LD_EXP 150
36194: PPUSH
36195: LD_VAR 0 1
36199: PPUSH
36200: EMPTY
36201: PPUSH
36202: CALL_OW 1
36206: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36207: LD_ADDR_EXP 151
36211: PUSH
36212: LD_EXP 151
36216: PPUSH
36217: LD_VAR 0 1
36221: PPUSH
36222: EMPTY
36223: PPUSH
36224: CALL_OW 1
36228: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36229: LD_ADDR_EXP 152
36233: PUSH
36234: LD_EXP 152
36238: PPUSH
36239: LD_VAR 0 1
36243: PPUSH
36244: EMPTY
36245: PPUSH
36246: CALL_OW 1
36250: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36251: LD_ADDR_EXP 153
36255: PUSH
36256: LD_EXP 153
36260: PPUSH
36261: LD_VAR 0 1
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL_OW 1
36272: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36273: LD_ADDR_EXP 154
36277: PUSH
36278: LD_EXP 154
36282: PPUSH
36283: LD_VAR 0 1
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL_OW 1
36294: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36295: LD_ADDR_EXP 155
36299: PUSH
36300: LD_EXP 155
36304: PPUSH
36305: LD_VAR 0 1
36309: PPUSH
36310: EMPTY
36311: PPUSH
36312: CALL_OW 1
36316: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36317: LD_ADDR_EXP 156
36321: PUSH
36322: LD_EXP 156
36326: PPUSH
36327: LD_VAR 0 1
36331: PPUSH
36332: EMPTY
36333: PPUSH
36334: CALL_OW 1
36338: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36339: LD_ADDR_EXP 157
36343: PUSH
36344: LD_EXP 157
36348: PPUSH
36349: LD_VAR 0 1
36353: PPUSH
36354: EMPTY
36355: PPUSH
36356: CALL_OW 1
36360: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36361: LD_ADDR_EXP 158
36365: PUSH
36366: LD_EXP 158
36370: PPUSH
36371: LD_VAR 0 1
36375: PPUSH
36376: LD_INT 0
36378: PPUSH
36379: CALL_OW 1
36383: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36384: LD_ADDR_EXP 159
36388: PUSH
36389: LD_EXP 159
36393: PPUSH
36394: LD_VAR 0 1
36398: PPUSH
36399: LD_INT 0
36401: PPUSH
36402: CALL_OW 1
36406: ST_TO_ADDR
// end ;
36407: LD_VAR 0 2
36411: RET
// export function MC_Add ( side , units ) ; var base ; begin
36412: LD_INT 0
36414: PPUSH
36415: PPUSH
// base := mc_bases + 1 ;
36416: LD_ADDR_VAR 0 4
36420: PUSH
36421: LD_EXP 116
36425: PUSH
36426: LD_INT 1
36428: PLUS
36429: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36430: LD_ADDR_EXP 142
36434: PUSH
36435: LD_EXP 142
36439: PPUSH
36440: LD_VAR 0 4
36444: PPUSH
36445: LD_VAR 0 1
36449: PPUSH
36450: CALL_OW 1
36454: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36455: LD_ADDR_EXP 116
36459: PUSH
36460: LD_EXP 116
36464: PPUSH
36465: LD_VAR 0 4
36469: PPUSH
36470: LD_VAR 0 2
36474: PPUSH
36475: CALL_OW 1
36479: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36480: LD_ADDR_EXP 117
36484: PUSH
36485: LD_EXP 117
36489: PPUSH
36490: LD_VAR 0 4
36494: PPUSH
36495: EMPTY
36496: PPUSH
36497: CALL_OW 1
36501: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36502: LD_ADDR_EXP 118
36506: PUSH
36507: LD_EXP 118
36511: PPUSH
36512: LD_VAR 0 4
36516: PPUSH
36517: EMPTY
36518: PPUSH
36519: CALL_OW 1
36523: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36524: LD_ADDR_EXP 119
36528: PUSH
36529: LD_EXP 119
36533: PPUSH
36534: LD_VAR 0 4
36538: PPUSH
36539: EMPTY
36540: PPUSH
36541: CALL_OW 1
36545: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36546: LD_ADDR_EXP 120
36550: PUSH
36551: LD_EXP 120
36555: PPUSH
36556: LD_VAR 0 4
36560: PPUSH
36561: EMPTY
36562: PPUSH
36563: CALL_OW 1
36567: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36568: LD_ADDR_EXP 121
36572: PUSH
36573: LD_EXP 121
36577: PPUSH
36578: LD_VAR 0 4
36582: PPUSH
36583: EMPTY
36584: PPUSH
36585: CALL_OW 1
36589: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36590: LD_ADDR_EXP 122
36594: PUSH
36595: LD_EXP 122
36599: PPUSH
36600: LD_VAR 0 4
36604: PPUSH
36605: EMPTY
36606: PPUSH
36607: CALL_OW 1
36611: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36612: LD_ADDR_EXP 123
36616: PUSH
36617: LD_EXP 123
36621: PPUSH
36622: LD_VAR 0 4
36626: PPUSH
36627: EMPTY
36628: PPUSH
36629: CALL_OW 1
36633: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36634: LD_ADDR_EXP 124
36638: PUSH
36639: LD_EXP 124
36643: PPUSH
36644: LD_VAR 0 4
36648: PPUSH
36649: EMPTY
36650: PPUSH
36651: CALL_OW 1
36655: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36656: LD_ADDR_EXP 125
36660: PUSH
36661: LD_EXP 125
36665: PPUSH
36666: LD_VAR 0 4
36670: PPUSH
36671: EMPTY
36672: PPUSH
36673: CALL_OW 1
36677: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36678: LD_ADDR_EXP 126
36682: PUSH
36683: LD_EXP 126
36687: PPUSH
36688: LD_VAR 0 4
36692: PPUSH
36693: EMPTY
36694: PPUSH
36695: CALL_OW 1
36699: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36700: LD_ADDR_EXP 127
36704: PUSH
36705: LD_EXP 127
36709: PPUSH
36710: LD_VAR 0 4
36714: PPUSH
36715: LD_INT 0
36717: PPUSH
36718: CALL_OW 1
36722: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36723: LD_ADDR_EXP 128
36727: PUSH
36728: LD_EXP 128
36732: PPUSH
36733: LD_VAR 0 4
36737: PPUSH
36738: EMPTY
36739: PPUSH
36740: CALL_OW 1
36744: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36745: LD_ADDR_EXP 129
36749: PUSH
36750: LD_EXP 129
36754: PPUSH
36755: LD_VAR 0 4
36759: PPUSH
36760: EMPTY
36761: PPUSH
36762: CALL_OW 1
36766: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36767: LD_ADDR_EXP 130
36771: PUSH
36772: LD_EXP 130
36776: PPUSH
36777: LD_VAR 0 4
36781: PPUSH
36782: EMPTY
36783: PPUSH
36784: CALL_OW 1
36788: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36789: LD_ADDR_EXP 131
36793: PUSH
36794: LD_EXP 131
36798: PPUSH
36799: LD_VAR 0 4
36803: PPUSH
36804: EMPTY
36805: PPUSH
36806: CALL_OW 1
36810: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36811: LD_ADDR_EXP 132
36815: PUSH
36816: LD_EXP 132
36820: PPUSH
36821: LD_VAR 0 4
36825: PPUSH
36826: EMPTY
36827: PPUSH
36828: CALL_OW 1
36832: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36833: LD_ADDR_EXP 133
36837: PUSH
36838: LD_EXP 133
36842: PPUSH
36843: LD_VAR 0 4
36847: PPUSH
36848: EMPTY
36849: PPUSH
36850: CALL_OW 1
36854: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36855: LD_ADDR_EXP 134
36859: PUSH
36860: LD_EXP 134
36864: PPUSH
36865: LD_VAR 0 4
36869: PPUSH
36870: EMPTY
36871: PPUSH
36872: CALL_OW 1
36876: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36877: LD_ADDR_EXP 135
36881: PUSH
36882: LD_EXP 135
36886: PPUSH
36887: LD_VAR 0 4
36891: PPUSH
36892: EMPTY
36893: PPUSH
36894: CALL_OW 1
36898: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36899: LD_ADDR_EXP 136
36903: PUSH
36904: LD_EXP 136
36908: PPUSH
36909: LD_VAR 0 4
36913: PPUSH
36914: EMPTY
36915: PPUSH
36916: CALL_OW 1
36920: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36921: LD_ADDR_EXP 137
36925: PUSH
36926: LD_EXP 137
36930: PPUSH
36931: LD_VAR 0 4
36935: PPUSH
36936: EMPTY
36937: PPUSH
36938: CALL_OW 1
36942: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36943: LD_ADDR_EXP 138
36947: PUSH
36948: LD_EXP 138
36952: PPUSH
36953: LD_VAR 0 4
36957: PPUSH
36958: EMPTY
36959: PPUSH
36960: CALL_OW 1
36964: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36965: LD_ADDR_EXP 139
36969: PUSH
36970: LD_EXP 139
36974: PPUSH
36975: LD_VAR 0 4
36979: PPUSH
36980: EMPTY
36981: PPUSH
36982: CALL_OW 1
36986: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36987: LD_ADDR_EXP 140
36991: PUSH
36992: LD_EXP 140
36996: PPUSH
36997: LD_VAR 0 4
37001: PPUSH
37002: EMPTY
37003: PPUSH
37004: CALL_OW 1
37008: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37009: LD_ADDR_EXP 141
37013: PUSH
37014: LD_EXP 141
37018: PPUSH
37019: LD_VAR 0 4
37023: PPUSH
37024: EMPTY
37025: PPUSH
37026: CALL_OW 1
37030: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37031: LD_ADDR_EXP 143
37035: PUSH
37036: LD_EXP 143
37040: PPUSH
37041: LD_VAR 0 4
37045: PPUSH
37046: EMPTY
37047: PPUSH
37048: CALL_OW 1
37052: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37053: LD_ADDR_EXP 145
37057: PUSH
37058: LD_EXP 145
37062: PPUSH
37063: LD_VAR 0 4
37067: PPUSH
37068: EMPTY
37069: PPUSH
37070: CALL_OW 1
37074: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37075: LD_ADDR_EXP 146
37079: PUSH
37080: LD_EXP 146
37084: PPUSH
37085: LD_VAR 0 4
37089: PPUSH
37090: EMPTY
37091: PPUSH
37092: CALL_OW 1
37096: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37097: LD_ADDR_EXP 147
37101: PUSH
37102: LD_EXP 147
37106: PPUSH
37107: LD_VAR 0 4
37111: PPUSH
37112: EMPTY
37113: PPUSH
37114: CALL_OW 1
37118: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37119: LD_ADDR_EXP 148
37123: PUSH
37124: LD_EXP 148
37128: PPUSH
37129: LD_VAR 0 4
37133: PPUSH
37134: EMPTY
37135: PPUSH
37136: CALL_OW 1
37140: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37141: LD_ADDR_EXP 149
37145: PUSH
37146: LD_EXP 149
37150: PPUSH
37151: LD_VAR 0 4
37155: PPUSH
37156: EMPTY
37157: PPUSH
37158: CALL_OW 1
37162: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37163: LD_ADDR_EXP 150
37167: PUSH
37168: LD_EXP 150
37172: PPUSH
37173: LD_VAR 0 4
37177: PPUSH
37178: EMPTY
37179: PPUSH
37180: CALL_OW 1
37184: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37185: LD_ADDR_EXP 151
37189: PUSH
37190: LD_EXP 151
37194: PPUSH
37195: LD_VAR 0 4
37199: PPUSH
37200: EMPTY
37201: PPUSH
37202: CALL_OW 1
37206: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37207: LD_ADDR_EXP 152
37211: PUSH
37212: LD_EXP 152
37216: PPUSH
37217: LD_VAR 0 4
37221: PPUSH
37222: EMPTY
37223: PPUSH
37224: CALL_OW 1
37228: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37229: LD_ADDR_EXP 153
37233: PUSH
37234: LD_EXP 153
37238: PPUSH
37239: LD_VAR 0 4
37243: PPUSH
37244: EMPTY
37245: PPUSH
37246: CALL_OW 1
37250: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37251: LD_ADDR_EXP 154
37255: PUSH
37256: LD_EXP 154
37260: PPUSH
37261: LD_VAR 0 4
37265: PPUSH
37266: EMPTY
37267: PPUSH
37268: CALL_OW 1
37272: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37273: LD_ADDR_EXP 155
37277: PUSH
37278: LD_EXP 155
37282: PPUSH
37283: LD_VAR 0 4
37287: PPUSH
37288: EMPTY
37289: PPUSH
37290: CALL_OW 1
37294: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37295: LD_ADDR_EXP 156
37299: PUSH
37300: LD_EXP 156
37304: PPUSH
37305: LD_VAR 0 4
37309: PPUSH
37310: EMPTY
37311: PPUSH
37312: CALL_OW 1
37316: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37317: LD_ADDR_EXP 157
37321: PUSH
37322: LD_EXP 157
37326: PPUSH
37327: LD_VAR 0 4
37331: PPUSH
37332: EMPTY
37333: PPUSH
37334: CALL_OW 1
37338: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37339: LD_ADDR_EXP 158
37343: PUSH
37344: LD_EXP 158
37348: PPUSH
37349: LD_VAR 0 4
37353: PPUSH
37354: LD_INT 0
37356: PPUSH
37357: CALL_OW 1
37361: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37362: LD_ADDR_EXP 159
37366: PUSH
37367: LD_EXP 159
37371: PPUSH
37372: LD_VAR 0 4
37376: PPUSH
37377: LD_INT 0
37379: PPUSH
37380: CALL_OW 1
37384: ST_TO_ADDR
// result := base ;
37385: LD_ADDR_VAR 0 3
37389: PUSH
37390: LD_VAR 0 4
37394: ST_TO_ADDR
// end ;
37395: LD_VAR 0 3
37399: RET
// export function MC_Start ( ) ; var i ; begin
37400: LD_INT 0
37402: PPUSH
37403: PPUSH
// for i = 1 to mc_bases do
37404: LD_ADDR_VAR 0 2
37408: PUSH
37409: DOUBLE
37410: LD_INT 1
37412: DEC
37413: ST_TO_ADDR
37414: LD_EXP 116
37418: PUSH
37419: FOR_TO
37420: IFFALSE 38520
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37422: LD_ADDR_EXP 116
37426: PUSH
37427: LD_EXP 116
37431: PPUSH
37432: LD_VAR 0 2
37436: PPUSH
37437: LD_EXP 116
37441: PUSH
37442: LD_VAR 0 2
37446: ARRAY
37447: PUSH
37448: LD_INT 0
37450: DIFF
37451: PPUSH
37452: CALL_OW 1
37456: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37457: LD_ADDR_EXP 117
37461: PUSH
37462: LD_EXP 117
37466: PPUSH
37467: LD_VAR 0 2
37471: PPUSH
37472: EMPTY
37473: PPUSH
37474: CALL_OW 1
37478: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37479: LD_ADDR_EXP 118
37483: PUSH
37484: LD_EXP 118
37488: PPUSH
37489: LD_VAR 0 2
37493: PPUSH
37494: EMPTY
37495: PPUSH
37496: CALL_OW 1
37500: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37501: LD_ADDR_EXP 119
37505: PUSH
37506: LD_EXP 119
37510: PPUSH
37511: LD_VAR 0 2
37515: PPUSH
37516: EMPTY
37517: PPUSH
37518: CALL_OW 1
37522: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37523: LD_ADDR_EXP 120
37527: PUSH
37528: LD_EXP 120
37532: PPUSH
37533: LD_VAR 0 2
37537: PPUSH
37538: EMPTY
37539: PUSH
37540: EMPTY
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PPUSH
37546: CALL_OW 1
37550: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37551: LD_ADDR_EXP 121
37555: PUSH
37556: LD_EXP 121
37560: PPUSH
37561: LD_VAR 0 2
37565: PPUSH
37566: EMPTY
37567: PPUSH
37568: CALL_OW 1
37572: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37573: LD_ADDR_EXP 148
37577: PUSH
37578: LD_EXP 148
37582: PPUSH
37583: LD_VAR 0 2
37587: PPUSH
37588: EMPTY
37589: PPUSH
37590: CALL_OW 1
37594: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37595: LD_ADDR_EXP 122
37599: PUSH
37600: LD_EXP 122
37604: PPUSH
37605: LD_VAR 0 2
37609: PPUSH
37610: EMPTY
37611: PPUSH
37612: CALL_OW 1
37616: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37617: LD_ADDR_EXP 123
37621: PUSH
37622: LD_EXP 123
37626: PPUSH
37627: LD_VAR 0 2
37631: PPUSH
37632: EMPTY
37633: PPUSH
37634: CALL_OW 1
37638: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37639: LD_ADDR_EXP 124
37643: PUSH
37644: LD_EXP 124
37648: PPUSH
37649: LD_VAR 0 2
37653: PPUSH
37654: LD_EXP 116
37658: PUSH
37659: LD_VAR 0 2
37663: ARRAY
37664: PPUSH
37665: LD_INT 2
37667: PUSH
37668: LD_INT 30
37670: PUSH
37671: LD_INT 32
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 30
37680: PUSH
37681: LD_INT 33
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: LIST
37692: PPUSH
37693: CALL_OW 72
37697: PPUSH
37698: CALL_OW 1
37702: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37703: LD_ADDR_EXP 125
37707: PUSH
37708: LD_EXP 125
37712: PPUSH
37713: LD_VAR 0 2
37717: PPUSH
37718: LD_EXP 116
37722: PUSH
37723: LD_VAR 0 2
37727: ARRAY
37728: PPUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 30
37734: PUSH
37735: LD_INT 32
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 31
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 58
37759: PUSH
37760: EMPTY
37761: LIST
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PPUSH
37767: CALL_OW 72
37771: PPUSH
37772: CALL_OW 1
37776: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37777: LD_ADDR_EXP 126
37781: PUSH
37782: LD_EXP 126
37786: PPUSH
37787: LD_VAR 0 2
37791: PPUSH
37792: EMPTY
37793: PPUSH
37794: CALL_OW 1
37798: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37799: LD_ADDR_EXP 130
37803: PUSH
37804: LD_EXP 130
37808: PPUSH
37809: LD_VAR 0 2
37813: PPUSH
37814: EMPTY
37815: PPUSH
37816: CALL_OW 1
37820: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37821: LD_ADDR_EXP 129
37825: PUSH
37826: LD_EXP 129
37830: PPUSH
37831: LD_VAR 0 2
37835: PPUSH
37836: EMPTY
37837: PPUSH
37838: CALL_OW 1
37842: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37843: LD_ADDR_EXP 131
37847: PUSH
37848: LD_EXP 131
37852: PPUSH
37853: LD_VAR 0 2
37857: PPUSH
37858: EMPTY
37859: PPUSH
37860: CALL_OW 1
37864: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37865: LD_ADDR_EXP 132
37869: PUSH
37870: LD_EXP 132
37874: PPUSH
37875: LD_VAR 0 2
37879: PPUSH
37880: EMPTY
37881: PPUSH
37882: CALL_OW 1
37886: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37887: LD_ADDR_EXP 133
37891: PUSH
37892: LD_EXP 133
37896: PPUSH
37897: LD_VAR 0 2
37901: PPUSH
37902: EMPTY
37903: PPUSH
37904: CALL_OW 1
37908: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37909: LD_ADDR_EXP 134
37913: PUSH
37914: LD_EXP 134
37918: PPUSH
37919: LD_VAR 0 2
37923: PPUSH
37924: EMPTY
37925: PPUSH
37926: CALL_OW 1
37930: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37931: LD_ADDR_EXP 135
37935: PUSH
37936: LD_EXP 135
37940: PPUSH
37941: LD_VAR 0 2
37945: PPUSH
37946: EMPTY
37947: PPUSH
37948: CALL_OW 1
37952: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37953: LD_ADDR_EXP 136
37957: PUSH
37958: LD_EXP 136
37962: PPUSH
37963: LD_VAR 0 2
37967: PPUSH
37968: EMPTY
37969: PPUSH
37970: CALL_OW 1
37974: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37975: LD_ADDR_EXP 137
37979: PUSH
37980: LD_EXP 137
37984: PPUSH
37985: LD_VAR 0 2
37989: PPUSH
37990: EMPTY
37991: PPUSH
37992: CALL_OW 1
37996: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37997: LD_ADDR_EXP 138
38001: PUSH
38002: LD_EXP 138
38006: PPUSH
38007: LD_VAR 0 2
38011: PPUSH
38012: EMPTY
38013: PPUSH
38014: CALL_OW 1
38018: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38019: LD_ADDR_EXP 127
38023: PUSH
38024: LD_EXP 127
38028: PPUSH
38029: LD_VAR 0 2
38033: PPUSH
38034: LD_INT 0
38036: PPUSH
38037: CALL_OW 1
38041: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38042: LD_ADDR_EXP 140
38046: PUSH
38047: LD_EXP 140
38051: PPUSH
38052: LD_VAR 0 2
38056: PPUSH
38057: LD_INT 0
38059: PPUSH
38060: CALL_OW 1
38064: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38065: LD_ADDR_EXP 128
38069: PUSH
38070: LD_EXP 128
38074: PPUSH
38075: LD_VAR 0 2
38079: PPUSH
38080: EMPTY
38081: PPUSH
38082: CALL_OW 1
38086: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38087: LD_ADDR_EXP 139
38091: PUSH
38092: LD_EXP 139
38096: PPUSH
38097: LD_VAR 0 2
38101: PPUSH
38102: LD_INT 0
38104: PPUSH
38105: CALL_OW 1
38109: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38110: LD_ADDR_EXP 141
38114: PUSH
38115: LD_EXP 141
38119: PPUSH
38120: LD_VAR 0 2
38124: PPUSH
38125: EMPTY
38126: PPUSH
38127: CALL_OW 1
38131: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38132: LD_ADDR_EXP 144
38136: PUSH
38137: LD_EXP 144
38141: PPUSH
38142: LD_VAR 0 2
38146: PPUSH
38147: LD_INT 0
38149: PPUSH
38150: CALL_OW 1
38154: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38155: LD_ADDR_EXP 145
38159: PUSH
38160: LD_EXP 145
38164: PPUSH
38165: LD_VAR 0 2
38169: PPUSH
38170: EMPTY
38171: PPUSH
38172: CALL_OW 1
38176: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38177: LD_ADDR_EXP 146
38181: PUSH
38182: LD_EXP 146
38186: PPUSH
38187: LD_VAR 0 2
38191: PPUSH
38192: EMPTY
38193: PPUSH
38194: CALL_OW 1
38198: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38199: LD_ADDR_EXP 147
38203: PUSH
38204: LD_EXP 147
38208: PPUSH
38209: LD_VAR 0 2
38213: PPUSH
38214: EMPTY
38215: PPUSH
38216: CALL_OW 1
38220: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38221: LD_ADDR_EXP 149
38225: PUSH
38226: LD_EXP 149
38230: PPUSH
38231: LD_VAR 0 2
38235: PPUSH
38236: LD_EXP 116
38240: PUSH
38241: LD_VAR 0 2
38245: ARRAY
38246: PPUSH
38247: LD_INT 2
38249: PUSH
38250: LD_INT 30
38252: PUSH
38253: LD_INT 6
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: LD_INT 30
38262: PUSH
38263: LD_INT 7
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 30
38272: PUSH
38273: LD_INT 8
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: PPUSH
38286: CALL_OW 72
38290: PPUSH
38291: CALL_OW 1
38295: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38296: LD_ADDR_EXP 150
38300: PUSH
38301: LD_EXP 150
38305: PPUSH
38306: LD_VAR 0 2
38310: PPUSH
38311: EMPTY
38312: PPUSH
38313: CALL_OW 1
38317: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38318: LD_ADDR_EXP 151
38322: PUSH
38323: LD_EXP 151
38327: PPUSH
38328: LD_VAR 0 2
38332: PPUSH
38333: EMPTY
38334: PPUSH
38335: CALL_OW 1
38339: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38340: LD_ADDR_EXP 152
38344: PUSH
38345: LD_EXP 152
38349: PPUSH
38350: LD_VAR 0 2
38354: PPUSH
38355: EMPTY
38356: PPUSH
38357: CALL_OW 1
38361: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38362: LD_ADDR_EXP 153
38366: PUSH
38367: LD_EXP 153
38371: PPUSH
38372: LD_VAR 0 2
38376: PPUSH
38377: EMPTY
38378: PPUSH
38379: CALL_OW 1
38383: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38384: LD_ADDR_EXP 154
38388: PUSH
38389: LD_EXP 154
38393: PPUSH
38394: LD_VAR 0 2
38398: PPUSH
38399: EMPTY
38400: PPUSH
38401: CALL_OW 1
38405: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38406: LD_ADDR_EXP 155
38410: PUSH
38411: LD_EXP 155
38415: PPUSH
38416: LD_VAR 0 2
38420: PPUSH
38421: EMPTY
38422: PPUSH
38423: CALL_OW 1
38427: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38428: LD_ADDR_EXP 156
38432: PUSH
38433: LD_EXP 156
38437: PPUSH
38438: LD_VAR 0 2
38442: PPUSH
38443: EMPTY
38444: PPUSH
38445: CALL_OW 1
38449: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38450: LD_ADDR_EXP 157
38454: PUSH
38455: LD_EXP 157
38459: PPUSH
38460: LD_VAR 0 2
38464: PPUSH
38465: EMPTY
38466: PPUSH
38467: CALL_OW 1
38471: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38472: LD_ADDR_EXP 158
38476: PUSH
38477: LD_EXP 158
38481: PPUSH
38482: LD_VAR 0 2
38486: PPUSH
38487: LD_INT 0
38489: PPUSH
38490: CALL_OW 1
38494: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38495: LD_ADDR_EXP 159
38499: PUSH
38500: LD_EXP 159
38504: PPUSH
38505: LD_VAR 0 2
38509: PPUSH
38510: LD_INT 0
38512: PPUSH
38513: CALL_OW 1
38517: ST_TO_ADDR
// end ;
38518: GO 37419
38520: POP
38521: POP
// MC_InitSides ( ) ;
38522: CALL 38808 0 0
// MC_InitResearch ( ) ;
38526: CALL 38547 0 0
// CustomInitMacro ( ) ;
38530: CALL 471 0 0
// skirmish := true ;
38534: LD_ADDR_EXP 114
38538: PUSH
38539: LD_INT 1
38541: ST_TO_ADDR
// end ;
38542: LD_VAR 0 1
38546: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38547: LD_INT 0
38549: PPUSH
38550: PPUSH
38551: PPUSH
38552: PPUSH
38553: PPUSH
38554: PPUSH
// if not mc_bases then
38555: LD_EXP 116
38559: NOT
38560: IFFALSE 38564
// exit ;
38562: GO 38803
// for i = 1 to 8 do
38564: LD_ADDR_VAR 0 2
38568: PUSH
38569: DOUBLE
38570: LD_INT 1
38572: DEC
38573: ST_TO_ADDR
38574: LD_INT 8
38576: PUSH
38577: FOR_TO
38578: IFFALSE 38604
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38580: LD_ADDR_EXP 143
38584: PUSH
38585: LD_EXP 143
38589: PPUSH
38590: LD_VAR 0 2
38594: PPUSH
38595: EMPTY
38596: PPUSH
38597: CALL_OW 1
38601: ST_TO_ADDR
38602: GO 38577
38604: POP
38605: POP
// tmp := [ ] ;
38606: LD_ADDR_VAR 0 5
38610: PUSH
38611: EMPTY
38612: ST_TO_ADDR
// for i = 1 to mc_sides do
38613: LD_ADDR_VAR 0 2
38617: PUSH
38618: DOUBLE
38619: LD_INT 1
38621: DEC
38622: ST_TO_ADDR
38623: LD_EXP 142
38627: PUSH
38628: FOR_TO
38629: IFFALSE 38687
// if not mc_sides [ i ] in tmp then
38631: LD_EXP 142
38635: PUSH
38636: LD_VAR 0 2
38640: ARRAY
38641: PUSH
38642: LD_VAR 0 5
38646: IN
38647: NOT
38648: IFFALSE 38685
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38650: LD_ADDR_VAR 0 5
38654: PUSH
38655: LD_VAR 0 5
38659: PPUSH
38660: LD_VAR 0 5
38664: PUSH
38665: LD_INT 1
38667: PLUS
38668: PPUSH
38669: LD_EXP 142
38673: PUSH
38674: LD_VAR 0 2
38678: ARRAY
38679: PPUSH
38680: CALL_OW 2
38684: ST_TO_ADDR
38685: GO 38628
38687: POP
38688: POP
// if not tmp then
38689: LD_VAR 0 5
38693: NOT
38694: IFFALSE 38698
// exit ;
38696: GO 38803
// for j in tmp do
38698: LD_ADDR_VAR 0 3
38702: PUSH
38703: LD_VAR 0 5
38707: PUSH
38708: FOR_IN
38709: IFFALSE 38801
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38711: LD_ADDR_VAR 0 6
38715: PUSH
38716: LD_INT 22
38718: PUSH
38719: LD_VAR 0 3
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PPUSH
38728: CALL_OW 69
38732: ST_TO_ADDR
// if not un then
38733: LD_VAR 0 6
38737: NOT
38738: IFFALSE 38742
// continue ;
38740: GO 38708
// nation := GetNation ( un [ 1 ] ) ;
38742: LD_ADDR_VAR 0 4
38746: PUSH
38747: LD_VAR 0 6
38751: PUSH
38752: LD_INT 1
38754: ARRAY
38755: PPUSH
38756: CALL_OW 248
38760: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38761: LD_ADDR_EXP 143
38765: PUSH
38766: LD_EXP 143
38770: PPUSH
38771: LD_VAR 0 3
38775: PPUSH
38776: LD_VAR 0 3
38780: PPUSH
38781: LD_VAR 0 4
38785: PPUSH
38786: LD_INT 1
38788: PPUSH
38789: CALL 65777 0 3
38793: PPUSH
38794: CALL_OW 1
38798: ST_TO_ADDR
// end ;
38799: GO 38708
38801: POP
38802: POP
// end ;
38803: LD_VAR 0 1
38807: RET
// export function MC_InitSides ( ) ; var i ; begin
38808: LD_INT 0
38810: PPUSH
38811: PPUSH
// if not mc_bases then
38812: LD_EXP 116
38816: NOT
38817: IFFALSE 38821
// exit ;
38819: GO 38895
// for i = 1 to mc_bases do
38821: LD_ADDR_VAR 0 2
38825: PUSH
38826: DOUBLE
38827: LD_INT 1
38829: DEC
38830: ST_TO_ADDR
38831: LD_EXP 116
38835: PUSH
38836: FOR_TO
38837: IFFALSE 38893
// if mc_bases [ i ] then
38839: LD_EXP 116
38843: PUSH
38844: LD_VAR 0 2
38848: ARRAY
38849: IFFALSE 38891
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38851: LD_ADDR_EXP 142
38855: PUSH
38856: LD_EXP 142
38860: PPUSH
38861: LD_VAR 0 2
38865: PPUSH
38866: LD_EXP 116
38870: PUSH
38871: LD_VAR 0 2
38875: ARRAY
38876: PUSH
38877: LD_INT 1
38879: ARRAY
38880: PPUSH
38881: CALL_OW 255
38885: PPUSH
38886: CALL_OW 1
38890: ST_TO_ADDR
38891: GO 38836
38893: POP
38894: POP
// end ;
38895: LD_VAR 0 1
38899: RET
// every 0 0$03 trigger skirmish do
38900: LD_EXP 114
38904: IFFALSE 39058
38906: GO 38908
38908: DISABLE
// begin enable ;
38909: ENABLE
// MC_CheckBuildings ( ) ;
38910: CALL 43556 0 0
// MC_CheckPeopleLife ( ) ;
38914: CALL 43717 0 0
// RaiseSailEvent ( 100 ) ;
38918: LD_INT 100
38920: PPUSH
38921: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38925: LD_INT 103
38927: PPUSH
38928: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38932: LD_INT 104
38934: PPUSH
38935: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38939: LD_INT 105
38941: PPUSH
38942: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38946: LD_INT 106
38948: PPUSH
38949: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38953: LD_INT 107
38955: PPUSH
38956: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38960: LD_INT 108
38962: PPUSH
38963: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38967: LD_INT 109
38969: PPUSH
38970: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38974: LD_INT 110
38976: PPUSH
38977: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38981: LD_INT 111
38983: PPUSH
38984: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38988: LD_INT 112
38990: PPUSH
38991: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38995: LD_INT 113
38997: PPUSH
38998: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39002: LD_INT 120
39004: PPUSH
39005: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39009: LD_INT 121
39011: PPUSH
39012: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39016: LD_INT 122
39018: PPUSH
39019: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39023: LD_INT 123
39025: PPUSH
39026: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39030: LD_INT 124
39032: PPUSH
39033: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39037: LD_INT 125
39039: PPUSH
39040: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39044: LD_INT 126
39046: PPUSH
39047: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39051: LD_INT 200
39053: PPUSH
39054: CALL_OW 427
// end ;
39058: END
// on SailEvent ( event ) do begin if event < 100 then
39059: LD_VAR 0 1
39063: PUSH
39064: LD_INT 100
39066: LESS
39067: IFFALSE 39078
// CustomEvent ( event ) ;
39069: LD_VAR 0 1
39073: PPUSH
39074: CALL 33534 0 1
// if event = 100 then
39078: LD_VAR 0 1
39082: PUSH
39083: LD_INT 100
39085: EQUAL
39086: IFFALSE 39092
// MC_ClassManager ( ) ;
39088: CALL 39484 0 0
// if event = 101 then
39092: LD_VAR 0 1
39096: PUSH
39097: LD_INT 101
39099: EQUAL
39100: IFFALSE 39106
// MC_RepairBuildings ( ) ;
39102: CALL 44302 0 0
// if event = 102 then
39106: LD_VAR 0 1
39110: PUSH
39111: LD_INT 102
39113: EQUAL
39114: IFFALSE 39120
// MC_Heal ( ) ;
39116: CALL 45209 0 0
// if event = 103 then
39120: LD_VAR 0 1
39124: PUSH
39125: LD_INT 103
39127: EQUAL
39128: IFFALSE 39134
// MC_Build ( ) ;
39130: CALL 45631 0 0
// if event = 104 then
39134: LD_VAR 0 1
39138: PUSH
39139: LD_INT 104
39141: EQUAL
39142: IFFALSE 39148
// MC_TurretWeapon ( ) ;
39144: CALL 47272 0 0
// if event = 105 then
39148: LD_VAR 0 1
39152: PUSH
39153: LD_INT 105
39155: EQUAL
39156: IFFALSE 39162
// MC_BuildUpgrade ( ) ;
39158: CALL 46823 0 0
// if event = 106 then
39162: LD_VAR 0 1
39166: PUSH
39167: LD_INT 106
39169: EQUAL
39170: IFFALSE 39176
// MC_PlantMines ( ) ;
39172: CALL 47702 0 0
// if event = 107 then
39176: LD_VAR 0 1
39180: PUSH
39181: LD_INT 107
39183: EQUAL
39184: IFFALSE 39190
// MC_CollectCrates ( ) ;
39186: CALL 48493 0 0
// if event = 108 then
39190: LD_VAR 0 1
39194: PUSH
39195: LD_INT 108
39197: EQUAL
39198: IFFALSE 39204
// MC_LinkRemoteControl ( ) ;
39200: CALL 50343 0 0
// if event = 109 then
39204: LD_VAR 0 1
39208: PUSH
39209: LD_INT 109
39211: EQUAL
39212: IFFALSE 39218
// MC_ProduceVehicle ( ) ;
39214: CALL 50524 0 0
// if event = 110 then
39218: LD_VAR 0 1
39222: PUSH
39223: LD_INT 110
39225: EQUAL
39226: IFFALSE 39232
// MC_SendAttack ( ) ;
39228: CALL 50990 0 0
// if event = 111 then
39232: LD_VAR 0 1
39236: PUSH
39237: LD_INT 111
39239: EQUAL
39240: IFFALSE 39246
// MC_Defend ( ) ;
39242: CALL 51098 0 0
// if event = 112 then
39246: LD_VAR 0 1
39250: PUSH
39251: LD_INT 112
39253: EQUAL
39254: IFFALSE 39260
// MC_Research ( ) ;
39256: CALL 51831 0 0
// if event = 113 then
39260: LD_VAR 0 1
39264: PUSH
39265: LD_INT 113
39267: EQUAL
39268: IFFALSE 39274
// MC_MinesTrigger ( ) ;
39270: CALL 52945 0 0
// if event = 120 then
39274: LD_VAR 0 1
39278: PUSH
39279: LD_INT 120
39281: EQUAL
39282: IFFALSE 39288
// MC_RepairVehicle ( ) ;
39284: CALL 53044 0 0
// if event = 121 then
39288: LD_VAR 0 1
39292: PUSH
39293: LD_INT 121
39295: EQUAL
39296: IFFALSE 39302
// MC_TameApe ( ) ;
39298: CALL 53785 0 0
// if event = 122 then
39302: LD_VAR 0 1
39306: PUSH
39307: LD_INT 122
39309: EQUAL
39310: IFFALSE 39316
// MC_ChangeApeClass ( ) ;
39312: CALL 54614 0 0
// if event = 123 then
39316: LD_VAR 0 1
39320: PUSH
39321: LD_INT 123
39323: EQUAL
39324: IFFALSE 39330
// MC_Bazooka ( ) ;
39326: CALL 55264 0 0
// if event = 124 then
39330: LD_VAR 0 1
39334: PUSH
39335: LD_INT 124
39337: EQUAL
39338: IFFALSE 39344
// MC_TeleportExit ( ) ;
39340: CALL 55462 0 0
// if event = 125 then
39344: LD_VAR 0 1
39348: PUSH
39349: LD_INT 125
39351: EQUAL
39352: IFFALSE 39358
// MC_Deposits ( ) ;
39354: CALL 56109 0 0
// if event = 126 then
39358: LD_VAR 0 1
39362: PUSH
39363: LD_INT 126
39365: EQUAL
39366: IFFALSE 39372
// MC_RemoteDriver ( ) ;
39368: CALL 56734 0 0
// if event = 200 then
39372: LD_VAR 0 1
39376: PUSH
39377: LD_INT 200
39379: EQUAL
39380: IFFALSE 39386
// MC_Idle ( ) ;
39382: CALL 58683 0 0
// end ;
39386: PPOPN 1
39388: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39389: LD_INT 0
39391: PPUSH
39392: PPUSH
// if not mc_bases [ base ] or not tag then
39393: LD_EXP 116
39397: PUSH
39398: LD_VAR 0 1
39402: ARRAY
39403: NOT
39404: PUSH
39405: LD_VAR 0 2
39409: NOT
39410: OR
39411: IFFALSE 39415
// exit ;
39413: GO 39479
// for i in mc_bases [ base ] union mc_ape [ base ] do
39415: LD_ADDR_VAR 0 4
39419: PUSH
39420: LD_EXP 116
39424: PUSH
39425: LD_VAR 0 1
39429: ARRAY
39430: PUSH
39431: LD_EXP 145
39435: PUSH
39436: LD_VAR 0 1
39440: ARRAY
39441: UNION
39442: PUSH
39443: FOR_IN
39444: IFFALSE 39477
// if GetTag ( i ) = tag then
39446: LD_VAR 0 4
39450: PPUSH
39451: CALL_OW 110
39455: PUSH
39456: LD_VAR 0 2
39460: EQUAL
39461: IFFALSE 39475
// SetTag ( i , 0 ) ;
39463: LD_VAR 0 4
39467: PPUSH
39468: LD_INT 0
39470: PPUSH
39471: CALL_OW 109
39475: GO 39443
39477: POP
39478: POP
// end ;
39479: LD_VAR 0 3
39483: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39484: LD_INT 0
39486: PPUSH
39487: PPUSH
39488: PPUSH
39489: PPUSH
39490: PPUSH
39491: PPUSH
39492: PPUSH
39493: PPUSH
// if not mc_bases then
39494: LD_EXP 116
39498: NOT
39499: IFFALSE 39503
// exit ;
39501: GO 39961
// for i = 1 to mc_bases do
39503: LD_ADDR_VAR 0 2
39507: PUSH
39508: DOUBLE
39509: LD_INT 1
39511: DEC
39512: ST_TO_ADDR
39513: LD_EXP 116
39517: PUSH
39518: FOR_TO
39519: IFFALSE 39959
// begin tmp := MC_ClassCheckReq ( i ) ;
39521: LD_ADDR_VAR 0 4
39525: PUSH
39526: LD_VAR 0 2
39530: PPUSH
39531: CALL 39966 0 1
39535: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39536: LD_ADDR_EXP 157
39540: PUSH
39541: LD_EXP 157
39545: PPUSH
39546: LD_VAR 0 2
39550: PPUSH
39551: LD_VAR 0 4
39555: PPUSH
39556: CALL_OW 1
39560: ST_TO_ADDR
// if not tmp then
39561: LD_VAR 0 4
39565: NOT
39566: IFFALSE 39570
// continue ;
39568: GO 39518
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39570: LD_ADDR_VAR 0 6
39574: PUSH
39575: LD_EXP 116
39579: PUSH
39580: LD_VAR 0 2
39584: ARRAY
39585: PPUSH
39586: LD_INT 2
39588: PUSH
39589: LD_INT 30
39591: PUSH
39592: LD_INT 4
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 30
39601: PUSH
39602: LD_INT 5
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: LIST
39613: PPUSH
39614: CALL_OW 72
39618: PUSH
39619: LD_EXP 116
39623: PUSH
39624: LD_VAR 0 2
39628: ARRAY
39629: PPUSH
39630: LD_INT 2
39632: PUSH
39633: LD_INT 30
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 30
39645: PUSH
39646: LD_INT 1
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: LIST
39657: PPUSH
39658: CALL_OW 72
39662: PUSH
39663: LD_EXP 116
39667: PUSH
39668: LD_VAR 0 2
39672: ARRAY
39673: PPUSH
39674: LD_INT 30
39676: PUSH
39677: LD_INT 3
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PPUSH
39684: CALL_OW 72
39688: PUSH
39689: LD_EXP 116
39693: PUSH
39694: LD_VAR 0 2
39698: ARRAY
39699: PPUSH
39700: LD_INT 2
39702: PUSH
39703: LD_INT 30
39705: PUSH
39706: LD_INT 6
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 30
39715: PUSH
39716: LD_INT 7
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 30
39725: PUSH
39726: LD_INT 8
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: PPUSH
39739: CALL_OW 72
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: ST_TO_ADDR
// for j = 1 to 4 do
39750: LD_ADDR_VAR 0 3
39754: PUSH
39755: DOUBLE
39756: LD_INT 1
39758: DEC
39759: ST_TO_ADDR
39760: LD_INT 4
39762: PUSH
39763: FOR_TO
39764: IFFALSE 39955
// begin if not tmp [ j ] then
39766: LD_VAR 0 4
39770: PUSH
39771: LD_VAR 0 3
39775: ARRAY
39776: NOT
39777: IFFALSE 39781
// continue ;
39779: GO 39763
// for p in tmp [ j ] do
39781: LD_ADDR_VAR 0 5
39785: PUSH
39786: LD_VAR 0 4
39790: PUSH
39791: LD_VAR 0 3
39795: ARRAY
39796: PUSH
39797: FOR_IN
39798: IFFALSE 39951
// begin if not b [ j ] then
39800: LD_VAR 0 6
39804: PUSH
39805: LD_VAR 0 3
39809: ARRAY
39810: NOT
39811: IFFALSE 39815
// break ;
39813: GO 39951
// e := 0 ;
39815: LD_ADDR_VAR 0 7
39819: PUSH
39820: LD_INT 0
39822: ST_TO_ADDR
// for k in b [ j ] do
39823: LD_ADDR_VAR 0 8
39827: PUSH
39828: LD_VAR 0 6
39832: PUSH
39833: LD_VAR 0 3
39837: ARRAY
39838: PUSH
39839: FOR_IN
39840: IFFALSE 39867
// if IsNotFull ( k ) then
39842: LD_VAR 0 8
39846: PPUSH
39847: CALL 67930 0 1
39851: IFFALSE 39865
// begin e := k ;
39853: LD_ADDR_VAR 0 7
39857: PUSH
39858: LD_VAR 0 8
39862: ST_TO_ADDR
// break ;
39863: GO 39867
// end ;
39865: GO 39839
39867: POP
39868: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39869: LD_VAR 0 7
39873: PUSH
39874: LD_VAR 0 5
39878: PPUSH
39879: LD_VAR 0 7
39883: PPUSH
39884: CALL 101094 0 2
39888: NOT
39889: AND
39890: IFFALSE 39949
// begin if IsInUnit ( p ) then
39892: LD_VAR 0 5
39896: PPUSH
39897: CALL_OW 310
39901: IFFALSE 39912
// ComExitBuilding ( p ) ;
39903: LD_VAR 0 5
39907: PPUSH
39908: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39912: LD_VAR 0 5
39916: PPUSH
39917: LD_VAR 0 7
39921: PPUSH
39922: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39926: LD_VAR 0 5
39930: PPUSH
39931: LD_VAR 0 3
39935: PPUSH
39936: CALL_OW 183
// AddComExitBuilding ( p ) ;
39940: LD_VAR 0 5
39944: PPUSH
39945: CALL_OW 182
// end ; end ;
39949: GO 39797
39951: POP
39952: POP
// end ;
39953: GO 39763
39955: POP
39956: POP
// end ;
39957: GO 39518
39959: POP
39960: POP
// end ;
39961: LD_VAR 0 1
39965: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39966: LD_INT 0
39968: PPUSH
39969: PPUSH
39970: PPUSH
39971: PPUSH
39972: PPUSH
39973: PPUSH
39974: PPUSH
39975: PPUSH
39976: PPUSH
39977: PPUSH
39978: PPUSH
39979: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39980: LD_VAR 0 1
39984: NOT
39985: PUSH
39986: LD_EXP 116
39990: PUSH
39991: LD_VAR 0 1
39995: ARRAY
39996: NOT
39997: OR
39998: PUSH
39999: LD_EXP 116
40003: PUSH
40004: LD_VAR 0 1
40008: ARRAY
40009: PPUSH
40010: LD_INT 2
40012: PUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 30
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: LIST
40037: PPUSH
40038: CALL_OW 72
40042: NOT
40043: OR
40044: IFFALSE 40048
// exit ;
40046: GO 43551
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40048: LD_ADDR_VAR 0 4
40052: PUSH
40053: LD_EXP 116
40057: PUSH
40058: LD_VAR 0 1
40062: ARRAY
40063: PPUSH
40064: LD_INT 2
40066: PUSH
40067: LD_INT 25
40069: PUSH
40070: LD_INT 1
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 25
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 25
40089: PUSH
40090: LD_INT 3
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 25
40099: PUSH
40100: LD_INT 4
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 25
40109: PUSH
40110: LD_INT 5
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 25
40119: PUSH
40120: LD_INT 8
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 25
40129: PUSH
40130: LD_INT 9
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: PPUSH
40147: CALL_OW 72
40151: ST_TO_ADDR
// if not tmp then
40152: LD_VAR 0 4
40156: NOT
40157: IFFALSE 40161
// exit ;
40159: GO 43551
// for i in tmp do
40161: LD_ADDR_VAR 0 3
40165: PUSH
40166: LD_VAR 0 4
40170: PUSH
40171: FOR_IN
40172: IFFALSE 40203
// if GetTag ( i ) then
40174: LD_VAR 0 3
40178: PPUSH
40179: CALL_OW 110
40183: IFFALSE 40201
// tmp := tmp diff i ;
40185: LD_ADDR_VAR 0 4
40189: PUSH
40190: LD_VAR 0 4
40194: PUSH
40195: LD_VAR 0 3
40199: DIFF
40200: ST_TO_ADDR
40201: GO 40171
40203: POP
40204: POP
// if not tmp then
40205: LD_VAR 0 4
40209: NOT
40210: IFFALSE 40214
// exit ;
40212: GO 43551
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40214: LD_ADDR_VAR 0 5
40218: PUSH
40219: LD_EXP 116
40223: PUSH
40224: LD_VAR 0 1
40228: ARRAY
40229: PPUSH
40230: LD_INT 2
40232: PUSH
40233: LD_INT 25
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 25
40245: PUSH
40246: LD_INT 5
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 25
40255: PUSH
40256: LD_INT 8
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 25
40265: PUSH
40266: LD_INT 9
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: PPUSH
40280: CALL_OW 72
40284: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40285: LD_ADDR_VAR 0 6
40289: PUSH
40290: LD_EXP 116
40294: PUSH
40295: LD_VAR 0 1
40299: ARRAY
40300: PPUSH
40301: LD_INT 25
40303: PUSH
40304: LD_INT 2
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PPUSH
40311: CALL_OW 72
40315: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40316: LD_ADDR_VAR 0 7
40320: PUSH
40321: LD_EXP 116
40325: PUSH
40326: LD_VAR 0 1
40330: ARRAY
40331: PPUSH
40332: LD_INT 25
40334: PUSH
40335: LD_INT 3
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PPUSH
40342: CALL_OW 72
40346: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40347: LD_ADDR_VAR 0 8
40351: PUSH
40352: LD_EXP 116
40356: PUSH
40357: LD_VAR 0 1
40361: ARRAY
40362: PPUSH
40363: LD_INT 25
40365: PUSH
40366: LD_INT 4
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 24
40375: PUSH
40376: LD_INT 251
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PPUSH
40387: CALL_OW 72
40391: ST_TO_ADDR
// if mc_is_defending [ base ] then
40392: LD_EXP 159
40396: PUSH
40397: LD_VAR 0 1
40401: ARRAY
40402: IFFALSE 40863
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40404: LD_ADDR_EXP 158
40408: PUSH
40409: LD_EXP 158
40413: PPUSH
40414: LD_VAR 0 1
40418: PPUSH
40419: LD_INT 4
40421: PPUSH
40422: CALL_OW 1
40426: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40427: LD_ADDR_VAR 0 12
40431: PUSH
40432: LD_EXP 116
40436: PUSH
40437: LD_VAR 0 1
40441: ARRAY
40442: PPUSH
40443: LD_INT 2
40445: PUSH
40446: LD_INT 30
40448: PUSH
40449: LD_INT 4
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 30
40458: PUSH
40459: LD_INT 5
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: LIST
40470: PPUSH
40471: CALL_OW 72
40475: ST_TO_ADDR
// if not b then
40476: LD_VAR 0 12
40480: NOT
40481: IFFALSE 40485
// exit ;
40483: GO 43551
// p := [ ] ;
40485: LD_ADDR_VAR 0 11
40489: PUSH
40490: EMPTY
40491: ST_TO_ADDR
// if sci >= 2 then
40492: LD_VAR 0 8
40496: PUSH
40497: LD_INT 2
40499: GREATEREQUAL
40500: IFFALSE 40531
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40502: LD_ADDR_VAR 0 8
40506: PUSH
40507: LD_VAR 0 8
40511: PUSH
40512: LD_INT 1
40514: ARRAY
40515: PUSH
40516: LD_VAR 0 8
40520: PUSH
40521: LD_INT 2
40523: ARRAY
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: ST_TO_ADDR
40529: GO 40592
// if sci = 1 then
40531: LD_VAR 0 8
40535: PUSH
40536: LD_INT 1
40538: EQUAL
40539: IFFALSE 40560
// sci := [ sci [ 1 ] ] else
40541: LD_ADDR_VAR 0 8
40545: PUSH
40546: LD_VAR 0 8
40550: PUSH
40551: LD_INT 1
40553: ARRAY
40554: PUSH
40555: EMPTY
40556: LIST
40557: ST_TO_ADDR
40558: GO 40592
// if sci = 0 then
40560: LD_VAR 0 8
40564: PUSH
40565: LD_INT 0
40567: EQUAL
40568: IFFALSE 40592
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40570: LD_ADDR_VAR 0 11
40574: PUSH
40575: LD_VAR 0 4
40579: PPUSH
40580: LD_INT 4
40582: PPUSH
40583: CALL 100957 0 2
40587: PUSH
40588: LD_INT 1
40590: ARRAY
40591: ST_TO_ADDR
// if eng > 4 then
40592: LD_VAR 0 6
40596: PUSH
40597: LD_INT 4
40599: GREATER
40600: IFFALSE 40646
// for i = eng downto 4 do
40602: LD_ADDR_VAR 0 3
40606: PUSH
40607: DOUBLE
40608: LD_VAR 0 6
40612: INC
40613: ST_TO_ADDR
40614: LD_INT 4
40616: PUSH
40617: FOR_DOWNTO
40618: IFFALSE 40644
// eng := eng diff eng [ i ] ;
40620: LD_ADDR_VAR 0 6
40624: PUSH
40625: LD_VAR 0 6
40629: PUSH
40630: LD_VAR 0 6
40634: PUSH
40635: LD_VAR 0 3
40639: ARRAY
40640: DIFF
40641: ST_TO_ADDR
40642: GO 40617
40644: POP
40645: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40646: LD_ADDR_VAR 0 4
40650: PUSH
40651: LD_VAR 0 4
40655: PUSH
40656: LD_VAR 0 5
40660: PUSH
40661: LD_VAR 0 6
40665: UNION
40666: PUSH
40667: LD_VAR 0 7
40671: UNION
40672: PUSH
40673: LD_VAR 0 8
40677: UNION
40678: DIFF
40679: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40680: LD_ADDR_VAR 0 13
40684: PUSH
40685: LD_EXP 116
40689: PUSH
40690: LD_VAR 0 1
40694: ARRAY
40695: PPUSH
40696: LD_INT 2
40698: PUSH
40699: LD_INT 30
40701: PUSH
40702: LD_INT 32
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: LD_INT 30
40711: PUSH
40712: LD_INT 31
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: LIST
40723: PPUSH
40724: CALL_OW 72
40728: PUSH
40729: LD_EXP 116
40733: PUSH
40734: LD_VAR 0 1
40738: ARRAY
40739: PPUSH
40740: LD_INT 2
40742: PUSH
40743: LD_INT 30
40745: PUSH
40746: LD_INT 4
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 30
40755: PUSH
40756: LD_INT 5
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: LIST
40767: PPUSH
40768: CALL_OW 72
40772: PUSH
40773: LD_INT 6
40775: MUL
40776: PLUS
40777: ST_TO_ADDR
// if bcount < tmp then
40778: LD_VAR 0 13
40782: PUSH
40783: LD_VAR 0 4
40787: LESS
40788: IFFALSE 40834
// for i = tmp downto bcount do
40790: LD_ADDR_VAR 0 3
40794: PUSH
40795: DOUBLE
40796: LD_VAR 0 4
40800: INC
40801: ST_TO_ADDR
40802: LD_VAR 0 13
40806: PUSH
40807: FOR_DOWNTO
40808: IFFALSE 40832
// tmp := Delete ( tmp , tmp ) ;
40810: LD_ADDR_VAR 0 4
40814: PUSH
40815: LD_VAR 0 4
40819: PPUSH
40820: LD_VAR 0 4
40824: PPUSH
40825: CALL_OW 3
40829: ST_TO_ADDR
40830: GO 40807
40832: POP
40833: POP
// result := [ tmp , 0 , 0 , p ] ;
40834: LD_ADDR_VAR 0 2
40838: PUSH
40839: LD_VAR 0 4
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: LD_INT 0
40849: PUSH
40850: LD_VAR 0 11
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: ST_TO_ADDR
// exit ;
40861: GO 43551
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40863: LD_EXP 116
40867: PUSH
40868: LD_VAR 0 1
40872: ARRAY
40873: PPUSH
40874: LD_INT 2
40876: PUSH
40877: LD_INT 30
40879: PUSH
40880: LD_INT 6
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 30
40889: PUSH
40890: LD_INT 7
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 30
40899: PUSH
40900: LD_INT 8
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: PPUSH
40913: CALL_OW 72
40917: NOT
40918: PUSH
40919: LD_EXP 116
40923: PUSH
40924: LD_VAR 0 1
40928: ARRAY
40929: PPUSH
40930: LD_INT 30
40932: PUSH
40933: LD_INT 3
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PPUSH
40940: CALL_OW 72
40944: NOT
40945: AND
40946: IFFALSE 41018
// begin if eng = tmp then
40948: LD_VAR 0 6
40952: PUSH
40953: LD_VAR 0 4
40957: EQUAL
40958: IFFALSE 40962
// exit ;
40960: GO 43551
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40962: LD_ADDR_EXP 158
40966: PUSH
40967: LD_EXP 158
40971: PPUSH
40972: LD_VAR 0 1
40976: PPUSH
40977: LD_INT 1
40979: PPUSH
40980: CALL_OW 1
40984: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40985: LD_ADDR_VAR 0 2
40989: PUSH
40990: LD_INT 0
40992: PUSH
40993: LD_VAR 0 4
40997: PUSH
40998: LD_VAR 0 6
41002: DIFF
41003: PUSH
41004: LD_INT 0
41006: PUSH
41007: LD_INT 0
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: ST_TO_ADDR
// exit ;
41016: GO 43551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41018: LD_EXP 143
41022: PUSH
41023: LD_EXP 142
41027: PUSH
41028: LD_VAR 0 1
41032: ARRAY
41033: ARRAY
41034: PUSH
41035: LD_EXP 116
41039: PUSH
41040: LD_VAR 0 1
41044: ARRAY
41045: PPUSH
41046: LD_INT 2
41048: PUSH
41049: LD_INT 30
41051: PUSH
41052: LD_INT 6
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 30
41061: PUSH
41062: LD_INT 7
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 30
41071: PUSH
41072: LD_INT 8
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: PPUSH
41085: CALL_OW 72
41089: AND
41090: PUSH
41091: LD_EXP 116
41095: PUSH
41096: LD_VAR 0 1
41100: ARRAY
41101: PPUSH
41102: LD_INT 30
41104: PUSH
41105: LD_INT 3
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PPUSH
41112: CALL_OW 72
41116: NOT
41117: AND
41118: IFFALSE 41332
// begin if sci >= 6 then
41120: LD_VAR 0 8
41124: PUSH
41125: LD_INT 6
41127: GREATEREQUAL
41128: IFFALSE 41132
// exit ;
41130: GO 43551
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41132: LD_ADDR_EXP 158
41136: PUSH
41137: LD_EXP 158
41141: PPUSH
41142: LD_VAR 0 1
41146: PPUSH
41147: LD_INT 2
41149: PPUSH
41150: CALL_OW 1
41154: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41155: LD_ADDR_VAR 0 9
41159: PUSH
41160: LD_VAR 0 4
41164: PUSH
41165: LD_VAR 0 8
41169: DIFF
41170: PPUSH
41171: LD_INT 4
41173: PPUSH
41174: CALL 100957 0 2
41178: ST_TO_ADDR
// p := [ ] ;
41179: LD_ADDR_VAR 0 11
41183: PUSH
41184: EMPTY
41185: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41186: LD_VAR 0 8
41190: PUSH
41191: LD_INT 6
41193: LESS
41194: PUSH
41195: LD_VAR 0 9
41199: PUSH
41200: LD_INT 6
41202: GREATER
41203: AND
41204: IFFALSE 41285
// begin for i = 1 to 6 - sci do
41206: LD_ADDR_VAR 0 3
41210: PUSH
41211: DOUBLE
41212: LD_INT 1
41214: DEC
41215: ST_TO_ADDR
41216: LD_INT 6
41218: PUSH
41219: LD_VAR 0 8
41223: MINUS
41224: PUSH
41225: FOR_TO
41226: IFFALSE 41281
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41228: LD_ADDR_VAR 0 11
41232: PUSH
41233: LD_VAR 0 11
41237: PPUSH
41238: LD_VAR 0 11
41242: PUSH
41243: LD_INT 1
41245: PLUS
41246: PPUSH
41247: LD_VAR 0 9
41251: PUSH
41252: LD_INT 1
41254: ARRAY
41255: PPUSH
41256: CALL_OW 2
41260: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41261: LD_ADDR_VAR 0 9
41265: PUSH
41266: LD_VAR 0 9
41270: PPUSH
41271: LD_INT 1
41273: PPUSH
41274: CALL_OW 3
41278: ST_TO_ADDR
// end ;
41279: GO 41225
41281: POP
41282: POP
// end else
41283: GO 41305
// if sort then
41285: LD_VAR 0 9
41289: IFFALSE 41305
// p := sort [ 1 ] ;
41291: LD_ADDR_VAR 0 11
41295: PUSH
41296: LD_VAR 0 9
41300: PUSH
41301: LD_INT 1
41303: ARRAY
41304: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41305: LD_ADDR_VAR 0 2
41309: PUSH
41310: LD_INT 0
41312: PUSH
41313: LD_INT 0
41315: PUSH
41316: LD_INT 0
41318: PUSH
41319: LD_VAR 0 11
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// exit ;
41330: GO 43551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41332: LD_EXP 143
41336: PUSH
41337: LD_EXP 142
41341: PUSH
41342: LD_VAR 0 1
41346: ARRAY
41347: ARRAY
41348: PUSH
41349: LD_EXP 116
41353: PUSH
41354: LD_VAR 0 1
41358: ARRAY
41359: PPUSH
41360: LD_INT 2
41362: PUSH
41363: LD_INT 30
41365: PUSH
41366: LD_INT 6
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 30
41375: PUSH
41376: LD_INT 7
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 30
41385: PUSH
41386: LD_INT 8
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL_OW 72
41403: AND
41404: PUSH
41405: LD_EXP 116
41409: PUSH
41410: LD_VAR 0 1
41414: ARRAY
41415: PPUSH
41416: LD_INT 30
41418: PUSH
41419: LD_INT 3
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PPUSH
41426: CALL_OW 72
41430: AND
41431: IFFALSE 42165
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41433: LD_ADDR_EXP 158
41437: PUSH
41438: LD_EXP 158
41442: PPUSH
41443: LD_VAR 0 1
41447: PPUSH
41448: LD_INT 3
41450: PPUSH
41451: CALL_OW 1
41455: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41456: LD_ADDR_VAR 0 2
41460: PUSH
41461: LD_INT 0
41463: PUSH
41464: LD_INT 0
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 0
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: ST_TO_ADDR
// if not eng then
41479: LD_VAR 0 6
41483: NOT
41484: IFFALSE 41547
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41486: LD_ADDR_VAR 0 11
41490: PUSH
41491: LD_VAR 0 4
41495: PPUSH
41496: LD_INT 2
41498: PPUSH
41499: CALL 100957 0 2
41503: PUSH
41504: LD_INT 1
41506: ARRAY
41507: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41508: LD_ADDR_VAR 0 2
41512: PUSH
41513: LD_VAR 0 2
41517: PPUSH
41518: LD_INT 2
41520: PPUSH
41521: LD_VAR 0 11
41525: PPUSH
41526: CALL_OW 1
41530: ST_TO_ADDR
// tmp := tmp diff p ;
41531: LD_ADDR_VAR 0 4
41535: PUSH
41536: LD_VAR 0 4
41540: PUSH
41541: LD_VAR 0 11
41545: DIFF
41546: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41547: LD_VAR 0 4
41551: PUSH
41552: LD_VAR 0 8
41556: PUSH
41557: LD_INT 6
41559: LESS
41560: AND
41561: IFFALSE 41749
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41563: LD_ADDR_VAR 0 9
41567: PUSH
41568: LD_VAR 0 4
41572: PUSH
41573: LD_VAR 0 8
41577: PUSH
41578: LD_VAR 0 7
41582: UNION
41583: DIFF
41584: PPUSH
41585: LD_INT 4
41587: PPUSH
41588: CALL 100957 0 2
41592: ST_TO_ADDR
// p := [ ] ;
41593: LD_ADDR_VAR 0 11
41597: PUSH
41598: EMPTY
41599: ST_TO_ADDR
// if sort then
41600: LD_VAR 0 9
41604: IFFALSE 41720
// for i = 1 to 6 - sci do
41606: LD_ADDR_VAR 0 3
41610: PUSH
41611: DOUBLE
41612: LD_INT 1
41614: DEC
41615: ST_TO_ADDR
41616: LD_INT 6
41618: PUSH
41619: LD_VAR 0 8
41623: MINUS
41624: PUSH
41625: FOR_TO
41626: IFFALSE 41718
// begin if i = sort then
41628: LD_VAR 0 3
41632: PUSH
41633: LD_VAR 0 9
41637: EQUAL
41638: IFFALSE 41642
// break ;
41640: GO 41718
// if GetClass ( i ) = 4 then
41642: LD_VAR 0 3
41646: PPUSH
41647: CALL_OW 257
41651: PUSH
41652: LD_INT 4
41654: EQUAL
41655: IFFALSE 41659
// continue ;
41657: GO 41625
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41659: LD_ADDR_VAR 0 11
41663: PUSH
41664: LD_VAR 0 11
41668: PPUSH
41669: LD_VAR 0 11
41673: PUSH
41674: LD_INT 1
41676: PLUS
41677: PPUSH
41678: LD_VAR 0 9
41682: PUSH
41683: LD_VAR 0 3
41687: ARRAY
41688: PPUSH
41689: CALL_OW 2
41693: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41694: LD_ADDR_VAR 0 4
41698: PUSH
41699: LD_VAR 0 4
41703: PUSH
41704: LD_VAR 0 9
41708: PUSH
41709: LD_VAR 0 3
41713: ARRAY
41714: DIFF
41715: ST_TO_ADDR
// end ;
41716: GO 41625
41718: POP
41719: POP
// if p then
41720: LD_VAR 0 11
41724: IFFALSE 41749
// result := Replace ( result , 4 , p ) ;
41726: LD_ADDR_VAR 0 2
41730: PUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: LD_INT 4
41738: PPUSH
41739: LD_VAR 0 11
41743: PPUSH
41744: CALL_OW 1
41748: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41749: LD_VAR 0 4
41753: PUSH
41754: LD_VAR 0 7
41758: PUSH
41759: LD_INT 6
41761: LESS
41762: AND
41763: IFFALSE 41951
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41765: LD_ADDR_VAR 0 9
41769: PUSH
41770: LD_VAR 0 4
41774: PUSH
41775: LD_VAR 0 8
41779: PUSH
41780: LD_VAR 0 7
41784: UNION
41785: DIFF
41786: PPUSH
41787: LD_INT 3
41789: PPUSH
41790: CALL 100957 0 2
41794: ST_TO_ADDR
// p := [ ] ;
41795: LD_ADDR_VAR 0 11
41799: PUSH
41800: EMPTY
41801: ST_TO_ADDR
// if sort then
41802: LD_VAR 0 9
41806: IFFALSE 41922
// for i = 1 to 6 - mech do
41808: LD_ADDR_VAR 0 3
41812: PUSH
41813: DOUBLE
41814: LD_INT 1
41816: DEC
41817: ST_TO_ADDR
41818: LD_INT 6
41820: PUSH
41821: LD_VAR 0 7
41825: MINUS
41826: PUSH
41827: FOR_TO
41828: IFFALSE 41920
// begin if i = sort then
41830: LD_VAR 0 3
41834: PUSH
41835: LD_VAR 0 9
41839: EQUAL
41840: IFFALSE 41844
// break ;
41842: GO 41920
// if GetClass ( i ) = 3 then
41844: LD_VAR 0 3
41848: PPUSH
41849: CALL_OW 257
41853: PUSH
41854: LD_INT 3
41856: EQUAL
41857: IFFALSE 41861
// continue ;
41859: GO 41827
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41861: LD_ADDR_VAR 0 11
41865: PUSH
41866: LD_VAR 0 11
41870: PPUSH
41871: LD_VAR 0 11
41875: PUSH
41876: LD_INT 1
41878: PLUS
41879: PPUSH
41880: LD_VAR 0 9
41884: PUSH
41885: LD_VAR 0 3
41889: ARRAY
41890: PPUSH
41891: CALL_OW 2
41895: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41896: LD_ADDR_VAR 0 4
41900: PUSH
41901: LD_VAR 0 4
41905: PUSH
41906: LD_VAR 0 9
41910: PUSH
41911: LD_VAR 0 3
41915: ARRAY
41916: DIFF
41917: ST_TO_ADDR
// end ;
41918: GO 41827
41920: POP
41921: POP
// if p then
41922: LD_VAR 0 11
41926: IFFALSE 41951
// result := Replace ( result , 3 , p ) ;
41928: LD_ADDR_VAR 0 2
41932: PUSH
41933: LD_VAR 0 2
41937: PPUSH
41938: LD_INT 3
41940: PPUSH
41941: LD_VAR 0 11
41945: PPUSH
41946: CALL_OW 1
41950: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41951: LD_VAR 0 4
41955: PUSH
41956: LD_INT 6
41958: GREATER
41959: PUSH
41960: LD_VAR 0 6
41964: PUSH
41965: LD_INT 6
41967: LESS
41968: AND
41969: IFFALSE 42163
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41971: LD_ADDR_VAR 0 9
41975: PUSH
41976: LD_VAR 0 4
41980: PUSH
41981: LD_VAR 0 8
41985: PUSH
41986: LD_VAR 0 7
41990: UNION
41991: PUSH
41992: LD_VAR 0 6
41996: UNION
41997: DIFF
41998: PPUSH
41999: LD_INT 2
42001: PPUSH
42002: CALL 100957 0 2
42006: ST_TO_ADDR
// p := [ ] ;
42007: LD_ADDR_VAR 0 11
42011: PUSH
42012: EMPTY
42013: ST_TO_ADDR
// if sort then
42014: LD_VAR 0 9
42018: IFFALSE 42134
// for i = 1 to 6 - eng do
42020: LD_ADDR_VAR 0 3
42024: PUSH
42025: DOUBLE
42026: LD_INT 1
42028: DEC
42029: ST_TO_ADDR
42030: LD_INT 6
42032: PUSH
42033: LD_VAR 0 6
42037: MINUS
42038: PUSH
42039: FOR_TO
42040: IFFALSE 42132
// begin if i = sort then
42042: LD_VAR 0 3
42046: PUSH
42047: LD_VAR 0 9
42051: EQUAL
42052: IFFALSE 42056
// break ;
42054: GO 42132
// if GetClass ( i ) = 2 then
42056: LD_VAR 0 3
42060: PPUSH
42061: CALL_OW 257
42065: PUSH
42066: LD_INT 2
42068: EQUAL
42069: IFFALSE 42073
// continue ;
42071: GO 42039
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42073: LD_ADDR_VAR 0 11
42077: PUSH
42078: LD_VAR 0 11
42082: PPUSH
42083: LD_VAR 0 11
42087: PUSH
42088: LD_INT 1
42090: PLUS
42091: PPUSH
42092: LD_VAR 0 9
42096: PUSH
42097: LD_VAR 0 3
42101: ARRAY
42102: PPUSH
42103: CALL_OW 2
42107: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42108: LD_ADDR_VAR 0 4
42112: PUSH
42113: LD_VAR 0 4
42117: PUSH
42118: LD_VAR 0 9
42122: PUSH
42123: LD_VAR 0 3
42127: ARRAY
42128: DIFF
42129: ST_TO_ADDR
// end ;
42130: GO 42039
42132: POP
42133: POP
// if p then
42134: LD_VAR 0 11
42138: IFFALSE 42163
// result := Replace ( result , 2 , p ) ;
42140: LD_ADDR_VAR 0 2
42144: PUSH
42145: LD_VAR 0 2
42149: PPUSH
42150: LD_INT 2
42152: PPUSH
42153: LD_VAR 0 11
42157: PPUSH
42158: CALL_OW 1
42162: ST_TO_ADDR
// end ; exit ;
42163: GO 43551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42165: LD_EXP 143
42169: PUSH
42170: LD_EXP 142
42174: PUSH
42175: LD_VAR 0 1
42179: ARRAY
42180: ARRAY
42181: NOT
42182: PUSH
42183: LD_EXP 116
42187: PUSH
42188: LD_VAR 0 1
42192: ARRAY
42193: PPUSH
42194: LD_INT 30
42196: PUSH
42197: LD_INT 3
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PPUSH
42204: CALL_OW 72
42208: AND
42209: PUSH
42210: LD_EXP 121
42214: PUSH
42215: LD_VAR 0 1
42219: ARRAY
42220: AND
42221: IFFALSE 42829
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42223: LD_ADDR_EXP 158
42227: PUSH
42228: LD_EXP 158
42232: PPUSH
42233: LD_VAR 0 1
42237: PPUSH
42238: LD_INT 5
42240: PPUSH
42241: CALL_OW 1
42245: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42246: LD_ADDR_VAR 0 2
42250: PUSH
42251: LD_INT 0
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: LD_INT 0
42259: PUSH
42260: LD_INT 0
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: LIST
42267: LIST
42268: ST_TO_ADDR
// if sci > 1 then
42269: LD_VAR 0 8
42273: PUSH
42274: LD_INT 1
42276: GREATER
42277: IFFALSE 42305
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42279: LD_ADDR_VAR 0 4
42283: PUSH
42284: LD_VAR 0 4
42288: PUSH
42289: LD_VAR 0 8
42293: PUSH
42294: LD_VAR 0 8
42298: PUSH
42299: LD_INT 1
42301: ARRAY
42302: DIFF
42303: DIFF
42304: ST_TO_ADDR
// if tmp and not sci then
42305: LD_VAR 0 4
42309: PUSH
42310: LD_VAR 0 8
42314: NOT
42315: AND
42316: IFFALSE 42385
// begin sort := SortBySkill ( tmp , 4 ) ;
42318: LD_ADDR_VAR 0 9
42322: PUSH
42323: LD_VAR 0 4
42327: PPUSH
42328: LD_INT 4
42330: PPUSH
42331: CALL 100957 0 2
42335: ST_TO_ADDR
// if sort then
42336: LD_VAR 0 9
42340: IFFALSE 42356
// p := sort [ 1 ] ;
42342: LD_ADDR_VAR 0 11
42346: PUSH
42347: LD_VAR 0 9
42351: PUSH
42352: LD_INT 1
42354: ARRAY
42355: ST_TO_ADDR
// if p then
42356: LD_VAR 0 11
42360: IFFALSE 42385
// result := Replace ( result , 4 , p ) ;
42362: LD_ADDR_VAR 0 2
42366: PUSH
42367: LD_VAR 0 2
42371: PPUSH
42372: LD_INT 4
42374: PPUSH
42375: LD_VAR 0 11
42379: PPUSH
42380: CALL_OW 1
42384: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42385: LD_ADDR_VAR 0 4
42389: PUSH
42390: LD_VAR 0 4
42394: PUSH
42395: LD_VAR 0 7
42399: DIFF
42400: ST_TO_ADDR
// if tmp and mech < 6 then
42401: LD_VAR 0 4
42405: PUSH
42406: LD_VAR 0 7
42410: PUSH
42411: LD_INT 6
42413: LESS
42414: AND
42415: IFFALSE 42603
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42417: LD_ADDR_VAR 0 9
42421: PUSH
42422: LD_VAR 0 4
42426: PUSH
42427: LD_VAR 0 8
42431: PUSH
42432: LD_VAR 0 7
42436: UNION
42437: DIFF
42438: PPUSH
42439: LD_INT 3
42441: PPUSH
42442: CALL 100957 0 2
42446: ST_TO_ADDR
// p := [ ] ;
42447: LD_ADDR_VAR 0 11
42451: PUSH
42452: EMPTY
42453: ST_TO_ADDR
// if sort then
42454: LD_VAR 0 9
42458: IFFALSE 42574
// for i = 1 to 6 - mech do
42460: LD_ADDR_VAR 0 3
42464: PUSH
42465: DOUBLE
42466: LD_INT 1
42468: DEC
42469: ST_TO_ADDR
42470: LD_INT 6
42472: PUSH
42473: LD_VAR 0 7
42477: MINUS
42478: PUSH
42479: FOR_TO
42480: IFFALSE 42572
// begin if i = sort then
42482: LD_VAR 0 3
42486: PUSH
42487: LD_VAR 0 9
42491: EQUAL
42492: IFFALSE 42496
// break ;
42494: GO 42572
// if GetClass ( i ) = 3 then
42496: LD_VAR 0 3
42500: PPUSH
42501: CALL_OW 257
42505: PUSH
42506: LD_INT 3
42508: EQUAL
42509: IFFALSE 42513
// continue ;
42511: GO 42479
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42513: LD_ADDR_VAR 0 11
42517: PUSH
42518: LD_VAR 0 11
42522: PPUSH
42523: LD_VAR 0 11
42527: PUSH
42528: LD_INT 1
42530: PLUS
42531: PPUSH
42532: LD_VAR 0 9
42536: PUSH
42537: LD_VAR 0 3
42541: ARRAY
42542: PPUSH
42543: CALL_OW 2
42547: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42548: LD_ADDR_VAR 0 4
42552: PUSH
42553: LD_VAR 0 4
42557: PUSH
42558: LD_VAR 0 9
42562: PUSH
42563: LD_VAR 0 3
42567: ARRAY
42568: DIFF
42569: ST_TO_ADDR
// end ;
42570: GO 42479
42572: POP
42573: POP
// if p then
42574: LD_VAR 0 11
42578: IFFALSE 42603
// result := Replace ( result , 3 , p ) ;
42580: LD_ADDR_VAR 0 2
42584: PUSH
42585: LD_VAR 0 2
42589: PPUSH
42590: LD_INT 3
42592: PPUSH
42593: LD_VAR 0 11
42597: PPUSH
42598: CALL_OW 1
42602: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42603: LD_ADDR_VAR 0 4
42607: PUSH
42608: LD_VAR 0 4
42612: PUSH
42613: LD_VAR 0 6
42617: DIFF
42618: ST_TO_ADDR
// if tmp and eng < 6 then
42619: LD_VAR 0 4
42623: PUSH
42624: LD_VAR 0 6
42628: PUSH
42629: LD_INT 6
42631: LESS
42632: AND
42633: IFFALSE 42827
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42635: LD_ADDR_VAR 0 9
42639: PUSH
42640: LD_VAR 0 4
42644: PUSH
42645: LD_VAR 0 8
42649: PUSH
42650: LD_VAR 0 7
42654: UNION
42655: PUSH
42656: LD_VAR 0 6
42660: UNION
42661: DIFF
42662: PPUSH
42663: LD_INT 2
42665: PPUSH
42666: CALL 100957 0 2
42670: ST_TO_ADDR
// p := [ ] ;
42671: LD_ADDR_VAR 0 11
42675: PUSH
42676: EMPTY
42677: ST_TO_ADDR
// if sort then
42678: LD_VAR 0 9
42682: IFFALSE 42798
// for i = 1 to 6 - eng do
42684: LD_ADDR_VAR 0 3
42688: PUSH
42689: DOUBLE
42690: LD_INT 1
42692: DEC
42693: ST_TO_ADDR
42694: LD_INT 6
42696: PUSH
42697: LD_VAR 0 6
42701: MINUS
42702: PUSH
42703: FOR_TO
42704: IFFALSE 42796
// begin if i = sort then
42706: LD_VAR 0 3
42710: PUSH
42711: LD_VAR 0 9
42715: EQUAL
42716: IFFALSE 42720
// break ;
42718: GO 42796
// if GetClass ( i ) = 2 then
42720: LD_VAR 0 3
42724: PPUSH
42725: CALL_OW 257
42729: PUSH
42730: LD_INT 2
42732: EQUAL
42733: IFFALSE 42737
// continue ;
42735: GO 42703
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42737: LD_ADDR_VAR 0 11
42741: PUSH
42742: LD_VAR 0 11
42746: PPUSH
42747: LD_VAR 0 11
42751: PUSH
42752: LD_INT 1
42754: PLUS
42755: PPUSH
42756: LD_VAR 0 9
42760: PUSH
42761: LD_VAR 0 3
42765: ARRAY
42766: PPUSH
42767: CALL_OW 2
42771: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42772: LD_ADDR_VAR 0 4
42776: PUSH
42777: LD_VAR 0 4
42781: PUSH
42782: LD_VAR 0 9
42786: PUSH
42787: LD_VAR 0 3
42791: ARRAY
42792: DIFF
42793: ST_TO_ADDR
// end ;
42794: GO 42703
42796: POP
42797: POP
// if p then
42798: LD_VAR 0 11
42802: IFFALSE 42827
// result := Replace ( result , 2 , p ) ;
42804: LD_ADDR_VAR 0 2
42808: PUSH
42809: LD_VAR 0 2
42813: PPUSH
42814: LD_INT 2
42816: PPUSH
42817: LD_VAR 0 11
42821: PPUSH
42822: CALL_OW 1
42826: ST_TO_ADDR
// end ; exit ;
42827: GO 43551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42829: LD_EXP 143
42833: PUSH
42834: LD_EXP 142
42838: PUSH
42839: LD_VAR 0 1
42843: ARRAY
42844: ARRAY
42845: NOT
42846: PUSH
42847: LD_EXP 116
42851: PUSH
42852: LD_VAR 0 1
42856: ARRAY
42857: PPUSH
42858: LD_INT 30
42860: PUSH
42861: LD_INT 3
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PPUSH
42868: CALL_OW 72
42872: AND
42873: PUSH
42874: LD_EXP 121
42878: PUSH
42879: LD_VAR 0 1
42883: ARRAY
42884: NOT
42885: AND
42886: IFFALSE 43551
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42888: LD_ADDR_EXP 158
42892: PUSH
42893: LD_EXP 158
42897: PPUSH
42898: LD_VAR 0 1
42902: PPUSH
42903: LD_INT 6
42905: PPUSH
42906: CALL_OW 1
42910: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42911: LD_ADDR_VAR 0 2
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: LD_INT 0
42921: PUSH
42922: LD_INT 0
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: LIST
42933: ST_TO_ADDR
// if sci >= 1 then
42934: LD_VAR 0 8
42938: PUSH
42939: LD_INT 1
42941: GREATEREQUAL
42942: IFFALSE 42964
// tmp := tmp diff sci [ 1 ] ;
42944: LD_ADDR_VAR 0 4
42948: PUSH
42949: LD_VAR 0 4
42953: PUSH
42954: LD_VAR 0 8
42958: PUSH
42959: LD_INT 1
42961: ARRAY
42962: DIFF
42963: ST_TO_ADDR
// if tmp and not sci then
42964: LD_VAR 0 4
42968: PUSH
42969: LD_VAR 0 8
42973: NOT
42974: AND
42975: IFFALSE 43044
// begin sort := SortBySkill ( tmp , 4 ) ;
42977: LD_ADDR_VAR 0 9
42981: PUSH
42982: LD_VAR 0 4
42986: PPUSH
42987: LD_INT 4
42989: PPUSH
42990: CALL 100957 0 2
42994: ST_TO_ADDR
// if sort then
42995: LD_VAR 0 9
42999: IFFALSE 43015
// p := sort [ 1 ] ;
43001: LD_ADDR_VAR 0 11
43005: PUSH
43006: LD_VAR 0 9
43010: PUSH
43011: LD_INT 1
43013: ARRAY
43014: ST_TO_ADDR
// if p then
43015: LD_VAR 0 11
43019: IFFALSE 43044
// result := Replace ( result , 4 , p ) ;
43021: LD_ADDR_VAR 0 2
43025: PUSH
43026: LD_VAR 0 2
43030: PPUSH
43031: LD_INT 4
43033: PPUSH
43034: LD_VAR 0 11
43038: PPUSH
43039: CALL_OW 1
43043: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43044: LD_ADDR_VAR 0 4
43048: PUSH
43049: LD_VAR 0 4
43053: PUSH
43054: LD_VAR 0 7
43058: DIFF
43059: ST_TO_ADDR
// if tmp and mech < 6 then
43060: LD_VAR 0 4
43064: PUSH
43065: LD_VAR 0 7
43069: PUSH
43070: LD_INT 6
43072: LESS
43073: AND
43074: IFFALSE 43256
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43076: LD_ADDR_VAR 0 9
43080: PUSH
43081: LD_VAR 0 4
43085: PUSH
43086: LD_VAR 0 7
43090: DIFF
43091: PPUSH
43092: LD_INT 3
43094: PPUSH
43095: CALL 100957 0 2
43099: ST_TO_ADDR
// p := [ ] ;
43100: LD_ADDR_VAR 0 11
43104: PUSH
43105: EMPTY
43106: ST_TO_ADDR
// if sort then
43107: LD_VAR 0 9
43111: IFFALSE 43227
// for i = 1 to 6 - mech do
43113: LD_ADDR_VAR 0 3
43117: PUSH
43118: DOUBLE
43119: LD_INT 1
43121: DEC
43122: ST_TO_ADDR
43123: LD_INT 6
43125: PUSH
43126: LD_VAR 0 7
43130: MINUS
43131: PUSH
43132: FOR_TO
43133: IFFALSE 43225
// begin if i = sort then
43135: LD_VAR 0 3
43139: PUSH
43140: LD_VAR 0 9
43144: EQUAL
43145: IFFALSE 43149
// break ;
43147: GO 43225
// if GetClass ( i ) = 3 then
43149: LD_VAR 0 3
43153: PPUSH
43154: CALL_OW 257
43158: PUSH
43159: LD_INT 3
43161: EQUAL
43162: IFFALSE 43166
// continue ;
43164: GO 43132
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43166: LD_ADDR_VAR 0 11
43170: PUSH
43171: LD_VAR 0 11
43175: PPUSH
43176: LD_VAR 0 11
43180: PUSH
43181: LD_INT 1
43183: PLUS
43184: PPUSH
43185: LD_VAR 0 9
43189: PUSH
43190: LD_VAR 0 3
43194: ARRAY
43195: PPUSH
43196: CALL_OW 2
43200: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43201: LD_ADDR_VAR 0 4
43205: PUSH
43206: LD_VAR 0 4
43210: PUSH
43211: LD_VAR 0 9
43215: PUSH
43216: LD_VAR 0 3
43220: ARRAY
43221: DIFF
43222: ST_TO_ADDR
// end ;
43223: GO 43132
43225: POP
43226: POP
// if p then
43227: LD_VAR 0 11
43231: IFFALSE 43256
// result := Replace ( result , 3 , p ) ;
43233: LD_ADDR_VAR 0 2
43237: PUSH
43238: LD_VAR 0 2
43242: PPUSH
43243: LD_INT 3
43245: PPUSH
43246: LD_VAR 0 11
43250: PPUSH
43251: CALL_OW 1
43255: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43256: LD_ADDR_VAR 0 4
43260: PUSH
43261: LD_VAR 0 4
43265: PUSH
43266: LD_VAR 0 6
43270: DIFF
43271: ST_TO_ADDR
// if tmp and eng < 4 then
43272: LD_VAR 0 4
43276: PUSH
43277: LD_VAR 0 6
43281: PUSH
43282: LD_INT 4
43284: LESS
43285: AND
43286: IFFALSE 43476
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43288: LD_ADDR_VAR 0 9
43292: PUSH
43293: LD_VAR 0 4
43297: PUSH
43298: LD_VAR 0 7
43302: PUSH
43303: LD_VAR 0 6
43307: UNION
43308: DIFF
43309: PPUSH
43310: LD_INT 2
43312: PPUSH
43313: CALL 100957 0 2
43317: ST_TO_ADDR
// p := [ ] ;
43318: LD_ADDR_VAR 0 11
43322: PUSH
43323: EMPTY
43324: ST_TO_ADDR
// if sort then
43325: LD_VAR 0 9
43329: IFFALSE 43445
// for i = 1 to 4 - eng do
43331: LD_ADDR_VAR 0 3
43335: PUSH
43336: DOUBLE
43337: LD_INT 1
43339: DEC
43340: ST_TO_ADDR
43341: LD_INT 4
43343: PUSH
43344: LD_VAR 0 6
43348: MINUS
43349: PUSH
43350: FOR_TO
43351: IFFALSE 43443
// begin if i = sort then
43353: LD_VAR 0 3
43357: PUSH
43358: LD_VAR 0 9
43362: EQUAL
43363: IFFALSE 43367
// break ;
43365: GO 43443
// if GetClass ( i ) = 2 then
43367: LD_VAR 0 3
43371: PPUSH
43372: CALL_OW 257
43376: PUSH
43377: LD_INT 2
43379: EQUAL
43380: IFFALSE 43384
// continue ;
43382: GO 43350
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43384: LD_ADDR_VAR 0 11
43388: PUSH
43389: LD_VAR 0 11
43393: PPUSH
43394: LD_VAR 0 11
43398: PUSH
43399: LD_INT 1
43401: PLUS
43402: PPUSH
43403: LD_VAR 0 9
43407: PUSH
43408: LD_VAR 0 3
43412: ARRAY
43413: PPUSH
43414: CALL_OW 2
43418: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43419: LD_ADDR_VAR 0 4
43423: PUSH
43424: LD_VAR 0 4
43428: PUSH
43429: LD_VAR 0 9
43433: PUSH
43434: LD_VAR 0 3
43438: ARRAY
43439: DIFF
43440: ST_TO_ADDR
// end ;
43441: GO 43350
43443: POP
43444: POP
// if p then
43445: LD_VAR 0 11
43449: IFFALSE 43474
// result := Replace ( result , 2 , p ) ;
43451: LD_ADDR_VAR 0 2
43455: PUSH
43456: LD_VAR 0 2
43460: PPUSH
43461: LD_INT 2
43463: PPUSH
43464: LD_VAR 0 11
43468: PPUSH
43469: CALL_OW 1
43473: ST_TO_ADDR
// end else
43474: GO 43520
// for i = eng downto 5 do
43476: LD_ADDR_VAR 0 3
43480: PUSH
43481: DOUBLE
43482: LD_VAR 0 6
43486: INC
43487: ST_TO_ADDR
43488: LD_INT 5
43490: PUSH
43491: FOR_DOWNTO
43492: IFFALSE 43518
// tmp := tmp union eng [ i ] ;
43494: LD_ADDR_VAR 0 4
43498: PUSH
43499: LD_VAR 0 4
43503: PUSH
43504: LD_VAR 0 6
43508: PUSH
43509: LD_VAR 0 3
43513: ARRAY
43514: UNION
43515: ST_TO_ADDR
43516: GO 43491
43518: POP
43519: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43520: LD_ADDR_VAR 0 2
43524: PUSH
43525: LD_VAR 0 2
43529: PPUSH
43530: LD_INT 1
43532: PPUSH
43533: LD_VAR 0 4
43537: PUSH
43538: LD_VAR 0 5
43542: DIFF
43543: PPUSH
43544: CALL_OW 1
43548: ST_TO_ADDR
// exit ;
43549: GO 43551
// end ; end ;
43551: LD_VAR 0 2
43555: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43556: LD_INT 0
43558: PPUSH
43559: PPUSH
43560: PPUSH
// if not mc_bases then
43561: LD_EXP 116
43565: NOT
43566: IFFALSE 43570
// exit ;
43568: GO 43712
// for i = 1 to mc_bases do
43570: LD_ADDR_VAR 0 2
43574: PUSH
43575: DOUBLE
43576: LD_INT 1
43578: DEC
43579: ST_TO_ADDR
43580: LD_EXP 116
43584: PUSH
43585: FOR_TO
43586: IFFALSE 43703
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43588: LD_ADDR_VAR 0 3
43592: PUSH
43593: LD_EXP 116
43597: PUSH
43598: LD_VAR 0 2
43602: ARRAY
43603: PPUSH
43604: LD_INT 21
43606: PUSH
43607: LD_INT 3
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: PUSH
43617: LD_INT 2
43619: PUSH
43620: LD_INT 30
43622: PUSH
43623: LD_INT 29
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 30
43632: PUSH
43633: LD_INT 30
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: LIST
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 3
43651: PUSH
43652: LD_INT 24
43654: PUSH
43655: LD_INT 1000
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: LIST
43670: PPUSH
43671: CALL_OW 72
43675: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43676: LD_ADDR_EXP 117
43680: PUSH
43681: LD_EXP 117
43685: PPUSH
43686: LD_VAR 0 2
43690: PPUSH
43691: LD_VAR 0 3
43695: PPUSH
43696: CALL_OW 1
43700: ST_TO_ADDR
// end ;
43701: GO 43585
43703: POP
43704: POP
// RaiseSailEvent ( 101 ) ;
43705: LD_INT 101
43707: PPUSH
43708: CALL_OW 427
// end ;
43712: LD_VAR 0 1
43716: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43717: LD_INT 0
43719: PPUSH
43720: PPUSH
43721: PPUSH
43722: PPUSH
43723: PPUSH
43724: PPUSH
43725: PPUSH
// if not mc_bases then
43726: LD_EXP 116
43730: NOT
43731: IFFALSE 43735
// exit ;
43733: GO 44297
// for i = 1 to mc_bases do
43735: LD_ADDR_VAR 0 2
43739: PUSH
43740: DOUBLE
43741: LD_INT 1
43743: DEC
43744: ST_TO_ADDR
43745: LD_EXP 116
43749: PUSH
43750: FOR_TO
43751: IFFALSE 44288
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43753: LD_ADDR_VAR 0 5
43757: PUSH
43758: LD_EXP 116
43762: PUSH
43763: LD_VAR 0 2
43767: ARRAY
43768: PUSH
43769: LD_EXP 145
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: UNION
43780: PPUSH
43781: LD_INT 21
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: PUSH
43794: LD_INT 3
43796: PUSH
43797: LD_INT 54
43799: PUSH
43800: EMPTY
43801: LIST
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: LD_INT 3
43809: PUSH
43810: LD_INT 24
43812: PUSH
43813: LD_INT 1000
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: LIST
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PPUSH
43833: CALL_OW 72
43837: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43838: LD_ADDR_VAR 0 6
43842: PUSH
43843: LD_EXP 116
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PPUSH
43854: LD_INT 21
43856: PUSH
43857: LD_INT 1
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 1
43866: PUSH
43867: LD_INT 3
43869: PUSH
43870: LD_INT 54
43872: PUSH
43873: EMPTY
43874: LIST
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 3
43882: PUSH
43883: LD_INT 24
43885: PUSH
43886: LD_INT 250
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: LIST
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PPUSH
43906: CALL_OW 72
43910: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43911: LD_ADDR_VAR 0 7
43915: PUSH
43916: LD_VAR 0 5
43920: PUSH
43921: LD_VAR 0 6
43925: DIFF
43926: ST_TO_ADDR
// if not need_heal_1 then
43927: LD_VAR 0 6
43931: NOT
43932: IFFALSE 43965
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43934: LD_ADDR_EXP 119
43938: PUSH
43939: LD_EXP 119
43943: PPUSH
43944: LD_VAR 0 2
43948: PUSH
43949: LD_INT 1
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PPUSH
43956: EMPTY
43957: PPUSH
43958: CALL 70700 0 3
43962: ST_TO_ADDR
43963: GO 44035
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43965: LD_ADDR_EXP 119
43969: PUSH
43970: LD_EXP 119
43974: PPUSH
43975: LD_VAR 0 2
43979: PUSH
43980: LD_INT 1
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PPUSH
43987: LD_EXP 119
43991: PUSH
43992: LD_VAR 0 2
43996: ARRAY
43997: PUSH
43998: LD_INT 1
44000: ARRAY
44001: PPUSH
44002: LD_INT 3
44004: PUSH
44005: LD_INT 24
44007: PUSH
44008: LD_INT 1000
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: PUSH
44024: LD_VAR 0 6
44028: UNION
44029: PPUSH
44030: CALL 70700 0 3
44034: ST_TO_ADDR
// if not need_heal_2 then
44035: LD_VAR 0 7
44039: NOT
44040: IFFALSE 44073
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44042: LD_ADDR_EXP 119
44046: PUSH
44047: LD_EXP 119
44051: PPUSH
44052: LD_VAR 0 2
44056: PUSH
44057: LD_INT 2
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PPUSH
44064: EMPTY
44065: PPUSH
44066: CALL 70700 0 3
44070: ST_TO_ADDR
44071: GO 44105
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44073: LD_ADDR_EXP 119
44077: PUSH
44078: LD_EXP 119
44082: PPUSH
44083: LD_VAR 0 2
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PPUSH
44095: LD_VAR 0 7
44099: PPUSH
44100: CALL 70700 0 3
44104: ST_TO_ADDR
// if need_heal_2 then
44105: LD_VAR 0 7
44109: IFFALSE 44270
// for j in need_heal_2 do
44111: LD_ADDR_VAR 0 3
44115: PUSH
44116: LD_VAR 0 7
44120: PUSH
44121: FOR_IN
44122: IFFALSE 44268
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44124: LD_ADDR_VAR 0 5
44128: PUSH
44129: LD_EXP 116
44133: PUSH
44134: LD_VAR 0 2
44138: ARRAY
44139: PPUSH
44140: LD_INT 2
44142: PUSH
44143: LD_INT 30
44145: PUSH
44146: LD_INT 6
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: PUSH
44153: LD_INT 30
44155: PUSH
44156: LD_INT 7
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 30
44165: PUSH
44166: LD_INT 8
44168: PUSH
44169: EMPTY
44170: LIST
44171: LIST
44172: PUSH
44173: LD_INT 30
44175: PUSH
44176: LD_INT 0
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PUSH
44183: LD_INT 30
44185: PUSH
44186: LD_INT 1
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: PPUSH
44201: CALL_OW 72
44205: ST_TO_ADDR
// if tmp then
44206: LD_VAR 0 5
44210: IFFALSE 44266
// begin k := NearestUnitToUnit ( tmp , j ) ;
44212: LD_ADDR_VAR 0 4
44216: PUSH
44217: LD_VAR 0 5
44221: PPUSH
44222: LD_VAR 0 3
44226: PPUSH
44227: CALL_OW 74
44231: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44232: LD_VAR 0 3
44236: PPUSH
44237: LD_VAR 0 4
44241: PPUSH
44242: CALL_OW 296
44246: PUSH
44247: LD_INT 5
44249: GREATER
44250: IFFALSE 44266
// ComMoveToNearbyEntrance ( j , k ) ;
44252: LD_VAR 0 3
44256: PPUSH
44257: LD_VAR 0 4
44261: PPUSH
44262: CALL 103318 0 2
// end ; end ;
44266: GO 44121
44268: POP
44269: POP
// if not need_heal_1 and not need_heal_2 then
44270: LD_VAR 0 6
44274: NOT
44275: PUSH
44276: LD_VAR 0 7
44280: NOT
44281: AND
44282: IFFALSE 44286
// continue ;
44284: GO 43750
// end ;
44286: GO 43750
44288: POP
44289: POP
// RaiseSailEvent ( 102 ) ;
44290: LD_INT 102
44292: PPUSH
44293: CALL_OW 427
// end ;
44297: LD_VAR 0 1
44301: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44302: LD_INT 0
44304: PPUSH
44305: PPUSH
44306: PPUSH
44307: PPUSH
44308: PPUSH
44309: PPUSH
44310: PPUSH
44311: PPUSH
// if not mc_bases then
44312: LD_EXP 116
44316: NOT
44317: IFFALSE 44321
// exit ;
44319: GO 45204
// for i = 1 to mc_bases do
44321: LD_ADDR_VAR 0 2
44325: PUSH
44326: DOUBLE
44327: LD_INT 1
44329: DEC
44330: ST_TO_ADDR
44331: LD_EXP 116
44335: PUSH
44336: FOR_TO
44337: IFFALSE 45202
// begin if not mc_building_need_repair [ i ] then
44339: LD_EXP 117
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: NOT
44350: IFFALSE 44537
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44352: LD_ADDR_VAR 0 6
44356: PUSH
44357: LD_EXP 135
44361: PUSH
44362: LD_VAR 0 2
44366: ARRAY
44367: PPUSH
44368: LD_INT 3
44370: PUSH
44371: LD_INT 24
44373: PUSH
44374: LD_INT 1000
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 2
44387: PUSH
44388: LD_INT 34
44390: PUSH
44391: LD_INT 13
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 34
44400: PUSH
44401: LD_INT 52
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: LD_INT 34
44410: PUSH
44411: LD_EXP 101
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PPUSH
44430: CALL_OW 72
44434: ST_TO_ADDR
// if cranes then
44435: LD_VAR 0 6
44439: IFFALSE 44501
// for j in cranes do
44441: LD_ADDR_VAR 0 3
44445: PUSH
44446: LD_VAR 0 6
44450: PUSH
44451: FOR_IN
44452: IFFALSE 44499
// if not IsInArea ( j , mc_parking [ i ] ) then
44454: LD_VAR 0 3
44458: PPUSH
44459: LD_EXP 140
44463: PUSH
44464: LD_VAR 0 2
44468: ARRAY
44469: PPUSH
44470: CALL_OW 308
44474: NOT
44475: IFFALSE 44497
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44477: LD_VAR 0 3
44481: PPUSH
44482: LD_EXP 140
44486: PUSH
44487: LD_VAR 0 2
44491: ARRAY
44492: PPUSH
44493: CALL_OW 113
44497: GO 44451
44499: POP
44500: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44501: LD_ADDR_EXP 118
44505: PUSH
44506: LD_EXP 118
44510: PPUSH
44511: LD_VAR 0 2
44515: PPUSH
44516: EMPTY
44517: PPUSH
44518: CALL_OW 1
44522: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44523: LD_VAR 0 2
44527: PPUSH
44528: LD_INT 101
44530: PPUSH
44531: CALL 39389 0 2
// continue ;
44535: GO 44336
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44537: LD_ADDR_EXP 122
44541: PUSH
44542: LD_EXP 122
44546: PPUSH
44547: LD_VAR 0 2
44551: PPUSH
44552: EMPTY
44553: PPUSH
44554: CALL_OW 1
44558: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44559: LD_VAR 0 2
44563: PPUSH
44564: LD_INT 103
44566: PPUSH
44567: CALL 39389 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44571: LD_ADDR_VAR 0 5
44575: PUSH
44576: LD_EXP 116
44580: PUSH
44581: LD_VAR 0 2
44585: ARRAY
44586: PUSH
44587: LD_EXP 145
44591: PUSH
44592: LD_VAR 0 2
44596: ARRAY
44597: UNION
44598: PPUSH
44599: LD_INT 2
44601: PUSH
44602: LD_INT 25
44604: PUSH
44605: LD_INT 2
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 25
44614: PUSH
44615: LD_INT 16
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: LIST
44626: PUSH
44627: EMPTY
44628: LIST
44629: PPUSH
44630: CALL_OW 72
44634: ST_TO_ADDR
// if mc_need_heal [ i ] then
44635: LD_EXP 119
44639: PUSH
44640: LD_VAR 0 2
44644: ARRAY
44645: IFFALSE 44689
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44647: LD_ADDR_VAR 0 5
44651: PUSH
44652: LD_VAR 0 5
44656: PUSH
44657: LD_EXP 119
44661: PUSH
44662: LD_VAR 0 2
44666: ARRAY
44667: PUSH
44668: LD_INT 1
44670: ARRAY
44671: PUSH
44672: LD_EXP 119
44676: PUSH
44677: LD_VAR 0 2
44681: ARRAY
44682: PUSH
44683: LD_INT 2
44685: ARRAY
44686: UNION
44687: DIFF
44688: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44689: LD_ADDR_VAR 0 6
44693: PUSH
44694: LD_EXP 135
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: PPUSH
44705: LD_INT 2
44707: PUSH
44708: LD_INT 34
44710: PUSH
44711: LD_INT 13
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 34
44720: PUSH
44721: LD_INT 52
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 34
44730: PUSH
44731: LD_EXP 101
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: PPUSH
44746: CALL_OW 72
44750: ST_TO_ADDR
// if cranes then
44751: LD_VAR 0 6
44755: IFFALSE 44891
// begin for j in cranes do
44757: LD_ADDR_VAR 0 3
44761: PUSH
44762: LD_VAR 0 6
44766: PUSH
44767: FOR_IN
44768: IFFALSE 44889
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44770: LD_VAR 0 3
44774: PPUSH
44775: CALL_OW 256
44779: PUSH
44780: LD_INT 1000
44782: EQUAL
44783: PUSH
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL_OW 314
44793: NOT
44794: AND
44795: IFFALSE 44829
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44797: LD_VAR 0 3
44801: PPUSH
44802: LD_EXP 117
44806: PUSH
44807: LD_VAR 0 2
44811: ARRAY
44812: PPUSH
44813: LD_VAR 0 3
44817: PPUSH
44818: CALL_OW 74
44822: PPUSH
44823: CALL_OW 130
44827: GO 44887
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44829: LD_VAR 0 3
44833: PPUSH
44834: CALL_OW 256
44838: PUSH
44839: LD_INT 500
44841: LESS
44842: PUSH
44843: LD_VAR 0 3
44847: PPUSH
44848: LD_EXP 140
44852: PUSH
44853: LD_VAR 0 2
44857: ARRAY
44858: PPUSH
44859: CALL_OW 308
44863: NOT
44864: AND
44865: IFFALSE 44887
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44867: LD_VAR 0 3
44871: PPUSH
44872: LD_EXP 140
44876: PUSH
44877: LD_VAR 0 2
44881: ARRAY
44882: PPUSH
44883: CALL_OW 113
// end ;
44887: GO 44767
44889: POP
44890: POP
// end ; if tmp > 3 then
44891: LD_VAR 0 5
44895: PUSH
44896: LD_INT 3
44898: GREATER
44899: IFFALSE 44919
// tmp := ShrinkArray ( tmp , 4 ) ;
44901: LD_ADDR_VAR 0 5
44905: PUSH
44906: LD_VAR 0 5
44910: PPUSH
44911: LD_INT 4
44913: PPUSH
44914: CALL 102766 0 2
44918: ST_TO_ADDR
// if not tmp then
44919: LD_VAR 0 5
44923: NOT
44924: IFFALSE 44928
// continue ;
44926: GO 44336
// for j in tmp do
44928: LD_ADDR_VAR 0 3
44932: PUSH
44933: LD_VAR 0 5
44937: PUSH
44938: FOR_IN
44939: IFFALSE 45198
// begin if IsInUnit ( j ) then
44941: LD_VAR 0 3
44945: PPUSH
44946: CALL_OW 310
44950: IFFALSE 44961
// ComExitBuilding ( j ) ;
44952: LD_VAR 0 3
44956: PPUSH
44957: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44961: LD_VAR 0 3
44965: PUSH
44966: LD_EXP 118
44970: PUSH
44971: LD_VAR 0 2
44975: ARRAY
44976: IN
44977: NOT
44978: IFFALSE 45036
// begin SetTag ( j , 101 ) ;
44980: LD_VAR 0 3
44984: PPUSH
44985: LD_INT 101
44987: PPUSH
44988: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44992: LD_ADDR_EXP 118
44996: PUSH
44997: LD_EXP 118
45001: PPUSH
45002: LD_VAR 0 2
45006: PUSH
45007: LD_EXP 118
45011: PUSH
45012: LD_VAR 0 2
45016: ARRAY
45017: PUSH
45018: LD_INT 1
45020: PLUS
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PPUSH
45026: LD_VAR 0 3
45030: PPUSH
45031: CALL 70700 0 3
45035: ST_TO_ADDR
// end ; wait ( 1 ) ;
45036: LD_INT 1
45038: PPUSH
45039: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45043: LD_ADDR_VAR 0 7
45047: PUSH
45048: LD_EXP 117
45052: PUSH
45053: LD_VAR 0 2
45057: ARRAY
45058: ST_TO_ADDR
// if mc_scan [ i ] then
45059: LD_EXP 139
45063: PUSH
45064: LD_VAR 0 2
45068: ARRAY
45069: IFFALSE 45131
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45071: LD_ADDR_VAR 0 7
45075: PUSH
45076: LD_EXP 117
45080: PUSH
45081: LD_VAR 0 2
45085: ARRAY
45086: PPUSH
45087: LD_INT 3
45089: PUSH
45090: LD_INT 30
45092: PUSH
45093: LD_INT 32
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: LD_INT 30
45102: PUSH
45103: LD_INT 33
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 30
45112: PUSH
45113: LD_INT 31
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: PPUSH
45126: CALL_OW 72
45130: ST_TO_ADDR
// if not to_repair_tmp then
45131: LD_VAR 0 7
45135: NOT
45136: IFFALSE 45140
// continue ;
45138: GO 44938
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45140: LD_ADDR_VAR 0 8
45144: PUSH
45145: LD_VAR 0 7
45149: PPUSH
45150: LD_VAR 0 3
45154: PPUSH
45155: CALL_OW 74
45159: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45160: LD_VAR 0 8
45164: PPUSH
45165: LD_INT 16
45167: PPUSH
45168: CALL 73299 0 2
45172: PUSH
45173: LD_INT 4
45175: ARRAY
45176: PUSH
45177: LD_INT 10
45179: LESS
45180: IFFALSE 45196
// ComRepairBuilding ( j , to_repair ) ;
45182: LD_VAR 0 3
45186: PPUSH
45187: LD_VAR 0 8
45191: PPUSH
45192: CALL_OW 130
// end ;
45196: GO 44938
45198: POP
45199: POP
// end ;
45200: GO 44336
45202: POP
45203: POP
// end ;
45204: LD_VAR 0 1
45208: RET
// export function MC_Heal ; var i , j , tmp ; begin
45209: LD_INT 0
45211: PPUSH
45212: PPUSH
45213: PPUSH
45214: PPUSH
// if not mc_bases then
45215: LD_EXP 116
45219: NOT
45220: IFFALSE 45224
// exit ;
45222: GO 45626
// for i = 1 to mc_bases do
45224: LD_ADDR_VAR 0 2
45228: PUSH
45229: DOUBLE
45230: LD_INT 1
45232: DEC
45233: ST_TO_ADDR
45234: LD_EXP 116
45238: PUSH
45239: FOR_TO
45240: IFFALSE 45624
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45242: LD_EXP 119
45246: PUSH
45247: LD_VAR 0 2
45251: ARRAY
45252: PUSH
45253: LD_INT 1
45255: ARRAY
45256: NOT
45257: PUSH
45258: LD_EXP 119
45262: PUSH
45263: LD_VAR 0 2
45267: ARRAY
45268: PUSH
45269: LD_INT 2
45271: ARRAY
45272: NOT
45273: AND
45274: IFFALSE 45312
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45276: LD_ADDR_EXP 120
45280: PUSH
45281: LD_EXP 120
45285: PPUSH
45286: LD_VAR 0 2
45290: PPUSH
45291: EMPTY
45292: PPUSH
45293: CALL_OW 1
45297: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45298: LD_VAR 0 2
45302: PPUSH
45303: LD_INT 102
45305: PPUSH
45306: CALL 39389 0 2
// continue ;
45310: GO 45239
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45312: LD_ADDR_VAR 0 4
45316: PUSH
45317: LD_EXP 116
45321: PUSH
45322: LD_VAR 0 2
45326: ARRAY
45327: PPUSH
45328: LD_INT 25
45330: PUSH
45331: LD_INT 4
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: PPUSH
45338: CALL_OW 72
45342: ST_TO_ADDR
// if not tmp then
45343: LD_VAR 0 4
45347: NOT
45348: IFFALSE 45352
// continue ;
45350: GO 45239
// if mc_taming [ i ] then
45352: LD_EXP 147
45356: PUSH
45357: LD_VAR 0 2
45361: ARRAY
45362: IFFALSE 45386
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45364: LD_ADDR_EXP 147
45368: PUSH
45369: LD_EXP 147
45373: PPUSH
45374: LD_VAR 0 2
45378: PPUSH
45379: EMPTY
45380: PPUSH
45381: CALL_OW 1
45385: ST_TO_ADDR
// for j in tmp do
45386: LD_ADDR_VAR 0 3
45390: PUSH
45391: LD_VAR 0 4
45395: PUSH
45396: FOR_IN
45397: IFFALSE 45620
// begin if IsInUnit ( j ) then
45399: LD_VAR 0 3
45403: PPUSH
45404: CALL_OW 310
45408: IFFALSE 45419
// ComExitBuilding ( j ) ;
45410: LD_VAR 0 3
45414: PPUSH
45415: CALL_OW 122
// if not j in mc_healers [ i ] then
45419: LD_VAR 0 3
45423: PUSH
45424: LD_EXP 120
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: IN
45435: NOT
45436: IFFALSE 45482
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45438: LD_ADDR_EXP 120
45442: PUSH
45443: LD_EXP 120
45447: PPUSH
45448: LD_VAR 0 2
45452: PUSH
45453: LD_EXP 120
45457: PUSH
45458: LD_VAR 0 2
45462: ARRAY
45463: PUSH
45464: LD_INT 1
45466: PLUS
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PPUSH
45472: LD_VAR 0 3
45476: PPUSH
45477: CALL 70700 0 3
45481: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45482: LD_VAR 0 3
45486: PPUSH
45487: CALL_OW 110
45491: PUSH
45492: LD_INT 102
45494: NONEQUAL
45495: IFFALSE 45509
// SetTag ( j , 102 ) ;
45497: LD_VAR 0 3
45501: PPUSH
45502: LD_INT 102
45504: PPUSH
45505: CALL_OW 109
// Wait ( 3 ) ;
45509: LD_INT 3
45511: PPUSH
45512: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45516: LD_EXP 119
45520: PUSH
45521: LD_VAR 0 2
45525: ARRAY
45526: PUSH
45527: LD_INT 1
45529: ARRAY
45530: IFFALSE 45562
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45532: LD_VAR 0 3
45536: PPUSH
45537: LD_EXP 119
45541: PUSH
45542: LD_VAR 0 2
45546: ARRAY
45547: PUSH
45548: LD_INT 1
45550: ARRAY
45551: PUSH
45552: LD_INT 1
45554: ARRAY
45555: PPUSH
45556: CALL_OW 128
45560: GO 45618
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45562: LD_VAR 0 3
45566: PPUSH
45567: CALL_OW 314
45571: NOT
45572: PUSH
45573: LD_EXP 119
45577: PUSH
45578: LD_VAR 0 2
45582: ARRAY
45583: PUSH
45584: LD_INT 2
45586: ARRAY
45587: AND
45588: IFFALSE 45618
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45590: LD_VAR 0 3
45594: PPUSH
45595: LD_EXP 119
45599: PUSH
45600: LD_VAR 0 2
45604: ARRAY
45605: PUSH
45606: LD_INT 2
45608: ARRAY
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: CALL_OW 128
// end ;
45618: GO 45396
45620: POP
45621: POP
// end ;
45622: GO 45239
45624: POP
45625: POP
// end ;
45626: LD_VAR 0 1
45630: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45631: LD_INT 0
45633: PPUSH
45634: PPUSH
45635: PPUSH
45636: PPUSH
45637: PPUSH
// if not mc_bases then
45638: LD_EXP 116
45642: NOT
45643: IFFALSE 45647
// exit ;
45645: GO 46818
// for i = 1 to mc_bases do
45647: LD_ADDR_VAR 0 2
45651: PUSH
45652: DOUBLE
45653: LD_INT 1
45655: DEC
45656: ST_TO_ADDR
45657: LD_EXP 116
45661: PUSH
45662: FOR_TO
45663: IFFALSE 46816
// begin if mc_scan [ i ] then
45665: LD_EXP 139
45669: PUSH
45670: LD_VAR 0 2
45674: ARRAY
45675: IFFALSE 45679
// continue ;
45677: GO 45662
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45679: LD_EXP 121
45683: PUSH
45684: LD_VAR 0 2
45688: ARRAY
45689: NOT
45690: PUSH
45691: LD_EXP 123
45695: PUSH
45696: LD_VAR 0 2
45700: ARRAY
45701: NOT
45702: AND
45703: PUSH
45704: LD_EXP 122
45708: PUSH
45709: LD_VAR 0 2
45713: ARRAY
45714: AND
45715: IFFALSE 45753
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45717: LD_ADDR_EXP 122
45721: PUSH
45722: LD_EXP 122
45726: PPUSH
45727: LD_VAR 0 2
45731: PPUSH
45732: EMPTY
45733: PPUSH
45734: CALL_OW 1
45738: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45739: LD_VAR 0 2
45743: PPUSH
45744: LD_INT 103
45746: PPUSH
45747: CALL 39389 0 2
// continue ;
45751: GO 45662
// end ; if mc_construct_list [ i ] then
45753: LD_EXP 123
45757: PUSH
45758: LD_VAR 0 2
45762: ARRAY
45763: IFFALSE 45983
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45765: LD_ADDR_VAR 0 4
45769: PUSH
45770: LD_EXP 116
45774: PUSH
45775: LD_VAR 0 2
45779: ARRAY
45780: PPUSH
45781: LD_INT 25
45783: PUSH
45784: LD_INT 2
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PPUSH
45791: CALL_OW 72
45795: PUSH
45796: LD_EXP 118
45800: PUSH
45801: LD_VAR 0 2
45805: ARRAY
45806: DIFF
45807: ST_TO_ADDR
// if not tmp then
45808: LD_VAR 0 4
45812: NOT
45813: IFFALSE 45817
// continue ;
45815: GO 45662
// for j in tmp do
45817: LD_ADDR_VAR 0 3
45821: PUSH
45822: LD_VAR 0 4
45826: PUSH
45827: FOR_IN
45828: IFFALSE 45979
// begin if not mc_builders [ i ] then
45830: LD_EXP 122
45834: PUSH
45835: LD_VAR 0 2
45839: ARRAY
45840: NOT
45841: IFFALSE 45899
// begin SetTag ( j , 103 ) ;
45843: LD_VAR 0 3
45847: PPUSH
45848: LD_INT 103
45850: PPUSH
45851: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45855: LD_ADDR_EXP 122
45859: PUSH
45860: LD_EXP 122
45864: PPUSH
45865: LD_VAR 0 2
45869: PUSH
45870: LD_EXP 122
45874: PUSH
45875: LD_VAR 0 2
45879: ARRAY
45880: PUSH
45881: LD_INT 1
45883: PLUS
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PPUSH
45889: LD_VAR 0 3
45893: PPUSH
45894: CALL 70700 0 3
45898: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45899: LD_VAR 0 3
45903: PPUSH
45904: CALL_OW 310
45908: IFFALSE 45919
// ComExitBuilding ( j ) ;
45910: LD_VAR 0 3
45914: PPUSH
45915: CALL_OW 122
// wait ( 3 ) ;
45919: LD_INT 3
45921: PPUSH
45922: CALL_OW 67
// if not mc_construct_list [ i ] then
45926: LD_EXP 123
45930: PUSH
45931: LD_VAR 0 2
45935: ARRAY
45936: NOT
45937: IFFALSE 45941
// break ;
45939: GO 45979
// if not HasTask ( j ) then
45941: LD_VAR 0 3
45945: PPUSH
45946: CALL_OW 314
45950: NOT
45951: IFFALSE 45977
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45953: LD_VAR 0 3
45957: PPUSH
45958: LD_EXP 123
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: PUSH
45969: LD_INT 1
45971: ARRAY
45972: PPUSH
45973: CALL 73563 0 2
// end ;
45977: GO 45827
45979: POP
45980: POP
// end else
45981: GO 46814
// if mc_build_list [ i ] then
45983: LD_EXP 121
45987: PUSH
45988: LD_VAR 0 2
45992: ARRAY
45993: IFFALSE 46814
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45995: LD_ADDR_VAR 0 5
45999: PUSH
46000: LD_EXP 116
46004: PUSH
46005: LD_VAR 0 2
46009: ARRAY
46010: PPUSH
46011: LD_INT 2
46013: PUSH
46014: LD_INT 30
46016: PUSH
46017: LD_INT 0
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 30
46026: PUSH
46027: LD_INT 1
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: LIST
46038: PPUSH
46039: CALL_OW 72
46043: ST_TO_ADDR
// if depot then
46044: LD_VAR 0 5
46048: IFFALSE 46066
// depot := depot [ 1 ] else
46050: LD_ADDR_VAR 0 5
46054: PUSH
46055: LD_VAR 0 5
46059: PUSH
46060: LD_INT 1
46062: ARRAY
46063: ST_TO_ADDR
46064: GO 46074
// depot := 0 ;
46066: LD_ADDR_VAR 0 5
46070: PUSH
46071: LD_INT 0
46073: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46074: LD_EXP 121
46078: PUSH
46079: LD_VAR 0 2
46083: ARRAY
46084: PUSH
46085: LD_INT 1
46087: ARRAY
46088: PUSH
46089: LD_INT 1
46091: ARRAY
46092: PPUSH
46093: CALL 73387 0 1
46097: PUSH
46098: LD_EXP 116
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PPUSH
46109: LD_INT 2
46111: PUSH
46112: LD_INT 30
46114: PUSH
46115: LD_INT 2
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 30
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: EMPTY
46129: LIST
46130: LIST
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: LIST
46136: PPUSH
46137: CALL_OW 72
46141: NOT
46142: AND
46143: IFFALSE 46248
// begin for j = 1 to mc_build_list [ i ] do
46145: LD_ADDR_VAR 0 3
46149: PUSH
46150: DOUBLE
46151: LD_INT 1
46153: DEC
46154: ST_TO_ADDR
46155: LD_EXP 121
46159: PUSH
46160: LD_VAR 0 2
46164: ARRAY
46165: PUSH
46166: FOR_TO
46167: IFFALSE 46246
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46169: LD_EXP 121
46173: PUSH
46174: LD_VAR 0 2
46178: ARRAY
46179: PUSH
46180: LD_VAR 0 3
46184: ARRAY
46185: PUSH
46186: LD_INT 1
46188: ARRAY
46189: PUSH
46190: LD_INT 2
46192: EQUAL
46193: IFFALSE 46244
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46195: LD_ADDR_EXP 121
46199: PUSH
46200: LD_EXP 121
46204: PPUSH
46205: LD_VAR 0 2
46209: PPUSH
46210: LD_EXP 121
46214: PUSH
46215: LD_VAR 0 2
46219: ARRAY
46220: PPUSH
46221: LD_VAR 0 3
46225: PPUSH
46226: LD_INT 1
46228: PPUSH
46229: LD_INT 0
46231: PPUSH
46232: CALL 70118 0 4
46236: PPUSH
46237: CALL_OW 1
46241: ST_TO_ADDR
// break ;
46242: GO 46246
// end ;
46244: GO 46166
46246: POP
46247: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46248: LD_EXP 121
46252: PUSH
46253: LD_VAR 0 2
46257: ARRAY
46258: PUSH
46259: LD_INT 1
46261: ARRAY
46262: PUSH
46263: LD_INT 1
46265: ARRAY
46266: PUSH
46267: LD_INT 0
46269: EQUAL
46270: PUSH
46271: LD_VAR 0 5
46275: PUSH
46276: LD_VAR 0 5
46280: PPUSH
46281: LD_EXP 121
46285: PUSH
46286: LD_VAR 0 2
46290: ARRAY
46291: PUSH
46292: LD_INT 1
46294: ARRAY
46295: PUSH
46296: LD_INT 1
46298: ARRAY
46299: PPUSH
46300: LD_EXP 121
46304: PUSH
46305: LD_VAR 0 2
46309: ARRAY
46310: PUSH
46311: LD_INT 1
46313: ARRAY
46314: PUSH
46315: LD_INT 2
46317: ARRAY
46318: PPUSH
46319: LD_EXP 121
46323: PUSH
46324: LD_VAR 0 2
46328: ARRAY
46329: PUSH
46330: LD_INT 1
46332: ARRAY
46333: PUSH
46334: LD_INT 3
46336: ARRAY
46337: PPUSH
46338: LD_EXP 121
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: PUSH
46349: LD_INT 1
46351: ARRAY
46352: PUSH
46353: LD_INT 4
46355: ARRAY
46356: PPUSH
46357: CALL 78803 0 5
46361: AND
46362: OR
46363: IFFALSE 46644
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46365: LD_ADDR_VAR 0 4
46369: PUSH
46370: LD_EXP 116
46374: PUSH
46375: LD_VAR 0 2
46379: ARRAY
46380: PPUSH
46381: LD_INT 25
46383: PUSH
46384: LD_INT 2
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PPUSH
46391: CALL_OW 72
46395: PUSH
46396: LD_EXP 118
46400: PUSH
46401: LD_VAR 0 2
46405: ARRAY
46406: DIFF
46407: ST_TO_ADDR
// if not tmp then
46408: LD_VAR 0 4
46412: NOT
46413: IFFALSE 46417
// continue ;
46415: GO 45662
// for j in tmp do
46417: LD_ADDR_VAR 0 3
46421: PUSH
46422: LD_VAR 0 4
46426: PUSH
46427: FOR_IN
46428: IFFALSE 46640
// begin if not mc_builders [ i ] then
46430: LD_EXP 122
46434: PUSH
46435: LD_VAR 0 2
46439: ARRAY
46440: NOT
46441: IFFALSE 46499
// begin SetTag ( j , 103 ) ;
46443: LD_VAR 0 3
46447: PPUSH
46448: LD_INT 103
46450: PPUSH
46451: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46455: LD_ADDR_EXP 122
46459: PUSH
46460: LD_EXP 122
46464: PPUSH
46465: LD_VAR 0 2
46469: PUSH
46470: LD_EXP 122
46474: PUSH
46475: LD_VAR 0 2
46479: ARRAY
46480: PUSH
46481: LD_INT 1
46483: PLUS
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PPUSH
46489: LD_VAR 0 3
46493: PPUSH
46494: CALL 70700 0 3
46498: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46499: LD_VAR 0 3
46503: PPUSH
46504: CALL_OW 310
46508: IFFALSE 46519
// ComExitBuilding ( j ) ;
46510: LD_VAR 0 3
46514: PPUSH
46515: CALL_OW 122
// wait ( 3 ) ;
46519: LD_INT 3
46521: PPUSH
46522: CALL_OW 67
// if not mc_build_list [ i ] then
46526: LD_EXP 121
46530: PUSH
46531: LD_VAR 0 2
46535: ARRAY
46536: NOT
46537: IFFALSE 46541
// break ;
46539: GO 46640
// if not HasTask ( j ) then
46541: LD_VAR 0 3
46545: PPUSH
46546: CALL_OW 314
46550: NOT
46551: IFFALSE 46638
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46553: LD_VAR 0 3
46557: PPUSH
46558: LD_EXP 121
46562: PUSH
46563: LD_VAR 0 2
46567: ARRAY
46568: PUSH
46569: LD_INT 1
46571: ARRAY
46572: PUSH
46573: LD_INT 1
46575: ARRAY
46576: PPUSH
46577: LD_EXP 121
46581: PUSH
46582: LD_VAR 0 2
46586: ARRAY
46587: PUSH
46588: LD_INT 1
46590: ARRAY
46591: PUSH
46592: LD_INT 2
46594: ARRAY
46595: PPUSH
46596: LD_EXP 121
46600: PUSH
46601: LD_VAR 0 2
46605: ARRAY
46606: PUSH
46607: LD_INT 1
46609: ARRAY
46610: PUSH
46611: LD_INT 3
46613: ARRAY
46614: PPUSH
46615: LD_EXP 121
46619: PUSH
46620: LD_VAR 0 2
46624: ARRAY
46625: PUSH
46626: LD_INT 1
46628: ARRAY
46629: PUSH
46630: LD_INT 4
46632: ARRAY
46633: PPUSH
46634: CALL_OW 145
// end ;
46638: GO 46427
46640: POP
46641: POP
// end else
46642: GO 46814
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46644: LD_EXP 116
46648: PUSH
46649: LD_VAR 0 2
46653: ARRAY
46654: PPUSH
46655: LD_EXP 121
46659: PUSH
46660: LD_VAR 0 2
46664: ARRAY
46665: PUSH
46666: LD_INT 1
46668: ARRAY
46669: PUSH
46670: LD_INT 1
46672: ARRAY
46673: PPUSH
46674: LD_EXP 121
46678: PUSH
46679: LD_VAR 0 2
46683: ARRAY
46684: PUSH
46685: LD_INT 1
46687: ARRAY
46688: PUSH
46689: LD_INT 2
46691: ARRAY
46692: PPUSH
46693: LD_EXP 121
46697: PUSH
46698: LD_VAR 0 2
46702: ARRAY
46703: PUSH
46704: LD_INT 1
46706: ARRAY
46707: PUSH
46708: LD_INT 3
46710: ARRAY
46711: PPUSH
46712: LD_EXP 121
46716: PUSH
46717: LD_VAR 0 2
46721: ARRAY
46722: PUSH
46723: LD_INT 1
46725: ARRAY
46726: PUSH
46727: LD_INT 4
46729: ARRAY
46730: PPUSH
46731: LD_EXP 116
46735: PUSH
46736: LD_VAR 0 2
46740: ARRAY
46741: PPUSH
46742: LD_INT 21
46744: PUSH
46745: LD_INT 3
46747: PUSH
46748: EMPTY
46749: LIST
46750: LIST
46751: PPUSH
46752: CALL_OW 72
46756: PPUSH
46757: EMPTY
46758: PPUSH
46759: CALL 77553 0 7
46763: NOT
46764: IFFALSE 46814
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46766: LD_ADDR_EXP 121
46770: PUSH
46771: LD_EXP 121
46775: PPUSH
46776: LD_VAR 0 2
46780: PPUSH
46781: LD_EXP 121
46785: PUSH
46786: LD_VAR 0 2
46790: ARRAY
46791: PPUSH
46792: LD_INT 1
46794: PPUSH
46795: LD_INT 1
46797: NEG
46798: PPUSH
46799: LD_INT 0
46801: PPUSH
46802: CALL 70118 0 4
46806: PPUSH
46807: CALL_OW 1
46811: ST_TO_ADDR
// continue ;
46812: GO 45662
// end ; end ; end ;
46814: GO 45662
46816: POP
46817: POP
// end ;
46818: LD_VAR 0 1
46822: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46823: LD_INT 0
46825: PPUSH
46826: PPUSH
46827: PPUSH
46828: PPUSH
46829: PPUSH
46830: PPUSH
// if not mc_bases then
46831: LD_EXP 116
46835: NOT
46836: IFFALSE 46840
// exit ;
46838: GO 47267
// for i = 1 to mc_bases do
46840: LD_ADDR_VAR 0 2
46844: PUSH
46845: DOUBLE
46846: LD_INT 1
46848: DEC
46849: ST_TO_ADDR
46850: LD_EXP 116
46854: PUSH
46855: FOR_TO
46856: IFFALSE 47265
// begin tmp := mc_build_upgrade [ i ] ;
46858: LD_ADDR_VAR 0 4
46862: PUSH
46863: LD_EXP 148
46867: PUSH
46868: LD_VAR 0 2
46872: ARRAY
46873: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46874: LD_ADDR_VAR 0 6
46878: PUSH
46879: LD_EXP 149
46883: PUSH
46884: LD_VAR 0 2
46888: ARRAY
46889: PPUSH
46890: LD_INT 2
46892: PUSH
46893: LD_INT 30
46895: PUSH
46896: LD_INT 6
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 30
46905: PUSH
46906: LD_INT 7
46908: PUSH
46909: EMPTY
46910: LIST
46911: LIST
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: LIST
46917: PPUSH
46918: CALL_OW 72
46922: ST_TO_ADDR
// if not tmp and not lab then
46923: LD_VAR 0 4
46927: NOT
46928: PUSH
46929: LD_VAR 0 6
46933: NOT
46934: AND
46935: IFFALSE 46939
// continue ;
46937: GO 46855
// if tmp then
46939: LD_VAR 0 4
46943: IFFALSE 47063
// for j in tmp do
46945: LD_ADDR_VAR 0 3
46949: PUSH
46950: LD_VAR 0 4
46954: PUSH
46955: FOR_IN
46956: IFFALSE 47061
// begin if UpgradeCost ( j ) then
46958: LD_VAR 0 3
46962: PPUSH
46963: CALL 77213 0 1
46967: IFFALSE 47059
// begin ComUpgrade ( j ) ;
46969: LD_VAR 0 3
46973: PPUSH
46974: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46978: LD_ADDR_EXP 148
46982: PUSH
46983: LD_EXP 148
46987: PPUSH
46988: LD_VAR 0 2
46992: PPUSH
46993: LD_EXP 148
46997: PUSH
46998: LD_VAR 0 2
47002: ARRAY
47003: PUSH
47004: LD_VAR 0 3
47008: DIFF
47009: PPUSH
47010: CALL_OW 1
47014: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47015: LD_ADDR_EXP 123
47019: PUSH
47020: LD_EXP 123
47024: PPUSH
47025: LD_VAR 0 2
47029: PUSH
47030: LD_EXP 123
47034: PUSH
47035: LD_VAR 0 2
47039: ARRAY
47040: PUSH
47041: LD_INT 1
47043: PLUS
47044: PUSH
47045: EMPTY
47046: LIST
47047: LIST
47048: PPUSH
47049: LD_VAR 0 3
47053: PPUSH
47054: CALL 70700 0 3
47058: ST_TO_ADDR
// end ; end ;
47059: GO 46955
47061: POP
47062: POP
// if not lab or not mc_lab_upgrade [ i ] then
47063: LD_VAR 0 6
47067: NOT
47068: PUSH
47069: LD_EXP 150
47073: PUSH
47074: LD_VAR 0 2
47078: ARRAY
47079: NOT
47080: OR
47081: IFFALSE 47085
// continue ;
47083: GO 46855
// for j in lab do
47085: LD_ADDR_VAR 0 3
47089: PUSH
47090: LD_VAR 0 6
47094: PUSH
47095: FOR_IN
47096: IFFALSE 47261
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47098: LD_VAR 0 3
47102: PPUSH
47103: CALL_OW 266
47107: PUSH
47108: LD_INT 6
47110: PUSH
47111: LD_INT 7
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: IN
47118: PUSH
47119: LD_VAR 0 3
47123: PPUSH
47124: CALL_OW 461
47128: PUSH
47129: LD_INT 1
47131: NONEQUAL
47132: AND
47133: IFFALSE 47259
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47135: LD_VAR 0 3
47139: PPUSH
47140: LD_EXP 150
47144: PUSH
47145: LD_VAR 0 2
47149: ARRAY
47150: PUSH
47151: LD_INT 1
47153: ARRAY
47154: PPUSH
47155: CALL 77418 0 2
47159: IFFALSE 47259
// begin ComCancel ( j ) ;
47161: LD_VAR 0 3
47165: PPUSH
47166: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47170: LD_VAR 0 3
47174: PPUSH
47175: LD_EXP 150
47179: PUSH
47180: LD_VAR 0 2
47184: ARRAY
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: PPUSH
47190: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47194: LD_VAR 0 3
47198: PUSH
47199: LD_EXP 123
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: IN
47210: NOT
47211: IFFALSE 47257
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47213: LD_ADDR_EXP 123
47217: PUSH
47218: LD_EXP 123
47222: PPUSH
47223: LD_VAR 0 2
47227: PUSH
47228: LD_EXP 123
47232: PUSH
47233: LD_VAR 0 2
47237: ARRAY
47238: PUSH
47239: LD_INT 1
47241: PLUS
47242: PUSH
47243: EMPTY
47244: LIST
47245: LIST
47246: PPUSH
47247: LD_VAR 0 3
47251: PPUSH
47252: CALL 70700 0 3
47256: ST_TO_ADDR
// break ;
47257: GO 47261
// end ; end ; end ;
47259: GO 47095
47261: POP
47262: POP
// end ;
47263: GO 46855
47265: POP
47266: POP
// end ;
47267: LD_VAR 0 1
47271: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47272: LD_INT 0
47274: PPUSH
47275: PPUSH
47276: PPUSH
47277: PPUSH
47278: PPUSH
47279: PPUSH
47280: PPUSH
47281: PPUSH
47282: PPUSH
// if not mc_bases then
47283: LD_EXP 116
47287: NOT
47288: IFFALSE 47292
// exit ;
47290: GO 47697
// for i = 1 to mc_bases do
47292: LD_ADDR_VAR 0 2
47296: PUSH
47297: DOUBLE
47298: LD_INT 1
47300: DEC
47301: ST_TO_ADDR
47302: LD_EXP 116
47306: PUSH
47307: FOR_TO
47308: IFFALSE 47695
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47310: LD_EXP 124
47314: PUSH
47315: LD_VAR 0 2
47319: ARRAY
47320: NOT
47321: PUSH
47322: LD_EXP 116
47326: PUSH
47327: LD_VAR 0 2
47331: ARRAY
47332: PPUSH
47333: LD_INT 30
47335: PUSH
47336: LD_INT 3
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PPUSH
47343: CALL_OW 72
47347: NOT
47348: OR
47349: IFFALSE 47353
// continue ;
47351: GO 47307
// busy := false ;
47353: LD_ADDR_VAR 0 8
47357: PUSH
47358: LD_INT 0
47360: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47361: LD_ADDR_VAR 0 4
47365: PUSH
47366: LD_EXP 116
47370: PUSH
47371: LD_VAR 0 2
47375: ARRAY
47376: PPUSH
47377: LD_INT 30
47379: PUSH
47380: LD_INT 3
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PPUSH
47387: CALL_OW 72
47391: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47392: LD_ADDR_VAR 0 6
47396: PUSH
47397: LD_EXP 124
47401: PUSH
47402: LD_VAR 0 2
47406: ARRAY
47407: PPUSH
47408: LD_INT 2
47410: PUSH
47411: LD_INT 30
47413: PUSH
47414: LD_INT 32
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: LD_INT 30
47423: PUSH
47424: LD_INT 33
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: PUSH
47431: EMPTY
47432: LIST
47433: LIST
47434: LIST
47435: PPUSH
47436: CALL_OW 72
47440: ST_TO_ADDR
// if not t then
47441: LD_VAR 0 6
47445: NOT
47446: IFFALSE 47450
// continue ;
47448: GO 47307
// for j in tmp do
47450: LD_ADDR_VAR 0 3
47454: PUSH
47455: LD_VAR 0 4
47459: PUSH
47460: FOR_IN
47461: IFFALSE 47491
// if not BuildingStatus ( j ) = bs_idle then
47463: LD_VAR 0 3
47467: PPUSH
47468: CALL_OW 461
47472: PUSH
47473: LD_INT 2
47475: EQUAL
47476: NOT
47477: IFFALSE 47489
// begin busy := true ;
47479: LD_ADDR_VAR 0 8
47483: PUSH
47484: LD_INT 1
47486: ST_TO_ADDR
// break ;
47487: GO 47491
// end ;
47489: GO 47460
47491: POP
47492: POP
// if busy then
47493: LD_VAR 0 8
47497: IFFALSE 47501
// continue ;
47499: GO 47307
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47501: LD_ADDR_VAR 0 7
47505: PUSH
47506: LD_VAR 0 6
47510: PPUSH
47511: LD_INT 35
47513: PUSH
47514: LD_INT 0
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PPUSH
47521: CALL_OW 72
47525: ST_TO_ADDR
// if tw then
47526: LD_VAR 0 7
47530: IFFALSE 47607
// begin tw := tw [ 1 ] ;
47532: LD_ADDR_VAR 0 7
47536: PUSH
47537: LD_VAR 0 7
47541: PUSH
47542: LD_INT 1
47544: ARRAY
47545: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47546: LD_ADDR_VAR 0 9
47550: PUSH
47551: LD_VAR 0 7
47555: PPUSH
47556: LD_EXP 141
47560: PUSH
47561: LD_VAR 0 2
47565: ARRAY
47566: PPUSH
47567: CALL 75710 0 2
47571: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47572: LD_EXP 155
47576: PUSH
47577: LD_VAR 0 2
47581: ARRAY
47582: IFFALSE 47605
// if not weapon in mc_allowed_tower_weapons [ i ] then
47584: LD_VAR 0 9
47588: PUSH
47589: LD_EXP 155
47593: PUSH
47594: LD_VAR 0 2
47598: ARRAY
47599: IN
47600: NOT
47601: IFFALSE 47605
// continue ;
47603: GO 47307
// end else
47605: GO 47670
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47607: LD_ADDR_VAR 0 5
47611: PUSH
47612: LD_EXP 124
47616: PUSH
47617: LD_VAR 0 2
47621: ARRAY
47622: PPUSH
47623: LD_VAR 0 4
47627: PPUSH
47628: CALL 101999 0 2
47632: ST_TO_ADDR
// if not tmp2 then
47633: LD_VAR 0 5
47637: NOT
47638: IFFALSE 47642
// continue ;
47640: GO 47307
// tw := tmp2 [ 1 ] ;
47642: LD_ADDR_VAR 0 7
47646: PUSH
47647: LD_VAR 0 5
47651: PUSH
47652: LD_INT 1
47654: ARRAY
47655: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47656: LD_ADDR_VAR 0 9
47660: PUSH
47661: LD_VAR 0 5
47665: PUSH
47666: LD_INT 2
47668: ARRAY
47669: ST_TO_ADDR
// end ; if not weapon then
47670: LD_VAR 0 9
47674: NOT
47675: IFFALSE 47679
// continue ;
47677: GO 47307
// ComPlaceWeapon ( tw , weapon ) ;
47679: LD_VAR 0 7
47683: PPUSH
47684: LD_VAR 0 9
47688: PPUSH
47689: CALL_OW 148
// end ;
47693: GO 47307
47695: POP
47696: POP
// end ;
47697: LD_VAR 0 1
47701: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47702: LD_INT 0
47704: PPUSH
47705: PPUSH
47706: PPUSH
47707: PPUSH
47708: PPUSH
47709: PPUSH
47710: PPUSH
// if not mc_bases then
47711: LD_EXP 116
47715: NOT
47716: IFFALSE 47720
// exit ;
47718: GO 48488
// for i = 1 to mc_bases do
47720: LD_ADDR_VAR 0 2
47724: PUSH
47725: DOUBLE
47726: LD_INT 1
47728: DEC
47729: ST_TO_ADDR
47730: LD_EXP 116
47734: PUSH
47735: FOR_TO
47736: IFFALSE 48486
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47738: LD_EXP 129
47742: PUSH
47743: LD_VAR 0 2
47747: ARRAY
47748: NOT
47749: PUSH
47750: LD_EXP 129
47754: PUSH
47755: LD_VAR 0 2
47759: ARRAY
47760: PUSH
47761: LD_EXP 130
47765: PUSH
47766: LD_VAR 0 2
47770: ARRAY
47771: EQUAL
47772: OR
47773: PUSH
47774: LD_EXP 139
47778: PUSH
47779: LD_VAR 0 2
47783: ARRAY
47784: OR
47785: IFFALSE 47789
// continue ;
47787: GO 47735
// if mc_miners [ i ] then
47789: LD_EXP 130
47793: PUSH
47794: LD_VAR 0 2
47798: ARRAY
47799: IFFALSE 48173
// begin for j = mc_miners [ i ] downto 1 do
47801: LD_ADDR_VAR 0 3
47805: PUSH
47806: DOUBLE
47807: LD_EXP 130
47811: PUSH
47812: LD_VAR 0 2
47816: ARRAY
47817: INC
47818: ST_TO_ADDR
47819: LD_INT 1
47821: PUSH
47822: FOR_DOWNTO
47823: IFFALSE 48171
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47825: LD_EXP 130
47829: PUSH
47830: LD_VAR 0 2
47834: ARRAY
47835: PUSH
47836: LD_VAR 0 3
47840: ARRAY
47841: PPUSH
47842: CALL_OW 301
47846: PUSH
47847: LD_EXP 130
47851: PUSH
47852: LD_VAR 0 2
47856: ARRAY
47857: PUSH
47858: LD_VAR 0 3
47862: ARRAY
47863: PPUSH
47864: CALL_OW 257
47868: PUSH
47869: LD_INT 1
47871: NONEQUAL
47872: OR
47873: IFFALSE 47936
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47875: LD_ADDR_VAR 0 5
47879: PUSH
47880: LD_EXP 130
47884: PUSH
47885: LD_VAR 0 2
47889: ARRAY
47890: PUSH
47891: LD_EXP 130
47895: PUSH
47896: LD_VAR 0 2
47900: ARRAY
47901: PUSH
47902: LD_VAR 0 3
47906: ARRAY
47907: DIFF
47908: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47909: LD_ADDR_EXP 130
47913: PUSH
47914: LD_EXP 130
47918: PPUSH
47919: LD_VAR 0 2
47923: PPUSH
47924: LD_VAR 0 5
47928: PPUSH
47929: CALL_OW 1
47933: ST_TO_ADDR
// continue ;
47934: GO 47822
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47936: LD_EXP 130
47940: PUSH
47941: LD_VAR 0 2
47945: ARRAY
47946: PUSH
47947: LD_VAR 0 3
47951: ARRAY
47952: PPUSH
47953: CALL_OW 257
47957: PUSH
47958: LD_INT 1
47960: EQUAL
47961: PUSH
47962: LD_EXP 130
47966: PUSH
47967: LD_VAR 0 2
47971: ARRAY
47972: PUSH
47973: LD_VAR 0 3
47977: ARRAY
47978: PPUSH
47979: CALL_OW 459
47983: NOT
47984: AND
47985: PUSH
47986: LD_EXP 130
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: PUSH
47997: LD_VAR 0 3
48001: ARRAY
48002: PPUSH
48003: CALL_OW 314
48007: NOT
48008: AND
48009: IFFALSE 48169
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48011: LD_EXP 130
48015: PUSH
48016: LD_VAR 0 2
48020: ARRAY
48021: PUSH
48022: LD_VAR 0 3
48026: ARRAY
48027: PPUSH
48028: CALL_OW 310
48032: IFFALSE 48055
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48034: LD_EXP 130
48038: PUSH
48039: LD_VAR 0 2
48043: ARRAY
48044: PUSH
48045: LD_VAR 0 3
48049: ARRAY
48050: PPUSH
48051: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48055: LD_EXP 130
48059: PUSH
48060: LD_VAR 0 2
48064: ARRAY
48065: PUSH
48066: LD_VAR 0 3
48070: ARRAY
48071: PPUSH
48072: CALL_OW 314
48076: NOT
48077: IFFALSE 48169
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48079: LD_ADDR_VAR 0 7
48083: PUSH
48084: LD_INT 1
48086: PPUSH
48087: LD_EXP 129
48091: PUSH
48092: LD_VAR 0 2
48096: ARRAY
48097: PPUSH
48098: CALL_OW 12
48102: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48103: LD_EXP 130
48107: PUSH
48108: LD_VAR 0 2
48112: ARRAY
48113: PUSH
48114: LD_VAR 0 3
48118: ARRAY
48119: PPUSH
48120: LD_EXP 129
48124: PUSH
48125: LD_VAR 0 2
48129: ARRAY
48130: PUSH
48131: LD_VAR 0 7
48135: ARRAY
48136: PUSH
48137: LD_INT 1
48139: ARRAY
48140: PPUSH
48141: LD_EXP 129
48145: PUSH
48146: LD_VAR 0 2
48150: ARRAY
48151: PUSH
48152: LD_VAR 0 7
48156: ARRAY
48157: PUSH
48158: LD_INT 2
48160: ARRAY
48161: PPUSH
48162: LD_INT 0
48164: PPUSH
48165: CALL_OW 193
// end ; end ; end ;
48169: GO 47822
48171: POP
48172: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48173: LD_ADDR_VAR 0 5
48177: PUSH
48178: LD_EXP 116
48182: PUSH
48183: LD_VAR 0 2
48187: ARRAY
48188: PPUSH
48189: LD_INT 2
48191: PUSH
48192: LD_INT 30
48194: PUSH
48195: LD_INT 4
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: LD_INT 30
48204: PUSH
48205: LD_INT 5
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: PUSH
48212: LD_INT 30
48214: PUSH
48215: LD_INT 32
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: PPUSH
48228: CALL_OW 72
48232: ST_TO_ADDR
// if not tmp then
48233: LD_VAR 0 5
48237: NOT
48238: IFFALSE 48242
// continue ;
48240: GO 47735
// list := [ ] ;
48242: LD_ADDR_VAR 0 6
48246: PUSH
48247: EMPTY
48248: ST_TO_ADDR
// for j in tmp do
48249: LD_ADDR_VAR 0 3
48253: PUSH
48254: LD_VAR 0 5
48258: PUSH
48259: FOR_IN
48260: IFFALSE 48329
// begin for k in UnitsInside ( j ) do
48262: LD_ADDR_VAR 0 4
48266: PUSH
48267: LD_VAR 0 3
48271: PPUSH
48272: CALL_OW 313
48276: PUSH
48277: FOR_IN
48278: IFFALSE 48325
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48280: LD_VAR 0 4
48284: PPUSH
48285: CALL_OW 257
48289: PUSH
48290: LD_INT 1
48292: EQUAL
48293: PUSH
48294: LD_VAR 0 4
48298: PPUSH
48299: CALL_OW 459
48303: NOT
48304: AND
48305: IFFALSE 48323
// list := list ^ k ;
48307: LD_ADDR_VAR 0 6
48311: PUSH
48312: LD_VAR 0 6
48316: PUSH
48317: LD_VAR 0 4
48321: ADD
48322: ST_TO_ADDR
48323: GO 48277
48325: POP
48326: POP
// end ;
48327: GO 48259
48329: POP
48330: POP
// list := list diff mc_miners [ i ] ;
48331: LD_ADDR_VAR 0 6
48335: PUSH
48336: LD_VAR 0 6
48340: PUSH
48341: LD_EXP 130
48345: PUSH
48346: LD_VAR 0 2
48350: ARRAY
48351: DIFF
48352: ST_TO_ADDR
// if not list then
48353: LD_VAR 0 6
48357: NOT
48358: IFFALSE 48362
// continue ;
48360: GO 47735
// k := mc_mines [ i ] - mc_miners [ i ] ;
48362: LD_ADDR_VAR 0 4
48366: PUSH
48367: LD_EXP 129
48371: PUSH
48372: LD_VAR 0 2
48376: ARRAY
48377: PUSH
48378: LD_EXP 130
48382: PUSH
48383: LD_VAR 0 2
48387: ARRAY
48388: MINUS
48389: ST_TO_ADDR
// if k > list then
48390: LD_VAR 0 4
48394: PUSH
48395: LD_VAR 0 6
48399: GREATER
48400: IFFALSE 48412
// k := list ;
48402: LD_ADDR_VAR 0 4
48406: PUSH
48407: LD_VAR 0 6
48411: ST_TO_ADDR
// for j = 1 to k do
48412: LD_ADDR_VAR 0 3
48416: PUSH
48417: DOUBLE
48418: LD_INT 1
48420: DEC
48421: ST_TO_ADDR
48422: LD_VAR 0 4
48426: PUSH
48427: FOR_TO
48428: IFFALSE 48482
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48430: LD_ADDR_EXP 130
48434: PUSH
48435: LD_EXP 130
48439: PPUSH
48440: LD_VAR 0 2
48444: PUSH
48445: LD_EXP 130
48449: PUSH
48450: LD_VAR 0 2
48454: ARRAY
48455: PUSH
48456: LD_INT 1
48458: PLUS
48459: PUSH
48460: EMPTY
48461: LIST
48462: LIST
48463: PPUSH
48464: LD_VAR 0 6
48468: PUSH
48469: LD_VAR 0 3
48473: ARRAY
48474: PPUSH
48475: CALL 70700 0 3
48479: ST_TO_ADDR
48480: GO 48427
48482: POP
48483: POP
// end ;
48484: GO 47735
48486: POP
48487: POP
// end ;
48488: LD_VAR 0 1
48492: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48493: LD_INT 0
48495: PPUSH
48496: PPUSH
48497: PPUSH
48498: PPUSH
48499: PPUSH
48500: PPUSH
48501: PPUSH
48502: PPUSH
48503: PPUSH
48504: PPUSH
48505: PPUSH
// if not mc_bases then
48506: LD_EXP 116
48510: NOT
48511: IFFALSE 48515
// exit ;
48513: GO 50338
// for i = 1 to mc_bases do
48515: LD_ADDR_VAR 0 2
48519: PUSH
48520: DOUBLE
48521: LD_INT 1
48523: DEC
48524: ST_TO_ADDR
48525: LD_EXP 116
48529: PUSH
48530: FOR_TO
48531: IFFALSE 50336
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48533: LD_EXP 116
48537: PUSH
48538: LD_VAR 0 2
48542: ARRAY
48543: NOT
48544: PUSH
48545: LD_EXP 123
48549: PUSH
48550: LD_VAR 0 2
48554: ARRAY
48555: OR
48556: IFFALSE 48560
// continue ;
48558: GO 48530
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48560: LD_EXP 132
48564: PUSH
48565: LD_VAR 0 2
48569: ARRAY
48570: NOT
48571: PUSH
48572: LD_EXP 133
48576: PUSH
48577: LD_VAR 0 2
48581: ARRAY
48582: AND
48583: IFFALSE 48621
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48585: LD_ADDR_EXP 133
48589: PUSH
48590: LD_EXP 133
48594: PPUSH
48595: LD_VAR 0 2
48599: PPUSH
48600: EMPTY
48601: PPUSH
48602: CALL_OW 1
48606: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48607: LD_VAR 0 2
48611: PPUSH
48612: LD_INT 107
48614: PPUSH
48615: CALL 39389 0 2
// continue ;
48619: GO 48530
// end ; target := [ ] ;
48621: LD_ADDR_VAR 0 7
48625: PUSH
48626: EMPTY
48627: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48628: LD_ADDR_VAR 0 6
48632: PUSH
48633: LD_EXP 116
48637: PUSH
48638: LD_VAR 0 2
48642: ARRAY
48643: PUSH
48644: LD_INT 1
48646: ARRAY
48647: PPUSH
48648: CALL_OW 255
48652: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48653: LD_ADDR_VAR 0 9
48657: PUSH
48658: LD_EXP 116
48662: PUSH
48663: LD_VAR 0 2
48667: ARRAY
48668: PPUSH
48669: LD_INT 2
48671: PUSH
48672: LD_INT 30
48674: PUSH
48675: LD_INT 0
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: PUSH
48682: LD_INT 30
48684: PUSH
48685: LD_INT 1
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: EMPTY
48693: LIST
48694: LIST
48695: LIST
48696: PPUSH
48697: CALL_OW 72
48701: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48702: LD_ADDR_VAR 0 3
48706: PUSH
48707: DOUBLE
48708: LD_EXP 132
48712: PUSH
48713: LD_VAR 0 2
48717: ARRAY
48718: INC
48719: ST_TO_ADDR
48720: LD_INT 1
48722: PUSH
48723: FOR_DOWNTO
48724: IFFALSE 48969
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48726: LD_EXP 132
48730: PUSH
48731: LD_VAR 0 2
48735: ARRAY
48736: PUSH
48737: LD_VAR 0 3
48741: ARRAY
48742: PUSH
48743: LD_INT 2
48745: ARRAY
48746: PPUSH
48747: LD_EXP 132
48751: PUSH
48752: LD_VAR 0 2
48756: ARRAY
48757: PUSH
48758: LD_VAR 0 3
48762: ARRAY
48763: PUSH
48764: LD_INT 3
48766: ARRAY
48767: PPUSH
48768: CALL_OW 488
48772: PUSH
48773: LD_EXP 132
48777: PUSH
48778: LD_VAR 0 2
48782: ARRAY
48783: PUSH
48784: LD_VAR 0 3
48788: ARRAY
48789: PUSH
48790: LD_INT 2
48792: ARRAY
48793: PPUSH
48794: LD_EXP 132
48798: PUSH
48799: LD_VAR 0 2
48803: ARRAY
48804: PUSH
48805: LD_VAR 0 3
48809: ARRAY
48810: PUSH
48811: LD_INT 3
48813: ARRAY
48814: PPUSH
48815: CALL_OW 284
48819: PUSH
48820: LD_INT 0
48822: EQUAL
48823: AND
48824: IFFALSE 48879
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48826: LD_ADDR_VAR 0 5
48830: PUSH
48831: LD_EXP 132
48835: PUSH
48836: LD_VAR 0 2
48840: ARRAY
48841: PPUSH
48842: LD_VAR 0 3
48846: PPUSH
48847: CALL_OW 3
48851: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48852: LD_ADDR_EXP 132
48856: PUSH
48857: LD_EXP 132
48861: PPUSH
48862: LD_VAR 0 2
48866: PPUSH
48867: LD_VAR 0 5
48871: PPUSH
48872: CALL_OW 1
48876: ST_TO_ADDR
// continue ;
48877: GO 48723
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48879: LD_VAR 0 6
48883: PPUSH
48884: LD_EXP 132
48888: PUSH
48889: LD_VAR 0 2
48893: ARRAY
48894: PUSH
48895: LD_VAR 0 3
48899: ARRAY
48900: PUSH
48901: LD_INT 2
48903: ARRAY
48904: PPUSH
48905: LD_EXP 132
48909: PUSH
48910: LD_VAR 0 2
48914: ARRAY
48915: PUSH
48916: LD_VAR 0 3
48920: ARRAY
48921: PUSH
48922: LD_INT 3
48924: ARRAY
48925: PPUSH
48926: LD_INT 30
48928: PPUSH
48929: CALL 71596 0 4
48933: PUSH
48934: LD_INT 4
48936: ARRAY
48937: PUSH
48938: LD_INT 0
48940: EQUAL
48941: IFFALSE 48967
// begin target := mc_crates [ i ] [ j ] ;
48943: LD_ADDR_VAR 0 7
48947: PUSH
48948: LD_EXP 132
48952: PUSH
48953: LD_VAR 0 2
48957: ARRAY
48958: PUSH
48959: LD_VAR 0 3
48963: ARRAY
48964: ST_TO_ADDR
// break ;
48965: GO 48969
// end ; end ;
48967: GO 48723
48969: POP
48970: POP
// if not target then
48971: LD_VAR 0 7
48975: NOT
48976: IFFALSE 48980
// continue ;
48978: GO 48530
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48980: LD_ADDR_VAR 0 8
48984: PUSH
48985: LD_EXP 135
48989: PUSH
48990: LD_VAR 0 2
48994: ARRAY
48995: PPUSH
48996: LD_INT 2
48998: PUSH
48999: LD_INT 3
49001: PUSH
49002: LD_INT 58
49004: PUSH
49005: EMPTY
49006: LIST
49007: PUSH
49008: EMPTY
49009: LIST
49010: LIST
49011: PUSH
49012: LD_INT 61
49014: PUSH
49015: EMPTY
49016: LIST
49017: PUSH
49018: LD_INT 33
49020: PUSH
49021: LD_INT 5
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PUSH
49028: LD_INT 33
49030: PUSH
49031: LD_INT 3
49033: PUSH
49034: EMPTY
49035: LIST
49036: LIST
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: LIST
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 2
49047: PUSH
49048: LD_INT 34
49050: PUSH
49051: LD_INT 32
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: LD_INT 34
49060: PUSH
49061: LD_INT 51
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: PUSH
49068: LD_INT 34
49070: PUSH
49071: LD_INT 12
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: PUSH
49084: EMPTY
49085: LIST
49086: LIST
49087: PPUSH
49088: CALL_OW 72
49092: ST_TO_ADDR
// if not cargo then
49093: LD_VAR 0 8
49097: NOT
49098: IFFALSE 49804
// begin if mc_crates_collector [ i ] < 5 then
49100: LD_EXP 133
49104: PUSH
49105: LD_VAR 0 2
49109: ARRAY
49110: PUSH
49111: LD_INT 5
49113: LESS
49114: IFFALSE 49480
// begin if mc_ape [ i ] then
49116: LD_EXP 145
49120: PUSH
49121: LD_VAR 0 2
49125: ARRAY
49126: IFFALSE 49173
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49128: LD_ADDR_VAR 0 5
49132: PUSH
49133: LD_EXP 145
49137: PUSH
49138: LD_VAR 0 2
49142: ARRAY
49143: PPUSH
49144: LD_INT 25
49146: PUSH
49147: LD_INT 16
49149: PUSH
49150: EMPTY
49151: LIST
49152: LIST
49153: PUSH
49154: LD_INT 24
49156: PUSH
49157: LD_INT 750
49159: PUSH
49160: EMPTY
49161: LIST
49162: LIST
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: PPUSH
49168: CALL_OW 72
49172: ST_TO_ADDR
// if not tmp then
49173: LD_VAR 0 5
49177: NOT
49178: IFFALSE 49225
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49180: LD_ADDR_VAR 0 5
49184: PUSH
49185: LD_EXP 116
49189: PUSH
49190: LD_VAR 0 2
49194: ARRAY
49195: PPUSH
49196: LD_INT 25
49198: PUSH
49199: LD_INT 2
49201: PUSH
49202: EMPTY
49203: LIST
49204: LIST
49205: PUSH
49206: LD_INT 24
49208: PUSH
49209: LD_INT 750
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PPUSH
49220: CALL_OW 72
49224: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49225: LD_EXP 145
49229: PUSH
49230: LD_VAR 0 2
49234: ARRAY
49235: PUSH
49236: LD_EXP 116
49240: PUSH
49241: LD_VAR 0 2
49245: ARRAY
49246: PPUSH
49247: LD_INT 25
49249: PUSH
49250: LD_INT 2
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: LD_INT 24
49259: PUSH
49260: LD_INT 750
49262: PUSH
49263: EMPTY
49264: LIST
49265: LIST
49266: PUSH
49267: EMPTY
49268: LIST
49269: LIST
49270: PPUSH
49271: CALL_OW 72
49275: AND
49276: PUSH
49277: LD_VAR 0 5
49281: PUSH
49282: LD_INT 5
49284: LESS
49285: AND
49286: IFFALSE 49368
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49288: LD_ADDR_VAR 0 3
49292: PUSH
49293: LD_EXP 116
49297: PUSH
49298: LD_VAR 0 2
49302: ARRAY
49303: PPUSH
49304: LD_INT 25
49306: PUSH
49307: LD_INT 2
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 24
49316: PUSH
49317: LD_INT 750
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: PPUSH
49328: CALL_OW 72
49332: PUSH
49333: FOR_IN
49334: IFFALSE 49366
// begin tmp := tmp union j ;
49336: LD_ADDR_VAR 0 5
49340: PUSH
49341: LD_VAR 0 5
49345: PUSH
49346: LD_VAR 0 3
49350: UNION
49351: ST_TO_ADDR
// if tmp >= 5 then
49352: LD_VAR 0 5
49356: PUSH
49357: LD_INT 5
49359: GREATEREQUAL
49360: IFFALSE 49364
// break ;
49362: GO 49366
// end ;
49364: GO 49333
49366: POP
49367: POP
// end ; if not tmp then
49368: LD_VAR 0 5
49372: NOT
49373: IFFALSE 49377
// continue ;
49375: GO 48530
// for j in tmp do
49377: LD_ADDR_VAR 0 3
49381: PUSH
49382: LD_VAR 0 5
49386: PUSH
49387: FOR_IN
49388: IFFALSE 49478
// if not GetTag ( j ) then
49390: LD_VAR 0 3
49394: PPUSH
49395: CALL_OW 110
49399: NOT
49400: IFFALSE 49476
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49402: LD_ADDR_EXP 133
49406: PUSH
49407: LD_EXP 133
49411: PPUSH
49412: LD_VAR 0 2
49416: PUSH
49417: LD_EXP 133
49421: PUSH
49422: LD_VAR 0 2
49426: ARRAY
49427: PUSH
49428: LD_INT 1
49430: PLUS
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PPUSH
49436: LD_VAR 0 3
49440: PPUSH
49441: CALL 70700 0 3
49445: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49446: LD_VAR 0 3
49450: PPUSH
49451: LD_INT 107
49453: PPUSH
49454: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49458: LD_EXP 133
49462: PUSH
49463: LD_VAR 0 2
49467: ARRAY
49468: PUSH
49469: LD_INT 5
49471: GREATEREQUAL
49472: IFFALSE 49476
// break ;
49474: GO 49478
// end ;
49476: GO 49387
49478: POP
49479: POP
// end ; if mc_crates_collector [ i ] and target then
49480: LD_EXP 133
49484: PUSH
49485: LD_VAR 0 2
49489: ARRAY
49490: PUSH
49491: LD_VAR 0 7
49495: AND
49496: IFFALSE 49802
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49498: LD_EXP 133
49502: PUSH
49503: LD_VAR 0 2
49507: ARRAY
49508: PUSH
49509: LD_VAR 0 7
49513: PUSH
49514: LD_INT 1
49516: ARRAY
49517: LESS
49518: IFFALSE 49538
// tmp := mc_crates_collector [ i ] else
49520: LD_ADDR_VAR 0 5
49524: PUSH
49525: LD_EXP 133
49529: PUSH
49530: LD_VAR 0 2
49534: ARRAY
49535: ST_TO_ADDR
49536: GO 49552
// tmp := target [ 1 ] ;
49538: LD_ADDR_VAR 0 5
49542: PUSH
49543: LD_VAR 0 7
49547: PUSH
49548: LD_INT 1
49550: ARRAY
49551: ST_TO_ADDR
// k := 0 ;
49552: LD_ADDR_VAR 0 4
49556: PUSH
49557: LD_INT 0
49559: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49560: LD_ADDR_VAR 0 3
49564: PUSH
49565: LD_EXP 133
49569: PUSH
49570: LD_VAR 0 2
49574: ARRAY
49575: PUSH
49576: FOR_IN
49577: IFFALSE 49800
// begin k := k + 1 ;
49579: LD_ADDR_VAR 0 4
49583: PUSH
49584: LD_VAR 0 4
49588: PUSH
49589: LD_INT 1
49591: PLUS
49592: ST_TO_ADDR
// if k > tmp then
49593: LD_VAR 0 4
49597: PUSH
49598: LD_VAR 0 5
49602: GREATER
49603: IFFALSE 49607
// break ;
49605: GO 49800
// if not GetClass ( j ) in [ 2 , 16 ] then
49607: LD_VAR 0 3
49611: PPUSH
49612: CALL_OW 257
49616: PUSH
49617: LD_INT 2
49619: PUSH
49620: LD_INT 16
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: IN
49627: NOT
49628: IFFALSE 49681
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49630: LD_ADDR_EXP 133
49634: PUSH
49635: LD_EXP 133
49639: PPUSH
49640: LD_VAR 0 2
49644: PPUSH
49645: LD_EXP 133
49649: PUSH
49650: LD_VAR 0 2
49654: ARRAY
49655: PUSH
49656: LD_VAR 0 3
49660: DIFF
49661: PPUSH
49662: CALL_OW 1
49666: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49667: LD_VAR 0 3
49671: PPUSH
49672: LD_INT 0
49674: PPUSH
49675: CALL_OW 109
// continue ;
49679: GO 49576
// end ; if IsInUnit ( j ) then
49681: LD_VAR 0 3
49685: PPUSH
49686: CALL_OW 310
49690: IFFALSE 49701
// ComExitBuilding ( j ) ;
49692: LD_VAR 0 3
49696: PPUSH
49697: CALL_OW 122
// wait ( 3 ) ;
49701: LD_INT 3
49703: PPUSH
49704: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49708: LD_VAR 0 3
49712: PPUSH
49713: CALL_OW 314
49717: PUSH
49718: LD_VAR 0 6
49722: PPUSH
49723: LD_VAR 0 7
49727: PUSH
49728: LD_INT 2
49730: ARRAY
49731: PPUSH
49732: LD_VAR 0 7
49736: PUSH
49737: LD_INT 3
49739: ARRAY
49740: PPUSH
49741: LD_INT 30
49743: PPUSH
49744: CALL 71596 0 4
49748: PUSH
49749: LD_INT 4
49751: ARRAY
49752: AND
49753: IFFALSE 49771
// ComStandNearbyBuilding ( j , depot ) else
49755: LD_VAR 0 3
49759: PPUSH
49760: LD_VAR 0 9
49764: PPUSH
49765: CALL 67278 0 2
49769: GO 49798
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49771: LD_VAR 0 3
49775: PPUSH
49776: LD_VAR 0 7
49780: PUSH
49781: LD_INT 2
49783: ARRAY
49784: PPUSH
49785: LD_VAR 0 7
49789: PUSH
49790: LD_INT 3
49792: ARRAY
49793: PPUSH
49794: CALL_OW 117
// end ;
49798: GO 49576
49800: POP
49801: POP
// end ; end else
49802: GO 50334
// begin for j in cargo do
49804: LD_ADDR_VAR 0 3
49808: PUSH
49809: LD_VAR 0 8
49813: PUSH
49814: FOR_IN
49815: IFFALSE 50332
// begin if GetTag ( j ) <> 0 then
49817: LD_VAR 0 3
49821: PPUSH
49822: CALL_OW 110
49826: PUSH
49827: LD_INT 0
49829: NONEQUAL
49830: IFFALSE 49834
// continue ;
49832: GO 49814
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49834: LD_VAR 0 3
49838: PPUSH
49839: CALL_OW 256
49843: PUSH
49844: LD_INT 1000
49846: LESS
49847: PUSH
49848: LD_VAR 0 3
49852: PPUSH
49853: LD_EXP 140
49857: PUSH
49858: LD_VAR 0 2
49862: ARRAY
49863: PPUSH
49864: CALL_OW 308
49868: NOT
49869: AND
49870: IFFALSE 49892
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49872: LD_VAR 0 3
49876: PPUSH
49877: LD_EXP 140
49881: PUSH
49882: LD_VAR 0 2
49886: ARRAY
49887: PPUSH
49888: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49892: LD_VAR 0 3
49896: PPUSH
49897: CALL_OW 256
49901: PUSH
49902: LD_INT 1000
49904: LESS
49905: PUSH
49906: LD_VAR 0 3
49910: PPUSH
49911: LD_EXP 140
49915: PUSH
49916: LD_VAR 0 2
49920: ARRAY
49921: PPUSH
49922: CALL_OW 308
49926: AND
49927: IFFALSE 49931
// continue ;
49929: GO 49814
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49931: LD_VAR 0 3
49935: PPUSH
49936: CALL_OW 262
49940: PUSH
49941: LD_INT 2
49943: EQUAL
49944: PUSH
49945: LD_VAR 0 3
49949: PPUSH
49950: CALL_OW 261
49954: PUSH
49955: LD_INT 15
49957: LESS
49958: AND
49959: IFFALSE 49963
// continue ;
49961: GO 49814
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49963: LD_VAR 0 3
49967: PPUSH
49968: CALL_OW 262
49972: PUSH
49973: LD_INT 1
49975: EQUAL
49976: PUSH
49977: LD_VAR 0 3
49981: PPUSH
49982: CALL_OW 261
49986: PUSH
49987: LD_INT 10
49989: LESS
49990: AND
49991: IFFALSE 50271
// begin if not depot then
49993: LD_VAR 0 9
49997: NOT
49998: IFFALSE 50002
// continue ;
50000: GO 49814
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50002: LD_VAR 0 3
50006: PPUSH
50007: LD_VAR 0 9
50011: PPUSH
50012: LD_VAR 0 3
50016: PPUSH
50017: CALL_OW 74
50021: PPUSH
50022: CALL_OW 296
50026: PUSH
50027: LD_INT 6
50029: LESS
50030: IFFALSE 50046
// SetFuel ( j , 100 ) else
50032: LD_VAR 0 3
50036: PPUSH
50037: LD_INT 100
50039: PPUSH
50040: CALL_OW 240
50044: GO 50271
// if GetFuel ( j ) = 0 then
50046: LD_VAR 0 3
50050: PPUSH
50051: CALL_OW 261
50055: PUSH
50056: LD_INT 0
50058: EQUAL
50059: IFFALSE 50271
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50061: LD_ADDR_EXP 135
50065: PUSH
50066: LD_EXP 135
50070: PPUSH
50071: LD_VAR 0 2
50075: PPUSH
50076: LD_EXP 135
50080: PUSH
50081: LD_VAR 0 2
50085: ARRAY
50086: PUSH
50087: LD_VAR 0 3
50091: DIFF
50092: PPUSH
50093: CALL_OW 1
50097: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50098: LD_VAR 0 3
50102: PPUSH
50103: CALL_OW 263
50107: PUSH
50108: LD_INT 1
50110: EQUAL
50111: IFFALSE 50127
// ComExitVehicle ( IsInUnit ( j ) ) ;
50113: LD_VAR 0 3
50117: PPUSH
50118: CALL_OW 310
50122: PPUSH
50123: CALL_OW 121
// if GetControl ( j ) = control_remote then
50127: LD_VAR 0 3
50131: PPUSH
50132: CALL_OW 263
50136: PUSH
50137: LD_INT 2
50139: EQUAL
50140: IFFALSE 50151
// ComUnlink ( j ) ;
50142: LD_VAR 0 3
50146: PPUSH
50147: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50151: LD_ADDR_VAR 0 10
50155: PUSH
50156: LD_VAR 0 2
50160: PPUSH
50161: LD_INT 3
50163: PPUSH
50164: CALL 59763 0 2
50168: ST_TO_ADDR
// if fac then
50169: LD_VAR 0 10
50173: IFFALSE 50269
// begin for k in fac do
50175: LD_ADDR_VAR 0 4
50179: PUSH
50180: LD_VAR 0 10
50184: PUSH
50185: FOR_IN
50186: IFFALSE 50267
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50188: LD_ADDR_VAR 0 11
50192: PUSH
50193: LD_VAR 0 10
50197: PPUSH
50198: LD_VAR 0 3
50202: PPUSH
50203: CALL_OW 265
50207: PPUSH
50208: LD_VAR 0 3
50212: PPUSH
50213: CALL_OW 262
50217: PPUSH
50218: LD_VAR 0 3
50222: PPUSH
50223: CALL_OW 263
50227: PPUSH
50228: LD_VAR 0 3
50232: PPUSH
50233: CALL_OW 264
50237: PPUSH
50238: CALL 68196 0 5
50242: ST_TO_ADDR
// if components then
50243: LD_VAR 0 11
50247: IFFALSE 50265
// begin MC_InsertProduceList ( i , components ) ;
50249: LD_VAR 0 2
50253: PPUSH
50254: LD_VAR 0 11
50258: PPUSH
50259: CALL 59308 0 2
// break ;
50263: GO 50267
// end ; end ;
50265: GO 50185
50267: POP
50268: POP
// end ; continue ;
50269: GO 49814
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50271: LD_VAR 0 3
50275: PPUSH
50276: LD_INT 1
50278: PPUSH
50279: CALL_OW 289
50283: PUSH
50284: LD_INT 100
50286: LESS
50287: PUSH
50288: LD_VAR 0 3
50292: PPUSH
50293: CALL_OW 314
50297: NOT
50298: AND
50299: IFFALSE 50328
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50301: LD_VAR 0 3
50305: PPUSH
50306: LD_VAR 0 7
50310: PUSH
50311: LD_INT 2
50313: ARRAY
50314: PPUSH
50315: LD_VAR 0 7
50319: PUSH
50320: LD_INT 3
50322: ARRAY
50323: PPUSH
50324: CALL_OW 117
// break ;
50328: GO 50332
// end ;
50330: GO 49814
50332: POP
50333: POP
// end ; end ;
50334: GO 48530
50336: POP
50337: POP
// end ;
50338: LD_VAR 0 1
50342: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50343: LD_INT 0
50345: PPUSH
50346: PPUSH
50347: PPUSH
50348: PPUSH
// if not mc_bases then
50349: LD_EXP 116
50353: NOT
50354: IFFALSE 50358
// exit ;
50356: GO 50519
// for i = 1 to mc_bases do
50358: LD_ADDR_VAR 0 2
50362: PUSH
50363: DOUBLE
50364: LD_INT 1
50366: DEC
50367: ST_TO_ADDR
50368: LD_EXP 116
50372: PUSH
50373: FOR_TO
50374: IFFALSE 50517
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50376: LD_ADDR_VAR 0 4
50380: PUSH
50381: LD_EXP 135
50385: PUSH
50386: LD_VAR 0 2
50390: ARRAY
50391: PUSH
50392: LD_EXP 138
50396: PUSH
50397: LD_VAR 0 2
50401: ARRAY
50402: UNION
50403: PPUSH
50404: LD_INT 33
50406: PUSH
50407: LD_INT 2
50409: PUSH
50410: EMPTY
50411: LIST
50412: LIST
50413: PPUSH
50414: CALL_OW 72
50418: ST_TO_ADDR
// if tmp then
50419: LD_VAR 0 4
50423: IFFALSE 50515
// for j in tmp do
50425: LD_ADDR_VAR 0 3
50429: PUSH
50430: LD_VAR 0 4
50434: PUSH
50435: FOR_IN
50436: IFFALSE 50513
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50438: LD_VAR 0 3
50442: PPUSH
50443: CALL_OW 312
50447: NOT
50448: PUSH
50449: LD_VAR 0 3
50453: PPUSH
50454: CALL_OW 256
50458: PUSH
50459: LD_INT 250
50461: GREATEREQUAL
50462: AND
50463: IFFALSE 50476
// Connect ( j ) else
50465: LD_VAR 0 3
50469: PPUSH
50470: CALL 73671 0 1
50474: GO 50511
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50476: LD_VAR 0 3
50480: PPUSH
50481: CALL_OW 256
50485: PUSH
50486: LD_INT 250
50488: LESS
50489: PUSH
50490: LD_VAR 0 3
50494: PPUSH
50495: CALL_OW 312
50499: AND
50500: IFFALSE 50511
// ComUnlink ( j ) ;
50502: LD_VAR 0 3
50506: PPUSH
50507: CALL_OW 136
50511: GO 50435
50513: POP
50514: POP
// end ;
50515: GO 50373
50517: POP
50518: POP
// end ;
50519: LD_VAR 0 1
50523: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50524: LD_INT 0
50526: PPUSH
50527: PPUSH
50528: PPUSH
50529: PPUSH
50530: PPUSH
// if not mc_bases then
50531: LD_EXP 116
50535: NOT
50536: IFFALSE 50540
// exit ;
50538: GO 50985
// for i = 1 to mc_bases do
50540: LD_ADDR_VAR 0 2
50544: PUSH
50545: DOUBLE
50546: LD_INT 1
50548: DEC
50549: ST_TO_ADDR
50550: LD_EXP 116
50554: PUSH
50555: FOR_TO
50556: IFFALSE 50983
// begin if not mc_produce [ i ] then
50558: LD_EXP 137
50562: PUSH
50563: LD_VAR 0 2
50567: ARRAY
50568: NOT
50569: IFFALSE 50573
// continue ;
50571: GO 50555
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50573: LD_ADDR_VAR 0 5
50577: PUSH
50578: LD_EXP 116
50582: PUSH
50583: LD_VAR 0 2
50587: ARRAY
50588: PPUSH
50589: LD_INT 30
50591: PUSH
50592: LD_INT 3
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PPUSH
50599: CALL_OW 72
50603: ST_TO_ADDR
// if not fac then
50604: LD_VAR 0 5
50608: NOT
50609: IFFALSE 50613
// continue ;
50611: GO 50555
// for j in fac do
50613: LD_ADDR_VAR 0 3
50617: PUSH
50618: LD_VAR 0 5
50622: PUSH
50623: FOR_IN
50624: IFFALSE 50979
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50626: LD_VAR 0 3
50630: PPUSH
50631: CALL_OW 461
50635: PUSH
50636: LD_INT 2
50638: NONEQUAL
50639: PUSH
50640: LD_VAR 0 3
50644: PPUSH
50645: LD_INT 15
50647: PPUSH
50648: CALL 73299 0 2
50652: PUSH
50653: LD_INT 4
50655: ARRAY
50656: OR
50657: IFFALSE 50661
// continue ;
50659: GO 50623
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50661: LD_VAR 0 3
50665: PPUSH
50666: LD_EXP 137
50670: PUSH
50671: LD_VAR 0 2
50675: ARRAY
50676: PUSH
50677: LD_INT 1
50679: ARRAY
50680: PUSH
50681: LD_INT 1
50683: ARRAY
50684: PPUSH
50685: LD_EXP 137
50689: PUSH
50690: LD_VAR 0 2
50694: ARRAY
50695: PUSH
50696: LD_INT 1
50698: ARRAY
50699: PUSH
50700: LD_INT 2
50702: ARRAY
50703: PPUSH
50704: LD_EXP 137
50708: PUSH
50709: LD_VAR 0 2
50713: ARRAY
50714: PUSH
50715: LD_INT 1
50717: ARRAY
50718: PUSH
50719: LD_INT 3
50721: ARRAY
50722: PPUSH
50723: LD_EXP 137
50727: PUSH
50728: LD_VAR 0 2
50732: ARRAY
50733: PUSH
50734: LD_INT 1
50736: ARRAY
50737: PUSH
50738: LD_INT 4
50740: ARRAY
50741: PPUSH
50742: CALL_OW 448
50746: PUSH
50747: LD_VAR 0 3
50751: PPUSH
50752: LD_EXP 137
50756: PUSH
50757: LD_VAR 0 2
50761: ARRAY
50762: PUSH
50763: LD_INT 1
50765: ARRAY
50766: PUSH
50767: LD_INT 1
50769: ARRAY
50770: PUSH
50771: LD_EXP 137
50775: PUSH
50776: LD_VAR 0 2
50780: ARRAY
50781: PUSH
50782: LD_INT 1
50784: ARRAY
50785: PUSH
50786: LD_INT 2
50788: ARRAY
50789: PUSH
50790: LD_EXP 137
50794: PUSH
50795: LD_VAR 0 2
50799: ARRAY
50800: PUSH
50801: LD_INT 1
50803: ARRAY
50804: PUSH
50805: LD_INT 3
50807: ARRAY
50808: PUSH
50809: LD_EXP 137
50813: PUSH
50814: LD_VAR 0 2
50818: ARRAY
50819: PUSH
50820: LD_INT 1
50822: ARRAY
50823: PUSH
50824: LD_INT 4
50826: ARRAY
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: PPUSH
50834: CALL 77066 0 2
50838: AND
50839: IFFALSE 50977
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50841: LD_VAR 0 3
50845: PPUSH
50846: LD_EXP 137
50850: PUSH
50851: LD_VAR 0 2
50855: ARRAY
50856: PUSH
50857: LD_INT 1
50859: ARRAY
50860: PUSH
50861: LD_INT 1
50863: ARRAY
50864: PPUSH
50865: LD_EXP 137
50869: PUSH
50870: LD_VAR 0 2
50874: ARRAY
50875: PUSH
50876: LD_INT 1
50878: ARRAY
50879: PUSH
50880: LD_INT 2
50882: ARRAY
50883: PPUSH
50884: LD_EXP 137
50888: PUSH
50889: LD_VAR 0 2
50893: ARRAY
50894: PUSH
50895: LD_INT 1
50897: ARRAY
50898: PUSH
50899: LD_INT 3
50901: ARRAY
50902: PPUSH
50903: LD_EXP 137
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: PUSH
50914: LD_INT 1
50916: ARRAY
50917: PUSH
50918: LD_INT 4
50920: ARRAY
50921: PPUSH
50922: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50926: LD_ADDR_VAR 0 4
50930: PUSH
50931: LD_EXP 137
50935: PUSH
50936: LD_VAR 0 2
50940: ARRAY
50941: PPUSH
50942: LD_INT 1
50944: PPUSH
50945: CALL_OW 3
50949: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50950: LD_ADDR_EXP 137
50954: PUSH
50955: LD_EXP 137
50959: PPUSH
50960: LD_VAR 0 2
50964: PPUSH
50965: LD_VAR 0 4
50969: PPUSH
50970: CALL_OW 1
50974: ST_TO_ADDR
// break ;
50975: GO 50979
// end ; end ;
50977: GO 50623
50979: POP
50980: POP
// end ;
50981: GO 50555
50983: POP
50984: POP
// end ;
50985: LD_VAR 0 1
50989: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50990: LD_INT 0
50992: PPUSH
50993: PPUSH
50994: PPUSH
// if not mc_bases then
50995: LD_EXP 116
50999: NOT
51000: IFFALSE 51004
// exit ;
51002: GO 51093
// for i = 1 to mc_bases do
51004: LD_ADDR_VAR 0 2
51008: PUSH
51009: DOUBLE
51010: LD_INT 1
51012: DEC
51013: ST_TO_ADDR
51014: LD_EXP 116
51018: PUSH
51019: FOR_TO
51020: IFFALSE 51091
// begin if mc_attack [ i ] then
51022: LD_EXP 136
51026: PUSH
51027: LD_VAR 0 2
51031: ARRAY
51032: IFFALSE 51089
// begin tmp := mc_attack [ i ] [ 1 ] ;
51034: LD_ADDR_VAR 0 3
51038: PUSH
51039: LD_EXP 136
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: PUSH
51050: LD_INT 1
51052: ARRAY
51053: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51054: LD_ADDR_EXP 136
51058: PUSH
51059: LD_EXP 136
51063: PPUSH
51064: LD_VAR 0 2
51068: PPUSH
51069: EMPTY
51070: PPUSH
51071: CALL_OW 1
51075: ST_TO_ADDR
// Attack ( tmp ) ;
51076: LD_VAR 0 3
51080: PPUSH
51081: CALL 122456 0 1
// exit ;
51085: POP
51086: POP
51087: GO 51093
// end ; end ;
51089: GO 51019
51091: POP
51092: POP
// end ;
51093: LD_VAR 0 1
51097: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51098: LD_INT 0
51100: PPUSH
51101: PPUSH
51102: PPUSH
51103: PPUSH
51104: PPUSH
51105: PPUSH
51106: PPUSH
// if not mc_bases then
51107: LD_EXP 116
51111: NOT
51112: IFFALSE 51116
// exit ;
51114: GO 51826
// for i = 1 to mc_bases do
51116: LD_ADDR_VAR 0 2
51120: PUSH
51121: DOUBLE
51122: LD_INT 1
51124: DEC
51125: ST_TO_ADDR
51126: LD_EXP 116
51130: PUSH
51131: FOR_TO
51132: IFFALSE 51824
// begin if not mc_bases [ i ] then
51134: LD_EXP 116
51138: PUSH
51139: LD_VAR 0 2
51143: ARRAY
51144: NOT
51145: IFFALSE 51149
// continue ;
51147: GO 51131
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51149: LD_ADDR_VAR 0 7
51153: PUSH
51154: LD_EXP 116
51158: PUSH
51159: LD_VAR 0 2
51163: ARRAY
51164: PUSH
51165: LD_INT 1
51167: ARRAY
51168: PPUSH
51169: CALL 67500 0 1
51173: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51174: LD_ADDR_EXP 139
51178: PUSH
51179: LD_EXP 139
51183: PPUSH
51184: LD_VAR 0 2
51188: PPUSH
51189: LD_EXP 116
51193: PUSH
51194: LD_VAR 0 2
51198: ARRAY
51199: PUSH
51200: LD_INT 1
51202: ARRAY
51203: PPUSH
51204: CALL_OW 255
51208: PPUSH
51209: LD_EXP 141
51213: PUSH
51214: LD_VAR 0 2
51218: ARRAY
51219: PPUSH
51220: CALL 67465 0 2
51224: PPUSH
51225: CALL_OW 1
51229: ST_TO_ADDR
// if not mc_scan [ i ] then
51230: LD_EXP 139
51234: PUSH
51235: LD_VAR 0 2
51239: ARRAY
51240: NOT
51241: IFFALSE 51419
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51243: LD_ADDR_EXP 159
51247: PUSH
51248: LD_EXP 159
51252: PPUSH
51253: LD_VAR 0 2
51257: PPUSH
51258: LD_INT 0
51260: PPUSH
51261: CALL_OW 1
51265: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51266: LD_ADDR_VAR 0 4
51270: PUSH
51271: LD_EXP 116
51275: PUSH
51276: LD_VAR 0 2
51280: ARRAY
51281: PPUSH
51282: LD_INT 2
51284: PUSH
51285: LD_INT 25
51287: PUSH
51288: LD_INT 5
51290: PUSH
51291: EMPTY
51292: LIST
51293: LIST
51294: PUSH
51295: LD_INT 25
51297: PUSH
51298: LD_INT 8
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: PUSH
51305: LD_INT 25
51307: PUSH
51308: LD_INT 9
51310: PUSH
51311: EMPTY
51312: LIST
51313: LIST
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: PPUSH
51321: CALL_OW 72
51325: ST_TO_ADDR
// if not tmp then
51326: LD_VAR 0 4
51330: NOT
51331: IFFALSE 51335
// continue ;
51333: GO 51131
// for j in tmp do
51335: LD_ADDR_VAR 0 3
51339: PUSH
51340: LD_VAR 0 4
51344: PUSH
51345: FOR_IN
51346: IFFALSE 51417
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51348: LD_VAR 0 3
51352: PPUSH
51353: CALL_OW 310
51357: PPUSH
51358: CALL_OW 266
51362: PUSH
51363: LD_INT 5
51365: EQUAL
51366: PUSH
51367: LD_VAR 0 3
51371: PPUSH
51372: CALL_OW 257
51376: PUSH
51377: LD_INT 1
51379: EQUAL
51380: AND
51381: PUSH
51382: LD_VAR 0 3
51386: PPUSH
51387: CALL_OW 459
51391: NOT
51392: AND
51393: PUSH
51394: LD_VAR 0 7
51398: AND
51399: IFFALSE 51415
// ComChangeProfession ( j , class ) ;
51401: LD_VAR 0 3
51405: PPUSH
51406: LD_VAR 0 7
51410: PPUSH
51411: CALL_OW 123
51415: GO 51345
51417: POP
51418: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
51419: LD_EXP 139
51423: PUSH
51424: LD_VAR 0 2
51428: ARRAY
51429: PUSH
51430: LD_EXP 159
51434: PUSH
51435: LD_VAR 0 2
51439: ARRAY
51440: NOT
51441: AND
51442: PUSH
51443: LD_EXP 138
51447: PUSH
51448: LD_VAR 0 2
51452: ARRAY
51453: NOT
51454: AND
51455: IFFALSE 51706
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51457: LD_ADDR_EXP 159
51461: PUSH
51462: LD_EXP 159
51466: PPUSH
51467: LD_VAR 0 2
51471: PPUSH
51472: LD_INT 1
51474: PPUSH
51475: CALL_OW 1
51479: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51480: LD_ADDR_VAR 0 4
51484: PUSH
51485: LD_EXP 116
51489: PUSH
51490: LD_VAR 0 2
51494: ARRAY
51495: PPUSH
51496: LD_INT 2
51498: PUSH
51499: LD_INT 25
51501: PUSH
51502: LD_INT 1
51504: PUSH
51505: EMPTY
51506: LIST
51507: LIST
51508: PUSH
51509: LD_INT 25
51511: PUSH
51512: LD_INT 5
51514: PUSH
51515: EMPTY
51516: LIST
51517: LIST
51518: PUSH
51519: LD_INT 25
51521: PUSH
51522: LD_INT 8
51524: PUSH
51525: EMPTY
51526: LIST
51527: LIST
51528: PUSH
51529: LD_INT 25
51531: PUSH
51532: LD_INT 9
51534: PUSH
51535: EMPTY
51536: LIST
51537: LIST
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: PPUSH
51546: CALL_OW 72
51550: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51551: LD_ADDR_VAR 0 4
51555: PUSH
51556: LD_VAR 0 4
51560: PUSH
51561: LD_VAR 0 4
51565: PPUSH
51566: LD_INT 18
51568: PPUSH
51569: CALL 99969 0 2
51573: DIFF
51574: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51575: LD_VAR 0 4
51579: NOT
51580: PUSH
51581: LD_EXP 116
51585: PUSH
51586: LD_VAR 0 2
51590: ARRAY
51591: PPUSH
51592: LD_INT 2
51594: PUSH
51595: LD_INT 30
51597: PUSH
51598: LD_INT 4
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: LD_INT 30
51607: PUSH
51608: LD_INT 5
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: LIST
51619: PPUSH
51620: CALL_OW 72
51624: NOT
51625: AND
51626: IFFALSE 51688
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51628: LD_ADDR_VAR 0 4
51632: PUSH
51633: LD_EXP 116
51637: PUSH
51638: LD_VAR 0 2
51642: ARRAY
51643: PPUSH
51644: LD_INT 2
51646: PUSH
51647: LD_INT 25
51649: PUSH
51650: LD_INT 2
51652: PUSH
51653: EMPTY
51654: LIST
51655: LIST
51656: PUSH
51657: LD_INT 25
51659: PUSH
51660: LD_INT 3
51662: PUSH
51663: EMPTY
51664: LIST
51665: LIST
51666: PUSH
51667: LD_INT 25
51669: PUSH
51670: LD_INT 4
51672: PUSH
51673: EMPTY
51674: LIST
51675: LIST
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: PPUSH
51683: CALL_OW 72
51687: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51688: LD_VAR 0 2
51692: PPUSH
51693: LD_VAR 0 4
51697: PPUSH
51698: CALL 127165 0 2
// exit ;
51702: POP
51703: POP
51704: GO 51826
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51706: LD_EXP 139
51710: PUSH
51711: LD_VAR 0 2
51715: ARRAY
51716: PUSH
51717: LD_EXP 159
51721: PUSH
51722: LD_VAR 0 2
51726: ARRAY
51727: NOT
51728: AND
51729: PUSH
51730: LD_EXP 138
51734: PUSH
51735: LD_VAR 0 2
51739: ARRAY
51740: AND
51741: IFFALSE 51822
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51743: LD_ADDR_EXP 159
51747: PUSH
51748: LD_EXP 159
51752: PPUSH
51753: LD_VAR 0 2
51757: PPUSH
51758: LD_INT 1
51760: PPUSH
51761: CALL_OW 1
51765: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51766: LD_ADDR_VAR 0 4
51770: PUSH
51771: LD_EXP 138
51775: PUSH
51776: LD_VAR 0 2
51780: ARRAY
51781: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51782: LD_ADDR_EXP 138
51786: PUSH
51787: LD_EXP 138
51791: PPUSH
51792: LD_VAR 0 2
51796: PPUSH
51797: EMPTY
51798: PPUSH
51799: CALL_OW 1
51803: ST_TO_ADDR
// Defend ( i , tmp ) ;
51804: LD_VAR 0 2
51808: PPUSH
51809: LD_VAR 0 4
51813: PPUSH
51814: CALL 127735 0 2
// exit ;
51818: POP
51819: POP
51820: GO 51826
// end ; end ;
51822: GO 51131
51824: POP
51825: POP
// end ;
51826: LD_VAR 0 1
51830: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51831: LD_INT 0
51833: PPUSH
51834: PPUSH
51835: PPUSH
51836: PPUSH
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
51842: PPUSH
51843: PPUSH
// if not mc_bases then
51844: LD_EXP 116
51848: NOT
51849: IFFALSE 51853
// exit ;
51851: GO 52940
// for i = 1 to mc_bases do
51853: LD_ADDR_VAR 0 2
51857: PUSH
51858: DOUBLE
51859: LD_INT 1
51861: DEC
51862: ST_TO_ADDR
51863: LD_EXP 116
51867: PUSH
51868: FOR_TO
51869: IFFALSE 52938
// begin tmp := mc_lab [ i ] ;
51871: LD_ADDR_VAR 0 6
51875: PUSH
51876: LD_EXP 149
51880: PUSH
51881: LD_VAR 0 2
51885: ARRAY
51886: ST_TO_ADDR
// if not tmp then
51887: LD_VAR 0 6
51891: NOT
51892: IFFALSE 51896
// continue ;
51894: GO 51868
// idle_lab := 0 ;
51896: LD_ADDR_VAR 0 11
51900: PUSH
51901: LD_INT 0
51903: ST_TO_ADDR
// for j in tmp do
51904: LD_ADDR_VAR 0 3
51908: PUSH
51909: LD_VAR 0 6
51913: PUSH
51914: FOR_IN
51915: IFFALSE 52934
// begin researching := false ;
51917: LD_ADDR_VAR 0 10
51921: PUSH
51922: LD_INT 0
51924: ST_TO_ADDR
// side := GetSide ( j ) ;
51925: LD_ADDR_VAR 0 4
51929: PUSH
51930: LD_VAR 0 3
51934: PPUSH
51935: CALL_OW 255
51939: ST_TO_ADDR
// if not mc_tech [ side ] then
51940: LD_EXP 143
51944: PUSH
51945: LD_VAR 0 4
51949: ARRAY
51950: NOT
51951: IFFALSE 51955
// continue ;
51953: GO 51914
// if BuildingStatus ( j ) = bs_idle then
51955: LD_VAR 0 3
51959: PPUSH
51960: CALL_OW 461
51964: PUSH
51965: LD_INT 2
51967: EQUAL
51968: IFFALSE 52156
// begin if idle_lab and UnitsInside ( j ) < 6 then
51970: LD_VAR 0 11
51974: PUSH
51975: LD_VAR 0 3
51979: PPUSH
51980: CALL_OW 313
51984: PUSH
51985: LD_INT 6
51987: LESS
51988: AND
51989: IFFALSE 52060
// begin tmp2 := UnitsInside ( idle_lab ) ;
51991: LD_ADDR_VAR 0 9
51995: PUSH
51996: LD_VAR 0 11
52000: PPUSH
52001: CALL_OW 313
52005: ST_TO_ADDR
// if tmp2 then
52006: LD_VAR 0 9
52010: IFFALSE 52052
// for x in tmp2 do
52012: LD_ADDR_VAR 0 7
52016: PUSH
52017: LD_VAR 0 9
52021: PUSH
52022: FOR_IN
52023: IFFALSE 52050
// begin ComExitBuilding ( x ) ;
52025: LD_VAR 0 7
52029: PPUSH
52030: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52034: LD_VAR 0 7
52038: PPUSH
52039: LD_VAR 0 3
52043: PPUSH
52044: CALL_OW 180
// end ;
52048: GO 52022
52050: POP
52051: POP
// idle_lab := 0 ;
52052: LD_ADDR_VAR 0 11
52056: PUSH
52057: LD_INT 0
52059: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52060: LD_ADDR_VAR 0 5
52064: PUSH
52065: LD_EXP 143
52069: PUSH
52070: LD_VAR 0 4
52074: ARRAY
52075: PUSH
52076: FOR_IN
52077: IFFALSE 52137
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52079: LD_VAR 0 3
52083: PPUSH
52084: LD_VAR 0 5
52088: PPUSH
52089: CALL_OW 430
52093: PUSH
52094: LD_VAR 0 4
52098: PPUSH
52099: LD_VAR 0 5
52103: PPUSH
52104: CALL 66570 0 2
52108: AND
52109: IFFALSE 52135
// begin researching := true ;
52111: LD_ADDR_VAR 0 10
52115: PUSH
52116: LD_INT 1
52118: ST_TO_ADDR
// ComResearch ( j , t ) ;
52119: LD_VAR 0 3
52123: PPUSH
52124: LD_VAR 0 5
52128: PPUSH
52129: CALL_OW 124
// break ;
52133: GO 52137
// end ;
52135: GO 52076
52137: POP
52138: POP
// if not researching then
52139: LD_VAR 0 10
52143: NOT
52144: IFFALSE 52156
// idle_lab := j ;
52146: LD_ADDR_VAR 0 11
52150: PUSH
52151: LD_VAR 0 3
52155: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52156: LD_VAR 0 3
52160: PPUSH
52161: CALL_OW 461
52165: PUSH
52166: LD_INT 10
52168: EQUAL
52169: IFFALSE 52757
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52171: LD_EXP 145
52175: PUSH
52176: LD_VAR 0 2
52180: ARRAY
52181: NOT
52182: PUSH
52183: LD_EXP 146
52187: PUSH
52188: LD_VAR 0 2
52192: ARRAY
52193: NOT
52194: AND
52195: PUSH
52196: LD_EXP 143
52200: PUSH
52201: LD_VAR 0 4
52205: ARRAY
52206: PUSH
52207: LD_INT 1
52209: GREATER
52210: AND
52211: IFFALSE 52342
// begin ComCancel ( j ) ;
52213: LD_VAR 0 3
52217: PPUSH
52218: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52222: LD_ADDR_EXP 143
52226: PUSH
52227: LD_EXP 143
52231: PPUSH
52232: LD_VAR 0 4
52236: PPUSH
52237: LD_EXP 143
52241: PUSH
52242: LD_VAR 0 4
52246: ARRAY
52247: PPUSH
52248: LD_EXP 143
52252: PUSH
52253: LD_VAR 0 4
52257: ARRAY
52258: PUSH
52259: LD_INT 1
52261: MINUS
52262: PPUSH
52263: LD_EXP 143
52267: PUSH
52268: LD_VAR 0 4
52272: ARRAY
52273: PPUSH
52274: LD_INT 0
52276: PPUSH
52277: CALL 70118 0 4
52281: PPUSH
52282: CALL_OW 1
52286: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52287: LD_ADDR_EXP 143
52291: PUSH
52292: LD_EXP 143
52296: PPUSH
52297: LD_VAR 0 4
52301: PPUSH
52302: LD_EXP 143
52306: PUSH
52307: LD_VAR 0 4
52311: ARRAY
52312: PPUSH
52313: LD_EXP 143
52317: PUSH
52318: LD_VAR 0 4
52322: ARRAY
52323: PPUSH
52324: LD_INT 1
52326: PPUSH
52327: LD_INT 0
52329: PPUSH
52330: CALL 70118 0 4
52334: PPUSH
52335: CALL_OW 1
52339: ST_TO_ADDR
// continue ;
52340: GO 51914
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52342: LD_EXP 145
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: PUSH
52353: LD_EXP 146
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: NOT
52364: AND
52365: IFFALSE 52492
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52367: LD_ADDR_EXP 146
52371: PUSH
52372: LD_EXP 146
52376: PPUSH
52377: LD_VAR 0 2
52381: PUSH
52382: LD_EXP 146
52386: PUSH
52387: LD_VAR 0 2
52391: ARRAY
52392: PUSH
52393: LD_INT 1
52395: PLUS
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: PPUSH
52401: LD_EXP 145
52405: PUSH
52406: LD_VAR 0 2
52410: ARRAY
52411: PUSH
52412: LD_INT 1
52414: ARRAY
52415: PPUSH
52416: CALL 70700 0 3
52420: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52421: LD_EXP 145
52425: PUSH
52426: LD_VAR 0 2
52430: ARRAY
52431: PUSH
52432: LD_INT 1
52434: ARRAY
52435: PPUSH
52436: LD_INT 112
52438: PPUSH
52439: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52443: LD_ADDR_VAR 0 9
52447: PUSH
52448: LD_EXP 145
52452: PUSH
52453: LD_VAR 0 2
52457: ARRAY
52458: PPUSH
52459: LD_INT 1
52461: PPUSH
52462: CALL_OW 3
52466: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52467: LD_ADDR_EXP 145
52471: PUSH
52472: LD_EXP 145
52476: PPUSH
52477: LD_VAR 0 2
52481: PPUSH
52482: LD_VAR 0 9
52486: PPUSH
52487: CALL_OW 1
52491: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52492: LD_EXP 145
52496: PUSH
52497: LD_VAR 0 2
52501: ARRAY
52502: PUSH
52503: LD_EXP 146
52507: PUSH
52508: LD_VAR 0 2
52512: ARRAY
52513: AND
52514: PUSH
52515: LD_EXP 146
52519: PUSH
52520: LD_VAR 0 2
52524: ARRAY
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: PPUSH
52530: CALL_OW 310
52534: NOT
52535: AND
52536: PUSH
52537: LD_VAR 0 3
52541: PPUSH
52542: CALL_OW 313
52546: PUSH
52547: LD_INT 6
52549: EQUAL
52550: AND
52551: IFFALSE 52607
// begin tmp2 := UnitsInside ( j ) ;
52553: LD_ADDR_VAR 0 9
52557: PUSH
52558: LD_VAR 0 3
52562: PPUSH
52563: CALL_OW 313
52567: ST_TO_ADDR
// if tmp2 = 6 then
52568: LD_VAR 0 9
52572: PUSH
52573: LD_INT 6
52575: EQUAL
52576: IFFALSE 52607
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52578: LD_VAR 0 9
52582: PUSH
52583: LD_INT 1
52585: ARRAY
52586: PPUSH
52587: LD_INT 112
52589: PPUSH
52590: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52594: LD_VAR 0 9
52598: PUSH
52599: LD_INT 1
52601: ARRAY
52602: PPUSH
52603: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52607: LD_EXP 146
52611: PUSH
52612: LD_VAR 0 2
52616: ARRAY
52617: PUSH
52618: LD_EXP 146
52622: PUSH
52623: LD_VAR 0 2
52627: ARRAY
52628: PUSH
52629: LD_INT 1
52631: ARRAY
52632: PPUSH
52633: CALL_OW 314
52637: NOT
52638: AND
52639: PUSH
52640: LD_EXP 146
52644: PUSH
52645: LD_VAR 0 2
52649: ARRAY
52650: PUSH
52651: LD_INT 1
52653: ARRAY
52654: PPUSH
52655: CALL_OW 310
52659: NOT
52660: AND
52661: IFFALSE 52687
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52663: LD_EXP 146
52667: PUSH
52668: LD_VAR 0 2
52672: ARRAY
52673: PUSH
52674: LD_INT 1
52676: ARRAY
52677: PPUSH
52678: LD_VAR 0 3
52682: PPUSH
52683: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52687: LD_EXP 146
52691: PUSH
52692: LD_VAR 0 2
52696: ARRAY
52697: PUSH
52698: LD_INT 1
52700: ARRAY
52701: PPUSH
52702: CALL_OW 310
52706: PUSH
52707: LD_EXP 146
52711: PUSH
52712: LD_VAR 0 2
52716: ARRAY
52717: PUSH
52718: LD_INT 1
52720: ARRAY
52721: PPUSH
52722: CALL_OW 310
52726: PPUSH
52727: CALL_OW 461
52731: PUSH
52732: LD_INT 3
52734: NONEQUAL
52735: AND
52736: IFFALSE 52757
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52738: LD_EXP 146
52742: PUSH
52743: LD_VAR 0 2
52747: ARRAY
52748: PUSH
52749: LD_INT 1
52751: ARRAY
52752: PPUSH
52753: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52757: LD_VAR 0 3
52761: PPUSH
52762: CALL_OW 461
52766: PUSH
52767: LD_INT 6
52769: EQUAL
52770: PUSH
52771: LD_VAR 0 6
52775: PUSH
52776: LD_INT 1
52778: GREATER
52779: AND
52780: IFFALSE 52932
// begin sci := [ ] ;
52782: LD_ADDR_VAR 0 8
52786: PUSH
52787: EMPTY
52788: ST_TO_ADDR
// for x in ( tmp diff j ) do
52789: LD_ADDR_VAR 0 7
52793: PUSH
52794: LD_VAR 0 6
52798: PUSH
52799: LD_VAR 0 3
52803: DIFF
52804: PUSH
52805: FOR_IN
52806: IFFALSE 52858
// begin if sci = 6 then
52808: LD_VAR 0 8
52812: PUSH
52813: LD_INT 6
52815: EQUAL
52816: IFFALSE 52820
// break ;
52818: GO 52858
// if BuildingStatus ( x ) = bs_idle then
52820: LD_VAR 0 7
52824: PPUSH
52825: CALL_OW 461
52829: PUSH
52830: LD_INT 2
52832: EQUAL
52833: IFFALSE 52856
// sci := sci ^ UnitsInside ( x ) ;
52835: LD_ADDR_VAR 0 8
52839: PUSH
52840: LD_VAR 0 8
52844: PUSH
52845: LD_VAR 0 7
52849: PPUSH
52850: CALL_OW 313
52854: ADD
52855: ST_TO_ADDR
// end ;
52856: GO 52805
52858: POP
52859: POP
// if not sci then
52860: LD_VAR 0 8
52864: NOT
52865: IFFALSE 52869
// continue ;
52867: GO 51914
// for x in sci do
52869: LD_ADDR_VAR 0 7
52873: PUSH
52874: LD_VAR 0 8
52878: PUSH
52879: FOR_IN
52880: IFFALSE 52930
// if IsInUnit ( x ) and not HasTask ( x ) then
52882: LD_VAR 0 7
52886: PPUSH
52887: CALL_OW 310
52891: PUSH
52892: LD_VAR 0 7
52896: PPUSH
52897: CALL_OW 314
52901: NOT
52902: AND
52903: IFFALSE 52928
// begin ComExitBuilding ( x ) ;
52905: LD_VAR 0 7
52909: PPUSH
52910: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52914: LD_VAR 0 7
52918: PPUSH
52919: LD_VAR 0 3
52923: PPUSH
52924: CALL_OW 180
// end ;
52928: GO 52879
52930: POP
52931: POP
// end ; end ;
52932: GO 51914
52934: POP
52935: POP
// end ;
52936: GO 51868
52938: POP
52939: POP
// end ;
52940: LD_VAR 0 1
52944: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52945: LD_INT 0
52947: PPUSH
52948: PPUSH
// if not mc_bases then
52949: LD_EXP 116
52953: NOT
52954: IFFALSE 52958
// exit ;
52956: GO 53039
// for i = 1 to mc_bases do
52958: LD_ADDR_VAR 0 2
52962: PUSH
52963: DOUBLE
52964: LD_INT 1
52966: DEC
52967: ST_TO_ADDR
52968: LD_EXP 116
52972: PUSH
52973: FOR_TO
52974: IFFALSE 53037
// if mc_mines [ i ] and mc_miners [ i ] then
52976: LD_EXP 129
52980: PUSH
52981: LD_VAR 0 2
52985: ARRAY
52986: PUSH
52987: LD_EXP 130
52991: PUSH
52992: LD_VAR 0 2
52996: ARRAY
52997: AND
52998: IFFALSE 53035
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53000: LD_EXP 130
53004: PUSH
53005: LD_VAR 0 2
53009: ARRAY
53010: PUSH
53011: LD_INT 1
53013: ARRAY
53014: PPUSH
53015: CALL_OW 255
53019: PPUSH
53020: LD_EXP 129
53024: PUSH
53025: LD_VAR 0 2
53029: ARRAY
53030: PPUSH
53031: CALL 67653 0 2
53035: GO 52973
53037: POP
53038: POP
// end ;
53039: LD_VAR 0 1
53043: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53044: LD_INT 0
53046: PPUSH
53047: PPUSH
53048: PPUSH
53049: PPUSH
53050: PPUSH
53051: PPUSH
53052: PPUSH
53053: PPUSH
// if not mc_bases or not mc_parking then
53054: LD_EXP 116
53058: NOT
53059: PUSH
53060: LD_EXP 140
53064: NOT
53065: OR
53066: IFFALSE 53070
// exit ;
53068: GO 53780
// for i = 1 to mc_bases do
53070: LD_ADDR_VAR 0 2
53074: PUSH
53075: DOUBLE
53076: LD_INT 1
53078: DEC
53079: ST_TO_ADDR
53080: LD_EXP 116
53084: PUSH
53085: FOR_TO
53086: IFFALSE 53778
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53088: LD_EXP 116
53092: PUSH
53093: LD_VAR 0 2
53097: ARRAY
53098: NOT
53099: PUSH
53100: LD_EXP 140
53104: PUSH
53105: LD_VAR 0 2
53109: ARRAY
53110: NOT
53111: OR
53112: IFFALSE 53116
// continue ;
53114: GO 53085
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53116: LD_ADDR_VAR 0 5
53120: PUSH
53121: LD_EXP 116
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PUSH
53132: LD_INT 1
53134: ARRAY
53135: PPUSH
53136: CALL_OW 255
53140: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53141: LD_ADDR_VAR 0 6
53145: PUSH
53146: LD_EXP 116
53150: PUSH
53151: LD_VAR 0 2
53155: ARRAY
53156: PPUSH
53157: LD_INT 30
53159: PUSH
53160: LD_INT 3
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: PPUSH
53167: CALL_OW 72
53171: ST_TO_ADDR
// if not fac then
53172: LD_VAR 0 6
53176: NOT
53177: IFFALSE 53228
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53179: LD_ADDR_VAR 0 6
53183: PUSH
53184: LD_EXP 116
53188: PUSH
53189: LD_VAR 0 2
53193: ARRAY
53194: PPUSH
53195: LD_INT 2
53197: PUSH
53198: LD_INT 30
53200: PUSH
53201: LD_INT 0
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: PUSH
53208: LD_INT 30
53210: PUSH
53211: LD_INT 1
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: LIST
53222: PPUSH
53223: CALL_OW 72
53227: ST_TO_ADDR
// if not fac then
53228: LD_VAR 0 6
53232: NOT
53233: IFFALSE 53237
// continue ;
53235: GO 53085
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53237: LD_ADDR_VAR 0 7
53241: PUSH
53242: LD_EXP 140
53246: PUSH
53247: LD_VAR 0 2
53251: ARRAY
53252: PPUSH
53253: LD_INT 22
53255: PUSH
53256: LD_VAR 0 5
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PUSH
53265: LD_INT 21
53267: PUSH
53268: LD_INT 2
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: LD_INT 3
53277: PUSH
53278: LD_INT 24
53280: PUSH
53281: LD_INT 1000
53283: PUSH
53284: EMPTY
53285: LIST
53286: LIST
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: PUSH
53292: EMPTY
53293: LIST
53294: LIST
53295: LIST
53296: PPUSH
53297: CALL_OW 70
53301: ST_TO_ADDR
// for j in fac do
53302: LD_ADDR_VAR 0 3
53306: PUSH
53307: LD_VAR 0 6
53311: PUSH
53312: FOR_IN
53313: IFFALSE 53394
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53315: LD_ADDR_VAR 0 7
53319: PUSH
53320: LD_VAR 0 7
53324: PUSH
53325: LD_INT 22
53327: PUSH
53328: LD_VAR 0 5
53332: PUSH
53333: EMPTY
53334: LIST
53335: LIST
53336: PUSH
53337: LD_INT 91
53339: PUSH
53340: LD_VAR 0 3
53344: PUSH
53345: LD_INT 15
53347: PUSH
53348: EMPTY
53349: LIST
53350: LIST
53351: LIST
53352: PUSH
53353: LD_INT 21
53355: PUSH
53356: LD_INT 2
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: PUSH
53363: LD_INT 3
53365: PUSH
53366: LD_INT 24
53368: PUSH
53369: LD_INT 1000
53371: PUSH
53372: EMPTY
53373: LIST
53374: LIST
53375: PUSH
53376: EMPTY
53377: LIST
53378: LIST
53379: PUSH
53380: EMPTY
53381: LIST
53382: LIST
53383: LIST
53384: LIST
53385: PPUSH
53386: CALL_OW 69
53390: UNION
53391: ST_TO_ADDR
53392: GO 53312
53394: POP
53395: POP
// if not vehs then
53396: LD_VAR 0 7
53400: NOT
53401: IFFALSE 53427
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53403: LD_ADDR_EXP 128
53407: PUSH
53408: LD_EXP 128
53412: PPUSH
53413: LD_VAR 0 2
53417: PPUSH
53418: EMPTY
53419: PPUSH
53420: CALL_OW 1
53424: ST_TO_ADDR
// continue ;
53425: GO 53085
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53427: LD_ADDR_VAR 0 8
53431: PUSH
53432: LD_EXP 116
53436: PUSH
53437: LD_VAR 0 2
53441: ARRAY
53442: PPUSH
53443: LD_INT 30
53445: PUSH
53446: LD_INT 3
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PPUSH
53453: CALL_OW 72
53457: ST_TO_ADDR
// if tmp then
53458: LD_VAR 0 8
53462: IFFALSE 53565
// begin for j in tmp do
53464: LD_ADDR_VAR 0 3
53468: PUSH
53469: LD_VAR 0 8
53473: PUSH
53474: FOR_IN
53475: IFFALSE 53563
// for k in UnitsInside ( j ) do
53477: LD_ADDR_VAR 0 4
53481: PUSH
53482: LD_VAR 0 3
53486: PPUSH
53487: CALL_OW 313
53491: PUSH
53492: FOR_IN
53493: IFFALSE 53559
// if k then
53495: LD_VAR 0 4
53499: IFFALSE 53557
// if not k in mc_repair_vehicle [ i ] then
53501: LD_VAR 0 4
53505: PUSH
53506: LD_EXP 128
53510: PUSH
53511: LD_VAR 0 2
53515: ARRAY
53516: IN
53517: NOT
53518: IFFALSE 53557
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53520: LD_ADDR_EXP 128
53524: PUSH
53525: LD_EXP 128
53529: PPUSH
53530: LD_VAR 0 2
53534: PPUSH
53535: LD_EXP 128
53539: PUSH
53540: LD_VAR 0 2
53544: ARRAY
53545: PUSH
53546: LD_VAR 0 4
53550: UNION
53551: PPUSH
53552: CALL_OW 1
53556: ST_TO_ADDR
53557: GO 53492
53559: POP
53560: POP
53561: GO 53474
53563: POP
53564: POP
// end ; if not mc_repair_vehicle [ i ] then
53565: LD_EXP 128
53569: PUSH
53570: LD_VAR 0 2
53574: ARRAY
53575: NOT
53576: IFFALSE 53580
// continue ;
53578: GO 53085
// for j in mc_repair_vehicle [ i ] do
53580: LD_ADDR_VAR 0 3
53584: PUSH
53585: LD_EXP 128
53589: PUSH
53590: LD_VAR 0 2
53594: ARRAY
53595: PUSH
53596: FOR_IN
53597: IFFALSE 53774
// begin if GetClass ( j ) <> 3 then
53599: LD_VAR 0 3
53603: PPUSH
53604: CALL_OW 257
53608: PUSH
53609: LD_INT 3
53611: NONEQUAL
53612: IFFALSE 53653
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53614: LD_ADDR_EXP 128
53618: PUSH
53619: LD_EXP 128
53623: PPUSH
53624: LD_VAR 0 2
53628: PPUSH
53629: LD_EXP 128
53633: PUSH
53634: LD_VAR 0 2
53638: ARRAY
53639: PUSH
53640: LD_VAR 0 3
53644: DIFF
53645: PPUSH
53646: CALL_OW 1
53650: ST_TO_ADDR
// continue ;
53651: GO 53596
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53653: LD_VAR 0 3
53657: PPUSH
53658: CALL_OW 311
53662: NOT
53663: PUSH
53664: LD_VAR 0 3
53668: PUSH
53669: LD_EXP 119
53673: PUSH
53674: LD_VAR 0 2
53678: ARRAY
53679: PUSH
53680: LD_INT 1
53682: ARRAY
53683: IN
53684: NOT
53685: AND
53686: PUSH
53687: LD_VAR 0 3
53691: PUSH
53692: LD_EXP 119
53696: PUSH
53697: LD_VAR 0 2
53701: ARRAY
53702: PUSH
53703: LD_INT 2
53705: ARRAY
53706: IN
53707: NOT
53708: AND
53709: IFFALSE 53772
// begin if IsInUnit ( j ) then
53711: LD_VAR 0 3
53715: PPUSH
53716: CALL_OW 310
53720: IFFALSE 53733
// ComExitBuilding ( j ) else
53722: LD_VAR 0 3
53726: PPUSH
53727: CALL_OW 122
53731: GO 53772
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53733: LD_VAR 0 3
53737: PPUSH
53738: LD_VAR 0 7
53742: PUSH
53743: LD_INT 1
53745: ARRAY
53746: PPUSH
53747: CALL 104307 0 2
53751: NOT
53752: IFFALSE 53772
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53754: LD_VAR 0 3
53758: PPUSH
53759: LD_VAR 0 7
53763: PUSH
53764: LD_INT 1
53766: ARRAY
53767: PPUSH
53768: CALL_OW 129
// end ; end ;
53772: GO 53596
53774: POP
53775: POP
// end ;
53776: GO 53085
53778: POP
53779: POP
// end ;
53780: LD_VAR 0 1
53784: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53785: LD_INT 0
53787: PPUSH
53788: PPUSH
53789: PPUSH
53790: PPUSH
53791: PPUSH
53792: PPUSH
53793: PPUSH
53794: PPUSH
53795: PPUSH
53796: PPUSH
53797: PPUSH
// if not mc_bases then
53798: LD_EXP 116
53802: NOT
53803: IFFALSE 53807
// exit ;
53805: GO 54609
// for i = 1 to mc_bases do
53807: LD_ADDR_VAR 0 2
53811: PUSH
53812: DOUBLE
53813: LD_INT 1
53815: DEC
53816: ST_TO_ADDR
53817: LD_EXP 116
53821: PUSH
53822: FOR_TO
53823: IFFALSE 54607
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53825: LD_EXP 144
53829: PUSH
53830: LD_VAR 0 2
53834: ARRAY
53835: NOT
53836: PUSH
53837: LD_EXP 119
53841: PUSH
53842: LD_VAR 0 2
53846: ARRAY
53847: PUSH
53848: LD_INT 1
53850: ARRAY
53851: OR
53852: PUSH
53853: LD_EXP 119
53857: PUSH
53858: LD_VAR 0 2
53862: ARRAY
53863: PUSH
53864: LD_INT 2
53866: ARRAY
53867: OR
53868: PUSH
53869: LD_EXP 142
53873: PUSH
53874: LD_VAR 0 2
53878: ARRAY
53879: PPUSH
53880: LD_INT 1
53882: PPUSH
53883: CALL_OW 325
53887: NOT
53888: OR
53889: PUSH
53890: LD_EXP 139
53894: PUSH
53895: LD_VAR 0 2
53899: ARRAY
53900: OR
53901: IFFALSE 53905
// continue ;
53903: GO 53822
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53905: LD_ADDR_VAR 0 8
53909: PUSH
53910: LD_EXP 116
53914: PUSH
53915: LD_VAR 0 2
53919: ARRAY
53920: PPUSH
53921: LD_INT 25
53923: PUSH
53924: LD_INT 4
53926: PUSH
53927: EMPTY
53928: LIST
53929: LIST
53930: PUSH
53931: LD_INT 50
53933: PUSH
53934: EMPTY
53935: LIST
53936: PUSH
53937: LD_INT 3
53939: PUSH
53940: LD_INT 60
53942: PUSH
53943: EMPTY
53944: LIST
53945: PUSH
53946: EMPTY
53947: LIST
53948: LIST
53949: PUSH
53950: EMPTY
53951: LIST
53952: LIST
53953: LIST
53954: PPUSH
53955: CALL_OW 72
53959: PUSH
53960: LD_EXP 120
53964: PUSH
53965: LD_VAR 0 2
53969: ARRAY
53970: DIFF
53971: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53972: LD_ADDR_VAR 0 9
53976: PUSH
53977: LD_EXP 116
53981: PUSH
53982: LD_VAR 0 2
53986: ARRAY
53987: PPUSH
53988: LD_INT 2
53990: PUSH
53991: LD_INT 30
53993: PUSH
53994: LD_INT 0
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PUSH
54001: LD_INT 30
54003: PUSH
54004: LD_INT 1
54006: PUSH
54007: EMPTY
54008: LIST
54009: LIST
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: LIST
54015: PPUSH
54016: CALL_OW 72
54020: ST_TO_ADDR
// if not tmp or not dep then
54021: LD_VAR 0 8
54025: NOT
54026: PUSH
54027: LD_VAR 0 9
54031: NOT
54032: OR
54033: IFFALSE 54037
// continue ;
54035: GO 53822
// side := GetSide ( tmp [ 1 ] ) ;
54037: LD_ADDR_VAR 0 11
54041: PUSH
54042: LD_VAR 0 8
54046: PUSH
54047: LD_INT 1
54049: ARRAY
54050: PPUSH
54051: CALL_OW 255
54055: ST_TO_ADDR
// dep := dep [ 1 ] ;
54056: LD_ADDR_VAR 0 9
54060: PUSH
54061: LD_VAR 0 9
54065: PUSH
54066: LD_INT 1
54068: ARRAY
54069: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54070: LD_ADDR_VAR 0 7
54074: PUSH
54075: LD_EXP 144
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: PPUSH
54086: LD_INT 22
54088: PUSH
54089: LD_INT 0
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: LD_INT 25
54098: PUSH
54099: LD_INT 12
54101: PUSH
54102: EMPTY
54103: LIST
54104: LIST
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: PPUSH
54110: CALL_OW 70
54114: PUSH
54115: LD_INT 22
54117: PUSH
54118: LD_INT 0
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PUSH
54125: LD_INT 25
54127: PUSH
54128: LD_INT 12
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PUSH
54135: LD_INT 91
54137: PUSH
54138: LD_VAR 0 9
54142: PUSH
54143: LD_INT 20
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: LIST
54150: PUSH
54151: EMPTY
54152: LIST
54153: LIST
54154: LIST
54155: PPUSH
54156: CALL_OW 69
54160: UNION
54161: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54162: LD_ADDR_VAR 0 10
54166: PUSH
54167: LD_EXP 144
54171: PUSH
54172: LD_VAR 0 2
54176: ARRAY
54177: PPUSH
54178: LD_INT 81
54180: PUSH
54181: LD_VAR 0 11
54185: PUSH
54186: EMPTY
54187: LIST
54188: LIST
54189: PPUSH
54190: CALL_OW 70
54194: ST_TO_ADDR
// if not apes or danger_at_area then
54195: LD_VAR 0 7
54199: NOT
54200: PUSH
54201: LD_VAR 0 10
54205: OR
54206: IFFALSE 54256
// begin if mc_taming [ i ] then
54208: LD_EXP 147
54212: PUSH
54213: LD_VAR 0 2
54217: ARRAY
54218: IFFALSE 54254
// begin MC_Reset ( i , 121 ) ;
54220: LD_VAR 0 2
54224: PPUSH
54225: LD_INT 121
54227: PPUSH
54228: CALL 39389 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54232: LD_ADDR_EXP 147
54236: PUSH
54237: LD_EXP 147
54241: PPUSH
54242: LD_VAR 0 2
54246: PPUSH
54247: EMPTY
54248: PPUSH
54249: CALL_OW 1
54253: ST_TO_ADDR
// end ; continue ;
54254: GO 53822
// end ; for j in tmp do
54256: LD_ADDR_VAR 0 3
54260: PUSH
54261: LD_VAR 0 8
54265: PUSH
54266: FOR_IN
54267: IFFALSE 54603
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54269: LD_VAR 0 3
54273: PUSH
54274: LD_EXP 147
54278: PUSH
54279: LD_VAR 0 2
54283: ARRAY
54284: IN
54285: NOT
54286: PUSH
54287: LD_EXP 147
54291: PUSH
54292: LD_VAR 0 2
54296: ARRAY
54297: PUSH
54298: LD_INT 3
54300: LESS
54301: AND
54302: IFFALSE 54360
// begin SetTag ( j , 121 ) ;
54304: LD_VAR 0 3
54308: PPUSH
54309: LD_INT 121
54311: PPUSH
54312: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54316: LD_ADDR_EXP 147
54320: PUSH
54321: LD_EXP 147
54325: PPUSH
54326: LD_VAR 0 2
54330: PUSH
54331: LD_EXP 147
54335: PUSH
54336: LD_VAR 0 2
54340: ARRAY
54341: PUSH
54342: LD_INT 1
54344: PLUS
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: PPUSH
54350: LD_VAR 0 3
54354: PPUSH
54355: CALL 70700 0 3
54359: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54360: LD_VAR 0 3
54364: PUSH
54365: LD_EXP 147
54369: PUSH
54370: LD_VAR 0 2
54374: ARRAY
54375: IN
54376: IFFALSE 54601
// begin if GetClass ( j ) <> 4 then
54378: LD_VAR 0 3
54382: PPUSH
54383: CALL_OW 257
54387: PUSH
54388: LD_INT 4
54390: NONEQUAL
54391: IFFALSE 54444
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54393: LD_ADDR_EXP 147
54397: PUSH
54398: LD_EXP 147
54402: PPUSH
54403: LD_VAR 0 2
54407: PPUSH
54408: LD_EXP 147
54412: PUSH
54413: LD_VAR 0 2
54417: ARRAY
54418: PUSH
54419: LD_VAR 0 3
54423: DIFF
54424: PPUSH
54425: CALL_OW 1
54429: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54430: LD_VAR 0 3
54434: PPUSH
54435: LD_INT 0
54437: PPUSH
54438: CALL_OW 109
// continue ;
54442: GO 54266
// end ; if IsInUnit ( j ) then
54444: LD_VAR 0 3
54448: PPUSH
54449: CALL_OW 310
54453: IFFALSE 54464
// ComExitBuilding ( j ) ;
54455: LD_VAR 0 3
54459: PPUSH
54460: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54464: LD_ADDR_VAR 0 6
54468: PUSH
54469: LD_VAR 0 7
54473: PPUSH
54474: LD_VAR 0 3
54478: PPUSH
54479: CALL_OW 74
54483: ST_TO_ADDR
// if not ape then
54484: LD_VAR 0 6
54488: NOT
54489: IFFALSE 54493
// break ;
54491: GO 54603
// x := GetX ( ape ) ;
54493: LD_ADDR_VAR 0 4
54497: PUSH
54498: LD_VAR 0 6
54502: PPUSH
54503: CALL_OW 250
54507: ST_TO_ADDR
// y := GetY ( ape ) ;
54508: LD_ADDR_VAR 0 5
54512: PUSH
54513: LD_VAR 0 6
54517: PPUSH
54518: CALL_OW 251
54522: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54523: LD_VAR 0 4
54527: PPUSH
54528: LD_VAR 0 5
54532: PPUSH
54533: CALL_OW 488
54537: NOT
54538: PUSH
54539: LD_VAR 0 11
54543: PPUSH
54544: LD_VAR 0 4
54548: PPUSH
54549: LD_VAR 0 5
54553: PPUSH
54554: LD_INT 20
54556: PPUSH
54557: CALL 71596 0 4
54561: PUSH
54562: LD_INT 4
54564: ARRAY
54565: OR
54566: IFFALSE 54570
// break ;
54568: GO 54603
// if not HasTask ( j ) then
54570: LD_VAR 0 3
54574: PPUSH
54575: CALL_OW 314
54579: NOT
54580: IFFALSE 54601
// ComTameXY ( j , x , y ) ;
54582: LD_VAR 0 3
54586: PPUSH
54587: LD_VAR 0 4
54591: PPUSH
54592: LD_VAR 0 5
54596: PPUSH
54597: CALL_OW 131
// end ; end ;
54601: GO 54266
54603: POP
54604: POP
// end ;
54605: GO 53822
54607: POP
54608: POP
// end ;
54609: LD_VAR 0 1
54613: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54614: LD_INT 0
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
54623: PPUSH
// if not mc_bases then
54624: LD_EXP 116
54628: NOT
54629: IFFALSE 54633
// exit ;
54631: GO 55259
// for i = 1 to mc_bases do
54633: LD_ADDR_VAR 0 2
54637: PUSH
54638: DOUBLE
54639: LD_INT 1
54641: DEC
54642: ST_TO_ADDR
54643: LD_EXP 116
54647: PUSH
54648: FOR_TO
54649: IFFALSE 55257
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54651: LD_EXP 145
54655: PUSH
54656: LD_VAR 0 2
54660: ARRAY
54661: NOT
54662: PUSH
54663: LD_EXP 145
54667: PUSH
54668: LD_VAR 0 2
54672: ARRAY
54673: PPUSH
54674: LD_INT 25
54676: PUSH
54677: LD_INT 12
54679: PUSH
54680: EMPTY
54681: LIST
54682: LIST
54683: PPUSH
54684: CALL_OW 72
54688: NOT
54689: OR
54690: IFFALSE 54694
// continue ;
54692: GO 54648
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54694: LD_ADDR_VAR 0 5
54698: PUSH
54699: LD_EXP 145
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: PUSH
54710: LD_INT 1
54712: ARRAY
54713: PPUSH
54714: CALL_OW 255
54718: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54719: LD_VAR 0 5
54723: PPUSH
54724: LD_INT 2
54726: PPUSH
54727: CALL_OW 325
54731: IFFALSE 54984
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54733: LD_ADDR_VAR 0 4
54737: PUSH
54738: LD_EXP 145
54742: PUSH
54743: LD_VAR 0 2
54747: ARRAY
54748: PPUSH
54749: LD_INT 25
54751: PUSH
54752: LD_INT 16
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: PPUSH
54759: CALL_OW 72
54763: ST_TO_ADDR
// if tmp < 6 then
54764: LD_VAR 0 4
54768: PUSH
54769: LD_INT 6
54771: LESS
54772: IFFALSE 54984
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54774: LD_ADDR_VAR 0 6
54778: PUSH
54779: LD_EXP 116
54783: PUSH
54784: LD_VAR 0 2
54788: ARRAY
54789: PPUSH
54790: LD_INT 2
54792: PUSH
54793: LD_INT 30
54795: PUSH
54796: LD_INT 0
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PUSH
54803: LD_INT 30
54805: PUSH
54806: LD_INT 1
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: LIST
54817: PPUSH
54818: CALL_OW 72
54822: ST_TO_ADDR
// if depot then
54823: LD_VAR 0 6
54827: IFFALSE 54984
// begin selected := 0 ;
54829: LD_ADDR_VAR 0 7
54833: PUSH
54834: LD_INT 0
54836: ST_TO_ADDR
// for j in depot do
54837: LD_ADDR_VAR 0 3
54841: PUSH
54842: LD_VAR 0 6
54846: PUSH
54847: FOR_IN
54848: IFFALSE 54879
// begin if UnitsInside ( j ) < 6 then
54850: LD_VAR 0 3
54854: PPUSH
54855: CALL_OW 313
54859: PUSH
54860: LD_INT 6
54862: LESS
54863: IFFALSE 54877
// begin selected := j ;
54865: LD_ADDR_VAR 0 7
54869: PUSH
54870: LD_VAR 0 3
54874: ST_TO_ADDR
// break ;
54875: GO 54879
// end ; end ;
54877: GO 54847
54879: POP
54880: POP
// if selected then
54881: LD_VAR 0 7
54885: IFFALSE 54984
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54887: LD_ADDR_VAR 0 3
54891: PUSH
54892: LD_EXP 145
54896: PUSH
54897: LD_VAR 0 2
54901: ARRAY
54902: PPUSH
54903: LD_INT 25
54905: PUSH
54906: LD_INT 12
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: PPUSH
54913: CALL_OW 72
54917: PUSH
54918: FOR_IN
54919: IFFALSE 54982
// if not HasTask ( j ) then
54921: LD_VAR 0 3
54925: PPUSH
54926: CALL_OW 314
54930: NOT
54931: IFFALSE 54980
// begin if not IsInUnit ( j ) then
54933: LD_VAR 0 3
54937: PPUSH
54938: CALL_OW 310
54942: NOT
54943: IFFALSE 54959
// ComEnterUnit ( j , selected ) ;
54945: LD_VAR 0 3
54949: PPUSH
54950: LD_VAR 0 7
54954: PPUSH
54955: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54959: LD_VAR 0 3
54963: PPUSH
54964: LD_INT 16
54966: PPUSH
54967: CALL_OW 183
// AddComExitBuilding ( j ) ;
54971: LD_VAR 0 3
54975: PPUSH
54976: CALL_OW 182
// end ;
54980: GO 54918
54982: POP
54983: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54984: LD_VAR 0 5
54988: PPUSH
54989: LD_INT 11
54991: PPUSH
54992: CALL_OW 325
54996: IFFALSE 55255
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54998: LD_ADDR_VAR 0 4
55002: PUSH
55003: LD_EXP 145
55007: PUSH
55008: LD_VAR 0 2
55012: ARRAY
55013: PPUSH
55014: LD_INT 25
55016: PUSH
55017: LD_INT 16
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: PPUSH
55024: CALL_OW 72
55028: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55029: LD_VAR 0 4
55033: PUSH
55034: LD_INT 6
55036: GREATEREQUAL
55037: PUSH
55038: LD_VAR 0 5
55042: PPUSH
55043: LD_INT 2
55045: PPUSH
55046: CALL_OW 325
55050: NOT
55051: OR
55052: IFFALSE 55255
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55054: LD_ADDR_VAR 0 8
55058: PUSH
55059: LD_EXP 116
55063: PUSH
55064: LD_VAR 0 2
55068: ARRAY
55069: PPUSH
55070: LD_INT 2
55072: PUSH
55073: LD_INT 30
55075: PUSH
55076: LD_INT 4
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: PUSH
55083: LD_INT 30
55085: PUSH
55086: LD_INT 5
55088: PUSH
55089: EMPTY
55090: LIST
55091: LIST
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: PPUSH
55098: CALL_OW 72
55102: ST_TO_ADDR
// if barracks then
55103: LD_VAR 0 8
55107: IFFALSE 55255
// begin selected := 0 ;
55109: LD_ADDR_VAR 0 7
55113: PUSH
55114: LD_INT 0
55116: ST_TO_ADDR
// for j in barracks do
55117: LD_ADDR_VAR 0 3
55121: PUSH
55122: LD_VAR 0 8
55126: PUSH
55127: FOR_IN
55128: IFFALSE 55159
// begin if UnitsInside ( j ) < 6 then
55130: LD_VAR 0 3
55134: PPUSH
55135: CALL_OW 313
55139: PUSH
55140: LD_INT 6
55142: LESS
55143: IFFALSE 55157
// begin selected := j ;
55145: LD_ADDR_VAR 0 7
55149: PUSH
55150: LD_VAR 0 3
55154: ST_TO_ADDR
// break ;
55155: GO 55159
// end ; end ;
55157: GO 55127
55159: POP
55160: POP
// if selected then
55161: LD_VAR 0 7
55165: IFFALSE 55255
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55167: LD_ADDR_VAR 0 3
55171: PUSH
55172: LD_EXP 145
55176: PUSH
55177: LD_VAR 0 2
55181: ARRAY
55182: PPUSH
55183: LD_INT 25
55185: PUSH
55186: LD_INT 12
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: PPUSH
55193: CALL_OW 72
55197: PUSH
55198: FOR_IN
55199: IFFALSE 55253
// if not IsInUnit ( j ) and not HasTask ( j ) then
55201: LD_VAR 0 3
55205: PPUSH
55206: CALL_OW 310
55210: NOT
55211: PUSH
55212: LD_VAR 0 3
55216: PPUSH
55217: CALL_OW 314
55221: NOT
55222: AND
55223: IFFALSE 55251
// begin ComEnterUnit ( j , selected ) ;
55225: LD_VAR 0 3
55229: PPUSH
55230: LD_VAR 0 7
55234: PPUSH
55235: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55239: LD_VAR 0 3
55243: PPUSH
55244: LD_INT 15
55246: PPUSH
55247: CALL_OW 183
// end ;
55251: GO 55198
55253: POP
55254: POP
// end ; end ; end ; end ; end ;
55255: GO 54648
55257: POP
55258: POP
// end ;
55259: LD_VAR 0 1
55263: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55264: LD_INT 0
55266: PPUSH
55267: PPUSH
55268: PPUSH
55269: PPUSH
// if not mc_bases then
55270: LD_EXP 116
55274: NOT
55275: IFFALSE 55279
// exit ;
55277: GO 55457
// for i = 1 to mc_bases do
55279: LD_ADDR_VAR 0 2
55283: PUSH
55284: DOUBLE
55285: LD_INT 1
55287: DEC
55288: ST_TO_ADDR
55289: LD_EXP 116
55293: PUSH
55294: FOR_TO
55295: IFFALSE 55455
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55297: LD_ADDR_VAR 0 4
55301: PUSH
55302: LD_EXP 116
55306: PUSH
55307: LD_VAR 0 2
55311: ARRAY
55312: PPUSH
55313: LD_INT 25
55315: PUSH
55316: LD_INT 9
55318: PUSH
55319: EMPTY
55320: LIST
55321: LIST
55322: PPUSH
55323: CALL_OW 72
55327: ST_TO_ADDR
// if not tmp then
55328: LD_VAR 0 4
55332: NOT
55333: IFFALSE 55337
// continue ;
55335: GO 55294
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55337: LD_EXP 142
55341: PUSH
55342: LD_VAR 0 2
55346: ARRAY
55347: PPUSH
55348: LD_INT 29
55350: PPUSH
55351: CALL_OW 325
55355: NOT
55356: PUSH
55357: LD_EXP 142
55361: PUSH
55362: LD_VAR 0 2
55366: ARRAY
55367: PPUSH
55368: LD_INT 28
55370: PPUSH
55371: CALL_OW 325
55375: NOT
55376: AND
55377: IFFALSE 55381
// continue ;
55379: GO 55294
// for j in tmp do
55381: LD_ADDR_VAR 0 3
55385: PUSH
55386: LD_VAR 0 4
55390: PUSH
55391: FOR_IN
55392: IFFALSE 55451
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55394: LD_VAR 0 3
55398: PUSH
55399: LD_EXP 119
55403: PUSH
55404: LD_VAR 0 2
55408: ARRAY
55409: PUSH
55410: LD_INT 1
55412: ARRAY
55413: IN
55414: NOT
55415: PUSH
55416: LD_VAR 0 3
55420: PUSH
55421: LD_EXP 119
55425: PUSH
55426: LD_VAR 0 2
55430: ARRAY
55431: PUSH
55432: LD_INT 2
55434: ARRAY
55435: IN
55436: NOT
55437: AND
55438: IFFALSE 55449
// ComSpaceTimeShoot ( j ) ;
55440: LD_VAR 0 3
55444: PPUSH
55445: CALL 66661 0 1
55449: GO 55391
55451: POP
55452: POP
// end ;
55453: GO 55294
55455: POP
55456: POP
// end ;
55457: LD_VAR 0 1
55461: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55462: LD_INT 0
55464: PPUSH
55465: PPUSH
55466: PPUSH
55467: PPUSH
55468: PPUSH
55469: PPUSH
55470: PPUSH
55471: PPUSH
55472: PPUSH
// if not mc_bases then
55473: LD_EXP 116
55477: NOT
55478: IFFALSE 55482
// exit ;
55480: GO 56104
// for i = 1 to mc_bases do
55482: LD_ADDR_VAR 0 2
55486: PUSH
55487: DOUBLE
55488: LD_INT 1
55490: DEC
55491: ST_TO_ADDR
55492: LD_EXP 116
55496: PUSH
55497: FOR_TO
55498: IFFALSE 56102
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55500: LD_EXP 151
55504: PUSH
55505: LD_VAR 0 2
55509: ARRAY
55510: NOT
55511: PUSH
55512: LD_INT 38
55514: PPUSH
55515: LD_EXP 142
55519: PUSH
55520: LD_VAR 0 2
55524: ARRAY
55525: PPUSH
55526: CALL_OW 321
55530: PUSH
55531: LD_INT 2
55533: NONEQUAL
55534: OR
55535: IFFALSE 55539
// continue ;
55537: GO 55497
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55539: LD_ADDR_VAR 0 8
55543: PUSH
55544: LD_EXP 116
55548: PUSH
55549: LD_VAR 0 2
55553: ARRAY
55554: PPUSH
55555: LD_INT 30
55557: PUSH
55558: LD_INT 34
55560: PUSH
55561: EMPTY
55562: LIST
55563: LIST
55564: PPUSH
55565: CALL_OW 72
55569: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55570: LD_ADDR_VAR 0 9
55574: PUSH
55575: LD_EXP 116
55579: PUSH
55580: LD_VAR 0 2
55584: ARRAY
55585: PPUSH
55586: LD_INT 25
55588: PUSH
55589: LD_INT 4
55591: PUSH
55592: EMPTY
55593: LIST
55594: LIST
55595: PPUSH
55596: CALL_OW 72
55600: PPUSH
55601: LD_INT 0
55603: PPUSH
55604: CALL 99969 0 2
55608: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55609: LD_VAR 0 9
55613: NOT
55614: PUSH
55615: LD_VAR 0 8
55619: NOT
55620: OR
55621: PUSH
55622: LD_EXP 116
55626: PUSH
55627: LD_VAR 0 2
55631: ARRAY
55632: PPUSH
55633: LD_INT 124
55635: PPUSH
55636: CALL 99969 0 2
55640: OR
55641: IFFALSE 55645
// continue ;
55643: GO 55497
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55645: LD_EXP 152
55649: PUSH
55650: LD_VAR 0 2
55654: ARRAY
55655: PUSH
55656: LD_EXP 151
55660: PUSH
55661: LD_VAR 0 2
55665: ARRAY
55666: LESS
55667: PUSH
55668: LD_EXP 152
55672: PUSH
55673: LD_VAR 0 2
55677: ARRAY
55678: PUSH
55679: LD_VAR 0 8
55683: LESS
55684: AND
55685: IFFALSE 56100
// begin tmp := sci [ 1 ] ;
55687: LD_ADDR_VAR 0 7
55691: PUSH
55692: LD_VAR 0 9
55696: PUSH
55697: LD_INT 1
55699: ARRAY
55700: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55701: LD_VAR 0 7
55705: PPUSH
55706: LD_INT 124
55708: PPUSH
55709: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55713: LD_ADDR_VAR 0 3
55717: PUSH
55718: DOUBLE
55719: LD_EXP 151
55723: PUSH
55724: LD_VAR 0 2
55728: ARRAY
55729: INC
55730: ST_TO_ADDR
55731: LD_EXP 151
55735: PUSH
55736: LD_VAR 0 2
55740: ARRAY
55741: PUSH
55742: FOR_DOWNTO
55743: IFFALSE 56086
// begin if IsInUnit ( tmp ) then
55745: LD_VAR 0 7
55749: PPUSH
55750: CALL_OW 310
55754: IFFALSE 55765
// ComExitBuilding ( tmp ) ;
55756: LD_VAR 0 7
55760: PPUSH
55761: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55765: LD_INT 35
55767: PPUSH
55768: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55772: LD_VAR 0 7
55776: PPUSH
55777: CALL_OW 310
55781: NOT
55782: PUSH
55783: LD_VAR 0 7
55787: PPUSH
55788: CALL_OW 314
55792: NOT
55793: AND
55794: IFFALSE 55765
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55796: LD_ADDR_VAR 0 6
55800: PUSH
55801: LD_VAR 0 7
55805: PPUSH
55806: CALL_OW 250
55810: PUSH
55811: LD_VAR 0 7
55815: PPUSH
55816: CALL_OW 251
55820: PUSH
55821: EMPTY
55822: LIST
55823: LIST
55824: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55825: LD_INT 35
55827: PPUSH
55828: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55832: LD_ADDR_VAR 0 4
55836: PUSH
55837: LD_EXP 151
55841: PUSH
55842: LD_VAR 0 2
55846: ARRAY
55847: PUSH
55848: LD_VAR 0 3
55852: ARRAY
55853: PUSH
55854: LD_INT 1
55856: ARRAY
55857: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55858: LD_ADDR_VAR 0 5
55862: PUSH
55863: LD_EXP 151
55867: PUSH
55868: LD_VAR 0 2
55872: ARRAY
55873: PUSH
55874: LD_VAR 0 3
55878: ARRAY
55879: PUSH
55880: LD_INT 2
55882: ARRAY
55883: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55884: LD_VAR 0 7
55888: PPUSH
55889: LD_INT 10
55891: PPUSH
55892: CALL 73299 0 2
55896: PUSH
55897: LD_INT 4
55899: ARRAY
55900: IFFALSE 55938
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55902: LD_VAR 0 7
55906: PPUSH
55907: LD_VAR 0 6
55911: PUSH
55912: LD_INT 1
55914: ARRAY
55915: PPUSH
55916: LD_VAR 0 6
55920: PUSH
55921: LD_INT 2
55923: ARRAY
55924: PPUSH
55925: CALL_OW 111
// wait ( 0 0$10 ) ;
55929: LD_INT 350
55931: PPUSH
55932: CALL_OW 67
// end else
55936: GO 55964
// begin ComMoveXY ( tmp , x , y ) ;
55938: LD_VAR 0 7
55942: PPUSH
55943: LD_VAR 0 4
55947: PPUSH
55948: LD_VAR 0 5
55952: PPUSH
55953: CALL_OW 111
// wait ( 0 0$3 ) ;
55957: LD_INT 105
55959: PPUSH
55960: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55964: LD_VAR 0 7
55968: PPUSH
55969: LD_VAR 0 4
55973: PPUSH
55974: LD_VAR 0 5
55978: PPUSH
55979: CALL_OW 307
55983: IFFALSE 55825
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55985: LD_VAR 0 7
55989: PPUSH
55990: LD_VAR 0 4
55994: PPUSH
55995: LD_VAR 0 5
55999: PPUSH
56000: LD_VAR 0 8
56004: PUSH
56005: LD_VAR 0 3
56009: ARRAY
56010: PPUSH
56011: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56015: LD_INT 35
56017: PPUSH
56018: CALL_OW 67
// until not HasTask ( tmp ) ;
56022: LD_VAR 0 7
56026: PPUSH
56027: CALL_OW 314
56031: NOT
56032: IFFALSE 56015
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56034: LD_ADDR_EXP 152
56038: PUSH
56039: LD_EXP 152
56043: PPUSH
56044: LD_VAR 0 2
56048: PUSH
56049: LD_EXP 152
56053: PUSH
56054: LD_VAR 0 2
56058: ARRAY
56059: PUSH
56060: LD_INT 1
56062: PLUS
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: PPUSH
56068: LD_VAR 0 8
56072: PUSH
56073: LD_VAR 0 3
56077: ARRAY
56078: PPUSH
56079: CALL 70700 0 3
56083: ST_TO_ADDR
// end ;
56084: GO 55742
56086: POP
56087: POP
// MC_Reset ( i , 124 ) ;
56088: LD_VAR 0 2
56092: PPUSH
56093: LD_INT 124
56095: PPUSH
56096: CALL 39389 0 2
// end ; end ;
56100: GO 55497
56102: POP
56103: POP
// end ;
56104: LD_VAR 0 1
56108: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56109: LD_INT 0
56111: PPUSH
56112: PPUSH
56113: PPUSH
// if not mc_bases then
56114: LD_EXP 116
56118: NOT
56119: IFFALSE 56123
// exit ;
56121: GO 56729
// for i = 1 to mc_bases do
56123: LD_ADDR_VAR 0 2
56127: PUSH
56128: DOUBLE
56129: LD_INT 1
56131: DEC
56132: ST_TO_ADDR
56133: LD_EXP 116
56137: PUSH
56138: FOR_TO
56139: IFFALSE 56727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56141: LD_ADDR_VAR 0 3
56145: PUSH
56146: LD_EXP 116
56150: PUSH
56151: LD_VAR 0 2
56155: ARRAY
56156: PPUSH
56157: LD_INT 25
56159: PUSH
56160: LD_INT 4
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: PPUSH
56167: CALL_OW 72
56171: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56172: LD_VAR 0 3
56176: NOT
56177: PUSH
56178: LD_EXP 153
56182: PUSH
56183: LD_VAR 0 2
56187: ARRAY
56188: NOT
56189: OR
56190: PUSH
56191: LD_EXP 116
56195: PUSH
56196: LD_VAR 0 2
56200: ARRAY
56201: PPUSH
56202: LD_INT 2
56204: PUSH
56205: LD_INT 30
56207: PUSH
56208: LD_INT 0
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: PUSH
56215: LD_INT 30
56217: PUSH
56218: LD_INT 1
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: LIST
56229: PPUSH
56230: CALL_OW 72
56234: NOT
56235: OR
56236: IFFALSE 56286
// begin if mc_deposits_finder [ i ] then
56238: LD_EXP 154
56242: PUSH
56243: LD_VAR 0 2
56247: ARRAY
56248: IFFALSE 56284
// begin MC_Reset ( i , 125 ) ;
56250: LD_VAR 0 2
56254: PPUSH
56255: LD_INT 125
56257: PPUSH
56258: CALL 39389 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56262: LD_ADDR_EXP 154
56266: PUSH
56267: LD_EXP 154
56271: PPUSH
56272: LD_VAR 0 2
56276: PPUSH
56277: EMPTY
56278: PPUSH
56279: CALL_OW 1
56283: ST_TO_ADDR
// end ; continue ;
56284: GO 56138
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56286: LD_EXP 153
56290: PUSH
56291: LD_VAR 0 2
56295: ARRAY
56296: PUSH
56297: LD_INT 1
56299: ARRAY
56300: PUSH
56301: LD_INT 3
56303: ARRAY
56304: PUSH
56305: LD_INT 1
56307: EQUAL
56308: PUSH
56309: LD_INT 20
56311: PPUSH
56312: LD_EXP 142
56316: PUSH
56317: LD_VAR 0 2
56321: ARRAY
56322: PPUSH
56323: CALL_OW 321
56327: PUSH
56328: LD_INT 2
56330: NONEQUAL
56331: AND
56332: IFFALSE 56382
// begin if mc_deposits_finder [ i ] then
56334: LD_EXP 154
56338: PUSH
56339: LD_VAR 0 2
56343: ARRAY
56344: IFFALSE 56380
// begin MC_Reset ( i , 125 ) ;
56346: LD_VAR 0 2
56350: PPUSH
56351: LD_INT 125
56353: PPUSH
56354: CALL 39389 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56358: LD_ADDR_EXP 154
56362: PUSH
56363: LD_EXP 154
56367: PPUSH
56368: LD_VAR 0 2
56372: PPUSH
56373: EMPTY
56374: PPUSH
56375: CALL_OW 1
56379: ST_TO_ADDR
// end ; continue ;
56380: GO 56138
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56382: LD_EXP 153
56386: PUSH
56387: LD_VAR 0 2
56391: ARRAY
56392: PUSH
56393: LD_INT 1
56395: ARRAY
56396: PUSH
56397: LD_INT 1
56399: ARRAY
56400: PPUSH
56401: LD_EXP 153
56405: PUSH
56406: LD_VAR 0 2
56410: ARRAY
56411: PUSH
56412: LD_INT 1
56414: ARRAY
56415: PUSH
56416: LD_INT 2
56418: ARRAY
56419: PPUSH
56420: LD_EXP 142
56424: PUSH
56425: LD_VAR 0 2
56429: ARRAY
56430: PPUSH
56431: CALL_OW 440
56435: IFFALSE 56478
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56437: LD_ADDR_EXP 153
56441: PUSH
56442: LD_EXP 153
56446: PPUSH
56447: LD_VAR 0 2
56451: PPUSH
56452: LD_EXP 153
56456: PUSH
56457: LD_VAR 0 2
56461: ARRAY
56462: PPUSH
56463: LD_INT 1
56465: PPUSH
56466: CALL_OW 3
56470: PPUSH
56471: CALL_OW 1
56475: ST_TO_ADDR
56476: GO 56725
// begin if not mc_deposits_finder [ i ] then
56478: LD_EXP 154
56482: PUSH
56483: LD_VAR 0 2
56487: ARRAY
56488: NOT
56489: IFFALSE 56541
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56491: LD_ADDR_EXP 154
56495: PUSH
56496: LD_EXP 154
56500: PPUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: LD_VAR 0 3
56510: PUSH
56511: LD_INT 1
56513: ARRAY
56514: PUSH
56515: EMPTY
56516: LIST
56517: PPUSH
56518: CALL_OW 1
56522: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56523: LD_VAR 0 3
56527: PUSH
56528: LD_INT 1
56530: ARRAY
56531: PPUSH
56532: LD_INT 125
56534: PPUSH
56535: CALL_OW 109
// end else
56539: GO 56725
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56541: LD_EXP 154
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: PUSH
56552: LD_INT 1
56554: ARRAY
56555: PPUSH
56556: CALL_OW 310
56560: IFFALSE 56583
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56562: LD_EXP 154
56566: PUSH
56567: LD_VAR 0 2
56571: ARRAY
56572: PUSH
56573: LD_INT 1
56575: ARRAY
56576: PPUSH
56577: CALL_OW 122
56581: GO 56725
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56583: LD_EXP 154
56587: PUSH
56588: LD_VAR 0 2
56592: ARRAY
56593: PUSH
56594: LD_INT 1
56596: ARRAY
56597: PPUSH
56598: CALL_OW 314
56602: NOT
56603: PUSH
56604: LD_EXP 154
56608: PUSH
56609: LD_VAR 0 2
56613: ARRAY
56614: PUSH
56615: LD_INT 1
56617: ARRAY
56618: PPUSH
56619: LD_EXP 153
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PUSH
56630: LD_INT 1
56632: ARRAY
56633: PUSH
56634: LD_INT 1
56636: ARRAY
56637: PPUSH
56638: LD_EXP 153
56642: PUSH
56643: LD_VAR 0 2
56647: ARRAY
56648: PUSH
56649: LD_INT 1
56651: ARRAY
56652: PUSH
56653: LD_INT 2
56655: ARRAY
56656: PPUSH
56657: CALL_OW 297
56661: PUSH
56662: LD_INT 6
56664: GREATER
56665: AND
56666: IFFALSE 56725
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56668: LD_EXP 154
56672: PUSH
56673: LD_VAR 0 2
56677: ARRAY
56678: PUSH
56679: LD_INT 1
56681: ARRAY
56682: PPUSH
56683: LD_EXP 153
56687: PUSH
56688: LD_VAR 0 2
56692: ARRAY
56693: PUSH
56694: LD_INT 1
56696: ARRAY
56697: PUSH
56698: LD_INT 1
56700: ARRAY
56701: PPUSH
56702: LD_EXP 153
56706: PUSH
56707: LD_VAR 0 2
56711: ARRAY
56712: PUSH
56713: LD_INT 1
56715: ARRAY
56716: PUSH
56717: LD_INT 2
56719: ARRAY
56720: PPUSH
56721: CALL_OW 111
// end ; end ; end ;
56725: GO 56138
56727: POP
56728: POP
// end ;
56729: LD_VAR 0 1
56733: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56734: LD_INT 0
56736: PPUSH
56737: PPUSH
56738: PPUSH
56739: PPUSH
56740: PPUSH
56741: PPUSH
56742: PPUSH
56743: PPUSH
56744: PPUSH
56745: PPUSH
56746: PPUSH
// if not mc_bases then
56747: LD_EXP 116
56751: NOT
56752: IFFALSE 56756
// exit ;
56754: GO 57696
// for i = 1 to mc_bases do
56756: LD_ADDR_VAR 0 2
56760: PUSH
56761: DOUBLE
56762: LD_INT 1
56764: DEC
56765: ST_TO_ADDR
56766: LD_EXP 116
56770: PUSH
56771: FOR_TO
56772: IFFALSE 57694
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56774: LD_EXP 116
56778: PUSH
56779: LD_VAR 0 2
56783: ARRAY
56784: NOT
56785: PUSH
56786: LD_EXP 139
56790: PUSH
56791: LD_VAR 0 2
56795: ARRAY
56796: OR
56797: IFFALSE 56801
// continue ;
56799: GO 56771
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56801: LD_ADDR_VAR 0 7
56805: PUSH
56806: LD_EXP 116
56810: PUSH
56811: LD_VAR 0 2
56815: ARRAY
56816: PUSH
56817: LD_INT 1
56819: ARRAY
56820: PPUSH
56821: CALL_OW 248
56825: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56826: LD_VAR 0 7
56830: PUSH
56831: LD_INT 3
56833: EQUAL
56834: PUSH
56835: LD_EXP 135
56839: PUSH
56840: LD_VAR 0 2
56844: ARRAY
56845: PUSH
56846: LD_EXP 138
56850: PUSH
56851: LD_VAR 0 2
56855: ARRAY
56856: UNION
56857: PPUSH
56858: LD_INT 33
56860: PUSH
56861: LD_INT 2
56863: PUSH
56864: EMPTY
56865: LIST
56866: LIST
56867: PPUSH
56868: CALL_OW 72
56872: NOT
56873: OR
56874: IFFALSE 56878
// continue ;
56876: GO 56771
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56878: LD_ADDR_VAR 0 9
56882: PUSH
56883: LD_EXP 116
56887: PUSH
56888: LD_VAR 0 2
56892: ARRAY
56893: PPUSH
56894: LD_INT 30
56896: PUSH
56897: LD_INT 36
56899: PUSH
56900: EMPTY
56901: LIST
56902: LIST
56903: PPUSH
56904: CALL_OW 72
56908: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56909: LD_ADDR_VAR 0 10
56913: PUSH
56914: LD_EXP 135
56918: PUSH
56919: LD_VAR 0 2
56923: ARRAY
56924: PPUSH
56925: LD_INT 34
56927: PUSH
56928: LD_INT 31
56930: PUSH
56931: EMPTY
56932: LIST
56933: LIST
56934: PPUSH
56935: CALL_OW 72
56939: ST_TO_ADDR
// if not cts and not mcts then
56940: LD_VAR 0 9
56944: NOT
56945: PUSH
56946: LD_VAR 0 10
56950: NOT
56951: AND
56952: IFFALSE 56956
// continue ;
56954: GO 56771
// x := cts ;
56956: LD_ADDR_VAR 0 11
56960: PUSH
56961: LD_VAR 0 9
56965: ST_TO_ADDR
// if not x then
56966: LD_VAR 0 11
56970: NOT
56971: IFFALSE 56983
// x := mcts ;
56973: LD_ADDR_VAR 0 11
56977: PUSH
56978: LD_VAR 0 10
56982: ST_TO_ADDR
// if not x then
56983: LD_VAR 0 11
56987: NOT
56988: IFFALSE 56992
// continue ;
56990: GO 56771
// if mc_remote_driver [ i ] then
56992: LD_EXP 156
56996: PUSH
56997: LD_VAR 0 2
57001: ARRAY
57002: IFFALSE 57389
// for j in mc_remote_driver [ i ] do
57004: LD_ADDR_VAR 0 3
57008: PUSH
57009: LD_EXP 156
57013: PUSH
57014: LD_VAR 0 2
57018: ARRAY
57019: PUSH
57020: FOR_IN
57021: IFFALSE 57387
// begin if GetClass ( j ) <> 3 then
57023: LD_VAR 0 3
57027: PPUSH
57028: CALL_OW 257
57032: PUSH
57033: LD_INT 3
57035: NONEQUAL
57036: IFFALSE 57089
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57038: LD_ADDR_EXP 156
57042: PUSH
57043: LD_EXP 156
57047: PPUSH
57048: LD_VAR 0 2
57052: PPUSH
57053: LD_EXP 156
57057: PUSH
57058: LD_VAR 0 2
57062: ARRAY
57063: PUSH
57064: LD_VAR 0 3
57068: DIFF
57069: PPUSH
57070: CALL_OW 1
57074: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57075: LD_VAR 0 3
57079: PPUSH
57080: LD_INT 0
57082: PPUSH
57083: CALL_OW 109
// continue ;
57087: GO 57020
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57089: LD_EXP 135
57093: PUSH
57094: LD_VAR 0 2
57098: ARRAY
57099: PPUSH
57100: LD_INT 34
57102: PUSH
57103: LD_INT 31
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: PUSH
57110: LD_INT 58
57112: PUSH
57113: EMPTY
57114: LIST
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: PPUSH
57120: CALL_OW 72
57124: PUSH
57125: LD_VAR 0 3
57129: PPUSH
57130: CALL 100057 0 1
57134: NOT
57135: AND
57136: IFFALSE 57207
// begin if IsInUnit ( j ) then
57138: LD_VAR 0 3
57142: PPUSH
57143: CALL_OW 310
57147: IFFALSE 57158
// ComExitBuilding ( j ) ;
57149: LD_VAR 0 3
57153: PPUSH
57154: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57158: LD_VAR 0 3
57162: PPUSH
57163: LD_EXP 135
57167: PUSH
57168: LD_VAR 0 2
57172: ARRAY
57173: PPUSH
57174: LD_INT 34
57176: PUSH
57177: LD_INT 31
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PUSH
57184: LD_INT 58
57186: PUSH
57187: EMPTY
57188: LIST
57189: PUSH
57190: EMPTY
57191: LIST
57192: LIST
57193: PPUSH
57194: CALL_OW 72
57198: PUSH
57199: LD_INT 1
57201: ARRAY
57202: PPUSH
57203: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57207: LD_VAR 0 3
57211: PPUSH
57212: CALL_OW 310
57216: NOT
57217: PUSH
57218: LD_VAR 0 3
57222: PPUSH
57223: CALL_OW 310
57227: PPUSH
57228: CALL_OW 266
57232: PUSH
57233: LD_INT 36
57235: NONEQUAL
57236: PUSH
57237: LD_VAR 0 3
57241: PPUSH
57242: CALL 100057 0 1
57246: NOT
57247: AND
57248: OR
57249: IFFALSE 57385
// begin if IsInUnit ( j ) then
57251: LD_VAR 0 3
57255: PPUSH
57256: CALL_OW 310
57260: IFFALSE 57271
// ComExitBuilding ( j ) ;
57262: LD_VAR 0 3
57266: PPUSH
57267: CALL_OW 122
// ct := 0 ;
57271: LD_ADDR_VAR 0 8
57275: PUSH
57276: LD_INT 0
57278: ST_TO_ADDR
// for k in x do
57279: LD_ADDR_VAR 0 4
57283: PUSH
57284: LD_VAR 0 11
57288: PUSH
57289: FOR_IN
57290: IFFALSE 57363
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57292: LD_VAR 0 4
57296: PPUSH
57297: CALL_OW 264
57301: PUSH
57302: LD_INT 31
57304: EQUAL
57305: PUSH
57306: LD_VAR 0 4
57310: PPUSH
57311: CALL_OW 311
57315: NOT
57316: AND
57317: PUSH
57318: LD_VAR 0 4
57322: PPUSH
57323: CALL_OW 266
57327: PUSH
57328: LD_INT 36
57330: EQUAL
57331: PUSH
57332: LD_VAR 0 4
57336: PPUSH
57337: CALL_OW 313
57341: PUSH
57342: LD_INT 3
57344: LESS
57345: AND
57346: OR
57347: IFFALSE 57361
// begin ct := k ;
57349: LD_ADDR_VAR 0 8
57353: PUSH
57354: LD_VAR 0 4
57358: ST_TO_ADDR
// break ;
57359: GO 57363
// end ;
57361: GO 57289
57363: POP
57364: POP
// if ct then
57365: LD_VAR 0 8
57369: IFFALSE 57385
// ComEnterUnit ( j , ct ) ;
57371: LD_VAR 0 3
57375: PPUSH
57376: LD_VAR 0 8
57380: PPUSH
57381: CALL_OW 120
// end ; end ;
57385: GO 57020
57387: POP
57388: POP
// places := 0 ;
57389: LD_ADDR_VAR 0 5
57393: PUSH
57394: LD_INT 0
57396: ST_TO_ADDR
// for j = 1 to x do
57397: LD_ADDR_VAR 0 3
57401: PUSH
57402: DOUBLE
57403: LD_INT 1
57405: DEC
57406: ST_TO_ADDR
57407: LD_VAR 0 11
57411: PUSH
57412: FOR_TO
57413: IFFALSE 57489
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57415: LD_VAR 0 11
57419: PUSH
57420: LD_VAR 0 3
57424: ARRAY
57425: PPUSH
57426: CALL_OW 264
57430: PUSH
57431: LD_INT 31
57433: EQUAL
57434: IFFALSE 57452
// places := places + 1 else
57436: LD_ADDR_VAR 0 5
57440: PUSH
57441: LD_VAR 0 5
57445: PUSH
57446: LD_INT 1
57448: PLUS
57449: ST_TO_ADDR
57450: GO 57487
// if GetBType ( x [ j ] ) = b_control_tower then
57452: LD_VAR 0 11
57456: PUSH
57457: LD_VAR 0 3
57461: ARRAY
57462: PPUSH
57463: CALL_OW 266
57467: PUSH
57468: LD_INT 36
57470: EQUAL
57471: IFFALSE 57487
// places := places + 3 ;
57473: LD_ADDR_VAR 0 5
57477: PUSH
57478: LD_VAR 0 5
57482: PUSH
57483: LD_INT 3
57485: PLUS
57486: ST_TO_ADDR
57487: GO 57412
57489: POP
57490: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57491: LD_VAR 0 5
57495: PUSH
57496: LD_INT 0
57498: EQUAL
57499: PUSH
57500: LD_VAR 0 5
57504: PUSH
57505: LD_EXP 156
57509: PUSH
57510: LD_VAR 0 2
57514: ARRAY
57515: LESSEQUAL
57516: OR
57517: IFFALSE 57521
// continue ;
57519: GO 56771
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57521: LD_ADDR_VAR 0 6
57525: PUSH
57526: LD_EXP 116
57530: PUSH
57531: LD_VAR 0 2
57535: ARRAY
57536: PPUSH
57537: LD_INT 25
57539: PUSH
57540: LD_INT 3
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: PPUSH
57547: CALL_OW 72
57551: PUSH
57552: LD_EXP 156
57556: PUSH
57557: LD_VAR 0 2
57561: ARRAY
57562: DIFF
57563: PPUSH
57564: LD_INT 3
57566: PPUSH
57567: CALL 100957 0 2
57571: ST_TO_ADDR
// for j in tmp do
57572: LD_ADDR_VAR 0 3
57576: PUSH
57577: LD_VAR 0 6
57581: PUSH
57582: FOR_IN
57583: IFFALSE 57618
// if GetTag ( j ) > 0 then
57585: LD_VAR 0 3
57589: PPUSH
57590: CALL_OW 110
57594: PUSH
57595: LD_INT 0
57597: GREATER
57598: IFFALSE 57616
// tmp := tmp diff j ;
57600: LD_ADDR_VAR 0 6
57604: PUSH
57605: LD_VAR 0 6
57609: PUSH
57610: LD_VAR 0 3
57614: DIFF
57615: ST_TO_ADDR
57616: GO 57582
57618: POP
57619: POP
// if not tmp then
57620: LD_VAR 0 6
57624: NOT
57625: IFFALSE 57629
// continue ;
57627: GO 56771
// if places then
57629: LD_VAR 0 5
57633: IFFALSE 57692
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57635: LD_ADDR_EXP 156
57639: PUSH
57640: LD_EXP 156
57644: PPUSH
57645: LD_VAR 0 2
57649: PPUSH
57650: LD_EXP 156
57654: PUSH
57655: LD_VAR 0 2
57659: ARRAY
57660: PUSH
57661: LD_VAR 0 6
57665: PUSH
57666: LD_INT 1
57668: ARRAY
57669: UNION
57670: PPUSH
57671: CALL_OW 1
57675: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57676: LD_VAR 0 6
57680: PUSH
57681: LD_INT 1
57683: ARRAY
57684: PPUSH
57685: LD_INT 126
57687: PPUSH
57688: CALL_OW 109
// end ; end ;
57692: GO 56771
57694: POP
57695: POP
// end ;
57696: LD_VAR 0 1
57700: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57701: LD_INT 0
57703: PPUSH
57704: PPUSH
57705: PPUSH
57706: PPUSH
57707: PPUSH
57708: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57709: LD_VAR 0 1
57713: NOT
57714: PUSH
57715: LD_VAR 0 2
57719: NOT
57720: OR
57721: PUSH
57722: LD_VAR 0 3
57726: NOT
57727: OR
57728: PUSH
57729: LD_VAR 0 4
57733: PUSH
57734: LD_INT 1
57736: PUSH
57737: LD_INT 2
57739: PUSH
57740: LD_INT 3
57742: PUSH
57743: LD_INT 4
57745: PUSH
57746: LD_INT 5
57748: PUSH
57749: LD_INT 8
57751: PUSH
57752: LD_INT 9
57754: PUSH
57755: LD_INT 15
57757: PUSH
57758: LD_INT 16
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: LIST
57765: LIST
57766: LIST
57767: LIST
57768: LIST
57769: LIST
57770: LIST
57771: IN
57772: NOT
57773: OR
57774: IFFALSE 57778
// exit ;
57776: GO 58678
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57778: LD_ADDR_VAR 0 2
57782: PUSH
57783: LD_VAR 0 2
57787: PPUSH
57788: LD_INT 21
57790: PUSH
57791: LD_INT 3
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: LD_INT 24
57800: PUSH
57801: LD_INT 250
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: PPUSH
57812: CALL_OW 72
57816: ST_TO_ADDR
// case class of 1 , 15 :
57817: LD_VAR 0 4
57821: PUSH
57822: LD_INT 1
57824: DOUBLE
57825: EQUAL
57826: IFTRUE 57836
57828: LD_INT 15
57830: DOUBLE
57831: EQUAL
57832: IFTRUE 57836
57834: GO 57921
57836: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57837: LD_ADDR_VAR 0 8
57841: PUSH
57842: LD_VAR 0 2
57846: PPUSH
57847: LD_INT 2
57849: PUSH
57850: LD_INT 30
57852: PUSH
57853: LD_INT 32
57855: PUSH
57856: EMPTY
57857: LIST
57858: LIST
57859: PUSH
57860: LD_INT 30
57862: PUSH
57863: LD_INT 31
57865: PUSH
57866: EMPTY
57867: LIST
57868: LIST
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: LIST
57874: PPUSH
57875: CALL_OW 72
57879: PUSH
57880: LD_VAR 0 2
57884: PPUSH
57885: LD_INT 2
57887: PUSH
57888: LD_INT 30
57890: PUSH
57891: LD_INT 4
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: PUSH
57898: LD_INT 30
57900: PUSH
57901: LD_INT 5
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: EMPTY
57909: LIST
57910: LIST
57911: LIST
57912: PPUSH
57913: CALL_OW 72
57917: ADD
57918: ST_TO_ADDR
57919: GO 58167
57921: LD_INT 2
57923: DOUBLE
57924: EQUAL
57925: IFTRUE 57935
57927: LD_INT 16
57929: DOUBLE
57930: EQUAL
57931: IFTRUE 57935
57933: GO 57981
57935: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57936: LD_ADDR_VAR 0 8
57940: PUSH
57941: LD_VAR 0 2
57945: PPUSH
57946: LD_INT 2
57948: PUSH
57949: LD_INT 30
57951: PUSH
57952: LD_INT 0
57954: PUSH
57955: EMPTY
57956: LIST
57957: LIST
57958: PUSH
57959: LD_INT 30
57961: PUSH
57962: LD_INT 1
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: EMPTY
57970: LIST
57971: LIST
57972: LIST
57973: PPUSH
57974: CALL_OW 72
57978: ST_TO_ADDR
57979: GO 58167
57981: LD_INT 3
57983: DOUBLE
57984: EQUAL
57985: IFTRUE 57989
57987: GO 58035
57989: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57990: LD_ADDR_VAR 0 8
57994: PUSH
57995: LD_VAR 0 2
57999: PPUSH
58000: LD_INT 2
58002: PUSH
58003: LD_INT 30
58005: PUSH
58006: LD_INT 2
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: PUSH
58013: LD_INT 30
58015: PUSH
58016: LD_INT 3
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: LIST
58027: PPUSH
58028: CALL_OW 72
58032: ST_TO_ADDR
58033: GO 58167
58035: LD_INT 4
58037: DOUBLE
58038: EQUAL
58039: IFTRUE 58043
58041: GO 58100
58043: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58044: LD_ADDR_VAR 0 8
58048: PUSH
58049: LD_VAR 0 2
58053: PPUSH
58054: LD_INT 2
58056: PUSH
58057: LD_INT 30
58059: PUSH
58060: LD_INT 6
58062: PUSH
58063: EMPTY
58064: LIST
58065: LIST
58066: PUSH
58067: LD_INT 30
58069: PUSH
58070: LD_INT 7
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: PUSH
58077: LD_INT 30
58079: PUSH
58080: LD_INT 8
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: PUSH
58087: EMPTY
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: PPUSH
58093: CALL_OW 72
58097: ST_TO_ADDR
58098: GO 58167
58100: LD_INT 5
58102: DOUBLE
58103: EQUAL
58104: IFTRUE 58120
58106: LD_INT 8
58108: DOUBLE
58109: EQUAL
58110: IFTRUE 58120
58112: LD_INT 9
58114: DOUBLE
58115: EQUAL
58116: IFTRUE 58120
58118: GO 58166
58120: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58121: LD_ADDR_VAR 0 8
58125: PUSH
58126: LD_VAR 0 2
58130: PPUSH
58131: LD_INT 2
58133: PUSH
58134: LD_INT 30
58136: PUSH
58137: LD_INT 4
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: PUSH
58144: LD_INT 30
58146: PUSH
58147: LD_INT 5
58149: PUSH
58150: EMPTY
58151: LIST
58152: LIST
58153: PUSH
58154: EMPTY
58155: LIST
58156: LIST
58157: LIST
58158: PPUSH
58159: CALL_OW 72
58163: ST_TO_ADDR
58164: GO 58167
58166: POP
// if not tmp then
58167: LD_VAR 0 8
58171: NOT
58172: IFFALSE 58176
// exit ;
58174: GO 58678
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58176: LD_VAR 0 4
58180: PUSH
58181: LD_INT 1
58183: PUSH
58184: LD_INT 15
58186: PUSH
58187: EMPTY
58188: LIST
58189: LIST
58190: IN
58191: PUSH
58192: LD_EXP 125
58196: PUSH
58197: LD_VAR 0 1
58201: ARRAY
58202: AND
58203: IFFALSE 58359
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58205: LD_ADDR_VAR 0 9
58209: PUSH
58210: LD_EXP 125
58214: PUSH
58215: LD_VAR 0 1
58219: ARRAY
58220: PUSH
58221: LD_INT 1
58223: ARRAY
58224: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58225: LD_VAR 0 9
58229: PUSH
58230: LD_EXP 126
58234: PUSH
58235: LD_VAR 0 1
58239: ARRAY
58240: IN
58241: NOT
58242: IFFALSE 58357
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58244: LD_ADDR_EXP 126
58248: PUSH
58249: LD_EXP 126
58253: PPUSH
58254: LD_VAR 0 1
58258: PUSH
58259: LD_EXP 126
58263: PUSH
58264: LD_VAR 0 1
58268: ARRAY
58269: PUSH
58270: LD_INT 1
58272: PLUS
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PPUSH
58278: LD_VAR 0 9
58282: PPUSH
58283: CALL 70700 0 3
58287: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58288: LD_ADDR_EXP 125
58292: PUSH
58293: LD_EXP 125
58297: PPUSH
58298: LD_VAR 0 1
58302: PPUSH
58303: LD_EXP 125
58307: PUSH
58308: LD_VAR 0 1
58312: ARRAY
58313: PUSH
58314: LD_VAR 0 9
58318: DIFF
58319: PPUSH
58320: CALL_OW 1
58324: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58325: LD_VAR 0 3
58329: PPUSH
58330: LD_EXP 126
58334: PUSH
58335: LD_VAR 0 1
58339: ARRAY
58340: PUSH
58341: LD_EXP 126
58345: PUSH
58346: LD_VAR 0 1
58350: ARRAY
58351: ARRAY
58352: PPUSH
58353: CALL_OW 120
// end ; exit ;
58357: GO 58678
// end ; if tmp > 1 then
58359: LD_VAR 0 8
58363: PUSH
58364: LD_INT 1
58366: GREATER
58367: IFFALSE 58471
// for i = 2 to tmp do
58369: LD_ADDR_VAR 0 6
58373: PUSH
58374: DOUBLE
58375: LD_INT 2
58377: DEC
58378: ST_TO_ADDR
58379: LD_VAR 0 8
58383: PUSH
58384: FOR_TO
58385: IFFALSE 58469
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58387: LD_VAR 0 8
58391: PUSH
58392: LD_VAR 0 6
58396: ARRAY
58397: PPUSH
58398: CALL_OW 461
58402: PUSH
58403: LD_INT 6
58405: EQUAL
58406: IFFALSE 58467
// begin x := tmp [ i ] ;
58408: LD_ADDR_VAR 0 9
58412: PUSH
58413: LD_VAR 0 8
58417: PUSH
58418: LD_VAR 0 6
58422: ARRAY
58423: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58424: LD_ADDR_VAR 0 8
58428: PUSH
58429: LD_VAR 0 8
58433: PPUSH
58434: LD_VAR 0 6
58438: PPUSH
58439: CALL_OW 3
58443: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58444: LD_ADDR_VAR 0 8
58448: PUSH
58449: LD_VAR 0 8
58453: PPUSH
58454: LD_INT 1
58456: PPUSH
58457: LD_VAR 0 9
58461: PPUSH
58462: CALL_OW 2
58466: ST_TO_ADDR
// end ;
58467: GO 58384
58469: POP
58470: POP
// for i in tmp do
58471: LD_ADDR_VAR 0 6
58475: PUSH
58476: LD_VAR 0 8
58480: PUSH
58481: FOR_IN
58482: IFFALSE 58551
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58484: LD_VAR 0 6
58488: PPUSH
58489: CALL_OW 313
58493: PUSH
58494: LD_INT 6
58496: LESS
58497: PUSH
58498: LD_VAR 0 6
58502: PPUSH
58503: CALL_OW 266
58507: PUSH
58508: LD_INT 31
58510: PUSH
58511: LD_INT 32
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: IN
58518: NOT
58519: AND
58520: PUSH
58521: LD_VAR 0 6
58525: PPUSH
58526: CALL_OW 313
58530: PUSH
58531: LD_INT 0
58533: EQUAL
58534: OR
58535: IFFALSE 58549
// begin j := i ;
58537: LD_ADDR_VAR 0 7
58541: PUSH
58542: LD_VAR 0 6
58546: ST_TO_ADDR
// break ;
58547: GO 58551
// end ; end ;
58549: GO 58481
58551: POP
58552: POP
// if j then
58553: LD_VAR 0 7
58557: IFFALSE 58575
// ComEnterUnit ( unit , j ) else
58559: LD_VAR 0 3
58563: PPUSH
58564: LD_VAR 0 7
58568: PPUSH
58569: CALL_OW 120
58573: GO 58678
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58575: LD_ADDR_VAR 0 10
58579: PUSH
58580: LD_VAR 0 2
58584: PPUSH
58585: LD_INT 2
58587: PUSH
58588: LD_INT 30
58590: PUSH
58591: LD_INT 0
58593: PUSH
58594: EMPTY
58595: LIST
58596: LIST
58597: PUSH
58598: LD_INT 30
58600: PUSH
58601: LD_INT 1
58603: PUSH
58604: EMPTY
58605: LIST
58606: LIST
58607: PUSH
58608: EMPTY
58609: LIST
58610: LIST
58611: LIST
58612: PPUSH
58613: CALL_OW 72
58617: ST_TO_ADDR
// if depot then
58618: LD_VAR 0 10
58622: IFFALSE 58678
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58624: LD_ADDR_VAR 0 10
58628: PUSH
58629: LD_VAR 0 10
58633: PPUSH
58634: LD_VAR 0 3
58638: PPUSH
58639: CALL_OW 74
58643: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58644: LD_VAR 0 3
58648: PPUSH
58649: LD_VAR 0 10
58653: PPUSH
58654: CALL_OW 296
58658: PUSH
58659: LD_INT 10
58661: GREATER
58662: IFFALSE 58678
// ComStandNearbyBuilding ( unit , depot ) ;
58664: LD_VAR 0 3
58668: PPUSH
58669: LD_VAR 0 10
58673: PPUSH
58674: CALL 67278 0 2
// end ; end ; end ;
58678: LD_VAR 0 5
58682: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58683: LD_INT 0
58685: PPUSH
58686: PPUSH
58687: PPUSH
58688: PPUSH
// if not mc_bases then
58689: LD_EXP 116
58693: NOT
58694: IFFALSE 58698
// exit ;
58696: GO 58937
// for i = 1 to mc_bases do
58698: LD_ADDR_VAR 0 2
58702: PUSH
58703: DOUBLE
58704: LD_INT 1
58706: DEC
58707: ST_TO_ADDR
58708: LD_EXP 116
58712: PUSH
58713: FOR_TO
58714: IFFALSE 58935
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58716: LD_ADDR_VAR 0 4
58720: PUSH
58721: LD_EXP 116
58725: PUSH
58726: LD_VAR 0 2
58730: ARRAY
58731: PPUSH
58732: LD_INT 21
58734: PUSH
58735: LD_INT 1
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: PPUSH
58742: CALL_OW 72
58746: PUSH
58747: LD_EXP 145
58751: PUSH
58752: LD_VAR 0 2
58756: ARRAY
58757: UNION
58758: ST_TO_ADDR
// if not tmp then
58759: LD_VAR 0 4
58763: NOT
58764: IFFALSE 58768
// continue ;
58766: GO 58713
// for j in tmp do
58768: LD_ADDR_VAR 0 3
58772: PUSH
58773: LD_VAR 0 4
58777: PUSH
58778: FOR_IN
58779: IFFALSE 58931
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58781: LD_VAR 0 3
58785: PPUSH
58786: CALL_OW 110
58790: NOT
58791: PUSH
58792: LD_VAR 0 3
58796: PPUSH
58797: CALL_OW 314
58801: NOT
58802: AND
58803: PUSH
58804: LD_VAR 0 3
58808: PPUSH
58809: CALL_OW 311
58813: NOT
58814: AND
58815: PUSH
58816: LD_VAR 0 3
58820: PPUSH
58821: CALL_OW 310
58825: NOT
58826: AND
58827: PUSH
58828: LD_VAR 0 3
58832: PUSH
58833: LD_EXP 119
58837: PUSH
58838: LD_VAR 0 2
58842: ARRAY
58843: PUSH
58844: LD_INT 1
58846: ARRAY
58847: IN
58848: NOT
58849: AND
58850: PUSH
58851: LD_VAR 0 3
58855: PUSH
58856: LD_EXP 119
58860: PUSH
58861: LD_VAR 0 2
58865: ARRAY
58866: PUSH
58867: LD_INT 2
58869: ARRAY
58870: IN
58871: NOT
58872: AND
58873: PUSH
58874: LD_VAR 0 3
58878: PUSH
58879: LD_EXP 128
58883: PUSH
58884: LD_VAR 0 2
58888: ARRAY
58889: IN
58890: NOT
58891: AND
58892: IFFALSE 58929
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58894: LD_VAR 0 2
58898: PPUSH
58899: LD_EXP 116
58903: PUSH
58904: LD_VAR 0 2
58908: ARRAY
58909: PPUSH
58910: LD_VAR 0 3
58914: PPUSH
58915: LD_VAR 0 3
58919: PPUSH
58920: CALL_OW 257
58924: PPUSH
58925: CALL 57701 0 4
// end ;
58929: GO 58778
58931: POP
58932: POP
// end ;
58933: GO 58713
58935: POP
58936: POP
// end ;
58937: LD_VAR 0 1
58941: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58942: LD_INT 0
58944: PPUSH
58945: PPUSH
58946: PPUSH
58947: PPUSH
58948: PPUSH
58949: PPUSH
// if not mc_bases [ base ] then
58950: LD_EXP 116
58954: PUSH
58955: LD_VAR 0 1
58959: ARRAY
58960: NOT
58961: IFFALSE 58965
// exit ;
58963: GO 59147
// tmp := [ ] ;
58965: LD_ADDR_VAR 0 6
58969: PUSH
58970: EMPTY
58971: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58972: LD_ADDR_VAR 0 7
58976: PUSH
58977: LD_VAR 0 3
58981: PPUSH
58982: LD_INT 0
58984: PPUSH
58985: CALL_OW 517
58989: ST_TO_ADDR
// if not list then
58990: LD_VAR 0 7
58994: NOT
58995: IFFALSE 58999
// exit ;
58997: GO 59147
// for i = 1 to amount do
58999: LD_ADDR_VAR 0 5
59003: PUSH
59004: DOUBLE
59005: LD_INT 1
59007: DEC
59008: ST_TO_ADDR
59009: LD_VAR 0 2
59013: PUSH
59014: FOR_TO
59015: IFFALSE 59095
// begin x := rand ( 1 , list [ 1 ] ) ;
59017: LD_ADDR_VAR 0 8
59021: PUSH
59022: LD_INT 1
59024: PPUSH
59025: LD_VAR 0 7
59029: PUSH
59030: LD_INT 1
59032: ARRAY
59033: PPUSH
59034: CALL_OW 12
59038: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59039: LD_ADDR_VAR 0 6
59043: PUSH
59044: LD_VAR 0 6
59048: PPUSH
59049: LD_VAR 0 5
59053: PPUSH
59054: LD_VAR 0 7
59058: PUSH
59059: LD_INT 1
59061: ARRAY
59062: PUSH
59063: LD_VAR 0 8
59067: ARRAY
59068: PUSH
59069: LD_VAR 0 7
59073: PUSH
59074: LD_INT 2
59076: ARRAY
59077: PUSH
59078: LD_VAR 0 8
59082: ARRAY
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PPUSH
59088: CALL_OW 1
59092: ST_TO_ADDR
// end ;
59093: GO 59014
59095: POP
59096: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59097: LD_ADDR_EXP 129
59101: PUSH
59102: LD_EXP 129
59106: PPUSH
59107: LD_VAR 0 1
59111: PPUSH
59112: LD_VAR 0 6
59116: PPUSH
59117: CALL_OW 1
59121: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59122: LD_ADDR_EXP 131
59126: PUSH
59127: LD_EXP 131
59131: PPUSH
59132: LD_VAR 0 1
59136: PPUSH
59137: LD_VAR 0 3
59141: PPUSH
59142: CALL_OW 1
59146: ST_TO_ADDR
// end ;
59147: LD_VAR 0 4
59151: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59152: LD_INT 0
59154: PPUSH
// if not mc_bases [ base ] then
59155: LD_EXP 116
59159: PUSH
59160: LD_VAR 0 1
59164: ARRAY
59165: NOT
59166: IFFALSE 59170
// exit ;
59168: GO 59195
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59170: LD_ADDR_EXP 121
59174: PUSH
59175: LD_EXP 121
59179: PPUSH
59180: LD_VAR 0 1
59184: PPUSH
59185: LD_VAR 0 2
59189: PPUSH
59190: CALL_OW 1
59194: ST_TO_ADDR
// end ;
59195: LD_VAR 0 3
59199: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59200: LD_INT 0
59202: PPUSH
// if not mc_bases [ base ] then
59203: LD_EXP 116
59207: PUSH
59208: LD_VAR 0 1
59212: ARRAY
59213: NOT
59214: IFFALSE 59218
// exit ;
59216: GO 59255
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59218: LD_ADDR_EXP 121
59222: PUSH
59223: LD_EXP 121
59227: PPUSH
59228: LD_VAR 0 1
59232: PPUSH
59233: LD_EXP 121
59237: PUSH
59238: LD_VAR 0 1
59242: ARRAY
59243: PUSH
59244: LD_VAR 0 2
59248: UNION
59249: PPUSH
59250: CALL_OW 1
59254: ST_TO_ADDR
// end ;
59255: LD_VAR 0 3
59259: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59260: LD_INT 0
59262: PPUSH
// if not mc_bases [ base ] then
59263: LD_EXP 116
59267: PUSH
59268: LD_VAR 0 1
59272: ARRAY
59273: NOT
59274: IFFALSE 59278
// exit ;
59276: GO 59303
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59278: LD_ADDR_EXP 137
59282: PUSH
59283: LD_EXP 137
59287: PPUSH
59288: LD_VAR 0 1
59292: PPUSH
59293: LD_VAR 0 2
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// end ;
59303: LD_VAR 0 3
59307: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59308: LD_INT 0
59310: PPUSH
// if not mc_bases [ base ] then
59311: LD_EXP 116
59315: PUSH
59316: LD_VAR 0 1
59320: ARRAY
59321: NOT
59322: IFFALSE 59326
// exit ;
59324: GO 59363
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59326: LD_ADDR_EXP 137
59330: PUSH
59331: LD_EXP 137
59335: PPUSH
59336: LD_VAR 0 1
59340: PPUSH
59341: LD_EXP 137
59345: PUSH
59346: LD_VAR 0 1
59350: ARRAY
59351: PUSH
59352: LD_VAR 0 2
59356: ADD
59357: PPUSH
59358: CALL_OW 1
59362: ST_TO_ADDR
// end ;
59363: LD_VAR 0 3
59367: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59368: LD_INT 0
59370: PPUSH
// if not mc_bases [ base ] then
59371: LD_EXP 116
59375: PUSH
59376: LD_VAR 0 1
59380: ARRAY
59381: NOT
59382: IFFALSE 59386
// exit ;
59384: GO 59440
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59386: LD_ADDR_EXP 138
59390: PUSH
59391: LD_EXP 138
59395: PPUSH
59396: LD_VAR 0 1
59400: PPUSH
59401: LD_VAR 0 2
59405: PPUSH
59406: CALL_OW 1
59410: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59411: LD_ADDR_EXP 127
59415: PUSH
59416: LD_EXP 127
59420: PPUSH
59421: LD_VAR 0 1
59425: PPUSH
59426: LD_VAR 0 2
59430: PUSH
59431: LD_INT 0
59433: PLUS
59434: PPUSH
59435: CALL_OW 1
59439: ST_TO_ADDR
// end ;
59440: LD_VAR 0 3
59444: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59445: LD_INT 0
59447: PPUSH
// if not mc_bases [ base ] then
59448: LD_EXP 116
59452: PUSH
59453: LD_VAR 0 1
59457: ARRAY
59458: NOT
59459: IFFALSE 59463
// exit ;
59461: GO 59488
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59463: LD_ADDR_EXP 127
59467: PUSH
59468: LD_EXP 127
59472: PPUSH
59473: LD_VAR 0 1
59477: PPUSH
59478: LD_VAR 0 2
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// end ;
59488: LD_VAR 0 3
59492: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59493: LD_INT 0
59495: PPUSH
59496: PPUSH
59497: PPUSH
59498: PPUSH
// if not mc_bases [ base ] then
59499: LD_EXP 116
59503: PUSH
59504: LD_VAR 0 1
59508: ARRAY
59509: NOT
59510: IFFALSE 59514
// exit ;
59512: GO 59579
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59514: LD_ADDR_EXP 136
59518: PUSH
59519: LD_EXP 136
59523: PPUSH
59524: LD_VAR 0 1
59528: PUSH
59529: LD_EXP 136
59533: PUSH
59534: LD_VAR 0 1
59538: ARRAY
59539: PUSH
59540: LD_INT 1
59542: PLUS
59543: PUSH
59544: EMPTY
59545: LIST
59546: LIST
59547: PPUSH
59548: LD_VAR 0 1
59552: PUSH
59553: LD_VAR 0 2
59557: PUSH
59558: LD_VAR 0 3
59562: PUSH
59563: LD_VAR 0 4
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: LIST
59572: LIST
59573: PPUSH
59574: CALL 70700 0 3
59578: ST_TO_ADDR
// end ;
59579: LD_VAR 0 5
59583: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59584: LD_INT 0
59586: PPUSH
// if not mc_bases [ base ] then
59587: LD_EXP 116
59591: PUSH
59592: LD_VAR 0 1
59596: ARRAY
59597: NOT
59598: IFFALSE 59602
// exit ;
59600: GO 59627
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59602: LD_ADDR_EXP 153
59606: PUSH
59607: LD_EXP 153
59611: PPUSH
59612: LD_VAR 0 1
59616: PPUSH
59617: LD_VAR 0 2
59621: PPUSH
59622: CALL_OW 1
59626: ST_TO_ADDR
// end ;
59627: LD_VAR 0 3
59631: RET
// export function MC_GetMinesField ( base ) ; begin
59632: LD_INT 0
59634: PPUSH
// result := mc_mines [ base ] ;
59635: LD_ADDR_VAR 0 2
59639: PUSH
59640: LD_EXP 129
59644: PUSH
59645: LD_VAR 0 1
59649: ARRAY
59650: ST_TO_ADDR
// end ;
59651: LD_VAR 0 2
59655: RET
// export function MC_GetProduceList ( base ) ; begin
59656: LD_INT 0
59658: PPUSH
// result := mc_produce [ base ] ;
59659: LD_ADDR_VAR 0 2
59663: PUSH
59664: LD_EXP 137
59668: PUSH
59669: LD_VAR 0 1
59673: ARRAY
59674: ST_TO_ADDR
// end ;
59675: LD_VAR 0 2
59679: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59680: LD_INT 0
59682: PPUSH
59683: PPUSH
// if not mc_bases then
59684: LD_EXP 116
59688: NOT
59689: IFFALSE 59693
// exit ;
59691: GO 59758
// if mc_bases [ base ] then
59693: LD_EXP 116
59697: PUSH
59698: LD_VAR 0 1
59702: ARRAY
59703: IFFALSE 59758
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59705: LD_ADDR_VAR 0 3
59709: PUSH
59710: LD_EXP 116
59714: PUSH
59715: LD_VAR 0 1
59719: ARRAY
59720: PPUSH
59721: LD_INT 30
59723: PUSH
59724: LD_VAR 0 2
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: PPUSH
59733: CALL_OW 72
59737: ST_TO_ADDR
// if result then
59738: LD_VAR 0 3
59742: IFFALSE 59758
// result := result [ 1 ] ;
59744: LD_ADDR_VAR 0 3
59748: PUSH
59749: LD_VAR 0 3
59753: PUSH
59754: LD_INT 1
59756: ARRAY
59757: ST_TO_ADDR
// end ; end ;
59758: LD_VAR 0 3
59762: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59763: LD_INT 0
59765: PPUSH
59766: PPUSH
// if not mc_bases then
59767: LD_EXP 116
59771: NOT
59772: IFFALSE 59776
// exit ;
59774: GO 59821
// if mc_bases [ base ] then
59776: LD_EXP 116
59780: PUSH
59781: LD_VAR 0 1
59785: ARRAY
59786: IFFALSE 59821
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59788: LD_ADDR_VAR 0 3
59792: PUSH
59793: LD_EXP 116
59797: PUSH
59798: LD_VAR 0 1
59802: ARRAY
59803: PPUSH
59804: LD_INT 30
59806: PUSH
59807: LD_VAR 0 2
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PPUSH
59816: CALL_OW 72
59820: ST_TO_ADDR
// end ;
59821: LD_VAR 0 3
59825: RET
// export function MC_SetTame ( base , area ) ; begin
59826: LD_INT 0
59828: PPUSH
// if not mc_bases or not base then
59829: LD_EXP 116
59833: NOT
59834: PUSH
59835: LD_VAR 0 1
59839: NOT
59840: OR
59841: IFFALSE 59845
// exit ;
59843: GO 59870
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59845: LD_ADDR_EXP 144
59849: PUSH
59850: LD_EXP 144
59854: PPUSH
59855: LD_VAR 0 1
59859: PPUSH
59860: LD_VAR 0 2
59864: PPUSH
59865: CALL_OW 1
59869: ST_TO_ADDR
// end ;
59870: LD_VAR 0 3
59874: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59875: LD_INT 0
59877: PPUSH
59878: PPUSH
// if not mc_bases or not base then
59879: LD_EXP 116
59883: NOT
59884: PUSH
59885: LD_VAR 0 1
59889: NOT
59890: OR
59891: IFFALSE 59895
// exit ;
59893: GO 59997
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59895: LD_ADDR_VAR 0 4
59899: PUSH
59900: LD_EXP 116
59904: PUSH
59905: LD_VAR 0 1
59909: ARRAY
59910: PPUSH
59911: LD_INT 30
59913: PUSH
59914: LD_VAR 0 2
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: PPUSH
59923: CALL_OW 72
59927: ST_TO_ADDR
// if not tmp then
59928: LD_VAR 0 4
59932: NOT
59933: IFFALSE 59937
// exit ;
59935: GO 59997
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59937: LD_ADDR_EXP 148
59941: PUSH
59942: LD_EXP 148
59946: PPUSH
59947: LD_VAR 0 1
59951: PPUSH
59952: LD_EXP 148
59956: PUSH
59957: LD_VAR 0 1
59961: ARRAY
59962: PPUSH
59963: LD_EXP 148
59967: PUSH
59968: LD_VAR 0 1
59972: ARRAY
59973: PUSH
59974: LD_INT 1
59976: PLUS
59977: PPUSH
59978: LD_VAR 0 4
59982: PUSH
59983: LD_INT 1
59985: ARRAY
59986: PPUSH
59987: CALL_OW 2
59991: PPUSH
59992: CALL_OW 1
59996: ST_TO_ADDR
// end ;
59997: LD_VAR 0 3
60001: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60002: LD_INT 0
60004: PPUSH
60005: PPUSH
// if not mc_bases or not base or not kinds then
60006: LD_EXP 116
60010: NOT
60011: PUSH
60012: LD_VAR 0 1
60016: NOT
60017: OR
60018: PUSH
60019: LD_VAR 0 2
60023: NOT
60024: OR
60025: IFFALSE 60029
// exit ;
60027: GO 60090
// for i in kinds do
60029: LD_ADDR_VAR 0 4
60033: PUSH
60034: LD_VAR 0 2
60038: PUSH
60039: FOR_IN
60040: IFFALSE 60088
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60042: LD_ADDR_EXP 150
60046: PUSH
60047: LD_EXP 150
60051: PPUSH
60052: LD_VAR 0 1
60056: PUSH
60057: LD_EXP 150
60061: PUSH
60062: LD_VAR 0 1
60066: ARRAY
60067: PUSH
60068: LD_INT 1
60070: PLUS
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: PPUSH
60076: LD_VAR 0 4
60080: PPUSH
60081: CALL 70700 0 3
60085: ST_TO_ADDR
60086: GO 60039
60088: POP
60089: POP
// end ;
60090: LD_VAR 0 3
60094: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60095: LD_INT 0
60097: PPUSH
// if not mc_bases or not base or not areas then
60098: LD_EXP 116
60102: NOT
60103: PUSH
60104: LD_VAR 0 1
60108: NOT
60109: OR
60110: PUSH
60111: LD_VAR 0 2
60115: NOT
60116: OR
60117: IFFALSE 60121
// exit ;
60119: GO 60146
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60121: LD_ADDR_EXP 134
60125: PUSH
60126: LD_EXP 134
60130: PPUSH
60131: LD_VAR 0 1
60135: PPUSH
60136: LD_VAR 0 2
60140: PPUSH
60141: CALL_OW 1
60145: ST_TO_ADDR
// end ;
60146: LD_VAR 0 3
60150: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60151: LD_INT 0
60153: PPUSH
// if not mc_bases or not base or not teleports_exit then
60154: LD_EXP 116
60158: NOT
60159: PUSH
60160: LD_VAR 0 1
60164: NOT
60165: OR
60166: PUSH
60167: LD_VAR 0 2
60171: NOT
60172: OR
60173: IFFALSE 60177
// exit ;
60175: GO 60202
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60177: LD_ADDR_EXP 151
60181: PUSH
60182: LD_EXP 151
60186: PPUSH
60187: LD_VAR 0 1
60191: PPUSH
60192: LD_VAR 0 2
60196: PPUSH
60197: CALL_OW 1
60201: ST_TO_ADDR
// end ;
60202: LD_VAR 0 3
60206: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60207: LD_INT 0
60209: PPUSH
60210: PPUSH
60211: PPUSH
// if not mc_bases or not base or not ext_list then
60212: LD_EXP 116
60216: NOT
60217: PUSH
60218: LD_VAR 0 1
60222: NOT
60223: OR
60224: PUSH
60225: LD_VAR 0 5
60229: NOT
60230: OR
60231: IFFALSE 60235
// exit ;
60233: GO 60408
// tmp := GetFacExtXYD ( x , y , d ) ;
60235: LD_ADDR_VAR 0 8
60239: PUSH
60240: LD_VAR 0 2
60244: PPUSH
60245: LD_VAR 0 3
60249: PPUSH
60250: LD_VAR 0 4
60254: PPUSH
60255: CALL 100087 0 3
60259: ST_TO_ADDR
// if not tmp then
60260: LD_VAR 0 8
60264: NOT
60265: IFFALSE 60269
// exit ;
60267: GO 60408
// for i in tmp do
60269: LD_ADDR_VAR 0 7
60273: PUSH
60274: LD_VAR 0 8
60278: PUSH
60279: FOR_IN
60280: IFFALSE 60406
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60282: LD_ADDR_EXP 121
60286: PUSH
60287: LD_EXP 121
60291: PPUSH
60292: LD_VAR 0 1
60296: PPUSH
60297: LD_EXP 121
60301: PUSH
60302: LD_VAR 0 1
60306: ARRAY
60307: PPUSH
60308: LD_EXP 121
60312: PUSH
60313: LD_VAR 0 1
60317: ARRAY
60318: PUSH
60319: LD_INT 1
60321: PLUS
60322: PPUSH
60323: LD_VAR 0 5
60327: PUSH
60328: LD_INT 1
60330: ARRAY
60331: PUSH
60332: LD_VAR 0 7
60336: PUSH
60337: LD_INT 1
60339: ARRAY
60340: PUSH
60341: LD_VAR 0 7
60345: PUSH
60346: LD_INT 2
60348: ARRAY
60349: PUSH
60350: LD_VAR 0 7
60354: PUSH
60355: LD_INT 3
60357: ARRAY
60358: PUSH
60359: EMPTY
60360: LIST
60361: LIST
60362: LIST
60363: LIST
60364: PPUSH
60365: CALL_OW 2
60369: PPUSH
60370: CALL_OW 1
60374: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60375: LD_ADDR_VAR 0 5
60379: PUSH
60380: LD_VAR 0 5
60384: PPUSH
60385: LD_INT 1
60387: PPUSH
60388: CALL_OW 3
60392: ST_TO_ADDR
// if not ext_list then
60393: LD_VAR 0 5
60397: NOT
60398: IFFALSE 60404
// exit ;
60400: POP
60401: POP
60402: GO 60408
// end ;
60404: GO 60279
60406: POP
60407: POP
// end ;
60408: LD_VAR 0 6
60412: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60413: LD_INT 0
60415: PPUSH
// if not mc_bases or not base or not weapon_list then
60416: LD_EXP 116
60420: NOT
60421: PUSH
60422: LD_VAR 0 1
60426: NOT
60427: OR
60428: PUSH
60429: LD_VAR 0 2
60433: NOT
60434: OR
60435: IFFALSE 60439
// exit ;
60437: GO 60464
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60439: LD_ADDR_EXP 155
60443: PUSH
60444: LD_EXP 155
60448: PPUSH
60449: LD_VAR 0 1
60453: PPUSH
60454: LD_VAR 0 2
60458: PPUSH
60459: CALL_OW 1
60463: ST_TO_ADDR
// end ;
60464: LD_VAR 0 3
60468: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60469: LD_INT 0
60471: PPUSH
// if not mc_bases or not base or not tech_list then
60472: LD_EXP 116
60476: NOT
60477: PUSH
60478: LD_VAR 0 1
60482: NOT
60483: OR
60484: PUSH
60485: LD_VAR 0 2
60489: NOT
60490: OR
60491: IFFALSE 60495
// exit ;
60493: GO 60520
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60495: LD_ADDR_EXP 143
60499: PUSH
60500: LD_EXP 143
60504: PPUSH
60505: LD_VAR 0 1
60509: PPUSH
60510: LD_VAR 0 2
60514: PPUSH
60515: CALL_OW 1
60519: ST_TO_ADDR
// end ;
60520: LD_VAR 0 3
60524: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60525: LD_INT 0
60527: PPUSH
// if not mc_bases or not parking_area or not base then
60528: LD_EXP 116
60532: NOT
60533: PUSH
60534: LD_VAR 0 2
60538: NOT
60539: OR
60540: PUSH
60541: LD_VAR 0 1
60545: NOT
60546: OR
60547: IFFALSE 60551
// exit ;
60549: GO 60576
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60551: LD_ADDR_EXP 140
60555: PUSH
60556: LD_EXP 140
60560: PPUSH
60561: LD_VAR 0 1
60565: PPUSH
60566: LD_VAR 0 2
60570: PPUSH
60571: CALL_OW 1
60575: ST_TO_ADDR
// end ;
60576: LD_VAR 0 3
60580: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60581: LD_INT 0
60583: PPUSH
// if not mc_bases or not base or not scan_area then
60584: LD_EXP 116
60588: NOT
60589: PUSH
60590: LD_VAR 0 1
60594: NOT
60595: OR
60596: PUSH
60597: LD_VAR 0 2
60601: NOT
60602: OR
60603: IFFALSE 60607
// exit ;
60605: GO 60632
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60607: LD_ADDR_EXP 141
60611: PUSH
60612: LD_EXP 141
60616: PPUSH
60617: LD_VAR 0 1
60621: PPUSH
60622: LD_VAR 0 2
60626: PPUSH
60627: CALL_OW 1
60631: ST_TO_ADDR
// end ;
60632: LD_VAR 0 3
60636: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60637: LD_INT 0
60639: PPUSH
60640: PPUSH
// if not mc_bases or not base then
60641: LD_EXP 116
60645: NOT
60646: PUSH
60647: LD_VAR 0 1
60651: NOT
60652: OR
60653: IFFALSE 60657
// exit ;
60655: GO 60721
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60657: LD_ADDR_VAR 0 3
60661: PUSH
60662: LD_INT 1
60664: PUSH
60665: LD_INT 2
60667: PUSH
60668: LD_INT 3
60670: PUSH
60671: LD_INT 4
60673: PUSH
60674: LD_INT 11
60676: PUSH
60677: EMPTY
60678: LIST
60679: LIST
60680: LIST
60681: LIST
60682: LIST
60683: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60684: LD_ADDR_EXP 143
60688: PUSH
60689: LD_EXP 143
60693: PPUSH
60694: LD_VAR 0 1
60698: PPUSH
60699: LD_EXP 143
60703: PUSH
60704: LD_VAR 0 1
60708: ARRAY
60709: PUSH
60710: LD_VAR 0 3
60714: DIFF
60715: PPUSH
60716: CALL_OW 1
60720: ST_TO_ADDR
// end ;
60721: LD_VAR 0 2
60725: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60726: LD_INT 0
60728: PPUSH
// result := mc_vehicles [ base ] ;
60729: LD_ADDR_VAR 0 3
60733: PUSH
60734: LD_EXP 135
60738: PUSH
60739: LD_VAR 0 1
60743: ARRAY
60744: ST_TO_ADDR
// if onlyCombat then
60745: LD_VAR 0 2
60749: IFFALSE 60927
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60751: LD_ADDR_VAR 0 3
60755: PUSH
60756: LD_VAR 0 3
60760: PUSH
60761: LD_VAR 0 3
60765: PPUSH
60766: LD_INT 2
60768: PUSH
60769: LD_INT 34
60771: PUSH
60772: LD_INT 12
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PUSH
60779: LD_INT 34
60781: PUSH
60782: LD_INT 51
60784: PUSH
60785: EMPTY
60786: LIST
60787: LIST
60788: PUSH
60789: LD_INT 34
60791: PUSH
60792: LD_EXP 96
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: PUSH
60801: LD_INT 34
60803: PUSH
60804: LD_INT 32
60806: PUSH
60807: EMPTY
60808: LIST
60809: LIST
60810: PUSH
60811: LD_INT 34
60813: PUSH
60814: LD_INT 13
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: LD_INT 34
60823: PUSH
60824: LD_INT 52
60826: PUSH
60827: EMPTY
60828: LIST
60829: LIST
60830: PUSH
60831: LD_INT 34
60833: PUSH
60834: LD_EXP 101
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: PUSH
60843: LD_INT 34
60845: PUSH
60846: LD_INT 14
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: PUSH
60853: LD_INT 34
60855: PUSH
60856: LD_INT 53
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PUSH
60863: LD_INT 34
60865: PUSH
60866: LD_EXP 95
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PUSH
60875: LD_INT 34
60877: PUSH
60878: LD_INT 31
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PUSH
60885: LD_INT 34
60887: PUSH
60888: LD_INT 48
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: PUSH
60895: LD_INT 34
60897: PUSH
60898: LD_INT 8
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PUSH
60905: EMPTY
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: PPUSH
60921: CALL_OW 72
60925: DIFF
60926: ST_TO_ADDR
// end ; end_of_file
60927: LD_VAR 0 3
60931: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60932: LD_INT 0
60934: PPUSH
60935: PPUSH
60936: PPUSH
// if not mc_bases or not skirmish then
60937: LD_EXP 116
60941: NOT
60942: PUSH
60943: LD_EXP 114
60947: NOT
60948: OR
60949: IFFALSE 60953
// exit ;
60951: GO 61118
// for i = 1 to mc_bases do
60953: LD_ADDR_VAR 0 4
60957: PUSH
60958: DOUBLE
60959: LD_INT 1
60961: DEC
60962: ST_TO_ADDR
60963: LD_EXP 116
60967: PUSH
60968: FOR_TO
60969: IFFALSE 61116
// begin if sci in mc_bases [ i ] then
60971: LD_VAR 0 2
60975: PUSH
60976: LD_EXP 116
60980: PUSH
60981: LD_VAR 0 4
60985: ARRAY
60986: IN
60987: IFFALSE 61114
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60989: LD_ADDR_EXP 145
60993: PUSH
60994: LD_EXP 145
60998: PPUSH
60999: LD_VAR 0 4
61003: PUSH
61004: LD_EXP 145
61008: PUSH
61009: LD_VAR 0 4
61013: ARRAY
61014: PUSH
61015: LD_INT 1
61017: PLUS
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PPUSH
61023: LD_VAR 0 1
61027: PPUSH
61028: CALL 70700 0 3
61032: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61033: LD_ADDR_VAR 0 5
61037: PUSH
61038: LD_EXP 116
61042: PUSH
61043: LD_VAR 0 4
61047: ARRAY
61048: PPUSH
61049: LD_INT 2
61051: PUSH
61052: LD_INT 30
61054: PUSH
61055: LD_INT 0
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: LD_INT 30
61064: PUSH
61065: LD_INT 1
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: LIST
61076: PPUSH
61077: CALL_OW 72
61081: PPUSH
61082: LD_VAR 0 1
61086: PPUSH
61087: CALL_OW 74
61091: ST_TO_ADDR
// if tmp then
61092: LD_VAR 0 5
61096: IFFALSE 61112
// ComStandNearbyBuilding ( ape , tmp ) ;
61098: LD_VAR 0 1
61102: PPUSH
61103: LD_VAR 0 5
61107: PPUSH
61108: CALL 67278 0 2
// break ;
61112: GO 61116
// end ; end ;
61114: GO 60968
61116: POP
61117: POP
// end ;
61118: LD_VAR 0 3
61122: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61123: LD_INT 0
61125: PPUSH
61126: PPUSH
61127: PPUSH
// if not mc_bases or not skirmish then
61128: LD_EXP 116
61132: NOT
61133: PUSH
61134: LD_EXP 114
61138: NOT
61139: OR
61140: IFFALSE 61144
// exit ;
61142: GO 61233
// for i = 1 to mc_bases do
61144: LD_ADDR_VAR 0 4
61148: PUSH
61149: DOUBLE
61150: LD_INT 1
61152: DEC
61153: ST_TO_ADDR
61154: LD_EXP 116
61158: PUSH
61159: FOR_TO
61160: IFFALSE 61231
// begin if building in mc_busy_turret_list [ i ] then
61162: LD_VAR 0 1
61166: PUSH
61167: LD_EXP 126
61171: PUSH
61172: LD_VAR 0 4
61176: ARRAY
61177: IN
61178: IFFALSE 61229
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61180: LD_ADDR_VAR 0 5
61184: PUSH
61185: LD_EXP 126
61189: PUSH
61190: LD_VAR 0 4
61194: ARRAY
61195: PUSH
61196: LD_VAR 0 1
61200: DIFF
61201: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61202: LD_ADDR_EXP 126
61206: PUSH
61207: LD_EXP 126
61211: PPUSH
61212: LD_VAR 0 4
61216: PPUSH
61217: LD_VAR 0 5
61221: PPUSH
61222: CALL_OW 1
61226: ST_TO_ADDR
// break ;
61227: GO 61231
// end ; end ;
61229: GO 61159
61231: POP
61232: POP
// end ;
61233: LD_VAR 0 3
61237: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61238: LD_INT 0
61240: PPUSH
61241: PPUSH
61242: PPUSH
// if not mc_bases or not skirmish then
61243: LD_EXP 116
61247: NOT
61248: PUSH
61249: LD_EXP 114
61253: NOT
61254: OR
61255: IFFALSE 61259
// exit ;
61257: GO 61458
// for i = 1 to mc_bases do
61259: LD_ADDR_VAR 0 5
61263: PUSH
61264: DOUBLE
61265: LD_INT 1
61267: DEC
61268: ST_TO_ADDR
61269: LD_EXP 116
61273: PUSH
61274: FOR_TO
61275: IFFALSE 61456
// if building in mc_bases [ i ] then
61277: LD_VAR 0 1
61281: PUSH
61282: LD_EXP 116
61286: PUSH
61287: LD_VAR 0 5
61291: ARRAY
61292: IN
61293: IFFALSE 61454
// begin tmp := mc_bases [ i ] diff building ;
61295: LD_ADDR_VAR 0 6
61299: PUSH
61300: LD_EXP 116
61304: PUSH
61305: LD_VAR 0 5
61309: ARRAY
61310: PUSH
61311: LD_VAR 0 1
61315: DIFF
61316: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61317: LD_ADDR_EXP 116
61321: PUSH
61322: LD_EXP 116
61326: PPUSH
61327: LD_VAR 0 5
61331: PPUSH
61332: LD_VAR 0 6
61336: PPUSH
61337: CALL_OW 1
61341: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61342: LD_VAR 0 1
61346: PUSH
61347: LD_EXP 124
61351: PUSH
61352: LD_VAR 0 5
61356: ARRAY
61357: IN
61358: IFFALSE 61397
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61360: LD_ADDR_EXP 124
61364: PUSH
61365: LD_EXP 124
61369: PPUSH
61370: LD_VAR 0 5
61374: PPUSH
61375: LD_EXP 124
61379: PUSH
61380: LD_VAR 0 5
61384: ARRAY
61385: PUSH
61386: LD_VAR 0 1
61390: DIFF
61391: PPUSH
61392: CALL_OW 1
61396: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61397: LD_VAR 0 1
61401: PUSH
61402: LD_EXP 125
61406: PUSH
61407: LD_VAR 0 5
61411: ARRAY
61412: IN
61413: IFFALSE 61452
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61415: LD_ADDR_EXP 125
61419: PUSH
61420: LD_EXP 125
61424: PPUSH
61425: LD_VAR 0 5
61429: PPUSH
61430: LD_EXP 125
61434: PUSH
61435: LD_VAR 0 5
61439: ARRAY
61440: PUSH
61441: LD_VAR 0 1
61445: DIFF
61446: PPUSH
61447: CALL_OW 1
61451: ST_TO_ADDR
// break ;
61452: GO 61456
// end ;
61454: GO 61274
61456: POP
61457: POP
// end ;
61458: LD_VAR 0 4
61462: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61463: LD_INT 0
61465: PPUSH
61466: PPUSH
61467: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61468: LD_EXP 116
61472: NOT
61473: PUSH
61474: LD_EXP 114
61478: NOT
61479: OR
61480: PUSH
61481: LD_VAR 0 3
61485: PUSH
61486: LD_EXP 142
61490: IN
61491: NOT
61492: OR
61493: IFFALSE 61497
// exit ;
61495: GO 61620
// for i = 1 to mc_vehicles do
61497: LD_ADDR_VAR 0 6
61501: PUSH
61502: DOUBLE
61503: LD_INT 1
61505: DEC
61506: ST_TO_ADDR
61507: LD_EXP 135
61511: PUSH
61512: FOR_TO
61513: IFFALSE 61618
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61515: LD_VAR 0 2
61519: PUSH
61520: LD_EXP 135
61524: PUSH
61525: LD_VAR 0 6
61529: ARRAY
61530: IN
61531: PUSH
61532: LD_VAR 0 1
61536: PUSH
61537: LD_EXP 135
61541: PUSH
61542: LD_VAR 0 6
61546: ARRAY
61547: IN
61548: OR
61549: IFFALSE 61616
// begin tmp := mc_vehicles [ i ] diff old ;
61551: LD_ADDR_VAR 0 7
61555: PUSH
61556: LD_EXP 135
61560: PUSH
61561: LD_VAR 0 6
61565: ARRAY
61566: PUSH
61567: LD_VAR 0 2
61571: DIFF
61572: ST_TO_ADDR
// tmp := tmp diff new ;
61573: LD_ADDR_VAR 0 7
61577: PUSH
61578: LD_VAR 0 7
61582: PUSH
61583: LD_VAR 0 1
61587: DIFF
61588: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61589: LD_ADDR_EXP 135
61593: PUSH
61594: LD_EXP 135
61598: PPUSH
61599: LD_VAR 0 6
61603: PPUSH
61604: LD_VAR 0 7
61608: PPUSH
61609: CALL_OW 1
61613: ST_TO_ADDR
// break ;
61614: GO 61618
// end ;
61616: GO 61512
61618: POP
61619: POP
// end ;
61620: LD_VAR 0 5
61624: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61625: LD_INT 0
61627: PPUSH
61628: PPUSH
61629: PPUSH
61630: PPUSH
// if not mc_bases or not skirmish then
61631: LD_EXP 116
61635: NOT
61636: PUSH
61637: LD_EXP 114
61641: NOT
61642: OR
61643: IFFALSE 61647
// exit ;
61645: GO 62039
// side := GetSide ( vehicle ) ;
61647: LD_ADDR_VAR 0 5
61651: PUSH
61652: LD_VAR 0 1
61656: PPUSH
61657: CALL_OW 255
61661: ST_TO_ADDR
// for i = 1 to mc_bases do
61662: LD_ADDR_VAR 0 4
61666: PUSH
61667: DOUBLE
61668: LD_INT 1
61670: DEC
61671: ST_TO_ADDR
61672: LD_EXP 116
61676: PUSH
61677: FOR_TO
61678: IFFALSE 62037
// begin if factory in mc_bases [ i ] then
61680: LD_VAR 0 2
61684: PUSH
61685: LD_EXP 116
61689: PUSH
61690: LD_VAR 0 4
61694: ARRAY
61695: IN
61696: IFFALSE 62035
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61698: LD_EXP 138
61702: PUSH
61703: LD_VAR 0 4
61707: ARRAY
61708: PUSH
61709: LD_EXP 127
61713: PUSH
61714: LD_VAR 0 4
61718: ARRAY
61719: LESS
61720: PUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: CALL_OW 264
61730: PUSH
61731: LD_INT 31
61733: PUSH
61734: LD_INT 32
61736: PUSH
61737: LD_INT 51
61739: PUSH
61740: LD_EXP 96
61744: PUSH
61745: LD_INT 12
61747: PUSH
61748: LD_INT 30
61750: PUSH
61751: LD_EXP 95
61755: PUSH
61756: LD_INT 11
61758: PUSH
61759: LD_INT 53
61761: PUSH
61762: LD_INT 14
61764: PUSH
61765: LD_EXP 99
61769: PUSH
61770: LD_INT 29
61772: PUSH
61773: LD_EXP 97
61777: PUSH
61778: LD_INT 13
61780: PUSH
61781: LD_INT 52
61783: PUSH
61784: LD_EXP 101
61788: PUSH
61789: LD_INT 48
61791: PUSH
61792: LD_INT 8
61794: PUSH
61795: EMPTY
61796: LIST
61797: LIST
61798: LIST
61799: LIST
61800: LIST
61801: LIST
61802: LIST
61803: LIST
61804: LIST
61805: LIST
61806: LIST
61807: LIST
61808: LIST
61809: LIST
61810: LIST
61811: LIST
61812: LIST
61813: LIST
61814: IN
61815: NOT
61816: AND
61817: IFFALSE 61865
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61819: LD_ADDR_EXP 138
61823: PUSH
61824: LD_EXP 138
61828: PPUSH
61829: LD_VAR 0 4
61833: PUSH
61834: LD_EXP 138
61838: PUSH
61839: LD_VAR 0 4
61843: ARRAY
61844: PUSH
61845: LD_INT 1
61847: PLUS
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: PPUSH
61853: LD_VAR 0 1
61857: PPUSH
61858: CALL 70700 0 3
61862: ST_TO_ADDR
61863: GO 61909
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61865: LD_ADDR_EXP 135
61869: PUSH
61870: LD_EXP 135
61874: PPUSH
61875: LD_VAR 0 4
61879: PUSH
61880: LD_EXP 135
61884: PUSH
61885: LD_VAR 0 4
61889: ARRAY
61890: PUSH
61891: LD_INT 1
61893: PLUS
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PPUSH
61899: LD_VAR 0 1
61903: PPUSH
61904: CALL 70700 0 3
61908: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61909: LD_VAR 0 1
61913: PPUSH
61914: CALL_OW 263
61918: PUSH
61919: LD_INT 2
61921: EQUAL
61922: IFFALSE 61951
// begin repeat wait ( 0 0$3 ) ;
61924: LD_INT 105
61926: PPUSH
61927: CALL_OW 67
// Connect ( vehicle ) ;
61931: LD_VAR 0 1
61935: PPUSH
61936: CALL 73671 0 1
// until IsControledBy ( vehicle ) ;
61940: LD_VAR 0 1
61944: PPUSH
61945: CALL_OW 312
61949: IFFALSE 61924
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61951: LD_VAR 0 1
61955: PPUSH
61956: LD_EXP 140
61960: PUSH
61961: LD_VAR 0 4
61965: ARRAY
61966: PPUSH
61967: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61971: LD_VAR 0 1
61975: PPUSH
61976: CALL_OW 263
61980: PUSH
61981: LD_INT 1
61983: NONEQUAL
61984: IFFALSE 61988
// break ;
61986: GO 62037
// repeat wait ( 0 0$1 ) ;
61988: LD_INT 35
61990: PPUSH
61991: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61995: LD_VAR 0 1
61999: PPUSH
62000: LD_EXP 140
62004: PUSH
62005: LD_VAR 0 4
62009: ARRAY
62010: PPUSH
62011: CALL_OW 308
62015: IFFALSE 61988
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62017: LD_VAR 0 1
62021: PPUSH
62022: CALL_OW 311
62026: PPUSH
62027: CALL_OW 121
// exit ;
62031: POP
62032: POP
62033: GO 62039
// end ; end ;
62035: GO 61677
62037: POP
62038: POP
// end ;
62039: LD_VAR 0 3
62043: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62044: LD_INT 0
62046: PPUSH
62047: PPUSH
62048: PPUSH
62049: PPUSH
// if not mc_bases or not skirmish then
62050: LD_EXP 116
62054: NOT
62055: PUSH
62056: LD_EXP 114
62060: NOT
62061: OR
62062: IFFALSE 62066
// exit ;
62064: GO 62419
// repeat wait ( 0 0$1 ) ;
62066: LD_INT 35
62068: PPUSH
62069: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62073: LD_VAR 0 2
62077: PPUSH
62078: LD_VAR 0 3
62082: PPUSH
62083: CALL_OW 284
62087: IFFALSE 62066
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62089: LD_VAR 0 2
62093: PPUSH
62094: LD_VAR 0 3
62098: PPUSH
62099: CALL_OW 283
62103: PUSH
62104: LD_INT 4
62106: EQUAL
62107: IFFALSE 62111
// exit ;
62109: GO 62419
// for i = 1 to mc_bases do
62111: LD_ADDR_VAR 0 7
62115: PUSH
62116: DOUBLE
62117: LD_INT 1
62119: DEC
62120: ST_TO_ADDR
62121: LD_EXP 116
62125: PUSH
62126: FOR_TO
62127: IFFALSE 62417
// begin if mc_crates_area [ i ] then
62129: LD_EXP 134
62133: PUSH
62134: LD_VAR 0 7
62138: ARRAY
62139: IFFALSE 62250
// for j in mc_crates_area [ i ] do
62141: LD_ADDR_VAR 0 8
62145: PUSH
62146: LD_EXP 134
62150: PUSH
62151: LD_VAR 0 7
62155: ARRAY
62156: PUSH
62157: FOR_IN
62158: IFFALSE 62248
// if InArea ( x , y , j ) then
62160: LD_VAR 0 2
62164: PPUSH
62165: LD_VAR 0 3
62169: PPUSH
62170: LD_VAR 0 8
62174: PPUSH
62175: CALL_OW 309
62179: IFFALSE 62246
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62181: LD_ADDR_EXP 132
62185: PUSH
62186: LD_EXP 132
62190: PPUSH
62191: LD_VAR 0 7
62195: PUSH
62196: LD_EXP 132
62200: PUSH
62201: LD_VAR 0 7
62205: ARRAY
62206: PUSH
62207: LD_INT 1
62209: PLUS
62210: PUSH
62211: EMPTY
62212: LIST
62213: LIST
62214: PPUSH
62215: LD_VAR 0 4
62219: PUSH
62220: LD_VAR 0 2
62224: PUSH
62225: LD_VAR 0 3
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: LIST
62234: PPUSH
62235: CALL 70700 0 3
62239: ST_TO_ADDR
// exit ;
62240: POP
62241: POP
62242: POP
62243: POP
62244: GO 62419
// end ;
62246: GO 62157
62248: POP
62249: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62250: LD_ADDR_VAR 0 9
62254: PUSH
62255: LD_EXP 116
62259: PUSH
62260: LD_VAR 0 7
62264: ARRAY
62265: PPUSH
62266: LD_INT 2
62268: PUSH
62269: LD_INT 30
62271: PUSH
62272: LD_INT 0
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: PUSH
62279: LD_INT 30
62281: PUSH
62282: LD_INT 1
62284: PUSH
62285: EMPTY
62286: LIST
62287: LIST
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: LIST
62293: PPUSH
62294: CALL_OW 72
62298: ST_TO_ADDR
// if not depot then
62299: LD_VAR 0 9
62303: NOT
62304: IFFALSE 62308
// continue ;
62306: GO 62126
// for j in depot do
62308: LD_ADDR_VAR 0 8
62312: PUSH
62313: LD_VAR 0 9
62317: PUSH
62318: FOR_IN
62319: IFFALSE 62413
// if GetDistUnitXY ( j , x , y ) < 30 then
62321: LD_VAR 0 8
62325: PPUSH
62326: LD_VAR 0 2
62330: PPUSH
62331: LD_VAR 0 3
62335: PPUSH
62336: CALL_OW 297
62340: PUSH
62341: LD_INT 30
62343: LESS
62344: IFFALSE 62411
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62346: LD_ADDR_EXP 132
62350: PUSH
62351: LD_EXP 132
62355: PPUSH
62356: LD_VAR 0 7
62360: PUSH
62361: LD_EXP 132
62365: PUSH
62366: LD_VAR 0 7
62370: ARRAY
62371: PUSH
62372: LD_INT 1
62374: PLUS
62375: PUSH
62376: EMPTY
62377: LIST
62378: LIST
62379: PPUSH
62380: LD_VAR 0 4
62384: PUSH
62385: LD_VAR 0 2
62389: PUSH
62390: LD_VAR 0 3
62394: PUSH
62395: EMPTY
62396: LIST
62397: LIST
62398: LIST
62399: PPUSH
62400: CALL 70700 0 3
62404: ST_TO_ADDR
// exit ;
62405: POP
62406: POP
62407: POP
62408: POP
62409: GO 62419
// end ;
62411: GO 62318
62413: POP
62414: POP
// end ;
62415: GO 62126
62417: POP
62418: POP
// end ;
62419: LD_VAR 0 6
62423: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62424: LD_INT 0
62426: PPUSH
62427: PPUSH
62428: PPUSH
62429: PPUSH
// if not mc_bases or not skirmish then
62430: LD_EXP 116
62434: NOT
62435: PUSH
62436: LD_EXP 114
62440: NOT
62441: OR
62442: IFFALSE 62446
// exit ;
62444: GO 62723
// side := GetSide ( lab ) ;
62446: LD_ADDR_VAR 0 4
62450: PUSH
62451: LD_VAR 0 2
62455: PPUSH
62456: CALL_OW 255
62460: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62461: LD_VAR 0 4
62465: PUSH
62466: LD_EXP 142
62470: IN
62471: NOT
62472: PUSH
62473: LD_EXP 143
62477: NOT
62478: OR
62479: PUSH
62480: LD_EXP 116
62484: NOT
62485: OR
62486: IFFALSE 62490
// exit ;
62488: GO 62723
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62490: LD_ADDR_EXP 143
62494: PUSH
62495: LD_EXP 143
62499: PPUSH
62500: LD_VAR 0 4
62504: PPUSH
62505: LD_EXP 143
62509: PUSH
62510: LD_VAR 0 4
62514: ARRAY
62515: PUSH
62516: LD_VAR 0 1
62520: DIFF
62521: PPUSH
62522: CALL_OW 1
62526: ST_TO_ADDR
// for i = 1 to mc_bases do
62527: LD_ADDR_VAR 0 5
62531: PUSH
62532: DOUBLE
62533: LD_INT 1
62535: DEC
62536: ST_TO_ADDR
62537: LD_EXP 116
62541: PUSH
62542: FOR_TO
62543: IFFALSE 62721
// begin if lab in mc_bases [ i ] then
62545: LD_VAR 0 2
62549: PUSH
62550: LD_EXP 116
62554: PUSH
62555: LD_VAR 0 5
62559: ARRAY
62560: IN
62561: IFFALSE 62719
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62563: LD_VAR 0 1
62567: PUSH
62568: LD_INT 11
62570: PUSH
62571: LD_INT 4
62573: PUSH
62574: LD_INT 3
62576: PUSH
62577: LD_INT 2
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: IN
62586: PUSH
62587: LD_EXP 146
62591: PUSH
62592: LD_VAR 0 5
62596: ARRAY
62597: AND
62598: IFFALSE 62719
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62600: LD_ADDR_VAR 0 6
62604: PUSH
62605: LD_EXP 146
62609: PUSH
62610: LD_VAR 0 5
62614: ARRAY
62615: PUSH
62616: LD_INT 1
62618: ARRAY
62619: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62620: LD_ADDR_EXP 146
62624: PUSH
62625: LD_EXP 146
62629: PPUSH
62630: LD_VAR 0 5
62634: PPUSH
62635: EMPTY
62636: PPUSH
62637: CALL_OW 1
62641: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62642: LD_VAR 0 6
62646: PPUSH
62647: LD_INT 0
62649: PPUSH
62650: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62654: LD_VAR 0 6
62658: PPUSH
62659: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62663: LD_ADDR_EXP 145
62667: PUSH
62668: LD_EXP 145
62672: PPUSH
62673: LD_VAR 0 5
62677: PPUSH
62678: LD_EXP 145
62682: PUSH
62683: LD_VAR 0 5
62687: ARRAY
62688: PPUSH
62689: LD_INT 1
62691: PPUSH
62692: LD_VAR 0 6
62696: PPUSH
62697: CALL_OW 2
62701: PPUSH
62702: CALL_OW 1
62706: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62707: LD_VAR 0 5
62711: PPUSH
62712: LD_INT 112
62714: PPUSH
62715: CALL 39389 0 2
// end ; end ; end ;
62719: GO 62542
62721: POP
62722: POP
// end ;
62723: LD_VAR 0 3
62727: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62728: LD_INT 0
62730: PPUSH
62731: PPUSH
62732: PPUSH
62733: PPUSH
62734: PPUSH
62735: PPUSH
62736: PPUSH
62737: PPUSH
// if not mc_bases or not skirmish then
62738: LD_EXP 116
62742: NOT
62743: PUSH
62744: LD_EXP 114
62748: NOT
62749: OR
62750: IFFALSE 62754
// exit ;
62752: GO 64125
// for i = 1 to mc_bases do
62754: LD_ADDR_VAR 0 3
62758: PUSH
62759: DOUBLE
62760: LD_INT 1
62762: DEC
62763: ST_TO_ADDR
62764: LD_EXP 116
62768: PUSH
62769: FOR_TO
62770: IFFALSE 64123
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62772: LD_VAR 0 1
62776: PUSH
62777: LD_EXP 116
62781: PUSH
62782: LD_VAR 0 3
62786: ARRAY
62787: IN
62788: PUSH
62789: LD_VAR 0 1
62793: PUSH
62794: LD_EXP 123
62798: PUSH
62799: LD_VAR 0 3
62803: ARRAY
62804: IN
62805: OR
62806: PUSH
62807: LD_VAR 0 1
62811: PUSH
62812: LD_EXP 138
62816: PUSH
62817: LD_VAR 0 3
62821: ARRAY
62822: IN
62823: OR
62824: PUSH
62825: LD_VAR 0 1
62829: PUSH
62830: LD_EXP 135
62834: PUSH
62835: LD_VAR 0 3
62839: ARRAY
62840: IN
62841: OR
62842: PUSH
62843: LD_VAR 0 1
62847: PUSH
62848: LD_EXP 145
62852: PUSH
62853: LD_VAR 0 3
62857: ARRAY
62858: IN
62859: OR
62860: PUSH
62861: LD_VAR 0 1
62865: PUSH
62866: LD_EXP 146
62870: PUSH
62871: LD_VAR 0 3
62875: ARRAY
62876: IN
62877: OR
62878: IFFALSE 64121
// begin if un in mc_ape [ i ] then
62880: LD_VAR 0 1
62884: PUSH
62885: LD_EXP 145
62889: PUSH
62890: LD_VAR 0 3
62894: ARRAY
62895: IN
62896: IFFALSE 62935
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62898: LD_ADDR_EXP 145
62902: PUSH
62903: LD_EXP 145
62907: PPUSH
62908: LD_VAR 0 3
62912: PPUSH
62913: LD_EXP 145
62917: PUSH
62918: LD_VAR 0 3
62922: ARRAY
62923: PUSH
62924: LD_VAR 0 1
62928: DIFF
62929: PPUSH
62930: CALL_OW 1
62934: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62935: LD_VAR 0 1
62939: PUSH
62940: LD_EXP 146
62944: PUSH
62945: LD_VAR 0 3
62949: ARRAY
62950: IN
62951: IFFALSE 62975
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62953: LD_ADDR_EXP 146
62957: PUSH
62958: LD_EXP 146
62962: PPUSH
62963: LD_VAR 0 3
62967: PPUSH
62968: EMPTY
62969: PPUSH
62970: CALL_OW 1
62974: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62975: LD_VAR 0 1
62979: PPUSH
62980: CALL_OW 247
62984: PUSH
62985: LD_INT 2
62987: EQUAL
62988: PUSH
62989: LD_VAR 0 1
62993: PPUSH
62994: CALL_OW 110
62998: PUSH
62999: LD_INT 20
63001: EQUAL
63002: PUSH
63003: LD_VAR 0 1
63007: PUSH
63008: LD_EXP 138
63012: PUSH
63013: LD_VAR 0 3
63017: ARRAY
63018: IN
63019: OR
63020: PUSH
63021: LD_VAR 0 1
63025: PPUSH
63026: CALL_OW 264
63030: PUSH
63031: LD_INT 12
63033: PUSH
63034: LD_INT 51
63036: PUSH
63037: LD_EXP 96
63041: PUSH
63042: LD_INT 32
63044: PUSH
63045: LD_INT 13
63047: PUSH
63048: LD_INT 52
63050: PUSH
63051: LD_INT 31
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: LIST
63058: LIST
63059: LIST
63060: LIST
63061: LIST
63062: IN
63063: OR
63064: AND
63065: IFFALSE 63373
// begin if un in mc_defender [ i ] then
63067: LD_VAR 0 1
63071: PUSH
63072: LD_EXP 138
63076: PUSH
63077: LD_VAR 0 3
63081: ARRAY
63082: IN
63083: IFFALSE 63122
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63085: LD_ADDR_EXP 138
63089: PUSH
63090: LD_EXP 138
63094: PPUSH
63095: LD_VAR 0 3
63099: PPUSH
63100: LD_EXP 138
63104: PUSH
63105: LD_VAR 0 3
63109: ARRAY
63110: PUSH
63111: LD_VAR 0 1
63115: DIFF
63116: PPUSH
63117: CALL_OW 1
63121: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63122: LD_ADDR_VAR 0 8
63126: PUSH
63127: LD_VAR 0 3
63131: PPUSH
63132: LD_INT 3
63134: PPUSH
63135: CALL 59763 0 2
63139: ST_TO_ADDR
// if fac then
63140: LD_VAR 0 8
63144: IFFALSE 63373
// begin for j in fac do
63146: LD_ADDR_VAR 0 4
63150: PUSH
63151: LD_VAR 0 8
63155: PUSH
63156: FOR_IN
63157: IFFALSE 63371
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63159: LD_ADDR_VAR 0 9
63163: PUSH
63164: LD_VAR 0 8
63168: PPUSH
63169: LD_VAR 0 1
63173: PPUSH
63174: CALL_OW 265
63178: PPUSH
63179: LD_VAR 0 1
63183: PPUSH
63184: CALL_OW 262
63188: PPUSH
63189: LD_VAR 0 1
63193: PPUSH
63194: CALL_OW 263
63198: PPUSH
63199: LD_VAR 0 1
63203: PPUSH
63204: CALL_OW 264
63208: PPUSH
63209: CALL 68196 0 5
63213: ST_TO_ADDR
// if components then
63214: LD_VAR 0 9
63218: IFFALSE 63369
// begin if GetWeapon ( un ) = ar_control_tower then
63220: LD_VAR 0 1
63224: PPUSH
63225: CALL_OW 264
63229: PUSH
63230: LD_INT 31
63232: EQUAL
63233: IFFALSE 63350
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63235: LD_VAR 0 1
63239: PPUSH
63240: CALL_OW 311
63244: PPUSH
63245: LD_INT 0
63247: PPUSH
63248: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63252: LD_ADDR_EXP 156
63256: PUSH
63257: LD_EXP 156
63261: PPUSH
63262: LD_VAR 0 3
63266: PPUSH
63267: LD_EXP 156
63271: PUSH
63272: LD_VAR 0 3
63276: ARRAY
63277: PUSH
63278: LD_VAR 0 1
63282: PPUSH
63283: CALL_OW 311
63287: DIFF
63288: PPUSH
63289: CALL_OW 1
63293: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63294: LD_ADDR_VAR 0 7
63298: PUSH
63299: LD_EXP 137
63303: PUSH
63304: LD_VAR 0 3
63308: ARRAY
63309: PPUSH
63310: LD_INT 1
63312: PPUSH
63313: LD_VAR 0 9
63317: PPUSH
63318: CALL_OW 2
63322: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63323: LD_ADDR_EXP 137
63327: PUSH
63328: LD_EXP 137
63332: PPUSH
63333: LD_VAR 0 3
63337: PPUSH
63338: LD_VAR 0 7
63342: PPUSH
63343: CALL_OW 1
63347: ST_TO_ADDR
// end else
63348: GO 63367
// MC_InsertProduceList ( i , [ components ] ) ;
63350: LD_VAR 0 3
63354: PPUSH
63355: LD_VAR 0 9
63359: PUSH
63360: EMPTY
63361: LIST
63362: PPUSH
63363: CALL 59308 0 2
// break ;
63367: GO 63371
// end ; end ;
63369: GO 63156
63371: POP
63372: POP
// end ; end ; if GetType ( un ) = unit_building then
63373: LD_VAR 0 1
63377: PPUSH
63378: CALL_OW 247
63382: PUSH
63383: LD_INT 3
63385: EQUAL
63386: IFFALSE 63789
// begin btype := GetBType ( un ) ;
63388: LD_ADDR_VAR 0 5
63392: PUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: CALL_OW 266
63402: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63403: LD_VAR 0 5
63407: PUSH
63408: LD_INT 29
63410: PUSH
63411: LD_INT 30
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: IN
63418: IFFALSE 63491
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63420: LD_VAR 0 1
63424: PPUSH
63425: CALL_OW 250
63429: PPUSH
63430: LD_VAR 0 1
63434: PPUSH
63435: CALL_OW 251
63439: PPUSH
63440: LD_VAR 0 1
63444: PPUSH
63445: CALL_OW 255
63449: PPUSH
63450: CALL_OW 440
63454: NOT
63455: IFFALSE 63491
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63457: LD_VAR 0 1
63461: PPUSH
63462: CALL_OW 250
63466: PPUSH
63467: LD_VAR 0 1
63471: PPUSH
63472: CALL_OW 251
63476: PPUSH
63477: LD_VAR 0 1
63481: PPUSH
63482: CALL_OW 255
63486: PPUSH
63487: CALL_OW 441
// end ; if btype = b_warehouse then
63491: LD_VAR 0 5
63495: PUSH
63496: LD_INT 1
63498: EQUAL
63499: IFFALSE 63517
// begin btype := b_depot ;
63501: LD_ADDR_VAR 0 5
63505: PUSH
63506: LD_INT 0
63508: ST_TO_ADDR
// pos := 1 ;
63509: LD_ADDR_VAR 0 6
63513: PUSH
63514: LD_INT 1
63516: ST_TO_ADDR
// end ; if btype = b_factory then
63517: LD_VAR 0 5
63521: PUSH
63522: LD_INT 3
63524: EQUAL
63525: IFFALSE 63543
// begin btype := b_workshop ;
63527: LD_ADDR_VAR 0 5
63531: PUSH
63532: LD_INT 2
63534: ST_TO_ADDR
// pos := 1 ;
63535: LD_ADDR_VAR 0 6
63539: PUSH
63540: LD_INT 1
63542: ST_TO_ADDR
// end ; if btype = b_barracks then
63543: LD_VAR 0 5
63547: PUSH
63548: LD_INT 5
63550: EQUAL
63551: IFFALSE 63561
// btype := b_armoury ;
63553: LD_ADDR_VAR 0 5
63557: PUSH
63558: LD_INT 4
63560: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63561: LD_VAR 0 5
63565: PUSH
63566: LD_INT 7
63568: PUSH
63569: LD_INT 8
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: IN
63576: IFFALSE 63586
// btype := b_lab ;
63578: LD_ADDR_VAR 0 5
63582: PUSH
63583: LD_INT 6
63585: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63586: LD_ADDR_EXP 121
63590: PUSH
63591: LD_EXP 121
63595: PPUSH
63596: LD_VAR 0 3
63600: PUSH
63601: LD_EXP 121
63605: PUSH
63606: LD_VAR 0 3
63610: ARRAY
63611: PUSH
63612: LD_INT 1
63614: PLUS
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PPUSH
63620: LD_VAR 0 5
63624: PUSH
63625: LD_VAR 0 1
63629: PPUSH
63630: CALL_OW 250
63634: PUSH
63635: LD_VAR 0 1
63639: PPUSH
63640: CALL_OW 251
63644: PUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: CALL_OW 254
63654: PUSH
63655: EMPTY
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: PPUSH
63661: CALL 70700 0 3
63665: ST_TO_ADDR
// if pos = 1 then
63666: LD_VAR 0 6
63670: PUSH
63671: LD_INT 1
63673: EQUAL
63674: IFFALSE 63789
// begin tmp := mc_build_list [ i ] ;
63676: LD_ADDR_VAR 0 7
63680: PUSH
63681: LD_EXP 121
63685: PUSH
63686: LD_VAR 0 3
63690: ARRAY
63691: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63692: LD_VAR 0 7
63696: PPUSH
63697: LD_INT 2
63699: PUSH
63700: LD_INT 30
63702: PUSH
63703: LD_INT 0
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 30
63712: PUSH
63713: LD_INT 1
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: LIST
63724: PPUSH
63725: CALL_OW 72
63729: IFFALSE 63739
// pos := 2 ;
63731: LD_ADDR_VAR 0 6
63735: PUSH
63736: LD_INT 2
63738: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63739: LD_ADDR_VAR 0 7
63743: PUSH
63744: LD_VAR 0 7
63748: PPUSH
63749: LD_VAR 0 6
63753: PPUSH
63754: LD_VAR 0 7
63758: PPUSH
63759: CALL 71026 0 3
63763: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63764: LD_ADDR_EXP 121
63768: PUSH
63769: LD_EXP 121
63773: PPUSH
63774: LD_VAR 0 3
63778: PPUSH
63779: LD_VAR 0 7
63783: PPUSH
63784: CALL_OW 1
63788: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63789: LD_VAR 0 1
63793: PUSH
63794: LD_EXP 116
63798: PUSH
63799: LD_VAR 0 3
63803: ARRAY
63804: IN
63805: IFFALSE 63844
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63807: LD_ADDR_EXP 116
63811: PUSH
63812: LD_EXP 116
63816: PPUSH
63817: LD_VAR 0 3
63821: PPUSH
63822: LD_EXP 116
63826: PUSH
63827: LD_VAR 0 3
63831: ARRAY
63832: PUSH
63833: LD_VAR 0 1
63837: DIFF
63838: PPUSH
63839: CALL_OW 1
63843: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63844: LD_VAR 0 1
63848: PUSH
63849: LD_EXP 123
63853: PUSH
63854: LD_VAR 0 3
63858: ARRAY
63859: IN
63860: IFFALSE 63899
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63862: LD_ADDR_EXP 123
63866: PUSH
63867: LD_EXP 123
63871: PPUSH
63872: LD_VAR 0 3
63876: PPUSH
63877: LD_EXP 123
63881: PUSH
63882: LD_VAR 0 3
63886: ARRAY
63887: PUSH
63888: LD_VAR 0 1
63892: DIFF
63893: PPUSH
63894: CALL_OW 1
63898: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63899: LD_VAR 0 1
63903: PUSH
63904: LD_EXP 135
63908: PUSH
63909: LD_VAR 0 3
63913: ARRAY
63914: IN
63915: IFFALSE 63954
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63917: LD_ADDR_EXP 135
63921: PUSH
63922: LD_EXP 135
63926: PPUSH
63927: LD_VAR 0 3
63931: PPUSH
63932: LD_EXP 135
63936: PUSH
63937: LD_VAR 0 3
63941: ARRAY
63942: PUSH
63943: LD_VAR 0 1
63947: DIFF
63948: PPUSH
63949: CALL_OW 1
63953: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63954: LD_VAR 0 1
63958: PUSH
63959: LD_EXP 138
63963: PUSH
63964: LD_VAR 0 3
63968: ARRAY
63969: IN
63970: IFFALSE 64009
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63972: LD_ADDR_EXP 138
63976: PUSH
63977: LD_EXP 138
63981: PPUSH
63982: LD_VAR 0 3
63986: PPUSH
63987: LD_EXP 138
63991: PUSH
63992: LD_VAR 0 3
63996: ARRAY
63997: PUSH
63998: LD_VAR 0 1
64002: DIFF
64003: PPUSH
64004: CALL_OW 1
64008: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64009: LD_VAR 0 1
64013: PUSH
64014: LD_EXP 125
64018: PUSH
64019: LD_VAR 0 3
64023: ARRAY
64024: IN
64025: IFFALSE 64064
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64027: LD_ADDR_EXP 125
64031: PUSH
64032: LD_EXP 125
64036: PPUSH
64037: LD_VAR 0 3
64041: PPUSH
64042: LD_EXP 125
64046: PUSH
64047: LD_VAR 0 3
64051: ARRAY
64052: PUSH
64053: LD_VAR 0 1
64057: DIFF
64058: PPUSH
64059: CALL_OW 1
64063: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64064: LD_VAR 0 1
64068: PUSH
64069: LD_EXP 124
64073: PUSH
64074: LD_VAR 0 3
64078: ARRAY
64079: IN
64080: IFFALSE 64119
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64082: LD_ADDR_EXP 124
64086: PUSH
64087: LD_EXP 124
64091: PPUSH
64092: LD_VAR 0 3
64096: PPUSH
64097: LD_EXP 124
64101: PUSH
64102: LD_VAR 0 3
64106: ARRAY
64107: PUSH
64108: LD_VAR 0 1
64112: DIFF
64113: PPUSH
64114: CALL_OW 1
64118: ST_TO_ADDR
// end ; break ;
64119: GO 64123
// end ;
64121: GO 62769
64123: POP
64124: POP
// end ;
64125: LD_VAR 0 2
64129: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64130: LD_INT 0
64132: PPUSH
64133: PPUSH
64134: PPUSH
// if not mc_bases or not skirmish then
64135: LD_EXP 116
64139: NOT
64140: PUSH
64141: LD_EXP 114
64145: NOT
64146: OR
64147: IFFALSE 64151
// exit ;
64149: GO 64366
// for i = 1 to mc_bases do
64151: LD_ADDR_VAR 0 3
64155: PUSH
64156: DOUBLE
64157: LD_INT 1
64159: DEC
64160: ST_TO_ADDR
64161: LD_EXP 116
64165: PUSH
64166: FOR_TO
64167: IFFALSE 64364
// begin if building in mc_construct_list [ i ] then
64169: LD_VAR 0 1
64173: PUSH
64174: LD_EXP 123
64178: PUSH
64179: LD_VAR 0 3
64183: ARRAY
64184: IN
64185: IFFALSE 64362
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64187: LD_ADDR_EXP 123
64191: PUSH
64192: LD_EXP 123
64196: PPUSH
64197: LD_VAR 0 3
64201: PPUSH
64202: LD_EXP 123
64206: PUSH
64207: LD_VAR 0 3
64211: ARRAY
64212: PUSH
64213: LD_VAR 0 1
64217: DIFF
64218: PPUSH
64219: CALL_OW 1
64223: ST_TO_ADDR
// if building in mc_lab [ i ] then
64224: LD_VAR 0 1
64228: PUSH
64229: LD_EXP 149
64233: PUSH
64234: LD_VAR 0 3
64238: ARRAY
64239: IN
64240: IFFALSE 64295
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64242: LD_ADDR_EXP 150
64246: PUSH
64247: LD_EXP 150
64251: PPUSH
64252: LD_VAR 0 3
64256: PPUSH
64257: LD_EXP 150
64261: PUSH
64262: LD_VAR 0 3
64266: ARRAY
64267: PPUSH
64268: LD_INT 1
64270: PPUSH
64271: LD_EXP 150
64275: PUSH
64276: LD_VAR 0 3
64280: ARRAY
64281: PPUSH
64282: LD_INT 0
64284: PPUSH
64285: CALL 70118 0 4
64289: PPUSH
64290: CALL_OW 1
64294: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64295: LD_VAR 0 1
64299: PUSH
64300: LD_EXP 116
64304: PUSH
64305: LD_VAR 0 3
64309: ARRAY
64310: IN
64311: NOT
64312: IFFALSE 64358
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64314: LD_ADDR_EXP 116
64318: PUSH
64319: LD_EXP 116
64323: PPUSH
64324: LD_VAR 0 3
64328: PUSH
64329: LD_EXP 116
64333: PUSH
64334: LD_VAR 0 3
64338: ARRAY
64339: PUSH
64340: LD_INT 1
64342: PLUS
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PPUSH
64348: LD_VAR 0 1
64352: PPUSH
64353: CALL 70700 0 3
64357: ST_TO_ADDR
// exit ;
64358: POP
64359: POP
64360: GO 64366
// end ; end ;
64362: GO 64166
64364: POP
64365: POP
// end ;
64366: LD_VAR 0 2
64370: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64371: LD_INT 0
64373: PPUSH
64374: PPUSH
64375: PPUSH
64376: PPUSH
64377: PPUSH
64378: PPUSH
64379: PPUSH
// if not mc_bases or not skirmish then
64380: LD_EXP 116
64384: NOT
64385: PUSH
64386: LD_EXP 114
64390: NOT
64391: OR
64392: IFFALSE 64396
// exit ;
64394: GO 65057
// for i = 1 to mc_bases do
64396: LD_ADDR_VAR 0 3
64400: PUSH
64401: DOUBLE
64402: LD_INT 1
64404: DEC
64405: ST_TO_ADDR
64406: LD_EXP 116
64410: PUSH
64411: FOR_TO
64412: IFFALSE 65055
// begin if building in mc_construct_list [ i ] then
64414: LD_VAR 0 1
64418: PUSH
64419: LD_EXP 123
64423: PUSH
64424: LD_VAR 0 3
64428: ARRAY
64429: IN
64430: IFFALSE 65053
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64432: LD_ADDR_EXP 123
64436: PUSH
64437: LD_EXP 123
64441: PPUSH
64442: LD_VAR 0 3
64446: PPUSH
64447: LD_EXP 123
64451: PUSH
64452: LD_VAR 0 3
64456: ARRAY
64457: PUSH
64458: LD_VAR 0 1
64462: DIFF
64463: PPUSH
64464: CALL_OW 1
64468: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64469: LD_ADDR_EXP 116
64473: PUSH
64474: LD_EXP 116
64478: PPUSH
64479: LD_VAR 0 3
64483: PUSH
64484: LD_EXP 116
64488: PUSH
64489: LD_VAR 0 3
64493: ARRAY
64494: PUSH
64495: LD_INT 1
64497: PLUS
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: CALL 70700 0 3
64512: ST_TO_ADDR
// btype := GetBType ( building ) ;
64513: LD_ADDR_VAR 0 5
64517: PUSH
64518: LD_VAR 0 1
64522: PPUSH
64523: CALL_OW 266
64527: ST_TO_ADDR
// side := GetSide ( building ) ;
64528: LD_ADDR_VAR 0 8
64532: PUSH
64533: LD_VAR 0 1
64537: PPUSH
64538: CALL_OW 255
64542: ST_TO_ADDR
// if btype = b_lab then
64543: LD_VAR 0 5
64547: PUSH
64548: LD_INT 6
64550: EQUAL
64551: IFFALSE 64601
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64553: LD_ADDR_EXP 149
64557: PUSH
64558: LD_EXP 149
64562: PPUSH
64563: LD_VAR 0 3
64567: PUSH
64568: LD_EXP 149
64572: PUSH
64573: LD_VAR 0 3
64577: ARRAY
64578: PUSH
64579: LD_INT 1
64581: PLUS
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PPUSH
64587: LD_VAR 0 1
64591: PPUSH
64592: CALL 70700 0 3
64596: ST_TO_ADDR
// exit ;
64597: POP
64598: POP
64599: GO 65057
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64601: LD_VAR 0 5
64605: PUSH
64606: LD_INT 0
64608: PUSH
64609: LD_INT 2
64611: PUSH
64612: LD_INT 4
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: LIST
64619: IN
64620: IFFALSE 64744
// begin if btype = b_armoury then
64622: LD_VAR 0 5
64626: PUSH
64627: LD_INT 4
64629: EQUAL
64630: IFFALSE 64640
// btype := b_barracks ;
64632: LD_ADDR_VAR 0 5
64636: PUSH
64637: LD_INT 5
64639: ST_TO_ADDR
// if btype = b_depot then
64640: LD_VAR 0 5
64644: PUSH
64645: LD_INT 0
64647: EQUAL
64648: IFFALSE 64658
// btype := b_warehouse ;
64650: LD_ADDR_VAR 0 5
64654: PUSH
64655: LD_INT 1
64657: ST_TO_ADDR
// if btype = b_workshop then
64658: LD_VAR 0 5
64662: PUSH
64663: LD_INT 2
64665: EQUAL
64666: IFFALSE 64676
// btype := b_factory ;
64668: LD_ADDR_VAR 0 5
64672: PUSH
64673: LD_INT 3
64675: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64676: LD_VAR 0 5
64680: PPUSH
64681: LD_VAR 0 8
64685: PPUSH
64686: CALL_OW 323
64690: PUSH
64691: LD_INT 1
64693: EQUAL
64694: IFFALSE 64740
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64696: LD_ADDR_EXP 148
64700: PUSH
64701: LD_EXP 148
64705: PPUSH
64706: LD_VAR 0 3
64710: PUSH
64711: LD_EXP 148
64715: PUSH
64716: LD_VAR 0 3
64720: ARRAY
64721: PUSH
64722: LD_INT 1
64724: PLUS
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: PPUSH
64730: LD_VAR 0 1
64734: PPUSH
64735: CALL 70700 0 3
64739: ST_TO_ADDR
// exit ;
64740: POP
64741: POP
64742: GO 65057
// end ; if btype in [ b_bunker , b_turret ] then
64744: LD_VAR 0 5
64748: PUSH
64749: LD_INT 32
64751: PUSH
64752: LD_INT 33
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: IN
64759: IFFALSE 65049
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64761: LD_ADDR_EXP 124
64765: PUSH
64766: LD_EXP 124
64770: PPUSH
64771: LD_VAR 0 3
64775: PUSH
64776: LD_EXP 124
64780: PUSH
64781: LD_VAR 0 3
64785: ARRAY
64786: PUSH
64787: LD_INT 1
64789: PLUS
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PPUSH
64795: LD_VAR 0 1
64799: PPUSH
64800: CALL 70700 0 3
64804: ST_TO_ADDR
// if btype = b_bunker then
64805: LD_VAR 0 5
64809: PUSH
64810: LD_INT 32
64812: EQUAL
64813: IFFALSE 65049
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64815: LD_ADDR_EXP 125
64819: PUSH
64820: LD_EXP 125
64824: PPUSH
64825: LD_VAR 0 3
64829: PUSH
64830: LD_EXP 125
64834: PUSH
64835: LD_VAR 0 3
64839: ARRAY
64840: PUSH
64841: LD_INT 1
64843: PLUS
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PPUSH
64849: LD_VAR 0 1
64853: PPUSH
64854: CALL 70700 0 3
64858: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64859: LD_ADDR_VAR 0 6
64863: PUSH
64864: LD_EXP 116
64868: PUSH
64869: LD_VAR 0 3
64873: ARRAY
64874: PPUSH
64875: LD_INT 25
64877: PUSH
64878: LD_INT 1
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 3
64887: PUSH
64888: LD_INT 54
64890: PUSH
64891: EMPTY
64892: LIST
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PPUSH
64902: CALL_OW 72
64906: ST_TO_ADDR
// if tmp then
64907: LD_VAR 0 6
64911: IFFALSE 64917
// exit ;
64913: POP
64914: POP
64915: GO 65057
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64917: LD_ADDR_VAR 0 6
64921: PUSH
64922: LD_EXP 116
64926: PUSH
64927: LD_VAR 0 3
64931: ARRAY
64932: PPUSH
64933: LD_INT 2
64935: PUSH
64936: LD_INT 30
64938: PUSH
64939: LD_INT 4
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 30
64948: PUSH
64949: LD_INT 5
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: LIST
64960: PPUSH
64961: CALL_OW 72
64965: ST_TO_ADDR
// if not tmp then
64966: LD_VAR 0 6
64970: NOT
64971: IFFALSE 64977
// exit ;
64973: POP
64974: POP
64975: GO 65057
// for j in tmp do
64977: LD_ADDR_VAR 0 4
64981: PUSH
64982: LD_VAR 0 6
64986: PUSH
64987: FOR_IN
64988: IFFALSE 65047
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64990: LD_ADDR_VAR 0 7
64994: PUSH
64995: LD_VAR 0 4
64999: PPUSH
65000: CALL_OW 313
65004: PPUSH
65005: LD_INT 25
65007: PUSH
65008: LD_INT 1
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PPUSH
65015: CALL_OW 72
65019: ST_TO_ADDR
// if units then
65020: LD_VAR 0 7
65024: IFFALSE 65045
// begin ComExitBuilding ( units [ 1 ] ) ;
65026: LD_VAR 0 7
65030: PUSH
65031: LD_INT 1
65033: ARRAY
65034: PPUSH
65035: CALL_OW 122
// exit ;
65039: POP
65040: POP
65041: POP
65042: POP
65043: GO 65057
// end ; end ;
65045: GO 64987
65047: POP
65048: POP
// end ; end ; exit ;
65049: POP
65050: POP
65051: GO 65057
// end ; end ;
65053: GO 64411
65055: POP
65056: POP
// end ;
65057: LD_VAR 0 2
65061: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65062: LD_INT 0
65064: PPUSH
65065: PPUSH
65066: PPUSH
65067: PPUSH
65068: PPUSH
65069: PPUSH
65070: PPUSH
// if not mc_bases or not skirmish then
65071: LD_EXP 116
65075: NOT
65076: PUSH
65077: LD_EXP 114
65081: NOT
65082: OR
65083: IFFALSE 65087
// exit ;
65085: GO 65352
// btype := GetBType ( building ) ;
65087: LD_ADDR_VAR 0 6
65091: PUSH
65092: LD_VAR 0 1
65096: PPUSH
65097: CALL_OW 266
65101: ST_TO_ADDR
// x := GetX ( building ) ;
65102: LD_ADDR_VAR 0 7
65106: PUSH
65107: LD_VAR 0 1
65111: PPUSH
65112: CALL_OW 250
65116: ST_TO_ADDR
// y := GetY ( building ) ;
65117: LD_ADDR_VAR 0 8
65121: PUSH
65122: LD_VAR 0 1
65126: PPUSH
65127: CALL_OW 251
65131: ST_TO_ADDR
// d := GetDir ( building ) ;
65132: LD_ADDR_VAR 0 9
65136: PUSH
65137: LD_VAR 0 1
65141: PPUSH
65142: CALL_OW 254
65146: ST_TO_ADDR
// for i = 1 to mc_bases do
65147: LD_ADDR_VAR 0 4
65151: PUSH
65152: DOUBLE
65153: LD_INT 1
65155: DEC
65156: ST_TO_ADDR
65157: LD_EXP 116
65161: PUSH
65162: FOR_TO
65163: IFFALSE 65350
// begin if not mc_build_list [ i ] then
65165: LD_EXP 121
65169: PUSH
65170: LD_VAR 0 4
65174: ARRAY
65175: NOT
65176: IFFALSE 65180
// continue ;
65178: GO 65162
// for j := 1 to mc_build_list [ i ] do
65180: LD_ADDR_VAR 0 5
65184: PUSH
65185: DOUBLE
65186: LD_INT 1
65188: DEC
65189: ST_TO_ADDR
65190: LD_EXP 121
65194: PUSH
65195: LD_VAR 0 4
65199: ARRAY
65200: PUSH
65201: FOR_TO
65202: IFFALSE 65346
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65204: LD_VAR 0 6
65208: PUSH
65209: LD_VAR 0 7
65213: PUSH
65214: LD_VAR 0 8
65218: PUSH
65219: LD_VAR 0 9
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: PPUSH
65230: LD_EXP 121
65234: PUSH
65235: LD_VAR 0 4
65239: ARRAY
65240: PUSH
65241: LD_VAR 0 5
65245: ARRAY
65246: PPUSH
65247: CALL 76882 0 2
65251: IFFALSE 65344
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65253: LD_ADDR_EXP 121
65257: PUSH
65258: LD_EXP 121
65262: PPUSH
65263: LD_VAR 0 4
65267: PPUSH
65268: LD_EXP 121
65272: PUSH
65273: LD_VAR 0 4
65277: ARRAY
65278: PPUSH
65279: LD_VAR 0 5
65283: PPUSH
65284: CALL_OW 3
65288: PPUSH
65289: CALL_OW 1
65293: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65294: LD_ADDR_EXP 123
65298: PUSH
65299: LD_EXP 123
65303: PPUSH
65304: LD_VAR 0 4
65308: PUSH
65309: LD_EXP 123
65313: PUSH
65314: LD_VAR 0 4
65318: ARRAY
65319: PUSH
65320: LD_INT 1
65322: PLUS
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PPUSH
65328: LD_VAR 0 1
65332: PPUSH
65333: CALL 70700 0 3
65337: ST_TO_ADDR
// exit ;
65338: POP
65339: POP
65340: POP
65341: POP
65342: GO 65352
// end ;
65344: GO 65201
65346: POP
65347: POP
// end ;
65348: GO 65162
65350: POP
65351: POP
// end ;
65352: LD_VAR 0 3
65356: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65357: LD_INT 0
65359: PPUSH
65360: PPUSH
65361: PPUSH
// if not mc_bases or not skirmish then
65362: LD_EXP 116
65366: NOT
65367: PUSH
65368: LD_EXP 114
65372: NOT
65373: OR
65374: IFFALSE 65378
// exit ;
65376: GO 65568
// for i = 1 to mc_bases do
65378: LD_ADDR_VAR 0 4
65382: PUSH
65383: DOUBLE
65384: LD_INT 1
65386: DEC
65387: ST_TO_ADDR
65388: LD_EXP 116
65392: PUSH
65393: FOR_TO
65394: IFFALSE 65481
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65396: LD_VAR 0 1
65400: PUSH
65401: LD_EXP 124
65405: PUSH
65406: LD_VAR 0 4
65410: ARRAY
65411: IN
65412: PUSH
65413: LD_VAR 0 1
65417: PUSH
65418: LD_EXP 125
65422: PUSH
65423: LD_VAR 0 4
65427: ARRAY
65428: IN
65429: NOT
65430: AND
65431: IFFALSE 65479
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65433: LD_ADDR_EXP 125
65437: PUSH
65438: LD_EXP 125
65442: PPUSH
65443: LD_VAR 0 4
65447: PUSH
65448: LD_EXP 125
65452: PUSH
65453: LD_VAR 0 4
65457: ARRAY
65458: PUSH
65459: LD_INT 1
65461: PLUS
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PPUSH
65467: LD_VAR 0 1
65471: PPUSH
65472: CALL 70700 0 3
65476: ST_TO_ADDR
// break ;
65477: GO 65481
// end ; end ;
65479: GO 65393
65481: POP
65482: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65483: LD_VAR 0 1
65487: PPUSH
65488: CALL_OW 257
65492: PUSH
65493: LD_EXP 142
65497: IN
65498: PUSH
65499: LD_VAR 0 1
65503: PPUSH
65504: CALL_OW 266
65508: PUSH
65509: LD_INT 5
65511: EQUAL
65512: AND
65513: PUSH
65514: LD_VAR 0 2
65518: PPUSH
65519: CALL_OW 110
65523: PUSH
65524: LD_INT 18
65526: NONEQUAL
65527: AND
65528: IFFALSE 65568
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65530: LD_VAR 0 2
65534: PPUSH
65535: CALL_OW 257
65539: PUSH
65540: LD_INT 5
65542: PUSH
65543: LD_INT 8
65545: PUSH
65546: LD_INT 9
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: LIST
65553: IN
65554: IFFALSE 65568
// SetClass ( unit , 1 ) ;
65556: LD_VAR 0 2
65560: PPUSH
65561: LD_INT 1
65563: PPUSH
65564: CALL_OW 336
// end ;
65568: LD_VAR 0 3
65572: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65573: LD_INT 0
65575: PPUSH
65576: PPUSH
// if not mc_bases or not skirmish then
65577: LD_EXP 116
65581: NOT
65582: PUSH
65583: LD_EXP 114
65587: NOT
65588: OR
65589: IFFALSE 65593
// exit ;
65591: GO 65709
// if GetLives ( abandoned_vehicle ) > 250 then
65593: LD_VAR 0 2
65597: PPUSH
65598: CALL_OW 256
65602: PUSH
65603: LD_INT 250
65605: GREATER
65606: IFFALSE 65610
// exit ;
65608: GO 65709
// for i = 1 to mc_bases do
65610: LD_ADDR_VAR 0 6
65614: PUSH
65615: DOUBLE
65616: LD_INT 1
65618: DEC
65619: ST_TO_ADDR
65620: LD_EXP 116
65624: PUSH
65625: FOR_TO
65626: IFFALSE 65707
// begin if driver in mc_bases [ i ] then
65628: LD_VAR 0 1
65632: PUSH
65633: LD_EXP 116
65637: PUSH
65638: LD_VAR 0 6
65642: ARRAY
65643: IN
65644: IFFALSE 65705
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65646: LD_VAR 0 1
65650: PPUSH
65651: LD_EXP 116
65655: PUSH
65656: LD_VAR 0 6
65660: ARRAY
65661: PPUSH
65662: LD_INT 2
65664: PUSH
65665: LD_INT 30
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 30
65677: PUSH
65678: LD_INT 1
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: LIST
65689: PPUSH
65690: CALL_OW 72
65694: PUSH
65695: LD_INT 1
65697: ARRAY
65698: PPUSH
65699: CALL 103318 0 2
// break ;
65703: GO 65707
// end ; end ;
65705: GO 65625
65707: POP
65708: POP
// end ; end_of_file
65709: LD_VAR 0 5
65713: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65714: LD_INT 0
65716: PPUSH
65717: PPUSH
// if exist_mode then
65718: LD_VAR 0 2
65722: IFFALSE 65747
// unit := CreateCharacter ( prefix & ident ) else
65724: LD_ADDR_VAR 0 5
65728: PUSH
65729: LD_VAR 0 3
65733: PUSH
65734: LD_VAR 0 1
65738: STR
65739: PPUSH
65740: CALL_OW 34
65744: ST_TO_ADDR
65745: GO 65762
// unit := NewCharacter ( ident ) ;
65747: LD_ADDR_VAR 0 5
65751: PUSH
65752: LD_VAR 0 1
65756: PPUSH
65757: CALL_OW 25
65761: ST_TO_ADDR
// result := unit ;
65762: LD_ADDR_VAR 0 4
65766: PUSH
65767: LD_VAR 0 5
65771: ST_TO_ADDR
// end ;
65772: LD_VAR 0 4
65776: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65777: LD_INT 0
65779: PPUSH
65780: PPUSH
// if not side or not nation then
65781: LD_VAR 0 1
65785: NOT
65786: PUSH
65787: LD_VAR 0 2
65791: NOT
65792: OR
65793: IFFALSE 65797
// exit ;
65795: GO 66565
// case nation of nation_american :
65797: LD_VAR 0 2
65801: PUSH
65802: LD_INT 1
65804: DOUBLE
65805: EQUAL
65806: IFTRUE 65810
65808: GO 66024
65810: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65811: LD_ADDR_VAR 0 4
65815: PUSH
65816: LD_INT 35
65818: PUSH
65819: LD_INT 45
65821: PUSH
65822: LD_INT 46
65824: PUSH
65825: LD_INT 47
65827: PUSH
65828: LD_INT 82
65830: PUSH
65831: LD_INT 83
65833: PUSH
65834: LD_INT 84
65836: PUSH
65837: LD_INT 85
65839: PUSH
65840: LD_INT 86
65842: PUSH
65843: LD_INT 1
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: LD_INT 6
65851: PUSH
65852: LD_INT 15
65854: PUSH
65855: LD_INT 16
65857: PUSH
65858: LD_INT 7
65860: PUSH
65861: LD_INT 12
65863: PUSH
65864: LD_INT 13
65866: PUSH
65867: LD_INT 10
65869: PUSH
65870: LD_INT 14
65872: PUSH
65873: LD_INT 20
65875: PUSH
65876: LD_INT 21
65878: PUSH
65879: LD_INT 22
65881: PUSH
65882: LD_INT 25
65884: PUSH
65885: LD_INT 32
65887: PUSH
65888: LD_INT 27
65890: PUSH
65891: LD_INT 36
65893: PUSH
65894: LD_INT 69
65896: PUSH
65897: LD_INT 39
65899: PUSH
65900: LD_INT 34
65902: PUSH
65903: LD_INT 40
65905: PUSH
65906: LD_INT 48
65908: PUSH
65909: LD_INT 49
65911: PUSH
65912: LD_INT 50
65914: PUSH
65915: LD_INT 51
65917: PUSH
65918: LD_INT 52
65920: PUSH
65921: LD_INT 53
65923: PUSH
65924: LD_INT 54
65926: PUSH
65927: LD_INT 55
65929: PUSH
65930: LD_INT 56
65932: PUSH
65933: LD_INT 57
65935: PUSH
65936: LD_INT 58
65938: PUSH
65939: LD_INT 59
65941: PUSH
65942: LD_INT 60
65944: PUSH
65945: LD_INT 61
65947: PUSH
65948: LD_INT 62
65950: PUSH
65951: LD_INT 80
65953: PUSH
65954: LD_INT 82
65956: PUSH
65957: LD_INT 83
65959: PUSH
65960: LD_INT 84
65962: PUSH
65963: LD_INT 85
65965: PUSH
65966: LD_INT 86
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: LIST
66014: LIST
66015: LIST
66016: LIST
66017: LIST
66018: LIST
66019: LIST
66020: LIST
66021: ST_TO_ADDR
66022: GO 66489
66024: LD_INT 2
66026: DOUBLE
66027: EQUAL
66028: IFTRUE 66032
66030: GO 66258
66032: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66033: LD_ADDR_VAR 0 4
66037: PUSH
66038: LD_INT 35
66040: PUSH
66041: LD_INT 45
66043: PUSH
66044: LD_INT 46
66046: PUSH
66047: LD_INT 47
66049: PUSH
66050: LD_INT 82
66052: PUSH
66053: LD_INT 83
66055: PUSH
66056: LD_INT 84
66058: PUSH
66059: LD_INT 85
66061: PUSH
66062: LD_INT 87
66064: PUSH
66065: LD_INT 70
66067: PUSH
66068: LD_INT 1
66070: PUSH
66071: LD_INT 11
66073: PUSH
66074: LD_INT 3
66076: PUSH
66077: LD_INT 4
66079: PUSH
66080: LD_INT 5
66082: PUSH
66083: LD_INT 6
66085: PUSH
66086: LD_INT 15
66088: PUSH
66089: LD_INT 18
66091: PUSH
66092: LD_INT 7
66094: PUSH
66095: LD_INT 17
66097: PUSH
66098: LD_INT 8
66100: PUSH
66101: LD_INT 20
66103: PUSH
66104: LD_INT 21
66106: PUSH
66107: LD_INT 22
66109: PUSH
66110: LD_INT 72
66112: PUSH
66113: LD_INT 26
66115: PUSH
66116: LD_INT 69
66118: PUSH
66119: LD_INT 39
66121: PUSH
66122: LD_INT 40
66124: PUSH
66125: LD_INT 41
66127: PUSH
66128: LD_INT 42
66130: PUSH
66131: LD_INT 43
66133: PUSH
66134: LD_INT 48
66136: PUSH
66137: LD_INT 49
66139: PUSH
66140: LD_INT 50
66142: PUSH
66143: LD_INT 51
66145: PUSH
66146: LD_INT 52
66148: PUSH
66149: LD_INT 53
66151: PUSH
66152: LD_INT 54
66154: PUSH
66155: LD_INT 55
66157: PUSH
66158: LD_INT 56
66160: PUSH
66161: LD_INT 60
66163: PUSH
66164: LD_INT 61
66166: PUSH
66167: LD_INT 62
66169: PUSH
66170: LD_INT 66
66172: PUSH
66173: LD_INT 67
66175: PUSH
66176: LD_INT 68
66178: PUSH
66179: LD_INT 81
66181: PUSH
66182: LD_INT 82
66184: PUSH
66185: LD_INT 83
66187: PUSH
66188: LD_INT 84
66190: PUSH
66191: LD_INT 85
66193: PUSH
66194: LD_INT 87
66196: PUSH
66197: LD_INT 88
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: ST_TO_ADDR
66256: GO 66489
66258: LD_INT 3
66260: DOUBLE
66261: EQUAL
66262: IFTRUE 66266
66264: GO 66488
66266: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66267: LD_ADDR_VAR 0 4
66271: PUSH
66272: LD_INT 46
66274: PUSH
66275: LD_INT 47
66277: PUSH
66278: LD_INT 1
66280: PUSH
66281: LD_INT 2
66283: PUSH
66284: LD_INT 82
66286: PUSH
66287: LD_INT 83
66289: PUSH
66290: LD_INT 84
66292: PUSH
66293: LD_INT 85
66295: PUSH
66296: LD_INT 86
66298: PUSH
66299: LD_INT 11
66301: PUSH
66302: LD_INT 9
66304: PUSH
66305: LD_INT 20
66307: PUSH
66308: LD_INT 19
66310: PUSH
66311: LD_INT 21
66313: PUSH
66314: LD_INT 24
66316: PUSH
66317: LD_INT 22
66319: PUSH
66320: LD_INT 25
66322: PUSH
66323: LD_INT 28
66325: PUSH
66326: LD_INT 29
66328: PUSH
66329: LD_INT 30
66331: PUSH
66332: LD_INT 31
66334: PUSH
66335: LD_INT 37
66337: PUSH
66338: LD_INT 38
66340: PUSH
66341: LD_INT 32
66343: PUSH
66344: LD_INT 27
66346: PUSH
66347: LD_INT 33
66349: PUSH
66350: LD_INT 69
66352: PUSH
66353: LD_INT 39
66355: PUSH
66356: LD_INT 34
66358: PUSH
66359: LD_INT 40
66361: PUSH
66362: LD_INT 71
66364: PUSH
66365: LD_INT 23
66367: PUSH
66368: LD_INT 44
66370: PUSH
66371: LD_INT 48
66373: PUSH
66374: LD_INT 49
66376: PUSH
66377: LD_INT 50
66379: PUSH
66380: LD_INT 51
66382: PUSH
66383: LD_INT 52
66385: PUSH
66386: LD_INT 53
66388: PUSH
66389: LD_INT 54
66391: PUSH
66392: LD_INT 55
66394: PUSH
66395: LD_INT 56
66397: PUSH
66398: LD_INT 57
66400: PUSH
66401: LD_INT 58
66403: PUSH
66404: LD_INT 59
66406: PUSH
66407: LD_INT 63
66409: PUSH
66410: LD_INT 64
66412: PUSH
66413: LD_INT 65
66415: PUSH
66416: LD_INT 82
66418: PUSH
66419: LD_INT 83
66421: PUSH
66422: LD_INT 84
66424: PUSH
66425: LD_INT 85
66427: PUSH
66428: LD_INT 86
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: ST_TO_ADDR
66486: GO 66489
66488: POP
// if state > - 1 and state < 3 then
66489: LD_VAR 0 3
66493: PUSH
66494: LD_INT 1
66496: NEG
66497: GREATER
66498: PUSH
66499: LD_VAR 0 3
66503: PUSH
66504: LD_INT 3
66506: LESS
66507: AND
66508: IFFALSE 66565
// for i in result do
66510: LD_ADDR_VAR 0 5
66514: PUSH
66515: LD_VAR 0 4
66519: PUSH
66520: FOR_IN
66521: IFFALSE 66563
// if GetTech ( i , side ) <> state then
66523: LD_VAR 0 5
66527: PPUSH
66528: LD_VAR 0 1
66532: PPUSH
66533: CALL_OW 321
66537: PUSH
66538: LD_VAR 0 3
66542: NONEQUAL
66543: IFFALSE 66561
// result := result diff i ;
66545: LD_ADDR_VAR 0 4
66549: PUSH
66550: LD_VAR 0 4
66554: PUSH
66555: LD_VAR 0 5
66559: DIFF
66560: ST_TO_ADDR
66561: GO 66520
66563: POP
66564: POP
// end ;
66565: LD_VAR 0 4
66569: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66570: LD_INT 0
66572: PPUSH
66573: PPUSH
66574: PPUSH
// result := true ;
66575: LD_ADDR_VAR 0 3
66579: PUSH
66580: LD_INT 1
66582: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66583: LD_ADDR_VAR 0 5
66587: PUSH
66588: LD_VAR 0 2
66592: PPUSH
66593: CALL_OW 480
66597: ST_TO_ADDR
// if not tmp then
66598: LD_VAR 0 5
66602: NOT
66603: IFFALSE 66607
// exit ;
66605: GO 66656
// for i in tmp do
66607: LD_ADDR_VAR 0 4
66611: PUSH
66612: LD_VAR 0 5
66616: PUSH
66617: FOR_IN
66618: IFFALSE 66654
// if GetTech ( i , side ) <> state_researched then
66620: LD_VAR 0 4
66624: PPUSH
66625: LD_VAR 0 1
66629: PPUSH
66630: CALL_OW 321
66634: PUSH
66635: LD_INT 2
66637: NONEQUAL
66638: IFFALSE 66652
// begin result := false ;
66640: LD_ADDR_VAR 0 3
66644: PUSH
66645: LD_INT 0
66647: ST_TO_ADDR
// exit ;
66648: POP
66649: POP
66650: GO 66656
// end ;
66652: GO 66617
66654: POP
66655: POP
// end ;
66656: LD_VAR 0 3
66660: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66661: LD_INT 0
66663: PPUSH
66664: PPUSH
66665: PPUSH
66666: PPUSH
66667: PPUSH
66668: PPUSH
66669: PPUSH
66670: PPUSH
66671: PPUSH
66672: PPUSH
66673: PPUSH
66674: PPUSH
66675: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66676: LD_VAR 0 1
66680: NOT
66681: PUSH
66682: LD_VAR 0 1
66686: PPUSH
66687: CALL_OW 257
66691: PUSH
66692: LD_INT 9
66694: NONEQUAL
66695: OR
66696: IFFALSE 66700
// exit ;
66698: GO 67273
// side := GetSide ( unit ) ;
66700: LD_ADDR_VAR 0 9
66704: PUSH
66705: LD_VAR 0 1
66709: PPUSH
66710: CALL_OW 255
66714: ST_TO_ADDR
// tech_space := tech_spacanom ;
66715: LD_ADDR_VAR 0 12
66719: PUSH
66720: LD_INT 29
66722: ST_TO_ADDR
// tech_time := tech_taurad ;
66723: LD_ADDR_VAR 0 13
66727: PUSH
66728: LD_INT 28
66730: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66731: LD_ADDR_VAR 0 11
66735: PUSH
66736: LD_VAR 0 1
66740: PPUSH
66741: CALL_OW 310
66745: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66746: LD_VAR 0 11
66750: PPUSH
66751: CALL_OW 247
66755: PUSH
66756: LD_INT 2
66758: EQUAL
66759: IFFALSE 66763
// exit ;
66761: GO 67273
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66763: LD_ADDR_VAR 0 8
66767: PUSH
66768: LD_INT 81
66770: PUSH
66771: LD_VAR 0 9
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 3
66782: PUSH
66783: LD_INT 21
66785: PUSH
66786: LD_INT 3
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PPUSH
66801: CALL_OW 69
66805: ST_TO_ADDR
// if not tmp then
66806: LD_VAR 0 8
66810: NOT
66811: IFFALSE 66815
// exit ;
66813: GO 67273
// if in_unit then
66815: LD_VAR 0 11
66819: IFFALSE 66843
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66821: LD_ADDR_VAR 0 10
66825: PUSH
66826: LD_VAR 0 8
66830: PPUSH
66831: LD_VAR 0 11
66835: PPUSH
66836: CALL_OW 74
66840: ST_TO_ADDR
66841: GO 66863
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66843: LD_ADDR_VAR 0 10
66847: PUSH
66848: LD_VAR 0 8
66852: PPUSH
66853: LD_VAR 0 1
66857: PPUSH
66858: CALL_OW 74
66862: ST_TO_ADDR
// if not enemy then
66863: LD_VAR 0 10
66867: NOT
66868: IFFALSE 66872
// exit ;
66870: GO 67273
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66872: LD_VAR 0 11
66876: PUSH
66877: LD_VAR 0 11
66881: PPUSH
66882: LD_VAR 0 10
66886: PPUSH
66887: CALL_OW 296
66891: PUSH
66892: LD_INT 13
66894: GREATER
66895: AND
66896: PUSH
66897: LD_VAR 0 1
66901: PPUSH
66902: LD_VAR 0 10
66906: PPUSH
66907: CALL_OW 296
66911: PUSH
66912: LD_INT 12
66914: GREATER
66915: OR
66916: IFFALSE 66920
// exit ;
66918: GO 67273
// missile := [ 1 ] ;
66920: LD_ADDR_VAR 0 14
66924: PUSH
66925: LD_INT 1
66927: PUSH
66928: EMPTY
66929: LIST
66930: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66931: LD_VAR 0 9
66935: PPUSH
66936: LD_VAR 0 12
66940: PPUSH
66941: CALL_OW 325
66945: IFFALSE 66974
// missile := Insert ( missile , missile + 1 , 2 ) ;
66947: LD_ADDR_VAR 0 14
66951: PUSH
66952: LD_VAR 0 14
66956: PPUSH
66957: LD_VAR 0 14
66961: PUSH
66962: LD_INT 1
66964: PLUS
66965: PPUSH
66966: LD_INT 2
66968: PPUSH
66969: CALL_OW 2
66973: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66974: LD_VAR 0 9
66978: PPUSH
66979: LD_VAR 0 13
66983: PPUSH
66984: CALL_OW 325
66988: PUSH
66989: LD_VAR 0 10
66993: PPUSH
66994: CALL_OW 255
66998: PPUSH
66999: LD_VAR 0 13
67003: PPUSH
67004: CALL_OW 325
67008: NOT
67009: AND
67010: IFFALSE 67039
// missile := Insert ( missile , missile + 1 , 3 ) ;
67012: LD_ADDR_VAR 0 14
67016: PUSH
67017: LD_VAR 0 14
67021: PPUSH
67022: LD_VAR 0 14
67026: PUSH
67027: LD_INT 1
67029: PLUS
67030: PPUSH
67031: LD_INT 3
67033: PPUSH
67034: CALL_OW 2
67038: ST_TO_ADDR
// if missile < 2 then
67039: LD_VAR 0 14
67043: PUSH
67044: LD_INT 2
67046: LESS
67047: IFFALSE 67051
// exit ;
67049: GO 67273
// x := GetX ( enemy ) ;
67051: LD_ADDR_VAR 0 4
67055: PUSH
67056: LD_VAR 0 10
67060: PPUSH
67061: CALL_OW 250
67065: ST_TO_ADDR
// y := GetY ( enemy ) ;
67066: LD_ADDR_VAR 0 5
67070: PUSH
67071: LD_VAR 0 10
67075: PPUSH
67076: CALL_OW 251
67080: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67081: LD_ADDR_VAR 0 6
67085: PUSH
67086: LD_VAR 0 4
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PPUSH
67095: LD_INT 1
67097: PPUSH
67098: CALL_OW 12
67102: PLUS
67103: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67104: LD_ADDR_VAR 0 7
67108: PUSH
67109: LD_VAR 0 5
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PPUSH
67118: LD_INT 1
67120: PPUSH
67121: CALL_OW 12
67125: PLUS
67126: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67127: LD_VAR 0 6
67131: PPUSH
67132: LD_VAR 0 7
67136: PPUSH
67137: CALL_OW 488
67141: NOT
67142: IFFALSE 67164
// begin _x := x ;
67144: LD_ADDR_VAR 0 6
67148: PUSH
67149: LD_VAR 0 4
67153: ST_TO_ADDR
// _y := y ;
67154: LD_ADDR_VAR 0 7
67158: PUSH
67159: LD_VAR 0 5
67163: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67164: LD_ADDR_VAR 0 3
67168: PUSH
67169: LD_INT 1
67171: PPUSH
67172: LD_VAR 0 14
67176: PPUSH
67177: CALL_OW 12
67181: ST_TO_ADDR
// case i of 1 :
67182: LD_VAR 0 3
67186: PUSH
67187: LD_INT 1
67189: DOUBLE
67190: EQUAL
67191: IFTRUE 67195
67193: GO 67212
67195: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67196: LD_VAR 0 1
67200: PPUSH
67201: LD_VAR 0 10
67205: PPUSH
67206: CALL_OW 115
67210: GO 67273
67212: LD_INT 2
67214: DOUBLE
67215: EQUAL
67216: IFTRUE 67220
67218: GO 67242
67220: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67221: LD_VAR 0 1
67225: PPUSH
67226: LD_VAR 0 6
67230: PPUSH
67231: LD_VAR 0 7
67235: PPUSH
67236: CALL_OW 153
67240: GO 67273
67242: LD_INT 3
67244: DOUBLE
67245: EQUAL
67246: IFTRUE 67250
67248: GO 67272
67250: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67251: LD_VAR 0 1
67255: PPUSH
67256: LD_VAR 0 6
67260: PPUSH
67261: LD_VAR 0 7
67265: PPUSH
67266: CALL_OW 154
67270: GO 67273
67272: POP
// end ;
67273: LD_VAR 0 2
67277: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67278: LD_INT 0
67280: PPUSH
67281: PPUSH
67282: PPUSH
67283: PPUSH
67284: PPUSH
67285: PPUSH
// if not unit or not building then
67286: LD_VAR 0 1
67290: NOT
67291: PUSH
67292: LD_VAR 0 2
67296: NOT
67297: OR
67298: IFFALSE 67302
// exit ;
67300: GO 67460
// x := GetX ( building ) ;
67302: LD_ADDR_VAR 0 5
67306: PUSH
67307: LD_VAR 0 2
67311: PPUSH
67312: CALL_OW 250
67316: ST_TO_ADDR
// y := GetY ( building ) ;
67317: LD_ADDR_VAR 0 6
67321: PUSH
67322: LD_VAR 0 2
67326: PPUSH
67327: CALL_OW 251
67331: ST_TO_ADDR
// for i = 0 to 5 do
67332: LD_ADDR_VAR 0 4
67336: PUSH
67337: DOUBLE
67338: LD_INT 0
67340: DEC
67341: ST_TO_ADDR
67342: LD_INT 5
67344: PUSH
67345: FOR_TO
67346: IFFALSE 67458
// begin _x := ShiftX ( x , i , 3 ) ;
67348: LD_ADDR_VAR 0 7
67352: PUSH
67353: LD_VAR 0 5
67357: PPUSH
67358: LD_VAR 0 4
67362: PPUSH
67363: LD_INT 3
67365: PPUSH
67366: CALL_OW 272
67370: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67371: LD_ADDR_VAR 0 8
67375: PUSH
67376: LD_VAR 0 6
67380: PPUSH
67381: LD_VAR 0 4
67385: PPUSH
67386: LD_INT 3
67388: PPUSH
67389: CALL_OW 273
67393: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67394: LD_VAR 0 7
67398: PPUSH
67399: LD_VAR 0 8
67403: PPUSH
67404: CALL_OW 488
67408: NOT
67409: IFFALSE 67413
// continue ;
67411: GO 67345
// if HexInfo ( _x , _y ) = 0 then
67413: LD_VAR 0 7
67417: PPUSH
67418: LD_VAR 0 8
67422: PPUSH
67423: CALL_OW 428
67427: PUSH
67428: LD_INT 0
67430: EQUAL
67431: IFFALSE 67456
// begin ComMoveXY ( unit , _x , _y ) ;
67433: LD_VAR 0 1
67437: PPUSH
67438: LD_VAR 0 7
67442: PPUSH
67443: LD_VAR 0 8
67447: PPUSH
67448: CALL_OW 111
// exit ;
67452: POP
67453: POP
67454: GO 67460
// end ; end ;
67456: GO 67345
67458: POP
67459: POP
// end ;
67460: LD_VAR 0 3
67464: RET
// export function ScanBase ( side , base_area ) ; begin
67465: LD_INT 0
67467: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67468: LD_ADDR_VAR 0 3
67472: PUSH
67473: LD_VAR 0 2
67477: PPUSH
67478: LD_INT 81
67480: PUSH
67481: LD_VAR 0 1
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PPUSH
67490: CALL_OW 70
67494: ST_TO_ADDR
// end ;
67495: LD_VAR 0 3
67499: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67500: LD_INT 0
67502: PPUSH
67503: PPUSH
67504: PPUSH
67505: PPUSH
// result := false ;
67506: LD_ADDR_VAR 0 2
67510: PUSH
67511: LD_INT 0
67513: ST_TO_ADDR
// side := GetSide ( unit ) ;
67514: LD_ADDR_VAR 0 3
67518: PUSH
67519: LD_VAR 0 1
67523: PPUSH
67524: CALL_OW 255
67528: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67529: LD_ADDR_VAR 0 4
67533: PUSH
67534: LD_VAR 0 1
67538: PPUSH
67539: CALL_OW 248
67543: ST_TO_ADDR
// case nat of 1 :
67544: LD_VAR 0 4
67548: PUSH
67549: LD_INT 1
67551: DOUBLE
67552: EQUAL
67553: IFTRUE 67557
67555: GO 67568
67557: POP
// tech := tech_lassight ; 2 :
67558: LD_ADDR_VAR 0 5
67562: PUSH
67563: LD_INT 12
67565: ST_TO_ADDR
67566: GO 67607
67568: LD_INT 2
67570: DOUBLE
67571: EQUAL
67572: IFTRUE 67576
67574: GO 67587
67576: POP
// tech := tech_mortar ; 3 :
67577: LD_ADDR_VAR 0 5
67581: PUSH
67582: LD_INT 41
67584: ST_TO_ADDR
67585: GO 67607
67587: LD_INT 3
67589: DOUBLE
67590: EQUAL
67591: IFTRUE 67595
67593: GO 67606
67595: POP
// tech := tech_bazooka ; end ;
67596: LD_ADDR_VAR 0 5
67600: PUSH
67601: LD_INT 44
67603: ST_TO_ADDR
67604: GO 67607
67606: POP
// if Researched ( side , tech ) then
67607: LD_VAR 0 3
67611: PPUSH
67612: LD_VAR 0 5
67616: PPUSH
67617: CALL_OW 325
67621: IFFALSE 67648
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67623: LD_ADDR_VAR 0 2
67627: PUSH
67628: LD_INT 5
67630: PUSH
67631: LD_INT 8
67633: PUSH
67634: LD_INT 9
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: LIST
67641: PUSH
67642: LD_VAR 0 4
67646: ARRAY
67647: ST_TO_ADDR
// end ;
67648: LD_VAR 0 2
67652: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67653: LD_INT 0
67655: PPUSH
67656: PPUSH
67657: PPUSH
// if not mines then
67658: LD_VAR 0 2
67662: NOT
67663: IFFALSE 67667
// exit ;
67665: GO 67811
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67667: LD_ADDR_VAR 0 5
67671: PUSH
67672: LD_INT 81
67674: PUSH
67675: LD_VAR 0 1
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 3
67686: PUSH
67687: LD_INT 21
67689: PUSH
67690: LD_INT 3
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PPUSH
67705: CALL_OW 69
67709: ST_TO_ADDR
// for i in mines do
67710: LD_ADDR_VAR 0 4
67714: PUSH
67715: LD_VAR 0 2
67719: PUSH
67720: FOR_IN
67721: IFFALSE 67809
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67723: LD_VAR 0 4
67727: PUSH
67728: LD_INT 1
67730: ARRAY
67731: PPUSH
67732: LD_VAR 0 4
67736: PUSH
67737: LD_INT 2
67739: ARRAY
67740: PPUSH
67741: CALL_OW 458
67745: NOT
67746: IFFALSE 67750
// continue ;
67748: GO 67720
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67750: LD_VAR 0 4
67754: PUSH
67755: LD_INT 1
67757: ARRAY
67758: PPUSH
67759: LD_VAR 0 4
67763: PUSH
67764: LD_INT 2
67766: ARRAY
67767: PPUSH
67768: CALL_OW 428
67772: PUSH
67773: LD_VAR 0 5
67777: IN
67778: IFFALSE 67807
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67780: LD_VAR 0 4
67784: PUSH
67785: LD_INT 1
67787: ARRAY
67788: PPUSH
67789: LD_VAR 0 4
67793: PUSH
67794: LD_INT 2
67796: ARRAY
67797: PPUSH
67798: LD_VAR 0 1
67802: PPUSH
67803: CALL_OW 456
// end ;
67807: GO 67720
67809: POP
67810: POP
// end ;
67811: LD_VAR 0 3
67815: RET
// export function Count ( array ) ; var i ; begin
67816: LD_INT 0
67818: PPUSH
67819: PPUSH
// result := 0 ;
67820: LD_ADDR_VAR 0 2
67824: PUSH
67825: LD_INT 0
67827: ST_TO_ADDR
// for i in array do
67828: LD_ADDR_VAR 0 3
67832: PUSH
67833: LD_VAR 0 1
67837: PUSH
67838: FOR_IN
67839: IFFALSE 67863
// if i then
67841: LD_VAR 0 3
67845: IFFALSE 67861
// result := result + 1 ;
67847: LD_ADDR_VAR 0 2
67851: PUSH
67852: LD_VAR 0 2
67856: PUSH
67857: LD_INT 1
67859: PLUS
67860: ST_TO_ADDR
67861: GO 67838
67863: POP
67864: POP
// end ;
67865: LD_VAR 0 2
67869: RET
// export function IsEmpty ( building ) ; begin
67870: LD_INT 0
67872: PPUSH
// if not building then
67873: LD_VAR 0 1
67877: NOT
67878: IFFALSE 67882
// exit ;
67880: GO 67925
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67882: LD_ADDR_VAR 0 2
67886: PUSH
67887: LD_VAR 0 1
67891: PUSH
67892: LD_INT 22
67894: PUSH
67895: LD_VAR 0 1
67899: PPUSH
67900: CALL_OW 255
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: LD_INT 58
67911: PUSH
67912: EMPTY
67913: LIST
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PPUSH
67919: CALL_OW 69
67923: IN
67924: ST_TO_ADDR
// end ;
67925: LD_VAR 0 2
67929: RET
// export function IsNotFull ( building ) ; begin
67930: LD_INT 0
67932: PPUSH
// if not building then
67933: LD_VAR 0 1
67937: NOT
67938: IFFALSE 67942
// exit ;
67940: GO 67961
// result := UnitsInside ( building ) < 6 ;
67942: LD_ADDR_VAR 0 2
67946: PUSH
67947: LD_VAR 0 1
67951: PPUSH
67952: CALL_OW 313
67956: PUSH
67957: LD_INT 6
67959: LESS
67960: ST_TO_ADDR
// end ;
67961: LD_VAR 0 2
67965: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67966: LD_INT 0
67968: PPUSH
67969: PPUSH
67970: PPUSH
67971: PPUSH
// tmp := [ ] ;
67972: LD_ADDR_VAR 0 3
67976: PUSH
67977: EMPTY
67978: ST_TO_ADDR
// list := [ ] ;
67979: LD_ADDR_VAR 0 5
67983: PUSH
67984: EMPTY
67985: ST_TO_ADDR
// for i = 16 to 25 do
67986: LD_ADDR_VAR 0 4
67990: PUSH
67991: DOUBLE
67992: LD_INT 16
67994: DEC
67995: ST_TO_ADDR
67996: LD_INT 25
67998: PUSH
67999: FOR_TO
68000: IFFALSE 68073
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68002: LD_ADDR_VAR 0 3
68006: PUSH
68007: LD_VAR 0 3
68011: PUSH
68012: LD_INT 22
68014: PUSH
68015: LD_VAR 0 1
68019: PPUSH
68020: CALL_OW 255
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 91
68031: PUSH
68032: LD_VAR 0 1
68036: PUSH
68037: LD_INT 6
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 30
68047: PUSH
68048: LD_VAR 0 4
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: LIST
68061: PUSH
68062: EMPTY
68063: LIST
68064: PPUSH
68065: CALL_OW 69
68069: ADD
68070: ST_TO_ADDR
68071: GO 67999
68073: POP
68074: POP
// for i = 1 to tmp do
68075: LD_ADDR_VAR 0 4
68079: PUSH
68080: DOUBLE
68081: LD_INT 1
68083: DEC
68084: ST_TO_ADDR
68085: LD_VAR 0 3
68089: PUSH
68090: FOR_TO
68091: IFFALSE 68179
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68093: LD_ADDR_VAR 0 5
68097: PUSH
68098: LD_VAR 0 5
68102: PUSH
68103: LD_VAR 0 3
68107: PUSH
68108: LD_VAR 0 4
68112: ARRAY
68113: PPUSH
68114: CALL_OW 266
68118: PUSH
68119: LD_VAR 0 3
68123: PUSH
68124: LD_VAR 0 4
68128: ARRAY
68129: PPUSH
68130: CALL_OW 250
68134: PUSH
68135: LD_VAR 0 3
68139: PUSH
68140: LD_VAR 0 4
68144: ARRAY
68145: PPUSH
68146: CALL_OW 251
68150: PUSH
68151: LD_VAR 0 3
68155: PUSH
68156: LD_VAR 0 4
68160: ARRAY
68161: PPUSH
68162: CALL_OW 254
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: PUSH
68173: EMPTY
68174: LIST
68175: ADD
68176: ST_TO_ADDR
68177: GO 68090
68179: POP
68180: POP
// result := list ;
68181: LD_ADDR_VAR 0 2
68185: PUSH
68186: LD_VAR 0 5
68190: ST_TO_ADDR
// end ;
68191: LD_VAR 0 2
68195: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68196: LD_INT 0
68198: PPUSH
68199: PPUSH
68200: PPUSH
68201: PPUSH
68202: PPUSH
68203: PPUSH
68204: PPUSH
// if not factory then
68205: LD_VAR 0 1
68209: NOT
68210: IFFALSE 68214
// exit ;
68212: GO 68807
// if control = control_apeman then
68214: LD_VAR 0 4
68218: PUSH
68219: LD_INT 5
68221: EQUAL
68222: IFFALSE 68331
// begin tmp := UnitsInside ( factory ) ;
68224: LD_ADDR_VAR 0 8
68228: PUSH
68229: LD_VAR 0 1
68233: PPUSH
68234: CALL_OW 313
68238: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68239: LD_VAR 0 8
68243: PPUSH
68244: LD_INT 25
68246: PUSH
68247: LD_INT 12
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PPUSH
68254: CALL_OW 72
68258: NOT
68259: IFFALSE 68269
// control := control_manual ;
68261: LD_ADDR_VAR 0 4
68265: PUSH
68266: LD_INT 1
68268: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68269: LD_ADDR_VAR 0 8
68273: PUSH
68274: LD_VAR 0 1
68278: PPUSH
68279: CALL 67966 0 1
68283: ST_TO_ADDR
// if tmp then
68284: LD_VAR 0 8
68288: IFFALSE 68331
// begin for i in tmp do
68290: LD_ADDR_VAR 0 7
68294: PUSH
68295: LD_VAR 0 8
68299: PUSH
68300: FOR_IN
68301: IFFALSE 68329
// if i [ 1 ] = b_ext_radio then
68303: LD_VAR 0 7
68307: PUSH
68308: LD_INT 1
68310: ARRAY
68311: PUSH
68312: LD_INT 22
68314: EQUAL
68315: IFFALSE 68327
// begin control := control_remote ;
68317: LD_ADDR_VAR 0 4
68321: PUSH
68322: LD_INT 2
68324: ST_TO_ADDR
// break ;
68325: GO 68329
// end ;
68327: GO 68300
68329: POP
68330: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68331: LD_VAR 0 1
68335: PPUSH
68336: LD_VAR 0 2
68340: PPUSH
68341: LD_VAR 0 3
68345: PPUSH
68346: LD_VAR 0 4
68350: PPUSH
68351: LD_VAR 0 5
68355: PPUSH
68356: CALL_OW 448
68360: IFFALSE 68395
// begin result := [ chassis , engine , control , weapon ] ;
68362: LD_ADDR_VAR 0 6
68366: PUSH
68367: LD_VAR 0 2
68371: PUSH
68372: LD_VAR 0 3
68376: PUSH
68377: LD_VAR 0 4
68381: PUSH
68382: LD_VAR 0 5
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: ST_TO_ADDR
// exit ;
68393: GO 68807
// end ; _chassis := AvailableChassisList ( factory ) ;
68395: LD_ADDR_VAR 0 9
68399: PUSH
68400: LD_VAR 0 1
68404: PPUSH
68405: CALL_OW 475
68409: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68410: LD_ADDR_VAR 0 11
68414: PUSH
68415: LD_VAR 0 1
68419: PPUSH
68420: CALL_OW 476
68424: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68425: LD_ADDR_VAR 0 12
68429: PUSH
68430: LD_VAR 0 1
68434: PPUSH
68435: CALL_OW 477
68439: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68440: LD_ADDR_VAR 0 10
68444: PUSH
68445: LD_VAR 0 1
68449: PPUSH
68450: CALL_OW 478
68454: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68455: LD_VAR 0 9
68459: NOT
68460: PUSH
68461: LD_VAR 0 11
68465: NOT
68466: OR
68467: PUSH
68468: LD_VAR 0 12
68472: NOT
68473: OR
68474: PUSH
68475: LD_VAR 0 10
68479: NOT
68480: OR
68481: IFFALSE 68516
// begin result := [ chassis , engine , control , weapon ] ;
68483: LD_ADDR_VAR 0 6
68487: PUSH
68488: LD_VAR 0 2
68492: PUSH
68493: LD_VAR 0 3
68497: PUSH
68498: LD_VAR 0 4
68502: PUSH
68503: LD_VAR 0 5
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: ST_TO_ADDR
// exit ;
68514: GO 68807
// end ; if not chassis in _chassis then
68516: LD_VAR 0 2
68520: PUSH
68521: LD_VAR 0 9
68525: IN
68526: NOT
68527: IFFALSE 68553
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68529: LD_ADDR_VAR 0 2
68533: PUSH
68534: LD_VAR 0 9
68538: PUSH
68539: LD_INT 1
68541: PPUSH
68542: LD_VAR 0 9
68546: PPUSH
68547: CALL_OW 12
68551: ARRAY
68552: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68553: LD_VAR 0 2
68557: PPUSH
68558: LD_VAR 0 3
68562: PPUSH
68563: CALL 68812 0 2
68567: NOT
68568: IFFALSE 68627
// repeat engine := _engine [ 1 ] ;
68570: LD_ADDR_VAR 0 3
68574: PUSH
68575: LD_VAR 0 11
68579: PUSH
68580: LD_INT 1
68582: ARRAY
68583: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68584: LD_ADDR_VAR 0 11
68588: PUSH
68589: LD_VAR 0 11
68593: PPUSH
68594: LD_INT 1
68596: PPUSH
68597: CALL_OW 3
68601: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68602: LD_VAR 0 2
68606: PPUSH
68607: LD_VAR 0 3
68611: PPUSH
68612: CALL 68812 0 2
68616: PUSH
68617: LD_VAR 0 11
68621: PUSH
68622: EMPTY
68623: EQUAL
68624: OR
68625: IFFALSE 68570
// if not control in _control then
68627: LD_VAR 0 4
68631: PUSH
68632: LD_VAR 0 12
68636: IN
68637: NOT
68638: IFFALSE 68664
// control := _control [ rand ( 1 , _control ) ] ;
68640: LD_ADDR_VAR 0 4
68644: PUSH
68645: LD_VAR 0 12
68649: PUSH
68650: LD_INT 1
68652: PPUSH
68653: LD_VAR 0 12
68657: PPUSH
68658: CALL_OW 12
68662: ARRAY
68663: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68664: LD_VAR 0 2
68668: PPUSH
68669: LD_VAR 0 5
68673: PPUSH
68674: CALL 69032 0 2
68678: NOT
68679: IFFALSE 68738
// repeat weapon := _weapon [ 1 ] ;
68681: LD_ADDR_VAR 0 5
68685: PUSH
68686: LD_VAR 0 10
68690: PUSH
68691: LD_INT 1
68693: ARRAY
68694: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68695: LD_ADDR_VAR 0 10
68699: PUSH
68700: LD_VAR 0 10
68704: PPUSH
68705: LD_INT 1
68707: PPUSH
68708: CALL_OW 3
68712: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68713: LD_VAR 0 2
68717: PPUSH
68718: LD_VAR 0 5
68722: PPUSH
68723: CALL 69032 0 2
68727: PUSH
68728: LD_VAR 0 10
68732: PUSH
68733: EMPTY
68734: EQUAL
68735: OR
68736: IFFALSE 68681
// result := [ ] ;
68738: LD_ADDR_VAR 0 6
68742: PUSH
68743: EMPTY
68744: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68745: LD_VAR 0 1
68749: PPUSH
68750: LD_VAR 0 2
68754: PPUSH
68755: LD_VAR 0 3
68759: PPUSH
68760: LD_VAR 0 4
68764: PPUSH
68765: LD_VAR 0 5
68769: PPUSH
68770: CALL_OW 448
68774: IFFALSE 68807
// result := [ chassis , engine , control , weapon ] ;
68776: LD_ADDR_VAR 0 6
68780: PUSH
68781: LD_VAR 0 2
68785: PUSH
68786: LD_VAR 0 3
68790: PUSH
68791: LD_VAR 0 4
68795: PUSH
68796: LD_VAR 0 5
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: ST_TO_ADDR
// end ;
68807: LD_VAR 0 6
68811: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68812: LD_INT 0
68814: PPUSH
// if not chassis or not engine then
68815: LD_VAR 0 1
68819: NOT
68820: PUSH
68821: LD_VAR 0 2
68825: NOT
68826: OR
68827: IFFALSE 68831
// exit ;
68829: GO 69027
// case engine of engine_solar :
68831: LD_VAR 0 2
68835: PUSH
68836: LD_INT 2
68838: DOUBLE
68839: EQUAL
68840: IFTRUE 68844
68842: GO 68882
68844: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68845: LD_ADDR_VAR 0 3
68849: PUSH
68850: LD_INT 11
68852: PUSH
68853: LD_INT 12
68855: PUSH
68856: LD_INT 13
68858: PUSH
68859: LD_INT 14
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: LD_INT 2
68867: PUSH
68868: LD_INT 3
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: ST_TO_ADDR
68880: GO 69011
68882: LD_INT 1
68884: DOUBLE
68885: EQUAL
68886: IFTRUE 68890
68888: GO 68952
68890: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68891: LD_ADDR_VAR 0 3
68895: PUSH
68896: LD_INT 11
68898: PUSH
68899: LD_INT 12
68901: PUSH
68902: LD_INT 13
68904: PUSH
68905: LD_INT 14
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: LD_INT 3
68916: PUSH
68917: LD_INT 4
68919: PUSH
68920: LD_INT 5
68922: PUSH
68923: LD_INT 21
68925: PUSH
68926: LD_INT 23
68928: PUSH
68929: LD_INT 22
68931: PUSH
68932: LD_INT 24
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: ST_TO_ADDR
68950: GO 69011
68952: LD_INT 3
68954: DOUBLE
68955: EQUAL
68956: IFTRUE 68960
68958: GO 69010
68960: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68961: LD_ADDR_VAR 0 3
68965: PUSH
68966: LD_INT 13
68968: PUSH
68969: LD_INT 14
68971: PUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 3
68977: PUSH
68978: LD_INT 4
68980: PUSH
68981: LD_INT 5
68983: PUSH
68984: LD_INT 21
68986: PUSH
68987: LD_INT 22
68989: PUSH
68990: LD_INT 23
68992: PUSH
68993: LD_INT 24
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: ST_TO_ADDR
69008: GO 69011
69010: POP
// result := ( chassis in result ) ;
69011: LD_ADDR_VAR 0 3
69015: PUSH
69016: LD_VAR 0 1
69020: PUSH
69021: LD_VAR 0 3
69025: IN
69026: ST_TO_ADDR
// end ;
69027: LD_VAR 0 3
69031: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69032: LD_INT 0
69034: PPUSH
// if not chassis or not weapon then
69035: LD_VAR 0 1
69039: NOT
69040: PUSH
69041: LD_VAR 0 2
69045: NOT
69046: OR
69047: IFFALSE 69051
// exit ;
69049: GO 70113
// case weapon of us_machine_gun :
69051: LD_VAR 0 2
69055: PUSH
69056: LD_INT 2
69058: DOUBLE
69059: EQUAL
69060: IFTRUE 69064
69062: GO 69094
69064: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69065: LD_ADDR_VAR 0 3
69069: PUSH
69070: LD_INT 1
69072: PUSH
69073: LD_INT 2
69075: PUSH
69076: LD_INT 3
69078: PUSH
69079: LD_INT 4
69081: PUSH
69082: LD_INT 5
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: ST_TO_ADDR
69092: GO 70097
69094: LD_INT 3
69096: DOUBLE
69097: EQUAL
69098: IFTRUE 69102
69100: GO 69132
69102: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69103: LD_ADDR_VAR 0 3
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: LD_INT 2
69113: PUSH
69114: LD_INT 3
69116: PUSH
69117: LD_INT 4
69119: PUSH
69120: LD_INT 5
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: ST_TO_ADDR
69130: GO 70097
69132: LD_INT 11
69134: DOUBLE
69135: EQUAL
69136: IFTRUE 69140
69138: GO 69170
69140: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69141: LD_ADDR_VAR 0 3
69145: PUSH
69146: LD_INT 1
69148: PUSH
69149: LD_INT 2
69151: PUSH
69152: LD_INT 3
69154: PUSH
69155: LD_INT 4
69157: PUSH
69158: LD_INT 5
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: ST_TO_ADDR
69168: GO 70097
69170: LD_INT 4
69172: DOUBLE
69173: EQUAL
69174: IFTRUE 69178
69176: GO 69204
69178: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69179: LD_ADDR_VAR 0 3
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: LD_INT 3
69189: PUSH
69190: LD_INT 4
69192: PUSH
69193: LD_INT 5
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: ST_TO_ADDR
69202: GO 70097
69204: LD_INT 5
69206: DOUBLE
69207: EQUAL
69208: IFTRUE 69212
69210: GO 69238
69212: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69213: LD_ADDR_VAR 0 3
69217: PUSH
69218: LD_INT 2
69220: PUSH
69221: LD_INT 3
69223: PUSH
69224: LD_INT 4
69226: PUSH
69227: LD_INT 5
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: ST_TO_ADDR
69236: GO 70097
69238: LD_INT 9
69240: DOUBLE
69241: EQUAL
69242: IFTRUE 69246
69244: GO 69272
69246: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69247: LD_ADDR_VAR 0 3
69251: PUSH
69252: LD_INT 2
69254: PUSH
69255: LD_INT 3
69257: PUSH
69258: LD_INT 4
69260: PUSH
69261: LD_INT 5
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: ST_TO_ADDR
69270: GO 70097
69272: LD_INT 7
69274: DOUBLE
69275: EQUAL
69276: IFTRUE 69280
69278: GO 69306
69280: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69281: LD_ADDR_VAR 0 3
69285: PUSH
69286: LD_INT 2
69288: PUSH
69289: LD_INT 3
69291: PUSH
69292: LD_INT 4
69294: PUSH
69295: LD_INT 5
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: ST_TO_ADDR
69304: GO 70097
69306: LD_INT 12
69308: DOUBLE
69309: EQUAL
69310: IFTRUE 69314
69312: GO 69340
69314: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69315: LD_ADDR_VAR 0 3
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: LD_INT 3
69325: PUSH
69326: LD_INT 4
69328: PUSH
69329: LD_INT 5
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: ST_TO_ADDR
69338: GO 70097
69340: LD_INT 13
69342: DOUBLE
69343: EQUAL
69344: IFTRUE 69348
69346: GO 69374
69348: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69349: LD_ADDR_VAR 0 3
69353: PUSH
69354: LD_INT 2
69356: PUSH
69357: LD_INT 3
69359: PUSH
69360: LD_INT 4
69362: PUSH
69363: LD_INT 5
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: ST_TO_ADDR
69372: GO 70097
69374: LD_INT 14
69376: DOUBLE
69377: EQUAL
69378: IFTRUE 69382
69380: GO 69400
69382: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69383: LD_ADDR_VAR 0 3
69387: PUSH
69388: LD_INT 4
69390: PUSH
69391: LD_INT 5
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: ST_TO_ADDR
69398: GO 70097
69400: LD_INT 6
69402: DOUBLE
69403: EQUAL
69404: IFTRUE 69408
69406: GO 69426
69408: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69409: LD_ADDR_VAR 0 3
69413: PUSH
69414: LD_INT 4
69416: PUSH
69417: LD_INT 5
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: ST_TO_ADDR
69424: GO 70097
69426: LD_INT 10
69428: DOUBLE
69429: EQUAL
69430: IFTRUE 69434
69432: GO 69452
69434: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69435: LD_ADDR_VAR 0 3
69439: PUSH
69440: LD_INT 4
69442: PUSH
69443: LD_INT 5
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: ST_TO_ADDR
69450: GO 70097
69452: LD_INT 22
69454: DOUBLE
69455: EQUAL
69456: IFTRUE 69460
69458: GO 69486
69460: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69461: LD_ADDR_VAR 0 3
69465: PUSH
69466: LD_INT 11
69468: PUSH
69469: LD_INT 12
69471: PUSH
69472: LD_INT 13
69474: PUSH
69475: LD_INT 14
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: ST_TO_ADDR
69484: GO 70097
69486: LD_INT 23
69488: DOUBLE
69489: EQUAL
69490: IFTRUE 69494
69492: GO 69520
69494: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69495: LD_ADDR_VAR 0 3
69499: PUSH
69500: LD_INT 11
69502: PUSH
69503: LD_INT 12
69505: PUSH
69506: LD_INT 13
69508: PUSH
69509: LD_INT 14
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: ST_TO_ADDR
69518: GO 70097
69520: LD_INT 24
69522: DOUBLE
69523: EQUAL
69524: IFTRUE 69528
69526: GO 69554
69528: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69529: LD_ADDR_VAR 0 3
69533: PUSH
69534: LD_INT 11
69536: PUSH
69537: LD_INT 12
69539: PUSH
69540: LD_INT 13
69542: PUSH
69543: LD_INT 14
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: ST_TO_ADDR
69552: GO 70097
69554: LD_INT 30
69556: DOUBLE
69557: EQUAL
69558: IFTRUE 69562
69560: GO 69588
69562: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69563: LD_ADDR_VAR 0 3
69567: PUSH
69568: LD_INT 11
69570: PUSH
69571: LD_INT 12
69573: PUSH
69574: LD_INT 13
69576: PUSH
69577: LD_INT 14
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: ST_TO_ADDR
69586: GO 70097
69588: LD_INT 25
69590: DOUBLE
69591: EQUAL
69592: IFTRUE 69596
69594: GO 69614
69596: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69597: LD_ADDR_VAR 0 3
69601: PUSH
69602: LD_INT 13
69604: PUSH
69605: LD_INT 14
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: ST_TO_ADDR
69612: GO 70097
69614: LD_INT 27
69616: DOUBLE
69617: EQUAL
69618: IFTRUE 69622
69620: GO 69640
69622: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69623: LD_ADDR_VAR 0 3
69627: PUSH
69628: LD_INT 13
69630: PUSH
69631: LD_INT 14
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: ST_TO_ADDR
69638: GO 70097
69640: LD_EXP 100
69644: DOUBLE
69645: EQUAL
69646: IFTRUE 69650
69648: GO 69676
69650: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69651: LD_ADDR_VAR 0 3
69655: PUSH
69656: LD_INT 11
69658: PUSH
69659: LD_INT 12
69661: PUSH
69662: LD_INT 13
69664: PUSH
69665: LD_INT 14
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: ST_TO_ADDR
69674: GO 70097
69676: LD_INT 28
69678: DOUBLE
69679: EQUAL
69680: IFTRUE 69684
69682: GO 69702
69684: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69685: LD_ADDR_VAR 0 3
69689: PUSH
69690: LD_INT 13
69692: PUSH
69693: LD_INT 14
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: ST_TO_ADDR
69700: GO 70097
69702: LD_INT 29
69704: DOUBLE
69705: EQUAL
69706: IFTRUE 69710
69708: GO 69728
69710: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69711: LD_ADDR_VAR 0 3
69715: PUSH
69716: LD_INT 13
69718: PUSH
69719: LD_INT 14
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: ST_TO_ADDR
69726: GO 70097
69728: LD_INT 31
69730: DOUBLE
69731: EQUAL
69732: IFTRUE 69736
69734: GO 69754
69736: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69737: LD_ADDR_VAR 0 3
69741: PUSH
69742: LD_INT 13
69744: PUSH
69745: LD_INT 14
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: ST_TO_ADDR
69752: GO 70097
69754: LD_INT 26
69756: DOUBLE
69757: EQUAL
69758: IFTRUE 69762
69760: GO 69780
69762: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69763: LD_ADDR_VAR 0 3
69767: PUSH
69768: LD_INT 13
69770: PUSH
69771: LD_INT 14
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: ST_TO_ADDR
69778: GO 70097
69780: LD_INT 42
69782: DOUBLE
69783: EQUAL
69784: IFTRUE 69788
69786: GO 69814
69788: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69789: LD_ADDR_VAR 0 3
69793: PUSH
69794: LD_INT 21
69796: PUSH
69797: LD_INT 22
69799: PUSH
69800: LD_INT 23
69802: PUSH
69803: LD_INT 24
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: ST_TO_ADDR
69812: GO 70097
69814: LD_INT 43
69816: DOUBLE
69817: EQUAL
69818: IFTRUE 69822
69820: GO 69848
69822: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69823: LD_ADDR_VAR 0 3
69827: PUSH
69828: LD_INT 21
69830: PUSH
69831: LD_INT 22
69833: PUSH
69834: LD_INT 23
69836: PUSH
69837: LD_INT 24
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: ST_TO_ADDR
69846: GO 70097
69848: LD_INT 44
69850: DOUBLE
69851: EQUAL
69852: IFTRUE 69856
69854: GO 69882
69856: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69857: LD_ADDR_VAR 0 3
69861: PUSH
69862: LD_INT 21
69864: PUSH
69865: LD_INT 22
69867: PUSH
69868: LD_INT 23
69870: PUSH
69871: LD_INT 24
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: ST_TO_ADDR
69880: GO 70097
69882: LD_INT 45
69884: DOUBLE
69885: EQUAL
69886: IFTRUE 69890
69888: GO 69916
69890: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69891: LD_ADDR_VAR 0 3
69895: PUSH
69896: LD_INT 21
69898: PUSH
69899: LD_INT 22
69901: PUSH
69902: LD_INT 23
69904: PUSH
69905: LD_INT 24
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: ST_TO_ADDR
69914: GO 70097
69916: LD_INT 49
69918: DOUBLE
69919: EQUAL
69920: IFTRUE 69924
69922: GO 69950
69924: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69925: LD_ADDR_VAR 0 3
69929: PUSH
69930: LD_INT 21
69932: PUSH
69933: LD_INT 22
69935: PUSH
69936: LD_INT 23
69938: PUSH
69939: LD_INT 24
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: ST_TO_ADDR
69948: GO 70097
69950: LD_INT 51
69952: DOUBLE
69953: EQUAL
69954: IFTRUE 69958
69956: GO 69984
69958: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69959: LD_ADDR_VAR 0 3
69963: PUSH
69964: LD_INT 21
69966: PUSH
69967: LD_INT 22
69969: PUSH
69970: LD_INT 23
69972: PUSH
69973: LD_INT 24
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: ST_TO_ADDR
69982: GO 70097
69984: LD_INT 52
69986: DOUBLE
69987: EQUAL
69988: IFTRUE 69992
69990: GO 70018
69992: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69993: LD_ADDR_VAR 0 3
69997: PUSH
69998: LD_INT 21
70000: PUSH
70001: LD_INT 22
70003: PUSH
70004: LD_INT 23
70006: PUSH
70007: LD_INT 24
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: ST_TO_ADDR
70016: GO 70097
70018: LD_INT 53
70020: DOUBLE
70021: EQUAL
70022: IFTRUE 70026
70024: GO 70044
70026: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70027: LD_ADDR_VAR 0 3
70031: PUSH
70032: LD_INT 23
70034: PUSH
70035: LD_INT 24
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: ST_TO_ADDR
70042: GO 70097
70044: LD_INT 46
70046: DOUBLE
70047: EQUAL
70048: IFTRUE 70052
70050: GO 70070
70052: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70053: LD_ADDR_VAR 0 3
70057: PUSH
70058: LD_INT 23
70060: PUSH
70061: LD_INT 24
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: ST_TO_ADDR
70068: GO 70097
70070: LD_INT 47
70072: DOUBLE
70073: EQUAL
70074: IFTRUE 70078
70076: GO 70096
70078: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70079: LD_ADDR_VAR 0 3
70083: PUSH
70084: LD_INT 23
70086: PUSH
70087: LD_INT 24
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: ST_TO_ADDR
70094: GO 70097
70096: POP
// result := ( chassis in result ) ;
70097: LD_ADDR_VAR 0 3
70101: PUSH
70102: LD_VAR 0 1
70106: PUSH
70107: LD_VAR 0 3
70111: IN
70112: ST_TO_ADDR
// end ;
70113: LD_VAR 0 3
70117: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70118: LD_INT 0
70120: PPUSH
70121: PPUSH
70122: PPUSH
70123: PPUSH
70124: PPUSH
70125: PPUSH
70126: PPUSH
// result := array ;
70127: LD_ADDR_VAR 0 5
70131: PUSH
70132: LD_VAR 0 1
70136: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70137: LD_VAR 0 1
70141: NOT
70142: PUSH
70143: LD_VAR 0 2
70147: NOT
70148: OR
70149: PUSH
70150: LD_VAR 0 3
70154: NOT
70155: OR
70156: PUSH
70157: LD_VAR 0 2
70161: PUSH
70162: LD_VAR 0 1
70166: GREATER
70167: OR
70168: PUSH
70169: LD_VAR 0 3
70173: PUSH
70174: LD_VAR 0 1
70178: GREATER
70179: OR
70180: IFFALSE 70184
// exit ;
70182: GO 70480
// if direction then
70184: LD_VAR 0 4
70188: IFFALSE 70252
// begin d := 1 ;
70190: LD_ADDR_VAR 0 9
70194: PUSH
70195: LD_INT 1
70197: ST_TO_ADDR
// if i_from > i_to then
70198: LD_VAR 0 2
70202: PUSH
70203: LD_VAR 0 3
70207: GREATER
70208: IFFALSE 70234
// length := ( array - i_from ) + i_to else
70210: LD_ADDR_VAR 0 11
70214: PUSH
70215: LD_VAR 0 1
70219: PUSH
70220: LD_VAR 0 2
70224: MINUS
70225: PUSH
70226: LD_VAR 0 3
70230: PLUS
70231: ST_TO_ADDR
70232: GO 70250
// length := i_to - i_from ;
70234: LD_ADDR_VAR 0 11
70238: PUSH
70239: LD_VAR 0 3
70243: PUSH
70244: LD_VAR 0 2
70248: MINUS
70249: ST_TO_ADDR
// end else
70250: GO 70313
// begin d := - 1 ;
70252: LD_ADDR_VAR 0 9
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: ST_TO_ADDR
// if i_from > i_to then
70261: LD_VAR 0 2
70265: PUSH
70266: LD_VAR 0 3
70270: GREATER
70271: IFFALSE 70291
// length := i_from - i_to else
70273: LD_ADDR_VAR 0 11
70277: PUSH
70278: LD_VAR 0 2
70282: PUSH
70283: LD_VAR 0 3
70287: MINUS
70288: ST_TO_ADDR
70289: GO 70313
// length := ( array - i_to ) + i_from ;
70291: LD_ADDR_VAR 0 11
70295: PUSH
70296: LD_VAR 0 1
70300: PUSH
70301: LD_VAR 0 3
70305: MINUS
70306: PUSH
70307: LD_VAR 0 2
70311: PLUS
70312: ST_TO_ADDR
// end ; if not length then
70313: LD_VAR 0 11
70317: NOT
70318: IFFALSE 70322
// exit ;
70320: GO 70480
// tmp := array ;
70322: LD_ADDR_VAR 0 10
70326: PUSH
70327: LD_VAR 0 1
70331: ST_TO_ADDR
// for i = 1 to length do
70332: LD_ADDR_VAR 0 6
70336: PUSH
70337: DOUBLE
70338: LD_INT 1
70340: DEC
70341: ST_TO_ADDR
70342: LD_VAR 0 11
70346: PUSH
70347: FOR_TO
70348: IFFALSE 70468
// begin for j = 1 to array do
70350: LD_ADDR_VAR 0 7
70354: PUSH
70355: DOUBLE
70356: LD_INT 1
70358: DEC
70359: ST_TO_ADDR
70360: LD_VAR 0 1
70364: PUSH
70365: FOR_TO
70366: IFFALSE 70454
// begin k := j + d ;
70368: LD_ADDR_VAR 0 8
70372: PUSH
70373: LD_VAR 0 7
70377: PUSH
70378: LD_VAR 0 9
70382: PLUS
70383: ST_TO_ADDR
// if k > array then
70384: LD_VAR 0 8
70388: PUSH
70389: LD_VAR 0 1
70393: GREATER
70394: IFFALSE 70404
// k := 1 ;
70396: LD_ADDR_VAR 0 8
70400: PUSH
70401: LD_INT 1
70403: ST_TO_ADDR
// if not k then
70404: LD_VAR 0 8
70408: NOT
70409: IFFALSE 70421
// k := array ;
70411: LD_ADDR_VAR 0 8
70415: PUSH
70416: LD_VAR 0 1
70420: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70421: LD_ADDR_VAR 0 10
70425: PUSH
70426: LD_VAR 0 10
70430: PPUSH
70431: LD_VAR 0 8
70435: PPUSH
70436: LD_VAR 0 1
70440: PUSH
70441: LD_VAR 0 7
70445: ARRAY
70446: PPUSH
70447: CALL_OW 1
70451: ST_TO_ADDR
// end ;
70452: GO 70365
70454: POP
70455: POP
// array := tmp ;
70456: LD_ADDR_VAR 0 1
70460: PUSH
70461: LD_VAR 0 10
70465: ST_TO_ADDR
// end ;
70466: GO 70347
70468: POP
70469: POP
// result := array ;
70470: LD_ADDR_VAR 0 5
70474: PUSH
70475: LD_VAR 0 1
70479: ST_TO_ADDR
// end ;
70480: LD_VAR 0 5
70484: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70485: LD_INT 0
70487: PPUSH
70488: PPUSH
// result := 0 ;
70489: LD_ADDR_VAR 0 3
70493: PUSH
70494: LD_INT 0
70496: ST_TO_ADDR
// if not array or not value in array then
70497: LD_VAR 0 1
70501: NOT
70502: PUSH
70503: LD_VAR 0 2
70507: PUSH
70508: LD_VAR 0 1
70512: IN
70513: NOT
70514: OR
70515: IFFALSE 70519
// exit ;
70517: GO 70573
// for i = 1 to array do
70519: LD_ADDR_VAR 0 4
70523: PUSH
70524: DOUBLE
70525: LD_INT 1
70527: DEC
70528: ST_TO_ADDR
70529: LD_VAR 0 1
70533: PUSH
70534: FOR_TO
70535: IFFALSE 70571
// if value = array [ i ] then
70537: LD_VAR 0 2
70541: PUSH
70542: LD_VAR 0 1
70546: PUSH
70547: LD_VAR 0 4
70551: ARRAY
70552: EQUAL
70553: IFFALSE 70569
// begin result := i ;
70555: LD_ADDR_VAR 0 3
70559: PUSH
70560: LD_VAR 0 4
70564: ST_TO_ADDR
// exit ;
70565: POP
70566: POP
70567: GO 70573
// end ;
70569: GO 70534
70571: POP
70572: POP
// end ;
70573: LD_VAR 0 3
70577: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70578: LD_INT 0
70580: PPUSH
// vc_chassis := chassis ;
70581: LD_ADDR_OWVAR 37
70585: PUSH
70586: LD_VAR 0 1
70590: ST_TO_ADDR
// vc_engine := engine ;
70591: LD_ADDR_OWVAR 39
70595: PUSH
70596: LD_VAR 0 2
70600: ST_TO_ADDR
// vc_control := control ;
70601: LD_ADDR_OWVAR 38
70605: PUSH
70606: LD_VAR 0 3
70610: ST_TO_ADDR
// vc_weapon := weapon ;
70611: LD_ADDR_OWVAR 40
70615: PUSH
70616: LD_VAR 0 4
70620: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70621: LD_ADDR_OWVAR 41
70625: PUSH
70626: LD_VAR 0 5
70630: ST_TO_ADDR
// end ;
70631: LD_VAR 0 6
70635: RET
// export function WantPlant ( unit ) ; var task ; begin
70636: LD_INT 0
70638: PPUSH
70639: PPUSH
// result := false ;
70640: LD_ADDR_VAR 0 2
70644: PUSH
70645: LD_INT 0
70647: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70648: LD_ADDR_VAR 0 3
70652: PUSH
70653: LD_VAR 0 1
70657: PPUSH
70658: CALL_OW 437
70662: ST_TO_ADDR
// if task then
70663: LD_VAR 0 3
70667: IFFALSE 70695
// if task [ 1 ] [ 1 ] = p then
70669: LD_VAR 0 3
70673: PUSH
70674: LD_INT 1
70676: ARRAY
70677: PUSH
70678: LD_INT 1
70680: ARRAY
70681: PUSH
70682: LD_STRING p
70684: EQUAL
70685: IFFALSE 70695
// result := true ;
70687: LD_ADDR_VAR 0 2
70691: PUSH
70692: LD_INT 1
70694: ST_TO_ADDR
// end ;
70695: LD_VAR 0 2
70699: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70700: LD_INT 0
70702: PPUSH
70703: PPUSH
70704: PPUSH
70705: PPUSH
// if pos < 1 then
70706: LD_VAR 0 2
70710: PUSH
70711: LD_INT 1
70713: LESS
70714: IFFALSE 70718
// exit ;
70716: GO 71021
// if pos = 1 then
70718: LD_VAR 0 2
70722: PUSH
70723: LD_INT 1
70725: EQUAL
70726: IFFALSE 70759
// result := Replace ( arr , pos [ 1 ] , value ) else
70728: LD_ADDR_VAR 0 4
70732: PUSH
70733: LD_VAR 0 1
70737: PPUSH
70738: LD_VAR 0 2
70742: PUSH
70743: LD_INT 1
70745: ARRAY
70746: PPUSH
70747: LD_VAR 0 3
70751: PPUSH
70752: CALL_OW 1
70756: ST_TO_ADDR
70757: GO 71021
// begin tmp := arr ;
70759: LD_ADDR_VAR 0 6
70763: PUSH
70764: LD_VAR 0 1
70768: ST_TO_ADDR
// s_arr := [ tmp ] ;
70769: LD_ADDR_VAR 0 7
70773: PUSH
70774: LD_VAR 0 6
70778: PUSH
70779: EMPTY
70780: LIST
70781: ST_TO_ADDR
// for i = 1 to pos - 1 do
70782: LD_ADDR_VAR 0 5
70786: PUSH
70787: DOUBLE
70788: LD_INT 1
70790: DEC
70791: ST_TO_ADDR
70792: LD_VAR 0 2
70796: PUSH
70797: LD_INT 1
70799: MINUS
70800: PUSH
70801: FOR_TO
70802: IFFALSE 70847
// begin tmp := tmp [ pos [ i ] ] ;
70804: LD_ADDR_VAR 0 6
70808: PUSH
70809: LD_VAR 0 6
70813: PUSH
70814: LD_VAR 0 2
70818: PUSH
70819: LD_VAR 0 5
70823: ARRAY
70824: ARRAY
70825: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70826: LD_ADDR_VAR 0 7
70830: PUSH
70831: LD_VAR 0 7
70835: PUSH
70836: LD_VAR 0 6
70840: PUSH
70841: EMPTY
70842: LIST
70843: ADD
70844: ST_TO_ADDR
// end ;
70845: GO 70801
70847: POP
70848: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70849: LD_ADDR_VAR 0 6
70853: PUSH
70854: LD_VAR 0 6
70858: PPUSH
70859: LD_VAR 0 2
70863: PUSH
70864: LD_VAR 0 2
70868: ARRAY
70869: PPUSH
70870: LD_VAR 0 3
70874: PPUSH
70875: CALL_OW 1
70879: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70880: LD_ADDR_VAR 0 7
70884: PUSH
70885: LD_VAR 0 7
70889: PPUSH
70890: LD_VAR 0 7
70894: PPUSH
70895: LD_VAR 0 6
70899: PPUSH
70900: CALL_OW 1
70904: ST_TO_ADDR
// for i = s_arr downto 2 do
70905: LD_ADDR_VAR 0 5
70909: PUSH
70910: DOUBLE
70911: LD_VAR 0 7
70915: INC
70916: ST_TO_ADDR
70917: LD_INT 2
70919: PUSH
70920: FOR_DOWNTO
70921: IFFALSE 71005
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70923: LD_ADDR_VAR 0 6
70927: PUSH
70928: LD_VAR 0 7
70932: PUSH
70933: LD_VAR 0 5
70937: PUSH
70938: LD_INT 1
70940: MINUS
70941: ARRAY
70942: PPUSH
70943: LD_VAR 0 2
70947: PUSH
70948: LD_VAR 0 5
70952: PUSH
70953: LD_INT 1
70955: MINUS
70956: ARRAY
70957: PPUSH
70958: LD_VAR 0 7
70962: PUSH
70963: LD_VAR 0 5
70967: ARRAY
70968: PPUSH
70969: CALL_OW 1
70973: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70974: LD_ADDR_VAR 0 7
70978: PUSH
70979: LD_VAR 0 7
70983: PPUSH
70984: LD_VAR 0 5
70988: PUSH
70989: LD_INT 1
70991: MINUS
70992: PPUSH
70993: LD_VAR 0 6
70997: PPUSH
70998: CALL_OW 1
71002: ST_TO_ADDR
// end ;
71003: GO 70920
71005: POP
71006: POP
// result := s_arr [ 1 ] ;
71007: LD_ADDR_VAR 0 4
71011: PUSH
71012: LD_VAR 0 7
71016: PUSH
71017: LD_INT 1
71019: ARRAY
71020: ST_TO_ADDR
// end ; end ;
71021: LD_VAR 0 4
71025: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71026: LD_INT 0
71028: PPUSH
71029: PPUSH
// if not list then
71030: LD_VAR 0 1
71034: NOT
71035: IFFALSE 71039
// exit ;
71037: GO 71130
// i := list [ pos1 ] ;
71039: LD_ADDR_VAR 0 5
71043: PUSH
71044: LD_VAR 0 1
71048: PUSH
71049: LD_VAR 0 2
71053: ARRAY
71054: ST_TO_ADDR
// if not i then
71055: LD_VAR 0 5
71059: NOT
71060: IFFALSE 71064
// exit ;
71062: GO 71130
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71064: LD_ADDR_VAR 0 1
71068: PUSH
71069: LD_VAR 0 1
71073: PPUSH
71074: LD_VAR 0 2
71078: PPUSH
71079: LD_VAR 0 1
71083: PUSH
71084: LD_VAR 0 3
71088: ARRAY
71089: PPUSH
71090: CALL_OW 1
71094: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71095: LD_ADDR_VAR 0 1
71099: PUSH
71100: LD_VAR 0 1
71104: PPUSH
71105: LD_VAR 0 3
71109: PPUSH
71110: LD_VAR 0 5
71114: PPUSH
71115: CALL_OW 1
71119: ST_TO_ADDR
// result := list ;
71120: LD_ADDR_VAR 0 4
71124: PUSH
71125: LD_VAR 0 1
71129: ST_TO_ADDR
// end ;
71130: LD_VAR 0 4
71134: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71135: LD_INT 0
71137: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71138: LD_ADDR_VAR 0 5
71142: PUSH
71143: LD_VAR 0 1
71147: PPUSH
71148: CALL_OW 250
71152: PPUSH
71153: LD_VAR 0 1
71157: PPUSH
71158: CALL_OW 251
71162: PPUSH
71163: LD_VAR 0 2
71167: PPUSH
71168: LD_VAR 0 3
71172: PPUSH
71173: LD_VAR 0 4
71177: PPUSH
71178: CALL 71188 0 5
71182: ST_TO_ADDR
// end ;
71183: LD_VAR 0 5
71187: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71188: LD_INT 0
71190: PPUSH
71191: PPUSH
71192: PPUSH
71193: PPUSH
// if not list then
71194: LD_VAR 0 3
71198: NOT
71199: IFFALSE 71203
// exit ;
71201: GO 71591
// result := [ ] ;
71203: LD_ADDR_VAR 0 6
71207: PUSH
71208: EMPTY
71209: ST_TO_ADDR
// for i in list do
71210: LD_ADDR_VAR 0 7
71214: PUSH
71215: LD_VAR 0 3
71219: PUSH
71220: FOR_IN
71221: IFFALSE 71423
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71223: LD_ADDR_VAR 0 9
71227: PUSH
71228: LD_VAR 0 7
71232: PPUSH
71233: LD_VAR 0 1
71237: PPUSH
71238: LD_VAR 0 2
71242: PPUSH
71243: CALL_OW 297
71247: ST_TO_ADDR
// if not result then
71248: LD_VAR 0 6
71252: NOT
71253: IFFALSE 71279
// result := [ [ i , tmp ] ] else
71255: LD_ADDR_VAR 0 6
71259: PUSH
71260: LD_VAR 0 7
71264: PUSH
71265: LD_VAR 0 9
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: EMPTY
71275: LIST
71276: ST_TO_ADDR
71277: GO 71421
// begin if result [ result ] [ 2 ] < tmp then
71279: LD_VAR 0 6
71283: PUSH
71284: LD_VAR 0 6
71288: ARRAY
71289: PUSH
71290: LD_INT 2
71292: ARRAY
71293: PUSH
71294: LD_VAR 0 9
71298: LESS
71299: IFFALSE 71341
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71301: LD_ADDR_VAR 0 6
71305: PUSH
71306: LD_VAR 0 6
71310: PPUSH
71311: LD_VAR 0 6
71315: PUSH
71316: LD_INT 1
71318: PLUS
71319: PPUSH
71320: LD_VAR 0 7
71324: PUSH
71325: LD_VAR 0 9
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PPUSH
71334: CALL_OW 2
71338: ST_TO_ADDR
71339: GO 71421
// for j = 1 to result do
71341: LD_ADDR_VAR 0 8
71345: PUSH
71346: DOUBLE
71347: LD_INT 1
71349: DEC
71350: ST_TO_ADDR
71351: LD_VAR 0 6
71355: PUSH
71356: FOR_TO
71357: IFFALSE 71419
// begin if tmp < result [ j ] [ 2 ] then
71359: LD_VAR 0 9
71363: PUSH
71364: LD_VAR 0 6
71368: PUSH
71369: LD_VAR 0 8
71373: ARRAY
71374: PUSH
71375: LD_INT 2
71377: ARRAY
71378: LESS
71379: IFFALSE 71417
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71381: LD_ADDR_VAR 0 6
71385: PUSH
71386: LD_VAR 0 6
71390: PPUSH
71391: LD_VAR 0 8
71395: PPUSH
71396: LD_VAR 0 7
71400: PUSH
71401: LD_VAR 0 9
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PPUSH
71410: CALL_OW 2
71414: ST_TO_ADDR
// break ;
71415: GO 71419
// end ; end ;
71417: GO 71356
71419: POP
71420: POP
// end ; end ;
71421: GO 71220
71423: POP
71424: POP
// if result and not asc then
71425: LD_VAR 0 6
71429: PUSH
71430: LD_VAR 0 4
71434: NOT
71435: AND
71436: IFFALSE 71511
// begin tmp := result ;
71438: LD_ADDR_VAR 0 9
71442: PUSH
71443: LD_VAR 0 6
71447: ST_TO_ADDR
// for i = tmp downto 1 do
71448: LD_ADDR_VAR 0 7
71452: PUSH
71453: DOUBLE
71454: LD_VAR 0 9
71458: INC
71459: ST_TO_ADDR
71460: LD_INT 1
71462: PUSH
71463: FOR_DOWNTO
71464: IFFALSE 71509
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71466: LD_ADDR_VAR 0 6
71470: PUSH
71471: LD_VAR 0 6
71475: PPUSH
71476: LD_VAR 0 9
71480: PUSH
71481: LD_VAR 0 7
71485: MINUS
71486: PUSH
71487: LD_INT 1
71489: PLUS
71490: PPUSH
71491: LD_VAR 0 9
71495: PUSH
71496: LD_VAR 0 7
71500: ARRAY
71501: PPUSH
71502: CALL_OW 1
71506: ST_TO_ADDR
71507: GO 71463
71509: POP
71510: POP
// end ; tmp := [ ] ;
71511: LD_ADDR_VAR 0 9
71515: PUSH
71516: EMPTY
71517: ST_TO_ADDR
// if mode then
71518: LD_VAR 0 5
71522: IFFALSE 71591
// begin for i = 1 to result do
71524: LD_ADDR_VAR 0 7
71528: PUSH
71529: DOUBLE
71530: LD_INT 1
71532: DEC
71533: ST_TO_ADDR
71534: LD_VAR 0 6
71538: PUSH
71539: FOR_TO
71540: IFFALSE 71579
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71542: LD_ADDR_VAR 0 9
71546: PUSH
71547: LD_VAR 0 9
71551: PPUSH
71552: LD_VAR 0 7
71556: PPUSH
71557: LD_VAR 0 6
71561: PUSH
71562: LD_VAR 0 7
71566: ARRAY
71567: PUSH
71568: LD_INT 1
71570: ARRAY
71571: PPUSH
71572: CALL_OW 1
71576: ST_TO_ADDR
71577: GO 71539
71579: POP
71580: POP
// result := tmp ;
71581: LD_ADDR_VAR 0 6
71585: PUSH
71586: LD_VAR 0 9
71590: ST_TO_ADDR
// end ; end ;
71591: LD_VAR 0 6
71595: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71596: LD_INT 0
71598: PPUSH
71599: PPUSH
71600: PPUSH
71601: PPUSH
71602: PPUSH
71603: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71604: LD_ADDR_VAR 0 5
71608: PUSH
71609: LD_INT 0
71611: PUSH
71612: LD_INT 0
71614: PUSH
71615: LD_INT 0
71617: PUSH
71618: EMPTY
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: ST_TO_ADDR
// if not x or not y then
71626: LD_VAR 0 2
71630: NOT
71631: PUSH
71632: LD_VAR 0 3
71636: NOT
71637: OR
71638: IFFALSE 71642
// exit ;
71640: GO 73294
// if not range then
71642: LD_VAR 0 4
71646: NOT
71647: IFFALSE 71657
// range := 10 ;
71649: LD_ADDR_VAR 0 4
71653: PUSH
71654: LD_INT 10
71656: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71657: LD_ADDR_VAR 0 8
71661: PUSH
71662: LD_INT 81
71664: PUSH
71665: LD_VAR 0 1
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 92
71676: PUSH
71677: LD_VAR 0 2
71681: PUSH
71682: LD_VAR 0 3
71686: PUSH
71687: LD_VAR 0 4
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 3
71700: PUSH
71701: LD_INT 21
71703: PUSH
71704: LD_INT 3
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: LIST
71719: PPUSH
71720: CALL_OW 69
71724: ST_TO_ADDR
// if not tmp then
71725: LD_VAR 0 8
71729: NOT
71730: IFFALSE 71734
// exit ;
71732: GO 73294
// for i in tmp do
71734: LD_ADDR_VAR 0 6
71738: PUSH
71739: LD_VAR 0 8
71743: PUSH
71744: FOR_IN
71745: IFFALSE 73269
// begin points := [ 0 , 0 , 0 ] ;
71747: LD_ADDR_VAR 0 9
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: LD_INT 0
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: LIST
71765: ST_TO_ADDR
// bpoints := 1 ;
71766: LD_ADDR_VAR 0 10
71770: PUSH
71771: LD_INT 1
71773: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71774: LD_VAR 0 6
71778: PPUSH
71779: CALL_OW 247
71783: PUSH
71784: LD_INT 1
71786: DOUBLE
71787: EQUAL
71788: IFTRUE 71792
71790: GO 72370
71792: POP
// begin if GetClass ( i ) = 1 then
71793: LD_VAR 0 6
71797: PPUSH
71798: CALL_OW 257
71802: PUSH
71803: LD_INT 1
71805: EQUAL
71806: IFFALSE 71827
// points := [ 10 , 5 , 3 ] ;
71808: LD_ADDR_VAR 0 9
71812: PUSH
71813: LD_INT 10
71815: PUSH
71816: LD_INT 5
71818: PUSH
71819: LD_INT 3
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71827: LD_VAR 0 6
71831: PPUSH
71832: CALL_OW 257
71836: PUSH
71837: LD_INT 2
71839: PUSH
71840: LD_INT 3
71842: PUSH
71843: LD_INT 4
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: LIST
71850: IN
71851: IFFALSE 71872
// points := [ 3 , 2 , 1 ] ;
71853: LD_ADDR_VAR 0 9
71857: PUSH
71858: LD_INT 3
71860: PUSH
71861: LD_INT 2
71863: PUSH
71864: LD_INT 1
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: LIST
71871: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71872: LD_VAR 0 6
71876: PPUSH
71877: CALL_OW 257
71881: PUSH
71882: LD_INT 5
71884: EQUAL
71885: IFFALSE 71906
// points := [ 130 , 5 , 2 ] ;
71887: LD_ADDR_VAR 0 9
71891: PUSH
71892: LD_INT 130
71894: PUSH
71895: LD_INT 5
71897: PUSH
71898: LD_INT 2
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: LIST
71905: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71906: LD_VAR 0 6
71910: PPUSH
71911: CALL_OW 257
71915: PUSH
71916: LD_INT 8
71918: EQUAL
71919: IFFALSE 71940
// points := [ 35 , 35 , 30 ] ;
71921: LD_ADDR_VAR 0 9
71925: PUSH
71926: LD_INT 35
71928: PUSH
71929: LD_INT 35
71931: PUSH
71932: LD_INT 30
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: LIST
71939: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71940: LD_VAR 0 6
71944: PPUSH
71945: CALL_OW 257
71949: PUSH
71950: LD_INT 9
71952: EQUAL
71953: IFFALSE 71974
// points := [ 20 , 55 , 40 ] ;
71955: LD_ADDR_VAR 0 9
71959: PUSH
71960: LD_INT 20
71962: PUSH
71963: LD_INT 55
71965: PUSH
71966: LD_INT 40
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: LIST
71973: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71974: LD_VAR 0 6
71978: PPUSH
71979: CALL_OW 257
71983: PUSH
71984: LD_INT 12
71986: PUSH
71987: LD_INT 16
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: IN
71994: IFFALSE 72015
// points := [ 5 , 3 , 2 ] ;
71996: LD_ADDR_VAR 0 9
72000: PUSH
72001: LD_INT 5
72003: PUSH
72004: LD_INT 3
72006: PUSH
72007: LD_INT 2
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: LIST
72014: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72015: LD_VAR 0 6
72019: PPUSH
72020: CALL_OW 257
72024: PUSH
72025: LD_INT 17
72027: EQUAL
72028: IFFALSE 72049
// points := [ 100 , 50 , 75 ] ;
72030: LD_ADDR_VAR 0 9
72034: PUSH
72035: LD_INT 100
72037: PUSH
72038: LD_INT 50
72040: PUSH
72041: LD_INT 75
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: LIST
72048: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72049: LD_VAR 0 6
72053: PPUSH
72054: CALL_OW 257
72058: PUSH
72059: LD_INT 15
72061: EQUAL
72062: IFFALSE 72083
// points := [ 10 , 5 , 3 ] ;
72064: LD_ADDR_VAR 0 9
72068: PUSH
72069: LD_INT 10
72071: PUSH
72072: LD_INT 5
72074: PUSH
72075: LD_INT 3
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: LIST
72082: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72083: LD_VAR 0 6
72087: PPUSH
72088: CALL_OW 257
72092: PUSH
72093: LD_INT 14
72095: EQUAL
72096: IFFALSE 72117
// points := [ 10 , 0 , 0 ] ;
72098: LD_ADDR_VAR 0 9
72102: PUSH
72103: LD_INT 10
72105: PUSH
72106: LD_INT 0
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: LIST
72116: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72117: LD_VAR 0 6
72121: PPUSH
72122: CALL_OW 257
72126: PUSH
72127: LD_INT 11
72129: EQUAL
72130: IFFALSE 72151
// points := [ 30 , 10 , 5 ] ;
72132: LD_ADDR_VAR 0 9
72136: PUSH
72137: LD_INT 30
72139: PUSH
72140: LD_INT 10
72142: PUSH
72143: LD_INT 5
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: LIST
72150: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72151: LD_VAR 0 1
72155: PPUSH
72156: LD_INT 5
72158: PPUSH
72159: CALL_OW 321
72163: PUSH
72164: LD_INT 2
72166: EQUAL
72167: IFFALSE 72184
// bpoints := bpoints * 1.8 ;
72169: LD_ADDR_VAR 0 10
72173: PUSH
72174: LD_VAR 0 10
72178: PUSH
72179: LD_REAL  1.80000000000000E+0000
72182: MUL
72183: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72184: LD_VAR 0 6
72188: PPUSH
72189: CALL_OW 257
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: LD_INT 3
72202: PUSH
72203: LD_INT 4
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: IN
72212: PUSH
72213: LD_VAR 0 1
72217: PPUSH
72218: LD_INT 51
72220: PPUSH
72221: CALL_OW 321
72225: PUSH
72226: LD_INT 2
72228: EQUAL
72229: AND
72230: IFFALSE 72247
// bpoints := bpoints * 1.2 ;
72232: LD_ADDR_VAR 0 10
72236: PUSH
72237: LD_VAR 0 10
72241: PUSH
72242: LD_REAL  1.20000000000000E+0000
72245: MUL
72246: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72247: LD_VAR 0 6
72251: PPUSH
72252: CALL_OW 257
72256: PUSH
72257: LD_INT 5
72259: PUSH
72260: LD_INT 7
72262: PUSH
72263: LD_INT 9
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: LIST
72270: IN
72271: PUSH
72272: LD_VAR 0 1
72276: PPUSH
72277: LD_INT 52
72279: PPUSH
72280: CALL_OW 321
72284: PUSH
72285: LD_INT 2
72287: EQUAL
72288: AND
72289: IFFALSE 72306
// bpoints := bpoints * 1.5 ;
72291: LD_ADDR_VAR 0 10
72295: PUSH
72296: LD_VAR 0 10
72300: PUSH
72301: LD_REAL  1.50000000000000E+0000
72304: MUL
72305: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72306: LD_VAR 0 1
72310: PPUSH
72311: LD_INT 66
72313: PPUSH
72314: CALL_OW 321
72318: PUSH
72319: LD_INT 2
72321: EQUAL
72322: IFFALSE 72339
// bpoints := bpoints * 1.1 ;
72324: LD_ADDR_VAR 0 10
72328: PUSH
72329: LD_VAR 0 10
72333: PUSH
72334: LD_REAL  1.10000000000000E+0000
72337: MUL
72338: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72339: LD_ADDR_VAR 0 10
72343: PUSH
72344: LD_VAR 0 10
72348: PUSH
72349: LD_VAR 0 6
72353: PPUSH
72354: LD_INT 1
72356: PPUSH
72357: CALL_OW 259
72361: PUSH
72362: LD_REAL  1.15000000000000E+0000
72365: MUL
72366: MUL
72367: ST_TO_ADDR
// end ; unit_vehicle :
72368: GO 73198
72370: LD_INT 2
72372: DOUBLE
72373: EQUAL
72374: IFTRUE 72378
72376: GO 73186
72378: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72379: LD_VAR 0 6
72383: PPUSH
72384: CALL_OW 264
72388: PUSH
72389: LD_INT 2
72391: PUSH
72392: LD_INT 42
72394: PUSH
72395: LD_INT 24
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: LIST
72402: IN
72403: IFFALSE 72424
// points := [ 25 , 5 , 3 ] ;
72405: LD_ADDR_VAR 0 9
72409: PUSH
72410: LD_INT 25
72412: PUSH
72413: LD_INT 5
72415: PUSH
72416: LD_INT 3
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: LIST
72423: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72424: LD_VAR 0 6
72428: PPUSH
72429: CALL_OW 264
72433: PUSH
72434: LD_INT 4
72436: PUSH
72437: LD_INT 43
72439: PUSH
72440: LD_INT 25
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: LIST
72447: IN
72448: IFFALSE 72469
// points := [ 40 , 15 , 5 ] ;
72450: LD_ADDR_VAR 0 9
72454: PUSH
72455: LD_INT 40
72457: PUSH
72458: LD_INT 15
72460: PUSH
72461: LD_INT 5
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: LIST
72468: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72469: LD_VAR 0 6
72473: PPUSH
72474: CALL_OW 264
72478: PUSH
72479: LD_INT 3
72481: PUSH
72482: LD_INT 23
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: IN
72489: IFFALSE 72510
// points := [ 7 , 25 , 8 ] ;
72491: LD_ADDR_VAR 0 9
72495: PUSH
72496: LD_INT 7
72498: PUSH
72499: LD_INT 25
72501: PUSH
72502: LD_INT 8
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: LIST
72509: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72510: LD_VAR 0 6
72514: PPUSH
72515: CALL_OW 264
72519: PUSH
72520: LD_INT 5
72522: PUSH
72523: LD_INT 27
72525: PUSH
72526: LD_INT 44
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: LIST
72533: IN
72534: IFFALSE 72555
// points := [ 14 , 50 , 16 ] ;
72536: LD_ADDR_VAR 0 9
72540: PUSH
72541: LD_INT 14
72543: PUSH
72544: LD_INT 50
72546: PUSH
72547: LD_INT 16
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: LIST
72554: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72555: LD_VAR 0 6
72559: PPUSH
72560: CALL_OW 264
72564: PUSH
72565: LD_INT 6
72567: PUSH
72568: LD_INT 46
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: IN
72575: IFFALSE 72596
// points := [ 32 , 120 , 70 ] ;
72577: LD_ADDR_VAR 0 9
72581: PUSH
72582: LD_INT 32
72584: PUSH
72585: LD_INT 120
72587: PUSH
72588: LD_INT 70
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: LIST
72595: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72596: LD_VAR 0 6
72600: PPUSH
72601: CALL_OW 264
72605: PUSH
72606: LD_INT 7
72608: PUSH
72609: LD_INT 28
72611: PUSH
72612: LD_INT 45
72614: PUSH
72615: LD_EXP 100
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: IN
72626: IFFALSE 72647
// points := [ 35 , 20 , 45 ] ;
72628: LD_ADDR_VAR 0 9
72632: PUSH
72633: LD_INT 35
72635: PUSH
72636: LD_INT 20
72638: PUSH
72639: LD_INT 45
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: LIST
72646: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72647: LD_VAR 0 6
72651: PPUSH
72652: CALL_OW 264
72656: PUSH
72657: LD_INT 47
72659: PUSH
72660: EMPTY
72661: LIST
72662: IN
72663: IFFALSE 72684
// points := [ 67 , 45 , 75 ] ;
72665: LD_ADDR_VAR 0 9
72669: PUSH
72670: LD_INT 67
72672: PUSH
72673: LD_INT 45
72675: PUSH
72676: LD_INT 75
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: LIST
72683: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72684: LD_VAR 0 6
72688: PPUSH
72689: CALL_OW 264
72693: PUSH
72694: LD_INT 26
72696: PUSH
72697: EMPTY
72698: LIST
72699: IN
72700: IFFALSE 72721
// points := [ 120 , 30 , 80 ] ;
72702: LD_ADDR_VAR 0 9
72706: PUSH
72707: LD_INT 120
72709: PUSH
72710: LD_INT 30
72712: PUSH
72713: LD_INT 80
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: LIST
72720: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72721: LD_VAR 0 6
72725: PPUSH
72726: CALL_OW 264
72730: PUSH
72731: LD_INT 22
72733: PUSH
72734: EMPTY
72735: LIST
72736: IN
72737: IFFALSE 72758
// points := [ 40 , 1 , 1 ] ;
72739: LD_ADDR_VAR 0 9
72743: PUSH
72744: LD_INT 40
72746: PUSH
72747: LD_INT 1
72749: PUSH
72750: LD_INT 1
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: LIST
72757: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72758: LD_VAR 0 6
72762: PPUSH
72763: CALL_OW 264
72767: PUSH
72768: LD_INT 29
72770: PUSH
72771: EMPTY
72772: LIST
72773: IN
72774: IFFALSE 72795
// points := [ 70 , 200 , 400 ] ;
72776: LD_ADDR_VAR 0 9
72780: PUSH
72781: LD_INT 70
72783: PUSH
72784: LD_INT 200
72786: PUSH
72787: LD_INT 400
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: LIST
72794: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72795: LD_VAR 0 6
72799: PPUSH
72800: CALL_OW 264
72804: PUSH
72805: LD_INT 14
72807: PUSH
72808: LD_INT 53
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: IN
72815: IFFALSE 72836
// points := [ 40 , 10 , 20 ] ;
72817: LD_ADDR_VAR 0 9
72821: PUSH
72822: LD_INT 40
72824: PUSH
72825: LD_INT 10
72827: PUSH
72828: LD_INT 20
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: LIST
72835: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72836: LD_VAR 0 6
72840: PPUSH
72841: CALL_OW 264
72845: PUSH
72846: LD_INT 9
72848: PUSH
72849: EMPTY
72850: LIST
72851: IN
72852: IFFALSE 72873
// points := [ 5 , 70 , 20 ] ;
72854: LD_ADDR_VAR 0 9
72858: PUSH
72859: LD_INT 5
72861: PUSH
72862: LD_INT 70
72864: PUSH
72865: LD_INT 20
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: LIST
72872: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72873: LD_VAR 0 6
72877: PPUSH
72878: CALL_OW 264
72882: PUSH
72883: LD_INT 10
72885: PUSH
72886: EMPTY
72887: LIST
72888: IN
72889: IFFALSE 72910
// points := [ 35 , 110 , 70 ] ;
72891: LD_ADDR_VAR 0 9
72895: PUSH
72896: LD_INT 35
72898: PUSH
72899: LD_INT 110
72901: PUSH
72902: LD_INT 70
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: LIST
72909: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72910: LD_VAR 0 6
72914: PPUSH
72915: CALL_OW 265
72919: PUSH
72920: LD_INT 25
72922: EQUAL
72923: IFFALSE 72944
// points := [ 80 , 65 , 100 ] ;
72925: LD_ADDR_VAR 0 9
72929: PUSH
72930: LD_INT 80
72932: PUSH
72933: LD_INT 65
72935: PUSH
72936: LD_INT 100
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: LIST
72943: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72944: LD_VAR 0 6
72948: PPUSH
72949: CALL_OW 263
72953: PUSH
72954: LD_INT 1
72956: EQUAL
72957: IFFALSE 72992
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72959: LD_ADDR_VAR 0 10
72963: PUSH
72964: LD_VAR 0 10
72968: PUSH
72969: LD_VAR 0 6
72973: PPUSH
72974: CALL_OW 311
72978: PPUSH
72979: LD_INT 3
72981: PPUSH
72982: CALL_OW 259
72986: PUSH
72987: LD_INT 4
72989: MUL
72990: MUL
72991: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72992: LD_VAR 0 6
72996: PPUSH
72997: CALL_OW 263
73001: PUSH
73002: LD_INT 2
73004: EQUAL
73005: IFFALSE 73056
// begin j := IsControledBy ( i ) ;
73007: LD_ADDR_VAR 0 7
73011: PUSH
73012: LD_VAR 0 6
73016: PPUSH
73017: CALL_OW 312
73021: ST_TO_ADDR
// if j then
73022: LD_VAR 0 7
73026: IFFALSE 73056
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73028: LD_ADDR_VAR 0 10
73032: PUSH
73033: LD_VAR 0 10
73037: PUSH
73038: LD_VAR 0 7
73042: PPUSH
73043: LD_INT 3
73045: PPUSH
73046: CALL_OW 259
73050: PUSH
73051: LD_INT 3
73053: MUL
73054: MUL
73055: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73056: LD_VAR 0 6
73060: PPUSH
73061: CALL_OW 264
73065: PUSH
73066: LD_INT 5
73068: PUSH
73069: LD_INT 6
73071: PUSH
73072: LD_INT 46
73074: PUSH
73075: LD_INT 44
73077: PUSH
73078: LD_INT 47
73080: PUSH
73081: LD_INT 45
73083: PUSH
73084: LD_INT 28
73086: PUSH
73087: LD_INT 7
73089: PUSH
73090: LD_INT 27
73092: PUSH
73093: LD_INT 29
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: IN
73108: PUSH
73109: LD_VAR 0 1
73113: PPUSH
73114: LD_INT 52
73116: PPUSH
73117: CALL_OW 321
73121: PUSH
73122: LD_INT 2
73124: EQUAL
73125: AND
73126: IFFALSE 73143
// bpoints := bpoints * 1.2 ;
73128: LD_ADDR_VAR 0 10
73132: PUSH
73133: LD_VAR 0 10
73137: PUSH
73138: LD_REAL  1.20000000000000E+0000
73141: MUL
73142: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73143: LD_VAR 0 6
73147: PPUSH
73148: CALL_OW 264
73152: PUSH
73153: LD_INT 6
73155: PUSH
73156: LD_INT 46
73158: PUSH
73159: LD_INT 47
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: LIST
73166: IN
73167: IFFALSE 73184
// bpoints := bpoints * 1.2 ;
73169: LD_ADDR_VAR 0 10
73173: PUSH
73174: LD_VAR 0 10
73178: PUSH
73179: LD_REAL  1.20000000000000E+0000
73182: MUL
73183: ST_TO_ADDR
// end ; unit_building :
73184: GO 73198
73186: LD_INT 3
73188: DOUBLE
73189: EQUAL
73190: IFTRUE 73194
73192: GO 73197
73194: POP
// ; end ;
73195: GO 73198
73197: POP
// for j = 1 to 3 do
73198: LD_ADDR_VAR 0 7
73202: PUSH
73203: DOUBLE
73204: LD_INT 1
73206: DEC
73207: ST_TO_ADDR
73208: LD_INT 3
73210: PUSH
73211: FOR_TO
73212: IFFALSE 73265
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73214: LD_ADDR_VAR 0 5
73218: PUSH
73219: LD_VAR 0 5
73223: PPUSH
73224: LD_VAR 0 7
73228: PPUSH
73229: LD_VAR 0 5
73233: PUSH
73234: LD_VAR 0 7
73238: ARRAY
73239: PUSH
73240: LD_VAR 0 9
73244: PUSH
73245: LD_VAR 0 7
73249: ARRAY
73250: PUSH
73251: LD_VAR 0 10
73255: MUL
73256: PLUS
73257: PPUSH
73258: CALL_OW 1
73262: ST_TO_ADDR
73263: GO 73211
73265: POP
73266: POP
// end ;
73267: GO 71744
73269: POP
73270: POP
// result := Replace ( result , 4 , tmp ) ;
73271: LD_ADDR_VAR 0 5
73275: PUSH
73276: LD_VAR 0 5
73280: PPUSH
73281: LD_INT 4
73283: PPUSH
73284: LD_VAR 0 8
73288: PPUSH
73289: CALL_OW 1
73293: ST_TO_ADDR
// end ;
73294: LD_VAR 0 5
73298: RET
// export function DangerAtRange ( unit , range ) ; begin
73299: LD_INT 0
73301: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73302: LD_ADDR_VAR 0 3
73306: PUSH
73307: LD_VAR 0 1
73311: PPUSH
73312: CALL_OW 255
73316: PPUSH
73317: LD_VAR 0 1
73321: PPUSH
73322: CALL_OW 250
73326: PPUSH
73327: LD_VAR 0 1
73331: PPUSH
73332: CALL_OW 251
73336: PPUSH
73337: LD_VAR 0 2
73341: PPUSH
73342: CALL 71596 0 4
73346: ST_TO_ADDR
// end ;
73347: LD_VAR 0 3
73351: RET
// export function DangerInArea ( side , area ) ; begin
73352: LD_INT 0
73354: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73355: LD_ADDR_VAR 0 3
73359: PUSH
73360: LD_VAR 0 2
73364: PPUSH
73365: LD_INT 81
73367: PUSH
73368: LD_VAR 0 1
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PPUSH
73377: CALL_OW 70
73381: ST_TO_ADDR
// end ;
73382: LD_VAR 0 3
73386: RET
// export function IsExtension ( b ) ; begin
73387: LD_INT 0
73389: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73390: LD_ADDR_VAR 0 2
73394: PUSH
73395: LD_VAR 0 1
73399: PUSH
73400: LD_INT 23
73402: PUSH
73403: LD_INT 20
73405: PUSH
73406: LD_INT 22
73408: PUSH
73409: LD_INT 17
73411: PUSH
73412: LD_INT 24
73414: PUSH
73415: LD_INT 21
73417: PUSH
73418: LD_INT 19
73420: PUSH
73421: LD_INT 16
73423: PUSH
73424: LD_INT 25
73426: PUSH
73427: LD_INT 18
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: IN
73442: ST_TO_ADDR
// end ;
73443: LD_VAR 0 2
73447: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73448: LD_INT 0
73450: PPUSH
73451: PPUSH
73452: PPUSH
// result := [ ] ;
73453: LD_ADDR_VAR 0 4
73457: PUSH
73458: EMPTY
73459: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73460: LD_ADDR_VAR 0 5
73464: PUSH
73465: LD_VAR 0 2
73469: PPUSH
73470: LD_INT 21
73472: PUSH
73473: LD_INT 3
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PPUSH
73480: CALL_OW 70
73484: ST_TO_ADDR
// if not tmp then
73485: LD_VAR 0 5
73489: NOT
73490: IFFALSE 73494
// exit ;
73492: GO 73558
// if checkLink then
73494: LD_VAR 0 3
73498: IFFALSE 73548
// begin for i in tmp do
73500: LD_ADDR_VAR 0 6
73504: PUSH
73505: LD_VAR 0 5
73509: PUSH
73510: FOR_IN
73511: IFFALSE 73546
// if GetBase ( i ) <> base then
73513: LD_VAR 0 6
73517: PPUSH
73518: CALL_OW 274
73522: PUSH
73523: LD_VAR 0 1
73527: NONEQUAL
73528: IFFALSE 73544
// ComLinkToBase ( base , i ) ;
73530: LD_VAR 0 1
73534: PPUSH
73535: LD_VAR 0 6
73539: PPUSH
73540: CALL_OW 169
73544: GO 73510
73546: POP
73547: POP
// end ; result := tmp ;
73548: LD_ADDR_VAR 0 4
73552: PUSH
73553: LD_VAR 0 5
73557: ST_TO_ADDR
// end ;
73558: LD_VAR 0 4
73562: RET
// export function ComComplete ( units , b ) ; var i ; begin
73563: LD_INT 0
73565: PPUSH
73566: PPUSH
// if not units then
73567: LD_VAR 0 1
73571: NOT
73572: IFFALSE 73576
// exit ;
73574: GO 73666
// for i in units do
73576: LD_ADDR_VAR 0 4
73580: PUSH
73581: LD_VAR 0 1
73585: PUSH
73586: FOR_IN
73587: IFFALSE 73664
// if BuildingStatus ( b ) = bs_build then
73589: LD_VAR 0 2
73593: PPUSH
73594: CALL_OW 461
73598: PUSH
73599: LD_INT 1
73601: EQUAL
73602: IFFALSE 73662
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73604: LD_VAR 0 4
73608: PPUSH
73609: LD_STRING h
73611: PUSH
73612: LD_VAR 0 2
73616: PPUSH
73617: CALL_OW 250
73621: PUSH
73622: LD_VAR 0 2
73626: PPUSH
73627: CALL_OW 251
73631: PUSH
73632: LD_VAR 0 2
73636: PUSH
73637: LD_INT 0
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: LD_INT 0
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: PUSH
73655: EMPTY
73656: LIST
73657: PPUSH
73658: CALL_OW 446
73662: GO 73586
73664: POP
73665: POP
// end ;
73666: LD_VAR 0 3
73670: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73671: LD_INT 0
73673: PPUSH
73674: PPUSH
73675: PPUSH
73676: PPUSH
73677: PPUSH
73678: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73679: LD_VAR 0 1
73683: NOT
73684: PUSH
73685: LD_VAR 0 1
73689: PPUSH
73690: CALL_OW 263
73694: PUSH
73695: LD_INT 2
73697: NONEQUAL
73698: OR
73699: IFFALSE 73703
// exit ;
73701: GO 74019
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73703: LD_ADDR_VAR 0 6
73707: PUSH
73708: LD_INT 22
73710: PUSH
73711: LD_VAR 0 1
73715: PPUSH
73716: CALL_OW 255
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 2
73727: PUSH
73728: LD_INT 30
73730: PUSH
73731: LD_INT 36
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 34
73740: PUSH
73741: LD_INT 31
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: LIST
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PPUSH
73757: CALL_OW 69
73761: ST_TO_ADDR
// if not tmp then
73762: LD_VAR 0 6
73766: NOT
73767: IFFALSE 73771
// exit ;
73769: GO 74019
// result := [ ] ;
73771: LD_ADDR_VAR 0 2
73775: PUSH
73776: EMPTY
73777: ST_TO_ADDR
// for i in tmp do
73778: LD_ADDR_VAR 0 3
73782: PUSH
73783: LD_VAR 0 6
73787: PUSH
73788: FOR_IN
73789: IFFALSE 73860
// begin t := UnitsInside ( i ) ;
73791: LD_ADDR_VAR 0 4
73795: PUSH
73796: LD_VAR 0 3
73800: PPUSH
73801: CALL_OW 313
73805: ST_TO_ADDR
// if t then
73806: LD_VAR 0 4
73810: IFFALSE 73858
// for j in t do
73812: LD_ADDR_VAR 0 7
73816: PUSH
73817: LD_VAR 0 4
73821: PUSH
73822: FOR_IN
73823: IFFALSE 73856
// result := Replace ( result , result + 1 , j ) ;
73825: LD_ADDR_VAR 0 2
73829: PUSH
73830: LD_VAR 0 2
73834: PPUSH
73835: LD_VAR 0 2
73839: PUSH
73840: LD_INT 1
73842: PLUS
73843: PPUSH
73844: LD_VAR 0 7
73848: PPUSH
73849: CALL_OW 1
73853: ST_TO_ADDR
73854: GO 73822
73856: POP
73857: POP
// end ;
73858: GO 73788
73860: POP
73861: POP
// if not result then
73862: LD_VAR 0 2
73866: NOT
73867: IFFALSE 73871
// exit ;
73869: GO 74019
// mech := result [ 1 ] ;
73871: LD_ADDR_VAR 0 5
73875: PUSH
73876: LD_VAR 0 2
73880: PUSH
73881: LD_INT 1
73883: ARRAY
73884: ST_TO_ADDR
// if result > 1 then
73885: LD_VAR 0 2
73889: PUSH
73890: LD_INT 1
73892: GREATER
73893: IFFALSE 74005
// begin for i = 2 to result do
73895: LD_ADDR_VAR 0 3
73899: PUSH
73900: DOUBLE
73901: LD_INT 2
73903: DEC
73904: ST_TO_ADDR
73905: LD_VAR 0 2
73909: PUSH
73910: FOR_TO
73911: IFFALSE 74003
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73913: LD_ADDR_VAR 0 4
73917: PUSH
73918: LD_VAR 0 2
73922: PUSH
73923: LD_VAR 0 3
73927: ARRAY
73928: PPUSH
73929: LD_INT 3
73931: PPUSH
73932: CALL_OW 259
73936: PUSH
73937: LD_VAR 0 2
73941: PUSH
73942: LD_VAR 0 3
73946: ARRAY
73947: PPUSH
73948: CALL_OW 432
73952: MINUS
73953: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73954: LD_VAR 0 4
73958: PUSH
73959: LD_VAR 0 5
73963: PPUSH
73964: LD_INT 3
73966: PPUSH
73967: CALL_OW 259
73971: PUSH
73972: LD_VAR 0 5
73976: PPUSH
73977: CALL_OW 432
73981: MINUS
73982: GREATEREQUAL
73983: IFFALSE 74001
// mech := result [ i ] ;
73985: LD_ADDR_VAR 0 5
73989: PUSH
73990: LD_VAR 0 2
73994: PUSH
73995: LD_VAR 0 3
73999: ARRAY
74000: ST_TO_ADDR
// end ;
74001: GO 73910
74003: POP
74004: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74005: LD_VAR 0 1
74009: PPUSH
74010: LD_VAR 0 5
74014: PPUSH
74015: CALL_OW 135
// end ;
74019: LD_VAR 0 2
74023: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74024: LD_INT 0
74026: PPUSH
74027: PPUSH
74028: PPUSH
74029: PPUSH
74030: PPUSH
74031: PPUSH
74032: PPUSH
74033: PPUSH
74034: PPUSH
74035: PPUSH
74036: PPUSH
74037: PPUSH
74038: PPUSH
// result := [ ] ;
74039: LD_ADDR_VAR 0 7
74043: PUSH
74044: EMPTY
74045: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74046: LD_VAR 0 1
74050: PPUSH
74051: CALL_OW 266
74055: PUSH
74056: LD_INT 0
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: IN
74066: NOT
74067: IFFALSE 74071
// exit ;
74069: GO 75705
// if name then
74071: LD_VAR 0 3
74075: IFFALSE 74091
// SetBName ( base_dep , name ) ;
74077: LD_VAR 0 1
74081: PPUSH
74082: LD_VAR 0 3
74086: PPUSH
74087: CALL_OW 500
// base := GetBase ( base_dep ) ;
74091: LD_ADDR_VAR 0 15
74095: PUSH
74096: LD_VAR 0 1
74100: PPUSH
74101: CALL_OW 274
74105: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74106: LD_ADDR_VAR 0 16
74110: PUSH
74111: LD_VAR 0 1
74115: PPUSH
74116: CALL_OW 255
74120: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74121: LD_ADDR_VAR 0 17
74125: PUSH
74126: LD_VAR 0 1
74130: PPUSH
74131: CALL_OW 248
74135: ST_TO_ADDR
// if sources then
74136: LD_VAR 0 5
74140: IFFALSE 74187
// for i = 1 to 3 do
74142: LD_ADDR_VAR 0 8
74146: PUSH
74147: DOUBLE
74148: LD_INT 1
74150: DEC
74151: ST_TO_ADDR
74152: LD_INT 3
74154: PUSH
74155: FOR_TO
74156: IFFALSE 74185
// AddResourceType ( base , i , sources [ i ] ) ;
74158: LD_VAR 0 15
74162: PPUSH
74163: LD_VAR 0 8
74167: PPUSH
74168: LD_VAR 0 5
74172: PUSH
74173: LD_VAR 0 8
74177: ARRAY
74178: PPUSH
74179: CALL_OW 276
74183: GO 74155
74185: POP
74186: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74187: LD_ADDR_VAR 0 18
74191: PUSH
74192: LD_VAR 0 15
74196: PPUSH
74197: LD_VAR 0 2
74201: PPUSH
74202: LD_INT 1
74204: PPUSH
74205: CALL 73448 0 3
74209: ST_TO_ADDR
// InitHc ;
74210: CALL_OW 19
// InitUc ;
74214: CALL_OW 18
// uc_side := side ;
74218: LD_ADDR_OWVAR 20
74222: PUSH
74223: LD_VAR 0 16
74227: ST_TO_ADDR
// uc_nation := nation ;
74228: LD_ADDR_OWVAR 21
74232: PUSH
74233: LD_VAR 0 17
74237: ST_TO_ADDR
// if buildings then
74238: LD_VAR 0 18
74242: IFFALSE 75564
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74244: LD_ADDR_VAR 0 19
74248: PUSH
74249: LD_VAR 0 18
74253: PPUSH
74254: LD_INT 2
74256: PUSH
74257: LD_INT 30
74259: PUSH
74260: LD_INT 29
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: LD_INT 30
74269: PUSH
74270: LD_INT 30
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: LIST
74281: PPUSH
74282: CALL_OW 72
74286: ST_TO_ADDR
// if tmp then
74287: LD_VAR 0 19
74291: IFFALSE 74339
// for i in tmp do
74293: LD_ADDR_VAR 0 8
74297: PUSH
74298: LD_VAR 0 19
74302: PUSH
74303: FOR_IN
74304: IFFALSE 74337
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74306: LD_VAR 0 8
74310: PPUSH
74311: CALL_OW 250
74315: PPUSH
74316: LD_VAR 0 8
74320: PPUSH
74321: CALL_OW 251
74325: PPUSH
74326: LD_VAR 0 16
74330: PPUSH
74331: CALL_OW 441
74335: GO 74303
74337: POP
74338: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74339: LD_VAR 0 18
74343: PPUSH
74344: LD_INT 2
74346: PUSH
74347: LD_INT 30
74349: PUSH
74350: LD_INT 32
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 30
74359: PUSH
74360: LD_INT 33
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: LIST
74371: PPUSH
74372: CALL_OW 72
74376: IFFALSE 74464
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74378: LD_ADDR_VAR 0 8
74382: PUSH
74383: LD_VAR 0 18
74387: PPUSH
74388: LD_INT 2
74390: PUSH
74391: LD_INT 30
74393: PUSH
74394: LD_INT 32
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 30
74403: PUSH
74404: LD_INT 33
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: LIST
74415: PPUSH
74416: CALL_OW 72
74420: PUSH
74421: FOR_IN
74422: IFFALSE 74462
// begin if not GetBWeapon ( i ) then
74424: LD_VAR 0 8
74428: PPUSH
74429: CALL_OW 269
74433: NOT
74434: IFFALSE 74460
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74436: LD_VAR 0 8
74440: PPUSH
74441: LD_VAR 0 8
74445: PPUSH
74446: LD_VAR 0 2
74450: PPUSH
74451: CALL 75710 0 2
74455: PPUSH
74456: CALL_OW 431
// end ;
74460: GO 74421
74462: POP
74463: POP
// end ; for i = 1 to personel do
74464: LD_ADDR_VAR 0 8
74468: PUSH
74469: DOUBLE
74470: LD_INT 1
74472: DEC
74473: ST_TO_ADDR
74474: LD_VAR 0 6
74478: PUSH
74479: FOR_TO
74480: IFFALSE 75544
// begin if i > 4 then
74482: LD_VAR 0 8
74486: PUSH
74487: LD_INT 4
74489: GREATER
74490: IFFALSE 74494
// break ;
74492: GO 75544
// case i of 1 :
74494: LD_VAR 0 8
74498: PUSH
74499: LD_INT 1
74501: DOUBLE
74502: EQUAL
74503: IFTRUE 74507
74505: GO 74587
74507: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74508: LD_ADDR_VAR 0 12
74512: PUSH
74513: LD_VAR 0 18
74517: PPUSH
74518: LD_INT 22
74520: PUSH
74521: LD_VAR 0 16
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 58
74532: PUSH
74533: EMPTY
74534: LIST
74535: PUSH
74536: LD_INT 2
74538: PUSH
74539: LD_INT 30
74541: PUSH
74542: LD_INT 32
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 30
74551: PUSH
74552: LD_INT 4
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 30
74561: PUSH
74562: LD_INT 5
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: LIST
74579: PPUSH
74580: CALL_OW 72
74584: ST_TO_ADDR
74585: GO 74809
74587: LD_INT 2
74589: DOUBLE
74590: EQUAL
74591: IFTRUE 74595
74593: GO 74657
74595: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74596: LD_ADDR_VAR 0 12
74600: PUSH
74601: LD_VAR 0 18
74605: PPUSH
74606: LD_INT 22
74608: PUSH
74609: LD_VAR 0 16
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 2
74620: PUSH
74621: LD_INT 30
74623: PUSH
74624: LD_INT 0
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 30
74633: PUSH
74634: LD_INT 1
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: LIST
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: PPUSH
74650: CALL_OW 72
74654: ST_TO_ADDR
74655: GO 74809
74657: LD_INT 3
74659: DOUBLE
74660: EQUAL
74661: IFTRUE 74665
74663: GO 74727
74665: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74666: LD_ADDR_VAR 0 12
74670: PUSH
74671: LD_VAR 0 18
74675: PPUSH
74676: LD_INT 22
74678: PUSH
74679: LD_VAR 0 16
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 2
74690: PUSH
74691: LD_INT 30
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 30
74703: PUSH
74704: LD_INT 3
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: LIST
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PPUSH
74720: CALL_OW 72
74724: ST_TO_ADDR
74725: GO 74809
74727: LD_INT 4
74729: DOUBLE
74730: EQUAL
74731: IFTRUE 74735
74733: GO 74808
74735: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74736: LD_ADDR_VAR 0 12
74740: PUSH
74741: LD_VAR 0 18
74745: PPUSH
74746: LD_INT 22
74748: PUSH
74749: LD_VAR 0 16
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 2
74760: PUSH
74761: LD_INT 30
74763: PUSH
74764: LD_INT 6
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 30
74773: PUSH
74774: LD_INT 7
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 30
74783: PUSH
74784: LD_INT 8
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PPUSH
74801: CALL_OW 72
74805: ST_TO_ADDR
74806: GO 74809
74808: POP
// if i = 1 then
74809: LD_VAR 0 8
74813: PUSH
74814: LD_INT 1
74816: EQUAL
74817: IFFALSE 74928
// begin tmp := [ ] ;
74819: LD_ADDR_VAR 0 19
74823: PUSH
74824: EMPTY
74825: ST_TO_ADDR
// for j in f do
74826: LD_ADDR_VAR 0 9
74830: PUSH
74831: LD_VAR 0 12
74835: PUSH
74836: FOR_IN
74837: IFFALSE 74910
// if GetBType ( j ) = b_bunker then
74839: LD_VAR 0 9
74843: PPUSH
74844: CALL_OW 266
74848: PUSH
74849: LD_INT 32
74851: EQUAL
74852: IFFALSE 74879
// tmp := Insert ( tmp , 1 , j ) else
74854: LD_ADDR_VAR 0 19
74858: PUSH
74859: LD_VAR 0 19
74863: PPUSH
74864: LD_INT 1
74866: PPUSH
74867: LD_VAR 0 9
74871: PPUSH
74872: CALL_OW 2
74876: ST_TO_ADDR
74877: GO 74908
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74879: LD_ADDR_VAR 0 19
74883: PUSH
74884: LD_VAR 0 19
74888: PPUSH
74889: LD_VAR 0 19
74893: PUSH
74894: LD_INT 1
74896: PLUS
74897: PPUSH
74898: LD_VAR 0 9
74902: PPUSH
74903: CALL_OW 2
74907: ST_TO_ADDR
74908: GO 74836
74910: POP
74911: POP
// if tmp then
74912: LD_VAR 0 19
74916: IFFALSE 74928
// f := tmp ;
74918: LD_ADDR_VAR 0 12
74922: PUSH
74923: LD_VAR 0 19
74927: ST_TO_ADDR
// end ; x := personel [ i ] ;
74928: LD_ADDR_VAR 0 13
74932: PUSH
74933: LD_VAR 0 6
74937: PUSH
74938: LD_VAR 0 8
74942: ARRAY
74943: ST_TO_ADDR
// if x = - 1 then
74944: LD_VAR 0 13
74948: PUSH
74949: LD_INT 1
74951: NEG
74952: EQUAL
74953: IFFALSE 75162
// begin for j in f do
74955: LD_ADDR_VAR 0 9
74959: PUSH
74960: LD_VAR 0 12
74964: PUSH
74965: FOR_IN
74966: IFFALSE 75158
// repeat InitHc ;
74968: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74972: LD_VAR 0 9
74976: PPUSH
74977: CALL_OW 266
74981: PUSH
74982: LD_INT 5
74984: EQUAL
74985: IFFALSE 75055
// begin if UnitsInside ( j ) < 3 then
74987: LD_VAR 0 9
74991: PPUSH
74992: CALL_OW 313
74996: PUSH
74997: LD_INT 3
74999: LESS
75000: IFFALSE 75036
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75002: LD_INT 0
75004: PPUSH
75005: LD_INT 5
75007: PUSH
75008: LD_INT 8
75010: PUSH
75011: LD_INT 9
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: LIST
75018: PUSH
75019: LD_VAR 0 17
75023: ARRAY
75024: PPUSH
75025: LD_VAR 0 4
75029: PPUSH
75030: CALL_OW 380
75034: GO 75053
// PrepareHuman ( false , i , skill ) ;
75036: LD_INT 0
75038: PPUSH
75039: LD_VAR 0 8
75043: PPUSH
75044: LD_VAR 0 4
75048: PPUSH
75049: CALL_OW 380
// end else
75053: GO 75072
// PrepareHuman ( false , i , skill ) ;
75055: LD_INT 0
75057: PPUSH
75058: LD_VAR 0 8
75062: PPUSH
75063: LD_VAR 0 4
75067: PPUSH
75068: CALL_OW 380
// un := CreateHuman ;
75072: LD_ADDR_VAR 0 14
75076: PUSH
75077: CALL_OW 44
75081: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75082: LD_ADDR_VAR 0 7
75086: PUSH
75087: LD_VAR 0 7
75091: PPUSH
75092: LD_INT 1
75094: PPUSH
75095: LD_VAR 0 14
75099: PPUSH
75100: CALL_OW 2
75104: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75105: LD_VAR 0 14
75109: PPUSH
75110: LD_VAR 0 9
75114: PPUSH
75115: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75119: LD_VAR 0 9
75123: PPUSH
75124: CALL_OW 313
75128: PUSH
75129: LD_INT 6
75131: EQUAL
75132: PUSH
75133: LD_VAR 0 9
75137: PPUSH
75138: CALL_OW 266
75142: PUSH
75143: LD_INT 32
75145: PUSH
75146: LD_INT 31
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: IN
75153: OR
75154: IFFALSE 74968
75156: GO 74965
75158: POP
75159: POP
// end else
75160: GO 75542
// for j = 1 to x do
75162: LD_ADDR_VAR 0 9
75166: PUSH
75167: DOUBLE
75168: LD_INT 1
75170: DEC
75171: ST_TO_ADDR
75172: LD_VAR 0 13
75176: PUSH
75177: FOR_TO
75178: IFFALSE 75540
// begin InitHc ;
75180: CALL_OW 19
// if not f then
75184: LD_VAR 0 12
75188: NOT
75189: IFFALSE 75278
// begin PrepareHuman ( false , i , skill ) ;
75191: LD_INT 0
75193: PPUSH
75194: LD_VAR 0 8
75198: PPUSH
75199: LD_VAR 0 4
75203: PPUSH
75204: CALL_OW 380
// un := CreateHuman ;
75208: LD_ADDR_VAR 0 14
75212: PUSH
75213: CALL_OW 44
75217: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75218: LD_ADDR_VAR 0 7
75222: PUSH
75223: LD_VAR 0 7
75227: PPUSH
75228: LD_INT 1
75230: PPUSH
75231: LD_VAR 0 14
75235: PPUSH
75236: CALL_OW 2
75240: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75241: LD_VAR 0 14
75245: PPUSH
75246: LD_VAR 0 1
75250: PPUSH
75251: CALL_OW 250
75255: PPUSH
75256: LD_VAR 0 1
75260: PPUSH
75261: CALL_OW 251
75265: PPUSH
75266: LD_INT 10
75268: PPUSH
75269: LD_INT 0
75271: PPUSH
75272: CALL_OW 50
// continue ;
75276: GO 75177
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75278: LD_VAR 0 12
75282: PUSH
75283: LD_INT 1
75285: ARRAY
75286: PPUSH
75287: CALL_OW 313
75291: PUSH
75292: LD_VAR 0 12
75296: PUSH
75297: LD_INT 1
75299: ARRAY
75300: PPUSH
75301: CALL_OW 266
75305: PUSH
75306: LD_INT 32
75308: PUSH
75309: LD_INT 31
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: IN
75316: AND
75317: PUSH
75318: LD_VAR 0 12
75322: PUSH
75323: LD_INT 1
75325: ARRAY
75326: PPUSH
75327: CALL_OW 313
75331: PUSH
75332: LD_INT 6
75334: EQUAL
75335: OR
75336: IFFALSE 75356
// f := Delete ( f , 1 ) ;
75338: LD_ADDR_VAR 0 12
75342: PUSH
75343: LD_VAR 0 12
75347: PPUSH
75348: LD_INT 1
75350: PPUSH
75351: CALL_OW 3
75355: ST_TO_ADDR
// if not f then
75356: LD_VAR 0 12
75360: NOT
75361: IFFALSE 75379
// begin x := x + 2 ;
75363: LD_ADDR_VAR 0 13
75367: PUSH
75368: LD_VAR 0 13
75372: PUSH
75373: LD_INT 2
75375: PLUS
75376: ST_TO_ADDR
// continue ;
75377: GO 75177
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75379: LD_VAR 0 12
75383: PUSH
75384: LD_INT 1
75386: ARRAY
75387: PPUSH
75388: CALL_OW 266
75392: PUSH
75393: LD_INT 5
75395: EQUAL
75396: IFFALSE 75470
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75398: LD_VAR 0 12
75402: PUSH
75403: LD_INT 1
75405: ARRAY
75406: PPUSH
75407: CALL_OW 313
75411: PUSH
75412: LD_INT 3
75414: LESS
75415: IFFALSE 75451
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75417: LD_INT 0
75419: PPUSH
75420: LD_INT 5
75422: PUSH
75423: LD_INT 8
75425: PUSH
75426: LD_INT 9
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: LIST
75433: PUSH
75434: LD_VAR 0 17
75438: ARRAY
75439: PPUSH
75440: LD_VAR 0 4
75444: PPUSH
75445: CALL_OW 380
75449: GO 75468
// PrepareHuman ( false , i , skill ) ;
75451: LD_INT 0
75453: PPUSH
75454: LD_VAR 0 8
75458: PPUSH
75459: LD_VAR 0 4
75463: PPUSH
75464: CALL_OW 380
// end else
75468: GO 75487
// PrepareHuman ( false , i , skill ) ;
75470: LD_INT 0
75472: PPUSH
75473: LD_VAR 0 8
75477: PPUSH
75478: LD_VAR 0 4
75482: PPUSH
75483: CALL_OW 380
// un := CreateHuman ;
75487: LD_ADDR_VAR 0 14
75491: PUSH
75492: CALL_OW 44
75496: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75497: LD_ADDR_VAR 0 7
75501: PUSH
75502: LD_VAR 0 7
75506: PPUSH
75507: LD_INT 1
75509: PPUSH
75510: LD_VAR 0 14
75514: PPUSH
75515: CALL_OW 2
75519: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75520: LD_VAR 0 14
75524: PPUSH
75525: LD_VAR 0 12
75529: PUSH
75530: LD_INT 1
75532: ARRAY
75533: PPUSH
75534: CALL_OW 52
// end ;
75538: GO 75177
75540: POP
75541: POP
// end ;
75542: GO 74479
75544: POP
75545: POP
// result := result ^ buildings ;
75546: LD_ADDR_VAR 0 7
75550: PUSH
75551: LD_VAR 0 7
75555: PUSH
75556: LD_VAR 0 18
75560: ADD
75561: ST_TO_ADDR
// end else
75562: GO 75705
// begin for i = 1 to personel do
75564: LD_ADDR_VAR 0 8
75568: PUSH
75569: DOUBLE
75570: LD_INT 1
75572: DEC
75573: ST_TO_ADDR
75574: LD_VAR 0 6
75578: PUSH
75579: FOR_TO
75580: IFFALSE 75703
// begin if i > 4 then
75582: LD_VAR 0 8
75586: PUSH
75587: LD_INT 4
75589: GREATER
75590: IFFALSE 75594
// break ;
75592: GO 75703
// x := personel [ i ] ;
75594: LD_ADDR_VAR 0 13
75598: PUSH
75599: LD_VAR 0 6
75603: PUSH
75604: LD_VAR 0 8
75608: ARRAY
75609: ST_TO_ADDR
// if x = - 1 then
75610: LD_VAR 0 13
75614: PUSH
75615: LD_INT 1
75617: NEG
75618: EQUAL
75619: IFFALSE 75623
// continue ;
75621: GO 75579
// PrepareHuman ( false , i , skill ) ;
75623: LD_INT 0
75625: PPUSH
75626: LD_VAR 0 8
75630: PPUSH
75631: LD_VAR 0 4
75635: PPUSH
75636: CALL_OW 380
// un := CreateHuman ;
75640: LD_ADDR_VAR 0 14
75644: PUSH
75645: CALL_OW 44
75649: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75650: LD_VAR 0 14
75654: PPUSH
75655: LD_VAR 0 1
75659: PPUSH
75660: CALL_OW 250
75664: PPUSH
75665: LD_VAR 0 1
75669: PPUSH
75670: CALL_OW 251
75674: PPUSH
75675: LD_INT 10
75677: PPUSH
75678: LD_INT 0
75680: PPUSH
75681: CALL_OW 50
// result := result ^ un ;
75685: LD_ADDR_VAR 0 7
75689: PUSH
75690: LD_VAR 0 7
75694: PUSH
75695: LD_VAR 0 14
75699: ADD
75700: ST_TO_ADDR
// end ;
75701: GO 75579
75703: POP
75704: POP
// end ; end ;
75705: LD_VAR 0 7
75709: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75710: LD_INT 0
75712: PPUSH
75713: PPUSH
75714: PPUSH
75715: PPUSH
75716: PPUSH
75717: PPUSH
75718: PPUSH
75719: PPUSH
75720: PPUSH
75721: PPUSH
75722: PPUSH
75723: PPUSH
75724: PPUSH
75725: PPUSH
75726: PPUSH
75727: PPUSH
// result := false ;
75728: LD_ADDR_VAR 0 3
75732: PUSH
75733: LD_INT 0
75735: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75736: LD_VAR 0 1
75740: NOT
75741: PUSH
75742: LD_VAR 0 1
75746: PPUSH
75747: CALL_OW 266
75751: PUSH
75752: LD_INT 32
75754: PUSH
75755: LD_INT 33
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: IN
75762: NOT
75763: OR
75764: IFFALSE 75768
// exit ;
75766: GO 76877
// nat := GetNation ( tower ) ;
75768: LD_ADDR_VAR 0 12
75772: PUSH
75773: LD_VAR 0 1
75777: PPUSH
75778: CALL_OW 248
75782: ST_TO_ADDR
// side := GetSide ( tower ) ;
75783: LD_ADDR_VAR 0 16
75787: PUSH
75788: LD_VAR 0 1
75792: PPUSH
75793: CALL_OW 255
75797: ST_TO_ADDR
// x := GetX ( tower ) ;
75798: LD_ADDR_VAR 0 10
75802: PUSH
75803: LD_VAR 0 1
75807: PPUSH
75808: CALL_OW 250
75812: ST_TO_ADDR
// y := GetY ( tower ) ;
75813: LD_ADDR_VAR 0 11
75817: PUSH
75818: LD_VAR 0 1
75822: PPUSH
75823: CALL_OW 251
75827: ST_TO_ADDR
// if not x or not y then
75828: LD_VAR 0 10
75832: NOT
75833: PUSH
75834: LD_VAR 0 11
75838: NOT
75839: OR
75840: IFFALSE 75844
// exit ;
75842: GO 76877
// weapon := 0 ;
75844: LD_ADDR_VAR 0 18
75848: PUSH
75849: LD_INT 0
75851: ST_TO_ADDR
// fac_list := [ ] ;
75852: LD_ADDR_VAR 0 17
75856: PUSH
75857: EMPTY
75858: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
75859: LD_ADDR_VAR 0 6
75863: PUSH
75864: LD_VAR 0 1
75868: PPUSH
75869: CALL_OW 274
75873: PPUSH
75874: LD_VAR 0 2
75878: PPUSH
75879: LD_INT 0
75881: PPUSH
75882: CALL 73448 0 3
75886: PPUSH
75887: LD_INT 30
75889: PUSH
75890: LD_INT 3
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PPUSH
75897: CALL_OW 72
75901: ST_TO_ADDR
// if not factories then
75902: LD_VAR 0 6
75906: NOT
75907: IFFALSE 75911
// exit ;
75909: GO 76877
// for i in factories do
75911: LD_ADDR_VAR 0 8
75915: PUSH
75916: LD_VAR 0 6
75920: PUSH
75921: FOR_IN
75922: IFFALSE 75947
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75924: LD_ADDR_VAR 0 17
75928: PUSH
75929: LD_VAR 0 17
75933: PUSH
75934: LD_VAR 0 8
75938: PPUSH
75939: CALL_OW 478
75943: UNION
75944: ST_TO_ADDR
75945: GO 75921
75947: POP
75948: POP
// if not fac_list then
75949: LD_VAR 0 17
75953: NOT
75954: IFFALSE 75958
// exit ;
75956: GO 76877
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75958: LD_ADDR_VAR 0 5
75962: PUSH
75963: LD_INT 4
75965: PUSH
75966: LD_INT 5
75968: PUSH
75969: LD_INT 9
75971: PUSH
75972: LD_INT 10
75974: PUSH
75975: LD_INT 6
75977: PUSH
75978: LD_INT 7
75980: PUSH
75981: LD_INT 11
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 27
75995: PUSH
75996: LD_INT 28
75998: PUSH
75999: LD_INT 26
76001: PUSH
76002: LD_INT 30
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 43
76013: PUSH
76014: LD_INT 44
76016: PUSH
76017: LD_INT 46
76019: PUSH
76020: LD_INT 45
76022: PUSH
76023: LD_INT 47
76025: PUSH
76026: LD_INT 49
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: LIST
76041: PUSH
76042: LD_VAR 0 12
76046: ARRAY
76047: ST_TO_ADDR
// list := list isect fac_list ;
76048: LD_ADDR_VAR 0 5
76052: PUSH
76053: LD_VAR 0 5
76057: PUSH
76058: LD_VAR 0 17
76062: ISECT
76063: ST_TO_ADDR
// if not list then
76064: LD_VAR 0 5
76068: NOT
76069: IFFALSE 76073
// exit ;
76071: GO 76877
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76073: LD_VAR 0 12
76077: PUSH
76078: LD_INT 3
76080: EQUAL
76081: PUSH
76082: LD_INT 49
76084: PUSH
76085: LD_VAR 0 5
76089: IN
76090: AND
76091: PUSH
76092: LD_INT 31
76094: PPUSH
76095: LD_VAR 0 16
76099: PPUSH
76100: CALL_OW 321
76104: PUSH
76105: LD_INT 2
76107: EQUAL
76108: AND
76109: IFFALSE 76169
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76111: LD_INT 22
76113: PUSH
76114: LD_VAR 0 16
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 35
76125: PUSH
76126: LD_INT 49
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 91
76135: PUSH
76136: LD_VAR 0 1
76140: PUSH
76141: LD_INT 10
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: LIST
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: LIST
76153: PPUSH
76154: CALL_OW 69
76158: NOT
76159: IFFALSE 76169
// weapon := ru_time_lapser ;
76161: LD_ADDR_VAR 0 18
76165: PUSH
76166: LD_INT 49
76168: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76169: LD_VAR 0 12
76173: PUSH
76174: LD_INT 1
76176: PUSH
76177: LD_INT 2
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: IN
76184: PUSH
76185: LD_INT 11
76187: PUSH
76188: LD_VAR 0 5
76192: IN
76193: PUSH
76194: LD_INT 30
76196: PUSH
76197: LD_VAR 0 5
76201: IN
76202: OR
76203: AND
76204: PUSH
76205: LD_INT 6
76207: PPUSH
76208: LD_VAR 0 16
76212: PPUSH
76213: CALL_OW 321
76217: PUSH
76218: LD_INT 2
76220: EQUAL
76221: AND
76222: IFFALSE 76387
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76224: LD_INT 22
76226: PUSH
76227: LD_VAR 0 16
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 2
76238: PUSH
76239: LD_INT 35
76241: PUSH
76242: LD_INT 11
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 35
76251: PUSH
76252: LD_INT 30
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 91
76266: PUSH
76267: LD_VAR 0 1
76271: PUSH
76272: LD_INT 18
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: LIST
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: LIST
76284: PPUSH
76285: CALL_OW 69
76289: NOT
76290: PUSH
76291: LD_INT 22
76293: PUSH
76294: LD_VAR 0 16
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: LD_INT 30
76308: PUSH
76309: LD_INT 32
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 30
76318: PUSH
76319: LD_INT 33
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 91
76333: PUSH
76334: LD_VAR 0 1
76338: PUSH
76339: LD_INT 12
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: LIST
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: LIST
76351: PUSH
76352: EMPTY
76353: LIST
76354: PPUSH
76355: CALL_OW 69
76359: PUSH
76360: LD_INT 2
76362: GREATER
76363: AND
76364: IFFALSE 76387
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76366: LD_ADDR_VAR 0 18
76370: PUSH
76371: LD_INT 11
76373: PUSH
76374: LD_INT 30
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_VAR 0 12
76385: ARRAY
76386: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76387: LD_VAR 0 18
76391: NOT
76392: PUSH
76393: LD_INT 40
76395: PPUSH
76396: LD_VAR 0 16
76400: PPUSH
76401: CALL_OW 321
76405: PUSH
76406: LD_INT 2
76408: EQUAL
76409: AND
76410: PUSH
76411: LD_INT 7
76413: PUSH
76414: LD_VAR 0 5
76418: IN
76419: PUSH
76420: LD_INT 28
76422: PUSH
76423: LD_VAR 0 5
76427: IN
76428: OR
76429: PUSH
76430: LD_INT 45
76432: PUSH
76433: LD_VAR 0 5
76437: IN
76438: OR
76439: AND
76440: IFFALSE 76694
// begin hex := GetHexInfo ( x , y ) ;
76442: LD_ADDR_VAR 0 4
76446: PUSH
76447: LD_VAR 0 10
76451: PPUSH
76452: LD_VAR 0 11
76456: PPUSH
76457: CALL_OW 546
76461: ST_TO_ADDR
// if hex [ 1 ] then
76462: LD_VAR 0 4
76466: PUSH
76467: LD_INT 1
76469: ARRAY
76470: IFFALSE 76474
// exit ;
76472: GO 76877
// height := hex [ 2 ] ;
76474: LD_ADDR_VAR 0 15
76478: PUSH
76479: LD_VAR 0 4
76483: PUSH
76484: LD_INT 2
76486: ARRAY
76487: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76488: LD_ADDR_VAR 0 14
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: LD_INT 2
76498: PUSH
76499: LD_INT 3
76501: PUSH
76502: LD_INT 5
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: ST_TO_ADDR
// for i in tmp do
76511: LD_ADDR_VAR 0 8
76515: PUSH
76516: LD_VAR 0 14
76520: PUSH
76521: FOR_IN
76522: IFFALSE 76692
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76524: LD_ADDR_VAR 0 9
76528: PUSH
76529: LD_VAR 0 10
76533: PPUSH
76534: LD_VAR 0 8
76538: PPUSH
76539: LD_INT 5
76541: PPUSH
76542: CALL_OW 272
76546: PUSH
76547: LD_VAR 0 11
76551: PPUSH
76552: LD_VAR 0 8
76556: PPUSH
76557: LD_INT 5
76559: PPUSH
76560: CALL_OW 273
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76569: LD_VAR 0 9
76573: PUSH
76574: LD_INT 1
76576: ARRAY
76577: PPUSH
76578: LD_VAR 0 9
76582: PUSH
76583: LD_INT 2
76585: ARRAY
76586: PPUSH
76587: CALL_OW 488
76591: IFFALSE 76690
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76593: LD_ADDR_VAR 0 4
76597: PUSH
76598: LD_VAR 0 9
76602: PUSH
76603: LD_INT 1
76605: ARRAY
76606: PPUSH
76607: LD_VAR 0 9
76611: PUSH
76612: LD_INT 2
76614: ARRAY
76615: PPUSH
76616: CALL_OW 546
76620: ST_TO_ADDR
// if hex [ 1 ] then
76621: LD_VAR 0 4
76625: PUSH
76626: LD_INT 1
76628: ARRAY
76629: IFFALSE 76633
// continue ;
76631: GO 76521
// h := hex [ 2 ] ;
76633: LD_ADDR_VAR 0 13
76637: PUSH
76638: LD_VAR 0 4
76642: PUSH
76643: LD_INT 2
76645: ARRAY
76646: ST_TO_ADDR
// if h + 7 < height then
76647: LD_VAR 0 13
76651: PUSH
76652: LD_INT 7
76654: PLUS
76655: PUSH
76656: LD_VAR 0 15
76660: LESS
76661: IFFALSE 76690
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76663: LD_ADDR_VAR 0 18
76667: PUSH
76668: LD_INT 7
76670: PUSH
76671: LD_INT 28
76673: PUSH
76674: LD_INT 45
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: LIST
76681: PUSH
76682: LD_VAR 0 12
76686: ARRAY
76687: ST_TO_ADDR
// break ;
76688: GO 76692
// end ; end ; end ;
76690: GO 76521
76692: POP
76693: POP
// end ; if not weapon then
76694: LD_VAR 0 18
76698: NOT
76699: IFFALSE 76759
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76701: LD_ADDR_VAR 0 5
76705: PUSH
76706: LD_VAR 0 5
76710: PUSH
76711: LD_INT 11
76713: PUSH
76714: LD_INT 30
76716: PUSH
76717: LD_INT 49
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: LIST
76724: DIFF
76725: ST_TO_ADDR
// if not list then
76726: LD_VAR 0 5
76730: NOT
76731: IFFALSE 76735
// exit ;
76733: GO 76877
// weapon := list [ rand ( 1 , list ) ] ;
76735: LD_ADDR_VAR 0 18
76739: PUSH
76740: LD_VAR 0 5
76744: PUSH
76745: LD_INT 1
76747: PPUSH
76748: LD_VAR 0 5
76752: PPUSH
76753: CALL_OW 12
76757: ARRAY
76758: ST_TO_ADDR
// end ; if weapon then
76759: LD_VAR 0 18
76763: IFFALSE 76877
// begin tmp := CostOfWeapon ( weapon ) ;
76765: LD_ADDR_VAR 0 14
76769: PUSH
76770: LD_VAR 0 18
76774: PPUSH
76775: CALL_OW 451
76779: ST_TO_ADDR
// j := GetBase ( tower ) ;
76780: LD_ADDR_VAR 0 9
76784: PUSH
76785: LD_VAR 0 1
76789: PPUSH
76790: CALL_OW 274
76794: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76795: LD_VAR 0 9
76799: PPUSH
76800: LD_INT 1
76802: PPUSH
76803: CALL_OW 275
76807: PUSH
76808: LD_VAR 0 14
76812: PUSH
76813: LD_INT 1
76815: ARRAY
76816: GREATEREQUAL
76817: PUSH
76818: LD_VAR 0 9
76822: PPUSH
76823: LD_INT 2
76825: PPUSH
76826: CALL_OW 275
76830: PUSH
76831: LD_VAR 0 14
76835: PUSH
76836: LD_INT 2
76838: ARRAY
76839: GREATEREQUAL
76840: AND
76841: PUSH
76842: LD_VAR 0 9
76846: PPUSH
76847: LD_INT 3
76849: PPUSH
76850: CALL_OW 275
76854: PUSH
76855: LD_VAR 0 14
76859: PUSH
76860: LD_INT 3
76862: ARRAY
76863: GREATEREQUAL
76864: AND
76865: IFFALSE 76877
// result := weapon ;
76867: LD_ADDR_VAR 0 3
76871: PUSH
76872: LD_VAR 0 18
76876: ST_TO_ADDR
// end ; end ;
76877: LD_VAR 0 3
76881: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76882: LD_INT 0
76884: PPUSH
76885: PPUSH
// result := true ;
76886: LD_ADDR_VAR 0 3
76890: PUSH
76891: LD_INT 1
76893: ST_TO_ADDR
// if array1 = array2 then
76894: LD_VAR 0 1
76898: PUSH
76899: LD_VAR 0 2
76903: EQUAL
76904: IFFALSE 76964
// begin for i = 1 to array1 do
76906: LD_ADDR_VAR 0 4
76910: PUSH
76911: DOUBLE
76912: LD_INT 1
76914: DEC
76915: ST_TO_ADDR
76916: LD_VAR 0 1
76920: PUSH
76921: FOR_TO
76922: IFFALSE 76960
// if array1 [ i ] <> array2 [ i ] then
76924: LD_VAR 0 1
76928: PUSH
76929: LD_VAR 0 4
76933: ARRAY
76934: PUSH
76935: LD_VAR 0 2
76939: PUSH
76940: LD_VAR 0 4
76944: ARRAY
76945: NONEQUAL
76946: IFFALSE 76958
// begin result := false ;
76948: LD_ADDR_VAR 0 3
76952: PUSH
76953: LD_INT 0
76955: ST_TO_ADDR
// break ;
76956: GO 76960
// end ;
76958: GO 76921
76960: POP
76961: POP
// end else
76962: GO 76972
// result := false ;
76964: LD_ADDR_VAR 0 3
76968: PUSH
76969: LD_INT 0
76971: ST_TO_ADDR
// end ;
76972: LD_VAR 0 3
76976: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
76977: LD_INT 0
76979: PPUSH
76980: PPUSH
// if not array1 or not array2 then
76981: LD_VAR 0 1
76985: NOT
76986: PUSH
76987: LD_VAR 0 2
76991: NOT
76992: OR
76993: IFFALSE 76997
// exit ;
76995: GO 77061
// result := true ;
76997: LD_ADDR_VAR 0 3
77001: PUSH
77002: LD_INT 1
77004: ST_TO_ADDR
// for i = 1 to array1 do
77005: LD_ADDR_VAR 0 4
77009: PUSH
77010: DOUBLE
77011: LD_INT 1
77013: DEC
77014: ST_TO_ADDR
77015: LD_VAR 0 1
77019: PUSH
77020: FOR_TO
77021: IFFALSE 77059
// if array1 [ i ] <> array2 [ i ] then
77023: LD_VAR 0 1
77027: PUSH
77028: LD_VAR 0 4
77032: ARRAY
77033: PUSH
77034: LD_VAR 0 2
77038: PUSH
77039: LD_VAR 0 4
77043: ARRAY
77044: NONEQUAL
77045: IFFALSE 77057
// begin result := false ;
77047: LD_ADDR_VAR 0 3
77051: PUSH
77052: LD_INT 0
77054: ST_TO_ADDR
// break ;
77055: GO 77059
// end ;
77057: GO 77020
77059: POP
77060: POP
// end ;
77061: LD_VAR 0 3
77065: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77066: LD_INT 0
77068: PPUSH
77069: PPUSH
77070: PPUSH
// pom := GetBase ( fac ) ;
77071: LD_ADDR_VAR 0 5
77075: PUSH
77076: LD_VAR 0 1
77080: PPUSH
77081: CALL_OW 274
77085: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77086: LD_ADDR_VAR 0 4
77090: PUSH
77091: LD_VAR 0 2
77095: PUSH
77096: LD_INT 1
77098: ARRAY
77099: PPUSH
77100: LD_VAR 0 2
77104: PUSH
77105: LD_INT 2
77107: ARRAY
77108: PPUSH
77109: LD_VAR 0 2
77113: PUSH
77114: LD_INT 3
77116: ARRAY
77117: PPUSH
77118: LD_VAR 0 2
77122: PUSH
77123: LD_INT 4
77125: ARRAY
77126: PPUSH
77127: CALL_OW 449
77131: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77132: LD_ADDR_VAR 0 3
77136: PUSH
77137: LD_VAR 0 5
77141: PPUSH
77142: LD_INT 1
77144: PPUSH
77145: CALL_OW 275
77149: PUSH
77150: LD_VAR 0 4
77154: PUSH
77155: LD_INT 1
77157: ARRAY
77158: GREATEREQUAL
77159: PUSH
77160: LD_VAR 0 5
77164: PPUSH
77165: LD_INT 2
77167: PPUSH
77168: CALL_OW 275
77172: PUSH
77173: LD_VAR 0 4
77177: PUSH
77178: LD_INT 2
77180: ARRAY
77181: GREATEREQUAL
77182: AND
77183: PUSH
77184: LD_VAR 0 5
77188: PPUSH
77189: LD_INT 3
77191: PPUSH
77192: CALL_OW 275
77196: PUSH
77197: LD_VAR 0 4
77201: PUSH
77202: LD_INT 3
77204: ARRAY
77205: GREATEREQUAL
77206: AND
77207: ST_TO_ADDR
// end ;
77208: LD_VAR 0 3
77212: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77213: LD_INT 0
77215: PPUSH
77216: PPUSH
77217: PPUSH
77218: PPUSH
// pom := GetBase ( building ) ;
77219: LD_ADDR_VAR 0 3
77223: PUSH
77224: LD_VAR 0 1
77228: PPUSH
77229: CALL_OW 274
77233: ST_TO_ADDR
// if not pom then
77234: LD_VAR 0 3
77238: NOT
77239: IFFALSE 77243
// exit ;
77241: GO 77413
// btype := GetBType ( building ) ;
77243: LD_ADDR_VAR 0 5
77247: PUSH
77248: LD_VAR 0 1
77252: PPUSH
77253: CALL_OW 266
77257: ST_TO_ADDR
// if btype = b_armoury then
77258: LD_VAR 0 5
77262: PUSH
77263: LD_INT 4
77265: EQUAL
77266: IFFALSE 77276
// btype := b_barracks ;
77268: LD_ADDR_VAR 0 5
77272: PUSH
77273: LD_INT 5
77275: ST_TO_ADDR
// if btype = b_depot then
77276: LD_VAR 0 5
77280: PUSH
77281: LD_INT 0
77283: EQUAL
77284: IFFALSE 77294
// btype := b_warehouse ;
77286: LD_ADDR_VAR 0 5
77290: PUSH
77291: LD_INT 1
77293: ST_TO_ADDR
// if btype = b_workshop then
77294: LD_VAR 0 5
77298: PUSH
77299: LD_INT 2
77301: EQUAL
77302: IFFALSE 77312
// btype := b_factory ;
77304: LD_ADDR_VAR 0 5
77308: PUSH
77309: LD_INT 3
77311: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77312: LD_ADDR_VAR 0 4
77316: PUSH
77317: LD_VAR 0 5
77321: PPUSH
77322: LD_VAR 0 1
77326: PPUSH
77327: CALL_OW 248
77331: PPUSH
77332: CALL_OW 450
77336: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77337: LD_ADDR_VAR 0 2
77341: PUSH
77342: LD_VAR 0 3
77346: PPUSH
77347: LD_INT 1
77349: PPUSH
77350: CALL_OW 275
77354: PUSH
77355: LD_VAR 0 4
77359: PUSH
77360: LD_INT 1
77362: ARRAY
77363: GREATEREQUAL
77364: PUSH
77365: LD_VAR 0 3
77369: PPUSH
77370: LD_INT 2
77372: PPUSH
77373: CALL_OW 275
77377: PUSH
77378: LD_VAR 0 4
77382: PUSH
77383: LD_INT 2
77385: ARRAY
77386: GREATEREQUAL
77387: AND
77388: PUSH
77389: LD_VAR 0 3
77393: PPUSH
77394: LD_INT 3
77396: PPUSH
77397: CALL_OW 275
77401: PUSH
77402: LD_VAR 0 4
77406: PUSH
77407: LD_INT 3
77409: ARRAY
77410: GREATEREQUAL
77411: AND
77412: ST_TO_ADDR
// end ;
77413: LD_VAR 0 2
77417: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77418: LD_INT 0
77420: PPUSH
77421: PPUSH
77422: PPUSH
// pom := GetBase ( building ) ;
77423: LD_ADDR_VAR 0 4
77427: PUSH
77428: LD_VAR 0 1
77432: PPUSH
77433: CALL_OW 274
77437: ST_TO_ADDR
// if not pom then
77438: LD_VAR 0 4
77442: NOT
77443: IFFALSE 77447
// exit ;
77445: GO 77548
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77447: LD_ADDR_VAR 0 5
77451: PUSH
77452: LD_VAR 0 2
77456: PPUSH
77457: LD_VAR 0 1
77461: PPUSH
77462: CALL_OW 248
77466: PPUSH
77467: CALL_OW 450
77471: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77472: LD_ADDR_VAR 0 3
77476: PUSH
77477: LD_VAR 0 4
77481: PPUSH
77482: LD_INT 1
77484: PPUSH
77485: CALL_OW 275
77489: PUSH
77490: LD_VAR 0 5
77494: PUSH
77495: LD_INT 1
77497: ARRAY
77498: GREATEREQUAL
77499: PUSH
77500: LD_VAR 0 4
77504: PPUSH
77505: LD_INT 2
77507: PPUSH
77508: CALL_OW 275
77512: PUSH
77513: LD_VAR 0 5
77517: PUSH
77518: LD_INT 2
77520: ARRAY
77521: GREATEREQUAL
77522: AND
77523: PUSH
77524: LD_VAR 0 4
77528: PPUSH
77529: LD_INT 3
77531: PPUSH
77532: CALL_OW 275
77536: PUSH
77537: LD_VAR 0 5
77541: PUSH
77542: LD_INT 3
77544: ARRAY
77545: GREATEREQUAL
77546: AND
77547: ST_TO_ADDR
// end ;
77548: LD_VAR 0 3
77552: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77553: LD_INT 0
77555: PPUSH
77556: PPUSH
77557: PPUSH
77558: PPUSH
77559: PPUSH
77560: PPUSH
77561: PPUSH
77562: PPUSH
77563: PPUSH
77564: PPUSH
77565: PPUSH
// result := false ;
77566: LD_ADDR_VAR 0 8
77570: PUSH
77571: LD_INT 0
77573: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77574: LD_VAR 0 5
77578: NOT
77579: PUSH
77580: LD_VAR 0 1
77584: NOT
77585: OR
77586: PUSH
77587: LD_VAR 0 2
77591: NOT
77592: OR
77593: PUSH
77594: LD_VAR 0 3
77598: NOT
77599: OR
77600: IFFALSE 77604
// exit ;
77602: GO 78418
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77604: LD_ADDR_VAR 0 14
77608: PUSH
77609: LD_VAR 0 1
77613: PPUSH
77614: LD_VAR 0 2
77618: PPUSH
77619: LD_VAR 0 3
77623: PPUSH
77624: LD_VAR 0 4
77628: PPUSH
77629: LD_VAR 0 5
77633: PUSH
77634: LD_INT 1
77636: ARRAY
77637: PPUSH
77638: CALL_OW 248
77642: PPUSH
77643: LD_INT 0
77645: PPUSH
77646: CALL 79655 0 6
77650: ST_TO_ADDR
// if not hexes then
77651: LD_VAR 0 14
77655: NOT
77656: IFFALSE 77660
// exit ;
77658: GO 78418
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77660: LD_ADDR_VAR 0 17
77664: PUSH
77665: LD_VAR 0 5
77669: PPUSH
77670: LD_INT 22
77672: PUSH
77673: LD_VAR 0 13
77677: PPUSH
77678: CALL_OW 255
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 2
77689: PUSH
77690: LD_INT 30
77692: PUSH
77693: LD_INT 0
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 30
77702: PUSH
77703: LD_INT 1
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: LIST
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PPUSH
77719: CALL_OW 72
77723: ST_TO_ADDR
// for i = 1 to hexes do
77724: LD_ADDR_VAR 0 9
77728: PUSH
77729: DOUBLE
77730: LD_INT 1
77732: DEC
77733: ST_TO_ADDR
77734: LD_VAR 0 14
77738: PUSH
77739: FOR_TO
77740: IFFALSE 78416
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77742: LD_ADDR_VAR 0 13
77746: PUSH
77747: LD_VAR 0 14
77751: PUSH
77752: LD_VAR 0 9
77756: ARRAY
77757: PUSH
77758: LD_INT 1
77760: ARRAY
77761: PPUSH
77762: LD_VAR 0 14
77766: PUSH
77767: LD_VAR 0 9
77771: ARRAY
77772: PUSH
77773: LD_INT 2
77775: ARRAY
77776: PPUSH
77777: CALL_OW 428
77781: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77782: LD_VAR 0 14
77786: PUSH
77787: LD_VAR 0 9
77791: ARRAY
77792: PUSH
77793: LD_INT 1
77795: ARRAY
77796: PPUSH
77797: LD_VAR 0 14
77801: PUSH
77802: LD_VAR 0 9
77806: ARRAY
77807: PUSH
77808: LD_INT 2
77810: ARRAY
77811: PPUSH
77812: CALL_OW 351
77816: PUSH
77817: LD_VAR 0 14
77821: PUSH
77822: LD_VAR 0 9
77826: ARRAY
77827: PUSH
77828: LD_INT 1
77830: ARRAY
77831: PPUSH
77832: LD_VAR 0 14
77836: PUSH
77837: LD_VAR 0 9
77841: ARRAY
77842: PUSH
77843: LD_INT 2
77845: ARRAY
77846: PPUSH
77847: CALL_OW 488
77851: NOT
77852: OR
77853: PUSH
77854: LD_VAR 0 13
77858: PPUSH
77859: CALL_OW 247
77863: PUSH
77864: LD_INT 3
77866: EQUAL
77867: OR
77868: IFFALSE 77874
// exit ;
77870: POP
77871: POP
77872: GO 78418
// if not tmp then
77874: LD_VAR 0 13
77878: NOT
77879: IFFALSE 77883
// continue ;
77881: GO 77739
// result := true ;
77883: LD_ADDR_VAR 0 8
77887: PUSH
77888: LD_INT 1
77890: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
77891: LD_VAR 0 6
77895: PUSH
77896: LD_VAR 0 13
77900: PPUSH
77901: CALL_OW 247
77905: PUSH
77906: LD_INT 2
77908: EQUAL
77909: AND
77910: PUSH
77911: LD_VAR 0 13
77915: PPUSH
77916: CALL_OW 263
77920: PUSH
77921: LD_INT 1
77923: EQUAL
77924: AND
77925: IFFALSE 78089
// begin if IsDrivenBy ( tmp ) then
77927: LD_VAR 0 13
77931: PPUSH
77932: CALL_OW 311
77936: IFFALSE 77940
// continue ;
77938: GO 77739
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
77940: LD_VAR 0 6
77944: PPUSH
77945: LD_INT 3
77947: PUSH
77948: LD_INT 60
77950: PUSH
77951: EMPTY
77952: LIST
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 3
77960: PUSH
77961: LD_INT 55
77963: PUSH
77964: EMPTY
77965: LIST
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PPUSH
77975: CALL_OW 72
77979: IFFALSE 78087
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
77981: LD_ADDR_VAR 0 18
77985: PUSH
77986: LD_VAR 0 6
77990: PPUSH
77991: LD_INT 3
77993: PUSH
77994: LD_INT 60
77996: PUSH
77997: EMPTY
77998: LIST
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 3
78006: PUSH
78007: LD_INT 55
78009: PUSH
78010: EMPTY
78011: LIST
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PPUSH
78021: CALL_OW 72
78025: PUSH
78026: LD_INT 1
78028: ARRAY
78029: ST_TO_ADDR
// if IsInUnit ( driver ) then
78030: LD_VAR 0 18
78034: PPUSH
78035: CALL_OW 310
78039: IFFALSE 78050
// ComExit ( driver ) ;
78041: LD_VAR 0 18
78045: PPUSH
78046: CALL 102839 0 1
// AddComEnterUnit ( driver , tmp ) ;
78050: LD_VAR 0 18
78054: PPUSH
78055: LD_VAR 0 13
78059: PPUSH
78060: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78064: LD_VAR 0 18
78068: PPUSH
78069: LD_VAR 0 7
78073: PPUSH
78074: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78078: LD_VAR 0 18
78082: PPUSH
78083: CALL_OW 181
// end ; continue ;
78087: GO 77739
// end ; if not cleaners or not tmp in cleaners then
78089: LD_VAR 0 6
78093: NOT
78094: PUSH
78095: LD_VAR 0 13
78099: PUSH
78100: LD_VAR 0 6
78104: IN
78105: NOT
78106: OR
78107: IFFALSE 78414
// begin if dep then
78109: LD_VAR 0 17
78113: IFFALSE 78249
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78115: LD_ADDR_VAR 0 16
78119: PUSH
78120: LD_VAR 0 17
78124: PUSH
78125: LD_INT 1
78127: ARRAY
78128: PPUSH
78129: CALL_OW 250
78133: PPUSH
78134: LD_VAR 0 17
78138: PUSH
78139: LD_INT 1
78141: ARRAY
78142: PPUSH
78143: CALL_OW 254
78147: PPUSH
78148: LD_INT 5
78150: PPUSH
78151: CALL_OW 272
78155: PUSH
78156: LD_VAR 0 17
78160: PUSH
78161: LD_INT 1
78163: ARRAY
78164: PPUSH
78165: CALL_OW 251
78169: PPUSH
78170: LD_VAR 0 17
78174: PUSH
78175: LD_INT 1
78177: ARRAY
78178: PPUSH
78179: CALL_OW 254
78183: PPUSH
78184: LD_INT 5
78186: PPUSH
78187: CALL_OW 273
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78196: LD_VAR 0 16
78200: PUSH
78201: LD_INT 1
78203: ARRAY
78204: PPUSH
78205: LD_VAR 0 16
78209: PUSH
78210: LD_INT 2
78212: ARRAY
78213: PPUSH
78214: CALL_OW 488
78218: IFFALSE 78249
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78220: LD_VAR 0 13
78224: PPUSH
78225: LD_VAR 0 16
78229: PUSH
78230: LD_INT 1
78232: ARRAY
78233: PPUSH
78234: LD_VAR 0 16
78238: PUSH
78239: LD_INT 2
78241: ARRAY
78242: PPUSH
78243: CALL_OW 111
// continue ;
78247: GO 77739
// end ; end ; r := GetDir ( tmp ) ;
78249: LD_ADDR_VAR 0 15
78253: PUSH
78254: LD_VAR 0 13
78258: PPUSH
78259: CALL_OW 254
78263: ST_TO_ADDR
// if r = 5 then
78264: LD_VAR 0 15
78268: PUSH
78269: LD_INT 5
78271: EQUAL
78272: IFFALSE 78282
// r := 0 ;
78274: LD_ADDR_VAR 0 15
78278: PUSH
78279: LD_INT 0
78281: ST_TO_ADDR
// for j = r to 5 do
78282: LD_ADDR_VAR 0 10
78286: PUSH
78287: DOUBLE
78288: LD_VAR 0 15
78292: DEC
78293: ST_TO_ADDR
78294: LD_INT 5
78296: PUSH
78297: FOR_TO
78298: IFFALSE 78412
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78300: LD_ADDR_VAR 0 11
78304: PUSH
78305: LD_VAR 0 13
78309: PPUSH
78310: CALL_OW 250
78314: PPUSH
78315: LD_VAR 0 10
78319: PPUSH
78320: LD_INT 2
78322: PPUSH
78323: CALL_OW 272
78327: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78328: LD_ADDR_VAR 0 12
78332: PUSH
78333: LD_VAR 0 13
78337: PPUSH
78338: CALL_OW 251
78342: PPUSH
78343: LD_VAR 0 10
78347: PPUSH
78348: LD_INT 2
78350: PPUSH
78351: CALL_OW 273
78355: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78356: LD_VAR 0 11
78360: PPUSH
78361: LD_VAR 0 12
78365: PPUSH
78366: CALL_OW 488
78370: PUSH
78371: LD_VAR 0 11
78375: PPUSH
78376: LD_VAR 0 12
78380: PPUSH
78381: CALL_OW 428
78385: NOT
78386: AND
78387: IFFALSE 78410
// begin ComMoveXY ( tmp , _x , _y ) ;
78389: LD_VAR 0 13
78393: PPUSH
78394: LD_VAR 0 11
78398: PPUSH
78399: LD_VAR 0 12
78403: PPUSH
78404: CALL_OW 111
// break ;
78408: GO 78412
// end ; end ;
78410: GO 78297
78412: POP
78413: POP
// end ; end ;
78414: GO 77739
78416: POP
78417: POP
// end ;
78418: LD_VAR 0 8
78422: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78423: LD_INT 0
78425: PPUSH
// result := true ;
78426: LD_ADDR_VAR 0 3
78430: PUSH
78431: LD_INT 1
78433: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78434: LD_VAR 0 2
78438: PUSH
78439: LD_INT 24
78441: DOUBLE
78442: EQUAL
78443: IFTRUE 78453
78445: LD_INT 33
78447: DOUBLE
78448: EQUAL
78449: IFTRUE 78453
78451: GO 78478
78453: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78454: LD_ADDR_VAR 0 3
78458: PUSH
78459: LD_INT 32
78461: PPUSH
78462: LD_VAR 0 1
78466: PPUSH
78467: CALL_OW 321
78471: PUSH
78472: LD_INT 2
78474: EQUAL
78475: ST_TO_ADDR
78476: GO 78798
78478: LD_INT 20
78480: DOUBLE
78481: EQUAL
78482: IFTRUE 78486
78484: GO 78511
78486: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78487: LD_ADDR_VAR 0 3
78491: PUSH
78492: LD_INT 6
78494: PPUSH
78495: LD_VAR 0 1
78499: PPUSH
78500: CALL_OW 321
78504: PUSH
78505: LD_INT 2
78507: EQUAL
78508: ST_TO_ADDR
78509: GO 78798
78511: LD_INT 22
78513: DOUBLE
78514: EQUAL
78515: IFTRUE 78525
78517: LD_INT 36
78519: DOUBLE
78520: EQUAL
78521: IFTRUE 78525
78523: GO 78550
78525: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78526: LD_ADDR_VAR 0 3
78530: PUSH
78531: LD_INT 15
78533: PPUSH
78534: LD_VAR 0 1
78538: PPUSH
78539: CALL_OW 321
78543: PUSH
78544: LD_INT 2
78546: EQUAL
78547: ST_TO_ADDR
78548: GO 78798
78550: LD_INT 30
78552: DOUBLE
78553: EQUAL
78554: IFTRUE 78558
78556: GO 78583
78558: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78559: LD_ADDR_VAR 0 3
78563: PUSH
78564: LD_INT 20
78566: PPUSH
78567: LD_VAR 0 1
78571: PPUSH
78572: CALL_OW 321
78576: PUSH
78577: LD_INT 2
78579: EQUAL
78580: ST_TO_ADDR
78581: GO 78798
78583: LD_INT 28
78585: DOUBLE
78586: EQUAL
78587: IFTRUE 78597
78589: LD_INT 21
78591: DOUBLE
78592: EQUAL
78593: IFTRUE 78597
78595: GO 78622
78597: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78598: LD_ADDR_VAR 0 3
78602: PUSH
78603: LD_INT 21
78605: PPUSH
78606: LD_VAR 0 1
78610: PPUSH
78611: CALL_OW 321
78615: PUSH
78616: LD_INT 2
78618: EQUAL
78619: ST_TO_ADDR
78620: GO 78798
78622: LD_INT 16
78624: DOUBLE
78625: EQUAL
78626: IFTRUE 78630
78628: GO 78657
78630: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78631: LD_ADDR_VAR 0 3
78635: PUSH
78636: LD_EXP 107
78640: PPUSH
78641: LD_VAR 0 1
78645: PPUSH
78646: CALL_OW 321
78650: PUSH
78651: LD_INT 2
78653: EQUAL
78654: ST_TO_ADDR
78655: GO 78798
78657: LD_INT 19
78659: DOUBLE
78660: EQUAL
78661: IFTRUE 78671
78663: LD_INT 23
78665: DOUBLE
78666: EQUAL
78667: IFTRUE 78671
78669: GO 78698
78671: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78672: LD_ADDR_VAR 0 3
78676: PUSH
78677: LD_EXP 106
78681: PPUSH
78682: LD_VAR 0 1
78686: PPUSH
78687: CALL_OW 321
78691: PUSH
78692: LD_INT 2
78694: EQUAL
78695: ST_TO_ADDR
78696: GO 78798
78698: LD_INT 17
78700: DOUBLE
78701: EQUAL
78702: IFTRUE 78706
78704: GO 78731
78706: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78707: LD_ADDR_VAR 0 3
78711: PUSH
78712: LD_INT 39
78714: PPUSH
78715: LD_VAR 0 1
78719: PPUSH
78720: CALL_OW 321
78724: PUSH
78725: LD_INT 2
78727: EQUAL
78728: ST_TO_ADDR
78729: GO 78798
78731: LD_INT 18
78733: DOUBLE
78734: EQUAL
78735: IFTRUE 78739
78737: GO 78764
78739: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78740: LD_ADDR_VAR 0 3
78744: PUSH
78745: LD_INT 40
78747: PPUSH
78748: LD_VAR 0 1
78752: PPUSH
78753: CALL_OW 321
78757: PUSH
78758: LD_INT 2
78760: EQUAL
78761: ST_TO_ADDR
78762: GO 78798
78764: LD_INT 27
78766: DOUBLE
78767: EQUAL
78768: IFTRUE 78772
78770: GO 78797
78772: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78773: LD_ADDR_VAR 0 3
78777: PUSH
78778: LD_INT 35
78780: PPUSH
78781: LD_VAR 0 1
78785: PPUSH
78786: CALL_OW 321
78790: PUSH
78791: LD_INT 2
78793: EQUAL
78794: ST_TO_ADDR
78795: GO 78798
78797: POP
// end ;
78798: LD_VAR 0 3
78802: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78803: LD_INT 0
78805: PPUSH
78806: PPUSH
78807: PPUSH
78808: PPUSH
78809: PPUSH
78810: PPUSH
78811: PPUSH
78812: PPUSH
78813: PPUSH
78814: PPUSH
78815: PPUSH
// result := false ;
78816: LD_ADDR_VAR 0 6
78820: PUSH
78821: LD_INT 0
78823: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78824: LD_VAR 0 1
78828: NOT
78829: PUSH
78830: LD_VAR 0 1
78834: PPUSH
78835: CALL_OW 266
78839: PUSH
78840: LD_INT 0
78842: PUSH
78843: LD_INT 1
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: IN
78850: NOT
78851: OR
78852: PUSH
78853: LD_VAR 0 2
78857: NOT
78858: OR
78859: PUSH
78860: LD_VAR 0 5
78864: PUSH
78865: LD_INT 0
78867: PUSH
78868: LD_INT 1
78870: PUSH
78871: LD_INT 2
78873: PUSH
78874: LD_INT 3
78876: PUSH
78877: LD_INT 4
78879: PUSH
78880: LD_INT 5
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: IN
78891: NOT
78892: OR
78893: PUSH
78894: LD_VAR 0 3
78898: PPUSH
78899: LD_VAR 0 4
78903: PPUSH
78904: CALL_OW 488
78908: NOT
78909: OR
78910: IFFALSE 78914
// exit ;
78912: GO 79650
// side := GetSide ( depot ) ;
78914: LD_ADDR_VAR 0 9
78918: PUSH
78919: LD_VAR 0 1
78923: PPUSH
78924: CALL_OW 255
78928: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
78929: LD_VAR 0 9
78933: PPUSH
78934: LD_VAR 0 2
78938: PPUSH
78939: CALL 78423 0 2
78943: NOT
78944: IFFALSE 78948
// exit ;
78946: GO 79650
// pom := GetBase ( depot ) ;
78948: LD_ADDR_VAR 0 10
78952: PUSH
78953: LD_VAR 0 1
78957: PPUSH
78958: CALL_OW 274
78962: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78963: LD_ADDR_VAR 0 11
78967: PUSH
78968: LD_VAR 0 2
78972: PPUSH
78973: LD_VAR 0 1
78977: PPUSH
78978: CALL_OW 248
78982: PPUSH
78983: CALL_OW 450
78987: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78988: LD_VAR 0 10
78992: PPUSH
78993: LD_INT 1
78995: PPUSH
78996: CALL_OW 275
79000: PUSH
79001: LD_VAR 0 11
79005: PUSH
79006: LD_INT 1
79008: ARRAY
79009: GREATEREQUAL
79010: PUSH
79011: LD_VAR 0 10
79015: PPUSH
79016: LD_INT 2
79018: PPUSH
79019: CALL_OW 275
79023: PUSH
79024: LD_VAR 0 11
79028: PUSH
79029: LD_INT 2
79031: ARRAY
79032: GREATEREQUAL
79033: AND
79034: PUSH
79035: LD_VAR 0 10
79039: PPUSH
79040: LD_INT 3
79042: PPUSH
79043: CALL_OW 275
79047: PUSH
79048: LD_VAR 0 11
79052: PUSH
79053: LD_INT 3
79055: ARRAY
79056: GREATEREQUAL
79057: AND
79058: NOT
79059: IFFALSE 79063
// exit ;
79061: GO 79650
// if GetBType ( depot ) = b_depot then
79063: LD_VAR 0 1
79067: PPUSH
79068: CALL_OW 266
79072: PUSH
79073: LD_INT 0
79075: EQUAL
79076: IFFALSE 79088
// dist := 28 else
79078: LD_ADDR_VAR 0 14
79082: PUSH
79083: LD_INT 28
79085: ST_TO_ADDR
79086: GO 79096
// dist := 36 ;
79088: LD_ADDR_VAR 0 14
79092: PUSH
79093: LD_INT 36
79095: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79096: LD_VAR 0 1
79100: PPUSH
79101: LD_VAR 0 3
79105: PPUSH
79106: LD_VAR 0 4
79110: PPUSH
79111: CALL_OW 297
79115: PUSH
79116: LD_VAR 0 14
79120: GREATER
79121: IFFALSE 79125
// exit ;
79123: GO 79650
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79125: LD_ADDR_VAR 0 12
79129: PUSH
79130: LD_VAR 0 2
79134: PPUSH
79135: LD_VAR 0 3
79139: PPUSH
79140: LD_VAR 0 4
79144: PPUSH
79145: LD_VAR 0 5
79149: PPUSH
79150: LD_VAR 0 1
79154: PPUSH
79155: CALL_OW 248
79159: PPUSH
79160: LD_INT 0
79162: PPUSH
79163: CALL 79655 0 6
79167: ST_TO_ADDR
// if not hexes then
79168: LD_VAR 0 12
79172: NOT
79173: IFFALSE 79177
// exit ;
79175: GO 79650
// hex := GetHexInfo ( x , y ) ;
79177: LD_ADDR_VAR 0 15
79181: PUSH
79182: LD_VAR 0 3
79186: PPUSH
79187: LD_VAR 0 4
79191: PPUSH
79192: CALL_OW 546
79196: ST_TO_ADDR
// if hex [ 1 ] then
79197: LD_VAR 0 15
79201: PUSH
79202: LD_INT 1
79204: ARRAY
79205: IFFALSE 79209
// exit ;
79207: GO 79650
// height := hex [ 2 ] ;
79209: LD_ADDR_VAR 0 13
79213: PUSH
79214: LD_VAR 0 15
79218: PUSH
79219: LD_INT 2
79221: ARRAY
79222: ST_TO_ADDR
// for i = 1 to hexes do
79223: LD_ADDR_VAR 0 7
79227: PUSH
79228: DOUBLE
79229: LD_INT 1
79231: DEC
79232: ST_TO_ADDR
79233: LD_VAR 0 12
79237: PUSH
79238: FOR_TO
79239: IFFALSE 79569
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79241: LD_VAR 0 12
79245: PUSH
79246: LD_VAR 0 7
79250: ARRAY
79251: PUSH
79252: LD_INT 1
79254: ARRAY
79255: PPUSH
79256: LD_VAR 0 12
79260: PUSH
79261: LD_VAR 0 7
79265: ARRAY
79266: PUSH
79267: LD_INT 2
79269: ARRAY
79270: PPUSH
79271: CALL_OW 488
79275: NOT
79276: PUSH
79277: LD_VAR 0 12
79281: PUSH
79282: LD_VAR 0 7
79286: ARRAY
79287: PUSH
79288: LD_INT 1
79290: ARRAY
79291: PPUSH
79292: LD_VAR 0 12
79296: PUSH
79297: LD_VAR 0 7
79301: ARRAY
79302: PUSH
79303: LD_INT 2
79305: ARRAY
79306: PPUSH
79307: CALL_OW 428
79311: PUSH
79312: LD_INT 0
79314: GREATER
79315: OR
79316: PUSH
79317: LD_VAR 0 12
79321: PUSH
79322: LD_VAR 0 7
79326: ARRAY
79327: PUSH
79328: LD_INT 1
79330: ARRAY
79331: PPUSH
79332: LD_VAR 0 12
79336: PUSH
79337: LD_VAR 0 7
79341: ARRAY
79342: PUSH
79343: LD_INT 2
79345: ARRAY
79346: PPUSH
79347: CALL_OW 351
79351: OR
79352: IFFALSE 79358
// exit ;
79354: POP
79355: POP
79356: GO 79650
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79358: LD_ADDR_VAR 0 8
79362: PUSH
79363: LD_VAR 0 12
79367: PUSH
79368: LD_VAR 0 7
79372: ARRAY
79373: PUSH
79374: LD_INT 1
79376: ARRAY
79377: PPUSH
79378: LD_VAR 0 12
79382: PUSH
79383: LD_VAR 0 7
79387: ARRAY
79388: PUSH
79389: LD_INT 2
79391: ARRAY
79392: PPUSH
79393: CALL_OW 546
79397: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79398: LD_VAR 0 8
79402: PUSH
79403: LD_INT 1
79405: ARRAY
79406: PUSH
79407: LD_VAR 0 8
79411: PUSH
79412: LD_INT 2
79414: ARRAY
79415: PUSH
79416: LD_VAR 0 13
79420: PUSH
79421: LD_INT 2
79423: PLUS
79424: GREATER
79425: OR
79426: PUSH
79427: LD_VAR 0 8
79431: PUSH
79432: LD_INT 2
79434: ARRAY
79435: PUSH
79436: LD_VAR 0 13
79440: PUSH
79441: LD_INT 2
79443: MINUS
79444: LESS
79445: OR
79446: PUSH
79447: LD_VAR 0 8
79451: PUSH
79452: LD_INT 3
79454: ARRAY
79455: PUSH
79456: LD_INT 0
79458: PUSH
79459: LD_INT 8
79461: PUSH
79462: LD_INT 9
79464: PUSH
79465: LD_INT 10
79467: PUSH
79468: LD_INT 11
79470: PUSH
79471: LD_INT 12
79473: PUSH
79474: LD_INT 13
79476: PUSH
79477: LD_INT 16
79479: PUSH
79480: LD_INT 17
79482: PUSH
79483: LD_INT 18
79485: PUSH
79486: LD_INT 19
79488: PUSH
79489: LD_INT 20
79491: PUSH
79492: LD_INT 21
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: IN
79510: NOT
79511: OR
79512: PUSH
79513: LD_VAR 0 8
79517: PUSH
79518: LD_INT 5
79520: ARRAY
79521: NOT
79522: OR
79523: PUSH
79524: LD_VAR 0 8
79528: PUSH
79529: LD_INT 6
79531: ARRAY
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: LD_INT 2
79538: PUSH
79539: LD_INT 7
79541: PUSH
79542: LD_INT 9
79544: PUSH
79545: LD_INT 10
79547: PUSH
79548: LD_INT 11
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: IN
79559: NOT
79560: OR
79561: IFFALSE 79567
// exit ;
79563: POP
79564: POP
79565: GO 79650
// end ;
79567: GO 79238
79569: POP
79570: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79571: LD_VAR 0 9
79575: PPUSH
79576: LD_VAR 0 3
79580: PPUSH
79581: LD_VAR 0 4
79585: PPUSH
79586: LD_INT 20
79588: PPUSH
79589: CALL 71596 0 4
79593: PUSH
79594: LD_INT 4
79596: ARRAY
79597: IFFALSE 79601
// exit ;
79599: GO 79650
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79601: LD_VAR 0 2
79605: PUSH
79606: LD_INT 29
79608: PUSH
79609: LD_INT 30
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: IN
79616: PUSH
79617: LD_VAR 0 3
79621: PPUSH
79622: LD_VAR 0 4
79626: PPUSH
79627: LD_VAR 0 9
79631: PPUSH
79632: CALL_OW 440
79636: NOT
79637: AND
79638: IFFALSE 79642
// exit ;
79640: GO 79650
// result := true ;
79642: LD_ADDR_VAR 0 6
79646: PUSH
79647: LD_INT 1
79649: ST_TO_ADDR
// end ;
79650: LD_VAR 0 6
79654: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79655: LD_INT 0
79657: PPUSH
79658: PPUSH
79659: PPUSH
79660: PPUSH
79661: PPUSH
79662: PPUSH
79663: PPUSH
79664: PPUSH
79665: PPUSH
79666: PPUSH
79667: PPUSH
79668: PPUSH
79669: PPUSH
79670: PPUSH
79671: PPUSH
79672: PPUSH
79673: PPUSH
79674: PPUSH
79675: PPUSH
79676: PPUSH
79677: PPUSH
79678: PPUSH
79679: PPUSH
79680: PPUSH
79681: PPUSH
79682: PPUSH
79683: PPUSH
79684: PPUSH
79685: PPUSH
79686: PPUSH
79687: PPUSH
79688: PPUSH
79689: PPUSH
79690: PPUSH
79691: PPUSH
79692: PPUSH
79693: PPUSH
79694: PPUSH
79695: PPUSH
79696: PPUSH
79697: PPUSH
79698: PPUSH
79699: PPUSH
79700: PPUSH
79701: PPUSH
79702: PPUSH
79703: PPUSH
79704: PPUSH
79705: PPUSH
79706: PPUSH
79707: PPUSH
79708: PPUSH
79709: PPUSH
79710: PPUSH
79711: PPUSH
79712: PPUSH
79713: PPUSH
79714: PPUSH
// result = [ ] ;
79715: LD_ADDR_VAR 0 7
79719: PUSH
79720: EMPTY
79721: ST_TO_ADDR
// temp_list = [ ] ;
79722: LD_ADDR_VAR 0 9
79726: PUSH
79727: EMPTY
79728: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79729: LD_VAR 0 4
79733: PUSH
79734: LD_INT 0
79736: PUSH
79737: LD_INT 1
79739: PUSH
79740: LD_INT 2
79742: PUSH
79743: LD_INT 3
79745: PUSH
79746: LD_INT 4
79748: PUSH
79749: LD_INT 5
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: IN
79760: NOT
79761: PUSH
79762: LD_VAR 0 1
79766: PUSH
79767: LD_INT 0
79769: PUSH
79770: LD_INT 1
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: IN
79777: PUSH
79778: LD_VAR 0 5
79782: PUSH
79783: LD_INT 1
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 3
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: LIST
79796: IN
79797: NOT
79798: AND
79799: OR
79800: IFFALSE 79804
// exit ;
79802: GO 98195
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79804: LD_VAR 0 1
79808: PUSH
79809: LD_INT 6
79811: PUSH
79812: LD_INT 7
79814: PUSH
79815: LD_INT 8
79817: PUSH
79818: LD_INT 13
79820: PUSH
79821: LD_INT 12
79823: PUSH
79824: LD_INT 15
79826: PUSH
79827: LD_INT 11
79829: PUSH
79830: LD_INT 14
79832: PUSH
79833: LD_INT 10
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: IN
79847: IFFALSE 79857
// btype = b_lab ;
79849: LD_ADDR_VAR 0 1
79853: PUSH
79854: LD_INT 6
79856: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79857: LD_VAR 0 6
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: LD_INT 1
79867: PUSH
79868: LD_INT 2
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: LIST
79875: IN
79876: NOT
79877: PUSH
79878: LD_VAR 0 1
79882: PUSH
79883: LD_INT 0
79885: PUSH
79886: LD_INT 1
79888: PUSH
79889: LD_INT 2
79891: PUSH
79892: LD_INT 3
79894: PUSH
79895: LD_INT 6
79897: PUSH
79898: LD_INT 36
79900: PUSH
79901: LD_INT 4
79903: PUSH
79904: LD_INT 5
79906: PUSH
79907: LD_INT 31
79909: PUSH
79910: LD_INT 32
79912: PUSH
79913: LD_INT 33
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: IN
79929: NOT
79930: PUSH
79931: LD_VAR 0 6
79935: PUSH
79936: LD_INT 1
79938: EQUAL
79939: AND
79940: OR
79941: PUSH
79942: LD_VAR 0 1
79946: PUSH
79947: LD_INT 2
79949: PUSH
79950: LD_INT 3
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: IN
79957: NOT
79958: PUSH
79959: LD_VAR 0 6
79963: PUSH
79964: LD_INT 2
79966: EQUAL
79967: AND
79968: OR
79969: IFFALSE 79979
// mode = 0 ;
79971: LD_ADDR_VAR 0 6
79975: PUSH
79976: LD_INT 0
79978: ST_TO_ADDR
// case mode of 0 :
79979: LD_VAR 0 6
79983: PUSH
79984: LD_INT 0
79986: DOUBLE
79987: EQUAL
79988: IFTRUE 79992
79990: GO 91445
79992: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79993: LD_ADDR_VAR 0 11
79997: PUSH
79998: LD_INT 0
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 0
80010: PUSH
80011: LD_INT 1
80013: NEG
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 1
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 1
80031: PUSH
80032: LD_INT 1
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 0
80041: PUSH
80042: LD_INT 1
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 1
80051: NEG
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: LD_INT 1
80062: NEG
80063: PUSH
80064: LD_INT 1
80066: NEG
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 1
80074: NEG
80075: PUSH
80076: LD_INT 2
80078: NEG
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: LD_INT 2
80089: NEG
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 1
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 1
80108: PUSH
80109: LD_INT 2
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: LD_INT 2
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 1
80128: NEG
80129: PUSH
80130: LD_INT 1
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: PUSH
80140: LD_INT 3
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: LD_INT 3
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 1
80159: NEG
80160: PUSH
80161: LD_INT 2
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80186: LD_ADDR_VAR 0 12
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: LD_INT 0
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: LD_INT 0
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 1
80214: PUSH
80215: LD_INT 0
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: LD_INT 1
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 1
80244: NEG
80245: PUSH
80246: LD_INT 0
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: LD_INT 1
80259: NEG
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 1
80267: PUSH
80268: LD_INT 1
80270: NEG
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 2
80278: PUSH
80279: LD_INT 0
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 2
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 1
80298: NEG
80299: PUSH
80300: LD_INT 1
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 2
80309: NEG
80310: PUSH
80311: LD_INT 0
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: NEG
80321: PUSH
80322: LD_INT 1
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 2
80332: NEG
80333: PUSH
80334: LD_INT 1
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 3
80343: NEG
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 3
80354: NEG
80355: PUSH
80356: LD_INT 1
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80382: LD_ADDR_VAR 0 13
80386: PUSH
80387: LD_INT 0
80389: PUSH
80390: LD_INT 0
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 1
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: LD_INT 1
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 1
80440: NEG
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 1
80451: NEG
80452: PUSH
80453: LD_INT 1
80455: NEG
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 2
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 2
80475: PUSH
80476: LD_INT 1
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 2
80485: PUSH
80486: LD_INT 2
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: LD_INT 2
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 2
80505: NEG
80506: PUSH
80507: LD_INT 1
80509: NEG
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 2
80517: NEG
80518: PUSH
80519: LD_INT 2
80521: NEG
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 2
80529: NEG
80530: PUSH
80531: LD_INT 3
80533: NEG
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 3
80541: NEG
80542: PUSH
80543: LD_INT 2
80545: NEG
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 3
80553: NEG
80554: PUSH
80555: LD_INT 3
80557: NEG
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80581: LD_ADDR_VAR 0 14
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 0
80598: PUSH
80599: LD_INT 1
80601: NEG
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 1
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: LD_INT 1
80622: PUSH
80623: EMPTY
80624: LIST
80625: LIST
80626: PUSH
80627: LD_INT 0
80629: PUSH
80630: LD_INT 1
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 1
80639: NEG
80640: PUSH
80641: LD_INT 0
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 1
80650: NEG
80651: PUSH
80652: LD_INT 1
80654: NEG
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 1
80662: NEG
80663: PUSH
80664: LD_INT 2
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 0
80674: PUSH
80675: LD_INT 2
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 1
80685: PUSH
80686: LD_INT 1
80688: NEG
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: LD_INT 2
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: LD_INT 2
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: LD_INT 1
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PUSH
80725: LD_INT 1
80727: NEG
80728: PUSH
80729: LD_INT 3
80731: NEG
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 0
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 1
80750: PUSH
80751: LD_INT 2
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80777: LD_ADDR_VAR 0 15
80781: PUSH
80782: LD_INT 0
80784: PUSH
80785: LD_INT 0
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 0
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 1
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 1
80815: PUSH
80816: LD_INT 1
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 0
80825: PUSH
80826: LD_INT 1
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 1
80835: NEG
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 1
80846: NEG
80847: PUSH
80848: LD_INT 1
80850: NEG
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 1
80858: PUSH
80859: LD_INT 1
80861: NEG
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 2
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 2
80879: PUSH
80880: LD_INT 1
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: LD_INT 1
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 2
80900: NEG
80901: PUSH
80902: LD_INT 0
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 2
80911: NEG
80912: PUSH
80913: LD_INT 1
80915: NEG
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 2
80923: PUSH
80924: LD_INT 1
80926: NEG
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PUSH
80932: LD_INT 3
80934: PUSH
80935: LD_INT 0
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 3
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80970: LD_ADDR_VAR 0 16
80974: PUSH
80975: LD_INT 0
80977: PUSH
80978: LD_INT 0
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: LD_INT 1
80990: NEG
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: PUSH
80999: LD_INT 0
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 1
81008: PUSH
81009: LD_INT 1
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 0
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 1
81028: NEG
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 1
81039: NEG
81040: PUSH
81041: LD_INT 1
81043: NEG
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 1
81051: NEG
81052: PUSH
81053: LD_INT 2
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: LD_INT 1
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: LD_INT 2
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 1
81083: PUSH
81084: LD_INT 2
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 2
81093: NEG
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 2
81105: NEG
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 3
81117: PUSH
81118: LD_INT 2
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 3
81127: PUSH
81128: LD_INT 3
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: PUSH
81138: LD_INT 3
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81163: LD_ADDR_VAR 0 17
81167: PUSH
81168: LD_INT 0
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 0
81180: PUSH
81181: LD_INT 1
81183: NEG
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 1
81191: PUSH
81192: LD_INT 0
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 1
81201: PUSH
81202: LD_INT 1
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 0
81211: PUSH
81212: LD_INT 1
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 1
81221: NEG
81222: PUSH
81223: LD_INT 0
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: NEG
81233: PUSH
81234: LD_INT 1
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 1
81244: NEG
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 0
81256: PUSH
81257: LD_INT 2
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 1
81267: PUSH
81268: LD_INT 1
81270: NEG
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 2
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 2
81288: PUSH
81289: LD_INT 1
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: LD_INT 2
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 1
81308: PUSH
81309: LD_INT 2
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 0
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 1
81328: NEG
81329: PUSH
81330: LD_INT 1
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 2
81339: NEG
81340: PUSH
81341: LD_INT 0
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 2
81350: NEG
81351: PUSH
81352: LD_INT 1
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 2
81362: NEG
81363: PUSH
81364: LD_INT 2
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81393: LD_ADDR_VAR 0 18
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: LD_INT 1
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 1
81421: PUSH
81422: LD_INT 0
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 1
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 0
81441: PUSH
81442: LD_INT 1
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: LD_INT 0
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 1
81462: NEG
81463: PUSH
81464: LD_INT 1
81466: NEG
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 1
81474: NEG
81475: PUSH
81476: LD_INT 2
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 0
81486: PUSH
81487: LD_INT 2
81489: NEG
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 1
81497: PUSH
81498: LD_INT 1
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 2
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 2
81518: PUSH
81519: LD_INT 1
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 2
81528: PUSH
81529: LD_INT 2
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: LD_INT 2
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 1
81558: NEG
81559: PUSH
81560: LD_INT 1
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 2
81569: NEG
81570: PUSH
81571: LD_INT 0
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 2
81580: NEG
81581: PUSH
81582: LD_INT 1
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 2
81592: NEG
81593: PUSH
81594: LD_INT 2
81596: NEG
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81623: LD_ADDR_VAR 0 19
81627: PUSH
81628: LD_INT 0
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 0
81640: PUSH
81641: LD_INT 1
81643: NEG
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 1
81651: PUSH
81652: LD_INT 0
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 1
81661: PUSH
81662: LD_INT 1
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 0
81671: PUSH
81672: LD_INT 1
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 1
81681: NEG
81682: PUSH
81683: LD_INT 0
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 1
81692: NEG
81693: PUSH
81694: LD_INT 1
81696: NEG
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 1
81704: NEG
81705: PUSH
81706: LD_INT 2
81708: NEG
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 0
81716: PUSH
81717: LD_INT 2
81719: NEG
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 1
81727: PUSH
81728: LD_INT 1
81730: NEG
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 2
81738: PUSH
81739: LD_INT 0
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 2
81748: PUSH
81749: LD_INT 1
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 2
81758: PUSH
81759: LD_INT 2
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 1
81768: PUSH
81769: LD_INT 2
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 0
81778: PUSH
81779: LD_INT 2
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 1
81788: NEG
81789: PUSH
81790: LD_INT 1
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 2
81799: NEG
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 2
81810: NEG
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 2
81822: NEG
81823: PUSH
81824: LD_INT 2
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81853: LD_ADDR_VAR 0 20
81857: PUSH
81858: LD_INT 0
81860: PUSH
81861: LD_INT 0
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 0
81870: PUSH
81871: LD_INT 1
81873: NEG
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 1
81881: PUSH
81882: LD_INT 0
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 1
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 0
81901: PUSH
81902: LD_INT 1
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 1
81911: NEG
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: LD_INT 1
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 1
81934: NEG
81935: PUSH
81936: LD_INT 2
81938: NEG
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 0
81946: PUSH
81947: LD_INT 2
81949: NEG
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 1
81957: PUSH
81958: LD_INT 1
81960: NEG
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 2
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 2
81978: PUSH
81979: LD_INT 1
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 2
81988: PUSH
81989: LD_INT 2
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 1
81998: PUSH
81999: LD_INT 2
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 1
82018: NEG
82019: PUSH
82020: LD_INT 1
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 2
82029: NEG
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 2
82040: NEG
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 2
82052: NEG
82053: PUSH
82054: LD_INT 2
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82083: LD_ADDR_VAR 0 21
82087: PUSH
82088: LD_INT 0
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 0
82100: PUSH
82101: LD_INT 1
82103: NEG
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 1
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 0
82131: PUSH
82132: LD_INT 1
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 1
82141: NEG
82142: PUSH
82143: LD_INT 0
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 1
82152: NEG
82153: PUSH
82154: LD_INT 1
82156: NEG
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 1
82164: NEG
82165: PUSH
82166: LD_INT 2
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 0
82176: PUSH
82177: LD_INT 2
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 1
82187: PUSH
82188: LD_INT 1
82190: NEG
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 2
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 2
82208: PUSH
82209: LD_INT 1
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 2
82218: PUSH
82219: LD_INT 2
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 1
82228: PUSH
82229: LD_INT 2
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 0
82238: PUSH
82239: LD_INT 2
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 1
82248: NEG
82249: PUSH
82250: LD_INT 1
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 2
82259: NEG
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 2
82270: NEG
82271: PUSH
82272: LD_INT 1
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 2
82282: NEG
82283: PUSH
82284: LD_INT 2
82286: NEG
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82313: LD_ADDR_VAR 0 22
82317: PUSH
82318: LD_INT 0
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: LD_INT 1
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 1
82341: PUSH
82342: LD_INT 0
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 1
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 0
82361: PUSH
82362: LD_INT 1
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 1
82371: NEG
82372: PUSH
82373: LD_INT 0
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 1
82382: NEG
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 1
82394: NEG
82395: PUSH
82396: LD_INT 2
82398: NEG
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 0
82406: PUSH
82407: LD_INT 2
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 1
82417: PUSH
82418: LD_INT 1
82420: NEG
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 2
82428: PUSH
82429: LD_INT 0
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 2
82438: PUSH
82439: LD_INT 1
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 2
82448: PUSH
82449: LD_INT 2
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: LD_INT 2
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 1
82478: NEG
82479: PUSH
82480: LD_INT 1
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 2
82489: NEG
82490: PUSH
82491: LD_INT 0
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 2
82512: NEG
82513: PUSH
82514: LD_INT 2
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82543: LD_ADDR_VAR 0 23
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: PUSH
82572: LD_INT 0
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 0
82591: PUSH
82592: LD_INT 1
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: LD_INT 0
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: LD_INT 1
82616: NEG
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 1
82624: NEG
82625: PUSH
82626: LD_INT 2
82628: NEG
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 0
82636: PUSH
82637: LD_INT 2
82639: NEG
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 1
82647: PUSH
82648: LD_INT 1
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 2
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 2
82668: PUSH
82669: LD_INT 1
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 2
82678: PUSH
82679: LD_INT 2
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 1
82688: PUSH
82689: LD_INT 2
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 0
82698: PUSH
82699: LD_INT 2
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: LD_INT 1
82708: NEG
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 2
82719: NEG
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 2
82742: NEG
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: LD_INT 3
82758: NEG
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 1
82766: NEG
82767: PUSH
82768: LD_INT 3
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 1
82778: PUSH
82779: LD_INT 2
82781: NEG
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 2
82789: PUSH
82790: LD_INT 1
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82823: LD_ADDR_VAR 0 24
82827: PUSH
82828: LD_INT 0
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 0
82840: PUSH
82841: LD_INT 1
82843: NEG
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 1
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 1
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: LD_INT 1
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 1
82892: NEG
82893: PUSH
82894: LD_INT 1
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 1
82904: NEG
82905: PUSH
82906: LD_INT 2
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 0
82916: PUSH
82917: LD_INT 2
82919: NEG
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 1
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 2
82938: PUSH
82939: LD_INT 0
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 2
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 2
82958: PUSH
82959: LD_INT 2
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 1
82968: PUSH
82969: LD_INT 2
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 0
82978: PUSH
82979: LD_INT 2
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 1
82988: NEG
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 2
82999: NEG
83000: PUSH
83001: LD_INT 0
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 2
83010: NEG
83011: PUSH
83012: LD_INT 1
83014: NEG
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 2
83022: NEG
83023: PUSH
83024: LD_INT 2
83026: NEG
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 1
83034: PUSH
83035: LD_INT 2
83037: NEG
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 2
83045: PUSH
83046: LD_INT 1
83048: NEG
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 3
83056: PUSH
83057: LD_INT 1
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 3
83066: PUSH
83067: LD_INT 2
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83099: LD_ADDR_VAR 0 25
83103: PUSH
83104: LD_INT 0
83106: PUSH
83107: LD_INT 0
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 0
83116: PUSH
83117: LD_INT 1
83119: NEG
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 1
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 1
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 1
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 1
83157: NEG
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: NEG
83169: PUSH
83170: LD_INT 1
83172: NEG
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: NEG
83181: PUSH
83182: LD_INT 2
83184: NEG
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: LD_INT 2
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 1
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 2
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 2
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 2
83234: PUSH
83235: LD_INT 2
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 1
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 0
83254: PUSH
83255: LD_INT 2
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 1
83264: NEG
83265: PUSH
83266: LD_INT 1
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 2
83275: NEG
83276: PUSH
83277: LD_INT 0
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 2
83286: NEG
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: NEG
83299: PUSH
83300: LD_INT 2
83302: NEG
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 3
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 3
83320: PUSH
83321: LD_INT 2
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: PUSH
83331: LD_INT 3
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: LD_INT 3
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83373: LD_ADDR_VAR 0 26
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: LD_INT 0
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 0
83390: PUSH
83391: LD_INT 1
83393: NEG
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 1
83401: PUSH
83402: LD_INT 0
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: LD_INT 1
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 0
83421: PUSH
83422: LD_INT 1
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 1
83431: NEG
83432: PUSH
83433: LD_INT 0
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 1
83442: NEG
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 1
83454: NEG
83455: PUSH
83456: LD_INT 2
83458: NEG
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 0
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 1
83477: PUSH
83478: LD_INT 1
83480: NEG
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 2
83488: PUSH
83489: LD_INT 0
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 2
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 2
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 1
83518: PUSH
83519: LD_INT 2
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 0
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: NEG
83539: PUSH
83540: LD_INT 1
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PUSH
83547: LD_INT 2
83549: NEG
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 2
83560: NEG
83561: PUSH
83562: LD_INT 1
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 2
83572: NEG
83573: PUSH
83574: LD_INT 2
83576: NEG
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 2
83584: PUSH
83585: LD_INT 3
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 1
83594: PUSH
83595: LD_INT 3
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 1
83604: NEG
83605: PUSH
83606: LD_INT 2
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 2
83615: NEG
83616: PUSH
83617: LD_INT 1
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83649: LD_ADDR_VAR 0 27
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: LD_INT 0
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 0
83666: PUSH
83667: LD_INT 1
83669: NEG
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 1
83677: PUSH
83678: LD_INT 0
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: LD_INT 1
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: LD_INT 1
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 1
83707: NEG
83708: PUSH
83709: LD_INT 0
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 1
83718: NEG
83719: PUSH
83720: LD_INT 1
83722: NEG
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: LD_INT 2
83734: NEG
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: LD_INT 2
83745: NEG
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 1
83753: PUSH
83754: LD_INT 1
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 2
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 2
83774: PUSH
83775: LD_INT 1
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: LD_INT 2
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 1
83794: PUSH
83795: LD_INT 2
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 0
83804: PUSH
83805: LD_INT 2
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: NEG
83815: PUSH
83816: LD_INT 1
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 2
83825: NEG
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 2
83836: NEG
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 2
83848: NEG
83849: PUSH
83850: LD_INT 2
83852: NEG
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: NEG
83861: PUSH
83862: LD_INT 2
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 2
83871: NEG
83872: PUSH
83873: LD_INT 1
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 3
83882: NEG
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 3
83894: NEG
83895: PUSH
83896: LD_INT 2
83898: NEG
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83929: LD_ADDR_VAR 0 28
83933: PUSH
83934: LD_INT 0
83936: PUSH
83937: LD_INT 0
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 0
83946: PUSH
83947: LD_INT 1
83949: NEG
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: PUSH
83958: LD_INT 0
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 1
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 0
83977: PUSH
83978: LD_INT 1
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 1
83987: NEG
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 1
83998: NEG
83999: PUSH
84000: LD_INT 1
84002: NEG
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: PUSH
84008: LD_INT 1
84010: NEG
84011: PUSH
84012: LD_INT 2
84014: NEG
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 0
84022: PUSH
84023: LD_INT 2
84025: NEG
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 1
84033: PUSH
84034: LD_INT 1
84036: NEG
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 2
84044: PUSH
84045: LD_INT 0
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 1
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 2
84064: PUSH
84065: LD_INT 2
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 1
84074: PUSH
84075: LD_INT 2
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 0
84084: PUSH
84085: LD_INT 2
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 1
84094: NEG
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 2
84105: NEG
84106: PUSH
84107: LD_INT 0
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 2
84116: NEG
84117: PUSH
84118: LD_INT 1
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 2
84128: NEG
84129: PUSH
84130: LD_INT 2
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 2
84140: NEG
84141: PUSH
84142: LD_INT 3
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: LD_INT 3
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 3
84164: NEG
84165: PUSH
84166: LD_INT 1
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 3
84176: NEG
84177: PUSH
84178: LD_INT 2
84180: NEG
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84211: LD_ADDR_VAR 0 29
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: LD_INT 0
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 0
84228: PUSH
84229: LD_INT 1
84231: NEG
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: PUSH
84237: LD_INT 1
84239: PUSH
84240: LD_INT 0
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 1
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 0
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: LD_INT 0
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: PUSH
84278: LD_INT 1
84280: NEG
84281: PUSH
84282: LD_INT 1
84284: NEG
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: PUSH
84290: LD_INT 1
84292: NEG
84293: PUSH
84294: LD_INT 2
84296: NEG
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: LD_INT 0
84304: PUSH
84305: LD_INT 2
84307: NEG
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 1
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 2
84326: PUSH
84327: LD_INT 0
84329: PUSH
84330: EMPTY
84331: LIST
84332: LIST
84333: PUSH
84334: LD_INT 2
84336: PUSH
84337: LD_INT 1
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: PUSH
84347: LD_INT 2
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: PUSH
84354: LD_INT 0
84356: PUSH
84357: LD_INT 2
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 1
84366: NEG
84367: PUSH
84368: LD_INT 1
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: LD_INT 1
84381: NEG
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 2
84389: NEG
84390: PUSH
84391: LD_INT 2
84393: NEG
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 2
84401: NEG
84402: PUSH
84403: LD_INT 3
84405: NEG
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 2
84413: PUSH
84414: LD_INT 1
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 3
84424: PUSH
84425: LD_INT 1
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: PUSH
84432: LD_INT 1
84434: PUSH
84435: LD_INT 3
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 1
84444: NEG
84445: PUSH
84446: LD_INT 2
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 3
84455: NEG
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84490: LD_ADDR_VAR 0 30
84494: PUSH
84495: LD_INT 0
84497: PUSH
84498: LD_INT 0
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 0
84507: PUSH
84508: LD_INT 1
84510: NEG
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 1
84518: PUSH
84519: LD_INT 0
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 1
84528: PUSH
84529: LD_INT 1
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 0
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: NEG
84549: PUSH
84550: LD_INT 0
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 1
84559: NEG
84560: PUSH
84561: LD_INT 1
84563: NEG
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 1
84571: NEG
84572: PUSH
84573: LD_INT 2
84575: NEG
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: LD_INT 2
84586: NEG
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: PUSH
84595: LD_INT 1
84597: NEG
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 2
84605: PUSH
84606: LD_INT 0
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 2
84615: PUSH
84616: LD_INT 1
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: PUSH
84626: LD_INT 2
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 2
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 2
84656: NEG
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 2
84667: NEG
84668: PUSH
84669: LD_INT 1
84671: NEG
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: LD_INT 1
84679: NEG
84680: PUSH
84681: LD_INT 3
84683: NEG
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: PUSH
84692: LD_INT 2
84694: NEG
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 3
84702: PUSH
84703: LD_INT 2
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 2
84712: PUSH
84713: LD_INT 3
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 2
84722: NEG
84723: PUSH
84724: LD_INT 1
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 3
84733: NEG
84734: PUSH
84735: LD_INT 1
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84768: LD_ADDR_VAR 0 31
84772: PUSH
84773: LD_INT 0
84775: PUSH
84776: LD_INT 0
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 1
84788: NEG
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 1
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 1
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 0
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 1
84826: NEG
84827: PUSH
84828: LD_INT 0
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: NEG
84838: PUSH
84839: LD_INT 1
84841: NEG
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 1
84849: NEG
84850: PUSH
84851: LD_INT 2
84853: NEG
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 1
84861: PUSH
84862: LD_INT 1
84864: NEG
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: LD_INT 2
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: LD_INT 2
84882: PUSH
84883: LD_INT 1
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: PUSH
84890: LD_INT 2
84892: PUSH
84893: LD_INT 2
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: LD_INT 2
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 0
84912: PUSH
84913: LD_INT 2
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: LD_INT 1
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 2
84933: NEG
84934: PUSH
84935: LD_INT 1
84937: NEG
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 2
84945: NEG
84946: PUSH
84947: LD_INT 2
84949: NEG
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: PUSH
84955: LD_INT 2
84957: NEG
84958: PUSH
84959: LD_INT 3
84961: NEG
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 2
84969: PUSH
84970: LD_INT 1
84972: NEG
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 3
84980: PUSH
84981: LD_INT 1
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: LD_INT 3
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: NEG
85001: PUSH
85002: LD_INT 2
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 3
85011: NEG
85012: PUSH
85013: LD_INT 2
85015: NEG
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85046: LD_ADDR_VAR 0 32
85050: PUSH
85051: LD_INT 0
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 0
85063: PUSH
85064: LD_INT 1
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: PUSH
85085: LD_INT 1
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 0
85094: PUSH
85095: LD_INT 1
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: NEG
85105: PUSH
85106: LD_INT 0
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 1
85115: NEG
85116: PUSH
85117: LD_INT 1
85119: NEG
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 1
85127: NEG
85128: PUSH
85129: LD_INT 2
85131: NEG
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 0
85139: PUSH
85140: LD_INT 2
85142: NEG
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: LD_INT 1
85150: PUSH
85151: LD_INT 1
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 2
85161: PUSH
85162: LD_INT 1
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: LD_INT 2
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: LD_INT 2
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 0
85191: PUSH
85192: LD_INT 2
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 1
85201: NEG
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 2
85212: NEG
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 2
85223: NEG
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: EMPTY
85230: LIST
85231: LIST
85232: PUSH
85233: LD_INT 1
85235: NEG
85236: PUSH
85237: LD_INT 3
85239: NEG
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: LD_INT 2
85250: NEG
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 3
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 2
85268: PUSH
85269: LD_INT 3
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 2
85278: NEG
85279: PUSH
85280: LD_INT 1
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 3
85289: NEG
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85324: LD_ADDR_VAR 0 33
85328: PUSH
85329: LD_INT 0
85331: PUSH
85332: LD_INT 0
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 0
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: PUSH
85363: LD_INT 1
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 0
85372: PUSH
85373: LD_INT 1
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 1
85382: NEG
85383: PUSH
85384: LD_INT 0
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 1
85393: NEG
85394: PUSH
85395: LD_INT 1
85397: NEG
85398: PUSH
85399: EMPTY
85400: LIST
85401: LIST
85402: PUSH
85403: LD_INT 1
85405: NEG
85406: PUSH
85407: LD_INT 2
85409: NEG
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 1
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 2
85428: PUSH
85429: LD_INT 0
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 2
85438: PUSH
85439: LD_INT 1
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 1
85448: PUSH
85449: LD_INT 2
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: PUSH
85456: LD_INT 0
85458: PUSH
85459: LD_INT 2
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: LD_INT 1
85468: NEG
85469: PUSH
85470: LD_INT 1
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 2
85479: NEG
85480: PUSH
85481: LD_INT 0
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: LD_INT 1
85494: NEG
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 2
85502: NEG
85503: PUSH
85504: LD_INT 2
85506: NEG
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 2
85514: NEG
85515: PUSH
85516: LD_INT 3
85518: NEG
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: LD_INT 2
85526: PUSH
85527: LD_INT 1
85529: NEG
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 3
85537: PUSH
85538: LD_INT 1
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: LD_INT 2
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 3
85568: NEG
85569: PUSH
85570: LD_INT 2
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85603: LD_ADDR_VAR 0 34
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: LD_INT 0
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 1
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 0
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 0
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 1
85661: NEG
85662: PUSH
85663: LD_INT 0
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: NEG
85673: PUSH
85674: LD_INT 1
85676: NEG
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 1
85684: NEG
85685: PUSH
85686: LD_INT 2
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 0
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 1
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 2
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 1
85748: NEG
85749: PUSH
85750: LD_INT 1
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 2
85759: NEG
85760: PUSH
85761: LD_INT 0
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 2
85770: NEG
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 2
85782: NEG
85783: PUSH
85784: LD_INT 2
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: LD_INT 3
85798: NEG
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: LD_INT 2
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 3
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 2
85827: PUSH
85828: LD_INT 3
85830: PUSH
85831: EMPTY
85832: LIST
85833: LIST
85834: PUSH
85835: LD_INT 2
85837: NEG
85838: PUSH
85839: LD_INT 1
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 3
85848: NEG
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: EMPTY
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85883: LD_ADDR_VAR 0 35
85887: PUSH
85888: LD_INT 0
85890: PUSH
85891: LD_INT 0
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 0
85900: PUSH
85901: LD_INT 1
85903: NEG
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 1
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PUSH
85929: LD_INT 0
85931: PUSH
85932: LD_INT 1
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 1
85941: NEG
85942: PUSH
85943: LD_INT 0
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 1
85952: NEG
85953: PUSH
85954: LD_INT 1
85956: NEG
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 2
85964: PUSH
85965: LD_INT 1
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 2
85974: NEG
85975: PUSH
85976: LD_INT 1
85978: NEG
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85995: LD_ADDR_VAR 0 36
85999: PUSH
86000: LD_INT 0
86002: PUSH
86003: LD_INT 0
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 0
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 1
86023: PUSH
86024: LD_INT 0
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 1
86033: PUSH
86034: LD_INT 1
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 0
86043: PUSH
86044: LD_INT 1
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 1
86053: NEG
86054: PUSH
86055: LD_INT 0
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 1
86064: NEG
86065: PUSH
86066: LD_INT 1
86068: NEG
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 1
86076: NEG
86077: PUSH
86078: LD_INT 2
86080: NEG
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PUSH
86086: LD_INT 1
86088: PUSH
86089: LD_INT 2
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86107: LD_ADDR_VAR 0 37
86111: PUSH
86112: LD_INT 0
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 0
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: LD_INT 0
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 0
86155: PUSH
86156: LD_INT 1
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 1
86165: NEG
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 1
86176: NEG
86177: PUSH
86178: LD_INT 1
86180: NEG
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 1
86199: NEG
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86219: LD_ADDR_VAR 0 38
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 0
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 0
86236: PUSH
86237: LD_INT 1
86239: NEG
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: LD_INT 0
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 1
86257: PUSH
86258: LD_INT 1
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 0
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: NEG
86278: PUSH
86279: LD_INT 0
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 1
86288: NEG
86289: PUSH
86290: LD_INT 1
86292: NEG
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 2
86300: PUSH
86301: LD_INT 1
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 2
86310: NEG
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86331: LD_ADDR_VAR 0 39
86335: PUSH
86336: LD_INT 0
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 0
86348: PUSH
86349: LD_INT 1
86351: NEG
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: PUSH
86370: LD_INT 1
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 0
86379: PUSH
86380: LD_INT 1
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: NEG
86390: PUSH
86391: LD_INT 0
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 1
86400: NEG
86401: PUSH
86402: LD_INT 1
86404: NEG
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 1
86412: NEG
86413: PUSH
86414: LD_INT 2
86416: NEG
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: LD_INT 1
86424: PUSH
86425: LD_INT 2
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86443: LD_ADDR_VAR 0 40
86447: PUSH
86448: LD_INT 0
86450: PUSH
86451: LD_INT 0
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 0
86460: PUSH
86461: LD_INT 1
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: LD_INT 0
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 1
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 0
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 1
86501: NEG
86502: PUSH
86503: LD_INT 0
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 1
86524: PUSH
86525: LD_INT 1
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: LD_INT 1
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86555: LD_ADDR_VAR 0 41
86559: PUSH
86560: LD_INT 0
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 0
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: LD_INT 0
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 1
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 0
86603: PUSH
86604: LD_INT 1
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 0
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: LD_INT 1
86624: NEG
86625: PUSH
86626: LD_INT 1
86628: NEG
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: NEG
86637: PUSH
86638: LD_INT 2
86640: NEG
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: LD_INT 1
86651: NEG
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 2
86679: PUSH
86680: LD_INT 2
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 1
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: NEG
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: NEG
86711: PUSH
86712: LD_INT 0
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 2
86721: NEG
86722: PUSH
86723: LD_INT 1
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 2
86733: NEG
86734: PUSH
86735: LD_INT 2
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 2
86745: NEG
86746: PUSH
86747: LD_INT 3
86749: NEG
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 2
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 3
86768: PUSH
86769: LD_INT 0
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 3
86778: PUSH
86779: LD_INT 1
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 3
86788: PUSH
86789: LD_INT 2
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 3
86798: PUSH
86799: LD_INT 3
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 2
86808: PUSH
86809: LD_INT 3
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 2
86818: NEG
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 3
86829: NEG
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 3
86840: NEG
86841: PUSH
86842: LD_INT 1
86844: NEG
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 3
86852: NEG
86853: PUSH
86854: LD_INT 2
86856: NEG
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 3
86864: NEG
86865: PUSH
86866: LD_INT 3
86868: NEG
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86905: LD_ADDR_VAR 0 42
86909: PUSH
86910: LD_INT 0
86912: PUSH
86913: LD_INT 0
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 0
86922: PUSH
86923: LD_INT 1
86925: NEG
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 1
86933: PUSH
86934: LD_INT 0
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 1
86943: PUSH
86944: LD_INT 1
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 0
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 1
86963: NEG
86964: PUSH
86965: LD_INT 0
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: LD_INT 1
86974: NEG
86975: PUSH
86976: LD_INT 1
86978: NEG
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 1
86986: NEG
86987: PUSH
86988: LD_INT 2
86990: NEG
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 0
86998: PUSH
86999: LD_INT 2
87001: NEG
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 1
87009: PUSH
87010: LD_INT 1
87012: NEG
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: PUSH
87018: LD_INT 2
87020: PUSH
87021: LD_INT 1
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 2
87030: PUSH
87031: LD_INT 2
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: LD_INT 2
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 2
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 1
87060: NEG
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 2
87071: NEG
87072: PUSH
87073: LD_INT 1
87075: NEG
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 2
87083: NEG
87084: PUSH
87085: LD_INT 2
87087: NEG
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 2
87095: NEG
87096: PUSH
87097: LD_INT 3
87099: NEG
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 1
87107: NEG
87108: PUSH
87109: LD_INT 3
87111: NEG
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 0
87119: PUSH
87120: LD_INT 3
87122: NEG
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 1
87130: PUSH
87131: LD_INT 2
87133: NEG
87134: PUSH
87135: EMPTY
87136: LIST
87137: LIST
87138: PUSH
87139: LD_INT 3
87141: PUSH
87142: LD_INT 2
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PUSH
87149: LD_INT 3
87151: PUSH
87152: LD_INT 3
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: LD_INT 3
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: PUSH
87172: LD_INT 3
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 0
87181: PUSH
87182: LD_INT 3
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 1
87191: NEG
87192: PUSH
87193: LD_INT 2
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 3
87202: NEG
87203: PUSH
87204: LD_INT 2
87206: NEG
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 3
87214: NEG
87215: PUSH
87216: LD_INT 3
87218: NEG
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87255: LD_ADDR_VAR 0 43
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: LD_INT 0
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 0
87272: PUSH
87273: LD_INT 1
87275: NEG
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 1
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: LD_INT 1
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 0
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 1
87313: NEG
87314: PUSH
87315: LD_INT 0
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 1
87324: NEG
87325: PUSH
87326: LD_INT 1
87328: NEG
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PUSH
87334: LD_INT 1
87336: NEG
87337: PUSH
87338: LD_INT 2
87340: NEG
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 0
87348: PUSH
87349: LD_INT 2
87351: NEG
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 1
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 2
87370: PUSH
87371: LD_INT 0
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 2
87380: PUSH
87381: LD_INT 1
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: PUSH
87388: LD_INT 1
87390: PUSH
87391: LD_INT 2
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: LD_INT 2
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 1
87410: NEG
87411: PUSH
87412: LD_INT 1
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 2
87421: NEG
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 2
87432: NEG
87433: PUSH
87434: LD_INT 1
87436: NEG
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: LD_INT 3
87448: NEG
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: LD_INT 3
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: LD_INT 2
87470: NEG
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 2
87478: PUSH
87479: LD_INT 1
87481: NEG
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 3
87489: PUSH
87490: LD_INT 0
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 3
87499: PUSH
87500: LD_INT 1
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: LD_INT 3
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: LD_INT 3
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: LD_INT 2
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: NEG
87541: PUSH
87542: LD_INT 1
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 3
87551: NEG
87552: PUSH
87553: LD_INT 0
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: PUSH
87560: LD_INT 3
87562: NEG
87563: PUSH
87564: LD_INT 1
87566: NEG
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87603: LD_ADDR_VAR 0 44
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: LD_INT 0
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: LD_INT 1
87623: NEG
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 1
87631: PUSH
87632: LD_INT 0
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 1
87641: PUSH
87642: LD_INT 1
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: LD_INT 1
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 1
87661: NEG
87662: PUSH
87663: LD_INT 0
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: NEG
87673: PUSH
87674: LD_INT 1
87676: NEG
87677: PUSH
87678: EMPTY
87679: LIST
87680: LIST
87681: PUSH
87682: LD_INT 1
87684: NEG
87685: PUSH
87686: LD_INT 2
87688: NEG
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 1
87696: PUSH
87697: LD_INT 1
87699: NEG
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 2
87707: PUSH
87708: LD_INT 0
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 2
87717: PUSH
87718: LD_INT 1
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 2
87727: PUSH
87728: LD_INT 2
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: LD_INT 2
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 1
87747: NEG
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 2
87758: NEG
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 2
87769: NEG
87770: PUSH
87771: LD_INT 1
87773: NEG
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 2
87781: NEG
87782: PUSH
87783: LD_INT 2
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 2
87793: NEG
87794: PUSH
87795: LD_INT 3
87797: NEG
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 2
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 3
87816: PUSH
87817: LD_INT 0
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 3
87826: PUSH
87827: LD_INT 1
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 3
87836: PUSH
87837: LD_INT 2
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: LD_INT 3
87846: PUSH
87847: LD_INT 3
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 2
87856: PUSH
87857: LD_INT 3
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: NEG
87867: PUSH
87868: LD_INT 1
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 3
87877: NEG
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 3
87888: NEG
87889: PUSH
87890: LD_INT 1
87892: NEG
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 3
87900: NEG
87901: PUSH
87902: LD_INT 2
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 3
87912: NEG
87913: PUSH
87914: LD_INT 3
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: LIST
87943: LIST
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87953: LD_ADDR_VAR 0 45
87957: PUSH
87958: LD_INT 0
87960: PUSH
87961: LD_INT 0
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 1
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 1
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 1
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 1
88011: NEG
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 1
88022: NEG
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 1
88034: NEG
88035: PUSH
88036: LD_INT 2
88038: NEG
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 0
88046: PUSH
88047: LD_INT 2
88049: NEG
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 1
88057: PUSH
88058: LD_INT 1
88060: NEG
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 2
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 2
88078: PUSH
88079: LD_INT 2
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: LD_INT 1
88088: PUSH
88089: LD_INT 2
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 0
88098: PUSH
88099: LD_INT 2
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 1
88108: NEG
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 2
88119: NEG
88120: PUSH
88121: LD_INT 1
88123: NEG
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: PUSH
88129: LD_INT 2
88131: NEG
88132: PUSH
88133: LD_INT 2
88135: NEG
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 2
88143: NEG
88144: PUSH
88145: LD_INT 3
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: NEG
88156: PUSH
88157: LD_INT 3
88159: NEG
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: PUSH
88165: LD_INT 0
88167: PUSH
88168: LD_INT 3
88170: NEG
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 1
88178: PUSH
88179: LD_INT 2
88181: NEG
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 3
88189: PUSH
88190: LD_INT 2
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: LD_INT 3
88199: PUSH
88200: LD_INT 3
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 2
88209: PUSH
88210: LD_INT 3
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 1
88219: PUSH
88220: LD_INT 3
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 0
88229: PUSH
88230: LD_INT 3
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 1
88239: NEG
88240: PUSH
88241: LD_INT 2
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 3
88250: NEG
88251: PUSH
88252: LD_INT 2
88254: NEG
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 3
88262: NEG
88263: PUSH
88264: LD_INT 3
88266: NEG
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88303: LD_ADDR_VAR 0 46
88307: PUSH
88308: LD_INT 0
88310: PUSH
88311: LD_INT 0
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 0
88320: PUSH
88321: LD_INT 1
88323: NEG
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 1
88331: PUSH
88332: LD_INT 0
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: LD_INT 1
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: PUSH
88349: LD_INT 0
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 1
88361: NEG
88362: PUSH
88363: LD_INT 0
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 1
88372: NEG
88373: PUSH
88374: LD_INT 1
88376: NEG
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: LD_INT 2
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: LD_INT 2
88399: NEG
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 1
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 2
88418: PUSH
88419: LD_INT 0
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 2
88428: PUSH
88429: LD_INT 1
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 2
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: LD_INT 2
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 1
88458: NEG
88459: PUSH
88460: LD_INT 1
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 2
88469: NEG
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 2
88480: NEG
88481: PUSH
88482: LD_INT 1
88484: NEG
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 1
88492: NEG
88493: PUSH
88494: LD_INT 3
88496: NEG
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: LD_INT 3
88507: NEG
88508: PUSH
88509: EMPTY
88510: LIST
88511: LIST
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: LD_INT 2
88518: NEG
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 2
88526: PUSH
88527: LD_INT 1
88529: NEG
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 3
88537: PUSH
88538: LD_INT 0
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 3
88547: PUSH
88548: LD_INT 1
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 1
88557: PUSH
88558: LD_INT 3
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: LD_INT 3
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: LD_INT 1
88577: NEG
88578: PUSH
88579: LD_INT 2
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 2
88588: NEG
88589: PUSH
88590: LD_INT 1
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 3
88599: NEG
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 3
88610: NEG
88611: PUSH
88612: LD_INT 1
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88651: LD_ADDR_VAR 0 47
88655: PUSH
88656: LD_INT 0
88658: PUSH
88659: LD_INT 0
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 1
88671: NEG
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 1
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 1
88689: PUSH
88690: LD_INT 1
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 0
88699: PUSH
88700: LD_INT 1
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 1
88709: NEG
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: NEG
88721: PUSH
88722: LD_INT 1
88724: NEG
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 1
88732: NEG
88733: PUSH
88734: LD_INT 2
88736: NEG
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 2
88747: NEG
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 1
88755: PUSH
88756: LD_INT 1
88758: NEG
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 2
88766: NEG
88767: PUSH
88768: LD_INT 1
88770: NEG
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 2
88778: NEG
88779: PUSH
88780: LD_INT 2
88782: NEG
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88802: LD_ADDR_VAR 0 48
88806: PUSH
88807: LD_INT 0
88809: PUSH
88810: LD_INT 0
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 1
88830: PUSH
88831: LD_INT 0
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: LD_INT 1
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: LD_INT 1
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 1
88860: NEG
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 1
88871: NEG
88872: PUSH
88873: LD_INT 1
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: NEG
88884: PUSH
88885: LD_INT 2
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: LD_INT 2
88898: NEG
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: LD_INT 1
88909: NEG
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 2
88917: PUSH
88918: LD_INT 0
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 2
88927: PUSH
88928: LD_INT 1
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88949: LD_ADDR_VAR 0 49
88953: PUSH
88954: LD_INT 0
88956: PUSH
88957: LD_INT 0
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: LD_INT 1
88969: NEG
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: LD_INT 1
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 1
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 0
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 1
89007: NEG
89008: PUSH
89009: LD_INT 0
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 1
89018: NEG
89019: PUSH
89020: LD_INT 1
89022: NEG
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 1
89030: PUSH
89031: LD_INT 1
89033: NEG
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 2
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: PUSH
89052: LD_INT 1
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 2
89061: PUSH
89062: LD_INT 2
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 2
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89093: LD_ADDR_VAR 0 50
89097: PUSH
89098: LD_INT 0
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 0
89110: PUSH
89111: LD_INT 1
89113: NEG
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 1
89121: PUSH
89122: LD_INT 0
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 1
89131: PUSH
89132: LD_INT 1
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PUSH
89139: LD_INT 0
89141: PUSH
89142: LD_INT 1
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 1
89151: NEG
89152: PUSH
89153: LD_INT 0
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 1
89162: NEG
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 2
89174: PUSH
89175: LD_INT 1
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 2
89184: PUSH
89185: LD_INT 2
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 1
89194: PUSH
89195: LD_INT 2
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: LD_INT 2
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 1
89214: NEG
89215: PUSH
89216: LD_INT 1
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89237: LD_ADDR_VAR 0 51
89241: PUSH
89242: LD_INT 0
89244: PUSH
89245: LD_INT 0
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: LD_INT 1
89257: NEG
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 1
89265: PUSH
89266: LD_INT 0
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 1
89275: PUSH
89276: LD_INT 1
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 0
89285: PUSH
89286: LD_INT 1
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: LD_INT 0
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 1
89306: NEG
89307: PUSH
89308: LD_INT 1
89310: NEG
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 1
89318: PUSH
89319: LD_INT 2
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 0
89328: PUSH
89329: LD_INT 2
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 1
89338: NEG
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 2
89349: NEG
89350: PUSH
89351: LD_INT 0
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 2
89360: NEG
89361: PUSH
89362: LD_INT 1
89364: NEG
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89384: LD_ADDR_VAR 0 52
89388: PUSH
89389: LD_INT 0
89391: PUSH
89392: LD_INT 0
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 0
89401: PUSH
89402: LD_INT 1
89404: NEG
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 1
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 0
89432: PUSH
89433: LD_INT 1
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: LD_INT 1
89457: NEG
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: LD_INT 1
89465: NEG
89466: PUSH
89467: LD_INT 2
89469: NEG
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 2
89488: NEG
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: LD_INT 2
89499: NEG
89500: PUSH
89501: LD_INT 1
89503: NEG
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 2
89511: NEG
89512: PUSH
89513: LD_INT 2
89515: NEG
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89535: LD_ADDR_VAR 0 53
89539: PUSH
89540: LD_INT 0
89542: PUSH
89543: LD_INT 0
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 0
89552: PUSH
89553: LD_INT 1
89555: NEG
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 1
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 1
89573: PUSH
89574: LD_INT 1
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 0
89583: PUSH
89584: LD_INT 1
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: NEG
89594: PUSH
89595: LD_INT 0
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 1
89604: NEG
89605: PUSH
89606: LD_INT 1
89608: NEG
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: LD_INT 2
89620: NEG
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: LD_INT 2
89631: NEG
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 1
89639: PUSH
89640: LD_INT 1
89642: NEG
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 2
89650: PUSH
89651: LD_INT 0
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 2
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 2
89670: PUSH
89671: LD_INT 2
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: PUSH
89678: LD_INT 1
89680: PUSH
89681: LD_INT 2
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: LD_INT 0
89690: PUSH
89691: LD_INT 2
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 1
89700: NEG
89701: PUSH
89702: LD_INT 1
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 2
89711: NEG
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 2
89722: NEG
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 2
89734: NEG
89735: PUSH
89736: LD_INT 2
89738: NEG
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89765: LD_ADDR_VAR 0 54
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 0
89782: PUSH
89783: LD_INT 1
89785: NEG
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 1
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 1
89803: PUSH
89804: LD_INT 1
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: LD_INT 1
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: NEG
89824: PUSH
89825: LD_INT 0
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 1
89834: NEG
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: NEG
89847: PUSH
89848: LD_INT 2
89850: NEG
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: LD_INT 2
89861: NEG
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 1
89869: PUSH
89870: LD_INT 1
89872: NEG
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 2
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 2
89890: PUSH
89891: LD_INT 1
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 2
89900: PUSH
89901: LD_INT 2
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: LD_INT 1
89910: PUSH
89911: LD_INT 2
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: LD_INT 2
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 1
89930: NEG
89931: PUSH
89932: LD_INT 1
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 2
89941: NEG
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 2
89952: NEG
89953: PUSH
89954: LD_INT 1
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 2
89964: NEG
89965: PUSH
89966: LD_INT 2
89968: NEG
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89995: LD_ADDR_VAR 0 55
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: LD_INT 1
90015: NEG
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 1
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 0
90043: PUSH
90044: LD_INT 1
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: LD_INT 1
90068: NEG
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 1
90076: NEG
90077: PUSH
90078: LD_INT 2
90080: NEG
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 0
90088: PUSH
90089: LD_INT 2
90091: NEG
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 1
90099: PUSH
90100: LD_INT 1
90102: NEG
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 2
90110: PUSH
90111: LD_INT 0
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 2
90120: PUSH
90121: LD_INT 1
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 2
90130: PUSH
90131: LD_INT 2
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 1
90140: PUSH
90141: LD_INT 2
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 0
90150: PUSH
90151: LD_INT 2
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: PUSH
90162: LD_INT 1
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 2
90171: NEG
90172: PUSH
90173: LD_INT 0
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 2
90182: NEG
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 2
90194: NEG
90195: PUSH
90196: LD_INT 2
90198: NEG
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90225: LD_ADDR_VAR 0 56
90229: PUSH
90230: LD_INT 0
90232: PUSH
90233: LD_INT 0
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 0
90242: PUSH
90243: LD_INT 1
90245: NEG
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: PUSH
90251: LD_INT 1
90253: PUSH
90254: LD_INT 0
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: LD_INT 1
90263: PUSH
90264: LD_INT 1
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 1
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 1
90283: NEG
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 1
90294: NEG
90295: PUSH
90296: LD_INT 1
90298: NEG
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PUSH
90304: LD_INT 1
90306: NEG
90307: PUSH
90308: LD_INT 2
90310: NEG
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: LD_INT 2
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 1
90329: PUSH
90330: LD_INT 1
90332: NEG
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 2
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 2
90350: PUSH
90351: LD_INT 1
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: LD_INT 2
90360: PUSH
90361: LD_INT 2
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 1
90370: PUSH
90371: LD_INT 2
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: LD_INT 2
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 1
90390: NEG
90391: PUSH
90392: LD_INT 1
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 2
90401: NEG
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 2
90412: NEG
90413: PUSH
90414: LD_INT 1
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 2
90424: NEG
90425: PUSH
90426: LD_INT 2
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90455: LD_ADDR_VAR 0 57
90459: PUSH
90460: LD_INT 0
90462: PUSH
90463: LD_INT 0
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 0
90472: PUSH
90473: LD_INT 1
90475: NEG
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 1
90483: PUSH
90484: LD_INT 0
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 1
90493: PUSH
90494: LD_INT 1
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 0
90503: PUSH
90504: LD_INT 1
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 1
90513: NEG
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 1
90524: NEG
90525: PUSH
90526: LD_INT 1
90528: NEG
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: LD_INT 2
90540: NEG
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: LD_INT 2
90551: NEG
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: LD_INT 1
90562: NEG
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 2
90570: PUSH
90571: LD_INT 0
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 2
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 2
90590: PUSH
90591: LD_INT 2
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 1
90600: PUSH
90601: LD_INT 2
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: LD_INT 2
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 1
90620: NEG
90621: PUSH
90622: LD_INT 1
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 2
90631: NEG
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 2
90642: NEG
90643: PUSH
90644: LD_INT 1
90646: NEG
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 2
90654: NEG
90655: PUSH
90656: LD_INT 2
90658: NEG
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90685: LD_ADDR_VAR 0 58
90689: PUSH
90690: LD_INT 0
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 0
90702: PUSH
90703: LD_INT 1
90705: NEG
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 1
90713: PUSH
90714: LD_INT 0
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: LD_INT 1
90723: PUSH
90724: LD_INT 1
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 0
90733: PUSH
90734: LD_INT 1
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: NEG
90744: PUSH
90745: LD_INT 0
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 1
90754: NEG
90755: PUSH
90756: LD_INT 1
90758: NEG
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 1
90766: NEG
90767: PUSH
90768: LD_INT 2
90770: NEG
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 0
90778: PUSH
90779: LD_INT 2
90781: NEG
90782: PUSH
90783: EMPTY
90784: LIST
90785: LIST
90786: PUSH
90787: LD_INT 1
90789: PUSH
90790: LD_INT 1
90792: NEG
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 2
90800: PUSH
90801: LD_INT 0
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 2
90810: PUSH
90811: LD_INT 1
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 2
90820: PUSH
90821: LD_INT 2
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 1
90830: PUSH
90831: LD_INT 2
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: LD_INT 2
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: NEG
90851: PUSH
90852: LD_INT 1
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 2
90861: NEG
90862: PUSH
90863: LD_INT 0
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 2
90872: NEG
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 2
90884: NEG
90885: PUSH
90886: LD_INT 2
90888: NEG
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90915: LD_ADDR_VAR 0 59
90919: PUSH
90920: LD_INT 0
90922: PUSH
90923: LD_INT 0
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: LD_INT 0
90932: PUSH
90933: LD_INT 1
90935: NEG
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 1
90943: PUSH
90944: LD_INT 0
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: PUSH
90951: LD_INT 1
90953: PUSH
90954: LD_INT 1
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 0
90963: PUSH
90964: LD_INT 1
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 1
90973: NEG
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: PUSH
90982: LD_INT 1
90984: NEG
90985: PUSH
90986: LD_INT 1
90988: NEG
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91003: LD_ADDR_VAR 0 60
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: LD_INT 0
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 0
91020: PUSH
91021: LD_INT 1
91023: NEG
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 1
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 1
91041: PUSH
91042: LD_INT 1
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 1
91061: NEG
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 1
91072: NEG
91073: PUSH
91074: LD_INT 1
91076: NEG
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91091: LD_ADDR_VAR 0 61
91095: PUSH
91096: LD_INT 0
91098: PUSH
91099: LD_INT 0
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 0
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PUSH
91117: LD_INT 1
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 1
91129: PUSH
91130: LD_INT 1
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 0
91139: PUSH
91140: LD_INT 1
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 1
91149: NEG
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: LD_INT 1
91164: NEG
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91179: LD_ADDR_VAR 0 62
91183: PUSH
91184: LD_INT 0
91186: PUSH
91187: LD_INT 0
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: PUSH
91194: LD_INT 0
91196: PUSH
91197: LD_INT 1
91199: NEG
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 1
91217: PUSH
91218: LD_INT 1
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 0
91227: PUSH
91228: LD_INT 1
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: LD_INT 0
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 1
91248: NEG
91249: PUSH
91250: LD_INT 1
91252: NEG
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91267: LD_ADDR_VAR 0 63
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: LD_INT 0
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 0
91284: PUSH
91285: LD_INT 1
91287: NEG
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: LD_INT 1
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 0
91315: PUSH
91316: LD_INT 1
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 1
91325: NEG
91326: PUSH
91327: LD_INT 0
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: LD_INT 1
91336: NEG
91337: PUSH
91338: LD_INT 1
91340: NEG
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91355: LD_ADDR_VAR 0 64
91359: PUSH
91360: LD_INT 0
91362: PUSH
91363: LD_INT 0
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: LD_INT 0
91372: PUSH
91373: LD_INT 1
91375: NEG
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: LD_INT 0
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: LD_INT 1
91393: PUSH
91394: LD_INT 1
91396: PUSH
91397: EMPTY
91398: LIST
91399: LIST
91400: PUSH
91401: LD_INT 0
91403: PUSH
91404: LD_INT 1
91406: PUSH
91407: EMPTY
91408: LIST
91409: LIST
91410: PUSH
91411: LD_INT 1
91413: NEG
91414: PUSH
91415: LD_INT 0
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: LD_INT 1
91424: NEG
91425: PUSH
91426: LD_INT 1
91428: NEG
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: ST_TO_ADDR
// end ; 1 :
91443: GO 97340
91445: LD_INT 1
91447: DOUBLE
91448: EQUAL
91449: IFTRUE 91453
91451: GO 94076
91453: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91454: LD_ADDR_VAR 0 11
91458: PUSH
91459: LD_INT 1
91461: NEG
91462: PUSH
91463: LD_INT 3
91465: NEG
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 0
91473: PUSH
91474: LD_INT 3
91476: NEG
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 1
91484: PUSH
91485: LD_INT 2
91487: NEG
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: LIST
91497: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91498: LD_ADDR_VAR 0 12
91502: PUSH
91503: LD_INT 2
91505: PUSH
91506: LD_INT 1
91508: NEG
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 3
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 3
91526: PUSH
91527: LD_INT 1
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: LIST
91538: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91539: LD_ADDR_VAR 0 13
91543: PUSH
91544: LD_INT 3
91546: PUSH
91547: LD_INT 2
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 3
91556: PUSH
91557: LD_INT 3
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: LD_INT 3
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: LIST
91578: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91579: LD_ADDR_VAR 0 14
91583: PUSH
91584: LD_INT 1
91586: PUSH
91587: LD_INT 3
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 0
91596: PUSH
91597: LD_INT 3
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: NEG
91607: PUSH
91608: LD_INT 2
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: LIST
91619: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91620: LD_ADDR_VAR 0 15
91624: PUSH
91625: LD_INT 2
91627: NEG
91628: PUSH
91629: LD_INT 1
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 3
91638: NEG
91639: PUSH
91640: LD_INT 0
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: LD_INT 3
91649: NEG
91650: PUSH
91651: LD_INT 1
91653: NEG
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: LIST
91663: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91664: LD_ADDR_VAR 0 16
91668: PUSH
91669: LD_INT 2
91671: NEG
91672: PUSH
91673: LD_INT 3
91675: NEG
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 3
91683: NEG
91684: PUSH
91685: LD_INT 2
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 3
91695: NEG
91696: PUSH
91697: LD_INT 3
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91710: LD_ADDR_VAR 0 17
91714: PUSH
91715: LD_INT 1
91717: NEG
91718: PUSH
91719: LD_INT 3
91721: NEG
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: LD_INT 3
91732: NEG
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 1
91740: PUSH
91741: LD_INT 2
91743: NEG
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: LIST
91753: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91754: LD_ADDR_VAR 0 18
91758: PUSH
91759: LD_INT 2
91761: PUSH
91762: LD_INT 1
91764: NEG
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 3
91772: PUSH
91773: LD_INT 0
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: PUSH
91780: LD_INT 3
91782: PUSH
91783: LD_INT 1
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: LIST
91794: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91795: LD_ADDR_VAR 0 19
91799: PUSH
91800: LD_INT 3
91802: PUSH
91803: LD_INT 2
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 3
91812: PUSH
91813: LD_INT 3
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 2
91822: PUSH
91823: LD_INT 3
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91835: LD_ADDR_VAR 0 20
91839: PUSH
91840: LD_INT 1
91842: PUSH
91843: LD_INT 3
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 0
91852: PUSH
91853: LD_INT 3
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 1
91862: NEG
91863: PUSH
91864: LD_INT 2
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91876: LD_ADDR_VAR 0 21
91880: PUSH
91881: LD_INT 2
91883: NEG
91884: PUSH
91885: LD_INT 1
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 3
91894: NEG
91895: PUSH
91896: LD_INT 0
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 3
91905: NEG
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: LIST
91919: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91920: LD_ADDR_VAR 0 22
91924: PUSH
91925: LD_INT 2
91927: NEG
91928: PUSH
91929: LD_INT 3
91931: NEG
91932: PUSH
91933: EMPTY
91934: LIST
91935: LIST
91936: PUSH
91937: LD_INT 3
91939: NEG
91940: PUSH
91941: LD_INT 2
91943: NEG
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 3
91951: NEG
91952: PUSH
91953: LD_INT 3
91955: NEG
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: LIST
91965: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91966: LD_ADDR_VAR 0 23
91970: PUSH
91971: LD_INT 0
91973: PUSH
91974: LD_INT 3
91976: NEG
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 1
91984: NEG
91985: PUSH
91986: LD_INT 4
91988: NEG
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 1
91996: PUSH
91997: LD_INT 3
91999: NEG
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: LIST
92009: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92010: LD_ADDR_VAR 0 24
92014: PUSH
92015: LD_INT 3
92017: PUSH
92018: LD_INT 0
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: PUSH
92025: LD_INT 3
92027: PUSH
92028: LD_INT 1
92030: NEG
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 4
92038: PUSH
92039: LD_INT 1
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: EMPTY
92047: LIST
92048: LIST
92049: LIST
92050: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92051: LD_ADDR_VAR 0 25
92055: PUSH
92056: LD_INT 3
92058: PUSH
92059: LD_INT 3
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 4
92068: PUSH
92069: LD_INT 3
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 3
92078: PUSH
92079: LD_INT 4
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92091: LD_ADDR_VAR 0 26
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 3
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: PUSH
92109: LD_INT 4
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: LD_INT 1
92118: NEG
92119: PUSH
92120: LD_INT 3
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: LIST
92131: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92132: LD_ADDR_VAR 0 27
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: LD_INT 0
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 3
92150: NEG
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 4
92161: NEG
92162: PUSH
92163: LD_INT 1
92165: NEG
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: LIST
92175: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92176: LD_ADDR_VAR 0 28
92180: PUSH
92181: LD_INT 3
92183: NEG
92184: PUSH
92185: LD_INT 3
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 3
92195: NEG
92196: PUSH
92197: LD_INT 4
92199: NEG
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 4
92207: NEG
92208: PUSH
92209: LD_INT 3
92211: NEG
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92222: LD_ADDR_VAR 0 29
92226: PUSH
92227: LD_INT 1
92229: NEG
92230: PUSH
92231: LD_INT 3
92233: NEG
92234: PUSH
92235: EMPTY
92236: LIST
92237: LIST
92238: PUSH
92239: LD_INT 0
92241: PUSH
92242: LD_INT 3
92244: NEG
92245: PUSH
92246: EMPTY
92247: LIST
92248: LIST
92249: PUSH
92250: LD_INT 1
92252: PUSH
92253: LD_INT 2
92255: NEG
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 1
92263: NEG
92264: PUSH
92265: LD_INT 4
92267: NEG
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 0
92275: PUSH
92276: LD_INT 4
92278: NEG
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 1
92286: PUSH
92287: LD_INT 3
92289: NEG
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 1
92297: NEG
92298: PUSH
92299: LD_INT 5
92301: NEG
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 0
92309: PUSH
92310: LD_INT 5
92312: NEG
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 1
92320: PUSH
92321: LD_INT 4
92323: NEG
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 1
92331: NEG
92332: PUSH
92333: LD_INT 6
92335: NEG
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 0
92343: PUSH
92344: LD_INT 6
92346: NEG
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 1
92354: PUSH
92355: LD_INT 5
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92377: LD_ADDR_VAR 0 30
92381: PUSH
92382: LD_INT 2
92384: PUSH
92385: LD_INT 1
92387: NEG
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 3
92395: PUSH
92396: LD_INT 0
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 3
92405: PUSH
92406: LD_INT 1
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: LD_INT 3
92415: PUSH
92416: LD_INT 1
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 4
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 4
92436: PUSH
92437: LD_INT 1
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 4
92446: PUSH
92447: LD_INT 1
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 5
92457: PUSH
92458: LD_INT 0
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 5
92467: PUSH
92468: LD_INT 1
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 5
92477: PUSH
92478: LD_INT 1
92480: NEG
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 6
92488: PUSH
92489: LD_INT 0
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 6
92498: PUSH
92499: LD_INT 1
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92520: LD_ADDR_VAR 0 31
92524: PUSH
92525: LD_INT 3
92527: PUSH
92528: LD_INT 2
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 3
92537: PUSH
92538: LD_INT 3
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: LD_INT 3
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 4
92557: PUSH
92558: LD_INT 3
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 4
92567: PUSH
92568: LD_INT 4
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: LD_INT 4
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 5
92587: PUSH
92588: LD_INT 4
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 5
92597: PUSH
92598: LD_INT 5
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 4
92607: PUSH
92608: LD_INT 5
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 6
92617: PUSH
92618: LD_INT 5
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 6
92627: PUSH
92628: LD_INT 6
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 5
92637: PUSH
92638: LD_INT 6
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92659: LD_ADDR_VAR 0 32
92663: PUSH
92664: LD_INT 1
92666: PUSH
92667: LD_INT 3
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 0
92676: PUSH
92677: LD_INT 3
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: LD_INT 1
92686: NEG
92687: PUSH
92688: LD_INT 2
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: LD_INT 1
92697: PUSH
92698: LD_INT 4
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 0
92707: PUSH
92708: LD_INT 4
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 1
92717: NEG
92718: PUSH
92719: LD_INT 3
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 1
92728: PUSH
92729: LD_INT 5
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 0
92738: PUSH
92739: LD_INT 5
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 1
92748: NEG
92749: PUSH
92750: LD_INT 4
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: LD_INT 6
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: PUSH
92767: LD_INT 0
92769: PUSH
92770: LD_INT 6
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 1
92779: NEG
92780: PUSH
92781: LD_INT 5
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92802: LD_ADDR_VAR 0 33
92806: PUSH
92807: LD_INT 2
92809: NEG
92810: PUSH
92811: LD_INT 1
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: LD_INT 3
92820: NEG
92821: PUSH
92822: LD_INT 0
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 3
92831: NEG
92832: PUSH
92833: LD_INT 1
92835: NEG
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 3
92843: NEG
92844: PUSH
92845: LD_INT 1
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 4
92854: NEG
92855: PUSH
92856: LD_INT 0
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 4
92865: NEG
92866: PUSH
92867: LD_INT 1
92869: NEG
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 4
92877: NEG
92878: PUSH
92879: LD_INT 1
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 5
92888: NEG
92889: PUSH
92890: LD_INT 0
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 5
92899: NEG
92900: PUSH
92901: LD_INT 1
92903: NEG
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 5
92911: NEG
92912: PUSH
92913: LD_INT 1
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 6
92922: NEG
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 6
92933: NEG
92934: PUSH
92935: LD_INT 1
92937: NEG
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92957: LD_ADDR_VAR 0 34
92961: PUSH
92962: LD_INT 2
92964: NEG
92965: PUSH
92966: LD_INT 3
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 3
92976: NEG
92977: PUSH
92978: LD_INT 2
92980: NEG
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: PUSH
92986: LD_INT 3
92988: NEG
92989: PUSH
92990: LD_INT 3
92992: NEG
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 3
93000: NEG
93001: PUSH
93002: LD_INT 4
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 4
93012: NEG
93013: PUSH
93014: LD_INT 3
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 4
93024: NEG
93025: PUSH
93026: LD_INT 4
93028: NEG
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 4
93036: NEG
93037: PUSH
93038: LD_INT 5
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 5
93048: NEG
93049: PUSH
93050: LD_INT 4
93052: NEG
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 5
93060: NEG
93061: PUSH
93062: LD_INT 5
93064: NEG
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: LD_INT 5
93072: NEG
93073: PUSH
93074: LD_INT 6
93076: NEG
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 6
93084: NEG
93085: PUSH
93086: LD_INT 5
93088: NEG
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 6
93096: NEG
93097: PUSH
93098: LD_INT 6
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93120: LD_ADDR_VAR 0 41
93124: PUSH
93125: LD_INT 0
93127: PUSH
93128: LD_INT 2
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 1
93138: NEG
93139: PUSH
93140: LD_INT 3
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 1
93150: PUSH
93151: LD_INT 2
93153: NEG
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: LIST
93163: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93164: LD_ADDR_VAR 0 42
93168: PUSH
93169: LD_INT 2
93171: PUSH
93172: LD_INT 0
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 2
93181: PUSH
93182: LD_INT 1
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 3
93192: PUSH
93193: LD_INT 1
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: LIST
93204: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93205: LD_ADDR_VAR 0 43
93209: PUSH
93210: LD_INT 2
93212: PUSH
93213: LD_INT 2
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 3
93222: PUSH
93223: LD_INT 2
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 2
93232: PUSH
93233: LD_INT 3
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: LIST
93244: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93245: LD_ADDR_VAR 0 44
93249: PUSH
93250: LD_INT 0
93252: PUSH
93253: LD_INT 2
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 1
93262: PUSH
93263: LD_INT 3
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 1
93272: NEG
93273: PUSH
93274: LD_INT 2
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: LIST
93285: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93286: LD_ADDR_VAR 0 45
93290: PUSH
93291: LD_INT 2
93293: NEG
93294: PUSH
93295: LD_INT 0
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 2
93304: NEG
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 3
93315: NEG
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: LIST
93329: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93330: LD_ADDR_VAR 0 46
93334: PUSH
93335: LD_INT 2
93337: NEG
93338: PUSH
93339: LD_INT 2
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 2
93349: NEG
93350: PUSH
93351: LD_INT 3
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 3
93361: NEG
93362: PUSH
93363: LD_INT 2
93365: NEG
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: LIST
93375: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93376: LD_ADDR_VAR 0 47
93380: PUSH
93381: LD_INT 2
93383: NEG
93384: PUSH
93385: LD_INT 3
93387: NEG
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 1
93395: NEG
93396: PUSH
93397: LD_INT 3
93399: NEG
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93409: LD_ADDR_VAR 0 48
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: LD_INT 2
93419: NEG
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 2
93427: PUSH
93428: LD_INT 1
93430: NEG
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93440: LD_ADDR_VAR 0 49
93444: PUSH
93445: LD_INT 3
93447: PUSH
93448: LD_INT 1
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 3
93457: PUSH
93458: LD_INT 2
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93469: LD_ADDR_VAR 0 50
93473: PUSH
93474: LD_INT 2
93476: PUSH
93477: LD_INT 3
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 1
93486: PUSH
93487: LD_INT 3
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93498: LD_ADDR_VAR 0 51
93502: PUSH
93503: LD_INT 1
93505: NEG
93506: PUSH
93507: LD_INT 2
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 2
93516: NEG
93517: PUSH
93518: LD_INT 1
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93529: LD_ADDR_VAR 0 52
93533: PUSH
93534: LD_INT 3
93536: NEG
93537: PUSH
93538: LD_INT 1
93540: NEG
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 3
93548: NEG
93549: PUSH
93550: LD_INT 2
93552: NEG
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93562: LD_ADDR_VAR 0 53
93566: PUSH
93567: LD_INT 1
93569: NEG
93570: PUSH
93571: LD_INT 3
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 0
93581: PUSH
93582: LD_INT 3
93584: NEG
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: LD_INT 1
93592: PUSH
93593: LD_INT 2
93595: NEG
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: LIST
93605: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93606: LD_ADDR_VAR 0 54
93610: PUSH
93611: LD_INT 2
93613: PUSH
93614: LD_INT 1
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 3
93624: PUSH
93625: LD_INT 0
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 3
93634: PUSH
93635: LD_INT 1
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: LIST
93646: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93647: LD_ADDR_VAR 0 55
93651: PUSH
93652: LD_INT 3
93654: PUSH
93655: LD_INT 2
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 3
93664: PUSH
93665: LD_INT 3
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: LD_INT 2
93674: PUSH
93675: LD_INT 3
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: LIST
93686: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93687: LD_ADDR_VAR 0 56
93691: PUSH
93692: LD_INT 1
93694: PUSH
93695: LD_INT 3
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PUSH
93702: LD_INT 0
93704: PUSH
93705: LD_INT 3
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: PUSH
93712: LD_INT 1
93714: NEG
93715: PUSH
93716: LD_INT 2
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: LIST
93727: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93728: LD_ADDR_VAR 0 57
93732: PUSH
93733: LD_INT 2
93735: NEG
93736: PUSH
93737: LD_INT 1
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: LD_INT 3
93746: NEG
93747: PUSH
93748: LD_INT 0
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: LD_INT 3
93757: NEG
93758: PUSH
93759: LD_INT 1
93761: NEG
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: LIST
93771: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93772: LD_ADDR_VAR 0 58
93776: PUSH
93777: LD_INT 2
93779: NEG
93780: PUSH
93781: LD_INT 3
93783: NEG
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: PUSH
93789: LD_INT 3
93791: NEG
93792: PUSH
93793: LD_INT 2
93795: NEG
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 3
93803: NEG
93804: PUSH
93805: LD_INT 3
93807: NEG
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: LIST
93817: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93818: LD_ADDR_VAR 0 59
93822: PUSH
93823: LD_INT 1
93825: NEG
93826: PUSH
93827: LD_INT 2
93829: NEG
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 0
93837: PUSH
93838: LD_INT 2
93840: NEG
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 1
93848: PUSH
93849: LD_INT 1
93851: NEG
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: LIST
93861: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93862: LD_ADDR_VAR 0 60
93866: PUSH
93867: LD_INT 1
93869: PUSH
93870: LD_INT 1
93872: NEG
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 2
93880: PUSH
93881: LD_INT 0
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 2
93890: PUSH
93891: LD_INT 1
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: LIST
93902: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93903: LD_ADDR_VAR 0 61
93907: PUSH
93908: LD_INT 2
93910: PUSH
93911: LD_INT 1
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 2
93920: PUSH
93921: LD_INT 2
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: LD_INT 1
93930: PUSH
93931: LD_INT 2
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93943: LD_ADDR_VAR 0 62
93947: PUSH
93948: LD_INT 1
93950: PUSH
93951: LD_INT 2
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 0
93960: PUSH
93961: LD_INT 2
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 1
93970: NEG
93971: PUSH
93972: LD_INT 1
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: LIST
93983: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93984: LD_ADDR_VAR 0 63
93988: PUSH
93989: LD_INT 1
93991: NEG
93992: PUSH
93993: LD_INT 1
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 2
94002: NEG
94003: PUSH
94004: LD_INT 0
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 2
94013: NEG
94014: PUSH
94015: LD_INT 1
94017: NEG
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: LIST
94027: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94028: LD_ADDR_VAR 0 64
94032: PUSH
94033: LD_INT 1
94035: NEG
94036: PUSH
94037: LD_INT 2
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 2
94047: NEG
94048: PUSH
94049: LD_INT 1
94051: NEG
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 2
94059: NEG
94060: PUSH
94061: LD_INT 2
94063: NEG
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: ST_TO_ADDR
// end ; 2 :
94074: GO 97340
94076: LD_INT 2
94078: DOUBLE
94079: EQUAL
94080: IFTRUE 94084
94082: GO 97339
94084: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94085: LD_ADDR_VAR 0 29
94089: PUSH
94090: LD_INT 4
94092: PUSH
94093: LD_INT 0
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 4
94102: PUSH
94103: LD_INT 1
94105: NEG
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 5
94113: PUSH
94114: LD_INT 0
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 5
94123: PUSH
94124: LD_INT 1
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 4
94133: PUSH
94134: LD_INT 1
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: PUSH
94141: LD_INT 3
94143: PUSH
94144: LD_INT 0
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 3
94153: PUSH
94154: LD_INT 1
94156: NEG
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 3
94164: PUSH
94165: LD_INT 2
94167: NEG
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 5
94175: PUSH
94176: LD_INT 2
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 3
94185: PUSH
94186: LD_INT 3
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 3
94195: PUSH
94196: LD_INT 2
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 4
94205: PUSH
94206: LD_INT 3
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 4
94215: PUSH
94216: LD_INT 4
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 3
94225: PUSH
94226: LD_INT 4
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 2
94235: PUSH
94236: LD_INT 3
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 2
94245: PUSH
94246: LD_INT 2
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 4
94255: PUSH
94256: LD_INT 2
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 2
94265: PUSH
94266: LD_INT 4
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 0
94275: PUSH
94276: LD_INT 4
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 0
94285: PUSH
94286: LD_INT 3
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 1
94295: PUSH
94296: LD_INT 4
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PUSH
94303: LD_INT 1
94305: PUSH
94306: LD_INT 5
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 0
94315: PUSH
94316: LD_INT 5
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 1
94325: NEG
94326: PUSH
94327: LD_INT 4
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 1
94336: NEG
94337: PUSH
94338: LD_INT 3
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 2
94347: PUSH
94348: LD_INT 5
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 2
94357: NEG
94358: PUSH
94359: LD_INT 3
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 3
94368: NEG
94369: PUSH
94370: LD_INT 0
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 3
94379: NEG
94380: PUSH
94381: LD_INT 1
94383: NEG
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 2
94391: NEG
94392: PUSH
94393: LD_INT 0
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 2
94402: NEG
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 3
94413: NEG
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 4
94424: NEG
94425: PUSH
94426: LD_INT 0
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 4
94435: NEG
94436: PUSH
94437: LD_INT 1
94439: NEG
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 4
94447: NEG
94448: PUSH
94449: LD_INT 2
94451: NEG
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 2
94459: NEG
94460: PUSH
94461: LD_INT 2
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 4
94470: NEG
94471: PUSH
94472: LD_INT 4
94474: NEG
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 4
94482: NEG
94483: PUSH
94484: LD_INT 5
94486: NEG
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 3
94494: NEG
94495: PUSH
94496: LD_INT 4
94498: NEG
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: LD_INT 3
94506: NEG
94507: PUSH
94508: LD_INT 3
94510: NEG
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 4
94518: NEG
94519: PUSH
94520: LD_INT 3
94522: NEG
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: LD_INT 5
94530: NEG
94531: PUSH
94532: LD_INT 4
94534: NEG
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 5
94542: NEG
94543: PUSH
94544: LD_INT 5
94546: NEG
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 3
94554: NEG
94555: PUSH
94556: LD_INT 5
94558: NEG
94559: PUSH
94560: EMPTY
94561: LIST
94562: LIST
94563: PUSH
94564: LD_INT 5
94566: NEG
94567: PUSH
94568: LD_INT 3
94570: NEG
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94623: LD_ADDR_VAR 0 30
94627: PUSH
94628: LD_INT 4
94630: PUSH
94631: LD_INT 4
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 4
94640: PUSH
94641: LD_INT 3
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 5
94650: PUSH
94651: LD_INT 4
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 5
94660: PUSH
94661: LD_INT 5
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 4
94670: PUSH
94671: LD_INT 5
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 3
94680: PUSH
94681: LD_INT 4
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 3
94690: PUSH
94691: LD_INT 3
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 5
94700: PUSH
94701: LD_INT 3
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 3
94710: PUSH
94711: LD_INT 5
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 0
94720: PUSH
94721: LD_INT 3
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 0
94730: PUSH
94731: LD_INT 2
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 1
94740: PUSH
94741: LD_INT 3
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 1
94750: PUSH
94751: LD_INT 4
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 0
94760: PUSH
94761: LD_INT 4
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 1
94770: NEG
94771: PUSH
94772: LD_INT 3
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 1
94781: NEG
94782: PUSH
94783: LD_INT 2
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 2
94792: PUSH
94793: LD_INT 4
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 2
94802: NEG
94803: PUSH
94804: LD_INT 2
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 4
94813: NEG
94814: PUSH
94815: LD_INT 0
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 4
94824: NEG
94825: PUSH
94826: LD_INT 1
94828: NEG
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 3
94836: NEG
94837: PUSH
94838: LD_INT 0
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 3
94847: NEG
94848: PUSH
94849: LD_INT 1
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 4
94858: NEG
94859: PUSH
94860: LD_INT 1
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: PUSH
94867: LD_INT 5
94869: NEG
94870: PUSH
94871: LD_INT 0
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 5
94880: NEG
94881: PUSH
94882: LD_INT 1
94884: NEG
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 5
94892: NEG
94893: PUSH
94894: LD_INT 2
94896: NEG
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 3
94904: NEG
94905: PUSH
94906: LD_INT 2
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 3
94915: NEG
94916: PUSH
94917: LD_INT 3
94919: NEG
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 3
94927: NEG
94928: PUSH
94929: LD_INT 4
94931: NEG
94932: PUSH
94933: EMPTY
94934: LIST
94935: LIST
94936: PUSH
94937: LD_INT 2
94939: NEG
94940: PUSH
94941: LD_INT 3
94943: NEG
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 2
94951: NEG
94952: PUSH
94953: LD_INT 2
94955: NEG
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 3
94963: NEG
94964: PUSH
94965: LD_INT 2
94967: NEG
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 4
94975: NEG
94976: PUSH
94977: LD_INT 3
94979: NEG
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 4
94987: NEG
94988: PUSH
94989: LD_INT 4
94991: NEG
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 2
94999: NEG
95000: PUSH
95001: LD_INT 4
95003: NEG
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: PUSH
95009: LD_INT 4
95011: NEG
95012: PUSH
95013: LD_INT 2
95015: NEG
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: LD_INT 0
95023: PUSH
95024: LD_INT 4
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 0
95034: PUSH
95035: LD_INT 5
95037: NEG
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 1
95045: PUSH
95046: LD_INT 4
95048: NEG
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 1
95056: PUSH
95057: LD_INT 3
95059: NEG
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 0
95067: PUSH
95068: LD_INT 3
95070: NEG
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 1
95078: NEG
95079: PUSH
95080: LD_INT 4
95082: NEG
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 1
95090: NEG
95091: PUSH
95092: LD_INT 5
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 2
95102: PUSH
95103: LD_INT 3
95105: NEG
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 2
95113: NEG
95114: PUSH
95115: LD_INT 5
95117: NEG
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95170: LD_ADDR_VAR 0 31
95174: PUSH
95175: LD_INT 0
95177: PUSH
95178: LD_INT 4
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 0
95187: PUSH
95188: LD_INT 3
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 1
95197: PUSH
95198: LD_INT 4
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 1
95207: PUSH
95208: LD_INT 5
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: LD_INT 5
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 1
95227: NEG
95228: PUSH
95229: LD_INT 4
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 1
95238: NEG
95239: PUSH
95240: LD_INT 3
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 2
95249: PUSH
95250: LD_INT 5
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 2
95259: NEG
95260: PUSH
95261: LD_INT 3
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 3
95270: NEG
95271: PUSH
95272: LD_INT 0
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 3
95281: NEG
95282: PUSH
95283: LD_INT 1
95285: NEG
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: LD_INT 2
95293: NEG
95294: PUSH
95295: LD_INT 0
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 2
95304: NEG
95305: PUSH
95306: LD_INT 1
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 3
95315: NEG
95316: PUSH
95317: LD_INT 1
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 4
95326: NEG
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 4
95337: NEG
95338: PUSH
95339: LD_INT 1
95341: NEG
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 4
95349: NEG
95350: PUSH
95351: LD_INT 2
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 2
95361: NEG
95362: PUSH
95363: LD_INT 2
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 4
95372: NEG
95373: PUSH
95374: LD_INT 4
95376: NEG
95377: PUSH
95378: EMPTY
95379: LIST
95380: LIST
95381: PUSH
95382: LD_INT 4
95384: NEG
95385: PUSH
95386: LD_INT 5
95388: NEG
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: PUSH
95394: LD_INT 3
95396: NEG
95397: PUSH
95398: LD_INT 4
95400: NEG
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 3
95408: NEG
95409: PUSH
95410: LD_INT 3
95412: NEG
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 4
95420: NEG
95421: PUSH
95422: LD_INT 3
95424: NEG
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 5
95432: NEG
95433: PUSH
95434: LD_INT 4
95436: NEG
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 5
95444: NEG
95445: PUSH
95446: LD_INT 5
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 3
95456: NEG
95457: PUSH
95458: LD_INT 5
95460: NEG
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: LD_INT 5
95468: NEG
95469: PUSH
95470: LD_INT 3
95472: NEG
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: LD_INT 0
95480: PUSH
95481: LD_INT 3
95483: NEG
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: PUSH
95489: LD_INT 0
95491: PUSH
95492: LD_INT 4
95494: NEG
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: LD_INT 1
95502: PUSH
95503: LD_INT 3
95505: NEG
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 1
95513: PUSH
95514: LD_INT 2
95516: NEG
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 0
95524: PUSH
95525: LD_INT 2
95527: NEG
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 1
95535: NEG
95536: PUSH
95537: LD_INT 3
95539: NEG
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 1
95547: NEG
95548: PUSH
95549: LD_INT 4
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 2
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 2
95570: NEG
95571: PUSH
95572: LD_INT 4
95574: NEG
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 4
95582: PUSH
95583: LD_INT 0
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 4
95592: PUSH
95593: LD_INT 1
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 5
95603: PUSH
95604: LD_INT 0
95606: PUSH
95607: EMPTY
95608: LIST
95609: LIST
95610: PUSH
95611: LD_INT 5
95613: PUSH
95614: LD_INT 1
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PUSH
95621: LD_INT 4
95623: PUSH
95624: LD_INT 1
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 3
95633: PUSH
95634: LD_INT 0
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: LD_INT 3
95643: PUSH
95644: LD_INT 1
95646: NEG
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 3
95654: PUSH
95655: LD_INT 2
95657: NEG
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 5
95665: PUSH
95666: LD_INT 2
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95720: LD_ADDR_VAR 0 32
95724: PUSH
95725: LD_INT 4
95727: NEG
95728: PUSH
95729: LD_INT 0
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 4
95738: NEG
95739: PUSH
95740: LD_INT 1
95742: NEG
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 3
95750: NEG
95751: PUSH
95752: LD_INT 0
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 3
95761: NEG
95762: PUSH
95763: LD_INT 1
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 4
95772: NEG
95773: PUSH
95774: LD_INT 1
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 5
95783: NEG
95784: PUSH
95785: LD_INT 0
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 5
95794: NEG
95795: PUSH
95796: LD_INT 1
95798: NEG
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 5
95806: NEG
95807: PUSH
95808: LD_INT 2
95810: NEG
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 3
95818: NEG
95819: PUSH
95820: LD_INT 2
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 3
95829: NEG
95830: PUSH
95831: LD_INT 3
95833: NEG
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: PUSH
95839: LD_INT 3
95841: NEG
95842: PUSH
95843: LD_INT 4
95845: NEG
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PUSH
95851: LD_INT 2
95853: NEG
95854: PUSH
95855: LD_INT 3
95857: NEG
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 2
95865: NEG
95866: PUSH
95867: LD_INT 2
95869: NEG
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: NEG
95878: PUSH
95879: LD_INT 2
95881: NEG
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 4
95889: NEG
95890: PUSH
95891: LD_INT 3
95893: NEG
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 4
95901: NEG
95902: PUSH
95903: LD_INT 4
95905: NEG
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 2
95913: NEG
95914: PUSH
95915: LD_INT 4
95917: NEG
95918: PUSH
95919: EMPTY
95920: LIST
95921: LIST
95922: PUSH
95923: LD_INT 4
95925: NEG
95926: PUSH
95927: LD_INT 2
95929: NEG
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 0
95937: PUSH
95938: LD_INT 4
95940: NEG
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: LD_INT 0
95948: PUSH
95949: LD_INT 5
95951: NEG
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: LD_INT 1
95959: PUSH
95960: LD_INT 4
95962: NEG
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: LD_INT 3
95973: NEG
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: LD_INT 0
95981: PUSH
95982: LD_INT 3
95984: NEG
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 1
95992: NEG
95993: PUSH
95994: LD_INT 4
95996: NEG
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 1
96004: NEG
96005: PUSH
96006: LD_INT 5
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 2
96016: PUSH
96017: LD_INT 3
96019: NEG
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 2
96027: NEG
96028: PUSH
96029: LD_INT 5
96031: NEG
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 3
96039: PUSH
96040: LD_INT 0
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PUSH
96047: LD_INT 3
96049: PUSH
96050: LD_INT 1
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 4
96060: PUSH
96061: LD_INT 0
96063: PUSH
96064: EMPTY
96065: LIST
96066: LIST
96067: PUSH
96068: LD_INT 4
96070: PUSH
96071: LD_INT 1
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 3
96080: PUSH
96081: LD_INT 1
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 2
96090: PUSH
96091: LD_INT 0
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 2
96100: PUSH
96101: LD_INT 1
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 2
96111: PUSH
96112: LD_INT 2
96114: NEG
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 4
96122: PUSH
96123: LD_INT 2
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 4
96132: PUSH
96133: LD_INT 4
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 4
96142: PUSH
96143: LD_INT 3
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 5
96152: PUSH
96153: LD_INT 4
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 5
96162: PUSH
96163: LD_INT 5
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 4
96172: PUSH
96173: LD_INT 5
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 3
96182: PUSH
96183: LD_INT 4
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 3
96192: PUSH
96193: LD_INT 3
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 5
96202: PUSH
96203: LD_INT 3
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 3
96212: PUSH
96213: LD_INT 5
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: LIST
96235: LIST
96236: LIST
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96267: LD_ADDR_VAR 0 33
96271: PUSH
96272: LD_INT 4
96274: NEG
96275: PUSH
96276: LD_INT 4
96278: NEG
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: LD_INT 4
96286: NEG
96287: PUSH
96288: LD_INT 5
96290: NEG
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: PUSH
96296: LD_INT 3
96298: NEG
96299: PUSH
96300: LD_INT 4
96302: NEG
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: PUSH
96308: LD_INT 3
96310: NEG
96311: PUSH
96312: LD_INT 3
96314: NEG
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: PUSH
96320: LD_INT 4
96322: NEG
96323: PUSH
96324: LD_INT 3
96326: NEG
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 5
96334: NEG
96335: PUSH
96336: LD_INT 4
96338: NEG
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 5
96346: NEG
96347: PUSH
96348: LD_INT 5
96350: NEG
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 3
96358: NEG
96359: PUSH
96360: LD_INT 5
96362: NEG
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: LD_INT 5
96370: NEG
96371: PUSH
96372: LD_INT 3
96374: NEG
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: PUSH
96380: LD_INT 0
96382: PUSH
96383: LD_INT 3
96385: NEG
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: LD_INT 0
96393: PUSH
96394: LD_INT 4
96396: NEG
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 1
96404: PUSH
96405: LD_INT 3
96407: NEG
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 1
96415: PUSH
96416: LD_INT 2
96418: NEG
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 0
96426: PUSH
96427: LD_INT 2
96429: NEG
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 1
96437: NEG
96438: PUSH
96439: LD_INT 3
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 1
96449: NEG
96450: PUSH
96451: LD_INT 4
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 2
96461: PUSH
96462: LD_INT 2
96464: NEG
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 2
96472: NEG
96473: PUSH
96474: LD_INT 4
96476: NEG
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 4
96484: PUSH
96485: LD_INT 0
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 4
96494: PUSH
96495: LD_INT 1
96497: NEG
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 5
96505: PUSH
96506: LD_INT 0
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 5
96515: PUSH
96516: LD_INT 1
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 4
96525: PUSH
96526: LD_INT 1
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: LD_INT 3
96535: PUSH
96536: LD_INT 0
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 3
96545: PUSH
96546: LD_INT 1
96548: NEG
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 3
96556: PUSH
96557: LD_INT 2
96559: NEG
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 5
96567: PUSH
96568: LD_INT 2
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 3
96577: PUSH
96578: LD_INT 3
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 3
96587: PUSH
96588: LD_INT 2
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 4
96597: PUSH
96598: LD_INT 3
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 4
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 3
96617: PUSH
96618: LD_INT 4
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: LD_INT 3
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 2
96637: PUSH
96638: LD_INT 2
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 4
96647: PUSH
96648: LD_INT 2
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 2
96657: PUSH
96658: LD_INT 4
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 0
96667: PUSH
96668: LD_INT 4
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 0
96677: PUSH
96678: LD_INT 3
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 1
96687: PUSH
96688: LD_INT 4
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 1
96697: PUSH
96698: LD_INT 5
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 0
96707: PUSH
96708: LD_INT 5
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 1
96717: NEG
96718: PUSH
96719: LD_INT 4
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 1
96728: NEG
96729: PUSH
96730: LD_INT 3
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 2
96739: PUSH
96740: LD_INT 5
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 2
96749: NEG
96750: PUSH
96751: LD_INT 3
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96805: LD_ADDR_VAR 0 34
96809: PUSH
96810: LD_INT 0
96812: PUSH
96813: LD_INT 4
96815: NEG
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 0
96823: PUSH
96824: LD_INT 5
96826: NEG
96827: PUSH
96828: EMPTY
96829: LIST
96830: LIST
96831: PUSH
96832: LD_INT 1
96834: PUSH
96835: LD_INT 4
96837: NEG
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: LD_INT 1
96845: PUSH
96846: LD_INT 3
96848: NEG
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 0
96856: PUSH
96857: LD_INT 3
96859: NEG
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: PUSH
96865: LD_INT 1
96867: NEG
96868: PUSH
96869: LD_INT 4
96871: NEG
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: LD_INT 1
96879: NEG
96880: PUSH
96881: LD_INT 5
96883: NEG
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 2
96891: PUSH
96892: LD_INT 3
96894: NEG
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PUSH
96900: LD_INT 2
96902: NEG
96903: PUSH
96904: LD_INT 5
96906: NEG
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: PUSH
96912: LD_INT 3
96914: PUSH
96915: LD_INT 0
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: PUSH
96922: LD_INT 3
96924: PUSH
96925: LD_INT 1
96927: NEG
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 4
96935: PUSH
96936: LD_INT 0
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 4
96945: PUSH
96946: LD_INT 1
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 3
96955: PUSH
96956: LD_INT 1
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 2
96965: PUSH
96966: LD_INT 0
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 2
96975: PUSH
96976: LD_INT 1
96978: NEG
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 2
96986: PUSH
96987: LD_INT 2
96989: NEG
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 4
96997: PUSH
96998: LD_INT 2
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: LD_INT 4
97007: PUSH
97008: LD_INT 4
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 4
97017: PUSH
97018: LD_INT 3
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: LD_INT 5
97027: PUSH
97028: LD_INT 4
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 5
97037: PUSH
97038: LD_INT 5
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 4
97047: PUSH
97048: LD_INT 5
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 3
97057: PUSH
97058: LD_INT 4
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: PUSH
97065: LD_INT 3
97067: PUSH
97068: LD_INT 3
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 5
97077: PUSH
97078: LD_INT 3
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 3
97087: PUSH
97088: LD_INT 5
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 0
97097: PUSH
97098: LD_INT 3
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 0
97107: PUSH
97108: LD_INT 2
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 1
97117: PUSH
97118: LD_INT 3
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 1
97127: PUSH
97128: LD_INT 4
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 0
97137: PUSH
97138: LD_INT 4
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 1
97147: NEG
97148: PUSH
97149: LD_INT 3
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: PUSH
97156: LD_INT 1
97158: NEG
97159: PUSH
97160: LD_INT 2
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 2
97169: PUSH
97170: LD_INT 4
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_INT 2
97179: NEG
97180: PUSH
97181: LD_INT 2
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: LD_INT 4
97190: NEG
97191: PUSH
97192: LD_INT 0
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: LD_INT 4
97201: NEG
97202: PUSH
97203: LD_INT 1
97205: NEG
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: PUSH
97211: LD_INT 3
97213: NEG
97214: PUSH
97215: LD_INT 0
97217: PUSH
97218: EMPTY
97219: LIST
97220: LIST
97221: PUSH
97222: LD_INT 3
97224: NEG
97225: PUSH
97226: LD_INT 1
97228: PUSH
97229: EMPTY
97230: LIST
97231: LIST
97232: PUSH
97233: LD_INT 4
97235: NEG
97236: PUSH
97237: LD_INT 1
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 5
97246: NEG
97247: PUSH
97248: LD_INT 0
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: LD_INT 5
97257: NEG
97258: PUSH
97259: LD_INT 1
97261: NEG
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: PUSH
97267: LD_INT 5
97269: NEG
97270: PUSH
97271: LD_INT 2
97273: NEG
97274: PUSH
97275: EMPTY
97276: LIST
97277: LIST
97278: PUSH
97279: LD_INT 3
97281: NEG
97282: PUSH
97283: LD_INT 2
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: ST_TO_ADDR
// end ; end ;
97337: GO 97340
97339: POP
// case btype of b_depot , b_warehouse :
97340: LD_VAR 0 1
97344: PUSH
97345: LD_INT 0
97347: DOUBLE
97348: EQUAL
97349: IFTRUE 97359
97351: LD_INT 1
97353: DOUBLE
97354: EQUAL
97355: IFTRUE 97359
97357: GO 97560
97359: POP
// case nation of nation_american :
97360: LD_VAR 0 5
97364: PUSH
97365: LD_INT 1
97367: DOUBLE
97368: EQUAL
97369: IFTRUE 97373
97371: GO 97429
97373: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97374: LD_ADDR_VAR 0 9
97378: PUSH
97379: LD_VAR 0 11
97383: PUSH
97384: LD_VAR 0 12
97388: PUSH
97389: LD_VAR 0 13
97393: PUSH
97394: LD_VAR 0 14
97398: PUSH
97399: LD_VAR 0 15
97403: PUSH
97404: LD_VAR 0 16
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: PUSH
97417: LD_VAR 0 4
97421: PUSH
97422: LD_INT 1
97424: PLUS
97425: ARRAY
97426: ST_TO_ADDR
97427: GO 97558
97429: LD_INT 2
97431: DOUBLE
97432: EQUAL
97433: IFTRUE 97437
97435: GO 97493
97437: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97438: LD_ADDR_VAR 0 9
97442: PUSH
97443: LD_VAR 0 17
97447: PUSH
97448: LD_VAR 0 18
97452: PUSH
97453: LD_VAR 0 19
97457: PUSH
97458: LD_VAR 0 20
97462: PUSH
97463: LD_VAR 0 21
97467: PUSH
97468: LD_VAR 0 22
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: PUSH
97481: LD_VAR 0 4
97485: PUSH
97486: LD_INT 1
97488: PLUS
97489: ARRAY
97490: ST_TO_ADDR
97491: GO 97558
97493: LD_INT 3
97495: DOUBLE
97496: EQUAL
97497: IFTRUE 97501
97499: GO 97557
97501: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97502: LD_ADDR_VAR 0 9
97506: PUSH
97507: LD_VAR 0 23
97511: PUSH
97512: LD_VAR 0 24
97516: PUSH
97517: LD_VAR 0 25
97521: PUSH
97522: LD_VAR 0 26
97526: PUSH
97527: LD_VAR 0 27
97531: PUSH
97532: LD_VAR 0 28
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: PUSH
97545: LD_VAR 0 4
97549: PUSH
97550: LD_INT 1
97552: PLUS
97553: ARRAY
97554: ST_TO_ADDR
97555: GO 97558
97557: POP
97558: GO 98113
97560: LD_INT 2
97562: DOUBLE
97563: EQUAL
97564: IFTRUE 97574
97566: LD_INT 3
97568: DOUBLE
97569: EQUAL
97570: IFTRUE 97574
97572: GO 97630
97574: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97575: LD_ADDR_VAR 0 9
97579: PUSH
97580: LD_VAR 0 29
97584: PUSH
97585: LD_VAR 0 30
97589: PUSH
97590: LD_VAR 0 31
97594: PUSH
97595: LD_VAR 0 32
97599: PUSH
97600: LD_VAR 0 33
97604: PUSH
97605: LD_VAR 0 34
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: LIST
97617: PUSH
97618: LD_VAR 0 4
97622: PUSH
97623: LD_INT 1
97625: PLUS
97626: ARRAY
97627: ST_TO_ADDR
97628: GO 98113
97630: LD_INT 16
97632: DOUBLE
97633: EQUAL
97634: IFTRUE 97692
97636: LD_INT 17
97638: DOUBLE
97639: EQUAL
97640: IFTRUE 97692
97642: LD_INT 18
97644: DOUBLE
97645: EQUAL
97646: IFTRUE 97692
97648: LD_INT 19
97650: DOUBLE
97651: EQUAL
97652: IFTRUE 97692
97654: LD_INT 22
97656: DOUBLE
97657: EQUAL
97658: IFTRUE 97692
97660: LD_INT 20
97662: DOUBLE
97663: EQUAL
97664: IFTRUE 97692
97666: LD_INT 21
97668: DOUBLE
97669: EQUAL
97670: IFTRUE 97692
97672: LD_INT 23
97674: DOUBLE
97675: EQUAL
97676: IFTRUE 97692
97678: LD_INT 24
97680: DOUBLE
97681: EQUAL
97682: IFTRUE 97692
97684: LD_INT 25
97686: DOUBLE
97687: EQUAL
97688: IFTRUE 97692
97690: GO 97748
97692: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97693: LD_ADDR_VAR 0 9
97697: PUSH
97698: LD_VAR 0 35
97702: PUSH
97703: LD_VAR 0 36
97707: PUSH
97708: LD_VAR 0 37
97712: PUSH
97713: LD_VAR 0 38
97717: PUSH
97718: LD_VAR 0 39
97722: PUSH
97723: LD_VAR 0 40
97727: PUSH
97728: EMPTY
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: PUSH
97736: LD_VAR 0 4
97740: PUSH
97741: LD_INT 1
97743: PLUS
97744: ARRAY
97745: ST_TO_ADDR
97746: GO 98113
97748: LD_INT 6
97750: DOUBLE
97751: EQUAL
97752: IFTRUE 97804
97754: LD_INT 7
97756: DOUBLE
97757: EQUAL
97758: IFTRUE 97804
97760: LD_INT 8
97762: DOUBLE
97763: EQUAL
97764: IFTRUE 97804
97766: LD_INT 13
97768: DOUBLE
97769: EQUAL
97770: IFTRUE 97804
97772: LD_INT 12
97774: DOUBLE
97775: EQUAL
97776: IFTRUE 97804
97778: LD_INT 15
97780: DOUBLE
97781: EQUAL
97782: IFTRUE 97804
97784: LD_INT 11
97786: DOUBLE
97787: EQUAL
97788: IFTRUE 97804
97790: LD_INT 14
97792: DOUBLE
97793: EQUAL
97794: IFTRUE 97804
97796: LD_INT 10
97798: DOUBLE
97799: EQUAL
97800: IFTRUE 97804
97802: GO 97860
97804: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97805: LD_ADDR_VAR 0 9
97809: PUSH
97810: LD_VAR 0 41
97814: PUSH
97815: LD_VAR 0 42
97819: PUSH
97820: LD_VAR 0 43
97824: PUSH
97825: LD_VAR 0 44
97829: PUSH
97830: LD_VAR 0 45
97834: PUSH
97835: LD_VAR 0 46
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: PUSH
97848: LD_VAR 0 4
97852: PUSH
97853: LD_INT 1
97855: PLUS
97856: ARRAY
97857: ST_TO_ADDR
97858: GO 98113
97860: LD_INT 36
97862: DOUBLE
97863: EQUAL
97864: IFTRUE 97868
97866: GO 97924
97868: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97869: LD_ADDR_VAR 0 9
97873: PUSH
97874: LD_VAR 0 47
97878: PUSH
97879: LD_VAR 0 48
97883: PUSH
97884: LD_VAR 0 49
97888: PUSH
97889: LD_VAR 0 50
97893: PUSH
97894: LD_VAR 0 51
97898: PUSH
97899: LD_VAR 0 52
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: PUSH
97912: LD_VAR 0 4
97916: PUSH
97917: LD_INT 1
97919: PLUS
97920: ARRAY
97921: ST_TO_ADDR
97922: GO 98113
97924: LD_INT 4
97926: DOUBLE
97927: EQUAL
97928: IFTRUE 97950
97930: LD_INT 5
97932: DOUBLE
97933: EQUAL
97934: IFTRUE 97950
97936: LD_INT 34
97938: DOUBLE
97939: EQUAL
97940: IFTRUE 97950
97942: LD_INT 37
97944: DOUBLE
97945: EQUAL
97946: IFTRUE 97950
97948: GO 98006
97950: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97951: LD_ADDR_VAR 0 9
97955: PUSH
97956: LD_VAR 0 53
97960: PUSH
97961: LD_VAR 0 54
97965: PUSH
97966: LD_VAR 0 55
97970: PUSH
97971: LD_VAR 0 56
97975: PUSH
97976: LD_VAR 0 57
97980: PUSH
97981: LD_VAR 0 58
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: PUSH
97994: LD_VAR 0 4
97998: PUSH
97999: LD_INT 1
98001: PLUS
98002: ARRAY
98003: ST_TO_ADDR
98004: GO 98113
98006: LD_INT 31
98008: DOUBLE
98009: EQUAL
98010: IFTRUE 98056
98012: LD_INT 32
98014: DOUBLE
98015: EQUAL
98016: IFTRUE 98056
98018: LD_INT 33
98020: DOUBLE
98021: EQUAL
98022: IFTRUE 98056
98024: LD_INT 27
98026: DOUBLE
98027: EQUAL
98028: IFTRUE 98056
98030: LD_INT 26
98032: DOUBLE
98033: EQUAL
98034: IFTRUE 98056
98036: LD_INT 28
98038: DOUBLE
98039: EQUAL
98040: IFTRUE 98056
98042: LD_INT 29
98044: DOUBLE
98045: EQUAL
98046: IFTRUE 98056
98048: LD_INT 30
98050: DOUBLE
98051: EQUAL
98052: IFTRUE 98056
98054: GO 98112
98056: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98057: LD_ADDR_VAR 0 9
98061: PUSH
98062: LD_VAR 0 59
98066: PUSH
98067: LD_VAR 0 60
98071: PUSH
98072: LD_VAR 0 61
98076: PUSH
98077: LD_VAR 0 62
98081: PUSH
98082: LD_VAR 0 63
98086: PUSH
98087: LD_VAR 0 64
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: PUSH
98100: LD_VAR 0 4
98104: PUSH
98105: LD_INT 1
98107: PLUS
98108: ARRAY
98109: ST_TO_ADDR
98110: GO 98113
98112: POP
// temp_list2 = [ ] ;
98113: LD_ADDR_VAR 0 10
98117: PUSH
98118: EMPTY
98119: ST_TO_ADDR
// for i in temp_list do
98120: LD_ADDR_VAR 0 8
98124: PUSH
98125: LD_VAR 0 9
98129: PUSH
98130: FOR_IN
98131: IFFALSE 98183
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98133: LD_ADDR_VAR 0 10
98137: PUSH
98138: LD_VAR 0 10
98142: PUSH
98143: LD_VAR 0 8
98147: PUSH
98148: LD_INT 1
98150: ARRAY
98151: PUSH
98152: LD_VAR 0 2
98156: PLUS
98157: PUSH
98158: LD_VAR 0 8
98162: PUSH
98163: LD_INT 2
98165: ARRAY
98166: PUSH
98167: LD_VAR 0 3
98171: PLUS
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: EMPTY
98178: LIST
98179: ADD
98180: ST_TO_ADDR
98181: GO 98130
98183: POP
98184: POP
// result = temp_list2 ;
98185: LD_ADDR_VAR 0 7
98189: PUSH
98190: LD_VAR 0 10
98194: ST_TO_ADDR
// end ;
98195: LD_VAR 0 7
98199: RET
// export function EnemyInRange ( unit , dist ) ; begin
98200: LD_INT 0
98202: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98203: LD_ADDR_VAR 0 3
98207: PUSH
98208: LD_VAR 0 1
98212: PPUSH
98213: CALL_OW 255
98217: PPUSH
98218: LD_VAR 0 1
98222: PPUSH
98223: CALL_OW 250
98227: PPUSH
98228: LD_VAR 0 1
98232: PPUSH
98233: CALL_OW 251
98237: PPUSH
98238: LD_VAR 0 2
98242: PPUSH
98243: CALL 71596 0 4
98247: PUSH
98248: LD_INT 4
98250: ARRAY
98251: ST_TO_ADDR
// end ;
98252: LD_VAR 0 3
98256: RET
// export function PlayerSeeMe ( unit ) ; begin
98257: LD_INT 0
98259: PPUSH
// result := See ( your_side , unit ) ;
98260: LD_ADDR_VAR 0 2
98264: PUSH
98265: LD_OWVAR 2
98269: PPUSH
98270: LD_VAR 0 1
98274: PPUSH
98275: CALL_OW 292
98279: ST_TO_ADDR
// end ;
98280: LD_VAR 0 2
98284: RET
// export function ReverseDir ( unit ) ; begin
98285: LD_INT 0
98287: PPUSH
// if not unit then
98288: LD_VAR 0 1
98292: NOT
98293: IFFALSE 98297
// exit ;
98295: GO 98320
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98297: LD_ADDR_VAR 0 2
98301: PUSH
98302: LD_VAR 0 1
98306: PPUSH
98307: CALL_OW 254
98311: PUSH
98312: LD_INT 3
98314: PLUS
98315: PUSH
98316: LD_INT 6
98318: MOD
98319: ST_TO_ADDR
// end ;
98320: LD_VAR 0 2
98324: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98325: LD_INT 0
98327: PPUSH
98328: PPUSH
98329: PPUSH
98330: PPUSH
98331: PPUSH
// if not hexes then
98332: LD_VAR 0 2
98336: NOT
98337: IFFALSE 98341
// exit ;
98339: GO 98489
// dist := 9999 ;
98341: LD_ADDR_VAR 0 5
98345: PUSH
98346: LD_INT 9999
98348: ST_TO_ADDR
// for i = 1 to hexes do
98349: LD_ADDR_VAR 0 4
98353: PUSH
98354: DOUBLE
98355: LD_INT 1
98357: DEC
98358: ST_TO_ADDR
98359: LD_VAR 0 2
98363: PUSH
98364: FOR_TO
98365: IFFALSE 98477
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98367: LD_VAR 0 1
98371: PPUSH
98372: LD_VAR 0 2
98376: PUSH
98377: LD_VAR 0 4
98381: ARRAY
98382: PUSH
98383: LD_INT 1
98385: ARRAY
98386: PPUSH
98387: LD_VAR 0 2
98391: PUSH
98392: LD_VAR 0 4
98396: ARRAY
98397: PUSH
98398: LD_INT 2
98400: ARRAY
98401: PPUSH
98402: CALL_OW 297
98406: PUSH
98407: LD_VAR 0 5
98411: LESS
98412: IFFALSE 98475
// begin hex := hexes [ i ] ;
98414: LD_ADDR_VAR 0 7
98418: PUSH
98419: LD_VAR 0 2
98423: PUSH
98424: LD_VAR 0 4
98428: ARRAY
98429: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98430: LD_ADDR_VAR 0 5
98434: PUSH
98435: LD_VAR 0 1
98439: PPUSH
98440: LD_VAR 0 2
98444: PUSH
98445: LD_VAR 0 4
98449: ARRAY
98450: PUSH
98451: LD_INT 1
98453: ARRAY
98454: PPUSH
98455: LD_VAR 0 2
98459: PUSH
98460: LD_VAR 0 4
98464: ARRAY
98465: PUSH
98466: LD_INT 2
98468: ARRAY
98469: PPUSH
98470: CALL_OW 297
98474: ST_TO_ADDR
// end ; end ;
98475: GO 98364
98477: POP
98478: POP
// result := hex ;
98479: LD_ADDR_VAR 0 3
98483: PUSH
98484: LD_VAR 0 7
98488: ST_TO_ADDR
// end ;
98489: LD_VAR 0 3
98493: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98494: LD_INT 0
98496: PPUSH
98497: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98498: LD_VAR 0 1
98502: NOT
98503: PUSH
98504: LD_VAR 0 1
98508: PUSH
98509: LD_INT 21
98511: PUSH
98512: LD_INT 2
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 23
98521: PUSH
98522: LD_INT 2
98524: PUSH
98525: EMPTY
98526: LIST
98527: LIST
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PPUSH
98533: CALL_OW 69
98537: IN
98538: NOT
98539: OR
98540: IFFALSE 98544
// exit ;
98542: GO 98591
// for i = 1 to 3 do
98544: LD_ADDR_VAR 0 3
98548: PUSH
98549: DOUBLE
98550: LD_INT 1
98552: DEC
98553: ST_TO_ADDR
98554: LD_INT 3
98556: PUSH
98557: FOR_TO
98558: IFFALSE 98589
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98560: LD_VAR 0 1
98564: PPUSH
98565: CALL_OW 250
98569: PPUSH
98570: LD_VAR 0 1
98574: PPUSH
98575: CALL_OW 251
98579: PPUSH
98580: LD_INT 1
98582: PPUSH
98583: CALL_OW 453
98587: GO 98557
98589: POP
98590: POP
// end ;
98591: LD_VAR 0 2
98595: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98596: LD_INT 0
98598: PPUSH
98599: PPUSH
98600: PPUSH
98601: PPUSH
98602: PPUSH
98603: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98604: LD_VAR 0 1
98608: NOT
98609: PUSH
98610: LD_VAR 0 2
98614: NOT
98615: OR
98616: PUSH
98617: LD_VAR 0 1
98621: PPUSH
98622: CALL_OW 314
98626: OR
98627: IFFALSE 98631
// exit ;
98629: GO 99072
// x := GetX ( enemy_unit ) ;
98631: LD_ADDR_VAR 0 7
98635: PUSH
98636: LD_VAR 0 2
98640: PPUSH
98641: CALL_OW 250
98645: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98646: LD_ADDR_VAR 0 8
98650: PUSH
98651: LD_VAR 0 2
98655: PPUSH
98656: CALL_OW 251
98660: ST_TO_ADDR
// if not x or not y then
98661: LD_VAR 0 7
98665: NOT
98666: PUSH
98667: LD_VAR 0 8
98671: NOT
98672: OR
98673: IFFALSE 98677
// exit ;
98675: GO 99072
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98677: LD_ADDR_VAR 0 6
98681: PUSH
98682: LD_VAR 0 7
98686: PPUSH
98687: LD_INT 0
98689: PPUSH
98690: LD_INT 4
98692: PPUSH
98693: CALL_OW 272
98697: PUSH
98698: LD_VAR 0 8
98702: PPUSH
98703: LD_INT 0
98705: PPUSH
98706: LD_INT 4
98708: PPUSH
98709: CALL_OW 273
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PUSH
98718: LD_VAR 0 7
98722: PPUSH
98723: LD_INT 1
98725: PPUSH
98726: LD_INT 4
98728: PPUSH
98729: CALL_OW 272
98733: PUSH
98734: LD_VAR 0 8
98738: PPUSH
98739: LD_INT 1
98741: PPUSH
98742: LD_INT 4
98744: PPUSH
98745: CALL_OW 273
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: PUSH
98754: LD_VAR 0 7
98758: PPUSH
98759: LD_INT 2
98761: PPUSH
98762: LD_INT 4
98764: PPUSH
98765: CALL_OW 272
98769: PUSH
98770: LD_VAR 0 8
98774: PPUSH
98775: LD_INT 2
98777: PPUSH
98778: LD_INT 4
98780: PPUSH
98781: CALL_OW 273
98785: PUSH
98786: EMPTY
98787: LIST
98788: LIST
98789: PUSH
98790: LD_VAR 0 7
98794: PPUSH
98795: LD_INT 3
98797: PPUSH
98798: LD_INT 4
98800: PPUSH
98801: CALL_OW 272
98805: PUSH
98806: LD_VAR 0 8
98810: PPUSH
98811: LD_INT 3
98813: PPUSH
98814: LD_INT 4
98816: PPUSH
98817: CALL_OW 273
98821: PUSH
98822: EMPTY
98823: LIST
98824: LIST
98825: PUSH
98826: LD_VAR 0 7
98830: PPUSH
98831: LD_INT 4
98833: PPUSH
98834: LD_INT 4
98836: PPUSH
98837: CALL_OW 272
98841: PUSH
98842: LD_VAR 0 8
98846: PPUSH
98847: LD_INT 4
98849: PPUSH
98850: LD_INT 4
98852: PPUSH
98853: CALL_OW 273
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: PUSH
98862: LD_VAR 0 7
98866: PPUSH
98867: LD_INT 5
98869: PPUSH
98870: LD_INT 4
98872: PPUSH
98873: CALL_OW 272
98877: PUSH
98878: LD_VAR 0 8
98882: PPUSH
98883: LD_INT 5
98885: PPUSH
98886: LD_INT 4
98888: PPUSH
98889: CALL_OW 273
98893: PUSH
98894: EMPTY
98895: LIST
98896: LIST
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: LIST
98905: ST_TO_ADDR
// for i = tmp downto 1 do
98906: LD_ADDR_VAR 0 4
98910: PUSH
98911: DOUBLE
98912: LD_VAR 0 6
98916: INC
98917: ST_TO_ADDR
98918: LD_INT 1
98920: PUSH
98921: FOR_DOWNTO
98922: IFFALSE 99023
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98924: LD_VAR 0 6
98928: PUSH
98929: LD_VAR 0 4
98933: ARRAY
98934: PUSH
98935: LD_INT 1
98937: ARRAY
98938: PPUSH
98939: LD_VAR 0 6
98943: PUSH
98944: LD_VAR 0 4
98948: ARRAY
98949: PUSH
98950: LD_INT 2
98952: ARRAY
98953: PPUSH
98954: CALL_OW 488
98958: NOT
98959: PUSH
98960: LD_VAR 0 6
98964: PUSH
98965: LD_VAR 0 4
98969: ARRAY
98970: PUSH
98971: LD_INT 1
98973: ARRAY
98974: PPUSH
98975: LD_VAR 0 6
98979: PUSH
98980: LD_VAR 0 4
98984: ARRAY
98985: PUSH
98986: LD_INT 2
98988: ARRAY
98989: PPUSH
98990: CALL_OW 428
98994: PUSH
98995: LD_INT 0
98997: NONEQUAL
98998: OR
98999: IFFALSE 99021
// tmp := Delete ( tmp , i ) ;
99001: LD_ADDR_VAR 0 6
99005: PUSH
99006: LD_VAR 0 6
99010: PPUSH
99011: LD_VAR 0 4
99015: PPUSH
99016: CALL_OW 3
99020: ST_TO_ADDR
99021: GO 98921
99023: POP
99024: POP
// j := GetClosestHex ( unit , tmp ) ;
99025: LD_ADDR_VAR 0 5
99029: PUSH
99030: LD_VAR 0 1
99034: PPUSH
99035: LD_VAR 0 6
99039: PPUSH
99040: CALL 98325 0 2
99044: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99045: LD_VAR 0 1
99049: PPUSH
99050: LD_VAR 0 5
99054: PUSH
99055: LD_INT 1
99057: ARRAY
99058: PPUSH
99059: LD_VAR 0 5
99063: PUSH
99064: LD_INT 2
99066: ARRAY
99067: PPUSH
99068: CALL_OW 111
// end ;
99072: LD_VAR 0 3
99076: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99077: LD_INT 0
99079: PPUSH
99080: PPUSH
99081: PPUSH
// uc_side = 0 ;
99082: LD_ADDR_OWVAR 20
99086: PUSH
99087: LD_INT 0
99089: ST_TO_ADDR
// uc_nation = 0 ;
99090: LD_ADDR_OWVAR 21
99094: PUSH
99095: LD_INT 0
99097: ST_TO_ADDR
// InitHc_All ( ) ;
99098: CALL_OW 584
// InitVc ;
99102: CALL_OW 20
// if mastodonts then
99106: LD_VAR 0 6
99110: IFFALSE 99177
// for i = 1 to mastodonts do
99112: LD_ADDR_VAR 0 11
99116: PUSH
99117: DOUBLE
99118: LD_INT 1
99120: DEC
99121: ST_TO_ADDR
99122: LD_VAR 0 6
99126: PUSH
99127: FOR_TO
99128: IFFALSE 99175
// begin vc_chassis := 31 ;
99130: LD_ADDR_OWVAR 37
99134: PUSH
99135: LD_INT 31
99137: ST_TO_ADDR
// vc_control := control_rider ;
99138: LD_ADDR_OWVAR 38
99142: PUSH
99143: LD_INT 4
99145: ST_TO_ADDR
// animal := CreateVehicle ;
99146: LD_ADDR_VAR 0 12
99150: PUSH
99151: CALL_OW 45
99155: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99156: LD_VAR 0 12
99160: PPUSH
99161: LD_VAR 0 8
99165: PPUSH
99166: LD_INT 0
99168: PPUSH
99169: CALL 101365 0 3
// end ;
99173: GO 99127
99175: POP
99176: POP
// if horses then
99177: LD_VAR 0 5
99181: IFFALSE 99248
// for i = 1 to horses do
99183: LD_ADDR_VAR 0 11
99187: PUSH
99188: DOUBLE
99189: LD_INT 1
99191: DEC
99192: ST_TO_ADDR
99193: LD_VAR 0 5
99197: PUSH
99198: FOR_TO
99199: IFFALSE 99246
// begin hc_class := 21 ;
99201: LD_ADDR_OWVAR 28
99205: PUSH
99206: LD_INT 21
99208: ST_TO_ADDR
// hc_gallery :=  ;
99209: LD_ADDR_OWVAR 33
99213: PUSH
99214: LD_STRING 
99216: ST_TO_ADDR
// animal := CreateHuman ;
99217: LD_ADDR_VAR 0 12
99221: PUSH
99222: CALL_OW 44
99226: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99227: LD_VAR 0 12
99231: PPUSH
99232: LD_VAR 0 8
99236: PPUSH
99237: LD_INT 0
99239: PPUSH
99240: CALL 101365 0 3
// end ;
99244: GO 99198
99246: POP
99247: POP
// if birds then
99248: LD_VAR 0 1
99252: IFFALSE 99319
// for i = 1 to birds do
99254: LD_ADDR_VAR 0 11
99258: PUSH
99259: DOUBLE
99260: LD_INT 1
99262: DEC
99263: ST_TO_ADDR
99264: LD_VAR 0 1
99268: PUSH
99269: FOR_TO
99270: IFFALSE 99317
// begin hc_class = 18 ;
99272: LD_ADDR_OWVAR 28
99276: PUSH
99277: LD_INT 18
99279: ST_TO_ADDR
// hc_gallery =  ;
99280: LD_ADDR_OWVAR 33
99284: PUSH
99285: LD_STRING 
99287: ST_TO_ADDR
// animal := CreateHuman ;
99288: LD_ADDR_VAR 0 12
99292: PUSH
99293: CALL_OW 44
99297: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99298: LD_VAR 0 12
99302: PPUSH
99303: LD_VAR 0 8
99307: PPUSH
99308: LD_INT 0
99310: PPUSH
99311: CALL 101365 0 3
// end ;
99315: GO 99269
99317: POP
99318: POP
// if tigers then
99319: LD_VAR 0 2
99323: IFFALSE 99407
// for i = 1 to tigers do
99325: LD_ADDR_VAR 0 11
99329: PUSH
99330: DOUBLE
99331: LD_INT 1
99333: DEC
99334: ST_TO_ADDR
99335: LD_VAR 0 2
99339: PUSH
99340: FOR_TO
99341: IFFALSE 99405
// begin hc_class = class_tiger ;
99343: LD_ADDR_OWVAR 28
99347: PUSH
99348: LD_INT 14
99350: ST_TO_ADDR
// hc_gallery =  ;
99351: LD_ADDR_OWVAR 33
99355: PUSH
99356: LD_STRING 
99358: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99359: LD_ADDR_OWVAR 35
99363: PUSH
99364: LD_INT 7
99366: NEG
99367: PPUSH
99368: LD_INT 7
99370: PPUSH
99371: CALL_OW 12
99375: ST_TO_ADDR
// animal := CreateHuman ;
99376: LD_ADDR_VAR 0 12
99380: PUSH
99381: CALL_OW 44
99385: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99386: LD_VAR 0 12
99390: PPUSH
99391: LD_VAR 0 8
99395: PPUSH
99396: LD_INT 0
99398: PPUSH
99399: CALL 101365 0 3
// end ;
99403: GO 99340
99405: POP
99406: POP
// if apemans then
99407: LD_VAR 0 3
99411: IFFALSE 99534
// for i = 1 to apemans do
99413: LD_ADDR_VAR 0 11
99417: PUSH
99418: DOUBLE
99419: LD_INT 1
99421: DEC
99422: ST_TO_ADDR
99423: LD_VAR 0 3
99427: PUSH
99428: FOR_TO
99429: IFFALSE 99532
// begin hc_class = class_apeman ;
99431: LD_ADDR_OWVAR 28
99435: PUSH
99436: LD_INT 12
99438: ST_TO_ADDR
// hc_gallery =  ;
99439: LD_ADDR_OWVAR 33
99443: PUSH
99444: LD_STRING 
99446: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99447: LD_ADDR_OWVAR 35
99451: PUSH
99452: LD_INT 2
99454: NEG
99455: PPUSH
99456: LD_INT 2
99458: PPUSH
99459: CALL_OW 12
99463: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99464: LD_ADDR_OWVAR 31
99468: PUSH
99469: LD_INT 1
99471: PPUSH
99472: LD_INT 3
99474: PPUSH
99475: CALL_OW 12
99479: PUSH
99480: LD_INT 1
99482: PPUSH
99483: LD_INT 3
99485: PPUSH
99486: CALL_OW 12
99490: PUSH
99491: LD_INT 0
99493: PUSH
99494: LD_INT 0
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: ST_TO_ADDR
// animal := CreateHuman ;
99503: LD_ADDR_VAR 0 12
99507: PUSH
99508: CALL_OW 44
99512: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99513: LD_VAR 0 12
99517: PPUSH
99518: LD_VAR 0 8
99522: PPUSH
99523: LD_INT 0
99525: PPUSH
99526: CALL 101365 0 3
// end ;
99530: GO 99428
99532: POP
99533: POP
// if enchidnas then
99534: LD_VAR 0 4
99538: IFFALSE 99605
// for i = 1 to enchidnas do
99540: LD_ADDR_VAR 0 11
99544: PUSH
99545: DOUBLE
99546: LD_INT 1
99548: DEC
99549: ST_TO_ADDR
99550: LD_VAR 0 4
99554: PUSH
99555: FOR_TO
99556: IFFALSE 99603
// begin hc_class = 13 ;
99558: LD_ADDR_OWVAR 28
99562: PUSH
99563: LD_INT 13
99565: ST_TO_ADDR
// hc_gallery =  ;
99566: LD_ADDR_OWVAR 33
99570: PUSH
99571: LD_STRING 
99573: ST_TO_ADDR
// animal := CreateHuman ;
99574: LD_ADDR_VAR 0 12
99578: PUSH
99579: CALL_OW 44
99583: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99584: LD_VAR 0 12
99588: PPUSH
99589: LD_VAR 0 8
99593: PPUSH
99594: LD_INT 0
99596: PPUSH
99597: CALL 101365 0 3
// end ;
99601: GO 99555
99603: POP
99604: POP
// if fishes then
99605: LD_VAR 0 7
99609: IFFALSE 99676
// for i = 1 to fishes do
99611: LD_ADDR_VAR 0 11
99615: PUSH
99616: DOUBLE
99617: LD_INT 1
99619: DEC
99620: ST_TO_ADDR
99621: LD_VAR 0 7
99625: PUSH
99626: FOR_TO
99627: IFFALSE 99674
// begin hc_class = 20 ;
99629: LD_ADDR_OWVAR 28
99633: PUSH
99634: LD_INT 20
99636: ST_TO_ADDR
// hc_gallery =  ;
99637: LD_ADDR_OWVAR 33
99641: PUSH
99642: LD_STRING 
99644: ST_TO_ADDR
// animal := CreateHuman ;
99645: LD_ADDR_VAR 0 12
99649: PUSH
99650: CALL_OW 44
99654: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99655: LD_VAR 0 12
99659: PPUSH
99660: LD_VAR 0 9
99664: PPUSH
99665: LD_INT 0
99667: PPUSH
99668: CALL 101365 0 3
// end ;
99672: GO 99626
99674: POP
99675: POP
// end ;
99676: LD_VAR 0 10
99680: RET
// export function WantHeal ( sci , unit ) ; begin
99681: LD_INT 0
99683: PPUSH
// if GetTaskList ( sci ) > 0 then
99684: LD_VAR 0 1
99688: PPUSH
99689: CALL_OW 437
99693: PUSH
99694: LD_INT 0
99696: GREATER
99697: IFFALSE 99767
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99699: LD_VAR 0 1
99703: PPUSH
99704: CALL_OW 437
99708: PUSH
99709: LD_INT 1
99711: ARRAY
99712: PUSH
99713: LD_INT 1
99715: ARRAY
99716: PUSH
99717: LD_STRING l
99719: EQUAL
99720: PUSH
99721: LD_VAR 0 1
99725: PPUSH
99726: CALL_OW 437
99730: PUSH
99731: LD_INT 1
99733: ARRAY
99734: PUSH
99735: LD_INT 4
99737: ARRAY
99738: PUSH
99739: LD_VAR 0 2
99743: EQUAL
99744: AND
99745: IFFALSE 99757
// result := true else
99747: LD_ADDR_VAR 0 3
99751: PUSH
99752: LD_INT 1
99754: ST_TO_ADDR
99755: GO 99765
// result := false ;
99757: LD_ADDR_VAR 0 3
99761: PUSH
99762: LD_INT 0
99764: ST_TO_ADDR
// end else
99765: GO 99775
// result := false ;
99767: LD_ADDR_VAR 0 3
99771: PUSH
99772: LD_INT 0
99774: ST_TO_ADDR
// end ;
99775: LD_VAR 0 3
99779: RET
// export function HealTarget ( sci ) ; begin
99780: LD_INT 0
99782: PPUSH
// if not sci then
99783: LD_VAR 0 1
99787: NOT
99788: IFFALSE 99792
// exit ;
99790: GO 99857
// result := 0 ;
99792: LD_ADDR_VAR 0 2
99796: PUSH
99797: LD_INT 0
99799: ST_TO_ADDR
// if GetTaskList ( sci ) then
99800: LD_VAR 0 1
99804: PPUSH
99805: CALL_OW 437
99809: IFFALSE 99857
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99811: LD_VAR 0 1
99815: PPUSH
99816: CALL_OW 437
99820: PUSH
99821: LD_INT 1
99823: ARRAY
99824: PUSH
99825: LD_INT 1
99827: ARRAY
99828: PUSH
99829: LD_STRING l
99831: EQUAL
99832: IFFALSE 99857
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99834: LD_ADDR_VAR 0 2
99838: PUSH
99839: LD_VAR 0 1
99843: PPUSH
99844: CALL_OW 437
99848: PUSH
99849: LD_INT 1
99851: ARRAY
99852: PUSH
99853: LD_INT 4
99855: ARRAY
99856: ST_TO_ADDR
// end ;
99857: LD_VAR 0 2
99861: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99862: LD_INT 0
99864: PPUSH
99865: PPUSH
99866: PPUSH
99867: PPUSH
// if not base_units then
99868: LD_VAR 0 1
99872: NOT
99873: IFFALSE 99877
// exit ;
99875: GO 99964
// result := false ;
99877: LD_ADDR_VAR 0 2
99881: PUSH
99882: LD_INT 0
99884: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99885: LD_ADDR_VAR 0 5
99889: PUSH
99890: LD_VAR 0 1
99894: PPUSH
99895: LD_INT 21
99897: PUSH
99898: LD_INT 3
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PPUSH
99905: CALL_OW 72
99909: ST_TO_ADDR
// if not tmp then
99910: LD_VAR 0 5
99914: NOT
99915: IFFALSE 99919
// exit ;
99917: GO 99964
// for i in tmp do
99919: LD_ADDR_VAR 0 3
99923: PUSH
99924: LD_VAR 0 5
99928: PUSH
99929: FOR_IN
99930: IFFALSE 99962
// begin result := EnemyInRange ( i , 22 ) ;
99932: LD_ADDR_VAR 0 2
99936: PUSH
99937: LD_VAR 0 3
99941: PPUSH
99942: LD_INT 22
99944: PPUSH
99945: CALL 98200 0 2
99949: ST_TO_ADDR
// if result then
99950: LD_VAR 0 2
99954: IFFALSE 99960
// exit ;
99956: POP
99957: POP
99958: GO 99964
// end ;
99960: GO 99929
99962: POP
99963: POP
// end ;
99964: LD_VAR 0 2
99968: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99969: LD_INT 0
99971: PPUSH
99972: PPUSH
// if not units then
99973: LD_VAR 0 1
99977: NOT
99978: IFFALSE 99982
// exit ;
99980: GO 100052
// result := [ ] ;
99982: LD_ADDR_VAR 0 3
99986: PUSH
99987: EMPTY
99988: ST_TO_ADDR
// for i in units do
99989: LD_ADDR_VAR 0 4
99993: PUSH
99994: LD_VAR 0 1
99998: PUSH
99999: FOR_IN
100000: IFFALSE 100050
// if GetTag ( i ) = tag then
100002: LD_VAR 0 4
100006: PPUSH
100007: CALL_OW 110
100011: PUSH
100012: LD_VAR 0 2
100016: EQUAL
100017: IFFALSE 100048
// result := Replace ( result , result + 1 , i ) ;
100019: LD_ADDR_VAR 0 3
100023: PUSH
100024: LD_VAR 0 3
100028: PPUSH
100029: LD_VAR 0 3
100033: PUSH
100034: LD_INT 1
100036: PLUS
100037: PPUSH
100038: LD_VAR 0 4
100042: PPUSH
100043: CALL_OW 1
100047: ST_TO_ADDR
100048: GO 99999
100050: POP
100051: POP
// end ;
100052: LD_VAR 0 3
100056: RET
// export function IsDriver ( un ) ; begin
100057: LD_INT 0
100059: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100060: LD_ADDR_VAR 0 2
100064: PUSH
100065: LD_VAR 0 1
100069: PUSH
100070: LD_INT 55
100072: PUSH
100073: EMPTY
100074: LIST
100075: PPUSH
100076: CALL_OW 69
100080: IN
100081: ST_TO_ADDR
// end ;
100082: LD_VAR 0 2
100086: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100087: LD_INT 0
100089: PPUSH
100090: PPUSH
// list := [ ] ;
100091: LD_ADDR_VAR 0 5
100095: PUSH
100096: EMPTY
100097: ST_TO_ADDR
// case d of 0 :
100098: LD_VAR 0 3
100102: PUSH
100103: LD_INT 0
100105: DOUBLE
100106: EQUAL
100107: IFTRUE 100111
100109: GO 100244
100111: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100112: LD_ADDR_VAR 0 5
100116: PUSH
100117: LD_VAR 0 1
100121: PUSH
100122: LD_INT 4
100124: MINUS
100125: PUSH
100126: LD_VAR 0 2
100130: PUSH
100131: LD_INT 4
100133: MINUS
100134: PUSH
100135: LD_INT 2
100137: PUSH
100138: EMPTY
100139: LIST
100140: LIST
100141: LIST
100142: PUSH
100143: LD_VAR 0 1
100147: PUSH
100148: LD_INT 3
100150: MINUS
100151: PUSH
100152: LD_VAR 0 2
100156: PUSH
100157: LD_INT 1
100159: PUSH
100160: EMPTY
100161: LIST
100162: LIST
100163: LIST
100164: PUSH
100165: LD_VAR 0 1
100169: PUSH
100170: LD_INT 4
100172: PLUS
100173: PUSH
100174: LD_VAR 0 2
100178: PUSH
100179: LD_INT 4
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: LIST
100186: PUSH
100187: LD_VAR 0 1
100191: PUSH
100192: LD_INT 3
100194: PLUS
100195: PUSH
100196: LD_VAR 0 2
100200: PUSH
100201: LD_INT 3
100203: PLUS
100204: PUSH
100205: LD_INT 5
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: LIST
100212: PUSH
100213: LD_VAR 0 1
100217: PUSH
100218: LD_VAR 0 2
100222: PUSH
100223: LD_INT 4
100225: PLUS
100226: PUSH
100227: LD_INT 0
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: LIST
100234: PUSH
100235: EMPTY
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: ST_TO_ADDR
// end ; 1 :
100242: GO 100942
100244: LD_INT 1
100246: DOUBLE
100247: EQUAL
100248: IFTRUE 100252
100250: GO 100385
100252: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100253: LD_ADDR_VAR 0 5
100257: PUSH
100258: LD_VAR 0 1
100262: PUSH
100263: LD_VAR 0 2
100267: PUSH
100268: LD_INT 4
100270: MINUS
100271: PUSH
100272: LD_INT 3
100274: PUSH
100275: EMPTY
100276: LIST
100277: LIST
100278: LIST
100279: PUSH
100280: LD_VAR 0 1
100284: PUSH
100285: LD_INT 3
100287: MINUS
100288: PUSH
100289: LD_VAR 0 2
100293: PUSH
100294: LD_INT 3
100296: MINUS
100297: PUSH
100298: LD_INT 2
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: LIST
100305: PUSH
100306: LD_VAR 0 1
100310: PUSH
100311: LD_INT 4
100313: MINUS
100314: PUSH
100315: LD_VAR 0 2
100319: PUSH
100320: LD_INT 1
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: LIST
100327: PUSH
100328: LD_VAR 0 1
100332: PUSH
100333: LD_VAR 0 2
100337: PUSH
100338: LD_INT 3
100340: PLUS
100341: PUSH
100342: LD_INT 0
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: LIST
100349: PUSH
100350: LD_VAR 0 1
100354: PUSH
100355: LD_INT 4
100357: PLUS
100358: PUSH
100359: LD_VAR 0 2
100363: PUSH
100364: LD_INT 4
100366: PLUS
100367: PUSH
100368: LD_INT 5
100370: PUSH
100371: EMPTY
100372: LIST
100373: LIST
100374: LIST
100375: PUSH
100376: EMPTY
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: LIST
100382: ST_TO_ADDR
// end ; 2 :
100383: GO 100942
100385: LD_INT 2
100387: DOUBLE
100388: EQUAL
100389: IFTRUE 100393
100391: GO 100522
100393: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100394: LD_ADDR_VAR 0 5
100398: PUSH
100399: LD_VAR 0 1
100403: PUSH
100404: LD_VAR 0 2
100408: PUSH
100409: LD_INT 3
100411: MINUS
100412: PUSH
100413: LD_INT 3
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: LIST
100420: PUSH
100421: LD_VAR 0 1
100425: PUSH
100426: LD_INT 4
100428: PLUS
100429: PUSH
100430: LD_VAR 0 2
100434: PUSH
100435: LD_INT 4
100437: PUSH
100438: EMPTY
100439: LIST
100440: LIST
100441: LIST
100442: PUSH
100443: LD_VAR 0 1
100447: PUSH
100448: LD_VAR 0 2
100452: PUSH
100453: LD_INT 4
100455: PLUS
100456: PUSH
100457: LD_INT 0
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: LIST
100464: PUSH
100465: LD_VAR 0 1
100469: PUSH
100470: LD_INT 3
100472: MINUS
100473: PUSH
100474: LD_VAR 0 2
100478: PUSH
100479: LD_INT 1
100481: PUSH
100482: EMPTY
100483: LIST
100484: LIST
100485: LIST
100486: PUSH
100487: LD_VAR 0 1
100491: PUSH
100492: LD_INT 4
100494: MINUS
100495: PUSH
100496: LD_VAR 0 2
100500: PUSH
100501: LD_INT 4
100503: MINUS
100504: PUSH
100505: LD_INT 2
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: LIST
100512: PUSH
100513: EMPTY
100514: LIST
100515: LIST
100516: LIST
100517: LIST
100518: LIST
100519: ST_TO_ADDR
// end ; 3 :
100520: GO 100942
100522: LD_INT 3
100524: DOUBLE
100525: EQUAL
100526: IFTRUE 100530
100528: GO 100663
100530: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100531: LD_ADDR_VAR 0 5
100535: PUSH
100536: LD_VAR 0 1
100540: PUSH
100541: LD_INT 3
100543: PLUS
100544: PUSH
100545: LD_VAR 0 2
100549: PUSH
100550: LD_INT 4
100552: PUSH
100553: EMPTY
100554: LIST
100555: LIST
100556: LIST
100557: PUSH
100558: LD_VAR 0 1
100562: PUSH
100563: LD_INT 4
100565: PLUS
100566: PUSH
100567: LD_VAR 0 2
100571: PUSH
100572: LD_INT 4
100574: PLUS
100575: PUSH
100576: LD_INT 5
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: LIST
100583: PUSH
100584: LD_VAR 0 1
100588: PUSH
100589: LD_INT 4
100591: MINUS
100592: PUSH
100593: LD_VAR 0 2
100597: PUSH
100598: LD_INT 1
100600: PUSH
100601: EMPTY
100602: LIST
100603: LIST
100604: LIST
100605: PUSH
100606: LD_VAR 0 1
100610: PUSH
100611: LD_VAR 0 2
100615: PUSH
100616: LD_INT 4
100618: MINUS
100619: PUSH
100620: LD_INT 3
100622: PUSH
100623: EMPTY
100624: LIST
100625: LIST
100626: LIST
100627: PUSH
100628: LD_VAR 0 1
100632: PUSH
100633: LD_INT 3
100635: MINUS
100636: PUSH
100637: LD_VAR 0 2
100641: PUSH
100642: LD_INT 3
100644: MINUS
100645: PUSH
100646: LD_INT 2
100648: PUSH
100649: EMPTY
100650: LIST
100651: LIST
100652: LIST
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: ST_TO_ADDR
// end ; 4 :
100661: GO 100942
100663: LD_INT 4
100665: DOUBLE
100666: EQUAL
100667: IFTRUE 100671
100669: GO 100804
100671: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100672: LD_ADDR_VAR 0 5
100676: PUSH
100677: LD_VAR 0 1
100681: PUSH
100682: LD_VAR 0 2
100686: PUSH
100687: LD_INT 4
100689: PLUS
100690: PUSH
100691: LD_INT 0
100693: PUSH
100694: EMPTY
100695: LIST
100696: LIST
100697: LIST
100698: PUSH
100699: LD_VAR 0 1
100703: PUSH
100704: LD_INT 3
100706: PLUS
100707: PUSH
100708: LD_VAR 0 2
100712: PUSH
100713: LD_INT 3
100715: PLUS
100716: PUSH
100717: LD_INT 5
100719: PUSH
100720: EMPTY
100721: LIST
100722: LIST
100723: LIST
100724: PUSH
100725: LD_VAR 0 1
100729: PUSH
100730: LD_INT 4
100732: PLUS
100733: PUSH
100734: LD_VAR 0 2
100738: PUSH
100739: LD_INT 4
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: LIST
100746: PUSH
100747: LD_VAR 0 1
100751: PUSH
100752: LD_VAR 0 2
100756: PUSH
100757: LD_INT 3
100759: MINUS
100760: PUSH
100761: LD_INT 3
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: LIST
100768: PUSH
100769: LD_VAR 0 1
100773: PUSH
100774: LD_INT 4
100776: MINUS
100777: PUSH
100778: LD_VAR 0 2
100782: PUSH
100783: LD_INT 4
100785: MINUS
100786: PUSH
100787: LD_INT 2
100789: PUSH
100790: EMPTY
100791: LIST
100792: LIST
100793: LIST
100794: PUSH
100795: EMPTY
100796: LIST
100797: LIST
100798: LIST
100799: LIST
100800: LIST
100801: ST_TO_ADDR
// end ; 5 :
100802: GO 100942
100804: LD_INT 5
100806: DOUBLE
100807: EQUAL
100808: IFTRUE 100812
100810: GO 100941
100812: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100813: LD_ADDR_VAR 0 5
100817: PUSH
100818: LD_VAR 0 1
100822: PUSH
100823: LD_INT 4
100825: MINUS
100826: PUSH
100827: LD_VAR 0 2
100831: PUSH
100832: LD_INT 1
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: LIST
100839: PUSH
100840: LD_VAR 0 1
100844: PUSH
100845: LD_VAR 0 2
100849: PUSH
100850: LD_INT 4
100852: MINUS
100853: PUSH
100854: LD_INT 3
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: LIST
100861: PUSH
100862: LD_VAR 0 1
100866: PUSH
100867: LD_INT 4
100869: PLUS
100870: PUSH
100871: LD_VAR 0 2
100875: PUSH
100876: LD_INT 4
100878: PLUS
100879: PUSH
100880: LD_INT 5
100882: PUSH
100883: EMPTY
100884: LIST
100885: LIST
100886: LIST
100887: PUSH
100888: LD_VAR 0 1
100892: PUSH
100893: LD_INT 3
100895: PLUS
100896: PUSH
100897: LD_VAR 0 2
100901: PUSH
100902: LD_INT 4
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: LIST
100909: PUSH
100910: LD_VAR 0 1
100914: PUSH
100915: LD_VAR 0 2
100919: PUSH
100920: LD_INT 3
100922: PLUS
100923: PUSH
100924: LD_INT 0
100926: PUSH
100927: EMPTY
100928: LIST
100929: LIST
100930: LIST
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: LIST
100936: LIST
100937: LIST
100938: ST_TO_ADDR
// end ; end ;
100939: GO 100942
100941: POP
// result := list ;
100942: LD_ADDR_VAR 0 4
100946: PUSH
100947: LD_VAR 0 5
100951: ST_TO_ADDR
// end ;
100952: LD_VAR 0 4
100956: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100957: LD_INT 0
100959: PPUSH
100960: PPUSH
100961: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100962: LD_VAR 0 1
100966: NOT
100967: PUSH
100968: LD_VAR 0 2
100972: PUSH
100973: LD_INT 1
100975: PUSH
100976: LD_INT 2
100978: PUSH
100979: LD_INT 3
100981: PUSH
100982: LD_INT 4
100984: PUSH
100985: EMPTY
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: IN
100991: NOT
100992: OR
100993: IFFALSE 100997
// exit ;
100995: GO 101089
// tmp := [ ] ;
100997: LD_ADDR_VAR 0 5
101001: PUSH
101002: EMPTY
101003: ST_TO_ADDR
// for i in units do
101004: LD_ADDR_VAR 0 4
101008: PUSH
101009: LD_VAR 0 1
101013: PUSH
101014: FOR_IN
101015: IFFALSE 101058
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101017: LD_ADDR_VAR 0 5
101021: PUSH
101022: LD_VAR 0 5
101026: PPUSH
101027: LD_VAR 0 5
101031: PUSH
101032: LD_INT 1
101034: PLUS
101035: PPUSH
101036: LD_VAR 0 4
101040: PPUSH
101041: LD_VAR 0 2
101045: PPUSH
101046: CALL_OW 259
101050: PPUSH
101051: CALL_OW 2
101055: ST_TO_ADDR
101056: GO 101014
101058: POP
101059: POP
// if not tmp then
101060: LD_VAR 0 5
101064: NOT
101065: IFFALSE 101069
// exit ;
101067: GO 101089
// result := SortListByListDesc ( units , tmp ) ;
101069: LD_ADDR_VAR 0 3
101073: PUSH
101074: LD_VAR 0 1
101078: PPUSH
101079: LD_VAR 0 5
101083: PPUSH
101084: CALL_OW 77
101088: ST_TO_ADDR
// end ;
101089: LD_VAR 0 3
101093: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101094: LD_INT 0
101096: PPUSH
101097: PPUSH
101098: PPUSH
// result := false ;
101099: LD_ADDR_VAR 0 3
101103: PUSH
101104: LD_INT 0
101106: ST_TO_ADDR
// x := GetX ( building ) ;
101107: LD_ADDR_VAR 0 4
101111: PUSH
101112: LD_VAR 0 2
101116: PPUSH
101117: CALL_OW 250
101121: ST_TO_ADDR
// y := GetY ( building ) ;
101122: LD_ADDR_VAR 0 5
101126: PUSH
101127: LD_VAR 0 2
101131: PPUSH
101132: CALL_OW 251
101136: ST_TO_ADDR
// if not building or not x or not y then
101137: LD_VAR 0 2
101141: NOT
101142: PUSH
101143: LD_VAR 0 4
101147: NOT
101148: OR
101149: PUSH
101150: LD_VAR 0 5
101154: NOT
101155: OR
101156: IFFALSE 101160
// exit ;
101158: GO 101252
// if GetTaskList ( unit ) then
101160: LD_VAR 0 1
101164: PPUSH
101165: CALL_OW 437
101169: IFFALSE 101252
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101171: LD_STRING e
101173: PUSH
101174: LD_VAR 0 1
101178: PPUSH
101179: CALL_OW 437
101183: PUSH
101184: LD_INT 1
101186: ARRAY
101187: PUSH
101188: LD_INT 1
101190: ARRAY
101191: EQUAL
101192: PUSH
101193: LD_VAR 0 4
101197: PUSH
101198: LD_VAR 0 1
101202: PPUSH
101203: CALL_OW 437
101207: PUSH
101208: LD_INT 1
101210: ARRAY
101211: PUSH
101212: LD_INT 2
101214: ARRAY
101215: EQUAL
101216: AND
101217: PUSH
101218: LD_VAR 0 5
101222: PUSH
101223: LD_VAR 0 1
101227: PPUSH
101228: CALL_OW 437
101232: PUSH
101233: LD_INT 1
101235: ARRAY
101236: PUSH
101237: LD_INT 3
101239: ARRAY
101240: EQUAL
101241: AND
101242: IFFALSE 101252
// result := true end ;
101244: LD_ADDR_VAR 0 3
101248: PUSH
101249: LD_INT 1
101251: ST_TO_ADDR
// end ;
101252: LD_VAR 0 3
101256: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101257: LD_INT 0
101259: PPUSH
// result := false ;
101260: LD_ADDR_VAR 0 4
101264: PUSH
101265: LD_INT 0
101267: ST_TO_ADDR
// if GetTaskList ( unit ) then
101268: LD_VAR 0 1
101272: PPUSH
101273: CALL_OW 437
101277: IFFALSE 101360
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101279: LD_STRING M
101281: PUSH
101282: LD_VAR 0 1
101286: PPUSH
101287: CALL_OW 437
101291: PUSH
101292: LD_INT 1
101294: ARRAY
101295: PUSH
101296: LD_INT 1
101298: ARRAY
101299: EQUAL
101300: PUSH
101301: LD_VAR 0 2
101305: PUSH
101306: LD_VAR 0 1
101310: PPUSH
101311: CALL_OW 437
101315: PUSH
101316: LD_INT 1
101318: ARRAY
101319: PUSH
101320: LD_INT 2
101322: ARRAY
101323: EQUAL
101324: AND
101325: PUSH
101326: LD_VAR 0 3
101330: PUSH
101331: LD_VAR 0 1
101335: PPUSH
101336: CALL_OW 437
101340: PUSH
101341: LD_INT 1
101343: ARRAY
101344: PUSH
101345: LD_INT 3
101347: ARRAY
101348: EQUAL
101349: AND
101350: IFFALSE 101360
// result := true ;
101352: LD_ADDR_VAR 0 4
101356: PUSH
101357: LD_INT 1
101359: ST_TO_ADDR
// end ; end ;
101360: LD_VAR 0 4
101364: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101365: LD_INT 0
101367: PPUSH
101368: PPUSH
101369: PPUSH
101370: PPUSH
// if not unit or not area then
101371: LD_VAR 0 1
101375: NOT
101376: PUSH
101377: LD_VAR 0 2
101381: NOT
101382: OR
101383: IFFALSE 101387
// exit ;
101385: GO 101551
// tmp := AreaToList ( area , i ) ;
101387: LD_ADDR_VAR 0 6
101391: PUSH
101392: LD_VAR 0 2
101396: PPUSH
101397: LD_VAR 0 5
101401: PPUSH
101402: CALL_OW 517
101406: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101407: LD_ADDR_VAR 0 5
101411: PUSH
101412: DOUBLE
101413: LD_INT 1
101415: DEC
101416: ST_TO_ADDR
101417: LD_VAR 0 6
101421: PUSH
101422: LD_INT 1
101424: ARRAY
101425: PUSH
101426: FOR_TO
101427: IFFALSE 101549
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101429: LD_ADDR_VAR 0 7
101433: PUSH
101434: LD_VAR 0 6
101438: PUSH
101439: LD_INT 1
101441: ARRAY
101442: PUSH
101443: LD_VAR 0 5
101447: ARRAY
101448: PUSH
101449: LD_VAR 0 6
101453: PUSH
101454: LD_INT 2
101456: ARRAY
101457: PUSH
101458: LD_VAR 0 5
101462: ARRAY
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101468: LD_VAR 0 7
101472: PUSH
101473: LD_INT 1
101475: ARRAY
101476: PPUSH
101477: LD_VAR 0 7
101481: PUSH
101482: LD_INT 2
101484: ARRAY
101485: PPUSH
101486: CALL_OW 428
101490: PUSH
101491: LD_INT 0
101493: EQUAL
101494: IFFALSE 101547
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101496: LD_VAR 0 1
101500: PPUSH
101501: LD_VAR 0 7
101505: PUSH
101506: LD_INT 1
101508: ARRAY
101509: PPUSH
101510: LD_VAR 0 7
101514: PUSH
101515: LD_INT 2
101517: ARRAY
101518: PPUSH
101519: LD_VAR 0 3
101523: PPUSH
101524: CALL_OW 48
// result := IsPlaced ( unit ) ;
101528: LD_ADDR_VAR 0 4
101532: PUSH
101533: LD_VAR 0 1
101537: PPUSH
101538: CALL_OW 305
101542: ST_TO_ADDR
// exit ;
101543: POP
101544: POP
101545: GO 101551
// end ; end ;
101547: GO 101426
101549: POP
101550: POP
// end ;
101551: LD_VAR 0 4
101555: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101556: LD_INT 0
101558: PPUSH
101559: PPUSH
101560: PPUSH
// if not side or side > 8 then
101561: LD_VAR 0 1
101565: NOT
101566: PUSH
101567: LD_VAR 0 1
101571: PUSH
101572: LD_INT 8
101574: GREATER
101575: OR
101576: IFFALSE 101580
// exit ;
101578: GO 101767
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101580: LD_ADDR_VAR 0 4
101584: PUSH
101585: LD_INT 22
101587: PUSH
101588: LD_VAR 0 1
101592: PUSH
101593: EMPTY
101594: LIST
101595: LIST
101596: PUSH
101597: LD_INT 21
101599: PUSH
101600: LD_INT 3
101602: PUSH
101603: EMPTY
101604: LIST
101605: LIST
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: PPUSH
101611: CALL_OW 69
101615: ST_TO_ADDR
// if not tmp then
101616: LD_VAR 0 4
101620: NOT
101621: IFFALSE 101625
// exit ;
101623: GO 101767
// enable_addtolog := true ;
101625: LD_ADDR_OWVAR 81
101629: PUSH
101630: LD_INT 1
101632: ST_TO_ADDR
// AddToLog ( [ ) ;
101633: LD_STRING [
101635: PPUSH
101636: CALL_OW 561
// for i in tmp do
101640: LD_ADDR_VAR 0 3
101644: PUSH
101645: LD_VAR 0 4
101649: PUSH
101650: FOR_IN
101651: IFFALSE 101758
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101653: LD_STRING [
101655: PUSH
101656: LD_VAR 0 3
101660: PPUSH
101661: CALL_OW 266
101665: STR
101666: PUSH
101667: LD_STRING , 
101669: STR
101670: PUSH
101671: LD_VAR 0 3
101675: PPUSH
101676: CALL_OW 250
101680: STR
101681: PUSH
101682: LD_STRING , 
101684: STR
101685: PUSH
101686: LD_VAR 0 3
101690: PPUSH
101691: CALL_OW 251
101695: STR
101696: PUSH
101697: LD_STRING , 
101699: STR
101700: PUSH
101701: LD_VAR 0 3
101705: PPUSH
101706: CALL_OW 254
101710: STR
101711: PUSH
101712: LD_STRING , 
101714: STR
101715: PUSH
101716: LD_VAR 0 3
101720: PPUSH
101721: LD_INT 1
101723: PPUSH
101724: CALL_OW 268
101728: STR
101729: PUSH
101730: LD_STRING , 
101732: STR
101733: PUSH
101734: LD_VAR 0 3
101738: PPUSH
101739: LD_INT 2
101741: PPUSH
101742: CALL_OW 268
101746: STR
101747: PUSH
101748: LD_STRING ],
101750: STR
101751: PPUSH
101752: CALL_OW 561
// end ;
101756: GO 101650
101758: POP
101759: POP
// AddToLog ( ]; ) ;
101760: LD_STRING ];
101762: PPUSH
101763: CALL_OW 561
// end ;
101767: LD_VAR 0 2
101771: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101772: LD_INT 0
101774: PPUSH
101775: PPUSH
101776: PPUSH
101777: PPUSH
101778: PPUSH
// if not area or not rate or not max then
101779: LD_VAR 0 1
101783: NOT
101784: PUSH
101785: LD_VAR 0 2
101789: NOT
101790: OR
101791: PUSH
101792: LD_VAR 0 4
101796: NOT
101797: OR
101798: IFFALSE 101802
// exit ;
101800: GO 101994
// while 1 do
101802: LD_INT 1
101804: IFFALSE 101994
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101806: LD_ADDR_VAR 0 9
101810: PUSH
101811: LD_VAR 0 1
101815: PPUSH
101816: LD_INT 1
101818: PPUSH
101819: CALL_OW 287
101823: PUSH
101824: LD_INT 10
101826: MUL
101827: ST_TO_ADDR
// r := rate / 10 ;
101828: LD_ADDR_VAR 0 7
101832: PUSH
101833: LD_VAR 0 2
101837: PUSH
101838: LD_INT 10
101840: DIVREAL
101841: ST_TO_ADDR
// time := 1 1$00 ;
101842: LD_ADDR_VAR 0 8
101846: PUSH
101847: LD_INT 2100
101849: ST_TO_ADDR
// if amount < min then
101850: LD_VAR 0 9
101854: PUSH
101855: LD_VAR 0 3
101859: LESS
101860: IFFALSE 101878
// r := r * 2 else
101862: LD_ADDR_VAR 0 7
101866: PUSH
101867: LD_VAR 0 7
101871: PUSH
101872: LD_INT 2
101874: MUL
101875: ST_TO_ADDR
101876: GO 101904
// if amount > max then
101878: LD_VAR 0 9
101882: PUSH
101883: LD_VAR 0 4
101887: GREATER
101888: IFFALSE 101904
// r := r / 2 ;
101890: LD_ADDR_VAR 0 7
101894: PUSH
101895: LD_VAR 0 7
101899: PUSH
101900: LD_INT 2
101902: DIVREAL
101903: ST_TO_ADDR
// time := time / r ;
101904: LD_ADDR_VAR 0 8
101908: PUSH
101909: LD_VAR 0 8
101913: PUSH
101914: LD_VAR 0 7
101918: DIVREAL
101919: ST_TO_ADDR
// if time < 0 then
101920: LD_VAR 0 8
101924: PUSH
101925: LD_INT 0
101927: LESS
101928: IFFALSE 101945
// time := time * - 1 ;
101930: LD_ADDR_VAR 0 8
101934: PUSH
101935: LD_VAR 0 8
101939: PUSH
101940: LD_INT 1
101942: NEG
101943: MUL
101944: ST_TO_ADDR
// wait ( time ) ;
101945: LD_VAR 0 8
101949: PPUSH
101950: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101954: LD_INT 35
101956: PPUSH
101957: LD_INT 875
101959: PPUSH
101960: CALL_OW 12
101964: PPUSH
101965: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101969: LD_INT 1
101971: PPUSH
101972: LD_INT 5
101974: PPUSH
101975: CALL_OW 12
101979: PPUSH
101980: LD_VAR 0 1
101984: PPUSH
101985: LD_INT 1
101987: PPUSH
101988: CALL_OW 55
// end ;
101992: GO 101802
// end ;
101994: LD_VAR 0 5
101998: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101999: LD_INT 0
102001: PPUSH
102002: PPUSH
102003: PPUSH
102004: PPUSH
102005: PPUSH
102006: PPUSH
102007: PPUSH
102008: PPUSH
// if not turrets or not factories then
102009: LD_VAR 0 1
102013: NOT
102014: PUSH
102015: LD_VAR 0 2
102019: NOT
102020: OR
102021: IFFALSE 102025
// exit ;
102023: GO 102332
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102025: LD_ADDR_VAR 0 10
102029: PUSH
102030: LD_INT 5
102032: PUSH
102033: LD_INT 6
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: PUSH
102040: LD_INT 2
102042: PUSH
102043: LD_INT 4
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PUSH
102050: LD_INT 3
102052: PUSH
102053: LD_INT 5
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: PUSH
102060: EMPTY
102061: LIST
102062: LIST
102063: LIST
102064: PUSH
102065: LD_INT 24
102067: PUSH
102068: LD_INT 25
102070: PUSH
102071: EMPTY
102072: LIST
102073: LIST
102074: PUSH
102075: LD_INT 23
102077: PUSH
102078: LD_INT 27
102080: PUSH
102081: EMPTY
102082: LIST
102083: LIST
102084: PUSH
102085: EMPTY
102086: LIST
102087: LIST
102088: PUSH
102089: LD_INT 42
102091: PUSH
102092: LD_INT 43
102094: PUSH
102095: EMPTY
102096: LIST
102097: LIST
102098: PUSH
102099: LD_INT 44
102101: PUSH
102102: LD_INT 46
102104: PUSH
102105: EMPTY
102106: LIST
102107: LIST
102108: PUSH
102109: LD_INT 45
102111: PUSH
102112: LD_INT 47
102114: PUSH
102115: EMPTY
102116: LIST
102117: LIST
102118: PUSH
102119: EMPTY
102120: LIST
102121: LIST
102122: LIST
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: LIST
102128: ST_TO_ADDR
// result := [ ] ;
102129: LD_ADDR_VAR 0 3
102133: PUSH
102134: EMPTY
102135: ST_TO_ADDR
// for i in turrets do
102136: LD_ADDR_VAR 0 4
102140: PUSH
102141: LD_VAR 0 1
102145: PUSH
102146: FOR_IN
102147: IFFALSE 102330
// begin nat := GetNation ( i ) ;
102149: LD_ADDR_VAR 0 7
102153: PUSH
102154: LD_VAR 0 4
102158: PPUSH
102159: CALL_OW 248
102163: ST_TO_ADDR
// weapon := 0 ;
102164: LD_ADDR_VAR 0 8
102168: PUSH
102169: LD_INT 0
102171: ST_TO_ADDR
// if not nat then
102172: LD_VAR 0 7
102176: NOT
102177: IFFALSE 102181
// continue ;
102179: GO 102146
// for j in list [ nat ] do
102181: LD_ADDR_VAR 0 5
102185: PUSH
102186: LD_VAR 0 10
102190: PUSH
102191: LD_VAR 0 7
102195: ARRAY
102196: PUSH
102197: FOR_IN
102198: IFFALSE 102239
// if GetBWeapon ( i ) = j [ 1 ] then
102200: LD_VAR 0 4
102204: PPUSH
102205: CALL_OW 269
102209: PUSH
102210: LD_VAR 0 5
102214: PUSH
102215: LD_INT 1
102217: ARRAY
102218: EQUAL
102219: IFFALSE 102237
// begin weapon := j [ 2 ] ;
102221: LD_ADDR_VAR 0 8
102225: PUSH
102226: LD_VAR 0 5
102230: PUSH
102231: LD_INT 2
102233: ARRAY
102234: ST_TO_ADDR
// break ;
102235: GO 102239
// end ;
102237: GO 102197
102239: POP
102240: POP
// if not weapon then
102241: LD_VAR 0 8
102245: NOT
102246: IFFALSE 102250
// continue ;
102248: GO 102146
// for k in factories do
102250: LD_ADDR_VAR 0 6
102254: PUSH
102255: LD_VAR 0 2
102259: PUSH
102260: FOR_IN
102261: IFFALSE 102326
// begin weapons := AvailableWeaponList ( k ) ;
102263: LD_ADDR_VAR 0 9
102267: PUSH
102268: LD_VAR 0 6
102272: PPUSH
102273: CALL_OW 478
102277: ST_TO_ADDR
// if not weapons then
102278: LD_VAR 0 9
102282: NOT
102283: IFFALSE 102287
// continue ;
102285: GO 102260
// if weapon in weapons then
102287: LD_VAR 0 8
102291: PUSH
102292: LD_VAR 0 9
102296: IN
102297: IFFALSE 102324
// begin result := [ i , weapon ] ;
102299: LD_ADDR_VAR 0 3
102303: PUSH
102304: LD_VAR 0 4
102308: PUSH
102309: LD_VAR 0 8
102313: PUSH
102314: EMPTY
102315: LIST
102316: LIST
102317: ST_TO_ADDR
// exit ;
102318: POP
102319: POP
102320: POP
102321: POP
102322: GO 102332
// end ; end ;
102324: GO 102260
102326: POP
102327: POP
// end ;
102328: GO 102146
102330: POP
102331: POP
// end ;
102332: LD_VAR 0 3
102336: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102337: LD_INT 0
102339: PPUSH
// if not side or side > 8 then
102340: LD_VAR 0 3
102344: NOT
102345: PUSH
102346: LD_VAR 0 3
102350: PUSH
102351: LD_INT 8
102353: GREATER
102354: OR
102355: IFFALSE 102359
// exit ;
102357: GO 102418
// if not range then
102359: LD_VAR 0 4
102363: NOT
102364: IFFALSE 102375
// range := - 12 ;
102366: LD_ADDR_VAR 0 4
102370: PUSH
102371: LD_INT 12
102373: NEG
102374: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102375: LD_VAR 0 1
102379: PPUSH
102380: LD_VAR 0 2
102384: PPUSH
102385: LD_VAR 0 3
102389: PPUSH
102390: LD_VAR 0 4
102394: PPUSH
102395: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102399: LD_VAR 0 1
102403: PPUSH
102404: LD_VAR 0 2
102408: PPUSH
102409: LD_VAR 0 3
102413: PPUSH
102414: CALL_OW 331
// end ;
102418: LD_VAR 0 5
102422: RET
// export function Video ( mode ) ; begin
102423: LD_INT 0
102425: PPUSH
// ingame_video = mode ;
102426: LD_ADDR_OWVAR 52
102430: PUSH
102431: LD_VAR 0 1
102435: ST_TO_ADDR
// interface_hidden = mode ;
102436: LD_ADDR_OWVAR 54
102440: PUSH
102441: LD_VAR 0 1
102445: ST_TO_ADDR
// end ;
102446: LD_VAR 0 2
102450: RET
// export function Join ( array , element ) ; begin
102451: LD_INT 0
102453: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102454: LD_ADDR_VAR 0 3
102458: PUSH
102459: LD_VAR 0 1
102463: PPUSH
102464: LD_VAR 0 1
102468: PUSH
102469: LD_INT 1
102471: PLUS
102472: PPUSH
102473: LD_VAR 0 2
102477: PPUSH
102478: CALL_OW 1
102482: ST_TO_ADDR
// end ;
102483: LD_VAR 0 3
102487: RET
// export function JoinUnion ( array , element ) ; begin
102488: LD_INT 0
102490: PPUSH
// result := array union element ;
102491: LD_ADDR_VAR 0 3
102495: PUSH
102496: LD_VAR 0 1
102500: PUSH
102501: LD_VAR 0 2
102505: UNION
102506: ST_TO_ADDR
// end ;
102507: LD_VAR 0 3
102511: RET
// export function GetBehemoths ( side ) ; begin
102512: LD_INT 0
102514: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102515: LD_ADDR_VAR 0 2
102519: PUSH
102520: LD_INT 22
102522: PUSH
102523: LD_VAR 0 1
102527: PUSH
102528: EMPTY
102529: LIST
102530: LIST
102531: PUSH
102532: LD_INT 31
102534: PUSH
102535: LD_INT 25
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: PUSH
102542: EMPTY
102543: LIST
102544: LIST
102545: PPUSH
102546: CALL_OW 69
102550: ST_TO_ADDR
// end ;
102551: LD_VAR 0 2
102555: RET
// export function Shuffle ( array ) ; var i , index ; begin
102556: LD_INT 0
102558: PPUSH
102559: PPUSH
102560: PPUSH
// result := [ ] ;
102561: LD_ADDR_VAR 0 2
102565: PUSH
102566: EMPTY
102567: ST_TO_ADDR
// if not array then
102568: LD_VAR 0 1
102572: NOT
102573: IFFALSE 102577
// exit ;
102575: GO 102676
// Randomize ;
102577: CALL_OW 10
// for i = array downto 1 do
102581: LD_ADDR_VAR 0 3
102585: PUSH
102586: DOUBLE
102587: LD_VAR 0 1
102591: INC
102592: ST_TO_ADDR
102593: LD_INT 1
102595: PUSH
102596: FOR_DOWNTO
102597: IFFALSE 102674
// begin index := rand ( 1 , array ) ;
102599: LD_ADDR_VAR 0 4
102603: PUSH
102604: LD_INT 1
102606: PPUSH
102607: LD_VAR 0 1
102611: PPUSH
102612: CALL_OW 12
102616: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102617: LD_ADDR_VAR 0 2
102621: PUSH
102622: LD_VAR 0 2
102626: PPUSH
102627: LD_VAR 0 2
102631: PUSH
102632: LD_INT 1
102634: PLUS
102635: PPUSH
102636: LD_VAR 0 1
102640: PUSH
102641: LD_VAR 0 4
102645: ARRAY
102646: PPUSH
102647: CALL_OW 2
102651: ST_TO_ADDR
// array := Delete ( array , index ) ;
102652: LD_ADDR_VAR 0 1
102656: PUSH
102657: LD_VAR 0 1
102661: PPUSH
102662: LD_VAR 0 4
102666: PPUSH
102667: CALL_OW 3
102671: ST_TO_ADDR
// end ;
102672: GO 102596
102674: POP
102675: POP
// end ;
102676: LD_VAR 0 2
102680: RET
// export function GetBaseMaterials ( base ) ; begin
102681: LD_INT 0
102683: PPUSH
// result := [ 0 , 0 , 0 ] ;
102684: LD_ADDR_VAR 0 2
102688: PUSH
102689: LD_INT 0
102691: PUSH
102692: LD_INT 0
102694: PUSH
102695: LD_INT 0
102697: PUSH
102698: EMPTY
102699: LIST
102700: LIST
102701: LIST
102702: ST_TO_ADDR
// if not base then
102703: LD_VAR 0 1
102707: NOT
102708: IFFALSE 102712
// exit ;
102710: GO 102761
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102712: LD_ADDR_VAR 0 2
102716: PUSH
102717: LD_VAR 0 1
102721: PPUSH
102722: LD_INT 1
102724: PPUSH
102725: CALL_OW 275
102729: PUSH
102730: LD_VAR 0 1
102734: PPUSH
102735: LD_INT 2
102737: PPUSH
102738: CALL_OW 275
102742: PUSH
102743: LD_VAR 0 1
102747: PPUSH
102748: LD_INT 3
102750: PPUSH
102751: CALL_OW 275
102755: PUSH
102756: EMPTY
102757: LIST
102758: LIST
102759: LIST
102760: ST_TO_ADDR
// end ;
102761: LD_VAR 0 2
102765: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102766: LD_INT 0
102768: PPUSH
102769: PPUSH
// result := array ;
102770: LD_ADDR_VAR 0 3
102774: PUSH
102775: LD_VAR 0 1
102779: ST_TO_ADDR
// if size > 0 then
102780: LD_VAR 0 2
102784: PUSH
102785: LD_INT 0
102787: GREATER
102788: IFFALSE 102834
// for i := array downto size do
102790: LD_ADDR_VAR 0 4
102794: PUSH
102795: DOUBLE
102796: LD_VAR 0 1
102800: INC
102801: ST_TO_ADDR
102802: LD_VAR 0 2
102806: PUSH
102807: FOR_DOWNTO
102808: IFFALSE 102832
// result := Delete ( result , result ) ;
102810: LD_ADDR_VAR 0 3
102814: PUSH
102815: LD_VAR 0 3
102819: PPUSH
102820: LD_VAR 0 3
102824: PPUSH
102825: CALL_OW 3
102829: ST_TO_ADDR
102830: GO 102807
102832: POP
102833: POP
// end ;
102834: LD_VAR 0 3
102838: RET
// export function ComExit ( unit ) ; var tmp ; begin
102839: LD_INT 0
102841: PPUSH
102842: PPUSH
// if not IsInUnit ( unit ) then
102843: LD_VAR 0 1
102847: PPUSH
102848: CALL_OW 310
102852: NOT
102853: IFFALSE 102857
// exit ;
102855: GO 102917
// tmp := IsInUnit ( unit ) ;
102857: LD_ADDR_VAR 0 3
102861: PUSH
102862: LD_VAR 0 1
102866: PPUSH
102867: CALL_OW 310
102871: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102872: LD_VAR 0 3
102876: PPUSH
102877: CALL_OW 247
102881: PUSH
102882: LD_INT 2
102884: EQUAL
102885: IFFALSE 102898
// ComExitVehicle ( unit ) else
102887: LD_VAR 0 1
102891: PPUSH
102892: CALL_OW 121
102896: GO 102907
// ComExitBuilding ( unit ) ;
102898: LD_VAR 0 1
102902: PPUSH
102903: CALL_OW 122
// result := tmp ;
102907: LD_ADDR_VAR 0 2
102911: PUSH
102912: LD_VAR 0 3
102916: ST_TO_ADDR
// end ;
102917: LD_VAR 0 2
102921: RET
// export function ComExitAll ( units ) ; var i ; begin
102922: LD_INT 0
102924: PPUSH
102925: PPUSH
// if not units then
102926: LD_VAR 0 1
102930: NOT
102931: IFFALSE 102935
// exit ;
102933: GO 102961
// for i in units do
102935: LD_ADDR_VAR 0 3
102939: PUSH
102940: LD_VAR 0 1
102944: PUSH
102945: FOR_IN
102946: IFFALSE 102959
// ComExit ( i ) ;
102948: LD_VAR 0 3
102952: PPUSH
102953: CALL 102839 0 1
102957: GO 102945
102959: POP
102960: POP
// end ;
102961: LD_VAR 0 2
102965: RET
// export function ResetHc ; begin
102966: LD_INT 0
102968: PPUSH
// InitHc ;
102969: CALL_OW 19
// hc_importance := 0 ;
102973: LD_ADDR_OWVAR 32
102977: PUSH
102978: LD_INT 0
102980: ST_TO_ADDR
// end ;
102981: LD_VAR 0 1
102985: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102986: LD_INT 0
102988: PPUSH
102989: PPUSH
102990: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102991: LD_ADDR_VAR 0 6
102995: PUSH
102996: LD_VAR 0 1
103000: PUSH
103001: LD_VAR 0 3
103005: PLUS
103006: PUSH
103007: LD_INT 2
103009: DIV
103010: ST_TO_ADDR
// if _x < 0 then
103011: LD_VAR 0 6
103015: PUSH
103016: LD_INT 0
103018: LESS
103019: IFFALSE 103036
// _x := _x * - 1 ;
103021: LD_ADDR_VAR 0 6
103025: PUSH
103026: LD_VAR 0 6
103030: PUSH
103031: LD_INT 1
103033: NEG
103034: MUL
103035: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103036: LD_ADDR_VAR 0 7
103040: PUSH
103041: LD_VAR 0 2
103045: PUSH
103046: LD_VAR 0 4
103050: PLUS
103051: PUSH
103052: LD_INT 2
103054: DIV
103055: ST_TO_ADDR
// if _y < 0 then
103056: LD_VAR 0 7
103060: PUSH
103061: LD_INT 0
103063: LESS
103064: IFFALSE 103081
// _y := _y * - 1 ;
103066: LD_ADDR_VAR 0 7
103070: PUSH
103071: LD_VAR 0 7
103075: PUSH
103076: LD_INT 1
103078: NEG
103079: MUL
103080: ST_TO_ADDR
// result := [ _x , _y ] ;
103081: LD_ADDR_VAR 0 5
103085: PUSH
103086: LD_VAR 0 6
103090: PUSH
103091: LD_VAR 0 7
103095: PUSH
103096: EMPTY
103097: LIST
103098: LIST
103099: ST_TO_ADDR
// end ;
103100: LD_VAR 0 5
103104: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103105: LD_INT 0
103107: PPUSH
103108: PPUSH
103109: PPUSH
103110: PPUSH
// task := GetTaskList ( unit ) ;
103111: LD_ADDR_VAR 0 7
103115: PUSH
103116: LD_VAR 0 1
103120: PPUSH
103121: CALL_OW 437
103125: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103126: LD_VAR 0 7
103130: NOT
103131: PUSH
103132: LD_VAR 0 1
103136: PPUSH
103137: LD_VAR 0 2
103141: PPUSH
103142: CALL_OW 308
103146: NOT
103147: AND
103148: IFFALSE 103152
// exit ;
103150: GO 103270
// if IsInArea ( unit , area ) then
103152: LD_VAR 0 1
103156: PPUSH
103157: LD_VAR 0 2
103161: PPUSH
103162: CALL_OW 308
103166: IFFALSE 103184
// begin ComMoveToArea ( unit , goAway ) ;
103168: LD_VAR 0 1
103172: PPUSH
103173: LD_VAR 0 3
103177: PPUSH
103178: CALL_OW 113
// exit ;
103182: GO 103270
// end ; if task [ 1 ] [ 1 ] <> M then
103184: LD_VAR 0 7
103188: PUSH
103189: LD_INT 1
103191: ARRAY
103192: PUSH
103193: LD_INT 1
103195: ARRAY
103196: PUSH
103197: LD_STRING M
103199: NONEQUAL
103200: IFFALSE 103204
// exit ;
103202: GO 103270
// x := task [ 1 ] [ 2 ] ;
103204: LD_ADDR_VAR 0 5
103208: PUSH
103209: LD_VAR 0 7
103213: PUSH
103214: LD_INT 1
103216: ARRAY
103217: PUSH
103218: LD_INT 2
103220: ARRAY
103221: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103222: LD_ADDR_VAR 0 6
103226: PUSH
103227: LD_VAR 0 7
103231: PUSH
103232: LD_INT 1
103234: ARRAY
103235: PUSH
103236: LD_INT 3
103238: ARRAY
103239: ST_TO_ADDR
// if InArea ( x , y , area ) then
103240: LD_VAR 0 5
103244: PPUSH
103245: LD_VAR 0 6
103249: PPUSH
103250: LD_VAR 0 2
103254: PPUSH
103255: CALL_OW 309
103259: IFFALSE 103270
// ComStop ( unit ) ;
103261: LD_VAR 0 1
103265: PPUSH
103266: CALL_OW 141
// end ;
103270: LD_VAR 0 4
103274: RET
// export function Abs ( value ) ; begin
103275: LD_INT 0
103277: PPUSH
// result := value ;
103278: LD_ADDR_VAR 0 2
103282: PUSH
103283: LD_VAR 0 1
103287: ST_TO_ADDR
// if value < 0 then
103288: LD_VAR 0 1
103292: PUSH
103293: LD_INT 0
103295: LESS
103296: IFFALSE 103313
// result := value * - 1 ;
103298: LD_ADDR_VAR 0 2
103302: PUSH
103303: LD_VAR 0 1
103307: PUSH
103308: LD_INT 1
103310: NEG
103311: MUL
103312: ST_TO_ADDR
// end ;
103313: LD_VAR 0 2
103317: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103318: LD_INT 0
103320: PPUSH
103321: PPUSH
103322: PPUSH
103323: PPUSH
103324: PPUSH
103325: PPUSH
103326: PPUSH
103327: PPUSH
// if not unit or not building then
103328: LD_VAR 0 1
103332: NOT
103333: PUSH
103334: LD_VAR 0 2
103338: NOT
103339: OR
103340: IFFALSE 103344
// exit ;
103342: GO 103570
// x := GetX ( building ) ;
103344: LD_ADDR_VAR 0 4
103348: PUSH
103349: LD_VAR 0 2
103353: PPUSH
103354: CALL_OW 250
103358: ST_TO_ADDR
// y := GetY ( building ) ;
103359: LD_ADDR_VAR 0 6
103363: PUSH
103364: LD_VAR 0 2
103368: PPUSH
103369: CALL_OW 251
103373: ST_TO_ADDR
// d := GetDir ( building ) ;
103374: LD_ADDR_VAR 0 8
103378: PUSH
103379: LD_VAR 0 2
103383: PPUSH
103384: CALL_OW 254
103388: ST_TO_ADDR
// r := 4 ;
103389: LD_ADDR_VAR 0 9
103393: PUSH
103394: LD_INT 4
103396: ST_TO_ADDR
// for i := 1 to 5 do
103397: LD_ADDR_VAR 0 10
103401: PUSH
103402: DOUBLE
103403: LD_INT 1
103405: DEC
103406: ST_TO_ADDR
103407: LD_INT 5
103409: PUSH
103410: FOR_TO
103411: IFFALSE 103568
// begin _x := ShiftX ( x , d , r + i ) ;
103413: LD_ADDR_VAR 0 5
103417: PUSH
103418: LD_VAR 0 4
103422: PPUSH
103423: LD_VAR 0 8
103427: PPUSH
103428: LD_VAR 0 9
103432: PUSH
103433: LD_VAR 0 10
103437: PLUS
103438: PPUSH
103439: CALL_OW 272
103443: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103444: LD_ADDR_VAR 0 7
103448: PUSH
103449: LD_VAR 0 6
103453: PPUSH
103454: LD_VAR 0 8
103458: PPUSH
103459: LD_VAR 0 9
103463: PUSH
103464: LD_VAR 0 10
103468: PLUS
103469: PPUSH
103470: CALL_OW 273
103474: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103475: LD_VAR 0 5
103479: PPUSH
103480: LD_VAR 0 7
103484: PPUSH
103485: CALL_OW 488
103489: PUSH
103490: LD_VAR 0 5
103494: PPUSH
103495: LD_VAR 0 7
103499: PPUSH
103500: CALL_OW 428
103504: PPUSH
103505: CALL_OW 247
103509: PUSH
103510: LD_INT 3
103512: PUSH
103513: LD_INT 2
103515: PUSH
103516: EMPTY
103517: LIST
103518: LIST
103519: IN
103520: NOT
103521: AND
103522: IFFALSE 103566
// begin ComMoveXY ( unit , _x , _y ) ;
103524: LD_VAR 0 1
103528: PPUSH
103529: LD_VAR 0 5
103533: PPUSH
103534: LD_VAR 0 7
103538: PPUSH
103539: CALL_OW 111
// result := [ _x , _y ] ;
103543: LD_ADDR_VAR 0 3
103547: PUSH
103548: LD_VAR 0 5
103552: PUSH
103553: LD_VAR 0 7
103557: PUSH
103558: EMPTY
103559: LIST
103560: LIST
103561: ST_TO_ADDR
// exit ;
103562: POP
103563: POP
103564: GO 103570
// end ; end ;
103566: GO 103410
103568: POP
103569: POP
// end ;
103570: LD_VAR 0 3
103574: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103575: LD_INT 0
103577: PPUSH
103578: PPUSH
103579: PPUSH
// result := 0 ;
103580: LD_ADDR_VAR 0 3
103584: PUSH
103585: LD_INT 0
103587: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103588: LD_VAR 0 1
103592: PUSH
103593: LD_INT 0
103595: LESS
103596: PUSH
103597: LD_VAR 0 1
103601: PUSH
103602: LD_INT 8
103604: GREATER
103605: OR
103606: PUSH
103607: LD_VAR 0 2
103611: PUSH
103612: LD_INT 0
103614: LESS
103615: OR
103616: PUSH
103617: LD_VAR 0 2
103621: PUSH
103622: LD_INT 8
103624: GREATER
103625: OR
103626: IFFALSE 103630
// exit ;
103628: GO 103705
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103630: LD_ADDR_VAR 0 4
103634: PUSH
103635: LD_INT 22
103637: PUSH
103638: LD_VAR 0 2
103642: PUSH
103643: EMPTY
103644: LIST
103645: LIST
103646: PPUSH
103647: CALL_OW 69
103651: PUSH
103652: FOR_IN
103653: IFFALSE 103703
// begin un := UnitShoot ( i ) ;
103655: LD_ADDR_VAR 0 5
103659: PUSH
103660: LD_VAR 0 4
103664: PPUSH
103665: CALL_OW 504
103669: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103670: LD_VAR 0 5
103674: PPUSH
103675: CALL_OW 255
103679: PUSH
103680: LD_VAR 0 1
103684: EQUAL
103685: IFFALSE 103701
// begin result := un ;
103687: LD_ADDR_VAR 0 3
103691: PUSH
103692: LD_VAR 0 5
103696: ST_TO_ADDR
// exit ;
103697: POP
103698: POP
103699: GO 103705
// end ; end ;
103701: GO 103652
103703: POP
103704: POP
// end ;
103705: LD_VAR 0 3
103709: RET
// export function GetCargoBay ( units ) ; begin
103710: LD_INT 0
103712: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103713: LD_ADDR_VAR 0 2
103717: PUSH
103718: LD_VAR 0 1
103722: PPUSH
103723: LD_INT 2
103725: PUSH
103726: LD_INT 34
103728: PUSH
103729: LD_INT 12
103731: PUSH
103732: EMPTY
103733: LIST
103734: LIST
103735: PUSH
103736: LD_INT 34
103738: PUSH
103739: LD_INT 51
103741: PUSH
103742: EMPTY
103743: LIST
103744: LIST
103745: PUSH
103746: LD_INT 34
103748: PUSH
103749: LD_INT 32
103751: PUSH
103752: EMPTY
103753: LIST
103754: LIST
103755: PUSH
103756: LD_INT 34
103758: PUSH
103759: LD_EXP 96
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: PUSH
103768: EMPTY
103769: LIST
103770: LIST
103771: LIST
103772: LIST
103773: LIST
103774: PPUSH
103775: CALL_OW 72
103779: ST_TO_ADDR
// end ;
103780: LD_VAR 0 2
103784: RET
// export function Negate ( value ) ; begin
103785: LD_INT 0
103787: PPUSH
// result := not value ;
103788: LD_ADDR_VAR 0 2
103792: PUSH
103793: LD_VAR 0 1
103797: NOT
103798: ST_TO_ADDR
// end ;
103799: LD_VAR 0 2
103803: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103804: LD_INT 0
103806: PPUSH
// if x1 = x2 then
103807: LD_VAR 0 1
103811: PUSH
103812: LD_VAR 0 3
103816: EQUAL
103817: IFFALSE 103851
// begin if y1 > y2 then
103819: LD_VAR 0 2
103823: PUSH
103824: LD_VAR 0 4
103828: GREATER
103829: IFFALSE 103841
// result := 0 else
103831: LD_ADDR_VAR 0 5
103835: PUSH
103836: LD_INT 0
103838: ST_TO_ADDR
103839: GO 103849
// result := 3 ;
103841: LD_ADDR_VAR 0 5
103845: PUSH
103846: LD_INT 3
103848: ST_TO_ADDR
// exit ;
103849: GO 103937
// end ; if y1 = y2 then
103851: LD_VAR 0 2
103855: PUSH
103856: LD_VAR 0 4
103860: EQUAL
103861: IFFALSE 103895
// begin if x1 > x2 then
103863: LD_VAR 0 1
103867: PUSH
103868: LD_VAR 0 3
103872: GREATER
103873: IFFALSE 103885
// result := 1 else
103875: LD_ADDR_VAR 0 5
103879: PUSH
103880: LD_INT 1
103882: ST_TO_ADDR
103883: GO 103893
// result := 4 ;
103885: LD_ADDR_VAR 0 5
103889: PUSH
103890: LD_INT 4
103892: ST_TO_ADDR
// exit ;
103893: GO 103937
// end ; if x1 > x2 and y1 > y2 then
103895: LD_VAR 0 1
103899: PUSH
103900: LD_VAR 0 3
103904: GREATER
103905: PUSH
103906: LD_VAR 0 2
103910: PUSH
103911: LD_VAR 0 4
103915: GREATER
103916: AND
103917: IFFALSE 103929
// result := 2 else
103919: LD_ADDR_VAR 0 5
103923: PUSH
103924: LD_INT 2
103926: ST_TO_ADDR
103927: GO 103937
// result := 5 ;
103929: LD_ADDR_VAR 0 5
103933: PUSH
103934: LD_INT 5
103936: ST_TO_ADDR
// end ;
103937: LD_VAR 0 5
103941: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103942: LD_INT 0
103944: PPUSH
103945: PPUSH
// if not driver or not IsInUnit ( driver ) then
103946: LD_VAR 0 1
103950: NOT
103951: PUSH
103952: LD_VAR 0 1
103956: PPUSH
103957: CALL_OW 310
103961: NOT
103962: OR
103963: IFFALSE 103967
// exit ;
103965: GO 104057
// vehicle := IsInUnit ( driver ) ;
103967: LD_ADDR_VAR 0 3
103971: PUSH
103972: LD_VAR 0 1
103976: PPUSH
103977: CALL_OW 310
103981: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103982: LD_VAR 0 1
103986: PPUSH
103987: LD_STRING \
103989: PUSH
103990: LD_INT 0
103992: PUSH
103993: LD_INT 0
103995: PUSH
103996: LD_INT 0
103998: PUSH
103999: LD_INT 0
104001: PUSH
104002: LD_INT 0
104004: PUSH
104005: LD_INT 0
104007: PUSH
104008: EMPTY
104009: LIST
104010: LIST
104011: LIST
104012: LIST
104013: LIST
104014: LIST
104015: LIST
104016: PUSH
104017: LD_STRING E
104019: PUSH
104020: LD_INT 0
104022: PUSH
104023: LD_INT 0
104025: PUSH
104026: LD_VAR 0 3
104030: PUSH
104031: LD_INT 0
104033: PUSH
104034: LD_INT 0
104036: PUSH
104037: LD_INT 0
104039: PUSH
104040: EMPTY
104041: LIST
104042: LIST
104043: LIST
104044: LIST
104045: LIST
104046: LIST
104047: LIST
104048: PUSH
104049: EMPTY
104050: LIST
104051: LIST
104052: PPUSH
104053: CALL_OW 446
// end ;
104057: LD_VAR 0 2
104061: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104062: LD_INT 0
104064: PPUSH
104065: PPUSH
// if not driver or not IsInUnit ( driver ) then
104066: LD_VAR 0 1
104070: NOT
104071: PUSH
104072: LD_VAR 0 1
104076: PPUSH
104077: CALL_OW 310
104081: NOT
104082: OR
104083: IFFALSE 104087
// exit ;
104085: GO 104177
// vehicle := IsInUnit ( driver ) ;
104087: LD_ADDR_VAR 0 3
104091: PUSH
104092: LD_VAR 0 1
104096: PPUSH
104097: CALL_OW 310
104101: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104102: LD_VAR 0 1
104106: PPUSH
104107: LD_STRING \
104109: PUSH
104110: LD_INT 0
104112: PUSH
104113: LD_INT 0
104115: PUSH
104116: LD_INT 0
104118: PUSH
104119: LD_INT 0
104121: PUSH
104122: LD_INT 0
104124: PUSH
104125: LD_INT 0
104127: PUSH
104128: EMPTY
104129: LIST
104130: LIST
104131: LIST
104132: LIST
104133: LIST
104134: LIST
104135: LIST
104136: PUSH
104137: LD_STRING E
104139: PUSH
104140: LD_INT 0
104142: PUSH
104143: LD_INT 0
104145: PUSH
104146: LD_VAR 0 3
104150: PUSH
104151: LD_INT 0
104153: PUSH
104154: LD_INT 0
104156: PUSH
104157: LD_INT 0
104159: PUSH
104160: EMPTY
104161: LIST
104162: LIST
104163: LIST
104164: LIST
104165: LIST
104166: LIST
104167: LIST
104168: PUSH
104169: EMPTY
104170: LIST
104171: LIST
104172: PPUSH
104173: CALL_OW 447
// end ;
104177: LD_VAR 0 2
104181: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104182: LD_INT 0
104184: PPUSH
104185: PPUSH
104186: PPUSH
// tmp := [ ] ;
104187: LD_ADDR_VAR 0 5
104191: PUSH
104192: EMPTY
104193: ST_TO_ADDR
// for i in units do
104194: LD_ADDR_VAR 0 4
104198: PUSH
104199: LD_VAR 0 1
104203: PUSH
104204: FOR_IN
104205: IFFALSE 104243
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104207: LD_ADDR_VAR 0 5
104211: PUSH
104212: LD_VAR 0 5
104216: PPUSH
104217: LD_VAR 0 5
104221: PUSH
104222: LD_INT 1
104224: PLUS
104225: PPUSH
104226: LD_VAR 0 4
104230: PPUSH
104231: CALL_OW 256
104235: PPUSH
104236: CALL_OW 2
104240: ST_TO_ADDR
104241: GO 104204
104243: POP
104244: POP
// if not tmp then
104245: LD_VAR 0 5
104249: NOT
104250: IFFALSE 104254
// exit ;
104252: GO 104302
// if asc then
104254: LD_VAR 0 2
104258: IFFALSE 104282
// result := SortListByListAsc ( units , tmp ) else
104260: LD_ADDR_VAR 0 3
104264: PUSH
104265: LD_VAR 0 1
104269: PPUSH
104270: LD_VAR 0 5
104274: PPUSH
104275: CALL_OW 76
104279: ST_TO_ADDR
104280: GO 104302
// result := SortListByListDesc ( units , tmp ) ;
104282: LD_ADDR_VAR 0 3
104286: PUSH
104287: LD_VAR 0 1
104291: PPUSH
104292: LD_VAR 0 5
104296: PPUSH
104297: CALL_OW 77
104301: ST_TO_ADDR
// end ;
104302: LD_VAR 0 3
104306: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104307: LD_INT 0
104309: PPUSH
104310: PPUSH
// task := GetTaskList ( mech ) ;
104311: LD_ADDR_VAR 0 4
104315: PUSH
104316: LD_VAR 0 1
104320: PPUSH
104321: CALL_OW 437
104325: ST_TO_ADDR
// if not task then
104326: LD_VAR 0 4
104330: NOT
104331: IFFALSE 104335
// exit ;
104333: GO 104377
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104335: LD_ADDR_VAR 0 3
104339: PUSH
104340: LD_VAR 0 4
104344: PUSH
104345: LD_INT 1
104347: ARRAY
104348: PUSH
104349: LD_INT 1
104351: ARRAY
104352: PUSH
104353: LD_STRING r
104355: EQUAL
104356: PUSH
104357: LD_VAR 0 4
104361: PUSH
104362: LD_INT 1
104364: ARRAY
104365: PUSH
104366: LD_INT 4
104368: ARRAY
104369: PUSH
104370: LD_VAR 0 2
104374: EQUAL
104375: AND
104376: ST_TO_ADDR
// end ;
104377: LD_VAR 0 3
104381: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104382: LD_INT 0
104384: PPUSH
// SetDir ( unit , d ) ;
104385: LD_VAR 0 1
104389: PPUSH
104390: LD_VAR 0 4
104394: PPUSH
104395: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104399: LD_VAR 0 1
104403: PPUSH
104404: LD_VAR 0 2
104408: PPUSH
104409: LD_VAR 0 3
104413: PPUSH
104414: LD_VAR 0 5
104418: PPUSH
104419: CALL_OW 48
// end ;
104423: LD_VAR 0 6
104427: RET
// export function ToNaturalNumber ( number ) ; begin
104428: LD_INT 0
104430: PPUSH
// result := number div 1 ;
104431: LD_ADDR_VAR 0 2
104435: PUSH
104436: LD_VAR 0 1
104440: PUSH
104441: LD_INT 1
104443: DIV
104444: ST_TO_ADDR
// if number < 0 then
104445: LD_VAR 0 1
104449: PUSH
104450: LD_INT 0
104452: LESS
104453: IFFALSE 104463
// result := 0 ;
104455: LD_ADDR_VAR 0 2
104459: PUSH
104460: LD_INT 0
104462: ST_TO_ADDR
// end ;
104463: LD_VAR 0 2
104467: RET
// export function SortByClass ( units , class ) ; var un ; begin
104468: LD_INT 0
104470: PPUSH
104471: PPUSH
// if not units or not class then
104472: LD_VAR 0 1
104476: NOT
104477: PUSH
104478: LD_VAR 0 2
104482: NOT
104483: OR
104484: IFFALSE 104488
// exit ;
104486: GO 104583
// result := [ ] ;
104488: LD_ADDR_VAR 0 3
104492: PUSH
104493: EMPTY
104494: ST_TO_ADDR
// for un in units do
104495: LD_ADDR_VAR 0 4
104499: PUSH
104500: LD_VAR 0 1
104504: PUSH
104505: FOR_IN
104506: IFFALSE 104581
// if GetClass ( un ) = class then
104508: LD_VAR 0 4
104512: PPUSH
104513: CALL_OW 257
104517: PUSH
104518: LD_VAR 0 2
104522: EQUAL
104523: IFFALSE 104550
// result := Insert ( result , 1 , un ) else
104525: LD_ADDR_VAR 0 3
104529: PUSH
104530: LD_VAR 0 3
104534: PPUSH
104535: LD_INT 1
104537: PPUSH
104538: LD_VAR 0 4
104542: PPUSH
104543: CALL_OW 2
104547: ST_TO_ADDR
104548: GO 104579
// result := Replace ( result , result + 1 , un ) ;
104550: LD_ADDR_VAR 0 3
104554: PUSH
104555: LD_VAR 0 3
104559: PPUSH
104560: LD_VAR 0 3
104564: PUSH
104565: LD_INT 1
104567: PLUS
104568: PPUSH
104569: LD_VAR 0 4
104573: PPUSH
104574: CALL_OW 1
104578: ST_TO_ADDR
104579: GO 104505
104581: POP
104582: POP
// end ;
104583: LD_VAR 0 3
104587: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104588: LD_INT 0
104590: PPUSH
104591: PPUSH
104592: PPUSH
104593: PPUSH
104594: PPUSH
104595: PPUSH
104596: PPUSH
// result := [ ] ;
104597: LD_ADDR_VAR 0 4
104601: PUSH
104602: EMPTY
104603: ST_TO_ADDR
// if x - r < 0 then
104604: LD_VAR 0 1
104608: PUSH
104609: LD_VAR 0 3
104613: MINUS
104614: PUSH
104615: LD_INT 0
104617: LESS
104618: IFFALSE 104630
// min_x := 0 else
104620: LD_ADDR_VAR 0 8
104624: PUSH
104625: LD_INT 0
104627: ST_TO_ADDR
104628: GO 104646
// min_x := x - r ;
104630: LD_ADDR_VAR 0 8
104634: PUSH
104635: LD_VAR 0 1
104639: PUSH
104640: LD_VAR 0 3
104644: MINUS
104645: ST_TO_ADDR
// if y - r < 0 then
104646: LD_VAR 0 2
104650: PUSH
104651: LD_VAR 0 3
104655: MINUS
104656: PUSH
104657: LD_INT 0
104659: LESS
104660: IFFALSE 104672
// min_y := 0 else
104662: LD_ADDR_VAR 0 7
104666: PUSH
104667: LD_INT 0
104669: ST_TO_ADDR
104670: GO 104688
// min_y := y - r ;
104672: LD_ADDR_VAR 0 7
104676: PUSH
104677: LD_VAR 0 2
104681: PUSH
104682: LD_VAR 0 3
104686: MINUS
104687: ST_TO_ADDR
// max_x := x + r ;
104688: LD_ADDR_VAR 0 9
104692: PUSH
104693: LD_VAR 0 1
104697: PUSH
104698: LD_VAR 0 3
104702: PLUS
104703: ST_TO_ADDR
// max_y := y + r ;
104704: LD_ADDR_VAR 0 10
104708: PUSH
104709: LD_VAR 0 2
104713: PUSH
104714: LD_VAR 0 3
104718: PLUS
104719: ST_TO_ADDR
// for _x = min_x to max_x do
104720: LD_ADDR_VAR 0 5
104724: PUSH
104725: DOUBLE
104726: LD_VAR 0 8
104730: DEC
104731: ST_TO_ADDR
104732: LD_VAR 0 9
104736: PUSH
104737: FOR_TO
104738: IFFALSE 104839
// for _y = min_y to max_y do
104740: LD_ADDR_VAR 0 6
104744: PUSH
104745: DOUBLE
104746: LD_VAR 0 7
104750: DEC
104751: ST_TO_ADDR
104752: LD_VAR 0 10
104756: PUSH
104757: FOR_TO
104758: IFFALSE 104835
// begin if not ValidHex ( _x , _y ) then
104760: LD_VAR 0 5
104764: PPUSH
104765: LD_VAR 0 6
104769: PPUSH
104770: CALL_OW 488
104774: NOT
104775: IFFALSE 104779
// continue ;
104777: GO 104757
// if GetResourceTypeXY ( _x , _y ) then
104779: LD_VAR 0 5
104783: PPUSH
104784: LD_VAR 0 6
104788: PPUSH
104789: CALL_OW 283
104793: IFFALSE 104833
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
104795: LD_ADDR_VAR 0 4
104799: PUSH
104800: LD_VAR 0 4
104804: PPUSH
104805: LD_VAR 0 4
104809: PUSH
104810: LD_INT 1
104812: PLUS
104813: PPUSH
104814: LD_VAR 0 5
104818: PUSH
104819: LD_VAR 0 6
104823: PUSH
104824: EMPTY
104825: LIST
104826: LIST
104827: PPUSH
104828: CALL_OW 1
104832: ST_TO_ADDR
// end ;
104833: GO 104757
104835: POP
104836: POP
104837: GO 104737
104839: POP
104840: POP
// end ;
104841: LD_VAR 0 4
104845: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
104846: LD_INT 0
104848: PPUSH
104849: PPUSH
104850: PPUSH
104851: PPUSH
104852: PPUSH
104853: PPUSH
// if not units then
104854: LD_VAR 0 1
104858: NOT
104859: IFFALSE 104863
// exit ;
104861: GO 105264
// result := UnitFilter ( units , [ f_ok ] ) ;
104863: LD_ADDR_VAR 0 3
104867: PUSH
104868: LD_VAR 0 1
104872: PPUSH
104873: LD_INT 50
104875: PUSH
104876: EMPTY
104877: LIST
104878: PPUSH
104879: CALL_OW 72
104883: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
104884: LD_ADDR_VAR 0 7
104888: PUSH
104889: LD_VAR 0 1
104893: PUSH
104894: LD_INT 1
104896: ARRAY
104897: PPUSH
104898: CALL_OW 255
104902: ST_TO_ADDR
// if not result then
104903: LD_VAR 0 3
104907: NOT
104908: IFFALSE 104912
// exit ;
104910: GO 105264
// for i in result do
104912: LD_ADDR_VAR 0 4
104916: PUSH
104917: LD_VAR 0 3
104921: PUSH
104922: FOR_IN
104923: IFFALSE 105262
// begin tag := GetTag ( i ) + 1 ;
104925: LD_ADDR_VAR 0 8
104929: PUSH
104930: LD_VAR 0 4
104934: PPUSH
104935: CALL_OW 110
104939: PUSH
104940: LD_INT 1
104942: PLUS
104943: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
104944: LD_ADDR_VAR 0 6
104948: PUSH
104949: LD_VAR 0 4
104953: PPUSH
104954: CALL_OW 250
104958: PPUSH
104959: LD_VAR 0 4
104963: PPUSH
104964: CALL_OW 251
104968: PPUSH
104969: LD_INT 6
104971: PPUSH
104972: CALL 104588 0 3
104976: ST_TO_ADDR
// if cr then
104977: LD_VAR 0 6
104981: IFFALSE 105020
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
104983: LD_VAR 0 4
104987: PPUSH
104988: LD_VAR 0 6
104992: PUSH
104993: LD_INT 1
104995: ARRAY
104996: PUSH
104997: LD_INT 1
104999: ARRAY
105000: PPUSH
105001: LD_VAR 0 6
105005: PUSH
105006: LD_INT 1
105008: ARRAY
105009: PUSH
105010: LD_INT 2
105012: ARRAY
105013: PPUSH
105014: CALL_OW 116
105018: GO 105260
// if path > tag then
105020: LD_VAR 0 2
105024: PUSH
105025: LD_VAR 0 8
105029: GREATER
105030: IFFALSE 105208
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
105032: LD_ADDR_VAR 0 5
105036: PUSH
105037: LD_INT 81
105039: PUSH
105040: LD_VAR 0 7
105044: PUSH
105045: EMPTY
105046: LIST
105047: LIST
105048: PUSH
105049: LD_INT 91
105051: PUSH
105052: LD_VAR 0 4
105056: PUSH
105057: LD_INT 12
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: LIST
105064: PUSH
105065: EMPTY
105066: LIST
105067: LIST
105068: PPUSH
105069: CALL_OW 69
105073: ST_TO_ADDR
// if enemy then
105074: LD_VAR 0 5
105078: IFFALSE 105106
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105080: LD_VAR 0 4
105084: PPUSH
105085: LD_VAR 0 5
105089: PPUSH
105090: LD_VAR 0 4
105094: PPUSH
105095: CALL_OW 74
105099: PPUSH
105100: CALL_OW 115
105104: GO 105206
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
105106: LD_VAR 0 4
105110: PPUSH
105111: LD_VAR 0 2
105115: PUSH
105116: LD_VAR 0 8
105120: ARRAY
105121: PUSH
105122: LD_INT 1
105124: ARRAY
105125: PPUSH
105126: LD_VAR 0 2
105130: PUSH
105131: LD_VAR 0 8
105135: ARRAY
105136: PUSH
105137: LD_INT 2
105139: ARRAY
105140: PPUSH
105141: CALL_OW 297
105145: PUSH
105146: LD_INT 6
105148: GREATER
105149: IFFALSE 105192
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
105151: LD_VAR 0 4
105155: PPUSH
105156: LD_VAR 0 2
105160: PUSH
105161: LD_VAR 0 8
105165: ARRAY
105166: PUSH
105167: LD_INT 1
105169: ARRAY
105170: PPUSH
105171: LD_VAR 0 2
105175: PUSH
105176: LD_VAR 0 8
105180: ARRAY
105181: PUSH
105182: LD_INT 2
105184: ARRAY
105185: PPUSH
105186: CALL_OW 114
105190: GO 105206
// SetTag ( i , tag ) ;
105192: LD_VAR 0 4
105196: PPUSH
105197: LD_VAR 0 8
105201: PPUSH
105202: CALL_OW 109
// end else
105206: GO 105260
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105208: LD_ADDR_VAR 0 5
105212: PUSH
105213: LD_INT 81
105215: PUSH
105216: LD_VAR 0 7
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: PPUSH
105225: CALL_OW 69
105229: ST_TO_ADDR
// if enemy then
105230: LD_VAR 0 5
105234: IFFALSE 105260
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
105236: LD_VAR 0 4
105240: PPUSH
105241: LD_VAR 0 5
105245: PPUSH
105246: LD_VAR 0 4
105250: PPUSH
105251: CALL_OW 74
105255: PPUSH
105256: CALL_OW 115
// end ; end ;
105260: GO 104922
105262: POP
105263: POP
// end ; end_of_file end_of_file
105264: LD_VAR 0 3
105268: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105269: LD_INT 0
105271: PPUSH
// if p2 = 100 then
105272: LD_VAR 0 2
105276: PUSH
105277: LD_INT 100
105279: EQUAL
105280: IFFALSE 106229
// begin if not StreamModeActive then
105282: LD_EXP 160
105286: NOT
105287: IFFALSE 105297
// StreamModeActive := true ;
105289: LD_ADDR_EXP 160
105293: PUSH
105294: LD_INT 1
105296: ST_TO_ADDR
// if p3 = 0 then
105297: LD_VAR 0 3
105301: PUSH
105302: LD_INT 0
105304: EQUAL
105305: IFFALSE 105311
// InitStreamMode ;
105307: CALL 106389 0 0
// if p3 = 1 then
105311: LD_VAR 0 3
105315: PUSH
105316: LD_INT 1
105318: EQUAL
105319: IFFALSE 105329
// sRocket := true ;
105321: LD_ADDR_EXP 165
105325: PUSH
105326: LD_INT 1
105328: ST_TO_ADDR
// if p3 = 2 then
105329: LD_VAR 0 3
105333: PUSH
105334: LD_INT 2
105336: EQUAL
105337: IFFALSE 105347
// sSpeed := true ;
105339: LD_ADDR_EXP 164
105343: PUSH
105344: LD_INT 1
105346: ST_TO_ADDR
// if p3 = 3 then
105347: LD_VAR 0 3
105351: PUSH
105352: LD_INT 3
105354: EQUAL
105355: IFFALSE 105365
// sEngine := true ;
105357: LD_ADDR_EXP 166
105361: PUSH
105362: LD_INT 1
105364: ST_TO_ADDR
// if p3 = 4 then
105365: LD_VAR 0 3
105369: PUSH
105370: LD_INT 4
105372: EQUAL
105373: IFFALSE 105383
// sSpec := true ;
105375: LD_ADDR_EXP 163
105379: PUSH
105380: LD_INT 1
105382: ST_TO_ADDR
// if p3 = 5 then
105383: LD_VAR 0 3
105387: PUSH
105388: LD_INT 5
105390: EQUAL
105391: IFFALSE 105401
// sLevel := true ;
105393: LD_ADDR_EXP 167
105397: PUSH
105398: LD_INT 1
105400: ST_TO_ADDR
// if p3 = 6 then
105401: LD_VAR 0 3
105405: PUSH
105406: LD_INT 6
105408: EQUAL
105409: IFFALSE 105419
// sArmoury := true ;
105411: LD_ADDR_EXP 168
105415: PUSH
105416: LD_INT 1
105418: ST_TO_ADDR
// if p3 = 7 then
105419: LD_VAR 0 3
105423: PUSH
105424: LD_INT 7
105426: EQUAL
105427: IFFALSE 105437
// sRadar := true ;
105429: LD_ADDR_EXP 169
105433: PUSH
105434: LD_INT 1
105436: ST_TO_ADDR
// if p3 = 8 then
105437: LD_VAR 0 3
105441: PUSH
105442: LD_INT 8
105444: EQUAL
105445: IFFALSE 105455
// sBunker := true ;
105447: LD_ADDR_EXP 170
105451: PUSH
105452: LD_INT 1
105454: ST_TO_ADDR
// if p3 = 9 then
105455: LD_VAR 0 3
105459: PUSH
105460: LD_INT 9
105462: EQUAL
105463: IFFALSE 105473
// sHack := true ;
105465: LD_ADDR_EXP 171
105469: PUSH
105470: LD_INT 1
105472: ST_TO_ADDR
// if p3 = 10 then
105473: LD_VAR 0 3
105477: PUSH
105478: LD_INT 10
105480: EQUAL
105481: IFFALSE 105491
// sFire := true ;
105483: LD_ADDR_EXP 172
105487: PUSH
105488: LD_INT 1
105490: ST_TO_ADDR
// if p3 = 11 then
105491: LD_VAR 0 3
105495: PUSH
105496: LD_INT 11
105498: EQUAL
105499: IFFALSE 105509
// sRefresh := true ;
105501: LD_ADDR_EXP 173
105505: PUSH
105506: LD_INT 1
105508: ST_TO_ADDR
// if p3 = 12 then
105509: LD_VAR 0 3
105513: PUSH
105514: LD_INT 12
105516: EQUAL
105517: IFFALSE 105527
// sExp := true ;
105519: LD_ADDR_EXP 174
105523: PUSH
105524: LD_INT 1
105526: ST_TO_ADDR
// if p3 = 13 then
105527: LD_VAR 0 3
105531: PUSH
105532: LD_INT 13
105534: EQUAL
105535: IFFALSE 105545
// sDepot := true ;
105537: LD_ADDR_EXP 175
105541: PUSH
105542: LD_INT 1
105544: ST_TO_ADDR
// if p3 = 14 then
105545: LD_VAR 0 3
105549: PUSH
105550: LD_INT 14
105552: EQUAL
105553: IFFALSE 105563
// sFlag := true ;
105555: LD_ADDR_EXP 176
105559: PUSH
105560: LD_INT 1
105562: ST_TO_ADDR
// if p3 = 15 then
105563: LD_VAR 0 3
105567: PUSH
105568: LD_INT 15
105570: EQUAL
105571: IFFALSE 105581
// sKamikadze := true ;
105573: LD_ADDR_EXP 184
105577: PUSH
105578: LD_INT 1
105580: ST_TO_ADDR
// if p3 = 16 then
105581: LD_VAR 0 3
105585: PUSH
105586: LD_INT 16
105588: EQUAL
105589: IFFALSE 105599
// sTroll := true ;
105591: LD_ADDR_EXP 185
105595: PUSH
105596: LD_INT 1
105598: ST_TO_ADDR
// if p3 = 17 then
105599: LD_VAR 0 3
105603: PUSH
105604: LD_INT 17
105606: EQUAL
105607: IFFALSE 105617
// sSlow := true ;
105609: LD_ADDR_EXP 186
105613: PUSH
105614: LD_INT 1
105616: ST_TO_ADDR
// if p3 = 18 then
105617: LD_VAR 0 3
105621: PUSH
105622: LD_INT 18
105624: EQUAL
105625: IFFALSE 105635
// sLack := true ;
105627: LD_ADDR_EXP 187
105631: PUSH
105632: LD_INT 1
105634: ST_TO_ADDR
// if p3 = 19 then
105635: LD_VAR 0 3
105639: PUSH
105640: LD_INT 19
105642: EQUAL
105643: IFFALSE 105653
// sTank := true ;
105645: LD_ADDR_EXP 189
105649: PUSH
105650: LD_INT 1
105652: ST_TO_ADDR
// if p3 = 20 then
105653: LD_VAR 0 3
105657: PUSH
105658: LD_INT 20
105660: EQUAL
105661: IFFALSE 105671
// sRemote := true ;
105663: LD_ADDR_EXP 190
105667: PUSH
105668: LD_INT 1
105670: ST_TO_ADDR
// if p3 = 21 then
105671: LD_VAR 0 3
105675: PUSH
105676: LD_INT 21
105678: EQUAL
105679: IFFALSE 105689
// sPowell := true ;
105681: LD_ADDR_EXP 191
105685: PUSH
105686: LD_INT 1
105688: ST_TO_ADDR
// if p3 = 22 then
105689: LD_VAR 0 3
105693: PUSH
105694: LD_INT 22
105696: EQUAL
105697: IFFALSE 105707
// sTeleport := true ;
105699: LD_ADDR_EXP 194
105703: PUSH
105704: LD_INT 1
105706: ST_TO_ADDR
// if p3 = 23 then
105707: LD_VAR 0 3
105711: PUSH
105712: LD_INT 23
105714: EQUAL
105715: IFFALSE 105725
// sOilTower := true ;
105717: LD_ADDR_EXP 196
105721: PUSH
105722: LD_INT 1
105724: ST_TO_ADDR
// if p3 = 24 then
105725: LD_VAR 0 3
105729: PUSH
105730: LD_INT 24
105732: EQUAL
105733: IFFALSE 105743
// sShovel := true ;
105735: LD_ADDR_EXP 197
105739: PUSH
105740: LD_INT 1
105742: ST_TO_ADDR
// if p3 = 25 then
105743: LD_VAR 0 3
105747: PUSH
105748: LD_INT 25
105750: EQUAL
105751: IFFALSE 105761
// sSheik := true ;
105753: LD_ADDR_EXP 198
105757: PUSH
105758: LD_INT 1
105760: ST_TO_ADDR
// if p3 = 26 then
105761: LD_VAR 0 3
105765: PUSH
105766: LD_INT 26
105768: EQUAL
105769: IFFALSE 105779
// sEarthquake := true ;
105771: LD_ADDR_EXP 200
105775: PUSH
105776: LD_INT 1
105778: ST_TO_ADDR
// if p3 = 27 then
105779: LD_VAR 0 3
105783: PUSH
105784: LD_INT 27
105786: EQUAL
105787: IFFALSE 105797
// sAI := true ;
105789: LD_ADDR_EXP 201
105793: PUSH
105794: LD_INT 1
105796: ST_TO_ADDR
// if p3 = 28 then
105797: LD_VAR 0 3
105801: PUSH
105802: LD_INT 28
105804: EQUAL
105805: IFFALSE 105815
// sCargo := true ;
105807: LD_ADDR_EXP 204
105811: PUSH
105812: LD_INT 1
105814: ST_TO_ADDR
// if p3 = 29 then
105815: LD_VAR 0 3
105819: PUSH
105820: LD_INT 29
105822: EQUAL
105823: IFFALSE 105833
// sDLaser := true ;
105825: LD_ADDR_EXP 205
105829: PUSH
105830: LD_INT 1
105832: ST_TO_ADDR
// if p3 = 30 then
105833: LD_VAR 0 3
105837: PUSH
105838: LD_INT 30
105840: EQUAL
105841: IFFALSE 105851
// sExchange := true ;
105843: LD_ADDR_EXP 206
105847: PUSH
105848: LD_INT 1
105850: ST_TO_ADDR
// if p3 = 31 then
105851: LD_VAR 0 3
105855: PUSH
105856: LD_INT 31
105858: EQUAL
105859: IFFALSE 105869
// sFac := true ;
105861: LD_ADDR_EXP 207
105865: PUSH
105866: LD_INT 1
105868: ST_TO_ADDR
// if p3 = 32 then
105869: LD_VAR 0 3
105873: PUSH
105874: LD_INT 32
105876: EQUAL
105877: IFFALSE 105887
// sPower := true ;
105879: LD_ADDR_EXP 208
105883: PUSH
105884: LD_INT 1
105886: ST_TO_ADDR
// if p3 = 33 then
105887: LD_VAR 0 3
105891: PUSH
105892: LD_INT 33
105894: EQUAL
105895: IFFALSE 105905
// sRandom := true ;
105897: LD_ADDR_EXP 209
105901: PUSH
105902: LD_INT 1
105904: ST_TO_ADDR
// if p3 = 34 then
105905: LD_VAR 0 3
105909: PUSH
105910: LD_INT 34
105912: EQUAL
105913: IFFALSE 105923
// sShield := true ;
105915: LD_ADDR_EXP 210
105919: PUSH
105920: LD_INT 1
105922: ST_TO_ADDR
// if p3 = 35 then
105923: LD_VAR 0 3
105927: PUSH
105928: LD_INT 35
105930: EQUAL
105931: IFFALSE 105941
// sTime := true ;
105933: LD_ADDR_EXP 211
105937: PUSH
105938: LD_INT 1
105940: ST_TO_ADDR
// if p3 = 36 then
105941: LD_VAR 0 3
105945: PUSH
105946: LD_INT 36
105948: EQUAL
105949: IFFALSE 105959
// sTools := true ;
105951: LD_ADDR_EXP 212
105955: PUSH
105956: LD_INT 1
105958: ST_TO_ADDR
// if p3 = 101 then
105959: LD_VAR 0 3
105963: PUSH
105964: LD_INT 101
105966: EQUAL
105967: IFFALSE 105977
// sSold := true ;
105969: LD_ADDR_EXP 177
105973: PUSH
105974: LD_INT 1
105976: ST_TO_ADDR
// if p3 = 102 then
105977: LD_VAR 0 3
105981: PUSH
105982: LD_INT 102
105984: EQUAL
105985: IFFALSE 105995
// sDiff := true ;
105987: LD_ADDR_EXP 178
105991: PUSH
105992: LD_INT 1
105994: ST_TO_ADDR
// if p3 = 103 then
105995: LD_VAR 0 3
105999: PUSH
106000: LD_INT 103
106002: EQUAL
106003: IFFALSE 106013
// sFog := true ;
106005: LD_ADDR_EXP 181
106009: PUSH
106010: LD_INT 1
106012: ST_TO_ADDR
// if p3 = 104 then
106013: LD_VAR 0 3
106017: PUSH
106018: LD_INT 104
106020: EQUAL
106021: IFFALSE 106031
// sReset := true ;
106023: LD_ADDR_EXP 182
106027: PUSH
106028: LD_INT 1
106030: ST_TO_ADDR
// if p3 = 105 then
106031: LD_VAR 0 3
106035: PUSH
106036: LD_INT 105
106038: EQUAL
106039: IFFALSE 106049
// sSun := true ;
106041: LD_ADDR_EXP 183
106045: PUSH
106046: LD_INT 1
106048: ST_TO_ADDR
// if p3 = 106 then
106049: LD_VAR 0 3
106053: PUSH
106054: LD_INT 106
106056: EQUAL
106057: IFFALSE 106067
// sTiger := true ;
106059: LD_ADDR_EXP 179
106063: PUSH
106064: LD_INT 1
106066: ST_TO_ADDR
// if p3 = 107 then
106067: LD_VAR 0 3
106071: PUSH
106072: LD_INT 107
106074: EQUAL
106075: IFFALSE 106085
// sBomb := true ;
106077: LD_ADDR_EXP 180
106081: PUSH
106082: LD_INT 1
106084: ST_TO_ADDR
// if p3 = 108 then
106085: LD_VAR 0 3
106089: PUSH
106090: LD_INT 108
106092: EQUAL
106093: IFFALSE 106103
// sWound := true ;
106095: LD_ADDR_EXP 188
106099: PUSH
106100: LD_INT 1
106102: ST_TO_ADDR
// if p3 = 109 then
106103: LD_VAR 0 3
106107: PUSH
106108: LD_INT 109
106110: EQUAL
106111: IFFALSE 106121
// sBetray := true ;
106113: LD_ADDR_EXP 192
106117: PUSH
106118: LD_INT 1
106120: ST_TO_ADDR
// if p3 = 110 then
106121: LD_VAR 0 3
106125: PUSH
106126: LD_INT 110
106128: EQUAL
106129: IFFALSE 106139
// sContamin := true ;
106131: LD_ADDR_EXP 193
106135: PUSH
106136: LD_INT 1
106138: ST_TO_ADDR
// if p3 = 111 then
106139: LD_VAR 0 3
106143: PUSH
106144: LD_INT 111
106146: EQUAL
106147: IFFALSE 106157
// sOil := true ;
106149: LD_ADDR_EXP 195
106153: PUSH
106154: LD_INT 1
106156: ST_TO_ADDR
// if p3 = 112 then
106157: LD_VAR 0 3
106161: PUSH
106162: LD_INT 112
106164: EQUAL
106165: IFFALSE 106175
// sStu := true ;
106167: LD_ADDR_EXP 199
106171: PUSH
106172: LD_INT 1
106174: ST_TO_ADDR
// if p3 = 113 then
106175: LD_VAR 0 3
106179: PUSH
106180: LD_INT 113
106182: EQUAL
106183: IFFALSE 106193
// sBazooka := true ;
106185: LD_ADDR_EXP 202
106189: PUSH
106190: LD_INT 1
106192: ST_TO_ADDR
// if p3 = 114 then
106193: LD_VAR 0 3
106197: PUSH
106198: LD_INT 114
106200: EQUAL
106201: IFFALSE 106211
// sMortar := true ;
106203: LD_ADDR_EXP 203
106207: PUSH
106208: LD_INT 1
106210: ST_TO_ADDR
// if p3 = 115 then
106211: LD_VAR 0 3
106215: PUSH
106216: LD_INT 115
106218: EQUAL
106219: IFFALSE 106229
// sRanger := true ;
106221: LD_ADDR_EXP 213
106225: PUSH
106226: LD_INT 1
106228: ST_TO_ADDR
// end ; if p2 = 101 then
106229: LD_VAR 0 2
106233: PUSH
106234: LD_INT 101
106236: EQUAL
106237: IFFALSE 106365
// begin case p3 of 1 :
106239: LD_VAR 0 3
106243: PUSH
106244: LD_INT 1
106246: DOUBLE
106247: EQUAL
106248: IFTRUE 106252
106250: GO 106259
106252: POP
// hHackUnlimitedResources ; 2 :
106253: CALL 117402 0 0
106257: GO 106365
106259: LD_INT 2
106261: DOUBLE
106262: EQUAL
106263: IFTRUE 106267
106265: GO 106274
106267: POP
// hHackSetLevel10 ; 3 :
106268: CALL 117535 0 0
106272: GO 106365
106274: LD_INT 3
106276: DOUBLE
106277: EQUAL
106278: IFTRUE 106282
106280: GO 106289
106282: POP
// hHackSetLevel10YourUnits ; 4 :
106283: CALL 117620 0 0
106287: GO 106365
106289: LD_INT 4
106291: DOUBLE
106292: EQUAL
106293: IFTRUE 106297
106295: GO 106304
106297: POP
// hHackInvincible ; 5 :
106298: CALL 118068 0 0
106302: GO 106365
106304: LD_INT 5
106306: DOUBLE
106307: EQUAL
106308: IFTRUE 106312
106310: GO 106319
106312: POP
// hHackInvisible ; 6 :
106313: CALL 118179 0 0
106317: GO 106365
106319: LD_INT 6
106321: DOUBLE
106322: EQUAL
106323: IFTRUE 106327
106325: GO 106334
106327: POP
// hHackChangeYourSide ; 7 :
106328: CALL 118236 0 0
106332: GO 106365
106334: LD_INT 7
106336: DOUBLE
106337: EQUAL
106338: IFTRUE 106342
106340: GO 106349
106342: POP
// hHackChangeUnitSide ; 8 :
106343: CALL 118278 0 0
106347: GO 106365
106349: LD_INT 8
106351: DOUBLE
106352: EQUAL
106353: IFTRUE 106357
106355: GO 106364
106357: POP
// hHackFog ; end ;
106358: CALL 118379 0 0
106362: GO 106365
106364: POP
// end ; end ;
106365: LD_VAR 0 7
106369: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
106370: GO 106372
106372: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
106373: LD_STRING initStreamRollete();
106375: PPUSH
106376: CALL_OW 559
// InitStreamMode ;
106380: CALL 106389 0 0
// DefineStreamItems ( ) ;
106384: CALL 106829 0 0
// end ;
106388: END
// function InitStreamMode ; begin
106389: LD_INT 0
106391: PPUSH
// streamModeActive := false ;
106392: LD_ADDR_EXP 160
106396: PUSH
106397: LD_INT 0
106399: ST_TO_ADDR
// normalCounter := 36 ;
106400: LD_ADDR_EXP 161
106404: PUSH
106405: LD_INT 36
106407: ST_TO_ADDR
// hardcoreCounter := 16 ;
106408: LD_ADDR_EXP 162
106412: PUSH
106413: LD_INT 16
106415: ST_TO_ADDR
// sRocket := false ;
106416: LD_ADDR_EXP 165
106420: PUSH
106421: LD_INT 0
106423: ST_TO_ADDR
// sSpeed := false ;
106424: LD_ADDR_EXP 164
106428: PUSH
106429: LD_INT 0
106431: ST_TO_ADDR
// sEngine := false ;
106432: LD_ADDR_EXP 166
106436: PUSH
106437: LD_INT 0
106439: ST_TO_ADDR
// sSpec := false ;
106440: LD_ADDR_EXP 163
106444: PUSH
106445: LD_INT 0
106447: ST_TO_ADDR
// sLevel := false ;
106448: LD_ADDR_EXP 167
106452: PUSH
106453: LD_INT 0
106455: ST_TO_ADDR
// sArmoury := false ;
106456: LD_ADDR_EXP 168
106460: PUSH
106461: LD_INT 0
106463: ST_TO_ADDR
// sRadar := false ;
106464: LD_ADDR_EXP 169
106468: PUSH
106469: LD_INT 0
106471: ST_TO_ADDR
// sBunker := false ;
106472: LD_ADDR_EXP 170
106476: PUSH
106477: LD_INT 0
106479: ST_TO_ADDR
// sHack := false ;
106480: LD_ADDR_EXP 171
106484: PUSH
106485: LD_INT 0
106487: ST_TO_ADDR
// sFire := false ;
106488: LD_ADDR_EXP 172
106492: PUSH
106493: LD_INT 0
106495: ST_TO_ADDR
// sRefresh := false ;
106496: LD_ADDR_EXP 173
106500: PUSH
106501: LD_INT 0
106503: ST_TO_ADDR
// sExp := false ;
106504: LD_ADDR_EXP 174
106508: PUSH
106509: LD_INT 0
106511: ST_TO_ADDR
// sDepot := false ;
106512: LD_ADDR_EXP 175
106516: PUSH
106517: LD_INT 0
106519: ST_TO_ADDR
// sFlag := false ;
106520: LD_ADDR_EXP 176
106524: PUSH
106525: LD_INT 0
106527: ST_TO_ADDR
// sKamikadze := false ;
106528: LD_ADDR_EXP 184
106532: PUSH
106533: LD_INT 0
106535: ST_TO_ADDR
// sTroll := false ;
106536: LD_ADDR_EXP 185
106540: PUSH
106541: LD_INT 0
106543: ST_TO_ADDR
// sSlow := false ;
106544: LD_ADDR_EXP 186
106548: PUSH
106549: LD_INT 0
106551: ST_TO_ADDR
// sLack := false ;
106552: LD_ADDR_EXP 187
106556: PUSH
106557: LD_INT 0
106559: ST_TO_ADDR
// sTank := false ;
106560: LD_ADDR_EXP 189
106564: PUSH
106565: LD_INT 0
106567: ST_TO_ADDR
// sRemote := false ;
106568: LD_ADDR_EXP 190
106572: PUSH
106573: LD_INT 0
106575: ST_TO_ADDR
// sPowell := false ;
106576: LD_ADDR_EXP 191
106580: PUSH
106581: LD_INT 0
106583: ST_TO_ADDR
// sTeleport := false ;
106584: LD_ADDR_EXP 194
106588: PUSH
106589: LD_INT 0
106591: ST_TO_ADDR
// sOilTower := false ;
106592: LD_ADDR_EXP 196
106596: PUSH
106597: LD_INT 0
106599: ST_TO_ADDR
// sShovel := false ;
106600: LD_ADDR_EXP 197
106604: PUSH
106605: LD_INT 0
106607: ST_TO_ADDR
// sSheik := false ;
106608: LD_ADDR_EXP 198
106612: PUSH
106613: LD_INT 0
106615: ST_TO_ADDR
// sEarthquake := false ;
106616: LD_ADDR_EXP 200
106620: PUSH
106621: LD_INT 0
106623: ST_TO_ADDR
// sAI := false ;
106624: LD_ADDR_EXP 201
106628: PUSH
106629: LD_INT 0
106631: ST_TO_ADDR
// sCargo := false ;
106632: LD_ADDR_EXP 204
106636: PUSH
106637: LD_INT 0
106639: ST_TO_ADDR
// sDLaser := false ;
106640: LD_ADDR_EXP 205
106644: PUSH
106645: LD_INT 0
106647: ST_TO_ADDR
// sExchange := false ;
106648: LD_ADDR_EXP 206
106652: PUSH
106653: LD_INT 0
106655: ST_TO_ADDR
// sFac := false ;
106656: LD_ADDR_EXP 207
106660: PUSH
106661: LD_INT 0
106663: ST_TO_ADDR
// sPower := false ;
106664: LD_ADDR_EXP 208
106668: PUSH
106669: LD_INT 0
106671: ST_TO_ADDR
// sRandom := false ;
106672: LD_ADDR_EXP 209
106676: PUSH
106677: LD_INT 0
106679: ST_TO_ADDR
// sShield := false ;
106680: LD_ADDR_EXP 210
106684: PUSH
106685: LD_INT 0
106687: ST_TO_ADDR
// sTime := false ;
106688: LD_ADDR_EXP 211
106692: PUSH
106693: LD_INT 0
106695: ST_TO_ADDR
// sTools := false ;
106696: LD_ADDR_EXP 212
106700: PUSH
106701: LD_INT 0
106703: ST_TO_ADDR
// sSold := false ;
106704: LD_ADDR_EXP 177
106708: PUSH
106709: LD_INT 0
106711: ST_TO_ADDR
// sDiff := false ;
106712: LD_ADDR_EXP 178
106716: PUSH
106717: LD_INT 0
106719: ST_TO_ADDR
// sFog := false ;
106720: LD_ADDR_EXP 181
106724: PUSH
106725: LD_INT 0
106727: ST_TO_ADDR
// sReset := false ;
106728: LD_ADDR_EXP 182
106732: PUSH
106733: LD_INT 0
106735: ST_TO_ADDR
// sSun := false ;
106736: LD_ADDR_EXP 183
106740: PUSH
106741: LD_INT 0
106743: ST_TO_ADDR
// sTiger := false ;
106744: LD_ADDR_EXP 179
106748: PUSH
106749: LD_INT 0
106751: ST_TO_ADDR
// sBomb := false ;
106752: LD_ADDR_EXP 180
106756: PUSH
106757: LD_INT 0
106759: ST_TO_ADDR
// sWound := false ;
106760: LD_ADDR_EXP 188
106764: PUSH
106765: LD_INT 0
106767: ST_TO_ADDR
// sBetray := false ;
106768: LD_ADDR_EXP 192
106772: PUSH
106773: LD_INT 0
106775: ST_TO_ADDR
// sContamin := false ;
106776: LD_ADDR_EXP 193
106780: PUSH
106781: LD_INT 0
106783: ST_TO_ADDR
// sOil := false ;
106784: LD_ADDR_EXP 195
106788: PUSH
106789: LD_INT 0
106791: ST_TO_ADDR
// sStu := false ;
106792: LD_ADDR_EXP 199
106796: PUSH
106797: LD_INT 0
106799: ST_TO_ADDR
// sBazooka := false ;
106800: LD_ADDR_EXP 202
106804: PUSH
106805: LD_INT 0
106807: ST_TO_ADDR
// sMortar := false ;
106808: LD_ADDR_EXP 203
106812: PUSH
106813: LD_INT 0
106815: ST_TO_ADDR
// sRanger := false ;
106816: LD_ADDR_EXP 213
106820: PUSH
106821: LD_INT 0
106823: ST_TO_ADDR
// end ;
106824: LD_VAR 0 1
106828: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
106829: LD_INT 0
106831: PPUSH
106832: PPUSH
106833: PPUSH
106834: PPUSH
106835: PPUSH
// result := [ ] ;
106836: LD_ADDR_VAR 0 1
106840: PUSH
106841: EMPTY
106842: ST_TO_ADDR
// if campaign_id = 1 then
106843: LD_OWVAR 69
106847: PUSH
106848: LD_INT 1
106850: EQUAL
106851: IFFALSE 109789
// begin case mission_number of 1 :
106853: LD_OWVAR 70
106857: PUSH
106858: LD_INT 1
106860: DOUBLE
106861: EQUAL
106862: IFTRUE 106866
106864: GO 106930
106866: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
106867: LD_ADDR_VAR 0 1
106871: PUSH
106872: LD_INT 2
106874: PUSH
106875: LD_INT 4
106877: PUSH
106878: LD_INT 11
106880: PUSH
106881: LD_INT 12
106883: PUSH
106884: LD_INT 15
106886: PUSH
106887: LD_INT 16
106889: PUSH
106890: LD_INT 22
106892: PUSH
106893: LD_INT 23
106895: PUSH
106896: LD_INT 26
106898: PUSH
106899: EMPTY
106900: LIST
106901: LIST
106902: LIST
106903: LIST
106904: LIST
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: PUSH
106910: LD_INT 101
106912: PUSH
106913: LD_INT 102
106915: PUSH
106916: LD_INT 106
106918: PUSH
106919: EMPTY
106920: LIST
106921: LIST
106922: LIST
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: ST_TO_ADDR
106928: GO 109787
106930: LD_INT 2
106932: DOUBLE
106933: EQUAL
106934: IFTRUE 106938
106936: GO 107010
106938: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
106939: LD_ADDR_VAR 0 1
106943: PUSH
106944: LD_INT 2
106946: PUSH
106947: LD_INT 4
106949: PUSH
106950: LD_INT 11
106952: PUSH
106953: LD_INT 12
106955: PUSH
106956: LD_INT 15
106958: PUSH
106959: LD_INT 16
106961: PUSH
106962: LD_INT 22
106964: PUSH
106965: LD_INT 23
106967: PUSH
106968: LD_INT 26
106970: PUSH
106971: EMPTY
106972: LIST
106973: LIST
106974: LIST
106975: LIST
106976: LIST
106977: LIST
106978: LIST
106979: LIST
106980: LIST
106981: PUSH
106982: LD_INT 101
106984: PUSH
106985: LD_INT 102
106987: PUSH
106988: LD_INT 105
106990: PUSH
106991: LD_INT 106
106993: PUSH
106994: LD_INT 108
106996: PUSH
106997: EMPTY
106998: LIST
106999: LIST
107000: LIST
107001: LIST
107002: LIST
107003: PUSH
107004: EMPTY
107005: LIST
107006: LIST
107007: ST_TO_ADDR
107008: GO 109787
107010: LD_INT 3
107012: DOUBLE
107013: EQUAL
107014: IFTRUE 107018
107016: GO 107094
107018: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
107019: LD_ADDR_VAR 0 1
107023: PUSH
107024: LD_INT 2
107026: PUSH
107027: LD_INT 4
107029: PUSH
107030: LD_INT 5
107032: PUSH
107033: LD_INT 11
107035: PUSH
107036: LD_INT 12
107038: PUSH
107039: LD_INT 15
107041: PUSH
107042: LD_INT 16
107044: PUSH
107045: LD_INT 22
107047: PUSH
107048: LD_INT 26
107050: PUSH
107051: LD_INT 36
107053: PUSH
107054: EMPTY
107055: LIST
107056: LIST
107057: LIST
107058: LIST
107059: LIST
107060: LIST
107061: LIST
107062: LIST
107063: LIST
107064: LIST
107065: PUSH
107066: LD_INT 101
107068: PUSH
107069: LD_INT 102
107071: PUSH
107072: LD_INT 105
107074: PUSH
107075: LD_INT 106
107077: PUSH
107078: LD_INT 108
107080: PUSH
107081: EMPTY
107082: LIST
107083: LIST
107084: LIST
107085: LIST
107086: LIST
107087: PUSH
107088: EMPTY
107089: LIST
107090: LIST
107091: ST_TO_ADDR
107092: GO 109787
107094: LD_INT 4
107096: DOUBLE
107097: EQUAL
107098: IFTRUE 107102
107100: GO 107186
107102: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
107103: LD_ADDR_VAR 0 1
107107: PUSH
107108: LD_INT 2
107110: PUSH
107111: LD_INT 4
107113: PUSH
107114: LD_INT 5
107116: PUSH
107117: LD_INT 8
107119: PUSH
107120: LD_INT 11
107122: PUSH
107123: LD_INT 12
107125: PUSH
107126: LD_INT 15
107128: PUSH
107129: LD_INT 16
107131: PUSH
107132: LD_INT 22
107134: PUSH
107135: LD_INT 23
107137: PUSH
107138: LD_INT 26
107140: PUSH
107141: LD_INT 36
107143: PUSH
107144: EMPTY
107145: LIST
107146: LIST
107147: LIST
107148: LIST
107149: LIST
107150: LIST
107151: LIST
107152: LIST
107153: LIST
107154: LIST
107155: LIST
107156: LIST
107157: PUSH
107158: LD_INT 101
107160: PUSH
107161: LD_INT 102
107163: PUSH
107164: LD_INT 105
107166: PUSH
107167: LD_INT 106
107169: PUSH
107170: LD_INT 108
107172: PUSH
107173: EMPTY
107174: LIST
107175: LIST
107176: LIST
107177: LIST
107178: LIST
107179: PUSH
107180: EMPTY
107181: LIST
107182: LIST
107183: ST_TO_ADDR
107184: GO 109787
107186: LD_INT 5
107188: DOUBLE
107189: EQUAL
107190: IFTRUE 107194
107192: GO 107294
107194: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
107195: LD_ADDR_VAR 0 1
107199: PUSH
107200: LD_INT 2
107202: PUSH
107203: LD_INT 4
107205: PUSH
107206: LD_INT 5
107208: PUSH
107209: LD_INT 6
107211: PUSH
107212: LD_INT 8
107214: PUSH
107215: LD_INT 11
107217: PUSH
107218: LD_INT 12
107220: PUSH
107221: LD_INT 15
107223: PUSH
107224: LD_INT 16
107226: PUSH
107227: LD_INT 22
107229: PUSH
107230: LD_INT 23
107232: PUSH
107233: LD_INT 25
107235: PUSH
107236: LD_INT 26
107238: PUSH
107239: LD_INT 36
107241: PUSH
107242: EMPTY
107243: LIST
107244: LIST
107245: LIST
107246: LIST
107247: LIST
107248: LIST
107249: LIST
107250: LIST
107251: LIST
107252: LIST
107253: LIST
107254: LIST
107255: LIST
107256: LIST
107257: PUSH
107258: LD_INT 101
107260: PUSH
107261: LD_INT 102
107263: PUSH
107264: LD_INT 105
107266: PUSH
107267: LD_INT 106
107269: PUSH
107270: LD_INT 108
107272: PUSH
107273: LD_INT 109
107275: PUSH
107276: LD_INT 112
107278: PUSH
107279: EMPTY
107280: LIST
107281: LIST
107282: LIST
107283: LIST
107284: LIST
107285: LIST
107286: LIST
107287: PUSH
107288: EMPTY
107289: LIST
107290: LIST
107291: ST_TO_ADDR
107292: GO 109787
107294: LD_INT 6
107296: DOUBLE
107297: EQUAL
107298: IFTRUE 107302
107300: GO 107422
107302: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
107303: LD_ADDR_VAR 0 1
107307: PUSH
107308: LD_INT 2
107310: PUSH
107311: LD_INT 4
107313: PUSH
107314: LD_INT 5
107316: PUSH
107317: LD_INT 6
107319: PUSH
107320: LD_INT 8
107322: PUSH
107323: LD_INT 11
107325: PUSH
107326: LD_INT 12
107328: PUSH
107329: LD_INT 15
107331: PUSH
107332: LD_INT 16
107334: PUSH
107335: LD_INT 20
107337: PUSH
107338: LD_INT 21
107340: PUSH
107341: LD_INT 22
107343: PUSH
107344: LD_INT 23
107346: PUSH
107347: LD_INT 25
107349: PUSH
107350: LD_INT 26
107352: PUSH
107353: LD_INT 30
107355: PUSH
107356: LD_INT 31
107358: PUSH
107359: LD_INT 32
107361: PUSH
107362: LD_INT 36
107364: PUSH
107365: EMPTY
107366: LIST
107367: LIST
107368: LIST
107369: LIST
107370: LIST
107371: LIST
107372: LIST
107373: LIST
107374: LIST
107375: LIST
107376: LIST
107377: LIST
107378: LIST
107379: LIST
107380: LIST
107381: LIST
107382: LIST
107383: LIST
107384: LIST
107385: PUSH
107386: LD_INT 101
107388: PUSH
107389: LD_INT 102
107391: PUSH
107392: LD_INT 105
107394: PUSH
107395: LD_INT 106
107397: PUSH
107398: LD_INT 108
107400: PUSH
107401: LD_INT 109
107403: PUSH
107404: LD_INT 112
107406: PUSH
107407: EMPTY
107408: LIST
107409: LIST
107410: LIST
107411: LIST
107412: LIST
107413: LIST
107414: LIST
107415: PUSH
107416: EMPTY
107417: LIST
107418: LIST
107419: ST_TO_ADDR
107420: GO 109787
107422: LD_INT 7
107424: DOUBLE
107425: EQUAL
107426: IFTRUE 107430
107428: GO 107530
107430: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
107431: LD_ADDR_VAR 0 1
107435: PUSH
107436: LD_INT 2
107438: PUSH
107439: LD_INT 4
107441: PUSH
107442: LD_INT 5
107444: PUSH
107445: LD_INT 7
107447: PUSH
107448: LD_INT 11
107450: PUSH
107451: LD_INT 12
107453: PUSH
107454: LD_INT 15
107456: PUSH
107457: LD_INT 16
107459: PUSH
107460: LD_INT 20
107462: PUSH
107463: LD_INT 21
107465: PUSH
107466: LD_INT 22
107468: PUSH
107469: LD_INT 23
107471: PUSH
107472: LD_INT 25
107474: PUSH
107475: LD_INT 26
107477: PUSH
107478: EMPTY
107479: LIST
107480: LIST
107481: LIST
107482: LIST
107483: LIST
107484: LIST
107485: LIST
107486: LIST
107487: LIST
107488: LIST
107489: LIST
107490: LIST
107491: LIST
107492: LIST
107493: PUSH
107494: LD_INT 101
107496: PUSH
107497: LD_INT 102
107499: PUSH
107500: LD_INT 103
107502: PUSH
107503: LD_INT 105
107505: PUSH
107506: LD_INT 106
107508: PUSH
107509: LD_INT 108
107511: PUSH
107512: LD_INT 112
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: LIST
107519: LIST
107520: LIST
107521: LIST
107522: LIST
107523: PUSH
107524: EMPTY
107525: LIST
107526: LIST
107527: ST_TO_ADDR
107528: GO 109787
107530: LD_INT 8
107532: DOUBLE
107533: EQUAL
107534: IFTRUE 107538
107536: GO 107666
107538: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
107539: LD_ADDR_VAR 0 1
107543: PUSH
107544: LD_INT 2
107546: PUSH
107547: LD_INT 4
107549: PUSH
107550: LD_INT 5
107552: PUSH
107553: LD_INT 6
107555: PUSH
107556: LD_INT 7
107558: PUSH
107559: LD_INT 8
107561: PUSH
107562: LD_INT 11
107564: PUSH
107565: LD_INT 12
107567: PUSH
107568: LD_INT 15
107570: PUSH
107571: LD_INT 16
107573: PUSH
107574: LD_INT 20
107576: PUSH
107577: LD_INT 21
107579: PUSH
107580: LD_INT 22
107582: PUSH
107583: LD_INT 23
107585: PUSH
107586: LD_INT 25
107588: PUSH
107589: LD_INT 26
107591: PUSH
107592: LD_INT 30
107594: PUSH
107595: LD_INT 31
107597: PUSH
107598: LD_INT 32
107600: PUSH
107601: LD_INT 36
107603: PUSH
107604: EMPTY
107605: LIST
107606: LIST
107607: LIST
107608: LIST
107609: LIST
107610: LIST
107611: LIST
107612: LIST
107613: LIST
107614: LIST
107615: LIST
107616: LIST
107617: LIST
107618: LIST
107619: LIST
107620: LIST
107621: LIST
107622: LIST
107623: LIST
107624: LIST
107625: PUSH
107626: LD_INT 101
107628: PUSH
107629: LD_INT 102
107631: PUSH
107632: LD_INT 103
107634: PUSH
107635: LD_INT 105
107637: PUSH
107638: LD_INT 106
107640: PUSH
107641: LD_INT 108
107643: PUSH
107644: LD_INT 109
107646: PUSH
107647: LD_INT 112
107649: PUSH
107650: EMPTY
107651: LIST
107652: LIST
107653: LIST
107654: LIST
107655: LIST
107656: LIST
107657: LIST
107658: LIST
107659: PUSH
107660: EMPTY
107661: LIST
107662: LIST
107663: ST_TO_ADDR
107664: GO 109787
107666: LD_INT 9
107668: DOUBLE
107669: EQUAL
107670: IFTRUE 107674
107672: GO 107810
107674: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
107675: LD_ADDR_VAR 0 1
107679: PUSH
107680: LD_INT 2
107682: PUSH
107683: LD_INT 4
107685: PUSH
107686: LD_INT 5
107688: PUSH
107689: LD_INT 6
107691: PUSH
107692: LD_INT 7
107694: PUSH
107695: LD_INT 8
107697: PUSH
107698: LD_INT 11
107700: PUSH
107701: LD_INT 12
107703: PUSH
107704: LD_INT 15
107706: PUSH
107707: LD_INT 16
107709: PUSH
107710: LD_INT 20
107712: PUSH
107713: LD_INT 21
107715: PUSH
107716: LD_INT 22
107718: PUSH
107719: LD_INT 23
107721: PUSH
107722: LD_INT 25
107724: PUSH
107725: LD_INT 26
107727: PUSH
107728: LD_INT 28
107730: PUSH
107731: LD_INT 30
107733: PUSH
107734: LD_INT 31
107736: PUSH
107737: LD_INT 32
107739: PUSH
107740: LD_INT 36
107742: PUSH
107743: EMPTY
107744: LIST
107745: LIST
107746: LIST
107747: LIST
107748: LIST
107749: LIST
107750: LIST
107751: LIST
107752: LIST
107753: LIST
107754: LIST
107755: LIST
107756: LIST
107757: LIST
107758: LIST
107759: LIST
107760: LIST
107761: LIST
107762: LIST
107763: LIST
107764: LIST
107765: PUSH
107766: LD_INT 101
107768: PUSH
107769: LD_INT 102
107771: PUSH
107772: LD_INT 103
107774: PUSH
107775: LD_INT 105
107777: PUSH
107778: LD_INT 106
107780: PUSH
107781: LD_INT 108
107783: PUSH
107784: LD_INT 109
107786: PUSH
107787: LD_INT 112
107789: PUSH
107790: LD_INT 114
107792: PUSH
107793: EMPTY
107794: LIST
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: LIST
107801: LIST
107802: LIST
107803: PUSH
107804: EMPTY
107805: LIST
107806: LIST
107807: ST_TO_ADDR
107808: GO 109787
107810: LD_INT 10
107812: DOUBLE
107813: EQUAL
107814: IFTRUE 107818
107816: GO 108002
107818: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
107819: LD_ADDR_VAR 0 1
107823: PUSH
107824: LD_INT 2
107826: PUSH
107827: LD_INT 4
107829: PUSH
107830: LD_INT 5
107832: PUSH
107833: LD_INT 6
107835: PUSH
107836: LD_INT 7
107838: PUSH
107839: LD_INT 8
107841: PUSH
107842: LD_INT 9
107844: PUSH
107845: LD_INT 10
107847: PUSH
107848: LD_INT 11
107850: PUSH
107851: LD_INT 12
107853: PUSH
107854: LD_INT 13
107856: PUSH
107857: LD_INT 14
107859: PUSH
107860: LD_INT 15
107862: PUSH
107863: LD_INT 16
107865: PUSH
107866: LD_INT 17
107868: PUSH
107869: LD_INT 18
107871: PUSH
107872: LD_INT 19
107874: PUSH
107875: LD_INT 20
107877: PUSH
107878: LD_INT 21
107880: PUSH
107881: LD_INT 22
107883: PUSH
107884: LD_INT 23
107886: PUSH
107887: LD_INT 24
107889: PUSH
107890: LD_INT 25
107892: PUSH
107893: LD_INT 26
107895: PUSH
107896: LD_INT 28
107898: PUSH
107899: LD_INT 30
107901: PUSH
107902: LD_INT 31
107904: PUSH
107905: LD_INT 32
107907: PUSH
107908: LD_INT 36
107910: PUSH
107911: EMPTY
107912: LIST
107913: LIST
107914: LIST
107915: LIST
107916: LIST
107917: LIST
107918: LIST
107919: LIST
107920: LIST
107921: LIST
107922: LIST
107923: LIST
107924: LIST
107925: LIST
107926: LIST
107927: LIST
107928: LIST
107929: LIST
107930: LIST
107931: LIST
107932: LIST
107933: LIST
107934: LIST
107935: LIST
107936: LIST
107937: LIST
107938: LIST
107939: LIST
107940: LIST
107941: PUSH
107942: LD_INT 101
107944: PUSH
107945: LD_INT 102
107947: PUSH
107948: LD_INT 103
107950: PUSH
107951: LD_INT 104
107953: PUSH
107954: LD_INT 105
107956: PUSH
107957: LD_INT 106
107959: PUSH
107960: LD_INT 107
107962: PUSH
107963: LD_INT 108
107965: PUSH
107966: LD_INT 109
107968: PUSH
107969: LD_INT 110
107971: PUSH
107972: LD_INT 111
107974: PUSH
107975: LD_INT 112
107977: PUSH
107978: LD_INT 114
107980: PUSH
107981: EMPTY
107982: LIST
107983: LIST
107984: LIST
107985: LIST
107986: LIST
107987: LIST
107988: LIST
107989: LIST
107990: LIST
107991: LIST
107992: LIST
107993: LIST
107994: LIST
107995: PUSH
107996: EMPTY
107997: LIST
107998: LIST
107999: ST_TO_ADDR
108000: GO 109787
108002: LD_INT 11
108004: DOUBLE
108005: EQUAL
108006: IFTRUE 108010
108008: GO 108202
108010: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
108011: LD_ADDR_VAR 0 1
108015: PUSH
108016: LD_INT 2
108018: PUSH
108019: LD_INT 3
108021: PUSH
108022: LD_INT 4
108024: PUSH
108025: LD_INT 5
108027: PUSH
108028: LD_INT 6
108030: PUSH
108031: LD_INT 7
108033: PUSH
108034: LD_INT 8
108036: PUSH
108037: LD_INT 9
108039: PUSH
108040: LD_INT 10
108042: PUSH
108043: LD_INT 11
108045: PUSH
108046: LD_INT 12
108048: PUSH
108049: LD_INT 13
108051: PUSH
108052: LD_INT 14
108054: PUSH
108055: LD_INT 15
108057: PUSH
108058: LD_INT 16
108060: PUSH
108061: LD_INT 17
108063: PUSH
108064: LD_INT 18
108066: PUSH
108067: LD_INT 19
108069: PUSH
108070: LD_INT 20
108072: PUSH
108073: LD_INT 21
108075: PUSH
108076: LD_INT 22
108078: PUSH
108079: LD_INT 23
108081: PUSH
108082: LD_INT 24
108084: PUSH
108085: LD_INT 25
108087: PUSH
108088: LD_INT 26
108090: PUSH
108091: LD_INT 28
108093: PUSH
108094: LD_INT 30
108096: PUSH
108097: LD_INT 31
108099: PUSH
108100: LD_INT 32
108102: PUSH
108103: LD_INT 34
108105: PUSH
108106: LD_INT 36
108108: PUSH
108109: EMPTY
108110: LIST
108111: LIST
108112: LIST
108113: LIST
108114: LIST
108115: LIST
108116: LIST
108117: LIST
108118: LIST
108119: LIST
108120: LIST
108121: LIST
108122: LIST
108123: LIST
108124: LIST
108125: LIST
108126: LIST
108127: LIST
108128: LIST
108129: LIST
108130: LIST
108131: LIST
108132: LIST
108133: LIST
108134: LIST
108135: LIST
108136: LIST
108137: LIST
108138: LIST
108139: LIST
108140: LIST
108141: PUSH
108142: LD_INT 101
108144: PUSH
108145: LD_INT 102
108147: PUSH
108148: LD_INT 103
108150: PUSH
108151: LD_INT 104
108153: PUSH
108154: LD_INT 105
108156: PUSH
108157: LD_INT 106
108159: PUSH
108160: LD_INT 107
108162: PUSH
108163: LD_INT 108
108165: PUSH
108166: LD_INT 109
108168: PUSH
108169: LD_INT 110
108171: PUSH
108172: LD_INT 111
108174: PUSH
108175: LD_INT 112
108177: PUSH
108178: LD_INT 114
108180: PUSH
108181: EMPTY
108182: LIST
108183: LIST
108184: LIST
108185: LIST
108186: LIST
108187: LIST
108188: LIST
108189: LIST
108190: LIST
108191: LIST
108192: LIST
108193: LIST
108194: LIST
108195: PUSH
108196: EMPTY
108197: LIST
108198: LIST
108199: ST_TO_ADDR
108200: GO 109787
108202: LD_INT 12
108204: DOUBLE
108205: EQUAL
108206: IFTRUE 108210
108208: GO 108418
108210: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
108211: LD_ADDR_VAR 0 1
108215: PUSH
108216: LD_INT 1
108218: PUSH
108219: LD_INT 2
108221: PUSH
108222: LD_INT 3
108224: PUSH
108225: LD_INT 4
108227: PUSH
108228: LD_INT 5
108230: PUSH
108231: LD_INT 6
108233: PUSH
108234: LD_INT 7
108236: PUSH
108237: LD_INT 8
108239: PUSH
108240: LD_INT 9
108242: PUSH
108243: LD_INT 10
108245: PUSH
108246: LD_INT 11
108248: PUSH
108249: LD_INT 12
108251: PUSH
108252: LD_INT 13
108254: PUSH
108255: LD_INT 14
108257: PUSH
108258: LD_INT 15
108260: PUSH
108261: LD_INT 16
108263: PUSH
108264: LD_INT 17
108266: PUSH
108267: LD_INT 18
108269: PUSH
108270: LD_INT 19
108272: PUSH
108273: LD_INT 20
108275: PUSH
108276: LD_INT 21
108278: PUSH
108279: LD_INT 22
108281: PUSH
108282: LD_INT 23
108284: PUSH
108285: LD_INT 24
108287: PUSH
108288: LD_INT 25
108290: PUSH
108291: LD_INT 26
108293: PUSH
108294: LD_INT 27
108296: PUSH
108297: LD_INT 28
108299: PUSH
108300: LD_INT 30
108302: PUSH
108303: LD_INT 31
108305: PUSH
108306: LD_INT 32
108308: PUSH
108309: LD_INT 33
108311: PUSH
108312: LD_INT 34
108314: PUSH
108315: LD_INT 36
108317: PUSH
108318: EMPTY
108319: LIST
108320: LIST
108321: LIST
108322: LIST
108323: LIST
108324: LIST
108325: LIST
108326: LIST
108327: LIST
108328: LIST
108329: LIST
108330: LIST
108331: LIST
108332: LIST
108333: LIST
108334: LIST
108335: LIST
108336: LIST
108337: LIST
108338: LIST
108339: LIST
108340: LIST
108341: LIST
108342: LIST
108343: LIST
108344: LIST
108345: LIST
108346: LIST
108347: LIST
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: LIST
108353: PUSH
108354: LD_INT 101
108356: PUSH
108357: LD_INT 102
108359: PUSH
108360: LD_INT 103
108362: PUSH
108363: LD_INT 104
108365: PUSH
108366: LD_INT 105
108368: PUSH
108369: LD_INT 106
108371: PUSH
108372: LD_INT 107
108374: PUSH
108375: LD_INT 108
108377: PUSH
108378: LD_INT 109
108380: PUSH
108381: LD_INT 110
108383: PUSH
108384: LD_INT 111
108386: PUSH
108387: LD_INT 112
108389: PUSH
108390: LD_INT 113
108392: PUSH
108393: LD_INT 114
108395: PUSH
108396: EMPTY
108397: LIST
108398: LIST
108399: LIST
108400: LIST
108401: LIST
108402: LIST
108403: LIST
108404: LIST
108405: LIST
108406: LIST
108407: LIST
108408: LIST
108409: LIST
108410: LIST
108411: PUSH
108412: EMPTY
108413: LIST
108414: LIST
108415: ST_TO_ADDR
108416: GO 109787
108418: LD_INT 13
108420: DOUBLE
108421: EQUAL
108422: IFTRUE 108426
108424: GO 108622
108426: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
108427: LD_ADDR_VAR 0 1
108431: PUSH
108432: LD_INT 1
108434: PUSH
108435: LD_INT 2
108437: PUSH
108438: LD_INT 3
108440: PUSH
108441: LD_INT 4
108443: PUSH
108444: LD_INT 5
108446: PUSH
108447: LD_INT 8
108449: PUSH
108450: LD_INT 9
108452: PUSH
108453: LD_INT 10
108455: PUSH
108456: LD_INT 11
108458: PUSH
108459: LD_INT 12
108461: PUSH
108462: LD_INT 14
108464: PUSH
108465: LD_INT 15
108467: PUSH
108468: LD_INT 16
108470: PUSH
108471: LD_INT 17
108473: PUSH
108474: LD_INT 18
108476: PUSH
108477: LD_INT 19
108479: PUSH
108480: LD_INT 20
108482: PUSH
108483: LD_INT 21
108485: PUSH
108486: LD_INT 22
108488: PUSH
108489: LD_INT 23
108491: PUSH
108492: LD_INT 24
108494: PUSH
108495: LD_INT 25
108497: PUSH
108498: LD_INT 26
108500: PUSH
108501: LD_INT 27
108503: PUSH
108504: LD_INT 28
108506: PUSH
108507: LD_INT 30
108509: PUSH
108510: LD_INT 31
108512: PUSH
108513: LD_INT 32
108515: PUSH
108516: LD_INT 33
108518: PUSH
108519: LD_INT 34
108521: PUSH
108522: LD_INT 36
108524: PUSH
108525: EMPTY
108526: LIST
108527: LIST
108528: LIST
108529: LIST
108530: LIST
108531: LIST
108532: LIST
108533: LIST
108534: LIST
108535: LIST
108536: LIST
108537: LIST
108538: LIST
108539: LIST
108540: LIST
108541: LIST
108542: LIST
108543: LIST
108544: LIST
108545: LIST
108546: LIST
108547: LIST
108548: LIST
108549: LIST
108550: LIST
108551: LIST
108552: LIST
108553: LIST
108554: LIST
108555: LIST
108556: LIST
108557: PUSH
108558: LD_INT 101
108560: PUSH
108561: LD_INT 102
108563: PUSH
108564: LD_INT 103
108566: PUSH
108567: LD_INT 104
108569: PUSH
108570: LD_INT 105
108572: PUSH
108573: LD_INT 106
108575: PUSH
108576: LD_INT 107
108578: PUSH
108579: LD_INT 108
108581: PUSH
108582: LD_INT 109
108584: PUSH
108585: LD_INT 110
108587: PUSH
108588: LD_INT 111
108590: PUSH
108591: LD_INT 112
108593: PUSH
108594: LD_INT 113
108596: PUSH
108597: LD_INT 114
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: LIST
108604: LIST
108605: LIST
108606: LIST
108607: LIST
108608: LIST
108609: LIST
108610: LIST
108611: LIST
108612: LIST
108613: LIST
108614: LIST
108615: PUSH
108616: EMPTY
108617: LIST
108618: LIST
108619: ST_TO_ADDR
108620: GO 109787
108622: LD_INT 14
108624: DOUBLE
108625: EQUAL
108626: IFTRUE 108630
108628: GO 108842
108630: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
108631: LD_ADDR_VAR 0 1
108635: PUSH
108636: LD_INT 1
108638: PUSH
108639: LD_INT 2
108641: PUSH
108642: LD_INT 3
108644: PUSH
108645: LD_INT 4
108647: PUSH
108648: LD_INT 5
108650: PUSH
108651: LD_INT 6
108653: PUSH
108654: LD_INT 7
108656: PUSH
108657: LD_INT 8
108659: PUSH
108660: LD_INT 9
108662: PUSH
108663: LD_INT 10
108665: PUSH
108666: LD_INT 11
108668: PUSH
108669: LD_INT 12
108671: PUSH
108672: LD_INT 13
108674: PUSH
108675: LD_INT 14
108677: PUSH
108678: LD_INT 15
108680: PUSH
108681: LD_INT 16
108683: PUSH
108684: LD_INT 17
108686: PUSH
108687: LD_INT 18
108689: PUSH
108690: LD_INT 19
108692: PUSH
108693: LD_INT 20
108695: PUSH
108696: LD_INT 21
108698: PUSH
108699: LD_INT 22
108701: PUSH
108702: LD_INT 23
108704: PUSH
108705: LD_INT 24
108707: PUSH
108708: LD_INT 25
108710: PUSH
108711: LD_INT 26
108713: PUSH
108714: LD_INT 27
108716: PUSH
108717: LD_INT 28
108719: PUSH
108720: LD_INT 29
108722: PUSH
108723: LD_INT 30
108725: PUSH
108726: LD_INT 31
108728: PUSH
108729: LD_INT 32
108731: PUSH
108732: LD_INT 33
108734: PUSH
108735: LD_INT 34
108737: PUSH
108738: LD_INT 36
108740: PUSH
108741: EMPTY
108742: LIST
108743: LIST
108744: LIST
108745: LIST
108746: LIST
108747: LIST
108748: LIST
108749: LIST
108750: LIST
108751: LIST
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: LIST
108757: LIST
108758: LIST
108759: LIST
108760: LIST
108761: LIST
108762: LIST
108763: LIST
108764: LIST
108765: LIST
108766: LIST
108767: LIST
108768: LIST
108769: LIST
108770: LIST
108771: LIST
108772: LIST
108773: LIST
108774: LIST
108775: LIST
108776: LIST
108777: PUSH
108778: LD_INT 101
108780: PUSH
108781: LD_INT 102
108783: PUSH
108784: LD_INT 103
108786: PUSH
108787: LD_INT 104
108789: PUSH
108790: LD_INT 105
108792: PUSH
108793: LD_INT 106
108795: PUSH
108796: LD_INT 107
108798: PUSH
108799: LD_INT 108
108801: PUSH
108802: LD_INT 109
108804: PUSH
108805: LD_INT 110
108807: PUSH
108808: LD_INT 111
108810: PUSH
108811: LD_INT 112
108813: PUSH
108814: LD_INT 113
108816: PUSH
108817: LD_INT 114
108819: PUSH
108820: EMPTY
108821: LIST
108822: LIST
108823: LIST
108824: LIST
108825: LIST
108826: LIST
108827: LIST
108828: LIST
108829: LIST
108830: LIST
108831: LIST
108832: LIST
108833: LIST
108834: LIST
108835: PUSH
108836: EMPTY
108837: LIST
108838: LIST
108839: ST_TO_ADDR
108840: GO 109787
108842: LD_INT 15
108844: DOUBLE
108845: EQUAL
108846: IFTRUE 108850
108848: GO 109062
108850: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
108851: LD_ADDR_VAR 0 1
108855: PUSH
108856: LD_INT 1
108858: PUSH
108859: LD_INT 2
108861: PUSH
108862: LD_INT 3
108864: PUSH
108865: LD_INT 4
108867: PUSH
108868: LD_INT 5
108870: PUSH
108871: LD_INT 6
108873: PUSH
108874: LD_INT 7
108876: PUSH
108877: LD_INT 8
108879: PUSH
108880: LD_INT 9
108882: PUSH
108883: LD_INT 10
108885: PUSH
108886: LD_INT 11
108888: PUSH
108889: LD_INT 12
108891: PUSH
108892: LD_INT 13
108894: PUSH
108895: LD_INT 14
108897: PUSH
108898: LD_INT 15
108900: PUSH
108901: LD_INT 16
108903: PUSH
108904: LD_INT 17
108906: PUSH
108907: LD_INT 18
108909: PUSH
108910: LD_INT 19
108912: PUSH
108913: LD_INT 20
108915: PUSH
108916: LD_INT 21
108918: PUSH
108919: LD_INT 22
108921: PUSH
108922: LD_INT 23
108924: PUSH
108925: LD_INT 24
108927: PUSH
108928: LD_INT 25
108930: PUSH
108931: LD_INT 26
108933: PUSH
108934: LD_INT 27
108936: PUSH
108937: LD_INT 28
108939: PUSH
108940: LD_INT 29
108942: PUSH
108943: LD_INT 30
108945: PUSH
108946: LD_INT 31
108948: PUSH
108949: LD_INT 32
108951: PUSH
108952: LD_INT 33
108954: PUSH
108955: LD_INT 34
108957: PUSH
108958: LD_INT 36
108960: PUSH
108961: EMPTY
108962: LIST
108963: LIST
108964: LIST
108965: LIST
108966: LIST
108967: LIST
108968: LIST
108969: LIST
108970: LIST
108971: LIST
108972: LIST
108973: LIST
108974: LIST
108975: LIST
108976: LIST
108977: LIST
108978: LIST
108979: LIST
108980: LIST
108981: LIST
108982: LIST
108983: LIST
108984: LIST
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: LIST
108990: LIST
108991: LIST
108992: LIST
108993: LIST
108994: LIST
108995: LIST
108996: LIST
108997: PUSH
108998: LD_INT 101
109000: PUSH
109001: LD_INT 102
109003: PUSH
109004: LD_INT 103
109006: PUSH
109007: LD_INT 104
109009: PUSH
109010: LD_INT 105
109012: PUSH
109013: LD_INT 106
109015: PUSH
109016: LD_INT 107
109018: PUSH
109019: LD_INT 108
109021: PUSH
109022: LD_INT 109
109024: PUSH
109025: LD_INT 110
109027: PUSH
109028: LD_INT 111
109030: PUSH
109031: LD_INT 112
109033: PUSH
109034: LD_INT 113
109036: PUSH
109037: LD_INT 114
109039: PUSH
109040: EMPTY
109041: LIST
109042: LIST
109043: LIST
109044: LIST
109045: LIST
109046: LIST
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: PUSH
109056: EMPTY
109057: LIST
109058: LIST
109059: ST_TO_ADDR
109060: GO 109787
109062: LD_INT 16
109064: DOUBLE
109065: EQUAL
109066: IFTRUE 109070
109068: GO 109194
109070: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
109071: LD_ADDR_VAR 0 1
109075: PUSH
109076: LD_INT 2
109078: PUSH
109079: LD_INT 4
109081: PUSH
109082: LD_INT 5
109084: PUSH
109085: LD_INT 7
109087: PUSH
109088: LD_INT 11
109090: PUSH
109091: LD_INT 12
109093: PUSH
109094: LD_INT 15
109096: PUSH
109097: LD_INT 16
109099: PUSH
109100: LD_INT 20
109102: PUSH
109103: LD_INT 21
109105: PUSH
109106: LD_INT 22
109108: PUSH
109109: LD_INT 23
109111: PUSH
109112: LD_INT 25
109114: PUSH
109115: LD_INT 26
109117: PUSH
109118: LD_INT 30
109120: PUSH
109121: LD_INT 31
109123: PUSH
109124: LD_INT 32
109126: PUSH
109127: LD_INT 33
109129: PUSH
109130: LD_INT 34
109132: PUSH
109133: EMPTY
109134: LIST
109135: LIST
109136: LIST
109137: LIST
109138: LIST
109139: LIST
109140: LIST
109141: LIST
109142: LIST
109143: LIST
109144: LIST
109145: LIST
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: PUSH
109154: LD_INT 101
109156: PUSH
109157: LD_INT 102
109159: PUSH
109160: LD_INT 103
109162: PUSH
109163: LD_INT 106
109165: PUSH
109166: LD_INT 108
109168: PUSH
109169: LD_INT 112
109171: PUSH
109172: LD_INT 113
109174: PUSH
109175: LD_INT 114
109177: PUSH
109178: EMPTY
109179: LIST
109180: LIST
109181: LIST
109182: LIST
109183: LIST
109184: LIST
109185: LIST
109186: LIST
109187: PUSH
109188: EMPTY
109189: LIST
109190: LIST
109191: ST_TO_ADDR
109192: GO 109787
109194: LD_INT 17
109196: DOUBLE
109197: EQUAL
109198: IFTRUE 109202
109200: GO 109414
109202: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
109203: LD_ADDR_VAR 0 1
109207: PUSH
109208: LD_INT 1
109210: PUSH
109211: LD_INT 2
109213: PUSH
109214: LD_INT 3
109216: PUSH
109217: LD_INT 4
109219: PUSH
109220: LD_INT 5
109222: PUSH
109223: LD_INT 6
109225: PUSH
109226: LD_INT 7
109228: PUSH
109229: LD_INT 8
109231: PUSH
109232: LD_INT 9
109234: PUSH
109235: LD_INT 10
109237: PUSH
109238: LD_INT 11
109240: PUSH
109241: LD_INT 12
109243: PUSH
109244: LD_INT 13
109246: PUSH
109247: LD_INT 14
109249: PUSH
109250: LD_INT 15
109252: PUSH
109253: LD_INT 16
109255: PUSH
109256: LD_INT 17
109258: PUSH
109259: LD_INT 18
109261: PUSH
109262: LD_INT 19
109264: PUSH
109265: LD_INT 20
109267: PUSH
109268: LD_INT 21
109270: PUSH
109271: LD_INT 22
109273: PUSH
109274: LD_INT 23
109276: PUSH
109277: LD_INT 24
109279: PUSH
109280: LD_INT 25
109282: PUSH
109283: LD_INT 26
109285: PUSH
109286: LD_INT 27
109288: PUSH
109289: LD_INT 28
109291: PUSH
109292: LD_INT 29
109294: PUSH
109295: LD_INT 30
109297: PUSH
109298: LD_INT 31
109300: PUSH
109301: LD_INT 32
109303: PUSH
109304: LD_INT 33
109306: PUSH
109307: LD_INT 34
109309: PUSH
109310: LD_INT 36
109312: PUSH
109313: EMPTY
109314: LIST
109315: LIST
109316: LIST
109317: LIST
109318: LIST
109319: LIST
109320: LIST
109321: LIST
109322: LIST
109323: LIST
109324: LIST
109325: LIST
109326: LIST
109327: LIST
109328: LIST
109329: LIST
109330: LIST
109331: LIST
109332: LIST
109333: LIST
109334: LIST
109335: LIST
109336: LIST
109337: LIST
109338: LIST
109339: LIST
109340: LIST
109341: LIST
109342: LIST
109343: LIST
109344: LIST
109345: LIST
109346: LIST
109347: LIST
109348: LIST
109349: PUSH
109350: LD_INT 101
109352: PUSH
109353: LD_INT 102
109355: PUSH
109356: LD_INT 103
109358: PUSH
109359: LD_INT 104
109361: PUSH
109362: LD_INT 105
109364: PUSH
109365: LD_INT 106
109367: PUSH
109368: LD_INT 107
109370: PUSH
109371: LD_INT 108
109373: PUSH
109374: LD_INT 109
109376: PUSH
109377: LD_INT 110
109379: PUSH
109380: LD_INT 111
109382: PUSH
109383: LD_INT 112
109385: PUSH
109386: LD_INT 113
109388: PUSH
109389: LD_INT 114
109391: PUSH
109392: EMPTY
109393: LIST
109394: LIST
109395: LIST
109396: LIST
109397: LIST
109398: LIST
109399: LIST
109400: LIST
109401: LIST
109402: LIST
109403: LIST
109404: LIST
109405: LIST
109406: LIST
109407: PUSH
109408: EMPTY
109409: LIST
109410: LIST
109411: ST_TO_ADDR
109412: GO 109787
109414: LD_INT 18
109416: DOUBLE
109417: EQUAL
109418: IFTRUE 109422
109420: GO 109558
109422: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
109423: LD_ADDR_VAR 0 1
109427: PUSH
109428: LD_INT 2
109430: PUSH
109431: LD_INT 4
109433: PUSH
109434: LD_INT 5
109436: PUSH
109437: LD_INT 7
109439: PUSH
109440: LD_INT 11
109442: PUSH
109443: LD_INT 12
109445: PUSH
109446: LD_INT 15
109448: PUSH
109449: LD_INT 16
109451: PUSH
109452: LD_INT 20
109454: PUSH
109455: LD_INT 21
109457: PUSH
109458: LD_INT 22
109460: PUSH
109461: LD_INT 23
109463: PUSH
109464: LD_INT 25
109466: PUSH
109467: LD_INT 26
109469: PUSH
109470: LD_INT 30
109472: PUSH
109473: LD_INT 31
109475: PUSH
109476: LD_INT 32
109478: PUSH
109479: LD_INT 33
109481: PUSH
109482: LD_INT 34
109484: PUSH
109485: LD_INT 35
109487: PUSH
109488: LD_INT 36
109490: PUSH
109491: EMPTY
109492: LIST
109493: LIST
109494: LIST
109495: LIST
109496: LIST
109497: LIST
109498: LIST
109499: LIST
109500: LIST
109501: LIST
109502: LIST
109503: LIST
109504: LIST
109505: LIST
109506: LIST
109507: LIST
109508: LIST
109509: LIST
109510: LIST
109511: LIST
109512: LIST
109513: PUSH
109514: LD_INT 101
109516: PUSH
109517: LD_INT 102
109519: PUSH
109520: LD_INT 103
109522: PUSH
109523: LD_INT 106
109525: PUSH
109526: LD_INT 108
109528: PUSH
109529: LD_INT 112
109531: PUSH
109532: LD_INT 113
109534: PUSH
109535: LD_INT 114
109537: PUSH
109538: LD_INT 115
109540: PUSH
109541: EMPTY
109542: LIST
109543: LIST
109544: LIST
109545: LIST
109546: LIST
109547: LIST
109548: LIST
109549: LIST
109550: LIST
109551: PUSH
109552: EMPTY
109553: LIST
109554: LIST
109555: ST_TO_ADDR
109556: GO 109787
109558: LD_INT 19
109560: DOUBLE
109561: EQUAL
109562: IFTRUE 109566
109564: GO 109786
109566: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
109567: LD_ADDR_VAR 0 1
109571: PUSH
109572: LD_INT 1
109574: PUSH
109575: LD_INT 2
109577: PUSH
109578: LD_INT 3
109580: PUSH
109581: LD_INT 4
109583: PUSH
109584: LD_INT 5
109586: PUSH
109587: LD_INT 6
109589: PUSH
109590: LD_INT 7
109592: PUSH
109593: LD_INT 8
109595: PUSH
109596: LD_INT 9
109598: PUSH
109599: LD_INT 10
109601: PUSH
109602: LD_INT 11
109604: PUSH
109605: LD_INT 12
109607: PUSH
109608: LD_INT 13
109610: PUSH
109611: LD_INT 14
109613: PUSH
109614: LD_INT 15
109616: PUSH
109617: LD_INT 16
109619: PUSH
109620: LD_INT 17
109622: PUSH
109623: LD_INT 18
109625: PUSH
109626: LD_INT 19
109628: PUSH
109629: LD_INT 20
109631: PUSH
109632: LD_INT 21
109634: PUSH
109635: LD_INT 22
109637: PUSH
109638: LD_INT 23
109640: PUSH
109641: LD_INT 24
109643: PUSH
109644: LD_INT 25
109646: PUSH
109647: LD_INT 26
109649: PUSH
109650: LD_INT 27
109652: PUSH
109653: LD_INT 28
109655: PUSH
109656: LD_INT 29
109658: PUSH
109659: LD_INT 30
109661: PUSH
109662: LD_INT 31
109664: PUSH
109665: LD_INT 32
109667: PUSH
109668: LD_INT 33
109670: PUSH
109671: LD_INT 34
109673: PUSH
109674: LD_INT 35
109676: PUSH
109677: LD_INT 36
109679: PUSH
109680: EMPTY
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: LIST
109687: LIST
109688: LIST
109689: LIST
109690: LIST
109691: LIST
109692: LIST
109693: LIST
109694: LIST
109695: LIST
109696: LIST
109697: LIST
109698: LIST
109699: LIST
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: LIST
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: LIST
109712: LIST
109713: LIST
109714: LIST
109715: LIST
109716: LIST
109717: PUSH
109718: LD_INT 101
109720: PUSH
109721: LD_INT 102
109723: PUSH
109724: LD_INT 103
109726: PUSH
109727: LD_INT 104
109729: PUSH
109730: LD_INT 105
109732: PUSH
109733: LD_INT 106
109735: PUSH
109736: LD_INT 107
109738: PUSH
109739: LD_INT 108
109741: PUSH
109742: LD_INT 109
109744: PUSH
109745: LD_INT 110
109747: PUSH
109748: LD_INT 111
109750: PUSH
109751: LD_INT 112
109753: PUSH
109754: LD_INT 113
109756: PUSH
109757: LD_INT 114
109759: PUSH
109760: LD_INT 115
109762: PUSH
109763: EMPTY
109764: LIST
109765: LIST
109766: LIST
109767: LIST
109768: LIST
109769: LIST
109770: LIST
109771: LIST
109772: LIST
109773: LIST
109774: LIST
109775: LIST
109776: LIST
109777: LIST
109778: LIST
109779: PUSH
109780: EMPTY
109781: LIST
109782: LIST
109783: ST_TO_ADDR
109784: GO 109787
109786: POP
// end else
109787: GO 110006
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
109789: LD_ADDR_VAR 0 1
109793: PUSH
109794: LD_INT 1
109796: PUSH
109797: LD_INT 2
109799: PUSH
109800: LD_INT 3
109802: PUSH
109803: LD_INT 4
109805: PUSH
109806: LD_INT 5
109808: PUSH
109809: LD_INT 6
109811: PUSH
109812: LD_INT 7
109814: PUSH
109815: LD_INT 8
109817: PUSH
109818: LD_INT 9
109820: PUSH
109821: LD_INT 10
109823: PUSH
109824: LD_INT 11
109826: PUSH
109827: LD_INT 12
109829: PUSH
109830: LD_INT 13
109832: PUSH
109833: LD_INT 14
109835: PUSH
109836: LD_INT 15
109838: PUSH
109839: LD_INT 16
109841: PUSH
109842: LD_INT 17
109844: PUSH
109845: LD_INT 18
109847: PUSH
109848: LD_INT 19
109850: PUSH
109851: LD_INT 20
109853: PUSH
109854: LD_INT 21
109856: PUSH
109857: LD_INT 22
109859: PUSH
109860: LD_INT 23
109862: PUSH
109863: LD_INT 24
109865: PUSH
109866: LD_INT 25
109868: PUSH
109869: LD_INT 26
109871: PUSH
109872: LD_INT 27
109874: PUSH
109875: LD_INT 28
109877: PUSH
109878: LD_INT 29
109880: PUSH
109881: LD_INT 30
109883: PUSH
109884: LD_INT 31
109886: PUSH
109887: LD_INT 32
109889: PUSH
109890: LD_INT 33
109892: PUSH
109893: LD_INT 34
109895: PUSH
109896: LD_INT 35
109898: PUSH
109899: LD_INT 36
109901: PUSH
109902: EMPTY
109903: LIST
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: LIST
109909: LIST
109910: LIST
109911: LIST
109912: LIST
109913: LIST
109914: LIST
109915: LIST
109916: LIST
109917: LIST
109918: LIST
109919: LIST
109920: LIST
109921: LIST
109922: LIST
109923: LIST
109924: LIST
109925: LIST
109926: LIST
109927: LIST
109928: LIST
109929: LIST
109930: LIST
109931: LIST
109932: LIST
109933: LIST
109934: LIST
109935: LIST
109936: LIST
109937: LIST
109938: LIST
109939: PUSH
109940: LD_INT 101
109942: PUSH
109943: LD_INT 102
109945: PUSH
109946: LD_INT 103
109948: PUSH
109949: LD_INT 104
109951: PUSH
109952: LD_INT 105
109954: PUSH
109955: LD_INT 106
109957: PUSH
109958: LD_INT 107
109960: PUSH
109961: LD_INT 108
109963: PUSH
109964: LD_INT 109
109966: PUSH
109967: LD_INT 110
109969: PUSH
109970: LD_INT 111
109972: PUSH
109973: LD_INT 112
109975: PUSH
109976: LD_INT 113
109978: PUSH
109979: LD_INT 114
109981: PUSH
109982: LD_INT 115
109984: PUSH
109985: EMPTY
109986: LIST
109987: LIST
109988: LIST
109989: LIST
109990: LIST
109991: LIST
109992: LIST
109993: LIST
109994: LIST
109995: LIST
109996: LIST
109997: LIST
109998: LIST
109999: LIST
110000: LIST
110001: PUSH
110002: EMPTY
110003: LIST
110004: LIST
110005: ST_TO_ADDR
// if result then
110006: LD_VAR 0 1
110010: IFFALSE 110299
// begin normal :=  ;
110012: LD_ADDR_VAR 0 3
110016: PUSH
110017: LD_STRING 
110019: ST_TO_ADDR
// hardcore :=  ;
110020: LD_ADDR_VAR 0 4
110024: PUSH
110025: LD_STRING 
110027: ST_TO_ADDR
// for i = 1 to normalCounter do
110028: LD_ADDR_VAR 0 5
110032: PUSH
110033: DOUBLE
110034: LD_INT 1
110036: DEC
110037: ST_TO_ADDR
110038: LD_EXP 161
110042: PUSH
110043: FOR_TO
110044: IFFALSE 110145
// begin tmp := 0 ;
110046: LD_ADDR_VAR 0 2
110050: PUSH
110051: LD_STRING 0
110053: ST_TO_ADDR
// if result [ 1 ] then
110054: LD_VAR 0 1
110058: PUSH
110059: LD_INT 1
110061: ARRAY
110062: IFFALSE 110127
// if result [ 1 ] [ 1 ] = i then
110064: LD_VAR 0 1
110068: PUSH
110069: LD_INT 1
110071: ARRAY
110072: PUSH
110073: LD_INT 1
110075: ARRAY
110076: PUSH
110077: LD_VAR 0 5
110081: EQUAL
110082: IFFALSE 110127
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
110084: LD_ADDR_VAR 0 1
110088: PUSH
110089: LD_VAR 0 1
110093: PPUSH
110094: LD_INT 1
110096: PPUSH
110097: LD_VAR 0 1
110101: PUSH
110102: LD_INT 1
110104: ARRAY
110105: PPUSH
110106: LD_INT 1
110108: PPUSH
110109: CALL_OW 3
110113: PPUSH
110114: CALL_OW 1
110118: ST_TO_ADDR
// tmp := 1 ;
110119: LD_ADDR_VAR 0 2
110123: PUSH
110124: LD_STRING 1
110126: ST_TO_ADDR
// end ; normal := normal & tmp ;
110127: LD_ADDR_VAR 0 3
110131: PUSH
110132: LD_VAR 0 3
110136: PUSH
110137: LD_VAR 0 2
110141: STR
110142: ST_TO_ADDR
// end ;
110143: GO 110043
110145: POP
110146: POP
// for i = 1 to hardcoreCounter do
110147: LD_ADDR_VAR 0 5
110151: PUSH
110152: DOUBLE
110153: LD_INT 1
110155: DEC
110156: ST_TO_ADDR
110157: LD_EXP 162
110161: PUSH
110162: FOR_TO
110163: IFFALSE 110268
// begin tmp := 0 ;
110165: LD_ADDR_VAR 0 2
110169: PUSH
110170: LD_STRING 0
110172: ST_TO_ADDR
// if result [ 2 ] then
110173: LD_VAR 0 1
110177: PUSH
110178: LD_INT 2
110180: ARRAY
110181: IFFALSE 110250
// if result [ 2 ] [ 1 ] = 100 + i then
110183: LD_VAR 0 1
110187: PUSH
110188: LD_INT 2
110190: ARRAY
110191: PUSH
110192: LD_INT 1
110194: ARRAY
110195: PUSH
110196: LD_INT 100
110198: PUSH
110199: LD_VAR 0 5
110203: PLUS
110204: EQUAL
110205: IFFALSE 110250
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
110207: LD_ADDR_VAR 0 1
110211: PUSH
110212: LD_VAR 0 1
110216: PPUSH
110217: LD_INT 2
110219: PPUSH
110220: LD_VAR 0 1
110224: PUSH
110225: LD_INT 2
110227: ARRAY
110228: PPUSH
110229: LD_INT 1
110231: PPUSH
110232: CALL_OW 3
110236: PPUSH
110237: CALL_OW 1
110241: ST_TO_ADDR
// tmp := 1 ;
110242: LD_ADDR_VAR 0 2
110246: PUSH
110247: LD_STRING 1
110249: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
110250: LD_ADDR_VAR 0 4
110254: PUSH
110255: LD_VAR 0 4
110259: PUSH
110260: LD_VAR 0 2
110264: STR
110265: ST_TO_ADDR
// end ;
110266: GO 110162
110268: POP
110269: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
110270: LD_STRING getStreamItemsFromMission("
110272: PUSH
110273: LD_VAR 0 3
110277: STR
110278: PUSH
110279: LD_STRING ","
110281: STR
110282: PUSH
110283: LD_VAR 0 4
110287: STR
110288: PUSH
110289: LD_STRING ")
110291: STR
110292: PPUSH
110293: CALL_OW 559
// end else
110297: GO 110306
// ToLua ( getStreamItemsFromMission("","") ) ;
110299: LD_STRING getStreamItemsFromMission("","")
110301: PPUSH
110302: CALL_OW 559
// end ;
110306: LD_VAR 0 1
110310: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
110311: LD_EXP 160
110315: PUSH
110316: LD_EXP 165
110320: AND
110321: IFFALSE 110445
110323: GO 110325
110325: DISABLE
110326: LD_INT 0
110328: PPUSH
110329: PPUSH
// begin enable ;
110330: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
110331: LD_ADDR_VAR 0 2
110335: PUSH
110336: LD_INT 22
110338: PUSH
110339: LD_OWVAR 2
110343: PUSH
110344: EMPTY
110345: LIST
110346: LIST
110347: PUSH
110348: LD_INT 2
110350: PUSH
110351: LD_INT 34
110353: PUSH
110354: LD_INT 7
110356: PUSH
110357: EMPTY
110358: LIST
110359: LIST
110360: PUSH
110361: LD_INT 34
110363: PUSH
110364: LD_INT 45
110366: PUSH
110367: EMPTY
110368: LIST
110369: LIST
110370: PUSH
110371: LD_INT 34
110373: PUSH
110374: LD_INT 28
110376: PUSH
110377: EMPTY
110378: LIST
110379: LIST
110380: PUSH
110381: LD_INT 34
110383: PUSH
110384: LD_INT 47
110386: PUSH
110387: EMPTY
110388: LIST
110389: LIST
110390: PUSH
110391: EMPTY
110392: LIST
110393: LIST
110394: LIST
110395: LIST
110396: LIST
110397: PUSH
110398: EMPTY
110399: LIST
110400: LIST
110401: PPUSH
110402: CALL_OW 69
110406: ST_TO_ADDR
// if not tmp then
110407: LD_VAR 0 2
110411: NOT
110412: IFFALSE 110416
// exit ;
110414: GO 110445
// for i in tmp do
110416: LD_ADDR_VAR 0 1
110420: PUSH
110421: LD_VAR 0 2
110425: PUSH
110426: FOR_IN
110427: IFFALSE 110443
// begin SetLives ( i , 0 ) ;
110429: LD_VAR 0 1
110433: PPUSH
110434: LD_INT 0
110436: PPUSH
110437: CALL_OW 234
// end ;
110441: GO 110426
110443: POP
110444: POP
// end ;
110445: PPOPN 2
110447: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
110448: LD_EXP 160
110452: PUSH
110453: LD_EXP 166
110457: AND
110458: IFFALSE 110542
110460: GO 110462
110462: DISABLE
110463: LD_INT 0
110465: PPUSH
110466: PPUSH
// begin enable ;
110467: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
110468: LD_ADDR_VAR 0 2
110472: PUSH
110473: LD_INT 22
110475: PUSH
110476: LD_OWVAR 2
110480: PUSH
110481: EMPTY
110482: LIST
110483: LIST
110484: PUSH
110485: LD_INT 32
110487: PUSH
110488: LD_INT 3
110490: PUSH
110491: EMPTY
110492: LIST
110493: LIST
110494: PUSH
110495: EMPTY
110496: LIST
110497: LIST
110498: PPUSH
110499: CALL_OW 69
110503: ST_TO_ADDR
// if not tmp then
110504: LD_VAR 0 2
110508: NOT
110509: IFFALSE 110513
// exit ;
110511: GO 110542
// for i in tmp do
110513: LD_ADDR_VAR 0 1
110517: PUSH
110518: LD_VAR 0 2
110522: PUSH
110523: FOR_IN
110524: IFFALSE 110540
// begin SetLives ( i , 0 ) ;
110526: LD_VAR 0 1
110530: PPUSH
110531: LD_INT 0
110533: PPUSH
110534: CALL_OW 234
// end ;
110538: GO 110523
110540: POP
110541: POP
// end ;
110542: PPOPN 2
110544: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
110545: LD_EXP 160
110549: PUSH
110550: LD_EXP 163
110554: AND
110555: IFFALSE 110648
110557: GO 110559
110559: DISABLE
110560: LD_INT 0
110562: PPUSH
// begin enable ;
110563: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
110564: LD_ADDR_VAR 0 1
110568: PUSH
110569: LD_INT 22
110571: PUSH
110572: LD_OWVAR 2
110576: PUSH
110577: EMPTY
110578: LIST
110579: LIST
110580: PUSH
110581: LD_INT 2
110583: PUSH
110584: LD_INT 25
110586: PUSH
110587: LD_INT 5
110589: PUSH
110590: EMPTY
110591: LIST
110592: LIST
110593: PUSH
110594: LD_INT 25
110596: PUSH
110597: LD_INT 9
110599: PUSH
110600: EMPTY
110601: LIST
110602: LIST
110603: PUSH
110604: LD_INT 25
110606: PUSH
110607: LD_INT 8
110609: PUSH
110610: EMPTY
110611: LIST
110612: LIST
110613: PUSH
110614: EMPTY
110615: LIST
110616: LIST
110617: LIST
110618: LIST
110619: PUSH
110620: EMPTY
110621: LIST
110622: LIST
110623: PPUSH
110624: CALL_OW 69
110628: PUSH
110629: FOR_IN
110630: IFFALSE 110646
// begin SetClass ( i , 1 ) ;
110632: LD_VAR 0 1
110636: PPUSH
110637: LD_INT 1
110639: PPUSH
110640: CALL_OW 336
// end ;
110644: GO 110629
110646: POP
110647: POP
// end ;
110648: PPOPN 1
110650: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
110651: LD_EXP 160
110655: PUSH
110656: LD_EXP 164
110660: AND
110661: PUSH
110662: LD_OWVAR 65
110666: PUSH
110667: LD_INT 7
110669: LESS
110670: AND
110671: IFFALSE 110685
110673: GO 110675
110675: DISABLE
// begin enable ;
110676: ENABLE
// game_speed := 7 ;
110677: LD_ADDR_OWVAR 65
110681: PUSH
110682: LD_INT 7
110684: ST_TO_ADDR
// end ;
110685: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
110686: LD_EXP 160
110690: PUSH
110691: LD_EXP 167
110695: AND
110696: IFFALSE 110898
110698: GO 110700
110700: DISABLE
110701: LD_INT 0
110703: PPUSH
110704: PPUSH
110705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
110706: LD_ADDR_VAR 0 3
110710: PUSH
110711: LD_INT 81
110713: PUSH
110714: LD_OWVAR 2
110718: PUSH
110719: EMPTY
110720: LIST
110721: LIST
110722: PUSH
110723: LD_INT 21
110725: PUSH
110726: LD_INT 1
110728: PUSH
110729: EMPTY
110730: LIST
110731: LIST
110732: PUSH
110733: EMPTY
110734: LIST
110735: LIST
110736: PPUSH
110737: CALL_OW 69
110741: ST_TO_ADDR
// if not tmp then
110742: LD_VAR 0 3
110746: NOT
110747: IFFALSE 110751
// exit ;
110749: GO 110898
// if tmp > 5 then
110751: LD_VAR 0 3
110755: PUSH
110756: LD_INT 5
110758: GREATER
110759: IFFALSE 110771
// k := 5 else
110761: LD_ADDR_VAR 0 2
110765: PUSH
110766: LD_INT 5
110768: ST_TO_ADDR
110769: GO 110781
// k := tmp ;
110771: LD_ADDR_VAR 0 2
110775: PUSH
110776: LD_VAR 0 3
110780: ST_TO_ADDR
// for i := 1 to k do
110781: LD_ADDR_VAR 0 1
110785: PUSH
110786: DOUBLE
110787: LD_INT 1
110789: DEC
110790: ST_TO_ADDR
110791: LD_VAR 0 2
110795: PUSH
110796: FOR_TO
110797: IFFALSE 110896
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
110799: LD_VAR 0 3
110803: PUSH
110804: LD_VAR 0 1
110808: ARRAY
110809: PPUSH
110810: LD_VAR 0 1
110814: PUSH
110815: LD_INT 4
110817: MOD
110818: PUSH
110819: LD_INT 1
110821: PLUS
110822: PPUSH
110823: CALL_OW 259
110827: PUSH
110828: LD_INT 10
110830: LESS
110831: IFFALSE 110894
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
110833: LD_VAR 0 3
110837: PUSH
110838: LD_VAR 0 1
110842: ARRAY
110843: PPUSH
110844: LD_VAR 0 1
110848: PUSH
110849: LD_INT 4
110851: MOD
110852: PUSH
110853: LD_INT 1
110855: PLUS
110856: PPUSH
110857: LD_VAR 0 3
110861: PUSH
110862: LD_VAR 0 1
110866: ARRAY
110867: PPUSH
110868: LD_VAR 0 1
110872: PUSH
110873: LD_INT 4
110875: MOD
110876: PUSH
110877: LD_INT 1
110879: PLUS
110880: PPUSH
110881: CALL_OW 259
110885: PUSH
110886: LD_INT 1
110888: PLUS
110889: PPUSH
110890: CALL_OW 237
110894: GO 110796
110896: POP
110897: POP
// end ;
110898: PPOPN 3
110900: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
110901: LD_EXP 160
110905: PUSH
110906: LD_EXP 168
110910: AND
110911: IFFALSE 110931
110913: GO 110915
110915: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
110916: LD_INT 4
110918: PPUSH
110919: LD_OWVAR 2
110923: PPUSH
110924: LD_INT 0
110926: PPUSH
110927: CALL_OW 324
110931: END
// every 0 0$1 trigger StreamModeActive and sShovel do
110932: LD_EXP 160
110936: PUSH
110937: LD_EXP 197
110941: AND
110942: IFFALSE 110962
110944: GO 110946
110946: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
110947: LD_INT 19
110949: PPUSH
110950: LD_OWVAR 2
110954: PPUSH
110955: LD_INT 0
110957: PPUSH
110958: CALL_OW 324
110962: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
110963: LD_EXP 160
110967: PUSH
110968: LD_EXP 169
110972: AND
110973: IFFALSE 111075
110975: GO 110977
110977: DISABLE
110978: LD_INT 0
110980: PPUSH
110981: PPUSH
// begin enable ;
110982: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
110983: LD_ADDR_VAR 0 2
110987: PUSH
110988: LD_INT 22
110990: PUSH
110991: LD_OWVAR 2
110995: PUSH
110996: EMPTY
110997: LIST
110998: LIST
110999: PUSH
111000: LD_INT 2
111002: PUSH
111003: LD_INT 34
111005: PUSH
111006: LD_INT 11
111008: PUSH
111009: EMPTY
111010: LIST
111011: LIST
111012: PUSH
111013: LD_INT 34
111015: PUSH
111016: LD_INT 30
111018: PUSH
111019: EMPTY
111020: LIST
111021: LIST
111022: PUSH
111023: EMPTY
111024: LIST
111025: LIST
111026: LIST
111027: PUSH
111028: EMPTY
111029: LIST
111030: LIST
111031: PPUSH
111032: CALL_OW 69
111036: ST_TO_ADDR
// if not tmp then
111037: LD_VAR 0 2
111041: NOT
111042: IFFALSE 111046
// exit ;
111044: GO 111075
// for i in tmp do
111046: LD_ADDR_VAR 0 1
111050: PUSH
111051: LD_VAR 0 2
111055: PUSH
111056: FOR_IN
111057: IFFALSE 111073
// begin SetLives ( i , 0 ) ;
111059: LD_VAR 0 1
111063: PPUSH
111064: LD_INT 0
111066: PPUSH
111067: CALL_OW 234
// end ;
111071: GO 111056
111073: POP
111074: POP
// end ;
111075: PPOPN 2
111077: END
// every 0 0$1 trigger StreamModeActive and sBunker do
111078: LD_EXP 160
111082: PUSH
111083: LD_EXP 170
111087: AND
111088: IFFALSE 111108
111090: GO 111092
111092: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
111093: LD_INT 32
111095: PPUSH
111096: LD_OWVAR 2
111100: PPUSH
111101: LD_INT 0
111103: PPUSH
111104: CALL_OW 324
111108: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
111109: LD_EXP 160
111113: PUSH
111114: LD_EXP 171
111118: AND
111119: IFFALSE 111300
111121: GO 111123
111123: DISABLE
111124: LD_INT 0
111126: PPUSH
111127: PPUSH
111128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
111129: LD_ADDR_VAR 0 2
111133: PUSH
111134: LD_INT 22
111136: PUSH
111137: LD_OWVAR 2
111141: PUSH
111142: EMPTY
111143: LIST
111144: LIST
111145: PUSH
111146: LD_INT 33
111148: PUSH
111149: LD_INT 3
111151: PUSH
111152: EMPTY
111153: LIST
111154: LIST
111155: PUSH
111156: EMPTY
111157: LIST
111158: LIST
111159: PPUSH
111160: CALL_OW 69
111164: ST_TO_ADDR
// if not tmp then
111165: LD_VAR 0 2
111169: NOT
111170: IFFALSE 111174
// exit ;
111172: GO 111300
// side := 0 ;
111174: LD_ADDR_VAR 0 3
111178: PUSH
111179: LD_INT 0
111181: ST_TO_ADDR
// for i := 1 to 8 do
111182: LD_ADDR_VAR 0 1
111186: PUSH
111187: DOUBLE
111188: LD_INT 1
111190: DEC
111191: ST_TO_ADDR
111192: LD_INT 8
111194: PUSH
111195: FOR_TO
111196: IFFALSE 111244
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
111198: LD_OWVAR 2
111202: PUSH
111203: LD_VAR 0 1
111207: NONEQUAL
111208: PUSH
111209: LD_OWVAR 2
111213: PPUSH
111214: LD_VAR 0 1
111218: PPUSH
111219: CALL_OW 81
111223: PUSH
111224: LD_INT 2
111226: EQUAL
111227: AND
111228: IFFALSE 111242
// begin side := i ;
111230: LD_ADDR_VAR 0 3
111234: PUSH
111235: LD_VAR 0 1
111239: ST_TO_ADDR
// break ;
111240: GO 111244
// end ;
111242: GO 111195
111244: POP
111245: POP
// if not side then
111246: LD_VAR 0 3
111250: NOT
111251: IFFALSE 111255
// exit ;
111253: GO 111300
// for i := 1 to tmp do
111255: LD_ADDR_VAR 0 1
111259: PUSH
111260: DOUBLE
111261: LD_INT 1
111263: DEC
111264: ST_TO_ADDR
111265: LD_VAR 0 2
111269: PUSH
111270: FOR_TO
111271: IFFALSE 111298
// if Prob ( 60 ) then
111273: LD_INT 60
111275: PPUSH
111276: CALL_OW 13
111280: IFFALSE 111296
// SetSide ( i , side ) ;
111282: LD_VAR 0 1
111286: PPUSH
111287: LD_VAR 0 3
111291: PPUSH
111292: CALL_OW 235
111296: GO 111270
111298: POP
111299: POP
// end ;
111300: PPOPN 3
111302: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
111303: LD_EXP 160
111307: PUSH
111308: LD_EXP 173
111312: AND
111313: IFFALSE 111432
111315: GO 111317
111317: DISABLE
111318: LD_INT 0
111320: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
111321: LD_ADDR_VAR 0 1
111325: PUSH
111326: LD_INT 22
111328: PUSH
111329: LD_OWVAR 2
111333: PUSH
111334: EMPTY
111335: LIST
111336: LIST
111337: PUSH
111338: LD_INT 21
111340: PUSH
111341: LD_INT 1
111343: PUSH
111344: EMPTY
111345: LIST
111346: LIST
111347: PUSH
111348: LD_INT 3
111350: PUSH
111351: LD_INT 23
111353: PUSH
111354: LD_INT 0
111356: PUSH
111357: EMPTY
111358: LIST
111359: LIST
111360: PUSH
111361: EMPTY
111362: LIST
111363: LIST
111364: PUSH
111365: EMPTY
111366: LIST
111367: LIST
111368: LIST
111369: PPUSH
111370: CALL_OW 69
111374: PUSH
111375: FOR_IN
111376: IFFALSE 111430
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
111378: LD_VAR 0 1
111382: PPUSH
111383: CALL_OW 257
111387: PUSH
111388: LD_INT 1
111390: PUSH
111391: LD_INT 2
111393: PUSH
111394: LD_INT 3
111396: PUSH
111397: LD_INT 4
111399: PUSH
111400: EMPTY
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: IN
111406: IFFALSE 111428
// SetClass ( un , rand ( 1 , 4 ) ) ;
111408: LD_VAR 0 1
111412: PPUSH
111413: LD_INT 1
111415: PPUSH
111416: LD_INT 4
111418: PPUSH
111419: CALL_OW 12
111423: PPUSH
111424: CALL_OW 336
111428: GO 111375
111430: POP
111431: POP
// end ;
111432: PPOPN 1
111434: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
111435: LD_EXP 160
111439: PUSH
111440: LD_EXP 172
111444: AND
111445: IFFALSE 111524
111447: GO 111449
111449: DISABLE
111450: LD_INT 0
111452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111453: LD_ADDR_VAR 0 1
111457: PUSH
111458: LD_INT 22
111460: PUSH
111461: LD_OWVAR 2
111465: PUSH
111466: EMPTY
111467: LIST
111468: LIST
111469: PUSH
111470: LD_INT 21
111472: PUSH
111473: LD_INT 3
111475: PUSH
111476: EMPTY
111477: LIST
111478: LIST
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: PPUSH
111484: CALL_OW 69
111488: ST_TO_ADDR
// if not tmp then
111489: LD_VAR 0 1
111493: NOT
111494: IFFALSE 111498
// exit ;
111496: GO 111524
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
111498: LD_VAR 0 1
111502: PUSH
111503: LD_INT 1
111505: PPUSH
111506: LD_VAR 0 1
111510: PPUSH
111511: CALL_OW 12
111515: ARRAY
111516: PPUSH
111517: LD_INT 100
111519: PPUSH
111520: CALL_OW 234
// end ;
111524: PPOPN 1
111526: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
111527: LD_EXP 160
111531: PUSH
111532: LD_EXP 174
111536: AND
111537: IFFALSE 111635
111539: GO 111541
111541: DISABLE
111542: LD_INT 0
111544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
111545: LD_ADDR_VAR 0 1
111549: PUSH
111550: LD_INT 22
111552: PUSH
111553: LD_OWVAR 2
111557: PUSH
111558: EMPTY
111559: LIST
111560: LIST
111561: PUSH
111562: LD_INT 21
111564: PUSH
111565: LD_INT 1
111567: PUSH
111568: EMPTY
111569: LIST
111570: LIST
111571: PUSH
111572: EMPTY
111573: LIST
111574: LIST
111575: PPUSH
111576: CALL_OW 69
111580: ST_TO_ADDR
// if not tmp then
111581: LD_VAR 0 1
111585: NOT
111586: IFFALSE 111590
// exit ;
111588: GO 111635
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
111590: LD_VAR 0 1
111594: PUSH
111595: LD_INT 1
111597: PPUSH
111598: LD_VAR 0 1
111602: PPUSH
111603: CALL_OW 12
111607: ARRAY
111608: PPUSH
111609: LD_INT 1
111611: PPUSH
111612: LD_INT 4
111614: PPUSH
111615: CALL_OW 12
111619: PPUSH
111620: LD_INT 3000
111622: PPUSH
111623: LD_INT 9000
111625: PPUSH
111626: CALL_OW 12
111630: PPUSH
111631: CALL_OW 492
// end ;
111635: PPOPN 1
111637: END
// every 0 0$1 trigger StreamModeActive and sDepot do
111638: LD_EXP 160
111642: PUSH
111643: LD_EXP 175
111647: AND
111648: IFFALSE 111668
111650: GO 111652
111652: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
111653: LD_INT 1
111655: PPUSH
111656: LD_OWVAR 2
111660: PPUSH
111661: LD_INT 0
111663: PPUSH
111664: CALL_OW 324
111668: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
111669: LD_EXP 160
111673: PUSH
111674: LD_EXP 176
111678: AND
111679: IFFALSE 111762
111681: GO 111683
111683: DISABLE
111684: LD_INT 0
111686: PPUSH
111687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111688: LD_ADDR_VAR 0 2
111692: PUSH
111693: LD_INT 22
111695: PUSH
111696: LD_OWVAR 2
111700: PUSH
111701: EMPTY
111702: LIST
111703: LIST
111704: PUSH
111705: LD_INT 21
111707: PUSH
111708: LD_INT 3
111710: PUSH
111711: EMPTY
111712: LIST
111713: LIST
111714: PUSH
111715: EMPTY
111716: LIST
111717: LIST
111718: PPUSH
111719: CALL_OW 69
111723: ST_TO_ADDR
// if not tmp then
111724: LD_VAR 0 2
111728: NOT
111729: IFFALSE 111733
// exit ;
111731: GO 111762
// for i in tmp do
111733: LD_ADDR_VAR 0 1
111737: PUSH
111738: LD_VAR 0 2
111742: PUSH
111743: FOR_IN
111744: IFFALSE 111760
// SetBLevel ( i , 10 ) ;
111746: LD_VAR 0 1
111750: PPUSH
111751: LD_INT 10
111753: PPUSH
111754: CALL_OW 241
111758: GO 111743
111760: POP
111761: POP
// end ;
111762: PPOPN 2
111764: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
111765: LD_EXP 160
111769: PUSH
111770: LD_EXP 177
111774: AND
111775: IFFALSE 111886
111777: GO 111779
111779: DISABLE
111780: LD_INT 0
111782: PPUSH
111783: PPUSH
111784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111785: LD_ADDR_VAR 0 3
111789: PUSH
111790: LD_INT 22
111792: PUSH
111793: LD_OWVAR 2
111797: PUSH
111798: EMPTY
111799: LIST
111800: LIST
111801: PUSH
111802: LD_INT 25
111804: PUSH
111805: LD_INT 1
111807: PUSH
111808: EMPTY
111809: LIST
111810: LIST
111811: PUSH
111812: EMPTY
111813: LIST
111814: LIST
111815: PPUSH
111816: CALL_OW 69
111820: ST_TO_ADDR
// if not tmp then
111821: LD_VAR 0 3
111825: NOT
111826: IFFALSE 111830
// exit ;
111828: GO 111886
// un := tmp [ rand ( 1 , tmp ) ] ;
111830: LD_ADDR_VAR 0 2
111834: PUSH
111835: LD_VAR 0 3
111839: PUSH
111840: LD_INT 1
111842: PPUSH
111843: LD_VAR 0 3
111847: PPUSH
111848: CALL_OW 12
111852: ARRAY
111853: ST_TO_ADDR
// if Crawls ( un ) then
111854: LD_VAR 0 2
111858: PPUSH
111859: CALL_OW 318
111863: IFFALSE 111874
// ComWalk ( un ) ;
111865: LD_VAR 0 2
111869: PPUSH
111870: CALL_OW 138
// SetClass ( un , class_sniper ) ;
111874: LD_VAR 0 2
111878: PPUSH
111879: LD_INT 5
111881: PPUSH
111882: CALL_OW 336
// end ;
111886: PPOPN 3
111888: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
111889: LD_EXP 160
111893: PUSH
111894: LD_EXP 178
111898: AND
111899: PUSH
111900: LD_OWVAR 67
111904: PUSH
111905: LD_INT 3
111907: LESS
111908: AND
111909: IFFALSE 111928
111911: GO 111913
111913: DISABLE
// Difficulty := Difficulty + 1 ;
111914: LD_ADDR_OWVAR 67
111918: PUSH
111919: LD_OWVAR 67
111923: PUSH
111924: LD_INT 1
111926: PLUS
111927: ST_TO_ADDR
111928: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
111929: LD_EXP 160
111933: PUSH
111934: LD_EXP 179
111938: AND
111939: IFFALSE 112042
111941: GO 111943
111943: DISABLE
111944: LD_INT 0
111946: PPUSH
// begin for i := 1 to 5 do
111947: LD_ADDR_VAR 0 1
111951: PUSH
111952: DOUBLE
111953: LD_INT 1
111955: DEC
111956: ST_TO_ADDR
111957: LD_INT 5
111959: PUSH
111960: FOR_TO
111961: IFFALSE 112040
// begin uc_nation := nation_nature ;
111963: LD_ADDR_OWVAR 21
111967: PUSH
111968: LD_INT 0
111970: ST_TO_ADDR
// uc_side := 0 ;
111971: LD_ADDR_OWVAR 20
111975: PUSH
111976: LD_INT 0
111978: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
111979: LD_ADDR_OWVAR 29
111983: PUSH
111984: LD_INT 12
111986: PUSH
111987: LD_INT 12
111989: PUSH
111990: EMPTY
111991: LIST
111992: LIST
111993: ST_TO_ADDR
// hc_agressivity := 20 ;
111994: LD_ADDR_OWVAR 35
111998: PUSH
111999: LD_INT 20
112001: ST_TO_ADDR
// hc_class := class_tiger ;
112002: LD_ADDR_OWVAR 28
112006: PUSH
112007: LD_INT 14
112009: ST_TO_ADDR
// hc_gallery :=  ;
112010: LD_ADDR_OWVAR 33
112014: PUSH
112015: LD_STRING 
112017: ST_TO_ADDR
// hc_name :=  ;
112018: LD_ADDR_OWVAR 26
112022: PUSH
112023: LD_STRING 
112025: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
112026: CALL_OW 44
112030: PPUSH
112031: LD_INT 0
112033: PPUSH
112034: CALL_OW 51
// end ;
112038: GO 111960
112040: POP
112041: POP
// end ;
112042: PPOPN 1
112044: END
// every 0 0$1 trigger StreamModeActive and sBomb do
112045: LD_EXP 160
112049: PUSH
112050: LD_EXP 180
112054: AND
112055: IFFALSE 112064
112057: GO 112059
112059: DISABLE
// StreamSibBomb ;
112060: CALL 112065 0 0
112064: END
// export function StreamSibBomb ; var i , x , y ; begin
112065: LD_INT 0
112067: PPUSH
112068: PPUSH
112069: PPUSH
112070: PPUSH
// result := false ;
112071: LD_ADDR_VAR 0 1
112075: PUSH
112076: LD_INT 0
112078: ST_TO_ADDR
// for i := 1 to 16 do
112079: LD_ADDR_VAR 0 2
112083: PUSH
112084: DOUBLE
112085: LD_INT 1
112087: DEC
112088: ST_TO_ADDR
112089: LD_INT 16
112091: PUSH
112092: FOR_TO
112093: IFFALSE 112292
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112095: LD_ADDR_VAR 0 3
112099: PUSH
112100: LD_INT 10
112102: PUSH
112103: LD_INT 20
112105: PUSH
112106: LD_INT 30
112108: PUSH
112109: LD_INT 40
112111: PUSH
112112: LD_INT 50
112114: PUSH
112115: LD_INT 60
112117: PUSH
112118: LD_INT 70
112120: PUSH
112121: LD_INT 80
112123: PUSH
112124: LD_INT 90
112126: PUSH
112127: LD_INT 100
112129: PUSH
112130: LD_INT 110
112132: PUSH
112133: LD_INT 120
112135: PUSH
112136: LD_INT 130
112138: PUSH
112139: LD_INT 140
112141: PUSH
112142: LD_INT 150
112144: PUSH
112145: EMPTY
112146: LIST
112147: LIST
112148: LIST
112149: LIST
112150: LIST
112151: LIST
112152: LIST
112153: LIST
112154: LIST
112155: LIST
112156: LIST
112157: LIST
112158: LIST
112159: LIST
112160: LIST
112161: PUSH
112162: LD_INT 1
112164: PPUSH
112165: LD_INT 15
112167: PPUSH
112168: CALL_OW 12
112172: ARRAY
112173: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112174: LD_ADDR_VAR 0 4
112178: PUSH
112179: LD_INT 10
112181: PUSH
112182: LD_INT 20
112184: PUSH
112185: LD_INT 30
112187: PUSH
112188: LD_INT 40
112190: PUSH
112191: LD_INT 50
112193: PUSH
112194: LD_INT 60
112196: PUSH
112197: LD_INT 70
112199: PUSH
112200: LD_INT 80
112202: PUSH
112203: LD_INT 90
112205: PUSH
112206: LD_INT 100
112208: PUSH
112209: LD_INT 110
112211: PUSH
112212: LD_INT 120
112214: PUSH
112215: LD_INT 130
112217: PUSH
112218: LD_INT 140
112220: PUSH
112221: LD_INT 150
112223: PUSH
112224: EMPTY
112225: LIST
112226: LIST
112227: LIST
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: LIST
112237: LIST
112238: LIST
112239: LIST
112240: PUSH
112241: LD_INT 1
112243: PPUSH
112244: LD_INT 15
112246: PPUSH
112247: CALL_OW 12
112251: ARRAY
112252: ST_TO_ADDR
// if ValidHex ( x , y ) then
112253: LD_VAR 0 3
112257: PPUSH
112258: LD_VAR 0 4
112262: PPUSH
112263: CALL_OW 488
112267: IFFALSE 112290
// begin result := [ x , y ] ;
112269: LD_ADDR_VAR 0 1
112273: PUSH
112274: LD_VAR 0 3
112278: PUSH
112279: LD_VAR 0 4
112283: PUSH
112284: EMPTY
112285: LIST
112286: LIST
112287: ST_TO_ADDR
// break ;
112288: GO 112292
// end ; end ;
112290: GO 112092
112292: POP
112293: POP
// if result then
112294: LD_VAR 0 1
112298: IFFALSE 112358
// begin ToLua ( playSibBomb() ) ;
112300: LD_STRING playSibBomb()
112302: PPUSH
112303: CALL_OW 559
// wait ( 0 0$14 ) ;
112307: LD_INT 490
112309: PPUSH
112310: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
112314: LD_VAR 0 1
112318: PUSH
112319: LD_INT 1
112321: ARRAY
112322: PPUSH
112323: LD_VAR 0 1
112327: PUSH
112328: LD_INT 2
112330: ARRAY
112331: PPUSH
112332: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
112336: LD_VAR 0 1
112340: PUSH
112341: LD_INT 1
112343: ARRAY
112344: PPUSH
112345: LD_VAR 0 1
112349: PUSH
112350: LD_INT 2
112352: ARRAY
112353: PPUSH
112354: CALL_OW 429
// end ; end ;
112358: LD_VAR 0 1
112362: RET
// every 0 0$1 trigger StreamModeActive and sReset do
112363: LD_EXP 160
112367: PUSH
112368: LD_EXP 182
112372: AND
112373: IFFALSE 112385
112375: GO 112377
112377: DISABLE
// YouLost (  ) ;
112378: LD_STRING 
112380: PPUSH
112381: CALL_OW 104
112385: END
// every 0 0$1 trigger StreamModeActive and sFog do
112386: LD_EXP 160
112390: PUSH
112391: LD_EXP 181
112395: AND
112396: IFFALSE 112410
112398: GO 112400
112400: DISABLE
// FogOff ( your_side ) ;
112401: LD_OWVAR 2
112405: PPUSH
112406: CALL_OW 344
112410: END
// every 0 0$1 trigger StreamModeActive and sSun do
112411: LD_EXP 160
112415: PUSH
112416: LD_EXP 183
112420: AND
112421: IFFALSE 112449
112423: GO 112425
112425: DISABLE
// begin solar_recharge_percent := 0 ;
112426: LD_ADDR_OWVAR 79
112430: PUSH
112431: LD_INT 0
112433: ST_TO_ADDR
// wait ( 5 5$00 ) ;
112434: LD_INT 10500
112436: PPUSH
112437: CALL_OW 67
// solar_recharge_percent := 100 ;
112441: LD_ADDR_OWVAR 79
112445: PUSH
112446: LD_INT 100
112448: ST_TO_ADDR
// end ;
112449: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
112450: LD_EXP 160
112454: PUSH
112455: LD_EXP 184
112459: AND
112460: IFFALSE 112699
112462: GO 112464
112464: DISABLE
112465: LD_INT 0
112467: PPUSH
112468: PPUSH
112469: PPUSH
// begin tmp := [ ] ;
112470: LD_ADDR_VAR 0 3
112474: PUSH
112475: EMPTY
112476: ST_TO_ADDR
// for i := 1 to 6 do
112477: LD_ADDR_VAR 0 1
112481: PUSH
112482: DOUBLE
112483: LD_INT 1
112485: DEC
112486: ST_TO_ADDR
112487: LD_INT 6
112489: PUSH
112490: FOR_TO
112491: IFFALSE 112596
// begin uc_nation := nation_nature ;
112493: LD_ADDR_OWVAR 21
112497: PUSH
112498: LD_INT 0
112500: ST_TO_ADDR
// uc_side := 0 ;
112501: LD_ADDR_OWVAR 20
112505: PUSH
112506: LD_INT 0
112508: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112509: LD_ADDR_OWVAR 29
112513: PUSH
112514: LD_INT 12
112516: PUSH
112517: LD_INT 12
112519: PUSH
112520: EMPTY
112521: LIST
112522: LIST
112523: ST_TO_ADDR
// hc_agressivity := 20 ;
112524: LD_ADDR_OWVAR 35
112528: PUSH
112529: LD_INT 20
112531: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
112532: LD_ADDR_OWVAR 28
112536: PUSH
112537: LD_INT 17
112539: ST_TO_ADDR
// hc_gallery :=  ;
112540: LD_ADDR_OWVAR 33
112544: PUSH
112545: LD_STRING 
112547: ST_TO_ADDR
// hc_name :=  ;
112548: LD_ADDR_OWVAR 26
112552: PUSH
112553: LD_STRING 
112555: ST_TO_ADDR
// un := CreateHuman ;
112556: LD_ADDR_VAR 0 2
112560: PUSH
112561: CALL_OW 44
112565: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
112566: LD_VAR 0 2
112570: PPUSH
112571: LD_INT 1
112573: PPUSH
112574: CALL_OW 51
// tmp := tmp ^ un ;
112578: LD_ADDR_VAR 0 3
112582: PUSH
112583: LD_VAR 0 3
112587: PUSH
112588: LD_VAR 0 2
112592: ADD
112593: ST_TO_ADDR
// end ;
112594: GO 112490
112596: POP
112597: POP
// repeat wait ( 0 0$1 ) ;
112598: LD_INT 35
112600: PPUSH
112601: CALL_OW 67
// for un in tmp do
112605: LD_ADDR_VAR 0 2
112609: PUSH
112610: LD_VAR 0 3
112614: PUSH
112615: FOR_IN
112616: IFFALSE 112690
// begin if IsDead ( un ) then
112618: LD_VAR 0 2
112622: PPUSH
112623: CALL_OW 301
112627: IFFALSE 112647
// begin tmp := tmp diff un ;
112629: LD_ADDR_VAR 0 3
112633: PUSH
112634: LD_VAR 0 3
112638: PUSH
112639: LD_VAR 0 2
112643: DIFF
112644: ST_TO_ADDR
// continue ;
112645: GO 112615
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
112647: LD_VAR 0 2
112651: PPUSH
112652: LD_INT 3
112654: PUSH
112655: LD_INT 22
112657: PUSH
112658: LD_INT 0
112660: PUSH
112661: EMPTY
112662: LIST
112663: LIST
112664: PUSH
112665: EMPTY
112666: LIST
112667: LIST
112668: PPUSH
112669: CALL_OW 69
112673: PPUSH
112674: LD_VAR 0 2
112678: PPUSH
112679: CALL_OW 74
112683: PPUSH
112684: CALL_OW 115
// end ;
112688: GO 112615
112690: POP
112691: POP
// until not tmp ;
112692: LD_VAR 0 3
112696: NOT
112697: IFFALSE 112598
// end ;
112699: PPOPN 3
112701: END
// every 0 0$1 trigger StreamModeActive and sTroll do
112702: LD_EXP 160
112706: PUSH
112707: LD_EXP 185
112711: AND
112712: IFFALSE 112766
112714: GO 112716
112716: DISABLE
// begin ToLua ( displayTroll(); ) ;
112717: LD_STRING displayTroll();
112719: PPUSH
112720: CALL_OW 559
// wait ( 3 3$00 ) ;
112724: LD_INT 6300
112726: PPUSH
112727: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112731: LD_STRING hideTroll();
112733: PPUSH
112734: CALL_OW 559
// wait ( 1 1$00 ) ;
112738: LD_INT 2100
112740: PPUSH
112741: CALL_OW 67
// ToLua ( displayTroll(); ) ;
112745: LD_STRING displayTroll();
112747: PPUSH
112748: CALL_OW 559
// wait ( 1 1$00 ) ;
112752: LD_INT 2100
112754: PPUSH
112755: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112759: LD_STRING hideTroll();
112761: PPUSH
112762: CALL_OW 559
// end ;
112766: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
112767: LD_EXP 160
112771: PUSH
112772: LD_EXP 186
112776: AND
112777: IFFALSE 112840
112779: GO 112781
112781: DISABLE
112782: LD_INT 0
112784: PPUSH
// begin p := 0 ;
112785: LD_ADDR_VAR 0 1
112789: PUSH
112790: LD_INT 0
112792: ST_TO_ADDR
// repeat game_speed := 1 ;
112793: LD_ADDR_OWVAR 65
112797: PUSH
112798: LD_INT 1
112800: ST_TO_ADDR
// wait ( 0 0$1 ) ;
112801: LD_INT 35
112803: PPUSH
112804: CALL_OW 67
// p := p + 1 ;
112808: LD_ADDR_VAR 0 1
112812: PUSH
112813: LD_VAR 0 1
112817: PUSH
112818: LD_INT 1
112820: PLUS
112821: ST_TO_ADDR
// until p >= 60 ;
112822: LD_VAR 0 1
112826: PUSH
112827: LD_INT 60
112829: GREATEREQUAL
112830: IFFALSE 112793
// game_speed := 4 ;
112832: LD_ADDR_OWVAR 65
112836: PUSH
112837: LD_INT 4
112839: ST_TO_ADDR
// end ;
112840: PPOPN 1
112842: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
112843: LD_EXP 160
112847: PUSH
112848: LD_EXP 187
112852: AND
112853: IFFALSE 112999
112855: GO 112857
112857: DISABLE
112858: LD_INT 0
112860: PPUSH
112861: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
112862: LD_ADDR_VAR 0 1
112866: PUSH
112867: LD_INT 22
112869: PUSH
112870: LD_OWVAR 2
112874: PUSH
112875: EMPTY
112876: LIST
112877: LIST
112878: PUSH
112879: LD_INT 2
112881: PUSH
112882: LD_INT 30
112884: PUSH
112885: LD_INT 0
112887: PUSH
112888: EMPTY
112889: LIST
112890: LIST
112891: PUSH
112892: LD_INT 30
112894: PUSH
112895: LD_INT 1
112897: PUSH
112898: EMPTY
112899: LIST
112900: LIST
112901: PUSH
112902: EMPTY
112903: LIST
112904: LIST
112905: LIST
112906: PUSH
112907: EMPTY
112908: LIST
112909: LIST
112910: PPUSH
112911: CALL_OW 69
112915: ST_TO_ADDR
// if not depot then
112916: LD_VAR 0 1
112920: NOT
112921: IFFALSE 112925
// exit ;
112923: GO 112999
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
112925: LD_ADDR_VAR 0 2
112929: PUSH
112930: LD_VAR 0 1
112934: PUSH
112935: LD_INT 1
112937: PPUSH
112938: LD_VAR 0 1
112942: PPUSH
112943: CALL_OW 12
112947: ARRAY
112948: PPUSH
112949: CALL_OW 274
112953: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
112954: LD_VAR 0 2
112958: PPUSH
112959: LD_INT 1
112961: PPUSH
112962: LD_INT 0
112964: PPUSH
112965: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
112969: LD_VAR 0 2
112973: PPUSH
112974: LD_INT 2
112976: PPUSH
112977: LD_INT 0
112979: PPUSH
112980: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
112984: LD_VAR 0 2
112988: PPUSH
112989: LD_INT 3
112991: PPUSH
112992: LD_INT 0
112994: PPUSH
112995: CALL_OW 277
// end ;
112999: PPOPN 2
113001: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
113002: LD_EXP 160
113006: PUSH
113007: LD_EXP 188
113011: AND
113012: IFFALSE 113109
113014: GO 113016
113016: DISABLE
113017: LD_INT 0
113019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113020: LD_ADDR_VAR 0 1
113024: PUSH
113025: LD_INT 22
113027: PUSH
113028: LD_OWVAR 2
113032: PUSH
113033: EMPTY
113034: LIST
113035: LIST
113036: PUSH
113037: LD_INT 21
113039: PUSH
113040: LD_INT 1
113042: PUSH
113043: EMPTY
113044: LIST
113045: LIST
113046: PUSH
113047: LD_INT 3
113049: PUSH
113050: LD_INT 23
113052: PUSH
113053: LD_INT 0
113055: PUSH
113056: EMPTY
113057: LIST
113058: LIST
113059: PUSH
113060: EMPTY
113061: LIST
113062: LIST
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: LIST
113068: PPUSH
113069: CALL_OW 69
113073: ST_TO_ADDR
// if not tmp then
113074: LD_VAR 0 1
113078: NOT
113079: IFFALSE 113083
// exit ;
113081: GO 113109
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
113083: LD_VAR 0 1
113087: PUSH
113088: LD_INT 1
113090: PPUSH
113091: LD_VAR 0 1
113095: PPUSH
113096: CALL_OW 12
113100: ARRAY
113101: PPUSH
113102: LD_INT 200
113104: PPUSH
113105: CALL_OW 234
// end ;
113109: PPOPN 1
113111: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
113112: LD_EXP 160
113116: PUSH
113117: LD_EXP 189
113121: AND
113122: IFFALSE 113201
113124: GO 113126
113126: DISABLE
113127: LD_INT 0
113129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
113130: LD_ADDR_VAR 0 1
113134: PUSH
113135: LD_INT 22
113137: PUSH
113138: LD_OWVAR 2
113142: PUSH
113143: EMPTY
113144: LIST
113145: LIST
113146: PUSH
113147: LD_INT 21
113149: PUSH
113150: LD_INT 2
113152: PUSH
113153: EMPTY
113154: LIST
113155: LIST
113156: PUSH
113157: EMPTY
113158: LIST
113159: LIST
113160: PPUSH
113161: CALL_OW 69
113165: ST_TO_ADDR
// if not tmp then
113166: LD_VAR 0 1
113170: NOT
113171: IFFALSE 113175
// exit ;
113173: GO 113201
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
113175: LD_VAR 0 1
113179: PUSH
113180: LD_INT 1
113182: PPUSH
113183: LD_VAR 0 1
113187: PPUSH
113188: CALL_OW 12
113192: ARRAY
113193: PPUSH
113194: LD_INT 60
113196: PPUSH
113197: CALL_OW 234
// end ;
113201: PPOPN 1
113203: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
113204: LD_EXP 160
113208: PUSH
113209: LD_EXP 190
113213: AND
113214: IFFALSE 113313
113216: GO 113218
113218: DISABLE
113219: LD_INT 0
113221: PPUSH
113222: PPUSH
// begin enable ;
113223: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
113224: LD_ADDR_VAR 0 1
113228: PUSH
113229: LD_INT 22
113231: PUSH
113232: LD_OWVAR 2
113236: PUSH
113237: EMPTY
113238: LIST
113239: LIST
113240: PUSH
113241: LD_INT 61
113243: PUSH
113244: EMPTY
113245: LIST
113246: PUSH
113247: LD_INT 33
113249: PUSH
113250: LD_INT 2
113252: PUSH
113253: EMPTY
113254: LIST
113255: LIST
113256: PUSH
113257: EMPTY
113258: LIST
113259: LIST
113260: LIST
113261: PPUSH
113262: CALL_OW 69
113266: ST_TO_ADDR
// if not tmp then
113267: LD_VAR 0 1
113271: NOT
113272: IFFALSE 113276
// exit ;
113274: GO 113313
// for i in tmp do
113276: LD_ADDR_VAR 0 2
113280: PUSH
113281: LD_VAR 0 1
113285: PUSH
113286: FOR_IN
113287: IFFALSE 113311
// if IsControledBy ( i ) then
113289: LD_VAR 0 2
113293: PPUSH
113294: CALL_OW 312
113298: IFFALSE 113309
// ComUnlink ( i ) ;
113300: LD_VAR 0 2
113304: PPUSH
113305: CALL_OW 136
113309: GO 113286
113311: POP
113312: POP
// end ;
113313: PPOPN 2
113315: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
113316: LD_EXP 160
113320: PUSH
113321: LD_EXP 191
113325: AND
113326: IFFALSE 113466
113328: GO 113330
113330: DISABLE
113331: LD_INT 0
113333: PPUSH
113334: PPUSH
// begin ToLua ( displayPowell(); ) ;
113335: LD_STRING displayPowell();
113337: PPUSH
113338: CALL_OW 559
// uc_side := 0 ;
113342: LD_ADDR_OWVAR 20
113346: PUSH
113347: LD_INT 0
113349: ST_TO_ADDR
// uc_nation := 2 ;
113350: LD_ADDR_OWVAR 21
113354: PUSH
113355: LD_INT 2
113357: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
113358: LD_ADDR_OWVAR 37
113362: PUSH
113363: LD_INT 14
113365: ST_TO_ADDR
// vc_engine := engine_siberite ;
113366: LD_ADDR_OWVAR 39
113370: PUSH
113371: LD_INT 3
113373: ST_TO_ADDR
// vc_control := control_apeman ;
113374: LD_ADDR_OWVAR 38
113378: PUSH
113379: LD_INT 5
113381: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
113382: LD_ADDR_OWVAR 40
113386: PUSH
113387: LD_INT 29
113389: ST_TO_ADDR
// un := CreateVehicle ;
113390: LD_ADDR_VAR 0 2
113394: PUSH
113395: CALL_OW 45
113399: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113400: LD_VAR 0 2
113404: PPUSH
113405: LD_INT 1
113407: PPUSH
113408: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
113412: LD_INT 35
113414: PPUSH
113415: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
113419: LD_VAR 0 2
113423: PPUSH
113424: LD_INT 22
113426: PUSH
113427: LD_OWVAR 2
113431: PUSH
113432: EMPTY
113433: LIST
113434: LIST
113435: PPUSH
113436: CALL_OW 69
113440: PPUSH
113441: LD_VAR 0 2
113445: PPUSH
113446: CALL_OW 74
113450: PPUSH
113451: CALL_OW 115
// until IsDead ( un ) ;
113455: LD_VAR 0 2
113459: PPUSH
113460: CALL_OW 301
113464: IFFALSE 113412
// end ;
113466: PPOPN 2
113468: END
// every 0 0$1 trigger StreamModeActive and sStu do
113469: LD_EXP 160
113473: PUSH
113474: LD_EXP 199
113478: AND
113479: IFFALSE 113495
113481: GO 113483
113483: DISABLE
// begin ToLua ( displayStucuk(); ) ;
113484: LD_STRING displayStucuk();
113486: PPUSH
113487: CALL_OW 559
// ResetFog ;
113491: CALL_OW 335
// end ;
113495: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
113496: LD_EXP 160
113500: PUSH
113501: LD_EXP 192
113505: AND
113506: IFFALSE 113647
113508: GO 113510
113510: DISABLE
113511: LD_INT 0
113513: PPUSH
113514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113515: LD_ADDR_VAR 0 2
113519: PUSH
113520: LD_INT 22
113522: PUSH
113523: LD_OWVAR 2
113527: PUSH
113528: EMPTY
113529: LIST
113530: LIST
113531: PUSH
113532: LD_INT 21
113534: PUSH
113535: LD_INT 1
113537: PUSH
113538: EMPTY
113539: LIST
113540: LIST
113541: PUSH
113542: EMPTY
113543: LIST
113544: LIST
113545: PPUSH
113546: CALL_OW 69
113550: ST_TO_ADDR
// if not tmp then
113551: LD_VAR 0 2
113555: NOT
113556: IFFALSE 113560
// exit ;
113558: GO 113647
// un := tmp [ rand ( 1 , tmp ) ] ;
113560: LD_ADDR_VAR 0 1
113564: PUSH
113565: LD_VAR 0 2
113569: PUSH
113570: LD_INT 1
113572: PPUSH
113573: LD_VAR 0 2
113577: PPUSH
113578: CALL_OW 12
113582: ARRAY
113583: ST_TO_ADDR
// SetSide ( un , 0 ) ;
113584: LD_VAR 0 1
113588: PPUSH
113589: LD_INT 0
113591: PPUSH
113592: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
113596: LD_VAR 0 1
113600: PPUSH
113601: LD_OWVAR 3
113605: PUSH
113606: LD_VAR 0 1
113610: DIFF
113611: PPUSH
113612: LD_VAR 0 1
113616: PPUSH
113617: CALL_OW 74
113621: PPUSH
113622: CALL_OW 115
// wait ( 0 0$20 ) ;
113626: LD_INT 700
113628: PPUSH
113629: CALL_OW 67
// SetSide ( un , your_side ) ;
113633: LD_VAR 0 1
113637: PPUSH
113638: LD_OWVAR 2
113642: PPUSH
113643: CALL_OW 235
// end ;
113647: PPOPN 2
113649: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
113650: LD_EXP 160
113654: PUSH
113655: LD_EXP 193
113659: AND
113660: IFFALSE 113766
113662: GO 113664
113664: DISABLE
113665: LD_INT 0
113667: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113668: LD_ADDR_VAR 0 1
113672: PUSH
113673: LD_INT 22
113675: PUSH
113676: LD_OWVAR 2
113680: PUSH
113681: EMPTY
113682: LIST
113683: LIST
113684: PUSH
113685: LD_INT 2
113687: PUSH
113688: LD_INT 30
113690: PUSH
113691: LD_INT 0
113693: PUSH
113694: EMPTY
113695: LIST
113696: LIST
113697: PUSH
113698: LD_INT 30
113700: PUSH
113701: LD_INT 1
113703: PUSH
113704: EMPTY
113705: LIST
113706: LIST
113707: PUSH
113708: EMPTY
113709: LIST
113710: LIST
113711: LIST
113712: PUSH
113713: EMPTY
113714: LIST
113715: LIST
113716: PPUSH
113717: CALL_OW 69
113721: ST_TO_ADDR
// if not depot then
113722: LD_VAR 0 1
113726: NOT
113727: IFFALSE 113731
// exit ;
113729: GO 113766
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
113731: LD_VAR 0 1
113735: PUSH
113736: LD_INT 1
113738: ARRAY
113739: PPUSH
113740: CALL_OW 250
113744: PPUSH
113745: LD_VAR 0 1
113749: PUSH
113750: LD_INT 1
113752: ARRAY
113753: PPUSH
113754: CALL_OW 251
113758: PPUSH
113759: LD_INT 70
113761: PPUSH
113762: CALL_OW 495
// end ;
113766: PPOPN 1
113768: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
113769: LD_EXP 160
113773: PUSH
113774: LD_EXP 194
113778: AND
113779: IFFALSE 113990
113781: GO 113783
113783: DISABLE
113784: LD_INT 0
113786: PPUSH
113787: PPUSH
113788: PPUSH
113789: PPUSH
113790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113791: LD_ADDR_VAR 0 5
113795: PUSH
113796: LD_INT 22
113798: PUSH
113799: LD_OWVAR 2
113803: PUSH
113804: EMPTY
113805: LIST
113806: LIST
113807: PUSH
113808: LD_INT 21
113810: PUSH
113811: LD_INT 1
113813: PUSH
113814: EMPTY
113815: LIST
113816: LIST
113817: PUSH
113818: EMPTY
113819: LIST
113820: LIST
113821: PPUSH
113822: CALL_OW 69
113826: ST_TO_ADDR
// if not tmp then
113827: LD_VAR 0 5
113831: NOT
113832: IFFALSE 113836
// exit ;
113834: GO 113990
// for i in tmp do
113836: LD_ADDR_VAR 0 1
113840: PUSH
113841: LD_VAR 0 5
113845: PUSH
113846: FOR_IN
113847: IFFALSE 113988
// begin d := rand ( 0 , 5 ) ;
113849: LD_ADDR_VAR 0 4
113853: PUSH
113854: LD_INT 0
113856: PPUSH
113857: LD_INT 5
113859: PPUSH
113860: CALL_OW 12
113864: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
113865: LD_ADDR_VAR 0 2
113869: PUSH
113870: LD_VAR 0 1
113874: PPUSH
113875: CALL_OW 250
113879: PPUSH
113880: LD_VAR 0 4
113884: PPUSH
113885: LD_INT 3
113887: PPUSH
113888: LD_INT 12
113890: PPUSH
113891: CALL_OW 12
113895: PPUSH
113896: CALL_OW 272
113900: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
113901: LD_ADDR_VAR 0 3
113905: PUSH
113906: LD_VAR 0 1
113910: PPUSH
113911: CALL_OW 251
113915: PPUSH
113916: LD_VAR 0 4
113920: PPUSH
113921: LD_INT 3
113923: PPUSH
113924: LD_INT 12
113926: PPUSH
113927: CALL_OW 12
113931: PPUSH
113932: CALL_OW 273
113936: ST_TO_ADDR
// if ValidHex ( x , y ) then
113937: LD_VAR 0 2
113941: PPUSH
113942: LD_VAR 0 3
113946: PPUSH
113947: CALL_OW 488
113951: IFFALSE 113986
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
113953: LD_VAR 0 1
113957: PPUSH
113958: LD_VAR 0 2
113962: PPUSH
113963: LD_VAR 0 3
113967: PPUSH
113968: LD_INT 3
113970: PPUSH
113971: LD_INT 6
113973: PPUSH
113974: CALL_OW 12
113978: PPUSH
113979: LD_INT 1
113981: PPUSH
113982: CALL_OW 483
// end ;
113986: GO 113846
113988: POP
113989: POP
// end ;
113990: PPOPN 5
113992: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
113993: LD_EXP 160
113997: PUSH
113998: LD_EXP 195
114002: AND
114003: IFFALSE 114097
114005: GO 114007
114007: DISABLE
114008: LD_INT 0
114010: PPUSH
114011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
114012: LD_ADDR_VAR 0 2
114016: PUSH
114017: LD_INT 22
114019: PUSH
114020: LD_OWVAR 2
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: PUSH
114029: LD_INT 32
114031: PUSH
114032: LD_INT 1
114034: PUSH
114035: EMPTY
114036: LIST
114037: LIST
114038: PUSH
114039: LD_INT 21
114041: PUSH
114042: LD_INT 2
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: PUSH
114049: EMPTY
114050: LIST
114051: LIST
114052: LIST
114053: PPUSH
114054: CALL_OW 69
114058: ST_TO_ADDR
// if not tmp then
114059: LD_VAR 0 2
114063: NOT
114064: IFFALSE 114068
// exit ;
114066: GO 114097
// for i in tmp do
114068: LD_ADDR_VAR 0 1
114072: PUSH
114073: LD_VAR 0 2
114077: PUSH
114078: FOR_IN
114079: IFFALSE 114095
// SetFuel ( i , 0 ) ;
114081: LD_VAR 0 1
114085: PPUSH
114086: LD_INT 0
114088: PPUSH
114089: CALL_OW 240
114093: GO 114078
114095: POP
114096: POP
// end ;
114097: PPOPN 2
114099: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
114100: LD_EXP 160
114104: PUSH
114105: LD_EXP 196
114109: AND
114110: IFFALSE 114176
114112: GO 114114
114114: DISABLE
114115: LD_INT 0
114117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
114118: LD_ADDR_VAR 0 1
114122: PUSH
114123: LD_INT 22
114125: PUSH
114126: LD_OWVAR 2
114130: PUSH
114131: EMPTY
114132: LIST
114133: LIST
114134: PUSH
114135: LD_INT 30
114137: PUSH
114138: LD_INT 29
114140: PUSH
114141: EMPTY
114142: LIST
114143: LIST
114144: PUSH
114145: EMPTY
114146: LIST
114147: LIST
114148: PPUSH
114149: CALL_OW 69
114153: ST_TO_ADDR
// if not tmp then
114154: LD_VAR 0 1
114158: NOT
114159: IFFALSE 114163
// exit ;
114161: GO 114176
// DestroyUnit ( tmp [ 1 ] ) ;
114163: LD_VAR 0 1
114167: PUSH
114168: LD_INT 1
114170: ARRAY
114171: PPUSH
114172: CALL_OW 65
// end ;
114176: PPOPN 1
114178: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
114179: LD_EXP 160
114183: PUSH
114184: LD_EXP 198
114188: AND
114189: IFFALSE 114318
114191: GO 114193
114193: DISABLE
114194: LD_INT 0
114196: PPUSH
// begin uc_side := 0 ;
114197: LD_ADDR_OWVAR 20
114201: PUSH
114202: LD_INT 0
114204: ST_TO_ADDR
// uc_nation := nation_arabian ;
114205: LD_ADDR_OWVAR 21
114209: PUSH
114210: LD_INT 2
114212: ST_TO_ADDR
// hc_gallery :=  ;
114213: LD_ADDR_OWVAR 33
114217: PUSH
114218: LD_STRING 
114220: ST_TO_ADDR
// hc_name :=  ;
114221: LD_ADDR_OWVAR 26
114225: PUSH
114226: LD_STRING 
114228: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
114229: LD_INT 1
114231: PPUSH
114232: LD_INT 11
114234: PPUSH
114235: LD_INT 10
114237: PPUSH
114238: CALL_OW 380
// un := CreateHuman ;
114242: LD_ADDR_VAR 0 1
114246: PUSH
114247: CALL_OW 44
114251: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114252: LD_VAR 0 1
114256: PPUSH
114257: LD_INT 1
114259: PPUSH
114260: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
114264: LD_INT 35
114266: PPUSH
114267: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
114271: LD_VAR 0 1
114275: PPUSH
114276: LD_INT 22
114278: PUSH
114279: LD_OWVAR 2
114283: PUSH
114284: EMPTY
114285: LIST
114286: LIST
114287: PPUSH
114288: CALL_OW 69
114292: PPUSH
114293: LD_VAR 0 1
114297: PPUSH
114298: CALL_OW 74
114302: PPUSH
114303: CALL_OW 115
// until IsDead ( un ) ;
114307: LD_VAR 0 1
114311: PPUSH
114312: CALL_OW 301
114316: IFFALSE 114264
// end ;
114318: PPOPN 1
114320: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
114321: LD_EXP 160
114325: PUSH
114326: LD_EXP 200
114330: AND
114331: IFFALSE 114343
114333: GO 114335
114335: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
114336: LD_STRING earthquake(getX(game), 0, 32)
114338: PPUSH
114339: CALL_OW 559
114343: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
114344: LD_EXP 160
114348: PUSH
114349: LD_EXP 201
114353: AND
114354: IFFALSE 114445
114356: GO 114358
114358: DISABLE
114359: LD_INT 0
114361: PPUSH
// begin enable ;
114362: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
114363: LD_ADDR_VAR 0 1
114367: PUSH
114368: LD_INT 22
114370: PUSH
114371: LD_OWVAR 2
114375: PUSH
114376: EMPTY
114377: LIST
114378: LIST
114379: PUSH
114380: LD_INT 21
114382: PUSH
114383: LD_INT 2
114385: PUSH
114386: EMPTY
114387: LIST
114388: LIST
114389: PUSH
114390: LD_INT 33
114392: PUSH
114393: LD_INT 3
114395: PUSH
114396: EMPTY
114397: LIST
114398: LIST
114399: PUSH
114400: EMPTY
114401: LIST
114402: LIST
114403: LIST
114404: PPUSH
114405: CALL_OW 69
114409: ST_TO_ADDR
// if not tmp then
114410: LD_VAR 0 1
114414: NOT
114415: IFFALSE 114419
// exit ;
114417: GO 114445
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114419: LD_VAR 0 1
114423: PUSH
114424: LD_INT 1
114426: PPUSH
114427: LD_VAR 0 1
114431: PPUSH
114432: CALL_OW 12
114436: ARRAY
114437: PPUSH
114438: LD_INT 1
114440: PPUSH
114441: CALL_OW 234
// end ;
114445: PPOPN 1
114447: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
114448: LD_EXP 160
114452: PUSH
114453: LD_EXP 202
114457: AND
114458: IFFALSE 114599
114460: GO 114462
114462: DISABLE
114463: LD_INT 0
114465: PPUSH
114466: PPUSH
114467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114468: LD_ADDR_VAR 0 3
114472: PUSH
114473: LD_INT 22
114475: PUSH
114476: LD_OWVAR 2
114480: PUSH
114481: EMPTY
114482: LIST
114483: LIST
114484: PUSH
114485: LD_INT 25
114487: PUSH
114488: LD_INT 1
114490: PUSH
114491: EMPTY
114492: LIST
114493: LIST
114494: PUSH
114495: EMPTY
114496: LIST
114497: LIST
114498: PPUSH
114499: CALL_OW 69
114503: ST_TO_ADDR
// if not tmp then
114504: LD_VAR 0 3
114508: NOT
114509: IFFALSE 114513
// exit ;
114511: GO 114599
// un := tmp [ rand ( 1 , tmp ) ] ;
114513: LD_ADDR_VAR 0 2
114517: PUSH
114518: LD_VAR 0 3
114522: PUSH
114523: LD_INT 1
114525: PPUSH
114526: LD_VAR 0 3
114530: PPUSH
114531: CALL_OW 12
114535: ARRAY
114536: ST_TO_ADDR
// if Crawls ( un ) then
114537: LD_VAR 0 2
114541: PPUSH
114542: CALL_OW 318
114546: IFFALSE 114557
// ComWalk ( un ) ;
114548: LD_VAR 0 2
114552: PPUSH
114553: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
114557: LD_VAR 0 2
114561: PPUSH
114562: LD_INT 9
114564: PPUSH
114565: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
114569: LD_INT 28
114571: PPUSH
114572: LD_OWVAR 2
114576: PPUSH
114577: LD_INT 2
114579: PPUSH
114580: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
114584: LD_INT 29
114586: PPUSH
114587: LD_OWVAR 2
114591: PPUSH
114592: LD_INT 2
114594: PPUSH
114595: CALL_OW 322
// end ;
114599: PPOPN 3
114601: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
114602: LD_EXP 160
114606: PUSH
114607: LD_EXP 203
114611: AND
114612: IFFALSE 114723
114614: GO 114616
114616: DISABLE
114617: LD_INT 0
114619: PPUSH
114620: PPUSH
114621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114622: LD_ADDR_VAR 0 3
114626: PUSH
114627: LD_INT 22
114629: PUSH
114630: LD_OWVAR 2
114634: PUSH
114635: EMPTY
114636: LIST
114637: LIST
114638: PUSH
114639: LD_INT 25
114641: PUSH
114642: LD_INT 1
114644: PUSH
114645: EMPTY
114646: LIST
114647: LIST
114648: PUSH
114649: EMPTY
114650: LIST
114651: LIST
114652: PPUSH
114653: CALL_OW 69
114657: ST_TO_ADDR
// if not tmp then
114658: LD_VAR 0 3
114662: NOT
114663: IFFALSE 114667
// exit ;
114665: GO 114723
// un := tmp [ rand ( 1 , tmp ) ] ;
114667: LD_ADDR_VAR 0 2
114671: PUSH
114672: LD_VAR 0 3
114676: PUSH
114677: LD_INT 1
114679: PPUSH
114680: LD_VAR 0 3
114684: PPUSH
114685: CALL_OW 12
114689: ARRAY
114690: ST_TO_ADDR
// if Crawls ( un ) then
114691: LD_VAR 0 2
114695: PPUSH
114696: CALL_OW 318
114700: IFFALSE 114711
// ComWalk ( un ) ;
114702: LD_VAR 0 2
114706: PPUSH
114707: CALL_OW 138
// SetClass ( un , class_mortar ) ;
114711: LD_VAR 0 2
114715: PPUSH
114716: LD_INT 8
114718: PPUSH
114719: CALL_OW 336
// end ;
114723: PPOPN 3
114725: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
114726: LD_EXP 160
114730: PUSH
114731: LD_EXP 204
114735: AND
114736: IFFALSE 114880
114738: GO 114740
114740: DISABLE
114741: LD_INT 0
114743: PPUSH
114744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
114745: LD_ADDR_VAR 0 2
114749: PUSH
114750: LD_INT 22
114752: PUSH
114753: LD_OWVAR 2
114757: PUSH
114758: EMPTY
114759: LIST
114760: LIST
114761: PUSH
114762: LD_INT 21
114764: PUSH
114765: LD_INT 2
114767: PUSH
114768: EMPTY
114769: LIST
114770: LIST
114771: PUSH
114772: LD_INT 2
114774: PUSH
114775: LD_INT 34
114777: PUSH
114778: LD_INT 12
114780: PUSH
114781: EMPTY
114782: LIST
114783: LIST
114784: PUSH
114785: LD_INT 34
114787: PUSH
114788: LD_INT 51
114790: PUSH
114791: EMPTY
114792: LIST
114793: LIST
114794: PUSH
114795: LD_INT 34
114797: PUSH
114798: LD_INT 32
114800: PUSH
114801: EMPTY
114802: LIST
114803: LIST
114804: PUSH
114805: EMPTY
114806: LIST
114807: LIST
114808: LIST
114809: LIST
114810: PUSH
114811: EMPTY
114812: LIST
114813: LIST
114814: LIST
114815: PPUSH
114816: CALL_OW 69
114820: ST_TO_ADDR
// if not tmp then
114821: LD_VAR 0 2
114825: NOT
114826: IFFALSE 114830
// exit ;
114828: GO 114880
// for i in tmp do
114830: LD_ADDR_VAR 0 1
114834: PUSH
114835: LD_VAR 0 2
114839: PUSH
114840: FOR_IN
114841: IFFALSE 114878
// if GetCargo ( i , mat_artifact ) = 0 then
114843: LD_VAR 0 1
114847: PPUSH
114848: LD_INT 4
114850: PPUSH
114851: CALL_OW 289
114855: PUSH
114856: LD_INT 0
114858: EQUAL
114859: IFFALSE 114876
// SetCargo ( i , mat_siberit , 100 ) ;
114861: LD_VAR 0 1
114865: PPUSH
114866: LD_INT 3
114868: PPUSH
114869: LD_INT 100
114871: PPUSH
114872: CALL_OW 290
114876: GO 114840
114878: POP
114879: POP
// end ;
114880: PPOPN 2
114882: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
114883: LD_EXP 160
114887: PUSH
114888: LD_EXP 205
114892: AND
114893: IFFALSE 115076
114895: GO 114897
114897: DISABLE
114898: LD_INT 0
114900: PPUSH
114901: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
114902: LD_ADDR_VAR 0 2
114906: PUSH
114907: LD_INT 22
114909: PUSH
114910: LD_OWVAR 2
114914: PUSH
114915: EMPTY
114916: LIST
114917: LIST
114918: PPUSH
114919: CALL_OW 69
114923: ST_TO_ADDR
// if not tmp then
114924: LD_VAR 0 2
114928: NOT
114929: IFFALSE 114933
// exit ;
114931: GO 115076
// for i := 1 to 2 do
114933: LD_ADDR_VAR 0 1
114937: PUSH
114938: DOUBLE
114939: LD_INT 1
114941: DEC
114942: ST_TO_ADDR
114943: LD_INT 2
114945: PUSH
114946: FOR_TO
114947: IFFALSE 115074
// begin uc_side := your_side ;
114949: LD_ADDR_OWVAR 20
114953: PUSH
114954: LD_OWVAR 2
114958: ST_TO_ADDR
// uc_nation := nation_american ;
114959: LD_ADDR_OWVAR 21
114963: PUSH
114964: LD_INT 1
114966: ST_TO_ADDR
// vc_chassis := us_morphling ;
114967: LD_ADDR_OWVAR 37
114971: PUSH
114972: LD_INT 5
114974: ST_TO_ADDR
// vc_engine := engine_siberite ;
114975: LD_ADDR_OWVAR 39
114979: PUSH
114980: LD_INT 3
114982: ST_TO_ADDR
// vc_control := control_computer ;
114983: LD_ADDR_OWVAR 38
114987: PUSH
114988: LD_INT 3
114990: ST_TO_ADDR
// vc_weapon := us_double_laser ;
114991: LD_ADDR_OWVAR 40
114995: PUSH
114996: LD_INT 10
114998: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
114999: LD_VAR 0 2
115003: PUSH
115004: LD_INT 1
115006: ARRAY
115007: PPUSH
115008: CALL_OW 310
115012: NOT
115013: IFFALSE 115060
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
115015: CALL_OW 45
115019: PPUSH
115020: LD_VAR 0 2
115024: PUSH
115025: LD_INT 1
115027: ARRAY
115028: PPUSH
115029: CALL_OW 250
115033: PPUSH
115034: LD_VAR 0 2
115038: PUSH
115039: LD_INT 1
115041: ARRAY
115042: PPUSH
115043: CALL_OW 251
115047: PPUSH
115048: LD_INT 12
115050: PPUSH
115051: LD_INT 1
115053: PPUSH
115054: CALL_OW 50
115058: GO 115072
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
115060: CALL_OW 45
115064: PPUSH
115065: LD_INT 1
115067: PPUSH
115068: CALL_OW 51
// end ;
115072: GO 114946
115074: POP
115075: POP
// end ;
115076: PPOPN 2
115078: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
115079: LD_EXP 160
115083: PUSH
115084: LD_EXP 206
115088: AND
115089: IFFALSE 115311
115091: GO 115093
115093: DISABLE
115094: LD_INT 0
115096: PPUSH
115097: PPUSH
115098: PPUSH
115099: PPUSH
115100: PPUSH
115101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115102: LD_ADDR_VAR 0 6
115106: PUSH
115107: LD_INT 22
115109: PUSH
115110: LD_OWVAR 2
115114: PUSH
115115: EMPTY
115116: LIST
115117: LIST
115118: PUSH
115119: LD_INT 21
115121: PUSH
115122: LD_INT 1
115124: PUSH
115125: EMPTY
115126: LIST
115127: LIST
115128: PUSH
115129: LD_INT 3
115131: PUSH
115132: LD_INT 23
115134: PUSH
115135: LD_INT 0
115137: PUSH
115138: EMPTY
115139: LIST
115140: LIST
115141: PUSH
115142: EMPTY
115143: LIST
115144: LIST
115145: PUSH
115146: EMPTY
115147: LIST
115148: LIST
115149: LIST
115150: PPUSH
115151: CALL_OW 69
115155: ST_TO_ADDR
// if not tmp then
115156: LD_VAR 0 6
115160: NOT
115161: IFFALSE 115165
// exit ;
115163: GO 115311
// s1 := rand ( 1 , 4 ) ;
115165: LD_ADDR_VAR 0 2
115169: PUSH
115170: LD_INT 1
115172: PPUSH
115173: LD_INT 4
115175: PPUSH
115176: CALL_OW 12
115180: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
115181: LD_ADDR_VAR 0 4
115185: PUSH
115186: LD_VAR 0 6
115190: PUSH
115191: LD_INT 1
115193: ARRAY
115194: PPUSH
115195: LD_VAR 0 2
115199: PPUSH
115200: CALL_OW 259
115204: ST_TO_ADDR
// if s1 = 1 then
115205: LD_VAR 0 2
115209: PUSH
115210: LD_INT 1
115212: EQUAL
115213: IFFALSE 115233
// s2 := rand ( 2 , 4 ) else
115215: LD_ADDR_VAR 0 3
115219: PUSH
115220: LD_INT 2
115222: PPUSH
115223: LD_INT 4
115225: PPUSH
115226: CALL_OW 12
115230: ST_TO_ADDR
115231: GO 115241
// s2 := 1 ;
115233: LD_ADDR_VAR 0 3
115237: PUSH
115238: LD_INT 1
115240: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
115241: LD_ADDR_VAR 0 5
115245: PUSH
115246: LD_VAR 0 6
115250: PUSH
115251: LD_INT 1
115253: ARRAY
115254: PPUSH
115255: LD_VAR 0 3
115259: PPUSH
115260: CALL_OW 259
115264: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
115265: LD_VAR 0 6
115269: PUSH
115270: LD_INT 1
115272: ARRAY
115273: PPUSH
115274: LD_VAR 0 2
115278: PPUSH
115279: LD_VAR 0 5
115283: PPUSH
115284: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
115288: LD_VAR 0 6
115292: PUSH
115293: LD_INT 1
115295: ARRAY
115296: PPUSH
115297: LD_VAR 0 3
115301: PPUSH
115302: LD_VAR 0 4
115306: PPUSH
115307: CALL_OW 237
// end ;
115311: PPOPN 6
115313: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
115314: LD_EXP 160
115318: PUSH
115319: LD_EXP 207
115323: AND
115324: IFFALSE 115403
115326: GO 115328
115328: DISABLE
115329: LD_INT 0
115331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
115332: LD_ADDR_VAR 0 1
115336: PUSH
115337: LD_INT 22
115339: PUSH
115340: LD_OWVAR 2
115344: PUSH
115345: EMPTY
115346: LIST
115347: LIST
115348: PUSH
115349: LD_INT 30
115351: PUSH
115352: LD_INT 3
115354: PUSH
115355: EMPTY
115356: LIST
115357: LIST
115358: PUSH
115359: EMPTY
115360: LIST
115361: LIST
115362: PPUSH
115363: CALL_OW 69
115367: ST_TO_ADDR
// if not tmp then
115368: LD_VAR 0 1
115372: NOT
115373: IFFALSE 115377
// exit ;
115375: GO 115403
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
115377: LD_VAR 0 1
115381: PUSH
115382: LD_INT 1
115384: PPUSH
115385: LD_VAR 0 1
115389: PPUSH
115390: CALL_OW 12
115394: ARRAY
115395: PPUSH
115396: LD_INT 1
115398: PPUSH
115399: CALL_OW 234
// end ;
115403: PPOPN 1
115405: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
115406: LD_EXP 160
115410: PUSH
115411: LD_EXP 208
115415: AND
115416: IFFALSE 115528
115418: GO 115420
115420: DISABLE
115421: LD_INT 0
115423: PPUSH
115424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
115425: LD_ADDR_VAR 0 2
115429: PUSH
115430: LD_INT 22
115432: PUSH
115433: LD_OWVAR 2
115437: PUSH
115438: EMPTY
115439: LIST
115440: LIST
115441: PUSH
115442: LD_INT 2
115444: PUSH
115445: LD_INT 30
115447: PUSH
115448: LD_INT 27
115450: PUSH
115451: EMPTY
115452: LIST
115453: LIST
115454: PUSH
115455: LD_INT 30
115457: PUSH
115458: LD_INT 26
115460: PUSH
115461: EMPTY
115462: LIST
115463: LIST
115464: PUSH
115465: LD_INT 30
115467: PUSH
115468: LD_INT 28
115470: PUSH
115471: EMPTY
115472: LIST
115473: LIST
115474: PUSH
115475: EMPTY
115476: LIST
115477: LIST
115478: LIST
115479: LIST
115480: PUSH
115481: EMPTY
115482: LIST
115483: LIST
115484: PPUSH
115485: CALL_OW 69
115489: ST_TO_ADDR
// if not tmp then
115490: LD_VAR 0 2
115494: NOT
115495: IFFALSE 115499
// exit ;
115497: GO 115528
// for i in tmp do
115499: LD_ADDR_VAR 0 1
115503: PUSH
115504: LD_VAR 0 2
115508: PUSH
115509: FOR_IN
115510: IFFALSE 115526
// SetLives ( i , 1 ) ;
115512: LD_VAR 0 1
115516: PPUSH
115517: LD_INT 1
115519: PPUSH
115520: CALL_OW 234
115524: GO 115509
115526: POP
115527: POP
// end ;
115528: PPOPN 2
115530: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
115531: LD_EXP 160
115535: PUSH
115536: LD_EXP 209
115540: AND
115541: IFFALSE 115815
115543: GO 115545
115545: DISABLE
115546: LD_INT 0
115548: PPUSH
115549: PPUSH
115550: PPUSH
// begin i := rand ( 1 , 7 ) ;
115551: LD_ADDR_VAR 0 1
115555: PUSH
115556: LD_INT 1
115558: PPUSH
115559: LD_INT 7
115561: PPUSH
115562: CALL_OW 12
115566: ST_TO_ADDR
// case i of 1 :
115567: LD_VAR 0 1
115571: PUSH
115572: LD_INT 1
115574: DOUBLE
115575: EQUAL
115576: IFTRUE 115580
115578: GO 115590
115580: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
115581: LD_STRING earthquake(getX(game), 0, 32)
115583: PPUSH
115584: CALL_OW 559
115588: GO 115815
115590: LD_INT 2
115592: DOUBLE
115593: EQUAL
115594: IFTRUE 115598
115596: GO 115612
115598: POP
// begin ToLua ( displayStucuk(); ) ;
115599: LD_STRING displayStucuk();
115601: PPUSH
115602: CALL_OW 559
// ResetFog ;
115606: CALL_OW 335
// end ; 3 :
115610: GO 115815
115612: LD_INT 3
115614: DOUBLE
115615: EQUAL
115616: IFTRUE 115620
115618: GO 115724
115620: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115621: LD_ADDR_VAR 0 2
115625: PUSH
115626: LD_INT 22
115628: PUSH
115629: LD_OWVAR 2
115633: PUSH
115634: EMPTY
115635: LIST
115636: LIST
115637: PUSH
115638: LD_INT 25
115640: PUSH
115641: LD_INT 1
115643: PUSH
115644: EMPTY
115645: LIST
115646: LIST
115647: PUSH
115648: EMPTY
115649: LIST
115650: LIST
115651: PPUSH
115652: CALL_OW 69
115656: ST_TO_ADDR
// if not tmp then
115657: LD_VAR 0 2
115661: NOT
115662: IFFALSE 115666
// exit ;
115664: GO 115815
// un := tmp [ rand ( 1 , tmp ) ] ;
115666: LD_ADDR_VAR 0 3
115670: PUSH
115671: LD_VAR 0 2
115675: PUSH
115676: LD_INT 1
115678: PPUSH
115679: LD_VAR 0 2
115683: PPUSH
115684: CALL_OW 12
115688: ARRAY
115689: ST_TO_ADDR
// if Crawls ( un ) then
115690: LD_VAR 0 3
115694: PPUSH
115695: CALL_OW 318
115699: IFFALSE 115710
// ComWalk ( un ) ;
115701: LD_VAR 0 3
115705: PPUSH
115706: CALL_OW 138
// SetClass ( un , class_mortar ) ;
115710: LD_VAR 0 3
115714: PPUSH
115715: LD_INT 8
115717: PPUSH
115718: CALL_OW 336
// end ; 4 :
115722: GO 115815
115724: LD_INT 4
115726: DOUBLE
115727: EQUAL
115728: IFTRUE 115732
115730: GO 115793
115732: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
115733: LD_ADDR_VAR 0 2
115737: PUSH
115738: LD_INT 22
115740: PUSH
115741: LD_OWVAR 2
115745: PUSH
115746: EMPTY
115747: LIST
115748: LIST
115749: PUSH
115750: LD_INT 30
115752: PUSH
115753: LD_INT 29
115755: PUSH
115756: EMPTY
115757: LIST
115758: LIST
115759: PUSH
115760: EMPTY
115761: LIST
115762: LIST
115763: PPUSH
115764: CALL_OW 69
115768: ST_TO_ADDR
// if not tmp then
115769: LD_VAR 0 2
115773: NOT
115774: IFFALSE 115778
// exit ;
115776: GO 115815
// DestroyUnit ( tmp [ 1 ] ) ;
115778: LD_VAR 0 2
115782: PUSH
115783: LD_INT 1
115785: ARRAY
115786: PPUSH
115787: CALL_OW 65
// end ; 5 .. 7 :
115791: GO 115815
115793: LD_INT 5
115795: DOUBLE
115796: GREATEREQUAL
115797: IFFALSE 115805
115799: LD_INT 7
115801: DOUBLE
115802: LESSEQUAL
115803: IFTRUE 115807
115805: GO 115814
115807: POP
// StreamSibBomb ; end ;
115808: CALL 112065 0 0
115812: GO 115815
115814: POP
// end ;
115815: PPOPN 3
115817: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
115818: LD_EXP 160
115822: PUSH
115823: LD_EXP 210
115827: AND
115828: IFFALSE 115984
115830: GO 115832
115832: DISABLE
115833: LD_INT 0
115835: PPUSH
115836: PPUSH
115837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
115838: LD_ADDR_VAR 0 2
115842: PUSH
115843: LD_INT 81
115845: PUSH
115846: LD_OWVAR 2
115850: PUSH
115851: EMPTY
115852: LIST
115853: LIST
115854: PUSH
115855: LD_INT 2
115857: PUSH
115858: LD_INT 21
115860: PUSH
115861: LD_INT 1
115863: PUSH
115864: EMPTY
115865: LIST
115866: LIST
115867: PUSH
115868: LD_INT 21
115870: PUSH
115871: LD_INT 2
115873: PUSH
115874: EMPTY
115875: LIST
115876: LIST
115877: PUSH
115878: EMPTY
115879: LIST
115880: LIST
115881: LIST
115882: PUSH
115883: EMPTY
115884: LIST
115885: LIST
115886: PPUSH
115887: CALL_OW 69
115891: ST_TO_ADDR
// if not tmp then
115892: LD_VAR 0 2
115896: NOT
115897: IFFALSE 115901
// exit ;
115899: GO 115984
// p := 0 ;
115901: LD_ADDR_VAR 0 3
115905: PUSH
115906: LD_INT 0
115908: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
115909: LD_INT 35
115911: PPUSH
115912: CALL_OW 67
// p := p + 1 ;
115916: LD_ADDR_VAR 0 3
115920: PUSH
115921: LD_VAR 0 3
115925: PUSH
115926: LD_INT 1
115928: PLUS
115929: ST_TO_ADDR
// for i in tmp do
115930: LD_ADDR_VAR 0 1
115934: PUSH
115935: LD_VAR 0 2
115939: PUSH
115940: FOR_IN
115941: IFFALSE 115972
// if GetLives ( i ) < 1000 then
115943: LD_VAR 0 1
115947: PPUSH
115948: CALL_OW 256
115952: PUSH
115953: LD_INT 1000
115955: LESS
115956: IFFALSE 115970
// SetLives ( i , 1000 ) ;
115958: LD_VAR 0 1
115962: PPUSH
115963: LD_INT 1000
115965: PPUSH
115966: CALL_OW 234
115970: GO 115940
115972: POP
115973: POP
// until p > 20 ;
115974: LD_VAR 0 3
115978: PUSH
115979: LD_INT 20
115981: GREATER
115982: IFFALSE 115909
// end ;
115984: PPOPN 3
115986: END
// every 0 0$1 trigger StreamModeActive and sTime do
115987: LD_EXP 160
115991: PUSH
115992: LD_EXP 211
115996: AND
115997: IFFALSE 116032
115999: GO 116001
116001: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
116002: LD_INT 28
116004: PPUSH
116005: LD_OWVAR 2
116009: PPUSH
116010: LD_INT 2
116012: PPUSH
116013: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
116017: LD_INT 30
116019: PPUSH
116020: LD_OWVAR 2
116024: PPUSH
116025: LD_INT 2
116027: PPUSH
116028: CALL_OW 322
// end ;
116032: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
116033: LD_EXP 160
116037: PUSH
116038: LD_EXP 212
116042: AND
116043: IFFALSE 116164
116045: GO 116047
116047: DISABLE
116048: LD_INT 0
116050: PPUSH
116051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
116052: LD_ADDR_VAR 0 2
116056: PUSH
116057: LD_INT 22
116059: PUSH
116060: LD_OWVAR 2
116064: PUSH
116065: EMPTY
116066: LIST
116067: LIST
116068: PUSH
116069: LD_INT 21
116071: PUSH
116072: LD_INT 1
116074: PUSH
116075: EMPTY
116076: LIST
116077: LIST
116078: PUSH
116079: LD_INT 3
116081: PUSH
116082: LD_INT 23
116084: PUSH
116085: LD_INT 0
116087: PUSH
116088: EMPTY
116089: LIST
116090: LIST
116091: PUSH
116092: EMPTY
116093: LIST
116094: LIST
116095: PUSH
116096: EMPTY
116097: LIST
116098: LIST
116099: LIST
116100: PPUSH
116101: CALL_OW 69
116105: ST_TO_ADDR
// if not tmp then
116106: LD_VAR 0 2
116110: NOT
116111: IFFALSE 116115
// exit ;
116113: GO 116164
// for i in tmp do
116115: LD_ADDR_VAR 0 1
116119: PUSH
116120: LD_VAR 0 2
116124: PUSH
116125: FOR_IN
116126: IFFALSE 116162
// begin if Crawls ( i ) then
116128: LD_VAR 0 1
116132: PPUSH
116133: CALL_OW 318
116137: IFFALSE 116148
// ComWalk ( i ) ;
116139: LD_VAR 0 1
116143: PPUSH
116144: CALL_OW 138
// SetClass ( i , 2 ) ;
116148: LD_VAR 0 1
116152: PPUSH
116153: LD_INT 2
116155: PPUSH
116156: CALL_OW 336
// end ;
116160: GO 116125
116162: POP
116163: POP
// end ;
116164: PPOPN 2
116166: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
116167: LD_EXP 160
116171: PUSH
116172: LD_EXP 213
116176: AND
116177: IFFALSE 116458
116179: GO 116181
116181: DISABLE
116182: LD_INT 0
116184: PPUSH
116185: PPUSH
116186: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
116187: LD_OWVAR 2
116191: PPUSH
116192: LD_INT 9
116194: PPUSH
116195: LD_INT 1
116197: PPUSH
116198: LD_INT 1
116200: PPUSH
116201: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
116205: LD_INT 9
116207: PPUSH
116208: LD_OWVAR 2
116212: PPUSH
116213: CALL_OW 343
// uc_side := 9 ;
116217: LD_ADDR_OWVAR 20
116221: PUSH
116222: LD_INT 9
116224: ST_TO_ADDR
// uc_nation := 2 ;
116225: LD_ADDR_OWVAR 21
116229: PUSH
116230: LD_INT 2
116232: ST_TO_ADDR
// hc_name := Dark Warrior ;
116233: LD_ADDR_OWVAR 26
116237: PUSH
116238: LD_STRING Dark Warrior
116240: ST_TO_ADDR
// hc_gallery :=  ;
116241: LD_ADDR_OWVAR 33
116245: PUSH
116246: LD_STRING 
116248: ST_TO_ADDR
// hc_noskilllimit := true ;
116249: LD_ADDR_OWVAR 76
116253: PUSH
116254: LD_INT 1
116256: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
116257: LD_ADDR_OWVAR 31
116261: PUSH
116262: LD_INT 30
116264: PUSH
116265: LD_INT 30
116267: PUSH
116268: LD_INT 30
116270: PUSH
116271: LD_INT 30
116273: PUSH
116274: EMPTY
116275: LIST
116276: LIST
116277: LIST
116278: LIST
116279: ST_TO_ADDR
// un := CreateHuman ;
116280: LD_ADDR_VAR 0 3
116284: PUSH
116285: CALL_OW 44
116289: ST_TO_ADDR
// hc_noskilllimit := false ;
116290: LD_ADDR_OWVAR 76
116294: PUSH
116295: LD_INT 0
116297: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116298: LD_VAR 0 3
116302: PPUSH
116303: LD_INT 1
116305: PPUSH
116306: CALL_OW 51
// p := 0 ;
116310: LD_ADDR_VAR 0 2
116314: PUSH
116315: LD_INT 0
116317: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116318: LD_INT 35
116320: PPUSH
116321: CALL_OW 67
// p := p + 1 ;
116325: LD_ADDR_VAR 0 2
116329: PUSH
116330: LD_VAR 0 2
116334: PUSH
116335: LD_INT 1
116337: PLUS
116338: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
116339: LD_VAR 0 3
116343: PPUSH
116344: CALL_OW 256
116348: PUSH
116349: LD_INT 1000
116351: LESS
116352: IFFALSE 116366
// SetLives ( un , 1000 ) ;
116354: LD_VAR 0 3
116358: PPUSH
116359: LD_INT 1000
116361: PPUSH
116362: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
116366: LD_VAR 0 3
116370: PPUSH
116371: LD_INT 81
116373: PUSH
116374: LD_OWVAR 2
116378: PUSH
116379: EMPTY
116380: LIST
116381: LIST
116382: PUSH
116383: LD_INT 91
116385: PUSH
116386: LD_VAR 0 3
116390: PUSH
116391: LD_INT 30
116393: PUSH
116394: EMPTY
116395: LIST
116396: LIST
116397: LIST
116398: PUSH
116399: EMPTY
116400: LIST
116401: LIST
116402: PPUSH
116403: CALL_OW 69
116407: PPUSH
116408: LD_VAR 0 3
116412: PPUSH
116413: CALL_OW 74
116417: PPUSH
116418: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
116422: LD_VAR 0 2
116426: PUSH
116427: LD_INT 60
116429: GREATER
116430: PUSH
116431: LD_VAR 0 3
116435: PPUSH
116436: CALL_OW 301
116440: OR
116441: IFFALSE 116318
// if un then
116443: LD_VAR 0 3
116447: IFFALSE 116458
// RemoveUnit ( un ) ;
116449: LD_VAR 0 3
116453: PPUSH
116454: CALL_OW 64
// end ;
116458: PPOPN 3
116460: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
116461: LD_INT 0
116463: PPUSH
// case cmd of 301 :
116464: LD_VAR 0 1
116468: PUSH
116469: LD_INT 301
116471: DOUBLE
116472: EQUAL
116473: IFTRUE 116477
116475: GO 116509
116477: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
116478: LD_VAR 0 6
116482: PPUSH
116483: LD_VAR 0 7
116487: PPUSH
116488: LD_VAR 0 8
116492: PPUSH
116493: LD_VAR 0 4
116497: PPUSH
116498: LD_VAR 0 5
116502: PPUSH
116503: CALL 117710 0 5
116507: GO 116630
116509: LD_INT 302
116511: DOUBLE
116512: EQUAL
116513: IFTRUE 116517
116515: GO 116554
116517: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
116518: LD_VAR 0 6
116522: PPUSH
116523: LD_VAR 0 7
116527: PPUSH
116528: LD_VAR 0 8
116532: PPUSH
116533: LD_VAR 0 9
116537: PPUSH
116538: LD_VAR 0 4
116542: PPUSH
116543: LD_VAR 0 5
116547: PPUSH
116548: CALL 117801 0 6
116552: GO 116630
116554: LD_INT 303
116556: DOUBLE
116557: EQUAL
116558: IFTRUE 116562
116560: GO 116599
116562: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
116563: LD_VAR 0 6
116567: PPUSH
116568: LD_VAR 0 7
116572: PPUSH
116573: LD_VAR 0 8
116577: PPUSH
116578: LD_VAR 0 9
116582: PPUSH
116583: LD_VAR 0 4
116587: PPUSH
116588: LD_VAR 0 5
116592: PPUSH
116593: CALL 116635 0 6
116597: GO 116630
116599: LD_INT 304
116601: DOUBLE
116602: EQUAL
116603: IFTRUE 116607
116605: GO 116629
116607: POP
// hHackTeleport ( unit , x , y ) ; end ;
116608: LD_VAR 0 2
116612: PPUSH
116613: LD_VAR 0 4
116617: PPUSH
116618: LD_VAR 0 5
116622: PPUSH
116623: CALL 118394 0 3
116627: GO 116630
116629: POP
// end ;
116630: LD_VAR 0 12
116634: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
116635: LD_INT 0
116637: PPUSH
116638: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
116639: LD_VAR 0 1
116643: PUSH
116644: LD_INT 1
116646: LESS
116647: PUSH
116648: LD_VAR 0 1
116652: PUSH
116653: LD_INT 3
116655: GREATER
116656: OR
116657: PUSH
116658: LD_VAR 0 5
116662: PPUSH
116663: LD_VAR 0 6
116667: PPUSH
116668: CALL_OW 428
116672: OR
116673: IFFALSE 116677
// exit ;
116675: GO 117397
// uc_side := your_side ;
116677: LD_ADDR_OWVAR 20
116681: PUSH
116682: LD_OWVAR 2
116686: ST_TO_ADDR
// uc_nation := nation ;
116687: LD_ADDR_OWVAR 21
116691: PUSH
116692: LD_VAR 0 1
116696: ST_TO_ADDR
// bc_level = 1 ;
116697: LD_ADDR_OWVAR 43
116701: PUSH
116702: LD_INT 1
116704: ST_TO_ADDR
// case btype of 1 :
116705: LD_VAR 0 2
116709: PUSH
116710: LD_INT 1
116712: DOUBLE
116713: EQUAL
116714: IFTRUE 116718
116716: GO 116729
116718: POP
// bc_type := b_depot ; 2 :
116719: LD_ADDR_OWVAR 42
116723: PUSH
116724: LD_INT 0
116726: ST_TO_ADDR
116727: GO 117341
116729: LD_INT 2
116731: DOUBLE
116732: EQUAL
116733: IFTRUE 116737
116735: GO 116748
116737: POP
// bc_type := b_warehouse ; 3 :
116738: LD_ADDR_OWVAR 42
116742: PUSH
116743: LD_INT 1
116745: ST_TO_ADDR
116746: GO 117341
116748: LD_INT 3
116750: DOUBLE
116751: EQUAL
116752: IFTRUE 116756
116754: GO 116767
116756: POP
// bc_type := b_lab ; 4 .. 9 :
116757: LD_ADDR_OWVAR 42
116761: PUSH
116762: LD_INT 6
116764: ST_TO_ADDR
116765: GO 117341
116767: LD_INT 4
116769: DOUBLE
116770: GREATEREQUAL
116771: IFFALSE 116779
116773: LD_INT 9
116775: DOUBLE
116776: LESSEQUAL
116777: IFTRUE 116781
116779: GO 116833
116781: POP
// begin bc_type := b_lab_half ;
116782: LD_ADDR_OWVAR 42
116786: PUSH
116787: LD_INT 7
116789: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
116790: LD_ADDR_OWVAR 44
116794: PUSH
116795: LD_INT 10
116797: PUSH
116798: LD_INT 11
116800: PUSH
116801: LD_INT 12
116803: PUSH
116804: LD_INT 15
116806: PUSH
116807: LD_INT 14
116809: PUSH
116810: LD_INT 13
116812: PUSH
116813: EMPTY
116814: LIST
116815: LIST
116816: LIST
116817: LIST
116818: LIST
116819: LIST
116820: PUSH
116821: LD_VAR 0 2
116825: PUSH
116826: LD_INT 3
116828: MINUS
116829: ARRAY
116830: ST_TO_ADDR
// end ; 10 .. 13 :
116831: GO 117341
116833: LD_INT 10
116835: DOUBLE
116836: GREATEREQUAL
116837: IFFALSE 116845
116839: LD_INT 13
116841: DOUBLE
116842: LESSEQUAL
116843: IFTRUE 116847
116845: GO 116924
116847: POP
// begin bc_type := b_lab_full ;
116848: LD_ADDR_OWVAR 42
116852: PUSH
116853: LD_INT 8
116855: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
116856: LD_ADDR_OWVAR 44
116860: PUSH
116861: LD_INT 10
116863: PUSH
116864: LD_INT 12
116866: PUSH
116867: LD_INT 14
116869: PUSH
116870: LD_INT 13
116872: PUSH
116873: EMPTY
116874: LIST
116875: LIST
116876: LIST
116877: LIST
116878: PUSH
116879: LD_VAR 0 2
116883: PUSH
116884: LD_INT 9
116886: MINUS
116887: ARRAY
116888: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
116889: LD_ADDR_OWVAR 45
116893: PUSH
116894: LD_INT 11
116896: PUSH
116897: LD_INT 15
116899: PUSH
116900: LD_INT 12
116902: PUSH
116903: LD_INT 15
116905: PUSH
116906: EMPTY
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: PUSH
116912: LD_VAR 0 2
116916: PUSH
116917: LD_INT 9
116919: MINUS
116920: ARRAY
116921: ST_TO_ADDR
// end ; 14 :
116922: GO 117341
116924: LD_INT 14
116926: DOUBLE
116927: EQUAL
116928: IFTRUE 116932
116930: GO 116943
116932: POP
// bc_type := b_workshop ; 15 :
116933: LD_ADDR_OWVAR 42
116937: PUSH
116938: LD_INT 2
116940: ST_TO_ADDR
116941: GO 117341
116943: LD_INT 15
116945: DOUBLE
116946: EQUAL
116947: IFTRUE 116951
116949: GO 116962
116951: POP
// bc_type := b_factory ; 16 :
116952: LD_ADDR_OWVAR 42
116956: PUSH
116957: LD_INT 3
116959: ST_TO_ADDR
116960: GO 117341
116962: LD_INT 16
116964: DOUBLE
116965: EQUAL
116966: IFTRUE 116970
116968: GO 116981
116970: POP
// bc_type := b_ext_gun ; 17 :
116971: LD_ADDR_OWVAR 42
116975: PUSH
116976: LD_INT 17
116978: ST_TO_ADDR
116979: GO 117341
116981: LD_INT 17
116983: DOUBLE
116984: EQUAL
116985: IFTRUE 116989
116987: GO 117017
116989: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
116990: LD_ADDR_OWVAR 42
116994: PUSH
116995: LD_INT 19
116997: PUSH
116998: LD_INT 23
117000: PUSH
117001: LD_INT 19
117003: PUSH
117004: EMPTY
117005: LIST
117006: LIST
117007: LIST
117008: PUSH
117009: LD_VAR 0 1
117013: ARRAY
117014: ST_TO_ADDR
117015: GO 117341
117017: LD_INT 18
117019: DOUBLE
117020: EQUAL
117021: IFTRUE 117025
117023: GO 117036
117025: POP
// bc_type := b_ext_radar ; 19 :
117026: LD_ADDR_OWVAR 42
117030: PUSH
117031: LD_INT 20
117033: ST_TO_ADDR
117034: GO 117341
117036: LD_INT 19
117038: DOUBLE
117039: EQUAL
117040: IFTRUE 117044
117042: GO 117055
117044: POP
// bc_type := b_ext_radio ; 20 :
117045: LD_ADDR_OWVAR 42
117049: PUSH
117050: LD_INT 22
117052: ST_TO_ADDR
117053: GO 117341
117055: LD_INT 20
117057: DOUBLE
117058: EQUAL
117059: IFTRUE 117063
117061: GO 117074
117063: POP
// bc_type := b_ext_siberium ; 21 :
117064: LD_ADDR_OWVAR 42
117068: PUSH
117069: LD_INT 21
117071: ST_TO_ADDR
117072: GO 117341
117074: LD_INT 21
117076: DOUBLE
117077: EQUAL
117078: IFTRUE 117082
117080: GO 117093
117082: POP
// bc_type := b_ext_computer ; 22 :
117083: LD_ADDR_OWVAR 42
117087: PUSH
117088: LD_INT 24
117090: ST_TO_ADDR
117091: GO 117341
117093: LD_INT 22
117095: DOUBLE
117096: EQUAL
117097: IFTRUE 117101
117099: GO 117112
117101: POP
// bc_type := b_ext_track ; 23 :
117102: LD_ADDR_OWVAR 42
117106: PUSH
117107: LD_INT 16
117109: ST_TO_ADDR
117110: GO 117341
117112: LD_INT 23
117114: DOUBLE
117115: EQUAL
117116: IFTRUE 117120
117118: GO 117131
117120: POP
// bc_type := b_ext_laser ; 24 :
117121: LD_ADDR_OWVAR 42
117125: PUSH
117126: LD_INT 25
117128: ST_TO_ADDR
117129: GO 117341
117131: LD_INT 24
117133: DOUBLE
117134: EQUAL
117135: IFTRUE 117139
117137: GO 117150
117139: POP
// bc_type := b_control_tower ; 25 :
117140: LD_ADDR_OWVAR 42
117144: PUSH
117145: LD_INT 36
117147: ST_TO_ADDR
117148: GO 117341
117150: LD_INT 25
117152: DOUBLE
117153: EQUAL
117154: IFTRUE 117158
117156: GO 117169
117158: POP
// bc_type := b_breastwork ; 26 :
117159: LD_ADDR_OWVAR 42
117163: PUSH
117164: LD_INT 31
117166: ST_TO_ADDR
117167: GO 117341
117169: LD_INT 26
117171: DOUBLE
117172: EQUAL
117173: IFTRUE 117177
117175: GO 117188
117177: POP
// bc_type := b_bunker ; 27 :
117178: LD_ADDR_OWVAR 42
117182: PUSH
117183: LD_INT 32
117185: ST_TO_ADDR
117186: GO 117341
117188: LD_INT 27
117190: DOUBLE
117191: EQUAL
117192: IFTRUE 117196
117194: GO 117207
117196: POP
// bc_type := b_turret ; 28 :
117197: LD_ADDR_OWVAR 42
117201: PUSH
117202: LD_INT 33
117204: ST_TO_ADDR
117205: GO 117341
117207: LD_INT 28
117209: DOUBLE
117210: EQUAL
117211: IFTRUE 117215
117213: GO 117226
117215: POP
// bc_type := b_armoury ; 29 :
117216: LD_ADDR_OWVAR 42
117220: PUSH
117221: LD_INT 4
117223: ST_TO_ADDR
117224: GO 117341
117226: LD_INT 29
117228: DOUBLE
117229: EQUAL
117230: IFTRUE 117234
117232: GO 117245
117234: POP
// bc_type := b_barracks ; 30 :
117235: LD_ADDR_OWVAR 42
117239: PUSH
117240: LD_INT 5
117242: ST_TO_ADDR
117243: GO 117341
117245: LD_INT 30
117247: DOUBLE
117248: EQUAL
117249: IFTRUE 117253
117251: GO 117264
117253: POP
// bc_type := b_solar_power ; 31 :
117254: LD_ADDR_OWVAR 42
117258: PUSH
117259: LD_INT 27
117261: ST_TO_ADDR
117262: GO 117341
117264: LD_INT 31
117266: DOUBLE
117267: EQUAL
117268: IFTRUE 117272
117270: GO 117283
117272: POP
// bc_type := b_oil_power ; 32 :
117273: LD_ADDR_OWVAR 42
117277: PUSH
117278: LD_INT 26
117280: ST_TO_ADDR
117281: GO 117341
117283: LD_INT 32
117285: DOUBLE
117286: EQUAL
117287: IFTRUE 117291
117289: GO 117302
117291: POP
// bc_type := b_siberite_power ; 33 :
117292: LD_ADDR_OWVAR 42
117296: PUSH
117297: LD_INT 28
117299: ST_TO_ADDR
117300: GO 117341
117302: LD_INT 33
117304: DOUBLE
117305: EQUAL
117306: IFTRUE 117310
117308: GO 117321
117310: POP
// bc_type := b_oil_mine ; 34 :
117311: LD_ADDR_OWVAR 42
117315: PUSH
117316: LD_INT 29
117318: ST_TO_ADDR
117319: GO 117341
117321: LD_INT 34
117323: DOUBLE
117324: EQUAL
117325: IFTRUE 117329
117327: GO 117340
117329: POP
// bc_type := b_siberite_mine ; end ;
117330: LD_ADDR_OWVAR 42
117334: PUSH
117335: LD_INT 30
117337: ST_TO_ADDR
117338: GO 117341
117340: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
117341: LD_ADDR_VAR 0 8
117345: PUSH
117346: LD_VAR 0 5
117350: PPUSH
117351: LD_VAR 0 6
117355: PPUSH
117356: LD_VAR 0 3
117360: PPUSH
117361: CALL_OW 47
117365: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
117366: LD_OWVAR 42
117370: PUSH
117371: LD_INT 32
117373: PUSH
117374: LD_INT 33
117376: PUSH
117377: EMPTY
117378: LIST
117379: LIST
117380: IN
117381: IFFALSE 117397
// PlaceWeaponTurret ( b , weapon ) ;
117383: LD_VAR 0 8
117387: PPUSH
117388: LD_VAR 0 4
117392: PPUSH
117393: CALL_OW 431
// end ;
117397: LD_VAR 0 7
117401: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
117402: LD_INT 0
117404: PPUSH
117405: PPUSH
117406: PPUSH
117407: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117408: LD_ADDR_VAR 0 4
117412: PUSH
117413: LD_INT 22
117415: PUSH
117416: LD_OWVAR 2
117420: PUSH
117421: EMPTY
117422: LIST
117423: LIST
117424: PUSH
117425: LD_INT 2
117427: PUSH
117428: LD_INT 30
117430: PUSH
117431: LD_INT 0
117433: PUSH
117434: EMPTY
117435: LIST
117436: LIST
117437: PUSH
117438: LD_INT 30
117440: PUSH
117441: LD_INT 1
117443: PUSH
117444: EMPTY
117445: LIST
117446: LIST
117447: PUSH
117448: EMPTY
117449: LIST
117450: LIST
117451: LIST
117452: PUSH
117453: EMPTY
117454: LIST
117455: LIST
117456: PPUSH
117457: CALL_OW 69
117461: ST_TO_ADDR
// if not tmp then
117462: LD_VAR 0 4
117466: NOT
117467: IFFALSE 117471
// exit ;
117469: GO 117530
// for i in tmp do
117471: LD_ADDR_VAR 0 2
117475: PUSH
117476: LD_VAR 0 4
117480: PUSH
117481: FOR_IN
117482: IFFALSE 117528
// for j = 1 to 3 do
117484: LD_ADDR_VAR 0 3
117488: PUSH
117489: DOUBLE
117490: LD_INT 1
117492: DEC
117493: ST_TO_ADDR
117494: LD_INT 3
117496: PUSH
117497: FOR_TO
117498: IFFALSE 117524
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
117500: LD_VAR 0 2
117504: PPUSH
117505: CALL_OW 274
117509: PPUSH
117510: LD_VAR 0 3
117514: PPUSH
117515: LD_INT 99999
117517: PPUSH
117518: CALL_OW 277
117522: GO 117497
117524: POP
117525: POP
117526: GO 117481
117528: POP
117529: POP
// end ;
117530: LD_VAR 0 1
117534: RET
// export function hHackSetLevel10 ; var i , j ; begin
117535: LD_INT 0
117537: PPUSH
117538: PPUSH
117539: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
117540: LD_ADDR_VAR 0 2
117544: PUSH
117545: LD_INT 21
117547: PUSH
117548: LD_INT 1
117550: PUSH
117551: EMPTY
117552: LIST
117553: LIST
117554: PPUSH
117555: CALL_OW 69
117559: PUSH
117560: FOR_IN
117561: IFFALSE 117613
// if IsSelected ( i ) then
117563: LD_VAR 0 2
117567: PPUSH
117568: CALL_OW 306
117572: IFFALSE 117611
// begin for j := 1 to 4 do
117574: LD_ADDR_VAR 0 3
117578: PUSH
117579: DOUBLE
117580: LD_INT 1
117582: DEC
117583: ST_TO_ADDR
117584: LD_INT 4
117586: PUSH
117587: FOR_TO
117588: IFFALSE 117609
// SetSkill ( i , j , 10 ) ;
117590: LD_VAR 0 2
117594: PPUSH
117595: LD_VAR 0 3
117599: PPUSH
117600: LD_INT 10
117602: PPUSH
117603: CALL_OW 237
117607: GO 117587
117609: POP
117610: POP
// end ;
117611: GO 117560
117613: POP
117614: POP
// end ;
117615: LD_VAR 0 1
117619: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
117620: LD_INT 0
117622: PPUSH
117623: PPUSH
117624: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
117625: LD_ADDR_VAR 0 2
117629: PUSH
117630: LD_INT 22
117632: PUSH
117633: LD_OWVAR 2
117637: PUSH
117638: EMPTY
117639: LIST
117640: LIST
117641: PUSH
117642: LD_INT 21
117644: PUSH
117645: LD_INT 1
117647: PUSH
117648: EMPTY
117649: LIST
117650: LIST
117651: PUSH
117652: EMPTY
117653: LIST
117654: LIST
117655: PPUSH
117656: CALL_OW 69
117660: PUSH
117661: FOR_IN
117662: IFFALSE 117703
// begin for j := 1 to 4 do
117664: LD_ADDR_VAR 0 3
117668: PUSH
117669: DOUBLE
117670: LD_INT 1
117672: DEC
117673: ST_TO_ADDR
117674: LD_INT 4
117676: PUSH
117677: FOR_TO
117678: IFFALSE 117699
// SetSkill ( i , j , 10 ) ;
117680: LD_VAR 0 2
117684: PPUSH
117685: LD_VAR 0 3
117689: PPUSH
117690: LD_INT 10
117692: PPUSH
117693: CALL_OW 237
117697: GO 117677
117699: POP
117700: POP
// end ;
117701: GO 117661
117703: POP
117704: POP
// end ;
117705: LD_VAR 0 1
117709: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
117710: LD_INT 0
117712: PPUSH
// uc_side := your_side ;
117713: LD_ADDR_OWVAR 20
117717: PUSH
117718: LD_OWVAR 2
117722: ST_TO_ADDR
// uc_nation := nation ;
117723: LD_ADDR_OWVAR 21
117727: PUSH
117728: LD_VAR 0 1
117732: ST_TO_ADDR
// InitHc ;
117733: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
117737: LD_INT 0
117739: PPUSH
117740: LD_VAR 0 2
117744: PPUSH
117745: LD_VAR 0 3
117749: PPUSH
117750: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
117754: LD_VAR 0 4
117758: PPUSH
117759: LD_VAR 0 5
117763: PPUSH
117764: CALL_OW 428
117768: PUSH
117769: LD_INT 0
117771: EQUAL
117772: IFFALSE 117796
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
117774: CALL_OW 44
117778: PPUSH
117779: LD_VAR 0 4
117783: PPUSH
117784: LD_VAR 0 5
117788: PPUSH
117789: LD_INT 1
117791: PPUSH
117792: CALL_OW 48
// end ;
117796: LD_VAR 0 6
117800: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
117801: LD_INT 0
117803: PPUSH
117804: PPUSH
// uc_side := your_side ;
117805: LD_ADDR_OWVAR 20
117809: PUSH
117810: LD_OWVAR 2
117814: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
117815: LD_VAR 0 1
117819: PUSH
117820: LD_INT 1
117822: PUSH
117823: LD_INT 2
117825: PUSH
117826: LD_INT 3
117828: PUSH
117829: LD_INT 4
117831: PUSH
117832: LD_INT 5
117834: PUSH
117835: EMPTY
117836: LIST
117837: LIST
117838: LIST
117839: LIST
117840: LIST
117841: IN
117842: IFFALSE 117854
// uc_nation := nation_american else
117844: LD_ADDR_OWVAR 21
117848: PUSH
117849: LD_INT 1
117851: ST_TO_ADDR
117852: GO 117897
// if chassis in [ 11 , 12 , 13 , 14 ] then
117854: LD_VAR 0 1
117858: PUSH
117859: LD_INT 11
117861: PUSH
117862: LD_INT 12
117864: PUSH
117865: LD_INT 13
117867: PUSH
117868: LD_INT 14
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: LIST
117875: LIST
117876: IN
117877: IFFALSE 117889
// uc_nation := nation_arabian else
117879: LD_ADDR_OWVAR 21
117883: PUSH
117884: LD_INT 2
117886: ST_TO_ADDR
117887: GO 117897
// uc_nation := nation_russian ;
117889: LD_ADDR_OWVAR 21
117893: PUSH
117894: LD_INT 3
117896: ST_TO_ADDR
// vc_chassis := chassis ;
117897: LD_ADDR_OWVAR 37
117901: PUSH
117902: LD_VAR 0 1
117906: ST_TO_ADDR
// vc_engine := engine ;
117907: LD_ADDR_OWVAR 39
117911: PUSH
117912: LD_VAR 0 2
117916: ST_TO_ADDR
// vc_control := control ;
117917: LD_ADDR_OWVAR 38
117921: PUSH
117922: LD_VAR 0 3
117926: ST_TO_ADDR
// vc_weapon := weapon ;
117927: LD_ADDR_OWVAR 40
117931: PUSH
117932: LD_VAR 0 4
117936: ST_TO_ADDR
// un := CreateVehicle ;
117937: LD_ADDR_VAR 0 8
117941: PUSH
117942: CALL_OW 45
117946: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
117947: LD_VAR 0 8
117951: PPUSH
117952: LD_INT 0
117954: PPUSH
117955: LD_INT 5
117957: PPUSH
117958: CALL_OW 12
117962: PPUSH
117963: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
117967: LD_VAR 0 8
117971: PPUSH
117972: LD_VAR 0 5
117976: PPUSH
117977: LD_VAR 0 6
117981: PPUSH
117982: LD_INT 1
117984: PPUSH
117985: CALL_OW 48
// end ;
117989: LD_VAR 0 7
117993: RET
// export hInvincible ; every 1 do
117994: GO 117996
117996: DISABLE
// hInvincible := [ ] ;
117997: LD_ADDR_EXP 214
118001: PUSH
118002: EMPTY
118003: ST_TO_ADDR
118004: END
// every 10 do var i ;
118005: GO 118007
118007: DISABLE
118008: LD_INT 0
118010: PPUSH
// begin enable ;
118011: ENABLE
// if not hInvincible then
118012: LD_EXP 214
118016: NOT
118017: IFFALSE 118021
// exit ;
118019: GO 118065
// for i in hInvincible do
118021: LD_ADDR_VAR 0 1
118025: PUSH
118026: LD_EXP 214
118030: PUSH
118031: FOR_IN
118032: IFFALSE 118063
// if GetLives ( i ) < 1000 then
118034: LD_VAR 0 1
118038: PPUSH
118039: CALL_OW 256
118043: PUSH
118044: LD_INT 1000
118046: LESS
118047: IFFALSE 118061
// SetLives ( i , 1000 ) ;
118049: LD_VAR 0 1
118053: PPUSH
118054: LD_INT 1000
118056: PPUSH
118057: CALL_OW 234
118061: GO 118031
118063: POP
118064: POP
// end ;
118065: PPOPN 1
118067: END
// export function hHackInvincible ; var i ; begin
118068: LD_INT 0
118070: PPUSH
118071: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
118072: LD_ADDR_VAR 0 2
118076: PUSH
118077: LD_INT 2
118079: PUSH
118080: LD_INT 21
118082: PUSH
118083: LD_INT 1
118085: PUSH
118086: EMPTY
118087: LIST
118088: LIST
118089: PUSH
118090: LD_INT 21
118092: PUSH
118093: LD_INT 2
118095: PUSH
118096: EMPTY
118097: LIST
118098: LIST
118099: PUSH
118100: EMPTY
118101: LIST
118102: LIST
118103: LIST
118104: PPUSH
118105: CALL_OW 69
118109: PUSH
118110: FOR_IN
118111: IFFALSE 118172
// if IsSelected ( i ) then
118113: LD_VAR 0 2
118117: PPUSH
118118: CALL_OW 306
118122: IFFALSE 118170
// begin if i in hInvincible then
118124: LD_VAR 0 2
118128: PUSH
118129: LD_EXP 214
118133: IN
118134: IFFALSE 118154
// hInvincible := hInvincible diff i else
118136: LD_ADDR_EXP 214
118140: PUSH
118141: LD_EXP 214
118145: PUSH
118146: LD_VAR 0 2
118150: DIFF
118151: ST_TO_ADDR
118152: GO 118170
// hInvincible := hInvincible union i ;
118154: LD_ADDR_EXP 214
118158: PUSH
118159: LD_EXP 214
118163: PUSH
118164: LD_VAR 0 2
118168: UNION
118169: ST_TO_ADDR
// end ;
118170: GO 118110
118172: POP
118173: POP
// end ;
118174: LD_VAR 0 1
118178: RET
// export function hHackInvisible ; var i , j ; begin
118179: LD_INT 0
118181: PPUSH
118182: PPUSH
118183: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
118184: LD_ADDR_VAR 0 2
118188: PUSH
118189: LD_INT 21
118191: PUSH
118192: LD_INT 1
118194: PUSH
118195: EMPTY
118196: LIST
118197: LIST
118198: PPUSH
118199: CALL_OW 69
118203: PUSH
118204: FOR_IN
118205: IFFALSE 118229
// if IsSelected ( i ) then
118207: LD_VAR 0 2
118211: PPUSH
118212: CALL_OW 306
118216: IFFALSE 118227
// ComForceInvisible ( i ) ;
118218: LD_VAR 0 2
118222: PPUSH
118223: CALL_OW 496
118227: GO 118204
118229: POP
118230: POP
// end ;
118231: LD_VAR 0 1
118235: RET
// export function hHackChangeYourSide ; begin
118236: LD_INT 0
118238: PPUSH
// if your_side = 8 then
118239: LD_OWVAR 2
118243: PUSH
118244: LD_INT 8
118246: EQUAL
118247: IFFALSE 118259
// your_side := 0 else
118249: LD_ADDR_OWVAR 2
118253: PUSH
118254: LD_INT 0
118256: ST_TO_ADDR
118257: GO 118273
// your_side := your_side + 1 ;
118259: LD_ADDR_OWVAR 2
118263: PUSH
118264: LD_OWVAR 2
118268: PUSH
118269: LD_INT 1
118271: PLUS
118272: ST_TO_ADDR
// end ;
118273: LD_VAR 0 1
118277: RET
// export function hHackChangeUnitSide ; var i , j ; begin
118278: LD_INT 0
118280: PPUSH
118281: PPUSH
118282: PPUSH
// for i in all_units do
118283: LD_ADDR_VAR 0 2
118287: PUSH
118288: LD_OWVAR 3
118292: PUSH
118293: FOR_IN
118294: IFFALSE 118372
// if IsSelected ( i ) then
118296: LD_VAR 0 2
118300: PPUSH
118301: CALL_OW 306
118305: IFFALSE 118370
// begin j := GetSide ( i ) ;
118307: LD_ADDR_VAR 0 3
118311: PUSH
118312: LD_VAR 0 2
118316: PPUSH
118317: CALL_OW 255
118321: ST_TO_ADDR
// if j = 8 then
118322: LD_VAR 0 3
118326: PUSH
118327: LD_INT 8
118329: EQUAL
118330: IFFALSE 118342
// j := 0 else
118332: LD_ADDR_VAR 0 3
118336: PUSH
118337: LD_INT 0
118339: ST_TO_ADDR
118340: GO 118356
// j := j + 1 ;
118342: LD_ADDR_VAR 0 3
118346: PUSH
118347: LD_VAR 0 3
118351: PUSH
118352: LD_INT 1
118354: PLUS
118355: ST_TO_ADDR
// SetSide ( i , j ) ;
118356: LD_VAR 0 2
118360: PPUSH
118361: LD_VAR 0 3
118365: PPUSH
118366: CALL_OW 235
// end ;
118370: GO 118293
118372: POP
118373: POP
// end ;
118374: LD_VAR 0 1
118378: RET
// export function hHackFog ; begin
118379: LD_INT 0
118381: PPUSH
// FogOff ( true ) ;
118382: LD_INT 1
118384: PPUSH
118385: CALL_OW 344
// end ;
118389: LD_VAR 0 1
118393: RET
// export function hHackTeleport ( unit , x , y ) ; begin
118394: LD_INT 0
118396: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
118397: LD_VAR 0 1
118401: PPUSH
118402: LD_VAR 0 2
118406: PPUSH
118407: LD_VAR 0 3
118411: PPUSH
118412: LD_INT 1
118414: PPUSH
118415: LD_INT 1
118417: PPUSH
118418: CALL_OW 483
// CenterOnXY ( x , y ) ;
118422: LD_VAR 0 2
118426: PPUSH
118427: LD_VAR 0 3
118431: PPUSH
118432: CALL_OW 84
// end ; end_of_file
118436: LD_VAR 0 4
118440: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
118441: LD_INT 0
118443: PPUSH
118444: PPUSH
118445: PPUSH
118446: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118447: LD_VAR 0 1
118451: PPUSH
118452: CALL_OW 264
118456: PUSH
118457: LD_EXP 99
118461: EQUAL
118462: IFFALSE 118534
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
118464: LD_INT 68
118466: PPUSH
118467: LD_VAR 0 1
118471: PPUSH
118472: CALL_OW 255
118476: PPUSH
118477: CALL_OW 321
118481: PUSH
118482: LD_INT 2
118484: EQUAL
118485: IFFALSE 118497
// eff := 70 else
118487: LD_ADDR_VAR 0 4
118491: PUSH
118492: LD_INT 70
118494: ST_TO_ADDR
118495: GO 118505
// eff := 30 ;
118497: LD_ADDR_VAR 0 4
118501: PUSH
118502: LD_INT 30
118504: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
118505: LD_VAR 0 1
118509: PPUSH
118510: CALL_OW 250
118514: PPUSH
118515: LD_VAR 0 1
118519: PPUSH
118520: CALL_OW 251
118524: PPUSH
118525: LD_VAR 0 4
118529: PPUSH
118530: CALL_OW 495
// end ; end ;
118534: LD_VAR 0 2
118538: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
118539: LD_INT 0
118541: PPUSH
// end ;
118542: LD_VAR 0 4
118546: RET
// export function SOS_Command ( cmd ) ; begin
118547: LD_INT 0
118549: PPUSH
// end ;
118550: LD_VAR 0 2
118554: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
118555: LD_INT 0
118557: PPUSH
// if cmd = 121 then
118558: LD_VAR 0 1
118562: PUSH
118563: LD_INT 121
118565: EQUAL
118566: IFFALSE 118568
// end ;
118568: LD_VAR 0 6
118572: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
118573: LD_INT 0
118575: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
118576: LD_VAR 0 1
118580: PUSH
118581: LD_INT 250
118583: EQUAL
118584: PUSH
118585: LD_VAR 0 2
118589: PPUSH
118590: CALL_OW 264
118594: PUSH
118595: LD_EXP 102
118599: EQUAL
118600: AND
118601: IFFALSE 118622
// MinerPlaceMine ( unit , x , y ) ;
118603: LD_VAR 0 2
118607: PPUSH
118608: LD_VAR 0 4
118612: PPUSH
118613: LD_VAR 0 5
118617: PPUSH
118618: CALL 120971 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
118622: LD_VAR 0 1
118626: PUSH
118627: LD_INT 251
118629: EQUAL
118630: PUSH
118631: LD_VAR 0 2
118635: PPUSH
118636: CALL_OW 264
118640: PUSH
118641: LD_EXP 102
118645: EQUAL
118646: AND
118647: IFFALSE 118668
// MinerDetonateMine ( unit , x , y ) ;
118649: LD_VAR 0 2
118653: PPUSH
118654: LD_VAR 0 4
118658: PPUSH
118659: LD_VAR 0 5
118663: PPUSH
118664: CALL 121248 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
118668: LD_VAR 0 1
118672: PUSH
118673: LD_INT 252
118675: EQUAL
118676: PUSH
118677: LD_VAR 0 2
118681: PPUSH
118682: CALL_OW 264
118686: PUSH
118687: LD_EXP 102
118691: EQUAL
118692: AND
118693: IFFALSE 118714
// MinerCreateMinefield ( unit , x , y ) ;
118695: LD_VAR 0 2
118699: PPUSH
118700: LD_VAR 0 4
118704: PPUSH
118705: LD_VAR 0 5
118709: PPUSH
118710: CALL 121665 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
118714: LD_VAR 0 1
118718: PUSH
118719: LD_INT 253
118721: EQUAL
118722: PUSH
118723: LD_VAR 0 2
118727: PPUSH
118728: CALL_OW 257
118732: PUSH
118733: LD_INT 5
118735: EQUAL
118736: AND
118737: IFFALSE 118758
// ComBinocular ( unit , x , y ) ;
118739: LD_VAR 0 2
118743: PPUSH
118744: LD_VAR 0 4
118748: PPUSH
118749: LD_VAR 0 5
118753: PPUSH
118754: CALL 122036 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
118758: LD_VAR 0 1
118762: PUSH
118763: LD_INT 254
118765: EQUAL
118766: PUSH
118767: LD_VAR 0 2
118771: PPUSH
118772: CALL_OW 264
118776: PUSH
118777: LD_EXP 97
118781: EQUAL
118782: AND
118783: PUSH
118784: LD_VAR 0 3
118788: PPUSH
118789: CALL_OW 263
118793: PUSH
118794: LD_INT 3
118796: EQUAL
118797: AND
118798: IFFALSE 118814
// HackDestroyVehicle ( unit , selectedUnit ) ;
118800: LD_VAR 0 2
118804: PPUSH
118805: LD_VAR 0 3
118809: PPUSH
118810: CALL 120331 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
118814: LD_VAR 0 1
118818: PUSH
118819: LD_INT 255
118821: EQUAL
118822: PUSH
118823: LD_VAR 0 2
118827: PPUSH
118828: CALL_OW 264
118832: PUSH
118833: LD_INT 14
118835: PUSH
118836: LD_INT 53
118838: PUSH
118839: EMPTY
118840: LIST
118841: LIST
118842: IN
118843: AND
118844: PUSH
118845: LD_VAR 0 4
118849: PPUSH
118850: LD_VAR 0 5
118854: PPUSH
118855: CALL_OW 488
118859: AND
118860: IFFALSE 118884
// CutTreeXYR ( unit , x , y , 12 ) ;
118862: LD_VAR 0 2
118866: PPUSH
118867: LD_VAR 0 4
118871: PPUSH
118872: LD_VAR 0 5
118876: PPUSH
118877: LD_INT 12
118879: PPUSH
118880: CALL 118897 0 4
// end ;
118884: LD_VAR 0 6
118888: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
118889: LD_INT 0
118891: PPUSH
// end ;
118892: LD_VAR 0 4
118896: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
118897: LD_INT 0
118899: PPUSH
118900: PPUSH
118901: PPUSH
118902: PPUSH
118903: PPUSH
118904: PPUSH
118905: PPUSH
118906: PPUSH
118907: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
118908: LD_VAR 0 1
118912: NOT
118913: PUSH
118914: LD_VAR 0 2
118918: PPUSH
118919: LD_VAR 0 3
118923: PPUSH
118924: CALL_OW 488
118928: NOT
118929: OR
118930: PUSH
118931: LD_VAR 0 4
118935: NOT
118936: OR
118937: IFFALSE 118941
// exit ;
118939: GO 119281
// list := [ ] ;
118941: LD_ADDR_VAR 0 13
118945: PUSH
118946: EMPTY
118947: ST_TO_ADDR
// if x - r < 0 then
118948: LD_VAR 0 2
118952: PUSH
118953: LD_VAR 0 4
118957: MINUS
118958: PUSH
118959: LD_INT 0
118961: LESS
118962: IFFALSE 118974
// min_x := 0 else
118964: LD_ADDR_VAR 0 7
118968: PUSH
118969: LD_INT 0
118971: ST_TO_ADDR
118972: GO 118990
// min_x := x - r ;
118974: LD_ADDR_VAR 0 7
118978: PUSH
118979: LD_VAR 0 2
118983: PUSH
118984: LD_VAR 0 4
118988: MINUS
118989: ST_TO_ADDR
// if y - r < 0 then
118990: LD_VAR 0 3
118994: PUSH
118995: LD_VAR 0 4
118999: MINUS
119000: PUSH
119001: LD_INT 0
119003: LESS
119004: IFFALSE 119016
// min_y := 0 else
119006: LD_ADDR_VAR 0 8
119010: PUSH
119011: LD_INT 0
119013: ST_TO_ADDR
119014: GO 119032
// min_y := y - r ;
119016: LD_ADDR_VAR 0 8
119020: PUSH
119021: LD_VAR 0 3
119025: PUSH
119026: LD_VAR 0 4
119030: MINUS
119031: ST_TO_ADDR
// max_x := x + r ;
119032: LD_ADDR_VAR 0 9
119036: PUSH
119037: LD_VAR 0 2
119041: PUSH
119042: LD_VAR 0 4
119046: PLUS
119047: ST_TO_ADDR
// max_y := y + r ;
119048: LD_ADDR_VAR 0 10
119052: PUSH
119053: LD_VAR 0 3
119057: PUSH
119058: LD_VAR 0 4
119062: PLUS
119063: ST_TO_ADDR
// for _x = min_x to max_x do
119064: LD_ADDR_VAR 0 11
119068: PUSH
119069: DOUBLE
119070: LD_VAR 0 7
119074: DEC
119075: ST_TO_ADDR
119076: LD_VAR 0 9
119080: PUSH
119081: FOR_TO
119082: IFFALSE 119199
// for _y = min_y to max_y do
119084: LD_ADDR_VAR 0 12
119088: PUSH
119089: DOUBLE
119090: LD_VAR 0 8
119094: DEC
119095: ST_TO_ADDR
119096: LD_VAR 0 10
119100: PUSH
119101: FOR_TO
119102: IFFALSE 119195
// begin if not ValidHex ( _x , _y ) then
119104: LD_VAR 0 11
119108: PPUSH
119109: LD_VAR 0 12
119113: PPUSH
119114: CALL_OW 488
119118: NOT
119119: IFFALSE 119123
// continue ;
119121: GO 119101
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119123: LD_VAR 0 11
119127: PPUSH
119128: LD_VAR 0 12
119132: PPUSH
119133: CALL_OW 351
119137: PUSH
119138: LD_VAR 0 11
119142: PPUSH
119143: LD_VAR 0 12
119147: PPUSH
119148: CALL_OW 554
119152: AND
119153: IFFALSE 119193
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119155: LD_ADDR_VAR 0 13
119159: PUSH
119160: LD_VAR 0 13
119164: PPUSH
119165: LD_VAR 0 13
119169: PUSH
119170: LD_INT 1
119172: PLUS
119173: PPUSH
119174: LD_VAR 0 11
119178: PUSH
119179: LD_VAR 0 12
119183: PUSH
119184: EMPTY
119185: LIST
119186: LIST
119187: PPUSH
119188: CALL_OW 2
119192: ST_TO_ADDR
// end ;
119193: GO 119101
119195: POP
119196: POP
119197: GO 119081
119199: POP
119200: POP
// if not list then
119201: LD_VAR 0 13
119205: NOT
119206: IFFALSE 119210
// exit ;
119208: GO 119281
// for i in list do
119210: LD_ADDR_VAR 0 6
119214: PUSH
119215: LD_VAR 0 13
119219: PUSH
119220: FOR_IN
119221: IFFALSE 119279
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119223: LD_VAR 0 1
119227: PPUSH
119228: LD_STRING M
119230: PUSH
119231: LD_VAR 0 6
119235: PUSH
119236: LD_INT 1
119238: ARRAY
119239: PUSH
119240: LD_VAR 0 6
119244: PUSH
119245: LD_INT 2
119247: ARRAY
119248: PUSH
119249: LD_INT 0
119251: PUSH
119252: LD_INT 0
119254: PUSH
119255: LD_INT 0
119257: PUSH
119258: LD_INT 0
119260: PUSH
119261: EMPTY
119262: LIST
119263: LIST
119264: LIST
119265: LIST
119266: LIST
119267: LIST
119268: LIST
119269: PUSH
119270: EMPTY
119271: LIST
119272: PPUSH
119273: CALL_OW 447
119277: GO 119220
119279: POP
119280: POP
// end ;
119281: LD_VAR 0 5
119285: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
119286: LD_EXP 217
119290: NOT
119291: IFFALSE 119341
119293: GO 119295
119295: DISABLE
// begin initHack := true ;
119296: LD_ADDR_EXP 217
119300: PUSH
119301: LD_INT 1
119303: ST_TO_ADDR
// hackTanks := [ ] ;
119304: LD_ADDR_EXP 218
119308: PUSH
119309: EMPTY
119310: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
119311: LD_ADDR_EXP 219
119315: PUSH
119316: EMPTY
119317: ST_TO_ADDR
// hackLimit := 3 ;
119318: LD_ADDR_EXP 220
119322: PUSH
119323: LD_INT 3
119325: ST_TO_ADDR
// hackDist := 12 ;
119326: LD_ADDR_EXP 221
119330: PUSH
119331: LD_INT 12
119333: ST_TO_ADDR
// hackCounter := [ ] ;
119334: LD_ADDR_EXP 222
119338: PUSH
119339: EMPTY
119340: ST_TO_ADDR
// end ;
119341: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
119342: LD_EXP 217
119346: PUSH
119347: LD_INT 34
119349: PUSH
119350: LD_EXP 97
119354: PUSH
119355: EMPTY
119356: LIST
119357: LIST
119358: PPUSH
119359: CALL_OW 69
119363: AND
119364: IFFALSE 119619
119366: GO 119368
119368: DISABLE
119369: LD_INT 0
119371: PPUSH
119372: PPUSH
// begin enable ;
119373: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
119374: LD_ADDR_VAR 0 1
119378: PUSH
119379: LD_INT 34
119381: PUSH
119382: LD_EXP 97
119386: PUSH
119387: EMPTY
119388: LIST
119389: LIST
119390: PPUSH
119391: CALL_OW 69
119395: PUSH
119396: FOR_IN
119397: IFFALSE 119617
// begin if not i in hackTanks then
119399: LD_VAR 0 1
119403: PUSH
119404: LD_EXP 218
119408: IN
119409: NOT
119410: IFFALSE 119493
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
119412: LD_ADDR_EXP 218
119416: PUSH
119417: LD_EXP 218
119421: PPUSH
119422: LD_EXP 218
119426: PUSH
119427: LD_INT 1
119429: PLUS
119430: PPUSH
119431: LD_VAR 0 1
119435: PPUSH
119436: CALL_OW 1
119440: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
119441: LD_ADDR_EXP 219
119445: PUSH
119446: LD_EXP 219
119450: PPUSH
119451: LD_EXP 219
119455: PUSH
119456: LD_INT 1
119458: PLUS
119459: PPUSH
119460: EMPTY
119461: PPUSH
119462: CALL_OW 1
119466: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
119467: LD_ADDR_EXP 222
119471: PUSH
119472: LD_EXP 222
119476: PPUSH
119477: LD_EXP 222
119481: PUSH
119482: LD_INT 1
119484: PLUS
119485: PPUSH
119486: EMPTY
119487: PPUSH
119488: CALL_OW 1
119492: ST_TO_ADDR
// end ; if not IsOk ( i ) then
119493: LD_VAR 0 1
119497: PPUSH
119498: CALL_OW 302
119502: NOT
119503: IFFALSE 119516
// begin HackUnlinkAll ( i ) ;
119505: LD_VAR 0 1
119509: PPUSH
119510: CALL 119622 0 1
// continue ;
119514: GO 119396
// end ; HackCheckCapturedStatus ( i ) ;
119516: LD_VAR 0 1
119520: PPUSH
119521: CALL 120065 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
119525: LD_ADDR_VAR 0 2
119529: PUSH
119530: LD_INT 81
119532: PUSH
119533: LD_VAR 0 1
119537: PPUSH
119538: CALL_OW 255
119542: PUSH
119543: EMPTY
119544: LIST
119545: LIST
119546: PUSH
119547: LD_INT 33
119549: PUSH
119550: LD_INT 3
119552: PUSH
119553: EMPTY
119554: LIST
119555: LIST
119556: PUSH
119557: LD_INT 91
119559: PUSH
119560: LD_VAR 0 1
119564: PUSH
119565: LD_EXP 221
119569: PUSH
119570: EMPTY
119571: LIST
119572: LIST
119573: LIST
119574: PUSH
119575: LD_INT 50
119577: PUSH
119578: EMPTY
119579: LIST
119580: PUSH
119581: EMPTY
119582: LIST
119583: LIST
119584: LIST
119585: LIST
119586: PPUSH
119587: CALL_OW 69
119591: ST_TO_ADDR
// if not tmp then
119592: LD_VAR 0 2
119596: NOT
119597: IFFALSE 119601
// continue ;
119599: GO 119396
// HackLink ( i , tmp ) ;
119601: LD_VAR 0 1
119605: PPUSH
119606: LD_VAR 0 2
119610: PPUSH
119611: CALL 119758 0 2
// end ;
119615: GO 119396
119617: POP
119618: POP
// end ;
119619: PPOPN 2
119621: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
119622: LD_INT 0
119624: PPUSH
119625: PPUSH
119626: PPUSH
// if not hack in hackTanks then
119627: LD_VAR 0 1
119631: PUSH
119632: LD_EXP 218
119636: IN
119637: NOT
119638: IFFALSE 119642
// exit ;
119640: GO 119753
// index := GetElementIndex ( hackTanks , hack ) ;
119642: LD_ADDR_VAR 0 4
119646: PUSH
119647: LD_EXP 218
119651: PPUSH
119652: LD_VAR 0 1
119656: PPUSH
119657: CALL 70485 0 2
119661: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
119662: LD_EXP 219
119666: PUSH
119667: LD_VAR 0 4
119671: ARRAY
119672: IFFALSE 119753
// begin for i in hackTanksCaptured [ index ] do
119674: LD_ADDR_VAR 0 3
119678: PUSH
119679: LD_EXP 219
119683: PUSH
119684: LD_VAR 0 4
119688: ARRAY
119689: PUSH
119690: FOR_IN
119691: IFFALSE 119717
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
119693: LD_VAR 0 3
119697: PUSH
119698: LD_INT 1
119700: ARRAY
119701: PPUSH
119702: LD_VAR 0 3
119706: PUSH
119707: LD_INT 2
119709: ARRAY
119710: PPUSH
119711: CALL_OW 235
119715: GO 119690
119717: POP
119718: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
119719: LD_ADDR_EXP 219
119723: PUSH
119724: LD_EXP 219
119728: PPUSH
119729: LD_VAR 0 4
119733: PPUSH
119734: EMPTY
119735: PPUSH
119736: CALL_OW 1
119740: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
119741: LD_VAR 0 1
119745: PPUSH
119746: LD_INT 0
119748: PPUSH
119749: CALL_OW 505
// end ; end ;
119753: LD_VAR 0 2
119757: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
119758: LD_INT 0
119760: PPUSH
119761: PPUSH
119762: PPUSH
// if not hack in hackTanks or not vehicles then
119763: LD_VAR 0 1
119767: PUSH
119768: LD_EXP 218
119772: IN
119773: NOT
119774: PUSH
119775: LD_VAR 0 2
119779: NOT
119780: OR
119781: IFFALSE 119785
// exit ;
119783: GO 120060
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
119785: LD_ADDR_VAR 0 2
119789: PUSH
119790: LD_VAR 0 1
119794: PPUSH
119795: LD_VAR 0 2
119799: PPUSH
119800: LD_INT 1
119802: PPUSH
119803: LD_INT 1
119805: PPUSH
119806: CALL 71135 0 4
119810: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
119811: LD_ADDR_VAR 0 5
119815: PUSH
119816: LD_EXP 218
119820: PPUSH
119821: LD_VAR 0 1
119825: PPUSH
119826: CALL 70485 0 2
119830: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
119831: LD_EXP 219
119835: PUSH
119836: LD_VAR 0 5
119840: ARRAY
119841: PUSH
119842: LD_EXP 220
119846: LESS
119847: IFFALSE 120036
// begin for i := 1 to vehicles do
119849: LD_ADDR_VAR 0 4
119853: PUSH
119854: DOUBLE
119855: LD_INT 1
119857: DEC
119858: ST_TO_ADDR
119859: LD_VAR 0 2
119863: PUSH
119864: FOR_TO
119865: IFFALSE 120034
// begin if hackTanksCaptured [ index ] = hackLimit then
119867: LD_EXP 219
119871: PUSH
119872: LD_VAR 0 5
119876: ARRAY
119877: PUSH
119878: LD_EXP 220
119882: EQUAL
119883: IFFALSE 119887
// break ;
119885: GO 120034
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
119887: LD_ADDR_EXP 222
119891: PUSH
119892: LD_EXP 222
119896: PPUSH
119897: LD_VAR 0 5
119901: PPUSH
119902: LD_EXP 222
119906: PUSH
119907: LD_VAR 0 5
119911: ARRAY
119912: PUSH
119913: LD_INT 1
119915: PLUS
119916: PPUSH
119917: CALL_OW 1
119921: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
119922: LD_ADDR_EXP 219
119926: PUSH
119927: LD_EXP 219
119931: PPUSH
119932: LD_VAR 0 5
119936: PUSH
119937: LD_EXP 219
119941: PUSH
119942: LD_VAR 0 5
119946: ARRAY
119947: PUSH
119948: LD_INT 1
119950: PLUS
119951: PUSH
119952: EMPTY
119953: LIST
119954: LIST
119955: PPUSH
119956: LD_VAR 0 2
119960: PUSH
119961: LD_VAR 0 4
119965: ARRAY
119966: PUSH
119967: LD_VAR 0 2
119971: PUSH
119972: LD_VAR 0 4
119976: ARRAY
119977: PPUSH
119978: CALL_OW 255
119982: PUSH
119983: EMPTY
119984: LIST
119985: LIST
119986: PPUSH
119987: CALL 70700 0 3
119991: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
119992: LD_VAR 0 2
119996: PUSH
119997: LD_VAR 0 4
120001: ARRAY
120002: PPUSH
120003: LD_VAR 0 1
120007: PPUSH
120008: CALL_OW 255
120012: PPUSH
120013: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
120017: LD_VAR 0 2
120021: PUSH
120022: LD_VAR 0 4
120026: ARRAY
120027: PPUSH
120028: CALL_OW 141
// end ;
120032: GO 119864
120034: POP
120035: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
120036: LD_VAR 0 1
120040: PPUSH
120041: LD_EXP 219
120045: PUSH
120046: LD_VAR 0 5
120050: ARRAY
120051: PUSH
120052: LD_INT 0
120054: PLUS
120055: PPUSH
120056: CALL_OW 505
// end ;
120060: LD_VAR 0 3
120064: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
120065: LD_INT 0
120067: PPUSH
120068: PPUSH
120069: PPUSH
120070: PPUSH
// if not hack in hackTanks then
120071: LD_VAR 0 1
120075: PUSH
120076: LD_EXP 218
120080: IN
120081: NOT
120082: IFFALSE 120086
// exit ;
120084: GO 120326
// index := GetElementIndex ( hackTanks , hack ) ;
120086: LD_ADDR_VAR 0 4
120090: PUSH
120091: LD_EXP 218
120095: PPUSH
120096: LD_VAR 0 1
120100: PPUSH
120101: CALL 70485 0 2
120105: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
120106: LD_ADDR_VAR 0 3
120110: PUSH
120111: DOUBLE
120112: LD_EXP 219
120116: PUSH
120117: LD_VAR 0 4
120121: ARRAY
120122: INC
120123: ST_TO_ADDR
120124: LD_INT 1
120126: PUSH
120127: FOR_DOWNTO
120128: IFFALSE 120300
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
120130: LD_ADDR_VAR 0 5
120134: PUSH
120135: LD_EXP 219
120139: PUSH
120140: LD_VAR 0 4
120144: ARRAY
120145: PUSH
120146: LD_VAR 0 3
120150: ARRAY
120151: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
120152: LD_VAR 0 5
120156: PUSH
120157: LD_INT 1
120159: ARRAY
120160: PPUSH
120161: CALL_OW 302
120165: NOT
120166: PUSH
120167: LD_VAR 0 5
120171: PUSH
120172: LD_INT 1
120174: ARRAY
120175: PPUSH
120176: CALL_OW 255
120180: PUSH
120181: LD_VAR 0 1
120185: PPUSH
120186: CALL_OW 255
120190: NONEQUAL
120191: OR
120192: IFFALSE 120298
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
120194: LD_VAR 0 5
120198: PUSH
120199: LD_INT 1
120201: ARRAY
120202: PPUSH
120203: CALL_OW 305
120207: PUSH
120208: LD_VAR 0 5
120212: PUSH
120213: LD_INT 1
120215: ARRAY
120216: PPUSH
120217: CALL_OW 255
120221: PUSH
120222: LD_VAR 0 1
120226: PPUSH
120227: CALL_OW 255
120231: EQUAL
120232: AND
120233: IFFALSE 120257
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
120235: LD_VAR 0 5
120239: PUSH
120240: LD_INT 1
120242: ARRAY
120243: PPUSH
120244: LD_VAR 0 5
120248: PUSH
120249: LD_INT 2
120251: ARRAY
120252: PPUSH
120253: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
120257: LD_ADDR_EXP 219
120261: PUSH
120262: LD_EXP 219
120266: PPUSH
120267: LD_VAR 0 4
120271: PPUSH
120272: LD_EXP 219
120276: PUSH
120277: LD_VAR 0 4
120281: ARRAY
120282: PPUSH
120283: LD_VAR 0 3
120287: PPUSH
120288: CALL_OW 3
120292: PPUSH
120293: CALL_OW 1
120297: ST_TO_ADDR
// end ; end ;
120298: GO 120127
120300: POP
120301: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
120302: LD_VAR 0 1
120306: PPUSH
120307: LD_EXP 219
120311: PUSH
120312: LD_VAR 0 4
120316: ARRAY
120317: PUSH
120318: LD_INT 0
120320: PLUS
120321: PPUSH
120322: CALL_OW 505
// end ;
120326: LD_VAR 0 2
120330: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
120331: LD_INT 0
120333: PPUSH
120334: PPUSH
120335: PPUSH
120336: PPUSH
// if not hack in hackTanks then
120337: LD_VAR 0 1
120341: PUSH
120342: LD_EXP 218
120346: IN
120347: NOT
120348: IFFALSE 120352
// exit ;
120350: GO 120437
// index := GetElementIndex ( hackTanks , hack ) ;
120352: LD_ADDR_VAR 0 5
120356: PUSH
120357: LD_EXP 218
120361: PPUSH
120362: LD_VAR 0 1
120366: PPUSH
120367: CALL 70485 0 2
120371: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
120372: LD_ADDR_VAR 0 4
120376: PUSH
120377: DOUBLE
120378: LD_INT 1
120380: DEC
120381: ST_TO_ADDR
120382: LD_EXP 219
120386: PUSH
120387: LD_VAR 0 5
120391: ARRAY
120392: PUSH
120393: FOR_TO
120394: IFFALSE 120435
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
120396: LD_EXP 219
120400: PUSH
120401: LD_VAR 0 5
120405: ARRAY
120406: PUSH
120407: LD_VAR 0 4
120411: ARRAY
120412: PUSH
120413: LD_INT 1
120415: ARRAY
120416: PUSH
120417: LD_VAR 0 2
120421: EQUAL
120422: IFFALSE 120433
// KillUnit ( vehicle ) ;
120424: LD_VAR 0 2
120428: PPUSH
120429: CALL_OW 66
120433: GO 120393
120435: POP
120436: POP
// end ;
120437: LD_VAR 0 3
120441: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
120442: LD_EXP 223
120446: NOT
120447: IFFALSE 120482
120449: GO 120451
120451: DISABLE
// begin initMiner := true ;
120452: LD_ADDR_EXP 223
120456: PUSH
120457: LD_INT 1
120459: ST_TO_ADDR
// minersList := [ ] ;
120460: LD_ADDR_EXP 224
120464: PUSH
120465: EMPTY
120466: ST_TO_ADDR
// minerMinesList := [ ] ;
120467: LD_ADDR_EXP 225
120471: PUSH
120472: EMPTY
120473: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
120474: LD_ADDR_EXP 226
120478: PUSH
120479: LD_INT 5
120481: ST_TO_ADDR
// end ;
120482: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
120483: LD_EXP 223
120487: PUSH
120488: LD_INT 34
120490: PUSH
120491: LD_EXP 102
120495: PUSH
120496: EMPTY
120497: LIST
120498: LIST
120499: PPUSH
120500: CALL_OW 69
120504: AND
120505: IFFALSE 120968
120507: GO 120509
120509: DISABLE
120510: LD_INT 0
120512: PPUSH
120513: PPUSH
120514: PPUSH
120515: PPUSH
// begin enable ;
120516: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
120517: LD_ADDR_VAR 0 1
120521: PUSH
120522: LD_INT 34
120524: PUSH
120525: LD_EXP 102
120529: PUSH
120530: EMPTY
120531: LIST
120532: LIST
120533: PPUSH
120534: CALL_OW 69
120538: PUSH
120539: FOR_IN
120540: IFFALSE 120612
// begin if not i in minersList then
120542: LD_VAR 0 1
120546: PUSH
120547: LD_EXP 224
120551: IN
120552: NOT
120553: IFFALSE 120610
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
120555: LD_ADDR_EXP 224
120559: PUSH
120560: LD_EXP 224
120564: PPUSH
120565: LD_EXP 224
120569: PUSH
120570: LD_INT 1
120572: PLUS
120573: PPUSH
120574: LD_VAR 0 1
120578: PPUSH
120579: CALL_OW 1
120583: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
120584: LD_ADDR_EXP 225
120588: PUSH
120589: LD_EXP 225
120593: PPUSH
120594: LD_EXP 225
120598: PUSH
120599: LD_INT 1
120601: PLUS
120602: PPUSH
120603: EMPTY
120604: PPUSH
120605: CALL_OW 1
120609: ST_TO_ADDR
// end end ;
120610: GO 120539
120612: POP
120613: POP
// for i := minerMinesList downto 1 do
120614: LD_ADDR_VAR 0 1
120618: PUSH
120619: DOUBLE
120620: LD_EXP 225
120624: INC
120625: ST_TO_ADDR
120626: LD_INT 1
120628: PUSH
120629: FOR_DOWNTO
120630: IFFALSE 120966
// begin if IsLive ( minersList [ i ] ) then
120632: LD_EXP 224
120636: PUSH
120637: LD_VAR 0 1
120641: ARRAY
120642: PPUSH
120643: CALL_OW 300
120647: IFFALSE 120675
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
120649: LD_EXP 224
120653: PUSH
120654: LD_VAR 0 1
120658: ARRAY
120659: PPUSH
120660: LD_EXP 225
120664: PUSH
120665: LD_VAR 0 1
120669: ARRAY
120670: PPUSH
120671: CALL_OW 505
// if not minerMinesList [ i ] then
120675: LD_EXP 225
120679: PUSH
120680: LD_VAR 0 1
120684: ARRAY
120685: NOT
120686: IFFALSE 120690
// continue ;
120688: GO 120629
// for j := minerMinesList [ i ] downto 1 do
120690: LD_ADDR_VAR 0 2
120694: PUSH
120695: DOUBLE
120696: LD_EXP 225
120700: PUSH
120701: LD_VAR 0 1
120705: ARRAY
120706: INC
120707: ST_TO_ADDR
120708: LD_INT 1
120710: PUSH
120711: FOR_DOWNTO
120712: IFFALSE 120962
// begin side := GetSide ( minersList [ i ] ) ;
120714: LD_ADDR_VAR 0 3
120718: PUSH
120719: LD_EXP 224
120723: PUSH
120724: LD_VAR 0 1
120728: ARRAY
120729: PPUSH
120730: CALL_OW 255
120734: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
120735: LD_ADDR_VAR 0 4
120739: PUSH
120740: LD_EXP 225
120744: PUSH
120745: LD_VAR 0 1
120749: ARRAY
120750: PUSH
120751: LD_VAR 0 2
120755: ARRAY
120756: PUSH
120757: LD_INT 1
120759: ARRAY
120760: PPUSH
120761: LD_EXP 225
120765: PUSH
120766: LD_VAR 0 1
120770: ARRAY
120771: PUSH
120772: LD_VAR 0 2
120776: ARRAY
120777: PUSH
120778: LD_INT 2
120780: ARRAY
120781: PPUSH
120782: CALL_OW 428
120786: ST_TO_ADDR
// if not tmp then
120787: LD_VAR 0 4
120791: NOT
120792: IFFALSE 120796
// continue ;
120794: GO 120711
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
120796: LD_VAR 0 4
120800: PUSH
120801: LD_INT 81
120803: PUSH
120804: LD_VAR 0 3
120808: PUSH
120809: EMPTY
120810: LIST
120811: LIST
120812: PPUSH
120813: CALL_OW 69
120817: IN
120818: PUSH
120819: LD_EXP 225
120823: PUSH
120824: LD_VAR 0 1
120828: ARRAY
120829: PUSH
120830: LD_VAR 0 2
120834: ARRAY
120835: PUSH
120836: LD_INT 1
120838: ARRAY
120839: PPUSH
120840: LD_EXP 225
120844: PUSH
120845: LD_VAR 0 1
120849: ARRAY
120850: PUSH
120851: LD_VAR 0 2
120855: ARRAY
120856: PUSH
120857: LD_INT 2
120859: ARRAY
120860: PPUSH
120861: CALL_OW 458
120865: AND
120866: IFFALSE 120960
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
120868: LD_EXP 225
120872: PUSH
120873: LD_VAR 0 1
120877: ARRAY
120878: PUSH
120879: LD_VAR 0 2
120883: ARRAY
120884: PUSH
120885: LD_INT 1
120887: ARRAY
120888: PPUSH
120889: LD_EXP 225
120893: PUSH
120894: LD_VAR 0 1
120898: ARRAY
120899: PUSH
120900: LD_VAR 0 2
120904: ARRAY
120905: PUSH
120906: LD_INT 2
120908: ARRAY
120909: PPUSH
120910: LD_VAR 0 3
120914: PPUSH
120915: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
120919: LD_ADDR_EXP 225
120923: PUSH
120924: LD_EXP 225
120928: PPUSH
120929: LD_VAR 0 1
120933: PPUSH
120934: LD_EXP 225
120938: PUSH
120939: LD_VAR 0 1
120943: ARRAY
120944: PPUSH
120945: LD_VAR 0 2
120949: PPUSH
120950: CALL_OW 3
120954: PPUSH
120955: CALL_OW 1
120959: ST_TO_ADDR
// end ; end ;
120960: GO 120711
120962: POP
120963: POP
// end ;
120964: GO 120629
120966: POP
120967: POP
// end ;
120968: PPOPN 4
120970: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
120971: LD_INT 0
120973: PPUSH
120974: PPUSH
// result := false ;
120975: LD_ADDR_VAR 0 4
120979: PUSH
120980: LD_INT 0
120982: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
120983: LD_VAR 0 1
120987: PPUSH
120988: CALL_OW 264
120992: PUSH
120993: LD_EXP 102
120997: EQUAL
120998: NOT
120999: IFFALSE 121003
// exit ;
121001: GO 121243
// index := GetElementIndex ( minersList , unit ) ;
121003: LD_ADDR_VAR 0 5
121007: PUSH
121008: LD_EXP 224
121012: PPUSH
121013: LD_VAR 0 1
121017: PPUSH
121018: CALL 70485 0 2
121022: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
121023: LD_EXP 225
121027: PUSH
121028: LD_VAR 0 5
121032: ARRAY
121033: PUSH
121034: LD_EXP 226
121038: GREATEREQUAL
121039: IFFALSE 121043
// exit ;
121041: GO 121243
// ComMoveXY ( unit , x , y ) ;
121043: LD_VAR 0 1
121047: PPUSH
121048: LD_VAR 0 2
121052: PPUSH
121053: LD_VAR 0 3
121057: PPUSH
121058: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
121062: LD_INT 35
121064: PPUSH
121065: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
121069: LD_VAR 0 1
121073: PPUSH
121074: LD_VAR 0 2
121078: PPUSH
121079: LD_VAR 0 3
121083: PPUSH
121084: CALL 101257 0 3
121088: NOT
121089: PUSH
121090: LD_VAR 0 1
121094: PPUSH
121095: CALL_OW 314
121099: AND
121100: IFFALSE 121104
// exit ;
121102: GO 121243
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
121104: LD_VAR 0 2
121108: PPUSH
121109: LD_VAR 0 3
121113: PPUSH
121114: CALL_OW 428
121118: PUSH
121119: LD_VAR 0 1
121123: EQUAL
121124: PUSH
121125: LD_VAR 0 1
121129: PPUSH
121130: CALL_OW 314
121134: NOT
121135: AND
121136: IFFALSE 121062
// PlaySoundXY ( x , y , PlantMine ) ;
121138: LD_VAR 0 2
121142: PPUSH
121143: LD_VAR 0 3
121147: PPUSH
121148: LD_STRING PlantMine
121150: PPUSH
121151: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
121155: LD_VAR 0 2
121159: PPUSH
121160: LD_VAR 0 3
121164: PPUSH
121165: LD_VAR 0 1
121169: PPUSH
121170: CALL_OW 255
121174: PPUSH
121175: LD_INT 0
121177: PPUSH
121178: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
121182: LD_ADDR_EXP 225
121186: PUSH
121187: LD_EXP 225
121191: PPUSH
121192: LD_VAR 0 5
121196: PUSH
121197: LD_EXP 225
121201: PUSH
121202: LD_VAR 0 5
121206: ARRAY
121207: PUSH
121208: LD_INT 1
121210: PLUS
121211: PUSH
121212: EMPTY
121213: LIST
121214: LIST
121215: PPUSH
121216: LD_VAR 0 2
121220: PUSH
121221: LD_VAR 0 3
121225: PUSH
121226: EMPTY
121227: LIST
121228: LIST
121229: PPUSH
121230: CALL 70700 0 3
121234: ST_TO_ADDR
// result := true ;
121235: LD_ADDR_VAR 0 4
121239: PUSH
121240: LD_INT 1
121242: ST_TO_ADDR
// end ;
121243: LD_VAR 0 4
121247: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
121248: LD_INT 0
121250: PPUSH
121251: PPUSH
121252: PPUSH
// if not unit in minersList then
121253: LD_VAR 0 1
121257: PUSH
121258: LD_EXP 224
121262: IN
121263: NOT
121264: IFFALSE 121268
// exit ;
121266: GO 121660
// index := GetElementIndex ( minersList , unit ) ;
121268: LD_ADDR_VAR 0 6
121272: PUSH
121273: LD_EXP 224
121277: PPUSH
121278: LD_VAR 0 1
121282: PPUSH
121283: CALL 70485 0 2
121287: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
121288: LD_ADDR_VAR 0 5
121292: PUSH
121293: DOUBLE
121294: LD_EXP 225
121298: PUSH
121299: LD_VAR 0 6
121303: ARRAY
121304: INC
121305: ST_TO_ADDR
121306: LD_INT 1
121308: PUSH
121309: FOR_DOWNTO
121310: IFFALSE 121471
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
121312: LD_EXP 225
121316: PUSH
121317: LD_VAR 0 6
121321: ARRAY
121322: PUSH
121323: LD_VAR 0 5
121327: ARRAY
121328: PUSH
121329: LD_INT 1
121331: ARRAY
121332: PUSH
121333: LD_VAR 0 2
121337: EQUAL
121338: PUSH
121339: LD_EXP 225
121343: PUSH
121344: LD_VAR 0 6
121348: ARRAY
121349: PUSH
121350: LD_VAR 0 5
121354: ARRAY
121355: PUSH
121356: LD_INT 2
121358: ARRAY
121359: PUSH
121360: LD_VAR 0 3
121364: EQUAL
121365: AND
121366: IFFALSE 121469
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
121368: LD_EXP 225
121372: PUSH
121373: LD_VAR 0 6
121377: ARRAY
121378: PUSH
121379: LD_VAR 0 5
121383: ARRAY
121384: PUSH
121385: LD_INT 1
121387: ARRAY
121388: PPUSH
121389: LD_EXP 225
121393: PUSH
121394: LD_VAR 0 6
121398: ARRAY
121399: PUSH
121400: LD_VAR 0 5
121404: ARRAY
121405: PUSH
121406: LD_INT 2
121408: ARRAY
121409: PPUSH
121410: LD_VAR 0 1
121414: PPUSH
121415: CALL_OW 255
121419: PPUSH
121420: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
121424: LD_ADDR_EXP 225
121428: PUSH
121429: LD_EXP 225
121433: PPUSH
121434: LD_VAR 0 6
121438: PPUSH
121439: LD_EXP 225
121443: PUSH
121444: LD_VAR 0 6
121448: ARRAY
121449: PPUSH
121450: LD_VAR 0 5
121454: PPUSH
121455: CALL_OW 3
121459: PPUSH
121460: CALL_OW 1
121464: ST_TO_ADDR
// exit ;
121465: POP
121466: POP
121467: GO 121660
// end ; end ;
121469: GO 121309
121471: POP
121472: POP
// for i := minerMinesList [ index ] downto 1 do
121473: LD_ADDR_VAR 0 5
121477: PUSH
121478: DOUBLE
121479: LD_EXP 225
121483: PUSH
121484: LD_VAR 0 6
121488: ARRAY
121489: INC
121490: ST_TO_ADDR
121491: LD_INT 1
121493: PUSH
121494: FOR_DOWNTO
121495: IFFALSE 121658
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
121497: LD_EXP 225
121501: PUSH
121502: LD_VAR 0 6
121506: ARRAY
121507: PUSH
121508: LD_VAR 0 5
121512: ARRAY
121513: PUSH
121514: LD_INT 1
121516: ARRAY
121517: PPUSH
121518: LD_EXP 225
121522: PUSH
121523: LD_VAR 0 6
121527: ARRAY
121528: PUSH
121529: LD_VAR 0 5
121533: ARRAY
121534: PUSH
121535: LD_INT 2
121537: ARRAY
121538: PPUSH
121539: LD_VAR 0 2
121543: PPUSH
121544: LD_VAR 0 3
121548: PPUSH
121549: CALL_OW 298
121553: PUSH
121554: LD_INT 6
121556: LESS
121557: IFFALSE 121656
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
121559: LD_EXP 225
121563: PUSH
121564: LD_VAR 0 6
121568: ARRAY
121569: PUSH
121570: LD_VAR 0 5
121574: ARRAY
121575: PUSH
121576: LD_INT 1
121578: ARRAY
121579: PPUSH
121580: LD_EXP 225
121584: PUSH
121585: LD_VAR 0 6
121589: ARRAY
121590: PUSH
121591: LD_VAR 0 5
121595: ARRAY
121596: PUSH
121597: LD_INT 2
121599: ARRAY
121600: PPUSH
121601: LD_VAR 0 1
121605: PPUSH
121606: CALL_OW 255
121610: PPUSH
121611: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
121615: LD_ADDR_EXP 225
121619: PUSH
121620: LD_EXP 225
121624: PPUSH
121625: LD_VAR 0 6
121629: PPUSH
121630: LD_EXP 225
121634: PUSH
121635: LD_VAR 0 6
121639: ARRAY
121640: PPUSH
121641: LD_VAR 0 5
121645: PPUSH
121646: CALL_OW 3
121650: PPUSH
121651: CALL_OW 1
121655: ST_TO_ADDR
// end ; end ;
121656: GO 121494
121658: POP
121659: POP
// end ;
121660: LD_VAR 0 4
121664: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
121665: LD_INT 0
121667: PPUSH
121668: PPUSH
121669: PPUSH
121670: PPUSH
121671: PPUSH
121672: PPUSH
121673: PPUSH
121674: PPUSH
121675: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
121676: LD_VAR 0 1
121680: PPUSH
121681: CALL_OW 264
121685: PUSH
121686: LD_EXP 102
121690: EQUAL
121691: NOT
121692: PUSH
121693: LD_VAR 0 1
121697: PUSH
121698: LD_EXP 224
121702: IN
121703: NOT
121704: OR
121705: IFFALSE 121709
// exit ;
121707: GO 122031
// index := GetElementIndex ( minersList , unit ) ;
121709: LD_ADDR_VAR 0 6
121713: PUSH
121714: LD_EXP 224
121718: PPUSH
121719: LD_VAR 0 1
121723: PPUSH
121724: CALL 70485 0 2
121728: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
121729: LD_ADDR_VAR 0 8
121733: PUSH
121734: LD_EXP 226
121738: PUSH
121739: LD_EXP 225
121743: PUSH
121744: LD_VAR 0 6
121748: ARRAY
121749: MINUS
121750: ST_TO_ADDR
// if not minesFreeAmount then
121751: LD_VAR 0 8
121755: NOT
121756: IFFALSE 121760
// exit ;
121758: GO 122031
// tmp := [ ] ;
121760: LD_ADDR_VAR 0 7
121764: PUSH
121765: EMPTY
121766: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
121767: LD_ADDR_VAR 0 5
121771: PUSH
121772: DOUBLE
121773: LD_INT 1
121775: DEC
121776: ST_TO_ADDR
121777: LD_VAR 0 8
121781: PUSH
121782: FOR_TO
121783: IFFALSE 121978
// begin _d := rand ( 0 , 5 ) ;
121785: LD_ADDR_VAR 0 11
121789: PUSH
121790: LD_INT 0
121792: PPUSH
121793: LD_INT 5
121795: PPUSH
121796: CALL_OW 12
121800: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
121801: LD_ADDR_VAR 0 12
121805: PUSH
121806: LD_INT 2
121808: PPUSH
121809: LD_INT 6
121811: PPUSH
121812: CALL_OW 12
121816: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
121817: LD_ADDR_VAR 0 9
121821: PUSH
121822: LD_VAR 0 2
121826: PPUSH
121827: LD_VAR 0 11
121831: PPUSH
121832: LD_VAR 0 12
121836: PPUSH
121837: CALL_OW 272
121841: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
121842: LD_ADDR_VAR 0 10
121846: PUSH
121847: LD_VAR 0 3
121851: PPUSH
121852: LD_VAR 0 11
121856: PPUSH
121857: LD_VAR 0 12
121861: PPUSH
121862: CALL_OW 273
121866: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
121867: LD_VAR 0 9
121871: PPUSH
121872: LD_VAR 0 10
121876: PPUSH
121877: CALL_OW 488
121881: PUSH
121882: LD_VAR 0 9
121886: PUSH
121887: LD_VAR 0 10
121891: PUSH
121892: EMPTY
121893: LIST
121894: LIST
121895: PUSH
121896: LD_VAR 0 7
121900: IN
121901: NOT
121902: AND
121903: PUSH
121904: LD_VAR 0 9
121908: PPUSH
121909: LD_VAR 0 10
121913: PPUSH
121914: CALL_OW 458
121918: NOT
121919: AND
121920: IFFALSE 121962
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
121922: LD_ADDR_VAR 0 7
121926: PUSH
121927: LD_VAR 0 7
121931: PPUSH
121932: LD_VAR 0 7
121936: PUSH
121937: LD_INT 1
121939: PLUS
121940: PPUSH
121941: LD_VAR 0 9
121945: PUSH
121946: LD_VAR 0 10
121950: PUSH
121951: EMPTY
121952: LIST
121953: LIST
121954: PPUSH
121955: CALL_OW 1
121959: ST_TO_ADDR
121960: GO 121976
// i := i - 1 ;
121962: LD_ADDR_VAR 0 5
121966: PUSH
121967: LD_VAR 0 5
121971: PUSH
121972: LD_INT 1
121974: MINUS
121975: ST_TO_ADDR
// end ;
121976: GO 121782
121978: POP
121979: POP
// for i in tmp do
121980: LD_ADDR_VAR 0 5
121984: PUSH
121985: LD_VAR 0 7
121989: PUSH
121990: FOR_IN
121991: IFFALSE 122029
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
121993: LD_VAR 0 1
121997: PPUSH
121998: LD_VAR 0 5
122002: PUSH
122003: LD_INT 1
122005: ARRAY
122006: PPUSH
122007: LD_VAR 0 5
122011: PUSH
122012: LD_INT 2
122014: ARRAY
122015: PPUSH
122016: CALL 120971 0 3
122020: NOT
122021: IFFALSE 122027
// exit ;
122023: POP
122024: POP
122025: GO 122031
122027: GO 121990
122029: POP
122030: POP
// end ;
122031: LD_VAR 0 4
122035: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
122036: LD_INT 0
122038: PPUSH
122039: PPUSH
122040: PPUSH
122041: PPUSH
122042: PPUSH
122043: PPUSH
122044: PPUSH
// if not GetClass ( unit ) = class_sniper then
122045: LD_VAR 0 1
122049: PPUSH
122050: CALL_OW 257
122054: PUSH
122055: LD_INT 5
122057: EQUAL
122058: NOT
122059: IFFALSE 122063
// exit ;
122061: GO 122451
// dist := 8 ;
122063: LD_ADDR_VAR 0 5
122067: PUSH
122068: LD_INT 8
122070: ST_TO_ADDR
// viewRange := 12 ;
122071: LD_ADDR_VAR 0 7
122075: PUSH
122076: LD_INT 12
122078: ST_TO_ADDR
// side := GetSide ( unit ) ;
122079: LD_ADDR_VAR 0 6
122083: PUSH
122084: LD_VAR 0 1
122088: PPUSH
122089: CALL_OW 255
122093: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
122094: LD_INT 61
122096: PPUSH
122097: LD_VAR 0 6
122101: PPUSH
122102: CALL_OW 321
122106: PUSH
122107: LD_INT 2
122109: EQUAL
122110: IFFALSE 122120
// viewRange := 16 ;
122112: LD_ADDR_VAR 0 7
122116: PUSH
122117: LD_INT 16
122119: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
122120: LD_VAR 0 1
122124: PPUSH
122125: LD_VAR 0 2
122129: PPUSH
122130: LD_VAR 0 3
122134: PPUSH
122135: CALL_OW 297
122139: PUSH
122140: LD_VAR 0 5
122144: GREATER
122145: IFFALSE 122224
// begin ComMoveXY ( unit , x , y ) ;
122147: LD_VAR 0 1
122151: PPUSH
122152: LD_VAR 0 2
122156: PPUSH
122157: LD_VAR 0 3
122161: PPUSH
122162: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
122166: LD_INT 35
122168: PPUSH
122169: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
122173: LD_VAR 0 1
122177: PPUSH
122178: LD_VAR 0 2
122182: PPUSH
122183: LD_VAR 0 3
122187: PPUSH
122188: CALL 101257 0 3
122192: NOT
122193: IFFALSE 122197
// exit ;
122195: GO 122451
// until GetDistUnitXY ( unit , x , y ) < dist ;
122197: LD_VAR 0 1
122201: PPUSH
122202: LD_VAR 0 2
122206: PPUSH
122207: LD_VAR 0 3
122211: PPUSH
122212: CALL_OW 297
122216: PUSH
122217: LD_VAR 0 5
122221: LESS
122222: IFFALSE 122166
// end ; ComTurnXY ( unit , x , y ) ;
122224: LD_VAR 0 1
122228: PPUSH
122229: LD_VAR 0 2
122233: PPUSH
122234: LD_VAR 0 3
122238: PPUSH
122239: CALL_OW 118
// wait ( 5 ) ;
122243: LD_INT 5
122245: PPUSH
122246: CALL_OW 67
// _d := GetDir ( unit ) ;
122250: LD_ADDR_VAR 0 10
122254: PUSH
122255: LD_VAR 0 1
122259: PPUSH
122260: CALL_OW 254
122264: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
122265: LD_ADDR_VAR 0 8
122269: PUSH
122270: LD_VAR 0 1
122274: PPUSH
122275: CALL_OW 250
122279: PPUSH
122280: LD_VAR 0 10
122284: PPUSH
122285: LD_VAR 0 5
122289: PPUSH
122290: CALL_OW 272
122294: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
122295: LD_ADDR_VAR 0 9
122299: PUSH
122300: LD_VAR 0 1
122304: PPUSH
122305: CALL_OW 251
122309: PPUSH
122310: LD_VAR 0 10
122314: PPUSH
122315: LD_VAR 0 5
122319: PPUSH
122320: CALL_OW 273
122324: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
122325: LD_VAR 0 8
122329: PPUSH
122330: LD_VAR 0 9
122334: PPUSH
122335: CALL_OW 488
122339: NOT
122340: IFFALSE 122344
// exit ;
122342: GO 122451
// ComAnimCustom ( unit , 1 ) ;
122344: LD_VAR 0 1
122348: PPUSH
122349: LD_INT 1
122351: PPUSH
122352: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
122356: LD_VAR 0 8
122360: PPUSH
122361: LD_VAR 0 9
122365: PPUSH
122366: LD_VAR 0 6
122370: PPUSH
122371: LD_VAR 0 7
122375: PPUSH
122376: CALL_OW 330
// repeat wait ( 1 ) ;
122380: LD_INT 1
122382: PPUSH
122383: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
122387: LD_VAR 0 1
122391: PPUSH
122392: CALL_OW 316
122396: PUSH
122397: LD_VAR 0 1
122401: PPUSH
122402: CALL_OW 314
122406: OR
122407: PUSH
122408: LD_VAR 0 1
122412: PPUSH
122413: CALL_OW 302
122417: NOT
122418: OR
122419: PUSH
122420: LD_VAR 0 1
122424: PPUSH
122425: CALL_OW 301
122429: OR
122430: IFFALSE 122380
// RemoveSeeing ( _x , _y , side ) ;
122432: LD_VAR 0 8
122436: PPUSH
122437: LD_VAR 0 9
122441: PPUSH
122442: LD_VAR 0 6
122446: PPUSH
122447: CALL_OW 331
// end ; end_of_file
122451: LD_VAR 0 4
122455: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
122456: LD_INT 0
122458: PPUSH
122459: PPUSH
122460: PPUSH
122461: PPUSH
122462: PPUSH
122463: PPUSH
122464: PPUSH
122465: PPUSH
122466: PPUSH
122467: PPUSH
122468: PPUSH
122469: PPUSH
122470: PPUSH
122471: PPUSH
122472: PPUSH
122473: PPUSH
122474: PPUSH
122475: PPUSH
122476: PPUSH
122477: PPUSH
122478: PPUSH
122479: PPUSH
122480: PPUSH
122481: PPUSH
122482: PPUSH
122483: PPUSH
122484: PPUSH
122485: PPUSH
122486: PPUSH
122487: PPUSH
122488: PPUSH
122489: PPUSH
122490: PPUSH
122491: PPUSH
// if not list then
122492: LD_VAR 0 1
122496: NOT
122497: IFFALSE 122501
// exit ;
122499: GO 127160
// base := list [ 1 ] ;
122501: LD_ADDR_VAR 0 3
122505: PUSH
122506: LD_VAR 0 1
122510: PUSH
122511: LD_INT 1
122513: ARRAY
122514: ST_TO_ADDR
// group := list [ 2 ] ;
122515: LD_ADDR_VAR 0 4
122519: PUSH
122520: LD_VAR 0 1
122524: PUSH
122525: LD_INT 2
122527: ARRAY
122528: ST_TO_ADDR
// path := list [ 3 ] ;
122529: LD_ADDR_VAR 0 5
122533: PUSH
122534: LD_VAR 0 1
122538: PUSH
122539: LD_INT 3
122541: ARRAY
122542: ST_TO_ADDR
// flags := list [ 4 ] ;
122543: LD_ADDR_VAR 0 6
122547: PUSH
122548: LD_VAR 0 1
122552: PUSH
122553: LD_INT 4
122555: ARRAY
122556: ST_TO_ADDR
// mined := [ ] ;
122557: LD_ADDR_VAR 0 27
122561: PUSH
122562: EMPTY
122563: ST_TO_ADDR
// bombed := [ ] ;
122564: LD_ADDR_VAR 0 28
122568: PUSH
122569: EMPTY
122570: ST_TO_ADDR
// healers := [ ] ;
122571: LD_ADDR_VAR 0 31
122575: PUSH
122576: EMPTY
122577: ST_TO_ADDR
// to_heal := [ ] ;
122578: LD_ADDR_VAR 0 30
122582: PUSH
122583: EMPTY
122584: ST_TO_ADDR
// repairs := [ ] ;
122585: LD_ADDR_VAR 0 33
122589: PUSH
122590: EMPTY
122591: ST_TO_ADDR
// to_repair := [ ] ;
122592: LD_ADDR_VAR 0 32
122596: PUSH
122597: EMPTY
122598: ST_TO_ADDR
// if not group or not path then
122599: LD_VAR 0 4
122603: NOT
122604: PUSH
122605: LD_VAR 0 5
122609: NOT
122610: OR
122611: IFFALSE 122615
// exit ;
122613: GO 127160
// side := GetSide ( group [ 1 ] ) ;
122615: LD_ADDR_VAR 0 35
122619: PUSH
122620: LD_VAR 0 4
122624: PUSH
122625: LD_INT 1
122627: ARRAY
122628: PPUSH
122629: CALL_OW 255
122633: ST_TO_ADDR
// if flags then
122634: LD_VAR 0 6
122638: IFFALSE 122782
// begin f_ignore_area := flags [ 1 ] ;
122640: LD_ADDR_VAR 0 17
122644: PUSH
122645: LD_VAR 0 6
122649: PUSH
122650: LD_INT 1
122652: ARRAY
122653: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
122654: LD_ADDR_VAR 0 18
122658: PUSH
122659: LD_VAR 0 6
122663: PUSH
122664: LD_INT 2
122666: ARRAY
122667: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
122668: LD_ADDR_VAR 0 19
122672: PUSH
122673: LD_VAR 0 6
122677: PUSH
122678: LD_INT 3
122680: ARRAY
122681: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
122682: LD_ADDR_VAR 0 20
122686: PUSH
122687: LD_VAR 0 6
122691: PUSH
122692: LD_INT 4
122694: ARRAY
122695: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
122696: LD_ADDR_VAR 0 21
122700: PUSH
122701: LD_VAR 0 6
122705: PUSH
122706: LD_INT 5
122708: ARRAY
122709: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
122710: LD_ADDR_VAR 0 22
122714: PUSH
122715: LD_VAR 0 6
122719: PUSH
122720: LD_INT 6
122722: ARRAY
122723: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
122724: LD_ADDR_VAR 0 23
122728: PUSH
122729: LD_VAR 0 6
122733: PUSH
122734: LD_INT 7
122736: ARRAY
122737: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
122738: LD_ADDR_VAR 0 24
122742: PUSH
122743: LD_VAR 0 6
122747: PUSH
122748: LD_INT 8
122750: ARRAY
122751: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
122752: LD_ADDR_VAR 0 25
122756: PUSH
122757: LD_VAR 0 6
122761: PUSH
122762: LD_INT 9
122764: ARRAY
122765: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
122766: LD_ADDR_VAR 0 26
122770: PUSH
122771: LD_VAR 0 6
122775: PUSH
122776: LD_INT 10
122778: ARRAY
122779: ST_TO_ADDR
// end else
122780: GO 122862
// begin f_ignore_area := false ;
122782: LD_ADDR_VAR 0 17
122786: PUSH
122787: LD_INT 0
122789: ST_TO_ADDR
// f_capture := false ;
122790: LD_ADDR_VAR 0 18
122794: PUSH
122795: LD_INT 0
122797: ST_TO_ADDR
// f_ignore_civ := false ;
122798: LD_ADDR_VAR 0 19
122802: PUSH
122803: LD_INT 0
122805: ST_TO_ADDR
// f_murder := false ;
122806: LD_ADDR_VAR 0 20
122810: PUSH
122811: LD_INT 0
122813: ST_TO_ADDR
// f_mines := false ;
122814: LD_ADDR_VAR 0 21
122818: PUSH
122819: LD_INT 0
122821: ST_TO_ADDR
// f_repair := false ;
122822: LD_ADDR_VAR 0 22
122826: PUSH
122827: LD_INT 0
122829: ST_TO_ADDR
// f_heal := false ;
122830: LD_ADDR_VAR 0 23
122834: PUSH
122835: LD_INT 0
122837: ST_TO_ADDR
// f_spacetime := false ;
122838: LD_ADDR_VAR 0 24
122842: PUSH
122843: LD_INT 0
122845: ST_TO_ADDR
// f_attack_depot := false ;
122846: LD_ADDR_VAR 0 25
122850: PUSH
122851: LD_INT 0
122853: ST_TO_ADDR
// f_crawl := false ;
122854: LD_ADDR_VAR 0 26
122858: PUSH
122859: LD_INT 0
122861: ST_TO_ADDR
// end ; if f_heal then
122862: LD_VAR 0 23
122866: IFFALSE 122893
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
122868: LD_ADDR_VAR 0 31
122872: PUSH
122873: LD_VAR 0 4
122877: PPUSH
122878: LD_INT 25
122880: PUSH
122881: LD_INT 4
122883: PUSH
122884: EMPTY
122885: LIST
122886: LIST
122887: PPUSH
122888: CALL_OW 72
122892: ST_TO_ADDR
// if f_repair then
122893: LD_VAR 0 22
122897: IFFALSE 122924
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
122899: LD_ADDR_VAR 0 33
122903: PUSH
122904: LD_VAR 0 4
122908: PPUSH
122909: LD_INT 25
122911: PUSH
122912: LD_INT 3
122914: PUSH
122915: EMPTY
122916: LIST
122917: LIST
122918: PPUSH
122919: CALL_OW 72
122923: ST_TO_ADDR
// units_path := [ ] ;
122924: LD_ADDR_VAR 0 16
122928: PUSH
122929: EMPTY
122930: ST_TO_ADDR
// for i = 1 to group do
122931: LD_ADDR_VAR 0 7
122935: PUSH
122936: DOUBLE
122937: LD_INT 1
122939: DEC
122940: ST_TO_ADDR
122941: LD_VAR 0 4
122945: PUSH
122946: FOR_TO
122947: IFFALSE 122976
// units_path := Replace ( units_path , i , path ) ;
122949: LD_ADDR_VAR 0 16
122953: PUSH
122954: LD_VAR 0 16
122958: PPUSH
122959: LD_VAR 0 7
122963: PPUSH
122964: LD_VAR 0 5
122968: PPUSH
122969: CALL_OW 1
122973: ST_TO_ADDR
122974: GO 122946
122976: POP
122977: POP
// repeat for i = group downto 1 do
122978: LD_ADDR_VAR 0 7
122982: PUSH
122983: DOUBLE
122984: LD_VAR 0 4
122988: INC
122989: ST_TO_ADDR
122990: LD_INT 1
122992: PUSH
122993: FOR_DOWNTO
122994: IFFALSE 127116
// begin wait ( 5 ) ;
122996: LD_INT 5
122998: PPUSH
122999: CALL_OW 67
// tmp := [ ] ;
123003: LD_ADDR_VAR 0 14
123007: PUSH
123008: EMPTY
123009: ST_TO_ADDR
// attacking := false ;
123010: LD_ADDR_VAR 0 29
123014: PUSH
123015: LD_INT 0
123017: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
123018: LD_VAR 0 4
123022: PUSH
123023: LD_VAR 0 7
123027: ARRAY
123028: PPUSH
123029: CALL_OW 301
123033: PUSH
123034: LD_VAR 0 4
123038: PUSH
123039: LD_VAR 0 7
123043: ARRAY
123044: NOT
123045: OR
123046: IFFALSE 123155
// begin if GetType ( group [ i ] ) = unit_human then
123048: LD_VAR 0 4
123052: PUSH
123053: LD_VAR 0 7
123057: ARRAY
123058: PPUSH
123059: CALL_OW 247
123063: PUSH
123064: LD_INT 1
123066: EQUAL
123067: IFFALSE 123113
// begin to_heal := to_heal diff group [ i ] ;
123069: LD_ADDR_VAR 0 30
123073: PUSH
123074: LD_VAR 0 30
123078: PUSH
123079: LD_VAR 0 4
123083: PUSH
123084: LD_VAR 0 7
123088: ARRAY
123089: DIFF
123090: ST_TO_ADDR
// healers := healers diff group [ i ] ;
123091: LD_ADDR_VAR 0 31
123095: PUSH
123096: LD_VAR 0 31
123100: PUSH
123101: LD_VAR 0 4
123105: PUSH
123106: LD_VAR 0 7
123110: ARRAY
123111: DIFF
123112: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
123113: LD_ADDR_VAR 0 4
123117: PUSH
123118: LD_VAR 0 4
123122: PPUSH
123123: LD_VAR 0 7
123127: PPUSH
123128: CALL_OW 3
123132: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
123133: LD_ADDR_VAR 0 16
123137: PUSH
123138: LD_VAR 0 16
123142: PPUSH
123143: LD_VAR 0 7
123147: PPUSH
123148: CALL_OW 3
123152: ST_TO_ADDR
// continue ;
123153: GO 122993
// end ; if f_repair then
123155: LD_VAR 0 22
123159: IFFALSE 123648
// begin if GetType ( group [ i ] ) = unit_vehicle then
123161: LD_VAR 0 4
123165: PUSH
123166: LD_VAR 0 7
123170: ARRAY
123171: PPUSH
123172: CALL_OW 247
123176: PUSH
123177: LD_INT 2
123179: EQUAL
123180: IFFALSE 123370
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
123182: LD_VAR 0 4
123186: PUSH
123187: LD_VAR 0 7
123191: ARRAY
123192: PPUSH
123193: CALL_OW 256
123197: PUSH
123198: LD_INT 700
123200: LESS
123201: PUSH
123202: LD_VAR 0 4
123206: PUSH
123207: LD_VAR 0 7
123211: ARRAY
123212: PUSH
123213: LD_VAR 0 32
123217: IN
123218: NOT
123219: AND
123220: IFFALSE 123244
// to_repair := to_repair union group [ i ] ;
123222: LD_ADDR_VAR 0 32
123226: PUSH
123227: LD_VAR 0 32
123231: PUSH
123232: LD_VAR 0 4
123236: PUSH
123237: LD_VAR 0 7
123241: ARRAY
123242: UNION
123243: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
123244: LD_VAR 0 4
123248: PUSH
123249: LD_VAR 0 7
123253: ARRAY
123254: PPUSH
123255: CALL_OW 256
123259: PUSH
123260: LD_INT 1000
123262: EQUAL
123263: PUSH
123264: LD_VAR 0 4
123268: PUSH
123269: LD_VAR 0 7
123273: ARRAY
123274: PUSH
123275: LD_VAR 0 32
123279: IN
123280: AND
123281: IFFALSE 123305
// to_repair := to_repair diff group [ i ] ;
123283: LD_ADDR_VAR 0 32
123287: PUSH
123288: LD_VAR 0 32
123292: PUSH
123293: LD_VAR 0 4
123297: PUSH
123298: LD_VAR 0 7
123302: ARRAY
123303: DIFF
123304: ST_TO_ADDR
// if group [ i ] in to_repair then
123305: LD_VAR 0 4
123309: PUSH
123310: LD_VAR 0 7
123314: ARRAY
123315: PUSH
123316: LD_VAR 0 32
123320: IN
123321: IFFALSE 123368
// begin if not IsInArea ( group [ i ] , f_repair ) then
123323: LD_VAR 0 4
123327: PUSH
123328: LD_VAR 0 7
123332: ARRAY
123333: PPUSH
123334: LD_VAR 0 22
123338: PPUSH
123339: CALL_OW 308
123343: NOT
123344: IFFALSE 123366
// ComMoveToArea ( group [ i ] , f_repair ) ;
123346: LD_VAR 0 4
123350: PUSH
123351: LD_VAR 0 7
123355: ARRAY
123356: PPUSH
123357: LD_VAR 0 22
123361: PPUSH
123362: CALL_OW 113
// continue ;
123366: GO 122993
// end ; end else
123368: GO 123648
// if group [ i ] in repairs then
123370: LD_VAR 0 4
123374: PUSH
123375: LD_VAR 0 7
123379: ARRAY
123380: PUSH
123381: LD_VAR 0 33
123385: IN
123386: IFFALSE 123648
// begin if IsInUnit ( group [ i ] ) then
123388: LD_VAR 0 4
123392: PUSH
123393: LD_VAR 0 7
123397: ARRAY
123398: PPUSH
123399: CALL_OW 310
123403: IFFALSE 123471
// begin z := IsInUnit ( group [ i ] ) ;
123405: LD_ADDR_VAR 0 13
123409: PUSH
123410: LD_VAR 0 4
123414: PUSH
123415: LD_VAR 0 7
123419: ARRAY
123420: PPUSH
123421: CALL_OW 310
123425: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
123426: LD_VAR 0 13
123430: PUSH
123431: LD_VAR 0 32
123435: IN
123436: PUSH
123437: LD_VAR 0 13
123441: PPUSH
123442: LD_VAR 0 22
123446: PPUSH
123447: CALL_OW 308
123451: AND
123452: IFFALSE 123469
// ComExitVehicle ( group [ i ] ) ;
123454: LD_VAR 0 4
123458: PUSH
123459: LD_VAR 0 7
123463: ARRAY
123464: PPUSH
123465: CALL_OW 121
// end else
123469: GO 123648
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
123471: LD_ADDR_VAR 0 13
123475: PUSH
123476: LD_VAR 0 4
123480: PPUSH
123481: LD_INT 95
123483: PUSH
123484: LD_VAR 0 22
123488: PUSH
123489: EMPTY
123490: LIST
123491: LIST
123492: PUSH
123493: LD_INT 58
123495: PUSH
123496: EMPTY
123497: LIST
123498: PUSH
123499: EMPTY
123500: LIST
123501: LIST
123502: PPUSH
123503: CALL_OW 72
123507: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
123508: LD_VAR 0 4
123512: PUSH
123513: LD_VAR 0 7
123517: ARRAY
123518: PPUSH
123519: CALL_OW 314
123523: NOT
123524: IFFALSE 123646
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
123526: LD_ADDR_VAR 0 10
123530: PUSH
123531: LD_VAR 0 13
123535: PPUSH
123536: LD_VAR 0 4
123540: PUSH
123541: LD_VAR 0 7
123545: ARRAY
123546: PPUSH
123547: CALL_OW 74
123551: ST_TO_ADDR
// if not x then
123552: LD_VAR 0 10
123556: NOT
123557: IFFALSE 123561
// continue ;
123559: GO 122993
// if GetLives ( x ) < 1000 then
123561: LD_VAR 0 10
123565: PPUSH
123566: CALL_OW 256
123570: PUSH
123571: LD_INT 1000
123573: LESS
123574: IFFALSE 123598
// ComRepairVehicle ( group [ i ] , x ) else
123576: LD_VAR 0 4
123580: PUSH
123581: LD_VAR 0 7
123585: ARRAY
123586: PPUSH
123587: LD_VAR 0 10
123591: PPUSH
123592: CALL_OW 129
123596: GO 123646
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
123598: LD_VAR 0 23
123602: PUSH
123603: LD_VAR 0 4
123607: PUSH
123608: LD_VAR 0 7
123612: ARRAY
123613: PPUSH
123614: CALL_OW 256
123618: PUSH
123619: LD_INT 1000
123621: LESS
123622: AND
123623: NOT
123624: IFFALSE 123646
// ComEnterUnit ( group [ i ] , x ) ;
123626: LD_VAR 0 4
123630: PUSH
123631: LD_VAR 0 7
123635: ARRAY
123636: PPUSH
123637: LD_VAR 0 10
123641: PPUSH
123642: CALL_OW 120
// end ; continue ;
123646: GO 122993
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
123648: LD_VAR 0 23
123652: PUSH
123653: LD_VAR 0 4
123657: PUSH
123658: LD_VAR 0 7
123662: ARRAY
123663: PPUSH
123664: CALL_OW 247
123668: PUSH
123669: LD_INT 1
123671: EQUAL
123672: AND
123673: IFFALSE 124151
// begin if group [ i ] in healers then
123675: LD_VAR 0 4
123679: PUSH
123680: LD_VAR 0 7
123684: ARRAY
123685: PUSH
123686: LD_VAR 0 31
123690: IN
123691: IFFALSE 123964
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
123693: LD_VAR 0 4
123697: PUSH
123698: LD_VAR 0 7
123702: ARRAY
123703: PPUSH
123704: LD_VAR 0 23
123708: PPUSH
123709: CALL_OW 308
123713: NOT
123714: PUSH
123715: LD_VAR 0 4
123719: PUSH
123720: LD_VAR 0 7
123724: ARRAY
123725: PPUSH
123726: CALL_OW 314
123730: NOT
123731: AND
123732: IFFALSE 123756
// ComMoveToArea ( group [ i ] , f_heal ) else
123734: LD_VAR 0 4
123738: PUSH
123739: LD_VAR 0 7
123743: ARRAY
123744: PPUSH
123745: LD_VAR 0 23
123749: PPUSH
123750: CALL_OW 113
123754: GO 123962
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
123756: LD_VAR 0 4
123760: PUSH
123761: LD_VAR 0 7
123765: ARRAY
123766: PPUSH
123767: CALL 99780 0 1
123771: PPUSH
123772: CALL_OW 256
123776: PUSH
123777: LD_INT 1000
123779: EQUAL
123780: IFFALSE 123799
// ComStop ( group [ i ] ) else
123782: LD_VAR 0 4
123786: PUSH
123787: LD_VAR 0 7
123791: ARRAY
123792: PPUSH
123793: CALL_OW 141
123797: GO 123962
// if not HasTask ( group [ i ] ) and to_heal then
123799: LD_VAR 0 4
123803: PUSH
123804: LD_VAR 0 7
123808: ARRAY
123809: PPUSH
123810: CALL_OW 314
123814: NOT
123815: PUSH
123816: LD_VAR 0 30
123820: AND
123821: IFFALSE 123962
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
123823: LD_ADDR_VAR 0 13
123827: PUSH
123828: LD_VAR 0 30
123832: PPUSH
123833: LD_INT 3
123835: PUSH
123836: LD_INT 54
123838: PUSH
123839: EMPTY
123840: LIST
123841: PUSH
123842: EMPTY
123843: LIST
123844: LIST
123845: PPUSH
123846: CALL_OW 72
123850: PPUSH
123851: LD_VAR 0 4
123855: PUSH
123856: LD_VAR 0 7
123860: ARRAY
123861: PPUSH
123862: CALL_OW 74
123866: ST_TO_ADDR
// if z then
123867: LD_VAR 0 13
123871: IFFALSE 123962
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
123873: LD_INT 91
123875: PUSH
123876: LD_VAR 0 13
123880: PUSH
123881: LD_INT 10
123883: PUSH
123884: EMPTY
123885: LIST
123886: LIST
123887: LIST
123888: PUSH
123889: LD_INT 81
123891: PUSH
123892: LD_VAR 0 13
123896: PPUSH
123897: CALL_OW 255
123901: PUSH
123902: EMPTY
123903: LIST
123904: LIST
123905: PUSH
123906: EMPTY
123907: LIST
123908: LIST
123909: PPUSH
123910: CALL_OW 69
123914: PUSH
123915: LD_INT 0
123917: EQUAL
123918: IFFALSE 123942
// ComHeal ( group [ i ] , z ) else
123920: LD_VAR 0 4
123924: PUSH
123925: LD_VAR 0 7
123929: ARRAY
123930: PPUSH
123931: LD_VAR 0 13
123935: PPUSH
123936: CALL_OW 128
123940: GO 123962
// ComMoveToArea ( group [ i ] , f_heal ) ;
123942: LD_VAR 0 4
123946: PUSH
123947: LD_VAR 0 7
123951: ARRAY
123952: PPUSH
123953: LD_VAR 0 23
123957: PPUSH
123958: CALL_OW 113
// end ; continue ;
123962: GO 122993
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
123964: LD_VAR 0 4
123968: PUSH
123969: LD_VAR 0 7
123973: ARRAY
123974: PPUSH
123975: CALL_OW 256
123979: PUSH
123980: LD_INT 700
123982: LESS
123983: PUSH
123984: LD_VAR 0 4
123988: PUSH
123989: LD_VAR 0 7
123993: ARRAY
123994: PUSH
123995: LD_VAR 0 30
123999: IN
124000: NOT
124001: AND
124002: IFFALSE 124026
// to_heal := to_heal union group [ i ] ;
124004: LD_ADDR_VAR 0 30
124008: PUSH
124009: LD_VAR 0 30
124013: PUSH
124014: LD_VAR 0 4
124018: PUSH
124019: LD_VAR 0 7
124023: ARRAY
124024: UNION
124025: ST_TO_ADDR
// if group [ i ] in to_heal then
124026: LD_VAR 0 4
124030: PUSH
124031: LD_VAR 0 7
124035: ARRAY
124036: PUSH
124037: LD_VAR 0 30
124041: IN
124042: IFFALSE 124151
// begin if GetLives ( group [ i ] ) = 1000 then
124044: LD_VAR 0 4
124048: PUSH
124049: LD_VAR 0 7
124053: ARRAY
124054: PPUSH
124055: CALL_OW 256
124059: PUSH
124060: LD_INT 1000
124062: EQUAL
124063: IFFALSE 124089
// to_heal := to_heal diff group [ i ] else
124065: LD_ADDR_VAR 0 30
124069: PUSH
124070: LD_VAR 0 30
124074: PUSH
124075: LD_VAR 0 4
124079: PUSH
124080: LD_VAR 0 7
124084: ARRAY
124085: DIFF
124086: ST_TO_ADDR
124087: GO 124151
// begin if not IsInArea ( group [ i ] , to_heal ) then
124089: LD_VAR 0 4
124093: PUSH
124094: LD_VAR 0 7
124098: ARRAY
124099: PPUSH
124100: LD_VAR 0 30
124104: PPUSH
124105: CALL_OW 308
124109: NOT
124110: IFFALSE 124134
// ComMoveToArea ( group [ i ] , f_heal ) else
124112: LD_VAR 0 4
124116: PUSH
124117: LD_VAR 0 7
124121: ARRAY
124122: PPUSH
124123: LD_VAR 0 23
124127: PPUSH
124128: CALL_OW 113
124132: GO 124149
// ComHold ( group [ i ] ) ;
124134: LD_VAR 0 4
124138: PUSH
124139: LD_VAR 0 7
124143: ARRAY
124144: PPUSH
124145: CALL_OW 140
// continue ;
124149: GO 122993
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
124151: LD_VAR 0 4
124155: PUSH
124156: LD_VAR 0 7
124160: ARRAY
124161: PPUSH
124162: LD_INT 10
124164: PPUSH
124165: CALL 98200 0 2
124169: NOT
124170: PUSH
124171: LD_VAR 0 16
124175: PUSH
124176: LD_VAR 0 7
124180: ARRAY
124181: PUSH
124182: EMPTY
124183: EQUAL
124184: NOT
124185: AND
124186: IFFALSE 124452
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
124188: LD_VAR 0 4
124192: PUSH
124193: LD_VAR 0 7
124197: ARRAY
124198: PPUSH
124199: CALL_OW 262
124203: PUSH
124204: LD_INT 1
124206: PUSH
124207: LD_INT 2
124209: PUSH
124210: EMPTY
124211: LIST
124212: LIST
124213: IN
124214: IFFALSE 124255
// if GetFuel ( group [ i ] ) < 10 then
124216: LD_VAR 0 4
124220: PUSH
124221: LD_VAR 0 7
124225: ARRAY
124226: PPUSH
124227: CALL_OW 261
124231: PUSH
124232: LD_INT 10
124234: LESS
124235: IFFALSE 124255
// SetFuel ( group [ i ] , 12 ) ;
124237: LD_VAR 0 4
124241: PUSH
124242: LD_VAR 0 7
124246: ARRAY
124247: PPUSH
124248: LD_INT 12
124250: PPUSH
124251: CALL_OW 240
// if units_path [ i ] then
124255: LD_VAR 0 16
124259: PUSH
124260: LD_VAR 0 7
124264: ARRAY
124265: IFFALSE 124450
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
124267: LD_VAR 0 4
124271: PUSH
124272: LD_VAR 0 7
124276: ARRAY
124277: PPUSH
124278: LD_VAR 0 16
124282: PUSH
124283: LD_VAR 0 7
124287: ARRAY
124288: PUSH
124289: LD_INT 1
124291: ARRAY
124292: PUSH
124293: LD_INT 1
124295: ARRAY
124296: PPUSH
124297: LD_VAR 0 16
124301: PUSH
124302: LD_VAR 0 7
124306: ARRAY
124307: PUSH
124308: LD_INT 1
124310: ARRAY
124311: PUSH
124312: LD_INT 2
124314: ARRAY
124315: PPUSH
124316: CALL_OW 297
124320: PUSH
124321: LD_INT 6
124323: GREATER
124324: IFFALSE 124399
// begin if not HasTask ( group [ i ] ) then
124326: LD_VAR 0 4
124330: PUSH
124331: LD_VAR 0 7
124335: ARRAY
124336: PPUSH
124337: CALL_OW 314
124341: NOT
124342: IFFALSE 124397
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
124344: LD_VAR 0 4
124348: PUSH
124349: LD_VAR 0 7
124353: ARRAY
124354: PPUSH
124355: LD_VAR 0 16
124359: PUSH
124360: LD_VAR 0 7
124364: ARRAY
124365: PUSH
124366: LD_INT 1
124368: ARRAY
124369: PUSH
124370: LD_INT 1
124372: ARRAY
124373: PPUSH
124374: LD_VAR 0 16
124378: PUSH
124379: LD_VAR 0 7
124383: ARRAY
124384: PUSH
124385: LD_INT 1
124387: ARRAY
124388: PUSH
124389: LD_INT 2
124391: ARRAY
124392: PPUSH
124393: CALL_OW 114
// end else
124397: GO 124450
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
124399: LD_ADDR_VAR 0 15
124403: PUSH
124404: LD_VAR 0 16
124408: PUSH
124409: LD_VAR 0 7
124413: ARRAY
124414: PPUSH
124415: LD_INT 1
124417: PPUSH
124418: CALL_OW 3
124422: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
124423: LD_ADDR_VAR 0 16
124427: PUSH
124428: LD_VAR 0 16
124432: PPUSH
124433: LD_VAR 0 7
124437: PPUSH
124438: LD_VAR 0 15
124442: PPUSH
124443: CALL_OW 1
124447: ST_TO_ADDR
// continue ;
124448: GO 122993
// end ; end ; end else
124450: GO 127114
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
124452: LD_ADDR_VAR 0 14
124456: PUSH
124457: LD_INT 81
124459: PUSH
124460: LD_VAR 0 4
124464: PUSH
124465: LD_VAR 0 7
124469: ARRAY
124470: PPUSH
124471: CALL_OW 255
124475: PUSH
124476: EMPTY
124477: LIST
124478: LIST
124479: PPUSH
124480: CALL_OW 69
124484: ST_TO_ADDR
// if not tmp then
124485: LD_VAR 0 14
124489: NOT
124490: IFFALSE 124494
// continue ;
124492: GO 122993
// if f_ignore_area then
124494: LD_VAR 0 17
124498: IFFALSE 124586
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
124500: LD_ADDR_VAR 0 15
124504: PUSH
124505: LD_VAR 0 14
124509: PPUSH
124510: LD_INT 3
124512: PUSH
124513: LD_INT 92
124515: PUSH
124516: LD_VAR 0 17
124520: PUSH
124521: LD_INT 1
124523: ARRAY
124524: PUSH
124525: LD_VAR 0 17
124529: PUSH
124530: LD_INT 2
124532: ARRAY
124533: PUSH
124534: LD_VAR 0 17
124538: PUSH
124539: LD_INT 3
124541: ARRAY
124542: PUSH
124543: EMPTY
124544: LIST
124545: LIST
124546: LIST
124547: LIST
124548: PUSH
124549: EMPTY
124550: LIST
124551: LIST
124552: PPUSH
124553: CALL_OW 72
124557: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124558: LD_VAR 0 14
124562: PUSH
124563: LD_VAR 0 15
124567: DIFF
124568: IFFALSE 124586
// tmp := tmp diff tmp2 ;
124570: LD_ADDR_VAR 0 14
124574: PUSH
124575: LD_VAR 0 14
124579: PUSH
124580: LD_VAR 0 15
124584: DIFF
124585: ST_TO_ADDR
// end ; if not f_murder then
124586: LD_VAR 0 20
124590: NOT
124591: IFFALSE 124649
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
124593: LD_ADDR_VAR 0 15
124597: PUSH
124598: LD_VAR 0 14
124602: PPUSH
124603: LD_INT 3
124605: PUSH
124606: LD_INT 50
124608: PUSH
124609: EMPTY
124610: LIST
124611: PUSH
124612: EMPTY
124613: LIST
124614: LIST
124615: PPUSH
124616: CALL_OW 72
124620: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124621: LD_VAR 0 14
124625: PUSH
124626: LD_VAR 0 15
124630: DIFF
124631: IFFALSE 124649
// tmp := tmp diff tmp2 ;
124633: LD_ADDR_VAR 0 14
124637: PUSH
124638: LD_VAR 0 14
124642: PUSH
124643: LD_VAR 0 15
124647: DIFF
124648: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
124649: LD_ADDR_VAR 0 14
124653: PUSH
124654: LD_VAR 0 4
124658: PUSH
124659: LD_VAR 0 7
124663: ARRAY
124664: PPUSH
124665: LD_VAR 0 14
124669: PPUSH
124670: LD_INT 1
124672: PPUSH
124673: LD_INT 1
124675: PPUSH
124676: CALL 71135 0 4
124680: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
124681: LD_VAR 0 4
124685: PUSH
124686: LD_VAR 0 7
124690: ARRAY
124691: PPUSH
124692: CALL_OW 257
124696: PUSH
124697: LD_INT 1
124699: EQUAL
124700: IFFALSE 125148
// begin if WantPlant ( group [ i ] ) then
124702: LD_VAR 0 4
124706: PUSH
124707: LD_VAR 0 7
124711: ARRAY
124712: PPUSH
124713: CALL 70636 0 1
124717: IFFALSE 124721
// continue ;
124719: GO 122993
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
124721: LD_VAR 0 18
124725: PUSH
124726: LD_VAR 0 4
124730: PUSH
124731: LD_VAR 0 7
124735: ARRAY
124736: PPUSH
124737: CALL_OW 310
124741: NOT
124742: AND
124743: PUSH
124744: LD_VAR 0 14
124748: PUSH
124749: LD_INT 1
124751: ARRAY
124752: PUSH
124753: LD_VAR 0 14
124757: PPUSH
124758: LD_INT 21
124760: PUSH
124761: LD_INT 2
124763: PUSH
124764: EMPTY
124765: LIST
124766: LIST
124767: PUSH
124768: LD_INT 58
124770: PUSH
124771: EMPTY
124772: LIST
124773: PUSH
124774: EMPTY
124775: LIST
124776: LIST
124777: PPUSH
124778: CALL_OW 72
124782: IN
124783: AND
124784: IFFALSE 124820
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
124786: LD_VAR 0 4
124790: PUSH
124791: LD_VAR 0 7
124795: ARRAY
124796: PPUSH
124797: LD_VAR 0 14
124801: PUSH
124802: LD_INT 1
124804: ARRAY
124805: PPUSH
124806: CALL_OW 120
// attacking := true ;
124810: LD_ADDR_VAR 0 29
124814: PUSH
124815: LD_INT 1
124817: ST_TO_ADDR
// continue ;
124818: GO 122993
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
124820: LD_VAR 0 26
124824: PUSH
124825: LD_VAR 0 4
124829: PUSH
124830: LD_VAR 0 7
124834: ARRAY
124835: PPUSH
124836: CALL_OW 257
124840: PUSH
124841: LD_INT 1
124843: EQUAL
124844: AND
124845: PUSH
124846: LD_VAR 0 4
124850: PUSH
124851: LD_VAR 0 7
124855: ARRAY
124856: PPUSH
124857: CALL_OW 256
124861: PUSH
124862: LD_INT 800
124864: LESS
124865: AND
124866: PUSH
124867: LD_VAR 0 4
124871: PUSH
124872: LD_VAR 0 7
124876: ARRAY
124877: PPUSH
124878: CALL_OW 318
124882: NOT
124883: AND
124884: IFFALSE 124901
// ComCrawl ( group [ i ] ) ;
124886: LD_VAR 0 4
124890: PUSH
124891: LD_VAR 0 7
124895: ARRAY
124896: PPUSH
124897: CALL_OW 137
// if f_mines then
124901: LD_VAR 0 21
124905: IFFALSE 125148
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
124907: LD_VAR 0 14
124911: PUSH
124912: LD_INT 1
124914: ARRAY
124915: PPUSH
124916: CALL_OW 247
124920: PUSH
124921: LD_INT 3
124923: EQUAL
124924: PUSH
124925: LD_VAR 0 14
124929: PUSH
124930: LD_INT 1
124932: ARRAY
124933: PUSH
124934: LD_VAR 0 27
124938: IN
124939: NOT
124940: AND
124941: IFFALSE 125148
// begin x := GetX ( tmp [ 1 ] ) ;
124943: LD_ADDR_VAR 0 10
124947: PUSH
124948: LD_VAR 0 14
124952: PUSH
124953: LD_INT 1
124955: ARRAY
124956: PPUSH
124957: CALL_OW 250
124961: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
124962: LD_ADDR_VAR 0 11
124966: PUSH
124967: LD_VAR 0 14
124971: PUSH
124972: LD_INT 1
124974: ARRAY
124975: PPUSH
124976: CALL_OW 251
124980: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
124981: LD_ADDR_VAR 0 12
124985: PUSH
124986: LD_VAR 0 4
124990: PUSH
124991: LD_VAR 0 7
124995: ARRAY
124996: PPUSH
124997: CALL 98285 0 1
125001: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
125002: LD_VAR 0 4
125006: PUSH
125007: LD_VAR 0 7
125011: ARRAY
125012: PPUSH
125013: LD_VAR 0 10
125017: PPUSH
125018: LD_VAR 0 11
125022: PPUSH
125023: LD_VAR 0 14
125027: PUSH
125028: LD_INT 1
125030: ARRAY
125031: PPUSH
125032: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
125036: LD_VAR 0 4
125040: PUSH
125041: LD_VAR 0 7
125045: ARRAY
125046: PPUSH
125047: LD_VAR 0 10
125051: PPUSH
125052: LD_VAR 0 12
125056: PPUSH
125057: LD_INT 7
125059: PPUSH
125060: CALL_OW 272
125064: PPUSH
125065: LD_VAR 0 11
125069: PPUSH
125070: LD_VAR 0 12
125074: PPUSH
125075: LD_INT 7
125077: PPUSH
125078: CALL_OW 273
125082: PPUSH
125083: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
125087: LD_VAR 0 4
125091: PUSH
125092: LD_VAR 0 7
125096: ARRAY
125097: PPUSH
125098: LD_INT 71
125100: PPUSH
125101: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
125105: LD_ADDR_VAR 0 27
125109: PUSH
125110: LD_VAR 0 27
125114: PPUSH
125115: LD_VAR 0 27
125119: PUSH
125120: LD_INT 1
125122: PLUS
125123: PPUSH
125124: LD_VAR 0 14
125128: PUSH
125129: LD_INT 1
125131: ARRAY
125132: PPUSH
125133: CALL_OW 1
125137: ST_TO_ADDR
// attacking := true ;
125138: LD_ADDR_VAR 0 29
125142: PUSH
125143: LD_INT 1
125145: ST_TO_ADDR
// continue ;
125146: GO 122993
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
125148: LD_VAR 0 4
125152: PUSH
125153: LD_VAR 0 7
125157: ARRAY
125158: PPUSH
125159: CALL_OW 257
125163: PUSH
125164: LD_INT 17
125166: EQUAL
125167: PUSH
125168: LD_VAR 0 4
125172: PUSH
125173: LD_VAR 0 7
125177: ARRAY
125178: PPUSH
125179: CALL_OW 110
125183: PUSH
125184: LD_INT 71
125186: EQUAL
125187: NOT
125188: AND
125189: IFFALSE 125335
// begin attacking := false ;
125191: LD_ADDR_VAR 0 29
125195: PUSH
125196: LD_INT 0
125198: ST_TO_ADDR
// k := 5 ;
125199: LD_ADDR_VAR 0 9
125203: PUSH
125204: LD_INT 5
125206: ST_TO_ADDR
// if tmp < k then
125207: LD_VAR 0 14
125211: PUSH
125212: LD_VAR 0 9
125216: LESS
125217: IFFALSE 125229
// k := tmp ;
125219: LD_ADDR_VAR 0 9
125223: PUSH
125224: LD_VAR 0 14
125228: ST_TO_ADDR
// for j = 1 to k do
125229: LD_ADDR_VAR 0 8
125233: PUSH
125234: DOUBLE
125235: LD_INT 1
125237: DEC
125238: ST_TO_ADDR
125239: LD_VAR 0 9
125243: PUSH
125244: FOR_TO
125245: IFFALSE 125333
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
125247: LD_VAR 0 14
125251: PUSH
125252: LD_VAR 0 8
125256: ARRAY
125257: PUSH
125258: LD_VAR 0 14
125262: PPUSH
125263: LD_INT 58
125265: PUSH
125266: EMPTY
125267: LIST
125268: PPUSH
125269: CALL_OW 72
125273: IN
125274: NOT
125275: IFFALSE 125331
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125277: LD_VAR 0 4
125281: PUSH
125282: LD_VAR 0 7
125286: ARRAY
125287: PPUSH
125288: LD_VAR 0 14
125292: PUSH
125293: LD_VAR 0 8
125297: ARRAY
125298: PPUSH
125299: CALL_OW 115
// attacking := true ;
125303: LD_ADDR_VAR 0 29
125307: PUSH
125308: LD_INT 1
125310: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
125311: LD_VAR 0 4
125315: PUSH
125316: LD_VAR 0 7
125320: ARRAY
125321: PPUSH
125322: LD_INT 71
125324: PPUSH
125325: CALL_OW 109
// continue ;
125329: GO 125244
// end ; end ;
125331: GO 125244
125333: POP
125334: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
125335: LD_VAR 0 4
125339: PUSH
125340: LD_VAR 0 7
125344: ARRAY
125345: PPUSH
125346: CALL_OW 257
125350: PUSH
125351: LD_INT 8
125353: EQUAL
125354: PUSH
125355: LD_VAR 0 4
125359: PUSH
125360: LD_VAR 0 7
125364: ARRAY
125365: PPUSH
125366: CALL_OW 264
125370: PUSH
125371: LD_INT 28
125373: PUSH
125374: LD_INT 45
125376: PUSH
125377: LD_INT 7
125379: PUSH
125380: LD_INT 47
125382: PUSH
125383: EMPTY
125384: LIST
125385: LIST
125386: LIST
125387: LIST
125388: IN
125389: OR
125390: IFFALSE 125646
// begin attacking := false ;
125392: LD_ADDR_VAR 0 29
125396: PUSH
125397: LD_INT 0
125399: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
125400: LD_VAR 0 14
125404: PUSH
125405: LD_INT 1
125407: ARRAY
125408: PPUSH
125409: CALL_OW 266
125413: PUSH
125414: LD_INT 32
125416: PUSH
125417: LD_INT 31
125419: PUSH
125420: LD_INT 33
125422: PUSH
125423: LD_INT 4
125425: PUSH
125426: LD_INT 5
125428: PUSH
125429: EMPTY
125430: LIST
125431: LIST
125432: LIST
125433: LIST
125434: LIST
125435: IN
125436: IFFALSE 125622
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
125438: LD_ADDR_VAR 0 9
125442: PUSH
125443: LD_VAR 0 14
125447: PUSH
125448: LD_INT 1
125450: ARRAY
125451: PPUSH
125452: CALL_OW 266
125456: PPUSH
125457: LD_VAR 0 14
125461: PUSH
125462: LD_INT 1
125464: ARRAY
125465: PPUSH
125466: CALL_OW 250
125470: PPUSH
125471: LD_VAR 0 14
125475: PUSH
125476: LD_INT 1
125478: ARRAY
125479: PPUSH
125480: CALL_OW 251
125484: PPUSH
125485: LD_VAR 0 14
125489: PUSH
125490: LD_INT 1
125492: ARRAY
125493: PPUSH
125494: CALL_OW 254
125498: PPUSH
125499: LD_VAR 0 14
125503: PUSH
125504: LD_INT 1
125506: ARRAY
125507: PPUSH
125508: CALL_OW 248
125512: PPUSH
125513: LD_INT 0
125515: PPUSH
125516: CALL 79655 0 6
125520: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
125521: LD_ADDR_VAR 0 8
125525: PUSH
125526: LD_VAR 0 4
125530: PUSH
125531: LD_VAR 0 7
125535: ARRAY
125536: PPUSH
125537: LD_VAR 0 9
125541: PPUSH
125542: CALL 98325 0 2
125546: ST_TO_ADDR
// if j then
125547: LD_VAR 0 8
125551: IFFALSE 125620
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
125553: LD_VAR 0 8
125557: PUSH
125558: LD_INT 1
125560: ARRAY
125561: PPUSH
125562: LD_VAR 0 8
125566: PUSH
125567: LD_INT 2
125569: ARRAY
125570: PPUSH
125571: CALL_OW 488
125575: IFFALSE 125620
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
125577: LD_VAR 0 4
125581: PUSH
125582: LD_VAR 0 7
125586: ARRAY
125587: PPUSH
125588: LD_VAR 0 8
125592: PUSH
125593: LD_INT 1
125595: ARRAY
125596: PPUSH
125597: LD_VAR 0 8
125601: PUSH
125602: LD_INT 2
125604: ARRAY
125605: PPUSH
125606: CALL_OW 116
// attacking := true ;
125610: LD_ADDR_VAR 0 29
125614: PUSH
125615: LD_INT 1
125617: ST_TO_ADDR
// continue ;
125618: GO 122993
// end ; end else
125620: GO 125646
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125622: LD_VAR 0 4
125626: PUSH
125627: LD_VAR 0 7
125631: ARRAY
125632: PPUSH
125633: LD_VAR 0 14
125637: PUSH
125638: LD_INT 1
125640: ARRAY
125641: PPUSH
125642: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
125646: LD_VAR 0 4
125650: PUSH
125651: LD_VAR 0 7
125655: ARRAY
125656: PPUSH
125657: CALL_OW 265
125661: PUSH
125662: LD_INT 11
125664: EQUAL
125665: IFFALSE 125943
// begin k := 10 ;
125667: LD_ADDR_VAR 0 9
125671: PUSH
125672: LD_INT 10
125674: ST_TO_ADDR
// x := 0 ;
125675: LD_ADDR_VAR 0 10
125679: PUSH
125680: LD_INT 0
125682: ST_TO_ADDR
// if tmp < k then
125683: LD_VAR 0 14
125687: PUSH
125688: LD_VAR 0 9
125692: LESS
125693: IFFALSE 125705
// k := tmp ;
125695: LD_ADDR_VAR 0 9
125699: PUSH
125700: LD_VAR 0 14
125704: ST_TO_ADDR
// for j = k downto 1 do
125705: LD_ADDR_VAR 0 8
125709: PUSH
125710: DOUBLE
125711: LD_VAR 0 9
125715: INC
125716: ST_TO_ADDR
125717: LD_INT 1
125719: PUSH
125720: FOR_DOWNTO
125721: IFFALSE 125796
// begin if GetType ( tmp [ j ] ) = unit_human then
125723: LD_VAR 0 14
125727: PUSH
125728: LD_VAR 0 8
125732: ARRAY
125733: PPUSH
125734: CALL_OW 247
125738: PUSH
125739: LD_INT 1
125741: EQUAL
125742: IFFALSE 125794
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
125744: LD_VAR 0 4
125748: PUSH
125749: LD_VAR 0 7
125753: ARRAY
125754: PPUSH
125755: LD_VAR 0 14
125759: PUSH
125760: LD_VAR 0 8
125764: ARRAY
125765: PPUSH
125766: CALL 98596 0 2
// x := tmp [ j ] ;
125770: LD_ADDR_VAR 0 10
125774: PUSH
125775: LD_VAR 0 14
125779: PUSH
125780: LD_VAR 0 8
125784: ARRAY
125785: ST_TO_ADDR
// attacking := true ;
125786: LD_ADDR_VAR 0 29
125790: PUSH
125791: LD_INT 1
125793: ST_TO_ADDR
// end ; end ;
125794: GO 125720
125796: POP
125797: POP
// if not x then
125798: LD_VAR 0 10
125802: NOT
125803: IFFALSE 125943
// begin attacking := true ;
125805: LD_ADDR_VAR 0 29
125809: PUSH
125810: LD_INT 1
125812: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
125813: LD_VAR 0 4
125817: PUSH
125818: LD_VAR 0 7
125822: ARRAY
125823: PPUSH
125824: CALL_OW 250
125828: PPUSH
125829: LD_VAR 0 4
125833: PUSH
125834: LD_VAR 0 7
125838: ARRAY
125839: PPUSH
125840: CALL_OW 251
125844: PPUSH
125845: CALL_OW 546
125849: PUSH
125850: LD_INT 2
125852: ARRAY
125853: PUSH
125854: LD_VAR 0 14
125858: PUSH
125859: LD_INT 1
125861: ARRAY
125862: PPUSH
125863: CALL_OW 250
125867: PPUSH
125868: LD_VAR 0 14
125872: PUSH
125873: LD_INT 1
125875: ARRAY
125876: PPUSH
125877: CALL_OW 251
125881: PPUSH
125882: CALL_OW 546
125886: PUSH
125887: LD_INT 2
125889: ARRAY
125890: EQUAL
125891: IFFALSE 125919
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
125893: LD_VAR 0 4
125897: PUSH
125898: LD_VAR 0 7
125902: ARRAY
125903: PPUSH
125904: LD_VAR 0 14
125908: PUSH
125909: LD_INT 1
125911: ARRAY
125912: PPUSH
125913: CALL 98596 0 2
125917: GO 125943
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125919: LD_VAR 0 4
125923: PUSH
125924: LD_VAR 0 7
125928: ARRAY
125929: PPUSH
125930: LD_VAR 0 14
125934: PUSH
125935: LD_INT 1
125937: ARRAY
125938: PPUSH
125939: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
125943: LD_VAR 0 4
125947: PUSH
125948: LD_VAR 0 7
125952: ARRAY
125953: PPUSH
125954: CALL_OW 264
125958: PUSH
125959: LD_INT 29
125961: EQUAL
125962: IFFALSE 126328
// begin if WantsToAttack ( group [ i ] ) in bombed then
125964: LD_VAR 0 4
125968: PUSH
125969: LD_VAR 0 7
125973: ARRAY
125974: PPUSH
125975: CALL_OW 319
125979: PUSH
125980: LD_VAR 0 28
125984: IN
125985: IFFALSE 125989
// continue ;
125987: GO 122993
// k := 8 ;
125989: LD_ADDR_VAR 0 9
125993: PUSH
125994: LD_INT 8
125996: ST_TO_ADDR
// x := 0 ;
125997: LD_ADDR_VAR 0 10
126001: PUSH
126002: LD_INT 0
126004: ST_TO_ADDR
// if tmp < k then
126005: LD_VAR 0 14
126009: PUSH
126010: LD_VAR 0 9
126014: LESS
126015: IFFALSE 126027
// k := tmp ;
126017: LD_ADDR_VAR 0 9
126021: PUSH
126022: LD_VAR 0 14
126026: ST_TO_ADDR
// for j = 1 to k do
126027: LD_ADDR_VAR 0 8
126031: PUSH
126032: DOUBLE
126033: LD_INT 1
126035: DEC
126036: ST_TO_ADDR
126037: LD_VAR 0 9
126041: PUSH
126042: FOR_TO
126043: IFFALSE 126175
// begin if GetType ( tmp [ j ] ) = unit_building then
126045: LD_VAR 0 14
126049: PUSH
126050: LD_VAR 0 8
126054: ARRAY
126055: PPUSH
126056: CALL_OW 247
126060: PUSH
126061: LD_INT 3
126063: EQUAL
126064: IFFALSE 126173
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
126066: LD_VAR 0 14
126070: PUSH
126071: LD_VAR 0 8
126075: ARRAY
126076: PUSH
126077: LD_VAR 0 28
126081: IN
126082: NOT
126083: PUSH
126084: LD_VAR 0 14
126088: PUSH
126089: LD_VAR 0 8
126093: ARRAY
126094: PPUSH
126095: CALL_OW 313
126099: AND
126100: IFFALSE 126173
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126102: LD_VAR 0 4
126106: PUSH
126107: LD_VAR 0 7
126111: ARRAY
126112: PPUSH
126113: LD_VAR 0 14
126117: PUSH
126118: LD_VAR 0 8
126122: ARRAY
126123: PPUSH
126124: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
126128: LD_ADDR_VAR 0 28
126132: PUSH
126133: LD_VAR 0 28
126137: PPUSH
126138: LD_VAR 0 28
126142: PUSH
126143: LD_INT 1
126145: PLUS
126146: PPUSH
126147: LD_VAR 0 14
126151: PUSH
126152: LD_VAR 0 8
126156: ARRAY
126157: PPUSH
126158: CALL_OW 1
126162: ST_TO_ADDR
// attacking := true ;
126163: LD_ADDR_VAR 0 29
126167: PUSH
126168: LD_INT 1
126170: ST_TO_ADDR
// break ;
126171: GO 126175
// end ; end ;
126173: GO 126042
126175: POP
126176: POP
// if not attacking and f_attack_depot then
126177: LD_VAR 0 29
126181: NOT
126182: PUSH
126183: LD_VAR 0 25
126187: AND
126188: IFFALSE 126283
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126190: LD_ADDR_VAR 0 13
126194: PUSH
126195: LD_VAR 0 14
126199: PPUSH
126200: LD_INT 2
126202: PUSH
126203: LD_INT 30
126205: PUSH
126206: LD_INT 0
126208: PUSH
126209: EMPTY
126210: LIST
126211: LIST
126212: PUSH
126213: LD_INT 30
126215: PUSH
126216: LD_INT 1
126218: PUSH
126219: EMPTY
126220: LIST
126221: LIST
126222: PUSH
126223: EMPTY
126224: LIST
126225: LIST
126226: LIST
126227: PPUSH
126228: CALL_OW 72
126232: ST_TO_ADDR
// if z then
126233: LD_VAR 0 13
126237: IFFALSE 126283
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
126239: LD_VAR 0 4
126243: PUSH
126244: LD_VAR 0 7
126248: ARRAY
126249: PPUSH
126250: LD_VAR 0 13
126254: PPUSH
126255: LD_VAR 0 4
126259: PUSH
126260: LD_VAR 0 7
126264: ARRAY
126265: PPUSH
126266: CALL_OW 74
126270: PPUSH
126271: CALL_OW 115
// attacking := true ;
126275: LD_ADDR_VAR 0 29
126279: PUSH
126280: LD_INT 1
126282: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
126283: LD_VAR 0 4
126287: PUSH
126288: LD_VAR 0 7
126292: ARRAY
126293: PPUSH
126294: CALL_OW 256
126298: PUSH
126299: LD_INT 500
126301: LESS
126302: IFFALSE 126328
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126304: LD_VAR 0 4
126308: PUSH
126309: LD_VAR 0 7
126313: ARRAY
126314: PPUSH
126315: LD_VAR 0 14
126319: PUSH
126320: LD_INT 1
126322: ARRAY
126323: PPUSH
126324: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
126328: LD_VAR 0 4
126332: PUSH
126333: LD_VAR 0 7
126337: ARRAY
126338: PPUSH
126339: CALL_OW 264
126343: PUSH
126344: LD_INT 49
126346: EQUAL
126347: IFFALSE 126468
// begin if not HasTask ( group [ i ] ) then
126349: LD_VAR 0 4
126353: PUSH
126354: LD_VAR 0 7
126358: ARRAY
126359: PPUSH
126360: CALL_OW 314
126364: NOT
126365: IFFALSE 126468
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
126367: LD_ADDR_VAR 0 9
126371: PUSH
126372: LD_INT 81
126374: PUSH
126375: LD_VAR 0 4
126379: PUSH
126380: LD_VAR 0 7
126384: ARRAY
126385: PPUSH
126386: CALL_OW 255
126390: PUSH
126391: EMPTY
126392: LIST
126393: LIST
126394: PPUSH
126395: CALL_OW 69
126399: PPUSH
126400: LD_VAR 0 4
126404: PUSH
126405: LD_VAR 0 7
126409: ARRAY
126410: PPUSH
126411: CALL_OW 74
126415: ST_TO_ADDR
// if k then
126416: LD_VAR 0 9
126420: IFFALSE 126468
// if GetDistUnits ( group [ i ] , k ) > 10 then
126422: LD_VAR 0 4
126426: PUSH
126427: LD_VAR 0 7
126431: ARRAY
126432: PPUSH
126433: LD_VAR 0 9
126437: PPUSH
126438: CALL_OW 296
126442: PUSH
126443: LD_INT 10
126445: GREATER
126446: IFFALSE 126468
// ComMoveUnit ( group [ i ] , k ) ;
126448: LD_VAR 0 4
126452: PUSH
126453: LD_VAR 0 7
126457: ARRAY
126458: PPUSH
126459: LD_VAR 0 9
126463: PPUSH
126464: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
126468: LD_VAR 0 4
126472: PUSH
126473: LD_VAR 0 7
126477: ARRAY
126478: PPUSH
126479: CALL_OW 256
126483: PUSH
126484: LD_INT 250
126486: LESS
126487: PUSH
126488: LD_VAR 0 4
126492: PUSH
126493: LD_VAR 0 7
126497: ARRAY
126498: PUSH
126499: LD_INT 21
126501: PUSH
126502: LD_INT 2
126504: PUSH
126505: EMPTY
126506: LIST
126507: LIST
126508: PUSH
126509: LD_INT 23
126511: PUSH
126512: LD_INT 2
126514: PUSH
126515: EMPTY
126516: LIST
126517: LIST
126518: PUSH
126519: EMPTY
126520: LIST
126521: LIST
126522: PPUSH
126523: CALL_OW 69
126527: IN
126528: AND
126529: IFFALSE 126654
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
126531: LD_ADDR_VAR 0 9
126535: PUSH
126536: LD_OWVAR 3
126540: PUSH
126541: LD_VAR 0 4
126545: PUSH
126546: LD_VAR 0 7
126550: ARRAY
126551: DIFF
126552: PPUSH
126553: LD_VAR 0 4
126557: PUSH
126558: LD_VAR 0 7
126562: ARRAY
126563: PPUSH
126564: CALL_OW 74
126568: ST_TO_ADDR
// if not k then
126569: LD_VAR 0 9
126573: NOT
126574: IFFALSE 126578
// continue ;
126576: GO 122993
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
126578: LD_VAR 0 9
126582: PUSH
126583: LD_INT 81
126585: PUSH
126586: LD_VAR 0 4
126590: PUSH
126591: LD_VAR 0 7
126595: ARRAY
126596: PPUSH
126597: CALL_OW 255
126601: PUSH
126602: EMPTY
126603: LIST
126604: LIST
126605: PPUSH
126606: CALL_OW 69
126610: IN
126611: PUSH
126612: LD_VAR 0 9
126616: PPUSH
126617: LD_VAR 0 4
126621: PUSH
126622: LD_VAR 0 7
126626: ARRAY
126627: PPUSH
126628: CALL_OW 296
126632: PUSH
126633: LD_INT 5
126635: LESS
126636: AND
126637: IFFALSE 126654
// ComAutodestruct ( group [ i ] ) ;
126639: LD_VAR 0 4
126643: PUSH
126644: LD_VAR 0 7
126648: ARRAY
126649: PPUSH
126650: CALL 98494 0 1
// end ; if f_attack_depot then
126654: LD_VAR 0 25
126658: IFFALSE 126770
// begin k := 6 ;
126660: LD_ADDR_VAR 0 9
126664: PUSH
126665: LD_INT 6
126667: ST_TO_ADDR
// if tmp < k then
126668: LD_VAR 0 14
126672: PUSH
126673: LD_VAR 0 9
126677: LESS
126678: IFFALSE 126690
// k := tmp ;
126680: LD_ADDR_VAR 0 9
126684: PUSH
126685: LD_VAR 0 14
126689: ST_TO_ADDR
// for j = 1 to k do
126690: LD_ADDR_VAR 0 8
126694: PUSH
126695: DOUBLE
126696: LD_INT 1
126698: DEC
126699: ST_TO_ADDR
126700: LD_VAR 0 9
126704: PUSH
126705: FOR_TO
126706: IFFALSE 126768
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
126708: LD_VAR 0 8
126712: PPUSH
126713: CALL_OW 266
126717: PUSH
126718: LD_INT 0
126720: PUSH
126721: LD_INT 1
126723: PUSH
126724: EMPTY
126725: LIST
126726: LIST
126727: IN
126728: IFFALSE 126766
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126730: LD_VAR 0 4
126734: PUSH
126735: LD_VAR 0 7
126739: ARRAY
126740: PPUSH
126741: LD_VAR 0 14
126745: PUSH
126746: LD_VAR 0 8
126750: ARRAY
126751: PPUSH
126752: CALL_OW 115
// attacking := true ;
126756: LD_ADDR_VAR 0 29
126760: PUSH
126761: LD_INT 1
126763: ST_TO_ADDR
// break ;
126764: GO 126768
// end ;
126766: GO 126705
126768: POP
126769: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
126770: LD_VAR 0 4
126774: PUSH
126775: LD_VAR 0 7
126779: ARRAY
126780: PPUSH
126781: CALL_OW 302
126785: PUSH
126786: LD_VAR 0 29
126790: NOT
126791: AND
126792: IFFALSE 127114
// begin if GetTag ( group [ i ] ) = 71 then
126794: LD_VAR 0 4
126798: PUSH
126799: LD_VAR 0 7
126803: ARRAY
126804: PPUSH
126805: CALL_OW 110
126809: PUSH
126810: LD_INT 71
126812: EQUAL
126813: IFFALSE 126854
// begin if HasTask ( group [ i ] ) then
126815: LD_VAR 0 4
126819: PUSH
126820: LD_VAR 0 7
126824: ARRAY
126825: PPUSH
126826: CALL_OW 314
126830: IFFALSE 126836
// continue else
126832: GO 122993
126834: GO 126854
// SetTag ( group [ i ] , 0 ) ;
126836: LD_VAR 0 4
126840: PUSH
126841: LD_VAR 0 7
126845: ARRAY
126846: PPUSH
126847: LD_INT 0
126849: PPUSH
126850: CALL_OW 109
// end ; k := 8 ;
126854: LD_ADDR_VAR 0 9
126858: PUSH
126859: LD_INT 8
126861: ST_TO_ADDR
// x := 0 ;
126862: LD_ADDR_VAR 0 10
126866: PUSH
126867: LD_INT 0
126869: ST_TO_ADDR
// if tmp < k then
126870: LD_VAR 0 14
126874: PUSH
126875: LD_VAR 0 9
126879: LESS
126880: IFFALSE 126892
// k := tmp ;
126882: LD_ADDR_VAR 0 9
126886: PUSH
126887: LD_VAR 0 14
126891: ST_TO_ADDR
// for j = 1 to k do
126892: LD_ADDR_VAR 0 8
126896: PUSH
126897: DOUBLE
126898: LD_INT 1
126900: DEC
126901: ST_TO_ADDR
126902: LD_VAR 0 9
126906: PUSH
126907: FOR_TO
126908: IFFALSE 127006
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
126910: LD_VAR 0 14
126914: PUSH
126915: LD_VAR 0 8
126919: ARRAY
126920: PPUSH
126921: CALL_OW 247
126925: PUSH
126926: LD_INT 1
126928: EQUAL
126929: PUSH
126930: LD_VAR 0 14
126934: PUSH
126935: LD_VAR 0 8
126939: ARRAY
126940: PPUSH
126941: CALL_OW 256
126945: PUSH
126946: LD_INT 250
126948: LESS
126949: PUSH
126950: LD_VAR 0 20
126954: AND
126955: PUSH
126956: LD_VAR 0 20
126960: NOT
126961: PUSH
126962: LD_VAR 0 14
126966: PUSH
126967: LD_VAR 0 8
126971: ARRAY
126972: PPUSH
126973: CALL_OW 256
126977: PUSH
126978: LD_INT 250
126980: GREATEREQUAL
126981: AND
126982: OR
126983: AND
126984: IFFALSE 127004
// begin x := tmp [ j ] ;
126986: LD_ADDR_VAR 0 10
126990: PUSH
126991: LD_VAR 0 14
126995: PUSH
126996: LD_VAR 0 8
127000: ARRAY
127001: ST_TO_ADDR
// break ;
127002: GO 127006
// end ;
127004: GO 126907
127006: POP
127007: POP
// if x then
127008: LD_VAR 0 10
127012: IFFALSE 127036
// ComAttackUnit ( group [ i ] , x ) else
127014: LD_VAR 0 4
127018: PUSH
127019: LD_VAR 0 7
127023: ARRAY
127024: PPUSH
127025: LD_VAR 0 10
127029: PPUSH
127030: CALL_OW 115
127034: GO 127060
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127036: LD_VAR 0 4
127040: PUSH
127041: LD_VAR 0 7
127045: ARRAY
127046: PPUSH
127047: LD_VAR 0 14
127051: PUSH
127052: LD_INT 1
127054: ARRAY
127055: PPUSH
127056: CALL_OW 115
// if not HasTask ( group [ i ] ) then
127060: LD_VAR 0 4
127064: PUSH
127065: LD_VAR 0 7
127069: ARRAY
127070: PPUSH
127071: CALL_OW 314
127075: NOT
127076: IFFALSE 127114
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
127078: LD_VAR 0 4
127082: PUSH
127083: LD_VAR 0 7
127087: ARRAY
127088: PPUSH
127089: LD_VAR 0 14
127093: PPUSH
127094: LD_VAR 0 4
127098: PUSH
127099: LD_VAR 0 7
127103: ARRAY
127104: PPUSH
127105: CALL_OW 74
127109: PPUSH
127110: CALL_OW 115
// end ; end ; end ;
127114: GO 122993
127116: POP
127117: POP
// wait ( 0 0$2 ) ;
127118: LD_INT 70
127120: PPUSH
127121: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
127125: LD_VAR 0 4
127129: NOT
127130: PUSH
127131: LD_VAR 0 4
127135: PUSH
127136: EMPTY
127137: EQUAL
127138: OR
127139: PUSH
127140: LD_INT 81
127142: PUSH
127143: LD_VAR 0 35
127147: PUSH
127148: EMPTY
127149: LIST
127150: LIST
127151: PPUSH
127152: CALL_OW 69
127156: NOT
127157: OR
127158: IFFALSE 122978
// end ;
127160: LD_VAR 0 2
127164: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
127165: LD_INT 0
127167: PPUSH
127168: PPUSH
127169: PPUSH
127170: PPUSH
127171: PPUSH
// if not base or not mc_bases [ base ] or not solds then
127172: LD_VAR 0 1
127176: NOT
127177: PUSH
127178: LD_EXP 116
127182: PUSH
127183: LD_VAR 0 1
127187: ARRAY
127188: NOT
127189: OR
127190: PUSH
127191: LD_VAR 0 2
127195: NOT
127196: OR
127197: IFFALSE 127201
// exit ;
127199: GO 127730
// side := mc_sides [ base ] ;
127201: LD_ADDR_VAR 0 5
127205: PUSH
127206: LD_EXP 142
127210: PUSH
127211: LD_VAR 0 1
127215: ARRAY
127216: ST_TO_ADDR
// if not side then
127217: LD_VAR 0 5
127221: NOT
127222: IFFALSE 127226
// exit ;
127224: GO 127730
// for i in solds do
127226: LD_ADDR_VAR 0 6
127230: PUSH
127231: LD_VAR 0 2
127235: PUSH
127236: FOR_IN
127237: IFFALSE 127298
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
127239: LD_VAR 0 6
127243: PPUSH
127244: CALL_OW 310
127248: PPUSH
127249: CALL_OW 266
127253: PUSH
127254: LD_INT 32
127256: PUSH
127257: LD_INT 31
127259: PUSH
127260: EMPTY
127261: LIST
127262: LIST
127263: IN
127264: IFFALSE 127284
// solds := solds diff i else
127266: LD_ADDR_VAR 0 2
127270: PUSH
127271: LD_VAR 0 2
127275: PUSH
127276: LD_VAR 0 6
127280: DIFF
127281: ST_TO_ADDR
127282: GO 127296
// SetTag ( i , 18 ) ;
127284: LD_VAR 0 6
127288: PPUSH
127289: LD_INT 18
127291: PPUSH
127292: CALL_OW 109
127296: GO 127236
127298: POP
127299: POP
// if not solds then
127300: LD_VAR 0 2
127304: NOT
127305: IFFALSE 127309
// exit ;
127307: GO 127730
// repeat wait ( 0 0$2 ) ;
127309: LD_INT 70
127311: PPUSH
127312: CALL_OW 67
// enemy := mc_scan [ base ] ;
127316: LD_ADDR_VAR 0 4
127320: PUSH
127321: LD_EXP 139
127325: PUSH
127326: LD_VAR 0 1
127330: ARRAY
127331: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127332: LD_EXP 116
127336: PUSH
127337: LD_VAR 0 1
127341: ARRAY
127342: NOT
127343: PUSH
127344: LD_EXP 116
127348: PUSH
127349: LD_VAR 0 1
127353: ARRAY
127354: PUSH
127355: EMPTY
127356: EQUAL
127357: OR
127358: IFFALSE 127395
// begin for i in solds do
127360: LD_ADDR_VAR 0 6
127364: PUSH
127365: LD_VAR 0 2
127369: PUSH
127370: FOR_IN
127371: IFFALSE 127384
// ComStop ( i ) ;
127373: LD_VAR 0 6
127377: PPUSH
127378: CALL_OW 141
127382: GO 127370
127384: POP
127385: POP
// solds := [ ] ;
127386: LD_ADDR_VAR 0 2
127390: PUSH
127391: EMPTY
127392: ST_TO_ADDR
// exit ;
127393: GO 127730
// end ; for i in solds do
127395: LD_ADDR_VAR 0 6
127399: PUSH
127400: LD_VAR 0 2
127404: PUSH
127405: FOR_IN
127406: IFFALSE 127702
// begin if IsInUnit ( i ) then
127408: LD_VAR 0 6
127412: PPUSH
127413: CALL_OW 310
127417: IFFALSE 127428
// ComExitBuilding ( i ) ;
127419: LD_VAR 0 6
127423: PPUSH
127424: CALL_OW 122
// if GetLives ( i ) > 333 then
127428: LD_VAR 0 6
127432: PPUSH
127433: CALL_OW 256
127437: PUSH
127438: LD_INT 333
127440: GREATER
127441: IFFALSE 127469
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
127443: LD_VAR 0 6
127447: PPUSH
127448: LD_VAR 0 4
127452: PPUSH
127453: LD_VAR 0 6
127457: PPUSH
127458: CALL_OW 74
127462: PPUSH
127463: CALL_OW 115
127467: GO 127700
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
127469: LD_VAR 0 6
127473: PPUSH
127474: LD_EXP 116
127478: PUSH
127479: LD_VAR 0 1
127483: ARRAY
127484: PPUSH
127485: LD_INT 2
127487: PUSH
127488: LD_INT 30
127490: PUSH
127491: LD_INT 0
127493: PUSH
127494: EMPTY
127495: LIST
127496: LIST
127497: PUSH
127498: LD_INT 30
127500: PUSH
127501: LD_INT 1
127503: PUSH
127504: EMPTY
127505: LIST
127506: LIST
127507: PUSH
127508: LD_INT 30
127510: PUSH
127511: LD_INT 6
127513: PUSH
127514: EMPTY
127515: LIST
127516: LIST
127517: PUSH
127518: EMPTY
127519: LIST
127520: LIST
127521: LIST
127522: LIST
127523: PPUSH
127524: CALL_OW 72
127528: PPUSH
127529: LD_VAR 0 6
127533: PPUSH
127534: CALL_OW 74
127538: PPUSH
127539: CALL_OW 296
127543: PUSH
127544: LD_INT 10
127546: GREATER
127547: IFFALSE 127700
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
127549: LD_ADDR_VAR 0 7
127553: PUSH
127554: LD_EXP 116
127558: PUSH
127559: LD_VAR 0 1
127563: ARRAY
127564: PPUSH
127565: LD_INT 2
127567: PUSH
127568: LD_INT 30
127570: PUSH
127571: LD_INT 0
127573: PUSH
127574: EMPTY
127575: LIST
127576: LIST
127577: PUSH
127578: LD_INT 30
127580: PUSH
127581: LD_INT 1
127583: PUSH
127584: EMPTY
127585: LIST
127586: LIST
127587: PUSH
127588: LD_INT 30
127590: PUSH
127591: LD_INT 6
127593: PUSH
127594: EMPTY
127595: LIST
127596: LIST
127597: PUSH
127598: EMPTY
127599: LIST
127600: LIST
127601: LIST
127602: LIST
127603: PPUSH
127604: CALL_OW 72
127608: PPUSH
127609: LD_VAR 0 6
127613: PPUSH
127614: CALL_OW 74
127618: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
127619: LD_VAR 0 6
127623: PPUSH
127624: LD_VAR 0 7
127628: PPUSH
127629: CALL_OW 250
127633: PPUSH
127634: LD_INT 3
127636: PPUSH
127637: LD_INT 5
127639: PPUSH
127640: CALL_OW 272
127644: PPUSH
127645: LD_VAR 0 7
127649: PPUSH
127650: CALL_OW 251
127654: PPUSH
127655: LD_INT 3
127657: PPUSH
127658: LD_INT 5
127660: PPUSH
127661: CALL_OW 273
127665: PPUSH
127666: CALL_OW 111
// SetTag ( i , 0 ) ;
127670: LD_VAR 0 6
127674: PPUSH
127675: LD_INT 0
127677: PPUSH
127678: CALL_OW 109
// solds := solds diff i ;
127682: LD_ADDR_VAR 0 2
127686: PUSH
127687: LD_VAR 0 2
127691: PUSH
127692: LD_VAR 0 6
127696: DIFF
127697: ST_TO_ADDR
// continue ;
127698: GO 127405
// end ; end ;
127700: GO 127405
127702: POP
127703: POP
// until not solds or not enemy ;
127704: LD_VAR 0 2
127708: NOT
127709: PUSH
127710: LD_VAR 0 4
127714: NOT
127715: OR
127716: IFFALSE 127309
// MC_Reset ( base , 18 ) ;
127718: LD_VAR 0 1
127722: PPUSH
127723: LD_INT 18
127725: PPUSH
127726: CALL 39389 0 2
// end ;
127730: LD_VAR 0 3
127734: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
127735: LD_INT 0
127737: PPUSH
127738: PPUSH
127739: PPUSH
127740: PPUSH
127741: PPUSH
127742: PPUSH
127743: PPUSH
127744: PPUSH
127745: PPUSH
127746: PPUSH
127747: PPUSH
127748: PPUSH
127749: PPUSH
127750: PPUSH
127751: PPUSH
127752: PPUSH
127753: PPUSH
127754: PPUSH
127755: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
127756: LD_ADDR_VAR 0 12
127760: PUSH
127761: LD_EXP 116
127765: PUSH
127766: LD_VAR 0 1
127770: ARRAY
127771: PPUSH
127772: LD_INT 25
127774: PUSH
127775: LD_INT 3
127777: PUSH
127778: EMPTY
127779: LIST
127780: LIST
127781: PPUSH
127782: CALL_OW 72
127786: ST_TO_ADDR
// if mc_remote_driver [ base ] then
127787: LD_EXP 156
127791: PUSH
127792: LD_VAR 0 1
127796: ARRAY
127797: IFFALSE 127821
// mechs := mechs diff mc_remote_driver [ base ] ;
127799: LD_ADDR_VAR 0 12
127803: PUSH
127804: LD_VAR 0 12
127808: PUSH
127809: LD_EXP 156
127813: PUSH
127814: LD_VAR 0 1
127818: ARRAY
127819: DIFF
127820: ST_TO_ADDR
// for i in mechs do
127821: LD_ADDR_VAR 0 4
127825: PUSH
127826: LD_VAR 0 12
127830: PUSH
127831: FOR_IN
127832: IFFALSE 127867
// if GetTag ( i ) > 0 then
127834: LD_VAR 0 4
127838: PPUSH
127839: CALL_OW 110
127843: PUSH
127844: LD_INT 0
127846: GREATER
127847: IFFALSE 127865
// mechs := mechs diff i ;
127849: LD_ADDR_VAR 0 12
127853: PUSH
127854: LD_VAR 0 12
127858: PUSH
127859: LD_VAR 0 4
127863: DIFF
127864: ST_TO_ADDR
127865: GO 127831
127867: POP
127868: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
127869: LD_ADDR_VAR 0 8
127873: PUSH
127874: LD_EXP 116
127878: PUSH
127879: LD_VAR 0 1
127883: ARRAY
127884: PPUSH
127885: LD_INT 2
127887: PUSH
127888: LD_INT 25
127890: PUSH
127891: LD_INT 1
127893: PUSH
127894: EMPTY
127895: LIST
127896: LIST
127897: PUSH
127898: LD_INT 25
127900: PUSH
127901: LD_INT 5
127903: PUSH
127904: EMPTY
127905: LIST
127906: LIST
127907: PUSH
127908: LD_INT 25
127910: PUSH
127911: LD_INT 8
127913: PUSH
127914: EMPTY
127915: LIST
127916: LIST
127917: PUSH
127918: LD_INT 25
127920: PUSH
127921: LD_INT 9
127923: PUSH
127924: EMPTY
127925: LIST
127926: LIST
127927: PUSH
127928: EMPTY
127929: LIST
127930: LIST
127931: LIST
127932: LIST
127933: LIST
127934: PPUSH
127935: CALL_OW 72
127939: ST_TO_ADDR
// if not defenders and not solds then
127940: LD_VAR 0 2
127944: NOT
127945: PUSH
127946: LD_VAR 0 8
127950: NOT
127951: AND
127952: IFFALSE 127956
// exit ;
127954: GO 129726
// depot_under_attack := false ;
127956: LD_ADDR_VAR 0 16
127960: PUSH
127961: LD_INT 0
127963: ST_TO_ADDR
// sold_defenders := [ ] ;
127964: LD_ADDR_VAR 0 17
127968: PUSH
127969: EMPTY
127970: ST_TO_ADDR
// if mechs then
127971: LD_VAR 0 12
127975: IFFALSE 128128
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
127977: LD_ADDR_VAR 0 4
127981: PUSH
127982: LD_VAR 0 2
127986: PPUSH
127987: LD_INT 21
127989: PUSH
127990: LD_INT 2
127992: PUSH
127993: EMPTY
127994: LIST
127995: LIST
127996: PPUSH
127997: CALL_OW 72
128001: PUSH
128002: FOR_IN
128003: IFFALSE 128126
// begin if GetTag ( i ) <> 20 then
128005: LD_VAR 0 4
128009: PPUSH
128010: CALL_OW 110
128014: PUSH
128015: LD_INT 20
128017: NONEQUAL
128018: IFFALSE 128032
// SetTag ( i , 20 ) ;
128020: LD_VAR 0 4
128024: PPUSH
128025: LD_INT 20
128027: PPUSH
128028: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
128032: LD_VAR 0 4
128036: PPUSH
128037: CALL_OW 263
128041: PUSH
128042: LD_INT 1
128044: EQUAL
128045: PUSH
128046: LD_VAR 0 4
128050: PPUSH
128051: CALL_OW 311
128055: NOT
128056: AND
128057: IFFALSE 128124
// begin un := mechs [ 1 ] ;
128059: LD_ADDR_VAR 0 10
128063: PUSH
128064: LD_VAR 0 12
128068: PUSH
128069: LD_INT 1
128071: ARRAY
128072: ST_TO_ADDR
// ComExit ( un ) ;
128073: LD_VAR 0 10
128077: PPUSH
128078: CALL 102839 0 1
// AddComEnterUnit ( un , i ) ;
128082: LD_VAR 0 10
128086: PPUSH
128087: LD_VAR 0 4
128091: PPUSH
128092: CALL_OW 180
// SetTag ( un , 19 ) ;
128096: LD_VAR 0 10
128100: PPUSH
128101: LD_INT 19
128103: PPUSH
128104: CALL_OW 109
// mechs := mechs diff un ;
128108: LD_ADDR_VAR 0 12
128112: PUSH
128113: LD_VAR 0 12
128117: PUSH
128118: LD_VAR 0 10
128122: DIFF
128123: ST_TO_ADDR
// end ; end ;
128124: GO 128002
128126: POP
128127: POP
// if solds then
128128: LD_VAR 0 8
128132: IFFALSE 128191
// for i in solds do
128134: LD_ADDR_VAR 0 4
128138: PUSH
128139: LD_VAR 0 8
128143: PUSH
128144: FOR_IN
128145: IFFALSE 128189
// if not GetTag ( i ) then
128147: LD_VAR 0 4
128151: PPUSH
128152: CALL_OW 110
128156: NOT
128157: IFFALSE 128187
// begin defenders := defenders union i ;
128159: LD_ADDR_VAR 0 2
128163: PUSH
128164: LD_VAR 0 2
128168: PUSH
128169: LD_VAR 0 4
128173: UNION
128174: ST_TO_ADDR
// SetTag ( i , 18 ) ;
128175: LD_VAR 0 4
128179: PPUSH
128180: LD_INT 18
128182: PPUSH
128183: CALL_OW 109
// end ;
128187: GO 128144
128189: POP
128190: POP
// repeat wait ( 0 0$2 ) ;
128191: LD_INT 70
128193: PPUSH
128194: CALL_OW 67
// enemy := mc_scan [ base ] ;
128198: LD_ADDR_VAR 0 21
128202: PUSH
128203: LD_EXP 139
128207: PUSH
128208: LD_VAR 0 1
128212: ARRAY
128213: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128214: LD_EXP 116
128218: PUSH
128219: LD_VAR 0 1
128223: ARRAY
128224: NOT
128225: PUSH
128226: LD_EXP 116
128230: PUSH
128231: LD_VAR 0 1
128235: ARRAY
128236: PUSH
128237: EMPTY
128238: EQUAL
128239: OR
128240: IFFALSE 128277
// begin for i in defenders do
128242: LD_ADDR_VAR 0 4
128246: PUSH
128247: LD_VAR 0 2
128251: PUSH
128252: FOR_IN
128253: IFFALSE 128266
// ComStop ( i ) ;
128255: LD_VAR 0 4
128259: PPUSH
128260: CALL_OW 141
128264: GO 128252
128266: POP
128267: POP
// defenders := [ ] ;
128268: LD_ADDR_VAR 0 2
128272: PUSH
128273: EMPTY
128274: ST_TO_ADDR
// exit ;
128275: GO 129726
// end ; for i in defenders do
128277: LD_ADDR_VAR 0 4
128281: PUSH
128282: LD_VAR 0 2
128286: PUSH
128287: FOR_IN
128288: IFFALSE 129186
// begin e := NearestUnitToUnit ( enemy , i ) ;
128290: LD_ADDR_VAR 0 13
128294: PUSH
128295: LD_VAR 0 21
128299: PPUSH
128300: LD_VAR 0 4
128304: PPUSH
128305: CALL_OW 74
128309: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
128310: LD_ADDR_VAR 0 7
128314: PUSH
128315: LD_EXP 116
128319: PUSH
128320: LD_VAR 0 1
128324: ARRAY
128325: PPUSH
128326: LD_INT 2
128328: PUSH
128329: LD_INT 30
128331: PUSH
128332: LD_INT 0
128334: PUSH
128335: EMPTY
128336: LIST
128337: LIST
128338: PUSH
128339: LD_INT 30
128341: PUSH
128342: LD_INT 1
128344: PUSH
128345: EMPTY
128346: LIST
128347: LIST
128348: PUSH
128349: EMPTY
128350: LIST
128351: LIST
128352: LIST
128353: PPUSH
128354: CALL_OW 72
128358: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
128359: LD_ADDR_VAR 0 16
128363: PUSH
128364: LD_VAR 0 7
128368: NOT
128369: PUSH
128370: LD_VAR 0 7
128374: PPUSH
128375: LD_INT 3
128377: PUSH
128378: LD_INT 24
128380: PUSH
128381: LD_INT 600
128383: PUSH
128384: EMPTY
128385: LIST
128386: LIST
128387: PUSH
128388: EMPTY
128389: LIST
128390: LIST
128391: PPUSH
128392: CALL_OW 72
128396: OR
128397: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
128398: LD_VAR 0 4
128402: PPUSH
128403: CALL_OW 247
128407: PUSH
128408: LD_INT 2
128410: DOUBLE
128411: EQUAL
128412: IFTRUE 128416
128414: GO 128812
128416: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
128417: LD_VAR 0 4
128421: PPUSH
128422: CALL_OW 256
128426: PUSH
128427: LD_INT 1000
128429: EQUAL
128430: PUSH
128431: LD_VAR 0 4
128435: PPUSH
128436: LD_VAR 0 13
128440: PPUSH
128441: CALL_OW 296
128445: PUSH
128446: LD_INT 40
128448: LESS
128449: PUSH
128450: LD_VAR 0 13
128454: PPUSH
128455: LD_EXP 141
128459: PUSH
128460: LD_VAR 0 1
128464: ARRAY
128465: PPUSH
128466: CALL_OW 308
128470: OR
128471: AND
128472: IFFALSE 128594
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
128474: LD_VAR 0 4
128478: PPUSH
128479: CALL_OW 262
128483: PUSH
128484: LD_INT 1
128486: EQUAL
128487: PUSH
128488: LD_VAR 0 4
128492: PPUSH
128493: CALL_OW 261
128497: PUSH
128498: LD_INT 30
128500: LESS
128501: AND
128502: PUSH
128503: LD_VAR 0 7
128507: AND
128508: IFFALSE 128578
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
128510: LD_VAR 0 4
128514: PPUSH
128515: LD_VAR 0 7
128519: PPUSH
128520: LD_VAR 0 4
128524: PPUSH
128525: CALL_OW 74
128529: PPUSH
128530: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
128534: LD_VAR 0 4
128538: PPUSH
128539: LD_VAR 0 7
128543: PPUSH
128544: LD_VAR 0 4
128548: PPUSH
128549: CALL_OW 74
128553: PPUSH
128554: CALL_OW 296
128558: PUSH
128559: LD_INT 6
128561: LESS
128562: IFFALSE 128576
// SetFuel ( i , 100 ) ;
128564: LD_VAR 0 4
128568: PPUSH
128569: LD_INT 100
128571: PPUSH
128572: CALL_OW 240
// end else
128576: GO 128592
// ComAttackUnit ( i , e ) ;
128578: LD_VAR 0 4
128582: PPUSH
128583: LD_VAR 0 13
128587: PPUSH
128588: CALL_OW 115
// end else
128592: GO 128695
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
128594: LD_VAR 0 13
128598: PPUSH
128599: LD_EXP 141
128603: PUSH
128604: LD_VAR 0 1
128608: ARRAY
128609: PPUSH
128610: CALL_OW 308
128614: NOT
128615: PUSH
128616: LD_VAR 0 4
128620: PPUSH
128621: LD_VAR 0 13
128625: PPUSH
128626: CALL_OW 296
128630: PUSH
128631: LD_INT 40
128633: GREATEREQUAL
128634: AND
128635: PUSH
128636: LD_VAR 0 4
128640: PPUSH
128641: CALL_OW 256
128645: PUSH
128646: LD_INT 650
128648: LESSEQUAL
128649: OR
128650: PUSH
128651: LD_VAR 0 4
128655: PPUSH
128656: LD_EXP 140
128660: PUSH
128661: LD_VAR 0 1
128665: ARRAY
128666: PPUSH
128667: CALL_OW 308
128671: NOT
128672: AND
128673: IFFALSE 128695
// ComMoveToArea ( i , mc_parking [ base ] ) ;
128675: LD_VAR 0 4
128679: PPUSH
128680: LD_EXP 140
128684: PUSH
128685: LD_VAR 0 1
128689: ARRAY
128690: PPUSH
128691: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
128695: LD_VAR 0 4
128699: PPUSH
128700: CALL_OW 256
128704: PUSH
128705: LD_INT 1000
128707: LESS
128708: PUSH
128709: LD_VAR 0 4
128713: PPUSH
128714: CALL_OW 263
128718: PUSH
128719: LD_INT 1
128721: EQUAL
128722: AND
128723: PUSH
128724: LD_VAR 0 4
128728: PPUSH
128729: CALL_OW 311
128733: AND
128734: PUSH
128735: LD_VAR 0 4
128739: PPUSH
128740: LD_EXP 140
128744: PUSH
128745: LD_VAR 0 1
128749: ARRAY
128750: PPUSH
128751: CALL_OW 308
128755: AND
128756: IFFALSE 128810
// begin mech := IsDrivenBy ( i ) ;
128758: LD_ADDR_VAR 0 9
128762: PUSH
128763: LD_VAR 0 4
128767: PPUSH
128768: CALL_OW 311
128772: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
128773: LD_VAR 0 9
128777: PPUSH
128778: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
128782: LD_VAR 0 9
128786: PPUSH
128787: LD_VAR 0 4
128791: PPUSH
128792: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
128796: LD_VAR 0 9
128800: PPUSH
128801: LD_VAR 0 4
128805: PPUSH
128806: CALL_OW 180
// end ; end ; unit_human :
128810: GO 129157
128812: LD_INT 1
128814: DOUBLE
128815: EQUAL
128816: IFTRUE 128820
128818: GO 129156
128820: POP
// begin b := IsInUnit ( i ) ;
128821: LD_ADDR_VAR 0 18
128825: PUSH
128826: LD_VAR 0 4
128830: PPUSH
128831: CALL_OW 310
128835: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
128836: LD_ADDR_VAR 0 19
128840: PUSH
128841: LD_VAR 0 18
128845: NOT
128846: PUSH
128847: LD_VAR 0 18
128851: PPUSH
128852: CALL_OW 266
128856: PUSH
128857: LD_INT 32
128859: PUSH
128860: LD_INT 31
128862: PUSH
128863: EMPTY
128864: LIST
128865: LIST
128866: IN
128867: OR
128868: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
128869: LD_VAR 0 18
128873: PPUSH
128874: CALL_OW 266
128878: PUSH
128879: LD_INT 5
128881: EQUAL
128882: PUSH
128883: LD_VAR 0 4
128887: PPUSH
128888: CALL_OW 257
128892: PUSH
128893: LD_INT 1
128895: PUSH
128896: LD_INT 2
128898: PUSH
128899: LD_INT 3
128901: PUSH
128902: LD_INT 4
128904: PUSH
128905: EMPTY
128906: LIST
128907: LIST
128908: LIST
128909: LIST
128910: IN
128911: AND
128912: IFFALSE 128949
// begin class := AllowSpecClass ( i ) ;
128914: LD_ADDR_VAR 0 20
128918: PUSH
128919: LD_VAR 0 4
128923: PPUSH
128924: CALL 67500 0 1
128928: ST_TO_ADDR
// if class then
128929: LD_VAR 0 20
128933: IFFALSE 128949
// ComChangeProfession ( i , class ) ;
128935: LD_VAR 0 4
128939: PPUSH
128940: LD_VAR 0 20
128944: PPUSH
128945: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
128949: LD_VAR 0 16
128953: PUSH
128954: LD_VAR 0 2
128958: PPUSH
128959: LD_INT 21
128961: PUSH
128962: LD_INT 2
128964: PUSH
128965: EMPTY
128966: LIST
128967: LIST
128968: PPUSH
128969: CALL_OW 72
128973: PUSH
128974: LD_INT 1
128976: LESSEQUAL
128977: OR
128978: PUSH
128979: LD_VAR 0 19
128983: AND
128984: PUSH
128985: LD_VAR 0 4
128989: PUSH
128990: LD_VAR 0 17
128994: IN
128995: NOT
128996: AND
128997: IFFALSE 129090
// begin if b then
128999: LD_VAR 0 18
129003: IFFALSE 129052
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
129005: LD_VAR 0 18
129009: PPUSH
129010: LD_VAR 0 21
129014: PPUSH
129015: LD_VAR 0 18
129019: PPUSH
129020: CALL_OW 74
129024: PPUSH
129025: CALL_OW 296
129029: PUSH
129030: LD_INT 10
129032: LESS
129033: PUSH
129034: LD_VAR 0 18
129038: PPUSH
129039: CALL_OW 461
129043: PUSH
129044: LD_INT 7
129046: NONEQUAL
129047: AND
129048: IFFALSE 129052
// continue ;
129050: GO 128287
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
129052: LD_ADDR_VAR 0 17
129056: PUSH
129057: LD_VAR 0 17
129061: PPUSH
129062: LD_VAR 0 17
129066: PUSH
129067: LD_INT 1
129069: PLUS
129070: PPUSH
129071: LD_VAR 0 4
129075: PPUSH
129076: CALL_OW 1
129080: ST_TO_ADDR
// ComExitBuilding ( i ) ;
129081: LD_VAR 0 4
129085: PPUSH
129086: CALL_OW 122
// end ; if sold_defenders then
129090: LD_VAR 0 17
129094: IFFALSE 129154
// if i in sold_defenders then
129096: LD_VAR 0 4
129100: PUSH
129101: LD_VAR 0 17
129105: IN
129106: IFFALSE 129154
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
129108: LD_VAR 0 4
129112: PPUSH
129113: CALL_OW 314
129117: NOT
129118: PUSH
129119: LD_VAR 0 4
129123: PPUSH
129124: LD_VAR 0 13
129128: PPUSH
129129: CALL_OW 296
129133: PUSH
129134: LD_INT 30
129136: LESS
129137: AND
129138: IFFALSE 129154
// ComAttackUnit ( i , e ) ;
129140: LD_VAR 0 4
129144: PPUSH
129145: LD_VAR 0 13
129149: PPUSH
129150: CALL_OW 115
// end ; end ; end ;
129154: GO 129157
129156: POP
// if IsDead ( i ) then
129157: LD_VAR 0 4
129161: PPUSH
129162: CALL_OW 301
129166: IFFALSE 129184
// defenders := defenders diff i ;
129168: LD_ADDR_VAR 0 2
129172: PUSH
129173: LD_VAR 0 2
129177: PUSH
129178: LD_VAR 0 4
129182: DIFF
129183: ST_TO_ADDR
// end ;
129184: GO 128287
129186: POP
129187: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
129188: LD_VAR 0 21
129192: NOT
129193: PUSH
129194: LD_VAR 0 2
129198: NOT
129199: OR
129200: PUSH
129201: LD_EXP 116
129205: PUSH
129206: LD_VAR 0 1
129210: ARRAY
129211: NOT
129212: OR
129213: IFFALSE 128191
// MC_Reset ( base , 18 ) ;
129215: LD_VAR 0 1
129219: PPUSH
129220: LD_INT 18
129222: PPUSH
129223: CALL 39389 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
129227: LD_ADDR_VAR 0 2
129231: PUSH
129232: LD_VAR 0 2
129236: PUSH
129237: LD_VAR 0 2
129241: PPUSH
129242: LD_INT 2
129244: PUSH
129245: LD_INT 25
129247: PUSH
129248: LD_INT 1
129250: PUSH
129251: EMPTY
129252: LIST
129253: LIST
129254: PUSH
129255: LD_INT 25
129257: PUSH
129258: LD_INT 5
129260: PUSH
129261: EMPTY
129262: LIST
129263: LIST
129264: PUSH
129265: LD_INT 25
129267: PUSH
129268: LD_INT 8
129270: PUSH
129271: EMPTY
129272: LIST
129273: LIST
129274: PUSH
129275: LD_INT 25
129277: PUSH
129278: LD_INT 9
129280: PUSH
129281: EMPTY
129282: LIST
129283: LIST
129284: PUSH
129285: EMPTY
129286: LIST
129287: LIST
129288: LIST
129289: LIST
129290: LIST
129291: PPUSH
129292: CALL_OW 72
129296: DIFF
129297: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
129298: LD_VAR 0 21
129302: NOT
129303: PUSH
129304: LD_VAR 0 2
129308: PPUSH
129309: LD_INT 21
129311: PUSH
129312: LD_INT 2
129314: PUSH
129315: EMPTY
129316: LIST
129317: LIST
129318: PPUSH
129319: CALL_OW 72
129323: AND
129324: IFFALSE 129662
// begin tmp := FilterByTag ( defenders , 19 ) ;
129326: LD_ADDR_VAR 0 11
129330: PUSH
129331: LD_VAR 0 2
129335: PPUSH
129336: LD_INT 19
129338: PPUSH
129339: CALL 99969 0 2
129343: ST_TO_ADDR
// if tmp then
129344: LD_VAR 0 11
129348: IFFALSE 129418
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
129350: LD_ADDR_VAR 0 11
129354: PUSH
129355: LD_VAR 0 11
129359: PPUSH
129360: LD_INT 25
129362: PUSH
129363: LD_INT 3
129365: PUSH
129366: EMPTY
129367: LIST
129368: LIST
129369: PPUSH
129370: CALL_OW 72
129374: ST_TO_ADDR
// if tmp then
129375: LD_VAR 0 11
129379: IFFALSE 129418
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
129381: LD_ADDR_EXP 128
129385: PUSH
129386: LD_EXP 128
129390: PPUSH
129391: LD_VAR 0 1
129395: PPUSH
129396: LD_EXP 128
129400: PUSH
129401: LD_VAR 0 1
129405: ARRAY
129406: PUSH
129407: LD_VAR 0 11
129411: UNION
129412: PPUSH
129413: CALL_OW 1
129417: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
129418: LD_VAR 0 1
129422: PPUSH
129423: LD_INT 19
129425: PPUSH
129426: CALL 39389 0 2
// repeat wait ( 0 0$1 ) ;
129430: LD_INT 35
129432: PPUSH
129433: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
129437: LD_EXP 116
129441: PUSH
129442: LD_VAR 0 1
129446: ARRAY
129447: NOT
129448: PUSH
129449: LD_EXP 116
129453: PUSH
129454: LD_VAR 0 1
129458: ARRAY
129459: PUSH
129460: EMPTY
129461: EQUAL
129462: OR
129463: IFFALSE 129500
// begin for i in defenders do
129465: LD_ADDR_VAR 0 4
129469: PUSH
129470: LD_VAR 0 2
129474: PUSH
129475: FOR_IN
129476: IFFALSE 129489
// ComStop ( i ) ;
129478: LD_VAR 0 4
129482: PPUSH
129483: CALL_OW 141
129487: GO 129475
129489: POP
129490: POP
// defenders := [ ] ;
129491: LD_ADDR_VAR 0 2
129495: PUSH
129496: EMPTY
129497: ST_TO_ADDR
// exit ;
129498: GO 129726
// end ; for i in defenders do
129500: LD_ADDR_VAR 0 4
129504: PUSH
129505: LD_VAR 0 2
129509: PUSH
129510: FOR_IN
129511: IFFALSE 129600
// begin if not IsInArea ( i , mc_parking [ base ] ) then
129513: LD_VAR 0 4
129517: PPUSH
129518: LD_EXP 140
129522: PUSH
129523: LD_VAR 0 1
129527: ARRAY
129528: PPUSH
129529: CALL_OW 308
129533: NOT
129534: IFFALSE 129558
// ComMoveToArea ( i , mc_parking [ base ] ) else
129536: LD_VAR 0 4
129540: PPUSH
129541: LD_EXP 140
129545: PUSH
129546: LD_VAR 0 1
129550: ARRAY
129551: PPUSH
129552: CALL_OW 113
129556: GO 129598
// if GetControl ( i ) = control_manual then
129558: LD_VAR 0 4
129562: PPUSH
129563: CALL_OW 263
129567: PUSH
129568: LD_INT 1
129570: EQUAL
129571: IFFALSE 129598
// if IsDrivenBy ( i ) then
129573: LD_VAR 0 4
129577: PPUSH
129578: CALL_OW 311
129582: IFFALSE 129598
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
129584: LD_VAR 0 4
129588: PPUSH
129589: CALL_OW 311
129593: PPUSH
129594: CALL_OW 121
// end ;
129598: GO 129510
129600: POP
129601: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
129602: LD_VAR 0 2
129606: PPUSH
129607: LD_INT 95
129609: PUSH
129610: LD_EXP 140
129614: PUSH
129615: LD_VAR 0 1
129619: ARRAY
129620: PUSH
129621: EMPTY
129622: LIST
129623: LIST
129624: PPUSH
129625: CALL_OW 72
129629: PUSH
129630: LD_VAR 0 2
129634: EQUAL
129635: PUSH
129636: LD_EXP 139
129640: PUSH
129641: LD_VAR 0 1
129645: ARRAY
129646: OR
129647: PUSH
129648: LD_EXP 116
129652: PUSH
129653: LD_VAR 0 1
129657: ARRAY
129658: NOT
129659: OR
129660: IFFALSE 129430
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
129662: LD_ADDR_EXP 138
129666: PUSH
129667: LD_EXP 138
129671: PPUSH
129672: LD_VAR 0 1
129676: PPUSH
129677: LD_VAR 0 2
129681: PPUSH
129682: LD_INT 21
129684: PUSH
129685: LD_INT 2
129687: PUSH
129688: EMPTY
129689: LIST
129690: LIST
129691: PPUSH
129692: CALL_OW 72
129696: PPUSH
129697: CALL_OW 1
129701: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
129702: LD_VAR 0 1
129706: PPUSH
129707: LD_INT 19
129709: PPUSH
129710: CALL 39389 0 2
// MC_Reset ( base , 20 ) ;
129714: LD_VAR 0 1
129718: PPUSH
129719: LD_INT 20
129721: PPUSH
129722: CALL 39389 0 2
// end ; end_of_file
129726: LD_VAR 0 3
129730: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
129731: LD_VAR 0 1
129735: PUSH
129736: LD_INT 200
129738: DOUBLE
129739: GREATEREQUAL
129740: IFFALSE 129748
129742: LD_INT 299
129744: DOUBLE
129745: LESSEQUAL
129746: IFTRUE 129750
129748: GO 129782
129750: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
129751: LD_VAR 0 1
129755: PPUSH
129756: LD_VAR 0 2
129760: PPUSH
129761: LD_VAR 0 3
129765: PPUSH
129766: LD_VAR 0 4
129770: PPUSH
129771: LD_VAR 0 5
129775: PPUSH
129776: CALL 118573 0 5
129780: GO 129859
129782: LD_INT 300
129784: DOUBLE
129785: GREATEREQUAL
129786: IFFALSE 129794
129788: LD_INT 399
129790: DOUBLE
129791: LESSEQUAL
129792: IFTRUE 129796
129794: GO 129858
129796: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
129797: LD_VAR 0 1
129801: PPUSH
129802: LD_VAR 0 2
129806: PPUSH
129807: LD_VAR 0 3
129811: PPUSH
129812: LD_VAR 0 4
129816: PPUSH
129817: LD_VAR 0 5
129821: PPUSH
129822: LD_VAR 0 6
129826: PPUSH
129827: LD_VAR 0 7
129831: PPUSH
129832: LD_VAR 0 8
129836: PPUSH
129837: LD_VAR 0 9
129841: PPUSH
129842: LD_VAR 0 10
129846: PPUSH
129847: LD_VAR 0 11
129851: PPUSH
129852: CALL 116461 0 11
129856: GO 129859
129858: POP
// end ;
129859: PPOPN 11
129861: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
129862: LD_VAR 0 1
129866: PPUSH
129867: LD_VAR 0 2
129871: PPUSH
129872: LD_VAR 0 3
129876: PPUSH
129877: LD_VAR 0 4
129881: PPUSH
129882: LD_VAR 0 5
129886: PPUSH
129887: CALL 118555 0 5
// end ; end_of_file
129891: PPOPN 5
129893: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
129894: LD_VAR 0 1
129898: PPUSH
129899: LD_VAR 0 2
129903: PPUSH
129904: LD_VAR 0 3
129908: PPUSH
129909: LD_VAR 0 4
129913: PPUSH
129914: LD_VAR 0 5
129918: PPUSH
129919: LD_VAR 0 6
129923: PPUSH
129924: CALL 105269 0 6
// end ;
129928: PPOPN 6
129930: END
